--------------
void __fastcall png_set_sPLT(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_const_sPLT_tp entries,
        int nentries)
{
  png_const_sPLT_tp v4; // r6
  int v5; // r5
  bool v8; // zf
  char *v9; // r4
  int splt_palettes_num; // r1
  png_uint_32 free_me; // r0
  char *v12; // r11
  const char *name; // r0
  bool v14; // zf
  png_alloc_size_t v15; // r4
  png_voidp v16; // r0
  png_voidp v17; // r0
  __int64 v18; // kr00_8
  int v19; // r1
  const char *v20; // r1

  v4 = entries;
  v5 = nentries;
  if ( entries )
  {
    v8 = png_ptr == 0;
    if ( png_ptr )
      v8 = info_ptr == 0;
    if ( !v8 && nentries >= 1 )
    {
      v9 = j_png_realloc_array(png_ptr, info_ptr->splt_palettes, info_ptr->splt_palettes_num, nentries, 0x10u);
      if ( !v9 )
      {
        v20 = "too many sPLT chunks";
LABEL_22:
        sub_18A980(png_ptr, (png_const_charp)v20, 1);
        return;
      }
      j_png_free(png_ptr, info_ptr->splt_palettes);
      splt_palettes_num = info_ptr->splt_palettes_num;
      free_me = info_ptr->free_me;
      info_ptr->splt_palettes = (png_sPLT_tp)v9;
      v12 = &v9[16 * splt_palettes_num];
      info_ptr->free_me = free_me | 0x20;
      while ( 1 )
      {
        while ( 1 )
        {
          name = (const char *)v4->name;
          v14 = v4->name == 0;
          if ( v4->name )
            v14 = v4->entries == 0;
          if ( !v14 )
            break;
          j_png_app_error(png_ptr, (png_const_charp)"png_set_sPLT: invalid sPLT");
          if ( !--v5 )
            return;
        }
        v12[4] = v4->depth;
        v15 = strlen(name) + 1;
        v16 = j_png_malloc_base(png_ptr, v15);
        *(_DWORD *)v12 = v16;
        if ( !v16 )
          break;
        qmemcpy(v16, v4->name, v15);
        v17 = j_png_malloc_array(png_ptr, v4->nentries, 0xAu);
        *((_DWORD *)v12 + 2) = v17;
        if ( !v17 )
        {
          j_png_free(png_ptr, *(png_voidp *)v12);
          *(_DWORD *)v12 = 0;
          break;
        }
        v18 = *(_QWORD *)&v4->entries;
        *((_DWORD *)v12 + 3) = HIDWORD(v18);
        qmemcpy(v17, (const void *)v18, 10 * HIDWORD(v18));
        ++v4;
        v12 += 16;
        v19 = info_ptr->splt_palettes_num;
        info_ptr->valid |= 0x2000u;
        info_ptr->splt_palettes_num = v19 + 1;
        if ( !--v5 )
          return;
      }
      if ( v5 >= 1 )
      {
        v20 = "sPLT out of memory";
        goto LABEL_22;
      }
    }
  }
}

//----- (00202AA0) --------------------------------------------------------
void __fastcall png_set_unknown_chunks(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        png_const_unknown_chunkp unknowns,
        int num_unknowns)
{
  png_const_unknown_chunkp v4; // r6
  int v5; // r5
  bool v8; // zf
  png_unknown_chunk *v9; // r9
  png_unknown_chunk *v10; // r4
  int v11; // r0
  png_uint_32 v12; // r0
  png_uint_32 v13; // r1
  int v14; // r2
  png_alloc_size_t size; // r1
  png_byte *v16; // r0
  png_size_t v17; // r0

  v4 = unknowns;
  v5 = num_unknowns;
  if ( unknowns )
  {
    v8 = png_ptr == 0;
    if ( png_ptr )
      v8 = info_ptr == 0;
    if ( !v8 && num_unknowns >= 1 )
    {
      v9 = (png_unknown_chunk *)j_png_realloc_array(
                                  png_ptr,
                                  info_ptr->unknown_chunks,
                                  info_ptr->unknown_chunks_num,
                                  num_unknowns,
                                  0x14u);
      if ( v9 )
      {
        j_png_free(png_ptr, info_ptr->unknown_chunks);
        info_ptr->free_me |= 0x200u;
        info_ptr->unknown_chunks = v9;
        if ( v5 >= 1 )
        {
          v10 = &v9[info_ptr->unknown_chunks_num];
          do
          {
            v11 = *(_DWORD *)v4->name;
            v10->name[4] = 0;
            *(_DWORD *)v10->name = v11;
            v12 = v4->location & 0xB;
            if ( (v4->location & 0xB) == 0 )
            {
              if ( (png_ptr->mode & 0x8000) != 0
                || (j_png_app_warning(png_ptr, (png_const_charp)"png_set_unknown_chunks now expects a valid location"),
                    (v12 = png_ptr->mode & 0xB) == 0) )
              {
                j_png_error(png_ptr, (png_const_charp)"invalid location in png_set_unknown_chunks");
                JUMPOUT(0x202BB0);
              }
            }
            do
            {
              v13 = v12;
              v14 = v12 & -v12;
              v12 ^= v14;
            }
            while ( v13 != v14 );
            v10->location = v13;
            size = v4->size;
            if ( size )
            {
              v16 = (png_byte *)j_png_malloc_base(png_ptr, size);
              v10->data = v16;
              if ( !v16 )
              {
                j_png_chunk_report(png_ptr, (png_const_charp)"unknown chunk: out of memory", 1);
                goto LABEL_19;
              }
              qmemcpy(v16, v4->data, v4->size);
              v17 = v4->size;
            }
            else
            {
              v17 = 0;
              v10->data = 0;
            }
            v10->size = v17;
            ++v10;
            ++info_ptr->unknown_chunks_num;
LABEL_19:
            ++v4;
          }
          while ( v5-- > 1 );
        }
      }
      else
      {
        sub_18A980(png_ptr, (png_const_charp)"too many unknown chunks", 1);
      }
    }
  }
}
// 202BAC: control flows out of bounds to 202BB0

//----- (00202BF0) --------------------------------------------------------
void __fastcall png_set_unknown_chunk_location(
        png_const_structrp_5 png_ptr,
        png_inforp_5 info_ptr,
        int chunk,
        int location)
{
  bool v5; // zf
  char v7; // r4
  bool v9; // cc
  png_uint_32 v10; // r0
  bool v11; // nf
  char v12; // r4
  png_uint_32 v13; // r1
  int v14; // r2

  v5 = png_ptr == 0;
  v7 = location;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    v9 = chunk <= 0;
    if ( chunk >= 0 )
      v9 = info_ptr->unknown_chunks_num <= chunk;
    if ( !v9 )
    {
      if ( (location & 0xB) != 0 )
      {
        v10 = location & 0xB;
        if ( (location & 0xB) != 0 )
        {
          do
          {
LABEL_15:
            v13 = v10;
            v14 = v10 & -v10;
            v10 ^= v14;
          }
          while ( v13 != v14 );
          info_ptr->unknown_chunks[chunk].location = v13;
          return;
        }
      }
      else
      {
        j_png_app_error(png_ptr, (png_const_charp)"invalid unknown chunk location");
        v11 = (v7 & 4) != 0;
        v12 = 8;
        if ( !v11 )
          v12 = 1;
        v10 = v12 & 0xB;
        if ( (v12 & 0xB) != 0 )
          goto LABEL_15;
      }
      if ( (png_ptr->mode & 0x8000) != 0
        || (j_png_app_warning(png_ptr, (png_const_charp)"png_set_unknown_chunks now expects a valid location"),
            (v10 = png_ptr->mode & 0xB) == 0) )
      {
        j_png_error(png_ptr, (png_const_charp)"invalid location in png_set_unknown_chunks");
        JUMPOUT(0x202C88);
      }
      goto LABEL_15;
    }
  }
}
// 202C86: control flows out of bounds to 202C88

//----- (00202CB0) --------------------------------------------------------
png_uint_32 __fastcall png_permit_mng_features(png_structrp_7 png_ptr, png_uint_32 mng_features)
{
  png_uint_32 result; // r0

  if ( !png_ptr )
    return 0;
  result = mng_features & 5;
  png_ptr->mng_features_permitted = result;
  return result;
}

//----- (00202CC4) --------------------------------------------------------
void __fastcall png_set_keep_unknown_chunks(
        png_structrp_7 png_ptr,
        int keep,
        png_const_bytep chunk_list,
        int num_chunks_in)
{
  int v4; // r11
  const char *v6; // r1
  unsigned int num_chunk_list; // r9
  png_bytep v8; // r12
  const png_byte *v9; // r5
  png_structrp_7 v10; // r4
  png_byte *v11; // r0
  png_byte *v12; // r6
  png_byte *v13; // r10
  const png_byte *v14; // r1
  png_bytep v15; // r4
  unsigned int v16; // r5
  unsigned int v17; // r4
  png_bytep v18; // r1
  png_bytep v19; // r2
  int v20; // r3
  png_struct *v21; // r4
  png_struct *v22; // r4

  v4 = num_chunks_in;
  if ( !png_ptr )
    return;
  if ( (unsigned int)keep >= 4 )
  {
    v6 = "png_set_keep_unknown_chunks: invalid keep";
LABEL_13:
    sub_197D9C(png_ptr, (png_const_charp)v6);
    return;
  }
  if ( num_chunks_in <= 0 )
  {
    png_ptr->unknown_default = keep;
    if ( !num_chunks_in )
      return;
    v4 = 18;
    chunk_list = "bKGD";
  }
  else if ( !chunk_list )
  {
    v6 = "png_set_keep_unknown_chunks: no chunk list";
    goto LABEL_13;
  }
  v8 = png_ptr->chunk_list;
  num_chunk_list = png_ptr->num_chunk_list;
  if ( !v8 )
    num_chunk_list = 0;
  if ( num_chunk_list + v4 > 0x33333333 )
  {
    v6 = "png_set_keep_unknown_chunks: too many chunks";
    goto LABEL_13;
  }
  if ( keep )
  {
    v9 = chunk_list;
    v10 = png_ptr;
    v11 = (png_byte *)j_png_malloc(png_ptr, 5 * (num_chunk_list + v4));
    v8 = v11;
    if ( num_chunk_list )
    {
      v12 = v11;
      qmemcpy(v11, v10->chunk_list, 5 * num_chunk_list);
      v8 = v12;
    }
    png_ptr = v10;
    chunk_list = v9;
  }
  else if ( !num_chunk_list )
  {
    goto LABEL_39;
  }
  v13 = 0;
  if ( !v8 )
  {
LABEL_40:
    v17 = 0;
LABEL_41:
    v8 = png_ptr->chunk_list;
    goto LABEL_42;
  }
  do
  {
    v14 = &chunk_list[5 * (_DWORD)v13];
    v15 = v8;
    if ( num_chunk_list )
    {
      v16 = 0;
      v15 = v8;
      while ( *(_DWORD *)v15 != *(_DWORD *)v14 )
      {
        ++v16;
        v15 += 5;
        if ( v16 >= num_chunk_list )
          goto LABEL_24;
      }
    }
    else
    {
LABEL_24:
      if ( !keep )
        goto LABEL_27;
      ++num_chunk_list;
      *(_DWORD *)v15 = *(_DWORD *)v14;
    }
    v15[4] = keep;
LABEL_27:
    ++v13;
  }
  while ( v13 != (png_byte *)v4 );
  if ( num_chunk_list )
  {
    v17 = 0;
    v18 = v8;
    v19 = v8;
    do
    {
      if ( v19[4] )
      {
        ++v17;
        if ( v19 != v18 )
        {
          v20 = *(_DWORD *)v19;
          v18[4] = v19[4];
          *(_DWORD *)v18 = v20;
        }
        v18 += 5;
      }
      --num_chunk_list;
      v19 += 5;
    }
    while ( num_chunk_list );
    if ( v17 )
    {
      v13 = v8;
      goto LABEL_41;
    }
  }
  if ( png_ptr->chunk_list != v8 )
  {
    v21 = png_ptr;
    j_png_free(png_ptr, v8);
    png_ptr = v21;
LABEL_39:
    v13 = 0;
    goto LABEL_40;
  }
  v13 = 0;
  v17 = 0;
LABEL_42:
  png_ptr->num_chunk_list = v17;
  if ( v8 != v13 )
  {
    if ( v8 )
    {
      v22 = png_ptr;
      j_png_free(png_ptr, v8);
      png_ptr = v22;
    }
    png_ptr->chunk_list = v13;
  }
}

//----- (00202EB4) --------------------------------------------------------
void __fastcall png_set_read_user_chunk_fn(
        png_structrp_7 png_ptr,
        png_voidp user_chunk_ptr,
        png_user_chunk_ptr read_user_chunk_fn)
{
  if ( png_ptr )
  {
    png_ptr->user_chunk_ptr = user_chunk_ptr;
    png_ptr->read_user_chunk_fn = read_user_chunk_fn;
  }
}

//----- (00202EBE) --------------------------------------------------------
void __fastcall png_set_rows(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, png_bytepp row_pointers)
{
  bool v3; // zf
  png_bytepp v6; // r1
  bool v7; // zf

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = info_ptr == 0;
  if ( !v3 )
  {
    v6 = info_ptr->row_pointers;
    v7 = v6 == 0;
    if ( v6 )
      v7 = v6 == row_pointers;
    if ( !v7 )
      j_png_free_data(png_ptr, info_ptr, 0x40u, 0);
    info_ptr->row_pointers = row_pointers;
    if ( row_pointers )
      info_ptr->valid |= 0x8000u;
  }
}

//----- (00202EF8) --------------------------------------------------------
void __fastcall png_set_compression_buffer_size(png_structrp_7 png_ptr, png_size_t size)
{
  const char *v4; // r1

  if ( png_ptr )
  {
    if ( (int)size <= 0 )
    {
      j_png_error(png_ptr, (png_const_charp)"invalid compression buffer size");
      JUMPOUT(0x202F54);
    }
    if ( (png_ptr->mode & 0x8000) != 0 )
    {
      png_ptr->IDAT_read_size = size;
      return;
    }
    if ( png_ptr->zowner )
    {
      v4 = "Compression buffer size cannot be changed because it is in use";
LABEL_9:
      sub_194634(png_ptr, (png_const_charp)v4);
      return;
    }
    if ( size <= 5 )
    {
      v4 = "Compression buffer size cannot be reduced below 6";
      goto LABEL_9;
    }
    if ( png_ptr->zbuffer_size != size )
    {
      j_png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
      png_ptr->zbuffer_size = size;
    }
  }
}
// 202F52: control flows out of bounds to 202F54

//----- (00202FCC) --------------------------------------------------------
void __fastcall png_set_invalid(png_const_structrp_5 png_ptr, png_inforp_5 info_ptr, int mask)
{
  if ( png_ptr )
  {
    if ( info_ptr )
      info_ptr->valid &= ~mask;
  }
}

//----- (00202FDE) --------------------------------------------------------
void __fastcall png_set_user_limits(png_structrp_7 png_ptr, png_uint_32 user_width_max, png_uint_32 user_height_max)
{
  if ( png_ptr )
  {
    png_ptr->user_width_max = user_width_max;
    png_ptr->user_height_max = user_height_max;
  }
}

//----- (00202FE8) --------------------------------------------------------
void __fastcall png_set_chunk_cache_max(png_structrp_7 png_ptr, png_uint_32 user_chunk_cache_max)
{
  if ( png_ptr )
    png_ptr->user_chunk_cache_max = user_chunk_cache_max;
}

//----- (00202FF2) --------------------------------------------------------
void __fastcall png_set_chunk_malloc_max(png_structrp_7 png_ptr, png_alloc_size_t user_chunk_malloc_max)
{
  if ( png_ptr )
    png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
}

//----- (00202FFC) --------------------------------------------------------
void __fastcall png_set_benign_errors(png_structrp_7 png_ptr, int allowed)
{
  png_uint_32 flags; // r2
  png_uint_32 v3; // r3

  flags = png_ptr->flags;
  v3 = flags & 0xFF8FFFFF;
  if ( allowed )
    v3 = flags | 0x700000;
  png_ptr->flags = v3;
}

//----- (00203012) --------------------------------------------------------
void __fastcall png_set_check_for_invalid_index(png_structrp_7 png_ptr, int allowed)
{
  int v2; // r2

  v2 = 0;
  if ( allowed < 1 )
    v2 = -1;
  png_ptr->num_palette_max = v2;
}

//----- (00203024) --------------------------------------------------------
png_uint_32 __fastcall png_check_keyword(png_structrp_7 png_ptr, png_const_charp key, png_bytep new_key)
{
  png_int_32 v3; // r3
  bool v5; // zf
  png_uint_32 result; // r0
  png_int_32 v8; // r5
  int v9; // r8
  png_uint_32 v10; // r10
  png_const_charp v11; // r6
  const unsigned __int8 *v12; // r1
  png_byte v13; // r4
  bool v14; // zf
  unsigned __int8 v15[280]; // [sp+0h] [bp-118h] BYREF

  v5 = key == 0;
  if ( key )
  {
    v3 = *key;
    v5 = v3 == 0;
  }
  if ( v5 )
  {
    result = 0;
    *new_key = 0;
  }
  else
  {
    v8 = 0;
    v9 = 1;
    v10 = 0;
    v11 = key;
    do
    {
      v12 = v11 + 1;
      v13 = v3;
      while ( 1 )
      {
        v11 = v12;
        if ( v13 > 0xA0u || (unsigned __int8)(v13 - 33) <= 0x5Du )
        {
          v9 = 0;
          *new_key = v13;
          goto LABEL_18;
        }
        if ( !v9 )
          break;
        ++v12;
        v13 = *v11;
        if ( !v8 )
          v8 = v3;
        v3 = *v11;
        if ( !*v11 )
          goto LABEL_20;
      }
      *new_key = 32;
      if ( v13 != 32 )
        v8 = v3;
      v9 = 1;
LABEL_18:
      ++v10;
      ++new_key;
      if ( v10 > 0x4E )
        break;
      v3 = *v12;
    }
    while ( *v12 );
LABEL_20:
    v14 = v10 == 0;
    if ( v10 )
      v14 = v9 == 0;
    if ( !v14 )
    {
      --new_key;
      --v10;
      if ( !v8 )
        v8 = 32;
    }
    result = 0;
    *new_key = 0;
    if ( v10 )
    {
      if ( *v11 )
      {
        j_png_warning(png_ptr, (png_const_charp)"keyword truncated");
      }
      else if ( v8 )
      {
        j_png_warning_parameter((unsigned __int8 (*)[32])v15, 1, key);
        j_png_warning_parameter_signed((unsigned __int8 (*)[32])v15, 2, 4, v8);
        j_png_formatted_warning(
          png_ptr,
          (unsigned __int8 (*)[32])v15,
          (png_const_charp)"keyword \"@1\": bad character '0x@2'");
      }
      return v10;
    }
  }
  return result;
}
// 203058: variable 'v3' is possibly undefined

//----- (00203148) --------------------------------------------------------
void __fastcall png_set_bgr(png_structrp_8 png_ptr)
{
  if ( png_ptr )
    png_ptr->transformations |= 1u;
}

//----- (0020315A) --------------------------------------------------------
void __fastcall png_set_swap(png_structrp_8 png_ptr)
{
  if ( png_ptr )
  {
    if ( png_ptr->bit_depth == 16 )
      png_ptr->transformations |= 0x10u;
  }
}

//----- (00203176) --------------------------------------------------------
void __fastcall png_set_packing(png_structrp_8 png_ptr)
{
  png_uint_32 transformations; // r1

  if ( png_ptr )
  {
    if ( png_ptr->bit_depth <= 7u )
    {
      transformations = png_ptr->transformations;
      png_ptr->usr_bit_depth = 8;
      png_ptr->transformations = transformations | 4;
    }
  }
}

//----- (00203196) --------------------------------------------------------
void __fastcall png_set_packswap(png_structrp_8 png_ptr)
{
  if ( png_ptr )
  {
    if ( png_ptr->bit_depth <= 7u )
      png_ptr->transformations |= 0x10000u;
  }
}

//----- (002031B2) --------------------------------------------------------
void __fastcall png_set_shift(png_structrp_8 png_ptr, png_const_color_8p true_bits)
{
  png_byte alpha; // r2
  int v3; // r1

  if ( png_ptr )
  {
    png_ptr->transformations |= 8u;
    alpha = true_bits->alpha;
    v3 = *(_DWORD *)&true_bits->red;
    png_ptr->shift.alpha = alpha;
    *(_DWORD *)&png_ptr->shift.red = v3;
  }
}

//----- (002031D2) --------------------------------------------------------
int __fastcall png_set_interlace_handling(png_structrp_8 png_ptr)
{
  bool v1; // zf

  v1 = png_ptr == 0;
  if ( png_ptr )
    v1 = png_ptr->interlaced == 0;
  if ( v1 )
    return 1;
  png_ptr->transformations |= 2u;
  return 7;
}

//----- (002031F4) --------------------------------------------------------
void __fastcall png_set_filler(png_structrp_8 png_ptr, png_uint_32 filler, int filler_loc)
{
  png_byte v3; // r1
  __int64 v4; // kr00_8
  png_uint_32 v5; // r1
  const char *v6; // r1

  if ( !png_ptr )
    return;
  if ( (png_ptr->mode & 0x8000) == 0 )
  {
    if ( png_ptr->color_type != 2 )
    {
      if ( png_ptr->color_type )
      {
        v6 = "png_set_filler: inappropriate color type";
      }
      else
      {
        if ( png_ptr->bit_depth > 7u )
        {
          v3 = 2;
LABEL_9:
          png_ptr->usr_channels = v3;
          goto LABEL_10;
        }
        v6 = "png_set_filler is invalid for low bit depth gray output";
      }
      sub_197D9C(png_ptr, (png_const_charp)v6);
      return;
    }
    v3 = 4;
    goto LABEL_9;
  }
  png_ptr->filler = filler;
LABEL_10:
  v4 = *(_QWORD *)&png_ptr->flags;
  png_ptr->transformations = HIDWORD(v4) | 0x8000;
  if ( filler_loc == 1 )
    v5 = v4 | 0x80;
  else
    v5 = v4 & 0xFFFFFF7F;
  png_ptr->flags = v5;
}

//----- (0020325C) --------------------------------------------------------
void __fastcall png_set_add_alpha(png_structrp_8 png_ptr, png_uint_32 filler, int filler_loc)
{
  png_byte v4; // r0
  __int64 v5; // r0
  png_uint_32 v6; // r0
  const char *v7; // r1
  png_uint_32 transformations; // r0

  if ( png_ptr )
  {
    if ( (png_ptr->mode & 0x8000) != 0 )
    {
      png_ptr->filler = filler;
LABEL_10:
      v5 = *(_QWORD *)&png_ptr->flags;
      png_ptr->transformations = HIDWORD(v5) | 0x8000;
      if ( filler_loc == 1 )
        v6 = v5 | 0x80;
      else
        v6 = v5 & 0xFFFFFF7F;
      png_ptr->flags = v6;
      goto LABEL_17;
    }
    if ( png_ptr->color_type != 2 )
    {
      if ( png_ptr->color_type )
      {
        v7 = "png_set_filler: inappropriate color type";
      }
      else
      {
        if ( png_ptr->bit_depth > 7u )
        {
          v4 = 2;
LABEL_9:
          png_ptr->usr_channels = v4;
          goto LABEL_10;
        }
        v7 = "png_set_filler is invalid for low bit depth gray output";
      }
      j_png_app_error(png_ptr, (png_const_charp)v7);
LABEL_17:
      transformations = png_ptr->transformations;
      if ( (transformations & 0x8000) != 0 )
        png_ptr->transformations = transformations | 0x1000000;
      return;
    }
    v4 = 4;
    goto LABEL_9;
  }
}

//----- (002032DC) --------------------------------------------------------
void __fastcall png_set_swap_alpha(png_structrp_8 png_ptr)
{
  if ( png_ptr )
    png_ptr->transformations |= 0x20000u;
}

//----- (002032EE) --------------------------------------------------------
void __fastcall png_set_invert_alpha(png_structrp_8 png_ptr)
{
  if ( png_ptr )
    png_ptr->transformations |= 0x80000u;
}

//----- (00203300) --------------------------------------------------------
void __fastcall png_set_invert_mono(png_structrp_8 png_ptr)
{
  if ( png_ptr )
    png_ptr->transformations |= 0x20u;
}

//----- (00203312) --------------------------------------------------------
void __fastcall png_do_invert(png_row_infop row_info, png_bytep row)
{
  png_size_t v2; // r0
  unsigned int v3; // r12
  png_bytep v4; // r2
  unsigned int v5; // r3
  __int64 v6; // t2^8
  int bit_depth; // r2
  png_size_t v8; // r0
  png_size_t j; // r2
  png_size_t v10; // r0
  png_size_t rowbytes; // r12
  png_size_t i; // r2
  png_byte *v13; // r0
  png_byte v14; // lr

  if ( row_info->color_type == 4 )
  {
    bit_depth = row_info->bit_depth;
    if ( bit_depth == 16 )
    {
      rowbytes = row_info->rowbytes;
      if ( rowbytes )
      {
        for ( i = 0; i < rowbytes; i += 4 )
        {
          v13 = &row[i];
          v14 = row[i + 1];
          row[i] = ~row[i];
          v13[1] = ~v14;
        }
      }
    }
    else if ( bit_depth == 8 )
    {
      v8 = row_info->rowbytes;
      if ( v8 )
      {
        for ( j = 0; j < v8; j += 2 )
          row[j] = ~row[j];
      }
    }
  }
  else if ( !row_info->color_type )
  {
    v2 = row_info->rowbytes;
    if ( v2 )
    {
      if ( v2 >= 0x10 && (v3 = v2 & 0xFFFFFFF0, (v2 & 0xFFFFFFF0) != 0) )
      {
        v4 = &row[v3];
        v5 = v2 & 0xFFFFFFF0;
        do
        {
          v5 -= 16;
          v6 = ~*((_QWORD *)row + 1);
          *(_QWORD *)row = ~*(_QWORD *)row;
          *((_QWORD *)row + 1) = v6;
          row += 16;
        }
        while ( v5 );
        if ( v2 == v3 )
          return;
      }
      else
      {
        v3 = 0;
        v4 = row;
      }
      v10 = v2 - v3;
      do
      {
        --v10;
        *v4 = ~*v4;
        ++v4;
      }
      while ( v10 );
    }
  }
}

//----- (002033B0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_do_swap(png_row_infop row_info, png_bytep row)
{
  png_uint_32 v2; // r2
  png_uint_32 v3; // lr
  png_bytep v4; // r0
  png_uint_32 v5; // r3
  __int128 v6; // q10
  png_uint_32 v7; // r1
  png_byte v8; // r2
  int8x8x4_t v9; // 0:d16.8,8:d17.8,16:d18.8,24:d19.8 OVERLAPPED

  if ( row_info->bit_depth == 16 )
  {
    v2 = row_info->channels * row_info->width;
    if ( v2 )
    {
      if ( v2 < 0x10 || (v3 = v2 - (v2 & 0xF), v2 == (v2 & 0xF)) )
      {
        v3 = 0;
        v4 = row;
LABEL_10:
        v7 = v2 - v3;
        do
        {
          v8 = *v4;
          --v7;
          *v4 = v4[1];
          v4[1] = v8;
          v4 += 2;
        }
        while ( v7 );
        return;
      }
      v4 = &row[2 * v3];
      v5 = v2 - (v2 & 0xF);
      do
      {
        v9 = vld2q_s8((const char *)row);
        v5 -= 16;
        v6 = *(_OWORD *)v9.val[0].n64_u64;
        vst2q_s8((char *)row, *(int8x8x4_t *)((char *)&v9 + 16));
        row += 32;
      }
      while ( v5 );
      if ( (v2 & 0xF) != 0 )
        goto LABEL_10;
    }
  }
}
// 2033D7: failed to expand linear variable 0:d16.8,8:d17.8,16:d18.8,24:d19.8

//----- (0020340C) --------------------------------------------------------
void __fastcall png_do_packswap(png_row_infop row_info, png_bytep row)
{
  unsigned int bit_depth; // r2
  signed int rowbytes; // r0
  const png_byte *v4; // r2
  png_byte *v5; // r0

  bit_depth = row_info->bit_depth;
  if ( bit_depth <= 7 )
  {
    rowbytes = row_info->rowbytes;
    switch ( bit_depth )
    {
      case 1u:
        v4 = onebppswaptable;
        break;
      case 4u:
        v4 = fourbppswaptable;
        break;
      case 2u:
        v4 = twobppswaptable;
        break;
      default:
        return;
    }
    if ( rowbytes >= 1 )
    {
      v5 = &row[rowbytes];
      do
      {
        *row = v4[*row];
        ++row;
      }
      while ( row < v5 );
    }
  }
}

//----- (00203454) --------------------------------------------------------
void __fastcall png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
{
  png_size_t rowbytes; // r12
  int channels; // r4
  png_byte *v5; // r3
  int bit_depth; // r4
  png_bytep v7; // r4
  png_bytep v8; // lr
  unsigned int v9; // r12
  png_bytep v10; // r2
  png_byte v11; // t1
  png_byte v12; // r2
  int v13; // r4
  bool v14; // zf
  png_bytep v15; // r2
  png_bytep v16; // r4
  unsigned int v17; // r12
  png_byte v18; // r5
  png_byte v19; // r2
  png_bytep v20; // r4
  unsigned int v21; // r12
  png_bytep v22; // r2
  png_byte v23; // r5
  int color_type; // r3
  png_byte v25; // r2
  png_bytep v26; // r2
  unsigned int v27; // r12
  png_bytep v28; // r4
  png_byte v29; // r5
  int v30; // r3

  rowbytes = row_info->rowbytes;
  channels = row_info->channels;
  v5 = &row[rowbytes];
  if ( channels != 4 )
  {
    if ( channels != 2 )
      return;
    bit_depth = row_info->bit_depth;
    if ( bit_depth == 16 )
    {
      v20 = row + 2;
      v8 = row;
      if ( !at_start )
      {
        v8 = row + 2;
        v20 = row + 4;
      }
      if ( v20 < v5 )
      {
        v21 = (((unsigned int)&row[rowbytes - 1 - (_DWORD)v20] >> 1) & 0x7FFFFFFE) + 2;
        v22 = v8;
        do
        {
          *v22 = *v20;
          v23 = v20[1];
          v20 += 4;
          v22[1] = v23;
          v22 += 2;
        }
        while ( v20 < v5 );
        v8 += v21;
      }
      v12 = 16;
    }
    else
    {
      if ( bit_depth != 8 )
        return;
      v7 = row + 1;
      v8 = row;
      if ( !at_start )
      {
        v8 = row + 1;
        v7 = row + 2;
      }
      if ( v7 < v5 )
      {
        v9 = ((unsigned int)&row[rowbytes - 1 - (_DWORD)v7] >> 1) + 1;
        v10 = v8;
        do
        {
          v11 = *v7;
          v7 += 2;
          *v10++ = v11;
        }
        while ( v7 < v5 );
        v8 += v9;
      }
      v12 = 8;
    }
    row_info->channels = 1;
    color_type = row_info->color_type;
    row_info->pixel_depth = v12;
    if ( color_type != 4 )
      goto LABEL_40;
    v25 = 0;
    goto LABEL_39;
  }
  v13 = row_info->bit_depth;
  if ( v13 == 16 )
  {
    v14 = at_start == 0;
    v8 = row;
    v26 = row + 2;
    if ( v14 )
    {
      v8 = row + 6;
      v26 = row + 8;
    }
    if ( v26 < v5 )
    {
      v27 = 6 * ((unsigned int)&row[rowbytes - 1 - (_DWORD)v26] >> 3) + 6;
      v28 = v8;
      do
      {
        *v28 = *v26;
        v28[1] = v26[1];
        v28[2] = v26[2];
        v28[3] = v26[3];
        v28[4] = v26[4];
        v29 = v26[5];
        v26 += 8;
        v28[5] = v29;
        v28 += 6;
      }
      while ( v26 < v5 );
      v8 += v27;
    }
    v19 = 48;
  }
  else
  {
    if ( v13 != 8 )
      return;
    v14 = at_start == 0;
    v8 = row;
    v15 = row + 1;
    if ( v14 )
    {
      v8 = row + 3;
      v15 = row + 4;
    }
    if ( v15 < v5 )
    {
      v16 = v8;
      v17 = 3 * ((unsigned int)&row[rowbytes - 1 - (_DWORD)v15] >> 2) + 3;
      do
      {
        *v16 = *v15;
        v16[1] = v15[1];
        v18 = v15[2];
        v15 += 4;
        v16[2] = v18;
        v16 += 3;
      }
      while ( v15 < v5 );
      v8 += v17;
    }
    v19 = 24;
  }
  row_info->channels = 3;
  v30 = row_info->color_type;
  row_info->pixel_depth = v19;
  if ( v30 == 6 )
  {
    v25 = 2;
LABEL_39:
    row_info->color_type = v25;
  }
LABEL_40:
  row_info->rowbytes = v8 - row;
}

//----- (002035B4) --------------------------------------------------------
void __fastcall png_do_bgr(png_row_infop row_info, png_bytep row)
{
  int color_type; // r2
  int bit_depth; // r3
  png_uint_32 width; // r0
  png_byte v5; // r2
  png_byte v6; // lr
  png_byte v7; // r12
  png_byte v8; // r2
  png_byte v9; // r2
  png_byte v10; // lr
  png_byte v11; // r12
  png_byte v12; // r2

  color_type = row_info->color_type;
  if ( (color_type & 2) != 0 )
  {
    bit_depth = row_info->bit_depth;
    width = row_info->width;
    if ( bit_depth == 16 )
    {
      if ( color_type == 2 )
      {
        for ( ; width; row += 6 )
        {
          v10 = *row;
          --width;
          v11 = row[1];
          v12 = row[5];
          *row = row[4];
          row[4] = v10;
          row[1] = v12;
          row[5] = v11;
        }
      }
      else if ( color_type == 6 && width )
      {
        do
        {
          v6 = *row;
          --width;
          v7 = row[1];
          v8 = row[5];
          *row = row[4];
          row[4] = v6;
          row[1] = v8;
          row[5] = v7;
          row += 8;
        }
        while ( width );
      }
    }
    else if ( bit_depth == 8 )
    {
      if ( color_type == 2 )
      {
        for ( ; width; row += 3 )
        {
          v9 = *row;
          --width;
          *row = row[2];
          row[2] = v9;
        }
      }
      else if ( color_type == 6 && width )
      {
        do
        {
          v5 = *row;
          --width;
          *row = row[2];
          row[2] = v5;
          row += 4;
        }
        while ( width );
      }
    }
  }
}

//----- (00203650) --------------------------------------------------------
void __fastcall png_do_check_palette_indexes(png_structrp_8 png_ptr, png_row_infop row_info)
{
  int bit_depth; // r12
  int v3; // r3
  int pixel_depth; // r2
  png_size_t rowbytes; // r1
  __int64 v6; // kr00_8
  int v7; // lr
  png_bytep row_buf; // r12
  png_bytep v9; // r2
  char v10; // r4
  png_bytep v11; // r1
  int v13; // lr
  unsigned int v14; // r1
  int v15; // r3
  int num_palette_max; // lr
  unsigned int v17; // r1
  int v18; // r3
  int v19; // r3
  int v20; // r1
  int v21; // r3
  int v22; // r1
  int v23; // r1
  int v24; // r3
  int v25; // r3

  if ( png_ptr->num_palette )
  {
    bit_depth = row_info->bit_depth;
    if ( 1 << bit_depth > png_ptr->num_palette )
    {
      v3 = bit_depth - 1;
      pixel_depth = row_info->pixel_depth;
      v6 = *(_QWORD *)&row_info->width;
      rowbytes = row_info->rowbytes;
      v7 = v6 * -pixel_depth;
      row_buf = png_ptr->row_buf;
      v9 = &row_buf[rowbytes - 1];
      v10 = v7 & 7;
      switch ( v3 )
      {
        case 0:
          if ( v9 > row_buf )
          {
            if ( *v9 >> v10 )
              png_ptr->num_palette_max = 1;
            v11 = &row_buf[rowbytes - 2];
            if ( v9 - 1 > row_buf )
            {
              do
              {
                if ( *v11-- )
                  png_ptr->num_palette_max = 1;
              }
              while ( v11 > row_buf );
            }
          }
          return;
        case 1:
          if ( v9 <= row_buf )
            return;
          num_palette_max = png_ptr->num_palette_max;
          v17 = *v9 >> v10;
          if ( (unsigned __int8)(v17 & 3) > num_palette_max )
          {
            png_ptr->num_palette_max = v17 & 3;
            num_palette_max = v17 & 3;
          }
          v18 = (v17 >> 2) & 3;
          if ( v18 > num_palette_max )
          {
            png_ptr->num_palette_max = v18;
            num_palette_max = (v17 >> 2) & 3;
          }
          v19 = (v17 >> 4) & 3;
          if ( v19 <= num_palette_max )
          {
            do
            {
LABEL_35:
              v23 = v17 >> 6;
              if ( v23 > num_palette_max )
              {
                png_ptr->num_palette_max = v23;
                num_palette_max = v23;
              }
              if ( --v9 <= row_buf )
                return;
              v17 = *v9;
              v24 = v17 & 3;
              if ( num_palette_max < v24 )
              {
                png_ptr->num_palette_max = v24;
                v17 = *v9;
                num_palette_max = v24;
              }
              v25 = (v17 >> 2) & 3;
              if ( v25 > num_palette_max )
              {
                png_ptr->num_palette_max = v25;
                v17 = *v9;
                num_palette_max = v25;
              }
              v19 = (v17 >> 4) & 3;
            }
            while ( v19 <= num_palette_max );
            png_ptr->num_palette_max = v19;
            v17 = *v9;
          }
          else
          {
            png_ptr->num_palette_max = v19;
          }
          num_palette_max = v19;
          goto LABEL_35;
        case 3:
          if ( v9 <= row_buf )
            return;
          v13 = png_ptr->num_palette_max;
          v14 = *v9 >> v10;
          v15 = v14 & 0xF;
          if ( v15 <= v13 )
            goto LABEL_29;
          png_ptr->num_palette_max = v15;
LABEL_28:
          v13 = v15;
          while ( 1 )
          {
LABEL_29:
            v22 = v14 >> 4;
            if ( v22 > v13 )
            {
              png_ptr->num_palette_max = v22;
              v13 = v22;
            }
            if ( --v9 <= row_buf )
              return;
            v14 = *v9;
            v15 = v14 & 0xF;
            if ( v13 < v15 )
            {
              png_ptr->num_palette_max = v15;
              v14 = *v9;
              goto LABEL_28;
            }
          }
        case 7:
          if ( v9 > row_buf )
          {
            v20 = png_ptr->num_palette_max;
            do
            {
              v21 = *v9--;
              if ( v20 < v21 )
              {
                png_ptr->num_palette_max = v21;
                v20 = v21;
              }
            }
            while ( v9 > row_buf );
          }
          return;
        default:
          return;
      }
    }
  }
}

//----- (002037A4) --------------------------------------------------------
void __fastcall png_set_user_transform_info(
        png_structrp_8 png_ptr,
        png_voidp user_transform_ptr,
        int user_transform_depth,
        int user_transform_channels)
{
  bool v4; // nf

  if ( png_ptr )
  {
    v4 = (png_ptr->mode & 0x8000) != 0;
    if ( (png_ptr->mode & 0x8000) != 0 )
      v4 = (png_ptr->flags & 0x40) != 0;
    if ( v4 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"info change after png_start_read_image or png_read_update_info");
    }
    else
    {
      png_ptr->user_transform_depth = user_transform_depth;
      png_ptr->user_transform_ptr = user_transform_ptr;
      png_ptr->user_transform_channels = user_transform_channels;
    }
  }
}

//----- (00203814) --------------------------------------------------------
png_voidp __fastcall png_get_user_transform_ptr(png_const_structrp_6 png_ptr)
{
  if ( png_ptr )
    return png_ptr->user_transform_ptr;
  else
    return 0;
}

//----- (00203820) --------------------------------------------------------
png_uint_32 __fastcall png_get_current_row_number(png_const_structrp_6 png_ptr)
{
  if ( png_ptr )
    return png_ptr->row_number;
  else
    return -1;
}

//----- (0020382E) --------------------------------------------------------
png_byte __fastcall png_get_current_pass_number(png_const_structrp_6 png_ptr)
{
  if ( png_ptr )
    return png_ptr->pass;
  else
    return 8;
}

//----- (0020383C) --------------------------------------------------------
void __fastcall png_write_data(png_structrp_9 png_ptr, png_const_bytep data, png_size_t length)
{
  void (*write_data_fn)(void); // r3

  write_data_fn = (void (*)(void))png_ptr->write_data_fn;
  if ( !write_data_fn )
  {
    j_png_error(png_ptr, (png_const_charp)"Call to NULL write function");
    JUMPOUT(0x203850);
  }
  write_data_fn();
}
// 20384E: control flows out of bounds to 203850

//----- (0020386C) --------------------------------------------------------
void __fastcall png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
  if ( png_ptr && fwrite(data, 1u, length, (FILE *)png_ptr->io_ptr) != length )
  {
    j_png_error(png_ptr, (png_const_charp)"Write Error");
    JUMPOUT(0x203898);
  }
}
// 203896: control flows out of bounds to 203898

//----- (002038A4) --------------------------------------------------------
void __fastcall png_flush(png_structrp_9 png_ptr)
{
  void (*output_flush_fn)(void); // r1

  output_flush_fn = (void (*)(void))png_ptr->output_flush_fn;
  if ( output_flush_fn )
    output_flush_fn();
}

//----- (002038B0) --------------------------------------------------------
void __fastcall png_default_flush(png_structp png_ptr)
{
  if ( png_ptr )
    sub_19D590((FILE *)png_ptr->io_ptr);
}

//----- (002038C0) --------------------------------------------------------
void __fastcall png_set_write_fn(
        png_structrp_9 png_ptr,
        png_voidp io_ptr,
        png_rw_ptr write_data_fn,
        png_flush_ptr output_flush_fn)
{
  png_rw_ptr read_data_fn; // r1

  if ( png_ptr )
  {
    png_ptr->io_ptr = io_ptr;
    read_data_fn = png_ptr->read_data_fn;
    if ( !write_data_fn )
      write_data_fn = png_default_write_data;
    png_ptr->write_data_fn = write_data_fn;
    if ( !output_flush_fn )
      output_flush_fn = png_default_flush;
    png_ptr->output_flush_fn = output_flush_fn;
    if ( read_data_fn )
    {
      png_ptr->read_data_fn = 0;
      sub_194634(png_ptr, (png_const_charp)"Can't set both read_data_fn and write_data_fn in the same structure");
    }
  }
}

//----- (00203920) --------------------------------------------------------
void __fastcall png_write_info_before_PLTE(png_structrp_10 png_ptr, png_const_inforp_0 info_ptr)
{
  bool v3; // zf
  signed __int16 flags; // r0
  png_uint_32 v6; // r0
  __int64 v7; // [sp+8h] [bp-18h]

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = info_ptr == 0;
  if ( !v3 && (png_ptr->mode & 0x400) == 0 )
  {
    j_png_write_sig(png_ptr);
    if ( (png_ptr->mode & 0x1000) != 0 && png_ptr->mng_features_permitted )
    {
      j_png_warning(png_ptr, (png_const_charp)"MNG features are not allowed in a PNG datastream");
      png_ptr->mng_features_permitted = 0;
    }
    LODWORD(v7) = info_ptr->filter_type;
    HIDWORD(v7) = info_ptr->interlace_type;
    j_png_write_IHDR(
      png_ptr,
      info_ptr->width,
      info_ptr->height,
      info_ptr->bit_depth,
      info_ptr->color_type,
      info_ptr->compression_type,
      v7);
    flags = info_ptr->colorspace.flags;
    if ( (flags & 0x8008) == 8 && LOBYTE(info_ptr->valid) << 31 )
    {
      j_png_write_gAMA_fixed(png_ptr, info_ptr->colorspace.gamma);
      flags = info_ptr->colorspace.flags;
    }
    if ( flags >= 0 )
    {
      v6 = info_ptr->valid & 0x800;
      if ( (info_ptr->valid & 0x1000) != 0 )
      {
        if ( v6 )
          j_png_app_warning(png_ptr, (png_const_charp)"profile matches sRGB but writing iCCP instead");
        j_png_write_iCCP(png_ptr, info_ptr->iccp_name, info_ptr->iccp_profile);
      }
      else if ( v6 )
      {
        j_png_write_sRGB(png_ptr, info_ptr->colorspace.rendering_intent);
      }
    }
    if ( (info_ptr->valid & 2) != 0 )
      j_png_write_sBIT(png_ptr, &info_ptr->sig_bit, info_ptr->color_type);
    if ( (info_ptr->colorspace.flags & 0x8010) == 16 && (info_ptr->valid & 4) != 0 )
      j_png_write_cHRM_fixed(png_ptr, &info_ptr->colorspace.end_points_xy);
    write_unknown_chunks(png_ptr, info_ptr, 1u);
    png_ptr->mode |= 0x400u;
  }
}

//----- (00203A84) --------------------------------------------------------
void __fastcall write_unknown_chunks(png_structrp_10 png_ptr, png_const_inforp_0 info_ptr, unsigned int where)
{
  int unknown_chunks_num; // r0
  unsigned __int8 v5; // r4
  png_unknown_chunkp unknown_chunks; // r6
  png_unknown_chunk *v7; // r5
  int v8; // r0
  bool v9; // zf
  png_size_t size; // r3

  unknown_chunks_num = info_ptr->unknown_chunks_num;
  v5 = where;
  if ( unknown_chunks_num >= 1 )
  {
    unknown_chunks = info_ptr->unknown_chunks;
    v7 = &unknown_chunks[unknown_chunks_num];
    do
    {
      if ( (unknown_chunks->location & v5) != 0 )
      {
        v8 = j_png_handle_as_unknown(png_ptr, unknown_chunks->name);
        if ( v8 != 1 )
        {
          if ( v8 == 3 || (unknown_chunks->name[3] & 0x20) != 0 )
            goto LABEL_11;
          v9 = v8 == 0;
          if ( !v8 )
            v9 = png_ptr->unknown_default == 3;
          if ( v9 )
          {
LABEL_11:
            size = unknown_chunks->size;
            if ( !size )
            {
              j_png_warning(png_ptr, (png_const_charp)"Writing zero-length unknown chunk");
              size = unknown_chunks->size;
            }
            j_png_write_chunk(png_ptr, unknown_chunks->name, unknown_chunks->data, size);
          }
        }
      }
      ++unknown_chunks;
    }
    while ( unknown_chunks < v7 );
  }
}

//----- (00203B1C) --------------------------------------------------------
void __fastcall png_write_info(png_structrp_10 png_ptr, png_const_inforp_0 info_ptr)
{
  bool v3; // zf
  png_uint_32 valid; // r0
  int num_trans; // r0
  int i; // r1
  int v8; // r4
  int v9; // r6
  int v10; // r6
  int v11; // r4
  png_textp text; // r0
  int compression; // r1
  png_textp v14; // r0
  int v15; // r1

  v3 = png_ptr == 0;
  if ( png_ptr )
    v3 = info_ptr == 0;
  if ( !v3 )
  {
    j_png_write_info_before_PLTE(png_ptr, info_ptr);
    valid = info_ptr->valid;
    if ( (valid & 8) != 0 )
    {
      j_png_write_PLTE(png_ptr, info_ptr->palette, info_ptr->num_palette);
      valid = info_ptr->valid;
      if ( (valid & 0x10) == 0 )
        goto LABEL_7;
    }
    else
    {
      if ( info_ptr->color_type == 3 )
      {
        j_png_error(png_ptr, (png_const_charp)"Valid palette required for paletted images");
        JUMPOUT(0x203D8C);
      }
      if ( (valid & 0x10) == 0 )
      {
LABEL_7:
        if ( (valid & 0x20) == 0 )
          goto LABEL_8;
        goto LABEL_27;
      }
    }
    if ( (png_ptr->transformations & 0x80000) != 0 && info_ptr->color_type == 3 )
    {
      num_trans = info_ptr->num_trans;
      if ( (unsigned int)num_trans >= 0x100 )
        num_trans = 256;
      if ( num_trans >= 1 )
      {
        for ( i = 0; i < num_trans; ++i )
          info_ptr->trans_alpha[i] = ~info_ptr->trans_alpha[i];
      }
    }
    j_png_write_tRNS(png_ptr, info_ptr->trans_alpha, &info_ptr->trans_color, info_ptr->num_trans, info_ptr->color_type);
    valid = info_ptr->valid;
    if ( (valid & 0x20) == 0 )
    {
LABEL_8:
      if ( (valid & 0x10000) == 0 )
        goto LABEL_9;
      goto LABEL_28;
    }
LABEL_27:
    j_png_write_bKGD(png_ptr, &info_ptr->background, info_ptr->color_type);
    valid = info_ptr->valid;
    if ( (valid & 0x10000) == 0 )
    {
LABEL_9:
      if ( (valid & 0x40) == 0 )
        goto LABEL_10;
      goto LABEL_29;
    }
LABEL_28:
    j_png_write_eXIf(png_ptr, info_ptr->exif, info_ptr->num_exif);
    valid = info_ptr->valid;
    if ( (valid & 0x40) == 0 )
    {
LABEL_10:
      if ( (valid & 0x100) == 0 )
        goto LABEL_11;
      goto LABEL_30;
    }
LABEL_29:
    j_png_write_hIST(png_ptr, info_ptr->hist, info_ptr->num_palette);
    valid = info_ptr->valid;
    if ( (valid & 0x100) == 0 )
    {
LABEL_11:
      if ( (valid & 0x400) == 0 )
        goto LABEL_12;
      goto LABEL_31;
    }
LABEL_30:
    j_png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset, info_ptr->offset_unit_type);
    valid = info_ptr->valid;
    if ( (valid & 0x400) == 0 )
    {
LABEL_12:
      if ( (valid & 0x4000) == 0 )
        goto LABEL_13;
      goto LABEL_32;
    }
LABEL_31:
    j_png_write_pCAL(
      png_ptr,
      info_ptr->pcal_purpose,
      info_ptr->pcal_X0,
      info_ptr->pcal_X1,
      info_ptr->pcal_type,
      info_ptr->pcal_nparams,
      info_ptr->pcal_units,
      info_ptr->pcal_params);
    valid = info_ptr->valid;
    if ( (valid & 0x4000) == 0 )
    {
LABEL_13:
      if ( (valid & 0x80) == 0 )
        goto LABEL_14;
      goto LABEL_33;
    }
LABEL_32:
    j_png_write_sCAL_s(png_ptr, info_ptr->scal_unit, info_ptr->scal_s_width, info_ptr->scal_s_height);
    valid = info_ptr->valid;
    if ( (valid & 0x80) == 0 )
    {
LABEL_14:
      if ( (valid & 0x200) == 0 )
        goto LABEL_15;
      goto LABEL_34;
    }
LABEL_33:
    j_png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit, info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
    valid = info_ptr->valid;
    if ( (valid & 0x200) == 0 )
    {
LABEL_15:
      if ( (valid & 0x2000) == 0 )
        goto LABEL_38;
      goto LABEL_35;
    }
LABEL_34:
    j_png_write_tIME(png_ptr, &info_ptr->mod_time);
    png_ptr->mode |= 0x200u;
    if ( (info_ptr->valid & 0x2000) == 0 )
    {
LABEL_38:
      if ( info_ptr->num_text >= 1 )
      {
        v10 = 0;
        v11 = 0;
        do
        {
          text = info_ptr->text;
          compression = text[v10].compression;
          if ( compression < 1 )
          {
            if ( compression == -1 )
            {
              j_png_write_tEXt(png_ptr, text[v10].key, text[v10].text, 0);
              info_ptr->text[v10].compression = -3;
            }
            else if ( !compression )
            {
              j_png_write_zTXt(png_ptr, text[v10].key, text[v10].text, 0);
              info_ptr->text[v10].compression = -2;
            }
          }
          else
          {
            j_png_write_iTXt(png_ptr, compression, text[v10].key, text[v10].lang, text[v10].lang_key, text[v10].text);
            v14 = info_ptr->text;
            v15 = -2;
            if ( v14[v10].compression == -1 )
              v15 = -3;
            v14[v10].compression = v15;
          }
          ++v11;
          ++v10;
        }
        while ( v11 < info_ptr->num_text );
      }
      write_unknown_chunks(png_ptr, info_ptr, 2u);
      return;
    }
LABEL_35:
    if ( info_ptr->splt_palettes_num >= 1 )
    {
      v8 = 0;
      v9 = 0;
      do
      {
        j_png_write_sPLT(png_ptr, &info_ptr->splt_palettes[v8]);
        ++v9;
        ++v8;
      }
      while ( v9 < info_ptr->splt_palettes_num );
    }
    goto LABEL_38;
  }
}
// 203D88: control flows out of bounds to 203D8C

//----- (00203DB8) --------------------------------------------------------
void __fastcall png_write_end(png_structrp_10 png_ptr, png_inforp_6 info_ptr)
{
  int v4; // r6
  int v5; // r5
  png_textp text; // r0
  int compression; // r4
  png_textp v8; // r0
  int v9; // r1

  if ( png_ptr )
  {
    if ( (png_ptr->mode & 4) == 0 )
    {
      j_png_error(png_ptr, (png_const_charp)"No IDATs written into file");
      JUMPOUT(0x203EE0);
    }
    if ( png_ptr->num_palette_max > png_ptr->num_palette )
      j_png_benign_error(png_ptr, (png_const_charp)"Wrote palette index exceeding num_palette");
    if ( info_ptr )
    {
      if ( (info_ptr->valid & 0x200) != 0 && (png_ptr->mode & 0x200) == 0 )
        j_png_write_tIME(png_ptr, &info_ptr->mod_time);
      if ( info_ptr->num_text >= 1 )
      {
        v4 = 0;
        v5 = 0;
        do
        {
          text = info_ptr->text;
          compression = text[v4].compression;
          if ( compression < 1 )
          {
            if ( compression < 0 )
            {
              if ( compression == -1 )
              {
                j_png_write_tEXt(png_ptr, text[v4].key, text[v4].text, 0);
                info_ptr->text[v4].compression = -3;
              }
            }
            else
            {
              j_png_write_zTXt(png_ptr, text[v4].key, text[v4].text, text[v4].compression);
              info_ptr->text[v4].compression = -2;
            }
          }
          else
          {
            j_png_write_iTXt(png_ptr, compression, text[v4].key, text[v4].lang, text[v4].lang_key, text[v4].text);
            v8 = info_ptr->text;
            v9 = -2;
            if ( v8[v4].compression == -1 )
              v9 = -3;
            v8[v4].compression = v9;
          }
          ++v5;
          ++v4;
        }
        while ( v5 < info_ptr->num_text );
      }
      if ( BYTE2(info_ptr->valid) << 31 )
        j_png_write_eXIf(png_ptr, info_ptr->exif, info_ptr->num_exif);
      write_unknown_chunks(png_ptr, info_ptr, 8u);
    }
    png_ptr->mode |= 8u;
    sub_197170(png_ptr);
  }
}
// 203EDC: control flows out of bounds to 203EE0

//----- (00203F28) --------------------------------------------------------
void __fastcall png_convert_from_struct_tm(png_timep ptime, const tm *ttime)
{
  ptime->year = ttime->tm_year + 1900;
  ptime->month = ttime->tm_mon + 1;
  ptime->day = ttime->tm_mday;
  ptime->hour = ttime->tm_hour;
  ptime->minute = ttime->tm_min;
  ptime->second = ttime->tm_sec;
}

//----- (00203F48) --------------------------------------------------------
void __fastcall png_convert_from_time_t(png_timep ptime, time_t ttime)
{
  struct tm *v3; // r0
  time_t timer; // [sp+4h] [bp-Ch] BYREF

  timer = ttime;
  v3 = gmtime(&timer);
  ptime->year = v3->tm_year + 1900;
  ptime->month = v3->tm_mon + 1;
  ptime->day = v3->tm_mday;
  ptime->hour = v3->tm_hour;
  ptime->minute = v3->tm_min;
  ptime->second = v3->tm_sec;
}

//----- (00203F80) --------------------------------------------------------
png_structp __fastcall png_create_write_struct(
        png_const_charp user_png_ver,
        png_voidp error_ptr,
        png_error_ptr error_fn,
        png_error_ptr warn_fn)
{
  png_structp png_struct; // r0
  png_struct *v5; // r4
  png_uint_32 flags; // r1

  png_struct = j_png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, 0, 0, 0);
  v5 = png_struct;
  if ( png_struct )
  {
    flags = png_struct->flags;
    *(_QWORD *)&png_struct->zlib_mem_level = 0x100000008LL;
    *(_QWORD *)&png_struct->zlib_text_level = 0x8FFFFFFFFLL;
    *(_QWORD *)&png_struct->zbuffer_size = 0xFFFFFFFF00002000LL;
    *(_QWORD *)&png_struct->zlib_method = 0xF00000008LL;
    png_struct->zlib_text_window_bits = 15;
    png_struct->zlib_text_mem_level = 8;
    png_struct->zlib_text_strategy = 0;
    png_struct->flags = flags | 0x200000;
    j_png_set_write_fn(png_struct, 0, 0, 0);
  }
  return v5;
}

//----- (00204000) --------------------------------------------------------
png_structp __fastcall png_create_write_struct_2(
        png_const_charp user_png_ver,
        png_voidp error_ptr,
        png_error_ptr error_fn,
        png_error_ptr warn_fn,
        png_voidp mem_ptr,
        png_malloc_ptr malloc_fn,
        png_free_ptr free_fn)
{
  png_structp png_struct; // r0
  png_struct *v8; // r4
  png_uint_32 flags; // r2

  png_struct = j_png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);
  v8 = png_struct;
  if ( png_struct )
  {
    flags = png_struct->flags;
    *(_QWORD *)&png_struct->zlib_mem_level = 0x100000008LL;
    *(_QWORD *)&png_struct->zlib_text_level = 0x8FFFFFFFFLL;
    *(_QWORD *)&png_struct->zbuffer_size = 0xFFFFFFFF00002000LL;
    *(_QWORD *)&png_struct->zlib_method = 0xF00000008LL;
    png_struct->zlib_text_window_bits = 15;
    png_struct->zlib_text_mem_level = 8;
    png_struct->zlib_text_strategy = 0;
    png_struct->flags = flags | 0x200000;
    j_png_set_write_fn(png_struct, 0, 0, 0);
  }
  return v8;
}

//----- (00204090) --------------------------------------------------------
void __fastcall png_write_rows(png_structrp_10 png_ptr, png_bytepp row, png_uint_32 num_rows)
{
  bool v4; // zf
  png_uint_32 v5; // r4
  const png_byte *v7; // t1

  v4 = png_ptr == 0;
  v5 = num_rows;
  if ( png_ptr )
    v4 = num_rows == 0;
  if ( !v4 )
  {
    do
    {
      v7 = *row++;
      j_png_write_row(png_ptr, v7);
      --v5;
    }
    while ( v5 );
  }
}

//----- (002040BC) --------------------------------------------------------
void __fastcall png_write_row(png_structrp_10 png_ptr, png_const_bytep row)
{
  png_uint_32 row_number; // r0
  bool v5; // zf
  png_byte usr_channels; // r1
  png_byte usr_bit_depth; // r2
  png_uint_32 usr_width; // r0
  unsigned int v9; // r1
  unsigned int v10; // r2
  png_bytep row_buf; // r0
  unsigned int pass; // r2
  int pixel_depth; // r1
  bool v14; // zf
  int color_type; // r2
  png_bytep v16; // r1
  png_uint_32 width; // r0
  int v18; // r12
  int v19; // r12
  _BYTE *v20; // r1
  char v21; // r5
  char v22; // r2
  _BYTE *v23; // r1
  unsigned __int16 v24; // r2
  __int16 v25; // r3
  __int16 v26; // r2
  png_write_status_ptr write_row_fn; // r3
  png_row_info row_info; // [sp+4h] [bp-1Ch] BYREF

  if ( !png_ptr )
    return;
  row_number = png_ptr->row_number;
  v5 = row_number == 0;
  if ( !row_number )
    v5 = png_ptr->pass == 0;
  if ( v5 )
  {
    if ( (png_ptr->mode & 0x400) == 0 )
      goto LABEL_67;
    j_png_write_start_row(png_ptr);
  }
  if ( png_ptr->interlaced && (png_ptr->transformations & 2) != 0 )
  {
    switch ( png_ptr->pass )
    {
      case 0u:
        if ( !(LOBYTE(png_ptr->row_number) << 29) )
          break;
        goto LABEL_48;
      case 1u:
        if ( LOBYTE(png_ptr->row_number) << 29 || png_ptr->width <= 4 )
          goto LABEL_48;
        break;
      case 2u:
        if ( (png_ptr->row_number & 7) != 4 )
          goto LABEL_48;
        break;
      case 3u:
        if ( LOBYTE(png_ptr->row_number) << 30 || png_ptr->width <= 2 )
          goto LABEL_48;
        break;
      case 4u:
        if ( (png_ptr->row_number & 3) != 2 )
          goto LABEL_48;
        break;
      case 5u:
        if ( LOBYTE(png_ptr->row_number) << 31 || png_ptr->width <= 1 )
          goto LABEL_48;
        break;
      case 6u:
        if ( !(LOBYTE(png_ptr->row_number) << 31) )
          goto LABEL_48;
        break;
      default:
        break;
    }
  }
  usr_channels = png_ptr->usr_channels;
  usr_bit_depth = png_ptr->usr_bit_depth;
  row_info.color_type = png_ptr->color_type;
  usr_width = png_ptr->usr_width;
  row_info.width = usr_width;
  row_info.channels = usr_channels;
  row_info.bit_depth = usr_bit_depth;
  row_info.pixel_depth = usr_bit_depth * usr_channels;
  v9 = (unsigned __int8)(usr_bit_depth * usr_channels);
  if ( v9 < 8 )
    v10 = (usr_width * v9 + 7) >> 3;
  else
    v10 = (v9 >> 3) * usr_width;
  row_buf = png_ptr->row_buf;
  row_info.rowbytes = v10;
  qmemcpy(row_buf + 1, row, v10);
  if ( png_ptr->interlaced )
  {
    pass = png_ptr->pass;
    if ( pass <= 5 && (png_ptr->transformations & 2) != 0 )
    {
      j_png_do_write_interlace(&row_info, png_ptr->row_buf + 1, pass);
      if ( !row_info.width )
      {
LABEL_48:
        j_png_write_finish_row(png_ptr);
        return;
      }
    }
  }
  if ( png_ptr->transformations )
    j_png_do_write_transformations(png_ptr, &row_info);
  pixel_depth = png_ptr->pixel_depth;
  v14 = row_info.pixel_depth == pixel_depth;
  if ( row_info.pixel_depth == pixel_depth )
    v14 = row_info.pixel_depth == png_ptr->transformed_pixel_depth;
  if ( !v14 )
  {
    j_png_error(png_ptr, (png_const_charp)"internal write transform logic error");
LABEL_67:
    j_png_error(png_ptr, (png_const_charp)"png_write_info was never called before png_write_row");
    JUMPOUT(0x204340);
  }
  if ( (png_ptr->mng_features_permitted & 4) == 0 || png_ptr->filter_type != 64 )
    goto LABEL_60;
  color_type = row_info.color_type;
  if ( (row_info.color_type & 2) == 0 )
    goto LABEL_61;
  v16 = png_ptr->row_buf;
  width = row_info.width;
  if ( row_info.bit_depth == 16 )
  {
    if ( row_info.color_type == 2 )
    {
      v19 = 6;
      if ( !row_info.width )
        goto LABEL_60;
    }
    else
    {
      if ( row_info.color_type != 6 )
        goto LABEL_60;
      v19 = 8;
      if ( !row_info.width )
        goto LABEL_60;
    }
    v23 = v16 + 6;
    do
    {
      --width;
      v24 = _byteswap_ushort(*(_WORD *)(v23 - 3));
      v25 = _byteswap_ushort(*(_WORD *)(v23 - 5)) - v24;
      v26 = _byteswap_ushort(*(_WORD *)(v23 - 1)) - v24;
      *(v23 - 4) = v25;
      *v23 = v26;
      *(v23 - 5) = HIBYTE(v25);
      *(v23 - 1) = HIBYTE(v26);
      v23 += v19;
    }
    while ( width );
    goto LABEL_60;
  }
  if ( row_info.bit_depth == 8 )
  {
    if ( row_info.color_type != 2 )
    {
      if ( row_info.color_type != 6 )
        goto LABEL_60;
      v18 = 4;
      if ( !row_info.width )
        goto LABEL_60;
      goto LABEL_54;
    }
    v18 = 3;
    if ( row_info.width )
    {
LABEL_54:
      v20 = v16 + 1;
      do
      {
        --width;
        v21 = v20[1];
        v22 = v20[2];
        *v20 -= v21;
        v20[2] = v22 - v21;
        v20 += v18;
      }
      while ( width );
    }
  }
LABEL_60:
  color_type = row_info.color_type;
LABEL_61:
  if ( color_type == 3 && png_ptr->num_palette_max >= 0 )
    j_png_do_check_palette_indexes(png_ptr, &row_info);
  j_png_write_find_filter(png_ptr, &row_info);
  write_row_fn = png_ptr->write_row_fn;
  if ( write_row_fn )
    write_row_fn(png_ptr, png_ptr->row_number, png_ptr->pass);
}
// 20433E: control flows out of bounds to 204340

//----- (002043A0) --------------------------------------------------------
void __fastcall png_write_image(png_structrp_10 png_ptr, png_bytepp image)
{
  int v4; // r8
  png_uint_32 height; // r0
  int v6; // r9
  png_uint_32 i; // r6

  if ( png_ptr )
  {
    v4 = j_png_set_interlace_handling(png_ptr);
    if ( v4 >= 1 )
    {
      height = png_ptr->height;
      v6 = 0;
      do
      {
        if ( height )
        {
          for ( i = 0; i < height; ++i )
          {
            j_png_write_row(png_ptr, image[i]);
            height = png_ptr->height;
          }
        }
        else
        {
          height = 0;
        }
        ++v6;
      }
      while ( v6 != v4 );
    }
  }
}

//----- (002043EE) --------------------------------------------------------
void __fastcall png_set_flush(png_structrp_10 png_ptr, int nrows)
{
  if ( png_ptr )
  {
    if ( nrows <= 0 )
      nrows = 0;
    png_ptr->flush_dist = nrows;
  }
}

//----- (00204400) --------------------------------------------------------
void __fastcall png_write_flush(png_structrp_10 png_ptr)
{
  if ( png_ptr )
  {
    if ( png_ptr->row_number < png_ptr->num_rows )
    {
      j_png_compress_IDAT(png_ptr, 0, 0, 2);
      png_ptr->flush_rows = 0;
      sub_19C290(png_ptr);
    }
  }
}

//----- (00204436) --------------------------------------------------------
void __fastcall png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
{
  png_struct *v2; // r4
  bool v4; // zf
  png_bytep prev_row; // r1
  png_bytep chunk_list; // r1

  v4 = png_ptr_ptr == 0;
  if ( png_ptr_ptr )
  {
    v2 = *png_ptr_ptr;
    v4 = *png_ptr_ptr == 0;
  }
  if ( !v4 )
  {
    j_png_destroy_info_struct(v2, info_ptr_ptr);
    *png_ptr_ptr = 0;
    if ( (v2->flags & 2) != 0 )
      j_deflateEnd((z_streamp)&v2->zstream);
    j_png_free_buffer_list(v2, &v2->zbuffer_list);
    j_png_free(v2, v2->row_buf);
    prev_row = v2->prev_row;
    v2->row_buf = 0;
    j_png_free(v2, prev_row);
    j_png_free(v2, v2->try_row);
    j_png_free(v2, v2->tst_row);
    chunk_list = v2->chunk_list;
    v2->prev_row = 0;
    v2->try_row = 0;
    v2->tst_row = 0;
    j_png_free(v2, chunk_list);
    v2->chunk_list = 0;
    sub_19721C(v2);
  }
}
// 20444C: variable 'v2' is possibly undefined

//----- (002044C4) --------------------------------------------------------
void __fastcall png_set_filter(png_structrp_10 png_ptr, int method, int filters)
{
  unsigned int v4; // r5
  png_byte v5; // r0
  png_bytep row_buf; // r1
  png_uint_32 width; // r12
  unsigned int v8; // r3
  unsigned int v9; // r0
  unsigned int v10; // r6
  png_alloc_size_t v11; // r8

  v4 = filters;
  if ( png_ptr )
  {
    if ( method && ((method == 64) & ((unsigned __int8)(png_ptr->mng_features_permitted & 4) >> 2)) != 1 )
    {
      j_png_error(png_ptr, (png_const_charp)"Unknown custom filter method");
      JUMPOUT(0x2045DC);
    }
    v5 = 8;
    switch ( (char)filters )
    {
      case 0:
        break;
      case 1:
        v5 = 16;
        break;
      case 2:
        v5 = 32;
        break;
      case 3:
        v5 = 64;
        break;
      case 4:
        v5 = 0x80;
        break;
      case 5:
      case 6:
      case 7:
        j_png_app_error(png_ptr, (png_const_charp)"Unknown row filter for method 0");
        v5 = 8;
        break;
      default:
        v5 = filters;
        break;
    }
    row_buf = png_ptr->row_buf;
    png_ptr->do_filter = v5;
    if ( !row_buf )
      goto LABEL_28;
    width = png_ptr->width;
    if ( png_ptr->height == 1 )
      v4 &= 0xFFFFFF1F;
    if ( width == 1 )
      v4 &= 0xFFFFFF2F;
    if ( (v4 & 0xE0) != 0 && !png_ptr->prev_row )
    {
      j_png_app_warning(png_ptr, (png_const_charp)"png_set_filter: UP/AVG/PAETH cannot be added after start");
      width = png_ptr->width;
      v4 &= 0xFFFFFF1F;
    }
    v8 = png_ptr->usr_bit_depth * png_ptr->usr_channels;
    if ( v8 < 8 )
      v9 = (v8 * width + 7) >> 3;
    else
      v9 = (v8 >> 3) * width;
    v10 = ((v4 >> 4) & 1) + ((v4 >> 5) & 1) + ((v4 >> 6) & 1) + ((v4 >> 7) & 1);
    v11 = v9 + 1;
    if ( png_ptr->try_row )
    {
      if ( v10 < 2 )
        goto LABEL_28;
    }
    else
    {
      png_ptr->try_row = (png_bytep)j_png_malloc(png_ptr, v11);
      if ( v10 < 2 )
      {
LABEL_28:
        png_ptr->do_filter = v4;
        return;
      }
    }
    if ( !png_ptr->tst_row )
      png_ptr->tst_row = (png_bytep)j_png_malloc(png_ptr, v11);
    goto LABEL_28;
  }
}
// 2045D8: control flows out of bounds to 2045DC

//----- (0020465C) --------------------------------------------------------
void __fastcall png_set_compression_level(png_structrp_10 png_ptr, int level)
{
  if ( png_ptr )
    png_ptr->zlib_level = level;
}

//----- (00204666) --------------------------------------------------------
void __fastcall png_set_compression_mem_level(png_structrp_10 png_ptr, int mem_level)
{
  if ( png_ptr )
    png_ptr->zlib_mem_level = mem_level;
}

//----- (00204670) --------------------------------------------------------
void __fastcall png_set_compression_strategy(png_structrp_10 png_ptr, int strategy)
{
  png_uint_32 flags; // r2

  if ( png_ptr )
  {
    flags = png_ptr->flags;
    png_ptr->zlib_strategy = strategy;
    png_ptr->flags = flags | 1;
  }
}

//----- (00204688) --------------------------------------------------------
void __fastcall png_set_compression_window_bits(png_structrp_10 png_ptr, int window_bits)
{
  if ( png_ptr )
  {
    if ( window_bits < 16 )
    {
      if ( window_bits <= 7 )
      {
        j_png_warning(png_ptr, (png_const_charp)"Only compression windows >= 256 supported by PNG");
        window_bits = 8;
      }
      png_ptr->zlib_window_bits = window_bits;
    }
    else
    {
      j_png_warning(png_ptr, (png_const_charp)"Only compression windows <= 32k supported by PNG");
      png_ptr->zlib_window_bits = 15;
    }
  }
}

//----- (002046C8) --------------------------------------------------------
void __fastcall png_set_compression_method(png_structrp_10 png_ptr, int method)
{
  if ( png_ptr )
  {
    if ( method != 8 )
      j_png_warning(png_ptr, (png_const_charp)"Only compression method 8 is supported by PNG");
    png_ptr->zlib_method = method;
  }
}

//----- (002046F0) --------------------------------------------------------
void __fastcall png_set_text_compression_level(png_structrp_10 png_ptr, int level)
{
  if ( png_ptr )
    png_ptr->zlib_text_level = level;
}

//----- (002046FA) --------------------------------------------------------
void __fastcall png_set_text_compression_mem_level(png_structrp_10 png_ptr, int mem_level)
{
  if ( png_ptr )
    png_ptr->zlib_text_mem_level = mem_level;
}

//----- (00204704) --------------------------------------------------------
void __fastcall png_set_text_compression_strategy(png_structrp_10 png_ptr, int strategy)
{
  if ( png_ptr )
    png_ptr->zlib_text_strategy = strategy;
}

//----- (00204710) --------------------------------------------------------
void __fastcall png_set_text_compression_window_bits(png_structrp_10 png_ptr, int window_bits)
{
  if ( png_ptr )
  {
    if ( window_bits < 16 )
    {
      if ( window_bits <= 7 )
      {
        j_png_warning(png_ptr, (png_const_charp)"Only compression windows >= 256 supported by PNG");
        window_bits = 8;
      }
      png_ptr->zlib_text_window_bits = window_bits;
    }
    else
    {
      j_png_warning(png_ptr, (png_const_charp)"Only compression windows <= 32k supported by PNG");
      png_ptr->zlib_text_window_bits = 15;
    }
  }
}

//----- (00204750) --------------------------------------------------------
void __fastcall png_set_text_compression_method(png_structrp_10 png_ptr, int method)
{
  if ( png_ptr )
  {
    if ( method != 8 )
      j_png_warning(png_ptr, (png_const_charp)"Only compression method 8 is supported by PNG");
    png_ptr->zlib_text_method = method;
  }
}

//----- (00204778) --------------------------------------------------------
void __fastcall png_set_write_status_fn(png_structrp_10 png_ptr, png_write_status_ptr write_row_fn)
{
  if ( png_ptr )
    png_ptr->write_row_fn = write_row_fn;
}

//----- (00204782) --------------------------------------------------------
void __fastcall png_set_write_user_transform_fn(
        png_structrp_10 png_ptr,
        png_user_transform_ptr write_user_transform_fn)
{
  png_uint_32 transformations; // r2

  if ( png_ptr )
  {
    transformations = png_ptr->transformations;
    png_ptr->write_user_transform_fn = write_user_transform_fn;
    png_ptr->transformations = transformations | 0x100000;
  }
}

//----- (00204798) --------------------------------------------------------
void __fastcall png_write_png(png_structrp_10 png_ptr, png_inforp_6 info_ptr, int transforms, voidp params)
{
  bool v5; // zf
  __int16 v7; // r6
  bool v8; // nf
  png_struct *v9; // r0
  int v10; // r2
  png_bytepp row_pointers; // r5
  int v12; // r9
  png_uint_32 height; // r0
  int i; // r10
  png_uint_32 j; // r6

  v5 = png_ptr == 0;
  v7 = transforms;
  if ( png_ptr )
    v5 = info_ptr == 0;
  if ( !v5 )
  {
    if ( (info_ptr->valid & 0x8000) == 0 )
    {
      sub_197D9C(png_ptr, (png_const_charp)"no rows for png_write_image to write");
      return;
    }
    j_png_write_info(png_ptr, info_ptr);
    if ( (v7 & 0x20) != 0 )
      j_png_set_invert_mono(png_ptr);
    v8 = (v7 & 0x40) != 0;
    if ( (v7 & 0x40) != 0 )
      v8 = (info_ptr->valid & 2) != 0;
    if ( v8 )
      j_png_set_shift(png_ptr, &info_ptr->sig_bit);
    if ( (v7 & 4) != 0 )
      j_png_set_packing(png_ptr);
    if ( (v7 & 0x100) != 0 )
      j_png_set_swap_alpha(png_ptr);
    if ( (v7 & 0x1800) == 0 )
      goto LABEL_26;
    if ( (v7 & 0x1000) != 0 )
    {
      if ( (v7 & 0x800) != 0 )
        j_png_app_error(png_ptr, (png_const_charp)"PNG_TRANSFORM_STRIP_FILLER: BEFORE+AFTER not supported");
      v9 = png_ptr;
      v10 = 1;
    }
    else
    {
      if ( (v7 & 0x800) == 0 )
      {
LABEL_26:
        if ( (v7 & 0x80) != 0 )
          j_png_set_bgr(png_ptr);
        if ( (v7 & 0x200) != 0 )
          j_png_set_swap(png_ptr);
        if ( (v7 & 8) != 0 )
          j_png_set_packswap(png_ptr);
        if ( (v7 & 0x400) != 0 )
          j_png_set_invert_alpha(png_ptr);
        row_pointers = info_ptr->row_pointers;
        v12 = j_png_set_interlace_handling(png_ptr);
        if ( v12 >= 1 )
        {
          height = png_ptr->height;
          for ( i = 0; i != v12; ++i )
          {
            if ( height )
            {
              for ( j = 0; j < height; ++j )
              {
                j_png_write_row(png_ptr, row_pointers[j]);
                height = png_ptr->height;
              }
            }
            else
            {
              height = 0;
            }
          }
        }
        png_write_end(png_ptr, info_ptr);
        return;
      }
      v9 = png_ptr;
      v10 = 0;
    }
    j_png_set_filler(v9, 0, v10);
    goto LABEL_26;
  }
}

//----- (00204910) --------------------------------------------------------
int __fastcall png_image_write_to_memory(
        png_imagep image,
        void *memory,
        png_alloc_size_t *memory_bytes,
        int convert_to_8bit,
        const void *buffer,
        png_int_32 row_stride,
        const void *colormap)
{
  const void *v7; // r10
  bool v12; // zf
  int v13; // r5
  int v14; // r4
  const char *v16; // r1
  _DWORD arg[10]; // [sp+8h] [bp-48h] BYREF
  png_alloc_size_t v18; // [sp+30h] [bp-20h]

  if ( !image )
    return 0;
  if ( image->version == 1 )
  {
    v12 = memory_bytes == 0;
    if ( memory_bytes )
    {
      v7 = buffer;
      v12 = buffer == 0;
    }
    if ( !v12 )
    {
      if ( !memory )
        *memory_bytes = 0;
      v13 = 0;
      if ( png_image_write_init(image) )
      {
        arg[0] = image;
        arg[1] = v7;
        arg[2] = row_stride;
        arg[8] = memory;
        arg[3] = colormap;
        arg[4] = convert_to_8bit;
        memset(&arg[5], 0, 12);
        arg[9] = *memory_bytes;
        v18 = 0;
        v14 = j_png_safe_execute(image, png_image_write_memory, arg);
        j_png_image_free(image);
        if ( v14 )
        {
          if ( memory )
          {
            if ( v18 > *memory_bytes )
              v14 = 0;
          }
          v13 = v14;
          *memory_bytes = v18;
        }
      }
      return v13;
    }
    v16 = "png_image_write_to_memory: invalid argument";
  }
  else
  {
    v16 = "png_image_write_to_memory: incorrect PNG_IMAGE_VERSION";
  }
  return sub_18FD2C(image, (png_const_charp)v16);
}
// 20495E: variable 'v7' is possibly undefined

//----- (00204A30) --------------------------------------------------------
int __fastcall png_image_write_init(png_imagep image)
{
  png_structp png_struct; // r0
  png_struct *v3; // r5
  png_uint_32 flags; // r1
  png_info *info_struct; // r6
  png_control *v6; // r0
  int v7; // r1
  png_info *info_ptr_ptr; // [sp+10h] [bp-18h] BYREF
  png_struct *png_ptr_ptr; // [sp+14h] [bp-14h] BYREF

  png_struct = j_png_create_png_struct((png_const_charp)"1.6.34", image, png_safe_error, png_safe_warning, 0, 0, 0);
  v3 = png_struct;
  if ( !png_struct )
  {
    png_ptr_ptr = 0;
    return j_png_image_error(image, (png_const_charp)"png_image_write_: out of memory");
  }
  flags = png_struct->flags;
  *(_QWORD *)&png_struct->zlib_mem_level = 0x100000008LL;
  *(_QWORD *)&png_struct->zlib_text_level = 0x8FFFFFFFFLL;
  *(_QWORD *)&png_struct->zbuffer_size = 0xFFFFFFFF00002000LL;
  *(_QWORD *)&png_struct->zlib_method = 0xF00000008LL;
  png_struct->zlib_text_window_bits = 15;
  png_struct->zlib_text_mem_level = 8;
  png_struct->zlib_text_strategy = 0;
  png_struct->flags = flags | 0x200000;
  j_png_set_write_fn(png_struct, 0, 0, 0);
  png_ptr_ptr = v3;
  info_struct = j_png_create_info_struct(v3);
  info_ptr_ptr = info_struct;
  if ( !info_struct )
  {
LABEL_7:
    j_png_destroy_write_struct(&png_ptr_ptr, 0);
    return j_png_image_error(image, (png_const_charp)"png_image_write_: out of memory");
  }
  v6 = (png_control *)j_png_malloc_warn(v3, 0x18u);
  if ( !v6 )
  {
    j_png_destroy_info_struct(v3, &info_ptr_ptr);
    goto LABEL_7;
  }
  *(_QWORD *)&v6->error_buf = 0LL;
  *(_QWORD *)&v6->size = 0LL;
  v7 = 1;
  v6->png_ptr = v3;
  v6->info_ptr = info_struct;
  *((_BYTE *)v6 + 20) = 1;
  image->opaque = v6;
  return v7;
}

//----- (00204B50) --------------------------------------------------------
int __fastcall png_image_write_memory(png_voidp argument)
{
  j_png_set_write_fn(***(png_structrp_9 ***)argument, argument, image_memory_write, image_memory_flush);
  return png_image_write_main(argument);
}

//----- (00204B7C) --------------------------------------------------------
int __fastcall png_image_write_to_stdio(
        png_imagep image,
        FILE *file,
        int convert_to_8bit,
        const void *buffer,
        __int64 a5)
{
  bool v9; // zf
  int v10; // r6
  const char *v12; // r1
  _DWORD v13[2]; // [sp+0h] [bp-48h] BYREF
  __int64 v14; // [sp+8h] [bp-40h]
  int v15; // [sp+10h] [bp-38h]
  __int64 v16; // [sp+14h] [bp-34h]
  __int64 v17; // [sp+1Ch] [bp-2Ch]
  int v18; // [sp+24h] [bp-24h]
  int v19; // [sp+28h] [bp-20h]

  if ( !image )
    return 0;
  if ( image->version == 1 )
  {
    v9 = file == 0;
    if ( file )
      v9 = buffer == 0;
    if ( !v9 )
    {
      v10 = 0;
      if ( png_image_write_init(image) )
      {
        image->opaque->png_ptr->io_ptr = file;
        v16 = 0LL;
        v17 = 0LL;
        v18 = 0;
        v19 = 0;
        v13[0] = image;
        v13[1] = buffer;
        v14 = a5;
        v15 = convert_to_8bit;
        v10 = j_png_safe_execute(image, png_image_write_main, v13);
        j_png_image_free(image);
      }
      return v10;
    }
    v12 = "png_image_write_to_stdio: invalid argument";
  }
  else
  {
    v12 = "png_image_write_to_stdio: incorrect PNG_IMAGE_VERSION";
  }
  return sub_18FD2C(image, (png_const_charp)v12);
}

//----- (00204C70) --------------------------------------------------------
int __fastcall png_image_write_main(png_voidp argument)
{
  _DWORD *v1; // r10
  int v2; // r2
  int v3; // r1
  int v4; // r11
  unsigned int v5; // r3
  __int64 *v6; // r0
  int v7; // r6
  __int64 v8; // r8
  unsigned int v9; // r5
  unsigned int v10; // r4
  unsigned int v11; // r1
  int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r1
  png_uint_32 v15; // r3
  int v16; // r0
  bool v17; // zf
  int v18; // r0
  int v19; // r6
  int v20; // r6
  unsigned int v21; // r5
  __int64 v22; // kr00_8
  int v23; // r6
  unsigned int v24; // r4
  unsigned int v25; // r5
  int v26; // lr
  int v27; // r1
  _BOOL4 v28; // r0
  int v29; // r2
  int v30; // r12
  unsigned int v31; // r9
  bool v32; // zf
  unsigned int v33; // r1
  int v34; // r1
  int v35; // r2
  int v36; // r1
  int v37; // r0
  int v38; // r1
  int v39; // r2
  png_byte *p_green; // r8
  unsigned int v41; // r10
  int v42; // r11
  int v43; // r4
  int v44; // r5
  int v45; // r6
  int v46; // r0
  unsigned int v47; // r10
  unsigned int v48; // r0
  int v49; // r6
  unsigned int v50; // r9
  bool v51; // zf
  unsigned int v52; // r0
  int v53; // r3
  unsigned int v54; // r1
  unsigned int v55; // r2
  unsigned int v56; // r1
  unsigned __int16 *v57; // r0
  int v58; // r0
  unsigned int v59; // r0
  unsigned int v60; // r2
  unsigned int v61; // r0
  unsigned int v62; // r2
  unsigned int v63; // r1
  unsigned int v64; // r2
  unsigned int v65; // r0
  unsigned int v66; // r4
  __int64 v67; // r0
  int v68; // r0
  int v69; // r5
  png_alloc_size_t rowbytes; // r0
  png_voidp v71; // r6
  int (*v72)(png_voidp); // r1
  int v73; // r4
  int v74; // r4
  const png_byte *v75; // r5
  int v76; // r6
  int bit_depth; // [sp+0h] [bp-4E8h]
  int v79; // [sp+3Ch] [bp-4ACh]
  int v80; // [sp+40h] [bp-4A8h]
  int v81; // [sp+44h] [bp-4A4h]
  _DWORD *v82; // [sp+48h] [bp-4A0h]
  int v83; // [sp+54h] [bp-494h]
  int v84; // [sp+58h] [bp-490h]
  int v85; // [sp+5Ch] [bp-48Ch]
  int v86; // [sp+60h] [bp-488h]
  int v87; // [sp+74h] [bp-474h]
  int v88; // [sp+78h] [bp-470h]
  int v89; // [sp+7Ch] [bp-46Ch]
  int v90; // [sp+80h] [bp-468h]
  int v91; // [sp+84h] [bp-464h]
  unsigned __int8 v92; // [sp+88h] [bp-460h]
  int v93; // [sp+8Ch] [bp-45Ch]
  unsigned int v94; // [sp+90h] [bp-458h]
  int v95; // [sp+94h] [bp-454h]
  int v96; // [sp+98h] [bp-450h]
  int v97; // [sp+9Ch] [bp-44Ch]
  int v98; // [sp+A0h] [bp-448h]
  int v99; // [sp+A4h] [bp-444h]
  unsigned int v100; // [sp+A8h] [bp-440h]
  int v101; // [sp+ACh] [bp-43Ch]
  unsigned int v102; // [sp+B0h] [bp-438h]
  int v103; // [sp+B4h] [bp-434h]
  int v104; // [sp+B8h] [bp-430h]
  int v105; // [sp+BCh] [bp-42Ch]
  int v106; // [sp+C0h] [bp-428h]
  int v107; // [sp+C4h] [bp-424h]
  png_color palette[256]; // [sp+C8h] [bp-420h] BYREF
  png_byte trans_alpha[256]; // [sp+3C8h] [bp-120h] BYREF

  v1 = argument;
  v2 = 0;
  v3 = 0;
  v4 = *(_DWORD *)argument;
  v5 = *(_DWORD *)(*(_DWORD *)argument + 16);
  v6 = **(__int64 ***)argument;
  v7 = v5 & 8;
  if ( (v5 & 8) == 0 )
    v2 = 1;
  v8 = *v6;
  v92 = v2;
  v102 = v5;
  v91 = v2 & (v5 >> 2);
  if ( v91 && !v1[4] )
    v3 = 1;
  v93 = v3;
  j_png_set_benign_errors((png_structrp_7)v8, 0);
  v9 = 1;
  v10 = *(_DWORD *)(v4 + 8);
  if ( (*(_DWORD *)(v4 + 16) & 8) == 0 )
    v9 = (*(_DWORD *)(v4 + 16) & 3) + 1;
  if ( v10 > 0x7FFFFFFF / v9 )
  {
    j_png_error(**(png_const_structrp_0 **)v4, (png_const_charp)"image row stride too large");
LABEL_141:
    j_png_error(**(png_const_structrp_0 **)v4, (png_const_charp)"supplied row stride too small");
    goto LABEL_142;
  }
  v11 = v9 * v10;
  v12 = v1[2];
  if ( !v12 )
  {
    v1[2] = v11;
    v12 = v9 * v10;
  }
  if ( v12 < 0 )
    v12 = -v12;
  if ( v12 < v11 )
    goto LABEL_141;
  v13 = 0xFFFFFFFF / v11;
  v15 = *(_DWORD *)(v4 + 12);
  if ( v15 > v13 )
  {
LABEL_142:
    j_png_error(**(png_const_structrp_0 **)v4, (png_const_charp)"memory image too large");
    goto LABEL_143;
  }
  if ( v7 )
  {
    v16 = v1[3];
    v17 = v16 == 0;
    if ( v16 )
    {
      v14 = *(_DWORD *)(v4 + 24);
      v17 = v14 == 0;
    }
    if ( !v17 )
    {
      if ( v14 <= 0x10 )
      {
        if ( v14 <= 4 )
        {
          v18 = 1;
          if ( v14 > 2 )
            v18 = 2;
        }
        else
        {
          v18 = 4;
        }
      }
      else
      {
        v18 = 8;
      }
      v80 = v7;
      v81 = v4;
      v22 = v8;
      j_png_set_IHDR((png_const_structrp_5)v8, (png_inforp_5)HIDWORD(v8), *(_DWORD *)(v4 + 8), v15, v18, 3, 0, 0, 0);
      v82 = v1;
      v23 = v1[3];
      v24 = *(_DWORD *)(*v1 + 16);
      v79 = *v1;
      v25 = *(_DWORD *)(*v1 + 24);
      memset(trans_alpha, 255, sizeof(trans_alpha));
      memset(palette, 0, sizeof(palette));
      v26 = 256;
      v27 = v24 & 0x21;
      if ( v25 < 0x100 )
        v26 = v25;
      v28 = v27 == 33;
      v103 = v26;
      if ( v26 >= 1 )
      {
        v29 = v23;
        if ( v27 != 33 )
          v29 = v23 + 3;
        v90 = v29;
        v89 = ((2 * (v24 >> 3)) & 4) + v23;
        v30 = (v24 >> 3) & 2;
        v31 = v24 & 3;
        v88 = (v27 != 33) + v23;
        v32 = v27 == 33;
        v33 = v31;
        v87 = v23 + 2 * (v30 ^ 2);
        if ( v32 )
          v33 = 0;
        v99 = v23 + 2 * v33;
        v34 = 1;
        if ( v32 )
          v34 = 2;
        v35 = v23 + v34;
        v86 = v23 + 2 * v34;
        v85 = v23 + 2 * v28;
        v36 = v23 + v28;
        v37 = v28 | v30;
        v97 = v36;
        v96 = v23 + v37;
        v38 = v23 + 2 * v37;
        v37 ^= 2u;
        v84 = v38;
        v98 = v35;
        v39 = 2 * v31 + 2;
        p_green = &palette[0].green;
        v41 = v31 + 1;
        v83 = v23 + 2 * v37;
        v106 = ((_BYTE)v31 + 1) & 1;
        v107 = v24 & 4;
        v95 = v23 + v37;
        v42 = 0;
        v101 = v23;
        v43 = 0;
        v44 = 0;
        v45 = 0;
        v104 = v39;
        v100 = v31;
        v94 = v31 + 1;
        while ( v107 )
        {
          if ( !v106 )
          {
            v105 = v45;
            v47 = *(unsigned __int16 *)(v99 + v42);
            v48 = 255 * v47 + 32895;
            v49 = BYTE2(v48);
            v50 = HIWORD(v48);
            v51 = BYTE2(v48) == 0;
            v52 = 0;
            if ( !v51 )
              v51 = v49 == 255;
            if ( !v51 )
            {
              v52 = ((v47 >> 1) + 2139062400) / v47;
              v39 = v104;
              v26 = v103;
            }
            v17 = v49 == 255;
            v45 = v105;
            trans_alpha[v44] = v50;
            v53 = v39;
            if ( !v17 )
              v45 = v44 + 1;
            LOBYTE(v54) = -1;
            v31 = v100;
            if ( v100 < 2 )
            {
              if ( v47 >= 0x80 )
              {
                v60 = *(unsigned __int16 *)(v85 + v42);
                if ( v60 < v47 )
                {
                  if ( *(_WORD *)(v85 + v42) )
                  {
                    if ( v47 >= 0xFF7F )
                      v61 = 255 * v60;
                    else
                      v61 = (v52 * v60 + 64) >> 7;
                    v54 = (png_sRGB_base[v61 >> 15] + (((v61 & 0x7FFF) * png_sRGB_delta[v61 >> 15]) >> 12)) >> 8;
                  }
                  else
                  {
                    LOBYTE(v54) = 0;
                  }
                }
              }
              *(p_green - 1) = v54;
              *p_green = v54;
              p_green[1] = v54;
            }
            else
            {
              if ( v47 >= 0x80 )
              {
                v55 = *(unsigned __int16 *)(v83 + v42);
                if ( v55 < v47 )
                {
                  if ( *(_WORD *)(v83 + v42) )
                  {
                    if ( v47 >= 0xFF7F )
                      v56 = 255 * v55;
                    else
                      v56 = (v52 * v55 + 64) >> 7;
                    v53 = v104;
                    v54 = (png_sRGB_base[v56 >> 15] + (((v56 & 0x7FFF) * png_sRGB_delta[v56 >> 15]) >> 12)) >> 8;
                  }
                  else
                  {
                    LOBYTE(v54) = 0;
                  }
                }
              }
              p_green[1] = v54;
              LOBYTE(v54) = -1;
              if ( v47 >= 0x80 )
              {
                v62 = *(unsigned __int16 *)(v86 + v42);
                if ( v62 < v47 )
                {
                  if ( *(_WORD *)(v86 + v42) )
                  {
                    if ( v47 >= 0xFF7F )
                      v63 = 255 * v62;
                    else
                      v63 = (v52 * v62 + 64) >> 7;
                    v53 = v104;
                    v54 = (png_sRGB_base[v63 >> 15] + (((v63 & 0x7FFF) * png_sRGB_delta[v63 >> 15]) >> 12)) >> 8;
                  }
                  else
                  {
                    LOBYTE(v54) = 0;
                  }
                }
              }
              *p_green = v54;
              LOBYTE(v54) = -1;
              if ( v47 >= 0x80 )
              {
                v64 = *(unsigned __int16 *)(v84 + v42);
                if ( v64 < v47 )
                {
                  if ( *(_WORD *)(v84 + v42) )
                  {
                    if ( v47 >= 0xFF7F )
                      v65 = 255 * v64;
                    else
                      v65 = (v52 * v64 + 64) >> 7;
                    v54 = (png_sRGB_base[v65 >> 15] + (((v65 & 0x7FFF) * png_sRGB_delta[v65 >> 15]) >> 12)) >> 8;
                  }
                  else
                  {
                    LOBYTE(v54) = 0;
                  }
                }
              }
              *(p_green - 1) = v54;
            }
            v41 = v94;
            v39 = v53;
            goto LABEL_98;
          }
          v57 = (unsigned __int16 *)(v101 + v42);
          if ( v31 < 2 )
          {
            v59 = (png_sRGB_base[(255 * (unsigned int)*v57) >> 15]
                 + ((((255 * *v57) & 0x7FFF) * (unsigned int)png_sRGB_delta[(255 * (unsigned int)*v57) >> 15]) >> 12)) >> 8;
LABEL_72:
            *(p_green - 1) = v59;
            *p_green = v59;
            p_green[1] = v59;
            goto LABEL_98;
          }
          p_green[1] = (unsigned __int16)(png_sRGB_base[(255 * (unsigned int)*(unsigned __int16 *)(v87 + v42)) >> 15]
                                        + ((((255 * *(_WORD *)(v87 + v42)) & 0x7FFF)
                                          * (unsigned int)png_sRGB_delta[(255
                                                                        * (unsigned int)*(unsigned __int16 *)(v87 + v42)) >> 15]) >> 12)) >> 8;
          *p_green = (unsigned __int16)(png_sRGB_base[(255 * (unsigned int)v57[1]) >> 15]
                                      + ((((255 * v57[1]) & 0x7FFF)
                                        * (unsigned int)png_sRGB_delta[(255 * (unsigned int)v57[1]) >> 15]) >> 12)) >> 8;
          v26 = v103;
          v39 = v104;
          *(p_green - 1) = (unsigned __int16)(png_sRGB_base[(255 * (unsigned int)*(unsigned __int16 *)(v89 + v42)) >> 15]
                                            + ((((255 * *(_WORD *)(v89 + v42)) & 0x7FFF)
                                              * (unsigned int)png_sRGB_delta[(255
                                                                            * (unsigned int)*(unsigned __int16 *)(v89 + v42)) >> 15]) >> 12)) >> 8;
LABEL_98:
          ++v44;
          v42 += v39;
          v43 += v41;
          p_green += 3;
          if ( v44 >= v26 )
            goto LABEL_101;
        }
        if ( v31 )
        {
          if ( v31 != 1 )
          {
            if ( v31 != 2 )
            {
              v46 = *(unsigned __int8 *)(v90 + v43);
              trans_alpha[v44] = v46;
              if ( v46 != 255 )
                v45 = v44 + 1;
            }
            p_green[1] = *(_BYTE *)(v95 + v43);
            *p_green = *(_BYTE *)(v98 + v43);
            *(p_green - 1) = *(_BYTE *)(v96 + v43);
            goto LABEL_98;
          }
          v58 = *(unsigned __int8 *)(v88 + v43);
          trans_alpha[v44] = v58;
          if ( v58 != 255 )
            v45 = v44 + 1;
        }
        LOBYTE(v59) = *(_BYTE *)(v97 + v43);
        goto LABEL_72;
      }
      v45 = 0;
LABEL_101:
      j_png_set_PLTE(**(png_structrp_7 **)v79, *(png_inforp_5 *)(*(_DWORD *)v79 + 4), palette, v26);
      if ( v45 >= 1 )
        j_png_set_tRNS(**(png_structrp_7 **)v79, *(png_inforp_5 *)(*(_DWORD *)v79 + 4), trans_alpha, v45, 0);
      *(_DWORD *)(v79 + 24) = v103;
      v8 = v22;
      v1 = v82;
      v20 = v80;
      v4 = v81;
      if ( v93 != 1 )
        goto LABEL_104;
      goto LABEL_24;
    }
LABEL_143:
    j_png_error(**(png_const_structrp_0 **)v4, (png_const_charp)"no color-map for color-mapped image");
    JUMPOUT(0x205448);
  }
  v19 = 8;
  if ( v93 )
    v19 = 16;
  bit_depth = v19;
  v20 = 0;
  j_png_set_IHDR(
    (png_const_structrp_5)v8,
    (png_inforp_5)HIDWORD(v8),
    *(_DWORD *)(v4 + 8),
    v15,
    bit_depth,
    v102 & 2 | (4 * (v102 & 1)),
    0,
    0,
    0);
  if ( v93 != 1 )
  {
LABEL_104:
    v21 = v102;
    if ( *(unsigned __int8 *)(v4 + 20) << 31 )
      j_png_set_gAMA_fixed((png_const_structrp_5)v8, (png_inforp_5)HIDWORD(v8), 45455);
    else
      j_png_set_sRGB((png_const_structrp_5)v8, (png_inforp_5)HIDWORD(v8), 0);
    j_png_write_info((png_structrp_10)v8, (png_const_inforp_0)HIDWORD(v8));
    goto LABEL_108;
  }
LABEL_24:
  j_png_set_gAMA_fixed((png_const_structrp_5)v8, (png_inforp_5)HIDWORD(v8), (png_fixed_point)&elf_hash_chain[8526]);
  if ( !(*(unsigned __int8 *)(v4 + 20) << 31) )
    j_png_set_cHRM_fixed(
      (png_const_structrp_5)v8,
      (png_inforp_5)HIDWORD(v8),
      31270,
      32900,
      0x80E80000FA00LL,
      30000,
      60000,
      15000,
      6000);
  j_png_write_info((png_structrp_10)v8, (png_const_inforp_0)HIDWORD(v8));
  j_png_set_swap((png_structrp_8)v8);
  v21 = v102;
LABEL_108:
  v66 = v21;
  if ( (v21 & 0x10) != 0 )
  {
    if ( (v21 & 0xA) == 2 )
      j_png_set_bgr((png_structrp_8)v8);
    v66 = v21 & 0xFFFFFFEF;
    if ( (v21 & 0x20) == 0 )
    {
LABEL_110:
      if ( !v20 )
        goto LABEL_111;
      goto LABEL_131;
    }
  }
  else if ( (v21 & 0x20) == 0 )
  {
    goto LABEL_110;
  }
  if ( !v20 && (v66 & 1) != 0 )
    j_png_set_swap_alpha((png_structrp_8)v8);
  v66 &= ~0x20u;
  if ( !v20 )
  {
LABEL_111:
    if ( v66 < 0x10 )
      goto LABEL_112;
LABEL_134:
    j_png_error((png_const_structrp_0)v8, (png_const_charp)"png_write_image: unsupported transformation");
LABEL_135:
    v74 = *(_DWORD *)(v4 + 12);
    if ( v74 )
    {
      v76 = v1[6];
      v75 = (const png_byte *)v1[5];
      do
      {
        j_png_write_row((png_structrp_10)v8, v75);
        v75 += v76;
        --v74;
      }
      while ( v74 );
    }
    goto LABEL_138;
  }
LABEL_131:
  if ( *(_DWORD *)(v4 + 24) <= 0x10u )
    j_png_set_packing((png_structrp_8)v8);
  if ( v66 >= 0x10 )
    goto LABEL_134;
LABEL_112:
  v67 = *(_QWORD *)(v1 + 1);
  HIDWORD(v67) <<= v91;
  if ( SHIDWORD(v67) <= -1 )
    LODWORD(v67) = v67 + (*(_DWORD *)(v4 + 12) - 1) * -HIDWORD(v67);
  *(_QWORD *)(v1 + 5) = v67;
  if ( (*(_BYTE *)(v4 + 20) & 2) != 0 )
  {
    j_png_set_filter((png_structrp_10)v8, 0, 0);
    if ( (_DWORD)v8 )
      *(_DWORD *)(v8 + 388) = 3;
  }
  v68 = v21 & 5;
  v69 = 0;
  if ( ((v68 == 5) & v92) == 0 && (v20 || !v1[4]) )
    goto LABEL_135;
  rowbytes = j_png_get_rowbytes((png_const_structrp_1)v8, (png_const_inforp)HIDWORD(v8));
  v71 = j_png_malloc((png_const_structrp_2)v8, rowbytes);
  v1[7] = v71;
  v72 = png_write_image_16bit;
  if ( !v93 )
    v72 = png_write_image_8bit;
  v73 = j_png_safe_execute((png_imagep)v4, v72, v1);
  v1[7] = 0;
  j_png_free((png_const_structrp_2)v8, v71);
  if ( v73 )
  {
LABEL_138:
    j_png_write_end((png_structrp_10)v8, (png_inforp_6)HIDWORD(v8));
    return 1;
  }
  return v69;
}
// 205446: control flows out of bounds to 205448
// 204D3E: variable 'v14' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 204C70: using guessed type png_byte trans_alpha[256];

//----- (00205514) --------------------------------------------------------
int __fastcall png_image_write_to_file(
        png_imagep image,
        const unsigned __int8 *file_name,
        int convert_to_8bit,
        const void *buffer,
        __int64 a5)
{
  bool v9; // zf
  FILE *v10; // r8
  int v11; // r0
  int v12; // r5
  int v13; // r0
  char *v14; // r1
  int v16; // r0

  if ( !image )
    return 0;
  if ( image->version != 1 )
  {
    v14 = "png_image_write_to_file: incorrect PNG_IMAGE_VERSION";
    return sub_18FD2C(image, (png_const_charp)v14);
  }
  v9 = file_name == 0;
  if ( file_name )
    v9 = buffer == 0;
  if ( v9 )
  {
    v14 = "png_image_write_to_file: invalid argument";
    return sub_18FD2C(image, (png_const_charp)v14);
  }
  v10 = fopen((const char *)file_name, "wb");
  if ( !v10 )
  {
    v13 = *(_DWORD *)_errno(0);
    goto LABEL_15;
  }
  if ( !j_png_image_write_to_stdio(image, v10, convert_to_8bit, buffer, a5) )
  {
    fclose(v10);
    remove((const char *)file_name);
    return 0;
  }
  v11 = fflush(v10);
  if ( v11 || (v11 = ferror(v10)) != 0 )
  {
    v12 = *(_DWORD *)_errno(v11);
    fclose(v10);
LABEL_11:
    remove((const char *)file_name);
    v13 = v12;
LABEL_15:
    v14 = strerror(v13);
    return sub_18FD2C(image, (png_const_charp)v14);
  }
  v16 = fclose(v10);
  if ( v16 )
  {
    v12 = *(_DWORD *)_errno(v16);
    goto LABEL_11;
  }
  return 1;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (0020563C) --------------------------------------------------------
void __fastcall image_memory_write(png_structp png_ptr, png_bytep data, png_size_t size)
{
  _DWORD *io_ptr; // r4
  int v4; // r3
  png_size_t v5; // r5

  io_ptr = png_ptr->io_ptr;
  v4 = io_ptr[10];
  if ( ~v4 < size )
  {
    j_png_error(png_ptr, (png_const_charp)"png_image_write_to_memory: PNG too big");
    JUMPOUT(0x20566C);
  }
  if ( size )
  {
    v5 = v4 + size;
    if ( io_ptr[9] >= v4 + size )
      qmemcpy((void *)(io_ptr[8] + v4), data, size);
    io_ptr[10] = v5;
  }
}
// 205668: control flows out of bounds to 20566C

//----- (00205698) --------------------------------------------------------
int __fastcall png_write_image_16bit(png_voidp argument)
{
  png_structrp_10 **v2; // r1
  png_structrp_10 *v3; // r2
  int v4; // r0
  unsigned int v5; // r6
  int v6; // r3
  png_structrp_10 *v7; // r5
  int v8; // r9
  int v9; // r12
  int v10; // r6
  int v11; // r3
  unsigned int v12; // lr
  int v13; // r10
  unsigned int v14; // r5
  int v15; // r11
  unsigned int v16; // r6
  unsigned int v17; // r0
  bool v18; // zf
  int v19; // r1
  int v20; // r2
  unsigned int v21; // r3
  unsigned int v22; // r4
  unsigned int v24; // [sp+4h] [bp-3Ch]
  int v25; // [sp+8h] [bp-38h]
  png_const_bytep *v26; // [sp+Ch] [bp-34h]
  png_structrp_10 png_ptr; // [sp+10h] [bp-30h]
  png_structrp_10 *v28; // [sp+14h] [bp-2Ch]
  int v29; // [sp+18h] [bp-28h]
  unsigned int v30; // [sp+1Ch] [bp-24h]
  int v31; // [sp+20h] [bp-20h]

  v2 = *(png_structrp_10 ***)argument;
  v3 = **(png_structrp_10 ***)argument;
  v4 = *(_DWORD *)(*(_DWORD *)argument + 16);
  png_ptr = *v3;
  if ( (v4 & 1) == 0 )
  {
    j_png_error(png_ptr, (png_const_charp)"png_write_image: internal call error");
    JUMPOUT(0x2057AC);
  }
  v5 = *((_DWORD *)argument + 7);
  v6 = v4 & 2 | 1;
  v7 = v2[3];
  v8 = v6;
  if ( (v4 & 0x20) != 0 )
  {
    v8 = -1;
    v5 += 2;
  }
  v24 = v5;
  if ( v7 )
  {
    v9 = v6 + 1;
    v10 = *((_DWORD *)argument + 5);
    v11 = (_DWORD)v2[2] * (v6 + 1);
    v25 = v11;
    if ( (v4 & 0x20) != 0 )
      v10 += 2;
    v29 = v10;
    v12 = v24 + 2 * v11;
    v30 = v12;
    v31 = v9;
    v13 = ((2 * v4) & 4) + 4;
    v26 = (png_const_bytep *)argument;
    do
    {
      v28 = v7;
      if ( v25 >= 1 )
      {
        v14 = v24;
        v15 = v29;
        do
        {
          v16 = *(unsigned __int16 *)(v15 + 2 * v8);
          v17 = 0;
          *(_WORD *)(v14 + 2 * v8) = v16;
          v18 = v16 == 0;
          if ( v16 )
            v18 = v16 == 0xFFFF;
          if ( !v18 )
          {
            v17 = ((v16 >> 1) | 0x7FFF8000) / v16;
            v12 = v30;
            v9 = v31;
          }
          v19 = 0;
          v20 = v9;
          do
          {
            v21 = *(unsigned __int16 *)(v15 + v19);
            LOWORD(v22) = -1;
            if ( v21 < v16 )
            {
              if ( v16 == 0xFFFF )
              {
                LOWORD(v22) = *(_WORD *)(v15 + v19);
              }
              else
              {
                LOWORD(v22) = *(_WORD *)(v15 + v19);
                if ( (_WORD)v22 )
                  v22 = (v21 * v17 + 0x4000) >> 15;
              }
            }
            *(_WORD *)(v14 + v19) = v22;
            --v20;
            v19 += 2;
          }
          while ( v20 > 1 );
          v14 += v13;
          v15 += v13;
        }
        while ( v14 < v12 );
      }
      j_png_write_row(png_ptr, v26[7]);
      v12 = v30;
      v9 = v31;
      v7 = (png_structrp_10 *)((char *)v28 - 1);
      v29 += (unsigned int)v26[6] & 0xFFFE;
    }
    while ( v28 != (png_structrp_10 *)((char *)&dword_0 + 1) );
  }
  return 1;
}
// 2057AA: control flows out of bounds to 2057AC
// 0: using guessed type int dword_0;

//----- (002057D4) --------------------------------------------------------
int __fastcall png_write_image_8bit(png_voidp argument)
{
  int v2; // r0
  const png_byte *v3; // r9
  int v4; // r1
  int v5; // r4
  int v6; // r12
  int v7; // r2
  int v8; // r0
  const png_byte *v9; // r10
  int v10; // r8
  unsigned __int16 *v11; // r1
  png_byte *v12; // r0
  int v13; // t1
  int v14; // lr
  unsigned __int16 *v15; // r0
  unsigned __int16 *v16; // r10
  unsigned int v17; // r11
  unsigned int v18; // r6
  int v19; // r0
  int v20; // r1
  bool v21; // zf
  unsigned int v22; // r0
  int v23; // r2
  int v24; // r1
  unsigned int v25; // r3
  unsigned int v26; // r5
  unsigned int v27; // r3
  int v29; // [sp+4h] [bp-44h]
  png_const_bytep *v30; // [sp+8h] [bp-40h]
  int v31; // [sp+Ch] [bp-3Ch]
  png_struct *png_ptr; // [sp+10h] [bp-38h]
  unsigned __int16 *v33; // [sp+14h] [bp-34h]
  unsigned __int16 *v34; // [sp+14h] [bp-34h]
  int v35; // [sp+18h] [bp-30h]
  int v36; // [sp+1Ch] [bp-2Ch]
  int v37; // [sp+20h] [bp-28h]
  int v38; // [sp+28h] [bp-20h]
  int v39; // [sp+28h] [bp-20h]

  v2 = *(_DWORD *)argument;
  v33 = (unsigned __int16 *)*((_DWORD *)argument + 5);
  v3 = (const png_byte *)*((_DWORD *)argument + 7);
  v4 = *(_DWORD *)(v2 + 16);
  v5 = *(_DWORD *)(v2 + 12);
  v6 = v4 & 2;
  png_ptr = **(png_struct ***)v2;
  v7 = v6 | 1;
  if ( (v4 & 1) != 0 )
  {
    v14 = v4 & 2 | 1;
    if ( (v4 & 0x20) != 0 )
      ++v3;
    if ( (v4 & 0x20) != 0 )
      v14 = -1;
    if ( v5 )
    {
      v39 = v7 + 1;
      v29 = *(_DWORD *)(v2 + 8) * (v7 + 1);
      v15 = (unsigned __int16 *)*((_DWORD *)argument + 5);
      if ( (v4 & 0x20) != 0 )
        v15 = v33 + 1;
      v34 = v15;
      v37 = ((2 * v4) & 4) + 4;
      v35 = v14;
      v36 = v4 & 2;
      v30 = (png_const_bytep *)argument;
      do
      {
        v31 = v5;
        if ( v29 >= 1 )
        {
          v16 = v34;
          v17 = (unsigned int)v3;
          do
          {
            v18 = v16[v14];
            v19 = 255 * v18 + 32895;
            *(_BYTE *)(v17 + v14) = BYTE2(v19);
            v20 = BYTE2(v19);
            v21 = BYTE2(v19) == 0;
            v22 = 0;
            if ( !v21 )
              v21 = v20 == 255;
            if ( !v21 )
            {
              v22 = ((v18 >> 1) + 2139062400) / v18;
              v14 = v35;
              v6 = v36;
            }
            v23 = v39;
            v24 = 0;
            do
            {
              LOBYTE(v25) = -1;
              if ( v18 >= 0x80 )
              {
                v26 = v16[v24];
                if ( v26 < v18 )
                {
                  if ( v16[v24] )
                  {
                    if ( v18 > 0xFF7E )
                      v27 = 255 * v26;
                    else
                      v27 = (v22 * v26 + 64) >> 7;
                    v25 = (png_sRGB_base[v27 >> 15] + (((v27 & 0x7FFF) * png_sRGB_delta[v27 >> 15]) >> 12)) >> 8;
                  }
                  else
                  {
                    LOBYTE(v25) = 0;
                  }
                }
              }
              *(_BYTE *)(v17 + v24) = v25;
              --v23;
              ++v24;
            }
            while ( v23 > 1 );
            v16 = (unsigned __int16 *)((char *)v16 + v37);
            v17 += v6 + 2;
          }
          while ( v17 < (unsigned int)&v3[v29] );
        }
        j_png_write_row(png_ptr, v30[7]);
        v14 = v35;
        v6 = v36;
        --v5;
        v34 = (unsigned __int16 *)((char *)v34 + ((unsigned int)v30[6] & 0xFFFE));
      }
      while ( v31 != 1 );
    }
  }
  else if ( v5 )
  {
    v8 = *(_DWORD *)(v2 + 8);
    v9 = &v3[v8 * v7];
    v38 = v8 * v7;
    do
    {
      v10 = v5;
      if ( v38 >= 1 )
      {
        v11 = v33;
        v12 = (png_byte *)v3;
        do
        {
          v13 = *v11++;
          *v12++ = (unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v13) >> 15]
                                    + ((((255 * (_WORD)v13) & 0x7FFF)
                                      * (unsigned int)png_sRGB_delta[(unsigned int)(255 * v13) >> 15]) >> 12)) >> 8;
        }
        while ( v12 < v9 );
      }
      j_png_write_row(png_ptr, v3);
      --v5;
      v33 = (unsigned __int16 *)((char *)v33 + (*((_DWORD *)argument + 6) & 0xFFFE));
    }
    while ( v10 != 1 );
  }
  return 1;
}

//----- (002059C4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_do_write_transformations(png_structrp_11 png_ptr, png_row_infop row_info)
{
  void (__fastcall *write_user_transform_fn)(png_structrp_11, png_row_infop, png_bytep); // r3
  png_structrp_11 v3; // r10
  png_row_infop v4; // r9
  png_uint_32 transformations; // r0
  bool v6; // zf
  int bit_depth; // r1
  bool v8; // zf
  int color_type; // r2
  __int64 v10; // r0
  png_byte *p_blue; // r3
  unsigned int v12; // r8
  int v13; // r6
  int v14; // r0
  _BYTE *v15; // r4
  png_uint_32 v16; // r2
  int v17; // r6
  int v18; // r3
  _BYTE *v19; // r1
  int green; // r3
  unsigned __int8 *v21; // r11
  bool v22; // zf
  png_size_t rowbytes; // r12
  int v24; // lr
  int v25; // r10
  unsigned int i; // r9
  int v27; // r6
  int v28; // r1
  int v29; // r2
  unsigned int v30; // r3
  int v31; // r5
  unsigned int v32; // r0
  char v33; // r6
  unsigned int v34; // r4
  unsigned int j; // r9
  int v36; // r0
  int v37; // r6
  int v38; // r2
  int v39; // r5
  unsigned int v40; // r3
  unsigned int v41; // r1
  char v42; // r6
  unsigned int v43; // r4
  png_uint_32 width; // r2
  char v45; // r3
  int v46; // r5
  _BYTE *v47; // r6
  png_uint_32 v49; // r2
  int v50; // r6
  int v51; // r3
  _BYTE *v52; // r1
  png_byte channels; // r1
  png_byte v54; // r1
  png_uint_32 v55; // r0
  unsigned int v56; // r0
  int k; // r8
  int v58; // r3
  unsigned int v59; // r5
  int v60; // r1
  unsigned __int8 v61; // r4
  int v62; // r2
  int v63; // r1
  int v64; // r4
  unsigned int v65; // r1
  int v66; // r5
  int v67; // r2
  int v68; // r3
  const char *v69; // r0
  __int128 v70; // q12 OVERLAPPED
  __int128 v71; // q13
  __int128 v72; // q14
  __int128 v73; // q15
  char *v74; // r4
  unsigned int v75; // r1
  int v76; // r5
  char *v77; // r2
  int v78; // r3
  __int128 v79; // q10
  int v80; // r0
  char v81; // r3
  char v82; // r6
  char v83; // r5
  int v84; // r5
  __int16 *v85; // r2
  int v86; // r3
  const char *v87; // r0
  __int128 v88; // q12 OVERLAPPED
  __int128 v89; // q13
  __int128 v90; // q14
  __int128 v91; // q15
  char *v92; // r4
  unsigned int v93; // r0
  char v94; // r1
  __int16 v95; // r6
  unsigned int v96; // r0
  char v97; // r1
  unsigned int v98; // r0
  __int16 v99; // r1
  int v100; // r0
  png_bytep row_buf; // r1
  png_uint_32 v102; // r0
  _BYTE *v103; // r1
  png_uint_32 v104; // r0
  _BYTE *v105; // r1
  char *v106; // r1
  char v107; // r3
  char *v108; // r1
  char v109; // r3
  png_uint_32 v110; // r0
  png_structrp_11 v111; // [sp+4h] [bp-44h]
  png_row_info *v112; // [sp+8h] [bp-40h]
  int v113[4]; // [sp+Ch] [bp-3Ch]
  int v114[11]; // [sp+1Ch] [bp-2Ch]
  int8x8x4_t v115; // 0:d16.8,8:d17.8,16:d18.8,24:d19.8 OVERLAPPED
  int8x8x4_t v116; // 0:d16.8,8:d18.8,16:d20.8,24:d22.8 OVERLAPPED
  int8x8x4_t v117; // 0:d16.8,8:d18.8,16:d20.8,24:d22.8 OVERLAPPED
  int8x8x4_t v118; // 0:d17.8,8:d19.8,16:d21.8,24:d23.8
  int8x8x4_t v119; // 0:d17.8,8:d19.8,16:d21.8,24:d23.8

  v3 = png_ptr;
  v4 = row_info;
  if ( !png_ptr )
    return;
  transformations = png_ptr->transformations;
  v6 = (transformations & 0x100000) == 0;
  if ( (transformations & 0x100000) != 0 )
  {
    write_user_transform_fn = v3->write_user_transform_fn;
    v6 = write_user_transform_fn == 0;
  }
  if ( v6 )
  {
    if ( (transformations & 0x8000) != 0 )
      goto LABEL_11;
LABEL_7:
    if ( (transformations & 0x10000) != 0 )
      goto LABEL_12;
LABEL_8:
    if ( (transformations & 4) == 0 )
      goto LABEL_16;
    goto LABEL_13;
  }
  write_user_transform_fn(v3, row_info, v3->row_buf + 1);
  transformations = v3->transformations;
  if ( (transformations & 0x8000) == 0 )
    goto LABEL_7;
LABEL_11:
  j_png_do_strip_channel(v4, v3->row_buf + 1, ((v3->flags >> 7) & 1) == 0);
  transformations = v3->transformations;
  if ( (transformations & 0x10000) == 0 )
    goto LABEL_8;
LABEL_12:
  j_png_do_packswap(v4, v3->row_buf + 1);
  transformations = v3->transformations;
  if ( (transformations & 4) == 0 )
    goto LABEL_16;
LABEL_13:
  bit_depth = v4->bit_depth;
  v8 = bit_depth == 8;
  if ( bit_depth == 8 )
    v8 = v4->channels == 1;
  if ( v8 )
  {
    v14 = v3->bit_depth;
    v15 = v3->row_buf + 1;
    switch ( v14 )
    {
      case 1:
        width = v4->width;
        if ( v4->width )
        {
          v45 = 0;
          v46 = 128;
          v47 = v3->row_buf + 1;
          do
          {
            while ( 1 )
            {
              if ( *v15++ )
                v45 |= v46;
              if ( v46 < 2 )
                break;
              v46 = (unsigned int)v46 >> 1;
              if ( !--width )
                goto LABEL_80;
            }
            *v47++ = v45;
            v46 = 128;
            v45 = 0;
            --width;
          }
          while ( width );
LABEL_80:
          if ( v46 != 128 )
            *v47 = v45;
        }
        break;
      case 2:
        v49 = v4->width;
        if ( v4->width )
        {
          v50 = 6;
          v51 = 0;
          v52 = v3->row_buf + 1;
          do
          {
            v51 |= (*v52 & 3) << v50;
            if ( v50 )
            {
              v50 -= 2;
            }
            else
            {
              *v15++ = v51;
              v51 = 0;
              v50 = 6;
            }
            --v49;
            ++v52;
          }
          while ( v49 );
          if ( v50 != 6 )
            *v15 = v51;
        }
        break;
      case 4:
        v16 = v4->width;
        if ( v4->width )
        {
          v17 = 4;
          v18 = 0;
          v19 = v3->row_buf + 1;
          do
          {
            v18 |= (*v19 & 0xF) << v17;
            if ( v17 )
            {
              v17 -= 4;
            }
            else
            {
              *v15++ = v18;
              v18 = 0;
              v17 = 4;
            }
            --v16;
            ++v19;
          }
          while ( v16 );
          if ( v17 != 4 )
            *v15 = v18;
        }
        break;
    }
    channels = v4->channels;
    v4->bit_depth = v14;
    v54 = channels * v14;
    v55 = v4->width;
    v4->pixel_depth = v54;
    if ( v54 < 8u )
      v56 = (v55 * v54 + 7) >> 3;
    else
      v56 = v55 * (v54 >> 3);
    v4->rowbytes = v56;
    transformations = v3->transformations;
    if ( (transformations & 0x10) != 0 )
      goto LABEL_17;
    goto LABEL_18;
  }
LABEL_16:
  if ( (transformations & 0x10) != 0 )
  {
LABEL_17:
    j_png_do_swap(v4, v3->row_buf + 1);
    transformations = v3->transformations;
  }
LABEL_18:
  if ( (transformations & 8) != 0 )
  {
    color_type = v4->color_type;
    if ( color_type != 3 )
    {
      LODWORD(v10) = v3->row_buf;
      HIDWORD(v10) = v4->bit_depth;
      if ( (color_type & 2) != 0 )
      {
        v12 = 3;
        v113[0] = v3->shift.red;
        green = v3->shift.green;
        v114[0] = HIDWORD(v10) - v113[0];
        v114[1] = HIDWORD(v10) - green;
        v113[1] = green;
        p_blue = &v3->shift.blue;
        v13 = 2;
      }
      else
      {
        p_blue = &v3->shift.gray;
        v12 = 1;
        v13 = 0;
      }
      v21 = (unsigned __int8 *)(v10 + 1);
      LODWORD(v10) = *p_blue;
      v113[v13] = v10;
      v114[v13] = HIDWORD(v10) - v10;
      if ( (color_type & 4) != 0 )
      {
        LODWORD(v10) = v3->shift.alpha;
        v113[v12] = v10;
        v114[v12++] = HIDWORD(v10) - v10;
      }
      v111 = v3;
      v112 = v4;
      if ( HIDWORD(v10) > 7 )
      {
        v25 = v4->width * v12;
        if ( HIDWORD(v10) == 8 )
        {
          if ( v25 )
          {
            for ( i = 0; i != v25; ++i )
            {
              v27 = v114[i % v12];
              v28 = v113[i % v12];
              v29 = -v28;
              if ( v27 <= -v28 )
              {
                LOBYTE(v32) = 0;
              }
              else
              {
                v30 = *v21;
                v31 = v27 - v28;
                v32 = v30 >> -(char)v27;
                if ( v27 > 0 )
                  v32 = v30 << v27;
                if ( v31 > v29 )
                {
                  v33 = v28 - v27;
                  do
                  {
                    v34 = v30 >> v33;
                    if ( v31 > 0 )
                      v34 = v30 << v31;
                    v31 -= v28;
                    v32 |= v34;
                    v33 += v28;
                  }
                  while ( v31 > v29 );
                }
              }
              *v21++ = v32;
            }
          }
        }
        else if ( v25 )
        {
          for ( j = 0; j != v25; ++j )
          {
            v36 = v113[j % v12];
            v37 = v114[j % v12];
            v38 = -v36;
            if ( v37 <= -v36 )
            {
              LOWORD(v41) = 0;
            }
            else
            {
              v39 = v37 - v36;
              v40 = v21[1] | (*v21 << 8);
              v41 = v40 >> -(char)v37;
              if ( v37 > 0 )
                v41 = v40 << v37;
              if ( v39 > v38 )
              {
                v42 = v36 - v37;
                do
                {
                  v43 = v40 >> v42;
                  if ( v39 > 0 )
                    v43 = v40 << v39;
                  v39 -= v36;
                  LOWORD(v41) = v41 | v43;
                  v42 += v36;
                }
                while ( v39 > v38 );
              }
            }
            v21[1] = v41;
            *v21 = BYTE1(v41);
            v21 += 2;
          }
        }
        goto LABEL_109;
      }
      LODWORD(v10) = v3->shift.gray;
      v22 = HIDWORD(v10) == 2;
      rowbytes = v4->rowbytes;
      if ( HIDWORD(v10) == 2 )
        v22 = (_DWORD)v10 == 1;
      if ( v22 )
      {
        v24 = 85;
        if ( !rowbytes )
        {
LABEL_109:
          v3 = v111;
          v4 = v112;
          transformations = v111->transformations;
          goto LABEL_110;
        }
      }
      else
      {
        v24 = 255;
        if ( v10 == 0x400000003LL )
          v24 = 17;
        if ( !rowbytes )
          goto LABEL_109;
      }
      for ( k = 0; k != rowbytes; ++k )
      {
        v58 = v114[0];
        if ( v114[0] <= -v113[0] )
        {
          v61 = 0;
        }
        else
        {
          v59 = *v21;
          v60 = -v114[0];
          v61 = 0;
          do
          {
            if ( v58 >= 1 )
              v62 = v59 << v58;
            else
              v62 = (v59 >> v60) & v24;
            v58 -= v113[0];
            LOBYTE(v60) = v60 + LOBYTE(v113[0]);
            v61 |= v62;
          }
          while ( v58 > -v113[0] );
        }
        *v21++ = v61;
      }
      goto LABEL_109;
    }
  }
LABEL_110:
  if ( (transformations & 0x20000) != 0 )
  {
    v63 = v4->color_type;
    v64 = (int)(v3->row_buf + 1);
    if ( v63 == 4 )
    {
      v75 = v4->width;
      if ( v4->bit_depth == 8 )
      {
        if ( v75 )
        {
          if ( v75 < 0x10 || (v76 = v4->width - (v4->width & 0xF), v4->width == (v4->width & 0xF)) )
          {
            v76 = 0;
            v77 = (char *)(v3->row_buf + 1);
          }
          else
          {
            v77 = (char *)(v64 + 2 * v76);
            v78 = v4->width - (v4->width & 0xF);
            do
            {
              v115 = vld2q_s8((const char *)v64);
              v78 -= 16;
              v79 = *(_OWORD *)v115.val[0].n64_u64;
              vst2q_s8((char *)v64, *(int8x8x4_t *)((char *)&v115 + 16));
              v64 += 32;
            }
            while ( v78 );
            if ( (v75 & 0xF) == 0 )
              goto LABEL_150;
          }
          v96 = v75 - v76;
          do
          {
            v97 = *v77;
            --v96;
            *v77 = v77[1];
            v77[1] = v97;
            v77 += 2;
          }
          while ( v96 );
        }
      }
      else if ( v75 )
      {
        if ( v75 <= 0xF || (v84 = v4->width - (v4->width & 0xF), v4->width == (v4->width & 0xF)) )
        {
          v84 = 0;
          v85 = (__int16 *)(v3->row_buf + 1);
        }
        else
        {
          v85 = (__int16 *)(v64 + 4 * v84);
          v86 = v4->width - (v4->width & 0xF);
          do
          {
            v87 = (const char *)v64;
            v86 -= 16;
            v117 = vld4_s8(v87);
            v87 += 32;
            v119 = vld4_s8(v87);
            v88 = *(_OWORD *)v117.val[2].n64_u64;
            v89 = *(_OWORD *)v117.val[3].n64_u64;
            v90 = *(_OWORD *)v117.val[0].n64_u64;
            v91 = *(_OWORD *)v117.val[1].n64_u64;
            vst4_s8((char *)v64, *(int8x8x4_t *)&v88);
            v92 = (char *)(v64 + 32);
            vst4_s8(v92, *(int8x8x4_t *)((char *)&v88 + 8));
            v64 = (int)(v92 + 32);
          }
          while ( v86 );
          if ( (v75 & 0xF) == 0 )
            goto LABEL_150;
        }
        v98 = v75 - v84;
        do
        {
          v99 = *v85;
          --v98;
          *v85 = v85[1];
          v85[1] = v99;
          v85 += 2;
        }
        while ( v98 );
      }
    }
    else if ( v63 == 6 )
    {
      v65 = v4->width;
      if ( v4->bit_depth != 8 )
      {
        for ( ; v65; v64 += 8 )
        {
          v80 = *(_DWORD *)(v64 + 2);
          --v65;
          v81 = *(_BYTE *)v64;
          v82 = *(_BYTE *)(v64 + 1);
          v83 = *(_BYTE *)(v64 + 7);
          *(_BYTE *)(v64 + 4) = *(_BYTE *)(v64 + 6);
          *(_DWORD *)v64 = v80;
          *(_BYTE *)(v64 + 5) = v83;
          *(_BYTE *)(v64 + 6) = v81;
          *(_BYTE *)(v64 + 7) = v82;
        }
        goto LABEL_150;
      }
      if ( v65 )
      {
        if ( v65 < 0x10 || (v66 = v4->width - (v4->width & 0xF), v4->width == (v4->width & 0xF)) )
        {
          v66 = 0;
          v67 = (int)(v3->row_buf + 1);
        }
        else
        {
          v67 = v64 + 4 * v66;
          v68 = v4->width - (v4->width & 0xF);
          do
          {
            v69 = (const char *)v64;
            v68 -= 16;
            v116 = vld4_s8(v69);
            v69 += 32;
            v118 = vld4_s8(v69);
            v70 = *(_OWORD *)v116.val[1].n64_u64;
            v71 = *(_OWORD *)v116.val[2].n64_u64;
            v72 = *(_OWORD *)v116.val[3].n64_u64;
            v73 = *(_OWORD *)v116.val[0].n64_u64;
            vst4_s8((char *)v64, *(int8x8x4_t *)&v70);
            v74 = (char *)(v64 + 32);
            vst4_s8(v74, *(int8x8x4_t *)((char *)&v70 + 8));
            v64 = (int)(v74 + 32);
          }
          while ( v68 );
          if ( (v65 & 0xF) == 0 )
            goto LABEL_150;
        }
        v93 = v65 - v66;
        do
        {
          v94 = *(_BYTE *)v67;
          --v93;
          v95 = *(_WORD *)(v67 + 1);
          *(_BYTE *)(v67 + 2) = *(_BYTE *)(v67 + 3);
          *(_WORD *)v67 = v95;
          *(_BYTE *)(v67 + 3) = v94;
          v67 += 4;
        }
        while ( v93 );
      }
    }
  }
LABEL_150:
  if ( (v3->transformations & 0x80000) != 0 )
  {
    v100 = v4->color_type;
    row_buf = v3->row_buf;
    if ( v100 == 4 )
    {
      v104 = v4->width;
      if ( v4->bit_depth == 8 )
      {
        if ( v104 )
        {
          v105 = row_buf + 2;
          do
          {
            --v104;
            *v105 = ~*v105;
            v105 += 2;
          }
          while ( v104 );
        }
      }
      else if ( v104 )
      {
        v108 = (char *)(row_buf + 4);
        do
        {
          --v104;
          v109 = *v108;
          *(v108 - 1) = ~*(v108 - 1);
          *v108 = ~v109;
          v108 += 4;
        }
        while ( v104 );
      }
    }
    else if ( v100 == 6 )
    {
      v102 = v4->width;
      if ( v4->bit_depth == 8 )
      {
        if ( v102 )
        {
          v103 = row_buf + 4;
          do
          {
            --v102;
            *v103 = ~*v103;
            v103 += 4;
          }
          while ( v102 );
        }
      }
      else if ( v102 )
      {
        v106 = (char *)(row_buf + 8);
        do
        {
          --v102;
          v107 = *v106;
          *(v106 - 1) = ~*(v106 - 1);
          *v106 = ~v107;
          v106 += 8;
        }
        while ( v102 );
      }
    }
  }
  v110 = v3->transformations;
  if ( (v110 & 1) != 0 )
  {
    j_png_do_bgr(v4, v3->row_buf + 1);
    v110 = v3->transformations;
  }
  if ( (v110 & 0x20) != 0 )
    sub_19BA54(v4, v3->row_buf + 1);
}
// 205D9B: failed to expand linear variable 0:d16.8,8:d18.8,16:d20.8,24:d22.8
// 205DA3: failed to expand linear variable q12.16
// 205DE5: failed to expand linear variable 0:d16.8,8:d17.8,16:d18.8,24:d19.8
// 205E39: failed to expand linear variable 0:d16.8,8:d18.8,16:d20.8,24:d22.8
// 205E41: failed to expand linear variable q12.16

//----- (00205F80) --------------------------------------------------------
void __fastcall png_save_uint_32(png_bytep buf, png_uint_32 i)
{
  buf[3] = i;
  buf[1] = BYTE2(i);
  *buf = HIBYTE(i);
  buf[2] = BYTE1(i);
}

//----- (00205F90) --------------------------------------------------------
void __fastcall png_save_uint_16(png_bytep buf, unsigned int i)
{
  buf[1] = i;
  *buf = BYTE1(i);
}

//----- (00205F98) --------------------------------------------------------
void __fastcall png_write_sig(png_structrp_12 png_ptr)
{
  int sig_bytes; // r2
  int v3[4]; // [sp+0h] [bp-10h] BYREF

  sig_bytes = png_ptr->sig_bytes;
  v3[1] = 169478669;
  v3[0] = 1196314761;
  png_ptr->io_state = 18;
  j_png_write_data(png_ptr, (png_const_bytep)v3 + sig_bytes, 8 - sig_bytes);
  if ( png_ptr->sig_bytes <= 2u )
    png_ptr->mode |= 0x1000u;
}

//----- (00205FE4) --------------------------------------------------------
void __fastcall png_write_chunk_start(png_structrp_12 png_ptr, png_const_bytep chunk_string, png_uint_32 length)
{
  int v4; // r9
  int v5; // r5
  int v6; // r10
  int v7; // r6
  png_byte data[4]; // [sp+4h] [bp-24h] BYREF
  png_byte v9[4]; // [sp+8h] [bp-20h] BYREF

  if ( png_ptr )
  {
    v4 = *chunk_string;
    v5 = chunk_string[1];
    v6 = chunk_string[2];
    v7 = chunk_string[3];
    png_ptr->io_state = 34;
    data[1] = BYTE2(length);
    data[0] = HIBYTE(length);
    data[2] = BYTE1(length);
    data[3] = length;
    v9[0] = v4;
    v9[1] = v5;
    v9[2] = v6;
    v9[3] = v7;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = (v5 << 16) | (v4 << 24) | (v6 << 8) | v7;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, v9, 4u);
    png_ptr->io_state = 66;
  }
}

//----- (00206090) --------------------------------------------------------
void __fastcall png_write_chunk_data(png_structrp_12 png_ptr, png_const_bytep data, png_size_t length)
{
  bool v4; // zf

  v4 = png_ptr == 0;
  if ( png_ptr )
    v4 = data == 0;
  if ( !v4 )
  {
    if ( length )
    {
      j_png_write_data(png_ptr, data, length);
      sub_19AB60(png_ptr, data, length);
    }
  }
}

//----- (002060CA) --------------------------------------------------------
void __fastcall png_write_chunk_end(png_structrp_12 png_ptr)
{
  png_uint_32 crc; // r1
  png_byte data[12]; // [sp+4h] [bp-Ch] BYREF

  if ( png_ptr )
  {
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    data[3] = crc;
    data[1] = BYTE2(crc);
    data[0] = HIBYTE(crc);
    data[2] = BYTE1(crc);
    j_png_write_data(png_ptr, data, 4u);
  }
}

//----- (00206108) --------------------------------------------------------
void __fastcall png_write_chunk(
        png_structrp_12 png_ptr,
        png_const_bytep chunk_string,
        png_const_bytep data,
        png_size_t length)
{
  int v7; // r2
  int v8; // r0
  int v9; // r3
  int v10; // r1
  int v11; // r9
  bool v12; // zf
  png_uint_32 crc; // r0
  png_byte v14; // [sp+4h] [bp-24h] BYREF
  char v15; // [sp+5h] [bp-23h]
  char v16; // [sp+6h] [bp-22h]
  char v17; // [sp+7h] [bp-21h]
  png_byte v18[4]; // [sp+8h] [bp-20h] BYREF

  if ( png_ptr )
  {
    if ( (int)length <= -1 )
    {
      j_png_error(png_ptr, (png_const_charp)"length exceeds PNG maximum");
      JUMPOUT(0x206200);
    }
    v7 = chunk_string[1];
    v8 = *chunk_string;
    v9 = chunk_string[2];
    v10 = chunk_string[3];
    v11 = (v7 << 16) | (v8 << 24) | (v9 << 8) | v10;
    png_ptr->io_state = 34;
    v15 = BYTE2(length);
    v14 = HIBYTE(length);
    v16 = BYTE1(length);
    v17 = length;
    v18[0] = v8;
    v18[1] = v7;
    v18[2] = v9;
    v18[3] = v10;
    j_png_write_data(png_ptr, &v14, 8u);
    png_ptr->chunk_name = v11;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, v18, 4u);
    v12 = data == 0;
    png_ptr->io_state = 66;
    if ( data )
      v12 = length == 0;
    if ( !v12 )
    {
      j_png_write_data(png_ptr, data, length);
      j_png_calculate_crc(png_ptr, data, length);
    }
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    v17 = crc;
    v15 = BYTE2(crc);
    v14 = HIBYTE(crc);
    v16 = BYTE1(crc);
    j_png_write_data(png_ptr, &v14, 4u);
  }
}
// 2061FC: control flows out of bounds to 206200

//----- (0020620C) --------------------------------------------------------
void __fastcall png_free_buffer_list(png_structrp_12 png_ptr, png_compression_bufferp *listp)
{
  png_compression_bufferp v4; // r1
  png_compression_buffer *next; // r5

  v4 = *listp;
  if ( v4 )
  {
    *listp = 0;
    do
    {
      next = v4->next;
      j_png_free(png_ptr, v4);
      v4 = next;
    }
    while ( next );
  }
}

//----- (00206230) --------------------------------------------------------
void __fastcall png_write_IHDR(
        png_structrp_12 png_ptr,
        png_uint_32 width,
        png_uint_32 height,
        int bit_depth,
        int color_type,
        int compression_type,
        __int64 filter_type)
{
  png_byte v11; // r0
  bool v12; // zf
  bool v13; // zf
  bool v14; // zf
  png_byte v15; // r5
  png_byte v16; // r11
  png_byte channels; // r0
  unsigned int v18; // r1
  png_uint_32 v19; // r1
  png_uint_32 crc; // r0
  png_byte v21; // r0
  png_byte data[8]; // [sp+3h] [bp-35h] BYREF
  png_byte buf[13]; // [sp+Bh] [bp-2Dh] BYREF

  switch ( color_type )
  {
    case 0:
      if ( (unsigned int)bit_depth <= 0x10 )
      {
        v11 = 1;
        if ( ((1 << bit_depth) & ((unsigned int)&elf_hash_bucket[16390] + 2)) != 0 )
          goto LABEL_20;
      }
      j_png_error(png_ptr, (png_const_charp)"Invalid bit depth for grayscale image");
LABEL_5:
      v12 = bit_depth == 8;
      v11 = 3;
      if ( bit_depth != 8 )
        v12 = bit_depth == 16;
      if ( !v12 )
      {
        j_png_error(png_ptr, (png_const_charp)"Invalid bit depth for RGB image");
LABEL_9:
        if ( (unsigned int)bit_depth > 8 || (v11 = 1, ((1 << bit_depth) & 0x116) == 0) )
        {
          j_png_error(png_ptr, (png_const_charp)"Invalid bit depth for paletted image");
LABEL_12:
          v13 = bit_depth == 8;
          v11 = 2;
          if ( bit_depth != 8 )
            v13 = bit_depth == 16;
          if ( !v13 )
          {
            j_png_error(png_ptr, (png_const_charp)"Invalid bit depth for grayscale+alpha image");
LABEL_16:
            v14 = bit_depth == 8;
            v11 = 4;
            if ( bit_depth != 8 )
              v14 = bit_depth == 16;
            if ( !v14 )
            {
LABEL_43:
              j_png_error(png_ptr, (png_const_charp)"Invalid bit depth for RGBA image");
              JUMPOUT(0x2064B4);
            }
          }
        }
      }
LABEL_20:
      png_ptr->channels = v11;
      if ( compression_type )
        j_png_warning(png_ptr, (png_const_charp)"Invalid compression type specified");
      v16 = BYTE4(filter_type);
      v15 = filter_type;
      if ( (png_ptr->mng_features_permitted & 4) == 0 || (png_ptr->mode & 0x1000) != 0 )
      {
        if ( !(_DWORD)filter_type )
        {
LABEL_29:
          v15 = 0;
          goto LABEL_30;
        }
LABEL_28:
        j_png_warning(png_ptr, (png_const_charp)"Invalid filter type specified");
        goto LABEL_29;
      }
      if ( (_DWORD)filter_type && (unsigned int)filter_type ^ 0x40 | (color_type | 4) ^ 6 )
        goto LABEL_28;
LABEL_30:
      if ( HIDWORD(filter_type) >= 2 )
      {
        j_png_warning(png_ptr, (png_const_charp)"Invalid interlace type specified");
        v16 = 1;
      }
      channels = png_ptr->channels;
      png_ptr->color_type = color_type;
      png_ptr->bit_depth = bit_depth;
      png_ptr->interlaced = v16;
      png_ptr->filter_type = v15;
      png_ptr->compression_type = 0;
      png_ptr->width = width;
      png_ptr->height = height;
      png_ptr->pixel_depth = channels * bit_depth;
      v18 = (unsigned __int8)(channels * bit_depth);
      if ( v18 < 8 )
        v19 = (v18 * width + 7) >> 3;
      else
        v19 = (v18 >> 3) * width;
      png_ptr->usr_width = width;
      png_ptr->rowbytes = v19;
      png_ptr->usr_bit_depth = bit_depth;
      png_ptr->usr_channels = channels;
      data[1] = BYTE2(width);
      data[0] = HIBYTE(width);
      data[2] = BYTE1(width);
      data[3] = width;
      data[4] = HIBYTE(height);
      data[5] = BYTE2(height);
      data[6] = BYTE1(height);
      data[7] = height;
      buf[0] = bit_depth;
      buf[1] = color_type;
      buf[2] = 0;
      png_ptr->io_state = 34;
      buf[3] = v15;
      *(_DWORD *)&buf[5] = 218103808;
      *(_DWORD *)&buf[9] = 1380206665;
      buf[4] = v16;
      j_png_write_data(png_ptr, &buf[5], 8u);
      png_ptr->chunk_name = 1229472850;
      j_png_reset_crc(png_ptr);
      j_png_calculate_crc(png_ptr, &buf[9], 4u);
      png_ptr->io_state = 66;
      j_png_write_data(png_ptr, data, 0xDu);
      j_png_calculate_crc(png_ptr, data, 0xDu);
      crc = png_ptr->crc;
      png_ptr->io_state = 130;
      buf[8] = crc;
      buf[6] = BYTE2(crc);
      buf[5] = HIBYTE(crc);
      buf[7] = BYTE1(crc);
      j_png_write_data(png_ptr, &buf[5], 4u);
      if ( !png_ptr->do_filter )
      {
        if ( png_ptr->color_type == 3 )
        {
          v21 = 8;
        }
        else
        {
          v21 = -8;
          if ( png_ptr->bit_depth < 8u )
            v21 = 8;
        }
        png_ptr->do_filter = v21;
      }
      png_ptr->mode = 1;
      return;
    case 2:
      goto LABEL_5;
    case 3:
      goto LABEL_9;
    case 4:
      goto LABEL_12;
    case 6:
      goto LABEL_16;
    default:
      j_png_error(png_ptr, (png_const_charp)"Invalid image color type specified");
      goto LABEL_43;
  }
}
// 2064B0: control flows out of bounds to 2064B4
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0020654C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_write_PLTE(png_structrp_12 png_ptr, png_const_colorp palette, png_uint_32 num_pal)
{
  png_uint_32 v4; // r5
  int color_type; // r0
  const char *v7; // r1
  png_uint_32 crc; // r0
  png_byte v9[3]; // [sp+1h] [bp-1Fh] BYREF
  png_byte data; // [sp+4h] [bp-1Ch] BYREF
  char v11; // [sp+5h] [bp-1Bh]
  char v12; // [sp+6h] [bp-1Ah]
  char v13; // [sp+7h] [bp-19h]
  int v14; // [sp+8h] [bp-18h] OVERLAPPED BYREF

  v4 = num_pal;
  color_type = png_ptr->color_type;
  if ( color_type == 3 )
  {
    if ( 1 << png_ptr->bit_depth < num_pal )
    {
LABEL_8:
      v7 = "Invalid number of colors in palette";
      if ( color_type == 3 )
      {
        j_png_error(png_ptr, (png_const_charp)"Invalid number of colors in palette");
        JUMPOUT(0x206694);
      }
      goto LABEL_9;
    }
  }
  else if ( num_pal > 0x100 )
  {
    goto LABEL_8;
  }
  if ( !(png_ptr->mng_features_permitted & 1 | num_pal) )
    goto LABEL_8;
  if ( (color_type & 2) == 0 )
  {
    v7 = "Ignoring request to write a PLTE chunk in grayscale PNG";
LABEL_9:
    j_png_warning(png_ptr, (png_const_charp)v7);
    return;
  }
  png_ptr->num_palette = num_pal;
  png_ptr->io_state = 34;
  v11 = (3 * num_pal) >> 16;
  data = (3 * num_pal) >> 24;
  v12 = (unsigned __int16)(3 * num_pal) >> 8;
  v13 = 3 * num_pal;
  v14 = 1163152464;
  j_png_write_data(png_ptr, &data, 8u);
  png_ptr->chunk_name = 1347179589;
  j_png_reset_crc(png_ptr);
  j_png_calculate_crc(png_ptr, (png_const_bytep)&v14, 4u);
  for ( png_ptr->io_state = 66; v4; --v4 )
  {
    v9[0] = palette->red;
    v9[1] = palette->green;
    v9[2] = palette->blue;
    j_png_write_data(png_ptr, v9, 3u);
    j_png_calculate_crc(png_ptr, v9, 3u);
    ++palette;
  }
  crc = png_ptr->crc;
  png_ptr->io_state = 130;
  v13 = crc;
  v11 = BYTE2(crc);
  data = HIBYTE(crc);
  v12 = BYTE1(crc);
  j_png_write_data(png_ptr, &data, 4u);
  png_ptr->mode |= 2u;
}
// 206692: control flows out of bounds to 206694
// 20654C: variables would overlap: ^8.4 and stkvar "buf" ^9.3(has user info)

//----- (002066F8) --------------------------------------------------------
void __fastcall png_compress_IDAT(
        png_structrp_12 png_ptr,
        png_const_bytep input,
        png_alloc_size_t input_len,
        int flush)
{
  png_compression_bufferp zbuffer_list; // r0
  png_compression_buffer *next; // r1
  png_compression_buffer *v10; // r6
  png_compression_buffer *v11; // r0
  png_alloc_size_t v12; // r0
  __int64 v13; // r0
  z_stream *p_zstream; // r5
  int v15; // r0
  signed int avail_out; // r9
  _BYTE *v17; // r8
  png_compression_bufferp v18; // r5
  Bytef *output; // r10
  png_alloc_size_t v20; // r0
  unsigned int v21; // r1
  char v22; // r2
  unsigned int v23; // r6
  unsigned int v24; // r1
  png_byte v25; // r2
  int v26; // r3
  unsigned int v27; // r6
  png_byte v28; // r0
  png_uint_32 crc; // r0
  png_uint_32 mode; // r0
  bool v31; // zf
  __int64 v32; // kr08_8
  signed int v33; // r5
  png_alloc_size_t v34; // r0
  unsigned int v35; // r1
  char v36; // r2
  unsigned int v37; // r6
  unsigned int v38; // r1
  char v39; // r2
  int v40; // r3
  unsigned int v41; // r6
  char v42; // r0
  png_uint_32 v43; // r0
  png_uint_32 v44; // r0
  int v45; // [sp+Ch] [bp-2Ch]
  png_byte v46; // [sp+10h] [bp-28h] BYREF
  char v47; // [sp+11h] [bp-27h]
  char v48; // [sp+12h] [bp-26h]
  char v49; // [sp+13h] [bp-25h]
  int v50; // [sp+14h] [bp-24h] BYREF

  if ( png_ptr->zowner != 1229209940 )
  {
    zbuffer_list = png_ptr->zbuffer_list;
    if ( zbuffer_list )
    {
      next = zbuffer_list->next;
      if ( zbuffer_list->next )
      {
        zbuffer_list->next = 0;
        do
        {
          v10 = next->next;
          j_png_free(png_ptr, next);
          next = v10;
        }
        while ( v10 );
      }
    }
    else
    {
      v11 = (png_compression_buffer *)j_png_malloc(png_ptr, png_ptr->zbuffer_size + 4);
      png_ptr->zbuffer_list = v11;
      v11->next = 0;
    }
    v12 = png_image_size(png_ptr);
    if ( png_deflate_claim(png_ptr, 0x49444154u, v12) )
    {
LABEL_56:
      j_png_error(png_ptr, png_ptr->zstream.msg);
      JUMPOUT(0x206AD0);
    }
    v13 = *(_QWORD *)&png_ptr->zbuffer_list;
    LODWORD(v13) = v13 + 4;
    *(_QWORD *)&png_ptr->zstream.next_out = v13;
  }
  p_zstream = &png_ptr->zstream;
  png_ptr->zstream.next_in = (Bytef *)input;
  png_ptr->zstream.avail_in = 0;
  v45 = flush;
  while ( 1 )
  {
    while ( 1 )
    {
      png_ptr->zstream.avail_in = input_len;
      v15 = j_deflate((z_streamp)p_zstream, flush);
      avail_out = png_ptr->zstream.avail_out;
      v17 = (_BYTE *)v15;
      input_len = png_ptr->zstream.avail_in;
      png_ptr->zstream.avail_in = 0;
      if ( avail_out )
      {
LABEL_12:
        if ( v17 )
          goto LABEL_32;
        goto LABEL_13;
      }
      avail_out = png_ptr->zbuffer_size;
      v18 = png_ptr->zbuffer_list;
      output = v18->output;
      if ( (png_ptr->mode & 4) == 0 && !png_ptr->compression_type )
      {
        v20 = png_image_size(png_ptr);
        if ( v20 <= 0x4000 )
        {
          v21 = *output;
          if ( (v21 & 0xF) == 8 )
          {
            v22 = v21 & 0xF0;
            if ( (v21 & 0xF0) <= 0x70 )
            {
              v23 = v21 >> 4;
              v24 = 128 << (*output >> 4);
              if ( v24 >= v20 )
              {
                v25 = v22 + 8;
                v26 = (v23 << 12) | 0x800;
                v27 = 1 - v23;
                do
                {
                  v25 -= 16;
                  v26 -= 4096;
                  if ( !v27 )
                    break;
                  ++v27;
                  v24 >>= 1;
                }
                while ( v24 >= v20 );
                v28 = v18->output[1];
                v18->output[0] = v25;
                v18->output[1] = (v28 & 0xE0 | ((v26 | v28 & 0xE0u) % 0x1F)) ^ 0x1F;
              }
            }
          }
        }
      }
      if ( avail_out )
      {
        if ( avail_out <= -1 )
        {
          j_png_error(png_ptr, (png_const_charp)"length exceeds PNG maximum");
          goto LABEL_53;
        }
        png_ptr->io_state = 34;
        v47 = BYTE2(avail_out);
        v46 = HIBYTE(avail_out);
        v48 = BYTE1(avail_out);
        v49 = avail_out;
        v50 = 1413563465;
        j_png_write_data(png_ptr, &v46, 8u);
        png_ptr->chunk_name = 1229209940;
        j_png_reset_crc(png_ptr);
        j_png_calculate_crc(png_ptr, (png_const_bytep)&v50, 4u);
        png_ptr->io_state = 66;
        j_png_write_data(png_ptr, v18->output, avail_out);
        j_png_calculate_crc(png_ptr, v18->output, avail_out);
        crc = png_ptr->crc;
        png_ptr->io_state = 130;
        v49 = crc;
        v47 = BYTE2(crc);
        v46 = HIBYTE(crc);
        v48 = BYTE1(crc);
        j_png_write_data(png_ptr, &v46, 4u);
      }
      mode = png_ptr->mode;
      png_ptr->zstream.next_out = output;
      png_ptr->zstream.avail_out = avail_out;
      flush = v45;
      png_ptr->mode = mode | 4;
      if ( !v45 )
        break;
      p_zstream = &png_ptr->zstream;
      if ( v17 )
        goto LABEL_12;
    }
    p_zstream = &png_ptr->zstream;
    if ( v17 )
      break;
LABEL_13:
    if ( !input_len )
    {
      if ( flush != 4 )
        return;
LABEL_53:
      j_png_error(png_ptr, (png_const_charp)"Z_OK on Z_FINISH with output space");
      goto LABEL_54;
    }
  }
LABEL_32:
  v31 = flush == 4;
  if ( flush == 4 )
    v31 = v17 == (_BYTE *)&dword_0 + 1;
  if ( !v31 )
  {
LABEL_55:
    j_png_zstream_error(png_ptr, (int)v17);
    goto LABEL_56;
  }
  v32 = *(_QWORD *)&png_ptr->zbuffer_list;
  v33 = HIDWORD(v32) - avail_out;
  v17 = (_BYTE *)(v32 + 4);
  if ( (png_ptr->mode & 4) == 0 && !png_ptr->compression_type )
  {
    v34 = png_image_size(png_ptr);
    if ( v34 <= 0x4000 )
    {
      v35 = (unsigned __int8)*v17;
      if ( (v35 & 0xF) == 8 )
      {
        v36 = v35 & 0xF0;
        if ( (v35 & 0xF0) <= 0x70 )
        {
          v37 = v35 >> 4;
          v38 = 128 << (*v17 >> 4);
          if ( v38 >= v34 )
          {
            v39 = v36 + 8;
            v40 = (v37 << 12) | 0x800;
            v41 = 1 - v37;
            do
            {
              v39 -= 16;
              v40 -= 4096;
              if ( !v41 )
                break;
              ++v41;
              v38 >>= 1;
            }
            while ( v38 >= v34 );
            v42 = *(_BYTE *)(v32 + 5);
            *(_BYTE *)(v32 + 4) = v39;
            *(_BYTE *)(v32 + 5) = (v42 & 0xE0 | ((v40 | v42 & 0xE0u) % 0x1F)) ^ 0x1F;
          }
        }
      }
    }
  }
  if ( v33 )
  {
    if ( v33 > -1 )
    {
      png_ptr->io_state = 34;
      v47 = (unsigned int)(HIDWORD(v32) - avail_out) >> 16;
      v46 = (unsigned int)(HIDWORD(v32) - avail_out) >> 24;
      v48 = (unsigned __int16)(WORD2(v32) - avail_out) >> 8;
      v49 = BYTE4(v32) - avail_out;
      v50 = 1413563465;
      j_png_write_data(png_ptr, &v46, 8u);
      png_ptr->chunk_name = 1229209940;
      j_png_reset_crc(png_ptr);
      j_png_calculate_crc(png_ptr, (png_const_bytep)&v50, 4u);
      png_ptr->io_state = 66;
      j_png_write_data(png_ptr, (png_const_bytep)(v32 + 4), v33);
      j_png_calculate_crc(png_ptr, (png_const_bytep)(v32 + 4), v33);
      v43 = png_ptr->crc;
      png_ptr->io_state = 130;
      v49 = v43;
      v47 = BYTE2(v43);
      v46 = HIBYTE(v43);
      v48 = BYTE1(v43);
      j_png_write_data(png_ptr, &v46, 4u);
      goto LABEL_49;
    }
LABEL_54:
    j_png_error(png_ptr, (png_const_charp)"length exceeds PNG maximum");
    goto LABEL_55;
  }
LABEL_49:
  v44 = png_ptr->mode;
  png_ptr->zstream.next_out = 0;
  png_ptr->zstream.avail_out = 0;
  png_ptr->zowner = 0;
  png_ptr->mode = v44 | 0xC;
}
// 206ACE: control flows out of bounds to 206AD0
// 0: using guessed type int dword_0;

//----- (00206B04) --------------------------------------------------------
int __fastcall png_deflate_claim(png_structrp_12 png_ptr, png_uint_32 owner, png_alloc_size_t data_size)
{
  png_uint_32 zowner; // r0
  int v7; // r6
  int zlib_method; // r8
  int zlib_level; // r9
  int zlib_mem_level; // r3
  int zlib_window_bits; // r6
  int zlib_strategy; // r11
  unsigned int v13; // r1
  bool v14; // cc
  png_uint_32 flags; // r1
  int zlib_set_level; // r0
  bool v17; // zf
  int zlib_set_window_bits; // r0
  bool v19; // zf
  int v20; // r10
  z_stream *p_zstream; // r0
  unsigned __int8 buffer[4]; // [sp+10h] [bp-60h] BYREF
  __int16 v24; // [sp+14h] [bp-5Ch]
  char v25; // [sp+16h] [bp-5Ah]
  char v26; // [sp+17h] [bp-59h]
  char v27; // [sp+18h] [bp-58h]
  char v28; // [sp+19h] [bp-57h]

  zowner = png_ptr->zowner;
  if ( !zowner )
  {
LABEL_5:
    if ( owner == 1229209940 )
    {
      zlib_method = png_ptr->zlib_method;
      zlib_level = png_ptr->zlib_level;
      zlib_mem_level = png_ptr->zlib_mem_level;
      zlib_window_bits = png_ptr->zlib_window_bits;
      if ( LOBYTE(png_ptr->flags) << 31 )
      {
        zlib_strategy = png_ptr->zlib_strategy;
        if ( data_size > 0x4000 )
          goto LABEL_15;
      }
      else
      {
        zlib_strategy = png_ptr->do_filter != 8;
        if ( data_size > 0x4000 )
          goto LABEL_15;
      }
    }
    else
    {
      zlib_method = png_ptr->zlib_text_method;
      zlib_level = png_ptr->zlib_text_level;
      zlib_mem_level = png_ptr->zlib_text_mem_level;
      zlib_window_bits = png_ptr->zlib_text_window_bits;
      zlib_strategy = png_ptr->zlib_text_strategy;
      if ( data_size > 0x4000 )
        goto LABEL_15;
    }
    v13 = 1 << (zlib_window_bits - 1);
    if ( data_size + 262 <= v13 )
    {
      do
      {
        --zlib_window_bits;
        v14 = data_size + 262 > v13 >> 1;
        v13 >>= 1;
      }
      while ( !v14 );
    }
LABEL_15:
    flags = png_ptr->flags;
    if ( (flags & 2) != 0 )
    {
      zlib_set_level = png_ptr->zlib_set_level;
      v17 = zlib_set_level == zlib_level;
      if ( zlib_set_level == zlib_level )
        v17 = png_ptr->zlib_set_method == zlib_method;
      if ( !v17 )
        goto LABEL_23;
      zlib_set_window_bits = png_ptr->zlib_set_window_bits;
      v19 = zlib_set_window_bits == zlib_window_bits;
      if ( zlib_set_window_bits == zlib_window_bits )
        v19 = png_ptr->zlib_set_mem_level == zlib_mem_level;
      if ( !v19 || png_ptr->zlib_set_strategy != zlib_strategy )
      {
LABEL_23:
        v20 = zlib_mem_level;
        if ( j_deflateEnd((z_streamp)&png_ptr->zstream) )
          j_png_warning(png_ptr, (png_const_charp)"deflateEnd failed (ignored)");
        zlib_mem_level = v20;
        flags = png_ptr->flags & 0xFFFFFFFD;
        png_ptr->flags = flags;
      }
    }
    png_ptr->zstream.next_out = 0;
    png_ptr->zstream.avail_out = 0;
    png_ptr->zstream.next_in = 0;
    png_ptr->zstream.avail_in = 0;
    p_zstream = &png_ptr->zstream;
    if ( (flags & 2) != 0 )
    {
      v7 = j_deflateReset((z_streamp)p_zstream);
      if ( !v7 )
        goto LABEL_31;
    }
    else
    {
      v7 = j_deflateInit2_(
             (z_streamp)p_zstream,
             zlib_level,
             zlib_method,
             zlib_window_bits,
             zlib_mem_level,
             zlib_strategy,
             "1.1.3",
             56);
      if ( !v7 )
      {
        png_ptr->flags |= 2u;
LABEL_31:
        png_ptr->zowner = owner;
        return 0;
      }
    }
    j_png_zstream_error(png_ptr, v7);
    return v7;
  }
  buffer[3] = owner;
  v24 = 8250;
  v28 = zowner;
  buffer[1] = BYTE2(owner);
  buffer[0] = HIBYTE(owner);
  buffer[2] = BYTE1(owner);
  v25 = HIBYTE(zowner);
  v26 = BYTE2(zowner);
  v27 = BYTE1(zowner);
  j_png_safecat(buffer, 0x40u, 0xAu, (png_const_charp)" using zstream");
  j_png_warning(png_ptr, buffer);
  if ( png_ptr->zowner != 1229209940 )
  {
    png_ptr->zowner = 0;
    goto LABEL_5;
  }
  png_ptr->zstream.msg = "in use by IDAT";
  return -2;
}

//----- (00206D08) --------------------------------------------------------
png_alloc_size_t __fastcall png_image_size(png_structrp_12 png_ptr)
{
  png_uint_32 height; // r1
  png_size_t rowbytes; // r2
  unsigned int pixel_depth; // r8
  png_uint_32 v4; // lr
  int v5; // r5
  png_uint_32 v6; // r11
  png_alloc_size_t result; // r0
  int v8; // r1
  unsigned int v9; // r5
  bool v10; // zf
  bool v11; // vf
  int v12; // r4
  int v13; // r1
  int v14; // r6
  unsigned int v15; // r3
  int v16; // r1
  int v17; // r4
  int v18; // r6
  int v19; // r2
  unsigned int v20; // r3
  unsigned int v21; // r4

  height = png_ptr->height;
  rowbytes = png_ptr->rowbytes;
  if ( (rowbytes | height) >> 15 )
    return -1;
  if ( !png_ptr->interlaced )
    return (rowbytes + 1) * height;
  pixel_depth = png_ptr->pixel_depth;
  v4 = height - 1;
  v5 = 0;
  v6 = png_ptr->width - 1;
  result = 0;
LABEL_11:
  v16 = 7 - v5;
  while ( v5 <= 6 )
  {
    LOBYTE(v17) = 3;
    if ( v5 > 1 )
      v17 = v16 >> 1;
    v18 = v5 & 1;
    v19 = v5 + 1;
    --v16;
    v20 = v6 + (1 << v17) - ((v18 << (3 - (++v5 >> 1))) & 7);
    v21 = v20 >> v17;
    if ( v21 )
    {
      v8 = v19 - 1;
      if ( pixel_depth < 8 )
        v9 = (v21 * pixel_depth + 7) >> 3;
      else
        v9 = v21 * (pixel_depth >> 3);
      v11 = __OFSUB__(v8, 2);
      v10 = v8 == 2;
      LOBYTE(v12) = 3;
      v13 = 3 - (v8 >> 1);
      v14 = v18 ^ 1;
      if ( !((v19 - 3 < 0) ^ v11 | v10) )
        v12 = (9 - v19) >> 1;
      v15 = v9 + 1;
      v5 = v19;
      result += v15 * (((1 << v12) + v4 - ((v14 << v13) & 7)) >> v12);
      goto LABEL_11;
    }
  }
  return result;
}

//----- (00206DE8) --------------------------------------------------------
void __fastcall png_write_IEND(png_structrp_12 png_ptr)
{
  png_uint_32 crc; // r0
  png_byte data[4]; // [sp+4h] [bp-14h] BYREF
  int v4; // [sp+8h] [bp-10h] BYREF

  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    *(_DWORD *)data = 0;
    v4 = 1145980233;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1229278788;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v4, 4u);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    data[3] = crc;
    data[1] = BYTE2(crc);
    data[0] = HIBYTE(crc);
    data[2] = BYTE1(crc);
    j_png_write_data(png_ptr, data, 4u);
  }
  png_ptr->mode |= 0x10u;
}

//----- (00206E90) --------------------------------------------------------
void __fastcall png_write_gAMA_fixed(png_structrp_12 png_ptr, png_fixed_point file_gamma)
{
  png_uint_32 crc; // r0
  png_byte v4[4]; // [sp+0h] [bp-18h] BYREF
  png_byte data[4]; // [sp+4h] [bp-14h] BYREF
  int v6; // [sp+8h] [bp-10h] BYREF

  v4[1] = BYTE2(file_gamma);
  v4[0] = HIBYTE(file_gamma);
  v4[2] = BYTE1(file_gamma);
  v4[3] = file_gamma;
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    *(_DWORD *)data = 0x4000000;
    v6 = 1095582055;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1732332865;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v6, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, v4, 4u);
    j_png_calculate_crc(png_ptr, v4, 4u);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    data[3] = crc;
    data[1] = BYTE2(crc);
    data[0] = HIBYTE(crc);
    data[2] = BYTE1(crc);
    j_png_write_data(png_ptr, data, 4u);
  }
}

//----- (00206F64) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_write_sRGB(png_structrp_12 png_ptr, int srgb_intent)
{
  png_byte v3; // r5
  png_uint_32 crc; // r0
  png_byte v5; // [sp+3h] [bp-15h] BYREF
  png_byte data[4]; // [sp+4h] [bp-14h] BYREF
  int v7; // [sp+8h] [bp-10h] OVERLAPPED BYREF

  v3 = srgb_intent;
  if ( srgb_intent >= 4 )
    j_png_warning(png_ptr, (png_const_charp)"Invalid sRGB rendering intent specified");
  v5 = v3;
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    *(_DWORD *)data = 0x1000000;
    v7 = 1111970419;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1934772034;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v7, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, &v5, 1u);
    j_png_calculate_crc(png_ptr, &v5, 1u);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    data[3] = crc;
    data[1] = BYTE2(crc);
    data[0] = HIBYTE(crc);
    data[2] = BYTE1(crc);
    j_png_write_data(png_ptr, data, 4u);
  }
}
// 206F64: variables would overlap: ^8.4 and stkvar "buf" ^B.1(has user info)

//----- (00207058) --------------------------------------------------------
void __fastcall png_write_iCCP(png_structrp_12 png_ptr, png_const_charp name, png_const_bytep profile)
{
  png_alloc_size_t v5; // r4
  png_uint_32 v6; // r0
  png_size_t v7; // r6
  png_uint_32 output_len; // r0
  png_uint_32 v9; // r0
  int v10; // r9
  png_uint_32 v11; // r4
  png_compression_bufferp *p_zbuffer_list; // r6
  png_byte *output; // r8
  png_size_t zbuffer_size; // r5
  int v15; // r0
  bool v16; // zf
  png_uint_32 crc; // r0
  compression_state comp; // [sp+4h] [bp-484h] BYREF
  png_byte new_key[8]; // [sp+413h] [bp-75h] BYREF
  png_byte new_name[81]; // [sp+41Bh] [bp-6Dh] BYREF

  if ( !profile )
  {
    j_png_error(png_ptr, (png_const_charp)"No profile for iCCP chunk");
    goto LABEL_28;
  }
  v5 = _byteswap_ulong(*(_DWORD *)profile);
  if ( v5 <= 0x83 )
  {
LABEL_28:
    j_png_error(png_ptr, (png_const_charp)"ICC profile too short");
LABEL_29:
    j_png_error(png_ptr, (png_const_charp)"ICC profile length invalid (not a multiple of 4)");
    goto LABEL_30;
  }
  if ( profile[3] << 30 && profile[8] >= 4u )
    goto LABEL_29;
  v6 = j_png_check_keyword(png_ptr, name, new_key);
  if ( !v6 )
  {
LABEL_30:
    j_png_error(png_ptr, (png_const_charp)"iCCP: invalid keyword");
    goto LABEL_31;
  }
  v7 = v6 + 2;
  new_key[v6 + 1] = 0;
  comp.input = profile;
  comp.input_len = v5;
  comp.output_len = 0;
  if ( png_text_compress(png_ptr, 0x69434350u, &comp, v6 + 2) )
  {
LABEL_31:
    j_png_error(png_ptr, png_ptr->zstream.msg);
    goto LABEL_32;
  }
  if ( png_ptr )
  {
    output_len = comp.output_len;
    png_ptr->io_state = 34;
    v9 = output_len + v7;
    new_name[74] = BYTE2(v9);
    new_name[73] = HIBYTE(v9);
    new_name[75] = BYTE1(v9);
    new_name[76] = v9;
    *(_DWORD *)&new_name[77] = 1346585449;
    j_png_write_data(png_ptr, &new_name[73], 8u);
    png_ptr->chunk_name = 1766015824;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, &new_name[77], 4u);
    png_ptr->io_state = 66;
    if ( v7 )
    {
      j_png_write_data(png_ptr, new_key, v7);
      j_png_calculate_crc(png_ptr, new_key, v7);
    }
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  v11 = comp.output_len;
  p_zbuffer_list = &png_ptr->zbuffer_list;
  output = comp.output;
  zbuffer_size = 1024;
  while ( 1 )
  {
    if ( zbuffer_size > v11 )
      zbuffer_size = v11;
    p_zbuffer_list = (png_compression_bufferp *)*p_zbuffer_list;
    v15 = zbuffer_size;
    if ( zbuffer_size )
      v15 = 1;
    if ( (v15 & v10) == 1 )
    {
      j_png_write_data(png_ptr, output, zbuffer_size);
      j_png_calculate_crc(png_ptr, output, zbuffer_size);
    }
    v11 -= zbuffer_size;
    v16 = p_zbuffer_list == 0;
    if ( p_zbuffer_list )
      v16 = v11 == 0;
    if ( v16 )
      break;
    zbuffer_size = png_ptr->zbuffer_size;
    output = (png_byte *)(p_zbuffer_list + 1);
  }
  if ( v11 )
  {
LABEL_32:
    j_png_error(png_ptr, (png_const_charp)"error writing ancillary chunked compressed data");
    JUMPOUT(0x207234);
  }
  if ( png_ptr )
  {
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    new_name[76] = crc;
    new_name[74] = BYTE2(crc);
    new_name[73] = HIBYTE(crc);
    new_name[75] = BYTE1(crc);
    j_png_write_data(png_ptr, &new_name[73], 4u);
  }
}
// 207230: control flows out of bounds to 207234
// 207058: using guessed type png_byte new_key[8];

//----- (002072C0) --------------------------------------------------------
int __fastcall png_text_compress(
        png_structrp_12 png_ptr,
        png_uint_32 chunk_name,
        compression_state *comp,
        png_uint_32 prefix_len)
{
  int v7; // r6
  png_const_bytep input; // r0
  png_alloc_size_t input_len; // r8
  png_compression_bufferp *p_zbuffer_list; // r11
  uInt avail_out; // r1
  int v12; // r10
  int v13; // r0
  png_compression_buffer *v14; // r0
  uInt zbuffer_size; // r1
  int v16; // r0
  bool v17; // zf
  png_alloc_size_t v18; // r0
  unsigned int v19; // r1
  char v20; // r2
  unsigned int v21; // r6
  unsigned int v22; // r1
  png_byte v23; // r2
  int v24; // r3
  unsigned int v25; // r6
  png_byte v26; // r0
  png_byte *output; // [sp+4h] [bp-24h]

  v7 = png_deflate_claim(png_ptr, chunk_name, comp->input_len);
  if ( v7 )
    return v7;
  input_len = comp->input_len;
  input = comp->input;
  p_zbuffer_list = &png_ptr->zbuffer_list;
  avail_out = 1024;
  v12 = 1024;
  output = comp->output;
  png_ptr->zstream.next_out = comp->output;
  png_ptr->zstream.avail_out = 1024;
  *(_QWORD *)&png_ptr->zstream.next_in = (unsigned int)input;
  do
  {
    png_ptr->zstream.avail_in = input_len;
    if ( !avail_out )
    {
      if ( (int)(v12 + prefix_len) < 0 )
        goto LABEL_3;
      v14 = *p_zbuffer_list;
      if ( !*p_zbuffer_list )
      {
        v14 = (png_compression_buffer *)j_png_malloc_base(png_ptr, png_ptr->zbuffer_size + 4);
        if ( !v14 )
        {
LABEL_3:
          input_len = 0;
          v13 = 2;
          v7 = -4;
          goto LABEL_11;
        }
        v14->next = 0;
        *p_zbuffer_list = v14;
      }
      zbuffer_size = png_ptr->zbuffer_size;
      p_zbuffer_list = &v14->next;
      v12 += zbuffer_size;
      png_ptr->zstream.next_out = v14->output;
      png_ptr->zstream.avail_out = zbuffer_size;
    }
    v16 = j_deflate((z_streamp)&png_ptr->zstream, 4);
    input_len = png_ptr->zstream.avail_in;
    v7 = v16;
    v13 = 0;
    png_ptr->zstream.avail_in = 0;
LABEL_11:
    avail_out = png_ptr->zstream.avail_out;
  }
  while ( !(v13 | v7) );
  png_ptr->zstream.avail_out = 0;
  comp->output_len = v12 - avail_out;
  if ( v12 - avail_out + prefix_len >= 0x7FFFFFFF )
  {
    png_ptr->zowner = 0;
    png_ptr->zstream.msg = "compressed data too long";
    return -4;
  }
  j_png_zstream_error(png_ptr, v7);
  v17 = v7 == 1;
  png_ptr->zowner = 0;
  if ( v7 == 1 )
    v17 = input_len == 0;
  if ( v17 )
  {
    v18 = comp->input_len;
    if ( v18 <= 0x4000 )
    {
      v7 = 0;
      v19 = *output;
      if ( (v19 & 0xF) != 8 )
        return v7;
      v20 = v19 & 0xF0;
      if ( (v19 & 0xF0) > 0x70 )
        return v7;
      v21 = v19 >> 4;
      v22 = 128 << (*output >> 4);
      if ( v22 >= v18 )
      {
        v23 = v20 + 8;
        v24 = (v21 << 12) | 0x800;
        v25 = 1 - v21;
        do
        {
          v23 -= 16;
          v24 -= 4096;
          if ( !v25 )
            break;
          ++v25;
          v22 >>= 1;
        }
        while ( v22 >= v18 );
        v26 = comp->output[1];
        comp->output[0] = v23;
        comp->output[1] = (v26 & 0xE0 | ((v24 | v26 & 0xE0u) % 0x1F)) ^ 0x1F;
      }
    }
    return 0;
  }
  return v7;
}

//----- (00207454) --------------------------------------------------------
void __fastcall png_write_sPLT(png_structrp_12 png_ptr, png_const_sPLT_tp spalette)
{
  int depth; // r5
  png_int_32 nentries; // r4
  png_uint_32 v6; // r6
  int v7; // r0
  png_size_t v8; // r6
  int v9; // r9
  png_int_32 v10; // r0
  png_sPLT_entryp entries; // r1
  png_uint_16 *p_blue; // r4
  png_uint_16 *v13; // r8
  int v14; // r5
  int v15; // r2
  png_uint_16 v16; // r3
  __int16 v17; // kr00_2
  __int16 v18; // r2
  png_uint_16 v19; // r2
  png_uint_16 v20; // r3
  png_uint_32 crc; // r0
  png_size_t length; // [sp+0h] [bp-88h]
  png_byte *p_depth; // [sp+4h] [bp-84h]
  png_byte v24[4]; // [sp+Ah] [bp-7Eh] BYREF
  png_byte data; // [sp+Eh] [bp-7Ah] BYREF
  char v26; // [sp+Fh] [bp-79h]
  char v27; // [sp+10h] [bp-78h]
  char v28; // [sp+11h] [bp-77h]
  int v29; // [sp+12h] [bp-76h] BYREF
  png_byte entrybuf[10]; // [sp+16h] [bp-72h] BYREF

  depth = spalette->depth;
  nentries = spalette->nentries;
  p_depth = &spalette->depth;
  v6 = j_png_check_keyword(png_ptr, spalette->name, &entrybuf[2]);
  v7 = 10;
  if ( depth == 8 )
    v7 = 6;
  length = v7;
  if ( !v6 )
  {
    j_png_error(png_ptr, (png_const_charp)"sPLT: invalid keyword");
    JUMPOUT(0x207638);
  }
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    v26 = (v6 + v7 * nentries + 2) >> 16;
    data = (v6 + v7 * nentries + 2) >> 24;
    v27 = (unsigned __int16)(v6 + v7 * nentries + 2) >> 8;
    v28 = v6 + v7 * nentries + 2;
    v29 = 1414287475;
    j_png_write_data(png_ptr, &data, 8u);
    png_ptr->chunk_name = 1934642260;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v29, 4u);
    v8 = v6 + 1;
    png_ptr->io_state = 66;
    if ( v8 )
    {
      j_png_write_data(png_ptr, &entrybuf[2], v8);
      j_png_calculate_crc(png_ptr, &entrybuf[2], v8);
    }
    v9 = 1;
    j_png_write_data(png_ptr, p_depth, 1u);
    j_png_calculate_crc(png_ptr, p_depth, 1u);
  }
  else
  {
    v9 = 0;
  }
  v10 = spalette->nentries;
  if ( v10 >= 1 )
  {
    entries = spalette->entries;
    p_blue = &entries->blue;
    do
    {
      v13 = p_blue - 2;
      if ( *p_depth == 8 )
      {
        data = *(p_blue - 2);
        v14 = 3;
        v26 = *((_BYTE *)p_blue - 2);
        v27 = *(_BYTE *)p_blue;
        v15 = 4;
        v16 = p_blue[1];
      }
      else
      {
        v17 = *(p_blue - 2);
        data = HIBYTE(v17);
        v26 = v17;
        v14 = 7;
        v18 = *(p_blue - 1);
        v27 = HIBYTE(v18);
        v28 = v18;
        v19 = *p_blue;
        BYTE1(v29) = *p_blue;
        LOBYTE(v29) = HIBYTE(v19);
        v16 = p_blue[1];
        BYTE2(v29) = HIBYTE(v16);
        v15 = 8;
      }
      *(&data + v14) = v16;
      v20 = p_blue[2];
      *(&data + v15) = HIBYTE(v20);
      *(&data + v15 + 1) = v20;
      if ( v9 == 1 )
      {
        j_png_write_data(png_ptr, &data, length);
        j_png_calculate_crc(png_ptr, &data, length);
        v10 = spalette->nentries;
        entries = spalette->entries;
      }
      p_blue += 5;
    }
    while ( v13 + 5 < &entries[v10].red );
  }
  if ( png_ptr )
  {
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    v24[3] = crc;
    v24[1] = BYTE2(crc);
    v24[0] = HIBYTE(crc);
    v24[2] = BYTE1(crc);
    j_png_write_data(png_ptr, v24, 4u);
  }
}
// 207634: control flows out of bounds to 207638

//----- (00207658) --------------------------------------------------------
void __fastcall png_write_sBIT(png_structrp_12 png_ptr, png_const_color_8p sbit, int color_type)
{
  unsigned int gray; // r0
  png_size_t v5; // r5
  int v6; // r6
  unsigned int usr_bit_depth; // r3
  png_byte red; // r6
  unsigned int alpha; // r0
  png_uint_32 crc; // r0
  png_byte v11[4]; // [sp+0h] [bp-20h] BYREF
  png_byte data; // [sp+4h] [bp-1Ch] BYREF
  char v13; // [sp+5h] [bp-1Bh]
  char v14; // [sp+6h] [bp-1Ah]
  char v15; // [sp+7h] [bp-19h]
  int v16; // [sp+8h] [bp-18h] BYREF

  if ( (color_type & 2) != 0 )
  {
    if ( color_type == 3 )
      usr_bit_depth = 8;
    else
      usr_bit_depth = png_ptr->usr_bit_depth;
    red = sbit->red;
    if ( (unsigned __int8)(sbit->red - 1) >= usr_bit_depth )
      goto LABEL_17;
    if ( (unsigned __int8)(sbit->green - 1) >= usr_bit_depth )
      goto LABEL_17;
    LOBYTE(gray) = sbit->blue;
    if ( (unsigned __int8)(gray - 1) >= usr_bit_depth )
      goto LABEL_17;
    v11[1] = sbit->green;
    v5 = 3;
    v11[0] = red;
    v6 = 2;
  }
  else
  {
    gray = sbit->gray;
    if ( !sbit->gray || gray > png_ptr->usr_bit_depth )
      goto LABEL_17;
    v5 = 1;
    v6 = 0;
  }
  v11[v6] = gray;
  if ( (color_type & 4) != 0 )
  {
    alpha = sbit->alpha;
    if ( sbit->alpha && alpha <= png_ptr->usr_bit_depth )
    {
      v11[v5++] = alpha;
      goto LABEL_19;
    }
LABEL_17:
    j_png_warning(png_ptr, (png_const_charp)"Invalid sBIT depth specified");
    return;
  }
  if ( png_ptr )
  {
LABEL_19:
    png_ptr->io_state = 34;
    v13 = BYTE2(v5);
    data = HIBYTE(v5);
    v14 = BYTE1(v5);
    v15 = v5;
    v16 = 1414087283;
    j_png_write_data(png_ptr, &data, 8u);
    png_ptr->chunk_name = 1933723988;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v16, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, v11, v5);
    j_png_calculate_crc(png_ptr, v11, v5);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    v15 = crc;
    v13 = BYTE2(crc);
    data = HIBYTE(crc);
    v14 = BYTE1(crc);
    j_png_write_data(png_ptr, &data, 4u);
  }
}

//----- (002077B8) --------------------------------------------------------
void __fastcall png_write_cHRM_fixed(png_structrp_12 png_ptr, const png_xy_0 *xy)
{
  png_uint_32 crc; // r0
  png_byte buf[4]; // [sp+4h] [bp-3Ch] BYREF
  png_byte v6[4]; // [sp+8h] [bp-38h] BYREF
  png_byte v7[4]; // [sp+Ch] [bp-34h] BYREF
  png_byte v8[4]; // [sp+10h] [bp-30h] BYREF
  png_byte v9[4]; // [sp+14h] [bp-2Ch] BYREF
  png_byte v10[4]; // [sp+18h] [bp-28h] BYREF
  png_byte v11[4]; // [sp+1Ch] [bp-24h] BYREF
  png_byte v12[4]; // [sp+20h] [bp-20h] BYREF
  png_byte data[4]; // [sp+24h] [bp-1Ch] BYREF
  int v14; // [sp+28h] [bp-18h] BYREF

  j_png_save_int_32(buf, xy->whitex);
  j_png_save_int_32(v6, xy->whitey);
  j_png_save_int_32(v7, xy->redx);
  j_png_save_int_32(v8, xy->redy);
  j_png_save_int_32(v9, xy->greenx);
  j_png_save_int_32(v10, xy->greeny);
  j_png_save_int_32(v11, xy->bluex);
  j_png_save_int_32(v12, xy->bluey);
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    *(_DWORD *)data = 0x20000000;
    v14 = 1297238115;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1665684045;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v14, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, buf, 0x20u);
    j_png_calculate_crc(png_ptr, buf, 0x20u);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    data[3] = crc;
    data[1] = BYTE2(crc);
    data[0] = HIBYTE(crc);
    data[2] = BYTE1(crc);
    j_png_write_data(png_ptr, data, 4u);
  }
}
// 2077B8: using guessed type png_byte buf[4];
// 2077B8: using guessed type png_byte anonymous_0[4];
// 2077B8: using guessed type png_byte anonymous_1[4];
// 2077B8: using guessed type png_byte anonymous_2[4];
// 2077B8: using guessed type png_byte anonymous_3[4];
// 2077B8: using guessed type png_byte anonymous_4[4];
// 2077B8: using guessed type png_byte anonymous_5[4];
// 2077B8: using guessed type png_byte anonymous_6[4];

//----- (002078C8) --------------------------------------------------------
void __fastcall png_write_tRNS(
        png_structrp_12 png_ptr,
        png_const_bytep trans_alpha,
        png_const_color_16p tran,
        int num_trans,
        int color_type)
{
  bool v8; // cc
  const char *v9; // r1
  png_uint_16 gray; // kr00_2
  png_struct *v11; // r0
  const png_byte *v12; // r1
  int v13; // r2
  unsigned int red; // r0
  int bit_depth; // r3
  unsigned int v16; // r0
  unsigned int green; // r1
  unsigned int v18; // r1
  unsigned int blue; // r2
  unsigned int v20; // r2
  png_uint_32 crc; // r0
  png_byte v22; // [sp+6h] [bp-2Ah] BYREF
  char v23; // [sp+7h] [bp-29h]
  char v24; // [sp+8h] [bp-28h]
  char v25; // [sp+9h] [bp-27h]
  char v26; // [sp+Ah] [bp-26h]
  char v27; // [sp+Bh] [bp-25h]
  png_byte data[4]; // [sp+Ch] [bp-24h] BYREF
  int v29; // [sp+10h] [bp-20h] BYREF

  if ( !color_type )
  {
    if ( 1 << png_ptr->bit_depth > tran->gray )
    {
      gray = tran->gray;
      v22 = HIBYTE(gray);
      v23 = gray;
      png_ptr->io_state = 34;
      *(_DWORD *)data = 0x2000000;
      v29 = 1397641844;
      j_png_write_data(png_ptr, data, 8u);
      png_ptr->chunk_name = 1951551059;
      j_png_reset_crc(png_ptr);
      j_png_calculate_crc(png_ptr, (png_const_bytep)&v29, 4u);
      png_ptr->io_state = 66;
      j_png_write_data(png_ptr, &v22, 2u);
      v11 = png_ptr;
      v12 = &v22;
      v13 = 2;
      goto LABEL_20;
    }
    v9 = "Ignoring attempt to write tRNS chunk out-of-range for bit_depth";
LABEL_17:
    j_png_app_warning(png_ptr, (png_const_charp)v9);
    return;
  }
  if ( color_type == 2 )
  {
    red = tran->red;
    v23 = tran->red;
    bit_depth = png_ptr->bit_depth;
    v16 = red >> 8;
    v22 = v16;
    green = tran->green;
    v25 = tran->green;
    v18 = green >> 8;
    v24 = v18;
    blue = tran->blue;
    v27 = blue;
    v20 = blue >> 8;
    v26 = v20;
    if ( bit_depth != 8 || !(v16 | v18 | v20) )
    {
      png_ptr->io_state = 34;
      *(_DWORD *)data = 100663296;
      v29 = 1397641844;
      j_png_write_data(png_ptr, data, 8u);
      png_ptr->chunk_name = 1951551059;
      j_png_reset_crc(png_ptr);
      j_png_calculate_crc(png_ptr, (png_const_bytep)&v29, 4u);
      png_ptr->io_state = 66;
      j_png_write_data(png_ptr, &v22, 6u);
      v11 = png_ptr;
      v12 = &v22;
      v13 = 6;
      goto LABEL_20;
    }
    v9 = "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8";
    goto LABEL_17;
  }
  if ( color_type != 3 )
  {
    v9 = "Can't write tRNS with an alpha channel";
    goto LABEL_17;
  }
  v8 = num_trans < 1;
  if ( num_trans >= 1 )
    v8 = png_ptr->num_palette < num_trans;
  if ( v8 )
  {
    v9 = "Invalid number of transparent colors specified";
    goto LABEL_17;
  }
  png_ptr->io_state = 34;
  data[1] = BYTE2(num_trans);
  data[0] = HIBYTE(num_trans);
  data[2] = BYTE1(num_trans);
  data[3] = num_trans;
  v29 = 1397641844;
  j_png_write_data(png_ptr, data, 8u);
  png_ptr->chunk_name = 1951551059;
  j_png_reset_crc(png_ptr);
  j_png_calculate_crc(png_ptr, (png_const_bytep)&v29, 4u);
  png_ptr->io_state = 66;
  if ( !trans_alpha )
    goto LABEL_21;
  j_png_write_data(png_ptr, trans_alpha, num_trans);
  v11 = png_ptr;
  v12 = trans_alpha;
  v13 = num_trans;
LABEL_20:
  j_png_calculate_crc(v11, v12, v13);
LABEL_21:
  crc = png_ptr->crc;
  png_ptr->io_state = 130;
  data[3] = crc;
  data[1] = BYTE2(crc);
  data[0] = HIBYTE(crc);
  data[2] = BYTE1(crc);
  j_png_write_data(png_ptr, data, 4u);
}

//----- (00207B50) --------------------------------------------------------
void __fastcall png_write_bKGD(png_structrp_12 png_ptr, png_const_color_16p back, int color_type)
{
  unsigned int num_palette; // r0
  const char *v5; // r1
  png_uint_16 gray; // kr00_2
  png_struct *v7; // r0
  png_size_t v8; // r2
  unsigned int red; // r0
  int bit_depth; // r3
  unsigned int v11; // r0
  unsigned int green; // r2
  unsigned int v13; // r2
  unsigned int blue; // r1
  unsigned int v15; // r1
  png_uint_32 crc; // r0
  png_byte v17; // [sp+6h] [bp-22h] BYREF
  char v18; // [sp+7h] [bp-21h]
  char v19; // [sp+8h] [bp-20h]
  char v20; // [sp+9h] [bp-1Fh]
  char v21; // [sp+Ah] [bp-1Eh]
  char v22; // [sp+Bh] [bp-1Dh]
  png_byte data[4]; // [sp+Ch] [bp-1Ch] BYREF
  int v24; // [sp+10h] [bp-18h] BYREF

  if ( color_type == 3 )
  {
    num_palette = png_ptr->num_palette;
    if ( !png_ptr->num_palette && LOBYTE(png_ptr->mng_features_permitted) << 31 )
    {
      LOBYTE(back) = back->index;
    }
    else
    {
      back = (png_const_color_16p)back->index;
      if ( (unsigned int)back >= num_palette )
      {
        v5 = "Invalid background palette index";
LABEL_14:
        j_png_warning(png_ptr, (png_const_charp)v5);
        return;
      }
    }
    png_ptr->io_state = 34;
    *(_DWORD *)data = 0x1000000;
    v17 = (unsigned __int8)back;
    v24 = 1145523042;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1649100612;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v24, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, &v17, 1u);
    v7 = png_ptr;
    v8 = 1;
  }
  else if ( (color_type & 2) != 0 )
  {
    red = back->red;
    v18 = back->red;
    bit_depth = png_ptr->bit_depth;
    v11 = red >> 8;
    v17 = v11;
    green = back->green;
    v20 = back->green;
    v13 = green >> 8;
    v19 = v13;
    blue = back->blue;
    v22 = blue;
    v15 = blue >> 8;
    v21 = v15;
    if ( bit_depth == 8 && v11 | v13 | v15 )
    {
      v5 = "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8";
      goto LABEL_14;
    }
    png_ptr->io_state = 34;
    *(_DWORD *)data = 100663296;
    v24 = 1145523042;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1649100612;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v24, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, &v17, 6u);
    v7 = png_ptr;
    v8 = 6;
  }
  else
  {
    if ( 1 << png_ptr->bit_depth <= back->gray )
    {
      v5 = "Ignoring attempt to write bKGD chunk out-of-range for bit_depth";
      goto LABEL_14;
    }
    gray = back->gray;
    v17 = HIBYTE(gray);
    v18 = gray;
    png_ptr->io_state = 34;
    *(_DWORD *)data = 0x2000000;
    v24 = 1145523042;
    j_png_write_data(png_ptr, data, 8u);
    png_ptr->chunk_name = 1649100612;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v24, 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, &v17, 2u);
    v7 = png_ptr;
    v8 = 2;
  }
  j_png_calculate_crc(v7, &v17, v8);
  crc = png_ptr->crc;
  png_ptr->io_state = 130;
  data[3] = crc;
  data[1] = BYTE2(crc);
  data[0] = HIBYTE(crc);
  data[2] = BYTE1(crc);
  j_png_write_data(png_ptr, data, 4u);
}

//----- (00207DC0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_write_eXIf(png_structrp_12 png_ptr, png_bytep exif, int num_exif)
{
  int v4; // r5
  png_uint_32 crc; // r0
  png_byte v7; // [sp+3h] [bp-1Dh] BYREF
  png_byte data; // [sp+4h] [bp-1Ch] BYREF
  char v9; // [sp+5h] [bp-1Bh]
  char v10; // [sp+6h] [bp-1Ah]
  char v11; // [sp+7h] [bp-19h]
  int v12; // [sp+8h] [bp-18h] OVERLAPPED BYREF

  v4 = num_exif;
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    v9 = BYTE2(num_exif);
    data = HIBYTE(num_exif);
    v10 = BYTE1(num_exif);
    v11 = num_exif;
    v12 = 1716082789;
    j_png_write_data(png_ptr, &data, 8u);
    png_ptr->chunk_name = 1700284774;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v12, 4u);
    png_ptr->io_state = 66;
  }
  if ( v4 >= 1 )
  {
    do
    {
      v7 = *exif;
      if ( png_ptr )
      {
        j_png_write_data(png_ptr, &v7, 1u);
        j_png_calculate_crc(png_ptr, &v7, 1u);
      }
      --v4;
      ++exif;
    }
    while ( v4 );
  }
  if ( png_ptr )
  {
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    v11 = crc;
    v9 = BYTE2(crc);
    data = HIBYTE(crc);
    v10 = BYTE1(crc);
    j_png_write_data(png_ptr, &data, 4u);
  }
}
// 207DC0: variables would overlap: ^8.4 and stkvar "buf" ^B.1(has user info)

//----- (00207EB4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_write_hIST(png_structrp_12 png_ptr, png_const_uint_16p hist, int num_hist)
{
  int v4; // r5
  __int16 v6; // t1
  png_uint_32 crc; // r0
  png_byte v8[3]; // [sp+1h] [bp-1Fh] BYREF
  png_byte data; // [sp+4h] [bp-1Ch] BYREF
  char v10; // [sp+5h] [bp-1Bh]
  char v11; // [sp+6h] [bp-1Ah]
  char v12; // [sp+7h] [bp-19h]
  int v13; // [sp+8h] [bp-18h] OVERLAPPED BYREF

  v4 = num_hist;
  if ( png_ptr->num_palette >= num_hist )
  {
    png_ptr->io_state = 34;
    v10 = (unsigned int)num_hist >> 15;
    data = (unsigned int)num_hist >> 23;
    v11 = (unsigned int)num_hist >> 7;
    v12 = 2 * num_hist;
    v13 = 1414744424;
    j_png_write_data(png_ptr, &data, 8u);
    png_ptr->chunk_name = 1749635924;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, (png_const_bytep)&v13, 4u);
    png_ptr->io_state = 66;
    if ( v4 >= 1 )
    {
      do
      {
        v6 = *hist++;
        v8[0] = HIBYTE(v6);
        v8[1] = v6;
        j_png_write_data(png_ptr, v8, 2u);
        j_png_calculate_crc(png_ptr, v8, 2u);
        --v4;
      }
      while ( v4 );
    }
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    v12 = crc;
    v10 = BYTE2(crc);
    data = HIBYTE(crc);
    v11 = BYTE1(crc);
    j_png_write_data(png_ptr, &data, 4u);
  }
  else
  {
    j_png_warning(png_ptr, (png_const_charp)"Invalid number of histogram entries specified");
  }
}
// 207EB4: variables would overlap: ^8.4 and stkvar "buf" ^9.3(has user info)

//----- (00207FE4) --------------------------------------------------------
void __fastcall png_write_tEXt(png_structrp_12 png_ptr, png_const_charp key, png_const_charp text, png_size_t text_len)
{
  png_uint_32 v6; // r5
  size_t v7; // r6
  png_size_t v8; // r5
  bool v9; // zf
  png_uint_32 crc; // r0
  png_byte new_key[80]; // [sp+4h] [bp-74h] BYREF
  png_byte data; // [sp+54h] [bp-24h] BYREF
  char v13; // [sp+55h] [bp-23h]
  char v14; // [sp+56h] [bp-22h]
  char v15; // [sp+57h] [bp-21h]
  int v16; // [sp+58h] [bp-20h] BYREF

  v6 = j_png_check_keyword(png_ptr, key, new_key);
  if ( !v6 )
  {
    j_png_error(png_ptr, (png_const_charp)"tEXt: invalid keyword");
    goto LABEL_17;
  }
  if ( !text || !*text )
  {
    v7 = 0;
    if ( !png_ptr )
      return;
    goto LABEL_8;
  }
  v7 = strlen((const char *)text);
  if ( v7 > 2147483646 - v6 )
  {
LABEL_17:
    j_png_error(png_ptr, (png_const_charp)"tEXt: text too long");
    JUMPOUT(0x208124);
  }
  if ( !png_ptr )
    return;
LABEL_8:
  v8 = v6 + 1;
  png_ptr->io_state = 34;
  v13 = (v8 + v7) >> 16;
  data = (v8 + v7) >> 24;
  v14 = (unsigned __int16)(v8 + v7) >> 8;
  v15 = v8 + v7;
  v16 = 1951942004;
  j_png_write_data(png_ptr, &data, 8u);
  png_ptr->chunk_name = 1950701684;
  j_png_reset_crc(png_ptr);
  j_png_calculate_crc(png_ptr, (png_const_bytep)&v16, 4u);
  png_ptr->io_state = 66;
  if ( v8 )
  {
    j_png_write_data(png_ptr, new_key, v8);
    j_png_calculate_crc(png_ptr, new_key, v8);
  }
  v9 = v7 == 0;
  if ( v7 )
    v9 = text == 0;
  if ( !v9 )
  {
    j_png_write_data(png_ptr, text, v7);
    j_png_calculate_crc(png_ptr, text, v7);
  }
  crc = png_ptr->crc;
  png_ptr->io_state = 130;
  v15 = crc;
  v13 = BYTE2(crc);
  data = HIBYTE(crc);
  v14 = BYTE1(crc);
  j_png_write_data(png_ptr, &data, 4u);
}
// 208120: control flows out of bounds to 208124

//----- (00208158) --------------------------------------------------------
void __fastcall png_write_zTXt(png_structrp_12 png_ptr, png_const_charp key, png_const_charp text, int compression)
{
  png_uint_32 v6; // r0
  png_uint_32 v7; // r5
  size_t v8; // r0
  png_uint_32 output_len; // r0
  png_uint_32 v10; // r0
  int v11; // r9
  png_uint_32 v12; // r4
  png_compression_bufferp *p_zbuffer_list; // r6
  png_byte *output; // r8
  png_size_t zbuffer_size; // r5
  int v16; // r0
  bool v17; // zf
  png_uint_32 crc; // r0
  compression_state comp; // [sp+4h] [bp-484h] BYREF
  png_byte data[8]; // [sp+413h] [bp-75h] BYREF
  png_byte new_key[81]; // [sp+41Bh] [bp-6Dh] BYREF

  if ( compression )
  {
    if ( compression == -1 )
    {
      j_png_write_tEXt(png_ptr, key, text, 0xFFFFFFFF);
      return;
    }
    j_png_error(png_ptr, (png_const_charp)"zTXt: invalid compression type");
    goto LABEL_30;
  }
  v6 = j_png_check_keyword(png_ptr, key, data);
  if ( !v6 )
  {
LABEL_30:
    j_png_error(png_ptr, (png_const_charp)"zTXt: invalid keyword");
LABEL_31:
    j_png_error(png_ptr, png_ptr->zstream.msg);
    goto LABEL_32;
  }
  v7 = v6 + 2;
  data[v6 + 1] = 0;
  if ( text )
    v8 = strlen((const char *)text);
  else
    v8 = 0;
  comp.input = text;
  comp.input_len = v8;
  comp.output_len = 0;
  if ( png_text_compress(png_ptr, 0x7A545874u, &comp, v7) )
    goto LABEL_31;
  if ( png_ptr )
  {
    output_len = comp.output_len;
    png_ptr->io_state = 34;
    v10 = output_len + v7;
    new_key[74] = BYTE2(v10);
    new_key[73] = HIBYTE(v10);
    new_key[75] = BYTE1(v10);
    new_key[76] = v10;
    *(_DWORD *)&new_key[77] = 1951945850;
    j_png_write_data(png_ptr, &new_key[73], 8u);
    png_ptr->chunk_name = 2052348020;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, &new_key[77], 4u);
    png_ptr->io_state = 66;
    if ( v7 )
    {
      j_png_write_data(png_ptr, data, v7);
      j_png_calculate_crc(png_ptr, data, v7);
    }
    v11 = 1;
  }
  else
  {
    v11 = 0;
  }
  v12 = comp.output_len;
  p_zbuffer_list = &png_ptr->zbuffer_list;
  output = comp.output;
  zbuffer_size = 1024;
  while ( 1 )
  {
    if ( zbuffer_size > v12 )
      zbuffer_size = v12;
    p_zbuffer_list = (png_compression_bufferp *)*p_zbuffer_list;
    v16 = zbuffer_size;
    if ( zbuffer_size )
      v16 = 1;
    if ( (v16 & v11) == 1 )
    {
      j_png_write_data(png_ptr, output, zbuffer_size);
      j_png_calculate_crc(png_ptr, output, zbuffer_size);
    }
    v12 -= zbuffer_size;
    v17 = p_zbuffer_list == 0;
    if ( p_zbuffer_list )
      v17 = v12 == 0;
    if ( v17 )
      break;
    zbuffer_size = png_ptr->zbuffer_size;
    output = (png_byte *)(p_zbuffer_list + 1);
  }
  if ( v12 )
  {
LABEL_32:
    j_png_error(png_ptr, (png_const_charp)"error writing ancillary chunked compressed data");
    JUMPOUT(0x208318);
  }
  if ( png_ptr )
  {
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    new_key[76] = crc;
    new_key[74] = BYTE2(crc);
    new_key[73] = HIBYTE(crc);
    new_key[75] = BYTE1(crc);
    j_png_write_data(png_ptr, &new_key[73], 4u);
  }
}
// 208314: control flows out of bounds to 208318
// 208158: using guessed type png_byte data[8];

//----- (0020835C) --------------------------------------------------------
void __fastcall png_write_iTXt(
        png_structrp_12 png_ptr,
        int compression,
        png_const_charp key,
        png_const_charp lang,
        png_const_charp lang_key,
        png_const_charp text)
{
  png_uint_32 v9; // r0
  png_uint_32 v10; // r6
  char v11; // r8
  png_byte *v12; // r0
  png_const_charp v13; // r5
  size_t v14; // r4
  const char *v15; // r0
  png_const_charp zbuffer_size; // r5
  size_t v17; // r10
  size_t output_len; // r0
  png_size_t v19; // r9
  int v20; // r2
  png_uint_32 v21; // r6
  png_uint_32 v22; // r1
  int v23; // r8
  png_uint_32 v24; // r10
  size_t v25; // r0
  const png_byte *v26; // r4
  int v27; // r9
  bool v28; // zf
  int v29; // r8
  bool v30; // zf
  png_uint_32 v31; // r6
  png_compression_bufferp *p_zbuffer_list; // r4
  png_byte *output; // r9
  int v34; // r0
  bool v35; // zf
  int v36; // r0
  png_uint_32 crc; // r0
  png_const_bytep v38; // [sp+0h] [bp-498h]
  png_size_t v39; // [sp+4h] [bp-494h]
  png_size_t length; // [sp+8h] [bp-490h]
  const png_byte *v41; // [sp+Ch] [bp-48Ch]
  compression_state comp; // [sp+10h] [bp-488h] BYREF
  png_byte data[8]; // [sp+41Eh] [bp-7Ah] BYREF
  png_byte new_key[82]; // [sp+426h] [bp-72h] BYREF

  v9 = j_png_check_keyword(png_ptr, key, data);
  v10 = v9;
  if ( !v9 )
  {
    j_png_error(png_ptr, (png_const_charp)"iTXt: invalid keyword");
    goto LABEL_52;
  }
  v11 = compression + 1;
  if ( (unsigned int)(compression + 1) >= 4 )
  {
LABEL_52:
    j_png_error(png_ptr, (png_const_charp)"iTXt: invalid compression");
    goto LABEL_53;
  }
  v12 = &data[v9];
  v12[2] = 0;
  v12[1] = 0x1000100u >> (8 * v11);
  if ( !lang )
    lang = (png_const_charp)&byte_61CADE;
  v13 = lang_key;
  v41 = lang;
  v14 = strlen((const char *)lang);
  if ( !lang_key )
    v13 = (png_const_charp)&byte_61CADE;
  v15 = (const char *)v13;
  v38 = v13;
  zbuffer_size = text;
  v17 = strlen(v15);
  if ( !text )
    zbuffer_size = (png_const_charp)&byte_61CADE;
  output_len = strlen((const char *)zbuffer_size);
  comp.output_len = 0;
  v19 = v10 + 3;
  v20 = v10 + 3 + v14 + 1;
  length = v14 + 1;
  if ( v14 + 1 > 2147483644 - v10 )
    v20 = 0x7FFFFFFF;
  v21 = v20 + v17 + 1;
  LOWORD(v22) = 22644;
  v39 = v17 + 1;
  if ( v17 + 1 > 0x7FFFFFFF - v20 )
    v21 = 0x7FFFFFFF;
  v23 = v11 & 1;
  HIWORD(v22) = 26964;
  comp.input = zbuffer_size;
  comp.input_len = output_len;
  if ( !v23 )
  {
    v24 = v22;
    if ( output_len <= 0x7FFFFFFF - v21 )
    {
      comp.output_len = output_len;
      if ( png_ptr )
        goto LABEL_16;
LABEL_28:
      v27 = v23;
      v29 = 0;
      goto LABEL_29;
    }
LABEL_54:
    j_png_error(png_ptr, (png_const_charp)"iTXt: uncompressed text too long");
    JUMPOUT(0x208624);
  }
  v24 = v22;
  if ( png_text_compress(png_ptr, v22, &comp, v21) )
  {
LABEL_53:
    j_png_error(png_ptr, png_ptr->zstream.msg);
    goto LABEL_54;
  }
  output_len = comp.output_len;
  if ( !png_ptr )
    goto LABEL_28;
LABEL_16:
  v25 = output_len + v21;
  png_ptr->io_state = 34;
  new_key[75] = BYTE2(v25);
  new_key[74] = HIBYTE(v25);
  new_key[76] = BYTE1(v25);
  new_key[77] = v25;
  *(_DWORD *)&new_key[78] = 1951945833;
  j_png_write_data(png_ptr, &new_key[74], 8u);
  png_ptr->chunk_name = v24;
  j_png_reset_crc(png_ptr);
  j_png_calculate_crc(png_ptr, &new_key[78], 4u);
  png_ptr->io_state = 66;
  if ( v19 )
  {
    j_png_write_data(png_ptr, data, v19);
    j_png_calculate_crc(png_ptr, data, v19);
  }
  v26 = (const png_byte *)(v14 + 1);
  v27 = v23;
  v28 = length == 0;
  if ( length )
    v28 = v41 == 0;
  if ( !v28 )
  {
    j_png_write_data(png_ptr, v41, length);
    j_png_calculate_crc(png_ptr, v41, length);
  }
  v29 = 1;
  v30 = v39 == 0;
  if ( v39 )
  {
    v26 = v38;
    v30 = v38 == 0;
  }
  if ( !v30 )
  {
    j_png_write_data(png_ptr, v26, v39);
    j_png_calculate_crc(png_ptr, v26, v39);
    v29 = 1;
  }
LABEL_29:
  v31 = comp.output_len;
  if ( !v27 )
  {
LABEL_43:
    v36 = (int)zbuffer_size;
    if ( zbuffer_size )
      v36 = 1;
    if ( (v36 & v29) == 1 && v31 )
    {
      j_png_write_data(png_ptr, zbuffer_size, v31);
      j_png_calculate_crc(png_ptr, zbuffer_size, v31);
    }
    goto LABEL_48;
  }
  p_zbuffer_list = &png_ptr->zbuffer_list;
  output = comp.output;
  zbuffer_size = (_BYTE *)(elf_hash_bucket + 772);
  while ( 1 )
  {
    if ( (unsigned int)zbuffer_size > v31 )
      zbuffer_size = (png_const_charp)v31;
    p_zbuffer_list = (png_compression_bufferp *)*p_zbuffer_list;
    v34 = (int)zbuffer_size;
    if ( zbuffer_size )
      v34 = 1;
    if ( (v34 & v29) == 1 )
    {
      j_png_write_data(png_ptr, output, (png_size_t)zbuffer_size);
      j_png_calculate_crc(png_ptr, output, (png_size_t)zbuffer_size);
    }
    v31 -= (unsigned int)zbuffer_size;
    v35 = p_zbuffer_list == 0;
    if ( p_zbuffer_list )
      v35 = v31 == 0;
    if ( v35 )
      break;
    zbuffer_size = (png_const_charp)png_ptr->zbuffer_size;
    output = (png_byte *)(p_zbuffer_list + 1);
  }
  if ( v31 )
  {
    j_png_error(png_ptr, (png_const_charp)"error writing ancillary chunked compressed data");
    goto LABEL_43;
  }
LABEL_48:
  if ( png_ptr )
  {
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    new_key[77] = crc;
    new_key[75] = BYTE2(crc);
    new_key[74] = HIBYTE(crc);
    new_key[76] = BYTE1(crc);
    j_png_write_data(png_ptr, &new_key[74], 4u);
  }
}
// 208622: control flows out of bounds to 208624
// FC: using guessed type int elf_hash_bucket[16411];
// 61CADE: using guessed type char byte_61CADE;
// 20835C: using guessed type png_byte data[8];

//----- (0020868C) --------------------------------------------------------
void __fastcall png_write_oFFs(png_structrp_12 png_ptr, png_int_32 x_offset, png_int_32 y_offset, int unit_type)
{
  png_byte v5; // r5
  png_uint_32 crc; // r0
  png_byte data[4]; // [sp+3h] [bp-2Dh] BYREF
  png_byte v10[4]; // [sp+7h] [bp-29h] BYREF
  png_byte buf[9]; // [sp+Bh] [bp-25h] BYREF

  v5 = unit_type;
  if ( unit_type >= 2 )
    j_png_warning(png_ptr, (png_const_charp)"Unrecognized unit type for oFFs chunk");
  j_png_save_int_32(data, x_offset);
  j_png_save_int_32(v10, y_offset);
  buf[0] = v5;
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    *(_DWORD *)&buf[1] = 150994944;
    *(_DWORD *)&buf[5] = 1933985391;
    j_png_write_data(png_ptr, &buf[1], 8u);
    png_ptr->chunk_name = 1866876531;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, &buf[5], 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, data, 9u);
    j_png_calculate_crc(png_ptr, data, 9u);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    buf[4] = crc;
    buf[2] = BYTE2(crc);
    buf[1] = HIBYTE(crc);
    buf[3] = BYTE1(crc);
    j_png_write_data(png_ptr, &buf[1], 4u);
  }
}
// 20868C: using guessed type png_byte data[4];
// 20868C: using guessed type png_byte anonymous_0[4];

//----- (002087A0) --------------------------------------------------------
void __fastcall png_write_pCAL(
        png_structrp_12 png_ptr,
        png_charp purpose,
        png_int_32 X0,
        png_int_32 X1,
        int type,
        int nparams,
        png_const_charp units,
        png_charpp params)
{
  png_uint_32 v11; // r8
  int v12; // r10
  png_const_bytep *v13; // r11
  size_t v14; // r0
  int v15; // r4
  png_size_t *v16; // r0
  size_t *v17; // r6
  int v18; // r5
  png_charpp v19; // r9
  const char *v20; // t1
  size_t v21; // r0
  png_size_t v22; // r5
  png_int_32 v23; // r4
  png_byte v24; // r6
  int v25; // r8
  bool v26; // zf
  png_size_t *v27; // r4
  const png_byte *v28; // r5
  int v29; // r0
  png_size_t v30; // r6
  png_uint_32 crc; // r0
  png_size_t length; // [sp+4h] [bp-94h]
  png_int_32 i; // [sp+8h] [bp-90h]
  png_int_32 v34; // [sp+Ch] [bp-8Ch]
  png_structrp_9 v35; // [sp+10h] [bp-88h]
  png_size_t *ptr; // [sp+14h] [bp-84h]
  png_byte data[4]; // [sp+1Ah] [bp-7Eh] BYREF
  png_byte new_key[8]; // [sp+1Eh] [bp-7Ah] BYREF
  png_byte new_purpose[80]; // [sp+26h] [bp-72h] BYREF
  png_byte buf[10]; // [sp+76h] [bp-22h]

  if ( type >= 4 )
  {
    j_png_error(png_ptr, (png_const_charp)"Unrecognized equation type for pCAL chunk");
    goto LABEL_32;
  }
  v11 = j_png_check_keyword(png_ptr, purpose, new_key);
  if ( !v11 )
  {
LABEL_32:
    j_png_error(png_ptr, (png_const_charp)"pCAL: invalid keyword");
    JUMPOUT(0x2089C4);
  }
  i = X0;
  v34 = X1;
  v12 = nparams;
  v13 = (png_const_bytep *)params;
  v14 = strlen((const char *)units);
  if ( nparams )
    ++v14;
  v35 = png_ptr;
  length = v14;
  v15 = v14 + v11 + 11;
  v16 = (png_size_t *)j_png_malloc(png_ptr, 4 * nparams);
  ptr = v16;
  if ( nparams >= 1 )
  {
    v17 = v16;
    v18 = nparams;
    v19 = params;
    do
    {
      v20 = (const char *)*v19++;
      v21 = strlen(v20);
      if ( v18 != 1 )
        ++v21;
      --v18;
      *v17++ = v21;
      v15 += v21;
    }
    while ( v18 );
  }
  if ( v35 )
  {
    v22 = v11 + 1;
    v35->io_state = 34;
    new_purpose[73] = BYTE2(v15);
    new_purpose[72] = HIBYTE(v15);
    new_purpose[74] = BYTE1(v15);
    new_purpose[75] = v15;
    *(_DWORD *)&new_purpose[76] = 1279345520;
    j_png_write_data(v35, &new_purpose[72], 8u);
    v35->chunk_name = 1883455820;
    j_png_reset_crc(v35);
    j_png_calculate_crc(v35, &new_purpose[76], 4u);
    v23 = v34;
    v24 = type;
    v35->io_state = 66;
    if ( v11 != -1 )
    {
      j_png_write_data(v35, new_key, v22);
      j_png_calculate_crc(v35, new_key, v22);
    }
    v25 = 1;
  }
  else
  {
    v25 = 0;
    v23 = v34;
    v24 = type;
  }
  j_png_save_int_32(&new_purpose[72], i);
  j_png_save_int_32(&new_purpose[76], v23);
  buf[1] = nparams;
  buf[0] = v24;
  if ( v25 == 1 )
  {
    j_png_write_data(v35, &new_purpose[72], 0xAu);
    j_png_calculate_crc(v35, &new_purpose[72], 0xAu);
    v26 = length == 0;
    if ( length )
      v26 = units == 0;
    if ( !v26 )
    {
      j_png_write_data(v35, units, length);
      j_png_calculate_crc(v35, units, length);
    }
  }
  if ( nparams >= 1 )
  {
    v27 = ptr;
    do
    {
      v28 = *v13;
      v29 = (int)*v13;
      if ( *v13 )
        v29 = 1;
      if ( (v29 & v25) == 1 )
      {
        v30 = *v27;
        if ( *v27 )
        {
          j_png_write_data(v35, *v13, *v27);
          j_png_calculate_crc(v35, v28, v30);
        }
      }
      --v12;
      ++v27;
      ++v13;
    }
    while ( v12 );
  }
  j_png_free(v35, ptr);
  if ( v35 )
  {
    crc = v35->crc;
    v35->io_state = 130;
    data[3] = crc;
    data[1] = BYTE2(crc);
    data[0] = HIBYTE(crc);
    data[2] = BYTE1(crc);
    j_png_write_data(v35, data, 4u);
  }
}
// 2089C2: control flows out of bounds to 2089C4

//----- (00208A10) --------------------------------------------------------
void __fastcall png_write_sCAL_s(png_structrp_12 png_ptr, int unit, png_const_charp width, png_const_charp height)
{
  png_byte v7; // r9
  size_t v8; // r5
  size_t v9; // r6
  png_size_t v10; // r10
  png_uint_32 crc; // r0
  png_byte v12; // [sp+0h] [bp-68h] BYREF
  _BYTE v13[63]; // [sp+1h] [bp-67h] BYREF
  png_byte data; // [sp+40h] [bp-28h] BYREF
  char v15; // [sp+41h] [bp-27h]
  char v16; // [sp+42h] [bp-26h]
  char v17; // [sp+43h] [bp-25h]
  int v18; // [sp+44h] [bp-24h] BYREF

  v7 = unit;
  v8 = strlen((const char *)width);
  v9 = strlen((const char *)height);
  v10 = v8 + v9 + 2;
  if ( v10 < 0x41 )
  {
    v12 = v7;
    qmemcpy(v13, width, v8 + 1);
    qmemcpy(&v13[v8 + 1], height, v9);
    if ( png_ptr )
    {
      png_ptr->io_state = 34;
      v15 = (v8 + v9 + 2) >> 16;
      data = (v8 + v9 + 2) >> 24;
      v16 = (unsigned __int16)(v8 + v9 + 2) >> 8;
      v17 = v8 + v9 + 2;
      v18 = 1279345523;
      j_png_write_data(png_ptr, &data, 8u);
      png_ptr->chunk_name = 1933787468;
      j_png_reset_crc(png_ptr);
      j_png_calculate_crc(png_ptr, (png_const_bytep)&v18, 4u);
      png_ptr->io_state = 66;
      if ( v8 + v9 != -2 )
      {
        j_png_write_data(png_ptr, &v12, v10);
        j_png_calculate_crc(png_ptr, &v12, v10);
      }
      crc = png_ptr->crc;
      png_ptr->io_state = 130;
      v17 = crc;
      v15 = BYTE2(crc);
      data = HIBYTE(crc);
      v16 = BYTE1(crc);
      j_png_write_data(png_ptr, &data, 4u);
    }
  }
  else
  {
    j_png_warning(png_ptr, (png_const_charp)"Can't write sCAL (buffer too small)");
  }
}

//----- (00208B60) --------------------------------------------------------
void __fastcall png_write_pHYs(
        png_structrp_12 png_ptr,
        png_uint_32 x_pixels_per_unit,
        png_uint_32 y_pixels_per_unit,
        int unit_type)
{
  png_byte v5; // r8
  png_uint_32 crc; // r0
  png_byte data[8]; // [sp+3h] [bp-25h] BYREF
  png_byte buf[9]; // [sp+Bh] [bp-1Dh] BYREF

  v5 = unit_type;
  if ( unit_type >= 2 )
    j_png_warning(png_ptr, (png_const_charp)"Unrecognized unit type for pHYs chunk");
  data[3] = x_pixels_per_unit;
  data[7] = y_pixels_per_unit;
  buf[0] = v5;
  data[1] = BYTE2(x_pixels_per_unit);
  data[0] = HIBYTE(x_pixels_per_unit);
  data[2] = BYTE1(x_pixels_per_unit);
  data[4] = HIBYTE(y_pixels_per_unit);
  data[5] = BYTE2(y_pixels_per_unit);
  data[6] = BYTE1(y_pixels_per_unit);
  if ( png_ptr )
  {
    png_ptr->io_state = 34;
    *(_DWORD *)&buf[1] = 150994944;
    *(_DWORD *)&buf[5] = 1935231088;
    j_png_write_data(png_ptr, &buf[1], 8u);
    png_ptr->chunk_name = 1883789683;
    j_png_reset_crc(png_ptr);
    j_png_calculate_crc(png_ptr, &buf[5], 4u);
    png_ptr->io_state = 66;
    j_png_write_data(png_ptr, data, 9u);
    j_png_calculate_crc(png_ptr, data, 9u);
    crc = png_ptr->crc;
    png_ptr->io_state = 130;
    buf[4] = crc;
    buf[2] = BYTE2(crc);
    buf[1] = HIBYTE(crc);
    buf[3] = BYTE1(crc);
    j_png_write_data(png_ptr, &buf[1], 4u);
  }
}

//----- (00208C98) --------------------------------------------------------
void __fastcall png_write_tIME(png_structrp_12 png_ptr, png_const_timep mod_time)
{
  png_byte month; // r0
  png_byte day; // r2
  unsigned int hour; // r3
  bool v6; // cc
  unsigned int second; // r5
  png_uint_16 year; // r12
  png_byte minute; // r0
  png_uint_32 crc; // r0
  png_byte v11[7]; // [sp+5h] [bp-1Bh] BYREF
  png_byte data[4]; // [sp+Ch] [bp-14h] BYREF
  int v13; // [sp+10h] [bp-10h] BYREF

  month = mod_time->month;
  if ( (unsigned __int8)(month - 1) > 0xBu )
    goto LABEL_6;
  day = mod_time->day;
  hour = (unsigned __int8)(day - 1);
  v6 = hour > 0x1E;
  if ( hour <= 0x1E )
  {
    hour = mod_time->hour;
    v6 = hour > 0x17;
  }
  if ( v6 || (second = mod_time->second, second >= 0x3D) )
  {
LABEL_6:
    j_png_warning(png_ptr, (png_const_charp)"Invalid time specified for tIME chunk");
  }
  else
  {
    year = mod_time->year;
    v11[1] = mod_time->year;
    v11[2] = month;
    v11[3] = day;
    v11[4] = hour;
    v11[0] = HIBYTE(year);
    minute = mod_time->minute;
    v11[6] = second;
    v11[5] = minute;
    if ( png_ptr )
    {
      png_ptr->io_state = 34;
      *(_DWORD *)data = 117440512;
      v13 = 1162692980;
      j_png_write_data(png_ptr, data, 8u);
      png_ptr->chunk_name = 1950960965;
      j_png_reset_crc(png_ptr);
      j_png_calculate_crc(png_ptr, (png_const_bytep)&v13, 4u);
      png_ptr->io_state = 66;
      j_png_write_data(png_ptr, v11, 7u);
      j_png_calculate_crc(png_ptr, v11, 7u);
      crc = png_ptr->crc;
      png_ptr->io_state = 130;
      data[3] = crc;
      data[1] = BYTE2(crc);
      data[0] = HIBYTE(crc);
      data[2] = BYTE1(crc);
      j_png_write_data(png_ptr, data, 4u);
    }
  }
}

//----- (00208DCC) --------------------------------------------------------
void __fastcall png_write_start_row(png_structrp_12 png_ptr)
{
  unsigned int v2; // r0
  png_uint_32 width; // r1
  unsigned int v4; // r1
  png_alloc_size_t v5; // r5
  png_byte pixel_depth; // r2
  png_byte *v7; // r0
  unsigned int do_filter; // r6
  __int64 v9; // r0
  __int64 v10; // r0

  v2 = png_ptr->usr_bit_depth * png_ptr->usr_channels;
  width = png_ptr->width;
  if ( v2 < 8 )
    v4 = (width * v2 + 7) >> 3;
  else
    v4 = width * (v2 >> 3);
  v5 = v4 + 1;
  pixel_depth = png_ptr->pixel_depth;
  png_ptr->maximum_pixel_depth = v2;
  png_ptr->transformed_pixel_depth = pixel_depth;
  v7 = (png_byte *)j_png_malloc(png_ptr, v4 + 1);
  png_ptr->row_buf = v7;
  *v7 = 0;
  do_filter = png_ptr->do_filter;
  v9 = *(_QWORD *)&png_ptr->width;
  if ( HIDWORD(v9) == 1 )
    do_filter &= 0x1Fu;
  if ( (_DWORD)v9 == 1 )
    do_filter &= 0x2Fu;
  if ( !do_filter )
    do_filter = 8;
  png_ptr->do_filter = do_filter;
  if ( (do_filter & 0xF0) != 0 && !png_ptr->try_row )
  {
    png_ptr->try_row = (png_bytep)j_png_malloc(png_ptr, v5);
    if ( ((do_filter >> 5) & 1) + (do_filter >> 7) + ((do_filter >> 4) & 1) + ((do_filter >> 6) & 1) >= 2 )
      png_ptr->tst_row = (png_bytep)j_png_malloc(png_ptr, v5);
  }
  if ( (do_filter & 0xE0) != 0 )
    png_ptr->prev_row = (png_bytep)j_png_calloc(png_ptr, v5);
  if ( !png_ptr->interlaced )
  {
    v10 = *(_QWORD *)&png_ptr->width;
LABEL_21:
    png_ptr->num_rows = HIDWORD(v10);
    goto LABEL_22;
  }
  HIDWORD(v10) = png_ptr->height;
  if ( (png_ptr->transformations & 2) != 0 )
  {
    LODWORD(v10) = png_ptr->width;
    goto LABEL_21;
  }
  LODWORD(v10) = png_ptr->width + 7;
  png_ptr->num_rows = (unsigned int)(HIDWORD(v10) + 7) >> 3;
  LODWORD(v10) = (unsigned int)v10 >> 3;
LABEL_22:
  png_ptr->usr_width = v10;
}

//----- (00208EC0) --------------------------------------------------------
void __fastcall png_write_finish_row(png_structrp_12 png_ptr)
{
  png_uint_32 row_number; // r1
  png_uint_32 num_rows; // r0
  char transformations; // r0
  png_byte pass; // r6
  __int64 v6; // kr00_8
  unsigned int v7; // r11
  unsigned int v8; // r10
  unsigned int v9; // r5
  unsigned int v10; // r9
  bool v11; // cf
  png_bytep prev_row; // r0
  unsigned int v13; // r2
  png_uint_32 width; // r1
  unsigned int v15; // r1

  row_number = png_ptr->row_number;
  num_rows = png_ptr->num_rows;
  png_ptr->row_number = ++row_number;
  if ( row_number >= num_rows )
  {
    if ( !png_ptr->interlaced )
      goto LABEL_17;
    transformations = png_ptr->transformations;
    png_ptr->row_number = 0;
    if ( (transformations & 2) != 0 )
    {
      pass = png_ptr->pass + 1;
    }
    else
    {
      pass = png_ptr->pass;
      do
      {
        if ( ++pass > 6u )
          break;
        v6 = *(_QWORD *)&png_ptr->width;
        v7 = png_write_finish_row_png_pass_yinc[pass];
        v8 = HIDWORD(v6) + v7 - 1 - png_write_finish_row_png_pass_ystart[pass];
        png_ptr->num_rows = v8 / v7;
        v9 = png_do_write_interlace_png_pass_inc[pass];
        v10 = v6 + v9 - 1 - png_do_write_interlace_png_pass_start[pass];
        v11 = v8 >= v7;
        png_ptr->usr_width = v10 / v9;
        if ( v8 >= v7 )
          v11 = v10 >= v9;
      }
      while ( !v11 );
    }
    png_ptr->pass = pass;
    if ( pass <= 6u )
    {
      prev_row = png_ptr->prev_row;
      if ( prev_row )
      {
        v13 = png_ptr->usr_bit_depth * png_ptr->usr_channels;
        width = png_ptr->width;
        if ( v13 < 8 )
          v15 = (width * v13 + 7) >> 3;
        else
          v15 = width * (v13 >> 3);
        memset(prev_row, 0, v15 + 1);
      }
    }
    else
    {
LABEL_17:
      png_compress_IDAT(png_ptr, 0, 0, 4);
    }
  }
}

//----- (00208FC4) --------------------------------------------------------
void __fastcall png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
{
  png_bytep v3; // r6
  png_row_infop v4; // r10
  unsigned int pixel_depth; // r0
  png_uint_32 v6; // r8
  png_uint_32 v7; // r4
  int v8; // r1
  png_bytep v9; // lr
  int v10; // r9
  png_uint_32 v11; // r0
  int v12; // r4
  png_uint_32 v13; // r5
  bool v14; // zf
  png_uint_32 width; // r11
  char v16; // r5
  int v17; // r3
  png_bytep v18; // lr
  int v19; // r9
  int v20; // r0
  png_uint_32 v21; // r11
  char v22; // r5
  int v23; // r3
  png_bytep v24; // lr
  int v25; // r9
  png_uint_32 v26; // r0
  int v27; // r4
  png_uint_32 v28; // r11
  size_t v29; // r5
  png_uint_32 v30; // r9
  png_byte *v31; // r4
  int v32; // r10
  unsigned int v33; // r0
  unsigned int v34; // r1
  unsigned int v35; // r0
  png_row_info *v36; // [sp+0h] [bp-28h]
  png_uint_32 v37; // [sp+4h] [bp-24h]
  int v38; // [sp+8h] [bp-20h]

  v3 = row;
  v4 = row_info;
  if ( pass > 5 )
    return;
  pixel_depth = row_info->pixel_depth;
  switch ( pixel_depth )
  {
    case 4u:
      width = v4->width;
      v7 = png_do_write_interlace_png_pass_start[pass];
      if ( v4->width > v7 )
      {
        v16 = 4 * v7;
        v17 = 0;
        v18 = row;
        v38 = pass;
        v19 = png_do_write_interlace_png_pass_inc[pass];
        v20 = 4;
        v37 = png_do_write_interlace_png_pass_start[pass];
        do
        {
          v17 |= ((row[v7 >> 1] >> (~v16 & 4)) & 0xF) << v20;
          if ( v20 )
          {
            v20 -= 4;
          }
          else
          {
            *v18++ = v17;
            v17 = 0;
            v20 = 4;
          }
          v7 += v19;
          v16 += 4 * v19;
        }
        while ( v7 < width );
        if ( v20 != 4 )
          *v18 = v17;
        goto LABEL_37;
      }
      break;
    case 2u:
      v21 = v4->width;
      v7 = png_do_write_interlace_png_pass_start[pass];
      if ( v4->width > v7 )
      {
        v22 = 2 * v7;
        v23 = 0;
        v24 = row;
        v38 = pass;
        v25 = png_do_write_interlace_png_pass_inc[pass];
        v26 = png_do_write_interlace_png_pass_start[pass];
        v27 = 6;
        v37 = v26;
        do
        {
          v23 |= ((row[v26 >> 2] >> (~v22 & 6)) & 3) << v27;
          if ( v27 )
          {
            v27 -= 2;
          }
          else
          {
            *v24++ = v23;
            v27 = 6;
            v23 = 0;
          }
          v26 += v25;
          v22 += 2 * v25;
        }
        while ( v26 < v21 );
        if ( v27 != 6 )
          *v24 = v23;
        goto LABEL_37;
      }
      break;
    case 1u:
      v6 = v4->width;
      v7 = png_do_write_interlace_png_pass_start[pass];
      if ( v4->width > v7 )
      {
        v8 = 0;
        v9 = v3;
        v10 = png_do_write_interlace_png_pass_inc[pass];
        v11 = png_do_write_interlace_png_pass_start[pass];
        v12 = 7;
        v13 = v11;
        do
        {
          v8 |= ((v3[v13 >> 3] >> (~(_BYTE)v13 & 7)) & 1) << v12;
          if ( v12 )
          {
            --v12;
          }
          else
          {
            *v9++ = v8;
            v12 = 7;
            v8 = 0;
          }
          v13 += v10;
        }
        while ( v13 < v6 );
        v14 = v12 == 7;
        v7 = v11;
        if ( !v14 )
          *v9 = v8;
      }
      break;
    default:
      v28 = v4->width;
      v7 = png_do_write_interlace_png_pass_start[pass];
      if ( v4->width > v7 )
      {
        v29 = pixel_depth >> 3;
        v36 = v4;
        v30 = png_do_write_interlace_png_pass_start[pass];
        v31 = &row[(__int16)(pixel_depth >> 3) * v30];
        v38 = pass;
        v32 = png_do_write_interlace_png_pass_inc[pass];
        v37 = v30;
        do
        {
          if ( v3 != v31 )
            qmemcpy(v3, v31, v29);
          v30 += v32;
          v31 += (__int16)v29 * (__int16)v32;
          v3 += v29;
        }
        while ( v30 < v28 );
        v4 = v36;
LABEL_37:
        v7 = v37;
        pass = v38;
      }
      break;
  }
  v33 = (v4->width + png_do_write_interlace_png_pass_inc[pass] - 1 - v7) / png_do_write_interlace_png_pass_inc[pass];
  v34 = v4->pixel_depth;
  v4->width = v33;
  if ( v34 < 8 )
    v35 = (v33 * v34 + 7) >> 3;
  else
    v35 = v33 * (v34 >> 3);
  v4->rowbytes = v35;
}

//----- (002091C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall png_write_find_filter(png_structrp_12 png_ptr, png_row_infop row_info)
{
  int32x4_t v2; // q9
  png_structrp_12 v3; // r11
  const png_byte *row_buf; // lr
  png_size_t rowbytes; // r8
  int do_filter; // r12
  unsigned int v7; // r3
  unsigned __int32 v8; // r10
  bool v9; // zf
  int v10; // r6
  int32x4_t v11; // q11
  png_bytep v12; // r0
  int8x16_t v13; // q8
  unsigned __int32 *v14; // r2
  int32x4_t v15; // q11
  unsigned int v16; // r1
  int64x2_t v17; // q10
  unsigned __int32 v18; // t1
  int16x4_t v19; // d26
  int32x4_t v20; // q13
  int32x4_t v21; // q8
  png_size_t v22; // r1
  char *v23; // r0
  int v24; // t1
  int v25; // r3
  png_bytep try_row; // r4
  png_byte *v27; // r2
  const png_byte *v28; // r0
  unsigned int v29; // r8
  int v30; // r6
  bool v31; // cf
  png_byte *v32; // r1
  const png_byte *v33; // r5
  int v34; // r3
  __int64 v35; // d16
  __int64 v36; // d17
  png_bytep v37; // r8
  png_byte *v38; // r12
  png_byte *v39; // r1
  unsigned int v40; // r9
  int v41; // lr
  bool v42; // cf
  int32x4_t v43; // q11
  png_byte *v44; // r2
  int8x16_t v45; // q8
  png_byte *v46; // r6
  int32x4_t v47; // q11
  int v48; // r3
  unsigned __int32 *v49; // r0
  int64x2_t v50; // q10
  unsigned __int32 v51; // t1
  int8x8_t v52; // d26
  int8x8_t v53; // d19
  int64x2_t v54; // q15
  int32x4_t v55; // q14
  int32x4_t v56; // q15
  int32x4_t v57; // q8
  unsigned __int32 v58; // r4
  unsigned int v59; // r0
  png_byte v60; // t1
  unsigned int v61; // r1
  png_size_t v62; // r9
  png_byte *v63; // r4
  const png_byte *v64; // r5
  unsigned int v65; // r0
  png_byte v66; // r1
  int v67; // t1
  int v68; // r3
  unsigned int v69; // r2
  const png_byte *v70; // r5
  int v71; // r12
  int8x16_t *v72; // r3
  int v73; // r5
  int8x16_t *v74; // r6
  _BOOL4 v75; // r3
  _BOOL4 v76; // r8
  bool v77; // zf
  int v78; // r0
  png_byte *tst_row; // r0
  unsigned int v80; // r3
  int8x16_t v81; // q8
  int8x16_t v82; // q9
  png_size_t v83; // r0
  char *v84; // r1
  char v85; // r2
  char v86; // t1
  char v87; // t1
  png_bytep v88; // r0
  png_bytep prev_row; // r9
  png_bytep v90; // lr
  unsigned int v91; // r12
  png_bytep v92; // r1
  unsigned __int32 v93; // r0
  __int64 v94; // r2
  unsigned int v95; // r6
  int v96; // r5
  png_byte *v97; // r1
  png_bytep v98; // lr
  int8x8_t *v99; // r9
  png_bytep v100; // r2
  png_bytep v101; // r11
  uint8x8_t *v102; // r12
  uint8x8_t *v103; // r10
  unsigned int v104; // r6
  int v105; // r8
  unsigned int v106; // r1
  png_size_t v107; // r1
  unsigned int v108; // r8
  png_size_t v109; // r2
  unsigned int v110; // r10
  int8x16_t *v111; // r4
  unsigned int v112; // r1
  int v113; // r11
  int8x16_t *v114; // r5
  int v115; // r1
  int8x16_t *v116; // r6
  int v117; // r3
  unsigned int v118; // r2
  _BOOL4 v119; // r2
  bool v120; // zf
  int v121; // r4
  _BOOL4 v122; // r3
  _BOOL4 v123; // r5
  bool v124; // zf
  unsigned __int8 *v125; // r0
  _BYTE *v126; // r5
  _BYTE *v127; // r1
  int v128; // r3
  uint8x16_t v129; // q8
  int8x16_t v130; // q9
  unsigned int v131; // r3
  unsigned int v132; // r2
  unsigned int v133; // t1
  png_size_t v134; // r3
  int v135; // r0
  uint8x8_t *v136; // r4
  int v137; // lr
  int v138; // r3
  png_size_t v139; // r0
  int v140; // r6
  uint8x8_t *v141; // r8
  int v142; // r4
  unsigned int v143; // r0
  _BOOL4 v144; // r5
  bool v145; // zf
  uint8x8_t *v146; // r6
  int8x8_t *v147; // r4
  uint8x8_t *v148; // lr
  unsigned int v149; // r0
  uint8x8_t v150; // d16
  uint8x8_t v151; // d17
  uint8x8_t v152; // d18
  uint8x8_t v153; // d19
  uint16x8_t v154; // q10
  uint16x8_t v155; // q8
  uint16x8_t v156; // q11
  uint8x8_t v157; // d24
  uint8x8_t v158; // d25
  int16x8_t v159; // q9
  uint16x8_t v160; // q14
  uint16x8_t v161; // q12
  uint32x4_t v162; // q13
  int16x8_t v163; // q10
  uint32x4_t v164; // q11
  uint32x4_t v165; // q8
  int32x4_t v166; // q15
  png_size_t v167; // r0
  unsigned __int8 *v168; // r1
  int v169; // r3
  int v170; // t1
  int v171; // r5
  int v172; // t1
  unsigned int v173; // r3
  int8x16_t v174; // q8
  int8x16_t v175; // q9
  png_size_t v176; // r3
  char *v177; // r2
  _BYTE *v178; // r0
  char *v179; // r1
  char v180; // r6
  char v181; // t1
  char v182; // t1
  png_bytep v183; // r9
  png_byte *v184; // r4
  png_bytep v185; // r5
  png_bytep v186; // r6
  unsigned __int32 *v187; // r11
  unsigned __int8 *v188; // lr
  unsigned int v189; // r2
  unsigned __int32 v190; // r1
  png_size_t v191; // r2
  png_byte *v192; // r0
  unsigned int v193; // r3
  int v194; // r12
  unsigned int v195; // r2
  _BOOL4 v196; // r3
  _BOOL4 v197; // r0
  _BOOL4 v198; // r2
  bool v199; // zf
  unsigned __int8 *v200; // r9
  png_byte *v201; // r6
  unsigned __int8 *v202; // r2
  int v203; // r3
  unsigned int v204; // r0
  unsigned int v205; // r3
  unsigned int v206; // t1
  int v207; // t1
  int v208; // r3
  int v209; // r5
  unsigned __int8 *v210; // r6
  int v211; // r0
  bool v212; // cf
  png_byte *v213; // r0
  png_bytep v214; // lr
  int8x16_t *v215; // r0
  png_bytep v216; // r4
  png_bytep v217; // r5
  int8x16_t *v218; // r6
  int64x2_t *v219; // r10
  unsigned int v220; // r9
  png_bytep v221; // r12
  int v222; // r8
  png_bytep *v223; // r4
  png_row_infop v224; // r0
  png_bytep v225; // r5
  png_byte *v226; // lr
  png_bytep v227; // r9
  png_bytep v228; // r12
  unsigned __int32 *v229; // r10
  int v230; // r6
  unsigned int v231; // r4
  unsigned __int32 v232; // r0
  unsigned int v233; // r3
  int64x2_t *v234; // r2
  char v235; // r2
  unsigned int v236; // r4
  int8x16_t *v237; // r5
  _BYTE *v238; // r4
  char *v239; // r3
  int v240; // r2
  int8x16_t *v241; // r1
  int8x16_t v242; // q8
  int8x16_t v243; // q9
  int v244; // r2
  png_byte *v245; // r9
  unsigned int v246; // r0
  char v247; // r1
  char v248; // t1
  unsigned __int8 v249; // t1
  png_size_t v250; // r1
  int8x16_t *v251; // r11
  int8x16_t *v252; // r9
  int64x2_t *v253; // r12
  png_bytep v254; // lr
  int v255; // r4
  int64x2_t *v256; // r4
  unsigned int v257; // r12
  int v258; // r3
  int v259; // r11
  png_bytep v260; // r5
  int v261; // lr
  int64x2_t *v262; // r1
  int v263; // r3
  png_size_t v264; // r9
  int v265; // r8
  png_size_t v266; // r12
  int v267; // r9
  _BOOL4 v268; // r4
  bool v269; // zf
  unsigned int v270; // r8
  int64x2_t v271; // q9
  int64x2_t v272; // q10
  uint16x8_t v273; // q11
  uint16x8_t v274; // q3
  int64x2_t v275; // q8
  uint16x8_t v276; // q12
  uint16x8_t v277; // q4
  uint16x8_t v278; // q14
  uint16x8_t v279; // q2
  int16x8_t v280; // q0
  int32x4_t v281; // q15
  int32x4_t v282; // q1
  int32x4_t v283; // q6
  int64x2_t v284; // q13
  int32x4_t v285; // q13
  int32x4_t v286; // q5
  int32x4_t v287; // q15
  int32x4_t v288; // q2
  int32x4_t v289; // q7
  int32x4_t v290; // q3
  int16x8_t v291; // q13
  int32x4_t v292; // q3
  int32x4_t v293; // q4
  int16x8_t v294; // q14
  int32x4_t v295; // q1
  int32x4_t v296; // q11
  int32x4_t v297; // q1
  int64x2_t v298; // q12
  int32x4_t v299; // q4
  int32x4_t v300; // q11
  int64x2_t v301; // q12
  int8x16_t v302; // q9
  int64x2_t v303; // q8
  int v304; // r1
  unsigned __int32 *v305; // r3
  unsigned int v306; // r2
  int v307; // r1
  unsigned int v308; // r4
  _BOOL4 v309; // r2
  _BOOL4 v310; // r3
  _BOOL4 v311; // r4
  bool v312; // zf
  int8x16_t v313; // q8
  int v314; // r9
  int64x2_t v315; // q9
  uint32x4_t v316; // q10
  int32x4_t v317; // q11
  char *v318; // r1
  png_byte *v319; // r4
  char *v320; // r5
  unsigned __int32 *v321; // r8
  unsigned __int32 v322; // t1
  unsigned __int32 v323; // t1
  int32x4_t v324; // q12
  int32x4_t v325; // q13
  int v326; // r3
  int32x4_t v327; // q8
  unsigned int v328; // r2
  char v329; // r3
  char v330; // t1
  char v331; // t1
  unsigned __int8 v332; // r3
  int v333; // r6
  unsigned __int8 *v334; // r4
  int v335; // r12
  int v336; // r5
  int v337; // r11
  int v338; // r3
  char v339; // r8
  int v340; // r1
  unsigned int v341; // r1
  bool v342; // cf
  png_byte *v343; // r0
  png_size_t v344; // r1
  unsigned __int8 *v345; // lr
  unsigned __int8 *v346; // r8
  int v347; // r4
  int v348; // t1
  int v349; // r3
  int v350; // t1
  char v351; // r2
  int v352; // t1
  int v353; // r6
  int v354; // r5
  int v355; // r0
  unsigned __int8 v356; // r0
  unsigned __int8 v357; // t1
  png_byte *v358; // r0
  __int64 v359; // r0
  int8x16_t v360; // q8
  int64x2_t v361; // q9
  uint32x4_t v362; // q10
  int32x4_t v363; // q11
  int v364; // r1
  unsigned __int32 v365; // t1
  unsigned __int32 v366; // t1
  uint16x8_t v367; // q12
  int32x4_t v368; // q12
  int32x4_t v369; // q13
  int32x4_t v370; // q8
  int v371; // [sp+4h] [bp-B4h]
  unsigned int v372; // [sp+4h] [bp-B4h]
  unsigned int v373; // [sp+8h] [bp-B0h]
  unsigned int v374; // [sp+8h] [bp-B0h]
  png_size_t v375; // [sp+8h] [bp-B0h]
  png_bytep v376; // [sp+8h] [bp-B0h]
  png_size_t v377; // [sp+Ch] [bp-ACh]
  png_bytep v378; // [sp+Ch] [bp-ACh]
  unsigned int v379; // [sp+Ch] [bp-ACh]
  int v380; // [sp+10h] [bp-A8h]
  png_bytep v381; // [sp+10h] [bp-A8h]
  png_bytep v382; // [sp+10h] [bp-A8h]
  int v383; // [sp+10h] [bp-A8h]
  const png_byte *v384; // [sp+14h] [bp-A4h]
  png_bytep v385; // [sp+14h] [bp-A4h]
  const png_byte *v386; // [sp+14h] [bp-A4h]
  const png_byte *v387; // [sp+14h] [bp-A4h]
  int v388; // [sp+14h] [bp-A4h]
  int v390; // [sp+1Ch] [bp-9Ch]
  int v391; // [sp+1Ch] [bp-9Ch]
  png_byte *v392; // [sp+1Ch] [bp-9Ch]
  unsigned int v393; // [sp+20h] [bp-98h]
  int v394; // [sp+20h] [bp-98h]
  png_bytep *p_prev_row; // [sp+20h] [bp-98h]
  int v396; // [sp+20h] [bp-98h]
  png_structrp_12 v397; // [sp+24h] [bp-94h]
  unsigned int v398; // [sp+28h] [bp-90h]
  unsigned __int32 v399; // [sp+28h] [bp-90h]
  unsigned __int32 v400; // [sp+28h] [bp-90h]
  png_bytep v401; // [sp+28h] [bp-90h]
  png_bytep v402; // [sp+28h] [bp-90h]
  unsigned __int32 v403; // [sp+28h] [bp-90h]
  png_byte *v404; // [sp+28h] [bp-90h]
  unsigned int v405; // [sp+2Ch] [bp-8Ch]
  unsigned int v406; // [sp+30h] [bp-88h]
  unsigned int v407; // [sp+30h] [bp-88h]
  int32x4_t v408; // [sp+30h] [bp-88h]
  int v409; // [sp+30h] [bp-88h]
  unsigned __int32 v410; // [sp+40h] [bp-78h]
  int8x8x2_t v411; // 0:d24.8,8:d25.8

  v3 = png_ptr;
  row_buf = png_ptr->row_buf;
  rowbytes = row_info->rowbytes;
  do_filter = png_ptr->do_filter;
  v7 = ((unsigned int)row_info->pixel_depth + 7) >> 3;
  v393 = row_info->pixel_depth + 7;
  v406 = v7;
  if ( rowbytes >= 0x1FFFFFF )
  {
    v8 = -257;
    do_filter &= -do_filter;
    goto LABEL_20;
  }
  v9 = do_filter == 8;
  v8 = -257;
  if ( do_filter != 8 )
    v9 = (do_filter & 8) == 0;
  if ( !v9 )
  {
    if ( rowbytes )
    {
      if ( rowbytes >= 4 && (v10 = rowbytes & 0x1FFFFFC, (rowbytes & 0xFFFFFFFC) != 0) )
      {
        v11.n128_u64[0] = 0x1800000018LL;
        v11.n128_u64[1] = 0x1800000018LL;
        v12 = (png_bytep)&row_buf[v10];
        v13 = 0uLL;
        v14 = (unsigned __int32 *)(row_buf + 1);
        v2.n128_u16[0] = -1;
        v2.n128_u8[2] = -1;
        v2.n128_u8[3] = -1;
        v2.n128_u8[4] = -1;
        v2.n128_u8[5] = -1;
        v2.n128_u8[6] = -1;
        v2.n128_u8[7] = -1;
        v15 = vnegq_s32(v11);
        v16 = rowbytes & 0xFFFFFFFC;
        v17.n128_u64[0] = 0xFF000000FFLL;
        v17.n128_u64[1] = 0xFF000000FFLL;
        v411.val[0].n64_u64[0] = 0x10000000100LL;
        v411.val[1].n64_u64[0] = 0x10000000100LL;
        do
        {
          v18 = *v14++;
          v16 -= 4;
          v2.n128_u32[2] = v18;
          v19.n64_u64[0] = vmovl_s8(*(int8x8_t *)&v2.n128_i8[8]).n128_u64[0];
          *(int16x4_t *)&v2.n128_i8[8] = vcgt_s16(v19, (int16x4_t)v2.n128_u64[0]);
          v20 = vandq_s64(vmovl_u16(v19), v17);
          v13 = vaddq_s32(
                  vbslq_s64(
                    vshlq_s32(v15, vshlq_n_s32(vmovl_u16(*(uint16x4_t *)&v2.n128_i8[8]), 0x18u)),
                    v20,
                    vsubq_s32((int32x4_t)v411, v20)),
                  v13);
        }
        while ( v16 );
        v21 = vaddq_s32(v13, vextq_s8(v13, v13, 8u));
        v2 = vdupq_lane_s32((int32x2_t)v21.n128_u64[0], 1);
        v8 = vaddq_s32(v21, v2).n128_u32[0];
        if ( rowbytes == v10 )
        {
LABEL_18:
          v7 = v406;
          goto LABEL_20;
        }
      }
      else
      {
        v8 = 0;
        v12 = png_ptr->row_buf;
        v10 = 0;
      }
      v22 = rowbytes - v10;
      v23 = (char *)(v12 + 1);
      do
      {
        v24 = *v23++;
        v25 = (unsigned __int8)v24;
        if ( v24 <= -1 )
          v25 = 256 - v25;
        --v22;
        v8 += v25;
      }
      while ( v22 );
      goto LABEL_18;
    }
    v8 = 0;
  }
LABEL_20:
  v405 = rowbytes;
  v390 = do_filter;
  if ( do_filter == 16 )
  {
    try_row = v3->try_row;
    *try_row = 1;
    v27 = try_row + 1;
    v28 = row_buf + 1;
    if ( !v7 )
    {
      v61 = 0;
      if ( !rowbytes )
        goto LABEL_84;
      goto LABEL_50;
    }
    v29 = v7 + 1;
    if ( v393 < 0x80 )
      goto LABEL_44;
    v30 = v7 & 0x30;
    if ( (v7 & 0x30) == 0 )
      goto LABEL_44;
    v31 = v27 >= &row_buf[v29];
    if ( v27 < &row_buf[v29] )
      v31 = v28 >= &try_row[v29];
    if ( v31 )
    {
      v32 = &v27[v30];
      v33 = &v28[v30];
      v34 = v7 & 0x30;
      do
      {
        v35 = *(_QWORD *)v28;
        v36 = *((_QWORD *)v28 + 1);
        v28 += 16;
        v34 -= 16;
        *(_QWORD *)v27 = v35;
        *((_QWORD *)v27 + 1) = v36;
        v27 += 16;
      }
      while ( v34 );
      v7 = v406;
      if ( v406 == v30 )
      {
LABEL_47:
        v28 = &row_buf[v29];
        v27 = &try_row[v29];
        row_buf = v3->row_buf;
        v61 = v7;
        rowbytes = v405;
        if ( v405 <= v7 )
          goto LABEL_84;
LABEL_50:
        v62 = rowbytes - v61;
        if ( rowbytes - v61 >= 0x10 )
        {
          if ( (v62 & 0xFFFFFFF0) != 0 )
          {
            v398 = v62 & 0xFFFFFFF0;
            v71 = 0;
            v72 = (int8x16_t *)&v27[v62];
            if ( v27 < &v28[v62] )
              v71 = 1;
            v73 = 0;
            v74 = (int8x16_t *)(row_buf + 1);
            if ( v28 < (const png_byte *)v72 )
              v73 = 1;
            v75 = v74 < v72;
            v76 = v27 < &row_buf[v405 + 1 - v61];
            v77 = !v76 || !v75;
            if ( !v76 || !v75 )
              v77 = (v71 & v73) == 0;
            if ( v77 )
            {
              do_filter = 16;
              v64 = &v28[v398];
              v63 = &v27[v398];
              v61 += v398;
              row_buf += v398;
              v80 = v62 & 0xFFFFFFF0;
              do
              {
                v81 = *v74++;
                v80 -= 16;
                v82 = *(int8x16_t *)v28;
                v28 += 16;
                *(int8x16_t *)v27 = vsubq_s8(v82, v81);
                v27 += 16;
              }
              while ( v80 );
              rowbytes = v405;
              if ( v62 == v398 )
                goto LABEL_84;
            }
            else
            {
              v63 = v27;
              v64 = v28;
              rowbytes = v405;
              do_filter = 16;
            }
          }
          else
          {
            v63 = v27;
            v64 = v28;
            rowbytes = v405;
          }
        }
        else
        {
          v63 = v27;
          v64 = v28;
        }
        v83 = rowbytes - v61;
        v84 = (char *)(row_buf + 1);
        do
        {
          v86 = *v84++;
          v85 = v86;
          --v83;
          v87 = *v64++;
          *v63++ = v87 - v85;
        }
        while ( v83 );
LABEL_84:
        row_buf = v3->try_row;
        v7 = v406;
        goto LABEL_85;
      }
    }
    else
    {
LABEL_44:
      v30 = 0;
      v33 = row_buf + 1;
      v32 = try_row + 1;
    }
    v59 = v7 - v30;
    do
    {
      v60 = *v33++;
      --v59;
      *v32++ = v60;
    }
    while ( v59 );
    goto LABEL_47;
  }
  if ( (do_filter & 0x10) == 0 )
    goto LABEL_85;
  v37 = v3->try_row;
  v38 = (png_byte *)(row_buf + 1);
  *v37 = 1;
  v39 = v37 + 1;
  if ( !v7 )
  {
    v69 = 0;
    v58 = 0;
    v70 = row_buf + 1;
    goto LABEL_68;
  }
  v40 = v7 + 1;
  v384 = row_buf;
  if ( v393 < 0x20 )
    goto LABEL_52;
  v41 = v7 & 0x3C;
  if ( (v7 & 0x3C) == 0 )
    goto LABEL_52;
  v42 = v39 >= &v384[v40];
  if ( v39 < &v384[v40] )
    v42 = v38 >= &v37[v40];
  if ( !v42 )
  {
LABEL_52:
    v58 = 0;
    v46 = v38;
    v44 = v37 + 1;
    v41 = 0;
    goto LABEL_53;
  }
  v43.n128_u64[0] = 0x1800000018LL;
  v43.n128_u64[1] = 0x1800000018LL;
  v44 = &v39[v41];
  v45 = 0uLL;
  v46 = &v38[v41];
  v2.n128_u16[0] = -1;
  v2.n128_u8[2] = -1;
  v2.n128_u8[3] = -1;
  v2.n128_u8[4] = -1;
  v2.n128_u8[5] = -1;
  v2.n128_u8[6] = -1;
  v2.n128_u8[7] = -1;
  v47 = vnegq_s32(v43);
  v48 = v7 & 0x3C;
  v49 = (unsigned __int32 *)v38;
  v50.n128_u64[0] = 0xFF000000FFLL;
  v50.n128_u64[1] = 0xFF000000FFLL;
  v411.val[0].n64_u64[0] = 0x10000000100LL;
  v411.val[1].n64_u64[0] = 0x10000000100LL;
  do
  {
    v51 = *v49++;
    v48 -= 4;
    v2.n128_u32[2] = v51;
    v52.n64_u64[0] = vmovl_s8(*(int8x8_t *)&v2.n128_i8[8]).n128_u64[0];
    v53.n64_u64[0] = vcgt_s16(v52, (int16x4_t)v2.n128_u64[0]).n64_u64[0];
    v54 = vmovl_u16(v52);
    v55 = vmovl_u16(v53);
    v2 = (int32x4_t)vuzp_s8(v52, v53);
    v56 = vandq_s64(v54, v50);
    *(_DWORD *)v39 = v52.n64_u32[0];
    v39 += 8;
    v45 = vaddq_s32(vbslq_s64(vshlq_s32(v47, vshlq_n_s32(v55, 0x18u)), v56, vsubq_s32((int32x4_t)v411, v56)), v45);
  }
  while ( v48 );
  v57 = vaddq_s32(v45, vextq_s8(v45, v45, 8u));
  v58 = vaddq_s32(v57, vdupq_lane_s32((int32x2_t)v57.n128_u64[0], 1)).n128_u32[0];
  if ( v406 != v41 )
  {
LABEL_53:
    v65 = v406 - v41;
    do
    {
      v67 = (char)*v46++;
      v66 = v67;
      v68 = (unsigned __int8)v67;
      if ( v67 <= -1 )
        v68 = 256 - v68;
      *v44++ = v66;
      v58 += v68;
      --v65;
    }
    while ( v65 );
  }
  row_buf = v384;
  v39 = &v37[v40];
  v69 = v406;
  v70 = &v384[v40];
LABEL_68:
  for ( rowbytes = v405; v69 < v405; ++v69 )
  {
    LOBYTE(v78) = *v70 - *v38;
    *v39 = v78;
    v78 = (unsigned __int8)v78;
    if ( (unsigned __int8)v78 >= 0x80u )
      v78 = 256 - (unsigned __int8)v78;
    v58 += v78;
    if ( v58 > v8 )
      break;
    ++v38;
    ++v39;
    ++v70;
  }
  v7 = v406;
  do_filter = v390;
  if ( v58 < v8 )
  {
    tst_row = v3->tst_row;
    row_buf = v3->try_row;
    v8 = v58;
    if ( tst_row )
    {
      v3->try_row = tst_row;
      v3->tst_row = (png_bytep)row_buf;
    }
  }
LABEL_85:
  v397 = v3;
  if ( do_filter == 32 )
  {
    v88 = v3->try_row;
    *v88 = 2;
    if ( !rowbytes )
      goto LABEL_161;
    v90 = v3->row_buf;
    prev_row = v3->prev_row;
    if ( rowbytes >= 0x10 )
    {
      v107 = rowbytes;
      v108 = rowbytes & 0xFFFFFFF0;
      v91 = 0;
      if ( v108 )
      {
        v109 = v107 + 1;
        v400 = v8;
        v110 = (unsigned int)&v88[v107 + 1];
        v111 = (int8x16_t *)(prev_row + 1);
        v112 = (unsigned int)&prev_row[v107 + 1];
        v113 = 0;
        v114 = (int8x16_t *)(v88 + 1);
        if ( (unsigned int)(prev_row + 1) < v110 )
          v113 = 1;
        v31 = (unsigned int)v114 >= v112;
        v115 = 0;
        v116 = (int8x16_t *)(v90 + 1);
        if ( !v31 )
          v115 = 1;
        v117 = 0;
        v118 = (unsigned int)&v90[v109];
        if ( (unsigned int)v116 < v110 )
          v117 = 1;
        v119 = (unsigned int)v114 < v118;
        v120 = (v119 & v117) == 0;
        if ( (v119 & v117) == 0 )
          v120 = (v115 & v113) == 0;
        if ( v120 )
        {
          v3 = v397;
          v8 = v400;
          v91 = v108;
          prev_row += v108;
          v88 += v108;
          v90 += v108;
          v173 = v108;
          do
          {
            v174 = *v111++;
            v173 -= 16;
            v175 = *v116++;
            *v114++ = vsubq_s8(v175, v174);
          }
          while ( v173 );
          v9 = v405 == v108;
          rowbytes = v405;
          if ( v9 )
          {
LABEL_161:
            row_buf = v3->try_row;
            v7 = v406;
            do_filter = v390;
            if ( v390 != 64 )
              goto LABEL_162;
LABEL_100:
            v399 = v8;
            v98 = v3->try_row;
            *v98 = 3;
            v99 = (int8x8_t *)(v98 + 1);
            v100 = v3->row_buf;
            v101 = v3->prev_row;
            v102 = (uint8x8_t *)(v100 + 1);
            v103 = (uint8x8_t *)(v101 + 1);
            if ( !v7 )
            {
              v106 = 0;
              v3 = v397;
              if ( !rowbytes )
                goto LABEL_153;
LABEL_129:
              v134 = rowbytes - v106;
              if ( rowbytes - v106 >= 0x10 && (v134 & 0xFFFFFFF0) != 0 )
              {
                v373 = v134 & 0xFFFFFFF0;
                v135 = 0;
                v136 = (int8x8_t *)((char *)v99 + v134);
                if ( v99 < (uint8x8_t *)((char *)v103 + v134) )
                  v135 = 1;
                v137 = 0;
                v380 = v135;
                if ( v103 < v136 )
                  v137 = 1;
                v377 = rowbytes - v106;
                v31 = v99 >= (uint8x8_t *)((char *)v102 + v134);
                v138 = 0;
                v139 = rowbytes + 1 - v106;
                if ( !v31 )
                  v138 = 1;
                v140 = 0;
                v141 = (uint8x8_t *)(v100 + 1);
                if ( v102 < v136 )
                  v140 = 1;
                v31 = v141 >= v136;
                v142 = 0;
                v143 = (unsigned int)&v100[v139];
                if ( !v31 )
                  v142 = 1;
                v144 = (unsigned int)v99 < v143;
                v145 = (v144 & v142) == 0;
                if ( (v144 & v142) == 0 )
                  v145 = (v138 & v140) == 0;
                if ( !v145 || (v380 & v137) != 0 )
                {
                  v148 = v103;
                  v147 = v99;
                  v146 = v102;
                  rowbytes = v405;
                }
                else
                {
                  v146 = (uint8x8_t *)((char *)v102 + v373);
                  v147 = (int8x8_t *)((char *)v99 + v373);
                  v148 = (uint8x8_t *)((char *)v103 + v373);
                  v106 += v373;
                  v100 += v373;
                  v149 = v373;
                  do
                  {
                    v150.n64_u64[0] = v103->n64_u64[0];
                    v151.n64_u64[0] = v103[1].n64_u64[0];
                    v103 += 2;
                    v149 -= 16;
                    v152.n64_u64[0] = v141->n64_u64[0];
                    v153.n64_u64[0] = v141[1].n64_u64[0];
                    v141 += 2;
                    v154 = vmovl_u8(v151);
                    v155 = vmovl_u8(v150);
                    v156 = vmovl_u8(v153);
                    v157.n64_u64[0] = v102->n64_u64[0];
                    v158.n64_u64[0] = v102[1].n64_u64[0];
                    v102 += 2;
                    v159 = vmovl_u8(v152);
                    v160 = vmovl_u8(v158);
                    v161 = vmovl_u8(v157);
                    v162 = vaddl_u16(*(uint16x4_t *)&v156.n128_i8[8], *(uint16x4_t *)&v154.n128_i8[8]);
                    v163 = vaddl_u16((uint16x4_t)v156.n128_u64[0], (uint16x4_t)v154.n128_u64[0]);
                    v164 = vaddl_u16(*(uint16x4_t *)&v159.n128_i8[8], *(uint16x4_t *)&v155.n128_i8[8]);
                    v165 = vaddl_u16((uint16x4_t)v159.n128_u64[0], (uint16x4_t)v155.n128_u64[0]);
                    v166 = vmovl_u16(*(uint16x4_t *)&v161.n128_i8[8]);
                    v411 = (int8x8x2_t)vmovl_u16((uint16x4_t)v161.n128_u64[0]);
                    *(int16x4_t *)&v159.n128_i8[8] = vmovn_s32(
                                                       vsubq_s32(
                                                         vmovl_u16(*(uint16x4_t *)&v160.n128_i8[8]),
                                                         vshrq_n_u32(v162, 1u)));
                    v159.n128_u64[0] = vmovn_s32(vsubq_s32(vmovl_u16((uint16x4_t)v160.n128_u64[0]), vshrq_n_u32(v163, 1u))).n64_u64[0];
                    *(int16x4_t *)&v163.n128_i8[8] = vmovn_s32(vsubq_s32(v166, vshrq_n_u32(v164, 1u)));
                    v163.n128_u64[0] = vmovn_s32(vsubq_s32((int32x4_t)v411, vshrq_n_u32(v165, 1u))).n64_u64[0];
                    v99->n64_u64[0] = vmovn_s16(v163).n64_u64[0];
                    v99[1].n64_u64[0] = vmovn_s16(v159).n64_u64[0];
                    v99 += 2;
                  }
                  while ( v149 );
                  rowbytes = v405;
                  if ( v377 == v373 )
                  {
LABEL_153:
                    row_buf = v3->try_row;
                    v7 = v406;
                    v8 = v399;
                    LOBYTE(do_filter) = v390;
                    if ( v390 == 128 )
                      goto LABEL_192;
                    goto LABEL_195;
                  }
                }
              }
              else
              {
                v148 = v103;
                v147 = v99;
                v146 = v102;
              }
              v167 = rowbytes - v106;
              v168 = v100 + 1;
              do
              {
                v170 = v148->n64_u8[0];
                v148 = (uint8x8_t *)((char *)v148 + 1);
                v169 = v170;
                --v167;
                v172 = *v168++;
                v171 = v172;
                LOBYTE(v172) = v146->n64_u8[0];
                v146 = (uint8x8_t *)((char *)v146 + 1);
                v147->n64_u8[0] = v172 - ((unsigned int)(v169 + v171) >> 1);
                v147 = (int8x8_t *)((char *)v147 + 1);
              }
              while ( v167 );
              goto LABEL_153;
            }
            v104 = v7 + 1;
            v385 = v100;
            if ( v393 >= 0x80 )
            {
              v121 = v7 & 0x30;
              v105 = 0;
              if ( (v7 & 0x30) != 0 )
              {
                v122 = v102 < (uint8x8_t *)&v98[v104];
                v123 = v99 < (int8x8_t *)&v100[v104];
                v124 = !v123 || !v122;
                if ( !v123 || !v122 )
                  v124 = v103 >= (uint8x8_t *)&v98[v104] || v99 >= (int8x8_t *)&v101[v104];
                if ( v124 )
                {
                  v105 = v121;
                  v125 = (unsigned __int8 *)v103 + v121;
                  v126 = (char *)v99 + v121;
                  v127 = (char *)v102 + v121;
                  v128 = v121;
                  do
                  {
                    v129 = *(uint8x16_t *)v103->n64_u64;
                    v103 += 2;
                    v128 -= 16;
                    v130 = *(int8x16_t *)v102->n64_u64;
                    v102 += 2;
                    *(int8x16_t *)v99->n64_u64 = vsubq_s8(v130, vshrq_n_u8(v129, 1u));
                    v99 += 2;
                  }
                  while ( v128 );
                  if ( v406 == v121 )
                  {
LABEL_128:
                    v103 = (uint8x8_t *)&v101[v104];
                    v3 = v397;
                    v99 = (int8x8_t *)&v98[v104];
                    v100 = v397->row_buf;
                    v102 = (uint8x8_t *)&v385[v104];
                    rowbytes = v405;
                    v106 = v406;
                    if ( v405 <= v406 )
                      goto LABEL_153;
                    goto LABEL_129;
                  }
LABEL_126:
                  v131 = v406 - v105;
                  do
                  {
                    v133 = *v125++;
                    v132 = v133;
                    --v131;
                    LOBYTE(v133) = *v127++;
                    *v126++ = v133 - (v132 >> 1);
                  }
                  while ( v131 );
                  goto LABEL_128;
                }
              }
            }
            else
            {
              v105 = 0;
            }
            v127 = v100 + 1;
            v126 = v98 + 1;
            v125 = v101 + 1;
            goto LABEL_126;
          }
        }
        else
        {
          rowbytes = v405;
          v3 = v397;
          v8 = v400;
        }
      }
      else
      {
        rowbytes = v107;
      }
    }
    else
    {
      v91 = 0;
    }
    v176 = rowbytes - v91;
    v177 = (char *)(prev_row + 1);
    v178 = v88 + 1;
    v179 = (char *)(v90 + 1);
    do
    {
      v181 = *v177++;
      v180 = v181;
      --v176;
      v182 = *v179++;
      *v178++ = v182 - v180;
    }
    while ( v176 );
    goto LABEL_161;
  }
  if ( (do_filter & 0x20) != 0 )
  {
    v92 = v3->try_row;
    *v92 = 2;
    v93 = 0;
    if ( rowbytes )
    {
      v94 = *(_QWORD *)&v3->prev_row;
      v95 = 1;
      do
      {
        LOBYTE(v96) = *(_BYTE *)(HIDWORD(v94) + v95) - *(_BYTE *)(v94 + v95);
        v92[v95] = v96;
        v96 = (unsigned __int8)v96;
        if ( (unsigned __int8)v96 >= 0x80u )
          v96 = 256 - (unsigned __int8)v96;
        v93 += v96;
        if ( v95 >= rowbytes )
          break;
        ++v95;
      }
      while ( v93 <= v8 );
    }
    v7 = v406;
    if ( v93 < v8 )
    {
      v97 = v3->tst_row;
      row_buf = v3->try_row;
      v8 = v93;
      if ( v97 )
      {
        v3->try_row = v97;
        v3->tst_row = (png_bytep)row_buf;
      }
    }
  }
  if ( do_filter == 64 )
    goto LABEL_100;
LABEL_162:
  if ( (do_filter & 0x40) == 0 )
    goto LABEL_191;
  v386 = row_buf;
  v183 = v3->try_row;
  *v183 = 3;
  v184 = v183 + 1;
  v185 = v3->row_buf;
  v186 = v3->prev_row;
  v187 = (unsigned __int32 *)(v185 + 1);
  v188 = v186 + 1;
  if ( !v7 )
  {
    v191 = 0;
    v190 = 0;
    if ( rowbytes )
      goto LABEL_181;
    goto LABEL_188;
  }
  v189 = v7 + 1;
  v401 = v185;
  v374 = v7 + 1;
  v378 = v186;
  v381 = v183;
  if ( v393 < 0x20 )
  {
    v190 = 0;
LABEL_175:
    v200 = v185 + 1;
    v201 = v184;
    v202 = v188;
    v203 = 0;
    goto LABEL_176;
  }
  v190 = 0;
  if ( (v7 & 0x3C) == 0 )
    goto LABEL_175;
  v371 = v7 & 0x3C;
  v192 = &v183[v189];
  v193 = (unsigned int)&v186[v189];
  v31 = v188 >= &v183[v189];
  v194 = 0;
  v195 = (unsigned int)&v185[v189];
  if ( !v31 )
    v194 = 1;
  v196 = (unsigned int)v184 < v193;
  v197 = v187 < (unsigned __int32 *)v192;
  v198 = (unsigned int)v184 < v195;
  v199 = !v198 || !v197;
  if ( !v198 || !v197 )
    v199 = (v196 & v194) == 0;
  if ( v199 )
  {
    v360 = 0uLL;
    v361.n128_u64[0] = 0xFF000000FFLL;
    v361.n128_u64[1] = 0xFF000000FFLL;
    do_filter = v390;
    v362.n128_u64[0] = 0x8000000080LL;
    v362.n128_u64[1] = 0x8000000080LL;
    v363.n128_u64[0] = 0x10000000100LL;
    v363.n128_u64[1] = 0x10000000100LL;
    v202 = &v188[v371];
    v201 = &v184[v371];
    v200 = (unsigned __int8 *)v187 + v371;
    v364 = v371;
    do
    {
      v365 = *(_DWORD *)v188;
      v188 += 4;
      v364 -= 4;
      v411.val[0].n64_u32[0] = v365;
      v366 = *v187++;
      v367 = vmovl_u8(v411.val[0]);
      v367.n128_u32[2] = v366;
      v368 = vsubq_s32(
               vmovl_u16((uint16x4_t)vmovl_u8(*(uint8x8_t *)&v367.n128_i8[8]).n128_u64[0]),
               vandq_s64(vmovl_u16(vshr_n_u16((uint16x4_t)v367.n128_u64[0], 1u)), v361));
      v369 = vandq_s64(v368, v361);
      v411 = vuzp_s8(vmovn_s32(v368), *(int8x8_t *)&v368.n128_i8[8]);
      *(_DWORD *)v184 = v411.val[0].n64_u32[0];
      v184 += 8;
      v360 = vaddq_s32(vbslq_s64(vcgtq_u32(v362, v369), v369, vsubq_s32(v363, v369)), v360);
    }
    while ( v364 );
    v203 = v371;
    v370 = vaddq_s32(v360, vextq_s8(v360, v360, 8u));
    rowbytes = v405;
    v190 = vaddq_s32(v370, vdupq_lane_s32((int32x2_t)v370.n128_u64[0], 1)).n128_u32[0];
    if ( v406 == v371 )
      goto LABEL_180;
  }
  else
  {
    v200 = v185 + 1;
    v201 = v184;
    v202 = v188;
    v203 = 0;
    do_filter = v390;
  }
LABEL_176:
  v204 = v406 - v203;
  do
  {
    v206 = *v202++;
    v205 = v206;
    v207 = *v200++;
    v208 = v207 - (v205 >> 1);
    v209 = (unsigned __int8)v208;
    if ( (unsigned __int8)v208 >= 0x80u )
      v209 = 256 - (unsigned __int8)v208;
    *v201++ = v208;
    v190 += v209;
    --v204;
  }
  while ( v204 );
LABEL_180:
  v187 = (unsigned __int32 *)&v401[v374];
  v188 = &v378[v374];
  v185 = v397->row_buf;
  v184 = &v381[v374];
  v191 = v406;
  if ( v406 < rowbytes )
  {
LABEL_181:
    v210 = v185 + 1;
    do
    {
      LOBYTE(v211) = *(_BYTE *)v187 - ((*v210 + (unsigned int)*v188) >> 1);
      *v184 = v211;
      v211 = (unsigned __int8)v211;
      if ( (unsigned __int8)v211 >= 0x80u )
        v211 = 256 - (unsigned __int8)v211;
      v190 += v211;
      v212 = v190 >= v8;
      if ( v190 <= v8 )
      {
        ++v210;
        ++v191;
        v187 = (unsigned __int32 *)((char *)v187 + 1);
        ++v188;
        ++v184;
        v212 = v191 >= rowbytes;
      }
    }
    while ( !v212 );
  }
LABEL_188:
  v3 = v397;
  v7 = v406;
  row_buf = v386;
  if ( v190 < v8 )
  {
    v213 = v397->tst_row;
    row_buf = v397->try_row;
    v8 = v190;
    if ( v213 )
    {
      v397->try_row = v213;
      v397->tst_row = (png_bytep)row_buf;
    }
  }
LABEL_191:
  if ( do_filter == 128 )
  {
LABEL_192:
    v214 = v3->try_row;
    *v214 = 4;
    v215 = (int8x16_t *)(v214 + 1);
    v216 = v3->row_buf;
    v217 = v3->prev_row;
    v218 = (int8x16_t *)(v216 + 1);
    v219 = (int64x2_t *)(v217 + 1);
    if ( !v7 )
    {
      v233 = 0;
      v234 = (int64x2_t *)(v217 + 1);
      goto LABEL_216;
    }
    v220 = v7 + 1;
    v402 = v3->row_buf;
    if ( v393 >= 0x80 )
    {
      v222 = 0;
      if ( (v7 & 0x30) == 0 )
        goto LABEL_211;
      v235 = 0;
      v236 = (unsigned int)&v216[v220];
      if ( v215 < (int8x16_t *)&v217[v220] )
        v235 = 1;
      if ( (unsigned int)v215 < v236 && v218 < (int8x16_t *)&v214[v220] )
      {
LABEL_211:
        v221 = v3->prev_row;
      }
      else
      {
        v394 = v7 & 0x30;
        v221 = v3->prev_row;
        if ( ((v219 < (int64x2_t *)&v214[v220]) & (unsigned __int8)v235) == 0 )
        {
          v237 = (int8x16_t *)((char *)v218 + v394);
          v238 = (char *)v215 + v394;
          v222 = v7 & 0x30;
          v239 = (char *)v219 + v394;
          v240 = v394;
          v241 = v219;
          do
          {
            v242 = *v241++;
            v240 -= 16;
            v243 = *v218++;
            *v215++ = vsubq_s8(v243, v242);
          }
          while ( v240 );
          if ( v406 == v394 )
            goto LABEL_215;
          goto LABEL_213;
        }
      }
    }
    else
    {
      v221 = v3->prev_row;
      v222 = 0;
    }
    v239 = (char *)(v217 + 1);
    v238 = v214 + 1;
    v237 = v218;
LABEL_213:
    v246 = v406 - v222;
    do
    {
      v248 = *v239++;
      v247 = v248;
      --v246;
      v249 = v237->n128_u8[0];
      v237 = (int8x16_t *)((char *)v237 + 1);
      *v238++ = v249 - v247;
    }
    while ( v246 );
LABEL_215:
    v217 = v221;
    v216 = v3->row_buf;
    v234 = (int64x2_t *)&v221[v220];
    rowbytes = v405;
    v233 = v406;
    v218 = (int8x16_t *)&v402[v220];
    v215 = (int8x16_t *)&v214[v220];
LABEL_216:
    p_prev_row = &v3->prev_row;
    if ( rowbytes > v233 )
    {
      v250 = rowbytes - v233;
      if ( rowbytes - v233 < 0x10 )
      {
        v251 = v218;
        v252 = v215;
        v253 = v234;
        goto LABEL_289;
      }
      v254 = v216;
      if ( (v250 & 0xFFFFFFF0) != 0 )
      {
        v372 = v250 & 0xFFFFFFF0;
        v255 = 0;
        v392 = v217;
        if ( v215 < (int8x16_t *)((char *)v218 + v250) )
          v255 = 1;
        v388 = v255;
        v256 = (int8x16_t *)((char *)v215 + v250);
        v257 = v233;
        v258 = 0;
        v259 = 0;
        if ( v218 < (int8x16_t *)((char *)v215 + v250) )
          v258 = 1;
        v260 = v254;
        v383 = v258;
        v261 = 0;
        v375 = v250;
        v31 = v215 >= (int64x2_t *)((char *)v234 + v250);
        v262 = (int64x2_t *)(v260 + 1);
        if ( !v31 )
          v259 = 1;
        if ( v234 < v256 )
          v261 = 1;
        v263 = 0;
        v264 = rowbytes;
        if ( v262 < v256 )
          v263 = 1;
        v265 = 0;
        v407 = v257;
        v266 = v264 + 1 - v257;
        v267 = 0;
        v404 = v260;
        if ( v215 < (int8x16_t *)&v260[v266] )
          v267 = 1;
        v268 = v219 < v256;
        if ( v215 < (int8x16_t *)&v392[v266] )
          v265 = 1;
        if ( (v265 & v268) != 0 )
        {
          v251 = v218;
          v252 = v215;
          v253 = v234;
          v233 = v407;
          v217 = v392;
          v216 = v404;
          rowbytes = v405;
        }
        else
        {
          v269 = (v259 & v261) == 0;
          v216 = v260;
          rowbytes = v405;
          if ( (v259 & v261) == 0 )
            v269 = (v388 & v383) == 0;
          if ( !v269 || (v263 & v267) != 0 )
          {
            v251 = v218;
            v252 = v215;
            v253 = v234;
            v233 = v407;
            v217 = v392;
          }
          else
          {
            v253 = (int64x2_t *)((char *)v234 + v372);
            v233 = v407 + v372;
            v252 = (int8x16_t *)((char *)v215 + v372);
            v251 = (int8x16_t *)((char *)v218 + v372);
            v217 = &v392[v372];
            v216 = &v404[v372];
            v270 = v372;
            do
            {
              v271 = *v219++;
              v270 -= 16;
              v272 = *v234++;
              v273 = vmovl_u8((uint8x8_t)v271.n128_u64[0]);
              v274 = vmovl_u8(*(uint8x8_t *)&v271.n128_i8[8]);
              v275 = *v262++;
              v276 = vmovl_u8((uint8x8_t)v272.n128_u64[0]);
              v277 = vmovl_u8(*(uint8x8_t *)&v272.n128_i8[8]);
              v278 = vmovl_u8((uint8x8_t)v275.n128_u64[0]);
              v279 = vmovl_u8(*(uint8x8_t *)&v275.n128_i8[8]);
              v280 = vabdl_u16(*(uint16x4_t *)&v278.n128_i8[8], *(uint16x4_t *)&v273.n128_i8[8]);
              v281 = vabdl_u16(*(uint16x4_t *)&v276.n128_i8[8], *(uint16x4_t *)&v273.n128_i8[8]);
              v282 = vabsq_s32(
                       vaddq_s32(
                         vsubl_u16(*(uint16x4_t *)&v278.n128_i8[8], *(uint16x4_t *)&v273.n128_i8[8]),
                         vsubl_u16(*(uint16x4_t *)&v276.n128_i8[8], *(uint16x4_t *)&v273.n128_i8[8])));
              v283 = vabdl_u16((uint16x4_t)v279.n128_u64[0], (uint16x4_t)v274.n128_u64[0]);
              v284 = vorrq_s64(vcgtq_s32(v281, v280), vcgtq_s32(v281, v282));
              *(int16x4_t *)&v280.n128_i8[8] = vmovn_s32(vcgeq_s32(v282, v280));
              v408 = v284;
              v285 = vsubl_u16(*(uint16x4_t *)&v279.n128_i8[8], *(uint16x4_t *)&v274.n128_i8[8]);
              v286 = vabsq_s32(
                       vaddq_s32(
                         vsubl_u16((uint16x4_t)v279.n128_u64[0], (uint16x4_t)v274.n128_u64[0]),
                         vsubl_u16((uint16x4_t)v277.n128_u64[0], (uint16x4_t)v274.n128_u64[0])));
              v287 = vabdl_u16((uint16x4_t)v277.n128_u64[0], (uint16x4_t)v274.n128_u64[0]);
              v288 = vabdl_u16(*(uint16x4_t *)&v279.n128_i8[8], *(uint16x4_t *)&v274.n128_i8[8]);
              v289 = vsubl_u16(*(uint16x4_t *)&v277.n128_i8[8], *(uint16x4_t *)&v274.n128_i8[8]);
              v290 = vabdl_u16(*(uint16x4_t *)&v277.n128_i8[8], *(uint16x4_t *)&v274.n128_i8[8]);
              v291 = vabsq_s32(vaddq_s32(v285, v289));
              v292 = vorrq_s64(vcgtq_s32(v290, v288), vcgtq_s32(v290, v291));
              v293 = vsubl_u16((uint16x4_t)v278.n128_u64[0], (uint16x4_t)v273.n128_u64[0]);
              v294 = vabdl_u16((uint16x4_t)v278.n128_u64[0], (uint16x4_t)v273.n128_u64[0]);
              v295 = vaddq_s32(v293, vsubl_u16((uint16x4_t)v276.n128_u64[0], (uint16x4_t)v273.n128_u64[0]));
              v296 = vabdl_u16((uint16x4_t)v276.n128_u64[0], (uint16x4_t)v273.n128_u64[0]);
              v297 = vabsq_s32(v295);
              *(int16x4_t *)&v291.n128_i8[8] = vmovn_s32(vcgeq_s32(v291, v288));
              v298 = vcgtq_s32(v296, v294);
              v299 = vcgeq_s32(v297, v294);
              v291.n128_u64[0] = vmovn_s32(vcgeq_s32(v286, v283)).n64_u64[0];
              *(int16x4_t *)&v294.n128_i8[8] = vmovn_s32(v408);
              v300 = vorrq_s64(v298, vcgtq_s32(v296, v297));
              v280.n128_u64[0] = vmovn_s32(v299).n64_u64[0];
              *(int8x8_t *)&v298.n128_i8[8] = vmovn_s16(v291);
              *(int16x4_t *)&v291.n128_i8[8] = vmovn_s32(v292);
              v298.n128_u64[0] = vmovn_s16(v280).n64_u64[0];
              v291.n128_u64[0] = vmovn_s32(vorrq_s64(vcgtq_s32(v287, v283), vcgtq_s32(v287, v286))).n64_u64[0];
              v301 = vbslq_s64(v298, v272, v271);
              v294.n128_u64[0] = vmovn_s32(v300).n64_u64[0];
              *(int8x8_t *)&v271.n128_i8[8] = vmovn_s16(v291);
              v271.n128_u64[0] = vmovn_s16(v294).n64_u64[0];
              v302 = vbslq_s64(v271, v301, v275);
              v303 = *v218++;
              *v215++ = vsubq_s8(v303, v302);
            }
            while ( v270 );
            rowbytes = v405;
            if ( v375 == v372 )
              goto LABEL_303;
          }
        }
      }
      else
      {
        v251 = v218;
        v252 = v215;
        v253 = v234;
      }
LABEL_289:
      v344 = rowbytes - v233;
      v345 = v217 + 1;
      v346 = v216 + 1;
      do
      {
        v348 = *v345++;
        v347 = v348;
        v350 = v253->n128_u8[0];
        v253 = (int64x2_t *)((char *)v253 + 1);
        v349 = v350;
        v352 = *v346++;
        v351 = v352;
        v353 = v349 - v347;
        v354 = v352 - v347;
        v355 = v352 - v347 + v349 - v347;
        if ( v355 < 0 )
          v355 = -v355;
        if ( v354 < 0 )
          v354 = -v354;
        if ( v354 <= v355 )
          LOBYTE(v347) = v349;
        if ( v353 < 0 )
          v353 = -v353;
        if ( v353 > v355 )
          v351 = v347;
        v357 = v251->n128_u8[0];
        v251 = (int8x16_t *)((char *)v251 + 1);
        v356 = v357;
        if ( v353 > v354 )
          v351 = v347;
        --v344;
        v252->n128_u8[0] = v356 - v351;
        v252 = (int8x16_t *)((char *)v252 + 1);
      }
      while ( v344 );
    }
LABEL_303:
    v3 = v397;
    row_buf = v397->try_row;
LABEL_304:
    v224 = row_info;
    goto LABEL_305;
  }
LABEL_195:
  if ( (do_filter & 0x80) == 0 )
  {
    v223 = &v3->prev_row;
    v224 = row_info;
    goto LABEL_306;
  }
  v387 = row_buf;
  v403 = v8;
  v225 = v3->try_row;
  *v225 = 4;
  v226 = v225 + 1;
  v228 = v3->row_buf;
  v227 = v3->prev_row;
  v229 = (unsigned __int32 *)(v228 + 1);
  v230 = (int)(v227 + 1);
  if ( !v7 )
  {
    v244 = 0;
    v232 = 0;
    v245 = v227 + 1;
    goto LABEL_261;
  }
  v231 = v7 + 1;
  v391 = (int)(v227 + 1);
  v379 = v7 + 1;
  v382 = v225;
  if ( v393 < 0x20 )
  {
    v232 = 0;
LABEL_255:
    v320 = (char *)(v227 + 1);
    v319 = v226;
    v318 = (char *)(v228 + 1);
    v326 = 0;
    goto LABEL_256;
  }
  v304 = v7 & 0x3C;
  v232 = 0;
  if ( (v7 & 0x3C) == 0 )
    goto LABEL_255;
  v305 = (unsigned __int32 *)&v225[v231];
  v396 = v304;
  v306 = (unsigned int)&v227[v231];
  v31 = v230 >= (unsigned int)&v225[v231];
  v307 = 0;
  v308 = (unsigned int)&v228[v231];
  if ( !v31 )
    v307 = 1;
  v309 = (unsigned int)v226 < v306;
  v310 = v229 < v305;
  v311 = (unsigned int)v226 < v308;
  v312 = !v311 || !v310;
  if ( !v311 || !v310 )
    v312 = (v307 & v309) == 0;
  if ( !v312 )
    goto LABEL_255;
  v376 = v3->prev_row;
  v313 = 0uLL;
  v314 = v396;
  v315.n128_u64[0] = 0xFF000000FFLL;
  v315.n128_u64[1] = 0xFF000000FFLL;
  v316.n128_u64[0] = 0x8000000080LL;
  v316.n128_u64[1] = 0x8000000080LL;
  v317.n128_u64[0] = 0x10000000100LL;
  v317.n128_u64[1] = 0x10000000100LL;
  v318 = (char *)v229 + v396;
  v319 = &v226[v396];
  v320 = (char *)(v230 + v396);
  v321 = (unsigned __int32 *)v230;
  do
  {
    v322 = *v321++;
    v314 -= 4;
    v410 = v322;
    v323 = *v229++;
    v411.val[0].n64_u32[0] = v410;
    v411.val[1].n64_u32[0] = v323;
    v324 = vsubq_s32(
             vmovl_u16((uint16x4_t)vmovl_u8(v411.val[1]).n128_u64[0]),
             vmovl_u16((uint16x4_t)vmovl_u8(v411.val[0]).n128_u64[0]));
    v325 = vandq_s64(v324, v315);
    v411 = vuzp_s8(vmovn_s32(v324), *(int8x8_t *)&v324.n128_i8[8]);
    *(_DWORD *)v226 = v411.val[0].n64_u32[0];
    v226 += 8;
    v313 = vaddq_s32(vbslq_s64(vcgtq_u32(v316, v325), v325, vsubq_s32(v317, v325)), v313);
  }
  while ( v314 );
  v326 = v396;
  v327 = vaddq_s32(v313, vextq_s8(v313, v313, 8u));
  rowbytes = v405;
  v227 = v376;
  v232 = vaddq_s32(v327, vdupq_lane_s32((int32x2_t)v327.n128_u64[0], 1)).n128_u32[0];
  if ( v406 != v396 )
  {
LABEL_256:
    v328 = v406 - v326;
    do
    {
      v330 = *v320++;
      v329 = v330;
      v331 = *v318++;
      v332 = v331 - v329;
      v333 = v332;
      if ( v332 >= 0x80u )
        v333 = 256 - v332;
      *v319++ = v332;
      v232 += v333;
      --v328;
    }
    while ( v328 );
  }
  v229 = (unsigned __int32 *)&v228[v379];
  v245 = &v227[v379];
  v226 = &v382[v379];
  v228 = v3->row_buf;
  v244 = v406;
  v230 = v391;
LABEL_261:
  p_prev_row = &v3->prev_row;
  if ( v244 < rowbytes )
  {
    v334 = v228 + 1;
    do
    {
      v409 = v244;
      v335 = v230;
      v336 = *(unsigned __int8 *)v230;
      v337 = *v245;
      v338 = *v334;
      v230 = v337 - v336;
      v339 = *(_BYTE *)v229;
      v244 = v338 - v336;
      v340 = v338 - v336 + v337 - v336;
      if ( v340 < 0 )
        v340 = -v340;
      if ( v244 < 0 )
        v244 = v336 - v338;
      if ( v244 <= v340 )
        LOBYTE(v336) = *v245;
      if ( v230 < 0 )
        v230 = -v230;
      if ( v230 > v340 )
        LOBYTE(v338) = v336;
      if ( v230 > v244 )
        LOBYTE(v338) = v336;
      *v226 = v339 - v338;
      v341 = (unsigned __int8)(v339 - v338);
      if ( v341 >= 0x80 )
        v341 = 256 - v341;
      v232 += v341;
      v342 = v232 >= v403;
      if ( v232 <= v403 )
      {
        v230 = v335 + 1;
        ++v334;
        v244 = v409 + 1;
        ++v245;
        v229 = (unsigned __int32 *)((char *)v229 + 1);
        ++v226;
        v342 = v409 + 1 >= v405;
      }
    }
    while ( !v342 );
  }
  if ( v232 < v403 )
  {
    v3 = v397;
    v343 = v397->tst_row;
    row_buf = v397->try_row;
    if ( v343 )
    {
      v397->try_row = v343;
      v397->tst_row = (png_bytep)row_buf;
    }
    goto LABEL_304;
  }
  v3 = v397;
  row_buf = v387;
  v224 = row_info;
LABEL_305:
  v223 = p_prev_row;
LABEL_306:
  j_png_compress_IDAT(v3, row_buf, v224->rowbytes + 1, 0);
  v358 = *v223;
  if ( *v223 )
  {
    *v223 = v3->row_buf;
    v3->row_buf = v358;
  }
  j_png_write_finish_row(v3);
  v359 = *(_QWORD *)&v3->flush_dist;
  v3->flush_rows = ++HIDWORD(v359);
  if ( (unsigned int)(v359 - 1) < HIDWORD(v359) )
    sub_195080(v3);
}
// 209224: mask 0xFFFFFFFC is shortened because r8.4 <= 0x1FFFFFE
// 2091C0: fragmented variable at q9.16 may be wrong

//----- (0020A144) --------------------------------------------------------
RwImage_0 *__fastcall RtPNGImageWrite(RwImage_0 *image, const RwChar *imageName)
{
  RwImage_0 *v2; // r4
  bool v3; // zf
  RwStream_0 *v4; // r11
  jmp_buf *v5; // r0
  RwInt32 depth; // r10
  int palette; // r0
  int v8; // r0
  const png_byte *v9; // r9
  const png_color *v10; // r8
  png_byte *p_blue; // r0
  int v12; // r2
  png_byte *cpPixels; // r5
  RwInt32 stride; // r6
  int i; // r0
  png_info **p_info_struct; // r1
  int height; // [sp+14h] [bp-3Ch]
  png_uint_32 width; // [sp+18h] [bp-38h]
  png_const_structrp v20; // [sp+1Ch] [bp-34h] BYREF
  png_inforp_5 info_struct; // [sp+20h] [bp-30h] BYREF
  png_bytepp v22; // [sp+24h] [bp-2Ch]
  int v23; // [sp+28h] [bp-28h]
  int v24; // [sp+2Ch] [bp-24h]
  int v25; // [sp+30h] [bp-20h]

  v2 = image;
  v3 = image == 0;
  if ( image )
    v3 = imageName == 0;
  if ( !v3 )
  {
    v4 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMWRITE, imageName);
    if ( !v4 )
      return 0;
    v25 = 0;
    v24 = 0;
    v23 = 0;
    v22 = 0;
    info_struct = 0;
    v20 = j_png_create_write_struct_2((png_const_charp)"1.6.34", 0, 0, 0, 0, PNGMalloc, PNGFree);
    if ( !v20 )
    {
      v2 = 0;
LABEL_34:
      RwStreamClose(v4, 0);
      return v2;
    }
    info_struct = j_png_create_info_struct(v20);
    if ( !info_struct
      || (v5 = j_png_set_longjmp_fn((png_structrp_0)v20, (png_longjmp_ptr)&longjmp, 0x100u),
          setjmp((struct __jmp_buf_tag *)v5)) )
    {
      v2 = 0;
      RwStreamClose(v4, 0);
      j_png_destroy_write_struct((png_structpp)&v20, 0);
      return v2;
    }
    j_png_set_write_fn((png_structrp_9)v20, v4, PNGWrite, PNGFlush);
    depth = v2->depth;
    width = v2->width;
    height = v2->height;
    switch ( depth )
    {
      case 4:
        v8 = 4;
        break;
      case 8:
        v8 = 8;
        break;
      case 32:
        v25 = 8;
        v24 = 6;
        palette = 0;
LABEL_18:
        v23 = palette;
        goto LABEL_19;
      default:
LABEL_19:
        v9 = 0;
        j_png_set_IHDR(v20, info_struct, width, height, v25, v24, 0, 0, 0);
        if ( v24 == 3 )
        {
          v10 = (const png_color *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(3 << depth);
          v9 = (const png_byte *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(1 << depth);
          if ( depth != 31 )
          {
            p_blue = &v10->blue;
            v12 = 0;
            do
            {
              *(p_blue - 2) = *(_BYTE *)(v23 + 4 * v12);
              v10[v12].green = *(_BYTE *)(v23 + 4 * v12 + 1);
              *p_blue = *(_BYTE *)(v23 + 4 * v12 + 2);
              p_blue += 3;
              v9[v12] = *(_BYTE *)(v23 + 4 * v12 + 3);
              ++v12;
            }
            while ( v12 < 1 << depth );
          }
          j_png_set_PLTE((png_structrp_7)v20, info_struct, v10, 1 << depth);
          j_png_set_tRNS((png_structrp_7)v20, info_struct, v9, 1 << depth, 0);
        }
        else
        {
          v10 = 0;
        }
        j_png_write_info((png_structrp_10)v20, info_struct);
        j_png_set_packing((png_structrp_8)v20);
        cpPixels = v2->cpPixels;
        stride = v2->stride;
        v22 = (png_bytepp)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * height);
        if ( v22 )
        {
          if ( height >= 1 )
          {
            for ( i = 0; i < height; ++i )
            {
              v22[i] = cpPixels;
              cpPixels += stride;
            }
          }
          j_png_write_image((png_structrp_10)v20, v22);
          j_png_write_end((png_structrp_10)v20, info_struct);
          if ( v10 )
          {
            (*((void (__fastcall **)(const png_color *))RwEngineInstance + 76))(v10);
            (*((void (__fastcall **)(const png_byte *))RwEngineInstance + 76))(v9);
          }
          (*((void (__fastcall **)(png_bytepp))RwEngineInstance + 76))(v22);
          p_info_struct = &info_struct;
        }
        else
        {
          v2 = 0;
          p_info_struct = 0;
        }
        j_png_destroy_write_struct((png_structpp)&v20, p_info_struct);
        goto LABEL_34;
    }
    v25 = v8;
    v24 = 3;
    palette = (int)v2->palette;
    goto LABEL_18;
  }
  return v2;
}

//----- (0020A3B0) --------------------------------------------------------
png_voidp __fastcall PNGMalloc(png_structp png_ptr, png_size_t size)
{
  return (png_voidp)(*((int (__fastcall **)(png_size_t))RwEngineInstance + 75))(size);
}

//----- (0020A3C4) --------------------------------------------------------
void __fastcall PNGFree(png_structp png_ptr, png_voidp memPtr)
{
  (*((void (__fastcall **)(png_voidp))RwEngineInstance + 76))(memPtr);
}

//----- (0020A3D8) --------------------------------------------------------
void __fastcall PNGWrite(png_structp png_ptr, png_bytep data, png_size_t length)
{
  png_structp v3; // r0

  if ( png_ptr->io_ptr )
  {
    sub_190E54((RwStream_0 *)png_ptr->io_ptr, data, length);
  }
  else
  {
    j_png_error(png_ptr, 0);
    PNGFlush(v3);
  }
}
// 20A3ED: variable 'v3' is possibly undefined

//----- (0020A3F4) --------------------------------------------------------
RwImage_0 *__fastcall RtPNGImageRead(const RwChar *imageName)
{
  RwStream_0 *v1; // r9
  RwImage_0 *v2; // r5
  jmp_buf *v3; // r0
  RwInt32 v4; // r0
  RwImage_0 *v5; // r0
  png_byte *cpPixels; // r4
  RwInt32 stride; // r6
  RwRGBA_0 *palette; // r8
  signed int i; // r0
  int v11; // r0
  RwRGBA_0 *v12; // r3
  int j; // r0
  int v14; // r2
  png_byte *v15; // r3
  int k; // r1
  RwError_0 code; // [sp+14h] [bp-4Ch] BYREF
  png_color_16 *v18; // [sp+1Ch] [bp-44h] BYREF
  int v19; // [sp+20h] [bp-40h] BYREF
  png_colorp v20; // [sp+24h] [bp-3Ch] BYREF
  png_uint_32 height; // [sp+28h] [bp-38h] BYREF
  png_uint_32 width; // [sp+2Ch] [bp-34h] BYREF
  RwInt32 v23; // [sp+30h] [bp-30h]
  png_const_structrp struct_2; // [sp+34h] [bp-2Ch] BYREF
  png_info *info_ptr_ptr; // [sp+38h] [bp-28h] BYREF
  png_bytepp v26; // [sp+3Ch] [bp-24h]
  int interlace_type; // [sp+40h] [bp-20h] BYREF
  int v28[7]; // [sp+44h] [bp-1Ch] BYREF

  if ( !imageName )
  {
    v2 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483626);
    RwErrorSet(&code);
    return v2;
  }
  v1 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, imageName);
  v2 = 0;
  if ( v1 )
  {
    v26 = 0;
    info_ptr_ptr = 0;
    v23 = 0;
    width = 0;
    height = 0;
    struct_2 = j_png_create_read_struct_2((png_const_charp)"1.6.34", 0, 0, 0, 0, PNGMalloc, PNGFree);
    if ( struct_2 )
    {
      info_ptr_ptr = j_png_create_info_struct(struct_2);
      if ( !info_ptr_ptr )
      {
        v2 = 0;
        RwStreamClose(v1, 0);
        j_png_destroy_read_struct((png_structpp)&struct_2, 0, 0);
        return v2;
      }
      v3 = j_png_set_longjmp_fn((png_structrp_0)struct_2, (png_longjmp_ptr)&longjmp, 0x100u);
      if ( setjmp((struct __jmp_buf_tag *)v3) )
      {
        v2 = 0;
        RwStreamClose(v1, 0);
        j_png_destroy_read_struct((png_structpp)&struct_2, &info_ptr_ptr, 0);
        struct_2 = 0;
        info_ptr_ptr = 0;
        return v2;
      }
      j_png_set_read_fn((png_structrp_4)struct_2, v1, PNGRead);
      j_png_read_info((png_structrp_3)struct_2, info_ptr_ptr);
      j_png_get_IHDR(struct_2, info_ptr_ptr, &width, &height, &code.pluginID, v28, &interlace_type, 0, 0);
      j_png_set_strip_16((png_structrp_5)struct_2);
      switch ( v28[0] )
      {
        case 0:
          v23 = 8;
          if ( code.pluginID <= 7 )
            j_png_set_expand_gray_1_2_4_to_8((png_structrp_5)struct_2);
          break;
        case 2:
          v23 = 32;
          j_png_set_filler((png_structrp_8)struct_2, 0xFFu, 1);
          break;
        case 3:
          v23 = 8;
          if ( code.pluginID <= 7 )
          {
            j_png_set_packing((png_structrp_8)struct_2);
            v4 = 4;
            goto LABEL_17;
          }
          break;
        case 4:
          v23 = 32;
          j_png_set_gray_to_rgb((png_structrp_5)struct_2);
          break;
        case 6:
          v4 = 32;
LABEL_17:
          v23 = v4;
          break;
        default:
          break;
      }
      v5 = RwImageCreate(width, height, v23);
      v2 = v5;
      if ( v5 )
      {
        if ( RwImageAllocatePixels(v5) )
        {
          cpPixels = v2->cpPixels;
          stride = v2->stride;
          palette = v2->palette;
          v26 = (png_bytepp)(*((int (__fastcall **)(png_uint_32))RwEngineInstance + 75))(4 * height);
          if ( v26 )
          {
            if ( (int)height >= 1 )
            {
              for ( i = 0; i < (int)height; ++i )
              {
                v26[i] = cpPixels;
                cpPixels += stride;
              }
            }
            if ( v23 == 4 )
            {
              if ( !palette )
              {
LABEL_44:
                j_png_read_image((png_structrp_3)struct_2, v26);
                j_png_read_end((png_structrp_3)struct_2, info_ptr_ptr);
                j_png_destroy_read_struct((png_structpp)&struct_2, &info_ptr_ptr, 0);
                struct_2 = 0;
                info_ptr_ptr = 0;
                (*((void (__fastcall **)(png_bytepp))RwEngineInstance + 76))(v26);
                v26 = 0;
                goto LABEL_30;
              }
            }
            else if ( !palette || v23 != 8 )
            {
              goto LABEL_44;
            }
            v11 = 0;
            do
            {
              v12 = &palette[v11];
              v12->_anon_0._anon_0.red = v11;
              v12->_anon_0._anon_0.green = v11;
              v12->_anon_0._anon_0.blue = v11++;
              v12->_anon_0._anon_0.alpha = -1;
            }
            while ( v11 < 1 << v23 );
            if ( j_png_get_valid(struct_2, info_ptr_ptr, 8u) )
            {
              j_png_get_PLTE(struct_2, info_ptr_ptr, &v20, &v19);
              if ( v19 >= 1 )
              {
                for ( j = 0; j < v19; ++j )
                {
                  v14 = j;
                  v15 = (png_byte *)&palette[j];
                  *v15 = v20[j].red;
                  v15[1] = v20[v14].green;
                  v15[2] = v20[v14].blue;
                }
              }
            }
            if ( j_png_get_valid(struct_2, info_ptr_ptr, 0x10u) )
            {
              j_png_get_tRNS(struct_2, info_ptr_ptr, (png_bytep *)&v20, &v19, &v18);
              if ( v19 >= 1 )
              {
                for ( k = 0; k < v19; ++k )
                  palette[k]._anon_0._anon_0.alpha = *(&v20->red + k);
              }
            }
            goto LABEL_44;
          }
          RwImageFreePixels(v2);
        }
        RwImageDestroy(v2);
      }
    }
    v2 = 0;
LABEL_30:
    RwStreamClose(v1, 0);
  }
  return v2;
}
// 20A46E: conditional instruction was optimized away because %var_24.4==0
// 20A5E8: conditional instruction was optimized away because %var_30.4 is in (==4|==8)
// 20A3F4: using guessed type int var_1C[7];

//----- (0020A6E0) --------------------------------------------------------
void __fastcall PNGRead(png_structp png_ptr, png_bytep destAddr, png_size_t length)
{
  uLong v3; // r0
  const Bytef *v4; // r1
  uInt v5; // r2

  if ( png_ptr->io_ptr )
  {
    sub_199534((RwStream_0 *)png_ptr->io_ptr, destAddr, length);
  }
  else
  {
    j_png_error(png_ptr, 0);
    adler32(v3, v4, v5);
  }
}
// 20A6F5: variable 'v3' is possibly undefined
// 20A6F5: variable 'v4' is possibly undefined
// 20A6F5: variable 'v5' is possibly undefined

//----- (0020A6F8) --------------------------------------------------------
uLong __fastcall adler32(uLong adler, const Bytef *buf, uInt len)
{
  uLong v4; // r6
  signed int v5; // r3
  uInt v6; // r11
  uInt v7; // r4
  uInt v8; // r2
  int v9; // r4
  const Bytef *v10; // r2
  uLong v11; // r3
  uLong v12; // r5
  uLong v13; // r3
  uLong v14; // r5
  uLong v15; // r3
  uLong v16; // r5
  uLong v17; // r0
  uLong v18; // r3
  uLong v19; // r0
  uLong v20; // r3
  uLong v21; // r0
  uLong v22; // r3
  uLong v23; // r0
  uLong v24; // r3
  uLong v25; // r0
  uLong v26; // r3
  uLong v27; // r0
  int v28; // r3
  int v29; // r0
  int v30; // r3
  int v31; // r0
  int v32; // r3
  int v33; // r0
  int v34; // lr
  int v35; // r12
  int v36; // r3
  int v37; // r0
  int v38; // r3
  int v39; // r0
  int v40; // r3
  const Bytef *v41; // r3
  uInt v42; // r4
  int v43; // t1
  uInt v44; // [sp+0h] [bp-2Ch]
  uInt v45; // [sp+4h] [bp-28h]

  if ( !buf )
    return 1;
  v4 = HIWORD(adler);
  adler = (unsigned __int16)adler;
  if ( len )
  {
    do
    {
      v5 = 5552;
      if ( len < 0x15B0 )
        v5 = len;
      v6 = len - v5;
      if ( v5 < 16 )
        goto LABEL_16;
      v7 = ~len;
      if ( ~len <= 0xFFFFEA4F )
        v7 = -5553;
      if ( len >= 0x15B0 )
        len = 5552;
      if ( (int)len >= 31 )
        len = 31;
      v45 = (14 - len - v7) & 0xFFFFFFF0;
      v8 = -17 - v7;
      v9 = 15 - v7;
      v44 = v8;
      v10 = buf;
      do
      {
        v9 -= 16;
        v11 = adler + *v10;
        v12 = v11 + v10[1];
        v13 = v11 + v4 + v12;
        v14 = v12 + v10[2];
        v15 = v13 + v14;
        v16 = v14 + v10[3];
        v17 = v10[4] + v16;
        v18 = v15 + v16 + v17;
        v19 = v17 + v10[5];
        v20 = v18 + v19;
        v21 = v19 + v10[6];
        v22 = v20 + v21;
        v23 = v21 + v10[7];
        v24 = v22 + v23;
        v25 = v23 + v10[8];
        v26 = v24 + v25;
        v27 = v25 + v10[9];
        v28 = v26 + v27;
        v29 = v27 + v10[10];
        v30 = v28 + v29;
        v31 = v29 + v10[11];
        v32 = v30 + v31;
        v33 = v31 + v10[12];
        v34 = v10[14];
        v35 = v10[15];
        v36 = v32 + v33;
        v37 = v33 + v10[13];
        v10 += 16;
        v38 = v36 + v37;
        v39 = v37 + v34;
        v40 = v38 + v39;
        adler = v39 + v35;
        v4 = v40 + adler;
      }
      while ( v9 > 31 );
      buf += v45 + 16;
      len = v44 - v45;
      if ( v44 != v45 )
      {
LABEL_16:
        v41 = buf;
        v42 = len;
        do
        {
          v43 = *v41++;
          --v42;
          adler += v43;
          v4 += adler;
        }
        while ( v42 );
        buf += len;
      }
      v4 %= 0xFFF1u;
      adler %= 0xFFF1u;
      len = v6;
    }
    while ( v6 );
  }
  return adler | (v4 << 16);
}
// 20A6F8: too many cbuild loops

//----- (0020A848) --------------------------------------------------------
int __fastcall compress2(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level)
{
  int v6; // r5
  z_stream_0 v8; // [sp+0h] [bp-40h] BYREF

  v8.next_in = (Bytef *)source;
  v8.avail_in = sourceLen;
  v8.next_out = dest;
  v8.avail_out = *destLen;
  memset(&v8.zalloc, 0, 12);
  v6 = j_deflateInit_(&v8, level, "1.1.3", 56);
  if ( !v6 )
  {
    v6 = j_deflate(&v8, 4);
    if ( v6 == 1 )
    {
      *destLen = v8.total_out;
      return j_deflateEnd(&v8);
    }
    else
    {
      j_deflateEnd(&v8);
      if ( !v6 )
        return -5;
    }
  }
  return v6;
}

//----- (0020A8AC) --------------------------------------------------------
int __fastcall compress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
{
  int v5; // r5
  z_stream_0 v7; // [sp+0h] [bp-40h] BYREF

  v7.next_in = (Bytef *)source;
  v7.avail_in = sourceLen;
  v7.next_out = dest;
  v7.avail_out = *destLen;
  memset(&v7.zalloc, 0, 12);
  v5 = j_deflateInit_(&v7, -1, "1.1.3", 56);
  if ( !v5 )
  {
    v5 = j_deflate(&v7, 4);
    if ( v5 == 1 )
    {
      *destLen = v7.total_out;
      return j_deflateEnd(&v7);
    }
    else
    {
      j_deflateEnd(&v7);
      if ( !v5 )
        return -5;
    }
  }
  return v5;
}

//----- (0020A910) --------------------------------------------------------
const uLongf *get_crc_table()
{
  return crc_table;
}

//----- (0020A91C) --------------------------------------------------------
uLong __fastcall crc32(uLong crc, const Bytef *buf, uInt len)
{
  uLong v4; // r3
  uInt v5; // r12
  uInt v6; // lr
  const Bytef *v7; // r0
  uLongf v8; // r3
  uLongf v9; // r3
  uLongf v10; // r3
  uLongf v11; // r3
  uLongf v12; // r3
  uLongf v13; // r3
  int v14; // r4
  int v15; // r5
  uLongf v16; // r3
  int v17; // t1

  if ( !buf )
    return 0;
  v4 = ~crc;
  if ( len >= 8 )
  {
    v5 = len - 8;
    v6 = (len - 8) & 0xFFFFFFF8;
    v7 = &buf[v6 + 8];
    do
    {
      len -= 8;
      v8 = crc_table[(unsigned __int8)v4 ^ *buf] ^ (v4 >> 8);
      v9 = crc_table[(unsigned __int8)v8 ^ buf[1]] ^ (v8 >> 8);
      v10 = crc_table[(unsigned __int8)v9 ^ buf[2]] ^ (v9 >> 8);
      v11 = crc_table[(unsigned __int8)v10 ^ buf[3]] ^ (v10 >> 8);
      v12 = crc_table[(unsigned __int8)v11 ^ buf[4]] ^ (v11 >> 8);
      v13 = crc_table[(unsigned __int8)v12 ^ buf[5]] ^ (v12 >> 8);
      v14 = (unsigned __int8)v13 ^ buf[6];
      v15 = buf[7];
      buf += 8;
      v16 = crc_table[v14] ^ (v13 >> 8);
      v4 = crc_table[(unsigned __int8)v16 ^ v15] ^ (v16 >> 8);
    }
    while ( len > 7 );
    len = v5 - v6;
    if ( v5 == v6 )
      return ~v4;
    goto LABEL_9;
  }
  v7 = buf;
  while ( len )
  {
LABEL_9:
    v17 = *v7++;
    --len;
    v4 = crc_table[v17 ^ (unsigned __int8)v4] ^ (v4 >> 8);
  }
  return ~v4;
}

//----- (0020AA08) --------------------------------------------------------
int __fastcall deflateInit_(z_streamp strm, int level, const unsigned __int8 *version, int stream_size)
{
  return j_deflateInit2_(strm, level, 8, 15, 8, 0, version, stream_size);
}

//----- (0020AA2C) --------------------------------------------------------
int __fastcall deflateInit2_(
        z_streamp strm,
        int level,
        int method,
        int windowBits,
        int memLevel,
        int strategy,
        const unsigned __int8 *version,
        int stream_size)
{
  __int64 v8; // r8
  int result; // r0
  bool v12; // zf
  voidpf (__fastcall *zalloc)(voidpf, unsigned int, unsigned int); // r3
  int v14; // r11
  bool v15; // cc
  bool v16; // zf
  internal_state_0 *v17; // r0
  internal_state_0 *v18; // r6
  int v19; // r3
  int v20; // r0
  uInt w_size; // r1
  Posf *v22; // r0
  uInt hash_size; // r1
  Posf *v24; // r0
  int v25; // r0
  uInt lit_bufsize; // r1
  Bytef *window; // r2
  Posf *prev; // r2
  bool v29; // zf
  internal_state_0 *state; // r1
  int status; // r0
  bool v32; // zf

  LODWORD(v8) = level;
  if ( !version )
    return -6;
  result = -6;
  v12 = stream_size == 56;
  if ( stream_size == 56 )
    v12 = *version == 49;
  if ( v12 )
  {
    if ( strm )
    {
      HIDWORD(v8) = strategy;
      zalloc = strm->zalloc;
      strm->msg = 0;
      if ( !zalloc )
      {
        strm->opaque = 0;
        zalloc = zcalloc;
        strm->zalloc = zcalloc;
      }
      if ( !strm->zfree )
        strm->zfree = zcfree;
      v14 = windowBits;
      if ( level == -1 )
        LODWORD(v8) = 6;
      if ( windowBits < 0 )
        v14 = -windowBits;
      v15 = (unsigned int)strategy > 2;
      result = -2;
      if ( (unsigned int)strategy <= 2 )
        v15 = (unsigned int)v8 > 9;
      if ( !v15 )
      {
        v16 = (v14 & 0xFFFFFFF8) == 8;
        if ( (v14 & 0xFFFFFFF8) == 8 )
          v16 = method == 8;
        if ( v16 && (unsigned int)(memLevel - 1) <= 8 )
        {
          v17 = (internal_state_0 *)zalloc(strm->opaque, 1u, 0x16B8u);
          v18 = v17;
          if ( v17 )
          {
            strm->state = v17;
            v17->noheader = (unsigned int)windowBits >> 31;
            v17->strm = strm;
            v17->w_size = 1 << v14;
            v17->w_bits = v14;
            v17->w_mask = (1 << v14) - 1;
            v19 = 1 << (memLevel + 7);
            v17->hash_size = v19;
            v17->hash_bits = memLevel + 7;
            v17->hash_mask = v19 - 1;
            v17->hash_shift = (memLevel + 9) / 3u;
            v20 = ((int (__fastcall *)(voidpf))strm->zalloc)(strm->opaque);
            w_size = v18->w_size;
            v18->window = (Bytef *)v20;
            v22 = (Posf *)strm->zalloc(strm->opaque, w_size, 2);
            hash_size = v18->hash_size;
            v18->prev = v22;
            v24 = (Posf *)strm->zalloc(strm->opaque, hash_size, 2);
            v18->lit_bufsize = 1 << (memLevel + 6);
            v18->head = v24;
            v25 = ((int (__fastcall *)(voidpf))strm->zalloc)(strm->opaque);
            lit_bufsize = v18->lit_bufsize;
            window = v18->window;
            v18->pending_buf = (Bytef *)v25;
            v18->pending_buf_size = 4 * lit_bufsize;
            if ( window )
            {
              prev = v18->prev;
              v29 = prev == 0;
              if ( prev )
                v29 = v18->head == 0;
              if ( !v29 && v25 )
              {
                v18->l_buf = (uchf *)(3 * lit_bufsize + v25);
                v18->d_buf = (ushf *)(v25 + (lit_bufsize & 0xFFFFFFFE));
                *(_QWORD *)&v18->level = v8;
                v18->method = 8;
                return deflateReset(strm);
              }
            }
            state = strm->state;
            strm->msg = (unsigned __int8 *)z_errmsg[6];
            if ( state )
            {
              status = state->status;
              v32 = status == 42;
              if ( status != 42 )
                v32 = status == 666;
              if ( v32 || status == 113 )
              {
                if ( state->pending_buf )
                {
                  strm->zfree(strm->opaque, state->pending_buf);
                  state = strm->state;
                }
                if ( state->head )
                {
                  strm->zfree(strm->opaque, state->head);
                  state = strm->state;
                }
                if ( state->prev )
                {
                  strm->zfree(strm->opaque, state->prev);
                  state = strm->state;
                }
                if ( state->window )
                {
                  strm->zfree(strm->opaque, state->window);
                  state = strm->state;
                }
                strm->zfree(strm->opaque, state);
                strm->state = 0;
              }
            }
          }
          return -4;
        }
      }
    }
    else
    {
      return -2;
    }
  }
  return result;
}

//----- (0020AC14) --------------------------------------------------------
int __fastcall deflateEnd(z_streamp strm)
{
  internal_state_0 *state; // r1
  bool v3; // zf
  int status; // r5
  bool v5; // zf
  int result; // r0

  v3 = strm == 0;
  if ( strm )
  {
    state = strm->state;
    v3 = state == 0;
  }
  if ( v3 )
    return -2;
  status = state->status;
  v5 = status == 42;
  if ( status != 42 )
    v5 = status == 666;
  if ( !v5 && status != 113 )
    return -2;
  if ( state->pending_buf )
  {
    strm->zfree(strm->opaque, state->pending_buf);
    state = strm->state;
  }
  if ( state->head )
  {
    strm->zfree(strm->opaque, state->head);
    state = strm->state;
  }
  if ( state->prev )
  {
    strm->zfree(strm->opaque, state->prev);
    state = strm->state;
  }
  if ( state->window )
  {
    strm->zfree(strm->opaque, state->window);
    state = strm->state;
  }
  strm->zfree(strm->opaque, state);
  result = 0;
  strm->state = 0;
  if ( status == 113 )
    return -3;
  return result;
}
// 20AC24: variable 'state' is possibly undefined

//----- (0020AC88) --------------------------------------------------------
int __fastcall deflateReset(z_streamp strm)
{
  internal_state_0 *state; // r5
  int v2; // r4
  int noheader; // r1
  int v4; // r2
  uInt hash_size; // r2
  Posf *head; // r1
  int level; // r0
  __int64 v8; // r2
  unsigned __int16 *v9; // r0
  uInt v10; // r1
  uInt v11; // r0

  if ( !strm )
    return -2;
  state = strm->state;
  if ( !state || !strm->zalloc || !strm->zfree )
    return -2;
  v2 = 0;
  strm->total_in = 0;
  strm->total_out = 0;
  strm->msg = 0;
  strm->data_type = 2;
  noheader = state->noheader;
  state->pending_out = state->pending_buf;
  state->pending = 0;
  if ( noheader <= -1 )
  {
    state->noheader = 0;
    noheader = 0;
  }
  v4 = 42;
  if ( noheader )
    v4 = 113;
  state->status = v4;
  strm->adler = 1;
  state->last_flush = 0;
  j__tr_init((deflate_state_0 *)state);
  hash_size = state->hash_size;
  head = state->head;
  state->window_size = 2 * state->w_size;
  head[hash_size - 1] = 0;
  memset(state->head, 0, 2 * state->hash_size - 2);
  level = state->level;
  state->strstart = 0;
  level *= 3;
  state->block_start = 0;
  LODWORD(v8) = *(&configuration_table[0].good_length + 2 * level);
  v9 = &configuration_table[0].good_length + 2 * level;
  state->lookahead = 0;
  v10 = v9[3];
  HIDWORD(v8) = v9[2];
  v11 = v9[1];
  state->match_length = 2;
  state->match_available = 0;
  state->ins_h = 0;
  state->max_lazy_match = v11;
  *(_QWORD *)&state->good_match = v8;
  state->prev_length = 2;
  state->max_chain_length = v10;
  return v2;
}

//----- (0020AD40) --------------------------------------------------------
int __fastcall deflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLength)
{
  internal_state_0 *state; // r4
  size_t v5; // r8
  const Bytef *v6; // r5
  int result; // r0
  bool v8; // zf
  unsigned int v9; // r1
  Bytef *window; // r3
  uInt hash_shift; // r9
  uInt hash_mask; // lr
  uInt v13; // r0
  int v14; // r1
  int ins_h; // r5
  uInt w_mask; // r0
  int v17; // r3
  __int64 v18; // kr10_8

  v5 = dictLength;
  v6 = dictionary;
  result = -2;
  if ( strm )
  {
    v8 = dictionary == 0;
    if ( dictionary )
    {
      state = strm->state;
      v8 = state == 0;
    }
    if ( !v8 )
    {
      if ( state->status == 42 )
      {
        strm->adler = j_adler32(strm->adler, dictionary, dictLength);
        if ( v5 >= 3 )
        {
          v9 = state->w_size - 262;
          if ( v5 > v9 )
          {
            v6 += v5 - v9;
            v5 = state->w_size - 262;
          }
          qmemcpy(state->window, v6, v5);
          window = state->window;
          hash_shift = state->hash_shift;
          hash_mask = state->hash_mask;
          state->strstart = v5;
          state->block_start = v5;
          v13 = *window;
          state->ins_h = v13;
          v14 = 2;
          ins_h = ((v13 << hash_shift) ^ window[1]) & hash_mask;
          state->ins_h = ins_h;
          while ( 1 )
          {
            w_mask = state->w_mask;
            v17 = (window[v14] ^ (ins_h << hash_shift)) & hash_mask;
            v18 = *(_QWORD *)&state->prev;
            state->ins_h = v17;
            *(_WORD *)(v18 + 2 * (w_mask & (v14 - 2))) = *(_WORD *)(HIDWORD(v18) + 2 * v17);
            state->head[state->ins_h] = v14 - 2;
            if ( v14 - 1 > v5 - 3 )
              break;
            window = state->window;
            ++v14;
            ins_h = state->ins_h;
            hash_shift = state->hash_shift;
            hash_mask = state->hash_mask;
          }
        }
        return 0;
      }
      else
      {
        return -2;
      }
    }
  }
  return result;
}
// 20AD60: variable 'state' is possibly undefined

//----- (0020AE04) --------------------------------------------------------
int __fastcall deflateParams(z_streamp strm, int level, int strategy)
{
  internal_state_0 *state; // r6
  bool v6; // zf
  bool v8; // cc
  int result; // r0
  int v10; // r2
  int nice_length; // r3
  uInt max_chain; // r2
  uInt max_lazy; // r1

  v6 = strm == 0;
  if ( strm )
  {
    state = strm->state;
    v6 = state == 0;
  }
  if ( v6 )
    return -2;
  if ( level == -1 )
    level = 6;
  v8 = (unsigned int)strategy > 2;
  result = -2;
  if ( (unsigned int)strategy <= 2 )
    v8 = (unsigned int)level > 9;
  if ( !v8 )
  {
    v10 = state->level;
    if ( configuration_table[v10].func == configuration_table[level].func || !strm->total_in )
    {
      result = 0;
      if ( v10 == level )
      {
LABEL_16:
        state->strategy = strategy;
        return result;
      }
    }
    else
    {
      result = j_deflate(strm, 1);
      if ( state->level == level )
        goto LABEL_16;
    }
    nice_length = configuration_table[level].nice_length;
    max_chain = configuration_table[level].max_chain;
    max_lazy = configuration_table[level].max_lazy;
    state->good_match = configuration_table[level].good_length;
    state->nice_match = nice_length;
    state->max_chain_length = max_chain;
    state->max_lazy_match = max_lazy;
    state->level = level;
    goto LABEL_16;
  }
  return result;
}
// 20AE2E: variable 'state' is possibly undefined

//----- (0020AEA0) --------------------------------------------------------
int __fastcall deflate(z_streamp strm, int flush)
{
  int result; // r0
  internal_state_0 *state; // r8
  int status; // r1
  int last_flush; // r12
  int *p_pending; // r1
  int pending; // r10
  int v10; // r0
  Bytef *pending_buf; // lr
  int v12; // r5
  int v13; // r2
  int v14; // r0
  unsigned int v15; // r2
  unsigned __int64 v16; // r2
  Bytef *v17; // lr
  int v18; // r2
  uLong adler; // r3
  Bytef *v20; // r0
  int v21; // r2
  Bytef *v22; // r0
  int v23; // r2
  uLong v24; // r3
  Bytef *v25; // r0
  int v26; // r2
  Bytef *v27; // r0
  internal_state_0 *v28; // r1
  uInt avail_out; // r0
  size_t v30; // r5
  internal_state_0 *v31; // r1
  __int64 v32; // r0
  internal_state_0 *v33; // r2
  internal_state_0 *v34; // r0
  uInt avail_in; // r1
  int v36; // r0
  bool v37; // zf
  __int64 v38; // r0
  block_state v39; // r0
  internal_state_0 *v40; // r1
  uInt v41; // r0
  size_t v42; // r5
  internal_state_0 *v43; // r1
  __int64 v44; // r0
  internal_state_0 *v45; // r2
  internal_state_0 *v46; // r0
  int v47; // r1
  uLong v48; // r2
  Bytef *v49; // r0
  int v50; // r1
  Bytef *v51; // r0
  int v52; // r1
  uLong v53; // r2
  Bytef *v54; // r0
  int v55; // r1
  Bytef *v56; // r0
  internal_state_0 *v57; // r0
  size_t v58; // r5
  internal_state_0 *v59; // r1
  __int64 v60; // r0
  internal_state_0 *v61; // r2
  internal_state_0 *v62; // r0
  int v63; // r1

  result = -2;
  if ( !strm )
    return result;
  if ( (unsigned int)flush > 4 )
    return result;
  state = strm->state;
  if ( !state )
    return result;
  if ( !strm->next_out || !strm->next_in && strm->avail_in || (status = state->status, flush != 4) && status == 666 )
  {
    strm->msg = (unsigned __int8 *)z_errmsg[4];
    return -2;
  }
  if ( !strm->avail_out )
    goto LABEL_35;
  state->strm = strm;
  last_flush = state->last_flush;
  state->last_flush = flush;
  if ( status == 42 )
  {
    p_pending = &state->pending;
    pending = state->pending;
    v10 = 3;
    state->status = 113;
    pending_buf = state->pending_buf;
    state->pending = pending + 1;
    v12 = state->level - 1;
    LOWORD(v13) = -30720;
    if ( (unsigned int)(v12 >> 1) < 3 )
      v10 = v12 >> 1;
    HIWORD(v13) = -1;
    v14 = (v13 + (state->w_bits << 12)) | (v10 << 6);
    LOWORD(v15) = 4229;
    if ( state->strstart )
      v14 |= 0x20u;
    HIWORD(v15) = 2114;
    v16 = (unsigned int)v14 * (unsigned __int64)v15;
    pending_buf[pending] = BYTE1(v14);
    LODWORD(v16) = *p_pending;
    v17 = state->pending_buf;
    ++*p_pending;
    v17[v16] = (v14 | (v14 - 31 * ((HIDWORD(v16) + ((unsigned int)(v14 - HIDWORD(v16)) >> 1)) >> 4))) ^ 0x1F;
    if ( state->strstart )
    {
      v18 = state->pending;
      adler = strm->adler;
      v20 = state->pending_buf;
      state->pending = v18 + 1;
      v20[v18] = HIBYTE(adler);
      v21 = state->pending;
      v22 = state->pending_buf;
      state->pending = v21 + 1;
      v22[v21] = BYTE2(adler);
      v23 = state->pending;
      v24 = strm->adler;
      v25 = state->pending_buf;
      state->pending = v23 + 1;
      v25[v23] = BYTE1(v24);
      v26 = state->pending;
      v27 = state->pending_buf;
      state->pending = v26 + 1;
      v27[v26] = v24;
    }
    strm->adler = 1;
  }
  else
  {
    p_pending = &state->pending;
  }
  if ( *p_pending )
  {
    v28 = strm->state;
    avail_out = strm->avail_out;
    v30 = v28->pending;
    if ( v30 > avail_out )
      v30 = strm->avail_out;
    if ( v30 )
    {
      qmemcpy(strm->next_out, v28->pending_out, v30);
      v31 = strm->state;
      strm->next_out += v30;
      v31->pending_out += v30;
      v32 = *(_QWORD *)&strm->avail_out;
      v33 = strm->state;
      HIDWORD(v32) += v30;
      LODWORD(v32) = v32 - v30;
      *(_QWORD *)&strm->avail_out = v32;
      v33->pending -= v30;
      v34 = strm->state;
      if ( !v34->pending )
        v34->pending_out = v34->pending_buf;
      avail_out = strm->avail_out;
    }
    if ( !avail_out )
      goto LABEL_70;
  }
  else if ( flush != 4 && last_flush >= flush && !strm->avail_in )
  {
    goto LABEL_35;
  }
  avail_in = strm->avail_in;
  v36 = state->status;
  if ( v36 == 666 )
  {
    if ( avail_in )
    {
LABEL_35:
      strm->msg = (unsigned __int8 *)z_errmsg[7];
      return -5;
    }
  }
  else if ( avail_in )
  {
LABEL_43:
    v39 = configuration_table[state->level].func(state, flush);
    if ( (v39 | 1) == 3 )
      state->status = 666;
    if ( (v39 | 2) == 2 )
    {
      if ( !strm->avail_out )
LABEL_70:
        state->last_flush = -1;
      return 0;
    }
    if ( v39 == block_done )
    {
      if ( flush == 1 )
      {
        j__tr_align((deflate_state_0 *)state);
      }
      else
      {
        j__tr_stored_block((deflate_state_0 *)state, 0, 0, 0);
        if ( flush == 3 )
        {
          state->head[state->hash_size - 1] = 0;
          memset(state->head, 0, 2 * state->hash_size - 2);
        }
      }
      v40 = strm->state;
      v41 = strm->avail_out;
      v42 = v40->pending;
      if ( v42 > v41 )
        v42 = strm->avail_out;
      if ( v42 )
      {
        qmemcpy(strm->next_out, v40->pending_out, v42);
        v43 = strm->state;
        strm->next_out += v42;
        v43->pending_out += v42;
        v44 = *(_QWORD *)&strm->avail_out;
        v45 = strm->state;
        HIDWORD(v44) += v42;
        LODWORD(v44) = v44 - v42;
        *(_QWORD *)&strm->avail_out = v44;
        v45->pending -= v42;
        v46 = strm->state;
        if ( !v46->pending )
          v46->pending_out = v46->pending_buf;
        v41 = strm->avail_out;
      }
      if ( !v41 )
        goto LABEL_70;
    }
    goto LABEL_60;
  }
  v37 = v36 == 666;
  v38 = 0LL;
  if ( v37 )
    LODWORD(v38) = 1;
  if ( !flush )
    HIDWORD(v38) = 1;
  if ( state->lookahead || !v38 )
    goto LABEL_43;
LABEL_60:
  if ( flush != 4 )
    return 0;
  if ( state->noheader )
    return 1;
  v47 = state->pending;
  v48 = strm->adler;
  v49 = state->pending_buf;
  state->pending = v47 + 1;
  v49[v47] = HIBYTE(v48);
  v50 = state->pending;
  v51 = state->pending_buf;
  state->pending = v50 + 1;
  v51[v50] = BYTE2(v48);
  v52 = state->pending;
  v53 = strm->adler;
  v54 = state->pending_buf;
  state->pending = v52 + 1;
  v54[v52] = BYTE1(v53);
  v55 = state->pending;
  v56 = state->pending_buf;
  state->pending = v55 + 1;
  v56[v55] = v53;
  v57 = strm->state;
  v58 = v57->pending;
  if ( v58 > strm->avail_out )
    v58 = strm->avail_out;
  if ( v58 )
  {
    qmemcpy(strm->next_out, v57->pending_out, v58);
    v59 = strm->state;
    strm->next_out += v58;
    v59->pending_out += v58;
    v60 = *(_QWORD *)&strm->avail_out;
    v61 = strm->state;
    HIDWORD(v60) += v58;
    LODWORD(v60) = v60 - v58;
    *(_QWORD *)&strm->avail_out = v60;
    v61->pending -= v58;
    v62 = strm->state;
    if ( !v62->pending )
      v62->pending_out = v62->pending_buf;
  }
  v63 = state->pending;
  state->noheader = -1;
  return v63 == 0;
}

//----- (0020B24C) --------------------------------------------------------
int __fastcall deflateCopy(z_streamp dest, z_streamp source)
{
  bool v3; // zf
  int result; // r0
  internal_state_0 *state; // r4
  __int64 v6; // d20
  __int64 v7; // d16
  __int64 v8; // d17
  __int64 v9; // d18
  __int64 v10; // d19
  __int64 v11; // d23
  alloc_func zalloc; // r3
  voidpf opaque; // r0
  internal_state_0 *v14; // r0
  internal_state_0 *v15; // r5
  uInt w_size; // r1
  Bytef *v17; // r0
  uInt v18; // r1
  Posf *v19; // r0
  uInt hash_size; // r1
  Posf *v21; // r0
  uInt lit_bufsize; // r1
  Bytef *v23; // r8
  Bytef *window; // r0
  Posf *prev; // r1
  bool v26; // zf
  Bytef *pending_buf; // r2
  int v28; // r0

  v3 = dest == 0;
  result = -2;
  if ( !v3 )
    v3 = source == 0;
  if ( !v3 )
  {
    state = source->state;
    if ( !state )
      return -2;
    v6 = *(_QWORD *)&source->adler;
    v7 = *(_QWORD *)&source->next_in;
    v8 = *(_QWORD *)&source->total_in;
    v9 = *(_QWORD *)&source->avail_out;
    v10 = *(_QWORD *)&source->msg;
    v11 = *(_QWORD *)&source->opaque;
    *(_QWORD *)&dest->zalloc = *(_QWORD *)&source->zalloc;
    *(_QWORD *)&dest->opaque = v11;
    zalloc = dest->zalloc;
    opaque = dest->opaque;
    *(_QWORD *)&dest->adler = v6;
    *(_QWORD *)&dest->next_in = v7;
    *(_QWORD *)&dest->total_in = v8;
    *(_QWORD *)&dest->avail_out = v9;
    *(_QWORD *)&dest->msg = v10;
    v14 = (internal_state_0 *)zalloc(opaque, 1, 5816);
    v15 = v14;
    if ( v14 )
    {
      dest->state = v14;
      qmemcpy(v14, state, sizeof(internal_state_0));
      w_size = v15->w_size;
      v15->strm = dest;
      v17 = (Bytef *)dest->zalloc(dest->opaque, w_size, 2);
      v18 = v15->w_size;
      v15->window = v17;
      v19 = (Posf *)dest->zalloc(dest->opaque, v18, 2);
      hash_size = v15->hash_size;
      v15->prev = v19;
      v21 = (Posf *)dest->zalloc(dest->opaque, hash_size, 2);
      lit_bufsize = v15->lit_bufsize;
      v15->head = v21;
      v23 = (Bytef *)dest->zalloc(dest->opaque, lit_bufsize, 4);
      v15->pending_buf = v23;
      window = v15->window;
      if ( window )
      {
        prev = v15->prev;
        v26 = prev == 0;
        if ( prev )
          v26 = v23 == 0;
        if ( !v26 && v15->head )
        {
          qmemcpy(window, state->window, 2 * v15->w_size);
          qmemcpy(v15->prev, state->prev, 2 * v15->w_size);
          qmemcpy(v15->head, state->head, 2 * v15->hash_size);
          qmemcpy(v15->pending_buf, state->pending_buf, v15->pending_buf_size);
          pending_buf = v15->pending_buf;
          v15->pending_out = &pending_buf[state->pending_out - state->pending_buf];
          v28 = 3 * v15->lit_bufsize;
          v15->d_buf = (ushf *)&v23[v15->lit_bufsize & 0xFFFFFFFE];
          v15->l_buf = &pending_buf[v28];
          v15->l_desc.dyn_tree = v15->dyn_ltree;
          v15->d_desc.dyn_tree = v15->dyn_dtree;
          v15->bl_desc.dyn_tree = v15->bl_tree;
          return 0;
        }
      }
      j_deflateEnd(dest);
    }
    return -4;
  }
  return result;
}

//----- (0020B39C) --------------------------------------------------------
block_state __fastcall deflate_stored(deflate_state *s, int flush)
{
  ulg v3; // r10
  ulg v5; // r0
  uInt lookahead; // r1
  int block_start; // r0
  uInt strstart; // r1
  uInt v9; // r2
  charf *v10; // r1
  z_streamp strm; // r6
  internal_state_0 *state; // r0
  size_t pending; // r4
  internal_state_0 *v14; // r1
  __int64 v15; // r0
  internal_state_0 *v16; // r2
  internal_state_0 *v17; // r0
  ulg v18; // r2
  charf *v19; // r1
  z_streamp v20; // r6
  internal_state_0 *v21; // r0
  size_t avail_out; // r4
  internal_state_0 *v23; // r1
  __int64 v24; // r0
  internal_state_0 *v25; // r2
  internal_state_0 *v26; // r0
  block_state result; // r0
  int v28; // r0
  int v29; // r3
  charf *v30; // r1
  z_streamp v31; // r6
  internal_state_0 *v32; // r0
  size_t v33; // r4
  internal_state_0 *v34; // r1
  __int64 v35; // r0
  internal_state_0 *v36; // r2
  internal_state_0 *v37; // r0

  v3 = 0xFFFF;
  v5 = s->pending_buf_size - 5;
  if ( v5 < 0xFFFF )
    v3 = v5;
  while ( 1 )
  {
    lookahead = s->lookahead;
    if ( lookahead <= 1 )
    {
      fill_window(s);
      lookahead = s->lookahead;
      if ( !(lookahead | flush) )
        return 0;
      if ( !lookahead )
        break;
    }
    block_start = s->block_start;
    strstart = lookahead + s->strstart;
    s->lookahead = 0;
    v9 = block_start + v3;
    s->strstart = strstart;
    if ( !strstart || strstart >= v9 )
    {
      s->strstart = v9;
      s->lookahead = strstart - v9;
      if ( block_start < 0 )
        v10 = 0;
      else
        v10 = &s->window[block_start];
      j__tr_flush_block((deflate_state_0 *)s, v10, v3, 0);
      strm = s->strm;
      s->block_start = s->strstart;
      state = strm->state;
      pending = state->pending;
      if ( pending > strm->avail_out )
        pending = strm->avail_out;
      if ( pending )
      {
        qmemcpy(strm->next_out, state->pending_out, pending);
        v14 = strm->state;
        strm->next_out += pending;
        v14->pending_out += pending;
        v15 = *(_QWORD *)&strm->avail_out;
        v16 = strm->state;
        HIDWORD(v15) += pending;
        LODWORD(v15) = v15 - pending;
        *(_QWORD *)&strm->avail_out = v15;
        v16->pending -= pending;
        v17 = strm->state;
        if ( !v17->pending )
          v17->pending_out = v17->pending_buf;
      }
      if ( !s->strm->avail_out )
        return 0;
      block_start = s->block_start;
      strstart = s->strstart;
    }
    v18 = strstart - block_start;
    if ( strstart - block_start >= s->w_size - 262 )
    {
      if ( block_start < 0 )
        v19 = 0;
      else
        v19 = &s->window[block_start];
      j__tr_flush_block((deflate_state_0 *)s, v19, v18, 0);
      v20 = s->strm;
      s->block_start = s->strstart;
      v21 = v20->state;
      avail_out = v21->pending;
      if ( avail_out > v20->avail_out )
        avail_out = v20->avail_out;
      if ( avail_out )
      {
        qmemcpy(v20->next_out, v21->pending_out, avail_out);
        v23 = v20->state;
        v20->next_out += avail_out;
        v23->pending_out += avail_out;
        v24 = *(_QWORD *)&v20->avail_out;
        v25 = v20->state;
        HIDWORD(v24) += avail_out;
        LODWORD(v24) = v24 - avail_out;
        *(_QWORD *)&v20->avail_out = v24;
        v25->pending -= avail_out;
        v26 = v20->state;
        if ( !v26->pending )
          v26->pending_out = v26->pending_buf;
      }
      if ( !s->strm->avail_out )
        return 0;
    }
  }
  v28 = s->block_start;
  v29 = 0;
  if ( v28 < 0 )
    v30 = 0;
  else
    v30 = &s->window[v28];
  if ( flush == 4 )
    v29 = 1;
  j__tr_flush_block((deflate_state_0 *)s, v30, s->strstart - v28, v29);
  v31 = s->strm;
  s->block_start = s->strstart;
  v32 = v31->state;
  v33 = v32->pending;
  if ( v33 > v31->avail_out )
    v33 = v31->avail_out;
  if ( v33 )
  {
    qmemcpy(v31->next_out, v32->pending_out, v33);
    v34 = v31->state;
    v31->next_out += v33;
    v34->pending_out += v33;
    v35 = *(_QWORD *)&v31->avail_out;
    v36 = v31->state;
    HIDWORD(v35) += v33;
    LODWORD(v35) = v35 - v33;
    *(_QWORD *)&v31->avail_out = v35;
    v36->pending -= v33;
    v37 = v31->state;
    if ( !v37->pending )
      v37->pending_out = v37->pending_buf;
  }
  if ( s->strm->avail_out )
  {
    result = block_done;
    if ( flush == 4 )
      return 3;
  }
  else
  {
    result = need_more;
    if ( flush == 4 )
      return 2;
  }
  return result;
}

//----- (0020B570) --------------------------------------------------------
block_state __fastcall deflate_fast(deflate_state *s, int flush)
{
  uInt *p_last_lit; // r11
  ushf **p_d_buf; // r8
  IPos v5; // r6
  uInt lookahead; // r0
  __int64 v7; // kr00_8
  __int64 v8; // kr08_8
  uInt strstart; // r4
  uInt v10; // r0
  uInt match_length; // r0
  uchf v12; // r0
  int v13; // lr
  uInt v14; // r3
  uInt v15; // r2
  uchf *v16; // r1
  int v17; // r12
  unsigned int v18; // r0
  z_streamp *v19; // r0
  uInt v20; // r1
  uInt v21; // r2
  uInt max_lazy_match; // r12
  bool v23; // zf
  uInt v24; // r1
  __int64 v25; // kr10_8
  Posf *head; // r6
  Posf *prev; // r9
  uInt ins_h; // r0
  char hash_shift; // r2
  uInt hash_mask; // r5
  int v31; // r0
  uInt v32; // r0
  uInt v33; // r2
  Bytef *window; // r0
  __int64 v35; // kr20_8
  uInt v36; // r2
  uInt v37; // r1
  int v38; // lr
  int v39; // r0
  uInt v40; // r2
  uchf *v41; // r1
  int block_start; // r0
  ulg v43; // r2
  charf *v44; // r1
  z_streamp strm; // r9
  internal_state_0 *state; // r0
  size_t pending; // r4
  internal_state_0 *v48; // r1
  __int64 v49; // r0
  internal_state_0 *v50; // r2
  internal_state_0 *v51; // r0
  block_state result; // r0
  int v53; // r0
  int v54; // r3
  charf *v55; // r1
  z_streamp v56; // r6
  internal_state_0 *v57; // r0
  size_t avail_out; // r4
  internal_state_0 *v59; // r1
  __int64 v60; // r0
  internal_state_0 *v61; // r2
  internal_state_0 *v62; // r0
  uchf **p_l_buf; // [sp+Ch] [bp-24h]
  uInt *p_lit_bufsize; // [sp+10h] [bp-20h]

  p_lit_bufsize = &s->lit_bufsize;
  p_l_buf = &s->l_buf;
  p_last_lit = &s->last_lit;
  p_d_buf = &s->d_buf;
  v5 = 0;
  while ( s->lookahead >> 1 > 0x82 )
  {
LABEL_6:
    v7 = *(_QWORD *)&s->w_mask;
    v8 = *(_QWORD *)&s->prev;
    strstart = s->strstart;
    v10 = s->hash_mask & (*(unsigned __int8 *)(HIDWORD(v7) + strstart + 2) ^ (s->ins_h << s->hash_shift));
    s->ins_h = v10;
    v5 = *(unsigned __int16 *)(HIDWORD(v8) + 2 * v10);
    *(_WORD *)(v8 + 2 * (v7 & strstart)) = v5;
    s->head[s->ins_h] = s->strstart;
LABEL_7:
    if ( v5 && s->strstart - v5 <= s->w_size - 262 && s->strategy != 2 )
    {
      match_length = longest_match(s, v5);
      s->match_length = match_length;
      if ( match_length >= 3 )
        goto LABEL_11;
LABEL_24:
      v38 = 0;
      v39 = s->window[s->strstart];
      (*p_d_buf)[*p_last_lit] = 0;
      v40 = *p_last_lit;
      v41 = *p_l_buf;
      ++*p_last_lit;
      v41[v40] = v39;
      ++s->dyn_ltree[v39].fc.freq;
      v33 = s->strstart + 1;
      v23 = *p_last_lit == *p_lit_bufsize - 1;
      --s->lookahead;
      s->strstart = v33;
      if ( v23 )
        v38 = 1;
      if ( v38 )
        goto LABEL_27;
    }
    else
    {
      match_length = s->match_length;
      if ( match_length < 3 )
        goto LABEL_24;
LABEL_11:
      v12 = match_length - 3;
      v13 = 0;
      v14 = s->strstart - s->match_start;
      (*p_d_buf)[*p_last_lit] = v14;
      v15 = *p_last_lit;
      v16 = *p_l_buf;
      v17 = length_code[v12];
      ++*p_last_lit;
      v16[v15] = v12;
      v18 = (unsigned __int16)(v14 - 1);
      if ( v18 >= 0x100 )
        v18 = (v18 >> 7) + 256;
      v19 = &s->strm + dist_code[v18];
      ++s->dyn_ltree[(v17 | 0x100) + 1].fc.freq;
      ++*((_WORD *)v19 + 1216);
      v20 = s->match_length;
      v21 = s->lookahead - v20;
      max_lazy_match = s->max_lazy_match;
      v23 = *p_last_lit == *p_lit_bufsize - 1;
      s->lookahead = v21;
      if ( v23 )
        v13 = 1;
      if ( v21 < 3 || v20 > max_lazy_match )
      {
        window = s->window;
        v35 = *(_QWORD *)&s->hash_mask;
        v36 = s->strstart;
        s->match_length = 0;
        v33 = v36 + v20;
        s->strstart = v33;
        v37 = window[v33];
        s->ins_h = v37;
        s->ins_h = (window[v33 + 1] ^ (v37 << SBYTE4(v35))) & v35;
        if ( v13 )
          goto LABEL_27;
      }
      else
      {
        s->match_length = v20 - 1;
        do
        {
          v24 = s->strstart;
          v25 = *(_QWORD *)&s->w_mask;
          head = s->head;
          prev = s->prev;
          ins_h = s->ins_h;
          hash_mask = s->hash_mask;
          hash_shift = s->hash_shift;
          s->strstart = v24 + 1;
          v31 = ((ins_h << hash_shift) ^ *(unsigned __int8 *)(v24 + HIDWORD(v25) + 3)) & hash_mask;
          s->ins_h = v31;
          v5 = head[v31];
          prev[(unsigned int)v25 & (v24 + 1)] = v5;
          s->head[s->ins_h] = s->strstart;
          v32 = s->match_length - 1;
          s->match_length = v32;
        }
        while ( v32 );
        v33 = s->strstart + 1;
        s->strstart = v33;
        if ( v13 )
        {
LABEL_27:
          block_start = s->block_start;
          v43 = v33 - block_start;
          if ( block_start < 0 )
            v44 = 0;
          else
            v44 = &s->window[block_start];
          j__tr_flush_block((deflate_state_0 *)s, v44, v43, 0);
          strm = s->strm;
          s->block_start = s->strstart;
          state = strm->state;
          pending = state->pending;
          if ( pending > strm->avail_out )
            pending = strm->avail_out;
          if ( pending )
          {
            qmemcpy(strm->next_out, state->pending_out, pending);
            v48 = strm->state;
            strm->next_out += pending;
            v48->pending_out += pending;
            v49 = *(_QWORD *)&strm->avail_out;
            v50 = strm->state;
            HIDWORD(v49) += pending;
            LODWORD(v49) = v49 - pending;
            *(_QWORD *)&strm->avail_out = v49;
            v50->pending -= pending;
            v51 = strm->state;
            if ( !v51->pending )
              v51->pending_out = v51->pending_buf;
          }
          if ( !s->strm->avail_out )
            return 0;
        }
      }
    }
  }
  fill_window(s);
  lookahead = s->lookahead;
  if ( __PAIR64__(flush, lookahead) < 0x106 )
    return 0;
  if ( lookahead )
  {
    if ( lookahead < 3 )
      goto LABEL_7;
    goto LABEL_6;
  }
  v53 = s->block_start;
  v54 = 0;
  if ( v53 < 0 )
    v55 = 0;
  else
    v55 = &s->window[v53];
  if ( flush == 4 )
    v54 = 1;
  j__tr_flush_block((deflate_state_0 *)s, v55, s->strstart - v53, v54);
  v56 = s->strm;
  s->block_start = s->strstart;
  v57 = v56->state;
  avail_out = v57->pending;
  if ( avail_out > v56->avail_out )
    avail_out = v56->avail_out;
  if ( avail_out )
  {
    qmemcpy(v56->next_out, v57->pending_out, avail_out);
    v59 = v56->state;
    v56->next_out += avail_out;
    v59->pending_out += avail_out;
    v60 = *(_QWORD *)&v56->avail_out;
    v61 = v56->state;
    HIDWORD(v60) += avail_out;
    LODWORD(v60) = v60 - avail_out;
    *(_QWORD *)&v56->avail_out = v60;
    v61->pending -= avail_out;
    v62 = v56->state;
    if ( !v62->pending )
      v62->pending_out = v62->pending_buf;
  }
  if ( s->strm->avail_out )
  {
    result = block_done;
    if ( flush == 4 )
      return 3;
  }
  else
  {
    result = need_more;
    if ( flush == 4 )
      return 2;
  }
  return result;
}

//----- (0020B920) --------------------------------------------------------
block_state __fastcall deflate_slow(deflate_state *s, int flush)
{
  uInt *p_last_lit; // r9
  ushf **p_d_buf; // r11
  IPos v6; // r8
  uInt lookahead; // r0
  uInt v8; // r1
  uInt v9; // r0
  uInt v10; // r0
  __int64 v11; // kr00_8
  __int64 v12; // kr08_8
  uInt strstart; // r4
  uInt v14; // r0
  uInt match_length; // r1
  uInt v16; // r0
  uInt match_start; // r2
  int v18; // r0
  uInt v19; // r2
  uchf *v20; // r1
  int v21; // r0
  charf *v22; // r1
  z_streamp v23; // r6
  internal_state_0 *v24; // r0
  size_t avail_out; // r4
  internal_state_0 *v26; // r1
  __int64 v27; // r0
  internal_state_0 *v28; // r2
  internal_state_0 *v29; // r0
  z_streamp v30; // r1
  uInt v31; // r2
  uInt v32; // r10
  uchf v33; // r1
  uInt v34; // r12
  ushf v35; // r0
  uInt v36; // r3
  unsigned int v37; // r0
  uchf *v38; // r6
  z_streamp *v39; // r0
  __int64 v40; // kr10_8
  uInt prev_length; // r6
  uInt v42; // r4
  unsigned int v43; // r10
  uInt v44; // r4
  uInt w_mask; // r6
  Posf *prev; // r1
  Posf *head; // r8
  uInt v48; // r0
  uInt v49; // r0
  uInt v50; // r2
  int block_start; // r0
  ulg v52; // r2
  charf *v53; // r1
  z_streamp strm; // r10
  internal_state_0 *state; // r0
  size_t pending; // r4
  internal_state_0 *v57; // r1
  __int64 v58; // r0
  internal_state_0 *v59; // r2
  internal_state_0 *v60; // r0
  block_state result; // r0
  int v62; // r0
  uInt v63; // r3
  uchf *v64; // r2
  int v65; // r0
  int v66; // r3
  charf *v67; // r1
  z_streamp v68; // r6
  internal_state_0 *v69; // r0
  size_t v70; // r4
  internal_state_0 *v71; // r1
  __int64 v72; // r0
  internal_state_0 *v73; // r2
  internal_state_0 *v74; // r0
  uInt v75; // [sp+0h] [bp-38h]
  uInt v76; // [sp+4h] [bp-34h]
  int v77; // [sp+8h] [bp-30h]
  uInt *p_lit_bufsize; // [sp+14h] [bp-24h]
  uchf **p_l_buf; // [sp+18h] [bp-20h]

  p_lit_bufsize = &s->lit_bufsize;
  p_l_buf = &s->l_buf;
  p_last_lit = &s->last_lit;
  p_d_buf = &s->d_buf;
  v6 = 0;
LABEL_2:
  lookahead = s->lookahead;
  while ( lookahead >> 1 > 0x82 )
  {
LABEL_9:
    v11 = *(_QWORD *)&s->w_mask;
    v12 = *(_QWORD *)&s->prev;
    strstart = s->strstart;
    v14 = s->hash_mask & (*(unsigned __int8 *)(HIDWORD(v11) + strstart + 2) ^ (s->ins_h << s->hash_shift));
    s->ins_h = v14;
    v6 = *(unsigned __int16 *)(HIDWORD(v12) + 2 * v14);
    *(_WORD *)(v12 + 2 * (v11 & strstart)) = v6;
    s->head[s->ins_h] = s->strstart;
LABEL_10:
    match_length = s->match_length;
    v16 = 2;
    match_start = s->match_start;
    s->prev_length = match_length;
    s->match_length = 2;
    s->prev_match = match_start;
    if ( !v6 )
      goto LABEL_15;
    if ( match_length < s->max_lazy_match )
    {
      if ( s->strstart - v6 > s->w_size - 262 || s->strategy == 2 )
      {
        v16 = 2;
        goto LABEL_15;
      }
      v16 = longest_match(s, v6);
      s->match_length = v16;
      if ( v16 <= 5 )
      {
        if ( s->strategy == 1 )
          goto LABEL_33;
        if ( v16 == 3 )
        {
          if ( s->strstart - s->match_start > 0x1000 )
          {
LABEL_33:
            v16 = 2;
            s->match_length = 2;
          }
          else
          {
            v16 = 3;
          }
        }
      }
LABEL_15:
      match_length = s->prev_length;
      if ( match_length < 3 )
        goto LABEL_19;
      goto LABEL_16;
    }
    v16 = 2;
    if ( match_length < 3 )
      goto LABEL_19;
LABEL_16:
    if ( v16 <= match_length )
    {
      v77 = flush;
      v32 = s->strstart;
      v33 = match_length - 3;
      v34 = s->lookahead;
      v35 = v32 - 1 - s->prev_match;
      (*p_d_buf)[*p_last_lit] = v35;
      v36 = *p_last_lit;
      v37 = (unsigned __int16)(v35 - 1);
      v38 = *p_l_buf;
      ++*p_last_lit;
      v38[v36] = v33;
      if ( v37 >= 0x100 )
        v37 = (v37 >> 7) + 256;
      v39 = &s->strm + dist_code[v37];
      ++s->dyn_ltree[(length_code[v33] | 0x100) + 1].fc.freq;
      ++*((_WORD *)v39 + 1216);
      v40 = *(_QWORD *)&s->lookahead;
      prev_length = HIDWORD(v40) - 2;
      v76 = *p_last_lit;
      v42 = *p_lit_bufsize;
      s->lookahead = v40 + 1 - HIDWORD(v40);
      s->prev_length = HIDWORD(v40) - 2;
      v43 = v32 + v34 - 3;
      v75 = v42 - 1;
      do
      {
        v44 = s->strstart;
        s->strstart = v44 + 1;
        if ( v44 + 1 <= v43 )
        {
          w_mask = s->w_mask;
          head = s->head;
          prev = s->prev;
          v48 = (s->window[v44 + 3] ^ (s->ins_h << s->hash_shift)) & s->hash_mask;
          s->ins_h = v48;
          v6 = head[v48];
          prev[w_mask & (v44 + 1)] = v6;
          s->head[s->ins_h] = s->strstart;
          prev_length = s->prev_length;
        }
        s->prev_length = --prev_length;
      }
      while ( prev_length );
      v49 = s->strstart;
      s->match_length = 2;
      v50 = v49 + 1;
      s->match_available = 0;
      s->strstart = v49 + 1;
      flush = v77;
      if ( v76 == v75 )
      {
        block_start = s->block_start;
        v52 = v50 - block_start;
        if ( block_start < 0 )
          v53 = 0;
        else
          v53 = &s->window[block_start];
        j__tr_flush_block((deflate_state_0 *)s, v53, v52, 0);
        strm = s->strm;
        s->block_start = s->strstart;
        state = strm->state;
        pending = state->pending;
        if ( pending > strm->avail_out )
          pending = strm->avail_out;
        if ( pending )
        {
          qmemcpy(strm->next_out, state->pending_out, pending);
          v57 = strm->state;
          strm->next_out += pending;
          v57->pending_out += pending;
          v58 = *(_QWORD *)&strm->avail_out;
          v59 = strm->state;
          HIDWORD(v58) += pending;
          LODWORD(v58) = v58 - pending;
          *(_QWORD *)&strm->avail_out = v58;
          v59->pending -= pending;
          v60 = strm->state;
          if ( !v60->pending )
            v60->pending_out = v60->pending_buf;
        }
        flush = v77;
        if ( !s->strm->avail_out )
          return 0;
      }
      goto LABEL_2;
    }
LABEL_19:
    if ( s->match_available )
    {
      v18 = s->window[s->strstart - 1];
      (*p_d_buf)[*p_last_lit] = 0;
      v19 = *p_last_lit;
      v20 = *p_l_buf;
      ++*p_last_lit;
      v20[v19] = v18;
      ++s->dyn_ltree[v18].fc.freq;
      if ( *p_last_lit == *p_lit_bufsize - 1 )
      {
        v21 = s->block_start;
        if ( v21 < 0 )
          v22 = 0;
        else
          v22 = &s->window[v21];
        j__tr_flush_block((deflate_state_0 *)s, v22, s->strstart - v21, 0);
        v23 = s->strm;
        s->block_start = s->strstart;
        v24 = v23->state;
        avail_out = v24->pending;
        if ( avail_out > v23->avail_out )
          avail_out = v23->avail_out;
        if ( avail_out )
        {
          qmemcpy(v23->next_out, v24->pending_out, avail_out);
          v26 = v23->state;
          v23->next_out += avail_out;
          v26->pending_out += avail_out;
          v27 = *(_QWORD *)&v23->avail_out;
          v28 = v23->state;
          HIDWORD(v27) += avail_out;
          LODWORD(v27) = v27 - avail_out;
          *(_QWORD *)&v23->avail_out = v27;
          v28->pending -= avail_out;
          v29 = v23->state;
          if ( !v29->pending )
            v29->pending_out = v29->pending_buf;
        }
      }
      v30 = s->strm;
      v31 = s->lookahead;
      ++s->strstart;
      lookahead = v31 - 1;
      s->lookahead = v31 - 1;
      if ( !v30->avail_out )
        return 0;
    }
    else
    {
      v8 = s->lookahead;
      v9 = s->strstart + 1;
      s->match_available = 1;
      s->strstart = v9;
      lookahead = v8 - 1;
      s->lookahead = v8 - 1;
    }
  }
  fill_window(s);
  v10 = s->lookahead;
  if ( !flush && v10 < 0x106 )
    return 0;
  if ( v10 )
  {
    if ( v10 < 3 )
      goto LABEL_10;
    goto LABEL_9;
  }
  if ( s->match_available )
  {
    v62 = s->window[s->strstart - 1];
    (*p_d_buf)[*p_last_lit] = 0;
    v63 = *p_last_lit;
    v64 = *p_l_buf;
    ++*p_last_lit;
    v64[v63] = v62;
    ++s->dyn_ltree[v62].fc.freq;
    s->match_available = 0;
  }
  v65 = s->block_start;
  v66 = 0;
  if ( v65 < 0 )
    v67 = 0;
  else
    v67 = &s->window[v65];
  if ( flush == 4 )
    v66 = 1;
  j__tr_flush_block((deflate_state_0 *)s, v67, s->strstart - v65, v66);
  v68 = s->strm;
  s->block_start = s->strstart;
  v69 = v68->state;
  v70 = v69->pending;
  if ( v70 > v68->avail_out )
    v70 = v68->avail_out;
  if ( v70 )
  {
    qmemcpy(v68->next_out, v69->pending_out, v70);
    v71 = v68->state;
    v68->next_out += v70;
    v71->pending_out += v70;
    v72 = *(_QWORD *)&v68->avail_out;
    v73 = v68->state;
    HIDWORD(v72) += v70;
    LODWORD(v72) = v72 - v70;
    *(_QWORD *)&v68->avail_out = v72;
    v73->pending -= v70;
    v74 = v68->state;
    if ( !v74->pending )
      v74->pending_out = v74->pending_buf;
  }
  if ( s->strm->avail_out )
  {
    result = block_done;
    if ( flush == 4 )
      return 3;
  }
  else
  {
    result = need_more;
    if ( flush == 4 )
      return 2;
  }
  return result;
}

//----- (0020BD6C) --------------------------------------------------------
void __fastcall fill_window(deflate_state *s)
{
  unsigned int w_size; // r5
  uInt lookahead; // r0
  int32x4_t v4; // q4
  uInt strstart; // r1
  uInt v6; // r6
  ulg v7; // r8
  __int64 v8; // kr00_8
  uInt hash_size; // r0
  Posf *head; // r6
  int block_start; // r3
  int v12; // r1
  Posf *v13; // r3
  int v14; // r1
  uInt v15; // r2
  Posf *v16; // r12
  int16x8_t *v17; // r6
  int8x16_t v18; // q8
  int8x16_t v19; // q8
  int32x4_t v20; // q9
  int32x4_t v21; // q8
  int64x2_t v22; // q10
  int8x16_t v23; // q8
  Posf *v24; // r1
  unsigned int v25; // r2
  bool v26; // cf
  Posf v27; // r2
  Posf *prev; // r2
  Posf *v29; // r0
  int v30; // r1
  int16x8_t *v31; // r1
  unsigned int v32; // r2
  int8x16_t v33; // q8
  int8x16_t v34; // q8
  int32x4_t v35; // q9
  int32x4_t v36; // q8
  int64x2_t v37; // q10
  int8x16_t v38; // q8
  Posf *v39; // r0
  unsigned int v40; // r2
  Posf v41; // r2
  z_streamp strm; // r10
  uInt avail_in; // r1
  uInt v44; // r0
  Bytef *v45; // r8
  internal_state_0 *state; // r0
  uLong total_in; // r1
  Bytef *window; // r1
  __int64 v49; // kr08_8
  uInt v50; // r6
  uInt v51; // r2

  w_size = s->w_size;
  lookahead = s->lookahead;
  v4 = vdupq_n_s32(w_size);
  do
  {
    strstart = s->strstart;
    v6 = w_size;
    v7 = s->window_size - lookahead - strstart;
    if ( strstart | lookahead | v7 )
    {
      if ( v7 == -1 )
      {
        v6 = -2;
      }
      else
      {
        v6 = s->window_size - lookahead - strstart;
        if ( strstart >= s->w_size + w_size - 262 )
        {
          qmemcpy(s->window, &s->window[w_size], w_size);
          v8 = *(_QWORD *)&s->strstart;
          hash_size = s->hash_size;
          head = s->head;
          block_start = s->block_start;
          s->strstart = v8 - w_size;
          s->match_start = HIDWORD(v8) - w_size;
          v12 = block_start - w_size;
          v13 = &head[hash_size];
          s->block_start = v12;
          if ( hash_size < 8 )
            goto LABEL_10;
          v14 = hash_size & 7;
          v15 = hash_size - v14;
          if ( hash_size == v14 )
            goto LABEL_10;
          v16 = &head[v14];
          v17 = (int16x8_t *)(v13 - 8);
          hash_size &= 7u;
          do
          {
            v15 -= 8;
            v18 = vrev64q_s16(*v17);
            v19 = vextq_s8(v18, v18, 8u);
            v20 = vmovl_u16(*(uint16x4_t *)&v19.n128_i8[8]);
            v21 = vmovl_u16((uint16x4_t)v19.n128_u64[0]);
            *(int16x4_t *)&v22.n128_i8[8] = vmovn_s32(vsubq_s32(v20, v4));
            *(int16x4_t *)&v20.n128_i8[8] = vmovn_s32(vcgtq_u32(v4, v20));
            v22.n128_u64[0] = vmovn_s32(vsubq_s32(v21, v4)).n64_u64[0];
            v20.n128_u64[0] = vmovn_s32(vcgtq_u32(v4, v21)).n64_u64[0];
            v23 = vrev64q_s16(vbicq_s64(v22, v20));
            *v17-- = vextq_s8(v23, v23, 8u);
          }
          while ( v15 );
          v13 = v16;
          if ( v14 )
          {
LABEL_10:
            v24 = v13 - 1;
            do
            {
              v25 = *v24;
              v26 = v25 >= w_size;
              v27 = v25 - w_size;
              if ( !v26 )
                v27 = 0;
              --hash_size;
              *v24-- = v27;
            }
            while ( hash_size );
          }
          prev = s->prev;
          v29 = &prev[w_size];
          if ( w_size >= 8 )
          {
            v30 = w_size;
            if ( w_size != (w_size & 7) )
            {
              v29 = &prev[w_size & 7];
              v31 = (int16x8_t *)&prev[w_size - 8];
              v32 = w_size - (w_size & 7);
              do
              {
                v32 -= 8;
                v33 = vrev64q_s16(*v31);
                v34 = vextq_s8(v33, v33, 8u);
                v35 = vmovl_u16(*(uint16x4_t *)&v34.n128_i8[8]);
                v36 = vmovl_u16((uint16x4_t)v34.n128_u64[0]);
                *(int16x4_t *)&v37.n128_i8[8] = vmovn_s32(vsubq_s32(v35, v4));
                *(int16x4_t *)&v35.n128_i8[8] = vmovn_s32(vcgtq_u32(v4, v35));
                v37.n128_u64[0] = vmovn_s32(vsubq_s32(v36, v4)).n64_u64[0];
                v35.n128_u64[0] = vmovn_s32(vcgtq_u32(v4, v36)).n64_u64[0];
                v38 = vrev64q_s16(vbicq_s64(v37, v35));
                *v31-- = vextq_s8(v38, v38, 8u);
              }
              while ( v32 );
              v30 = w_size & 7;
              if ( (w_size & 7) == 0 )
              {
LABEL_25:
                v6 = v7 + w_size;
                goto LABEL_26;
              }
            }
          }
          else
          {
            v30 = w_size;
          }
          v39 = v29 - 1;
          do
          {
            v40 = *v39;
            v26 = v40 >= w_size;
            v41 = v40 - w_size;
            if ( !v26 )
              v41 = 0;
            --v30;
            *v39-- = v41;
          }
          while ( v30 );
          goto LABEL_25;
        }
      }
    }
LABEL_26:
    strm = s->strm;
    avail_in = s->strm->avail_in;
    if ( !avail_in )
      break;
    v44 = s->lookahead;
    if ( avail_in <= v6 )
      v6 = s->strm->avail_in;
    if ( v6 )
    {
      v45 = &s->window[s->strstart + v44];
      state = strm->state;
      strm->avail_in = avail_in - v6;
      if ( !state->noheader )
        strm->adler = j_adler32(strm->adler, strm->next_in, v6);
      qmemcpy(v45, strm->next_in, v6);
      total_in = strm->total_in;
      strm->next_in += v6;
      strm->total_in = total_in + v6;
      v44 = s->lookahead;
    }
    else
    {
      v6 = 0;
    }
    lookahead = v44 + v6;
    s->lookahead = lookahead;
    if ( lookahead >= 3 )
    {
      window = s->window;
      v49 = *(_QWORD *)&s->hash_mask;
      v50 = s->strstart;
      v51 = window[v50];
      s->ins_h = v51;
      s->ins_h = (window[v50 + 1] ^ (v51 << SBYTE4(v49))) & v49;
      if ( lookahead >> 1 > 0x82 )
        break;
    }
  }
  while ( s->strm->avail_in );
}

//----- (0020BF9E) --------------------------------------------------------
uInt __fastcall longest_match(deflate_state *s, IPos cur_match)
{
  uInt max_chain_length; // r3
  uInt prev_length; // r10
  uInt w_mask; // r4
  Bytef *window; // lr
  Posf *prev; // r9
  uInt strstart; // r12
  uInt v8; // r6
  IPos v9; // r11
  Bytef *v10; // r2
  int nice_match; // r5
  uInt lookahead; // r0
  unsigned __int8 v13; // r6
  Bytef *v14; // r8
  int v15; // r9
  Bytef *v16; // r2
  int v17; // r10
  unsigned __int8 *v18; // r12
  unsigned __int8 *v19; // r11
  Bytef *v20; // r0
  unsigned __int8 *v21; // r0
  unsigned __int8 *v22; // r12
  int v23; // r0
  uInt v26; // [sp+8h] [bp-40h]
  Bytef *v27; // [sp+Ch] [bp-3Ch]
  IPos v28; // [sp+10h] [bp-38h]
  Posf *v29; // [sp+14h] [bp-34h]
  Bytef *v30; // [sp+18h] [bp-30h]
  int v31; // [sp+20h] [bp-28h]
  unsigned __int8 v32; // [sp+24h] [bp-24h]
  Bytef *v33; // [sp+28h] [bp-20h]

  max_chain_length = s->max_chain_length;
  prev_length = s->prev_length;
  window = s->window;
  w_mask = s->w_mask;
  prev = s->prev;
  if ( prev_length >= s->good_match )
    max_chain_length >>= 2;
  strstart = s->strstart;
  v8 = s->w_size - 262;
  v9 = strstart - v8;
  v10 = &window[strstart];
  if ( strstart <= v8 )
    v9 = 0;
  nice_match = s->nice_match;
  lookahead = s->lookahead;
  v26 = lookahead;
  if ( nice_match > lookahead )
    nice_match = lookahead;
  v13 = v10[prev_length];
  v32 = v10[prev_length - 1];
  v33 = &window[strstart];
  v29 = prev;
  v30 = window;
  v27 = v10 + 258;
  v28 = v9;
  while ( 1 )
  {
    v14 = &window[cur_match];
    if ( window[cur_match + prev_length] != v13 || v14[prev_length - 1] != v32 || *v14 != *v33 || v14[1] != v33[1] )
      goto LABEL_33;
    v31 = prev_length;
    v15 = 2;
    v16 = v33;
    v17 = 0;
    while ( 1 )
    {
      v18 = &v16[v17];
      v19 = &v14[v17];
      if ( v16[v17 + 3] != v14[v17 + 3] )
      {
        v21 = v18 + 3;
        goto LABEL_30;
      }
      v20 = &v16[v15];
      if ( v18[4] != v19[4] )
      {
        v21 = v20 + 2;
        goto LABEL_30;
      }
      v16 = v33;
      if ( v18[5] != v19[5] )
      {
        v21 = v20 + 3;
        goto LABEL_30;
      }
      if ( v18[6] != v19[6] )
      {
        v21 = v20 + 4;
        goto LABEL_30;
      }
      if ( v18[7] != v19[7] )
      {
        v21 = v20 + 5;
        goto LABEL_30;
      }
      if ( v18[8] != v19[8] )
      {
        v21 = v20 + 6;
        goto LABEL_30;
      }
      if ( v18[9] != v19[9] )
        break;
      v15 += 8;
      v21 = &v33[v15];
      if ( v17 + 2 <= 249 )
      {
        v17 += 8;
        if ( v18[10] == v19[10] )
          continue;
      }
      goto LABEL_30;
    }
    v21 = v20 + 7;
LABEL_30:
    prev_length = v31;
    v22 = (unsigned __int8 *)(v21 - v27);
    v9 = v28;
    prev = v29;
    window = v30;
    v23 = v21 - v27 + 258;
    if ( v23 <= v31 )
      goto LABEL_33;
    s->match_start = cur_match;
    if ( v23 >= nice_match )
      break;
    prev_length = v23;
    v13 = v33[v23];
    v32 = v22[(_DWORD)v33 + 257];
LABEL_33:
    cur_match = prev[cur_match & w_mask];
    if ( v9 < cur_match )
    {
      if ( --max_chain_length )
        continue;
    }
    goto LABEL_35;
  }
  prev_length = v23;
LABEL_35:
  if ( prev_length > v26 )
    return v26;
  return prev_length;
}

//----- (0020C144) --------------------------------------------------------
gzFile __fastcall gzopen(const unsigned __int8 *path, const unsigned __int8 *mode)
{
  return gz_open(path, mode, -1);
}

//----- (0020C14C) --------------------------------------------------------
gzFile __fastcall gz_open(const unsigned __int8 *path, const unsigned __int8 *mode, int fd)
{
  bool v4; // zf
  const unsigned __int8 *v6; // r5
  gz_stream_0 *v7; // r11
  gz_stream_0 *v8; // r0
  size_t v9; // r0
  char *v10; // r0
  int *v11; // r2
  int v12; // r10
  int v13; // r1
  int v14; // r6
  bool v15; // zf
  bool v16; // zf
  Byte *v17; // r0
  int v18; // r5
  Byte *v19; // r0
  FILE *v20; // r0
  int v21; // r0
  char modes[80]; // [sp+20h] [bp-70h] BYREF
  int v24[8]; // [sp+70h] [bp-20h] BYREF

  v4 = path == 0;
  v6 = mode;
  v7 = 0;
  if ( path )
    v4 = mode == 0;
  if ( !v4 )
  {
    v8 = (gz_stream_0 *)malloc(0x64u);
    v7 = v8;
    if ( !v8 )
      return 0;
    v8->stream.zalloc = 0;
    v8->stream.zfree = 0;
    v8->stream.opaque = 0;
    v8->stream.next_out = 0;
    v8->stream.avail_out = 0;
    v8->stream.next_in = 0;
    v8->stream.avail_in = 0;
    v8->outbuf = 0;
    *(_QWORD *)&v8->z_err = 0LL;
    *(_QWORD *)&v8->file = 0LL;
    v8->crc = j_crc32(0, 0, 0);
    v7->msg = 0;
    v7->transparent = 0;
    v9 = strlen((const char *)path);
    v10 = (char *)malloc(v9 + 1);
    v7->path = (unsigned __int8 *)v10;
    if ( !v10 )
    {
LABEL_38:
      destroy(v7);
      return 0;
    }
    strcpy(v10, (const char *)path);
    v11 = (int *)modes;
    v12 = 0;
    v13 = -1;
    v7->mode = 0;
    do
    {
      v14 = *v6;
      if ( v14 == 114 )
      {
        v7->mode = 114;
        v14 = *v6;
      }
      v15 = v14 == 119;
      if ( v14 != 119 )
        v15 = v14 == 97;
      if ( v15 )
      {
        v7->mode = 119;
        v14 = *v6;
      }
      if ( (unsigned __int8)(v14 - 48) > 9u )
      {
        if ( v14 == 102 )
        {
          v12 = 1;
          v14 = 104;
        }
        else if ( v14 == 104 )
        {
          v12 = 2;
          v14 = 104;
        }
        else
        {
          *(_BYTE *)v11 = v14;
          v11 = (int *)((char *)v11 + 1);
          v14 = *v6;
        }
      }
      else
      {
        v13 = v14 - 48;
      }
      v16 = v11 == v24;
      if ( v11 != v24 )
      {
        ++v6;
        v16 = v14 == 0;
      }
    }
    while ( !v16 );
    if ( v7->mode == 119 )
    {
      v18 = j_deflateInit2_((z_streamp)v7, v13, 8, -15, 8, v12, "1.1.3", 56);
      v19 = (Byte *)malloc(0x4000u);
      v7->outbuf = v19;
      v7->stream.next_out = v19;
      if ( v18 || !v19 )
        goto LABEL_38;
    }
    else
    {
      if ( !v7->mode )
        goto LABEL_38;
      v17 = (Byte *)malloc(0x4000u);
      v7->inbuf = v17;
      v7->stream.next_in = v17;
      if ( j_inflateInit2_((z_streamp_1)v7, -15, "1.1.3", 56) || !v7->inbuf )
        goto LABEL_38;
    }
    v7->stream.avail_out = 0x4000;
    *(_DWORD *)_errno(0x4000) = 0;
    if ( fd <= -1 )
      v20 = fopen((const char *)path, modes);
    else
      v20 = fdopen(fd, modes);
    v7->file = v20;
    if ( !v20 )
      goto LABEL_38;
    if ( v7->mode == 119 )
    {
      fprintf(v20, "%c%c%c%c%c%c%c%c%c%c", 31, 139, 8, 0, 0, 0, 0, 0, 0, 3);
      v21 = 10;
    }
    else
    {
      check_header(v7);
      v21 = ftell(v7->file) - v7->stream.avail_in;
    }
    v7->startpos = v21;
  }
  return v7;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (0020C36C) --------------------------------------------------------
gzFile __fastcall gzdopen(int fd, const unsigned __int8 *mode)
{
  unsigned __int8 v5[20]; // [sp+0h] [bp-28h] BYREF

  if ( fd < 0 )
    return 0;
  sprintf(v5, "<fd:%d>", fd);
  return gz_open(v5, mode, fd);
}

//----- (0020C3CC) --------------------------------------------------------
int __fastcall gzsetparams(gzFile file, int level, int strategy)
{
  FILE *v6; // r3
  const void *v7; // r0

  if ( !file || *((_BYTE *)file + 92) != 119 )
    return -2;
  if ( !*((_DWORD *)file + 4) )
  {
    v6 = (FILE *)*((_DWORD *)file + 16);
    v7 = (const void *)*((_DWORD *)file + 18);
    *((_DWORD *)file + 3) = v7;
    if ( fwrite(v7, 1u, 0x4000u, v6) != 0x4000 )
      *((_DWORD *)file + 14) = -1;
    *((_DWORD *)file + 4) = 0x4000;
  }
  return sub_1A1088((z_streamp)file, level, strategy);
}

//----- (0020C428) --------------------------------------------------------
int __fastcall gzread(gzFile file, voidp buf, unsigned int len)
{
  unsigned int v4; // r5
  int v6; // r1
  bool v7; // zf
  int result; // r0
  const Bytef *v9; // r8
  int v10; // r0
  size_t v11; // r0
  size_t v12; // r0
  size_t v13; // r0
  char *v14; // r1
  size_t v15; // r0
  int v16; // r1
  size_t v17; // r0
  int v18; // r1
  size_t v19; // r0
  int v20; // r1
  FILE *v21; // r0
  unsigned __int8 *v22; // r1
  FILE *v23; // r0
  size_t v24; // r0
  int v25; // r0
  FILE *v26; // r0
  int v27; // r0
  unsigned int v28; // r6
  bool v29; // zf
  int v30; // r0
  uLong v31; // r0
  int v32; // r1
  int v33; // r6
  size_t v34; // r0
  unsigned __int8 *v35; // r2
  int v36; // r1
  size_t v37; // r0
  FILE *v38; // r0
  size_t v39; // r0
  int v40; // r6
  unsigned __int8 *v41; // r2
  int v42; // r1
  FILE *v43; // r0
  size_t v44; // r0
  int v45; // r6
  unsigned __int8 *v46; // r2
  int v47; // r1
  FILE *v48; // r0
  int v49; // r6
  int v50; // r10
  uLong v51; // r1
  bool v52; // zf
  uLong v53; // r0
  int v54; // r1
  __int64 v55; // r0
  size_t v56; // r0
  int v57; // r2

  v4 = len;
  if ( !file || *((_BYTE *)file + 92) != 114 )
    return -2;
  v6 = *((_DWORD *)file + 14);
  v7 = v6 == -3;
  result = -1;
  if ( v6 != -3 )
    v7 = v6 == -1;
  if ( !v7 )
  {
    if ( v6 == 1 )
      return 0;
    *((_DWORD *)file + 3) = buf;
    *((_DWORD *)file + 4) = len;
    if ( len )
    {
      v9 = (const Bytef *)buf;
      while ( 1 )
      {
        v27 = *((_DWORD *)file + 22);
        v28 = *((_DWORD *)file + 1);
        if ( v27 )
        {
          if ( v28 > len )
            v28 = len;
          if ( !v28 )
            goto LABEL_95;
          qmemcpy(*((void **)file + 3), *(const void **)file, v28);
          buf = (char *)buf + v28;
          HIDWORD(v55) = *((_DWORD *)file + 1) - v28;
          LODWORD(v55) = *(_DWORD *)file + v28;
          len = *((_DWORD *)file + 4) - v28;
          *((_DWORD *)file + 3) = buf;
          *((_DWORD *)file + 4) = len;
          *(_QWORD *)file = v55;
          if ( !len )
          {
            v56 = 0;
          }
          else
          {
LABEL_95:
            v56 = *((_DWORD *)file + 4) - fread(buf, 1u, len, *((FILE **)file + 16));
            *((_DWORD *)file + 4) = v56;
          }
          result = v4 - v56;
          v57 = *((_DWORD *)file + 5);
          *((_DWORD *)file + 2) += result;
          *((_DWORD *)file + 5) = v57 + result;
          if ( !result )
          {
            *((_DWORD *)file + 15) = 1;
            return 0;
          }
          return result;
        }
        v29 = v28 == 0;
        if ( !v28 )
        {
          v27 = *((_DWORD *)file + 15);
          v29 = v27 == 0;
        }
        if ( v29 )
        {
          *(_DWORD *)_errno(v27) = 0;
          v37 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
          *((_DWORD *)file + 1) = v37;
          if ( !v37 )
          {
            v38 = (FILE *)*((_DWORD *)file + 16);
            *((_DWORD *)file + 15) = 1;
            if ( ferror(v38) )
            {
              *((_DWORD *)file + 14) = -1;
              goto LABEL_90;
            }
          }
          *(_DWORD *)file = *((_DWORD *)file + 17);
        }
        v30 = j_inflate((z_streamp_1)file, 0);
        *((_DWORD *)file + 14) = v30;
        if ( v30 == 1 )
          break;
LABEL_85:
        v52 = v30 == 0;
        if ( !v30 )
          v52 = *((_DWORD *)file + 15) == 0;
        if ( v52 )
        {
          len = *((_DWORD *)file + 4);
          if ( len )
            continue;
        }
        goto LABEL_90;
      }
      v31 = j_crc32(*((_DWORD *)file + 19), v9, *((_DWORD *)file + 3) - (_DWORD)v9);
      v32 = *((_DWORD *)file + 15);
      v9 = (const Bytef *)*((_DWORD *)file + 3);
      *((_DWORD *)file + 19) = v31;
      if ( v32 )
        goto LABEL_54;
      v34 = *((_DWORD *)file + 1);
      if ( v34 )
      {
        v35 = *(unsigned __int8 **)file;
        v36 = 0;
      }
      else
      {
        *(_DWORD *)_errno(0) = 0;
        v34 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
        *((_DWORD *)file + 1) = v34;
        if ( !v34 )
        {
          v43 = (FILE *)*((_DWORD *)file + 16);
          *((_DWORD *)file + 15) = 1;
          if ( !ferror(v43) )
          {
LABEL_54:
            v33 = -65793;
            goto LABEL_79;
          }
          v40 = -1;
          *((_DWORD *)file + 14) = -1;
LABEL_63:
          v33 = v40 - 65792;
          goto LABEL_79;
        }
        v36 = *((_DWORD *)file + 15);
        v35 = (unsigned __int8 *)*((_DWORD *)file + 17);
        *(_DWORD *)file = v35;
      }
      v39 = v34 - 1;
      *(_DWORD *)file = v35 + 1;
      *((_DWORD *)file + 1) = v39;
      v40 = *v35;
      if ( v36 )
        goto LABEL_63;
      if ( v39 )
      {
        v41 = *(unsigned __int8 **)file;
        v42 = 0;
      }
      else
      {
        *(_DWORD *)_errno(0) = 0;
        v39 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
        *((_DWORD *)file + 1) = v39;
        if ( !v39 )
        {
          v48 = (FILE *)*((_DWORD *)file + 16);
          *((_DWORD *)file + 15) = 1;
          if ( ferror(v48) )
          {
            *((_DWORD *)file + 14) = -1;
            v33 = (v40 | 0xFFFFFF00) - 0x10000;
            goto LABEL_79;
          }
          goto LABEL_63;
        }
        v42 = *((_DWORD *)file + 15);
        v41 = (unsigned __int8 *)*((_DWORD *)file + 17);
        *(_DWORD *)file = v41;
      }
      v44 = v39 - 1;
      *(_DWORD *)file = v41 + 1;
      *((_DWORD *)file + 1) = v44;
      v45 = v40 | (*v41 << 8);
      if ( v42 )
      {
LABEL_71:
        v33 = v45 - 0x10000;
        goto LABEL_79;
      }
      if ( v44 )
      {
        v46 = *(unsigned __int8 **)file;
        v47 = 0;
      }
      else
      {
        *(_DWORD *)_errno(0) = 0;
        v44 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
        *((_DWORD *)file + 1) = v44;
        if ( !v44 )
        {
          v23 = (FILE *)*((_DWORD *)file + 16);
          *((_DWORD *)file + 15) = 1;
          if ( ferror(v23) )
            *((_DWORD *)file + 14) = -1;
          goto LABEL_71;
        }
        v47 = *((_DWORD *)file + 15);
        v46 = (unsigned __int8 *)*((_DWORD *)file + 17);
        *(_DWORD *)file = v46;
      }
      v24 = v44 - 1;
      *(_DWORD *)file = v46 + 1;
      *((_DWORD *)file + 1) = v24;
      v33 = v45 | (*v46 << 16);
      if ( !v47 )
      {
        if ( v24 )
        {
          v22 = *(unsigned __int8 **)file;
        }
        else
        {
          *(_DWORD *)_errno(0) = 0;
          v24 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
          *((_DWORD *)file + 1) = v24;
          if ( !v24 )
          {
            v26 = (FILE *)*((_DWORD *)file + 16);
            *((_DWORD *)file + 15) = 1;
            if ( ferror(v26) )
              *((_DWORD *)file + 14) = -1;
            goto LABEL_79;
          }
          v22 = (unsigned __int8 *)*((_DWORD *)file + 17);
          *(_DWORD *)file = v22;
        }
        *(_DWORD *)file = v22 + 1;
        *((_DWORD *)file + 1) = v24 - 1;
        v25 = *v22;
        goto LABEL_80;
      }
LABEL_79:
      *((_DWORD *)file + 14) = -3;
      v25 = -1;
LABEL_80:
      if ( v33 + (v25 << 24) != *((_DWORD *)file + 19) )
      {
        *((_DWORD *)file + 14) = -3;
        goto LABEL_90;
      }
      if ( *((_DWORD *)file + 15) )
        goto LABEL_82;
      v10 = *((_DWORD *)file + 1);
      if ( v10 )
      {
        v11 = v10 - 1;
        ++*(_DWORD *)file;
        *((_DWORD *)file + 1) = v11;
      }
      else
      {
        *(_DWORD *)_errno(0) = 0;
        v15 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
        *((_DWORD *)file + 1) = v15;
        if ( !v15 )
          goto LABEL_34;
        v16 = *((_DWORD *)file + 15);
        v11 = v15 - 1;
        *(_DWORD *)file = *((_DWORD *)file + 17) + 1;
        *((_DWORD *)file + 1) = v11;
        if ( v16 )
          goto LABEL_82;
      }
      if ( v11 )
      {
        v12 = v11 - 1;
        ++*(_DWORD *)file;
        *((_DWORD *)file + 1) = v12;
      }
      else
      {
        *(_DWORD *)_errno(0) = 0;
        v17 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
        *((_DWORD *)file + 1) = v17;
        if ( !v17 )
          goto LABEL_34;
        v18 = *((_DWORD *)file + 15);
        v12 = v17 - 1;
        *(_DWORD *)file = *((_DWORD *)file + 17) + 1;
        *((_DWORD *)file + 1) = v12;
        if ( v18 )
          goto LABEL_82;
      }
      if ( v12 )
      {
        v13 = v12 - 1;
        ++*(_DWORD *)file;
        *((_DWORD *)file + 1) = v13;
LABEL_20:
        if ( v13 )
        {
          v14 = *(char **)file;
LABEL_33:
          *(_DWORD *)file = v14 + 1;
          *((_DWORD *)file + 1) = v13 - 1;
LABEL_83:
          check_header((gz_stream_0 *)file);
          if ( *((_DWORD *)file + 14) )
            goto LABEL_90;
          v49 = *((_DWORD *)file + 2);
          v50 = *((_DWORD *)file + 5);
          j_inflateReset((z_streamp_1)file);
          *((_DWORD *)file + 2) = v49;
          *((_DWORD *)file + 5) = v50;
          v51 = j_crc32(0, 0, 0);
          v30 = *((_DWORD *)file + 14);
          *((_DWORD *)file + 19) = v51;
          goto LABEL_85;
        }
        *(_DWORD *)_errno(0) = 0;
        v13 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
        *((_DWORD *)file + 1) = v13;
        if ( v13 )
        {
          v14 = (char *)*((_DWORD *)file + 17);
          *(_DWORD *)file = v14;
          goto LABEL_33;
        }
        goto LABEL_34;
      }
      *(_DWORD *)_errno(0) = 0;
      v19 = fread(*((void **)file + 17), 1u, 0x4000u, *((FILE **)file + 16));
      *((_DWORD *)file + 1) = v19;
      if ( v19 )
      {
        v20 = *((_DWORD *)file + 15);
        v13 = v19 - 1;
        *(_DWORD *)file = *((_DWORD *)file + 17) + 1;
        *((_DWORD *)file + 1) = v13;
        if ( !v20 )
          goto LABEL_20;
LABEL_82:
        *((_DWORD *)file + 14) = -3;
        goto LABEL_83;
      }
LABEL_34:
      v21 = (FILE *)*((_DWORD *)file + 16);
      *((_DWORD *)file + 15) = 1;
      if ( ferror(v21) )
        *((_DWORD *)file + 14) = -1;
      goto LABEL_82;
    }
    v9 = (const Bytef *)buf;
LABEL_90:
    v53 = j_crc32(*((_DWORD *)file + 19), v9, *((_DWORD *)file + 3) - (_DWORD)v9);
    v54 = *((_DWORD *)file + 4);
    *((_DWORD *)file + 19) = v53;
    return v4 - v54;
  }
  return result;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (0020C834) --------------------------------------------------------
void __fastcall check_header(gz_stream_0 *s)
{
  Bytef v2; // r8
  unsigned int i; // r6
  int v4; // r5
  uInt avail_in; // r0
  Bytef *next_in; // r1
  FILE *file; // r0
  int v8; // r1
  __int64 v9; // r0
  __int64 v10; // r0
  uInt v11; // r0
  Bytef *inbuf; // r2
  size_t v13; // r0
  bool v14; // zf
  int v15; // r6
  Bytef *v16; // r1
  FILE *v17; // r0
  int v18; // r6
  int v19; // r1
  FILE *v20; // r0
  int v21; // r0
  Bytef *v22; // r2
  int z_eof; // r1
  Bytef *v24; // r1
  FILE *v25; // r0
  int v26; // r5
  Bytef *v27; // r1
  FILE *v28; // r0
  Bytef *v29; // r1
  FILE *v30; // r0
  Bytef *v31; // r1
  FILE *v32; // r0
  size_t v33; // r0
  Bytef *v34; // r1
  size_t v35; // r0
  int v36; // r1
  FILE *v37; // r0
  FILE *v38; // r0
  int v39; // r0

  v2 = 1;
  for ( i = 0; ; ++i )
  {
    if ( s->z_eof )
    {
      v4 = -1;
      if ( i > 1 )
        goto LABEL_16;
      goto LABEL_11;
    }
    avail_in = s->stream.avail_in;
    if ( avail_in )
    {
      next_in = s->stream.next_in;
      goto LABEL_10;
    }
    *(_DWORD *)_errno() = 0;
    avail_in = fread(s->inbuf, 1u, 0x4000u, s->file);
    s->stream.avail_in = avail_in;
    if ( !avail_in )
      break;
    next_in = s->inbuf;
    s->stream.next_in = next_in;
LABEL_10:
    s->stream.next_in = next_in + 1;
    s->stream.avail_in = avail_in - 1;
    v4 = *next_in;
    if ( i > 1 )
      goto LABEL_16;
LABEL_11:
    if ( v4 != gz_magic[i] )
    {
      if ( i )
      {
        HIDWORD(v9) = s->stream.avail_in + 1;
        LODWORD(v9) = s->stream.next_in - 1;
        *(_QWORD *)&s->stream.next_in = v9;
      }
      if ( v4 != -1 )
      {
        v10 = *(_QWORD *)&s->stream.next_in;
        s->transparent = 1;
        ++HIDWORD(v10);
        LODWORD(v10) = v10 - 1;
        *(_QWORD *)&s->stream.next_in = v10;
      }
      v8 = s->stream.avail_in == 0;
      goto LABEL_23;
    }
  }
  file = s->file;
  s->z_eof = 1;
  v4 = -1;
  if ( ferror(file) )
    s->z_err = -1;
  if ( i <= 1 )
    goto LABEL_11;
LABEL_16:
  if ( s->z_eof )
  {
    v8 = -3;
    goto LABEL_23;
  }
  v11 = s->stream.avail_in;
  if ( v11 )
  {
    inbuf = s->stream.next_in;
  }
  else
  {
    *(_DWORD *)_errno() = 0;
    v11 = fread(s->inbuf, 1u, 0x4000u, s->file);
    s->stream.avail_in = v11;
    if ( !v11 )
    {
      v20 = s->file;
      s->z_eof = 1;
      v21 = ferror(v20);
      v8 = -3;
      if ( v21 )
        s->z_err = -1;
      goto LABEL_23;
    }
    inbuf = s->inbuf;
    s->stream.next_in = inbuf;
  }
  v13 = v11 - 1;
  v14 = v4 == 8;
  s->stream.next_in = inbuf + 1;
  s->stream.avail_in = v13;
  v8 = -3;
  if ( v4 == 8 )
  {
    v2 = *inbuf;
    v14 = (*inbuf & 0xE0) == 0;
  }
  if ( !v14 )
    goto LABEL_23;
  v15 = 6;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( s->z_eof )
      {
        if ( !--v15 )
          goto LABEL_45;
      }
      if ( v13 )
      {
        v16 = s->stream.next_in;
        goto LABEL_40;
      }
      *(_DWORD *)_errno() = 0;
      v13 = fread(s->inbuf, 1u, 0x4000u, s->file);
      s->stream.avail_in = v13;
      if ( v13 )
      {
        v16 = s->inbuf;
        s->stream.next_in = v16;
LABEL_40:
        --v13;
        s->stream.next_in = v16 + 1;
        s->stream.avail_in = v13;
        if ( !--v15 )
          goto LABEL_45;
        continue;
      }
      break;
    }
    v17 = s->file;
    s->z_eof = 1;
    v14 = ferror(v17) == 0;
    v13 = 0;
    if ( !v14 )
      s->z_err = -1;
    if ( --v15 )
      continue;
    break;
  }
LABEL_45:
  if ( (v2 & 4) != 0 )
  {
    if ( s->z_eof )
    {
      v18 = -1;
      v19 = -1;
    }
    else
    {
      if ( v13 )
      {
        v22 = s->stream.next_in;
        z_eof = 0;
      }
      else
      {
        *(_DWORD *)_errno() = 0;
        v13 = fread(s->inbuf, 1u, 0x4000u, s->file);
        s->stream.avail_in = v13;
        if ( !v13 )
        {
          v25 = s->file;
          s->z_eof = 1;
          v18 = -1;
          if ( ferror(v25) )
            s->z_err = -1;
          v13 = 0;
          v19 = -1;
          goto LABEL_65;
        }
        z_eof = s->z_eof;
        v22 = s->inbuf;
        s->stream.next_in = v22;
      }
      --v13;
      s->stream.next_in = v22 + 1;
      s->stream.avail_in = v13;
      v18 = *v22;
      if ( z_eof )
      {
        v19 = -1;
      }
      else
      {
        if ( v13 )
        {
          v24 = s->stream.next_in;
        }
        else
        {
          *(_DWORD *)_errno() = 0;
          v13 = fread(s->inbuf, 1u, 0x4000u, s->file);
          s->stream.avail_in = v13;
          if ( !v13 )
          {
            v38 = s->file;
            s->z_eof = 1;
            v39 = ferror(v38);
            v19 = -1;
            if ( v39 )
              s->z_err = -1;
            v13 = 0;
            goto LABEL_65;
          }
          v24 = s->inbuf;
          s->stream.next_in = v24;
        }
        --v13;
        s->stream.next_in = v24 + 1;
        s->stream.avail_in = v13;
        v19 = *v24;
      }
    }
LABEL_65:
    if ( v18 + (v19 << 8) )
    {
      v26 = -v18 - (v19 << 8);
      while ( !s->z_eof )
      {
        if ( v13 )
        {
          v27 = s->stream.next_in;
        }
        else
        {
          *(_DWORD *)_errno() = 0;
          v13 = fread(s->inbuf, 1u, 0x4000u, s->file);
          s->stream.avail_in = v13;
          if ( !v13 )
          {
            v28 = s->file;
            s->z_eof = 1;
            if ( ferror(v28) )
              s->z_err = -1;
            v13 = 0;
            break;
          }
          v27 = s->inbuf;
          s->stream.next_in = v27;
        }
        --v13;
        ++v26;
        s->stream.next_in = v27 + 1;
        s->stream.avail_in = v13;
        if ( !v26 )
          break;
      }
    }
  }
  if ( (v2 & 8) != 0 )
  {
    while ( !s->z_eof )
    {
      if ( v13 )
      {
        v29 = s->stream.next_in;
      }
      else
      {
        *(_DWORD *)_errno() = 0;
        v13 = fread(s->inbuf, 1u, 0x4000u, s->file);
        s->stream.avail_in = v13;
        if ( !v13 )
        {
          v30 = s->file;
          s->z_eof = 1;
          if ( ferror(v30) )
            s->z_err = -1;
          v13 = 0;
          break;
        }
        v29 = s->inbuf;
        s->stream.next_in = v29;
      }
      --v13;
      s->stream.next_in = v29 + 1;
      s->stream.avail_in = v13;
      if ( !*v29 )
        break;
    }
  }
  if ( (v2 & 0x10) != 0 )
  {
    while ( !s->z_eof )
    {
      if ( v13 )
      {
        v31 = s->stream.next_in;
      }
      else
      {
        *(_DWORD *)_errno() = 0;
        v13 = fread(s->inbuf, 1u, 0x4000u, s->file);
        s->stream.avail_in = v13;
        if ( !v13 )
        {
          v32 = s->file;
          s->z_eof = 1;
          if ( ferror(v32) )
            s->z_err = -1;
          v13 = 0;
          break;
        }
        v31 = s->inbuf;
        s->stream.next_in = v31;
      }
      --v13;
      s->stream.next_in = v31 + 1;
      s->stream.avail_in = v13;
      if ( !*v31 )
        break;
    }
  }
  if ( (v2 & 2) != 0 && !s->z_eof )
  {
    if ( v13 )
    {
      v33 = v13 - 1;
      ++s->stream.next_in;
      s->stream.avail_in = v33;
      goto LABEL_103;
    }
    *(_DWORD *)_errno() = 0;
    v35 = fread(s->inbuf, 1u, 0x4000u, s->file);
    s->stream.avail_in = v35;
    if ( !v35 )
      goto LABEL_111;
    v36 = s->z_eof;
    v33 = v35 - 1;
    s->stream.next_in = s->inbuf + 1;
    s->stream.avail_in = v33;
    if ( v36 )
      goto LABEL_113;
LABEL_103:
    if ( v33 )
    {
      v34 = s->stream.next_in;
      goto LABEL_110;
    }
    *(_DWORD *)_errno() = 0;
    v33 = fread(s->inbuf, 1u, 0x4000u, s->file);
    s->stream.avail_in = v33;
    if ( v33 )
    {
      v34 = s->inbuf;
      s->stream.next_in = v34;
LABEL_110:
      s->stream.next_in = v34 + 1;
      s->stream.avail_in = v33 - 1;
    }
    else
    {
LABEL_111:
      v37 = s->file;
      s->z_eof = 1;
      if ( ferror(v37) )
        s->z_err = -1;
    }
  }
LABEL_113:
  v8 = s->z_eof;
  if ( v8 )
    v8 = -3;
LABEL_23:
  s->z_err = v8;
}
// 19CEE8: using guessed type int _errno(void);

//----- (0020CC1C) --------------------------------------------------------
int __fastcall gzgetc(gzFile file)
{
  int v1; // r0
  int v2; // r1
  unsigned __int8 v4; // [sp+7h] [bp-9h] BYREF

  v1 = j_gzread(file, &v4, 1u);
  v2 = v4;
  if ( v1 != 1 )
    return -1;
  return v2;
}

//----- (0020CC3C) --------------------------------------------------------
unsigned __int8 *__fastcall gzgets(gzFile file, unsigned __int8 *buf, int len)
{
  int v5; // r6
  unsigned __int8 *result; // r0
  unsigned __int8 *v7; // r5
  int v8; // r4
  int v9; // t1

  v5 = len;
  result = 0;
  if ( buf && len >= 1 )
  {
    v7 = buf;
    v8 = 1;
    while ( v5 >= 2 )
    {
      if ( j_gzread(file, v7, 1u) != 1 )
        goto LABEL_9;
      v9 = *v7++;
      --v5;
      if ( v9 == 10 )
      {
        v8 = 1;
        goto LABEL_9;
      }
    }
    v8 = 0;
LABEL_9:
    result = buf;
    *v7 = 0;
    if ( v7 == buf )
      result = 0;
    if ( !v8 )
      return buf;
  }
  return result;
}

//----- (0020CC98) --------------------------------------------------------
int __fastcall gzwrite(gzFile file, const voidp buf, unsigned int len)
{
  FILE *v6; // r3
  const void *v7; // r0
  int v8; // r0
  uLong v10; // r0
  int v11; // r1

  if ( !file || *((_BYTE *)file + 92) != 119 )
    return -2;
  *(_DWORD *)file = buf;
  *((_DWORD *)file + 1) = len;
  if ( !len )
    goto LABEL_12;
  while ( 1 )
  {
    if ( *((_DWORD *)file + 4) )
      goto LABEL_7;
    v6 = (FILE *)*((_DWORD *)file + 16);
    v7 = (const void *)*((_DWORD *)file + 18);
    *((_DWORD *)file + 3) = v7;
    if ( fwrite(v7, 1u, 0x4000u, v6) != 0x4000 )
      break;
    *((_DWORD *)file + 4) = 0x4000;
LABEL_7:
    v8 = j_deflate((z_streamp)file, 0);
    *((_DWORD *)file + 14) = v8;
    if ( v8 || !*((_DWORD *)file + 1) )
      goto LABEL_12;
  }
  *((_DWORD *)file + 14) = -1;
LABEL_12:
  v10 = j_crc32(*((_DWORD *)file + 19), (const Bytef *)buf, len);
  v11 = *((_DWORD *)file + 1);
  *((_DWORD *)file + 19) = v10;
  return len - v11;
}

//----- (0020CD18) --------------------------------------------------------
int gzprintf(gzFile file, const unsigned __int8 *format, ...)
{
  signed int v3; // r2
  unsigned __int8 s[4096]; // [sp+4h] [bp-1014h] BYREF
  va_list va; // [sp+1020h] [bp+8h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  v3 = strlen((const char *)s);
  if ( v3 < 1 )
    return 0;
  else
    return j_gzwrite(file, s, v3);
}

//----- (0020CD90) --------------------------------------------------------
int __fastcall gzputc(gzFile file, int c)
{
  int v2; // r0
  int v3; // r1
  unsigned __int8 v5; // [sp+7h] [bp-9h] BYREF

  v5 = c;
  v2 = j_gzwrite(file, &v5, 1u);
  v3 = v5;
  if ( v2 != 1 )
    return -1;
  return v3;
}

//----- (0020CDB4) --------------------------------------------------------
int __fastcall gzputs(gzFile file, const unsigned __int8 *s)
{
  unsigned int v4; // r2

  v4 = strlen((const char *)s);
  return gzwrite(file, (const voidp)s, v4);
}

//----- (0020CDCE) --------------------------------------------------------
int __fastcall gzflush(gzFile file, int flush)
{
  int v4; // r2
  int v5; // r5
  int v6; // r6
  int v7; // r1
  int result; // r0
  int v9; // r1
  int v10; // r3

  if ( !file || *((_BYTE *)file + 92) != 119 )
    return -2;
  v4 = *((_DWORD *)file + 4);
  v5 = 0;
  *((_DWORD *)file + 1) = 0;
  while ( 1 )
  {
    v6 = 0x4000 - v4;
    if ( v4 != 0x4000 )
    {
      if ( fwrite(*((const void **)file + 18), 1u, 0x4000 - v4, *((FILE **)file + 16)) != v6 )
      {
        result = -1;
        *((_DWORD *)file + 14) = -1;
        return result;
      }
      *((_DWORD *)file + 3) = *((_DWORD *)file + 18);
      *((_DWORD *)file + 4) = 0x4000;
    }
    if ( v5 )
      break;
    v7 = j_deflate((z_streamp)file, flush);
    v4 = *((_DWORD *)file + 4);
    result = v7 ^ 0xFFFFFFFB | v6;
    if ( result )
      result = v7;
    v9 = result;
    *((_DWORD *)file + 14) = result;
    if ( result != 1 )
      v9 = 0;
    v10 = v4;
    if ( v4 )
      v10 = 1;
    v5 = v10 | v9;
    if ( (unsigned int)result >= 2 )
      return result;
  }
  result = *((_DWORD *)file + 14);
  if ( (unsigned int)result <= 1 )
  {
    fflush(*((FILE **)file + 16));
    result = *((_DWORD *)file + 14);
    if ( result == 1 )
      return 0;
  }
  return result;
}

//----- (0020CE72) --------------------------------------------------------
int __fastcall gzseek(gzFile file, int offset, int whence)
{
  bool v4; // zf
  int v5; // r6
  int v6; // r5
  int v8; // r0
  void *v9; // r0
  unsigned int v10; // r2
  int v11; // r0
  __int64 v12; // r0
  unsigned int v13; // r1
  unsigned int v14; // r0
  uLong v15; // r0
  int v16; // r1
  int v17; // r6
  unsigned int v18; // r2
  int v19; // r0

  v4 = file == 0;
  v5 = offset;
  v6 = -1;
  if ( file )
    v4 = whence == 2;
  if ( v4 )
    return v6;
  if ( (*((_DWORD *)file + 14) | 2) == -1 )
    return -1;
  v8 = *((unsigned __int8 *)file + 92);
  if ( v8 != 119 )
  {
    if ( whence == 1 )
      v6 = *((_DWORD *)file + 5) + offset;
    else
      v6 = offset;
    if ( v6 < 0 )
      return -1;
    if ( *((_DWORD *)file + 22) )
    {
      v12 = *((_QWORD *)file + 8);
      *(_DWORD *)file = HIDWORD(v12);
      *((_DWORD *)file + 1) = 0;
      if ( fseek((FILE *)v12, v6, 0) >= 0 )
      {
        *((_DWORD *)file + 2) = v6;
        *((_DWORD *)file + 5) = v6;
        return v6;
      }
      return -1;
    }
    v13 = *((_DWORD *)file + 5);
    if ( v6 >= v13 )
    {
      v6 -= v13;
    }
    else
    {
      if ( v8 != 114 )
        return -1;
      v14 = *((_DWORD *)file + 17);
      *((_DWORD *)file + 14) = 0;
      *((_DWORD *)file + 15) = 0;
      *(_QWORD *)file = v14;
      v15 = j_crc32(0, 0, 0);
      v16 = *((_DWORD *)file + 24);
      *((_DWORD *)file + 19) = v15;
      if ( !v16 )
      {
        rewind(*((FILE **)file + 16));
        if ( v6 )
          goto LABEL_34;
        goto LABEL_38;
      }
      j_inflateReset((z_streamp_1)file);
      if ( fseek(*((FILE **)file + 16), *((_DWORD *)file + 24), 0) < 0 )
        return -1;
    }
    if ( v6 )
    {
LABEL_34:
      if ( !*((_DWORD *)file + 18) )
        *((_DWORD *)file + 18) = malloc(0x4000u);
      v17 = v6;
LABEL_39:
      v6 = -1;
      while ( v17 >= 1 )
      {
        v18 = v17;
        if ( v17 >= 0x4000 )
          v18 = 0x4000;
        v19 = j_gzread(file, *((voidp *)file + 18), v18);
        if ( v19 < 1 )
          return v6;
        v17 -= v19;
      }
      return *((_DWORD *)file + 5);
    }
LABEL_38:
    v17 = 0;
    goto LABEL_39;
  }
  if ( !whence )
    v5 = offset - *((_DWORD *)file + 2);
  if ( v5 < 0 )
    return -1;
  if ( !*((_DWORD *)file + 17) )
  {
    v9 = malloc(0x4000u);
    *((_DWORD *)file + 17) = v9;
    memset(v9, 0, 0x4000u);
  }
  v6 = -1;
  while ( v5 >= 1 )
  {
    v10 = v5;
    if ( v5 >= 0x4000 )
      v10 = 0x4000;
    v11 = j_gzwrite(file, *((const voidp *)file + 17), v10);
    v5 -= v11;
    if ( !v11 )
      return v6;
  }
  return *((_DWORD *)file + 2);
}

//----- (0020CFA8) --------------------------------------------------------
int __fastcall gzrewind(gzFile file)
{
  unsigned int v2; // r0
  uLong v3; // r0
  int v4; // r1

  if ( !file || *((_BYTE *)file + 92) != 114 )
    return -1;
  v2 = *((_DWORD *)file + 17);
  *((_DWORD *)file + 14) = 0;
  *((_DWORD *)file + 15) = 0;
  *(_QWORD *)file = v2;
  v3 = j_crc32(0, 0, 0);
  v4 = *((_DWORD *)file + 24);
  *((_DWORD *)file + 19) = v3;
  if ( v4 )
  {
    j_inflateReset((z_streamp_1)file);
    return sub_195C40(*((FILE **)file + 16), *((_DWORD *)file + 24), 0);
  }
  else
  {
    rewind(*((FILE **)file + 16));
    return 0;
  }
}

//----- (0020CFF8) --------------------------------------------------------
int __fastcall gztell(gzFile file)
{
  return gzseek(file, 0, 1);
}

//----- (0020CFFE) --------------------------------------------------------
int __fastcall gzeof(gzFile file)
{
  if ( file && *((_BYTE *)file + 92) == 114 )
    return *((_DWORD *)file + 15);
  else
    return 0;
}

//----- (0020D010) --------------------------------------------------------
int __fastcall gzclose(gzFile file)
{
  int v2; // r1
  int v3; // r6
  size_t v4; // r5
  int v5; // r0
  unsigned int v6; // r2
  unsigned int v7; // r0
  int v8; // r3
  FILE *v10; // r5
  unsigned int v11; // r6
  unsigned int v12; // r6
  FILE *v13; // r5

  if ( !file )
    return -2;
  if ( *((_BYTE *)file + 92) == 119 )
  {
    v2 = *((_DWORD *)file + 4);
    v3 = 0;
    *((_DWORD *)file + 1) = 0;
    while ( 1 )
    {
      v4 = 0x4000 - v2;
      if ( v2 != 0x4000 )
      {
        if ( fwrite(*((const void **)file + 18), 1u, v4, *((FILE **)file + 16)) != v4 )
        {
          *((_DWORD *)file + 14) = -1;
          return destroy((gz_stream_0 *)file);
        }
        *((_DWORD *)file + 3) = *((_DWORD *)file + 18);
        *((_DWORD *)file + 4) = 0x4000;
      }
      if ( v3 )
        break;
      v5 = j_deflate((z_streamp)file, 4);
      v2 = *((_DWORD *)file + 4);
      v6 = v5 ^ 0xFFFFFFFB | v4;
      if ( v6 )
        v6 = v5;
      v7 = v6;
      *((_DWORD *)file + 14) = v6;
      if ( v6 != 1 )
        v7 = 0;
      v8 = v2;
      if ( v2 )
        v8 = 1;
      v3 = v8 | v7;
      if ( v6 >= 2 )
        return destroy((gz_stream_0 *)file);
    }
    if ( *((_DWORD *)file + 14) <= 1u )
    {
      v10 = (FILE *)*((_DWORD *)file + 16);
      v11 = *((_DWORD *)file + 19);
      fputc((unsigned __int8)v11, v10);
      fputc(BYTE1(v11), v10);
      fputc(BYTE2(v11), v10);
      fputc(HIBYTE(v11), v10);
      v12 = *((_DWORD *)file + 2);
      v13 = (FILE *)*((_DWORD *)file + 16);
      fputc((unsigned __int8)v12, v13);
      fputc(BYTE1(v12), v13);
      fputc(BYTE2(v12), v13);
      fputc(HIBYTE(v12), v13);
    }
  }
  return destroy((gz_stream_0 *)file);
}

//----- (0020D0F4) --------------------------------------------------------
int __fastcall destroy(gz_stream_0 *s)
{
  unsigned __int8 *msg; // r0
  int mode; // r0
  int v4; // r0
  int z_err; // r5
  FILE *file; // r0
  int v8; // r0
  Byte *inbuf; // r0
  Byte *outbuf; // r0
  unsigned __int8 *path; // r0

  if ( !s )
    return -2;
  msg = s->msg;
  if ( msg )
    free(msg);
  if ( !s->stream.state )
    goto LABEL_9;
  mode = s->mode;
  if ( mode == 114 )
  {
    v4 = j_inflateEnd((z_streamp_1)s);
    goto LABEL_11;
  }
  if ( mode != 119 )
  {
LABEL_9:
    z_err = 0;
    goto LABEL_12;
  }
  v4 = j_deflateEnd((z_streamp)s);
LABEL_11:
  z_err = v4;
LABEL_12:
  file = s->file;
  if ( file )
  {
    v8 = fclose(file);
    if ( v8 )
    {
      if ( *(_DWORD *)_errno(v8) != 29 )
        z_err = -1;
    }
  }
  inbuf = s->inbuf;
  if ( s->z_err < 0 )
    z_err = s->z_err;
  if ( inbuf )
    free(inbuf);
  outbuf = s->outbuf;
  if ( outbuf )
    free(outbuf);
  path = s->path;
  if ( path )
    free(path);
  free(s);
  return z_err;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (0020D17C) --------------------------------------------------------
const unsigned __int8 *__fastcall gzerror(gzFile file, int *errnum)
{
  int v3; // r0
  const char *v4; // r5
  void *v5; // r0
  const unsigned __int8 **v6; // r9
  const char *v7; // r6
  size_t v8; // r8
  size_t v9; // r0
  char *v10; // r0

  if ( !file )
  {
    *errnum = -2;
    v6 = &z_errmsg[4];
    return *v6;
  }
  v3 = *((_DWORD *)file + 14);
  v4 = &byte_61CADE;
  *errnum = v3;
  if ( v3 == -1 )
  {
LABEL_5:
    if ( *v4 )
    {
LABEL_7:
      v6 = (const unsigned __int8 **)((char *)file + 80);
      v5 = (void *)*((_DWORD *)file + 20);
      if ( v5 )
        free(v5);
      v7 = (const char *)*((_DWORD *)file + 21);
      v8 = strlen(v7);
      v9 = strlen(v4);
      v10 = (char *)malloc(v9 + v8 + 3);
      *((_DWORD *)file + 20) = v10;
      strcpy(v10, v7);
      strcat(*((char **)file + 20), ": ");
      strcat(*((char **)file + 20), v4);
      return *v6;
    }
LABEL_6:
    v4 = (const char *)z_errmsg[2 - *((_DWORD *)file + 14)];
    goto LABEL_7;
  }
  if ( v3 )
  {
    v4 = (const char *)*((_DWORD *)file + 6);
    if ( !v4 )
      goto LABEL_6;
    goto LABEL_5;
  }
  return (const unsigned __int8 *)v4;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (0020D224) --------------------------------------------------------
void __fastcall inflate_blocks_reset(inflate_blocks_statef *s, z_streamp_0 z, uLongf *c)
{
  inflate_block_mode mode; // r0
  check_func checkfn; // r3
  Bytef *window; // r0
  uLong v8; // r0

  if ( c )
    *c = s->check;
  mode = s->mode;
  if ( (s->mode & 0xFFFFFFFE) == 4 )
  {
    z->zfree(z->opaque, s->sub.trees.blens);
    mode = s->mode;
  }
  if ( mode == CODES )
    j_inflate_codes_free((inflate_codes_statef_0 *)s->sub.left, z);
  checkfn = s->checkfn;
  window = s->window;
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = window;
  s->write = window;
  if ( checkfn )
  {
    v8 = checkfn(0, 0, 0);
    s->check = v8;
    z->adler = v8;
  }
}

//----- (0020D278) --------------------------------------------------------
inflate_blocks_statef *__fastcall inflate_blocks_new(z_streamp_0 z, check_func c, uInt w)
{
  inflate_blocks_statef *v6; // r4
  inflate_huft *v7; // r0
  Bytef *v8; // r0
  uLong v9; // r0

  v6 = (inflate_blocks_statef *)z->zalloc(z->opaque, 1, 64);
  if ( !v6 )
    return v6;
  v7 = (inflate_huft *)z->zalloc(z->opaque, 8, 1440);
  v6->hufts = v7;
  if ( !v7 )
  {
LABEL_7:
    z->zfree(z->opaque, v6);
    return 0;
  }
  v8 = (Bytef *)z->zalloc(z->opaque, 1, w);
  v6->window = v8;
  if ( !v8 )
  {
    z->zfree(z->opaque, v6->hufts);
    goto LABEL_7;
  }
  v6->mode = TYPE;
  v6->bitk = 0;
  v6->bitb = 0;
  v6->end = &v8[w];
  v6->read = v8;
  v6->write = v8;
  v6->checkfn = c;
  if ( c )
  {
    v9 = c(0, 0, 0);
    v6->check = v9;
    z->adler = v9;
  }
  return v6;
}

//----- (0020D2F8) --------------------------------------------------------
int __fastcall inflate_blocks(inflate_blocks_statef *s, z_streamp_0 z, int r)
{
  int v4; // r12
  Bytef *read; // r0
  Bytef *write; // r8
  Bytef *next_in; // r6
  uInt avail_in; // r9
  Bytef *v9; // r11
  int v10; // r0
  uInt last; // r0
  z_streamp_0 v12; // r11
  int v13; // t1
  bool v14; // cf
  uIntf *v15; // r0
  uInt index; // r0
  uInt v17; // r4
  int v18; // t1
  unsigned int v19; // r3
  uIntf *blens; // r1
  uInt v21; // r2
  uInt v22; // r2
  uIntf *v23; // r1
  uIntf *v24; // r0
  inflate_huft *hufts; // r3
  int v26; // r4
  uInt v27; // r0
  uInt v28; // r1
  uIntf v29; // r2
  int v30; // t1
  uInt v31; // r2
  unsigned int v32; // r11
  int v33; // r3
  uIntf *v34; // r1
  int v35; // r2
  int v36; // lr
  int v37; // t1
  uLong v38; // r12
  bool v39; // zf
  uIntf v40; // r1
  uInt v41; // r12
  int v42; // r3
  int v43; // r4
  int v44; // r2
  uLong v45; // r1
  int v46; // r0
  inflate_blocks_statef *v47; // r0
  z_stream *v48; // r1
  unsigned int v49; // r1
  int v50; // r0
  int v51; // r1
  inflate_codes_statef_0 *v52; // r0
  int v53; // r4
  uLong v54; // r1
  int v55; // r0
  int v56; // r2
  Bytef *v57; // r0
  inflate_codes_statef_0 *v58; // r0
  uLong v59; // r1
  int v60; // r0
  uLong total_in; // r1
  int v62; // r0
  inflate_block_mode mode; // r0
  Bytef *window; // r4
  Bytef *v65; // r0
  Bytef *v66; // r1
  Bytef *v67; // r3
  Bytef *v68; // r0
  size_t left; // r5
  uInt v70; // r0
  int v71; // t1
  int v72; // t1
  z_streamp_0 v73; // r1
  uLong v74; // r3
  int v75; // r0
  inflate_blocks_statef *v76; // r0
  uLong v77; // r3
  int v78; // r0
  uLong v79; // r1
  uInt v80; // r3
  z_streamp_0 v81; // r4
  uLong v82; // r2
  int v83; // r0
  uLong v84; // r1
  int v85; // r0
  uInt v86; // r0
  uLong v87; // r2
  int v88; // r0
  uLong v89; // r4
  uLong v90; // r1
  int v91; // r0
  uLong v92; // r1
  int v93; // r0
  uInt v95; // r0
  uLong v96; // r1
  int v97; // r0
  uInt v98; // [sp+18h] [bp-60h]
  int v99; // [sp+24h] [bp-54h]
  int v100; // [sp+24h] [bp-54h]
  int v101; // [sp+24h] [bp-54h]
  int v102; // [sp+24h] [bp-54h]
  int v103; // [sp+24h] [bp-54h]
  inflate_huft **p_tb; // [sp+34h] [bp-44h]
  uInt *p_bb; // [sp+38h] [bp-40h]
  unsigned int bitk; // [sp+40h] [bp-38h]
  uLong bitb; // [sp+44h] [bp-34h]
  uLong v110; // [sp+44h] [bp-34h]
  Bytef **p_end; // [sp+48h] [bp-30h]
  inflate_huft *v112; // [sp+4Ch] [bp-2Ch] BYREF
  inflate_huft *v113; // [sp+50h] [bp-28h] BYREF
  uIntf v114; // [sp+54h] [bp-24h] BYREF
  uIntf v115[8]; // [sp+58h] [bp-20h] BYREF

  v4 = r;
  bitk = s->bitk;
  bitb = s->bitb;
  write = s->write;
  read = s->read;
  next_in = z->next_in;
  avail_in = z->avail_in;
  if ( write >= read )
  {
    p_end = &s->end;
    v9 = (Bytef *)(s->end - write);
  }
  else
  {
    v9 = &read[~(unsigned int)write];
    p_end = &s->end;
  }
  p_bb = &s->sub.trees.bb;
  p_tb = &s->sub.trees.tb;
  while ( 2 )
  {
    mode = s->mode;
LABEL_80:
    switch ( mode )
    {
      case TYPE:
        if ( bitk > 2 )
        {
          v49 = bitb;
        }
        else
        {
          if ( !avail_in )
            goto LABEL_119;
          v71 = *next_in++;
          --avail_in;
          v4 = 0;
          v49 = bitb | (v71 << bitk);
          r = bitk + 8;
          bitk += 8;
        }
        s->last = v49 & 1;
        v110 = v49;
        v50 = (v49 >> 1) & 3;
        if ( v50 == 1 )
        {
          v103 = v4;
          j_inflate_trees_fixed(v115, &v114, &v113, &v112, z);
          v58 = j_inflate_codes_new(v115[0], v114, v113, v112, z);
          s->sub.left = (uInt)v58;
          if ( v58 )
          {
            v4 = v103;
            bitk -= 3;
            bitb = v110 >> 3;
            s->mode = CODES;
            continue;
          }
          s->bitk = bitk;
          s->bitb = v110;
          total_in = z->total_in;
          v62 = next_in - z->next_in;
          z->next_in = next_in;
          z->avail_in = avail_in;
          z->total_in = v62 + total_in;
          s->write = write;
          return j_inflate_flush(s, z, -4);
        }
        if ( v50 == 2 )
        {
          bitk -= 3;
          bitb = v49 >> 3;
          s->mode = TABLE;
          continue;
        }
        if ( v50 != 3 )
        {
          v51 = (bitk - 3) & 7;
          bitk = bitk - 3 - v51;
          bitb = v110 >> 3 >> v51;
          s->mode = LENS;
          continue;
        }
        s->mode = BAD;
        v73 = z;
        z->msg = "invalid block type";
        v86 = bitk - 3;
        r = v110 >> 3;
        goto LABEL_128;
      case LENS:
        if ( bitk > 0x1F )
          goto LABEL_5;
        do
        {
          if ( !avail_in )
            goto LABEL_119;
          v72 = *next_in++;
          --avail_in;
          v4 = 0;
          v14 = bitk + 8 >= 0x20;
          bitb |= v72 << bitk;
          bitk += 8;
        }
        while ( !v14 );
LABEL_5:
        r = bitb;
        v10 = HIWORD(bitb) ^ 0xFFFF;
        if ( v10 != (unsigned __int16)bitb )
        {
          s->mode = BAD;
          v73 = z;
          z->msg = "invalid stored block lengths";
          v86 = bitk;
LABEL_128:
          s->bitk = v86;
          s->bitb = r;
LABEL_129:
          v87 = v73->total_in;
          v88 = next_in - v73->next_in;
          v73->next_in = next_in;
          v73->avail_in = avail_in;
          v73->total_in = v88 + v87;
          v76 = s;
          s->write = write;
          v56 = -3;
          return j_inflate_flush(v76, v73, v56);
        }
        s->sub.left = v10;
        if ( v10 )
        {
          last = 2;
        }
        else
        {
          last = s->last;
          if ( last )
            last = 7;
        }
        s->mode = last;
        bitk = 0;
        bitb = 0;
        continue;
      case STORED:
        if ( !avail_in )
          goto LABEL_119;
        if ( v9 )
        {
          window = write;
          goto LABEL_103;
        }
        if ( write != *p_end || (window = s->window, v68 = s->read, v68 == window) )
        {
          window = write;
        }
        else
        {
          if ( window < v68 )
            write = v68 - 1;
          v9 = (Bytef *)(write - window);
          if ( write != window )
            goto LABEL_103;
        }
        s->write = window;
        v56 = j_inflate_flush(s, z, v4);
        v65 = s->write;
        v66 = s->read;
        v67 = *p_end;
        if ( v65 < v66 )
          v9 = &v66[~(unsigned int)v65];
        else
          v9 = (Bytef *)(v67 - v65);
        if ( v65 != v67 || (window = s->window, v66 == window) )
        {
          window = s->write;
          if ( !v9 )
            goto LABEL_120;
        }
        else
        {
          if ( window < v66 )
            v65 = v66 - 1;
          v9 = (Bytef *)(v65 - window);
          if ( v65 == window )
          {
LABEL_120:
            s->bitk = bitk;
            s->bitb = bitb;
            v73 = z;
            v77 = z->total_in;
            v78 = next_in - z->next_in;
            z->next_in = next_in;
            z->avail_in = avail_in;
            z->total_in = v78 + v77;
            s->write = window;
            v76 = s;
            return j_inflate_flush(v76, v73, v56);
          }
        }
LABEL_103:
        left = s->sub.left;
        if ( left > avail_in )
          left = avail_in;
        if ( left > (unsigned int)v9 )
          left = (size_t)v9;
        qmemcpy(window, next_in, left);
        v9 -= left;
        write = &window[left];
        avail_in -= left;
        next_in += left;
        v70 = s->sub.left - left;
        s->sub.left = v70;
        if ( v70 )
        {
          v4 = 0;
          continue;
        }
        mode = s->last;
        v4 = 0;
        if ( mode )
          mode = DRY;
        s->mode = mode;
        goto LABEL_80;
      case TABLE:
        v12 = z;
        if ( bitk > 0xD )
          goto LABEL_12;
        do
        {
          if ( !avail_in )
            goto LABEL_124;
          v13 = *next_in++;
          --avail_in;
          v4 = 0;
          r = bitk + 8;
          v14 = bitk + 8 >= 0xE;
          bitb |= v13 << bitk;
          bitk += 8;
        }
        while ( !v14 );
LABEL_12:
        v14 = (bitb & 0x1F) >= 0x1D;
        s->sub.left = bitb & 0x3FFF;
        if ( (bitb & 0x1F) <= 0x1D )
        {
          r = (bitb >> 5) & 0x1F;
          v14 = (unsigned int)r >= 0x1E;
        }
        if ( v14 )
        {
          v56 = -3;
          s->mode = BAD;
          z->msg = "too many length or distance symbols";
          s->bitk = bitk;
          s->bitb = bitb;
          goto LABEL_146;
        }
        v99 = v4;
        v15 = (uIntf *)z->zalloc(z->opaque, (bitb & 0x1F) + r + 258, 4);
        s->sub.trees.blens = v15;
        if ( !v15 )
        {
          v95 = bitk;
          v56 = -4;
          goto LABEL_145;
        }
        s->mode = BTREE;
        index = 0;
        s->sub.trees.index = 0;
        v4 = v99;
        v17 = bitk - 14;
        bitb >>= 14;
        do
        {
LABEL_18:
          if ( v17 > 2 )
          {
            v19 = bitb;
          }
          else
          {
            if ( !avail_in )
            {
              s->bitk = v17;
              goto LABEL_126;
            }
            v18 = *next_in++;
            --avail_in;
            v4 = 0;
            v19 = bitb | (v18 << v17);
            v17 += 8;
          }
          v17 -= 3;
          blens = s->sub.trees.blens;
          v21 = border[index];
          s->sub.trees.index = index + 1;
          blens[v21] = v19 & 7;
          index = s->sub.trees.index;
          bitb = v19 >> 3;
        }
        while ( index < (s->sub.left >> 10) + 4 );
LABEL_23:
        v100 = v4;
        bitk = v17;
        if ( index <= 0x12 )
        {
          do
          {
            v22 = border[index];
            v23 = s->sub.trees.blens;
            s->sub.trees.index = index + 1;
            v23[v22] = 0;
            index = s->sub.trees.index;
          }
          while ( index < 0x13 );
        }
        v24 = s->sub.trees.blens;
        hufts = s->hufts;
        s->sub.trees.bb = 7;
        v26 = j_inflate_trees_bits(v24, p_bb, p_tb, hufts, (int)v12);
        if ( v26 )
        {
          v12->zfree(v12->opaque, s->sub.trees.blens);
          v56 = v26;
          if ( v26 == -3 )
            s->mode = BAD;
          v95 = bitk;
LABEL_145:
          s->bitk = v95;
          s->bitb = bitb;
LABEL_146:
          v96 = v12->total_in;
          v97 = next_in - v12->next_in;
          v12->next_in = next_in;
          v12->avail_in = avail_in;
          v12->total_in = v97 + v96;
          s->write = write;
LABEL_147:
          v76 = s;
          v73 = v12;
          return j_inflate_flush(v76, v73, v56);
        }
        s->mode = DTREE;
        v27 = 0;
        s->sub.trees.index = 0;
        v4 = v100;
LABEL_27:
        v28 = s->sub.left;
        if ( v27 < (v28 & 0x1F) + ((v28 >> 5) & 0x1F) + 258 )
        {
          while ( 1 )
          {
            v29 = *p_bb;
            if ( bitk < *p_bb )
              break;
LABEL_31:
            v31 = (uInt)&(*p_tb)[inflate_mask[v29] & bitb];
            v32 = *(_DWORD *)(v31 + 4);
            v33 = *(unsigned __int8 *)(v31 + 1);
            if ( v32 > 0xF )
            {
              v35 = 3;
              if ( v32 == 18 )
                v35 = 11;
              v36 = v32 - 14;
              if ( v32 == 18 )
                v36 = 7;
              if ( bitk < v36 + v33 )
              {
                while ( avail_in )
                {
                  v37 = *next_in++;
                  --avail_in;
                  v4 = 0;
                  v14 = bitk + 8 >= v36 + v33;
                  bitb |= v37 << bitk;
                  bitk += 8;
                  if ( v14 )
                    goto LABEL_41;
                }
LABEL_119:
                s->bitk = bitk;
                s->bitb = bitb;
                v73 = z;
                v74 = z->total_in;
                v75 = next_in - z->next_in;
                z->next_in = next_in;
                z->avail_in = 0;
                z->total_in = v75 + v74;
                v76 = s;
                s->write = write;
                v56 = v4;
                return j_inflate_flush(v76, v73, v56);
              }
LABEL_41:
              v101 = v4;
              v38 = bitb >> v33;
              v98 = inflate_mask[v36] & (bitb >> v33);
              bitk = bitk - v33 - v36;
              if ( v35 + v98 + v27 > (v28 & 0x1F) + ((v28 >> 5) & 0x1F) + 258 )
                goto LABEL_130;
              v39 = v32 == 16;
              if ( v32 == 16 )
                v39 = v27 == 0;
              if ( v39 )
              {
LABEL_130:
                v89 = v38 >> v36;
                z->zfree(z->opaque, s->sub.trees.blens);
                v56 = -3;
                s->mode = BAD;
                z->msg = "invalid bit length repeat";
                s->bitk = bitk;
                s->bitb = v89;
                v90 = z->total_in;
                v91 = next_in - z->next_in;
                z->next_in = next_in;
                z->avail_in = avail_in;
                z->total_in = v91 + v90;
                s->write = write;
                v76 = s;
                v73 = z;
                return j_inflate_flush(v76, v73, v56);
              }
              v39 = v32 == 16;
              v12 = z;
              bitb = v38 >> v36;
              if ( v39 )
                v40 = s->sub.trees.blens[v27 - 1];
              else
                v40 = 0;
              v41 = v35 + v27;
              v42 = -(v35 + v98);
              do
              {
                ++v42;
                s->sub.trees.blens[v27++] = v40;
              }
              while ( v42 );
              v27 = v41 + v98;
              s->sub.trees.index = v41 + v98;
              v4 = v101;
            }
            else
            {
              v34 = s->sub.trees.blens;
              s->sub.trees.index = v27 + 1;
              v34[v27] = v32;
              v12 = z;
              bitk -= v33;
              v27 = s->sub.trees.index;
              bitb >>= v33;
            }
            v28 = s->sub.left;
            if ( v27 >= (v28 & 0x1F) + ((v28 >> 5) & 0x1F) + 258 )
              goto LABEL_52;
          }
          while ( avail_in )
          {
            v30 = *next_in++;
            --avail_in;
            v4 = 0;
            bitb |= v30 << bitk;
            bitk += 8;
            if ( bitk >= v29 )
              goto LABEL_31;
          }
LABEL_124:
          s->bitk = bitk;
LABEL_126:
          s->bitb = bitb;
          v84 = v12->total_in;
          v85 = next_in - v12->next_in;
          v12->next_in = next_in;
          v12->avail_in = 0;
          v12->total_in = v85 + v84;
          v76 = s;
          s->write = write;
          v73 = v12;
          v56 = v4;
          return j_inflate_flush(v76, v73, v56);
        }
LABEL_52:
        v102 = v4;
        s->sub.trees.tb = 0;
        v115[0] = 9;
        v114 = 6;
        v43 = j_inflate_trees_dynamic(
                (v28 & 0x1F) + 257,
                ((v28 >> 5) & 0x1F) + 1,
                s->sub.trees.blens,
                v115,
                &v114,
                &v113,
                &v112,
                s->hufts,
                v12);
        v12->zfree(v12->opaque, s->sub.trees.blens);
        if ( v43 )
        {
          v44 = v43;
          if ( v43 == -3 )
            s->mode = BAD;
          s->bitk = bitk;
          s->bitb = bitb;
          v45 = v12->total_in;
          v46 = next_in - v12->next_in;
          v12->next_in = next_in;
          v12->avail_in = avail_in;
          v12->total_in = v46 + v45;
          v47 = s;
          v48 = v12;
          s->write = write;
          return j_inflate_flush(v47, v48, v44);
        }
        v52 = j_inflate_codes_new(v115[0], v114, v113, v112, v12);
        if ( v52 )
        {
          s->sub.left = (uInt)v52;
          v53 = v102;
          s->mode = CODES;
LABEL_64:
          s->bitk = bitk;
          s->bitb = bitb;
          v54 = v12->total_in;
          v55 = next_in - v12->next_in;
          v12->next_in = next_in;
          v12->avail_in = avail_in;
          v12->total_in = v55 + v54;
          s->write = write;
          v56 = j_inflate_codes(s, v12, v53);
          if ( v56 != 1 )
            goto LABEL_147;
          j_inflate_codes_free((inflate_codes_statef_0 *)s->sub.left, v12);
          bitk = s->bitk;
          bitb = s->bitb;
          write = s->write;
          v57 = s->read;
          avail_in = v12->avail_in;
          next_in = v12->next_in;
          if ( write >= v57 )
            v9 = (Bytef *)(*p_end - write);
          else
            v9 = &v57[~(unsigned int)write];
          if ( s->last )
          {
            v4 = 0;
            s->mode = DRY;
LABEL_132:
            s->write = write;
            v81 = z;
            v56 = j_inflate_flush(s, z, v4);
            write = s->write;
            v80 = bitk;
            v79 = bitb;
            if ( s->read == write )
            {
              s->mode = DONE;
LABEL_135:
              s->bitk = v80;
              s->bitb = v79;
              v56 = 1;
            }
            else
            {
              s->bitk = bitk;
              s->bitb = bitb;
            }
            v92 = v81->total_in;
            v93 = next_in - v81->next_in;
            v81->next_in = next_in;
            v81->avail_in = avail_in;
            v81->total_in = v93 + v92;
            s->write = write;
            v76 = s;
            v73 = v81;
            return j_inflate_flush(v76, v73, v56);
          }
          v4 = 0;
          s->mode = TYPE;
          continue;
        }
        s->bitk = bitk;
        v44 = -4;
        s->bitb = bitb;
        v59 = v12->total_in;
        v60 = next_in - v12->next_in;
        v12->next_in = next_in;
        v12->avail_in = avail_in;
        v12->total_in = v60 + v59;
        s->write = write;
        v47 = s;
        v48 = v12;
        return j_inflate_flush(v47, v48, v44);
      case BTREE:
        index = s->sub.trees.index;
        v12 = z;
        v17 = bitk;
        if ( index < (s->sub.left >> 10) + 4 )
          goto LABEL_18;
        goto LABEL_23;
      case DTREE:
        v27 = s->sub.trees.index;
        v12 = z;
        goto LABEL_27;
      case CODES:
        v12 = z;
        v53 = v4;
        goto LABEL_64;
      case DRY:
        goto LABEL_132;
      case DONE:
        v79 = bitb;
        v81 = z;
        v80 = bitk;
        goto LABEL_135;
      case BAD:
        s->bitk = bitk;
        s->bitb = bitb;
        v73 = z;
        goto LABEL_129;
      default:
        s->bitk = bitk;
        s->bitb = bitb;
        v73 = z;
        v82 = z->total_in;
        v83 = next_in - z->next_in;
        z->next_in = next_in;
        z->avail_in = avail_in;
        z->total_in = v83 + v82;
        v76 = s;
        v56 = -2;
        s->write = write;
        return j_inflate_flush(v76, v73, v56);
    }
  }
}
// 20D9E8: conditional instruction was optimized away because r0.4 is in (==0|==7)
// 20D3DC: variable 'r' is possibly undefined

//----- (0020DCEC) --------------------------------------------------------
int __fastcall inflate_blocks_free(inflate_blocks_statef *s, z_streamp_0 z)
{
  inflate_block_mode mode; // r0
  check_func checkfn; // r3
  Bytef *window; // r1
  uLong v7; // r0

  mode = s->mode;
  if ( (mode & 0xFFFFFFFE) == 4 )
  {
    z->zfree(z->opaque, s->sub.trees.blens);
    mode = s->mode;
  }
  if ( mode == CODES )
    j_inflate_codes_free((inflate_codes_statef_0 *)s->sub.left, z);
  checkfn = s->checkfn;
  window = s->window;
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = window;
  s->write = window;
  if ( checkfn )
  {
    v7 = checkfn(0, 0, 0);
    s->check = v7;
    z->adler = v7;
    window = s->window;
  }
  z->zfree(z->opaque, window);
  z->zfree(z->opaque, s->hufts);
  z->zfree(z->opaque, s);
  return 0;
}

//----- (0020DD50) --------------------------------------------------------
void __fastcall inflate_set_dictionary(inflate_blocks_statef *s, const Bytef *d, uInt n)
{
  Bytef *v5; // r0

  qmemcpy(s->window, d, n);
  v5 = &s->window[n];
  s->read = v5;
  s->write = v5;
}

//----- (0020DD68) --------------------------------------------------------
int __fastcall inflate_blocks_sync_point(inflate_blocks_statef *s)
{
  int result; // r0

  result = s->mode;
  if ( result != 1 )
    return 0;
  return result;
}

//----- (0020DD74) --------------------------------------------------------
inflate_codes_statef_0 *__fastcall inflate_codes_new(
        uInt bl,
        uInt bd,
        inflate_huft *tl,
        inflate_huft *td,
        z_streamp_0 z)
{
  Byte v5; // r4
  Byte v8; // r6
  inflate_codes_statef_0 *result; // r0

  v5 = bl;
  v8 = bd;
  result = (inflate_codes_statef_0 *)z->zalloc(z->opaque, 1, 28);
  if ( result )
  {
    result->lbits = v5;
    result->mode = START;
    result->dbits = v8;
    result->ltree = tl;
    result->dtree = td;
  }
  return result;
}

//----- (0020DDA8) --------------------------------------------------------
int __fastcall inflate_codes(inflate_blocks_statef *s, z_streamp_0 z, int r)
{
  inflate_blocks_statef *v3; // r3
  uInt left; // r11
  uLong bitb; // r4
  uInt bitk; // r5
  Bytef *read; // r0
  Bytef *write; // r12
  Bytef *next_in; // r10
  uInt avail_in; // r6
  unsigned int v11; // lr
  __int64 v12; // r0
  bool v13; // cf
  uLong total_in; // r1
  int v15; // r0
  int v16; // r0
  Bytef *v17; // r0
  uInt v18; // r0
  int v19; // t1
  unsigned __int8 *v20; // r8
  int v21; // r0
  int v22; // r3
  uInt v23; // r3
  int v24; // t1
  uInt v25; // r0
  int v26; // r9
  uInt v27; // r1
  uInt v28; // r8
  int v29; // t1
  unsigned __int8 *v30; // r8
  int v31; // r3
  int v32; // r0
  uInt v33; // r0
  int v34; // t1
  int v35; // r8
  uInt v36; // r3
  int v37; // r3
  unsigned int v38; // r3
  unsigned int v39; // r1
  Bytef *v40; // r0
  Bytef *v41; // r0
  int v42; // r0
  int v43; // r9
  Bytef *v44; // r0
  Bytef *v45; // r2
  Bytef *v46; // r8
  Bytef *window; // r0
  Bytef *v48; // r1
  bool v49; // zf
  int v50; // r0
  Bytef *v51; // r0
  Bytef *v52; // r2
  Bytef v53; // t1
  int v54; // r0
  int v55; // r8
  Bytef *v56; // r1
  int v57; // r0
  uLong v58; // r2
  int v59; // r0
  inflate_blocks_statef *v62; // [sp+1Ch] [bp-24h]
  Bytef **p_end; // [sp+20h] [bp-20h]

  v3 = s;
  left = s->sub.left;
  bitb = s->bitb;
  bitk = s->bitk;
  write = s->write;
  read = s->read;
  next_in = z->next_in;
  avail_in = z->avail_in;
  if ( write >= read )
  {
    p_end = &v3->end;
    v11 = v3->end - write;
  }
  else
  {
    v11 = (unsigned int)&read[~(unsigned int)write];
    p_end = &v3->end;
  }
  LODWORD(v12) = *(_DWORD *)left;
  v62 = v3;
  if ( *(_DWORD *)left > 9u )
  {
LABEL_107:
    v43 = -2;
    goto LABEL_105;
  }
  while ( 2 )
  {
    v43 = 1;
    switch ( (int)v12 )
    {
      case 0:
        v13 = avail_in >= 0xA;
        if ( avail_in >= 0xA )
          v13 = v11 >= 0x102;
        if ( !v13 )
          goto LABEL_78;
        v3->bitk = bitk;
        v3->bitb = bitb;
        total_in = z->total_in;
        v15 = next_in - z->next_in;
        z->next_in = next_in;
        z->avail_in = avail_in;
        z->total_in = v15 + total_in;
        v3->write = write;
        v16 = j_inflate_fast(
                *(unsigned __int8 *)(left + 16),
                *(unsigned __int8 *)(left + 17),
                *(inflate_huft **)(left + 20),
                *(inflate_huft **)(left + 24),
                v62,
                z);
        v3 = v62;
        r = v16;
        bitb = v62->bitb;
        bitk = v62->bitk;
        write = v62->write;
        v17 = v62->read;
        avail_in = z->avail_in;
        next_in = z->next_in;
        if ( write >= v17 )
        {
          v11 = *p_end - write;
          if ( r )
          {
LABEL_12:
            LODWORD(v12) = 9;
            if ( r == 1 )
              LODWORD(v12) = 7;
            *(_DWORD *)left = v12;
            continue;
          }
        }
        else
        {
          v11 = (unsigned int)&v17[~(unsigned int)write];
          if ( r )
            goto LABEL_12;
        }
        r = 0;
LABEL_78:
        v18 = *(unsigned __int8 *)(left + 16);
        v55 = *(_DWORD *)(left + 20);
        *(_DWORD *)left = 1;
        *(_DWORD *)(left + 8) = v55;
        *(_DWORD *)(left + 12) = v18;
        if ( bitk < v18 )
        {
LABEL_16:
          while ( avail_in )
          {
            v19 = *next_in++;
            --avail_in;
            r = 0;
            bitb |= v19 << bitk;
            bitk += 8;
            if ( bitk >= v18 )
              goto LABEL_18;
          }
LABEL_104:
          avail_in = 0;
          v43 = r;
          goto LABEL_105;
        }
LABEL_18:
        v20 = (unsigned __int8 *)(*(_DWORD *)(left + 8) + 8 * (inflate_mask[v18] & bitb));
        v21 = *v20;
        v22 = v20[1];
        bitk -= v22;
        bitb >>= v22;
        if ( *v20 )
        {
          v3 = v62;
          if ( (v21 & 0x10) != 0 )
          {
            *(_DWORD *)(left + 8) = v21 & 0xF;
            HIDWORD(v12) = *((_DWORD *)v20 + 1);
            LODWORD(v12) = 2;
            *(_QWORD *)left = v12;
          }
          else
          {
            if ( (v21 & 0x40) == 0 )
            {
              *(_DWORD *)(left + 12) = v21;
              *(_DWORD *)(left + 8) = &v20[8 * *((_DWORD *)v20 + 1)];
              LODWORD(v12) = 1;
              continue;
            }
            if ( (v21 & 0x20) == 0 )
            {
              v43 = -3;
              *(_DWORD *)left = 9;
              z->msg = "invalid literal/length code";
              goto LABEL_105;
            }
            LODWORD(v12) = 7;
            *(_DWORD *)left = 7;
          }
        }
        else
        {
          LODWORD(v12) = 6;
          HIDWORD(v12) = *((_DWORD *)v20 + 1);
          *(_DWORD *)left = 6;
          *(_DWORD *)(left + 8) = HIDWORD(v12);
          v3 = v62;
        }
        continue;
      case 1:
        v18 = *(_DWORD *)(left + 12);
        if ( bitk < v18 )
          goto LABEL_16;
        goto LABEL_18;
      case 2:
        v23 = *(_DWORD *)(left + 8);
        if ( bitk >= v23 )
          goto LABEL_25;
        do
        {
          if ( !avail_in )
          {
            avail_in = 0;
            v43 = r;
            v3 = v62;
            goto LABEL_105;
          }
          v24 = *next_in++;
          --avail_in;
          r = 0;
          bitb |= v24 << bitk;
          bitk += 8;
        }
        while ( bitk < v23 );
LABEL_25:
        bitk -= v23;
        v25 = *(unsigned __int8 *)(left + 17);
        v26 = *(_DWORD *)(left + 24);
        v27 = inflate_mask[v23] & bitb;
        bitb >>= v23;
        v28 = *(_DWORD *)(left + 4) + v27;
        *(_DWORD *)left = 3;
        *(_DWORD *)(left + 4) = v28;
        *(_DWORD *)(left + 8) = v26;
        *(_DWORD *)(left + 12) = v25;
        v3 = v62;
        if ( bitk < v25 )
        {
LABEL_28:
          while ( avail_in )
          {
            v29 = *next_in++;
            --avail_in;
            r = 0;
            bitb |= v29 << bitk;
            bitk += 8;
            if ( bitk >= v25 )
              goto LABEL_30;
          }
          goto LABEL_104;
        }
LABEL_30:
        v30 = (unsigned __int8 *)(*(_DWORD *)(left + 8) + 8 * (inflate_mask[v25] & bitb));
        v31 = *v30;
        v32 = v30[1];
        bitk -= v32;
        bitb >>= v32;
        if ( (v31 & 0x10) != 0 )
        {
          *(_DWORD *)(left + 8) = v31 & 0xF;
          HIDWORD(v12) = *((_DWORD *)v30 + 1);
          LODWORD(v12) = 4;
          *(_DWORD *)left = 4;
          *(_DWORD *)(left + 12) = HIDWORD(v12);
          v3 = v62;
          continue;
        }
        if ( (v31 & 0x40) == 0 )
        {
          *(_DWORD *)(left + 12) = v31;
          *(_DWORD *)(left + 8) = &v30[8 * *((_DWORD *)v30 + 1)];
          LODWORD(v12) = 3;
          v3 = v62;
          continue;
        }
        v43 = -3;
        *(_DWORD *)left = 9;
        z->msg = "invalid distance code";
        v3 = v62;
LABEL_105:
        v3->bitk = bitk;
        v3->bitb = bitb;
        v58 = z->total_in;
        v59 = next_in - z->next_in;
        z->next_in = next_in;
        z->avail_in = avail_in;
        z->total_in = v59 + v58;
        v3->write = write;
        return sub_197FDC(v3, z, v43);
      case 3:
        v25 = *(_DWORD *)(left + 12);
        if ( bitk < v25 )
          goto LABEL_28;
        goto LABEL_30;
      case 4:
        v33 = *(_DWORD *)(left + 8);
        if ( bitk >= v33 )
          goto LABEL_36;
        do
        {
          if ( !avail_in )
            goto LABEL_104;
          v34 = *next_in++;
          --avail_in;
          r = 0;
          bitb |= v34 << bitk;
          bitk += 8;
        }
        while ( bitk < v33 );
LABEL_36:
        bitk -= v33;
        v35 = *(_DWORD *)(left + 12);
        v36 = inflate_mask[v33];
        *(_DWORD *)left = 5;
        v37 = v36 & bitb;
        bitb >>= v33;
        v38 = v37 + v35;
        *(_DWORD *)(left + 12) = v38;
LABEL_37:
        v39 = write - v62->window;
        if ( v38 <= v39 )
        {
          v40 = write;
        }
        else
        {
          v38 -= v39;
          v40 = *p_end;
        }
        if ( *(_DWORD *)(left + 4) )
        {
          v46 = &v40[-v38];
          v3 = v62;
          while ( 1 )
          {
            if ( !v11 )
            {
              if ( write != *p_end || (window = v3->window, v48 = v3->read, v48 == window) )
              {
                window = write;
              }
              else
              {
                if ( window < v48 )
                  write = v48 - 1;
                v11 = write - window;
                v49 = write == window;
                write = v3->window;
                if ( !v49 )
                  goto LABEL_67;
              }
              v3->write = window;
              v50 = j_inflate_flush(v3, z, r);
              v3 = v62;
              v43 = v50;
              v51 = v62->write;
              v52 = v62->read;
              if ( v51 >= v52 )
              {
                v11 = *p_end - v51;
                if ( v51 != *p_end )
                  goto LABEL_66;
              }
              else
              {
                v11 = (unsigned int)&v52[~(unsigned int)v51];
                v3 = v62;
                if ( v51 != *p_end )
                  goto LABEL_66;
              }
              write = v3->window;
              if ( v52 == write )
              {
LABEL_66:
                write = v62->write;
                if ( !v11 )
                  goto LABEL_105;
                goto LABEL_67;
              }
              if ( write < v52 )
                v51 = v52 - 1;
              v11 = v51 - write;
              if ( v51 == write )
                goto LABEL_105;
            }
LABEL_67:
            v53 = *v46++;
            --v11;
            *write++ = v53;
            r = 0;
            if ( v46 == *p_end )
              v46 = v3->window;
            v54 = *(_DWORD *)(left + 4) - 1;
            *(_DWORD *)(left + 4) = v54;
            if ( !v54 )
              goto LABEL_72;
          }
        }
        v3 = v62;
LABEL_72:
        LODWORD(v12) = 0;
        *(_DWORD *)left = 0;
        continue;
      case 5:
        v38 = *(_DWORD *)(left + 12);
        goto LABEL_37;
      case 6:
        if ( v11 )
          goto LABEL_89;
        if ( write != *p_end || (v41 = v3->window, v56 = v3->read, v56 == v41) )
        {
          v41 = write;
        }
        else
        {
          if ( v41 < v56 )
            write = v56 - 1;
          v11 = write - v41;
          v49 = write == v41;
          write = v3->window;
          if ( !v49 )
            goto LABEL_89;
        }
        v3->write = v41;
        v42 = j_inflate_flush(v3, z, r);
        v3 = v62;
        v43 = v42;
        v44 = v62->write;
        v45 = v62->read;
        if ( v44 >= v45 )
        {
          v11 = *p_end - v44;
          if ( v44 != *p_end )
            goto LABEL_88;
        }
        else
        {
          v11 = (unsigned int)&v45[~(unsigned int)v44];
          v3 = v62;
          if ( v44 != *p_end )
            goto LABEL_88;
        }
        write = v3->window;
        if ( v45 == write )
        {
LABEL_88:
          write = v62->write;
          if ( !v11 )
            goto LABEL_105;
          goto LABEL_89;
        }
        if ( write < v45 )
          v44 = v45 - 1;
        v11 = v44 - write;
        if ( v44 == write )
          goto LABEL_105;
LABEL_89:
        --v11;
        *write++ = *(_DWORD *)(left + 8);
        LODWORD(v12) = 0;
        *(_DWORD *)left = 0;
        r = 0;
        continue;
      case 7:
        v3->write = write;
        if ( bitk > 7 )
        {
          ++avail_in;
          --next_in;
        }
        v57 = j_inflate_flush(v3, z, r);
        v3 = v62;
        v43 = v57;
        write = v62->write;
        if ( bitk > 7 )
          bitk -= 8;
        if ( v62->read == write )
        {
          v43 = 1;
          *(_DWORD *)left = 8;
        }
        goto LABEL_105;
      case 8:
        goto LABEL_105;
      case 9:
        v43 = -3;
        goto LABEL_105;
      default:
        goto LABEL_107;
    }
  }
}
// 20DE96: conditional instruction was optimized away because r0.4 is in (==7|==9)

//----- (0020E310) --------------------------------------------------------
void __fastcall inflate_codes_free(inflate_codes_statef_0 *c, z_streamp_0 z)
{
  z->zfree(z->opaque, c);
}

//----- (0020E31C) --------------------------------------------------------
int __fastcall inflate_fast(
        uInt bl,
        uInt bd,
        inflate_huft *tl,
        inflate_huft *td,
        inflate_blocks_statef *s,
        z_streamp_0 z)
{
  inflate_blocks_statef *v6; // r11
  uLong bitb; // r8
  uInt bitk; // r9
  Bytef *read; // r2
  Bytef *write; // lr
  Bytef *next_in; // r6
  uInt avail_in; // r12
  Bytef *v13; // r3
  inflate_huft *v14; // r5
  Bytef *v15; // r1
  Bytef *v16; // r2
  unsigned int v17; // r3
  Bytef *v18; // r0
  unsigned int v19; // r10
  unsigned int v20; // r5
  Bytef *v21; // r12
  __int64 v22; // d16
  __int64 v23; // d17
  Bytef *v24; // r4
  unsigned int v25; // r4
  bool v26; // zf
  Bytef *v27; // lr
  Bytef *v28; // r2
  unsigned int v29; // r0
  Bytef *v30; // r11
  unsigned int v31; // r5
  Bytef *v32; // r10
  __int64 v33; // d16
  __int64 v34; // d17
  int v35; // r10
  Bytef *v36; // r10
  inflate_huft *v37; // r1
  unsigned int v38; // r0
  unsigned int i; // r5
  int v40; // t1
  int v41; // r4
  int Exop; // r2
  inflate_huft *v43; // r0
  int v44; // r3
  inflate_huft *v45; // r0
  uInt v46; // r3
  int Bits; // r2
  int v48; // r4
  uInt base; // r12
  uLong v50; // r3
  uInt v51; // r11
  unsigned int v52; // r2
  Bytef *v53; // lr
  uInt v54; // r5
  uInt v55; // r0
  unsigned int v56; // r9
  int v57; // t1
  int v58; // r5
  Bytef *v59; // r4
  inflate_huft *v60; // r0
  int v61; // r6
  int v62; // r5
  uLong v63; // lr
  int v64; // r5
  unsigned int v65; // r3
  int v66; // r10
  unsigned int v67; // r5
  unsigned int v68; // r8
  unsigned int v69; // r11
  unsigned int v70; // r5
  int v71; // t1
  int v72; // r2
  unsigned int v73; // r10
  Bytef *window; // r5
  uInt v75; // r1
  uInt v76; // r11
  int v77; // r2
  uInt v78; // r0
  unsigned int v79; // r4
  Bytef *v80; // r8
  Bytef *v81; // r1
  Bytef *v82; // r0
  bool v83; // cf
  Bytef *v84; // r0
  Bytef v85; // t1
  unsigned int v86; // lr
  Bytef *v87; // r0
  unsigned int v88; // r5
  bool v89; // cf
  Bytef v90; // t1
  bool v91; // cc
  z_streamp_0 v92; // r4
  uInt v93; // r1
  bool v94; // cf
  int result; // r0
  uInt v96; // r0
  uInt v97; // r2
  Bytef *v98; // r1
  int v99; // r3
  uInt v100; // r0
  unsigned int v101; // [sp+0h] [bp-58h]
  uInt v102; // [sp+4h] [bp-54h]
  int v103; // [sp+8h] [bp-50h]
  Bytef **p_end; // [sp+Ch] [bp-4Ch]
  Bytef *v105; // [sp+10h] [bp-48h]
  uInt v106; // [sp+20h] [bp-38h]
  uInt v109; // [sp+2Ch] [bp-2Ch]
  Bytef *v110; // [sp+30h] [bp-28h]
  uInt v111; // [sp+38h] [bp-20h]

  v6 = s;
  bitb = s->bitb;
  bitk = s->bitk;
  write = s->write;
  read = s->read;
  avail_in = z->avail_in;
  next_in = z->next_in;
  if ( write >= read )
  {
    p_end = &s->end;
    v13 = (Bytef *)(s->end - write);
  }
  else
  {
    v13 = &read[~(unsigned int)write];
    p_end = &s->end;
  }
  v14 = tl;
  v111 = inflate_mask[bl];
  v106 = inflate_mask[bd];
  v15 = v13;
  while ( 1 )
  {
    if ( bitk <= 0x13 )
    {
      v36 = v15;
      v37 = v14;
      v38 = (unsigned int)&next_in[((19 - bitk) >> 3) + 1];
      for ( i = bitk; i < 0x14; i += 8 )
      {
        v40 = *next_in++;
        v41 = v40 << i;
        bitb |= v41;
      }
      avail_in = avail_in - 1 - ((19 - bitk) >> 3);
      bitk += ((19 - bitk) & 0xFFFFFFF8) + 8;
      v14 = v37;
      next_in = (Bytef *)v38;
      v15 = v36;
    }
    Exop = v14[v111 & bitb].word.what.Exop;
    v43 = &v14[v111 & bitb];
    if ( v43->word.what.Exop )
      break;
LABEL_22:
    Bits = v43->word.what.Bits;
    --v15;
    bitk -= Bits;
    bitb >>= Bits;
    *write++ = v43->base;
LABEL_59:
    v91 = avail_in > 0xA;
    if ( avail_in >= 0xA )
      v91 = (unsigned int)v15 >> 1 > 0x80;
    if ( !v91 )
    {
      v92 = z;
      v93 = z->avail_in - avail_in;
      v94 = bitk >> 3 >= v93;
      result = 0;
      goto LABEL_66;
    }
  }
  while ( 1 )
  {
    v44 = v43->word.what.Bits;
    bitk -= v44;
    bitb >>= v44;
    if ( (Exop & 0x10) != 0 )
    {
      v109 = avail_in;
      v110 = write;
      v48 = Exop & 0xF;
      base = v43->base;
      v50 = bitb >> (Exop & 0xF);
      v105 = v15;
      v51 = inflate_mask[v48];
      v52 = bitk - v48;
      if ( bitk - v48 > 0xE )
      {
        v59 = next_in;
      }
      else
      {
        v53 = next_in + 1;
        v54 = v48 + 14 - bitk;
        v55 = v54 >> 3;
        v56 = (v54 & 0xFFFFFFF8) + bitk + 8;
        do
        {
          v57 = *next_in++;
          v58 = v57 << v52;
          v52 += 8;
          v50 |= v58;
        }
        while ( v52 < 0xF );
        v52 = v56 - v48;
        v59 = &v53[v55];
        v109 = v109 - 1 - v55;
      }
      v60 = &td[v50 & v106];
      v61 = v60->word.what.Exop;
      v62 = v60->word.what.Bits;
      bitk = v52 - v62;
      v63 = v50 >> v62;
      if ( (v61 & 0x10) == 0 )
      {
        while ( (v61 & 0x40) == 0 )
        {
          v60 += v60->base + (inflate_mask[v61] & v63);
          v61 = v60->word.what.Exop;
          v64 = v60->word.what.Bits;
          bitk -= v64;
          v63 >>= v64;
          if ( (v61 & 0x10) != 0 )
            goto LABEL_31;
        }
        next_in = v59;
        bitb = v63;
        v6 = s;
        v100 = z->avail_in;
        v92 = z;
        z->msg = "invalid distance code";
        v93 = v100 - v109;
        result = -3;
        if ( bitk >> 3 < v93 )
          v93 = bitk >> 3;
        write = v110;
        v97 = v109 + v93;
        goto LABEL_69;
      }
LABEL_31:
      v65 = v61 & 0xF;
      v66 = v51 & bitb;
      if ( bitk >= v65 )
      {
        next_in = v59;
      }
      else
      {
        v67 = v65 - 1 - bitk;
        v68 = v67 & 0xFFFFFFF8;
        v69 = v67 >> 3;
        next_in = &v59[(v67 >> 3) + 1];
        v70 = bitk;
        do
        {
          v71 = *v59++;
          v72 = v71 << v70;
          v70 += 8;
          v63 |= v72;
        }
        while ( v70 < v65 );
        v109 = v109 - 1 - v69;
        bitk += v68 + 8;
      }
      v73 = v66 + base;
      window = s->window;
      v75 = v60->base;
      v76 = inflate_mask[v65] & v63;
      v77 = v110 - window;
      v78 = v76 + v75;
      if ( v76 + v75 <= v110 - window )
      {
        v84 = &v110[-v78];
        v25 = v73 - 2;
        v21 = v84 + 2;
        v6 = s;
        *v110 = *v84;
        v110[1] = v84[1];
        v110 += 2;
        v81 = v105;
      }
      else
      {
        v102 = v75;
        v79 = v78 - v77;
        v80 = *p_end;
        v21 = &(*p_end)[-(v78 - v77)];
        if ( v73 > v78 - v77 )
        {
          v101 = v73;
          v81 = v105;
          v82 = &window[v102 + v76];
          v30 = v110;
          v35 = v82 - v110;
          if ( v79 >= 0x10 )
          {
            if ( (v79 & 0xFFFFFFF0) != 0 )
            {
              v83 = v110 >= v80;
              if ( v110 < v80 )
                v83 = v21 >= &v110[v79];
              if ( v83 )
              {
                v103 = v82 - v110;
                v28 = &v21[v79 & 0xFFFFFFF0];
                v29 = v79 - (v79 & 0xFFFFFFF0);
                v30 = &v110[v79 & 0xFFFFFFF0];
                v31 = v79 & 0xFFFFFFF0;
                v32 = v110;
                do
                {
                  v33 = *(_QWORD *)v21;
                  v34 = *((_QWORD *)v21 + 1);
                  v21 += 16;
                  v31 -= 16;
                  *(_QWORD *)v32 = v33;
                  *((_QWORD *)v32 + 1) = v34;
                  v32 += 16;
                }
                while ( v31 );
                v35 = v103;
                if ( v79 == (v79 & 0xFFFFFFF0) )
                  goto LABEL_49;
              }
              else
              {
                v30 = v110;
                v29 = v79;
                v28 = v21;
              }
              do
              {
LABEL_48:
                v85 = *v28++;
                --v29;
                *v30++ = v85;
              }
              while ( v29 );
LABEL_49:
              v6 = s;
              v110 += v35;
              v73 = v101;
              v21 = s->window;
              v25 = v101 - v79;
              goto LABEL_50;
            }
            v30 = v110;
          }
          v29 = v79;
          v28 = v21;
          goto LABEL_48;
        }
        v25 = v73;
        v6 = s;
        v81 = v105;
      }
LABEL_50:
      v15 = &v81[-v73];
      bitk -= v65;
      bitb = v63 >> v65;
      if ( v25 >= 0x10 && (v86 = v25 & 0xFFFFFFF0, (v25 & 0xFFFFFFF0) != 0) )
      {
        v87 = &v21[v25];
        v88 = v25;
        v24 = v110;
        v89 = v110 >= v87;
        if ( v110 < v87 )
          v89 = v21 >= &v110[v88];
        if ( v89 )
        {
          v16 = &v21[v86];
          v17 = v88 - v86;
          v18 = &v110[v86];
          v19 = v88;
          v20 = v86;
          do
          {
            v22 = *(_QWORD *)v21;
            v23 = *((_QWORD *)v21 + 1);
            v21 += 16;
            v20 -= 16;
            *(_QWORD *)v24 = v22;
            *((_QWORD *)v24 + 1) = v23;
            v24 += 16;
          }
          while ( v20 );
          v25 = v19;
          v26 = v19 == v86;
          avail_in = v109;
          v27 = v110;
          if ( v26 )
            goto LABEL_58;
        }
        else
        {
          v16 = v21;
          v18 = v110;
          v27 = v110;
          v17 = v88;
          avail_in = v109;
          v25 = v88;
        }
      }
      else
      {
        v27 = v110;
        v16 = v21;
        v17 = v25;
        avail_in = v109;
        v18 = v110;
      }
      do
      {
        v90 = *v16++;
        --v17;
        *v18++ = v90;
      }
      while ( v17 );
LABEL_58:
      write = &v27[v25];
      v14 = tl;
      goto LABEL_59;
    }
    if ( (Exop & 0x40) != 0 )
      break;
    v45 = &v43[v43->base];
    v46 = inflate_mask[Exop] & bitb;
    Exop = v45[v46].word.what.Exop;
    v43 = &v45[v46];
    if ( !Exop )
      goto LABEL_22;
  }
  v92 = z;
  if ( (Exop & 0x20) != 0 )
  {
    v93 = z->avail_in - avail_in;
    v94 = bitk >> 3 >= v93;
    result = 1;
  }
  else
  {
    v96 = z->avail_in;
    z->msg = "invalid literal/length code";
    v93 = v96 - avail_in;
    v94 = bitk >> 3 >= v96 - avail_in;
    result = -3;
  }
LABEL_66:
  if ( !v94 )
    v93 = bitk >> 3;
  v97 = v93 + avail_in;
LABEL_69:
  v6->bitk = bitk - 8 * v93;
  v6->bitb = bitb;
  v98 = &next_in[-v93];
  v99 = v98 - v92->next_in + v92->total_in;
  v92->next_in = v98;
  v92->avail_in = v97;
  v92->total_in = v99;
  v6->write = write;
  return result;
}

//----- (0020E79C) --------------------------------------------------------
int __fastcall inflateReset(z_streamp_1 z)
{
  z_stream *v1; // r1
  bool v2; // zf
  Bytef *next_out; // r2

  v1 = (z_stream *)z;
  v2 = z == 0;
  if ( z )
  {
    z = (z_streamp_1)z->state;
    v2 = z == 0;
  }
  if ( v2 )
    return -2;
  v1->total_in = 0;
  v1->total_out = 0;
  v1->msg = 0;
  next_out = z->next_out;
  if ( next_out )
    next_out = (Bytef *)&byte_7;
  z->next_in = next_out;
  j_inflate_blocks_reset((inflate_blocks_statef *)v1->state[5].dummy, v1, 0);
  return 0;
}
// 7: using guessed type char byte_7;

//----- (0020E7D4) --------------------------------------------------------
int __fastcall inflateEnd(z_streamp_1 z)
{
  free_func zfree; // r2
  internal_state_1 *state; // r1
  bool v4; // zf
  inflate_blocks_statef *blocks; // r0
  int result; // r0

  if ( !z )
    return -2;
  state = z->state;
  v4 = state == 0;
  if ( state )
  {
    zfree = z->zfree;
    v4 = zfree == 0;
  }
  if ( v4 )
    return -2;
  blocks = (inflate_blocks_statef *)state->blocks;
  if ( blocks )
  {
    j_inflate_blocks_free(blocks, (z_streamp_0)z);
    state = z->state;
    zfree = z->zfree;
  }
  zfree(z->opaque, state);
  result = 0;
  z->state = 0;
  return result;
}
// 20E7F8: variable 'zfree' is possibly undefined

//----- (0020E808) --------------------------------------------------------
int __fastcall inflateInit2_(z_streamp_1 z, int w, const unsigned __int8 *version, int stream_size)
{
  int v6; // r6
  bool v7; // zf
  voidpf (__fastcall *zalloc)(voidpf, unsigned int, unsigned int); // r3
  internal_state_1 *v9; // r0
  internal_state_1 *state; // r1
  uLong (*v11)(uLong, const Bytef *, uInt); // r1
  inflate_blocks_statef *v12; // r0
  internal_state_1 *v13; // r1
  int nowrap; // r0
  free_func v15; // r2
  inflate_blocks_statef *v16; // r0
  free_func zfree; // r2
  inflate_blocks_statef *blocks; // r0

  v6 = -6;
  if ( version )
  {
    v7 = stream_size == 56;
    if ( stream_size == 56 )
      v7 = *version == 49;
    if ( v7 )
    {
      if ( z )
      {
        zalloc = z->zalloc;
        z->msg = 0;
        if ( !zalloc )
        {
          z->opaque = 0;
          zalloc = zcalloc;
          z->zalloc = zcalloc;
        }
        if ( !z->zfree )
          z->zfree = zcfree;
        v9 = (internal_state_1 *)zalloc(z->opaque, 1u, 0x18u);
        z->state = v9;
        if ( !v9 )
          return -4;
        v9->blocks = 0;
        z->state->nowrap = 0;
        if ( w <= -1 )
        {
          w = -w;
          z->state->nowrap = 1;
        }
        state = z->state;
        if ( (w & 0xFFFFFFF8) == 8 )
        {
          state->wbits = w;
          v11 = adler32;
          if ( z->state->nowrap )
            v11 = 0;
          v12 = j_inflate_blocks_new((z_streamp_0)z, v11, 1 << w);
          z->state->blocks = (inflate_blocks_statef_0 *)v12;
          v13 = z->state;
          if ( v12 )
          {
            v6 = 0;
            if ( v13 )
            {
              z->total_in = 0;
              z->total_out = 0;
              z->msg = 0;
              nowrap = v13->nowrap;
              if ( nowrap )
                nowrap = 7;
              v13->mode = nowrap;
              j_inflate_blocks_reset((inflate_blocks_statef *)z->state->blocks, (z_streamp_0)z, 0);
            }
            return v6;
          }
          if ( v13 )
          {
            zfree = z->zfree;
            if ( zfree )
            {
              blocks = (inflate_blocks_statef *)v13->blocks;
              if ( blocks )
              {
                j_inflate_blocks_free(blocks, (z_streamp_0)z);
                v13 = z->state;
                zfree = z->zfree;
              }
              zfree(z->opaque, v13);
              v6 = -4;
              z->state = 0;
              return v6;
            }
          }
          return -4;
        }
        if ( state )
        {
          v15 = z->zfree;
          if ( v15 )
          {
            v16 = (inflate_blocks_statef *)state->blocks;
            if ( v16 )
            {
              j_inflate_blocks_free(v16, (z_streamp_0)z);
              state = z->state;
              v15 = z->zfree;
            }
            v15(z->opaque, state);
            v6 = -2;
            z->state = 0;
            return v6;
          }
        }
      }
      return -2;
    }
  }
  return v6;
}

//----- (0020E920) --------------------------------------------------------
int __fastcall inflateInit_(z_streamp_1 z, const unsigned __int8 *version, int stream_size)
{
  return inflateInit2_(z, 15, version, stream_size);
}

//----- (0020E928) --------------------------------------------------------
int __fastcall inflate(z_streamp_1 z, int f)
{
  internal_state_1 *state; // r3
  bool v4; // zf
  unsigned int v5; // r12
  int v6; // r9
  int v7; // r2
  int result; // r0
  uInt avail_in; // r1
  Bytef *next_in; // r0
  uLong v11; // r2
  uInt v12; // r1
  internal_state_1 *v13; // r0
  char *v14; // r1
  unsigned int v15; // r5
  int v16; // r1
  internal_state_1 *v17; // r0
  uInt v18; // r1
  Bytef *v19; // r2
  internal_state_1 *v20; // r0
  uLong v21; // r3
  int v22; // r1
  internal_state_1 *v23; // r0
  uInt v24; // r1
  Bytef *v25; // r0
  internal_state_1 *v26; // r3
  uLong v27; // r2
  uInt v28; // r1
  Bytef *v29; // r0
  internal_state_1 *v30; // r3
  uLong v31; // r2
  uInt v32; // r1
  Bytef *v33; // r0
  internal_state_1 *v34; // r3
  uLong v35; // r2
  uInt v36; // r1
  Bytef *v37; // r0
  internal_state_1 *v38; // r3
  uLong v39; // r2
  internal_state_1 *v40; // r0
  internal_state_1 *v41; // r0
  uInt v42; // r1
  Bytef *v43; // r0
  internal_state_1 *v44; // r3
  uLong v45; // r2
  uInt v46; // r1
  Bytef *v47; // r0
  internal_state_1 *v48; // r3
  uLong v49; // r2
  uInt v50; // r1
  Bytef *v51; // r0
  internal_state_1 *v52; // r3
  uLong v53; // r2
  uInt v54; // r1
  Bytef *v55; // r0
  internal_state_1 *v56; // r3
  uLong v57; // r2
  internal_state_1 *v58; // r0

  if ( !z )
    return -2;
  state = z->state;
  v4 = state == 0;
  if ( state )
    v4 = z->next_in == 0;
  if ( v4 )
    return -2;
  LOWORD(v5) = 4229;
  v6 = 0;
  if ( f == 4 )
    v6 = -5;
  v7 = -5;
  HIWORD(v5) = 2114;
  while ( 2 )
  {
    result = 1;
    switch ( state->mode )
    {
      case METHOD:
        avail_in = z->avail_in;
        result = v7;
        if ( !avail_in )
          return result;
        next_in = z->next_in;
        v11 = z->total_in + 1;
        ++z->next_in;
        z->avail_in = avail_in - 1;
        z->total_in = v11;
        v12 = *next_in;
        state->sub.method = v12;
        v13 = z->state;
        if ( (v12 & 0xF) != 8 )
        {
          v13->mode = BAD_0;
          v14 = "unknown compression method";
          goto LABEL_25;
        }
        if ( (v13->sub.method >> 4) + 8 > v13->wbits )
        {
          v13->mode = BAD_0;
          v14 = "invalid window size";
          goto LABEL_25;
        }
        v7 = v6;
        v13->mode = FLAG;
LABEL_22:
        v18 = z->avail_in;
        result = v7;
        if ( !v18 )
          return result;
        v19 = z->next_in;
        v20 = z->state;
        v21 = z->total_in + 1;
        ++z->next_in;
        z->avail_in = v18 - 1;
        z->total_in = v21;
        v22 = *v19;
        if ( (v22 | (v20->sub.method << 8)) != 31
                                             * ((unsigned int)((((v22 | (v20->sub.method << 8)) * (unsigned __int64)v5) >> 32)
                                                             + ((unsigned int)((v22 | (v20->sub.method << 8))
                                                                             - (((v22 | (v20->sub.method << 8))
                                                                               * (unsigned __int64)v5) >> 32)) >> 1)) >> 4) )
        {
          v20->mode = BAD_0;
          v14 = "incorrect header check";
LABEL_25:
          v23 = z->state;
          z->msg = (unsigned __int8 *)v14;
LABEL_38:
          v23->sub.method = 5;
LABEL_8:
          state = z->state;
          v7 = v6;
          continue;
        }
        if ( (v22 & 0x20) == 0 )
        {
          v20->mode = BLOCKS;
          goto LABEL_8;
        }
        v20->mode = DICT4;
        result = v6;
LABEL_52:
        v42 = z->avail_in;
        if ( v42 )
        {
          v43 = z->next_in;
          v44 = z->state;
          v45 = z->total_in + 1;
          ++z->next_in;
          z->avail_in = v42 - 1;
          z->total_in = v45;
          v44->sub.check.need = *v43 << 24;
          z->state->mode = DICT3;
          result = v6;
LABEL_54:
          v46 = z->avail_in;
          if ( v46 )
          {
            v47 = z->next_in;
            v48 = z->state;
            v49 = z->total_in + 1;
            ++z->next_in;
            z->avail_in = v46 - 1;
            z->total_in = v49;
            v48->sub.check.need += *v47 << 16;
            z->state->mode = DICT2;
            result = v6;
LABEL_56:
            v50 = z->avail_in;
            if ( v50 )
            {
              v51 = z->next_in;
              v52 = z->state;
              v53 = z->total_in + 1;
              ++z->next_in;
              z->avail_in = v50 - 1;
              z->total_in = v53;
              v52->sub.check.need += *v51 << 8;
              z->state->mode = DICT1;
              result = v6;
LABEL_58:
              v54 = z->avail_in;
              if ( v54 )
              {
                v55 = z->next_in;
                v56 = z->state;
                v57 = z->total_in + 1;
                ++z->next_in;
                z->avail_in = v54 - 1;
                z->total_in = v57;
                v56->sub.check.need += *v55;
                v58 = z->state;
                z->adler = v58->sub.check.need;
                v58->mode = DICT0;
                return 2;
              }
            }
          }
        }
        return result;
      case FLAG:
        goto LABEL_22;
      case DICT4:
        result = v7;
        goto LABEL_52;
      case DICT3:
        result = v7;
        goto LABEL_54;
      case DICT2:
        result = v7;
        goto LABEL_56;
      case DICT1:
        result = v7;
        goto LABEL_58;
      case DICT0:
        state->mode = BAD_0;
        v41 = z->state;
        z->msg = "need dictionary";
        v41->sub.method = 0;
        return -2;
      case BLOCKS:
        v15 = v5;
        v16 = j_inflate_blocks((inflate_blocks_statef *)state->blocks, (z_streamp_0)z, v7);
        if ( v16 == -3 )
        {
          v7 = -3;
          z->state->mode = BAD_0;
          z->state->sub.method = 0;
          goto LABEL_20;
        }
        if ( v16 != 1 )
        {
          result = v6;
          if ( v16 )
            return v16;
          return result;
        }
        j_inflate_blocks_reset((inflate_blocks_statef *)z->state->blocks, (z_streamp_0)z, &z->state->sub.method);
        v17 = z->state;
        if ( v17->nowrap )
        {
          v7 = v6;
          v17->mode = DONE_0;
LABEL_20:
          state = z->state;
          v5 = v15;
          continue;
        }
        v7 = v6;
        v5 = v15;
        v17->mode = CHECK4;
LABEL_29:
        v24 = z->avail_in;
        result = v7;
        if ( !v24 )
          return result;
        v25 = z->next_in;
        v26 = z->state;
        v27 = z->total_in + 1;
        ++z->next_in;
        z->avail_in = v24 - 1;
        z->total_in = v27;
        v7 = v6;
        v26->sub.check.need = *v25 << 24;
        z->state->mode = CHECK3;
LABEL_31:
        v28 = z->avail_in;
        result = v7;
        if ( !v28 )
          return result;
        v29 = z->next_in;
        v30 = z->state;
        v31 = z->total_in + 1;
        ++z->next_in;
        z->avail_in = v28 - 1;
        z->total_in = v31;
        v7 = v6;
        v30->sub.check.need += *v29 << 16;
        z->state->mode = CHECK2;
LABEL_33:
        v32 = z->avail_in;
        result = v7;
        if ( !v32 )
          return result;
        v33 = z->next_in;
        v34 = z->state;
        v35 = z->total_in + 1;
        ++z->next_in;
        z->avail_in = v32 - 1;
        z->total_in = v35;
        v7 = v6;
        v34->sub.check.need += *v33 << 8;
        z->state->mode = CHECK1;
LABEL_35:
        v36 = z->avail_in;
        result = v7;
        if ( !v36 )
          return result;
        v37 = z->next_in;
        v38 = z->state;
        v39 = z->total_in + 1;
        ++z->next_in;
        z->avail_in = v36 - 1;
        z->total_in = v39;
        v38->sub.check.need += *v37;
        v40 = z->state;
        if ( v40->sub.method == v40->sub.check.need )
        {
          v40->mode = DONE_0;
          return 1;
        }
        v40->mode = BAD_0;
        v23 = z->state;
        z->msg = "incorrect data check";
        goto LABEL_38;
      case CHECK4:
        goto LABEL_29;
      case CHECK3:
        goto LABEL_31;
      case CHECK2:
        goto LABEL_33;
      case CHECK1:
        goto LABEL_35;
      case DONE_0:
        return result;
      case BAD_0:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (0020ECB4) --------------------------------------------------------
int __fastcall inflateSetDictionary(z_streamp_1 z, const Bytef *dictionary, uInt dictLength)
{
  z_streamp_1 v3; // r4
  bool v4; // zf
  const Bytef *v6; // r5
  internal_state_1 *state; // r0
  inflate_blocks_statef *blocks; // r0
  char v9; // r1
  uInt v10; // r1
  uInt v11; // r2

  v3 = z;
  v4 = z == 0;
  if ( z )
  {
    z = (z_streamp_1)z->state;
    v4 = z == 0;
  }
  v6 = dictionary;
  if ( v4 || z->next_in != (Bytef *)&byte_6 )
    return -2;
  if ( j_adler32(1u, dictionary, dictLength) != v3->adler )
    return -3;
  state = v3->state;
  v3->adler = 1;
  v9 = *(_QWORD *)&state->wbits;
  blocks = (inflate_blocks_statef *)state->blocks;
  v10 = 1 << v9;
  v11 = v10 - 1;
  if ( v10 > dictLength )
    v11 = dictLength;
  else
    v6 += dictLength - (v10 - 1);
  j_inflate_set_dictionary(blocks, v6, v11);
  v3->state->mode = BLOCKS;
  return 0;
}
// 6: using guessed type char byte_6;

//----- (0020ED28) --------------------------------------------------------
int __fastcall inflateSync(z_streamp_1 z)
{
  z_stream *v1; // r4
  bool v2; // zf
  uInt avail_in; // r3
  internal_state *state; // r12
  Bytef *next_in; // lr
  unsigned int dummy; // r2
  Bytef *v7; // r1
  int v8; // r5
  unsigned int v9; // r5
  uInt v10; // r5
  internal_state *v12; // r1
  internal_state *v13; // r0
  uLong total_in; // r5
  uLong total_out; // r6
  int v16; // r0

  v1 = (z_stream *)z;
  v2 = z == 0;
  if ( z )
  {
    z = (z_streamp_1)z->state;
    v2 = z == 0;
  }
  if ( v2 )
    return -2;
  if ( z->next_in != (Bytef *)&byte_9[4] )
  {
    z->next_in = (Bytef *)(byte_9 + 4);
    v1->state[1].dummy = 0;
  }
  avail_in = v1->avail_in;
  if ( !avail_in )
    return -5;
  state = v1->state;
  next_in = v1->next_in;
  dummy = state[1].dummy;
  if ( dummy > 3 )
  {
    v7 = v1->next_in;
    v10 = v1->avail_in;
  }
  else
  {
    v7 = v1->next_in;
    do
    {
      v8 = *v7;
      if ( v8 == inflateSync_mark[dummy] )
      {
        ++dummy;
      }
      else
      {
        v2 = v8 == 0;
        v9 = 0;
        if ( v2 )
          v9 = 4 - dummy;
        dummy = v9;
      }
      v10 = avail_in - 1;
      ++v7;
      if ( dummy > 3 )
        break;
      --avail_in;
    }
    while ( avail_in );
  }
  v1->next_in = v7;
  v1->avail_in = v10;
  v1->total_in += v7 - next_in;
  state[1].dummy = dummy;
  if ( dummy != 4 )
    return -3;
  v12 = v1->state;
  v13 = 0;
  total_in = v1->total_in;
  total_out = v1->total_out;
  if ( v12 )
  {
    v1->total_in = 0;
    v1->total_out = 0;
    v1->msg = 0;
    v16 = v12[3].dummy;
    if ( v16 )
      v16 = 7;
    v12->dummy = v16;
    j_inflate_blocks_reset((inflate_blocks_statef *)v1->state[5].dummy, v1, 0);
    v13 = v1->state;
  }
  v1->total_out = total_out;
  v1->total_in = total_in;
  v13->dummy = 7;
  return 0;
}

//----- (0020EE04) --------------------------------------------------------
int __fastcall inflateSyncPoint(z_streamp_1 z)
{
  bool v1; // zf
  inflate_blocks_statef *total_out; // r0

  v1 = z == 0;
  if ( z )
  {
    z = (z_streamp_1)z->state;
    v1 = z == 0;
  }
  if ( v1 )
    return -2;
  total_out = (inflate_blocks_statef *)z->total_out;
  if ( !total_out )
    return -2;
  else
    return sub_18B340(total_out);
}

//----- (0020EE20) --------------------------------------------------------
int __fastcall inflate_trees_bits(uIntf *c, uIntf *bb, inflate_huft **tb, inflate_huft *hp, int a5)
{
  uIntf *v9; // r0
  uIntf *v10; // r4
  int v11; // r6
  const char *v12; // r0
  uInt hn[8]; // [sp+18h] [bp-20h] BYREF

  hn[0] = 0;
  v9 = (uIntf *)(*(int (__fastcall **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  v10 = v9;
  if ( v9 )
  {
    v11 = huft_build(c, 0x13u, 0x13u, 0, 0, tb, bb, hp, hn, v9);
    if ( v11 != -5 )
    {
      if ( v11 == -3 )
      {
        v12 = "oversubscribed dynamic bit lengths tree";
LABEL_8:
        v11 = -3;
        *(_DWORD *)(a5 + 24) = v12;
        goto LABEL_9;
      }
      if ( *bb )
      {
LABEL_9:
        (*(void (__fastcall **)(_DWORD, uIntf *))(a5 + 36))(*(_DWORD *)(a5 + 40), v10);
        return v11;
      }
    }
    v12 = "incomplete dynamic bit lengths tree";
    goto LABEL_8;
  }
  return -4;
}
// 20EE20: using guessed type uInt var_20[8];

//----- (0020EEEC) --------------------------------------------------------
int __fastcall huft_build(
        uIntf *b,
        uInt n,
        uInt s,
        const uIntf *d,
        const uIntf *e,
        inflate_huft **t,
        uIntf *m,
        inflate_huft *hp,
        uInt *hn,
        uIntf *v)
{
  uIntf *v11; // lr
  int *v12; // r8
  int v13; // r3
  uIntf v14; // r6
  int v15; // r1
  uIntf v16; // r11
  unsigned int v17; // r6
  unsigned int v18; // r9
  int v19; // r5
  unsigned int v20; // r4
  unsigned int v21; // r3
  int v22; // r6
  unsigned int v23; // r5
  int *v24; // r3
  int v25; // r4
  int v26; // t1
  uInt v27; // r4
  uIntf v28; // r3
  int v29; // r6
  int v30; // r0
  signed int v31; // r5
  int v32; // r1
  int v33; // r0
  int v34; // r9
  int v35; // r8
  unsigned int v36; // r12
  int *v37; // r0
  inflate_huft *v38; // r3
  unsigned int v39; // r1
  uIntf v40; // r0
  uIntf v41; // r6
  int v42; // r2
  uIntf v43; // lr
  uIntf v44; // r3
  unsigned int v45; // r0
  bool v46; // cf
  int v47; // r4
  _DWORD *v48; // r0
  uInt v49; // r4
  int v50; // r11
  unsigned int v51; // r4
  int v52; // r0
  int v53; // r6
  unsigned int *v54; // r8
  unsigned int v55; // r0
  uIntf v56; // lr
  int **v57; // r6
  unsigned int v58; // r0
  unsigned int v59; // r4
  inflate_huft *v60; // r0
  unsigned int v61; // r6
  unsigned int v62; // r0
  bool v63; // zf
  int v64; // r0
  bool v65; // cc
  int v67; // [sp+8h] [bp-110h]
  int v68; // [sp+Ch] [bp-10Ch]
  uIntf *v69; // [sp+10h] [bp-108h]
  int v70; // [sp+14h] [bp-104h]
  const uIntf *v71; // [sp+18h] [bp-100h]
  int *v73; // [sp+20h] [bp-F8h]
  unsigned int *v74; // [sp+24h] [bp-F4h]
  char *v75; // [sp+28h] [bp-F0h]
  signed int v76; // [sp+2Ch] [bp-ECh]
  uIntf v77; // [sp+30h] [bp-E8h]
  unsigned int v78; // [sp+34h] [bp-E4h]
  signed int v79; // [sp+34h] [bp-E4h]
  unsigned int v80; // [sp+38h] [bp-E0h]
  int v81[2]; // [sp+3Ch] [bp-DCh] BYREF
  int v82; // [sp+44h] [bp-D4h] BYREF
  int v83[15]; // [sp+7Ch] [bp-9Ch]
  __int64 v84; // [sp+B8h] [bp-60h] BYREF
  __int64 v85; // [sp+C0h] [bp-58h]
  __int64 v86; // [sp+C8h] [bp-50h]
  __int64 v87; // [sp+D0h] [bp-48h]
  __int64 v88; // [sp+D8h] [bp-40h]
  __int64 v89; // [sp+E0h] [bp-38h]
  __int64 v90; // [sp+E8h] [bp-30h]
  __int64 v91; // [sp+F0h] [bp-28h]

  v11 = v;
  v12 = (int *)&v84 + 1;
  v90 = 0LL;
  v91 = 0LL;
  v88 = 0LL;
  v89 = 0LL;
  v84 = 0LL;
  v85 = 0LL;
  v86 = 0LL;
  v87 = 0LL;
  v13 = 0;
  do
  {
    v14 = b[v13++];
    ++*((_DWORD *)&v84 + v14);
  }
  while ( n != v13 );
  if ( (_DWORD)v84 == n )
  {
    v15 = 0;
    *t = 0;
    *m = 0;
    return v15;
  }
  v16 = *m;
  v71 = d;
  if ( HIDWORD(v84) )
  {
    v17 = 1;
    goto LABEL_34;
  }
  if ( (_DWORD)v85 )
  {
    v17 = 2;
    goto LABEL_34;
  }
  if ( HIDWORD(v85) )
  {
    v17 = 3;
    goto LABEL_34;
  }
  if ( (_DWORD)v86 )
  {
    v17 = 4;
    goto LABEL_34;
  }
  if ( HIDWORD(v86) )
  {
    v17 = 5;
    goto LABEL_34;
  }
  if ( (_DWORD)v87 )
  {
    v17 = 6;
    goto LABEL_34;
  }
  if ( HIDWORD(v87) )
  {
    v17 = 7;
    goto LABEL_34;
  }
  if ( (_DWORD)v88 )
  {
    v17 = 8;
    goto LABEL_34;
  }
  if ( HIDWORD(v88) )
  {
    v17 = 9;
    goto LABEL_34;
  }
  if ( (_DWORD)v89 )
  {
    v17 = 10;
LABEL_33:
    v11 = v;
LABEL_34:
    if ( v16 < v17 )
      v16 = v17;
    if ( HIDWORD(v91) )
    {
      v18 = 15;
      if ( v16 >= 0xF )
        v16 = 15;
      *m = v16;
      v19 = 1 << v17;
      v20 = v17;
      goto LABEL_76;
    }
    goto LABEL_46;
  }
  if ( HIDWORD(v89) )
  {
    v17 = 11;
    goto LABEL_33;
  }
  if ( (_DWORD)v90 )
  {
    v17 = 12;
    goto LABEL_33;
  }
  if ( HIDWORD(v90) )
  {
    v17 = 13;
    goto LABEL_33;
  }
  if ( (_DWORD)v91 )
  {
    v17 = 14;
    goto LABEL_33;
  }
  if ( HIDWORD(v91) )
  {
    v17 = 15;
    if ( v16 <= 0xF )
      v16 = 15;
    v18 = 15;
    goto LABEL_139;
  }
  v11 = v;
  v17 = 16;
  if ( v16 <= 0x10 )
    v16 = 16;
LABEL_46:
  if ( (_DWORD)v91 )
  {
    v18 = 14;
    goto LABEL_73;
  }
  if ( HIDWORD(v90) )
  {
    v18 = 13;
    goto LABEL_73;
  }
  if ( (_DWORD)v90 )
  {
    v18 = 12;
    goto LABEL_73;
  }
  if ( HIDWORD(v89) )
  {
    v18 = 11;
    goto LABEL_73;
  }
  if ( (_DWORD)v89 )
  {
    v18 = 10;
    goto LABEL_73;
  }
  if ( HIDWORD(v88) )
  {
    v18 = 9;
    goto LABEL_73;
  }
  if ( (_DWORD)v88 )
  {
    v18 = 8;
    goto LABEL_73;
  }
  if ( HIDWORD(v87) )
  {
    v18 = 7;
    goto LABEL_73;
  }
  if ( !(_DWORD)v87 )
  {
    if ( HIDWORD(v86) )
    {
      v18 = 5;
      goto LABEL_72;
    }
    if ( (_DWORD)v86 )
    {
      v18 = 4;
      goto LABEL_72;
    }
    if ( HIDWORD(v85) )
    {
      v18 = 3;
      goto LABEL_72;
    }
    if ( (_DWORD)v85 )
    {
      v18 = 2;
      goto LABEL_72;
    }
    v18 = HIDWORD(v84) != 0;
LABEL_139:
    if ( v16 > v18 )
      v16 = v18;
    v20 = v17;
    *m = v16;
    v19 = 1 << v17;
    v11 = v;
    goto LABEL_79;
  }
  v18 = 6;
LABEL_72:
  v11 = v;
LABEL_73:
  v20 = v17;
  if ( v16 > v18 )
    v16 = v18;
  v19 = 1 << v17;
  *m = v16;
  if ( v17 < v18 )
  {
LABEL_76:
    v21 = v20;
    do
    {
      v22 = v19 - *((_DWORD *)&v84 + v21);
      if ( v22 < 0 )
        return -3;
      ++v21;
      v19 = 2 * v22;
    }
    while ( v21 < v18 );
  }
LABEL_79:
  if ( v19 - *((_DWORD *)&v84 + v18) < 0 )
    return -3;
  v67 = v19 - *((_DWORD *)&v84 + v18);
  v78 = v20;
  *((_DWORD *)&v84 + v18) = v19;
  v81[1] = 0;
  if ( v18 != 1 )
  {
    v23 = 1 - v18;
    v24 = &v82;
    v25 = 0;
    do
    {
      v26 = *v12++;
      ++v23;
      v25 += v26;
      *v24++ = v25;
    }
    while ( v23 );
  }
  v27 = 0;
  do
  {
    v28 = b[v27];
    if ( v28 )
    {
      v29 = v81[v28];
      v81[v28] = v29 + 1;
      v11[v29] = v27;
    }
    ++v27;
  }
  while ( v27 < n );
  v30 = v81[v18];
  v31 = v78;
  v74 = v11;
  v81[0] = 0;
  v83[0] = 0;
  v76 = v18;
  if ( v78 <= v18 )
  {
    v34 = -v16;
    v35 = -1;
    v36 = 0;
    v69 = &v[v30];
    v75 = (char *)&v84 + 4 * v78 + 4;
    v37 = v81;
    v38 = 0;
    v39 = 0;
    v68 = -v16;
    v77 = v16;
    do
    {
      v73 = v37;
      v80 = *((_DWORD *)&v84 + v31);
      if ( v80 )
      {
        v79 = v31;
        v70 = 1 << (v31 - 1);
        do
        {
          v40 = v34 + v16;
          if ( v31 <= (int)(v34 + v16) )
          {
            v50 = v35;
            v42 = v34;
          }
          else
          {
            while ( 2 )
            {
              v41 = v77;
              while ( 1 )
              {
                v42 = v40;
                v43 = v31 - v40;
                v44 = v76 - v40;
                v45 = 1 << (v31 - v40);
                if ( v44 > v41 )
                  v44 = v41;
                if ( v45 > v80 )
                {
                  v46 = v43 >= v44;
                  if ( v43 < v44 )
                    v46 = ++v43 >= v44;
                  if ( !v46 )
                  {
                    v47 = v45 - v80;
                    v48 = v75;
                    do
                    {
                      if ( (unsigned int)(2 * v47) <= *v48 )
                        break;
                      ++v43;
                      v47 = 2 * v47 - *v48++;
                    }
                    while ( v43 < v44 );
                  }
                }
                v36 = 1 << v43;
                v49 = *hn + (1 << v43);
                if ( v49 > 0x5A0 )
                  return -4;
                v50 = v35 + 1;
                v38 = &hp[*hn];
                v83[v35 + 1] = (int)v38;
                *hn = v49;
                if ( v35 != -1 )
                  break;
                v35 = 0;
                LOBYTE(v34) = v42;
                *t = v38;
                v41 = v77;
                v31 = v79;
                v40 = v42 + v77;
                if ( v79 <= (int)(v42 + v77) )
                {
                  v50 = 0;
                  goto LABEL_115;
                }
              }
              v51 = v39 >> v34;
              LOBYTE(v34) = v42;
              v81[v50] = v39;
              v52 = v83[v35++];
              v53 = v52 + 8 * v51;
              *(_BYTE *)v53 = v43;
              *(_BYTE *)(v53 + 1) = v77;
              v73 = (int *)((((int)v38 - v52) >> 3) - v51);
              *(_DWORD *)(v53 + 4) = v73;
              v40 = v42 + v77;
              v31 = v79;
              if ( v79 > (int)(v42 + v77) )
                continue;
              break;
            }
          }
LABEL_115:
          v54 = v74;
          if ( v74 >= v69 )
          {
            LOBYTE(v56) = -64;
          }
          else
          {
            v55 = *v74;
            if ( *v74 >= s )
            {
              v58 = v55 - s;
              v57 = (int **)&v71[v58];
              v56 = e[v58] + 80;
            }
            else
            {
              LOBYTE(v56) = 96;
              if ( v55 < 0x100 )
                LOBYTE(v56) = 0;
              v57 = (int **)v74;
            }
            v54 = v74 + 1;
            v73 = *v57;
          }
          v59 = v39 >> v42;
          --v80;
          if ( v39 >> v42 < v36 )
          {
            do
            {
              v38[v59].word.what.Exop = v56;
              v60 = &v38[v59];
              v59 += 1 << (v79 - v42);
              v60->word.what.Bits = v79 - v42;
              v60->base = (uInt)v73;
            }
            while ( v59 < v36 );
          }
          v61 = v70;
          v62 = v39;
          do
          {
            v39 = v61 ^ v62;
            v63 = (v61 & v62) == 0;
            v61 >>= 1;
            v62 = v39;
          }
          while ( !v63 );
          v31 = v79;
          v74 = v54;
          v35 = v50;
          if ( (((1 << v42) - 1) & v39) == v81[v50] )
          {
            v34 = v42;
            v16 = v77;
          }
          else
          {
            v16 = v77;
            do
            {
              v34 = v42 - v77;
              v64 = v81[--v35];
              v63 = (((1 << (v42 + v68)) - 1) & v39) == v64;
              v42 -= v77;
            }
            while ( !v63 );
          }
        }
        while ( v80 );
      }
      v75 += 4;
      v65 = v31++ < v76;
      v37 = v73;
    }
    while ( v65 );
  }
  v32 = v67;
  if ( v67 )
    v32 = -5;
  v33 = 0;
  if ( v76 != 1 )
    return v32;
  return v33;
}
// 20EEEC: using guessed type int var_9C[15];

//----- (0020F394) --------------------------------------------------------
int __fastcall inflate_trees_dynamic(
        uInt nl,
        uInt nd,
        uIntf *c,
        uIntf *bl,
        uIntf *bd,
        inflate_huft **tl,
        inflate_huft **td,
        inflate_huft *hp,
        z_streamp_0 z)
{
  uIntf *v; // r4
  int v14; // r0
  int v15; // r1
  int v16; // r5
  char *v17; // r0
  uInt hn[8]; // [sp+18h] [bp-20h] BYREF

  hn[0] = 0;
  v = (uIntf *)z->zalloc(z->opaque, 288, 4);
  if ( !v )
    return -4;
  v14 = huft_build(c, nl, 0x101u, cplens, cplext, tl, bl, hp, hn, v);
  if ( v14 == -4 )
  {
    v16 = -4;
  }
  else
  {
    if ( v14 == -3 )
    {
      v17 = "oversubscribed literal/length tree";
    }
    else
    {
      if ( !v14 && *bl )
      {
        v15 = huft_build(&c[nl], nd, 0, cpdist, cpdext, td, bd, hp, hn, v) + 5;
        v16 = -4;
        v17 = "incomplete distance tree";
        switch ( v15 )
        {
          case 0:
            goto LABEL_12;
          case 1:
            goto LABEL_13;
          case 2:
            v17 = "oversubscribed distance tree";
            goto LABEL_12;
          case 5:
            if ( nl >= 0x102 && !*bd )
              goto LABEL_17;
            z->zfree(z->opaque, v);
            return 0;
          default:
LABEL_17:
            v17 = "empty distance tree with lengths";
            goto LABEL_12;
        }
      }
      v17 = "incomplete literal/length tree";
    }
LABEL_12:
    v16 = -3;
    z->msg = (unsigned __int8 *)v17;
  }
LABEL_13:
  z->zfree(z->opaque, v);
  return v16;
}

//----- (0020F51C) --------------------------------------------------------
int __fastcall inflate_trees_fixed(uIntf *bl, uIntf *bd, inflate_huft **tl, inflate_huft **td, z_streamp_0 z)
{
  int result; // r0

  *bl = 9;
  *bd = 5;
  result = 0;
  *tl = fixed_tl;
  *td = fixed_td;
  return result;
}

//----- (0020F548) --------------------------------------------------------
int __fastcall inflate_flush(inflate_blocks_statef *s, z_streamp_0 z, int r)
{
  int v5; // r5
  Bytef **p_write; // r10
  Bytef *read; // r6
  bool v8; // cc
  Bytef **p_end; // r0
  __int64 v10; // kr00_8
  size_t avail_out; // r4
  __int64 v12; // r0
  Bytef *v13; // r3
  uLong v14; // r0
  Bytef *v15; // r0
  char *v16; // r8
  int v17; // r6
  Bytef *write; // r1
  Bytef *window; // r2
  Bytef *v20; // r10
  __int64 v21; // kr08_8
  size_t v22; // r4
  __int64 v23; // r0
  check_func checkfn; // r3
  uLong v25; // r0

  v5 = r;
  p_write = &s->write;
  read = s->read;
  v8 = read > s->write;
  p_end = &s->end;
  if ( !v8 )
    p_end = p_write;
  v10 = *(_QWORD *)&z->next_out;
  avail_out = *p_end - read;
  if ( avail_out > HIDWORD(v10) )
    avail_out = z->avail_out;
  LODWORD(v12) = HIDWORD(v10) - avail_out;
  HIDWORD(v12) = z->total_out + avail_out;
  *(_QWORD *)&z->avail_out = v12;
  if ( avail_out )
    v5 = 0;
  v13 = p_write[1];
  if ( r != -5 )
    v5 = r;
  if ( v13 )
  {
    v14 = ((int (__fastcall *)(uLong, Bytef *, size_t))v13)(s->check, read, avail_out);
    s->check = v14;
    z->adler = v14;
  }
  qmemcpy((void *)v10, read, avail_out);
  v15 = &read[avail_out];
  v16 = (char *)(v10 + avail_out);
  if ( &read[avail_out] == *(p_write - 2) )
  {
    write = s->write;
    v17 = v5;
    window = s->window;
    if ( write == v15 )
    {
      *p_write = window;
      write = window;
    }
    v20 = window;
    v21 = *(_QWORD *)&z->avail_out;
    v22 = write - window;
    if ( write - window > (unsigned int)v21 )
      v22 = z->avail_out;
    HIDWORD(v23) = HIDWORD(v21) + v22;
    LODWORD(v23) = v21 - v22;
    *(_QWORD *)&z->avail_out = v23;
    if ( v22 )
      v17 = 0;
    checkfn = s->checkfn;
    if ( v5 != -5 )
      v17 = v5;
    if ( checkfn )
    {
      v25 = checkfn(s->check, window, v22);
      s->check = v25;
      z->adler = v25;
    }
    qmemcpy(v16, v20, v22);
    v15 = &v20[v22];
    v16 += v22;
  }
  else
  {
    v17 = v5;
  }
  z->next_out = (Bytef *)v16;
  s->read = v15;
  return v17;
}

//----- (0020F63C) --------------------------------------------------------
void __fastcall tr_init(deflate_state_0 *s)
{
  s->bi_valid = 0;
  s->last_eob_len = 8;
  s->bi_buf = 0;
  s->l_desc.dyn_tree = s->dyn_ltree;
  s->l_desc.stat_desc = &static_l_desc;
  s->d_desc.dyn_tree = s->dyn_dtree;
  s->d_desc.stat_desc = &static_d_desc;
  s->bl_desc.dyn_tree = s->bl_tree;
  s->bl_desc.stat_desc = &static_bl_desc;
  init_block(s);
}

//----- (0020F69C) --------------------------------------------------------
void __fastcall init_block(deflate_state_0 *s)
{
  int i; // r3

  for ( i = 0; i != 286; ++i )
    s->dyn_ltree[i].fc.freq = 0;
  s->dyn_dtree[2].fc.freq = 0;
  s->dyn_dtree[1].fc.freq = 0;
  s->dyn_dtree[3].fc.freq = 0;
  s->dyn_dtree[4].fc.freq = 0;
  s->dyn_dtree[5].fc.freq = 0;
  s->dyn_dtree[6].fc.freq = 0;
  s->dyn_dtree[7].fc.freq = 0;
  s->dyn_dtree[8].fc.freq = 0;
  s->dyn_dtree[9].fc.freq = 0;
  s->dyn_dtree[10].fc.freq = 0;
  s->dyn_dtree[11].fc.freq = 0;
  s->dyn_dtree[12].fc.freq = 0;
  s->dyn_dtree[13].fc.freq = 0;
  s->dyn_dtree[14].fc.freq = 0;
  s->dyn_dtree[15].fc.freq = 0;
  s->dyn_dtree[16].fc.freq = 0;
  s->dyn_dtree[17].fc.freq = 0;
  s->dyn_dtree[18].fc.freq = 0;
  s->dyn_dtree[19].fc.freq = 0;
  s->dyn_dtree[0].fc.freq = 0;
  s->dyn_dtree[21].fc.freq = 0;
  s->dyn_dtree[20].fc.freq = 0;
  s->dyn_dtree[22].fc.freq = 0;
  s->dyn_dtree[23].fc.freq = 0;
  s->dyn_dtree[24].fc.freq = 0;
  s->dyn_dtree[25].fc.freq = 0;
  s->dyn_dtree[26].fc.freq = 0;
  s->dyn_dtree[27].fc.freq = 0;
  s->dyn_dtree[28].fc.freq = 0;
  s->dyn_dtree[29].fc.freq = 0;
  s->bl_tree[0].fc.freq = 0;
  s->bl_tree[2].fc.freq = 0;
  s->bl_tree[1].fc.freq = 0;
  s->bl_tree[3].fc.freq = 0;
  s->bl_tree[4].fc.freq = 0;
  s->bl_tree[5].fc.freq = 0;
  s->bl_tree[6].fc.freq = 0;
  s->bl_tree[7].fc.freq = 0;
  s->bl_tree[8].fc.freq = 0;
  s->bl_tree[9].fc.freq = 0;
  s->bl_tree[10].fc.freq = 0;
  s->bl_tree[11].fc.freq = 0;
  s->bl_tree[12].fc.freq = 0;
  s->bl_tree[13].fc.freq = 0;
  s->bl_tree[14].fc.freq = 0;
  s->bl_tree[15].fc.freq = 0;
  s->bl_tree[16].fc.freq = 0;
  s->bl_tree[17].fc.freq = 0;
  s->bl_tree[18].fc.freq = 0;
  s->opt_len = 0;
  s->static_len = 0;
  s->matches = 0;
  s->last_lit = 0;
  s->dyn_ltree[256].fc.freq = 1;
}

//----- (0020F796) --------------------------------------------------------
void __fastcall tr_stored_block(deflate_state_0 *s, charf *buf, ulg stored_len, int eof)
{
  int bi_valid; // r5
  int *p_bi_valid; // r12
  int v6; // r6
  ush *p_bi_buf; // lr
  int pending; // r5
  Bytef *pending_buf; // r8
  int v10; // r5
  Bytef *v11; // r8
  Bytef bi_buf_high; // r6
  int v13; // r3
  int v14; // r4
  Bytef *v15; // r3
  Bytef *v16; // r3
  int v17; // r4
  Bytef *v18; // r6
  int v19; // r5
  int v20; // r6
  Bytef *v21; // r3
  int v22; // r6
  Bytef *v23; // r3
  int v24; // r6
  Bytef *v25; // r3
  int v26; // r6
  Bytef *v27; // r3
  Bytef v28; // t1

  bi_valid = s->bi_valid;
  p_bi_valid = &s->bi_valid;
  v6 = s->bi_buf | (eof << bi_valid);
  s->bi_buf = v6;
  p_bi_buf = &s->bi_buf;
  if ( bi_valid < 14 )
  {
    v13 = bi_valid + 3;
  }
  else
  {
    pending = s->pending;
    pending_buf = s->pending_buf;
    s->pending = pending + 1;
    pending_buf[pending] = v6;
    v10 = s->pending;
    v11 = s->pending_buf;
    bi_buf_high = HIBYTE(s->bi_buf);
    s->pending = v10 + 1;
    v11[v10] = bi_buf_high;
    v6 = (unsigned __int16)eof >> (16 - *(_BYTE *)p_bi_valid);
    v13 = *p_bi_valid - 13;
    *p_bi_buf = v6;
  }
  *p_bi_valid = v13;
  if ( v13 < 9 )
  {
    if ( v13 < 1 )
      goto LABEL_9;
    v16 = s->pending_buf;
    v17 = s->pending;
  }
  else
  {
    v14 = s->pending;
    v15 = s->pending_buf;
    s->pending = v14 + 1;
    v15[v14] = v6;
    v16 = s->pending_buf;
    v17 = s->pending;
    LOBYTE(v6) = HIBYTE(s->bi_buf);
  }
  s->pending = v17 + 1;
  v16[v17] = v6;
LABEL_9:
  *p_bi_buf = 0;
  *p_bi_valid = 0;
  v18 = s->pending_buf;
  v19 = s->pending;
  s->last_eob_len = 8;
  s->pending = v19 + 1;
  v18[v19] = stored_len;
  v20 = s->pending;
  v21 = s->pending_buf;
  s->pending = v20 + 1;
  v21[v20] = BYTE1(stored_len);
  v22 = s->pending;
  v23 = s->pending_buf;
  s->pending = v22 + 1;
  v23[v22] = ~(_BYTE)stored_len;
  v24 = s->pending;
  v25 = s->pending_buf;
  s->pending = v24 + 1;
  for ( v25[v24] = (unsigned __int16)~(_WORD)stored_len >> 8; stored_len; v27[v26] = v28 )
  {
    v26 = s->pending;
    --stored_len;
    v27 = s->pending_buf;
    v28 = *buf++;
    s->pending = v26 + 1;
  }
}

//----- (0020F894) --------------------------------------------------------
void __fastcall tr_align(deflate_state_0 *s)
{
  int bi_valid; // r4
  int *p_bi_valid; // lr
  unsigned int v3; // r3
  ush *p_bi_buf; // r2
  int pending; // r4
  Bytef *pending_buf; // r1
  int v7; // r3
  Bytef *v8; // r1
  int v9; // r1
  int v10; // r5
  Bytef *v11; // r1
  Bytef *v12; // r1
  int v13; // r1
  int v14; // r5
  Bytef *v15; // r1
  Bytef *v16; // r1
  int v17; // r5
  Bytef *v18; // r1
  int *p_last_eob_len; // r12
  unsigned int v20; // r3
  int v21; // r5
  Bytef *v22; // r1
  int v23; // r3
  Bytef *v24; // r1
  int v25; // r1
  int v26; // r4
  Bytef *v27; // r1
  Bytef *v28; // r1
  int v29; // r1
  int v30; // r4
  Bytef *v31; // r1
  int v32; // r3
  Bytef *v33; // r1
  int v34; // r0
  int v35; // r4
  Bytef *v36; // r1

  bi_valid = s->bi_valid;
  p_bi_valid = &s->bi_valid;
  v3 = s->bi_buf | (2 << bi_valid);
  s->bi_buf = v3;
  p_bi_buf = &s->bi_buf;
  if ( bi_valid < 14 )
  {
    v9 = bi_valid + 3;
  }
  else
  {
    pending = s->pending;
    pending_buf = s->pending_buf;
    s->pending = pending + 1;
    pending_buf[pending] = v3;
    v7 = s->pending;
    v8 = s->pending_buf;
    LOBYTE(pending) = HIBYTE(s->bi_buf);
    s->pending = v7 + 1;
    v8[v7] = pending;
    v9 = *p_bi_valid - 13;
    v3 = 2u >> (16 - *p_bi_valid);
    *p_bi_buf = v3;
  }
  *p_bi_valid = v9;
  if ( v9 < 10 )
  {
    v13 = v9 + 7;
  }
  else
  {
    v10 = s->pending;
    v11 = s->pending_buf;
    s->pending = v10 + 1;
    v11[v10] = v3;
    v3 = s->pending;
    v12 = s->pending_buf;
    LOBYTE(v10) = HIBYTE(s->bi_buf);
    s->pending = v3 + 1;
    v12[v3] = v10;
    LOWORD(v3) = 0;
    *p_bi_buf = 0;
    v13 = *p_bi_valid - 9;
  }
  *p_bi_valid = v13;
  if ( v13 == 16 )
  {
    v14 = s->pending;
    v15 = s->pending_buf;
    s->pending = v14 + 1;
    v15[v14] = v3;
    v3 = s->pending;
    v16 = s->pending_buf;
    LOBYTE(v14) = HIBYTE(s->bi_buf);
    s->pending = v3 + 1;
    v16[v3] = v14;
    LOWORD(v3) = 0;
    v13 = 0;
    *p_bi_buf = 0;
  }
  else
  {
    if ( v13 < 8 )
      goto LABEL_12;
    v17 = s->pending;
    v18 = s->pending_buf;
    s->pending = v17 + 1;
    v18[v17] = v3;
    v3 = HIBYTE(*p_bi_buf);
    *p_bi_buf = v3;
    v13 = *p_bi_valid - 8;
  }
  *p_bi_valid = v13;
LABEL_12:
  p_last_eob_len = &s->last_eob_len;
  if ( s->last_eob_len + 11 - v13 <= 8 )
  {
    v20 = (unsigned __int16)v3 | (2 << v13);
    *p_bi_buf = v20;
    if ( v13 < 14 )
    {
      v25 = v13 + 3;
    }
    else
    {
      v21 = s->pending;
      v22 = s->pending_buf;
      s->pending = v21 + 1;
      v22[v21] = v20;
      v23 = s->pending;
      v24 = s->pending_buf;
      LOBYTE(v21) = HIBYTE(s->bi_buf);
      s->pending = v23 + 1;
      v24[v23] = v21;
      v25 = *p_bi_valid - 13;
      v20 = 2u >> (16 - *p_bi_valid);
      *p_bi_buf = v20;
    }
    *p_bi_valid = v25;
    if ( v25 < 10 )
    {
      v29 = v25 + 7;
    }
    else
    {
      v26 = s->pending;
      v27 = s->pending_buf;
      s->pending = v26 + 1;
      v27[v26] = v20;
      v20 = s->pending;
      v28 = s->pending_buf;
      LOBYTE(v26) = HIBYTE(s->bi_buf);
      s->pending = v20 + 1;
      v28[v20] = v26;
      LOBYTE(v20) = 0;
      *p_bi_buf = 0;
      v29 = *p_bi_valid - 9;
    }
    *p_bi_valid = v29;
    if ( v29 == 16 )
    {
      v30 = s->pending;
      v31 = s->pending_buf;
      s->pending = v30 + 1;
      v31[v30] = v20;
      v32 = s->pending;
      v33 = s->pending_buf;
      LOBYTE(v30) = HIBYTE(s->bi_buf);
      s->pending = v32 + 1;
      v34 = 0;
      v33[v32] = v30;
      *p_bi_buf = 0;
LABEL_23:
      *p_bi_valid = v34;
      goto LABEL_24;
    }
    if ( v29 >= 8 )
    {
      v35 = s->pending;
      v36 = s->pending_buf;
      s->pending = v35 + 1;
      v36[v35] = v20;
      s->bi_buf = HIBYTE(s->bi_buf);
      v34 = *p_bi_valid - 8;
      goto LABEL_23;
    }
  }
LABEL_24:
  *p_last_eob_len = 7;
}

//----- (0020FA20) --------------------------------------------------------
void __fastcall tr_flush_block(deflate_state_0 *s, charf *buf, ulg stored_len, int eof)
{
  deflate_state_0 *v4; // r10
  int v5; // r4
  int8x16_t v7; // q8
  int i; // r1
  ct_data_s *v9; // r2
  unsigned __int64 v10; // d18
  int v11; // r1
  int v12; // r5
  int32x4_t v13; // q8
  unsigned __int32 v14; // r0
  int8x16_t v15; // q8
  unsigned int v16; // r0
  const __int16 *v17; // r2
  unsigned __int64 v18; // d18
  int32x4_t v19; // q8
  int max_code; // r1
  int dad; // r4
  int v22; // r6
  int v23; // r8
  int v24; // r5
  int v25; // r12
  ct_data_s *v26; // r0
  bool v27; // cc
  int v28; // r0
  z_streamp *v29; // r2
  int v30; // r2
  int v31; // r1
  int v32; // r6
  int v33; // r2
  int v34; // r5
  int v35; // r8
  int v36; // r0
  ct_data_s *v37; // r0
  int v38; // r3
  int v39; // r4
  int v40; // r12
  ulg v41; // r0
  unsigned int v42; // r2
  ulg static_len; // r2
  int v44; // r1
  unsigned int v45; // r1
  int *p_bi_valid; // lr
  int bi_valid; // r1
  int v48; // r2
  int pending; // r6
  Bytef *pending_buf; // r3
  int v51; // r3
  Bytef *v52; // r2
  int v53; // r2
  int v54; // r0
  int v55; // r0
  ush *p_bi_buf; // r11
  int v57; // r3
  Bytef *v58; // r1
  int v59; // r1
  Bytef *v60; // r0
  int v61; // r1
  int v62; // r2
  int v63; // r6
  int v64; // r0
  int v65; // r3
  Bytef *v66; // r1
  int v67; // r1
  Bytef *v68; // r0
  int v69; // r1
  int v70; // r0
  int v71; // r3
  Bytef *v72; // r1
  int v73; // r1
  Bytef *v74; // r0
  int v75; // r1
  int v76; // r5
  deflate_state_0 *v77; // r9
  Bytef **p_pending_buf; // r10
  Bytef *v79; // t1
  Bytef *v80; // r1
  int *p_pending; // r8
  Bytef *v82; // r1
  Bytef *v83; // r0
  Bytef v84; // r3
  int v85; // r1
  int v86; // r0
  const uch *v87; // r6
  unsigned int v88; // r3
  int v89; // r4
  Bytef *v90; // r12
  int v91; // r5
  Bytef *v92; // r12
  int v93; // r1
  int v94; // r2
  Bytef *v95; // r1
  Bytef bi_buf; // r3
  int v97; // r1
  Bytef *v98; // r2
  int v99; // r3
  Bytef v100; // r1
  charf *v101; // [sp+Ch] [bp-24h]
  charf *v102; // [sp+Ch] [bp-24h]
  int v104; // [sp+10h] [bp-20h]

  v4 = s;
  v5 = eof;
  if ( s->level < 1 )
  {
    v41 = stored_len + 5;
    v40 = 0;
    v42 = stored_len + 5;
    if ( !buf )
      goto LABEL_86;
    goto LABEL_84;
  }
  v101 = buf;
  if ( s->data_type == 2 )
  {
    v7 = 0uLL;
    for ( i = 0; i != 120; i += 4 )
    {
      v9 = &s->dyn_ltree[i + 7];
      v10 = (unsigned __int64)vld2_s16((const __int16 *)v9);
      v7 = vaddw_u16(v7, (uint16x4_t)v10);
    }
    v11 = s->dyn_ltree[1].fc.freq + s->dyn_ltree[0].fc.freq + s->dyn_ltree[2].fc.freq;
    v12 = 0;
    v13 = vaddq_s32(v7, vextq_s8(v7, v7, 8u));
    v14 = vaddq_s32(v13, vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 1)).n128_u32[0];
    v15 = vdupq_n_s32(0);
    v15.n128_u32[0] = v11
                    + v4->dyn_ltree[3].fc.freq
                    + v4->dyn_ltree[4].fc.freq
                    + v4->dyn_ltree[5].fc.freq
                    + v4->dyn_ltree[6].fc.freq;
    v16 = (v14 + v4->dyn_ltree[127].fc.freq) >> 2;
    do
    {
      v17 = (const __int16 *)&v4->dyn_ltree[v12 + 128];
      v12 += 4;
      v18 = (unsigned __int64)vld2_s16(v17);
      v15 = vaddw_u16(v15, (uint16x4_t)v18);
    }
    while ( v12 != 124 );
    v19 = vaddq_s32(v15, vextq_s8(v15, v15, 8u));
    v4->data_type = vaddq_s32(v19, vdupq_lane_s32((int32x2_t)v19.n128_u64[0], 1)).n128_u32[0]
                  + v4->dyn_ltree[252].fc.freq
                  + v4->dyn_ltree[253].fc.freq
                  + v4->dyn_ltree[254].fc.freq
                  + v4->dyn_ltree[255].fc.freq <= v16;
  }
  build_tree(v4, &v4->l_desc);
  build_tree(v4, &v4->d_desc);
  max_code = v4->l_desc.max_code;
  dad = v4->dyn_ltree[0].dl.dad;
  v22 = 4;
  v23 = 7;
  v24 = 0;
  v25 = -1;
  v4->dyn_ltree[max_code + 1].dl.dad = -1;
  if ( !dad )
  {
    v22 = 3;
    v23 = 138;
  }
LABEL_28:
  v28 = 0;
  while ( v24 <= max_code )
  {
    v29 = &v4->strm + v24;
    ++v28;
    ++v24;
    v30 = *((unsigned __int16 *)v29 + 73);
    if ( v28 >= v23 || dad != v30 )
    {
      if ( v28 >= v22 )
      {
        if ( dad )
        {
          v26 = &v4->bl_tree[16];
          if ( dad != v25 )
          {
            ++v4->bl_tree[dad].fc.freq;
            v26 = &v4->bl_tree[16];
          }
        }
        else
        {
          v27 = v28 - 1 < 10;
          v26 = &v4->bl_tree[18];
          if ( v27 )
            v26 = &v4->bl_tree[17];
        }
        ++v26->fc.freq;
      }
      else
      {
        v4->bl_tree[dad].fc.freq += v28;
      }
      v22 = 4;
      if ( dad == v30 )
        v22 = 3;
      if ( !v30 )
        v22 = 3;
      v23 = 7;
      v25 = dad;
      if ( dad == v30 )
        v23 = 6;
      if ( !v30 )
        v23 = 138;
      dad = v30;
      goto LABEL_28;
    }
  }
  v31 = v4->d_desc.max_code;
  v32 = 4;
  v33 = v4->dyn_dtree[0].dl.dad;
  v34 = 0;
  v35 = -1;
  v4->dyn_dtree[v31 + 1].dl.dad = -1;
  v36 = 7;
  if ( !v33 )
  {
    v32 = 3;
    v36 = 138;
  }
LABEL_53:
  v38 = 0;
  while ( v34 + v38 <= v31 )
  {
    v39 = v4->dyn_dtree[v34 + 1 + v38++].dl.dad;
    if ( v38 >= v36 || v33 != v39 )
    {
      v34 += v38;
      if ( v38 >= v32 )
      {
        if ( v33 )
        {
          v37 = &v4->bl_tree[16];
          if ( v33 != v35 )
          {
            ++v4->bl_tree[v33].fc.freq;
            v37 = &v4->bl_tree[16];
          }
        }
        else
        {
          v37 = &v4->bl_tree[18];
          if ( v38 - 1 < 10 )
            v37 = &v4->bl_tree[17];
        }
        ++v37->fc.freq;
      }
      else
      {
        v4->bl_tree[v33].fc.freq += v38;
      }
      v32 = 4;
      if ( v33 == v39 )
        v32 = 3;
      if ( !v39 )
        v32 = 3;
      v36 = 7;
      v35 = v33;
      if ( v33 == v39 )
        v36 = 6;
      if ( !v39 )
        v36 = 138;
      v33 = v39;
      goto LABEL_53;
    }
  }
  build_tree(v4, &v4->bl_desc);
  if ( v4->bl_tree[15].dl.dad )
  {
    v40 = 18;
LABEL_60:
    v5 = eof;
    goto LABEL_81;
  }
  v5 = eof;
  if ( v4->bl_tree[1].dl.dad )
  {
    v40 = 17;
  }
  else if ( v4->bl_tree[14].dl.dad )
  {
    v40 = 16;
  }
  else if ( v4->bl_tree[2].dl.dad )
  {
    v40 = 15;
  }
  else if ( v4->bl_tree[13].dl.dad )
  {
    v40 = 14;
  }
  else if ( v4->bl_tree[3].dl.dad )
  {
    v40 = 13;
  }
  else if ( v4->bl_tree[12].dl.dad )
  {
    v40 = 12;
  }
  else if ( v4->bl_tree[4].dl.dad )
  {
    v40 = 11;
  }
  else if ( v4->bl_tree[11].dl.dad )
  {
    v40 = 10;
  }
  else
  {
    if ( !v4->bl_tree[5].dl.dad )
    {
      if ( v4->bl_tree[10].dl.dad )
      {
        v40 = 8;
      }
      else if ( v4->bl_tree[6].dl.dad )
      {
        v40 = 7;
      }
      else if ( v4->bl_tree[9].dl.dad )
      {
        v40 = 6;
      }
      else if ( v4->bl_tree[7].dl.dad )
      {
        v40 = 5;
      }
      else if ( v4->bl_tree[8].dl.dad )
      {
        v40 = 4;
      }
      else
      {
        v40 = 3;
        if ( !v4->bl_tree[0].dl.dad )
          v40 = 2;
      }
      goto LABEL_60;
    }
    v40 = 9;
  }
LABEL_81:
  static_len = v4->static_len;
  v44 = v4->opt_len + 3 * v40;
  v4->opt_len = v44 + 17;
  v45 = v44 + 27;
  v42 = (static_len + 10) >> 3;
  v41 = v42;
  if ( v42 > v45 >> 3 )
    v42 = v45 >> 3;
  buf = v101;
  if ( !v101 )
    goto LABEL_86;
LABEL_84:
  if ( stored_len + 4 <= v42 )
  {
    j__tr_stored_block(v4, buf, stored_len, v5);
    goto LABEL_109;
  }
LABEL_86:
  p_bi_valid = &v4->bi_valid;
  bi_valid = v4->bi_valid;
  if ( v41 == v42 )
  {
    v48 = v4->bi_buf | ((v5 + 2) << bi_valid);
    v4->bi_buf = v48;
    if ( bi_valid < 14 )
    {
      v54 = bi_valid + 3;
    }
    else
    {
      pending = v4->pending;
      pending_buf = v4->pending_buf;
      v4->pending = pending + 1;
      pending_buf[pending] = v48;
      v51 = v4->pending;
      v52 = v4->pending_buf;
      LOBYTE(pending) = HIBYTE(v4->bi_buf);
      v4->pending = v51 + 1;
      v52[v51] = pending;
      v53 = *p_bi_valid;
      v4->bi_buf = (unsigned __int16)(v5 + 2) >> (16 - *(_BYTE *)p_bi_valid);
      v54 = v53 - 13;
    }
    *p_bi_valid = v54;
    compress_block(v4, (ct_data *)static_ltree, (ct_data *)static_dtree);
  }
  else
  {
    v104 = v5;
    v55 = v4->bi_buf | ((v5 + 4) << bi_valid);
    p_bi_buf = &v4->bi_buf;
    v4->bi_buf = v55;
    if ( bi_valid < 14 )
    {
      v61 = bi_valid + 3;
    }
    else
    {
      v57 = v4->pending;
      v58 = v4->pending_buf;
      v4->pending = v57 + 1;
      v58[v57] = v55;
      v59 = v4->pending;
      v60 = v4->pending_buf;
      LOBYTE(v57) = HIBYTE(v4->bi_buf);
      v4->pending = v59 + 1;
      v60[v59] = v57;
      v61 = *p_bi_valid - 13;
      v55 = (unsigned __int16)(v5 + 4) >> (16 - *p_bi_valid);
      *p_bi_buf = v55;
    }
    *p_bi_valid = v61;
    v62 = v4->l_desc.max_code;
    v63 = v4->d_desc.max_code;
    v64 = (unsigned __int16)v55 | ((v62 - 256) << v61);
    *p_bi_buf = v64;
    if ( v61 < 12 )
    {
      v69 = v61 + 5;
    }
    else
    {
      v65 = v4->pending;
      v66 = v4->pending_buf;
      v4->pending = v65 + 1;
      v66[v65] = v64;
      v67 = v4->pending;
      v68 = v4->pending_buf;
      LOBYTE(v65) = HIBYTE(v4->bi_buf);
      v4->pending = v67 + 1;
      v68[v67] = v65;
      v69 = *p_bi_valid - 11;
      v64 = (unsigned __int16)(v62 - 256) >> (16 - *p_bi_valid);
      *p_bi_buf = v64;
    }
    v70 = (unsigned __int16)v64 | (v63 << v69);
    *p_bi_valid = v69;
    *p_bi_buf = v70;
    v102 = (charf *)v63;
    if ( v69 < 12 )
    {
      v75 = v69 + 5;
    }
    else
    {
      v71 = v4->pending;
      v72 = v4->pending_buf;
      v4->pending = v71 + 1;
      v72[v71] = v70;
      v73 = v4->pending;
      v74 = v4->pending_buf;
      LOBYTE(v71) = HIBYTE(v4->bi_buf);
      v4->pending = v73 + 1;
      v74[v73] = v71;
      v75 = *p_bi_valid - 11;
      v70 = (unsigned __int16)v63 >> (16 - *p_bi_valid);
      *p_bi_buf = v70;
    }
    *p_bi_valid = v75;
    v76 = ((v40 - 3) << v75) | (unsigned __int16)v70;
    *p_bi_buf = v76;
    if ( v75 < 13 )
    {
      p_pending = &v4->pending;
      v77 = v4;
      p_pending_buf = &v4->pending_buf;
      v85 = v75 + 4;
    }
    else
    {
      v77 = v4;
      v79 = v4->pending_buf;
      p_pending_buf = &v4->pending_buf;
      p_pending = (int *)(p_pending_buf + 3);
      v80 = p_pending_buf[3];
      p_pending_buf[3] = v80 + 1;
      v80[(_DWORD)v79] = v76;
      v82 = p_pending_buf[3];
      v83 = *p_pending_buf;
      v84 = *((_BYTE *)p_bi_buf + 1);
      p_pending_buf[3] = v82 + 1;
      v82[(_DWORD)v83] = v84;
      v76 = (unsigned __int16)(v40 - 3) >> (16 - *p_bi_valid);
      v85 = *p_bi_valid - 12;
      *p_bi_buf = v76;
    }
    v86 = v40 + 1;
    v87 = bl_order;
    *p_bi_valid = v85;
    do
    {
      v88 = v77->bl_tree[*v87].dl.dad;
      v76 = (unsigned __int16)v76 | (v88 << v85);
      *p_bi_buf = v76;
      if ( v85 < 14 )
      {
        v85 += 3;
      }
      else
      {
        v89 = *p_pending;
        v90 = *p_pending_buf;
        ++*p_pending;
        v90[v89] = v76;
        v91 = *p_pending;
        v92 = *p_pending_buf;
        LOBYTE(v89) = *((_BYTE *)p_bi_buf + 1);
        ++*p_pending;
        v92[v91] = v89;
        v85 = *p_bi_valid - 13;
        v76 = v88 >> (16 - *p_bi_valid);
        *p_bi_buf = v76;
      }
      ++v87;
      --v86;
      *p_bi_valid = v85;
    }
    while ( v86 );
    v4 = v77;
    send_tree(v77, v77->dyn_ltree, v62);
    send_tree(v77, v77->dyn_dtree, (int)v102);
    compress_block(v77, v77->dyn_ltree, v77->dyn_dtree);
    v5 = v104;
  }
LABEL_109:
  init_block(v4);
  if ( !v5 )
    return;
  v93 = v4->bi_valid;
  if ( v93 >= 9 )
  {
    v94 = v4->pending;
    v95 = v4->pending_buf;
    bi_buf = v4->bi_buf;
    v4->pending = v94 + 1;
    v95[v94] = bi_buf;
    v97 = 5809;
    v98 = v4->pending_buf;
LABEL_114:
    v99 = v4->pending;
    v100 = *((_BYTE *)&v4->strm + v97);
    v4->pending = v99 + 1;
    v98[v99] = v100;
    goto LABEL_115;
  }
  if ( v93 >= 1 )
  {
    v98 = v4->pending_buf;
    v97 = 5808;
    goto LABEL_114;
  }
LABEL_115:
  v4->bi_buf = 0;
  v4->bi_valid = 0;
}

//----- (002100C4) --------------------------------------------------------
void __fastcall build_tree(deflate_state_0 *s, tree_desc *desc)
{
  ct_data *dyn_tree; // r9
  static_tree_desc_0 *stat_desc; // r1
  int elems; // r6
  const ct_data *static_tree; // r5
  int *p_heap_len; // r10
  int v7; // r4
  int i; // r3
  int v9; // r2
  int v10; // r1
  int v11; // r2
  int v12; // r12
  int v13; // r1
  z_streamp *v14; // r2
  int v15; // r3
  int j; // r12
  int v17; // r5
  int v18; // r4
  int v19; // r6
  int v20; // r8
  int v21; // r3
  int v22; // r5
  unsigned int freq; // r2
  unsigned int v24; // lr
  unsigned int v25; // r2
  unsigned int v26; // r2
  int v27; // r1
  unsigned int v28; // r3
  z_streamp *v29; // r2
  int v30; // lr
  int v31; // r6
  int v32; // r8
  int v33; // r12
  int v34; // r3
  int v35; // r5
  int v36; // r1
  int v37; // r3
  int v38; // r2
  unsigned int v39; // r4
  unsigned int v40; // r11
  bool v41; // cc
  unsigned int v42; // r2
  int v43; // r1
  unsigned int v44; // r4
  z_streamp *v45; // r2
  int *heap; // r5
  int v47; // r2
  int v48; // r1
  int v49; // r1
  uch *depth; // r11
  ct_data *v51; // r1
  int v52; // r6
  int v53; // r1
  int v54; // r12
  int v55; // r3
  int v56; // r1
  int v57; // r2
  unsigned int v58; // r4
  unsigned int v59; // r8
  int v60; // r3
  unsigned int v61; // r2
  unsigned int v62; // r4
  z_streamp *v63; // r2
  int v64; // r2
  int v65; // r1
  __int64 v66; // kr00_8
  static_tree_desc_0 *v67; // r1
  int extra_base; // r8
  int max_length; // r11
  int v70; // r1
  int v71; // r5
  int v72; // r10
  int v73; // r3
  int v74; // r2
  int v75; // r6
  int v76; // r1
  intf v77; // lr
  int v78; // r2
  char *v79; // r1
  char *v80; // lr
  ush *v81; // r6
  char *v82; // r1
  int v83; // r2
  __int16 v84; // r3
  ush v85; // r1
  int v86; // r6
  int v87; // r3
  int v88; // r5
  z_streamp *v89; // r1
  int v90; // r1
  int v91; // r6
  int v92; // r2
  _WORD *v93; // r6
  int v94; // t1
  int v95; // r0
  int dad; // r2
  unsigned int v97; // r3
  int v98; // r5
  int v99; // r6
  int v100; // r4
  const intf *extra_bits; // [sp+0h] [bp-58h]
  int v104; // [sp+8h] [bp-50h]
  int *p_heap_max; // [sp+Ch] [bp-4Ch]
  ulg *p_opt_len; // [sp+Ch] [bp-4Ch]
  int v107; // [sp+10h] [bp-48h]
  int v108; // [sp+14h] [bp-44h]
  const ct_data *v109; // [sp+14h] [bp-44h]
  unsigned __int16 v110[1]; // [sp+1Ch] [bp-3Ch]
  __int16 v111; // [sp+1Eh] [bp-3Ah]
  __int16 v112; // [sp+20h] [bp-38h]
  __int16 v113; // [sp+22h] [bp-36h]
  __int16 v114; // [sp+24h] [bp-34h]
  __int16 v115; // [sp+26h] [bp-32h]
  __int16 v116; // [sp+28h] [bp-30h]
  __int16 v117; // [sp+2Ah] [bp-2Eh]
  __int16 v118; // [sp+2Ch] [bp-2Ch]
  __int16 v119; // [sp+2Eh] [bp-2Ah]
  __int16 v120; // [sp+30h] [bp-28h]
  __int16 v121; // [sp+32h] [bp-26h]
  __int16 v122; // [sp+34h] [bp-24h]
  __int16 v123; // [sp+36h] [bp-22h]
  __int16 v124; // [sp+38h] [bp-20h]
  __int16 v125; // [sp+3Ah] [bp-1Eh]

  dyn_tree = desc->dyn_tree;
  stat_desc = desc->stat_desc;
  elems = stat_desc->elems;
  static_tree = stat_desc->static_tree;
  p_heap_len = &s->heap_len;
  s->heap_max = 573;
  s->heap_len = 0;
  v108 = elems;
  if ( elems < 1 )
  {
    v107 = -1;
    v10 = 0;
  }
  else
  {
    v7 = -1;
    for ( i = 0; i != elems; ++i )
    {
      if ( dyn_tree[i].fc.freq )
      {
        v7 = i;
        v9 = *p_heap_len + 1;
        *p_heap_len = v9;
        s->heap[v9] = i;
        s->depth[i] = 0;
      }
      else
      {
        dyn_tree[i].dl.dad = 0;
      }
    }
    v107 = v7;
    v10 = *p_heap_len;
    if ( *p_heap_len > 1 )
      goto LABEL_17;
  }
  do
  {
    v11 = v10 + 1;
    *p_heap_len = v10 + 1;
    v12 = v107;
    v13 = 0;
    v14 = &s->strm + v11;
    if ( v107 < 2 )
      v13 = v107 + 1;
    v14[725] = (z_streamp)v13;
    dyn_tree[v13].fc.freq = 1;
    s->depth[v13] = 0;
    --s->opt_len;
    if ( v107 < 2 )
      v12 = v107 + 1;
    v107 = v12;
    if ( static_tree )
      s->static_len -= static_tree[v13].dl.dad;
    v10 = *p_heap_len;
  }
  while ( *p_heap_len < 2 );
LABEL_17:
  p_heap_max = &s->heap_max;
  desc->max_code = v107;
  v15 = *p_heap_len;
  if ( *p_heap_len < 2 )
    goto LABEL_38;
  for ( j = (unsigned int)v15 >> 1; ; --j )
  {
    v18 = 2 * j;
    v17 = j;
    v19 = s->heap[j];
    if ( 2 * j <= v15 )
    {
      v20 = j;
      while ( v18 < v15 )
      {
        v21 = s->heap[v18];
        v22 = s->heap[v18 | 1];
        freq = dyn_tree[v21].fc.freq;
        v24 = dyn_tree[v22].fc.freq;
        if ( v24 >= freq )
        {
          if ( v24 != freq )
            break;
          v25 = s->depth[v22];
          v17 = v18;
          if ( v25 <= s->depth[v21] )
            v17 = v18 | 1;
        }
        else
        {
          v17 = v18 | 1;
        }
LABEL_32:
        v26 = dyn_tree[v19].fc.freq;
        v27 = s->heap[v17];
        v28 = dyn_tree[v27].fc.freq;
        if ( v26 < v28 || v26 == v28 && s->depth[v19] <= (unsigned int)s->depth[v27] )
        {
          v17 = v20;
          goto LABEL_20;
        }
        v29 = &s->strm + v20;
        v18 = 2 * v17;
        v20 = v17;
        v29[725] = (z_streamp)v27;
        v15 = *p_heap_len;
        if ( 2 * v17 > *p_heap_len )
          goto LABEL_20;
      }
      v17 = v18;
      goto LABEL_32;
    }
LABEL_20:
    s->heap[v17] = v19;
    if ( j < 2 )
      break;
    v15 = *p_heap_len;
  }
  v15 = *p_heap_len;
  do
  {
LABEL_38:
    v30 = v108;
    v31 = v15 - 1;
    v32 = s->heap[1];
    *p_heap_len = v15 - 1;
    v33 = s->heap[v15];
    s->heap[1] = v33;
    if ( v15 < 3 )
    {
      v34 = 1;
      goto LABEL_55;
    }
    v35 = 1;
    v36 = 2;
    while ( 1 )
    {
      if ( v36 >= v31 )
      {
LABEL_48:
        v34 = v36;
        goto LABEL_49;
      }
      v37 = s->heap[v36];
      v38 = s->heap[v36 | 1];
      v39 = dyn_tree[v37].fc.freq;
      v40 = dyn_tree[v38].fc.freq;
      if ( v40 >= v39 )
      {
        if ( v40 != v39 )
          goto LABEL_48;
        v41 = s->depth[v38] > (unsigned int)s->depth[v37];
        v34 = v36;
        if ( !v41 )
          v34 = v36 | 1;
      }
      else
      {
        v34 = v36 | 1;
      }
LABEL_49:
      v42 = dyn_tree[v33].fc.freq;
      v43 = s->heap[v34];
      v44 = dyn_tree[v43].fc.freq;
      if ( v42 < v44 || v42 == v44 && s->depth[v33] <= (unsigned int)s->depth[v43] )
        break;
      v45 = &s->strm + v35;
      v35 = v34;
      v45[725] = (z_streamp)v43;
      v36 = 2 * v34;
      v31 = *p_heap_len;
      if ( 2 * v34 > *p_heap_len )
        goto LABEL_55;
    }
    v34 = v35;
LABEL_55:
    heap = s->heap;
    s->heap[v34] = v33;
    v47 = s->heap[1];
    v48 = *p_heap_max - 1;
    *p_heap_max = v48;
    s->heap[v48] = v32;
    v49 = *p_heap_max - 1;
    *p_heap_max = v49;
    s->heap[v49] = v47;
    dyn_tree[v108].fc.freq = dyn_tree[v32].fc.freq + dyn_tree[v47].fc.freq;
    depth = s->depth;
    v51 = &dyn_tree[v47];
    if ( s->depth[v32] >= (unsigned int)s->depth[v47] )
      v47 = v32;
    depth[v108] = depth[v47] + 1;
    v51->dl.dad = v108;
    dyn_tree[v32].dl.dad = v108;
    s->heap[1] = v108++;
    v52 = *p_heap_len;
    if ( *p_heap_len < 2 )
    {
      v53 = 1;
      goto LABEL_74;
    }
    v54 = 1;
    v55 = 2;
    while ( 2 )
    {
      if ( v55 >= v52 )
        goto LABEL_67;
      v56 = heap[v55];
      v57 = heap[v55 | 1];
      v58 = dyn_tree[v56].fc.freq;
      v59 = dyn_tree[v57].fc.freq;
      if ( v59 < v58 )
      {
        v53 = v55 | 1;
        goto LABEL_68;
      }
      if ( v59 != v58 )
      {
LABEL_67:
        v53 = v55;
        goto LABEL_68;
      }
      v41 = depth[v57] > (unsigned int)depth[v56];
      v53 = v55;
      if ( !v41 )
        v53 = v55 | 1;
LABEL_68:
      v60 = s->heap[v53];
      v61 = dyn_tree[v30].fc.freq;
      v62 = dyn_tree[v60].fc.freq;
      if ( v61 >= v62 && (v61 != v62 || depth[v30] > (unsigned int)s->depth[v60]) )
      {
        v63 = &s->strm + v54;
        v54 = v53;
        v63[725] = (z_streamp)v60;
        v55 = 2 * v53;
        v52 = *p_heap_len;
        if ( 2 * v53 > *p_heap_len )
          goto LABEL_74;
        continue;
      }
      break;
    }
    v53 = v54;
LABEL_74:
    s->heap[v53] = v30;
    v15 = *p_heap_len;
  }
  while ( *p_heap_len > 1 );
  v64 = s->heap[1];
  v65 = *p_heap_max - 1;
  *p_heap_max = v65;
  heap[v65] = v64;
  v66 = *(_QWORD *)&desc->dyn_tree;
  v67 = desc->stat_desc;
  v109 = v67->static_tree;
  extra_bits = v67->extra_bits;
  extra_base = v67->extra_base;
  max_length = v67->max_length;
  *(_QWORD *)&s->bl_count[8] = 0LL;
  *(_QWORD *)&s->bl_count[12] = 0LL;
  *(_QWORD *)s->bl_count = 0LL;
  *(_QWORD *)&s->bl_count[4] = 0LL;
  v70 = heap[*p_heap_max];
  v71 = 0;
  *(_WORD *)(v66 + 4 * v70 + 2) = 0;
  v72 = *p_heap_max;
  if ( *p_heap_max < 572 )
  {
    v104 = extra_base;
    p_opt_len = &s->opt_len;
    do
    {
      v73 = s->heap[++v72];
      v74 = v66 + 4 * v73;
      v75 = *(unsigned __int16 *)(v66 + 4 * *(unsigned __int16 *)(v74 + 2) + 2);
      v76 = max_length;
      if ( max_length > v75 )
        v76 = v75 + 1;
      *(_WORD *)(v74 + 2) = v76;
      v71 += max_length <= v75;
      if ( v73 <= SHIDWORD(v66) )
      {
        ++s->bl_count[v76];
        v77 = v73 >= extra_base ? extra_bits[v73 - extra_base] : 0;
        v78 = *(unsigned __int16 *)(v66 + 4 * v73);
        *p_opt_len += (v76 + v77) * v78;
        extra_base = v104;
        if ( v109 )
          s->static_len += (v109[v73].dl.dad + v77) * v78;
      }
    }
    while ( v72 - 1 < 571 );
    if ( v71 )
    {
      v79 = (char *)s + 2 * max_length;
      v80 = v79 + 2870;
      v81 = (ush *)(v79 + 2868);
      do
      {
        v82 = v80;
        do
        {
          v83 = *((unsigned __int16 *)v82 - 2);
          v82 -= 2;
        }
        while ( !v83 );
        v84 = *(_WORD *)v82;
        *((_WORD *)v82 - 1) = v83 - 1;
        v41 = v71 <= 2;
        v71 -= 2;
        *(_WORD *)v82 = v84 + 2;
        v85 = *v81 - 1;
        *v81 = v85;
      }
      while ( !v41 );
      if ( max_length )
      {
        v86 = 573;
        while ( 1 )
        {
          v87 = v85;
          v88 = v86;
          while ( v87 )
          {
            v89 = &s->strm + v88--;
            v90 = (int)v89[724];
            if ( v90 <= SHIDWORD(v66) )
            {
              v91 = v66 + 4 * v90;
              v94 = *(unsigned __int16 *)(v91 + 2);
              v93 = (_WORD *)(v91 + 2);
              v92 = v94;
              if ( max_length != v94 )
              {
                *p_opt_len += (max_length - v92) * *(unsigned __int16 *)(v66 + 4 * v90);
                *v93 = max_length;
              }
              --v87;
              v86 = v88;
            }
          }
          if ( !--max_length )
            break;
          v85 = s->bl_count[max_length];
        }
      }
    }
  }
  v111 = 2 * s->bl_count[0];
  v112 = 2 * (s->bl_count[1] + v111);
  v113 = 2 * (s->bl_count[2] + v112);
  v114 = 2 * (s->bl_count[3] + v113);
  v115 = 2 * (s->bl_count[4] + v114);
  v116 = 2 * (s->bl_count[5] + v115);
  v117 = 2 * (s->bl_count[6] + v116);
  v118 = 2 * (s->bl_count[7] + v117);
  v119 = 2 * (s->bl_count[8] + v118);
  v120 = 2 * (s->bl_count[9] + v119);
  v121 = 2 * (s->bl_count[10] + v120);
  v122 = 2 * (s->bl_count[11] + v121);
  v123 = 2 * (s->bl_count[12] + v122);
  v124 = 2 * (s->bl_count[13] + v123);
  v125 = 2 * (s->bl_count[14] + v124);
  if ( v107 >= 0 )
  {
    v95 = 0;
    do
    {
      dad = dyn_tree[v95].dl.dad;
      if ( dyn_tree[v95].dl.dad )
      {
        v97 = v110[dad];
        v98 = 0;
        v110[dad] = v97 + 1;
        v99 = dad + 1;
        do
        {
          --v99;
          v100 = v98 | v97 & 1;
          v97 >>= 1;
          v98 = 2 * v100;
        }
        while ( v99 > 1 );
        dyn_tree[v95].fc.freq = v100;
      }
    }
    while ( v95++ != v107 );
  }
}
// 2100C4: using guessed type unsigned __int16 var_3C[1];

//----- (002106E0) --------------------------------------------------------
void __fastcall compress_block(deflate_state_0 *s, ct_data *ltree, ct_data *dtree)
{
  ush *p_bi_buf; // lr
  int *p_bi_valid; // r9
  uInt v5; // r11
  int v6; // r8
  int v7; // r12
  int v8; // r2
  int v9; // r6
  ct_data *v10; // r1
  int *v11; // r3
  unsigned int freq; // r10
  int dad; // r4
  int v14; // r5
  int pending; // r2
  Bytef *pending_buf; // r9
  int v17; // r2
  Bytef *v18; // r9
  Bytef bi_buf_high; // r5
  int v20; // r9
  int v21; // r2
  unsigned int v22; // r4
  int v23; // r3
  int v24; // r10
  int v25; // r6
  Bytef *v26; // r2
  int v27; // r6
  Bytef *v28; // r2
  Bytef v29; // r5
  int bi_valid; // r4
  int v31; // r10
  int v32; // r3
  int v33; // r2
  Bytef *v34; // r1
  int v35; // r2
  Bytef *v36; // r1
  Bytef v37; // r6
  int *v38; // r6
  unsigned int v39; // r8
  int v40; // r1
  int v41; // r6
  unsigned int v42; // r3
  int v43; // r4
  int v44; // r2
  Bytef *v45; // r1
  int v46; // r2
  Bytef *v47; // r12
  Bytef v48; // r5
  int v49; // r5
  unsigned int v50; // r3
  int v51; // r2
  Bytef *v52; // r1
  int v53; // r2
  Bytef *v54; // r1
  Bytef v55; // r6
  unsigned int v56; // r6
  int v57; // r3
  int v58; // r2
  int v59; // r5
  Bytef *v60; // r1
  int v61; // r2
  Bytef *v62; // r1
  int v63; // r1
  int v64; // r2
  int *v66; // [sp+Ch] [bp-30h]

  if ( s->last_lit )
  {
    p_bi_buf = &s->bi_buf;
    p_bi_valid = &s->bi_valid;
    v5 = 0;
    v66 = &s->bi_valid;
    while ( 1 )
    {
      v6 = s->d_buf[v5];
      v7 = s->l_buf[v5++];
      if ( v6 )
      {
        v8 = *p_bi_valid;
        v9 = length_code[v7];
        v10 = &ltree[v9 | 0x100];
        v11 = p_bi_valid;
        freq = v10[1].fc.freq;
        dad = v10[1].dl.dad;
        v14 = *p_bi_buf | (freq << *p_bi_valid);
        *p_bi_buf = v14;
        if ( v8 <= 16 - dad )
        {
          v20 = v8 + dad;
        }
        else
        {
          pending = s->pending;
          pending_buf = s->pending_buf;
          s->pending = pending + 1;
          pending_buf[pending] = v14;
          v17 = s->pending;
          v18 = s->pending_buf;
          bi_buf_high = HIBYTE(s->bi_buf);
          s->pending = v17 + 1;
          v18[v17] = bi_buf_high;
          v20 = *v11 + dad - 16;
          v14 = freq >> (16 - *(_BYTE *)v11);
          *p_bi_buf = v14;
        }
        *v11 = v20;
        if ( (unsigned int)(v9 - 8) <= 0x13 )
        {
          v31 = extra_lbits[v9];
          v32 = v7 - base_length[v9];
          v14 = (v32 << v20) | (unsigned __int16)v14;
          *p_bi_buf = v14;
          if ( v20 <= 16 - v31 )
          {
            v38 = &s->bi_valid;
            v20 += v31;
          }
          else
          {
            v33 = s->pending;
            v34 = s->pending_buf;
            s->pending = v33 + 1;
            v34[v33] = v14;
            v35 = s->pending;
            v36 = s->pending_buf;
            v37 = HIBYTE(s->bi_buf);
            s->pending = v35 + 1;
            v36[v35] = v37;
            v38 = &s->bi_valid;
            v20 = *v66 + v31 - 16;
            v14 = (unsigned __int16)v32 >> (16 - *(_BYTE *)v66);
            *p_bi_buf = v14;
          }
          *v38 = v20;
        }
        v39 = v6 - 1;
        v40 = v39;
        if ( v39 >= 0x100 )
          v40 = (v39 >> 7) + 256;
        v41 = dist_code[v40];
        v42 = dtree[v41].fc.freq;
        v43 = dtree[v41].dl.dad;
        v24 = (v42 << v20) | (unsigned __int16)v14;
        *p_bi_buf = v24;
        if ( v20 <= 16 - v43 )
        {
          bi_valid = v43 + v20;
          p_bi_valid = &s->bi_valid;
        }
        else
        {
          v44 = s->pending;
          v45 = s->pending_buf;
          s->pending = v44 + 1;
          v45[v44] = v24;
          v46 = s->pending;
          v47 = s->pending_buf;
          v48 = HIBYTE(s->bi_buf);
          s->pending = v46 + 1;
          v47[v46] = v48;
          p_bi_valid = &s->bi_valid;
          bi_valid = *v66 + v43 - 16;
          v24 = v42 >> (16 - *(_BYTE *)v66);
          *p_bi_buf = v24;
        }
        *p_bi_valid = bi_valid;
        if ( (unsigned int)(v41 - 4) > 0x19 )
          goto LABEL_25;
        v49 = extra_dbits[v41];
        v50 = v39 - base_dist[v41];
        v24 = (v50 << bi_valid) | (unsigned __int16)v24;
        *p_bi_buf = v24;
        if ( bi_valid <= 16 - v49 )
        {
          bi_valid += v49;
        }
        else
        {
          v51 = s->pending;
          v52 = s->pending_buf;
          s->pending = v51 + 1;
          v52[v51] = v24;
          v53 = s->pending;
          v54 = s->pending_buf;
          v55 = HIBYTE(s->bi_buf);
          s->pending = v53 + 1;
          v54[v53] = v55;
          bi_valid = *p_bi_valid + v49 - 16;
          v24 = (unsigned __int16)v50 >> (16 - *(_BYTE *)p_bi_valid);
          *p_bi_buf = v24;
        }
      }
      else
      {
        v21 = *p_bi_valid;
        v22 = ltree[v7].fc.freq;
        v23 = ltree[v7].dl.dad;
        v24 = (v22 << *p_bi_valid) | *p_bi_buf;
        *p_bi_buf = v24;
        if ( v21 <= 16 - v23 )
        {
          bi_valid = v21 + v23;
        }
        else
        {
          v25 = s->pending;
          v26 = s->pending_buf;
          s->pending = v25 + 1;
          v26[v25] = v24;
          v27 = s->pending;
          v28 = s->pending_buf;
          v29 = HIBYTE(s->bi_buf);
          s->pending = v27 + 1;
          v28[v27] = v29;
          v24 = v22 >> (16 - *(_BYTE *)p_bi_valid);
          bi_valid = *p_bi_valid + v23 - 16;
          *p_bi_buf = v24;
        }
      }
      *p_bi_valid = bi_valid;
LABEL_25:
      if ( v5 >= s->last_lit )
        goto LABEL_28;
    }
  }
  LOWORD(v24) = s->bi_buf;
  p_bi_buf = &s->bi_buf;
  bi_valid = s->bi_valid;
  p_bi_valid = &s->bi_valid;
LABEL_28:
  v56 = ltree[256].fc.freq;
  v57 = ltree[256].dl.dad;
  v58 = (unsigned __int16)v24 | (v56 << bi_valid);
  *p_bi_buf = v58;
  if ( bi_valid <= 16 - v57 )
  {
    v64 = bi_valid + v57;
  }
  else
  {
    v59 = s->pending;
    v60 = s->pending_buf;
    s->pending = v59 + 1;
    v60[v59] = v58;
    v61 = s->pending;
    v62 = s->pending_buf;
    LOBYTE(v59) = *((_BYTE *)p_bi_buf + 1);
    s->pending = v61 + 1;
    v62[v61] = v59;
    v63 = *p_bi_valid + v57;
    *p_bi_buf = v56 >> (16 - *p_bi_valid);
    v64 = v63 - 16;
  }
  *p_bi_valid = v64;
  s->last_eob_len = ltree[256].dl.dad;
}

//----- (00210A18) --------------------------------------------------------
int __fastcall tr_tally(deflate_state_0 *s, unsigned int dist, unsigned int lc)
{
  uInt last_lit; // lr
  uchf *l_buf; // r3
  unsigned int v5; // r1
  z_streamp *v6; // r2
  ct_data_s *v7; // r1

  s->d_buf[s->last_lit] = dist;
  last_lit = s->last_lit;
  l_buf = s->l_buf;
  s->last_lit = last_lit + 1;
  l_buf[last_lit] = lc;
  if ( dist )
  {
    v5 = dist - 1;
    ++s->matches;
    if ( v5 >= 0x100 )
      v5 = (v5 >> 7) + 256;
    v6 = &s->strm + (length_code[lc] | 0x100);
    v7 = &s->dyn_dtree[dist_code[v5]];
    ++*((_WORD *)v6 + 72);
  }
  else
  {
    v7 = &s->dyn_ltree[lc];
  }
  ++v7->fc.freq;
  return s->last_lit == s->lit_bufsize - 1;
}

//----- (00210AC0) --------------------------------------------------------
void __fastcall send_tree(deflate_state_0 *s, ct_data *tree, int max_code)
{
  int dad; // lr
  ct_data_s::$4F0F685EC8FA33D55D00A49514E362B1 *p_dl; // r2
  int v6; // r5
  int v7; // r8
  int v8; // r1
  int v9; // r11
  int v10; // r8
  ush *v11; // r4
  int *v12; // r11
  int v13; // r1
  int v14; // r3
  unsigned int v15; // r8
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r6
  Bytef *v20; // r12
  int v21; // r2
  Bytef *v22; // r12
  int v23; // r3
  z_streamp *v24; // r1
  unsigned int v25; // r5
  int v26; // r2
  int v27; // r3
  bool v28; // cc
  int v29; // r6
  Bytef *v30; // r2
  Bytef *v31; // r1
  int v32; // r2
  unsigned int v33; // r8
  int v34; // r2
  int v35; // r3
  int v36; // r1
  int v37; // r6
  Bytef *v38; // r12
  int v39; // r2
  Bytef *v40; // r12
  int v41; // r6
  unsigned int freq; // r6
  int v43; // r5
  int v44; // r1
  int v45; // r3
  Bytef *v46; // r2
  int v47; // r2
  Bytef *v48; // r1
  int v49; // r6
  unsigned int v50; // r3
  int v51; // r1
  int v52; // r6
  Bytef *v53; // r2
  int v54; // r2
  Bytef *v55; // r1
  int v56; // r2
  int v57; // r1
  int v58; // r1
  int v59; // r3
  Bytef *v60; // r2
  int v61; // r2
  Bytef *v62; // r1
  int v63; // r1
  int v64; // r6
  Bytef *v65; // r2
  int v66; // r2
  Bytef *v67; // r1
  int v68; // r10
  char *v69; // r1
  int v70; // r9
  int v71; // r6
  int v72; // r3
  int v73; // r2
  int v74; // t1
  int v75; // r4
  int v76; // r6
  ush *v77; // r4
  z_streamp *v78; // r3
  unsigned __int16 *v79; // r8
  unsigned __int16 *v80; // r11
  int v81; // r1
  int v82; // r5
  unsigned int v83; // r12
  int v84; // r6
  int pending; // r4
  Bytef *pending_buf; // r3
  int v87; // r3
  Bytef *v88; // r1
  int *v89; // r10
  int v90; // [sp+0h] [bp-30h]
  int v91; // [sp+4h] [bp-2Ch]
  ct_data_s::$4F0F685EC8FA33D55D00A49514E362B1 *v92; // [sp+8h] [bp-28h]
  int *p_bi_valid; // [sp+Ch] [bp-24h]
  ush *p_bi_buf; // [sp+10h] [bp-20h]

  p_bi_buf = &s->bi_buf;
  dad = tree->dl.dad;
  p_bi_valid = &s->bi_valid;
  p_dl = &tree[1].dl;
  v6 = 7;
  v7 = 4;
  if ( !tree->dl.dad )
  {
    v6 = 138;
    v7 = 3;
  }
  v8 = 0;
  v9 = -1;
  v92 = p_dl;
LABEL_41:
  v68 = v8;
  v69 = (char *)&p_dl[2 * v8];
  v70 = dad;
  v71 = -3;
  v72 = -1;
  while ( 1 )
  {
    v73 = v72;
    if ( v68 + v71 + 3 > max_code )
      break;
    v74 = *(unsigned __int16 *)v69;
    v69 += 4;
    dad = v74;
    v75 = v71 + 1;
    if ( v71 + 4 < v6 )
    {
      --v72;
      ++v71;
      if ( v70 == dad )
        continue;
    }
    v76 = v75 + 3;
    v90 = v68 + v75 + 3;
    v91 = max_code;
    if ( v75 + 3 < v7 )
    {
      v77 = &s->bi_buf;
      v78 = &s->strm + v70;
      v79 = (unsigned __int16 *)(v78 + 669);
      v80 = (unsigned __int16 *)v78 + 1339;
      LOWORD(v81) = *p_bi_buf;
      v82 = *p_bi_valid;
      do
      {
        v83 = *v79;
        v84 = *v80;
        v81 = (unsigned __int16)v81 | (v83 << v82);
        *v77 = v81;
        if ( v82 <= 16 - v84 )
        {
          v89 = &s->bi_valid;
          v82 += v84;
        }
        else
        {
          pending = s->pending;
          pending_buf = s->pending_buf;
          s->pending = pending + 1;
          pending_buf[pending] = v81;
          v87 = s->pending;
          v88 = s->pending_buf;
          LOBYTE(pending) = HIBYTE(s->bi_buf);
          s->pending = v87 + 1;
          v88[v87] = pending;
          v89 = &s->bi_valid;
          v77 = &s->bi_buf;
          v82 = *p_bi_valid + v84 - 16;
          v81 = v83 >> (16 - *p_bi_valid);
          *p_bi_buf = v81;
        }
        ++v73;
        *v89 = v82;
      }
      while ( v73 );
      goto LABEL_32;
    }
    v10 = v75 + 2;
    if ( v70 )
    {
      if ( v70 == v9 )
      {
        v11 = &s->bi_buf;
        v10 = v76;
        v12 = &s->bi_valid;
        LOWORD(v13) = *p_bi_buf;
        v14 = *p_bi_valid;
      }
      else
      {
        v12 = &s->bi_valid;
        v24 = &s->strm + v70;
        v11 = &s->bi_buf;
        v25 = *((unsigned __int16 *)v24 + 1338);
        v26 = *p_bi_valid;
        v27 = *((unsigned __int16 *)v24 + 1339);
        v13 = (v25 << *p_bi_valid) | *p_bi_buf;
        v28 = *p_bi_valid <= 16 - v27;
        *p_bi_buf = v13;
        if ( v28 )
        {
          v14 = v27 + v26;
        }
        else
        {
          v29 = s->pending;
          v30 = s->pending_buf;
          s->pending = v29 + 1;
          v30[v29] = v13;
          v31 = s->pending_buf;
          v32 = s->pending;
          LOBYTE(v29) = HIBYTE(s->bi_buf);
          s->pending = v32 + 1;
          v11 = &s->bi_buf;
          v31[v32] = v29;
          v14 = *p_bi_valid + v27 - 16;
          v13 = v25 >> (16 - *p_bi_valid);
          *p_bi_buf = v13;
        }
        *p_bi_valid = v14;
      }
      freq = s->bl_tree[16].fc.freq;
      v43 = s->bl_tree[16].dl.dad;
      v44 = (unsigned __int16)v13 | (freq << v14);
      *v11 = v44;
      if ( v14 <= 16 - v43 )
      {
        v49 = v14 + v43;
      }
      else
      {
        v45 = s->pending;
        v46 = s->pending_buf;
        s->pending = v45 + 1;
        v46[v45] = v44;
        v47 = s->pending;
        v48 = s->pending_buf;
        LOBYTE(v45) = HIBYTE(s->bi_buf);
        s->pending = v47 + 1;
        v11 = &s->bi_buf;
        v48[v47] = v45;
        v44 = freq >> (16 - *v12);
        v49 = *v12 + v43 - 16;
        *p_bi_buf = v44;
      }
      LOWORD(v50) = v10 - 3;
      *v12 = v49;
      v51 = (unsigned __int16)v44 | ((v10 - 3) << v49);
      *v11 = v51;
      if ( v49 >= 15 )
      {
        v52 = s->pending;
        v50 = (unsigned __int16)v50;
        v53 = s->pending_buf;
        s->pending = v52 + 1;
        v53[v52] = v51;
        v54 = s->pending;
        v55 = s->pending_buf;
        LOBYTE(v52) = *((_BYTE *)v11 + 1);
        s->pending = v54 + 1;
        v55[v54] = v52;
        v56 = 16 - *v12;
        v57 = *v12 - 14;
        goto LABEL_28;
      }
      v57 = v49 + 2;
    }
    else if ( v10 > 9 )
    {
      v12 = &s->bi_valid;
      v33 = s->bl_tree[18].fc.freq;
      v34 = *p_bi_valid;
      v35 = s->bl_tree[18].dl.dad;
      v36 = *p_bi_buf | (v33 << *p_bi_valid);
      *p_bi_buf = v36;
      if ( v34 <= 16 - v35 )
      {
        v41 = v34 + v35;
      }
      else
      {
        v37 = s->pending;
        v38 = s->pending_buf;
        s->pending = v37 + 1;
        v38[v37] = v36;
        v39 = s->pending;
        v40 = s->pending_buf;
        LOBYTE(v37) = HIBYTE(s->bi_buf);
        s->pending = v39 + 1;
        v40[v39] = v37;
        v41 = *p_bi_valid + v35 - 16;
        v36 = v33 >> (16 - *p_bi_valid);
        *p_bi_buf = v36;
      }
      v50 = v75 - 8;
      v11 = &s->bi_buf;
      v63 = (unsigned __int16)v36 | (v50 << v41);
      *p_bi_valid = v41;
      *p_bi_buf = v63;
      if ( v41 < 10 )
      {
        v57 = v41 + 7;
      }
      else
      {
        v64 = s->pending;
        v50 = (unsigned __int16)v50;
        v65 = s->pending_buf;
        s->pending = v64 + 1;
        v65[v64] = v63;
        v66 = s->pending;
        v67 = s->pending_buf;
        LOBYTE(v64) = HIBYTE(s->bi_buf);
        s->pending = v66 + 1;
        v67[v66] = v64;
        v56 = 16 - *p_bi_valid;
        v57 = *p_bi_valid - 9;
LABEL_28:
        *v11 = v50 >> v56;
      }
    }
    else
    {
      v12 = &s->bi_valid;
      v15 = s->bl_tree[17].fc.freq;
      v16 = *p_bi_valid;
      v17 = s->bl_tree[17].dl.dad;
      v18 = *p_bi_buf | (v15 << *p_bi_valid);
      *p_bi_buf = v18;
      if ( v16 <= 16 - v17 )
      {
        v23 = v17 + v16;
      }
      else
      {
        v19 = s->pending;
        v20 = s->pending_buf;
        s->pending = v19 + 1;
        v20[v19] = v18;
        v21 = s->pending;
        v22 = s->pending_buf;
        LOBYTE(v19) = HIBYTE(s->bi_buf);
        s->pending = v21 + 1;
        v22[v21] = v19;
        v23 = *p_bi_valid + v17 - 16;
        v18 = v15 >> (16 - *p_bi_valid);
        *p_bi_buf = v18;
      }
      v58 = (unsigned __int16)v18 | (v75 << v23);
      *p_bi_valid = v23;
      *p_bi_buf = v58;
      if ( v23 < 14 )
      {
        v57 = v23 + 3;
      }
      else
      {
        v59 = s->pending;
        v60 = s->pending_buf;
        s->pending = v59 + 1;
        v60[v59] = v58;
        v61 = s->pending;
        v62 = s->pending_buf;
        LOBYTE(v59) = HIBYTE(s->bi_buf);
        s->pending = v61 + 1;
        v62[v61] = v59;
        v57 = *p_bi_valid - 13;
        *p_bi_buf = (unsigned __int16)v75 >> (16 - *p_bi_valid);
      }
    }
    *v12 = v57;
LABEL_32:
    v6 = 7;
    if ( v70 == dad )
      v6 = 6;
    if ( !dad )
      v6 = 138;
    v7 = 4;
    v9 = v70;
    if ( v70 == dad )
      v7 = 3;
    if ( !dad )
      v7 = 3;
    p_dl = v92;
    v8 = v90;
    max_code = v91;
    goto LABEL_41;
  }
}

//----- (00210E40) --------------------------------------------------------
int __fastcall uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
{
  int v5; // r5
  z_stream_1 v7; // [sp+0h] [bp-40h] BYREF

  v7.next_in = (Bytef *)source;
  v7.avail_in = sourceLen;
  v7.next_out = dest;
  v7.avail_out = *destLen;
  v7.zalloc = 0;
  v7.zfree = 0;
  v5 = j_inflateInit_(&v7, "1.1.3", 56);
  if ( !v5 )
  {
    v5 = j_inflate(&v7, 4);
    if ( v5 == 1 )
    {
      *destLen = v7.total_out;
      return j_inflateEnd(&v7);
    }
    else
    {
      j_inflateEnd(&v7);
      if ( !v5 )
        return -5;
    }
  }
  return v5;
}

//----- (00210EA0) --------------------------------------------------------
char *zlibVersion()
{
  return "1.1.3";
}

//----- (00210EAC) --------------------------------------------------------
const unsigned __int8 *__fastcall zError(int err)
{
  return z_errmsg[2 - err];
}

//----- (00210EC0) --------------------------------------------------------
voidpf __fastcall zcalloc(voidpf opaque, unsigned int items, unsigned int size)
{
  return sub_199A08(items, size);
}

//----- (00210EC8) --------------------------------------------------------
void __fastcall zcfree(voidpf opaque, voidpf ptr)
{
  j_free(ptr);
}

//----- (00210ED0) --------------------------------------------------------
RwBool __fastcall RtQuatConvertFromMatrix(RtQuat_0 *const qpQuat, const RwMatrix *const mpMatrix)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  unsigned int v6; // r0
  unsigned int v7; // r1
  int v8; // r5
  float z; // s0
  float v10; // s6
  RwReal v11; // r0
  float v12; // s6
  void (__fastcall *v13)(RtQuat_0 *const, const RwMatrix *const); // r2

  v6 = (unsigned int)mpMatrix;
  if ( mpMatrix )
    v6 = 1;
  v7 = (unsigned int)qpQuat;
  if ( qpQuat )
    v7 = 1;
  v8 = v7 & v6;
  if ( (v7 & v6) != 0 )
  {
    v2.n64_u32[0] = LODWORD(mpMatrix->right.x);
    v3.n64_u32[0] = LODWORD(mpMatrix->up.y);
    z = mpMatrix->at.z;
    v10 = (float)(mpMatrix->right.x + v3.n64_f32[0]) + z;
    if ( v10 <= 0.0 )
    {
      LODWORD(v12) = vmax_f32(v2, v3).n64_u32[0];
      v13 = (void (__fastcall *)(RtQuat_0 *const, const RwMatrix *const))QuatFromXDiagDomMatrix;
      if ( v2.n64_f32[0] <= v3.n64_f32[0] )
        v13 = (void (__fastcall *)(RtQuat_0 *const, const RwMatrix *const))QuatFromYDiagDomMatrix;
      if ( v12 <= z )
        v13 = (void (__fastcall *)(RtQuat_0 *const, const RwMatrix *const))QuatFromZDiagDomMatrix;
      v13(qpQuat, mpMatrix);
    }
    else
    {
      v11 = _rwSqrt(v10 + 1.0);
      qpQuat->real = v11 * 0.5;
      qpQuat->imag.x = (float)(0.5 / v11) * (float)(mpMatrix->up.z - mpMatrix->at.y);
      qpQuat->imag.y = (float)(0.5 / v11) * (float)(mpMatrix->at.x - mpMatrix->right.z);
      qpQuat->imag.z = (float)(0.5 / v11) * (float)(mpMatrix->right.y - mpMatrix->up.x);
    }
  }
  return v8;
}
// 210F7C: variable 'v2' is possibly undefined
// 210F7C: variable 'v3' is possibly undefined

//----- (00210FB4) --------------------------------------------------------
RtQuat_0 *__fastcall QuatFromXDiagDomMatrix(RtQuat_0 *const qpQuat, const RwMatrix *const mpMatrix)
{
  float v4; // s2
  RtQuat_0 *result; // r0

  v4 = _rwSqrt((float)(mpMatrix->right.x - (float)(mpMatrix->up.y + mpMatrix->at.z)) + 1.0);
  result = qpQuat;
  qpQuat->imag.x = v4 * 0.5;
  qpQuat->real = (float)(0.5 / v4) * (float)(mpMatrix->up.z - mpMatrix->at.y);
  qpQuat->imag.y = (float)(0.5 / v4) * (float)(mpMatrix->right.y + mpMatrix->up.x);
  qpQuat->imag.z = (float)(0.5 / v4) * (float)(mpMatrix->right.z + mpMatrix->at.x);
  return result;
}

//----- (00211034) --------------------------------------------------------
RtQuat_0 *__fastcall QuatFromZDiagDomMatrix(RtQuat_0 *const qpQuat, const RwMatrix *const mpMatrix)
{
  float v4; // s2
  RtQuat_0 *result; // r0

  v4 = _rwSqrt((float)(mpMatrix->at.z - (float)(mpMatrix->right.x + mpMatrix->up.y)) + 1.0);
  result = qpQuat;
  qpQuat->imag.z = v4 * 0.5;
  qpQuat->real = (float)(0.5 / v4) * (float)(mpMatrix->right.y - mpMatrix->up.x);
  qpQuat->imag.x = (float)(0.5 / v4) * (float)(mpMatrix->at.x + mpMatrix->right.z);
  qpQuat->imag.y = (float)(0.5 / v4) * (float)(mpMatrix->at.y + mpMatrix->up.z);
  return result;
}

//----- (002110B4) --------------------------------------------------------
RtQuat_0 *__fastcall QuatFromYDiagDomMatrix(RtQuat_0 *const qpQuat, const RwMatrix *const mpMatrix)
{
  float v4; // s2
  RtQuat_0 *result; // r0

  v4 = _rwSqrt((float)(mpMatrix->up.y - (float)(mpMatrix->at.z + mpMatrix->right.x)) + 1.0);
  result = qpQuat;
  qpQuat->imag.y = v4 * 0.5;
  qpQuat->real = (float)(0.5 / v4) * (float)(mpMatrix->at.x - mpMatrix->right.z);
  qpQuat->imag.z = (float)(0.5 / v4) * (float)(mpMatrix->up.z + mpMatrix->at.y);
  qpQuat->imag.x = (float)(0.5 / v4) * (float)(mpMatrix->up.x + mpMatrix->right.y);
  return result;
}

//----- (00211134) --------------------------------------------------------
RtQuat_0 *__fastcall RtQuatRotate(RtQuat_0 *quat, const RwV3d_0 *axis, RwReal angle, RwOpCombineType_0 combineOp)
{
  RtQuat_0 *v4; // r4
  bool v5; // zf
  float v8; // s0
  float v9; // r0
  RwReal v10; // s4
  RwReal v11; // s0
  RwInt32 v12; // r0
  float v13; // r0
  float x; // s16
  float y; // s18
  float z; // s20
  float real; // s22
  float v18; // r0
  float v19; // s10
  float v20; // s2
  float v21; // s12
  RwReal v22; // s2
  RwReal v23; // s8
  RwReal v24; // s10
  RwReal v25; // s12
  float v26; // r0
  float v27; // s16
  float v28; // s18
  float v29; // s20
  float v30; // s22
  float v31; // r0
  float v32; // s2
  float v33; // s10
  float v34; // s12
  float v35; // s1
  RwReal v36; // s2
  RwReal v37; // s10
  RwReal v38; // s12
  RwReal v39; // s8
  RwV3d_0 v41; // [sp+0h] [bp-40h] BYREF
  float v42; // [sp+Ch] [bp-34h]

  v4 = quat;
  v5 = quat == 0;
  if ( quat )
    v5 = axis == 0;
  if ( v5 )
  {
    v4 = 0;
    v41.x = 0.0;
    v12 = _rwerror(-2147483626);
LABEL_12:
    LODWORD(v41.y) = v12;
    RwErrorSet((RwError_0 *)&v41);
    return v4;
  }
  if ( combineOp == rwCOMBINEPOSTCONCAT )
  {
    v13 = cosf(angle * 0.0087266);
    x = v4->imag.x;
    y = v4->imag.y;
    z = v4->imag.z;
    real = v4->real;
    v42 = v13;
    RwV3dNormalize(&v41, axis);
    v18 = sinf(angle * 0.0087266);
    v19 = z * (float)(v18 * v41.y);
    v20 = y * (float)(v18 * v41.z);
    v21 = y * (float)(v18 * v41.y);
    v41.x = v18 * v41.x;
    v41.y = v18 * v41.y;
    v41.z = v18 * v41.z;
    v22 = (float)((float)(v19 - v20) + (float)(x * v42)) + (float)(real * v41.x);
    v23 = (float)(real * v42) - (float)((float)(z * v41.z) + (float)((float)(x * v41.x) + v21));
    v24 = (float)((float)(y * v42) + (float)((float)(x * v41.z) - (float)(z * v41.x))) + (float)(real * v41.y);
    v25 = (float)((float)((float)(y * v41.x) - (float)(x * v41.y)) + (float)(z * v42)) + (float)(real * v41.z);
    v4->imag.x = v22;
    v4->imag.y = v24;
    v4->imag.z = v25;
    v4->real = v23;
    return v4;
  }
  if ( combineOp == rwCOMBINEPRECONCAT )
  {
    v26 = cosf(angle * 0.0087266);
    v27 = v4->imag.x;
    v28 = v4->imag.y;
    v29 = v4->imag.z;
    v30 = v4->real;
    v42 = v26;
    RwV3dNormalize(&v41, axis);
    v31 = sinf(angle * 0.0087266);
    v32 = v29 * (float)(v31 * v41.y);
    v33 = v28 * (float)(v31 * v41.z);
    v34 = v28 * (float)(v31 * v41.y);
    v41.x = v31 * v41.x;
    v41.y = v31 * v41.y;
    v35 = v27 * (float)(v31 * v41.z);
    v41.z = v31 * v41.z;
    v36 = (float)((float)(v30 * v41.x) + (float)(v33 - v32)) + (float)(v27 * v42);
    v37 = (float)(v30 * v42) - (float)((float)(v29 * v41.z) + (float)((float)(v27 * v41.x) + v34));
    v38 = (float)(v28 * v42) + (float)((float)((float)(v29 * v41.x) - v35) + (float)(v30 * v41.y));
    v39 = (float)((float)((float)(v27 * v41.y) - (float)(v28 * v41.x)) + (float)(v30 * v41.z)) + (float)(v29 * v42);
    v4->imag.x = v36;
    v4->imag.y = v38;
    v4->imag.z = v39;
    v4->real = v37;
    return v4;
  }
  if ( combineOp )
  {
    v4 = 0;
    v41.x = 0.0;
    v12 = _rwerror(-2147483645, "Invalid combination type");
    goto LABEL_12;
  }
  v8 = angle * 0.0087266;
  quat->real = cosf(angle * 0.0087266);
  RwV3dNormalize(&v4->imag, axis);
  v9 = sinf(v8);
  v10 = v9 * v4->imag.y;
  v11 = v9 * v4->imag.z;
  v4->imag.x = v9 * v4->imag.x;
  v4->imag.y = v10;
  v4->imag.z = v11;
  return v4;
}

//----- (002113C0) --------------------------------------------------------
const RtQuat_0 *__fastcall RtQuatQueryRotate(const RtQuat_0 *quat, RwV3d_0 *unitAxis, RwReal *angle)
{
  const RtQuat_0 *v3; // r4
  bool v6; // zf
  float v7; // r0
  float v8; // s16
  float v9; // r0
  float v10; // s0
  float v11; // s2
  RwError_0 v13; // [sp+0h] [bp-20h] BYREF

  v3 = quat;
  if ( !quat )
    goto LABEL_11;
  v6 = unitAxis == 0;
  if ( unitAxis )
    v6 = angle == 0;
  if ( v6 )
  {
LABEL_11:
    v3 = 0;
    v13.pluginID = 0;
    v13.errorCode = _rwerror(-2147483626);
    RwErrorSet(&v13);
  }
  else
  {
    v7 = _rwSqrt(
           (float)((float)(quat->imag.x * quat->imag.x) + (float)(quat->imag.y * quat->imag.y))
         + (float)(quat->imag.z * quat->imag.z));
    v8 = 0.0;
    if ( v7 > 0.0 )
      v8 = 1.0 / v7;
    v9 = atan2f(v7, v3->real);
    v10 = v9;
    if ( v9 <= 1.5708 )
    {
      unitAxis->x = v8 * v3->imag.x;
      unitAxis->y = v8 * v3->imag.y;
      v11 = v8 * v3->imag.z;
    }
    else
    {
      v10 = 3.1416 - v9;
      unitAxis->x = -(float)(v8 * v3->imag.x);
      unitAxis->y = -(float)(v8 * v3->imag.y);
      v11 = -(float)(v8 * v3->imag.z);
    }
    unitAxis->z = v11;
    *angle = v10 * 114.59;
  }
  return v3;
}

//----- (002114D0) --------------------------------------------------------
RwV3d_0 *__fastcall RtQuatTransformVectors(
        RwV3d_0 *vectorsOut,
        const RwV3d_0 *vectorsIn,
        const RwInt32 numPoints,
        const RtQuat_0 *quat)
{
  float x; // s4
  RwV3d_0 *v5; // r12
  float y; // s2
  float v7; // s8
  float z; // s0
  float v9; // s6
  float real; // s10
  float v11; // s12
  float v12; // s0
  float v13; // s2
  float v14; // s4
  float v15; // s14
  float v16; // s6
  float v17; // s8
  float v18; // s12
  float v19; // s6
  float v20; // s10
  float v21; // s12
  float v22; // s1
  float v23; // s3
  RwReal v24; // s7
  RwReal v25; // s9
  RwReal v26; // s14
  float v27; // s1
  RwReal v28; // s3
  RwReal v29; // s5
  RwReal v30; // s14
  float v31; // s1

  if ( numPoints >= 1 )
  {
    x = quat->imag.x;
    v5 = vectorsOut;
    y = quat->imag.y;
    v7 = x * x;
    z = quat->imag.z;
    v9 = y * y;
    real = quat->real;
    v11 = z * z;
    v12 = z + z;
    v13 = y + y;
    v14 = x + x;
    v15 = real * real;
    v16 = v7 + v9;
    v17 = real * v13;
    v18 = v16 + v11;
    v19 = real * v12;
    v20 = real * v14;
    v21 = v15 - v18;
    do
    {
      --numPoints;
      v22 = vectorsIn->y;
      v23 = vectorsIn->z;
      v24 = (float)(v19 * vectorsIn->x) - (float)(v20 * v23);
      v25 = (float)(v17 * v23) - (float)(v19 * v22);
      v26 = (float)(v20 * v22) - (float)(v17 * vectorsIn->x);
      v27 = (float)((float)(v14 * vectorsIn->x) + (float)(v13 * v22)) + (float)(v12 * v23);
      v5->x = v25;
      v5->y = v24;
      v5->z = v26;
      v28 = v25 + (float)(v27 * quat->imag.x);
      v5->x = v28;
      v29 = v24 + (float)(v27 * quat->imag.y);
      v5->y = v29;
      v30 = v26 + (float)(v27 * quat->imag.z);
      v5->z = v30;
      v5->x = v28 + (float)(v21 * vectorsIn->x);
      v5->y = v29 + (float)(v21 * vectorsIn->y);
      v31 = vectorsIn->z;
      ++vectorsIn;
      v5->z = v30 + (float)(v21 * v31);
      ++v5;
    }
    while ( numPoints );
  }
  return vectorsOut;
}

//----- (002115DA) --------------------------------------------------------
RwReal __fastcall RtQuatModulus(RtQuat_0 *q)
{
  return sub_198AF4(
           (float)(q->real * q->real)
         + (float)((float)((float)(q->imag.x * q->imag.x) + (float)(q->imag.y * q->imag.y))
                 + (float)(q->imag.z * q->imag.z)));
}

//----- (00211610) --------------------------------------------------------
RtSlerp_0 *__fastcall RtSlerpCreate(RwInt32 nMatRefMask)
{
  RtSlerp_0 *v2; // r0
  RtSlerp_0 *v3; // r4
  RwMatrix *v4; // r0
  RwMatrix *v5; // r0
  RwError_0 v7; // [sp+0h] [bp-10h] BYREF

  v2 = (RtSlerp_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(32);
  v3 = v2;
  if ( v2 )
  {
    v2->matRefMask = nMatRefMask;
    if ( (nMatRefMask & 1) != 0 )
    {
      v4 = 0;
    }
    else
    {
      v4 = RwMatrixCreate();
      nMatRefMask = v3->matRefMask;
    }
    v3->startMat = v4;
    if ( (nMatRefMask & 2) != 0 )
      v5 = 0;
    else
      v5 = RwMatrixCreate();
    v3->endMat = v5;
  }
  else
  {
    v3 = 0;
    v7.pluginID = 0;
    v7.errorCode = _rwerror(-2147483629, 32);
    RwErrorSet(&v7);
  }
  return v3;
}

//----- (00211674) --------------------------------------------------------
RtSlerp_0 *__fastcall RtSlerpInitialize(RtSlerp_0 *spSlerp, RwMatrix *mpMat1, RwMatrix *mpMat2)
{
  RwInt32 matRefMask; // r0
  RwMatrix *startMat; // r3
  __int64 v6; // d16
  __int64 v7; // d17
  __int64 v8; // d20
  __int64 v9; // d21
  __int64 v10; // d23
  __int64 v11; // d18
  __int64 v12; // d19
  RwMatrix *endMat; // r1
  __int64 v14; // d16
  __int64 v15; // d17
  __int64 v16; // d20
  __int64 v17; // d21
  __int64 v18; // d23
  __int64 v19; // d18
  __int64 v20; // d19
  RwMatrix dst; // [sp+4h] [bp-54h] BYREF
  RwV3d_0 center; // [sp+44h] [bp-14h] BYREF

  dst.up.y = 1.0;
  dst.at.z = 1.0;
  dst.up.x = 0.0;
  dst.right.z = 0.0;
  dst.right.x = 1.0;
  dst.right.y = 0.0;
  dst.up.z = 0.0;
  dst.at.x = 0.0;
  dst.at.y = 0.0;
  dst.flags = -1;
  memset(&dst.pos, 0, sizeof(dst.pos));
  matRefMask = spSlerp->matRefMask;
  if ( (matRefMask & 1) != 0 )
  {
    spSlerp->startMat = mpMat1;
    if ( (matRefMask & 2) != 0 )
      goto LABEL_3;
LABEL_5:
    endMat = spSlerp->endMat;
    v14 = *(_QWORD *)&mpMat2->right.x;
    v15 = *(_QWORD *)&mpMat2->right.z;
    v16 = *(_QWORD *)&mpMat2->up.x;
    v17 = *(_QWORD *)&mpMat2->up.z;
    v18 = *(_QWORD *)&mpMat2->pos.z;
    v19 = *(_QWORD *)&mpMat2->at.x;
    v20 = *(_QWORD *)&mpMat2->at.z;
    *(_QWORD *)&endMat->pos.x = *(_QWORD *)&mpMat2->pos.x;
    *(_QWORD *)&endMat->pos.z = v18;
    *(_QWORD *)&endMat->at.x = v19;
    *(_QWORD *)&endMat->at.z = v20;
    *(_QWORD *)&endMat->right.x = v14;
    *(_QWORD *)&endMat->right.z = v15;
    endMat = (RwMatrix *)((char *)endMat + 16);
    *(_QWORD *)&endMat->right.x = v16;
    *(_QWORD *)&endMat->right.z = v17;
    goto LABEL_6;
  }
  startMat = spSlerp->startMat;
  v6 = *(_QWORD *)&mpMat1->right.x;
  v7 = *(_QWORD *)&mpMat1->right.z;
  v8 = *(_QWORD *)&mpMat1->up.x;
  v9 = *(_QWORD *)&mpMat1->up.z;
  v10 = *(_QWORD *)&mpMat1->pos.z;
  v11 = *(_QWORD *)&mpMat1->at.x;
  v12 = *(_QWORD *)&mpMat1->at.z;
  *(_QWORD *)&startMat->pos.x = *(_QWORD *)&mpMat1->pos.x;
  *(_QWORD *)&startMat->pos.z = v10;
  *(_QWORD *)&startMat->at.x = v11;
  *(_QWORD *)&startMat->at.z = v12;
  *(_QWORD *)&startMat->right.x = v6;
  *(_QWORD *)&startMat->right.z = v7;
  startMat = (RwMatrix *)((char *)startMat + 16);
  *(_QWORD *)&startMat->right.x = v8;
  *(_QWORD *)&startMat->right.z = v9;
  if ( (spSlerp->matRefMask & 2) == 0 )
    goto LABEL_5;
LABEL_3:
  spSlerp->endMat = mpMat2;
LABEL_6:
  RwMatrixInvert(&dst, spSlerp->startMat);
  RwMatrixTransform(&dst, spSlerp->endMat, rwCOMBINEPOSTCONCAT);
  RwMatrixQueryRotate(&dst, &spSlerp->axis, &spSlerp->angle, &center);
  spSlerp->useLerp = spSlerp->angle < 2.0;
  return spSlerp;
}

//----- (00211764) --------------------------------------------------------
void __fastcall RtSlerpDestroy(RtSlerp_0 *spSlerp)
{
  RwInt32 matRefMask; // r0

  matRefMask = spSlerp->matRefMask;
  if ( (matRefMask & 1) == 0 )
  {
    RwMatrixDestroy(spSlerp->startMat);
    matRefMask = spSlerp->matRefMask;
  }
  if ( (matRefMask & 2) == 0 )
    RwMatrixDestroy(spSlerp->endMat);
  (*((void (__fastcall **)(RtSlerp_0 *))RwEngineInstance + 76))(spSlerp);
}

//----- (0021179C) --------------------------------------------------------
RwMatrix *__fastcall RtSlerpGetMatrix(RtSlerp_0 *spSlerp, RwMatrix *mpResultMat, RwReal nDelta)
{
  __int64 v5; // kr00_8
  float v6; // s14
  float v7; // s1
  float v8; // s5
  float v9; // s7
  float v10; // s12
  float v11; // s13
  float v12; // s15
  float v13; // s18
  float v14; // s20
  float v15; // s22
  float v16; // s24
  float v17; // s9
  float v18; // s8
  float v19; // s26
  float v20; // s4
  float v21; // s28
  float v22; // s0
  float v23; // s30
  RwMatrix *startMat; // r0
  __int64 *v25; // r1
  __int64 *p_at; // r2
  _QWORD *p_x; // r0
  __int64 v28; // d16
  __int64 v29; // d17
  __int64 v30; // d23
  __int64 v31; // d18
  __int64 v32; // d19
  __int64 v33; // d20
  __int64 v34; // d21
  __int64 v36; // kr08_8
  float v37; // s18
  float v38; // s20
  __int64 v39; // d18
  __int64 v40; // d19
  RwMatrix *v41; // r3
  float v42; // s24
  float v43; // s26
  float v44; // s28
  __int64 v45; // d23
  __int64 v46; // d16
  __int64 v47; // d17
  __int64 v48; // d20
  __int64 v49; // d21
  float v50; // s22

  if ( nDelta <= 0.0 )
  {
    startMat = spSlerp->startMat;
    if ( startMat == mpResultMat )
      return mpResultMat;
    goto LABEL_8;
  }
  if ( nDelta >= 1.0 )
  {
    startMat = spSlerp->endMat;
    if ( startMat == mpResultMat )
      return mpResultMat;
LABEL_8:
    v25 = (__int64 *)startMat;
    p_at = (__int64 *)&startMat->at;
    p_x = (_QWORD *)&startMat->pos.x;
    v28 = *v25;
    v29 = v25[1];
    v25 += 2;
    v30 = p_x[1];
    v31 = *p_at;
    v32 = p_at[1];
    v33 = *v25;
    v34 = v25[1];
    *(_QWORD *)&mpResultMat->pos.x = *p_x;
    *(_QWORD *)&mpResultMat->pos.z = v30;
    *(_QWORD *)&mpResultMat->at.x = v31;
    *(_QWORD *)&mpResultMat->at.z = v32;
    *(_QWORD *)&mpResultMat->right.x = v28;
    *(_QWORD *)&mpResultMat->right.z = v29;
    *(_QWORD *)&mpResultMat->up.x = v33;
    *(_QWORD *)&mpResultMat->up.z = v34;
    return mpResultMat;
  }
  if ( spSlerp->useLerp )
  {
    v5 = *(_QWORD *)&spSlerp->startMat;
    v6 = *(float *)(v5 + 8);
    v7 = *(float *)(v5 + 16);
    v8 = *(float *)(HIDWORD(v5) + 8);
    v9 = *(float *)(HIDWORD(v5) + 16);
    v10 = (float)(*(float *)(HIDWORD(v5) + 4) - *(float *)(v5 + 4)) * nDelta;
    v11 = *(float *)(v5 + 32);
    v12 = *(float *)(v5 + 36);
    v13 = *(float *)(v5 + 40);
    v14 = *(float *)(HIDWORD(v5) + 32);
    v15 = *(float *)(HIDWORD(v5) + 36);
    v16 = *(float *)(HIDWORD(v5) + 40);
    v17 = *(float *)(v5 + 24);
    v18 = (float)(*(float *)(HIDWORD(v5) + 48) - *(float *)(v5 + 48)) * nDelta;
    v19 = *(float *)(HIDWORD(v5) + 24);
    v20 = (float)(*(float *)(HIDWORD(v5) + 52) - *(float *)(v5 + 52)) * nDelta;
    v21 = *(float *)(v5 + 20);
    v22 = (float)(*(float *)(HIDWORD(v5) + 56) - *(float *)(v5 + 56)) * nDelta;
    v23 = *(float *)(HIDWORD(v5) + 20);
    mpResultMat->right.x = *(float *)v5 + (float)((float)(*(float *)HIDWORD(v5) - *(float *)v5) * nDelta);
    mpResultMat->right.y = v10 + spSlerp->startMat->right.y;
    mpResultMat->right.z = (float)((float)(v8 - v6) * nDelta) + spSlerp->startMat->right.z;
    mpResultMat->up.x = (float)((float)(v9 - v7) * nDelta) + spSlerp->startMat->up.x;
    mpResultMat->up.y = (float)((float)(v23 - v21) * nDelta) + spSlerp->startMat->up.y;
    mpResultMat->up.z = (float)((float)(v19 - v17) * nDelta) + spSlerp->startMat->up.z;
    mpResultMat->at.x = (float)((float)(v14 - v11) * nDelta) + spSlerp->startMat->at.x;
    mpResultMat->at.y = (float)((float)(v15 - v12) * nDelta) + spSlerp->startMat->at.y;
    mpResultMat->at.z = (float)((float)(v16 - v13) * nDelta) + spSlerp->startMat->at.z;
    mpResultMat->pos.x = v18 + spSlerp->startMat->pos.x;
    mpResultMat->pos.y = v20 + spSlerp->startMat->pos.y;
    mpResultMat->pos.z = v22 + spSlerp->startMat->pos.z;
    RwV3dNormalize(&mpResultMat->right, &mpResultMat->right);
    RwV3dNormalize(&mpResultMat->up, &mpResultMat->up);
    RwV3dNormalize(&mpResultMat->at, &mpResultMat->at);
  }
  else
  {
    v36 = *(_QWORD *)&spSlerp->startMat;
    v37 = *(float *)(HIDWORD(v36) + 48);
    v38 = *(float *)(HIDWORD(v36) + 52);
    v39 = *(_QWORD *)(v36 + 32);
    v40 = *(_QWORD *)(v36 + 40);
    v41 = spSlerp->startMat;
    v42 = *(float *)(v36 + 48);
    v43 = *(float *)(v36 + 52);
    v44 = *(float *)(v36 + 56);
    v45 = *(_QWORD *)(v36 + 56);
    v46 = *(_QWORD *)&v41->right.x;
    v47 = *(_QWORD *)&v41->right.z;
    v41 = (RwMatrix *)((char *)v41 + 16);
    v48 = *(_QWORD *)&v41->right.x;
    v49 = *(_QWORD *)&v41->right.z;
    v50 = *(float *)(HIDWORD(v36) + 56);
    *(_QWORD *)&mpResultMat->pos.x = *(_QWORD *)(v36 + 48);
    *(_QWORD *)&mpResultMat->pos.z = v45;
    *(_QWORD *)&mpResultMat->at.x = v39;
    *(_QWORD *)&mpResultMat->at.z = v40;
    *(_QWORD *)&mpResultMat->right.x = v46;
    *(_QWORD *)&mpResultMat->right.z = v47;
    *(_QWORD *)&mpResultMat->up.x = v48;
    *(_QWORD *)&mpResultMat->up.z = v49;
    mpResultMat->pos.x = 0.0;
    mpResultMat->pos.y = 0.0;
    mpResultMat->pos.z = 0.0;
    RwMatrixRotate(mpResultMat, &spSlerp->axis, spSlerp->angle * nDelta, rwCOMBINEPOSTCONCAT);
    mpResultMat->pos.x = v42 + (float)((float)(v37 - v42) * nDelta);
    mpResultMat->pos.y = v43 + (float)((float)(v38 - v43) * nDelta);
    mpResultMat->pos.z = v44 + (float)((float)(v50 - v44) * nDelta);
  }
  return mpResultMat;
}

//----- (00211A3C) --------------------------------------------------------
RtSlerp_0 *__fastcall RtSlerpSetLerp(RtSlerp_0 *spSlerp, RwBool useLerp)
{
  spSlerp->useLerp = useLerp;
  return spSlerp;
}

//----- (00211A40) --------------------------------------------------------
void __fastcall RtQuatSetupSlerpCache(RtQuat_0 *qpFrom, RtQuat_0 *qpTo, RtQuatSlerpCache_0 *sCache)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  __int64 v5; // d17
  float real; // s2
  float v8; // s16
  __int64 v9; // d17
  unsigned int v10; // r1
  int *v11; // r1
  float v12; // s0
  RwReal v13; // s20
  RwReal v14; // r0
  float v15; // s2
  RwReal v16; // s2
  RwReal v17; // r0
  RwBool v18; // r0
  float v19; // s0

  v5 = *(_QWORD *)&qpFrom->imag.z;
  *(_QWORD *)&sCache->raFrom.imag.x = *(_QWORD *)&qpFrom->imag.x;
  *(_QWORD *)&sCache->raFrom.imag.z = v5;
  real = qpTo->real;
  v3.n64_f32[0] = (float)((float)((float)(qpFrom->imag.x * qpTo->imag.x) + (float)(qpFrom->imag.y * qpTo->imag.y))
                        + (float)(qpFrom->imag.z * qpTo->imag.z))
                + (float)(qpFrom->real * real);
  if ( v3.n64_f32[0] >= 0.0 )
  {
    v4.n64_u32[0] = 1.0;
    v9 = *(_QWORD *)&qpTo->imag.z;
    *(_QWORD *)&sCache->raTo.imag.x = *(_QWORD *)&qpTo->imag.x;
    *(_QWORD *)&sCache->raTo.imag.z = v9;
    LODWORD(v8) = vmin_f32(v3, v4).n64_u32[0];
  }
  else
  {
    v8 = -v3.n64_f32[0];
    sCache->raTo.real = -real;
    sCache->raTo.imag.x = -qpTo->imag.x;
    sCache->raTo.imag.y = -qpTo->imag.y;
    if ( v3.n64_f32[0] < -1.0 )
      v8 = 1.0;
    sCache->raTo.imag.z = -qpTo->imag.z;
  }
  v10 = LODWORD(v8) & 0x7FFFFFFF;
  if ( (LODWORD(v8) & 0x7FFFFFFFu) < 0x3F800000 )
  {
    if ( HIBYTE(v10) > 0x3Eu )
    {
      if ( SLODWORD(v8) <= -1 )
      {
        v16 = (float)(v8 + 1.0) * 0.5;
        v17 = _rwSqrt(v16);
        v12 = (float)((float)(v17
                            + (float)((float)((float)((float)(v16
                                                            * (float)((float)(v16
                                                                            * (float)((float)(v16
                                                                                            * (float)((float)(v16 * (float)((float)(v16 * (float)((float)(v16 * 0.000034793) + 0.00079154)) + -0.040056)) + 0.20121))
                                                                                    + -0.32557))
                                                                    + 0.16667))
                                                    / (float)((float)(v16
                                                                    * (float)((float)(v16
                                                                                    * (float)((float)(v16 * (float)((float)(v16 * 0.077038) + -0.68828))
                                                                                            + 2.0209))
                                                                            + -2.4034))
                                                            + 1.0))
                                            * v17)
                                    + -0.000000075498))
                    * -2.0)
            + 3.1416;
      }
      else
      {
        v13 = (float)(1.0 - v8) * 0.5;
        v14 = _rwSqrt(v13);
        v15 = (float)((float)((float)(v13
                                    * (float)((float)(v13
                                                    * (float)((float)(v13
                                                                    * (float)((float)(v13
                                                                                    * (float)((float)(v13 * (float)((float)(v13 * 0.000034793) + 0.00079154))
                                                                                            + -0.040056))
                                                                            + 0.20121))
                                                            + -0.32557))
                                            + 0.16667))
                            / (float)((float)(v13
                                            * (float)((float)(v13
                                                            * (float)((float)(v13
                                                                            * (float)((float)(v13 * 0.077038) + -0.68828))
                                                                    + 2.0209))
                                                    + -2.4034))
                                    + 1.0))
                    * v14)
            + (float)((float)(v13
                            - (float)(COERCE_FLOAT(LODWORD(v14) & 0xFFFFF000) * COERCE_FLOAT(LODWORD(v14) & 0xFFFFF000)))
                    / (float)(v14 + COERCE_FLOAT(LODWORD(v14) & 0xFFFFF000)));
        v12 = (float)(v15 + COERCE_FLOAT(LODWORD(v14) & 0xFFFFF000))
            + (float)(v15 + COERCE_FLOAT(LODWORD(v14) & 0xFFFFF000));
      }
    }
    else if ( v10 > 0x23000000 )
    {
      v12 = 1.5708
          - (float)(v8
                  - (float)(0.000000075498
                          - (float)(v8
                                  * (float)((float)((float)(v8 * v8)
                                                  * (float)((float)((float)(v8 * v8)
                                                                  * (float)((float)((float)(v8 * v8)
                                                                                  * (float)((float)((float)(v8 * v8)
                                                                                                  * (float)((float)((float)(v8 * v8) * (float)((float)((float)(v8 * v8) * 0.000034793) + 0.00079154)) + -0.040056))
                                                                                          + 0.20121))
                                                                          + -0.32557))
                                                          + 0.16667))
                                          / (float)((float)((float)(v8 * v8)
                                                          * (float)((float)((float)(v8 * v8)
                                                                          * (float)((float)((float)(v8 * v8)
                                                                                          * (float)((float)((float)(v8 * v8) * 0.077038)
                                                                                                  + -0.68828))
                                                                                  + 2.0209))
                                                                  + -2.4034))
                                                  + 1.0)))));
    }
    else
    {
      v12 = 1.5708;
    }
  }
  else
  {
    v11 = dword_211E08;
    if ( SLODWORD(v8) > 0 )
      v11 = &dword_211E08[1];
    v12 = *(float *)v11;
  }
  v18 = 0;
  sCache->omega = v12;
  if ( v8 >= 0.99999 )
    v18 = 1;
  sCache->nearlyZeroOm = v18;
  if ( v8 < 0.99999 )
  {
    v19 = 1.0
        / (float)(v12
                + (float)((float)(v12 * (float)(v12 * v12))
                        * (float)((float)((float)(v12 * v12)
                                        * (float)((float)((float)(v12 * v12)
                                                        * (float)((float)((float)(v12 * v12)
                                                                        * (float)((float)((float)(v12 * v12)
                                                                                        * (float)((float)((float)(v12 * v12) * 1.5897e-10)
                                                                                                + -0.000000025051))
                                                                                + 0.0000027557))
                                                                + -0.00019841))
                                                + 0.0083333))
                                + -0.16667)));
    sCache->raFrom = (RtQuat_0)vmulq_n_f32((float32x4_t)sCache->raFrom, v19);
    sCache->raTo = (RtQuat_0)vmulq_n_f32((float32x4_t)sCache->raTo, v19);
  }
}
// 211AF0: variable 'v3' is possibly undefined
// 211AF0: variable 'v4' is possibly undefined
// 211E08: using guessed type int dword_211E08[2];

//----- (00211E2C) --------------------------------------------------------
void __fastcall RtQuatSetupSlerpArgandCache(RtQuat_0 *qpFrom, RtQuat_0 *qpTo, RtQuatSlerpArgandCache_0 *sArgandCache)
{
  float x; // s16
  float y; // s18
  float z; // s20
  float real; // s22
  float v9; // r0
  float v10; // r1
  float v11; // s22
  float v12; // s24
  float v13; // s0
  float v14; // s2
  float v15; // s16
  float v16; // r0
  RwReal v17; // s0
  RwReal v18; // s2
  float v19; // s4
  float v20; // s10
  RwReal v21; // s0
  RwReal v22; // s2

  x = qpTo->imag.x;
  y = qpTo->imag.y;
  z = qpTo->imag.z;
  real = qpTo->real;
  if ( (float)((float)((float)((float)(qpFrom->imag.x * qpTo->imag.x) + (float)(qpFrom->imag.y * y))
                     + (float)(qpFrom->imag.z * z))
             + (float)(qpFrom->real * real)) < 0.0 )
  {
    z = -z;
    y = -y;
    x = -x;
    real = -real;
  }
  v9 = _rwSqrt((float)((float)(x * x) + (float)(y * y)) + (float)(z * z));
  v10 = real;
  v11 = v9;
  v12 = 0.0;
  v13 = atan2f(v9, v10) / v9;
  v14 = 0.0;
  if ( v11 > 0.0 )
    v14 = v13;
  sArgandCache->logTo.real = 0.0;
  sArgandCache->logTo.imag.x = x * v14;
  sArgandCache->logTo.imag.y = y * v14;
  sArgandCache->logTo.imag.z = z * v14;
  v15 = _rwSqrt(
          (float)((float)(qpFrom->imag.x * qpFrom->imag.x) + (float)(qpFrom->imag.y * qpFrom->imag.y))
        + (float)(qpFrom->imag.z * qpFrom->imag.z));
  v16 = atan2f(v15, qpFrom->real);
  if ( v15 > 0.0 )
    v12 = v16 / v15;
  v17 = qpFrom->imag.x * v12;
  sArgandCache->logBase.imag.x = v17;
  v18 = v12 * qpFrom->imag.y;
  sArgandCache->logBase.imag.y = v18;
  v19 = v12 * qpFrom->imag.z;
  v20 = sArgandCache->logTo.imag.z;
  v21 = sArgandCache->logTo.imag.x - v17;
  v22 = sArgandCache->logTo.imag.y - v18;
  sArgandCache->logBase.real = sArgandCache->logTo.real;
  sArgandCache->logBase.imag.x = v21;
  sArgandCache->logBase.imag.y = v22;
  sArgandCache->logBase.imag.z = v20 - v19;
}

//----- (00211F8C) --------------------------------------------------------
RwCamera_0 *__fastcall RtTileRender(
        RwCamera_0 *camera,
        RwInt32 iWidth,
        RwInt32 iHeight,
        RwInt32 tWidth,
        RwInt32 tHeight,
        RtTileRenderCallBack renderCallBack,
        RtTileArchiveCallBack archiveCallBack,
        void *pData)
{
  int v8; // r9
  float32x2_t v9; // d1
  float32x2_t v10; // d2
  float32x2_t v11; // d9
  RwCamera_0 *v16; // r6
  bool v17; // cc
  bool v18; // cc
  RwCamera_0 *v19; // r4
  unsigned __int64 v20; // d8
  float x; // s20
  float y; // s22
  RwRaster_0 *v23; // r0
  RwRaster_0 *v24; // r6
  RwRaster_0 *v25; // r4
  RwImage_0 *v26; // r0
  RwFrame_0 *v27; // r0
  __int64 v28; // d18
  __int64 v29; // d19
  __int64 v30; // d17
  __int64 v31; // d20
  __int64 v32; // d21
  __int64 v33; // d22
  __int64 v34; // d23
  float v35; // s0
  float v36; // s2
  float v37; // s8
  float v38; // s10
  RwInt32 v39; // r1
  RwInt32 v40; // r0
  float v41; // s24
  int v42; // r1
  int *v43; // r0
  RwStream_0 *v44; // r0
  float v45; // s2
  int *v46; // r8
  RwInt32 v47; // r9
  int v48; // r0
  float v49; // s0
  float v50; // s26
  RwInt32 v51; // r6
  float v52; // s21
  float32x2_t v53; // d15
  RwInt32 v54; // r4
  float v55; // s2
  float v56; // s4
  RwReal v57; // s0
  RwReal v58; // s2
  RwReal v59; // s4
  RwReal v60; // s2
  RwReal v61; // s4
  bool v62; // zf
  RwRaster_0 *v64; // [sp+4h] [bp-F4h]
  int v65; // [sp+8h] [bp-F0h]
  RwMatrix *matrix; // [sp+Ch] [bp-ECh]
  RwFrame_0 *frame; // [sp+10h] [bp-E8h]
  RwRaster_0 *raster; // [sp+18h] [bp-E0h]
  RwImage_0 *rastera; // [sp+18h] [bp-E0h]
  RwMatrix *LTM; // [sp+1Ch] [bp-DCh]
  RwRaster_0 *frameBuffer; // [sp+20h] [bp-D8h]
  RwRaster_0 *v72; // [sp+20h] [bp-D8h]
  RwCameraProjection_0 projectionType; // [sp+24h] [bp-D4h]
  RwCamera_0 *object; // [sp+28h] [bp-D0h]
  int v75[2]; // [sp+2Ch] [bp-CCh] BYREF
  RwStream_0 *stream; // [sp+34h] [bp-C4h]
  RwInt32 v77; // [sp+38h] [bp-C0h]
  RwInt32 v78; // [sp+3Ch] [bp-BCh]
  RwInt32 v79; // [sp+40h] [bp-B8h]
  int v80; // [sp+44h] [bp-B4h]
  int v81; // [sp+48h] [bp-B0h]
  int v82; // [sp+4Ch] [bp-ACh]
  size_t v83; // [sp+50h] [bp-A8h]
  RwInt32 v84; // [sp+54h] [bp-A4h]
  RwInt32 v85; // [sp+58h] [bp-A0h]
  void *v86; // [sp+5Ch] [bp-9Ch]
  RwRect_0 rect; // [sp+60h] [bp-98h] BYREF
  RwV2d_0 viewWindow; // [sp+70h] [bp-88h] BYREF
  RwV2d_0 buffer; // [sp+78h] [bp-80h] BYREF
  unsigned int v90; // [sp+80h] [bp-78h]
  int v91; // [sp+84h] [bp-74h]
  unsigned int v92; // [sp+88h] [bp-70h]
  int v93; // [sp+8Ch] [bp-6Ch]
  int v94; // [sp+90h] [bp-68h]
  int v95; // [sp+94h] [bp-64h]

  v16 = 0;
  if ( iWidth >= tWidth )
  {
    v17 = iWidth < 1;
    if ( iWidth >= 1 )
      v17 = iHeight < 1;
    if ( !v17 )
    {
      v18 = tWidth < 1;
      if ( tWidth >= 1 )
      {
        v8 = tHeight;
        v18 = tHeight < 1;
      }
      if ( !v18 )
      {
        v16 = 0;
        if ( camera )
        {
          if ( iHeight >= v8 )
          {
            if ( iWidth % tWidth <= 0 )
            {
              v16 = 0;
              if ( iHeight % v8 <= 0 )
              {
                stream = 0;
                v75[0] = 1;
                v86 = 0;
                v19 = RwCameraCreate();
                projectionType = camera->projectionType;
                frameBuffer = camera->frameBuffer;
                raster = camera->zBuffer;
                LTM = RwFrameGetLTM((RwFrame_0 *)camera->object.object.parent);
                *(RwReal *)&v20 = camera->viewWindow.x;
                v11.n64_u32[0] = LODWORD(camera->viewWindow.y);
                x = camera->viewOffset.x;
                y = camera->viewOffset.y;
                v19->beginUpdate = camera->beginUpdate;
                v19->endUpdate = camera->endUpdate;
                RwCameraSetNearClipPlane(v19, camera->nearPlane);
                RwCameraSetFarClipPlane(v19, camera->farPlane);
                object = v19;
                RwCameraSetProjection(v19, projectionType);
                if ( frameBuffer->width < tWidth )
                  goto LABEL_54;
                v16 = 0;
                if ( frameBuffer->height < v8 )
                  goto LABEL_54;
                rect.x = 0;
                rect.y = 0;
                rect.w = tWidth;
                rect.h = v8;
                v23 = RwRasterCreate(0, 0, 0, 2);
                v24 = v23;
                if ( v23 )
                {
                  RwRasterSubRaster(v23, frameBuffer, &rect);
                  v72 = v24;
                  v19->frameBuffer = v24;
                  v16 = 0;
                  v25 = RwRasterCreate(0, 0, 0, 1);
                  RwRasterSubRaster(v25, raster, &rect);
                  object->zBuffer = v25;
                  v26 = RwImageCreate(tWidth, v8, 32);
                  if ( v26 )
                  {
                    rastera = v26;
                    if ( RwImageAllocatePixels(v26) && (v27 = RwFrameCreate()) != 0 )
                    {
                      v28 = *(_QWORD *)&LTM->at.x;
                      v29 = *(_QWORD *)&LTM->at.z;
                      v30 = *(_QWORD *)&LTM->right.z;
                      v31 = *(_QWORD *)&LTM->up.x;
                      v32 = *(_QWORD *)&LTM->up.z;
                      v33 = *(_QWORD *)&LTM->pos.x;
                      v34 = *(_QWORD *)&LTM->pos.z;
                      matrix = &v27->modelling;
                      *(_QWORD *)&v27->modelling.right.x = *(_QWORD *)&LTM->right.x;
                      *(_QWORD *)&v27->modelling.right.z = v30;
                      *(_QWORD *)&v27->modelling.pos.x = v33;
                      *(_QWORD *)&v27->modelling.pos.z = v34;
                      *(_QWORD *)&v27->modelling.at.x = v28;
                      *(_QWORD *)&v27->modelling.at.z = v29;
                      *(_QWORD *)&v27->modelling.up.x = v31;
                      *(_QWORD *)&v27->modelling.up.z = v32;
                      frame = v27;
                      _rwObjectHasFrameSetFrame(object, v27);
                      if ( iWidth <= iHeight )
                      {
                        v36 = *(float *)&v20 / (float)(iWidth / tWidth);
                        v35 = (float)(v36 * (float)v8) / (float)tWidth;
                      }
                      else
                      {
                        v35 = v11.n64_f32[0] / (float)(iHeight / v8);
                        v36 = (float)(v35 * (float)tWidth) / (float)v8;
                      }
                      v65 = iHeight / v8;
                      viewWindow.x = v36;
                      v37 = v11.n64_f32[0] / *(float *)&v20;
                      v38 = (float)iHeight / (float)iWidth;
                      viewWindow.y = v35;
                      if ( (float)(v11.n64_f32[0] / *(float *)&v20) <= v38 )
                      {
                        v40 = iWidth;
                        v39 = (int)(float)((float)(v37 / v38) * (float)iHeight);
                      }
                      else
                      {
                        v39 = iHeight;
                        v40 = (int)(float)((float)(v38 / v37) * (float)iWidth);
                      }
                      v84 = v40;
                      v85 = v39;
                      RwCameraSetViewWindow(object, &viewWindow);
                      v41 = viewWindow.y;
                      v42 = iHeight / v8;
                      v43 = (int *)pData;
                      viewWindow.y = v41 + v41;
                      viewWindow.x = viewWindow.x + viewWindow.x;
                      if ( archiveCallBack == RtTileDefaultArchive )
                      {
                        v43 = (int *)pData;
                        if ( pData )
                        {
                          v95 = 0;
                          v93 = 0x1000000;
                          v94 = 0x1000000;
                          v91 = 402653184;
                          LODWORD(buffer.y) = bswap32(iWidth);
                          v90 = bswap32(iHeight);
                          v82 = iHeight / v8;
                          buffer.x = -4.7387e-26;
                          v81 = iWidth / tWidth;
                          v79 = tWidth;
                          v80 = v8;
                          v77 = iWidth;
                          v75[1] = (int)pData;
                          v78 = iHeight;
                          v92 = bswap32(((((24 * iWidth) | 7) / 8 + 1) & 0xFFFFFFFE) * iHeight);
                          v44 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMWRITE, pData);
                          stream = v44;
                          if ( v44 )
                          {
                            RwStreamWrite(v44, &buffer, 0x20u);
                            v83 = 3 * tWidth * v8 * v81;
                            v86 = (void *)(*((int (**)(void))RwEngineInstance + 75))();
                            memset(v86, 0, v83);
                          }
                          else
                          {
                            v86 = 0;
                          }
                          v42 = iHeight / v8;
                          v43 = v75;
                        }
                      }
                      if ( v42 < 1 )
                      {
LABEL_46:
                        v16 = camera;
                      }
                      else
                      {
                        v45 = viewWindow.y;
                        v46 = v43;
                        v47 = 0;
                        v48 = iWidth / tWidth;
                        v49 = viewWindow.x;
                        v64 = v25;
                        v50 = -(float)(v11.n64_f32[0] + (float)(viewWindow.y * -0.5));
                        while ( v48 < 1 )
                        {
LABEL_45:
                          v10.n64_f32[0] = v45 * 0.5;
                          ++v47;
                          v50 = v50 + v45;
                          v11.n64_f32[0] = v11.n64_f32[0] - (float)(v45 * 0.5);
                          LODWORD(v41) = vmin_f32(v11, v10).n64_u32[0];
                          if ( v47 >= v42 )
                            goto LABEL_46;
                        }
                        v9.n64_f32[0] = v49 * 0.5;
                        v51 = 0;
                        v52 = -v50;
                        *((float *)&v20 + 1) = *(float *)&v20 - (float)(v49 * 0.5);
                        v53.n64_u64[0] = v20;
                        while ( 1 )
                        {
                          v54 = v48;
                          if ( v41 > 0.0 )
                          {
                            v54 = v48;
                            if ( v9.n64_f32[0] > 0.0 )
                            {
                              v55 = *((float *)&v20 + 1) * LTM->right.y;
                              v56 = *((float *)&v20 + 1) * LTM->right.z;
                              v57 = (float)(*((float *)&v20 + 1) * LTM->right.x) + LTM->pos.x;
                              frame->modelling.pos.x = v57;
                              v58 = v55 + LTM->pos.y;
                              frame->modelling.pos.y = v58;
                              v59 = v56 + LTM->pos.z;
                              frame->modelling.pos.z = v59;
                              v60 = v58 + (float)(LTM->up.y * v52);
                              v61 = v59 + (float)(LTM->up.z * v52);
                              frame->modelling.pos.x = v57 + (float)(LTM->up.x * v52);
                              frame->modelling.pos.y = v60;
                              frame->modelling.pos.z = v61;
                              RwMatrixOptimize(matrix, 0);
                              if ( projectionType == rwPERSPECTIVE )
                              {
                                buffer.y = y + v50;
                                buffer.x = x + *((float *)&v20 + 1);
                                RwCameraSetViewOffset(object, &buffer);
                              }
                              RwFrameUpdateObjects(frame);
                              v54 = v51;
                              if ( renderCallBack(object, v51, v47, pData) != object )
                                break;
                            }
                          }
                          RwImageSetFromRaster(rastera, v72);
                          v62 = (int)archiveCallBack(rastera, v54, v47, v46) == 0;
                          v48 = iWidth / tWidth;
                          if ( v62 )
                            break;
                          v49 = viewWindow.x;
                          v51 = v54 + 1;
                          v9.n64_f32[0] = viewWindow.x * 0.5;
                          *((float *)&v20 + 1) = *((float *)&v20 + 1) - viewWindow.x;
                          v53.n64_f32[0] = v53.n64_f32[0] - (float)(viewWindow.x * 0.5);
                          v9.n64_u64[0] = vmin_f32(v53, v9).n64_u64[0];
                          if ( v54 + 1 >= iWidth / tWidth )
                          {
                            v45 = viewWindow.y;
                            v25 = v64;
                            v42 = v65;
                            goto LABEL_45;
                          }
                        }
                        v16 = 0;
                        v25 = v64;
                      }
                      RwFrameDestroy(frame);
                    }
                    else
                    {
                      v16 = 0;
                    }
                    RwImageDestroy(rastera);
                  }
                  RwRasterDestroy(v72);
                }
                else
                {
                  v16 = 0;
                  v25 = RwRasterCreate(0, 0, 0, 1);
                }
                if ( v25 )
                  RwRasterDestroy(v25);
                if ( object )
LABEL_54:
                  RwCameraDestroy(object);
                if ( stream )
                  RwStreamClose(stream, 0);
                if ( v86 )
                  (*((void (**)(void))RwEngineInstance + 76))();
              }
            }
            else
            {
              return 0;
            }
          }
        }
      }
    }
  }
  return v16;
}
// 211FD6: variable 'v8' is possibly undefined
// 212406: variable 'v9' is possibly undefined
// 212428: variable 'v11' is possibly undefined
// 212428: variable 'v10' is possibly undefined

//----- (00212498) --------------------------------------------------------
RwImage_0 *__fastcall RtTileDefaultArchive(RwImage_0 *image, RwInt32 x, RwInt32 y, void *pData)
{
  RwInt32 v6; // r0
  int v7; // r6
  int v8; // r9
  RwUInt8 *cpPixels; // r12
  int v10; // lr
  int v11; // r4
  int v12; // r6
  int v13; // r10
  int v14; // r0
  int v15; // r11
  int v16; // r2
  RwUInt8 *v17; // r0
  int v18; // r4
  RwImage_0 *v20; // [sp+4h] [bp-24h]
  RwInt32 stride; // [sp+8h] [bp-20h]

  if ( pData )
  {
    v6 = *((_DWORD *)pData + 7);
    if ( v6 > x )
    {
      v7 = *((_DWORD *)pData + 6);
      if ( v7 >= 1 )
      {
        v8 = v7 * y;
        v20 = image;
        stride = image->stride;
        cpPixels = image->cpPixels;
        v10 = 3 * *((_DWORD *)pData + 3);
        v11 = *((_DWORD *)pData + 5);
        v12 = *((_DWORD *)pData + 12) + 3 * x * v11;
        v13 = 0;
        if ( v11 <= 0 )
          goto LABEL_5;
LABEL_12:
        v15 = v11 * x;
        v16 = 0;
        while ( 1 )
        {
          v17 = &cpPixels[4 * v16];
          *(_BYTE *)(v12 + 3 * v16) = v17[2];
          v18 = 3 * v16 + v12;
          *(_BYTE *)(v18 + 1) = v17[1];
          *(_BYTE *)(v18 + 2) = *v17;
          v14 = *(_DWORD *)pData;
          if ( *(_DWORD *)pData == 1 && v15 + v16 > *((_DWORD *)pData + 10) )
            break;
          if ( ++v16 >= *((_DWORD *)pData + 5) )
            goto LABEL_6;
        }
        v12 += v10;
        cpPixels += stride;
LABEL_9:
        if ( v8 <= *((_DWORD *)pData + 11) )
        {
          while ( ++v13 < *((_DWORD *)pData + 6) )
          {
            v11 = *((_DWORD *)pData + 5);
            ++v8;
            if ( v11 > 0 )
              goto LABEL_12;
LABEL_5:
            v14 = *(_DWORD *)pData;
LABEL_6:
            v12 += v10;
            cpPixels += stride;
            if ( v14 == 1 )
              goto LABEL_9;
          }
        }
        v6 = *((_DWORD *)pData + 7);
        image = v20;
      }
    }
    if ( v6 - 1 <= x )
    {
      RwStreamWrite(*((RwStream_0 **)pData + 2), *((const void **)pData + 12), *((_DWORD *)pData + 9));
      memset(*((void **)pData + 12), 0, *((_DWORD *)pData + 9));
    }
  }
  return image;
}

//----- (00212574) --------------------------------------------------------
RwStream_0 *__fastcall _rpReadWorldRights(RwStream_0 *s, RwInt32 len, void *obj, RwInt32 off, RwInt32 size)
{
  RwStream_0 *v6; // r4

  v6 = s;
  if ( !RwStreamReadInt32(s, (RwInt32 *)&lastSeenWorldRightsPluginId, 4u) )
    return 0;
  if ( len == 8 && !RwStreamReadInt32(v6, (RwInt32 *)&lastSeenWorldExtraData, 4u) )
    return 0;
  return v6;
}

//----- (002125B0) --------------------------------------------------------
RwStream_0 *__fastcall _rpWriteWorldRights(RwStream_0 *s, RwInt32 len, const void *obj, RwInt32 off, RwInt32 size)
{
  RwStream_0 *result; // r0

  if ( !RwStreamWriteInt32(s, (const RwInt32 *)(*((_DWORD *)obj + 27) + 44), 4u) )
    return 0;
  result = RwStreamWriteInt32(s, (const RwInt32 *)(*((_DWORD *)obj + 27) + 48), 4u);
  if ( result )
    return s;
  return result;
}

//----- (002125E2) --------------------------------------------------------
RwInt32 __fastcall _rpSizeWorldRights(const void *obj, RwInt32 off, RwInt32 size)
{
  int v3; // r0
  bool v4; // zf

  v3 = *((_DWORD *)obj + 27);
  v4 = v3 == 0;
  if ( v3 )
    v4 = *(_DWORD *)(v3 + 44) == 0;
  if ( v4 )
    return 0;
  else
    return 8;
}

//----- (002125F8) --------------------------------------------------------
RwStream_0 *__fastcall _rpReadSectRights(RwStream_0 *s, RwInt32 len, void *obj, RwInt32 off, RwInt32 size)
{
  RwStream_0 *v6; // r4

  v6 = s;
  if ( !RwStreamReadInt32(s, (RwInt32 *)&lastSeenSectRightsPluginId, 4u) )
    return 0;
  if ( len == 8 && !RwStreamReadInt32(v6, (RwInt32 *)&lastSeenSectExtraData, 4u) )
    return 0;
  return v6;
}

//----- (00212634) --------------------------------------------------------
RwStream_0 *__fastcall _rpWriteSectRights(RwStream_0 *s, RwInt32 len, const void *obj, RwInt32 off, RwInt32 size)
{
  RwStream_0 *result; // r0

  if ( !RwStreamWriteInt32(s, (const RwInt32 *)(*((_DWORD *)obj + 33) + 44), 4u) )
    return 0;
  result = RwStreamWriteInt32(s, (const RwInt32 *)(*((_DWORD *)obj + 33) + 48), 4u);
  if ( result )
    return s;
  return result;
}

//----- (0021266A) --------------------------------------------------------
RwInt32 __fastcall _rpSizeSectRights(const void *obj, RwInt32 off, RwInt32 size)
{
  int v3; // r0
  bool v4; // zf

  v3 = *((_DWORD *)obj + 33);
  v4 = v3 == 0;
  if ( v3 )
    v4 = *(_DWORD *)(v3 + 44) == 0;
  if ( v4 )
    return 0;
  else
    return 8;
}

//----- (00212680) --------------------------------------------------------
RwUInt32 __fastcall RpWorldStreamGetSize(const RpWorld_0 *world)
{
  RwUInt32 flags; // r6
  RwUInt32 Size; // r0
  unsigned __int16 *rootSector; // r1
  RwUInt32 v5; // r5
  RwUInt32 v6; // r6
  int v7; // r0
  int v8; // r2
  int v9; // r2
  int v10; // r6

  flags = world->flags;
  Size = _rpMaterialListStreamGetSize(&world->matList);
  rootSector = (unsigned __int16 *)world->rootSector;
  v5 = Size;
  if ( *(int *)rootSector <= -1 )
  {
    if ( HIBYTE(world->flags) << 31 )
    {
      v10 = 68;
    }
    else
    {
      v7 = rootSector[69];
      v8 = 16 * v7;
      if ( (flags & 0x10) == 0 )
        v8 = 12 * v7;
      v9 = v8 + 68;
      if ( (flags & 8) != 0 )
        v9 += 4 * v7;
      v10 = v9 + 8 * (rootSector[70] + world->numTexCoordSets * v7);
    }
    v6 = v10 + _rwPluginRegistryGetSize(&sectorTKList, rootSector);
  }
  else
  {
    v6 = PlaneSectorStreamGetSize((const RpPlaneSector_0 *)world->rootSector, world, flags);
  }
  return _rwPluginRegistryGetSize(&worldTKList, world) + v5 + v6 + 112;
}

//----- (00212718) --------------------------------------------------------
RwUInt32 __fastcall PlaneSectorStreamGetSize(
        const RpPlaneSector_0 *planeSector,
        const RpWorld_0 *world,
        RwUInt32 flags)
{
  RpSector_0 *leftSubTree; // r1
  RwUInt32 Size; // r8
  int type_high; // r0
  int v9; // r2
  int v10; // r2
  int v11; // r8
  unsigned __int16 *rightSubTree; // r1
  RwUInt32 v13; // r0
  int v14; // r0
  int v15; // r6
  int v16; // r3
  int v17; // r4

  leftSubTree = planeSector->leftSubTree;
  if ( leftSubTree->type <= -1 )
  {
    if ( HIBYTE(world->flags) << 31 )
    {
      v11 = 68;
    }
    else
    {
      type_high = HIWORD(leftSubTree[34].type);
      v9 = 16 * type_high;
      if ( (flags & 0x10) == 0 )
        v9 = 12 * type_high;
      v10 = v9 + 68;
      if ( (flags & 8) != 0 )
        v10 += 4 * type_high;
      v11 = v10 + 8 * (LOWORD(leftSubTree[35].type) + world->numTexCoordSets * type_high);
    }
    Size = v11 + _rwPluginRegistryGetSize(&sectorTKList, leftSubTree);
  }
  else
  {
    Size = PlaneSectorStreamGetSize((const RpPlaneSector_0 *)leftSubTree, world, flags);
  }
  rightSubTree = (unsigned __int16 *)planeSector->rightSubTree;
  if ( *(int *)rightSubTree <= -1 )
  {
    if ( HIBYTE(world->flags) << 31 )
    {
      v17 = 68;
    }
    else
    {
      v14 = rightSubTree[69];
      v15 = 16 * v14;
      if ( (flags & 0x10) == 0 )
        v15 = 12 * v14;
      v16 = v15 + 68;
      if ( (flags & 8) != 0 )
        v16 += 4 * v14;
      v17 = v16 + 8 * (rightSubTree[70] + world->numTexCoordSets * v14);
    }
    v13 = _rwPluginRegistryGetSize(&sectorTKList, rightSubTree) + v17;
  }
  else
  {
    v13 = PlaneSectorStreamGetSize((const RpPlaneSector_0 *)planeSector->rightSubTree, world, flags);
  }
  return v13 + Size + 60;
}

//----- (002127FC) --------------------------------------------------------
const RpWorld_0 *__fastcall RpWorldStreamWrite(const RpWorld_0 *world, RwStream_0 *stream)
{
  RwUInt32 flags; // r8
  RwInt32 Size; // r0
  RpSector_0 *rootSector; // r12
  float v7; // lr
  float v8; // r1
  float v9; // r2
  float v10; // r3
  float v11; // r5
  int i; // r4
  __int64 v13; // kr00_8
  int v14; // r6
  int v15; // r0
  const RwPluginRegistry_0 *v16; // r5
  float y; // s2
  float z; // s4
  __int64 v25; // d17
  __int64 v26; // d18
  RpSector_0 *v27; // r0
  unsigned int v29; // [sp+8h] [bp-120h] BYREF
  float v30[9]; // [sp+Ch] [bp-11Ch] BYREF
  _QWORD v31[31]; // [sp+30h] [bp-F8h] BYREF

  flags = world->flags;
  Size = RpWorldStreamGetSize(world);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 11, Size, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(stream, 1, 64, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    return 0;
  }
  rootSector = world->rootSector;
  v7 = 0.0;
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  v11 = *(float *)&rootSector;
  for ( i = 0; i > -1; --i )
  {
    while ( (int)*(_DWORD *)LODWORD(v11) > -1 )
    {
      v13 = *(_QWORD *)(LODWORD(v11) + 8);
      ++i;
      ++LODWORD(v9);
      LODWORD(v30[i - 1]) = *(_DWORD *)(LODWORD(v11) + 12);
      v11 = *(float *)&v13;
      if ( i <= -1 )
        goto LABEL_8;
    }
    v14 = *(unsigned __int16 *)(LODWORD(v11) + 140);
    ++LODWORD(v10);
    v15 = *(unsigned __int16 *)(LODWORD(v11) + 138);
    v11 = v30[i - 1];
    LODWORD(v7) += v14;
    LODWORD(v8) += v15;
  }
LABEL_8:
  v16 = 0;
  _R0 = world->numTexCoordSets << 16;
  __asm { UXTB16.W        R0, R0 }
  LODWORD(v30[8]) = _R0 | flags | 0x40000000;
  v29 = (unsigned int)rootSector->type >> 31;
  y = world->worldOrigin.y;
  z = world->worldOrigin.z;
  v30[0] = -world->worldOrigin.x;
  v30[1] = -y;
  v30[3] = v7;
  v30[4] = v8;
  v30[5] = v9;
  v30[6] = v10;
  v30[7] = 0.0;
  v30[2] = -z;
  v25 = *(_QWORD *)&world->boundingBox.sup.z;
  v26 = *(_QWORD *)&world->boundingBox.inf.y;
  v31[0] = *(_QWORD *)&world->boundingBox.sup.x;
  v31[1] = v25;
  v31[2] = v26;
  RwMemRealToFloat32(v30, 0xCu);
  RwMemRealToFloat32(v31, 0x18u);
  RwMemLittleEndian32(&v29, 0x40u);
  if ( RwStreamWrite(stream, &v29, 0x40u) )
  {
    if ( _rpMaterialListStreamWrite(&world->matList, stream) )
    {
      v27 = world->rootSector;
      if ( v27->type <= -1 )
      {
        if ( WorldSectorStreamWrite((const RpWorldSector_0 *)v27, stream, world, flags) )
        {
LABEL_12:
          v16 = _rwPluginRegistryWriteDataChunks(&worldTKList, stream, world);
          if ( v16 )
            return world;
          return (const RpWorld_0 *)v16;
        }
      }
      else if ( PlaneSectorStreamWrite((const RpPlaneSector_0 *)v27, stream, world, flags) )
      {
        goto LABEL_12;
      }
    }
    return 0;
  }
  return (const RpWorld_0 *)v16;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (00212978) --------------------------------------------------------
const RpWorldSector_0 *__fastcall WorldSectorStreamWrite(
        const RpWorldSector_0 *worldSector,
        RwStream_0 *stream,
        const RpWorld_0 *world,
        RwUInt32 flags)
{
  char v6; // r8
  int numVertices; // r0
  int v9; // r3
  int v10; // r2
  int v11; // r5
  RwInt32 Size; // r0
  int v13; // r0
  int v14; // r3
  int v15; // r2
  RwInt32 v16; // r2
  const RpWorldSector_0 *v17; // r5
  double v18; // d16
  double v19; // d16
  int v20; // r6
  RwUInt32 v21; // r5
  int v23[3]; // [sp+8h] [bp-48h] BYREF
  double v24; // [sp+14h] [bp-3Ch] BYREF
  RwReal z; // [sp+1Ch] [bp-34h]
  double v26; // [sp+20h] [bp-30h] BYREF
  RwReal v27; // [sp+28h] [bp-28h]
  int v28; // [sp+30h] [bp-20h]

  v6 = flags;
  if ( HIBYTE(world->flags) << 31 )
  {
    v11 = 68;
  }
  else
  {
    numVertices = worldSector->numVertices;
    v9 = 16 * numVertices;
    if ( (v6 & 0x10) == 0 )
      v9 = 12 * numVertices;
    v10 = v9 + 68;
    if ( (v6 & 8) != 0 )
      v10 += 4 * numVertices;
    v11 = v10 + 8 * (worldSector->numPolygons + world->numTexCoordSets * numVertices);
  }
  Size = _rwPluginRegistryGetSize(&sectorTKList, worldSector);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 9, Size + v11, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  if ( HIBYTE(world->flags) << 31 )
  {
    v16 = 44;
  }
  else
  {
    v13 = worldSector->numVertices;
    v14 = 16 * v13;
    if ( (v6 & 0x10) == 0 )
      v14 = 12 * v13;
    v15 = v14 + 44;
    if ( (v6 & 8) != 0 )
      v15 += 4 * v13;
    v16 = v15 + 8 * (worldSector->numPolygons + world->numTexCoordSets * v13);
  }
  v17 = 0;
  if ( _rwStreamWriteVersionedChunkHeader(stream, 1, v16, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    v23[0] = worldSector->matListWindowBase;
    v23[1] = worldSector->numPolygons;
    v23[2] = worldSector->numVertices;
    v18 = *(double *)&worldSector->tightBoundingBox.inf.x;
    z = worldSector->tightBoundingBox.inf.z;
    v24 = v18;
    v19 = *(double *)&worldSector->tightBoundingBox.sup.x;
    v27 = worldSector->tightBoundingBox.sup.z;
    v28 = 0;
    v26 = v19;
    RwMemRealToFloat32(&v24, 0xCu);
    RwMemRealToFloat32(&v26, 0xCu);
    RwMemLittleEndian32(v23, 0x2Cu);
    if ( RwStreamWrite(stream, v23, 0x2Cu) )
    {
      if ( HIBYTE(world->flags) << 31 )
        goto LABEL_31;
      if ( worldSector->numVertices )
      {
        if ( !RwStreamWriteReal(stream, &worldSector->vertices->x, 12 * worldSector->numVertices)
          || (v6 & 0x10) != 0 && !RwStreamWrite(stream, worldSector->normals, 4 * worldSector->numVertices)
          || (v6 & 8) != 0 && !RwStreamWrite(stream, worldSector->preLitLum, 4 * worldSector->numVertices) )
        {
          return 0;
        }
        if ( world->numTexCoordSets >= 1 )
        {
          v20 = 0;
          v21 = 8 * worldSector->numVertices;
          while ( RwStreamWriteReal(stream, &worldSector->texCoords[v20]->u, v21) )
          {
            if ( ++v20 >= world->numTexCoordSets )
              goto LABEL_29;
          }
          return 0;
        }
      }
LABEL_29:
      if ( !worldSector->numPolygons
        || RwStreamWriteInt16(stream, (const RwInt16 *)worldSector->polygons, 8 * worldSector->numPolygons) )
      {
LABEL_31:
        v17 = (const RpWorldSector_0 *)_rwPluginRegistryWriteDataChunks(&sectorTKList, stream, worldSector);
        if ( v17 )
          return worldSector;
        return v17;
      }
      return 0;
    }
  }
  return v17;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (00212B60) --------------------------------------------------------
const RpPlaneSector_0 *__fastcall PlaneSectorStreamWrite(
        const RpPlaneSector_0 *planeSector,
        RwStream_0 *stream,
        const RpWorld_0 *world,
        RwUInt32 flags)
{
  const RpPlaneSector_0 *v7; // r4
  RwInt32 Size; // r0
  RwReal value; // r1
  RpSector_0 *leftSubTree; // r2
  RpSector_0 *rightSubTree; // r3
  int leftValue_low; // r6
  int rightValue_low; // r5
  const RpWorldSector_0 *v14; // r0
  const RpWorldSector_0 *v15; // r0
  void *v16; // r0
  RwInt32 type; // [sp+8h] [bp-30h] BYREF
  _DWORD v19[3]; // [sp+Ch] [bp-2Ch] BYREF
  int v20; // [sp+18h] [bp-20h] BYREF
  int v21[7]; // [sp+1Ch] [bp-1Ch] BYREF

  v7 = planeSector;
  Size = PlaneSectorStreamGetSize(planeSector, world, flags);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 10, Size, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 1, 24, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  value = v7->value;
  leftSubTree = v7->leftSubTree;
  rightSubTree = v7->rightSubTree;
  leftValue_low = LODWORD(v7->leftValue);
  rightValue_low = LODWORD(v7->rightValue);
  type = v7->type;
  *(RwReal *)v19 = value;
  v19[1] = (unsigned int)leftSubTree->type >> 31;
  v19[2] = (unsigned int)rightSubTree->type >> 31;
  v20 = leftValue_low;
  v21[0] = rightValue_low;
  RwMemRealToFloat32(v19, 4u);
  RwMemRealToFloat32(&v20, 4u);
  RwMemRealToFloat32(v21, 4u);
  RwMemLittleEndian32(&type, 0x18u);
  if ( !RwStreamWrite(stream, &type, 0x18u) )
    return 0;
  v14 = (const RpWorldSector_0 *)v7->leftSubTree;
  if ( v14->type <= -1 )
  {
    if ( WorldSectorStreamWrite(v14, stream, world, flags) )
      goto LABEL_6;
    return 0;
  }
  if ( !PlaneSectorStreamWrite((const RpPlaneSector_0 *)v14, stream, world, flags) )
    return 0;
LABEL_6:
  v15 = (const RpWorldSector_0 *)v7->rightSubTree;
  if ( v15->type <= -1 )
    v16 = (void *)WorldSectorStreamWrite(v15, stream, world, flags);
  else
    v16 = (void *)PlaneSectorStreamWrite((const RpPlaneSector_0 *)v15, stream, world, flags);
  if ( !v16 )
    return 0;
  return v7;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 212B60: using guessed type int var_1C[7];

//----- (00212C50) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldStreamRead(RwStream_0 *stream)
{
  char *v2; // r4
  RwUInt32 v3; // r0
  RwUInt32 v4; // r0
  RwInt32 v5; // r0
  RwUInt32 v6; // r9
  size_t v7; // r6
  int v8; // r10
  size_t v9; // r0
  char *v10; // r0
  float v11; // s4
  float v12; // s0
  float v13; // s2
  RpWorldSector_0 *v14; // r0
  RpPlaneSector_0 *v15; // r0
  RwBBox_0 *v16; // r1
  __int64 v17; // d17
  __int64 v18; // d18
  int v19; // r2
  int i; // r6
  RpMaterial_0 *v21; // r0
  __int128 buffer; // [sp+8h] [bp-A8h] BYREF
  __int64 v24; // [sp+18h] [bp-98h]
  _DWORD v25[7]; // [sp+20h] [bp-90h] BYREF
  RwUInt32 v26; // [sp+40h] [bp-70h] BYREF
  RwUInt32 versionOut; // [sp+44h] [bp-6Ch] BYREF
  RwUInt32 lengthOut; // [sp+48h] [bp-68h] BYREF
  RwUInt8 *v29; // [sp+4Ch] [bp-64h] BYREF
  __int128 code; // [sp+50h] [bp-60h] BYREF
  __int64 v31; // [sp+60h] [bp-50h]
  __int64 v32; // [sp+68h] [bp-48h]
  __int64 v33; // [sp+70h] [bp-40h]
  __int64 v34; // [sp+78h] [bp-38h] BYREF
  __int64 v35; // [sp+80h] [bp-30h]
  __int64 v36; // [sp+88h] [bp-28h]

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &versionOut) )
    return 0;
  if ( versionOut - 212992 >= 0x2004 )
  {
    v2 = 0;
    LODWORD(code) = 0;
    DWORD1(code) = _rwerror(-2147483644);
    RwErrorSet((RwError_0 *)&code);
    return (RpWorld_0 *)v2;
  }
  v35 = 0LL;
  v36 = 0LL;
  v33 = 0LL;
  v34 = 0LL;
  code = 0uLL;
  v31 = 0LL;
  v32 = 0LL;
  if ( versionOut > 0x34000 )
  {
    v4 = RwStreamRead(stream, &code, lengthOut);
    if ( v4 == lengthOut )
    {
      if ( (int)v33 >= 1 )
        goto LABEL_10;
      goto LABEL_12;
    }
    return 0;
  }
  buffer = 0uLL;
  v24 = 0LL;
  memset(v25, 0, sizeof(v25));
  v3 = RwStreamRead(stream, &buffer, lengthOut);
  if ( v3 != lengthOut )
    return 0;
  v31 = *(_QWORD *)&v25[1];
  v32 = *(_QWORD *)&v25[3];
  code = buffer;
  v33 = *(_QWORD *)&v25[5];
  if ( v25[5] >= 1 )
    goto LABEL_10;
LABEL_12:
  RwMemNative32(&code, 0x40u);
  RwMemFloat32ToReal(&v34, 0x18u);
  RwMemFloat32ToReal((char *)&code + 4, 0xCu);
  v6 = HIDWORD(v33);
  v7 = worldTKList.sizeOfStruct + 24 * v32 + sectorTKList.sizeOfStruct * HIDWORD(v32);
  if ( (v33 & 0xFF000000000000LL) != 0 )
  {
    v8 = (HIDWORD(v33) & 0xFF0000u) >> 16;
    if ( (v33 & 0x100000000000000LL) != 0 )
      goto LABEL_21;
  }
  else
  {
    if ( (v33 & 0x8000000000LL) != 0 )
      v8 = 2;
    else
      v8 = (HIDWORD(v33) >> 2) & 1;
    if ( (v33 & 0x100000000000000LL) != 0 )
      goto LABEL_21;
  }
  v9 = v7 + 12 * HIDWORD(v31);
  if ( (v33 & 0x1000000000LL) != 0 )
    v9 += 4 * HIDWORD(v31);
  if ( (v33 & 0x800000000LL) != 0 )
    v9 += 4 * HIDWORD(v31);
  if ( v8 )
    v9 += 8 * v8 * HIDWORD(v31);
  v7 = v9 + 8 * v31;
LABEL_21:
  v10 = (char *)(*((int (__fastcall **)(size_t))RwEngineInstance + 75))(v7);
  v2 = v10;
  if ( !v10 )
  {
    v2 = 0;
    LODWORD(buffer) = 0;
    v5 = _rwerror(-2147483629, v7);
    goto LABEL_11;
  }
  memset(v10, 0, v7);
  v29 = (RwUInt8 *)&v2[worldTKList.sizeOfStruct];
  *(_DWORD *)(v2 + 1) = 0;
  v2[7] = 0;
  *(_WORD *)(v2 + 5) = 0;
  *v2 = 7;
  v2[3] = 1;
  _rpWorldRegisterWorld((RpWorld_0 *)v2, v7);
  *((_DWORD *)v2 + 2) = v6;
  *((_DWORD *)v2 + 3) = 2;
  v11 = *((float *)&code + 3);
  v12 = -*((float *)&code + 1);
  v13 = -*((float *)&code + 2);
  *((_DWORD *)v2 + 7) = 0;
  *((_DWORD *)v2 + 8) = v8;
  *((_DWORD *)v2 + 27) = 0;
  *((float *)v2 + 17) = v12;
  *((float *)v2 + 18) = v13;
  *((float *)v2 + 19) = -v11;
  if ( !RwStreamFindChunk(stream, 8u, 0, &v26) )
    goto LABEL_58;
  if ( v26 - 212992 >= 0x2004 )
  {
LABEL_10:
    v2 = 0;
    LODWORD(buffer) = 0;
    v5 = _rwerror(-2147483644);
LABEL_11:
    DWORD1(buffer) = v5;
    RwErrorSet((RwError_0 *)&buffer);
    return (RpWorld_0 *)v2;
  }
  if ( !_rpMaterialListStreamRead(stream, (RpMaterialList_0 *)(v2 + 16)) )
    goto LABEL_58;
  if ( (_DWORD)code )
  {
    if ( !RwStreamFindChunk(stream, 9u, 0, &v26) )
      goto LABEL_58;
    if ( v26 - 212992 >= 0x2004 )
    {
LABEL_28:
      LODWORD(buffer) = 0;
      DWORD1(buffer) = _rwerror(-2147483644);
      RwErrorSet((RwError_0 *)&buffer);
      _rpWorldUnregisterWorld((RpWorld_0 *)v2);
LABEL_59:
      (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v2);
      return 0;
    }
    v14 = WorldSectorStreamRead(stream, &v29, (RpWorld_0 *)v2, v6);
    *((_DWORD *)v2 + 7) = v14;
    if ( !v14 )
    {
LABEL_58:
      _rpWorldUnregisterWorld((RpWorld_0 *)v2);
      goto LABEL_59;
    }
  }
  else
  {
    if ( !RwStreamFindChunk(stream, 0xAu, 0, &v26) )
      goto LABEL_58;
    if ( v26 - 212992 >= 0x2004 )
      goto LABEL_28;
    v15 = PlaneSectorStreamRead(stream, &v29, (RpWorld_0 *)v2, v6);
    *((_DWORD *)v2 + 7) = v15;
    if ( !v15 )
      goto LABEL_58;
  }
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 10) = v2 + 44;
  *((_DWORD *)v2 + 11) = v2 + 44;
  *((_DWORD *)v2 + 12) = v2 + 44;
  *((_DWORD *)v2 + 13) = v2 + 52;
  *((_DWORD *)v2 + 14) = v2 + 52;
  v16 = (RwBBox_0 *)(v2 + 80);
  *((_DWORD *)v2 + 15) = v2 + 60;
  *((_DWORD *)v2 + 16) = v2 + 60;
  if ( versionOut >= (unsigned int)&stru_33FFC.st_value + 3 )
  {
    v17 = v35;
    v18 = v36;
    *(_QWORD *)&v16->sup.x = v34;
    *((_QWORD *)v2 + 11) = v17;
    *((_QWORD *)v2 + 12) = v18;
  }
  else
  {
    _rpWorldFindBBox((RpWorld_0 *)v2, v16);
  }
  _rpWorldSetupSectorBoundingBoxes((RpWorld_0 *)v2);
  RpWorldSetSectorRenderCallBack((RpWorld_0 *)v2, 0);
  v19 = *((_DWORD *)v2 + 5);
  if ( v19 >= 1 )
  {
    for ( i = 0; i < v19; ++i )
    {
      v21 = *(RpMaterial_0 **)(*((_DWORD *)v2 + 4) + 4 * i);
      if ( v21->texture )
      {
        RpMaterialSetTexture(v21, v21->texture);
        v19 = *((_DWORD *)v2 + 5);
      }
    }
  }
  _rwPluginRegistryInitObject(&worldTKList, v2);
  lastSeenWorldRightsPluginId = 0;
  lastSeenWorldExtraData = 0;
  if ( !_rwPluginRegistryReadDataChunks(&worldTKList, stream, v2) )
    goto LABEL_58;
  if ( lastSeenWorldRightsPluginId )
    _rwPluginRegistryInvokeRights(&worldTKList, lastSeenWorldRightsPluginId, v2, lastSeenWorldExtraData);
  if ( !RpWorldUnlock((RpWorld_0 *)v2) )
  {
    RpWorldDestroy((RpWorld_0 *)v2);
    return 0;
  }
  return (RpWorld_0 *)v2;
}
// 33FFC: using guessed type Elf32_Sym stru_33FFC;

//----- (002130C4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RpWorldSector_0 *__fastcall WorldSectorStreamRead(
        RwStream_0 *stream,
        RwUInt8 **binaryWorldMallocAddr,
        RpWorld_0 *world,
        RwUInt32 flags)
{
  char v4; // r11
  RpWorldSector_0 *v8; // r4
  RpWorldSector_0 *v9; // r6
  bool v10; // zf
  __int64 v11; // d16
  __int64 v12; // r2
  __int64 v13; // d16
  RwUInt16 v14; // r0
  RwUInt8 *v15; // r1
  int v16; // r0
  RwUInt32 v17; // r2
  RwUInt8 *v18; // r1
  RwUInt32 v19; // r8
  int v20; // r0
  RwUInt8 *v21; // r1
  int v22; // r8
  signed int v23; // r11
  RwUInt8 *v24; // r1
  RwInt32 errorCode; // r0
  RwUInt8 *v26; // r1
  int v27; // r5
  char *v28; // r10
  unsigned int numPolygons; // r11
  unsigned int v30; // r1
  char *v31; // r8
  RwInt32 sizeOfStruct; // r1
  RwInt32 v33; // r0
  unsigned int v34; // r3
  const char *v35; // r5
  __int16 *v36; // r2
  uint16x8_t v37; // q13 OVERLAPPED
  uint16x8_t v38; // q12
  uint16x8_t v39; // q11
  uint16x8_t v40; // q10
  __int16 *v41; // r2
  char *v42; // lr
  _WORD *v43; // r3
  int v44; // r5
  char *v45; // r0
  unsigned __int8 *v46; // r2
  void **p_polygons; // [sp+8h] [bp-58h]
  char *v49; // [sp+8h] [bp-58h]
  RwError_0 v50; // [sp+Ch] [bp-54h] BYREF
  RwUInt32 versionOut; // [sp+14h] [bp-4Ch] BYREF
  RwError_0 code; // [sp+18h] [bp-48h] BYREF
  int v53; // [sp+20h] [bp-40h]
  __int64 v54; // [sp+24h] [bp-3Ch] BYREF
  RwReal v55; // [sp+2Ch] [bp-34h]
  __int64 v56; // [sp+30h] [bp-30h] BYREF
  RwReal v57; // [sp+38h] [bp-28h]
  int8x8x4_t v58; // 0:d16.8,8:d17.8,16:d18.8,24:d19.8

  v4 = flags;
  v8 = 0;
  if ( !RwStreamFindChunk(stream, 1u, 0, &versionOut) )
    return v8;
  if ( versionOut - 212992 >= 0x2004 )
  {
    v8 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483644);
    RwErrorSet(&code);
    return v8;
  }
  if ( RwStreamRead(stream, &code, 0x2Cu) != 44 )
    return 0;
  RwMemNative32(&code, 0x2Cu);
  RwMemFloat32ToReal(&v54, 0xCu);
  RwMemFloat32ToReal(&v56, 0xCu);
  v9 = (RpWorldSector_0 *)*binaryWorldMallocAddr;
  v10 = *binaryWorldMallocAddr == 0;
  *binaryWorldMallocAddr += sectorTKList.sizeOfStruct;
  if ( v10 )
  {
    v8 = 0;
    v50.pluginID = 0;
    sizeOfStruct = sectorTKList.sizeOfStruct;
    goto LABEL_32;
  }
  v9->type = -1;
  v11 = v54;
  LODWORD(v12) = &v9->noCollAtomicsInWorldSector;
  HIDWORD(v12) = &v9->lightsInWorldSector;
  v9->tightBoundingBox.inf.z = v55;
  v8 = 0;
  *(_QWORD *)&v9->tightBoundingBox.inf.x = v11;
  v13 = v56;
  v9->tightBoundingBox.sup.z = v57;
  *(_QWORD *)&v9->tightBoundingBox.sup.x = v13;
  v9->matListWindowBase = code.pluginID;
  v9->numPolygons = code.errorCode;
  v14 = v53;
  *(_QWORD *)&v9->polygons = 0LL;
  *(_QWORD *)&v9->normals = 0LL;
  *(_QWORD *)&v9->texCoords[5] = 0LL;
  *(_QWORD *)&v9->texCoords[7] = 0LL;
  *(_QWORD *)&v9->texCoords[1] = 0LL;
  *(_QWORD *)&v9->texCoords[3] = 0LL;
  v9->repEntry = 0;
  v9->collAtomicsInWorldSector.link.next = &v9->collAtomicsInWorldSector.link;
  v9->collAtomicsInWorldSector.link.prev = &v9->collAtomicsInWorldSector.link;
  v9->noCollAtomicsInWorldSector.link.next = &v9->noCollAtomicsInWorldSector.link;
  *(_QWORD *)&v9->noCollAtomicsInWorldSector.link.prev = v12;
  v9->lightsInWorldSector.link.prev = &v9->lightsInWorldSector.link;
  v9->pipeline = 0;
  v9->numVertices = v14;
  v9->mesh = 0;
  if ( HIBYTE(world->flags) << 31 )
    goto LABEL_50;
  p_polygons = (void **)&v9->polygons;
  if ( v53 )
  {
    v15 = *binaryWorldMallocAddr;
    v16 = 3 * v53;
    *binaryWorldMallocAddr += 12 * v53;
    v17 = 4 * v16;
    v9->vertices = (RwV3d_0 *)v15;
    if ( v15 )
    {
      if ( !RwStreamReadReal(stream, (RwReal *)v15, v17) )
        return 0;
      if ( (v4 & 0x10) != 0 )
      {
        v18 = *binaryWorldMallocAddr;
        v19 = 4 * v53;
        v10 = *binaryWorldMallocAddr == 0;
        *binaryWorldMallocAddr += 4 * v53;
        v9->normals = (RpVertexNormal_0 *)v18;
        if ( v10 )
        {
          v8 = 0;
          v50.pluginID = 0;
          v33 = _rwerror(-2147483629, v19);
          goto LABEL_33;
        }
        if ( RwStreamRead(stream, v18, v19) != v19 )
          return 0;
      }
      if ( (v4 & 8) == 0 )
        goto LABEL_16;
      v20 = v53;
      v21 = *binaryWorldMallocAddr;
      *binaryWorldMallocAddr += 4 * v53;
      v17 = 4 * v20;
      v9->preLitLum = (RwRGBA_0 *)v21;
      if ( v21 )
      {
        if ( !RwStreamRead(stream, v21, v17) )
          return 0;
LABEL_16:
        if ( world->numTexCoordSets >= 1 )
        {
          v22 = 0;
          v23 = 8 * v9->numVertices;
          while ( 1 )
          {
            v24 = *binaryWorldMallocAddr;
            *binaryWorldMallocAddr += v23;
            v9->texCoords[v22] = (RwTexCoords_0 *)v24;
            if ( !v24 )
              goto LABEL_36;
            if ( !RwStreamReadReal(stream, (RwReal *)v24, v23) )
              return 0;
            if ( ++v22 >= world->numTexCoordSets )
              goto LABEL_21;
          }
        }
        goto LABEL_21;
      }
      v8 = 0;
    }
    else
    {
      v8 = 0;
    }
    v50.pluginID = 0;
    sizeOfStruct = v17;
LABEL_32:
    v33 = _rwerror(-2147483629, sizeOfStruct);
LABEL_33:
    v50.errorCode = v33;
    RwErrorSet(&v50);
    return v8;
  }
LABEL_21:
  errorCode = code.errorCode;
  if ( !code.errorCode )
    goto LABEL_50;
  v26 = *binaryWorldMallocAddr;
  v23 = 8 * code.errorCode;
  v10 = *binaryWorldMallocAddr == 0;
  *binaryWorldMallocAddr += 8 * code.errorCode;
  *p_polygons = v26;
  if ( v10 )
  {
LABEL_36:
    v8 = 0;
    v50.pluginID = 0;
    v33 = _rwerror(-2147483629, v23);
    goto LABEL_33;
  }
  v27 = 8 * errorCode;
  if ( versionOut < 0x30400 )
    v27 = v23 / 2;
  if ( RwStreamRead(stream, v26, v27) != v27 )
    return 0;
  v28 = (char *)*p_polygons;
  if ( versionOut >> 10 > 0xC0 )
  {
    RwMemNative16(*p_polygons, v23);
    goto LABEL_50;
  }
  numPolygons = v9->numPolygons;
  v49 = (char *)(*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(4 * numPolygons);
  qmemcpy(v49, v28, 4 * numPolygons);
  if ( numPolygons )
  {
    if ( numPolygons >= 8 )
    {
      v30 = numPolygons - (numPolygons & 7);
      if ( numPolygons == (numPolygons & 7) || &v49[4 * numPolygons] > v28 && v49 < &v28[8 * numPolygons] )
      {
        v30 = 0;
        v31 = v49;
      }
      else
      {
        v34 = numPolygons - (numPolygons & 7);
        v35 = v49;
        v31 = &v49[4 * numPolygons - (unsigned __int16)(4 * (numPolygons & 7))];
        v36 = (__int16 *)v28;
        do
        {
          v58 = vld4_s8(v35);
          v35 += 32;
          v34 -= 8;
          v37 = vmovl_u8(v58.val[3]);
          v38 = vmovl_u8(v58.val[2]);
          v39 = vmovl_u8(v58.val[1]);
          v40 = vmovl_u8(v58.val[0]);
          vst4_s16(v36, *(int16x4x4_t *)((char *)&v37 - 24));
          v41 = v36 + 16;
          vst4_s16(v41, *(int16x4x4_t *)(&v37 - 1));
          v36 = v41 + 16;
        }
        while ( v34 );
        if ( (numPolygons & 7) == 0 )
          goto LABEL_49;
      }
    }
    else
    {
      v30 = 0;
      v31 = v49;
    }
    v42 = &v28[8 * v30];
    v43 = v42 + 6;
    v44 = 0;
    do
    {
      v45 = &v42[8 * v44];
      *(v43 - 3) = (unsigned __int8)v31[4 * v44];
      v46 = (unsigned __int8 *)&v31[4 * v44++];
      *((_WORD *)v45 + 1) = v46[1];
      *((_WORD *)v45 + 2) = v46[2];
      *v43 = v46[3];
      v43 += 4;
    }
    while ( numPolygons - v30 != v44 );
  }
LABEL_49:
  (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v49);
LABEL_50:
  _rwPluginRegistryInitObject(&sectorTKList, v9);
  lastSeenSectRightsPluginId = 0;
  lastSeenSectExtraData = 0;
  if ( _rwPluginRegistryReadDataChunks(&sectorTKList, stream, v9) )
  {
    if ( lastSeenSectRightsPluginId )
      _rwPluginRegistryInvokeRights(&sectorTKList, lastSeenSectRightsPluginId, v9, lastSeenSectExtraData);
    return v9;
  }
  return v8;
}
// 2133B1: failed to expand linear variable q13.16

//----- (00213488) --------------------------------------------------------
RpPlaneSector_0 *__fastcall PlaneSectorStreamRead(
        RwStream_0 *stream,
        RwUInt8 **binaryWorldMallocAddr,
        RpWorld_0 *world,
        RwUInt32 flags)
{
  RwUInt8 *v8; // r4
  RwUInt32 v9; // r0
  bool v10; // zf
  RwInt32 errorCode; // r0
  int v12; // s0
  RwInt32 v13; // r0
  void *v14; // r0
  void *v15; // r0
  RwError_0 v17; // [sp+0h] [bp-48h] BYREF
  RwUInt32 versionOut; // [sp+8h] [bp-40h] BYREF
  RwUInt32 lengthOut; // [sp+Ch] [bp-3Ch] BYREF
  RwError_0 code; // [sp+10h] [bp-38h] BYREF
  __int64 v21; // [sp+18h] [bp-30h]
  int v22; // [sp+20h] [bp-28h] BYREF
  int v23[9]; // [sp+24h] [bp-24h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &versionOut) )
    return 0;
  if ( versionOut - 212992 >= 0x2004 )
  {
    v8 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483644);
    RwErrorSet(&code);
    return (RpPlaneSector_0 *)v8;
  }
  v8 = 0;
  code = 0LL;
  v21 = 0LL;
  v22 = 0;
  v23[0] = 0;
  v9 = RwStreamRead(stream, &code, lengthOut);
  if ( v9 != lengthOut )
    return (RpPlaneSector_0 *)v8;
  RwMemNative32(&code, 0x18u);
  RwMemFloat32ToReal(&code.errorCode, 4u);
  RwMemFloat32ToReal(&v22, 4u);
  RwMemFloat32ToReal(v23, 4u);
  v8 = *binaryWorldMallocAddr;
  v10 = *binaryWorldMallocAddr == 0;
  *binaryWorldMallocAddr += 24;
  if ( v10 )
  {
    v8 = 0;
    v17.pluginID = 0;
    v13 = _rwerror(-2147483629, 24);
LABEL_25:
    v17.errorCode = v13;
    RwErrorSet(&v17);
    return (RpPlaneSector_0 *)v8;
  }
  *(RwError_0 *)v8 = code;
  if ( (flags & 0x40000000) != 0 )
  {
    *((_DWORD *)v8 + 4) = v22;
    v12 = v23[0];
  }
  else
  {
    errorCode = code.errorCode;
    *((_DWORD *)v8 + 4) = code.errorCode;
    v12 = errorCode;
  }
  *((_DWORD *)v8 + 5) = v12;
  if ( (_DWORD)v21 )
  {
    if ( !RwStreamFindChunk(stream, 9u, 0, &versionOut) )
      return 0;
    if ( versionOut - 212992 >= 0x2004 )
      goto LABEL_24;
    v14 = WorldSectorStreamRead(stream, binaryWorldMallocAddr, world, flags);
  }
  else
  {
    if ( !RwStreamFindChunk(stream, 0xAu, 0, &versionOut) )
      return 0;
    if ( versionOut - 212992 >= 0x2004 )
      goto LABEL_24;
    v14 = PlaneSectorStreamRead(stream, binaryWorldMallocAddr, world, flags);
  }
  *((_DWORD *)v8 + 2) = v14;
  if ( !v14 )
    return 0;
  if ( HIDWORD(v21) )
  {
    if ( RwStreamFindChunk(stream, 9u, 0, &versionOut) )
    {
      if ( versionOut - 212992 < 0x2004 )
      {
        v15 = WorldSectorStreamRead(stream, binaryWorldMallocAddr, world, flags);
        goto LABEL_29;
      }
      goto LABEL_24;
    }
    return 0;
  }
  if ( !RwStreamFindChunk(stream, 0xAu, 0, &versionOut) )
    return 0;
  if ( versionOut - 212992 >= 0x2004 )
  {
LABEL_24:
    v8 = 0;
    v17.pluginID = 0;
    v13 = _rwerror(-2147483644);
    goto LABEL_25;
  }
  v15 = PlaneSectorStreamRead(stream, binaryWorldMallocAddr, world, flags);
LABEL_29:
  *((_DWORD *)v8 + 3) = v15;
  if ( !v15 )
    return 0;
  return (RpPlaneSector_0 *)v8;
}
// 213488: using guessed type int var_24[9];

//----- (0021363C) --------------------------------------------------------
RpWorldSectorChunkInfo *__fastcall _rpWorldSectorChunkInfoRead(
        RwStream_0 *stream,
        RpWorldSectorChunkInfo *worldSectorChunkInfo,
        RwInt32 *bytesRead)
{
  RpWorldSectorChunkInfo *v6; // r6
  RwUInt32 v7; // r0
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  v6 = 0;
  if ( RwStreamFindChunk(stream, 1u, lengthOut, 0) )
  {
    *(_QWORD *)&worldSectorChunkInfo->sup.y = 0LL;
    *(_QWORD *)&worldSectorChunkInfo->collSectorPresent = 0LL;
    *(_QWORD *)&worldSectorChunkInfo->matListWindowBase = 0LL;
    *(_QWORD *)&worldSectorChunkInfo->numVertices = 0LL;
    *(_QWORD *)&worldSectorChunkInfo->inf.y = 0LL;
    *(_QWORD *)&worldSectorChunkInfo->sup.x = 0LL;
    if ( RwStreamRead(stream, worldSectorChunkInfo, 0x2Cu) == 44 )
    {
      v7 = lengthOut[0];
      *bytesRead = lengthOut[0] + 12;
      RwStreamSkip(stream, v7 - 44);
      RwMemNative32(worldSectorChunkInfo, 0x2Cu);
      RwMemFloat32ToReal(&worldSectorChunkInfo->inf, 0xCu);
      RwMemFloat32ToReal(&worldSectorChunkInfo->sup, 0xCu);
      return worldSectorChunkInfo;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}
// 21363C: using guessed type RwUInt32 lengthOut[5];

//----- (002136BE) --------------------------------------------------------
RpPlaneSectorChunkInfo_0 *__fastcall _rpPlaneSectorChunkInfoRead(
        RwStream_0 *stream,
        RpPlaneSectorChunkInfo_0 *planeSectorChunkInfo,
        RwInt32 *bytesRead)
{
  RpPlaneSectorChunkInfo_0 *v6; // r6
  RwUInt32 v7; // r0
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  v6 = 0;
  if ( RwStreamFindChunk(stream, 1u, lengthOut, 0) )
  {
    planeSectorChunkInfo->rightValue = 0.0;
    *(_QWORD *)&planeSectorChunkInfo->type = 0LL;
    *(_QWORD *)&planeSectorChunkInfo->leftIsWorldSector = 0LL;
    planeSectorChunkInfo->leftValue = 0.0;
    if ( RwStreamRead(stream, planeSectorChunkInfo, 0x18u) == 24 )
    {
      v7 = lengthOut[0];
      *bytesRead = lengthOut[0] + 12;
      RwStreamSkip(stream, v7 - 24);
      RwMemNative32(planeSectorChunkInfo, 0x18u);
      RwMemFloat32ToReal(&planeSectorChunkInfo->value, 4u);
      RwMemFloat32ToReal(&planeSectorChunkInfo->leftValue, 4u);
      RwMemFloat32ToReal(&planeSectorChunkInfo->rightValue, 4u);
      return planeSectorChunkInfo;
    }
  }
  return v6;
}
// 2136BE: using guessed type RwUInt32 lengthOut[5];

//----- (0021373C) --------------------------------------------------------
RpWorldChunkInfo_0 *__fastcall _rpWorldChunkInfoRead(
        RwStream_0 *stream,
        RpWorldChunkInfo_0 *worldChunkInfo,
        RwInt32 *bytesRead)
{
  RwUInt32 v6; // r0
  RwUInt32 v7; // r0
  __int64 v8; // d16
  __int64 v9; // d17
  RwUInt32 v10; // r0
  __int128 v12; // [sp+0h] [bp-50h] BYREF
  __int64 v13; // [sp+10h] [bp-40h]
  _DWORD v14[7]; // [sp+18h] [bp-38h] BYREF
  RwUInt32 versionOut; // [sp+38h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+3Ch] [bp-14h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
    return 0;
  v6 = versionOut;
  if ( versionOut - 212992 < 0x2004 )
  {
    *(_QWORD *)&worldChunkInfo->boundingBox.sup.z = 0LL;
    *(_QWORD *)&worldChunkInfo->boundingBox.inf.y = 0LL;
    *(_QWORD *)&worldChunkInfo->colSectorSize = 0LL;
    *(_QWORD *)&worldChunkInfo->boundingBox.sup.x = 0LL;
    *(_QWORD *)&worldChunkInfo->rootIsWorldSector = 0LL;
    *(_QWORD *)&worldChunkInfo->invWorldOrigin.y = 0LL;
    *(_QWORD *)&worldChunkInfo->numPolygons = 0LL;
    *(_QWORD *)&worldChunkInfo->numPlaneSectors = 0LL;
    if ( v6 > 0x34000 )
    {
      v10 = RwStreamRead(stream, worldChunkInfo, lengthOut[0]);
      if ( v10 == lengthOut[0] )
        goto LABEL_8;
    }
    else
    {
      v12 = 0uLL;
      v13 = 0LL;
      memset(v14, 0, sizeof(v14));
      v7 = RwStreamRead(stream, &v12, lengthOut[0]);
      if ( v7 == lengthOut[0] )
      {
        worldChunkInfo->rootIsWorldSector = v12;
        v8 = *(_QWORD *)((char *)&v12 + 4);
        worldChunkInfo->invWorldOrigin.z = *((RwReal *)&v12 + 3);
        *(_QWORD *)&worldChunkInfo->invWorldOrigin.x = v8;
        v9 = *(_QWORD *)&v14[3];
        *(_QWORD *)&worldChunkInfo->numPolygons = *(_QWORD *)&v14[1];
        *(_QWORD *)&worldChunkInfo->numPlaneSectors = v9;
        *(_QWORD *)&worldChunkInfo->colSectorSize = *(_QWORD *)&v14[5];
LABEL_8:
        RwMemNative32(worldChunkInfo, 0x40u);
        RwMemFloat32ToReal(&worldChunkInfo->boundingBox, 0x18u);
        RwMemFloat32ToReal(&worldChunkInfo->invWorldOrigin, 0xCu);
        *bytesRead = lengthOut[0] + 12;
        return worldChunkInfo;
      }
    }
    return 0;
  }
  worldChunkInfo = 0;
  LODWORD(v12) = 0;
  DWORD1(v12) = _rwerror(-2147483644);
  RwErrorSet((RwError_0 *)&v12);
  return worldChunkInfo;
}
// 21373C: using guessed type RwUInt32 lengthOut[5];

//----- (00213838) --------------------------------------------------------
void *__fastcall _rpBinaryWorldClose(void *instance, RwInt32 offset, RwInt32 size)
{
  --binWorldModule;
  return instance;
}
// 6BD53C: using guessed type int binWorldModule;

//----- (00213848) --------------------------------------------------------
void *__fastcall _rpBinaryWorldOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  ++binWorldModule;
  return instance;
}
// 6BD53C: using guessed type int binWorldModule;

//----- (00213858) --------------------------------------------------------
RwStream_0 *__fastcall _rpReadAtomicRights(RwStream_0 *s, RwInt32 len, void *obj, RwInt32 off, RwInt32 size)
{
  RwStream_0 *v6; // r4

  v6 = s;
  if ( !RwStreamReadInt32(s, (RwInt32 *)&lastSeenRightsPluginId, 4u) )
    return 0;
  if ( len == 8 && !RwStreamReadInt32(v6, (RwInt32 *)&lastSeenExtraData, 4u) )
    return 0;
  return v6;
}

//----- (00213894) --------------------------------------------------------
RwStream_0 *__fastcall _rpWriteAtomicRights(RwStream_0 *s, RwInt32 len, const void *obj, RwInt32 off, RwInt32 size)
{
  RwStream_0 *result; // r0

  if ( !RwStreamWriteInt32(s, (const RwInt32 *)(*((_DWORD *)obj + 27) + 44), 4u) )
    return 0;
  result = RwStreamWriteInt32(s, (const RwInt32 *)(*((_DWORD *)obj + 27) + 48), 4u);
  if ( result )
    return s;
  return result;
}

//----- (002138C6) --------------------------------------------------------
RwInt32 __fastcall _rpSizeAtomicRights(const void *obj, RwInt32 off, RwInt32 size)
{
  int v3; // r0
  bool v4; // zf

  v3 = *((_DWORD *)obj + 27);
  v4 = v3 == 0;
  if ( v3 )
    v4 = *(_DWORD *)(v3 + 44) == 0;
  if ( v4 )
    return 0;
  else
    return 8;
}

//----- (002138DC) --------------------------------------------------------
RpAtomic_0 *__fastcall AtomicDefaultRenderCallBack(RpAtomic_0 *atomic)
{
  RxPipeline_0 *pipeline; // r0
  RpAtomic_0 *result; // r0

  pipeline = atomic->pipeline;
  if ( !pipeline )
    pipeline = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 60);
  result = (RpAtomic_0 *)RxPipelineExecute(pipeline, atomic, 1);
  if ( result )
    return atomic;
  return result;
}

//----- (00213914) --------------------------------------------------------
void __fastcall _rpAtomicResyncInterpolatedSphere(RpAtomic_0 *atomic)
{
  RpGeometry_0 *geometry; // r2
  int endMorphTarget; // r1
  int startMorphTarget; // r4
  RwInt32 numMorphTargets; // r3
  int v5; // r12
  bool v6; // zf
  bool v7; // nf
  bool v8; // vf
  RpMorphTarget_0 *morphTarget; // r2
  bool v10; // zf
  bool v11; // nf
  bool v12; // vf
  _QWORD *p_x; // r1
  __int64 v14; // d17
  RpMorphTarget_0 *v15; // r2
  float *v16; // r1
  float *v17; // r2
  float v18; // s0
  RwReal v19; // s2
  RwReal v20; // s2
  RwReal v21; // s4
  RwReal v22; // s4
  float v23; // s6
  float v24; // s8
  RwReal v25; // s0
  RwUInt8 privateFlags; // r2

  geometry = atomic->geometry;
  if ( geometry )
  {
    endMorphTarget = (unsigned __int16)atomic->interpolator.endMorphTarget;
    startMorphTarget = (unsigned __int16)atomic->interpolator.startMorphTarget;
    numMorphTargets = geometry->numMorphTargets;
    v5 = (__int16)endMorphTarget;
    if ( startMorphTarget == endMorphTarget )
      goto LABEL_7;
    v8 = __OFSUB__(numMorphTargets, (__int16)startMorphTarget);
    v6 = numMorphTargets == (__int16)startMorphTarget;
    v7 = numMorphTargets - (__int16)startMorphTarget < 0;
    if ( numMorphTargets > (__int16)startMorphTarget )
    {
      v8 = __OFSUB__(numMorphTargets, (__int16)endMorphTarget);
      v6 = numMorphTargets == (__int16)endMorphTarget;
      v7 = numMorphTargets - (__int16)endMorphTarget < 0;
    }
    if ( v7 ^ v8 | v6 )
    {
LABEL_7:
      morphTarget = geometry->morphTarget;
      v12 = __OFSUB__(numMorphTargets, (__int16)startMorphTarget);
      v10 = numMorphTargets == (__int16)startMorphTarget;
      v11 = numMorphTargets - (__int16)startMorphTarget < 0;
      if ( numMorphTargets > (__int16)startMorphTarget )
      {
        v12 = __OFSUB__(numMorphTargets, (__int16)endMorphTarget);
        v10 = numMorphTargets == (__int16)endMorphTarget;
        v11 = numMorphTargets - (__int16)endMorphTarget < 0;
      }
      if ( v11 ^ v12 | v10 )
        p_x = (_QWORD *)&morphTarget->boundingSphere.center.x;
      else
        p_x = (_QWORD *)&morphTarget[(__int16)startMorphTarget].boundingSphere.center.x;
      v14 = p_x[1];
      *(_QWORD *)&atomic->boundingSphere.center.x = *p_x;
      *(_QWORD *)&atomic->boundingSphere.center.z = v14;
    }
    else
    {
      v15 = geometry->morphTarget;
      v16 = (float *)&v15[(__int16)startMorphTarget];
      v17 = (float *)&v15[v5];
      v18 = atomic->interpolator.recipTime * atomic->interpolator.position;
      atomic->boundingSphere.radius = v16[4] + (float)(v18 * (float)(v17[4] - v16[4]));
      v19 = v17[1] - v16[1];
      atomic->boundingSphere.center.x = v19;
      v20 = v18 * v19;
      v21 = v17[2] - v16[2];
      atomic->boundingSphere.center.y = v21;
      v22 = v18 * v21;
      v23 = v16[3];
      v24 = v17[3];
      atomic->boundingSphere.center.x = v20;
      atomic->boundingSphere.center.y = v22;
      v25 = v18 * (float)(v24 - v23);
      atomic->boundingSphere.center.z = v25;
      atomic->boundingSphere.center.x = v20 + v16[1];
      atomic->boundingSphere.center.y = v22 + v16[2];
      atomic->boundingSphere.center.z = v25 + v16[3];
    }
    privateFlags = atomic->object.object.privateFlags;
    atomic->interpolator.flags &= ~2u;
    atomic->object.object.privateFlags = privateFlags | 1;
  }
}

//----- (00213A18) --------------------------------------------------------
const RwSphere_0 *__fastcall RpAtomicGetWorldBoundingSphere(RpAtomic_0 *atomic)
{
  RwFrame_0 *parent; // r5
  RwBool v3; // r0
  bool v4; // zf
  RwMatrix *LTM; // r5
  float radius; // s0
  float v7; // s10
  float v8; // s6
  float v9; // s2
  RwUInt8 privateFlags; // r0

  parent = (RwFrame_0 *)atomic->object.object.parent;
  if ( (atomic->interpolator.flags & 2) != 0 )
    _rpAtomicResyncInterpolatedSphere(atomic);
  v3 = RwFrameDirty(parent);
  v4 = v3 == 0;
  if ( !v3 )
    v4 = atomic->object.object.privateFlags << 31 == 0;
  if ( !v4 )
  {
    LTM = RwFrameGetLTM(parent);
    RwV3dTransformPoints(&atomic->worldBoundingSphere.center, &atomic->boundingSphere.center, 1, LTM);
    if ( (LTM->flags & 3) == 3 )
    {
      radius = atomic->boundingSphere.radius;
    }
    else
    {
      v7 = LTM->right.z * LTM->right.z;
      v8 = (float)(LTM->right.x * LTM->right.x) + (float)(LTM->right.y * LTM->right.y);
      v9 = (float)((float)(LTM->at.x * LTM->at.x) + (float)(LTM->at.y * LTM->at.y)) + (float)(LTM->at.z * LTM->at.z);
      if ( (float)((float)((float)(LTM->up.x * LTM->up.x) + (float)(LTM->up.y * LTM->up.y))
                 + (float)(LTM->up.z * LTM->up.z)) >= v9 )
        v9 = (float)((float)(LTM->up.x * LTM->up.x) + (float)(LTM->up.y * LTM->up.y)) + (float)(LTM->up.z * LTM->up.z);
      if ( (float)(v8 + v7) >= v9 )
        v9 = v8 + v7;
      radius = _rwSqrt(v9) * atomic->boundingSphere.radius;
    }
    privateFlags = atomic->object.object.privateFlags;
    atomic->worldBoundingSphere.radius = radius;
    atomic->object.object.privateFlags = privateFlags & 0xFE;
  }
  return &atomic->worldBoundingSphere;
}

//----- (00213B0C) --------------------------------------------------------
void *__fastcall _rpClumpClose(void *instance, RwInt32 offset, RwInt32 size)
{
  int v4; // r0

  RwFreeListForAllUsed(*(RwFreeList_0 **)((char *)RwEngineInstance + clumpModule + 4), ClumpTidyDestroyClump, 0);
  RwFreeListForAllUsed(*(RwFreeList_0 **)((char *)RwEngineInstance + clumpModule), ClumpTidyDestroyAtomic, 0);
  RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + clumpModule));
  RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + clumpModule + 4));
  v4 = clumpModule;
  *(_DWORD *)((char *)RwEngineInstance + clumpModule) = 0;
  *(_DWORD *)((char *)RwEngineInstance + v4 + 4) = 0;
  --clumpModule;
  return instance;
}
// 6BD598: using guessed type int clumpModule;
// 6BD59C: using guessed type int clumpModule;

//----- (00213B9C) --------------------------------------------------------
void __fastcall RpAtomicSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpAtomicFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpAtomicFreeListBlockSize = blockSize;
}

//----- (00213BB4) --------------------------------------------------------
void __fastcall RpClumpSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpClumpFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpClumpFreeListBlockSize = blockSize;
}

//----- (00213BCC) --------------------------------------------------------
void *__fastcall _rpClumpOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2
  RwFreeList_0 *v6; // r0
  int v7; // r2

  clumpModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         atomicTKList.sizeOfStruct,
         _rpAtomicFreeListBlockSize,
         4,
         _rpAtomicFreeListPreallocBlocks,
         &_rpAtomicFreeList);
  v5 = clumpModule;
  *(_DWORD *)((char *)RwEngineInstance + clumpModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  v6 = RwFreeListCreateAndPreallocateSpace(
         clumpTKList.sizeOfStruct,
         _rpClumpFreeListBlockSize,
         4,
         _rpClumpFreeListPreallocBlocks,
         &_rpClumpFreeList);
  v7 = clumpModule;
  *(_DWORD *)((char *)RwEngineInstance + clumpModule + 4) = v6;
  if ( *(_DWORD *)((char *)RwEngineInstance + v7 + 4) )
  {
    ++clumpModule;
  }
  else
  {
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v7));
    instance = 0;
    *(_DWORD *)((char *)RwEngineInstance + clumpModule) = 0;
  }
  return instance;
}
// 6BD598: using guessed type int clumpModule;
// 6BD59C: using guessed type int clumpModule;

//----- (00213CBC) --------------------------------------------------------
bool _rpClumpRegisterExtensions()
{
  int v0; // r4

  v0 = 0;
  _rpClumpCameraExtOffset = RwCameraRegisterPlugin(12, 0x10u, ClumpInitCameraExt, ClumpDeInitCameraExt, 0);
  if ( _rpClumpCameraExtOffset >= 0 )
  {
    _rpClumpLightExtOffset = RpLightRegisterPlugin(12, 0x10u, ClumpInitLightExt, ClumpDeInitLightExt, 0);
    return _rpClumpLightExtOffset >= 0;
  }
  return v0;
}

//----- (00213D1C) --------------------------------------------------------
void *__fastcall ClumpInitCameraExt(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  RwInt32 v3; // r1
  char *v4; // r1

  v3 = _rpClumpCameraExtOffset;
  *(_DWORD *)((char *)object + _rpClumpCameraExtOffset) = 0;
  v4 = (char *)object + v3;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  return object;
}

//----- (00213D38) --------------------------------------------------------
void *__fastcall ClumpInitLightExt(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  RwInt32 v3; // r1
  char *v4; // r1

  v3 = _rpClumpLightExtOffset;
  *(_DWORD *)((char *)object + _rpClumpLightExtOffset) = 0;
  v4 = (char *)object + v3;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  return object;
}

//----- (00213D52) --------------------------------------------------------
RwInt32 __fastcall RpClumpGetNumAtomics(RpClump_0 *clump)
{
  RwLinkList_0 *p_atomicList; // r1
  RwInt32 result; // r0
  RwLinkList_0 *next; // r2

  p_atomicList = &clump->atomicList;
  result = -1;
  next = p_atomicList;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    ++result;
  }
  while ( next != p_atomicList );
  return result;
}

//----- (00213D66) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpForAllAtomics(RpClump_0 *clump, RpAtomicCallBack callback, void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_atomicList; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_atomicList = &clump->atomicList;
  next = clump->atomicList.link.next;
  do
  {
    if ( next == (RwLLLink *)p_atomicList )
      break;
    v8 = next->next;
    v9 = (int)callback((RpAtomic_0 *)&next[-8], pData) == 0;
    next = v8;
  }
  while ( !v9 );
  return clump;
}

//----- (00213D94) --------------------------------------------------------
RwInt32 __fastcall RpClumpGetNumLights(RpClump_0 *clump)
{
  RwLinkList_0 *p_lightList; // r1
  RwInt32 result; // r0
  RwLinkList_0 *next; // r3
  bool v4; // zf

  p_lightList = &clump->lightList;
  result = 0;
  next = p_lightList;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    v4 = next == p_lightList;
    if ( next != p_lightList )
    {
      ++result;
      v4 = (char *)next - _rpClumpLightExtOffset == &byte_4;
    }
  }
  while ( !v4 );
  return result;
}
// 4: using guessed type char byte_4;

//----- (00213DBC) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpForAllLights(RpClump_0 *clump, RpLightCallBack callback, void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_lightList; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_lightList = &clump->lightList;
  next = clump->lightList.link.next;
  do
  {
    if ( next == (RwLLLink *)p_lightList )
      break;
    v8 = next->next;
    v9 = (int)callback((RpLight_0 *)((char *)next - _rpClumpLightExtOffset - 4), pData) == 0;
    next = v8;
  }
  while ( !v9 );
  return clump;
}

//----- (00213DFC) --------------------------------------------------------
RwInt32 __fastcall RpClumpGetNumCameras(RpClump_0 *clump)
{
  RwLinkList_0 *p_cameraList; // r1
  RwInt32 result; // r0
  RwLinkList_0 *next; // r3
  bool v4; // zf

  p_cameraList = &clump->cameraList;
  result = 0;
  next = p_cameraList;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    v4 = next == p_cameraList;
    if ( next != p_cameraList )
    {
      ++result;
      v4 = (char *)next - _rpClumpCameraExtOffset == &byte_4;
    }
  }
  while ( !v4 );
  return result;
}
// 4: using guessed type char byte_4;

//----- (00213E24) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpForAllCameras(RpClump_0 *clump, RwCameraCallBack callback, void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_cameraList; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_cameraList = &clump->cameraList;
  next = clump->cameraList.link.next;
  do
  {
    if ( next == (RwLLLink *)p_cameraList )
      break;
    v8 = next->next;
    v9 = (int)callback((RwCamera_0 *)((char *)next - _rpClumpCameraExtOffset - 4), pData) == 0;
    next = v8;
  }
  while ( !v9 );
  return clump;
}

//----- (00213E64) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpCreateSpace(const RwV3d_0 *position, RwReal radius)
{
  RpGeometry_0 *Space; // r11
  RwFrame_0 *v4; // r0
  RwFrame_0 *v5; // r8
  __int64 v6; // d16
  char *v7; // r0
  char *v8; // r6
  char v9; // r1
  RwLLLink *v10; // r10
  char *v11; // r0
  RpClump_0 *v12; // r5
  RpGeometry_0 *v13; // r1
  RwFrame_0 *v14; // r4
  __int64 v15; // d17
  RpGeometry_0 **v17; // [sp+0h] [bp-20h]

  Space = RpGeometryCreateSpace(radius);
  if ( !Space )
    return 0;
  v4 = RwFrameCreate();
  v5 = v4;
  if ( !v4 )
  {
LABEL_14:
    RpGeometryDestroy(Space);
    return 0;
  }
  v6 = *(_QWORD *)&position->x;
  v4->modelling.pos.z = position->z;
  *(_QWORD *)&v4->modelling.pos.x = v6;
  v7 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + clumpModule));
  v8 = v7;
  if ( !v7 )
  {
LABEL_13:
    RwFrameDestroy(v5);
    goto LABEL_14;
  }
  *(_DWORD *)(v7 + 1) = 0;
  v7[7] = 0;
  *(_WORD *)(v7 + 5) = 0;
  *v7 = 1;
  *((_DWORD *)v7 + 4) = AtomicSync;
  *((_DWORD *)v7 + 5) = 0;
  *((_WORD *)v7 + 1) = 261;
  _rwObjectHasFrameSetFrame(v7, 0);
  *((_QWORD *)v8 + 5) = 0LL;
  *((_QWORD *)v8 + 6) = 0LL;
  *((_QWORD *)v8 + 3) = 0LL;
  *((_QWORD *)v8 + 4) = 0LL;
  *((_DWORD *)v8 + 14) = 0;
  *((_DWORD *)v8 + 17) = 0;
  *((_DWORD *)v8 + 18) = AtomicDefaultRenderCallBack;
  *((_DWORD *)v8 + 19) = 3;
  *((_DWORD *)v8 + 20) = 0;
  *((_DWORD *)v8 + 21) = 1065353216;
  *((_DWORD *)v8 + 22) = 1065353216;
  *((_DWORD *)v8 + 23) = 0;
  *((_DWORD *)v8 + 15) = 0;
  v9 = v8[3] | 1;
  *((_DWORD *)v8 + 25) = v8 + 100;
  *((_DWORD *)v8 + 26) = v8 + 100;
  *((_DWORD *)v8 + 27) = 0;
  v8[3] = v9;
  *((_DWORD *)v8 + 16) = 0;
  v10 = (RwLLLink *)(v8 + 64);
  _rwPluginRegistryInitObject(&atomicTKList, v8);
  v11 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                  + clumpModule
                                                                                  + 4));
  v12 = (RpClump_0 *)v11;
  if ( !v11 )
  {
    RpAtomicDestroy((RpAtomic_0 *)v8);
    goto LABEL_13;
  }
  v17 = (RpGeometry_0 **)(v8 + 24);
  v11[7] = 0;
  *(_WORD *)(v11 + 5) = 0;
  *v11 = 2;
  *((_DWORD *)v11 + 2) = v11 + 8;
  *((_DWORD *)v11 + 3) = v11 + 8;
  *((_DWORD *)v11 + 4) = v11 + 16;
  *((_DWORD *)v11 + 5) = v11 + 16;
  *((_DWORD *)v11 + 6) = v11 + 24;
  *((_DWORD *)v11 + 7) = v11 + 24;
  *((_DWORD *)v11 + 8) = 0;
  *((_DWORD *)v11 + 9) = 0;
  *(_DWORD *)(v11 + 1) = 0;
  *((_DWORD *)v11 + 10) = ClumpCallBack;
  _rwPluginRegistryInitObject(&clumpTKList, v11);
  _rwObjectHasFrameSetFrame(v8, v5);
  v13 = (RpGeometry_0 *)*((_DWORD *)v8 + 6);
  v8[3] |= 1u;
  if ( v13 != Space )
  {
    _rpGeometryAddRef(Space);
    if ( *v17 )
      RpGeometryDestroy(*v17);
    *((_DWORD *)v8 + 6) = Space;
    v14 = (RwFrame_0 *)*((_DWORD *)v8 + 1);
    v15 = *(_QWORD *)&Space->morphTarget->boundingSphere.center.z;
    *(_QWORD *)(v8 + 28) = *(_QWORD *)&Space->morphTarget->boundingSphere.center.x;
    *(_QWORD *)(v8 + 36) = v15;
    if ( v14 && RpAtomicGetWorld((const RpAtomic_0 *)v8) )
      RwFrameUpdateObjects(v14);
  }
  RpGeometryDestroy(Space);
  *((_DWORD *)v8 + 16) = v12->atomicList.link.next;
  *((_DWORD *)v8 + 17) = &v12->atomicList;
  v12->atomicList.link.next->prev = v10;
  v12->atomicList.link.next = v10;
  *((_DWORD *)v8 + 15) = v12;
  v12->object.parent = v5;
  return v12;
}
// 6BD598: using guessed type int clumpModule;

//----- (00214044) --------------------------------------------------------
RpAtomic_0 *RpAtomicCreate()
{
  char *v0; // r0
  _QWORD *v1; // r4
  int v2; // r5
  char v3; // r1

  v0 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + clumpModule));
  v1 = v0;
  v2 = 0;
  if ( v0 )
  {
    *(_DWORD *)(v0 + 1) = 0;
    v0[7] = 0;
    *(_WORD *)(v0 + 5) = 0;
    *v0 = 1;
    *((_DWORD *)v0 + 4) = AtomicSync;
    *((_DWORD *)v0 + 5) = 0;
    *((_WORD *)v0 + 1) = 261;
    _rwObjectHasFrameSetFrame(v0, 0);
    v1[5] = 0LL;
    v1[6] = 0LL;
    v1[3] = 0LL;
    v1[4] = 0LL;
    *((_DWORD *)v1 + 22) = 1065353216;
    *((_DWORD *)v1 + 23) = 0;
    *((_DWORD *)v1 + 14) = 0;
    *((_DWORD *)v1 + 15) = 0;
    *((_DWORD *)v1 + 16) = 0;
    *((_DWORD *)v1 + 17) = 0;
    *((_DWORD *)v1 + 18) = AtomicDefaultRenderCallBack;
    *((_DWORD *)v1 + 19) = 3;
    *((_DWORD *)v1 + 20) = 0;
    *((_DWORD *)v1 + 21) = 1065353216;
    v3 = *((_BYTE *)v1 + 3) | 1;
    *((_DWORD *)v1 + 25) = (char *)v1 + 100;
    *((_DWORD *)v1 + 26) = (char *)v1 + 100;
    *((_DWORD *)v1 + 27) = 0;
    *((_BYTE *)v1 + 3) = v3;
    _rwPluginRegistryInitObject(&atomicTKList, v1);
    return (RpAtomic_0 *)v1;
  }
  return (RpAtomic_0 *)v2;
}
// 6BD598: using guessed type int clumpModule;

//----- (002140F4) --------------------------------------------------------
RpClump_0 *RpClumpCreate()
{
  char *v0; // r0
  char *v1; // r4

  v0 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                 + clumpModule
                                                                                 + 4));
  v1 = v0;
  if ( v0 )
  {
    v0[7] = 0;
    *(_WORD *)(v0 + 5) = 0;
    *v0 = 2;
    *((_DWORD *)v0 + 2) = v0 + 8;
    *((_DWORD *)v0 + 3) = v0 + 8;
    *((_DWORD *)v0 + 4) = v0 + 16;
    *((_DWORD *)v0 + 5) = v0 + 16;
    *((_DWORD *)v0 + 6) = v0 + 24;
    *((_DWORD *)v0 + 7) = v0 + 24;
    *((_DWORD *)v0 + 8) = 0;
    *((_DWORD *)v0 + 9) = 0;
    *(_DWORD *)(v0 + 1) = 0;
    *((_DWORD *)v0 + 10) = ClumpCallBack;
    _rwPluginRegistryInitObject(&clumpTKList, v0);
  }
  return (RpClump_0 *)v1;
}
// 6BD598: using guessed type int clumpModule;

//----- (0021416C) --------------------------------------------------------
RwBool __fastcall RpAtomicDestroy(RpAtomic_0 *atomic)
{
  RwResEntry_0 *repEntry; // r0
  RpGeometry_0 *geometry; // r0
  RwFrame_0 *parent; // r5

  _rwPluginRegistryDeInitObject(&atomicTKList, atomic);
  repEntry = atomic->repEntry;
  if ( repEntry )
    RwResourcesFreeResEntry(repEntry);
  geometry = atomic->geometry;
  if ( geometry )
  {
    RpGeometryDestroy(geometry);
    parent = (RwFrame_0 *)atomic->object.object.parent;
    atomic->geometry = 0;
    if ( parent )
    {
      if ( RpAtomicGetWorld(atomic) )
        RwFrameUpdateObjects(parent);
    }
  }
  _rwObjectHasFrameReleaseFrame(atomic);
  (*((void (__fastcall **)(_DWORD, RpAtomic_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + clumpModule),
    atomic);
  return 1;
}
// 6BD598: using guessed type int clumpModule;

//----- (002141D4) --------------------------------------------------------
RpAtomic_0 *__fastcall RpAtomicSetFrame(RpAtomic_0 *atomic, RwFrame_0 *frame)
{
  _rwObjectHasFrameSetFrame(atomic, frame);
  atomic->object.object.privateFlags |= 1u;
  return atomic;
}

//----- (002141EA) --------------------------------------------------------
RpAtomic_0 *__fastcall RpAtomicSetGeometry(RpAtomic_0 *atomic, RpGeometry_0 *geometry, RwUInt32 flags)
{
  RpGeometry_0 *v5; // r0
  __int64 v7; // d17
  RwFrame_0 *parent; // r5

  v5 = atomic->geometry;
  if ( v5 != geometry )
  {
    if ( geometry )
    {
      _rpGeometryAddRef(geometry);
      v5 = atomic->geometry;
    }
    if ( v5 )
      RpGeometryDestroy(v5);
    atomic->geometry = geometry;
    if ( !(flags << 31) )
    {
      if ( geometry )
      {
        v7 = *(_QWORD *)&geometry->morphTarget->boundingSphere.center.z;
        *(_QWORD *)&atomic->boundingSphere.center.x = *(_QWORD *)&geometry->morphTarget->boundingSphere.center.x;
        *(_QWORD *)&atomic->boundingSphere.center.z = v7;
      }
      parent = (RwFrame_0 *)atomic->object.object.parent;
      if ( parent && RpAtomicGetWorld(atomic) )
        RwFrameUpdateObjects(parent);
    }
  }
  return atomic;
}

//----- (00214244) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpAddAtomic(RpClump_0 *clump, RpAtomic_0 *atomic)
{
  RwLLLink_0 *p_inClumpLink; // r1

  atomic->inClumpLink.next = clump->atomicList.link.next;
  p_inClumpLink = &atomic->inClumpLink;
  p_inClumpLink->prev = &clump->atomicList.link;
  clump->atomicList.link.next->prev = p_inClumpLink;
  clump->atomicList.link.next = p_inClumpLink;
  p_inClumpLink[-1].prev = (RwLLLink *)clump;
  return clump;
}

//----- (0021425C) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpRender(RpClump_0 *clump)
{
  RpClump_0 *v1; // r4
  RwLinkList_0 *p_atomicList; // r5
  RwLinkList_0 *next; // r6

  v1 = clump;
  p_atomicList = &clump->atomicList;
  next = &clump->atomicList;
  while ( 1 )
  {
    next = (RwLinkList_0 *)next->link.next;
    if ( next == p_atomicList )
      break;
    if ( (BYTE2(next[-8].link.next) & 4) != 0 )
    {
      RwFrameGetLTM((RwFrame_0 *)next[-8].link.prev);
      if ( !((int (__fastcall *)(RwLinkList_0 *))next[1].link.next)(&next[-8]) )
        v1 = 0;
    }
  }
  return v1;
}

//----- (0021429E) --------------------------------------------------------
RwObjectHasFrame_0 *__fastcall AtomicSync(RwObjectHasFrame_0 *object)
{
  if ( ((int)object[3].sync & 2) != 0 )
    _rpAtomicResyncInterpolatedSphere((RpAtomic_0 *)object);
  object->object.privateFlags |= 1u;
  return object;
}

//----- (002142C0) --------------------------------------------------------
RpClump_0 *__fastcall RpLightGetClump(const RpLight_0 *light)
{
  return *(RpClump_0 **)(&light->object.object.type + _rpClumpLightExtOffset);
}

//----- (002142D0) --------------------------------------------------------
RpClump_0 *__fastcall RwCameraGetClump(const RwCamera_0 *camera)
{
  return *(RpClump_0 **)(&camera->object.object.type + _rpClumpCameraExtOffset);
}

//----- (002142E0) --------------------------------------------------------
RpAtomic_0 *__fastcall RpAtomicClone(RpAtomic_0 *atomic)
{
  char *v2; // r0
  RwUInt8 *v3; // r5
  RpGeometry_0 **v4; // r9
  RwUInt8 v5; // r1
  RwUInt8 privateFlags; // r0
  RpGeometry_0 *v7; // r0
  RpGeometry_0 *geometry; // r6
  __int64 v9; // d17
  RwFrame_0 *v10; // r6
  __int64 v11; // d17
  __int64 v12; // d17
  RwReal position; // r1

  v2 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + clumpModule));
  v3 = (RwUInt8 *)v2;
  if ( !v2 )
    return 0;
  *(_DWORD *)(v2 + 1) = 0;
  v2[7] = 0;
  *(_WORD *)(v2 + 5) = 0;
  *v2 = 1;
  *((_DWORD *)v2 + 4) = AtomicSync;
  *((_DWORD *)v2 + 5) = 0;
  *((_WORD *)v2 + 1) = 261;
  _rwObjectHasFrameSetFrame(v2, 0);
  v4 = (RpGeometry_0 **)(v3 + 24);
  *((_QWORD *)v3 + 5) = 0LL;
  *((_QWORD *)v3 + 6) = 0LL;
  *((_QWORD *)v3 + 3) = 0LL;
  *((_QWORD *)v3 + 4) = 0LL;
  *((_DWORD *)v3 + 20) = 0;
  *((_DWORD *)v3 + 21) = 1065353216;
  *((_DWORD *)v3 + 22) = 1065353216;
  *((_DWORD *)v3 + 23) = 0;
  *((_DWORD *)v3 + 14) = 0;
  *((_DWORD *)v3 + 15) = 0;
  *((_DWORD *)v3 + 16) = 0;
  *((_DWORD *)v3 + 17) = 0;
  *((_DWORD *)v3 + 18) = AtomicDefaultRenderCallBack;
  v5 = v3[3];
  *((_DWORD *)v3 + 25) = v3 + 100;
  *((_DWORD *)v3 + 26) = v3 + 100;
  *((_DWORD *)v3 + 27) = 0;
  v3[3] = v5 | 1;
  *((_DWORD *)v3 + 19) = 3;
  _rwPluginRegistryInitObject(&atomicTKList, v3);
  *v3 = atomic->object.object.type;
  v3[1] = atomic->object.object.subType;
  v3[2] = atomic->object.object.flags;
  privateFlags = atomic->object.object.privateFlags;
  *((_DWORD *)v3 + 1) = 0;
  v3[3] = privateFlags;
  v3[2] = atomic->object.object.flags;
  _rwObjectHasFrameSetFrame(v3, 0);
  v7 = (RpGeometry_0 *)*((_DWORD *)v3 + 6);
  v3[3] |= 1u;
  geometry = atomic->geometry;
  if ( v7 != geometry )
  {
    if ( geometry )
    {
      _rpGeometryAddRef(atomic->geometry);
      v7 = *v4;
    }
    if ( v7 )
      RpGeometryDestroy(v7);
    *v4 = geometry;
    if ( geometry )
    {
      v9 = *(_QWORD *)&geometry->morphTarget->boundingSphere.center.z;
      *(_QWORD *)(v3 + 28) = *(_QWORD *)&geometry->morphTarget->boundingSphere.center.x;
      *(_QWORD *)(v3 + 36) = v9;
    }
    v10 = (RwFrame_0 *)*((_DWORD *)v3 + 1);
    if ( v10 && RpAtomicGetWorld((const RpAtomic_0 *)v3) )
      RwFrameUpdateObjects(v10);
  }
  v11 = *(_QWORD *)&atomic->boundingSphere.center.z;
  *(_QWORD *)(v3 + 28) = *(_QWORD *)&atomic->boundingSphere.center.x;
  *(_QWORD *)(v3 + 36) = v11;
  *((_DWORD *)v3 + 18) = atomic->renderCallBack;
  *((_DWORD *)v3 + 27) = atomic->pipeline;
  v12 = *(_QWORD *)&atomic->interpolator.time;
  position = atomic->interpolator.position;
  *(_QWORD *)(v3 + 76) = *(_QWORD *)&atomic->interpolator.flags;
  *(_QWORD *)(v3 + 84) = v12;
  *((RwReal *)v3 + 23) = position;
  _rwPluginRegistryCopyObject(&atomicTKList, v3, atomic);
  return (RpAtomic_0 *)v3;
}
// 6BD598: using guessed type int clumpModule;

//----- (0021444C) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpClone(RpClump_0 *clump)
{
  char *v2; // r0
  RpClump_0 *v3; // r11
  RwFrame_0 *v4; // r0
  RpClump_0 *next; // r5
  RpClump_0 *v6; // r4
  RpAtomic_0 *v7; // r6
  RwLLLink *prev; // r0
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  v2 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                 + clumpModule
                                                                                 + 4));
  v3 = (RpClump_0 *)v2;
  if ( !v2 )
    return 0;
  v2[7] = 0;
  *(_WORD *)(v2 + 5) = 0;
  *v2 = 2;
  *((_DWORD *)v2 + 2) = v2 + 8;
  *((_DWORD *)v2 + 3) = v2 + 8;
  *((_DWORD *)v2 + 4) = v2 + 16;
  *((_DWORD *)v2 + 5) = v2 + 16;
  *((_DWORD *)v2 + 6) = v2 + 24;
  *((_DWORD *)v2 + 7) = v2 + 24;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *(_DWORD *)(v2 + 1) = 0;
  *((_DWORD *)v2 + 10) = ClumpCallBack;
  _rwPluginRegistryInitObject(&clumpTKList, v2);
  v4 = _rwFrameCloneAndLinkClones((RwFrame_0 *)clump->object.parent);
  v3->object.parent = v4;
  if ( v4 )
  {
    next = (RpClump_0 *)clump->atomicList.link.next;
    if ( next != (RpClump_0 *)&clump->atomicList )
    {
      while ( 1 )
      {
        v6 = *(RpClump_0 **)&next->object.type;
        v7 = RpAtomicClone((RpAtomic_0 *)&next[-2].inWorldLink);
        if ( !v7 )
        {
          _rwFramePurgeClone((RwFrame_0 *)clump->object.parent);
          goto LABEL_10;
        }
        prev = next[-2].inWorldLink.prev;
        if ( !prev )
          break;
        _rwObjectHasFrameSetFrame(v7, (RwFrame_0 *)prev[20].next);
        next = v6;
        v7->object.object.privateFlags |= 1u;
        v7->inClumpLink.next = v3->atomicList.link.next;
        v7->inClumpLink.prev = &v3->atomicList.link;
        v3->atomicList.link.next->prev = &v7->inClumpLink;
        v3->atomicList.link.next = &v7->inClumpLink;
        v7->clump = v3;
        if ( v6 == (RpClump_0 *)&clump->atomicList )
          goto LABEL_12;
      }
      RpAtomicDestroy(v7);
      code.pluginID = 0;
      code.errorCode = _rwerror(5);
      RwErrorSet(&code);
    }
LABEL_12:
    _rwFramePurgeClone((RwFrame_0 *)clump->object.parent);
    v3->callback = clump->callback;
    _rwPluginRegistryCopyObject(&clumpTKList, v3, clump);
  }
  else
  {
LABEL_10:
    RpClumpDestroy(v3);
    return 0;
  }
  return v3;
}
// 6BD598: using guessed type int clumpModule;

//----- (0021458C) --------------------------------------------------------
RwBool __fastcall RpClumpDestroy(RpClump_0 *clump)
{
  RpClump_0 *next; // r9
  RwLinkList_0 *p_atomicList; // r10
  RpClump_0 *v4; // r5
  RpAtomic_0 *p_inWorldLink; // r6
  RwResEntry_0 *parent; // r0
  RpGeometry_0 *v7; // r0
  RwFrame_0 *prev; // r4
  RwLinkList_0 *v9; // r0
  RwLinkList_0 v10; // kr00_8
  RwInt32 v11; // r2
  RpLight_0 *v12; // r4
  RwLinkList_0 *v13; // r0
  RwLinkList_0 v14; // kr08_8
  RwInt32 v15; // r2
  RwCamera_0 *v16; // r4
  RwFrame_0 *v17; // r0
  RpClump_0 *v19; // [sp+0h] [bp-20h]

  _rwPluginRegistryDeInitObject(&clumpTKList, clump);
  v19 = clump;
  p_atomicList = &clump->atomicList;
  next = (RpClump_0 *)clump->atomicList.link.next;
  if ( next != (RpClump_0 *)&clump->atomicList )
  {
    do
    {
      v4 = next;
      p_inWorldLink = (RpAtomic_0 *)&next[-2].inWorldLink;
      next = *(RpClump_0 **)&next->object.type;
      _rwPluginRegistryDeInitObject(&atomicTKList, p_inWorldLink);
      parent = (RwResEntry_0 *)v4[-1].object.parent;
      if ( parent )
        RwResourcesFreeResEntry(parent);
      v7 = (RpGeometry_0 *)v4[-1].atomicList.link.next;
      if ( v7 )
      {
        RpGeometryDestroy(v7);
        prev = (RwFrame_0 *)v4[-2].inWorldLink.prev;
        v4[-1].atomicList.link.next = 0;
        if ( prev )
        {
          if ( RpAtomicGetWorld(p_inWorldLink) )
            RwFrameUpdateObjects(prev);
        }
      }
      _rwObjectHasFrameReleaseFrame(p_inWorldLink);
      (*((void (__fastcall **)(_DWORD, RpAtomic_0 *))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + clumpModule),
        p_inWorldLink);
    }
    while ( next != (RpClump_0 *)p_atomicList );
  }
  v9 = (RwLinkList_0 *)v19->lightList.link.next;
  do
  {
    if ( v9 == &v19->lightList )
      break;
    v10 = *v9;
    v11 = _rpClumpLightExtOffset;
    v9->link.prev->next = v9->link.next;
    v9->link.next->prev = v9->link.prev;
    v9->link.next = 0;
    v9->link.prev = 0;
    v9[-1].link.prev = 0;
    v12 = (RpLight_0 *)((char *)&v9[-1].link.prev - v11);
    RpLightDestroy(v12);
    v9 = (RwLinkList_0 *)v10.link.next;
  }
  while ( v12 );
  v13 = (RwLinkList_0 *)v19->cameraList.link.next;
  do
  {
    if ( v13 == &v19->cameraList )
      break;
    v14 = *v13;
    v15 = _rpClumpCameraExtOffset;
    v13->link.prev->next = v13->link.next;
    v13->link.next->prev = v13->link.prev;
    v13->link.next = 0;
    v13->link.prev = 0;
    v13[-1].link.prev = 0;
    v16 = (RwCamera_0 *)((char *)&v13[-1].link.prev - v15);
    RwCameraDestroy(v16);
    v13 = (RwLinkList_0 *)v14.link.next;
  }
  while ( v16 );
  v17 = (RwFrame_0 *)v19->object.parent;
  if ( v17 )
    RwFrameDestroyHierarchy(v17);
  (*((void (__fastcall **)(_DWORD, RpClump_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + clumpModule + 4),
    v19);
  return 1;
}
// 6BD598: using guessed type int clumpModule;

//----- (002146E4) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpSetCallBack(RpClump_0 *clump, RpClumpCallBack callback)
{
  RpClump_0 *(*v2)(RpClump_0 *, void *); // r2

  v2 = ClumpCallBack;
  if ( callback )
    v2 = callback;
  clump->callback = v2;
  return clump;
}

//----- (002146FC) --------------------------------------------------------
RpClumpCallBack __fastcall RpClumpGetCallBack(const RpClump_0 *clump)
{
  RpClumpCallBack result; // r0

  result = clump->callback;
  if ( result == ClumpCallBack )
    return 0;
  return result;
}

//----- (00214710) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpRemoveAtomic(RpClump_0 *clump, RpAtomic_0 *atomic)
{
  atomic->inClumpLink.prev->next = atomic->inClumpLink.next;
  atomic->inClumpLink.next->prev = atomic->inClumpLink.prev;
  atomic->clump = 0;
  return clump;
}

//----- (00214724) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpAddLight(RpClump_0 *clump, RpLight_0 *light)
{
  RwLLLink *next; // r12
  RwInt32 v3; // lr
  RwLLLink *v4; // r2

  next = clump->lightList.link.next;
  v3 = _rpClumpLightExtOffset;
  v4 = (RwLLLink *)(&light->object.object.type + _rpClumpLightExtOffset);
  v4[1].next = &clump->lightList.link;
  v4->prev = next;
  v4 = (RwLLLink *)((char *)v4 + 4);
  clump->lightList.link.next->prev = v4;
  clump->lightList.link.next = v4;
  *(_DWORD *)(&light->object.object.type + v3) = clump;
  return clump;
}

//----- (00214750) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpRemoveLight(RpClump_0 *clump, RpLight_0 *light)
{
  RwUInt8 *v2; // r3

  v2 = &light->object.object.type + _rpClumpLightExtOffset;
  **(_DWORD **)((char *)&light->object.lFrame.next + _rpClumpLightExtOffset) = *(void **)((char *)&light->object.object.parent
                                                                                        + _rpClumpLightExtOffset);
  *(_DWORD *)(*((_DWORD *)v2 + 1) + 4) = *((_DWORD *)v2 + 2);
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 2) = 0;
  return clump;
}

//----- (00214780) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpAddCamera(RpClump_0 *clump, RwCamera_0 *camera)
{
  RwLLLink *next; // r12
  RwInt32 v3; // lr
  RwLLLink *v4; // r2

  next = clump->cameraList.link.next;
  v3 = _rpClumpCameraExtOffset;
  v4 = (RwLLLink *)(&camera->object.object.type + _rpClumpCameraExtOffset);
  v4[1].next = &clump->cameraList.link;
  v4->prev = next;
  v4 = (RwLLLink *)((char *)v4 + 4);
  clump->cameraList.link.next->prev = v4;
  clump->cameraList.link.next = v4;
  *(_DWORD *)(&camera->object.object.type + v3) = clump;
  return clump;
}

//----- (002147AC) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpRemoveCamera(RpClump_0 *clump, RwCamera_0 *camera)
{
  RwUInt8 *v2; // r3

  v2 = &camera->object.object.type + _rpClumpCameraExtOffset;
  **(_DWORD **)((char *)&camera->object.lFrame.next + _rpClumpCameraExtOffset) = *(void **)((char *)&camera->object.object.parent
                                                                                          + _rpClumpCameraExtOffset);
  *(_DWORD *)(*((_DWORD *)v2 + 1) + 4) = *((_DWORD *)v2 + 2);
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 2) = 0;
  return clump;
}

//----- (002147DC) --------------------------------------------------------
RwUInt32 __fastcall RpAtomicStreamGetSize(RpAtomic_0 *atomic)
{
  RwUInt32 Size; // r5

  Size = RpGeometryStreamGetSize(atomic->geometry);
  return _rwPluginRegistryGetSize(&atomicTKList, atomic) + Size + 52;
}

//----- (00214800) --------------------------------------------------------
RwUInt32 __fastcall RpClumpStreamGetSize(RpClump_0 *clump)
{
  RwUInt32 v2; // r6
  RwUInt32 Size; // r8
  RwInt32 numGeoms; // r0
  RwInt32 v5; // r4
  int v6; // r5
  RwUInt32 v7; // r1
  int v8; // r6
  RwInt32 v9; // r4
  RpClump_0 *next; // r1
  RpClump_0 *v11; // r5
  RwLLLink *v12; // r0
  RwLLLink *v13; // r4
  const RpLight_0 *v14; // r5
  RwLLLink *v15; // r0
  RwLLLink *v16; // r4
  const RwCamera_0 *v17; // r5
  rpGeometryList_0 v19; // [sp+0h] [bp-28h] BYREF
  rwFrameList_0 frameList; // [sp+8h] [bp-20h] BYREF

  v2 = 0;
  if ( _rwFrameListInitialize(&frameList, (RwFrame_0 *)clump->object.parent) )
  {
    Size = _rwFrameListStreamGetSize(&frameList);
    _rwFrameListDeinitialize(&frameList);
    v19.numGeoms = 0;
    if ( GeometryListInitialize(&v19, clump) )
    {
      numGeoms = v19.numGeoms;
      if ( v19.numGeoms < 1 )
      {
        v6 = 16;
      }
      else
      {
        v5 = 0;
        v6 = 16;
        do
        {
          v7 = v6 + RpGeometryStreamGetSize(v19.geometries[v5]);
          numGeoms = v19.numGeoms;
          ++v5;
          v6 = v7 + 12;
        }
        while ( v5 < v19.numGeoms );
      }
      v8 = Size + v6 + 48;
      if ( numGeoms )
      {
        if ( numGeoms >= 1 )
        {
          v9 = 0;
          do
            RpGeometryDestroy(v19.geometries[v9++]);
          while ( v9 < v19.numGeoms );
        }
        (*((void (__fastcall **)(RpGeometry_0 **))RwEngineInstance + 76))(v19.geometries);
      }
      next = (RpClump_0 *)clump->atomicList.link.next;
      if ( next != (RpClump_0 *)&clump->atomicList )
      {
        do
        {
          v11 = *(RpClump_0 **)&next->object.type;
          v8 += _rwPluginRegistryGetSize(&atomicTKList, &next[-2].inWorldLink) + 52;
          next = v11;
        }
        while ( v11 != (RpClump_0 *)&clump->atomicList );
      }
      v12 = clump->lightList.link.next;
      do
      {
        if ( v12 == (RwLLLink *)&clump->lightList )
          break;
        v13 = v12->next;
        v14 = (const RpLight_0 *)((char *)v12 - _rpClumpLightExtOffset - 4);
        v8 += RpLightStreamGetSize(v14) + 28;
        v12 = v13;
      }
      while ( v14 );
      v15 = clump->cameraList.link.next;
      do
      {
        if ( v15 == (RwLLLink *)&clump->cameraList )
          break;
        v16 = v15->next;
        v17 = (const RwCamera_0 *)((char *)v15 - _rpClumpCameraExtOffset - 4);
        v8 += RwCameraStreamGetSize(v17) + 28;
        v15 = v16;
      }
      while ( v17 );
      return _rwPluginRegistryGetSize(&clumpTKList, clump) + v8 + 12;
    }
  }
  return v2;
}

//----- (00214944) --------------------------------------------------------
rpGeometryList_0 *__fastcall GeometryListInitialize(rpGeometryList_0 *geomList, RpClump_0 *clump)
{
  RwLinkList_0 *p_atomicList; // r9
  int v4; // r0
  int v5; // r6
  RwLinkList_0 *next; // r1
  RpGeometry_0 **v7; // r10
  RwLinkList_0 *v8; // r4
  RwInt32 v9; // r0
  RwLinkList_0 *v10; // r1
  RpGeometry_0 *v11; // r6
  int v12; // r3
  RwError_0 v14; // [sp+0h] [bp-20h] BYREF

  p_atomicList = &clump->atomicList;
  v4 = -1;
  v5 = -4;
  next = &clump->atomicList;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    v5 += 4;
    ++v4;
  }
  while ( next != p_atomicList );
  if ( v4 < 1 )
  {
    v7 = 0;
    geomList->geometries = 0;
  }
  else
  {
    v7 = (RpGeometry_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v5);
    geomList->geometries = v7;
    if ( !v7 )
    {
      geomList = 0;
      v14.pluginID = 0;
      v14.errorCode = _rwerror(-2147483629, v5);
      RwErrorSet(&v14);
      return geomList;
    }
  }
  geomList->numGeoms = 0;
  v8 = (RwLinkList_0 *)p_atomicList->link.next;
  if ( (RwLinkList_0 *)p_atomicList->link.next != p_atomicList )
  {
    v9 = 0;
    do
    {
      v10 = v8;
      while ( 1 )
      {
        v11 = (RpGeometry_0 *)v10[-5].link.next;
        if ( v9 < 1 )
          break;
        v12 = 0;
        while ( geomList->geometries[v12] != v11 )
        {
          if ( ++v12 >= v9 )
          {
            v8 = v10;
            goto LABEL_17;
          }
        }
        v10 = (RwLinkList_0 *)v10->link.next;
        if ( v10 == p_atomicList )
          return geomList;
      }
LABEL_17:
      _rpGeometryAddRef((RpGeometry_0 *)v10[-5].link.next);
      *v7++ = v11;
      v9 = geomList->numGeoms + 1;
      geomList->numGeoms = v9;
      v8 = (RwLinkList_0 *)v8->link.next;
    }
    while ( v8 != p_atomicList );
  }
  return geomList;
}

//----- (00214A10) --------------------------------------------------------
RpAtomic_0 *__fastcall RpAtomicStreamWrite(RpAtomic_0 *atomic, RwStream_0 *stream)
{
  int v3[8]; // [sp+0h] [bp-20h] BYREF

  v3[0] = (int)stream;
  v3[5] = 1;
  v3[2] = 0;
  v3[4] = 0;
  return ClumpAtomicStreamWrite(atomic, v3);
}

//----- (00214A2C) --------------------------------------------------------
RpAtomic_0 *__fastcall ClumpAtomicStreamWrite(RpAtomic_0 *atomic, void *pData)
{
  RpAtomic_0 *v3; // r4
  RwStream_0 *v4; // r6
  RwInt32 v5; // r2
  RwUInt32 Size; // r9
  int v7; // r0
  RwInt32 v8; // r2
  RwInt32 npIndex[10]; // [sp+8h] [bp-28h] BYREF

  v3 = atomic;
  v4 = *(RwStream_0 **)pData;
  if ( *((_DWORD *)pData + 4) )
  {
    v5 = _rwPluginRegistryGetSize(&atomicTKList, atomic) + 40;
  }
  else
  {
    Size = RpGeometryStreamGetSize(atomic->geometry);
    v5 = _rwPluginRegistryGetSize(&atomicTKList, v3) + Size + 52;
  }
  if ( !_rwStreamWriteVersionedChunkHeader(v4, 20, v5, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    goto LABEL_20;
  if ( !_rwStreamWriteVersionedChunkHeader(*(RwStream_0 **)pData, 1, 16, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  npIndex[2] = v3->object.object.flags;
  npIndex[3] = 0;
  if ( *((_DWORD *)pData + 2) )
  {
    if ( !_rwFrameListFindFrame(
            (const rwFrameList_0 *)((char *)pData + 4),
            (const RwFrame_0 *)v3->object.object.parent,
            npIndex) )
      goto LABEL_20;
  }
  v7 = *((_DWORD *)pData + 4);
  if ( !v7 )
    goto LABEL_16;
  if ( v7 < 1 )
  {
LABEL_20:
    v3 = 0;
    *((_DWORD *)pData + 5) = 0;
    return v3;
  }
  v8 = 0;
  while ( *(RpGeometry_0 **)(*((_DWORD *)pData + 3) + 4 * v8) != v3->geometry )
  {
    if ( ++v8 >= v7 )
      goto LABEL_20;
  }
  npIndex[1] = v8;
LABEL_16:
  RwMemLittleEndian32(npIndex, 0x10u);
  if ( !RwStreamWrite(*(RwStream_0 **)pData, npIndex, 0x10u)
    || !*((_DWORD *)pData + 4) && !RpGeometryStreamWrite(v3->geometry, *(RwStream_0 **)pData)
    || !_rwPluginRegistryWriteDataChunks(&atomicTKList, *(RwStream_0 **)pData, v3) )
  {
    goto LABEL_20;
  }
  return v3;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (00214B28) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpStreamWrite(RpClump_0 *clump, RwStream_0 *stream)
{
  RwInt32 Size; // r0
  RwLinkList_0 *p_atomicList; // r8
  int v6; // r0
  RwLinkList_0 *next; // r1
  RwLinkList_0 *p_lightList; // r9
  RwLinkList_0 *v9; // r2
  int v10; // r0
  bool v11; // zf
  RwLinkList_0 *p_cameraList; // r5
  RwLinkList_0 *v13; // r2
  int v14; // r0
  bool v15; // zf
  RpClump_0 *v16; // r6
  RwInt32 v17; // r10
  RwInt32 v18; // r6
  RwUInt32 v19; // r0
  int v20; // r6
  RwLinkList_0 *v21; // r0
  RwLinkList_0 *v22; // r6
  int v23; // r0
  char *v24; // r10
  RwLinkList_0 *v25; // r0
  RwLinkList_0 *v26; // r8
  const RpLight_0 *v27; // r6
  RwInt32 v28; // r4
  RwLinkList_0 *v30; // r0
  RwLinkList_0 *v31; // r8
  const RwCamera_0 *v32; // r6
  RwInt32 v33; // r5
  RwStream_0 *pData; // [sp+Ch] [bp-44h] BYREF
  rwFrameList_0 v35; // [sp+10h] [bp-40h] BYREF
  rpGeometryList_0 v36; // [sp+18h] [bp-38h] BYREF
  int v37; // [sp+20h] [bp-30h]
  int mem; // [sp+24h] [bp-2Ch] BYREF
  int v39; // [sp+28h] [bp-28h]
  int v40; // [sp+2Ch] [bp-24h]
  RwInt32 npIndex[8]; // [sp+30h] [bp-20h] BYREF

  Size = RpClumpStreamGetSize(clump);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 16, Size, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(stream, 1, 12, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    return 0;
  }
  p_atomicList = &clump->atomicList;
  v6 = -1;
  next = &clump->atomicList;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    ++v6;
  }
  while ( next != p_atomicList );
  p_lightList = &clump->lightList;
  mem = v6;
  v9 = &clump->lightList;
  v10 = 0;
  do
  {
    v9 = (RwLinkList_0 *)v9->link.next;
    v11 = v9 == p_lightList;
    if ( v9 != p_lightList )
    {
      ++v10;
      v11 = (char *)v9 - _rpClumpLightExtOffset == byte_4;
    }
  }
  while ( !v11 );
  p_cameraList = &clump->cameraList;
  v39 = v10;
  v13 = &clump->cameraList;
  v14 = 0;
  do
  {
    v13 = (RwLinkList_0 *)v13->link.next;
    v15 = v13 == p_cameraList;
    if ( v13 != p_cameraList )
    {
      ++v14;
      v15 = (char *)v13 - _rpClumpCameraExtOffset == byte_4;
    }
  }
  while ( !v15 );
  v40 = v14;
  RwMemLittleEndian32(&mem, 0xCu);
  if ( !RwStreamWrite(stream, &mem, 0xCu) || !_rwFrameListInitialize(&v35, (RwFrame_0 *)clump->object.parent) )
    return 0;
  if ( !_rwFrameListStreamWrite(&v35, stream) )
  {
    _rwFrameListDeinitialize(&v35);
    return 0;
  }
  v16 = 0;
  v36.numGeoms = 0;
  if ( !GeometryListInitialize(&v36, clump) )
    return v16;
  if ( v36.numGeoms < 1 )
  {
    v18 = 16;
  }
  else
  {
    v17 = 0;
    v18 = 16;
    do
    {
      v19 = RpGeometryStreamGetSize(v36.geometries[v17++]);
      v18 += v19 + 12;
    }
    while ( v17 < v36.numGeoms );
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 26, v18, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(stream, 1, 4, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || (npIndex[0] = v36.numGeoms, RwMemLittleEndian32(npIndex, 4u), !RwStreamWrite(stream, npIndex, 4u)) )
  {
LABEL_46:
    if ( v36.numGeoms )
    {
      if ( v36.numGeoms >= 1 )
      {
        v28 = 0;
        do
          RpGeometryDestroy(v36.geometries[v28++]);
        while ( v28 < v36.numGeoms );
      }
      (*((void (__fastcall **)(RpGeometry_0 **))RwEngineInstance + 76))(v36.geometries);
    }
    return 0;
  }
  if ( v36.numGeoms >= 1 )
  {
    v20 = 0;
    while ( RpGeometryStreamWrite(v36.geometries[v20], stream) )
    {
      if ( ++v20 >= v36.numGeoms )
        goto LABEL_32;
    }
    goto LABEL_46;
  }
LABEL_32:
  pData = stream;
  v37 = 1;
  v21 = (RwLinkList_0 *)p_atomicList->link.next;
  do
  {
    if ( v21 == p_atomicList )
      break;
    v22 = (RwLinkList_0 *)v21->link.next;
    v11 = ClumpAtomicStreamWrite((RpAtomic_0 *)&v21[-8], &pData) == 0;
    v21 = v22;
  }
  while ( !v11 );
  v23 = v37;
  if ( v39 < 1 )
  {
    v24 = (_BYTE *)(&stru_35FFC + 7);
    goto LABEL_54;
  }
  v24 = (char *)&stru_35FFC.st_value + 3;
  if ( !v37 )
  {
LABEL_54:
    if ( v40 >= 1 && v23 )
    {
      v30 = (RwLinkList_0 *)p_cameraList->link.next;
      while ( v30 != p_cameraList )
      {
        v31 = (RwLinkList_0 *)v30->link.next;
        v32 = (const RwCamera_0 *)((char *)v30 - _rpClumpCameraExtOffset - 4);
        if ( !_rwFrameListFindFrame(
                &v35,
                *(const RwFrame_0 **)((char *)&v30->link.next - _rpClumpCameraExtOffset),
                npIndex)
          || !_rwStreamWriteVersionedChunkHeader(pData, 1, 4, (RwUInt32)v24, 0xFFFFu)
          || !RwStreamWriteInt32(pData, npIndex, 4u)
          || !RwCameraStreamWrite(v32, pData) )
        {
          goto LABEL_64;
        }
        v30 = v31;
        if ( !v32 )
          goto LABEL_65;
      }
    }
    goto LABEL_65;
  }
  v25 = (RwLinkList_0 *)p_lightList->link.next;
  while ( 1 )
  {
    if ( v25 == p_lightList )
    {
LABEL_45:
      v23 = v37;
      goto LABEL_54;
    }
    v26 = (RwLinkList_0 *)v25->link.next;
    v27 = (const RpLight_0 *)((char *)v25 - _rpClumpLightExtOffset - 4);
    if ( !_rwFrameListFindFrame(&v35, *(const RwFrame_0 **)((char *)&v25->link.next - _rpClumpLightExtOffset), npIndex)
      || !_rwStreamWriteVersionedChunkHeader(pData, 1, 4, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
      || !RwStreamWriteInt32(pData, npIndex, 4u)
      || !RpLightStreamWrite(v27, pData) )
    {
      break;
    }
    v25 = v26;
    if ( !v27 )
      goto LABEL_45;
  }
LABEL_64:
  v37 = 0;
LABEL_65:
  if ( v36.numGeoms )
  {
    if ( v36.numGeoms >= 1 )
    {
      v33 = 0;
      do
        RpGeometryDestroy(v36.geometries[v33++]);
      while ( v33 < v36.numGeoms );
    }
    (*((void (__fastcall **)(RpGeometry_0 **))RwEngineInstance + 76))(v36.geometries);
  }
  _rwFrameListDeinitialize(&v35);
  if ( !v37 )
    return 0;
  v16 = (RpClump_0 *)_rwPluginRegistryWriteDataChunks(&clumpTKList, stream, clump);
  if ( v16 )
    return clump;
  return v16;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (00214E5C) --------------------------------------------------------
RpAtomic_0 *__fastcall RpAtomicStreamRead(RwStream_0 *stream)
{
  rpGeometryList_0 v2; // [sp+0h] [bp-18h] BYREF
  rwFrameList_0 fl; // [sp+8h] [bp-10h] BYREF

  fl.numFrames = 0;
  v2.numGeoms = 0;
  return ClumpAtomicStreamRead(stream, &fl, &v2);
}

//----- (00214E74) --------------------------------------------------------
RpAtomic_0 *__fastcall ClumpAtomicStreamRead(RwStream_0 *stream, rwFrameList_0 *fl, rpGeometryList_0 *gl)
{
  RwUInt32 v6; // r4
  char *v7; // r0
  char *v8; // r6
  RpAtomic_0 *v9; // r4
  RpGeometry_0 **v10; // r11
  char v11; // r1
  RpGeometry_0 *v12; // r0
  RpGeometry_0 *v13; // r4
  __int64 v14; // d17
  RwFrame_0 *v15; // r4
  RwInt32 v16; // r0
  RwError_0 *p_buffer; // r0
  RpGeometry_0 *v18; // r4
  RwFrame_0 *v19; // r5
  __int64 v20; // d17
  RwInt32 v21; // r0
  int v23[2]; // [sp+0h] [bp-40h] BYREF
  __int64 buffer; // [sp+8h] [bp-38h] BYREF
  __int64 v25; // [sp+10h] [bp-30h]
  RwUInt32 versionOut; // [sp+1Ch] [bp-24h] BYREF
  RwUInt32 lengthOut[8]; // [sp+20h] [bp-20h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
  {
    v9 = 0;
    v16 = -2147483622;
LABEL_20:
    LODWORD(buffer) = 0;
    HIDWORD(buffer) = _rwerror(v16);
    p_buffer = (RwError_0 *)&buffer;
LABEL_41:
    RwErrorSet(p_buffer);
    return v9;
  }
  if ( versionOut - 212992 > 0x2003 )
  {
    v16 = -2147483644;
    v9 = 0;
    goto LABEL_20;
  }
  v6 = lengthOut[0];
  buffer = 0LL;
  v25 = 0LL;
  if ( v6 != RwStreamRead(stream, &buffer, lengthOut[0]) )
  {
LABEL_38:
    v9 = 0;
    goto LABEL_39;
  }
  RwMemNative32(&buffer, 0x10u);
  v7 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + clumpModule));
  v8 = v7;
  v9 = 0;
  if ( !v7 )
    return v9;
  *(_DWORD *)(v7 + 1) = 0;
  v7[7] = 0;
  *(_WORD *)(v7 + 5) = 0;
  *v7 = 1;
  *((_DWORD *)v7 + 4) = AtomicSync;
  *((_DWORD *)v7 + 5) = 0;
  *((_WORD *)v7 + 1) = 261;
  _rwObjectHasFrameSetFrame(v7, 0);
  v10 = (RpGeometry_0 **)(v8 + 24);
  *((_QWORD *)v8 + 5) = 0LL;
  *((_QWORD *)v8 + 6) = 0LL;
  *((_QWORD *)v8 + 3) = 0LL;
  *((_QWORD *)v8 + 4) = 0LL;
  *((_DWORD *)v8 + 22) = 1065353216;
  *((_DWORD *)v8 + 23) = 0;
  *((_DWORD *)v8 + 14) = 0;
  *((_DWORD *)v8 + 15) = 0;
  *((_DWORD *)v8 + 16) = 0;
  *((_DWORD *)v8 + 17) = 0;
  *((_DWORD *)v8 + 18) = AtomicDefaultRenderCallBack;
  *((_DWORD *)v8 + 19) = 3;
  *((_DWORD *)v8 + 20) = 0;
  *((_DWORD *)v8 + 21) = 1065353216;
  v11 = v8[3] | 1;
  *((_DWORD *)v8 + 25) = v8 + 100;
  *((_DWORD *)v8 + 26) = v8 + 100;
  *((_DWORD *)v8 + 27) = 0;
  v8[3] = v11;
  _rwPluginRegistryInitObject(&atomicTKList, v8);
  v8[2] = v25;
  if ( fl->numFrames )
  {
    _rwObjectHasFrameSetFrame(v8, fl->frames[buffer]);
    v8[3] |= 1u;
  }
  if ( gl->numGeoms )
  {
    v12 = *v10;
    v13 = gl->geometries[HIDWORD(buffer)];
    if ( *v10 != v13 )
    {
      if ( v13 )
      {
        _rpGeometryAddRef(gl->geometries[HIDWORD(buffer)]);
        v12 = *v10;
      }
      if ( v12 )
        RpGeometryDestroy(v12);
      *v10 = v13;
      if ( v13 )
      {
        v14 = *(_QWORD *)&v13->morphTarget->boundingSphere.center.z;
        *(_QWORD *)(v8 + 28) = *(_QWORD *)&v13->morphTarget->boundingSphere.center.x;
        *(_QWORD *)(v8 + 36) = v14;
      }
      v15 = (RwFrame_0 *)*((_DWORD *)v8 + 1);
      if ( v15 && RpAtomicGetWorld((const RpAtomic_0 *)v8) )
        RwFrameUpdateObjects(v15);
    }
    goto LABEL_31;
  }
  v9 = 0;
  if ( !RwStreamFindChunk(stream, 0xFu, 0, &versionOut) )
  {
    RpAtomicDestroy((RpAtomic_0 *)v8);
    goto LABEL_39;
  }
  if ( versionOut - 212992 > 0x2003 )
  {
    RpAtomicDestroy((RpAtomic_0 *)v8);
    v9 = 0;
    v21 = -2147483644;
LABEL_40:
    v23[0] = 0;
    v23[1] = _rwerror(v21);
    p_buffer = (RwError_0 *)v23;
    goto LABEL_41;
  }
  v18 = RpGeometryStreamRead(stream);
  if ( !v18 )
  {
    RpAtomicDestroy((RpAtomic_0 *)v8);
    goto LABEL_38;
  }
  if ( *v10 != v18 )
  {
    _rpGeometryAddRef(v18);
    if ( *v10 )
      RpGeometryDestroy(*v10);
    *((_DWORD *)v8 + 6) = v18;
    v19 = (RwFrame_0 *)*((_DWORD *)v8 + 1);
    v20 = *(_QWORD *)&v18->morphTarget->boundingSphere.center.z;
    *(_QWORD *)(v8 + 28) = *(_QWORD *)&v18->morphTarget->boundingSphere.center.x;
    *(_QWORD *)(v8 + 36) = v20;
    if ( v19 && RpAtomicGetWorld((const RpAtomic_0 *)v8) )
      RwFrameUpdateObjects(v19);
  }
  RpGeometryDestroy(v18);
LABEL_31:
  v9 = 0;
  lastSeenExtraData = 0;
  lastSeenRightsPluginId = 0;
  if ( !_rwPluginRegistryReadDataChunks(&atomicTKList, stream, v8) )
  {
LABEL_39:
    v21 = -2147483622;
    goto LABEL_40;
  }
  if ( lastSeenRightsPluginId )
    _rwPluginRegistryInvokeRights(&atomicTKList, lastSeenRightsPluginId, v8, lastSeenExtraData);
  return (RpAtomic_0 *)v8;
}
// 6BD598: using guessed type int clumpModule;
// 214E74: using guessed type RwUInt32 lengthOut[8];

//----- (00215108) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpStreamRead(RwStream_0 *stream)
{
  int v2; // r4
  RwInt32 i; // r10
  rpGeometryList_0 *v4; // r9
  RpGeometry_0 *v5; // r0
  RwInt32 v6; // r0
  RwError_0 *p_buffer; // r0
  RwInt32 v8; // r0
  int v9; // r9
  RpAtomic_0 *v10; // r0
  RwLLLink_0 *p_inClumpLink; // r0
  RwInt32 v12; // r9
  RwStream_0 *Int32; // r0
  RpLight_0 *v14; // r0
  RpLight_0 *v15; // r5
  RwInt32 v16; // r0
  int v17; // r1
  RwUInt8 *v18; // r2
  int v19; // r9
  RwStream_0 *Chunk; // r0
  RwCamera_0 *v21; // r0
  RwCamera_0 *v22; // r5
  RwInt32 v23; // r0
  int v24; // r1
  RwUInt8 *v25; // r2
  RwInt32 v26; // r5
  RwInt32 v27; // r5
  RwInt32 v28; // r5
  RwInt32 v29; // r5
  int v31; // [sp+0h] [bp-60h] BYREF
  int v32; // [sp+4h] [bp-5Ch]
  RwUInt32 v33; // [sp+8h] [bp-58h] BYREF
  rpGeometryList_0 v34; // [sp+Ch] [bp-54h] BYREF
  rwFrameList_0 frameList; // [sp+14h] [bp-4Ch] BYREF
  int buffer; // [sp+1Ch] [bp-44h] BYREF
  RwInt32 v37; // [sp+20h] [bp-40h]
  int v38; // [sp+24h] [bp-3Ch]
  RwUInt32 versionOut; // [sp+28h] [bp-38h] BYREF
  RwUInt32 lengthOut; // [sp+2Ch] [bp-34h] BYREF
  RwError_0 code; // [sp+30h] [bp-30h] BYREF
  RwUInt32 v42; // [sp+38h] [bp-28h] BYREF
  RwUInt32 v43; // [sp+3Ch] [bp-24h] BYREF
  RwInt32 mem[8]; // [sp+40h] [bp-20h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &versionOut) )
  {
    v2 = 0;
    v6 = -2147483622;
LABEL_22:
    buffer = 0;
    v37 = _rwerror(v6);
    p_buffer = (RwError_0 *)&buffer;
LABEL_81:
    RwErrorSet(p_buffer);
    return (RpClump_0 *)v2;
  }
  if ( versionOut - 212992 > 0x2003 )
  {
    v6 = -2147483644;
    v2 = 0;
    goto LABEL_22;
  }
  if ( RwStreamRead(stream, &buffer, 0xCu) != 12 )
  {
LABEL_80:
    v2 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483622);
    p_buffer = &code;
    goto LABEL_81;
  }
  RwMemNative32(&buffer, 0xCu);
  v2 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + clumpModule + 4));
  if ( !v2 )
    return 0;
  *(_BYTE *)(v2 + 7) = 0;
  *(_WORD *)(v2 + 5) = 0;
  *(_BYTE *)v2 = 2;
  *(_DWORD *)(v2 + 8) = v2 + 8;
  *(_DWORD *)(v2 + 12) = v2 + 8;
  *(_DWORD *)(v2 + 16) = v2 + 16;
  *(_DWORD *)(v2 + 20) = v2 + 16;
  *(_DWORD *)(v2 + 24) = v2 + 24;
  *(_DWORD *)(v2 + 28) = v2 + 24;
  *(_DWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v2 + 1) = 0;
  *(_DWORD *)(v2 + 40) = ClumpCallBack;
  _rwPluginRegistryInitObject(&clumpTKList, (void *)v2);
  if ( !RwStreamFindChunk(stream, 0xEu, 0, &v33) || !_rwFrameListStreamRead(stream, &frameList) )
    goto LABEL_79;
  if ( !RwStreamFindChunk(stream, 0x1Au, 0, &v33) )
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483622);
    RwErrorSet(&code);
    return 0;
  }
  v31 = v2 + 24;
  v32 = v2 + 16;
  if ( !RwStreamFindChunk(stream, 1u, &v43, &v42) )
    goto LABEL_78;
  if ( v42 - 212992 > 0x2003 )
  {
    code.pluginID = 0;
    v8 = _rwerror(-2147483644);
LABEL_27:
    code.errorCode = v8;
    RwErrorSet(&code);
LABEL_78:
    _rwFrameListDeinitialize(&frameList);
LABEL_79:
    RpClumpDestroy((RpClump_0 *)v2);
    goto LABEL_80;
  }
  if ( RwStreamRead(stream, mem, 4u) != 4 )
    goto LABEL_78;
  RwMemNative32(mem, 4u);
  v34.numGeoms = mem[0];
  if ( mem[0] < 1 )
  {
    v34.geometries = 0;
    if ( &v31 == (int *)-12 )
      goto LABEL_78;
    goto LABEL_35;
  }
  v34.geometries = (RpGeometry_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * mem[0]);
  if ( !v34.geometries )
  {
    code.pluginID = 0;
    v8 = _rwerror(-2147483629, 4 * mem[0]);
    goto LABEL_27;
  }
  if ( mem[0] < 1 )
  {
    if ( &v31 == (int *)-12 )
      goto LABEL_78;
  }
  else
  {
    for ( i = 0; i < mem[0]; ++i )
    {
      v4 = 0;
      if ( !RwStreamFindChunk(stream, 0xFu, 0, &v42) )
        break;
      if ( v42 - 212992 > 0x2003 )
        goto LABEL_78;
      v5 = RpGeometryStreamRead(stream);
      v34.geometries[i] = v5;
      if ( !v5 )
      {
        v4 = 0;
        break;
      }
      v4 = &v34;
    }
    if ( !v4 )
      goto LABEL_78;
  }
LABEL_35:
  *(_DWORD *)(v2 + 4) = *frameList.frames;
  if ( buffer >= 1 )
  {
    v9 = 0;
    while ( RwStreamFindChunk(stream, 0x14u, 0, &versionOut) )
    {
      v10 = ClumpAtomicStreamRead(stream, &frameList, &v34);
      if ( !v10 )
        break;
      ++v9;
      v10->inClumpLink.next = *(RwLLLink **)(v2 + 8);
      p_inClumpLink = &v10->inClumpLink;
      p_inClumpLink->prev = (RwLLLink *)(v2 + 8);
      *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4) = p_inClumpLink;
      *(_DWORD *)(v2 + 8) = p_inClumpLink;
      p_inClumpLink[-1].prev = (RwLLLink *)v2;
      if ( v9 >= buffer )
        goto LABEL_40;
    }
    if ( !v34.numGeoms )
      goto LABEL_78;
    if ( v34.numGeoms >= 1 )
    {
      v27 = 0;
      do
        RpGeometryDestroy(v34.geometries[v27++]);
      while ( v27 < v34.numGeoms );
    }
LABEL_77:
    (*((void (__fastcall **)(RpGeometry_0 **))RwEngineInstance + 76))(v34.geometries);
    goto LABEL_78;
  }
LABEL_40:
  if ( v37 >= 1 )
  {
    v12 = 0;
    while ( RwStreamFindChunk(stream, 1u, 0, 0) )
    {
      Int32 = RwStreamReadInt32(stream, mem, 4u);
      if ( Int32 )
        Int32 = (RwStream_0 *)RwStreamFindChunk(stream, 0x12u, 0, 0);
      if ( !Int32 )
        break;
      v14 = RpLightStreamRead(stream);
      v15 = v14;
      if ( !v14 )
        break;
      _rwObjectHasFrameSetFrame(v14, frameList.frames[mem[0]]);
      v16 = _rpClumpLightExtOffset;
      ++v12;
      v17 = *(_DWORD *)(v2 + 16);
      v18 = &v15->object.object.type + _rpClumpLightExtOffset;
      *((_DWORD *)v18 + 2) = v32;
      *((_DWORD *)v18 + 1) = v17;
      v18 += 4;
      *(_DWORD *)(*(_DWORD *)(v2 + 16) + 4) = v18;
      *(_DWORD *)(v2 + 16) = v18;
      *(_DWORD *)(&v15->object.object.type + v16) = v2;
      if ( v12 >= v37 )
        goto LABEL_48;
    }
    if ( !v34.numGeoms )
      goto LABEL_78;
    if ( v34.numGeoms >= 1 )
    {
      v28 = 0;
      do
        RpGeometryDestroy(v34.geometries[v28++]);
      while ( v28 < v34.numGeoms );
    }
    goto LABEL_77;
  }
LABEL_48:
  if ( v38 >= 1 )
  {
    v19 = 0;
    while ( RwStreamFindChunk(stream, 1u, 0, 0) )
    {
      Chunk = RwStreamReadInt32(stream, mem, 4u);
      if ( Chunk )
        Chunk = (RwStream_0 *)RwStreamFindChunk(stream, 5u, 0, 0);
      if ( !Chunk )
        break;
      v21 = RwCameraStreamRead(stream);
      v22 = v21;
      if ( !v21 )
        break;
      _rwObjectHasFrameSetFrame(v21, frameList.frames[mem[0]]);
      v23 = _rpClumpCameraExtOffset;
      ++v19;
      v24 = *(_DWORD *)(v2 + 24);
      v25 = &v22->object.object.type + _rpClumpCameraExtOffset;
      *((_DWORD *)v25 + 2) = v31;
      *((_DWORD *)v25 + 1) = v24;
      v25 += 4;
      *(_DWORD *)(*(_DWORD *)(v2 + 24) + 4) = v25;
      *(_DWORD *)(v2 + 24) = v25;
      *(_DWORD *)(&v22->object.object.type + v23) = v2;
      if ( v19 >= v38 )
        goto LABEL_56;
    }
    if ( !v34.numGeoms )
      goto LABEL_78;
    if ( v34.numGeoms >= 1 )
    {
      v29 = 0;
      do
        RpGeometryDestroy(v34.geometries[v29++]);
      while ( v29 < v34.numGeoms );
    }
    goto LABEL_77;
  }
LABEL_56:
  if ( v34.numGeoms )
  {
    if ( v34.numGeoms >= 1 )
    {
      v26 = 0;
      do
        RpGeometryDestroy(v34.geometries[v26++]);
      while ( v26 < v34.numGeoms );
    }
    (*((void (__fastcall **)(RpGeometry_0 **))RwEngineInstance + 76))(v34.geometries);
  }
  _rwFrameListDeinitialize(&frameList);
  if ( !_rwPluginRegistryReadDataChunks(&clumpTKList, stream, (void *)v2) )
    goto LABEL_79;
  return (RpClump_0 *)v2;
}
// 6BD598: using guessed type int clumpModule;

//----- (00215598) --------------------------------------------------------
RpClumpChunkInfo_0 *__fastcall _rpClumpChunkInfoRead(
        RwStream_0 *stream,
        RpClumpChunkInfo_0 *clumpChunkInfo,
        RwInt32 *bytesRead)
{
  RwUInt32 v6; // r5
  RwUInt32 v8; // [sp+0h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &v8) )
    return 0;
  if ( v8 > 0x33000 )
  {
    v6 = 12;
  }
  else
  {
    v6 = 4;
    clumpChunkInfo->numLights = 0;
    clumpChunkInfo->numCameras = 0;
  }
  if ( RwStreamRead(stream, clumpChunkInfo, v6) != v6 )
    return 0;
  RwMemNative32(clumpChunkInfo, v6);
  *bytesRead = lengthOut[0] + 12;
  return clumpChunkInfo;
}
// 215598: using guessed type RwUInt32 lengthOut[5];

//----- (002155F4) --------------------------------------------------------
RwInt32 __fastcall RpAtomicRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&atomicTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (0021561C) --------------------------------------------------------
RwInt32 __fastcall RpClumpRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&clumpTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (00215644) --------------------------------------------------------
RwInt32 __fastcall RpAtomicRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&atomicTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (00215664) --------------------------------------------------------
RwInt32 __fastcall RpAtomicSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&atomicTKList, pluginID, alwaysCB);
}

//----- (00215674) --------------------------------------------------------
RwInt32 __fastcall RpAtomicSetStreamRightsCallBack(RwUInt32 pluginID, RwPluginDataChunkRightsCallBack rightsCB)
{
  return sub_19E33C(&atomicTKList, pluginID, rightsCB);
}

//----- (00215684) --------------------------------------------------------
RwInt32 __fastcall RpClumpRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&clumpTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (002156A4) --------------------------------------------------------
RwInt32 __fastcall RpClumpSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&clumpTKList, pluginID, alwaysCB);
}

//----- (002156B4) --------------------------------------------------------
RwInt32 __fastcall RpAtomicGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&atomicTKList, pluginID);
}

//----- (002156C4) --------------------------------------------------------
RwInt32 __fastcall RpClumpGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&clumpTKList, pluginID);
}

//----- (002156D4) --------------------------------------------------------
RwBool __fastcall RpAtomicValidatePlugins(const RpAtomic_0 *atomic)
{
  return 1;
}

//----- (002156D8) --------------------------------------------------------
RwBool __fastcall RpClumpValidatePlugins(const RpClump_0 *clump)
{
  return 1;
}

//----- (002156DC) --------------------------------------------------------
RwBool __fastcall RpAtomicInstance(RpAtomic_0 *atomic)
{
  RpGeometry_0 *geometry; // r5
  RwBool result; // r0
  RwUInt32 flags; // r1
  RwResEntry_0 *repEntry; // r0

  geometry = atomic->geometry;
  if ( geometry->numMorphTargets != 1 )
    return 0;
  flags = geometry->flags;
  if ( (flags & 0x1000000) != 0 )
    return 1;
  repEntry = geometry->repEntry;
  if ( repEntry )
  {
    RwResourcesFreeResEntry(repEntry);
    flags = geometry->flags;
  }
  geometry->flags = flags | 0x2000000;
  atomic->renderCallBack(atomic);
  result = 1;
  geometry->flags = geometry->flags & 0xFCFFFFFF | 0x1000000;
  return result;
}

//----- (0021571C) --------------------------------------------------------
void *__fastcall _rpGeometryOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  ++geometryModule;
  return instance;
}
// 6BD5A0: using guessed type int geometryModule;

//----- (0021572C) --------------------------------------------------------
void *__fastcall _rpGeometryClose(void *instance, RwInt32 offset, RwInt32 size)
{
  --geometryModule;
  return instance;
}
// 6BD5A0: using guessed type int geometryModule;

//----- (0021573C) --------------------------------------------------------
RwPluginRegEntry_0 *_rpGeometryGetTKListFirstRegEntry()
{
  return geometryTKList.firstRegEntry;
}

//----- (00215748) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryTransform(RpGeometry_0 *geometry, const RwMatrix *matrix)
{
  RpGeometry_0 *v2; // r9
  RwInt32 v4; // r4
  const RpMorphTarget_0 *v5; // r10
  RwV3d_0 *normals; // r5
  RwInt32 i; // r6

  v2 = geometry;
  geometry->lockedSinceLastInst |= 6u;
  if ( !geometry )
    return 0;
  if ( geometry->numMorphTargets >= 1 )
  {
    v4 = 0;
    do
    {
      v5 = &v2->morphTarget[v4];
      normals = v5->normals;
      RwV3dTransformPoints(v5->verts, v5->verts, v2->numVertices, matrix);
      if ( normals )
      {
        RwV3dTransformVectors(normals, normals, v2->numVertices, matrix);
        for ( i = v2->numVertices; i; --i )
        {
          _rwV3dNormalize(normals, normals);
          ++normals;
        }
      }
      RpMorphTargetCalcBoundingSphere(v5, &v5->boundingSphere);
      ++v4;
    }
    while ( v4 < v2->numMorphTargets );
  }
  if ( !RpGeometryUnlock(v2) )
  {
    RpGeometryDestroy(v2);
    return 0;
  }
  return v2;
}

//----- (002157DE) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryLock(RpGeometry_0 *geometry, RwInt32 lockMode)
{
  bool v3; // zf
  RpMeshHeader_0 *mesh; // r0

  v3 = (lockMode & 1) == 0;
  mesh = (RpMeshHeader_0 *)(geometry->lockedSinceLastInst | lockMode);
  geometry->lockedSinceLastInst = (unsigned __int16)mesh;
  if ( (lockMode & 1) != 0 )
  {
    mesh = geometry->mesh;
    v3 = mesh == 0;
  }
  if ( !v3 )
  {
    _rpMeshDestroy(mesh);
    geometry->mesh = 0;
  }
  return geometry;
}

//----- (00215808) --------------------------------------------------------
const RpMorphTarget_0 *__fastcall RpMorphTargetCalcBoundingSphere(
        const RpMorphTarget_0 *morphTarget,
        RwSphere_0 *boundingSphere)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  RwInt32 numVertices; // r6
  float32x2_t v7; // d8
  float v8; // s18
  RwV3d_0 *verts; // r0
  float32x2_t v10; // d16
  float32x2_t v11; // d16
  unsigned __int64 v12; // d2
  const RpMorphTarget_0 *result; // r0
  RwBBox_0 v14; // [sp+0h] [bp-38h] BYREF

  numVertices = morphTarget->parentGeom->numVertices;
  RwBBoxCalculate(&v14, morphTarget->verts, numVertices);
  v7.n64_u64[0] = vmul_f32(
                    vadd_f32(*(float32x2_t *)&v14.inf.y, *(float32x2_t *)&v14.sup.y),
                    (float32x2_t)0x3F0000003F000000LL).n64_u64[0];
  v8 = (float)(v14.inf.x + v14.sup.x) * 0.5;
  v2.n64_u32[0] = 0;
  if ( numVertices )
  {
    verts = morphTarget->verts;
    do
    {
      v3.n64_u32[0] = LODWORD(verts->x);
      --numVertices;
      v10.n64_u64[0] = *(unsigned __int64 *)&verts->y;
      ++verts;
      v11.n64_u64[0] = vsub_f32(v10, v7).n64_u64[0];
      v12 = vmul_f32(v11, v11).n64_u64[0];
      v3.n64_f32[0] = (float)((float)((float)(v3.n64_f32[0] - v8) * (float)(v3.n64_f32[0] - v8)) + *(float *)&v12)
                    + *((float *)&v12 + 1);
      v2.n64_u64[0] = vmax_f32(v3, v2).n64_u64[0];
    }
    while ( numVertices );
    if ( v2.n64_f32[0] > 0.0 )
      v2.n64_u32[0] = _rwSqrt(v2.n64_f32[0]);
  }
  LODWORD(boundingSphere->center.y) = v7.n64_u32[0];
  boundingSphere->center.x = v8;
  LODWORD(boundingSphere->center.z) = v7.n64_u32[1];
  result = morphTarget;
  boundingSphere->radius = v2.n64_f32[0] * 1.001;
  return result;
}
// 215880: variable 'v3' is possibly undefined
// 215880: variable 'v2' is possibly undefined

//----- (002158D0) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryUnlock(RpGeometry_0 *geometry)
{
  RpGeometry_0 *v1; // r10
  RpBuildMesh_0 *v2; // r9
  RwInt32 v3; // r6
  RpTriangle_0 *triangles; // r4
  RpTriangle_0 *v5; // r5
  RwInt32 matIndex; // r1
  RpMaterial_0 *Material; // r1
  RpMeshHeader_0 *v8; // r0

  v1 = geometry;
  if ( !geometry->mesh )
  {
    v2 = _rpBuildMeshCreate(geometry->numTriangles);
    if ( v2 )
    {
      if ( v1->numTriangles >= 1 )
      {
        v3 = 0;
        do
        {
          triangles = v1->triangles;
          v5 = &triangles[v3];
          matIndex = v5->matIndex;
          if ( matIndex == -1 )
            Material = 0;
          else
            Material = _rpMaterialListGetMaterial(&v1->matList, matIndex);
          _rpBuildMeshAddTriangle(v2, Material, triangles[v3++].vertIndex[0], v5->vertIndex[1], v5->vertIndex[2]);
        }
        while ( v3 < v1->numTriangles );
      }
      v8 = _rpMeshOptimise(v2, v1->flags & 1);
      if ( v8 )
      {
        v1->mesh = v8;
        return v1;
      }
      _rpBuildMeshDestroy(v2);
    }
    return 0;
  }
  return v1;
}

//----- (00215960) --------------------------------------------------------
RwBool __fastcall RpGeometryDestroy(RpGeometry_0 *geometry)
{
  RwInt16 v2; // r0
  RwInt16 refCount; // r1
  RwResEntry_0 *repEntry; // r0
  RpMeshHeader_0 *mesh; // r0
  u_native vertexBuffer; // r0

  v2 = geometry->refCount - 1;
  geometry->refCount = v2;
  refCount = v2;
  if ( v2 > 0 )
    return 1;
  repEntry = geometry->repEntry;
  if ( repEntry )
  {
    RwResourcesFreeResEntry(repEntry);
    refCount = geometry->refCount;
  }
  geometry->refCount = refCount + 1;
  mesh = geometry->mesh;
  geometry->lockedSinceLastInst |= 0xFFFu;
  if ( mesh )
  {
    _rpMeshDestroy(mesh);
    geometry->mesh = 0;
  }
  _rwPluginRegistryDeInitObject(&geometryTKList, geometry);
  if ( geometry->morphTarget )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    geometry->morphTarget = 0;
  }
  _rpMaterialListDeinitialize(&geometry->matList);
  vertexBuffer = geometry->vertexBuffer;
  if ( vertexBuffer )
  {
    emu_ArraysDelete(vertexBuffer);
    geometry->vertexBuffer = 0;
  }
  --geometry->refCount;
  (*((void (__fastcall **)(RpGeometry_0 *))RwEngineInstance + 76))(geometry);
  return 1;
}

//----- (002159F8) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryCreateSpace(RwReal radius)
{
  RpGeometry_0 *v2; // r0
  RpGeometry_0 *v3; // r4
  RpMorphTarget_0 *morphTarget; // r0

  v2 = RpGeometryCreate(0, 0, 0);
  v3 = v2;
  if ( v2 )
  {
    morphTarget = v2->morphTarget;
    morphTarget->boundingSphere.center.x = 0.0;
    morphTarget->boundingSphere.center.y = 0.0;
    morphTarget->boundingSphere.center.z = 0.0;
    morphTarget->boundingSphere.radius = radius;
  }
  if ( !RpGeometryUnlock(v3) )
  {
    RpGeometryDestroy(v3);
    return 0;
  }
  return v3;
}

//----- (00215A40) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryCreate(RwInt32 numVerts, RwInt32 numTriangles, RwUInt32 format)
{
  RwInt32 sizeOfStruct; // r0
  RwUInt32 v7; // r6
  RpGeometry_0 *v8; // r4
  int v9; // r8
  int v10; // r0
  RpGeometry_0 *v11; // r5
  RpTriangle_0 **p_triangles; // r0
  RwRGBA_0 *v13; // r3
  bool v14; // zf
  RwTexCoords_0 **texCoords; // r2
  int v16; // r12
  RwTexCoords_0 *v17; // r1
  int v18; // r3
  int v19; // r6
  RpMaterialList_0 *matList; // [sp+4h] [bp-2Ch]
  RwError_0 code; // [sp+Ch] [bp-24h] BYREF

  if ( HIWORD(numVerts) || numTriangles <= -1 )
  {
    v8 = 0;
    if ( numVerts >= 0x10000 )
    {
      code.pluginID = 0;
      code.errorCode = _rwerror(6);
      RwErrorSet(&code);
    }
  }
  else
  {
    sizeOfStruct = geometryTKList.sizeOfStruct;
    if ( (format & 0xFF0000) != 0 )
    {
      v7 = (format & 0xFF0000) >> 16;
    }
    else if ( (format & 0x80) != 0 )
    {
      v7 = 2;
    }
    else
    {
      v7 = (format >> 2) & 1;
    }
    v9 = v7;
    if ( v7 )
      v9 = 128;
    if ( v7 == 1 )
      v9 = 4;
    if ( (format & 0x1000000) == 0 )
    {
      if ( (format & 8) != 0 )
        sizeOfStruct = geometryTKList.sizeOfStruct + 4 * numVerts;
      if ( v7 )
        sizeOfStruct += 8 * numVerts * v7;
      sizeOfStruct += 8 * numTriangles;
    }
    v10 = (*((int (__fastcall **)(RwInt32))RwEngineInstance + 75))(sizeOfStruct);
    v11 = (RpGeometry_0 *)v10;
    if ( !v10 )
      return 0;
    matList = (RpMaterialList_0 *)(v10 + 32);
    v8 = 0;
    if ( _rpMaterialListInitialize((RpMaterialList_0 *)(v10 + 32)) )
    {
      v11->numMorphTargets = 0;
      v11->object.type = 8;
      v11->lockedSinceLastInst = 0;
      HIBYTE(v11->object.parent) = 0;
      *(_WORD *)((char *)&v11->object.parent + 1) = 0;
      v11->numTexCoordSets = v7;
      *(_DWORD *)&v11->object.subType = 0;
      v11->refCount = 1;
      v11->texCoords[6] = 0;
      v11->texCoords[7] = 0;
      v11->vertexBuffer = 0;
      v11->mesh = 0;
      v11->repEntry = 0;
      v11->morphTarget = 0;
      v11->numTriangles = numTriangles;
      v11->numVertices = numVerts;
      v11->flags = format & 0xF000F7B | v9;
      *(_QWORD *)&v11->texCoords[2] = 0LL;
      *(_QWORD *)&v11->texCoords[4] = 0LL;
      p_triangles = &v11->triangles;
      *(_QWORD *)&v11->triangles = 0LL;
      *(_QWORD *)v11->texCoords = 0LL;
      if ( (format & 0x1000000) == 0 )
      {
        v13 = (RwRGBA_0 *)(&v11->object.type + geometryTKList.sizeOfStruct);
        if ( numVerts && (format & 8) != 0 )
        {
          v11->preLitLum = v13;
          v13 += numVerts;
        }
        v14 = numVerts == 0;
        if ( numVerts )
          v14 = v7 == 0;
        if ( !v14 )
        {
          texCoords = v11->texCoords;
          v16 = 8 * v7 * numVerts;
          v17 = (RwTexCoords_0 *)v13;
          do
          {
            *texCoords++ = v17;
            v17 += numVerts;
            --v7;
          }
          while ( v7 );
          v13 = (RwRGBA_0 *)((char *)v13 + v16);
        }
        if ( numTriangles )
        {
          *p_triangles = (RpTriangle_0 *)v13;
          if ( numTriangles >= 1 )
          {
            *(_WORD *)&v13[1]._anon_0.col[2] = -1;
            if ( numTriangles != 1 )
            {
              v18 = 0;
              do
              {
                v19 = (int)&(*p_triangles)[v18++];
                *(_WORD *)(v19 + 14) = -1;
              }
              while ( numTriangles - 1 != v18 );
            }
          }
        }
      }
      if ( RpGeometryAddMorphTargets(v11, 1) > -1 )
      {
        _rwPluginRegistryInitObject(&geometryTKList, v11);
        return v11;
      }
      _rpMaterialListDeinitialize(matList);
      (*((void (__fastcall **)(RpGeometry_0 *))RwEngineInstance + 76))(v11);
      return 0;
    }
  }
  return v8;
}

//----- (00215C08) --------------------------------------------------------
RwInt32 __fastcall RpGeometryAddMorphTargets(RpGeometry_0 *geometry, RwInt32 mtcount)
{
  RwUInt32 flags; // r0
  int v5; // r2
  int v6; // r4
  RpMorphTarget_0 *morphTarget; // r0
  int v8; // r2
  int v9; // r6
  RpMorphTarget_0 *v10; // r0
  RwInt32 numMorphTargets; // r2
  _BYTE *v12; // r1
  int v13; // r2
  RwInt32 v14; // r1
  RwInt32 v15; // r4
  int v16; // r2
  int v17; // r6
  RpMorphTarget_0 *v18; // r1
  RpMorphTarget_0 *v19; // r0
  RwInt32 v20; // r0
  int v21; // r1
  char *v22; // r2
  RwError_0 v24; // [sp+0h] [bp-20h] BYREF

  flags = geometry->flags;
  if ( (flags & 0x1000000) != 0 )
  {
    v6 = 28;
  }
  else
  {
    v5 = 24 * geometry->numVertices;
    if ( (flags & 0x10) == 0 )
      v5 = 12 * geometry->numVertices;
    v6 = v5 + 28;
  }
  morphTarget = geometry->morphTarget;
  v8 = geometry->numMorphTargets + mtcount;
  v9 = v8 * v6;
  if ( morphTarget )
  {
    v10 = (RpMorphTarget_0 *)(*((int (__fastcall **)(RpMorphTarget_0 *, int))RwEngineInstance + 77))(morphTarget, v9);
    if ( v10 )
    {
      numMorphTargets = geometry->numMorphTargets;
      if ( numMorphTargets * v6 != 28 * numMorphTargets )
      {
        v12 = (char *)v10 + numMorphTargets * v6 - 1;
        v13 = -(numMorphTargets * (v6 - 28));
        do
        {
          ++v13;
          v12[28 * mtcount] = *v12;
          --v12;
        }
        while ( v13 );
      }
      goto LABEL_13;
    }
LABEL_25:
    v24.pluginID = 0;
    v24.errorCode = _rwerror(-2147483629, v9);
    RwErrorSet(&v24);
    return -1;
  }
  v10 = (RpMorphTarget_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v8 * v6);
  if ( !v10 )
    goto LABEL_25;
LABEL_13:
  v14 = geometry->numMorphTargets;
  geometry->morphTarget = v10;
  v15 = v14 + mtcount;
  geometry->numMorphTargets = v14 + mtcount;
  if ( v14 + mtcount >= 1 )
  {
    v16 = 1;
    v17 = 0;
    v18 = &v10[v15];
    while ( 1 )
    {
      v19 = &v10[v17];
      v19->verts = 0;
      v19->normals = 0;
      if ( !(HIBYTE(geometry->flags) << 31) )
      {
        if ( geometry->numVertices )
        {
          v19->verts = (RwV3d_0 *)v18;
          v18 = (RpMorphTarget_0 *)((char *)v18 + 12 * geometry->numVertices);
          if ( (geometry->flags & 0x10) != 0 )
          {
            v19->normals = (RwV3d_0 *)v18;
            v18 = (RpMorphTarget_0 *)((char *)v18 + 12 * geometry->numVertices);
          }
        }
      }
      v15 = geometry->numMorphTargets;
      if ( v16 >= v15 )
        break;
      ++v17;
      v10 = geometry->morphTarget;
      ++v16;
    }
  }
  if ( mtcount >= 1 )
  {
    v20 = v15 - mtcount;
    v21 = 28 * v15 - 28 * mtcount;
    do
    {
      ++v20;
      v22 = (char *)geometry->morphTarget + v21;
      v21 += 28;
      *(_DWORD *)v22 = geometry;
      v22 += 4;
      *(_QWORD *)v22 = 0LL;
      *((_QWORD *)v22 + 1) = 0LL;
      v15 = geometry->numMorphTargets;
    }
    while ( v20 < v15 );
  }
  return v15 - mtcount;
}

//----- (00215D58) --------------------------------------------------------
RwInt32 __fastcall RpGeometryAddMorphTarget(RpGeometry_0 *geometry)
{
  return RpGeometryAddMorphTargets(geometry, 1);
}

//----- (00215D5C) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryRemoveMorphTarget(RpGeometry_0 *geometry, RwInt32 morphTargetIndex)
{
  RpGeometry_0 *v2; // r4
  __int64 v4; // r2
  int v5; // r6
  int v6; // r10
  int v7; // r5
  int morphTarget; // r9
  int numMorphTargets; // r0
  int v10; // r1
  int v11; // r3
  int v12; // r5
  int v13; // r2
  int v14; // r6
  RpMorphTarget_0 *v15; // r0
  __int64 v16; // d16
  __int64 v17; // d17
  __int64 v18; // d18
  __int64 v19; // d19
  _QWORD *v20; // r0
  size_t v21; // r11
  int v22; // r6
  RpMorphTarget_0 *v23; // r5
  char *v24; // r10
  int v25; // r1
  int v26; // r0
  int v27; // r1
  int v28; // r3
  int v29; // r0
  int v30; // r6
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  v2 = geometry;
  v4 = *(_QWORD *)&geometry->numVertices;
  v5 = 3 * v4;
  v6 = ((int)(geometry->flags << 27) >> 31) & (12 * v4);
  v7 = (v6 + 12 * v4 + 28) * (HIDWORD(v4) - 1);
  morphTarget = (*((int (__fastcall **)(int))RwEngineInstance + 75))(v7);
  if ( morphTarget )
  {
    numMorphTargets = v2->numMorphTargets;
    if ( numMorphTargets >= 1 )
    {
      v10 = 4 * v5;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      do
      {
        if ( morphTargetIndex != v12 )
        {
          v14 = 7 * v13++;
          v15 = &v2->morphTarget[v11];
          v16 = *(_QWORD *)&v15->parentGeom;
          v17 = *(_QWORD *)&v15->boundingSphere.center.y;
          v15 = (RpMorphTarget_0 *)((char *)v15 + 12);
          v18 = *(_QWORD *)&v15->parentGeom;
          v19 = *(_QWORD *)&v15->boundingSphere.center.y;
          v20 = (_QWORD *)(morphTarget + 4 * v14);
          *v20 = v16;
          v20[1] = v17;
          v20 = (_QWORD *)((char *)v20 + 12);
          *v20 = v18;
          v20[1] = v19;
          numMorphTargets = v2->numMorphTargets;
        }
        ++v12;
        ++v11;
      }
      while ( v12 < numMorphTargets );
      if ( numMorphTargets >= 1 )
      {
        v21 = v6 + v10;
        v22 = 0;
        v23 = &v2->morphTarget[numMorphTargets];
        v24 = (char *)(morphTarget + 28 * v13);
        do
        {
          if ( morphTargetIndex != v22 )
          {
            qmemcpy(v24, v23, v21);
            numMorphTargets = v2->numMorphTargets;
            v24 += v21;
          }
          ++v22;
          v23 = (RpMorphTarget_0 *)((char *)v23 + v21);
        }
        while ( v22 < numMorphTargets );
      }
    }
    (*((void (__fastcall **)(RpMorphTarget_0 *))RwEngineInstance + 76))(v2->morphTarget);
    v25 = v2->numMorphTargets;
    v2->morphTarget = (RpMorphTarget_0 *)morphTarget;
    v26 = v25 - 1;
    v2->numMorphTargets = v25 - 1;
    if ( v25 >= 2 )
    {
      v27 = 1;
      v28 = 0;
      v29 = morphTarget + 28 * v26;
      while ( 1 )
      {
        v30 = morphTarget + v28;
        *(_DWORD *)(v30 + 20) = 0;
        *(_DWORD *)(v30 + 24) = 0;
        if ( v2->numVertices )
        {
          *(_DWORD *)(v30 + 20) = v29;
          v29 += 12 * v2->numVertices;
          if ( (v2->flags & 0x10) != 0 )
          {
            *(_DWORD *)(v30 + 24) = v29;
            v29 += 12 * v2->numVertices;
          }
        }
        if ( v27 >= v2->numMorphTargets )
          break;
        v28 += 28;
        morphTarget = (int)v2->morphTarget;
        ++v27;
      }
    }
  }
  else
  {
    v2 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483629, v7);
    RwErrorSet(&code);
  }
  return v2;
}

//----- (00215EA8) --------------------------------------------------------
void __fastcall RpGeometryTriangleSetVertexIndices(
        const RpGeometry_0 *geometry,
        RpTriangle_0 *triangle,
        RwUInt16 vert1,
        RwUInt16 vert2,
        RwUInt16 vert3)
{
  triangle->vertIndex[1] = vert2;
  triangle->vertIndex[0] = vert1;
  triangle->vertIndex[2] = vert3;
}

//----- (00215EB6) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryTriangleSetMaterial(
        RpGeometry_0 *geometry,
        RpTriangle_0 *triangle,
        RpMaterial_0 *material)
{
  RpGeometry_0 *v5; // r4
  RwInt32 MaterialIndex; // r0

  v5 = geometry;
  if ( !material )
  {
    LOWORD(MaterialIndex) = -1;
LABEL_6:
    triangle->matIndex = MaterialIndex;
    return v5;
  }
  MaterialIndex = _rpMaterialListFindMaterialIndex(&geometry->matList, material);
  if ( MaterialIndex > -1 )
    goto LABEL_6;
  MaterialIndex = _rpMaterialListAppendMaterial(&v5->matList, material);
  if ( MaterialIndex >= 0 )
    goto LABEL_6;
  return 0;
}

//----- (00215EF8) --------------------------------------------------------
void __fastcall RpGeometryTriangleGetVertexIndices(
        const RpGeometry_0 *geometry,
        const RpTriangle_0 *triangle,
        RwUInt16 *vert1,
        RwUInt16 *vert2,
        _WORD *a5)
{
  if ( vert1 )
    *vert1 = triangle->vertIndex[0];
  if ( vert2 )
    *vert2 = triangle->vertIndex[1];
  if ( a5 )
    *a5 = triangle->vertIndex[2];
}

//----- (00215F1E) --------------------------------------------------------
RpMaterial_0 *__fastcall RpGeometryTriangleGetMaterial(const RpGeometry_0 *geometry, const RpTriangle_0 *triangle)
{
  int matIndex; // r1

  matIndex = triangle->matIndex;
  if ( matIndex == -1 )
    return 0;
  else
    return *(RpMaterial_0 **)(*(int *)((char *)&dword_20 + (_DWORD)geometry) + 4 * matIndex);
}
// 20: using guessed type int dword_20;

//----- (00215F30) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryForAllMaterials(RpGeometry_0 *geometry, RpMaterialCallBack fpCallBack, void *pData)
{
  RwInt32 numMaterials; // r4
  RwInt32 i; // r6

  numMaterials = geometry->matList.numMaterials;
  if ( numMaterials >= 1 )
  {
    for ( i = 0; i < numMaterials; ++i )
    {
      if ( !(int)fpCallBack(geometry->matList.materials[i], pData) )
        break;
    }
  }
  return geometry;
}

//----- (00215F60) --------------------------------------------------------
const RpGeometry_0 *__fastcall RpGeometryForAllMeshes(
        const RpGeometry_0 *geometry,
        RpMeshCallBack fpCallBack,
        void *pData)
{
  const RpGeometry_0 *v3; // r4
  RpMeshHeader_0 *mesh; // r0

  v3 = geometry;
  mesh = geometry->mesh;
  if ( !mesh )
    return 0;
  if ( !_rpMeshHeaderForAllMeshes(mesh, fpCallBack, pData) )
    return 0;
  return v3;
}

//----- (00215F7E) --------------------------------------------------------
RpGeometry_0 *__fastcall _rpGeometryAddRef(RpGeometry_0 *geometry)
{
  ++geometry->refCount;
  return geometry;
}

//----- (00215F88) --------------------------------------------------------
RwInt32 __fastcall RpGeometryRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&geometryTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (00215FB0) --------------------------------------------------------
RwInt32 __fastcall RpGeometryRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&geometryTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (00215FD0) --------------------------------------------------------
RwInt32 __fastcall RpGeometrySetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&geometryTKList, pluginID, alwaysCB);
}

//----- (00215FE0) --------------------------------------------------------
RwInt32 __fastcall RpGeometryGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&geometryTKList, pluginID);
}

//----- (00215FF0) --------------------------------------------------------
RwBool __fastcall RpGeometryValidatePlugins(const RpGeometry_0 *geometry)
{
  return 1;
}

//----- (00215FF4) --------------------------------------------------------
RwUInt32 __fastcall RpGeometryStreamGetSize(const RpGeometry_0 *geometry)
{
  RwUInt32 flags; // r1
  RwInt32 numVertices; // r0
  unsigned __int32 v4; // r6
  int v5; // r3
  RwInt32 numMorphTargets; // r1
  RpMorphTarget_0 *morphTarget; // lr
  unsigned int v8; // r0
  int v9; // r3
  int v10; // r3
  int v12; // r12
  int32x4_t v13; // q10
  int64x2_t v14; // q9
  RwV3d_0 **p_verts; // r5
  int8x16_t v16; // q8
  int v17; // r3
  int32x4_t *v18; // r6
  int8x16_t v19; // q12
  int32x4_t v20; // q13
  unsigned __int64 *v21; // r2
  int8x16_t v22; // q11
  int32x4_t v27; // q8
  int v28; // r1
  RwV3d_0 **p_normals; // r2
  int v30; // r3
  RwV3d_0 *v31; // r5
  RwUInt32 Size; // r5
  int32x4x2_t v34; // 0:q0.16,16:q15.16
  int32x4x2_t v35; // 0:q12.16,16:q1.16

  flags = geometry->flags;
  if ( (flags & 0x1000000) != 0 )
  {
    v4 = 40;
  }
  else
  {
    numVertices = geometry->numVertices;
    v4 = 16;
    if ( numVertices )
    {
      v5 = 4 * numVertices + 16;
      if ( (flags & 8) == 0 )
        v5 = 16;
      v4 = v5 + 8 * (geometry->numTriangles + geometry->numTexCoordSets * numVertices);
    }
    numMorphTargets = geometry->numMorphTargets;
    if ( numMorphTargets >= 1 )
    {
      morphTarget = geometry->morphTarget;
      v8 = 12 * numVertices;
      if ( (unsigned int)numMorphTargets >= 4 )
      {
        v10 = geometry->numMorphTargets & 3;
        if ( (numMorphTargets & 3) == 0 )
          v10 = 4;
        v12 = numMorphTargets - v10;
        _ZF = numMorphTargets == v10;
        v9 = 0;
        if ( !_ZF )
        {
          v16 = vdupq_n_s32(0);
          v13.n128_u64[0] = 0x1800000018LL;
          v13.n128_u64[1] = 0x1800000018LL;
          v14 = vdupq_n_s32(v8);
          p_verts = &morphTarget->verts;
          v16.n128_u32[0] = v4;
          v17 = v12;
          do
          {
            v18 = (int32x4_t *)p_verts;
            v19 = (int8x16_t)*((_OWORD *)p_verts + 5);
            v17 -= 4;
            v20 = (int32x4_t)*((_OWORD *)p_verts + 3);
            v21 = (unsigned __int64 *)(p_verts + 8);
            p_verts += 28;
            v34 = vzipq_s32(v20, vextq_s8(v20, v19, 0xCu));
            v34.val[0].n128_u64[0] = *v21;
            v34.val[0].n128_u64[1] = v21[1];
            v35 = vzipq_s32(v19, v20);
            v35.val[0] = vextq_s8(vextq_s8(v20, v34.val[1], 8u), vrev64q_s32(vextq_s8(v18[1], *v18, 0xCu)), 8u);
            v22 = vextq_s8(
                    vextq_s8(v20, v35.val[1], 4u),
                    vextq_s8((int8x16_t)vzipq_s32(*v18, *v18), v34.val[0], 0xCu),
                    8u);
            v35.val[0] = vextq_s8(v35.val[0], v35.val[0], 8u);
            _Q11 = vextq_s8(v22, v22, 8u);
            __asm
            {
              VCEQ.I32        Q12, Q12, #0
              VCEQ.I32        Q11, Q11, #0
            }
            v16 = vaddq_s32(vaddq_s32(vaddq_s32(v16, vbicq_s64(v14, v35.val[0])), vbicq_s64(v14, _Q11)), v13);
          }
          while ( !_ZF );
          v9 = v12;
          v27 = vaddq_s32(v16, vextq_s8(v16, v16, 8u));
          v4 = vaddq_s32(v27, vdupq_lane_s32((int32x2_t)v27.n128_u64[0], 1)).n128_u32[0];
        }
      }
      else
      {
        v9 = 0;
      }
      v28 = numMorphTargets - v9;
      p_normals = &morphTarget[v9].normals;
      do
      {
        v30 = (int)*(p_normals - 1);
        v31 = *p_normals;
        p_normals += 7;
        if ( v30 )
          v4 += v8;
        v4 += 24;
        if ( v31 )
          v4 += v8;
        --v28;
      }
      while ( v28 );
    }
  }
  Size = _rpMaterialListStreamGetSize(&geometry->matList);
  return _rwPluginRegistryGetSize(&geometryTKList, geometry) + v4 + Size + 36;
}

//----- (00216154) --------------------------------------------------------
const RpGeometry_0 *__fastcall RpGeometryStreamWrite(const RpGeometry_0 *geometry, RwStream_0 *stream)
{
  RwInt32 Size; // r0
  RwUInt32 flags; // r1
  RwInt32 numVertices; // r0
  RwInt32 v7; // r2
  int v8; // r2
  RwInt32 numMorphTargets; // r1
  RpMorphTarget_0 *morphTarget; // lr
  unsigned int v11; // r0
  int v12; // r5
  int v13; // r5
  int v15; // r12
  int32x4_t v16; // q10
  int64x2_t v17; // q9
  RwV3d_0 **p_verts; // r3
  int8x16_t v19; // q8
  int v20; // r5
  int8x16_t v21; // q12
  int32x4_t v22; // q13
  int8x16_t v23; // q11
  int8x16_t v24; // q14
  unsigned __int64 *v25; // r2
  int8x16_t v26; // q11
  int32x4_t v31; // q8
  int v32; // r1
  RwV3d_0 **p_normals; // r3
  int v34; // r6
  RwV3d_0 *v35; // r5
  RwInt32 numTriangles; // r1
  RwInt32 v37; // r2
  RwInt32 v38; // r3
  RwUInt32 v41; // r1
  RwInt32 v42; // r0
  int v43; // r5
  RwUInt32 v44; // r6
  RwInt32 v45; // r5
  RpTriangle_0 *triangles; // r6
  int v47; // r5
  RwInt32 v48; // r6
  RpMorphTarget_0 *v49; // r0
  __int64 v50; // d17
  _BOOL4 v51; // r0
  const RpGeometry_0 *result; // r0
  _QWORD v53[2]; // [sp+8h] [bp-40h] BYREF
  _BOOL4 v54; // [sp+18h] [bp-30h]
  _BOOL4 v55; // [sp+1Ch] [bp-2Ch]
  _DWORD mem[10]; // [sp+20h] [bp-28h] BYREF
  int32x4x2_t v57; // 0:q0.16,16:q15.16
  int32x4x2_t v58; // 0:q12.16,16:q1.16

  Size = RpGeometryStreamGetSize(geometry);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 15, Size, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  flags = geometry->flags;
  if ( (flags & 0x1000000) != 0 )
  {
    v7 = 40;
  }
  else
  {
    numVertices = geometry->numVertices;
    v7 = 16;
    if ( numVertices )
    {
      v8 = 4 * numVertices + 16;
      if ( (flags & 8) == 0 )
        v8 = 16;
      v7 = v8 + 8 * (geometry->numTriangles + geometry->numTexCoordSets * numVertices);
    }
    numMorphTargets = geometry->numMorphTargets;
    if ( numMorphTargets >= 1 )
    {
      morphTarget = geometry->morphTarget;
      v11 = 12 * numVertices;
      if ( (unsigned int)numMorphTargets >= 4 )
      {
        v13 = geometry->numMorphTargets & 3;
        if ( (numMorphTargets & 3) == 0 )
          v13 = 4;
        v15 = numMorphTargets - v13;
        _ZF = numMorphTargets == v13;
        v12 = 0;
        if ( !_ZF )
        {
          v19 = vdupq_n_s32(0);
          v16.n128_u64[0] = 0x1800000018LL;
          v16.n128_u64[1] = 0x1800000018LL;
          v17 = vdupq_n_s32(v11);
          p_verts = &morphTarget->verts;
          v19.n128_u32[0] = v7;
          v20 = v15;
          do
          {
            v21 = (int8x16_t)*((_OWORD *)p_verts + 5);
            v20 -= 4;
            v22 = (int32x4_t)*((_OWORD *)p_verts + 3);
            v23 = *(int8x16_t *)p_verts;
            v24 = (int8x16_t)*((_OWORD *)p_verts + 1);
            v25 = (unsigned __int64 *)(p_verts + 8);
            p_verts += 28;
            v57 = vzipq_s32(v22, vextq_s8(v22, v21, 0xCu));
            v57.val[0].n128_u64[0] = *v25;
            v57.val[0].n128_u64[1] = v25[1];
            v58 = vzipq_s32(v21, v22);
            v58.val[0] = vextq_s8(vextq_s8(v22, v57.val[1], 8u), vrev64q_s32(vextq_s8(v24, v23, 0xCu)), 8u);
            v26 = vextq_s8(
                    vextq_s8(v22, v58.val[1], 4u),
                    vextq_s8((int8x16_t)vzipq_s32(v23, v23), v57.val[0], 0xCu),
                    8u);
            v58.val[0] = vextq_s8(v58.val[0], v58.val[0], 8u);
            _Q11 = vextq_s8(v26, v26, 8u);
            __asm
            {
              VCEQ.I32        Q12, Q12, #0
              VCEQ.I32        Q11, Q11, #0
            }
            v19 = vaddq_s32(vaddq_s32(vaddq_s32(v19, vbicq_s64(v17, v58.val[0])), vbicq_s64(v17, _Q11)), v16);
          }
          while ( !_ZF );
          v12 = v15;
          v31 = vaddq_s32(v19, vextq_s8(v19, v19, 8u));
          v7 = vaddq_s32(v31, vdupq_lane_s32((int32x2_t)v31.n128_u64[0], 1)).n128_u32[0];
        }
      }
      else
      {
        v12 = 0;
      }
      v32 = numMorphTargets - v12;
      p_normals = &morphTarget[v12].normals;
      do
      {
        v34 = (int)*(p_normals - 1);
        v35 = *p_normals;
        p_normals += 7;
        if ( v34 )
          v7 += v11;
        v7 += 24;
        if ( v35 )
          v7 += v11;
        --v32;
      }
      while ( v32 );
    }
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 1, v7, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  numTriangles = geometry->numTriangles;
  v37 = geometry->numVertices;
  v38 = geometry->numMorphTargets;
  _R6 = geometry->numTexCoordSets << 16;
  __asm { UXTB16.W        R6, R6 }
  mem[0] = geometry->flags | _R6;
  mem[1] = numTriangles;
  mem[2] = v37;
  mem[3] = v38;
  RwMemLittleEndian32(mem, 0x10u);
  if ( !RwStreamWrite(stream, mem, 0x10u) )
    return 0;
  v41 = geometry->flags;
  if ( (v41 & 0x1000000) == 0 )
  {
    v42 = geometry->numVertices;
    if ( v42 )
    {
      if ( (v41 & 8) != 0 && !RwStreamWrite(stream, geometry->preLitLum, 4 * v42) )
        return 0;
      if ( geometry->numTexCoordSets >= 1 )
      {
        v43 = 0;
        v44 = 8 * geometry->numVertices;
        while ( RwStreamWriteReal(stream, &geometry->texCoords[v43]->u, v44) )
        {
          if ( ++v43 >= geometry->numTexCoordSets )
            goto LABEL_34;
        }
        return 0;
      }
LABEL_34:
      v45 = geometry->numTriangles;
      if ( v45 )
      {
        triangles = geometry->triangles;
        while ( v45 )
        {
          LOWORD(v53[0]) = triangles->vertIndex[1];
          WORD1(v53[0]) = triangles->vertIndex[0];
          WORD2(v53[0]) = triangles->matIndex;
          HIWORD(v53[0]) = triangles->vertIndex[2];
          RwMemLittleEndian32(v53, 8u);
          ++triangles;
          --v45;
          if ( !RwStreamWrite(stream, v53, 8u) )
            return 0;
        }
      }
    }
  }
  if ( geometry->numMorphTargets >= 1 )
  {
    v47 = 0;
    v48 = 0;
    do
    {
      v49 = &geometry->morphTarget[v47];
      v50 = *(_QWORD *)&v49->boundingSphere.center.z;
      v53[0] = *(_QWORD *)&v49->boundingSphere.center.x;
      v53[1] = v50;
      if ( HIBYTE(geometry->flags) << 31 )
      {
        v51 = 0;
        v54 = 0;
      }
      else
      {
        v54 = v49->verts != 0;
        v51 = v49->normals != 0;
      }
      v55 = v51;
      RwMemRealToFloat32(v53, 0x10u);
      RwMemLittleEndian32(v53, 0x18u);
      if ( !RwStreamWrite(stream, v53, 0x18u)
        || v54 && !RwStreamWriteReal(stream, &geometry->morphTarget[v47].verts->x, 12 * geometry->numVertices) )
      {
        return 0;
      }
      if ( v55 && !RwStreamWriteReal(stream, &geometry->morphTarget[v47].normals->x, 12 * geometry->numVertices) )
        return 0;
      ++v48;
      ++v47;
    }
    while ( v48 < geometry->numMorphTargets );
  }
  if ( !_rpMaterialListStreamWrite(&geometry->matList, stream) )
    return 0;
  result = (const RpGeometry_0 *)_rwPluginRegistryWriteDataChunks(&geometryTKList, stream, geometry);
  if ( result )
    return geometry;
  return result;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 216154: using guessed type _DWORD mem[10];

//----- (00216448) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometryStreamRead(RwStream_0 *stream)
{
  RpGeometry_0 *v2; // r5
  RwUInt32 v3; // r4
  RwInt32 v4; // r0
  RwUInt32 v5; // r0
  RpGeometry_0 *v6; // r10
  RwInt32 numVertices; // r4
  int v8; // r4
  RwUInt32 v9; // r5
  RwInt32 numTriangles; // r6
  RpTriangle_0 *triangles; // r5
  RpTriangle_0 v12; // r0
  int v13; // r6
  RwInt32 v14; // r5
  RpMorphTarget_0 *morphTarget; // r4
  RpMorphTarget_0 *v16; // r8
  __int64 v17; // d17
  int p_boundingSphere; // r1
  RwReal *p_x; // r1
  RwUInt32 v20; // r2
  RwError_0 code; // [sp+8h] [bp-58h] BYREF
  __int64 v23; // [sp+10h] [bp-50h] BYREF
  int v24; // [sp+18h] [bp-48h]
  int v25; // [sp+1Ch] [bp-44h]
  RwUInt32 versionOut; // [sp+24h] [bp-3Ch] BYREF
  RwSurfaceProperties_0 mem; // [sp+28h] [bp-38h] BYREF
  RwUInt32 buffer[3]; // [sp+34h] [bp-2Ch] BYREF
  int v29; // [sp+40h] [bp-20h]

  v2 = 0;
  if ( RwStreamFindChunk(stream, 1u, 0, &versionOut) )
  {
    v3 = versionOut;
    if ( versionOut - 212992 >= 0x2004 )
    {
      v2 = 0;
      code.pluginID = 0;
      v4 = _rwerror(-2147483644);
LABEL_4:
      code.errorCode = v4;
      RwErrorSet(&code);
      return v2;
    }
    v5 = RwStreamRead(stream, buffer, 0x10u);
    if ( v3 > 0x34000 )
    {
      if ( v5 != 16 )
        return 0;
    }
    else
    {
      if ( v5 != 16 || RwStreamRead(stream, &mem, 0xCu) != 12 )
        return 0;
      RwMemNative32(&mem, 0xCu);
      RwMemRealToFloat32(&mem, 0xCu);
    }
    RwMemNative32(buffer, 0x10u);
    v6 = RpGeometryCreate(buffer[2], buffer[1], buffer[0]);
    if ( v6 )
    {
      if ( v29 >= 2 && RpGeometryAddMorphTargets(v6, v29 - 1) <= -1 )
        goto LABEL_48;
      if ( HIBYTE(v6->flags) << 31 )
        goto LABEL_26;
      numVertices = v6->numVertices;
      if ( !numVertices )
        goto LABEL_26;
      if ( (buffer[0] & 8) != 0 )
      {
        if ( RwStreamRead(stream, v6->preLitLum, 4 * numVertices) != 4 * numVertices )
          goto LABEL_48;
        RwMemNative32(v6->preLitLum, 4 * numVertices);
      }
      if ( v6->numTexCoordSets >= 1 )
      {
        v8 = 0;
        v9 = 8 * v6->numVertices;
        while ( RwStreamReadReal(stream, &v6->texCoords[v8]->u, v9) )
        {
          if ( ++v8 >= v6->numTexCoordSets )
            goto LABEL_22;
        }
        goto LABEL_48;
      }
LABEL_22:
      numTriangles = v6->numTriangles;
      if ( !numTriangles )
        goto LABEL_26;
      triangles = v6->triangles;
      if ( RwStreamRead(stream, triangles, 8 * numTriangles) == 8 * numTriangles )
      {
        RwMemNative32(triangles, 8 * numTriangles);
        do
        {
          v12 = *triangles;
          --numTriangles;
          triangles->vertIndex[1] = (RwUInt16)*triangles;
          triangles->matIndex = v12.vertIndex[2];
          triangles->vertIndex[0] = v12.vertIndex[1];
          triangles->vertIndex[2] = v12.matIndex;
          ++triangles;
        }
        while ( numTriangles );
LABEL_26:
        if ( v6->numMorphTargets < 1 )
        {
LABEL_37:
          v2 = 0;
          if ( !RwStreamFindChunk(stream, 8u, 0, &versionOut) )
            return v2;
          if ( versionOut - 212992 >= 0x2004 )
          {
            RpGeometryDestroy(v6);
            v2 = 0;
            code.pluginID = 0;
            v4 = _rwerror(-2147483644);
            goto LABEL_4;
          }
          if ( versionOut < 0x34001 )
            _rpMaterialSetDefaultSurfaceProperties(&mem);
          if ( _rpMaterialListStreamRead(stream, &v6->matList) )
          {
            if ( versionOut < 0x34001 )
              _rpMaterialSetDefaultSurfaceProperties(0);
            if ( _rwPluginRegistryReadDataChunks(&geometryTKList, stream, v6) && RpGeometryUnlock(v6) )
              return v6;
          }
          goto LABEL_48;
        }
        v13 = 0;
        v14 = 0;
        while ( 1 )
        {
          morphTarget = v6->morphTarget;
          if ( RwStreamRead(stream, &code, 0x18u) != 24 )
            break;
          RwMemNative32(&code, 0x18u);
          RwMemFloat32ToReal(&code, 0xCu);
          RwMemFloat32ToReal((char *)&v23 + 4, 4u);
          v16 = &morphTarget[v13];
          v17 = v23;
          p_boundingSphere = (int)&morphTarget[v13].boundingSphere;
          *(RwError_0 *)p_boundingSphere = code;
          *(_QWORD *)(p_boundingSphere + 8) = v17;
          if ( v24 )
          {
            p_x = &v16->verts->x;
            if ( v25 )
            {
              v20 = 24 * v6->numVertices;
              goto LABEL_35;
            }
            if ( !RwStreamReadReal(stream, p_x, 12 * v6->numVertices) )
              break;
          }
          if ( v25 )
          {
            p_x = &v16->normals->x;
            v20 = 12 * v6->numVertices;
LABEL_35:
            if ( !RwStreamReadReal(stream, p_x, v20) )
              break;
          }
          ++v14;
          ++v13;
          if ( v14 >= v6->numMorphTargets )
            goto LABEL_37;
        }
      }
LABEL_48:
      RpGeometryDestroy(v6);
    }
    return 0;
  }
  return v2;
}

//----- (002166D0) --------------------------------------------------------
RpGeometryChunkInfo_0 *__fastcall _rpGeometryChunkInfoRead(
        RwStream_0 *stream,
        RpGeometryChunkInfo_0 *geometryChunkInfo,
        RwInt32 *bytesRead)
{
  RwUInt32 v7; // [sp+0h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &v7) )
    return 0;
  *(_QWORD *)&geometryChunkInfo->format = 0LL;
  *(_QWORD *)&geometryChunkInfo->numVertices = 0LL;
  if ( RwStreamRead(stream, geometryChunkInfo, 0x10u) != 16 )
    return 0;
  RwStreamSkip(stream, lengthOut[0] - 16);
  *bytesRead = lengthOut[0] + 12;
  RwMemNative32(geometryChunkInfo, 0x10u);
  return geometryChunkInfo;
}
// 2166D0: using guessed type RwUInt32 lengthOut[5];

//----- (00216730) --------------------------------------------------------
RpLight_0 *__fastcall RpLightSetRadius(RpLight_0 *light, RwReal radius)
{
  RwFrame_0 *parent; // r0

  parent = (RwFrame_0 *)light->object.object.parent;
  light->radius = radius;
  if ( parent )
    RwFrameUpdateObjects(parent);
  return light;
}

//----- (00216746) --------------------------------------------------------
RpLight_0 *__fastcall RpLightSetColor(RpLight_0 *light, const RwRGBAReal_0 *color)
{
  __int64 v2; // d17

  v2 = *(_QWORD *)&color->blue;
  *(_QWORD *)&light->color.red = *(_QWORD *)&color->red;
  *(_QWORD *)&light->color.blue = v2;
  light->object.object.privateFlags = light->color.red == light->color.green;
  return light;
}

//----- (00216780) --------------------------------------------------------
RwReal __fastcall RpLightGetConeAngle(const RpLight_0 *light)
{
  float minusCosAngle; // s2
  float v2; // s0
  float v3; // r0
  unsigned int v4; // r1
  int *v5; // r1
  RwReal v7; // s18
  RwReal v8; // r0
  float v9; // s2
  float v10; // s2
  RwReal v11; // r0
  float v12; // s16
  RwReal v13; // r0

  minusCosAngle = light->minusCosAngle;
  v2 = -minusCosAngle;
  v3 = -minusCosAngle;
  v4 = fabs(-minusCosAngle);
  if ( v4 < 0x3F800000 )
  {
    if ( HIBYTE(v4) > 0x3Eu )
    {
      if ( SLODWORD(v3) <= -1 )
      {
        v11 = (float)(1.0 - minusCosAngle) * 0.5;
        v12 = (float)(v11
                    * (float)((float)(v11
                                    * (float)((float)(v11
                                                    * (float)((float)(v11
                                                                    * (float)((float)(v11
                                                                                    * (float)((float)(v11 * 0.000034793)
                                                                                            + 0.00079154))
                                                                            + -0.040056))
                                                            + 0.20121))
                                            + -0.32557))
                            + 0.16667))
            / (float)((float)(v11
                            * (float)((float)(v11
                                            * (float)((float)(v11 * (float)((float)(v11 * 0.077038) + -0.68828)) + 2.0209))
                                    + -2.4034))
                    + 1.0);
        v13 = _rwSqrt(v11);
        return (float)((float)(v13 + (float)((float)(v12 * v13) + -0.000000075498)) * -2.0) + 3.1416;
      }
      else
      {
        v7 = (float)(minusCosAngle + 1.0) * 0.5;
        v8 = _rwSqrt(v7);
        v9 = (float)((float)((float)(v7
                                   * (float)((float)(v7
                                                   * (float)((float)(v7
                                                                   * (float)((float)(v7
                                                                                   * (float)((float)(v7 * (float)((float)(v7 * 0.000034793) + 0.00079154))
                                                                                           + -0.040056))
                                                                           + 0.20121))
                                                           + -0.32557))
                                           + 0.16667))
                           / (float)((float)(v7
                                           * (float)((float)(v7
                                                           * (float)((float)(v7
                                                                           * (float)((float)(v7 * 0.077038) + -0.68828))
                                                                   + 2.0209))
                                                   + -2.4034))
                                   + 1.0))
                   * v8)
           + (float)((float)(v7
                           - (float)(COERCE_FLOAT(LODWORD(v8) & 0xFFFFF000) * COERCE_FLOAT(LODWORD(v8) & 0xFFFFF000)))
                   / (float)(v8 + COERCE_FLOAT(LODWORD(v8) & 0xFFFFF000)));
        return (float)(v9 + COERCE_FLOAT(LODWORD(v8) & 0xFFFFF000))
             + (float)(v9 + COERCE_FLOAT(LODWORD(v8) & 0xFFFFF000));
      }
    }
    else if ( v4 > 0x23000000 )
    {
      v10 = minusCosAngle * minusCosAngle;
      return 1.5708
           - (float)(v2
                   - (float)(0.000000075498
                           - (float)((float)((float)(v10
                                                   * (float)((float)(v10
                                                                   * (float)((float)(v10
                                                                                   * (float)((float)(v10 * (float)((float)(v10 * (float)((float)(v10 * 0.000034793) + 0.00079154)) + -0.040056))
                                                                                           + 0.20121))
                                                                           + -0.32557))
                                                           + 0.16667))
                                           / (float)((float)(v10
                                                           * (float)((float)(v10
                                                                           * (float)((float)(v10
                                                                                           * (float)((float)(v10 * 0.077038) + -0.68828))
                                                                                   + 2.0209))
                                                                   + -2.4034))
                                                   + 1.0))
                                   * v2)));
    }
    else
    {
      return 1.5708;
    }
  }
  else
  {
    v5 = dword_216A1C;
    if ( SLODWORD(v3) > 0 )
      v5 = &dword_216A1C[1];
    return *(float *)v5;
  }
}
// 216A1C: using guessed type int dword_216A1C[2];

//----- (00216A24) --------------------------------------------------------
RpLight_0 *__fastcall RpLightSetConeAngle(RpLight_0 *light, RwReal angle)
{
  RpLight_0 *result; // r0

  result = 0;
  if ( angle >= 0.0 && angle <= 3.1416 )
  {
    LODWORD(light->minusCosAngle) = COERCE_UNSIGNED_INT(cosf(angle)) ^ 0x80000000;
    return light;
  }
  return result;
}

//----- (00216A60) --------------------------------------------------------
RwInt32 __fastcall RpLightRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&lightTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (00216A88) --------------------------------------------------------
RwInt32 __fastcall RpLightRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&lightTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (00216AA8) --------------------------------------------------------
RwInt32 __fastcall RpLightSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&lightTKList, pluginID, alwaysCB);
}

//----- (00216AB8) --------------------------------------------------------
RwInt32 __fastcall RpLightGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&lightTKList, pluginID);
}

//----- (00216AC8) --------------------------------------------------------
RwBool __fastcall RpLightValidatePlugins(const RpLight_0 *light)
{
  return 1;
}

//----- (00216ACC) --------------------------------------------------------
RwUInt32 __fastcall RpLightStreamGetSize(const RpLight_0 *light)
{
  return _rwPluginRegistryGetSize(&lightTKList, light) + 48;
}

//----- (00216AE4) --------------------------------------------------------
const RpLight_0 *__fastcall RpLightStreamWrite(const RpLight_0 *light, RwStream_0 *stream)
{
  RwInt32 Size; // r0
  __int64 v5; // d17
  const RpLight_0 *result; // r0
  __int64 mem; // [sp+8h] [bp-30h] BYREF
  __int64 v8; // [sp+10h] [bp-28h] BYREF
  _DWORD v9[8]; // [sp+18h] [bp-20h] BYREF

  Size = _rwPluginRegistryGetSize(&lightTKList, light);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 18, Size + 48, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 1, 24, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  v5 = *(_QWORD *)&light->color.green;
  mem = *(_QWORD *)&light->radius;
  v8 = v5;
  v9[0] = LODWORD(light->minusCosAngle);
  v9[1] = light->object.object.flags | (light->object.object.subType << 16);
  RwMemRealToFloat32(&mem, 4u);
  RwMemRealToFloat32((char *)&mem + 4, 4u);
  RwMemRealToFloat32(&v8, 4u);
  RwMemRealToFloat32((char *)&v8 + 4, 4u);
  RwMemRealToFloat32(v9, 4u);
  RwMemLittleEndian32(&mem, 0x18u);
  if ( !RwStreamWrite(stream, &mem, 0x18u) )
    return 0;
  result = (const RpLight_0 *)_rwPluginRegistryWriteDataChunks(&lightTKList, stream, light);
  if ( result )
    return light;
  return result;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (00216BC0) --------------------------------------------------------
RpLight_0 *__fastcall RpLightStreamRead(RwStream_0 *stream)
{
  int v2; // r5
  RwUInt32 v3; // r0
  char v4; // r6^2
  __int16 v5; // r1
  RwInt32 errorCode; // r0
  __int64 v7; // kr00_8
  RwReal v8; // r0
  float v9; // s0
  float v10; // s2
  RwError_0 v12; // [sp+0h] [bp-30h] BYREF
  __int64 v13; // [sp+8h] [bp-28h] BYREF
  float v14; // [sp+10h] [bp-20h] BYREF
  int v15; // [sp+14h] [bp-1Ch]
  RwUInt32 versionOut; // [sp+18h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+1Ch] [bp-14h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
    return 0;
  if ( versionOut - 212992 > 0x2003 )
  {
    v2 = 0;
    v12.pluginID = 0;
    v12.errorCode = _rwerror(-2147483644);
    RwErrorSet(&v12);
    return (RpLight_0 *)v2;
  }
  v2 = 0;
  v12 = 0LL;
  v13 = 0LL;
  v14 = 0.0;
  v15 = 0;
  v3 = RwStreamRead(stream, &v12, lengthOut[0]);
  if ( v3 == lengthOut[0] )
  {
    RwMemNative32(&v12, 0x18u);
    v4 = BYTE2(v15);
    v2 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + lightModule));
    if ( v2 )
    {
      *(_BYTE *)v2 = 3;
      *(_BYTE *)(v2 + 2) = 0;
      *(_DWORD *)(v2 + 4) = 0;
      *(_BYTE *)(v2 + 62) = 0;
      *(_BYTE *)(v2 + 3) = 1;
      *(_DWORD *)(v2 + 36) = 1065353216;
      *(_DWORD *)(v2 + 40) = 1065353216;
      *(_DWORD *)(v2 + 44) = v2 + 44;
      *(_DWORD *)(v2 + 48) = v2 + 44;
      *(_DWORD *)(v2 + 52) = 0;
      *(_DWORD *)(v2 + 56) = 0;
      *(_BYTE *)(v2 + 1) = v4;
      *(_DWORD *)(v2 + 16) = LightSync;
      *(_QWORD *)(v2 + 20) = 0x3F80000000000000LL;
      *(_QWORD *)(v2 + 28) = 0x3F8000003F800000LL;
      v5 = *((_WORD *)RwEngineInstance + 5) - 1;
      *(_BYTE *)(v2 + 2) = 3;
      *(_WORD *)(v2 + 60) = v5;
      _rwPluginRegistryInitObject(&lightTKList, (void *)v2);
      RwMemFloat32ToReal(&v12, 4u);
      RwMemFloat32ToReal(&v12.errorCode, 4u);
      RwMemFloat32ToReal(&v13, 4u);
      RwMemFloat32ToReal((char *)&v13 + 4, 4u);
      RwMemFloat32ToReal(&v14, 4u);
      errorCode = v12.errorCode;
      v7 = v13;
      *(_DWORD *)(v2 + 20) = v12.pluginID;
      *(_DWORD *)(v2 + 24) = errorCode;
      *(_QWORD *)(v2 + 28) = v7;
      if ( versionOut > (unsigned int)&stru_302FC.st_name + 3 )
      {
        v9 = *(float *)&errorCode;
        v10 = *(float *)&v7;
        *(float *)(v2 + 40) = v14;
      }
      else
      {
        v8 = _rwSqrt(1.0 / (float)((float)(v14 * v14) + 1.0));
        v9 = *(float *)(v2 + 24);
        v10 = *(float *)(v2 + 28);
        *(_DWORD *)(v2 + 40) = LODWORD(v8) ^ 0x80000000;
      }
      *(_BYTE *)(v2 + 3) = v9 == v10;
      *(_BYTE *)(v2 + 2) = v15;
      if ( !_rwPluginRegistryReadDataChunks(&lightTKList, stream, (void *)v2) )
        return 0;
      return (RpLight_0 *)v2;
    }
    return 0;
  }
  return (RpLight_0 *)v2;
}
// 302FC: using guessed type Elf32_Sym stru_302FC;
// 6BD5C8: using guessed type int lightModule;
// 216BC0: using guessed type RwUInt32 lengthOut[5];

//----- (00216DB0) --------------------------------------------------------
RpLight_0 *__fastcall RpLightCreate(RwInt32 type)
{
  RwUInt8 v1; // r5
  RpLight_0 *v2; // r4
  RpLight_0 *result; // r0
  RwUInt16 v4; // r1

  v1 = type;
  v2 = (RpLight_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                      + lightModule));
  result = 0;
  if ( v2 )
  {
    v2->object.object.subType = v1;
    v2->object.object.type = 3;
    v2->object.object.flags = 0;
    v2->object.object.parent = 0;
    v2->isMainLight = 0;
    v2->object.object.privateFlags = 1;
    v2->color.alpha = 1.0;
    v2->minusCosAngle = 1.0;
    v2->WorldSectorsInLight.link.next = &v2->WorldSectorsInLight.link;
    v2->WorldSectorsInLight.link.prev = &v2->WorldSectorsInLight.link;
    v2->inWorld.next = 0;
    v2->inWorld.prev = 0;
    v2->object.sync = LightSync;
    *(_QWORD *)&v2->radius = 0x3F80000000000000LL;
    *(_QWORD *)&v2->color.green = 0x3F8000003F800000LL;
    v4 = *((_WORD *)RwEngineInstance + 5) - 1;
    v2->object.object.flags = 3;
    v2->lightFrame = v4;
    _rwPluginRegistryInitObject(&lightTKList, v2);
    return v2;
  }
  return result;
}
// 6BD5C8: using guessed type int lightModule;

//----- (00216E64) --------------------------------------------------------
RpLightChunkInfo_0 *__fastcall _rpLightChunkInfoRead(
        RwStream_0 *stream,
        RpLightChunkInfo_0 *lightChunkInfo,
        RwInt32 *bytesRead)
{
  RpLightChunkInfo_0 *v6; // r6
  RwUInt32 v7; // r0
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  v6 = 0;
  if ( RwStreamFindChunk(stream, 1u, lengthOut, 0) )
  {
    lightChunkInfo->typeAndFlags = 0;
    *(_QWORD *)&lightChunkInfo->radius = 0LL;
    *(_QWORD *)&lightChunkInfo->green = 0LL;
    lightChunkInfo->minusCosAngle = 0.0;
    if ( RwStreamRead(stream, lightChunkInfo, 0x18u) == 24 )
    {
      v7 = lengthOut[0];
      *bytesRead = lengthOut[0] + 12;
      RwStreamSkip(stream, v7 - 24);
      RwMemNative32(lightChunkInfo, lengthOut[0]);
      RwMemFloat32ToReal(lightChunkInfo, 4u);
      RwMemFloat32ToReal(&lightChunkInfo->red, 4u);
      RwMemFloat32ToReal(&lightChunkInfo->green, 4u);
      RwMemFloat32ToReal(&lightChunkInfo->blue, 4u);
      RwMemFloat32ToReal(&lightChunkInfo->minusCosAngle, 4u);
      return lightChunkInfo;
    }
  }
  return v6;
}
// 216E64: using guessed type RwUInt32 lengthOut[5];

//----- (00216EF4) --------------------------------------------------------
RwBool __fastcall RpLightDestroy(RpLight_0 *light)
{
  _rwPluginRegistryDeInitObject(&lightTKList, light);
  _rwObjectHasFrameReleaseFrame(light);
  (*((void (__fastcall **)(_DWORD, RpLight_0 *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + lightModule),
    light);
  return 1;
}
// 6BD5C8: using guessed type int lightModule;

//----- (00216F38) --------------------------------------------------------
void *__fastcall _rpLightClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeListForAllUsed(*(RwFreeList_0 **)((char *)RwEngineInstance + lightModule), LightTidyDestroyLight, 0);
  RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + lightModule));
  *(_DWORD *)((char *)RwEngineInstance + lightModule) = 0;
  --lightModule;
  return instance;
}
// 6BD5C8: using guessed type int lightModule;
// 6BD5CC: using guessed type int lightModule;

//----- (00216F94) --------------------------------------------------------
void __fastcall LightTidyDestroyLight(void *object, void *data)
{
  _rwPluginRegistryDeInitObject(&lightTKList, object);
  _rwObjectHasFrameReleaseFrame(object);
  (*((void (__fastcall **)(_DWORD, void *))RwEngineInstance + 80))(
    *(_DWORD *)((char *)RwEngineInstance + lightModule),
    object);
}
// 6BD5C8: using guessed type int lightModule;

//----- (00216FD4) --------------------------------------------------------
void __fastcall RpLightSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpLightFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpLightFreeListBlockSize = blockSize;
}

//----- (00216FEC) --------------------------------------------------------
void *__fastcall _rpLightOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2

  lightModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         lightTKList.sizeOfStruct,
         _rpLightFreeListBlockSize,
         4,
         _rpLightFreeListPreallocBlocks,
         &_rpLightFreeList);
  v5 = lightModule;
  *(_DWORD *)((char *)RwEngineInstance + lightModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  ++lightModule;
  return instance;
}
// 6BD5C8: using guessed type int lightModule;
// 6BD5CC: using guessed type int lightModule;

//----- (00217064) --------------------------------------------------------
void __fastcall _rpMaterialSetDefaultSurfaceProperties(const RwSurfaceProperties_0 *surfaceProps)
{
  __int64 v1; // d16

  if ( surfaceProps )
  {
    v1 = *(_QWORD *)&surfaceProps->ambient;
    defaultSurfaceProperties.diffuse = surfaceProps->diffuse;
    *(_QWORD *)&defaultSurfaceProperties.ambient = v1;
  }
  else
  {
    defaultSurfaceProperties.ambient = 1.0;
    defaultSurfaceProperties.specular = 1.0;
    defaultSurfaceProperties.diffuse = 1.0;
  }
}

//----- (00217090) --------------------------------------------------------
void __fastcall RpMaterialSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpMaterialFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpMaterialFreeListBlockSize = blockSize;
}

//----- (002170A8) --------------------------------------------------------
void *__fastcall _rpMaterialOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2

  materialModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         materialTKList.sizeOfStruct,
         _rpMaterialFreeListBlockSize,
         4,
         _rpMaterialFreeListPreallocBlocks,
         &_rpMaterialFreeList);
  v5 = materialModule;
  *(_DWORD *)((char *)RwEngineInstance + materialModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  ++materialModule;
  return instance;
}
// 6BD5F4: using guessed type int materialModule;
// 6BD5F8: using guessed type int materialModule;

//----- (00217120) --------------------------------------------------------
void *__fastcall _rpMaterialClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + materialModule);
  if ( v4 )
  {
    RwFreeListDestroy(v4);
    *(_DWORD *)((char *)RwEngineInstance + materialModule) = 0;
  }
  --materialModule;
  return instance;
}
// 6BD5F4: using guessed type int materialModule;
// 6BD5F8: using guessed type int materialModule;

//----- (00217170) --------------------------------------------------------
RpMaterial_0 *RpMaterialCreate()
{
  char *v0; // r4
  RpMaterial_0 *result; // r0
  __int64 v2; // d16

  v0 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                 + materialModule));
  result = 0;
  if ( v0 )
  {
    *((_DWORD *)v0 + 1) = -1;
    *((_WORD *)v0 + 12) = 1;
    *(_DWORD *)v0 = 0;
    *((_DWORD *)v0 + 2) = 0;
    v2 = *(_QWORD *)&defaultSurfaceProperties.ambient;
    *((_DWORD *)v0 + 5) = LODWORD(defaultSurfaceProperties.diffuse);
    *(_QWORD *)(v0 + 12) = v2;
    _rwPluginRegistryInitObject(&materialTKList, v0);
    return (RpMaterial_0 *)v0;
  }
  return result;
}
// 6BD5F4: using guessed type int materialModule;

//----- (002171D0) --------------------------------------------------------
RwBool __fastcall RpMaterialDestroy(RpMaterial_0 *material)
{
  int refCount; // r0

  refCount = (unsigned __int16)material->refCount;
  if ( refCount == 1 )
  {
    _rwPluginRegistryDeInitObject(&materialTKList, material);
    if ( material->texture )
    {
      RwTextureDestroy(material->texture);
      material->texture = 0;
    }
    (*((void (__fastcall **)(_DWORD, RpMaterial_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + materialModule),
      material);
    return 1;
  }
  else
  {
    material->refCount = refCount - 1;
    return 1;
  }
}
// 6BD5F4: using guessed type int materialModule;

//----- (00217224) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialSetTexture(RpMaterial_0 *material, RwTexture_0 *texture)
{
  RwTexture_0 *v4; // r0

  v4 = material->texture;
  if ( v4 != texture )
  {
    if ( texture )
    {
      ++texture->refCount;
      v4 = material->texture;
    }
    if ( v4 )
      RwTextureDestroy(v4);
    material->texture = texture;
  }
  return material;
}

//----- (0021724C) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialClone(RpMaterial_0 *material)
{
  int v2; // r5
  __int64 v3; // d16
  RwTexture_0 *texture; // r6
  bool v5; // zf
  __int64 v6; // d16

  v2 = (*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + materialModule));
  if ( !v2 )
    return 0;
  *(_DWORD *)(v2 + 4) = -1;
  *(_WORD *)(v2 + 24) = 1;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 8) = 0;
  v3 = *(_QWORD *)&defaultSurfaceProperties.ambient;
  *(RwReal *)(v2 + 20) = defaultSurfaceProperties.diffuse;
  *(_QWORD *)(v2 + 12) = v3;
  _rwPluginRegistryInitObject(&materialTKList, (void *)v2);
  texture = material->texture;
  v5 = material->texture == 0;
  if ( material->texture )
    v5 = *(_DWORD *)v2 == (_DWORD)texture;
  if ( !v5 )
  {
    ++texture->refCount;
    if ( *(_DWORD *)v2 )
      RwTextureDestroy(*(RwTexture_0 **)v2);
    *(_DWORD *)v2 = texture;
  }
  *(RwRGBA_0 *)(v2 + 4) = material->color;
  *(_DWORD *)(v2 + 8) = material->pipeline;
  v6 = *(_QWORD *)&material->surfaceProps.ambient;
  *(RwReal *)(v2 + 20) = material->surfaceProps.diffuse;
  *(_QWORD *)(v2 + 12) = v6;
  _rwPluginRegistryCopyObject(&materialTKList, (void *)v2, material);
  return (RpMaterial_0 *)v2;
}
// 6BD5F4: using guessed type int materialModule;

//----- (00217300) --------------------------------------------------------
RwInt32 __fastcall RpMaterialRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&materialTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (00217328) --------------------------------------------------------
RwInt32 __fastcall RpMaterialRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&materialTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (00217348) --------------------------------------------------------
RwInt32 __fastcall RpMaterialSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&materialTKList, pluginID, alwaysCB);
}

//----- (00217358) --------------------------------------------------------
RwInt32 __fastcall RpMaterialSetStreamRightsCallBack(RwUInt32 pluginID, RwPluginDataChunkRightsCallBack rightsCB)
{
  return sub_19E33C(&materialTKList, pluginID, rightsCB);
}

//----- (00217368) --------------------------------------------------------
RwInt32 __fastcall RpMaterialGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&materialTKList, pluginID);
}

//----- (00217378) --------------------------------------------------------
RwBool __fastcall RpMaterialValidatePlugins(const RpMaterial_0 *material)
{
  return 1;
}

//----- (0021737C) --------------------------------------------------------
RpMaterialChunkInfo_0 *__fastcall _rpMaterialChunkInfoRead(
        RwStream_0 *stream,
        RpMaterialChunkInfo_0 *materialChunkInfo,
        RwInt32 *bytesRead)
{
  RpMaterialChunkInfo_0 *v6; // r6
  RwUInt32 v7; // r1
  RwRGBA_0 color; // r5
  RwUInt32 lengthOut[5]; // [sp+4h] [bp-14h] BYREF

  v6 = 0;
  if ( RwStreamFindChunk(stream, 1u, lengthOut, 0) )
  {
    *(_QWORD *)&materialChunkInfo->textured = 0LL;
    *(_QWORD *)&materialChunkInfo->surfaceProps.specular = 0LL;
    *(_QWORD *)&materialChunkInfo->flags = 0LL;
    *(_QWORD *)&materialChunkInfo->unused = 0LL;
    v7 = RwStreamRead(stream, materialChunkInfo, lengthOut[0]);
    if ( v7 == lengthOut[0] )
    {
      *bytesRead = v7 + 12;
      color = materialChunkInfo->color;
      RwMemNative32(materialChunkInfo, v7);
      materialChunkInfo->color = color;
      if ( lengthOut[0] > 0x10 )
      {
        RwMemFloat32ToReal(&materialChunkInfo->surfaceProps, 0xCu);
      }
      else
      {
        materialChunkInfo->surfaceProps.ambient = 1.0;
        materialChunkInfo->surfaceProps.specular = 1.0;
        materialChunkInfo->surfaceProps.diffuse = 1.0;
      }
      return materialChunkInfo;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}
// 21737C: using guessed type RwUInt32 lengthOut[5];

//----- (002173FC) --------------------------------------------------------
RpMaterial_0 *__fastcall RpMaterialStreamRead(RwStream_0 *stream)
{
  RwUInt32 v2; // r0
  char *v3; // r0
  RpMaterial_0 *v4; // r4
  __int64 v5; // d16
  __int64 v6; // d16
  int refCount; // r0
  RwError_0 *p_buffer; // r0
  int v10; // r0
  int v11[2]; // [sp+0h] [bp-48h] BYREF
  __int64 buffer; // [sp+8h] [bp-40h] BYREF
  int v13; // [sp+10h] [bp-38h]
  __int128 v14; // [sp+14h] [bp-34h] BYREF
  RwUInt32 versionOut; // [sp+28h] [bp-20h] BYREF
  RwUInt32 lengthOut[7]; // [sp+2Ch] [bp-1Ch] BYREF

  if ( !RwStreamFindChunk(stream, 1u, lengthOut, &versionOut) )
    return 0;
  if ( versionOut - 212992 > 0x2003 )
  {
    v4 = 0;
    LODWORD(buffer) = 0;
    HIDWORD(buffer) = _rwerror(-2147483644);
    p_buffer = (RwError_0 *)&buffer;
    goto LABEL_15;
  }
  buffer = 0LL;
  v13 = 0;
  v14 = 0uLL;
  v2 = RwStreamRead(stream, &buffer, lengthOut[0]);
  if ( v2 != lengthOut[0] )
    return 0;
  RwMemNative32(&buffer, 0x1Cu);
  v3 = (char *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                 + materialModule));
  v4 = (RpMaterial_0 *)v3;
  if ( !v3 )
    return 0;
  *((_DWORD *)v3 + 1) = -1;
  *((_WORD *)v3 + 12) = 1;
  *(_DWORD *)v3 = 0;
  *((_DWORD *)v3 + 2) = 0;
  v5 = *(_QWORD *)&defaultSurfaceProperties.ambient;
  *((_DWORD *)v3 + 5) = LODWORD(defaultSurfaceProperties.diffuse);
  *(_QWORD *)(v3 + 12) = v5;
  _rwPluginRegistryInitObject(&materialTKList, v3);
  v4->color = (RwRGBA_0)HIDWORD(buffer);
  RwMemFloat32ToReal((char *)&v14 + 4, 0xCu);
  v6 = *(_QWORD *)((char *)&v14 + 4);
  v4->surfaceProps.diffuse = *((RwReal *)&v14 + 3);
  v4->texture = 0;
  *(_QWORD *)&v4->surfaceProps.ambient = v6;
  if ( (_DWORD)v14 )
  {
    if ( !RwStreamFindChunk(stream, 6u, 0, &versionOut) )
    {
      refCount = (unsigned __int16)v4->refCount;
      if ( refCount == 1 )
      {
        _rwPluginRegistryDeInitObject(&materialTKList, v4);
        if ( v4->texture )
        {
          RwTextureDestroy(v4->texture);
          v4->texture = 0;
        }
        goto LABEL_19;
      }
LABEL_20:
      v4->refCount = refCount - 1;
      return 0;
    }
    if ( versionOut - 212992 <= 0x2003 )
    {
      v4->texture = RwTextureStreamRead(stream);
      goto LABEL_9;
    }
    v10 = (unsigned __int16)v4->refCount;
    if ( v10 == 1 )
    {
      _rwPluginRegistryDeInitObject(&materialTKList, v4);
      if ( v4->texture )
      {
        RwTextureDestroy(v4->texture);
        v4->texture = 0;
      }
      (*((void (__fastcall **)(_DWORD, RpMaterial_0 *))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + materialModule),
        v4);
    }
    else
    {
      v4->refCount = v10 - 1;
    }
    v4 = 0;
    v11[0] = 0;
    v11[1] = _rwerror(-2147483644);
    p_buffer = (RwError_0 *)v11;
LABEL_15:
    RwErrorSet(p_buffer);
    return v4;
  }
LABEL_9:
  if ( !_rwPluginRegistryReadDataChunks(&materialTKList, stream, v4) )
  {
    refCount = (unsigned __int16)v4->refCount;
    if ( refCount == 1 )
    {
      _rwPluginRegistryDeInitObject(&materialTKList, v4);
      if ( v4->texture )
      {
        RwTextureDestroy(v4->texture);
        v4->texture = 0;
      }
LABEL_19:
      (*((void (__fastcall **)(_DWORD, RpMaterial_0 *))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + materialModule),
        v4);
      return 0;
    }
    goto LABEL_20;
  }
  return v4;
}
// 6BD5F4: using guessed type int materialModule;
// 2173FC: using guessed type RwUInt32 lengthOut[7];

//----- (002175F8) --------------------------------------------------------
RwUInt32 __fastcall RpMaterialStreamGetSize(const RpMaterial_0 *material)
{
  RwTexture_0 *texture; // r0
  RwUInt32 v3; // r5

  texture = material->texture;
  if ( texture )
    v3 = RwTextureStreamGetSize(texture) + 64;
  else
    v3 = 52;
  return _rwPluginRegistryGetSize(&materialTKList, material) + v3;
}

//----- (00217620) --------------------------------------------------------
const RpMaterial_0 *__fastcall RpMaterialStreamWrite(const RpMaterial_0 *material, RwStream_0 *stream)
{
  RwTexture_0 *texture; // r0
  RwUInt32 v5; // r6
  RwInt32 Size; // r0
  const RpMaterial_0 *v7; // r6
  RwTexture_0 *v8; // r0
  double v9; // d16
  int v11[4]; // [sp+8h] [bp-38h] BYREF
  double v12; // [sp+18h] [bp-28h] BYREF
  RwReal diffuse; // [sp+20h] [bp-20h]

  texture = material->texture;
  if ( texture )
    v5 = RwTextureStreamGetSize(texture) + 64;
  else
    v5 = 52;
  Size = _rwPluginRegistryGetSize(&materialTKList, material);
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 7, Size + v5, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
    return 0;
  v7 = 0;
  if ( _rwStreamWriteVersionedChunkHeader(stream, 1, 28, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu) )
  {
    v11[0] = 0;
    v8 = material->texture;
    if ( material->texture )
      v8 = (RwTexture_0 *)(&dword_0 + 1);
    v11[3] = (int)v8;
    v9 = *(double *)&material->surfaceProps.ambient;
    diffuse = material->surfaceProps.diffuse;
    v12 = v9;
    RwMemRealToFloat32(&v12, 0xCu);
    RwMemLittleEndian32(v11, 0x1Cu);
    v11[1] = (int)material->color;
    if ( RwStreamWrite(stream, v11, 0x1Cu) )
    {
      if ( !material->texture || RwTextureStreamWrite(material->texture, stream) )
      {
        v7 = (const RpMaterial_0 *)_rwPluginRegistryWriteDataChunks(&materialTKList, stream, material);
        if ( v7 )
          return material;
        return v7;
      }
      return 0;
    }
  }
  return v7;
}
// 0: using guessed type int dword_0;
// 35FFC: using guessed type Elf32_Sym stru_35FFC;

//----- (002176EC) --------------------------------------------------------
RpMaterialList_0 *__fastcall _rpMaterialListDeinitialize(RpMaterialList_0 *matList)
{
  RpMaterial_0 **materials; // r8
  RwInt32 numMaterials; // r6
  RpMaterial_0 **v4; // r4

  materials = matList->materials;
  if ( matList->materials )
  {
    numMaterials = matList->numMaterials;
    if ( numMaterials >= 1 )
    {
      v4 = matList->materials;
      do
      {
        RpMaterialDestroy(*v4);
        *v4++ = 0;
        --numMaterials;
      }
      while ( numMaterials );
    }
    (*((void (__fastcall **)(RpMaterial_0 **))RwEngineInstance + 76))(materials);
    matList->materials = 0;
  }
  matList->numMaterials = 0;
  matList->space = 0;
  return matList;
}

//----- (00217744) --------------------------------------------------------
RpMaterialList_0 *__fastcall _rpMaterialListInitialize(RpMaterialList_0 *matList)
{
  matList->materials = 0;
  matList->numMaterials = 0;
  matList->space = 0;
  return matList;
}

//----- (00217750) --------------------------------------------------------
RpMaterial_0 **__fastcall _rpMaterialListAlloc(RwUInt32 count)
{
  return (RpMaterial_0 **)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * count);
}

//----- (00217764) --------------------------------------------------------
RpMaterialList_0 *__fastcall _rpMaterialListCopy(RpMaterialList_0 *matListOut, const RpMaterialList_0 *matListIn)
{
  RpMaterialList_0 *v3; // r4
  RwInt32 space; // r0
  RpMaterial_0 **v5; // r0
  int v6; // r0
  RpMaterial_0 *v7; // r1
  RwInt32 v8; // r0
  RwError_0 v10; // [sp+0h] [bp-10h] BYREF

  v3 = matListOut;
  matListOut->numMaterials = matListIn->numMaterials;
  space = matListIn->space;
  v3->materials = 0;
  v3->space = space;
  if ( matListIn->materials )
  {
    v5 = (RpMaterial_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * space);
    v3->materials = v5;
    if ( v5 )
    {
      if ( v3->numMaterials < 1 )
      {
        v6 = 0;
      }
      else
      {
        *v5 = *matListIn->materials;
        ++(*v3->materials)->refCount;
        if ( v3->numMaterials < 2 )
        {
          v6 = 1;
        }
        else
        {
          v6 = 1;
          do
          {
            v3->materials[v6] = matListIn->materials[v6];
            v7 = v3->materials[v6++];
            ++v7->refCount;
          }
          while ( v6 < v3->numMaterials );
        }
      }
      for ( ; v6 < v3->space; ++v6 )
        v3->materials[v6] = 0;
    }
    else
    {
      v8 = v3->space;
      v3 = 0;
      v10.pluginID = 0;
      v10.errorCode = _rwerror(-2147483629, 4 * v8);
      RwErrorSet(&v10);
    }
  }
  return v3;
}

//----- (00217818) --------------------------------------------------------
RpMaterial_0 *__fastcall _rpMaterialListGetMaterial(const RpMaterialList_0 *matList, RwInt32 matIndex)
{
  return matList->materials[matIndex];
}

//----- (00217820) --------------------------------------------------------
RpMaterialList_0 *__fastcall _rpMaterialListSetSize(RpMaterialList_0 *matList, RwInt32 size)
{
  RpMaterialList_0 *v2; // r4
  RpMaterial_0 **materials; // r0
  int v5; // r0
  RwError_0 v7; // [sp+0h] [bp-18h] BYREF

  v2 = matList;
  if ( matList->space < size )
  {
    materials = matList->materials;
    if ( v2->materials )
    {
      v5 = (*((int (__fastcall **)(RpMaterial_0 **, int))RwEngineInstance + 77))(materials, 4 * size);
      if ( v5 )
      {
LABEL_4:
        v2->space = size;
        v2->materials = (RpMaterial_0 **)v5;
        return v2;
      }
    }
    else
    {
      v5 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * size);
      if ( v5 )
        goto LABEL_4;
    }
    v2 = 0;
    v7.pluginID = 0;
    v7.errorCode = _rwerror(-2147483629, 4 * size);
    RwErrorSet(&v7);
  }
  return v2;
}

//----- (00217884) --------------------------------------------------------
RwInt32 __fastcall _rpMaterialListAppendMaterial(RpMaterialList_0 *matList, RpMaterial_0 *material)
{
  __int64 v4; // r0
  int v5; // r6
  RpMaterial_0 **v6; // r0
  __int64 v7; // kr00_8
  RwInt32 result; // r0
  RwError_0 v9; // [sp+0h] [bp-18h] BYREF

  v4 = *(_QWORD *)&matList->numMaterials;
  if ( SHIDWORD(v4) > (int)v4 )
  {
    matList->materials[v4] = material;
LABEL_6:
    ++material->refCount;
    result = matList->numMaterials;
    matList->numMaterials = result + 1;
    return result;
  }
  v5 = 4 * HIDWORD(v4) + 80;
  if ( matList->materials )
  {
    v6 = (RpMaterial_0 **)(*((int (__fastcall **)(RpMaterial_0 **, int))RwEngineInstance + 77))(
                            matList->materials,
                            4 * HIDWORD(v4) + 80);
    if ( v6 )
    {
LABEL_5:
      v7 = *(_QWORD *)&matList->numMaterials;
      matList->materials = v6;
      matList->space = HIDWORD(v7) + 20;
      v6[(_DWORD)v7] = material;
      goto LABEL_6;
    }
  }
  else
  {
    v6 = (RpMaterial_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v5);
    if ( v6 )
      goto LABEL_5;
  }
  v9.pluginID = 0;
  v9.errorCode = _rwerror(-2147483629, v5);
  RwErrorSet(&v9);
  return -1;
}

//----- (00217910) --------------------------------------------------------
RwInt32 __fastcall _rpMaterialListFindMaterialIndex(const RpMaterialList_0 *matList, const RpMaterial_0 *material)
{
  int v2; // r3
  RwInt32 v3; // r2

  v2 = matList->numMaterials - 1;
  do
  {
    v3 = v2;
    if ( v2 + 1 < 1 )
      break;
    --v2;
  }
  while ( matList->materials[v3] != material );
  return v3;
}

//----- (0021792C) --------------------------------------------------------
RwUInt32 __fastcall _rpMaterialListStreamGetSize(const RpMaterialList_0 *matList)
{
  RwInt32 numMaterials; // r1
  RwUInt32 v3; // r8
  RwInt32 i; // r6
  RpMaterial_0 **materials; // r2
  RwInt32 v6; // r4
  const RpMaterial_0 *v7; // r0
  RwInt32 v8; // r5
  RwUInt32 Size; // r0

  numMaterials = matList->numMaterials;
  v3 = 4 * numMaterials + 16;
  if ( numMaterials >= 1 )
  {
    for ( i = 0; i < numMaterials; ++i )
    {
      materials = matList->materials;
      v6 = i;
      do
      {
        if ( !v6 )
        {
          v7 = materials[i];
          goto LABEL_9;
        }
        v7 = matList->materials[v6 - 1];
        v8 = --v6;
      }
      while ( v7 != materials[i] );
      if ( v8 + 1 >= 1 )
        continue;
LABEL_9:
      Size = RpMaterialStreamGetSize(v7);
      numMaterials = matList->numMaterials;
      v3 += Size + 12;
    }
  }
  return v3;
}

//----- (00217988) --------------------------------------------------------
const RpMaterialList_0 *__fastcall _rpMaterialListStreamWrite(const RpMaterialList_0 *matList, RwStream_0 *stream)
{
  const RpMaterialList_0 *v2; // r11
  RwInt32 numMaterials; // r1
  RwInt32 *p_numMaterials; // r10
  RwInt32 v6; // r8
  RwInt32 i; // r6
  RpMaterial_0 **materials; // r2
  RwInt32 v9; // r4
  const RpMaterial_0 *v10; // r0
  RwInt32 v11; // r5
  RwUInt32 Size; // r0
  int v13; // r6
  RpMaterial_0 **v14; // r0
  int v15; // r2
  int v16; // r1
  RwInt32 v17; // r3
  int v18; // r0
  RwInt32 v19; // r5
  int v20; // r6
  RwInt32 v21; // r1
  RpMaterial_0 *v22; // r2
  RwInt32 ints[8]; // [sp+8h] [bp-20h] BYREF

  v2 = matList;
  p_numMaterials = &matList->numMaterials;
  numMaterials = matList->numMaterials;
  v6 = 4 * numMaterials + 16;
  if ( numMaterials >= 1 )
  {
    for ( i = 0; i < numMaterials; ++i )
    {
      materials = v2->materials;
      v9 = i;
      do
      {
        if ( !v9 )
        {
          v10 = materials[i];
          goto LABEL_9;
        }
        v10 = v2->materials[v9 - 1];
        v11 = --v9;
      }
      while ( v10 != materials[i] );
      if ( v11 + 1 >= 1 )
        continue;
LABEL_9:
      Size = RpMaterialStreamGetSize(v10);
      numMaterials = *p_numMaterials;
      v6 += Size + 12;
    }
  }
  if ( !_rwStreamWriteVersionedChunkHeader(stream, 8, v6, (RwUInt32)&stru_35FFC.st_value + 3, 0xFFFFu)
    || !_rwStreamWriteVersionedChunkHeader(
          stream,
          1,
          4 * *p_numMaterials + 4,
          (RwUInt32)&stru_35FFC.st_value + 3,
          0xFFFFu)
    || !RwStreamWriteInt32(stream, p_numMaterials, 4u) )
  {
    return 0;
  }
  if ( *p_numMaterials >= 1 )
  {
    v13 = 0;
    while ( 1 )
    {
      ints[0] = v13 - 1;
      if ( v13 )
      {
        v14 = v2->materials;
        v15 = v13;
        v16 = (int)(v2->materials - 1);
        do
        {
          if ( *(RpMaterial_0 **)(v16 + 4 * v15) == v14[v13] )
            break;
          v17 = v15 - 2;
          --v15;
          ints[0] = v17;
        }
        while ( v15 );
      }
      if ( !RwStreamWriteInt32(stream, ints, 4u) )
        return 0;
      v18 = *p_numMaterials;
      if ( ++v13 >= *p_numMaterials )
      {
        if ( v18 >= 1 )
        {
          v19 = 0;
          v20 = -1;
          do
          {
            v21 = v20;
            ints[0] = v19;
            while ( 1 )
            {
              ints[0] = v21;
              if ( v21 == -1 )
                break;
              v22 = v2->materials[v21--];
              if ( v22 == v2->materials[v19] )
              {
                if ( v21 + 2 > 0 )
                  goto LABEL_30;
                break;
              }
            }
            if ( !RpMaterialStreamWrite(v2->materials[v19], stream) )
              return 0;
            v18 = *p_numMaterials;
LABEL_30:
            ++v19;
            ++v20;
          }
          while ( v19 < v18 );
        }
        return v2;
      }
    }
  }
  return v2;
}
// 35FFC: using guessed type Elf32_Sym stru_35FFC;
// 217988: using guessed type RwInt32 ints[8];

//----- (00217AC8) --------------------------------------------------------
RpMaterialList_0 *__fastcall _rpMaterialListStreamRead(RwStream_0 *stream, RpMaterialList_0 *matList)
{
  RpMaterialList_0 *v4; // r5
  RwInt32 v5; // r4
  RpMaterial_0 **v6; // r0
  RwInt32 *v7; // r9
  RwInt32 i; // r4
  int v9; // r0
  RpMaterial_0 *v10; // r5
  RpMaterial_0 **v11; // r8
  RwInt32 v12; // r4
  RpMaterial_0 **v13; // r5
  RpMaterial_0 **materials; // r8
  RwInt32 numMaterials; // r4
  RpMaterial_0 **v16; // r6
  RwInt32 v18; // r4
  RpMaterial_0 **v19; // r5
  RwInt32 v20; // r4
  RpMaterial_0 **v21; // r6
  RwInt32 v22; // r4
  RpMaterial_0 **v23; // r5
  RwUInt32 v24; // [sp+0h] [bp-30h] BYREF
  RwUInt32 lengthOut; // [sp+4h] [bp-2Ch] BYREF
  RwInt32 ints; // [sp+8h] [bp-28h] BYREF
  RwError_0 code; // [sp+Ch] [bp-24h] BYREF

  if ( !RwStreamFindChunk(stream, 1u, &lengthOut, &v24) )
    return 0;
  if ( v24 - 212992 > 0x2003 )
  {
    v4 = 0;
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483644);
    RwErrorSet(&code);
    return v4;
  }
  v4 = 0;
  if ( RwStreamReadInt32(stream, &ints, 4u) )
  {
    matList->materials = 0;
    matList->numMaterials = 0;
    matList->space = 0;
    v5 = ints;
    if ( !ints )
      return matList;
    if ( ints >= 1 )
    {
      v6 = (RpMaterial_0 **)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * ints);
      if ( !v6 )
      {
        v4 = 0;
        code.pluginID = 0;
        code.errorCode = _rwerror(-2147483629, 4 * v5);
        RwErrorSet(&code);
        materials = matList->materials;
        if ( matList->materials )
        {
          numMaterials = matList->numMaterials;
          if ( numMaterials >= 1 )
          {
            v16 = matList->materials;
            do
            {
              RpMaterialDestroy(*v16);
              *v16++ = 0;
              --numMaterials;
            }
            while ( numMaterials );
          }
LABEL_31:
          (*((void (__fastcall **)(RpMaterial_0 **))RwEngineInstance + 76))(materials);
          matList->materials = 0;
        }
        goto LABEL_32;
      }
      matList->space = v5;
      matList->materials = v6;
      v5 = ints;
    }
    v7 = (RwInt32 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v5);
    if ( RwStreamReadInt32(stream, v7, 4 * ints) )
    {
      if ( ints >= 1 )
      {
        for ( i = 0; i < ints; ++i )
        {
          v9 = v7[i];
          if ( v9 <= -1 )
          {
            if ( !RwStreamFindChunk(stream, 7u, 0, &v24) )
            {
              (*((void (__fastcall **)(RwInt32 *))RwEngineInstance + 76))(v7);
              v11 = matList->materials;
              if ( !matList->materials )
                goto LABEL_26;
              v18 = matList->numMaterials;
              if ( v18 >= 1 )
              {
                v19 = matList->materials;
                do
                {
                  RpMaterialDestroy(*v19);
                  *v19++ = 0;
                  --v18;
                }
                while ( v18 );
              }
              goto LABEL_25;
            }
            if ( v24 - 212992 > 0x2003 )
            {
              v4 = 0;
              code.pluginID = 0;
              code.errorCode = _rwerror(-2147483644);
              RwErrorSet(&code);
              (*((void (__fastcall **)(RwInt32 *))RwEngineInstance + 76))(v7);
              materials = matList->materials;
              if ( !matList->materials )
                goto LABEL_32;
              v20 = matList->numMaterials;
              if ( v20 >= 1 )
              {
                v21 = matList->materials;
                do
                {
                  RpMaterialDestroy(*v21);
                  *v21++ = 0;
                  --v20;
                }
                while ( v20 );
              }
              goto LABEL_31;
            }
            v10 = RpMaterialStreamRead(stream);
            if ( !v10 )
            {
              (*((void (__fastcall **)(RwInt32 *))RwEngineInstance + 76))(v7);
              v11 = matList->materials;
              if ( !matList->materials )
                goto LABEL_26;
              v22 = matList->numMaterials;
              if ( v22 >= 1 )
              {
                v23 = matList->materials;
                do
                {
                  RpMaterialDestroy(*v23);
                  *v23++ = 0;
                  --v22;
                }
                while ( v22 );
              }
LABEL_25:
              (*((void (__fastcall **)(RpMaterial_0 **))RwEngineInstance + 76))(v11);
              matList->materials = 0;
              goto LABEL_26;
            }
          }
          else
          {
            v10 = matList->materials[v9];
            ++v10->refCount;
          }
          _rpMaterialListAppendMaterial(matList, v10);
          RpMaterialDestroy(v10);
        }
      }
      (*((void (__fastcall **)(RwInt32 *))RwEngineInstance + 76))(v7);
      return matList;
    }
    (*((void (__fastcall **)(RwInt32 *))RwEngineInstance + 76))(v7);
    v11 = matList->materials;
    if ( matList->materials )
    {
      v12 = matList->numMaterials;
      if ( v12 >= 1 )
      {
        v13 = matList->materials;
        do
        {
          RpMaterialDestroy(*v13);
          *v13++ = 0;
          --v12;
        }
        while ( v12 );
      }
      goto LABEL_25;
    }
LABEL_26:
    v4 = 0;
LABEL_32:
    matList->numMaterials = 0;
    matList->space = 0;
  }
  return v4;
}

//----- (00217DA4) --------------------------------------------------------
void __fastcall _rpMeshHeaderDestroy(RpMeshHeader_0 *meshHeader)
{
  u_native indexBuffer; // r0

  indexBuffer = meshHeader->indexBuffer;
  if ( indexBuffer )
  {
    emu_ArraysDelete(indexBuffer);
    meshHeader->indexBuffer = 0;
  }
  (*((void (__fastcall **)(RpMeshHeader_0 *))RwEngineInstance + 76))(meshHeader);
}

//----- (00217DD0) --------------------------------------------------------
RpMeshHeader_0 *__fastcall _rpMeshHeaderCreate(RwUInt32 size)
{
  RpMeshHeader_0 *result; // r0

  result = (RpMeshHeader_0 *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(size);
  result->indexBuffer = 0;
  return result;
}

//----- (00217DEC) --------------------------------------------------------
void *__fastcall _rpMeshClose(void *instance, RwInt32 offset, RwInt32 size)
{
  if ( !--meshModule.numInstances && MeshStatic )
  {
    RwFreeListDestroy((RwFreeList_0 *)MeshStatic);
    MeshStatic = 0;
  }
  return instance;
}
// 6BD604: using guessed type int MeshStatic;

//----- (00217E24) --------------------------------------------------------
void *__fastcall _rpMeshOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwModuleInfo_0 v4; // kr00_8

  meshModule.globalsOffset = offset;
  if ( !meshModule.numInstances )
  {
    MeshStatic = (int)RwFreeListCreate(12, 50, 4);
    if ( !MeshStatic )
      return 0;
    offset = meshModule.globalsOffset;
  }
  *(_WORD *)((char *)RwEngineInstance + offset) = 1;
  v4 = meshModule;
  ++meshModule.numInstances;
  *((_BYTE *)RwEngineInstance + v4.globalsOffset + 8) = 3;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 9) = 4;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 10) = 5;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 12) = 1;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 16) = 2;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 24) = 6;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 40) = 4;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 41) = 8;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 42) = 0;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 43) = 1;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 44) = 2;
  *((_BYTE *)RwEngineInstance + meshModule.globalsOffset + 45) = 16;
  return instance;
}
// 6BD604: using guessed type int MeshStatic;

//----- (00217F0C) --------------------------------------------------------
RpBuildMesh_0 *__fastcall _rpBuildMeshCreate(RwUInt32 bufferSize)
{
  RpBuildMesh_0 *v2; // r4
  int v3; // r0
  RwInt32 v4; // r0
  RwError_0 v6; // [sp+0h] [bp-18h] BYREF

  v2 = (RpBuildMesh_0 *)(*((int (__fastcall **)(int))RwEngineInstance + 79))(MeshStatic);
  if ( !v2 )
  {
    v2 = 0;
    v6.pluginID = 0;
    v4 = _rwerror(-2147483629, 12);
LABEL_8:
    v6.errorCode = v4;
    RwErrorSet(&v6);
    return v2;
  }
  v2->numTriangles = 0;
  if ( !bufferSize )
  {
    v2->triangleBufferSize = 0;
    v2->meshTriangles = 0;
    return v2;
  }
  v3 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(12 * bufferSize);
  v2->meshTriangles = (RpBuildMeshTriangle_0 *)v3;
  if ( !v3 )
  {
    (*((void (__fastcall **)(int, RpBuildMesh_0 *))RwEngineInstance + 80))(MeshStatic, v2);
    v2 = 0;
    v6.pluginID = 0;
    v4 = _rwerror(-2147483629, 12 * bufferSize);
    goto LABEL_8;
  }
  v2->triangleBufferSize = bufferSize;
  return v2;
}
// 6BD604: using guessed type int MeshStatic;

//----- (00217FB8) --------------------------------------------------------
RwBool __fastcall _rpBuildMeshDestroy(RpBuildMesh_0 *mesh)
{
  if ( mesh->meshTriangles )
  {
    (*((void (**)(void))RwEngineInstance + 76))();
    mesh->meshTriangles = 0;
  }
  (*((void (__fastcall **)(int, RpBuildMesh_0 *))RwEngineInstance + 80))(MeshStatic, mesh);
  return 1;
}
// 6BD604: using guessed type int MeshStatic;

//----- (00217FFC) --------------------------------------------------------
RwBool __fastcall _rpMeshDestroy(RpMeshHeader_0 *mesh)
{
  RwUInt32 flags; // r0
  bool v3; // zf
  u_native indexBuffer; // r0
  bool v6; // zf

  flags = mesh->flags;
  v3 = flags == 0;
  if ( !flags )
    v3 = mesh->numMeshes == 0;
  if ( !v3 )
    goto LABEL_4;
  v6 = mesh->serialNum == 0;
  if ( !mesh->serialNum )
    v6 = mesh->totalIndicesInMesh == 0;
  if ( !v6 || mesh->firstMeshOffset )
  {
LABEL_4:
    indexBuffer = mesh->indexBuffer;
    if ( indexBuffer )
    {
      emu_ArraysDelete(indexBuffer);
      mesh->indexBuffer = 0;
    }
    (*((void (__fastcall **)(RpMeshHeader_0 *))RwEngineInstance + 76))(mesh);
  }
  return 1;
}

//----- (00218048) --------------------------------------------------------
RpBuildMesh_0 *__fastcall _rpBuildMeshAddTriangle(
        RpBuildMesh_0 *mesh,
        RpMaterial_0 *material,
        RwInt32 vert1,
        RwInt32 vert2,
        RwInt32 vert3)
{
  RpBuildMesh_0 *v5; // r4
  __int64 v7; // r0
  RwUInt16 v8; // r8
  RwUInt16 v9; // r6
  int v10; // r9
  RwError_0 v12; // [sp+0h] [bp-20h] BYREF

  v5 = mesh;
  v7 = *(_QWORD *)&mesh->triangleBufferSize;
  v8 = vert2;
  v9 = vert1;
  if ( HIDWORD(v7) >= (unsigned int)v7 )
  {
    v10 = 12 * HIDWORD(v7) + 12;
    if ( HIDWORD(v7) )
    {
      LODWORD(v7) = (*((int (__fastcall **)(RpBuildMeshTriangle_0 *, int))RwEngineInstance + 77))(
                      v5->meshTriangles,
                      12 * HIDWORD(v7) + 12);
      if ( (_DWORD)v7 )
      {
LABEL_5:
        HIDWORD(v7) = v5->numTriangles;
        v5->meshTriangles = (RpBuildMeshTriangle_0 *)v7;
        v5->triangleBufferSize = HIDWORD(v7) + 1;
        goto LABEL_6;
      }
    }
    else
    {
      LODWORD(v7) = (*((int (__fastcall **)(int))RwEngineInstance + 75))(v10);
      if ( (_DWORD)v7 )
        goto LABEL_5;
    }
    v5 = 0;
    v12.pluginID = 0;
    v12.errorCode = _rwerror(-2147483629, v10);
    RwErrorSet(&v12);
    return v5;
  }
  LODWORD(v7) = v5->meshTriangles;
LABEL_6:
  *(_DWORD *)(v7 + 12 * HIDWORD(v7) + 8) = material;
  v5->meshTriangles[v5->numTriangles].vertIndex[0] = v9;
  v5->meshTriangles[v5->numTriangles].vertIndex[1] = v8;
  v5->meshTriangles[v5->numTriangles++].vertIndex[2] = vert3;
  return v5;
}

//----- (00218104) --------------------------------------------------------
RpMeshHeader_0 *__fastcall _rpMeshHeaderForAllMeshes(
        RpMeshHeader_0 *meshHeader,
        RpMeshCallBack fpCallBack,
        void *pData)
{
  int numMeshes; // r0
  int v7; // r6
  RpMesh_0 *v8; // r4

  numMeshes = meshHeader->numMeshes;
  if ( numMeshes )
  {
    v7 = -numMeshes;
    v8 = (RpMesh_0 *)((char *)&meshHeader[1] + meshHeader->firstMeshOffset);
    do
    {
      if ( !(int)fpCallBack(v8, meshHeader, pData) )
        break;
      ++v7;
      ++v8;
    }
    while ( v7 );
  }
  return meshHeader;
}

//----- (0021813A) --------------------------------------------------------
RwStream_0 *__fastcall _rpMeshWrite(
        const RpMeshHeader_0 *meshHeader,
        const void *object,
        RwStream_0 *stream,
        const RpMaterialList_0 *matList)
{
  RwStream_0 *v5; // r4
  int numMeshes; // r0
  const RpMeshHeader_0 *i; // r8
  __int64 v8; // r0
  RwInt32 MaterialIndex; // r0
  int v10; // r0
  bool v11; // zf
  RwInt32 *flags; // r6
  unsigned int v13; // r11
  unsigned int v14; // r10
  unsigned int j; // r0
  unsigned int v16; // r1
  bool v17; // cf
  RwInt32 *v18; // r12
  uint32x4_t *v19; // r2
  RwStream_0 *v20; // lr
  int v21; // r3
  RwInt32 v22; // r4
  RwInt32 v23; // r1
  RwInt32 v24; // t1
  int v27; // [sp+8h] [bp-440h]
  RwInt32 v29[256]; // [sp+18h] [bp-430h] BYREF
  RwInt32 v30[2]; // [sp+418h] [bp-30h] BYREF
  RwInt32 ints[10]; // [sp+420h] [bp-28h] BYREF

  v5 = stream;
  ints[0] = meshHeader->flags;
  ints[1] = meshHeader->numMeshes;
  ints[2] = meshHeader->totalIndicesInMesh;
  if ( !RwStreamWriteInt32(stream, ints, 0xCu) )
    return 0;
  numMeshes = meshHeader->numMeshes;
  if ( meshHeader->numMeshes )
  {
    for ( i = meshHeader + 1; ; i = (const RpMeshHeader_0 *)((char *)i + 16) )
    {
      v27 = numMeshes;
      v8 = *(_QWORD *)&i->numMeshes;
      v30[0] = *(_DWORD *)&i->numMeshes;
      MaterialIndex = _rpMaterialListFindMaterialIndex(matList, (const RpMaterial_0 *)HIDWORD(v8));
      if ( MaterialIndex <= 0 )
        MaterialIndex = 0;
      v30[1] = MaterialIndex;
      if ( !RwStreamWriteInt32(v5, v30, 8u) )
        return 0;
      v10 = *(unsigned __int8 *)object;
      if ( v10 != 8 )
      {
        v11 = v10 == 7;
        if ( v10 == 7 )
          v11 = *((unsigned __int8 *)object + 11) << 31 == 0;
        if ( !v11 )
          goto LABEL_35;
        v13 = *(_DWORD *)&i->numMeshes;
        flags = (RwInt32 *)i->flags;
        if ( !v13 )
          goto LABEL_35;
        goto LABEL_16;
      }
      v13 = *(_DWORD *)&i->numMeshes;
      flags = (RwInt32 *)i->flags;
      if ( !(*((unsigned __int8 *)object + 11) << 31) )
        break;
      RwStreamWrite(v5, flags, 2 * v13);
LABEL_35:
      numMeshes = v27 - 1;
      if ( v27 == 1 )
        return v5;
    }
    while ( 1 )
    {
      if ( !v13 )
        goto LABEL_35;
LABEL_16:
      v14 = v13;
      if ( v13 >= 0x100 )
        v14 = 256;
      if ( v14 )
      {
        if ( v14 < 4 )
        {
          j = 0;
          goto LABEL_30;
        }
        j = v14 & 0x1FC;
        if ( (v14 & 0x1FC) == 0 )
        {
          for ( j = 0; j < v14; ++j )
          {
LABEL_30:
            v24 = *(unsigned __int16 *)flags;
            flags = (RwInt32 *)((char *)flags + 2);
            v29[j] = v24;
          }
          goto LABEL_31;
        }
        v16 = (unsigned int)flags + 2 * v14;
        v17 = (unsigned int)v29 >= v16;
        if ( (unsigned int)v29 < v16 )
          v17 = flags >= &v29[v14];
        if ( !v17 )
        {
          j = 0;
          goto LABEL_30;
        }
        v18 = (RwInt32 *)((char *)flags + 2 * j);
        v19 = (uint32x4_t *)v29;
        v20 = v5;
        v21 = v14 & 0x1FC;
        do
        {
          v22 = flags[1];
          v21 -= 4;
          v23 = *flags;
          flags += 2;
          *v19++ = vmovl_u16((uint16x4_t)__PAIR64__(v22, v23));
        }
        while ( v21 );
        flags = v18;
        v5 = v20;
        if ( v14 != j )
          goto LABEL_30;
      }
LABEL_31:
      if ( !RwStreamWriteInt32(v5, v29, 4 * v14) )
        return 0;
      v13 -= v14;
    }
  }
  return v5;
}
// 21813A: using guessed type RwInt32 var_430[256];

//----- (0021829C) --------------------------------------------------------
int __fastcall GetMeshPriority(const RpMesh_0 *mesh)
{
  RpMaterial_0 *material; // r0
  int result; // r0
  int alpha; // r1
  int v4; // r1

  material = mesh->material;
  if ( !material )
    return 0;
  if ( material->texture )
  {
    alpha = material->color._anon_0._anon_0.alpha;
    if ( (material->texture->raster->cFormat & 0xF) == 6 )
    {
      result = 3;
      if ( alpha == 255 )
        return 1;
    }
    else
    {
      result = 6;
      if ( alpha == 255 )
        return 5;
    }
  }
  else
  {
    v4 = material->color._anon_0._anon_0.alpha;
    result = 4;
    if ( v4 == 255 )
      return 2;
  }
  return result;
}

//----- (002182DA) --------------------------------------------------------
int __fastcall MeshSorter(const void *a, const void *b)
{
  unsigned __int8 *v2; // r0
  int v3; // r2
  int result; // r0
  int v5; // r2
  unsigned __int8 *v6; // r1
  int v7; // r2
  int v8; // r1
  int v9; // r2
  int v10; // r1
  int v11; // r1

  v2 = (unsigned __int8 *)*((_DWORD *)a + 2);
  if ( v2 )
  {
    if ( *(_DWORD *)v2 )
    {
      v3 = v2[7];
      if ( (*(_BYTE *)(**(_DWORD **)v2 + 34) & 0xF) == 6 )
      {
        result = 3;
        if ( v3 == 255 )
          result = 1;
      }
      else
      {
        result = 6;
        if ( v3 == 255 )
          result = 5;
      }
    }
    else
    {
      v5 = v2[7];
      result = 4;
      if ( v5 == 255 )
        result = 2;
    }
  }
  else
  {
    result = 0;
  }
  v6 = (unsigned __int8 *)*((_DWORD *)b + 2);
  if ( v6 )
  {
    if ( *(_DWORD *)v6 )
    {
      v7 = v6[7];
      if ( (*(_BYTE *)(**(_DWORD **)v6 + 34) & 0xF) == 6 )
      {
        v8 = 3;
        if ( v7 == 255 )
          v8 = 1;
        result -= v8;
      }
      else
      {
        v11 = 6;
        if ( v7 == 255 )
          v11 = 5;
        result -= v11;
      }
    }
    else
    {
      v9 = v6[7];
      v10 = 4;
      if ( v9 == 255 )
        v10 = 2;
      result -= v10;
    }
  }
  return result;
}

//----- (0021835C) --------------------------------------------------------
RpMeshHeader_0 *__fastcall _rpMeshRead(RwStream_0 *stream, const void *object, const RpMaterialList_0 *matList)
{
  int v5; // r0
  int v6; // r1
  int v7; // r4
  RpMeshHeader_0 *result; // r0
  int16x4_t *v9; // r0
  RwInt32 globalsOffset; // r0
  char *v11; // r1
  int v12; // r8
  RwInt32 *v13; // r4
  int16x4_t *v14; // r10
  int16x4_t **v15; // r11
  int16x4_t *v16; // r0
  int16x4_t *v17; // r0
  int v18; // r0
  bool v19; // zf
  unsigned int v20; // r5
  RwInt32 *v21; // lr
  int16x4_t *v22; // r12
  RwInt32 *v23; // r0
  unsigned int v24; // r1
  int32x4_t *v25; // r4
  int v26; // r2
  int32x4_t v27; // q8
  unsigned int v28; // r9
  int v29; // r3
  int v30; // t1
  const void *v31; // [sp+0h] [bp-450h]
  const RpMaterialList_0 *v32; // [sp+4h] [bp-44Ch]
  RpMeshHeader_0 *v33; // [sp+8h] [bp-448h]
  int16x4_t *indexData; // [sp+Ch] [bp-444h]
  int16x4_t **v35; // [sp+10h] [bp-440h]
  int16x4_t *v36; // [sp+14h] [bp-43Ch]
  int v37; // [sp+18h] [bp-438h]
  RwInt32 v39[256]; // [sp+20h] [bp-430h] BYREF
  RwInt32 v40[2]; // [sp+420h] [bp-30h] BYREF
  RwInt32 ints; // [sp+428h] [bp-28h] BYREF
  int v42; // [sp+42Ch] [bp-24h]
  GLuint count; // [sp+430h] [bp-20h]

  if ( !RwStreamReadInt32(stream, &ints, 0xCu) )
    return 0;
  v5 = 20 * v42 + 20;
  if ( *(_BYTE *)object == 8 && *((unsigned __int8 *)object + 11) << 31 )
  {
    v6 = 1;
  }
  else
  {
    v5 += 2 * count;
    v6 = 0;
  }
  v37 = v6;
  v7 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(v5);
  result = 0;
  *(_DWORD *)(v7 + 16) = 0;
  if ( v7 )
  {
    v35 = (int16x4_t **)(v7 + 20);
    if ( v37 == 1 )
      v9 = (int16x4_t *)malloc(2 * count);
    else
      v9 = (int16x4_t *)(v7 + 20 + 16 * v42);
    indexData = v9;
    *(_DWORD *)v7 = ints;
    *(_WORD *)(v7 + 4) = v42;
    globalsOffset = meshModule.globalsOffset;
    v11 = (char *)RwEngineInstance;
    *(_WORD *)(v7 + 6) = *(_WORD *)((char *)RwEngineInstance + meshModule.globalsOffset);
    *(_QWORD *)(v7 + 8) = count;
    ++*(_WORD *)&v11[globalsOffset];
    v33 = (RpMeshHeader_0 *)v7;
    v12 = *(unsigned __int16 *)(v7 + 4);
    if ( !*(_WORD *)(v7 + 4) )
      goto LABEL_39;
    v13 = v40;
    v36 = 0;
    v14 = indexData;
    v15 = v35;
    v31 = object;
    v32 = matList;
    while ( 1 )
    {
      if ( !RwStreamReadInt32(stream, v13, 8u) )
        return 0;
      v15[1] = (int16x4_t *)v40[0];
      v15[2] = (int16x4_t *)_rpMaterialListGetMaterial(matList, v40[1]);
      if ( v37 != 1 )
        break;
      v15[3] = v36;
      v16 = v15[1];
      *v15 = 0;
      RwStreamRead(stream, v14, 2 * (_DWORD)v16);
      v17 = v15[1];
      v36 = (int16x4_t *)((char *)v17 + (_DWORD)v36);
      v14 = (int16x4_t *)((char *)v14 + 2 * (_DWORD)v17);
LABEL_38:
      --v12;
      v15 += 4;
      if ( !v12 )
      {
LABEL_39:
        if ( v37 == 1 )
        {
          qsort(v35, v33->numMeshes, 0x10u, MeshSorter);
          emu_ArraysReset();
          emu_ArraysIndices(indexData, 0x1403u, count);
          v33->indexBuffer = emu_ArraysStore(0, 0);
          free(indexData);
        }
        else
        {
          v33->indexBuffer = 0;
        }
        return v33;
      }
    }
    v15[3] = 0;
    *v15 = v14;
    v18 = *(unsigned __int8 *)object;
    if ( v18 != 8 )
    {
      v19 = v18 == 7;
      if ( v18 == 7 )
        v19 = *((unsigned __int8 *)object + 11) << 31 == 0;
      if ( !v19 )
        goto LABEL_38;
    }
    v20 = (unsigned int)v15[1];
    if ( !v20 )
    {
LABEL_37:
      object = v31;
      matList = v32;
      goto LABEL_38;
    }
    while ( 1 )
    {
      v28 = v20;
      if ( v20 >= 0x100 )
        v28 = 256;
      if ( !RwStreamReadInt32(stream, v39, 4 * v28) )
        return 0;
      v20 -= v28;
      if ( v28 > 3 )
      {
        v29 = v28 & 0x1FC;
        v23 = v39;
        if ( (v28 & 0x1FC) != 0 && (v14 >= (int16x4_t *)&v39[v28] || v39 >= (RwInt32 *)((char *)v14 + 2 * v28)) )
        {
          v21 = v13;
          v22 = (int16x4_t *)((char *)v14 + 2 * v29);
          v23 = &v39[v29];
          v24 = v28 - v29;
          v25 = (int32x4_t *)v39;
          v26 = v28 & 0x1FC;
          do
          {
            v27 = *v25++;
            v26 -= 4;
            v14->n64_u64[0] = vmovn_s32(v27).n64_u64[0];
            ++v14;
          }
          while ( v26 );
          v14 = v22;
          v13 = v21;
          if ( v28 == v29 )
            goto LABEL_36;
          goto LABEL_35;
        }
      }
      else
      {
        v23 = v39;
      }
      v24 = v28;
      do
      {
LABEL_35:
        v30 = *v23++;
        --v24;
        v14->n64_u16[0] = v30;
        v14 = (int16x4_t *)((char *)v14 + 2);
      }
      while ( v24 );
LABEL_36:
      if ( !v20 )
        goto LABEL_37;
    }
  }
  return result;
}
// 21835C: using guessed type RwInt32 var_430[256];

//----- (002185B4) --------------------------------------------------------
RwInt32 __fastcall _rpMeshSize(const RpMeshHeader_0 *meshHeader, const void *object)
{
  int v2; // r2
  int v3; // r1
  RwUInt32 totalIndicesInMesh; // r2
  int v5; // r1

  v2 = *(unsigned __int8 *)object;
  if ( v2 == 7 )
  {
    if ( *((unsigned __int8 *)object + 11) << 31 )
      return 8 * meshHeader->numMeshes + 12;
    v3 = 0;
  }
  else if ( v2 == 8 )
  {
    v3 = *((_BYTE *)object + 11) & 1;
  }
  else
  {
    v3 = 0;
  }
  totalIndicesInMesh = meshHeader->totalIndicesInMesh;
  if ( v3 == 1 )
    v5 = 2 * totalIndicesInMesh;
  else
    v5 = 4 * totalIndicesInMesh;
  return 8 * meshHeader->numMeshes + 12 + v5;
}

//----- (002185F4) --------------------------------------------------------
int _rpMeshGetNextSerialNumber()
{
  int result; // r0

  result = *(__int16 *)((char *)RwEngineInstance + meshModule.globalsOffset);
  *(_WORD *)((char *)RwEngineInstance + meshModule.globalsOffset) = result + 1;
  return result;
}

//----- (00218614) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGenerateTrivialTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  __int64 v2; // kr00_8
  RpMeshHeader_0 *v3; // r4
  RpMeshHeader_0 *v4; // r0
  int v5; // r2
  _WORD *v6; // r1
  int v7; // r3
  __int16 v8; // r6

  v2 = *(_QWORD *)&buildMesh->numTriangles;
  v3 = _rpMeshHeaderCreate(22 * v2 + 20);
  memset(v3, 205, 22 * v2 + 20);
  v3->numMeshes = v2;
  v3->flags = 1;
  v3->serialNum = 0;
  v3->totalIndicesInMesh = 3 * v2;
  v3->firstMeshOffset = 0;
  if ( (int)v2 >= 1 )
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v2) + 4;
    v6 = (_WORD *)((char *)&v3[1] + 16 * v2);
    v7 = v2 + 1;
    do
    {
      v4->flags = (RwUInt32)v6;
      *(_DWORD *)&v4->numMeshes = 3;
      --v7;
      v4->totalIndicesInMesh = *(_DWORD *)(v5 + 4);
      v4 = (RpMeshHeader_0 *)((char *)v4 + 16);
      *v6 = *(_WORD *)(v5 - 4);
      v6[1] = *(_WORD *)(v5 - 2);
      v8 = *(_WORD *)v5;
      v5 += 12;
      v6[2] = v8;
      v6 += 3;
    }
    while ( v7 > 1 );
  }
  return v3;
}

//----- (00218690) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGenerateDefaultTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  return TriStripMeshGenerate(buildMesh, 0, 1);
}

//----- (00218698) --------------------------------------------------------
RpMeshHeader_0 *__fastcall TriStripMeshGenerate(RpBuildMesh_0 *mesh, RwBool preprocess, RwBool maintainWinding)
{
  RpBuildMesh_0 *v3; // r9
  _DWORD *v5; // r0
  int v6; // r3
  size_t v7; // r2
  size_t numTriangles; // r1
  _DWORD *v10; // r4
  unsigned int v11; // r0
  int v12; // r5
  _DWORD *v13; // r6
  int v14; // r2
  unsigned int v15; // r1
  int v16; // r3
  int v17; // r3
  int v18; // r10
  _DWORD *v19; // r0
  int v20; // r8
  int v21; // r2
  unsigned int v22; // r0
  unsigned int v23; // r1
  _DWORD *v24; // r0
  int v25; // r2
  _DWORD *v26; // r5
  int v27; // r3
  RwFreeList_0 *v28; // r0
  int (__fastcall **v29)(int); // r0
  int v30; // r1
  __int64 **v31; // r5
  int v32; // r2
  _DWORD *v33; // r8
  RwUInt32 *v34; // r4
  int v35; // r0
  RwUInt32 v36; // r3
  int v37; // r1
  __int64 *v38; // t1
  __int64 v39; // d16
  RwUInt32 v40; // r0
  TriBinEntry_0 **v41; // r0
  RwUInt32 v42; // r1
  TriBinList_0 **v43; // r5
  TriBinEntry_0 *v44; // r2
  TriBinEntry_0 *head; // r3
  TriStripListEntry_0 *v46; // r11
  int v47; // r4
  TriStripListEntry_0 *v48; // r6
  Edge_0 *v49; // r1
  unsigned int v50; // r11
  TriStripListEntry_0 *v51; // r6
  TriBinEntry_0 *v52; // r5
  TriBinEntry_0 **v53; // r8
  RwUInt32 tri; // r4
  RwUInt16 *v55; // r0
  RpBuildMeshTriangle_0 *v56; // r1
  TriBinEntry_0 *next; // r0
  RwUInt32 v58; // r3
  TriBinList_0 *v59; // r10
  TriBinEntry_0 *v60; // r6
  TriBinEntry_0 *v61; // t1
  Edge_0 *v62; // r0
  TriBinEntry_0 *tri1; // lr
  _BOOL4 v64; // r2
  TriBinEntry_0 *tri2; // r12
  _BOOL4 v66; // r0
  Edge_0 *v67; // r0
  TriBinEntry_0 *v68; // r1
  _BOOL4 v69; // r2
  TriBinEntry_0 *v70; // r0
  _BOOL4 v71; // r0
  int v72; // r4
  RwUInt32 v73; // r6
  Edge_0 *v74; // r0
  TriBinEntry_0 *v75; // r5
  _BOOL4 v76; // r1
  TriBinEntry_0 *v77; // r3
  _BOOL4 v78; // r0
  _BOOL4 v79; // r0
  _BOOL4 v80; // r1
  Edge_0 *v81; // r0
  TriBinEntry_0 *v82; // r6
  _BOOL4 v83; // r4
  TriBinEntry_0 *v84; // r2
  _BOOL4 v85; // r0
  _BOOL4 v86; // r0
  _BOOL4 v87; // r1
  _BOOL4 v88; // r4
  _BOOL4 v89; // r1
  _BOOL4 v90; // r0
  unsigned int v91; // r1
  _BOOL4 v92; // r4
  _BOOL4 v93; // r2
  _BOOL4 v94; // r1
  _BOOL4 v95; // r0
  _BOOL4 v96; // r3
  _BOOL4 v97; // r1
  _BOOL4 v98; // r0
  unsigned int v99; // r1
  _BOOL4 v100; // r2
  unsigned int v101; // r1
  _BOOL4 v102; // r2
  Edge_0 *v103; // r3
  int v104; // r5
  unsigned int v105; // r0
  int i; // r0
  TriBinEntry_0 *v107; // r1
  unsigned int v108; // r9
  TriBinEntry_0 *v109; // r0
  Edge_0 **edge; // r1
  Edge_0 **v111; // r2
  Edge_0 *v112; // r11
  Edge_0 *v113; // r10
  RpBuildMeshTriangle_0 *v114; // r1
  int v115; // r5
  TriBinEntry_0 *v116; // r0
  _BOOL4 v117; // r0
  TriBinEntry_0 *v118; // r1
  RwBool used; // r1
  TriBinEntry_0 *v120; // r1
  int v121; // r1
  unsigned int v122; // r1
  RwUInt32 stripLen; // r0
  int v124; // r1
  RwUInt32 v125; // r0
  RwUInt32 v126; // r1
  int v127; // r0
  int v128; // r0
  unsigned int v129; // r1
  TriStripListEntry_0 *v130; // r6
  RwUInt16 *v131; // r0
  Edge_0 *v132; // r1
  RwFreeList_0 *edgeFreeList; // r4
  Edge_0 *v134; // r5
  RwFreeList_0 *binEntryFreeList; // r4
  RwUInt32 v136; // r3
  TriBinEntry_0 **v137; // r5
  RwUInt32 v138; // r6
  TriStripListEntry_0 *v139; // r4
  int v140; // r0
  RwUInt32 v141; // r1
  unsigned int v142; // r2
  unsigned int v143; // r1
  int v144; // r1
  TriStripListEntry_0 *v145; // r5
  RpBuildMeshTriangle_0 *j; // r6
  int v147; // r5
  bool v148; // zf
  int v149; // r11
  __int64 v150; // r4
  RwUInt32 v151; // r0
  int *v152; // r2
  int v153; // r1
  int v154; // t1
  int v155; // r3
  RpMeshHeader_0 *v156; // r0
  RwInt32 globalsOffset; // r6
  char *v158; // r1
  RwUInt16 v159; // r2
  const void ***v160; // r6
  RpMeshHeader_0 *v161; // r4
  char *v162; // r5
  int v163; // r8
  _DWORD *v164; // [sp+8h] [bp-108h]
  int v165; // [sp+2Ch] [bp-E4h]
  int *v166; // [sp+30h] [bp-E0h]
  int v167; // [sp+34h] [bp-DCh]
  _DWORD *v169; // [sp+58h] [bp-B8h]
  RpBuildMesh_0 *v170; // [sp+5Ch] [bp-B4h]
  _DWORD *v171; // [sp+60h] [bp-B0h]
  int v172; // [sp+68h] [bp-A8h]
  __int64 **v173; // [sp+6Ch] [bp-A4h]
  unsigned int v174; // [sp+70h] [bp-A0h]
  unsigned int v175; // [sp+74h] [bp-9Ch]
  TriStripListEntry_0 *strip; // [sp+78h] [bp-98h]
  int v177; // [sp+84h] [bp-8Ch]
  Edge_0 *v178; // [sp+88h] [bp-88h]
  TriBinEntry_0 **v179; // [sp+8Ch] [bp-84h]
  Edge_0 *v180; // [sp+90h] [bp-80h]
  TriBinList_0 *v181; // [sp+94h] [bp-7Ch]
  TriStripListEntry_0 *v182; // [sp+98h] [bp-78h]
  unsigned int v183; // [sp+9Ch] [bp-74h]
  int v184; // [sp+A0h] [bp-70h]
  TriStripListEntry_0 *v185; // [sp+A4h] [bp-6Ch]
  RwUInt32 v186; // [sp+A8h] [bp-68h]
  int v187; // [sp+ACh] [bp-64h]
  unsigned int v188; // [sp+B0h] [bp-60h]
  RwInt32 currentAttempt; // [sp+B4h] [bp-5Ch]
  RpBuildMeshTriangle_0 *triList; // [sp+B8h] [bp-58h]
  RpMeshHeader_0 *triLista; // [sp+B8h] [bp-58h]
  TriStripList_0 stripList; // [sp+BCh] [bp-54h] BYREF
  MeshOpFreeLists_0 meshOpFreeLists; // [sp+C0h] [bp-50h] BYREF
  TriBinList_0 binListArray[2]; // [sp+C8h] [bp-48h] BYREF
  __int64 v195; // [sp+D0h] [bp-40h]
  Edge_0 *edgelist; // [sp+DCh] [bp-34h] BYREF

  v3 = mesh;
  v5 = (_DWORD *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * mesh->numTriangles);
  if ( !v5 )
    return 0;
  if ( v3->numTriangles )
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v5[v7] = &v3->meshTriangles[v6++];
      numTriangles = v3->numTriangles;
      ++v7;
    }
    while ( v7 < numTriangles );
  }
  else
  {
    numTriangles = 0;
  }
  v10 = v5;
  qsort(v5, numTriangles, 4u, SortPolygons);
  v11 = v3->numTriangles;
  if ( v11 < 2 )
  {
    v12 = 1;
    v13 = v10;
  }
  else
  {
    v12 = 1;
    v13 = v10;
    v14 = *(_DWORD *)(*v10 + 8);
    v15 = 1;
    do
    {
      v16 = v10[v15++];
      v17 = *(_DWORD *)(v16 + 8);
      if ( v17 != v14 )
        ++v12;
      v14 = v17;
    }
    while ( v15 < v11 );
  }
  v164 = v13;
  v18 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v12);
  v19 = (_DWORD *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(16 * v12);
  v20 = 1;
  v21 = *(_DWORD *)(*v13 + 8);
  *v19 = 0;
  v19[1] = 0;
  v169 = v19;
  v19[2] = v21;
  v22 = v3->numTriangles;
  if ( v22 >= 2 )
  {
    v23 = 0;
    while ( v23 < v22 - 1 )
    {
      v26 = &v13[v23++];
      v27 = *(_DWORD *)(v26[1] + 8);
      if ( *(_DWORD *)(*v26 + 8) != v27 )
      {
        v169[4 * v20] = 0;
        v24 = &v169[4 * v20++];
        v25 = *(v24 - 3);
        v24[1] = v23;
        v24[2] = v27;
        *(v24 - 3) = v23 - v25;
        v22 = v3->numTriangles;
      }
    }
  }
  v169[4 * v20 - 3] = v22 - v169[4 * v20 - 3];
  v28 = RwFreeListCreate(16, v3->numTriangles / 0xA + 5, 4);
  LOWORD(v3) = 0;
  *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4) = v28;
  v29 = (int (__fastcall **)(int))RwEngineInstance;
  stripList.head = 0;
  v166 = (int *)v18;
  if ( !v20 )
    goto LABEL_184;
  v30 = 0;
  if ( !preprocess )
    v30 = 3;
  v165 = v30;
  v31 = (__int64 **)v13;
  v3 = 0;
  v167 = v20;
  v32 = 0;
  v185 = 0;
  while ( 2 )
  {
    v172 = v32;
    v33 = &v169[4 * v32];
    v34 = v33 + 1;
    v35 = v29[75](12 * v33[1]);
    triList = (RpBuildMeshTriangle_0 *)v35;
    v171 = v33;
    if ( v33[1] )
    {
      v36 = 0;
      v37 = v35;
      do
      {
        v38 = *v31++;
        ++v36;
        v39 = *v38;
        *(_DWORD *)(v37 + 8) = *((_DWORD *)v38 + 2);
        *(_QWORD *)v37 = v39;
        v37 += 12;
        v40 = *v34;
      }
      while ( v36 < *v34 );
    }
    else
    {
      v40 = 0;
    }
    v186 = v40;
    v173 = v31;
    edgelist = 0;
    *(_QWORD *)&binListArray[0].head = 0LL;
    v195 = 0LL;
    meshOpFreeLists.binEntryFreeList = 0;
    meshOpFreeLists.edgeFreeList = 0;
    v41 = TriStripBinEntryArrayCreate(v40, &meshOpFreeLists, &edgelist, triList);
    v42 = v186;
    if ( v186 )
    {
      v43 = (TriBinList_0 **)v41;
      do
      {
        (*v43)[4].head = (TriBinEntry_0 *)binListArray[LOBYTE((*v43)[8].head)];
        v44 = (TriBinEntry_0 *)*v43;
        head = (*v43)[4].head;
        if ( head )
        {
          head->prev = v44;
          v44 = (TriBinEntry_0 *)*v43;
        }
        ++v43;
        --v42;
        binListArray[v44->adjCount].head = v44;
        v44->prev = 0;
      }
      while ( v42 );
    }
    v179 = v41;
    v46 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
    v47 = 2 * v186 + 2;
    v46->stripLen = 0;
    v46->stripSize = v47;
    v182 = v46;
    v46->strip = (RwUInt16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v47);
    v48 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
    v48->stripLen = 0;
    v48->stripSize = v47;
    strip = v48;
    v48->strip = (RwUInt16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v47);
    if ( !v186 )
      goto LABEL_167;
    v49 = 0;
    v50 = 0;
    v178 = 0;
    do
    {
      v51 = stripList.head;
      v52 = binListArray[0].head;
      v53 = v179;
      v180 = v49;
      v188 = v50 + 1;
      while ( v52 )
      {
        tri = v52->tri;
        v51 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
        v51->stripLen = 3;
        v51->stripSize = 3;
        v51->next = v185;
        v55 = (RwUInt16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(12);
        v51->strip = v55;
        v56 = &triList[tri];
        *v55 = v56->vertIndex[0];
        v51->strip[1] = v56->vertIndex[1];
        v51->strip[2] = v56->vertIndex[2];
        next = v52->next;
        v52->used = 1;
        v52->used2 = 1;
        v52 = next;
        if ( next )
          next->prev = 0;
        v58 = v188++;
        v185 = v51;
        if ( v58 >= v186 )
        {
          stripList.head = v51;
          binListArray[0].head = next;
          goto LABEL_167;
        }
      }
      stripList.head = v51;
      binListArray[0].head = 0;
      v59 = &binListArray[1];
      do
      {
        v61 = v59->head;
        ++v59;
        v60 = v61;
      }
      while ( !v61 );
      v62 = v60->edge[2];
      tri1 = v62->tri1;
      if ( tri1 )
        v64 = tri1->used == 0;
      else
        v64 = 0;
      tri2 = v62->tri2;
      if ( tri2 )
        v66 = tri2->used == 0;
      else
        v66 = 0;
      v170 = v3;
      if ( (unsigned int)(v66 + v64) >= 2 )
      {
        v67 = v60->edge[1];
        v68 = v67->tri1;
        v69 = v68 && v68->used == 0;
        v70 = v67->tri2;
        v71 = v70 && v70->used == 0;
        if ( (unsigned int)(v71 + v69) > 1 )
        {
          v72 = 1;
          v73 = v186;
          goto LABEL_122;
        }
      }
      v74 = v60->edge[0];
      v75 = v74->tri1;
      if ( v75 )
        v76 = v75->used == 0;
      else
        v76 = 0;
      v77 = v74->tri2;
      if ( v77 )
        v78 = v77->used == 0;
      else
        v78 = 0;
      if ( (unsigned int)(v78 + v76) >= 2 )
      {
        if ( tri1 )
        {
          v79 = tri1->used == 0;
          if ( tri2 )
          {
LABEL_68:
            v80 = tri2->used == 0;
            goto LABEL_71;
          }
        }
        else
        {
          v79 = 0;
          if ( tri2 )
            goto LABEL_68;
        }
        v80 = 0;
LABEL_71:
        if ( (unsigned int)(v79 + v80) > 1 )
        {
          v72 = 2;
          v73 = v186;
          goto LABEL_122;
        }
      }
      v81 = v60->edge[1];
      v82 = v81->tri1;
      if ( v82 )
        v83 = v82->used == 0;
      else
        v83 = 0;
      v84 = v81->tri2;
      if ( v84 )
        v85 = v84->used == 0;
      else
        v85 = 0;
      if ( (unsigned int)(v85 + v83) < 2 )
      {
LABEL_87:
        if ( v75 )
        {
          v88 = v75->used == 0;
          if ( v77 )
            goto LABEL_89;
        }
        else
        {
          v88 = 0;
          if ( v77 )
          {
LABEL_89:
            v89 = v77->used == 0;
            if ( v82 )
            {
LABEL_90:
              v90 = v82->used == 0;
              goto LABEL_94;
            }
LABEL_93:
            v90 = 0;
LABEL_94:
            v91 = v89 + v88;
            if ( v84 )
              v92 = v84->used == 0;
            else
              v92 = 0;
            if ( v91 > v90 + v92 )
            {
              if ( v75 )
              {
                v93 = v75->used == 0;
                if ( v77 )
                  goto LABEL_100;
              }
              else
              {
                v93 = 0;
                if ( v77 )
                {
LABEL_100:
                  v94 = v77->used == 0;
                  if ( tri1 )
                  {
LABEL_101:
                    v95 = tri1->used == 0;
                    goto LABEL_109;
                  }
LABEL_108:
                  v95 = 0;
LABEL_109:
                  v99 = v94 + v93;
                  if ( tri2 )
                    v100 = tri2->used == 0;
                  else
                    v100 = 0;
                  v72 = 1;
                  v73 = v186;
                  if ( v99 > v95 + v100 )
                    v72 = 2;
                  goto LABEL_122;
                }
              }
              v94 = 0;
              if ( tri1 )
                goto LABEL_101;
              goto LABEL_108;
            }
            if ( v82 )
            {
              v96 = v82->used == 0;
              if ( v84 )
                goto LABEL_104;
            }
            else
            {
              v96 = 0;
              if ( v84 )
              {
LABEL_104:
                v97 = v84->used == 0;
                if ( tri1 )
                {
LABEL_105:
                  v98 = tri1->used == 0;
LABEL_114:
                  v101 = v97 + v96;
                  if ( tri2 )
                    v102 = tri2->used == 0;
                  else
                    v102 = 0;
                  v73 = v186;
                  v72 = v101 <= v98 + v102;
                  goto LABEL_122;
                }
LABEL_113:
                v98 = 0;
                goto LABEL_114;
              }
            }
            v97 = 0;
            if ( tri1 )
              goto LABEL_105;
            goto LABEL_113;
          }
        }
        v89 = 0;
        if ( v82 )
          goto LABEL_90;
        goto LABEL_93;
      }
      if ( v75 )
      {
        v86 = v75->used == 0;
        if ( !v77 )
          goto LABEL_84;
      }
      else
      {
        v86 = 0;
        if ( !v77 )
        {
LABEL_84:
          v87 = 0;
          goto LABEL_85;
        }
      }
      v87 = v77->used == 0;
LABEL_85:
      if ( (unsigned int)(v86 + v87) <= 1 )
        goto LABEL_87;
      v72 = 0;
      v73 = v186;
LABEL_122:
      v187 = v72;
      v181 = v59;
      v177 = v72;
      v103 = v178;
      v175 = (v72 + 2) % 3u;
      v104 = v165;
      v174 = (v72 + 1) % 3u;
      v105 = 0;
      do
      {
        while ( 1 )
        {
          v183 = v105;
          for ( i = 0; i != v73; ++i )
          {
            v107 = v53[i];
            v107->used2 = v107->used;
          }
          v108 = v72;
          currentAttempt = v104 + 1;
          if ( v104 )
          {
            v108 = v175;
            if ( v104 != 2 )
            {
              v108 = v174;
              if ( v104 != 1 )
                v108 = v187;
            }
          }
          v184 = v104;
          switch ( v108 )
          {
            case 0u:
              v109 = v59[-1].head;
              edge = v109->edge;
              v111 = &v109->edge[1];
              goto LABEL_135;
            case 1u:
              v109 = v59[-1].head;
              edge = &v109->edge[1];
              v111 = &v109->edge[2];
              goto LABEL_135;
            case 2u:
              v109 = v59[-1].head;
              edge = &v109->edge[2];
              v111 = v109->edge;
LABEL_135:
              v112 = *edge;
              v113 = *v111;
              goto LABEL_137;
          }
          v109 = v59[-1].head;
          v112 = v103;
          v113 = v180;
LABEL_137:
          v114 = &triList[v109->tri];
          *v182->strip = v114->vertIndex[v108 % 3];
          v182->strip[1] = v114->vertIndex[(v108 + 1) % 3];
          v182->strip[2] = v114->vertIndex[(v108 + 2) % 3];
          v182->stripLen = 3;
          TriStripMarkTriUsed(v109, binListArray, currentAttempt);
          v115 = TriStripFollow(v182, v113, binListArray, triList, currentAttempt);
          v116 = v112->tri1;
          v103 = v112;
          v180 = v113;
          if ( v184 <= 2 )
            break;
          if ( v116 )
            v117 = v116->used == 0;
          else
            v117 = 0;
          v120 = v112->tri2;
          v53 = v179;
          v59 = v181;
          v72 = v177;
          if ( !v120 )
            goto LABEL_155;
          used = v120->used;
LABEL_148:
          if ( v117 + (used == 0) )
            goto LABEL_156;
LABEL_149:
          v121 = v187;
          v50 = v188 + v115;
          v105 = v183;
          if ( v188 + v115 > v183 )
            v121 = v108;
          v187 = v121;
          if ( v188 + v115 > v183 )
            v105 = v188 + v115;
          v104 = currentAttempt;
          v73 = v186;
          if ( v184 >= 3 )
          {
            v178 = v103;
            v130 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
            v130->next = v185;
            stripList.head = v130;
            v130->stripSize = v182->stripLen;
            v130->stripLen = v182->stripLen;
            v131 = (RwUInt16 *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * v182->stripLen);
            v130->strip = v131;
            qmemcpy(v131, v182->strip, 4 * v182->stripLen);
            goto LABEL_166;
          }
        }
        if ( v116 )
          v117 = v116->used2 == 0;
        else
          v117 = 0;
        v118 = v112->tri2;
        v53 = v179;
        v59 = v181;
        v72 = v177;
        if ( v118 )
        {
          used = v118->used2;
          goto LABEL_148;
        }
LABEL_155:
        if ( !v117 )
          goto LABEL_149;
LABEL_156:
        *strip->strip = v182->strip[1];
        strip->strip[1] = *v182->strip;
        strip->stripLen = 2;
        v178 = v112;
        v122 = v188 + TriStripFollow(strip, v112, binListArray, triList, currentAttempt);
        stripLen = strip->stripLen;
        v50 = v122 + v115;
        if ( (stripLen & 1) != 0 )
        {
          strip->strip[stripLen] = strip->strip[stripLen - 2];
          ++strip->stripLen;
        }
        v105 = v183;
        v124 = v187;
        if ( v50 > v183 )
          v124 = v108;
        v187 = v124;
        if ( v50 > v183 )
          v105 = v50;
        v104 = currentAttempt;
        v103 = v178;
        v73 = v186;
        v59 = v181;
      }
      while ( v184 < 3 );
      v130 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
      v130->next = v185;
      stripList.head = v130;
      v125 = strip->stripLen;
      v126 = v182->stripLen;
      v130->stripLen = 0;
      v127 = v125 + v126 - 2;
      v130->stripSize = v127;
      v128 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v127);
      v130->strip = (RwUInt16 *)v128;
      v129 = strip->stripLen;
      if ( v129 >= 3 )
      {
        do
        {
          *(_WORD *)(v128 + 2 * v130->stripLen++) = strip->strip[v129 - 1];
          v129 = strip->stripLen - 1;
          strip->stripLen = v129;
          v128 = (int)v130->strip;
        }
        while ( v129 > 2 );
      }
      qmemcpy((void *)(v128 + 2 * v130->stripLen), v182->strip, 4 * v182->stripLen);
      v130->stripLen = v130->stripSize;
LABEL_166:
      v185 = v130;
      v3 = v170;
      v49 = v180;
    }
    while ( v50 < v186 );
LABEL_167:
    (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(strip->strip);
    strip->strip = 0;
    (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
      strip);
    (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v182->strip);
    v182->strip = 0;
    (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
      v182);
    v132 = edgelist;
    edgeFreeList = meshOpFreeLists.edgeFreeList;
    if ( edgelist )
    {
      do
      {
        v134 = v132->next;
        (*((void (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 80))(edgeFreeList);
        v132 = v134;
      }
      while ( v134 );
    }
    RwFreeListDestroy(edgeFreeList);
    binEntryFreeList = meshOpFreeLists.binEntryFreeList;
    v136 = v186;
    meshOpFreeLists.edgeFreeList = 0;
    if ( v186 )
    {
      v137 = v179;
      do
      {
        v138 = v136;
        (*((void (__fastcall **)(RwFreeList_0 *, TriBinEntry_0 *))RwEngineInstance + 80))(binEntryFreeList, *v137);
        *v137++ = 0;
        v136 = v138 - 1;
      }
      while ( v138 != 1 );
    }
    RwFreeListDestroy(binEntryFreeList);
    (*((void (__fastcall **)(TriBinEntry_0 **))RwEngineInstance + 76))(v179);
    TriStripJoin(&stripList, maintainWinding);
    v139 = stripList.head;
    if ( stripList.head )
    {
      do
      {
        v140 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(2 * v139->stripLen + 16);
        *(_DWORD *)(v140 + 8) = v171[2];
        v141 = v139->stripLen;
        *(_DWORD *)v140 = v140 + 16;
        *(_DWORD *)(v140 + 4) = v141;
        if ( v141 )
        {
          v142 = *(_DWORD *)(v140 + 4);
          *(_WORD *)(v140 + 16) = *v139->strip;
          if ( v142 >= 2 )
          {
            v143 = 1;
            do
            {
              *(_WORD *)(*(_DWORD *)v140 + 2 * v143) = v139->strip[v143];
              ++v143;
            }
            while ( v143 < *(_DWORD *)(v140 + 4) );
          }
        }
        v144 = (unsigned __int16)v3;
        v3 = (RpBuildMesh_0 *)((char *)v3 + 1);
        v166[v144] = v140;
        v139 = v139->next;
      }
      while ( v139 );
      v145 = stripList.head;
      for ( j = triList; stripList.head; v145 = stripList.head )
      {
        stripList.head = v145->next;
        (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v145->strip);
        v145->strip = 0;
        (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
          *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
          v145);
      }
      v185 = v145;
      v147 = v167;
    }
    else
    {
      v147 = v167;
      v185 = 0;
      j = triList;
    }
    (*((void (__fastcall **)(RpBuildMeshTriangle_0 *))RwEngineInstance + 76))(j);
    v29 = (int (__fastcall **)(int))RwEngineInstance;
    v32 = v172 + 1;
    v148 = v172 + 1 == v147;
    v31 = v173;
    if ( !v148 )
      continue;
    break;
  }
LABEL_184:
  RwFreeListDestroy(*(RwFreeList_0 **)((char *)v29 + meshModule.globalsOffset + 4));
  v149 = (unsigned __int16)v3;
  v150 = 0LL;
  *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4) = 0;
  v151 = 20;
  if ( (_WORD)v3 )
  {
    v152 = v166;
    v153 = (unsigned __int16)v3;
    do
    {
      v154 = *v152++;
      --v153;
      v155 = *(_DWORD *)(v154 + 4);
      LODWORD(v150) = v150 + v155;
      v151 += 2 * v155 + 16;
    }
    while ( v153 );
  }
  v156 = _rpMeshHeaderCreate(v151);
  v156->flags = 1;
  v156->numMeshes = (unsigned __int16)v3;
  globalsOffset = meshModule.globalsOffset;
  v158 = (char *)RwEngineInstance;
  v159 = *(_WORD *)((char *)RwEngineInstance + meshModule.globalsOffset);
  *(_QWORD *)&v156->totalIndicesInMesh = v150;
  triLista = v156;
  v156->serialNum = v159;
  ++*(_WORD *)&v158[globalsOffset];
  if ( (_WORD)v3 )
  {
    v160 = (const void ***)v166;
    v161 = v156 + 1;
    v162 = (char *)&v156[1] + 16 * (unsigned __int16)v3;
    do
    {
      v161->flags = (RwUInt32)v162;
      *(_DWORD *)&v161->numMeshes = (*v160)[1];
      v161->totalIndicesInMesh = (RwUInt32)(*v160)[2];
      qmemcpy(v162, **v160, 2 * (_DWORD)(*v160)[1]);
      v163 = *(_DWORD *)&v161->numMeshes;
      (*((void (__fastcall **)(const void **))RwEngineInstance + 76))(*v160);
      v162 += 2 * v163;
      *v160++ = 0;
      v161 = (RpMeshHeader_0 *)((char *)v161 + 16);
      --v149;
    }
    while ( v149 );
  }
  (*((void (__fastcall **)(_DWORD *))RwEngineInstance + 76))(v164);
  (*((void (__fastcall **)(int *))RwEngineInstance + 76))(v166);
  (*((void (__fastcall **)(_DWORD *))RwEngineInstance + 76))(v169);
  return triLista;
}

//----- (00219308) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGenerateDefaultIgnoreWindingTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  return TriStripMeshGenerate(buildMesh, 0, 0);
}

//----- (00219310) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGeneratePreprocessTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  return TriStripMeshGenerate(buildMesh, 1, 1);
}

//----- (00219318) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGeneratePreprocessIgnoreWindingTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  return TriStripMeshGenerate(buildMesh, 1, 0);
}

//----- (00219320) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGenerateExhaustiveTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  RwBool v2; // r2

  return BuildMeshGenerateExhaustiveTriStrip(buildMesh, (char *)&dword_0 + 1, v2);
}
// 219323: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;

//----- (00219324) --------------------------------------------------------
RpMeshHeader_0 *__fastcall BuildMeshGenerateExhaustiveTriStrip(
        RpBuildMesh_0 *buildMesh,
        void *data,
        RwBool maintainWinding)
{
  _DWORD *v4; // r4
  int v5; // r0
  size_t v6; // r2
  size_t numTriangles; // r1
  RwUInt32 v9; // r0
  int v10; // r5
  int v11; // r2
  unsigned int v12; // r1
  int v13; // r3
  int v14; // r3
  int v15; // r9
  _DWORD *v16; // r0
  int v17; // r11
  int v18; // r12
  int v19; // r2
  RwUInt32 v20; // r0
  unsigned int v21; // r1
  _DWORD *v22; // r0
  int v23; // r2
  _DWORD *v24; // r6
  int v25; // r3
  int (__fastcall **v26)(int); // r0
  TriStripListEntry_0 *i; // r6
  int v28; // r2
  RwUInt32 *v29; // r4
  RpBuildMeshTriangle_0 *v30; // r0
  __int64 **v31; // r3
  RwUInt32 v32; // r6
  RpBuildMeshTriangle_0 *v33; // r1
  __int64 *v34; // t1
  __int64 v35; // d16
  RwUInt32 v36; // r10
  RwUInt32 v37; // r6
  TriBinList_0 **v38; // r0
  RwUInt32 v39; // r1
  TriBinEntry_0 *v40; // r2
  TriBinEntry_0 *head; // r3
  TriStripListEntry_0 *v42; // r5
  int v43; // r4
  TriStripListEntry_0 *v44; // r5
  RwUInt32 v45; // r8
  TriStripListEntry_0 *v46; // r5
  int v47; // lr
  TriBinEntry_0 *v48; // r6
  RwUInt32 tri; // r4
  RwUInt16 *v50; // r0
  RpBuildMeshTriangle_0 *v51; // r1
  TriBinEntry_0 *next; // r0
  bool v53; // cf
  RwUInt32 v54; // r6
  TriBinEntry_0 *v55; // r12
  int v56; // r0
  unsigned int v57; // r3
  TriBinEntry_0 *v58; // r11
  unsigned int v59; // r4
  RpBuildMeshTriangle_0 *v60; // r1
  int v61; // r0
  int v62; // r0
  unsigned int v63; // r1
  unsigned int v64; // r0
  Edge_0 *v65; // r2
  TriBinEntry_0 *tri1; // r1
  _BOOL4 v67; // r1
  TriBinEntry_0 *tri2; // r2
  TriBinEntry_0 **v69; // r1
  RwUInt32 v70; // r2
  int v71; // t1
  Edge_0 **edge; // r1
  Edge_0 **v73; // r2
  unsigned __int64 v74; // r0
  int v75; // r9
  TriBinEntry_0 *v76; // r0
  _BOOL4 v77; // r0
  TriBinEntry_0 *v78; // r1
  TriStripListEntry_0 *v79; // r5
  RwUInt16 *v80; // r0
  int v81; // r0
  RwUInt32 stripLen; // r1
  int v83; // r0
  TriStripListEntry_0 *v84; // r9
  RwUInt32 v85; // r1
  RwUInt32 v86; // r0
  int v87; // r0
  int v88; // r0
  unsigned int v89; // r1
  Edge_0 *v90; // r1
  RwFreeList_0 *edgeFreeList; // r4
  Edge_0 *v92; // r5
  RwFreeList_0 *binEntryFreeList; // r4
  TriBinEntry_0 **v94; // r5
  TriStripListEntry_0 *v95; // r4
  int v96; // r0
  RwUInt32 v97; // r1
  unsigned int v98; // r2
  unsigned int v99; // r1
  int v100; // r1
  RwUInt32 v101; // r4
  RwUInt32 v102; // r0
  int *v103; // r2
  int v104; // r1
  int v105; // t1
  int v106; // r3
  RpMeshHeader_0 *v107; // r0
  RwInt32 globalsOffset; // r5
  char *v109; // r1
  RwUInt16 v110; // r2
  const void ***v111; // r6
  RpMeshHeader_0 *v112; // r4
  char *v113; // r5
  int v114; // r8
  _DWORD *v115; // [sp+8h] [bp-F8h]
  int *v116; // [sp+28h] [bp-D8h]
  int v118; // [sp+4Ch] [bp-B4h]
  _DWORD *v119; // [sp+50h] [bp-B0h]
  int v120; // [sp+54h] [bp-ACh]
  _DWORD *v121; // [sp+58h] [bp-A8h]
  int v122; // [sp+5Ch] [bp-A4h]
  __int64 **v123; // [sp+60h] [bp-A0h]
  TriStripListEntry_0 *v124; // [sp+64h] [bp-9Ch]
  int v125; // [sp+74h] [bp-8Ch]
  RwUInt32 v126; // [sp+78h] [bp-88h]
  TriStripListEntry_0 *v127; // [sp+7Ch] [bp-84h]
  Edge_0 *v128; // [sp+80h] [bp-80h]
  TriBinEntry_0 **v129; // [sp+84h] [bp-7Ch]
  TriStripListEntry_0 *strip; // [sp+88h] [bp-78h]
  RpBuildMeshTriangle_0 *triList; // [sp+8Ch] [bp-74h]
  Edge_0 *nextEdge; // [sp+94h] [bp-6Ch]
  TriBinEntry_0 *v133; // [sp+A0h] [bp-60h]
  int v134; // [sp+A4h] [bp-5Ch]
  unsigned int v135; // [sp+A8h] [bp-58h]
  RpMeshHeader_0 *v136; // [sp+A8h] [bp-58h]
  TriStripList_0 stripList; // [sp+ACh] [bp-54h] BYREF
  MeshOpFreeLists_0 meshOpFreeLists; // [sp+B0h] [bp-50h] BYREF
  TriBinList_0 binListArray[2]; // [sp+B8h] [bp-48h] BYREF
  __int64 v140; // [sp+C0h] [bp-40h]
  Edge_0 *edgelist; // [sp+CCh] [bp-34h] BYREF

  v4 = (_DWORD *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * buildMesh->numTriangles);
  if ( !v4 )
    return 0;
  if ( buildMesh->numTriangles )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v4[v6] = &buildMesh->meshTriangles[v5++];
      numTriangles = buildMesh->numTriangles;
      ++v6;
    }
    while ( v6 < numTriangles );
  }
  else
  {
    numTriangles = 0;
  }
  qsort(v4, numTriangles, 4u, SortPolygons);
  v9 = buildMesh->numTriangles;
  if ( v9 < 2 )
  {
    v10 = 1;
  }
  else
  {
    v10 = 1;
    v11 = *(_DWORD *)(*v4 + 8);
    v12 = 1;
    do
    {
      v13 = v4[v12++];
      v14 = *(_DWORD *)(v13 + 8);
      if ( v14 != v11 )
        ++v10;
      v11 = v14;
    }
    while ( v12 < v9 );
  }
  v15 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v10);
  v16 = (_DWORD *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(16 * v10);
  LOWORD(v17) = 0;
  v18 = 1;
  v19 = *(_DWORD *)(*v4 + 8);
  *v16 = 0;
  v16[1] = 0;
  v119 = v16;
  v16[2] = v19;
  v20 = buildMesh->numTriangles;
  if ( v20 >= 2 )
  {
    v21 = 0;
    while ( v21 < v20 - 1 )
    {
      v24 = &v4[v21++];
      v25 = *(_DWORD *)(v24[1] + 8);
      if ( *(_DWORD *)(*v24 + 8) != v25 )
      {
        v119[4 * v18] = 0;
        v22 = &v119[4 * v18++];
        v23 = *(v22 - 3);
        v22[1] = v21;
        v22[2] = v25;
        *(v22 - 3) = v21 - v23;
        v20 = buildMesh->numTriangles;
      }
    }
  }
  v115 = v4;
  v118 = v18;
  v119[4 * v18 - 3] = v20 - v119[4 * v18 - 3];
  *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4) = RwFreeListCreate(
                                                                           16,
                                                                           buildMesh->numTriangles / 0xA + 5,
                                                                           4);
  v26 = (int (__fastcall **)(int))RwEngineInstance;
  stripList.head = 0;
  v116 = (int *)v15;
  if ( v118 )
  {
    i = 0;
    v17 = 0;
    v28 = 0;
    v123 = (__int64 **)v4;
    do
    {
      v122 = v28;
      v121 = &v119[4 * v28];
      v29 = v121 + 1;
      v30 = (RpBuildMeshTriangle_0 *)v26[75](12 * v121[1]);
      triList = v30;
      v127 = i;
      if ( v121[1] )
      {
        v31 = v123;
        v32 = 0;
        v33 = v30;
        do
        {
          v34 = *v31++;
          ++v32;
          v35 = *v34;
          v33->material = (RpMaterial_0 *)*((_DWORD *)v34 + 2);
          *(_QWORD *)v33->vertIndex = v35;
          ++v33;
          v36 = *v29;
        }
        while ( v32 < *v29 );
      }
      else
      {
        v36 = 0;
        v31 = v123;
      }
      v123 = v31;
      edgelist = 0;
      *(_QWORD *)&binListArray[0].head = 0LL;
      v140 = 0LL;
      meshOpFreeLists.binEntryFreeList = 0;
      meshOpFreeLists.edgeFreeList = 0;
      v37 = v36;
      v129 = TriStripBinEntryArrayCreate(v36, &meshOpFreeLists, &edgelist, v30);
      if ( v36 )
      {
        v38 = (TriBinList_0 **)v129;
        v39 = v36;
        do
        {
          (*v38)[4].head = (TriBinEntry_0 *)binListArray[LOBYTE((*v38)[8].head)];
          v40 = (TriBinEntry_0 *)*v38;
          head = (*v38)[4].head;
          if ( head )
          {
            head->prev = v40;
            v40 = (TriBinEntry_0 *)*v38;
          }
          ++v38;
          --v39;
          binListArray[v40->adjCount].head = v40;
          v40->prev = 0;
        }
        while ( v39 );
      }
      v42 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
      v43 = 2 * v36 + 2;
      v42->stripLen = 0;
      v42->stripSize = v43;
      strip = v42;
      v42->strip = (RwUInt16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v43);
      v44 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
      v44->stripLen = 0;
      v44->stripSize = v43;
      v44->strip = (RwUInt16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v43);
      if ( !v36 )
        goto LABEL_83;
      v45 = 0;
      v135 = 0;
      v128 = 0;
      nextEdge = 0;
      v124 = v44;
      do
      {
        v46 = stripList.head;
        v47 = -1431655765;
        v48 = binListArray[0].head;
        v126 = v45 + 1;
        while ( v48 )
        {
          tri = v48->tri;
          v46 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
          v46->stripLen = 3;
          v46->stripSize = 3;
          v46->next = v127;
          v50 = (RwUInt16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(12);
          v46->strip = v50;
          v47 = -1431655765;
          v51 = &triList[tri];
          *v50 = v51->vertIndex[0];
          v46->strip[1] = v51->vertIndex[1];
          v46->strip[2] = v51->vertIndex[2];
          next = v48->next;
          v48->used = 1;
          v48 = next;
          if ( next )
            next->prev = 0;
          v53 = v126++ >= v36;
          v127 = v46;
          if ( v53 )
          {
            stripList.head = v46;
            v37 = v36;
            v44 = v124;
            binListArray[0].head = next;
            goto LABEL_83;
          }
        }
        v54 = v36;
        v55 = 0;
        stripList.head = v46;
        v56 = 1;
        v57 = 0x80000000;
        v120 = v17;
        binListArray[0].head = 0;
        do
        {
          v58 = binListArray[v56].head;
          v125 = v56;
          if ( !v58 )
            goto LABEL_67;
          do
          {
            v59 = 0;
            while ( v59 <= 2 )
            {
              ++v59;
              v64 = v59 - 3 * ((unsigned int)((v59 * (unsigned __int64)(unsigned int)v47) >> 32) >> 1);
              v65 = v58->edge[v64];
              tri1 = v65->tri1;
              if ( tri1 )
                v67 = tri1->used == 0;
              else
                v67 = 0;
              tri2 = v65->tri2;
              if ( tri2 )
              {
                if ( v67 + (tri2->used == 0) )
                  goto LABEL_58;
              }
              else if ( v67 )
              {
LABEL_58:
                v69 = v129;
                v70 = v54;
                v134 = v57;
                do
                {
                  v71 = (int)*v69++;
                  --v70;
                  *(_DWORD *)(v71 + 28) = *(_DWORD *)(v71 + 24);
                }
                while ( v70 );
                edge = v58->edge;
                v73 = &v58->edge[1];
                v133 = v55;
                if ( v59 != 1 )
                {
                  if ( v59 == 3 )
                  {
                    edge = &v58->edge[2];
                    v73 = v58->edge;
                  }
                  else
                  {
                    v73 = &v58->edge[2];
                    edge = &v58->edge[1];
                    if ( v59 != 2 )
                      goto LABEL_44;
                  }
                }
                v128 = *edge;
                nextEdge = *v73;
LABEL_44:
                v60 = &triList[v58->tri];
                *strip->strip = v60->vertIndex[v59
                                             - 1
                                             - 3
                                             * ((unsigned int)(((v59 - 1) * (unsigned __int64)(unsigned int)v47) >> 32) >> 1)];
                strip->strip[1] = v60->vertIndex[v64];
                v54 = v36;
                strip->strip[2] = v60->vertIndex[v59
                                               + 1
                                               - 3
                                               * ((unsigned int)(((v59 + 1) * (unsigned __int64)(unsigned int)v47) >> 32) >> 1)];
                strip->stripLen = 3;
                v58->used2 = 1;
                v61 = TriStripFollow(strip, nextEdge, binListArray, triList, 1);
                v57 = v134;
                v55 = v133;
                v62 = v61 + 1 + v61 + 1 - strip->stripLen;
                LOWORD(v47) = -21845;
                if ( v62 > v134 )
                  v55 = v58;
                v63 = v135;
                if ( v62 > v134 )
                  v63 = v59 - 1;
                HIWORD(v47) = -21846;
                v135 = v63;
                if ( v62 > v134 )
                  v57 = v62;
              }
            }
            v58 = v58->next;
          }
          while ( v58 );
LABEL_67:
          v56 = v125 + 1;
        }
        while ( v125 != 3 );
        if ( v135 <= 2 )
        {
          v128 = v55->edge[v135];
          nextEdge = v55->edge[dword_219D38[v135]];
        }
        v74 = v135 * (unsigned __int64)(unsigned int)v47;
        LODWORD(v74) = &triList[v55->tri];
        *strip->strip = *(_WORD *)(v74 + 2 * (v135 - 3 * (HIDWORD(v74) >> 1)));
        strip->strip[1] = *(_WORD *)(v74
                                   + 2
                                   * (v135
                                    + 1
                                    - 3
                                    * ((unsigned int)(((v135 + 1) * (unsigned __int64)(unsigned int)v47) >> 32) >> 1)));
        strip->strip[2] = *(_WORD *)(v74
                                   + 2
                                   * (v135
                                    + 2
                                    - 3
                                    * ((unsigned int)(((v135 + 2) * (unsigned __int64)(unsigned int)v47) >> 32) >> 1)));
        strip->stripLen = 3;
        TriStripMarkTriUsed(v55, binListArray, 4);
        v75 = TriStripFollow(strip, nextEdge, binListArray, triList, 4);
        v17 = v120;
        v76 = v128->tri1;
        if ( v76 )
          v77 = v76->used == 0;
        else
          v77 = 0;
        v78 = v128->tri2;
        if ( v78 )
        {
          if ( !(v77 + (v78->used == 0)) )
            goto LABEL_75;
LABEL_77:
          *v124->strip = strip->strip[1];
          v124->strip[1] = *strip->strip;
          v124->stripLen = 2;
          v81 = TriStripFollow(v124, v128, binListArray, triList, 4);
          stripLen = v124->stripLen;
          v83 = v81 + v75;
          if ( (stripLen & 1) != 0 )
          {
            v124->strip[stripLen] = v124->strip[stripLen - 2];
            ++v124->stripLen;
          }
          v45 = v83 + v126;
          v84 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
          v84->next = v127;
          stripList.head = v84;
          v85 = strip->stripLen;
          v86 = v124->stripLen;
          v84->stripLen = 0;
          v87 = v86 + v85 - 2;
          v84->stripSize = v87;
          v44 = v124;
          v88 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v87);
          v84->strip = (RwUInt16 *)v88;
          v89 = v124->stripLen;
          v37 = v36;
          if ( v89 >= 3 )
          {
            do
            {
              *(_WORD *)(v88 + 2 * v84->stripLen++) = v124->strip[v89 - 1];
              v89 = v124->stripLen - 1;
              v124->stripLen = v89;
              v88 = (int)v84->strip;
            }
            while ( v89 > 2 );
          }
          qmemcpy((void *)(v88 + 2 * v84->stripLen), strip->strip, 4 * strip->stripLen);
          v84->stripLen = v84->stripSize;
          v127 = v84;
        }
        else
        {
          if ( v77 )
            goto LABEL_77;
LABEL_75:
          v45 = v75 + v126;
          v79 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4));
          v79->next = v127;
          stripList.head = v79;
          v79->stripSize = strip->stripLen;
          v79->stripLen = strip->stripLen;
          v80 = (RwUInt16 *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * strip->stripLen);
          v79->strip = v80;
          qmemcpy(v80, strip->strip, 4 * strip->stripLen);
          v127 = v79;
          v44 = v124;
          v37 = v36;
        }
      }
      while ( v45 < v37 );
LABEL_83:
      (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v44->strip);
      v44->strip = 0;
      (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
        v44);
      (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(strip->strip);
      strip->strip = 0;
      (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
        strip);
      v90 = edgelist;
      edgeFreeList = meshOpFreeLists.edgeFreeList;
      if ( edgelist )
      {
        do
        {
          v92 = v90->next;
          (*((void (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 80))(edgeFreeList);
          v90 = v92;
        }
        while ( v92 );
      }
      RwFreeListDestroy(edgeFreeList);
      binEntryFreeList = meshOpFreeLists.binEntryFreeList;
      meshOpFreeLists.edgeFreeList = 0;
      if ( v37 )
      {
        v94 = v129;
        do
        {
          (*((void (__fastcall **)(RwFreeList_0 *, TriBinEntry_0 *))RwEngineInstance + 80))(binEntryFreeList, *v94);
          *v94++ = 0;
          --v37;
        }
        while ( v37 );
      }
      RwFreeListDestroy(binEntryFreeList);
      (*((void (__fastcall **)(TriBinEntry_0 **))RwEngineInstance + 76))(v129);
      TriStripJoin(&stripList, (RwBool)data);
      v95 = stripList.head;
      if ( stripList.head )
      {
        do
        {
          v96 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(2 * v95->stripLen + 16);
          *(_DWORD *)(v96 + 8) = v121[2];
          v97 = v95->stripLen;
          *(_DWORD *)v96 = v96 + 16;
          *(_DWORD *)(v96 + 4) = v97;
          if ( v97 )
          {
            v98 = *(_DWORD *)(v96 + 4);
            *(_WORD *)(v96 + 16) = *v95->strip;
            if ( v98 >= 2 )
            {
              v99 = 1;
              do
              {
                *(_WORD *)(*(_DWORD *)v96 + 2 * v99) = v95->strip[v99];
                ++v99;
              }
              while ( v99 < *(_DWORD *)(v96 + 4) );
            }
          }
          v100 = (unsigned __int16)v17++;
          v116[v100] = v96;
          v95 = v95->next;
        }
        while ( v95 );
        for ( i = stripList.head; stripList.head; i = stripList.head )
        {
          stripList.head = i->next;
          (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(i->strip);
          i->strip = 0;
          (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
            *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
            i);
        }
      }
      else
      {
        i = 0;
      }
      (*((void (__fastcall **)(RpBuildMeshTriangle_0 *))RwEngineInstance + 76))(triList);
      v26 = (int (__fastcall **)(int))RwEngineInstance;
      v28 = v122 + 1;
    }
    while ( v122 + 1 != v118 );
  }
  RwFreeListDestroy(*(RwFreeList_0 **)((char *)v26 + meshModule.globalsOffset + 4));
  v17 = (unsigned __int16)v17;
  v101 = 0;
  *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4) = 0;
  v102 = 20;
  if ( (_WORD)v17 )
  {
    v103 = v116;
    v104 = (unsigned __int16)v17;
    do
    {
      v105 = *v103++;
      --v104;
      v106 = *(_DWORD *)(v105 + 4);
      v101 += v106;
      v102 += 2 * v106 + 16;
    }
    while ( v104 );
  }
  v107 = _rpMeshHeaderCreate(v102);
  v107->flags = 1;
  v107->numMeshes = v17;
  globalsOffset = meshModule.globalsOffset;
  v109 = (char *)RwEngineInstance;
  v110 = *(_WORD *)((char *)RwEngineInstance + meshModule.globalsOffset);
  v107->totalIndicesInMesh = v101;
  v107->firstMeshOffset = 0;
  v136 = v107;
  v107->serialNum = v110;
  ++*(_WORD *)&v109[globalsOffset];
  if ( (_WORD)v17 )
  {
    v111 = (const void ***)v116;
    v112 = v107 + 1;
    v113 = (char *)&v107[1] + 16 * (unsigned __int16)v17;
    do
    {
      v112->flags = (RwUInt32)v113;
      *(_DWORD *)&v112->numMeshes = (*v111)[1];
      v112->totalIndicesInMesh = (RwUInt32)(*v111)[2];
      qmemcpy(v113, **v111, 2 * (_DWORD)(*v111)[1]);
      v114 = *(_DWORD *)&v112->numMeshes;
      (*((void (__fastcall **)(const void **))RwEngineInstance + 76))(*v111);
      v113 += 2 * v114;
      *v111++ = 0;
      v112 = (RpMeshHeader_0 *)((char *)v112 + 16);
      --v17;
    }
    while ( v17 );
  }
  (*((void (__fastcall **)(_DWORD *))RwEngineInstance + 76))(v115);
  (*((void (__fastcall **)(int *))RwEngineInstance + 76))(v116);
  (*((void (__fastcall **)(_DWORD *))RwEngineInstance + 76))(v119);
  return v136;
}
// 219D38: using guessed type int dword_219D38[3];

//----- (00219D90) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGenerateExhaustiveIgnoreWindingTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  RwBool v2; // r2

  return BuildMeshGenerateExhaustiveTriStrip(buildMesh, 0, v2);
}
// 219D92: variable 'v2' is possibly undefined

//----- (00219D96) --------------------------------------------------------
RwUInt32 __fastcall RpTriStripDefaultCost(RpTriStripPolygon_0 *startPolygon, RwUInt32 testFrame, void *data)
{
  RpTriStripPolygon_0 *poly1; // r4
  unsigned int v4; // r8
  RxVertexIndex *v5; // r9
  RwUInt32 v6; // lr
  RwUInt32 numEdges; // r12
  int v8; // r3
  RpTriStripEdge_0 *v9; // r6
  RpTriStripPolygon_0 **strip; // r5
  bool v11; // zf
  RpTriStripPolygon_0 **p_poly2; // r6
  RpTriStripPolygon_0 *poly2; // t1
  RpTriStripPolygon_0 *v14; // r12
  bool v15; // zf
  int v16; // r3
  RpTriStripEdge_0 *v17; // r6
  RpTriStripPolygon_0 **p_poly1; // r5
  bool v19; // zf
  RpTriStripPolygon_0 **v20; // r6
  RpTriStripPolygon_0 *v21; // t1
  RpTriStripPolygon_0 *v22; // r11
  bool v23; // zf
  unsigned int v24; // r6
  int v25; // lr
  RpTriStripEdge_0 *v26; // r2
  RpTriStripPolygon_0 **v27; // r3
  bool v28; // zf
  RpTriStripPolygon_0 **v29; // r2
  RpTriStripPolygon_0 *v30; // t1
  unsigned int v31; // r2
  unsigned int v32; // r3
  RpTriStripPolygon_0 *v33; // r5
  int v35; // r5
  RpTriStripEdge_0 *v36; // r4
  RwBool v37; // r0
  bool v38; // zf
  RpTriStripPolygon_0 **v39; // r4
  RpTriStripPolygon_0 *v40; // t1
  int v41; // r5
  RwUInt32 v42; // r8
  _DWORD *v43; // r5
  RwUInt32 i; // r4
  RwUInt32 v45; // r10
  RwUInt32 j; // r4
  RwUInt32 v47; // r11
  RwUInt32 k; // r4
  RwUInt32 v49; // r8
  RpTriStripPolygon_0 *v50; // [sp+0h] [bp-34h]
  RpTriStripPolygon_0 *v51; // [sp+4h] [bp-30h]
  int v52; // [sp+Ch] [bp-28h]
  RxVertexIndex *vertIndex; // [sp+10h] [bp-24h]

  startPolygon->testFrame = testFrame;
  numEdges = startPolygon->numEdges;
  if ( !numEdges )
    goto LABEL_37;
  v8 = 0;
  while ( 1 )
  {
    v9 = startPolygon->edges[v8];
    strip = (RpTriStripPolygon_0 **)v9->strip;
    v11 = strip == 0;
    if ( strip )
    {
      strip = &v9->poly1;
      poly1 = v9->poly1;
      v11 = poly1 == 0;
    }
    if ( !v11 )
    {
      poly2 = v9->poly2;
      p_poly2 = &v9->poly2;
      if ( poly2 )
        break;
    }
    if ( ++v8 >= numEdges )
      goto LABEL_37;
  }
  if ( poly1 == startPolygon )
    strip = p_poly2;
  v14 = *strip;
  v15 = *strip == 0;
  if ( *strip )
  {
    v14->testFrame = testFrame;
    v6 = v14->numEdges;
    v15 = v6 == 0;
  }
  if ( v15 )
    goto LABEL_37;
  v16 = 0;
  while ( 1 )
  {
    v17 = v14->edges[v16];
    p_poly1 = (RpTriStripPolygon_0 **)v17->strip;
    v19 = p_poly1 == 0;
    if ( p_poly1 )
    {
      p_poly1 = &v17->poly1;
      poly1 = v17->poly1;
      v19 = poly1 == startPolygon;
    }
    if ( !v19 )
    {
      v21 = v17->poly2;
      v20 = &v17->poly2;
      if ( v21 != startPolygon )
        break;
    }
    if ( ++v16 >= v6 )
      goto LABEL_37;
  }
  if ( poly1 == v14 )
    p_poly1 = v20;
  v22 = *p_poly1;
  v23 = *p_poly1 == 0;
  if ( *p_poly1 )
  {
    v22->testFrame = testFrame;
    v4 = v22->numEdges;
    v23 = v4 == 0;
  }
  if ( v23 )
    goto LABEL_37;
  v24 = 0;
  v25 = 40000;
  do
  {
    v26 = v22->edges[v24];
    v27 = (RpTriStripPolygon_0 **)v26->strip;
    v28 = v27 == 0;
    if ( v27 )
    {
      v27 = &v26->poly1;
      poly1 = v26->poly1;
      v28 = poly1 == v14;
    }
    if ( !v28 )
    {
      v30 = v26->poly2;
      v29 = &v26->poly2;
      if ( v30 != v14 )
        break;
    }
    ++v24;
    v31 = 0;
    v32 = 1;
  }
  while ( v24 < v4 );
  if ( poly1 == v22 )
    v27 = v29;
  v33 = *v27;
  if ( !*v27 )
  {
LABEL_37:
    v31 = 0;
    v32 = 1;
    v25 = 40000;
  }
  else
  {
    v25 = 40000;
    v32 = 1;
    v31 = 0;
    do
    {
      v50 = v14;
      v14 = v22;
      v22 = v33;
      v33->testFrame = testFrame;
      if ( startPolygon->numEdges )
      {
        vertIndex = v33->vertIndex;
        v41 = 0;
        v5 = v50->vertIndex;
        v42 = v50->numEdges;
        v51 = v22;
        while ( 1 )
        {
          v52 = v41;
          if ( v42 )
          {
            v43 = (_DWORD *)startPolygon->vertIndex[v41];
            for ( i = 0; i < v42; ++i )
            {
              v24 = v5[i];
              if ( v43 == (_DWORD *)v24 )
                break;
            }
            if ( i < v42 )
            {
              v45 = v14->numEdges;
              if ( v45 )
              {
                for ( j = 0; j < v45; ++j )
                {
                  v24 = v14->vertIndex[j];
                  if ( startPolygon->vertIndex[v52] == v24 )
                    break;
                }
              }
              else
              {
                j = 0;
              }
              if ( j < v45 )
              {
                v47 = v22->numEdges;
                if ( v47 )
                {
                  for ( k = 0; k < v47; ++k )
                  {
                    v24 = vertIndex[k];
                    if ( startPolygon->vertIndex[v52] == v24 )
                      break;
                  }
                }
                else
                {
                  k = 0;
                }
                v22 = v51;
                if ( k < v45 )
                  break;
              }
            }
          }
          v41 = v52 + 1;
          if ( v52 + 1 >= startPolygon->numEdges )
            goto LABEL_77;
        }
        v25 += 10000;
        v31 = 1;
      }
      else
      {
LABEL_77:
        if ( v31 )
        {
          ++v31;
        }
        else
        {
          ++v32;
          v31 = 0;
        }
      }
      v49 = v22->numEdges;
      if ( !v49 )
        break;
      v35 = 0;
      while ( 1 )
      {
        v36 = v22->edges[v35];
        v37 = v36->strip;
        v38 = v37 == 0;
        if ( v37 )
        {
          v24 = (unsigned int)&v36->poly1;
          v5 = (RxVertexIndex *)v36->poly1;
          v38 = v5 == (RxVertexIndex *)v14;
        }
        if ( !v38 )
        {
          v40 = v36->poly2;
          v39 = &v36->poly2;
          if ( v40 != v14 )
            break;
        }
        if ( ++v35 >= v49 )
          goto LABEL_38;
      }
      if ( v5 == (RxVertexIndex *)v22 )
        v24 = (unsigned int)v39;
      startPolygon = v50;
      v33 = *(RpTriStripPolygon_0 **)v24;
    }
    while ( *(_DWORD *)v24 );
  }
LABEL_38:
  if ( v31 > v32 )
    v31 = v32;
  return v31 + v25;
}
// 219DD4: variable 'poly1' is possibly undefined
// 219E14: variable 'v6' is possibly undefined
// 219E62: variable 'v4' is possibly undefined
// 219EBE: variable 'v5' is possibly undefined

//----- (00219FAE) --------------------------------------------------------
RpTriStripPolygon_0 *__fastcall RpTriStripPolygonFollowStrip(RpTriStripPolygon_0 *curr, RpTriStripPolygon_0 *prev)
{
  RpTriStripPolygon_0 **p_poly1; // lr
  RwUInt32 numEdges; // r12
  int v4; // r3
  RpTriStripEdge_0 *v5; // r2
  RpTriStripPolygon_0 *strip; // r4
  bool v7; // zf
  RpTriStripPolygon_0 **p_poly2; // r2
  RpTriStripPolygon_0 *poly2; // t1

  numEdges = curr->numEdges;
  if ( !numEdges )
    return 0;
  v4 = 0;
  while ( 1 )
  {
    v5 = curr->edges[v4];
    strip = (RpTriStripPolygon_0 *)v5->strip;
    v7 = strip == 0;
    if ( strip )
    {
      p_poly1 = &v5->poly1;
      strip = v5->poly1;
      v7 = strip == prev;
    }
    if ( !v7 )
    {
      poly2 = v5->poly2;
      p_poly2 = &v5->poly2;
      if ( poly2 != prev )
        break;
    }
    if ( ++v4 >= numEdges )
      return 0;
  }
  if ( strip == curr )
    p_poly1 = p_poly2;
  return *p_poly1;
}
// 219FEC: variable 'p_poly1' is possibly undefined

//----- (00219FF4) --------------------------------------------------------
RpTriStripMesh_0 *__fastcall RpTriStripMeshTunnel(RpTriStripMesh_0 *mesh, void *data)
{
  int v3; // r0
  unsigned int *v4; // r11
  int v5; // r1
  int (**v6)(void); // r4
  float v7; // s18
  float v8; // s16
  unsigned int v9; // r1
  RwLinkList_0 *next; // r2
  int v11; // r0
  unsigned int v12; // r1
  _DWORD *v13; // r12
  _DWORD *v14; // r2
  int *v15; // r3
  int v16; // r3
  int v17; // r8
  unsigned int v18; // r10
  int v19; // r0
  unsigned int v20; // lr
  unsigned int v21; // r12
  int (**v22)(void); // r9
  int (*v23)(void); // r0
  int v24; // r2
  int (*v25)(void); // r6
  int (***v26)(void); // r5
  bool v27; // zf
  int (***v28)(void); // r6
  int v29; // t1
  int (**v30)(void); // r2
  int (**v31)(void); // r0
  unsigned int v32; // r12
  int v33; // r6
  int (*v34)(void); // r5
  int (***v35)(void); // r2
  bool v36; // zf
  int (***v37)(void); // r5
  int (**v38)(void); // t1
  int v39; // r1
  unsigned int v40; // r0
  int v41; // r2
  unsigned int v42; // r2
  unsigned int v43; // r9
  unsigned int v44; // r8
  int (**v45)(void); // lr
  int (*v46)(void); // r0
  int v47; // r2
  int (*v48)(void); // r6
  int (**v49)(void); // r5
  bool v50; // zf
  int (**v51)(void); // r6
  int v52; // t1
  int (*v53)(void); // r0
  int (*v54)(void); // r2
  unsigned int v55; // r12
  int v56; // r6
  _DWORD *v57; // r5
  int (**v58)(void); // r2
  bool v59; // zf
  int (**v60)(void); // r5
  int (**v61)(void); // t1
  int v62; // r9
  int v63; // r0
  unsigned int v64; // r1
  _DWORD *v65; // r2
  int *v66; // r3
  int v67; // r6
  unsigned int v68; // r3
  unsigned int v69; // r4
  int v70; // r0
  unsigned int v71; // r0
  unsigned int v72; // r1
  int v73; // t1
  unsigned int v74; // r0
  int v75; // r1
  int *v76; // r2
  unsigned int v77; // r9
  int v78; // r4
  unsigned int v79; // r5
  int v80; // r10
  int v81; // r0
  _DWORD *v82; // r6
  int v83; // r1
  bool v84; // zf
  int *v85; // r6
  int v86; // t1
  int v87; // r0
  bool v88; // zf
  int v89; // r6
  int v90; // r8
  unsigned int v91; // r6
  int v92; // r0
  int v93; // r1
  int *v94; // r5
  bool v95; // zf
  int v96; // t1
  unsigned int v97; // r1
  int v98; // r2
  unsigned int v99; // r0
  int v100; // r1
  unsigned int v101; // r0
  RwLLLink *v102; // r1
  RwLLLink *v103; // r3
  RwLLLink **p_prev; // r6
  unsigned int v105; // r2
  int v106; // t1
  RwLLLink v107; // r2
  float numPolygons; // s0
  unsigned int v109; // r0
  RpTriStripMesh_0 *v111; // [sp+0h] [bp-58h]
  unsigned int v112; // [sp+4h] [bp-54h]
  RwLinkList_0 **v113; // [sp+8h] [bp-50h]
  RwLinkList_0 *p_polygonEndList; // [sp+Ch] [bp-4Ch]
  unsigned int v115; // [sp+10h] [bp-48h]
  int v116; // [sp+14h] [bp-44h]
  _DWORD *v117; // [sp+18h] [bp-40h]

  v3 = *((_DWORD *)data + 1);
  if ( v3 )
  {
    v4 = (unsigned int *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(8 * v3 + 20);
    v4[2] = (unsigned int)(v4 + 4);
    v5 = *((_DWORD *)data + 1);
    *v4 = 0;
    v4[1] = 1;
    v4[3] = (unsigned int)&v4[v5 + 4];
    v6 = (int (**)(void))data;
    v115 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(36 * *((_DWORD *)data + 1));
    v7 = 0.0;
    v8 = powf(0.001, *(float *)data);
    v111 = mesh;
    p_polygonEndList = &mesh->polygonEndList;
    do
    {
      v9 = 0;
      next = (RwLinkList_0 *)p_polygonEndList->link.next;
      if ( (RwLinkList_0 *)p_polygonEndList->link.next != p_polygonEndList )
      {
LABEL_4:
        v112 = v9;
        do
        {
          v113 = (RwLinkList_0 **)next;
          *(_DWORD *)v4[3] = next;
          v11 = *(_DWORD *)v4[3];
          if ( *(_DWORD *)(v11 + 24) )
          {
            v12 = 0;
            v13 = (_DWORD *)v115;
            do
            {
              v14 = *(_DWORD **)(v11 + 4 * v12 + 28);
              if ( !v14[7] )
              {
                v15 = v14 + 4;
                if ( v11 == v14[4] )
                  v15 = v14 + 5;
                v16 = *v15;
                if ( v16 )
                {
                  *v13 = v14;
                  v13[1] = v16;
                  v13[2] = 1;
                  v11 = *(_DWORD *)v4[3];
                  v13 += 3;
                }
              }
              ++v12;
            }
            while ( v12 < *(_DWORD *)(v11 + 24) );
            while ( (unsigned int)v13 > v115 )
            {
              v71 = *(v13 - 1);
              v72 = v4[2];
              *v4 = v71;
              v73 = *(v13 - 3);
              v13 -= 3;
              *(_DWORD *)(v72 + 4 * v71 - 4) = v73;
              *(_DWORD *)(v4[3] + 4 * *v4) = v13[1];
              v42 = *v4;
              v62 = *v4 & 1;
              if ( !v62 || **(_DWORD **)(v4[3] + 4 * v42) )
              {
                if ( !v42 )
                  goto LABEL_149;
                v74 = 0;
                do
                {
                  v75 = *(_DWORD *)(v4[2] + 4 * v74++);
                  v76 = (int *)(*(_DWORD *)(v75 + 28) == 0);
                  *(_DWORD *)(v75 + 28) = v76;
                  v20 = *v4;
                }
                while ( v74 < *v4 );
                if ( !v20 )
                {
LABEL_149:
                  v101 = 0;
                  do
                  {
                    v102 = *(RwLLLink **)(v4[3] + 4 * v101);
                    v103 = v102[3].next;
                    if ( v103 )
                    {
                      p_prev = &v102[3].prev;
                      v105 = 0;
                      do
                      {
                        v106 = (int)*p_prev++;
                        if ( *(_DWORD *)(v106 + 28) )
                          ++v105;
                        v103 = (RwLLLink *)((char *)v103 - 1);
                      }
                      while ( v103 );
                    }
                    else
                    {
                      v105 = 0;
                    }
                    if ( v102->next )
                    {
                      if ( v105 >= 2 )
                      {
                        v102->prev->next = v102->next;
                        v102->next->prev = v102->prev;
                        v102->next = 0;
                        v102->prev = 0;
                      }
                    }
                    else if ( v105 <= 1 )
                    {
                      v107.prev = &p_polygonEndList->link;
                      v107.next = p_polygonEndList->link.next;
                      *v102 = v107;
                      p_polygonEndList->link.next->prev = v102;
                      p_polygonEndList->link.next = v102;
                    }
                    ++v101;
                  }
                  while ( v101 <= *v4 );
                  *v4 = 0;
                  next = (RwLinkList_0 *)p_polygonEndList->link.next;
                  v9 = v112 + 1;
                  if ( (RwLinkList_0 *)p_polygonEndList->link.next != p_polygonEndList )
                    goto LABEL_4;
                  goto LABEL_164;
                }
                v116 = v62;
                v117 = v13;
                v77 = 0;
                v21 = v4[3];
                do
                {
                  v78 = *(_DWORD *)(v21 + 4 * (v77 | 1));
                  v79 = *(_DWORD *)(v78 + 24);
                  if ( v79 )
                  {
                    v80 = *(_DWORD *)(v21 + 4 * v77);
                    v81 = 0;
                    while ( 1 )
                    {
                      v82 = *(_DWORD **)(v78 + 4 * v81 + 28);
                      v83 = v82[7];
                      v84 = v83 == 0;
                      if ( v83 )
                      {
                        v76 = v82 + 4;
                        v83 = v82[4];
                        v84 = v83 == v80;
                      }
                      if ( !v84 )
                      {
                        v86 = v82[5];
                        v85 = v82 + 5;
                        if ( v86 != v80 )
                          break;
                      }
                      if ( ++v81 >= v79 )
                        goto LABEL_137;
                    }
                    if ( v83 == v78 )
                      v76 = v85;
                    v87 = *v76;
                    v88 = *v76 == 0;
                    v89 = *v76;
                    if ( *v76 )
                    {
                      v89 = 1;
                      v88 = v80 == v87;
                    }
                    if ( v88 )
                    {
LABEL_136:
                      if ( v89 )
                      {
                        v70 = 0;
                        goto LABEL_140;
                      }
                    }
                    else
                    {
                      while ( 1 )
                      {
                        v90 = v87;
                        v91 = *(_DWORD *)(v87 + 24);
                        if ( !v91 )
                          break;
                        v92 = 0;
                        while ( 1 )
                        {
                          v76 = *(int **)(v90 + 4 * v92 + 28);
                          if ( v76[7] )
                          {
                            v94 = v76 + 4;
                            v93 = v76[4];
                            v95 = v93 == v78;
                            if ( v93 != v78 )
                            {
                              v96 = v76[5];
                              v76 += 5;
                              v95 = v96 == v78;
                            }
                            if ( !v95 )
                              break;
                          }
                          if ( ++v92 >= v91 )
                            goto LABEL_137;
                        }
                        if ( v93 == v90 )
                          v94 = v76;
                        v87 = *v94;
                        v89 = *v94;
                        if ( *v94 )
                        {
                          v89 = 1;
                          v78 = v90;
                          if ( v80 != v87 )
                            continue;
                        }
                        goto LABEL_136;
                      }
                    }
                  }
LABEL_137:
                  v77 += 2;
                }
                while ( v77 < v20 );
                if ( v20 < 2 )
                {
                  v70 = 1;
LABEL_140:
                  v6 = (int (**)(void))data;
                  v97 = 0;
                  v62 = v116;
                  v13 = v117;
                  do
                  {
                    v98 = *(_DWORD *)(v4[2] + 4 * v97++);
                    *(_DWORD *)(v98 + 28) = *(_DWORD *)(v98 + 28) == 0;
                    v42 = *v4;
                  }
                  while ( v97 < *v4 );
                  if ( !v70 )
                    goto LABEL_81;
LABEL_146:
                  if ( v42 )
                  {
                    v99 = 0;
                    do
                    {
                      v100 = *(_DWORD *)(v4[2] + 4 * v99++);
                      *(_DWORD *)(v100 + 28) = *(_DWORD *)(v100 + 28) == 0;
                    }
                    while ( v99 < *v4 );
                  }
                  goto LABEL_149;
                }
                v6 = (int (**)(void))data;
                v17 = 0;
                v18 = 0;
                while ( 1 )
                {
                  v22 = *(int (***)(void))(v21 + 4 * v17);
                  if ( (int (*)(void))_rpTriStripTunnelCost(RpTriStripTunnel *,RpTriStripTunnelData *)::testFrame != v22[12] )
                  {
                    v23 = v22[6];
                    if ( v23 )
                    {
                      v24 = 0;
                      while ( 1 )
                      {
                        v25 = v22[v24 + 7];
                        v26 = (int (***)(void))*((_DWORD *)v25 + 7);
                        v27 = v26 == 0;
                        if ( v26 )
                        {
                          v26 = (int (***)(void))((char *)v25 + 16);
                          v6 = (int (**)(void))*((_DWORD *)v25 + 4);
                          v27 = v6 == 0;
                        }
                        if ( !v27 )
                        {
                          v29 = *((_DWORD *)v25 + 5);
                          v28 = (int (***)(void))((char *)v25 + 20);
                          if ( v29 )
                            break;
                        }
                        if ( ++v24 >= (unsigned int)v23 )
                          goto LABEL_15;
                      }
                      if ( v6 == v22 )
                        v26 = v28;
                      v30 = *v26;
                      if ( !*v26 )
                      {
LABEL_15:
                        v6 = (int (**)(void))data;
                        goto LABEL_16;
                      }
                      v6 = (int (**)(void))data;
                      do
                      {
                        v31 = v30;
                        v32 = (unsigned int)v30[6];
                        if ( !v32 )
                          break;
                        v33 = 0;
                        while ( 1 )
                        {
                          v34 = v31[v33 + 7];
                          v35 = (int (***)(void))*((_DWORD *)v34 + 7);
                          v36 = v35 == 0;
                          if ( v35 )
                          {
                            v35 = (int (***)(void))((char *)v34 + 16);
                            v6 = (int (**)(void))*((_DWORD *)v34 + 4);
                            v36 = v6 == v22;
                          }
                          if ( !v36 )
                          {
                            v38 = (int (**)(void))*((_DWORD *)v34 + 5);
                            v37 = (int (***)(void))((char *)v34 + 20);
                            if ( v38 != v22 )
                              break;
                          }
                          if ( ++v33 >= v32 )
                            goto LABEL_15;
                        }
                        v22 = v31;
                        if ( v6 == v31 )
                          v35 = v37;
                        v6 = (int (**)(void))data;
                        v30 = *v35;
                      }
                      while ( v30 );
                    }
LABEL_16:
                    v19 = v6[2]();
                    v20 = *v4;
                    v18 += v19;
                  }
                  if ( ++v17 > v20 )
                    break;
                  v21 = v4[3];
                }
                v39 = ++_rpTriStripTunnelCost(RpTriStripTunnel *,RpTriStripTunnelData *)::testFrame;
                if ( v20 )
                {
                  v40 = 0;
                  do
                  {
                    v41 = *(_DWORD *)(v4[2] + 4 * v40++);
                    *(_DWORD *)(v41 + 28) = *(_DWORD *)(v41 + 28) == 0;
                    v42 = *v4;
                  }
                  while ( v40 < *v4 );
                }
                else
                {
                  v42 = 0;
                }
                v43 = 0;
                v44 = 0;
                do
                {
                  v45 = *(int (***)(void))(v4[3] + 4 * v43);
                  if ( (int (*)(void))v39 != v45[12] )
                  {
                    v46 = v45[6];
                    if ( v46 )
                    {
                      v47 = 0;
                      while ( 1 )
                      {
                        v48 = v45[v47 + 7];
                        v49 = (int (**)(void))*((_DWORD *)v48 + 7);
                        v50 = v49 == 0;
                        if ( v49 )
                        {
                          v49 = (int (**)(void))((char *)v48 + 16);
                          v6 = (int (**)(void))*((_DWORD *)v48 + 4);
                          v50 = v6 == 0;
                        }
                        if ( !v50 )
                        {
                          v52 = *((_DWORD *)v48 + 5);
                          v51 = (int (**)(void))((char *)v48 + 20);
                          if ( v52 )
                            break;
                        }
                        if ( ++v47 >= (unsigned int)v46 )
                          goto LABEL_59;
                      }
                      if ( v6 == v45 )
                        v49 = v51;
                      v54 = *v49;
                      if ( !*v49 )
                      {
LABEL_59:
                        v53 = *(int (**)(void))(v4[3] + 4 * v43);
LABEL_77:
                        v6 = (int (**)(void))data;
                        goto LABEL_78;
                      }
                      v6 = (int (**)(void))data;
                      do
                      {
                        v53 = v54;
                        v55 = *((_DWORD *)v54 + 6);
                        if ( !v55 )
                          break;
                        v56 = 0;
                        while ( 1 )
                        {
                          v57 = (_DWORD *)*((_DWORD *)v53 + v56 + 7);
                          v58 = (int (**)(void))v57[7];
                          v59 = v58 == 0;
                          if ( v58 )
                          {
                            v6 = (int (**)(void))(v57 + 4);
                            v58 = (int (**)(void))v57[4];
                            v59 = v58 == v45;
                          }
                          if ( !v59 )
                          {
                            v61 = (int (**)(void))v57[5];
                            v60 = (int (**)(void))(v57 + 5);
                            if ( v61 != v45 )
                              break;
                          }
                          if ( ++v56 >= v55 )
                            goto LABEL_77;
                        }
                        v45 = (int (**)(void))v53;
                        if ( v58 == (int (**)(void))v53 )
                          v6 = v60;
                        v54 = *v6;
                        v6 = (int (**)(void))data;
                      }
                      while ( v54 );
                    }
                    else
                    {
                      v53 = *(int (**)(void))(v4[3] + 4 * v43);
                    }
LABEL_78:
                    v44 += ((int (__fastcall *)(int (*)(void)))v6[2])(v53);
                    v42 = *v4;
                    v39 = _rpTriStripTunnelCost(RpTriStripTunnel *,RpTriStripTunnelData *)::testFrame;
                  }
                  ++v43;
                }
                while ( v43 <= v42 );
                _rpTriStripTunnelCost(RpTriStripTunnel *,RpTriStripTunnelData *)::testFrame = v39 + 1;
                v62 = v116;
                v13 = v117;
                if ( v44 > v18 )
                  goto LABEL_146;
              }
LABEL_81:
              if ( v42 < v4[1] )
              {
                v63 = *(_DWORD *)(v4[3] + 4 * v42);
                if ( *(_DWORD *)(v63 + 24) )
                {
                  v64 = 0;
                  do
                  {
                    v65 = *(_DWORD **)(v63 + 4 * v64 + 28);
                    if ( v62 == v65[7] && v65 != *(_DWORD **)(v4[2] + 4 * *v4 - 4) )
                    {
                      v66 = v65 + 4;
                      if ( v63 == v65[4] )
                        v66 = v65 + 5;
                      v67 = *v66;
                      v13[1] = *v66;
                      if ( v67 )
                      {
                        v68 = 0;
                        while ( v67 != *(_DWORD *)(v4[3] + 4 * v68) )
                        {
                          v69 = *v4;
                          if ( ++v68 > *v4 )
                            goto LABEL_94;
                        }
                        v69 = *v4;
LABEL_94:
                        if ( v68 > v69 )
                        {
                          *v13 = v65;
                          v13[2] = v69 + 1;
                          v13 += 3;
                        }
                        v6 = (int (**)(void))data;
                      }
                    }
                    ++v64;
                  }
                  while ( v64 < *(_DWORD *)(v63 + 24) );
                }
              }
            }
          }
          next = *v113;
        }
        while ( *v113 != p_polygonEndList );
        v9 = v112;
      }
LABEL_164:
      numPolygons = (float)v111->numPolygons;
      v109 = v4[1] + 1;
      v4[1] = v109;
      v7 = (float)(v7 * 0.5) + (float)((float)v9 / numPolygons);
    }
    while ( v7 >= v8 && v109 < (unsigned int)v6[1] );
    (*((void (__fastcall **)(unsigned int))RwEngineInstance + 76))(v115);
    (*((void (__fastcall **)(unsigned int *))RwEngineInstance + 76))(v4);
    return v111;
  }
  return mesh;
}
// 683BF8: using guessed type int _rpTriStripTunnelCost(RpTriStripTunnel *,RpTriStripTunnelData *)::testFrame;

//----- (0021A5CC) --------------------------------------------------------
RpTriStripMesh_0 *__fastcall RpTriStripMeshQuick(RpTriStripMesh_0 *mesh, void *data)
{
  RwLinkList_0 *p_polygonUsedList; // r12
  RpTriStripMesh_0 *next; // lr
  int v4; // r2
  int v5; // r1
  RwLLLink *prev; // r3
  RwLinkList_0 *p_edgeFreeList; // r6
  unsigned int i; // r4
  int v9; // r0
  RwLinkList_0 *v10; // r1
  bool v11; // zf
  RwLinkList_0 *v12; // r0
  bool v13; // zf
  RwUInt32 v14; // r11
  RpTriStripPolygon_0 *v15; // r5
  unsigned int v16; // r6
  unsigned int v17; // r10
  unsigned int v18; // r8
  RpTriStripEdge_0 *v19; // r6
  RpTriStripPolygon_0 **p_poly1; // r0
  RpTriStripPolygon_0 *v21; // r1
  unsigned int v22; // r9
  RxVertexIndex *p_vert2; // r0
  int vert1; // r5
  RpTriStripPolygon_0 **p_poly2; // r1
  RpTriStripPolygon_0 *v26; // r4
  bool v27; // zf
  RpTriStripEdge_0 *v28; // r0
  RxVertexIndex *p_vert1; // r1
  int v30; // r4
  unsigned int v31; // r2
  RpTriStripEdge_0 *v32; // r6
  RpTriStripPolygon_0 **v33; // r0
  RpTriStripPolygon_0 *v34; // r5
  bool v35; // zf
  RxVertexIndex *v36; // r0
  RpTriStripPolygon_0 **v37; // r1
  RpTriStripPolygon_0 *v38; // r4
  bool v39; // zf
  RwLLLink_0 inFreeLink; // r0
  RpTriStripEdge_0 *v41; // r0
  RxVertexIndex *v42; // r1
  unsigned int v43; // r0
  RpTriStripEdge_0 *v44; // r4
  int v45; // r1
  _DWORD *v46; // r2
  int *v47; // r3
  bool v48; // zf
  int *v49; // r2
  RpTriStripEdge_0 *v50; // r5
  RpTriStripEdge_0 *v51; // t1
  RpTriStripEdge_0 *v52; // r2
  int v53; // r0
  unsigned int v54; // r12
  int v55; // r1
  _DWORD *v56; // r3
  int *v57; // r6
  bool v58; // zf
  int *v59; // r3
  RpTriStripEdge_0 *v60; // t1
  RpTriStripEdge_0 **v61; // r1
  RpTriStripEdge_0 *v62; // r12
  RpTriStripEdge_0 *v63; // lr
  int j; // r2
  int v65; // r0
  int *v66; // r0
  RpTriStripEdge_0 *v67; // t1
  int v68; // r3
  bool v69; // zf
  int v70; // r4
  int v71; // r5
  int v72; // r0
  int v73; // r1
  int v74; // r6
  bool v75; // zf
  int v76; // r1
  bool v77; // zf
  int v78; // r5
  int k; // r0
  int v80; // r1
  int v81; // r6
  bool v82; // zf
  int v83; // r1
  bool v84; // zf
  int v85; // r0
  int v86; // r5
  int v87; // r1
  int v88; // r6
  bool v89; // zf
  int v90; // r1
  bool v91; // zf
  int v92; // r5
  int v93; // r0
  int v94; // r4
  int v95; // r1
  int v96; // r6
  bool v97; // zf
  int v98; // r1
  bool v99; // zf
  unsigned int v100; // r0
  int v101; // r2
  RpTriStripEdge_0 **v102; // r3
  RpTriStripEdge_0 *v103; // r4
  bool v104; // zf
  RpTriStripEdge_0 *v105; // t1
  RpTriStripEdge_0 *v108; // [sp+14h] [bp-4Ch]
  int v109; // [sp+18h] [bp-48h]
  int v110; // [sp+1Ch] [bp-44h]
  unsigned int v111; // [sp+20h] [bp-40h]
  int v112[2]; // [sp+24h] [bp-3Ch] BYREF
  int v113[2]; // [sp+2Ch] [bp-34h] BYREF
  int v114[2]; // [sp+34h] [bp-2Ch] BYREF
  int v115[9]; // [sp+3Ch] [bp-24h] BYREF

  v112[0] = (int)v112;
  v112[1] = (int)v112;
  v113[0] = (int)v113;
  v113[1] = (int)v113;
  v114[1] = (int)v114;
  v114[0] = (int)v114;
  v115[1] = (int)v115;
  v115[0] = (int)v115;
  p_polygonUsedList = &mesh->polygonUsedList;
  next = (RpTriStripMesh_0 *)mesh->polygonUsedList.link.next;
  if ( next != (RpTriStripMesh_0 *)&mesh->polygonUsedList )
  {
    do
    {
      prev = next->polygonUsedList.link.prev;
      if ( prev )
      {
        p_edgeFreeList = &next[-1].edgeFreeList;
        v4 = 0;
        for ( i = 0; i < (unsigned int)prev; ++i )
        {
          v9 = *((_DWORD *)&next->polygonFreeList.link.next + i);
          v10 = *(RwLinkList_0 **)(v9 + 16);
          v11 = v10 == 0;
          if ( v10 )
            v11 = v10 == p_edgeFreeList;
          if ( !v11 )
            goto LABEL_14;
          v12 = *(RwLinkList_0 **)(v9 + 20);
          v13 = v12 == 0;
          if ( v12 )
            v13 = v12 == p_edgeFreeList;
          if ( !v13 )
LABEL_14:
            ++v4;
        }
      }
      else
      {
        v4 = 0;
      }
      v5 = v112[2 * v4];
      next->polygonUsedList.link.next = (RwLLLink *)&v112[2 * v4];
      next->polygonEndList.link.prev = (RwLLLink *)v5;
      *(_DWORD *)(v112[2 * v4] + 4) = &next->polygonEndList.link.prev;
      v112[2 * v4] = (int)&next->polygonEndList.link.prev;
      next = (RpTriStripMesh_0 *)next->numPolygons;
    }
    while ( next != (RpTriStripMesh_0 *)p_polygonUsedList );
  }
  v14 = 0;
  while ( 1 )
  {
    v30 = v112[0];
    if ( (int *)v112[0] == v112 )
    {
      v30 = v113[0];
      if ( (int *)v113[0] == v113 )
      {
        v30 = v114[0];
        if ( (int *)v114[0] == v114 )
        {
          v30 = v115[0];
          if ( (int *)v115[0] == v115 )
            return mesh;
        }
      }
    }
    v15 = (RpTriStripPolygon_0 *)(v30 - 16);
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v110 = v30 + 12;
    v108 = (RpTriStripEdge_0 *)(v30 - 16);
    v109 = v30;
    do
    {
      v111 = v16;
      v19 = *(RpTriStripEdge_0 **)(v110 + 4 * (v18 % 3));
      p_poly1 = &v19->poly1;
      if ( v19->poly1 == v15 )
        p_poly1 = &v19->poly2;
      v21 = *p_poly1;
      if ( *p_poly1 )
      {
        v22 = 1;
        if ( v21->inFreeLink.next )
        {
          p_vert2 = &v19->vert2;
          if ( v18 < 3 )
            p_vert2 = &v19->vert1;
          if ( !++v14 )
            v14 = 1;
          LOWORD(vert1) = *p_vert2;
          *(_DWORD *)(v30 + 32) = v14;
          while ( 1 )
          {
            v26 = v21;
            v27 = v21 == 0;
            if ( v21 )
              v27 = v14 == v21->testFrame;
            if ( v27 )
              break;
            v21->testFrame = v14;
            v28 = _rpTriStripEdgeFindNext(v19, v21, vert1, v14);
            ++v22;
            v21 = 0;
            if ( v28 )
            {
              p_vert1 = &v19->vert1;
              vert1 = v19->vert1;
              if ( vert1 != v28->vert1 )
              {
                if ( vert1 != v28->vert2 )
                  p_vert1 = &v19->vert2;
                LOWORD(vert1) = *p_vert1;
              }
              v19 = v28;
              p_poly2 = &v28->poly1;
              if ( v26 == v28->poly1 )
                p_poly2 = &v28->poly2;
              v21 = *p_poly2;
            }
          }
          v15 = (RpTriStripPolygon_0 *)v108;
          v30 = v109;
        }
      }
      else
      {
        v22 = 1;
      }
      v16 = v111;
      if ( v22 > v17 )
      {
        v16 = v18;
        v17 = v22;
      }
      ++v18;
    }
    while ( v18 != 6 );
    **(_DWORD **)(v30 + 4) = *(_DWORD *)v30;
    v31 = v16;
    *(_DWORD *)(*(_DWORD *)v30 + 4) = *(_DWORD *)(v30 + 4);
    *(_DWORD *)v30 = 0;
    *(_DWORD *)(v30 + 4) = 0;
    v32 = *(RpTriStripEdge_0 **)(v110 + 4 * (v16 % 3));
    v33 = &v32->poly1;
    if ( v32->poly1 == v15 )
      v33 = &v32->poly2;
    v34 = *v33;
    v35 = *v33 == 0;
    if ( *v33 )
      v35 = v34->inFreeLink.next == 0;
    if ( !v35 )
    {
      v36 = &v32->vert2;
      if ( v31 < 3 )
        v36 = &v32->vert1;
      v18 = *v36;
      while ( 1 )
      {
        v38 = v34;
        v39 = v34 == 0;
        if ( v34 )
          v39 = v34->testFrame == 0;
        if ( v39 )
          break;
        v32->strip = 1;
        v34 = 0;
        inFreeLink = v38->inFreeLink;
        v38->testFrame = 0;
        inFreeLink.prev->next = inFreeLink.next;
        v38->inFreeLink.next->prev = v38->inFreeLink.prev;
        v38->inFreeLink.next = 0;
        v38->inFreeLink.prev = 0;
        v41 = _rpTriStripEdgeFindNext(v32, v38, v18, 0);
        if ( v41 )
        {
          v42 = &v32->vert1;
          v18 = v32->vert1;
          if ( v18 != v41->vert1 )
          {
            if ( v18 != v41->vert2 )
              v42 = &v32->vert2;
            v18 = *v42;
          }
          v32 = v41;
          v38->inEndLink.prev->next = v38->inEndLink.next;
          v38->inEndLink.next->prev = v38->inEndLink.prev;
          v38->inEndLink.next = 0;
          v38->inEndLink.prev = 0;
          v37 = &v41->poly1;
          if ( v38 == v41->poly1 )
            v37 = &v41->poly2;
          v34 = *v37;
        }
      }
    }
    v43 = *(_DWORD *)(v109 + 8);
    if ( v43 )
    {
      v44 = v108;
      v45 = 0;
      while ( 1 )
      {
        v46 = *(_DWORD **)(v110 + 4 * v45);
        v47 = (int *)v46[7];
        v48 = v47 == 0;
        if ( v47 )
        {
          v47 = v46 + 4;
          v32 = (RpTriStripEdge_0 *)v46[4];
          v48 = v32 == 0;
        }
        if ( !v48 )
        {
          v51 = (RpTriStripEdge_0 *)v46[5];
          v49 = v46 + 5;
          v50 = v51;
          if ( v51 )
            break;
        }
        if ( ++v45 >= v43 )
        {
          v52 = 0;
          goto LABEL_91;
        }
      }
      if ( v32 == v108 )
        v47 = v49;
      v53 = *v47;
      if ( *v47 )
      {
        do
        {
          v52 = v44;
          v44 = (RpTriStripEdge_0 *)v53;
          v54 = *(_DWORD *)(v53 + 24);
          if ( !v54 )
            break;
          v55 = 0;
          while ( 1 )
          {
            v56 = *(_DWORD **)(v53 + 4 * v55 + 28);
            v57 = (int *)v56[7];
            v58 = v57 == 0;
            if ( v57 )
            {
              v57 = v56 + 4;
              v50 = (RpTriStripEdge_0 *)v56[4];
              v58 = v50 == v52;
            }
            if ( !v58 )
            {
              v60 = (RpTriStripEdge_0 *)v56[5];
              v59 = v56 + 5;
              if ( v60 != v52 )
                break;
            }
            if ( ++v55 >= v54 )
              goto LABEL_91;
          }
          if ( v50 == (RpTriStripEdge_0 *)v53 )
            v57 = v59;
          v53 = *v57;
        }
        while ( *v57 );
      }
      else
      {
        v52 = 0;
      }
    }
    else
    {
      v52 = 0;
      v44 = v108;
    }
LABEL_91:
    while ( 1 )
    {
      v62 = v52;
      v63 = v44;
      for ( j = 0; j != 3; ++j )
      {
        v65 = *(&v63->strip + j);
        v67 = *(RpTriStripEdge_0 **)(v65 + 16);
        v66 = (int *)(v65 + 16);
        if ( v63 == v67 )
          ++v66;
        v68 = *v66;
        v69 = *v66 == 0;
        if ( *v66 )
        {
          v18 = v68 + 16;
          v66 = *(int **)(v68 + 16);
          v69 = v66 == 0;
        }
        if ( !v69 )
        {
          **(_DWORD **)(v68 + 20) = v66;
          *(_DWORD *)(*(_DWORD *)(v68 + 16) + 4) = *(_DWORD *)(v68 + 20);
          v70 = *(_DWORD *)(v68 + 24);
          *(_DWORD *)(v68 + 16) = 0;
          *(_DWORD *)(v68 + 20) = 0;
          if ( v70 )
          {
            v71 = 0;
            v72 = 0;
            do
            {
              v73 = *(_DWORD *)(v68 + 4 * v71 + 28);
              v74 = *(_DWORD *)(v73 + 16);
              v75 = v74 == 0;
              if ( v74 )
                v75 = v74 == v68;
              if ( !v75 && *(_DWORD *)(v74 + 16) )
                goto LABEL_107;
              v76 = *(_DWORD *)(v73 + 20);
              if ( v76 )
              {
                v77 = v76 == v68;
                if ( v76 != v68 )
                  v77 = *(_DWORD *)(v76 + 16) == 0;
                if ( !v77 )
LABEL_107:
                  ++v72;
              }
              ++v71;
            }
            while ( v70 != v71 );
            v78 = 0;
            *(_DWORD *)v18 = v112[2 * v72];
            for ( k = 0; k != v70; ++k )
            {
              v80 = *(_DWORD *)(v68 + 4 * k + 28);
              v81 = *(_DWORD *)(v80 + 16);
              v82 = v81 == 0;
              if ( v81 )
                v82 = v81 == v68;
              if ( !v82 && *(_DWORD *)(v81 + 16) )
                goto LABEL_118;
              v83 = *(_DWORD *)(v80 + 20);
              if ( v83 )
              {
                v84 = v83 == v68;
                if ( v83 != v68 )
                  v84 = *(_DWORD *)(v83 + 16) == 0;
                if ( !v84 )
LABEL_118:
                  ++v78;
              }
            }
            *(_DWORD *)(v68 + 20) = &v112[2 * v78];
            v85 = 0;
            v86 = 0;
            do
            {
              v87 = *(_DWORD *)(v68 + 4 * v85 + 28);
              v88 = *(_DWORD *)(v87 + 16);
              v89 = v88 == 0;
              if ( v88 )
                v89 = v88 == v68;
              if ( !v89 && *(_DWORD *)(v88 + 16) )
                goto LABEL_129;
              v90 = *(_DWORD *)(v87 + 20);
              if ( v90 )
              {
                v91 = v90 == v68;
                if ( v90 != v68 )
                  v91 = *(_DWORD *)(v90 + 16) == 0;
                if ( !v91 )
LABEL_129:
                  ++v86;
              }
              ++v85;
            }
            while ( v70 != v85 );
          }
          else
          {
            v86 = 0;
            *(_DWORD *)(v68 + 16) = v112[0];
            *(_DWORD *)(v68 + 20) = v112;
          }
          *(_DWORD *)(v112[2 * v86] + 4) = v18;
          v92 = *(_DWORD *)(v68 + 24);
          if ( v92 )
          {
            v93 = 0;
            v94 = 0;
            do
            {
              v95 = *(_DWORD *)(v68 + 4 * v93 + 28);
              v96 = *(_DWORD *)(v95 + 16);
              v97 = v96 == 0;
              if ( v96 )
                v97 = v96 == v68;
              if ( !v97 && *(_DWORD *)(v96 + 16) )
                goto LABEL_143;
              v98 = *(_DWORD *)(v95 + 20);
              if ( v98 )
              {
                v99 = v98 == v68;
                if ( v98 != v68 )
                  v99 = *(_DWORD *)(v98 + 16) == 0;
                if ( !v99 )
LABEL_143:
                  ++v94;
              }
              ++v93;
            }
            while ( v92 != v93 );
          }
          else
          {
            v94 = 0;
          }
          v112[2 * v94] = v18;
        }
      }
      if ( !v62 )
        break;
      v100 = *(_DWORD *)&v62->vert1;
      v52 = 0;
      v44 = v62;
      if ( v100 )
      {
        v101 = 0;
        while ( 1 )
        {
          v102 = (RpTriStripEdge_0 **)*(&v62->strip + v101);
          if ( v102[7] )
          {
            v61 = v102 + 4;
            v103 = v102[4];
            v104 = v103 == v63;
            if ( v103 != v63 )
            {
              v105 = v102[5];
              v102 += 5;
              v104 = v105 == v63;
            }
            if ( !v104 )
              break;
          }
          if ( ++v101 >= v100 )
          {
            v52 = 0;
            v44 = v62;
            goto LABEL_91;
          }
        }
        v11 = v103 == v62;
        v44 = v62;
        if ( v11 )
          v61 = v102;
        v52 = *v61;
      }
    }
  }
}
// 21A96C: conditional instruction was optimized away because r4.4!=0

//----- (0021AA60) --------------------------------------------------------
RpTriStripEdge_0 *__fastcall _rpTriStripEdgeFindNext(
        RpTriStripEdge_0 *edge,
        RpTriStripPolygon_0 *polygon,
        RxVertexIndex otherIndex,
        RwUInt32 testFrame)
{
  RpTriStripEdge_0 *v4; // r12
  int vert1; // r4
  bool v6; // zf
  RpTriStripPolygon_0 **p_poly1; // lr
  RpTriStripPolygon_0 *v8; // lr
  bool v9; // zf
  RpTriStripEdge_0 *v10; // lr
  int v11; // r4
  bool v12; // zf
  RpTriStripEdge_0 *v13; // r4
  int v14; // r5
  bool v15; // zf
  RpTriStripPolygon_0 **v16; // r2
  RpTriStripPolygon_0 *v17; // r2
  bool v18; // zf
  RpTriStripPolygon_0 **v19; // r2
  RpTriStripPolygon_0 *v20; // r2
  bool v21; // zf
  RpTriStripPolygon_0 **v23; // r0
  RpTriStripPolygon_0 *v24; // r0
  bool v25; // zf
  RpTriStripPolygon_0 **p_poly2; // r4
  RpTriStripPolygon_0 *v27; // r4
  RwUInt32 v28; // r5
  bool v29; // zf
  RpTriStripPolygon_0 **v30; // r2
  RpTriStripPolygon_0 *v31; // r2
  RwUInt32 v32; // r5
  bool v33; // zf
  RpTriStripEdge_0 *v34; // r12

  v4 = polygon->edges[0];
  if ( v4 != edge )
  {
    vert1 = v4->vert1;
    v6 = vert1 == otherIndex;
    if ( vert1 != otherIndex )
      v6 = v4->vert2 == otherIndex;
    if ( !v6 )
    {
      p_poly1 = &v4->poly1;
      if ( v4->poly1 == polygon )
        p_poly1 = &v4->poly2;
      v8 = *p_poly1;
      v9 = v8 == 0;
      if ( v8 )
        v9 = v8->testFrame == testFrame;
      if ( !v9 && v8->inFreeLink.next )
        return v4;
    }
  }
  v10 = polygon->edges[1];
  if ( v10 != edge )
  {
    v11 = v10->vert1;
    v12 = v11 == otherIndex;
    if ( v11 != otherIndex )
      v12 = v10->vert2 == otherIndex;
    if ( !v12 )
    {
      p_poly2 = &v10->poly1;
      if ( v10->poly1 == polygon )
        p_poly2 = &v10->poly2;
      v27 = *p_poly2;
      if ( v27 )
      {
        v28 = v27->testFrame;
        v29 = v28 == testFrame;
        if ( v28 != testFrame )
          v29 = v27->inFreeLink.next == 0;
        if ( !v29 )
          return polygon->edges[1];
      }
    }
  }
  v13 = polygon->edges[2];
  if ( v13 != edge )
  {
    v14 = v13->vert1;
    v15 = v14 == otherIndex;
    if ( v14 != otherIndex )
      v15 = v13->vert2 == otherIndex;
    if ( !v15 )
    {
      v30 = &v13->poly1;
      if ( v13->poly1 == polygon )
        v30 = &v13->poly2;
      v31 = *v30;
      if ( v31 )
      {
        v32 = v31->testFrame;
        v33 = v32 == testFrame;
        if ( v32 != testFrame )
          v33 = v31->inFreeLink.next == 0;
        if ( !v33 )
          return polygon->edges[2];
      }
    }
  }
  if ( v4 != edge )
  {
    v16 = &v4->poly1;
    if ( v4->poly1 == polygon )
      v16 = &v4->poly2;
    v17 = *v16;
    v18 = v17 == 0;
    if ( v17 )
      v18 = v17->testFrame == testFrame;
    if ( !v18 && v17->inFreeLink.next )
      return v4;
  }
  if ( v10 != edge )
  {
    v19 = &v10->poly1;
    if ( v10->poly1 == polygon )
      v19 = &v10->poly2;
    v20 = *v19;
    v21 = v20 == 0;
    if ( v20 )
      v21 = v20->testFrame == testFrame;
    if ( !v21 )
    {
      v4 = polygon->edges[1];
      if ( v20->inFreeLink.next )
        return v4;
    }
  }
  if ( v13 == edge )
    return 0;
  v23 = &v13->poly1;
  if ( v13->poly1 == polygon )
    v23 = &v13->poly2;
  v24 = *v23;
  v25 = v24 == 0;
  if ( v24 )
    v25 = v24->testFrame == testFrame;
  if ( v25 )
    return 0;
  v34 = polygon->edges[2];
  if ( !v24->inFreeLink.next )
    return 0;
  return v34;
}

//----- (0021AB90) --------------------------------------------------------
RpMeshHeader_0 *__fastcall RpBuildMeshGenerateTriStrip(RpBuildMesh_0 *buildMesh, void *data)
{
  _DWORD *v4; // r10
  int v5; // r0
  size_t v6; // r2
  size_t numTriangles; // r1
  RwUInt32 v8; // r0
  int v9; // r4
  int v10; // r2
  unsigned int v11; // r1
  int v12; // r3
  int v13; // r3
  RwUInt32 v14; // r0
  void (**v15)(void); // r11
  int v16; // r5
  int v17; // r1
  int v18; // r8
  int v19; // r6
  RwUInt32 v20; // r2
  int v21; // r2
  int v22; // r11
  RpMesh_0 *v23; // r5
  int v24; // r9
  int v25; // r3
  unsigned int v26; // r0
  int v27; // r8
  int v28; // r6
  RwUInt32 numIndices; // r0
  int v30; // r1
  bool v31; // cf
  RwUInt32 v32; // r1
  int v33; // r0
  RpMeshHeader_0 *v34; // r8
  int *v35; // r0
  int v36; // r2
  int v37; // r1
  int v38; // r3
  void (__fastcall *v39)(int); // r1
  int *v40; // r5
  int v41; // t1
  RpTriStripData_0 *v43; // [sp+0h] [bp-28h]
  RpBuildMesh_0 *v44; // [sp+4h] [bp-24h]
  int v45; // [sp+8h] [bp-20h]

  v4 = (_DWORD *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * buildMesh->numTriangles);
  if ( buildMesh->numTriangles )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v4[v6] = &buildMesh->meshTriangles[v5++];
      numTriangles = buildMesh->numTriangles;
      ++v6;
    }
    while ( v6 < numTriangles );
  }
  else
  {
    numTriangles = 0;
  }
  qsort(v4, numTriangles, 4u, SortPolygons);
  v8 = buildMesh->numTriangles;
  if ( v8 < 2 )
  {
    v9 = 1;
  }
  else
  {
    v9 = 1;
    v10 = *(_DWORD *)(*v4 + 8);
    v11 = 1;
    do
    {
      v12 = v4[v11++];
      v13 = *(_DWORD *)(v12 + 8);
      if ( v10 != v13 )
        ++v9;
      v10 = v13;
    }
    while ( v11 < v8 );
  }
  v45 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v9);
  v44 = buildMesh;
  v14 = buildMesh->numTriangles;
  if ( v14 < 2 )
  {
    v18 = 0;
    v17 = 0;
    v21 = 1;
  }
  else
  {
    v15 = (void (**)(void))data;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = v16 + 1;
      if ( *(_DWORD *)(v4[v16] + 8) != *(_DWORD *)(v4[v16 + 1] + 8) )
      {
        *(_DWORD *)(v45 + 4 * v18) = _rpTriStripMeshCreate((RpBuildMeshTriangle_0 **)&v4[v17], v16 - v17 + 1);
        v15[1]();
        ++v18;
        v17 = v16 + 1;
        v14 = v44->numTriangles;
      }
      v20 = v16 + 2;
      ++v16;
    }
    while ( v20 < v14 );
    v21 = v19 + 1;
    data = v15;
  }
  *(_DWORD *)(v45 + 4 * v18) = _rpTriStripMeshCreate((RpBuildMeshTriangle_0 **)&v4[v17], v21 - v17);
  v43 = (RpTriStripData_0 *)data;
  (*((void (**)(void))data + 1))();
  v22 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(16 * v9 + 12 * v44->numTriangles + 20);
  *(_DWORD *)v22 = 1;
  v23 = (RpMesh_0 *)(v22 + 20);
  *(_WORD *)(v22 + 4) = v9;
  v24 = v22 + 20 + 16 * v9;
  *(_WORD *)(v22 + 6) = 0;
  v25 = 0;
  *(_DWORD *)(v22 + 8) = 0;
  *(_DWORD *)(v22 + 12) = 0;
  v26 = v44->numTriangles;
  if ( v26 < 2 )
  {
    v30 = 0;
  }
  else
  {
    v27 = 0;
    v25 = 0;
    do
    {
      if ( *(_DWORD *)(v4[v27] + 8) != *(_DWORD *)(v4[v27 + 1] + 8) )
      {
        v23->indices = (RxVertexIndex *)v24;
        v28 = v25;
        v23->material = *(RpMaterial_0 **)(v4[v27] + 8);
        _rpTriStripMeshCreateOutput(*(RpTriStripMesh_0 **)(v45 + 4 * v25), v23, v43);
        numIndices = v23->numIndices;
        ++v23;
        v25 = v28 + 1;
        *(_DWORD *)(v22 + 8) += numIndices;
        v24 += 2 * numIndices;
        v26 = v44->numTriangles;
      }
      v30 = v27 + 1;
      v31 = v27 + 2 >= v26;
      ++v27;
    }
    while ( !v31 );
  }
  v23->indices = (RxVertexIndex *)v24;
  v23->material = *(RpMaterial_0 **)(v4[v30] + 8);
  _rpTriStripMeshCreateOutput(*(RpTriStripMesh_0 **)(v45 + 4 * v25), v23, v43);
  v32 = v23->numIndices;
  *(_DWORD *)(v22 + 8) += v32;
  v33 = (*((int (__fastcall **)(int, RwUInt32))RwEngineInstance + 77))(v22, v24 + 2 * v32 - v22);
  v34 = (RpMeshHeader_0 *)v33;
  if ( v9 )
  {
    v35 = (int *)(v33 + 20);
    v36 = v9;
    v37 = (int)&v34[1] + 16 * v9;
    do
    {
      v38 = v35[1];
      --v36;
      *v35 = v37;
      v35 += 4;
      v37 += 2 * v38;
    }
    while ( v36 );
    v39 = (void (__fastcall *)(int))*((_DWORD *)RwEngineInstance + 76);
    v40 = (int *)v45;
    do
    {
      v41 = *v40++;
      v39(v41);
      --v9;
      v39 = (void (__fastcall *)(int))*((_DWORD *)RwEngineInstance + 76);
    }
    while ( v9 );
  }
  else
  {
    v39 = (void (__fastcall *)(int))*((_DWORD *)RwEngineInstance + 76);
  }
  v39(v45);
  return v34;
}
// 21ADA2: conditional instruction was optimized away because r4.4!=0

//----- (0021ADF8) --------------------------------------------------------
int __fastcall SortPolygons(const void *pA, const void *pB)
{
  int v2; // r2
  unsigned int **v3; // r0
  unsigned int **v4; // r1
  unsigned int *v6; // r8
  unsigned int v7; // r12
  int v8; // r2
  bool v9; // zf
  int v10; // r3
  unsigned int v11; // lr
  int v12; // r4
  unsigned int *v13; // r10
  unsigned int v14; // r9
  int v15; // r2
  bool v16; // zf
  int v17; // r2
  unsigned int v18; // r6
  int v19; // r0

  v2 = *(_DWORD *)pA;
  v3 = *(unsigned int ***)(*(_DWORD *)pB + 8);
  v4 = *(unsigned int ***)(v2 + 8);
  if ( v4 == v3 )
    return 0;
  if ( !v4 )
  {
    v7 = 0;
    v11 = 0;
    v6 = 0;
    v10 = 0;
    goto LABEL_16;
  }
  v6 = *v4;
  if ( *v4 )
  {
    v7 = *v6;
    v8 = (*(unsigned __int8 *)(*v6 + 34) << 8) & 0xF00;
    if ( v8 == 256 )
      goto LABEL_10;
    v9 = v8 == 1280;
    if ( v8 != 1280 )
      v9 = v8 == 768;
    if ( v9 )
    {
LABEL_10:
      v10 = 16;
      goto LABEL_14;
    }
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  v10 = 0;
LABEL_14:
  v11 = (unsigned int)v4[2];
  if ( *((unsigned __int8 *)v4 + 7) != 255 )
    v10 = 16;
LABEL_16:
  v12 = 0;
  if ( v3 )
  {
    v13 = *v3;
    if ( *v3 )
    {
      v14 = *v13;
      v15 = (*(unsigned __int8 *)(*v13 + 34) << 8) & 0xF00;
      if ( v15 == 256 )
        goto LABEL_23;
      v16 = v15 == 1280;
      if ( v15 != 1280 )
        v16 = v15 == 768;
      if ( v16 )
      {
LABEL_23:
        v17 = 16;
        goto LABEL_27;
      }
    }
    else
    {
      v14 = 0;
      v13 = 0;
    }
    v17 = 0;
LABEL_27:
    v18 = (unsigned int)v3[2];
    if ( *((unsigned __int8 *)v3 + 7) != 255 )
      v17 = 16;
    goto LABEL_29;
  }
  v14 = 0;
  v18 = 0;
  v13 = 0;
  v17 = 0;
LABEL_29:
  if ( v4 > v3 )
    v10 |= 1u;
  if ( v7 > v14 )
    v10 |= 8u;
  if ( v11 > v18 )
    v10 |= 4u;
  if ( v6 > v13 )
    v10 |= 2u;
  if ( v4 < v3 )
    v12 = 1;
  if ( v7 < v14 )
    v12 |= 8u;
  v19 = v12 | v17;
  if ( v11 < v18 )
    v19 |= 4u;
  if ( v6 < v13 )
    v19 |= 2u;
  return v10 - v19;
}

//----- (0021AF08) --------------------------------------------------------
RpTriStripMesh_0 *__fastcall _rpTriStripMeshCreate(RpBuildMeshTriangle_0 **triangles, RwUInt32 numTriangles)
{
  RwUInt32 v2; // r8
  unsigned int v4; // r4
  RwUInt32 v5; // r0
  RpBuildMeshTriangle_0 **v6; // r1
  unsigned __int16 *v7; // t1
  unsigned int v8; // r3
  unsigned int v9; // r6
  unsigned int v10; // r2
  _DWORD *v11; // r0
  RpTriStripMesh_0 *v12; // r0
  int v13; // r6
  RpTriStripMesh_0 *v14; // r3
  int v15; // r0
  int v16; // r1
  int v17; // r2
  bool v18; // zf
  RwLLLink *next; // r0
  __int64 v20; // r0
  int v21; // r1
  int v22; // r5
  unsigned int v23; // r2
  unsigned int v24; // r1
  unsigned int v25; // r11
  unsigned int v26; // r0
  int v27; // r12
  _DWORD *v28; // r1
  _DWORD *v29; // r12
  _DWORD *v30; // t1
  int v31; // r8
  int v32; // r0
  bool v33; // zf
  RwLLLink *prev; // r6
  int v35; // r2
  RwLLLink *v36; // r10
  int v37; // lr
  int v38; // r0
  unsigned int v39; // r2
  int v40; // r4
  __int64 v41; // r0
  RpTriStripMesh_0 *v43; // [sp+4h] [bp-54h]
  int v44; // [sp+8h] [bp-50h]
  RpBuildMeshTriangle_0 **v45; // [sp+Ch] [bp-4Ch]
  RwUInt32 v46; // [sp+10h] [bp-48h]
  RwLinkList_0 *p_polygonUsedList; // [sp+14h] [bp-44h]
  RwLinkList_0 *p_polygonEndList; // [sp+18h] [bp-40h]
  int v49; // [sp+1Ch] [bp-3Ch]
  _DWORD *p_next; // [sp+20h] [bp-38h]
  int v51; // [sp+24h] [bp-34h]
  int *v52; // [sp+28h] [bp-30h]
  int v53; // [sp+2Ch] [bp-2Ch]
  __int16 v54; // [sp+30h] [bp-28h]
  unsigned int v55; // [sp+38h] [bp-20h]

  v2 = numTriangles;
  v4 = 0;
  if ( numTriangles )
  {
    v5 = numTriangles;
    v6 = triangles;
    do
    {
      v7 = (unsigned __int16 *)*v6++;
      v8 = *v7;
      v9 = v7[2];
      v10 = v7[1];
      if ( v4 < v8 )
        v4 = v8;
      if ( v4 < v10 )
        v4 = v10;
      if ( v4 < v9 )
        v4 = v9;
      --v5;
    }
    while ( v5 );
  }
  v51 = (*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(12 * v4);
  if ( v4 )
  {
    v11 = (_DWORD *)(v51 + 4);
    do
    {
      *v11 = v11;
      v11[1] = v11;
      v11 += 3;
      --v4;
    }
    while ( v4 );
  }
  v44 = (*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(36 * v2);
  v12 = (RpTriStripMesh_0 *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(148 * v2 + 44);
  v12->numPolygons = v2;
  v12->polygonEndList.link.next = &v12->polygonEndList.link;
  p_polygonEndList = &v12->polygonEndList;
  v12->polygonEndList.link.prev = &v12->polygonEndList.link;
  v12->polygonUsedList.link.next = &v12->polygonUsedList.link;
  p_polygonUsedList = &v12->polygonUsedList;
  v12->polygonUsedList.link.prev = &v12->polygonUsedList.link;
  v12->polygonFreeList.link.next = &v12->polygonFreeList.link;
  v12->polygonFreeList.link.prev = &v12->polygonFreeList.link;
  v12->edgeUsedList.link.next = &v12->edgeUsedList.link;
  p_next = &v12->edgeUsedList.link.next;
  v12->edgeUsedList.link.prev = &v12->edgeUsedList.link;
  v12->edgeFreeList.link.next = &v12->edgeFreeList.link;
  v43 = v12;
  v12->edgeFreeList.link.prev = &v12->edgeFreeList.link;
  if ( v2 )
  {
    v13 = 0;
    v14 = v12 + 1;
    v53 = (int)&v12[1] + 52 * v2;
    v52 = (int *)v44;
    v45 = triangles;
    v46 = v2;
    do
    {
      v15 = triangles[v13]->vertIndex[0];
      LOWORD(v14->edgeFreeList.link.prev) = v15;
      v16 = triangles[v13]->vertIndex[1];
      HIWORD(v14->edgeFreeList.link.prev) = v16;
      v17 = triangles[v13]->vertIndex[2];
      LOWORD(v14[1].numPolygons) = v17;
      if ( v17 != v15 )
      {
        v18 = v15 == v16;
        if ( v15 != v16 )
          v18 = v16 == v17;
        if ( !v18 )
        {
          v49 = v13;
          next = p_polygonUsedList->link.next;
          v14->polygonUsedList.link.next = &p_polygonUsedList->link;
          v14->polygonEndList.link.prev = next;
          p_polygonUsedList->link.next->prev = (RwLLLink *)&v14->polygonEndList.link.prev;
          p_polygonUsedList->link.next = (RwLLLink *)&v14->polygonEndList.link.prev;
          HIDWORD(v20) = p_polygonEndList;
          LODWORD(v20) = p_polygonEndList->link.next;
          *(_QWORD *)&v14->numPolygons = v20;
          p_polygonEndList->link.next->prev = (RwLLLink *)v14;
          p_polygonEndList->link.next = (RwLLLink *)v14;
          v21 = 0;
          v14[1].polygonEndList.link.next = 0;
          v14->polygonFreeList.link.prev = (RwLLLink *)(&dword_0 + 3);
          do
          {
            v22 = v21;
            while ( 1 )
            {
              v23 = *((unsigned __int16 *)&v14->edgeFreeList.link.prev + v22);
              v55 = v22 + 1;
              v24 = (v22 + 1) % 3u;
              v25 = *((unsigned __int16 *)&v14->edgeFreeList.link.prev + v24);
              v26 = v23;
              if ( v23 > v25 )
                v26 = *((unsigned __int16 *)&v14->edgeFreeList.link.prev + v24);
              v54 = v26;
              v27 = v51 + 12 * v26;
              v30 = *(_DWORD **)(v27 + 4);
              v29 = (_DWORD *)(v27 + 4);
              v28 = v30;
              if ( v23 > v25 )
                v25 = *((unsigned __int16 *)&v14->edgeFreeList.link.prev + v22);
              if ( v28 == v29 )
                break;
              while ( 1 )
              {
                v31 = *(v28 - 1);
                v32 = *(unsigned __int16 *)(v31 + 26);
                v33 = v25 == v32;
                if ( v25 == v32 )
                  v33 = *(_DWORD *)(v31 + 20) == 0;
                if ( v33 )
                {
                  prev = v14->polygonFreeList.link.prev;
                  if ( prev )
                  {
                    v35 = *(_DWORD *)(v31 + 16);
                    v36 = 0;
                    v37 = 0;
                    v38 = v35 + 40;
                    v39 = *(_DWORD *)(v35 + 24);
                    do
                    {
                      if ( v39 )
                      {
                        v40 = 0;
                        while ( *((unsigned __int16 *)&v14->edgeFreeList.link.prev + (_DWORD)v36) != *(unsigned __int16 *)(v38 + 2 * v40) )
                        {
                          if ( ++v40 >= v39 )
                            goto LABEL_41;
                        }
                        ++v37;
                      }
LABEL_41:
                      v36 = (RwLLLink *)((char *)v36 + 1);
                    }
                    while ( v36 != prev );
                    if ( v37 == 2 )
                      break;
                  }
                }
                v28 = (_DWORD *)*v28;
                if ( v28 == v29 )
                  goto LABEL_45;
              }
              *((_DWORD *)&v14->edgeUsedList.link.next + v22) = v31;
              *(_DWORD *)(v31 + 20) = v14;
              ++v22;
              if ( v55 >= 3 )
                goto LABEL_46;
            }
LABEL_45:
            HIDWORD(v41) = p_next;
            LODWORD(v41) = *p_next;
            *(_QWORD *)v53 = v41;
            *(_DWORD *)(*p_next + 4) = v53;
            *p_next = v53;
            *((_DWORD *)&v14->edgeUsedList.link.next + v22) = v53;
            *(_DWORD *)(v53 + 16) = v14;
            *(_DWORD *)(v53 + 20) = 0;
            *(_WORD *)(v53 + 24) = v54;
            *(_WORD *)(v53 + 26) = v25;
            *(_DWORD *)(v53 + 28) = 0;
            *v52 = v53;
            v52[1] = *v29;
            v52[2] = (int)v29;
            *(_DWORD *)(*v29 + 4) = v52 + 1;
            *v29 = v52 + 1;
            v21 = v22 + 1;
            v53 += 32;
            v52 += 3;
          }
          while ( v55 < 3 );
LABEL_46:
          triangles = v45;
          v2 = v46;
          v14 = (RpTriStripMesh_0 *)((char *)v14 + 52);
          v13 = v49;
        }
      }
      ++v13;
    }
    while ( v13 != v2 );
  }
  (*((void (__fastcall **)(int))RwEngineInstance + 76))(v44);
  (*((void (__fastcall **)(int))RwEngineInstance + 76))(v51);
  return v43;
}
// 0: using guessed type int dword_0;

//----- (0021B188) --------------------------------------------------------
void __fastcall _rpTriStripMeshCreateOutput(RpTriStripMesh_0 *inMesh, RpMesh_0 *outMesh, RpTriStripData_0 *data)
{
  RwLinkList_0 *p_polygonEndList; // r9
  int v4; // r11
  RwLinkList_0 *next; // r10
  RxVertexIndex *indices; // r5
  RxVertexIndex v7; // r0
  RwUInt32 numEdges; // r1
  RwUInt32 i; // r0
  unsigned int v10; // r1
  int v11; // r0
  RxVertexIndex v12; // r0
  RpTriStripPolygon_0 *v13; // r2
  RpTriStripPolygon_0 *v14; // r8
  RwUInt32 v15; // r0
  int v16; // r1
  RpTriStripEdge_0 *v17; // r3
  RpTriStripPolygon_0 *poly1; // r5
  RpTriStripPolygon_0 **p_poly1; // r6
  bool v20; // zf
  RpTriStripPolygon_0 *poly2; // t1
  RpTriStripPolygon_0 *v22; // r0
  int v23; // lr
  RwUInt32 v24; // r1
  int v25; // r6
  RxVertexIndex v26; // r10
  int v27; // r10
  int v28; // r11
  RxVertexIndex *vertIndex; // r3
  int v30; // lr
  RxVertexIndex v31; // r8
  RwUInt32 v32; // r0
  int v33; // r2
  int v34; // r9
  int v35; // r12
  int v36; // r5
  int v37; // r4
  RxVertexIndex *v38; // r12
  int v39; // r3
  int v40; // r6
  RxVertexIndex *v41; // r5
  RwUInt32 n; // r0
  unsigned int v43; // r1
  int v44; // r0
  int v45; // r1
  RwUInt32 v46; // r12
  unsigned __int16 v47; // r1
  RpTriStripPolygon_0 *v48; // r0
  RwLinkList_0 *v49; // r8
  RxVertexIndex *v50; // r9
  int v51; // r5
  RwUInt32 v52; // r0
  int v53; // r11
  int v54; // r6
  int v55; // r4
  int v56; // r3
  int v57; // r2
  int v58; // r3
  RxVertexIndex *v59; // r5
  int v60; // r8
  RwUInt32 v61; // r1
  RwUInt32 kk; // r0
  RwUInt32 v63; // r12
  int v64; // r0
  RwUInt32 v65; // r5
  int v66; // r6
  int v67; // r4
  RxVertexIndex *v68; // r0
  int v69; // r5
  RxVertexIndex *v70; // r4
  RxVertexIndex v71; // r8
  RwUInt32 v72; // r1
  RwUInt32 ii; // r0
  unsigned int v74; // r1
  int v75; // r0
  RxVertexIndex *v76; // r0
  int v77; // r5
  RxVertexIndex *v78; // r4
  RwUInt32 v79; // r1
  RwUInt32 jj; // r0
  unsigned int v81; // r1
  int v82; // r0
  unsigned int v83; // r1
  int v84; // r0
  RwUInt32 v85; // r1
  RwUInt32 j; // r2
  int v87; // r0
  int v88; // r0
  int v89; // r0
  RwLLLink_0 *v90; // r1
  RxVertexIndex *v91; // r8
  int v92; // r6
  RwUInt32 v93; // r1
  RwUInt32 k; // r0
  unsigned int v95; // r1
  int v96; // r0
  RwUInt32 v97; // r1
  RwUInt32 m; // r0
  unsigned int v99; // r1
  int v100; // r0
  bool v101; // zf
  RwLLLink_0 *v102; // r6
  RwLinkList_0 *v104; // [sp+14h] [bp-4Ch]
  RpTriStripPolygon_0 *v105; // [sp+18h] [bp-48h]
  RpTriStripPolygon_0 *v106; // [sp+1Ch] [bp-44h]
  RwLinkList_0 *v107; // [sp+20h] [bp-40h]
  RpTriStripPolygon_0 *v108; // [sp+24h] [bp-3Ch]
  RxVertexIndex *v109; // [sp+28h] [bp-38h]
  int v110; // [sp+28h] [bp-38h]
  int v111; // [sp+2Ch] [bp-34h]
  int v112; // [sp+2Ch] [bp-34h]
  RxVertexIndex index3; // [sp+32h] [bp-2Eh] BYREF
  RxVertexIndex index2; // [sp+34h] [bp-2Ch] BYREF
  RxVertexIndex index1; // [sp+36h] [bp-2Ah] BYREF
  RpTriStripPolygon_0 *v116; // [sp+38h] [bp-28h] BYREF
  RpTriStripPolygon_0 *v117; // [sp+3Ch] [bp-24h] BYREF
  RpTriStripPolygon_0 *v118[8]; // [sp+40h] [bp-20h] BYREF

  p_polygonEndList = &inMesh->polygonEndList;
  v118[0] = 0;
  v4 = 0;
  v116 = 0;
  v117 = 0;
  next = &inMesh->polygonEndList;
  indices = outMesh->indices;
  if ( !data->ignoreWinding )
    v4 = 1;
  v104 = &inMesh->polygonEndList;
LABEL_11:
  if ( next != p_polygonEndList )
    goto LABEL_34;
  next = p_polygonEndList;
  do
  {
    next = (RwLinkList_0 *)next->link.next;
    if ( next == p_polygonEndList )
      goto LABEL_29;
    _rpTriStripGetStrip(&next->link, v118, &v117, &v116, &index1, &index2, &index3);
    if ( !v4 )
      break;
    numEdges = v118[0]->numEdges;
    if ( numEdges )
    {
      for ( i = 0; i < numEdges; ++i )
      {
        if ( v118[0]->vertIndex[i] == index1 )
          break;
      }
    }
    else
    {
      i = 0;
    }
    v10 = (i + 1) % numEdges;
    v11 = 2;
    if ( v118[0]->vertIndex[v10] == index2 )
      v11 = 1;
  }
  while ( v11 != v4 );
  if ( v4 )
    v4 ^= 3u;
  if ( indices != outMesh->indices )
  {
    *indices = *(indices - 1);
    indices[1] = index1;
    indices += 2;
  }
  if ( next != p_polygonEndList )
    goto LABEL_34;
LABEL_29:
  next = (RwLinkList_0 *)p_polygonEndList->link.next;
  if ( (RwLinkList_0 *)p_polygonEndList->link.next != p_polygonEndList )
  {
    _rpTriStripGetStrip(&next->link, v118, &v117, &v116, &index1, &index2, &index3);
    if ( indices == outMesh->indices )
    {
      v12 = index1;
    }
    else
    {
      *indices = *(indices - 1);
      v12 = index1;
      indices[1] = index1;
      indices += 2;
    }
    *indices++ = v12;
LABEL_34:
    *indices = index1;
    indices[1] = index2;
    indices[2] = index3;
    indices += 3;
    v13 = v117;
    if ( !v117 )
    {
LABEL_145:
      next->link.prev->next = next->link.next;
      next->link.next->prev = next->link.prev;
      next->link.next = 0;
      next->link.prev = 0;
      next = (RwLinkList_0 *)p_polygonEndList->link.next;
      if ( (RwLinkList_0 *)p_polygonEndList->link.next == p_polygonEndList )
      {
LABEL_158:
        v88 = v4;
        if ( v4 )
          v88 = 1;
        v111 = v88;
        if ( v4 )
        {
          next = (RwLinkList_0 *)p_polygonEndList->link.next;
          if ( (RwLinkList_0 *)p_polygonEndList->link.next != p_polygonEndList )
          {
            while ( 1 )
            {
              _rpTriStripGetStrip(&next->link, v118, &v117, &v116, &index1, &index2, &index3);
              if ( index1 == *(indices - 1) )
                break;
              next = (RwLinkList_0 *)next->link.next;
              if ( next == p_polygonEndList )
                goto LABEL_172;
            }
            *indices++ = index1;
            if ( next != p_polygonEndList )
              goto LABEL_199;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          _rpTriStripGetStrip(&next->link, v118, &v117, &v116, &index1, &index2, &index3);
          if ( index1 == *(indices - 1) )
          {
            if ( !v4 )
              break;
            v85 = v118[0]->numEdges;
            if ( v85 )
            {
              for ( j = 0; j < v85; ++j )
              {
                if ( v118[0]->vertIndex[j] == index1 )
                  break;
              }
            }
            else
            {
              j = 0;
            }
            v87 = 2;
            if ( v118[0]->vertIndex[(j + 1) % v85] == index2 )
              v87 = 1;
            if ( v87 == v4 )
              break;
          }
          next = (RwLinkList_0 *)next->link.next;
          if ( next == p_polygonEndList )
            goto LABEL_158;
        }
        if ( v4 )
          v4 ^= 3u;
        v89 = v4;
        if ( v4 )
          v89 = 1;
        v111 = v89;
        if ( next != p_polygonEndList )
          goto LABEL_199;
      }
LABEL_172:
      v90 = p_polygonEndList->link.next;
      if ( (RwLinkList_0 *)p_polygonEndList->link.next == p_polygonEndList )
      {
LABEL_198:
        next = p_polygonEndList;
        goto LABEL_199;
      }
      v91 = indices;
      v110 = v4 ^ 3;
      while ( 1 )
      {
        next = (RwLinkList_0 *)v90;
        _rpTriStripGetStrip(v90, v118, &v117, &v116, &index1, &index2, &index3);
        if ( index1 == *(indices - 2) )
        {
          if ( v111 != 1 )
          {
            v111 = 0;
LABEL_7:
            *indices++ = index1;
            goto LABEL_199;
          }
          v92 = index2;
          v93 = v118[0]->numEdges;
          if ( v93 )
          {
            for ( k = 0; k < v93; ++k )
            {
              if ( v118[0]->vertIndex[k] == index1 )
                break;
            }
          }
          else
          {
            k = 0;
          }
          v95 = (k + 1) % v93;
          indices = v91;
          v96 = 2;
          if ( v118[0]->vertIndex[v95] == index2 )
            v96 = 1;
          if ( v96 == v110 )
            goto LABEL_7;
        }
        else
        {
          v92 = index2;
        }
        if ( v92 == *(indices - 1) )
        {
          if ( v111 != 1 )
          {
            v111 = 0;
LABEL_9:
            *indices++ = v92;
LABEL_199:
            v101 = v111 == 1;
            if ( v111 == 1 )
              v101 = next == p_polygonEndList;
            if ( v101 )
            {
              v102 = p_polygonEndList->link.next;
              next = p_polygonEndList;
              if ( (RwLinkList_0 *)p_polygonEndList->link.next != p_polygonEndList )
              {
                while ( 1 )
                {
                  _rpTriStripGetStrip(v102, v118, &v117, &v116, &index1, &index2, &index3);
                  if ( index1 == *(indices - 2) )
                    break;
                  if ( index2 == *(indices - 1) )
                  {
                    *indices = index2;
                    v7 = index2;
LABEL_4:
                    indices[1] = v7;
                    indices += 2;
                    v4 ^= 3u;
                    next = (RwLinkList_0 *)v102;
                    goto LABEL_11;
                  }
                  v102 = v102->next;
                  if ( v102 == (RwLLLink_0 *)p_polygonEndList )
                  {
                    next = p_polygonEndList;
                    goto LABEL_11;
                  }
                }
                *indices = index1;
                v7 = index1;
                goto LABEL_4;
              }
            }
            goto LABEL_11;
          }
          v97 = v118[0]->numEdges;
          if ( v97 )
          {
            for ( m = 0; m < v97; ++m )
            {
              if ( v118[0]->vertIndex[m] == index1 )
                break;
            }
          }
          else
          {
            m = 0;
          }
          v99 = (m + 1) % v97;
          indices = v91;
          v100 = 2;
          if ( v118[0]->vertIndex[v99] == v92 )
            v100 = 1;
          if ( v100 == v110 )
            goto LABEL_9;
        }
        v90 = next->link.next;
        if ( (RwLinkList_0 *)next->link.next == p_polygonEndList )
          goto LABEL_198;
      }
    }
    v107 = next;
    while ( 1 )
    {
      v14 = v116;
      v118[0] = v13;
      v117 = v116;
      v109 = indices;
      if ( v116 && (v15 = v116->numEdges) != 0 )
      {
        v16 = 0;
        while ( 1 )
        {
          v17 = v116->edges[v16];
          if ( v17->strip )
          {
            p_poly1 = &v17->poly1;
            poly1 = v17->poly1;
            v20 = poly1 == v13;
            if ( poly1 != v13 )
            {
              poly2 = v17->poly2;
              v17 = (RpTriStripEdge_0 *)((char *)v17 + 20);
              v20 = poly2 == v13;
            }
            if ( !v20 )
              break;
          }
          if ( ++v16 >= v15 )
          {
            v22 = 0;
            goto LABEL_50;
          }
        }
        if ( poly1 == v116 )
          p_poly1 = (RpTriStripPolygon_0 **)v17;
        v22 = *p_poly1;
LABEL_50:
        indices = v109;
      }
      else
      {
        v22 = 0;
      }
      v112 = v4;
      v108 = v22;
      v116 = v22;
      if ( v13->inEndLink.next )
      {
        v13->inEndLink.prev->next = v13->inEndLink.next;
        v13->inEndLink.next->prev = v13->inEndLink.prev;
        v13->inEndLink.next = 0;
        v13->inEndLink.prev = 0;
      }
      v23 = *(indices - 3);
      v24 = v13->numEdges;
      v25 = *(indices - 1);
      v26 = *(indices - 3);
      if ( !v24 )
        goto LABEL_75;
      v105 = v14;
      v27 = *(indices - 3);
      v28 = *(indices - 2);
      vertIndex = v13->vertIndex;
      v30 = 0;
      v31 = *(indices - 3);
      v32 = 0;
      v106 = v13;
      do
      {
        v33 = vertIndex[v32];
        v34 = 0;
        v35 = 0;
        v36 = v30;
        ++v32;
        if ( v33 == v28 )
          v34 = 1;
        if ( v33 == v27 )
          v35 = 1;
        v37 = v35 | v34;
        v38 = vertIndex;
        v39 = v25;
        v40 = (v33 == v25) | v37;
        if ( v33 == v28 )
          v36 = 1;
        v20 = v40 == 0;
        v25 = v39;
        if ( v20 )
          v31 = v33;
        else
          v30 = v36;
        vertIndex = v38;
      }
      while ( v32 < v24 );
      if ( !v30 )
        break;
      p_polygonEndList = v104;
      v41 = v109;
      if ( v112 )
      {
        for ( n = 0; n < v24; ++n )
        {
          if ( v38[n] == v28 )
            break;
        }
        v43 = (n + 1) % v24;
        v44 = 2;
        if ( v106->vertIndex[v43] == v25 )
          v44 = 1;
        v45 = v112;
        if ( v44 == v112 )
        {
          v45 = v112 ^ 3;
        }
        else
        {
          v109[1] = v28;
          *v109 = v28;
          v109[2] = v25;
          v41 = v109 + 3;
        }
        v4 = v45;
        *v41 = v31;
        indices = v41 + 1;
      }
      else
      {
        v4 = 0;
        *v109 = v31;
        indices = v109 + 1;
      }
LABEL_144:
      v13 = v117;
      next = v107;
      if ( !v117 )
        goto LABEL_145;
    }
    v23 = v27;
    v26 = v31;
    p_polygonEndList = v104;
    indices = v109;
    v14 = v105;
LABEL_75:
    v4 = v112;
    if ( !v14 )
      goto LABEL_89;
    v46 = v14->numEdges;
    v47 = v23;
    if ( !v46 )
      goto LABEL_211;
    v48 = v14;
    v49 = p_polygonEndList;
    v50 = v48->vertIndex;
    v51 = 0;
    v47 = v23;
    v52 = 0;
    v53 = v25;
    do
    {
      v54 = v50[v52];
      v55 = 0;
      v56 = 0;
      v57 = v51;
      ++v52;
      if ( v54 == v53 )
        v55 = 1;
      if ( v54 == v23 )
        v56 = 1;
      v58 = v56 | v55 | (v54 == v26);
      if ( v54 == v53 )
        v57 = 1;
      if ( v58 )
        v51 = v57;
      else
        v47 = v54;
    }
    while ( v52 < v46 );
    v20 = v51 == 0;
    v25 = v53;
    indices = v109;
    p_polygonEndList = v49;
    v4 = v112;
    if ( v20 )
    {
LABEL_211:
      if ( !v108 )
        goto LABEL_106;
      v63 = v108->numEdges;
      if ( !v63 )
        goto LABEL_122;
      v64 = 0;
      v65 = 0;
      do
      {
        v66 = v108->vertIndex[v65++];
        v67 = v64;
        if ( v66 == v26 )
        {
          v67 = 1;
          v64 = 1;
        }
        if ( v66 == v23 )
          v64 = v67;
        if ( v66 == v47 )
          v64 = v67;
      }
      while ( v65 < v63 );
      indices = v109;
      if ( v64 )
      {
LABEL_106:
        v68 = indices;
        index1 = v23;
        v69 = *(indices - 1);
        v70 = v68 + 1;
        *v68 = v69;
        if ( v4 )
        {
          v71 = index1;
          v72 = v118[0]->numEdges;
          if ( v72 )
          {
            for ( ii = 0; ii < v72; ++ii )
            {
              if ( v118[0]->vertIndex[ii] == v69 )
                break;
            }
          }
          else
          {
            ii = 0;
          }
          v81 = (ii + 1) % v72;
          v82 = 2;
          if ( v118[0]->vertIndex[v81] == index1 )
            v82 = 1;
          if ( v82 == v4 )
          {
            v4 ^= 3u;
          }
          else
          {
            v70 = v109 + 2;
            v109[1] = v69;
          }
        }
        else
        {
          v71 = index1;
          v4 = 0;
        }
        v70[1] = v26;
        indices = v70 + 2;
        *v70 = v71;
      }
      else
      {
LABEL_122:
        v76 = indices;
        index1 = v23;
        v77 = *(indices - 1);
        v78 = v76 + 1;
        *v76 = v77;
        if ( v4 )
        {
          v79 = v118[0]->numEdges;
          if ( v79 )
          {
            for ( jj = 0; jj < v79; ++jj )
            {
              if ( v118[0]->vertIndex[jj] == v77 )
                break;
            }
          }
          else
          {
            jj = 0;
          }
          v83 = (jj + 1) % v79;
          v84 = 2;
          if ( v118[0]->vertIndex[v83] == v26 )
            v84 = 1;
          if ( v84 == v4 )
          {
            v4 ^= 3u;
          }
          else
          {
            v78 = v109 + 2;
            v109[1] = v77;
          }
        }
        else
        {
          v4 = 0;
        }
        *v78 = v26;
        indices = v78 + 2;
        v78[1] = index1;
      }
    }
    else
    {
LABEL_89:
      *(indices - 1) = v23;
      *indices = v25;
      v59 = indices + 1;
      if ( v4 )
      {
        v60 = v4 ^ 3;
        v61 = v118[0]->numEdges;
        if ( v61 )
        {
          for ( kk = 0; kk < v61; ++kk )
          {
            if ( v118[0]->vertIndex[kk] == v23 )
              break;
          }
        }
        else
        {
          kk = 0;
        }
        v74 = (kk + 1) % v61;
        v75 = 2;
        if ( v118[0]->vertIndex[v74] == v25 )
          v75 = 1;
        v4 = v112;
        if ( v75 != v60 )
        {
          v4 = v60;
          v59 = v109 + 4;
          v109[3] = v25;
          v109[2] = v23;
          v109[1] = v25;
          *(v109 - 1) = v25;
        }
      }
      else
      {
        v4 = 0;
      }
      *v59 = v26;
      indices = v59 + 1;
    }
    goto LABEL_144;
  }
  outMesh->numIndices = indices - outMesh->indices;
}

//----- (0021B8B4) --------------------------------------------------------
RwBool __fastcall RpMeshSetTriStripMethod(RpTriStripMeshCallBack callback, void *data)
{
  if ( !callback )
    data = 0;
  MeshopStatic.data = data;
  if ( !callback )
    callback = RpBuildMeshGenerateDefaultTriStrip;
  MeshopStatic.meshTristripMethod = callback;
  return 1;
}
// 468318: using guessed type __int16 **off_468318;

//----- (0021B8D8) --------------------------------------------------------
RwBool __fastcall RpMeshGetTriStripMethod(RpTriStripMeshCallBack *callback, void **data)
{
  if ( callback )
    *callback = MeshopStatic.meshTristripMethod;
  if ( data )
    *data = MeshopStatic.data;
  return 1;
}

//----- (0021B8F8) --------------------------------------------------------
RpMeshHeader_0 *__fastcall _rpTriListMeshGenerate(RpBuildMesh_0 *buildMesh, void *data)
{
  _DWORD *v3; // r8
  int v4; // r0
  size_t v5; // r2
  size_t numTriangles; // r1
  RpMeshHeader_0 *v7; // r11
  RwInt32 v8; // r0
  RwUInt32 v9; // r0
  int v10; // r6
  int v11; // r2
  unsigned int v12; // r1
  int v13; // r3
  int v14; // r3
  int v15; // r5
  RwUInt32 v16; // r9
  RwInt32 globalsOffset; // r2
  char *v18; // r1
  RwUInt16 v19; // r3
  RpMeshHeader_0 *v20; // r1
  RwUInt32 v21; // r2
  RwUInt32 v22; // r2
  int v23; // r6
  _WORD *v24; // r3
  RwUInt32 v25; // r6
  int v26; // r0
  RwError_0 code; // [sp+4h] [bp-24h] BYREF

  v3 = (_DWORD *)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * buildMesh->numTriangles);
  if ( !v3 )
  {
    v7 = 0;
    code.pluginID = 0;
    v8 = _rwerror(-2147483629, 4 * buildMesh->numTriangles);
LABEL_22:
    code.errorCode = v8;
    RwErrorSet(&code);
    return v7;
  }
  if ( buildMesh->numTriangles )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v3[v5] = &buildMesh->meshTriangles[v4++];
      numTriangles = buildMesh->numTriangles;
      ++v5;
    }
    while ( v5 < numTriangles );
  }
  else
  {
    numTriangles = 0;
  }
  qsort(v3, numTriangles, 4u, SortPolygons);
  v9 = buildMesh->numTriangles;
  if ( v9 < 2 )
  {
    v10 = 1;
  }
  else
  {
    v10 = 1;
    v11 = *(_DWORD *)(*v3 + 8);
    v12 = 1;
    do
    {
      v13 = v3[v12++];
      v14 = *(_DWORD *)(v13 + 8);
      if ( v14 != v11 )
        ++v10;
      v11 = v14;
    }
    while ( v12 < v9 );
  }
  v15 = 16 * v10;
  v16 = 16 * v10 + 6 * v9 + 20;
  v7 = _rpMeshHeaderCreate(v16);
  if ( !v7 )
  {
    (*((void (__fastcall **)(_DWORD *))RwEngineInstance + 76))(v3);
    v7 = 0;
    code.pluginID = 0;
    v8 = _rwerror(-2147483629, v16);
    goto LABEL_22;
  }
  v7->numMeshes = 1;
  v7->flags = 0;
  globalsOffset = meshModule.globalsOffset;
  v18 = (char *)RwEngineInstance;
  v19 = *(_WORD *)((char *)RwEngineInstance + meshModule.globalsOffset);
  v7->firstMeshOffset = 0;
  v7->serialNum = v19;
  v7->totalIndicesInMesh = 3 * buildMesh->numTriangles;
  ++*(_WORD *)&v18[globalsOffset];
  v20 = v7 + 1;
  *(_DWORD *)&v7[1].numMeshes = 0;
  v21 = *(_DWORD *)(*v3 + 8);
  v7[1].flags = (RwUInt32)&v7[1] + 16 * v10;
  v7[1].totalIndicesInMesh = v21;
  v22 = 0;
  do
  {
    v23 = v3[v22];
    v24 = (_WORD *)((char *)v7 + v15);
    if ( *(_DWORD *)(v23 + 8) != v20->totalIndicesInMesh )
    {
      v20[1].flags = 0;
      v25 = *(_DWORD *)(v3[v22] + 8);
      v20->indexBuffer = (u_native)(v24 + 10);
      v20 = (RpMeshHeader_0 *)((char *)v20 + 16);
      v20->totalIndicesInMesh = v25;
      ++v7->numMeshes;
      v23 = v3[v22];
    }
    v15 += 6;
    v24[10] = *(_WORD *)v23;
    v24[11] = *(_WORD *)(v3[v22] + 2);
    v26 = v3[v22++];
    v24[12] = *(_WORD *)(v26 + 4);
    *(_DWORD *)&v20->numMeshes += 3;
  }
  while ( v22 < buildMesh->numTriangles );
  _rpMeshHeaderForAllMeshes(v7, SortPolygonsInTriListMesh, 0);
  (*((void (__fastcall **)(_DWORD *))RwEngineInstance + 76))(v3);
  return v7;
}

//----- (0021BAC8) --------------------------------------------------------
RpMesh_0 *__fastcall SortPolygonsInTriListMesh(RpMesh_0 *mesh, RpMeshHeader_0 *meshHeader, void *pData)
{
  __int64 v4; // kr00_8
  unsigned int v5; // r6
  unsigned int v6; // r0
  int8x16_t v7; // q8
  unsigned int v8; // r12
  unsigned int v9; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r5
  unsigned int v12; // r6
  int64x2_t v13; // q8
  unsigned __int32 v14; // r1
  int v15; // r2
  unsigned int v16; // r5
  void *v17; // r11
  size_t v18; // r10
  char *v19; // r0
  _WORD *v20; // lr
  unsigned int v21; // r9
  unsigned __int16 *v22; // r1
  unsigned int v23; // r0
  unsigned int v24; // r3
  int v25; // r6
  int v26; // r2
  int v27; // r5
  int v28; // r4
  char *v30; // [sp+8h] [bp-38h]
  size_t v31; // [sp+10h] [bp-30h]
  unsigned int v32; // [sp+14h] [bp-2Ch]

  v4 = *(_QWORD *)&mesh->indices;
  v5 = (2863311531u * (unsigned __int64)mesh->numIndices) >> 32;
  if ( mesh->numIndices )
  {
    if ( HIDWORD(v4) >= 4 && (v6 = HIDWORD(v4) & 0xFFFFFFFC, (v4 & 0xFFFFFFFC00000000LL) != 0) )
    {
      v7 = 0uLL;
      v8 = v5;
      v9 = HIDWORD(v4) & 0xFFFFFFFC;
      v10 = (unsigned int *)v4;
      do
      {
        v11 = v10[1];
        v9 -= 4;
        v12 = *v10;
        v10 += 2;
        v7 = vorrq_s64(v7, vmovl_u16((uint16x4_t)__PAIR64__(v11, v12)));
      }
      while ( v9 );
      v5 = v8;
      v13 = vorrq_s64(v7, vextq_s8(v7, v7, 8u));
      v14 = vorrq_s64(v13, vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 1)).n128_u32[0];
      if ( HIDWORD(v4) == v6 )
        goto LABEL_10;
    }
    else
    {
      v14 = 0;
      v6 = 0;
    }
    do
    {
      v15 = *(unsigned __int16 *)(v4 + 2 * v6++);
      v14 |= v15;
    }
    while ( v6 < HIDWORD(v4) );
LABEL_10:
    v16 = (v14 + 31) >> 3;
    goto LABEL_12;
  }
  v16 = 3;
LABEL_12:
  v17 = (void *)(*((int (__fastcall **)(unsigned int))RwEngineInstance + 75))(v16);
  if ( v17 )
  {
    v31 = v16;
    v18 = 2 * mesh->numIndices;
    v19 = (char *)(*((int (__fastcall **)(size_t))RwEngineInstance + 75))(v18);
    if ( v19 )
    {
      v30 = v19;
      qmemcpy(v19, (const void *)v4, v18);
      v20 = (_WORD *)v4;
      if ( HIDWORD(v4) >= 3 )
      {
        v21 = v5 >> 1;
        v32 = 0;
        do
        {
          if ( v31 )
            memset(v17, 0, v31);
          v22 = (unsigned __int16 *)(v30 + 2);
          v23 = 0;
          do
          {
            v24 = *(v22 - 1);
            v25 = *v22;
            v26 = v22[1];
            if ( (v25 & v24 & v26) != 0xFFFF )
            {
              v27 = *((_DWORD *)v17 + (v24 >> 5));
              v28 = 1 << (v24 & 0x1F);
              if ( (v27 & v28) == 0
                && (*((_DWORD *)v17 + ((unsigned __int16)v25 >> 5)) & (1 << (v25 & 0x1F))) == 0
                && (*((_DWORD *)v17 + ((unsigned __int16)v26 >> 5)) & (1 << (v26 & 0x1F))) == 0 )
              {
                *((_DWORD *)v17 + (v24 >> 5)) = v27 | v28;
                *((_DWORD *)v17 + (*v22 >> 5)) |= 1 << (*v22 & 0x1F);
                *((_DWORD *)v17 + (v22[1] >> 5)) |= 1 << (v22[1] & 0x1F);
                *v20 = *(v22 - 1);
                v20[1] = *v22;
                v20[2] = v22[1];
                v20 += 3;
                *v22 = -1;
                v22[1] = -1;
                *(v22 - 1) = -1;
                ++v32;
              }
            }
            ++v23;
            v22 += 3;
          }
          while ( v23 < v21 );
        }
        while ( v32 < v21 );
      }
      (*((void (__fastcall **)(char *))RwEngineInstance + 76))(v30);
    }
    (*((void (__fastcall **)(void *))RwEngineInstance + 76))(v17);
  }
  return mesh;
}

//----- (0021BCCC) --------------------------------------------------------
RpMeshHeader_0 *__fastcall _rpMeshOptimise(RpBuildMesh_0 *mesh, RwUInt32 flags)
{
  bool v3; // zf
  RwUInt32 v4; // r1
  RpMeshHeader_0 *(__fastcall *meshTristripMethod)(RpBuildMesh_0 *, void *); // r3
  void *v6; // r1
  RpMeshHeader_0 *v7; // r5

  if ( !mesh )
    return 0;
  if ( mesh->numTriangles )
  {
    v4 = flags & 1;
    v3 = v4 == 0;
    meshTristripMethod = MeshopStatic.meshTristripMethod;
    v6 = (void *)(-v4 & (RwUInt32)MeshopStatic.data);
    if ( v3 )
      meshTristripMethod = _rpTriListMeshGenerate;
    v7 = meshTristripMethod(mesh, v6);
    if ( v7 )
    {
      _rpBuildMeshDestroy(mesh);
      return v7;
    }
    return 0;
  }
  _rpBuildMeshDestroy(mesh);
  return (RpMeshHeader_0 *)&MeshopStatic;
}

//----- (0021BD28) --------------------------------------------------------
TriStripListEntry_0 *__fastcall TriStripJoin(TriStripList_0 *stripList, RwBool maintainWinding)
{
  TriStripListEntry_0 *result; // r0
  TriStripListEntry_0 *v4; // r6
  TriStripListEntry_0 *head; // r1
  RwUInt32 v6; // r0
  int v7; // r0
  TriStripListEntry_0 *v8; // r5
  int v9; // r0
  unsigned int v10; // r1
  RwUInt16 v11; // r2
  TriStripListEntry *next; // r9
  RwUInt32 stripLen; // r0
  RwUInt16 *strip; // r2
  TriStripListEntry *v15; // r5
  int v16; // r1
  int v17; // r3
  int v18; // r1
  int v19; // r1
  int v20; // r0
  unsigned int v21; // r1
  unsigned __int16 v22; // r2
  TriStripListEntry *v23; // r0
  TriStripListEntry *v24; // r1
  TriStripListEntry *v25; // r4
  TriStripList_0 *v26; // [sp+4h] [bp-2Ch]

  result = stripList->head;
  if ( result )
  {
    v4 = (TriStripListEntry_0 *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                                  + meshModule.globalsOffset
                                                                                                  + 4));
    v4->stripLen = 0;
    v4->stripSize = 0;
    head = stripList->head;
    if ( stripList->head )
    {
      v6 = 0;
      do
      {
        v6 += head->stripLen + 6;
        v4->stripSize = v6;
        head = head->next;
      }
      while ( head );
    }
    v7 = (*((int (**)(void))RwEngineInstance + 75))();
    v4->strip = (RwUInt16 *)v7;
    v26 = stripList;
    v8 = stripList->head;
    if ( stripList->head->stripLen )
    {
      *(_WORD *)(v7 + 2 * v4->stripLen) = *v8->strip;
      v9 = v4->stripLen + 1;
      v4->stripLen = v9;
      if ( v8->stripLen >= 2 )
      {
        v10 = 1;
        do
        {
          v11 = v8->strip[v10++];
          v4->strip[v9] = v11;
          v9 = v4->stripLen + 1;
          v4->stripLen = v9;
        }
        while ( v10 < v8->stripLen );
      }
    }
    (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v8->strip);
    v8->strip = 0;
    next = v8->next;
    (*((void (__fastcall **)(_DWORD, TriStripListEntry_0 *))RwEngineInstance + 80))(
      *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
      v8);
    if ( next )
    {
LABEL_12:
      stripLen = v4->stripLen;
      strip = v4->strip;
      v15 = next;
      v16 = (int)&v4->strip[stripLen];
      v17 = *(unsigned __int16 *)(v16 - 2);
      do
      {
        if ( v17 == *v15->strip )
        {
          v19 = 0;
          if ( maintainWinding && (stripLen & 1) != 0 )
          {
            strip[stripLen] = v17;
            v19 = 1;
          }
          goto LABEL_31;
        }
        v15 = v15->next;
      }
      while ( v15 );
      v18 = *(unsigned __int16 *)(v16 - 4);
      v15 = next;
      while ( v18 != *v15->strip )
      {
        v15 = v15->next;
        if ( !v15 )
          goto LABEL_20;
      }
      strip[stripLen] = v18;
      v19 = 1;
      if ( maintainWinding && (stripLen & 1) == 0 )
      {
        v19 = 2;
        v4->strip[v4->stripLen + 1] = *v15->strip;
      }
      while ( 1 )
      {
        while ( 1 )
        {
LABEL_31:
          v20 = v4->stripLen + v19;
          v4->stripLen = v20;
          if ( v15->stripLen )
          {
            v21 = 0;
            do
            {
              v22 = v15->strip[v21++];
              v4->strip[v20] = v22;
              v20 = v4->stripLen + 1;
              v4->stripLen = v20;
            }
            while ( v21 < v15->stripLen );
          }
          (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v15->strip);
          v15->strip = 0;
          v23 = next;
          if ( next == v15 )
          {
            v25 = next->next;
            (*((void (__fastcall **)(_DWORD, TriStripListEntry *))RwEngineInstance + 80))(
              *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
              next);
            next = v25;
            if ( !v25 )
              goto LABEL_38;
          }
          else
          {
            do
            {
              v24 = v23;
              v23 = v23->next;
            }
            while ( v23 != v15 );
            v24->next = v15->next;
            (*((void (__fastcall **)(_DWORD, TriStripListEntry *))RwEngineInstance + 80))(
              *(_DWORD *)((char *)RwEngineInstance + meshModule.globalsOffset + 4),
              v15);
          }
          if ( next )
            goto LABEL_12;
          stripLen = v4->stripLen;
          strip = v4->strip;
LABEL_20:
          strip[stripLen] = strip[stripLen - 1];
          v4->strip[v4->stripLen + 1] = *next->strip;
          v19 = 2;
          if ( maintainWinding )
            break;
LABEL_23:
          v15 = next;
        }
        v15 = next;
        if ( (stripLen & 1) != 0 )
        {
          v19 = 3;
          v4->strip[v4->stripLen + 2] = *next->strip;
          goto LABEL_23;
        }
      }
    }
LABEL_38:
    v26->head = v4;
    result = 0;
    v4->next = 0;
  }
  return result;
}
// 21BE22: conditional instruction was optimized away because r9.4!=0

//----- (0021BF90) --------------------------------------------------------
TriBinEntry_0 **__fastcall TriStripBinEntryArrayCreate(
        RwUInt32 numTris,
        MeshOpFreeLists_0 *meshOpFreeLists,
        Edge_0 **edgelist,
        RpBuildMeshTriangle_0 *triList)
{
  TriBinEntry_0 **v6; // r10
  RwUInt32 v7; // r11
  int v8; // r0
  RpBuildMeshTriangle_0 *v9; // r9
  int v10; // r6
  int v11; // r5
  Edge_0 *v12; // r0
  int v13; // r2
  bool v14; // zf
  Edge_0 **v15; // r2
  Edge_0 **v16; // r4
  int v17; // r5
  Edge_0 *v18; // r0
  int v19; // r6
  RwUInt16 *v20; // r9
  int v21; // t1
  int v22; // r2
  bool v23; // zf
  Edge_0 *v24; // r0
  int v25; // r5
  int v26; // r6
  int v27; // r2
  bool v28; // zf
  TriBinEntry_0 *v29; // r1
  MeshOpFreeLists_0 *v31; // [sp+10h] [bp-30h]
  RwUInt32 v32; // [sp+14h] [bp-2Ch]

  v6 = (TriBinEntry_0 **)(*((int (__fastcall **)(RwUInt32))RwEngineInstance + 75))(4 * numTris);
  meshOpFreeLists->binEntryFreeList = RwFreeListCreate(36, numTris, 4);
  meshOpFreeLists->edgeFreeList = RwFreeListCreate(16, (numTris >> 1) + 1, 4);
  v32 = numTris;
  if ( numTris )
  {
    v7 = 0;
    v31 = meshOpFreeLists;
    do
    {
      v8 = (*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(meshOpFreeLists->binEntryFreeList);
      v6[v7] = (TriBinEntry_0 *)v8;
      *(_BYTE *)(v8 + 32) = 0;
      v6[v7]->tri = v7;
      v6[v7]->prev = 0;
      v6[v7]->next = 0;
      v6[v7]->used = 0;
      v9 = &triList[v7];
      v10 = v9->vertIndex[0];
      v11 = v9->vertIndex[1];
      v12 = *edgelist;
      if ( *edgelist )
      {
        while ( 1 )
        {
          if ( v12->v2 == v10 )
          {
            v13 = v12->v1;
            v14 = v13 == v11;
            if ( v13 == v11 )
              v14 = v12->tri2 == 0;
            if ( v14 )
              break;
          }
          v12 = v12->next;
          if ( !v12 )
            goto LABEL_12;
        }
        ++v12->tri1->adjCount;
        ++v6[v7]->adjCount;
        v12->tri2 = v6[v7];
        v15 = edgelist;
      }
      else
      {
LABEL_12:
        v12 = (Edge_0 *)(*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(meshOpFreeLists->edgeFreeList);
        v12->v1 = v10;
        v12->v2 = v11;
        v12->tri1 = v6[v7];
        v12->tri2 = 0;
        v15 = edgelist;
        v12->next = *edgelist;
        *edgelist = v12;
      }
      v16 = v15;
      v6[v7]->edge[0] = v12;
      v17 = v9->vertIndex[1];
      meshOpFreeLists = v31;
      v18 = *v15;
      v21 = v9->vertIndex[2];
      v20 = &v9->vertIndex[2];
      v19 = v21;
      if ( *v15 )
      {
        while ( 1 )
        {
          if ( v18->v2 == v17 )
          {
            v22 = v18->v1;
            v23 = v22 == v19;
            if ( v22 == v19 )
              v23 = v18->tri2 == 0;
            if ( v23 )
              break;
          }
          v18 = v18->next;
          if ( !v18 )
            goto LABEL_19;
        }
        ++v18->tri1->adjCount;
        ++v6[v7]->adjCount;
        v18->tri2 = v6[v7];
      }
      else
      {
LABEL_19:
        v18 = (Edge_0 *)(*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(v31->edgeFreeList);
        v18->v1 = v17;
        v18->v2 = v19;
        v18->tri1 = v6[v7];
        v18->tri2 = 0;
        v18->next = *v16;
        *v16 = v18;
      }
      v6[v7]->edge[1] = v18;
      v24 = *v16;
      v25 = *v20;
      v26 = triList[v7].vertIndex[0];
      if ( *v16 )
      {
        while ( 1 )
        {
          if ( v24->v2 == v25 )
          {
            v27 = v24->v1;
            v28 = v27 == v26;
            if ( v27 == v26 )
              v28 = v24->tri2 == 0;
            if ( v28 )
              break;
          }
          v24 = v24->next;
          if ( !v24 )
            goto LABEL_30;
        }
        ++v24->tri1->adjCount;
        ++v6[v7]->adjCount;
        v24->tri2 = v6[v7];
      }
      else
      {
LABEL_30:
        v24 = (Edge_0 *)(*((int (__fastcall **)(RwFreeList_0 *))RwEngineInstance + 79))(v31->edgeFreeList);
        v24->v1 = v25;
        v24->v2 = v26;
        v24->tri1 = v6[v7];
        v24->tri2 = 0;
        v24->next = *v16;
        *v16 = v24;
      }
      v29 = v6[v7++];
      v29->edge[2] = v24;
    }
    while ( v7 != v32 );
  }
  return v6;
}

//----- (0021C1CC) --------------------------------------------------------
void __fastcall TriStripMarkTriUsed(TriBinEntry_0 *tri, TriBinList_0 *binListArray, RwInt32 currentAttempt)
{
  int adjCount; // r2
  TriBinEntry *next; // r2
  TriBinEntry *prev; // r2
  TriBinEntry_0 *head; // r2
  int i; // lr
  int v8; // r2
  TriBinEntry_0 *v9; // r3
  bool v10; // zf
  int v11; // r2
  TriBinEntry *v12; // r2
  TriBinEntry *v13; // r2
  TriBinEntry_0 *v14; // r2
  RwUInt8 v15; // r2
  TriBinEntry_0 *v16; // r4

  if ( currentAttempt > 3 )
  {
    adjCount = tri->adjCount;
    tri->used = 1;
    if ( binListArray[adjCount].head == tri )
    {
      binListArray[adjCount] = (TriBinList_0)tri->next;
      head = binListArray[tri->adjCount].head;
      if ( head )
        head->prev = 0;
    }
    else
    {
      next = tri->next;
      if ( next )
        next->prev = tri->prev;
      prev = tri->prev;
      if ( prev )
        prev->next = tri->next;
    }
    for ( i = 1; i != 4; ++i )
    {
      v8 = *(&tri->tri + i);
      v9 = *(TriBinEntry_0 **)(v8 + 4);
      v10 = v9 == 0;
      if ( v9 )
        v10 = v9 == tri;
      if ( v10 || v9->used )
      {
        v9 = *(TriBinEntry_0 **)(v8 + 8);
        if ( !v9 || v9->used )
          continue;
      }
      v11 = v9->adjCount;
      if ( binListArray[v11].head == v9 )
      {
        binListArray[v11] = (TriBinList_0)v9->next;
        v14 = binListArray[v9->adjCount].head;
        if ( v14 )
          v14->prev = 0;
      }
      else
      {
        v12 = v9->next;
        if ( v12 )
          v12->prev = v9->prev;
        v13 = v9->prev;
        if ( v13 )
          v13->next = v9->next;
      }
      v15 = v9->adjCount - 1;
      v9->adjCount = v15;
      v16 = binListArray[v15].head;
      v9->next = v16;
      if ( v16 )
      {
        v16->prev = v9;
        v15 = v9->adjCount;
      }
      binListArray[v15].head = v9;
      v9->prev = 0;
    }
  }
  else
  {
    tri->used2 = 1;
  }
}

//----- (0021C2AA) --------------------------------------------------------
int __fastcall TriStripFollow(
        TriStripListEntry_0 *strip,
        Edge_0 *nextEdge,
        TriBinList_0 *binListArray,
        RpBuildMeshTriangle_0 *triList,
        RwInt32 currentAttempt)
{
  int v6; // r8
  int v7; // r2
  RwUInt32 stripLen; // r5
  TriBinEntry_0 *tri1; // r4
  int v10; // r8
  int v11; // r9
  Edge_0 *v12; // r3
  RwUInt32 v13; // lr
  RwUInt16 *v14; // r12
  int v15; // r1
  RpBuildMeshTriangle_0 *v16; // r0
  int v17; // r2
  RwUInt16 v18; // r5
  int v19; // r0
  RwUInt16 v20; // r1
  int v21; // r10
  RwUInt16 v22; // r5
  int v23; // r6
  Edge_0 *v24; // r0
  int v25; // r6
  bool v26; // zf
  bool v27; // zf
  int v28; // r6
  bool v29; // zf
  bool v30; // zf
  Edge_0 *v31; // r9
  TriBinEntry_0 *v32; // r1
  _BOOL4 v33; // r1
  TriBinEntry_0 *v34; // r1
  TriBinEntry_0 *v35; // r6
  RwBool used; // r6
  TriBinEntry_0 *tri2; // r6
  bool v38; // zf
  bool v39; // zf
  Edge_0 *v40; // r1
  TriBinEntry_0 *v41; // r0
  _BOOL4 v42; // r0
  TriBinEntry_0 *v43; // r0
  TriBinEntry_0 *v44; // r1
  RwBool used2; // r1
  TriBinEntry_0 *v46; // r1
  __int64 v47; // r0
  Edge_0 *v49; // [sp+4h] [bp-34h]
  RwUInt16 *v52; // [sp+10h] [bp-28h]
  Edge_0 *v53; // [sp+14h] [bp-24h]
  int v54; // [sp+18h] [bp-20h]

  v6 = 0;
  if ( nextEdge )
  {
    v7 = currentAttempt;
    v54 = 0;
    stripLen = strip->stripLen;
    v49 = 0;
    while ( 1 )
    {
      tri1 = nextEdge->tri1;
      v10 = strip->strip[(stripLen | 0xFFFFFFFE) + stripLen];
      v11 = strip->strip[((stripLen | 0xFFFFFFFE) ^ 1) + stripLen];
      if ( v7 > 3 )
      {
        if ( !tri1 || tri1->used )
        {
          tri1 = nextEdge->tri2;
          if ( !tri1 || tri1->used )
            return v54;
        }
      }
      else if ( !tri1 || tri1->used2 )
      {
        tri1 = nextEdge->tri2;
        if ( !tri1 || tri1->used2 )
          return v54;
      }
      v53 = nextEdge;
      TriStripMarkTriUsed(tri1, binListArray, v7);
      v12 = tri1->edge[0];
      v13 = strip->stripLen;
      v14 = &strip->strip[v13];
      v15 = triList[tri1->tri].vertIndex[0];
      v16 = &triList[tri1->tri];
      v17 = v16->vertIndex[2];
      v18 = v16->vertIndex[0];
      if ( v15 == v11 )
        v18 = 0;
      v19 = v16->vertIndex[1];
      if ( v15 == v10 )
        v18 = 0;
      v52 = strip->strip;
      v20 = v19;
      v21 = *(v14 - 1);
      if ( v19 == v11 )
        v20 = v18;
      if ( v19 == v10 )
        v20 = v18;
      v22 = v17;
      if ( v17 == v11 )
        v22 = v20;
      v23 = v12->v1;
      if ( v17 == v10 )
        v22 = v20;
      if ( v23 != v21 || (v24 = tri1->edge[0], v12->v2 != v22) )
      {
        if ( v23 != v22 || (v24 = tri1->edge[0], v12->v2 != v21) )
        {
          v24 = tri1->edge[1];
          v25 = v24->v1;
          v26 = v25 == v21;
          if ( v25 == v21 )
            v26 = v24->v2 == v22;
          if ( !v26 )
          {
            v27 = v25 == v22;
            if ( v25 == v22 )
              v27 = v24->v2 == v21;
            if ( !v27 )
            {
              v24 = tri1->edge[2];
              v28 = v24->v1;
              v29 = v28 == v21;
              if ( v28 == v21 )
                v29 = v24->v2 == v22;
              if ( !v29 )
              {
                v30 = v28 == v22;
                if ( v28 == v22 )
                  v30 = v24->v2 == v21;
                if ( !v30 )
                  v24 = 0;
              }
            }
          }
        }
      }
      v7 = currentAttempt;
      v6 = ++v54;
      if ( currentAttempt > 3 )
      {
        v31 = v53;
        if ( !v24 )
          goto LABEL_59;
        v34 = v24->tri1;
        if ( v34 )
          v33 = v34->used == 0;
        else
          v33 = 0;
        tri2 = v24->tri2;
        if ( tri2 )
        {
          used = tri2->used;
LABEL_56:
          if ( v33 + (used == 0) )
            goto LABEL_3;
          goto LABEL_59;
        }
      }
      else
      {
        v31 = v53;
        if ( !v24 )
          goto LABEL_59;
        v32 = v24->tri1;
        if ( v32 )
          v33 = v32->used2 == 0;
        else
          v33 = 0;
        v35 = v24->tri2;
        if ( v35 )
        {
          used = v35->used2;
          goto LABEL_56;
        }
      }
      if ( v33 )
        goto LABEL_3;
LABEL_59:
      v38 = v12 == v31;
      if ( v12 != v31 )
        v38 = v12 == v24;
      if ( v38 )
      {
        v12 = tri1->edge[1];
        v39 = v12 == v31;
        if ( v12 != v31 )
          v39 = v12 == v24;
        if ( v39 )
        {
          v40 = tri1->edge[2];
          v12 = v40;
          if ( v40 == v24 )
            v12 = v49;
          if ( v40 == v31 )
            v12 = v49;
        }
      }
      if ( currentAttempt > 3 )
      {
        if ( !v12 )
          goto LABEL_88;
        v43 = v12->tri1;
        if ( v43 )
          v42 = v43->used == 0;
        else
          v42 = 0;
        v46 = v12->tri2;
        if ( !v46 )
        {
LABEL_87:
          if ( !v42 )
          {
LABEL_88:
            v52[v13] = v22;
            ++strip->stripLen;
            return v6;
          }
          goto LABEL_85;
        }
        used2 = v46->used;
      }
      else
      {
        if ( !v12 )
          goto LABEL_88;
        v41 = v12->tri1;
        if ( v41 )
          v42 = v41->used2 == 0;
        else
          v42 = 0;
        v44 = v12->tri2;
        if ( !v44 )
          goto LABEL_87;
        used2 = v44->used2;
      }
      if ( !(v42 + (used2 == 0)) )
        goto LABEL_88;
LABEL_85:
      if ( (v13 & 1) != 0 )
        goto LABEL_88;
      v52[v13] = *(v14 - 2);
      v47 = *(_QWORD *)&strip->strip;
      HIDWORD(v47) = strip->stripLen + 1;
      strip->stripLen = HIDWORD(v47);
      v49 = v12;
      v14 = (RwUInt16 *)(v47 + 2 * HIDWORD(v47));
      v24 = v12;
LABEL_3:
      *v14 = v22;
      stripLen = strip->stripLen + 1;
      strip->stripLen = stripLen;
      nextEdge = v24;
    }
  }
  return v6;
}

//----- (0021C4FE) --------------------------------------------------------
void __fastcall _rpTriStripGetStrip(
        RwLLLink_0 *link,
        RpTriStripPolygon_0 **polygon1,
        RpTriStripPolygon_0 **polygon2,
        RpTriStripPolygon_0 **polygon3,
        RxVertexIndex *index1,
        RxVertexIndex *index2,
        RxVertexIndex *index3)
{
  RwLLLink_0 *v7; // r10
  RwLLLink *next; // r8
  int v9; // r6
  _DWORD *v10; // r4
  RpTriStripPolygon_0 **p_poly1; // r5
  bool v12; // zf
  RpTriStripPolygon_0 **v13; // r4
  RpTriStripPolygon_0 *poly1; // r12
  RpTriStripPolygon_0 *v15; // t1
  RpTriStripPolygon_0 *v16; // r10
  RpTriStripPolygon_0 *v17; // r9
  RwUInt32 numEdges; // r8
  int v19; // r6
  RpTriStripEdge_0 *v20; // r4
  RwBool strip; // r0
  bool v22; // zf
  RpTriStripPolygon_0 **p_poly2; // r4
  RpTriStripPolygon_0 *poly2; // t1
  RpTriStripPolygon_0 *v25; // r3
  RpTriStripPolygon_0 *v26; // r9
  RwUInt32 v27; // r8
  RwUInt32 v28; // r6
  int v29; // r12
  RpTriStripPolygon_0 *v30; // r0
  RpTriStripPolygon_0 *v31; // r0
  RwUInt32 v32; // r12
  int v33; // r0
  int v34; // r8
  RpTriStripPolygon_0 **v35; // r4
  RwUInt32 v36; // r10
  int v37; // r0
  int v38; // r10
  RpTriStripPolygon_0 *v39; // r12
  RwUInt32 v40; // r9
  RpTriStripPolygon_0 *v41; // r8
  int v42; // r2
  int v43; // r6
  bool v44; // zf
  int v45; // r3
  int v46; // r2
  RpTriStripPolygon_0 *v47; // r0
  RwUInt32 v48; // r3
  RwUInt32 i; // r1
  int v50; // r4
  bool v51; // zf
  int v52; // [sp+4h] [bp-24h]
  RpTriStripPolygon_0 *v53; // [sp+8h] [bp-20h]

  *polygon1 = (RpTriStripPolygon_0 *)link;
  next = link[3].next;
  if ( !next )
  {
LABEL_8:
    *polygon2 = 0;
    v16 = *polygon1;
LABEL_9:
    *index1 = v16->vertIndex[0];
    *index2 = (*polygon1)->vertIndex[1];
    *index3 = (*polygon1)->vertIndex[2];
    *polygon3 = 0;
    return;
  }
  v9 = 0;
  while ( 1 )
  {
    v10 = (_DWORD *)*((_DWORD *)&link[3].prev + v9);
    p_poly1 = (RpTriStripPolygon_0 **)v10[7];
    v12 = p_poly1 == 0;
    if ( p_poly1 )
    {
      p_poly1 = (RpTriStripPolygon_0 **)(v10 + 4);
      v7 = (RwLLLink_0 *)v10[4];
      v12 = v7 == 0;
    }
    if ( !v12 )
    {
      v15 = (RpTriStripPolygon_0 *)v10[5];
      v13 = (RpTriStripPolygon_0 **)(v10 + 5);
      poly1 = v15;
      if ( v15 )
        break;
    }
    if ( ++v9 >= (unsigned int)next )
      goto LABEL_8;
  }
  if ( v7 == link )
    p_poly1 = v13;
  v17 = *p_poly1;
  *polygon2 = *p_poly1;
  v16 = *polygon1;
  if ( !v17 )
    goto LABEL_9;
  numEdges = v17->numEdges;
  if ( numEdges )
  {
    v19 = 0;
    while ( 1 )
    {
      v20 = v17->edges[v19];
      strip = v20->strip;
      v22 = strip == 0;
      if ( strip )
      {
        p_poly1 = &v20->poly1;
        poly1 = v20->poly1;
        v22 = poly1 == v16;
      }
      if ( !v22 )
      {
        poly2 = v20->poly2;
        p_poly2 = &v20->poly2;
        if ( poly2 != v16 )
          break;
      }
      if ( ++v19 >= numEdges )
        goto LABEL_20;
    }
    if ( poly1 == v17 )
      p_poly1 = p_poly2;
    v31 = *p_poly1;
    *polygon3 = *p_poly1;
    v25 = *polygon2;
    v26 = *polygon1;
    v53 = v31;
    if ( v31 )
    {
      if ( v26->numEdges )
      {
        v32 = v25->numEdges;
        v33 = 0;
        while ( 1 )
        {
          v52 = v33;
          if ( v32 )
            break;
LABEL_43:
          v33 = v52 + 1;
          if ( v52 + 1 >= v26->numEdges )
            goto LABEL_47;
        }
        v34 = 0;
        v35 = (RpTriStripPolygon_0 **)v26->vertIndex[v33];
        while ( 1 )
        {
          if ( v35 == (RpTriStripPolygon_0 **)v25->vertIndex[v34] )
          {
            v36 = v53->numEdges;
            if ( v36 )
              break;
          }
LABEL_42:
          if ( ++v34 >= v32 )
            goto LABEL_43;
        }
        v37 = 0;
        while ( 1 )
        {
          p_poly1 = (RpTriStripPolygon_0 **)v53->vertIndex[v37];
          if ( v35 == p_poly1 )
            break;
          if ( ++v37 >= v36 )
            goto LABEL_42;
        }
        v33 = v52;
      }
      else
      {
        v33 = 0;
      }
LABEL_47:
      v30 = (RpTriStripPolygon_0 *)((char *)v26 + 2 * v33);
      goto LABEL_48;
    }
  }
  else
  {
LABEL_20:
    *polygon3 = 0;
    v25 = *polygon2;
    v26 = *polygon1;
  }
  v27 = v26->numEdges;
  if ( v27 )
  {
    v28 = v25->numEdges;
    v29 = 0;
    while ( !v28 )
    {
LABEL_27:
      if ( ++v29 >= v27 )
        goto LABEL_28;
    }
    p_poly1 = 0;
    while ( v26->vertIndex[v29] != v25->vertIndex[(_DWORD)p_poly1] )
    {
      p_poly1 = (RpTriStripPolygon_0 **)((char *)p_poly1 + 1);
      if ( (unsigned int)p_poly1 >= v28 )
        goto LABEL_27;
    }
LABEL_28:
    v30 = (RpTriStripPolygon_0 *)((char *)v26 + 2 * v29);
  }
  else
  {
    v30 = v26;
  }
LABEL_48:
  v38 = v30->vertIndex[0];
  *index3 = v38;
  v39 = *polygon1;
  v40 = (*polygon1)->numEdges;
  if ( v40 )
  {
    v41 = *polygon2;
    v42 = 0;
    while ( 1 )
    {
      v43 = v39->vertIndex[v42];
      v44 = v43 == v38;
      if ( v43 != v38 )
      {
        p_poly1 = (RpTriStripPolygon_0 **)v41->numEdges;
        v44 = p_poly1 == 0;
      }
      if ( !v44 )
        break;
LABEL_56:
      if ( ++v42 >= v40 )
        goto LABEL_59;
    }
    v45 = 0;
    while ( v43 != v41->vertIndex[v45] )
    {
      if ( ++v45 >= (unsigned int)p_poly1 )
        goto LABEL_56;
    }
  }
  else
  {
    v42 = 0;
  }
LABEL_59:
  v46 = v39->vertIndex[v42];
  *index2 = v46;
  v47 = *polygon1;
  v48 = (*polygon1)->numEdges;
  if ( v48 )
  {
    for ( i = 0; i < v48; ++i )
    {
      v50 = v47->vertIndex[i];
      v51 = v50 == v46;
      if ( v50 != v46 )
        v51 = v50 == *index3;
      if ( !v51 )
        break;
    }
  }
  else
  {
    i = 0;
  }
  *index1 = v47->vertIndex[i];
}
// 21C572: variable 'v7' is possibly undefined

//----- (0021C718) --------------------------------------------------------
void *__fastcall _rpSectorOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  ++sectorModule;
  return instance;
}
// 6BD608: using guessed type int sectorModule;

//----- (0021C728) --------------------------------------------------------
void *__fastcall _rpSectorClose(void *instance, RwInt32 offset, RwInt32 size)
{
  --sectorModule;
  return instance;
}
// 6BD608: using guessed type int sectorModule;

//----- (0021C738) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorGetNumVertices(const RpWorldSector_0 *sector)
{
  return sector->numVertices;
}

//----- (0021C73E) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorGetNumPolygons(const RpWorldSector_0 *sector)
{
  return sector->numPolygons;
}

//----- (0021C744) --------------------------------------------------------
RpWorldSector_0 *__fastcall RpWorldSectorRender(RpWorldSector_0 *sector)
{
  return (RpWorldSector_0 *)(*(int (__fastcall **)(RpWorldSector_0 *))(*((_DWORD *)RwEngineInstance + 1) + 104))(sector);
}

//----- (0021C758) --------------------------------------------------------
const RpWorldSector_0 *__fastcall RpWorldSectorForAllMeshes(
        const RpWorldSector_0 *sector,
        RpMeshCallBack fpCallBack,
        void *pData)
{
  const RpWorldSector_0 *v3; // r4
  RpMeshHeader_0 *mesh; // r0

  v3 = sector;
  mesh = sector->mesh;
  if ( !mesh )
    return 0;
  if ( !_rpMeshHeaderForAllMeshes(mesh, fpCallBack, pData) )
    return 0;
  return v3;
}

//----- (0021C778) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&sectorTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (0021C7A4) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&sectorTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (0021C7C8) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&sectorTKList, pluginID, alwaysCB);
}

//----- (0021C7DC) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorSetStreamRightsCallBack(RwUInt32 pluginID, RwPluginDataChunkRightsCallBack rightsCB)
{
  return sub_19E33C(&sectorTKList, pluginID, rightsCB);
}

//----- (0021C7F0) --------------------------------------------------------
RwInt32 __fastcall RpWorldSectorGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&sectorTKList, pluginID);
}

//----- (0021C800) --------------------------------------------------------
RwBool __fastcall RpWorldSectorValidatePlugins(const RpWorldSector_0 *sector)
{
  return 1;
}

//----- (0021C804) --------------------------------------------------------
RpWorldSector_0 *__fastcall _rpSectorDefaultRenderCallBack(RpWorldSector_0 *sector)
{
  RpWorldSector_0 *v1; // r4
  RxPipeline_0 *pipeline; // r0

  v1 = sector;
  if ( sector->numPolygons )
  {
    pipeline = sector->pipeline;
    if ( !pipeline )
    {
      pipeline = *(RxPipeline_0 **)(*((_DWORD *)RwEngineInstance + 1) + 108);
      if ( !pipeline )
        pipeline = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 64);
    }
    sector = (RpWorldSector_0 *)RxPipelineExecute(pipeline, v1, 1);
    if ( sector )
      return v1;
  }
  return sector;
}

//----- (0021C84C) --------------------------------------------------------
RwBool __fastcall _rpWorldForAllGlobalLights(RpLightCallBack callBack, void *pData)
{
  int v4; // r6
  _DWORD *v5; // r0
  _DWORD *v6; // r6
  _DWORD *v7; // t1
  _DWORD *v8; // r4
  bool v9; // zf

  v4 = *((_DWORD *)RwEngineInstance + 1);
  v7 = *(_DWORD **)(v4 + 60);
  v6 = (_DWORD *)(v4 + 60);
  v5 = v7;
  do
  {
    if ( v5 == v6 )
      break;
    v8 = (_DWORD *)*v5;
    v9 = (int)callBack((RpLight_0 *)(v5 - 13), pData) == 0;
    v5 = v8;
  }
  while ( !v9 );
  return 1;
}

//----- (0021C884) --------------------------------------------------------
RpWorldSector_0 *__fastcall _rpWorldSectorForAllLocalLights(
        RpWorldSector_0 *sector,
        RpLightCallBack callBack,
        void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_lightsInWorldSector; // r5
  RwLinkList_0 *v8; // r4
  RpLight_0 *v9; // r0

  p_lightsInWorldSector = &sector->lightsInWorldSector;
  next = sector->lightsInWorldSector.link.next;
  if ( next != (RwLLLink *)p_lightsInWorldSector )
  {
    do
    {
      v8 = (RwLinkList_0 *)next->next;
      v9 = (RpLight_0 *)next[1].next;
      if ( v9 && !(int)callBack(v9, pData) )
        break;
      next = &v8->link;
    }
    while ( v8 != p_lightsInWorldSector );
  }
  return sector;
}

//----- (0021C8B6) --------------------------------------------------------
RwBool __fastcall _rpWorldFindBBox(RpWorld_0 *world, RwBBox_0 *boundingBox)
{
  RpSector_0 *rootSector; // r0
  int v4; // r9
  int i; // r6
  __int64 v6; // kr00_8
  const RwV3d_0 *v7; // r1
  const RwV3d_0 *v8; // r5
  _DWORD v10[70]; // [sp+0h] [bp-118h]

  rootSector = world->rootSector;
  v4 = 0;
  for ( i = 0; i > -1; --i )
  {
    while ( rootSector->type > -1 )
    {
      v6 = *(_QWORD *)&rootSector[2].type;
      v10[++i] = rootSector[3].type;
      rootSector = (RpSector_0 *)v6;
      if ( i <= -1 )
        return 1;
    }
    v7 = (const RwV3d_0 *)&rootSector[29];
    v8 = (const RwV3d_0 *)&rootSector[26];
    if ( v4 )
    {
      RwBBoxAddPoint(boundingBox, v7);
    }
    else
    {
      RwBBoxInitialize(boundingBox, v7);
      v4 = 1;
    }
    RwBBoxAddPoint(boundingBox, v8);
    rootSector = (RpSector_0 *)v10[i];
  }
  return 1;
}

//----- (0021C924) --------------------------------------------------------
RpWorld_0 *__fastcall _rpWorldSetupSectorBoundingBoxes(RpWorld_0 *world)
{
  RpSector_0 *rootSector; // r2
  __int64 v2; // d17
  __int64 v3; // d18
  int v4; // r3
  __int64 v5; // d17
  __int64 v6; // d18
  _QWORD *v7; // r5
  int type; // r5
  __int64 v9; // d17
  __int64 v10; // d18
  __int64 *v11; // r5
  __int64 v12; // d17
  __int64 v13; // d18
  _QWORD v14[192]; // [sp+0h] [bp-728h] BYREF
  __int64 v15; // [sp+600h] [bp-128h]
  __int64 v16; // [sp+608h] [bp-120h]
  __int64 v17; // [sp+610h] [bp-118h]
  _DWORD v18[68]; // [sp+618h] [bp-110h]

  rootSector = world->rootSector;
  v2 = *(_QWORD *)&world->boundingBox.sup.z;
  v3 = *(_QWORD *)&world->boundingBox.inf.y;
  v15 = *(_QWORD *)&world->boundingBox.sup.x;
  v16 = v2;
  v17 = v3;
  v4 = 0;
  do
  {
    while ( rootSector->type > -1 )
    {
      v18[++v4] = rootSector[3].type;
      v5 = v16;
      v6 = v17;
      v7 = &v14[3 * v4];
      *v7 = v15;
      v7[1] = v5;
      v7[2] = v6;
      type = rootSector->type;
      *(RpSector_0 *)((char *)&v14[3 * v4 + 1] + rootSector->type + 4) = rootSector[5];
      *(RpSector_0 *)((char *)&v15 + type) = rootSector[4];
      rootSector = (RpSector_0 *)rootSector[2].type;
      if ( v4 <= -1 )
        return world;
    }
    v9 = v16;
    v10 = v17;
    *(_QWORD *)&rootSector[20].type = v15;
    *(_QWORD *)&rootSector[22].type = v9;
    *(_QWORD *)&rootSector[24].type = v10;
    v11 = &v14[3 * v4];
    rootSector = (RpSector_0 *)v18[v4];
    v12 = v11[1];
    --v4;
    v13 = v11[2];
    v15 = *v11;
    v16 = v12;
    v17 = v13;
  }
  while ( v4 > -1 );
  return world;
}
// 21C924: using guessed type _QWORD var_128;
// 21C924: using guessed type _DWORD var_110[68];

//----- (0021C9DC) --------------------------------------------------------
void __fastcall _rpWorldRegisterWorld(RpWorld_0 *world, RwUInt32 memorySize)
{
  RpWorld_0 **v4; // r0
  RpWorld_0 *v5; // r1
  _DWORD *v6; // r0

  v4 = (RpWorld_0 **)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                       + worldModule));
  if ( v4 )
  {
    v4[1] = (RpWorld_0 *)memorySize;
    *v4 = world;
    v5 = (RpWorld_0 *)((char *)RwEngineInstance + worldModule + 4);
    v4[2] = *(RpWorld_0 **)&v5->object.type;
    v4[3] = v5;
    v6 = v4 + 2;
    *(_DWORD *)(*(_DWORD *)&v5->object.type + 4) = v6;
    *(_DWORD *)&v5->object.type = v6;
  }
}
// 6BD630: using guessed type int worldModule;

//----- (0021CA38) --------------------------------------------------------
void __fastcall _rpWorldUnregisterWorld(RpWorld_0 *world)
{
  int v1; // r12
  _DWORD **v2; // r3

  v1 = worldModule;
  v2 = (_DWORD **)((char *)RwEngineInstance + worldModule + 4);
  while ( 1 )
  {
    v2 = (_DWORD **)*v2;
    if ( v2 == (_DWORD **)((char *)RwEngineInstance + worldModule + 4) )
      break;
    if ( *(v2 - 2) == (_DWORD *)world )
    {
      *v2[1] = *v2;
      (*v2)[1] = v2[1];
      (*((void (__fastcall **)(_DWORD, _DWORD **))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + v1),
        v2 - 2);
      return;
    }
  }
}
// 6BD630: using guessed type int worldModule;

//----- (0021CA98) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldLock(RpWorld_0 *world)
{
  RpSector_0 *rootSector; // r5
  int i; // r4
  __int64 v4; // r0
  RpMeshHeader_0 *type; // r0
  _DWORD v7[70]; // [sp+0h] [bp-118h]

  rootSector = world->rootSector;
  for ( i = 0; i > -1; --i )
  {
    while ( rootSector->type > -1 )
    {
      v4 = *(_QWORD *)&rootSector[2].type;
      v7[++i] = HIDWORD(v4);
      rootSector = (RpSector_0 *)v4;
      if ( i <= -1 )
        return world;
    }
    type = (RpMeshHeader_0 *)rootSector[32].type;
    if ( type )
    {
      _rpMeshDestroy(type);
      rootSector[32].type = 0;
    }
    rootSector = (RpSector_0 *)v7[i];
  }
  return world;
}

//----- (0021CAF0) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldUnlock(RpWorld_0 *world)
{
  RpWorld_0 *v1; // r8
  RpSector_0 *rootSector; // r4
  int v3; // r10
  __int64 v4; // r0
  int type_low; // r5
  RpMaterial_0 **materials; // r6
  RpBuildMesh_0 *v7; // r11
  RpMaterial_0 **v8; // r6
  int v9; // r5
  RpMeshHeader_0 *v10; // r0
  _DWORD v12[71]; // [sp+4h] [bp-11Ch]

  v1 = world;
  rootSector = world->rootSector;
  v3 = 0;
  while ( 1 )
  {
    while ( rootSector->type > -1 )
    {
      v4 = *(_QWORD *)&rootSector[2].type;
      v12[++v3] = HIDWORD(v4);
      rootSector = (RpSector_0 *)v4;
      if ( v3 <= -1 )
        return v1;
    }
    if ( rootSector[32].type )
      goto LABEL_12;
    type_low = LOWORD(rootSector[34].type);
    materials = v1->matList.materials;
    v7 = _rpBuildMeshCreate(LOWORD(rootSector[35].type));
    if ( !v7 )
      return 0;
    if ( LOWORD(rootSector[35].type) )
    {
      v8 = &materials[type_low];
      v9 = 0;
      do
      {
        _rpBuildMeshAddTriangle(
          v7,
          v8[*(unsigned __int16 *)(rootSector[1].type + 8 * v9)],
          *(unsigned __int16 *)(rootSector[1].type + 8 * v9 + 2),
          *(unsigned __int16 *)(rootSector[1].type + 8 * v9 + 4),
          *(unsigned __int16 *)(rootSector[1].type + 8 * v9 + 6));
        ++v9;
      }
      while ( v9 < LOWORD(rootSector[35].type) );
    }
    v10 = _rpMeshOptimise(v7, v1->flags & 1);
    if ( !v10 )
      break;
    rootSector[32].type = (RwInt32)v10;
LABEL_12:
    rootSector = (RpSector_0 *)v12[v3--];
    if ( v3 <= -1 )
      return v1;
  }
  _rpBuildMeshDestroy(v7);
  return 0;
}
// 21CAF0: using guessed type _DWORD var_11C[71];

//----- (0021CBB0) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldSectorGetWorld(const RpWorldSector_0 *sector)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r12
  RpWorld_0 *v3; // lr
  RpSector_0 *rootSector; // r4
  int v5; // r1
  __int64 v6; // kr00_8
  _DWORD v8[66]; // [sp+0h] [bp-108h]

  v2 = (char *)RwEngineInstance + worldModule + 4;
  v1 = (_DWORD *)*v2;
  if ( (_DWORD *)*v2 == v2 )
    return 0;
  while ( 1 )
  {
    v3 = (RpWorld_0 *)*(v1 - 2);
    if ( !(v3->object.privateFlags << 31) )
      break;
    if ( v3 <= (RpWorld_0 *)sector && (char *)v3 + *(v1 - 1) > (char *)sector )
      return v3;
LABEL_13:
    v1 = (_DWORD *)*v1;
    if ( v1 == v2 )
      return 0;
  }
  rootSector = v3->rootSector;
  v5 = 0;
  while ( 1 )
  {
    while ( rootSector->type > -1 )
    {
      v6 = *(_QWORD *)&rootSector[2].type;
      v8[++v5] = rootSector[3].type;
      rootSector = (RpSector_0 *)v6;
      if ( v5 <= -1 )
        goto LABEL_13;
    }
    if ( rootSector == (RpSector_0 *)sector )
      return v3;
    if ( rootSector )
    {
      rootSector = (RpSector_0 *)v8[v5--];
      if ( v5 > -1 )
        continue;
    }
    goto LABEL_13;
  }
}
// 6BD630: using guessed type int worldModule;

//----- (0021CC3C) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldForAllWorldSectors(RpWorld_0 *world, RpWorldSectorCallBack fpCallBack, void *pData)
{
  RpSector_0 *rootSector; // r0
  int i; // r5
  __int64 v7; // kr00_8
  _DWORD v9[70]; // [sp+0h] [bp-118h]

  rootSector = world->rootSector;
  for ( i = 0; i > -1; --i )
  {
    while ( rootSector->type > -1 )
    {
      v7 = *(_QWORD *)&rootSector[2].type;
      v9[++i] = rootSector[3].type;
      rootSector = (RpSector_0 *)v7;
      if ( i <= -1 )
        return world;
    }
    if ( !((int (*)(void))fpCallBack)() )
      break;
    rootSector = (RpSector_0 *)v9[i];
  }
  return world;
}

//----- (0021CC8C) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldRender(RpWorld_0 *world)
{
  RwCameraForAllSectorsInFrustum(*(RwCamera_0 **)RwEngineInstance, WorldSectorRender, world);
  return world;
}

//----- (0021CCB4) --------------------------------------------------------
RpWorldSector_0 *__fastcall WorldSectorRender(RpWorldSector_0 *sector, void *pData)
{
  RwLLLink *i; // r4
  RwLLLink *next; // r5
  const RwSphere_0 *WorldBoundingSphere; // r0
  RwLLLink *j; // r4
  RwLLLink *v7; // r5
  const RwSphere_0 *v8; // r0

  if ( RpWorldSectorRender(sector) )
  {
    for ( i = sector->collAtomicsInWorldSector.link.next; i != (RwLLLink *)&sector->collAtomicsInWorldSector; i = i->next )
    {
      next = i[1].next;
      if ( (BYTE2(next->next) & 4) != 0 && LOWORD(next[12].next) != *((unsigned __int16 *)RwEngineInstance + 4) )
      {
        WorldBoundingSphere = RpAtomicGetWorldBoundingSphere((RpAtomic_0 *)i[1].next);
        if ( RwCameraFrustumTestSphere(*(const RwCamera_0 **)RwEngineInstance, WorldBoundingSphere) )
          ((void (__fastcall *)(RwLLLink *))next[9].next)(next);
        LOWORD(next[12].next) = *((_WORD *)RwEngineInstance + 4);
      }
    }
    for ( j = sector->noCollAtomicsInWorldSector.link.next;
          j != (RwLLLink *)&sector->noCollAtomicsInWorldSector;
          j = j->next )
    {
      v7 = j[1].next;
      if ( (BYTE2(v7->next) & 4) != 0 && LOWORD(v7[12].next) != *((unsigned __int16 *)RwEngineInstance + 4) )
      {
        v8 = RpAtomicGetWorldBoundingSphere((RpAtomic_0 *)j[1].next);
        if ( RwCameraFrustumTestSphere(*(const RwCamera_0 **)RwEngineInstance, v8) )
          ((void (__fastcall *)(RwLLLink *))v7[9].next)(v7);
        LOWORD(v7[12].next) = *((_WORD *)RwEngineInstance + 4);
      }
    }
  }
  return sector;
}

//----- (0021CDB4) --------------------------------------------------------
RwBool __fastcall RpWorldDestroy(RpWorld_0 *world)
{
  int v2; // r0
  _DWORD **v3; // r2
  RpSector_0 *rootSector; // r4
  int i; // r5
  __int64 v6; // r0
  RpMeshHeader_0 *type; // r0
  RpSector_0 *v8; // r0
  _DWORD v10[70]; // [sp+0h] [bp-118h]

  v2 = worldModule;
  v3 = (_DWORD **)((char *)RwEngineInstance + worldModule + 4);
  while ( 1 )
  {
    v3 = (_DWORD **)*v3;
    if ( v3 == (_DWORD **)((char *)RwEngineInstance + worldModule + 4) )
      break;
    if ( *(v3 - 2) == (_DWORD *)world )
    {
      *v3[1] = *v3;
      (*v3)[1] = v3[1];
      (*((void (__fastcall **)(_DWORD, _DWORD **))RwEngineInstance + 80))(
        *(_DWORD *)((char *)RwEngineInstance + v2),
        v3 - 2);
      break;
    }
  }
  rootSector = world->rootSector;
  for ( i = 0; i > -1; --i )
  {
    while ( rootSector->type > -1 )
    {
      v6 = *(_QWORD *)&rootSector[2].type;
      v10[++i] = HIDWORD(v6);
      rootSector = (RpSector_0 *)v6;
      if ( i <= -1 )
        goto LABEL_12;
    }
    type = (RpMeshHeader_0 *)rootSector[32].type;
    if ( type )
    {
      _rpMeshDestroy(type);
      rootSector[32].type = 0;
    }
    rootSector = (RpSector_0 *)v10[i];
  }
LABEL_12:
  _rpMaterialListDeinitialize(&world->matList);
  v8 = world->rootSector;
  if ( world->object.privateFlags << 31 )
    WorldSectorDeinstanceAll(v8);
  else
    WorldSectorDestroyRecurse(v8);
  _rwPluginRegistryDeInitObject(&worldTKList, world);
  (*((void (__fastcall **)(RpWorld_0 *))RwEngineInstance + 76))(world);
  return 1;
}
// 6BD630: using guessed type int worldModule;

//----- (0021CEB4) --------------------------------------------------------
void __fastcall WorldSectorDeinstanceAll(RpSector_0 *a1)
{
  RwResEntry_0 *type; // r0
  RpTie_0 *v3; // r0
  RpTie_0 *next; // r6
  RpTie_0 *v5; // r0
  RpTie_0 *v6; // r6
  RpLightTie_0 *v7; // r0
  RpLightTie_0 *v8; // r6

  while ( a1->type != -2 )
  {
    if ( a1->type == -1 )
    {
      type = (RwResEntry_0 *)a1[13].type;
      if ( type )
        RwResourcesFreeResEntry(type);
      v3 = (RpTie_0 *)a1[14].type;
      if ( v3 != (RpTie_0 *)&a1[14] )
      {
        do
        {
          next = (RpTie_0 *)v3->lAtomicInWorldSector.next;
          _rpTieDestroy(v3);
          v3 = next;
        }
        while ( next != (RpTie_0 *)&a1[14] );
      }
      v5 = (RpTie_0 *)a1[16].type;
      if ( v5 != (RpTie_0 *)&a1[16] )
      {
        do
        {
          v6 = (RpTie_0 *)v5->lAtomicInWorldSector.next;
          _rpTieDestroy(v5);
          v5 = v6;
        }
        while ( v6 != (RpTie_0 *)&a1[16] );
      }
      v7 = (RpLightTie_0 *)a1[18].type;
      if ( v7 != (RpLightTie_0 *)&a1[18] )
      {
        do
        {
          v8 = (RpLightTie_0 *)v7->lightInWorldSector.next;
          _rpLightTieDestroy(v7);
          v7 = v8;
        }
        while ( v8 != (RpLightTie_0 *)&a1[18] );
      }
      sub_199CA0(&sectorTKList, a1);
      return;
    }
    WorldSectorDeinstanceAll(a1);
    a1 = (RpSector_0 *)a1[3].type;
  }
}

//----- (0021CF3C) --------------------------------------------------------
void __fastcall WorldSectorDestroyRecurse(RpSector_0 *sector)
{
  RwInt32 type; // r0
  RwResEntry_0 *v3; // r0
  RpTie_0 *v4; // r0
  RpSector_0 *next; // r6
  RpTie_0 *v6; // r0
  RpSector_0 *v7; // r6
  RpLightTie_0 *v8; // r0
  RpSector_0 *v9; // r6
  RpSector_0 *v10; // r0

  type = sector->type;
  if ( type != -2 )
  {
    if ( type == -1 )
    {
      v3 = (RwResEntry_0 *)sector[13].type;
      if ( v3 )
        RwResourcesFreeResEntry(v3);
      v4 = (RpTie_0 *)sector[14].type;
      if ( v4 != (RpTie_0 *)&sector[14] )
      {
        do
        {
          next = (RpSector_0 *)v4->lAtomicInWorldSector.next;
          _rpTieDestroy(v4);
          v4 = (RpTie_0 *)next;
        }
        while ( next != &sector[14] );
      }
      v6 = (RpTie_0 *)sector[16].type;
      if ( v6 != (RpTie_0 *)&sector[16] )
      {
        do
        {
          v7 = (RpSector_0 *)v6->lAtomicInWorldSector.next;
          _rpTieDestroy(v6);
          v6 = (RpTie_0 *)v7;
        }
        while ( v7 != &sector[16] );
      }
      v8 = (RpLightTie_0 *)sector[18].type;
      if ( v8 != (RpLightTie_0 *)&sector[18] )
      {
        do
        {
          v9 = (RpSector_0 *)v8->lightInWorldSector.next;
          _rpLightTieDestroy(v8);
          v8 = (RpLightTie_0 *)v9;
        }
        while ( v9 != &sector[18] );
      }
      _rwPluginRegistryDeInitObject(&sectorTKList, sector);
      if ( sector[2].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[2].type = 0;
      }
      if ( sector[3].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[3].type = 0;
      }
      if ( sector[12].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[12].type = 0;
      }
      if ( sector[1].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[1].type = 0;
      }
      if ( sector[4].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[4].type = 0;
      }
      if ( sector[5].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[5].type = 0;
      }
      if ( sector[6].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[6].type = 0;
      }
      if ( sector[7].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[7].type = 0;
      }
      if ( sector[8].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[8].type = 0;
      }
      if ( sector[9].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[9].type = 0;
      }
      if ( sector[10].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[10].type = 0;
      }
      if ( sector[11].type )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        sector[11].type = 0;
      }
    }
    else
    {
      WorldSectorDestroyRecurse((RpSector_0 *)sector[2].type);
      v10 = (RpSector_0 *)sector[3].type;
      sector[2].type = 0;
      WorldSectorDestroyRecurse(v10);
      sector[3].type = 0;
    }
  }
  (*((void (__fastcall **)(RpSector_0 *))RwEngineInstance + 76))(sector);
}

//----- (0021D12C) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldSetSectorRenderCallBack(RpWorld_0 *world, RpWorldSectorCallBackRender fpCallBack)
{
  if ( !fpCallBack )
    fpCallBack = _rpSectorDefaultRenderCallBack;
  world->renderCallBack = fpCallBack;
  return world;
}

//----- (0021D140) --------------------------------------------------------
RpWorldSectorCallBackRender __fastcall RpWorldGetSectorRenderCallBack(const RpWorld_0 *world)
{
  return world->renderCallBack;
}

//----- (0021D144) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldCreate(RwBBox_0 *boundingBox)
{
  int v2; // r0
  int v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r5
  __int64 v6; // r0
  __int64 v7; // d16
  __int64 v8; // d16
  __int64 v9; // d16
  __int64 v10; // d16
  __int64 v11; // d16
  __int64 v12; // d16
  RwInt32 sizeOfStruct; // r6
  int *v14; // r0
  char *v15; // r1
  _DWORD *v16; // r0
  RwError_0 v18[4]; // [sp+0h] [bp-20h] BYREF

  v2 = (*((int (__fastcall **)(RwInt32))RwEngineInstance + 75))(worldTKList.sizeOfStruct);
  v3 = v2;
  if ( v2 )
  {
    *(_BYTE *)(v2 + 7) = 0;
    *(_WORD *)(v2 + 5) = 0;
    *(_DWORD *)(v2 + 1) = 0;
    *(_BYTE *)v2 = 7;
    _rpMaterialListInitialize((RpMaterialList_0 *)(v2 + 16));
    *(_DWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 12) = 2;
    v4 = (_DWORD *)(*((int (__fastcall **)(RwInt32))RwEngineInstance + 75))(sectorTKList.sizeOfStruct);
    v5 = v4;
    if ( !v4 )
    {
      v18[0].pluginID = 0;
      v18[0].errorCode = _rwerror(-2147483629, 4);
      RwErrorSet(v18);
      (*((void (__fastcall **)(int))RwEngineInstance + 76))(v3);
      return 0;
    }
    HIDWORD(v6) = v4 + 16;
    *v4 = -1;
    LODWORD(v6) = v4 + 14;
    v5[32] = 0;
    v5[13] = 0;
    v5[14] = v5 + 14;
    *(_QWORD *)(v5 + 15) = v6;
    v5[17] = v5 + 16;
    v5[18] = v5 + 18;
    v5[19] = v5 + 18;
    *(_QWORD *)(v5 + 9) = 0LL;
    *(_QWORD *)(v5 + 11) = 0LL;
    *(_QWORD *)(v5 + 5) = 0LL;
    *(_QWORD *)(v5 + 7) = 0LL;
    *(_QWORD *)(v5 + 1) = 0LL;
    *(_QWORD *)(v5 + 3) = 0LL;
    *(_DWORD *)((char *)v5 + 138) = 0;
    v7 = *(_QWORD *)&boundingBox->inf.x;
    v5[25] = LODWORD(boundingBox->inf.z);
    *(_QWORD *)(v5 + 23) = v7;
    v8 = *(_QWORD *)&boundingBox->sup.x;
    v5[22] = LODWORD(boundingBox->sup.z);
    *((_QWORD *)v5 + 10) = v8;
    v9 = *(_QWORD *)&boundingBox->inf.x;
    v5[31] = LODWORD(boundingBox->inf.z);
    *(_QWORD *)(v5 + 29) = v9;
    v10 = *(_QWORD *)&boundingBox->sup.x;
    v5[28] = LODWORD(boundingBox->sup.z);
    *((_QWORD *)v5 + 13) = v10;
    v5[33] = 0;
    *(_DWORD *)(v3 + 28) = v5;
    *(_DWORD *)(v3 + 32) = 0;
    *(_DWORD *)(v3 + 68) = 0;
    *(_DWORD *)(v3 + 72) = 0;
    *(_DWORD *)(v3 + 76) = 0;
    v11 = *(_QWORD *)&boundingBox->inf.x;
    *(RwReal *)(v3 + 100) = boundingBox->inf.z;
    *(_QWORD *)(v3 + 92) = v11;
    v12 = *(_QWORD *)&boundingBox->sup.x;
    *(RwReal *)(v3 + 88) = boundingBox->sup.z;
    *(_DWORD *)(v3 + 36) = 0;
    *(_DWORD *)(v3 + 40) = v3 + 44;
    *(_DWORD *)(v3 + 44) = v3 + 44;
    *(_DWORD *)(v3 + 48) = v3 + 44;
    *(_DWORD *)(v3 + 52) = v3 + 52;
    *(_DWORD *)(v3 + 56) = v3 + 52;
    *(_DWORD *)(v3 + 60) = v3 + 60;
    *(_DWORD *)(v3 + 64) = v3 + 60;
    *(_DWORD *)(v3 + 104) = _rpSectorDefaultRenderCallBack;
    *(_DWORD *)(v3 + 108) = 0;
    *(_QWORD *)(v3 + 80) = v12;
    sizeOfStruct = worldTKList.sizeOfStruct;
    v14 = (int *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                   + worldModule));
    if ( v14 )
    {
      v14[1] = sizeOfStruct;
      *v14 = v3;
      v15 = (char *)RwEngineInstance + worldModule + 4;
      v14[2] = *(_DWORD *)v15;
      v14[3] = (int)v15;
      v16 = v14 + 2;
      *(_DWORD *)(*(_DWORD *)v15 + 4) = v16;
      *(_DWORD *)v15 = v16;
    }
    _rwPluginRegistryInitObject(&worldTKList, (void *)v3);
    _rwPluginRegistryInitObject(&sectorTKList, v5);
    if ( !RpWorldUnlock((RpWorld_0 *)v3) )
    {
      RpWorldDestroy((RpWorld_0 *)v3);
      return 0;
    }
  }
  else
  {
    v3 = 0;
    v18[0].pluginID = 0;
    v18[0].errorCode = _rwerror(-2147483629, worldTKList.sizeOfStruct);
    RwErrorSet(v18);
  }
  return (RpWorld_0 *)v3;
}
// 6BD630: using guessed type int worldModule;

//----- (0021D370) --------------------------------------------------------
RwBool __fastcall RpWorldInstance(RpWorld_0 *world)
{
  RwUInt32 flags; // r0
  RpSector_0 *rootSector; // r5
  int i; // r6
  __int64 v5; // r0
  RwResEntry_0 *type; // r0
  _DWORD v8[68]; // [sp+0h] [bp-110h]

  flags = world->flags;
  if ( (flags & 0x1000000) == 0 )
  {
    world->flags = flags | 0x2000000;
    rootSector = world->rootSector;
    for ( i = 0; i > -1; --i )
    {
      while ( rootSector->type > -1 )
      {
        v5 = *(_QWORD *)&rootSector[2].type;
        v8[++i] = HIDWORD(v5);
        rootSector = (RpSector_0 *)v5;
        if ( i <= -1 )
          goto LABEL_9;
      }
      type = (RwResEntry_0 *)rootSector[13].type;
      if ( type )
        RwResourcesFreeResEntry(type);
      RpWorldSectorRender((RpWorldSector_0 *)rootSector);
      rootSector = (RpSector_0 *)v8[i];
    }
LABEL_9:
    world->flags = world->flags & 0xFCFFFFFF | 0x1000000;
  }
  return 1;
}

//----- (0021D3E6) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldForAllClumps(RpWorld_0 *world, RpClumpCallBack fpCallBack, void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_clumpList; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_clumpList = &world->clumpList;
  next = world->clumpList.link.next;
  if ( next != (RwLLLink *)p_clumpList )
  {
    do
    {
      if ( p_clumpList == (RwLinkList_0 *)next )
        break;
      v8 = next->next;
      v9 = (int)fpCallBack((RpClump_0 *)&next[-4], pData) == 0;
      next = v8;
    }
    while ( !v9 );
  }
  return world;
}

//----- (0021D418) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldForAllMaterials(RpWorld_0 *world, RpMaterialCallBack fpCallBack, void *pData)
{
  RwInt32 numMaterials; // r4
  RwInt32 i; // r6

  numMaterials = world->matList.numMaterials;
  if ( numMaterials >= 1 )
  {
    for ( i = 0; i < numMaterials; ++i )
    {
      if ( !(int)fpCallBack(world->matList.materials[i], pData) )
        break;
    }
  }
  return world;
}

//----- (0021D448) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldForAllLights(RpWorld_0 *world, RpLightCallBack fpCallBack, void *pData)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_directionalLightList; // r5
  RwLLLink *v8; // r4
  bool v9; // zf
  RwLLLink *v10; // r0
  RwLLLink *v11; // r4

  p_directionalLightList = &world->directionalLightList;
  next = world->directionalLightList.link.next;
  if ( next != (RwLLLink *)p_directionalLightList )
  {
    while ( p_directionalLightList != (RwLinkList_0 *)next )
    {
      v8 = next->next;
      v9 = (int)fpCallBack((RpLight_0 *)&next[-7].prev, pData) == 0;
      next = v8;
      if ( v9 )
        return world;
    }
  }
  v10 = world->lightList.link.next;
  if ( v10 != (RwLLLink *)&world->lightList )
  {
    do
    {
      if ( &world->lightList == (RwLinkList_0 *)v10 )
        break;
      v11 = v10->next;
      v9 = (int)fpCallBack((RpLight_0 *)&v10[-7].prev, pData) == 0;
      v10 = v11;
    }
    while ( !v9 );
  }
  return world;
}

//----- (0021D498) --------------------------------------------------------
RwInt32 __fastcall RpWorldRegisterPlugin(
        RwInt32 size,
        RwUInt32 pluginID,
        RwPluginObjectConstructor constructCB,
        RwPluginObjectDestructor destructCB,
        RwPluginObjectCopy copyCB)
{
  return _rwPluginRegistryAddPlugin(&worldTKList, size, pluginID, constructCB, destructCB, copyCB);
}

//----- (0021D4C4) --------------------------------------------------------
RwInt32 __fastcall RpWorldRegisterPluginStream(
        RwUInt32 pluginID,
        RwPluginDataChunkReadCallBack readCB,
        RwPluginDataChunkWriteCallBack writeCB,
        RwPluginDataChunkGetSizeCallBack getSizeCB)
{
  return _rwPluginRegistryAddPluginStream(&worldTKList, pluginID, readCB, writeCB, getSizeCB);
}

//----- (0021D4E8) --------------------------------------------------------
RwInt32 __fastcall RpWorldSetStreamAlwaysCallBack(RwUInt32 pluginID, RwPluginDataChunkAlwaysCallBack alwaysCB)
{
  return sub_196434(&worldTKList, pluginID, alwaysCB);
}

//----- (0021D4FC) --------------------------------------------------------
RwInt32 __fastcall RpWorldSetStreamRightsCallBack(RwUInt32 pluginID, RwPluginDataChunkRightsCallBack rightsCB)
{
  return sub_19E33C(&worldTKList, pluginID, rightsCB);
}

//----- (0021D510) --------------------------------------------------------
RwInt32 __fastcall RpWorldGetPluginOffset(RwUInt32 pluginID)
{
  return sub_18F574(&worldTKList, pluginID);
}

//----- (0021D520) --------------------------------------------------------
RwBool __fastcall RpWorldValidatePlugins(RpWorld_0 *world)
{
  return 1;
}

//----- (0021D524) --------------------------------------------------------
bool RpWorldPluginAttach()
{
  RwInt32 v0; // r10
  RwInt32 v1; // r4
  int v2; // r10
  RwInt32 v3; // r4
  int v4; // r6
  int v5; // r5
  int v6; // r5
  int v7; // r4

  v0 = RwEngineRegisterPlugin(4, 0x501u, _rpMaterialOpen, _rpMaterialClose);
  v1 = RwEngineRegisterPlugin(48, 0x502u, _rpMeshOpen, _rpMeshClose);
  v2 = v1 | v0 | RwEngineRegisterPlugin(4, 0x503u, _rpGeometryOpen, _rpGeometryClose);
  v3 = RwEngineRegisterPlugin(8, 0x504u, _rpClumpOpen, _rpClumpClose);
  v4 = 0;
  v5 = v2 | v3 | RwEngineRegisterPlugin(4, 0x505u, _rpLightOpen, _rpLightClose);
  v6 = v5 | RwEngineRegisterPlugin(0, 0x50Au, _rpSectorOpen, _rpSectorClose);
  v7 = v6 | RwEngineRegisterPlugin(12, 0x507u, WorldOpen, WorldClose);
  if ( (RwEngineRegisterPlugin(0, 0x50Bu, _rpBinaryWorldOpen, _rpBinaryWorldClose) | v7) >= 0 )
    return _rpWorldObjRegisterExtensions() && _rpClumpRegisterExtensions() && _rxWorldDevicePluginAttach() != 0;
  return v4;
}

//----- (0021D678) --------------------------------------------------------
void *__fastcall WorldOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r1

  worldModule = offset;
  if ( !_rpWorldPipelineOpen() )
    return 0;
  v4 = RwFreeListCreateAndPreallocateSpace(16, 8, 4, 1, &_rpWorldListFreeList);
  v5 = worldModule;
  *(_DWORD *)((char *)RwEngineInstance + worldModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 4) = (char *)RwEngineInstance + v5 + 4;
  *(_DWORD *)((char *)RwEngineInstance + v5 + 8) = (char *)RwEngineInstance + v5 + 4;
  ++worldModule;
  return instance;
}
// 6BD630: using guessed type int worldModule;
// 6BD634: using guessed type int worldModule;

//----- (0021D6F4) --------------------------------------------------------
void *__fastcall WorldClose(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0

  v4 = *(RwFreeList_0 **)((char *)RwEngineInstance + worldModule);
  if ( v4 )
  {
    RwFreeListDestroy(v4);
    *(_DWORD *)((char *)RwEngineInstance + worldModule) = 0;
  }
  _rpWorldPipelineClose();
  --worldModule;
  return instance;
}
// 6BD630: using guessed type int worldModule;
// 6BD634: using guessed type int worldModule;

//----- (0021D748) --------------------------------------------------------
void __fastcall RpTieSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpTieFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpTieFreeListBlockSize = blockSize;
}

//----- (0021D760) --------------------------------------------------------
void __fastcall RpLightTieSetFreeListCreateParams(RwInt32 blockSize, RwInt32 numBlocksToPrealloc)
{
  _rpLightTieFreeListPreallocBlocks = numBlocksToPrealloc;
  _rpLightTieFreeListBlockSize = blockSize;
}

//----- (0021D778) --------------------------------------------------------
RwBool __fastcall _rpLightTieDestroy(RpLightTie_0 *tie)
{
  tie->WorldSectorInLight.prev->next = tie->WorldSectorInLight.next;
  tie->WorldSectorInLight.next->prev = tie->WorldSectorInLight.prev;
  tie->lightInWorldSector.prev->next = tie->lightInWorldSector.next;
  tie->lightInWorldSector.next->prev = tie->lightInWorldSector.prev;
  (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule + 4));
  return 1;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021D7C4) --------------------------------------------------------
RwBool __fastcall _rpTieDestroy(RpTie_0 *tie)
{
  RpAtomic_0 *apAtom; // r0
  bool v3; // zf

  apAtom = tie->apAtom;
  v3 = apAtom == 0;
  if ( apAtom )
    v3 = tie->worldSector == 0;
  if ( !v3 )
  {
    tie->lWorldSectorInAtomic.prev->next = tie->lWorldSectorInAtomic.next;
    tie->lWorldSectorInAtomic.next->prev = tie->lWorldSectorInAtomic.prev;
    tie->lAtomicInWorldSector.prev->next = tie->lAtomicInWorldSector.next;
    tie->lAtomicInWorldSector.next->prev = tie->lAtomicInWorldSector.prev;
    (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule));
  }
  return 1;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021D818) --------------------------------------------------------
bool _rpWorldObjRegisterExtensions()
{
  int v0; // r5
  RwInt32 v1; // r6
  RwInt32 v2; // r4
  RwInt32 v3; // r8
  RwInt32 v4; // r11
  RwInt32 v5; // r9
  RwInt32 v6; // r10
  int v7; // r4
  int v8; // r4
  RwInt32 v10; // [sp+4h] [bp-44h]
  RwInt32 v11; // [sp+8h] [bp-40h]
  RwInt32 v12; // [sp+Ch] [bp-3Ch]
  RwInt32 v13; // [sp+10h] [bp-38h]
  RwInt32 v14; // [sp+14h] [bp-34h]
  RwInt32 v15; // [sp+18h] [bp-30h]
  RwInt32 v16; // [sp+1Ch] [bp-2Ch]
  RwInt32 v17; // [sp+20h] [bp-28h]
  RwInt32 v18; // [sp+24h] [bp-24h]
  RwInt32 v19; // [sp+28h] [bp-20h]

  v19 = RwEngineRegisterPlugin(8, 0x509u, WorldObjectOpen, WorldObjectClose);
  v18 = RwCameraRegisterPlugin(28, 0x509u, WorldInitCameraExt, WorldDeInitCameraExt, WorldCopyCameraExt);
  cameraExtOffset = v18;
  v17 = RpAtomicRegisterPlugin(8, 0x509u, WorldInitAtomicExt, WorldDeInitAtomicExt, WorldCopyAtomicExt);
  atomicExtOffset = v17;
  v16 = RpClumpRegisterPlugin(4, 0x509u, WorldInitClumpExt, WorldDeInitClumpExt, WorldCopyClumpExt);
  clumpExtOffset = v16;
  v0 = 0;
  v15 = RpLightRegisterPlugin(8, 0x509u, WorldInitLightExt, WorldDeInitLightExt, WorldCopyLightExt);
  lightExtOffset = v15;
  v14 = RpGeometryRegisterPlugin(0, 0x50Eu, 0, 0, 0);
  v13 = RpWorldSectorRegisterPlugin(0, 0x50Eu, 0, 0, 0);
  v12 = RpGeometryRegisterPluginStream(0x50Eu, readGeometryMesh, writeGeometryMesh, sizeGeometryMesh);
  v11 = RpWorldSectorRegisterPluginStream(0x50Eu, readSectorMesh, writeSectorMesh, sizeSectorMesh);
  v10 = RpGeometryRegisterPlugin(0, 0x510u, 0, 0, 0);
  v1 = RpWorldSectorRegisterPlugin(0, 0x510u, 0, 0, 0);
  v2 = RpGeometryRegisterPluginStream(0x510u, readGeometryNative, writeGeometryNative, sizeGeometryNative);
  v3 = RpWorldSectorRegisterPluginStream(0x510u, readWorldSectorNative, writeWorldSectorNative, sizeWorldSectorNative);
  v4 = RpAtomicRegisterPlugin(0, 0x1Fu, 0, 0, 0);
  v5 = RpAtomicRegisterPluginStream(0x1Fu, _rpReadAtomicRights, _rpWriteAtomicRights, _rpSizeAtomicRights);
  v6 = RpWorldRegisterPlugin(0, 0x1Fu, 0, 0, 0);
  v7 = v19 | v18 | v17 | v16 | v15 | v14 | v13 | v12 | v11 | v10 | v1 | v2 | v3 | v4 | v5 | v6 | RpWorldRegisterPluginStream(
                                                                                                   0x1Fu,
                                                                                                   _rpReadWorldRights,
                                                                                                   _rpWriteWorldRights,
                                                                                                   _rpSizeWorldRights);
  v8 = v7 | RpWorldSectorRegisterPlugin(0, 0x1Fu, 0, 0, 0);
  if ( (RpWorldSectorRegisterPluginStream(0x1Fu, _rpReadSectRights, _rpWriteSectRights, _rpSizeSectRights) | v8) >= 0 )
    return _rpWorldPipeAttach() != 0;
  return v0;
}

//----- (0021DAD4) --------------------------------------------------------
void *__fastcall WorldObjectOpen(void *instance, RwInt32 offset, RwInt32 size)
{
  RwFreeList_0 *v4; // r0
  int v5; // r2
  RwFreeList_0 *v6; // r0
  int v7; // r2

  worldObjModule = offset;
  v4 = RwFreeListCreateAndPreallocateSpace(
         24,
         _rpTieFreeListBlockSize,
         4,
         _rpTieFreeListPreallocBlocks,
         &_rpTieFreeList);
  v5 = worldObjModule;
  *(_DWORD *)((char *)RwEngineInstance + worldObjModule) = v4;
  if ( !*(_DWORD *)((char *)RwEngineInstance + v5) )
    return 0;
  v6 = RwFreeListCreateAndPreallocateSpace(
         24,
         _rpLightTieFreeListBlockSize,
         4,
         _rpLightTieFreeListPreallocBlocks,
         &_rpLightTieFreeList);
  v7 = worldObjModule;
  *(_DWORD *)((char *)RwEngineInstance + worldObjModule + 4) = v6;
  if ( *(_DWORD *)((char *)RwEngineInstance + v7 + 4) )
  {
    *((_WORD *)RwEngineInstance + 4) = 1;
    ++worldObjModule;
  }
  else
  {
    RwFreeListDestroy(*(RwFreeList_0 **)((char *)RwEngineInstance + v7));
    instance = 0;
    *(_DWORD *)((char *)RwEngineInstance + worldObjModule) = 0;
  }
  return instance;
}
// 6BD690: using guessed type int worldObjModule;
// 6BD694: using guessed type int worldObjModule;

//----- (0021DBAC) --------------------------------------------------------
void *__fastcall WorldObjectClose(void *instance, RwInt32 offset, RwInt32 size)
{
  int v4; // r1
  char *v5; // r2
  RwFreeList_0 *v6; // r0
  RwFreeList_0 *v7; // r0

  v4 = worldObjModule;
  v5 = (char *)RwEngineInstance;
  v6 = *(RwFreeList_0 **)((char *)RwEngineInstance + worldObjModule + 4);
  if ( v6 )
  {
    RwFreeListDestroy(v6);
    v4 = worldObjModule;
    *(_DWORD *)((char *)RwEngineInstance + worldObjModule + 4) = 0;
    v5 = (char *)RwEngineInstance;
  }
  v7 = *(RwFreeList_0 **)&v5[v4];
  if ( v7 )
  {
    RwFreeListDestroy(v7);
    *(_DWORD *)((char *)RwEngineInstance + worldObjModule) = 0;
  }
  --worldObjModule;
  return instance;
}
// 6BD690: using guessed type int worldObjModule;
// 6BD694: using guessed type int worldObjModule;

//----- (0021DC24) --------------------------------------------------------
void *__fastcall WorldInitCameraExt(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  RwInt32 v3; // r1
  _DWORD *v4; // r1

  v3 = cameraExtOffset;
  *(_DWORD *)((char *)object + cameraExtOffset) = 0;
  v4 = (char *)object + v3;
  v4[1] = 0;
  v4[2] = 0;
  v4[4] = *((_DWORD *)object + 6);
  v4[5] = *((_DWORD *)object + 7);
  v4[6] = *((_DWORD *)object + 4);
  *((_DWORD *)object + 6) = WorldCameraBeginUpdate;
  *((_DWORD *)object + 7) = WorldCameraEndUpdate;
  *((_DWORD *)object + 4) = WorldCameraSync;
  v4[3] = 0;
  return object;
}

//----- (0021DC70) --------------------------------------------------------
void *__fastcall WorldDeInitCameraExt(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  _DWORD *v4; // r5

  v4 = (char *)object + cameraExtOffset;
  if ( *(_DWORD *)((char *)object + cameraExtOffset) )
    (*((void (**)(void))RwEngineInstance + 76))();
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  *((_DWORD *)object + 6) = v4[4];
  *((_DWORD *)object + 7) = v4[5];
  *((_DWORD *)object + 4) = v4[6];
  return object;
}

//----- (0021DCB0) --------------------------------------------------------
void *__fastcall WorldCopyCameraExt(
        void *dstObject,
        const void *srcObject,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwInt32 v5; // r0
  _DWORD *v6; // r5
  int v7; // r6
  RwFrame_0 *v8; // r0

  v5 = cameraExtOffset;
  v6 = (char *)dstObject + cameraExtOffset;
  *v6 = 0;
  v6[1] = 0;
  v6[2] = 0;
  v7 = *(_DWORD *)((char *)srcObject + v5 + 12);
  if ( v7 )
  {
    v8 = (RwFrame_0 *)*((_DWORD *)dstObject + 1);
    if ( v8 )
      RwFrameUpdateObjects(v8);
    v6[3] = v7;
  }
  return dstObject;
}

//----- (0021DCE8) --------------------------------------------------------
void *__fastcall WorldInitAtomicExt(void *object, RwInt32 offset, RwInt32 size)
{
  RwInt32 v3; // r1
  int v4; // r3

  v3 = atomicExtOffset;
  *(_DWORD *)((char *)object + atomicExtOffset) = 0;
  v4 = *((_DWORD *)object + 4);
  *((_WORD *)object + 48) = *((_WORD *)RwEngineInstance + 4) - 1;
  *(_DWORD *)((char *)object + v3 + 4) = v4;
  *((_DWORD *)object + 4) = WorldAtomicSync;
  return object;
}

//----- (0021DD28) --------------------------------------------------------
void *__fastcall WorldDeInitAtomicExt(void *object, RwInt32 offset, RwInt32 size)
{
  char *v4; // r5
  char *v5; // r6
  char *v6; // r8
  char *v7; // r0
  char *v8; // r1
  bool v9; // zf

  v4 = (char *)object + 100;
  v5 = (char *)*((_DWORD *)object + 25);
  v6 = (char *)object + atomicExtOffset;
  if ( v5 != (char *)object + 100 )
  {
    do
    {
      while ( 1 )
      {
        v7 = v5;
        v8 = (char *)*((_DWORD *)v5 - 1);
        v5 = *(char **)v5;
        v9 = v8 == 0;
        if ( v8 )
        {
          v8 = v7 - 12;
          v9 = *((_DWORD *)v7 + 2) == 0;
        }
        if ( !v9 )
          break;
        if ( v5 == v4 )
          goto LABEL_9;
      }
      **((_DWORD **)v8 + 4) = v5;
      *(_DWORD *)(*((_DWORD *)v8 + 3) + 4) = *((_DWORD *)v8 + 4);
      **((_DWORD **)v8 + 1) = *(_DWORD *)v8;
      *(_DWORD *)(*(_DWORD *)v8 + 4) = *((_DWORD *)v8 + 1);
      (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule));
    }
    while ( v5 != v4 );
  }
LABEL_9:
  *((_DWORD *)object + 4) = *((_DWORD *)v6 + 1);
  return object;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021DDB8) --------------------------------------------------------
void *__fastcall WorldInitClumpExt(void *object, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)object + clumpExtOffset) = 0;
  return object;
}

//----- (0021DDCC) --------------------------------------------------------
void *__fastcall WorldCopyClumpExt(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  RpWorld_0 *v5; // r0

  v5 = *(RpWorld_0 **)((char *)srcObject + clumpExtOffset);
  if ( v5 )
    RpWorldAddClump(v5, (RpClump_0 *)dstObject);
  return dstObject;
}

//----- (0021DDEC) --------------------------------------------------------
void *__fastcall WorldInitLightExt(void *object, RwInt32 offset, RwInt32 size)
{
  RwInt32 v3; // r1

  v3 = lightExtOffset;
  *(_DWORD *)((char *)object + lightExtOffset) = 0;
  *(_DWORD *)((char *)object + v3 + 4) = *((_DWORD *)object + 4);
  *((_DWORD *)object + 4) = WorldLightSync;
  return object;
}

//----- (0021DE0C) --------------------------------------------------------
void *__fastcall WorldDeInitLightExt(void *object, RwInt32 offset, RwInt32 size)
{
  _DWORD **v4; // r1
  char *v5; // r5
  __int64 v6; // kr00_8
  _DWORD **v7; // r1
  int v8; // t1

  v5 = (char *)object + 44;
  v4 = (_DWORD **)*((_DWORD *)object + 11);
  if ( v4 != (_DWORD **)((char *)object + 44) )
  {
    do
    {
      v6 = *(_QWORD *)v4;
      *v4[1] = *v4;
      (*v4)[1] = v4[1];
      v8 = (int)*(v4 - 3);
      v7 = v4 - 3;
      *v7[1] = v8;
      (*v7)[1] = v7[1];
      (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule + 4));
      v4 = (_DWORD **)v6;
    }
    while ( (char *)v6 != v5 );
  }
  return object;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021DE6C) --------------------------------------------------------
void *__fastcall WorldCopyLightExt(void *dstObject, const void *srcObject, RwInt32 offset, RwInt32 size)
{
  int v5; // r5
  int v6; // r0
  RwFrame_0 *v7; // r0

  v5 = *(_DWORD *)((char *)srcObject + lightExtOffset);
  if ( v5 )
  {
    *(_DWORD *)((char *)dstObject + lightExtOffset) = v5;
    if ( *((char *)dstObject + 1) < 0 )
    {
      v7 = (RwFrame_0 *)*((_DWORD *)dstObject + 1);
      if ( v7 )
        RwFrameUpdateObjects(v7);
      v6 = v5 + 52;
    }
    else
    {
      v6 = v5 + 60;
    }
    *((_DWORD *)dstObject + 13) = *(_DWORD *)v6;
    *((_DWORD *)dstObject + 14) = v6;
    *(_DWORD *)(*(_DWORD *)v6 + 4) = (char *)dstObject + 52;
    *(_DWORD *)v6 = (char *)dstObject + 52;
  }
  return dstObject;
}

//----- (0021DEB4) --------------------------------------------------------
RwStream_0 *__fastcall readGeometryMesh(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *result; // r0

  result = (RwStream_0 *)_rpMeshRead(stream, object, (const RpMaterialList_0 *)((char *)object + 32));
  *((_DWORD *)object + 22) = result;
  if ( result )
    return stream;
  return result;
}

//----- (0021DED0) --------------------------------------------------------
RwStream_0 *__fastcall writeGeometryMesh(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  return j__rpMeshWrite(
           *((const RpMeshHeader_0 **)object + 22),
           object,
           stream,
           (const RpMaterialList_0 *)((char *)object + 32));
}

//----- (0021DEE0) --------------------------------------------------------
RwInt32 __fastcall sizeGeometryMesh(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  return sub_18F460(*((const RpMeshHeader_0 **)object + 22), object);
}

//----- (0021DEE8) --------------------------------------------------------
RwStream_0 *__fastcall readSectorMesh(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RpWorld_0 *World; // r0
  RwStream_0 *result; // r0

  World = RpWorldSectorGetWorld((const RpWorldSector_0 *)object);
  result = (RwStream_0 *)_rpMeshRead(stream, World, &World->matList);
  *((_DWORD *)object + 32) = result;
  if ( result )
    return stream;
  return result;
}

//----- (0021DF0E) --------------------------------------------------------
RwStream_0 *__fastcall writeSectorMesh(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RpWorld_0 *World; // r1

  World = RpWorldSectorGetWorld((const RpWorldSector_0 *)object);
  return j__rpMeshWrite(*((const RpMeshHeader_0 **)object + 32), World, stream, &World->matList);
}

//----- (0021DF30) --------------------------------------------------------
RwInt32 __fastcall sizeSectorMesh(const void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  const RpMeshHeader_0 *v3; // r4
  RpWorld_0 *World; // r1

  v3 = (const RpMeshHeader_0 *)*((_DWORD *)object + 32);
  World = RpWorldSectorGetWorld((const RpWorldSector_0 *)object);
  return sub_18F460(v3, World);
}

//----- (0021DF48) --------------------------------------------------------
RwStream_0 *__fastcall readGeometryNative(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *result; // r0

  result = (RwStream_0 *)_rpGeometryNativeRead(stream, (RpGeometry_0 *)object);
  if ( result )
    return stream;
  return result;
}

//----- (0021DF5C) --------------------------------------------------------
RwStream_0 *__fastcall writeGeometryNative(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  return sub_199DC4(stream, (const RpGeometry_0 *)object);
}

//----- (0021DF66) --------------------------------------------------------
RwStream_0 *__fastcall readWorldSectorNative(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  RwStream_0 *result; // r0

  result = (RwStream_0 *)_rpWorldSectorNativeRead(stream, (RpWorldSector_0 *)object);
  if ( result )
    return stream;
  return result;
}

//----- (0021DF7A) --------------------------------------------------------
RwStream_0 *__fastcall writeWorldSectorNative(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  return sub_199B04(stream, (const RpWorldSector_0 *)object);
}

//----- (0021DF84) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldAddCamera(RpWorld_0 *world, RwCamera_0 *camera)
{
  RwFrame_0 *parent; // r0
  RwUInt8 *v4; // r5
  RpWorld_0 *result; // r0

  parent = (RwFrame_0 *)camera->object.object.parent;
  v4 = &camera->object.object.type + cameraExtOffset;
  if ( parent )
    RwFrameUpdateObjects(parent);
  result = world;
  *((_DWORD *)v4 + 3) = world;
  return result;
}

//----- (0021DFA8) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldRemoveCamera(RpWorld_0 *world, RwCamera_0 *camera)
{
  RwUInt8 *v3; // r5

  v3 = &camera->object.object.type + cameraExtOffset;
  if ( !*(RwLLLink **)((char *)&camera->object.lFrame.prev + cameraExtOffset) )
    return 0;
  if ( *(_DWORD *)v3 )
    (*((void (**)(void))RwEngineInstance + 76))();
  *(_DWORD *)v3 = 0;
  *((_DWORD *)v3 + 1) = 0;
  *((_DWORD *)v3 + 2) = 0;
  *((_DWORD *)v3 + 3) = 0;
  return world;
}

//----- (0021DFE8) --------------------------------------------------------
RpWorld_0 *__fastcall RwCameraGetWorld(const RwCamera_0 *camera)
{
  return *(RpWorld_0 **)((char *)&camera->object.lFrame.prev + cameraExtOffset);
}

//----- (0021DFF8) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldAddAtomic(RpWorld_0 *world, RpAtomic_0 *atomic)
{
  RwFrame_0 *parent; // r0
  RwInt32 v5; // r6

  parent = (RwFrame_0 *)atomic->object.object.parent;
  v5 = atomicExtOffset;
  if ( parent )
    RwFrameUpdateObjects(parent);
  *(_DWORD *)(&atomic->object.object.type + v5) = world;
  return world;
}

//----- (0021E024) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldRemoveAtomic(RpWorld_0 *world, RpAtomic_0 *atomic)
{
  RwResEntry_0 *repEntry; // r0
  RwInt32 v5; // r9
  RwLinkList_0 *p_llWorldSectorsInAtomic; // r5
  RpAtomic_0 *next; // r6
  RpAtomic_0 *v8; // r0
  RxPipeline_0 *pipeline; // r1
  bool v10; // zf

  repEntry = atomic->repEntry;
  v5 = atomicExtOffset;
  if ( repEntry )
    RwResourcesFreeResEntry(repEntry);
  p_llWorldSectorsInAtomic = &atomic->llWorldSectorsInAtomic;
  next = (RpAtomic_0 *)atomic->llWorldSectorsInAtomic.link.next;
  if ( next != (RpAtomic_0 *)&atomic->llWorldSectorsInAtomic )
  {
    do
    {
      while ( 1 )
      {
        v8 = next;
        pipeline = next[-1].pipeline;
        next = *(RpAtomic_0 **)&next->object.object.type;
        v10 = pipeline == 0;
        if ( pipeline )
        {
          pipeline = (RxPipeline_0 *)&v8[-1].llWorldSectorsInAtomic;
          v10 = v8->object.lFrame.next == 0;
        }
        if ( !v10 )
          break;
        if ( next == (RpAtomic_0 *)p_llWorldSectorsInAtomic )
          goto LABEL_11;
      }
      *(_DWORD *)pipeline->embeddedPacketState = next;
      *(_DWORD *)(pipeline->packetNumClusterSlots + 4) = pipeline->embeddedPacketState;
      *(_DWORD *)pipeline->numNodes = pipeline->locked;
      *(_DWORD *)(pipeline->locked + 4) = pipeline->numNodes;
      (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule));
    }
    while ( next != (RpAtomic_0 *)p_llWorldSectorsInAtomic );
  }
LABEL_11:
  *(_DWORD *)(&atomic->object.object.type + v5) = 0;
  return world;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021E0BC) --------------------------------------------------------
RpWorld_0 *__fastcall RpAtomicGetWorld(const RpAtomic_0 *atomic)
{
  return *(RpWorld_0 **)(&atomic->object.object.type + atomicExtOffset);
}

//----- (0021E0CC) --------------------------------------------------------
RpAtomic_0 *__fastcall RpAtomicForAllWorldSectors(RpAtomic_0 *atomic, RpWorldSectorCallBack callback, void *data)
{
  RwLLLink *next; // r0
  RwLinkList_0 *p_llWorldSectorsInAtomic; // r5
  RwLLLink *v8; // r4
  bool v9; // zf

  p_llWorldSectorsInAtomic = &atomic->llWorldSectorsInAtomic;
  next = atomic->llWorldSectorsInAtomic.link.next;
  do
  {
    if ( next == (RwLLLink *)p_llWorldSectorsInAtomic )
      break;
    v8 = next->next;
    v9 = (int)callback((RpWorldSector_0 *)next[1].next, data) == 0;
    next = v8;
  }
  while ( !v9 );
  return atomic;
}

//----- (0021E0FA) --------------------------------------------------------
RpWorldSector_0 *__fastcall RpWorldSectorForAllAtomics(RpWorldSector_0 *sector, RpAtomicCallBack callback, void *data)
{
  RwLLLink *next; // r1
  RwLinkList_0 *p_collAtomicsInWorldSector; // r4
  RpAtomic_0 *v8; // r0
  RwLLLink *v9; // r1
  RpAtomic_0 *v10; // r0
  RwLLLink *v12; // [sp+0h] [bp-30h] BYREF
  RwLLLink *v13; // [sp+4h] [bp-2Ch]
  int v14; // [sp+8h] [bp-28h]
  int v15; // [sp+14h] [bp-1Ch]

  v15 = 0;
  v14 = 0;
  p_collAtomicsInWorldSector = &sector->collAtomicsInWorldSector;
  next = sector->collAtomicsInWorldSector.link.next;
  if ( next != (RwLLLink *)&sector->collAtomicsInWorldSector )
  {
    do
    {
      v12 = next->next;
      v13 = next;
      next->next->prev = (RwLLLink *)&v12;
      v8 = (RpAtomic_0 *)next[1].next;
      next->next = (RwLLLink *)&v12;
      if ( v8 )
      {
        if ( !(int)callback(v8, data) )
          goto LABEL_10;
      }
      next = v12;
      v13->next = v12;
      v12->prev = v13;
    }
    while ( next != (RwLLLink *)p_collAtomicsInWorldSector );
  }
  v9 = sector->noCollAtomicsInWorldSector.link.next;
  if ( v9 != (RwLLLink *)&sector->noCollAtomicsInWorldSector )
  {
    while ( 1 )
    {
      v12 = v9->next;
      v13 = v9;
      v9->next->prev = (RwLLLink *)&v12;
      v10 = (RpAtomic_0 *)v9[1].next;
      v9->next = (RwLLLink *)&v12;
      if ( v10 )
      {
        if ( !(int)callback(v10, data) )
          break;
      }
      v9 = v12;
      v13->next = v12;
      v12->prev = v13;
      if ( v9 == (RwLLLink *)&sector->noCollAtomicsInWorldSector )
        return sector;
    }
LABEL_10:
    v13->next = v12;
    v12->prev = v13;
  }
  return sector;
}

//----- (0021E198) --------------------------------------------------------
RpWorldSector_0 *__fastcall RpWorldSectorForAllCollisionAtomics(
        RpWorldSector_0 *sector,
        RpAtomicCallBack callback,
        void *data)
{
  RwLLLink *next; // r1
  RwLinkList_0 *p_collAtomicsInWorldSector; // r4
  RpAtomic_0 *v8; // r0
  RwLLLink *v10; // [sp+0h] [bp-30h] BYREF
  RwLLLink *v11; // [sp+4h] [bp-2Ch]
  int v12; // [sp+8h] [bp-28h]
  int v13; // [sp+14h] [bp-1Ch]

  v13 = 0;
  v12 = 0;
  p_collAtomicsInWorldSector = &sector->collAtomicsInWorldSector;
  next = sector->collAtomicsInWorldSector.link.next;
  if ( next != (RwLLLink *)&sector->collAtomicsInWorldSector )
  {
    while ( 1 )
    {
      v10 = next->next;
      v11 = next;
      next->next->prev = (RwLLLink *)&v10;
      v8 = (RpAtomic_0 *)next[1].next;
      next->next = (RwLLLink *)&v10;
      if ( v8 )
      {
        if ( !(int)callback(v8, data) )
          break;
      }
      next = v10;
      v11->next = v10;
      v10->prev = v11;
      if ( next == (RwLLLink *)p_collAtomicsInWorldSector )
        return sector;
    }
    v11->next = v10;
    v10->prev = v11;
  }
  return sector;
}

//----- (0021E1F8) --------------------------------------------------------
RpWorldSector_0 *__fastcall RpWorldSectorForAllLights(RpWorldSector_0 *sector, RpLightCallBack callback, void *data)
{
  RwLLLink *next; // r1
  RwLinkList_0 *p_lightsInWorldSector; // r4
  RpLight_0 *v8; // r0
  RpWorld_0 *World; // r0
  RpWorld_0 *p_directionalLightList; // r4
  bool v11; // zf
  RpWorld_0 *v13; // [sp+0h] [bp-30h] BYREF
  _DWORD *p_next; // [sp+4h] [bp-2Ch]
  int v15; // [sp+8h] [bp-28h]
  int v16; // [sp+14h] [bp-1Ch]

  v16 = 0;
  v15 = 0;
  p_lightsInWorldSector = &sector->lightsInWorldSector;
  next = sector->lightsInWorldSector.link.next;
  if ( next != (RwLLLink *)&sector->lightsInWorldSector )
  {
    do
    {
      v13 = (RpWorld_0 *)next->next;
      p_next = &next->next;
      next->next->prev = (RwLLLink *)&v13;
      v8 = (RpLight_0 *)next[1].next;
      next->next = (RwLLLink *)&v13;
      if ( v8 )
      {
        if ( !(int)callback(v8, data) )
          goto LABEL_11;
      }
      next = (RwLLLink *)v13;
      *p_next = v13;
      v13->object.parent = p_next;
    }
    while ( next != (RwLLLink *)p_lightsInWorldSector );
  }
  World = RpWorldSectorGetWorld(sector);
  p_directionalLightList = World;
  v11 = World == 0;
  if ( World )
  {
    p_directionalLightList = (RpWorld_0 *)&World->directionalLightList;
    World = (RpWorld_0 *)World->directionalLightList.link.next;
    v11 = World == p_directionalLightList;
  }
  if ( !v11 )
  {
    while ( 1 )
    {
      v13 = *(RpWorld_0 **)&World->object.type;
      p_next = &World->object.type;
      *(_DWORD *)(*(_DWORD *)&World->object.type + 4) = &v13;
      *(_DWORD *)&World->object.type = &v13;
      if ( !(int)callback((RpLight_0 *)&World[-1].directionalLightList, data) )
        break;
      World = v13;
      *p_next = v13;
      v13->object.parent = p_next;
      if ( World == p_directionalLightList )
        return sector;
    }
LABEL_11:
    *p_next = v13;
    v13->object.parent = p_next;
  }
  return sector;
}

//----- (0021E294) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldAddClump(RpWorld_0 *world, RpClump_0 *clump)
{
  RwInt32 v4; // r0
  RwLLLink *next; // r1
  RwFrame_0 *parent; // r8
  RwInt32 numClumpsInWorld; // r5
  RwError_0 v9; // [sp+0h] [bp-18h] BYREF

  v4 = clumpExtOffset;
  if ( *(_DWORD *)(&clump->object.type + clumpExtOffset) )
  {
    world = 0;
    v9.pluginID = 0;
    v9.errorCode = _rwerror(3);
    RwErrorSet(&v9);
  }
  else
  {
    next = world->clumpList.link.next;
    clump->inWorldLink.prev = &world->clumpList.link;
    clump->inWorldLink.next = next;
    parent = (RwFrame_0 *)clump->object.parent;
    world->clumpList.link.next->prev = &clump->inWorldLink;
    numClumpsInWorld = world->numClumpsInWorld;
    world->clumpList.link.next = &clump->inWorldLink;
    world->numClumpsInWorld = numClumpsInWorld + 1;
    *(_DWORD *)(&clump->object.type + v4) = world;
    RpClumpForAllAtomics(clump, WorldAddClumpAtomic, world);
    RpClumpForAllLights(clump, WorldAddClumpLight, world);
    RpClumpForAllCameras(clump, WorldAddClumpCamera, world);
    if ( parent )
    {
      RwMatrixOptimize(&parent->modelling, 0);
      RwFrameUpdateObjects(parent);
    }
  }
  return world;
}

//----- (0021E334) --------------------------------------------------------
RpAtomic_0 *__fastcall WorldAddClumpAtomic(RpAtomic_0 *atomic, void *data)
{
  RwFrame_0 *parent; // r0
  RwInt32 v5; // r6

  parent = (RwFrame_0 *)atomic->object.object.parent;
  v5 = atomicExtOffset;
  if ( parent )
    RwFrameUpdateObjects(parent);
  *(_DWORD *)(&atomic->object.object.type + v5) = data;
  return atomic;
}

//----- (0021E360) --------------------------------------------------------
RpLight_0 *__fastcall WorldAddClumpLight(RpLight_0 *light, void *data)
{
  RwLLLink *v4; // r0
  RwLLLink *v5; // r5
  RwFrame_0 *parent; // r0
  RwLLLink *v7; // t1
  RpLight_0 *result; // r0

  *(_DWORD *)(&light->object.object.type + lightExtOffset) = data;
  if ( (light->object.object.subType & 0x80u) != 0 )
  {
    parent = (RwFrame_0 *)light->object.object.parent;
    if ( parent )
      RwFrameUpdateObjects(parent);
    v7 = (RwLLLink *)*((_DWORD *)data + 13);
    v5 = (RwLLLink *)((char *)data + 52);
    v4 = v7;
  }
  else
  {
    v5 = (RwLLLink *)((char *)data + 60);
    v4 = (RwLLLink *)*((_DWORD *)data + 15);
  }
  light->inWorld.next = v4;
  light->inWorld.prev = v5;
  v5->next->prev = &light->inWorld;
  result = light;
  v5->next = &light->inWorld;
  return result;
}

//----- (0021E3A4) --------------------------------------------------------
RwCamera_0 *__fastcall WorldAddClumpCamera(RwCamera_0 *camera, void *data)
{
  RwFrame_0 *parent; // r0
  RwUInt8 *v5; // r6

  parent = (RwFrame_0 *)camera->object.object.parent;
  v5 = &camera->object.object.type + cameraExtOffset;
  if ( parent )
    RwFrameUpdateObjects(parent);
  *((_DWORD *)v5 + 3) = data;
  return camera;
}

//----- (0021E3D0) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldRemoveClump(RpWorld_0 *world, RpClump_0 *clump)
{
  RwInt32 v4; // r6
  int v5; // r0
  int v6; // r0
  RwError_0 v8; // [sp+0h] [bp-18h] BYREF

  v4 = clumpExtOffset;
  v5 = *(_DWORD *)(&clump->object.type + clumpExtOffset);
  if ( v5 )
  {
    --*(_DWORD *)(v5 + 36);
    v6 = *(_DWORD *)(&clump->object.type + v4);
    if ( &clump->inWorldLink == (RwLLLink_0 *)*(RpClump_0 **)(v6 + 40) )
      *(_DWORD *)(v6 + 40) = clump->inWorldLink.next;
    clump->inWorldLink.prev->next = clump->inWorldLink.next;
    clump->inWorldLink.next->prev = clump->inWorldLink.prev;
    RpClumpForAllAtomics(clump, WorldRemoveClumpAtomic, world);
    RpClumpForAllLights(clump, WorldRemoveClumpLight, world);
    RpClumpForAllCameras(clump, WorldRemoveClumpCamera, world);
    *(_DWORD *)(&clump->object.type + v4) = 0;
  }
  else
  {
    world = 0;
    v8.pluginID = 0;
    v8.errorCode = _rwerror(4);
    RwErrorSet(&v8);
  }
  return world;
}

//----- (0021E460) --------------------------------------------------------
RpAtomic_0 *__fastcall WorldRemoveClumpAtomic(RpAtomic_0 *atomic, void *data)
{
  void **v3; // r8
  RwResEntry_0 *repEntry; // r0
  RpAtomic_0 *next; // r5
  RwLinkList_0 *p_llWorldSectorsInAtomic; // r6
  RpAtomic_0 *v7; // r0
  RxPipeline_0 *pipeline; // r1
  bool v9; // zf

  v3 = (void **)(&atomic->object.object.type + atomicExtOffset);
  if ( (RpAtomic_0 *)((char *)atomic + atomicExtOffset) && *v3 == data )
  {
    repEntry = atomic->repEntry;
    if ( repEntry )
      RwResourcesFreeResEntry(repEntry);
    p_llWorldSectorsInAtomic = &atomic->llWorldSectorsInAtomic;
    next = (RpAtomic_0 *)atomic->llWorldSectorsInAtomic.link.next;
    if ( next != (RpAtomic_0 *)&atomic->llWorldSectorsInAtomic )
    {
      do
      {
        while ( 1 )
        {
          v7 = next;
          pipeline = next[-1].pipeline;
          next = *(RpAtomic_0 **)&next->object.object.type;
          v9 = pipeline == 0;
          if ( pipeline )
          {
            pipeline = (RxPipeline_0 *)&v7[-1].llWorldSectorsInAtomic;
            v9 = v7->object.lFrame.next == 0;
          }
          if ( !v9 )
            break;
          if ( next == (RpAtomic_0 *)p_llWorldSectorsInAtomic )
            goto LABEL_13;
        }
        *(_DWORD *)pipeline->embeddedPacketState = next;
        *(_DWORD *)(pipeline->packetNumClusterSlots + 4) = pipeline->embeddedPacketState;
        *(_DWORD *)pipeline->numNodes = pipeline->locked;
        *(_DWORD *)(pipeline->locked + 4) = pipeline->numNodes;
        (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule));
      }
      while ( next != (RpAtomic_0 *)p_llWorldSectorsInAtomic );
    }
LABEL_13:
    *v3 = 0;
  }
  return atomic;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021E500) --------------------------------------------------------
RpLight_0 *__fastcall WorldRemoveClumpLight(RpLight_0 *light, void *data)
{
  void **v3; // r0
  RwLLLink *next; // r1
  RwLLLink v5; // kr00_8
  RwLLLink **p_prev; // r1
  RwLLLink *prev; // t1

  v3 = (void **)(&light->object.object.type + lightExtOffset);
  if ( v3 && *v3 == data )
  {
    *v3 = 0;
    next = light->WorldSectorsInLight.link.next;
    if ( next != (RwLLLink *)&light->WorldSectorsInLight )
    {
      do
      {
        v5 = *next;
        next->prev->next = next->next;
        next->next->prev = next->prev;
        prev = next[-2].prev;
        p_prev = &next[-2].prev;
        p_prev[1]->next = prev;
        (*p_prev)->prev = p_prev[1];
        (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance
                                                                           + worldObjModule
                                                                           + 4));
        next = v5.next;
      }
      while ( (RwLinkList_0 *)v5.next != &light->WorldSectorsInLight );
    }
    light->inWorld.prev->next = light->inWorld.next;
    light->inWorld.next->prev = light->inWorld.prev;
  }
  return light;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021E588) --------------------------------------------------------
RwCamera_0 *__fastcall WorldRemoveClumpCamera(RwCamera_0 *camera, void *data)
{
  RwUInt8 *v3; // r5
  void *v4; // r0

  v3 = &camera->object.object.type + cameraExtOffset;
  if ( (RwCamera_0 *)((char *)camera + cameraExtOffset) )
  {
    v4 = (void *)*((_DWORD *)v3 + 3);
    if ( v4 == data )
    {
      if ( v4 )
      {
        if ( *(_DWORD *)v3 )
          (*((void (**)(void))RwEngineInstance + 76))();
        *(_DWORD *)v3 = 0;
        *((_DWORD *)v3 + 1) = 0;
        *((_DWORD *)v3 + 2) = 0;
        *((_DWORD *)v3 + 3) = 0;
      }
    }
  }
  return camera;
}

//----- (0021E5C8) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraForAllSectorsInFrustum(RwCamera_0 *camera, RpWorldSectorCallBack callback, void *data)
{
  RwUInt8 *v6; // r0
  int v7; // r5
  RpWorldSector_0 **v8; // r4

  v6 = &camera->object.object.type + cameraExtOffset;
  v7 = *((_DWORD *)v6 + 2);
  if ( v7 )
  {
    v8 = *(RpWorldSector_0 ***)v6;
    do
    {
      if ( !(int)callback(*v8, data) )
        break;
      --v7;
      ++v8;
    }
    while ( v7 );
  }
  return camera;
}

//----- (0021E600) --------------------------------------------------------
RpWorld_0 *__fastcall RpClumpGetWorld(const RpClump_0 *clump)
{
  return *(RpWorld_0 **)(&clump->object.type + clumpExtOffset);
}

//----- (0021E610) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraForAllClumpsInFrustum(RwCamera_0 *camera, void *data)
{
  RwUInt8 *v4; // r0
  RwUInt16 v5; // r5
  int v6; // r1
  int *v7; // r0
  int v8; // r10
  RpAtomic_0 **v9; // r0
  RpAtomic_0 ***v10; // r9
  RpClump_0 *v11; // r6
  bool v12; // zf
  const RwSphere_0 *v13; // r0
  int (__fastcall *v14)(RpClump_0 *, void *); // r2
  RpAtomic_0 **i; // r0
  RpAtomic_0 **v16; // r10
  RpAtomic_0 **v17; // t1
  RpClump_0 *clump; // r6
  const RwSphere_0 *WorldBoundingSphere; // r0
  int (__fastcall *callback)(RpClump_0 *, void *); // r2
  int v22; // [sp+4h] [bp-3Ch]
  int *v23; // [sp+8h] [bp-38h]
  RpAtomic_0 *v24; // [sp+Ch] [bp-34h] BYREF
  RpAtomic_0 **v25; // [sp+10h] [bp-30h]
  int v26; // [sp+14h] [bp-2Ch]
  int v27; // [sp+20h] [bp-20h]

  v4 = &camera->object.object.type + cameraExtOffset;
  if ( *((_DWORD *)v4 + 3) )
  {
    v5 = *((_WORD *)RwEngineInstance + 4) + 1;
    *((_WORD *)RwEngineInstance + 4) = v5;
    camera->renderFrame = v5;
    v6 = *((_DWORD *)v4 + 2);
    if ( v6 )
    {
      v7 = *(int **)v4;
      while ( 1 )
      {
        v22 = v6;
        v27 = 0;
        v26 = 0;
        v23 = v7;
        v8 = *v7;
        v10 = (RpAtomic_0 ***)(*v7 + 56);
        v9 = *v10;
        if ( *v10 != (RpAtomic_0 **)v10 )
          break;
LABEL_12:
        v17 = *(RpAtomic_0 ***)(v8 + 64);
        v16 = (RpAtomic_0 **)(v8 + 64);
        for ( i = v17; i != v16; v24->object.object.parent = v25 )
        {
          clump = i[2]->clump;
          v24 = *i;
          v25 = i;
          (*i)->object.object.parent = &v24;
          *i = (RpAtomic_0 *)&v24;
          if ( clump->renderFrame != v5 )
          {
            WorldBoundingSphere = RpAtomicGetWorldBoundingSphere(i[2]);
            if ( RwCameraFrustumTestSphere(camera, WorldBoundingSphere) )
            {
              callback = (int (__fastcall *)(RpClump_0 *, void *))clump->callback;
              clump->renderFrame = v5;
              if ( !callback(clump, data) )
                goto LABEL_21;
            }
          }
          i = (RpAtomic_0 **)v24;
          *v25 = v24;
        }
        v6 = v22 - 1;
        v7 = v23 + 1;
        if ( v22 == 1 )
          return camera;
      }
      while ( 1 )
      {
        v11 = v9[2]->clump;
        v24 = *v9;
        v25 = v9;
        v12 = v11 == 0;
        (*v9)->object.object.parent = &v24;
        *v9 = (RpAtomic_0 *)&v24;
        if ( v11 )
          v12 = v11->renderFrame == v5;
        if ( !v12 )
        {
          v13 = RpAtomicGetWorldBoundingSphere(v9[2]);
          if ( RwCameraFrustumTestSphere(camera, v13) )
          {
            v14 = (int (__fastcall *)(RpClump_0 *, void *))v11->callback;
            v11->renderFrame = v5;
            if ( !v14(v11, data) )
              break;
          }
        }
        v9 = (RpAtomic_0 **)v24;
        *v25 = v24;
        v24->object.object.parent = v25;
        if ( v9 == (RpAtomic_0 **)v10 )
        {
          v8 = *v23;
          goto LABEL_12;
        }
      }
LABEL_21:
      *v25 = v24;
      v24->object.object.parent = v25;
    }
  }
  return camera;
}

//----- (0021E738) --------------------------------------------------------
RwCamera_0 *__fastcall RwCameraForAllClumpsNotInFrustum(RwCamera_0 *camera, RwInt32 numClumps, void *data)
{
  RwInt32 *v5; // r10
  RwInt32 v6; // r0
  _DWORD *v7; // r4
  RwInt32 v8; // r2
  int v9; // r0
  int v10; // r1
  int renderFrame; // r11
  _DWORD *v12; // r6
  int v13; // r5
  _DWORD *v14; // r1
  _DWORD *v15; // r0
  bool v16; // zf

  v5 = *(RwInt32 **)((char *)&camera->object.lFrame.prev + cameraExtOffset);
  if ( v5 )
  {
    v7 = (_DWORD *)v5[10];
    v6 = v5[9];
    v8 = numClumps;
    if ( v6 < numClumps )
      v8 = v5[9];
    if ( v8 )
    {
      v9 = ~v6;
      v10 = ~numClumps;
      renderFrame = camera->renderFrame;
      if ( v9 > v10 )
        v10 = v9;
      v12 = v5 + 11;
      v13 = v10 + 1;
      while ( 1 )
      {
        v14 = v7;
        v15 = v7;
        v7 = (_DWORD *)*v7;
        v16 = v12 == v14;
        if ( v12 != v14 )
          v16 = *((unsigned __int16 *)v15 + 6) == renderFrame;
        if ( !v16 )
        {
          v5[10] = (RwInt32)v14;
          if ( !((int (__fastcall *)(_DWORD *, void *))v15[2])(v15 - 8, data) )
            break;
        }
        if ( !++v13 )
          goto LABEL_13;
      }
    }
    else
    {
LABEL_13:
      v5[10] = (RwInt32)v7;
    }
  }
  return camera;
}

//----- (0021E7B0) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldAddLight(RpWorld_0 *world, RpLight_0 *light)
{
  RwLinkList_0 *p_lightList; // r0
  RwLLLink *next; // r1
  RwFrame_0 *parent; // r0
  RwLLLink_0 *p_inWorld; // r5

  *(_DWORD *)(&light->object.object.type + lightExtOffset) = world;
  if ( (light->object.object.subType & 0x80u) != 0 )
  {
    parent = (RwFrame_0 *)light->object.object.parent;
    if ( parent )
      RwFrameUpdateObjects(parent);
    p_lightList = &world->lightList;
    next = world->lightList.link.next;
  }
  else
  {
    p_lightList = &world->directionalLightList;
    next = world->directionalLightList.link.next;
  }
  light->inWorld.next = next;
  p_inWorld = &light->inWorld;
  p_inWorld->prev = &p_lightList->link;
  p_lightList->link.next->prev = p_inWorld;
  p_lightList->link.next = p_inWorld;
  return world;
}

//----- (0021E7F4) --------------------------------------------------------
RpWorld_0 *__fastcall RpWorldRemoveLight(RpWorld_0 *world, RpLight_0 *light)
{
  RwLLLink *next; // r1
  RwLinkList_0 *p_WorldSectorsInLight; // r6
  RwLLLink v6; // kr00_8
  RwLLLink **p_prev; // r1
  RwLLLink *prev; // t1

  *(_DWORD *)(&light->object.object.type + lightExtOffset) = 0;
  p_WorldSectorsInLight = &light->WorldSectorsInLight;
  next = light->WorldSectorsInLight.link.next;
  if ( next != (RwLLLink *)p_WorldSectorsInLight )
  {
    do
    {
      v6 = *next;
      next->prev->next = next->next;
      next->next->prev = next->prev;
      prev = next[-2].prev;
      p_prev = &next[-2].prev;
      p_prev[1]->next = prev;
      (*p_prev)->prev = p_prev[1];
      (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule + 4));
      next = v6.next;
    }
    while ( (RwLinkList_0 *)v6.next != p_WorldSectorsInLight );
  }
  light->inWorld.prev->next = light->inWorld.next;
  light->inWorld.next->prev = light->inWorld.prev;
  return world;
}
// 6BD690: using guessed type int worldObjModule;

//----- (0021E874) --------------------------------------------------------
RpWorld_0 *__fastcall RpLightGetWorld(const RpLight_0 *light)
{
  return *(RpWorld_0 **)(&light->object.object.type + lightExtOffset);
}

//----- (0021E884) --------------------------------------------------------
RpLight_0 *__fastcall RpLightForAllWorldSectors(RpLight_0 *light, RpWorldSectorCallBack callback, void *data)
{
  RpLight_0 *v3; // r8
  RpWorld_0 *v6; // r0
  RwLLLink *next; // r0
  RwLLLink *v8; // r5
  bool v9; // zf

  v3 = light;
  if ( (light->object.object.subType & 0x80u) != 0 )
  {
    next = light->WorldSectorsInLight.link.next;
    do
    {
      if ( next == (RwLLLink *)&v3->WorldSectorsInLight )
        break;
      v8 = next->next;
      v9 = (int)callback((RpWorldSector_0 *)next[1].next, data) == 0;
      next = v8;
    }
    while ( !v9 );
  }
  else
  {
    v6 = *(RpWorld_0 **)(&light->object.object.type + lightExtOffset);
    if ( v6 && !RpWorldForAllWorldSectors(v6, callback, data) )
      return 0;
  }
  return v3;
}

//----- (0021E8DC) --------------------------------------------------------
RwObjectHasFrame_0 *__fastcall WorldCameraSync(RwObjectHasFrame_0 *object)
{
  RwObjectHasFrame_0 *v1; // r8
  RwUInt8 *v2; // r4
  int v3; // r4
  RwInt32 v4; // r5
  RwMatrix *LTM; // r0
  double v6; // d16
  RwUInt8 *v7; // r9
  RwLLLink **p_prev; // r12
  int v9; // r10
  double v10; // d16
  double v11; // d16
  int v12; // r1
  int v13; // r4
  RwLLLink *v14; // r11
  float v15; // s2
  bool v16; // cc
  RwLLLink **p_next; // r1
  int v18; // r1
  float *v19; // r2
  int v20; // r2
  __int64 v21; // r0
  int v22; // r1
  int v23; // r0
  int v24; // r1
  int v25; // r5
  int v27; // [sp+0h] [bp-160h]
  double v28; // [sp+10h] [bp-150h] BYREF
  int v29; // [sp+18h] [bp-148h]
  double v30; // [sp+20h] [bp-140h] BYREF
  RwLLLink *prev; // [sp+28h] [bp-138h]
  double v32; // [sp+30h] [bp-130h] BYREF
  RwReal z; // [sp+38h] [bp-128h]
  _DWORD v34[64]; // [sp+3Ch] [bp-124h]
  RwError_0 code; // [sp+13Ch] [bp-24h] BYREF

  v1 = object;
  v2 = &object->object.type + cameraExtOffset;
  if ( !(*(int (__fastcall **)(RwObjectHasFrame_0 *))((char *)&object[1].object.parent + cameraExtOffset))(object) )
    return 0;
  v3 = *((_DWORD *)v2 + 3);
  if ( v3 )
  {
    v4 = cameraExtOffset;
    LTM = RwFrameGetLTM((RwFrame_0 *)v1->object.parent);
    v6 = *(double *)&LTM->pos.x;
    v7 = &v1->object.type + v4;
    p_prev = &v1[7].lFrame.prev;
    z = LTM->pos.z;
    v32 = v6;
    v9 = 0;
    v10 = *(double *)&v1[14].object.parent;
    prev = v1[14].lFrame.prev;
    v30 = v10;
    v11 = *(double *)&v1[13].lFrame.prev;
    v29 = *(_DWORD *)&v1[14].object.type;
    v28 = v11;
    v12 = *(_DWORD *)(v3 + 12);
    v13 = 0;
    v27 = v12;
    v14 = (*(RwLLLink **)((char *)&v1->lFrame.prev + v4))[3].prev;
    while ( 2 )
    {
      while ( (int)v14->next > -1 )
      {
        v15 = *(float *)&v14[2].prev;
        *(float *)&code.pluginID = *(float *)((char *)&v14->next->next + (unsigned int)&v30) - *(float *)&v14[2].next;
        v16 = code.pluginID <= -1;
        if ( code.pluginID <= -1 )
          v16 = COERCE_INT(v15 - *(float *)((char *)&v14->next->next + (unsigned int)&v28)) <= -1;
        if ( v16 )
        {
          ++v9;
          v22 = 12;
          v23 = 8;
          if ( *(float *)((char *)&v14->next->next + (unsigned int)&v32) > *(float *)&v14->prev != (v27 == 2) )
          {
            v23 = 12;
            v22 = 8;
          }
          v24 = *(int *)((char *)&v14->next + v22);
          v14 = *(RwLLLink **)((char *)&v14->next + v23);
          v34[v9] = v24;
          if ( v9 <= -1 )
            goto LABEL_30;
        }
        else
        {
          p_next = &v14[1].prev;
          if ( code.pluginID < 0 )
            p_next = &v14[1].next;
          v14 = *p_next;
        }
      }
      v18 = -1;
      v19 = (float *)p_prev;
      while ( 1 )
      {
        *(float *)&code.pluginID = (float)((float)((float)(*((float *)&v14[10].next + 3 * *((unsigned __int8 *)v19 + 16))
                                                         * *v19)
                                                 + (float)(*((float *)&v14[10].prev + 3 * *((unsigned __int8 *)v19 + 17))
                                                         * v19[1]))
                                         + (float)(*((float *)&v14[11].next + 3 * *((unsigned __int8 *)v19 + 18))
                                                 * v19[2]))
                                 - v19[3];
        if ( code.pluginID > 0 )
          break;
        ++v18;
        v19 += 5;
        if ( v18 > 4 )
        {
          v20 = *((_DWORD *)v7 + 1);
          if ( v13 >= v20 )
          {
            v25 = 4 * v20 + 200;
            if ( *(_DWORD *)v7 )
              LODWORD(v21) = (*((int (__fastcall **)(_DWORD, int))RwEngineInstance + 77))(*(_DWORD *)v7, v25);
            else
              LODWORD(v21) = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * v20 + 200);
            if ( !(_DWORD)v21 )
            {
              code.pluginID = 0;
              code.errorCode = _rwerror(-2147483629, v25);
              RwErrorSet(&code);
              goto LABEL_30;
            }
            HIDWORD(v21) = *((_DWORD *)v7 + 1) + 50;
            *(_QWORD *)v7 = v21;
            p_prev = &v1[7].lFrame.prev;
          }
          else
          {
            LODWORD(v21) = *(_DWORD *)v7;
          }
          *(_DWORD *)(v21 + 4 * v13++) = v14;
          break;
        }
      }
      v14 = (RwLLLink *)v34[v9--];
      if ( v9 > -1 )
        continue;
      break;
    }
LABEL_30:
    *((_DWORD *)v7 + 2) = v13;
  }
  return v1;
}
// 21E9C2: conditional instruction was optimized away because r10.4>=0
// 21E8DC: using guessed type _DWORD var_124[64];

//----- (0021EB20) --------------------------------------------------------
RwCamera_0 *__fastcall WorldCameraBeginUpdate(RwCamera_0 *camera)
{
  _WORD *v1; // r1
  int (**v2)(void); // r2
  __int16 v3; // r12

  v1 = RwEngineInstance;
  v2 = (int (**)(void))(&camera->object.object.type + cameraExtOffset);
  v3 = *((_WORD *)RwEngineInstance + 4);
  *((_DWORD *)RwEngineInstance + 1) = *(RwLLLink **)((char *)&camera->object.lFrame.prev + cameraExtOffset);
  v1[4] = v3 + 1;
  return (RwCamera_0 *)v2[4]();
}

//----- (0021EB4C) --------------------------------------------------------
RwCamera_0 *__fastcall WorldCameraEndUpdate(RwCamera_0 *camera)
{
  RwInt32 v1; // r2

  v1 = cameraExtOffset;
  *((_DWORD *)RwEngineInstance + 1) = 0;
  return (RwCamera_0 *)(*(int (**)(void))((char *)&camera->projectionType + v1))();
}

//----- (0021EB6C) --------------------------------------------------------
RwObjectHasFrame_0 *__fastcall WorldAtomicSync(RwObjectHasFrame_0 *type)
{
  RpAtomic_0 *v1; // r4
  RwUInt8 *v2; // r5
  int v3; // r8
  RwLinkList_0 *next; // r6
  RwLinkList_0 *p_llWorldSectorsInAtomic; // r11
  RwLinkList_0 *v6; // r0
  RwLLLink *prev; // r1
  bool v8; // zf
  const RwSphere_0 *WorldBoundingSphere; // r0
  double v10; // d16
  int v11; // r6
  double v12; // d16
  float radius; // s0
  int v14; // r10
  int v15; // r0
  _DWORD *v16; // r0
  int v17; // r2
  RwLLLink *v18; // r0
  int v19; // r0
  double v21; // [sp+0h] [bp-138h] BYREF
  float v22; // [sp+8h] [bp-130h]
  double v23; // [sp+10h] [bp-128h]
  float z; // [sp+18h] [bp-120h]
  _DWORD v25[71]; // [sp+1Ch] [bp-11Ch]

  v1 = (RpAtomic_0 *)type;
  v2 = &type->object.type + atomicExtOffset;
  if ( !(*(int (__fastcall **)(RwObjectHasFrame_0 *))((char *)&type->object.parent + atomicExtOffset))(type) )
    return 0;
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 )
  {
    p_llWorldSectorsInAtomic = &v1->llWorldSectorsInAtomic;
    next = (RwLinkList_0 *)v1->llWorldSectorsInAtomic.link.next;
    if ( next != &v1->llWorldSectorsInAtomic )
    {
      do
      {
        while ( 1 )
        {
          v6 = next;
          prev = next[-1].link.prev;
          next = (RwLinkList_0 *)next->link.next;
          v8 = prev == 0;
          if ( prev )
          {
            prev = (RwLLLink *)&v6[-2].link.prev;
            v8 = v6[1].link.next == 0;
          }
          if ( !v8 )
            break;
          if ( next == p_llWorldSectorsInAtomic )
            goto LABEL_11;
        }
        prev[2].next->next = &next->link;
        prev[1].prev->prev = prev[2].next;
        prev->prev->next = prev->next;
        prev->next->prev = prev->prev;
        (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance + worldObjModule));
      }
      while ( next != p_llWorldSectorsInAtomic );
    }
LABEL_11:
    WorldBoundingSphere = RpAtomicGetWorldBoundingSphere(v1);
    v10 = *(double *)&WorldBoundingSphere->center.x;
    v11 = 0;
    z = WorldBoundingSphere->center.z;
    v23 = v10;
    v12 = *(double *)&WorldBoundingSphere->center.x;
    v22 = WorldBoundingSphere->center.z;
    v21 = v12;
    radius = WorldBoundingSphere->radius;
    *(float *)&v23 = *(float *)&v23 - radius;
    *((float *)&v23 + 1) = *((float *)&v23 + 1) - radius;
    z = z - radius;
    *(float *)&v21 = radius + *(float *)&v12;
    *((float *)&v21 + 1) = radius + *((float *)&v12 + 1);
    v22 = radius + v22;
    v14 = *(_DWORD *)(v3 + 28);
    while ( 1 )
    {
      v15 = *(_DWORD *)v14;
      if ( *(int *)v14 < 0 )
        break;
      if ( *(float *)((char *)&v23 + v15) >= *(float *)(v14 + 16) )
      {
        if ( *(float *)(v14 + 20) < *(float *)((char *)&v21 + v15) )
        {
          v14 = *(_DWORD *)(v14 + 12);
        }
        else
        {
LABEL_22:
          v14 = v25[v11--];
LABEL_23:
          if ( v11 <= -1 )
            return &v1->object;
        }
      }
      else
      {
        if ( *(float *)(v14 + 20) < *(float *)((char *)&v21 + v15) )
        {
          ++v11;
          v19 = *(_DWORD *)(v14 + 12);
          v14 = *(_DWORD *)(v14 + 8);
          v25[v11] = v19;
          goto LABEL_23;
        }
        v14 = *(_DWORD *)(v14 + 8);
      }
    }
    v16 = (_DWORD *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                      + worldObjModule));
    v16[5] = v14;
    v17 = v14 + 56;
    v16[2] = v1;
    if ( (v1->object.object.flags & 1) == 0 )
      v17 = v14 + 64;
    *v16 = *(_DWORD *)v17;
    v16[1] = v17;
    *(_DWORD *)(*(_DWORD *)v17 + 4) = v16;
    *(_DWORD *)v17 = v16;
    v16[3] = v1->llWorldSectorsInAtomic.link.next;
    v16[4] = p_llWorldSectorsInAtomic;
    v18 = (RwLLLink *)(v16 + 3);
    v1->llWorldSectorsInAtomic.link.next->prev = v18;
    v1->llWorldSectorsInAtomic.link.next = v18;
    goto LABEL_22;
  }
  return &v1->object;
}
// 6BD690: using guessed type int worldObjModule;
// 21EB6C: using guessed type _DWORD var_11C[71];

//----- (0021ED44) --------------------------------------------------------
RwObjectHasFrame_0 *__fastcall WorldLightSync(RwObjectHasFrame_0 *object)
{
  RwFrame_0 *parent; // r9
  RwUInt8 *v3; // r5
  int v4; // r8
  bool v5; // zf
  RwObjectHasFrame_0 *v6; // r1
  void **p_parent; // r11
  float v8; // s16
  RwObject_0 v9; // kr00_8
  RwLLLink_0 *p_lFrame; // r1
  RwLLLink *next; // t1
  RwMatrix *LTM; // r0
  double v13; // d16
  int v14; // r5
  int v15; // r10
  int v16; // r0
  _DWORD *v17; // r0
  int v18; // r10
  int v19; // t1
  RwInt32 v20; // r0
  RwV3d_0 pos; // [sp+0h] [bp-148h] BYREF
  double v23; // [sp+10h] [bp-138h]
  float z; // [sp+18h] [bp-130h]
  RwError_0 code; // [sp+20h] [bp-128h] BYREF

  v3 = &object->object.type + lightExtOffset;
  if ( (*(int (__fastcall **)(RwObjectHasFrame_0 *))((char *)&object->object.parent + lightExtOffset))(object) )
  {
    if ( (char)object->object.subType <= -1 )
    {
      v4 = *(_DWORD *)v3;
      v5 = *(_DWORD *)v3 == 0;
      if ( *(_DWORD *)v3 )
      {
        parent = (RwFrame_0 *)object->object.parent;
        v5 = parent == 0;
      }
      if ( !v5 )
      {
        p_parent = &object[2].object.parent;
        v6 = (RwObjectHasFrame_0 *)object[2].object.parent;
        v8 = *(float *)&object[1].object.type;
        if ( v6 != (RwObjectHasFrame_0 *)&object[2].object.parent )
        {
          do
          {
            v9 = v6->object;
            *(_DWORD *)v6->object.parent = *(_DWORD *)&v6->object.type;
            *(_DWORD *)(*(_DWORD *)&v6->object.type + 4) = v6->object.parent;
            next = v6[-1].lFrame.next;
            p_lFrame = &v6[-1].lFrame;
            p_lFrame->prev->next = next;
            p_lFrame->next->prev = p_lFrame->prev;
            (*((void (__fastcall **)(_DWORD))RwEngineInstance + 80))(*(_DWORD *)((char *)RwEngineInstance
                                                                               + worldObjModule
                                                                               + 4));
            v6 = *(RwObjectHasFrame_0 **)&v9.type;
          }
          while ( *(void ***)&v9.type != p_parent );
        }
        LTM = RwFrameGetLTM(parent);
        v13 = *(double *)&LTM->pos.x;
        v14 = 0;
        z = LTM->pos.z;
        v23 = v13;
        pos = LTM->pos;
        pos.x = v8 + pos.x;
        pos.y = v8 + pos.y;
        pos.z = v8 + pos.z;
        *(float *)&v23 = *(float *)&v13 - v8;
        *((float *)&v23 + 1) = *((float *)&v13 + 1) - v8;
        z = z - v8;
        v15 = *(_DWORD *)(v4 + 28);
        while ( 1 )
        {
          v16 = *(_DWORD *)v15;
          if ( *(int *)v15 < 0 )
          {
            v17 = (_DWORD *)(*((int (__fastcall **)(_DWORD))RwEngineInstance + 79))(*(_DWORD *)((char *)RwEngineInstance
                                                                                              + worldObjModule
                                                                                              + 4));
            v17[5] = v15;
            v17[2] = object;
            v19 = *(_DWORD *)(v15 + 72);
            v18 = v15 + 72;
            *v17 = v19;
            v17[1] = v18;
            *(_DWORD *)(*(_DWORD *)v18 + 4) = v17;
            *(_DWORD *)v18 = v17;
            v17[3] = object[2].object.parent;
            v17[4] = p_parent;
            v17 += 3;
            *((_DWORD *)object[2].object.parent + 1) = v17;
            object[2].object.parent = v17;
LABEL_17:
            v15 = *(&code.pluginID + v14--);
LABEL_18:
            if ( v14 <= -1 )
              return object;
          }
          else if ( *(float *)((char *)&v23 + v16) >= *(float *)(v15 + 16) )
          {
            if ( *(float *)(v15 + 20) >= *(float *)((char *)&pos.x + v16) )
              goto LABEL_17;
            v15 = *(_DWORD *)(v15 + 12);
          }
          else
          {
            if ( *(float *)(v15 + 20) < *(float *)((char *)&pos.x + v16) )
            {
              ++v14;
              v20 = *(_DWORD *)(v15 + 12);
              v15 = *(_DWORD *)(v15 + 8);
              *(&code.pluginID + v14) = v20;
              goto LABEL_18;
            }
            v15 = *(_DWORD *)(v15 + 8);
          }
        }
      }
    }
  }
  else
  {
    code.pluginID = 0;
    code.errorCode = _rwerror(-2147483626);
    RwErrorSet(&code);
  }
  return object;
}
// 21EDD8: variable 'parent' is possibly undefined
// 6BD690: using guessed type int worldObjModule;

//----- (0021EF38) --------------------------------------------------------
const RpGeometry_0 *__fastcall RpGeometryIsCorrectlySorted(const RpGeometry_0 *geometry, RwBool *result)
{
  const RpGeometry_0 *v2; // r10
  RwBool v4; // r9
  int v5; // r5
  int v6; // r0
  int numMaterials; // r1
  int i; // r2
  RwInt32 v9; // r1
  RpTriangle_0 *triangles; // r2
  unsigned int v11; // r5
  int matIndex; // r12
  int v13; // r3
  unsigned int v14; // r2
  _WORD *v15; // r3
  unsigned int v16; // t1
  unsigned int v17; // r6
  unsigned int v18; // r4
  int v19; // r5
  unsigned int v20; // r5
  int v21; // r2
  int8x16_t v22; // q8
  unsigned int v23; // r3
  int32x4_t v24; // q9
  const __int16 *v25; // r6
  int32x4_t v26; // q8
  unsigned __int16 *v27; // r3
  int16x4x2_t v29; // 0:d20.8,8:d21.8

  v2 = geometry;
  v4 = 0;
  v5 = 0;
  if ( HIBYTE(geometry->flags) << 31 )
    goto LABEL_35;
  v6 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * geometry->matList.numMaterials);
  if ( !v6 )
    return 0;
  numMaterials = v2->matList.numMaterials;
  if ( numMaterials >= 1 )
  {
    for ( i = 0; i < numMaterials; ++i )
    {
      *(_DWORD *)(v6 + 4 * i) = 0xFFFF;
      numMaterials = v2->matList.numMaterials;
    }
  }
  if ( v2->numTriangles >= 1 )
  {
    v9 = 0;
    do
    {
      triangles = v2->triangles;
      v11 = triangles[v9].vertIndex[0];
      matIndex = triangles[v9].matIndex;
      v13 = v6 + 4 * matIndex;
      v16 = *(unsigned __int16 *)(v13 + 2);
      v15 = (_WORD *)(v13 + 2);
      v14 = v16;
      if ( v11 > v16 )
      {
        *v15 = v11;
        v14 = v11;
      }
      v17 = *(unsigned __int16 *)(v6 + 4 * matIndex);
      if ( v11 < v17 )
      {
        *(_WORD *)(v6 + 4 * matIndex) = v11;
        v17 = v11;
      }
      v18 = v2->triangles[v9].vertIndex[1];
      if ( v18 > v14 )
      {
        *v15 = v18;
        v14 = v18;
      }
      if ( v18 < v17 )
      {
        *(_WORD *)(v6 + 4 * matIndex) = v18;
        v17 = v18;
      }
      v19 = (int)&v2->triangles[v9++];
      v20 = *(unsigned __int16 *)(v19 + 4);
      if ( v20 > v14 )
        *v15 = v20;
      if ( v20 < v17 )
        *(_WORD *)(v6 + 4 * matIndex) = v20;
    }
    while ( v9 < v2->numTriangles );
    numMaterials = v2->matList.numMaterials;
  }
  if ( numMaterials < 1 )
  {
    v5 = 0;
  }
  else
  {
    if ( (unsigned int)numMaterials > 3 && (v21 = numMaterials & 0x7FFFFFFC, (numMaterials & 0xFFFFFFFC) != 0) )
    {
      v22 = 0uLL;
      v23 = numMaterials & 0xFFFFFFFC;
      v24.n128_u64[0] = 0x100000001LL;
      v24.n128_u64[1] = 0x100000001LL;
      v25 = (const __int16 *)v6;
      do
      {
        v29 = vld2_s16(v25);
        v25 += 8;
        v23 -= 4;
        v22 = vsubw_u16(vaddq_s32(vaddw_u16(v22, v29.val[1]), v24), v29.val[0]);
      }
      while ( v23 );
      v26 = vaddq_s32(v22, vextq_s8(v22, v22, 8u));
      v5 = vaddq_s32(v26, vdupq_lane_s32((int32x2_t)v26.n128_u64[0], 1)).n128_u32[0];
      if ( numMaterials == v21 )
        goto LABEL_34;
    }
    else
    {
      v21 = 0;
      v5 = 0;
    }
    do
    {
      v27 = (unsigned __int16 *)(v6 + 4 * v21++);
      v5 = v27[1] + v5 + 1 - *v27;
    }
    while ( v21 < numMaterials );
  }
LABEL_34:
  (*((void (**)(void))RwEngineInstance + 76))();
LABEL_35:
  if ( v5 <= v2->numVertices )
    v4 = 1;
  *result = v4;
  return v2;
}
// 21F00A: mask 0xFFFFFFFC is shortened because r1.4 <= 0x7FFFFFFF

//----- (0021F0A0) --------------------------------------------------------
RpGeometry_0 *__fastcall RpGeometrySortByMaterial(
        const RpGeometry_0 *source,
        RpGeometrySortByMaterialCallBack callback)
{
  RwUInt32 flags; // r11
  int v4; // r6
  int v5; // r10
  int v6; // r5
  unsigned __int16 *v7; // r8
  int v8; // r2
  int v9; // r10
  bool v11; // zf
  RwInt32 numTriangles; // r2
  unsigned int v13; // r0
  RwInt32 v14; // r1
  unsigned __int16 *v15; // r6
  RwInt16 matIndex; // r2
  RwUInt16 v17; // r4
  RwUInt16 v18; // r3
  unsigned int v19; // r3
  RpTriangle_0 *v20; // r2
  RwInt32 v21; // r1
  unsigned __int16 *v22; // r0
  int v23; // r1
  int v24; // r11
  int v25; // r2
  int v26; // r4
  RpGeometry_0 *v32; // r0
  RpGeometry_0 *v33; // r0
  RwUInt16 *v34; // lr
  bool v35; // zf
  RpGeometry_0 *v36; // r5
  unsigned __int16 *v37; // r0
  int v38; // r1
  int v39; // r2
  unsigned int v40; // r6
  unsigned int v41; // r12
  unsigned int v42; // r3
  RwUInt16 *v43; // r6
  int v44; // r4
  RwInt32 numMorphTargets; // r0
  int v46; // r4
  RwInt32 v47; // r1
  int v48; // r2
  int v49; // r0
  int v50; // r3
  RwInt32 v51; // r1
  int v52; // r2
  int v53; // r0
  int v54; // lr
  RpGeometry_0 *v55; // r0
  RwTexCoords_0 *v56; // r2
  int v57; // r8
  RwInt32 i; // r4
  int v59; // r12
  __int64 v60; // d16
  int v61; // r5
  int v62; // r6
  int v63; // r0
  __int64 v64; // d16
  RwInt32 numTexCoordSets; // r1
  RpGeometry_0 *v66; // r6
  RwInt32 j; // r0
  RwUInt16 *v68; // r4
  RwReal *p_u; // r1
  int v70; // t1
  RwReal v; // r6
  int v72; // r4
  RwInt32 v73; // r8
  RpMorphTarget_0 *v74; // r11
  __int64 v75; // d17
  RwPluginRegEntry_0 *k; // r4
  signed int size; // r2
  RwUInt16 *v78; // r2
  int v81; // [sp+8h] [bp-50h]
  RwRGBA_0 *preLitLum; // [sp+8h] [bp-50h]
  RwUInt32 v83; // [sp+Ch] [bp-4Ch]
  RwRGBA_0 *v84; // [sp+Ch] [bp-4Ch]
  RwUInt16 *v85; // [sp+10h] [bp-48h]
  int v86; // [sp+14h] [bp-44h]
  RpGeometry_0 *geometry; // [sp+18h] [bp-40h]
  int v88; // [sp+1Ch] [bp-3Ch]
  int v89; // [sp+20h] [bp-38h]
  int v90; // [sp+24h] [bp-34h]
  RwSphere_0 boundingSphere; // [sp+28h] [bp-30h] BYREF

  flags = source->flags;
  v4 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * source->numMorphTargets);
  v5 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * source->numMorphTargets);
  v6 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * source->numMorphTargets);
  v90 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(4 * source->numMorphTargets);
  v7 = (unsigned __int16 *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(24 * source->numTriangles);
  v83 = flags;
  v88 = v4;
  v89 = v5;
  if ( (flags & 0x10) != 0 )
  {
    v8 = v90;
    v9 = v6;
    if ( !v4 )
      goto LABEL_25;
    _ZF = v89 == 0;
    if ( v89 )
      _ZF = v6 == 0;
    if ( _ZF )
      goto LABEL_25;
  }
  else
  {
    v8 = v90;
    v9 = v6;
    if ( !v6 )
    {
LABEL_25:
      if ( v7 )
      {
        (*((void (__fastcall **)(unsigned __int16 *))RwEngineInstance + 76))(v7);
        v8 = v90;
      }
      if ( v8 )
        (*((void (__fastcall **)(int))RwEngineInstance + 76))(v8);
      if ( v9 )
        (*((void (__fastcall **)(int))RwEngineInstance + 76))(v9);
      if ( v89 )
        (*((void (**)(void))RwEngineInstance + 76))();
      if ( v4 )
        (*((void (**)(void))RwEngineInstance + 76))();
      return 0;
    }
  }
  v11 = v8 == 0;
  if ( v8 )
    v11 = v7 == 0;
  if ( v11 )
    goto LABEL_25;
  v81 = flags & 0x10;
  numTriangles = source->numTriangles;
  if ( numTriangles >= 1 )
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = &v7[3 * v13 / 2];
      matIndex = source->triangles[v13 / 8].matIndex;
      v15[2] = matIndex;
      v17 = source->triangles[v13 / 8].vertIndex[0];
      *(_DWORD *)v15 = v14;
      v15[3] = v17;
      v15[6] = matIndex;
      v18 = source->triangles[v13 / 8].vertIndex[1];
      *((_DWORD *)v15 + 2) = v14 | 0x40000000;
      v15[7] = v18;
      v19 = v14 | 0x80000000;
      v15[10] = matIndex;
      ++v14;
      v20 = &source->triangles[v13 / 8];
      v13 += 8;
      LOWORD(v20) = v20->vertIndex[2];
      *((_DWORD *)v15 + 4) = v19;
      v15[11] = (unsigned __int16)v20;
      numTriangles = source->numTriangles;
    }
    while ( v14 < numTriangles );
  }
  qsort(v7, 3 * numTriangles, 8u, SortVertsByMaterialCB);
  v21 = source->numTriangles;
  if ( v21 < 1 )
  {
    v24 = -1;
  }
  else
  {
    v22 = v7 + 2;
    v23 = 3 * v21;
    v24 = -1;
    v25 = 0;
    do
    {
      if ( v25 && *(v22 - 4) == *v22 )
      {
        if ( *(v22 - 3) != v22[1] )
          ++v24;
      }
      else
      {
        ++v24;
      }
      ++v25;
      v22 += 4;
    }
    while ( v25 < v23 );
  }
  v26 = (*((int (__fastcall **)(int))RwEngineInstance + 75))(2 * (v24 + 1));
  _R0 = source->numTexCoordSets << 16;
  v86 = v24 + 1;
  __asm { UXTB16.W        R0, R0 }
  v32 = RpGeometryCreate(v24 + 1, source->numTriangles, v83 | _R0);
  v33 = RpGeometryLock(v32, 4095);
  v34 = (RwUInt16 *)v26;
  v35 = v26 == 0;
  v36 = v33;
  if ( v26 )
    v35 = v33 == 0;
  if ( v35 )
  {
    (*((void (__fastcall **)(unsigned __int16 *))RwEngineInstance + 76))(v7);
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v90);
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v9);
    if ( v26 )
      (*((void (**)(void))RwEngineInstance + 76))();
    if ( !v36 )
      return 0;
    v55 = v36;
    goto LABEL_99;
  }
  geometry = v33;
  if ( source->numTriangles >= 1 )
  {
    v37 = v7 + 3;
    v38 = -1;
    v39 = 0;
    do
    {
      v40 = *(_DWORD *)(v37 - 3);
      v41 = v40 >> 30;
      v42 = ((v40 | 0x3FFFFFFF) ^ 0xC0000000) & v40;
      if ( v39 && *(v37 - 5) == *(v37 - 1) && *(v37 - 4) == *v37 )
      {
        v43 = &v7[4 * v39 + 3];
      }
      else
      {
        ++v38;
        v43 = v37;
      }
      v37 += 4;
      ++v39;
      v44 = (int)&geometry->triangles[v42];
      *(_WORD *)(v44 + 2 * v41) = v38;
      *(_WORD *)(v44 + 6) = source->triangles[v42].matIndex;
      v34[v38] = *v43;
    }
    while ( v39 < 3 * source->numTriangles );
  }
  v85 = v34;
  (*((void (__fastcall **)(unsigned __int16 *))RwEngineInstance + 76))(v7);
  numMorphTargets = source->numMorphTargets;
  if ( numMorphTargets >= 2 )
  {
    v46 = 0;
    do
    {
      RpGeometryAddMorphTarget(geometry);
      numMorphTargets = source->numMorphTargets;
      ++v46;
    }
    while ( v46 < numMorphTargets - 1 );
  }
  if ( geometry->numMorphTargets != numMorphTargets )
  {
    RpGeometryDestroy(geometry);
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v90);
    (*((void (__fastcall **)(int))RwEngineInstance + 76))(v9);
    (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v34);
    return 0;
  }
  if ( numMorphTargets >= 1 )
  {
    v47 = 0;
    v48 = 20;
    do
    {
      *(_DWORD *)(v9 + 4 * v47) = *(RpGeometry_0 **)((char *)&source->morphTarget->parentGeom + v48);
      v49 = *(int *)((char *)&geometry->morphTarget->parentGeom + v48);
      v48 += 28;
      *(_DWORD *)(v90 + 4 * v47++) = v49;
      numMorphTargets = source->numMorphTargets;
    }
    while ( v47 < numMorphTargets );
  }
  v50 = v88;
  if ( v81 )
  {
    if ( numMorphTargets >= 1 )
    {
      v51 = 0;
      v52 = 24;
      do
      {
        *(_DWORD *)(v88 + 4 * v51) = *(RpGeometry_0 **)((char *)&source->morphTarget->parentGeom + v52);
        v53 = *(int *)((char *)&geometry->morphTarget->parentGeom + v52);
        v52 += 28;
        *(_DWORD *)(v89 + 4 * v51++) = v53;
        numMorphTargets = source->numMorphTargets;
      }
      while ( v51 < numMorphTargets );
    }
    v54 = 1;
  }
  else
  {
    v54 = 0;
  }
  v56 = (RwTexCoords_0 *)(v83 << 28);
  if ( (v83 & 8) != 0 )
  {
    v57 = 1;
    preLitLum = geometry->preLitLum;
    v84 = source->preLitLum;
    if ( v24 < 0 )
      goto LABEL_78;
  }
  else
  {
    v57 = 0;
    v84 = 0;
    preLitLum = 0;
    if ( v24 < 0 )
      goto LABEL_78;
  }
  v50 = 0;
  do
  {
    v56 = (RwTexCoords_0 *)v85[v50];
    if ( v57 )
    {
      preLitLum[v50] = v84[(_DWORD)v56];
      numMorphTargets = source->numMorphTargets;
    }
    if ( numMorphTargets >= 1 )
    {
      for ( i = 0; i < numMorphTargets; ++i )
      {
        v59 = *(_DWORD *)(v9 + 4 * i) + 12 * (_DWORD)v56;
        v60 = *(_QWORD *)v59;
        v61 = *(_DWORD *)(v90 + 4 * i) + 12 * v50;
        *(_DWORD *)(v61 + 8) = *(_DWORD *)(v59 + 8);
        *(_QWORD *)v61 = v60;
        if ( v54 )
        {
          v62 = *(_DWORD *)(v88 + 4 * i) + 12 * (_DWORD)v56;
          v63 = *(_DWORD *)(v89 + 4 * i) + 12 * v50;
          v64 = *(_QWORD *)v62;
          *(_DWORD *)(v63 + 8) = *(_DWORD *)(v62 + 8);
          *(_QWORD *)v63 = v64;
        }
        numMorphTargets = source->numMorphTargets;
      }
    }
    ++v50;
  }
  while ( v50 != v86 );
LABEL_78:
  numTexCoordSets = source->numTexCoordSets;
  v66 = geometry;
  if ( numTexCoordSets >= 1 )
  {
    for ( j = 0; j < numTexCoordSets; ++j )
    {
      if ( v24 >= 0 )
      {
        v50 = v24 + 1;
        v68 = v85;
        p_u = &v66->texCoords[j]->u;
        v56 = source->texCoords[j];
        do
        {
          v70 = *v68++;
          --v50;
          v = v56[v70].v;
          *p_u = v56[v70].u;
          p_u[1] = v;
          p_u += 2;
        }
        while ( v50 );
        numTexCoordSets = source->numTexCoordSets;
        v66 = geometry;
      }
    }
  }
  if ( v66->numMorphTargets >= 1 )
  {
    v72 = 0;
    v73 = 0;
    do
    {
      v74 = &v66->morphTarget[v72];
      RpMorphTargetCalcBoundingSphere(v74, &boundingSphere);
      v75 = *(_QWORD *)&boundingSphere.center.z;
      ++v72;
      ++v73;
      *(_QWORD *)&v74->boundingSphere.center.x = *(_QWORD *)&boundingSphere.center.x;
      *(_QWORD *)&v74->boundingSphere.center.z = v75;
    }
    while ( v73 < v66->numMorphTargets );
  }
  (*((void (__fastcall **)(int, _DWORD, RwTexCoords_0 *, int))RwEngineInstance + 76))(
    v90,
    *((_DWORD *)RwEngineInstance + 76),
    v56,
    v50);
  (*((void (__fastcall **)(int))RwEngineInstance + 76))(v9);
  (*((void (__fastcall **)(int))RwEngineInstance + 76))(v89);
  (*((void (__fastcall **)(int))RwEngineInstance + 76))(v88);
  if ( !_rpMaterialListCopy(&v66->matList, &source->matList) )
  {
    (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v85);
LABEL_98:
    v55 = v66;
LABEL_99:
    RpGeometryDestroy(v55);
    return 0;
  }
  for ( k = _rpGeometryGetTKListFirstRegEntry(); k; k = k->nextRegEntry )
  {
    size = k->size;
    if ( size >= 1 )
      qmemcpy(&v66->object.type + k->offset, &source->object.type + k->offset, size);
  }
  v78 = v85;
  if ( callback )
  {
    callback(source, v66, v85, v86);
    v78 = v85;
  }
  (*((void (__fastcall **)(RwUInt16 *))RwEngineInstance + 76))(v78);
  if ( !RpGeometryUnlock(v66) )
    goto LABEL_98;
  return v66;
}
// 21F57E: variable 'v56' is possibly undefined
// 21F57E: variable 'v50' is possibly undefined

//----- (0021F654) --------------------------------------------------------
int __fastcall SortVertsByMaterialCB(const void *data1, const void *data2)
{
  int v2; // r2
  int v3; // r3
  int result; // r0
  unsigned int v5; // r1
  unsigned int v6; // r0
  bool v7; // cf

  v2 = *((__int16 *)data2 + 2);
  v3 = *((__int16 *)data1 + 2);
  if ( v3 > v2 )
    return 1;
  if ( v3 < v2 )
    return -1;
  v5 = *((unsigned __int16 *)data2 + 3);
  v6 = *((unsigned __int16 *)data1 + 3);
  v7 = v6 >= v5;
  if ( v6 > v5 )
    return 1;
  result = 0;
  if ( !v7 )
    return -1;
  return result;
}

//----- (0021F684) --------------------------------------------------------
RxPipeline_0 *__fastcall RpWorldSetDefaultSectorPipeline(RxPipeline_0 *pipeline)
{
  if ( !pipeline )
    pipeline = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 88);
  *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 64) = pipeline;
  return pipeline;
}

//----- (0021F6AC) --------------------------------------------------------
RxPipeline_0 *__fastcall RpAtomicSetDefaultPipeline(RxPipeline_0 *pipeline)
{
  if ( !pipeline )
    pipeline = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 84);
  *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 60) = pipeline;
  return pipeline;
}

//----- (0021F6D4) --------------------------------------------------------
RxPipeline_0 *__fastcall RpMaterialSetDefaultPipeline(RxPipeline_0 *pipeline)
{
  if ( !pipeline )
    pipeline = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 92);
  *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 68) = pipeline;
  return pipeline;
}

//----- (0021F6FC) --------------------------------------------------------
void _rpWorldPipelineClose()
{
  _rpDestroyPlatformWorldSectorPipelines();
  _rpDestroyPlatformAtomicPipelines();
  sub_19011C();
}

//----- (0021F710) --------------------------------------------------------
RwBool _rpWorldPipelineOpen()
{
  if ( _rpCreatePlatformMaterialPipelines()
    && _rpCreatePlatformAtomicPipelines()
    && _rpCreatePlatformWorldSectorPipelines() )
  {
    return 1;
  }
  _rpDestroyPlatformWorldSectorPipelines();
  _rpDestroyPlatformAtomicPipelines();
  _rpDestroyPlatformMaterialPipelines();
  return 0;
}

//----- (0021F73C) --------------------------------------------------------
RwBool _rpWorldPipeAttach()
{
  return 1;
}

//----- (0021F740) --------------------------------------------------------
void __fastcall RegisterStream(
        RQVertexAttributeType type,
        unsigned int count,
        RQVertexAttributeFormat form,
        bool normalized,
        __int64 stride,
        bool ownsBuffer)
{
  bool v8; // r6
  unsigned int numEntries; // r11
  unsigned int v10; // r4
  void *v11; // r12
  unsigned int v12; // r8
  _rpGeometryStreamBuilder *dataPtr; // r5
  _rpGeometryStreamBuilder *v14; // r6
  _rpGeometryStreamBuilder *v15; // r1
  _rpGeometryStreamBuilder *v16; // r1
  _rpGeometryStreamBuilder *v17; // r0
  RQVertexAttributeFormat v18; // [sp+4h] [bp-24h]
  bool v19; // [sp+8h] [bp-20h]

  v8 = ownsBuffer;
  numEntries = streams.numEntries;
  v11 = (void *)HIDWORD(stride);
  v10 = stride;
  if ( streams.numAlloced >= streams.numEntries + 1 )
  {
    dataPtr = streams.dataPtr;
  }
  else
  {
    v18 = form;
    v19 = normalized;
    v12 = 4 * (streams.numEntries + 1) / 3 + 3;
    dataPtr = (_rpGeometryStreamBuilder *)malloc(32 * v12);
    v14 = streams.dataPtr;
    if ( streams.dataPtr )
    {
      qmemcpy(dataPtr, streams.dataPtr, 32 * numEntries);
      free(v14);
      numEntries = streams.numEntries;
    }
    normalized = v19;
    v8 = ownsBuffer;
    v11 = (void *)HIDWORD(stride);
    v10 = stride;
    form = v18;
    streams.dataPtr = dataPtr;
    streams.numAlloced = v12;
  }
  v15 = &dataPtr[numEntries];
  *(_QWORD *)&v15->type = 0LL;
  *(_QWORD *)&v15->desc.count = 0LL;
  v15 = (_rpGeometryStreamBuilder *)((char *)v15 + 16);
  *(_QWORD *)&v15->type = 0LL;
  *(_QWORD *)&v15->desc.count = 0LL;
  streams.numEntries = numEntries + 1;
  dataPtr[numEntries].type = type;
  streams.dataPtr[numEntries].desc.count = count;
  v16 = &streams.dataPtr[numEntries];
  v16->desc.normalized = normalized;
  v16->desc.format = form;
  v17 = &streams.dataPtr[numEntries];
  v17->ownsBuffer = v8;
  v17->desc.stride = v10;
  v17->buffer = v11;
}

//----- (0021F838) --------------------------------------------------------
bool __fastcall _rpGeometryNeedsPrecideUVs(const RpGeometry_0 *geometry, int texCoordIndex)
{
  RwInt32 numVertices; // r2
  char *v4; // r0
  int v5; // r1
  int i; // r0

  numVertices = geometry->numVertices;
  if ( numVertices < 1 )
    return 0;
  v4 = (char *)geometry + 4 * texCoordIndex;
  v5 = 0;
  for ( i = *((_DWORD *)v4 + 13) + 4; *(float *)(i - 4) <= 63.998; i += 8 )
  {
    if ( ++v5 >= numVertices )
      return 0;
  }
  return 1;
}

//----- (0021F884) --------------------------------------------------------
bool __fastcall _rpGeometryNeedsPreciseSkin(const RpGeometry_0 *geometry, RpSkin_0 *skin)
{
  float32x4_t v2; // q0
  RpSkin_0 *v4; // r0
  const RwMatrixWeights_0 *VertexBoneWeights; // r0
  unsigned int numVertices; // r3
  int v7; // r1
  int8x16_t v8; // q8
  const RwMatrixWeights_0 *v9; // r2
  const float *p_w3; // r0
  const float *v11; // r0
  float32x4_t v12; // q9
  unsigned __int32 *v14; // r0

  if ( skin->vertexMaps.maxWeights != 4 )
    return 0;
  v4 = j_RpSkinGeometryGetSkin((RpGeometry_0 *)geometry);
  VertexBoneWeights = j_RpSkinGetVertexBoneWeights(v4);
  numVertices = geometry->numVertices;
  if ( !numVertices )
    return 0;
  v2.n128_u32[0] = 0;
  if ( numVertices < 4 )
    goto LABEL_13;
  v7 = geometry->numVertices & 3;
  if ( (numVertices & 3) == 0 )
    v7 = 4;
  if ( numVertices == v7 )
  {
LABEL_13:
    v7 = geometry->numVertices;
    v9 = VertexBoneWeights;
  }
  else
  {
    v8 = 0uLL;
    v9 = &VertexBoneWeights[numVertices - v7];
    p_w3 = &VertexBoneWeights->w3;
    do
    {
      v12.n128_u64[0] = (unsigned __int64)vld4_f32(p_w3);
      v11 = p_w3 + 8;
      numVertices -= 4;
      v12.n128_u64[1] = (unsigned __int64)vld4_f32(v11);
      p_w3 = v11 + 8;
      v8 = vmaxq_f32(v12, v8);
    }
    while ( v7 != numVertices );
    v2 = vmaxq_f32(v8, vextq_s8(v8, v8, 8u));
    if ( vmovn_s32(vcgtq_f32(v2, vdupq_lane_s32((int32x2_t)v2.n128_u64[0], 1))).n64_u16[0] << 31 )
      v2.n128_u32[1] = v2.n128_u32[0];
    v2.n128_u32[0] = v2.n128_u32[1];
  }
  v14 = (unsigned __int32 *)&v9->w3;
  do
  {
    v2.n128_u32[2] = *v14;
    v14 += 4;
    --v7;
    v2.n128_u64[0] = vmax_f32(*(float32x2_t *)&v2.n128_i8[8], (float32x2_t)v2.n128_u64[0]).n64_u64[0];
  }
  while ( v7 );
  return v2.n128_f32[0] >= 0.07;
}
// 21F908: variable 'v2' is possibly undefined

//----- (0021F92C) --------------------------------------------------------
RwInt8 __fastcall _rpGeometryNativeCompressNormal(float val)
{
  int v1; // r0

  if ( val >= 0.0 )
  {
    v1 = (int)(float)((float)(val * 127.0) + 0.5);
    if ( v1 >= 127 )
      LOBYTE(v1) = 127;
  }
  else
  {
    v1 = (int)(float)((float)(val * 128.0) + 0.5);
    if ( v1 <= -128 )
      LOBYTE(v1) = 0x80;
  }
  return v1;
}

//----- (0021F98C) --------------------------------------------------------
RwInt16 __fastcall _rpGeometryNativeCompressTexCoord(float val)
{
  return (int)(float)(val * 512.0);
}

//----- (0021F9A8) --------------------------------------------------------
RwStream_0 *__fastcall _rpGeometryNativeWrite(RwStream_0 *stream, const RpGeometry_0 *geometry)
{
  float32x4_t v2; // q0
  RwV3d_0 *verts; // r5
  _rpGeometryStreamBuilder *dataPtr; // r4
  unsigned int numEntries; // r0
  _rpGeometryStreamBuilder *v7; // r2
  _rpGeometryStreamBuilder *v8; // r2
  _rpGeometryStreamBuilder *v9; // r10
  _rpGeometryStreamBuilder *v10; // r0
  RwInt32 numVertices; // r4
  RwTexCoords_0 *v12; // r5
  RwInt32 v13; // r1
  RwReal *p_v; // r0
  char *v15; // r6
  RwInt32 v16; // r0
  char *v17; // r1
  float v; // s2
  unsigned int v19; // r6
  unsigned int v20; // r4
  _rpGeometryStreamBuilder *v21; // r0
  _rpGeometryStreamBuilder *v22; // r8
  unsigned int v23; // r5
  unsigned int v24; // r10
  _rpGeometryStreamBuilder *v25; // r4
  _rpGeometryStreamBuilder *v26; // r8
  _rpGeometryStreamBuilder *v27; // r0
  char v28; // r0
  _rpGeometryStreamBuilder *v29; // r2
  int v30; // r2
  _rpGeometryStreamBuilder *v31; // r1
  _rpGeometryStreamBuilder *v32; // r0
  _rpGeometryStreamBuilder *v33; // r2
  RwUInt32 flags; // r0
  RwInt32 v35; // r4
  char *v36; // r6
  RwV3d_0 *normals; // r0
  RwInt32 v38; // r5
  float x; // s6
  char *v40; // r4
  int v41; // r1
  float y; // s6
  int v43; // r1
  float z; // s6
  int v45; // r1
  unsigned int v46; // r5
  unsigned int v47; // r10
  _rpGeometryStreamBuilder *v48; // r4
  _rpGeometryStreamBuilder *v49; // r8
  _rpGeometryStreamBuilder *v50; // r1
  _rpGeometryStreamBuilder *v51; // r1
  _rpGeometryStreamBuilder *v52; // r0
  unsigned int v53; // r5
  RwRGBA_0 *preLitLum; // r8
  unsigned int v55; // r4
  _rpGeometryStreamBuilder *v56; // r0
  _rpGeometryStreamBuilder *v57; // r6
  _rpGeometryStreamBuilder *v58; // r1
  _rpGeometryStreamBuilder *v59; // r1
  _rpGeometryStreamBuilder *v60; // r0
  RwRGBA_0 *ExtraColorPtr; // r8
  unsigned int v62; // r5
  unsigned int v63; // r10
  _rpGeometryStreamBuilder *v64; // r6
  _rpGeometryStreamBuilder *v65; // r4
  _rpGeometryStreamBuilder *v66; // r1
  _rpGeometryStreamBuilder *v67; // r1
  _rpGeometryStreamBuilder *v68; // r0
  RwRGBA_0 *v69; // r0
  unsigned int v70; // r1
  RwRGBA_0 *v71; // r3
  unsigned int v72; // r6
  RwRGBA_0 *v73; // r3
  unsigned int v74; // r6
  RwRGBA_0 *v75; // r3
  unsigned int v76; // r6
  RwRGBA_0 *v77; // r6
  unsigned int v78; // r3
  int green; // r5
  int blue; // r4
  char v81; // r3
  char v82; // r3
  RpSkin_0 *Skin; // r0
  RpSkin_0 *v84; // r8
  const RwMatrixWeights_0 *VertexBoneWeights; // r6
  RpSkin_0 *v86; // r0
  const RwMatrixWeights_0 *v87; // r0
  RwInt32 v88; // r5
  RwInt32 *p_numVertices; // r11
  RwInt32 v90; // r3
  char *v91; // lr
  int v92; // r1
  int8x16_t v93; // q8
  const RwMatrixWeights_0 *v94; // r2
  const float *p_w3; // r0
  RwInt32 v96; // r3
  const float *v97; // r0
  float32x4_t v98; // q9
  unsigned __int32 *v99; // r0
  _WORD *v100; // r4
  RwInt32 v101; // r0
  _WORD *v102; // r1
  float w3; // s2
  unsigned int v104; // r5
  _rpGeometryStreamBuilder *v105; // r6
  _rpGeometryStreamBuilder *v106; // r10
  float *v107; // r0
  _BYTE *v108; // r1
  RwInt32 v109; // r5
  float v110; // s4
  float v111; // s2
  float *p_w2; // r4
  float v113; // s4
  unsigned int v114; // s2
  unsigned int v115; // r5
  unsigned int v116; // r10
  _rpGeometryStreamBuilder *v117; // r4
  _rpGeometryStreamBuilder *v118; // r6
  _rpGeometryStreamBuilder *v119; // r1
  _rpGeometryStreamBuilder *v120; // r1
  _rpGeometryStreamBuilder *v121; // r0
  const RwUInt32 *VertexBoneIndices; // r6
  char *v123; // r4
  RwInt32 v124; // r0
  char *v125; // r2
  const RwUInt32 *v126; // r1
  unsigned int v127; // r5
  unsigned int v128; // r10
  _rpGeometryStreamBuilder *v129; // r6
  _rpGeometryStreamBuilder *v130; // r8
  _rpGeometryStreamBuilder *v131; // r1
  _rpGeometryStreamBuilder *v132; // r1
  _rpGeometryStreamBuilder *v133; // r0
  unsigned int v134; // r4
  unsigned int v135; // r1
  unsigned int v136; // r5
  unsigned int *p_offset; // r0
  int v138; // r2
  RwInt32 v139; // r6
  char *v140; // r0
  unsigned int v141; // r1
  unsigned int v142; // r8
  _rpGeometryStreamBuilder *v143; // r0
  _rpGeometryStreamBuilder *v144; // r0
  RwInt32 v145; // r11
  unsigned int stride; // r2
  char *buffer; // r4
  char *v148; // r6
  _rpGeometryStreamBuilder *v149; // r1
  _rpGeometryStreamBuilder *v150; // r1
  unsigned int v151; // r2
  unsigned int *p_stride; // r0
  int v153; // r4
  unsigned int v154; // r6
  _rpGeometryStreamBuilder *v156; // r1
  _rpGeometryStreamBuilder *v157; // r1
  char *v158; // [sp+4h] [bp-2Ch]
  unsigned int v160; // [sp+Ch] [bp-24h]
  RwInt32 ints[8]; // [sp+10h] [bp-20h] BYREF

  if ( !(HIBYTE(geometry->flags) << 31) )
    return stream;
  streams.numEntries = 0;
  verts = geometry->morphTarget->verts;
  if ( streams.numAlloced )
  {
    dataPtr = streams.dataPtr;
    numEntries = 0;
  }
  else
  {
    dataPtr = (_rpGeometryStreamBuilder *)malloc(0x80u);
    if ( streams.dataPtr )
    {
      free(streams.dataPtr);
      numEntries = streams.numEntries;
    }
    else
    {
      numEntries = 0;
    }
    streams.dataPtr = dataPtr;
    streams.numAlloced = 4;
  }
  v7 = &dataPtr[numEntries];
  *(_QWORD *)&v7->type = 0LL;
  *(_QWORD *)&v7->desc.count = 0LL;
  v7 = (_rpGeometryStreamBuilder *)((char *)v7 + 16);
  *(_QWORD *)&v7->type = 0LL;
  *(_QWORD *)&v7->desc.count = 0LL;
  streams.numEntries = numEntries + 1;
  dataPtr[numEntries].type = VAT_Position;
  streams.dataPtr[numEntries].desc.count = 3;
  v8 = &streams.dataPtr[numEntries];
  v8->desc.normalized = 0;
  v8->desc.format = VAF_Float;
  v9 = streams.dataPtr;
  v10 = &streams.dataPtr[numEntries];
  v10->ownsBuffer = 0;
  v10->buffer = verts;
  v10->desc.stride = 12;
  if ( geometry->numTexCoordSets >= 1 )
  {
    numVertices = geometry->numVertices;
    if ( numVertices <= 0 )
    {
      v15 = (char *)malloc(4 * numVertices);
LABEL_21:
      v23 = streams.numEntries;
      if ( streams.numAlloced >= streams.numEntries + 1 )
      {
        v25 = streams.dataPtr;
      }
      else
      {
        v24 = 4 * (streams.numEntries + 1) / 3 + 3;
        v25 = (_rpGeometryStreamBuilder *)malloc(32 * v24);
        v26 = streams.dataPtr;
        if ( streams.dataPtr )
        {
          qmemcpy(v25, streams.dataPtr, 32 * v23);
          free(v26);
          v23 = streams.numEntries;
        }
        streams.dataPtr = v25;
        streams.numAlloced = v24;
      }
      v27 = &v25[v23];
      *(_QWORD *)&v27->type = 0LL;
      *(_QWORD *)&v27->desc.count = 0LL;
      v27 = (_rpGeometryStreamBuilder *)((char *)v27 + 16);
      *(_QWORD *)&v27->type = 0LL;
      *(_QWORD *)&v27->desc.count = 0LL;
      streams.numEntries = v23 + 1;
      v28 = 1;
      v25[v23].type = VAT_TexCoord;
      streams.dataPtr[v23].desc.count = 2;
      v29 = &streams.dataPtr[v23];
      v29->desc.normalized = 0;
      v29->desc.format = VAF_Short;
      v30 = 4;
      v9 = streams.dataPtr;
      v31 = &streams.dataPtr[v23];
      v31->buffer = v15;
    }
    else
    {
      v12 = geometry->texCoords[0];
      v13 = 0;
      p_v = &v12->v;
      while ( *(p_v - 1) <= 63.998 )
      {
        ++v13;
        p_v += 2;
        if ( v13 >= numVertices )
        {
          v15 = (char *)malloc(4 * numVertices);
          v16 = 0;
          do
          {
            *(_WORD *)&v15[4 * v16] = (int)(float)(v12->u * 512.0);
            v17 = &v15[4 * v16++];
            v = v12->v;
            ++v12;
            *((_WORD *)v17 + 1) = (int)(float)(v * 512.0);
          }
          while ( v16 < geometry->numVertices );
          goto LABEL_21;
        }
      }
      v19 = streams.numEntries;
      if ( streams.numAlloced >= streams.numEntries + 1 )
      {
        v22 = v9;
      }
      else
      {
        v20 = 4 * (streams.numEntries + 1) / 3 + 3;
        v21 = (_rpGeometryStreamBuilder *)malloc(32 * v20);
        v22 = v21;
        if ( v9 )
        {
          qmemcpy(v21, v9, 32 * v19);
          free(v9);
          v19 = streams.numEntries;
        }
        streams.dataPtr = v22;
        streams.numAlloced = v20;
      }
      v32 = &v22[v19];
      *(_QWORD *)&v32->type = 0LL;
      *(_QWORD *)&v32->desc.count = 0LL;
      v32 = (_rpGeometryStreamBuilder *)((char *)v32 + 16);
      *(_QWORD *)&v32->type = 0LL;
      *(_QWORD *)&v32->desc.count = 0LL;
      streams.numEntries = v19 + 1;
      v22[v19].type = VAT_TexCoord;
      streams.dataPtr[v19].desc.count = 2;
      v33 = &streams.dataPtr[v19];
      v28 = 0;
      v33->desc.normalized = 0;
      v33->desc.format = VAF_Float;
      v30 = 8;
      v9 = streams.dataPtr;
      v31 = &streams.dataPtr[v19];
      v31->buffer = v12;
    }
    v31->desc.stride = v30;
    v31->ownsBuffer = v28;
  }
  flags = geometry->flags;
  if ( (flags & 0x10) != 0 )
  {
    v35 = geometry->numVertices;
    v36 = (char *)malloc(4 * v35);
    if ( v35 >= 1 )
    {
      normals = geometry->morphTarget->normals;
      v38 = 0;
      do
      {
        x = normals->x;
        v40 = &v36[4 * v38];
        if ( normals->x >= 0.0 )
        {
          v41 = (int)(float)((float)(x * 127.0) + 0.5);
          if ( v41 >= 127 )
            LOBYTE(v41) = 127;
        }
        else
        {
          v41 = (int)(float)((float)(x * 128.0) + 0.5);
          if ( v41 <= -128 )
            LOBYTE(v41) = 0x80;
        }
        *v40 = v41;
        y = normals->y;
        if ( y >= 0.0 )
        {
          v43 = (int)(float)((float)(y * 127.0) + 0.5);
          if ( v43 >= 127 )
            LOBYTE(v43) = 127;
        }
        else
        {
          v43 = (int)(float)((float)(y * 128.0) + 0.5);
          if ( v43 <= -128 )
            LOBYTE(v43) = 0x80;
        }
        v40[1] = v43;
        z = normals->z;
        if ( z >= 0.0 )
        {
          v45 = (int)(float)((float)(z * 127.0) + 0.5);
          if ( v45 >= 127 )
            LOBYTE(v45) = 127;
        }
        else
        {
          v45 = (int)(float)((float)(z * 128.0) + 0.5);
          if ( v45 <= -128 )
            LOBYTE(v45) = 0x80;
        }
        v40[3] = 0;
        ++normals;
        v40[2] = v45;
        ++v38;
      }
      while ( v38 < geometry->numVertices );
    }
    v46 = streams.numEntries;
    if ( streams.numAlloced >= streams.numEntries + 1 )
    {
      v48 = streams.dataPtr;
    }
    else
    {
      v47 = 4 * (streams.numEntries + 1) / 3 + 3;
      v48 = (_rpGeometryStreamBuilder *)malloc(32 * v47);
      v49 = streams.dataPtr;
      if ( streams.dataPtr )
      {
        qmemcpy(v48, streams.dataPtr, 32 * v46);
        free(v49);
        v46 = streams.numEntries;
      }
      streams.dataPtr = v48;
      streams.numAlloced = v47;
    }
    v50 = &v48[v46];
    *(_QWORD *)&v50->type = 0LL;
    *(_QWORD *)&v50->desc.count = 0LL;
    v50 = (_rpGeometryStreamBuilder *)((char *)v50 + 16);
    *(_QWORD *)&v50->type = 0LL;
    *(_QWORD *)&v50->desc.count = 0LL;
    streams.numEntries = v46 + 1;
    v48[v46].type = VAT_Normal;
    streams.dataPtr[v46].desc.count = 3;
    v51 = &streams.dataPtr[v46];
    v51->desc.normalized = 1;
    v51->desc.format = VAF_Byte;
    v9 = streams.dataPtr;
    v52 = &streams.dataPtr[v46];
    v52->ownsBuffer = 1;
    v52->buffer = v36;
    v52->desc.stride = 4;
    flags = geometry->flags;
    if ( (flags & 8) == 0 )
    {
LABEL_32:
      if ( (flags & 0x200) == 0 )
        goto LABEL_73;
      goto LABEL_67;
    }
  }
  else if ( (flags & 8) == 0 )
  {
    goto LABEL_32;
  }
  v53 = streams.numEntries;
  preLitLum = geometry->preLitLum;
  if ( streams.numAlloced >= streams.numEntries + 1 )
  {
    v57 = v9;
  }
  else
  {
    v55 = 4 * (streams.numEntries + 1) / 3 + 3;
    v56 = (_rpGeometryStreamBuilder *)malloc(32 * v55);
    v57 = v56;
    if ( v9 )
    {
      qmemcpy(v56, v9, 32 * v53);
      free(v9);
      v53 = streams.numEntries;
    }
    streams.dataPtr = v57;
    streams.numAlloced = v55;
  }
  v58 = &v57[v53];
  *(_QWORD *)&v58->type = 0LL;
  *(_QWORD *)&v58->desc.count = 0LL;
  v58 = (_rpGeometryStreamBuilder *)((char *)v58 + 16);
  *(_QWORD *)&v58->type = 0LL;
  *(_QWORD *)&v58->desc.count = 0LL;
  streams.numEntries = v53 + 1;
  v57[v53].type = VAT_Color;
  streams.dataPtr[v53].desc.count = 4;
  v59 = &streams.dataPtr[v53];
  v59->desc.normalized = 1;
  v59->desc.format = VAF_UByte;
  v60 = &streams.dataPtr[v53];
  v60->ownsBuffer = 0;
  v60->buffer = preLitLum;
  v60->desc.stride = 4;
  flags = geometry->flags;
  if ( (flags & 0x200) != 0 )
  {
LABEL_67:
    ExtraColorPtr = GetExtraColorPtr((RpGeometry_0 *)geometry);
    v62 = streams.numEntries;
    if ( streams.numAlloced >= streams.numEntries + 1 )
    {
      v64 = streams.dataPtr;
    }
    else
    {
      v63 = 4 * (streams.numEntries + 1) / 3 + 3;
      v64 = (_rpGeometryStreamBuilder *)malloc(32 * v63);
      v65 = streams.dataPtr;
      if ( streams.dataPtr )
      {
        qmemcpy(v64, streams.dataPtr, 32 * v62);
        free(v65);
        v62 = streams.numEntries;
      }
      streams.dataPtr = v64;
      streams.numAlloced = v63;
    }
    v66 = &v64[v62];
    *(_QWORD *)&v66->type = 0LL;
    *(_QWORD *)&v66->desc.count = 0LL;
    v66 = (_rpGeometryStreamBuilder *)((char *)v66 + 16);
    *(_QWORD *)&v66->type = 0LL;
    *(_QWORD *)&v66->desc.count = 0LL;
    streams.numEntries = v62 + 1;
    v64[v62].type = VAT_Color2;
    streams.dataPtr[v62].desc.count = 4;
    v67 = &streams.dataPtr[v62];
    v67->desc.normalized = 1;
    v67->desc.format = VAF_UByte;
    v68 = &streams.dataPtr[v62];
    v68->ownsBuffer = 0;
    v68->buffer = ExtraColorPtr;
    v68->desc.stride = 4;
    flags = geometry->flags;
  }
LABEL_73:
  if ( (flags & 0x208) == 520 )
  {
    v69 = GetExtraColorPtr((RpGeometry_0 *)geometry);
    if ( geometry->numVertices )
    {
      v70 = 0;
      do
      {
        v71 = geometry->preLitLum;
        v72 = v71[v70]._anon_0._anon_0.red + 18;
        if ( v72 >= 0xFF )
          LOBYTE(v72) = -1;
        v71[v70]._anon_0._anon_0.red = v72;
        v73 = &geometry->preLitLum[v70];
        v74 = v73->_anon_0._anon_0.green + 18;
        if ( v74 >= 0xFF )
          LOBYTE(v74) = -1;
        v73->_anon_0._anon_0.green = v74;
        v75 = &geometry->preLitLum[v70];
        v76 = v75->_anon_0._anon_0.blue + 18;
        if ( v76 >= 0xFF )
          LOBYTE(v76) = -1;
        v75->_anon_0._anon_0.blue = v76;
        v77 = &v69[v70];
        v78 = v77->_anon_0._anon_0.red + 18;
        if ( v78 >= 0xFF )
          LOBYTE(v78) = -1;
        green = v77->_anon_0._anon_0.green;
        blue = v77->_anon_0._anon_0.blue;
        v69[v70]._anon_0._anon_0.red = v78;
        v81 = green + 18;
        if ( (unsigned int)(green + 18) >= 0xFF )
          v81 = -1;
        ++v70;
        v77->_anon_0._anon_0.green = v81;
        v82 = blue + 18;
        if ( (unsigned int)(blue + 18) >= 0xFF )
          v82 = -1;
        v77->_anon_0._anon_0.blue = v82;
      }
      while ( v70 < geometry->numVertices );
    }
  }
  Skin = j_RpSkinGeometryGetSkin((RpGeometry_0 *)geometry);
  v84 = Skin;
  if ( !Skin )
    goto LABEL_135;
  VertexBoneWeights = j_RpSkinGetVertexBoneWeights(Skin);
  if ( v84->vertexMaps.maxWeights != 4 )
  {
    p_numVertices = &geometry->numVertices;
    v88 = geometry->numVertices;
    goto LABEL_114;
  }
  v86 = j_RpSkinGeometryGetSkin((RpGeometry_0 *)geometry);
  v87 = j_RpSkinGetVertexBoneWeights(v86);
  p_numVertices = &geometry->numVertices;
  v88 = geometry->numVertices;
  if ( !v88 )
  {
    v91 = (char *)malloc(0);
LABEL_120:
    v115 = streams.numEntries;
    if ( streams.numAlloced >= streams.numEntries + 1 )
    {
      v117 = streams.dataPtr;
    }
    else
    {
      v116 = 4 * (streams.numEntries + 1) / 3 + 3;
      v117 = (_rpGeometryStreamBuilder *)malloc(32 * v116);
      v118 = streams.dataPtr;
      if ( streams.dataPtr )
      {
        qmemcpy(v117, streams.dataPtr, 32 * v115);
        free(v118);
        v115 = streams.numEntries;
      }
      streams.dataPtr = v117;
      streams.numAlloced = v116;
    }
    v119 = &v117[v115];
    *(_QWORD *)&v119->type = 0LL;
    *(_QWORD *)&v119->desc.count = 0LL;
    v119 = (_rpGeometryStreamBuilder *)((char *)v119 + 16);
    *(_QWORD *)&v119->type = 0LL;
    *(_QWORD *)&v119->desc.count = 0LL;
    streams.numEntries = v115 + 1;
    v117[v115].type = VAT_BoneWeight;
    streams.dataPtr[v115].desc.count = 4;
    v120 = &streams.dataPtr[v115];
    v120->desc.normalized = 1;
    v120->desc.format = VAF_UByte;
    v121 = &streams.dataPtr[v115];
    v121->buffer = v91;
    v121->desc.stride = 4;
    goto LABEL_126;
  }
  v2.n128_u32[0] = 0;
  if ( (unsigned int)v88 > 3 )
  {
    v92 = geometry->numVertices & 3;
    v90 = geometry->numVertices;
    if ( (v88 & 3) == 0 )
      v92 = 4;
    if ( v88 != v92 )
    {
      v93 = 0uLL;
      v94 = &v87[v88 - v92];
      p_w3 = &v87->w3;
      v96 = geometry->numVertices;
      do
      {
        v98.n128_u64[0] = (unsigned __int64)vld4_f32(p_w3);
        v97 = p_w3 + 8;
        v96 -= 4;
        v98.n128_u64[1] = (unsigned __int64)vld4_f32(v97);
        p_w3 = v97 + 8;
        v93 = vmaxq_f32(v98, v93);
      }
      while ( v92 != v96 );
      v90 = v92;
      v2 = vmaxq_f32(v93, vextq_s8(v93, v93, 8u));
      if ( vmovn_s32(vcgtq_f32(v2, vdupq_lane_s32((int32x2_t)v2.n128_u64[0], 1))).n64_u16[0] << 31 )
        v2.n128_u32[1] = v2.n128_u32[0];
      v87 = v94;
      v2.n128_u32[0] = v2.n128_u32[1];
    }
  }
  else
  {
    v90 = geometry->numVertices;
  }
  v99 = (unsigned __int32 *)&v87->w3;
  do
  {
    v2.n128_u32[2] = *v99;
    v99 += 4;
    --v90;
    v2.n128_u64[0] = vmax_f32(*(float32x2_t *)&v2.n128_i8[8], (float32x2_t)v2.n128_u64[0]).n64_u64[0];
  }
  while ( v90 );
  if ( v2.n128_f32[0] < 0.07 )
  {
LABEL_114:
    v91 = (char *)malloc(4 * v88);
    if ( v88 >= 1 )
    {
      v107 = &VertexBoneWeights->w3;
      v108 = v91 + 3;
      v109 = 0;
      do
      {
        v110 = *(v107 - 3);
        if ( *v107 == 0.0 )
        {
          *(v108 - 3) = (unsigned int)(float)(v110 * 255.0);
          p_w2 = &VertexBoneWeights->w2;
          v113 = *(v107 - 2) * 255.0;
          v111 = 255.0;
        }
        else
        {
          v111 = 255.0 / (float)((float)(v110 + *(v107 - 2)) + *(v107 - 1));
          *(v108 - 3) = (unsigned int)(float)(v110 * v111);
          p_w2 = v107 - 1;
          v113 = *(v107 - 2) * v111;
        }
        v107 += 4;
        ++VertexBoneWeights;
        v91[4 * v109++ + 1] = (unsigned int)v113;
        v114 = (unsigned int)(float)(v111 * *p_w2);
        *v108 = 0;
        *(v108 - 1) = v114;
        v108 += 4;
      }
      while ( v109 < *p_numVertices );
    }
    goto LABEL_120;
  }
  v100 = malloc(8 * v88);
  if ( v88 >= 1 )
  {
    v101 = 0;
    do
    {
      v100[4 * v101] = (unsigned int)(float)(VertexBoneWeights->w0 * 65535.0);
      v102 = &v100[4 * v101++];
      v102[1] = (unsigned int)(float)(VertexBoneWeights->w1 * 65535.0);
      v102[2] = (unsigned int)(float)(VertexBoneWeights->w2 * 65535.0);
      w3 = VertexBoneWeights->w3;
      ++VertexBoneWeights;
      v102[3] = (unsigned int)(float)(w3 * 65535.0);
    }
    while ( v101 < *p_numVertices );
  }
  v104 = streams.numEntries;
  if ( streams.numAlloced >= streams.numEntries + 1 )
  {
    v105 = streams.dataPtr;
  }
  else
  {
    v160 = 4 * (streams.numEntries + 1) / 3 + 3;
    v105 = (_rpGeometryStreamBuilder *)malloc(32 * v160);
    v106 = streams.dataPtr;
    if ( streams.dataPtr )
    {
      qmemcpy(v105, streams.dataPtr, 32 * v104);
      free(v106);
      v104 = streams.numEntries;
    }
    streams.dataPtr = v105;
    streams.numAlloced = v160;
  }
  v156 = &v105[v104];
  *(_QWORD *)&v156->type = 0LL;
  *(_QWORD *)&v156->desc.count = 0LL;
  v156 = (_rpGeometryStreamBuilder *)((char *)v156 + 16);
  *(_QWORD *)&v156->type = 0LL;
  *(_QWORD *)&v156->desc.count = 0LL;
  streams.numEntries = v104 + 1;
  v105[v104].type = VAT_BoneWeight;
  streams.dataPtr[v104].desc.count = 4;
  v157 = &streams.dataPtr[v104];
  v157->desc.normalized = 1;
  v157->desc.format = VAF_UShort;
  v121 = &streams.dataPtr[v104];
  v121->buffer = v100;
  v121->desc.stride = 8;
LABEL_126:
  v121->ownsBuffer = 1;
  VertexBoneIndices = j_RpSkinGetVertexBoneIndices(v84);
  v123 = (char *)malloc(4 * *p_numVertices);
  if ( *p_numVertices >= 1 )
  {
    v124 = 0;
    do
    {
      v125 = &v123[4 * v124];
      *(_WORD *)v125 = VertexBoneIndices[v124];
      v126 = &VertexBoneIndices[v124++];
      v125[2] = *((_WORD *)v126 + 1);
      v125[3] = *((_BYTE *)v126 + 3);
    }
    while ( v124 < *p_numVertices );
  }
  v127 = streams.numEntries;
  if ( streams.numAlloced >= streams.numEntries + 1 )
  {
    v129 = streams.dataPtr;
  }
  else
  {
    v128 = 4 * (streams.numEntries + 1) / 3 + 3;
    v129 = (_rpGeometryStreamBuilder *)malloc(32 * v128);
    v130 = streams.dataPtr;
    if ( streams.dataPtr )
    {
      qmemcpy(v129, streams.dataPtr, 32 * v127);
      free(v130);
      v127 = streams.numEntries;
    }
    streams.dataPtr = v129;
    streams.numAlloced = v128;
  }
  v131 = &v129[v127];
  *(_QWORD *)&v131->type = 0LL;
  *(_QWORD *)&v131->desc.count = 0LL;
  v131 = (_rpGeometryStreamBuilder *)((char *)v131 + 16);
  *(_QWORD *)&v131->type = 0LL;
  *(_QWORD *)&v131->desc.count = 0LL;
  streams.numEntries = v127 + 1;
  v129[v127].type = VAT_BoneIndices;
  streams.dataPtr[v127].desc.count = 4;
  v132 = &streams.dataPtr[v127];
  v132->desc.normalized = 0;
  v132->desc.format = VAF_UByte;
  v133 = &streams.dataPtr[v127];
  v133->buffer = v123;
  v133->desc.stride = 4;
  v133->ownsBuffer = 1;
LABEL_135:
  v134 = streams.numEntries;
  if ( streams.numEntries )
  {
    v135 = 0;
    v136 = 0;
    p_offset = &streams.dataPtr->desc.offset;
    do
    {
      v138 = *(p_offset - 1);
      ++v135;
      *p_offset = v136;
      p_offset += 8;
      v136 += v138;
    }
    while ( v135 < v134 );
  }
  else
  {
    v136 = 0;
  }
  v139 = geometry->numVertices;
  v140 = (char *)malloc(v139 * v136);
  v141 = 0;
  v158 = v140;
  if ( v134 )
  {
    v142 = 0;
    v143 = streams.dataPtr;
    if ( v139 >= 1 )
      goto LABEL_144;
    while ( 1 )
    {
      v149 = &v143[v142];
      if ( v149->ownsBuffer )
      {
        free(v149->buffer);
        v143 = streams.dataPtr;
        v150 = &streams.dataPtr[v142];
        v150->ownsBuffer = 0;
        v150->buffer = 0;
      }
      ++v142;
      v141 = streams.numEntries;
      if ( v142 >= streams.numEntries )
        break;
      if ( geometry->numVertices >= 1 )
      {
LABEL_144:
        v144 = &v143[v142];
        v145 = 0;
        stride = v144->desc.stride;
        buffer = (char *)v144->buffer;
        v148 = &v158[v144->desc.offset];
        do
        {
          qmemcpy(v148, buffer, stride);
          v143 = streams.dataPtr;
          v148 += v136;
          ++v145;
          stride = streams.dataPtr[v142].desc.stride;
          buffer += stride;
        }
        while ( v145 < geometry->numVertices );
      }
    }
    if ( streams.numEntries )
    {
      v151 = 0;
      p_stride = &streams.dataPtr->desc.stride;
      do
      {
        ++v151;
        *p_stride = v136;
        p_stride += 8;
      }
      while ( v151 < v141 );
    }
    else
    {
      v141 = 0;
    }
  }
  ints[0] = v141;
  RwStreamWriteInt32(stream, ints, 4u);
  if ( streams.numEntries )
  {
    v153 = 0;
    v154 = 0;
    while ( _rpGeometryStreamBuilder::WriteStreamInfo(&streams.dataPtr[v153], stream) )
    {
      ++v154;
      ++v153;
      if ( v154 >= streams.numEntries )
        goto LABEL_158;
    }
    return 0;
  }
LABEL_158:
  if ( !RwStreamWrite(stream, v158, geometry->numVertices * v136) )
    return 0;
  free(v158);
  return stream;
}
// 21FAAA: conditional instruction was optimized away because r4.4>=1
// 220114: variable 'v2' is possibly undefined
// 21F9A8: using guessed type RwInt32 ints[8];

//----- (00220710) --------------------------------------------------------
GLenum __fastcall VertexAttrFormatToGL(RQVertexAttributeFormat f)
{
  if ( (unsigned int)f <= VAF_UShort )
    return dword_220720[f];
  else
    return 0;
}
// 220720: using guessed type int dword_220720[];

//----- (00220734) --------------------------------------------------------
RpGeometry_0 *__fastcall _rpGeometryNativeRead(RwStream_0 *stream, RpGeometry_0 *geometry)
{
  GLuint v2; // r10
  RwUInt32 flags; // r0
  RpGeometry_0 *v4; // r6
  size_t v5; // r9
  unsigned int v6; // r0
  _DWORD *v7; // r11
  int v8; // r4
  RwInt32 v9; // r4
  RwInt32 v10; // r11
  GLint v11; // r8
  RwInt32 v12; // r6
  bool v13; // r11
  GLenum v14; // r2
  GLenum v15; // r3
  int v16; // r4
  void *v17; // r0
  void *v18; // r1
  int v19; // r0
  void *v20; // r0
  int v21; // r4
  void *v22; // r0
  void *v23; // r1
  void *v24; // r0
  void *v25; // r0
  int v26; // r5
  unsigned int v27; // r6
  void *v28; // r5
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r1
  void *v32; // r0
  size_t v33; // r9
  char *v34; // r8
  char v35; // r1
  RwInt32 numVertices; // r3
  int v37; // r1
  unsigned int v38; // r2
  bool v39; // zf
  unsigned int v40; // r3
  char *v41; // r1
  char v42; // r5
  char v43; // r4
  void *v44; // r4
  char *v45; // r0
  unsigned int v46; // r1
  int v49; // [sp+8h] [bp-88h]
  void *v50; // [sp+Ch] [bp-84h]
  void *v51; // [sp+10h] [bp-80h]
  void *v52; // [sp+14h] [bp-7Ch]
  void *v53; // [sp+18h] [bp-78h]
  void *v54; // [sp+1Ch] [bp-74h]
  int v55; // [sp+20h] [bp-70h]
  void *v56; // [sp+24h] [bp-6Ch]
  void *v57; // [sp+28h] [bp-68h]
  void *v58; // [sp+2Ch] [bp-64h]
  void *v59; // [sp+30h] [bp-60h]
  RwInt32 v60; // [sp+34h] [bp-5Ch]
  void *p; // [sp+3Ch] [bp-54h]
  int v63; // [sp+40h] [bp-50h]
  unsigned int v64; // [sp+44h] [bp-4Ch]
  unsigned int v65; // [sp+48h] [bp-48h]
  unsigned int v66; // [sp+4Ch] [bp-44h]
  _DWORD *v67; // [sp+50h] [bp-40h]
  RwInt32 v68; // [sp+54h] [bp-3Ch]
  void *v69; // [sp+58h] [bp-38h]
  _DWORD *v70; // [sp+5Ch] [bp-34h]
  unsigned int v71; // [sp+60h] [bp-30h]
  int v72; // [sp+64h] [bp-2Ch]
  int v73; // [sp+68h] [bp-28h]
  RwInt32 attributeIndex; // [sp+6Ch] [bp-24h]
  RwInt32 ints[8]; // [sp+70h] [bp-20h] BYREF

  flags = geometry->flags;
  if ( (flags & 0x1000000) == 0 )
    return geometry;
  if ( geometry->numTexCoordSets >= 2 )
  {
    geometry->numTexCoordSets = 1;
    geometry->flags = flags & 0xFFFFFF7B | 4;
  }
  emu_ArraysReset();
  RwStreamReadInt32(stream, ints, 4u);
  v60 = ints[0];
  if ( ints[0] )
  {
    v69 = 0;
    v52 = 0;
    v51 = 0;
    v54 = 0;
    v53 = 0;
    v50 = 0;
    v59 = 0;
    v72 = 0;
    v64 = 0;
    v70 = 0;
    v57 = 0;
    v56 = 0;
    v66 = 0;
    v55 = -1;
    v58 = 0;
    v49 = -1;
    v5 = 0;
    p = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v65 = 0;
    do
    {
      v71 = v6;
      v67 = v7;
      v73 = v8;
      RwStreamReadInt32(stream, ints, 4u);
      attributeIndex = ints[0];
      RwStreamReadInt32(stream, ints, 4u);
      v9 = ints[0];
      RwStreamReadInt32(stream, ints, 4u);
      v10 = ints[0];
      RwStreamReadInt32(stream, ints, 4u);
      v11 = ints[0];
      RwStreamReadInt32(stream, ints, 4u);
      v12 = ints[0];
      RwStreamReadInt32(stream, ints, 4u);
      v13 = v10 != 0;
      v68 = ints[0];
      v14 = 5122;
      v15 = 5120;
      switch ( v9 )
      {
        case 0:
          emu_ArraysVertexAttrib(attributeIndex, v11, 0x1406u, v13, ints[0]);
          v16 = v72;
          v63 = v72 + 1;
          if ( v64 >= v72 + 1 )
          {
            v19 = 4;
            goto LABEL_37;
          }
          v64 = 4 * (v72 + 1) / 3u + 3;
          v17 = malloc(4 * v64);
          v18 = v17;
          v59 = v17;
          if ( v69 )
          {
            qmemcpy(v17, v51, 4 * v72);
            free(v51);
            v18 = v59;
          }
          v19 = 4;
          goto LABEL_16;
        case 1:
          goto LABEL_18;
        case 2:
          v15 = 5121;
LABEL_18:
          emu_ArraysVertexAttrib(attributeIndex, v11, v15, v13, ints[0]);
          v21 = v72;
          if ( v64 >= v72 + 1 )
          {
            v24 = v69;
            v2 = v12;
          }
          else
          {
            v64 = 4 * (v72 + 1) / 3u + 3;
            v22 = malloc(4 * v64);
            v23 = v22;
            v2 = v12;
            v59 = v22;
            if ( v69 )
            {
              qmemcpy(v22, v54, 4 * v72);
              v21 = v72;
              free(v54);
              v23 = v59;
            }
            v24 = v23;
            v54 = v23;
            v50 = v23;
            v51 = v23;
            v52 = v23;
            v53 = v23;
          }
          v27 = v71;
          v69 = v24;
          *((_DWORD *)v24 + v21) = 4;
          v8 = v73 + 1;
          if ( v65 >= v73 + 1 )
          {
            v29 = v70;
            v11 = 1;
          }
          else
          {
            v65 = 4 * v8 / 3u + 3;
            v28 = malloc(4 * v65);
            if ( v70 )
            {
              qmemcpy(v28, v57, 4 * v73);
              v27 = v71;
              free(v57);
            }
            v29 = v28;
            v11 = 1;
            v56 = v28;
            v57 = v28;
          }
          ++v72;
          v7 = v67;
          v26 = v73;
          goto LABEL_45;
        case 3:
          goto LABEL_23;
        case 4:
          v14 = 5123;
LABEL_23:
          emu_ArraysVertexAttrib(attributeIndex, v11, v14, v13, ints[0]);
          v16 = v72;
          v63 = v72 + 1;
          if ( v64 >= v72 + 1 )
          {
            v19 = 2;
            goto LABEL_37;
          }
          v64 = 4 * (v72 + 1) / 3u + 3;
          v25 = malloc(4 * v64);
          v18 = v25;
          v7 = v67;
          v2 = v12;
          v26 = v73;
          v59 = v25;
          if ( v69 )
          {
            qmemcpy(v25, v53, 4 * v72);
            v16 = v72;
            free(v53);
            v18 = v59;
          }
          v54 = v18;
          v19 = 2;
          v50 = v18;
          v51 = v18;
          v52 = v18;
          v53 = v18;
          break;
        default:
          emu_ArraysVertexAttrib(attributeIndex, v11, 0, v13, ints[0]);
          v16 = v72;
          v63 = v72 + 1;
          if ( v64 >= v72 + 1 )
          {
            v19 = 1;
LABEL_37:
            v18 = v69;
          }
          else
          {
            v64 = 4 * (v72 + 1) / 3u + 3;
            v20 = malloc(4 * v64);
            v18 = v20;
            v59 = v20;
            if ( v69 )
            {
              qmemcpy(v20, v52, 4 * v72);
              free(v52);
              v18 = v59;
            }
            v19 = 1;
LABEL_16:
            v54 = v18;
            v50 = v18;
            v51 = v18;
            v52 = v18;
            v53 = v18;
          }
          v7 = v67;
          v2 = v12;
          v26 = v73;
          break;
      }
      v69 = v18;
      *((_DWORD *)v18 + v16) = v19;
      v8 = v26 + 1;
      if ( v65 >= v26 + 1 )
      {
        v72 = v63;
        v29 = v70;
      }
      else
      {
        v65 = 4 * v8 / 3u + 3;
        v30 = malloc(4 * v65);
        v31 = v30;
        v57 = v30;
        if ( v70 )
        {
          qmemcpy(v30, v56, 4 * v26);
          v2 = v12;
          v26 = v73;
          free(v56);
          v31 = v57;
        }
        v29 = v31;
        v56 = v31;
        v72 = v63;
      }
      v27 = v71;
LABEL_45:
      v70 = v29;
      v29[v26] = v11;
      if ( v66 <= v27 )
      {
        v66 = (v5 + 4) / 3 + 3;
        v32 = malloc(4 * v66);
        p = v32;
        if ( v7 )
        {
          qmemcpy(v32, v58, v5);
          free(v58);
          v32 = p;
        }
        v7 = v32;
        v58 = v32;
      }
      v6 = v27 + 1;
      v7[v27] = v68;
      if ( attributeIndex == 3 )
      {
        v49 = v68;
      }
      else if ( attributeIndex == 6 )
      {
        v55 = v68;
      }
      v5 += 4;
    }
    while ( v60 != v6 );
  }
  else
  {
    v7 = 0;
    v49 = -1;
    p = 0;
    v56 = 0;
    v70 = 0;
    v59 = 0;
    v50 = 0;
    v69 = 0;
    v55 = -1;
  }
  v4 = geometry;
  v33 = geometry->numVertices * v2;
  v34 = (char *)malloc(v33);
  if ( RwStreamRead(stream, v34, v33) )
  {
    v35 = 0;
    numVertices = geometry->numVertices;
    if ( v55 != -1 )
      v35 = 1;
    v37 = (unsigned __int8)v35 & modelNightBoost;
    v38 = geometry->numVertices;
    if ( v37 )
      v38 = 0;
    v39 = numVertices == 0;
    if ( numVertices )
      v39 = v37 == 0;
    if ( !v39 )
    {
      v40 = 0;
      v41 = &v34[v55 + 1];
      do
      {
        ++v40;
        v42 = *v41;
        v43 = v41[1];
        *(v41 - 1) += 12;
        *v41 = v42 + 12;
        v41[1] = v43 + 16;
        v41 += v2;
        v38 = geometry->numVertices;
      }
      while ( v40 < v38 );
    }
    if ( v49 == -1 )
    {
      v44 = p;
    }
    else
    {
      v44 = p;
      if ( v55 != -1 && modelForceColorAlpha )
      {
        if ( v38 )
        {
          v45 = v34 + 3;
          v46 = 0;
          do
          {
            ++v46;
            v45[v55] = -1;
            v45[v49] = -1;
            v45 += v2;
            v38 = geometry->numVertices;
          }
          while ( v46 < v38 );
        }
        else
        {
          v38 = 0;
        }
      }
    }
    emu_ArraysVertex(v34, v33, v38, v2);
    geometry->vertexBuffer = emu_ArraysStore(0, 1u);
    if ( v7 )
      free(v44);
    if ( v70 )
      free(v56);
    if ( v69 )
      free(v59);
  }
  else
  {
    if ( v7 )
      free(p);
    if ( v70 )
      free(v56);
    if ( v69 )
      free(v50);
    return 0;
  }
  return v4;
}
// 220B7E: variable 'v2' is possibly undefined

//----- (00220C9C) --------------------------------------------------------
RwInt32 __fastcall _rpGeometryNativeSize(const RpGeometry_0 *geometry)
{
  float32x4_t v1; // q0
  RwUInt32 flags; // r0
  RwInt32 numVertices; // r1
  RwInt32 numTexCoordSets; // r2
  int v7; // r5
  RwInt32 v8; // r6
  RwReal *p_v; // r3
  int v10; // r6
  char v11; // r3
  RpSkin_0 *Skin; // r0
  RpSkin_0 *v13; // r0
  const RwMatrixWeights_0 *VertexBoneWeights; // r0
  unsigned int v15; // r4
  unsigned int v16; // r1
  int v17; // r2
  int8x16_t v18; // q8
  const RwMatrixWeights_0 *v19; // r3
  const float *p_w3; // r0
  unsigned int v21; // r1
  const float *v22; // r0
  float32x4_t v23; // q9
  unsigned __int32 *v24; // r0

  flags = geometry->flags;
  if ( (flags & 0x1000000) == 0 )
    return 0;
  numVertices = geometry->numVertices;
  numTexCoordSets = geometry->numTexCoordSets;
  v7 = 12 * numVertices;
  if ( numTexCoordSets < 1 )
  {
    v10 = 1;
  }
  else
  {
    if ( numVertices < 1 )
    {
LABEL_9:
      v11 = 2;
    }
    else
    {
      v8 = 0;
      p_v = &geometry->texCoords[0]->v;
      while ( *(p_v - 1) <= 63.998 )
      {
        ++v8;
        p_v += 2;
        if ( v8 >= numVertices )
          goto LABEL_9;
      }
      v11 = 3;
    }
    v10 = 2;
    v7 += (numTexCoordSets << v11) * numVertices;
  }
  if ( (flags & 0x10) != 0 )
  {
    v7 += 4 * numVertices;
    ++v10;
  }
  if ( (flags & 8) != 0 )
  {
    v7 += 4 * numVertices;
    ++v10;
  }
  Skin = j_RpSkinGeometryGetSkin((RpGeometry_0 *)geometry);
  if ( Skin )
  {
    v10 += 2;
    if ( Skin->vertexMaps.maxWeights == 4 )
    {
      v13 = j_RpSkinGeometryGetSkin((RpGeometry_0 *)geometry);
      VertexBoneWeights = j_RpSkinGetVertexBoneWeights(v13);
      v15 = geometry->numVertices;
      if ( v15 )
      {
        v1.n128_u32[0] = 0;
        if ( v15 >= 4 )
        {
          v17 = v15 & 3;
          v16 = v15;
          if ( (v15 & 3) == 0 )
            v17 = 4;
          if ( v15 != v17 )
          {
            v18 = 0uLL;
            v19 = &VertexBoneWeights[v15 - v17];
            p_w3 = &VertexBoneWeights->w3;
            v21 = v15;
            do
            {
              v23.n128_u64[0] = (unsigned __int64)vld4_f32(p_w3);
              v22 = p_w3 + 8;
              v21 -= 4;
              v23.n128_u64[1] = (unsigned __int64)vld4_f32(v22);
              p_w3 = v22 + 8;
              v18 = vmaxq_f32(v23, v18);
            }
            while ( v17 != v21 );
            v16 = v17;
            v1 = vmaxq_f32(v18, vextq_s8(v18, v18, 8u));
            if ( vmovn_s32(vcgtq_f32(v1, vdupq_lane_s32((int32x2_t)v1.n128_u64[0], 1))).n64_u16[0] << 31 )
              v1.n128_u32[1] = v1.n128_u32[0];
            VertexBoneWeights = v19;
            v1.n128_u32[0] = v1.n128_u32[1];
          }
        }
        else
        {
          v16 = v15;
        }
        v24 = (unsigned __int32 *)&VertexBoneWeights->w3;
        do
        {
          v1.n128_u32[2] = *v24;
          v24 += 4;
          --v16;
          v1.n128_u64[0] = vmax_f32(*(float32x2_t *)&v1.n128_i8[8], (float32x2_t)v1.n128_u64[0]).n64_u64[0];
        }
        while ( v16 );
        if ( v1.n128_f32[0] >= 0.07 )
        {
          v7 += 12 * v15;
          return v7 + 24 * v10 + 4;
        }
      }
      else
      {
        v15 = 0;
      }
    }
    else
    {
      v15 = geometry->numVertices;
    }
    v7 += 8 * v15;
  }
  return v7 + 24 * v10 + 4;
}
// 220DB0: variable 'v1' is possibly undefined

//----- (00220DF0) --------------------------------------------------------
RwStream_0 *__fastcall _rpWorldSectorNativeWrite(RwStream_0 *stream, const RpWorldSector_0 *sector)
{
  RpWorldSectorGetWorld(sector);
  return stream;
}

//----- (00220E00) --------------------------------------------------------
RpWorldSector_0 *__fastcall _rpWorldSectorNativeRead(RwStream_0 *stream, RpWorldSector_0 *sector)
{
  return sector;
}

//----- (00220E04) --------------------------------------------------------
RwInt32 __fastcall _rpWorldSectorNativeSize(const RpWorldSector_0 *sector)
{
  RpWorldSectorGetWorld(sector);
  return 0;
}

//----- (00220E10) --------------------------------------------------------
void __fastcall OSArray<_rpGeometryStreamBuilder>::~OSArray(OSArray<_rpGeometryStreamBuilder> *this)
{
  _rpGeometryStreamBuilder *dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (00220E2A) --------------------------------------------------------
bool __fastcall _rpGeometryStreamBuilder::WriteStreamInfo(const _rpGeometryStreamBuilder *this, RwStream_0 *stream)
{
  bool result; // r0
  RwInt32 ints[3]; // [sp+4h] [bp-Ch] BYREF

  ints[0] = this->type;
  result = 0;
  if ( RwStreamWriteInt32(stream, ints, 4u) )
  {
    ints[0] = this->desc.format;
    if ( RwStreamWriteInt32(stream, ints, 4u) )
    {
      ints[0] = this->desc.normalized;
      if ( RwStreamWriteInt32(stream, ints, 4u) )
      {
        ints[0] = this->desc.count;
        if ( RwStreamWriteInt32(stream, ints, 4u) )
        {
          ints[0] = this->desc.stride;
          if ( RwStreamWriteInt32(stream, ints, 4u) )
          {
            ints[0] = this->desc.offset;
            if ( RwStreamWriteInt32(stream, ints, 4u) )
              return 1;
          }
        }
      }
    }
  }
  return result;
}

//----- (00220EA4) --------------------------------------------------------
RxNodeDefinition_0 *RxNodeDefinitionGetOpenGLAtomicAllInOne()
{
  return &RxNodeDefinitionGetOpenGLAtomicAllInOne(void)::nodeOpenGLAtomicAllInOneCSL;
}

//----- (00220EB0) --------------------------------------------------------
RwBool __fastcall _rxOpenGLDefaultAtomicAllInOneNode(RxPipelineNode_0 *self, const RxPipelineNodeParam_0 *params)
{
  RwFrame_0 **dataParam; // r9
  int v4; // r10
  RpMeshHeader_0 *v5; // r6
  int v6; // r11
  RwResEntry_0 **v7; // r4
  RwResEntry_0 *v8; // r8
  const RwBool *privateData; // r5
  int (__fastcall *v10)(RwFrame_0 **, RwResEntry_0 *, _DWORD, const RwBool, const RwBool); // r4
  char *v11; // r0
  RwFrame_0 **v12; // r1
  RwBool result; // r0
  void (__fastcall *v14)(RwFrame_0 **); // r1
  RwMatrix *LTM; // r0

  dataParam = (RwFrame_0 **)params->dataParam;
  v4 = *((_DWORD *)params->dataParam + 6);
  if ( *(int *)(v4 + 20) < 1 )
    return 1;
  v5 = *(RpMeshHeader_0 **)(v4 + 88);
  if ( !v5->numMeshes )
    return 1;
  v6 = *(_DWORD *)(v4 + 24);
  v7 = (RwResEntry_0 **)(dataParam + 5);
  if ( v6 == 1 )
    v7 = (RwResEntry_0 **)(v4 + 92);
  v8 = *v7;
  if ( *v7 )
  {
    if ( LOWORD(v8[1].link.next) == v5->serialNum )
    {
      privateData = (const RwBool *)self->privateData;
      v10 = (int (__fastcall *)(RwFrame_0 **, RwResEntry_0 *, _DWORD, const RwBool, const RwBool))privateData[2];
      if ( v10 && !v10(dataParam, v8, *(_DWORD *)(v4 + 88), *privateData, privateData[1]) )
      {
        RwResourcesFreeResEntry(v8);
        return 0;
      }
      if ( v8->link.next )
      {
        v8->link.prev->next = v8->link.next;
        v8->link.next->prev = v8->link.prev;
        v8->link.next = **(RwLLLink ***)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
        v11 = (char *)RwEngineInstance + resourcesModule.globalsOffset;
        v8->link.prev = *(RwLLLink **)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
        *(_DWORD *)(**((_DWORD **)v11 + 9) + 4) = v8;
        **((_DWORD **)v11 + 9) = v8;
      }
      goto LABEL_16;
    }
    RwResourcesFreeResEntry(*v7);
  }
  privateData = (const RwBool *)self->privateData;
  v12 = dataParam;
  if ( v6 == 1 )
    v12 = (RwFrame_0 **)v4;
  v8 = _rxOpenGLInstance(dataParam, v12, v7, v5, *privateData, *((RxOpenGLAllInOneInstanceCallBack *)privateData + 1));
  result = 0;
  if ( v8 )
  {
    *(_WORD *)(v4 + 12) = 0;
LABEL_16:
    if ( privateData[4] )
    {
      v14 = (void (__fastcall *)(RwFrame_0 **))privateData[3];
      if ( v14 )
        v14(dataParam);
      LTM = RwFrameGetLTM(dataParam[1]);
      if ( (LTM->flags & 0x20000) != 0 )
      {
        (*((void (__fastcall **)(RwResEntry_0 *, RwFrame_0 **, int, _DWORD))privateData + 4))(
          v8,
          dataParam,
          1,
          *(_DWORD *)(v4 + 8));
      }
      else
      {
        emu_glPushAndLoadMatrix(&LTM->right.x);
        (*((void (__fastcall **)(RwResEntry_0 *, RwFrame_0 **, int, _DWORD))privateData + 4))(
          v8,
          dataParam,
          1,
          *(_DWORD *)(v4 + 8));
        emu_glPopMatrix();
      }
    }
    if ( rwOpenGLLightingEnabled )
    {
      emu_glDisable(0xB50u);
      rwOpenGLLightingEnabled = 0;
    }
    return 1;
  }
  return result;
}

//----- (00221014) --------------------------------------------------------
RwBool __fastcall openglAtomicAllInOnePipelineInit(RxPipelineNode_0 *node)
{
  RwBool v2; // r1
  RwBool result; // r0
  _DWORD *privateData; // r2

  v2 = _rxOpenGLAllInOnePipelineInit(node);
  result = 0;
  if ( v2 )
  {
    privateData = node->privateData;
    privateData[1] = openglDefaultAtomicInstanceCB;
    *privateData = 0;
    privateData[2] = openglDefaultAtomicReinstanceCB;
    privateData[3] = _rxOpenGLDefaultAllInOneAtomicLightingCB;
    privateData[4] = _rxOpenGLDefaultAllInOneRenderCB;
    return 1;
  }
  return result;
}

//----- (00221060) --------------------------------------------------------
void __fastcall _rxOpenGLAllInOneAtomicInstanceVertexArray(
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RpAtomic_0 *atomic,
        const RpGeometry_0 *geometry,
        RpGeometryFlag_0 geomFlags,
        RwInt32 numTexCoords,
        const RwBool reinstance,
        RwUInt8 *baseVertexMem,
        RwRGBA_0 *vertexColor,
        RwRGBA_0 *secondVertexColor)
{
  int startMorphTarget; // r5
  int endMorphTarget; // r4
  RwUInt32 v11; // r10
  RwUInt32 numVertices; // r1
  RwV3d_0 *v13; // r4
  RwUInt8 *v14; // r5
  __int64 v15; // d16
  RwReal z; // r6
  __int32 v17; // r8
  RwUInt32 v18; // r1
  RwV3d_0 *v19; // r4
  RwUInt8 *v20; // r5
  __int64 v21; // d16
  RwReal v22; // r6
  float recipTime; // s0
  float position; // s2
  RpMorphTarget_0 *morphTarget; // r1
  float v26; // s0
  RpMorphTarget_0 *v27; // r11
  RwUInt32 v28; // r9
  float *p_x; // r1
  float *v30; // r6
  float *v31; // r4
  float v32; // s2
  float v33; // s4
  float *v34; // r5
  float *v35; // r11
  float v36; // s2
  float v37; // s4
  float v38; // s2
  float v39; // s4
  int v40; // r11
  _BOOL4 v41; // r1
  RwRGBA_0 *preLitLum; // r1
  RwUInt32 minVertexIdx; // r4
  RwUInt32 v44; // r5
  bool v45; // zf
  RwUInt8 *v46; // r6
  RwRGBA_0 *v47; // r3
  unsigned __int8 i; // r1
  float v49; // t1
  RwUInt8 v50; // r8
  RwUInt8 alpha; // r10
  int v52; // r1
  RwUInt16 lockedSinceLastInst; // r1
  int v54; // r4
  int v55; // r5
  int v56; // r10
  RwUInt32 v57; // r1
  RwUInt8 *v58; // r6
  RwTexCoords_0 *v59; // r3
  __int64 v60; // kr00_8
  float v; // s2

  startMorphTarget = (unsigned __int16)atomic->interpolator.startMorphTarget;
  endMorphTarget = (unsigned __int16)atomic->interpolator.endMorphTarget;
  v11 = (__int16)startMorphTarget;
  if ( startMorphTarget == endMorphTarget )
  {
    if ( !reinstance || (geometry->lockedSinceLastInst & 2) != 0 )
    {
      numVertices = instanceData->numVertices;
      if ( numVertices )
      {
        v13 = &geometry->morphTarget[(__int16)startMorphTarget].verts[instanceData->minVertexIdx];
        v14 = baseVertexMem;
        do
        {
          v15 = *(_QWORD *)&v13->x;
          --numVertices;
          z = v13->z;
          ++v13;
          *((RwReal *)v14 + 2) = z;
          *(_QWORD *)v14 = v15;
          v14 += instanceData->vertexStride;
        }
        while ( numVertices );
      }
    }
    v17 = geomFlags & 0x10;
    if ( (geomFlags & 0x10) != 0 )
    {
      if ( !reinstance || (geometry->lockedSinceLastInst & 4) != 0 )
      {
        v18 = instanceData->numVertices;
        if ( v18 )
        {
          v19 = &geometry->morphTarget[v11].normals[instanceData->minVertexIdx];
          v20 = baseVertexMem + 12;
          do
          {
            v21 = *(_QWORD *)&v19->x;
            --v18;
            v22 = v19->z;
            ++v19;
            *((RwReal *)v20 + 2) = v22;
            *(_QWORD *)v20 = v21;
            v20 += instanceData->vertexStride;
          }
          while ( v18 );
        }
      }
      goto LABEL_22;
    }
LABEL_18:
    v17 = 0;
    goto LABEL_22;
  }
  recipTime = atomic->interpolator.recipTime;
  position = atomic->interpolator.position;
  morphTarget = geometry->morphTarget;
  v26 = recipTime * position;
  v11 = (RwUInt32)&morphTarget[(__int16)startMorphTarget];
  v27 = &morphTarget[(__int16)endMorphTarget];
  v28 = instanceData->numVertices;
  v17 = geomFlags & 0x10;
  p_x = &v27->verts[instanceData->minVertexIdx].x;
  v30 = (float *)(*(_DWORD *)(v11 + 20) + 12 * instanceData->minVertexIdx);
  if ( (geomFlags & 0x10) == 0 )
  {
    if ( v28 )
    {
      v31 = (float *)baseVertexMem;
      do
      {
        --v28;
        *v31 = *v30 + (float)(v26 * (float)(*p_x - *v30));
        v31[1] = v30[1] + (float)(v26 * (float)(p_x[1] - v30[1]));
        v32 = v30[2];
        v30 += 3;
        v33 = p_x[2];
        p_x += 3;
        v31[2] = v32 + (float)(v26 * (float)(v33 - v32));
        v31 = (float *)((char *)v31 + instanceData->vertexStride);
      }
      while ( v28 );
    }
    goto LABEL_18;
  }
  if ( v28 )
  {
    v11 = *(_DWORD *)(v11 + 24) + 12 * instanceData->minVertexIdx;
    v34 = (float *)baseVertexMem;
    v35 = &v27->normals[instanceData->minVertexIdx].x;
    do
    {
      --v28;
      *v34 = *v30 + (float)(v26 * (float)(*p_x - *v30));
      v34[1] = v30[1] + (float)(v26 * (float)(p_x[1] - v30[1]));
      v36 = v30[2];
      v30 += 3;
      v37 = p_x[2];
      p_x += 3;
      v34[2] = v36 + (float)(v26 * (float)(v37 - v36));
      v34[3] = *(float *)v11 + (float)(v26 * (float)(*v35 - *(float *)v11));
      v34[4] = *(float *)(v11 + 4) + (float)(v26 * (float)(v35[1] - *(float *)(v11 + 4)));
      v38 = *(float *)(v11 + 8);
      v11 += 12;
      v39 = v35[2];
      v35 += 3;
      v34[5] = v38 + (float)(v26 * (float)(v39 - v38));
      v34 = (float *)((char *)v34 + instanceData->vertexStride);
    }
    while ( v28 );
  }
LABEL_22:
  v40 = 24;
  if ( !v17 )
    v40 = 12;
  if ( (geomFlags & 8) != 0 )
  {
    if ( !reinstance || (geometry->lockedSinceLastInst & 8) != 0 )
    {
      preLitLum = vertexColor;
      if ( !vertexColor )
        preLitLum = geometry->preLitLum;
      minVertexIdx = instanceData->minVertexIdx;
      v44 = instanceData->numVertices;
      v45 = secondVertexColor == 0;
      v46 = &baseVertexMem[v40];
      v47 = &preLitLum[minVertexIdx];
      if ( secondVertexColor )
      {
        v11 = (RwUInt32)&secondVertexColor[minVertexIdx];
        v45 = v11 == 0;
      }
      if ( v45 )
      {
        for ( i = -1; v44; v46 += instanceData->vertexStride )
        {
          --v44;
          *(RwRGBA_0 *)v46 = *v47;
          alpha = v47->_anon_0._anon_0.alpha;
          ++v47;
          i &= alpha;
        }
      }
      else
      {
        for ( i = -1; v44; v46 += instanceData->vertexStride )
        {
          --v44;
          *(RwRGBA_0 *)v46 = *v47;
          v49 = *(float *)v11;
          v11 += 4;
          *((float *)v46 + 1) = v49;
          v50 = v47->_anon_0._anon_0.alpha;
          ++v47;
          i &= v50;
        }
      }
      v41 = i != 255;
    }
    else
    {
      v41 = 0;
    }
    instanceData->vertexAlpha = v41;
    v52 = 8;
    if ( !secondVertexColor )
      v52 = 4;
    v40 += v52;
    if ( !numTexCoords )
      return;
  }
  else
  {
    instanceData->vertexAlpha = 0;
    if ( !numTexCoords )
      return;
  }
  lockedSinceLastInst = geometry->lockedSinceLastInst;
  v54 = lockedSinceLastInst & 0xFF0;
  if ( (lockedSinceLastInst & 0xFF0) != 0 )
    v54 = 1;
  if ( (reinstance == 0) | v54 && numTexCoords >= 1 )
  {
    v55 = 0;
    v56 = RwHackNoCompressedTexCoords;
    if ( reinstance )
      goto LABEL_51;
LABEL_52:
    v57 = instanceData->numVertices;
    v58 = &baseVertexMem[v40];
    v59 = &geometry->texCoords[v55][instanceData->minVertexIdx];
    if ( v56 )
    {
      for ( ; v57; v58 += instanceData->vertexStride )
      {
        v60 = (__int64)*v59++;
        *(_QWORD *)v58 = v60;
        --v57;
      }
    }
    else
    {
      for ( ; v57; v58 += instanceData->vertexStride )
      {
        --v57;
        *(_WORD *)v58 = (int)(float)(v59->u * 512.0);
        v = v59->v;
        ++v59;
        *((_WORD *)v58 + 1) = (int)(float)(v * 512.0);
      }
    }
    while ( ++v55 != numTexCoords )
    {
      lockedSinceLastInst = geometry->lockedSinceLastInst;
      v40 += 8;
      if ( !reinstance )
        goto LABEL_52;
LABEL_51:
      if ( (lockedSinceLastInst & (unsigned __int16)(16 << v55)) != 0 )
        goto LABEL_52;
    }
  }
}

//----- (00221400) --------------------------------------------------------
void __fastcall _rxOpenGLDefaultAllInOneAtomicLightingCB(void *object)
{
  _DWORD *i; // r11
  int v3; // r5
  _DWORD *v4; // r5
  _DWORD *j; // r8
  _DWORD *v6; // t1
  int v7; // r0
  int v8; // r2
  int v9; // r1
  bool v10; // zf
  RwMatrix *LTM; // r6
  const RwSphere_0 *WorldBoundingSphere; // r1
  const RpLight_0 *v13; // r0
  float32x2_t v14; // d16
  float v15; // s2
  unsigned __int64 v16; // d2
  RwBool v17; // r0
  RwBool v18; // r0
  RwBool v19; // [sp+0h] [bp-20h]

  if ( (*(_BYTE *)(*((_DWORD *)object + 6) + 8) & 0x20) != 0 && *((_DWORD *)RwEngineInstance + 1) )
  {
    v19 = _rwOpenGLLightsGlobalLightsEnable(rpLIGHTLIGHTATOMICS);
    ++*((_WORD *)RwEngineInstance + 5);
    for ( i = (_DWORD *)*((_DWORD *)object + 25); i != (_DWORD *)((char *)object + 100); i = (_DWORD *)*i )
    {
      v3 = i[2];
      v6 = *(_DWORD **)(v3 + 72);
      v4 = (_DWORD *)(v3 + 72);
      for ( j = v6; j != v4; v19 |= v17 )
      {
        while ( 1 )
        {
          v7 = j[2];
          if ( v7 )
          {
            v8 = *(unsigned __int16 *)(v7 + 60);
            v9 = *((unsigned __int16 *)RwEngineInstance + 5);
            v10 = v8 == v9;
            if ( v8 != v9 )
              v10 = *(unsigned __int8 *)(v7 + 2) << 31 == 0;
            if ( !v10 )
            {
              *(_WORD *)(v7 + 60) = v9;
              LTM = RwFrameGetLTM(*(RwFrame_0 **)(j[2] + 4));
              WorldBoundingSphere = RpAtomicGetWorldBoundingSphere((RpAtomic_0 *)object);
              v13 = (const RpLight_0 *)j[2];
              v14.n64_u64[0] = vsub_f32(*(float32x2_t *)&WorldBoundingSphere->center.y, *(float32x2_t *)&LTM->pos.y).n64_u64[0];
              v15 = WorldBoundingSphere->radius + v13->radius;
              v16 = vmul_f32(v14, v14).n64_u64[0];
              if ( (float)((float)((float)((float)(WorldBoundingSphere->center.x - LTM->pos.x)
                                         * (float)(WorldBoundingSphere->center.x - LTM->pos.x))
                                 + *(float *)&v16)
                         + *((float *)&v16 + 1)) < (float)(v15 * v15) )
                break;
            }
          }
          j = (_DWORD *)*j;
          if ( j == v4 )
            goto LABEL_13;
        }
        v17 = _rwOpenGLLightsLocalLightEnable(v13);
        j = (_DWORD *)*j;
      }
LABEL_13:
      ;
    }
    v18 = v19;
  }
  else
  {
    v18 = 0;
  }
  sub_18AA54(v18);
}

//----- (00221510) --------------------------------------------------------
RwBool __fastcall openglDefaultAtomicInstanceCB(
        void *object,
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RwBool instanceDLandVA,
        const RwBool reinstance)
{
  int v6; // r5
  signed int v8; // r9
  RwInt32 v9; // r11
  u_native emuArrayRef; // r0
  size_t vertexDataSize; // r0
  int v12; // r1
  char v13; // r3
  RwUInt32 numVertices; // r2
  RwUInt32 v15; // r1
  RwUInt8 *v16; // r10
  RwUInt16 *indexData; // r0
  GLsizei offset; // r5
  GLenum v19; // r2

  v6 = *((_DWORD *)object + 6);
  v8 = *(_DWORD *)(v6 + 8);
  v9 = *(_DWORD *)(v6 + 28);
  instanceData->vertexDesc = v8;
  if ( !reinstance || (*(_WORD *)(v6 + 12) & 0xFFF) != 0 )
  {
    if ( !(*(unsigned __int8 *)(v6 + 11) << 31) )
    {
      if ( reinstance )
      {
        emuArrayRef = instanceData->emuArrayRef;
        if ( emuArrayRef )
          emu_ArraysDelete(emuArrayRef);
      }
      if ( reinstance )
      {
        vertexDataSize = instanceData->vertexDataSize;
      }
      else
      {
        v12 = 24;
        v13 = 3;
        if ( (v8 & 0x10) == 0 )
          v12 = 12;
        numVertices = instanceData->numVertices;
        if ( (v8 & 8) != 0 )
          v12 += 4;
        if ( !RwHackNoCompressedTexCoords )
          v13 = 2;
        v15 = v12 + (v9 << v13);
        instanceData->vertexStride = v15;
        vertexDataSize = v15 * numVertices;
        instanceData->vertexDataSize = v15 * numVertices;
      }
      v16 = (RwUInt8 *)malloc(vertexDataSize);
      _rxOpenGLAllInOneAtomicInstanceVertexArray(
        instanceData,
        (const RpAtomic_0 *)object,
        (const RpGeometry_0 *)v6,
        (RpGeometryFlag_0)v8,
        v9,
        reinstance,
        v16,
        0,
        0);
      emu_ArraysReset();
      indexData = instanceData->indexData;
      if ( indexData )
        emu_ArraysIndices(indexData, 0x1403u, instanceData->numIndices);
      emu_ArraysVertex(v16, instanceData->vertexDataSize, instanceData->numVertices, instanceData->vertexStride);
      emu_ArraysVertexAttrib(0, 3, 0x1406u, 0, 0);
      offset = 12;
      if ( (v8 & 0x10) != 0 )
      {
        emu_ArraysVertexAttrib(2u, 3, 0x1406u, 0, 12);
        offset = 24;
        if ( (v8 & 8) == 0 )
        {
LABEL_21:
          if ( v9 >= 1 )
          {
LABEL_22:
            if ( RwHackNoCompressedTexCoords )
              v19 = 5126;
            else
              v19 = 5123;
            emu_ArraysVertexAttrib(1u, 2, v19, 0, offset);
          }
LABEL_26:
          instanceData->emuArrayRef = emu_ArraysStore(reinstance != 0, 1u);
          return 1;
        }
      }
      else if ( (v8 & 8) == 0 )
      {
        goto LABEL_21;
      }
      emu_ArraysVertexAttrib(3u, 4, 0x1401u, 1u, offset);
      offset += 4;
      if ( v9 >= 1 )
        goto LABEL_22;
      goto LABEL_26;
    }
    instanceData->vertexBufferRef = *(_DWORD *)(v6 + 84);
  }
  return 1;
}

//----- (0022167C) --------------------------------------------------------
RwBool __fastcall openglDefaultAtomicReinstanceCB(
        void *object,
        RwResEntry_0 *resEntry,
        const RpMeshHeader_0 *meshHeader,
        const RwBool instanceDLandVA,
        int (__fastcall *a5)(void *, RxOpenGLMeshInstanceData_0 *, const RwBool, int))
{
  int v5; // r5
  RwBool v6; // r1
  RwBool result; // r0

  v5 = *((_DWORD *)object + 6);
  if ( *(_WORD *)(v5 + 12) )
  {
    v6 = _rxOpenGLReinstance(
           object,
           meshHeader,
           (RxOpenGLMeshInstanceData_0 *)&resEntry[1].link.prev,
           instanceDLandVA,
           a5);
    result = 0;
    if ( !v6 )
      return result;
    *(_WORD *)(v5 + 12) = 0;
  }
  return 1;
}

//----- (002216A8) --------------------------------------------------------
RxNodeDefinition_0 *RxNodeDefinitionGetOpenGLWorldSectorAllInOne()
{
  return &RxNodeDefinitionGetOpenGLWorldSectorAllInOne(void)::nodeOpenGLWorldSectorAllInOneCSL;
}

//----- (002216B4) --------------------------------------------------------
RwBool __fastcall openglWorldSectorAllInOneNode(RxPipelineNode_0 *self, const RxPipelineNodeParam_0 *params)
{
  RpMeshHeader_0 *v2; // r6
  void *dataParam; // r4
  bool v5; // zf
  RwResEntry_0 *v6; // r8
  void *privateData; // r9
  char *v8; // r0
  void (__fastcall *v9)(void *); // r1
  void (__fastcall *v10)(RwResEntry_0 *, void *, int, _DWORD); // r6

  dataParam = params->dataParam;
  v5 = *((unsigned __int16 *)params->dataParam + 69) == 0;
  if ( *((_WORD *)params->dataParam + 69) )
  {
    v2 = (RpMeshHeader_0 *)*((_DWORD *)dataParam + 32);
    v5 = v2->numMeshes == 0;
  }
  if ( v5 )
    return 1;
  v6 = (RwResEntry_0 *)*((_DWORD *)dataParam + 13);
  if ( v6 )
  {
    if ( LOWORD(v6[1].link.next) == v2->serialNum )
    {
      privateData = self->privateData;
      if ( v6->link.next )
      {
        v6->link.prev->next = v6->link.next;
        v6->link.next->prev = v6->link.prev;
        v6->link.next = **(RwLLLink ***)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
        v8 = (char *)RwEngineInstance + resourcesModule.globalsOffset;
        v6->link.prev = *(RwLLLink **)((char *)RwEngineInstance + resourcesModule.globalsOffset + 36);
        *(_DWORD *)(**((_DWORD **)v8 + 9) + 4) = v6;
        **((_DWORD **)v8 + 9) = v6;
      }
      goto LABEL_10;
    }
    RwResourcesFreeResEntry(*((RwResEntry_0 **)dataParam + 13));
  }
  privateData = self->privateData;
  v6 = _rxOpenGLInstance(
         dataParam,
         dataParam,
         (RwResEntry_0 **)dataParam + 13,
         v2,
         *(_DWORD *)privateData,
         *((RxOpenGLAllInOneInstanceCallBack *)privateData + 1));
  if ( v6 )
  {
LABEL_10:
    v9 = (void (__fastcall *)(void *))*((_DWORD *)privateData + 3);
    if ( v9 )
      v9(dataParam);
    if ( rwOpenGLNormalizeEnabled )
    {
      emu_glDisable(0xBA1u);
      rwOpenGLNormalizeEnabled = 0;
    }
    v10 = (void (__fastcall *)(RwResEntry_0 *, void *, int, _DWORD))*((_DWORD *)privateData + 4);
    if ( v10 )
      v10(v6, dataParam, 255, *(_DWORD *)(*((_DWORD *)RwEngineInstance + 1) + 8));
    if ( rwOpenGLLightingEnabled )
    {
      emu_glDisable(0xB50u);
      rwOpenGLLightingEnabled = 0;
    }
    return 1;
  }
  return 0;
}
// 2216E0: variable 'v2' is possibly undefined

//----- (002217E4) --------------------------------------------------------
RwBool __fastcall openglWorldSectorAllInOnePipelineInit(RxPipelineNode_0 *node)
{
  RwBool v2; // r1
  RwBool result; // r0
  _DWORD *privateData; // r1

  v2 = _rxOpenGLAllInOnePipelineInit(node);
  result = 0;
  if ( v2 )
  {
    privateData = node->privateData;
    privateData[1] = openglDefaultWorldSectorInstanceCB;
    *privateData = 1;
    privateData[2] = 0;
    privateData[3] = openglDefaultWorldSectorLightingCB;
    result = 1;
    privateData[4] = _rxOpenGLDefaultAllInOneRenderCB;
  }
  return result;
}

//----- (00221824) --------------------------------------------------------
RwBool __fastcall openglDefaultWorldSectorInstanceCB(
        void *object,
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RwBool instanceDLandVA,
        const RwBool reinstance)
{
  RwUInt32 v6; // r9
  RwUInt32 offset; // r0
  int v8; // r10
  RwUInt32 numVertices; // r6
  RwUInt32 v10; // r1
  float *v11; // r12
  RwUInt32 v12; // r0
  float *v13; // r1
  __int64 v14; // d16
  int v15; // r2
  int v16; // r11
  RwUInt32 v17; // r0
  char *v18; // r1
  float *v19; // r2
  int v20; // r3
  unsigned int *v21; // lr
  RwUInt32 v22; // r5
  RwUInt32 v23; // r6
  RpMaterial_0 *material; // r1
  unsigned __int8 *v25; // r6
  unsigned __int8 i; // r2
  char v33; // r1
  int v34; // r1
  RwBool v35; // r2
  int k; // r1
  RwUInt32 v37; // r2
  float *v38; // r3
  __int64 *v39; // r6
  __int64 v40; // kr00_8
  RwUInt16 *indexData; // r0
  float *v42; // r5
  RwUInt8 color; // [sp+10h] [bp-28h]
  RwUInt32 j; // [sp+14h] [bp-24h]

  v6 = *(_DWORD *)(*((_DWORD *)RwEngineInstance + 1) + 8);
  instanceData->vertexDesc = v6;
  emu_ArraysReset();
  emu_ArraysVertexAttrib(0, 3, 0x1406u, 0, 0);
  offset = 12;
  instanceData->vertexStride = 12;
  v8 = (v6 >> 2) & 1;
  if ( (v6 & 0x80) != 0 )
    v8 = 2;
  if ( (v6 & 0x10) != 0 )
  {
    emu_ArraysVertexAttrib(2u, 3, 0x1406u, 0, 12);
    offset = instanceData->vertexStride + 12;
    instanceData->vertexStride = offset;
  }
  if ( (v6 & 8) != 0 )
  {
    emu_ArraysVertexAttrib(3u, 4, 0x1406u, 1u, offset);
    offset = instanceData->vertexStride + 4;
    instanceData->vertexStride = offset;
  }
  if ( v8 )
  {
    emu_ArraysVertexAttrib(1u, 2, 0x1406u, 0, offset);
    offset = instanceData->vertexStride;
  }
  numVertices = instanceData->numVertices;
  v10 = offset + 8 * v8;
  instanceData->vertexStride = v10;
  instanceData->vertexDataSize = numVertices * v10;
  v11 = (float *)malloc(numVertices * v10);
  if ( numVertices )
  {
    v12 = *((_DWORD *)object + 2) + 12 * instanceData->minVertexIdx;
    v13 = v11;
    do
    {
      v14 = *(_QWORD *)v12;
      --numVertices;
      v15 = *(_DWORD *)(v12 + 8);
      v12 += 12;
      *((_DWORD *)v13 + 2) = v15;
      *(_QWORD *)v13 = v14;
      v13 = (float *)((char *)v13 + instanceData->vertexStride);
    }
    while ( numVertices );
  }
  if ( (v6 & 0x10) != 0 )
  {
    v17 = instanceData->numVertices;
    if ( v17 )
    {
      v18 = (char *)(*((_DWORD *)object + 3) + 4 * instanceData->minVertexIdx);
      v19 = v11 + 3;
      do
      {
        --v17;
        *v19 = (float)*v18 * 0.0078125;
        v19[1] = (float)v18[1] * 0.0078125;
        v20 = v18[2];
        v18 += 4;
        v19[2] = (float)v20 * 0.0078125;
        v19 = (float *)((char *)v19 + instanceData->vertexStride);
      }
      while ( v17 );
    }
    v16 = 6;
  }
  else
  {
    v16 = 3;
  }
  if ( (v6 & 8) == 0 )
  {
    instanceData->vertexAlpha = 0;
    if ( !v8 )
      goto LABEL_40;
    goto LABEL_35;
  }
  v21 = (unsigned int *)&v11[v16];
  v22 = instanceData->numVertices;
  v23 = *((_DWORD *)object + 12) + 4 * instanceData->minVertexIdx;
  if ( (v6 & 0x40) == 0 || (material = instanceData->material, *(_DWORD *)&material->color == -1) )
  {
    for ( i = -1; v22; v21 = (unsigned int *)((char *)v21 + instanceData->vertexStride) )
    {
      --v22;
      *v21 = *(_DWORD *)v23;
      v33 = *(_BYTE *)(v23 + 3);
      v23 += 4;
      i &= v33;
    }
  }
  else if ( v22 )
  {
    v25 = (unsigned __int8 *)(v23 + 1);
    i = -1;
    color = (RwUInt8)material->color;
    for ( j = 1 - v22; ; ++j )
    {
      _R5 = (v25[1] * (__int16)(material->color._anon_0._anon_0.blue + 1)) << 8;
      __asm { UXTB16.W        R5, R5 }
      *v21 = ((v25[2] * (__int16)(material->color._anon_0._anon_0.alpha + 1)) << 16) & 0xFF000000 | _R5 | ((__int16)(material->color._anon_0._anon_0.green + 1) * *v25) & 0xFF00 | (unsigned __int8)((unsigned __int16)((color + 1) * *(v25 - 1)) >> 8);
      i &= v25[2];
      if ( !j )
        break;
      v25 += 4;
      v21 = (unsigned int *)((char *)v21 + instanceData->vertexStride);
      color = material->color._anon_0._anon_0.red;
    }
  }
  else
  {
    i = -1;
  }
  v34 = i;
  v35 = 0;
  ++v16;
  if ( v34 != 255 )
    v35 = 1;
  instanceData->vertexAlpha = v35;
  if ( v8 )
  {
LABEL_35:
    for ( k = 0; k != v8; ++k )
    {
      v37 = instanceData->numVertices;
      if ( v37 )
      {
        v38 = &v11[v16];
        v39 = (__int64 *)(*((_DWORD *)object + k + 4) + 8 * instanceData->minVertexIdx);
        do
        {
          v40 = *v39++;
          *(_QWORD *)v38 = v40;
          --v37;
          v38 = (float *)((char *)v38 + instanceData->vertexStride);
        }
        while ( v37 );
      }
      v16 += 2;
    }
  }
LABEL_40:
  indexData = instanceData->indexData;
  if ( indexData )
  {
    v42 = v11;
    emu_ArraysIndices(indexData, 0x1403u, instanceData->numIndices);
    v11 = v42;
  }
  emu_ArraysVertex(v11, instanceData->vertexDataSize, instanceData->numVertices, instanceData->vertexStride);
  instanceData->emuArrayRef = emu_ArraysStore(0, 1u);
  return 1;
}

//----- (00221AD4) --------------------------------------------------------
void __fastcall openglDefaultWorldSectorLightingCB(void *object)
{
  RwBool v2; // r0
  RwBool v3; // r5
  char *v4; // r4
  char *i; // r6
  char *v6; // t1
  const RpLight_0 *v7; // r0

  if ( (*(_BYTE *)(*((_DWORD *)RwEngineInstance + 1) + 8) & 0x20) != 0 )
  {
    v3 = _rwOpenGLLightsGlobalLightsEnable(rpLIGHTLIGHTWORLD);
    ++*((_WORD *)RwEngineInstance + 5);
    v6 = (char *)*((_DWORD *)object + 18);
    v4 = (char *)object + 72;
    for ( i = v6; i != v4; i = *(char **)i )
    {
      v7 = (const RpLight_0 *)*((_DWORD *)i + 2);
      if ( v7 && (v7->object.object.flags & 2) != 0 )
        v3 |= _rwOpenGLLightsLocalLightEnable(v7);
    }
    v2 = v3;
  }
  else
  {
    v2 = 0;
  }
  sub_18AA54(v2);
}

//----- (00221B50) --------------------------------------------------------
int GetNextLightApplied()
{
  int result; // r0

  if ( !openglLightApplied[1] )
    return 1;
  if ( !openglLightApplied[2] )
    return 2;
  if ( !openglLightApplied[3] )
    return 3;
  if ( !openglLightApplied[4] )
    return 4;
  if ( !openglLightApplied[5] )
    return 5;
  if ( !openglLightApplied[6] )
    return 6;
  result = -1;
  if ( !openglLightApplied[7] )
    return 7;
  return result;
}

//----- (00221BDC) --------------------------------------------------------
void ClearLightApplied()
{
  *(_QWORD *)openglLightApplied = 0LL;
  *(_QWORD *)&openglLightApplied[2] = 0LL;
  *(_QWORD *)&openglLightApplied[4] = 0LL;
  *(_QWORD *)&openglLightApplied[6] = 0LL;
}

//----- (00221BF4) --------------------------------------------------------
bool _rpOpenGLLightPluginAttach()
{
  rpOpenGLLightOffset = RpLightRegisterPlugin(
                          16,
                          0x505u,
                          openglLightConstructor,
                          openglLightDestructor,
                          openglLightCopy);
  return rpOpenGLLightOffset >= 0;
}

//----- (00221C40) --------------------------------------------------------
void *__fastcall openglLightConstructor(void *object, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  _QWORD *v3; // r1

  if ( !object )
    return 0;
  v3 = (char *)object + rpOpenGLLightOffset;
  *v3 = 0x3F80000040A00000LL;
  v3[1] = 0x40A0000000000000LL;
  return object;
}

//----- (00221C78) --------------------------------------------------------
void *__fastcall openglLightCopy(void *dstObject, const void *srcObject, RwInt32 offsetInObject, RwInt32 sizeInObject)
{
  bool v4; // zf
  void *v5; // r2
  __int64 *v6; // r1
  __int64 v7; // d16
  __int64 v8; // d17
  _QWORD *v9; // r1

  v4 = dstObject == 0;
  v5 = 0;
  if ( dstObject )
    v4 = srcObject == 0;
  if ( !v4 )
  {
    v6 = (__int64 *)((char *)srcObject + rpOpenGLLightOffset);
    v7 = *v6;
    v8 = v6[1];
    v9 = (char *)dstObject + rpOpenGLLightOffset;
    v5 = dstObject;
    *v9 = v7;
    v9[1] = v8;
  }
  return v5;
}

//----- (00221CA0) --------------------------------------------------------
RwBool _rwOpenGLLightsOpen()
{
  __int64 v0; // d16
  __int64 v1; // d17
  int IsEnabled; // r0
  int v3; // r1
  unsigned int v4; // r4
  unsigned int v5; // r0

  *(float *)&v0 = 1.0;
  *((float *)&v0 + 1) = 1.0;
  *(float *)&v1 = 1.0;
  *((float *)&v1 + 1) = 1.0;
  *(_QWORD *)openglOpaqueWhite = v0;
  *(_QWORD *)&openglOpaqueWhite[2] = v1;
  *(_QWORD *)rwOpenGLOpaqueBlack = 0LL;
  *(_QWORD *)&rwOpenGLOpaqueBlack[2] = 0x3F80000000000000LL;
  openglLightsMaxLights = 1;
  rwOpenGLLightingEnabled = emu_glIsEnabled(0xB50u) != 0;
  rwOpenGLColorMaterialEnabled = emu_glIsEnabled(0xB57u) != 0;
  IsEnabled = emu_glIsEnabled(0xBA1u);
  v3 = (unsigned __int8)openglLightsMaxLights;
  rwOpenGLNormalizeEnabled = IsEnabled != 0;
  if ( openglLightsMaxLights )
    v3 = 32;
  openglLightStatus = (RwBool *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(v3);
  if ( !openglLightStatus )
    return 0;
  if ( openglLightsMaxLights == 1 )
  {
    v4 = 0;
    do
    {
      openglLightStatus[v4] = emu_glIsEnabled(v4 + 0x4000) != 0;
      ++v4;
      v5 = (unsigned __int8)openglLightsMaxLights;
      if ( openglLightsMaxLights )
        v5 = 8;
    }
    while ( v4 < v5 );
  }
  return 1;
}
// 6BD700: using guessed type char openglLightsMaxLights;

//----- (00221DBC) --------------------------------------------------------
RwBool _rwOpenGLLightsClose()
{
  RwBool *v0; // r0
  char v1; // r1
  unsigned int v2; // r4
  unsigned int v3; // r2

  v0 = openglLightStatus;
  if ( openglLightStatus )
  {
    if ( openglLightsMaxLights == 1 )
    {
      v1 = 1;
      v2 = 0;
      do
      {
        if ( v0[v2] )
        {
          emu_glDisable(v2 + 0x4000);
          v0 = openglLightStatus;
          openglLightStatus[v2] = 0;
          v1 = openglLightsMaxLights;
        }
        v3 = v1 & 1;
        ++v2;
        if ( (v1 & 1) != 0 )
          v3 = 8;
      }
      while ( v2 < v3 );
    }
    (*((void (**)(void))RwEngineInstance + 76))();
    openglLightStatus = 0;
  }
  return 1;
}
// 6BD700: using guessed type char openglLightsMaxLights;

//----- (00221E48) --------------------------------------------------------
void __fastcall _rwOpenGLLightsEnable(const RwBool enableLighting)
{
  const GLfloat *v1; // r1

  if ( enableLighting )
  {
    if ( openglUseAmbientLight == 1 )
      v1 = openglOpaqueWhite;
    else
      v1 = rwOpenGLOpaqueBlack;
    emu_glLightModelfv(0xB53u, v1);
    if ( !rwOpenGLLightingEnabled )
    {
      emu_glEnable(0xB50u);
      rwOpenGLLightingEnabled = 1;
    }
  }
  else if ( rwOpenGLLightingEnabled )
  {
    emu_glDisable(0xB50u);
    rwOpenGLLightingEnabled = 0;
  }
}
// 6BD724: using guessed type char openglUseAmbientLight;

//----- (00221ED0) --------------------------------------------------------
RwBool __fastcall _rwOpenGLLightsGlobalLightsEnable(const RpLightFlag_0 lightFlags)
{
  unsigned __int8 v1; // r11
  int v2; // r6
  int *v3; // r4
  int *v4; // r6
  int *v5; // t1
  RwBool v6; // r5
  int v7; // r9
  RwMatrix *LTM; // r0
  float y; // s2
  float z; // s4
  float v11; // s0
  GLfloat params[11]; // [sp+24h] [bp-2Ch] BYREF

  v1 = lightFlags;
  v2 = *((_DWORD *)RwEngineInstance + 1);
  v5 = *(int **)(v2 + 60);
  v4 = (int *)(v2 + 60);
  v3 = v5;
  *(_QWORD *)openglLightApplied = 0LL;
  *(_QWORD *)&openglLightApplied[2] = 0LL;
  *(_QWORD *)&openglAmbientLight.red = 0LL;
  *(_QWORD *)&openglAmbientLight.blue = 0x3F80000000000000LL;
  openglUseAmbientLight = 0;
  *(_QWORD *)&openglLightApplied[4] = 0LL;
  *(_QWORD *)&openglLightApplied[6] = 0LL;
  if ( v5 != v4 )
  {
    v6 = 0;
    while ( 1 )
    {
      if ( (*((_BYTE *)v3 - 50) & v1) != 0 )
      {
        if ( *((_BYTE *)v3 - 51) == 1 )
        {
          if ( *((_BYTE *)v3 + 10) )
          {
            v7 = 0;
            goto LABEL_22;
          }
          if ( !openglLightApplied[1] )
          {
            v7 = 1;
LABEL_22:
            LTM = RwFrameGetLTM((RwFrame_0 *)*(v3 - 12));
            y = LTM->at.y;
            z = LTM->at.z;
            params[0] = -LTM->at.x;
            params[1] = -y;
            params[3] = 0.0;
            params[2] = -z;
            emu_glLightfv(v7 | 0x4000, 0x1203u, params);
            emu_glLightfv(v7 | 0x4000, 0x1200u, rwOpenGLOpaqueBlack);
            emu_glLightfv(v7 | 0x4000, 0x1201u, (const GLfloat *)v3 - 7);
            emu_glLightf(v7 | 0x4000, 0x1206u, 180.0);
            if ( !openglLightStatus[v7] )
            {
              emu_glEnable(v7 | 0x4000);
              openglLightStatus[v7] = 1;
            }
            v6 = 1;
            openglLightApplied[v7] = 1;
            goto LABEL_26;
          }
          if ( !openglLightApplied[2] )
          {
            v7 = 2;
            goto LABEL_22;
          }
          if ( !openglLightApplied[3] )
          {
            v7 = 3;
            goto LABEL_22;
          }
          if ( !openglLightApplied[4] )
          {
            v7 = 4;
            goto LABEL_22;
          }
          if ( !openglLightApplied[5] )
          {
            v7 = 5;
            goto LABEL_22;
          }
          if ( !openglLightApplied[6] )
          {
            v7 = 6;
            goto LABEL_22;
          }
          if ( !openglLightApplied[7] )
          {
            v7 = 7;
            goto LABEL_22;
          }
          v6 = 1;
        }
        else
        {
          v6 = 1;
          openglAmbientLight.red = *((float *)v3 - 7) + openglAmbientLight.red;
          openglAmbientLight.green = *((float *)v3 - 6) + openglAmbientLight.green;
          v11 = *((float *)v3 - 5);
          openglUseAmbientLight = 1;
          openglAmbientLight.blue = v11 + openglAmbientLight.blue;
        }
      }
LABEL_26:
      v3 = (int *)*v3;
      if ( v3 == v4 )
      {
        if ( !openglLightApplied[0] )
          goto LABEL_30;
        goto LABEL_32;
      }
    }
  }
  v6 = 0;
LABEL_30:
  if ( *openglLightStatus )
  {
    emu_glDisable(0x4000u);
    *openglLightStatus = 0;
  }
LABEL_32:
  if ( !openglLightApplied[1] && openglLightStatus[1] )
  {
    emu_glDisable(0x4001u);
    openglLightStatus[1] = 0;
  }
  if ( !openglLightApplied[2] && openglLightStatus[2] )
  {
    emu_glDisable(0x4002u);
    openglLightStatus[2] = 0;
  }
  if ( !openglLightApplied[3] && openglLightStatus[3] )
  {
    emu_glDisable(0x4003u);
    openglLightStatus[3] = 0;
  }
  if ( !openglLightApplied[4] && openglLightStatus[4] )
  {
    emu_glDisable(0x4004u);
    openglLightStatus[4] = 0;
  }
  if ( !openglLightApplied[5] && openglLightStatus[5] )
  {
    emu_glDisable(0x4005u);
    openglLightStatus[5] = 0;
  }
  if ( !openglLightApplied[6] && openglLightStatus[6] )
  {
    emu_glDisable(0x4006u);
    openglLightStatus[6] = 0;
  }
  if ( !openglLightApplied[7] && openglLightStatus[7] )
  {
    emu_glDisable(0x4007u);
    openglLightStatus[7] = 0;
  }
  return v6;
}
// 6BD724: using guessed type char openglUseAmbientLight;

//----- (002222C4) --------------------------------------------------------
RwBool __fastcall _rwOpenGLLightsLocalLightEnable(const RpLight_0 *const localLight)
{
  int v2; // r8
  float radius; // s16
  RwMatrix *LTM; // r6
  GLfloat y; // r1
  GLfloat z; // r2
  int *v7; // r5
  float v8; // s18
  float v9; // s20
  float v10; // s16
  int subType; // r0
  int v12; // r2
  int v13; // r0
  GLenum v14; // r1
  RwBool result; // r0
  int y_low; // r1
  int z_low; // r2
  RwReal ConeAngle; // r0
  int v19; // r1
  int v20; // r2
  RwReal v21; // r0
  GLfloat x; // [sp+4h] [bp-4Ch] BYREF
  int v23; // [sp+8h] [bp-48h]
  int v24; // [sp+Ch] [bp-44h]
  GLfloat params[16]; // [sp+10h] [bp-40h] BYREF

  if ( localLight->isMainLight )
  {
    v2 = 0;
  }
  else if ( openglLightApplied[1] )
  {
    if ( openglLightApplied[2] )
    {
      if ( openglLightApplied[3] )
      {
        if ( openglLightApplied[4] )
        {
          if ( openglLightApplied[5] )
          {
            if ( openglLightApplied[6] )
            {
              if ( openglLightApplied[7] )
                return 1;
              v2 = 7;
            }
            else
            {
              v2 = 6;
            }
          }
          else
          {
            v2 = 5;
          }
        }
        else
        {
          v2 = 4;
        }
      }
      else
      {
        v2 = 3;
      }
    }
    else
    {
      v2 = 2;
    }
  }
  else
  {
    v2 = 1;
  }
  radius = localLight->radius;
  if ( radius == 0.0 )
    return 1;
  emu_glLightfv(v2 | 0x4000, 0x1201u, &localLight->color.red);
  LTM = RwFrameGetLTM((RwFrame_0 *)localLight->object.object.parent);
  y = LTM->pos.y;
  z = LTM->pos.z;
  params[0] = LTM->pos.x;
  params[1] = y;
  params[2] = z;
  params[3] = 1.0;
  emu_glLightfv(v2 | 0x4000, 0x1203u, params);
  v7 = (int *)(&localLight->object.object.type + rpOpenGLLightOffset);
  v8 = *(float *)((char *)&localLight->object.lFrame.next + rpOpenGLLightOffset);
  v9 = *(float *)((char *)&localLight->object.lFrame.prev + rpOpenGLLightOffset);
  emu_glLightf(v2 | 0x4000, 0x1207u, *(GLfloat *)((char *)&localLight->object.object.parent + rpOpenGLLightOffset));
  v10 = 1.0 / radius;
  emu_glLightf(v2 | 0x4000, 0x1208u, v10 * v8);
  emu_glLightf(v2 | 0x4000, 0x1209u, v10 * (float)(v10 * v9));
  subType = localLight->object.object.subType;
  switch ( subType )
  {
    case 130:
      y_low = LODWORD(LTM->at.y);
      z_low = LODWORD(LTM->at.z);
      x = LTM->at.x;
      v23 = y_low;
      v24 = z_low;
      emu_glLightfv(v2 | 0x4000, 0x1204u, &x);
      ConeAngle = RpLightGetConeAngle(localLight);
      emu_glLightf(v2 | 0x4000, 0x1206u, ConeAngle * 57.296);
      v12 = *v7;
      v13 = v2 | 0x4000;
      v14 = 4613;
      break;
    case 129:
      v19 = LODWORD(LTM->at.y);
      v20 = LODWORD(LTM->at.z);
      x = LTM->at.x;
      v23 = v19;
      v24 = v20;
      emu_glLightfv(v2 | 0x4000, 0x1204u, &x);
      v21 = RpLightGetConeAngle(localLight);
      emu_glLightf(v2 | 0x4000, 0x1206u, v21 * 57.296);
      v13 = v2 | 0x4000;
      v14 = 4613;
      v12 = 0;
      break;
    case 128:
      v12 = 1127481344;
      v13 = v2 | 0x4000;
      v14 = 4614;
      break;
    default:
      return 0;
  }
  emu_glLightf(v13, v14, *(GLfloat *)&v12);
  if ( !openglLightStatus[v2] )
  {
    emu_glEnable(v2 | 0x4000);
    openglLightStatus[v2] = 1;
  }
  result = 1;
  openglLightApplied[v2] = 1;
  return result;
}

//----- (00222504) --------------------------------------------------------
void __fastcall _rwOpenGLLightsSetMaterialProperties(const RpMaterial_0 *material, const RwUInt32 flags)
{
  char v2; // r5
  RwRGBA_0 color; // r1
  float red; // s4
  float v5; // s0
  float green; // s6
  float blue; // s8
  float v8; // s0
  float v9; // s2
  float v10; // s6
  float v11; // s4
  float v12; // s2
  float ambient; // s2
  unsigned __int64 v14; // [sp+0h] [bp-28h] BYREF
  RwReal v15; // [sp+8h] [bp-20h]
  RwReal v16; // [sp+Ch] [bp-1Ch]
  GLfloat params; // [sp+10h] [bp-18h] BYREF
  RwReal v18; // [sp+14h] [bp-14h]
  RwReal diffuse; // [sp+18h] [bp-10h]
  float v20; // [sp+1Ch] [bp-Ch]

  v2 = flags;
  v14 = *(_QWORD *)rwOpenGLOpaqueBlack;
  v15 = rwOpenGLOpaqueBlack[2];
  v16 = rwOpenGLOpaqueBlack[3];
  params = rwOpenGLOpaqueBlack[0];
  v18 = rwOpenGLOpaqueBlack[1];
  diffuse = rwOpenGLOpaqueBlack[2];
  v20 = rwOpenGLOpaqueBlack[3];
  if ( (flags & 0x40) != 0 )
  {
    color = material->color;
    if ( color != -1 )
    {
      red = (float)color._anon_0._anon_0.red;
      v5 = material->surfaceProps.diffuse * 0.0039216;
      params = v5 * red;
      green = (float)material->color._anon_0._anon_0.green;
      v18 = v5 * green;
      blue = (float)material->color._anon_0._anon_0.blue;
      diffuse = v5 * blue;
      v8 = (float)material->color._anon_0._anon_0.alpha * 0.0039216;
      v20 = v8;
      v9 = material->surfaceProps.ambient * 0.0039216;
      v10 = openglAmbientLight.green * (float)(v9 * green);
      v11 = openglAmbientLight.red * (float)(v9 * red);
      v12 = openglAmbientLight.blue * (float)(v9 * blue);
LABEL_6:
      v14 = __PAIR64__(LODWORD(v10), LODWORD(v11));
      goto LABEL_8;
    }
  }
  v8 = 1.0;
  diffuse = material->surfaceProps.diffuse;
  params = diffuse;
  v18 = diffuse;
  v20 = 1.0;
  ambient = material->surfaceProps.ambient;
  if ( ambient != 1.0 )
  {
    v11 = ambient * openglAmbientLight.red;
    v10 = ambient * openglAmbientLight.green;
    v12 = ambient * openglAmbientLight.blue;
    goto LABEL_6;
  }
  v12 = openglAmbientLight.blue;
  v14 = *(_QWORD *)&openglAmbientLight.red;
LABEL_8:
  v16 = v8;
  v15 = v12;
  emu_glMaterialfv(0x404u, 0x1201u, &params);
  emu_glMaterialfv(0x404u, 0x1200u, (const GLfloat *)&v14);
  if ( (v2 & 8) != 0 )
  {
    if ( !rwOpenGLColorMaterialEnabled )
    {
      emu_glEnable(0xB57u);
      rwOpenGLColorMaterialEnabled = 1;
    }
    emu_glColorMaterial(0x404u, 0x1600u);
  }
  else
  {
    if ( rwOpenGLColorMaterialEnabled )
    {
      emu_glDisable(0xB57u);
      rwOpenGLColorMaterialEnabled = 0;
    }
    emu_glMaterialfv(0x404u, 0x1600u, rwOpenGLOpaqueBlack);
  }
}

//----- (002226B4) --------------------------------------------------------
void __fastcall RpOpenGLLightSetAttenuationParams(void *const voidLight, const RpOpenGLLightAttentuation_0 *params)
{
  __int64 v2; // d16
  char *v3; // r0

  v2 = *(_QWORD *)&params->constant;
  v3 = (char *)voidLight + rpOpenGLLightOffset;
  *((_DWORD *)v3 + 3) = LODWORD(params->quadratic);
  *(_QWORD *)(v3 + 4) = v2;
}

//----- (002226D0) --------------------------------------------------------
RpOpenGLLightAttentuation_0 *__fastcall RpOpenGLLightGetAttenuationParams(
        RpOpenGLLightAttentuation_0 *retstr,
        const void *const voidLight)
{
  char *v2; // r1
  __int64 v3; // d16

  v2 = (char *)voidLight + rpOpenGLLightOffset;
  v3 = *(_QWORD *)(v2 + 4);
  retstr->quadratic = *((RwReal *)v2 + 3);
  *(_QWORD *)&retstr->constant = v3;
  return retstr;
}

//----- (002226EC) --------------------------------------------------------
void __fastcall RpOpenGLLightSetSoftSpotExponent(void *const voidLight, const RwReal exponent)
{
  if ( *((unsigned __int8 *)voidLight + 1) == 130 )
    *(const RwReal *)((char *)voidLight + rpOpenGLLightOffset) = exponent;
}

//----- (0022270C) --------------------------------------------------------
RwReal __fastcall RpOpenGLLightGetSoftSpotExponent(const void *const voidLight)
{
  if ( *((unsigned __int8 *)voidLight + 1) == 130 )
    return *(float *)((char *)voidLight + rpOpenGLLightOffset);
  else
    return 0.0;
}

//----- (00222740) --------------------------------------------------------
RwResEntry_0 *__fastcall _rxOpenGLInstance(
        void *object,
        void *owner,
        RwResEntry_0 **resEntryPtr,
        RpMeshHeader_0 *meshHeader,
        const RwBool instanceDLandVA,
        RxOpenGLAllInOneInstanceCallBack instanceCB)
{
  RpMeshHeader_0 *v6; // r9
  RwResEntry_0 *result; // r0
  int numMeshes; // r10
  RwLLLink **p_prev; // r4
  RxOpenGLAllInOneInstanceCallBack v10; // r5
  RpMeshHeader_0 *v11; // r8
  int v12; // r11
  int (__fastcall **v13)(int, _DWORD, unsigned __int16 *, unsigned int); // lr
  GLenum v14; // r1
  unsigned __int16 *v15; // r2
  RwLLLink *v16; // r0
  unsigned __int16 *flags; // r6
  unsigned int v18; // r3
  unsigned int v19; // r1
  int8x16_t v20; // q8
  int8x16_t v21; // q9
  unsigned int v22; // r0
  unsigned int v23; // r9
  unsigned int v24; // r5
  uint32x4_t v25; // q10
  uint32x4_t v26; // q9
  uint32x4_t v27; // q8
  unsigned __int32 v28; // r5
  unsigned int v29; // r1
  unsigned __int16 v30; // d21.h[0]
  RwLLLink *v31; // r0
  RwLLLink *v32; // r0
  unsigned int v33; // r6
  unsigned __int32 v34; // t1
  RwLLLink *v35; // r1
  int16x4_t *v36; // r0
  unsigned int v37; // r12
  int16x4_t *v38; // r6
  unsigned int *v39; // r9
  int v40; // lr
  char *v41; // r5
  int v42; // r3
  _BOOL4 v43; // r5
  _BOOL4 v44; // r2
  bool v45; // zf
  unsigned int v46; // r2
  __int16 *v47; // r3
  int16x4_t *v48; // r5
  int16x4_t v49; // d16
  unsigned int v50; // lr
  int16x4_t v51; // d17
  __int16 v52; // t1
  RwResEntry_0 *entry; // [sp+0h] [bp-60h]
  RwLLLink **v54; // [sp+4h] [bp-5Ch]
  unsigned int v55; // [sp+8h] [bp-58h]
  RwLLLink *v56; // [sp+Ch] [bp-54h]
  unsigned int v57; // [sp+Ch] [bp-54h]
  RpMeshHeader_0 *v58; // [sp+10h] [bp-50h]
  RwLLLink *v60; // [sp+18h] [bp-48h]

  v6 = meshHeader;
  result = RwResourcesAllocateResEntry(owner, resEntryPtr, (56 * meshHeader->numMeshes) | 4, openglResEntryDestructor);
  if ( !result )
    return 0;
  LOWORD(result[1].link.next) = v6->serialNum;
  HIWORD(result[1].link.next) = v6->numMeshes;
  numMeshes = v6->numMeshes;
  if ( v6->numMeshes )
  {
    p_prev = &result[1].link.prev;
    v10 = instanceCB;
    entry = result;
    v54 = &result[2].link.prev;
    v11 = v6 + 1;
    v12 = 0;
    v58 = v6;
    v60 = 0;
    while ( 1 )
    {
      v13 = (int (__fastcall **)(int, _DWORD, unsigned __int16 *, unsigned int))RwEngineInstance;
      v14 = rwOpenGLPrimConvTbl[*((unsigned __int8 *)RwEngineInstance + meshModule.globalsOffset + LOBYTE(v6->flags) + 8)];
      *((_QWORD *)p_prev + 4) = 0LL;
      *((_QWORD *)p_prev + 5) = 0LL;
      *(_QWORD *)(p_prev + 5) = 0LL;
      *(_QWORD *)(p_prev + 7) = 0LL;
      v15 = (unsigned __int16 *)(p_prev + 1);
      *(_QWORD *)(p_prev + 1) = 0LL;
      *(_QWORD *)(p_prev + 3) = 0LL;
      *p_prev = (RwLLLink *)v14;
      p_prev[12] = (RwLLLink *)v11->totalIndicesInMesh;
      p_prev[13] = 0;
      if ( BYTE1(v6->flags) << 31 )
      {
        p_prev[10] = 0;
        p_prev[11] = 0;
        v31 = *(RwLLLink **)&v11->numMeshes;
        p_prev[6] = v60;
        p_prev[3] = v31;
        v60 = (RwLLLink *)((char *)v31 + (_DWORD)v60);
        if ( !v10 )
          goto LABEL_50;
        goto LABEL_49;
      }
      v16 = *(RwLLLink **)&v11->numMeshes;
      p_prev[10] = v16;
      flags = (unsigned __int16 *)v11->flags;
      if ( !v11->flags )
      {
        p_prev[11] = 0;
        p_prev[8] = (RwLLLink *)v6->indexBuffer;
        v32 = *(RwLLLink **)&v11->numMeshes;
        p_prev[3] = 0;
        p_prev[10] = v32;
        p_prev[9] = (RwLLLink *)v11->firstMeshOffset;
        if ( !v10 )
          goto LABEL_50;
        goto LABEL_49;
      }
      v18 = *(_DWORD *)&v11->numMeshes;
      p_prev[6] = 0;
      p_prev[3] = 0;
      if ( v18 )
        break;
LABEL_29:
      v36 = (int16x4_t *)v13[75](2 * (_DWORD)v16, v13[75], v15, v18);
      v37 = (unsigned int)p_prev[10];
      p_prev[11] = (RwLLLink *)v36;
      if ( !v37 )
      {
        if ( !v10 )
          goto LABEL_50;
        goto LABEL_49;
      }
      v38 = (int16x4_t *)v11->flags;
      v39 = (unsigned int *)(p_prev + 6);
      if ( v37 < 4 )
        goto LABEL_44;
      v57 = v37 & 0xFFFFFFFC;
      if ( (v37 & 0xFFFFFFFC) == 0 )
        goto LABEL_44;
      v40 = 0;
      v41 = (char *)v36 + 2 * v37;
      v42 = 0;
      if ( v36 < (int16x4_t *)((char *)&v54[14 * v12] + 1) )
        v40 = 1;
      if ( v41 > (char *)v39 )
        v42 = 1;
      v43 = v41 > (char *)v38;
      v44 = v36 < (int16x4_t *)((char *)v38 + 2 * v37);
      v45 = !v44 || !v43;
      if ( !v44 || !v43 )
        v45 = (v40 & v42) == 0;
      if ( !v45 )
      {
LABEL_44:
        v46 = v37;
        v48 = v36;
        v47 = (__int16 *)v11->flags;
        do
        {
LABEL_45:
          --v46;
          v52 = *v47++;
          v48->n64_u16[0] = v52 - *(_WORD *)v39;
          v48 = (int16x4_t *)((char *)v48 + 2);
        }
        while ( v46 );
        goto LABEL_46;
      }
      v46 = v37 - v57;
      v47 = (__int16 *)v38 + v57;
      v48 = (int16x4_t *)((char *)v36 + 2 * v57);
      v49.n64_u64[0] = vmovn_s32(vdupq_n_s32(*v39)).n64_u64[0];
      v49.n64_u16[3] = *v39;
      v50 = v37 & 0xFFFFFFFC;
      do
      {
        v51.n64_u64[0] = v38->n64_u64[0];
        ++v38;
        v50 -= 4;
        v36->n64_u64[0] = vsub_s16(v51, v49).n64_u64[0];
        ++v36;
      }
      while ( v50 );
      if ( v37 != v57 )
        goto LABEL_45;
LABEL_46:
      v10 = instanceCB;
      v6 = v58;
      if ( !instanceCB )
        goto LABEL_50;
LABEL_49:
      if ( !v10(object, (RxOpenGLMeshInstanceData_0 *)p_prev, instanceDLandVA, 0) )
      {
        RwResourcesFreeResEntry(entry);
        return 0;
      }
LABEL_50:
      --numMeshes;
      ++v12;
      p_prev += 14;
      v11 = (RpMeshHeader_0 *)((char *)v11 + 16);
      if ( !(numMeshes << 16) )
        return entry;
    }
    if ( v18 >= 4 && (v19 = v18 & 0xFFFFFFFC, (v18 & 0xFFFFFFFC) != 0) )
    {
      v20.n128_u64[0] = -1LL;
      v20.n128_u64[1] = -1LL;
      v55 = v18;
      v56 = v16;
      v21 = 0uLL;
      v18 -= v19;
      v15 = &flags[v19];
      v22 = v19;
      do
      {
        v23 = *((_DWORD *)flags + 1);
        v19 -= 4;
        v24 = *(_DWORD *)flags;
        flags += 4;
        v25 = vmovl_u16((uint16x4_t)__PAIR64__(v23, v24));
        v21 = vmaxq_u32(v21, v25);
        v20 = vminq_u32(v20, v25);
      }
      while ( v19 );
      v26 = vmaxq_u32(v21, vextq_s8(v21, v20, 8u));
      v27 = vminq_u32(v20, vextq_s8(v20, v20, 8u));
      v28 = v26.n128_u32[1];
      v29 = v27.n128_u32[1];
      v30 = vmovn_s32(vcgtq_u32(vdupq_lane_s32((int32x2_t)v27.n128_u64[0], 1), v27)).n64_u16[0];
      if ( vmovn_s32(vcgtq_u32(v26, vdupq_lane_s32((int32x2_t)v26.n128_u64[0], 1))).n64_u16[0] << 31 )
        v28 = v26.n128_u32[0];
      if ( v30 << 31 )
        v29 = v27.n128_u32[0];
      v45 = v55 == v22;
      v16 = v56;
      v6 = v58;
      if ( v45 )
        goto LABEL_28;
    }
    else
    {
      v29 = -1;
      v28 = 0;
      v15 = flags;
    }
    do
    {
      v34 = *v15++;
      v33 = v34;
      if ( v28 < v34 )
        v28 = v33;
      if ( v29 > v33 )
        v29 = v33;
      --v18;
    }
    while ( v18 );
LABEL_28:
    p_prev[6] = (RwLLLink *)v29;
    v35 = (RwLLLink *)(1 - v29 + v28);
    v10 = instanceCB;
    p_prev[3] = v35;
    goto LABEL_29;
  }
  return result;
}

//----- (00222A54) --------------------------------------------------------
void __fastcall openglResEntryDestructor(RwResEntry_0 *resEntry)
{
  int next_high; // r4
  RwResEntry_0 *v2; // r5
  u_native next; // r0

  next_high = HIWORD(resEntry[1].link.next);
  if ( HIWORD(resEntry[1].link.next) )
  {
    v2 = resEntry + 3;
    do
    {
      next = (u_native)v2[-1].link.next;
      if ( next )
        emu_ArraysDelete(next);
      --next_high;
      if ( v2->link.next )
      {
        (*((void (**)(void))RwEngineInstance + 76))();
        v2->link.next = 0;
      }
      v2 = (RwResEntry_0 *)((char *)v2 + 56);
    }
    while ( next_high << 16 );
  }
}

//----- (00222A9C) --------------------------------------------------------
void __fastcall _rxOpenGLMeshGetNumVerticesAndMinIndex(
        RxVertexIndex *indices,
        RwUInt32 numIndices,
        RwUInt32 *numVertices,
        RwUInt32 *minIndex)
{
  RwUInt32 v4; // r8
  int8x16_t v5; // q8
  RwUInt32 v6; // lr
  int8x16_t v7; // q9
  RxVertexIndex *v8; // r12
  RwUInt32 v9; // r5
  unsigned int v10; // r4
  unsigned int v11; // r6
  uint32x4_t v12; // q10
  uint32x4_t v13; // q9
  uint32x4_t v14; // q8
  unsigned __int32 v15; // r5
  RwUInt32 v16; // r4
  unsigned __int16 v17; // d21.h[0]
  RwUInt32 v18; // r0
  unsigned __int32 v19; // t1

  *numVertices = 0;
  if ( minIndex )
    *minIndex = 0;
  if ( numIndices )
  {
    if ( numIndices >= 4 && (v4 = numIndices & 0xFFFFFFFC, (numIndices & 0xFFFFFFFC) != 0) )
    {
      v5.n128_u64[0] = -1LL;
      v5.n128_u64[1] = -1LL;
      v6 = numIndices - v4;
      v7 = 0uLL;
      v8 = &indices[v4];
      v9 = numIndices & 0xFFFFFFFC;
      do
      {
        v10 = *((_DWORD *)indices + 1);
        v9 -= 4;
        v11 = *(_DWORD *)indices;
        indices += 4;
        v12 = vmovl_u16((uint16x4_t)__PAIR64__(v10, v11));
        v7 = vmaxq_u32(v7, v12);
        v5 = vminq_u32(v5, v12);
      }
      while ( v9 );
      v13 = vmaxq_u32(v7, vextq_s8(v7, v5, 8u));
      v14 = vminq_u32(v5, vextq_s8(v5, v5, 8u));
      v15 = v13.n128_u32[1];
      v16 = v14.n128_u32[1];
      v17 = vmovn_s32(vcgtq_u32(vdupq_lane_s32((int32x2_t)v14.n128_u64[0], 1), v14)).n64_u16[0];
      if ( vmovn_s32(vcgtq_u32(v13, vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 1))).n64_u16[0] << 31 )
        v15 = v13.n128_u32[0];
      if ( v17 << 31 )
        v16 = v14.n128_u32[0];
      if ( v4 == numIndices )
        goto LABEL_20;
    }
    else
    {
      v16 = -1;
      v15 = 0;
      v8 = indices;
      v6 = numIndices;
    }
    do
    {
      v19 = *v8++;
      v18 = v19;
      if ( v15 < v19 )
        v15 = v18;
      if ( v16 > v18 )
        v16 = v18;
      --v6;
    }
    while ( v6 );
LABEL_20:
    if ( minIndex )
    {
      *numVertices = 1 - v16 + v15;
      *minIndex = v16;
    }
    else
    {
      *numVertices = v15 + 1;
    }
  }
}

//----- (00222B80) --------------------------------------------------------
void __fastcall RxOpenGLMeshInstanceData::DrawStored(RxOpenGLMeshInstanceData *this)
{
  bool v1; // zf
  u_native vertexBufferRef; // r1
  u_native indexBufferRef; // r12
  RwUInt32 primType; // r2

  v1 = !skipBlendRender;
  if ( skipBlendRender )
    v1 = !emu_InternalBlendEnabled;
  if ( v1 && (!skipNonblendRender || emu_InternalBlendEnabled) )
  {
    vertexBufferRef = this->vertexBufferRef;
    if ( vertexBufferRef )
    {
      indexBufferRef = this->indexBufferRef;
      primType = this->primType;
      if ( indexBufferRef )
        emu_ArraysDrawStoredSeparate(indexBufferRef, vertexBufferRef, primType, this->indexOffset, this->numIndices);
      else
        sub_19318C(this->vertexBufferRef, primType);
    }
    else
    {
      sub_19318C(this->emuArrayRef, this->primType);
    }
  }
}

//----- (00222BEC) --------------------------------------------------------
void __fastcall _rpSkipBlendRender(bool doSkip)
{
  skipBlendRender = doSkip;
}

//----- (00222BFC) --------------------------------------------------------
void __fastcall _rpSkipNonblendRender(bool doSkip)
{
  skipNonblendRender = 0;
}

//----- (00222C0C) --------------------------------------------------------
RwBool __fastcall _rxOpenGLReinstance(
        void *object,
        const RpMeshHeader_0 *meshHeader,
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RwBool instanceDLandVA,
        int (__fastcall *a5)(void *, RxOpenGLMeshInstanceData_0 *, const RwBool, int))
{
  int numMeshes; // r4
  bool v9; // zf

  v9 = a5 == 0;
  if ( a5 )
  {
    numMeshes = meshHeader->numMeshes;
    v9 = numMeshes == 0;
  }
  if ( v9 )
    return 1;
  while ( a5(object, instanceData, instanceDLandVA, 1) )
  {
    --numMeshes;
    ++instanceData;
    if ( !(numMeshes << 16) )
      return 1;
  }
  return 0;
}
// 222C36: variable 'numMeshes' is possibly undefined

//----- (00222C50) --------------------------------------------------------
void __fastcall _rxOpenGLDefaultAllInOneRenderCB(
        RwResEntry_0 *repEntry,
        void *object,
        const RwUInt8 type,
        const RwUInt32 flags)
{
  RwLLLink *next; // r10
  int next_high; // r5
  RwLLLink **p_prev; // r4
  RwUInt32 v7; // r11
  RwLLLink *v8; // r0
  __int64 v9; // r0
  void *v10; // r6
  bool v11; // zf
  void *next_low; // r1
  RwRenderState_0 v13; // r0
  bool v14; // zf
  u_native v15; // r1
  u_native v16; // r0
  GLenum v17; // r1
  u_native v18; // r0
  RwUInt32 v19; // [sp+14h] [bp-34h]

  next_high = HIWORD(repEntry[1].link.next);
  if ( HIWORD(repEntry[1].link.next) )
  {
    p_prev = &repEntry[1].link.prev;
    v7 = flags & 0x84;
    v19 = flags & 8;
    while ( 1 )
    {
      v8 = p_prev[12];
      if ( !v8 )
        return;
      HIDWORD(v9) = p_prev[13];
      --next_high;
      LODWORD(v9) = HIBYTE(v8->prev);
      if ( v9 == 255 )
      {
        v10 = 0;
      }
      else
      {
        if ( !(_DWORD)v9 )
          goto LABEL_31;
        emu_EnableAlphaModulate((float)(unsigned int)v9 / 255.0);
        v10 = &dword_0 + 1;
      }
      _rwOpenGLSetRenderState(rwRENDERSTATEVERTEXALPHAENABLE, v10);
      if ( rwOpenGLLightingEnabled )
      {
        _rwOpenGLLightsSetMaterialProperties((const RpMaterial_0 *)p_prev[12], flags);
      }
      else
      {
        if ( rwOpenGLColorMaterialEnabled )
        {
          emu_glDisable(0xB57u);
          rwOpenGLColorMaterialEnabled = 0;
        }
        if ( !v19 )
          emu_glColor4fv(rwOpenGLOpaqueBlack);
      }
      v11 = v7 == 0;
      if ( v7 )
      {
        next = p_prev[12]->next;
        v11 = next == 0;
      }
      if ( v11 )
      {
        v13 = rwRENDERSTATETEXTURERASTER;
        next_low = 0;
LABEL_20:
        _rwOpenGLSetRenderState(v13, next_low);
        v14 = !skipBlendRender;
        if ( skipBlendRender )
          v14 = !emu_InternalBlendEnabled;
        if ( !v14 || !emu_InternalBlendEnabled && skipNonblendRender )
          goto LABEL_36;
        v15 = (u_native)p_prev[7];
        if ( !v15 )
        {
          v17 = (GLenum)*p_prev;
          v18 = (u_native)p_prev[5];
LABEL_35:
          emu_ArraysDrawStored(v18, v17);
          goto LABEL_36;
        }
        v16 = (u_native)p_prev[8];
        if ( !v16 )
        {
          v18 = (u_native)p_prev[7];
          v17 = (GLenum)*p_prev;
          goto LABEL_35;
        }
        emu_ArraysDrawStoredSeparate(v16, v15, (GLenum)*p_prev, (GLuint)p_prev[9], (GLuint)p_prev[10]);
LABEL_36:
        p_prev += 14;
        if ( v10 )
          emu_DisableAlphaModulate();
        if ( !(next_high << 16) )
          return;
      }
      else
      {
        if ( !(LOBYTE(next->next[6].next) << 31) )
        {
          _rwOpenGLSetRenderStateNoExtras(rwRENDERSTATETEXTURERASTER, next->next);
          next_low = (void *)LOBYTE(next[10].next);
          v13 = rwRENDERSTATETEXTUREFILTER;
          goto LABEL_20;
        }
        if ( v10 )
          emu_DisableAlphaModulate();
LABEL_31:
        p_prev += 14;
        if ( !(next_high << 16) )
          return;
      }
    }
  }
}
// 222D32: variable 'next' is possibly undefined
// 0: using guessed type int dword_0;

//----- (00222DE0) --------------------------------------------------------
RwBool __fastcall _rxOpenGLAllInOnePipelineInit(RxPipelineNode_0 *node)
{
  RwUInt32 v1; // r0

  v1 = openglAllInOneInitRefCount;
  if ( !openglAllInOneInitRefCount )
  {
    *(_QWORD *)rwOpenGLPrimConvTbl = 0LL;
    *(_QWORD *)&rwOpenGLPrimConvTbl[5] = 6LL;
    *(_QWORD *)&rwOpenGLPrimConvTbl[1] = 0x300000001LL;
    *(_QWORD *)&rwOpenGLPrimConvTbl[3] = 0x500000004LL;
    rwOpenGLVertexArrayEnabled = emu_glIsEnabled(0x8074u) != 0;
    rwOpenGLNormalArrayEnabled = emu_glIsEnabled(0x8075u) != 0;
    rwOpenGLColorArrayEnabled = emu_glIsEnabled(0x8076u) != 0;
    rwOpenGLTexCoordArrayEnabled = (RwBool *)(*((int (__fastcall **)(int))RwEngineInstance + 75))(32);
    _rwOpenGLSetActiveTextureUnit(0);
    *rwOpenGLTexCoordArrayEnabled = emu_glIsEnabled(0x8078u) != 0;
    _rwOpenGLSetActiveTextureUnit(0);
    v1 = openglAllInOneInitRefCount;
  }
  openglAllInOneInitRefCount = v1 + 1;
  return 1;
}

//----- (00222EE4) --------------------------------------------------------
void __fastcall _rxOpenGLAllInOnePipelineTerm(RxPipelineNode_0 *node)
{
  if ( !--openglAllInOneInitRefCount )
  {
    if ( rwOpenGLColorMaterialEnabled )
    {
      emu_glDisable(0xB57u);
      rwOpenGLColorMaterialEnabled = 0;
    }
    if ( rwOpenGLLightingEnabled )
    {
      emu_glDisable(0xB50u);
      rwOpenGLLightingEnabled = 0;
    }
    if ( *rwOpenGLTexCoordArrayEnabled )
      _rwOpenGLSetActiveTextureUnit(0);
    _rwOpenGLSetActiveTextureUnit(0);
    (*((void (__fastcall **)(RwBool *))RwEngineInstance + 76))(rwOpenGLTexCoordArrayEnabled);
    rwOpenGLTexCoordArrayEnabled = 0;
  }
}

//----- (00222F88) --------------------------------------------------------
void __fastcall RxOpenGLAllInOneSetInstanceCallBack(
        RxPipelineNode_0 *node,
        RxOpenGLAllInOneInstanceCallBack instanceCB)
{
  *((_DWORD *)node->privateData + 1) = instanceCB;
}

//----- (00222F8E) --------------------------------------------------------
RxOpenGLAllInOneInstanceCallBack __fastcall RxOpenGLAllInOneGetInstanceCallBack(RxPipelineNode_0 *node)
{
  return (RxOpenGLAllInOneInstanceCallBack)*((_DWORD *)node->privateData + 1);
}

//----- (00222F94) --------------------------------------------------------
void __fastcall RxOpenGLAllInOneSetReinstanceCallBack(
        RxPipelineNode_0 *node,
        RxOpenGLAllInOneReinstanceCallBack reinstanceCB)
{
  *((_DWORD *)node->privateData + 2) = reinstanceCB;
}

//----- (00222F9A) --------------------------------------------------------
RxOpenGLAllInOneReinstanceCallBack __fastcall RxOpenGLAllInOneGetReinstanceCallBack(RxPipelineNode_0 *node)
{
  return (RxOpenGLAllInOneReinstanceCallBack)*((_DWORD *)node->privateData + 2);
}

//----- (00222FA0) --------------------------------------------------------
void __fastcall RxOpenGLAllInOneSetLightingCallBack(
        RxPipelineNode_0 *node,
        RxOpenGLAllInOneLightingCallBack lightingCB)
{
  *((_DWORD *)node->privateData + 3) = lightingCB;
}

//----- (00222FA6) --------------------------------------------------------
RxOpenGLAllInOneLightingCallBack __fastcall RxOpenGLAllInOneGetLightingCallBack(RxPipelineNode_0 *node)
{
  return (RxOpenGLAllInOneLightingCallBack)*((_DWORD *)node->privateData + 3);
}

//----- (00222FAC) --------------------------------------------------------
void __fastcall RxOpenGLAllInOneSetRenderCallBack(RxPipelineNode_0 *node, RxOpenGLAllInOneRenderCallBack renderCB)
{
  *((_DWORD *)node->privateData + 4) = renderCB;
}

//----- (00222FB2) --------------------------------------------------------
RxOpenGLAllInOneRenderCallBack __fastcall RxOpenGLAllInOneGetRenderCallBack(RxPipelineNode_0 *node)
{
  return (RxOpenGLAllInOneRenderCallBack)*((_DWORD *)node->privateData + 4);
}

//----- (00222FB8) --------------------------------------------------------
void __fastcall RxOpenGLAllInOneSetInstanceDLandVA(RxPipelineNode_0 *node, const RwBool instanceDLandVA)
{
  *(_DWORD *)node->privateData = instanceDLandVA;
}

//----- (00222FBE) --------------------------------------------------------
RwBool __fastcall RxOpenGLAllInOneGetInstanceDLandVA(RxPipelineNode_0 *node)
{
  return *(_DWORD *)node->privateData;
}

//----- (00222FC8) --------------------------------------------------------
RwBool _rpCreatePlatformMaterialPipelines()
{
  return 1;
}

//----- (00222FD0) --------------------------------------------------------
RwBool _rpCreatePlatformWorldSectorPipelines()
{
  RxPipeline_0 *v0; // r0
  RxPipeline_0 *v1; // r4
  RxPipeline_0 *v2; // r5
  RxNodeDefinition_0 *OpenGLWorldSectorAllInOne; // r0
  RxPipeline_0 *v4; // r0

  v0 = RxPipelineCreate();
  v1 = v0;
  if ( v0 )
  {
    v0->pluginId = 2;
    v2 = RxPipelineLock(v0);
    if ( v2 )
    {
      OpenGLWorldSectorAllInOne = RxNodeDefinitionGetOpenGLWorldSectorAllInOne();
      v4 = RxLockedPipeAddFragment(v2, 0, OpenGLWorldSectorAllInOne, 0);
      if ( RxLockedPipeUnlock(v4) )
      {
        *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 88) = v1;
        RpWorldSetDefaultSectorPipeline(v1);
        return 1;
      }
    }
    _rxPipelineDestroy(v1);
  }
  return 0;
}

//----- (00223030) --------------------------------------------------------
void _rpDestroyPlatformWorldSectorPipelines()
{
  RxPipeline_0 *v0; // r0

  RpWorldSetDefaultSectorPipeline(0);
  v0 = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 88);
  if ( v0 )
  {
    _rxPipelineDestroy(v0);
    *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 88) = 0;
  }
}

//----- (00223080) --------------------------------------------------------
RwBool _rpCreatePlatformAtomicPipelines()
{
  RxPipeline_0 *v0; // r0
  RxPipeline_0 *v1; // r4
  RxPipeline_0 *v2; // r5
  RxNodeDefinition_0 *OpenGLAtomicAllInOne; // r0
  RxPipeline_0 *v4; // r0

  v0 = RxPipelineCreate();
  v1 = v0;
  if ( v0 )
  {
    v0->pluginId = 2;
    v2 = RxPipelineLock(v0);
    if ( v2 )
    {
      OpenGLAtomicAllInOne = RxNodeDefinitionGetOpenGLAtomicAllInOne();
      v4 = RxLockedPipeAddFragment(v2, 0, OpenGLAtomicAllInOne, 0);
      if ( RxLockedPipeUnlock(v4) )
      {
        *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 84) = v1;
        RpAtomicSetDefaultPipeline(v1);
        if ( _rwOpenGLLightsOpen() )
          return 1;
      }
    }
    _rxPipelineDestroy(v1);
  }
  return 0;
}

//----- (002230E8) --------------------------------------------------------
void _rpDestroyPlatformAtomicPipelines()
{
  RxPipeline_0 *v0; // r0

  RpAtomicSetDefaultPipeline(0);
  v0 = *(RxPipeline_0 **)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 84);
  if ( v0 )
  {
    _rxPipelineDestroy(v0);
    *(_DWORD *)((char *)RwEngineInstance + rxPipelineGlobalsOffset + 84) = 0;
  }
  sub_19C600();
}

//----- (00223140) --------------------------------------------------------
void *__fastcall INT123_safe_realloc(void *ptr, size_t size)
{
  if ( ptr )
    return sub_18F954(ptr, size);
  else
    return sub_194878(size);
}

//----- (0022314E) --------------------------------------------------------
unsigned __int8 *__fastcall strdup(const unsigned __int8 *src)
{
  size_t v2; // r0
  char *v3; // r0

  v2 = strlen((const char *)src);
  v3 = (char *)malloc(v2 + 1);
  if ( v3 )
    return (unsigned __int8 *)sub_19B9DC(v3, (const char *)src);
  else
    return 0;
}

//----- (0022316E) --------------------------------------------------------
int __fastcall INT123_compat_open(const unsigned __int8 *filename, int flags)
{
  return sub_18BB8C((const char *)filename, flags, 438);
}

//----- (0022317C) --------------------------------------------------------
void __fastcall INT123_dct64(double *out0, double *out1, double *samples)
{
  double *v3; // lr
  int v4; // r2
  double *v5; // r3
  double v6; // d18
  double v7; // d19
  double v8; // d20
  double v9; // d21
  double v10; // d17
  double v11; // d16
  double v12; // d20
  double v13; // d21
  double v14; // d22
  double v15; // d23
  double v16; // d24
  double v17; // d25
  double v18; // d16
  double v19; // d18
  double v20; // d16
  double v21; // d23
  double v22; // d17
  double v23; // d22
  int v24; // r3
  double *v25; // lr
  double *v26; // r2
  double v27; // d16
  double v28; // d17
  double v29; // d18
  double v30; // d19
  double v31; // d20
  double v32; // d21
  double v33; // d22
  double v34; // d23
  double v35; // d16
  double v36; // d16
  double v37; // d18
  double v38; // d19
  double v39; // d18
  double v40; // d22
  double v41; // d28
  double v42; // d22
  double v43; // d19
  double v44; // d21
  double v45; // d25
  double v46; // [sp+0h] [bp-208h]
  double v47; // [sp+8h] [bp-200h]
  double v48; // [sp+8h] [bp-200h]
  double v49; // [sp+10h] [bp-1F8h]
  double v50; // [sp+18h] [bp-1F0h]
  double v51; // [sp+18h] [bp-1F0h]
  double v52; // [sp+20h] [bp-1E8h]
  double v53; // [sp+20h] [bp-1E8h]
  double v54; // [sp+28h] [bp-1E0h]
  double v55; // [sp+28h] [bp-1E0h]
  double v56; // [sp+30h] [bp-1D8h]
  double v57; // [sp+30h] [bp-1D8h]
  double v58; // [sp+38h] [bp-1D0h]
  double v59; // [sp+38h] [bp-1D0h]
  double v60; // [sp+40h] [bp-1C8h]
  double v61; // [sp+48h] [bp-1C0h]
  double v62; // [sp+48h] [bp-1C0h]
  double v63; // [sp+50h] [bp-1B8h]
  double v64; // [sp+58h] [bp-1B0h]
  double v65; // [sp+58h] [bp-1B0h]
  double v66; // [sp+60h] [bp-1A8h]
  double v67; // [sp+60h] [bp-1A8h]
  double v68; // [sp+68h] [bp-1A0h]
  double v69; // [sp+68h] [bp-1A0h]
  double v70; // [sp+70h] [bp-198h]
  double v71; // [sp+70h] [bp-198h]
  double v72; // [sp+78h] [bp-190h]
  double v73; // [sp+78h] [bp-190h]
  double v74; // [sp+80h] [bp-188h]
  double v75; // [sp+88h] [bp-180h]
  double v76; // [sp+88h] [bp-180h]
  double v77; // [sp+90h] [bp-178h]
  double v78; // [sp+90h] [bp-178h]
  double v79; // [sp+98h] [bp-170h]
  double v80; // [sp+98h] [bp-170h]
  double v81; // [sp+A0h] [bp-168h]
  double v82; // [sp+A0h] [bp-168h]
  double v83; // [sp+A8h] [bp-160h]
  double v84; // [sp+A8h] [bp-160h]
  double v85; // [sp+A8h] [bp-160h]
  double v86; // [sp+B0h] [bp-158h]
  double v87; // [sp+B0h] [bp-158h]
  double v88; // [sp+B0h] [bp-158h]
  double v89; // [sp+B8h] [bp-150h]
  double v90; // [sp+B8h] [bp-150h]
  double v91; // [sp+C0h] [bp-148h]
  double v92; // [sp+C0h] [bp-148h]
  double v93; // [sp+C8h] [bp-140h]
  double v94; // [sp+C8h] [bp-140h]
  double v95; // [sp+D0h] [bp-138h]
  double v96; // [sp+D8h] [bp-130h]
  double v97; // [sp+D8h] [bp-130h]
  double v98; // [sp+E0h] [bp-128h]
  double v99; // [sp+E8h] [bp-120h]
  double v100; // [sp+E8h] [bp-120h]
  double v101; // [sp+E8h] [bp-120h]
  double v102; // [sp+F0h] [bp-118h]
  double v103; // [sp+F8h] [bp-110h]
  double v104; // [sp+F8h] [bp-110h]
  double v105; // [sp+100h] [bp-108h]
  double v106; // [sp+108h] [bp-100h]
  double v107; // [sp+110h] [bp-F8h]
  double v108; // [sp+118h] [bp-F0h]
  double v109; // [sp+120h] [bp-E8h]
  double v110; // [sp+128h] [bp-E0h]
  double v111; // [sp+130h] [bp-D8h]
  double v112; // [sp+138h] [bp-D0h]
  double v113; // [sp+140h] [bp-C8h]
  double v114; // [sp+148h] [bp-C0h]
  double v115; // [sp+150h] [bp-B8h]
  double v116; // [sp+158h] [bp-B0h]
  double v117; // [sp+160h] [bp-A8h]
  double v118; // [sp+168h] [bp-A0h]
  double v119; // [sp+170h] [bp-98h]
  double v120; // [sp+178h] [bp-90h]
  double v121; // [sp+180h] [bp-88h]
  double v122; // [sp+188h] [bp-80h]
  double v123; // [sp+190h] [bp-78h]
  double v124; // [sp+198h] [bp-70h]
  double v125; // [sp+1A0h] [bp-68h]
  double v126; // [sp+1A8h] [bp-60h]
  double v127; // [sp+1B0h] [bp-58h]
  double v128; // [sp+1B8h] [bp-50h]
  double v129; // [sp+1C0h] [bp-48h]
  double v130; // [sp+1C8h] [bp-40h]
  double v131; // [sp+1D0h] [bp-38h]
  double v132; // [sp+1D8h] [bp-30h]
  double v133; // [sp+1E0h] [bp-28h]
  double v134; // [sp+1E8h] [bp-20h]
  double v135; // [sp+1F0h] [bp-18h]
  double v136; // [sp+1F8h] [bp-10h]

  v46 = *samples + samples[31];
  v47 = samples[1] + samples[30];
  v49 = samples[2] + samples[29];
  v50 = samples[3] + samples[28];
  v52 = samples[4] + samples[27];
  v54 = samples[5] + samples[26];
  v56 = samples[6] + samples[25];
  v58 = samples[7] + samples[24];
  v3 = INT123_pnts[2];
  v60 = samples[8] + samples[23];
  v61 = samples[9] + samples[22];
  v63 = samples[10] + samples[21];
  v64 = samples[11] + samples[20];
  v66 = samples[12] + samples[19];
  v68 = samples[13] + samples[18];
  v70 = samples[14] + samples[17];
  v72 = samples[15] + samples[16];
  v74 = (samples[15] - samples[16]) * INT123_pnts[0][15];
  v75 = (samples[14] - samples[17]) * INT123_pnts[0][14];
  v77 = (samples[13] - samples[18]) * INT123_pnts[0][13];
  v79 = (samples[12] - samples[19]) * INT123_pnts[0][12];
  v81 = (samples[11] - samples[20]) * INT123_pnts[0][11];
  v83 = (samples[10] - samples[21]) * INT123_pnts[0][10];
  v86 = (samples[9] - samples[22]) * INT123_pnts[0][9];
  v89 = (samples[8] - samples[23]) * INT123_pnts[0][8];
  v91 = (samples[7] - samples[24]) * INT123_pnts[0][7];
  v93 = (samples[6] - samples[25]) * INT123_pnts[0][6];
  v95 = (samples[5] - samples[26]) * INT123_pnts[0][5];
  v96 = (samples[4] - samples[27]) * INT123_pnts[0][4];
  v98 = (samples[3] - samples[28]) * INT123_pnts[0][3];
  v99 = (samples[2] - samples[29]) * INT123_pnts[0][2];
  v102 = (samples[1] - samples[30]) * INT123_pnts[0][1];
  v103 = (*samples - samples[31]) * *INT123_pnts[0];
  v105 = v46 + v72;
  v106 = v47 + v70;
  v107 = v49 + v68;
  v108 = v50 + v66;
  v109 = v52 + v64;
  v110 = v54 + v63;
  v111 = v56 + v61;
  v112 = v58 + v60;
  v113 = (v58 - v60) * INT123_pnts[1][7];
  v114 = (v56 - v61) * INT123_pnts[1][6];
  v115 = (v54 - v63) * INT123_pnts[1][5];
  v116 = (v52 - v64) * INT123_pnts[1][4];
  v117 = (v50 - v66) * INT123_pnts[1][3];
  v118 = (v49 - v68) * INT123_pnts[1][2];
  v119 = (v47 - v70) * INT123_pnts[1][1];
  v120 = (v46 - v72) * *INT123_pnts[1];
  v121 = v74 + v103;
  v122 = v75 + v102;
  v123 = v77 + v99;
  v124 = v79 + v98;
  v125 = v81 + v96;
  v126 = v83 + v95;
  v127 = v86 + v93;
  v128 = v89 + v91;
  v129 = (v91 - v89) * INT123_pnts[1][7];
  v130 = (v93 - v86) * INT123_pnts[1][6];
  v131 = (v95 - v83) * INT123_pnts[1][5];
  v132 = (v96 - v81) * INT123_pnts[1][4];
  v133 = (v98 - v79) * INT123_pnts[1][3];
  v134 = (v99 - v77) * INT123_pnts[1][2];
  v135 = (v102 - v75) * INT123_pnts[1][1];
  v4 = 0;
  v136 = (v103 - v74) * *INT123_pnts[1];
  do
  {
    v5 = (double *)&INT123_pnts[v4];
    v4 += 32;
    v6 = v5[34];
    v7 = v5[35];
    v8 = v5[36];
    v9 = v5[37];
    v10 = v5[33] + v5[38];
    *v5 = v5[32] + v5[39];
    v5[1] = v10;
    v5[2] = v6 + v9;
    v5[3] = v7 + v8;
    v5[4] = (v7 - v8) * v3[3];
    v5[5] = (v6 - v9) * v3[2];
    v11 = v5[32] - v5[39];
    v12 = v5[40];
    v13 = v5[41];
    v14 = v5[42];
    v15 = v5[43];
    v16 = v5[44];
    v17 = v5[45];
    v5[6] = (v5[33] - v5[38]) * v3[1];
    v5[7] = v11 * *v3;
    v18 = v13 + v5[46];
    v5[8] = v12 + v5[47];
    v5[9] = v18;
    v5[10] = v14 + v17;
    v5[11] = v15 + v16;
    v19 = v5[45] - v5[42];
    v20 = v5[40];
    v21 = v5[47];
    v22 = v5[41];
    v23 = v5[46];
    v5[12] = (v5[44] - v5[43]) * v3[3];
    v5[13] = v19 * v3[2];
    v5[14] = (v23 - v22) * v3[1];
    v5[15] = (v21 - v20) * *v3;
  }
  while ( v4 != 64 );
  v24 = 0;
  v25 = INT123_pnts[3];
  do
  {
    v26 = (double *)&INT123_pnts[v24];
    v24 += 16;
    v27 = *v26;
    v28 = v26[1];
    v29 = v26[2];
    v30 = v26[3];
    v31 = v26[4];
    v32 = v26[5];
    v33 = v26[6];
    v34 = v26[7];
    v26[32] = *v26 + v30;
    v26[33] = v28 + v29;
    v26[34] = (v28 - v29) * v25[1];
    v35 = (v27 - v30) * *v25;
    v26[36] = v31 + v34;
    v26[35] = v35;
    v26[37] = v32 + v33;
    v36 = v26[7] - v26[4];
    v26[38] = (v26[6] - v26[5]) * v25[1];
    v26[39] = v36 * *v25;
  }
  while ( v24 != 64 );
  v48 = (v105 - v106) * *INT123_pnts[4];
  v51 = (v108 - v107) * *INT123_pnts[4];
  v55 = (v109 - v110) * *INT123_pnts[4];
  v59 = (v112 - v111) * *INT123_pnts[4];
  v62 = (v113 - v114) * *INT123_pnts[4];
  v65 = (v116 - v115) * *INT123_pnts[4];
  v69 = (v117 - v118) * *INT123_pnts[4];
  v73 = (v120 - v119) * *INT123_pnts[4];
  v76 = (v121 - v122) * *INT123_pnts[4];
  v80 = (v124 - v123) * *INT123_pnts[4];
  v84 = (v125 - v126) * *INT123_pnts[4];
  v90 = (v128 - v127) * *INT123_pnts[4];
  v94 = (v129 - v130) * *INT123_pnts[4];
  v97 = (v132 - v131) * *INT123_pnts[4];
  v100 = (v133 - v134) * *INT123_pnts[4];
  v104 = (v136 - v135) * *INT123_pnts[4];
  v71 = v73 + v119 + v120;
  v78 = v80 + v123 + v124;
  v87 = v90 + v127 + v128;
  v37 = v59 + v111 + v112;
  v53 = v37 + v109 + v110;
  v38 = v104 + v135 + v136;
  v57 = v55 + v37;
  v82 = v87 + v125 + v126;
  v39 = v71 + v117 + v118;
  v88 = v84 + v87;
  v85 = v84 + v90;
  v40 = v65 + v115 + v116;
  v41 = v40 + v69 + v71;
  v67 = v40 + v39;
  v42 = v38 + v133 + v134;
  v43 = v100 + v38;
  v92 = v42 + v129 + v130;
  v44 = v97 + v131 + v132;
  v45 = v94 + v100 + v104;
  v101 = v100 + v104 + v97;
  out0[256] = v105 + v106;
  out0[224] = v39 + v113 + v114;
  out0[208] = v92 + v82;
  out0[240] = v121 + v122 + v92;
  out0[176] = v82 + v44 + v42;
  out0[160] = v67;
  out0[192] = v53;
  out0[144] = v44 + v42 + v78;
  out0[112] = v78 + v44 + v43;
  out0[96] = v41;
  out0[128] = v51 + v107 + v108;
  out0[80] = v44 + v43 + v88;
  out0[48] = v88 + v43 + v94;
  out0[32] = v69 + v71 + v62;
  out0[64] = v57;
  out0[16] = v43 + v94 + v76;
  *out0 = v48;
  out1[16] = v76 + v45;
  *out1 = v48;
  out1[32] = v62 + v69 + v73;
  out1[48] = v45 + v85;
  out1[80] = v85 + v101;
  out1[64] = v55 + v59;
  out1[96] = v69 + v73 + v65;
  out1[112] = v101 + v80;
  out1[128] = v51;
  out1[144] = v80 + v97 + v104;
  out1[160] = v65 + v73;
  out1[176] = v97 + v104 + v90;
  out1[192] = v59;
  out1[208] = v90 + v104;
  out1[240] = v104;
  out1[224] = v73;
}

//----- (00223D1C) --------------------------------------------------------
void __fastcall INT123_do_equalizer(double *bandPtr, int channel, double (*equalizer)[32])
{
  double *v3; // r1
  int i; // r2
  double v5; // d16
  double *v6; // r3

  v3 = &(*equalizer)[32 * channel];
  for ( i = 0; i != 32; ++i )
  {
    v5 = v3[i];
    v6 = &bandPtr[i];
    *v6 = *v6 * v5;
  }
}

//----- (00223D40) --------------------------------------------------------
int __fastcall mpg123_feature(const mpg123_feature_set key)
{
  if ( (unsigned int)key <= MPG123_FEATURE_TIMEOUT_READ )
    return dword_223D50[key];
  else
    return 0;
}
// 223D50: using guessed type int dword_223D50[];

//----- (00223D88) --------------------------------------------------------
void __fastcall mpg123_rates(const int **list, size_t *number)
{
  if ( list )
    *list = my_rates;
  if ( number )
    *number = 9;
}

//----- (00223DA0) --------------------------------------------------------
void __fastcall mpg123_encodings(const int **list, size_t *number)
{
  if ( list )
    *list = good_encodings;
  if ( number )
    *number = 11;
}

//----- (00223DB8) --------------------------------------------------------
int __fastcall mpg123_encsize(int encoding)
{
  int result; // r0

  if ( encoding << 28 )
    return 1;
  if ( (encoding & 0x40) != 0 )
    return 2;
  if ( (encoding & 0x4000) != 0 )
    return 3;
  result = 4;
  if ( encoding != 512 && (encoding & 0x100) == 0 )
  {
    result = 0;
    if ( encoding == 1024 )
      return 8;
  }
  return result;
}

//----- (00223DF0) --------------------------------------------------------
int __fastcall INT123_frame_output_format(mpg123_handle *fr)
{
  int stereo; // r0
  unsigned int flags; // r4
  int *p_flags; // r9
  int v5; // r1
  int v6; // r11
  unsigned int v7; // r10
  int force_rate; // r3
  int v9; // r2
  int v10; // r4
  int v11; // r0
  _BYTE *v12; // r2
  int v13; // r5
  bool v14; // cc
  int *v15; // r12
  int v16; // r2
  _BYTE *v17; // r2
  int v18; // r6
  int v19; // r0
  int v20; // r2
  _BYTE *v21; // r2
  int v22; // r1
  _BYTE *v23; // r0
  int rate; // r5
  int *p_channels; // r3
  int channels; // r0
  bool v28; // zf
  audioformat *p_af; // r6
  int encoding; // r3
  int v31; // r0
  audioformat nf; // [sp+14h] [bp-2Ch] BYREF

  stereo = fr->stereo;
  nf.channels = stereo;
  flags = fr->p.flags;
  p_flags = &fr->p.flags;
  v5 = (flags >> 1) & 8;
  v6 = ((unsigned __int16)(flags & 0x400) >> 8) ^ 0xC;
  v7 = v5;
  if ( (flags & 0x400) != 0 )
    v7 = 6;
  if ( (flags & 7) != 0 )
    stereo = 1;
  if ( (flags & 8) != 0 )
    stereo = 2;
  if ( (flags & 0xF) != 0 )
    nf.channels = stereo;
  force_rate = fr->p.force_rate;
  if ( force_rate )
  {
    nf.rate = fr->p.force_rate;
    if ( force_rate <= 22049 )
    {
      if ( force_rate > 11999 )
      {
        if ( force_rate == 12000 )
        {
          v9 = 2;
          if ( v7 <= 1 )
            goto LABEL_49;
        }
        else
        {
          if ( force_rate != 16000 )
            goto LABEL_48;
          v9 = 3;
          if ( v7 <= 1 )
            goto LABEL_49;
        }
      }
      else if ( force_rate == 8000 )
      {
        v9 = 0;
        if ( v7 <= 1 )
          goto LABEL_49;
      }
      else
      {
        if ( force_rate != 11025 )
          goto LABEL_48;
        v9 = 1;
        if ( v7 <= 1 )
          goto LABEL_49;
      }
    }
    else if ( force_rate < 32000 )
    {
      if ( force_rate == 22050 )
      {
        v9 = 4;
        if ( v7 <= 1 )
          goto LABEL_49;
      }
      else
      {
        if ( force_rate != 24000 )
          goto LABEL_48;
        v9 = 5;
        if ( v7 <= 1 )
          goto LABEL_49;
      }
    }
    else
    {
      switch ( force_rate )
      {
        case 32000:
          v9 = 6;
          if ( v7 <= 1 )
            goto LABEL_49;
          break;
        case 44100:
          v9 = 7;
          if ( v7 <= 1 )
            goto LABEL_49;
          break;
        case 48000:
          v9 = 8;
          if ( v7 > 1 )
            break;
LABEL_49:
          v12 = (char *)&fr->rd + 120 * stereo + 12 * v9 + v5;
          v13 = (flags >> 1) & 8;
          while ( !*v12 )
          {
            ++v12;
            v14 = v13++ < 1;
            if ( !v14 )
              goto LABEL_52;
          }
          goto LABEL_171;
        default:
LABEL_48:
          v9 = 9;
          if ( v7 > 1 )
            break;
          goto LABEL_49;
      }
    }
LABEL_52:
    v13 = v7;
    if ( v7 <= 2 )
      v13 = 2;
    if ( force_rate <= 22049 )
    {
      if ( force_rate > 11999 )
      {
        if ( force_rate == 12000 )
        {
          v15 = &fr->p.flags;
          v16 = 2;
          if ( v13 < v6 )
            goto LABEL_86;
        }
        else
        {
          if ( force_rate != 16000 )
            goto LABEL_85;
          v15 = &fr->p.flags;
          v16 = 3;
          if ( v13 < v6 )
            goto LABEL_86;
        }
      }
      else if ( force_rate == 8000 )
      {
        v15 = &fr->p.flags;
        v16 = 0;
        if ( v13 < v6 )
          goto LABEL_86;
      }
      else
      {
        if ( force_rate != 11025 )
          goto LABEL_85;
        v15 = &fr->p.flags;
        v16 = 1;
        if ( v13 < v6 )
          goto LABEL_86;
      }
    }
    else if ( force_rate < 32000 )
    {
      if ( force_rate == 22050 )
      {
        v15 = &fr->p.flags;
        v16 = 4;
        if ( v13 < v6 )
          goto LABEL_86;
      }
      else
      {
        if ( force_rate != 24000 )
          goto LABEL_85;
        v15 = &fr->p.flags;
        v16 = 5;
        if ( v13 < v6 )
          goto LABEL_86;
      }
    }
    else
    {
      switch ( force_rate )
      {
        case 32000:
          v15 = &fr->p.flags;
          v16 = 6;
          if ( v13 < v6 )
            goto LABEL_86;
          break;
        case 44100:
          v15 = &fr->p.flags;
          v16 = 7;
          if ( v13 < v6 )
            goto LABEL_86;
          break;
        case 48000:
          v15 = &fr->p.flags;
          v16 = 8;
          if ( v13 >= v6 )
            break;
LABEL_86:
          v17 = (char *)&fr->rd + 120 * stereo + 12 * v16 + v13;
          v18 = v13;
          while ( !*v17 )
          {
            ++v18;
            ++v17;
            if ( v18 >= v6 )
              goto LABEL_89;
          }
          p_flags = v15;
          v19 = my_encodings[v18];
          goto LABEL_172;
        default:
LABEL_85:
          v15 = &fr->p.flags;
          v16 = 9;
          if ( v13 >= v6 )
            break;
          goto LABEL_86;
      }
    }
LABEL_89:
    if ( stereo == 1 )
    {
      p_flags = v15;
      if ( (flags & 7) != 0 )
      {
        stereo = 1;
        goto LABEL_99;
      }
      stereo = 2;
    }
    else
    {
      p_flags = v15;
      if ( stereo != 2 )
        goto LABEL_99;
      if ( (flags & 8) != 0 )
      {
        stereo = 2;
        goto LABEL_99;
      }
      stereo = 1;
    }
    nf.channels = stereo;
LABEL_99:
    if ( force_rate <= 22049 )
    {
      if ( force_rate > 11999 )
      {
        if ( force_rate == 12000 )
        {
          v20 = 2;
          if ( v7 <= 1 )
            goto LABEL_130;
        }
        else
        {
          if ( force_rate != 16000 )
            goto LABEL_129;
          v20 = 3;
          if ( v7 <= 1 )
            goto LABEL_130;
        }
      }
      else if ( force_rate == 8000 )
      {
        v20 = 0;
        if ( v7 <= 1 )
          goto LABEL_130;
      }
      else
      {
        if ( force_rate != 11025 )
          goto LABEL_129;
        v20 = 1;
        if ( v7 <= 1 )
          goto LABEL_130;
      }
    }
    else if ( force_rate < 32000 )
    {
      if ( force_rate == 22050 )
      {
        v20 = 4;
        if ( v7 <= 1 )
          goto LABEL_130;
      }
      else
      {
        if ( force_rate != 24000 )
          goto LABEL_129;
        v20 = 5;
        if ( v7 <= 1 )
          goto LABEL_130;
      }
    }
    else
    {
      switch ( force_rate )
      {
        case 32000:
          v20 = 6;
          if ( v7 <= 1 )
            goto LABEL_130;
          break;
        case 44100:
          v20 = 7;
          if ( v7 <= 1 )
            goto LABEL_130;
          break;
        case 48000:
          v20 = 8;
          if ( v7 > 1 )
            break;
LABEL_130:
          v21 = (char *)&fr->rd + 120 * stereo + 12 * v20 + v5;
          while ( !*v21 )
          {
            ++v21;
            v14 = v5++ < 1;
            if ( !v14 )
              goto LABEL_133;
          }
          v19 = my_encodings[v5];
          goto LABEL_172;
        default:
LABEL_129:
          v20 = 9;
          if ( v7 > 1 )
            break;
          goto LABEL_130;
      }
    }
LABEL_133:
    if ( force_rate <= 22049 )
    {
      if ( force_rate > 11999 )
      {
        if ( force_rate == 12000 )
        {
          v22 = 2;
          if ( v13 >= v6 )
            goto LABEL_168;
          goto LABEL_165;
        }
        if ( force_rate == 16000 )
        {
          v22 = 3;
          if ( v13 >= v6 )
            goto LABEL_168;
          goto LABEL_165;
        }
      }
      else
      {
        if ( force_rate == 8000 )
        {
          v22 = 0;
          if ( v13 >= v6 )
            goto LABEL_168;
          goto LABEL_165;
        }
        if ( force_rate == 11025 )
        {
          v22 = 1;
          if ( v13 >= v6 )
            goto LABEL_168;
          goto LABEL_165;
        }
      }
    }
    else
    {
      if ( force_rate >= 32000 )
      {
        switch ( force_rate )
        {
          case 32000:
            v22 = 6;
            if ( v13 >= v6 )
              goto LABEL_168;
            break;
          case 44100:
            v22 = 7;
            if ( v13 >= v6 )
            {
LABEL_168:
              if ( (flags & 0x20) == 0 )
                fprintf(
                  (FILE *)stderr,
                  "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/format.c:%i] error: Unable to set up output"
                  " format! Constraints: %s%s%liHz.\n",
                  240);
LABEL_170:
              fr->err = 1;
              return -1;
            }
            break;
          case 48000:
            v22 = 8;
            if ( v13 >= v6 )
              goto LABEL_168;
            break;
          default:
            goto LABEL_164;
        }
LABEL_165:
        v23 = (char *)&fr->rd + 120 * stereo + 12 * v22 + v13;
        while ( !*v23 )
        {
          ++v13;
          ++v23;
          if ( v13 >= v6 )
            goto LABEL_168;
        }
LABEL_171:
        v19 = my_encodings[v13];
LABEL_172:
        nf.encoding = v19;
        goto LABEL_173;
      }
      if ( force_rate == 22050 )
      {
        v22 = 4;
        if ( v13 >= v6 )
          goto LABEL_168;
        goto LABEL_165;
      }
      if ( force_rate == 24000 )
      {
        v22 = 5;
        if ( v13 >= v6 )
          goto LABEL_168;
        goto LABEL_165;
      }
    }
LABEL_164:
    v22 = 9;
    if ( v13 >= v6 )
      goto LABEL_168;
    goto LABEL_165;
  }
  v10 = 2;
  if ( !freq_fit(fr, &nf, v7, 2) )
  {
    if ( v7 > 2 )
      v10 = v7;
    if ( !freq_fit(fr, &nf, v10, v6) )
    {
      if ( nf.channels == 1 )
      {
        if ( !(*(unsigned __int8 *)p_flags << 29) )
        {
          v11 = 2;
          goto LABEL_192;
        }
      }
      else if ( nf.channels == 2 && (*(_BYTE *)p_flags & 8) == 0 )
      {
        v11 = 1;
LABEL_192:
        nf.channels = v11;
      }
      if ( !freq_fit(fr, &nf, v7, 2) && !freq_fit(fr, &nf, v10, v6) )
      {
        if ( (*p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/format.c:%i] error: Unable to set up output forma"
            "t! Constraints: %s%s%li, %li or %liHz.\n",
            265);
        goto LABEL_170;
      }
    }
  }
LABEL_173:
  rate = fr->af.rate;
  p_channels = &fr->af.channels;
  channels = nf.channels;
  v28 = nf.rate == rate;
  p_af = &fr->af;
  if ( nf.rate == rate )
    v28 = nf.channels == *p_channels;
  if ( v28 && nf.encoding == p_af->encoding )
    return 0;
  fr->af.rate = nf.rate;
  *p_channels = channels;
  encoding = nf.encoding;
  p_af->encoding = nf.encoding;
  if ( (encoding & 0xF) != 0 )
  {
    v31 = 1;
  }
  else if ( (encoding & 0x40) != 0 )
  {
    v31 = 2;
  }
  else if ( (encoding & 0x4000) != 0 )
  {
    v31 = 3;
  }
  else
  {
    v31 = 4;
    if ( encoding != 512 && (encoding & 0x100) == 0 )
    {
      if ( encoding != 1024 )
      {
        fr->af.encsize = 0;
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/format.c:%i] error: Some unknown encoding??? (%i)\n",
            289);
        goto LABEL_170;
      }
      v31 = 8;
    }
  }
  fr->af.encsize = v31;
  return 1;
}

//----- (00224424) --------------------------------------------------------
int __fastcall freq_fit(mpg123_handle *fr, audioformat *nf, int f0, int f2)
{
  int v4; // r9
  int channels; // lr
  int v6; // r6
  int force_rate; // r4
  _BYTE *v8; // r6
  int v9; // r4
  int v10; // r6
  int v11; // r6
  int v12; // r4
  _BYTE *v13; // r6
  int v14; // r5
  int v15; // r5
  int v16; // r4
  _BYTE *v17; // r5
  int v18; // r12
  int v20; // r4
  int v21; // r8
  int v22; // r6
  int v23; // lr
  char *v24; // r12
  char *v25; // r0
  char *v26; // r5
  int v27; // r4
  int v28; // t1
  char *v29; // r5
  char *v30; // r0
  int v31; // r6
  int v32; // t1
  int v33; // r0
  int v34; // r2

  v4 = freqs[fr->sampling_frequency] >> fr->p.down_sample;
  nf->rate = v4;
  channels = nf->channels;
  if ( v4 <= 22049 )
  {
    if ( v4 > 11999 )
    {
      if ( v4 == 12000 )
      {
        v6 = 2;
        if ( f0 < f2 )
          goto LABEL_34;
        goto LABEL_37;
      }
      if ( v4 == 16000 )
      {
        v6 = 3;
        if ( f0 < f2 )
          goto LABEL_34;
        goto LABEL_37;
      }
    }
    else
    {
      if ( v4 == 8000 )
      {
        v6 = 0;
        if ( f0 < f2 )
          goto LABEL_34;
        goto LABEL_37;
      }
      if ( v4 == 11025 )
      {
        v6 = 1;
        if ( f0 < f2 )
          goto LABEL_34;
        goto LABEL_37;
      }
    }
  }
  else if ( v4 < 32000 )
  {
    if ( v4 == 22050 )
    {
      v6 = 4;
      if ( f0 < f2 )
        goto LABEL_34;
      goto LABEL_37;
    }
    if ( v4 == 24000 )
    {
      v6 = 5;
      if ( f0 < f2 )
        goto LABEL_34;
      goto LABEL_37;
    }
  }
  else
  {
    switch ( v4 )
    {
      case 32000:
        v6 = 6;
        if ( f0 < f2 )
          goto LABEL_34;
        goto LABEL_37;
      case 44100:
        v6 = 7;
        if ( f0 < f2 )
          goto LABEL_34;
        goto LABEL_37;
      case 48000:
        v6 = 8;
        if ( f0 >= f2 )
          goto LABEL_37;
LABEL_34:
        v8 = (char *)&fr->rd + 120 * channels + 12 * v6 + f0;
        v9 = f0;
        while ( !*v8 )
        {
          ++v9;
          ++v8;
          if ( v9 >= f2 )
            goto LABEL_37;
        }
        goto LABEL_114;
    }
  }
  force_rate = fr->p.force_rate;
  if ( force_rate )
  {
    if ( force_rate == v4 )
    {
      v6 = 9;
      if ( f0 < f2 )
        goto LABEL_34;
    }
  }
LABEL_37:
  v10 = v4 >> 1;
  nf->rate = v4 >> 1;
  if ( v4 >> 1 <= 22049 )
  {
    if ( v10 > 11999 )
    {
      if ( v10 == 12000 )
      {
        v11 = 2;
        if ( f0 < f2 )
          goto LABEL_71;
        goto LABEL_74;
      }
      if ( v10 == 16000 )
      {
        v11 = 3;
        if ( f0 < f2 )
          goto LABEL_71;
        goto LABEL_74;
      }
    }
    else
    {
      if ( v10 == 8000 )
      {
        v11 = 0;
        if ( f0 < f2 )
          goto LABEL_71;
        goto LABEL_74;
      }
      if ( v10 == 11025 )
      {
        v11 = 1;
        if ( f0 < f2 )
          goto LABEL_71;
        goto LABEL_74;
      }
    }
  }
  else if ( v10 < 32000 )
  {
    if ( v10 == 22050 )
    {
      v11 = 4;
      if ( f0 < f2 )
        goto LABEL_71;
      goto LABEL_74;
    }
    if ( v10 == 24000 )
    {
      v11 = 5;
      if ( f0 < f2 )
        goto LABEL_71;
      goto LABEL_74;
    }
  }
  else
  {
    switch ( v10 )
    {
      case 32000:
        v11 = 6;
        if ( f0 < f2 )
          goto LABEL_71;
        goto LABEL_74;
      case 44100:
        v11 = 7;
        if ( f0 < f2 )
          goto LABEL_71;
        goto LABEL_74;
      case 48000:
        v11 = 8;
        if ( f0 >= f2 )
          goto LABEL_74;
LABEL_71:
        v13 = (char *)&fr->rd + 120 * channels + 12 * v11 + f0;
        v9 = f0;
        while ( !*v13 )
        {
          ++v9;
          ++v13;
          if ( v9 >= f2 )
            goto LABEL_74;
        }
        goto LABEL_114;
    }
  }
  v12 = fr->p.force_rate;
  if ( v12 )
  {
    if ( v12 == v10 )
    {
      v11 = 9;
      if ( f0 < f2 )
        goto LABEL_71;
    }
  }
LABEL_74:
  v14 = v4 >> 2;
  nf->rate = v4 >> 2;
  if ( v4 >> 2 <= 22049 )
  {
    if ( v14 > 11999 )
    {
      if ( v14 == 12000 )
      {
        v15 = 2;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
      }
      if ( v14 == 16000 )
      {
        v15 = 3;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
      }
    }
    else
    {
      if ( v14 == 8000 )
      {
        v15 = 0;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
      }
      if ( v14 == 11025 )
      {
        v15 = 1;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
      }
    }
  }
  else if ( v14 < 32000 )
  {
    if ( v14 == 22050 )
    {
      v15 = 4;
      if ( f0 >= f2 )
        goto LABEL_111;
      goto LABEL_108;
    }
    if ( v14 == 24000 )
    {
      v15 = 5;
      if ( f0 >= f2 )
        goto LABEL_111;
      goto LABEL_108;
    }
  }
  else
  {
    switch ( v14 )
    {
      case 32000:
        v15 = 6;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
      case 44100:
        v15 = 7;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
      case 48000:
        v15 = 8;
        if ( f0 >= f2 )
          goto LABEL_111;
        goto LABEL_108;
    }
  }
  v16 = fr->p.force_rate;
  if ( v16 )
  {
    if ( v16 == v14 )
    {
      v15 = 9;
      if ( f0 < f2 )
      {
LABEL_108:
        v17 = (char *)&fr->rd + 120 * channels + 12 * v15 + f0;
        v9 = f0;
        while ( !*v17 )
        {
          ++v9;
          ++v17;
          if ( v9 >= f2 )
            goto LABEL_111;
        }
LABEL_114:
        v18 = 1;
        nf->encoding = my_encodings[v9];
        return v18;
      }
    }
  }
LABEL_111:
  if ( fr->p.force_rate || fr->p.down_sample )
    return 0;
  v18 = 0;
  v20 = freqs[fr->sampling_frequency];
  if ( v20 <= 22049 )
  {
    if ( v20 > 11999 )
    {
      if ( v20 == 12000 )
      {
        v21 = 2;
        if ( f0 < f2 )
          goto LABEL_145;
        return 0;
      }
      if ( v20 != 16000 )
        return v18;
      v21 = 3;
      if ( f0 >= f2 )
        return 0;
    }
    else
    {
      if ( v20 == 8000 )
      {
        v21 = 0;
        if ( f0 < f2 )
          goto LABEL_145;
        return 0;
      }
      if ( v20 != 11025 )
        return v18;
      v21 = 1;
      if ( f0 >= f2 )
        return 0;
    }
  }
  else
  {
    if ( v20 >= 32000 )
    {
      switch ( v20 )
      {
        case 32000:
          v21 = 6;
          if ( f0 < f2 )
            goto LABEL_145;
          break;
        case 44100:
          v21 = 7;
          if ( f0 < f2 )
            goto LABEL_145;
          break;
        case 48000:
          v21 = 8;
          if ( f0 >= f2 )
            return 0;
          goto LABEL_145;
        default:
          return v18;
      }
      return 0;
    }
    if ( v20 == 22050 )
    {
      v21 = 4;
      if ( f0 < f2 )
        goto LABEL_145;
      return 0;
    }
    if ( v20 != 24000 )
      return v18;
    v21 = 5;
    if ( f0 >= f2 )
      return 0;
  }
LABEL_145:
  v22 = 15 * channels;
  v23 = f0;
  v24 = (char *)fr + 12 * v21 + 8 * v22 + f0;
  v25 = v24 + 45804;
  while ( 2 )
  {
    v26 = v25;
    v27 = v21;
    while ( v27 <= 7 )
    {
      v28 = (unsigned __int8)*v26;
      v26 += 12;
      ++v27;
      if ( v28 )
      {
        v33 = my_rates[v27];
        v34 = my_encodings[v23];
LABEL_159:
        nf->encoding = v34;
        v18 = 1;
        nf->rate = v33;
        return v18;
      }
    }
    ++v23;
    ++v25;
    if ( v23 < f2 )
      continue;
    break;
  }
  if ( f0 >= f2 )
    return 0;
  v29 = v24 + 45780;
  v18 = 0;
  do
  {
    v30 = v29;
    v31 = v21;
    while ( v31 >= 1 )
    {
      v32 = (unsigned __int8)*v30;
      v30 -= 12;
      --v31;
      if ( v32 )
      {
        v33 = my_rates[v31];
        v34 = my_encodings[f0];
        goto LABEL_159;
      }
    }
    ++f0;
    ++v29;
  }
  while ( f0 < f2 );
  return v18;
}

//----- (00224890) --------------------------------------------------------
int __fastcall INT123_frame_freq(mpg123_handle *fr)
{
  return freqs[fr->sampling_frequency];
}

//----- (002248A4) --------------------------------------------------------
int __fastcall mpg123_format_none(mpg123_handle *mh)
{
  if ( !mh )
    return -1;
  if ( (mh->p.flags & 0x20) == 0 && mh->p.verbose >= 3 )
    fwrite("Note: Disabling all formats.\n", 0x1Du, 1u, (FILE *)stderr);
  memset(mh->p.audio_caps, 0, sizeof(mh->p.audio_caps));
  return 0;
}

//----- (002248F4) --------------------------------------------------------
int __fastcall mpg123_fmt_none(mpg123_pars *mp)
{
  if ( !mp )
    return 25;
  if ( (mp->flags & 0x20) == 0 && mp->verbose >= 3 )
    fwrite("Note: Disabling all formats.\n", 0x1Du, 1u, (FILE *)stderr);
  memset(mp->audio_caps, 0, sizeof(mp->audio_caps));
  return 0;
}

//----- (00224938) --------------------------------------------------------
int __fastcall mpg123_format_all(mpg123_handle *mh)
{
  int v2; // r0

  if ( !mh )
    return -1;
  v2 = j_mpg123_fmt_all(&mh->p);
  if ( v2 )
  {
    mh->err = v2;
    return -1;
  }
  return 0;
}

//----- (0022495C) --------------------------------------------------------
int __fastcall mpg123_fmt_all(mpg123_pars *mp)
{
  int v2; // r1
  _DWORD *v3; // r3
  int v4; // r1
  _DWORD *v5; // r3

  if ( !mp )
    return 25;
  if ( (mp->flags & 0x20) == 0 && mp->verbose >= 3 )
    fwrite("Note: Enabling all formats.\n", 0x1Cu, 1u, (FILE *)stderr);
  v2 = 0;
  do
  {
    v3 = (int *)((char *)&mp->verbose + v2);
    v2 += 12;
    v3[8] = 16843009;
    v3[9] = 16777473;
    v3[10] = 16843009;
  }
  while ( v2 != 120 );
  v4 = 0;
  do
  {
    v5 = (int *)((char *)&mp->verbose + v4);
    v4 += 12;
    v5[38] = 16843009;
    v5[39] = 16777473;
    v5[40] = 16843009;
  }
  while ( v4 != 120 );
  return 0;
}

//----- (002249E8) --------------------------------------------------------
int __fastcall mpg123_format(mpg123_handle *mh, int rate, int channels, int encodings)
{
  int v5; // r0

  if ( !mh )
    return -1;
  v5 = j_mpg123_fmt(&mh->p, rate, channels, encodings);
  if ( v5 )
  {
    mh->err = v5;
    return -1;
  }
  return 0;
}

//----- (00224A0C) --------------------------------------------------------
int __fastcall mpg123_fmt(mpg123_pars *mp, int rate, int channels, int encodings)
{
  __int16 v5; // r9
  int v8; // r0
  int v9; // r1
  int result; // r0
  int v11; // r0
  int force_rate; // r1
  int v13; // r4
  int v14; // lr
  int v15; // r10
  int v16; // [sp+10h] [bp-30h]
  int v17; // [sp+14h] [bp-2Ch]
  int v18; // [sp+18h] [bp-28h] BYREF
  int v19; // [sp+1Ch] [bp-24h]

  v19 = 1;
  v5 = encodings;
  v18 = 0;
  if ( !mp )
    return 25;
  if ( !(channels << 30) )
    return 2;
  if ( (mp->flags & 0x20) != 0 || mp->verbose < 3 )
  {
    if ( (channels & 2) == 0 )
    {
LABEL_6:
      v8 = 0;
      v9 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    fprintf((FILE *)stderr, "Note: Want to enable format %li/%i for encodings 0x%x.\n", rate, channels, encodings);
    if ( (channels & 2) == 0 )
      goto LABEL_6;
  }
  if ( channels << 31 )
    goto LABEL_13;
  v8 = 1;
  v9 = 0;
LABEL_12:
  *(_DWORD *)((unsigned int)&v18 | (4 * v9)) = v8;
LABEL_13:
  if ( rate <= 22049 )
  {
    if ( rate > 11999 )
    {
      if ( rate == 12000 )
      {
        v11 = 2;
        goto LABEL_37;
      }
      if ( rate == 16000 )
      {
        v11 = 3;
        goto LABEL_37;
      }
    }
    else
    {
      if ( rate == 8000 )
      {
        v11 = 0;
        goto LABEL_37;
      }
      if ( rate == 11025 )
      {
        v11 = 1;
        goto LABEL_37;
      }
    }
  }
  else if ( rate < 32000 )
  {
    if ( rate == 22050 )
    {
      v11 = 4;
      goto LABEL_37;
    }
    if ( rate == 24000 )
    {
      v11 = 5;
      goto LABEL_37;
    }
  }
  else
  {
    switch ( rate )
    {
      case 32000:
        v11 = 6;
        goto LABEL_37;
      case 44100:
        v11 = 7;
        goto LABEL_37;
      case 48000:
        v11 = 8;
        goto LABEL_37;
    }
  }
  force_rate = mp->force_rate;
  result = 3;
  if ( force_rate && force_rate == rate )
  {
    v11 = 9;
LABEL_37:
    v13 = v5 & 0x60;
    v17 = v18;
    v16 = v19;
    if ( (v5 & 0xD0) == 208 )
      mp->audio_caps[v18][v11][0] = 1;
    v14 = v5 & 0x1180;
    if ( v13 == 96 )
      mp->audio_caps[v18][v11][1] = 1;
    if ( v14 == 4480 )
      mp->audio_caps[v18][v11][2] = 1;
    if ( (v5 & 0x2100) == 8448 )
      mp->audio_caps[v18][v11][3] = 1;
    if ( (v5 & 0x5080) == 20608 )
      mp->audio_caps[v18][v11][4] = 1;
    if ( (v5 & 0x6000) == 24576 )
      mp->audio_caps[v18][v11][5] = 1;
    v15 = v5 & 0x82;
    if ( (v5 & 0x400) != 0 )
      mp->audio_caps[v18][v11][7] = 1;
    if ( v15 == 130 )
      mp->audio_caps[v18][v11][8] = 1;
    if ( (v5 & 1) != 0 )
      mp->audio_caps[v18][v11][9] = 1;
    if ( (v5 & 4) != 0 )
      mp->audio_caps[v18][v11][10] = 1;
    if ( (v5 & 8) != 0 )
      mp->audio_caps[v18][v11][11] = 1;
    if ( v17 == v16 )
      return 0;
    if ( (v5 & 0xD0) == 208 )
    {
      mp->audio_caps[v19][v11][0] = 1;
      if ( v13 != 96 )
      {
LABEL_62:
        if ( v14 != 4480 )
          goto LABEL_64;
        goto LABEL_63;
      }
    }
    else if ( v13 != 96 )
    {
      goto LABEL_62;
    }
    mp->audio_caps[v19][v11][1] = 1;
    if ( v14 != 4480 )
    {
LABEL_64:
      if ( (v5 & 0x2100) == 8448 )
        mp->audio_caps[v19][v11][3] = 1;
      if ( (v5 & 0x5080) == 20608 )
        mp->audio_caps[v19][v11][4] = 1;
      if ( (v5 & 0x6000) == 24576 )
      {
        mp->audio_caps[v19][v11][5] = 1;
        if ( (v5 & 0x400) == 0 )
        {
LABEL_70:
          if ( v15 != 130 )
            goto LABEL_71;
          goto LABEL_82;
        }
      }
      else if ( (v5 & 0x400) == 0 )
      {
        goto LABEL_70;
      }
      mp->audio_caps[v19][v11][7] = 1;
      if ( v15 != 130 )
      {
LABEL_71:
        if ( (v5 & 1) == 0 )
          goto LABEL_72;
        goto LABEL_83;
      }
LABEL_82:
      mp->audio_caps[v19][v11][8] = 1;
      if ( (v5 & 1) == 0 )
      {
LABEL_72:
        if ( (v5 & 4) == 0 )
          goto LABEL_73;
        goto LABEL_84;
      }
LABEL_83:
      mp->audio_caps[v19][v11][9] = 1;
      if ( (v5 & 4) == 0 )
      {
LABEL_73:
        if ( (v5 & 8) == 0 )
          return 0;
LABEL_74:
        mp->audio_caps[v19][v11][11] = 1;
        return 0;
      }
LABEL_84:
      mp->audio_caps[v19][v11][10] = 1;
      if ( (v5 & 8) == 0 )
        return 0;
      goto LABEL_74;
    }
LABEL_63:
    mp->audio_caps[v19][v11][2] = 1;
    goto LABEL_64;
  }
  return result;
}

//----- (00224E40) --------------------------------------------------------
int __fastcall mpg123_format_support(mpg123_handle *mh, int rate, int encoding)
{
  int v3; // r1
  int v4; // r2
  int force_rate; // r3
  bool v6; // zf
  char *v7; // r1
  int result; // r0

  if ( !mh )
    return 0;
  if ( rate <= 22049 )
  {
    if ( rate > 11999 )
    {
      if ( rate == 12000 )
      {
        v3 = 2;
        if ( encoding >= 512 )
          goto LABEL_23;
        goto LABEL_33;
      }
      if ( rate == 16000 )
      {
        v3 = 3;
        if ( encoding >= 512 )
          goto LABEL_23;
        goto LABEL_33;
      }
    }
    else
    {
      if ( rate == 8000 )
      {
        v3 = 0;
        if ( encoding >= 512 )
          goto LABEL_23;
        goto LABEL_33;
      }
      if ( rate == 11025 )
      {
        v3 = 1;
        if ( encoding >= 512 )
          goto LABEL_23;
        goto LABEL_33;
      }
    }
  }
  else if ( rate < 32000 )
  {
    if ( rate == 22050 )
    {
      v3 = 4;
      if ( encoding >= 512 )
        goto LABEL_23;
      goto LABEL_33;
    }
    if ( rate == 24000 )
    {
      v3 = 5;
      if ( encoding >= 512 )
        goto LABEL_23;
      goto LABEL_33;
    }
  }
  else
  {
    switch ( rate )
    {
      case 32000:
        v3 = 6;
        if ( encoding < 512 )
          goto LABEL_33;
        goto LABEL_23;
      case 44100:
        v3 = 7;
        if ( encoding < 512 )
          goto LABEL_33;
        goto LABEL_23;
      case 48000:
        v3 = 8;
        if ( encoding < 512 )
          goto LABEL_33;
LABEL_23:
        if ( encoding >= 8448 )
        {
          switch ( encoding )
          {
            case 8448:
              v4 = 3;
              goto LABEL_63;
            case 20608:
              v4 = 4;
              goto LABEL_63;
            case 24576:
              v4 = 5;
              goto LABEL_63;
          }
        }
        else
        {
          switch ( encoding )
          {
            case 512:
              v4 = 6;
              goto LABEL_63;
            case 1024:
              v4 = 7;
              goto LABEL_63;
            case 4480:
              v4 = 2;
              goto LABEL_63;
          }
        }
        goto LABEL_62;
    }
  }
  force_rate = mh->p.force_rate;
  v6 = force_rate == rate;
  v3 = -1;
  if ( v6 )
    v3 = 9;
  if ( !force_rate )
    v3 = -1;
  if ( encoding >= 512 )
    goto LABEL_23;
LABEL_33:
  if ( encoding > 95 )
  {
    switch ( encoding )
    {
      case 96:
        v4 = 1;
        goto LABEL_63;
      case 130:
        v4 = 8;
        goto LABEL_63;
      case 208:
        v4 = 0;
        goto LABEL_63;
    }
  }
  else
  {
    switch ( encoding )
    {
      case 1:
        v4 = 9;
        goto LABEL_63;
      case 4:
        v4 = 10;
        goto LABEL_63;
      case 8:
        v4 = 11;
        goto LABEL_63;
    }
  }
LABEL_62:
  v4 = -1;
LABEL_63:
  if ( (v4 | v3) < 0 )
    return 0;
  v7 = (char *)mh + 12 * v3 + v4;
  result = v7[45912] != 0;
  if ( v7[46032] )
    return result | 2;
  return result;
}

//----- (00224FBA) --------------------------------------------------------
int __fastcall mpg123_fmt_support(mpg123_pars *mp, int rate, int encoding)
{
  int force_rate; // r3
  int v4; // r12
  int v5; // r2
  bool v6; // zf
  int v7; // r1
  char *v8; // r0

  if ( rate <= 22049 )
  {
    if ( rate > 11999 )
    {
      force_rate = 12000;
      if ( rate == 12000 )
      {
        v4 = 2;
        if ( encoding >= 512 )
          goto LABEL_22;
        goto LABEL_32;
      }
      if ( rate == 16000 )
      {
        v4 = 3;
        if ( encoding >= 512 )
          goto LABEL_22;
        goto LABEL_32;
      }
    }
    else
    {
      if ( rate == 8000 )
      {
        v4 = 0;
        if ( encoding >= 512 )
          goto LABEL_22;
        goto LABEL_32;
      }
      force_rate = 11025;
      if ( rate == 11025 )
      {
        v4 = 1;
        if ( encoding >= 512 )
          goto LABEL_22;
        goto LABEL_32;
      }
    }
    goto LABEL_47;
  }
  if ( rate < 32000 )
  {
    if ( rate == 22050 )
    {
      v4 = 4;
      if ( encoding >= 512 )
        goto LABEL_22;
      goto LABEL_32;
    }
    force_rate = 24000;
    if ( rate == 24000 )
    {
      v4 = 5;
      if ( encoding >= 512 )
        goto LABEL_22;
      goto LABEL_32;
    }
    goto LABEL_47;
  }
  if ( rate == 32000 )
  {
    v4 = 6;
    if ( encoding < 512 )
      goto LABEL_32;
    goto LABEL_22;
  }
  if ( rate == 44100 )
  {
    v4 = 7;
    if ( encoding < 512 )
      goto LABEL_32;
    goto LABEL_22;
  }
  force_rate = 48000;
  if ( rate != 48000 )
  {
LABEL_47:
    v6 = mp == 0;
    if ( mp )
    {
      force_rate = mp->force_rate;
      v6 = force_rate == 0;
    }
    if ( v6 || force_rate != rate )
    {
      v4 = -1;
      if ( encoding >= 512 )
        goto LABEL_22;
    }
    else
    {
      v4 = 9;
      if ( encoding >= 512 )
        goto LABEL_22;
    }
LABEL_32:
    if ( encoding > 95 )
    {
      switch ( encoding )
      {
        case 96:
          v5 = 1;
          goto LABEL_62;
        case 130:
          v5 = 8;
          goto LABEL_62;
        case 208:
          v5 = 0;
          goto LABEL_62;
      }
    }
    else
    {
      switch ( encoding )
      {
        case 1:
          v5 = 9;
          goto LABEL_62;
        case 4:
          v5 = 10;
          goto LABEL_62;
        case 8:
          v5 = 11;
          goto LABEL_62;
      }
    }
LABEL_61:
    v5 = -1;
    goto LABEL_62;
  }
  v4 = 8;
  if ( encoding < 512 )
    goto LABEL_32;
LABEL_22:
  if ( encoding >= 8448 )
  {
    if ( encoding == 8448 )
    {
      v5 = 3;
      goto LABEL_62;
    }
    if ( encoding == 20608 )
    {
      v5 = 4;
      goto LABEL_62;
    }
    if ( encoding != 24576 )
      goto LABEL_61;
    v5 = 5;
  }
  else
  {
    if ( encoding == 512 )
    {
      v5 = 6;
      goto LABEL_62;
    }
    if ( encoding == 1024 )
    {
      v5 = 7;
      goto LABEL_62;
    }
    if ( encoding != 4480 )
      goto LABEL_61;
    v5 = 2;
  }
LABEL_62:
  v7 = 0;
  if ( mp )
  {
    if ( (v5 | v4) >= 0 )
    {
      v8 = (char *)mp + 12 * v4 + v5;
      v7 = v8[32] != 0;
      if ( v8[152] )
        return v7 | 2;
    }
  }
  return v7;
}

//----- (00225144) --------------------------------------------------------
void __fastcall INT123_invalidate_format(audioformat *af)
{
  af->encoding = 0;
  af->channels = 0;
  af->rate = 0;
}

//----- (0022514E) --------------------------------------------------------
off_t __fastcall samples_to_storage(mpg123_handle *fr, off_t s)
{
  int v2; // r1

  if ( (fr->af.encoding & 0x4000) != 0 )
    v2 = 4 * s;
  else
    v2 = s * fr->af.encsize;
  return fr->af.channels * v2;
}

//----- (0022516E) --------------------------------------------------------
off_t __fastcall INT123_samples_to_bytes(mpg123_handle *fr, off_t s)
{
  return fr->af.channels * s * fr->af.encsize;
}

//----- (00225180) --------------------------------------------------------
off_t __fastcall INT123_bytes_to_samples(mpg123_handle *fr, off_t b)
{
  return sub_1912A8(b / fr->af.encsize, fr->af.channels);
}
// 1912A8: using guessed type int __fastcall sub_1912A8(_DWORD, _DWORD);

//----- (002251A2) --------------------------------------------------------
void __fastcall postprocess_buffer(mpg123_handle *fr)
{
  audioformat *p_af; // r12
  int encoding; // r1
  size_t fill; // r4
  size_t *p_fill; // r2
  unsigned __int8 *v5; // r1
  size_t v6; // r3
  outbuffer *v7; // lr
  unsigned __int8 *data; // r3
  unsigned __int8 *v9; // r4
  _BYTE *v10; // r5
  unsigned __int8 v11; // r1
  unsigned __int8 *v12; // r1
  outbuffer *p_buffer; // lr
  unsigned __int8 *v14; // r4
  _BYTE *v15; // r5
  unsigned __int8 v16; // r1
  unsigned __int8 *v17; // r1
  size_t *v18; // r0
  size_t v19; // r2

  p_af = &fr->af;
  encoding = fr->af.encoding;
  switch ( encoding )
  {
    case 24576:
      goto LABEL_4;
    case 20608:
      data = fr->buffer.data;
      p_fill = &fr->buffer.fill;
      if ( fr->buffer.fill >= 4 )
      {
        p_buffer = &fr->buffer;
        v14 = data + 2;
        do
        {
          v15 = v14 + 6;
          *data = *(v14 - 1);
          data[1] = *v14;
          v16 = v14[1];
          v14 += 4;
          data[2] = v16;
          data += 3;
          v12 = p_buffer->data;
        }
        while ( v15 - p_buffer->data <= *p_fill );
        goto LABEL_17;
      }
      goto LABEL_14;
    case 8448:
LABEL_4:
      fill = fr->buffer.fill;
      p_fill = &fr->buffer.fill;
      if ( fill >= 4 )
      {
        v5 = fr->buffer.data;
        v6 = 0;
        do
        {
          *(_DWORD *)&v5[4 * v6++] ^= 0x80000000;
          fill = *p_fill;
        }
        while ( v6 < *p_fill >> 2 );
        encoding = p_af->encoding;
      }
      if ( encoding == 24576 )
      {
        v7 = &fr->buffer;
        data = fr->buffer.data;
        if ( fill >= 4 )
        {
          v9 = data + 2;
          do
          {
            v10 = v9 + 6;
            *data = *(v9 - 1);
            data[1] = *v9;
            v11 = v9[1];
            v9 += 4;
            data[2] = v11;
            data += 3;
            v12 = v7->data;
          }
          while ( v10 - v7->data <= *p_fill );
          goto LABEL_17;
        }
LABEL_14:
        v12 = data;
LABEL_17:
        *p_fill = data - v12;
        encoding = p_af->encoding;
      }
      break;
  }
  if ( encoding == 96 && fr->buffer.fill >= 2 )
  {
    v17 = fr->buffer.data;
    v18 = &fr->buffer.fill;
    v19 = 0;
    do
      *(_WORD *)&v17[2 * v19++] += 0x8000;
    while ( v19 < *v18 >> 1 );
  }
}

//----- (002252A2) --------------------------------------------------------
void __fastcall INT123_frame_init(mpg123_handle *fr)
{
  INT123_frame_init_par(fr, 0);
}

//----- (002252B0) --------------------------------------------------------
void __fastcall INT123_frame_init_par(mpg123_handle *fr, mpg123_pars *mp)
{
  double *v3; // r0
  mpg123_pars_struct *p_p; // r0

  fr->buffer.data = 0;
  fr->own_buffer = 0;
  fr->rawbuffs = 0;
  fr->rawbuffss = 0;
  fr->rawdecwin = 0;
  fr->rawdecwins = 0;
  fr->conv16to8_buf = 0;
  fr->layerscratch = 0;
  fr->xing_toc = 0;
  fr->cpu_opts.type = generic;
  fr->cpu_opts.class = normal;
  fr->INT123_ntom_val[1] = 0x4000;
  fr->INT123_ntom_val[0] = 0x4000;
  fr->have_eq_settings = 0;
  fr->ntom_step = 0x8000;
  v3 = fr->equalizer[1];
  *v3 = 1.0;
  v3[1] = 1.0;
  fr->equalizer[1][2] = 1.0;
  fr->equalizer[1][3] = 1.0;
  fr->equalizer[0][0] = 1.0;
  fr->equalizer[0][1] = 1.0;
  fr->equalizer[1][4] = 1.0;
  fr->equalizer[1][5] = 1.0;
  fr->equalizer[0][2] = 1.0;
  fr->equalizer[0][3] = 1.0;
  fr->equalizer[1][6] = 1.0;
  fr->equalizer[1][7] = 1.0;
  fr->equalizer[0][4] = 1.0;
  fr->equalizer[0][5] = 1.0;
  fr->equalizer[1][8] = 1.0;
  fr->equalizer[1][9] = 1.0;
  fr->equalizer[0][6] = 1.0;
  fr->equalizer[0][7] = 1.0;
  fr->equalizer[1][10] = 1.0;
  fr->equalizer[1][11] = 1.0;
  fr->equalizer[0][8] = 1.0;
  fr->equalizer[0][9] = 1.0;
  fr->equalizer[1][12] = 1.0;
  fr->equalizer[1][13] = 1.0;
  fr->equalizer[0][10] = 1.0;
  fr->equalizer[0][11] = 1.0;
  fr->equalizer[1][14] = 1.0;
  fr->equalizer[1][15] = 1.0;
  fr->equalizer[0][12] = 1.0;
  fr->equalizer[0][13] = 1.0;
  fr->equalizer[1][16] = 1.0;
  fr->equalizer[1][17] = 1.0;
  fr->equalizer[0][14] = 1.0;
  fr->equalizer[0][15] = 1.0;
  fr->equalizer[1][18] = 1.0;
  fr->equalizer[1][19] = 1.0;
  fr->equalizer[0][16] = 1.0;
  fr->equalizer[0][17] = 1.0;
  fr->equalizer[1][20] = 1.0;
  fr->equalizer[1][21] = 1.0;
  fr->equalizer[0][18] = 1.0;
  fr->equalizer[0][19] = 1.0;
  fr->equalizer[1][22] = 1.0;
  fr->equalizer[1][23] = 1.0;
  fr->equalizer[0][20] = 1.0;
  fr->equalizer[0][21] = 1.0;
  fr->equalizer[1][24] = 1.0;
  fr->equalizer[1][25] = 1.0;
  fr->equalizer[0][22] = 1.0;
  fr->equalizer[0][23] = 1.0;
  fr->equalizer[1][26] = 1.0;
  fr->equalizer[1][27] = 1.0;
  fr->equalizer[0][24] = 1.0;
  fr->equalizer[0][25] = 1.0;
  fr->equalizer[1][28] = 1.0;
  fr->equalizer[1][29] = 1.0;
  fr->equalizer[0][26] = 1.0;
  fr->equalizer[0][27] = 1.0;
  fr->equalizer[1][30] = 1.0;
  fr->equalizer[1][31] = 1.0;
  fr->equalizer[0][28] = 1.0;
  fr->equalizer[0][29] = 1.0;
  fr->equalizer[0][30] = 1.0;
  fr->equalizer[0][31] = 1.0;
  fr->af.encoding = 0;
  fr->id3v2.version = 0;
  fr->af.channels = 0;
  fr->af.rate = 0;
  fr->rdat.iohandle = 0;
  fr->wrapperclean = 0;
  fr->wrapperdata = 0;
  fr->rdat.cleanup_handle = 0;
  *(_QWORD *)&fr->rdat.r_read = 0LL;
  *(_QWORD *)&fr->rdat.r_read_handle = 0LL;
  fr->icy.data = 0;
  *(_QWORD *)&fr->id3v2.title = 0LL;
  *(_QWORD *)&fr->id3v2.album = 0LL;
  *(_QWORD *)&fr->id3v2.text = 0LL;
  *(_QWORD *)&fr->id3v2.extra = 0LL;
  *(_QWORD *)&fr->id3v2.genre = 0LL;
  *(_QWORD *)&fr->id3v2.comment_list = 0LL;
  fr->err = 0;
  fr->decoder_change = 1;
  p_p = &fr->p;
  if ( mp )
  {
    qmemcpy(p_p, mp, sizeof(mpg123_pars_struct));
  }
  else
  {
    HIDWORD(fr->p.outscale) = 1072693248;
    LODWORD(fr->p.outscale) = 0;
    fr->p.icy_interval = 0;
    *(_QWORD *)&p_p->verbose = 0LL;
    *(_QWORD *)&fr->p.force_rate = 0LL;
    *(_QWORD *)&fr->p.rva = 0LL;
    *(_QWORD *)&fr->p.doublespeed = 0LL;
    fr->p.preframes = 4;
    fr->p.resync_limit = 1024;
    j_mpg123_fmt_all(p_p);
  }
  fr->down_sample = 0;
  frame_fixed_reset(fr);
  fr->synth_mono = 0;
  fr->synth = 0;
  fr->INT123_make_decode_tables = 0;
}

//----- (00225550) --------------------------------------------------------
int INT123_defdec()
{
  return 1;
}

//----- (00225554) --------------------------------------------------------
optcla __fastcall INT123_decclass(const optdec type)
{
  optcla v2; // r1

  if ( (unsigned int)(type - 7) < 6 && 0x35u >> (type - 7) << 31 )
    return 2;
  v2 = normal;
  if ( type == neon )
    return 2;
  return v2;
}

//----- (00225580) --------------------------------------------------------
int __fastcall mpg123_reset_eq(mpg123_handle *mh)
{
  double *v1; // r0

  mh->have_eq_settings = 0;
  mh->equalizer[1][0] = 1.0;
  mh->equalizer[1][1] = 1.0;
  mh->equalizer[1][2] = 1.0;
  mh->equalizer[1][3] = 1.0;
  mh->equalizer[0][0] = 1.0;
  mh->equalizer[0][1] = 1.0;
  mh->equalizer[1][4] = 1.0;
  mh->equalizer[1][5] = 1.0;
  mh->equalizer[0][2] = 1.0;
  mh->equalizer[0][3] = 1.0;
  mh->equalizer[1][6] = 1.0;
  mh->equalizer[1][7] = 1.0;
  mh->equalizer[0][4] = 1.0;
  mh->equalizer[0][5] = 1.0;
  mh->equalizer[1][8] = 1.0;
  mh->equalizer[1][9] = 1.0;
  mh->equalizer[0][6] = 1.0;
  mh->equalizer[0][7] = 1.0;
  mh->equalizer[1][10] = 1.0;
  mh->equalizer[1][11] = 1.0;
  mh->equalizer[0][8] = 1.0;
  mh->equalizer[0][9] = 1.0;
  mh->equalizer[1][12] = 1.0;
  mh->equalizer[1][13] = 1.0;
  mh->equalizer[0][10] = 1.0;
  mh->equalizer[0][11] = 1.0;
  mh->equalizer[1][14] = 1.0;
  mh->equalizer[1][15] = 1.0;
  mh->equalizer[0][12] = 1.0;
  mh->equalizer[0][13] = 1.0;
  mh->equalizer[1][16] = 1.0;
  mh->equalizer[1][17] = 1.0;
  mh->equalizer[0][14] = 1.0;
  mh->equalizer[0][15] = 1.0;
  mh->equalizer[1][18] = 1.0;
  mh->equalizer[1][19] = 1.0;
  mh->equalizer[0][16] = 1.0;
  mh->equalizer[0][17] = 1.0;
  mh->equalizer[1][20] = 1.0;
  mh->equalizer[1][21] = 1.0;
  mh->equalizer[0][18] = 1.0;
  mh->equalizer[0][19] = 1.0;
  mh->equalizer[1][22] = 1.0;
  mh->equalizer[1][23] = 1.0;
  mh->equalizer[0][20] = 1.0;
  mh->equalizer[0][21] = 1.0;
  mh->equalizer[1][24] = 1.0;
  mh->equalizer[1][25] = 1.0;
  mh->equalizer[0][22] = 1.0;
  mh->equalizer[0][23] = 1.0;
  mh->equalizer[1][26] = 1.0;
  mh->equalizer[1][27] = 1.0;
  mh->equalizer[0][24] = 1.0;
  mh->equalizer[0][25] = 1.0;
  mh->equalizer[1][28] = 1.0;
  mh->equalizer[1][29] = 1.0;
  mh->equalizer[0][26] = 1.0;
  mh->equalizer[0][27] = 1.0;
  mh->equalizer[1][30] = 1.0;
  mh->equalizer[1][31] = 1.0;
  mh->equalizer[0][28] = 1.0;
  mh->equalizer[0][29] = 1.0;
  v1 = &mh->equalizer[0][30];
  *v1 = 1.0;
  v1[1] = 1.0;
  return 0;
}

//----- (002256E0) --------------------------------------------------------
void __fastcall INT123_init_icy(icy_meta *icy)
{
  icy->data = 0;
}

//----- (002256E6) --------------------------------------------------------
void __fastcall INT123_init_id3(mpg123_handle *fr)
{
  mpg123_string **p_genre; // r1
  mpg123_string **p_title; // r0

  fr->id3v2.version = 0;
  *(_QWORD *)&fr->id3v2.text = 0LL;
  *(_QWORD *)&fr->id3v2.extra = 0LL;
  p_genre = &fr->id3v2.genre;
  p_title = &fr->id3v2.title;
  *(_QWORD *)p_genre = 0LL;
  *((_QWORD *)p_genre + 1) = 0LL;
  *(_QWORD *)p_title = 0LL;
  *((_QWORD *)p_title + 1) = 0LL;
}

//----- (00225710) --------------------------------------------------------
void __fastcall frame_fixed_reset(mpg123_handle *fr)
{
  unsigned __int8 *data; // r0
  icy_meta *p_icy; // r9
  int preframes; // r0

  data = fr->icy.data;
  p_icy = &fr->icy;
  if ( data )
    free(data);
  p_icy->data = 0;
  fr->icy.interval = 0;
  fr->icy.next = 0;
  fr->rdat.flags = 0;
  fr->rd = &bad_reader;
  fr->rdat.buffer.firstpos = 0;
  fr->rdat.buffer.fileoff = 0;
  HIDWORD(fr->lastscale) = -1074790400;
  LODWORD(fr->lastscale) = 0;
  HIDWORD(fr->mean_framesize) = 0;
  LODWORD(fr->mean_framesize) = 0;
  fr->to_ignore = 0;
  fr->to_decode = 0;
  fr->metaflags = 0;
  fr->outblock = 147456;
  fr->clip = 0;
  fr->oldhead = 0;
  fr->firsthead = 0;
  fr->abr_rate = 0;
  fr->track_frames = 0;
  fr->track_samples = -1;
  fr->framesize = 0;
  fr->mean_frames = 0;
  fr->freesize = 0;
  *(_WORD *)&fr->accurate = 1;
  *(_QWORD *)&fr->rdat.buffer.first = 0LL;
  *(_QWORD *)&fr->rdat.buffer.size = 0LL;
  *(_QWORD *)&fr->vbr = 0xFFFFFFFF00000000LL;
  *(_QWORD *)&fr->playnum = 0xFFFFFFFFLL;
  fr->rva.level[1] = -1;
  fr->rva.level[0] = -1;
  fr->firstframe = 0;
  fr->fsizeold = 0;
  fr->lastframe = -1;
  preframes = fr->p.preframes;
  fr->bo = 1;
  fr->ignoreframe = -preframes;
  *(_QWORD *)fr->rva.gain = 0LL;
  *(_QWORD *)fr->rva.peak = 0LL;
  fr->fresh = 1;
  fr->new_format = 0;
  j_INT123_exit_id3(fr);
  fr->id3v2.version = 0;
  *(_QWORD *)&fr->id3v2.text = 0LL;
  *(_QWORD *)&fr->id3v2.extra = 0LL;
  *(_QWORD *)&fr->id3v2.genre = 0LL;
  *(_QWORD *)&fr->id3v2.comment_list = 0LL;
  *(_QWORD *)&fr->id3v2.title = 0LL;
  *(_QWORD *)&fr->id3v2.album = 0LL;
  if ( p_icy->data )
    free(p_icy->data);
  p_icy->data = 0;
  fr->icy.interval = 0;
  fr->icy.next = 0;
  fr->error_protection = 0;
  fr->halfphase = 0;
  fr->freeformat_framesize = -1;
}

//----- (002258C4) --------------------------------------------------------
mpg123_pars *__fastcall mpg123_new_pars(int *error)
{
  mpg123_pars *v2; // r5

  v2 = (mpg123_pars *)malloc(0x130u);
  if ( v2 )
  {
    v2->icy_interval = 0;
    LODWORD(v2->outscale) = 0;
    HIDWORD(v2->outscale) = 1072693248;
    v2->resync_limit = 1024;
    v2->preframes = 4;
    *(_QWORD *)&v2->verbose = 0LL;
    *(_QWORD *)&v2->force_rate = 0LL;
    *(_QWORD *)&v2->rva = 0LL;
    *(_QWORD *)&v2->doublespeed = 0LL;
    j_mpg123_fmt_all(v2);
    if ( error )
      *error = 0;
  }
  else if ( error )
  {
    *error = 7;
  }
  return v2;
}

//----- (00225924) --------------------------------------------------------
void __fastcall mpg123_delete_pars(mpg123_pars *mp)
{
  if ( mp )
    j_free(mp);
}

//----- (0022592E) --------------------------------------------------------
int __fastcall INT123_frame_outbuffer(mpg123_handle *fr)
{
  outbuffer *p_buffer; // r6
  size_t *p_size; // r5
  unsigned __int8 *v4; // r0
  int result; // r0

  p_buffer = &fr->buffer;
  if ( !fr->own_buffer )
  {
    p_buffer->data = 0;
    goto LABEL_6;
  }
  if ( !p_buffer->data )
  {
LABEL_6:
    p_size = &fr->buffer.size;
    goto LABEL_8;
  }
  p_size = &fr->buffer.size;
  if ( fr->buffer.size == 294912 )
  {
    *p_size = 294912;
LABEL_9:
    fr->own_buffer = 1;
    result = 0;
    fr->buffer.fill = 0;
    return result;
  }
  free(p_buffer->data);
  p_buffer->data = 0;
LABEL_8:
  *p_size = 294912;
  v4 = (unsigned __int8 *)malloc(0x48000u);
  p_buffer->data = v4;
  if ( v4 )
    goto LABEL_9;
  fr->err = 7;
  return -1;
}

//----- (002259B2) --------------------------------------------------------
size_t mpg123_safe_buffer()
{
  return 147456;
}

//----- (002259B8) --------------------------------------------------------
int __fastcall mpg123_replace_buffer(mpg123_handle *mh, unsigned __int8 *data, size_t size)
{
  bool v5; // cc
  outbuffer *p_buffer; // r8
  int result; // r0

  v5 = data != 0;
  if ( data )
    v5 = size >> 14 > 8;
  if ( v5 )
  {
    p_buffer = &mh->buffer;
    if ( mh->own_buffer )
    {
      if ( p_buffer->data )
        free(p_buffer->data);
    }
    result = 0;
    mh->own_buffer = 0;
    p_buffer->data = data;
    mh->buffer.fill = 0;
    mh->buffer.size = size;
  }
  else
  {
    mh->err = 6;
    return -1;
  }
  return result;
}

//----- (00225A20) --------------------------------------------------------
int __fastcall INT123_frame_buffers(mpg123_handle *fr)
{
  void **p_rawbuffs; // r6
  unsigned __int32 v3; // r0
  unsigned int v4; // r1
  int rawbuffs; // r0
  int v6; // r5
  unsigned __int8 *rawdecwin; // r1
  unsigned __int8 **p_rawdecwin; // r5
  int v9; // r0

  p_rawbuffs = (void **)&fr->rawbuffs;
  v3 = fr->cpu_opts.type - 5;
  if ( v3 > 5 )
    v4 = 0;
  else
    v4 = (unsigned int)*(&off_225B88 + v3);
  rawbuffs = (int)fr->rawbuffs;
  if ( v4 <= 0x2200 )
    v4 = 8704;
  v6 = v4 | 0xF;
  if ( rawbuffs )
  {
    if ( fr->rawbuffss == v6 )
      goto LABEL_10;
    free((void *)rawbuffs);
    *p_rawbuffs = 0;
  }
  rawbuffs = (int)malloc(v6);
  *p_rawbuffs = (void *)rawbuffs;
  if ( !rawbuffs )
    return -1;
LABEL_10:
  fr->rawbuffss = v6;
  rawdecwin = fr->rawdecwin;
  if ( (rawbuffs & 0xF) != 0 )
    rawbuffs = rawbuffs - (rawbuffs & 0xF) + 16;
  fr->short_buffs[0][0] = (__int16 *)rawbuffs;
  fr->real_buffs[0][0] = (double *)rawbuffs;
  fr->short_buffs[1][0] = (__int16 *)(rawbuffs + 1088);
  fr->short_buffs[0][1] = (__int16 *)(rawbuffs + 544);
  fr->short_buffs[1][1] = (__int16 *)(rawbuffs + 1632);
  fr->real_buffs[1][0] = (double *)(rawbuffs + 4352);
  fr->real_buffs[0][1] = (double *)(rawbuffs + 2176);
  p_rawdecwin = &fr->rawdecwin;
  fr->real_buffs[1][1] = (double *)(rawbuffs + 6528);
  if ( !rawdecwin )
  {
LABEL_15:
    rawdecwin = (unsigned __int8 *)malloc(0x1100u);
    *p_rawdecwin = rawdecwin;
    if ( !rawdecwin )
      return -1;
    goto LABEL_16;
  }
  if ( fr->rawdecwins != 4352 )
  {
    free(rawdecwin);
    *p_rawdecwin = 0;
    goto LABEL_15;
  }
LABEL_16:
  fr->rawdecwins = 4352;
  fr->decwin = (double *)rawdecwin;
  if ( fr->layerscratch )
  {
LABEL_21:
    memset(*p_rawbuffs, 0, fr->rawbuffss);
    return 0;
  }
  v9 = (int)malloc(0x523Fu);
  fr->layerscratch = (double *)v9;
  if ( v9 )
  {
    if ( (v9 & 0x3F) != 0 )
      v9 = v9 - (v9 & 0x3F) + 64;
    fr->layer1.fraction = (double (*)[32])v9;
    fr->layer2.fraction = (double (*)[4][32])(v9 + 512);
    fr->layer3.hybrid_in = (double (*)[32][18])(v9 + 2560);
    fr->layer3.hybrid_out = (double (*)[18][32])(v9 + 11776);
    goto LABEL_21;
  }
  return -1;
}
// 225B88: using guessed type void *off_225B88;

//----- (00225BA0) --------------------------------------------------------
int __fastcall INT123_frame_buffers_reset(mpg123_handle *fr)
{
  unsigned __int8 *v2; // r0
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0

  fr->bsnum = 0;
  fr->buffer.fill = 0;
  v2 = fr->bsspace[1];
  fr->bsbuf = v2;
  rawbuffss = fr->rawbuffss;
  fr->bsbufold = v2;
  rawbuffs = fr->rawbuffs;
  fr->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(fr->bsspace, 0, sizeof(fr->bsspace));
  *(_WORD *)&fr->ssave[32] = 0;
  *(_QWORD *)&fr->ssave[16] = 0LL;
  *(_QWORD *)&fr->ssave[24] = 0LL;
  *(_QWORD *)fr->ssave = 0LL;
  *(_QWORD *)&fr->ssave[8] = 0LL;
  memset(fr->hybrid_block, 0, 0x4808u);
  return 0;
}

//----- (00225C18) --------------------------------------------------------
int __fastcall INT123_frame_fill_toc(mpg123_handle *fr, unsigned __int8 *in)
{
  unsigned __int8 *xing_toc; // r0
  unsigned __int8 **p_xing_toc; // r5

  xing_toc = fr->xing_toc;
  if ( !xing_toc )
  {
    p_xing_toc = &fr->xing_toc;
    xing_toc = (unsigned __int8 *)malloc(0x64u);
    *p_xing_toc = xing_toc;
    if ( !xing_toc )
      return 0;
  }
  qmemcpy(xing_toc, in, 0x64u);
  return 1;
}

//----- (00225C46) --------------------------------------------------------
int __fastcall INT123_frame_reset(mpg123_handle *fr)
{
  unsigned __int8 *v2; // r0
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0

  fr->bsnum = 0;
  fr->buffer.fill = 0;
  v2 = fr->bsspace[1];
  fr->bsbuf = v2;
  rawbuffss = fr->rawbuffss;
  fr->bsbufold = v2;
  rawbuffs = fr->rawbuffs;
  fr->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(fr->bsspace, 0, sizeof(fr->bsspace));
  *(_WORD *)&fr->ssave[32] = 0;
  *(_QWORD *)&fr->ssave[16] = 0LL;
  *(_QWORD *)&fr->ssave[24] = 0LL;
  *(_QWORD *)fr->ssave = 0LL;
  *(_QWORD *)&fr->ssave[8] = 0LL;
  memset(fr->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(fr);
  xing_toc = fr->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    fr->xing_toc = 0;
  }
  return 0;
}

//----- (00225CD4) --------------------------------------------------------
void __fastcall INT123_frame_exit(mpg123_handle *fr)
{
  outbuffer *p_buffer; // r5
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *rawdecwin; // r0
  unsigned __int8 *conv16to8_buf; // r0
  double *layerscratch; // r0
  unsigned __int8 *xing_toc; // r0
  unsigned __int8 *data; // r0
  void (*wrapperclean)(void *); // r1

  p_buffer = &fr->buffer;
  if ( fr->own_buffer && p_buffer->data )
    free(p_buffer->data);
  p_buffer->data = 0;
  rawbuffs = fr->rawbuffs;
  if ( rawbuffs )
    free(rawbuffs);
  fr->rawbuffs = 0;
  fr->rawbuffss = 0;
  rawdecwin = fr->rawdecwin;
  if ( rawdecwin )
    free(rawdecwin);
  fr->rawdecwin = 0;
  fr->rawdecwins = 0;
  conv16to8_buf = fr->conv16to8_buf;
  if ( conv16to8_buf )
    free(conv16to8_buf);
  fr->conv16to8_buf = 0;
  layerscratch = fr->layerscratch;
  if ( layerscratch )
    free(layerscratch);
  xing_toc = fr->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    fr->xing_toc = 0;
  }
  j_INT123_exit_id3(fr);
  data = fr->icy.data;
  if ( data )
    free(data);
  fr->icy.data = 0;
  wrapperclean = fr->wrapperclean;
  if ( wrapperclean )
  {
    wrapperclean(fr->wrapperdata);
    fr->wrapperdata = 0;
  }
}

//----- (00225D90) --------------------------------------------------------
void __fastcall INT123_exit_id3(mpg123_handle *fr)
{
  mpg123_text *comment_list; // r0
  size_t *p_comments; // r9
  mpg123_text **p_comment_list; // r10
  int v5; // r6
  size_t v6; // r4
  mpg123_text *v7; // r5
  unsigned __int8 *p; // r0
  unsigned __int8 *v9; // r0
  size_t *p_extras; // r9
  mpg123_text *extra; // r0
  mpg123_text **p_extra; // r10
  int v13; // r6
  size_t v14; // r4
  mpg123_text *v15; // r5
  unsigned __int8 *v16; // r0
  unsigned __int8 *v17; // r0
  mpg123_text *text; // r0
  size_t *p_texts; // r9
  size_t texts; // r2
  mpg123_text **p_text; // r8
  int v22; // r5
  size_t v23; // r4
  mpg123_text *v24; // r6
  unsigned __int8 *v25; // r0
  unsigned __int8 *v26; // r0

  comment_list = fr->id3v2.comment_list;
  p_comments = &fr->id3v2.comments;
  p_comment_list = &fr->id3v2.comment_list;
  if ( fr->id3v2.comments )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = &comment_list[v5];
      p = comment_list[v5].text.p;
      if ( p )
        free(p);
      v7->text.p = 0;
      v9 = v7->description.p;
      v7->text.size = 0;
      v7->text.fill = 0;
      if ( v9 )
        free(v9);
      v7->description.p = 0;
      v7->description.size = 0;
      ++v5;
      v7->description.fill = 0;
      ++v6;
      comment_list = *p_comment_list;
    }
    while ( v6 < *p_comments );
  }
  free(comment_list);
  *p_comment_list = 0;
  *p_comments = 0;
  p_extras = &fr->id3v2.extras;
  extra = fr->id3v2.extra;
  p_extra = &fr->id3v2.extra;
  if ( fr->id3v2.extras )
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = &extra[v13];
      v16 = extra[v13].text.p;
      if ( v16 )
        free(v16);
      v15->text.p = 0;
      v17 = v15->description.p;
      v15->text.size = 0;
      v15->text.fill = 0;
      if ( v17 )
        free(v17);
      v15->description.p = 0;
      v15->description.size = 0;
      ++v13;
      v15->description.fill = 0;
      ++v14;
      extra = *p_extra;
    }
    while ( v14 < *p_extras );
  }
  free(extra);
  *p_extra = 0;
  *p_extras = 0;
  text = fr->id3v2.text;
  p_texts = &fr->id3v2.texts;
  texts = fr->id3v2.texts;
  p_text = &fr->id3v2.text;
  if ( texts )
  {
    v22 = 0;
    v23 = 0;
    do
    {
      v24 = &text[v22];
      v25 = text[v22].text.p;
      if ( v25 )
        free(v25);
      v24->text.p = 0;
      v26 = v24->description.p;
      v24->text.size = 0;
      v24->text.fill = 0;
      if ( v26 )
        free(v26);
      v24->description.p = 0;
      v24->description.size = 0;
      ++v22;
      v24->description.fill = 0;
      ++v23;
      text = *p_text;
    }
    while ( v23 < *p_texts );
  }
  free(text);
  *p_text = 0;
  *p_texts = 0;
}

//----- (00225ED0) --------------------------------------------------------
void __fastcall INT123_clear_icy(icy_meta *icy)
{
  unsigned __int8 *data; // r0

  data = icy->data;
  if ( data )
    free(data);
  icy->data = 0;
}

//----- (00225EE8) --------------------------------------------------------
int __fastcall mpg123_info(mpg123_handle *mh, mpg123_frameinfo *mi)
{
  mpg123_version v4; // r0
  int framesize; // r0
  mpg123_flags v7; // r0

  if ( !mh )
    return -1;
  if ( !mi )
  {
    mh->err = 17;
    return -1;
  }
  if ( mh->mpeg25 )
    v4 = MPG123_2_5;
  else
    v4 = mh->lsf != 0;
  mi->version = v4;
  mi->layer = mh->lay;
  mi->rate = freqs[mh->sampling_frequency];
  switch ( mh->mode )
  {
    case 0:
      mi->mode = MPG123_M_STEREO;
      break;
    case 1:
      mi->mode = MPG123_M_JOINT;
      break;
    case 2:
      mi->mode = MPG123_M_DUAL;
      break;
    case 3:
      mi->mode = MPG123_M_MONO;
      break;
    default:
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: That mode cannot be!\n",
        591);
      break;
  }
  mi->mode_ext = mh->mode_ext;
  framesize = mh->framesize;
  mi->flags = 0;
  mi->framesize = framesize + 4;
  v7 = mh->error_protection != 0;
  mi->flags = v7;
  if ( mh->copyright )
  {
    v7 |= 2u;
    mi->flags = v7;
  }
  if ( mh->extension )
  {
    v7 |= 4u;
    mi->flags = v7;
  }
  if ( mh->original )
    mi->flags = v7 | 8;
  mi->emphasis = mh->emphasis;
  mi->bitrate = tabsel_123[mh->lsf - 1][mh->lay + 2][mh->bitrate_index];
  mi->abr_rate = mh->abr_rate;
  mi->vbr = mh->vbr;
  return 0;
}

//----- (0022602C) --------------------------------------------------------
int __fastcall INT123_frame_bitrate(mpg123_handle *fr)
{
  return tabsel_123[fr->lsf - 1][fr->lay + 2][fr->bitrate_index];
}

//----- (00226060) --------------------------------------------------------
off_t __fastcall INT123_frame_index_find(mpg123_handle *fr, off_t want_frame, off_t *get_frame)
{
  off_t audio_start; // r3
  int v4; // r5
  off_t track_frames; // lr
  bool v6; // cc
  int v7; // r1

  *get_frame = 0;
  if ( (fr->p.flags & 0x200) != 0 )
  {
    audio_start = fr->audio_start;
    *get_frame = 0;
    if ( !fr->xing_toc )
      goto LABEL_12;
    v4 = 37736;
    track_frames = fr->track_frames;
    v6 = track_frames < 1;
    if ( track_frames >= 1 )
    {
      v4 = 45796;
      v6 = fr->rdat.filelen < 1;
    }
    if ( v6 )
    {
LABEL_12:
      if ( fr->mean_framesize <= 0.0 )
        return audio_start;
      *(_WORD *)&fr->accurate = 256;
      *get_frame = want_frame;
      return (int)(fr->mean_framesize * (double)want_frame + (double)fr->audio_start);
    }
    else
    {
      v7 = (int)((double)want_frame * 100.0 / (double)track_frames);
      if ( v7 <= 0 )
        v7 = 0;
      if ( v7 >= 99 )
        v7 = 99;
      *get_frame = (int)((double)v7 / 100.0 * (double)track_frames);
      *(_WORD *)&fr->accurate = 256;
      return (int)((double)fr->xing_toc[v7] * 0.00390625 * (double)*(int *)((char *)&fr->fresh + v4));
    }
  }
  audio_start = 0;
  fr->oldhead = 0;
  fr->firsthead = 0;
  return audio_start;
}

//----- (00226190) --------------------------------------------------------
off_t __fastcall INT123_frame_ins2outs(mpg123_handle *fr, off_t ins)
{
  unsigned int down_sample; // r3
  off_t result; // r0
  int lay; // r2
  off_t v5; // r4
  int v6; // r3
  unsigned int ntom_step; // r12
  off_t v8; // r2
  signed int v9; // kr00_4

  down_sample = fr->down_sample;
  if ( down_sample < 3 )
    return ins >> down_sample;
  if ( down_sample != 3 )
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
      724,
      down_sample);
    return 0;
  }
  lay = fr->lay;
  if ( lay == 1 )
  {
    v5 = 384;
    if ( ins < 1 )
      return 0;
  }
  else if ( lay == 2 )
  {
    v5 = 1152;
    if ( ins < 1 )
      return 0;
  }
  else if ( fr->lsf )
  {
    v5 = 576;
    if ( ins < 1 )
      return 0;
  }
  else
  {
    v5 = 1152;
    if ( fr->mpeg25 )
      v5 = 576;
    if ( ins < 1 )
      return 0;
  }
  v6 = 0x4000;
  ntom_step = fr->ntom_step;
  result = 0;
  do
  {
    v8 = ins;
    if ( ins > v5 )
      v8 = v5;
    ins -= v8;
    v9 = v6 + v8 * ntom_step;
    v6 = v9 % 0x8000;
    result += v9 / 0x8000;
  }
  while ( ins > 0 );
  return result;
}

//----- (0022625C) --------------------------------------------------------
off_t __fastcall INT123_ntom_ins2outs(mpg123_handle *fr, off_t ins)
{
  int lay; // r2
  off_t v3; // r4
  int v4; // r3
  unsigned int ntom_step; // r12
  off_t result; // r0
  off_t v7; // r2
  signed int v8; // kr00_4

  lay = fr->lay;
  if ( lay == 1 )
  {
    v3 = 384;
    if ( ins < 1 )
      return 0;
  }
  else
  {
    if ( lay == 2 )
    {
      v3 = 1152;
      if ( ins >= 1 )
        goto LABEL_4;
      return 0;
    }
    if ( !fr->lsf )
    {
      v3 = 1152;
      if ( fr->mpeg25 )
        v3 = 576;
      if ( ins >= 1 )
        goto LABEL_4;
      return 0;
    }
    v3 = 576;
    if ( ins < 1 )
      return 0;
  }
LABEL_4:
  v4 = 0x4000;
  ntom_step = fr->ntom_step;
  result = 0;
  do
  {
    v7 = ins;
    if ( ins > v3 )
      v7 = v3;
    ins -= v7;
    v8 = v4 + v7 * ntom_step;
    v4 = v8 % 0x8000;
    result += v8 / 0x8000;
  }
  while ( ins > 0 );
  return result;
}

//----- (002262F4) --------------------------------------------------------
off_t __fastcall INT123_frame_outs(mpg123_handle *fr, off_t num)
{
  unsigned int down_sample; // r3
  int lay; // r2
  unsigned int v4; // r0
  unsigned int ntom_step; // r2
  int v6; // r3
  int *p_mpeg25; // r12
  int *p_lsf; // lr
  off_t result; // r0
  int v10; // r5
  int v11; // r6
  bool v12; // zf
  signed int v13; // kr00_4
  int mpeg25; // r2

  down_sample = fr->down_sample;
  if ( down_sample < 3 )
  {
    lay = fr->lay;
    if ( lay == 1 )
    {
      v4 = 384;
    }
    else if ( lay == 2 )
    {
      v4 = 1152;
    }
    else if ( fr->lsf )
    {
      v4 = 576;
    }
    else
    {
      mpeg25 = fr->mpeg25;
      v4 = 1152;
      if ( mpeg25 )
        v4 = 576;
    }
    return (v4 >> down_sample) * num;
  }
  if ( down_sample != 3 )
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
      744,
      down_sample);
    return 0;
  }
  if ( num < 1 )
    return 0;
  ntom_step = fr->ntom_step;
  v6 = fr->lay;
  p_mpeg25 = &fr->mpeg25;
  p_lsf = &fr->lsf;
  result = 0;
  v10 = 0x4000;
  do
  {
    if ( v6 == 1 )
    {
      v11 = 384;
    }
    else
    {
      if ( v6 == 2 )
        goto LABEL_11;
      v12 = *p_lsf == 0;
      if ( !*p_lsf )
        v12 = *p_mpeg25 == 0;
      if ( v12 )
LABEL_11:
        v11 = 1152;
      else
        v11 = 576;
    }
    --num;
    v13 = v10 + v11 * ntom_step;
    v10 = v13 % 0x8000;
    result += v13 / 0x8000;
  }
  while ( num );
  return result;
}

//----- (002263E4) --------------------------------------------------------
off_t __fastcall INT123_ntom_frmouts(mpg123_handle *fr, off_t frame)
{
  unsigned int ntom_step; // r2
  int lay; // r3
  int *p_mpeg25; // r12
  int *p_lsf; // lr
  off_t result; // r0
  int v7; // r5
  int v8; // r6
  bool v9; // zf
  signed int v10; // kr00_4

  if ( frame < 1 )
    return 0;
  ntom_step = fr->ntom_step;
  lay = fr->lay;
  p_mpeg25 = &fr->mpeg25;
  p_lsf = &fr->lsf;
  result = 0;
  v7 = 0x4000;
  do
  {
    if ( lay == 1 )
    {
      v8 = 384;
    }
    else
    {
      if ( lay == 2 )
        goto LABEL_5;
      v9 = *p_lsf == 0;
      if ( !*p_lsf )
        v9 = *p_mpeg25 == 0;
      if ( v9 )
LABEL_5:
        v8 = 1152;
      else
        v8 = 576;
    }
    --frame;
    v10 = v7 + ntom_step * v8;
    v7 = v10 % 0x8000;
    result += v10 / 0x8000;
  }
  while ( frame );
  return result;
}

//----- (00226468) --------------------------------------------------------
off_t __fastcall INT123_frame_expect_outsamples(mpg123_handle *fr)
{
  unsigned int down_sample; // r3
  int v2; // r1
  int mpeg25; // r1
  unsigned int v5; // r0
  int lay; // r2
  int v7; // r2

  down_sample = fr->down_sample;
  if ( down_sample >= 3 )
  {
    if ( down_sample == 3 )
    {
      lay = fr->lay;
      if ( lay == 1 )
      {
        v7 = 384;
      }
      else if ( lay == 2 )
      {
        v7 = 1152;
      }
      else if ( fr->lsf )
      {
        v7 = 576;
      }
      else
      {
        v7 = 1152;
        if ( fr->mpeg25 )
          v7 = 576;
      }
      return (signed int)(fr->INT123_ntom_val[0] + fr->ntom_step * v7) / 0x8000;
    }
    else
    {
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should no"
        "t be possible!!\n",
        766,
        down_sample);
      return 0;
    }
  }
  else
  {
    v2 = fr->lay;
    if ( v2 == 1 )
    {
      return 0x180u >> down_sample;
    }
    else if ( v2 == 2 )
    {
      return 0x480u >> down_sample;
    }
    else if ( fr->lsf )
    {
      return 0x240u >> down_sample;
    }
    else
    {
      mpeg25 = fr->mpeg25;
      v5 = 1152;
      if ( mpeg25 )
        v5 = 576;
      return v5 >> down_sample;
    }
  }
}

//----- (00226534) --------------------------------------------------------
off_t __fastcall INT123_ntom_frame_outsamples(mpg123_handle *fr)
{
  int lay; // r2
  int v2; // r2

  lay = fr->lay;
  if ( lay == 1 )
  {
    v2 = 384;
  }
  else if ( lay == 2 )
  {
    v2 = 1152;
  }
  else if ( fr->lsf )
  {
    v2 = 576;
  }
  else
  {
    v2 = 1152;
    if ( fr->mpeg25 )
      v2 = 576;
  }
  return (signed int)(fr->INT123_ntom_val[0] + fr->ntom_step * v2) / 0x8000;
}

//----- (00226588) --------------------------------------------------------
off_t __fastcall INT123_frame_offset(mpg123_handle *fr, off_t outs)
{
  unsigned int down_sample; // r2
  int lay; // r3
  unsigned int v4; // r0
  unsigned int ntom_step; // r2
  int v6; // r3
  int *p_mpeg25; // r12
  int *p_lsf; // lr
  int v9; // r4
  off_t result; // r0
  int v11; // r5
  bool v12; // zf
  signed int v13; // r4
  int mpeg25; // r3

  down_sample = fr->down_sample;
  if ( down_sample < 3 )
  {
    lay = fr->lay;
    if ( lay == 1 )
    {
      v4 = 384;
    }
    else if ( lay == 2 )
    {
      v4 = 1152;
    }
    else if ( fr->lsf )
    {
      v4 = 576;
    }
    else
    {
      mpeg25 = fr->mpeg25;
      v4 = 1152;
      if ( mpeg25 )
        v4 = 576;
    }
    return outs / (int)(v4 >> down_sample);
  }
  if ( down_sample != 3 )
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample ... should not be possible!!\n",
      786);
    return 0;
  }
  if ( outs < 1 )
    return 0;
  ntom_step = fr->ntom_step;
  v6 = fr->lay;
  p_mpeg25 = &fr->mpeg25;
  p_lsf = &fr->lsf;
  v9 = 0x4000;
  result = 0;
  if ( v6 != 1 )
    goto LABEL_11;
LABEL_13:
  v11 = 384;
  while ( 1 )
  {
    v13 = v9 + v11 * ntom_step;
    if ( outs < v13 / 0x8000 )
      return result;
    outs -= v13 / 0x8000;
    v9 = v13 % 0x8000;
    ++result;
    if ( v6 == 1 )
      goto LABEL_13;
LABEL_11:
    if ( v6 == 2 )
      goto LABEL_12;
    v12 = *p_lsf == 0;
    if ( !*p_lsf )
      v12 = *p_mpeg25 == 0;
    if ( v12 )
LABEL_12:
      v11 = 1152;
    else
      v11 = 576;
  }
}

//----- (00226670) --------------------------------------------------------
off_t __fastcall INT123_ntom_frameoff(mpg123_handle *fr, off_t soff)
{
  off_t result; // r0
  unsigned int ntom_step; // r2
  int lay; // r3
  int *p_mpeg25; // r12
  int *p_lsf; // lr
  int v7; // r4
  int v8; // r5
  bool v9; // zf
  signed int v10; // r4

  if ( soff < 1 )
    return 0;
  ntom_step = fr->ntom_step;
  lay = fr->lay;
  p_mpeg25 = &fr->mpeg25;
  p_lsf = &fr->lsf;
  v7 = 0x4000;
  result = 0;
  if ( lay != 1 )
    goto LABEL_6;
LABEL_8:
  v8 = 384;
  while ( 1 )
  {
    v10 = v7 + ntom_step * v8;
    if ( soff < v10 / 0x8000 )
      return result;
    soff -= v10 / 0x8000;
    v7 = v10 % 0x8000;
    ++result;
    if ( lay == 1 )
      goto LABEL_8;
LABEL_6:
    if ( lay == 2 )
      goto LABEL_7;
    v9 = *p_lsf == 0;
    if ( !*p_lsf )
      v9 = *p_mpeg25 == 0;
    if ( v9 )
LABEL_7:
      v8 = 1152;
    else
      v8 = 576;
  }
}

//----- (002266E8) --------------------------------------------------------
void __fastcall INT123_frame_set_frameseek(mpg123_handle *fr, off_t fe)
{
  int preframes; // r3
  int lay; // r12
  int v4; // r2
  int v5; // r3

  preframes = fr->p.preframes;
  lay = fr->lay;
  fr->firstframe = fe;
  v4 = preframes;
  if ( lay == 3 )
    v4 = 1;
  if ( preframes >= 1 )
    v4 = preframes;
  v5 = v4;
  if ( v4 > 2 )
    v5 = 2;
  if ( lay == 3 )
    v5 = v4;
  fr->ignoreframe = fe - v5;
}

//----- (00226726) --------------------------------------------------------
void __fastcall INT123_frame_skip(mpg123_handle *fr)
{
  unsigned __int8 *v2; // r0
  unsigned __int8 *v3; // r1

  if ( fr->lay == 3 )
  {
    v2 = &fr->bsbuf[fr->ssize - 512];
    v3 = &fr->bsbufold[fr->fsizeold - 512];
    fr->wordpointer = v2;
    qmemcpy(v2, v3, 0x200u);
    fr->bitindex = 0;
  }
}

//----- (00226774) --------------------------------------------------------
void __fastcall INT123_set_pointer(mpg123_handle *fr, int backstep)
{
  unsigned __int8 *v3; // r0

  v3 = &fr->bsbuf[fr->ssize - backstep];
  fr->wordpointer = v3;
  if ( backstep )
    qmemcpy(v3, &fr->bsbufold[fr->fsizeold - backstep], backstep);
  fr->bitindex = 0;
}

//----- (002267BC) --------------------------------------------------------
void __fastcall INT123_frame_set_seek(mpg123_handle *fr, off_t sp)
{
  unsigned int down_sample; // r0
  int v4; // r2
  unsigned int v5; // r2
  int v6; // r5
  int lay; // r3
  int *p_lsf; // lr
  int v9; // r0
  int v10; // r6
  bool v11; // zf
  signed int v12; // r5
  int v13; // r5
  int v14; // r3
  int *v15; // lr
  int v16; // r1
  int v17; // r6
  bool v18; // zf
  int preframes; // r2
  int v20; // r1
  int v21; // r3
  int v22; // r2

  down_sample = fr->down_sample;
  if ( down_sample >= 3 )
  {
    if ( down_sample == 3 )
    {
      if ( sp <= 0 )
      {
        v9 = 0;
        fr->firstframe = 0;
      }
      else
      {
        v6 = 0x4000;
        lay = fr->lay;
        p_lsf = &fr->lsf;
        v9 = 0;
        if ( lay != 1 )
          goto LABEL_11;
LABEL_17:
        v10 = 384;
        while ( 1 )
        {
          v12 = v6 + v10 * fr->ntom_step;
          if ( sp < v12 / 0x8000 )
            break;
          sp -= v12 / 0x8000;
          v6 = v12 % 0x8000;
          ++v9;
          if ( lay == 1 )
            goto LABEL_17;
LABEL_11:
          if ( lay == 2 )
            goto LABEL_12;
          v11 = *p_lsf == 0;
          if ( !*p_lsf )
            v11 = fr->mpeg25 == 0;
          if ( v11 )
LABEL_12:
            v10 = 1152;
          else
            v10 = 576;
        }
        fr->firstframe = v9;
        if ( v9 >= 1 )
        {
          v13 = 0;
          v14 = fr->lay;
          v15 = &fr->lsf;
          v16 = 0x4000;
          do
          {
            if ( v14 == 1 )
            {
              v17 = 384;
            }
            else
            {
              if ( v14 == 2 )
                goto LABEL_23;
              v18 = *v15 == 0;
              if ( !*v15 )
                v18 = fr->mpeg25 == 0;
              if ( v18 )
LABEL_23:
                v17 = 1152;
              else
                v17 = 576;
            }
            ++v13;
            v16 = (signed int)(v16 + v17 * fr->ntom_step) % 0x8000;
          }
          while ( v13 != v9 );
          goto LABEL_41;
        }
      }
    }
    else
    {
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample ... should not be possible!!\n",
        786);
      v9 = 0;
      v11 = fr->down_sample == 3;
      fr->firstframe = 0;
      if ( !v11 )
        goto LABEL_42;
    }
    v16 = 0x4000;
LABEL_41:
    fr->INT123_ntom_val[1] = v16;
    fr->INT123_ntom_val[0] = v16;
    goto LABEL_42;
  }
  v4 = fr->lay;
  if ( v4 == 1 )
  {
    v5 = 384;
  }
  else if ( v4 == 2 )
  {
    v5 = 1152;
  }
  else if ( fr->lsf )
  {
    v5 = 576;
  }
  else
  {
    v5 = 1152;
    if ( fr->mpeg25 )
      v5 = 576;
  }
  v9 = sp / (int)(v5 >> down_sample);
  fr->firstframe = v9;
LABEL_42:
  preframes = fr->p.preframes;
  v20 = fr->lay;
  fr->bitreservoir = 0;
  v21 = preframes;
  if ( v20 == 3 )
    v21 = 1;
  if ( preframes >= 1 )
    v21 = preframes;
  v22 = v21;
  if ( v21 > 2 )
    v22 = 2;
  if ( v20 == 3 )
    v22 = v21;
  fr->ignoreframe = v9 - v22;
}

//----- (00226988) --------------------------------------------------------
void __fastcall INT123_ntom_set_ntom(mpg123_handle *fr, off_t num)
{
  int lay; // r3
  int *p_lsf; // r4
  int v4; // r2
  int v5; // r6
  bool v6; // zf

  if ( num < 1 )
  {
    v4 = 0x4000;
  }
  else
  {
    lay = fr->lay;
    p_lsf = &fr->lsf;
    v4 = 0x4000;
    do
    {
      if ( lay == 1 )
      {
        v5 = 384;
      }
      else
      {
        if ( lay == 2 )
          goto LABEL_5;
        v6 = *p_lsf == 0;
        if ( !*p_lsf )
          v6 = fr->mpeg25 == 0;
        if ( v6 )
LABEL_5:
          v5 = 1152;
        else
          v5 = 576;
      }
      --num;
      v4 = (signed int)(v4 + v5 * fr->ntom_step) % 0x8000;
    }
    while ( num );
  }
  fr->INT123_ntom_val[1] = v4;
  fr->INT123_ntom_val[0] = v4;
}

//----- (00226A0E) --------------------------------------------------------
int __fastcall mpg123_volume_change(mpg123_handle *mh, double change)
{
  double v4; // d17

  if ( !mh )
    return -1;
  v4 = 0.0;
  if ( mh->p.outscale + change >= 0.0 )
    v4 = mh->p.outscale + change;
  mh->p.outscale = v4;
  j_INT123_do_rva(mh);
  return 0;
}

//----- (00226A4C) --------------------------------------------------------
int __fastcall mpg123_volume(mpg123_handle *mh, double vol)
{
  double v4; // d17

  if ( !mh )
    return -1;
  v4 = 0.0;
  if ( vol >= 0.0 )
    v4 = vol;
  mh->p.outscale = v4;
  j_INT123_do_rva(mh);
  return 0;
}

//----- (00226A84) --------------------------------------------------------
void __fastcall INT123_do_rva(mpg123_handle *fr)
{
  int rva; // r0
  double v3; // d9
  _BOOL4 v4; // r0
  double v5; // d16
  float *v6; // r0
  double v7; // d10
  float v8; // s18
  double v9; // d10
  void (*INT123_make_decode_tables)(mpg123_handle *); // r1

  rva = fr->p.rva;
  v3 = -1.0;
  if ( rva )
  {
    v4 = rva == 2 && fr->rva.level[1] != -1;
    v6 = (float *)(&fr->fresh + v4);
    v5 = 1.0;
    if ( *((_DWORD *)v6 + 9428) != -1 )
    {
      v7 = v6[9430];
      v8 = v6[9432];
      if ( (fr->p.flags & 0x20) == 0 && fr->p.verbose >= 2 )
        fprintf((FILE *)stderr, "Note: doing RVA with gain %f\n", v7);
      v3 = v8;
      v5 = pow(10.0, v7 / 20.0);
    }
  }
  else
  {
    v5 = 1.0;
  }
  v9 = v5 * fr->p.outscale;
  if ( v3 * v9 > 1.0 )
  {
    v9 = 1.0 / v3;
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] warning: limiting scale value to %f to prev"
      "ent clipping with indicated peak factor of %f\n",
      967,
      1.0 / v3,
      v3);
  }
  if ( v9 != fr->lastscale || fr->decoder_change )
  {
    fr->lastscale = v9;
    INT123_make_decode_tables = fr->INT123_make_decode_tables;
    if ( INT123_make_decode_tables )
      INT123_make_decode_tables(fr);
  }
}

//----- (00226BE0) --------------------------------------------------------
int __fastcall mpg123_getvolume(mpg123_handle *mh, double *base, double *really, double *rva_db)
{
  int result; // r0
  double v5; // d16
  int rva; // r1
  _BOOL4 v7; // r1
  float *v8; // r0

  if ( !mh )
    return -1;
  if ( base )
    *base = mh->p.outscale;
  if ( really )
    *really = mh->lastscale;
  v5 = 0.0;
  rva = mh->p.rva;
  if ( rva )
  {
    v7 = rva == 2 && mh->rva.level[1] != -1;
    v8 = (float *)(&mh->fresh + v7);
    if ( *((_DWORD *)v8 + 9428) != -1 )
      v5 = v8[9430];
  }
  result = 0;
  if ( rva_db )
    *rva_db = v5;
  return result;
}

//----- (00226C5C) --------------------------------------------------------
void __fastcall INT123_reset_icy(icy_meta *icy)
{
  unsigned __int8 *data; // r0

  data = icy->data;
  if ( data )
    free(data);
  icy->data = 0;
}

//----- (00226C74) --------------------------------------------------------
unsigned __int8 *__fastcall INT123_icy2utf8(const unsigned __int8 *src, int force)
{
  unsigned __int8 v2; // r2
  const unsigned __int8 *v3; // r1
  const unsigned __int8 *v4; // r6
  int v5; // r1
  char v6; // t1
  size_t v8; // r0
  char *v9; // r0
  unsigned __int8 *result; // r0
  size_t v11; // r4
  char *v12; // r9
  size_t v13; // r6
  int32x4_t v14; // q4
  int32x4_t v15; // q5
  int v16; // r5
  const unsigned __int8 *v17; // r3
  int v18; // r0
  unsigned int v19; // r10
  unsigned int v20; // r8
  unsigned int v21; // r2
  unsigned int v22; // r0
  unsigned int v23; // r1
  unsigned int v24; // r2
  int8x16_t v25; // q8
  int32x4_t v26; // q8

  if ( force )
    goto LABEL_27;
  v2 = *src;
  if ( !*src )
  {
LABEL_25:
    v8 = strlen((const char *)src);
    v9 = (char *)malloc(v8 + 1);
    if ( v9 )
      return (unsigned __int8 *)sub_19B9DC(v9, (const char *)src);
    return 0;
  }
  v3 = src;
  while ( 1 )
  {
    v4 = v3 + 1;
    if ( (v2 & 0x80u) == 0 )
      goto LABEL_24;
    if ( (unsigned __int8)(v2 + 62) > 0x3Bu )
      goto LABEL_27;
    if ( v2 == 239 )
      break;
    if ( v2 == 194 )
    {
      if ( *v4 >= 0xA0u )
      {
LABEL_14:
        v5 = 1;
        goto LABEL_22;
      }
      goto LABEL_27;
    }
    if ( v2 < 0xE0u )
      goto LABEL_14;
    if ( v2 < 0xF0u )
      goto LABEL_16;
    if ( v2 < 0xF8u )
    {
      v5 = 3;
      goto LABEL_22;
    }
    v5 = 5;
    if ( v2 < 0xFCu )
      v5 = 4;
    while ( v5 )
    {
LABEL_22:
      v6 = *v4++;
      --v5;
      if ( (v6 & 0xC0) != 128 )
        goto LABEL_27;
    }
LABEL_24:
    v3 = v4;
    v2 = *v4;
    if ( !*v4 )
      goto LABEL_25;
  }
  if ( *v4 != 191 || v3[2] <= 0xBDu )
  {
LABEL_16:
    v5 = 2;
    goto LABEL_22;
  }
LABEL_27:
  v11 = strlen((const char *)src) + 1;
  v12 = (char *)malloc(3 * v11);
  if ( !v12 )
    return 0;
  v13 = 0;
  if ( v11 )
  {
    v14 = vdupq_n_s32(0);
    v15.n128_u64[0] = 0x100000001LL;
    v15.n128_u64[1] = 0x100000001LL;
    v16 = 0;
    v17 = src;
    do
    {
      v18 = v17[v16++];
      v19 = tblofs[v18];
      v20 = tblofs[v18 + 1];
      if ( v19 < v20 )
      {
        v21 = v19 + 1;
        if ( v19 + 1 <= v20 )
          v21 = tblofs[v18 + 1];
        qmemcpy(&v12[v13], &cp1252_utf8[v19], v21 - v19);
        v22 = v20 - v19;
        if ( v20 - v19 >= 4 )
        {
          v23 = v22 & 0xFFFFFFFC;
          if ( (v22 & 0xFFFFFFFC) != 0 )
          {
            v17 = src;
            v25.n128_u64[1] = v14.n128_u64[1];
            v19 += v23;
            v24 = v22 & 0xFFFFFFFC;
            v25.n128_u64[0] = __PAIR64__(v14.n128_u32[1], v13);
            do
            {
              v25 = vaddq_s32(v25, v15);
              v24 -= 4;
            }
            while ( v24 );
            v26 = vaddq_s32(v25, vextq_s8(v25, v25, 8u));
            v13 = vaddq_s32(v26, vdupq_lane_s32((int32x2_t)v26.n128_u64[0], 1)).n128_u32[0];
            if ( v22 == v23 )
              continue;
          }
          else
          {
            v17 = src;
          }
        }
        else
        {
          v17 = src;
        }
        do
        {
          ++v19;
          ++v13;
        }
        while ( v19 < v20 );
      }
    }
    while ( v16 != v11 );
  }
  result = (unsigned __int8 *)realloc(v12, v13);
  if ( !result )
  {
    free(v12);
    return 0;
  }
  return result;
}

//----- (00226E0C) --------------------------------------------------------
void __fastcall INT123_reset_id3(mpg123_handle *fr)
{
  j_INT123_exit_id3(fr);
  fr->id3v2.version = 0;
  *(_QWORD *)&fr->id3v2.text = 0LL;
  *(_QWORD *)&fr->id3v2.extra = 0LL;
  *(_QWORD *)&fr->id3v2.genre = 0LL;
  *(_QWORD *)&fr->id3v2.comment_list = 0LL;
  *(_QWORD *)&fr->id3v2.title = 0LL;
  *(_QWORD *)&fr->id3v2.album = 0LL;
}

//----- (00226E40) --------------------------------------------------------
void __fastcall INT123_id3_link(mpg123_handle *fr)
{
  mpg123_string **p_title; // r9
  size_t texts; // r10
  size_t v3; // r8
  mpg123_string *p_text; // r6
  mpg123_string **p_album; // r11
  mpg123_string **v6; // r0
  size_t comments; // r0
  size_t *v8; // r3
  mpg123_string **p_comment; // r1
  size_t *p_fill; // r2
  size_t i; // r6
  bool v12; // zf
  mpg123_string **p_genre; // [sp+8h] [bp-28h]
  mpg123_string **p_year; // [sp+Ch] [bp-24h]
  mpg123_string **p_artist; // [sp+10h] [bp-20h]

  fr->id3v2.comment = 0;
  fr->id3v2.genre = 0;
  p_title = &fr->id3v2.title;
  texts = fr->id3v2.texts;
  *(_QWORD *)&fr->id3v2.title = 0LL;
  *(_QWORD *)&fr->id3v2.album = 0LL;
  if ( texts )
  {
    v3 = 0;
    p_genre = &fr->id3v2.genre;
    p_text = &fr->id3v2.text->text;
    p_year = &fr->id3v2.year;
    p_artist = &fr->id3v2.artist;
    p_album = &fr->id3v2.album;
    do
    {
      v12 = strncmp("TIT2", (const char *)&p_text[-2].size + 3, 4u) == 0;
      v6 = p_title;
      if ( v12
        || (v12 = strncmp("TALB", (const char *)&p_text[-2].size + 3, 4u) == 0, v6 = p_album, v12)
        || (v12 = strncmp("TPE1", (const char *)&p_text[-2].size + 3, 4u) == 0, v6 = p_artist, v12)
        || (v12 = strncmp("TYER", (const char *)&p_text[-2].size + 3, 4u) == 0, v6 = p_year, v12) )
      {
        *v6 = p_text;
      }
      else if ( !strncmp("TCON", (const char *)&p_text[-2].size + 3, 4u) )
      {
        *p_genre = p_text;
      }
      ++v3;
      p_text = (mpg123_string *)((char *)p_text + 32);
    }
    while ( v3 < texts );
  }
  comments = fr->id3v2.comments;
  if ( comments )
  {
    v8 = 0;
    p_comment = &fr->id3v2.comment;
    p_fill = &fr->id3v2.comment_list->description.fill;
    for ( i = 0; i < comments; ++i )
    {
      v12 = *p_fill == 0;
      if ( *p_fill )
        v12 = *(_BYTE *)*(p_fill - 2) == 0;
      if ( v12 )
      {
        v8 = p_fill + 1;
        *p_comment = (mpg123_string *)(p_fill + 1);
      }
      p_fill += 8;
    }
    if ( !v8 )
      *p_comment = &fr->id3v2.comment_list[comments - 1].text;
  }
}

//----- (00226F74) --------------------------------------------------------
void __fastcall INT123_id3_to_utf8(
        mpg123_string *sb,
        int encoding,
        const unsigned __int8 *source,
        size_t source_size,
        int a5)
{
  unsigned __int8 *v5; // r11
  int32x4_t v6; // q10
  size_t v8; // r6
  size_t v11; // r1
  int v12; // r10
  const unsigned __int8 *v13; // r1
  unsigned int v14; // r2
  mpg123_string *v15; // r0
  unsigned __int8 *v16; // r9
  size_t v17; // r4
  const unsigned __int8 *v18; // r6
  mpg123_string *v19; // r8
  unsigned int v20; // r0
  int64x2_t v21; // q9
  unsigned int v22; // r2
  int8x16_t v23; // q8
  int *v24; // r3
  int v25; // t1
  int32x4_t v26; // q8
  unsigned __int32 v27; // r5
  size_t v28; // r1
  const unsigned __int8 *v29; // r0
  unsigned int v30; // t1
  size_t size; // r1
  size_t v32; // r9
  _BYTE *p; // r0
  int v34; // r2
  int v35; // r2
  mpg123_string *v36; // r11
  int v37; // r0
  int v38; // r8
  int v39; // r6
  int v40; // r10
  size_t v41; // r5
  int v42; // r4
  int v43; // r0
  unsigned int v44; // r3
  int v45; // r0
  size_t v46; // r1
  size_t *p_size; // r2
  size_t v48; // r9
  _BYTE *v49; // r0
  size_t v50; // r9
  int v51; // r4
  unsigned int v52; // r11
  _BYTE *v53; // lr
  int v54; // r10
  int v55; // r4
  int v56; // r12
  _BYTE *v57; // r3
  size_t *v58; // r2
  size_t v59; // r0
  mpg123_string *v60; // r4
  const unsigned __int8 *v61; // r8
  size_t v62; // r1
  size_t v63; // r5
  unsigned __int8 *v64; // r0
  unsigned __int8 *v65; // r0
  mpg123_string *v66; // [sp+4h] [bp-54h]
  size_t *v67; // [sp+8h] [bp-50h]
  size_t len; // [sp+Ch] [bp-4Ch] BYREF
  unsigned __int8 *v69[8]; // [sp+10h] [bp-48h] BYREF
  __int64 v70; // [sp+30h] [bp-28h]
  int v71; // [sp+3Ch] [bp-1Ch]
  unsigned __int8 *v72; // [sp+40h] [bp-18h]
  unsigned __int8 *v73; // [sp+44h] [bp-14h]
  unsigned __int8 *v74; // [sp+48h] [bp-10h]
  unsigned __int8 *v75; // [sp+4Ch] [bp-Ch]
  unsigned __int8 *v76; // [sp+50h] [bp-8h]
  unsigned __int8 *v77; // [sp+54h] [bp-4h]
  __int64 savedregs; // [sp+58h] [bp+0h]

  v8 = source_size;
  v11 = encoding_widths[encoding];
  if ( encoding != 2 && v11 < source_size )
  {
    do
    {
      if ( *source )
        break;
      --v8;
      ++source;
    }
    while ( v8 > v11 );
  }
  v12 = v8 % v11;
  if ( v8 % v11 )
  {
    if ( a5 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] warning: Weird tag size %d for encoding %u "
        "- I will probably trim too early or something but I think the MP3 is broken.\n",
        244,
        v8,
        encoding);
    v8 -= v12;
  }
  v13 = source;
  v14 = v8;
  v15 = sb;
  v16 = v73;
  switch ( encoding )
  {
    case 0:
      v17 = v8;
      v18 = v13;
      v19 = v15;
      if ( !v14 )
      {
        size = v15->size;
        v27 = 0;
        v32 = 1;
        goto LABEL_33;
      }
      if ( v14 <= 3 || (v20 = v14 & 0xFFFFFFFC, (v14 & 0xFFFFFFFC) == 0) )
      {
        v20 = 0;
        v27 = v14;
LABEL_24:
        v28 = v17 - v20;
        v29 = &v18[v20];
        do
        {
          v30 = *v29++;
          --v28;
          v27 += v30 >> 7;
        }
        while ( v28 );
        goto LABEL_26;
      }
      v23 = vdupq_n_s32(0);
      v21.n128_u64[0] = 0xFF000000FFLL;
      v21.n128_u64[1] = 0xFF000000FFLL;
      v22 = v14 & 0xFFFFFFFC;
      v23.n128_u32[0] = v17;
      v24 = (int *)v13;
      do
      {
        v25 = *v24++;
        v22 -= 4;
        v71 = v25;
        v6.n128_u32[0] = v25;
        v6 = vandq_s64(vmovl_u16(vshr_n_u16((uint16x4_t)vmovl_u8((uint8x8_t)v6.n128_u64[0]).n128_u64[0], 7u)), v21);
        v23 = vaddq_s32(v23, v6);
      }
      while ( v22 );
      v26 = vaddq_s32(v23, vextq_s8(v23, v23, 8u));
      v27 = vaddq_s32(v26, vdupq_lane_s32((int32x2_t)v26.n128_u64[0], 1)).n128_u32[0];
      if ( v20 != v17 )
        goto LABEL_24;
LABEL_26:
      size = v19->size;
      v32 = v27 + 1;
      if ( v27 == -1 )
      {
        if ( size && v19->p )
          free(v19->p);
        v32 = 0;
        v27 = -1;
        p = 0;
        v19->p = 0;
        v19->size = 0;
        v19->fill = 0;
        if ( !v17 )
          goto LABEL_43;
        goto LABEL_38;
      }
LABEL_33:
      p = v19->p;
      if ( size == v32 )
      {
LABEL_37:
        if ( !v17 )
        {
LABEL_43:
          p[v27] = 0;
          goto LABEL_44;
        }
        do
        {
LABEL_38:
          v34 = *(char *)v18;
          if ( v34 < 0 )
          {
            *p = (*v18 >> 6) | 0xC0;
            v35 = 2;
            p[1] = *v18 & 0x3F | 0x80;
          }
          else
          {
            *p = v34;
            v35 = 1;
          }
          p += v35;
          --v17;
          ++v18;
        }
        while ( v17 );
        p = v19->p;
        goto LABEL_43;
      }
      if ( p )
      {
        p = realloc(p, v32);
        if ( p )
        {
LABEL_36:
          v19->p = p;
          v19->size = v32;
          goto LABEL_37;
        }
      }
      else
      {
        p = malloc(v32);
        if ( p )
          goto LABEL_36;
      }
      if ( v19->p )
        free(v19->p);
      v32 = 0;
      v19->p = 0;
      v19->size = 0;
LABEL_44:
      v19->fill = v32;
      return;
    case 1:
    case 2:
      v69[5] = v75;
      v69[6] = v76;
      v69[7] = v77;
      v70 = savedregs;
      v69[1] = v72;
      v69[2] = v73;
      v69[3] = v74;
      v69[4] = v5;
      v36 = v15;
      len = v8;
      v69[0] = (unsigned __int8 *)source;
      v37 = check_bom((const unsigned __int8 **)v69, &len) + 1;
      v38 = 0;
      v39 = 0;
      if ( v37 )
        v39 = 1;
      else
        v38 = 1;
      if ( (len & 0xFFFFFFFE) == 0 )
      {
        v41 = 0;
        p_size = &v36->size;
        v46 = v36->size;
        v48 = 1;
        goto LABEL_70;
      }
      v40 = 2;
      v41 = 0;
      if ( !v37 )
        v40 = 3;
      v42 = 0;
      while ( 1 )
      {
        v43 = v69[0][v41 + v38];
        v44 = v69[0][v41 + v39] | (v43 << 8);
        if ( ((v43 << 8) & 0xD800) != 55296 )
        {
          v45 = 3;
          if ( v44 < 0x800 )
            v45 = 2;
          if ( v44 < 0x80 )
            v45 = 1;
          goto LABEL_64;
        }
        if ( v41 + 3 >= len || (v69[0][v40 + v41] & 0xDC) != 220 )
          break;
        v41 += 2;
        v45 = 4;
LABEL_64:
        v41 += 2;
        v42 += v45;
        if ( v41 >= (len & 0xFFFFFFFE) )
        {
          v41 = len & 0xFFFFFFFE;
          goto LABEL_69;
        }
      }
      if ( a5 )
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Invalid UTF16 surrogate pair at %li (0x%04lx).\n",
          940,
          v41,
          v44);
LABEL_69:
      v48 = v42 + 1;
      p_size = &v36->size;
      v46 = v36->size;
      if ( v42 == -1 )
      {
        v67 = &v36->size;
        if ( v46 && v36->p )
          free(v36->p);
        v48 = 0;
        v49 = 0;
        v36->p = 0;
        v36->size = 0;
        v36->fill = 0;
        if ( v41 )
          goto LABEL_75;
      }
      else
      {
LABEL_70:
        v49 = v36->p;
        v67 = p_size;
        if ( v46 != v48 )
        {
          if ( v49 )
          {
            v49 = realloc(v49, v48);
            if ( v49 )
              goto LABEL_73;
LABEL_94:
            if ( v36->p )
              free(v36->p);
            v59 = 0;
            v36->p = 0;
            v36->size = 0;
LABEL_92:
            v36->fill = v59;
            __asm { POP             {R4-R7,PC} }
          }
          v49 = malloc(v48);
          if ( !v49 )
            goto LABEL_94;
LABEL_73:
          v36->p = v49;
          v36->size = v48;
        }
        if ( v41 )
        {
LABEL_75:
          v50 = 0;
          v66 = v36;
          while ( 1 )
          {
            v51 = v69[0][v50 + v38];
            v52 = v69[0][v50 + v39] | (v51 << 8);
            if ( ((v51 << 8) & 0xD800) == 55296 )
              break;
            if ( v52 >= 0x80 )
            {
              if ( v52 >> 11 )
              {
                v54 = 2;
                v56 = (v52 >> 6) & 0x3F | 0x80;
                *v49 = (v69[0][v50 + v38] >> 4) | 0xE0;
                v53 = v49 + 1;
                v55 = 3;
              }
              else
              {
                v56 = (v52 >> 6) | 0xC0;
                v55 = 2;
                v54 = 1;
                v53 = v49;
              }
              goto LABEL_83;
            }
            v55 = 1;
            v57 = v49;
LABEL_84:
            v50 += 2;
            v49 += v55;
            *v57 = v52;
            if ( v50 >= v41 )
            {
              v58 = v67;
              v36 = v66;
              v48 = *v67;
              v49 = v66->p;
              goto LABEL_91;
            }
          }
          v50 += 2;
          v53 = v49 + 2;
          v54 = 3;
          v55 = 4;
          v52 = ((v69[0][v50 + v38] << 8) & 0x300 | v69[0][v50 + v39] | ((v52 & 0x3FF) << 10)) + 0x10000;
          v56 = (v52 >> 6) & 0x3F | 0x80;
          v49[1] = (v52 >> 12) & 0x3F | 0x80;
          *v49 = (v52 >> 18) | 0xF0;
LABEL_83:
          LOBYTE(v52) = v52 & 0x3F | 0x80;
          v57 = &v49[v54];
          *v53 = v56;
          goto LABEL_84;
        }
      }
      v58 = v67;
LABEL_91:
      v49[v48 - 1] = 0;
      v59 = *v58;
      goto LABEL_92;
    case 3:
      v74 = v72;
      v60 = v15;
      v61 = v13;
      v62 = v15->size;
      v63 = v8 + 1;
      if ( v8 == -1 )
      {
        if ( v62 )
        {
          v65 = v15->p;
          if ( v60->p )
            free(v65);
        }
        v64 = 0;
        v60->p = 0;
        v60->size = 0;
        v60->fill = 0;
        goto LABEL_106;
      }
      v64 = v15->p;
      if ( v62 == v63 )
        goto LABEL_106;
      if ( v64 )
      {
        v64 = (unsigned __int8 *)realloc(v64, v8 + 1);
        if ( v64 )
        {
LABEL_101:
          v60->p = v64;
          v60->size = v63;
LABEL_106:
          qmemcpy(v64, v61, v8);
          v60->p[v8] = 0;
          goto LABEL_107;
        }
      }
      else
      {
        v64 = (unsigned __int8 *)malloc(v8 + 1);
        if ( v64 )
          goto LABEL_101;
      }
      if ( v60->p )
        free(v60->p);
      v63 = 0;
      v60->p = 0;
      v60->size = 0;
LABEL_107:
      v60->fill = v63;
      return;
    default:
      if ( v72 )
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Unknown text encoding %u, I take n"
          "o chances, sorry!\n",
          227,
          v76);
      if ( *(_DWORD *)v73 )
        free(*(void **)v73);
      *(_DWORD *)v73 = 0;
      *((_DWORD *)v16 + 1) = 0;
      *((_DWORD *)v16 + 2) = 0;
      return;
  }
}
// 23AD5A: variable 'v6' is possibly undefined
// 23AE50: variable 'v5' is possibly undefined

//----- (00227048) --------------------------------------------------------
void __fastcall mpg123_free_string(mpg123_string *sb)
{
  unsigned __int8 *p; // r0

  p = sb->p;
  if ( p )
    free(p);
  sb->p = 0;
  sb->size = 0;
  sb->fill = 0;
}

//----- (00227064) --------------------------------------------------------
int __fastcall INT123_parse_new_id3(mpg123_handle *fr, unsigned int first4bytes)
{
  unsigned __int8 v2; // r6
  int v4; // r11
  int v5; // r5
  int v6; // r4
  int flags; // r8
  int v8; // r9
  int v9; // r0
  unsigned __int8 *v10; // r0
  unsigned __int8 *v11; // r6
  unsigned __int8 *v12; // r8
  unsigned int v13; // r12
  int v14; // r3
  int v15; // r0
  reader **v16; // r6
  int v17; // r0
  int v19; // r5
  int v20; // r6
  int v21; // r2
  unsigned int v22; // r4
  mpg123_id3v2 *p_id3v2; // lr
  __int16 v24; // r0
  __int16 v25; // r1
  unsigned int v26; // r6
  __int16 v27; // r1
  unsigned int v28; // r4
  const char *v29; // r5
  char *v30; // r3
  unsigned int v31; // r9
  char v32; // r5
  bool v33; // zf
  int v34; // r0
  int v35; // r2
  int v36; // r4
  int v37; // r5
  char *v38; // r0
  unsigned int v39; // r1
  unsigned int v40; // r2
  unsigned __int8 v41; // r3
  char *v42; // r0
  size_t v43; // r1
  char *v44; // r5
  unsigned int v45; // r0
  int v46; // r1
  const unsigned __int8 *v47; // r9
  const unsigned __int8 *v48; // r5
  unsigned __int8 v49; // r8
  int v50; // r6
  unsigned int v51; // r2
  unsigned int v52; // r6
  char *v53; // r0
  _BOOL4 v54; // r0
  int v55; // r9
  char *v56; // r0
  int *v57; // r5
  char *v58; // r0
  float v59; // s0
  mpg123_string *v60; // r5
  size_t *v61; // r1
  size_t *v62; // r3
  size_t v63; // r1
  char *v64; // r0
  char *v65; // r8
  __int16 v66; // r1
  unsigned int v67; // r0
  unsigned __int8 *v68; // r5
  unsigned __int8 *v69; // r4
  unsigned int v70; // r1
  int v71; // r3
  unsigned int v72; // r3
  size_t v73; // r6
  size_t v74; // r9
  const char *v75; // r5
  int v76; // r0
  _DWORD *v77; // r5
  void *v78; // r0
  void *v79; // r0
  void *v80; // r0
  size_t v81; // r1
  void *v82; // r0
  size_t v83; // r1
  char *v84; // r6
  int v85; // r4
  size_t v86; // r9
  const char *v87; // r6
  int v88; // r0
  int v89; // r1
  float *v90; // r5
  int v91; // r4
  int v92; // r0
  float v93; // s0
  int v94; // r4
  unsigned int v95; // r1
  const char *v96; // r2
  unsigned int v97; // r1
  const char *v98; // r2
  const char *v99; // r2
  float *v100; // r6
  int v101; // r8
  int v102; // r0
  float v103; // s0
  int version; // r9
  signed int v105; // r5
  const char *v106; // r1
  signed int v107; // r0
  char v108; // r2
  unsigned int v109; // r6
  unsigned int v110; // r6
  unsigned __int8 *v111; // r1
  int v112; // r0
  int v113; // r2
  int v114; // r1
  int v115; // r0
  int v116; // r2
  int v117; // r3
  int v118; // r3
  int v119; // r2
  int v120; // r3
  unsigned __int8 *source; // [sp+10h] [bp-148h]
  int v122; // [sp+14h] [bp-144h]
  const unsigned __int8 *source_size; // [sp+18h] [bp-140h]
  unsigned __int8 *v124; // [sp+1Ch] [bp-13Ch]
  unsigned __int8 *v125; // [sp+1Ch] [bp-13Ch]
  int v126; // [sp+20h] [bp-138h]
  __int16 v127; // [sp+24h] [bp-134h]
  char *v128; // [sp+24h] [bp-134h]
  void **p_extra; // [sp+9Ch] [bp-BCh]
  size_t *p_extras; // [sp+A0h] [bp-B8h]
  void **p_comment_list; // [sp+A4h] [bp-B4h]
  size_t *p_comments; // [sp+ACh] [bp-ACh]
  void **p_text; // [sp+B4h] [bp-A4h]
  size_t *p_texts; // [sp+B8h] [bp-A0h]
  unsigned int v135; // [sp+C4h] [bp-94h]
  unsigned int v136; // [sp+C4h] [bp-94h]
  mpg123_pars_struct *v137; // [sp+D0h] [bp-88h]
  int byte_count; // [sp+D4h] [bp-84h]
  size_t byte_counta; // [sp+D4h] [bp-84h]
  unsigned int v140; // [sp+D8h] [bp-80h]
  unsigned int v141; // [sp+E0h] [bp-78h]
  char v142; // [sp+E4h] [bp-74h]
  int *p_flags; // [sp+E8h] [bp-70h]
  mpg123_pars_struct *p_p; // [sp+ECh] [bp-6Ch]
  reader **p_rd; // [sp+F0h] [bp-68h]
  char v146[4]; // [sp+F4h] [bp-64h] BYREF
  char v147; // [sp+F8h] [bp-60h]
  char v148[2]; // [sp+FAh] [bp-5Eh] BYREF
  unsigned __int8 v149; // [sp+FCh] [bp-5Ch]
  unsigned __int8 v150; // [sp+FDh] [bp-5Bh]
  unsigned __int8 v151; // [sp+FEh] [bp-5Ah]
  unsigned __int8 v152; // [sp+FFh] [bp-59h]
  int v153; // [sp+100h] [bp-58h]
  __int16 v154; // [sp+104h] [bp-54h]
  char v155; // [sp+106h] [bp-52h]
  __int64 v156; // [sp+108h] [bp-50h] BYREF
  __int64 v157; // [sp+110h] [bp-48h] BYREF
  int v158; // [sp+118h] [bp-40h]
  int v159; // [sp+11Ch] [bp-3Ch]

  v2 = first4bytes;
  v4 = (unsigned __int8)first4bytes;
  if ( (unsigned __int8)first4bytes == 255 )
    return 0;
  v5 = fr->rd->read_frame_body(fr, (unsigned __int8 *)v148, 6);
  if ( v5 < 0 )
    return v5;
  if ( (unsigned __int8)v148[0] == 255 )
    return 0;
  if ( ((v150 | v149 | v151 | v152) & 0x80u) != 0 )
  {
    if ( (fr->p.flags & 0x20) == 0 )
    {
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Bad tag length (not synchsafe): 0x%0"
        "2x%02x%02x%02x; You got a bad ID3 tag here.\n",
        583,
        v149,
        v150,
        v151,
        v152);
      return 0;
    }
    return 0;
  }
  p_rd = &fr->rd;
  v6 = (unsigned __int8)v148[1];
  flags = fr->p.flags;
  p_flags = &fr->p.flags;
  p_p = &fr->p;
  v8 = (v150 << 14) | (v149 << 21) | (v151 << 7) | v152;
  if ( (flags & 0x20) != 0 || fr->p.verbose < 2 )
  {
    v9 = fr->p.flags & 0x2000;
    if ( (flags & 0x2000) != 0 )
      goto LABEL_26;
  }
  else
  {
    fprintf((FILE *)stderr, "Note: ID3v2.%i rev %i tag of %lu bytes\n", v4, (unsigned __int8)v148[0], v8);
    flags = *p_flags;
    v9 = *p_flags & 0x2000;
    if ( v9 )
      goto LABEL_26;
  }
  if ( (unsigned int)(v4 - 2) > 2 || (v6 & 0xF) != 0 )
  {
LABEL_26:
    if ( (flags & 0x20) == 0 )
    {
      if ( v9 )
      {
        if ( p_p->verbose >= 3 )
          fwrite("Note: Skipping ID3v2 tag per user request.\n", 0x2Bu, 1u, (FILE *)stderr);
      }
      else
      {
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] warning: ID3v2: Won't parse the ID3v2 tag"
          " with major version %u and flags 0x%xu - some extra code may be needed\n",
          599,
          v4,
          v6);
      }
    }
    v16 = &fr->rd;
    v5 = (*p_rd)->skip_bytes(fr, v8);
    if ( v5 >= 0 )
      v5 = 1;
    if ( (v6 & 0x10) == 0 )
      return v5;
LABEL_33:
    if ( v5 >= 1 )
    {
      v17 = (*v16)->skip_bytes(fr, v8);
      if ( v17 < 0 )
        return v17;
    }
    return v5;
  }
  v142 = v6;
  fr->id3v2.version = v2;
  v10 = (unsigned __int8 *)malloc(v8 + 1);
  v11 = v10;
  if ( !v10 )
  {
    if ( (flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: ID3v2: Arrg! Unable to allocate %lu "
        "bytes for interpreting ID3v2 data - trying to skip instead.\n",
        815,
        v8);
    v15 = (*p_rd)->skip_bytes(fr, v8);
    return v15 & (v15 >> 31);
  }
  v5 = (*p_rd)->read_frame_body(fr, v10, v8);
  v12 = v11;
  if ( v5 < 1 )
  {
    if ( !v8 )
      goto LABEL_309;
    v16 = &fr->rd;
    if ( v5 != -10 && (*p_flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: ID3v2: Duh, not able to read ID3v2 tag data.\n",
        807);
    goto LABEL_310;
  }
  v13 = 0;
  v11[v8] = 0;
  if ( (v6 & 0x40) != 0 )
  {
    v14 = *v11;
    if ( v4 == 3 )
    {
      v13 = _byteswap_ulong(*(_DWORD *)v11);
    }
    else
    {
      v19 = v11[1];
      v20 = v11[2];
      v21 = v12[3];
      if ( ((v19 | v14 | v20 | v21) & 0x80u) != 0 )
      {
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Bad (non-synchsafe) tag offset: "
            "0x%02x%02x%02x%02x\n",
            626,
            v14,
            v12[1],
            v20,
            v21);
        v5 = 0;
        goto LABEL_309;
      }
      v13 = (v19 << 14) | (v14 << 21) | (v20 << 7) | v21;
    }
  }
  v141 = v8;
  v22 = v8 - 10;
  v147 = 0;
  if ( v13 >= v8 - 10 )
    goto LABEL_308;
  v137 = &fr->p;
  p_id3v2 = &fr->id3v2;
  p_extras = &fr->id3v2.extras;
  p_extra = (void **)&fr->id3v2.extra;
  p_comments = &fr->id3v2.comments;
  p_comment_list = (void **)&fr->id3v2.comment_list;
  p_texts = &fr->id3v2.texts;
  p_text = (void **)&fr->id3v2.text;
  while ( 2 )
  {
    version = p_id3v2->version;
    v105 = 4;
    v106 = (const char *)&v12[v13];
    v107 = 0;
    if ( version == 2 )
      v105 = 3;
    do
    {
      v108 = v106[v107];
      if ( (unsigned __int8)(v108 - 48) >= 0xAu && (unsigned __int8)(v108 - 65) >= 0x1Au )
        goto LABEL_308;
      ++v107;
    }
    while ( v107 < v105 );
    v109 = v13;
    strncpy(v146, v106, v105);
    v110 = v109 + v105;
    v111 = &v12[v110];
    v112 = v12[v110];
    if ( p_id3v2->version == 2 )
    {
      v113 = v111[1];
      v114 = v111[2];
      v115 = (v113 << 8) | (v112 << 16);
    }
    else if ( v4 == 3 )
    {
      v116 = v111[1];
      v117 = v111[2];
      v114 = v111[3];
      v115 = (v116 << 16) | (v112 << 24) | (v117 << 8);
    }
    else
    {
      v118 = v111[1];
      v119 = v111[2];
      v114 = v111[3];
      if ( ((v118 | v112 | v119 | v114) & 0x80u) != 0 )
      {
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: ID3v2: non-syncsafe size of %s f"
            "rame, skipping the remainder of tag\n",
            665,
            v146);
        break;
      }
      v115 = (v118 << 14) | (v112 << 21) | (v119 << 7);
    }
    v120 = v115 | v114;
    byte_count = v115 | v114;
    if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
    {
      fprintf((FILE *)stderr, "Note: ID3v2 %s frame of size %lu\n", v146, v120);
      v120 = byte_count;
    }
    v26 = v110 + v105;
    v13 = v26 + v120;
    if ( v26 + v120 > v141 )
    {
      if ( (*(_BYTE *)p_flags & 0x20) == 0 )
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Whoa! ID3v2 frame claims to be lar"
          "ger than the whole rest of the tag.\n",
          672);
      break;
    }
    if ( p_id3v2->version < 3u )
    {
      v27 = 0;
    }
    else
    {
      v24 = v12[v26];
      v13 += 2;
      v25 = v12[v26 + 1];
      v26 += 2;
      v27 = v25 | (v24 << 8);
    }
    v140 = v13;
    if ( version != 2 )
      goto LABEL_54;
    v135 = v22;
    v28 = 0;
    v127 = v27;
    do
    {
      v29 = (const char *)*(&off_660BE0 + v28);
      if ( !strncmp(v146, v29, 3u) )
      {
        v30 = off_660C74[v28];
        v22 = v135;
        *(_DWORD *)v146 = *(_DWORD *)v30;
        v13 = v140;
        v27 = v127;
        if ( (*(_BYTE *)p_flags & 0x20) == 0 && v137->verbose >= 3 )
        {
          fprintf((FILE *)stderr, "Translated ID3v2.2 frame %s to %s\n", v29, v30);
          v27 = v127;
          v13 = v140;
        }
LABEL_54:
        if ( (v27 & 0x8FBC) != 0 )
        {
          if ( (*(_BYTE *)p_flags & 0x20) != 0 )
            goto LABEL_284;
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] warning: ID3v2: skipping invalid/unsupported frame\n",
            700);
LABEL_283:
          v13 = v140;
          goto LABEL_284;
        }
        v31 = v22;
        v32 = v27;
        if ( !strncmp((const char *)frame_type, v146, 4u) )
        {
          v34 = 0;
        }
        else if ( !strncmp((const char *)frame_type[1], v146, 4u) )
        {
          v34 = 1;
        }
        else if ( !strncmp((const char *)frame_type[2], v146, 4u) )
        {
          v34 = 2;
        }
        else
        {
          v33 = strncmp((const char *)frame_type[3], v146, 4u) == 0;
          v34 = -2;
          if ( v33 )
            v34 = 3;
        }
        v35 = v34;
        if ( v146[0] == 84 )
          v35 = -1;
        if ( v34 == 1 )
          v35 = 1;
        v13 = v140;
        if ( v35 == -2 )
          goto LABEL_284;
        v128 = (char *)&v12[v26];
        v126 = v32 & 2 | v142 & 0x80;
        if ( v126 )
        {
          v36 = byte_count;
          v37 = v35;
          v38 = (char *)malloc(byte_count);
          if ( !v38 )
          {
            v22 = v31;
            v13 = v140;
            if ( (*(_BYTE *)p_flags & 0x20) != 0 )
              goto LABEL_284;
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: ID3v2: unable to allocate work"
              "ing buffer for de-unsync\n",
              725);
            v22 = v31;
            goto LABEL_283;
          }
          byte_count = 1;
          *v38 = *v128;
          v39 = v26 + v36;
          v13 = v140;
          v22 = v31;
          while ( 1 )
          {
            v40 = v26 + 1;
            if ( v26 + 1 >= v39 )
              break;
            v41 = v12[v26 + 1];
            if ( !v41 )
            {
              v33 = v12[v26++] == 255;
              if ( v33 )
                continue;
            }
            v38[byte_count++] = v41;
            v26 = v40;
          }
          v35 = v37;
          v128 = v38;
        }
        v136 = v22;
        switch ( v35 )
        {
          case -1:
            if ( *p_text )
            {
              v42 = (char *)realloc(*p_text, 32 * *p_texts + 32);
              if ( v42 )
              {
LABEL_90:
                *p_text = v42;
                v43 = (*p_texts)++;
                v44 = &v42[32 * v43];
                *(_DWORD *)v44 = 0;
                v44[6] = 0;
                *((_WORD *)v44 + 2) = 0;
                *((_DWORD *)v44 + 6) = 0;
                *((_DWORD *)v44 + 7) = 0;
                *((_QWORD *)v44 + 1) = 0LL;
                *((_QWORD *)v44 + 2) = 0LL;
                goto LABEL_133;
              }
            }
            else
            {
              v42 = (char *)malloc(32 * *p_texts + 32);
              if ( v42 )
                goto LABEL_90;
            }
            v44 = 0;
LABEL_133:
            if ( (*(_BYTE *)p_flags & 0x20) != 0 || p_p->verbose < 4 )
            {
              if ( v44 )
                goto LABEL_136;
            }
            else
            {
              v95 = *v128;
              if ( v95 > 3 )
                v96 = "unknown!";
              else
                v96 = off_660E5C[v95];
              fprintf((FILE *)stderr, "Note: Storing text from %s encoding\n", v96);
              if ( v44 )
              {
LABEL_136:
                *(_DWORD *)(v44 + 3) = *(_DWORD *)v146;
                v60 = (mpg123_string *)(v44 + 20);
                store_id3_text(
                  v60,
                  (unsigned __int8 *)v128,
                  byte_count,
                  (((unsigned int)*p_flags >> 5) & 1) == 0,
                  *p_flags & 0x800);
                v13 = v140;
                if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 4 )
                {
                  fprintf(
                    (FILE *)stderr,
                    "Note: ID3v2 %c%c%c%c text frame: %s\n",
                    (unsigned __int8)v146[0],
                    (unsigned __int8)v146[1],
                    (unsigned __int8)v146[2],
                    (unsigned __int8)v146[3],
                    v60->p);
                  goto LABEL_280;
                }
                goto LABEL_281;
              }
            }
            v13 = v140;
            if ( (*(_BYTE *)p_flags & 0x20) == 0 )
            {
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Unable to attach new text!\n",
                302);
              goto LABEL_280;
            }
            goto LABEL_281;
          case 0:
          case 3:
            v124 = v12;
            if ( byte_count <= 3 )
            {
              if ( (*(_BYTE *)p_flags & 0x20) == 0 )
              {
                fprintf(
                  (FILE *)stderr,
                  "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Invalid frame size of %lu "
                  "(too small for anything).\n",
                  327,
                  byte_count);
LABEL_178:
                v13 = v140;
                v12 = v124;
                goto LABEL_281;
              }
              goto LABEL_225;
            }
            v55 = (unsigned __int8)*v128;
            v122 = v35;
            source_size = (const unsigned __int8 *)(v128 + 4);
            if ( v35 == 3 )
            {
              if ( *p_text )
              {
                v56 = (char *)realloc(*p_text, 32 * *p_texts + 32);
                if ( !v56 )
                  goto LABEL_146;
                goto LABEL_142;
              }
              v56 = (char *)malloc(32 * *p_texts + 32);
              if ( v56 )
              {
LABEL_142:
                *p_text = v56;
                v61 = &fr->id3v2.texts;
LABEL_145:
                v62 = v61;
                v63 = *v61;
                *v62 = v63 + 1;
                *(_DWORD *)&v56[32 * v63] = 0;
                v64 = &v56[32 * v63];
                v64[6] = 0;
                v65 = v64;
                *((_WORD *)v64 + 2) = 0;
                *((_DWORD *)v64 + 6) = 0;
                *((_DWORD *)v64 + 7) = 0;
                v64 += 8;
                *(_QWORD *)v64 = 0LL;
                *((_QWORD *)v64 + 1) = 0LL;
LABEL_147:
                if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 4 )
                {
                  v97 = *v128;
                  if ( v97 > 3 )
                    v98 = "unknown!";
                  else
                    v98 = off_660E5C[v97];
                  fprintf((FILE *)stderr, "Note: Storing comment from %s encoding\n", v98);
                }
                if ( !v65 )
                {
                  v13 = v140;
                  if ( (*(_BYTE *)p_flags & 0x20) == 0 )
                  {
                    fprintf(
                      (FILE *)stderr,
                      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Unable to attach new comment!\n",
                      334);
                    goto LABEL_178;
                  }
                  goto LABEL_225;
                }
                v66 = *(_WORD *)(v128 + 1);
                v65[2] = v128[3];
                *(_WORD *)v65 = v66;
                *(_DWORD *)(v65 + 3) = *(_DWORD *)v146;
                v67 = byte_count - 4;
                v128[3] = v55;
                v68 = (unsigned __int8 *)(v128 + 3);
                v69 = (unsigned __int8 *)(v128 + 4);
                if ( byte_count - 4 >= 1 )
                {
                  v69 = (unsigned __int8 *)(v128 + 4);
                  v70 = encoding_widths[v55];
                  v71 = 0;
                  do
                  {
                    if ( *v69 )
                    {
                      v69 += v70;
                    }
                    else
                    {
                      if ( v70 > v67 - v71 )
                        goto LABEL_179;
                      v72 = 1;
                      if ( (unsigned int)(v55 - 1) <= 1 )
                      {
                        do
                        {
                          if ( v69[v72] )
                            break;
                          ++v72;
                        }
                        while ( v72 < v70 );
                      }
                      v69 += v70;
                      if ( v72 == v70 )
                        break;
                    }
                    v71 = v69 - source_size;
                  }
                  while ( v69 - source_size < (int)v67 );
                }
                if ( !v69 || (v73 = v69 - source_size, v69 - source_size >= v67) )
                {
LABEL_179:
                  if ( (*(_BYTE *)p_flags & 0x20) == 0 )
                    fprintf(
                      (FILE *)stderr,
                      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: No comment text / vali"
                      "d description?\n",
                      345);
                  v13 = v140;
                  if ( !*p_comments )
                    goto LABEL_225;
                  v77 = (char *)*p_comment_list + 32 * *p_comments - 32;
                  v78 = (void *)v77[5];
                  if ( v78 )
                    free(v78);
                  v77[5] = 0;
                  v79 = (void *)v77[2];
                  v77[6] = 0;
                  v77[7] = 0;
                  if ( v79 )
                    free(v79);
                  v77[2] = 0;
                  v77[3] = 0;
                  v77[4] = 0;
                  v80 = *p_comment_list;
                  if ( *p_comments >= 2 )
                  {
                    v81 = 32 * *p_comments - 32;
                    if ( v80 )
                      v82 = realloc(v80, v81);
                    else
                      v82 = malloc(v81);
                    v13 = v140;
                    if ( v82 )
                    {
                      *p_comment_list = v82;
                      --*p_comments;
                      v12 = v124;
                      goto LABEL_281;
                    }
LABEL_225:
                    v12 = v124;
LABEL_281:
                    v22 = v136;
                    if ( !v126 )
                      goto LABEL_284;
                    free(v128);
                    goto LABEL_283;
                  }
                  free(v80);
                  *p_comment_list = 0;
                  *p_comments = 0;
LABEL_224:
                  v13 = v140;
                  goto LABEL_225;
                }
                v155 = 0;
                v154 = 0;
                v153 = 0;
                v159 = 0;
                v156 = 0LL;
                v157 = 0LL;
                v158 = 0;
                source = v69;
                store_id3_text(
                  (mpg123_string *)(v65 + 8),
                  v68,
                  v73 + 1,
                  (((unsigned int)*p_flags >> 5) & 1) == 0,
                  *p_flags & 0x800);
                if ( !v122 && v73 != -1 )
                {
                  v94 = (((unsigned int)*p_flags >> 5) & 1) == 0;
                  j_INT123_id3_to_utf8((mpg123_string *)&v156, *v68, source_size, v73, v94);
                  if ( v94 )
                  {
                    if ( !(_DWORD)v157 )
                      fprintf(
                        (FILE *)stderr,
                        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: unable to convert st"
                        "ring to UTF-8 (out of memory, junk input?)!\n",
                        215);
                  }
                }
                *(source - 1) = v55;
                v74 = byte_count + v128 - (char *)source;
                store_id3_text(
                  (mpg123_string *)(v65 + 20),
                  source - 1,
                  v74 + 1,
                  (((unsigned int)*p_flags >> 5) & 1) == 0,
                  *p_flags & 0x800);
                if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 4 )
                {
                  fprintf((FILE *)stderr, "Note: ID3 comm/uslt desc of length %lu.\n", *((_DWORD *)v65 + 4));
                  fprintf((FILE *)stderr, "Note: ID3 comm/uslt text of length %lu.\n", *((_DWORD *)v65 + 7));
                }
                if ( (_DWORD)v157 && !v122 )
                {
                  v75 = (const char *)v156;
                  if ( !strcasecmp((const char *)v156, "rva")
                    || !strcasecmp(v75, "rva_mix")
                    || !strcasecmp(v75, "rva_track")
                    || !strcasecmp(v75, "rva_radio") )
                  {
                    v76 = 0;
                  }
                  else
                  {
                    if ( strcasecmp(v75, "rva_album")
                      && strcasecmp(v75, "rva_audiophile")
                      && strcasecmp(v75, "rva_user") )
                    {
                      goto LABEL_218;
                    }
                    v76 = 1;
                  }
                  v90 = (float *)(&fr->fresh + v76);
                  if ( *((int *)v90 + 9428) <= 1 )
                  {
                    if ( v74 != -1 )
                    {
                      v91 = (((unsigned int)*p_flags >> 5) & 1) == 0;
                      j_INT123_id3_to_utf8((mpg123_string *)((char *)&v157 + 4), *(source - 1), source, v74, v91);
                      v92 = v159;
                      if ( !v91 || v159 )
                      {
LABEL_213:
                        if ( v92 )
                        {
                          v93 = atof((const char *)HIDWORD(v157));
                          v90[9430] = v93;
                          if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
                            fprintf((FILE *)stderr, "Note: RVA value %fdB\n", v93);
                          v90[9432] = 0.0;
                          *((_DWORD *)v90 + 9428) = 1;
                        }
                        goto LABEL_218;
                      }
                      fprintf(
                        (FILE *)stderr,
                        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: unable to convert st"
                        "ring to UTF-8 (out of memory, junk input?)!\n",
                        215);
                    }
                    v92 = v159;
                    goto LABEL_213;
                  }
                }
LABEL_218:
                if ( HIDWORD(v157) )
                  free((void *)HIDWORD(v157));
                HIDWORD(v157) = 0;
                v158 = 0;
                v159 = 0;
                if ( (_DWORD)v156 )
                  free((void *)v156);
                v156 = 0LL;
                LODWORD(v157) = 0;
                goto LABEL_224;
              }
LABEL_146:
              v65 = 0;
              goto LABEL_147;
            }
            if ( *p_comment_list )
            {
              v56 = (char *)realloc(*p_comment_list, 32 * *p_comments + 32);
              if ( !v56 )
                goto LABEL_146;
            }
            else
            {
              v56 = (char *)malloc(32 * *p_comments + 32);
              if ( !v56 )
                goto LABEL_146;
            }
            *p_comment_list = v56;
            v61 = &fr->id3v2.comments;
            goto LABEL_145;
          case 1:
            v125 = v12;
            if ( byte_count <= 0 )
            {
              if ( (*(_BYTE *)p_flags & 0x20) == 0 )
                fprintf(
                  (FILE *)stderr,
                  "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Invalid frame size of %lu "
                  "(too small for anything).\n",
                  409,
                  byte_count);
            }
            else
            {
              v45 = byte_count - 1;
              v47 = (const unsigned __int8 *)(v128 + 1);
              v46 = *v128;
              v48 = (const unsigned __int8 *)(v128 + 1);
              v49 = *v128;
              if ( byte_count - 1 >= 1 )
              {
                v50 = 0;
                v48 = (const unsigned __int8 *)(v128 + 1);
                v51 = encoding_widths[(unsigned __int8)v46];
                do
                {
                  if ( *v48 )
                  {
                    v48 += v51;
                  }
                  else
                  {
                    if ( v51 > v45 - v50 )
                    {
                      v48 = 0;
                      goto LABEL_104;
                    }
                    v52 = 1;
                    if ( (unsigned int)(unsigned __int8)v46 - 1 <= 1 )
                    {
                      do
                      {
                        if ( v48[v52] )
                          break;
                        ++v52;
                      }
                      while ( v52 < v51 );
                    }
                    v48 += v51;
                    if ( v52 == v51 )
                      break;
                  }
                  v50 = v48 - v47;
                }
                while ( v48 - v47 < (int)v45 );
              }
              if ( v48 - v47 >= v45 )
                v48 = 0;
LABEL_104:
              if ( (*(_BYTE *)p_flags & 0x20) != 0 || p_p->verbose < 4 )
              {
                if ( v48 )
                  goto LABEL_107;
              }
              else
              {
                if ( (unsigned __int8)v46 > 3u )
                  v99 = "unknown!";
                else
                  v99 = off_660E5C[v46];
                fprintf((FILE *)stderr, "Note: Storing extra from %s encoding\n", v99);
                if ( v48 )
                {
LABEL_107:
                  if ( *p_extra )
                  {
                    v53 = (char *)realloc(*p_extra, 32 * *p_extras + 32);
                    if ( !v53 )
                    {
LABEL_204:
                      if ( (*(_BYTE *)p_flags & 0x20) == 0 )
                        fprintf(
                          (FILE *)stderr,
                          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Unable to attach n"
                          "ew extra text!\n",
                          422);
                      goto LABEL_279;
                    }
                  }
                  else
                  {
                    v53 = (char *)malloc(32 * *p_extras + 32);
                    if ( !v53 )
                      goto LABEL_204;
                  }
                  *p_extra = v53;
                  v83 = (*p_extras)++;
                  v84 = &v53[32 * v83];
                  *(_DWORD *)v84 = 0;
                  v84[6] = 0;
                  *((_WORD *)v84 + 2) = 0;
                  *((_DWORD *)v84 + 6) = 0;
                  *((_DWORD *)v84 + 7) = 0;
                  *((_QWORD *)v84 + 1) = 0LL;
                  *((_QWORD *)v84 + 2) = 0LL;
                  if ( !v84 )
                    goto LABEL_204;
                  *(_DWORD *)(v84 + 3) = *(_DWORD *)v146;
                  v155 = 0;
                  v154 = 0;
                  v153 = 0;
                  v159 = 0;
                  v156 = 0LL;
                  v157 = 0LL;
                  v158 = 0;
                  store_id3_text(
                    (mpg123_string *)(v84 + 8),
                    (unsigned __int8 *)v128,
                    v48 - (const unsigned __int8 *)v128,
                    (((unsigned int)*p_flags >> 5) & 1) == 0,
                    *p_flags & 0x800);
                  if ( v48 - v47 != -1 )
                  {
                    v85 = (((unsigned int)*p_flags >> 5) & 1) == 0;
                    j_INT123_id3_to_utf8((mpg123_string *)&v156, *v128, v47, v48 - v47, v85);
                    if ( v85 )
                    {
                      if ( !(_DWORD)v157 )
                        fprintf(
                          (FILE *)stderr,
                          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: unable to convert "
                          "string to UTF-8 (out of memory, junk input?)!\n",
                          215);
                    }
                  }
                  *((_BYTE *)v48 - 1) = v49;
                  v86 = v128 - (char *)v48 + byte_count;
                  store_id3_text(
                    (mpg123_string *)(v84 + 20),
                    (unsigned __int8 *)v48 - 1,
                    v86 + 1,
                    (((unsigned int)*p_flags >> 5) & 1) == 0,
                    *p_flags & 0x800);
                  if ( !(_DWORD)v157 )
                    goto LABEL_274;
                  v87 = (const char *)v156;
                  if ( !strncasecmp((const char *)v156, "replaygain_track_", 0x11u) )
                  {
                    if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
                    {
                      fwrite("Note: RVA ReplayGain track gain/peak\n", 0x25u, 1u, (FILE *)stderr);
                      v87 = (const char *)v156;
                    }
                    if ( strcasecmp(v87, "replaygain_track_peak") )
                    {
                      if ( strcasecmp(v87, "replaygain_track_gain") )
                        goto LABEL_274;
                      byte_counta = 0;
                      v88 = 0;
                      goto LABEL_259;
                    }
                    v88 = 0;
                    v89 = 1;
                  }
                  else
                  {
                    if ( strncasecmp(v87, "replaygain_album_", 0x11u) )
                      goto LABEL_274;
                    if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
                    {
                      fwrite("Note: RVA ReplayGain album gain/peak\n", 0x25u, 1u, (FILE *)stderr);
                      v87 = (const char *)v156;
                    }
                    if ( !strcasecmp(v87, "replaygain_album_peak") )
                    {
                      byte_counta = 1;
                      v88 = 1;
LABEL_259:
                      v100 = (float *)(&fr->fresh + v88);
                      if ( *((int *)v100 + 9428) <= 2 )
                      {
                        if ( v86 != -1 )
                        {
                          v101 = (((unsigned int)*p_flags >> 5) & 1) == 0;
                          j_INT123_id3_to_utf8((mpg123_string *)((char *)&v157 + 4), *(v48 - 1), v48, v86, v101);
                          v102 = v159;
                          if ( !v101 || v159 )
                          {
LABEL_265:
                            if ( v102 )
                            {
                              v103 = atof((const char *)HIDWORD(v157));
                              if ( byte_counta )
                              {
                                v100[9432] = v103;
                                if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
                                  fprintf((FILE *)stderr, "Note: RVA peak %f\n", v103);
                              }
                              else
                              {
                                v100[9430] = v103;
                                if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
                                  fprintf((FILE *)stderr, "Note: RVA gain %fdB\n", v103);
                              }
                              *((_DWORD *)v100 + 9428) = 2;
                            }
                            goto LABEL_274;
                          }
                          fprintf(
                            (FILE *)stderr,
                            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: unable to conver"
                            "t string to UTF-8 (out of memory, junk input?)!\n",
                            215);
                        }
                        v102 = v159;
                        goto LABEL_265;
                      }
LABEL_274:
                      if ( HIDWORD(v157) )
                        free((void *)HIDWORD(v157));
                      HIDWORD(v157) = 0;
                      v158 = 0;
                      v159 = 0;
                      if ( (_DWORD)v156 )
                        free((void *)v156);
                      v156 = 0LL;
                      LODWORD(v157) = 0;
                      goto LABEL_279;
                    }
                    if ( strcasecmp(v87, "replaygain_album_gain") )
                      goto LABEL_274;
                    v88 = 1;
                    v89 = 0;
                  }
                  byte_counta = v89;
                  goto LABEL_259;
                }
              }
              if ( (*(_BYTE *)p_flags & 0x20) == 0 )
                fprintf(
                  (FILE *)stderr,
                  "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: No extra frame text / vali"
                  "d description?\n",
                  416);
            }
LABEL_279:
            v12 = v125;
LABEL_280:
            v13 = v140;
            goto LABEL_281;
          case 2:
            v125 = v12;
            if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
              fprintf((FILE *)stderr, "Note: RVA2 identification \"%s\"\n", v128);
            v54 = !strncasecmp(v128, "album", 5u)
               || !strncasecmp(v128, "audiophile", 0xAu)
               || !strncasecmp(v128, "user", 4u);
            v57 = &fr->fresh + v54;
            v13 = v140;
            if ( v57[9428] > 3 )
              goto LABEL_281;
            v58 = &v128[strlen(v128)];
            v13 = v140;
            if ( v58[1] != 1 )
              goto LABEL_281;
            v59 = (float)((unsigned __int8)v58[3] | (v58[2] << 8)) * 0.0019531;
            *((float *)v57 + 9430) = v59;
            if ( (*(_BYTE *)p_flags & 0x20) == 0 && p_p->verbose >= 3 )
              fprintf((FILE *)stderr, "Note: RVA value %fdB\n", v59);
            v57[9432] = 0;
            v57[9428] = 3;
            goto LABEL_279;
          default:
            if ( (*(_BYTE *)p_flags & 0x20) != 0 )
              goto LABEL_281;
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: ID3v2: unknown frame type %i\n",
              785,
              v35);
            goto LABEL_280;
        }
      }
      ++v28;
    }
    while ( v28 < 0x25 );
    v22 = v135;
    v13 = v140;
    if ( (*(_BYTE *)p_flags & 0x20) == 0 && v137->verbose >= 3 )
    {
      fprintf(
        (FILE *)stderr,
        "Ignoring untranslated ID3v2.2 frame %c%c%c\n",
        (unsigned __int8)v146[0],
        (unsigned __int8)v146[1],
        (unsigned __int8)v146[2]);
      goto LABEL_283;
    }
LABEL_284:
    if ( v13 < v22 )
      continue;
    break;
  }
LABEL_308:
  v5 = 1;
  v8 = v141;
LABEL_309:
  LOBYTE(v6) = v142;
  v16 = &fr->rd;
LABEL_310:
  free(v12);
  if ( (v6 & 0x10) != 0 )
    goto LABEL_33;
  return v5;
}
// 660BE0: using guessed type void *off_660BE0;
// 660C74: using guessed type char *off_660C74[10];
// 660E5C: using guessed type char *off_660E5C[4];

//----- (002284DC) --------------------------------------------------------
void __fastcall INT123_fi_init(frame_index *fi)
{
  off_t *p_next; // r0

  fi->data = 0;
  fi->step = 1;
  p_next = &fi->next;
  *(_QWORD *)p_next = 0LL;
  *((_QWORD *)p_next + 1) = 0LL;
}

//----- (002284EE) --------------------------------------------------------
void __fastcall INT123_fi_exit(frame_index *fi)
{
  off_t *data; // r0

  if ( fi->size )
  {
    data = fi->data;
    if ( fi->data )
      free(data);
  }
  fi->data = 0;
  fi->step = 1;
  *(_QWORD *)&fi->next = 0LL;
  *(_QWORD *)&fi->fill = 0LL;
}

//----- (00228518) --------------------------------------------------------
int __fastcall INT123_fi_resize(frame_index *fi, size_t newsize)
{
  size_t size; // r0
  bool v6; // cc
  size_t i; // r0
  off_t step; // r1
  int v9; // r1
  size_t j; // r1
  off_t *v11; // r0
  size_t fill; // r1

  size = fi->size;
  if ( size == newsize )
    return 0;
  v6 = newsize != 0;
  if ( newsize )
    v6 = size > newsize;
  if ( v6 )
  {
    for ( i = fi->fill; i > newsize; fi->next = v9 * i )
    {
      while ( i <= 1 )
      {
        i = 1;
        if ( newsize )
          goto LABEL_18;
      }
      step = fi->step;
      fi->fill = i >> 1;
      v9 = 2 * step;
      fi->step = v9;
      if ( i >> 1 )
      {
        for ( j = 0; j < i; ++j )
        {
          fi->data[j] = fi->data[2 * j];
          i = fi->fill;
        }
        v9 = fi->step;
      }
      else
      {
        i = 0;
      }
    }
  }
LABEL_18:
  if ( fi->data )
  {
    v11 = (off_t *)realloc(fi->data, 4 * newsize);
    if ( !newsize )
      goto LABEL_23;
  }
  else
  {
    v11 = (off_t *)malloc(4 * newsize);
    if ( !newsize )
      goto LABEL_23;
  }
  if ( !v11 )
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/index.c:%i] error: failed to resize index!\n",
      82);
    return -1;
  }
LABEL_23:
  fi->size = newsize;
  fill = fi->fill;
  fi->data = v11;
  if ( fill > newsize )
  {
    fi->fill = newsize;
    fill = newsize;
  }
  fi->next = fi->step * fill;
  return 0;
}

//----- (002285D0) --------------------------------------------------------
void __fastcall INT123_fi_add(frame_index *fi, off_t pos)
{
  size_t fill; // r0
  size_t size; // r1
  __int64 v6; // kr00_8
  size_t grow_size; // r1
  int v8; // r6
  off_t step; // r1
  int v10; // r2
  size_t v11; // r1
  size_t v12; // r0
  off_t v13; // r0
  size_t v14; // r1

  v6 = *(_QWORD *)&fi->size;
  fill = fi->fill;
  size = v6;
  if ( fill != (_DWORD)v6 )
    goto LABEL_13;
  grow_size = fi->grow_size;
  v8 = fi->step * fill;
  if ( !grow_size )
    goto LABEL_5;
  if ( j_INT123_fi_resize(fi, grow_size + fill) )
  {
    fill = fi->fill;
LABEL_5:
    if ( fill >= 2 )
    {
      step = fi->step;
      fi->fill = fill >> 1;
      v10 = 2 * step;
      v11 = 0;
      fi->step = v10;
      if ( fill >> 1 )
      {
        v12 = 0;
        do
        {
          fi->data[v12] = fi->data[2 * v12];
          ++v12;
          v11 = fi->fill;
        }
        while ( v12 < v11 );
        v10 = fi->step;
      }
      fi->next = v11 * v10;
    }
  }
  if ( fi->next != v8 )
    return;
  fill = fi->fill;
  size = fi->size;
LABEL_13:
  if ( fill < size )
  {
    fi->data[fill] = pos;
    v13 = fi->step;
    v14 = fi->fill + 1;
    fi->fill = v14;
    fi->next = v13 * v14;
  }
}

//----- (00228652) --------------------------------------------------------
int __fastcall INT123_fi_set(frame_index *fi, off_t *offsets, off_t step, size_t fill)
{
  size_t v4; // r4

  v4 = fill;
  if ( j_INT123_fi_resize(fi, fill) == -1 )
    return -1;
  fi->step = step;
  if ( offsets )
  {
    qmemcpy(fi->data, offsets, 4 * v4);
    step = fi->step;
  }
  else
  {
    v4 = 0;
  }
  fi->fill = v4;
  fi->next = step * v4;
  return 0;
}

//----- (0022869E) --------------------------------------------------------
void __fastcall INT123_fi_reset(frame_index *fi)
{
  fi->fill = 0;
  fi->step = 1;
  fi->next = 0;
}

//----- (002286AA) --------------------------------------------------------
int __fastcall INT123_do_layer1(mpg123_handle *fr)
{
  int single; // r5
  int stereo; // r6
  int v3; // r9
  int *v4; // r12
  unsigned __int8 **v5; // lr
  unsigned int *v6; // r3
  int k; // r0
  int v8; // r4
  int v9; // r6
  int v10; // r2
  int v11; // r1
  int v12; // r1
  int v13; // r4
  int v14; // r8
  int v15; // r6
  int v16; // r2
  _DWORD *v17; // r4
  int v18; // r0
  int v19; // r2
  int v20; // r4
  int v21; // r8
  int v22; // r5
  int v23; // r6
  int v24; // lr
  _DWORD *v25; // r2
  char *v26; // r12
  int *v27; // r8
  unsigned __int8 **v28; // r10
  int v29; // r0
  int v30; // r6
  int v31; // r11
  int v32; // r1
  int v33; // r3
  int v34; // r3
  int v35; // r4
  int v36; // r11
  int v37; // r5
  int v38; // r6
  _DWORD *v39; // r10
  int *p_bitindex; // r11
  unsigned __int8 **p_wordpointer; // r8
  int i; // r1
  int v43; // r3
  int v44; // r6
  int v45; // r0
  int v46; // r5
  int v47; // r4
  char *v48; // lr
  int j; // r1
  int v50; // r3
  int v51; // r2
  int v52; // r6
  int v53; // r5
  int v54; // r4
  mpg123_handle *v55; // lr
  int v56; // r0
  int v58; // r2
  int v59; // r3
  int v60; // r6
  int v61; // r5
  int v62; // r4
  int v63; // r1
  int v64; // r3
  int v65; // r5
  int v66; // r4
  int v67; // r2
  int v68; // r2
  int v69; // r1
  int v70; // r12
  char *v71; // lr
  int v72; // r2
  int v73; // r6
  int v74; // r5
  int v75; // r10
  int v76; // r0
  int v77; // r9
  int v78; // r4
  int v79; // r3
  int v80; // r0
  int v81; // r9
  int v82; // r4
  int v83; // r6
  int v84; // r1
  int *v85; // r9
  char *v86; // r12
  int m; // r0
  int v88; // r2
  int v89; // r3
  int v90; // r5
  int v91; // r6
  int v92; // r1
  double *v93; // r3
  char *v94; // r12
  char *v95; // r2
  int n; // r0
  int v97; // r6
  int v98; // r5
  int v99; // t1
  int v100; // t1
  double v101; // d16
  int v102; // r3
  int v103; // r6
  int v104; // t1
  int v105; // r0
  int v106; // r4
  int v107; // r1
  int v108; // r2
  int v109; // r0
  double *v110; // r6
  int *v111; // r3
  char *v112; // r9
  char *v113; // r10
  int v114; // r5
  int v115; // lr
  double v116; // d16
  int v117; // r4
  int v118; // t1
  int v119; // t1
  double v120; // d17
  double *v121; // r0
  double v122; // d17
  int v123; // r4
  int v124; // r0
  int v125; // t1
  int v126; // t1
  int *v127; // r3
  double (*v128)[32]; // r6
  double (*v129)[32]; // r5
  int v130; // r0
  int v131; // r4
  int v132; // t1
  int v133; // t1
  int v134; // r2
  double v135; // d16
  int v136; // r1
  int v137; // r3
  int v138; // r1
  unsigned int v139; // r12
  int v140; // r0
  _QWORD *v141; // r3
  unsigned int v142; // r2
  _DWORD *v143; // r1
  int v144; // r0
  int v145; // r0
  int (__fastcall **p_synth_stereo)(double (*)[32], double (*)[32], mpg123_handle *); // [sp+0h] [bp-368h]
  int *p_jsbound; // [sp+4h] [bp-364h]
  int v149; // [sp+Ch] [bp-35Ch]
  func_synth_mono *p_synth_mono; // [sp+10h] [bp-358h]
  int *p_down_sample_sblimit; // [sp+18h] [bp-350h]
  int *p_stereo; // [sp+1Ch] [bp-34Ch]
  int v153; // [sp+20h] [bp-348h]
  double (*v154)[32]; // [sp+24h] [bp-344h]
  double (*fraction)[32]; // [sp+28h] [bp-340h]
  int v156; // [sp+2Ch] [bp-33Ch]
  int v157; // [sp+30h] [bp-338h]
  char v159[256]; // [sp+38h] [bp-330h] BYREF
  _DWORD v160[64]; // [sp+138h] [bp-230h] BYREF
  char v161[304]; // [sp+238h] [bp-130h] BYREF

  single = fr->single;
  stereo = fr->stereo;
  fraction = fr->layer1.fraction;
  if ( fr->mode == 1 )
    v3 = 4 * fr->mode_ext + 4;
  else
    v3 = 32;
  p_stereo = &fr->stereo;
  fr->jsbound = v3;
  p_jsbound = &fr->jsbound;
  if ( single == 3 )
    single = 0;
  if ( stereo == 1 )
    single = 0;
  v153 = single;
  if ( stereo != 2 )
  {
    p_bitindex = &fr->bitindex;
    p_wordpointer = &fr->wordpointer;
    for ( i = 0; i != 32; ++i )
    {
      v43 = *p_bitindex;
      v44 = **p_wordpointer;
      v45 = *p_bitindex + 4;
      v46 = (*p_wordpointer)[1];
      v47 = (*p_wordpointer)[2];
      *p_wordpointer += v45 >> 3;
      *p_bitindex = v45 & 7;
      v160[i] = ((v47 | ((v46 | (unsigned int)(v44 << 8)) << 8)) << v43 >> 20) & 0xF;
    }
    v48 = v159;
    for ( j = 0; j != 32; ++j )
    {
      if ( v160[j] )
      {
        v50 = *p_bitindex;
        v51 = *p_bitindex + 6;
        v52 = **p_wordpointer;
        v53 = (*p_wordpointer)[1];
        v54 = (*p_wordpointer)[2];
        *p_wordpointer += v51 >> 3;
        *p_bitindex = v51 & 7;
        *(_DWORD *)v48 = ((v54 | ((v53 | (unsigned int)(v52 << 8)) << 8)) << v50 >> 18) & 0x3F;
        v48 += 4;
      }
    }
    goto LABEL_39;
  }
  v4 = &fr->bitindex;
  v5 = &fr->wordpointer;
  v6 = v160;
  if ( v3 >= 1 )
  {
    for ( k = 0; k != v3; ++k )
    {
      v8 = *v4;
      v9 = *v4 + 4;
      v10 = (*v5)[2];
      v11 = (*v5)[1] | (**v5 << 8);
      *v5 += v9 >> 3;
      *v4 = v9 & 7;
      v160[2 * k] = ((v10 | (unsigned int)(v11 << 8)) << v8 >> 20) & 0xF;
      v12 = *v4;
      v13 = *v4 + 4;
      v14 = **v5;
      v15 = (*v5)[1];
      v16 = (*v5)[2];
      *v5 += v13 >> 3;
      *v4 = v13 & 7;
      v17 = &v160[2 * k];
      v17[1] = ((v16 | ((v15 | (unsigned int)(v14 << 8)) << 8)) << v12 >> 20) & 0xF;
    }
    if ( v3 > 31 )
    {
      v24 = 0;
      goto LABEL_17;
    }
    v6 = &v160[2 * v3];
  }
  v18 = v3 - 1;
  do
  {
    ++v18;
    v19 = *v4;
    v20 = *v4 + 4;
    v21 = **v5;
    v22 = (*v5)[1];
    v23 = (*v5)[2];
    *v5 += v20 >> 3;
    *v4 = v20 & 7;
    *v6++ = ((v23 | ((v22 | (unsigned int)(v21 << 8)) << 8)) << v19 >> 20) & 0xF;
  }
  while ( v18 < 31 );
  v24 = 1;
  if ( v3 < 1 )
  {
    v39 = v160;
    v26 = v159;
    goto LABEL_33;
  }
LABEL_17:
  v25 = v160;
  v26 = v159;
  v27 = &fr->bitindex;
  v28 = &fr->wordpointer;
  v29 = v3;
  do
  {
    if ( *v25 )
    {
      v30 = *v27;
      v31 = *v27 + 6;
      v32 = (*v28)[2];
      v33 = (*v28)[1] | (**v28 << 8);
      *v28 += v31 >> 3;
      *v27 = v31 & 7;
      *(_DWORD *)v26 = ((v32 | (unsigned int)(v33 << 8)) << v30 >> 18) & 0x3F;
      v26 += 4;
    }
    if ( v25[1] )
    {
      v34 = *v27;
      v35 = *v27 + 6;
      v36 = **v28;
      v37 = (*v28)[1];
      v38 = (*v28)[2];
      *v28 += v35 >> 3;
      *v27 = v35 & 7;
      *(_DWORD *)v26 = ((v38 | ((v37 | (unsigned int)(v36 << 8)) << 8)) << v34 >> 18) & 0x3F;
      v26 += 4;
    }
    v25 += 2;
    --v29;
  }
  while ( v29 );
  v39 = &v160[2 * v3];
LABEL_33:
  p_bitindex = &fr->bitindex;
  p_wordpointer = &fr->wordpointer;
  if ( v24 == 1 )
  {
    v55 = fr;
    v56 = v3 - 1;
    do
    {
      if ( *v39++ )
      {
        v58 = *p_bitindex;
        v59 = *p_bitindex + 6;
        v60 = **p_wordpointer;
        v61 = (*p_wordpointer)[1];
        v62 = (*p_wordpointer)[2];
        *p_wordpointer += v59 >> 3;
        *p_bitindex = v59 & 7;
        *(_DWORD *)v26 = ((v62 | ((v61 | (unsigned int)(v60 << 8)) << 8)) << v58 >> 18) & 0x3F;
        v63 = *p_bitindex;
        v64 = *p_bitindex + 6;
        v65 = **p_wordpointer;
        v66 = (*p_wordpointer)[1];
        v67 = (*p_wordpointer)[2];
        *p_wordpointer += v64 >> 3;
        *p_bitindex = v64 & 7;
        *((_DWORD *)v26 + 1) = ((v67 | ((v66 | (unsigned int)(v65 << 8)) << 8)) << v63 >> 18) & 0x3F;
        v26 += 8;
      }
      ++v56;
    }
    while ( v56 < 31 );
    goto LABEL_40;
  }
LABEL_39:
  v55 = fr;
LABEL_40:
  v68 = 0;
  p_synth_mono = &v55->synth_mono;
  p_synth_stereo = (int (__fastcall **)(double (*)[32], double (*)[32], mpg123_handle *))&v55->synth_stereo;
  p_down_sample_sblimit = &v55->down_sample_sblimit;
  v69 = 0;
  v154 = fraction + 1;
  do
  {
    v156 = v68;
    v157 = v69;
    if ( *p_stereo != 2 )
    {
      v86 = v161;
      for ( m = 0; m != 32; ++m )
      {
        v88 = v160[m];
        if ( v88 )
        {
          v89 = *p_bitindex;
          v90 = v88 + *p_bitindex + 1;
          v91 = (*p_wordpointer)[2];
          v92 = (*p_wordpointer)[1] | (**p_wordpointer << 8);
          *p_wordpointer += v90 >> 3;
          *p_bitindex = v90 & 7;
          v55 = fr;
          *(_DWORD *)v86 = (((v91 | (v92 << 8)) << v89) & 0xFFFFFFu) >> (23 - v88);
          v86 += 4;
        }
      }
      v93 = (double *)fraction;
      v94 = v159;
      v95 = v161;
      for ( n = 0; n != 32; ++n )
      {
        v97 = v160[n];
        if ( v97 )
        {
          v99 = *(_DWORD *)v95;
          v95 += 4;
          v98 = v99;
          v100 = *(_DWORD *)v94;
          v94 += 4;
          v101 = v55->muls[v97 + 1][v100] * (double)(v98 + (-1 << v97) + 1);
        }
        else
        {
          v101 = 0.0;
        }
        *v93++ = v101;
      }
      if ( *p_down_sample_sblimit <= 31 )
      {
        memset(&(*fraction)[*p_down_sample_sblimit], 0, 8 * (32 - *p_down_sample_sblimit));
        v55 = fr;
      }
      goto LABEL_95;
    }
    v70 = *p_jsbound;
    if ( *p_jsbound < 1 )
    {
      v85 = v160;
      v71 = v161;
    }
    else
    {
      v71 = v161;
      v72 = 0;
      do
      {
        v73 = v160[2 * v72];
        if ( v73 )
        {
          v74 = *p_bitindex;
          v75 = **p_wordpointer;
          v76 = v73 + *p_bitindex + 1;
          v77 = (*p_wordpointer)[1];
          v78 = (*p_wordpointer)[2];
          *p_wordpointer += v76 >> 3;
          *p_bitindex = v76 & 7;
          *(_DWORD *)v71 = (((v78 | ((v77 | (v75 << 8)) << 8)) << v74) & 0xFFFFFFu) >> (23 - v73);
          v71 += 4;
        }
        v79 = v160[2 * v72 + 1];
        if ( v79 )
        {
          v80 = *p_bitindex;
          v81 = **p_wordpointer;
          v82 = v79 + *p_bitindex + 1;
          v83 = (*p_wordpointer)[1];
          v84 = (*p_wordpointer)[2];
          *p_wordpointer += v82 >> 3;
          *p_bitindex = v82 & 7;
          *(_DWORD *)v71 = (((v84 | ((v83 | (v81 << 8)) << 8)) << v80) & 0xFFFFFFu) >> (23 - v79);
          v71 += 4;
        }
        ++v72;
      }
      while ( v70 != v72 );
      if ( v70 >= 32 )
      {
        v109 = 0;
        goto LABEL_69;
      }
      v85 = &v160[2 * v70];
    }
    v102 = v70 - 1;
    do
    {
      v104 = *v85++;
      v103 = v104;
      if ( v104 )
      {
        v105 = *p_bitindex;
        v106 = v103 + *p_bitindex + 1;
        v107 = (*p_wordpointer)[2];
        v108 = (*p_wordpointer)[1] | (**p_wordpointer << 8);
        *p_wordpointer += v106 >> 3;
        *p_bitindex = v106 & 7;
        *(_DWORD *)v71 = (((v107 | (v108 << 8)) << v105) & 0xFFFFFFu) >> (23 - v103);
        v71 += 4;
      }
      ++v102;
    }
    while ( v102 < 31 );
    v109 = 1;
LABEL_69:
    v55 = fr;
    if ( v70 < 1 )
    {
      v127 = v160;
      v112 = v159;
      v113 = v161;
      v129 = fraction + 1;
      v128 = fraction;
      if ( v109 != 1 )
        goto LABEL_85;
LABEL_80:
      v130 = v70 - 1;
      do
      {
        v132 = *v127++;
        v131 = v132;
        if ( v132 )
        {
          v133 = *(_DWORD *)v113;
          v113 += 4;
          v134 = (int)v55->muls[v131 + 1];
          v135 = (double)(v133 + (-1 << v131) + 1);
          *(double *)v128 = *(double *)(v134 + 8 * *(_DWORD *)v112) * v135;
          v136 = *((_DWORD *)v112 + 1);
          v112 += 8;
          *(double *)v129 = *(double *)(v134 + 8 * v136) * v135;
        }
        else
        {
          LODWORD((*v129)[0]) = 0;
          HIDWORD((*v129)[0]) = 0;
          LODWORD((*v128)[0]) = 0;
          HIDWORD((*v128)[0]) = 0;
        }
        ++v130;
        v128 = (double (*)[32])((char *)v128 + 8);
        v129 = (double (*)[32])((char *)v129 + 8);
      }
      while ( v130 < 31 );
      goto LABEL_85;
    }
    v110 = &(*fraction)[32];
    v111 = v160;
    v112 = v159;
    v113 = v161;
    v149 = v109;
    v114 = v70;
    do
    {
      v115 = *v111;
      v116 = 0.0;
      if ( *v111 )
      {
        v118 = *(_DWORD *)v113;
        v113 += 4;
        v117 = v118;
        v119 = *(_DWORD *)v112;
        v112 += 4;
        v120 = (double)((-1 << v115) + v117 + 1);
        v121 = (double *)(&fr->fresh + 128 * v115 + 2 * v119);
        v55 = fr;
        v122 = v121[2993] * v120;
      }
      else
      {
        v122 = 0.0;
        v55 = fr;
      }
      *(v110 - 32) = v122;
      v123 = v111[1];
      if ( v123 )
      {
        v125 = *(_DWORD *)v113;
        v113 += 4;
        v124 = v125;
        v126 = *(_DWORD *)v112;
        v112 += 4;
        v116 = v55->muls[v123 + 1][v126] * (double)(v124 + (-1 << v123) + 1);
      }
      *v110 = v116;
      v111 += 2;
      --v114;
      ++v110;
    }
    while ( v114 );
    v127 = &v160[2 * v70];
    v128 = (double (*)[32])&(*fraction)[v70];
    v129 = v128 + 1;
    if ( v149 == 1 )
      goto LABEL_80;
LABEL_85:
    v137 = *p_down_sample_sblimit;
    if ( *p_down_sample_sblimit <= 31 )
    {
      v138 = 32 - v137;
      if ( (unsigned int)(32 - v137) >= 2 && (v139 = v138 & 0xFFFFFFFE, (v138 & 0xFFFFFFFE) != 0) )
      {
        v140 = v137 + v139;
        v141 = &(*fraction)[v137];
        v142 = v138 & 0xFFFFFFFE;
        do
        {
          v142 -= 2;
          v141[32] = 0LL;
          v141[33] = 0LL;
          *v141 = 0LL;
          v141[1] = 0LL;
          v141 += 2;
        }
        while ( v142 );
        if ( v138 == v139 )
          goto LABEL_95;
      }
      else
      {
        v140 = *p_down_sample_sblimit;
      }
      v143 = &(*v154)[v140];
      v144 = v140 - 1;
      do
      {
        *(v143 - 64) = 0;
        ++v144;
        *v143 = 0;
        v143[1] = 0;
        *(v143 - 63) = 0;
        v143 += 2;
      }
      while ( v144 < 31 );
    }
LABEL_95:
    if ( v153 == -1 )
      v145 = (*p_synth_stereo)(fraction, v154, v55);
    else
      v145 = (*p_synth_mono)(fraction[v153], v55);
    v55 = fr;
    v69 = v157 + v145;
    v68 = v156 + 1;
  }
  while ( v156 != 11 );
  return v157 + v145;
}
// 228928: conditional instruction was optimized away because r9.4>=20
// 2286AA: using guessed type _DWORD var_230[64];

//----- (00228DE0) --------------------------------------------------------
void INT123_init_layer12()
{
  int *v0; // r0
  int v1; // r2
  int v2; // r6
  int v3; // r6
  int v4; // r1
  int *v5; // r0
  int v6; // r11
  int v7; // r12
  int v8; // r6
  int v9; // r6
  int v10; // [sp+0h] [bp-20h]

  grp_3tab[0] = 1;
  grp_3tab[1] = 1;
  v0 = grp_5tab;
  grp_3tab[2] = 1;
  grp_3tab[3] = 0;
  grp_3tab[4] = 1;
  grp_3tab[5] = 1;
  *(_QWORD *)&grp_3tab[6] = 0x100000002LL;
  grp_3tab[8] = 1;
  grp_3tab[9] = 1;
  grp_3tab[10] = 0;
  grp_3tab[11] = 1;
  grp_3tab[12] = 0;
  grp_3tab[13] = 0;
  grp_3tab[14] = 1;
  grp_3tab[15] = 2;
  grp_3tab[16] = 0;
  grp_3tab[17] = 1;
  grp_3tab[18] = 1;
  *(_QWORD *)&grp_3tab[19] = 0x100000002LL;
  grp_3tab[21] = 0;
  *(_QWORD *)&grp_3tab[22] = 0x100000002LL;
  grp_3tab[24] = 2;
  *(_QWORD *)&grp_3tab[25] = 0x100000002LL;
  grp_3tab[27] = 1;
  grp_3tab[28] = 1;
  grp_3tab[29] = 0;
  grp_3tab[30] = 0;
  grp_3tab[31] = 1;
  grp_3tab[32] = 0;
  *(_QWORD *)&grp_3tab[33] = 0x100000002LL;
  grp_3tab[35] = 0;
  grp_3tab[36] = 1;
  grp_3tab[37] = 0;
  grp_3tab[38] = 0;
  grp_3tab[39] = 0;
  grp_3tab[40] = 0;
  grp_3tab[41] = 0;
  grp_3tab[42] = 2;
  grp_3tab[43] = 0;
  grp_3tab[44] = 0;
  grp_3tab[45] = 1;
  grp_3tab[46] = 2;
  grp_3tab[47] = 0;
  grp_3tab[48] = 0;
  grp_3tab[49] = 2;
  grp_3tab[50] = 0;
  grp_3tab[51] = 2;
  grp_3tab[52] = 2;
  grp_3tab[53] = 0;
  grp_3tab[54] = 1;
  grp_3tab[55] = 1;
  grp_3tab[56] = 2;
  grp_3tab[57] = 0;
  grp_3tab[58] = 1;
  grp_3tab[59] = 2;
  *(_QWORD *)&grp_3tab[60] = 0x100000002LL;
  *(_QWORD *)&grp_3tab[62] = 0x100000002LL;
  grp_3tab[64] = 0;
  grp_3tab[65] = 2;
  grp_3tab[66] = 0;
  grp_3tab[67] = 0;
  grp_3tab[68] = 2;
  grp_3tab[69] = 2;
  grp_3tab[70] = 0;
  *(_QWORD *)&grp_3tab[71] = 0x100000002LL;
  grp_3tab[73] = 2;
  grp_3tab[74] = 2;
  grp_3tab[75] = 0;
  grp_3tab[76] = 2;
  grp_3tab[77] = 2;
  grp_3tab[78] = 2;
  grp_3tab[79] = 2;
  grp_3tab[80] = 2;
  v1 = 9;
  do
  {
    v2 = INT123_init_layer12_base[0][v1];
    *v0 = 17;
    v0[1] = 17;
    v0[3] = 18;
    v0[4] = 17;
    v0[6] = 0;
    v0[7] = 17;
    v0[9] = 19;
    v0[10] = 17;
    v0[2] = v2;
    v0[5] = v2;
    v0[8] = v2;
    v0[11] = v2;
    v0[12] = 20;
    v0[13] = 17;
    v0[14] = v2;
    v0[15] = 17;
    v0[16] = 18;
    v0[17] = v2;
    v0[18] = 18;
    v0[19] = 18;
    v0[20] = v2;
    v0[21] = 0;
    v0[22] = 18;
    v0[23] = v2;
    v0[24] = 19;
    v0[25] = 18;
    v0[26] = v2;
    v0[27] = 20;
    v0[28] = 18;
    v0[29] = v2;
    v0[30] = 17;
    v0[31] = 0;
    v0[32] = v2;
    v0[33] = 18;
    v0[34] = 0;
    v0[35] = v2;
    v0[36] = 0;
    v0[37] = 0;
    v0[38] = v2;
    v0[39] = 19;
    v0[40] = 0;
    v0[41] = v2;
    v0[42] = 20;
    v0[43] = 0;
    v0[44] = v2;
    v0[45] = 17;
    v0[46] = 19;
    v0[47] = v2;
    v0[48] = 18;
    v0[49] = 19;
    v0[50] = v2;
    v0[51] = 0;
    v0[52] = 19;
    v0[53] = v2;
    v0[54] = 19;
    v0[55] = 19;
    v0[56] = v2;
    v0[57] = 20;
    v0[58] = 19;
    v0[59] = v2;
    v0[60] = 17;
    v0[61] = 20;
    v0[62] = v2;
    v0[63] = 18;
    v0[64] = 20;
    v0[65] = v2;
    v0[66] = 0;
    v0[67] = 20;
    v0[68] = v2;
    v0[69] = 19;
    v0[70] = 20;
    v0[71] = v2;
    v0[72] = 20;
    v0[73] = 20;
    v0[74] = v2;
    v3 = v1 - 9;
    v0 += 75;
    ++v1;
  }
  while ( v3 < 4 );
  v4 = 0;
  v5 = grp_9tab;
  do
  {
    v6 = 18;
    v10 = v4;
    v7 = INT123_init_layer12_base[2][v4];
    do
    {
      *v5 = 21;
      v5[2] = v7;
      v5[3] = 1;
      v5[5] = v7;
      v5[6] = 22;
      v5[8] = v7;
      v5[9] = 23;
      v5[11] = v7;
      v5[12] = 0;
      v8 = INT123_init_layer12_base[0][v6];
      v5[14] = v7;
      v5[15] = 24;
      v5[17] = v7;
      v5[18] = 25;
      v5[1] = v8;
      v5[4] = v8;
      v5[7] = v8;
      v5[10] = v8;
      v5[13] = v8;
      v5[16] = v8;
      v5[20] = v7;
      v5[19] = v8;
      v5[21] = 2;
      v5[22] = v8;
      v5[23] = v7;
      v5[24] = 26;
      v5[25] = v8;
      v9 = v6 - 18;
      v5[26] = v7;
      v5 += 27;
      ++v6;
    }
    while ( v9 < 8 );
    ++v4;
  }
  while ( v10 < 8 );
}

//----- (00229014) --------------------------------------------------------
void __fastcall INT123_init_layer12_stuff(mpg123_handle *fr, double *(*init_table)(mpg123_handle *, double *, int))
{
  double *v3; // r6
  int v5; // r4
  double *v6; // r0

  v3 = fr->muls[0];
  v5 = 0;
  do
  {
    v6 = init_table(fr, v3, v5++);
    v3 += 64;
    *(_DWORD *)v6 = 0;
    *((_DWORD *)v6 + 1) = 0;
  }
  while ( v5 != 27 );
}

//----- (00229048) --------------------------------------------------------
double *__fastcall INT123_init_layer12_table(mpg123_handle *fr, double *table, int m)
{
  int v4; // r5
  double *v5; // r6
  double v6; // d8
  double v7; // r0

  v4 = 63;
  v5 = table;
  v6 = mulmul[m];
  do
  {
    v7 = exp2(COERCE_UNSIGNED_INT64((double)(v4 - 60) / 3.0), HIDWORD(COERCE_UNSIGNED_INT64((double)(v4 - 60) / 3.0)));
    --v4;
    *v5++ = v6 * v7;
  }
  while ( v4 );
  return table + 63;
}
// 189E54: using guessed type double __fastcall exp2(_DWORD, _DWORD);

//----- (002290A8) --------------------------------------------------------
int __fastcall INT123_do_layer2(mpg123_handle *fr)
{
  int stereo; // r9
  int sampling_frequency; // r0
  int single; // r8
  int v5; // r1
  int mode; // r3
  int v7; // r4
  const al_table *v8; // r5
  int v9; // r2
  int v10; // r1
  int v11; // r1
  int v12; // r9
  _DWORD *v13; // r3
  int v14; // r8
  int *v15; // r10
  unsigned __int8 **v16; // r11
  int v17; // r1
  int v18; // r0
  int v19; // r2
  int v20; // r12
  int v21; // r9
  int v22; // r6
  int v23; // r0
  int v24; // r2
  int v25; // lr
  int v26; // r9
  int v27; // r4
  _QWORD *v28; // r6
  _DWORD *v29; // r6
  int *p_bitindex; // lr
  unsigned __int8 **p_wordpointer; // r8
  int v32; // r1
  int bits; // r0
  int v34; // r2
  int v35; // r9
  int v36; // r3
  int v37; // r10
  int v38; // r4
  int v39; // r2
  __int64 *v40; // r5
  unsigned int *p_ultmp; // r12
  _DWORD *v42; // r4
  unsigned __int8 *v44; // r0
  int v45; // r1
  unsigned int v46; // r3
  unsigned int v47; // r6
  unsigned int v48; // r3
  int v49; // r1
  int *v50; // lr
  unsigned __int8 **v51; // r8
  int v52; // r2
  int v53; // r4
  int v54; // r9
  int v55; // r3
  int v56; // r10
  int v57; // r0
  int v58; // r0
  __int64 *v59; // r6
  _DWORD *v60; // r5
  unsigned int *v61; // r12
  int *v62; // lr
  unsigned __int8 **v63; // r8
  int v64; // r0
  unsigned __int8 *v66; // r4
  int v67; // r1
  unsigned int v68; // r2
  unsigned int v69; // r3
  unsigned int v70; // r2
  int *v71; // r12
  _DWORD *v72; // lr
  unsigned int *v73; // r8
  int *v74; // r2
  unsigned __int8 **v75; // r3
  char *v76; // r6
  int v78; // r0
  int v79; // t1
  unsigned __int8 *v80; // r0
  int v81; // r4
  unsigned int v82; // r5
  unsigned int v83; // r1
  unsigned int v84; // r1
  unsigned __int8 *v85; // r0
  int v86; // r1
  unsigned int v87; // r4
  unsigned int v88; // r5
  unsigned int v89; // r4
  unsigned __int8 *v90; // r0
  int v91; // r1
  unsigned int v92; // r4
  unsigned int v93; // r5
  unsigned int v94; // r4
  unsigned __int8 *v95; // r0
  int v96; // r1
  unsigned int v97; // r4
  unsigned int v98; // r5
  unsigned __int8 *v99; // r0
  int v100; // r1
  unsigned int v101; // r4
  unsigned int v102; // r5
  unsigned __int8 *v103; // r0
  int v104; // r1
  unsigned int v105; // r4
  unsigned int v106; // r5
  unsigned int v107; // r4
  unsigned __int8 *v108; // r0
  int v109; // r1
  unsigned int v110; // r4
  unsigned int v111; // r5
  double (*v112)[32]; // r1
  int v113; // r0
  const al_table *v114; // r2
  int v115; // r1
  int v116; // r8
  double *v117; // r4
  char *v118; // r11
  int v119; // r3
  __int16 v120; // r6
  int v121; // lr
  int *v122; // r8
  int v123; // r3
  int v124; // t1
  int v125; // r12
  int d; // r9
  int v127; // r10
  _DWORD *v128; // r1
  int v129; // r9
  int v130; // r6
  int v131; // r0
  int v132; // r2
  unsigned int v133; // r0
  int v134; // r1
  int v135; // r2
  unsigned int v136; // r0
  double v137; // d16
  double v138; // d16
  unsigned __int8 **v139; // r11
  int v140; // r6
  int v141; // r1
  int v142; // r2
  double v143; // d17
  int v144; // r0
  double v145; // d16
  int v146; // s0
  int v147; // r1
  int v148; // r12
  int v149; // r1
  __int16 v150; // lr
  int v151; // r3
  int v152; // r8
  int v153; // r9
  char v154; // lr
  int v155; // r0
  int v156; // r1
  int v157; // r5
  int v158; // r10
  char *v159; // r8
  int v160; // r11
  int v161; // r6
  unsigned int v162; // r0
  unsigned int v163; // r0
  int v164; // r2
  char *v165; // r3
  int v166; // r5
  int v167; // r0
  __int64 *v168; // r2
  __int64 v169; // d16
  char *v170; // r0
  int v171; // r3
  int v172; // r6
  double v173; // d17
  double *v174; // r4
  int v175; // r0
  int v176; // r3
  int v177; // r10
  int v178; // r6
  int v179; // r2
  int v180; // r0
  int v181; // r2
  int v182; // r6
  int v183; // r3
  double v184; // d16
  double v185; // d18
  double v186; // d19
  int v187; // r0
  double *v188; // r0
  double v189; // d16
  double v190; // d17
  int v191; // r1
  int v192; // r3
  int v193; // r0
  _DWORD *v194; // r1
  int v195; // r2
  int v197; // r4
  int v198; // r4
  int v199; // r0
  int v200; // r4
  int (__fastcall **p_synth_stereo)(double (*)[4][32], double *, mpg123_handle *); // [sp+14h] [bp-5ACh]
  double (*v203)[32]; // [sp+1Ch] [bp-5A4h]
  double (*v204)[32]; // [sp+20h] [bp-5A0h]
  int (__fastcall **p_synth_mono)(double (*)[32], mpg123_handle *); // [sp+28h] [bp-598h]
  double (*fraction)[4][32]; // [sp+2Ch] [bp-594h]
  int *p_down_sample_sblimit; // [sp+34h] [bp-58Ch]
  int *p_jsbound; // [sp+38h] [bp-588h]
  const al_table **p_alloc; // [sp+3Ch] [bp-584h]
  int *p_II_sblimit; // [sp+40h] [bp-580h]
  int *p_stereo; // [sp+44h] [bp-57Ch]
  int v212; // [sp+48h] [bp-578h]
  int v213; // [sp+4Ch] [bp-574h]
  int v214; // [sp+50h] [bp-570h]
  int v215; // [sp+54h] [bp-56Ch]
  int v216; // [sp+58h] [bp-568h]
  int v217; // [sp+58h] [bp-568h]
  int v218; // [sp+5Ch] [bp-564h]
  __int16 v219; // [sp+60h] [bp-560h]
  int v220; // [sp+60h] [bp-560h]
  double *v221; // [sp+64h] [bp-55Ch]
  int v222; // [sp+64h] [bp-55Ch]
  int v223; // [sp+68h] [bp-558h]
  char *v224; // [sp+68h] [bp-558h]
  _QWORD *v225; // [sp+6Ch] [bp-554h]
  int v226; // [sp+6Ch] [bp-554h]
  char v227; // [sp+6Ch] [bp-554h]
  char *v228; // [sp+70h] [bp-550h]
  unsigned __int8 **v229; // [sp+74h] [bp-54Ch]
  int v230; // [sp+78h] [bp-548h]
  int *v231; // [sp+78h] [bp-548h]
  mpg123_handle *v232; // [sp+7Ch] [bp-544h]
  int v233; // [sp+80h] [bp-540h]
  int v234; // [sp+80h] [bp-540h]
  int v235; // [sp+80h] [bp-540h]
  int v236; // [sp+84h] [bp-53Ch]
  int v237; // [sp+84h] [bp-53Ch]
  const al_table *v238; // [sp+84h] [bp-53Ch]
  const al_table *v239; // [sp+84h] [bp-53Ch]
  int v240; // [sp+88h] [bp-538h]
  __int16 v241; // [sp+88h] [bp-538h]
  char *v242; // [sp+8Ch] [bp-534h]
  int v243; // [sp+8Ch] [bp-534h]
  char v244[768]; // [sp+90h] [bp-530h] BYREF
  _QWORD v245[32]; // [sp+390h] [bp-230h] BYREF
  __int64 v246; // [sp+490h] [bp-130h] BYREF
  int v247; // [sp+498h] [bp-128h]
  int *v248; // [sp+49Ch] [bp-124h]
  __int64 v249; // [sp+4A0h] [bp-120h]
  __int64 v250; // [sp+4A8h] [bp-118h]
  int v251; // [sp+4B0h] [bp-110h]
  int *v252; // [sp+4B4h] [bp-10Ch]

  fraction = fr->layer2.fraction;
  stereo = fr->stereo;
  sampling_frequency = fr->sampling_frequency;
  p_stereo = &fr->stereo;
  single = fr->single;
  if ( sampling_frequency <= 2 )
    v5 = II_select_table_translate[32 * sampling_frequency + 16 * (2 - stereo) + fr->bitrate_index];
  else
    v5 = 4;
  mode = fr->mode;
  v7 = II_select_table_sblims[v5];
  v8 = (const al_table *)*(&off_660D08 + v5);
  fr->II_sblimit = v7;
  fr->alloc = v8;
  p_II_sblimit = &fr->II_sblimit;
  p_alloc = &fr->alloc;
  if ( mode == 1 )
  {
    v9 = 4 * fr->mode_ext + 4;
    fr->jsbound = v9;
    p_jsbound = &fr->jsbound;
    if ( v9 > v7 )
    {
      fwrite("Truncating stereo boundary to sideband limit.\n", 0x2Eu, 1u, (FILE *)stderr);
      v9 = *p_II_sblimit;
      v7 = *p_II_sblimit;
      *p_jsbound = *p_II_sblimit;
      v8 = *p_alloc;
      v10 = *p_stereo;
    }
    else
    {
      v10 = stereo;
    }
  }
  else
  {
    fr->jsbound = v7;
    v9 = v7;
    v10 = stereo;
    p_jsbound = &fr->jsbound;
  }
  if ( single == 3 )
    single = 0;
  if ( stereo == 1 )
    single = 0;
  v11 = v10 - 1;
  v212 = single;
  v12 = v7 << v11;
  v232 = fr;
  if ( !v11 )
  {
    if ( v7 )
    {
      v29 = v245;
      p_bitindex = &v232->bitindex;
      p_wordpointer = &v232->wordpointer;
      v32 = v7;
      v237 = v12;
      v234 = v7;
      do
      {
        --v32;
        bits = v8->bits;
        v34 = *p_bitindex;
        v35 = **p_wordpointer;
        v36 = *p_bitindex + bits;
        v37 = (*p_wordpointer)[1];
        v38 = (*p_wordpointer)[2];
        *p_wordpointer += v36 >> 3;
        *p_bitindex = v36 & 7;
        v8 += 1 << bits;
        *v29++ = (unsigned __int8)((((v38 | ((v37 | (v35 << 8)) << 8)) << v34) & 0xFFFFFFu) >> (24 - bits));
      }
      while ( v32 );
      v39 = v234;
      v12 = v237;
      v40 = &v246;
      p_ultmp = &v232->ultmp;
      v42 = v245;
      do
      {
        if ( *v42++ )
        {
          v44 = *p_wordpointer;
          v45 = *p_bitindex;
          v46 = (unsigned __int8)(**p_wordpointer << *p_bitindex);
          *p_ultmp = v46;
          v47 = v44[1] << v45;
          v45 += 2;
          v48 = v46 | (v47 >> 8);
          *p_ultmp = v48 >> 6;
          *p_wordpointer = &v44[v45 >> 3];
          *p_bitindex = v45 & 7;
          *(_DWORD *)v40 = (unsigned __int8)(v48 >> 6);
          v40 = (__int64 *)((char *)v40 + 4);
        }
        --v39;
      }
      while ( v39 );
    }
    goto LABEL_34;
  }
  v236 = v7 << v11;
  if ( v9 )
  {
    v233 = v7;
    v13 = v245;
    v230 = v9;
    v14 = v9;
    v16 = &fr->wordpointer;
    v15 = &fr->bitindex;
    do
    {
      --v14;
      v17 = v8->bits;
      v18 = *v15;
      v19 = **v16;
      v20 = *v15 + v17;
      v21 = (*v16)[1];
      v22 = (*v16)[2];
      *v16 += v20 >> 3;
      *v15 = v20 & 7;
      *v13 = (unsigned __int8)((((v22 | ((v21 | (v19 << 8)) << 8)) << v18) & 0xFFFFFFu) >> (24 - v17));
      v23 = *v15;
      v24 = *v15 + v17;
      v25 = **v16;
      v26 = (*v16)[1];
      v27 = (*v16)[2];
      *v16 += v24 >> 3;
      *v15 = v24 & 7;
      v13[1] = (unsigned __int8)((((v27 | ((v26 | (v25 << 8)) << 8)) << v23) & 0xFFFFFFu) >> (24 - v17));
      v13 += 2;
      v8 += 1 << v17;
    }
    while ( v14 );
    v9 = v230;
    v7 = v233;
    v28 = &v245[v230];
    if ( v233 == v230 )
      goto LABEL_29;
    goto LABEL_27;
  }
  v28 = v245;
  if ( v7 )
  {
LABEL_27:
    v49 = v9 - v7;
    v50 = &v232->bitindex;
    v51 = &v232->wordpointer;
    do
    {
      ++v49;
      v52 = v8->bits;
      v53 = *v50;
      v54 = **v51;
      v55 = *v50 + v52;
      v56 = (*v51)[1];
      v57 = (*v51)[2];
      *v51 += v55 >> 3;
      *v50 = v55 & 7;
      v58 = (unsigned __int8)((((v57 | ((v56 | (v54 << 8)) << 8)) << v53) & 0xFFFFFFu) >> (24 - v52));
      *(_DWORD *)v28 = v58;
      *((_DWORD *)v28 + 1) = v58;
      v8 += 1 << v52;
      ++v28;
    }
    while ( v49 );
  }
LABEL_29:
  v12 = v236;
  if ( !v236 )
    goto LABEL_48;
  v59 = &v246;
  v60 = v245;
  v61 = &v232->ultmp;
  v62 = &v232->bitindex;
  v63 = &v232->wordpointer;
  v64 = v236;
  do
  {
    if ( *v60++ )
    {
      v66 = *v63;
      v67 = *v62;
      v68 = (unsigned __int8)(**v63 << *v62);
      *v61 = v68;
      v69 = v66[1] << v67;
      v67 += 2;
      v70 = v68 | (v69 >> 8);
      *v61 = v70 >> 6;
      *v63 = &v66[v67 >> 3];
      *v62 = v67 & 7;
      *(_DWORD *)v59 = (unsigned __int8)(v70 >> 6);
      v59 = (__int64 *)((char *)v59 + 4);
    }
    --v64;
  }
  while ( v64 );
LABEL_34:
  if ( v12 )
  {
    v71 = (int *)&v246;
    v72 = v245;
    v73 = &v232->ultmp;
    v74 = &v232->bitindex;
    v75 = &v232->wordpointer;
    v76 = v244;
    while ( !*v72++ )
    {
LABEL_47:
      if ( !--v12 )
        goto LABEL_48;
    }
    v79 = *v71++;
    v78 = v79;
    if ( v79 == 2 )
    {
      v90 = *v75;
      v91 = *v74;
      v92 = (unsigned __int8)(**v75 << *v74);
      *v73 = v92;
      v93 = v90[1] << v91;
      v91 += 6;
      v94 = (v92 | (v93 >> 8)) >> 2;
      *v73 = v94;
      *v75 = &v90[v91 >> 3];
      *v74 = v91 & 7;
      *(_DWORD *)v76 = v94;
    }
    else
    {
      if ( v78 == 1 )
      {
        v95 = *v75;
        v96 = *v74;
        v97 = (unsigned __int8)(**v75 << *v74);
        *v73 = v97;
        v98 = v95[1] << v96;
        v96 += 6;
        v89 = (v97 | (v98 >> 8)) >> 2;
        *v73 = v89;
        *v75 = &v95[v96 >> 3];
        *v74 = v96 & 7;
        *(_DWORD *)v76 = v89;
        goto LABEL_43;
      }
      if ( !v78 )
      {
        v80 = *v75;
        v81 = *v74;
        v82 = (unsigned __int8)(**v75 << *v74);
        *v73 = v82;
        v83 = v80[1] << v81;
        v81 += 6;
        v84 = (v82 | (v83 >> 8)) >> 2;
        *v73 = v84;
        *v75 = &v80[v81 >> 3];
        *v74 = v81 & 7;
        *(_DWORD *)v76 = v84;
        v85 = *v75;
        v86 = *v74;
        v87 = (unsigned __int8)(**v75 << *v74);
        *v73 = v87;
        v88 = v85[1] << v86;
        v86 += 6;
        v89 = (v87 | (v88 >> 8)) >> 2;
        *v73 = v89;
        *v75 = &v85[v86 >> 3];
        *v74 = v86 & 7;
LABEL_43:
        *((_DWORD *)v76 + 1) = v89;
        v99 = *v75;
        v100 = *v74;
        v101 = (unsigned __int8)(**v75 << *v74);
        *v73 = v101;
        v102 = v99[1] << v100;
        v100 += 6;
        v94 = (v101 | (v102 >> 8)) >> 2;
        *v73 = v94;
        *v75 = &v99[v100 >> 3];
        *v74 = v100 & 7;
LABEL_46:
        *((_DWORD *)v76 + 2) = v94;
        v76 += 12;
        goto LABEL_47;
      }
      v103 = *v75;
      v104 = *v74;
      v105 = (unsigned __int8)(**v75 << *v74);
      *v73 = v105;
      v106 = v103[1] << v104;
      v104 += 6;
      v107 = (v105 | (v106 >> 8)) >> 2;
      *v73 = v107;
      *v75 = &v103[v104 >> 3];
      *v74 = v104 & 7;
      *(_DWORD *)v76 = v107;
      v108 = *v75;
      v109 = *v74;
      v110 = (unsigned __int8)(**v75 << *v74);
      *v73 = v110;
      v111 = v108[1] << v109;
      v109 += 6;
      v94 = (v110 | (v111 >> 8)) >> 2;
      *v73 = v94;
      *v75 = &v108[v109 >> 3];
      *v74 = v109 & 7;
    }
    *((_DWORD *)v76 + 1) = v94;
    goto LABEL_46;
  }
LABEL_48:
  p_synth_mono = (int (__fastcall **)(double (*)[32], mpg123_handle *))&v232->synth_mono;
  p_synth_stereo = (int (__fastcall **)(double (*)[4][32], double *, mpg123_handle *))&v232->synth_stereo;
  p_down_sample_sblimit = &v232->down_sample_sblimit;
  v231 = &v232->bitindex;
  v229 = &v232->wordpointer;
  v112 = fraction[v212];
  v204 = v112 + 2;
  v203 = v112 + 1;
  v213 = 0;
  v113 = 0;
  do
  {
    v214 = v113;
    v114 = *p_alloc;
    v115 = *p_jsbound;
    v215 = *p_II_sblimit;
    v116 = *p_stereo;
    v218 = *p_stereo;
    v235 = v113 >> 2;
    if ( *p_jsbound < 1 )
    {
      v118 = v244;
      v225 = v245;
    }
    else
    {
      v117 = (*fraction)[1];
      v118 = v244;
      v119 = 0;
      v225 = v245;
      v216 = *p_jsbound;
      do
      {
        v120 = v114->bits;
        if ( v116 >= 1 )
        {
          v121 = v116;
          v219 = v114->bits;
          v223 = v119;
          v122 = (int *)v225;
          v221 = v117;
          v238 = v114;
          do
          {
            v124 = *v122++;
            v123 = v124;
            if ( v124 )
            {
              v125 = v114[v123].bits;
              d = v114[v123].d;
              if ( d <= -1 )
              {
                v242 = v118;
                v139 = &v232->wordpointer;
                v140 = (*v229)[2];
                v141 = (*v229)[1] | (**v229 << 8);
                v142 = *v231;
                v143 = v232->muls[v125][*(_DWORD *)&v242[4 * v235]];
                *v229 += (*v231 + v125) >> 3;
                *v231 = (v142 + v125) & 7;
                *(v117 - 32) = v143 * (double)(int)(((((v140 | (v141 << 8)) << v142) & 0xFFFFFFu) >> (24 - v125)) + d);
                v144 = *v231 + v125;
                v145 = (double)(int)((((((*v139)[2] | (((*v139)[1] | (**v139 << 8)) << 8)) << *v231) & 0xFFFFFFu) >> (24 - v125))
                                   + d);
                *v229 += v144 >> 3;
                *v231 = v144 & 7;
                *v117 = v143 * v145;
                v146 = (((((*v229)[2] | (((*v139)[1] | (**v139 << 8)) << 8)) << *v231) & 0xFFFFFFu) >> (24 - v125)) + d;
                v147 = *v231 + v125;
                v114 = v238;
                *v229 += v147 >> 3;
                v118 = v242;
                *v231 = v147 & 7;
                v138 = v143 * (double)v146;
              }
              else
              {
                v249 = 0LL;
                v250 = 0LL;
                v251 = 0;
                v252 = grp_9tab;
                v127 = *(_DWORD *)&v118[4 * v235];
                v246 = 0LL;
                v247 = 0;
                v128 = (_DWORD *)&v246 + d;
                v248 = grp_3tab;
                HIDWORD(v249) = grp_5tab;
                v129 = *v231;
                v130 = *v231 + v125;
                v240 = **v229;
                v131 = (*v229)[1];
                v132 = (*v229)[2];
                *v229 += v130 >> 3;
                *v231 = v130 & 7;
                v133 = (((v132 | ((v131 | (v240 << 8)) << 8)) << v129) & 0xFFFFFFu) >> (24 - v125);
                v134 = *v128 + 4 * v133 + 4 * v133;
                v135 = *(_DWORD *)(v134 + 4 * v133);
                v136 = v134 + 4 * v133;
                v137 = v232->muls[v135][v127];
                v114 = v238;
                *(v117 - 32) = v137;
                *v117 = v232->muls[*(_DWORD *)(v136 + 4)][v127];
                v138 = v232->muls[*(_DWORD *)(v136 + 8)][v127];
              }
              v117[32] = v138;
              v118 += 12;
            }
            else
            {
              *((_DWORD *)v117 - 64) = 0;
              *((_DWORD *)v117 + 64) = 0;
              *((_DWORD *)v117 + 65) = 0;
              *((_DWORD *)v117 - 63) = 0;
              *(_DWORD *)v117 = 0;
              *((_DWORD *)v117 + 1) = 0;
            }
            --v121;
            v117 += 128;
          }
          while ( v121 );
          v116 = v218;
          v115 = v216;
          v225 = (_QWORD *)((char *)v225 + 4 * v218);
          v119 = v223;
          LOBYTE(v120) = v219;
          v117 = v221;
        }
        ++v119;
        ++v117;
        v114 += 1 << v120;
      }
      while ( v119 != v115 );
    }
    if ( v115 < v215 )
    {
      v148 = 0;
      v224 = (char *)fraction + 8 * v115;
      v149 = v215 - v115;
      v228 = (char *)v225 + 4;
      v222 = v235 + 3;
      do
      {
        v150 = v114->bits;
        v151 = *(_DWORD *)&v228[v148];
        if ( v151 )
        {
          v152 = v114[v151].bits;
          v153 = v114[v151].d;
          v239 = v114;
          v241 = v114->bits;
          if ( v153 <= -1 )
          {
            v220 = (int)v232->muls[v152];
            v171 = (*v229)[2] | (((*v229)[1] | (**v229 << 8)) << 8);
            v172 = *v231;
            v227 = 24 - v152;
            v173 = *(double *)(v220 + 8 * *(_DWORD *)&v118[4 * v222]);
            *v229 += (*v231 + v152) >> 3;
            *v231 = (v172 + v152) & 7;
            v174 = (double *)&v224[v148];
            *v174 = (double)(int)((((v171 << v172) & 0xFFFFFFu) >> (24 - v152)) + v153);
            v175 = *v231;
            v176 = *v231 + v152;
            v177 = **v229;
            v178 = (*v229)[1];
            v179 = (*v229)[2];
            *v229 += v176 >> 3;
            *v231 = v176 & 7;
            v174[32] = (double)(int)(((((v179 | ((v178 | (v177 << 8)) << 8)) << v175) & 0xFFFFFFu) >> (24 - v152)) + v153);
            v180 = *v231;
            v181 = *v231 + v152;
            v217 = **v229;
            v182 = (*v229)[1];
            v183 = (*v229)[2];
            *v229 += v181 >> 3;
            v116 = v218;
            *v231 = v181 & 7;
            v184 = *(double *)&v224[v148];
            v185 = *(double *)&v224[v148 + 256];
            v114 = v239;
            v186 = (double)(int)(((((v183 | ((v182 | (v217 << 8)) << 8)) << v180) & 0xFFFFFFu) >> v227) + v153);
            v174[160] = v173 * v185;
            v174[128] = v173 * v184;
            v174[64] = v186;
            v174[192] = v173 * v186;
            v187 = *(_DWORD *)&v118[4 * v235];
            v118 += 24;
            v188 = (double *)(v220 + 8 * v187);
            v189 = v184 * *v188;
            v190 = *v188 * v186;
            v174[32] = v185 * *v188;
            *v174 = v189;
            v174[64] = v190;
          }
          else
          {
            v154 = v114[v151].bits;
            LODWORD(v249) = 0;
            v250 = 0LL;
            v251 = 0;
            v252 = grp_9tab;
            v246 = 0LL;
            v247 = 0;
            v248 = grp_3tab;
            HIDWORD(v249) = grp_5tab;
            v226 = *(_DWORD *)&v118[4 * v222];
            v155 = *v231;
            v243 = v149;
            v156 = *(_DWORD *)&v118[4 * v235];
            v157 = *v231 + v152;
            v158 = **v229;
            v159 = v118;
            v160 = (*v229)[1];
            v161 = (*v229)[2];
            *v229 += v157 >> 3;
            *v231 = v157 & 7;
            v162 = ((v161 | ((v160 | (v158 << 8)) << 8)) << v155) & 0xFFFFFF;
            v118 = v159 + 24;
            v163 = v162 >> (24 - v154);
            v164 = *((_DWORD *)&v246 + v153) + 4 * v163 + 4 * v163;
            v165 = &v224[v148];
            *(double *)v165 = v232->muls[*(_DWORD *)(v164 + 4 * v163)][v156];
            v166 = *(_DWORD *)(v164 + 4 * v163);
            v167 = v164 + 4 * v163;
            *((_QWORD *)v165 + 128) = *(_QWORD *)&v232->muls[v166][v226];
            *((_QWORD *)v165 + 32) = *(_QWORD *)&v232->muls[*(_DWORD *)(v167 + 4)][v156];
            *((_QWORD *)v165 + 160) = *(_QWORD *)&v232->muls[*(_DWORD *)(v167 + 4)][v226];
            v168 = (__int64 *)&v232->muls[*(_DWORD *)(v167 + 8)][v156];
            LOBYTE(v150) = v241;
            v149 = v243;
            v116 = v218;
            v169 = *v168;
            v114 = v239;
            *((_QWORD *)v165 + 64) = v169;
            *((_QWORD *)v165 + 192) = *(_QWORD *)&v232->muls[*(_DWORD *)(v167 + 8)][v226];
          }
        }
        else
        {
          *(_DWORD *)&v224[v148] = 0;
          v170 = &v224[v148];
          *((_DWORD *)v170 + 384) = 0;
          *((_DWORD *)v170 + 385) = 0;
          *((_DWORD *)v170 + 1) = 0;
          *((_DWORD *)v170 + 64) = 0;
          *((_DWORD *)v170 + 65) = 0;
          *((_DWORD *)v170 + 128) = 0;
          *((_DWORD *)v170 + 129) = 0;
          *((_DWORD *)v170 + 256) = 0;
          *((_DWORD *)v170 + 257) = 0;
          *((_DWORD *)v170 + 320) = 0;
          *((_DWORD *)v170 + 321) = 0;
        }
        --v149;
        v148 += 8;
        v114 += 1 << v150;
      }
      while ( v149 );
    }
    v191 = v215;
    if ( v215 > *p_down_sample_sblimit )
      v191 = *p_down_sample_sblimit;
    v192 = v191;
    if ( v191 <= 31 )
    {
      v193 = (int)&(*fraction)[1][v191];
      do
      {
        if ( v116 >= 1 )
        {
          v194 = (_DWORD *)v193;
          v195 = v116;
          do
          {
            *(v194 - 64) = 0;
            --v195;
            v194[64] = 0;
            v194[65] = 0;
            *(v194 - 63) = 0;
            *v194 = 0;
            v194[1] = 0;
            v194 += 256;
          }
          while ( v195 );
        }
        v193 += 8;
      }
      while ( v192++ < 31 );
    }
    if ( v212 == -1 )
    {
      v200 = (*p_synth_stereo)(fraction, (*fraction)[4], v232) + v213;
      v198 = v200 + (*p_synth_stereo)((double (*)[4][32])((char *)fraction + 256), (*fraction)[5], v232);
      v199 = (*p_synth_stereo)((double (*)[4][32])((char *)fraction + 512), (*fraction)[6], v232);
    }
    else
    {
      v197 = (*p_synth_mono)(fraction[v212], v232) + v213;
      v198 = v197 + (*p_synth_mono)(v203, v232);
      v199 = (*p_synth_mono)(v204, v232);
    }
    v213 = v199 + v198;
    v113 = v214 + 1;
  }
  while ( v214 != 11 );
  return v213;
}
// 229CE0: using guessed type int II_select_table_sblims[5];
// 5F1328: using guessed type _DWORD II_select_table_translate[96];
// 660D08: using guessed type al_table (*off_660D08)[288];

//----- (00229D40) --------------------------------------------------------
double __fastcall INT123_init_layer3_gainpow2(mpg123_handle *fr, int i)
{
  return sub_189E50(
           COERCE_UNSIGNED_INT64((double)(i + 210) * -0.25),
           HIDWORD(COERCE_UNSIGNED_INT64((double)(i + 210) * -0.25)));
}
// 189E50: using guessed type double __fastcall sub_189E50(_DWORD, _DWORD);

//----- (00229D60) --------------------------------------------------------
void INT123_init_layer3()
{
  double v0; // d9
  int v1; // r4
  double *v2; // r6
  double v3; // r0
  int v4; // r4
  double v5; // d10
  double *v6; // r6
  double v7; // kr00_8
  double v8; // d14
  double v9; // d13
  double v10; // r0
  int v11; // r6
  double v12; // d11
  double *v13; // r5
  double v14; // kr08_8
  double v15; // d13
  double v16; // r8
  double v17; // kr10_8
  double v18; // r0
  double v19; // d12
  double v20; // r2
  double v21; // d10
  double v22; // d11
  double v23; // r0
  double v24; // d16
  int v25; // r5
  double *v26; // r4
  double v27; // d8
  double v28; // r0
  int v29; // r4
  double v30; // d12
  double v31; // r0
  double v32; // d17
  double v33; // d10
  int v34; // r9
  double *v35; // r5
  double *v36; // r4
  double *v37; // r6
  double *v38; // r8
  double v39; // d16
  double v40; // d17
  double v41; // d12
  double v42; // d13
  double v43; // d16
  double v44; // d18
  double v45; // d19
  double v46; // d16
  double v47; // d17
  unsigned __int8 *v48; // r9
  unsigned __int8 *shortDiff; // r8
  int v50; // r4
  int *v51; // r6
  int *v52; // r1
  const bandInfoStruct *v53; // r5
  int v54; // r2
  int *v55; // r0
  int v56; // r1
  unsigned __int8 *longDiff; // r5
  unsigned int v58; // t1
  unsigned int v59; // r4
  unsigned int v60; // r2
  int v61; // r1
  unsigned int v62; // r2
  unsigned int v63; // r10
  unsigned int v64; // r1
  unsigned int v65; // r3
  int v66; // r3
  int v67; // r3
  int v68; // r2
  int v69; // r0
  int *v70; // r3
  int v71; // r2
  int v72; // r1
  int v73; // r4
  int v74; // r3
  int *v75; // r0
  int v76; // r2
  int v77; // r1
  int *v78; // r2
  const bandInfoStruct *v79; // r0
  unsigned int v80; // lr
  int v81; // r6
  unsigned int v82; // r5
  int v83; // r3
  unsigned int v84; // r5
  unsigned int v85; // r4
  unsigned int v86; // r10
  unsigned int v87; // r4
  int v88; // r1
  unsigned int v89; // r4
  unsigned int v90; // r5
  int v91; // r1
  unsigned int v92; // r4
  unsigned int v93; // r6
  unsigned int v94; // r10
  unsigned int v95; // r4
  unsigned int v96; // lr
  unsigned int v97; // r5
  unsigned int v98; // r0
  int v99; // r0
  int64x2_t v100; // q8
  unsigned int v101; // r4
  unsigned int *v102; // r12
  int64x2_t *v103; // r1
  int64x2_t v104; // q9
  int v105; // r1
  int64x2_t v106; // q8
  int64x2_t v107; // q9
  int64x2_t v108; // q10
  unsigned int v109; // r2
  int v110; // r0
  int64x2_t v111; // q11
  unsigned int *v112; // r3
  int64x2_t v113; // q4
  int64x2_t v114; // q3
  int64x2_t v115; // q1
  int64x2_t *v116; // r1
  int64x2_t v117; // q13
  int v118; // [sp+Ch] [bp-94h]
  int v119; // [sp+10h] [bp-90h]
  unsigned int v120; // [sp+14h] [bp-8Ch]
  int v121; // [sp+14h] [bp-8Ch]
  int v122; // [sp+18h] [bp-88h]
  int **v123; // [sp+18h] [bp-88h]
  int v124; // [sp+1Ch] [bp-84h]
  int v125; // [sp+20h] [bp-80h]
  int v126; // [sp+20h] [bp-80h]
  unsigned int v127; // [sp+24h] [bp-7Ch]
  unsigned __int8 *v128; // [sp+24h] [bp-7Ch]
  int *v129; // [sp+28h] [bp-78h]
  int v130; // [sp+2Ch] [bp-74h]
  int *x; // [sp+30h] [bp-70h]
  int *x_4; // [sp+34h] [bp-6Ch]
  int *v133; // [sp+38h] [bp-68h]

  v0 = 0.0;
  v1 = 8207;
  v2 = ispow;
  do
  {
    v3 = pow(v0, 1.33333333);
    v0 = v0 + 1.0;
    *v2 = v3;
    --v1;
    ++v2;
  }
  while ( v1 );
  aa_ca[0] = -0.514495755;
  aa_ca[1] = -0.471731969;
  aa_ca[2] = -0.313377454;
  aa_ca[3] = -0.1819132;
  aa_cs[0] = 0.857492926;
  aa_cs[1] = 0.881741997;
  aa_cs[2] = 0.949628649;
  aa_cs[3] = 0.983314592;
  aa_ca[4] = -0.0945741925;
  aa_ca[5] = -0.0409655829;
  aa_ca[6] = -0.0141985686;
  aa_ca[7] = -0.00369997467;
  aa_cs[4] = 0.995517816;
  aa_cs[5] = 0.999160558;
  aa_cs[6] = 0.999899195;
  v4 = 55;
  aa_cs[7] = 0.999993155;
  v5 = 3.14159265;
  v6 = &win[3][18];
  do
  {
    v7 = sin((double)(v4 - 54) * 0.0436332313);
    v8 = sin((double)(v4 - 18) * 0.0436332313) * 0.5;
    v9 = cos((double)v4 * 3.14159265 / 72.0);
    v10 = cos((double)(v4 - 36) * 3.14159265 / 72.0);
    v4 += 2;
    *v6 = v8 / v9;
    *(v6 - 108) = v8 / v9;
    *(v6 - 126) = v7 * 0.5 / v10;
    *(v6 - 90) = v7 * 0.5 / v10;
    ++v6;
  }
  while ( v4 != 91 );
  v11 = 67;
  v12 = 0.130899694;
  v13 = &win[3][12];
  do
  {
    v14 = cos((double)(v11 - 12) * v5 / 72.0);
    v15 = cos((double)v11 * v5 / 72.0);
    v16 = cos((double)(v11 - 24) * v5 / 72.0);
    v17 = sin((double)(v11 - 54) * v12);
    v18 = sin((double)(v11 - 66) * v12);
    v19 = v5;
    v20 = (double)(v11 - 36) * v5 / 72.0;
    v21 = v12;
    v22 = v18 * 0.5;
    v23 = cos(v20);
    v11 += 2;
    *((_DWORD *)v13 - 107) = 0;
    *((_DWORD *)v13 - 108) = 0;
    *((_DWORD *)v13 - 24) = 0;
    *((_DWORD *)v13 - 23) = 0;
    v24 = v22 / v23;
    v12 = v21;
    v5 = v19;
    *(v13 - 60) = v17 * 0.5 / v15;
    *v13 = 0.5 / v16;
    *(v13 - 66) = 0.5 / v14;
    *(v13 - 6) = v24;
    ++v13;
  }
  while ( v11 != 79 );
  INT123_tfcos36[7] = 1.93185165;
  INT123_tfcos36[6] = 1.18310079;
  INT123_COS9[0] = 1.0;
  INT123_tfcos36[5] = 0.871723398;
  tfcos12[0] = 0.51763809;
  INT123_COS9[4] = 0.766044443;
  INT123_COS9[5] = 0.64278761;
  INT123_COS9[6] = 0.5;
  INT123_COS9[7] = 0.342020143;
  INT123_tfcos36[0] = 0.501909919;
  INT123_tfcos36[1] = 0.51763809;
  INT123_tfcos36[2] = 0.551688959;
  INT123_tfcos36[3] = 0.610387294;
  INT123_COS9[3] = 0.866025404;
  INT123_COS9[2] = 0.939692621;
  INT123_COS9[1] = 0.984807753;
  INT123_COS9[8] = 0.173648178;
  INT123_tfcos36[4] = 0.707106781;
  INT123_tfcos36[8] = 5.73685662;
  tfcos12[1] = 0.707106781;
  COS6_1 = 0.866025404;
  tfcos12[2] = 1.93185165;
  v25 = 7;
  COS6_2 = 0.5;
  dword_6D6264 = 1072566774;
  cos9_0 = 1112681756;
  dword_6D626C = -1077528038;
  cos9_1 = 2114679688;
  dword_6D6274 = -1075281041;
  cos9_2 = -1563471816;
  cos18_0 = -1937695721;
  unk_6D627C = 1072661387;
  cos18_1 = 1955204081;
  unk_6D6284 = -1076501592;
  v26 = win[2];
  cos18_2 = 1379669533;
  unk_6D628C = -1075539529;
  do
  {
    v27 = sin((double)(v25 - 6) * v12) * 0.5;
    v28 = cos((double)v25 * v19 / 24.0);
    v25 += 2;
    *v26++ = v27 / v28;
  }
  while ( v25 != 31 );
  v29 = 0;
  v30 = 0.0;
  do
  {
    v31 = tan(v30 * v5 / 12.0);
    v30 = v30 + 1.0;
    v32 = 1.41421356 / (v31 + 1.0);
    tan1_1[v29] = v31 / (v31 + 1.0);
    tan2_1[v29] = 1.0 / (v31 + 1.0);
    tan1_2[v29] = v31 * 1.41421356 / (v31 + 1.0);
    LODWORD(v31) = &tan2_2[v29++];
    *(double *)LODWORD(v31) = v32;
  }
  while ( v29 != 16 );
  v33 = 0.0;
  v34 = 0;
  v35 = pow2_2[1];
  v36 = pow1_2[1];
  v37 = pow2_1[1];
  v38 = pow1_1[1];
  do
  {
    v39 = v33;
    v40 = 1.0;
    v33 = v33 + 1.0;
    v41 = v39 * 0.5;
    v42 = v33 * 0.5;
    v43 = 1.0;
    if ( v34 >= 1 )
    {
      if ( (v34 & 1) != 0 )
      {
        v40 = pow(0.840896415, v42);
        v43 = 1.0;
      }
      else
      {
        v40 = 1.0;
        v43 = pow(0.840896415, v41);
      }
    }
    v44 = v40 * 1.41421356;
    v45 = v43 * 1.41421356;
    *(v38 - 32) = v40;
    *(v37 - 32) = v43;
    v46 = 1.0;
    v47 = 1.0;
    *(v36 - 32) = v44;
    *(v35 - 32) = v45;
    if ( v34 > 0 )
    {
      if ( (v34 & 1) != 0 )
      {
        v47 = pow(0.707106781, v42);
        v46 = 1.0;
      }
      else
      {
        v47 = 1.0;
        v46 = pow(0.707106781, v41);
      }
    }
    ++v34;
    *v38++ = v47;
    *v37++ = v46;
    *v36++ = v47 * 1.41421356;
    *v35++ = v46 * 1.41421356;
  }
  while ( v34 != 32 );
  v48 = &bandInfo[0].shortDiff[3];
  win1[0][0] = win[0][0];
  shortDiff = bandInfo[0].shortDiff;
  v50 = 0;
  win1[0][2] = win[0][2];
  win1[0][4] = win[0][4];
  win1[0][6] = win[0][6];
  win1[0][8] = win[0][8];
  win1[0][10] = win[0][10];
  win1[0][12] = win[0][12];
  win1[0][14] = win[0][14];
  win1[0][16] = win[0][16];
  win1[0][18] = win[0][18];
  win1[0][20] = win[0][20];
  win1[0][22] = win[0][22];
  win1[0][24] = win[0][24];
  win1[0][26] = win[0][26];
  win1[0][28] = win[0][28];
  win1[0][30] = win[0][30];
  win1[0][32] = win[0][32];
  win1[0][34] = win[0][34];
  win1[0][1] = -win[0][1];
  win1[0][3] = -win[0][3];
  win1[0][5] = -win[0][5];
  win1[0][7] = -win[0][7];
  win1[0][9] = -win[0][9];
  win1[0][11] = -win[0][11];
  win1[0][13] = -win[0][13];
  win1[0][15] = -win[0][15];
  win1[0][17] = -win[0][17];
  win1[0][19] = -win[0][19];
  win1[0][21] = -win[0][21];
  win1[0][23] = -win[0][23];
  win1[0][25] = -win[0][25];
  win1[0][27] = -win[0][27];
  win1[0][29] = -win[0][29];
  win1[0][31] = -win[0][31];
  win1[0][33] = -win[0][33];
  win1[0][35] = -win[0][35];
  win1[1][0] = win[1][0];
  win1[1][2] = win[1][2];
  win1[1][4] = win[1][4];
  win1[1][6] = win[1][6];
  win1[1][8] = win[1][8];
  win1[1][10] = win[1][10];
  win1[1][12] = win[1][12];
  win1[1][14] = win[1][14];
  win1[1][16] = win[1][16];
  win1[1][18] = win[1][18];
  win1[1][20] = win[1][20];
  win1[1][22] = win[1][22];
  win1[1][24] = win[1][24];
  win1[1][26] = win[1][26];
  win1[1][28] = win[1][28];
  win1[1][30] = win[1][30];
  win1[1][32] = win[1][32];
  win1[1][34] = win[1][34];
  win1[1][1] = -win[1][1];
  win1[1][3] = -win[1][3];
  win1[1][5] = -win[1][5];
  win1[1][7] = -win[1][7];
  win1[1][9] = -win[1][9];
  win1[1][11] = -win[1][11];
  win1[1][13] = -win[1][13];
  win1[1][15] = -win[1][15];
  win1[1][17] = -win[1][17];
  win1[1][19] = -win[1][19];
  win1[1][21] = -win[1][21];
  win1[1][23] = -win[1][23];
  win1[1][25] = -win[1][25];
  win1[1][27] = -win[1][27];
  win1[1][29] = -win[1][29];
  win1[1][31] = -win[1][31];
  win1[1][33] = -win[1][33];
  win1[1][35] = -win[1][35];
  win1[2][0] = win[2][0];
  win1[2][1] = -win[2][1];
  win1[2][2] = win[2][2];
  win1[2][3] = -win[2][3];
  win1[2][4] = win[2][4];
  win1[2][5] = -win[2][5];
  win1[2][6] = win[2][6];
  win1[2][7] = -win[2][7];
  win1[2][8] = win[2][8];
  win1[2][9] = -win[2][9];
  win1[2][10] = win[2][10];
  win1[2][11] = -win[2][11];
  win1[3][0] = win[3][0];
  win1[3][2] = win[3][2];
  win1[3][4] = win[3][4];
  win1[3][6] = win[3][6];
  win1[3][8] = win[3][8];
  win1[3][10] = win[3][10];
  win1[3][12] = win[3][12];
  win1[3][14] = win[3][14];
  win1[3][16] = win[3][16];
  win1[3][18] = win[3][18];
  win1[3][20] = win[3][20];
  win1[3][22] = win[3][22];
  win1[3][24] = win[3][24];
  win1[3][26] = win[3][26];
  win1[3][28] = win[3][28];
  win1[3][30] = win[3][30];
  win1[3][32] = win[3][32];
  win1[3][34] = win[3][34];
  win1[3][1] = -win[3][1];
  win1[3][3] = -win[3][3];
  win1[3][5] = -win[3][5];
  win1[3][7] = -win[3][7];
  win1[3][9] = -win[3][9];
  win1[3][11] = -win[3][11];
  win1[3][13] = -win[3][13];
  win1[3][15] = -win[3][15];
  win1[3][17] = -win[3][17];
  win1[3][19] = -win[3][19];
  win1[3][21] = -win[3][21];
  win1[3][23] = -win[3][23];
  win1[3][25] = -win[3][25];
  win1[3][27] = -win[3][27];
  win1[3][29] = -win[3][29];
  win1[3][31] = -win[3][31];
  win1[3][33] = -win[3][33];
  v51 = &mapbuf0[0][32];
  win1[3][35] = -win[3][35];
  v133 = mapbuf0[1];
  x_4 = mapbuf1[1];
  v52 = mapbuf2[1];
  do
  {
    v129 = v52;
    v53 = &bandInfo[v50];
    v54 = v50;
    x = v51;
    v55 = mapbuf0[v50];
    v130 = v50;
    v56 = v50;
    v122 = v50;
    v58 = v53->longDiff[0];
    longDiff = v53->longDiff;
    v59 = longDiff[2];
    v55[7] = 1;
    map[v54][0] = v55;
    v120 = longDiff[1];
    mapbuf0[v56][0] = v58 >> 1;
    v60 = longDiff[3];
    v125 = v58 + v120 + v59;
    v118 = v125 + v60;
    v127 = longDiff[4];
    v55[1] = 0;
    v55[2] = 3;
    v55[3] = 0;
    v55[18] = 3;
    v55[5] = v58;
    v55[6] = 3;
    v55[4] = v120 >> 1;
    v119 = v120 >> 1;
    v61 = v58 + v120;
    v121 = v59 >> 1;
    v55[8] = v59 >> 1;
    v55[9] = v61;
    v55[10] = 3;
    v55[11] = 2;
    v124 = v60 >> 1;
    v55[12] = v60 >> 1;
    v55[13] = v125;
    v55[14] = 3;
    v55[15] = 3;
    v126 = v127 >> 1;
    v55[16] = v127 >> 1;
    v55[17] = v118;
    v55[19] = 4;
    v55[23] = 5;
    v62 = longDiff[6];
    v63 = longDiff[5];
    v55[24] = v62 >> 1;
    v64 = longDiff[7];
    v65 = v127;
    v128 = longDiff;
    v66 = v65 + v118;
    v55[22] = 3;
    v55[21] = v66;
    v67 = v66 + v63;
    v68 = v62 + v67;
    v55[20] = v63 >> 1;
    v55[25] = v67;
    v55[26] = 3;
    v55[27] = 6;
    v55[28] = v64 >> 1;
    v55[29] = v68;
    v55[30] = 3;
    v55[31] = 7;
    v69 = v68 + v64;
    v70 = v51;
    v71 = 0;
    do
    {
      v72 = v71 + 3;
      v73 = v48[v71++] >> 1;
      *v70 = v73;
      v70[1] = v69;
      v70[2] = 0;
      v70[3] = v72;
      v70[4] = v73;
      v70[5] = v69 + 1;
      v70[6] = 1;
      v70[7] = v72;
      v70[8] = v73;
      v70[9] = v69 + 2;
      v70[10] = 2;
      v70[11] = v72;
      v70 += 12;
      v69 += 6 * v73;
    }
    while ( v71 != 10 );
    v74 = 0;
    v75 = mapbuf1[v130];
    mapend[v122][0] = v133;
    v76 = 0;
    map[v122][1] = v75;
    do
    {
      v77 = shortDiff[v74] >> 1;
      *v75 = v77;
      v75[1] = v76;
      v75[2] = 0;
      v75[3] = v74;
      v75[4] = v77;
      v75[5] = v76 | 1;
      v75[6] = 1;
      v75[7] = v74;
      v75[8] = v77;
      v75[9] = v76 + 2;
      v75[10] = 2;
      v75[11] = v74++;
      v76 += 6 * v77;
      v75 += 12;
    }
    while ( v74 != 13 );
    shortDiff += 110;
    v48 += 110;
    v78 = mapbuf2[v130];
    v79 = &bandInfo[v130];
    map[v122][2] = v78;
    v123 = mapend[v122];
    v123[1] = x_4;
    v80 = v79->longDiff[10];
    v81 = longDiff[7] >> 1;
    v82 = longDiff[6];
    *v78 = *v128 >> 1;
    v83 = v82 >> 1;
    v78[1] = 0;
    v78[2] = v119;
    v78[3] = 1;
    v78[4] = v121;
    v78[5] = 2;
    v78[6] = v124;
    v78[7] = 3;
    v78[8] = v126;
    v78[17] = 8;
    v84 = v79->longDiff[8];
    v78[9] = 4;
    v78[10] = v63 >> 1;
    v85 = v79->longDiff[9];
    v78[11] = 5;
    v78[12] = v83;
    v78[13] = 6;
    v78[14] = v81;
    v78[15] = 7;
    v78[16] = v84 >> 1;
    v86 = v79->longDiff[11];
    v78[18] = v85 >> 1;
    v78[20] = v80 >> 1;
    v78[19] = 9;
    v87 = v79->longDiff[12];
    v78[21] = 10;
    v78[22] = v86 >> 1;
    v78[23] = 11;
    v88 = v87 >> 1;
    v89 = v79->longDiff[13];
    v78[24] = v88;
    v90 = v79->longDiff[15];
    v91 = v89 >> 1;
    v92 = v79->longDiff[14];
    v93 = v79->longDiff[16];
    v78[25] = 12;
    v78[26] = v91;
    v78[27] = 13;
    v78[28] = v92 >> 1;
    v94 = v79->longDiff[17];
    v78[29] = 14;
    v78[30] = v90 >> 1;
    v95 = v79->longDiff[19];
    v96 = v79->longDiff[20];
    v97 = v79->longDiff[21];
    v98 = v79->longDiff[18];
    v78[31] = 15;
    v78[32] = v93 >> 1;
    v78[33] = 16;
    v78[34] = v94 >> 1;
    v78[35] = 17;
    v78[36] = v98 >> 1;
    v78[37] = 18;
    v78[38] = v95 >> 1;
    v78[39] = 19;
    v78[40] = v96 >> 1;
    v78[41] = 20;
    v78[42] = v97 >> 1;
    v78[43] = 21;
    v123[2] = v129;
    v52 = v129 + 44;
    v50 = v130 + 1;
    x_4 += 156;
    v51 = x + 152;
    v133 += 152;
  }
  while ( v130 != 8 );
  v99 = 0;
  v100.n128_u64[0] = 0x304000003000LL;
  v100.n128_u64[1] = 0x30C000003080LL;
  v101 = 0;
  do
  {
    v102 = &i_slen2[v99];
    v102[5] = v101 | 0x3140;
    v102[10] = v101 | 0x3108;
    v102[11] = v101 | 0x3148;
    v102[16] = v101 | 0x3110;
    v102[17] = v101 | 0x3150;
    v102[22] = v101 | 0x3118;
    v102[23] = v101 | 0x3158;
    v102[28] = v101 | 0x3120;
    v102[29] = v101 | 0x3160;
    v102[34] = v101 | 0x3128;
    v102[35] = v101 | 0x3168;
    *(int64x2_t *)&i_slen2[v99 + 6] = vorrq_s64(vdupq_n_s32(v101 | 8), v100);
    v103 = (int64x2_t *)&i_slen2[v99 + 12];
    v104 = vorrq_s64(vdupq_n_s32(v101), v100);
    v99 += 36;
    *v103 = vorrq_s64(vdupq_n_s32(v101 | 0x10), v100);
    *(int64x2_t *)(v102 + 18) = vorrq_s64(vdupq_n_s32(v101 | 0x18), v100);
    *((int64x2_t *)v102 + 6) = vorrq_s64(vdupq_n_s32(v101 | 0x20), v100);
    *(int64x2_t *)(v102 + 30) = vorrq_s64(vdupq_n_s32(v101 | 0x28), v100);
    v105 = v101++ | 0x3100;
    *(int64x2_t *)v102 = v104;
    v102[4] = v105;
  }
  while ( v99 != 180 );
  *(_QWORD *)&i_slen2[184] = 0x404800004008LL;
  *(_QWORD *)&i_slen2[186] = 0x40C800004088LL;
  *(_QWORD *)&i_slen2[180] = 0x404000004000LL;
  *(_QWORD *)&i_slen2[182] = 0x40C000004080LL;
  *(_QWORD *)&i_slen2[188] = 0x405000004010LL;
  *(_QWORD *)&i_slen2[190] = 0x40D000004090LL;
  *(_QWORD *)&i_slen2[192] = 0x405800004018LL;
  *(_QWORD *)&i_slen2[194] = 0x40D800004098LL;
  *(_QWORD *)&i_slen2[196] = 0x404100004001LL;
  *(_QWORD *)&i_slen2[198] = 0x40C100004081LL;
  *(_QWORD *)&i_slen2[200] = 0x404900004009LL;
  *(_QWORD *)&i_slen2[202] = 0x40C900004089LL;
  *(_QWORD *)&i_slen2[204] = 0x405100004011LL;
  *(_QWORD *)&i_slen2[206] = 0x40D100004091LL;
  *(_QWORD *)&i_slen2[208] = 0x405900004019LL;
  *(_QWORD *)&i_slen2[210] = 0x40D900004099LL;
  *(_QWORD *)&i_slen2[212] = 0x404200004002LL;
  *(_QWORD *)&i_slen2[214] = 0x40C200004082LL;
  *(_QWORD *)&i_slen2[216] = 0x404A0000400ALL;
  *(_QWORD *)&i_slen2[218] = 0x40CA0000408ALL;
  *(_QWORD *)&i_slen2[220] = 0x405200004012LL;
  *(_QWORD *)&i_slen2[222] = 0x40D200004092LL;
  *(_QWORD *)&i_slen2[224] = 0x405A0000401ALL;
  *(_QWORD *)&i_slen2[226] = 0x40DA0000409ALL;
  *(_QWORD *)&i_slen2[228] = 0x404300004003LL;
  *(_QWORD *)&i_slen2[230] = 0x40C300004083LL;
  *(_QWORD *)&i_slen2[232] = 0x404B0000400BLL;
  *(_QWORD *)&i_slen2[234] = 0x40CB0000408BLL;
  *(_QWORD *)&i_slen2[236] = 0x405300004013LL;
  *(_QWORD *)&i_slen2[238] = 0x40D300004093LL;
  *(_QWORD *)&i_slen2[240] = 0x405B0000401BLL;
  *(_QWORD *)&i_slen2[242] = 0x40DB0000409BLL;
  *(_QWORD *)&i_slen2[244] = 0x500800005000LL;
  *(_QWORD *)&i_slen2[246] = 0x500100005010LL;
  *(_QWORD *)&n_slen2[500] = 0xA0080000A000LL;
  *(_QWORD *)&n_slen2[502] = 0xA0010000A010LL;
  *(_QWORD *)&i_slen2[248] = 0x501100005009LL;
  *(_QWORD *)&i_slen2[250] = 0x500A00005002LL;
  *(_QWORD *)&i_slen2[252] = 0x500300005012LL;
  *(_QWORD *)&i_slen2[254] = 0x50130000500BLL;
  v106.n128_u64[0] = 0x48000000280LL;
  v106.n128_u64[1] = 0xC000000680LL;
  v107.n128_u64[0] = 0x44000000240LL;
  v107.n128_u64[1] = 0x8000000640LL;
  v108.n128_u64[0] = 0x40000000200LL;
  v108.n128_u64[1] = 0x4000000600LL;
  *(_QWORD *)&n_slen2[504] = 0xA0110000A009LL;
  *(_QWORD *)&n_slen2[506] = 0xA00A0000A002LL;
  v109 = 0;
  *(_QWORD *)&n_slen2[508] = 0xA0030000A012LL;
  *(_QWORD *)&n_slen2[510] = 0xA0130000A00BLL;
  v110 = 0;
  do
  {
    v111 = vdupq_n_s32(v109);
    v112 = &n_slen2[v110];
    v113 = vdupq_n_s32(v109 | 8);
    *(int64x2_t *)&n_slen2[v110 + 1] = vorrq_s64(v111, v108);
    *(int64x2_t *)&n_slen2[v110 + 5] = vorrq_s64(v111, v107);
    *(int64x2_t *)&n_slen2[v110 + 9] = vorrq_s64(v111, v106);
    *(int64x2_t *)&n_slen2[v110 + 17] = vorrq_s64(v113, v108);
    *(int64x2_t *)&n_slen2[v110 + 21] = vorrq_s64(v113, v107);
    n_slen2[v110] = v109;
    v114 = vdupq_n_s32(v109 | 0x10);
    v115 = vdupq_n_s32(v109 | 0x18);
    v112[13] = v109 | 0x2C0;
    v112[14] = v109 | 0x4C0;
    v112[15] = v109 | 0x6C0;
    v112[16] = v109 | 8;
    v112[29] = v109 | 0x2C8;
    v112[30] = v109 | 0x4C8;
    v112[31] = v109 | 0x6C8;
    v112[32] = v109 | 0x10;
    v112[45] = v109 | 0x2D0;
    v112[46] = v109 | 0x4D0;
    v112[47] = v109 | 0x6D0;
    v112[48] = v109 | 0x18;
    v112[61] = v109 | 0x2D8;
    v112[62] = v109 | 0x4D8;
    v112[63] = v109 | 0x6D8;
    v112[64] = v109 | 0x20;
    v112[77] = v109 | 0x2E0;
    v112[78] = v109 | 0x4E0;
    v112[79] = v109 | 0x6E0;
    *(int64x2_t *)&n_slen2[v110 + 25] = vorrq_s64(v113, v106);
    v116 = (int64x2_t *)&n_slen2[v110 + 33];
    v117 = vdupq_n_s32(v109 | 0x20);
    v110 += 80;
    ++v109;
    *v116 = vorrq_s64(v114, v108);
    *(int64x2_t *)(v112 + 37) = vorrq_s64(v114, v107);
    *(int64x2_t *)(v112 + 41) = vorrq_s64(v114, v106);
    *(int64x2_t *)(v112 + 49) = vorrq_s64(v115, v108);
    *(int64x2_t *)(v112 + 53) = vorrq_s64(v115, v107);
    *(int64x2_t *)(v112 + 57) = vorrq_s64(v115, v106);
    *(int64x2_t *)(v112 + 65) = vorrq_s64(v117, v108);
    *(int64x2_t *)(v112 + 69) = vorrq_s64(v117, v107);
    *(int64x2_t *)(v112 + 73) = vorrq_s64(v117, v106);
  }
  while ( v110 != 400 );
  *(_QWORD *)&n_slen2[404] = 0x104800001008LL;
  *(_QWORD *)&n_slen2[406] = 0x10C800001088LL;
  *(_QWORD *)&n_slen2[400] = 0x104000001000LL;
  *(_QWORD *)&n_slen2[402] = 0x10C000001080LL;
  *(_QWORD *)&n_slen2[408] = 0x105000001010LL;
  *(_QWORD *)&n_slen2[410] = 0x10D000001090LL;
  *(_QWORD *)&n_slen2[412] = 0x105800001018LL;
  *(_QWORD *)&n_slen2[414] = 0x10D800001098LL;
  *(_QWORD *)&n_slen2[416] = 0x106000001020LL;
  *(_QWORD *)&n_slen2[418] = 0x10E0000010A0LL;
  *(_QWORD *)&n_slen2[420] = 0x104100001001LL;
  *(_QWORD *)&n_slen2[422] = 0x10C100001081LL;
  *(_QWORD *)&n_slen2[424] = 0x104900001009LL;
  *(_QWORD *)&n_slen2[426] = 0x10C900001089LL;
  *(_QWORD *)&n_slen2[428] = 0x105100001011LL;
  *(_QWORD *)&n_slen2[430] = 0x10D100001091LL;
  *(_QWORD *)&n_slen2[432] = 0x105900001019LL;
  *(_QWORD *)&n_slen2[434] = 0x10D900001099LL;
  *(_QWORD *)&n_slen2[436] = 0x106100001021LL;
  *(_QWORD *)&n_slen2[438] = 0x10E1000010A1LL;
  *(_QWORD *)&n_slen2[440] = 0x104200001002LL;
  *(_QWORD *)&n_slen2[442] = 0x10C200001082LL;
  *(_QWORD *)&n_slen2[444] = 0x104A0000100ALL;
  *(_QWORD *)&n_slen2[446] = 0x10CA0000108ALL;
  *(_QWORD *)&n_slen2[448] = 0x105200001012LL;
  *(_QWORD *)&n_slen2[450] = 0x10D200001092LL;
  *(_QWORD *)&n_slen2[452] = 0x105A0000101ALL;
  *(_QWORD *)&n_slen2[454] = 0x10DA0000109ALL;
  *(_QWORD *)&n_slen2[456] = 0x106200001022LL;
  *(_QWORD *)&n_slen2[458] = 0x10E2000010A2LL;
  *(_QWORD *)&n_slen2[460] = 0x104300001003LL;
  *(_QWORD *)&n_slen2[462] = 0x10C300001083LL;
  *(_QWORD *)&n_slen2[464] = 0x104B0000100BLL;
  *(_QWORD *)&n_slen2[466] = 0x10CB0000108BLL;
  *(_QWORD *)&n_slen2[468] = 0x105300001013LL;
  *(_QWORD *)&n_slen2[470] = 0x10D300001093LL;
  *(_QWORD *)&n_slen2[472] = 0x105B0000101BLL;
  *(_QWORD *)&n_slen2[474] = 0x10DB0000109BLL;
  *(_QWORD *)&n_slen2[480] = 0x104400001004LL;
  *(_QWORD *)&n_slen2[482] = 0x10C400001084LL;
  *(_QWORD *)&n_slen2[476] = 0x106300001023LL;
  *(_QWORD *)&n_slen2[478] = 0x10E3000010A3LL;
  *(_QWORD *)&n_slen2[484] = 0x104C0000100CLL;
  *(_QWORD *)&n_slen2[486] = 0x10CC0000108CLL;
  *(_QWORD *)&n_slen2[488] = 0x105400001014LL;
  *(_QWORD *)&n_slen2[490] = 0x10D400001094LL;
  *(_QWORD *)&n_slen2[492] = 0x105C0000101CLL;
  *(_QWORD *)&n_slen2[494] = 0x10DC0000109CLL;
  *(_QWORD *)&n_slen2[496] = 0x106400001024LL;
  *(_QWORD *)&n_slen2[498] = 0x10E4000010A4LL;
}
// 6D6260: using guessed type int cos9_0;
// 6D6264: using guessed type int dword_6D6264;
// 6D6268: using guessed type int cos9_1;
// 6D626C: using guessed type int dword_6D626C;
// 6D6270: using guessed type int cos9_2;
// 6D6274: using guessed type int dword_6D6274;

//----- (0022B71C) --------------------------------------------------------
void __fastcall INT123_init_layer3_stuff(mpg123_handle *fr, double (*gainpow2)(mpg123_handle *, int))
{
  int v2; // r5
  double *v4; // r6
  const bandInfoStruct *v6; // r0
  int (*shortLimit)[14]; // r1
  int *p_down_sample_sblimit; // r9
  int (*longLimit)[23]; // r3
  int v10; // r12
  int i; // r6
  unsigned int v12; // kr00_4
  unsigned int v13; // r2
  int j; // r6
  int v15; // r2
  int v16; // r5

  v2 = -378;
  v4 = fr->gainpow2;
  do
  {
    *(_QWORD *)v4++ = ((__int64 (__fastcall *)(mpg123_handle *, int))gainpow2)(fr, v2 + 122);
    ++v2;
  }
  while ( v2 );
  v6 = bandInfo;
  shortLimit = fr->shortLimit;
  p_down_sample_sblimit = &fr->down_sample_sblimit;
  longLimit = fr->longLimit;
  v10 = 0;
  do
  {
    for ( i = 0; i != 23; ++i )
    {
      v12 = v6->longIdx[i] + 7;
      (*longLimit)[i] = v12 / 0x12 + 1;
      v13 = *p_down_sample_sblimit;
      if ( (int)(v12 / 0x12) < *p_down_sample_sblimit )
        v13 = v12 / 0x12 + 1;
      (*longLimit)[i] = v13;
    }
    for ( j = 0; j != 14; ++j )
    {
      v15 = (v6->shortIdx[j] - 1) / 18;
      (*shortLimit)[j] = v15 + 1;
      v16 = *p_down_sample_sblimit;
      if ( v15 < *p_down_sample_sblimit )
        v16 = v15 + 1;
      (*shortLimit)[j] = v16;
    }
    ++v10;
    ++shortLimit;
    ++longLimit;
    ++v6;
  }
  while ( v10 != 9 );
}

//----- (0022B7E0) --------------------------------------------------------
void __fastcall INT123_dct36(double *inbuf, double *o1, double *o2, double *wintab, double *tsbuf)
{
  double v5; // d16
  double v6; // d17
  double v7; // d18
  double v8; // d20
  double v9; // d21
  double v10; // d22
  double v11; // d23
  double v12; // d25
  double v13; // d27
  double v14; // d1
  double v15; // d2
  double v16; // d3
  double v17; // d0
  double v18; // d30
  double v19; // d29
  double v20; // d11
  double v21; // d4
  double v22; // d6
  double v23; // d5
  double v24; // d22
  double v25; // d7
  double v26; // d8
  double v27; // d17
  double v28; // d14
  double v29; // d18
  double v30; // d13
  double v31; // d21
  double v32; // d2
  double v33; // d1
  double v34; // d28
  double v35; // d26
  double v36; // d5
  double v37; // d3
  double v38; // d27
  double v39; // d18
  double v40; // d6
  double v41; // d9
  double v42; // d17
  double v43; // d2
  double v44; // d25
  double v45; // d17
  double v46; // d20
  double v47; // d24
  double v48; // d7
  double v49; // d19
  double v50; // d4
  double v51; // d10
  double v52; // d11
  double v53; // d12
  double v54; // d18
  double v55; // d1
  double v56; // d15
  double v57; // d0
  double v58; // d31
  double v59; // d8
  double v60; // d21
  double v61; // d0
  double v62; // d26
  double v63; // d17
  double v64; // d27
  double v65; // d19
  double v66; // d28
  double v67; // d13
  double v68; // d16
  double v69; // d30
  double v70; // d18
  double v71; // d20
  double v72; // d18
  double v73; // d22
  double v74; // d20
  double v75; // d5
  double v76; // d24
  double v77; // d3
  double v78; // d25
  double v79; // d21
  double v80; // d19
  double v81; // d18
  double v82; // d29
  double v83; // d23
  double v84; // d18
  double v85; // d20
  double v86; // d23
  double v87; // d24
  double v88; // d21
  double v89; // d22
  double v90; // d29
  double v91; // d24
  double v92; // d21
  double v93; // d17
  double v94; // d16
  double v95; // d24
  double v96; // d16
  double v97; // d17
  double v98; // d20
  double v99; // d17
  double v100; // d16
  double v101; // d17
  double v102; // d19
  double v103; // d17
  double v104; // d16
  double v105; // d17
  double v106; // d18
  double v107; // d17
  double v108; // d16
  double v109; // d17
  double v110; // d19
  double v111; // d18
  double v112; // d17
  double v113; // [sp+0h] [bp-D8h]
  double v114; // [sp+8h] [bp-D0h]
  double v115; // [sp+10h] [bp-C8h]
  double v116; // [sp+18h] [bp-C0h]
  double v117; // [sp+20h] [bp-B8h]
  double v118; // [sp+28h] [bp-B0h]
  double v119; // [sp+30h] [bp-A8h]
  double v120; // [sp+38h] [bp-A0h]
  double v121; // [sp+40h] [bp-98h]
  double v122; // [sp+48h] [bp-90h]
  double v123; // [sp+50h] [bp-88h]
  double v124; // [sp+58h] [bp-80h]
  double v125; // [sp+60h] [bp-78h]
  double v126; // [sp+68h] [bp-70h]
  double v127; // [sp+80h] [bp-58h]

  v5 = inbuf[16];
  v6 = inbuf[8];
  v7 = inbuf[9];
  v8 = inbuf[10];
  v9 = inbuf[11];
  v10 = inbuf[12];
  v11 = inbuf[13];
  v12 = inbuf[14];
  v13 = inbuf[15];
  v14 = inbuf[5];
  v15 = inbuf[6];
  v16 = inbuf[7];
  v17 = v10 + v9;
  v18 = v6 + v16;
  v19 = v8 + v7;
  v20 = v15 + v14;
  v114 = v13 + v5;
  v21 = inbuf[17];
  inbuf[16] = v13 + v5;
  inbuf[14] = v12 + v11;
  inbuf[12] = v10 + v9;
  inbuf[10] = v8 + v7;
  inbuf[8] = v6 + v16;
  inbuf[6] = v15 + v14;
  v22 = inbuf[4];
  v23 = inbuf[3];
  v24 = v11 + v10;
  v113 = v22 + v23;
  inbuf[4] = v22 + v23;
  v25 = inbuf[1];
  v26 = inbuf[2];
  v27 = v7 + v6;
  v28 = v26 + v25;
  v29 = v9 + v8;
  inbuf[2] = v26 + v25;
  v30 = *inbuf;
  v31 = v16 + v15;
  v32 = v23 + v26;
  v33 = v14 + v22;
  v34 = v25 + *inbuf;
  v35 = v29 + v27;
  v36 = v13 + v12 + v24;
  v37 = v13 + v12 + v5 + v21;
  v38 = v27 + v31;
  v39 = v24 + v29;
  v40 = v33 + v32;
  v41 = v32 + v34;
  inbuf[1] = v34;
  inbuf[17] = v37;
  inbuf[15] = v36;
  inbuf[13] = v39;
  inbuf[11] = v35;
  inbuf[9] = v27 + v31;
  inbuf[7] = v31 + v33;
  inbuf[5] = v33 + v32;
  inbuf[3] = v32 + v34;
  v42 = v32 + v34 + v35;
  v43 = v12 + v11;
  v44 = COS6_1;
  v122 = cos18_0 * v42;
  v45 = COS6_1 * (v31 + v33) + cos18_0 * v42 + cos18_1 * (v35 - v36);
  v118 = cos18_1 * (v35 - v36);
  v117 = COS6_1 * (v31 + v33);
  v46 = COS6_2;
  v47 = COS6_2 * v39;
  v48 = COS6_2 * v39 + v34;
  v121 = *(double *)&cos9_1 * (v38 - v37);
  v116 = *(double *)&cos9_0 * (v38 + v40);
  v49 = INT123_tfcos36[0] * (v116 + v121 + v48 + v45);
  v50 = (v19 - v43) * cos18_1;
  v51 = COS6_1 * v20;
  v52 = (v19 + v28) * cos18_0;
  v115 = INT123_tfcos36[2];
  v119 = INT123_tfcos36[3];
  v53 = (v18 - v114) * *(double *)&cos9_1;
  v54 = COS6_2 * v17;
  v55 = (v18 + v113) * *(double *)&cos9_0;
  v56 = v30 + COS6_2 * v17;
  v127 = v45;
  v57 = v56 + v55 + v53 + v52 + v50 + v51;
  v58 = *(double *)&cos9_2;
  v59 = INT123_tfcos36[1];
  v126 = INT123_tfcos36[8];
  v125 = INT123_tfcos36[7];
  v124 = INT123_tfcos36[6];
  v123 = INT123_tfcos36[5];
  v120 = INT123_tfcos36[4];
  v60 = cos18_2;
  o2[9] = (v57 + v49) * wintab[27];
  o2[8] = (v57 + v49) * wintab[26];
  tsbuf[256] = o1[8] + (v57 - v49) * wintab[8];
  tsbuf[288] = o1[9] + (v57 - v49) * wintab[9];
  v61 = v44 * (v35 + v36 - v41);
  v62 = v46 * (v38 + v37 - v40);
  v63 = v34 - v47 - v47;
  v64 = v63 - v62;
  v65 = (v63 - v62 - v61) * v59;
  v66 = v44 * (v19 + v43 - v28);
  v67 = v30 - v54 - v54;
  v68 = v46 * (v18 + v114 - v113);
  v69 = v67 - v68;
  v70 = v67 - v68 - v66;
  v71 = v70 + v65;
  v72 = v70 - v65;
  o2[10] = v71 * wintab[28];
  o2[7] = v71 * wintab[25];
  tsbuf[224] = o1[7] + v72 * wintab[7];
  v73 = (v114 + v113) * v58;
  tsbuf[320] = o1[10] + v72 * wintab[10];
  v74 = v60 * (v41 + v36);
  v75 = v118 - (v74 + v117);
  v76 = v58 * (v37 + v40);
  v77 = v48 - v116 - v76;
  v78 = (v77 + v75) * v115;
  v79 = (v43 + v28) * v60;
  v80 = v50 - v51 - v79;
  v81 = v56 - v55 - v73;
  v82 = v81 + v80 + v78;
  v83 = v81 + v80 - v78;
  o2[11] = v82 * wintab[29];
  o2[6] = v82 * wintab[24];
  tsbuf[192] = o1[6] + v83 * wintab[6];
  v84 = v81 - v80;
  tsbuf[352] = o1[11] + v83 * wintab[11];
  v85 = v122 + v74 - v117;
  v86 = v48 + v76 - v121;
  v87 = v119 * (v86 + v85);
  v88 = v52 - v51 + v79;
  v89 = v56 - v53 + v73;
  v90 = v89 + v88 + v87;
  o2[12] = v90 * wintab[30];
  v91 = v89 + v88 - v87;
  o2[5] = v90 * wintab[23];
  tsbuf[160] = o1[5] + v91 * wintab[5];
  v92 = v89 - v88;
  tsbuf[384] = o1[12] + v91 * wintab[12];
  v93 = v120 * (v62 + v62 + v63);
  v94 = v68 + v68 + v67;
  v95 = v94 + v93;
  o2[13] = (v94 + v93) * wintab[31];
  v96 = v94 - v93;
  o2[4] = v95 * wintab[22];
  tsbuf[128] = o1[4] + v96 * wintab[4];
  v97 = (v86 - v85) * v123;
  v98 = v92 + v97;
  tsbuf[416] = o1[13] + v96 * wintab[13];
  v99 = v92 - v97;
  o2[14] = v98 * wintab[32];
  o2[3] = v98 * wintab[21];
  tsbuf[96] = o1[3] + v99 * wintab[3];
  v100 = v99 * wintab[14];
  v101 = (v77 - v75) * v124;
  v102 = v84 + v101;
  tsbuf[448] = o1[14] + v100;
  v103 = v84 - v101;
  o2[15] = v102 * wintab[33];
  o2[2] = v102 * wintab[20];
  tsbuf[64] = o1[2] + v103 * wintab[2];
  v104 = v103 * wintab[15];
  v105 = (v64 + v61) * v125;
  v106 = v69 + v66 + v105;
  tsbuf[480] = o1[15] + v104;
  v107 = v69 + v66 - v105;
  o2[16] = v106 * wintab[34];
  o2[1] = v106 * wintab[19];
  tsbuf[32] = o1[1] + v107 * wintab[1];
  v108 = v107 * wintab[16];
  v109 = v126 * (v116 + v121 + v48 - v127);
  v110 = v56 + v55 + v53 - (v52 + v50 + v51);
  v111 = v110 + v109;
  tsbuf[512] = o1[16] + v108;
  v112 = v110 - v109;
  o2[17] = v111 * wintab[35];
  *o2 = v111 * wintab[18];
  *tsbuf = *o1 + v112 * *wintab;
  tsbuf[544] = o1[17] + v112 * wintab[17];
}
// 6D6260: using guessed type int cos9_0;
// 6D6268: using guessed type int cos9_1;
// 6D6270: using guessed type int cos9_2;

//----- (0022BE68) --------------------------------------------------------
int __fastcall INT123_do_layer3(mpg123_handle *fr)
{
  int v1; // r8
  int stereo; // r3
  int single; // r10
  int v4; // r2
  unsigned __int8 *wordpointer; // r3
  int bitindex; // r4
  int *p_bitindex; // r11
  int lsf; // r5
  double *v9; // r6
  unsigned __int8 **p_wordpointer; // r8
  unsigned int v11; // r2
  int v12; // r1
  int v13; // r3
  mpg123_handle *v14; // r9
  unsigned int bitreservoir; // r10
  int v16; // r2
  double *v17; // r0
  unsigned __int8 *v18; // r6
  int v19; // r1
  unsigned __int8 *v20; // r0
  int v21; // r1
  unsigned int *v22; // r2
  int *p_ssize; // r6
  int v24; // lr
  unsigned __int8 *v25; // r4
  unsigned int *v26; // r10
  int v27; // r2
  int v28; // r3
  int v29; // r5
  int v30; // r3
  unsigned int v31; // r5
  unsigned int v32; // r3
  int v33; // r3
  int v34; // r3
  unsigned int v35; // r6
  unsigned int *p_ultmp; // r10
  unsigned int v37; // r0
  int v38; // r1
  unsigned int v39; // r6
  unsigned __int8 *v40; // r0
  int v41; // r1
  int v42; // r6
  unsigned int *v43; // r3
  unsigned int v44; // r4
  unsigned int v45; // r5
  unsigned int v46; // r1
  unsigned int v47; // r4
  int v48; // r12
  int *p_flags; // lr
  int *v50; // r9
  int v51; // r3
  int v52; // r3
  bool v53; // zf
  int v54; // r3
  int v55; // r3
  int v56; // r6
  unsigned __int8 *v57; // r4
  unsigned __int8 *v58; // r5
  int v59; // r6
  int v60; // r2
  int v61; // r3
  int v62; // r6
  int v63; // r2
  int v64; // r4
  unsigned __int8 *v65; // r1
  int v66; // r0
  unsigned int v67; // r2
  unsigned int v68; // r2
  int v69; // r3
  unsigned int v70; // r2
  unsigned __int8 *v71; // r6
  double *v72; // r0
  int v73; // r2
  int v74; // r3
  int v75; // r1
  int v76; // r2
  unsigned int v77; // r1
  unsigned __int8 *v78; // r3
  int v79; // r6
  unsigned int v80; // r5
  int v81; // r2
  unsigned __int8 *v82; // r1
  unsigned int v83; // r3
  unsigned int v84; // r3
  unsigned int v85; // r2
  unsigned int v86; // r0
  unsigned __int8 *v87; // r3
  unsigned int v88; // r0
  unsigned int v89; // r1
  unsigned int v90; // r0
  unsigned __int8 *v91; // r2
  unsigned int v92; // r0
  unsigned int v93; // r0
  unsigned int v94; // r1
  unsigned __int8 *v95; // r3
  unsigned int v96; // r0
  unsigned int v97; // r0
  unsigned int v98; // r1
  unsigned __int8 *v99; // r2
  unsigned int v100; // r6
  unsigned int v101; // r1
  unsigned int v102; // r3
  unsigned int v103; // r6
  unsigned int v104; // r3
  int v105; // r6
  unsigned int v106; // r5
  unsigned __int8 *v107; // r0
  int v108; // r1
  unsigned int v109; // r2
  int v110; // r2
  unsigned int v111; // r2
  unsigned int v112; // r3
  char v113; // r5
  unsigned __int8 *v114; // r6
  unsigned int v115; // r2
  unsigned __int8 *v116; // r3
  unsigned int v117; // r1
  unsigned int v118; // r1
  unsigned int v119; // r1
  unsigned int v120; // r2
  unsigned __int8 *v121; // r6
  unsigned int v122; // r1
  unsigned int v123; // r1
  unsigned int v124; // r2
  unsigned __int8 *v125; // r3
  unsigned int v126; // r1
  unsigned int v127; // r1
  unsigned int v128; // r2
  unsigned __int8 *v129; // r6
  unsigned int v130; // r1
  unsigned int v131; // r1
  double *v132; // r0
  unsigned int v133; // r1
  unsigned __int8 *v134; // r2
  int v135; // r6
  unsigned int v136; // r0
  unsigned int v137; // r0
  unsigned int v138; // r1
  unsigned int v139; // r5
  int v140; // r3
  bool v141; // zf
  int mpeg25; // r6
  int v143; // r2
  unsigned int v144; // r2
  unsigned int v145; // r1
  unsigned int v146; // r2
  int v147; // r1
  char v148; // r6
  unsigned __int8 *v149; // r3
  unsigned int v150; // r1
  unsigned int v151; // r2
  mpg123_handle *v152; // r10
  unsigned __int8 *v153; // r0
  int v154; // r6
  const bandInfoStruct *v155; // r1
  int v156; // r3
  int scale_factors_2; // r0
  int v158; // r3
  int scale_factors_1; // r0
  __int64 *v160; // r5
  int *v161; // r12
  int v162; // r0
  double *v163; // r2
  int v164; // r1
  int v165; // r0
  double *v166; // r3
  double v167; // d17
  double v168; // d16
  __int64 v169; // kr00_8
  double (**v170)[16]; // r0
  double (*v171)[16]; // lr
  double (*v172)[16]; // r9
  int v173; // r4
  _DWORD *v174; // r3
  _BOOL4 v175; // r12
  int v176; // r0
  int v177; // r6
  int v178; // r2
  int v179; // r0
  int v180; // r0
  double v181; // d17
  double v182; // d16
  double *v183; // r2
  double v184; // d18
  int v185; // r0
  double v186; // d17
  double v187; // d16
  double *v188; // r2
  int v189; // r0
  double v190; // d18
  int v191; // r0
  int v192; // r2
  int v193; // r3
  int v194; // r6
  int v195; // r0
  int v196; // r4
  double v197; // d16
  double *v198; // r1
  double *v199; // r6
  double v200; // d17
  double v201; // d18
  int v202; // r0
  int v203; // r2
  int v204; // r3
  int v205; // r6
  int v206; // r0
  int v207; // r4
  double v208; // d16
  double *v209; // r1
  double *v210; // r6
  double v211; // d17
  double v212; // d18
  double *v213; // r2
  double v214; // d16
  int v215; // r0
  double v216; // d17
  double v217; // d18
  __int16 v218; // r3
  int *v219; // r1
  unsigned int v220; // r2
  unsigned int v221; // r1
  _DWORD *v222; // r12
  int v223; // t1
  double *v224; // r1
  int v225; // r0
  _DWORD *v226; // r12
  int v227; // t1
  int v228; // r0
  __int64 v229; // d16
  __int64 *v230; // r1
  int v231; // r4
  double *v232; // r12
  double (*v233)[18]; // lr
  int *v234; // r5
  _DWORD *v235; // r11
  int v236; // r0
  double v237; // d16
  double v238; // d17
  double v239; // d18
  double v240; // d19
  double v241; // d20
  double v242; // d21
  double v243; // d22
  double v244; // d23
  double v245; // d24
  double v246; // d25
  double v247; // d26
  double v248; // d27
  double v249; // d28
  double v250; // d29
  double v251; // d30
  double v252; // d31
  double *v253; // r1
  double v254; // d0
  double *v255; // r2
  double v256; // d1
  double v257; // d2
  double v258; // d3
  double v259; // d4
  double v260; // d5
  double v261; // d6
  double v262; // d7
  double v263; // d0
  double v264; // d1
  double v265; // d0
  double v266; // d1
  double v267; // d0
  double v268; // d1
  double v269; // d1
  double v270; // d0
  int *v271; // r0
  int *v272; // r8
  int v273; // r1
  double (*v274)[32]; // r9
  int v275; // r6
  int v276; // r2
  int v277; // r5
  unsigned int v278; // r3
  unsigned int v279; // r1
  _DWORD *v280; // r8
  int v281; // t1
  int v282; // r4
  unsigned int v283; // r11
  double *v284; // r12
  unsigned int v285; // r4
  unsigned int v286; // r0
  _QWORD *v287; // r1
  __int64 v288; // d16
  int i; // r4
  int v290; // r0
  int sfreq; // [sp+0h] [bp-3B0h]
  unsigned __int8 *v293; // [sp+8h] [bp-3A8h]
  int v294; // [sp+14h] [bp-39Ch]
  int i_stereo; // [sp+18h] [bp-398h]
  int v296; // [sp+24h] [bp-38Ch]
  int v297; // [sp+30h] [bp-380h]
  int sampling_frequency; // [sp+34h] [bp-37Ch]
  unsigned __int16 *v299; // [sp+38h] [bp-378h]
  unsigned __int8 *v300; // [sp+3Ch] [bp-374h]
  unsigned int v301; // [sp+40h] [bp-370h]
  int v302; // [sp+44h] [bp-36Ch]
  int *p_lsf; // [sp+48h] [bp-368h]
  double (*xr)[18]; // [sp+58h] [bp-358h]
  int v306; // [sp+64h] [bp-34Ch]
  int v307; // [sp+68h] [bp-348h]
  int v308; // [sp+6Ch] [bp-344h]
  const bandInfoStruct *v309; // [sp+6Ch] [bp-344h]
  _DWORD *v310; // [sp+70h] [bp-340h]
  int v311; // [sp+70h] [bp-340h]
  int v312; // [sp+74h] [bp-33Ch]
  double *v313; // [sp+74h] [bp-33Ch]
  int *v314; // [sp+78h] [bp-338h]
  int v315; // [sp+78h] [bp-338h]
  double (*hybrid_out)[18][32]; // [sp+7Ch] [bp-334h]
  char v317; // [sp+88h] [bp-328h]
  double *wintab; // [sp+8Ch] [bp-324h]
  double *wintaba; // [sp+8Ch] [bp-324h]
  double *v320; // [sp+90h] [bp-320h]
  double *v321; // [sp+90h] [bp-320h]
  double *v322; // [sp+90h] [bp-320h]
  unsigned __int8 *v323; // [sp+94h] [bp-31Ch]
  int ssize; // [sp+94h] [bp-31Ch]
  double *v325; // [sp+94h] [bp-31Ch]
  unsigned int v326; // [sp+98h] [bp-318h]
  unsigned __int8 *p_uctmp; // [sp+98h] [bp-318h]
  double (*v328)[18]; // [sp+98h] [bp-318h]
  unsigned int *p_bitreservoir; // [sp+9Ch] [bp-314h]
  int v330; // [sp+9Ch] [bp-314h]
  int *v331; // [sp+9Ch] [bp-314h]
  unsigned int v332; // [sp+9Ch] [bp-314h]
  int v333[16]; // [sp+A0h] [bp-310h] BYREF
  int v334; // [sp+E0h] [bp-2D0h] BYREF
  int v335; // [sp+104h] [bp-2ACh] BYREF
  int scf[39]; // [sp+218h] [bp-198h] BYREF
  int v337[20]; // [sp+2B4h] [bp-FCh] BYREF
  int v338; // [sp+304h] [bp-ACh]

  v1 = 0;
  stereo = fr->stereo;
  sampling_frequency = fr->sampling_frequency;
  single = fr->single;
  if ( stereo == 1 )
    single = 0;
  v4 = 1;
  if ( fr->single == -1 )
    v4 = 2;
  v302 = fr->stereo;
  if ( stereo == 1 )
    v4 = 1;
  i_stereo = 0;
  v306 = v4;
  v301 = 0;
  if ( fr->mode == 1 )
  {
    i_stereo = fr->mode_ext & 1;
    v301 = ((unsigned int)fr->mode_ext >> 1) & 1;
  }
  wordpointer = fr->wordpointer;
  bitindex = fr->bitindex;
  p_bitindex = &fr->bitindex;
  lsf = fr->lsf;
  v297 = single;
  v320 = (double *)(5 * lsf);
  v310 = &III_get_side_info_tabs[5 * lsf];
  if ( single == 3 )
    v1 = 4;
  v9 = (double *)III_get_side_info_tabs[5 * lsf + 1];
  v308 = v1;
  p_wordpointer = &fr->wordpointer;
  v11 = (((wordpointer[2] | ((wordpointer[1] | (*wordpointer << 8)) << 8)) << bitindex) & 0xFFFFFFu) >> (24 - (_BYTE)v9);
  v12 = ((unsigned int)v9 + bitindex) & 7;
  fr->bitindex = v12;
  v323 = &wordpointer[((int)v9 + bitindex) >> 3];
  fr->wordpointer = v323;
  p_lsf = &fr->lsf;
  v13 = 2;
  if ( lsf )
    v13 = 1;
  v333[0] = v11;
  v296 = v13;
  p_bitreservoir = &fr->bitreservoir;
  v14 = fr;
  bitreservoir = fr->bitreservoir;
  v326 = lsf;
  if ( v11 <= bitreservoir )
  {
    p_ssize = &fr->ssize;
    v24 = lsf;
    v25 = v323;
  }
  else
  {
    v317 = 24 - (_BYTE)v9;
    wintab = v9;
    if ( fr->to_ignore || (fr->p.flags & 0x20) != 0 || fr->p.verbose < 2 )
    {
      v16 = lsf;
      v17 = v9;
      v18 = v323;
    }
    else
    {
      fprintf((FILE *)stderr, "Note: missing %d bytes in bit reservoir for frame %li\n", v11 - bitreservoir, fr->num);
      v18 = *p_wordpointer;
      v12 = *p_bitindex;
      v16 = *p_lsf;
      bitreservoir = *p_bitreservoir;
      v17 = wintab;
    }
    v19 = v12 - (_DWORD)v17;
    v20 = &v18[v19 >> 3];
    *p_wordpointer = v20;
    *p_bitindex = v19 & 7;
    if ( v16 )
    {
      v21 = 0;
      v22 = p_bitreservoir;
    }
    else
    {
      *v20 = bitreservoir >> 1;
      v22 = p_bitreservoir;
      v20 = *p_wordpointer;
      LOBYTE(bitreservoir) = *(_BYTE *)p_bitreservoir << 7;
      v21 = 1;
    }
    v20[v21] = bitreservoir;
    v26 = v22;
    v14 = fr;
    memset(*p_wordpointer + 2, 0, fr->ssize - 2);
    v27 = *p_bitindex;
    v28 = (int)wintab + *p_bitindex;
    v29 = (*p_wordpointer)[2];
    v25 = &(*p_wordpointer)[v28 >> 3];
    v12 = v28 & 7;
    v30 = (*p_wordpointer)[1] | (**p_wordpointer << 8);
    *p_wordpointer = v25;
    *p_bitindex = v12;
    v11 = (((v29 | (v30 << 8)) << v27) & 0xFFFFFFu) >> v317;
    v333[0] = v11;
    bitreservoir = *v26;
    v24 = *p_lsf;
    p_ssize = &fr->ssize;
  }
  v31 = v14->framesize + bitreservoir - *p_ssize;
  ssize = *p_ssize;
  if ( v14->error_protection )
    v31 -= 2;
  v32 = 255;
  if ( !v24 )
    v32 = 511;
  if ( v31 <= v32 )
    v32 = v31;
  *p_bitreservoir = v32;
  v33 = 3;
  if ( v302 == 1 )
    v33 = 2;
  v34 = III_get_side_info_tabs[(_DWORD)v320 + v33];
  v35 = (unsigned __int8)(*v25 << v12);
  p_ultmp = &v14->ultmp;
  v14->ultmp = v35;
  v37 = v25[1] << v12;
  v38 = v12 + v34;
  v39 = (v35 | (v37 >> 8)) << v34 >> 8;
  v40 = &v25[v38 >> 3];
  v41 = v38 & 7;
  v14->ultmp = v39;
  *p_wordpointer = v40;
  *p_bitindex = v41;
  v333[1] = v39;
  if ( v302 >= 1 && !v24 )
  {
    v42 = v302;
    v43 = (unsigned int *)&v335;
    do
    {
      *(v43 - 23) = -1;
      --v42;
      v44 = (unsigned __int8)(*v40 << v41);
      *p_ultmp = v44;
      v45 = v40[1] << v41;
      v46 = v41 + 4;
      v40 += v46 >> 3;
      v41 = v46 & 7;
      v47 = (v44 | (v45 >> 8)) >> 4;
      *p_ultmp = v47;
      *p_wordpointer = v40;
      *p_bitindex = v41;
      *v43 = v47;
      v43 += 46;
    }
    while ( v42 );
  }
  if ( v326 > 1 )
  {
LABEL_72:
    v152 = fr;
    v153 = &fr->bsbuf[ssize - v11];
    *p_wordpointer = v153;
    if ( v11 )
      qmemcpy(v153, &fr->bsbufold[fr->fsizeold - v11], v11);
    *p_bitindex = 0;
    v154 = 0;
    v155 = &bandInfo[sampling_frequency];
    v156 = i_stereo | v301;
    if ( i_stereo | v301 )
      v156 = 1;
    v294 = (v297 == 3) | v156;
    v293 = &v155->longDiff[21];
    v299 = &v155->shortIdx[12];
    v300 = &v155->shortDiff[12];
    v309 = &bandInfo[sampling_frequency];
    v315 = 0;
    while ( 1 )
    {
      v331 = &v333[23 * v154];
      hybrid_out = fr->layer3.hybrid_out;
      xr = (double (*)[18])fr->layer3.hybrid_in;
      if ( *p_lsf )
        scale_factors_2 = III_get_scale_factors_2(v152, scf, (gr_info_s *)(v331 + 2), 0);
      else
        scale_factors_2 = III_get_scale_factors_1(v152, scf, (gr_info_s *)(v331 + 2), v156, sfreq);
      if ( III_dequantize_sample(v152, xr, scf, (gr_info_s *)(v331 + 2), sampling_frequency, scale_factors_2) )
      {
        if ( (v152->p.flags & 0x20) == 0 && v152->p.verbose >= 2 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: dequantization failed!\n",
            1998);
        return v315;
      }
      v307 = v154;
      if ( v302 == 2 )
      {
        if ( *p_lsf )
          scale_factors_1 = III_get_scale_factors_2(v152, v337, (gr_info_s *)(v331 + 48), i_stereo);
        else
          scale_factors_1 = III_get_scale_factors_1(v152, v337, (gr_info_s *)(v331 + 48), v158, sfreq);
        v160 = (__int64 *)&(*xr)[576];
        if ( III_dequantize_sample(v152, xr + 32, v337, (gr_info_s *)(v331 + 48), sampling_frequency, scale_factors_1) )
        {
          if ( (v152->p.flags & 0x20) == 0 && v152->p.verbose >= 2 )
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: dequantization failed!\n",
              2014);
          return v315;
        }
        v161 = &v333[23 * v154];
        if ( v301 )
        {
          v162 = v331[15];
          if ( v331[61] > (unsigned int)v162 )
            v162 = v331[61];
          if ( v162 >= 1 )
          {
            v163 = (double *)xr;
            v164 = 0;
            v165 = 18 * v162;
            do
            {
              v166 = v163 + 576;
              ++v164;
              v167 = v163[576];
              v168 = *v163 - v167;
              *v163 = *v163 + v167;
              ++v163;
              *v166 = v168;
            }
            while ( v164 < v165 );
          }
        }
        if ( i_stereo )
        {
          v169 = *(_QWORD *)(v331 + 51);
          v170 = &off_660E2C[4 * *p_lsf + 2 * (v169 & *p_lsf)];
          v171 = v170[2 * v301];
          v172 = v170[2 * v301 + 1];
          if ( HIDWORD(v169) == 2 )
          {
            v173 = 0;
            v174 = v331 + 53;
            v175 = v331[53] != 0;
            do
            {
              v176 = v331[v173 + 57];
              if ( v176 > 3 )
                v175 = 0;
              if ( v176 <= 11 )
              {
                do
                {
                  v177 = v176;
                  v178 = scf[3 * v176 + v173 - *v174 + 39];
                  if ( v178 != 7 )
                  {
                    v179 = v309->shortDiff[v176];
                    if ( v309->shortDiff[v177] )
                    {
                      v180 = v179 + 1;
                      v181 = (*v171)[v178];
                      v182 = (*v172)[v178];
                      v183 = (double *)&v160[bandInfo[sampling_frequency].shortIdx[v177] + v173];
                      do
                      {
                        --v180;
                        v184 = v182 * *(v183 - 576);
                        *(v183 - 576) = v181 * *(v183 - 576);
                        *v183 = v184;
                        v183 += 3;
                      }
                      while ( v180 > 1 );
                    }
                  }
                  v176 = v177 + 1;
                }
                while ( v177 < 11 );
              }
              v185 = scf[v173 + 33 - *v174 + 39];
              if ( v185 != 7 )
              {
                v186 = (*v171)[v185];
                v187 = (*v172)[v185];
                v188 = (double *)&v160[v173 + *v299];
                v189 = *v300 + 1;
                do
                {
                  --v189;
                  v190 = v187 * *(v188 - 576);
                  *(v188 - 576) = v186 * *(v188 - 576);
                  *v188 = v190;
                  v188 += 3;
                }
                while ( v189 > 1 );
              }
              ++v173;
            }
            while ( v173 != 3 );
            v53 = !v175;
            v161 = v331;
            if ( !v53 )
            {
              v191 = v331[60];
              if ( v191 <= 7 )
              {
                v192 = bandInfo[sampling_frequency].longIdx[v191];
                do
                {
                  v193 = v191;
                  v194 = scf[v191 + 39];
                  v195 = bandInfo[sampling_frequency].longDiff[v191];
                  if ( v194 == 7 )
                  {
                    v192 += v195;
                  }
                  else if ( v195 )
                  {
                    v196 = v195 + 1;
                    v197 = (*v172)[v194];
                    v198 = &(*v171)[v194];
                    v199 = (double *)&v160[v192];
                    v200 = *v198;
                    do
                    {
                      --v196;
                      ++v192;
                      v201 = v197 * *(v199 - 576);
                      *(v199 - 576) = v200 * *(v199 - 576);
                      *v199++ = v201;
                    }
                    while ( v196 > 1 );
                  }
                  v191 = v193 + 1;
                }
                while ( v193 < 7 );
              }
            }
          }
          else
          {
            v202 = v331[60];
            if ( v202 <= 21 )
            {
              v203 = bandInfo[sampling_frequency].longIdx[v202];
              if ( v202 != 21 )
              {
                do
                {
                  v204 = v202;
                  v205 = scf[v202 + 39];
                  v206 = bandInfo[sampling_frequency].longDiff[v202];
                  if ( v205 == 7 )
                  {
                    v203 += v206;
                  }
                  else if ( v206 )
                  {
                    v207 = v206 + 1;
                    v208 = (*v172)[v205];
                    v209 = &(*v171)[v205];
                    v210 = (double *)&v160[v203];
                    v211 = *v209;
                    do
                    {
                      --v207;
                      ++v203;
                      v212 = v208 * *(v210 - 576);
                      *(v210 - 576) = v211 * *(v210 - 576);
                      *v210++ = v212;
                    }
                    while ( v207 > 1 );
                  }
                  v202 = v204 + 1;
                }
                while ( v204 < 20 );
              }
              if ( v338 != 7 )
              {
                v213 = &(*xr)[v203 + 576];
                v214 = (*v172)[v338];
                v215 = *v293 + 1;
                v216 = (*v171)[v338];
                do
                {
                  --v215;
                  v217 = v214 * *(v213 - 576);
                  *(v213 - 576) = v216 * *(v213 - 576);
                  *v213++ = v217;
                }
                while ( v215 > 1 );
              }
            }
          }
        }
        v154 = v307;
        if ( v294 == 1 )
        {
          v218 = 0;
          v219 = &v333[23 * v307 + 2];
          v220 = v219[13];
          v221 = v219[59];
          if ( v221 <= v220 )
            v218 = 1;
          v161 = v331;
          if ( v221 > v220 )
            v220 = v221;
          v333[46 * v218 + 15 + 23 * v307] = v220;
        }
        if ( v297 == 1 )
        {
          v227 = v161[61];
          v226 = v161 + 61;
          if ( v227 >= 1 )
          {
            v228 = 0;
            do
            {
              v229 = *v160;
              ++v228;
              v230 = v160 - 576;
              ++v160;
              *v230 = v229;
            }
            while ( v228 < 18 * *v226 );
          }
        }
        else if ( v297 == 3 )
        {
          v223 = v161[61];
          v222 = v161 + 61;
          if ( v223 >= 1 )
          {
            v224 = (double *)xr;
            v225 = 0;
            do
            {
              ++v225;
              *v224 = *v224 + v224[576];
              ++v224;
            }
            while ( v225 < 18 * *v222 );
          }
        }
      }
      v231 = 0;
      v232 = &(*xr)[25];
      v233 = xr;
      do
      {
        v234 = &v333[46 * v231 + 23 * v154];
        v235 = v234 + 6;
        if ( v234[6] == 2 )
        {
          if ( v234[7] )
          {
            v236 = 1;
LABEL_148:
            v237 = aa_ca[0];
            v238 = aa_ca[1];
            v239 = aa_ca[2];
            v240 = aa_ca[3];
            v241 = aa_ca[4];
            v242 = aa_ca[5];
            v243 = aa_ca[6];
            v244 = aa_ca[7];
            v245 = aa_cs[0];
            v246 = aa_cs[1];
            v247 = aa_cs[2];
            v248 = aa_cs[3];
            v249 = aa_cs[4];
            v250 = aa_cs[5];
            v251 = aa_cs[6];
            v252 = aa_cs[7];
            v253 = v232;
            do
            {
              v254 = *(v253 - 4);
              v255 = v253 - 7;
              v256 = *(v253 - 5);
              --v236;
              v257 = *(v253 - 6);
              v258 = *(v253 - 7);
              v259 = *(v253 - 8);
              v260 = *(v253 - 9);
              v261 = *(v253 - 10);
              v262 = *(v253 - 11);
              *(v253 - 8) = v259 * v245 - v258 * v237;
              *(v253 - 9) = v260 * v246 - v257 * v238;
              *v255 = v258 * v245 + v259 * v237;
              v255[1] = v257 * v246 + v260 * v238;
              v255[2] = v256 * v247 + v261 * v239;
              *(v253 - 10) = v261 * v247 - v256 * v239;
              *(v253 - 11) = v262 * v248 - v254 * v240;
              *(v253 - 4) = v254 * v248 + v262 * v240;
              v263 = *(v253 - 3);
              v264 = *(v253 - 12);
              *(v253 - 12) = v264 * v249 - v263 * v241;
              *(v253 - 3) = v263 * v249 + v264 * v241;
              v265 = *(v253 - 2);
              v266 = *(v253 - 13);
              *(v253 - 13) = v266 * v250 - v265 * v242;
              *(v253 - 2) = v265 * v250 + v266 * v242;
              v267 = *(v253 - 1);
              v268 = *(v253 - 14);
              *(v253 - 14) = v268 * v251 - v267 * v243;
              *(v253 - 1) = v267 * v251 + v268 * v243;
              v269 = *(v253 - 15);
              v270 = *v253 * v252 + v269 * v244;
              *(v253 - 15) = v269 * v252 - *v253 * v244;
              *v253 = v270;
              v253 += 18;
            }
            while ( v236 );
          }
        }
        else
        {
          v236 = v234[15] - 1;
          if ( v234[15] != 1 )
            goto LABEL_148;
        }
        v271 = &v152->fresh + v231;
        v272 = &v333[46 * v231 + 23 * v154];
        v273 = v271[4610];
        v271[4610] = 1 - v273;
        v328 = v233;
        v274 = hybrid_out[v231];
        v275 = (int)v152->hybrid_block[v273][v231];
        v276 = v234[7];
        v311 = v231;
        v313 = v232;
        v277 = (int)v152->hybrid_block[1 - v273][v231];
        if ( v276 )
        {
          j_INT123_dct36(xr[32 * v231], (double *)v275, v152->hybrid_block[1 - v273][v231], win[0], (double *)v274);
          j_INT123_dct36(xr[32 * v231 + 1], (double *)(v275 + 144), (double *)(v277 + 144), win1[0], &(*v274)[1]);
          v274 = (double (*)[32])((char *)v274 + 16);
          v277 += 288;
          v275 += 288;
          v278 = 2;
        }
        else
        {
          v278 = 0;
        }
        v281 = v272[15];
        v280 = v272 + 15;
        v279 = v281;
        if ( *v235 == 2 )
        {
          if ( v278 >= v279 )
            goto LABEL_164;
          v282 = v278;
          do
          {
            v283 = v278;
            dct12(v233[v282], (double *)v275, (double *)v277, win[2], (double *)v274);
            dct12(v233[v282 + 1], (double *)(v275 + 144), (double *)(v277 + 144), win1[2], &(*v274)[1]);
            v233 = v328;
            v278 = v283 + 2;
            v274 = (double (*)[32])((char *)v274 + 16);
            v277 += 288;
            v275 += 288;
            v282 += 2;
          }
          while ( v283 + 2 < *v280 );
          v152 = fr;
          v231 = v311;
          v284 = v313;
          if ( v278 <= 0x1F )
            goto LABEL_165;
        }
        else
        {
          if ( v278 >= v279 )
          {
LABEL_164:
            v284 = v313;
LABEL_165:
            v286 = 32 - v278;
            do
            {
              --v286;
              *(_QWORD *)v274 = *(_QWORD *)v275;
              *(_DWORD *)v277 = 0;
              *(_DWORD *)(v277 + 4) = 0;
              (*v274)[32] = *(double *)(v275 + 8);
              *(_DWORD *)(v277 + 8) = 0;
              *(_DWORD *)(v277 + 12) = 0;
              (*v274)[64] = *(double *)(v275 + 16);
              *(_DWORD *)(v277 + 16) = 0;
              *(_DWORD *)(v277 + 20) = 0;
              (*v274)[96] = *(double *)(v275 + 24);
              *(_DWORD *)(v277 + 24) = 0;
              *(_DWORD *)(v277 + 28) = 0;
              (*v274)[128] = *(double *)(v275 + 32);
              *(_DWORD *)(v277 + 32) = 0;
              *(_DWORD *)(v277 + 36) = 0;
              (*v274)[160] = *(double *)(v275 + 40);
              *(_DWORD *)(v277 + 40) = 0;
              *(_DWORD *)(v277 + 44) = 0;
              (*v274)[192] = *(double *)(v275 + 48);
              *(_DWORD *)(v277 + 48) = 0;
              *(_DWORD *)(v277 + 52) = 0;
              (*v274)[224] = *(double *)(v275 + 56);
              *(_DWORD *)(v277 + 56) = 0;
              *(_DWORD *)(v277 + 60) = 0;
              (*v274)[256] = *(double *)(v275 + 64);
              *(_DWORD *)(v277 + 64) = 0;
              *(_DWORD *)(v277 + 68) = 0;
              (*v274)[288] = *(double *)(v275 + 72);
              *(_DWORD *)(v277 + 72) = 0;
              *(_DWORD *)(v277 + 76) = 0;
              (*v274)[320] = *(double *)(v275 + 80);
              *(_DWORD *)(v277 + 80) = 0;
              *(_DWORD *)(v277 + 84) = 0;
              (*v274)[352] = *(double *)(v275 + 88);
              *(_DWORD *)(v277 + 88) = 0;
              *(_DWORD *)(v277 + 92) = 0;
              (*v274)[384] = *(double *)(v275 + 96);
              *(_DWORD *)(v277 + 96) = 0;
              *(_DWORD *)(v277 + 100) = 0;
              (*v274)[416] = *(double *)(v275 + 104);
              *(_DWORD *)(v277 + 104) = 0;
              *(_DWORD *)(v277 + 108) = 0;
              (*v274)[448] = *(double *)(v275 + 112);
              *(_DWORD *)(v277 + 112) = 0;
              *(_DWORD *)(v277 + 116) = 0;
              (*v274)[480] = *(double *)(v275 + 120);
              *(_DWORD *)(v277 + 120) = 0;
              *(_DWORD *)(v277 + 124) = 0;
              (*v274)[512] = *(double *)(v275 + 128);
              v287 = &(*v274)[544];
              *(_DWORD *)(v277 + 128) = 0;
              *(_DWORD *)(v277 + 132) = 0;
              v274 = (double (*)[32])((char *)v274 + 8);
              v288 = *(_QWORD *)(v275 + 136);
              v275 += 144;
              *v287 = v288;
              *(_DWORD *)(v277 + 136) = 0;
              *(_DWORD *)(v277 + 140) = 0;
              v277 += 144;
            }
            while ( v286 );
            goto LABEL_167;
          }
          v285 = 0;
          v325 = v233[v278];
          v322 = win1[*v235];
          wintaba = win[*v235];
          do
          {
            v332 = v278;
            j_INT123_dct36(&v325[v285 / 8], (double *)(v275 + v285), (double *)(v277 + v285), wintaba, (double *)v274);
            j_INT123_dct36(
              &v325[v285 / 8 + 18],
              (double *)(v275 + v285 + 144),
              (double *)(v277 + v285 + 144),
              v322,
              &(*v274)[1]);
            v274 = (double (*)[32])((char *)v274 + 16);
            v285 += 288;
            v278 = v332 + 2;
          }
          while ( v332 + 2 < *v280 );
          v275 += v285;
          v277 += v285;
          v152 = fr;
          v231 = v311;
          v284 = v313;
          if ( v278 <= 0x1F )
            goto LABEL_165;
        }
LABEL_167:
        ++v231;
        v233 += 32;
        v154 = v307;
        v232 = v284 + 576;
      }
      while ( v231 < v306 );
      for ( i = 0; i != 18; ++i )
      {
        if ( v297 == -1 )
          v290 = fr->synth_stereo((*hybrid_out)[i], (*hybrid_out)[i + 18], v152);
        else
          v290 = fr->synth_mono((*hybrid_out)[i], v152);
        v315 += v290;
      }
      v154 = v307 + 1;
      if ( v307 + 1 >= v296 )
        return v315;
    }
  }
  v48 = v308;
  p_uctmp = &fr->uctmp;
  p_flags = &fr->p.flags;
  v321 = (double *)&III_get_side_info_tabs[(_DWORD)v320 + 4];
  v50 = &v334;
  v51 = 0;
  while ( 1 )
  {
    v312 = v51;
    v314 = v50;
    if ( v302 >= 1 )
      break;
LABEL_70:
    v50 = v314 + 23;
    v51 = v312 + 1;
    if ( v312 + 1 >= *v310 )
    {
      v11 = v333[0];
      ssize = fr->ssize;
      goto LABEL_72;
    }
  }
  v52 = 0;
  while ( 1 )
  {
    v330 = v52;
    v58 = &v40[(v41 + 12) >> 3];
    v59 = v40[2];
    v60 = v40[1] | (*v40 << 8);
    *p_wordpointer = v58;
    v61 = (v41 + 12) & 7;
    *p_bitindex = v61;
    *(v50 - 13) = ((v59 | (unsigned int)(v60 << 8)) << v41 >> 12) & 0xFFF;
    v62 = v58[1];
    v63 = *v58;
    v64 = v58[2];
    v65 = &v58[(unsigned int)(v61 + 9) >> 3];
    *p_wordpointer = v65;
    v66 = (v61 + 9) & 7;
    *p_bitindex = v66;
    v67 = ((v64 | ((v62 | (unsigned int)(v63 << 8)) << 8)) << v61 >> 15) & 0x1FF;
    *(v50 - 12) = v67;
    if ( v67 > 0x120 )
    {
      if ( (*(_BYTE *)p_flags & 0x20) == 0 )
      {
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: big_values too large!\n",
          463);
        v48 = v308;
        v66 = *p_bitindex;
        v65 = *p_wordpointer;
      }
      *(v50 - 12) = 288;
    }
    v57 = &fr->uctmp;
    v68 = (unsigned __int8)(*v65 << v66);
    *p_ultmp = v68;
    v69 = v66 + 8;
    v70 = ((v65[1] << v66) | (v68 << 8)) >> 8;
    *p_ultmp = v70;
    v71 = &v65[(v66 + 8) >> 3];
    *p_wordpointer = v71;
    v72 = &fr->gainpow2[v48 + 256 - v70];
    v73 = v69 >> 3;
    if ( v301 )
      v72 += 2;
    v74 = v69 & 7;
    *p_bitindex = v74;
    v50[8] = (int)v72;
    v75 = v71[1] | (v65[v73] << 8);
    v76 = *(_DWORD *)v321 + v74;
    v77 = (((v71[2] | (v75 << 8)) << v74) & 0xFFFFFFu) >> (24 - *(_DWORD *)v321);
    v78 = &v71[v76 >> 3];
    *p_wordpointer = v78;
    *p_bitindex = v76 & 7;
    *(v50 - 11) = v77;
    v79 = *v78 << (v76 & 7);
    v80 = (v76 & 7) + 1;
    *p_uctmp = v79;
    v81 = v80 & 7;
    v82 = &v78[v80 >> 3];
    *p_wordpointer = v82;
    *p_bitindex = v81;
    v83 = (unsigned __int8)(*v82 << (v80 & 7));
    *p_ultmp = v83;
    v84 = v83 | ((unsigned int)(v82[1] << (v80 & 7)) >> 8);
    if ( (v79 & 0x80u) == 0 )
    {
      v85 = v81 + 5;
      v86 = v84 >> 3;
      *p_ultmp = v84 >> 3;
      v87 = &v82[v85 >> 3];
      *p_wordpointer = v87;
      *p_bitindex = v85 & 7;
      *(v50 - 8) = v86;
      v88 = (unsigned __int8)(*v87 << (v85 & 7));
      *p_ultmp = v88;
      v89 = (v85 & 7) + 5;
      v90 = (v88 | ((unsigned int)(v87[1] << (v85 & 7)) >> 8)) >> 3;
      v91 = &v87[v89 >> 3];
      *p_ultmp = v90;
      *p_wordpointer = v91;
      *p_bitindex = v89 & 7;
      *(v50 - 7) = v90;
      v92 = (unsigned __int8)(*v91 << (v89 & 7));
      *p_ultmp = v92;
      v93 = v92 | ((unsigned int)(v91[1] << (v89 & 7)) >> 8);
      v94 = (v89 & 7) + 5;
      v93 >>= 3;
      v95 = &v91[v94 >> 3];
      *p_ultmp = v93;
      *p_wordpointer = v95;
      *p_bitindex = v94 & 7;
      *(v50 - 6) = v93;
      v96 = (unsigned __int8)(*v95 << (v94 & 7));
      *p_ultmp = v96;
      v97 = v96 | ((unsigned int)(v95[1] << (v94 & 7)) >> 8);
      *p_ultmp = v97 >> 4;
      v98 = (v94 & 7) + 4;
      v99 = &v95[v98 >> 3];
      v100 = v98 >> 3;
      v101 = v98 & 7;
      *p_wordpointer = v99;
      *p_bitindex = v101;
      v102 = (unsigned __int8)(v95[v100] << v101);
      *p_ultmp = v102;
      v103 = v99[1] << v101;
      v101 += 3;
      v104 = v102 | (v103 >> 8);
      *p_ultmp = v104 >> 5;
      v105 = (v97 >> 4) + 1;
      v106 = bandInfo[sampling_frequency].longIdx[v105];
      v107 = &v99[v101 >> 3];
      *p_wordpointer = v107;
      v108 = v101 & 7;
      *p_bitindex = v108;
      *v50 = v106 >> 1;
      v109 = v105 + (v104 >> 5);
      if ( v109 <= 0x15 )
        v110 = bandInfo[sampling_frequency].longIdx[v109 + 1] >> 1;
      else
        v110 = 288;
      v50[1] = v110;
      *(v50 - 10) = 0;
      *(v50 - 9) = 0;
      if ( *p_lsf )
        goto LABEL_69;
      goto LABEL_68;
    }
    v111 = v81 + 2;
    v112 = v84 >> 6;
    *p_ultmp = v112;
    v113 = v111 & 7;
    v114 = &v82[v111 >> 3];
    *p_wordpointer = v114;
    *p_bitindex = v111 & 7;
    *(v50 - 10) = v112;
    v115 = (v111 & 7) + 1;
    v116 = &v114[v115 >> 3];
    v117 = *v114 << v113;
    *p_uctmp = v117;
    *p_wordpointer = v116;
    *p_bitindex = v115 & 7;
    *(v50 - 9) = (v117 >> 7) & 1;
    v118 = (unsigned __int8)(*v116 << (v115 & 7));
    *p_ultmp = v118;
    v119 = v118 | ((unsigned int)(v116[1] << (v115 & 7)) >> 8);
    v120 = (v115 & 7) + 5;
    v119 >>= 3;
    v121 = &v116[v120 >> 3];
    *p_ultmp = v119;
    *p_wordpointer = v121;
    *p_bitindex = v120 & 7;
    *(v50 - 8) = v119;
    v122 = (unsigned __int8)(*v121 << (v120 & 7));
    *p_ultmp = v122;
    v123 = v122 | ((unsigned int)(v121[1] << (v120 & 7)) >> 8);
    v124 = (v120 & 7) + 5;
    v123 >>= 3;
    v125 = &v121[v124 >> 3];
    *p_ultmp = v123;
    *p_wordpointer = v125;
    *p_bitindex = v124 & 7;
    *(v50 - 7) = v123;
    *(v50 - 6) = 0;
    v126 = (unsigned __int8)(*v125 << (v124 & 7));
    *p_ultmp = v126;
    v127 = v126 | ((unsigned int)(v125[1] << (v124 & 7)) >> 8);
    v128 = (v124 & 7) + 3;
    v127 >>= 5;
    v129 = &v125[v128 >> 3];
    *p_ultmp = v127;
    *p_wordpointer = v129;
    *p_bitindex = v128 & 7;
    v50[5] = (int)&v72[8 * v127];
    v130 = (unsigned __int8)(*v129 << (v128 & 7));
    *p_ultmp = v130;
    v131 = (v130 | ((unsigned int)(v129[1] << (v128 & 7)) >> 8)) >> 5;
    *p_ultmp = v131;
    v132 = &v72[8 * v131];
    v133 = (v128 & 7) + 3;
    v134 = &v129[v133 >> 3];
    *p_wordpointer = v134;
    *p_bitindex = v133 & 7;
    v50[6] = (int)v132;
    v135 = v50[8];
    v136 = (unsigned __int8)(*v134 << (v133 & 7));
    *p_ultmp = v136;
    v137 = v136 | ((unsigned int)(v134[1] << (v133 & 7)) >> 8);
    v138 = (v133 & 7) + 3;
    v139 = v137 >> 5;
    v107 = &v134[v138 >> 3];
    *p_ultmp = v139;
    v108 = v138 & 7;
    *p_wordpointer = v107;
    *p_bitindex = v108;
    v140 = *(v50 - 10);
    v50[7] = v135 + (v139 << 6);
    if ( !v140 )
      break;
    v141 = v140 == 2;
    mpeg25 = fr->mpeg25;
    v143 = *p_lsf;
    if ( v140 != 2 )
      v141 = v143 == 0;
    if ( v141 )
    {
      if ( mpeg25 )
      {
LABEL_40:
        v53 = v140 == 2;
        if ( v140 == 2 )
          v53 = *(v50 - 9) == 0;
        if ( v53 )
          v54 = 6;
        else
          v54 = 8;
        v56 = bandInfo[sampling_frequency].longIdx[22] >> 1;
        *v50 = bandInfo[sampling_frequency].longIdx[v54] >> 1;
        v50[1] = v56;
        v57 = &fr->uctmp;
        if ( v143 )
          goto LABEL_69;
LABEL_68:
        v144 = *v107 << v108;
        v145 = v108 + 1;
        *v57 = v144;
        v107 += v145 >> 3;
        v108 = v145 & 7;
        *p_wordpointer = v107;
        *p_bitindex = v108;
        v50[2] = (v144 >> 7) & 1;
        goto LABEL_69;
      }
      v55 = 18;
    }
    else
    {
      if ( mpeg25 )
        goto LABEL_40;
      v55 = 27;
    }
    *v50 = v55;
    v50[1] = 288;
    if ( !v143 )
      goto LABEL_68;
LABEL_69:
    v146 = *v107 << v108;
    v147 = v108 + 1;
    *v57 = v146;
    v148 = v147 & 7;
    v149 = &v107[v147 >> 3];
    *p_wordpointer = v149;
    *p_bitindex = v147 & 7;
    v50[3] = (v146 >> 7) & 1;
    v150 = (v147 & 7) + 1;
    v151 = *v149 << v148;
    v40 = &v149[v150 >> 3];
    *v57 = v151;
    v41 = v150 & 7;
    *p_wordpointer = v40;
    *p_bitindex = v41;
    v50[4] = (v151 >> 7) & 1;
    v50 += 46;
    v52 = v330 + 1;
    if ( v330 + 1 >= v302 )
      goto LABEL_70;
  }
  if ( (*p_flags & 0x20) == 0 )
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: Blocktype == 0 and window-switching"
      " == 1 not allowed.\n",
      488);
    if ( (*p_flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: bad frame - unable to get valid sideinfo\n",
        1975);
  }
  return 0;
}
// 22C7B6: variable 'v156' is possibly undefined
// 22C7B6: variable 'sfreq' is possibly undefined
// 22C7FC: variable 'v158' is possibly undefined
// 5F23E8: using guessed type _DWORD III_get_side_info_tabs[10];
// 660E2C: using guessed type double (*off_660E2C[4])[16];
// 22BE68: using guessed type int scf[39];

//----- (0022D1E8) --------------------------------------------------------
int __fastcall III_get_scale_factors_2(mpg123_handle *fr, int *scf, gr_info_s *gr_info, int i_stereo)
{
  __int64 v5; // kr00_8
  unsigned int *v6; // r5
  unsigned int v7; // r12
  int v8; // r3
  unsigned int *p_ultmp; // r11
  int *p_bitindex; // r10
  unsigned __int8 **p_wordpointer; // r8
  int v12; // lr
  char v13; // r0
  int v14; // r0
  signed int v15; // r9
  signed int v16; // r1
  unsigned __int8 *v17; // r2
  int v18; // r3
  unsigned int v19; // r6
  unsigned int v20; // r5
  int v21; // r3
  unsigned int v22; // r6
  int v23; // r0
  int v24; // r6
  unsigned int v25; // r5
  signed int v26; // r0
  int v28; // [sp+8h] [bp-28h]
  int v29; // [sp+Ch] [bp-24h]
  int v30; // [sp+10h] [bp-20h]

  v5 = *(_QWORD *)&gr_info->scalefac_compress;
  v6 = (unsigned int *)((char *)i_slen2 + ((2 * v5) & 0xFFFFFFFC));
  if ( !i_stereo )
    v6 = &n_slen2[v5];
  v7 = *v6;
  gr_info->preflag = (*v6 >> 15) & 1;
  if ( HIDWORD(v5) == 2 )
  {
    v8 = 2;
    if ( !gr_info->mixed_block_flag )
      v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  p_ultmp = &fr->ultmp;
  p_bitindex = &fr->bitindex;
  p_wordpointer = &fr->wordpointer;
  v29 = (v7 >> 12) & 7;
  v12 = 0;
  v30 = 0;
  v28 = v8;
  do
  {
    v13 = v7;
    v7 >>= 3;
    v14 = v13 & 7;
    v15 = III_get_scale_factors_2_stab[v8][v29][v12];
    if ( v14 )
    {
      if ( III_get_scale_factors_2_stab[v8][v29][v12] )
      {
        v16 = 0;
        do
        {
          v17 = *p_wordpointer;
          ++v16;
          v18 = *p_bitindex;
          v19 = (unsigned __int8)(**p_wordpointer << *p_bitindex);
          *p_ultmp = v19;
          v20 = v17[1] << v18;
          v21 = v18 + v14;
          v22 = (v19 | (v20 >> 8)) << v14 >> 8;
          *p_ultmp = v22;
          *p_wordpointer = &v17[v21 >> 3];
          *p_bitindex = v21 & 7;
          *scf++ = v22;
        }
        while ( v16 < v15 );
      }
      v8 = v28;
      v30 += (__int16)v14 * (__int16)v15;
    }
    else if ( III_get_scale_factors_2_stab[v8][v29][v12] )
    {
      v23 = III_get_scale_factors_2_stab[v8][v29][v12];
      if ( (unsigned int)v15 <= 1 )
        v23 = 1;
      v24 = v8;
      v25 = v7;
      memset(scf, 0, 4 * v23);
      v26 = 0;
      do
      {
        ++v26;
        ++scf;
      }
      while ( v26 < v15 );
      v7 = v25;
      v8 = v24;
    }
    ++v12;
  }
  while ( v12 != 4 );
  memset(scf, 0, (8 * v8) | 4);
  return v30;
}

//----- (0022D334) --------------------------------------------------------
int __fastcall III_get_scale_factors_1(mpg123_handle *fr, int *scf, gr_info_s *gr_info, int ch, int gr)
{
  __int64 v6; // kr00_8
  int v7; // r8
  unsigned int *v8; // r10
  int *v9; // r11
  unsigned __int8 **v10; // lr
  int result; // r0
  unsigned __int8 *v12; // r12
  int v13; // r6
  unsigned int v14; // r9
  unsigned int v15; // r2
  int v16; // r6
  int v17; // r9
  unsigned __int8 *v18; // r12
  int v19; // r6
  unsigned int v20; // r9
  unsigned int v21; // r2
  int v22; // r6
  unsigned int v23; // r2
  unsigned __int8 *v24; // r12
  int v25; // r6
  unsigned int v26; // r9
  unsigned int v27; // r2
  int v28; // r6
  unsigned int v29; // r2
  unsigned __int8 *v30; // r12
  int v31; // r6
  unsigned int v32; // r9
  unsigned int v33; // r2
  int v34; // r6
  unsigned int v35; // r2
  unsigned __int8 *v36; // r12
  int v37; // r6
  unsigned int v38; // r9
  unsigned int v39; // r2
  int v40; // r6
  unsigned int v41; // r2
  unsigned __int8 *v42; // r12
  int v43; // r6
  unsigned int v44; // r9
  unsigned int v45; // r2
  int v46; // r6
  unsigned int v47; // r2
  unsigned __int8 *v48; // r12
  int v49; // r6
  unsigned int v50; // r9
  unsigned int v51; // r2
  int v52; // r6
  unsigned int v53; // r2
  unsigned __int8 *v54; // r12
  int v55; // r6
  unsigned int v56; // r9
  unsigned int v57; // r2
  int v58; // r6
  unsigned int v59; // r9
  unsigned __int8 *v60; // r2
  int v61; // r12
  int scfsi; // lr
  unsigned __int8 *wordpointer; // r6
  int bitindex; // r5
  unsigned int v65; // r2
  int v66; // r3
  unsigned int v67; // r0
  unsigned __int8 *v68; // r0
  int v69; // r2
  unsigned int v70; // r3
  int v71; // r5
  int v72; // r0
  unsigned __int8 *v73; // r0
  int v74; // r2
  unsigned int v75; // r3
  int v76; // r5
  int v77; // r0
  unsigned __int8 *v78; // r0
  int v79; // r2
  unsigned int v80; // r3
  int v81; // r5
  int v82; // r0
  unsigned __int8 *v83; // r0
  int v84; // r2
  unsigned int v85; // r3
  int v86; // r5
  int v87; // r0
  unsigned __int8 *v88; // r0
  int v89; // r2
  unsigned int v90; // r3
  int v91; // r5
  int v92; // r0
  int *v93; // r2
  int v94; // r6
  unsigned __int8 *v95; // r4
  int v96; // r5
  unsigned int v97; // r9
  unsigned int v98; // r3
  int v99; // r5
  unsigned int v100; // r3
  int *v101; // r8
  int k; // r6
  unsigned __int8 *v103; // r3
  int v104; // r5
  unsigned int v105; // r4
  unsigned int v106; // r2
  int *v107; // r1
  int v108; // r10
  unsigned int *p_ultmp; // lr
  int *p_bitindex; // r9
  unsigned __int8 **p_wordpointer; // r3
  int i; // r5
  unsigned __int8 *v113; // r6
  int v114; // r4
  unsigned int v115; // r0
  unsigned int v116; // r0
  int j; // r6
  unsigned __int8 *v118; // r0
  int v119; // r2
  unsigned int v120; // r4
  unsigned int v121; // r5
  int v122; // r2
  unsigned int v123; // r4
  unsigned __int8 *v124; // r2
  int v125; // r6
  unsigned int v126; // r3
  int v127; // r5
  int v128; // r2
  unsigned __int8 *v129; // r2
  int v130; // r3
  unsigned int v131; // r6
  int v132; // lr
  int v133; // r2
  unsigned __int8 *v134; // r2
  int v135; // r3
  unsigned int v136; // r6
  int v137; // lr
  int v138; // r2
  unsigned __int8 *v139; // r2
  int v140; // r3
  unsigned int v141; // r6
  int v142; // lr
  int v143; // r2
  unsigned __int8 *v144; // r2
  int v145; // r3
  unsigned int v146; // r6
  int v147; // lr
  int v148; // r2
  unsigned int v149; // r2
  unsigned __int8 *v150; // r2
  int v151; // r6
  unsigned int v152; // r3
  int v153; // r11
  int v154; // r10
  int v155; // r2
  unsigned __int8 *v156; // r2
  int v157; // r3
  unsigned int v158; // r4
  int v159; // r10
  int v160; // r2
  unsigned __int8 *v161; // r2
  int v162; // r3
  unsigned int v163; // r4
  int v164; // r10
  int v165; // r2
  unsigned __int8 *v166; // r2
  int v167; // r3
  unsigned int v168; // r4
  int v169; // r10
  int v170; // r2
  unsigned __int8 *v171; // r2
  int v172; // r3
  unsigned int v173; // r4
  int v174; // r10
  int v175; // r2
  unsigned __int8 *v176; // r6
  int v177; // r5
  unsigned int v178; // r2
  int v179; // r10
  int v180; // r2
  unsigned __int8 *v181; // r2
  int v182; // r3
  unsigned int v183; // r4
  int v184; // r10
  int v185; // r2
  unsigned __int8 *v186; // r2
  int v187; // r3
  unsigned int v188; // r4
  int v189; // r10
  int v190; // r2
  unsigned __int8 *v191; // r2
  int v192; // r3
  unsigned int v193; // r4
  int v194; // r10
  int v195; // r2
  unsigned __int8 *v196; // r2
  int v197; // r3
  unsigned int v198; // r4
  int v199; // r10
  int v200; // r2
  int v201; // [sp+0h] [bp-24h]
  int v202; // [sp+4h] [bp-20h]
  int v203; // [sp+4h] [bp-20h]

  v6 = *(_QWORD *)&gr_info->scalefac_compress;
  v7 = III_get_scale_factors_1_slen[0][v6];
  if ( HIDWORD(v6) != 2 )
  {
    scfsi = gr_info->scfsi;
    if ( gr_info->scfsi <= -1 )
    {
      v108 = III_get_scale_factors_1_slen[1][v6];
      p_ultmp = &fr->ultmp;
      p_bitindex = &fr->bitindex;
      p_wordpointer = &fr->wordpointer;
      for ( i = 0; i != 11; ++i )
      {
        v113 = *p_wordpointer;
        v114 = *p_bitindex;
        v115 = (unsigned __int8)(**p_wordpointer << *p_bitindex);
        *p_ultmp = v115;
        v116 = (v115 | ((unsigned int)(v113[1] << v114) >> 8)) << v7 >> 8;
        *p_ultmp = v116;
        *p_wordpointer = &v113[(v114 + v7) >> 3];
        *p_bitindex = (v114 + v7) & 7;
        scf[i] = v116;
      }
      for ( j = 0; j != 10; ++j )
      {
        v118 = *p_wordpointer;
        v119 = *p_bitindex;
        v120 = (unsigned __int8)(**p_wordpointer << *p_bitindex);
        *p_ultmp = v120;
        v121 = v118[1] << v119;
        v122 = v119 + v108;
        v123 = (v120 | (v121 >> 8)) << v108 >> 8;
        *p_ultmp = v123;
        *p_wordpointer = &v118[v122 >> 3];
        *p_bitindex = v122 & 7;
        scf[j + 11] = v123;
      }
      result = v7 + 10 * (v108 + v7);
      goto LABEL_26;
    }
    v203 = III_get_scale_factors_1_slen[1][v6];
    if ( (scfsi & 8) != 0 )
    {
      result = 0;
    }
    else
    {
      wordpointer = fr->wordpointer;
      bitindex = fr->bitindex;
      v65 = (unsigned __int8)(*wordpointer << bitindex);
      fr->ultmp = v65;
      v66 = wordpointer[1];
      fr->bitindex = (bitindex + v7) & 7;
      fr->wordpointer = &wordpointer[(bitindex + v7) >> 3];
      v67 = (v65 | ((unsigned int)(v66 << bitindex) >> 8)) << v7 >> 8;
      fr->ultmp = v67;
      *scf = v67;
      v68 = fr->wordpointer;
      v69 = fr->bitindex;
      v70 = (unsigned __int8)(*v68 << v69);
      fr->ultmp = v70;
      v71 = v68[1];
      fr->bitindex = (v69 + v7) & 7;
      fr->wordpointer = &v68[(v69 + v7) >> 3];
      v72 = (v70 | ((unsigned int)(v71 << v69) >> 8)) << v7 >> 8;
      fr->ultmp = v72;
      scf[1] = v72;
      v73 = fr->wordpointer;
      v74 = fr->bitindex;
      v75 = (unsigned __int8)(*v73 << v74);
      fr->ultmp = v75;
      v76 = v73[1];
      fr->bitindex = (v74 + v7) & 7;
      fr->wordpointer = &v73[(v74 + v7) >> 3];
      v77 = (v75 | ((unsigned int)(v76 << v74) >> 8)) << v7 >> 8;
      fr->ultmp = v77;
      scf[2] = v77;
      v78 = fr->wordpointer;
      v79 = fr->bitindex;
      v80 = (unsigned __int8)(*v78 << v79);
      fr->ultmp = v80;
      v81 = v78[1];
      fr->bitindex = (v79 + v7) & 7;
      fr->wordpointer = &v78[(v79 + v7) >> 3];
      v82 = (v80 | ((unsigned int)(v81 << v79) >> 8)) << v7 >> 8;
      fr->ultmp = v82;
      scf[3] = v82;
      v83 = fr->wordpointer;
      v84 = fr->bitindex;
      v85 = (unsigned __int8)(*v83 << v84);
      fr->ultmp = v85;
      v86 = v83[1];
      fr->bitindex = (v84 + v7) & 7;
      fr->wordpointer = &v83[(v84 + v7) >> 3];
      v87 = (v85 | ((unsigned int)(v86 << v84) >> 8)) << v7 >> 8;
      fr->ultmp = v87;
      scf[4] = v87;
      v88 = fr->wordpointer;
      v89 = fr->bitindex;
      v90 = (unsigned __int8)(*v88 << v89);
      fr->ultmp = v90;
      v91 = v88[1];
      fr->bitindex = (v89 + v7) & 7;
      fr->wordpointer = &v88[(v89 + v7) >> 3];
      v92 = (v90 | ((unsigned int)(v91 << v89) >> 8)) << v7 >> 8;
      fr->ultmp = v92;
      scf[5] = v92;
      result = 6 * v7;
    }
    v201 = scfsi;
    if ( (scfsi & 4) == 0 )
    {
      v124 = fr->wordpointer;
      v125 = fr->bitindex;
      v126 = (unsigned __int8)(*v124 << v125);
      fr->ultmp = v126;
      v127 = v124[1];
      fr->bitindex = (v125 + v7) & 7;
      fr->wordpointer = &v124[(v125 + v7) >> 3];
      v128 = (v126 | ((unsigned int)(v127 << v125) >> 8)) << v7 >> 8;
      fr->ultmp = v128;
      scf[6] = v128;
      v129 = fr->wordpointer;
      v130 = fr->bitindex;
      v131 = (unsigned __int8)(*v129 << v130);
      fr->ultmp = v131;
      v132 = v129[1];
      fr->bitindex = (v130 + v7) & 7;
      fr->wordpointer = &v129[(v130 + v7) >> 3];
      v133 = (v131 | ((unsigned int)(v132 << v130) >> 8)) << v7 >> 8;
      fr->ultmp = v133;
      scf[7] = v133;
      v134 = fr->wordpointer;
      v135 = fr->bitindex;
      v136 = (unsigned __int8)(*v134 << v135);
      fr->ultmp = v136;
      v137 = v134[1];
      fr->bitindex = (v135 + v7) & 7;
      fr->wordpointer = &v134[(v135 + v7) >> 3];
      v138 = (v136 | ((unsigned int)(v137 << v135) >> 8)) << v7 >> 8;
      fr->ultmp = v138;
      scf[8] = v138;
      v139 = fr->wordpointer;
      v140 = fr->bitindex;
      v141 = (unsigned __int8)(*v139 << v140);
      fr->ultmp = v141;
      v142 = v139[1];
      fr->bitindex = (v140 + v7) & 7;
      fr->wordpointer = &v139[(v140 + v7) >> 3];
      v143 = (v141 | ((unsigned int)(v142 << v140) >> 8)) << v7 >> 8;
      fr->ultmp = v143;
      scf[9] = v143;
      v144 = fr->wordpointer;
      v145 = fr->bitindex;
      v146 = (unsigned __int8)(*v144 << v145);
      fr->ultmp = v146;
      v147 = v144[1];
      fr->bitindex = (v145 + v7) & 7;
      fr->wordpointer = &v144[(v145 + v7) >> 3];
      v148 = v146 | ((unsigned int)(v147 << v145) >> 8);
      scfsi = v201;
      v149 = (unsigned int)(v148 << v7) >> 8;
      fr->ultmp = v149;
      scf[10] = v149;
      result += 5 * v7;
    }
    if ( (scfsi & 2) != 0 )
    {
      v153 = v203;
      if ( scfsi << 31 )
      {
LABEL_26:
        v107 = scf + 21;
        goto LABEL_27;
      }
    }
    else
    {
      v150 = fr->wordpointer;
      v151 = fr->bitindex;
      v152 = (unsigned __int8)(*v150 << v151);
      fr->ultmp = v152;
      v153 = v203;
      v154 = v150[1];
      fr->bitindex = (v151 + v203) & 7;
      fr->wordpointer = &v150[(v151 + v203) >> 3];
      v155 = (v152 | ((unsigned int)(v154 << v151) >> 8)) << v203 >> 8;
      fr->ultmp = v155;
      scf[11] = v155;
      v156 = fr->wordpointer;
      v157 = fr->bitindex;
      v158 = (unsigned __int8)(*v156 << v157);
      fr->ultmp = v158;
      v159 = v156[1];
      fr->bitindex = (v157 + v203) & 7;
      fr->wordpointer = &v156[(v157 + v203) >> 3];
      v160 = (v158 | ((unsigned int)(v159 << v157) >> 8)) << v203 >> 8;
      fr->ultmp = v160;
      scf[12] = v160;
      v161 = fr->wordpointer;
      v162 = fr->bitindex;
      v163 = (unsigned __int8)(*v161 << v162);
      fr->ultmp = v163;
      v164 = v161[1];
      fr->bitindex = (v162 + v203) & 7;
      fr->wordpointer = &v161[(v162 + v203) >> 3];
      v165 = (v163 | ((unsigned int)(v164 << v162) >> 8)) << v203 >> 8;
      fr->ultmp = v165;
      scf[13] = v165;
      v166 = fr->wordpointer;
      v167 = fr->bitindex;
      v168 = (unsigned __int8)(*v166 << v167);
      fr->ultmp = v168;
      v169 = v166[1];
      fr->bitindex = (v167 + v203) & 7;
      fr->wordpointer = &v166[(v167 + v203) >> 3];
      v170 = (v168 | ((unsigned int)(v169 << v167) >> 8)) << v203 >> 8;
      fr->ultmp = v170;
      scf[14] = v170;
      v171 = fr->wordpointer;
      v172 = fr->bitindex;
      v173 = (unsigned __int8)(*v171 << v172);
      fr->ultmp = v173;
      v174 = v171[1];
      fr->bitindex = (v172 + v203) & 7;
      fr->wordpointer = &v171[(v172 + v203) >> 3];
      v175 = (v173 | ((unsigned int)(v174 << v172) >> 8)) << v203 >> 8;
      fr->ultmp = v175;
      scf[15] = v175;
      result += 5 * v203;
      if ( v201 << 31 )
        goto LABEL_26;
    }
    v176 = fr->wordpointer;
    v177 = fr->bitindex;
    v178 = (unsigned __int8)(*v176 << v177);
    fr->ultmp = v178;
    v179 = v176[1];
    fr->bitindex = (v177 + v153) & 7;
    fr->wordpointer = &v176[(v177 + v153) >> 3];
    v180 = (v178 | ((unsigned int)(v179 << v177) >> 8)) << v153 >> 8;
    fr->ultmp = v180;
    scf[16] = v180;
    v181 = fr->wordpointer;
    v182 = fr->bitindex;
    v183 = (unsigned __int8)(*v181 << v182);
    fr->ultmp = v183;
    v184 = v181[1];
    fr->bitindex = (v182 + v153) & 7;
    fr->wordpointer = &v181[(v182 + v153) >> 3];
    v185 = (v183 | ((unsigned int)(v184 << v182) >> 8)) << v153 >> 8;
    fr->ultmp = v185;
    scf[17] = v185;
    v186 = fr->wordpointer;
    v187 = fr->bitindex;
    v188 = (unsigned __int8)(*v186 << v187);
    fr->ultmp = v188;
    v189 = v186[1];
    fr->bitindex = (v187 + v153) & 7;
    fr->wordpointer = &v186[(v187 + v153) >> 3];
    v190 = (v188 | ((unsigned int)(v189 << v187) >> 8)) << v153 >> 8;
    fr->ultmp = v190;
    scf[18] = v190;
    v191 = fr->wordpointer;
    v192 = fr->bitindex;
    v193 = (unsigned __int8)(*v191 << v192);
    fr->ultmp = v193;
    v194 = v191[1];
    fr->bitindex = (v192 + v153) & 7;
    fr->wordpointer = &v191[(v192 + v153) >> 3];
    v195 = (v193 | ((unsigned int)(v194 << v192) >> 8)) << v153 >> 8;
    fr->ultmp = v195;
    scf[19] = v195;
    v196 = fr->wordpointer;
    v197 = fr->bitindex;
    v198 = (unsigned __int8)(*v196 << v197);
    fr->ultmp = v198;
    v199 = v196[1];
    fr->bitindex = (v197 + v153) & 7;
    fr->wordpointer = &v196[(v197 + v153) >> 3];
    v200 = (v198 | ((unsigned int)(v199 << v197) >> 8)) << v153 >> 8;
    fr->ultmp = v200;
    scf[20] = v200;
    result += 5 * v153;
    goto LABEL_26;
  }
  v8 = &fr->ultmp;
  v9 = &fr->bitindex;
  v10 = &fr->wordpointer;
  v202 = III_get_scale_factors_1_slen[1][v6];
  result = 18 * (v202 + v7);
  if ( gr_info->mixed_block_flag )
  {
    v12 = *v10;
    result -= v7;
    v13 = *v9;
    v14 = (unsigned __int8)(**v10 << *v9);
    *v8 = v14;
    v15 = v12[1] << v13;
    v16 = v13 + v7;
    v17 = (v14 | (v15 >> 8)) << v7 >> 8;
    *v8 = v17;
    *v10 = &v12[v16 >> 3];
    *v9 = v16 & 7;
    *scf = v17;
    v18 = *v10;
    v19 = *v9;
    v20 = (unsigned __int8)(**v10 << *v9);
    *v8 = v20;
    v21 = v18[1] << v19;
    v22 = v19 + v7;
    v23 = (v20 | (v21 >> 8)) << v7 >> 8;
    *v8 = v23;
    *v10 = &v18[v22 >> 3];
    *v9 = v22 & 7;
    scf[1] = v23;
    v24 = *v10;
    v25 = *v9;
    v26 = (unsigned __int8)(**v10 << *v9);
    *v8 = v26;
    v27 = v24[1] << v25;
    v28 = v25 + v7;
    v29 = (v26 | (v27 >> 8)) << v7 >> 8;
    *v8 = v29;
    *v10 = &v24[v28 >> 3];
    *v9 = v28 & 7;
    scf[2] = v29;
    v30 = *v10;
    v31 = *v9;
    v32 = (unsigned __int8)(**v10 << *v9);
    *v8 = v32;
    v33 = v30[1] << v31;
    v34 = v31 + v7;
    v35 = (v32 | (v33 >> 8)) << v7 >> 8;
    *v8 = v35;
    *v10 = &v30[v34 >> 3];
    *v9 = v34 & 7;
    scf[3] = v35;
    v36 = *v10;
    v37 = *v9;
    v38 = (unsigned __int8)(**v10 << *v9);
    *v8 = v38;
    v39 = v36[1] << v37;
    v40 = v37 + v7;
    v41 = (v38 | (v39 >> 8)) << v7 >> 8;
    *v8 = v41;
    *v10 = &v36[v40 >> 3];
    *v9 = v40 & 7;
    scf[4] = v41;
    v42 = *v10;
    v43 = *v9;
    v44 = (unsigned __int8)(**v10 << *v9);
    *v8 = v44;
    v45 = v42[1] << v43;
    v46 = v43 + v7;
    v47 = (v44 | (v45 >> 8)) << v7 >> 8;
    *v8 = v47;
    *v10 = &v42[v46 >> 3];
    *v9 = v46 & 7;
    scf[5] = v47;
    v48 = *v10;
    v49 = *v9;
    v50 = (unsigned __int8)(**v10 << *v9);
    *v8 = v50;
    v51 = v48[1] << v49;
    v52 = v49 + v7;
    v53 = (v50 | (v51 >> 8)) << v7 >> 8;
    *v8 = v53;
    *v10 = &v48[v52 >> 3];
    *v9 = v52 & 7;
    scf[6] = v53;
    v54 = *v10;
    v55 = *v9;
    v56 = (unsigned __int8)(**v10 << *v9);
    *v8 = v56;
    v57 = v54[1] << v55;
    v58 = v55 + v7;
    v59 = (v56 | (v57 >> 8)) << v7 >> 8;
    v60 = &v54[v58 >> 3];
    *v8 = v59;
    v61 = 9;
    *v10 = v60;
    *v9 = v58 & 7;
    scf[7] = v59;
    scf += 8;
  }
  else
  {
    v61 = 18;
  }
  v93 = scf;
  v94 = v61;
  do
  {
    v95 = *v10;
    --v94;
    v96 = *v9;
    v97 = (unsigned __int8)(**v10 << *v9);
    *v8 = v97;
    v98 = v95[1] << v96;
    v99 = v96 + v7;
    v100 = (v97 | (v98 >> 8)) << v7 >> 8;
    *v8 = v100;
    *v10 = &v95[v99 >> 3];
    *v9 = v99 & 7;
    *v93++ = v100;
  }
  while ( v94 );
  v101 = &scf[v61];
  for ( k = 0; k != 18; ++k )
  {
    v103 = *v10;
    v104 = *v9;
    v105 = (unsigned __int8)(**v10 << *v9);
    *v8 = v105;
    v106 = (v105 | ((unsigned int)(v103[1] << v104) >> 8)) << v202 >> 8;
    *v8 = v106;
    *v10 = &v103[(v104 + v202) >> 3];
    *v9 = (v104 + v202) & 7;
    v101[k] = v106;
  }
  v107 = v101 + 20;
  v101[18] = 0;
  v101[19] = 0;
LABEL_27:
  *v107 = 0;
  return result;
}

//----- (0022DC88) --------------------------------------------------------
bool __fastcall III_dequantize_sample(
        mpg123_handle *fr,
        double (*xr)[18],
        int *scf,
        gr_info_s *gr_info,
        int sfreq,
        int part2bits)
{
  int bitindex; // r4
  unsigned __int8 *wordpointer; // r3
  unsigned int v9; // r11
  unsigned int part2_3_length; // r8
  int v11; // r9
  int v12; // r5
  int v13; // r1
  signed int region1start; // r3
  unsigned int v15; // r8
  int v16; // r2
  unsigned __int8 **p_wordpointer; // r5
  signed int big_values; // lr
  signed int v19; // r9
  signed int region2start; // r2
  int v21; // r1
  int v22; // r2
  unsigned int mixed_block_flag; // r6
  double v24; // d8
  int v25; // r3
  _BOOL4 v26; // r3
  int *v27; // r10
  double (*v28)[18]; // r6
  gr_info_s *v29; // r2
  double (*v30)[18]; // r3
  int v31; // r12
  unsigned int v32; // r10
  unsigned int v33; // r6
  int v34; // r2
  unsigned int v35; // r1
  int v36; // r12
  int v37; // r12
  double v38; // d16
  int v39; // t1
  int v40; // r6
  bool v41; // zf
  int v42; // r1
  int *v43; // r3
  double **v44; // r6
  int v45; // r0
  double *v46; // r3
  int v47; // r8
  unsigned int v48; // r1
  unsigned int v49; // r6
  int v50; // r2
  unsigned int v51; // r4
  int v52; // r0
  unsigned int v53; // r0
  unsigned int v54; // r1
  int v55; // r12
  __int16 *v56; // r1
  int v57; // r1
  bool v58; // nf
  double v59; // d16
  unsigned int v60; // r1
  unsigned int v61; // r3
  unsigned int v62; // r10
  unsigned int v63; // r4
  int v64; // r2
  int v65; // r0
  double *v66; // r3
  double v67; // d16
  int v68; // r8
  gr_info_s *v69; // lr
  __int16 *v70; // r1
  double (*v71)[18]; // r8
  unsigned int v72; // r0
  unsigned int v73; // r3
  int v74; // r6
  unsigned int v75; // r4
  int v76; // r2
  unsigned int v77; // r0
  int v78; // r0
  int v79; // t1
  int v80; // r6
  bool v81; // zf
  int v82; // r1
  int *v83; // r3
  double **v84; // r6
  double *v85; // r3
  double *v86; // r1
  int v87; // r3
  int v88; // r0
  int v89; // r1
  double v90; // d17
  double v91; // d17
  int v92; // t1
  int v93; // r6
  bool v94; // zf
  int v95; // r1
  int *v96; // r3
  double **v97; // r6
  double *v98; // r3
  double *v99; // r1
  int v100; // r3
  double v101; // d17
  double (*v102)[18]; // r8
  int v103; // r4
  double v104; // d17
  mpg123_handle *v105; // r8
  int v106; // r1
  int *v107; // r4
  double (*v108)[18]; // r9
  int v109; // r12
  double v110; // d8
  double (*v111)[18]; // r6
  int v112; // r10
  unsigned int v113; // r4
  int v114; // r1
  int v115; // r2
  double (*v116)[18]; // r12
  unsigned int v117; // r1
  unsigned int v118; // r2
  unsigned int v119; // r3
  int v120; // r6
  unsigned int v121; // r4
  int v122; // r0
  int v123; // r12
  __int16 *v124; // r1
  int v125; // r1
  bool v126; // nf
  double v127; // d16
  unsigned int linbits; // r1
  unsigned int v129; // r6
  unsigned int v130; // r2
  unsigned int v131; // r4
  int v132; // r3
  unsigned int v133; // r8
  int v134; // r0
  unsigned int v135; // r2
  unsigned int v136; // r0
  double (*v137)[18]; // r8
  char *v138; // r3
  bool v139; // nf
  double v140; // d16
  unsigned int v141; // r1
  unsigned int v142; // r6
  int v143; // r12
  unsigned int v144; // r4
  int v145; // r0
  int v146; // lr
  __int16 *table; // r1
  double (*v148)[18]; // r8
  unsigned int v149; // r0
  unsigned int v150; // r12
  unsigned int v151; // r3
  int v152; // r6
  unsigned int v153; // r4
  int v154; // r2
  int v155; // r0
  int v156; // r1
  int v157; // r2
  int v158; // r0
  int v159; // r1
  double v160; // d17
  double (*v161)[18]; // r1
  double v162; // d17
  double (*v163)[18]; // r8
  int v164; // r2
  int v165; // r3
  int v166; // r2
  double v167; // d17
  double v168; // d17
  __int64 v170; // kr48_8
  int v171; // t1
  int v172; // r1
  double (*v173)[18]; // lr
  int v174; // r0
  int v175; // r6
  int v176; // r1
  int v177; // r2
  int v178; // r3
  int v179; // r0
  unsigned int *v180; // r1
  unsigned int v181; // r2
  int *p_bitindex; // r4
  int v183; // r6
  int v184; // r0
  int v185; // r0
  int v186; // r0
  int v187; // r0
  int v188; // r1
  int v189; // r3
  unsigned __int8 *v190; // r2
  unsigned int v191; // r0
  int v192; // r1
  bool v193; // zf
  int *v194; // [sp+4h] [bp-8Ch]
  int v195; // [sp+8h] [bp-88h]
  int v196; // [sp+8h] [bp-88h]
  int v198; // [sp+10h] [bp-80h]
  unsigned int v199; // [sp+14h] [bp-7Ch]
  double (*v200)[18]; // [sp+14h] [bp-7Ch]
  double (*v201)[18]; // [sp+14h] [bp-7Ch]
  double (*v202)[18]; // [sp+14h] [bp-7Ch]
  double **p_pow2gain; // [sp+18h] [bp-78h]
  unsigned int v204; // [sp+18h] [bp-78h]
  int *v206; // [sp+20h] [bp-70h]
  int v207; // [sp+20h] [bp-70h]
  char v208; // [sp+24h] [bp-6Ch]
  unsigned int v209; // [sp+28h] [bp-68h]
  int *v210; // [sp+28h] [bp-68h]
  __int16 *v211; // [sp+2Ch] [bp-64h]
  unsigned __int8 *v212; // [sp+2Ch] [bp-64h]
  gr_info_s *v213; // [sp+30h] [bp-60h]
  int *v215; // [sp+34h] [bp-5Ch]
  int *v216; // [sp+34h] [bp-5Ch]
  unsigned int v217; // [sp+38h] [bp-58h]
  unsigned int v218; // [sp+38h] [bp-58h]
  unsigned int v219; // [sp+38h] [bp-58h]
  int v220; // [sp+3Ch] [bp-54h]
  __int16 *v221; // [sp+3Ch] [bp-54h]
  int v222; // [sp+40h] [bp-50h]
  int v223; // [sp+40h] [bp-50h]
  unsigned int v224; // [sp+40h] [bp-50h]
  double (*v225)[18]; // [sp+44h] [bp-4Ch]
  unsigned int scalefac_scale; // [sp+48h] [bp-48h]
  int v227; // [sp+48h] [bp-48h]
  int v228; // [sp+48h] [bp-48h]
  int v229; // [sp+4Ch] [bp-44h]
  int v230; // [sp+50h] [bp-40h]
  int v231; // [sp+54h] [bp-3Ch]
  int v232; // [sp+58h] [bp-38h]
  unsigned int v233; // [sp+5Ch] [bp-34h]
  int v234; // [sp+60h] [bp-30h]
  int v235; // [sp+64h] [bp-2Ch]

  scalefac_scale = gr_info->scalefac_scale;
  bitindex = fr->bitindex;
  wordpointer = fr->wordpointer;
  v9 = -bitindex & 7;
  part2_3_length = gr_info->part2_3_length;
  v11 = *wordpointer;
  v12 = wordpointer[1];
  v13 = wordpointer[2];
  fr->bitindex = (v9 + bitindex) & 7;
  fr->wordpointer = &wordpointer[(int)(v9 + bitindex) >> 3];
  region1start = gr_info->region1start;
  v15 = part2_3_length - part2bits - v9;
  v16 = v12 | (v11 << 8);
  p_wordpointer = &fr->wordpointer;
  big_values = gr_info->big_values;
  v19 = (((v13 | (v16 << 8)) << bitindex) & 0xFFFFFFu) >> (24 - v9) << 24 << (8 - v9);
  v195 = (288 - big_values) >> 1;
  if ( big_values <= region1start )
  {
    v22 = 0;
    v233 = gr_info->big_values;
    v234 = 0;
  }
  else
  {
    region2start = gr_info->region2start;
    v233 = gr_info->region1start;
    if ( big_values <= region2start )
    {
      v234 = big_values - region1start;
      v22 = 0;
    }
    else
    {
      v21 = region2start - region1start;
      v22 = big_values - region2start;
      v234 = v21;
    }
    big_values = region1start;
  }
  v235 = v22;
  v208 = scalefac_scale + 1;
  v213 = gr_info;
  if ( gr_info->block_type != 2 )
  {
    v110 = 0.0;
    v111 = (double (*)[18])&(*xr)[576];
    v210 = map[sfreq][2];
    v30 = xr;
    v228 = 0;
    v212 = pretab_choice[gr_info->preflag];
    v112 = 0;
    v113 = v15;
    v223 = -1;
    v207 = 0;
    v225 = (double (*)[18])&(*xr)[576];
    if ( !big_values )
    {
LABEL_167:
      while ( v207 <= 1 )
      {
        big_values = *(&v233 + ++v207);
        if ( big_values )
          goto LABEL_126;
      }
      v146 = v195;
      if ( !v195 || (int)(v113 + v9) < 1 )
        goto LABEL_221;
      while ( 1 )
      {
        table = htc[v213->count1table_select].table;
        if ( v9 <= 0x17 )
        {
          v148 = v30;
          v149 = 24 - v9;
          v150 = v113 - 8;
          v151 = (23 - v9) & 0xFFFFFFF8;
          v152 = (int)(*p_wordpointer + 1);
          v153 = v9;
          do
          {
            *p_wordpointer = (unsigned __int8 *)v152;
            v153 += 8;
            v154 = *(unsigned __int8 *)(v152++ - 1);
            v19 |= v154 << v149;
            v149 -= 8;
          }
          while ( v153 < 0x18 );
          v111 = (double (*)[18])&(*xr)[576];
          v113 = v150 - v151;
          v9 += v151 + 8;
          v30 = v148;
        }
        v155 = *table;
        if ( v155 <= -1 )
        {
          do
          {
            ++table;
            if ( v19 < 0 )
              table -= v155;
            --v9;
            v155 = *table;
            v19 *= 2;
          }
          while ( v155 < 0 );
        }
        if ( (int)(v9 + v113) <= 0 )
        {
          v9 = -v113;
          v158 = 45;
          v159 = 45;
          goto LABEL_220;
        }
        if ( !v112 )
        {
          v156 = *v212++;
          v157 = *scf++;
          v112 = *v210;
          v228 = v210[1];
          v110 = v213->pow2gain[(v156 + v157) << v208];
          v210 += 2;
        }
        --v112;
        if ( v30 >= v111 )
          goto LABEL_208;
        if ( (v155 & 8) != 0 )
        {
          v58 = v19 < 0;
          v19 *= 2;
          --v9;
          v160 = v110;
          if ( v58 )
            v160 = -v110;
          *(double *)v30 = v160;
          v223 = v228;
        }
        else
        {
          LODWORD((*v30)[0]) = 0;
          HIDWORD((*v30)[0]) = 0;
        }
        v161 = (double (*)[18])((char *)v30 + 8);
        if ( &(*v30)[1] >= (double *)v111 )
        {
LABEL_207:
          v30 = v161;
LABEL_208:
          if ( (fr->p.flags & 0x20) == 0 )
          {
            v202 = v30;
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
              1175,
              v30,
              v111);
            v30 = v202;
          }
          v158 = 1;
          v159 = 1;
LABEL_220:
          if ( v159 == 45 )
          {
LABEL_221:
            v105 = fr;
            v213->maxbandl = v223 + 1;
            v213->maxb = fr->longLimit[sfreq][v223 + 1];
            v108 = xr;
            goto LABEL_246;
          }
          v105 = fr;
          v193 = v158 == 0;
LABEL_262:
          v108 = xr;
          if ( v193 )
            goto LABEL_246;
          return 1;
        }
        if ( (v155 & 4) != 0 )
        {
          if ( (int)(v9 + v113) < 1 )
            goto LABEL_219;
          v58 = v19 < 0;
          v19 *= 2;
          --v9;
          v162 = v110;
          if ( v58 )
            v162 = -v110;
          *(double *)v161 = v162;
          v223 = v228;
        }
        else
        {
          LODWORD((*v161)[0]) = 0;
          HIDWORD((*v30)[1]) = 0;
        }
        v161 = (double (*)[18])((char *)v30 + 16);
        if ( !v112 )
        {
          v163 = v30;
          v164 = *v212++;
          v165 = *scf++;
          v166 = v164 + v165;
          v112 = *v210;
          v228 = v210[1];
          v30 = v163;
          v111 = (double (*)[18])&(*xr)[576];
          v110 = v213->pow2gain[v166 << v208];
          v210 += 2;
        }
        --v112;
        if ( v161 >= v111 )
          goto LABEL_207;
        if ( (v155 & 2) != 0 )
        {
          if ( (int)(v9 + v113) < 1 )
            goto LABEL_219;
          v58 = v19 < 0;
          v19 *= 2;
          --v9;
          v167 = v110;
          if ( v58 )
            v167 = -v110;
          *(double *)v161 = v167;
          v223 = v228;
        }
        else
        {
          LODWORD((*v161)[0]) = 0;
          HIDWORD((*v161)[0]) = 0;
        }
        v161 = (double (*)[18])((char *)v30 + 24);
        if ( &(*v30)[3] >= (double *)v111 )
          goto LABEL_207;
        if ( !(v155 << 31) )
        {
          LODWORD((*v161)[0]) = 0;
          HIDWORD((*v30)[3]) = 0;
LABEL_218:
          v30 = (double (*)[18])((char *)v30 + 32);
          goto LABEL_211;
        }
        if ( (int)(v9 + v113) >= 1 )
        {
          v58 = v19 < 0;
          v19 *= 2;
          --v9;
          v168 = v110;
          if ( v58 )
            v168 = -v110;
          *(double *)v161 = v168;
          v223 = v228;
          goto LABEL_218;
        }
LABEL_219:
        v223 = v228;
        v30 = v161;
LABEL_211:
        if ( !--v146 || (int)(v113 + v9) <= 0 )
          goto LABEL_221;
      }
    }
LABEL_126:
    v219 = v213->table_select[v207];
    v221 = ht[v219].table;
    while ( 1 )
    {
      if ( v112 )
      {
        if ( v9 <= 0x17 )
          goto LABEL_131;
      }
      else
      {
        v114 = *v212++;
        v115 = *scf++;
        v112 = *v210;
        v228 = v210[1];
        v110 = v213->pow2gain[(v114 + v115) << v208];
        v210 += 2;
        if ( v9 <= 0x17 )
        {
LABEL_131:
          v116 = v30;
          v117 = 24 - v9;
          v118 = v113 - 8;
          v119 = (23 - v9) & 0xFFFFFFF8;
          v120 = (int)(*p_wordpointer + 1);
          v121 = v9;
          do
          {
            *p_wordpointer = (unsigned __int8 *)v120;
            v121 += 8;
            v122 = *(unsigned __int8 *)(v120++ - 1);
            v19 |= v122 << v117;
            v117 -= 8;
          }
          while ( v121 < 0x18 );
          v111 = (double (*)[18])&(*xr)[576];
          v113 = v118 - v119;
          v9 += v119 + 8;
          v30 = v116;
        }
      }
      v123 = *v221;
      v124 = v221;
      if ( v123 <= -1 )
      {
        do
        {
          ++v124;
          if ( v19 < 0 )
            v124 -= v123;
          --v9;
          v123 = *v124;
          v19 *= 2;
        }
        while ( v123 < 0 );
      }
      if ( v30 >= v111 )
      {
        if ( (fr->p.flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
            1082);
        return 1;
      }
      v125 = v123 >> 4;
      if ( v123 >> 4 )
      {
        if ( v125 == 15 && v219 >= 0x10 )
        {
          linbits = ht[v219].linbits;
          if ( v9 <= 0x17 )
          {
            v201 = v30;
            v129 = (23 - v9) & 0xFFFFFFF8;
            v130 = 24 - v9;
            v131 = v113 - 8;
            v132 = (int)(*p_wordpointer + 1);
            v133 = v9;
            do
            {
              *p_wordpointer = (unsigned __int8 *)v132;
              v133 += 8;
              v134 = *(unsigned __int8 *)(v132++ - 1);
              v19 |= v134 << v130;
              v130 -= 8;
            }
            while ( v133 < 0x18 );
            v135 = v131 - v129;
            v136 = v9 + v129;
            v111 = (double (*)[18])&(*xr)[576];
            v9 = v136 + 8;
            v30 = v201;
            v113 = v135;
          }
          v9 = v9 - 1 - linbits;
          v127 = ispow[((unsigned int)v19 >> (32 - linbits)) + 15];
          v126 = v19 << linbits < 0;
          v19 = 2 * (v19 << linbits);
        }
        else
        {
          v126 = v19 < 0;
          --v9;
          v19 *= 2;
          v127 = ispow[v125];
        }
        if ( v126 )
          v127 = -v127;
        *(double *)v30 = v110 * v127;
        v223 = v228;
      }
      else
      {
        LODWORD((*v30)[0]) = 0;
        HIDWORD((*v30)[0]) = 0;
      }
      v137 = v30;
      v138 = (char *)&(*v30)[1];
      if ( v138 >= (char *)v111 )
      {
        if ( (fr->p.flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
            1106);
        return 1;
      }
      if ( (v123 & 0xF) != 0 )
      {
        if ( (v123 & 0xF) == 15 && v219 >= 0x10 )
        {
          v141 = ht[v219].linbits;
          if ( v9 <= 0x17 )
          {
            v224 = v113 - 8;
            v142 = 24 - v9;
            v143 = (int)(*p_wordpointer + 1);
            v204 = (23 - v9) & 0xFFFFFFF8;
            v144 = v9;
            do
            {
              *p_wordpointer = (unsigned __int8 *)v143;
              v144 += 8;
              v145 = *(unsigned __int8 *)(v143++ - 1);
              v19 |= v145 << v142;
              v142 -= 8;
            }
            while ( v144 < 0x18 );
            v113 = v224 - v204;
            v111 = (double (*)[18])&(*xr)[576];
            v9 += v204 + 8;
          }
          v9 = v9 - 1 - v141;
          v140 = ispow[((unsigned int)v19 >> (32 - v141)) + 15];
          v139 = v19 << v141 < 0;
          v19 = 2 * (v19 << v141);
        }
        else
        {
          v139 = v19 < 0;
          --v9;
          v19 *= 2;
          v140 = ispow[v123 & 0xF];
        }
        if ( v139 )
          v140 = -v140;
        *(double *)v138 = v110 * v140;
        v223 = v228;
      }
      else
      {
        *(_DWORD *)v138 = 0;
        *((_DWORD *)v138 + 1) = 0;
      }
      --v112;
      --big_values;
      v30 = (double (*)[18])((char *)v137 + 16);
      if ( !big_values )
        goto LABEL_167;
    }
  }
  v217 = v15;
  mixed_block_flag = gr_info->mixed_block_flag;
  v24 = 0.0;
  v232 = -1;
  v25 = 2;
  if ( !mixed_block_flag )
    v25 = -1;
  v231 = v25;
  v229 = v25;
  v230 = v25;
  v26 = mixed_block_flag == 0;
  v27 = scf;
  v28 = (double (*)[18])&(*xr)[576];
  v206 = map[sfreq][v26];
  p_pow2gain = &gr_info->pow2gain;
  v29 = gr_info;
  v194 = mapend[sfreq][v26];
  v30 = xr;
  v222 = 3;
  v220 = 0;
  v31 = 0;
  v227 = 0;
  v225 = (double (*)[18])&(*xr)[576];
  v198 = 0;
  if ( big_values )
  {
LABEL_13:
    v209 = v29->table_select[v198];
    v211 = ht[v209].table;
    do
    {
      if ( !v31 )
      {
        v39 = *v27++;
        v31 = *v206;
        v40 = v206[2];
        v222 = v40;
        v220 = v206[3];
        v41 = v40 == 3;
        v42 = v39 << v208;
        v43 = &v213->scfsi + v40;
        v44 = p_pow2gain;
        v45 = 3;
        if ( !v41 )
          v44 = (double **)(v43 + 19);
        v46 = *v44;
        v28 = (double (*)[18])&(*xr)[576];
        if ( v41 )
          v45 = 1;
        v227 = v45;
        v24 = v46[v42];
        v30 = (double (*)[18])&(*xr)[v206[1]];
        v206 += 4;
      }
      v47 = v31;
      if ( v9 <= 0x17 )
      {
        v48 = 24 - v9;
        v49 = (23 - v9) & 0xFFFFFFF8;
        v50 = (int)(*p_wordpointer + 1);
        v51 = v9;
        do
        {
          *p_wordpointer = (unsigned __int8 *)v50;
          v51 += 8;
          v52 = *(unsigned __int8 *)(v50++ - 1);
          v19 |= v52 << v48;
          v48 -= 8;
        }
        while ( v51 < 0x18 );
        v53 = v217 - 8 - v49;
        v54 = v9 + v49;
        v28 = (double (*)[18])&(*xr)[576];
        v9 = v54 + 8;
        v217 = v53;
      }
      v55 = *v211;
      v56 = v211;
      if ( v55 <= -1 )
      {
        do
        {
          ++v56;
          if ( v19 < 0 )
            v56 -= v55;
          --v9;
          v55 = *v56;
          v19 *= 2;
        }
        while ( v55 < 0 );
      }
      if ( v30 >= v28 )
      {
        if ( (fr->p.flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
            862);
        return 1;
      }
      v57 = v55 >> 4;
      if ( v55 >> 4 )
      {
        if ( v57 == 15 && v209 >= 0x10 )
        {
          v60 = ht[v209].linbits;
          *(&v229 + v222) = v220;
          if ( v9 <= 0x17 )
          {
            v200 = v30;
            v61 = 24 - v9;
            v216 = v27;
            v62 = v9;
            v63 = (23 - v9) & 0xFFFFFFF8;
            v64 = (int)(*p_wordpointer + 1);
            do
            {
              *p_wordpointer = (unsigned __int8 *)v64;
              v62 += 8;
              v65 = *(unsigned __int8 *)(v64++ - 1);
              v19 |= v65 << v61;
              v61 -= 8;
            }
            while ( v62 < 0x18 );
            v217 = v217 - 8 - v63;
            v28 = (double (*)[18])&(*xr)[576];
            v27 = v216;
            v9 += v63 + 8;
            v30 = v200;
          }
          v9 = v9 - 1 - v60;
          v59 = ispow[((unsigned int)v19 >> (32 - v60)) + 15];
          v58 = v19 << v60 < 0;
          v19 = 2 * (v19 << v60);
        }
        else
        {
          v58 = v19 < 0;
          v19 *= 2;
          *(&v229 + v222) = v220;
          --v9;
          v59 = ispow[v57];
        }
        if ( v58 )
          v59 = -v59;
        *(double *)v30 = v24 * v59;
      }
      else
      {
        LODWORD((*v30)[0]) = 0;
        HIDWORD((*v30)[0]) = 0;
      }
      v66 = &(*v30)[v227];
      if ( v66 >= (double *)v28 )
      {
        if ( (fr->p.flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
            887);
        return 1;
      }
      if ( (v55 & 0xF) != 0 )
      {
        if ( (v55 & 0xF) == 15 && v209 >= 0x10 )
        {
          v215 = v27;
          v32 = ht[v209].linbits;
          *(&v229 + v222) = v220;
          if ( v9 <= 0x17 )
          {
            v33 = 24 - v9;
            v218 = v217 - 8;
            v34 = (int)(*p_wordpointer + 1);
            v35 = v9;
            v199 = (23 - v9) & 0xFFFFFFF8;
            do
            {
              *p_wordpointer = (unsigned __int8 *)v34;
              v35 += 8;
              v36 = *(unsigned __int8 *)(v34++ - 1);
              v19 |= v36 << v33;
              v33 -= 8;
            }
            while ( v35 < 0x18 );
            v28 = (double (*)[18])&(*xr)[576];
            v217 = v218 - v199;
            v9 += v199 + 8;
          }
          v37 = v47;
          v9 = v9 - 1 - v32;
          v38 = ispow[((unsigned int)v19 >> (32 - v32)) + 15];
          v58 = v19 << v32 < 0;
          v19 = 2 * (v19 << v32);
          if ( v58 )
            v38 = -v38;
          *v66 = v24 * v38;
          v27 = v215;
          goto LABEL_58;
        }
        v58 = v19 < 0;
        v19 *= 2;
        *(&v229 + v222) = v220;
        --v9;
        v67 = ispow[v55 & 0xF];
        if ( v58 )
          v67 = -v67;
        *v66 = v24 * v67;
      }
      else
      {
        *(_DWORD *)v66 = 0;
        *((_DWORD *)v66 + 1) = 0;
      }
      v37 = v47;
LABEL_58:
      v31 = v37 - 1;
      --big_values;
      v30 = (double (*)[18])&v66[v227];
    }
    while ( big_values );
  }
  while ( v198 <= 0 )
  {
    big_values = *(&v233 + ++v198);
    v29 = v213;
    if ( big_values )
      goto LABEL_13;
  }
  v68 = v195;
  v69 = v213;
  if ( !v195 || (int)(v217 + v9) < 1 )
    goto LABEL_120;
  while ( 1 )
  {
    v70 = htc[v69->count1table_select].table;
    if ( v9 <= 0x17 )
    {
      v196 = v68;
      v71 = v30;
      v72 = 24 - v9;
      v73 = (23 - v9) & 0xFFFFFFF8;
      v74 = (int)(*p_wordpointer + 1);
      v75 = v9;
      do
      {
        *p_wordpointer = (unsigned __int8 *)v74;
        v75 += 8;
        v76 = *(unsigned __int8 *)(v74++ - 1);
        v19 |= v76 << v72;
        v72 -= 8;
      }
      while ( v75 < 0x18 );
      v217 = v217 - 8 - v73;
      v77 = v9 + v73;
      v30 = v71;
      v28 = (double (*)[18])&(*xr)[576];
      v69 = v213;
      v9 = v77 + 8;
      v68 = v196;
    }
    v78 = *v70;
    if ( v78 <= -1 )
    {
      do
      {
        ++v70;
        if ( v19 < 0 )
          v70 -= v78;
        --v9;
        v78 = *v70;
        v19 *= 2;
      }
      while ( v78 < 0 );
    }
    if ( (int)(v9 + v217) <= 0 )
    {
      v9 = -v217;
      v88 = 16;
      v89 = 16;
      goto LABEL_119;
    }
    if ( !v31 )
    {
      v79 = *v27++;
      v31 = *v206;
      v80 = v206[2];
      v222 = v80;
      v220 = v206[3];
      v81 = v80 == 3;
      v82 = v79 << v208;
      v83 = &v69->scfsi + v80;
      v84 = p_pow2gain;
      if ( !v81 )
        v84 = (double **)(v83 + 19);
      v85 = *v84;
      v28 = (double (*)[18])&(*xr)[576];
      v86 = &v85[v82];
      v87 = 3;
      if ( v81 )
        v87 = 1;
      v227 = v87;
      v24 = *v86;
      v30 = (double (*)[18])&(*xr)[v206[1]];
      v206 += 4;
    }
    --v31;
    if ( v30 >= v28 )
      break;
    if ( (v78 & 8) != 0 )
    {
      v58 = v19 < 0;
      v19 *= 2;
      --v9;
      v90 = v24;
      if ( v58 )
        v90 = -v24;
      *(&v229 + v222) = v220;
      *(double *)v30 = v90;
    }
    else
    {
      LODWORD((*v30)[0]) = 0;
      HIDWORD((*v30)[0]) = 0;
    }
    v30 = (double (*)[18])((char *)v30 + 8 * v227);
    if ( v30 >= v28 )
      break;
    if ( (v78 & 4) != 0 )
    {
      *(&v229 + v222) = v220;
      if ( (int)(v217 + v9) < 1 )
        goto LABEL_110;
      v58 = v19 < 0;
      v19 *= 2;
      --v9;
      v91 = v24;
      if ( v58 )
        v91 = -v24;
      *(double *)v30 = v91;
      if ( v31 )
      {
LABEL_87:
        v30 = (double (*)[18])((char *)v30 + 8 * v227);
        goto LABEL_97;
      }
    }
    else
    {
      LODWORD((*v30)[0]) = 0;
      HIDWORD((*v30)[0]) = 0;
      if ( v31 )
        goto LABEL_87;
    }
    v92 = *v27++;
    v31 = *v206;
    v93 = v206[2];
    v222 = v93;
    v220 = v206[3];
    v94 = v93 == 3;
    v95 = v92 << v208;
    v96 = &v69->scfsi + v93;
    v97 = p_pow2gain;
    if ( !v94 )
      v97 = (double **)(v96 + 19);
    v98 = *v97;
    v28 = (double (*)[18])&(*xr)[576];
    v99 = &v98[v95];
    v100 = 3;
    if ( v94 )
      v100 = 1;
    v227 = v100;
    v24 = *v99;
    v30 = (double (*)[18])&(*xr)[v206[1]];
    v206 += 4;
LABEL_97:
    --v31;
    if ( v30 >= v28 )
      break;
    if ( (v78 & 2) != 0 )
    {
      *(&v229 + v222) = v220;
      if ( (int)(v217 + v9) < 1 )
        goto LABEL_110;
      v58 = v19 < 0;
      v19 *= 2;
      --v9;
      v101 = v24;
      if ( v58 )
        v101 = -v24;
      *(double *)v30 = v101;
    }
    else
    {
      LODWORD((*v30)[0]) = 0;
      HIDWORD((*v30)[0]) = 0;
    }
    v30 = (double (*)[18])((char *)v30 + 8 * v227);
    if ( v30 >= v28 )
      break;
    if ( v78 << 31 )
    {
      *(&v229 + v222) = v220;
      if ( (int)(v217 + v9) < 1 )
        goto LABEL_110;
      v58 = v19 < 0;
      v19 *= 2;
      --v9;
      v104 = v24;
      if ( v58 )
        v104 = -v24;
      *(double *)v30 = v104;
    }
    else
    {
      LODWORD((*v30)[0]) = 0;
      HIDWORD((*v30)[0]) = 0;
    }
    v30 = (double (*)[18])((char *)v30 + 8 * v227);
LABEL_110:
    if ( !--v68 || (int)(v217 + v9) <= 0 )
      goto LABEL_120;
  }
  if ( (fr->p.flags & 0x20) == 0 )
  {
    v102 = v30;
    v103 = v31;
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
      967,
      v30,
      v28);
    v30 = v102;
    v31 = v103;
  }
  v88 = 1;
  v89 = 1;
LABEL_119:
  if ( v89 != 16 )
  {
    v193 = v88 == 0;
    v105 = fr;
    v113 = v217;
    goto LABEL_262;
  }
LABEL_120:
  if ( v222 > 2 )
  {
    v105 = fr;
    v109 = sfreq;
    v108 = xr;
    goto LABEL_239;
  }
  v105 = fr;
  v106 = v31;
  v108 = xr;
  v107 = v206;
  v109 = sfreq;
  if ( v106 >= 1 )
  {
LABEL_233:
    v172 = v106 + 1;
    while ( v30 < v28 )
    {
      LODWORD((*v30)[0]) = 0;
      HIDWORD((*v30)[0]) = 0;
      --v172;
      LODWORD((*v30)[3]) = 0;
      HIDWORD((*v30)[3]) = 0;
      v30 = (double (*)[18])((char *)v30 + 48);
      if ( v172 <= 1 )
        goto LABEL_236;
    }
    if ( (fr->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
        992);
    return 1;
  }
LABEL_236:
  while ( v107 < v194 )
  {
    v170 = *(_QWORD *)(v107 + 1);
    v30 = (double (*)[18])&(*xr)[v170];
    if ( !HIDWORD(v170) )
      break;
    v171 = *v107;
    v107 += 4;
    v106 = v171;
    if ( v171 >= 1 )
      goto LABEL_233;
  }
LABEL_239:
  v173 = v30;
  v174 = v229;
  v175 = 0;
  v213->maxband[0] = v229 + 1;
  v176 = v230;
  v213->maxband[1] = v230 + 1;
  v177 = v231;
  v213->maxband[2] = v231 + 1;
  v178 = v232 + 1;
  v213->maxbandl = v232 + 1;
  if ( v174 <= v176 )
    v175 = 1;
  v179 = (int)v105 + 92 * v109 + 4 * v178;
  v30 = v173;
  if ( *(&v229 + v175) > v177 )
    v177 = *(&v229 + v175);
  v180 = (unsigned int *)&v105->shortLimit[v109][v177 + 1];
  if ( v177 == -1 )
    v180 = (unsigned int *)(v179 + 19072);
  v213->maxb = *v180;
  v113 = v217;
LABEL_246:
  v181 = v113;
  p_bitindex = &v105->bitindex;
  v183 = v181 + v9;
  v184 = v105->bitindex - v9;
  *p_wordpointer += v184 >> 3;
  v105->bitindex = v184 & 7;
  if ( v30 < v225 )
  {
    memset(v30, 0, ((unsigned int)&(*v108)[576] + 7 - (_DWORD)v30) & 0xFFFFFFF8);
    if ( v183 < 17 )
      goto LABEL_248;
LABEL_251:
    v187 = ~v183;
    v188 = *p_bitindex;
    v189 = v183 + 16;
    v190 = *p_wordpointer;
    if ( ~v183 < -33 || v183 == 32 )
      v187 = -33;
    v191 = (v187 + v183 + 16) & 0xFFFFFFF0;
    do
    {
      v192 = v188 + 16;
      v189 -= 16;
      v190 += v192 >> 3;
      v188 = v192 & 7;
    }
    while ( v189 > 32 );
    *p_wordpointer = v190;
    *p_bitindex = v188;
    v105->ultmp = v188;
    v183 = v183 - 16 - v191;
    if ( v183 < 1 )
      return v183 < 0;
LABEL_249:
    v185 = *p_bitindex + v183;
    *p_wordpointer += v185 >> 3;
    v186 = v185 & 7;
    *p_bitindex = v186;
    v105->ultmp = v186;
    return 0;
  }
  if ( v183 >= 17 )
    goto LABEL_251;
LABEL_248:
  if ( v183 >= 1 )
    goto LABEL_249;
  return v183 < 0;
}

//----- (0022EC6C) --------------------------------------------------------
int mpg123_init()
{
  if ( !initialized )
  {
    j_INT123_init_layer12();
    j_INT123_init_layer3();
    j_INT123_prepare_decode_tables();
    initialized = 1;
  }
  return 0;
}
// 6D6158: using guessed type char initialized;

//----- (0022ECA0) --------------------------------------------------------
void INT123_prepare_decode_tables()
{
  int v0; // r5
  double v1; // d8
  double *v2; // r4
  double v3; // d16
  double *v4; // r0
  double *v5; // r1
  double *v6; // r1
  double *v7; // r1
  double *v8; // r0

  v0 = 0;
  v1 = 0.0;
  v2 = INT123_pnts[0];
  do
  {
    v3 = cos((v1 + v1 + 1.0) * 3.14159265 * 0.015625);
    v4 = &v2[v0];
    v1 = v1 + 1.0;
    ++v0;
    *v4 = 1.0 / (v3 + v3);
  }
  while ( v0 != 16 );
  v5 = INT123_pnts[1];
  *(_DWORD *)INT123_pnts[1] = -1671308943;
  *((_DWORD *)v5 + 1) = 1071649745;
  *((_DWORD *)v5 + 2) = 65790302;
  *((_DWORD *)v5 + 3) = 1071691855;
  *((_DWORD *)v5 + 4) = -788112780;
  *((_DWORD *)v5 + 5) = 1071785063;
  *((_DWORD *)v5 + 6) = -1732516922;
  *(int *)((char *)&dword_1C + (_DWORD)v5) = 1071952579;
  *((_DWORD *)v5 + 8) = 192758288;
  *((_DWORD *)v5 + 9) = 1072248976;
  *(_DWORD *)((char *)&word_28 + (_DWORD)v5) = 709807831;
  *(_DWORD *)((char *)&word_2C + (_DWORD)v5) = 1072756873;
  *(_DWORD *)((char *)&word_30 + (_DWORD)v5) = -1337958078;
  *((_DWORD *)v5 + 13) = 1073450788;
  *((_DWORD *)v5 + 14) = -2132461356;
  *(void **)((char *)&off_3C + (_DWORD)v5) = (void *)1075079059;
  v6 = INT123_pnts[2];
  *(_DWORD *)INT123_pnts[2] = -780354989;
  *((_DWORD *)v6 + 1) = 1071665214;
  *((_DWORD *)v6 + 2) = -1579149506;
  *((_DWORD *)v6 + 3) = 1071857207;
  *((_DWORD *)v6 + 4) = -273576617;
  *((_DWORD *)v6 + 5) = 1072483482;
  *((_DWORD *)v6 + 6) = -797723610;
  *((_DWORD *)v6 + 7) = 1074036953;
  v7 = INT123_pnts[3];
  *(_DWORD *)INT123_pnts[3] = 2077964437;
  *((_DWORD *)v7 + 1) = 1071731066;
  *((_DWORD *)v7 + 2) = -1857752837;
  *((_DWORD *)v7 + 3) = 1073014702;
  v8 = INT123_pnts[4];
  *(_DWORD *)INT123_pnts[4] = 1719614412;
  *((_DWORD *)v8 + 1) = 1072079006;
}
// 1C: using guessed type int dword_1C;
// 28: using guessed type __int16 word_28;
// 2C: using guessed type __int16 word_2C;
// 30: using guessed type __int16 word_30;
// 3C: using guessed type void *off_3C;

//----- (0022EE64) --------------------------------------------------------
mpg123_handle *__fastcall mpg123_new(const unsigned __int8 *decoder, int *error)
{
  return mpg123_parnew(0, decoder, error);
}

//----- (0022EE6C) --------------------------------------------------------
mpg123_handle *__fastcall mpg123_parnew(mpg123_pars *mp, const unsigned __int8 *decoder, int *error)
{
  mpg123_handle *v6; // r0
  mpg123_handle *v7; // r5
  void **p_data; // r6
  size_t *p_size; // r4
  int v10; // r0
  void *v11; // r0

  if ( initialized != 1 )
  {
    v10 = 8;
    goto LABEL_9;
  }
  v6 = (mpg123_handle *)malloc(0xB558u);
  v7 = v6;
  if ( !v6 )
  {
    v10 = 0;
LABEL_9:
    v7 = 0;
    if ( !v10 )
      v10 = 7;
    goto LABEL_18;
  }
  j_INT123_frame_init_par(v6, mp);
  j_INT123_frame_cpu_opt(v7, decoder);
  p_data = (void **)&v7->buffer.data;
  if ( v7->own_buffer )
  {
    if ( *p_data )
    {
      p_size = &v7->buffer.size;
      if ( v7->buffer.size == 294912 )
      {
        *p_size = 294912;
LABEL_16:
        v7->own_buffer = 1;
        v7->decoder_change = 1;
        v10 = 0;
        v7->buffer.fill = 0;
        goto LABEL_18;
      }
      free(*p_data);
      *p_data = 0;
      goto LABEL_15;
    }
  }
  else
  {
    *p_data = 0;
  }
  p_size = &v7->buffer.size;
LABEL_15:
  *p_size = 294912;
  v11 = malloc(0x48000u);
  *p_data = v11;
  if ( v11 )
    goto LABEL_16;
  v7->err = 7;
  j_INT123_frame_exit(v7);
  free(v7);
  v10 = 11;
  v7 = 0;
LABEL_18:
  if ( error )
    *error = v10;
  return v7;
}
// 6D6158: using guessed type char initialized;

//----- (0022EF4C) --------------------------------------------------------
int __fastcall INT123_frame_cpu_opt(mpg123_handle *fr, const unsigned __int8 *cpu)
{
  optdec v3; // r6
  int (__fastcall *v5)(double *, int, mpg123_handle *, int); // r2

  v3 = j_INT123_dectype(cpu);
  qmemcpy(&fr->synths, &synth_base, sizeof(fr->synths));
  if ( (unsigned int)v3 < generic_dither || (fr->p.flags & 0x20) != 0 )
  {
    fr->cpu_opts.class = normal;
    fr->cpu_opts.type = generic;
  }
  else
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/optimize.c:%i] error: you wanted decoder type %i, I only have %i\n",
      460,
      v3,
      1);
    v5 = fr->synths.plain[0][0];
    fr->cpu_opts.class = normal;
    fr->cpu_opts.type = generic;
    if ( v5 != INT123_synth_1to1 )
    {
      fr->synths.mono[0][1] = INT123_synth_1to1_8bit_wrap_mono;
      fr->synths.plain[0][1] = INT123_synth_1to1_8bit_wrap;
      fr->synths.mono2stereo[0][1] = INT123_synth_1to1_8bit_wrap_m2s;
    }
  }
  if ( (fr->p.flags & 0x20) == 0 && fr->p.verbose )
    fprintf((FILE *)stderr, "Decoder: %s\n", "generic");
  return 1;
}

//----- (0022F054) --------------------------------------------------------
int __fastcall mpg123_decoder(mpg123_handle *mh, const unsigned __int8 *decoder)
{
  optdec v4; // r0
  int result; // r0
  outbuffer *p_buffer; // r6
  size_t *p_size; // r5
  unsigned __int8 *v8; // r0

  v4 = j_INT123_dectype(decoder);
  if ( !mh )
    return -1;
  if ( v4 == nodec )
  {
    mh->err = 9;
    return -1;
  }
  if ( v4 == mh->cpu_opts.type )
    return 0;
  j_INT123_frame_cpu_opt(mh, decoder);
  p_buffer = &mh->buffer;
  if ( !mh->own_buffer )
  {
    p_buffer->data = 0;
    goto LABEL_12;
  }
  if ( !p_buffer->data )
  {
LABEL_12:
    p_size = &mh->buffer.size;
    goto LABEL_14;
  }
  p_size = &mh->buffer.size;
  if ( mh->buffer.size != 294912 )
  {
    free(p_buffer->data);
    p_buffer->data = 0;
LABEL_14:
    *p_size = 294912;
    v8 = (unsigned __int8 *)malloc(0x48000u);
    p_buffer->data = v8;
    if ( !v8 )
    {
      mh->err = 11;
      j_INT123_frame_exit(mh);
      return -1;
    }
    goto LABEL_15;
  }
  *p_size = 294912;
LABEL_15:
  mh->own_buffer = 1;
  mh->decoder_change = 1;
  result = 0;
  mh->buffer.fill = 0;
  return result;
}

//----- (0022F118) --------------------------------------------------------
optdec __fastcall INT123_dectype(const unsigned __int8 *decoder)
{
  bool v2; // zf
  int v3; // r0
  optdec v4; // r1

  v2 = decoder == 0;
  if ( decoder )
    v2 = *decoder == 0;
  if ( v2 || !strcasecmp((const char *)decoder, "auto") )
    return 0;
  if ( !strcasecmp((const char *)decoder, "generic") )
    return 1;
  if ( !strcasecmp((const char *)decoder, "generic_dither") )
    return 2;
  if ( !strcasecmp((const char *)decoder, "i386") )
    return 3;
  if ( !strcasecmp((const char *)decoder, "i486") )
    return 4;
  if ( !strcasecmp((const char *)decoder, "i586") )
    return 5;
  if ( !strcasecmp((const char *)decoder, "i586_dither") )
    return 6;
  if ( !strcasecmp((const char *)decoder, "MMX") )
    return 7;
  if ( !strcasecmp((const char *)decoder, "3DNow") )
    return 8;
  if ( !strcasecmp((const char *)decoder, "3DNowExt") )
    return 9;
  if ( !strcasecmp((const char *)decoder, "AltiVec") )
    return 10;
  if ( !strcasecmp((const char *)decoder, "SSE") )
    return 11;
  if ( !strcasecmp((const char *)decoder, "x86-64") )
    return 12;
  if ( !strcasecmp((const char *)decoder, "ARM") )
    return 13;
  v3 = strcasecmp((const char *)decoder, "NEON");
  v4 = nodec;
  if ( !v3 )
    return 14;
  return v4;
}

//----- (0022F268) --------------------------------------------------------
int __fastcall mpg123_param(mpg123_handle *mh, mpg123_parms key, int val, int a4, double fval)
{
  int v6; // r0

  if ( !mh )
    return -1;
  v6 = j_mpg123_par(&mh->p, key, val, a4, fval);
  if ( v6 )
  {
    mh->err = v6;
    return -1;
  }
  return 0;
}

//----- (0022F2A0) --------------------------------------------------------
int __fastcall mpg123_par(mpg123_pars *mp, mpg123_parms key, int val, int a4, double fval)
{
  int result; // r0
  int v7; // r0
  double v8; // d17

  if ( !mp )
    return 25;
  result = 35;
  switch ( key )
  {
    case MPG123_VERBOSE:
      result = 0;
      mp->verbose = val;
      break;
    case MPG123_FLAGS:
      if ( (val & 0x40) != 0 )
        goto LABEL_10;
      mp->flags = val;
      result = 0;
      break;
    case MPG123_ADD_FLAGS:
      if ( (val & 0x40) == 0 )
      {
        v7 = mp->flags | val;
        goto LABEL_28;
      }
LABEL_10:
      result = 13;
      break;
    case MPG123_FORCE_RATE:
      if ( val <= (int)&elf_hash_chain[7526] )
      {
        result = 0;
        if ( val <= 0 )
          val = 0;
        mp->force_rate = val;
      }
      else
      {
        result = 3;
      }
      break;
    case MPG123_DOWN_SAMPLE:
      if ( (unsigned int)val > 2 )
      {
        result = 3;
      }
      else
      {
        mp->down_sample = val;
        result = 0;
      }
      break;
    case MPG123_RVA:
      if ( (unsigned int)val <= 2 )
      {
        mp->rva = val;
        result = 0;
      }
      else
      {
        result = 12;
      }
      break;
    case MPG123_DOWNSPEED:
      result = 0;
      if ( val <= 0 )
        val = 0;
      mp->halfspeed = val;
      break;
    case MPG123_UPSPEED:
      result = 0;
      if ( val <= 0 )
        val = 0;
      mp->doublespeed = val;
      break;
    case MPG123_ICY_INTERVAL:
      result = 0;
      if ( val <= 0 )
        val = 0;
      mp->icy_interval = val;
      break;
    case MPG123_OUTSCALE:
      result = 0;
      v8 = (double)val * 0.0000305175781;
      if ( !val )
        v8 = fval;
      mp->outscale = v8;
      break;
    case MPG123_TIMEOUT:
      result = 0;
      if ( val > 0 )
        result = 21;
      break;
    case MPG123_REMOVE_FLAGS:
      v7 = mp->flags & ~val;
LABEL_28:
      mp->flags = v7;
      result = 0;
      break;
    case MPG123_RESYNC_LIMIT:
      result = 0;
      mp->resync_limit = val;
      break;
    case MPG123_INDEX_SIZE:
      return result;
    case MPG123_PREFRAMES:
      if ( val >= 0 )
      {
        mp->preframes = val;
        result = 0;
      }
      else
      {
        result = 39;
      }
      break;
    default:
      result = 5;
      break;
  }
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0022F3B8) --------------------------------------------------------
int __fastcall mpg123_getparam(mpg123_handle *mh, mpg123_parms key, int *val, double *fval)
{
  int v5; // r0

  if ( !mh )
    return -1;
  v5 = j_mpg123_getpar(&mh->p, key, val, fval);
  if ( v5 )
  {
    mh->err = v5;
    return -1;
  }
  return 0;
}

//----- (0022F3E0) --------------------------------------------------------
int __fastcall mpg123_getpar(mpg123_pars *mp, mpg123_parms key, int *val, double *fval)
{
  int result; // r0
  int verbose; // r0

  if ( !mp )
    return 25;
  result = 5;
  switch ( key )
  {
    case MPG123_VERBOSE:
      if ( !val )
        goto LABEL_31;
      verbose = mp->verbose;
      goto LABEL_30;
    case MPG123_FLAGS:
    case MPG123_ADD_FLAGS:
      if ( !val )
        goto LABEL_31;
      verbose = mp->flags;
      goto LABEL_30;
    case MPG123_FORCE_RATE:
      if ( !val )
        goto LABEL_31;
      verbose = mp->force_rate;
      goto LABEL_30;
    case MPG123_DOWN_SAMPLE:
      if ( !val )
        goto LABEL_31;
      verbose = mp->down_sample;
      goto LABEL_30;
    case MPG123_RVA:
      if ( !val )
        goto LABEL_31;
      verbose = mp->rva;
      goto LABEL_30;
    case MPG123_DOWNSPEED:
      if ( !val )
        goto LABEL_31;
      verbose = mp->halfspeed;
      goto LABEL_30;
    case MPG123_UPSPEED:
      if ( !val )
        goto LABEL_31;
      verbose = mp->doublespeed;
      goto LABEL_30;
    case MPG123_START_FRAME:
    case MPG123_DECODE_FRAMES:
    case MPG123_TIMEOUT:
    case MPG123_REMOVE_FLAGS:
      return result;
    case MPG123_ICY_INTERVAL:
      if ( !val )
        goto LABEL_31;
      verbose = mp->icy_interval;
      goto LABEL_30;
    case MPG123_OUTSCALE:
      if ( fval )
        *fval = mp->outscale;
      if ( !val )
        goto LABEL_31;
      *val = (int)(mp->outscale * 32768.0);
      return 0;
    case MPG123_RESYNC_LIMIT:
      if ( !val )
        goto LABEL_31;
      verbose = mp->resync_limit;
LABEL_30:
      *val = verbose;
LABEL_31:
      result = 0;
      break;
    case MPG123_INDEX_SIZE:
      result = 0;
      if ( val )
        *val = 0;
      return result;
    case MPG123_PREFRAMES:
      verbose = mp->preframes;
      goto LABEL_30;
  }
  return result;
}

//----- (0022F4A0) --------------------------------------------------------
int __fastcall mpg123_getstate(mpg123_handle *mh, mpg123_state key, int *val, double *fval)
{
  int result; // r0
  int accurate; // r1

  if ( !mh )
    return -1;
  if ( key == MPG123_ACCURATE )
  {
    accurate = mh->accurate;
    result = 0;
  }
  else
  {
    mh->err = 34;
    accurate = 0;
    result = -1;
  }
  if ( val )
    *val = accurate;
  if ( fval )
    *fval = 0.0;
  return result;
}

//----- (0022F4DA) --------------------------------------------------------
int __fastcall mpg123_eq(mpg123_handle *mh, mpg123_channels channel, int band, int a4, double val)
{
  int v6; // r2
  int v7; // r1

  if ( !mh )
    return -1;
  if ( (unsigned int)band < 0x20 )
  {
    if ( channel != MPG123_LEFT )
    {
      if ( channel == MPG123_RIGHT )
      {
        v7 = 1;
        goto LABEL_11;
      }
      if ( channel != MPG123_LR )
      {
        v6 = 2;
        goto LABEL_13;
      }
      mh->equalizer[1][band] = val;
    }
    v7 = 0;
LABEL_11:
    mh->equalizer[v7][band] = val;
    mh->have_eq_settings = 1;
    return 0;
  }
  v6 = 16;
LABEL_13:
  mh->err = v6;
  return -1;
}

//----- (0022F540) --------------------------------------------------------
double __fastcall mpg123_geteq(mpg123_handle *mh, mpg123_channels channel, int band)
{
  double v3; // d16
  char *v5; // r0
  int v6; // r1

  if ( !mh )
    return -1.0;
  v3 = 0.0;
  if ( (unsigned int)band <= 0x1F )
  {
    switch ( channel )
    {
      case MPG123_LEFT:
        v5 = (char *)mh + 8 * band;
        v6 = 18512;
        break;
      case MPG123_RIGHT:
        v5 = (char *)mh + 8 * band;
        v6 = 18768;
        break;
      case MPG123_LR:
        return (mh->equalizer[0][band] + mh->equalizer[1][band]) * 0.5;
      default:
        return v3;
    }
    return *(double *)&v5[v6];
  }
  return v3;
}

//----- (0022F5A8) --------------------------------------------------------
int __fastcall mpg123_open(mpg123_handle *mh, const unsigned __int8 *path)
{
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0

  if ( !mh )
    return -1;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  mh->rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    mh->xing_toc = 0;
  }
  return INT123_open_stream(mh, path, -1);
}

//----- (0022F688) --------------------------------------------------------
int __fastcall mpg123_close(mpg123_handle *mh)
{
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int v4; // r5
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0

  if ( !mh )
    return -1;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  v4 = 0;
  mh->rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    v4 = 0;
    mh->xing_toc = 0;
  }
  return v4;
}

//----- (0022F758) --------------------------------------------------------
int __fastcall INT123_open_stream(mpg123_handle *fr, const unsigned __int8 *bs_filenam, int fd)
{
  unsigned __int8 *data; // r0
  int v7; // r0
  int icy_interval; // r0
  reader *v9; // r0
  FILE *v11; // r6
  int *v12; // r0
  char *v13; // r0

  data = fr->icy.data;
  if ( data )
    free(data);
  v7 = 0;
  fr->icy.data = 0;
  if ( !bs_filenam )
    goto LABEL_6;
  fd = open((const char *)bs_filenam, 0, 438);
  if ( fd > -1 )
  {
    v7 = 1;
LABEL_6:
    fr->rdat.flags = v7;
    fr->rdat.filept = fd;
    icy_interval = fr->p.icy_interval;
    fr->rdat.filelen = -1;
    if ( icy_interval < 1 )
    {
      v9 = readers;
    }
    else
    {
      fr->icy.next = icy_interval;
      fr->icy.interval = icy_interval;
      v9 = &readers[1];
    }
    fr->rd = v9;
    return v9->init(fr) >> 31;
  }
  if ( (fr->p.flags & 0x20) == 0 )
  {
    v11 = (FILE *)stderr;
    v12 = (int *)_errno(&stderr);
    v13 = strerror(*v12);
    fprintf(
      v11,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: Cannot open file %s: %s\n",
      1073,
      (const char *)bs_filenam,
      v13);
  }
  fr->err = 22;
  return -1;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (0022F838) --------------------------------------------------------
int __fastcall mpg123_open_fd(mpg123_handle *mh, int fd)
{
  reader **p_rd; // r6
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0
  unsigned __int8 *data; // r0
  int icy_interval; // r0
  reader *v12; // r0

  if ( !mh )
    return -1;
  p_rd = &mh->rd;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  *p_rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    mh->xing_toc = 0;
  }
  data = mh->icy.data;
  if ( data )
    free(data);
  mh->icy.data = 0;
  mh->rdat.flags = 0;
  mh->rdat.filept = fd;
  icy_interval = mh->p.icy_interval;
  mh->rdat.filelen = -1;
  if ( icy_interval < 1 )
  {
    v12 = readers;
  }
  else
  {
    mh->icy.next = icy_interval;
    mh->icy.interval = icy_interval;
    v12 = &readers[1];
  }
  *p_rd = v12;
  return v12->init(mh) >> 31;
}

//----- (0022F970) --------------------------------------------------------
int __fastcall mpg123_open_handle(mpg123_handle *mh, void *iohandle)
{
  reader **p_rd; // r6
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0
  unsigned __int8 *data; // r0
  int icy_interval; // r0
  reader *v12; // r0

  if ( !mh )
    return -1;
  p_rd = &mh->rd;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  *p_rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    mh->xing_toc = 0;
  }
  if ( !mh->rdat.r_read_handle )
  {
    mh->err = 41;
    return -1;
  }
  data = mh->icy.data;
  if ( data )
    free(data);
  mh->icy.data = 0;
  mh->rdat.iohandle = iohandle;
  mh->rdat.filept = -1;
  mh->rdat.flags = 64;
  icy_interval = mh->p.icy_interval;
  mh->rdat.filelen = -1;
  if ( icy_interval < 1 )
  {
    v12 = readers;
  }
  else
  {
    mh->icy.next = icy_interval;
    mh->icy.interval = icy_interval;
    v12 = &readers[1];
  }
  *p_rd = v12;
  return v12->init(mh) >> 31;
}

//----- (0022FAC0) --------------------------------------------------------
int __fastcall INT123_open_stream_handle(mpg123_handle *fr, void *iohandle)
{
  icy_meta *p_icy; // r6
  unsigned __int8 *data; // r0
  int icy_interval; // r0
  reader *v7; // r0

  p_icy = &fr->icy;
  data = fr->icy.data;
  if ( data )
    free(data);
  p_icy->data = 0;
  fr->rdat.iohandle = iohandle;
  fr->rdat.filept = -1;
  fr->rdat.flags = 64;
  icy_interval = fr->p.icy_interval;
  fr->rdat.filelen = -1;
  if ( icy_interval < 1 )
  {
    v7 = readers;
  }
  else
  {
    fr->icy.next = icy_interval;
    fr->icy.interval = icy_interval;
    v7 = &readers[1];
  }
  fr->rd = v7;
  return v7->init(fr) >> 31;
}

//----- (0022FB40) --------------------------------------------------------
int __fastcall mpg123_open_feed(mpg123_handle *mh)
{
  reader **p_rd; // r5
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0
  unsigned __int8 *data; // r0

  if ( !mh )
    return -1;
  p_rd = &mh->rd;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  *p_rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    mh->xing_toc = 0;
  }
  if ( mh->p.icy_interval >= 1 )
  {
    if ( (mh->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: Feed reader cannot do ICY parsing!\n",
        1020);
    return -1;
  }
  data = mh->icy.data;
  if ( data )
    free(data);
  mh->icy.data = 0;
  *p_rd = &readers[2];
  mh->rdat.flags = 0;
  return readers[2].init(mh) >> 31;
}

//----- (0022FC74) --------------------------------------------------------
int __fastcall INT123_open_feed(mpg123_handle *fr)
{
  unsigned __int8 *data; // r0

  if ( fr->p.icy_interval < 1 )
  {
    data = fr->icy.data;
    if ( data )
      free(data);
    fr->icy.data = 0;
    fr->rdat.flags = 0;
    fr->rd = &readers[2];
    return readers[2].init(fr) >> 31;
  }
  else
  {
    if ( (fr->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: Feed reader cannot do ICY parsing!\n",
        1020);
    return -1;
  }
}

//----- (0022FCEC) --------------------------------------------------------
int __fastcall mpg123_replace_reader(
        mpg123_handle *mh,
        ssize_t (*r_read)(int, void *, size_t),
        off_t (*r_lseek)(int, off_t, int))
{
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0

  if ( !mh )
    return -1;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  mh->rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    mh->xing_toc = 0;
  }
  mh->rdat.r_lseek = r_lseek;
  mh->rdat.r_read = r_read;
  return 0;
}

//----- (0022FDD4) --------------------------------------------------------
int __fastcall mpg123_replace_reader_handle(
        mpg123_handle *mh,
        ssize_t (*r_read)(void *, void *, size_t),
        off_t (*r_lseek)(void *, off_t, int),
        void (*cleanup)(void *))
{
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0

  if ( !mh )
    return -1;
  rd = mh->rd;
  if ( rd )
  {
    close = rd->close;
    if ( close )
      close(mh);
  }
  mh->rd = 0;
  if ( mh->new_format )
  {
    mh->af.channels = 0;
    mh->af.rate = 0;
    mh->af.encoding = 0;
    mh->new_format = 0;
  }
  mh->bsnum = 0;
  mh->buffer.fill = 0;
  mh->bsbuf = mh->bsspace[1];
  rawbuffss = mh->rawbuffss;
  mh->bsbufold = mh->bsspace[1];
  rawbuffs = mh->rawbuffs;
  mh->bitreservoir = 0;
  memset(rawbuffs, 0, rawbuffss);
  memset(mh->bsspace, 0, sizeof(mh->bsspace));
  *(_WORD *)&mh->ssave[32] = 0;
  *(_QWORD *)&mh->ssave[16] = 0LL;
  *(_QWORD *)&mh->ssave[24] = 0LL;
  *(_QWORD *)mh->ssave = 0LL;
  *(_QWORD *)&mh->ssave[8] = 0LL;
  memset(mh->hybrid_block, 0, 0x4808u);
  frame_fixed_reset(mh);
  xing_toc = mh->xing_toc;
  if ( xing_toc )
  {
    free(xing_toc);
    mh->xing_toc = 0;
  }
  mh->rdat.r_lseek_handle = r_lseek;
  mh->rdat.r_read_handle = r_read;
  mh->rdat.cleanup_handle = cleanup;
  return 0;
}

//----- (0022FEC8) --------------------------------------------------------
int __fastcall INT123_decode_update(mpg123_handle *mh)
{
  int sampling_frequency; // r6
  int v3; // r0
  int v4; // r1
  int rate; // r2
  int v6; // r0
  int v7; // r6
  int v8; // r8
  int v9; // r1
  unsigned int v10; // r0
  int lay; // r0
  int v12; // r5
  unsigned int v13; // r1
  int v14; // r1
  int flags; // r2
  int v16; // r0

  if ( mh->num <= -1 )
  {
    if ( (mh->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/libmpg123.c:%i] error: decode_update() has been calle"
        "d before reading the first MPEG frame! Internal programming error.\n",
        511);
    mh->err = 37;
    return -1;
  }
  sampling_frequency = mh->sampling_frequency;
  v3 = j_INT123_frame_output_format(mh);
  if ( v3 < 0 )
    return -1;
  if ( v3 == 1 )
    mh->new_format = 1;
  v4 = freqs[sampling_frequency];
  rate = mh->af.rate;
  if ( rate == v4 )
  {
    v6 = 0;
  }
  else if ( rate == v4 >> 1 )
  {
    v6 = 1;
  }
  else
  {
    v6 = 3;
    if ( rate == v4 >> 2 )
      v6 = 2;
  }
  mh->down_sample = v6;
  if ( v6 == 3 )
  {
    if ( !j_INT123_synth_ntom_set_step(mh) )
    {
      v7 = mh->af.rate;
      v8 = freqs[mh->sampling_frequency];
      if ( v8 <= v7 )
        mh->down_sample_sblimit = 32;
      else
        mh->down_sample_sblimit = 32 * v7 / v8;
      lay = mh->lay;
      if ( lay == 1 )
      {
        v12 = 384;
      }
      else if ( lay == 2 )
      {
        v12 = 1152;
      }
      else if ( mh->lsf )
      {
        v12 = 576;
      }
      else
      {
        v12 = 1152;
        if ( mh->mpeg25 )
          v12 = 576;
      }
      v10 = ((v7 << 15) / (unsigned int)v8 * v12 + 0x7FFF) >> 15;
      goto LABEL_37;
    }
    return -1;
  }
  v9 = mh->lay;
  mh->down_sample_sblimit = 0x20u >> v6;
  if ( v9 == 1 )
  {
    v10 = 0x180u >> v6;
  }
  else if ( v9 == 2 )
  {
    v10 = 0x480u >> v6;
  }
  else if ( mh->lsf )
  {
    v10 = 0x240u >> v6;
  }
  else
  {
    v13 = 1152;
    if ( mh->mpeg25 )
      v13 = 576;
    v10 = v13 >> v6;
  }
LABEL_37:
  if ( (mh->af.encoding & 0x4000) != 0 )
    v14 = 4 * v10;
  else
    v14 = mh->af.encsize * v10;
  flags = mh->p.flags;
  mh->outblock = v14 * mh->af.channels;
  if ( (flags & 7) != 0 )
  {
    v16 = (flags & 7) - 1;
  }
  else
  {
    v16 = -1;
    if ( mh->af.channels == 1 )
      v16 = 3;
  }
  mh->single = v16;
  if ( j_INT123_set_synth_functions(mh) )
    return -1;
  j_INT123_do_rva(mh);
  return 0;
}

//----- (002300B0) --------------------------------------------------------
int __fastcall INT123_synth_ntom_set_step(mpg123_handle *fr)
{
  int sampling_frequency; // r3
  int *p_flags; // r8
  unsigned int v4; // r5
  int rate; // r6
  bool v6; // cc
  unsigned int v7; // r0
  off_t num; // r1
  int lay; // r2
  int *p_lsf; // lr
  int v12; // r3
  int v13; // r5
  bool v14; // zf

  sampling_frequency = fr->sampling_frequency;
  p_flags = &fr->p.flags;
  v4 = freqs[sampling_frequency];
  rate = fr->af.rate;
  if ( (fr->p.flags & 0x20) == 0 && fr->p.verbose >= 2 )
    fprintf((FILE *)stderr, "Init rate converter: %ld->%ld\n", freqs[sampling_frequency], rate);
  v6 = v4 - 1 > (unsigned int)&elf_hash_chain[7525] + 3;
  if ( v4 - 1 <= (unsigned int)&elf_hash_chain[7525] + 3 )
    v6 = rate - 1 > (unsigned int)&elf_hash_chain[7525] + 3;
  if ( v6 )
  {
    if ( (*(_BYTE *)p_flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/ntom.c:%i] error: NtoM converter: illegal rates\n",
        22);
    goto LABEL_13;
  }
  v7 = (rate << 15) / v4;
  fr->ntom_step = v7;
  if ( v7 > 0x40000 )
  {
    if ( (*(_BYTE *)p_flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/ntom.c:%i] error: max. 1:%i conversion allowed (%lu vs %lu)!\n",
        31,
        8,
        (rate << 15) / v4,
        0x40000);
LABEL_13:
    fr->err = 3;
    return -1;
  }
  num = fr->num;
  if ( num < 1 )
  {
    v12 = 0x4000;
  }
  else
  {
    lay = fr->lay;
    p_lsf = &fr->lsf;
    v12 = 0x4000;
    do
    {
      if ( lay == 1 )
      {
        v13 = 384;
      }
      else
      {
        if ( lay == 2 )
          goto LABEL_18;
        v14 = *p_lsf == 0;
        if ( !*p_lsf )
          v14 = fr->mpeg25 == 0;
        if ( v14 )
LABEL_18:
          v13 = 1152;
        else
          v13 = 576;
      }
      --num;
      v12 = (int)(v12 + v13 * v7) % 0x8000;
    }
    while ( num );
  }
  fr->INT123_ntom_val[0] = v12;
  fr->INT123_ntom_val[1] = v12;
  return 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00230234) --------------------------------------------------------
int __fastcall INT123_set_synth_functions(mpg123_handle *fr)
{
  int encoding; // r0
  int v3; // r9
  unsigned int down_sample; // r0
  char *v5; // r3
  int (*v6)(double *, int, mpg123_handle *, int); // r0
  int channels; // r6
  func_synth_mono *v8; // r5
  char flags; // r1
  double *gainpow2; // r4
  int i; // r5
  double v12; // r0
  const bandInfoStruct *v13; // r0
  int (*shortLimit)[14]; // r1
  int *p_down_sample_sblimit; // r10
  int (*longLimit)[23]; // r3
  int v17; // r12
  int j; // r5
  unsigned int v19; // kr00_4
  unsigned int v20; // r2
  int k; // r5
  int v22; // r2
  int v23; // r6
  int m; // r5
  char *v25; // r9
  double *v26; // r10
  int v27; // r11
  double v28; // d9
  double v29; // r0

  encoding = fr->af.encoding;
  if ( (encoding & 0x40) != 0 )
  {
    v3 = 0;
  }
  else if ( encoding << 28 )
  {
    v3 = 1;
  }
  else if ( (encoding & 0xE00) != 0 )
  {
    v3 = 2;
  }
  else
  {
    if ( (encoding & 0x4100) == 0 )
    {
      if ( (fr->p.flags & 0x20) == 0 )
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/optimize.c:%i] error: set_synth_functions: This out"
          "put format is disabled in this build!\n",
          339);
      return -1;
    }
    v3 = 3;
  }
  down_sample = fr->down_sample;
  if ( down_sample >= 4 )
  {
    if ( (fr->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/optimize.c:%i] error: set_synth_functions: This resam"
        "pling mode is not supported in this build!\n",
        359);
    return -1;
  }
  v5 = (char *)fr + 16 * down_sample + 4 * v3;
  v6 = (int (*)(double *, int, mpg123_handle *, int))*((_DWORD *)v5 + 9317);
  channels = fr->af.channels;
  fr->synth = v6;
  fr->synth_stereo = (func_synth_stereo)*((_DWORD *)v5 + 9333);
  v8 = (func_synth_mono *)(v5 + 37460);
  if ( channels == 2 )
    v8 = (func_synth_mono *)(v5 + 37396);
  fr->synth_mono = *v8;
  if ( v6 == INT123_synth_1to1_8bit_wrap )
    v6 = fr->synths.plain[0][0];
  if ( v6 != INT123_synth_ntom_s32
    && v6 != INT123_synth_ntom_real
    && v6 != INT123_synth_ntom_8bit
    && v6 != INT123_synth_ntom
    && v6 != INT123_synth_4to1_s32
    && v6 != INT123_synth_4to1_real
    && v6 != INT123_synth_4to1_8bit
    && v6 != INT123_synth_4to1
    && v6 != INT123_synth_2to1_s32
    && v6 != INT123_synth_2to1_real
    && v6 != INT123_synth_2to1_8bit
    && v6 != INT123_synth_2to1
    && v6 != INT123_synth_1to1_s32
    && v6 != INT123_synth_1to1_real
    && v6 != INT123_synth_1to1
    && v6 != INT123_synth_1to1_8bit )
  {
    if ( (fr->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/optimize.c:%i] error: Unable to determine active deco"
        "der type -- this is SERIOUS b0rkage!\n",
        303);
    fr->err = 37;
    return -1;
  }
  fr->cpu_opts.class = normal;
  fr->cpu_opts.type = generic;
  if ( j_INT123_frame_buffers(fr) )
  {
    flags = fr->p.flags;
    fr->err = 11;
    if ( (flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/optimize.c:%i] error: Failed to set up decoder buffers!\n",
        381);
    return -1;
  }
  if ( v3 == 1 && j_INT123_make_conv16to8_table(fr) )
  {
    if ( (fr->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/optimize.c:%i] error: Failed to set up conv16to8 table!\n",
        391);
    return -1;
  }
  gainpow2 = fr->gainpow2;
  for ( i = -46; i != 332; ++i )
  {
    v12 = exp2(COERCE_UNSIGNED_INT64((double)i * -0.25), HIDWORD(COERCE_UNSIGNED_INT64((double)i * -0.25)));
    *gainpow2++ = v12;
  }
  v13 = bandInfo;
  shortLimit = fr->shortLimit;
  p_down_sample_sblimit = &fr->down_sample_sblimit;
  longLimit = fr->longLimit;
  v17 = 0;
  do
  {
    for ( j = 0; j != 23; ++j )
    {
      v19 = v13->longIdx[j] + 7;
      (*longLimit)[j] = v19 / 0x12 + 1;
      v20 = *p_down_sample_sblimit;
      if ( (signed int)(v19 / 0x12) < fr->down_sample_sblimit )
        v20 = v19 / 0x12 + 1;
      (*longLimit)[j] = v20;
    }
    for ( k = 0; k != 14; ++k )
    {
      v22 = (v13->shortIdx[k] - 1) / 18;
      (*shortLimit)[k] = v22 + 1;
      v23 = *p_down_sample_sblimit;
      if ( v22 < *p_down_sample_sblimit )
        v23 = v22 + 1;
      (*shortLimit)[k] = v23;
    }
    ++v17;
    ++shortLimit;
    ++v13;
    ++longLimit;
  }
  while ( v17 != 9 );
  for ( m = 0; m != 27; ++m )
  {
    v25 = (char *)fr + 512 * m;
    v26 = (double *)(v25 + 23432);
    v27 = 63;
    v28 = mulmul[m];
    do
    {
      v29 = exp2(
              COERCE_UNSIGNED_INT64((double)(v27 - 60) / 3.0),
              HIDWORD(COERCE_UNSIGNED_INT64((double)(v27 - 60) / 3.0)));
      --v27;
      *v26++ = v28 * v29;
    }
    while ( v27 );
    *((_DWORD *)v25 + 5985) = 0;
    *((_DWORD *)v25 + 5984) = 0;
  }
  fr->INT123_make_decode_tables = INT123_make_decode_tables;
  j_INT123_make_decode_tables(fr);
  return 0;
}
// 189E54: using guessed type double __fastcall exp2(_DWORD, _DWORD);

//----- (00230620) --------------------------------------------------------
size_t __fastcall mpg123_outblock(mpg123_handle *mh)
{
  if ( mh )
    return mh->outblock;
  else
    return (size_t)&elf_hash_chain[20390];
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00230630) --------------------------------------------------------
int __fastcall mpg123_framebyframe_decode(mpg123_handle *mh, off_t *num, unsigned __int8 **audio, size_t *bytes)
{
  bool v5; // zf
  int result; // r0
  outbuffer *p_buffer; // r9
  unsigned __int8 *data; // r1

  v5 = audio == 0;
  result = 17;
  if ( audio )
    v5 = bytes == 0;
  if ( !v5 )
  {
    if ( mh )
    {
      if ( mh->buffer.size >= mh->outblock )
      {
        result = 0;
        *bytes = 0;
        mh->buffer.fill = 0;
        if ( mh->to_decode )
        {
          p_buffer = &mh->buffer;
          if ( num )
            *num = mh->num;
          decode_the_frame(mh);
          result = 0;
          mh->to_ignore = 0;
          mh->to_decode = 0;
          data = p_buffer->data;
          mh->buffer.p = p_buffer->data;
          *audio = data;
          *bytes = mh->buffer.fill;
        }
      }
      else
      {
        return 14;
      }
    }
    else
    {
      return 10;
    }
  }
  return result;
}

//----- (002306C8) --------------------------------------------------------
void __fastcall decode_the_frame(mpg123_handle *fr)
{
  unsigned int down_sample; // r3
  int v3; // r0
  unsigned int v4; // r0
  int lay; // r1
  int v6; // r1
  unsigned int v7; // r0
  int v8; // r0
  unsigned int v9; // r5
  int v10; // r0
  size_t fill; // r1
  size_t *p_fill; // r8
  int v13; // r2
  off_t num; // r2
  int v15; // r1
  int *p_lsf; // lr
  int v17; // r5
  int v18; // r2
  int v19; // r6
  bool v20; // zf

  down_sample = fr->down_sample;
  if ( down_sample >= 3 )
  {
    if ( down_sample == 3 )
    {
      lay = fr->lay;
      if ( lay == 1 )
      {
        v6 = 384;
      }
      else if ( lay == 2 )
      {
        v6 = 1152;
      }
      else if ( fr->lsf )
      {
        v6 = 576;
      }
      else
      {
        v6 = 1152;
        if ( fr->mpeg25 )
          v6 = 576;
      }
      v4 = (signed int)(fr->INT123_ntom_val[0] + fr->ntom_step * v6) / 0x8000;
    }
    else
    {
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should no"
        "t be possible!!\n",
        766,
        down_sample);
      v4 = 0;
    }
  }
  else
  {
    v3 = fr->lay;
    if ( v3 == 1 )
    {
      v4 = 0x180u >> down_sample;
    }
    else if ( v3 == 2 )
    {
      v4 = 0x480u >> down_sample;
    }
    else if ( fr->lsf )
    {
      v4 = 0x240u >> down_sample;
    }
    else
    {
      v7 = 1152;
      if ( fr->mpeg25 )
        v7 = 576;
      v4 = v7 >> down_sample;
    }
  }
  if ( (fr->af.encoding & 0x4000) != 0 )
    v8 = 4 * v4;
  else
    v8 = v4 * fr->af.encsize;
  v9 = fr->af.channels * v8;
  v10 = fr->do_layer(fr);
  fill = fr->buffer.fill;
  fr->clip += v10;
  if ( v9 > fill )
  {
    p_fill = &fr->buffer.fill;
    if ( (fr->p.flags & 0x20) == 0 && fr->p.verbose >= 2 )
    {
      fprintf(
        (FILE *)stderr,
        "Note: broken frame %li, filling up with %lu zeroes, from %lu\n",
        fr->num,
        v9 - fill,
        fill);
      fill = *p_fill;
    }
    if ( LOBYTE(fr->af.encoding) << 28 )
      v13 = *fr->conv16to8;
    else
      v13 = 0;
    memset(&fr->buffer.data[fill], v13, v9 - fill);
    *p_fill = v9;
    num = fr->num;
    if ( num < 0 )
    {
      v18 = 0x4000;
    }
    else
    {
      v15 = fr->lay;
      p_lsf = &fr->lsf;
      v17 = num + 1;
      v18 = 0x4000;
      do
      {
        if ( v15 == 1 )
        {
          v19 = 384;
        }
        else
        {
          if ( v15 == 2 )
            goto LABEL_36;
          v20 = *p_lsf == 0;
          if ( !*p_lsf )
            v20 = fr->mpeg25 == 0;
          if ( v20 )
LABEL_36:
            v19 = 1152;
          else
            v19 = 576;
        }
        --v17;
        v18 = (signed int)(v18 + v19 * fr->ntom_step) % 0x8000;
      }
      while ( v17 );
    }
    fr->INT123_ntom_val[1] = v18;
    fr->INT123_ntom_val[0] = v18;
  }
  postprocess_buffer(fr);
}

//----- (0023090C) --------------------------------------------------------
int __fastcall mpg123_framebyframe_next(mpg123_handle *mh)
{
  int result; // r0

  if ( !mh )
    return 10;
  mh->to_decode = 0;
  mh->to_ignore = 0;
  mh->buffer.fill = 0;
  result = get_next_frame(mh);
  if ( result >= 0 )
  {
    if ( mh->to_decode )
    {
      result = 0;
      if ( mh->new_format )
      {
        mh->new_format = 0;
        return -11;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00230952) --------------------------------------------------------
int __fastcall get_next_frame(mpg123_handle *mh)
{
  int *p_to_ignore; // r10
  int decoder_change; // r8
  unsigned __int8 *v4; // r0
  int v5; // r1
  int frame; // r0
  int v7; // r1
  int v8; // r0
  off_t v9; // r9
  off_t v10; // r11
  int v11; // r0
  int v12; // r3
  int v13; // r6
  bool v14; // zf
  int result; // r0
  int *p_decoder_change; // [sp+0h] [bp-78h]
  int *p_lsf; // [sp+4h] [bp-74h]
  int *p_mpeg25; // [sp+8h] [bp-70h]
  unsigned int *p_ntom_step; // [sp+Ch] [bp-6Ch]
  unsigned int *INT123_ntom_val; // [sp+10h] [bp-68h]
  unsigned int *v21; // [sp+14h] [bp-64h]
  int (**p_do_layer)(mpg123_handle *); // [sp+18h] [bp-60h]
  size_t *p_fill; // [sp+1Ch] [bp-5Ch]
  int *p_down_sample; // [sp+20h] [bp-58h]
  unsigned __int8 **p_bsbuf; // [sp+24h] [bp-54h]
  int *p_ssize; // [sp+28h] [bp-50h]
  unsigned __int8 **p_wordpointer; // [sp+2Ch] [bp-4Ch]
  unsigned __int8 **p_bsbufold; // [sp+30h] [bp-48h]
  int *p_fsizeold; // [sp+34h] [bp-44h]
  int *p_bitindex; // [sp+38h] [bp-40h]
  int *p_doublespeed; // [sp+3Ch] [bp-3Ch]
  int *p_lay; // [sp+40h] [bp-38h]
  off_t *p_ignoreframe; // [sp+44h] [bp-34h]
  off_t *p_playnum; // [sp+48h] [bp-30h]
  int *p_header_change; // [sp+4Ch] [bp-2Ch]
  int *p_to_decode; // [sp+50h] [bp-28h]
  off_t *p_firstframe; // [sp+54h] [bp-24h]
  off_t *p_num; // [sp+58h] [bp-20h]

  v21 = &mh->INT123_ntom_val[1];
  INT123_ntom_val = mh->INT123_ntom_val;
  p_ntom_step = &mh->ntom_step;
  p_mpeg25 = &mh->mpeg25;
  p_lsf = &mh->lsf;
  p_down_sample = &mh->down_sample;
  p_fill = &mh->buffer.fill;
  p_do_layer = &mh->do_layer;
  p_doublespeed = &mh->p.doublespeed;
  p_ignoreframe = &mh->ignoreframe;
  p_bitindex = &mh->bitindex;
  p_fsizeold = &mh->fsizeold;
  p_bsbufold = &mh->bsbufold;
  p_wordpointer = &mh->wordpointer;
  p_ssize = &mh->ssize;
  p_bsbuf = &mh->bsbuf;
  p_lay = &mh->lay;
  p_firstframe = &mh->firstframe;
  p_num = &mh->num;
  p_playnum = &mh->playnum;
  p_header_change = &mh->header_change;
  p_to_decode = &mh->to_decode;
  p_to_ignore = &mh->to_ignore;
  decoder_change = mh->decoder_change;
  p_decoder_change = &mh->decoder_change;
  while ( 1 )
  {
    if ( *p_to_ignore && *p_num < *p_firstframe && *p_num >= *p_ignoreframe )
    {
      (*p_do_layer)(mh);
      *p_fill = 0;
      if ( *p_down_sample == 3 )
      {
        if ( *p_num < 0 )
        {
          v5 = 0x4000;
        }
        else
        {
          v11 = *p_num + 1;
          v12 = *p_lay;
          v5 = 0x4000;
          do
          {
            if ( v12 == 1 )
            {
              v13 = 384;
            }
            else
            {
              if ( v12 == 2 )
                goto LABEL_25;
              v14 = *p_lsf == 0;
              if ( !*p_lsf )
                v14 = *p_mpeg25 == 0;
              if ( v14 )
LABEL_25:
                v13 = 1152;
              else
                v13 = 576;
            }
            --v11;
            v5 = (int)(v5 + v13 * *p_ntom_step) % 0x8000;
          }
          while ( v11 );
        }
        *INT123_ntom_val = v5;
        *v21 = v5;
      }
      *p_to_decode = 0;
      *p_to_ignore = 0;
    }
    *p_to_decode = 0;
    frame = j_INT123_read_frame(mh);
    if ( frame == -10 )
      return -10;
    if ( frame <= 0 )
    {
      if ( !frame || mh->rdat.filepos == mh->rdat.filelen )
      {
        mh->track_frames = *p_num + 1;
        return -12;
      }
      return -1;
    }
    v7 = *p_header_change;
    v8 = *p_playnum + 1;
    *p_playnum = v8;
    v9 = *p_firstframe;
    v10 = *p_num;
    if ( v7 > 1 )
      decoder_change = 1;
    if ( v10 >= v9 && (!*p_doublespeed || !(v8 % *p_doublespeed)) )
      break;
    if ( (!*p_to_ignore || v10 >= v9 || v10 < *p_ignoreframe) && *p_lay == 3 )
    {
      v4 = &(*p_bsbuf)[*p_ssize - 512];
      *p_wordpointer = v4;
      qmemcpy(v4, &(*p_bsbufold)[*p_fsizeold - 512], 0x200u);
      *p_bitindex = 0;
    }
  }
  if ( !decoder_change )
    return 0;
  if ( j_INT123_decode_update(mh) < 0 )
    return -1;
  result = 0;
  *p_decoder_change = 0;
  if ( mh->fresh )
    mh->fresh = 0;
  return result;
}

//----- (00230BC0) --------------------------------------------------------
int __fastcall mpg123_decode_frame(mpg123_handle *mh, off_t *num, unsigned __int8 **audio, size_t *bytes)
{
  int result; // r0
  outbuffer *p_buffer; // r10
  int *p_to_decode; // r5
  size_t *p_fill; // r9
  unsigned __int8 *data; // r0

  if ( bytes )
    *bytes = 0;
  if ( !mh )
    return -1;
  if ( mh->buffer.size < mh->outblock )
    return 14;
  p_buffer = &mh->buffer;
  mh->buffer.fill = 0;
  p_to_decode = &mh->to_decode;
  p_fill = &mh->buffer.fill;
  while ( !*p_to_decode )
  {
    result = get_next_frame(mh);
    if ( result <= -1 )
      return result;
  }
  if ( mh->new_format )
  {
    mh->new_format = 0;
    return -11;
  }
  else
  {
    if ( num )
      *num = mh->num;
    decode_the_frame(mh);
    mh->to_ignore = 0;
    *p_to_decode = 0;
    data = p_buffer->data;
    mh->buffer.p = p_buffer->data;
    if ( audio )
      *audio = data;
    if ( bytes )
      *bytes = *p_fill;
    return 0;
  }
}

//----- (00230C78) --------------------------------------------------------
int __fastcall mpg123_read(mpg123_handle *mh, unsigned __int8 *out, size_t size, size_t *done)
{
  return j_mpg123_decode(mh, 0, 0, out, size, done);
}

//----- (00230C94) --------------------------------------------------------
int __fastcall mpg123_decode(
        mpg123_handle *mh,
        const unsigned __int8 *inmemory,
        size_t inmemsize,
        unsigned __int8 *outmemory,
        size_t outmemsize,
        size_t *done)
{
  int next_frame; // r6
  const void **p_p; // r5
  size_t *p_fill; // r8
  int *p_to_decode; // r10
  size_t v13; // r6
  size_t v14; // r0
  size_t v16; // [sp+0h] [bp-30h]
  unsigned __int8 *v17; // [sp+4h] [bp-2Ch]
  size_t v18; // [sp+8h] [bp-28h]

  if ( done )
    *done = 0;
  if ( !mh )
    return -1;
  if ( !inmemsize )
  {
LABEL_14:
    v17 = outmemory;
    if ( !outmemory )
      outmemsize = 0;
    v16 = outmemsize;
    p_p = (const void **)&mh->buffer.p;
    p_fill = &mh->buffer.fill;
    p_to_decode = &mh->to_decode;
    v18 = 0;
    while ( 1 )
    {
      if ( *p_to_decode )
      {
        if ( mh->new_format )
        {
          next_frame = -11;
          mh->new_format = 0;
          goto LABEL_30;
        }
        if ( mh->buffer.size - *p_fill < mh->outblock )
        {
          next_frame = 14;
          goto LABEL_30;
        }
        decode_the_frame(mh);
        mh->to_ignore = 0;
        *p_to_decode = 0;
        *p_p = mh->buffer.data;
      }
      v13 = *p_fill;
      if ( *p_fill )
      {
        if ( v13 > v16 - v18 )
          v13 = v16 - v18;
        qmemcpy(v17, *p_p, v13);
        *p_fill -= v13;
        *p_p = (char *)*p_p + v13;
        v17 += v13;
        v14 = v18 + v13;
        next_frame = 0;
        v18 = v14;
        if ( v16 <= v14 )
          goto LABEL_30;
      }
      else
      {
        next_frame = get_next_frame(mh);
        if ( next_frame <= -1 )
          goto LABEL_30;
      }
    }
  }
  if ( !inmemory )
  {
    mh->err = 31;
    goto LABEL_11;
  }
  if ( !bc_add(&mh->rdat.buffer, inmemory, inmemsize) )
  {
    if ( mh->err == 18 )
      mh->err = 0;
    goto LABEL_14;
  }
  if ( (mh->p.flags & 0x20) == 0 )
  {
    next_frame = -1;
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: Failed to add buffer, return: %i\n",
      666,
      -1);
    v18 = 0;
    goto LABEL_30;
  }
LABEL_11:
  next_frame = -1;
  v18 = 0;
LABEL_30:
  if ( done )
    *done = v18;
  return next_frame;
}

//----- (00230E04) --------------------------------------------------------
int __fastcall mpg123_feed(mpg123_handle *mh, const unsigned __int8 *in, size_t size)
{
  int v5; // r4

  if ( !mh )
    return -1;
  if ( !size )
    return 0;
  if ( !in )
  {
    mh->err = 31;
    return -1;
  }
  if ( bc_add(&mh->rdat.buffer, in, size) )
  {
    if ( (mh->p.flags & 0x20) == 0 )
    {
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: Failed to add buffer, return: %i\n",
        666,
        -1);
      return -1;
    }
    return -1;
  }
  v5 = 0;
  if ( mh->err != 18 )
    return v5;
  mh->err = 0;
  return 0;
}

//----- (00230E78) --------------------------------------------------------
int __fastcall INT123_feed_more(mpg123_handle *fr, const unsigned __int8 *in, int count)
{
  if ( !bc_add(&fr->rdat.buffer, in, count) )
    return 0;
  if ( (fr->p.flags & 0x20) == 0 )
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: Failed to add buffer, return: %i\n",
      666,
      -1);
  return -1;
}

//----- (00230ECC) --------------------------------------------------------
int __fastcall mpg123_clip(mpg123_handle *mh)
{
  int result; // r0
  int clip; // r3

  result = 0;
  if ( mh )
  {
    clip = mh->clip;
    mh->clip = 0;
    return clip;
  }
  return result;
}

//----- (00230EE0) --------------------------------------------------------
int __fastcall mpg123_getformat(mpg123_handle *mh, int *rate, int *channels, int *encoding)
{
  int result; // r0

  if ( !mh )
    return -1;
  if ( mh->to_decode || !mh->fresh || (result = get_next_frame(mh), result >= 0) )
  {
    if ( rate )
      *rate = mh->af.rate;
    if ( channels )
      *channels = mh->af.channels;
    if ( encoding )
      *encoding = mh->af.encoding;
    result = 0;
    mh->new_format = 0;
  }
  return result;
}

//----- (00230F48) --------------------------------------------------------
off_t __fastcall mpg123_timeframe(mpg123_handle *mh, double seconds)
{
  unsigned int v4; // r5
  unsigned int v5; // r6
  off_t result; // r0

  v4 = HIDWORD(seconds);
  v5 = LODWORD(seconds);
  if ( !mh )
    return -1;
  if ( mh->to_decode )
    return (int)(COERCE_DOUBLE(__PAIR64__(v4, v5))
               / ((double)mpg123_tpf_bs[mh->lay]
                / (double)(int)(freqs[mh->sampling_frequency] << mh->lsf)));
  if ( !mh->fresh )
    return (int)(COERCE_DOUBLE(__PAIR64__(v4, v5))
               / ((double)mpg123_tpf_bs[mh->lay]
                / (double)(int)(freqs[mh->sampling_frequency] << mh->lsf)));
  result = get_next_frame(mh);
  if ( result >= 0 )
    return (int)(COERCE_DOUBLE(__PAIR64__(v4, v5))
               / ((double)mpg123_tpf_bs[mh->lay]
                / (double)(int)(freqs[mh->sampling_frequency] << mh->lsf)));
  return result;
}

//----- (00230FD4) --------------------------------------------------------
double __fastcall mpg123_tpf(mpg123_handle *fr)
{
  if ( fr )
    return (double)mpg123_tpf_bs[fr->lay] / (double)(int)(freqs[fr->sampling_frequency] << fr->lsf);
  else
    return -1.0;
}

//----- (00231034) --------------------------------------------------------
off_t __fastcall mpg123_tell(mpg123_handle *mh)
{
  int to_decode; // r2
  off_t result; // r0
  off_t firstframe; // r1
  off_t num; // r0
  unsigned int down_sample; // r3
  int v7; // r0
  unsigned int v8; // r0
  unsigned int v9; // r3
  int v10; // r1
  unsigned int v11; // r1
  unsigned int ntom_step; // r2
  int lay; // r3
  int *p_mpeg25; // r12
  int *p_lsf; // lr
  int v16; // r4
  int v17; // r6
  bool v18; // zf
  signed int v19; // kr00_4
  unsigned int v20; // r3
  int v21; // r1
  int v22; // r0
  unsigned int v23; // r0
  int v24; // r2
  int *v25; // lr
  int v26; // r5
  int v27; // r6
  int v28; // r3
  bool v29; // zf
  signed int v30; // r3
  int v31; // r2
  int *v32; // lr
  int v33; // r6
  int v34; // r3
  bool v35; // zf
  signed int v36; // r3

  if ( !mh )
    return -1;
  to_decode = mh->to_decode;
  if ( !to_decode && mh->fresh )
    return 0;
  firstframe = mh->firstframe;
  num = mh->num;
  if ( num < firstframe )
    goto LABEL_8;
  if ( num == firstframe )
  {
    if ( to_decode )
    {
LABEL_8:
      down_sample = mh->down_sample;
      if ( down_sample >= 3 )
      {
        if ( down_sample == 3 )
        {
          if ( firstframe < 1 )
          {
            result = 0;
          }
          else
          {
            ntom_step = mh->ntom_step;
            lay = mh->lay;
            p_mpeg25 = &mh->mpeg25;
            p_lsf = &mh->lsf;
            result = 0;
            v16 = 0x4000;
            do
            {
              if ( lay == 1 )
              {
                v17 = 384;
              }
              else
              {
                if ( lay == 2 )
                  goto LABEL_24;
                v18 = *p_lsf == 0;
                if ( !*p_lsf )
                  v18 = *p_mpeg25 == 0;
                if ( v18 )
LABEL_24:
                  v17 = 1152;
                else
                  v17 = 576;
              }
              --firstframe;
              v19 = v16 + v17 * ntom_step;
              v16 = v19 % 0x8000;
              result += v19 / 0x8000;
            }
            while ( firstframe );
          }
        }
        else
        {
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... shoul"
            "d not be possible!!\n",
            744,
            down_sample);
          result = 0;
        }
      }
      else
      {
        v7 = mh->lay;
        if ( v7 == 1 )
        {
          v8 = 384;
        }
        else if ( v7 == 2 )
        {
          v8 = 1152;
        }
        else if ( mh->lsf )
        {
          v8 = 576;
        }
        else
        {
          v8 = 1152;
          if ( mh->mpeg25 )
            v8 = 576;
        }
        result = (v8 >> down_sample) * firstframe;
      }
      goto LABEL_84;
    }
LABEL_32:
    v20 = mh->down_sample;
    v21 = num + 1;
    if ( v20 < 3 )
    {
      v22 = mh->lay;
      if ( v22 == 1 )
      {
        v23 = 384;
      }
      else if ( v22 == 2 )
      {
        v23 = 1152;
      }
      else if ( mh->lsf )
      {
        v23 = 576;
      }
      else
      {
        v23 = 1152;
        if ( mh->mpeg25 )
          v23 = 576;
      }
      v26 = (v23 >> v20) * v21;
      goto LABEL_83;
    }
    if ( v20 == 3 )
    {
      if ( num >= 0 )
      {
        v24 = mh->lay;
        v25 = &mh->lsf;
        v26 = 0;
        v27 = 0x4000;
        do
        {
          if ( v24 == 1 )
          {
            v28 = 384;
          }
          else
          {
            if ( v24 == 2 )
              goto LABEL_48;
            v29 = *v25 == 0;
            if ( !*v25 )
              v29 = mh->mpeg25 == 0;
            if ( v29 )
LABEL_48:
              v28 = 1152;
            else
              v28 = 576;
          }
          v30 = v27 + v28 * mh->ntom_step;
          --v21;
          v27 = v30 % 0x8000;
          v26 += v30 / 0x8000;
        }
        while ( v21 );
        goto LABEL_83;
      }
      goto LABEL_82;
    }
    goto LABEL_57;
  }
  if ( !to_decode )
    goto LABEL_32;
  v9 = mh->down_sample;
  if ( v9 < 3 )
  {
    v10 = mh->lay;
    if ( v10 == 1 )
    {
      v11 = 384;
    }
    else if ( v10 == 2 )
    {
      v11 = 1152;
    }
    else if ( mh->lsf )
    {
      v11 = 576;
    }
    else
    {
      v11 = 1152;
      if ( mh->mpeg25 )
        v11 = 576;
    }
    v26 = (v11 >> v9) * num;
    goto LABEL_83;
  }
  if ( v9 == 3 )
  {
    if ( num >= 1 )
    {
      v31 = mh->lay;
      v32 = &mh->lsf;
      v26 = 0;
      v33 = 0x4000;
      do
      {
        if ( v31 == 1 )
        {
          v34 = 384;
        }
        else
        {
          if ( v31 == 2 )
            goto LABEL_62;
          v35 = *v32 == 0;
          if ( !*v32 )
            v35 = mh->mpeg25 == 0;
          if ( v35 )
LABEL_62:
            v34 = 1152;
          else
            v34 = 576;
        }
        v36 = v33 + v34 * mh->ntom_step;
        --num;
        v33 = v36 % 0x8000;
        v26 += v36 / 0x8000;
      }
      while ( num );
      goto LABEL_83;
    }
    goto LABEL_82;
  }
LABEL_57:
  fprintf(
    (FILE *)stderr,
    "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
    744);
LABEL_82:
  v26 = 0;
LABEL_83:
  result = v26 - (signed int)mh->buffer.fill / mh->af.encsize / mh->af.channels;
LABEL_84:
  if ( result <= 0 )
    return 0;
  return result;
}

//----- (00231348) --------------------------------------------------------
off_t __fastcall mpg123_tellframe(mpg123_handle *mh)
{
  off_t firstframe; // r1
  off_t num; // r2

  if ( !mh )
    return -1;
  firstframe = mh->firstframe;
  num = mh->num;
  if ( num >= firstframe )
  {
    if ( !mh->to_decode && !mh->buffer.fill )
      ++num;
    return num;
  }
  return firstframe;
}

//----- (0023137E) --------------------------------------------------------
off_t __fastcall mpg123_tell_stream(mpg123_handle *mh)
{
  if ( mh )
    return ((int (*)(void))mh->rd->tell)();
  else
    return -1;
}

//----- (00231394) --------------------------------------------------------
off_t __fastcall mpg123_seek(mpg123_handle *mh, off_t sampleoff, int whence)
{
  off_t v6; // r0
  off_t v7; // r5
  off_t result; // r0
  off_t track_frames; // r0
  unsigned int down_sample; // r3
  int v11; // r1
  unsigned int v12; // r1
  int v13; // r5
  int lay; // r3
  int *p_lsf; // lr
  int v16; // r6
  bool v17; // zf
  signed int v18; // kr00_4
  int v19; // r1

  v6 = j_mpg123_tell(mh);
  v7 = v6;
  if ( whence && v6 <= -1 )
  {
    if ( mh )
      mh->err = 32;
    return -1;
  }
  if ( mh->to_decode || !mh->fresh || (result = get_next_frame(mh), result >= 0) )
  {
    if ( whence )
    {
      if ( whence == 2 )
      {
        track_frames = mh->track_frames;
        if ( track_frames > 0
          || (mh->rdat.flags & 4) != 0 && (j_mpg123_scan(mh), track_frames = mh->track_frames, track_frames >= 1) )
        {
          down_sample = mh->down_sample;
          if ( down_sample >= 3 )
          {
            if ( down_sample == 3 )
            {
              v13 = 0x4000;
              lay = mh->lay;
              p_lsf = &mh->lsf;
              v19 = 0;
              do
              {
                if ( lay == 1 )
                {
                  v16 = 384;
                }
                else
                {
                  if ( lay == 2 )
                    goto LABEL_29;
                  v17 = *p_lsf == 0;
                  if ( !*p_lsf )
                    v17 = mh->mpeg25 == 0;
                  if ( v17 )
LABEL_29:
                    v16 = 1152;
                  else
                    v16 = 576;
                }
                --track_frames;
                v18 = v13 + v16 * mh->ntom_step;
                v13 = v18 % 0x8000;
                v19 += v18 / 0x8000;
              }
              while ( track_frames );
            }
            else
            {
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... s"
                "hould not be possible!!\n",
                744,
                down_sample);
              v19 = 0;
            }
          }
          else
          {
            v11 = mh->lay;
            if ( v11 == 1 )
            {
              v12 = 384;
            }
            else if ( v11 == 2 )
            {
              v12 = 1152;
            }
            else if ( mh->lsf )
            {
              v12 = 576;
            }
            else
            {
              v12 = 1152;
              if ( mh->mpeg25 )
                v12 = 576;
            }
            v19 = (v12 >> down_sample) * track_frames;
          }
          sampleoff = v19 - sampleoff;
          goto LABEL_44;
        }
        mh->err = 19;
      }
      else
      {
        if ( whence == 1 )
        {
          sampleoff += v7;
          goto LABEL_44;
        }
        mh->err = 20;
      }
      return -1;
    }
LABEL_44:
    if ( sampleoff <= 0 )
      sampleoff = 0;
    j_INT123_frame_set_seek(mh, sampleoff);
    result = do_the_seek(mh);
    if ( result >= 0 )
      return mpg123_tell(mh);
  }
  return result;
}

//----- (00231530) --------------------------------------------------------
int __fastcall mpg123_scan(mpg123_handle *mh)
{
  int *p_to_decode; // r10
  int to_decode; // r5
  int to_ignore; // r11
  off_t num; // r9
  int result; // r0
  int next_frame; // r0
  int lay; // r0
  off_t v9; // r0
  int *p_lay; // r10
  int *p_lsf; // r11
  int v12; // r0
  bool v13; // zf
  int v14; // [sp+4h] [bp-2Ch]

  if ( !mh )
    return -1;
  if ( (mh->rdat.flags & 4) == 0 )
  {
    mh->err = 23;
    return -1;
  }
  p_to_decode = &mh->to_decode;
  to_decode = mh->to_decode;
  if ( !to_decode )
  {
    if ( mh->fresh )
    {
      next_frame = get_next_frame(mh);
      if ( next_frame < 0 )
      {
        v13 = next_frame == -12;
        result = 0;
        if ( !v13 )
          return -1;
        return result;
      }
      to_decode = *p_to_decode;
    }
    else
    {
      to_decode = 0;
    }
  }
  to_ignore = mh->to_ignore;
  num = mh->num;
  if ( mh->rd->seek_frame(mh, 0) < 0 || mh->num )
    return -1;
  lay = mh->lay;
  mh->track_frames = 1;
  v14 = to_ignore;
  if ( lay == 1 )
  {
    v9 = 384;
  }
  else if ( lay == 2 )
  {
    v9 = 1152;
  }
  else if ( mh->lsf )
  {
    v9 = 576;
  }
  else
  {
    v9 = 1152;
    if ( mh->mpeg25 )
      v9 = 576;
  }
  mh->track_samples = v9;
  if ( j_INT123_read_frame(mh) == 1 )
  {
    p_lay = &mh->lay;
    p_lsf = &mh->lsf;
    do
    {
      ++mh->track_frames;
      if ( *p_lay == 1 )
      {
        v12 = 384;
      }
      else
      {
        if ( *p_lay == 2 )
          goto LABEL_27;
        v13 = *p_lsf == 0;
        if ( !*p_lsf )
          v13 = mh->mpeg25 == 0;
        if ( v13 )
LABEL_27:
          v12 = 1152;
        else
          v12 = 576;
      }
      mh->track_samples += v12;
    }
    while ( j_INT123_read_frame(mh) == 1 );
  }
  if ( mh->rd->seek_frame(mh, num) < 0 || mh->num != num )
    return -1;
  mh->to_decode = to_decode;
  mh->to_ignore = v14;
  return 0;
}

//----- (002316B2) --------------------------------------------------------
int __fastcall do_the_seek(mpg123_handle *mh)
{
  off_t ignoreframe; // r5
  off_t firstframe; // r3
  off_t num; // r2
  int result; // r0
  off_t v6; // r6
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  int lay; // r1
  int *p_lsf; // lr
  int v11; // r2
  off_t v12; // r5
  int v13; // r3
  bool v14; // zf
  off_t v15; // r0

  ignoreframe = mh->ignoreframe;
  firstframe = mh->firstframe;
  num = mh->num;
  result = 0;
  v6 = 0;
  mh->buffer.fill = 0;
  if ( ignoreframe > 0 )
    v6 = ignoreframe;
  if ( num >= firstframe || (mh->to_decode = 0, num <= v6) )
  {
    if ( num != v6 || (result = 0, !mh->to_decode) && v6 >= firstframe )
    {
      if ( num == v6 - 1 )
      {
        result = 0;
        mh->to_decode = 0;
      }
      else
      {
        mh->buffer.fill = 0;
        mh->bsbuf = mh->bsspace[1];
        mh->bsnum = 0;
        rawbuffss = mh->rawbuffss;
        mh->bsbufold = mh->bsspace[1];
        rawbuffs = mh->rawbuffs;
        mh->bitreservoir = 0;
        memset(rawbuffs, 0, rawbuffss);
        memset(mh->bsspace, 0, sizeof(mh->bsspace));
        *(_WORD *)&mh->ssave[32] = 0;
        *(_QWORD *)&mh->ssave[16] = 0LL;
        *(_QWORD *)&mh->ssave[24] = 0LL;
        *(_QWORD *)mh->ssave = 0LL;
        *(_QWORD *)&mh->ssave[8] = 0LL;
        memset(mh->hybrid_block, 0, 0x4808u);
        if ( mh->down_sample == 3 )
        {
          if ( ignoreframe < 1 )
          {
            v11 = 0x4000;
          }
          else
          {
            lay = mh->lay;
            p_lsf = &mh->lsf;
            v11 = 0x4000;
            v12 = v6;
            do
            {
              if ( lay == 1 )
              {
                v13 = 384;
              }
              else
              {
                if ( lay == 2 )
                  goto LABEL_15;
                v14 = *p_lsf == 0;
                if ( !*p_lsf )
                  v14 = mh->mpeg25 == 0;
                if ( v14 )
LABEL_15:
                  v13 = 1152;
                else
                  v13 = 576;
              }
              --v12;
              v11 = (signed int)(v11 + v13 * mh->ntom_step) % 0x8000;
            }
            while ( v12 );
          }
          mh->INT123_ntom_val[1] = v11;
          mh->INT123_ntom_val[0] = v11;
        }
        result = mh->rd->seek_frame(mh, v6);
        if ( result >= 0 )
        {
          v15 = mh->num;
          if ( v15 < mh->firstframe )
            mh->to_decode = 0;
          mh->playnum = v15;
          return 0;
        }
      }
    }
  }
  return result;
}

//----- (00231858) --------------------------------------------------------
off_t __fastcall mpg123_feedseek(mpg123_handle *mh, off_t sampleoff, int whence, off_t *input_offset)
{
  int v8; // r5
  int next_frame; // r0
  off_t track_frames; // r0
  unsigned int down_sample; // r3
  int v12; // r1
  unsigned int v13; // r1
  int v14; // r5
  int lay; // r3
  int v16; // r6
  signed int v17; // kr00_4
  int *p_to_decode; // r5
  off_t fileoff; // r1
  off_t ignoreframe; // r0
  off_t num; // r1
  off_t firstframe; // r2
  off_t *p_num; // r5
  off_t v24; // r11
  off_t *p_fileoff; // lr
  int audio_start; // r6
  unsigned __int8 *xing_toc; // r1
  off_t v28; // r0
  bool v29; // cc
  double v30; // d18
  int v31; // r0
  double mean_framesize; // d16
  off_t v33; // r0
  ssize_t v34; // r2
  ssize_t size; // r1
  buffy *first; // r5
  buffy *next; // r10
  int v39; // r1

  v8 = j_mpg123_tell(mh);
  if ( v8 < 0 )
    return v8;
  if ( !input_offset )
  {
    mh->err = 33;
    return -1;
  }
  if ( mh->to_decode || !mh->fresh || (next_frame = get_next_frame(mh), next_frame >= 0) )
  {
    if ( whence )
    {
      if ( whence == 2 )
      {
        track_frames = mh->track_frames;
        if ( track_frames < 1 )
        {
          mh->err = 19;
          return -1;
        }
        down_sample = mh->down_sample;
        if ( down_sample >= 3 )
        {
          if ( down_sample == 3 )
          {
            v14 = 0x4000;
            lay = mh->lay;
            v39 = 0;
            do
            {
              if ( lay == 1 )
              {
                v16 = 384;
              }
              else if ( lay != 2 && (mh->lsf || mh->mpeg25) )
              {
                v16 = 576;
              }
              else
              {
                v16 = 1152;
              }
              --track_frames;
              v17 = v14 + v16 * mh->ntom_step;
              v14 = v17 % 0x8000;
              v39 += v17 / 0x8000;
            }
            while ( track_frames );
          }
          else
          {
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... sho"
              "uld not be possible!!\n",
              744,
              down_sample);
            v39 = 0;
          }
        }
        else
        {
          v12 = mh->lay;
          if ( v12 == 1 )
          {
            v13 = 384;
          }
          else if ( v12 == 2 )
          {
            v13 = 1152;
          }
          else if ( mh->lsf )
          {
            v13 = 576;
          }
          else
          {
            v13 = 1152;
            if ( mh->mpeg25 )
              v13 = 576;
          }
          v39 = (v13 >> down_sample) * track_frames;
        }
        sampleoff = v39 - sampleoff;
      }
      else
      {
        if ( whence != 1 )
        {
          mh->err = 20;
          return -1;
        }
        sampleoff += v8;
      }
    }
    if ( sampleoff <= 0 )
      sampleoff = 0;
    p_to_decode = &mh->to_decode;
    j_INT123_frame_set_seek(mh, sampleoff);
    fileoff = mh->rdat.buffer.fileoff;
    mh->buffer.fill = 0;
    ignoreframe = mh->ignoreframe;
    *input_offset = fileoff + mh->rdat.buffer.size;
    num = mh->num;
    firstframe = mh->firstframe;
    if ( ignoreframe <= 0 )
      ignoreframe = 0;
    if ( num < firstframe )
      *p_to_decode = 0;
    if ( num == ignoreframe )
    {
      firstframe = *p_to_decode;
      if ( *p_to_decode )
        return mpg123_tell(mh);
    }
    if ( num == ignoreframe - 1 )
      return mpg123_tell(mh);
    p_num = &mh->num;
    v24 = mh->ignoreframe;
    p_fileoff = &mh->rdat.buffer.fileoff;
    audio_start = 0;
    if ( v24 <= 0 )
      v24 = 0;
    if ( (mh->p.flags & 0x200) == 0 )
    {
      mh->oldhead = 0;
      mh->firsthead = 0;
LABEL_62:
      v24 = 0;
      goto LABEL_63;
    }
    xing_toc = mh->xing_toc;
    audio_start = mh->audio_start;
    if ( !xing_toc )
      goto LABEL_60;
    v28 = mh->track_frames;
    v29 = v28 < 1;
    if ( v28 >= 1 )
    {
      firstframe = mh->rdat.filelen;
      v29 = firstframe < 1;
    }
    if ( v29 )
    {
LABEL_60:
      mean_framesize = mh->mean_framesize;
      if ( mean_framesize <= 0.0 )
        goto LABEL_62;
      *(_WORD *)&mh->accurate = 256;
      audio_start = (int)(mean_framesize * (double)v24 + (double)audio_start);
    }
    else
    {
      v30 = (double)v28;
      *(_WORD *)&mh->accurate = 256;
      v31 = (int)((double)v24 * 100.0 / (double)v28);
      if ( v31 <= 0 )
        v31 = 0;
      if ( v31 >= 99 )
        v31 = 99;
      audio_start = (int)((double)xing_toc[v31] * 0.00390625 * (double)firstframe);
      v24 = (int)((double)v31 / 100.0 * v30);
    }
LABEL_63:
    v33 = *p_fileoff;
    if ( audio_start < *p_fileoff || (v34 = audio_start - v33, size = mh->rdat.buffer.size, audio_start - v33 >= size) )
    {
      first = mh->rdat.buffer.first;
      if ( first )
      {
        do
        {
          next = first->next;
          free(first->data);
          free(first);
          first = next;
        }
        while ( next );
      }
      *(_QWORD *)&mh->rdat.buffer.first = 0LL;
      *(_QWORD *)&mh->rdat.buffer.size = 0LL;
      mh->rdat.buffer.firstpos = 0;
      *p_fileoff = audio_start;
      p_num = &mh->num;
    }
    else
    {
      audio_start = size + v33;
      mh->rdat.buffer.pos = v34;
    }
    *input_offset = audio_start;
    *p_num = v24 - 1;
    if ( *input_offset >= 0 )
      return mpg123_tell(mh);
    return -1;
  }
  return next_frame;
}

//----- (00231BC0) --------------------------------------------------------
off_t __fastcall INT123_feed_set_pos(mpg123_handle *fr, off_t pos)
{
  off_t fileoff; // r1
  ssize_t v4; // r6
  ssize_t size; // r3
  bufferchain *p_buffer; // r6
  off_t *p_fileoff; // r8
  buffy *first; // r5
  buffy *next; // r4

  fileoff = fr->rdat.buffer.fileoff;
  if ( fileoff > pos || (v4 = pos - fileoff, size = fr->rdat.buffer.size, pos - fileoff >= size) )
  {
    p_buffer = &fr->rdat.buffer;
    p_fileoff = &fr->rdat.buffer.fileoff;
    first = fr->rdat.buffer.first;
    if ( first )
    {
      do
      {
        next = first->next;
        free(first->data);
        free(first);
        first = next;
      }
      while ( next );
    }
    *(_QWORD *)&p_buffer->first = 0LL;
    *(_QWORD *)&p_buffer->size = 0LL;
    p_buffer->firstpos = 0;
    *p_fileoff = pos;
  }
  else
  {
    pos = size + fileoff;
    fr->rdat.buffer.pos = v4;
  }
  return pos;
}

//----- (00231C28) --------------------------------------------------------
off_t __fastcall mpg123_seek_frame(mpg123_handle *mh, off_t offset, int whence)
{
  int v6; // r1
  off_t v7; // r0
  off_t result; // r0
  off_t track_frames; // r0
  int preframes; // r2
  int lay; // r1
  int v12; // r3
  int v13; // r2
  off_t num; // r1
  int v15; // r1

  if ( !mh )
    return -1;
  if ( !mh->to_decode )
  {
    if ( mh->fresh )
    {
      result = get_next_frame(mh);
      if ( result < 0 )
        return result;
    }
  }
  if ( whence )
  {
    if ( whence == 2 )
    {
      track_frames = mh->track_frames;
      if ( track_frames >= 1 )
      {
        offset = track_frames - offset;
        if ( offset >= 0 )
          goto LABEL_8;
        goto LABEL_18;
      }
      v15 = 19;
    }
    else
    {
      if ( whence == 1 )
      {
        offset += mh->num;
        goto LABEL_7;
      }
      v15 = 20;
    }
    mh->err = v15;
    return -1;
  }
LABEL_7:
  if ( offset >= 0 )
  {
LABEL_8:
    v6 = mh->track_frames;
    v7 = v6;
    if ( offset < v6 )
      v7 = offset;
    if ( v6 < 1 )
      v7 = offset;
    goto LABEL_19;
  }
LABEL_18:
  v7 = 0;
LABEL_19:
  preframes = mh->p.preframes;
  lay = mh->lay;
  mh->firstframe = v7;
  v12 = preframes;
  if ( lay == 3 )
    v12 = 1;
  if ( preframes >= 1 )
    v12 = preframes;
  v13 = v12;
  if ( v12 > 2 )
    v13 = 2;
  if ( lay == 3 )
    v13 = v12;
  mh->ignoreframe = v7 - v13;
  result = do_the_seek(mh);
  if ( result >= 0 )
  {
    num = mh->num;
    result = mh->firstframe;
    if ( num >= result )
    {
      if ( !mh->to_decode && !mh->buffer.fill )
        ++num;
      return num;
    }
  }
  return result;
}

//----- (00231D1A) --------------------------------------------------------
int __fastcall mpg123_set_filesize(mpg123_handle *mh, off_t size)
{
  if ( !mh )
    return 0xFFFFFFFF;
  mh->rdat.filelen = size;
  return 0;
}

//----- (00231D30) --------------------------------------------------------
off_t __fastcall mpg123_length(mpg123_handle *mh)
{
  off_t track_samples; // r5
  unsigned int down_sample; // r3
  off_t result; // r0
  int v5; // r0
  int v6; // r2
  off_t track_frames; // r0
  int lay; // r1
  off_t filelen; // r0
  int v10; // r1
  double mean_framesize; // d16
  int lsf; // r2
  double v13; // d16
  int *v14; // r3
  int v15; // r4
  off_t v16; // r1
  signed int v17; // kr00_4
  int v18; // r1
  double v19; // d16
  double v20; // d17
  int *v21; // r1

  if ( !mh )
    return -1;
  if ( !mh->to_decode )
  {
    if ( mh->fresh )
    {
      result = get_next_frame(mh);
      if ( result < 0 )
        return result;
    }
  }
  track_samples = mh->track_samples;
  if ( track_samples <= -1 )
  {
    track_frames = mh->track_frames;
    if ( track_frames >= 1 )
    {
      lay = mh->lay;
      if ( lay == 1 )
      {
        track_samples = 384 * track_frames;
      }
      else if ( lay == 2 )
      {
        track_samples = 1152 * track_frames;
      }
      else if ( mh->lsf )
      {
        track_samples = 576 * track_frames;
      }
      else
      {
        v18 = 1152;
        if ( mh->mpeg25 )
          v18 = 576;
        track_samples = v18 * track_frames;
      }
      goto LABEL_4;
    }
    filelen = mh->rdat.filelen;
    if ( filelen >= 1 )
    {
      v10 = mh->lay;
      mean_framesize = mh->mean_framesize;
      if ( mean_framesize == 0.0 )
      {
        if ( (unsigned int)(v10 - 2) >= 2 )
        {
          if ( v10 != 1 )
          {
            mean_framesize = 1.0;
            goto LABEL_49;
          }
          lsf = mh->lsf;
          v13 = 48000.0;
          v14 = (int *)&tabsel_123[lsf][0][mh->bitrate_index];
        }
        else
        {
          lsf = mh->lsf;
          v13 = 144000.0;
          v14 = (int *)&tabsel_123[lsf - 1][v10 + 2][mh->bitrate_index];
        }
        mean_framesize = v13 * (double)*v14 / (double)(int)(freqs[mh->sampling_frequency] << lsf);
      }
LABEL_49:
      v19 = (double)filelen / mean_framesize;
      if ( v10 == 1 )
      {
        v20 = 384.0;
      }
      else if ( v10 == 2 )
      {
        v20 = 1152.0;
      }
      else if ( mh->lsf )
      {
        v20 = 576.0;
      }
      else
      {
        v21 = &dword_231FB8;
        if ( mh->mpeg25 )
          v21 = &dword_231FBC[1];
        v20 = *(double *)v21;
      }
      track_samples = (int)(v19 * v20);
      goto LABEL_4;
    }
    if ( !filelen )
      return mpg123_tell(mh);
    return -1;
  }
LABEL_4:
  down_sample = mh->down_sample;
  if ( down_sample < 3 )
    return track_samples >> down_sample;
  if ( down_sample != 3 )
  {
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
      724,
      down_sample);
    return 0;
  }
  v5 = mh->lay;
  if ( v5 == 1 )
  {
    v6 = 384;
    if ( track_samples < 1 )
      return 0;
  }
  else if ( v5 == 2 )
  {
    v6 = 1152;
    if ( track_samples < 1 )
      return 0;
  }
  else if ( mh->lsf )
  {
    v6 = 576;
    if ( track_samples < 1 )
      return 0;
  }
  else
  {
    v6 = 1152;
    if ( mh->mpeg25 )
      v6 = 576;
    if ( track_samples < 1 )
      return 0;
  }
  v15 = 0x4000;
  result = 0;
  do
  {
    v16 = track_samples;
    if ( track_samples > v6 )
      v16 = v6;
    track_samples -= v16;
    v17 = v15 + v16 * mh->ntom_step;
    v15 = v17 % 0x8000;
    result += v17 / 0x8000;
  }
  while ( track_samples > 0 );
  return result;
}
// 231FB8: using guessed type int dword_231FB8;
// 231FBC: using guessed type int[2];

//----- (00231FE0) --------------------------------------------------------
double __fastcall INT123_compute_bpf(mpg123_handle *fr)
{
  int lay; // r2
  int lsf; // r1
  double v3; // d16
  int *v4; // r2

  lay = fr->lay;
  if ( (unsigned int)(lay - 2) < 2 )
  {
    lsf = fr->lsf;
    v3 = 144000.0;
    v4 = (int *)&tabsel_123[lsf - 1][lay + 2][fr->bitrate_index];
    return v3 * (double)*v4 / (double)(int)(freqs[fr->sampling_frequency] << lsf);
  }
  if ( lay == 1 )
  {
    lsf = fr->lsf;
    v3 = 48000.0;
    v4 = (int *)&tabsel_123[lsf][0][fr->bitrate_index];
    return v3 * (double)*v4 / (double)(int)(freqs[fr->sampling_frequency] << lsf);
  }
  return 1.0;
}

//----- (002320A0) --------------------------------------------------------
int __fastcall INT123_read_frame(mpg123_handle *fr)
{
  int framesize; // r5
  int halfspeed; // r2
  int *p_halfphase; // r6
  int halfphase; // r3
  int lay; // r1
  unsigned __int8 *bsbuf; // r0
  unsigned __int8 **p_wordpointer; // r0
  int *p_bitindex; // r1
  int v10; // r8
  int v11; // r3
  int v12; // r12
  int v13; // r5
  int v14; // lr
  int v15; // r6
  double v16; // d8
  int v17; // r11
  unsigned __int8 *p_silent_resync; // r6
  unsigned int *p_firsthead; // r5
  unsigned int *p_oldhead; // r9
  reader **p_rd; // r10
  int i; // r0
  reader *v23; // r0
  int v24; // r0
  int v25; // r1
  bool v26; // zf
  int v27; // r1
  bool v28; // zf
  int v29; // r6
  unsigned __int8 *v30; // r2
  unsigned __int8 *v31; // r1
  int v32; // r5
  unsigned __int8 v33; // r8
  int v34; // r0
  unsigned int v35; // r2
  int v36; // r1
  int filelen; // r0
  unsigned int v38; // r2
  double v39; // d11
  unsigned __int8 *v40; // r6
  unsigned __int8 *v41; // r0
  unsigned __int8 *v42; // r0
  double v43; // d16
  int v44; // r1
  unsigned int v45; // r2
  int v46; // r8
  int v47; // r0
  unsigned __int8 *v48; // r0
  float v49; // s22
  int v50; // r8
  unsigned int v51; // r1
  bool v52; // nf
  float *v53; // r1
  int v54; // s0
  float *v55; // r0
  float v56; // s0
  int v57; // r2
  int v58; // r0
  void (*v59)(mpg123_handle *); // r1
  int *v60; // r3
  unsigned __int8 **v61; // lr
  reader_data *v62; // r12
  unsigned __int8 *v63; // r8
  int v64; // r0
  reader *v65; // r0
  void (*forget)(mpg123_handle *); // r1
  int v67; // r6
  unsigned int v68; // r0
  bool v69; // zf
  int v70; // r5
  int v71; // r6
  int v72; // r5
  int (*back_bytes)(mpg123_handle *, off_t); // r8
  int v74; // r0
  bool v75; // zf
  int *v76; // r0
  int v77; // r1
  FILE *v78; // r8
  int v79; // r0
  int v80; // r0
  unsigned int v81; // r2
  bool v82; // zf
  int v83; // r5
  bool v84; // zf
  int v85; // r0
  unsigned int v86; // r5
  bool v87; // zf
  int v88; // r0
  bool v89; // zf
  int v90; // r6
  int v91; // r0
  bool v92; // cc
  int v93; // r5
  bool v94; // zf
  unsigned __int8 *v95; // r5
  int v96; // r0
  int v97; // r5
  int v98; // r1
  int v99; // r1
  int v100; // r2
  void (*v101)(mpg123_handle *); // r1
  int v103; // r1
  off_t mean_frames; // r1
  unsigned __int8 *v105; // r5
  int v106; // r3
  int v107; // r2
  double v108; // d17
  int *v109; // r3
  void (*v110)(mpg123_handle *); // r1
  int error_protection; // r0
  int v112; // [sp+Ch] [bp-154h]
  unsigned int v113; // [sp+10h] [bp-150h]
  unsigned int v114; // [sp+10h] [bp-150h]
  int v115; // [sp+10h] [bp-150h]
  float *peak; // [sp+5Ch] [bp-104h]
  float *gain; // [sp+60h] [bp-100h]
  float *v118; // [sp+64h] [bp-FCh]
  float *v119; // [sp+68h] [bp-F8h]
  off_t *p_track_frames; // [sp+6Ch] [bp-F4h]
  int *p_abr_rate; // [sp+74h] [bp-ECh]
  int *p_halfspeed; // [sp+78h] [bp-E8h]
  unsigned __int8 **p_xing_toc; // [sp+7Ch] [bp-E4h]
  mpg123_handle_struct::$52D0D30F14A3B81696E865A00E9A804B *p_rva; // [sp+80h] [bp-E0h]
  int *v125; // [sp+84h] [bp-DCh]
  unsigned __int8 *v126; // [sp+88h] [bp-D8h]
  int *p_stereo; // [sp+8Ch] [bp-D4h]
  off_t *p_audio_start; // [sp+94h] [bp-CCh]
  reader_data *p_rdat; // [sp+98h] [bp-C8h]
  unsigned __int8 **p_bsbufold; // [sp+9Ch] [bp-C4h]
  int *p_lsf; // [sp+A0h] [bp-C0h]
  unsigned __int8 *id3buf; // [sp+A4h] [bp-BCh]
  unsigned __int8 *v133; // [sp+A8h] [bp-B8h]
  unsigned __int8 *v134; // [sp+ACh] [bp-B4h]
  unsigned __int8 *v135; // [sp+B0h] [bp-B0h]
  unsigned __int8 *v136; // [sp+B4h] [bp-ACh]
  off_t *p_num; // [sp+B8h] [bp-A8h]
  int *p_lay; // [sp+BCh] [bp-A4h]
  mpg123_vbr *p_vbr; // [sp+C0h] [bp-A0h]
  unsigned __int8 **p_bsbuf; // [sp+C4h] [bp-9Ch]
  int *p_bsnum; // [sp+C8h] [bp-98h]
  int *p_metaflags; // [sp+D8h] [bp-88h]
  mpg123_pars_struct *p_p; // [sp+DCh] [bp-84h]
  int *p_flags; // [sp+E0h] [bp-80h]
  int v145; // [sp+E4h] [bp-7Ch]
  int v146; // [sp+E8h] [bp-78h]
  int *v147; // [sp+ECh] [bp-74h]
  int *p_framesize; // [sp+F0h] [bp-70h]
  unsigned int *v149; // [sp+F4h] [bp-6Ch]
  int *p_resync_limit; // [sp+F8h] [bp-68h]
  unsigned int *p_bitreservoir; // [sp+FCh] [bp-64h]
  int *p_header_change; // [sp+100h] [bp-60h]
  unsigned __int8 *v153; // [sp+104h] [bp-5Ch]
  int *v154; // [sp+108h] [bp-58h]
  unsigned int first4bytes; // [sp+10Ch] [bp-54h] BYREF
  double v156; // [sp+110h] [bp-50h] BYREF
  unsigned __int8 v157; // [sp+118h] [bp-48h]
  char v158; // [sp+119h] [bp-47h]

  framesize = fr->framesize;
  halfspeed = fr->p.halfspeed;
  fr->fsizeold = framesize;
  p_halfphase = &fr->halfphase;
  halfphase = fr->halfphase;
  if ( halfspeed )
  {
    if ( halfphase )
    {
      fr->to_decode = 1;
      fr->to_ignore = 1;
      *p_halfphase = halfphase - 1;
      lay = fr->lay;
      fr->bitindex = 0;
      bsbuf = fr->bsbuf;
      fr->wordpointer = bsbuf;
      if ( lay == 3 )
        qmemcpy(bsbuf, fr->ssave, fr->ssize);
      if ( !fr->error_protection )
        return 1;
      p_wordpointer = &fr->wordpointer;
      p_bitindex = &fr->bitindex;
      goto LABEL_7;
    }
    *p_halfphase = halfspeed - 1;
  }
  v145 = framesize;
  v146 = halfphase;
  p_halfspeed = &fr->p.halfspeed;
  p_framesize = &fr->framesize;
  v126 = &fr->bsspace[0][514];
  v147 = &fr->halfphase;
  p_track_frames = &fr->track_frames;
  v16 = 1.0;
  p_rdat = &fr->rdat;
  v17 = 0;
  p_xing_toc = &fr->xing_toc;
  p_abr_rate = &fr->abr_rate;
  v119 = &fr->rva.gain[1];
  v118 = &fr->rva.peak[1];
  v125 = &fr->rva.level[1];
  gain = fr->rva.gain;
  peak = fr->rva.peak;
  p_rva = &fr->rva;
  p_vbr = &fr->vbr;
  p_lsf = &fr->lsf;
  p_stereo = &fr->stereo;
  p_lay = &fr->lay;
  p_audio_start = &fr->audio_start;
  p_num = &fr->num;
  p_bsbufold = &fr->bsbufold;
  p_bsbuf = &fr->bsbuf;
  p_bsnum = &fr->bsnum;
  v136 = &fr->id3buf[4];
  v135 = &fr->id3buf[3];
  v134 = &fr->id3buf[2];
  v133 = &fr->id3buf[1];
  id3buf = fr->id3buf;
  p_metaflags = &fr->metaflags;
  p_bitreservoir = &fr->bitreservoir;
  p_resync_limit = &fr->p.resync_limit;
  p_flags = &fr->rdat.flags;
  p_silent_resync = &fr->silent_resync;
  v153 = &fr->silent_resync;
  p_p = &fr->p;
  v154 = &fr->p.flags;
  p_firsthead = &fr->firsthead;
  p_oldhead = &fr->oldhead;
  v149 = &fr->firsthead;
  p_header_change = &fr->header_change;
  p_rd = &fr->rd;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v65 = *p_rd;
            forget = (*p_rd)->forget;
            if ( forget )
            {
              forget(fr);
              v65 = *p_rd;
            }
            v10 = v65->head_read(fr, &first4bytes);
            if ( v10 < 1 )
              goto LABEL_259;
LABEL_151:
            v68 = *p_oldhead;
LABEL_181:
            *p_header_change = 2;
            if ( v68 )
            {
              if ( v68 == first4bytes )
              {
                v76 = p_header_change;
                v77 = 0;
                goto LABEL_184;
              }
              if ( ((first4bytes ^ v68) & (unsigned int)&stru_180BFC.r_info) == 0
                && ((v68 & 0xC0) == 192) == ((first4bytes & 0xC0) == 192) )
              {
                v76 = p_header_change;
                v77 = 1;
LABEL_184:
                *v76 = v77;
              }
            }
            if ( *p_firsthead )
              goto LABEL_210;
            v81 = first4bytes;
            v82 = (first4bytes & 0xC00) == 3072;
            if ( (first4bytes & 0xC00) != 3072 )
              v82 = (first4bytes & 0xF000) == 61440;
            if ( !v82 && first4bytes >= 0xFFE00000 && (first4bytes & 0x60000) != 0 )
              break;
            if ( first4bytes >> 8 == 4801587 )
            {
              v64 = j_INT123_parse_new_id3(fr, first4bytes);
              v10 = v64;
              if ( v64 < 0 )
                goto LABEL_259;
              if ( v64 )
                *p_metaflags |= 3u;
            }
            else
            {
              if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 2 && !*p_silent_resync )
              {
                fprintf((FILE *)stderr, "Note: Junk at the beginning (0x%08lx)\n", first4bytes);
                v81 = first4bytes;
              }
              if ( v81 != 1380533830 )
              {
                if ( v17 >= 0x10000 )
                {
LABEL_208:
                  p_firsthead = v149;
                  if ( v17 == 0x10000 )
                  {
                    if ( (*(_BYTE *)v154 & 0x20) == 0 )
                      fprintf(
                        (FILE *)stderr,
                        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Giving up searchin"
                        "g valid MPEG header after (over) 64K of junk.\n",
                        537);
                    return 0;
                  }
                }
                else
                {
                  while ( 1 )
                  {
                    v83 = v17;
                    v10 = (*p_rd)->head_shift(fr, &first4bytes);
                    if ( v10 < 1 )
                      goto LABEL_259;
                    v84 = (first4bytes & 0xC00) == 3072;
                    if ( (first4bytes & 0xC00) != 3072 )
                      v84 = (first4bytes & 0xF000) == 61440;
                    if ( !v84 && first4bytes >= 0xFFE00000 && (first4bytes & 0x60000) != 0 )
                    {
                      v85 = decode_header(fr, first4bytes);
                      v10 = v85;
                      if ( v85 )
                        break;
                    }
                    ++v17;
                    if ( v83 >= 0xFFFF )
                      goto LABEL_208;
                  }
                  p_firsthead = v149;
                  if ( v85 < 0 )
                    goto LABEL_259;
                }
                break;
              }
              if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 2 && !*p_silent_resync )
                fwrite("Note: Looks like a RIFF header.\n", 0x20u, 1u, (FILE *)stderr);
              for ( i = (*p_rd)->head_read(fr, &first4bytes); ; i = v23->head_shift(fr, &first4bytes) )
              {
                v10 = i;
                if ( i < 1 )
                  goto LABEL_259;
                v23 = *p_rd;
                if ( first4bytes == 1684108385 )
                  break;
              }
              v10 = v23->head_read(fr, &first4bytes);
              if ( v10 < 1 )
                goto LABEL_259;
              if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 2 && !*p_silent_resync )
                fwrite("Note: Skipped RIFF header!\n", 0x1Bu, 1u, (FILE *)stderr);
            }
            *p_oldhead = 0;
          }
          if ( *p_firsthead || (*(_BYTE *)p_flags & 0xC) == 0 )
            break;
          v69 = (first4bytes & 0xC00) == 3072;
          if ( (first4bytes & 0xC00) != 3072 )
            v69 = (first4bytes & 0xF000) == 61440;
          if ( v69 )
            break;
          if ( first4bytes < 0xFFE00000 )
            break;
          if ( (first4bytes & 0x60000) == 0 )
            break;
          v10 = decode_header(fr, first4bytes);
          if ( !v10 )
            break;
          LODWORD(v156) = 0;
          v70 = (*p_rd)->tell(fr);
          if ( v10 < 0 )
            goto LABEL_259;
          v10 = (*p_rd)->skip_bytes(fr, *p_framesize);
          if ( v10 <= -1 )
          {
            if ( v10 != -1 )
              goto LABEL_259;
            if ( (*(_BYTE *)v154 & 0x20) == 0 )
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: cannot seek!\n",
                561);
LABEL_299:
            v10 = -1;
            goto LABEL_259;
          }
          v71 = v70;
          v72 = (*p_rd)->head_read(fr, (unsigned int *)&v156);
          if ( v72 == -10 )
          {
            v10 = -10;
            goto LABEL_258;
          }
          back_bytes = (*p_rd)->back_bytes;
          v74 = (*p_rd)->tell(fr);
          v10 = back_bytes(fr, v74 - v71);
          if ( v10 <= -1 )
          {
            p_silent_resync = v153;
            if ( v10 != -1 )
              goto LABEL_259;
            if ( (*(_BYTE *)v154 & 0x20) == 0 )
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: cannot seek!\n",
                568);
            goto LABEL_299;
          }
          p_silent_resync = v153;
          if ( !v72 )
          {
            if ( (*(_BYTE *)v154 & 0x20) == 0 )
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] warning: cannot read next header,"
                " a one-frame stream? Duh...\n",
                575);
            break;
          }
          v75 = (LOWORD(v156) & 0xC00) == 3072;
          if ( (LOWORD(v156) & 0xC00) != 3072 )
            v75 = (LOWORD(v156) & 0xF000) == 61440;
          if ( !v75
            && LODWORD(v156) >= 0xFFE00000
            && (LODWORD(v156) & 0x60000) != 0
            && ((LODWORD(v156) ^ first4bytes) & 0xFFFE0C00) == 0 )
          {
            break;
          }
          *p_oldhead = 0;
          v10 = (*p_rd)->back_bytes(fr, 3);
          if ( v10 <= -1 )
          {
            if ( (*(_BYTE *)v154 & 0x20) == 0 )
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: cannot seek!\n",
                588);
            goto LABEL_258;
          }
          p_firsthead = v149;
        }
LABEL_210:
        v86 = first4bytes;
        v87 = (first4bytes & 0xC00) == 3072;
        if ( (first4bytes & 0xC00) != 3072 )
          v87 = (first4bytes & 0xF000) == 61440;
        if ( v87 || first4bytes < 0xFFE00000 || (first4bytes & 0x60000) == 0 )
          break;
        v88 = decode_header(fr, first4bytes);
        v10 = v88;
        if ( v88 < 0 )
          goto LABEL_259;
        if ( !v88 )
        {
          v86 = first4bytes;
          break;
        }
        v115 = (*p_rd)->tell(fr);
        v112 = 31 * *p_bsnum;
        v95 = &fr->bsspace[*p_bsnum][512];
        v96 = (*p_rd)->read_frame_body(fr, v95, *p_framesize);
        v10 = v96;
        if ( v96 < 0 )
          goto LABEL_258;
        v61 = p_bsbuf;
        v60 = p_bsnum;
        v63 = v95;
        *p_bsbufold = *p_bsbuf;
        *p_bsbuf = v95;
        *p_bsnum = (*p_bsnum & 1) == 0;
        if ( *v149 )
          goto LABEL_276;
        *v149 = first4bytes;
        if ( *p_num > -1 )
          goto LABEL_276;
        *p_audio_start = v115 - 4;
        v62 = p_rdat;
        if ( *p_lay != 3 )
          goto LABEL_275;
        v97 = 17;
        v98 = 32;
        if ( *p_lsf )
        {
          v98 = 17;
          v97 = 9;
        }
        if ( *p_stereo == 2 )
          v97 = v98;
        if ( *p_framesize < v97 + 120 )
          goto LABEL_275;
        v99 = 0;
        while ( !v126[128 * v112 + v99] )
        {
          v100 = v99 + 1;
          v92 = v99 + 3 < v97;
          ++v99;
          if ( !v92 )
          {
            if ( v100 + 2 != v97 )
              goto LABEL_275;
            goto LABEL_36;
          }
        }
        if ( v99 + 2 != v97 )
          goto LABEL_275;
LABEL_36:
        v24 = v63[v97];
        if ( v24 == 88 )
        {
          if ( v63[v97 + 1] == 105 )
          {
            v27 = v63[v97 | 2];
            v28 = v27 == 110;
            if ( v27 == 110 )
              v28 = v63[v97 + 3] == 103;
            if ( v28 )
            {
              *p_vbr = MPG123_VBR;
              goto LABEL_50;
            }
          }
LABEL_275:
          j_INT123_do_rva(fr);
          v63 = *p_bsbuf;
LABEL_276:
          fr->wordpointer = v63;
          mean_frames = fr->mean_frames;
          fr->bitindex = 0;
          fr->mean_frames = mean_frames + 1;
          v105 = v153;
          if ( mean_frames != -1 )
          {
            v106 = *p_lay;
            if ( (unsigned int)(*p_lay - 2) < 2 )
            {
              v107 = *p_lsf;
              v108 = 144000.0;
              v109 = (int *)&tabsel_123[*p_lsf - 1][v106 + 2][fr->bitrate_index];
              goto LABEL_281;
            }
            if ( v106 == 1 )
            {
              v107 = *p_lsf;
              v108 = 48000.0;
              v109 = (int *)&tabsel_123[*p_lsf][0][fr->bitrate_index];
LABEL_281:
              v105 = v153;
              v16 = v108 * (double)*v109 / (double)(int)(freqs[fr->sampling_frequency] << v107);
            }
            fr->mean_framesize = (fr->mean_framesize * (double)mean_frames + v16) / (double)(mean_frames + 1);
          }
          ++*p_num;
          if ( *p_halfspeed && *p_lay == 3 )
            qmemcpy(fr->ssave, v63, fr->ssize);
          if ( *v105 )
            --*v105;
          v110 = (*p_rd)->forget;
          if ( v110 )
            v110(fr);
          v10 = 1;
          fr->to_decode = 1;
          error_protection = fr->error_protection;
          fr->to_ignore = 1;
          if ( !error_protection )
            return v10;
          p_wordpointer = &fr->wordpointer;
          p_bitindex = &fr->bitindex;
LABEL_7:
          v10 = 1;
          v11 = *p_bitindex;
          v12 = **p_wordpointer;
          v13 = *p_bitindex + 16;
          v14 = (*p_wordpointer)[1];
          v15 = (*p_wordpointer)[2];
          *p_wordpointer += v13 >> 3;
          *p_bitindex = v13 & 7;
          fr->crc = (unsigned __int16)((v15 | ((v14 | (unsigned int)(v12 << 8)) << 8)) << v11 >> 8);
          return v10;
        }
        if ( v24 != 73 )
          goto LABEL_275;
        v25 = v63[v97 + 1];
        v26 = v25 == 110;
        if ( v25 == 110 )
          v26 = v63[v97 | 2] == 102;
        if ( !v26 || v63[v97 + 3] != 111 )
          goto LABEL_275;
LABEL_50:
        if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 2 )
        {
          fwrite("Note: Xing/Lame/Info header detected\n", 0x25u, 1u, (FILE *)stderr);
          v61 = p_bsbuf;
          v60 = p_bsnum;
          v62 = p_rdat;
          v63 = *p_bsbuf;
        }
        v29 = v97 | 4;
        v30 = v63;
        v31 = &v63[v97 | 4];
        v32 = (v97 | 4) + 4;
        v33 = v31[3];
        if ( (v33 & 1) != 0 )
        {
          v34 = *v154;
          if ( (*v154 & 0x1000) != 0 )
          {
            if ( (v34 & 0x20) == 0 && p_p->verbose >= 3 )
            {
              fwrite("Note: Ignoring Xing frames because of MPG123_IGNORE_STREAMLENGTH\n", 0x41u, 1u, (FILE *)stderr);
LABEL_134:
              v61 = p_bsbuf;
              v60 = p_bsnum;
              v62 = p_rdat;
            }
          }
          else
          {
            v60 = p_bsnum;
            v35 = (v31[5] << 16) | (v30[v32] << 24) | (v31[6] << 8) | v31[7];
            if ( v35 > 0xE38E3 )
              v35 = 0;
            *p_track_frames = v35;
            if ( (v34 & 0x20) == 0 && p_p->verbose >= 3 )
            {
              fprintf((FILE *)stderr, "Note: Xing: %lu frames\n", v35);
              goto LABEL_134;
            }
          }
          v32 = v29 + 8;
        }
        p_silent_resync = v153;
        if ( (v33 & 2) == 0 )
        {
          if ( (v33 & 4) == 0 )
            goto LABEL_65;
LABEL_82:
          v40 = *v61;
          v41 = *p_xing_toc;
          if ( *p_xing_toc || (v41 = (unsigned __int8 *)malloc(0x64u), (*p_xing_toc = v41) != 0) )
            qmemcpy(v41, &v40[v32], 0x64u);
          p_silent_resync = v153;
          v32 += 100;
          v61 = p_bsbuf;
          v60 = p_bsnum;
          if ( (v33 & 8) != 0 )
            goto LABEL_86;
          goto LABEL_90;
        }
        v36 = *v154;
        if ( (*v154 & 0x1000) != 0 )
        {
          if ( (v36 & 0x20) != 0 || p_p->verbose < 3 )
            goto LABEL_81;
          fwrite("Note: Ignoring Xing bytes because of MPG123_IGNORE_STREAMLENGTH\n", 0x40u, 1u, (FILE *)stderr);
LABEL_136:
          v61 = p_bsbuf;
          v60 = p_bsnum;
          goto LABEL_81;
        }
        filelen = v62->filelen;
        v38 = bswap32(*(_DWORD *)&(*v61)[v32]);
        if ( v62->filelen <= 0 )
        {
          v62->filelen = v38;
        }
        else if ( (v36 & 0x20) == 0 && filelen != v38 )
        {
          v39 = fabs(1.0 / (double)filelen * (double)(int)(filelen - v38));
          if ( p_p->verbose >= 3 )
          {
            v114 = v38;
            fprintf(
              (FILE *)stderr,
              "Note: Xing stream size %lu differs by %f%% from determined/given file size!\n",
              v38,
              v39);
            v38 = v114;
            v61 = p_bsbuf;
            v60 = p_bsnum;
          }
          if ( v39 > 1.0 )
          {
            v113 = v38;
            fprintf(
              (FILE *)stderr,
              "Warning: Xing stream size off by more than 1%%, fuzzy seeking may be even more fuzzy than by design!\n");
            v38 = v113;
            v61 = p_bsbuf;
            v60 = p_bsnum;
          }
        }
        if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
        {
          fprintf((FILE *)stderr, "Note: Xing: %lu bytes\n", v38);
          goto LABEL_136;
        }
LABEL_81:
        v32 += 4;
        if ( (v33 & 4) != 0 )
          goto LABEL_82;
LABEL_65:
        if ( (v33 & 8) != 0 )
        {
LABEL_86:
          if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
          {
            fprintf((FILE *)stderr, "Note: Xing: quality = %lu\n", bswap32(*(_DWORD *)&(*v61)[v32]));
            v61 = p_bsbuf;
            v60 = p_bsnum;
          }
          v32 += 4;
        }
LABEL_90:
        v42 = *v61;
        if ( !(*v61)[v32] )
          goto LABEL_130;
        v43 = *(double *)&v42[v32];
        v157 = v42[v32 + 8];
        v158 = 0;
        v156 = v43;
        v44 = *v154;
        if ( (*v154 & 0x20) == 0 && p_p->verbose >= 3 )
        {
          fprintf((FILE *)stderr, "Note: Info: Encoder: %s\n", (const char *)&v156);
          v61 = p_bsbuf;
          v60 = p_bsnum;
          v44 = *v154;
          v42 = *p_bsbuf;
        }
        v45 = v42[v32 + 9];
        v46 = v45 & 0xF;
        if ( (v44 & 0x20) == 0 && p_p->verbose >= 3 )
        {
          fprintf((FILE *)stderr, "Note: Info: rev %u\n", v45 >> 4);
          fprintf((FILE *)stderr, "Note: Info: vbr mode %u\n", v46);
          v61 = p_bsbuf;
          v60 = p_bsnum;
        }
        v47 = 0;
        switch ( v46 )
        {
          case 1:
          case 8:
            break;
          case 2:
          case 9:
            v47 = 2;
            break;
          default:
            v47 = 1;
            break;
        }
        *p_vbr = v47;
        if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
        {
          fprintf((FILE *)stderr, "Note: Info: peak = %f (I won't use this)\n", 0.0);
          v61 = p_bsbuf;
          v60 = p_bsnum;
        }
        v48 = *v61;
        v49 = 0.0;
        v50 = v32 + 15;
        v51 = (*v61)[v32 + 15];
        if ( (v51 & 0x1C) == 0 )
        {
LABEL_108:
          v50 = v32 + 17;
          v51 = v48[v32 + 17];
          if ( (v51 & 0x1C) != 0 )
            goto LABEL_111;
LABEL_115:
          v50 += 2;
          goto LABEL_116;
        }
        if ( (unsigned __int8)(((*v61)[v32 + 15] >> 5) - 1) <= 1u )
        {
          v52 = (v51 & 2) != 0;
          v53 = (float *)sub_2332B0;
          if ( v52 )
            v53 = (float *)&loc_2332B4;
          v49 = *v53 * (float)(v48[v32 + 16] & 0x1F);
          goto LABEL_108;
        }
        v49 = 0.0;
        if ( (v51 & 0x1C) == 0 )
          goto LABEL_115;
LABEL_111:
        if ( (unsigned __int8)((v51 >> 5) - 1) <= 1u )
        {
          v54 = v48[v50 + 1] & 0x1F;
          v55 = (float *)sub_2332B0;
          v56 = (float)(unsigned int)v54;
          if ( (v51 & 2) != 0 )
            v55 = (float *)&loc_2332B4;
          v49 = *v55 * v56;
          goto LABEL_115;
        }
LABEL_116:
        if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
        {
          fprintf((FILE *)stderr, "Note: Info: Radio Gain = %03.1fdB\n", v49);
          fprintf((FILE *)stderr, "Note: Info: Audiophile Gain = %03.1fdB\n", 0.0);
          v61 = p_bsbuf;
          v60 = p_bsnum;
        }
        if ( p_rva->level[0] <= 0 )
        {
          *peak = 0.0;
          *gain = v49;
          p_rva->level[0] = 0;
        }
        if ( *v125 < 1 )
        {
          *v118 = 0.0;
          *v119 = 0.0;
          *v125 = 0;
        }
        if ( *p_vbr == MPG123_ABR )
        {
          v57 = (*v61)[v50 + 1];
          *p_abr_rate = v57;
          if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
          {
            fprintf((FILE *)stderr, "Note: Info: ABR rate = %u\n", v57);
            v61 = p_bsbuf;
            v60 = p_bsnum;
          }
        }
        if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
        {
          p_silent_resync = v153;
          fprintf(
            (FILE *)stderr,
            "Note: Encoder delay = %i; padding = %i\n",
            ((*v61)[v50 + 3] >> 4) | (16 * (*v61)[v50 + 2]),
            (*v61)[v50 + 4] | (((*v61)[v50 + 3] & 0xF) << 8));
          v61 = p_bsbuf;
          v60 = p_bsnum;
        }
LABEL_130:
        v58 = *v60;
        *v61 = &fr->bsspace[*v60][512];
        *v60 = (v58 & 1) == 0;
        v59 = (*p_rd)->forget;
        if ( v59 )
          v59(fr);
        *p_oldhead = 0;
        p_firsthead = v149;
      }
      if ( (v86 & 0xFFFFFF00) != 1229206272 )
        break;
      v10 = j_INT123_parse_new_id3(fr, v86);
      if ( v10 < 0 )
        goto LABEL_259;
      *p_metaflags |= 3u;
      p_firsthead = v149;
    }
    if ( (v86 & 0xFFFFFF00) != 1413564160 )
      break;
    *id3buf = HIBYTE(v86);
    *v133 = BYTE2(v86);
    *v134 = BYTE1(v86);
    *v135 = v86;
    v10 = (*p_rd)->fullread(fr, v136, 124);
    if ( v10 < 0 )
      goto LABEL_259;
    *p_metaflags |= 3u;
    *p_flags |= 2u;
    p_firsthead = v149;
    if ( (*(_BYTE *)v154 & 0x20) == 0 && p_p->verbose >= 3 )
      fwrite("Note: Skipped ID3v1 tag.\n", 0x19u, 1u, (FILE *)stderr);
  }
  v80 = *v154;
  v89 = (*v154 & 0x20) == 0;
  if ( (*v154 & 0x20) == 0 )
    v89 = *p_silent_resync == 0;
  if ( v89 )
  {
    v78 = (FILE *)stderr;
    v79 = (*p_rd)->tell(fr);
    fprintf(v78, "Note: Illegal Audio-MPEG-Header 0x%08lx at offset %li.\n", v86, v79 - 4);
    v80 = *v154;
    if ( (*v154 & 0x20) == 0 )
      goto LABEL_225;
    goto LABEL_226;
  }
  if ( (v80 & 0x20) != 0 )
    goto LABEL_226;
LABEL_225:
  if ( &unk_626D70 != (_UNKNOWN *)(first4bytes >> 8) )
  {
LABEL_226:
    if ( (v80 & 0x80) == 0 )
      goto LABEL_227;
LABEL_265:
    if ( (v80 & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: not attempting to resync...\n",
        712);
    v103 = 27;
LABEL_271:
    fr->err = v103;
    return -1;
  }
  fwrite("Note: Could be a BMP album art.\n", 0x20u, 1u, (FILE *)stderr);
  v80 = *v154;
  if ( (*v154 & 0x80) != 0 )
    goto LABEL_265;
LABEL_227:
  v90 = *p_resync_limit;
  *p_bitreservoir = 0;
  if ( (v80 & 0x20) == 0 && !*v153 )
    fwrite("Note: Trying to resync...\n", 0x1Au, 1u, (FILE *)stderr);
  v91 = 1;
  while ( 2 )
  {
    v92 = v90 < 0;
    v93 = v91;
    if ( v90 >= 0 )
      v92 = v91 < v90;
    if ( !v92 )
    {
      v67 = 0;
LABEL_145:
      if ( (*(_BYTE *)v154 & 0x20) != 0 || *v153 )
      {
        if ( !v67 )
          goto LABEL_268;
      }
      else
      {
        fprintf((FILE *)stderr, "Note: Skipped %li bytes in input.\n", v93);
        if ( !v67 )
        {
LABEL_268:
          if ( (*(_BYTE *)v154 & 0x20) == 0 )
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Giving up resync after %li b"
              "ytes - your stream is not nice... (maybe increasing resync limit could help).\n",
              698,
              v93);
          v103 = 28;
          goto LABEL_271;
        }
      }
      p_firsthead = v149;
      *v149 = 0;
      p_silent_resync = v153;
      goto LABEL_151;
    }
    v10 = (*p_rd)->head_shift(fr, &first4bytes);
    if ( v10 > 0 )
    {
      if ( !*p_oldhead )
      {
        v68 = 0;
        p_silent_resync = v153;
        p_firsthead = v149;
        goto LABEL_181;
      }
      v91 = v93 + 1;
      v94 = (first4bytes & 0xC00) == 3072;
      if ( (first4bytes & 0xC00) != 3072 )
        v94 = (first4bytes & 0xF000) == 61440;
      if ( !v94 && first4bytes >= 0xFFE00000 && (first4bytes & 0x60000) != 0 )
      {
        v67 = 1;
        goto LABEL_145;
      }
      continue;
    }
    break;
  }
  if ( (*(_BYTE *)v154 & 0x20) == 0 )
    fwrite("Note: Hit end of (available) data during resync.\n", 0x31u, 1u, (FILE *)stderr);
LABEL_258:
  p_silent_resync = v153;
LABEL_259:
  v101 = (*p_rd)->forget;
  if ( v101 )
    v101(fr);
  *p_silent_resync = 0;
  if ( !fr->err )
    fr->err = 18;
  *p_framesize = v145;
  *v147 = v146;
  return v10;
}
// 180BFC: using guessed type Elf32_Rel stru_180BFC;
// 2332B0: using guessed type int sub_2332B0();

//----- (00233338) --------------------------------------------------------
int __fastcall mpg123_meta_check(mpg123_handle *mh)
{
  if ( mh )
    return mh->metaflags;
  else
    return 0;
}

//----- (00233346) --------------------------------------------------------
int __fastcall mpg123_id3(mpg123_handle *mh, mpg123_id3v1 **v1, mpg123_id3v2 **v2)
{
  if ( v1 )
    *v1 = 0;
  if ( v2 )
    *v2 = 0;
  if ( !mh )
    return -1;
  if ( LOBYTE(mh->metaflags) << 30 )
  {
    j_INT123_id3_link(mh);
    if ( v1 && (mh->rdat.flags & 2) != 0 )
      *v1 = (mpg123_id3v1 *)mh->id3buf;
    if ( v2 )
      *v2 = &mh->id3v2;
    mh->metaflags = mh->metaflags & 0xFFFFFFFC | 2;
  }
  return 0;
}

//----- (002333BC) --------------------------------------------------------
int __fastcall mpg123_icy(mpg123_handle *mh, unsigned __int8 **icy_meta)
{
  int result; // r0

  if ( !mh )
    return -1;
  if ( icy_meta )
  {
    result = 0;
    *icy_meta = 0;
    if ( (mh->metaflags & 0xC) != 0 )
    {
      *icy_meta = mh->icy.data;
      mh->metaflags = mh->metaflags & 0xFFFFFFF3 | 8;
      return 0;
    }
  }
  else
  {
    mh->err = 33;
    return -1;
  }
  return result;
}

//----- (00233406) --------------------------------------------------------
unsigned __int8 *__fastcall mpg123_icy2utf8(const unsigned __int8 *icy_text)
{
  return INT123_icy2utf8(icy_text, 0);
}

//----- (0023340C) --------------------------------------------------------
mpg123_text_encoding __fastcall mpg123_enc_from_id3(unsigned __int8 id3_enc_byte)
{
  if ( id3_enc_byte <= 3u )
    return dword_23341C[(char)id3_enc_byte];
  else
    return 0;
}
// 23341C: using guessed type int dword_23341C[4];

//----- (0023342C) --------------------------------------------------------
int __fastcall mpg123_store_utf8(
        mpg123_string *sb,
        mpg123_text_encoding enc,
        const unsigned __int8 *source,
        size_t source_size)
{
  int32x4_t v4; // q10
  size_t v7; // r6
  unsigned __int8 *v9; // r0
  int v10; // r1
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // r4
  size_t v13; // r0
  size_t size; // r1
  size_t v15; // r8
  unsigned __int8 *v16; // r0
  unsigned int v17; // r0
  int64x2_t v18; // q9
  unsigned int v19; // r2
  int8x16_t v20; // q8
  const unsigned __int8 *v21; // r3
  unsigned __int32 v22; // t1
  int32x4_t v23; // q8
  unsigned __int32 v24; // r4
  size_t v25; // r1
  const unsigned __int8 *v26; // r0
  unsigned int v27; // t1
  size_t v28; // r1
  size_t v29; // r8
  int v30; // r10
  unsigned __int8 *p; // r0
  _BYTE *v32; // r0
  int v33; // r2
  int v34; // r2

  v7 = source_size;
  switch ( enc )
  {
    case mpg123_text_utf8:
      if ( source_size >= 2 )
      {
        do
        {
          if ( *source )
            break;
          --v7;
          ++source;
        }
        while ( v7 > 1 );
      }
      size = sb->size;
      v15 = v7 + 1;
      if ( v7 == -1 )
      {
        if ( size )
        {
          p = sb->p;
          if ( sb->p )
            free(p);
        }
        v16 = 0;
        sb->p = 0;
        sb->size = 0;
        sb->fill = 0;
      }
      else
      {
        v16 = sb->p;
        if ( size != v15 )
        {
          if ( v16 )
          {
            v16 = (unsigned __int8 *)realloc(v16, v7 + 1);
            if ( !v16 )
              goto LABEL_62;
          }
          else
          {
            v16 = (unsigned __int8 *)malloc(v7 + 1);
            if ( !v16 )
              goto LABEL_62;
          }
          sb->p = v16;
          sb->size = v15;
        }
      }
      qmemcpy(v16, source, v7);
      sb->p[v7] = 0;
      sb->fill = v15;
      return sb->fill != 0;
    case mpg123_text_latin1:
      if ( source_size < 2 )
        goto LABEL_24;
      break;
    case mpg123_text_icy:
    case mpg123_text_cp1252:
      v9 = sb->p;
      if ( sb->p )
        free(v9);
      v10 = 0;
      sb->p = 0;
      sb->size = 0;
      sb->fill = 0;
      if ( !source[v7 - 1] )
      {
        if ( enc == mpg123_text_cp1252 )
          v10 = 1;
        v11 = j_INT123_icy2utf8(source, v10);
        v12 = v11;
        if ( v11 )
        {
          sb->fill = 0;
          v13 = strlen((const char *)v11);
          j_mpg123_add_substring(sb, v12, 0, v13);
          free(v12);
        }
      }
      return sb->fill != 0;
    case mpg123_text_utf16:
    case mpg123_text_utf16bom:
      if ( source_size >= 3 )
      {
        do
        {
          if ( *source )
            break;
          --v7;
          ++source;
        }
        while ( v7 > 2 );
      }
      goto convert_utf16bom;
    case mpg123_text_utf16be:
convert_utf16bom:
      JUMPOUT(0x23AE4C);
    default:
      goto LABEL_62;
  }
  do
  {
    if ( *source )
      goto LABEL_26;
    --v7;
    ++source;
  }
  while ( v7 > 1 );
LABEL_24:
  if ( !v7 )
  {
    v28 = sb->size;
    v29 = 1;
    v24 = 0;
    v7 = 0;
    v30 = 1;
    goto LABEL_42;
  }
  v7 = 1;
LABEL_26:
  if ( v7 >= 4 && (v17 = v7 & 0xFFFFFFFC, (v7 & 0xFFFFFFFC) != 0) )
  {
    v20 = vdupq_n_s32(0);
    v18.n128_u64[0] = 0xFF000000FFLL;
    v18.n128_u64[1] = 0xFF000000FFLL;
    v19 = v7 & 0xFFFFFFFC;
    v20.n128_u32[0] = v7;
    v21 = source;
    do
    {
      v22 = *(_DWORD *)v21;
      v21 += 4;
      v19 -= 4;
      v4.n128_u32[0] = v22;
      v4 = vandq_s64(vmovl_u16(vshr_n_u16((uint16x4_t)vmovl_u8((uint8x8_t)v4.n128_u64[0]).n128_u64[0], 7u)), v18);
      v20 = vaddq_s32(v20, v4);
    }
    while ( v19 );
    v23 = vaddq_s32(v20, vextq_s8(v20, v20, 8u));
    v24 = vaddq_s32(v23, vdupq_lane_s32((int32x2_t)v23.n128_u64[0], 1)).n128_u32[0];
    if ( v7 == v17 )
      goto LABEL_35;
  }
  else
  {
    v17 = 0;
    v24 = v7;
  }
  v25 = v7 - v17;
  v26 = &source[v17];
  do
  {
    v27 = *v26++;
    --v25;
    v24 += v27 >> 7;
  }
  while ( v25 );
LABEL_35:
  v28 = sb->size;
  v29 = v24 + 1;
  if ( v24 == -1 )
  {
    if ( v28 && sb->p )
      free(sb->p);
    v32 = 0;
    v24 = -1;
    sb->p = 0;
    sb->size = 0;
    v29 = 0;
    sb->fill = 0;
    goto LABEL_53;
  }
  v30 = 0;
LABEL_42:
  v32 = sb->p;
  if ( v28 == v29 )
    goto LABEL_52;
  if ( v32 )
  {
    v32 = realloc(v32, v29);
    if ( !v32 )
      goto LABEL_62;
    goto LABEL_51;
  }
  v32 = malloc(v29);
  if ( v32 )
  {
LABEL_51:
    sb->p = v32;
    sb->size = v29;
LABEL_52:
    if ( v30 )
    {
LABEL_58:
      v32[v24] = 0;
      sb->fill = v29;
      return sb->fill != 0;
    }
    do
    {
LABEL_53:
      v33 = *(char *)source;
      if ( v33 < 0 )
      {
        *v32 = (*source >> 6) | 0xC0;
        v34 = 2;
        v32[1] = *source & 0x3F | 0x80;
      }
      else
      {
        *v32 = v33;
        v34 = 1;
      }
      v32 += v34;
      --v7;
      ++source;
    }
    while ( v7 );
    v32 = sb->p;
    goto LABEL_58;
  }
LABEL_62:
  if ( sb->p )
    free(sb->p);
  sb->p = 0;
  sb->size = 0;
  sb->fill = 0;
  return sb->fill != 0;
}
// 2334C2: control flows out of bounds to 23AE4C
// 233540: variable 'v4' is possibly undefined

//----- (0023368C) --------------------------------------------------------
int __fastcall mpg123_set_string(mpg123_string *sb, const unsigned __int8 *stuff)
{
  size_t v4; // r3

  sb->fill = 0;
  v4 = strlen((const char *)stuff);
  return mpg123_add_substring(sb, stuff, 0, v4);
}

//----- (002336AE) --------------------------------------------------------
int __fastcall mpg123_index(mpg123_handle *mh, off_t **offsets, off_t *step, size_t *fill)
{
  int result; // r0
  bool v5; // zf

  if ( !mh )
    return -1;
  if ( !offsets )
    goto LABEL_8;
  v5 = step == 0;
  if ( step )
    v5 = fill == 0;
  if ( v5 )
  {
LABEL_8:
    mh->err = 26;
    return -1;
  }
  else
  {
    result = 0;
    *offsets = 0;
    *step = 0;
    *fill = 0;
  }
  return result;
}

//----- (002336DA) --------------------------------------------------------
int __fastcall mpg123_set_index(mpg123_handle *mh, off_t *offsets, off_t step, size_t fill)
{
  if ( mh )
    mh->err = 38;
  return -1;
}

//----- (002336EC) --------------------------------------------------------
void __fastcall mpg123_delete(mpg123_handle *mh)
{
  reader *rd; // r0
  void (*close)(mpg123_handle *); // r1
  int rawbuffss; // r1
  unsigned __int8 *rawbuffs; // r0
  unsigned __int8 *xing_toc; // r0

  if ( mh )
  {
    rd = mh->rd;
    if ( rd )
    {
      close = rd->close;
      if ( close )
        close(mh);
    }
    mh->rd = 0;
    if ( mh->new_format )
    {
      mh->af.channels = 0;
      mh->af.rate = 0;
      mh->af.encoding = 0;
      mh->new_format = 0;
    }
    mh->bsnum = 0;
    mh->buffer.fill = 0;
    mh->bsbuf = mh->bsspace[1];
    rawbuffss = mh->rawbuffss;
    mh->bsbufold = mh->bsspace[1];
    rawbuffs = mh->rawbuffs;
    mh->bitreservoir = 0;
    memset(rawbuffs, 0, rawbuffss);
    memset(mh->bsspace, 0, sizeof(mh->bsspace));
    *(_WORD *)&mh->ssave[32] = 0;
    *(_QWORD *)&mh->ssave[16] = 0LL;
    *(_QWORD *)&mh->ssave[24] = 0LL;
    *(_QWORD *)mh->ssave = 0LL;
    *(_QWORD *)&mh->ssave[8] = 0LL;
    memset(mh->hybrid_block, 0, 0x4808u);
    frame_fixed_reset(mh);
    xing_toc = mh->xing_toc;
    if ( xing_toc )
    {
      free(xing_toc);
      mh->xing_toc = 0;
    }
    j_INT123_frame_exit(mh);
    j_free(mh);
  }
}

//----- (002337C8) --------------------------------------------------------
const unsigned __int8 *__fastcall mpg123_plain_strerror(int errcode)
{
  const unsigned __int8 *result; // r0
  int v2; // r1

  if ( errcode >= 0 && (unsigned int)errcode <= 0x2A )
    return mpg123_error[errcode];
  v2 = errcode + 12;
  result = "A generic mpg123 error.";
  switch ( v2 )
  {
    case 0:
      result = "Message: I am done with this track.";
      break;
    case 1:
      result = "Message: Prepare for a changed audio format (query the new one)!";
      break;
    case 2:
      result = "Message: Feed me more input data!";
      break;
    case 11:
      return result;
    default:
      result = "I have no idea - an unknown error code!";
      break;
  }
  return result;
}

//----- (00233828) --------------------------------------------------------
int __fastcall mpg123_errcode(mpg123_handle *mh)
{
  if ( mh )
    return mh->err;
  else
    return (int)&byte_9[1];
}

//----- (00233838) --------------------------------------------------------
const unsigned __int8 *__fastcall mpg123_strerror(mpg123_handle *mh)
{
  int err; // r0
  const unsigned __int8 *result; // r0
  int v3; // r1

  if ( mh )
    err = mh->err;
  else
    err = 10;
  if ( err >= 0 && (unsigned int)err <= 0x2A )
    return mpg123_error[err];
  v3 = err + 12;
  result = "A generic mpg123 error.";
  switch ( v3 )
  {
    case 0:
      result = "Message: I am done with this track.";
      break;
    case 1:
      result = "Message: Prepare for a changed audio format (query the new one)!";
      break;
    case 2:
      result = "Message: Feed me more input data!";
      break;
    case 11:
      return result;
    default:
      result = "I have no idea - an unknown error code!";
      break;
  }
  return result;
}

//----- (002338A4) --------------------------------------------------------
unsigned int __fastcall INT123_ntom_val(mpg123_handle *fr, off_t frame)
{
  unsigned int ntom_step; // r2
  int lay; // r3
  int *p_mpeg25; // r12
  int *p_lsf; // lr
  unsigned int result; // r0
  int v7; // r5
  bool v8; // zf

  if ( frame < 1 )
    return 0x4000;
  ntom_step = fr->ntom_step;
  lay = fr->lay;
  p_mpeg25 = &fr->mpeg25;
  p_lsf = &fr->lsf;
  result = 0x4000;
  do
  {
    if ( lay == 1 )
    {
      v7 = 384;
    }
    else
    {
      if ( lay == 2 )
        goto LABEL_5;
      v8 = *p_lsf == 0;
      if ( !*p_lsf )
        v8 = *p_mpeg25 == 0;
      if ( v8 )
LABEL_5:
        v7 = 1152;
      else
        v7 = 576;
    }
    --frame;
    result = (int)(result + ntom_step * v7) % 0x8000;
  }
  while ( frame );
  return result;
}

//----- (00233918) --------------------------------------------------------
int __fastcall INT123_make_conv16to8_table(mpg123_handle *fr)
{
  int encoding; // r6
  unsigned __int8 *v3; // r0
  int v4; // r4
  unsigned __int8 **p_conv16to8; // r6
  int *p_flags; // r9
  double v7; // d8
  int result; // r0
  double v9; // d16
  double v10; // d17
  double v11; // d16
  unsigned int v12; // r5
  char flags; // r1

  encoding = fr->af.encoding;
  if ( !fr->conv16to8_buf )
  {
    v3 = (unsigned __int8 *)malloc(0x2000u);
    fr->conv16to8_buf = v3;
    if ( !v3 )
    {
      flags = fr->p.flags;
      fr->err = 4;
      if ( (flags & 0x20) == 0 )
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/tabinit.c:%i] error: Can't allocate 16 to 8 converter table!\n",
          253);
      return -1;
    }
    fr->conv16to8 = v3 + 4096;
  }
  v4 = -4096;
  switch ( encoding )
  {
    case 1:
      do
      {
        fr->conv16to8[v4] = ((unsigned int)v4 >> 5) + 0x80;
        ++v4;
      }
      while ( v4 != 4096 );
      return 0;
    case 130:
      do
      {
        fr->conv16to8[v4] = (unsigned int)v4 >> 5;
        ++v4;
      }
      while ( v4 != 4096 );
      return 0;
    case 4:
      p_conv16to8 = &fr->conv16to8;
      p_flags = &fr->p.flags;
      v7 = -4096.0;
      do
      {
        v9 = v7 * 255.0 * 8.0;
        v10 = -(v9 * 0.0000305175781);
        v11 = v9 * 0.0000305175781;
        if ( v4 < 0 )
          v11 = v10;
        v12 = ((v4 >> 31) & 0xFFFFFF80) + 255 - (int)(log(v11 + 1.0) * 22.9027838);
        if ( v12 >= 0x100 && (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/tabinit.c:%i] error: Converror %d %d\n",
            269,
            v4,
            v12);
        v7 = v7 + 1.0;
        if ( !v12 )
          LOBYTE(v12) = 2;
        (*p_conv16to8)[v4++] = v12;
      }
      while ( v4 != 4096 );
      return 0;
  }
  result = 0;
  do
    fr->conv16to8[v4++] = 0;
  while ( v4 != 4096 );
  return result;
}

//----- (00233AC8) --------------------------------------------------------
void __fastcall INT123_make_decode_tables(mpg123_handle *fr)
{
  double *p_lastscale; // r1
  int v2; // r3
  double v3; // d17
  double **p_decwin; // lr
  int v5; // r1
  double v6; // d16
  double v7; // d17
  int v8; // r2
  bool v9; // zf
  int v10; // r3
  int *v11; // r12
  double v12; // d17

  p_lastscale = &fr->lastscale;
  v2 = 0;
  if ( fr->lastscale < 0.0 )
    p_lastscale = &fr->p.outscale;
  v3 = *p_lastscale;
  p_decwin = &fr->decwin;
  v5 = 0;
  v6 = v3 * -0.5;
  do
  {
    if ( v5 < 528 )
    {
      v7 = v6 * (double)intwinbase[v2];
      (*p_decwin)[v5] = v7;
      (*p_decwin)[v5 + 16] = v7;
    }
    v8 = v2 % 32;
    v9 = v2 % 64 == 63;
    ++v2;
    if ( v9 )
      v6 = -v6;
    if ( v8 == 31 )
      v5 -= 1023;
    v5 += 32;
  }
  while ( v2 != 256 );
  v10 = 255;
  v11 = &intwinbase[256];
  do
  {
    ++v10;
    if ( v5 < 528 )
    {
      v12 = v6 * (double)*v11;
      (*p_decwin)[v5] = v12;
      (*p_decwin)[v5 + 16] = v12;
    }
    --v11;
    if ( v10 % 32 == 31 )
      v5 -= 1023;
    if ( v10 % 64 == 63 )
      v6 = -v6;
    v5 += 32;
  }
  while ( v10 <= 510 );
}

//----- (00233BE8) --------------------------------------------------------
int __fastcall INT123_synth_1to1_8bit_wrap(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  func_synth v6; // r12
  unsigned __int8 *data; // r11
  size_t fill; // r9
  int v9; // r4
  int result; // r0
  _WORD v12[78]; // [sp+4h] [bp-9Ch] BYREF

  v6 = fr->synths.plain[0][0];
  data = fr->buffer.data;
  fill = fr->buffer.fill;
  fr->buffer.data = (unsigned __int8 *)v12;
  v9 = 0;
  fr->buffer.fill = 0;
  result = ((int (__fastcall *)(double *, int))v6)(bandPtr, channel);
  fr->buffer.data = data;
  do
  {
    data[2 * v9 + fill + channel] = fr->conv16to8[(__int16)v12[2 * v9 + channel] >> 3];
    ++v9;
  }
  while ( v9 != 32 );
  if ( final )
    fill += 64;
  fr->buffer.fill = fill;
  return result;
}

//----- (00233C68) --------------------------------------------------------
int __fastcall INT123_synth_1to1_8bit_wrap_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r12
  int v4; // r5
  size_t fill; // r8
  unsigned __int8 *data; // r11
  int result; // r0
  __int16 v8[78]; // [sp+4h] [bp-9Ch] BYREF

  v3 = fr->synths.plain[0][0];
  v4 = 0;
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  do
  {
    data[fill + v4] = fr->conv16to8[v8[2 * v4] >> 3];
    ++v4;
  }
  while ( v4 != 32 );
  fr->buffer.fill = fill + 32;
  return result;
}
// 233C68: using guessed type __int16 var_9C[78];

//----- (00233CD4) --------------------------------------------------------
int __fastcall INT123_synth_1to1_8bit_wrap_m2s(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r12
  int v4; // r5
  size_t fill; // r8
  unsigned __int8 *data; // r11
  int result; // r0
  unsigned __int8 *v8; // r1
  unsigned __int8 **p_conv16to8; // r3
  size_t *p_fill; // r12
  unsigned __int8 v11; // r2
  unsigned __int8 *v12; // r4
  __int16 v13[78]; // [sp+4h] [bp-9Ch] BYREF

  v3 = fr->synths.plain[0][0];
  v4 = 0;
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v13;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  v8 = &data[fill];
  p_conv16to8 = &fr->conv16to8;
  p_fill = &fr->buffer.fill;
  fr->buffer.data = data;
  do
  {
    v8[2 * v4] = (*p_conv16to8)[v13[2 * v4] >> 3];
    v11 = (*p_conv16to8)[v13[2 * v4] >> 3];
    v12 = &v8[2 * v4++];
    v12[1] = v11;
  }
  while ( v4 != 32 );
  *p_fill = fill + 64;
  return result;
}
// 233CD4: using guessed type __int16 var_9C[78];

//----- (00233D54) --------------------------------------------------------
const unsigned __int8 *__fastcall mpg123_current_decoder(mpg123_handle *mh)
{
  if ( mh )
    return decname[mh->cpu_opts.type];
  else
    return 0;
}

//----- (00233D70) --------------------------------------------------------
const unsigned __int8 **mpg123_decoders()
{
  return mpg123_decoder_list;
}

//----- (00233D7C) --------------------------------------------------------
const unsigned __int8 **mpg123_supported_decoders()
{
  return mpg123_decoder_list;
}

//----- (00233D90) --------------------------------------------------------
int __fastcall decode_header(mpg123_handle *fr, unsigned int newhead)
{
  bool v3; // zf
  int v4; // r2
  int v5; // r6
  int flags; // r8
  unsigned int oldhead; // r3
  unsigned int v8; // r3
  int v9; // r5
  int v11; // r0
  unsigned int *p_oldhead; // r2
  int32x4_t v13; // q8
  int64x2_t v14; // q9
  int *p_flags; // r11
  int64x2_t v16; // q8
  int *p_lsf; // lr
  int v18; // r6
  int freeformat_framesize; // r1
  int lay; // r3
  int *p_freeformat; // r2
  int *p_bitrate_index; // r0
  int v23; // r0
  int v24; // r5
  int v25; // r3
  int v26; // r6
  int v27; // r1
  int v28; // r0
  int framesize; // r2
  reader **p_rd; // r10
  reader *rd; // r0
  int v32; // r1
  int v33; // r6
  bool v34; // zf
  int v35; // r12
  int v36; // r2
  int v37; // r3
  int v38; // r2
  int *p_padding; // [sp+Ch] [bp-24h]
  int v40[8]; // [sp+10h] [bp-20h] BYREF

  v3 = (newhead & 0xC00) == 3072;
  if ( (newhead & 0xC00) != 3072 )
    v3 = (newhead & 0xF000) == 61440;
  if ( v3 || newhead < 0xFFE00000 || (newhead & 0x60000) == 0 )
  {
    if ( (fr->p.flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: tried to decode obviously invalid header\n",
        886);
    return 0;
  }
  v4 = 1;
  v5 = 1;
  if ( (newhead & 0x100000) != 0 )
  {
    v4 = ((newhead >> 19) & 1) == 0;
    v5 = 0;
  }
  fr->mpeg25 = v5;
  flags = fr->p.flags;
  fr->lsf = v4;
  if ( (flags & 0x80) != 0 || (oldhead = fr->oldhead) == 0 || ((oldhead ^ newhead) & 0x180000) != 0 )
  {
    fr->lay = 4 - ((newhead >> 17) & 3);
    v8 = (newhead >> 10) & 3;
    if ( v8 == 3 )
    {
      if ( (flags & 0x20) == 0 )
        fprintf(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Stream error\n",
          911);
      return 0;
    }
    v11 = 6;
    if ( !v5 )
      v11 = 3 * v4;
    fr->sampling_frequency = v11 + v8;
    p_oldhead = &fr->oldhead;
  }
  else
  {
    p_oldhead = &fr->oldhead;
  }
  v13.n128_u64[0] = 0x800000009LL;
  v13.n128_u64[1] = 0x400000006LL;
  fr->error_protection = (newhead & 0x10000) == 0;
  fr->copyright = (newhead >> 3) & 1;
  v14.n128_u64[0] = 0x100000001LL;
  v14.n128_u64[1] = 0x300000003LL;
  p_flags = &fr->p.flags;
  v16 = vandq_s64(vshlq_u32(vnegq_s32(v13), vdupq_n_s32(newhead)), v14);
  fr->original = (newhead >> 2) & 1;
  p_lsf = &fr->lsf;
  fr->emphasis = newhead & 3;
  fr->freeformat = (unsigned __int16)newhead >> 12 == 0;
  v18 = 2;
  if ( v16.n128_u32[2] == 3 )
    v18 = 1;
  fr->stereo = v18;
  fr->bitrate_index = (unsigned __int16)newhead >> 12;
  p_padding = &fr->padding;
  *(int64x2_t *)&fr->padding = v16;
  *p_oldhead = newhead;
  if ( (unsigned __int16)newhead >> 12 )
  {
LABEL_27:
    lay = fr->lay;
    p_freeformat = &fr->freeformat;
    p_bitrate_index = &fr->bitrate_index;
    switch ( lay )
    {
      case 3:
        fr->do_layer = INT123_do_layer3;
        v24 = 17;
        v25 = *p_lsf;
        v26 = 32;
        if ( fr->stereo == 1 )
        {
          v24 = 9;
          v26 = 17;
        }
        if ( v25 )
          v26 = v24;
        fr->ssize = v26;
        if ( fr->error_protection )
          fr->ssize = v26 | 2;
        if ( *p_freeformat )
          goto LABEL_44;
        v27 = freqs[fr->sampling_frequency] << v25;
        v28 = tabsel_123[v25][2][*p_bitrate_index] * (_DWORD)&elf_hash_chain[19526];
        break;
      case 2:
        fr->do_layer = INT123_do_layer2;
        if ( *p_freeformat )
          goto LABEL_44;
        v28 = tabsel_123[*p_lsf][1][*p_bitrate_index] * (_DWORD)&elf_hash_chain[19526];
        v27 = freqs[fr->sampling_frequency];
        break;
      case 1:
        fr->do_layer = INT123_do_layer1;
        if ( !*p_freeformat )
        {
          v23 = 4 * (12000 * tabsel_123[*p_lsf][0][*p_bitrate_index] / freqs[fr->sampling_frequency] + *p_padding) - 4;
LABEL_43:
          fr->framesize = v23;
        }
LABEL_44:
        framesize = fr->framesize;
        if ( framesize <= 3456 )
          return 1;
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Frame size too big: %d\n",
            1020,
            framesize + 4 - *p_padding);
        return 0;
      default:
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Layer type %i not supported in this build!\n",
            1014,
            lay);
        return 0;
    }
    v23 = v28 / v27 + *p_padding - 4;
    goto LABEL_43;
  }
  freeformat_framesize = fr->freeformat_framesize;
  if ( freeformat_framesize > -1 )
  {
    fr->framesize = v16.n128_u32[0] + freeformat_framesize;
    goto LABEL_27;
  }
  if ( (fr->rdat.flags & 0xC) != 0 )
  {
    v9 = fr->rd->head_read(fr, (unsigned int *)v40);
    if ( v9 >= 1 )
    {
      p_rd = &fr->rd;
      rd = fr->rd;
      v32 = 5;
      while ( 1 )
      {
        v33 = v32;
        v9 = rd->head_shift(fr, (unsigned int *)v40);
        if ( v9 < 1 )
          break;
        v34 = (v40[0] & 0xC00) == 3072;
        if ( (v40[0] & 0xC00) != 3072 )
          v34 = (v40[0] & 0xF000) == 61440;
        if ( !v34 && v40[0] >= 0xFFE00000 && (v40[0] & 0x60000) != 0 )
        {
          if ( (v40[0] & 0x100000) != 0 )
          {
            v36 = (((unsigned int)v40[0] >> 19) & 1) == 0;
            v35 = 0;
          }
          else
          {
            v35 = 1;
            v36 = 1;
          }
          v37 = 6;
          if ( !v35 )
            v37 = -v36 & 3;
          if ( v36 == *p_lsf && v35 == fr->mpeg25 && (((unsigned int)v40[0] >> 10) & 3) + v37 == fr->sampling_frequency )
          {
            (*p_rd)->back_bytes(fr, v33);
            fr->framesize = v33 - 4;
            v38 = v33 - *p_padding - 4;
            fr->freeformat_framesize = v38;
            if ( (*(_BYTE *)p_flags & 0x20) == 0 && fr->p.verbose >= 2 )
              fprintf((FILE *)stderr, "Note: free format frame size %li\n", v38);
            goto LABEL_27;
          }
        }
        rd = *p_rd;
        v32 = v33 + 1;
        if ( v33 - 1 >= 0xFFFF )
        {
          rd->back_bytes(fr, v33);
          goto LABEL_69;
        }
      }
    }
    if ( v9 == -10 )
      return -10;
  }
  else
  {
    if ( (flags & 0x20) == 0 )
      fprintf(
        (FILE *)stderr,
        "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Cannot look for freeformat frame s"
        "ize with non-seekable and non-buffered stream!\n",
        827);
LABEL_69:
    v9 = 0;
  }
  fprintf(
    (FILE *)stderr,
    "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/parse.c:%i] error: Encountered free format header, but fa"
    "iled to guess frame size.\n",
    958);
  return v9;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002342D0) --------------------------------------------------------
int __fastcall mpg123_position(
        mpg123_handle *fr,
        off_t no,
        off_t buffsize,
        off_t *current_frame,
        off_t *frames_left,
        double *current_seconds,
        double *seconds_left)
{
  reader *rd; // r0
  double v10; // d8
  int *channels; // r6
  double v12; // d17
  off_t num; // r3
  off_t v14; // r10
  int rate; // r1
  bool v16; // cc
  double v17; // d9
  off_t track_frames; // r1
  off_t v19; // r0
  off_t *p_num; // r4
  int v22; // r0
  double mean_framesize; // d16
  int *p_lsf; // r1
  int lay; // r2
  int v26; // r1
  off_t *v27; // lr
  double v28; // d16
  int *v29; // r2
  off_t v30; // r1
  off_t v31; // r1
  __int64 v32; // r2
  double v33; // d16

  if ( !fr )
    return -1;
  rd = fr->rd;
  if ( !rd )
    return -1;
  v10 = 0.0;
  channels = &mpg123_tpf_bs[fr->lay];
  v12 = (double)*channels;
  num = fr->num;
  v14 = num + no;
  if ( buffsize >= 1 )
  {
    rate = fr->af.rate;
    v16 = rate < 1;
    if ( rate >= 1 )
    {
      channels = (int *)fr->af.channels;
      v16 = (int)channels < 1;
    }
    if ( !v16 )
    {
      v10 = (double)buffsize / (double)rate / (double)(int)channels * 0.5;
      if ( (fr->af.encoding & 0x40) == 0 )
        v10 = (double)buffsize / (double)rate / (double)(int)channels;
    }
  }
  v17 = v12 / (double)(int)(freqs[fr->sampling_frequency] << fr->lsf);
  track_frames = fr->track_frames;
  if ( track_frames && track_frames >= num )
  {
    v19 = track_frames - v14;
    if ( track_frames <= v14 )
      v19 = 0;
    goto LABEL_29;
  }
  if ( fr->rdat.filelen >= 0 )
  {
    p_num = &fr->num;
    v22 = rd->tell(fr);
    mean_framesize = fr->mean_framesize;
    if ( mean_framesize != 0.0 )
      goto LABEL_24;
    p_lsf = &fr->lsf;
    lay = fr->lay;
    if ( (unsigned int)(lay - 2) >= 2 )
    {
      if ( lay != 1 )
      {
        mean_framesize = 1.0;
LABEL_24:
        v30 = *p_num;
        v19 = (int)((double)(fr->rdat.filelen - v22) / mean_framesize);
        if ( v14 != *p_num )
        {
          if ( v14 >= *p_num )
          {
            v31 = v14 - v30;
            v16 = v19 < v31;
            v19 -= v31;
            if ( v16 )
              v19 = 0;
          }
          else
          {
            v19 += v30 - v14;
          }
        }
        goto LABEL_29;
      }
      v26 = *p_lsf;
      v27 = &fr->num;
      v28 = 48000.0;
      v29 = (int *)&tabsel_123[v26][0][fr->bitrate_index];
    }
    else
    {
      v26 = *p_lsf;
      v27 = &fr->num;
      v28 = 144000.0;
      v29 = (int *)&tabsel_123[v26 - 1][lay + 2][fr->bitrate_index];
    }
    p_num = v27;
    mean_framesize = v28 * (double)*v29 / (double)(int)(freqs[fr->sampling_frequency] << v26);
    goto LABEL_24;
  }
  v19 = 0;
LABEL_29:
  v32 = 0LL;
  v33 = v10 + v17 * (double)v19;
  if ( v19 < 0 )
    HIDWORD(v32) = 1;
  if ( v33 < 0.0 )
    LODWORD(v32) = 1;
  if ( v32 )
  {
    v33 = 0.0;
    v19 = 0;
  }
  if ( current_frame )
    *current_frame = v14;
  if ( frames_left )
    *frames_left = v19;
  if ( current_seconds )
    *current_seconds = v17 * (double)v14 - v10;
  if ( seconds_left )
    *seconds_left = v33;
  return 0;
}

//----- (00234538) --------------------------------------------------------
int __fastcall INT123_get_songlen(mpg123_handle *fr, int no)
{
  int lay; // r5
  off_t filelen; // r1
  double v5; // d16
  int lsf; // r1
  double v7; // d17
  int *v8; // r3
  double v9; // d17

  if ( fr )
  {
    if ( no >= 0 )
    {
      lay = fr->lay;
      return (int)((double)mpg123_tpf_bs[lay] / (double)(int)(freqs[fr->sampling_frequency] << fr->lsf) * (double)no);
    }
    if ( fr->rd )
    {
      filelen = fr->rdat.filelen;
      if ( filelen >= 0 )
      {
        v5 = (double)filelen;
        lay = fr->lay;
        if ( (unsigned int)(lay - 2) >= 2 )
        {
          if ( lay != 1 )
          {
            v9 = 1.0;
            goto LABEL_14;
          }
          lsf = fr->lsf;
          v7 = 48000.0;
          v8 = (int *)&tabsel_123[lsf][0][fr->bitrate_index];
        }
        else
        {
          lsf = fr->lsf;
          v7 = 144000.0;
          v8 = (int *)&tabsel_123[lsf - 1][lay + 2][fr->bitrate_index];
        }
        v9 = v7 * (double)*v8 / (double)(int)(freqs[fr->sampling_frequency] << lsf);
LABEL_14:
        no = (int)(v5 / v9);
        return (int)((double)mpg123_tpf_bs[lay] / (double)(int)(freqs[fr->sampling_frequency] << fr->lsf) * (double)no);
      }
    }
  }
  return 0;
}

//----- (0023467C) --------------------------------------------------------
int __fastcall bc_add(bufferchain *bc, const unsigned __int8 *data, ssize_t size)
{
  signed int v4; // r4
  buffy *last; // r0
  __int64 v7; // kr00_8
  unsigned __int8 *v8; // r0
  size_t v9; // r9
  buffy *v10; // r5
  size_t v11; // r0
  unsigned __int8 *v12; // r0
  buffy *v13; // r1
  bufferchain *p_next; // r0
  ssize_t v16; // r1

  v4 = size;
  last = bc->last;
  if ( last )
  {
    v7 = *(_QWORD *)&last->size;
    if ( SHIDWORD(v7) > (int)v7 )
    {
      v8 = last->data;
      v9 = HIDWORD(v7) - v7;
      if ( HIDWORD(v7) - (int)v7 > size )
        v9 = size;
      qmemcpy(&v8[v7], data, v9);
      v4 -= v9;
      bc->last->size += v9;
      bc->size += v9;
      if ( v4 < 1 )
        return 0;
LABEL_8:
      v10 = (buffy *)malloc(0x10u);
      if ( !v10 )
        return -2;
      v11 = v4;
      if ( v4 <= 4096 )
        v11 = 4096;
      v10->realsize = v11;
      v12 = (unsigned __int8 *)malloc(v11);
      v10->data = v12;
      if ( !v12 )
      {
        free(v10);
        return -3;
      }
      v10->next = 0;
      v10->size = v4;
      v13 = bc->last;
      if ( v13 )
      {
        p_next = (bufferchain *)&v13->next;
      }
      else
      {
        if ( bc->first )
          goto LABEL_18;
        p_next = bc;
      }
      p_next->first = v10;
      v12 = v10->data;
LABEL_18:
      v16 = bc->size + v4;
      bc->last = v10;
      bc->size = v16;
      qmemcpy(v12, &data[v9], v4);
      return 0;
    }
  }
  v9 = 0;
  if ( size >= 1 )
    goto LABEL_8;
  return 0;
}

//----- (00234740) --------------------------------------------------------
void __fastcall INT123_open_bad(mpg123_handle *mh)
{
  unsigned __int8 *data; // r0

  data = mh->icy.data;
  if ( data )
    free(data);
  mh->icy.data = 0;
  mh->rdat.flags = 0;
  mh->rd = &bad_reader;
  mh->rdat.buffer.firstpos = 0;
  mh->rdat.buffer.fileoff = 0;
  *(_QWORD *)&mh->rdat.buffer.first = 0LL;
  *(_QWORD *)&mh->rdat.buffer.size = 0LL;
}

//----- (0023478C) --------------------------------------------------------
void __fastcall mpg123_init_string(mpg123_string *sb)
{
  sb->p = 0;
  sb->size = 0;
  sb->fill = 0;
}

//----- (00234796) --------------------------------------------------------
int __fastcall mpg123_grow_string(mpg123_string *sb, size_t a2)
{
  unsigned __int8 *p; // r0
  unsigned __int8 *v5; // r0

  if ( sb->size >= a2 )
    return 1;
  p = sb->p;
  if ( sb->p )
  {
    v5 = (unsigned __int8 *)realloc(p, a2);
    if ( v5 )
    {
LABEL_4:
      sb->p = v5;
      sb->size = a2;
      return 1;
    }
  }
  else
  {
    v5 = (unsigned __int8 *)malloc(a2);
    if ( v5 )
      goto LABEL_4;
  }
  return 0;
}

//----- (002347C6) --------------------------------------------------------
int __fastcall mpg123_resize_string(mpg123_string *sb, size_t a2)
{
  size_t size; // r0
  unsigned __int8 *v5; // r0

  size = sb->size;
  if ( a2 )
  {
    if ( size == a2 )
      return 1;
    if ( sb->p )
    {
      v5 = (unsigned __int8 *)realloc(sb->p, a2);
      if ( v5 )
      {
LABEL_5:
        sb->p = v5;
        sb->size = a2;
        return 1;
      }
    }
    else
    {
      v5 = (unsigned __int8 *)malloc(a2);
      if ( v5 )
        goto LABEL_5;
    }
    return 0;
  }
  else
  {
    if ( size )
    {
      if ( sb->p )
        free(sb->p);
    }
    sb->p = 0;
    sb->size = 0;
    sb->fill = 0;
    return 1;
  }
}

//----- (00234810) --------------------------------------------------------
int __fastcall mpg123_copy_string(mpg123_string *from, mpg123_string *to)
{
  size_t fill; // r6
  unsigned __int8 *p; // r5
  size_t size; // r1
  unsigned __int8 *v6; // r0

  if ( !to )
    return -1;
  if ( !from )
  {
    size = to->size;
    p = 0;
    goto LABEL_10;
  }
  fill = from->fill;
  p = from->p;
  size = to->size;
  if ( !fill )
  {
LABEL_10:
    if ( size )
    {
      if ( to->p )
        free(to->p);
    }
    v6 = 0;
    fill = 0;
    to->p = 0;
    to->size = 0;
    to->fill = 0;
    goto LABEL_14;
  }
  v6 = to->p;
  if ( size == fill )
  {
LABEL_14:
    qmemcpy(v6, p, fill);
    to->fill = fill;
    return 1;
  }
  if ( v6 )
  {
    v6 = (unsigned __int8 *)realloc(v6, fill);
    if ( v6 )
    {
LABEL_7:
      to->p = v6;
      to->size = fill;
      goto LABEL_14;
    }
  }
  else
  {
    v6 = (unsigned __int8 *)malloc(fill);
    if ( v6 )
      goto LABEL_7;
  }
  return 0;
}

//----- (00234884) --------------------------------------------------------
int __fastcall mpg123_add_string(mpg123_string *sb, const unsigned __int8 *stuff)
{
  size_t v4; // r3

  v4 = strlen((const char *)stuff);
  return mpg123_add_substring(sb, stuff, 0, v4);
}

//----- (002348A0) --------------------------------------------------------
int __fastcall mpg123_add_substring(mpg123_string *sb, const unsigned __int8 *stuff, size_t from, size_t count)
{
  size_t fill; // r2
  __int64 v9; // r0
  size_t v10; // r6
  size_t v11; // r6
  __int64 v12; // r0
  unsigned __int8 *p; // r0

  fill = sb->fill;
  if ( fill )
  {
    if ( ~fill >= count )
    {
      v9 = *(_QWORD *)&sb->p;
      v10 = fill + count;
      if ( sb->size >= fill + count )
      {
LABEL_14:
        qmemcpy((void *)(v9 + fill - 1), &stuff[from], count);
        v11 = sb->fill + count;
LABEL_18:
        p = sb->p;
        sb->fill = v11;
        p[v11 - 1] = 0;
        return 1;
      }
      if ( (_DWORD)v9 )
      {
        LODWORD(v9) = realloc((void *)v9, fill + count);
        if ( !(_DWORD)v9 )
          return 0;
        goto LABEL_13;
      }
      LODWORD(v9) = malloc(fill + count);
      if ( (_DWORD)v9 )
      {
LABEL_13:
        fill = sb->fill;
        sb->p = (unsigned __int8 *)v9;
        sb->size = v10;
        goto LABEL_14;
      }
    }
  }
  else
  {
    v11 = count + 1;
    if ( count != -1 )
    {
      v12 = *(_QWORD *)&sb->p;
      if ( sb->size < v11 )
      {
        if ( (_DWORD)v12 )
        {
          LODWORD(v12) = realloc((void *)v12, count + 1);
          if ( !(_DWORD)v12 )
            return 0;
        }
        else
        {
          LODWORD(v12) = malloc(count + 1);
          if ( !(_DWORD)v12 )
            return 0;
        }
        sb->p = (unsigned __int8 *)v12;
        sb->size = v11;
      }
      qmemcpy((void *)v12, &stuff[from], count);
      goto LABEL_18;
    }
  }
  return 0;
}

//----- (0023493C) --------------------------------------------------------
int __fastcall mpg123_set_substring(mpg123_string *sb, const unsigned __int8 *stuff, size_t from, size_t count)
{
  sb->fill = 0;
  return mpg123_add_substring(sb, stuff, from, count);
}

//----- (00234946) --------------------------------------------------------
size_t __fastcall mpg123_strlen(mpg123_string *sb, int utf8)
{
  int32x4_t v2; // q11
  size_t fill; // r3
  unsigned __int8 *p; // r2
  unsigned __int8 v5; // lr
  unsigned int v6; // r3
  size_t result; // r0
  unsigned int v8; // lr
  int64x2_t v9; // q10
  int v10; // r1
  int8x16_t v11; // q8
  unsigned __int32 *v12; // r0
  unsigned int v13; // r5
  unsigned __int32 v14; // t1
  int32x4_t v15; // q8
  unsigned __int8 *v16; // r2
  unsigned int v17; // r1
  char v18; // t1

  fill = sb->fill;
  if ( fill < 2 )
    return 0;
  p = sb->p;
  v5 = *sb->p;
  if ( !v5 )
    return 0;
  v6 = fill - 2;
  if ( v6 )
  {
    while ( !p[v6] )
    {
      if ( !--v6 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v6 = 0;
  }
  if ( !utf8 )
    return v6 + 1;
  result = 0;
  if ( v6 != -1 )
  {
    if ( (v5 & 0xC0) != 128 )
      result = 1;
    if ( v6 )
    {
      if ( v6 >= 4 && (v8 = v6 & 0xFFFFFFFC, (v6 & 0xFFFFFFFC) != 0) )
      {
        v11 = vdupq_n_s32(0);
        v9.n128_u64[0] = 0x100000001LL;
        v9.n128_u64[1] = 0x100000001LL;
        v10 = v8 | 1;
        v11.n128_u32[0] = result;
        v12 = (unsigned __int32 *)(p + 1);
        v13 = v6 & 0xFFFFFFFC;
        do
        {
          v14 = *v12++;
          v13 -= 4;
          v2.n128_u32[0] = v14;
          v2 = vandq_s64(
                 vmovl_u16((uint16x4_t)~vceq_s16(
                                          (int16x4_t)(vmovl_u8((uint8x8_t)v2.n128_u64[0]).n128_u64[0] & 0xC000C000C000C0LL),
                                          (int16x4_t)0x80008000800080LL).n64_u64[0]),
                 v9);
          v11 = vaddq_s32(v11, v2);
        }
        while ( v13 );
        v15 = vaddq_s32(v11, vextq_s8(v11, v11, 8u));
        result = vaddq_s32(v15, vdupq_lane_s32((int32x2_t)v15.n128_u64[0], 1)).n128_u32[0];
        if ( v6 == v8 )
          return result;
      }
      else
      {
        v10 = 1;
      }
      v16 = &p[v10];
      v17 = v6 + 1 - v10;
      do
      {
        v18 = *v16++;
        if ( (v18 & 0xC0) != 128 )
          ++result;
        --v17;
      }
      while ( v17 );
    }
  }
  return result;
}
// 2349C6: variable 'v2' is possibly undefined

//----- (00234A30) --------------------------------------------------------
int __fastcall INT123_synth_1to1(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r8
  double *decwin; // lr
  double *v18; // r2
  double *v19; // r5
  int v20; // r3
  int result; // r0
  double *v22; // r6
  double v23; // d18
  double v24; // d18
  double v25; // d21
  double v26; // d20
  double *v27; // r2
  double v28; // d18
  __int16 v29; // r1
  double *v30; // r1
  _WORD *v31; // r3
  int j; // r6
  double v33; // d18
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v11 += 2;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v18 = &decwin[496 - bo];
  v19 = &decwin[-bo + 16];
  v20 = 0;
  result = 0;
  v22 = v16;
  do
  {
    v23 = *v19 * *v22
        - v19[1] * v22[1]
        + v19[2] * v22[2]
        - v19[3] * v22[3]
        + v19[4] * v22[4]
        - v19[5] * v22[5]
        + v19[6] * v22[6]
        - v19[7] * v22[7]
        + v19[8] * v22[8]
        - v19[9] * v22[9]
        + v19[10] * v22[10]
        - v19[11] * v22[11]
        + v19[12] * v22[12]
        - v19[13] * v22[13]
        + v19[14] * v22[14]
        - v19[15] * v22[15];
    if ( v23 <= 32767.0 )
    {
      if ( v23 >= -32768.0 )
      {
        *(_WORD *)&v11[4 * v20] = (int)v23;
      }
      else
      {
        *(_WORD *)&v11[4 * v20] = 0x8000;
        ++result;
      }
    }
    else
    {
      *(_WORD *)&v11[4 * v20] = 0x7FFF;
      ++result;
    }
    ++v20;
    v22 += 16;
    v19 += 32;
  }
  while ( v20 != 16 );
  v24 = decwin[528 - bo] * v16[256]
      + v18[34] * v16[258]
      + v18[36] * v16[260]
      + v18[38] * v16[262]
      + v18[40] * v16[264]
      + v18[42] * v16[266];
  v25 = v18[44] * v16[268];
  v26 = v18[46];
  v27 = v16 + 240;
  v28 = v24 + v25 + v26 * v16[270];
  if ( v28 <= 32767.0 )
  {
    if ( v28 >= -32768.0 )
    {
      *((_WORD *)v11 + 32) = (int)v28;
      goto LABEL_23;
    }
    v29 = 0x8000;
  }
  else
  {
    v29 = 0x7FFF;
  }
  *((_WORD *)v11 + 32) = v29;
  ++result;
LABEL_23:
  v31 = v11 + 68;
  for ( j = 0; j != -480; j -= 32 )
  {
    v30 = &decwin[bo];
    v33 = -(v30[j + 495] * *v27)
        - v30[j + 494] * v27[1]
        - v30[j + 493] * v27[2]
        - v30[j + 492] * v27[3]
        - v30[j + 491] * v27[4]
        - v30[j + 490] * v27[5]
        - v30[j + 489] * v27[6]
        - v30[j + 488] * v27[7]
        - v30[j + 487] * v27[8]
        - v30[j + 486] * v27[9]
        - v30[j + 485] * v27[10]
        - v30[j + 484] * v27[11]
        - v30[j + 483] * v27[12]
        - v30[j + 482] * v27[13]
        - v30[j + 481] * v27[14]
        - v30[j + 480] * v27[15];
    if ( v33 <= 32767.0 )
    {
      if ( v33 >= -32768.0 )
      {
        *v31 = (int)v33;
      }
      else
      {
        *v31 = 0x8000;
        ++result;
      }
    }
    else
    {
      *v31 = 0x7FFF;
      ++result;
    }
    v27 -= 16;
    v31 += 2;
  }
  if ( final )
    *p_fill += 128;
  return result;
}

//----- (00234ED0) --------------------------------------------------------
int __fastcall INT123_synth_1to1_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r5
  size_t fill; // r9
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v7; // r1
  __int16 v8[76]; // [sp+0h] [bp-98h] BYREF

  v3 = fr->synths.plain[0][0];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  *(_WORD *)&data[fill] = v8[0];
  v7 = &data[fill];
  *((_WORD *)v7 + 1) = v8[2];
  *((_WORD *)v7 + 2) = v8[4];
  *((_WORD *)v7 + 3) = v8[6];
  *((_WORD *)v7 + 4) = v8[8];
  *((_WORD *)v7 + 5) = v8[10];
  *((_WORD *)v7 + 6) = v8[12];
  *((_WORD *)v7 + 7) = v8[14];
  *((_WORD *)v7 + 8) = v8[16];
  *((_WORD *)v7 + 9) = v8[18];
  *((_WORD *)v7 + 10) = v8[20];
  *((_WORD *)v7 + 11) = v8[22];
  *((_WORD *)v7 + 12) = v8[24];
  *((_WORD *)v7 + 13) = v8[26];
  *((_WORD *)v7 + 14) = v8[28];
  *((_WORD *)v7 + 15) = v8[30];
  *((_WORD *)v7 + 16) = v8[32];
  *((_WORD *)v7 + 17) = v8[34];
  *((_WORD *)v7 + 18) = v8[36];
  *((_WORD *)v7 + 19) = v8[38];
  *((_WORD *)v7 + 20) = v8[40];
  *((_WORD *)v7 + 21) = v8[42];
  *((_WORD *)v7 + 22) = v8[44];
  *((_WORD *)v7 + 23) = v8[46];
  *((_WORD *)v7 + 24) = v8[48];
  *((_WORD *)v7 + 25) = v8[50];
  *((_WORD *)v7 + 26) = v8[52];
  *((_WORD *)v7 + 27) = v8[54];
  *((_WORD *)v7 + 28) = v8[56];
  *((_WORD *)v7 + 29) = v8[58];
  *((_WORD *)v7 + 30) = v8[60];
  *((_WORD *)v7 + 31) = v8[62];
  fr->buffer.fill = fill + 64;
  return result;
}

//----- (00234FE0) --------------------------------------------------------
int __fastcall INT123_synth_1to1_m2s(double *bandPtr, mpg123_handle *fr)
{
  mpg123_handle *v2; // r4
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  __int16 v6; // r3
  __int16 v7; // r5
  __int16 v8; // r12
  __int16 v9; // r2
  __int16 v10; // r3
  __int16 v11; // r5
  __int16 v12; // r12
  __int16 v13; // r2
  __int16 v14; // r3
  __int16 v15; // r5
  __int16 v16; // r12
  __int16 v17; // r2
  __int16 v18; // r3
  __int16 v19; // r5
  __int16 v20; // r12
  __int16 v21; // lr
  __int16 v22; // r8
  __int16 v23; // r9
  __int16 v24; // r5
  __int16 v25; // r2
  __int16 v26; // r3

  v2 = fr;
  data = fr->buffer.data;
  result = fr->synths.plain[0][0](bandPtr, 0, fr, 1);
  v5 = &data[v2->buffer.fill];
  v6 = *((_WORD *)v5 - 62);
  LOWORD(data) = *((_WORD *)v5 - 60);
  v7 = *((_WORD *)v5 - 58);
  LOWORD(v2) = *((_WORD *)v5 - 56);
  v8 = *((_WORD *)v5 - 54);
  *((_WORD *)v5 - 63) = *((_WORD *)v5 - 64);
  v9 = *((_WORD *)v5 - 52);
  *((_WORD *)v5 - 61) = v6;
  v10 = *((_WORD *)v5 - 50);
  *((_WORD *)v5 - 59) = (_WORD)data;
  LOWORD(data) = *((_WORD *)v5 - 48);
  *((_WORD *)v5 - 57) = v7;
  v11 = *((_WORD *)v5 - 46);
  *((_WORD *)v5 - 55) = (_WORD)v2;
  LOWORD(v2) = *((_WORD *)v5 - 44);
  *((_WORD *)v5 - 53) = v8;
  v12 = *((_WORD *)v5 - 42);
  *((_WORD *)v5 - 51) = v9;
  v13 = *((_WORD *)v5 - 40);
  *((_WORD *)v5 - 49) = v10;
  v14 = *((_WORD *)v5 - 38);
  *((_WORD *)v5 - 47) = (_WORD)data;
  LOWORD(data) = *((_WORD *)v5 - 36);
  *((_WORD *)v5 - 45) = v11;
  v15 = *((_WORD *)v5 - 34);
  *((_WORD *)v5 - 43) = (_WORD)v2;
  LOWORD(v2) = *((_WORD *)v5 - 32);
  *((_WORD *)v5 - 41) = v12;
  v16 = *((_WORD *)v5 - 30);
  *((_WORD *)v5 - 39) = v13;
  v17 = *((_WORD *)v5 - 28);
  *((_WORD *)v5 - 37) = v14;
  v18 = *((_WORD *)v5 - 26);
  *((_WORD *)v5 - 35) = (_WORD)data;
  LOWORD(data) = *((_WORD *)v5 - 24);
  *((_WORD *)v5 - 33) = v15;
  v19 = *((_WORD *)v5 - 22);
  *((_WORD *)v5 - 31) = (_WORD)v2;
  LOWORD(v2) = *((_WORD *)v5 - 20);
  *((_WORD *)v5 - 29) = v16;
  v20 = *((_WORD *)v5 - 18);
  *((_WORD *)v5 - 27) = v17;
  v21 = *((_WORD *)v5 - 16);
  *((_WORD *)v5 - 25) = v18;
  v22 = *((_WORD *)v5 - 14);
  *((_WORD *)v5 - 23) = (_WORD)data;
  v23 = *((_WORD *)v5 - 12);
  *((_WORD *)v5 - 21) = v19;
  v24 = *((_WORD *)v5 - 10);
  *((_WORD *)v5 - 19) = (_WORD)v2;
  LOWORD(v2) = *((_WORD *)v5 - 8);
  *((_WORD *)v5 - 17) = v20;
  v25 = *((_WORD *)v5 - 6);
  *((_WORD *)v5 - 15) = v21;
  v26 = *((_WORD *)v5 - 4);
  *((_WORD *)v5 - 13) = v22;
  LOWORD(data) = *((_WORD *)v5 - 2);
  *((_WORD *)v5 - 11) = v23;
  *((_WORD *)v5 - 9) = v24;
  *((_WORD *)v5 - 7) = (_WORD)v2;
  *((_WORD *)v5 - 5) = v25;
  *((_WORD *)v5 - 3) = v26;
  *((_WORD *)v5 - 1) = (_WORD)data;
  return result;
}

//----- (00235110) --------------------------------------------------------
int __fastcall INT123_synth_2to1(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r8
  double *decwin; // lr
  double *v18; // r2
  double *v19; // r5
  int v20; // r3
  int result; // r0
  double *v22; // r6
  double v23; // d18
  double v24; // d18
  double v25; // d21
  double v26; // d20
  double *v27; // r2
  double v28; // d18
  __int16 v29; // r1
  double *v30; // r1
  _WORD *v31; // r3
  int j; // r6
  double v33; // d18
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v11 += 2;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v18 = &decwin[464 - bo];
  v19 = &decwin[-bo + 16];
  v20 = 0;
  result = 0;
  v22 = v16;
  do
  {
    v23 = *v19 * *v22
        - v19[1] * v22[1]
        + v19[2] * v22[2]
        - v19[3] * v22[3]
        + v19[4] * v22[4]
        - v19[5] * v22[5]
        + v19[6] * v22[6]
        - v19[7] * v22[7]
        + v19[8] * v22[8]
        - v19[9] * v22[9]
        + v19[10] * v22[10]
        - v19[11] * v22[11]
        + v19[12] * v22[12]
        - v19[13] * v22[13]
        + v19[14] * v22[14]
        - v19[15] * v22[15];
    if ( v23 <= 32767.0 )
    {
      if ( v23 >= -32768.0 )
      {
        *(_WORD *)&v11[4 * v20] = (int)v23;
      }
      else
      {
        *(_WORD *)&v11[4 * v20] = 0x8000;
        ++result;
      }
    }
    else
    {
      *(_WORD *)&v11[4 * v20] = 0x7FFF;
      ++result;
    }
    ++v20;
    v22 += 32;
    v19 += 64;
  }
  while ( v20 != 8 );
  v24 = decwin[528 - bo] * v16[256]
      + v18[66] * v16[258]
      + v18[68] * v16[260]
      + v18[70] * v16[262]
      + v18[72] * v16[264]
      + v18[74] * v16[266];
  v25 = v18[76] * v16[268];
  v26 = v18[78];
  v27 = v16 + 224;
  v28 = v24 + v25 + v26 * v16[270];
  if ( v28 <= 32767.0 )
  {
    if ( v28 >= -32768.0 )
    {
      *((_WORD *)v11 + 16) = (int)v28;
      goto LABEL_23;
    }
    v29 = 0x8000;
  }
  else
  {
    v29 = 0x7FFF;
  }
  *((_WORD *)v11 + 16) = v29;
  ++result;
LABEL_23:
  v31 = v11 + 36;
  for ( j = 0; j != -448; j -= 64 )
  {
    v30 = &decwin[bo];
    v33 = -(v30[j + 463] * *v27)
        - v30[j + 462] * v27[1]
        - v30[j + 461] * v27[2]
        - v30[j + 460] * v27[3]
        - v30[j + 459] * v27[4]
        - v30[j + 458] * v27[5]
        - v30[j + 457] * v27[6]
        - v30[j + 456] * v27[7]
        - v30[j + 455] * v27[8]
        - v30[j + 454] * v27[9]
        - v30[j + 453] * v27[10]
        - v30[j + 452] * v27[11]
        - v30[j + 451] * v27[12]
        - v30[j + 450] * v27[13]
        - v30[j + 449] * v27[14]
        - v30[j + 448] * v27[15];
    if ( v33 <= 32767.0 )
    {
      if ( v33 >= -32768.0 )
      {
        *v31 = (int)v33;
      }
      else
      {
        *v31 = 0x8000;
        ++result;
      }
    }
    else
    {
      *v31 = 0x7FFF;
      ++result;
    }
    v27 -= 32;
    v31 += 2;
  }
  if ( final )
    *p_fill += 64;
  return result;
}

//----- (002355B0) --------------------------------------------------------
int __fastcall INT123_synth_2to1_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r6
  size_t fill; // r10
  unsigned __int8 *data; // r5
  int result; // r0
  unsigned __int8 *v7; // r2
  __int16 v8[44]; // [sp+0h] [bp-58h] BYREF

  v3 = fr->synths.plain[1][0];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = &data[fill];
  *(_WORD *)&data[fill] = v8[0];
  *((_WORD *)v7 + 1) = v8[2];
  *((_WORD *)v7 + 2) = v8[4];
  *((_WORD *)v7 + 3) = v8[6];
  *((_WORD *)v7 + 4) = v8[8];
  *((_WORD *)v7 + 5) = v8[10];
  *((_WORD *)v7 + 6) = v8[12];
  *((_WORD *)v7 + 7) = v8[14];
  *((_WORD *)v7 + 8) = v8[16];
  *((_WORD *)v7 + 9) = v8[18];
  *((_WORD *)v7 + 10) = v8[20];
  *((_WORD *)v7 + 11) = v8[22];
  *((_WORD *)v7 + 12) = v8[24];
  *((_WORD *)v7 + 13) = v8[26];
  *((_WORD *)v7 + 14) = v8[28];
  *((_WORD *)v7 + 15) = v8[30];
  fr->buffer.fill = fill + 32;
  return result;
}

//----- (00235660) --------------------------------------------------------
int __fastcall INT123_synth_2to1_m2s(double *bandPtr, mpg123_handle *fr)
{
  mpg123_handle *v2; // r4
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  __int16 v6; // r3
  __int16 v7; // r5
  __int16 v8; // r12
  __int16 v9; // lr
  __int16 v10; // r8
  __int16 v11; // r5
  __int16 v12; // r9
  __int16 v13; // r2
  __int16 v14; // r3
  __int16 v15; // r5

  v2 = fr;
  data = fr->buffer.data;
  result = fr->synths.plain[1][0](bandPtr, 0, fr, 1);
  v5 = &data[v2->buffer.fill];
  v6 = *((_WORD *)v5 - 30);
  LOWORD(data) = *((_WORD *)v5 - 28);
  v7 = *((_WORD *)v5 - 26);
  LOWORD(v2) = *((_WORD *)v5 - 24);
  v8 = *((_WORD *)v5 - 22);
  *((_WORD *)v5 - 31) = *((_WORD *)v5 - 32);
  v9 = *((_WORD *)v5 - 20);
  *((_WORD *)v5 - 29) = v6;
  v10 = *((_WORD *)v5 - 18);
  *((_WORD *)v5 - 27) = (_WORD)data;
  LOWORD(data) = *((_WORD *)v5 - 16);
  *((_WORD *)v5 - 25) = v7;
  v11 = *((_WORD *)v5 - 14);
  *((_WORD *)v5 - 23) = (_WORD)v2;
  v12 = *((_WORD *)v5 - 12);
  *((_WORD *)v5 - 21) = v8;
  v13 = *((_WORD *)v5 - 10);
  *((_WORD *)v5 - 19) = v9;
  v14 = *((_WORD *)v5 - 8);
  *((_WORD *)v5 - 17) = v10;
  LOWORD(v2) = *((_WORD *)v5 - 6);
  *((_WORD *)v5 - 15) = (_WORD)data;
  LOWORD(data) = *((_WORD *)v5 - 4);
  *((_WORD *)v5 - 13) = v11;
  v15 = *((_WORD *)v5 - 2);
  *((_WORD *)v5 - 11) = v12;
  *((_WORD *)v5 - 9) = v13;
  *((_WORD *)v5 - 7) = v14;
  *((_WORD *)v5 - 5) = (_WORD)v2;
  *((_WORD *)v5 - 3) = (_WORD)data;
  *((_WORD *)v5 - 1) = v15;
  return result;
}

//----- (00235710) --------------------------------------------------------
int __fastcall INT123_synth_4to1(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r8
  double *decwin; // lr
  double *v18; // r2
  double *v19; // r5
  int v20; // r3
  int result; // r0
  double *v22; // r6
  double v23; // d18
  double v24; // d18
  double v25; // d19
  double v26; // d22
  double *v27; // r1
  double *v28; // r2
  double v29; // d18
  __int16 v30; // r1
  double *v31; // r1
  _WORD *v32; // r3
  int j; // r6
  double v34; // d18
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v11 += 2;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v18 = &decwin[400 - bo];
  v19 = &decwin[-bo + 16];
  v20 = 0;
  result = 0;
  v22 = v16;
  do
  {
    v23 = *v19 * *v22
        - v19[1] * v22[1]
        + v19[2] * v22[2]
        - v19[3] * v22[3]
        + v19[4] * v22[4]
        - v19[5] * v22[5]
        + v19[6] * v22[6]
        - v19[7] * v22[7]
        + v19[8] * v22[8]
        - v19[9] * v22[9]
        + v19[10] * v22[10]
        - v19[11] * v22[11]
        + v19[12] * v22[12]
        - v19[13] * v22[13]
        + v19[14] * v22[14]
        - v19[15] * v22[15];
    if ( v23 <= 32767.0 )
    {
      if ( v23 >= -32768.0 )
      {
        *(_WORD *)&v11[4 * v20] = (int)v23;
      }
      else
      {
        *(_WORD *)&v11[4 * v20] = 0x8000;
        ++result;
      }
    }
    else
    {
      *(_WORD *)&v11[4 * v20] = 0x7FFF;
      ++result;
    }
    ++v20;
    v22 += 64;
    v19 += 128;
  }
  while ( v20 != 4 );
  v24 = decwin[528 - bo] * v16[256]
      + v18[130] * v16[258]
      + v18[132] * v16[260]
      + v18[134] * v16[262]
      + v18[136] * v16[264];
  v25 = v18[138] * v16[266];
  v26 = v18[140];
  v27 = v18 + 142;
  v28 = v16 + 192;
  v29 = v24 + v25 + v26 * v16[268] + *v27 * v16[270];
  if ( v29 <= 32767.0 )
  {
    if ( v29 >= -32768.0 )
    {
      *((_WORD *)v11 + 8) = (int)v29;
      goto LABEL_23;
    }
    v30 = 0x8000;
  }
  else
  {
    v30 = 0x7FFF;
  }
  *((_WORD *)v11 + 8) = v30;
  ++result;
LABEL_23:
  v32 = v11 + 20;
  for ( j = 0; j != -384; j -= 128 )
  {
    v31 = &decwin[bo];
    v34 = -(v31[j + 399] * *v28)
        - v31[j + 398] * v28[1]
        - v31[j + 397] * v28[2]
        - v31[j + 396] * v28[3]
        - v31[j + 395] * v28[4]
        - v31[j + 394] * v28[5]
        - v31[j + 393] * v28[6]
        - v31[j + 392] * v28[7]
        - v31[j + 391] * v28[8]
        - v31[j + 390] * v28[9]
        - v31[j + 389] * v28[10]
        - v31[j + 388] * v28[11]
        - v31[j + 387] * v28[12]
        - v31[j + 386] * v28[13]
        - v31[j + 385] * v28[14]
        - v31[j + 384] * v28[15];
    if ( v34 <= 32767.0 )
    {
      if ( v34 >= -32768.0 )
      {
        *v32 = (int)v34;
      }
      else
      {
        *v32 = 0x8000;
        ++result;
      }
    }
    else
    {
      *v32 = 0x7FFF;
      ++result;
    }
    v28 -= 64;
    v32 += 2;
  }
  if ( final )
    *p_fill += 32;
  return result;
}

//----- (00235BCE) --------------------------------------------------------
int __fastcall INT123_synth_4to1_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r12
  size_t fill; // r6
  unsigned __int8 *data; // r5
  int result; // r0
  unsigned __int8 *v7; // r2
  __int16 v8[28]; // [sp+0h] [bp-38h] BYREF

  v3 = fr->synths.plain[2][0];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = &data[fill];
  *(_WORD *)&data[fill] = v8[0];
  *((_WORD *)v7 + 1) = v8[2];
  *((_WORD *)v7 + 2) = v8[4];
  *((_WORD *)v7 + 3) = v8[6];
  *((_WORD *)v7 + 4) = v8[8];
  *((_WORD *)v7 + 5) = v8[10];
  *((_WORD *)v7 + 6) = v8[12];
  *((_WORD *)v7 + 7) = v8[14];
  fr->buffer.fill = fill + 16;
  return result;
}

//----- (00235C4C) --------------------------------------------------------
int __fastcall INT123_synth_4to1_m2s(double *bandPtr, mpg123_handle *fr)
{
  mpg123_handle *v2; // r4
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  __int16 v6; // r3
  __int16 v7; // r5
  __int16 v8; // r12
  __int16 v9; // r2
  __int16 v10; // r3

  v2 = fr;
  data = fr->buffer.data;
  result = fr->synths.plain[2][0](bandPtr, 0, fr, 1);
  v5 = &data[v2->buffer.fill];
  v6 = *((_WORD *)v5 - 14);
  LOWORD(data) = *((_WORD *)v5 - 12);
  v7 = *((_WORD *)v5 - 10);
  LOWORD(v2) = *((_WORD *)v5 - 8);
  v8 = *((_WORD *)v5 - 6);
  *((_WORD *)v5 - 15) = *((_WORD *)v5 - 16);
  v9 = *((_WORD *)v5 - 4);
  *((_WORD *)v5 - 13) = v6;
  v10 = *((_WORD *)v5 - 2);
  *((_WORD *)v5 - 11) = (_WORD)data;
  *((_WORD *)v5 - 9) = v7;
  *((_WORD *)v5 - 7) = (_WORD)v2;
  *((_WORD *)v5 - 5) = v8;
  *((_WORD *)v5 - 3) = v9;
  *((_WORD *)v5 - 1) = v10;
  return result;
}

//----- (00235CB8) --------------------------------------------------------
int __fastcall INT123_synth_ntom_mono(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r10
  size_t fill; // r8
  int result; // r0
  size_t *p_fill; // r1
  size_t v7; // r2
  size_t v8; // r5
  _DWORD v9[262]; // [sp+0h] [bp-418h] BYREF

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  fr->buffer.data = (unsigned __int8 *)v9;
  fr->buffer.fill = 0;
  result = j_INT123_synth_ntom(bandPtr, 0, fr, 1);
  fr->buffer.data = data;
  p_fill = &fr->buffer.fill;
  v7 = fr->buffer.fill;
  if ( v7 >= 4 )
  {
    v8 = 0;
    do
    {
      *(_WORD *)&data[2 * v8 + fill] = v9[v8];
      ++v8;
      v7 = *p_fill;
    }
    while ( v8 < *p_fill >> 2 );
  }
  *p_fill = fill + (v7 >> 1);
  return result;
}

//----- (00235D20) --------------------------------------------------------
int __fastcall INT123_synth_ntom(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // r8
  unsigned __int8 *data; // r6
  int i; // r4
  double v9; // d16
  double *v10; // r0
  unsigned __int8 *v11; // r4
  int bo; // r6
  unsigned int v13; // r10
  double *(*real_buffs)[2]; // r8
  double *v15; // r11
  double *decwin; // r1
  unsigned int ntom_step; // r5
  double *v18; // r2
  signed int v19; // r8
  double *v20; // r9
  int v21; // r11
  int result; // r0
  int v23; // r6
  double v24; // d18
  int v25; // r5
  unsigned int v26; // r6
  unsigned int v27; // r12
  unsigned __int8 *v28; // r6
  double *v29; // r9
  double *v30; // r2
  int v31; // r5
  int v32; // r6
  double v33; // d18
  int v34; // r10
  unsigned int v35; // r1
  double *v36; // r3
  double *v37; // r4
  int v38; // r1
  double *v39; // r10
  unsigned int v40; // r11
  int v41; // r3
  int v42; // r5
  double v43; // d18
  int v44; // r2
  unsigned int v45; // r3
  int v46; // r6
  _WORD *v47; // r5
  unsigned int v48; // r3
  int v49; // r2
  int v50; // [sp+4h] [bp-4Ch]
  outbuffer *p_buffer; // [sp+8h] [bp-48h]
  size_t *p_fill; // [sp+Ch] [bp-44h]
  double *v53; // [sp+10h] [bp-40h]
  int v54; // [sp+14h] [bp-3Ch]
  int v55; // [sp+18h] [bp-38h]
  mpg123_handle *v56; // [sp+1Ch] [bp-34h]
  unsigned int *p_ntom_step; // [sp+2Ch] [bp-24h]
  double *v60; // [sp+30h] [bp-20h]
  int v61; // [sp+30h] [bp-20h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v13 = fr->INT123_ntom_val[1];
    real_buffs = (double *(*)[2])fr->real_buffs[1];
    v11 += 2;
  }
  else
  {
    v13 = fr->INT123_ntom_val[0];
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->INT123_ntom_val[1] = v13;
    fr->bo = bo;
    real_buffs = fr->real_buffs;
  }
  p_buffer = &fr->buffer;
  p_fill = &fr->buffer.fill;
  if ( bo << 31 )
  {
    v15 = (*real_buffs)[0];
    j_INT123_dct64(&(*real_buffs)[1][(bo + 1) & 0xF], &(*real_buffs)[0][bo], bandPtr);
  }
  else
  {
    v15 = (*real_buffs)[1];
    j_INT123_dct64(&(*real_buffs)[0][bo], &v15[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  ntom_step = fr->ntom_step;
  p_ntom_step = &fr->ntom_step;
  v18 = &decwin[-bo + 16];
  v53 = v15 + 240;
  v19 = ntom_step + v13;
  v50 = 528 - bo;
  v56 = fr;
  v20 = v15;
  v21 = 16;
  v55 = 496 - bo;
  result = 0;
  v54 = bo;
  v60 = v20;
  do
  {
    if ( v19 >= 0x8000 )
    {
      v23 = ~v19;
      v24 = *v18 * *v20
          - v18[1] * v20[1]
          + v18[2] * v20[2]
          - v18[3] * v20[3]
          + v18[4] * v20[4]
          - v18[5] * v20[5]
          + v18[6] * v20[6]
          - v18[7] * v20[7]
          + v18[8] * v20[8]
          - v18[9] * v20[9]
          + v18[10] * v20[10]
          - v18[11] * v20[11]
          + v18[12] * v20[12]
          - v18[13] * v20[13]
          + v18[14] * v20[14]
          - v18[15] * v20[15];
      if ( ~v19 <= -65536 )
        v23 = -65536;
      v25 = v19 + 0x8000;
      v26 = v23 + v19 + 0x8000;
      v27 = v26 & 0xFFFF8000;
      v28 = &v11[4 * (v26 >> 15)];
      do
      {
        if ( v24 <= 32767.0 )
        {
          if ( v24 < -32768.0 )
          {
            *(_WORD *)v11 = 0x8000;
            ++result;
          }
          else
          {
            *(_WORD *)v11 = (int)v24;
          }
        }
        else
        {
          *(_WORD *)v11 = 0x7FFF;
          ++result;
        }
        v25 -= 0x8000;
        v11 += 4;
      }
      while ( v25 >= 0x10000 );
      v11 = v28 + 4;
      ntom_step = *p_ntom_step;
      v19 = v19 - 0x8000 - v27;
    }
    v19 += ntom_step;
    v18 += 32;
    --v21;
    v20 += 16;
  }
  while ( v21 );
  v29 = &decwin[v55];
  v30 = v60 + 256;
  if ( v19 < 0x8000 )
  {
    v61 = (int)v11;
    v34 = v54;
  }
  else
  {
    v31 = v19 + 0x8000;
    v32 = ~v19;
    v33 = decwin[v50] * *v30
        + v29[34] * v60[258]
        + v29[36] * v60[260]
        + v29[38] * v60[262]
        + v29[40] * v60[264]
        + v29[42] * v60[266]
        + v29[44] * v60[268]
        + v29[46] * v60[270];
    if ( ~v19 <= -65536 )
      v32 = -65536;
    v34 = v54;
    v35 = v32 + v19 + 0x8000;
    v61 = (int)&v11[4 * (v35 >> 15) + 4];
    do
    {
      if ( v33 <= 32767.0 )
      {
        if ( v33 < -32768.0 )
        {
          *(_WORD *)v11 = 0x8000;
          ++result;
        }
        else
        {
          *(_WORD *)v11 = (int)v33;
        }
      }
      else
      {
        *(_WORD *)v11 = 0x7FFF;
        ++result;
      }
      v31 -= 0x8000;
      v11 += 4;
    }
    while ( v31 >= 0x10000 );
    v19 = v19 - 0x8000 - (v35 & 0xFFFF8000);
  }
  v36 = v53;
  v37 = &v29[2 * v34];
  v38 = 15;
  do
  {
    v39 = v36;
    v40 = *p_ntom_step;
    v41 = *p_ntom_step + v19;
    if ( v41 >= 0x8000 )
    {
      v42 = ~v41;
      v43 = -(*(v37 - 1) * *v39)
          - *(v37 - 2) * *(v30 - 15)
          - *(v37 - 3) * *(v30 - 14)
          - *(v37 - 4) * *(v30 - 13)
          - *(v37 - 5) * *(v30 - 12)
          - *(v37 - 6) * *(v30 - 11)
          - *(v37 - 7) * *(v30 - 10)
          - *(v37 - 8) * *(v30 - 9)
          - *(v37 - 9) * *(v30 - 8)
          - *(v37 - 10) * *(v30 - 7)
          - *(v37 - 11) * *(v30 - 6)
          - *(v37 - 12) * *(v30 - 5)
          - *(v37 - 13) * *(v30 - 4)
          - *(v37 - 14) * *(v30 - 3)
          - *(v37 - 15) * *(v30 - 2)
          - *(v37 - 16) * *(v30 - 1);
      if ( ~v41 <= -65536 )
        v42 = -65536;
      v44 = v41 + 0x8000;
      v45 = v41 + 0x8000 + v42;
      v46 = (v45 >> 14) & 0x3FFFE;
      v47 = (_WORD *)v61;
      v48 = v45 & 0xFFFF8000;
      do
      {
        if ( v43 <= 32767.0 )
        {
          if ( v43 < -32768.0 )
          {
            *v47 = 0x8000;
            ++result;
          }
          else
          {
            *v47 = (int)v43;
          }
        }
        else
        {
          *v47 = 0x7FFF;
          ++result;
        }
        v44 -= 0x8000;
        v47 += 2;
      }
      while ( v44 >= 0x10000 );
      v19 = v19 - 0x8000 + v40 - v48;
      v61 += 2 * v46 + 4;
    }
    else
    {
      v19 += *p_ntom_step;
    }
    v36 = v39 - 16;
    v37 -= 32;
    --v38;
    v30 = v39;
  }
  while ( v38 );
  v56->INT123_ntom_val[channel] = v19;
  if ( final )
  {
    v49 = v61;
    if ( channel )
      v49 = v61 - 2;
    *p_fill = v49 - (unsigned int)p_buffer->data;
  }
  return result;
}

//----- (002362CE) --------------------------------------------------------
int __fastcall INT123_synth_ntom_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r8
  size_t fill; // r5
  int result; // r0
  size_t *p_fill; // r1
  unsigned int v7; // r3
  unsigned __int8 *v8; // r4

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  result = j_INT123_synth_ntom(bandPtr, 0, fr, 1);
  if ( fr->buffer.fill - fill >= 4 )
  {
    p_fill = &fr->buffer.fill;
    v7 = 0;
    do
    {
      v8 = &data[4 * v7++ + fill];
      *((_WORD *)v8 + 1) = *(_WORD *)v8;
    }
    while ( v7 < (*p_fill - fill) >> 2 );
  }
  return result;
}

//----- (00236320) --------------------------------------------------------
int __fastcall INT123_synth_1to1_8bit(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r11
  unsigned __int8 **p_conv16to8; // lr
  int v18; // r2
  double *decwin; // r1
  double *v20; // r6
  double *v21; // r12
  double *v22; // r5
  int result; // r0
  double v24; // d18
  int v25; // r8
  double *v26; // r3
  double v27; // d18
  int v28; // r2
  int v29; // r5
  _BYTE *v30; // r6
  double *v31; // r2
  double v32; // d18
  int v33; // r4
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    ++v11;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  p_conv16to8 = &fr->conv16to8;
  v18 = 0;
  decwin = fr->decwin;
  v20 = v16;
  v22 = &decwin[-bo + 16];
  result = 0;
  do
  {
    v24 = *v22 * *v20
        - v22[1] * v20[1]
        + v22[2] * v20[2]
        - v22[3] * v20[3]
        + v22[4] * v20[4]
        - v22[5] * v20[5]
        + v22[6] * v20[6]
        - v22[7] * v20[7]
        + v22[8] * v20[8]
        - v22[9] * v20[9]
        + v22[10] * v20[10]
        - v22[11] * v20[11]
        + v22[12] * v20[12]
        - v22[13] * v20[13]
        + v22[14] * v20[14]
        - v22[15] * v20[15];
    if ( v24 <= 32767.0 )
    {
      if ( v24 >= -32768.0 )
      {
        v25 = (int)v24;
      }
      else
      {
        ++result;
        LOWORD(v25) = 0x8000;
      }
    }
    else
    {
      ++result;
      LOWORD(v25) = 0x7FFF;
    }
    v20 += 16;
    v22 += 32;
    v11[2 * v18++] = (*p_conv16to8)[(__int16)v25 >> 3];
  }
  while ( v18 != 16 );
  v26 = v16 + 240;
  v21 = &decwin[496 - bo];
  v27 = decwin[528 - bo] * v16[256]
      + v21[34] * v16[258]
      + v21[36] * v16[260]
      + v21[38] * v16[262]
      + v21[40] * v16[264]
      + v21[42] * v16[266]
      + v21[44] * v16[268]
      + v21[46] * v16[270];
  if ( v27 <= 32767.0 )
  {
    if ( v27 >= -32768.0 )
    {
      v28 = (int)v27;
    }
    else
    {
      ++result;
      LOWORD(v28) = 0x8000;
    }
  }
  else
  {
    ++result;
    LOWORD(v28) = 0x7FFF;
  }
  v29 = 0;
  v30 = v11 + 34;
  v11[32] = (*p_conv16to8)[(__int16)v28 >> 3];
  do
  {
    v31 = &decwin[bo];
    v32 = -(v31[v29 + 495] * *v26)
        - v31[v29 + 494] * v26[1]
        - v31[v29 + 493] * v26[2]
        - v31[v29 + 492] * v26[3]
        - v31[v29 + 491] * v26[4]
        - v31[v29 + 490] * v26[5]
        - v31[v29 + 489] * v26[6]
        - v31[v29 + 488] * v26[7]
        - v31[v29 + 487] * v26[8]
        - v31[v29 + 486] * v26[9]
        - v31[v29 + 485] * v26[10]
        - v31[v29 + 484] * v26[11]
        - v31[v29 + 483] * v26[12]
        - v31[v29 + 482] * v26[13]
        - v31[v29 + 481] * v26[14]
        - v31[v29 + 480] * v26[15];
    if ( v32 <= 32767.0 )
    {
      if ( v32 >= -32768.0 )
      {
        v33 = (int)v32;
      }
      else
      {
        ++result;
        LOWORD(v33) = 0x8000;
      }
    }
    else
    {
      ++result;
      LOWORD(v33) = 0x7FFF;
    }
    v29 -= 32;
    v26 -= 16;
    *v30 = (*p_conv16to8)[(__int16)v33 >> 3];
    v30 += 2;
  }
  while ( v29 != -480 );
  if ( final )
    *p_fill += 64;
  return result;
}

//----- (002367D8) --------------------------------------------------------
int __fastcall INT123_synth_1to1_8bit_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r5
  size_t fill; // r9
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v7; // r1
  char v8[64]; // [sp+4h] [bp-5Ch] BYREF

  v3 = fr->synths.plain[0][1];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  data[fill] = v8[0];
  v7 = &data[fill];
  v7[1] = v8[2];
  v7[2] = v8[4];
  v7[3] = v8[6];
  v7[4] = v8[8];
  v7[5] = v8[10];
  v7[6] = v8[12];
  v7[7] = v8[14];
  v7[8] = v8[16];
  v7[9] = v8[18];
  v7[10] = v8[20];
  v7[11] = v8[22];
  v7[12] = v8[24];
  v7[13] = v8[26];
  v7[14] = v8[28];
  v7[15] = v8[30];
  v7[16] = v8[32];
  v7[17] = v8[34];
  v7[18] = v8[36];
  v7[19] = v8[38];
  v7[20] = v8[40];
  v7[21] = v8[42];
  v7[22] = v8[44];
  v7[23] = v8[46];
  v7[24] = v8[48];
  v7[25] = v8[50];
  v7[26] = v8[52];
  v7[27] = v8[54];
  v7[28] = v8[56];
  v7[29] = v8[58];
  v7[30] = v8[60];
  v7[31] = v8[62];
  fr->buffer.fill = fill + 32;
  return result;
}

//----- (0023690C) --------------------------------------------------------
int __fastcall INT123_synth_1to1_8bit_m2s(double *bandPtr, mpg123_handle *fr)
{
  mpg123_handle *v2; // r4
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  unsigned __int8 v6; // r3
  unsigned __int8 v7; // r5
  unsigned __int8 v8; // r12
  unsigned __int8 v9; // r2
  unsigned __int8 v10; // r3
  unsigned __int8 v11; // r5
  unsigned __int8 v12; // r12
  unsigned __int8 v13; // r2
  unsigned __int8 v14; // r3
  unsigned __int8 v15; // r5
  unsigned __int8 v16; // r12
  unsigned __int8 v17; // r2
  unsigned __int8 v18; // r3
  unsigned __int8 v19; // r5
  unsigned __int8 v20; // r12
  unsigned __int8 v21; // lr
  unsigned __int8 v22; // r8
  unsigned __int8 v23; // r9
  unsigned __int8 v24; // r5
  unsigned __int8 v25; // r2
  unsigned __int8 v26; // r3

  v2 = fr;
  data = fr->buffer.data;
  result = fr->synths.plain[0][1](bandPtr, 0, fr, 1);
  v5 = &data[v2->buffer.fill];
  v6 = *(v5 - 62);
  LOBYTE(data) = *(v5 - 60);
  v7 = *(v5 - 58);
  LOBYTE(v2) = *(v5 - 56);
  v8 = *(v5 - 54);
  *(v5 - 63) = *(v5 - 64);
  v9 = *(v5 - 52);
  *(v5 - 61) = v6;
  v10 = *(v5 - 50);
  *(v5 - 59) = (unsigned __int8)data;
  LOBYTE(data) = *(v5 - 48);
  *(v5 - 57) = v7;
  v11 = *(v5 - 46);
  *(v5 - 55) = (unsigned __int8)v2;
  LOBYTE(v2) = *(v5 - 44);
  *(v5 - 53) = v8;
  v12 = *(v5 - 42);
  *(v5 - 51) = v9;
  v13 = *(v5 - 40);
  *(v5 - 49) = v10;
  v14 = *(v5 - 38);
  *(v5 - 47) = (unsigned __int8)data;
  LOBYTE(data) = *(v5 - 36);
  *(v5 - 45) = v11;
  v15 = *(v5 - 34);
  *(v5 - 43) = (unsigned __int8)v2;
  LOBYTE(v2) = *(v5 - 32);
  *(v5 - 41) = v12;
  v16 = *(v5 - 30);
  *(v5 - 39) = v13;
  v17 = *(v5 - 28);
  *(v5 - 37) = v14;
  v18 = *(v5 - 26);
  *(v5 - 35) = (unsigned __int8)data;
  LOBYTE(data) = *(v5 - 24);
  *(v5 - 33) = v15;
  v19 = *(v5 - 22);
  *(v5 - 31) = (unsigned __int8)v2;
  LOBYTE(v2) = *(v5 - 20);
  *(v5 - 29) = v16;
  v20 = *(v5 - 18);
  *(v5 - 27) = v17;
  v21 = *(v5 - 16);
  *(v5 - 25) = v18;
  v22 = *(v5 - 14);
  *(v5 - 23) = (unsigned __int8)data;
  v23 = *(v5 - 12);
  *(v5 - 21) = v19;
  v24 = *(v5 - 10);
  *(v5 - 19) = (unsigned __int8)v2;
  LOBYTE(v2) = *(v5 - 8);
  *(v5 - 17) = v20;
  v25 = *(v5 - 6);
  *(v5 - 15) = v21;
  v26 = *(v5 - 4);
  *(v5 - 13) = v22;
  LOBYTE(data) = *(v5 - 2);
  *(v5 - 11) = v23;
  *(v5 - 9) = v24;
  *(v5 - 7) = (unsigned __int8)v2;
  *(v5 - 5) = v25;
  *(v5 - 3) = v26;
  *(v5 - 1) = (unsigned __int8)data;
  return result;
}

//----- (00236A38) --------------------------------------------------------
int __fastcall INT123_synth_2to1_8bit(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r11
  unsigned __int8 **p_conv16to8; // lr
  int v18; // r2
  double *decwin; // r1
  double *v20; // r6
  double *v21; // r12
  double *v22; // r5
  int result; // r0
  double v24; // d18
  int v25; // r8
  double *v26; // r3
  double v27; // d18
  int v28; // r2
  int v29; // r5
  _BYTE *v30; // r6
  double *v31; // r2
  double v32; // d18
  int v33; // r4
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    ++v11;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  p_conv16to8 = &fr->conv16to8;
  v18 = 0;
  decwin = fr->decwin;
  v20 = v16;
  v22 = &decwin[-bo + 16];
  result = 0;
  do
  {
    v24 = *v22 * *v20
        - v22[1] * v20[1]
        + v22[2] * v20[2]
        - v22[3] * v20[3]
        + v22[4] * v20[4]
        - v22[5] * v20[5]
        + v22[6] * v20[6]
        - v22[7] * v20[7]
        + v22[8] * v20[8]
        - v22[9] * v20[9]
        + v22[10] * v20[10]
        - v22[11] * v20[11]
        + v22[12] * v20[12]
        - v22[13] * v20[13]
        + v22[14] * v20[14]
        - v22[15] * v20[15];
    if ( v24 <= 32767.0 )
    {
      if ( v24 >= -32768.0 )
      {
        v25 = (int)v24;
      }
      else
      {
        ++result;
        LOWORD(v25) = 0x8000;
      }
    }
    else
    {
      ++result;
      LOWORD(v25) = 0x7FFF;
    }
    v20 += 32;
    v22 += 64;
    v11[2 * v18++] = (*p_conv16to8)[(__int16)v25 >> 3];
  }
  while ( v18 != 8 );
  v26 = v16 + 224;
  v21 = &decwin[464 - bo];
  v27 = decwin[528 - bo] * v16[256]
      + v21[66] * v16[258]
      + v21[68] * v16[260]
      + v21[70] * v16[262]
      + v21[72] * v16[264]
      + v21[74] * v16[266]
      + v21[76] * v16[268]
      + v21[78] * v16[270];
  if ( v27 <= 32767.0 )
  {
    if ( v27 >= -32768.0 )
    {
      v28 = (int)v27;
    }
    else
    {
      ++result;
      LOWORD(v28) = 0x8000;
    }
  }
  else
  {
    ++result;
    LOWORD(v28) = 0x7FFF;
  }
  v29 = 0;
  v30 = v11 + 18;
  v11[16] = (*p_conv16to8)[(__int16)v28 >> 3];
  do
  {
    v31 = &decwin[bo];
    v32 = -(v31[v29 + 463] * *v26)
        - v31[v29 + 462] * v26[1]
        - v31[v29 + 461] * v26[2]
        - v31[v29 + 460] * v26[3]
        - v31[v29 + 459] * v26[4]
        - v31[v29 + 458] * v26[5]
        - v31[v29 + 457] * v26[6]
        - v31[v29 + 456] * v26[7]
        - v31[v29 + 455] * v26[8]
        - v31[v29 + 454] * v26[9]
        - v31[v29 + 453] * v26[10]
        - v31[v29 + 452] * v26[11]
        - v31[v29 + 451] * v26[12]
        - v31[v29 + 450] * v26[13]
        - v31[v29 + 449] * v26[14]
        - v31[v29 + 448] * v26[15];
    if ( v32 <= 32767.0 )
    {
      if ( v32 >= -32768.0 )
      {
        v33 = (int)v32;
      }
      else
      {
        ++result;
        LOWORD(v33) = 0x8000;
      }
    }
    else
    {
      ++result;
      LOWORD(v33) = 0x7FFF;
    }
    v29 -= 64;
    v26 -= 32;
    *v30 = (*p_conv16to8)[(__int16)v33 >> 3];
    v30 += 2;
  }
  while ( v29 != -448 );
  if ( final )
    *p_fill += 32;
  return result;
}

//----- (00236EF0) --------------------------------------------------------
int __fastcall INT123_synth_2to1_8bit_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r6
  size_t fill; // r10
  unsigned __int8 *data; // r5
  int result; // r0
  unsigned __int8 *v7; // r2
  char v8[32]; // [sp+4h] [bp-3Ch] BYREF

  v3 = fr->synths.plain[1][1];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = &data[fill];
  data[fill] = v8[0];
  v7[1] = v8[2];
  v7[2] = v8[4];
  v7[3] = v8[6];
  v7[4] = v8[8];
  v7[5] = v8[10];
  v7[6] = v8[12];
  v7[7] = v8[14];
  v7[8] = v8[16];
  v7[9] = v8[18];
  v7[10] = v8[20];
  v7[11] = v8[22];
  v7[12] = v8[24];
  v7[13] = v8[26];
  v7[14] = v8[28];
  v7[15] = v8[30];
  fr->buffer.fill = fill + 16;
  return result;
}

//----- (00236FC4) --------------------------------------------------------
int __fastcall INT123_synth_2to1_8bit_m2s(double *bandPtr, mpg123_handle *fr)
{
  mpg123_handle *v2; // r4
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  unsigned __int8 v6; // r3
  unsigned __int8 v7; // r5
  unsigned __int8 v8; // r12
  unsigned __int8 v9; // lr
  unsigned __int8 v10; // r8
  unsigned __int8 v11; // r5
  unsigned __int8 v12; // r9
  unsigned __int8 v13; // r2
  unsigned __int8 v14; // r3
  unsigned __int8 v15; // r5

  v2 = fr;
  data = fr->buffer.data;
  result = fr->synths.plain[1][1](bandPtr, 0, fr, 1);
  v5 = &data[v2->buffer.fill];
  v6 = *(v5 - 30);
  LOBYTE(data) = *(v5 - 28);
  v7 = *(v5 - 26);
  LOBYTE(v2) = *(v5 - 24);
  v8 = *(v5 - 22);
  *(v5 - 31) = *(v5 - 32);
  v9 = *(v5 - 20);
  *(v5 - 29) = v6;
  v10 = *(v5 - 18);
  *(v5 - 27) = (unsigned __int8)data;
  LOBYTE(data) = *(v5 - 16);
  *(v5 - 25) = v7;
  v11 = *(v5 - 14);
  *(v5 - 23) = (unsigned __int8)v2;
  v12 = *(v5 - 12);
  *(v5 - 21) = v8;
  v13 = *(v5 - 10);
  *(v5 - 19) = v9;
  v14 = *(v5 - 8);
  *(v5 - 17) = v10;
  LOBYTE(v2) = *(v5 - 6);
  *(v5 - 15) = (unsigned __int8)data;
  LOBYTE(data) = *(v5 - 4);
  *(v5 - 13) = v11;
  v15 = *(v5 - 2);
  *(v5 - 11) = v12;
  *(v5 - 9) = v13;
  *(v5 - 7) = v14;
  *(v5 - 5) = (unsigned __int8)v2;
  *(v5 - 3) = (unsigned __int8)data;
  *(v5 - 1) = v15;
  return result;
}

//----- (00237070) --------------------------------------------------------
int __fastcall INT123_synth_4to1_8bit(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r11
  unsigned __int8 **p_conv16to8; // lr
  int v18; // r2
  double *decwin; // r1
  double *v20; // r6
  double *v21; // r12
  double *v22; // r5
  int result; // r0
  double v24; // d18
  int v25; // r8
  double *v26; // r3
  double v27; // d18
  int v28; // r2
  int v29; // r5
  _BYTE *v30; // r6
  double *v31; // r2
  double v32; // d18
  int v33; // r4
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    ++v11;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  p_conv16to8 = &fr->conv16to8;
  v18 = 0;
  decwin = fr->decwin;
  v20 = v16;
  v22 = &decwin[-bo + 16];
  result = 0;
  do
  {
    v24 = *v22 * *v20
        - v22[1] * v20[1]
        + v22[2] * v20[2]
        - v22[3] * v20[3]
        + v22[4] * v20[4]
        - v22[5] * v20[5]
        + v22[6] * v20[6]
        - v22[7] * v20[7]
        + v22[8] * v20[8]
        - v22[9] * v20[9]
        + v22[10] * v20[10]
        - v22[11] * v20[11]
        + v22[12] * v20[12]
        - v22[13] * v20[13]
        + v22[14] * v20[14]
        - v22[15] * v20[15];
    if ( v24 <= 32767.0 )
    {
      if ( v24 >= -32768.0 )
      {
        v25 = (int)v24;
      }
      else
      {
        ++result;
        LOWORD(v25) = 0x8000;
      }
    }
    else
    {
      ++result;
      LOWORD(v25) = 0x7FFF;
    }
    v20 += 64;
    v22 += 128;
    v11[2 * v18++] = (*p_conv16to8)[(__int16)v25 >> 3];
  }
  while ( v18 != 4 );
  v26 = v16 + 192;
  v21 = &decwin[400 - bo];
  v27 = decwin[528 - bo] * v16[256]
      + v21[130] * v16[258]
      + v21[132] * v16[260]
      + v21[134] * v16[262]
      + v21[136] * v16[264]
      + v21[138] * v16[266]
      + v21[140] * v16[268]
      + v21[142] * v16[270];
  if ( v27 <= 32767.0 )
  {
    if ( v27 >= -32768.0 )
    {
      v28 = (int)v27;
    }
    else
    {
      ++result;
      LOWORD(v28) = 0x8000;
    }
  }
  else
  {
    ++result;
    LOWORD(v28) = 0x7FFF;
  }
  v29 = 0;
  v30 = v11 + 10;
  v11[8] = (*p_conv16to8)[(__int16)v28 >> 3];
  do
  {
    v31 = &decwin[bo];
    v32 = -(v31[v29 + 399] * *v26)
        - v31[v29 + 398] * v26[1]
        - v31[v29 + 397] * v26[2]
        - v31[v29 + 396] * v26[3]
        - v31[v29 + 395] * v26[4]
        - v31[v29 + 394] * v26[5]
        - v31[v29 + 393] * v26[6]
        - v31[v29 + 392] * v26[7]
        - v31[v29 + 391] * v26[8]
        - v31[v29 + 390] * v26[9]
        - v31[v29 + 389] * v26[10]
        - v31[v29 + 388] * v26[11]
        - v31[v29 + 387] * v26[12]
        - v31[v29 + 386] * v26[13]
        - v31[v29 + 385] * v26[14]
        - v31[v29 + 384] * v26[15];
    if ( v32 <= 32767.0 )
    {
      if ( v32 >= -32768.0 )
      {
        v33 = (int)v32;
      }
      else
      {
        ++result;
        LOWORD(v33) = 0x8000;
      }
    }
    else
    {
      ++result;
      LOWORD(v33) = 0x7FFF;
    }
    v29 -= 128;
    v26 -= 64;
    *v30 = (*p_conv16to8)[(__int16)v33 >> 3];
    v30 += 2;
  }
  while ( v29 != -384 );
  if ( final )
    *p_fill += 16;
  return result;
}

//----- (00237548) --------------------------------------------------------
int __fastcall INT123_synth_4to1_8bit_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r12
  size_t fill; // r6
  unsigned __int8 *data; // r5
  int result; // r0
  unsigned __int8 *v7; // r2
  char v8[16]; // [sp+4h] [bp-2Ch] BYREF

  v3 = fr->synths.plain[2][1];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = &data[fill];
  data[fill] = v8[0];
  v7[1] = v8[2];
  v7[2] = v8[4];
  v7[3] = v8[6];
  v7[4] = v8[8];
  v7[5] = v8[10];
  v7[6] = v8[12];
  v7[7] = v8[14];
  fr->buffer.fill = fill + 8;
  return result;
}

//----- (002375EC) --------------------------------------------------------
int __fastcall INT123_synth_4to1_8bit_m2s(double *bandPtr, mpg123_handle *fr)
{
  mpg123_handle *v2; // r4
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  unsigned __int8 v6; // r3
  unsigned __int8 v7; // r5
  unsigned __int8 v8; // r12
  unsigned __int8 v9; // r2
  unsigned __int8 v10; // r3

  v2 = fr;
  data = fr->buffer.data;
  result = fr->synths.plain[2][1](bandPtr, 0, fr, 1);
  v5 = &data[v2->buffer.fill];
  v6 = *(v5 - 14);
  LOBYTE(data) = *(v5 - 12);
  v7 = *(v5 - 10);
  LOBYTE(v2) = *(v5 - 8);
  v8 = *(v5 - 6);
  *(v5 - 15) = *(v5 - 16);
  v9 = *(v5 - 4);
  *(v5 - 13) = v6;
  v10 = *(v5 - 2);
  *(v5 - 11) = (unsigned __int8)data;
  *(v5 - 9) = v7;
  *(v5 - 7) = (unsigned __int8)v2;
  *(v5 - 5) = v8;
  *(v5 - 3) = v9;
  *(v5 - 1) = v10;
  return result;
}

//----- (00237658) --------------------------------------------------------
int __fastcall INT123_synth_ntom_8bit_mono(double *bandPtr, mpg123_handle *fr)
{
  size_t v3; // r5
  unsigned __int8 *data; // r9
  size_t fill; // r8
  int result; // r0
  size_t *p_fill; // r1
  size_t v8; // r3
  _WORD v9[256]; // [sp+0h] [bp-220h] BYREF

  v3 = 0;
  data = fr->buffer.data;
  fill = fr->buffer.fill;
  fr->buffer.data = (unsigned __int8 *)v9;
  fr->buffer.fill = 0;
  result = j_INT123_synth_ntom_8bit(bandPtr, 0, fr, 1);
  fr->buffer.data = data;
  p_fill = &fr->buffer.fill;
  if ( fr->buffer.fill >= 2 )
  {
    v8 = 0;
    do
    {
      data[fill + v8] = v9[v8];
      ++v8;
    }
    while ( v8 < *p_fill >> 1 );
    v3 = *p_fill >> 1;
  }
  *p_fill = v3 + fill;
  return result;
}

//----- (002376E8) --------------------------------------------------------
int __fastcall INT123_synth_ntom_8bit(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // r8
  unsigned __int8 *data; // r6
  int i; // r4
  double v9; // d16
  double *v10; // r0
  unsigned __int8 *v11; // r8
  int bo; // r4
  unsigned int v13; // r10
  double *(*real_buffs)[2]; // r11
  double *v15; // r5
  int v16; // r2
  unsigned int ntom_step; // r4
  double *v18; // r3
  int v19; // lr
  unsigned __int8 **p_conv16to8; // r1
  int v21; // r12
  int result; // r0
  double *v23; // r10
  int v24; // r4
  double v25; // d18
  int v26; // r2
  unsigned int v27; // r4
  unsigned int v28; // r9
  int v29; // r5
  int v30; // r4
  double *v31; // r9
  double *v32; // r3
  int v33; // r6
  double v34; // d18
  unsigned int v35; // r4
  unsigned int v36; // r12
  int v37; // r6
  int v38; // r10
  int v39; // r4
  int v40; // r2
  double *v41; // r6
  unsigned __int8 *v42; // r12
  double *v43; // r2
  int v44; // r10
  double *v45; // r11
  int v46; // r5
  int v47; // r4
  int v48; // lr
  double v49; // d18
  int v50; // r3
  unsigned int v51; // r5
  int v52; // r4
  unsigned int v53; // r5
  int v54; // r8
  int v55; // [sp+4h] [bp-4Ch]
  outbuffer *p_buffer; // [sp+8h] [bp-48h]
  size_t *p_fill; // [sp+Ch] [bp-44h]
  double *v58; // [sp+10h] [bp-40h]
  int v59; // [sp+14h] [bp-3Ch]
  mpg123_handle *v60; // [sp+18h] [bp-38h]
  int v63; // [sp+24h] [bp-2Ch]
  double *decwin; // [sp+28h] [bp-28h]
  unsigned int v65; // [sp+28h] [bp-28h]
  double *v66; // [sp+2Ch] [bp-24h]
  unsigned __int8 *v67; // [sp+2Ch] [bp-24h]
  unsigned int *p_ntom_step; // [sp+30h] [bp-20h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v13 = fr->INT123_ntom_val[1];
    real_buffs = (double *(*)[2])fr->real_buffs[1];
    ++v11;
  }
  else
  {
    v13 = fr->INT123_ntom_val[0];
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->INT123_ntom_val[1] = v13;
    fr->bo = bo;
    real_buffs = fr->real_buffs;
  }
  p_buffer = &fr->buffer;
  p_fill = &fr->buffer.fill;
  if ( bo << 31 )
  {
    v15 = (*real_buffs)[0];
    j_INT123_dct64(&(*real_buffs)[1][(bo + 1) & 0xF], &(*real_buffs)[0][bo], bandPtr);
    v16 = bo;
  }
  else
  {
    v15 = (*real_buffs)[1];
    j_INT123_dct64(&(*real_buffs)[0][bo], &v15[bo + 1], bandPtr);
    v16 = bo + 1;
  }
  ntom_step = fr->ntom_step;
  p_ntom_step = &fr->ntom_step;
  decwin = fr->decwin;
  v18 = &decwin[-v16 + 16];
  v58 = v15 + 240;
  v19 = ntom_step + v13;
  v55 = 528 - v16;
  p_conv16to8 = &fr->conv16to8;
  v21 = 16;
  v63 = 496 - v16;
  result = 0;
  v23 = v15;
  v60 = fr;
  v59 = v16;
  v66 = v15;
  do
  {
    if ( v19 >= 0x8000 )
    {
      v24 = ~v19;
      v25 = *v18 * *v23
          - v18[1] * v23[1]
          + v18[2] * v23[2]
          - v18[3] * v23[3]
          + v18[4] * v23[4]
          - v18[5] * v23[5]
          + v18[6] * v23[6]
          - v18[7] * v23[7]
          + v18[8] * v23[8]
          - v18[9] * v23[9]
          + v18[10] * v23[10]
          - v18[11] * v23[11]
          + v18[12] * v23[12]
          - v18[13] * v23[13]
          + v18[14] * v23[14]
          - v18[15] * v23[15];
      if ( ~v19 <= -65536 )
        v24 = -65536;
      v26 = v19 + 0x8000;
      v27 = v24 + v19 + 0x8000;
      v28 = v27 & 0xFFFF8000;
      v29 = (int)&v11[2 * (v27 >> 15) + 2];
      do
      {
        if ( v25 <= 32767.0 )
        {
          if ( v25 >= -32768.0 )
          {
            v30 = (int)v25;
          }
          else
          {
            ++result;
            LOWORD(v30) = 0x8000;
          }
        }
        else
        {
          ++result;
          LOWORD(v30) = 0x7FFF;
        }
        v26 -= 0x8000;
        *v11 = (*p_conv16to8)[(__int16)v30 >> 3];
        v11 += 2;
      }
      while ( v26 >= 0x10000 );
      v11 = (unsigned __int8 *)v29;
      ntom_step = *p_ntom_step;
      v19 = v19 - 0x8000 - v28;
    }
    v19 += ntom_step;
    v18 += 32;
    --v21;
    v23 += 16;
  }
  while ( v21 );
  v31 = &decwin[v63];
  v32 = v66 + 256;
  if ( v19 < 0x8000 )
  {
    v42 = v11;
    v41 = v58;
    v40 = v59;
  }
  else
  {
    v33 = ~v19;
    v34 = decwin[v55] * *v32
        + v31[34] * v66[258]
        + v31[36] * v66[260]
        + v31[38] * v66[262]
        + v31[40] * v66[264]
        + v31[42] * v66[266]
        + v31[44] * v66[268]
        + v31[46] * v66[270];
    if ( ~v19 <= -65536 )
      v33 = -65536;
    v35 = v33 + v19 + 0x8000;
    v36 = v35 & 0xFFFF8000;
    v37 = v19 + 0x8000;
    v38 = (int)&v11[2 * (v35 >> 15) + 2];
    do
    {
      if ( v34 <= 32767.0 )
      {
        if ( v34 >= -32768.0 )
        {
          v39 = (int)v34;
        }
        else
        {
          ++result;
          LOWORD(v39) = 0x8000;
        }
      }
      else
      {
        ++result;
        LOWORD(v39) = 0x7FFF;
      }
      v37 -= 0x8000;
      *v11 = (*p_conv16to8)[(__int16)v39 >> 3];
      v11 += 2;
    }
    while ( v37 >= 0x10000 );
    v19 = v19 - 0x8000 - v36;
    v41 = v58;
    v40 = v59;
    v42 = (unsigned __int8 *)v38;
  }
  v43 = &v31[2 * v40];
  v44 = 15;
  do
  {
    v45 = v41;
    v46 = *p_ntom_step + v19;
    if ( v46 >= 0x8000 )
    {
      v65 = *p_ntom_step;
      v47 = ~v46;
      v48 = v19 - 0x8000;
      v49 = -(*(v43 - 1) * *v41)
          - *(v43 - 2) * *(v32 - 15)
          - *(v43 - 3) * *(v32 - 14)
          - *(v43 - 4) * *(v32 - 13)
          - *(v43 - 5) * *(v32 - 12)
          - *(v43 - 6) * *(v32 - 11)
          - *(v43 - 7) * *(v32 - 10)
          - *(v43 - 8) * *(v32 - 9)
          - *(v43 - 9) * *(v32 - 8)
          - *(v43 - 10) * *(v32 - 7)
          - *(v43 - 11) * *(v32 - 6)
          - *(v43 - 12) * *(v32 - 5)
          - *(v43 - 13) * *(v32 - 4)
          - *(v43 - 14) * *(v32 - 3)
          - *(v43 - 15) * *(v32 - 2)
          - *(v43 - 16) * *(v32 - 1);
      if ( ~v46 <= -65536 )
        v47 = -65536;
      v50 = v46 + 0x8000;
      v67 = v42;
      v51 = v46 + 0x8000 + v47;
      v52 = (v51 >> 14) & 0x3FFFE;
      v53 = v51 & 0xFFFF8000;
      do
      {
        if ( v49 <= 32767.0 )
        {
          if ( v49 >= -32768.0 )
          {
            v54 = (int)v49;
          }
          else
          {
            ++result;
            LOWORD(v54) = 0x8000;
          }
        }
        else
        {
          ++result;
          LOWORD(v54) = 0x7FFF;
        }
        v50 -= 0x8000;
        *v42 = (*p_conv16to8)[(__int16)v54 >> 3];
        v42 += 2;
      }
      while ( v50 >= 0x10000 );
      v19 = v65 + v48 - v53;
      v42 = &v67[v52 + 2];
    }
    else
    {
      v19 += *p_ntom_step;
    }
    v41 -= 16;
    v43 -= 32;
    --v44;
    v32 = v45;
  }
  while ( v44 );
  v60->INT123_ntom_val[channel] = v19;
  if ( final )
  {
    if ( channel )
      --v42;
    *p_fill = v42 - p_buffer->data;
  }
  return result;
}

//----- (00237CBC) --------------------------------------------------------
int __fastcall INT123_synth_ntom_8bit_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r8
  size_t fill; // r5
  int result; // r0
  size_t *p_fill; // r1
  unsigned __int8 *v7; // r2
  unsigned int v8; // r3
  unsigned __int8 v9; // r6
  unsigned __int8 *v10; // r4

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  result = j_INT123_synth_ntom_8bit(bandPtr, 0, fr, 1);
  if ( fr->buffer.fill - fill >= 2 )
  {
    p_fill = &fr->buffer.fill;
    v7 = &data[fill];
    v8 = 0;
    do
    {
      v9 = v7[2 * v8];
      v10 = &v7[2 * v8++];
      v10[1] = v9;
    }
    while ( v8 < (*p_fill - fill) >> 1 );
  }
  return result;
}

//----- (00237D10) --------------------------------------------------------
int __fastcall INT123_synth_1to1_real(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  unsigned __int8 *data; // r6
  size_t fill; // lr
  int i; // r0
  double v10; // d16
  double *v11; // r3
  unsigned __int8 *v12; // r4
  int bo; // r10
  int v14; // r1
  char *v15; // r0
  size_t *p_fill; // r9
  double **v17; // r1
  double *v18; // r11
  double *decwin; // r0
  double *v20; // r1
  double *v21; // r3
  int v22; // r5
  double *v23; // r6
  double *v24; // r2
  double v25; // d17
  double v26; // d19
  double v27; // d20
  double v28; // d22
  double *v29; // r2
  double *v30; // r0
  double v31; // d21
  int v32; // r3
  double *v33; // r2
  double v34; // d17
  double v35; // d18
  double v36; // d19
  double v37; // d20
  double *v38; // r1
  double *v39; // r6
  double *v40; // r5
  double v41; // d17
  double v42; // d20
  double v43; // d19

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v10 = fr->equalizer[channel][i];
      v11 = &bandPtr[i];
      *v11 = *v11 * v10;
    }
  }
  v12 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v12 += 8;
    v14 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v14 = 0;
  }
  v15 = (char *)fr + 8 * v14;
  p_fill = &fr->buffer.fill;
  v17 = (double **)(v15 + 18464);
  if ( bo << 31 )
  {
    v18 = *v17;
    j_INT123_dct64((double *)(*((_DWORD *)v15 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v17)[bo], bandPtr);
  }
  else
  {
    v18 = (double *)*((_DWORD *)v15 + 4617);
    j_INT123_dct64(&(*v17)[bo], &v18[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v20 = &decwin[496 - bo];
  v21 = &decwin[-bo + 16];
  v22 = 0;
  v23 = v18;
  do
  {
    v24 = (double *)&v12[v22];
    v22 += 16;
    v25 = *v21 * *v23
        - v21[1] * v23[1]
        + v21[2] * v23[2]
        - v21[3] * v23[3]
        + v21[4] * v23[4]
        - v21[5] * v23[5]
        + v21[6] * v23[6]
        - v21[7] * v23[7]
        + v21[8] * v23[8]
        - v21[9] * v23[9]
        + v21[10] * v23[10]
        - v21[11] * v23[11]
        + v21[12] * v23[12]
        - v21[13] * v23[13];
    v26 = v21[14] * v23[14];
    v27 = v23[15];
    v23 += 16;
    v28 = v21[15];
    v21 += 32;
    *v24 = (v25 + v26 - v28 * v27) * 0.0000305175781;
  }
  while ( v22 != 256 );
  v29 = &decwin[528 - bo];
  v30 = &decwin[bo];
  v31 = *v29;
  v32 = 0;
  v33 = v18 + 240;
  v34 = v31 * v18[256] + v20[34] * v18[258] + v20[36] * v18[260] + v20[38] * v18[262] + v20[40] * v18[264];
  v35 = v20[42] * v18[266];
  v36 = v20[46];
  v37 = v20[44] * v18[268];
  v38 = (double *)(v12 + 272);
  *((double *)v12 + 32) = (v34 + v35 + v37 + v36 * v18[270]) * 0.0000305175781;
  do
  {
    v39 = &v30[v32];
    v40 = &v30[v32 + 494];
    v32 -= 32;
    v41 = -(v39[495] * *v33)
        - *v40 * v33[1]
        - v39[493] * v33[2]
        - v39[492] * v33[3]
        - v39[491] * v33[4]
        - v39[490] * v33[5]
        - v39[489] * v33[6]
        - v39[488] * v33[7]
        - v39[487] * v33[8]
        - v39[486] * v33[9]
        - v39[485] * v33[10]
        - v39[484] * v33[11]
        - v39[483] * v33[12]
        - v39[482] * v33[13];
    v42 = v39[481] * v33[14];
    v43 = v33[15];
    v33 -= 16;
    *v38 = (v41 - v42 - v39[480] * v43) * 0.0000305175781;
    v38 += 2;
  }
  while ( v32 != -480 );
  if ( final )
    *p_fill += 512;
  return 0;
}

//----- (00238120) --------------------------------------------------------
int __fastcall INT123_synth_1to1_real_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r5
  size_t fill; // r9
  unsigned __int8 *data; // r6
  int result; // r0
  double *v7; // r1
  double v8[67]; // [sp+0h] [bp-218h] BYREF

  v3 = fr->synths.plain[0][2];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = (double *)&data[fill];
  *v7 = v8[0];
  v7[1] = v8[2];
  v7[2] = v8[4];
  v7[3] = v8[6];
  v7[4] = v8[8];
  v7[5] = v8[10];
  v7[6] = v8[12];
  v7[7] = v8[14];
  v7[8] = v8[16];
  v7[9] = v8[18];
  v7[10] = v8[20];
  v7[11] = v8[22];
  v7[12] = v8[24];
  v7[13] = v8[26];
  v7[14] = v8[28];
  v7[15] = v8[30];
  v7[16] = v8[32];
  v7[17] = v8[34];
  v7[18] = v8[36];
  v7[19] = v8[38];
  v7[20] = v8[40];
  v7[21] = v8[42];
  v7[22] = v8[44];
  v7[23] = v8[46];
  v7[24] = v8[48];
  v7[25] = v8[50];
  v7[26] = v8[52];
  v7[27] = v8[54];
  v7[28] = v8[56];
  v7[29] = v8[58];
  v7[30] = v8[60];
  v7[31] = v8[62];
  fr->buffer.fill = fill + 256;
  return result;
}

//----- (00238272) --------------------------------------------------------
int __fastcall INT123_synth_1to1_real_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  __int64 v6; // d17
  __int64 v7; // d18
  __int64 v8; // d19
  __int64 v9; // d20
  __int64 v10; // d21
  __int64 v11; // d22
  __int64 v12; // d23
  __int64 v13; // d24
  __int64 v14; // d25
  __int64 v15; // d26
  __int64 v16; // d27
  __int64 v17; // d28
  __int64 v18; // d29
  __int64 v19; // d30
  __int64 v20; // d31
  __int64 v21; // d0
  __int64 v22; // d1
  __int64 v23; // d2
  __int64 v24; // d3
  __int64 v25; // d4
  __int64 v26; // d16
  __int64 v27; // d17
  __int64 v28; // d18
  __int64 v29; // d19
  __int64 v30; // d20
  __int64 v31; // d21
  __int64 v32; // d22
  __int64 v33; // d23
  __int64 v34; // d24
  __int64 v35; // d25
  __int64 v36; // d26

  data = fr->buffer.data;
  result = fr->synths.plain[0][2](bandPtr, 0, fr, 1);
  v5 = &data[fr->buffer.fill];
  v6 = *((_QWORD *)v5 - 62);
  v7 = *((_QWORD *)v5 - 60);
  v8 = *((_QWORD *)v5 - 58);
  v9 = *((_QWORD *)v5 - 56);
  v10 = *((_QWORD *)v5 - 54);
  v11 = *((_QWORD *)v5 - 52);
  v12 = *((_QWORD *)v5 - 50);
  v13 = *((_QWORD *)v5 - 48);
  v14 = *((_QWORD *)v5 - 46);
  v15 = *((_QWORD *)v5 - 44);
  v16 = *((_QWORD *)v5 - 42);
  v17 = *((_QWORD *)v5 - 40);
  v18 = *((_QWORD *)v5 - 38);
  v19 = *((_QWORD *)v5 - 36);
  v20 = *((_QWORD *)v5 - 34);
  v21 = *((_QWORD *)v5 - 32);
  v22 = *((_QWORD *)v5 - 30);
  v23 = *((_QWORD *)v5 - 28);
  v24 = *((_QWORD *)v5 - 26);
  v25 = *((_QWORD *)v5 - 24);
  *((_QWORD *)v5 - 63) = *((_QWORD *)v5 - 64);
  v26 = *((_QWORD *)v5 - 22);
  *((_QWORD *)v5 - 61) = v6;
  v27 = *((_QWORD *)v5 - 20);
  *((_QWORD *)v5 - 59) = v7;
  v28 = *((_QWORD *)v5 - 18);
  *((_QWORD *)v5 - 57) = v8;
  v29 = *((_QWORD *)v5 - 16);
  *((_QWORD *)v5 - 55) = v9;
  v30 = *((_QWORD *)v5 - 14);
  *((_QWORD *)v5 - 53) = v10;
  v31 = *((_QWORD *)v5 - 12);
  *((_QWORD *)v5 - 51) = v11;
  v32 = *((_QWORD *)v5 - 10);
  *((_QWORD *)v5 - 49) = v12;
  *((_QWORD *)v5 - 47) = v13;
  *((_QWORD *)v5 - 45) = v14;
  *((_QWORD *)v5 - 43) = v15;
  v33 = *((_QWORD *)v5 - 2);
  v34 = *((_QWORD *)v5 - 4);
  v35 = *((_QWORD *)v5 - 6);
  v36 = *((_QWORD *)v5 - 8);
  *((_QWORD *)v5 - 41) = v16;
  *((_QWORD *)v5 - 39) = v17;
  *((_QWORD *)v5 - 37) = v18;
  *((_QWORD *)v5 - 35) = v19;
  *((_QWORD *)v5 - 33) = v20;
  *((_QWORD *)v5 - 31) = v21;
  *((_QWORD *)v5 - 29) = v22;
  *((_QWORD *)v5 - 27) = v23;
  *((_QWORD *)v5 - 25) = v24;
  *((_QWORD *)v5 - 23) = v25;
  *((_QWORD *)v5 - 21) = v26;
  *((_QWORD *)v5 - 19) = v27;
  *((_QWORD *)v5 - 17) = v28;
  *((_QWORD *)v5 - 15) = v29;
  *((_QWORD *)v5 - 13) = v30;
  *((_QWORD *)v5 - 11) = v31;
  *((_QWORD *)v5 - 9) = v32;
  *((_QWORD *)v5 - 7) = v36;
  *((_QWORD *)v5 - 5) = v35;
  *((_QWORD *)v5 - 3) = v34;
  *((_QWORD *)v5 - 1) = v33;
  return result;
}

//----- (002383A0) --------------------------------------------------------
int __fastcall INT123_synth_2to1_real(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  unsigned __int8 *data; // r6
  size_t fill; // lr
  int i; // r0
  double v10; // d16
  double *v11; // r3
  unsigned __int8 *v12; // r4
  int bo; // r10
  int v14; // r1
  char *v15; // r0
  size_t *p_fill; // r9
  double **v17; // r1
  double *v18; // r11
  double *decwin; // r0
  double *v20; // r1
  double *v21; // r3
  int v22; // r5
  double *v23; // r6
  double *v24; // r2
  double v25; // d17
  double v26; // d19
  double v27; // d20
  double v28; // d22
  double *v29; // r2
  double *v30; // r0
  double v31; // d21
  int v32; // r3
  double *v33; // r2
  double v34; // d17
  double v35; // d18
  double v36; // d19
  double v37; // d20
  double *v38; // r1
  double *v39; // r6
  double *v40; // r5
  double v41; // d17
  double v42; // d20
  double v43; // d19

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v10 = fr->equalizer[channel][i];
      v11 = &bandPtr[i];
      *v11 = *v11 * v10;
    }
  }
  v12 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v12 += 8;
    v14 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v14 = 0;
  }
  v15 = (char *)fr + 8 * v14;
  p_fill = &fr->buffer.fill;
  v17 = (double **)(v15 + 18464);
  if ( bo << 31 )
  {
    v18 = *v17;
    j_INT123_dct64((double *)(*((_DWORD *)v15 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v17)[bo], bandPtr);
  }
  else
  {
    v18 = (double *)*((_DWORD *)v15 + 4617);
    j_INT123_dct64(&(*v17)[bo], &v18[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v20 = &decwin[464 - bo];
  v21 = &decwin[-bo + 16];
  v22 = 0;
  v23 = v18;
  do
  {
    v24 = (double *)&v12[v22];
    v22 += 16;
    v25 = *v21 * *v23
        - v21[1] * v23[1]
        + v21[2] * v23[2]
        - v21[3] * v23[3]
        + v21[4] * v23[4]
        - v21[5] * v23[5]
        + v21[6] * v23[6]
        - v21[7] * v23[7]
        + v21[8] * v23[8]
        - v21[9] * v23[9]
        + v21[10] * v23[10]
        - v21[11] * v23[11]
        + v21[12] * v23[12]
        - v21[13] * v23[13];
    v26 = v21[14] * v23[14];
    v27 = v23[15];
    v23 += 32;
    v28 = v21[15];
    v21 += 64;
    *v24 = (v25 + v26 - v28 * v27) * 0.0000305175781;
  }
  while ( v22 != 128 );
  v29 = &decwin[528 - bo];
  v30 = &decwin[bo];
  v31 = *v29;
  v32 = 0;
  v33 = v18 + 224;
  v34 = v31 * v18[256] + v20[66] * v18[258] + v20[68] * v18[260] + v20[70] * v18[262] + v20[72] * v18[264];
  v35 = v20[74] * v18[266];
  v36 = v20[78];
  v37 = v20[76] * v18[268];
  v38 = (double *)(v12 + 144);
  *((double *)v12 + 16) = (v34 + v35 + v37 + v36 * v18[270]) * 0.0000305175781;
  do
  {
    v39 = &v30[v32];
    v40 = &v30[v32 + 462];
    v32 -= 64;
    v41 = -(v39[463] * *v33)
        - *v40 * v33[1]
        - v39[461] * v33[2]
        - v39[460] * v33[3]
        - v39[459] * v33[4]
        - v39[458] * v33[5]
        - v39[457] * v33[6]
        - v39[456] * v33[7]
        - v39[455] * v33[8]
        - v39[454] * v33[9]
        - v39[453] * v33[10]
        - v39[452] * v33[11]
        - v39[451] * v33[12]
        - v39[450] * v33[13];
    v42 = v39[449] * v33[14];
    v43 = v33[15];
    v33 -= 32;
    *v38 = (v41 - v42 - v39[448] * v43) * 0.0000305175781;
    v38 += 2;
  }
  while ( v32 != -448 );
  if ( final )
    *p_fill += 256;
  return 0;
}

//----- (002387A8) --------------------------------------------------------
int __fastcall INT123_synth_2to1_real_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r5
  size_t fill; // r9
  unsigned __int8 *data; // r6
  int result; // r0
  double *v7; // r1
  double v8[35]; // [sp+0h] [bp-118h] BYREF

  v3 = fr->synths.plain[1][2];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = (double *)&data[fill];
  *v7 = v8[0];
  v7[1] = v8[2];
  v7[2] = v8[4];
  v7[3] = v8[6];
  v7[4] = v8[8];
  v7[5] = v8[10];
  v7[6] = v8[12];
  v7[7] = v8[14];
  v7[8] = v8[16];
  v7[9] = v8[18];
  v7[10] = v8[20];
  v7[11] = v8[22];
  v7[12] = v8[24];
  v7[13] = v8[26];
  v7[14] = v8[28];
  v7[15] = v8[30];
  fr->buffer.fill = fill + 128;
  return result;
}

//----- (00238876) --------------------------------------------------------
int __fastcall INT123_synth_2to1_real_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  __int64 v6; // d17
  __int64 v7; // d18
  __int64 v8; // d19
  __int64 v9; // d20
  __int64 v10; // d21
  __int64 v11; // d22
  __int64 v12; // d23
  __int64 v13; // d24
  __int64 v14; // d25
  __int64 v15; // d26
  __int64 v16; // d27
  __int64 v17; // d28
  __int64 v18; // d29
  __int64 v19; // d30
  __int64 v20; // d31

  data = fr->buffer.data;
  result = fr->synths.plain[1][2](bandPtr, 0, fr, 1);
  v5 = &data[fr->buffer.fill];
  v6 = *((_QWORD *)v5 - 30);
  v7 = *((_QWORD *)v5 - 28);
  v8 = *((_QWORD *)v5 - 26);
  v9 = *((_QWORD *)v5 - 24);
  v10 = *((_QWORD *)v5 - 22);
  v11 = *((_QWORD *)v5 - 20);
  v12 = *((_QWORD *)v5 - 18);
  v13 = *((_QWORD *)v5 - 16);
  v14 = *((_QWORD *)v5 - 14);
  v15 = *((_QWORD *)v5 - 12);
  v16 = *((_QWORD *)v5 - 10);
  v17 = *((_QWORD *)v5 - 2);
  v18 = *((_QWORD *)v5 - 4);
  v19 = *((_QWORD *)v5 - 6);
  v20 = *((_QWORD *)v5 - 8);
  *((_QWORD *)v5 - 31) = *((_QWORD *)v5 - 32);
  *((_QWORD *)v5 - 29) = v6;
  *((_QWORD *)v5 - 27) = v7;
  *((_QWORD *)v5 - 25) = v8;
  *((_QWORD *)v5 - 23) = v9;
  *((_QWORD *)v5 - 21) = v10;
  *((_QWORD *)v5 - 19) = v11;
  *((_QWORD *)v5 - 17) = v12;
  *((_QWORD *)v5 - 15) = v13;
  *((_QWORD *)v5 - 13) = v14;
  *((_QWORD *)v5 - 11) = v15;
  *((_QWORD *)v5 - 9) = v16;
  *((_QWORD *)v5 - 7) = v20;
  *((_QWORD *)v5 - 5) = v19;
  *((_QWORD *)v5 - 3) = v18;
  *((_QWORD *)v5 - 1) = v17;
  return result;
}

//----- (00238928) --------------------------------------------------------
int __fastcall INT123_synth_4to1_real(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  unsigned __int8 *data; // r6
  size_t fill; // lr
  int i; // r0
  double v10; // d16
  double *v11; // r3
  unsigned __int8 *v12; // r4
  int bo; // r10
  int v14; // r1
  char *v15; // r0
  size_t *p_fill; // r9
  double **v17; // r1
  double *v18; // r11
  double *decwin; // r0
  double *v20; // r1
  double *v21; // r3
  int v22; // r5
  double *v23; // r6
  double *v24; // r2
  double v25; // d17
  double v26; // d19
  double v27; // d20
  double v28; // d22
  double *v29; // r2
  double *v30; // r0
  double v31; // d17
  double *v32; // r2
  int v33; // r3
  double v34; // d17
  double v35; // d20
  double v36; // d22
  double *v37; // r1
  double *v38; // r6
  double *v39; // r5
  double v40; // d17
  double v41; // d20
  double v42; // d19

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v10 = fr->equalizer[channel][i];
      v11 = &bandPtr[i];
      *v11 = *v11 * v10;
    }
  }
  v12 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v12 += 8;
    v14 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v14 = 0;
  }
  v15 = (char *)fr + 8 * v14;
  p_fill = &fr->buffer.fill;
  v17 = (double **)(v15 + 18464);
  if ( bo << 31 )
  {
    v18 = *v17;
    j_INT123_dct64((double *)(*((_DWORD *)v15 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v17)[bo], bandPtr);
  }
  else
  {
    v18 = (double *)*((_DWORD *)v15 + 4617);
    j_INT123_dct64(&(*v17)[bo], &v18[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v20 = &decwin[400 - bo];
  v21 = &decwin[-bo + 16];
  v22 = 0;
  v23 = v18;
  do
  {
    v24 = (double *)&v12[v22];
    v22 += 16;
    v25 = *v21 * *v23
        - v21[1] * v23[1]
        + v21[2] * v23[2]
        - v21[3] * v23[3]
        + v21[4] * v23[4]
        - v21[5] * v23[5]
        + v21[6] * v23[6]
        - v21[7] * v23[7]
        + v21[8] * v23[8]
        - v21[9] * v23[9]
        + v21[10] * v23[10]
        - v21[11] * v23[11]
        + v21[12] * v23[12]
        - v21[13] * v23[13];
    v26 = v21[14] * v23[14];
    v27 = v23[15];
    v23 += 64;
    v28 = v21[15];
    v21 += 128;
    *v24 = (v25 + v26 - v28 * v27) * 0.0000305175781;
  }
  while ( v22 != 64 );
  v29 = &decwin[528 - bo];
  v30 = &decwin[bo];
  v31 = *v29;
  v32 = v18 + 192;
  v33 = 0;
  v34 = v31 * v18[256]
      + v20[130] * v18[258]
      + v20[132] * v18[260]
      + v20[134] * v18[262]
      + v20[136] * v18[264]
      + v20[138] * v18[266];
  v35 = v20[140] * v18[268];
  v36 = v20[142];
  v37 = (double *)(v12 + 80);
  *((double *)v12 + 8) = (v34 + v35 + v36 * v18[270]) * 0.0000305175781;
  do
  {
    v38 = &v30[v33];
    v39 = &v30[v33 + 398];
    v33 -= 128;
    v40 = -(v38[399] * *v32)
        - *v39 * v32[1]
        - v38[397] * v32[2]
        - v38[396] * v32[3]
        - v38[395] * v32[4]
        - v38[394] * v32[5]
        - v38[393] * v32[6]
        - v38[392] * v32[7]
        - v38[391] * v32[8]
        - v38[390] * v32[9]
        - v38[389] * v32[10]
        - v38[388] * v32[11]
        - v38[387] * v32[12]
        - v38[386] * v32[13];
    v41 = v38[385] * v32[14];
    v42 = v32[15];
    v32 -= 64;
    *v37 = (v40 - v41 - v38[384] * v42) * 0.0000305175781;
    v37 += 2;
  }
  while ( v33 != -384 );
  if ( final )
    *p_fill += 128;
  return 0;
}

//----- (00238D48) --------------------------------------------------------
int __fastcall INT123_synth_4to1_real_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r6
  size_t fill; // r10
  unsigned __int8 *data; // r5
  int result; // r0
  double *v7; // r1
  double v8[19]; // [sp+0h] [bp-98h] BYREF

  v3 = fr->synths.plain[2][2];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = (double *)&data[fill];
  *v7 = v8[0];
  v7[1] = v8[2];
  v7[2] = v8[4];
  v7[3] = v8[6];
  v7[4] = v8[8];
  v7[5] = v8[10];
  v7[6] = v8[12];
  v7[7] = v8[14];
  fr->buffer.fill = fill + 64;
  return result;
}

//----- (00238DD6) --------------------------------------------------------
int __fastcall INT123_synth_4to1_real_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  __int64 v6; // d17
  __int64 v7; // d18
  __int64 v8; // d19
  __int64 v9; // d20
  __int64 v10; // d21
  __int64 v11; // d22
  __int64 v12; // d23

  data = fr->buffer.data;
  result = fr->synths.plain[2][2](bandPtr, 0, fr, 1);
  v5 = &data[fr->buffer.fill];
  v6 = *((_QWORD *)v5 - 14);
  v7 = *((_QWORD *)v5 - 12);
  v8 = *((_QWORD *)v5 - 10);
  v9 = *((_QWORD *)v5 - 2);
  v10 = *((_QWORD *)v5 - 4);
  v11 = *((_QWORD *)v5 - 6);
  v12 = *((_QWORD *)v5 - 8);
  *((_QWORD *)v5 - 15) = *((_QWORD *)v5 - 16);
  *((_QWORD *)v5 - 13) = v6;
  *((_QWORD *)v5 - 11) = v7;
  *((_QWORD *)v5 - 9) = v8;
  *((_QWORD *)v5 - 7) = v12;
  *((_QWORD *)v5 - 5) = v11;
  *((_QWORD *)v5 - 3) = v10;
  *((_QWORD *)v5 - 1) = v9;
  return result;
}

//----- (00238E42) --------------------------------------------------------
int __fastcall INT123_synth_ntom_real_mono(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r9
  size_t fill; // r8
  size_t *p_fill; // r0
  size_t v6; // r5
  unsigned __int8 *v7; // r1
  size_t v8; // r2
  __int64 *v9; // r3
  __int64 v10; // d16
  _BYTE v12[4120]; // [sp+0h] [bp-1018h] BYREF

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  fr->buffer.data = v12;
  fr->buffer.fill = 0;
  j_INT123_synth_ntom_real(bandPtr, 0, fr, 1);
  fr->buffer.data = data;
  p_fill = &fr->buffer.fill;
  v6 = fr->buffer.fill;
  if ( v6 >= 0x10 )
  {
    v7 = &data[fill];
    v8 = 0;
    v9 = (__int64 *)v12;
    do
    {
      v10 = *v9;
      ++v8;
      v9 += 2;
      *(_QWORD *)v7 = v10;
      v7 += 8;
      v6 = *p_fill;
    }
    while ( v8 < *p_fill >> 4 );
  }
  *p_fill = fill + (v6 >> 1);
  return 0;
}

//----- (00238EB0) --------------------------------------------------------
int __fastcall INT123_synth_ntom_real(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // r8
  unsigned __int8 *data; // r6
  int i; // r4
  double v9; // d16
  double *v10; // r0
  double *v11; // r4
  int bo; // r5
  unsigned int v13; // r10
  double *(*real_buffs)[2]; // r8
  char v15; // r0
  double *v16; // r8
  __int64 v17; // kr00_8
  __int64 v18; // kr08_8
  double *decwin; // r2
  double *v20; // r11
  unsigned int ntom_step; // r1
  unsigned int *p_ntom_step; // r9
  double *v23; // r6
  signed int v24; // r12
  int v25; // lr
  int v26; // r1
  int v27; // r0
  unsigned int v28; // r1
  unsigned int v29; // r2
  unsigned int v30; // r3
  double v31; // d17
  double *v32; // r1
  double *v33; // r10
  int v34; // r0
  unsigned int v35; // r3
  int v36; // r0
  unsigned int v37; // r8
  double v38; // d17
  int v39; // r4
  double *v40; // r6
  double *v41; // r3
  unsigned int v42; // r11
  int v43; // r2
  int v44; // r0
  bool v45; // cc
  int v46; // r5
  double *v47; // r2
  double v48; // d22
  double v49; // d17
  double v50; // d20
  unsigned int v51; // r0
  unsigned int v52; // r10
  unsigned int v53; // r0
  double v54; // d17
  outbuffer *p_buffer; // [sp+8h] [bp-40h]
  size_t *p_fill; // [sp+Ch] [bp-3Ch]
  double *v58; // [sp+14h] [bp-34h]
  double *v59; // [sp+18h] [bp-30h]
  mpg123_handle *v60; // [sp+20h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = (double *)&data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v13 = fr->INT123_ntom_val[1];
    real_buffs = (double *(*)[2])fr->real_buffs[1];
    ++v11;
  }
  else
  {
    v13 = fr->INT123_ntom_val[0];
    v15 = fr->bo + 15;
    fr->INT123_ntom_val[1] = v13;
    bo = v15 & 0xF;
    fr->bo = bo;
    real_buffs = fr->real_buffs;
  }
  p_buffer = &fr->buffer;
  p_fill = &fr->buffer.fill;
  if ( bo << 31 )
  {
    v18 = *(_QWORD *)real_buffs;
    v16 = (*real_buffs)[0];
    j_INT123_dct64((double *)(HIDWORD(v18) + 8 * ((bo + 1) & 0xF)), &v16[bo], bandPtr);
  }
  else
  {
    v17 = *(_QWORD *)real_buffs;
    v16 = (*real_buffs)[1];
    j_INT123_dct64((double *)(v17 + 8 * bo), &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v20 = v16 + 240;
  ntom_step = fr->ntom_step;
  v60 = fr;
  p_ntom_step = &fr->ntom_step;
  v23 = &decwin[-bo + 16];
  v24 = ntom_step + v13;
  v25 = 16;
  v58 = decwin;
  v59 = v16;
  do
  {
    if ( v24 >= 0x8000 )
    {
      v26 = ~v24;
      if ( ~v24 <= -65536 )
        v26 = -65536;
      v27 = v24 + 0x8000;
      v28 = v26 + v24 + 0x8000;
      v29 = v28 & 0xFFFF8000;
      v30 = (unsigned int)v11 + ((unsigned int)&loc_1FFFF0 & (v28 >> 11)) + 16;
      v31 = (*v23 * *v16
           - v23[1] * v16[1]
           + v23[2] * v16[2]
           - v23[3] * v16[3]
           + v23[4] * v16[4]
           - v23[5] * v16[5]
           + v23[6] * v16[6]
           - v23[7] * v16[7]
           + v23[8] * v16[8]
           - v23[9] * v16[9]
           + v23[10] * v16[10]
           - v23[11] * v16[11]
           + v23[12] * v16[12]
           - v23[13] * v16[13]
           + v23[14] * v16[14]
           - v23[15] * v16[15])
          * 0.0000305175781;
      do
      {
        *v11 = v31;
        v27 -= 0x8000;
        v11 += 2;
      }
      while ( v27 >= 0x10000 );
      ntom_step = *p_ntom_step;
      v24 = v24 - 0x8000 - v29;
      v11 = (double *)v30;
    }
    v24 += ntom_step;
    v23 += 32;
    --v25;
    v16 += 16;
  }
  while ( v25 );
  v32 = &v58[496 - bo];
  v33 = v59 + 256;
  if ( v24 < 0x8000 )
  {
    v37 = (unsigned int)v11;
  }
  else
  {
    v34 = ~v24;
    if ( ~v24 <= -65536 )
      v34 = -65536;
    v35 = v34 + v24 + 0x8000;
    v36 = v24 + 0x8000;
    v37 = (unsigned int)v11 + ((unsigned int)&loc_1FFFF0 & (v35 >> 11)) + 16;
    v38 = (v58[528 - bo] * *v33
         + v32[34] * v59[258]
         + v32[36] * v59[260]
         + v32[38] * v59[262]
         + v32[40] * v59[264]
         + v32[42] * v59[266]
         + v32[44] * v59[268]
         + v32[46] * v59[270])
        * 0.0000305175781;
    do
    {
      *v11 = v38;
      v36 -= 0x8000;
      v11 += 2;
    }
    while ( v36 >= 0x10000 );
    v24 = v24 - 0x8000 - (v35 & 0xFFFF8000);
  }
  v39 = 15;
  v40 = &v32[2 * bo];
  do
  {
    v41 = v20;
    v42 = *p_ntom_step;
    v43 = *p_ntom_step + v24;
    if ( v43 >= 0x8000 )
    {
      v44 = ~v43;
      v45 = ~v43 <= -65536;
      v46 = v43 + 0x8000;
      v47 = (double *)v37;
      v48 = *(v33 - 2);
      v49 = -(*(v40 - 1) * *v41)
          - *(v40 - 2) * *(v33 - 15)
          - *(v40 - 3) * *(v33 - 14)
          - *(v40 - 4) * *(v33 - 13)
          - *(v40 - 5) * *(v33 - 12)
          - *(v40 - 6) * *(v33 - 11)
          - *(v40 - 7) * *(v33 - 10)
          - *(v40 - 8) * *(v33 - 9)
          - *(v40 - 9) * *(v33 - 8)
          - *(v40 - 10) * *(v33 - 7)
          - *(v40 - 11) * *(v33 - 6)
          - *(v40 - 12) * *(v33 - 5)
          - *(v40 - 13) * *(v33 - 4)
          - *(v40 - 14) * *(v33 - 3);
      v50 = *(v33 - 1);
      if ( v45 )
        v44 = -65536;
      v51 = v44 + v46;
      v52 = ((unsigned int)&stru_3FFFC.st_name + 2) & (v51 >> 14);
      v53 = v51 & 0xFFFF8000;
      v54 = (v49 - *(v40 - 15) * v48 - *(v40 - 16) * v50) * 0.0000305175781;
      do
      {
        *v47 = v54;
        v46 -= 0x8000;
        v47 += 2;
      }
      while ( v46 >= 0x10000 );
      v24 = v24 - 0x8000 + v42 - v53;
      v37 += 8 * v52 + 16;
    }
    else
    {
      v24 += *p_ntom_step;
    }
    v20 = v41 - 16;
    v40 -= 32;
    --v39;
    v33 = v41;
  }
  while ( v39 );
  v60->INT123_ntom_val[channel] = v24;
  if ( final )
  {
    if ( channel )
      v37 -= 8;
    *p_fill = v37 - (unsigned int)p_buffer->data;
  }
  return 0;
}
// 3FFFC: using guessed type Elf32_Sym stru_3FFFC;

//----- (002393CA) --------------------------------------------------------
int __fastcall INT123_synth_ntom_real_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r8
  size_t fill; // r5
  unsigned __int8 *v5; // r1
  size_t v6; // r2

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  j_INT123_synth_ntom_real(bandPtr, 0, fr, 1);
  if ( fr->buffer.fill - fill >= 0x10 )
  {
    v5 = &data[fill];
    v6 = 0;
    do
    {
      ++v6;
      *((_QWORD *)v5 + 1) = *(_QWORD *)v5;
      v5 += 16;
    }
    while ( v6 < (fr->buffer.fill - fill) >> 4 );
  }
  return 0;
}

//----- (00239420) --------------------------------------------------------
int __fastcall INT123_synth_1to1_s32(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r8
  double *decwin; // lr
  double *v18; // r2
  double *v19; // r5
  int v20; // r3
  double *v21; // r6
  int result; // r0
  double v23; // d19
  double v24; // d19
  double v25; // d22
  double v26; // d21
  double *v27; // r2
  double v28; // d19
  unsigned int v29; // r1
  double *v30; // r1
  _DWORD *v31; // r3
  int j; // r6
  double v33; // d19
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v11 += 4;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v18 = &decwin[496 - bo];
  v19 = &decwin[-bo + 16];
  v20 = 0;
  v21 = v16;
  result = 0;
  do
  {
    v23 = (*v19 * *v21
         - v19[1] * v21[1]
         + v19[2] * v21[2]
         - v19[3] * v21[3]
         + v19[4] * v21[4]
         - v19[5] * v21[5]
         + v19[6] * v21[6]
         - v19[7] * v21[7]
         + v19[8] * v21[8]
         - v19[9] * v21[9]
         + v19[10] * v21[10]
         - v19[11] * v21[11]
         + v19[12] * v21[12]
         - v19[13] * v21[13]
         + v19[14] * v21[14]
         - v19[15] * v21[15])
        * 65536.0;
    if ( v23 <= 2147483650.0 )
    {
      if ( v23 >= -2147483650.0 )
      {
        *(_DWORD *)&v11[8 * v20] = (int)v23;
      }
      else
      {
        *(_DWORD *)&v11[8 * v20] = 0x80000000;
        ++result;
      }
    }
    else
    {
      *(_DWORD *)&v11[8 * v20] = 0x7FFFFFFF;
      ++result;
    }
    ++v20;
    v21 += 16;
    v19 += 32;
  }
  while ( v20 != 16 );
  v24 = decwin[528 - bo] * v16[256]
      + v18[34] * v16[258]
      + v18[36] * v16[260]
      + v18[38] * v16[262]
      + v18[40] * v16[264]
      + v18[42] * v16[266];
  v25 = v18[44] * v16[268];
  v26 = v18[46];
  v27 = v16 + 240;
  v28 = (v24 + v25 + v26 * v16[270]) * 65536.0;
  if ( v28 <= 2147483650.0 )
  {
    if ( v28 >= -2147483650.0 )
    {
      *((_DWORD *)v11 + 32) = (int)v28;
      goto LABEL_23;
    }
    v29 = 0x80000000;
  }
  else
  {
    v29 = 0x7FFFFFFF;
  }
  *((_DWORD *)v11 + 32) = v29;
  ++result;
LABEL_23:
  v31 = v11 + 136;
  for ( j = 0; j != -480; j -= 32 )
  {
    v30 = &decwin[bo];
    v33 = (-(v30[j + 495] * *v27)
         - v30[j + 494] * v27[1]
         - v30[j + 493] * v27[2]
         - v30[j + 492] * v27[3]
         - v30[j + 491] * v27[4]
         - v30[j + 490] * v27[5]
         - v30[j + 489] * v27[6]
         - v30[j + 488] * v27[7]
         - v30[j + 487] * v27[8]
         - v30[j + 486] * v27[9]
         - v30[j + 485] * v27[10]
         - v30[j + 484] * v27[11]
         - v30[j + 483] * v27[12]
         - v30[j + 482] * v27[13]
         - v30[j + 481] * v27[14]
         - v30[j + 480] * v27[15])
        * 65536.0;
    if ( v33 <= 2147483650.0 )
    {
      if ( v33 >= -2147483650.0 )
      {
        *v31 = (int)v33;
      }
      else
      {
        *v31 = 0x80000000;
        ++result;
      }
    }
    else
    {
      *v31 = 0x7FFFFFFF;
      ++result;
    }
    v27 -= 16;
    v31 += 2;
  }
  if ( final )
    *p_fill += 256;
  return result;
}

//----- (002398D8) --------------------------------------------------------
int __fastcall INT123_synth_1to1_s32_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r5
  size_t fill; // r9
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v7; // r1
  int v8[70]; // [sp+0h] [bp-118h] BYREF

  v3 = fr->synths.plain[0][3];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  *(_DWORD *)&data[fill] = v8[0];
  v7 = &data[fill];
  *((_DWORD *)v7 + 1) = v8[2];
  *((_DWORD *)v7 + 2) = v8[4];
  *((_DWORD *)v7 + 3) = v8[6];
  *((_DWORD *)v7 + 4) = v8[8];
  *((_DWORD *)v7 + 5) = v8[10];
  *((_DWORD *)v7 + 6) = v8[12];
  *((_DWORD *)v7 + 7) = v8[14];
  *((_DWORD *)v7 + 8) = v8[16];
  *((_DWORD *)v7 + 9) = v8[18];
  *((_DWORD *)v7 + 10) = v8[20];
  *((_DWORD *)v7 + 11) = v8[22];
  *((_DWORD *)v7 + 12) = v8[24];
  *((_DWORD *)v7 + 13) = v8[26];
  *((_DWORD *)v7 + 14) = v8[28];
  *((_DWORD *)v7 + 15) = v8[30];
  *((_DWORD *)v7 + 16) = v8[32];
  *((_DWORD *)v7 + 17) = v8[34];
  *((_DWORD *)v7 + 18) = v8[36];
  *((_DWORD *)v7 + 19) = v8[38];
  *((_DWORD *)v7 + 20) = v8[40];
  *((_DWORD *)v7 + 21) = v8[42];
  *((_DWORD *)v7 + 22) = v8[44];
  *((_DWORD *)v7 + 23) = v8[46];
  *((_DWORD *)v7 + 24) = v8[48];
  *((_DWORD *)v7 + 25) = v8[50];
  *((_DWORD *)v7 + 26) = v8[52];
  *((_DWORD *)v7 + 27) = v8[54];
  *((_DWORD *)v7 + 28) = v8[56];
  *((_DWORD *)v7 + 29) = v8[58];
  *((_DWORD *)v7 + 30) = v8[60];
  *((_DWORD *)v7 + 31) = v8[62];
  fr->buffer.fill = fill + 128;
  return result;
}

//----- (002399A8) --------------------------------------------------------
int __fastcall INT123_synth_1to1_s32_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  int v6; // r3
  int v7; // r6
  int v8; // r5
  int v9; // r4
  int v10; // r12
  int v11; // r2
  int v12; // r3
  int v13; // r6
  int v14; // r5
  int v15; // r4
  int v16; // r12
  int v17; // r2
  int v18; // r3
  int v19; // r6
  int v20; // r5
  int v21; // r4
  int v22; // r12
  int v23; // r2
  int v24; // r3
  int v25; // r6
  int v26; // r5
  int v27; // r4
  int v28; // r12
  int v29; // lr
  int v30; // r8
  int v31; // r9
  int v32; // r5
  int v33; // r4
  int v34; // r2
  int v35; // r3
  int v36; // r6

  data = fr->buffer.data;
  result = fr->synths.plain[0][3](bandPtr, 0, fr, 1);
  v5 = &data[fr->buffer.fill];
  v6 = *((_DWORD *)v5 - 62);
  v7 = *((_DWORD *)v5 - 60);
  v8 = *((_DWORD *)v5 - 58);
  v9 = *((_DWORD *)v5 - 56);
  v10 = *((_DWORD *)v5 - 54);
  *((_DWORD *)v5 - 63) = *((_DWORD *)v5 - 64);
  v11 = *((_DWORD *)v5 - 52);
  *((_DWORD *)v5 - 61) = v6;
  v12 = *((_DWORD *)v5 - 50);
  *((_DWORD *)v5 - 59) = v7;
  v13 = *((_DWORD *)v5 - 48);
  *((_DWORD *)v5 - 57) = v8;
  v14 = *((_DWORD *)v5 - 46);
  *((_DWORD *)v5 - 55) = v9;
  v15 = *((_DWORD *)v5 - 44);
  *((_DWORD *)v5 - 53) = v10;
  v16 = *((_DWORD *)v5 - 42);
  *((_DWORD *)v5 - 51) = v11;
  v17 = *((_DWORD *)v5 - 40);
  *((_DWORD *)v5 - 49) = v12;
  v18 = *((_DWORD *)v5 - 38);
  *((_DWORD *)v5 - 47) = v13;
  v19 = *((_DWORD *)v5 - 36);
  *((_DWORD *)v5 - 45) = v14;
  v20 = *((_DWORD *)v5 - 34);
  *((_DWORD *)v5 - 43) = v15;
  v21 = *((_DWORD *)v5 - 32);
  *((_DWORD *)v5 - 41) = v16;
  v22 = *((_DWORD *)v5 - 30);
  *((_DWORD *)v5 - 39) = v17;
  v23 = *((_DWORD *)v5 - 28);
  *((_DWORD *)v5 - 37) = v18;
  v24 = *((_DWORD *)v5 - 26);
  *((_DWORD *)v5 - 35) = v19;
  v25 = *((_DWORD *)v5 - 24);
  *((_DWORD *)v5 - 33) = v20;
  v26 = *((_DWORD *)v5 - 22);
  *((_DWORD *)v5 - 31) = v21;
  v27 = *((_DWORD *)v5 - 20);
  *((_DWORD *)v5 - 29) = v22;
  v28 = *((_DWORD *)v5 - 18);
  *((_DWORD *)v5 - 27) = v23;
  v29 = *((_DWORD *)v5 - 16);
  *((_DWORD *)v5 - 25) = v24;
  v30 = *((_DWORD *)v5 - 14);
  *((_DWORD *)v5 - 23) = v25;
  v31 = *((_DWORD *)v5 - 12);
  *((_DWORD *)v5 - 21) = v26;
  v32 = *((_DWORD *)v5 - 10);
  *((_DWORD *)v5 - 19) = v27;
  v33 = *((_DWORD *)v5 - 8);
  *((_DWORD *)v5 - 17) = v28;
  v34 = *((_DWORD *)v5 - 6);
  *((_DWORD *)v5 - 15) = v29;
  v35 = *((_DWORD *)v5 - 4);
  *((_DWORD *)v5 - 13) = v30;
  v36 = *((_DWORD *)v5 - 2);
  *((_DWORD *)v5 - 11) = v31;
  *((_DWORD *)v5 - 9) = v32;
  *((_DWORD *)v5 - 7) = v33;
  *((_DWORD *)v5 - 5) = v34;
  *((_DWORD *)v5 - 3) = v35;
  *((_DWORD *)v5 - 1) = v36;
  return result;
}

//----- (00239AD8) --------------------------------------------------------
int __fastcall INT123_synth_2to1_s32(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r8
  double *decwin; // lr
  double *v18; // r2
  double *v19; // r5
  int v20; // r3
  double *v21; // r6
  int result; // r0
  double v23; // d19
  double v24; // d19
  double v25; // d22
  double v26; // d21
  double *v27; // r2
  double v28; // d19
  unsigned int v29; // r1
  double *v30; // r1
  _DWORD *v31; // r3
  int j; // r6
  double v33; // d19
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v11 += 4;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v18 = &decwin[464 - bo];
  v19 = &decwin[-bo + 16];
  v20 = 0;
  v21 = v16;
  result = 0;
  do
  {
    v23 = (*v19 * *v21
         - v19[1] * v21[1]
         + v19[2] * v21[2]
         - v19[3] * v21[3]
         + v19[4] * v21[4]
         - v19[5] * v21[5]
         + v19[6] * v21[6]
         - v19[7] * v21[7]
         + v19[8] * v21[8]
         - v19[9] * v21[9]
         + v19[10] * v21[10]
         - v19[11] * v21[11]
         + v19[12] * v21[12]
         - v19[13] * v21[13]
         + v19[14] * v21[14]
         - v19[15] * v21[15])
        * 65536.0;
    if ( v23 <= 2147483650.0 )
    {
      if ( v23 >= -2147483650.0 )
      {
        *(_DWORD *)&v11[8 * v20] = (int)v23;
      }
      else
      {
        *(_DWORD *)&v11[8 * v20] = 0x80000000;
        ++result;
      }
    }
    else
    {
      *(_DWORD *)&v11[8 * v20] = 0x7FFFFFFF;
      ++result;
    }
    ++v20;
    v21 += 32;
    v19 += 64;
  }
  while ( v20 != 8 );
  v24 = decwin[528 - bo] * v16[256]
      + v18[66] * v16[258]
      + v18[68] * v16[260]
      + v18[70] * v16[262]
      + v18[72] * v16[264]
      + v18[74] * v16[266];
  v25 = v18[76] * v16[268];
  v26 = v18[78];
  v27 = v16 + 224;
  v28 = (v24 + v25 + v26 * v16[270]) * 65536.0;
  if ( v28 <= 2147483650.0 )
  {
    if ( v28 >= -2147483650.0 )
    {
      *((_DWORD *)v11 + 16) = (int)v28;
      goto LABEL_23;
    }
    v29 = 0x80000000;
  }
  else
  {
    v29 = 0x7FFFFFFF;
  }
  *((_DWORD *)v11 + 16) = v29;
  ++result;
LABEL_23:
  v31 = v11 + 72;
  for ( j = 0; j != -448; j -= 64 )
  {
    v30 = &decwin[bo];
    v33 = (-(v30[j + 463] * *v27)
         - v30[j + 462] * v27[1]
         - v30[j + 461] * v27[2]
         - v30[j + 460] * v27[3]
         - v30[j + 459] * v27[4]
         - v30[j + 458] * v27[5]
         - v30[j + 457] * v27[6]
         - v30[j + 456] * v27[7]
         - v30[j + 455] * v27[8]
         - v30[j + 454] * v27[9]
         - v30[j + 453] * v27[10]
         - v30[j + 452] * v27[11]
         - v30[j + 451] * v27[12]
         - v30[j + 450] * v27[13]
         - v30[j + 449] * v27[14]
         - v30[j + 448] * v27[15])
        * 65536.0;
    if ( v33 <= 2147483650.0 )
    {
      if ( v33 >= -2147483650.0 )
      {
        *v31 = (int)v33;
      }
      else
      {
        *v31 = 0x80000000;
        ++result;
      }
    }
    else
    {
      *v31 = 0x7FFFFFFF;
      ++result;
    }
    v27 -= 32;
    v31 += 2;
  }
  if ( final )
    *p_fill += 128;
  return result;
}

//----- (00239F90) --------------------------------------------------------
int __fastcall INT123_synth_2to1_s32_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r6
  size_t fill; // r10
  unsigned __int8 *data; // r5
  int result; // r0
  unsigned __int8 *v7; // r2
  int v8[38]; // [sp+0h] [bp-98h] BYREF

  v3 = fr->synths.plain[1][3];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = &data[fill];
  *(_DWORD *)&data[fill] = v8[0];
  *((_DWORD *)v7 + 1) = v8[2];
  *((_DWORD *)v7 + 2) = v8[4];
  *((_DWORD *)v7 + 3) = v8[6];
  *((_DWORD *)v7 + 4) = v8[8];
  *((_DWORD *)v7 + 5) = v8[10];
  *((_DWORD *)v7 + 6) = v8[12];
  *((_DWORD *)v7 + 7) = v8[14];
  *((_DWORD *)v7 + 8) = v8[16];
  *((_DWORD *)v7 + 9) = v8[18];
  *((_DWORD *)v7 + 10) = v8[20];
  *((_DWORD *)v7 + 11) = v8[22];
  *((_DWORD *)v7 + 12) = v8[24];
  *((_DWORD *)v7 + 13) = v8[26];
  *((_DWORD *)v7 + 14) = v8[28];
  *((_DWORD *)v7 + 15) = v8[30];
  fr->buffer.fill = fill + 64;
  return result;
}

//----- (0023A020) --------------------------------------------------------
int __fastcall INT123_synth_2to1_s32_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  int v6; // r3
  int v7; // r6
  int v8; // r5
  int v9; // r4
  int v10; // r12
  int v11; // lr
  int v12; // r8
  int v13; // r6
  int v14; // r5
  int v15; // r9
  int v16; // r2
  int v17; // r3
  int v18; // r4
  int v19; // r6
  int v20; // r5

  data = fr->buffer.data;
  result = fr->synths.plain[1][3](bandPtr, 0, fr, 1);
  v5 = &data[fr->buffer.fill];
  v6 = *((_DWORD *)v5 - 30);
  v7 = *((_DWORD *)v5 - 28);
  v8 = *((_DWORD *)v5 - 26);
  v9 = *((_DWORD *)v5 - 24);
  v10 = *((_DWORD *)v5 - 22);
  *((_DWORD *)v5 - 31) = *((_DWORD *)v5 - 32);
  v11 = *((_DWORD *)v5 - 20);
  *((_DWORD *)v5 - 29) = v6;
  v12 = *((_DWORD *)v5 - 18);
  *((_DWORD *)v5 - 27) = v7;
  v13 = *((_DWORD *)v5 - 16);
  *((_DWORD *)v5 - 25) = v8;
  v14 = *((_DWORD *)v5 - 14);
  *((_DWORD *)v5 - 23) = v9;
  v15 = *((_DWORD *)v5 - 12);
  *((_DWORD *)v5 - 21) = v10;
  v16 = *((_DWORD *)v5 - 10);
  *((_DWORD *)v5 - 19) = v11;
  v17 = *((_DWORD *)v5 - 8);
  *((_DWORD *)v5 - 17) = v12;
  v18 = *((_DWORD *)v5 - 6);
  *((_DWORD *)v5 - 15) = v13;
  v19 = *((_DWORD *)v5 - 4);
  *((_DWORD *)v5 - 13) = v14;
  v20 = *((_DWORD *)v5 - 2);
  *((_DWORD *)v5 - 11) = v15;
  *((_DWORD *)v5 - 9) = v16;
  *((_DWORD *)v5 - 7) = v17;
  *((_DWORD *)v5 - 5) = v18;
  *((_DWORD *)v5 - 3) = v19;
  *((_DWORD *)v5 - 1) = v20;
  return result;
}

//----- (0023A0D0) --------------------------------------------------------
int __fastcall INT123_synth_4to1_s32(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // lr
  unsigned __int8 *data; // r6
  int i; // r0
  double v9; // d16
  double *v10; // r3
  unsigned __int8 *v11; // r4
  int bo; // r10
  int v13; // r1
  char *v14; // r0
  double **v15; // r1
  double *v16; // r8
  double *decwin; // lr
  double *v18; // r2
  double *v19; // r5
  int v20; // r3
  double *v21; // r6
  int result; // r0
  double v23; // d19
  double v24; // d19
  double v25; // d20
  double v26; // d23
  double *v27; // r1
  double *v28; // r2
  double v29; // d19
  unsigned int v30; // r1
  double *v31; // r1
  _DWORD *v32; // r3
  int j; // r6
  double v34; // d19
  size_t *p_fill; // [sp+0h] [bp-28h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v11 += 4;
    v13 = 1;
  }
  else
  {
    bo = ((unsigned __int8)fr->bo + 15) & 0xF;
    fr->bo = bo;
    v13 = 0;
  }
  p_fill = &fr->buffer.fill;
  v14 = (char *)fr + 8 * v13;
  v15 = (double **)(v14 + 18464);
  if ( bo << 31 )
  {
    v16 = *v15;
    j_INT123_dct64((double *)(*((_DWORD *)v14 + 4617) + 8 * (((_BYTE)bo + 1) & 0xF)), &(*v15)[bo], bandPtr);
  }
  else
  {
    v16 = (double *)*((_DWORD *)v14 + 4617);
    j_INT123_dct64(&(*v15)[bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  decwin = fr->decwin;
  v18 = &decwin[400 - bo];
  v19 = &decwin[-bo + 16];
  v20 = 0;
  v21 = v16;
  result = 0;
  do
  {
    v23 = (*v19 * *v21
         - v19[1] * v21[1]
         + v19[2] * v21[2]
         - v19[3] * v21[3]
         + v19[4] * v21[4]
         - v19[5] * v21[5]
         + v19[6] * v21[6]
         - v19[7] * v21[7]
         + v19[8] * v21[8]
         - v19[9] * v21[9]
         + v19[10] * v21[10]
         - v19[11] * v21[11]
         + v19[12] * v21[12]
         - v19[13] * v21[13]
         + v19[14] * v21[14]
         - v19[15] * v21[15])
        * 65536.0;
    if ( v23 <= 2147483650.0 )
    {
      if ( v23 >= -2147483650.0 )
      {
        *(_DWORD *)&v11[8 * v20] = (int)v23;
      }
      else
      {
        *(_DWORD *)&v11[8 * v20] = 0x80000000;
        ++result;
      }
    }
    else
    {
      *(_DWORD *)&v11[8 * v20] = 0x7FFFFFFF;
      ++result;
    }
    ++v20;
    v21 += 64;
    v19 += 128;
  }
  while ( v20 != 4 );
  v24 = decwin[528 - bo] * v16[256]
      + v18[130] * v16[258]
      + v18[132] * v16[260]
      + v18[134] * v16[262]
      + v18[136] * v16[264];
  v25 = v18[138] * v16[266];
  v26 = v18[140];
  v27 = v18 + 142;
  v28 = v16 + 192;
  v29 = (v24 + v25 + v26 * v16[268] + *v27 * v16[270]) * 65536.0;
  if ( v29 <= 2147483650.0 )
  {
    if ( v29 >= -2147483650.0 )
    {
      *((_DWORD *)v11 + 8) = (int)v29;
      goto LABEL_23;
    }
    v30 = 0x80000000;
  }
  else
  {
    v30 = 0x7FFFFFFF;
  }
  *((_DWORD *)v11 + 8) = v30;
  ++result;
LABEL_23:
  v32 = v11 + 40;
  for ( j = 0; j != -384; j -= 128 )
  {
    v31 = &decwin[bo];
    v34 = (-(v31[j + 399] * *v28)
         - v31[j + 398] * v28[1]
         - v31[j + 397] * v28[2]
         - v31[j + 396] * v28[3]
         - v31[j + 395] * v28[4]
         - v31[j + 394] * v28[5]
         - v31[j + 393] * v28[6]
         - v31[j + 392] * v28[7]
         - v31[j + 391] * v28[8]
         - v31[j + 390] * v28[9]
         - v31[j + 389] * v28[10]
         - v31[j + 388] * v28[11]
         - v31[j + 387] * v28[12]
         - v31[j + 386] * v28[13]
         - v31[j + 385] * v28[14]
         - v31[j + 384] * v28[15])
        * 65536.0;
    if ( v34 <= 2147483650.0 )
    {
      if ( v34 >= -2147483650.0 )
      {
        *v32 = (int)v34;
      }
      else
      {
        *v32 = 0x80000000;
        ++result;
      }
    }
    else
    {
      *v32 = 0x7FFFFFFF;
      ++result;
    }
    v28 -= 64;
    v32 += 2;
  }
  if ( final )
    *p_fill += 64;
  return result;
}

//----- (0023A5A4) --------------------------------------------------------
int __fastcall INT123_synth_4to1_s32_mono(double *bandPtr, mpg123_handle *fr)
{
  func_synth v3; // r12
  size_t fill; // r6
  unsigned __int8 *data; // r5
  int result; // r0
  unsigned __int8 *v7; // r2
  int v8[22]; // [sp+0h] [bp-58h] BYREF

  v3 = fr->synths.plain[2][3];
  fill = fr->buffer.fill;
  data = fr->buffer.data;
  fr->buffer.data = (unsigned __int8 *)v8;
  fr->buffer.fill = 0;
  result = v3(bandPtr, 0, fr, 0);
  fr->buffer.data = data;
  v7 = &data[fill];
  *(_DWORD *)&data[fill] = v8[0];
  *((_DWORD *)v7 + 1) = v8[2];
  *((_DWORD *)v7 + 2) = v8[4];
  *((_DWORD *)v7 + 3) = v8[6];
  *((_DWORD *)v7 + 4) = v8[8];
  *((_DWORD *)v7 + 5) = v8[10];
  *((_DWORD *)v7 + 6) = v8[12];
  *((_DWORD *)v7 + 7) = v8[14];
  fr->buffer.fill = fill + 32;
  return result;
}

//----- (0023A612) --------------------------------------------------------
int __fastcall INT123_synth_4to1_s32_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r6
  int result; // r0
  unsigned __int8 *v5; // r1
  int v6; // r3
  int v7; // r6
  int v8; // r5
  int v9; // r4
  int v10; // r12
  int v11; // r2
  int v12; // r3

  data = fr->buffer.data;
  result = fr->synths.plain[2][3](bandPtr, 0, fr, 1);
  v5 = &data[fr->buffer.fill];
  v6 = *((_DWORD *)v5 - 14);
  v7 = *((_DWORD *)v5 - 12);
  v8 = *((_DWORD *)v5 - 10);
  v9 = *((_DWORD *)v5 - 8);
  v10 = *((_DWORD *)v5 - 6);
  *((_DWORD *)v5 - 15) = *((_DWORD *)v5 - 16);
  v11 = *((_DWORD *)v5 - 4);
  *((_DWORD *)v5 - 13) = v6;
  v12 = *((_DWORD *)v5 - 2);
  *((_DWORD *)v5 - 11) = v7;
  *((_DWORD *)v5 - 9) = v8;
  *((_DWORD *)v5 - 7) = v9;
  *((_DWORD *)v5 - 5) = v10;
  *((_DWORD *)v5 - 3) = v11;
  *((_DWORD *)v5 - 1) = v12;
  return result;
}

//----- (0023A67E) --------------------------------------------------------
int __fastcall INT123_synth_ntom_s32_mono(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r10
  size_t fill; // r8
  int result; // r0
  size_t *p_fill; // r1
  size_t v7; // r2
  size_t v8; // r5
  _QWORD v9[259]; // [sp+0h] [bp-818h] BYREF

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  fr->buffer.data = (unsigned __int8 *)v9;
  fr->buffer.fill = 0;
  result = j_INT123_synth_ntom_s32(bandPtr, 0, fr, 1);
  fr->buffer.data = data;
  p_fill = &fr->buffer.fill;
  v7 = fr->buffer.fill;
  if ( v7 >= 8 )
  {
    v8 = 0;
    do
    {
      *(_DWORD *)&data[4 * v8 + fill] = v9[v8];
      ++v8;
      v7 = *p_fill;
    }
    while ( v8 < *p_fill >> 3 );
  }
  *p_fill = fill + (v7 >> 1);
  return result;
}

//----- (0023A6E8) --------------------------------------------------------
int __fastcall INT123_synth_ntom_s32(double *bandPtr, int channel, mpg123_handle *fr, int final)
{
  size_t fill; // r8
  unsigned __int8 *data; // r6
  int i; // r4
  double v9; // d16
  double *v10; // r0
  unsigned __int8 *v11; // r4
  int bo; // r5
  unsigned int v13; // r11
  double *(*real_buffs)[2]; // r8
  char v15; // r0
  double *v16; // r10
  unsigned int ntom_step; // r2
  double *decwin; // r1
  int v19; // r11
  int v20; // r8
  double *v21; // r6
  double *v22; // r1
  int result; // r0
  int v24; // r3
  int v25; // r10
  double v26; // d19
  unsigned int v27; // r3
  unsigned int v28; // lr
  unsigned int v29; // r3
  double *v30; // r10
  double *v31; // r5
  double *v32; // r8
  int v33; // r2
  double v34; // d19
  unsigned int v35; // r2
  unsigned int v36; // r12
  int v37; // r3
  char *v38; // lr
  unsigned int *p_ntom_step; // r2
  int v40; // r4
  double *v41; // r6
  double *v42; // r1
  int v43; // r3
  int v44; // r5
  int v45; // r12
  int v46; // r11
  double v47; // d19
  unsigned int v48; // r10
  unsigned int v49; // r3
  char *v50; // r1
  char *v51; // r3
  int v52; // [sp+0h] [bp-48h]
  double *v53; // [sp+4h] [bp-44h]
  double *v54; // [sp+10h] [bp-38h]
  double *v57; // [sp+20h] [bp-28h]
  unsigned int v58; // [sp+20h] [bp-28h]
  int v59; // [sp+24h] [bp-24h]
  double *v60; // [sp+24h] [bp-24h]

  fill = fr->buffer.fill;
  data = fr->buffer.data;
  if ( fr->have_eq_settings )
  {
    for ( i = 0; i != 32; ++i )
    {
      v9 = fr->equalizer[channel][i];
      v10 = &bandPtr[i];
      *v10 = *v10 * v9;
    }
  }
  v11 = &data[fill];
  if ( channel )
  {
    bo = fr->bo;
    v13 = fr->INT123_ntom_val[1];
    real_buffs = (double *(*)[2])fr->real_buffs[1];
    v11 += 4;
  }
  else
  {
    v13 = fr->INT123_ntom_val[0];
    v15 = fr->bo + 15;
    fr->INT123_ntom_val[1] = v13;
    bo = v15 & 0xF;
    fr->bo = bo;
    real_buffs = fr->real_buffs;
  }
  if ( bo << 31 )
  {
    v16 = (*real_buffs)[0];
    j_INT123_dct64(&(*real_buffs)[1][(bo + 1) & 0xF], &(*real_buffs)[0][bo], bandPtr);
  }
  else
  {
    v16 = (*real_buffs)[1];
    j_INT123_dct64(&(*real_buffs)[0][bo], &v16[bo + 1], bandPtr);
    ++bo;
  }
  ntom_step = fr->ntom_step;
  decwin = fr->decwin;
  v19 = v13 + ntom_step;
  v20 = 16;
  v54 = &decwin[496 - bo];
  v21 = &decwin[-bo + 16];
  v53 = decwin;
  v22 = v16;
  v52 = 528 - bo;
  result = 0;
  v59 = bo;
  v57 = v16;
  do
  {
    if ( v19 >= 0x8000 )
    {
      v24 = ~v19;
      v25 = v19 + 0x8000;
      v26 = (*v21 * *v22
           - v21[1] * v22[1]
           + v21[2] * v22[2]
           - v21[3] * v22[3]
           + v21[4] * v22[4]
           - v21[5] * v22[5]
           + v21[6] * v22[6]
           - v21[7] * v22[7]
           + v21[8] * v22[8]
           - v21[9] * v22[9]
           + v21[10] * v22[10]
           - v21[11] * v22[11]
           + v21[12] * v22[12]
           - v21[13] * v22[13]
           + v21[14] * v22[14]
           - v21[15] * v22[15])
          * 65536.0;
      if ( ~v19 <= -65536 )
        v24 = -65536;
      v27 = v24 + v25;
      v28 = v27 & 0xFFFF8000;
      v29 = (unsigned int)&v11[((unsigned int)"rializeEv" & (v27 >> 12)) + 8];
      do
      {
        if ( v26 <= 2147483650.0 )
        {
          if ( v26 < -2147483650.0 )
          {
            *(_DWORD *)v11 = 0x80000000;
            ++result;
          }
          else
          {
            *(_DWORD *)v11 = (int)v26;
          }
        }
        else
        {
          *(_DWORD *)v11 = 0x7FFFFFFF;
          ++result;
        }
        v25 -= 0x8000;
        v11 += 8;
      }
      while ( v25 >= 0x10000 );
      v19 = v19 - 0x8000 - v28;
      v11 = (unsigned __int8 *)v29;
      ntom_step = fr->ntom_step;
    }
    v19 += ntom_step;
    v21 += 32;
    --v20;
    v22 += 16;
  }
  while ( v20 );
  v30 = v57 + 256;
  v31 = v57 + 240;
  if ( v19 < 0x8000 )
  {
    v38 = (char *)v11;
    p_ntom_step = &fr->ntom_step;
    v32 = v54;
  }
  else
  {
    v32 = v54;
    v33 = ~v19;
    v34 = (v53[v52] * *v30
         + v54[34] * v57[258]
         + v54[36] * v57[260]
         + v54[38] * v57[262]
         + v54[40] * v57[264]
         + v54[42] * v57[266]
         + v54[44] * v57[268]
         + v54[46] * v57[270])
        * 65536.0;
    if ( ~v19 <= -65536 )
      v33 = -65536;
    v35 = v33 + v19 + 0x8000;
    v36 = v35 & 0xFFFF8000;
    v37 = v19 + 0x8000;
    v38 = (char *)&v11[((unsigned int)"rializeEv" & (v35 >> 12)) + 8];
    do
    {
      if ( v34 <= 2147483650.0 )
      {
        if ( v34 < -2147483650.0 )
        {
          *(_DWORD *)v11 = 0x80000000;
          ++result;
        }
        else
        {
          *(_DWORD *)v11 = (int)v34;
        }
      }
      else
      {
        *(_DWORD *)v11 = 0x7FFFFFFF;
        ++result;
      }
      v37 -= 0x8000;
      v11 += 8;
    }
    while ( v37 >= 0x10000 );
    p_ntom_step = &fr->ntom_step;
    v19 = v19 - 0x8000 - v36;
  }
  v40 = 15;
  v41 = &v32[2 * v59];
  do
  {
    v42 = v31;
    v43 = *p_ntom_step + v19;
    if ( v43 >= 0x8000 )
    {
      v58 = *p_ntom_step;
      v44 = ~v43;
      v45 = v43 + 0x8000;
      v46 = v19 - 0x8000;
      v60 = v42;
      v47 = (-(*(v41 - 1) * *v42)
           - *(v41 - 2) * *(v30 - 15)
           - *(v41 - 3) * *(v30 - 14)
           - *(v41 - 4) * *(v30 - 13)
           - *(v41 - 5) * *(v30 - 12)
           - *(v41 - 6) * *(v30 - 11)
           - *(v41 - 7) * *(v30 - 10)
           - *(v41 - 8) * *(v30 - 9)
           - *(v41 - 9) * *(v30 - 8)
           - *(v41 - 10) * *(v30 - 7)
           - *(v41 - 11) * *(v30 - 6)
           - *(v41 - 12) * *(v30 - 5)
           - *(v41 - 13) * *(v30 - 4)
           - *(v41 - 14) * *(v30 - 3)
           - *(v41 - 15) * *(v30 - 2)
           - *(v41 - 16) * *(v30 - 1))
          * 65536.0;
      if ( ~v43 <= -65536 )
        v44 = -65536;
      v48 = ((unsigned int)(v45 + v44) >> 14) & 0x3FFFE;
      v49 = (v45 + v44) & 0xFFFF8000;
      v50 = v38;
      do
      {
        if ( v47 <= 2147483650.0 )
        {
          if ( v47 < -2147483650.0 )
          {
            *(_DWORD *)v38 = 0x80000000;
            ++result;
          }
          else
          {
            *(_DWORD *)v38 = (int)v47;
          }
        }
        else
        {
          *(_DWORD *)v38 = 0x7FFFFFFF;
          ++result;
        }
        v45 -= 0x8000;
        v38 += 8;
      }
      while ( v45 >= 0x10000 );
      v19 = v46 + v58 - v49;
      v51 = &v50[4 * v48];
      v42 = v60;
      p_ntom_step = &fr->ntom_step;
      v38 = v51 + 8;
    }
    else
    {
      v19 += *p_ntom_step;
    }
    v31 = v42 - 16;
    v41 -= 32;
    --v40;
    v30 = v42;
  }
  while ( v40 );
  fr->INT123_ntom_val[channel] = v19;
  if ( final )
  {
    if ( channel )
      v38 -= 4;
    fr->buffer.fill = v38 - (char *)fr->buffer.data;
  }
  return result;
}

//----- (0023ACCE) --------------------------------------------------------
int __fastcall INT123_synth_ntom_s32_m2s(double *bandPtr, mpg123_handle *fr)
{
  unsigned __int8 *data; // r8
  size_t fill; // r5
  int result; // r0
  size_t *p_fill; // r1
  unsigned __int8 *v7; // r2
  unsigned int v8; // r3
  int v9; // r6
  unsigned __int8 *v10; // r4

  data = fr->buffer.data;
  fill = fr->buffer.fill;
  result = j_INT123_synth_ntom_s32(bandPtr, 0, fr, 1);
  if ( fr->buffer.fill - fill >= 8 )
  {
    p_fill = &fr->buffer.fill;
    v7 = &data[fill];
    v8 = 0;
    do
    {
      v9 = *(_DWORD *)&v7[8 * v8];
      v10 = &v7[8 * v8++];
      *((_DWORD *)v10 + 1) = v9;
    }
    while ( v8 < (*p_fill - fill) >> 3 );
  }
  return result;
}

//----- (0023B100) --------------------------------------------------------
int __fastcall check_bom(const unsigned __int8 **source, size_t *len)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  bool v4; // zf
  int v5; // r4
  int result; // r0

  if ( *len < 2 )
    return 0;
  v2 = *source;
  v3 = **source;
  if ( v3 == 255 )
  {
    if ( v2[1] == 254 )
    {
      v5 = -1;
      goto LABEL_10;
    }
    return 0;
  }
  v4 = v3 == 254;
  if ( v3 == 254 )
    v4 = v2[1] == 255;
  if ( !v4 )
    return 0;
  v5 = 1;
LABEL_10:
  *source = v2 + 2;
  *len -= 2;
  result = check_bom(source, len);
  if ( !result )
    return v5;
  return result;
}

//----- (0023B144) --------------------------------------------------------
void __fastcall store_id3_text(
        mpg123_string *sb,
        unsigned __int8 *source,
        size_t source_size,
        const int noquiet,
        const int notranslate)
{
  __int64 v9; // r0

  if ( source_size )
  {
    if ( notranslate )
    {
      v9 = *(_QWORD *)&sb->p;
      if ( sb->size == source_size )
      {
LABEL_7:
        qmemcpy((void *)v9, source, source_size);
        sb->fill = source_size;
        return;
      }
      if ( (_DWORD)v9 )
      {
        LODWORD(v9) = realloc((void *)v9, source_size);
        if ( (_DWORD)v9 )
        {
LABEL_6:
          sb->p = (unsigned __int8 *)v9;
          sb->size = source_size;
          goto LABEL_7;
        }
      }
      else
      {
        LODWORD(v9) = malloc(source_size);
        if ( (_DWORD)v9 )
          goto LABEL_6;
      }
      if ( noquiet )
        sub_18E374(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: Cannot resize target string, out of memory?\n",
          203);
    }
    else
    {
      j_INT123_id3_to_utf8(sb, *source, source + 1, source_size - 1, noquiet);
      if ( noquiet && !sb->fill )
        sub_18E374(
          (FILE *)stderr,
          "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/id3.c:%i] error: unable to convert string to UTF-8 "
          "(out of memory, junk input?)!\n",
          215);
    }
  }
}

//----- (0023B1EC) --------------------------------------------------------
void __fastcall dct12(double *in, double *rawout1, double *rawout2, double *wi, double *ts)
{
  double v5; // d16
  double v6; // d20
  double v7; // d21
  double v8; // d22
  double v9; // d18
  double v10; // d19
  double v11; // d17
  double v12; // d23
  double v13; // d16
  double v14; // d21
  double v15; // d24
  double v16; // d25
  double v17; // d26
  double v18; // d21
  double v19; // d27
  double v20; // d22
  double v21; // d19
  double v22; // d17
  double v23; // d16
  double v24; // d18
  double v25; // d20
  double v26; // d23
  double v27; // d21
  double v28; // d17
  double v29; // d16
  double v30; // d18
  double v31; // d21
  double v32; // d16
  double v33; // d16
  double v34; // d20
  double v35; // d21
  double v36; // d22
  double v37; // d18
  double v38; // d19
  double v39; // d17
  double v40; // d16
  double v41; // d21
  double v42; // d25
  double v43; // d27
  double v44; // d21
  double v45; // d22
  double v46; // d17
  double v47; // d19
  double v48; // d16
  double v49; // d18
  double v50; // d20
  double v51; // d23
  double v52; // d16
  double v53; // d17
  double v54; // d21
  double v55; // d18
  double v56; // d16
  double v57; // d16
  double v58; // d20
  double v59; // d21
  double v60; // d22
  double v61; // d18
  double v62; // d19
  double v63; // d17
  double v64; // d16
  double v65; // d21
  double v66; // d25
  double v67; // d27
  double v68; // d21
  double v69; // d22
  double v70; // d17
  double v71; // d19
  double v72; // d16
  double v73; // d18
  double v74; // d20
  double v75; // d23
  double v76; // d16
  double v77; // d17
  double v78; // d21
  double v79; // d18
  double v80; // d16

  *ts = *rawout1;
  ts[32] = rawout1[1];
  ts[64] = rawout1[2];
  ts[96] = rawout1[3];
  ts[128] = rawout1[4];
  ts[160] = rawout1[5];
  v5 = in[12];
  v6 = in[6];
  v7 = in[9];
  v8 = v7 + v6;
  v9 = *in;
  v10 = in[3];
  v11 = in[15] + v5 + v7 + v6;
  v12 = v10 + *in;
  v13 = v5 + v7;
  v14 = (v12 - v11) * tfcos12[1];
  v15 = *in - v13;
  v16 = v15 + v14;
  v17 = (v15 + v14) * wi[10];
  v18 = v15 - v14;
  v19 = COS6_1;
  ts[512] = rawout1[16] + v17;
  v20 = v19 * (v8 + v12);
  ts[416] = rawout1[13] + v16 * wi[7];
  ts[224] = rawout1[7] + v18 * wi[1];
  v21 = (v6 + v10) * v19;
  ts[320] = rawout1[10] + v18 * wi[4];
  v22 = v12 + v11 * COS6_2;
  v23 = v9 + v13 * COS6_2;
  v24 = tfcos12[2] * (v22 - v20);
  v25 = v23 - v21;
  v26 = v23 - v21 + v24;
  v27 = tfcos12[0];
  ts[544] = rawout1[17] + wi[11] * v26;
  v28 = v27 * (v20 + v22);
  v29 = v21 + v23;
  v30 = v25 - v24;
  v31 = v29 + v28;
  ts[384] = rawout1[12] + v26 * wi[6];
  ts[448] = rawout1[14] + (v29 + v28) * wi[8];
  v32 = v29 - v28;
  ts[480] = rawout1[15] + v31 * wi[9];
  ts[192] = rawout1[6] + v30 * *wi;
  ts[352] = rawout1[11] + v30 * wi[5];
  ts[256] = rawout1[8] + v32 * wi[2];
  ts[288] = rawout1[9] + v32 * wi[3];
  v33 = in[13];
  v34 = in[7];
  v35 = in[10];
  v36 = v35 + v34;
  v37 = in[1];
  v38 = in[4];
  v39 = in[16] + v33 + v35 + v34;
  v40 = v33 + v35;
  v41 = (v38 + v37 - v39) * tfcos12[1];
  v42 = v37 - v40 + v41;
  v43 = COS6_1;
  rawout2[4] = wi[10] * v42;
  v44 = v37 - v40 - v41;
  rawout2[1] = v42 * wi[7];
  ts[416] = ts[416] + v44 * wi[1];
  v45 = v43 * (v36 + v38 + v37);
  ts[512] = ts[512] + v44 * wi[4];
  v46 = v38 + v37 + v39 * COS6_2;
  v47 = (v34 + v38) * v43;
  v48 = v37 + v40 * COS6_2;
  v49 = tfcos12[2] * (v46 - v45);
  v50 = v48 - v47;
  v51 = v48 - v47 + v49;
  v52 = v47 + v48;
  v53 = tfcos12[0] * (v45 + v46);
  rawout2[5] = wi[11] * v51;
  v54 = v52 + v53;
  *rawout2 = v51 * wi[6];
  v55 = v50 - v49;
  rawout2[2] = (v52 + v53) * wi[8];
  v56 = v52 - v53;
  rawout2[3] = v54 * wi[9];
  ts[384] = ts[384] + v55 * *wi;
  ts[544] = ts[544] + v55 * wi[5];
  ts[448] = ts[448] + v56 * wi[2];
  ts[480] = ts[480] + v56 * wi[3];
  rawout2[16] = 0.0;
  rawout2[17] = 0.0;
  rawout2[14] = 0.0;
  rawout2[15] = 0.0;
  rawout2[12] = 0.0;
  rawout2[13] = 0.0;
  v57 = in[14];
  v58 = in[8];
  v59 = in[11];
  v60 = v59 + v58;
  v61 = in[2];
  v62 = in[5];
  v63 = in[17] + v57 + v59 + v58;
  v64 = v57 + v59;
  v65 = (v62 + v61 - v63) * tfcos12[1];
  v66 = v61 - v64 + v65;
  v67 = COS6_1;
  rawout2[10] = wi[10] * v66;
  v68 = v61 - v64 - v65;
  rawout2[7] = v66 * wi[7];
  rawout2[1] = rawout2[1] + v68 * wi[1];
  v69 = v67 * (v60 + v62 + v61);
  rawout2[4] = rawout2[4] + v68 * wi[4];
  v70 = v62 + v61 + v63 * COS6_2;
  v71 = (v58 + v62) * v67;
  v72 = v61 + v64 * COS6_2;
  v73 = tfcos12[2] * (v70 - v69);
  v74 = v72 - v71;
  v75 = v72 - v71 + v73;
  v76 = v71 + v72;
  v77 = tfcos12[0] * (v69 + v70);
  rawout2[11] = wi[11] * v75;
  v78 = v76 + v77;
  rawout2[6] = v75 * wi[6];
  v79 = v74 - v73;
  rawout2[8] = (v76 + v77) * wi[8];
  v80 = v76 - v77;
  rawout2[9] = v78 * wi[9];
  *rawout2 = *rawout2 + v79 * *wi;
  rawout2[5] = rawout2[5] + v79 * wi[5];
  rawout2[2] = rawout2[2] + v80 * wi[2];
  rawout2[3] = rawout2[3] + v80 * wi[3];
}

//----- (0023B6FC) --------------------------------------------------------
int __fastcall synth_stereo_wrap(double *bandPtr_l, double *bandPtr_r, mpg123_handle *fr)
{
  int v5; // r6

  v5 = ((int (__fastcall *)(double *, _DWORD))fr->synth)(bandPtr_l, 0);
  return fr->synth(bandPtr_r, 1, fr, 1) + v5;
}

//----- (0023B72E) --------------------------------------------------------
int __fastcall bad_init(mpg123_handle *mh)
{
  mh->err = 24;
  return -1;
}

//----- (0023B73E) --------------------------------------------------------
ssize_t __fastcall bad_fullread(mpg123_handle *mh, unsigned __int8 *data, ssize_t count)
{
  mh->err = 24;
  return -1;
}

//----- (0023B74C) --------------------------------------------------------
int __fastcall bad_head_read(mpg123_handle *mh, unsigned int *newhead)
{
  mh->err = 24;
  return -1;
}

//----- (0023B75A) --------------------------------------------------------
int __fastcall bad_head_shift(mpg123_handle *mh, unsigned int *head)
{
  mh->err = 24;
  return -1;
}

//----- (0023B768) --------------------------------------------------------
off_t __fastcall bad_skip_bytes(mpg123_handle *mh, off_t len)
{
  mh->err = 24;
  return -1;
}

//----- (0023B776) --------------------------------------------------------
int __fastcall bad_read_frame_body(mpg123_handle *mh, unsigned __int8 *data, int size)
{
  mh->err = 24;
  return -1;
}

//----- (0023B784) --------------------------------------------------------
int __fastcall bad_back_bytes(mpg123_handle *mh, off_t bytes)
{
  mh->err = 24;
  return -1;
}

//----- (0023B792) --------------------------------------------------------
int __fastcall bad_seek_frame(mpg123_handle *mh, off_t num)
{
  mh->err = 24;
  return -1;
}

//----- (0023B7A0) --------------------------------------------------------
off_t __fastcall bad_tell(mpg123_handle *mh)
{
  mh->err = 24;
  return -1;
}

//----- (0023B7B0) --------------------------------------------------------
int __fastcall default_init(mpg123_handle *fr)
{
  ssize_t (*r_read)(int, void *, size_t); // r6
  ssize_t (*v3)(int, void *, size_t); // r2
  off_t (*r_lseek)(int, off_t, int); // r1
  off_t (*r_lseek_handle)(int, off_t, int); // r3
  int icy_interval; // r5
  char flags; // r6
  int *p_flags; // r9
  int v9; // r0
  off_t v10; // r10
  off_t (**p_lseek)(int, off_t, int); // r6
  int v12; // r0
  off_t (*v13)(void *, off_t, int); // r3
  int v14; // r0
  off_t (*v15)(void *, off_t, int); // r3
  bool v16; // cc
  int v17; // r6
  int v18; // r5
  int v19; // r2
  reader *rd; // r6
  reader *v21; // r3
  ssize_t (*v22)(mpg123_handle *, unsigned __int8 *, ssize_t); // r2

  r_read = fr->rdat.r_read;
  v3 = posix_read;
  r_lseek = fr->rdat.r_lseek;
  r_lseek_handle = posix_lseek;
  icy_interval = fr->p.icy_interval;
  fr->rdat.fdread = plain_read;
  if ( r_read )
    v3 = r_read;
  flags = fr->rdat.flags;
  fr->rdat.read = v3;
  if ( r_lseek )
    r_lseek_handle = r_lseek;
  p_flags = &fr->rdat.flags;
  if ( icy_interval > 0 )
    r_lseek_handle = nix_lseek;
  fr->rdat.lseek = r_lseek_handle;
  if ( (flags & 0x40) != 0 )
  {
    r_lseek_handle = (off_t (*)(int, off_t, int))fr->rdat.r_lseek_handle;
    if ( !r_lseek_handle )
      goto LABEL_29;
    v9 = 45808;
  }
  else
  {
    v9 = 45804;
  }
  v10 = r_lseek_handle(*(int *)((char *)&fr->fresh + v9), 0, 2);
  if ( v10 >= 0 )
  {
    p_lseek = &fr->rdat.lseek;
    if ( (*(_BYTE *)p_flags & 0x40) != 0 )
    {
      v13 = fr->rdat.r_lseek_handle;
      if ( !v13 )
        goto LABEL_29;
      v12 = v13(fr->rdat.iohandle, -128, 2);
    }
    else
    {
      v12 = (*p_lseek)(fr->rdat.filept, -128, 2);
    }
    if ( v12 >= 0 && fr->rd->fullread(fr, fr->id3buf, 128) == 128 )
    {
      if ( !strncmp((const char *)fr->id3buf, (const char *)&dword_23B9BC, 3u) )
        v10 -= 128;
      if ( (*(_BYTE *)p_flags & 0x40) != 0 )
      {
        v15 = fr->rdat.r_lseek_handle;
        if ( !v15 )
          goto LABEL_29;
        v14 = v15(fr->rdat.iohandle, 0, 0);
      }
      else
      {
        v14 = (*p_lseek)(fr->rdat.filept, 0, 0);
      }
      v16 = v10 < 1;
      if ( v10 >= 1 )
        v16 = v14 < 0;
      if ( !v16 )
      {
        v17 = 0;
        fr->rdat.filepos = 0;
        fr->rdat.filelen = v10;
        v18 = *p_flags;
        *p_flags |= 4u;
        if ( !strncmp((const char *)fr->id3buf, (const char *)&dword_23B9BC, 3u) )
        {
          *p_flags = v18 | 6;
          v17 = 0;
          fr->metaflags |= 1u;
        }
        return v17;
      }
    }
  }
LABEL_29:
  v17 = 0;
  fr->rdat.filepos = 0;
  fr->rdat.filelen = -1;
  v19 = fr->p.flags;
  if ( (v19 & 0x100) == 0 )
    return v17;
  rd = fr->rd;
  if ( rd == readers )
  {
    v21 = &readers[3];
    v22 = plain_fullread;
LABEL_37:
    v17 = 0;
    fr->rd = v21;
    fr->rdat.buffer.fileoff = 0;
    fr->rdat.buffer.firstpos = 0;
    fr->rdat.fullread = v22;
    *(_QWORD *)&fr->rdat.buffer.first = 0LL;
    *(_QWORD *)&fr->rdat.buffer.size = 0LL;
    fr->rdat.filelen = 0;
    *p_flags |= 8u;
    return v17;
  }
  if ( rd == &readers[1] )
  {
    v21 = &readers[4];
    v22 = icy_fullread;
    goto LABEL_37;
  }
  if ( (v19 & 0x20) == 0 )
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: mpg123 Programmer's fault: invalid reader\n",
      987);
  return -1;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 23B9BC: using guessed type int dword_23B9BC;

//----- (0023B9D8) --------------------------------------------------------
void __fastcall stream_close(mpg123_handle *fr)
{
  int flags; // r0
  int *p_filept; // r5
  int *p_flags; // r8
  buffy *first; // r5
  buffy *next; // r6
  void (*cleanup_handle)(void *); // r1
  void **p_iohandle; // r4

  flags = fr->rdat.flags;
  p_filept = &fr->rdat.filept;
  p_flags = &fr->rdat.flags;
  if ( (flags & 1) != 0 )
  {
    close(*p_filept);
    flags = *p_flags;
  }
  *p_filept = 0;
  if ( (flags & 8) == 0 )
  {
    if ( (flags & 0x40) == 0 )
      return;
    goto LABEL_10;
  }
  first = fr->rdat.buffer.first;
  if ( first )
  {
    do
    {
      next = first->next;
      free(first->data);
      free(first);
      first = next;
    }
    while ( next );
    flags = *p_flags;
  }
  fr->rdat.buffer.fileoff = 0;
  *(_QWORD *)&fr->rdat.buffer.first = 0LL;
  *(_QWORD *)&fr->rdat.buffer.size = 0LL;
  fr->rdat.buffer.firstpos = 0;
  if ( (flags & 0x40) != 0 )
  {
LABEL_10:
    cleanup_handle = fr->rdat.cleanup_handle;
    p_iohandle = &fr->rdat.iohandle;
    if ( cleanup_handle )
      cleanup_handle(*p_iohandle);
    *p_iohandle = 0;
  }
}

//----- (0023BA6C) --------------------------------------------------------
ssize_t __fastcall plain_fullread(mpg123_handle *fr, unsigned __int8 *buf, ssize_t count)
{
  ssize_t (**p_fdread)(mpg123_handle *, void *, size_t); // r9
  off_t *p_filepos; // r10
  ssize_t v8; // r5
  int v9; // r0

  if ( count < 1 )
    return 0;
  p_fdread = &fr->rdat.fdread;
  p_filepos = &fr->rdat.filepos;
  v8 = 0;
  while ( 1 )
  {
    v9 = (*p_fdread)(fr, &buf[v8], count - v8);
    if ( v9 < 0 )
      break;
    if ( v9 )
    {
      v8 += v9;
      if ( (fr->rdat.flags & 8) == 0 )
        *p_filepos += v9;
      if ( v8 < count )
        continue;
    }
    return v8;
  }
  return -1;
}

//----- (0023BADA) --------------------------------------------------------
int __fastcall generic_head_read(mpg123_handle *fr, unsigned int *newhead)
{
  ssize_t v3; // r0
  unsigned int v5[3]; // [sp+4h] [bp-Ch] BYREF

  v3 = fr->rd->fullread(fr, (unsigned __int8 *)v5, 4);
  if ( v3 == -10 )
    return -10;
  if ( v3 != 4 )
    return 0;
  *newhead = bswap32(v5[0]);
  return 1;
}
// 23BADA: using guessed type unsigned int var_C[3];

//----- (0023BB14) --------------------------------------------------------
int __fastcall generic_head_shift(mpg123_handle *fr, unsigned int *head)
{
  ssize_t v3; // r0
  char v5[9]; // [sp+7h] [bp-9h] BYREF

  v3 = fr->rd->fullread(fr, (unsigned __int8 *)v5, 1);
  if ( v3 == -10 )
    return -10;
  if ( v3 != 1 )
    return 0;
  *head = (unsigned __int8)v5[0] | (*head << 8);
  return 1;
}
// 23BB14: using guessed type char var_9[9];

//----- (0023BB58) --------------------------------------------------------
off_t __fastcall stream_skip_bytes(mpg123_handle *fr, off_t len)
{
  off_t v3; // r5
  int flags; // r0
  reader **p_rd; // r6
  int v6; // r2
  off_t result; // r0
  off_t (*r_lseek_handle)(void *, off_t, int); // r3
  ssize_t pos; // r0
  char v10[1024]; // [sp+4h] [bp-414h] BYREF

  v3 = len;
  flags = fr->rdat.flags;
  if ( (flags & 4) != 0 )
  {
    if ( (flags & 0x40) != 0 )
    {
      r_lseek_handle = fr->rdat.r_lseek_handle;
      if ( !r_lseek_handle )
        goto LABEL_16;
      result = r_lseek_handle(fr->rdat.iohandle, len, 1);
    }
    else
    {
      result = fr->rdat.lseek(fr->rdat.filept, len, 1);
    }
    if ( result >= 0 )
    {
      fr->rdat.filepos = result;
      goto LABEL_17;
    }
LABEL_16:
    fr->err = 40;
    result = -1;
LABEL_17:
    if ( result <= -1 )
      return -1;
    return result;
  }
  if ( len < 0 )
  {
    if ( (flags & 8) != 0 && (pos = fr->rdat.buffer.pos, pos >= -len) )
    {
      fr->rdat.buffer.pos = pos + len;
      return fr->rd->tell(fr);
    }
    else
    {
      fr->err = 23;
      return -1;
    }
  }
  else
  {
    p_rd = &fr->rd;
    do
    {
      if ( v3 < 1 )
        break;
      v6 = v3;
      if ( v3 >= 1024 )
        v6 = 1024;
      result = (*p_rd)->fullread(fr, (unsigned __int8 *)v10, v6);
      if ( result < 0 )
        return result;
      v3 -= result;
    }
    while ( result );
    return (*p_rd)->tell(fr);
  }
}
// 23BB58: using guessed type char var_414[1024];

//----- (0023BC7C) --------------------------------------------------------
int __fastcall generic_read_frame_body(mpg123_handle *fr, unsigned __int8 *buf, int size)
{
  int result; // r0

  result = fr->rd->fullread(fr, buf, size);
  if ( result != size )
    return -10;
  return result;
}

//----- (0023BC98) --------------------------------------------------------
int __fastcall stream_back_bytes(mpg123_handle *fr, off_t bytes)
{
  int v4; // r6
  off_t v5; // r1
  int result; // r0

  v4 = fr->rd->tell(fr) - bytes;
  if ( v4 < 0 )
    return -1;
  v5 = stream_skip_bytes(fr, -bytes);
  result = 0;
  if ( v5 != v4 )
    return -1;
  return result;
}

//----- (0023BCE0) --------------------------------------------------------
int __fastcall stream_seek_frame(mpg123_handle *fr, off_t newframe)
{
  off_t v4; // r9
  off_t audio_start; // r8
  unsigned __int8 *xing_toc; // r0
  off_t filelen; // r1
  off_t track_frames; // r2
  bool v9; // cc
  double v10; // d18
  int v11; // r2
  double mean_framesize; // d16
  off_t *p_num; // r6
  off_t num; // r0
  off_t v15; // r0

  if ( (fr->rdat.flags & 4) == 0 && fr->num > newframe )
  {
    fr->err = 23;
    return -1;
  }
  if ( (fr->p.flags & 0x200) != 0 )
  {
    xing_toc = fr->xing_toc;
    audio_start = fr->audio_start;
    if ( !xing_toc )
      goto LABEL_15;
    filelen = 37736;
    track_frames = fr->track_frames;
    v9 = track_frames < 1;
    if ( track_frames >= 1 )
    {
      filelen = fr->rdat.filelen;
      v9 = filelen < 1;
    }
    if ( v9 )
    {
LABEL_15:
      mean_framesize = fr->mean_framesize;
      if ( mean_framesize <= 0.0 )
      {
        v4 = 0;
      }
      else
      {
        v4 = newframe;
        *(_WORD *)&fr->accurate = 256;
        audio_start = (int)(mean_framesize * (double)newframe + (double)audio_start);
      }
    }
    else
    {
      v10 = (double)track_frames;
      *(_WORD *)&fr->accurate = 256;
      v11 = (int)((double)newframe * 100.0 / (double)track_frames);
      if ( v11 <= 0 )
        v11 = 0;
      if ( v11 >= 99 )
        v11 = 99;
      audio_start = (int)((double)xing_toc[v11] * 0.00390625 * (double)filelen);
      v4 = (int)((double)v11 / 100.0 * v10);
    }
  }
  else
  {
    v4 = 0;
    fr->oldhead = 0;
    audio_start = 0;
    fr->firsthead = 0;
  }
  p_num = &fr->num;
  num = fr->num;
  if ( num < newframe && num >= v4 )
    goto LABEL_24;
  v15 = fr->rd->tell(fr);
  if ( fr->rd->skip_bytes(fr, audio_start - v15) != audio_start )
    return -1;
  *p_num = v4 - 1;
  if ( v4 - 1 < newframe )
  {
    do
    {
      if ( !j_INT123_read_frame(fr) )
        break;
      num = *p_num;
LABEL_24:
      ;
    }
    while ( num < newframe );
  }
  return 0;
}

//----- (0023BE88) --------------------------------------------------------
off_t __fastcall generic_tell(mpg123_handle *fr)
{
  off_t v2; // r1

  if ( (fr->rdat.flags & 8) == 0 )
    return fr->rdat.filepos;
  v2 = fr->rdat.buffer.fileoff + fr->rdat.buffer.pos;
  fr->rdat.filepos = v2;
  return v2;
}

//----- (0023BEB4) --------------------------------------------------------
void __fastcall stream_rewind(mpg123_handle *fr)
{
  int flags; // r0
  off_t v3; // r0
  off_t (*r_lseek_handle)(void *, off_t, int); // r3
  off_t *p_filepos; // r1

  flags = fr->rdat.flags;
  if ( (flags & 4) == 0 )
    goto LABEL_10;
  if ( (flags & 0x40) != 0 )
  {
    r_lseek_handle = fr->rdat.r_lseek_handle;
    if ( !r_lseek_handle )
    {
LABEL_8:
      fr->err = 40;
      p_filepos = &fr->rdat.filepos;
      v3 = -1;
      goto LABEL_9;
    }
    v3 = r_lseek_handle(fr->rdat.iohandle, 0, 0);
  }
  else
  {
    v3 = fr->rdat.lseek(fr->rdat.filept, 0, 0);
  }
  if ( v3 < 0 )
    goto LABEL_8;
  fr->rdat.filepos = v3;
  p_filepos = &fr->rdat.filepos;
LABEL_9:
  *p_filepos = v3;
  fr->rdat.buffer.fileoff = v3;
  flags = fr->rdat.flags;
LABEL_10:
  if ( (flags & 8) != 0 )
  {
    fr->rdat.buffer.firstpos = 0;
    fr->rdat.buffer.pos = 0;
    fr->rdat.filepos = fr->rdat.buffer.fileoff;
  }
}

//----- (0023BF3C) --------------------------------------------------------
ssize_t __fastcall icy_fullread(mpg123_handle *fr, unsigned __int8 *buf, ssize_t count)
{
  unsigned __int8 *v4; // r6
  ssize_t v5; // r11
  int *p_flags; // r9
  off_t *p_filepos; // r8
  ssize_t (**p_fdread)(mpg123_handle *, void *, size_t); // r10
  off_t next; // r2
  ssize_t result; // r0
  unsigned __int8 *v11; // r6
  int v12; // r11
  int v13; // r0
  int v14; // r0
  off_t v15; // r5
  unsigned __int8 *v16; // r0
  char *v17; // r6
  int v18; // r0
  int v19; // r1
  int v20; // r5
  int v21; // r0
  unsigned __int8 *v22; // [sp+4h] [bp-4Ch]
  icy_meta *p_icy; // [sp+14h] [bp-3Ch]
  off_t *p_interval; // [sp+18h] [bp-38h]
  ssize_t v25; // [sp+1Ch] [bp-34h]
  int *v26; // [sp+20h] [bp-30h]
  off_t *p_next; // [sp+28h] [bp-28h]
  ssize_t v29; // [sp+2Ch] [bp-24h]
  char v30[29]; // [sp+33h] [bp-1Dh] BYREF

  v4 = buf;
  v5 = count;
  if ( (fr->rdat.flags & 4) == 0 )
  {
    if ( count < 1 )
      return 0;
    p_flags = &fr->rdat.flags;
    p_icy = &fr->icy;
    v26 = &fr->p.flags;
    p_interval = &fr->icy.interval;
    p_filepos = &fr->rdat.filepos;
    p_fdread = &fr->rdat.fdread;
    next = fr->icy.next;
    p_next = &fr->icy.next;
    v25 = v5;
    result = 0;
    while ( 1 )
    {
      v20 = v5 - result;
      if ( next >= v5 - result )
      {
        if ( v20 >= 1 )
        {
          v11 = &v4[result];
          v12 = 0;
          v29 = result;
          do
          {
            v13 = (*p_fdread)(fr, &v11[v12], v20 - v12);
            if ( v13 < 0 )
              goto LABEL_44;
            if ( !v13 )
              break;
            v12 += v13;
            if ( (*(_BYTE *)p_flags & 8) == 0 )
              *p_filepos += v13;
          }
          while ( v12 < v20 );
          if ( v12 <= -1 )
          {
LABEL_44:
            if ( (*(_BYTE *)v26 & 0x20) != 0 )
              return -1;
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: reading the rest of %li\n",
              192,
              v20);
            return -1;
          }
          if ( !v12 )
            return v29;
          next = *p_next - v12;
          *p_next = next;
          v4 = buf;
          result = v29 + v12;
          v5 = v25;
          if ( result < v25 )
            continue;
        }
        return result;
      }
      if ( next < 1 )
        goto LABEL_15;
      v29 = result;
      v21 = ((int (__fastcall *)(mpg123_handle *, unsigned __int8 *))*p_fdread)(fr, &v4[result]);
      if ( v21 <= 0 )
      {
        if ( !v21 )
          return v29;
        if ( (*(_BYTE *)v26 & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: icy boundary read\n",
            133);
        return -1;
      }
      if ( (*(_BYTE *)p_flags & 8) == 0 )
        *p_filepos += v21;
      next = *p_next - v21;
      *p_next = next;
      result = v29 + v21;
      if ( next <= 0 )
      {
LABEL_15:
        v29 = result;
        v14 = (*p_fdread)(fr, v30, 1);
        if ( v14 <= -1 )
        {
          if ( (*(_BYTE *)v26 & 0x20) == 0 )
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: reading icy size\n",
              152);
          return -1;
        }
        if ( !v14 )
          return v29;
        if ( (*(_BYTE *)p_flags & 8) == 0 )
          *p_filepos += v14;
        if ( v30[0] )
        {
          v15 = 16 * (unsigned __int8)v30[0];
          v16 = (unsigned __int8 *)malloc(v15 | 1);
          if ( v16 )
          {
            v22 = v16;
            v17 = (char *)&v16[v15];
            while ( 1 )
            {
              v18 = (*p_fdread)(fr, &v17[-v15], v15);
              if ( v18 <= 0 )
                break;
              v15 -= v18;
              if ( v15 < 1 )
              {
                v19 = *p_flags;
                *v17 = 0;
                if ( (v19 & 8) == 0 )
                  *p_filepos += v18;
                v4 = buf;
                if ( p_icy->data )
                  free(p_icy->data);
                p_icy->data = v22;
                fr->metaflags |= 4u;
                goto LABEL_32;
              }
            }
            if ( (*(_BYTE *)v26 & 0x20) == 0 )
              fprintf(
                (FILE *)stderr,
                "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: reading icy-meta\n",
                170);
            return -1;
          }
          if ( (*(_BYTE *)v26 & 0x20) == 0 )
            fprintf(
              (FILE *)stderr,
              "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: cannot allocate memory for"
              " meta_buff (%lu bytes) ... trying to skip the metadata!\n",
              183,
              v15);
          fr->rd->skip_bytes(fr, v15);
        }
LABEL_32:
        next = *p_interval;
        *p_next = *p_interval;
        result = v29;
        if ( v29 >= v5 )
          return result;
      }
      else if ( result >= v5 )
      {
        return result;
      }
    }
  }
  if ( (fr->p.flags & 0x20) != 0 )
    return -1;
  fprintf(
    (FILE *)stderr,
    "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: mpg123 programmer error: I don't do "
    "ICY on seekable streams.\n",
    104);
  return -1;
}
// 23BF3C: using guessed type char var_1D[29];

//----- (0023C20C) --------------------------------------------------------
int __fastcall feed_init(mpg123_handle *fr)
{
  int flags; // r3

  fr->rdat.buffer.fileoff = 0;
  fr->rdat.buffer.firstpos = 0;
  fr->rdat.filepos = 0;
  fr->rdat.filelen = 0;
  flags = fr->rdat.flags;
  *(_QWORD *)&fr->rdat.buffer.first = 0LL;
  *(_QWORD *)&fr->rdat.buffer.size = 0LL;
  fr->rdat.flags = flags | 8;
  return 0;
}

//----- (0023C244) --------------------------------------------------------
ssize_t __fastcall feed_read(mpg123_handle *fr, unsigned __int8 *out, ssize_t count)
{
  ssize_t pos; // r1
  ssize_t *p_pos; // r9
  ssize_t v7; // r11
  buffy *first; // r5
  int v9; // r4
  ssize_t size; // r0
  int v11; // r1
  ssize_t v12; // r6
  bool v13; // cc
  unsigned __int8 *v14; // r1
  ssize_t v15; // r0
  buffy *i; // r1
  buffy *v17; // r6
  ssize_t v18; // r1
  size_t v19; // r5
  int v20; // r1
  int v21; // r0
  unsigned __int8 *v22; // r1
  ssize_t result; // r0

  pos = fr->rdat.buffer.pos;
  p_pos = &fr->rdat.buffer.pos;
  if ( fr->rdat.buffer.size - pos >= count )
  {
    first = fr->rdat.buffer.first;
    if ( !first )
      goto LABEL_18;
    v9 = 0;
    while ( 1 )
    {
      size = first->size;
      if ( size + v9 > pos )
        break;
      first = first->next;
      v9 += size;
      if ( !first )
        goto LABEL_18;
    }
    if ( count >= 1 )
    {
      v11 = pos - v9;
      v12 = size - v11;
      v7 = count;
      v13 = size - v11 < count;
      v14 = &first->data[v11];
      if ( v13 )
        v7 = v12;
      qmemcpy(out, v14, v7);
      v15 = *p_pos + v7;
      *p_pos = v15;
      if ( v12 < count )
      {
        for ( i = first->next; i; first = v17 )
        {
          v17 = i;
          v18 = first->size;
          v19 = count - v7;
          v9 += v18;
          v20 = v15 - v9;
          v21 = v17->size - (v15 - v9);
          v22 = &v17->data[v20];
          if ( count - v7 > v21 )
            v19 = v21;
          qmemcpy(&out[v7], v22, v19);
          v7 += v19;
          v15 = *p_pos + v19;
          *p_pos = v15;
          if ( v7 >= count )
            break;
          i = v17->next;
        }
      }
    }
    else
    {
LABEL_18:
      v7 = 0;
    }
  }
  else
  {
    v7 = -10;
    *p_pos = fr->rdat.buffer.firstpos;
  }
  result = v7;
  if ( v7 != count )
    result = -1;
  if ( v7 < 0 )
    return v7;
  return result;
}

//----- (0023C322) --------------------------------------------------------
off_t __fastcall feed_skip_bytes(mpg123_handle *fr, off_t len)
{
  off_t result; // r0
  ssize_t pos; // r0
  ssize_t *p_pos; // r12

  if ( len < 0 )
    return -1;
  pos = fr->rdat.buffer.pos;
  p_pos = &fr->rdat.buffer.pos;
  if ( fr->rdat.buffer.size - pos >= len )
  {
    result = pos + len;
    *p_pos = result;
    if ( result >= 0 )
      result += fr->rdat.buffer.fileoff;
  }
  else
  {
    *p_pos = fr->rdat.buffer.firstpos;
    return -10;
  }
  return result;
}

//----- (0023C368) --------------------------------------------------------
int __fastcall feed_back_bytes(mpg123_handle *fr, off_t bytes)
{
  ssize_t v2; // r2
  ssize_t v3; // r1
  ssize_t pos; // r3
  ssize_t *p_pos; // r12
  int v7; // r1

  if ( bytes < 0 )
  {
    pos = fr->rdat.buffer.pos;
    p_pos = &fr->rdat.buffer.pos;
    if ( fr->rdat.buffer.size - pos >= -bytes )
    {
      v7 = pos - bytes;
      *p_pos = v7;
      if ( v7 >= 0 )
        v7 += fr->rdat.buffer.fileoff;
      return v7 >> 31;
    }
    else
    {
      *p_pos = fr->rdat.buffer.firstpos;
      return -1;
    }
  }
  else
  {
    v2 = fr->rdat.buffer.pos;
    if ( v2 >= bytes )
    {
      v3 = v2 - bytes;
      fr->rdat.buffer.pos = v3;
    }
    else
    {
      v3 = -1;
    }
    return v3 >> 31;
  }
}

//----- (0023C3CE) --------------------------------------------------------
int __fastcall feed_seek_frame(mpg123_handle *fr, off_t num)
{
  return -1;
}

//----- (0023C3D4) --------------------------------------------------------
void __fastcall buffered_forget(mpg123_handle *fr)
{
  buffy *first; // r5
  ssize_t *p_pos; // r10
  bufferchain *p_buffer; // r1
  ssize_t *p_size; // r6
  off_t *p_fileoff; // r4
  ssize_t size; // r1
  ssize_t v8; // r0
  buffy *next; // r8
  ssize_t v10; // r1
  bufferchain *v11; // [sp+0h] [bp-20h]

  first = fr->rdat.buffer.first;
  p_pos = &fr->rdat.buffer.pos;
  p_buffer = &fr->rdat.buffer;
  if ( first )
  {
    p_size = &fr->rdat.buffer.size;
    p_fileoff = &fr->rdat.buffer.fileoff;
    v11 = &fr->rdat.buffer;
    while ( 1 )
    {
      size = first->size;
      v8 = *p_pos;
      if ( *p_pos < size )
        break;
      next = first->next;
      if ( !next )
      {
        fr->rdat.buffer.last = 0;
        size = first->size;
      }
      *p_fileoff += size;
      *p_pos = v8 - first->size;
      *p_size -= first->size;
      free(first->data);
      free(first);
      first = next;
      if ( !next )
      {
        first = 0;
        break;
      }
    }
    p_buffer = v11;
  }
  else
  {
    p_fileoff = &fr->rdat.buffer.fileoff;
    first = 0;
  }
  p_buffer->first = first;
  v10 = *p_pos;
  fr->rdat.buffer.firstpos = *p_pos;
  fr->rdat.filepos = *p_fileoff + v10;
}

//----- (0023C488) --------------------------------------------------------
ssize_t __fastcall buffered_fullread(mpg123_handle *fr, unsigned __int8 *out, ssize_t count)
{
  int v4; // r9
  ssize_t pos; // r0
  ssize_t size; // r1
  int v8; // r9
  int *p_flags; // r4
  ssize_t v10; // r0
  int v11; // r11
  int v12; // r3
  int v13; // r1
  buffy *first; // r4
  int v15; // r5
  ssize_t v16; // r1
  int v17; // r0
  int v18; // r6
  signed int v19; // r8
  ssize_t v20; // r0
  buffy *i; // r1
  buffy *v22; // r6
  ssize_t v23; // r1
  size_t v24; // r4
  int v25; // r1
  int v26; // r0
  unsigned __int8 *v27; // r1
  ssize_t *p_size; // [sp+10h] [bp-1038h]
  ssize_t *p_pos; // [sp+1Ch] [bp-102Ch]
  bufferchain *bc; // [sp+20h] [bp-1028h]
  unsigned __int8 v33[4096]; // [sp+24h] [bp-1024h] BYREF

  v4 = count;
  pos = fr->rdat.buffer.pos;
  size = fr->rdat.buffer.size;
  p_pos = &fr->rdat.buffer.pos;
  bc = &fr->rdat.buffer;
  if ( size - pos < count )
  {
    v8 = count - size + pos;
    p_size = &fr->rdat.buffer.size;
    p_flags = &fr->p.flags;
    while ( v8 >= 1 )
    {
      v10 = fr->rdat.fullread(fr, v33, 4096);
      v11 = v10;
      if ( v10 <= -1 )
      {
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: buffer reading\n",
            743);
        v13 = 1;
LABEL_19:
        if ( v13 != 3 )
          return -1;
        break;
      }
      if ( !v10 )
        goto LABEL_13;
      v12 = bc_add(bc, v33, v10);
      if ( v12 )
      {
        if ( (*(_BYTE *)p_flags & 0x20) == 0 )
          fprintf(
            (FILE *)stderr,
            "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: unable to add to chain, return: %i\n",
            750,
            v12);
        v13 = 1;
        goto LABEL_19;
      }
      v8 -= v11;
      if ( v11 < 4096 )
      {
LABEL_13:
        if ( (*(_BYTE *)p_flags & 0x20) == 0 && fr->p.verbose >= 3 )
          fwrite("Note: Input data end.\n", 0x16u, 1u, (FILE *)stderr);
        v13 = 3;
        goto LABEL_19;
      }
    }
    v4 = count;
    pos = *p_pos;
    size = *p_size;
    if ( *p_size - *p_pos < count )
      v4 = *p_size - *p_pos;
  }
  if ( size - pos >= v4 )
  {
    first = bc->first;
    if ( !bc->first )
      goto LABEL_40;
    v15 = 0;
    while ( 1 )
    {
      v16 = first->size;
      if ( v16 + v15 > pos )
        break;
      first = first->next;
      v15 += v16;
      if ( !first )
        goto LABEL_40;
    }
    if ( v4 >= 1 )
    {
      v17 = pos - v15;
      v18 = v16 - v17;
      v19 = v4;
      if ( v4 > v16 - v17 )
        v19 = v16 - v17;
      qmemcpy(out, &first->data[v17], v19);
      v20 = *p_pos + v19;
      *p_pos = v20;
      if ( v4 > v18 )
      {
        for ( i = first->next; i; first = v22 )
        {
          v22 = i;
          v23 = first->size;
          v24 = v4 - v19;
          v15 += v23;
          v25 = v20 - v15;
          v26 = v22->size - (v20 - v15);
          v27 = &v22->data[v25];
          if ( v4 - v19 > v26 )
            v24 = v26;
          qmemcpy(&out[v19], v27, v24);
          v19 += v24;
          v20 = *p_pos + v24;
          *p_pos = v20;
          if ( v19 >= v4 )
            break;
          i = v22->next;
        }
      }
    }
    else
    {
LABEL_40:
      v19 = 0;
    }
    if ( v19 == v4 )
      return v4;
  }
  else
  {
    *p_pos = fr->rdat.buffer.firstpos;
    if ( v4 == -10 )
      return v4;
  }
  if ( (fr->p.flags & 0x20) == 0 )
    fprintf(
      (FILE *)stderr,
      "[C:/Projects/OSWrapper\\MPG123/mpg123-1.13.3/src/libmpg123/readers.c:%i] error: gotcount != count\n",
      768);
  return -1;
}
// 23C6CC: conditional instruction was optimized away because r0.4 is in (==1|==3)

//----- (0023C72C) --------------------------------------------------------
ssize_t __fastcall plain_read(mpg123_handle *fr, void *buf, size_t count)
{
  ssize_t (*r_read_handle)(void *, void *, size_t); // r12

  if ( (fr->rdat.flags & 0x40) == 0 )
    return fr->rdat.read(fr->rdat.filept, buf, count);
  r_read_handle = fr->rdat.r_read_handle;
  if ( r_read_handle )
    return r_read_handle(fr->rdat.iohandle, buf, count);
  else
    return -1;
}

//----- (0023C76C) --------------------------------------------------------
off_t __fastcall nix_lseek(int fd, off_t offset, int whence)
{
  return -1;
}

//----- (0023C780) --------------------------------------------------------
ALvoid __fastcall alGenAuxiliaryEffectSlots(ALsizei n, ALuint *effectslots)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_LastError; // r4
  ALsizei v5; // r5
  _BYTE *v6; // r0
  ALuint *v7; // r4
  _DWORD *v8; // r0
  ALenum inserted; // r0
  ALuint v10; // r1
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int v15; // r0
  ALenum *v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r0
  int v19; // t1
  ALCcontext *v22; // r6
  __int64 v23; // kr00_8
  int v24; // r4
  ALeffectslot **v25; // r0
  ALsizei v26; // r5
  ALvoid *v27; // r0
  __int64 v28; // kr08_8
  int v29; // t1
  unsigned int v34; // r0
  ALuint v36; // [sp+4h] [bp-3Ch]
  unsigned int v37; // [sp+8h] [bp-38h]
  ALCcontext *v38; // [sp+10h] [bp-30h]
  unsigned int *v39; // [sp+14h] [bp-2Ch]
  ALsizei v40; // [sp+18h] [bp-28h]
  UIntMap_0 *map; // [sp+1Ch] [bp-24h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    map = &ContextRef->EffectSlotMap;
    v38 = ContextRef;
    p_LastError = (unsigned int *)&ContextRef->LastError;
    v39 = (unsigned int *)&ContextRef->LastError;
    v40 = n;
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      v34 = __ldrex(p_LastError);
      v22 = v38;
      if ( v34 )
      {
LABEL_95:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_95;
        }
      }
      __dmb(0xBu);
      goto LABEL_88;
    }
    v5 = 0;
    if ( n >= 1 )
    {
      while ( 1 )
      {
        v6 = malloc(0x20F0u);
        if ( !v6 )
          break;
        *v6 = 0;
        v7 = (ALuint *)(v6 + 1);
        if ( ((unsigned int)(v6 + 1) & 0xF) != 0 )
        {
          do
          {
            *(_BYTE *)v7 = 85;
            v7 = (ALuint *)((char *)v7 + 1);
          }
          while ( ((unsigned __int8)v7 & 0xF) != 0 );
        }
        memset(v7, 0, 0x20E0u);
        v8 = calloc(1u, 0x10u);
        if ( !v8 )
        {
          v7[49] = 0;
          do
          {
            v29 = *((unsigned __int8 *)v7 - 1);
            v7 = (ALuint *)((char *)v7 - 1);
          }
          while ( v29 == 85 );
          free(v7);
          break;
        }
        *v8 = NoneDestroy;
        v8[1] = NoneDeviceUpdate;
        v8[2] = NoneUpdate;
        v8[3] = NoneProcess;
        v7[46] = 1065353216;
        v7[49] = (ALuint)v8;
        *((_BYTE *)v7 + 188) = 1;
        v7[48] = 0;
        memset(v7 + 52, 0, 0x200Cu);
        inserted = j_NewThunkEntry(v7 + 2103);
        v10 = v7[2103];
        if ( inserted || (inserted = j_InsertUIntMapEntry(map, v10, v7), v10 = v7[2103], inserted) )
        {
          v36 = v10;
          v37 = inserted;
          __dmb(0xBu);
          do
            v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
          __dmb(0xBu);
          if ( v11 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
            }
            while ( v12 == 1 );
          }
          __dmb(0xBu);
          do
            v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
          while ( 1 )
          {
            __dmb(0xBu);
            if ( v13 != 1 )
              break;
            sched_yield();
            __dmb(0xBu);
            do
              v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
          }
          __dmb(0xBu);
          do
            v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(v14 + 1, (unsigned int *)&ThunkLock.read_count) );
          __dmb(0xBu);
          if ( !v14 )
          {
            __dmb(0xBu);
            do
              v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
            while ( 1 )
            {
              __dmb(0xBu);
              if ( v15 != 1 )
                break;
              sched_yield();
              __dmb(0xBu);
              do
                v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
            }
          }
          __dmb(0xBu);
          do
            __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
          __dmb(0xBu);
          if ( v36 - 1 < ThunkArraySize )
          {
            v16 = ThunkArray;
            __dmb(0xBu);
            v17 = (unsigned int *)&v16[v36 - 1];
            do
              __ldrex(v17);
            while ( __strex(0, v17) );
            __dmb(0xBu);
          }
          __dmb(0xBu);
          do
            v18 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(v18 - 1, (unsigned int *)&ThunkLock.read_count) );
          __dmb(0xBu);
          if ( v18 == 1 )
          {
            __dmb(0xBu);
            do
              __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
            __dmb(0xBu);
          }
          (*(void (**)(void))v7[49])();
          do
          {
            v19 = *((unsigned __int8 *)v7 - 1);
            v7 = (ALuint *)((char *)v7 - 1);
          }
          while ( v19 == 85 );
          free(v7);
          if ( TrapALError )
            raise(5);
          if ( __ldrex(v39) )
          {
LABEL_55:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex(v37, v39) )
            {
              if ( __ldrex(v39) )
                goto LABEL_55;
            }
          }
          goto LABEL_86;
        }
        effectslots[v5++] = v10;
        n = v40;
        if ( v5 >= v40 )
          goto LABEL_58;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex(v39) )
        goto LABEL_85;
      __dmb(0xBu);
      while ( __strex(0xA005u, v39) )
      {
        if ( __ldrex(v39) )
          goto LABEL_85;
      }
      goto LABEL_86;
    }
LABEL_58:
    v22 = v38;
    (*(void (**)(void))(*(volatile RefCount *)((char *)&v38->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
    v23 = *(_QWORD *)&v38->ActiveEffectSlotCount;
    if ( HIDWORD(v23) - (int)v23 < n )
    {
      v24 = 2 * HIDWORD(v23);
      if ( !HIDWORD(v23) )
        v24 = 1;
      if ( v24 <= SHIDWORD(v23) || (v25 = (ALeffectslot **)realloc(v38->ActiveEffectSlots, 4 * v24)) == 0 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&v38->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
        if ( TrapALError )
          raise(5);
        if ( __ldrex(v39) )
        {
LABEL_85:
          __clrex();
        }
        else
        {
          __dmb(0xBu);
          while ( __strex(0xA005u, v39) )
          {
            if ( __ldrex(v39) )
              goto LABEL_85;
          }
        }
LABEL_86:
        __dmb(0xBu);
        v22 = v38;
        if ( v5 >= 1 )
          j_alDeleteAuxiliaryEffectSlots(v5, effectslots);
        goto LABEL_88;
      }
      v38->MaxActiveEffectSlots = v24;
      v38->ActiveEffectSlots = v25;
    }
    if ( n >= 1 )
    {
      v26 = 0;
      do
      {
        v27 = j_LookupUIntMapKey(map, effectslots[v26]);
        if ( !v27 )
        {
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/alAuxEffectSlot.c",
            476,
            "ALenum AddEffectSlotArray(ALCcontext *, ALsizei, const ALuint *)",
            "slot != NULL");
          JUMPOUT(0x23CBB4);
        }
        v28 = *(_QWORD *)&v38->ActiveEffectSlots;
        ++v26;
        v38->ActiveEffectSlotCount = HIDWORD(v28) + 1;
        *(_DWORD *)(v28 + 4 * HIDWORD(v28)) = v27;
      }
      while ( v26 < n );
    }
    (*(void (**)(void))(*(volatile RefCount *)((char *)&v38->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
LABEL_88:
    ALCcontext_DecRef(v22);
  }
}
// 23CBB0: control flows out of bounds to 23CBB4
// 23CA38: conditional instruction was optimized away because r1.4!=0
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0023CC50) --------------------------------------------------------
ALCcontext *GetContextRef()
{
  ALCcontext *volatile v0; // r4
  unsigned int v1; // r0
  unsigned int v2; // r0

  v0 = (ALCcontext *volatile)pthread_getspecific(LocalContext);
  if ( v0 )
  {
    __dmb(0xBu);
    do
      v1 = __ldrex((unsigned int *)&v0->ref);
    while ( __strex(v1 + 1, (unsigned int *)&v0->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCcontext_IncRef", "%p increasing refcount to %u\n", v0, v1 + 1);
    return v0;
  }
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_15;
  }
  v0 = GlobalContext;
  if ( GlobalContext )
  {
    __dmb(0xBu);
    do
      v2 = __ldrex((unsigned int *)&v0->ref);
    while ( __strex(v2 + 1, (unsigned int *)&v0->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCcontext_IncRef", "%p increasing refcount to %u\n", v0, v2 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_15:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x23CD20);
  }
  return v0;
}
// 23CD1C: control flows out of bounds to 23CD20
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0023CD68) --------------------------------------------------------
ALvoid __fastcall alSetError(ALCcontext *Context, ALenum errorCode)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&Context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&Context->LastError;
    __dmb(0xBu);
    while ( __strex(errorCode, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (0023CDAC) --------------------------------------------------------
void *__fastcall al_calloc(size_t alignment, size_t size)
{
  _BYTE *v4; // r0
  unsigned int v5; // r5
  unsigned int v6; // r0

  v4 = malloc(size + alignment);
  v5 = 0;
  if ( v4 )
  {
    *v4 = 0;
    v6 = (unsigned int)(v4 + 1);
    if ( ((alignment - 1) & v6) != 0 )
    {
      v5 = v6;
      do
        *(_BYTE *)v5++ = 85;
      while ( ((alignment - 1) & v5) != 0 );
    }
    else
    {
      v5 = v6;
    }
    memset((void *)v5, 0, size);
  }
  return (void *)v5;
}

//----- (0023CDEC) --------------------------------------------------------
ALenum __fastcall InitEffectSlot(ALeffectslot_0 *slot)
{
  ALeffectState_0 *v2; // r0
  __int64 v3; // r2
  ALenum v4; // r5

  v2 = (ALeffectState_0 *)calloc(1u, 0x10u);
  if ( v2 )
  {
    HIDWORD(v3) = NoneProcess;
    v2->Destroy = NoneDestroy;
    v2->DeviceUpdate = NoneDeviceUpdate;
    LODWORD(v3) = NoneUpdate;
    *(_QWORD *)&v2->Update = v3;
    v4 = 0;
    slot->Gain = 1.0;
    slot->EffectState = v2;
    slot->AuxSendAuto = 1;
    slot->NeedsUpdate = 0;
    memset(slot->WetBuffer, 0, 0x200Cu);
  }
  else
  {
    v4 = 40965;
    slot->EffectState = 0;
  }
  return v4;
}

//----- (0023CE60) --------------------------------------------------------
void __fastcall al_free(void *ptr)
{
  int v1; // t1

  if ( ptr )
  {
    do
    {
      v1 = (unsigned __int8)*((char *)ptr - 1);
      ptr = (char *)ptr - 1;
    }
    while ( v1 == 85 );
    j_free(ptr);
  }
}

//----- (0023CE74) --------------------------------------------------------
ALenum __fastcall NewThunkEntry(ALuint *index)
{
  unsigned int v2; // r1
  unsigned int v3; // r0
  unsigned int v4; // r1
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r1
  unsigned int v8; // r0
  int v9; // r6
  ALenum *v10; // r3
  unsigned int *v11; // r3
  unsigned int v12; // r5
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int v15; // r1
  unsigned int v16; // r0
  unsigned int v17; // r1
  unsigned int v18; // r0
  ALenum *v19; // r0
  ALenum *v20; // r5
  ALuint v21; // r4
  unsigned int v22; // r0
  unsigned int v23; // r0
  unsigned int v25; // r0

  __dmb(0xBu);
  do
    v2 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
  __dmb(0xBu);
  if ( v2 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v3 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
    }
    while ( v3 == 1 );
  }
  __dmb(0xBu);
  do
    v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
  __dmb(0xBu);
  if ( v4 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
    }
    while ( v5 == 1 );
  }
  __dmb(0xBu);
  do
    v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(v6 + 1, (unsigned int *)&ThunkLock.read_count) );
  __dmb(0xBu);
  if ( !v6 )
  {
    __dmb(0xBu);
    do
      v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
    __dmb(0xBu);
    if ( v7 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v8 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      while ( v8 == 1 );
    }
  }
  __dmb(0xBu);
  do
    __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
  __dmb(0xBu);
  v9 = 0;
  if ( ThunkArraySize )
  {
    while ( 1 )
    {
      v10 = ThunkArray;
      __dmb(0xBu);
      v11 = (unsigned int *)&v10[v9];
      do
        v12 = __ldrex(v11);
      while ( __strex(1u, v11) );
      __dmb(0xBu);
      if ( !v12 )
        break;
      if ( ++v9 >= ThunkArraySize )
        goto LABEL_31;
    }
    __dmb(0xBu);
    do
      v23 = __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(v23 - 1, (unsigned int *)&ThunkLock.read_count) );
    __dmb(0xBu);
    if ( v23 != 1 )
      goto LABEL_67;
    __dmb(0xBu);
    do
      __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
    goto LABEL_66;
  }
LABEL_31:
  __dmb(0xBu);
  do
    v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(v13 - 1, (unsigned int *)&ThunkLock.read_count) );
  __dmb(0xBu);
  if ( v13 == 1 )
  {
    __dmb(0xBu);
    do
      __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
    __dmb(0xBu);
  }
  __dmb(0xBu);
  do
    v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(v14 + 1, (unsigned int *)&ThunkLock.write_count) );
  __dmb(0xBu);
  if ( !v14 )
  {
    __dmb(0xBu);
    do
      v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
    __dmb(0xBu);
    if ( v15 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v16 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
        __dmb(0xBu);
      }
      while ( v16 == 1 );
    }
  }
  __dmb(0xBu);
  do
    v17 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
  __dmb(0xBu);
  if ( v17 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v18 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
      __dmb(0xBu);
    }
    while ( v18 == 1 );
  }
  v19 = (ALenum *)realloc(ThunkArray, 8 * ThunkArraySize);
  v20 = v19;
  if ( v19 )
  {
    v21 = ThunkArraySize;
    memset(&v19[ThunkArraySize], 0, 4 * ThunkArraySize);
    ThunkArray = v20;
    ThunkArraySize = 2 * v21;
    v20[v9] = 1;
    __dmb(0xBu);
    do
      __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v22 = __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(v22 - 1, (unsigned int *)&ThunkLock.write_count) );
    __dmb(0xBu);
    if ( v22 != 1 )
      goto LABEL_67;
    __dmb(0xBu);
    do
      __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
LABEL_66:
    __dmb(0xBu);
LABEL_67:
    *index = v9 + 1;
    return 0;
  }
  __dmb(0xBu);
  do
    __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    v25 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(v25 - 1, (unsigned int *)&ThunkLock.write_count) );
  __dmb(0xBu);
  if ( v25 == 1 )
  {
    __dmb(0xBu);
    do
      __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
    __dmb(0xBu);
  }
  if ( LogLevel_0 )
    j_al_print("(EE)", "NewThunkEntry", "Realloc failed to increase to %u entries!\n", 2 * ThunkArraySize);
  return 40965;
}

//----- (0023D2B8) --------------------------------------------------------
ALenum __fastcall InsertUIntMapEntry(UIntMap_0 *map, ALuint key, ALvoid *value)
{
  unsigned int *p_write_count; // r5
  unsigned int v7; // r0
  unsigned int *p_read_lock; // r4
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int *p_write_lock; // r4
  unsigned int v12; // r0
  unsigned int v13; // r0
  ALsizei size; // r12
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *array; // r0
  int v16; // r2
  int v17; // r6
  int v18; // r3
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v19; // r0
  unsigned int v20; // r0
  unsigned int *v21; // r0
  ALsizei v22; // r11
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v23; // r0
  unsigned int v24; // r1
  ALenum result; // r0
  unsigned int *v26; // r1
  unsigned int v27; // r0
  unsigned int *v28; // r0

  p_write_count = (unsigned int *)&map->lock.write_count;
  __dmb(0xBu);
  do
    v7 = __ldrex(p_write_count);
  while ( __strex(v7 + 1, p_write_count) );
  __dmb(0xBu);
  if ( !v7 )
  {
    p_read_lock = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      v9 = __ldrex(p_read_lock);
    while ( __strex(1u, p_read_lock) );
    __dmb(0xBu);
    if ( v9 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v10 = __ldrex(p_read_lock);
        while ( __strex(1u, p_read_lock) );
        __dmb(0xBu);
      }
      while ( v10 == 1 );
    }
  }
  p_write_lock = (unsigned int *)&map->lock.write_lock;
  __dmb(0xBu);
  do
    v12 = __ldrex(p_write_lock);
  while ( __strex(1u, p_write_lock) );
  __dmb(0xBu);
  if ( v12 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v13 = __ldrex(p_write_lock);
      while ( __strex(1u, p_write_lock) );
      __dmb(0xBu);
    }
    while ( v13 == 1 );
  }
  size = map->size;
  if ( size < 1 )
  {
    v17 = 0;
    if ( size )
      goto LABEL_29;
  }
  else
  {
    if ( size == 1 )
    {
      array = map->array;
      v17 = 0;
    }
    else
    {
      array = map->array;
      v16 = size - 1;
      v17 = 0;
      do
      {
        v18 = v17 + (v16 - v17) / 2;
        if ( array[v18].key < key )
          v17 = v18 + 1;
        else
          v16 = v17 + (v16 - v17) / 2;
      }
      while ( v16 > v17 );
    }
    if ( array[v17].key < key )
      ++v17;
    if ( v17 != size )
    {
LABEL_29:
      v19 = map->array;
      if ( map->array[v17].key == key )
        goto LABEL_48;
    }
  }
  if ( size == map->limit )
  {
    __dmb(0xBu);
    do
      __ldrex(p_write_lock);
    while ( __strex(0, p_write_lock) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v20 = __ldrex(p_write_count);
    while ( __strex(v20 - 1, p_write_count) );
    __dmb(0xBu);
    if ( v20 != 1 )
      return 40965;
    v21 = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      __ldrex(v21);
    while ( __strex(0, v21) );
LABEL_63:
    __dmb(0xBu);
    return 40965;
  }
  if ( size == map->maxsize )
  {
    v22 = 2 * size;
    if ( !size )
      v22 = 4;
    if ( v22 < size || (v23 = (UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *)realloc(map->array, 8 * v22)) == 0 )
    {
      __dmb(0xBu);
      do
        __ldrex(p_write_lock);
      while ( __strex(0, p_write_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        v27 = __ldrex(p_write_count);
      while ( __strex(v27 - 1, p_write_count) );
      __dmb(0xBu);
      if ( v27 != 1 )
        return 40965;
      v28 = (unsigned int *)&map->lock.read_lock;
      __dmb(0xBu);
      do
        __ldrex(v28);
      while ( __strex(0, v28) );
      goto LABEL_63;
    }
    map->maxsize = v22;
    size = map->size;
    map->array = v23;
  }
  if ( size > v17 )
  {
    memmove(&map->array[v17 + 1], &map->array[v17], 8 * (size - v17));
    size = map->size;
  }
  v19 = map->array;
  map->size = size + 1;
LABEL_48:
  v19[v17].key = key;
  map->array[v17].value = value;
  __dmb(0xBu);
  do
    __ldrex(p_write_lock);
  while ( __strex(0, p_write_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    v24 = __ldrex(p_write_count);
  while ( __strex(v24 - 1, p_write_count) );
  result = 0;
  __dmb(0xBu);
  if ( v24 == 1 )
  {
    v26 = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      __ldrex(v26);
    while ( __strex(0, v26) );
    result = 0;
    __dmb(0xBu);
  }
  return result;
}

//----- (0023D520) --------------------------------------------------------
void __fastcall FreeThunkEntry(ALuint index)
{
  unsigned int v2; // r1
  unsigned int v3; // r0
  unsigned int v4; // r1
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r1
  unsigned int v8; // r0
  ALenum *v9; // r1
  unsigned int *v10; // r0
  unsigned int v11; // r0

  __dmb(0xBu);
  do
    v2 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
  __dmb(0xBu);
  if ( v2 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v3 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
    }
    while ( v3 == 1 );
  }
  __dmb(0xBu);
  do
    v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
  __dmb(0xBu);
  if ( v4 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
    }
    while ( v5 == 1 );
  }
  __dmb(0xBu);
  do
    v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(v6 + 1, (unsigned int *)&ThunkLock.read_count) );
  __dmb(0xBu);
  if ( !v6 )
  {
    __dmb(0xBu);
    do
      v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
    __dmb(0xBu);
    if ( v7 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v8 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      while ( v8 == 1 );
    }
  }
  __dmb(0xBu);
  do
    __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
  __dmb(0xBu);
  if ( index - 1 < ThunkArraySize )
  {
    v9 = ThunkArray;
    __dmb(0xBu);
    v10 = (unsigned int *)&v9[index - 1];
    do
      __ldrex(v10);
    while ( __strex(0, v10) );
    __dmb(0xBu);
  }
  __dmb(0xBu);
  do
    v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
  while ( __strex(v11 - 1, (unsigned int *)&ThunkLock.read_count) );
  __dmb(0xBu);
  if ( v11 == 1 )
  {
    __dmb(0xBu);
    do
      __ldrex((unsigned int *)&ThunkLock.read_count);
    while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
    __dmb(0xBu);
  }
}

//----- (0023D6DC) --------------------------------------------------------
ALvoid __fastcall alDeleteAuxiliaryEffectSlots(ALsizei n, const ALuint *effectslots)
{
  int v4; // r4
  UIntMap_0 *p_EffectSlotMap; // r9
  _DWORD *v6; // r0
  int v7; // r1
  ALeffectslot *v8; // r5
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  ALenum *v13; // r1
  unsigned int *v14; // r0
  unsigned int v15; // r0
  ALsizei ActiveEffectSlotCount; // r2
  ALeffectslot **ActiveEffectSlots; // r0
  ALeffectslot **v18; // r1
  int v19; // r2
  int id_high; // t1
  ALCcontext *v22; // r0
  unsigned int *p_LastError; // r0
  ALCcontext *v26; // r0
  unsigned int *v27; // r0
  ALCcontext *v30; // r0
  unsigned int *v31; // r0
  ALuint id; // [sp+8h] [bp-30h]
  ALsizei v34; // [sp+Ch] [bp-2Ch]
  const ALuint *v35; // [sp+10h] [bp-28h]
  int v36; // [sp+14h] [bp-24h]
  ALCcontext *ContextRef; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_77:
        __clrex();
      }
      else
      {
        v22 = ContextRef;
        __dmb(0xBu);
        p_LastError = (unsigned int *)&v22->LastError;
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_77;
        }
      }
    }
    else
    {
      v34 = n;
      v35 = effectslots;
      if ( !n )
      {
LABEL_79:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      v4 = 0;
      p_EffectSlotMap = &ContextRef->EffectSlotMap;
      while ( 1 )
      {
        v6 = j_LookupUIntMapKey(p_EffectSlotMap, v35[v4]);
        if ( !v6 )
          break;
        if ( v6[2102] )
        {
          if ( TrapALError )
            raise(5);
          if ( __ldrex((unsigned int *)&ContextRef->ref) )
            goto LABEL_77;
          v30 = ContextRef;
          __dmb(0xBu);
          v31 = (unsigned int *)&v30->LastError;
          while ( __strex(0xA004u, v31) )
          {
            if ( __ldrex(v31) )
              goto LABEL_77;
          }
          goto LABEL_78;
        }
        if ( ++v4 >= n )
        {
          v7 = 0;
          do
          {
            v36 = v7;
            v8 = (ALeffectslot *)j_RemoveUIntMapKey(p_EffectSlotMap, v35[v7]);
            if ( v8 )
            {
              id = v8->id;
              __dmb(0xBu);
              do
                v9 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v9 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v9 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              }
              __dmb(0xBu);
              do
                v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v10 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              }
              __dmb(0xBu);
              do
                v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v11 + 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( !v11 )
              {
                __dmb(0xBu);
                do
                  v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                while ( 1 )
                {
                  __dmb(0xBu);
                  if ( v12 != 1 )
                    break;
                  sched_yield();
                  __dmb(0xBu);
                  do
                    v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
                  while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                }
              }
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
              if ( id - 1 < ThunkArraySize )
              {
                v13 = ThunkArray;
                __dmb(0xBu);
                v14 = (unsigned int *)&v13[id - 1];
                do
                  __ldrex(v14);
                while ( __strex(0, v14) );
                __dmb(0xBu);
              }
              __dmb(0xBu);
              do
                v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v15 - 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( v15 == 1 )
              {
                __dmb(0xBu);
                do
                  __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
                __dmb(0xBu);
              }
              (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                       + (unsigned int)&elf_hash_chain[6161])
                                + 44))();
              ActiveEffectSlotCount = ContextRef->ActiveEffectSlotCount;
              if ( ActiveEffectSlotCount )
              {
                ActiveEffectSlots = ContextRef->ActiveEffectSlots;
                v18 = &ActiveEffectSlots[ActiveEffectSlotCount];
                v19 = 4 * ActiveEffectSlotCount;
                while ( *ActiveEffectSlots != v8 )
                {
                  v19 -= 4;
                  ++ActiveEffectSlots;
                  if ( !v19 )
                    goto LABEL_51;
                }
                *ActiveEffectSlots = *(v18 - 1);
                --ContextRef->ActiveEffectSlotCount;
              }
LABEL_51:
              (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                       + (unsigned int)&elf_hash_chain[6161])
                                + 48))();
              ((void (*)(void))v8->EffectState->Destroy)();
              memset(v8, 0, sizeof(ALeffectslot));
              do
              {
                id_high = HIBYTE(v8[-1].id);
                v8 = (ALeffectslot *)((char *)v8 - 1);
              }
              while ( id_high == 85 );
              free(v8);
            }
            v7 = v36 + 1;
          }
          while ( v36 + 1 != v34 );
          goto LABEL_79;
        }
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
        goto LABEL_77;
      v26 = ContextRef;
      __dmb(0xBu);
      v27 = (unsigned int *)&v26->LastError;
      while ( __strex(0xA001u, v27) )
      {
        if ( __ldrex(v27) )
          goto LABEL_77;
      }
    }
LABEL_78:
    __dmb(0xBu);
    goto LABEL_79;
  }
}
// 23D73A: conditional instruction was optimized away because r5.4>=1
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0023DA48) --------------------------------------------------------
void __fastcall ALCcontext_DecRef(ALCcontext *context)
{
  unsigned int v2; // r0
  unsigned int v3; // r5
  unsigned int *p_write_count; // r5
  unsigned int v5; // r0
  unsigned int *p_read_lock; // r6
  unsigned int v7; // r0
  unsigned int v8; // r0
  unsigned int *p_write_lock; // r6
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int *v13; // r0
  unsigned int *v14; // r5
  unsigned int v15; // r0
  unsigned int *v16; // r6
  unsigned int v17; // r0
  unsigned int v18; // r0
  unsigned int *v19; // r6
  unsigned int v20; // r0
  unsigned int v21; // r0
  unsigned int v22; // r0
  unsigned int *v23; // r0
  ALsource **ActiveSources; // r0
  ALeffectslot **ActiveEffectSlots; // r0
  ALCdevice *Device; // r0

  __dmb(0xBu);
  do
  {
    v2 = __ldrex((unsigned int *)&context->ref);
    v3 = v2 - 1;
  }
  while ( __strex(v2 - 1, (unsigned int *)&context->ref) );
  __dmb(0xBu);
  if ( (unsigned int)LogLevel_0 >= LogRef )
    j_al_print("(--)", "ALCcontext_DecRef", "%p decreasing refcount to %u\n", context, v3);
  if ( !v3 )
  {
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print("(II)", "FreeContext", "%p\n", context);
    if ( context->SourceMap.size >= 1 )
    {
      if ( (unsigned int)LogLevel_0 >= LogWarning )
        j_al_print("(WW)", "FreeContext", "(%p) Deleting %d Source(s)\n", context, context->SourceMap.size);
      j_ReleaseALSources(context);
    }
    p_write_count = (unsigned int *)&context->SourceMap.lock.write_count;
    __dmb(0xBu);
    do
      v5 = __ldrex(p_write_count);
    while ( __strex(v5 + 1, p_write_count) );
    __dmb(0xBu);
    if ( !v5 )
    {
      p_read_lock = (unsigned int *)&context->SourceMap.lock.read_lock;
      __dmb(0xBu);
      do
        v7 = __ldrex(p_read_lock);
      while ( __strex(1u, p_read_lock) );
      __dmb(0xBu);
      if ( v7 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v8 = __ldrex(p_read_lock);
          while ( __strex(1u, p_read_lock) );
          __dmb(0xBu);
        }
        while ( v8 == 1 );
      }
    }
    p_write_lock = (unsigned int *)&context->SourceMap.lock.write_lock;
    __dmb(0xBu);
    do
      v10 = __ldrex(p_write_lock);
    while ( __strex(1u, p_write_lock) );
    __dmb(0xBu);
    if ( v10 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v11 = __ldrex(p_write_lock);
        while ( __strex(1u, p_write_lock) );
        __dmb(0xBu);
      }
      while ( v11 == 1 );
    }
    free(context->SourceMap.array);
    context->SourceMap.array = 0;
    context->SourceMap.size = 0;
    context->SourceMap.maxsize = 0;
    __dmb(0xBu);
    do
      __ldrex(p_write_lock);
    while ( __strex(0, p_write_lock) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v12 = __ldrex(p_write_count);
    while ( __strex(v12 - 1, p_write_count) );
    __dmb(0xBu);
    if ( v12 == 1 )
    {
      v13 = (unsigned int *)&context->SourceMap.lock.read_lock;
      __dmb(0xBu);
      do
        __ldrex(v13);
      while ( __strex(0, v13) );
      __dmb(0xBu);
    }
    if ( context->EffectSlotMap.size >= 1 )
    {
      if ( (unsigned int)LogLevel_0 >= LogWarning )
        j_al_print(
          "(WW)",
          "FreeContext",
          "(%p) Deleting %d AuxiliaryEffectSlot(s)\n",
          context,
          context->EffectSlotMap.size);
      j_ReleaseALAuxiliaryEffectSlots(context);
    }
    v14 = (unsigned int *)&context->EffectSlotMap.lock.write_count;
    __dmb(0xBu);
    do
      v15 = __ldrex(v14);
    while ( __strex(v15 + 1, v14) );
    __dmb(0xBu);
    if ( !v15 )
    {
      v16 = (unsigned int *)&context->EffectSlotMap.lock.read_lock;
      __dmb(0xBu);
      do
        v17 = __ldrex(v16);
      while ( __strex(1u, v16) );
      __dmb(0xBu);
      if ( v17 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v18 = __ldrex(v16);
          while ( __strex(1u, v16) );
          __dmb(0xBu);
        }
        while ( v18 == 1 );
      }
    }
    v19 = (unsigned int *)&context->EffectSlotMap.lock.write_lock;
    __dmb(0xBu);
    do
      v20 = __ldrex(v19);
    while ( __strex(1u, v19) );
    __dmb(0xBu);
    if ( v20 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v21 = __ldrex(v19);
        while ( __strex(1u, v19) );
        __dmb(0xBu);
      }
      while ( v21 == 1 );
    }
    free(context->EffectSlotMap.array);
    context->EffectSlotMap.array = 0;
    context->EffectSlotMap.size = 0;
    context->EffectSlotMap.maxsize = 0;
    __dmb(0xBu);
    do
      __ldrex(v19);
    while ( __strex(0, v19) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v22 = __ldrex(v14);
    while ( __strex(v22 - 1, v14) );
    __dmb(0xBu);
    if ( v22 == 1 )
    {
      v23 = (unsigned int *)&context->EffectSlotMap.lock.read_lock;
      __dmb(0xBu);
      do
        __ldrex(v23);
      while ( __strex(0, v23) );
      __dmb(0xBu);
    }
    ActiveSources = context->ActiveSources;
    context->ActiveSourceCount = 0;
    free(ActiveSources);
    ActiveEffectSlots = context->ActiveEffectSlots;
    context->MaxActiveSources = 0;
    context->ActiveSources = 0;
    context->ActiveEffectSlotCount = 0;
    free(ActiveEffectSlots);
    Device = context->Device;
    context->MaxActiveEffectSlots = 0;
    context->ActiveEffectSlots = 0;
    j_ALCdevice_DecRef(Device);
    j_free(context);
  }
}

//----- (0023DDB4) --------------------------------------------------------
ALvoid *__fastcall LookupUIntMapKey(UIntMap_0 *map, ALuint key)
{
  unsigned int *p_read_entry_lock; // r4
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int *p_read_lock; // r5
  unsigned int v8; // r0
  unsigned int v9; // r0
  RWLock *p_lock; // r10
  unsigned int v11; // r0
  unsigned int *p_write_lock; // r6
  unsigned int v13; // r0
  unsigned int v14; // r0
  ALsizei size; // r1
  ALvoid *result; // r0
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *array; // r0
  int v18; // r2
  int v19; // r1
  int v20; // r3
  unsigned int v21; // r1
  unsigned int *v22; // r1

  p_read_entry_lock = (unsigned int *)&map->lock.read_entry_lock;
  __dmb(0xBu);
  do
    v5 = __ldrex(p_read_entry_lock);
  while ( __strex(1u, p_read_entry_lock) );
  __dmb(0xBu);
  if ( v5 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v6 = __ldrex(p_read_entry_lock);
      while ( __strex(1u, p_read_entry_lock) );
      __dmb(0xBu);
    }
    while ( v6 == 1 );
  }
  p_read_lock = (unsigned int *)&map->lock.read_lock;
  __dmb(0xBu);
  do
    v8 = __ldrex(p_read_lock);
  while ( __strex(1u, p_read_lock) );
  __dmb(0xBu);
  if ( v8 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v9 = __ldrex(p_read_lock);
      while ( __strex(1u, p_read_lock) );
      __dmb(0xBu);
    }
    while ( v9 == 1 );
  }
  p_lock = &map->lock;
  __dmb(0xBu);
  do
    v11 = __ldrex((unsigned int *)&p_lock->read_count);
  while ( __strex(v11 + 1, (unsigned int *)&p_lock->read_count) );
  __dmb(0xBu);
  if ( !v11 )
  {
    p_write_lock = (unsigned int *)&map->lock.write_lock;
    __dmb(0xBu);
    do
      v13 = __ldrex(p_write_lock);
    while ( __strex(1u, p_write_lock) );
    __dmb(0xBu);
    if ( v13 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v14 = __ldrex(p_write_lock);
        while ( __strex(1u, p_write_lock) );
        __dmb(0xBu);
      }
      while ( v14 == 1 );
    }
  }
  __dmb(0xBu);
  do
    __ldrex(p_read_lock);
  while ( __strex(0, p_read_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    __ldrex(p_read_entry_lock);
  while ( __strex(0, p_read_entry_lock) );
  __dmb(0xBu);
  size = map->size;
  if ( size < 1 )
  {
    result = 0;
  }
  else
  {
    if ( size == 1 )
    {
      array = map->array;
      v19 = 0;
    }
    else
    {
      array = map->array;
      v18 = size - 1;
      v19 = 0;
      do
      {
        v20 = v19 + (v18 - v19) / 2;
        if ( array[v20].key < key )
          v19 = v20 + 1;
        else
          v18 = v19 + (v18 - v19) / 2;
      }
      while ( v18 > v19 );
    }
    if ( array[v19].key == key )
      result = array[v19].value;
    else
      result = 0;
  }
  __dmb(0xBu);
  do
    v21 = __ldrex((unsigned int *)&p_lock->read_count);
  while ( __strex(v21 - 1, (unsigned int *)&p_lock->read_count) );
  __dmb(0xBu);
  if ( v21 == 1 )
  {
    v22 = (unsigned int *)&map->lock.write_lock;
    __dmb(0xBu);
    do
      __ldrex(v22);
    while ( __strex(0, v22) );
    __dmb(0xBu);
  }
  return result;
}

//----- (0023DF46) --------------------------------------------------------
ALvoid *__fastcall RemoveUIntMapKey(UIntMap_0 *map, ALuint key)
{
  unsigned int *p_write_count; // r6
  unsigned int v5; // r0
  unsigned int *p_read_lock; // r4
  unsigned int v7; // r0
  unsigned int v8; // r0
  unsigned int *p_write_lock; // r4
  unsigned int v10; // r0
  unsigned int v11; // r0
  ALsizei size; // r12
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *array; // r0
  int v14; // r3
  int v15; // r2
  int v16; // r1
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v17; // r0
  ALvoid *value; // r9
  unsigned int v19; // r0
  unsigned int *v20; // r0

  p_write_count = (unsigned int *)&map->lock.write_count;
  __dmb(0xBu);
  do
    v5 = __ldrex(p_write_count);
  while ( __strex(v5 + 1, p_write_count) );
  __dmb(0xBu);
  if ( !v5 )
  {
    p_read_lock = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      v7 = __ldrex(p_read_lock);
    while ( __strex(1u, p_read_lock) );
    __dmb(0xBu);
    if ( v7 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v8 = __ldrex(p_read_lock);
        while ( __strex(1u, p_read_lock) );
        __dmb(0xBu);
      }
      while ( v8 == 1 );
    }
  }
  p_write_lock = (unsigned int *)&map->lock.write_lock;
  __dmb(0xBu);
  do
    v10 = __ldrex(p_write_lock);
  while ( __strex(1u, p_write_lock) );
  __dmb(0xBu);
  if ( v10 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v11 = __ldrex(p_write_lock);
      while ( __strex(1u, p_write_lock) );
      __dmb(0xBu);
    }
    while ( v11 == 1 );
  }
  size = map->size;
  if ( size < 1 )
    goto LABEL_28;
  if ( size == 1 )
  {
    array = map->array;
    v15 = 0;
  }
  else
  {
    array = map->array;
    v14 = size - 1;
    v15 = 0;
    do
    {
      v16 = v15 + (v14 - v15) / 2;
      if ( array[v16].key < key )
        v15 = v16 + 1;
      else
        v14 = v15 + (v14 - v15) / 2;
    }
    while ( v14 > v15 );
  }
  if ( array[v15].key == key )
  {
    v17 = &array[v15];
    value = v17->value;
    if ( size - 1 > v15 )
    {
      memmove(v17, &v17[1], 8 * (size - 1 - v15));
      size = map->size;
    }
    map->size = size - 1;
  }
  else
  {
LABEL_28:
    value = 0;
  }
  __dmb(0xBu);
  do
    __ldrex(p_write_lock);
  while ( __strex(0, p_write_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    v19 = __ldrex(p_write_count);
  while ( __strex(v19 - 1, p_write_count) );
  __dmb(0xBu);
  if ( v19 == 1 )
  {
    v20 = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      __ldrex(v20);
    while ( __strex(0, v20) );
    __dmb(0xBu);
  }
  return value;
}

//----- (0023E0AA) --------------------------------------------------------
ALboolean __fastcall alIsAuxiliaryEffectSlot(ALuint effectslot)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r5
  ALvoid *v4; // r4

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( !ContextRef )
    return 0;
  v4 = j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot);
  j_ALCcontext_DecRef(v3);
  return v4 != 0;
}

//----- (0023E0DC) --------------------------------------------------------
ALvoid __fastcall alAuxiliaryEffectSloti(ALuint effectslot, ALenum param, ALint value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r9
  ALCdevice *Device; // r8
  ALeffectslot_0 *v9; // r0
  ALeffectslot_0 *v10; // r6
  ALeffect_0 *v11; // r2
  unsigned int *v13; // r0
  unsigned int *v16; // r0
  unsigned int *v19; // r0
  unsigned int *p_LastError; // r0
  unsigned int v24; // r5
  unsigned int *v26; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    Device = ContextRef->Device;
    v9 = (ALeffectslot_0 *)j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot);
    v10 = v9;
    if ( v9 )
    {
      if ( param == 3 )
      {
        if ( (unsigned int)value >= 2 )
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            p_LastError = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(0xA003u, p_LastError) )
            {
              if ( __ldrex(p_LastError) )
                goto LABEL_46;
            }
            goto LABEL_47;
          }
          goto LABEL_46;
        }
        v9->AuxSendAuto = value;
      }
      else
      {
        if ( param != 1 )
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            v19 = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(0xA002u, v19) )
            {
              if ( __ldrex(v19) )
                goto LABEL_46;
            }
            goto LABEL_47;
          }
          goto LABEL_46;
        }
        if ( value )
        {
          v11 = (ALeffect_0 *)j_LookupUIntMapKey(&Device->EffectMap, value);
          if ( !v11 )
          {
            if ( TrapALError )
              raise(5);
            if ( !__ldrex((unsigned int *)&v7->ref) )
            {
              v13 = (unsigned int *)&v7->LastError;
              __dmb(0xBu);
              while ( __strex(0xA003u, v13) )
              {
                if ( __ldrex(v13) )
                  goto LABEL_46;
              }
              goto LABEL_47;
            }
LABEL_46:
            __clrex();
LABEL_47:
            __dmb(0xBu);
LABEL_48:
            ALCcontext_DecRef(v7);
            return;
          }
        }
        else
        {
          v11 = 0;
        }
        v24 = j_InitializeEffect(Device, v10, v11);
        if ( v24 )
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            v26 = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(v24, v26) )
            {
              if ( __ldrex(v26) )
                goto LABEL_46;
            }
            goto LABEL_47;
          }
          goto LABEL_46;
        }
      }
      v7->UpdateSources = 1;
      goto LABEL_48;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v7->ref) )
    {
      v16 = (unsigned int *)&v7->LastError;
      __dmb(0xBu);
      while ( __strex(0xA001u, v16) )
      {
        if ( __ldrex(v16) )
          goto LABEL_46;
      }
      goto LABEL_47;
    }
    goto LABEL_46;
  }
}

//----- (0023E280) --------------------------------------------------------
ALenum __fastcall InitializeEffect(ALCdevice *Device, ALeffectslot_0 *EffectSlot, ALeffect_0 *effect)
{
  ALenum type; // r5
  char *v7; // r11
  ALeffectState_0 *v8; // r5
  __int64 v9; // r2
  bool v10; // zf
  ALeffectState_0 *v11; // r0
  __int64 v12; // r2
  ALenum v13; // r5
  __int64 v14; // r2
  int v15; // r9
  unsigned int *p_EffectState; // r0
  void (__fastcall **v17)(_DWORD); // r6
  ALeffectState_0 *EffectState; // r0

  if ( effect )
  {
    type = effect->type;
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 44))(Device);
    v7 = (char *)&elf_hash_chain[6161] + (_DWORD)Device;
    switch ( type )
    {
      case 0:
        goto LABEL_7;
      case 1:
        goto LABEL_13;
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
        goto LABEL_18;
      case 4:
        if ( EffectSlot->effect.type == 4 )
          goto LABEL_24;
        v8 = (ALeffectState_0 *)malloc(0x7Cu);
        if ( !v8 )
          goto LABEL_33;
        HIDWORD(v9) = EchoProcess;
        v8[7].Destroy = 0;
        v8[7].DeviceUpdate = 0;
        v8[7].Update = 0;
        LODWORD(v9) = EchoUpdate;
        v8[2].Destroy = 0;
        v8->Destroy = EchoDestroy;
        v8->DeviceUpdate = EchoDeviceUpdate;
        *(_QWORD *)&v8->Update = v9;
        goto LABEL_22;
      case 9:
        if ( EffectSlot->effect.type == 9 )
          goto LABEL_24;
        v8 = (ALeffectState_0 *)malloc(0x48u);
        if ( !v8 )
          goto LABEL_33;
        HIDWORD(v14) = ModulatorProcess;
        v8[1].DeviceUpdate = 0;
        v8[1].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))(&dword_0 + 1);
        v8[4].Destroy = 0;
        v8[4].DeviceUpdate = 0;
        LODWORD(v14) = ModulatorUpdate;
        v8->Destroy = ModulatorDestroy;
        v8->DeviceUpdate = ModulatorDeviceUpdate;
        *(_QWORD *)&v8->Update = v14;
        goto LABEL_28;
      default:
        if ( type != 0x8000 )
        {
LABEL_18:
          if ( (type | 1) != 36865 || (EffectSlot->effect.type & 0xFFFFFFFE) == 36864 )
            goto LABEL_24;
          v11 = (ALeffectState_0 *)malloc(0x34u);
          v8 = v11;
          if ( !v11 )
            goto LABEL_33;
          v11[3].Destroy = 0;
          HIDWORD(v12) = DedicatedProcess;
          v11->Destroy = DedicatedDestroy;
          v11->DeviceUpdate = DedicatedDeviceUpdate;
          LODWORD(v12) = DedicatedUpdate;
          *(_QWORD *)&v11->Update = v12;
          *(_QWORD *)&v11[2].Destroy = 0LL;
          *(_QWORD *)&v11[2].Update = 0LL;
LABEL_22:
          *(_QWORD *)&v8[1].Destroy = 0LL;
          *(_QWORD *)&v8[1].Update = 0LL;
          goto LABEL_28;
        }
LABEL_13:
        v10 = EffectSlot->effect.type == 1;
        if ( EffectSlot->effect.type != 1 )
          v10 = EffectSlot->effect.type == 0x8000;
        if ( v10 )
          goto LABEL_24;
        v8 = j_ReverbCreate();
        if ( v8 )
          goto LABEL_28;
        break;
    }
    goto LABEL_33;
  }
  (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 44))(Device);
  v7 = (char *)&elf_hash_chain[6161] + (_DWORD)Device;
LABEL_7:
  if ( EffectSlot->effect.type )
  {
    v8 = (ALeffectState_0 *)calloc(1u, 0x10u);
    if ( !v8 )
    {
LABEL_33:
      (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v7 + 48))(Device);
      return 40965;
    }
    v8->Destroy = NoneDestroy;
    v8->DeviceUpdate = NoneDeviceUpdate;
    v8->Update = NoneUpdate;
    v8->Process = NoneProcess;
LABEL_28:
    v15 = fegetround();
    fesetround(3);
    if ( !((int (__fastcall *)(ALeffectState_0 *, ALCdevice *))v8->DeviceUpdate)(v8, Device) )
    {
      fesetround(v15);
      (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v7 + 48))(Device);
      v8->Destroy(v8);
      return 40965;
    }
    p_EffectState = (unsigned int *)&EffectSlot->EffectState;
    __dmb(0xBu);
    do
      v17 = (void (__fastcall **)(_DWORD))__ldrex(p_EffectState);
    while ( __strex((unsigned int)v8, p_EffectState) );
    __dmb(0xBu);
    if ( effect )
      qmemcpy(EffectSlot, effect, 0xB8u);
    else
      memset(EffectSlot, 0, 0xB8u);
    EffectState = EffectSlot->EffectState;
    v13 = 0;
    EffectSlot->NeedsUpdate = 0;
    ((void (*)(void))EffectState->Update)();
    (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v7 + 48))(Device);
    fesetround(v15);
    (*v17)(v17);
  }
  else
  {
    if ( effect )
LABEL_24:
      qmemcpy(EffectSlot, effect, 0xB8u);
    else
      memset(EffectSlot, 0, 0xB8u);
    (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v7 + 48))(Device);
    v13 = 0;
    EffectSlot->NeedsUpdate = 1;
  }
  return v13;
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0023E500) --------------------------------------------------------
ALvoid __fastcall alAuxiliaryEffectSlotiv(ALuint effectslot, ALenum param, const ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v10; // r0

  if ( (param | 2) == 3 )
  {
    alAuxiliaryEffectSloti(effectslot, param, *values);
    return;
  }
  ContextRef = j_GetContextRef();
  v5 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        p_LastError = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        v10 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
LABEL_18:
    __clrex();
LABEL_19:
    __dmb(0xBu);
    ALCcontext_DecRef(v5);
  }
}

//----- (0023E5A8) --------------------------------------------------------
ALvoid __fastcall alAuxiliaryEffectSlotf(ALuint effectslot, ALenum param, ALfloat value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r8
  ALfloat *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALfloat *)j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot);
    if ( v8 )
    {
      if ( param == 2 )
      {
        if ( value >= 0.0 && value <= 1.0 )
        {
          v8[46] = value;
          *((_DWORD *)v8 + 48) = 1;
LABEL_30:
          ALCcontext_DecRef(v7);
          return;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_28;
        }
        goto LABEL_29;
      }
    }
LABEL_28:
    __clrex();
LABEL_29:
    __dmb(0xBu);
    goto LABEL_30;
  }
}

//----- (0023E6C0) --------------------------------------------------------
ALvoid __fastcall alAuxiliaryEffectSlotfv(ALuint effectslot, ALenum param, const ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v10; // r0

  if ( param == 2 )
  {
    alAuxiliaryEffectSlotf(effectslot, 2, *values);
    return;
  }
  ContextRef = j_GetContextRef();
  v5 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        p_LastError = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        v10 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
LABEL_18:
    __clrex();
LABEL_19:
    __dmb(0xBu);
    ALCcontext_DecRef(v5);
  }
}

//----- (0023E764) --------------------------------------------------------
ALvoid __fastcall alGetAuxiliaryEffectSloti(ALuint effectslot, ALenum param, ALint *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  _DWORD *v8; // r0
  unsigned int *v10; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot);
    if ( v8 )
    {
      if ( param == 3 )
      {
        *value = *((unsigned __int8 *)v8 + 188);
        goto LABEL_23;
      }
      if ( param == 1 )
      {
        *value = v8[45];
LABEL_23:
        ALCcontext_DecRef(v7);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
LABEL_21:
    __clrex();
LABEL_22:
    __dmb(0xBu);
    goto LABEL_23;
  }
}

//----- (0023E82C) --------------------------------------------------------
ALvoid __fastcall alGetAuxiliaryEffectSlotiv(ALuint effectslot, ALenum param, ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v10; // r0

  if ( (param | 2) == 3 )
  {
    alGetAuxiliaryEffectSloti(effectslot, param, values);
    return;
  }
  ContextRef = j_GetContextRef();
  v5 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        p_LastError = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        v10 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
LABEL_18:
    __clrex();
LABEL_19:
    __dmb(0xBu);
    ALCcontext_DecRef(v5);
  }
}

//----- (0023E8D0) --------------------------------------------------------
ALvoid __fastcall alGetAuxiliaryEffectSlotf(ALuint effectslot, ALenum param, ALfloat *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALfloat *v8; // r0
  unsigned int *v10; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALfloat *)j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot);
    if ( v8 )
    {
      if ( param == 2 )
      {
        *value = v8[46];
LABEL_21:
        ALCcontext_DecRef(v7);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_19;
        }
        goto LABEL_20;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_19;
        }
        goto LABEL_20;
      }
    }
LABEL_19:
    __clrex();
LABEL_20:
    __dmb(0xBu);
    goto LABEL_21;
  }
}

//----- (0023E98C) --------------------------------------------------------
ALvoid __fastcall alGetAuxiliaryEffectSlotfv(ALuint effectslot, ALenum param, ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v6; // r4
  ALfloat *v7; // r0
  ALCcontext *v8; // r0
  unsigned int *v10; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v16; // r0

  if ( param == 2 )
  {
    ContextRef = j_GetContextRef();
    v6 = ContextRef;
    if ( ContextRef )
    {
      v7 = (ALfloat *)j_LookupUIntMapKey(&ContextRef->EffectSlotMap, effectslot);
      if ( v7 )
      {
        *values = v7[46];
LABEL_30:
        ALCcontext_DecRef(v6);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        p_LastError = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_28;
        }
        goto LABEL_29;
      }
LABEL_28:
      __clrex();
LABEL_29:
      __dmb(0xBu);
      goto LABEL_30;
    }
  }
  else
  {
    v8 = j_GetContextRef();
    v6 = v8;
    if ( v8 )
    {
      if ( j_LookupUIntMapKey(&v8->EffectSlotMap, effectslot) )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v6->ref) )
        {
          v10 = (unsigned int *)&v6->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v10) )
          {
            if ( __ldrex(v10) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v6->ref) )
        {
          v16 = (unsigned int *)&v6->LastError;
          __dmb(0xBu);
          while ( __strex(0xA001u, v16) )
          {
            if ( __ldrex(v16) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
      goto LABEL_28;
    }
  }
}

//----- (0023EA88) --------------------------------------------------------
ALeffectState_0 *NoneCreate()
{
  ALeffectState_0 *result; // r0
  __int64 v1; // r2

  result = (ALeffectState_0 *)calloc(1u, 0x10u);
  if ( !result )
    return 0;
  HIDWORD(v1) = NoneProcess;
  LODWORD(v1) = NoneUpdate;
  result->Destroy = NoneDestroy;
  result->DeviceUpdate = NoneDeviceUpdate;
  *(_QWORD *)&result->Update = v1;
  return result;
}

//----- (0023EACC) --------------------------------------------------------
ALboolean __fastcall NoneDeviceUpdate(ALeffectState_0 *State, ALCdevice *Device)
{
  return 1;
}

//----- (0023EAD4) --------------------------------------------------------
ALeffectState_0 *ReverbCreate()
{
  char *v0; // r0
  int v1; // r1

  v0 = (char *)malloc((size_t)&elf_hash_chain[30]);
  v1 = 0;
  if ( v0 )
  {
    *((_DWORD *)v0 + 12) = 1;
    *((_DWORD *)v0 + 25) = 0;
    *((_DWORD *)v0 + 26) = 0;
    *((_DWORD *)v0 + 21) = 0;
    *((_DWORD *)v0 + 22) = 0;
    *((_DWORD *)v0 + 27) = 0;
    *((_DWORD *)v0 + 28) = 0;
    *((_DWORD *)v0 + 23) = 0;
    *(_DWORD *)v0 = ReverbDestroy;
    *((_DWORD *)v0 + 1) = ReverbDeviceUpdate;
    *((_DWORD *)v0 + 2) = ReverbUpdate;
    *((_DWORD *)v0 + 3) = VerbProcess;
    *((_QWORD *)v0 + 4) = 0LL;
    *((_QWORD *)v0 + 5) = 0LL;
    *(_QWORD *)(v0 + 68) = 0LL;
    *(_QWORD *)(v0 + 76) = 0LL;
    *((_QWORD *)v0 + 2) = 0LL;
    *((_QWORD *)v0 + 3) = 0LL;
    *(_QWORD *)(v0 + 52) = 0LL;
    *(_QWORD *)(v0 + 60) = 0LL;
    *((_DWORD *)v0 + 24) = 0;
    *((_DWORD *)v0 + 29) = 0;
    *((_DWORD *)v0 + 30) = 0;
    *((_DWORD *)v0 + 31) = 0;
    *((_DWORD *)v0 + 32) = 0;
    *((_DWORD *)v0 + 33) = 0;
    *((_DWORD *)v0 + 34) = 0;
    *((_DWORD *)v0 + 35) = 0;
    *((_DWORD *)v0 + 36) = 0;
    *((_DWORD *)v0 + 59) = 0;
    *((_QWORD *)v0 + 25) = 0LL;
    *((_QWORD *)v0 + 26) = 0LL;
    *((_QWORD *)v0 + 23) = 0LL;
    *((_QWORD *)v0 + 24) = 0LL;
    *((_DWORD *)v0 + 54) = 0;
    *((_DWORD *)v0 + 55) = 0;
    *((_DWORD *)v0 + 60) = 0;
    *((_DWORD *)v0 + 61) = 0;
    *((_DWORD *)v0 + 92) = 0;
    *((_DWORD *)v0 + 56) = 0;
    *((_DWORD *)v0 + 57) = 0;
    *((_DWORD *)v0 + 88) = 0;
    *((_DWORD *)v0 + 89) = 0;
    *((_DWORD *)v0 + 58) = 0;
    *((_DWORD *)v0 + 62) = 0;
    *((_DWORD *)v0 + 63) = 0;
    *((_DWORD *)v0 + 64) = 0;
    *((_DWORD *)v0 + 65) = 0;
    *((_DWORD *)v0 + 66) = 0;
    *((_DWORD *)v0 + 67) = 0;
    *((_DWORD *)v0 + 68) = 0;
    *((_DWORD *)v0 + 69) = 0;
    *((_DWORD *)v0 + 70) = 0;
    *((_DWORD *)v0 + 71) = 0;
    *((_DWORD *)v0 + 72) = 0;
    *((_DWORD *)v0 + 73) = 0;
    *((_DWORD *)v0 + 74) = 0;
    *((_DWORD *)v0 + 75) = 0;
    *((_DWORD *)v0 + 76) = 0;
    *((_DWORD *)v0 + 77) = 0;
    *((_DWORD *)v0 + 78) = 0;
    *((_DWORD *)v0 + 79) = 0;
    *((_DWORD *)v0 + 80) = 0;
    *((_DWORD *)v0 + 81) = 0;
    *((_DWORD *)v0 + 82) = 0;
    *((_DWORD *)v0 + 83) = 0;
    *((_DWORD *)v0 + 84) = 0;
    *((_DWORD *)v0 + 85) = 0;
    *((_DWORD *)v0 + 86) = 0;
    *((_DWORD *)v0 + 87) = 0;
    *((_DWORD *)v0 + 90) = 0;
    *((_DWORD *)v0 + 91) = 0;
    *(_QWORD *)(v0 + 372) = 0LL;
    *(_QWORD *)(v0 + 380) = 0LL;
    *((_DWORD *)v0 + 37) = 0;
    *((_DWORD *)v0 + 38) = 0;
    *((_DWORD *)v0 + 39) = 0;
    *(_QWORD *)(v0 + 388) = 0LL;
    *(_QWORD *)(v0 + 396) = 0LL;
    *((_QWORD *)v0 + 20) = 0LL;
    *((_QWORD *)v0 + 21) = 0LL;
    *((_DWORD *)v0 + 44) = 0;
    *((_DWORD *)v0 + 45) = 0;
    *((_DWORD *)v0 + 101) = 0;
    *((_DWORD *)v0 + 102) = 0;
    *((_DWORD *)v0 + 103) = 0;
    *(_QWORD *)(v0 + 460) = 0LL;
    *(_QWORD *)(v0 + 468) = 0LL;
    *((_QWORD *)v0 + 56) = 0LL;
    *((_QWORD *)v0 + 57) = 0LL;
    *((_QWORD *)v0 + 54) = 0LL;
    *((_QWORD *)v0 + 55) = 0LL;
    *((_QWORD *)v0 + 52) = 0LL;
    *((_QWORD *)v0 + 53) = 0LL;
    *((_DWORD *)v0 + 119) = v0 + 380;
    return (ALeffectState_0 *)v0;
  }
  return (ALeffectState_0 *)v1;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0023EC20) --------------------------------------------------------
ALeffectState_0 *EchoCreate()
{
  _DWORD *v0; // r0
  int v1; // r1

  v0 = malloc(0x7Cu);
  v1 = 0;
  if ( v0 )
  {
    v0[28] = 0;
    v0[29] = 0;
    v0[30] = 0;
    v0[8] = 0;
    *v0 = EchoDestroy;
    v0[1] = EchoDeviceUpdate;
    v0[2] = EchoUpdate;
    v0[3] = EchoProcess;
    *((_QWORD *)v0 + 2) = 0LL;
    *((_QWORD *)v0 + 3) = 0LL;
    return (ALeffectState_0 *)v0;
  }
  return (ALeffectState_0 *)v1;
}

//----- (0023EC74) --------------------------------------------------------
ALeffectState_0 *ModulatorCreate()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r1

  v0 = malloc(0x48u);
  v1 = 0;
  if ( v0 )
  {
    v0[5] = 0;
    v0[6] = 1;
    v0[16] = 0;
    v0[17] = 0;
    v1 = v0;
    *v0 = ModulatorDestroy;
    v0[1] = ModulatorDeviceUpdate;
    v0[2] = ModulatorUpdate;
    v0[3] = ModulatorProcess;
  }
  return (ALeffectState_0 *)v1;
}

//----- (0023ECC0) --------------------------------------------------------
ALeffectState_0 *DedicatedCreate()
{
  _DWORD *v0; // r0
  int v1; // r1

  v0 = malloc(0x34u);
  v1 = 0;
  if ( v0 )
  {
    v0[12] = 0;
    *v0 = DedicatedDestroy;
    v0[1] = DedicatedDeviceUpdate;
    v0[2] = DedicatedUpdate;
    v0[3] = DedicatedProcess;
    *((_QWORD *)v0 + 4) = 0LL;
    *((_QWORD *)v0 + 5) = 0LL;
    *((_QWORD *)v0 + 2) = 0LL;
    *((_QWORD *)v0 + 3) = 0LL;
    return (ALeffectState_0 *)v0;
  }
  return (ALeffectState_0 *)v1;
}

//----- (0023ED18) --------------------------------------------------------
void __fastcall SetMixerFPUMode(FPUCtl *ctl)
{
  ctl->state = fegetround();
  sub_18F050(3);
}

//----- (0023ED2E) --------------------------------------------------------
void __fastcall RestoreFPUMode(const FPUCtl *ctl)
{
  sub_18F050(ctl->state);
}

//----- (0023ED34) --------------------------------------------------------
ALvoid __fastcall ReleaseALAuxiliaryEffectSlots(ALCcontext *Context)
{
  int v1; // r2
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v2; // r0
  void (***value)(void); // r5
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r0
  ALenum *v8; // r1
  unsigned int *v9; // r0
  unsigned int v10; // r0
  int v11; // t1
  ALCcontext *v12; // [sp+0h] [bp-28h]
  void (**v13)(void); // [sp+4h] [bp-24h]
  int v14; // [sp+8h] [bp-20h]

  if ( Context->EffectSlotMap.size >= 1 )
  {
    v1 = 0;
    v12 = Context;
    do
    {
      v14 = v1;
      v2 = &Context->EffectSlotMap.array[v1];
      value = (void (***)(void))v2->value;
      v2->value = 0;
      (*value[49])();
      v13 = value[2103];
      __dmb(0xBu);
      do
        v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v4 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v5 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v6 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v6 )
      {
        __dmb(0xBu);
        do
          v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v7 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( (unsigned int)v13 - 1 < ThunkArraySize )
      {
        v8 = ThunkArray;
        __dmb(0xBu);
        v9 = (unsigned int *)&v8[(_DWORD)v13 - 1];
        do
          __ldrex(v9);
        while ( __strex(0, v9) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v10 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v10 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      memset(value, 0, 0x20E0u);
      if ( value )
      {
        do
        {
          v11 = *((unsigned __int8 *)value - 1);
          value = (void (***)(void))((char *)value - 1);
        }
        while ( v11 == 85 );
        free(value);
      }
      Context = v12;
      v1 = v14 + 1;
    }
    while ( v14 + 1 < v12->EffectSlotMap.size );
  }
}

//----- (0023EF2C) --------------------------------------------------------
void __fastcall alGenBuffers(ALsizei n, ALuint *buffers)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_LastError; // r4
  ALsizei v5; // r5
  ALuint *v6; // r0
  ALuint *v7; // r4
  ALenum inserted; // r0
  ALuint v9; // r6
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  ALenum *v14; // r1
  unsigned int *v15; // r0
  unsigned int v16; // r0
  unsigned int *v23; // [sp+4h] [bp-34h]
  ALCcontext *v24; // [sp+8h] [bp-30h]
  ALsizei v25; // [sp+Ch] [bp-2Ch]
  UIntMap_0 *map; // [sp+14h] [bp-24h]
  UIntMap_0 *mapa; // [sp+14h] [bp-24h]
  ALsizei v29; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    v24 = ContextRef;
    p_LastError = (unsigned int *)&ContextRef->LastError;
    v23 = (unsigned int *)&ContextRef->LastError;
    v25 = n;
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex(p_LastError) )
      {
LABEL_70:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_70;
        }
      }
      __dmb(0xBu);
    }
    else if ( n >= 1 )
    {
      v5 = 0;
      map = &ContextRef->Device->BufferMap;
      while ( 1 )
      {
        v6 = (ALuint *)calloc(1u, 0x48u);
        v7 = v6;
        if ( !v6 )
          break;
        v29 = v5;
        v6[12] = 0;
        v6[13] = 0;
        v6[14] = 0;
        v6[15] = 0;
        v6[16] = 0;
        inserted = j_NewThunkEntry(v6 + 17);
        v9 = v7[17];
        if ( inserted || (inserted = j_InsertUIntMapEntry(map, v7[17], v7), v9 = v7[17], inserted) )
        {
          mapa = (UIntMap_0 *)inserted;
          __dmb(0xBu);
          do
            v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
          while ( 1 )
          {
            __dmb(0xBu);
            if ( v10 != 1 )
              break;
            sched_yield();
            __dmb(0xBu);
            do
              v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
          }
          __dmb(0xBu);
          do
            v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
          while ( 1 )
          {
            __dmb(0xBu);
            if ( v11 != 1 )
              break;
            sched_yield();
            __dmb(0xBu);
            do
              v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
          }
          __dmb(0xBu);
          do
            v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(v12 + 1, (unsigned int *)&ThunkLock.read_count) );
          __dmb(0xBu);
          if ( !v12 )
          {
            __dmb(0xBu);
            do
              v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
            while ( 1 )
            {
              __dmb(0xBu);
              if ( v13 != 1 )
                break;
              sched_yield();
              __dmb(0xBu);
              do
                v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
            }
          }
          __dmb(0xBu);
          do
            __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
          __dmb(0xBu);
          if ( v9 - 1 < ThunkArraySize )
          {
            v14 = ThunkArray;
            __dmb(0xBu);
            v15 = (unsigned int *)&v14[v9 - 1];
            do
              __ldrex(v15);
            while ( __strex(0, v15) );
            __dmb(0xBu);
          }
          __dmb(0xBu);
          do
            v16 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(v16 - 1, (unsigned int *)&ThunkLock.read_count) );
          __dmb(0xBu);
          if ( v16 == 1 )
          {
            __dmb(0xBu);
            do
              __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
            __dmb(0xBu);
          }
          free(v7);
          if ( TrapALError )
            raise(5);
          if ( __ldrex(v23) )
          {
LABEL_51:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex((unsigned int)mapa, v23) )
            {
              if ( __ldrex(v23) )
                goto LABEL_51;
            }
          }
          goto LABEL_61;
        }
        buffers[v5++] = v9;
        if ( v29 + 1 >= v25 )
          goto LABEL_63;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex(v23) )
      {
LABEL_60:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(0xA005u, v23) )
        {
          if ( __ldrex(v23) )
            goto LABEL_60;
        }
      }
LABEL_61:
      __dmb(0xBu);
      if ( v5 >= 1 )
        j_alDeleteBuffers(v5, buffers);
    }
LABEL_63:
    ALCcontext_DecRef(v24);
  }
}
// 23F152: conditional instruction was optimized away because r1.4!=0

//----- (0023F22C) --------------------------------------------------------
void __fastcall RWLockInit(RWLock *lock)
{
  lock->read_count = 0;
  lock->write_count = 0;
  lock->read_lock = 0;
  lock->read_entry_lock = 0;
  lock->write_lock = 0;
}

//----- (0023F23C) --------------------------------------------------------
void __fastcall alDeleteBuffers(ALsizei n, const ALuint *buffers)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_ref; // r4
  int v6; // r4
  UIntMap_0 *p_BufferMap; // r9
  ALuint v8; // r1
  _DWORD *v9; // r0
  int v10; // r1
  void **v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int v15; // r0
  ALenum *v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r0
  unsigned int *v20; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v26; // r0
  ALCcontext *v28; // [sp+0h] [bp-38h]
  char *v29; // [sp+8h] [bp-30h]
  void **p; // [sp+14h] [bp-24h]
  int v31; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  p_ref = (unsigned int *)&ContextRef->ref;
  if ( ContextRef )
  {
    v28 = ContextRef;
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_ref) )
      {
        v20 = p_ref + 20;
        __dmb(0xBu);
        do
        {
          if ( !__strex(0xA003u, v20) )
            goto LABEL_71;
        }
        while ( !__ldrex(v20) );
      }
LABEL_70:
      __clrex();
LABEL_71:
      __dmb(0xBu);
    }
    else if ( n )
    {
      v6 = 0;
      p_BufferMap = &ContextRef->Device->BufferMap;
      while ( 1 )
      {
        v8 = buffers[v6];
        if ( v8 )
        {
          v9 = j_LookupUIntMapKey(p_BufferMap, v8);
          if ( !v9 )
          {
            if ( TrapALError )
              raise(5);
            if ( __ldrex((unsigned int *)&v28->ref) )
              goto LABEL_70;
            p_LastError = (unsigned int *)&v28->LastError;
            __dmb(0xBu);
            while ( __strex(0xA001u, p_LastError) )
            {
              if ( __ldrex(p_LastError) )
                goto LABEL_70;
            }
            goto LABEL_71;
          }
          if ( v9[11] )
          {
            if ( TrapALError )
              raise(5);
            if ( __ldrex((unsigned int *)&v28->ref) )
              goto LABEL_70;
            v26 = (unsigned int *)&v28->LastError;
            __dmb(0xBu);
            while ( __strex(0xA004u, v26) )
            {
              if ( __ldrex(v26) )
                goto LABEL_70;
            }
            goto LABEL_71;
          }
        }
        if ( ++v6 >= n )
        {
          v10 = 0;
          do
          {
            v31 = v10;
            v11 = (void **)j_RemoveUIntMapKey(p_BufferMap, buffers[v10]);
            if ( v11 )
            {
              p = v11;
              v29 = (char *)v11[17];
              __dmb(0xBu);
              do
                v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v12 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              }
              __dmb(0xBu);
              do
                v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v13 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              }
              __dmb(0xBu);
              do
                v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v14 + 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( !v14 )
              {
                __dmb(0xBu);
                do
                  v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                while ( 1 )
                {
                  __dmb(0xBu);
                  if ( v15 != 1 )
                    break;
                  sched_yield();
                  __dmb(0xBu);
                  do
                    v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
                  while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                }
              }
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
              if ( (unsigned int)(v29 - 1) < ThunkArraySize )
              {
                v16 = ThunkArray;
                __dmb(0xBu);
                v17 = (unsigned int *)&v16[(_DWORD)(v29 - 1)];
                do
                  __ldrex(v17);
                while ( __strex(0, v17) );
                __dmb(0xBu);
              }
              __dmb(0xBu);
              do
                v18 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v18 - 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( v18 == 1 )
              {
                __dmb(0xBu);
                do
                  __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
                __dmb(0xBu);
              }
              free(*p);
              free(p);
            }
            v10 = v31 + 1;
          }
          while ( v31 + 1 != n );
          break;
        }
      }
    }
    ALCcontext_DecRef(v28);
  }
}
// 23F29E: conditional instruction was optimized away because r6.4>=1

//----- (0023F534) --------------------------------------------------------
ALboolean __fastcall alIsBuffer(ALuint buffer)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r4
  bool v4; // r5

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( !ContextRef )
    return 0;
  if ( buffer )
    v4 = j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) != 0;
  else
    v4 = 1;
  j_ALCcontext_DecRef(v3);
  return v4;
}

//----- (0023F56C) --------------------------------------------------------
void __fastcall alBufferData(ALuint buffer, ALenum format, const ALvoid *data, ALsizei size, ALuint a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r11
  ALbuffer_0 *v11; // r9
  unsigned int v12; // r1
  void **v13; // r0
  unsigned int *v15; // r0
  unsigned int *v18; // r0
  unsigned int *v21; // r0
  UserFmtType v23; // r2
  unsigned int v24; // r1
  UserFmtChannels v25; // r4
  int v26; // r0
  int v27; // r0
  int v28; // r1
  int v29; // r1
  unsigned int *v31; // r0
  unsigned int *p_LastError; // r0
  unsigned int v36; // r5
  ALenum v37; // r4
  unsigned int v38; // r5
  unsigned int *v40; // r0
  unsigned int v42; // r5
  unsigned int *v44; // r0
  unsigned int v46; // r5
  unsigned int *v48; // r0
  ALenum v50; // r4
  unsigned int v51; // r5
  unsigned int *v53; // r0
  unsigned int *v56; // r0
  ALenum v58; // r4
  unsigned int v59; // r5
  unsigned int *v61; // r0
  UserFmtChannels v63; // [sp+14h] [bp-24h]

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( !ContextRef )
    return;
  v11 = (ALbuffer_0 *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
  if ( v11 )
  {
    if ( ((a5 | size) & 0x80000000) == 0 )
    {
      v12 = 0;
      v13 = &off_5FCB24;
      do
      {
        if ( *(v13 - 1) == (void *)format )
        {
          v23 = (UserFmtType)v13[1];
          v24 = v23 - 5120;
          v25 = (UserFmtChannels)*v13;
          switch ( v23 )
          {
            case UserFmtByte:
            case UserFmtUByte:
            case UserFmtShort:
            case UserFmtUShort:
            case UserFmtFloat:
              if ( (unsigned int)(v25 - 5376) > 6 )
                v26 = 0;
              else
                v26 = dword_60A3C0[v25 - 5376];
              if ( v24 > 6 )
                v28 = 0;
              else
                v28 = dword_60A410[v24];
              if ( size % (unsigned int)(v28 * v26) )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  p_LastError = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(0xA003u, p_LastError) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(p_LastError) );
                }
                goto LABEL_120;
              }
              v38 = LoadData(v11, a5, format, size / (unsigned int)(v28 * v26), v25, v23, data, 1);
              if ( v38 )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v40 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(v38, v40) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v40) );
                }
                goto LABEL_120;
              }
              break;
            case UserFmtInt:
            case UserFmtUInt:
            case UserFmtDouble:
            case UserFmtByte3:
            case UserFmtUByte3:
              if ( (unsigned int)(v25 - 5376) > 6 )
                v27 = 0;
              else
                v27 = dword_60A3C0[v25 - 5376];
              if ( (unsigned int)(v23 - 5124) > 5 )
                v29 = 0;
              else
                v29 = dword_23FA58[v23 - 5124];
              if ( size % (unsigned int)(v29 * v27) )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v31 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(0xA003u, v31) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v31) );
                }
                goto LABEL_120;
              }
              v63 = v25;
              if ( (unsigned int)(v25 - 5377) > 5 )
                v37 = 65552;
              else
                v37 = dword_23FA74[v25 - 5377];
              v46 = LoadData(v11, a5, v37, size / (unsigned int)(v29 * v27), v63, v23, data, 1);
              if ( v46 )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v48 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(v46, v48) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v48) );
                }
                goto LABEL_120;
              }
              break;
            case UserFmtMulaw:
            case UserFmtAlaw:
              if ( (unsigned int)(v25 - 5376) > 6 )
                v36 = 0;
              else
                v36 = dword_60A3C0[v25 - 5376];
              if ( size % v36 )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v44 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(0xA003u, v44) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v44) );
                }
                goto LABEL_120;
              }
              if ( (unsigned int)(v25 - 5377) > 5 )
                v50 = 4353;
              else
                v50 = dword_23FA2C[v25 - 5377];
              v51 = LoadData(v11, a5, v50, size / v36, (UserFmtChannels)*v13, v23, data, 1);
              if ( v51 )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v53 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(v51, v53) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v53) );
                }
                goto LABEL_120;
              }
              break;
            case UserFmtIMA4:
              if ( (unsigned int)(v25 - 5376) > 6 )
                v42 = 0;
              else
                v42 = off_60A3A0[v25 - 5376];
              if ( size % v42 )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v56 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(0xA003u, v56) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v56) );
                }
                goto LABEL_120;
              }
              if ( (unsigned int)(v25 - 5377) > 5 )
                v58 = 4353;
              else
                v58 = dword_23FA2C[v25 - 5377];
              v59 = LoadData(v11, a5, v58, 65 * (size / v42), (UserFmtChannels)*v13, UserFmtIMA4, data, 1);
              if ( v59 )
              {
                if ( TrapALError )
                  raise(5);
                if ( !__ldrex((unsigned int *)&v10->ref) )
                {
                  v61 = (unsigned int *)&v10->LastError;
                  __dmb(0xBu);
                  do
                  {
                    if ( !__strex(v59, v61) )
                      goto LABEL_121;
                  }
                  while ( !__ldrex(v61) );
                }
                goto LABEL_120;
              }
              break;
            default:
              goto LABEL_122;
          }
          goto LABEL_122;
        }
        ++v12;
        v13 += 3;
      }
      while ( v12 < 0x24 );
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v10->ref) )
        goto LABEL_120;
      v15 = (unsigned int *)&v10->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v15) )
      {
        if ( __ldrex(v15) )
          goto LABEL_120;
      }
      goto LABEL_121;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v10->ref) )
    {
      v21 = (unsigned int *)&v10->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v21) )
      {
        if ( __ldrex(v21) )
          goto LABEL_120;
      }
      goto LABEL_121;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v10->ref) )
    {
      v18 = (unsigned int *)&v10->LastError;
      __dmb(0xBu);
      while ( __strex(0xA001u, v18) )
      {
        if ( __ldrex(v18) )
          goto LABEL_120;
      }
      goto LABEL_121;
    }
  }
LABEL_120:
  __clrex();
LABEL_121:
  __dmb(0xBu);
LABEL_122:
  ALCcontext_DecRef(v10);
}
// 23FA2C: using guessed type int dword_23FA2C[];
// 23FA58: using guessed type int dword_23FA58[6];
// 23FA74: using guessed type int dword_23FA74[3];
// 5FCB24: using guessed type void *off_5FCB24;
// 60A3A0: using guessed type int off_60A3A0[5];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];
// 60A410: using guessed type _DWORD dword_60A410[7];

//----- (0023FAA4) --------------------------------------------------------
ALenum __fastcall LoadData(
        ALbuffer_0 *ALBuf,
        ALuint freq,
        ALenum NewFormat,
        ALsizei frames,
        UserFmtChannels SrcChannels,
        UserFmtType SrcType,
        const ALvoid *data,
        int storesrc)
{
  int v9; // r0
  ALenum result; // r0
  void **v11; // r0
  char *v12; // r8
  ALsizei v13; // r6
  unsigned int v14; // r4
  size_t v15; // r10
  int v16; // r9
  unsigned int *p_write_count; // r11
  unsigned int v18; // r0
  unsigned int *p_read_lock; // r6
  unsigned int v20; // r0
  unsigned int v21; // r0
  ALbuffer_0 *v22; // r6
  unsigned int *p_write_lock; // r8
  unsigned int v24; // r0
  unsigned int v25; // r0
  unsigned int v26; // r0
  unsigned int *v27; // r0
  void *v28; // r0
  unsigned int v29; // r0
  unsigned int *v30; // r0
  ALuint v31; // r4
  ALenum v32; // lr
  int v33; // r0
  unsigned int v34; // r1
  int v35; // r0
  unsigned int v36; // r1
  unsigned int *v37; // r1
  unsigned __int32 v38; // [sp+Ch] [bp-34h]
  ALsizei numchans; // [sp+10h] [bp-30h]
  UserFmtType v43; // [sp+20h] [bp-20h]

  switch ( NewFormat )
  {
    case 4612:
      v9 = 11;
      goto LABEL_26;
    case 4613:
      v9 = 12;
      goto LABEL_26;
    case 4614:
      v9 = 13;
      goto LABEL_26;
    case 4615:
      v9 = 6;
      goto LABEL_26;
    case 4616:
      v9 = 7;
      goto LABEL_26;
    case 4617:
      v9 = 8;
      goto LABEL_26;
    case 4618:
      v9 = 14;
      goto LABEL_26;
    case 4619:
      v9 = 15;
      goto LABEL_26;
    case 4620:
      v9 = 16;
      goto LABEL_26;
    case 4621:
      v9 = 17;
      goto LABEL_26;
    case 4622:
      v9 = 18;
      goto LABEL_26;
    case 4623:
      v9 = 19;
      goto LABEL_26;
    case 4624:
      v9 = 20;
      goto LABEL_26;
    case 4625:
      v9 = 21;
      goto LABEL_26;
    case 4626:
      v9 = 22;
LABEL_26:
      v11 = &DecomposeFormat_list + 3 * v9;
      if ( v11[1] != (void *)SrcChannels )
        return 40962;
      v12 = (char *)v11[2];
      if ( (unsigned int)(SrcChannels - 5376) > 6 )
        v13 = 0;
      else
        v13 = dword_60A3C0[SrcChannels - 5376];
      if ( (unsigned int)(v12 - 5120) > 6 )
        v14 = 0;
      else
        v14 = dword_60A2C0[(_DWORD)(v12 - 5120)];
      v15 = frames * v13 * v14;
      v16 = (frames * (unsigned __int64)(unsigned int)v13 * v14) >> 32;
      if ( (frames * (unsigned __int64)(unsigned int)v13 * v14) >> 31 )
        return 40965;
      v38 = SrcChannels - 5376;
      p_write_count = (unsigned int *)&ALBuf->lock.write_count;
      numchans = v13;
      v43 = (UserFmtType)v11[2];
      __dmb(0xBu);
      do
        v18 = __ldrex(p_write_count);
      while ( __strex(v18 + 1, p_write_count) );
      __dmb(0xBu);
      if ( !v18 )
      {
        p_read_lock = (unsigned int *)&ALBuf->lock.read_lock;
        __dmb(0xBu);
        do
          v20 = __ldrex(p_read_lock);
        while ( __strex(1u, p_read_lock) );
        __dmb(0xBu);
        if ( v20 == 1 )
        {
          do
          {
            sched_yield();
            __dmb(0xBu);
            do
              v21 = __ldrex(p_read_lock);
            while ( __strex(1u, p_read_lock) );
            __dmb(0xBu);
          }
          while ( v21 == 1 );
        }
      }
      v22 = ALBuf;
      p_write_lock = (unsigned int *)&ALBuf->lock.write_lock;
      __dmb(0xBu);
      do
        v24 = __ldrex(p_write_lock);
      while ( __strex(1u, p_write_lock) );
      __dmb(0xBu);
      if ( v24 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v25 = __ldrex(p_write_lock);
          while ( __strex(1u, p_write_lock) );
          __dmb(0xBu);
        }
        while ( v25 == 1 );
      }
      if ( ALBuf->ref )
      {
        __dmb(0xBu);
        do
          __ldrex(p_write_lock);
        while ( __strex(0, p_write_lock) );
        __dmb(0xBu);
        __dmb(0xBu);
        do
          v26 = __ldrex(p_write_count);
        while ( __strex(v26 - 1, p_write_count) );
        __dmb(0xBu);
        if ( v26 == 1 )
        {
          v27 = (unsigned int *)&ALBuf->lock.read_lock;
          __dmb(0xBu);
          do
            __ldrex(v27);
          while ( __strex(0, v27) );
          __dmb(0xBu);
          return 40964;
        }
        else
        {
          return 40964;
        }
      }
      else
      {
        v28 = realloc(ALBuf->data, v15);
        if ( !(v15 | v16) || v28 )
        {
          ALBuf->data = v28;
          if ( data )
            ConvertData(v28, v43, data, SrcType, numchans, frames);
          ALBuf->OriginalChannels = SrcChannels;
          if ( storesrc )
          {
            ALBuf->OriginalType = SrcType;
            v31 = freq;
            v32 = NewFormat;
            if ( SrcType == UserFmtIMA4 )
            {
              v33 = 36 * (frames / 65);
              if ( v38 > 6 )
                v34 = 0;
              else
                v34 = dword_60A3C0[v38];
            }
            else
            {
              if ( v38 > 6 )
                v35 = 0;
              else
                v35 = dword_60A3C0[v38];
              if ( (unsigned int)(SrcType - 5120) > 0xB )
                v34 = 0;
              else
                v34 = dword_60A3E0[SrcType - 5120];
              v33 = v35 * frames;
            }
          }
          else
          {
            v34 = v14;
            ALBuf->OriginalType = v43;
            v33 = numchans * frames;
            v31 = freq;
            v32 = NewFormat;
          }
          v22->Frequency = v31;
          v22->Format = v32;
          v22->SampleLen = frames;
          v22->FmtChannels = SrcChannels;
          v22->FmtType = v43;
          v22->OriginalSize = v33 * v34;
          v22->LoopStart = 0;
          v22->LoopEnd = frames;
          __dmb(0xBu);
          do
            __ldrex(p_write_lock);
          while ( __strex(0, p_write_lock) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            v36 = __ldrex(p_write_count);
          while ( __strex(v36 - 1, p_write_count) );
          result = 0;
          __dmb(0xBu);
          if ( v36 == 1 )
          {
            v37 = (unsigned int *)&v22->lock.read_lock;
            __dmb(0xBu);
            do
              __ldrex(v37);
            while ( __strex(0, v37) );
            result = 0;
            __dmb(0xBu);
          }
        }
        else
        {
          __dmb(0xBu);
          do
            __ldrex(p_write_lock);
          while ( __strex(0, p_write_lock) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            v29 = __ldrex(p_write_count);
          while ( __strex(v29 - 1, p_write_count) );
          __dmb(0xBu);
          if ( v29 == 1 )
          {
            v30 = (unsigned int *)&ALBuf->lock.read_lock;
            __dmb(0xBu);
            do
              __ldrex(v30);
            while ( __strex(0, v30) );
            __dmb(0xBu);
            return 40965;
          }
          else
          {
            return 40965;
          }
        }
      }
      return result;
    default:
      v9 = 0;
      switch ( NewFormat )
      {
        case 4352:
          goto LABEL_26;
        case 4353:
          v9 = 1;
          goto LABEL_26;
        case 4354:
          v9 = 3;
          goto LABEL_26;
        case 4355:
          v9 = 4;
          goto LABEL_26;
        default:
          result = 40962;
          switch ( NewFormat )
          {
            case 65540:
              v9 = 9;
              goto LABEL_26;
            case 65541:
              v9 = 10;
              goto LABEL_26;
            case 65552:
              v9 = 2;
              goto LABEL_26;
            case 65553:
              v9 = 5;
              goto LABEL_26;
            default:
              return result;
          }
      }
      return result;
  }
}
// 6: using guessed type char byte_6;
// 5FCCD0: using guessed type void *DecomposeFormat_list;
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];
// 60A3E0: using guessed type _DWORD dword_60A3E0[12];

//----- (0023FE54) --------------------------------------------------------
ALuint __fastcall ChannelsFromUserFmt(UserFmtChannels chans)
{
  unsigned __int32 v1; // r0

  v1 = chans - 5376;
  if ( v1 <= 6 )
    return dword_60A3C0[v1];
  else
    return 0;
}
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (0023FE70) --------------------------------------------------------
void __fastcall alBufferSubDataSOFT(ALuint buffer, ALenum format, const ALvoid *data, ALsizei offset, unsigned int a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r9
  _DWORD *v11; // r0
  void **v12; // r3
  unsigned int v13; // r1
  unsigned int *p_LastError; // r0
  unsigned int *v18; // r0
  unsigned int *v21; // r0
  unsigned int *v23; // r5
  unsigned int v24; // r0
  unsigned int *v25; // r6
  unsigned int v26; // r0
  unsigned int v27; // r0
  unsigned int *v28; // r6
  unsigned int v29; // r0
  unsigned int v30; // r0
  _DWORD *v31; // r12
  __int64 v32; // r0
  unsigned int v33; // r2
  unsigned int v34; // r4
  int v35; // r2
  const ALvoid *v36; // r8
  int v37; // r3
  unsigned int v38; // r0
  unsigned int *v39; // r0
  unsigned int *v41; // r0
  ALsizei v43; // r0
  bool v44; // cc
  unsigned int v45; // r0
  unsigned int *v46; // r0
  unsigned int *v48; // r0
  unsigned int v50; // r0
  unsigned int v51; // r0
  int v52; // r0
  unsigned int v53; // r3
  unsigned int v54; // r11
  unsigned int v55; // r0
  unsigned int v56; // r0
  unsigned int *v57; // r0
  int v58; // [sp+8h] [bp-30h]
  __int64 srcType; // [sp+Ch] [bp-2Ch]
  unsigned int numchans; // [sp+14h] [bp-24h]
  _DWORD *v61; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( !ContextRef )
    return;
  v11 = j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
  if ( v11 )
  {
    if ( ((a5 | offset) & 0x80000000) == 0 )
    {
      v12 = &off_5FCB24;
      v13 = 0;
      while ( *(v12 - 1) != (void *)format )
      {
        ++v13;
        v12 += 3;
        if ( v13 >= 0x24 )
        {
          if ( TrapALError )
            raise(5);
          if ( __ldrex((unsigned int *)&v10->ref) )
            goto LABEL_91;
          p_LastError = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_91;
          }
          goto LABEL_92;
        }
      }
      v23 = v11 + 13;
      HIDWORD(srcType) = *v12;
      LODWORD(srcType) = v12[1];
      __dmb(0xBu);
      v61 = v11;
      do
        v24 = __ldrex(v23);
      while ( __strex(v24 + 1, v23) );
      __dmb(0xBu);
      if ( !v24 )
      {
        __dmb(0xBu);
        v25 = v61 + 14;
        do
          v26 = __ldrex(v25);
        while ( __strex(1u, v25) );
        __dmb(0xBu);
        if ( v26 == 1 )
        {
          do
          {
            sched_yield();
            __dmb(0xBu);
            do
              v27 = __ldrex(v25);
            while ( __strex(1u, v25) );
            __dmb(0xBu);
          }
          while ( v27 == 1 );
        }
      }
      __dmb(0xBu);
      v28 = v61 + 16;
      do
        v29 = __ldrex(v28);
      while ( __strex(1u, v28) );
      __dmb(0xBu);
      if ( v29 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v30 = __ldrex(v28);
          while ( __strex(1u, v28) );
          __dmb(0xBu);
        }
        while ( v30 == 1 );
      }
      v31 = v61;
      LODWORD(v32) = v61[7];
      HIDWORD(v32) = v61[6];
      v33 = HIDWORD(v32) - 5376;
      if ( (_DWORD)v32 == 5132 )
      {
        if ( v33 >= 7 )
          v34 = 0;
        else
          v34 = off_60A3A0[v33];
        v36 = data;
      }
      else
      {
        if ( v33 > 6 )
          v35 = 0;
        else
          v35 = dword_60A3C0[v33];
        if ( (unsigned int)(v32 - 5120) > 0xB )
          v37 = 0;
        else
          v37 = dword_60A3E0[(_DWORD)v32 - 5120];
        v36 = data;
        v34 = v37 * v35;
      }
      if ( srcType == v32 )
      {
        v43 = v61[8];
        v44 = v43 < offset;
        if ( v43 >= offset )
          v44 = v43 - offset < (int)a5;
        if ( v44 || (v31 = v61, offset % v34) || (v31 = v61, a5 % v34) )
        {
          __dmb(0xBu);
          do
            __ldrex(v28);
          while ( __strex(0, v28) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            v45 = __ldrex(v23);
          while ( __strex(v45 - 1, v23) );
          __dmb(0xBu);
          if ( v45 == 1 )
          {
            v46 = v31 + 14;
            __dmb(0xBu);
            do
              __ldrex(v46);
            while ( __strex(0, v46) );
            __dmb(0xBu);
          }
          if ( TrapALError )
            raise(5);
          if ( __ldrex((unsigned int *)&v10->ref) )
            goto LABEL_91;
          v48 = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v48) )
          {
            if ( __ldrex(v48) )
              goto LABEL_91;
          }
        }
        else
        {
          v50 = v61[4] - 5376;
          if ( v50 > 6 )
            v51 = 0;
          else
            v51 = dword_60A3C0[v50];
          numchans = v51;
          HIDWORD(srcType) = v61[5];
          if ( (unsigned int)(HIDWORD(srcType) - 5120) > 6 )
            v52 = 0;
          else
            v52 = dword_60A2C0[HIDWORD(srcType) - 5120];
          v58 = v52;
          v53 = 1;
          switch ( (int)srcType )
          {
            case 5120:
            case 5121:
            case 5130:
            case 5131:
              goto LABEL_107;
            case 5122:
            case 5123:
              v53 = 2;
              goto LABEL_107;
            case 5124:
            case 5125:
            case 5126:
              v53 = 4;
              goto LABEL_107;
            case 5127:
              v53 = 8;
              goto LABEL_107;
            case 5128:
            case 5129:
              v53 = 3;
              goto LABEL_107;
            case 5132:
              v54 = 65 * (offset / 36);
              v55 = 65 * (a5 / v34);
              goto LABEL_108;
            default:
              v53 = 0;
LABEL_107:
              v54 = offset / v53;
              v55 = a5 / v53 / numchans;
LABEL_108:
              ConvertData((ALvoid *)(*v61 + v54 * v58), SHIDWORD(srcType), v36, (UserFmtType)srcType, numchans, v55);
              __dmb(0xBu);
              do
                __ldrex(v28);
              while ( __strex(0, v28) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                v56 = __ldrex(v23);
              while ( __strex(v56 - 1, v23) );
              __dmb(0xBu);
              if ( v56 != 1 )
                goto LABEL_93;
              v57 = v61 + 14;
              __dmb(0xBu);
              do
                __ldrex(v57);
              while ( __strex(0, v57) );
              break;
          }
        }
      }
      else
      {
        __dmb(0xBu);
        do
          __ldrex(v28);
        while ( __strex(0, v28) );
        __dmb(0xBu);
        __dmb(0xBu);
        do
          v38 = __ldrex(v23);
        while ( __strex(v38 - 1, v23) );
        __dmb(0xBu);
        if ( v38 == 1 )
        {
          v39 = v61 + 14;
          __dmb(0xBu);
          do
            __ldrex(v39);
          while ( __strex(0, v39) );
          __dmb(0xBu);
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&v10->ref) )
          goto LABEL_91;
        v41 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v41) )
        {
          if ( __ldrex(v41) )
            goto LABEL_91;
        }
      }
      goto LABEL_92;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v10->ref) )
    {
      v21 = (unsigned int *)&v10->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v21) )
      {
        if ( __ldrex(v21) )
          goto LABEL_91;
      }
      goto LABEL_92;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v10->ref) )
    {
      v18 = (unsigned int *)&v10->LastError;
      __dmb(0xBu);
      while ( __strex(0xA001u, v18) )
      {
        if ( __ldrex(v18) )
          goto LABEL_91;
      }
      goto LABEL_92;
    }
  }
LABEL_91:
  __clrex();
LABEL_92:
  __dmb(0xBu);
LABEL_93:
  ALCcontext_DecRef(v10);
}
// 5FCB24: using guessed type void *off_5FCB24;
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3A0: using guessed type int off_60A3A0[5];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];
// 60A3E0: using guessed type _DWORD dword_60A3E0[12];

//----- (00240308) --------------------------------------------------------
void __fastcall WriteLock(RWLock *lock)
{
  unsigned int *p_write_count; // r0
  unsigned int v3; // r1
  unsigned int *p_read_lock; // r5
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int *p_write_lock; // r4
  unsigned int v8; // r0
  unsigned int v9; // r0

  p_write_count = (unsigned int *)&lock->write_count;
  __dmb(0xBu);
  do
    v3 = __ldrex(p_write_count);
  while ( __strex(v3 + 1, p_write_count) );
  __dmb(0xBu);
  if ( !v3 )
  {
    p_read_lock = (unsigned int *)&lock->read_lock;
    __dmb(0xBu);
    do
      v5 = __ldrex(p_read_lock);
    while ( __strex(1u, p_read_lock) );
    __dmb(0xBu);
    if ( v5 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v6 = __ldrex(p_read_lock);
        while ( __strex(1u, p_read_lock) );
        __dmb(0xBu);
      }
      while ( v6 == 1 );
    }
  }
  p_write_lock = (unsigned int *)&lock->write_lock;
  __dmb(0xBu);
  do
    v8 = __ldrex(p_write_lock);
  while ( __strex(1u, p_write_lock) );
  __dmb(0xBu);
  if ( v8 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v9 = __ldrex(p_write_lock);
      while ( __strex(1u, p_write_lock) );
      __dmb(0xBu);
    }
    while ( v9 == 1 );
  }
}

//----- (002403AA) --------------------------------------------------------
void __fastcall WriteUnlock(RWLock *lock)
{
  unsigned int *p_write_lock; // r1
  unsigned int *p_write_count; // r12
  unsigned int v3; // r2
  unsigned int *p_read_lock; // r0

  p_write_lock = (unsigned int *)&lock->write_lock;
  __dmb(0xBu);
  do
    __ldrex(p_write_lock);
  while ( __strex(0, p_write_lock) );
  p_write_count = (unsigned int *)&lock->write_count;
  __dmb(0xBu);
  __dmb(0xBu);
  do
    v3 = __ldrex(p_write_count);
  while ( __strex(v3 - 1, p_write_count) );
  __dmb(0xBu);
  if ( v3 == 1 )
  {
    p_read_lock = (unsigned int *)&lock->read_lock;
    __dmb(0xBu);
    do
      __ldrex(p_read_lock);
    while ( __strex(0, p_read_lock) );
    __dmb(0xBu);
  }
}

//----- (00240400) --------------------------------------------------------
ALuint __fastcall ChannelsFromFmt(FmtChannels chans)
{
  unsigned __int32 v1; // r0

  v1 = chans - 5376;
  if ( v1 <= 6 )
    return dword_60A3C0[v1];
  else
    return 0;
}
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (0024041C) --------------------------------------------------------
ALuint __fastcall BytesFromFmt(FmtType type)
{
  unsigned __int32 v1; // r0

  v1 = type - 5120;
  if ( v1 <= 6 )
    return dword_60A2C0[v1];
  else
    return 0;
}
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];

//----- (00240438) --------------------------------------------------------
ALuint __fastcall BytesFromUserFmt(UserFmtType type)
{
  unsigned __int32 v1; // r0

  v1 = type - 5120;
  if ( v1 <= 0xB )
    return dword_60A3E0[v1];
  else
    return 0;
}
// 60A3E0: using guessed type _DWORD dword_60A3E0[12];

//----- (00240458) --------------------------------------------------------
void __fastcall ConvertData(
        ALvoid *dst,
        UserFmtType dstType,
        const ALvoid *src,
        UserFmtType srcType,
        ALsizei numchans,
        ALsizei len)
{
  int32x4_t v6; // q8
  int64x2_t v7; // q9
  int v8; // r1
  unsigned int v9; // r12
  int64x2_t v10; // q8
  int v11; // r1
  unsigned int v12; // r12
  int v13; // r1
  unsigned int v14; // r12
  int32x4_t v15; // q8
  int v16; // r1
  unsigned int v17; // r12
  ALsizei v18; // r4
  unsigned int v19; // r0
  int64x2_t *v20; // r3
  ALima4 *v21; // lr
  ALima4 *v22; // r6
  int16x4_t *v23; // r4
  unsigned int v24; // r0
  int8x8_t *v25; // r5
  int8x8_t v26; // d18
  int16x8_t v27; // q9
  unsigned int v28; // r0
  __int16 v29; // t1
  int v30; // r1
  unsigned int v31; // r12
  ALsizei v32; // r4
  unsigned int v33; // r0
  int64x2_t *v34; // r3
  ALima4 *v35; // r8
  ALima4 *v36; // r6
  unsigned int v37; // r0
  int32x4_t *v38; // r4
  ALima4 *v39; // r5
  unsigned __int32 v40; // t1
  unsigned int v41; // r0
  int v42; // t1
  int64x2_t v43; // q8
  int v44; // r8
  unsigned int v45; // r12
  ALsizei v46; // r3
  unsigned int v47; // r0
  unsigned int *v48; // r6
  ALima4 *v49; // r9
  ALima4 *v50; // r5
  unsigned int v51; // r0
  int64x2_t *v52; // r4
  ALima4 *v53; // r3
  unsigned __int32 v54; // t1
  unsigned int v55; // r0
  int v56; // t1
  int v57; // r0
  ALsizei v58; // r1
  ALsizei v59; // r12
  float *v60; // r2
  ALima4 *v61; // r3
  int v62; // t1
  int v63; // r0
  ALsizei v64; // r1
  ALsizei v65; // r12
  double *v66; // r2
  ALima4 *v67; // r3
  int v68; // t1
  int v69; // r1
  ALsizei v70; // r2
  ALsizei v71; // lr
  int64x2_t *v72; // r3
  ALima4 *v73; // r6
  unsigned __int8 v74; // t1
  int v75; // r1
  ALsizei v76; // r2
  ALsizei v77; // lr
  int64x2_t *v78; // r3
  ALima4 *v79; // r6
  char v80; // t1
  int i12; // r12
  int64x2_t *v82; // r5
  ALsizei v83; // r6
  ALima4 *v84; // r4
  int v85; // t1
  int v86; // r0
  int v87; // r1
  int v88; // r1
  int v89; // r3
  int i23; // lr
  int64x2_t *v91; // r6
  ALsizei v92; // r3
  ALima4 *v93; // r5
  int v94; // t1
  char v95; // r2
  int v96; // r0
  char v97; // r4
  unsigned __int8 v98; // r1
  char v99; // r2
  ALima4 *v100; // r4
  unsigned int v101; // r8
  unsigned int v102; // r5
  unsigned int v103; // r6
  unsigned int v104; // r1
  ALima4 *v105; // r0
  int8x8_t *v106; // r3
  int16x8_t *v107; // r1
  unsigned int v108; // r2
  int8x8_t v109; // d16
  ALshort *v110; // r2
  unsigned int v111; // r1
  __int16 v112; // t1
  ALima4 *v113; // r3
  int64x2_t *v114; // r2
  unsigned int v115; // r0
  int16x8_t *v116; // r5
  int8x8_t *v117; // r4
  int8x8_t v118; // d16
  ALsizei v119; // r4
  unsigned int v120; // r0
  int64x2_t *v121; // lr
  ALima4 *v122; // r6
  unsigned int v123; // r0
  __int16 v124; // t1
  ALima4 *v125; // r3
  int64x2_t *v126; // r2
  unsigned int v127; // r0
  int64x2_t *v128; // r5
  ALima4 *v129; // r4
  unsigned __int64 v130; // d16
  unsigned __int64 v131; // d17
  ALsizei v132; // r4
  unsigned int v133; // r0
  int64x2_t *v134; // lr
  ALima4 *v135; // r6
  bool v136; // cf
  unsigned int v137; // r0
  unsigned __int8 v138; // t1
  ALima4 *v139; // r3
  int64x2_t *v140; // r2
  unsigned int v141; // r0
  int64x2_t *v142; // r5
  int64x2_t *v143; // r4
  int64x2_t v144; // q9
  ALsizei v145; // r4
  unsigned int v146; // r0
  int64x2_t *v147; // lr
  ALima4 *v148; // r6
  bool v149; // cf
  unsigned int v150; // r0
  char v151; // t1
  int64x2_t v152; // q8
  int v153; // r1
  unsigned int v154; // r12
  ALima4 *v155; // r3
  int64x2_t *v156; // r2
  unsigned int v157; // r0
  int64x2_t *v158; // r5
  int64x2_t *v159; // r4
  int64x2_t v160; // q9
  ALsizei v161; // r4
  unsigned int v162; // r0
  int64x2_t *v163; // lr
  ALima4 *v164; // r6
  bool v165; // cf
  unsigned int v166; // r0
  char v167; // t1
  int v168; // r1
  unsigned int v169; // r12
  ALima4 *v170; // r3
  int64x2_t *v171; // r2
  unsigned int v172; // r0
  int8x8_t *v173; // r5
  int16x8_t *v174; // r4
  int16x8_t v175; // q8
  ALsizei v176; // r4
  unsigned int v177; // r0
  int64x2_t *v178; // lr
  ALima4 *v179; // r6
  unsigned int v180; // r0
  int v181; // r1
  unsigned int v182; // r12
  ALsizei v183; // r4
  unsigned int v184; // r0
  int64x2_t *v185; // r3
  ALima4 *v186; // lr
  ALima4 *v187; // r6
  int8x8_t *v188; // r4
  unsigned int v189; // r0
  uint16x8_t *v190; // r5
  uint16x8_t v191; // q8
  uint16x8_t v192; // q9
  unsigned int v193; // r0
  __int16 v194; // t1
  int v195; // r1
  unsigned int v196; // r12
  ALima4 *v197; // r3
  int64x2_t *v198; // r2
  unsigned int v199; // r0
  int64x2_t *v200; // r5
  uint32x4_t *v201; // r4
  uint32x4_t v202; // q8
  int32x4_t v203; // q8
  ALsizei v204; // r4
  unsigned int v205; // r0
  int64x2_t *v206; // lr
  ALima4 *v207; // r6
  unsigned int v208; // r0
  int v209; // r1
  unsigned int v210; // r12
  ALima4 *v211; // r3
  int64x2_t *v212; // r2
  unsigned int v213; // r0
  int64x2_t *v214; // r5
  uint32x4_t *v215; // r4
  uint32x4_t v216; // q8
  uint32x4_t v217; // q9
  ALsizei v218; // r4
  unsigned int v219; // r0
  int64x2_t *v220; // lr
  ALima4 *v221; // r6
  unsigned int v222; // r0
  ALima4 v223; // r5
  int v224; // r0
  ALsizei v225; // r1
  ALsizei v226; // r12
  int64x2_t *v227; // r2
  float *v228; // r3
  float v229; // s6
  int v230; // r6
  int v231; // r0
  ALsizei v232; // r1
  ALsizei v233; // r12
  int64x2_t *v234; // r2
  double *v235; // r3
  double v236; // d19
  int v237; // r6
  int v238; // r0
  ALsizei v239; // r1
  ALsizei v240; // r12
  int64x2_t *v241; // r2
  ALima4 *v242; // r3
  int v243; // r0
  ALsizei v244; // r1
  ALsizei v245; // r12
  int64x2_t *v246; // r2
  ALima4 *v247; // r3
  ALima4 v248; // r6
  int v249; // r0
  ALsizei v250; // r2
  ALsizei v251; // lr
  int64x2_t *v252; // r3
  ALima4 *v253; // r6
  int v254; // t1
  int v255; // r0
  ALsizei v256; // r2
  ALsizei v257; // lr
  int64x2_t *v258; // r3
  ALima4 *v259; // r6
  int v260; // t1
  unsigned int v261; // r4
  unsigned int v262; // r11
  unsigned int v263; // r5
  int8x8_t *v264; // r12
  ALshort *v265; // r6
  unsigned int v266; // r0
  unsigned int v267; // r3
  int8x8_t *v268; // r2
  unsigned int v269; // r3
  int16x8_t *v270; // r1
  int8x8_t *v271; // r4
  int16x8_t v272; // q8
  ALshort *v273; // r1
  int v274; // r1
  unsigned int v275; // r12
  ALima4 *v276; // r3
  int64x2_t *v277; // r2
  unsigned int v278; // r0
  int64x2_t *v279; // r5
  ALima4 *v280; // r4
  unsigned __int64 v281; // d16
  unsigned __int64 v282; // d17
  ALsizei v283; // r4
  unsigned int v284; // r0
  int64x2_t *v285; // lr
  ALima4 *v286; // r6
  bool v287; // cf
  unsigned int v288; // r0
  unsigned __int8 v289; // t1
  int v290; // r1
  unsigned int v291; // r12
  ALsizei v292; // r4
  unsigned int v293; // r0
  int64x2_t *v294; // r3
  ALima4 *v295; // lr
  ALima4 *v296; // r6
  int8x8_t *v297; // r4
  unsigned int v298; // r0
  uint16x8_t *v299; // r5
  uint16x8_t v300; // q8
  uint16x8_t v301; // q9
  unsigned int v302; // r0
  __int16 v303; // t1
  int v304; // r1
  unsigned int v305; // r12
  ALima4 *v306; // r3
  int64x2_t *v307; // r2
  unsigned int v308; // r0
  int8x8_t *v309; // r5
  int16x8_t *v310; // r4
  int16x8_t v311; // q8
  ALsizei v312; // r4
  unsigned int v313; // r0
  int64x2_t *v314; // lr
  ALima4 *v315; // r6
  unsigned int v316; // r0
  int v317; // r1
  unsigned int v318; // r12
  ALima4 *v319; // r3
  int64x2_t *v320; // r2
  unsigned int v321; // r0
  int64x2_t *v322; // r5
  uint32x4_t *v323; // r4
  uint32x4_t v324; // q8
  uint32x4_t v325; // q9
  ALsizei v326; // r4
  unsigned int v327; // r0
  int64x2_t *v328; // lr
  ALima4 *v329; // r6
  unsigned int v330; // r0
  ALima4 v331; // r5
  int v332; // r1
  unsigned int v333; // r12
  ALima4 *v334; // r3
  int64x2_t *v335; // r2
  unsigned int v336; // r0
  int64x2_t *v337; // r5
  uint32x4_t *v338; // r4
  uint32x4_t v339; // q8
  int32x4_t v340; // q8
  ALsizei v341; // r4
  unsigned int v342; // r0
  int64x2_t *v343; // lr
  ALima4 *v344; // r6
  unsigned int v345; // r0
  int v346; // r0
  ALsizei v347; // r1
  ALsizei v348; // r12
  char *v349; // r2
  float *v350; // r3
  float v351; // s6
  char v352; // r6
  int v353; // r0
  ALsizei v354; // r1
  ALsizei v355; // r12
  char *v356; // r2
  double *v357; // r3
  double v358; // d19
  char v359; // r6
  int v360; // r0
  ALsizei v361; // r1
  ALsizei v362; // r12
  int64x2_t *v363; // r2
  ALima4 *v364; // r3
  ALima4 v365; // r6
  int v366; // r0
  ALsizei v367; // r1
  ALsizei v368; // r12
  int64x2_t *v369; // r2
  ALima4 *v370; // r3
  int i; // r0
  ALsizei v372; // r3
  int64x2_t *v373; // r6
  ALima4 *v374; // r5
  int v375; // t1
  int j; // r0
  ALsizei v377; // r3
  int64x2_t *v378; // r6
  ALima4 *v379; // r5
  int v380; // t1
  unsigned int v381; // r4
  unsigned int v382; // r9
  unsigned int v383; // r10
  int8x8_t *v384; // lr
  ALshort *v385; // r6
  unsigned int v386; // r5
  unsigned int v387; // r3
  int8x8_t *v388; // r2
  unsigned int v389; // r3
  uint16x8_t *v390; // r1
  int8x8_t *v391; // r4
  uint16x8_t v392; // q8
  uint16x8_t v393; // q9
  ALshort v394; // r1
  int32x4_t v395; // q8
  int v396; // r1
  unsigned int v397; // r12
  ALsizei v398; // r4
  unsigned int v399; // r0
  int64x2_t *v400; // r3
  ALima4 *v401; // lr
  ALima4 *v402; // r6
  int16x4_t *v403; // r4
  unsigned int v404; // r0
  uint8x8_t *v405; // r5
  uint8x8_t v406; // d18
  uint16x8_t v407; // q9
  unsigned int v408; // r0
  __int16 v409; // t1
  int v410; // r1
  unsigned int v411; // r12
  ALima4 *v412; // r3
  int64x2_t *v413; // r2
  unsigned int v414; // r0
  int64x2_t *v415; // r5
  ALima4 *v416; // r4
  unsigned __int64 v417; // d16
  unsigned __int64 v418; // d17
  ALsizei v419; // r4
  unsigned int v420; // r0
  int64x2_t *v421; // lr
  ALima4 *v422; // r6
  ALima4 *v423; // r0
  bool v424; // cf
  unsigned int v425; // r0
  unsigned __int16 v426; // t1
  int v427; // r1
  unsigned int v428; // r12
  ALima4 *v429; // r3
  int64x2_t *v430; // r2
  unsigned int v431; // r0
  unsigned __int64 *v432; // r5
  ALima4 *v433; // r4
  __int64 v434; // d16
  __int64 v435; // d17
  ALsizei v436; // r4
  unsigned int v437; // r0
  int64x2_t *v438; // lr
  ALima4 *v439; // r6
  ALima4 *v440; // r0
  bool v441; // cf
  unsigned int v442; // r0
  __int16 v443; // t1
  int v444; // r1
  unsigned int v445; // r12
  ALima4 *v446; // r3
  int64x2_t *v447; // r2
  unsigned int v448; // r0
  int16x4_t *v449; // r5
  int32x4_t *v450; // r4
  int32x4_t v451; // q8
  ALsizei v452; // r4
  unsigned int v453; // r0
  int64x2_t *v454; // lr
  ALima4 *v455; // r6
  ALima4 *v456; // r0
  bool v457; // cf
  unsigned int v458; // r0
  int v459; // r1
  unsigned int v460; // r12
  ALima4 *v461; // r3
  int64x2_t *v462; // r2
  unsigned int v463; // r0
  int16x4_t *v464; // r5
  uint32x4_t *v465; // r4
  uint32x4_t v466; // q8
  uint32x4_t v467; // q9
  ALsizei v468; // r4
  unsigned int v469; // r0
  int64x2_t *v470; // lr
  ALima4 *v471; // r6
  ALima4 *v472; // r0
  bool v473; // cf
  unsigned int v474; // r0
  __int16 v475; // r5
  int v476; // r0
  ALsizei v477; // r1
  ALsizei v478; // r12
  int64x2_t *v479; // r2
  float *v480; // r3
  float v481; // s6
  int v482; // r6
  int v483; // r0
  ALsizei v484; // r1
  ALsizei v485; // r12
  int64x2_t *v486; // r2
  double *v487; // r3
  double v488; // d19
  int v489; // r6
  int v490; // r0
  ALsizei v491; // r1
  ALsizei v492; // lr
  int64x2_t *v493; // r2
  ALima4 *v494; // r3
  int v495; // r6
  int v496; // r5
  int k; // r0
  ALsizei v498; // r2
  int64x2_t *v499; // r3
  ALima4 *v500; // r6
  int v501; // r5
  int v502; // r4
  int v503; // r0
  ALsizei v504; // r2
  ALsizei v505; // lr
  int64x2_t *v506; // r3
  ALima4 *v507; // r6
  int v508; // t1
  int v509; // r0
  ALsizei v510; // r2
  ALsizei v511; // lr
  int64x2_t *v512; // r3
  ALima4 *v513; // r6
  int v514; // t1
  unsigned int v515; // r4
  unsigned int v516; // r11
  unsigned int v517; // r5
  int64x2_t *v518; // r12
  ALshort *v519; // r6
  unsigned int v520; // r0
  unsigned int v521; // r3
  int64x2_t *v522; // r2
  ALshort *v523; // r1
  bool v524; // cf
  unsigned int v525; // r3
  ALshort *v526; // r1
  int64x2_t *v527; // r4
  unsigned __int64 v528; // d16
  unsigned __int64 v529; // d17
  ALshort v530; // r1
  int v531; // r1
  unsigned int v532; // r12
  ALima4 *v533; // r3
  int64x2_t *v534; // r2
  unsigned int v535; // r0
  int16x8_t *v536; // r5
  int8x8_t *v537; // r4
  int8x8_t v538; // d16
  ALsizei v539; // r4
  unsigned int v540; // r0
  int64x2_t *v541; // lr
  ALima4 *v542; // r6
  unsigned int v543; // r0
  __int16 v544; // t1
  int v545; // r1
  unsigned int v546; // r12
  ALima4 *v547; // r3
  int64x2_t *v548; // r2
  unsigned int v549; // r0
  unsigned __int64 *v550; // r5
  ALima4 *v551; // r4
  __int64 v552; // d16
  __int64 v553; // d17
  ALsizei v554; // r4
  unsigned int v555; // r0
  int64x2_t *v556; // lr
  ALima4 *v557; // r6
  ALima4 *v558; // r0
  bool v559; // cf
  unsigned int v560; // r0
  __int16 v561; // t1
  int v562; // r1
  unsigned int v563; // r12
  ALima4 *v564; // r3
  int64x2_t *v565; // r2
  unsigned int v566; // r0
  int64x2_t *v567; // r5
  ALima4 *v568; // r4
  unsigned __int64 v569; // d16
  unsigned __int64 v570; // d17
  ALsizei v571; // r4
  unsigned int v572; // r0
  int64x2_t *v573; // lr
  ALima4 *v574; // r6
  ALima4 *v575; // r0
  bool v576; // cf
  unsigned int v577; // r0
  unsigned __int16 v578; // t1
  int v579; // r1
  unsigned int v580; // r12
  ALima4 *v581; // r3
  int64x2_t *v582; // r2
  unsigned int v583; // r0
  int16x4_t *v584; // r5
  uint32x4_t *v585; // r4
  uint32x4_t v586; // q8
  uint32x4_t v587; // q9
  ALsizei v588; // r4
  unsigned int v589; // r0
  int64x2_t *v590; // lr
  ALima4 *v591; // r6
  ALima4 *v592; // r0
  bool v593; // cf
  unsigned int v594; // r0
  __int16 v595; // r5
  int v596; // r1
  unsigned int v597; // r12
  ALima4 *v598; // r3
  int64x2_t *v599; // r2
  unsigned int v600; // r0
  int16x4_t *v601; // r5
  int32x4_t *v602; // r4
  int32x4_t v603; // q8
  ALsizei v604; // r4
  unsigned int v605; // r0
  int64x2_t *v606; // lr
  ALima4 *v607; // r6
  ALima4 *v608; // r0
  bool v609; // cf
  unsigned int v610; // r0
  int v611; // r0
  ALsizei v612; // r1
  ALsizei v613; // r12
  int64x2_t *v614; // r2
  float *v615; // r3
  float v616; // s6
  int v617; // r6
  int v618; // r0
  ALsizei v619; // r1
  ALsizei v620; // r12
  int64x2_t *v621; // r2
  double *v622; // r3
  double v623; // d19
  int v624; // r6
  int m; // r12
  int64x2_t *v626; // r6
  ALsizei v627; // r3
  ALima4 *v628; // r5
  int v629; // r4
  int v630; // r0
  int v631; // r0
  ALsizei v632; // r1
  ALsizei v633; // lr
  int64x2_t *v634; // r2
  ALima4 *v635; // r3
  int v636; // r6
  int v637; // r5
  int v638; // r0
  ALsizei v639; // r2
  ALsizei v640; // lr
  int64x2_t *v641; // r3
  ALima4 *v642; // r6
  int v643; // t1
  int v644; // r0
  ALsizei v645; // r2
  ALsizei v646; // lr
  int64x2_t *v647; // r3
  ALima4 *v648; // r6
  int v649; // t1
  ALsizei v650; // r2
  unsigned int v651; // r11
  unsigned int v652; // r10
  int64x2_t *v653; // r4
  ALshort *v654; // r6
  unsigned int v655; // r0
  unsigned int v656; // r3
  ALsizei v657; // r5
  int64x2_t *v658; // r2
  ALshort *v659; // r1
  bool v660; // cf
  unsigned int v661; // r3
  ALshort *v662; // r1
  unsigned __int64 *v663; // r5
  __int64 v664; // d16
  __int64 v665; // d17
  ALshort v666; // r1
  int64x2_t v667; // q8
  int v668; // r8
  unsigned int v669; // r12
  ALsizei v670; // r3
  unsigned int v671; // r0
  unsigned int *v672; // r6
  ALima4 *v673; // r9
  ALima4 *v674; // r5
  unsigned int v675; // r0
  int64x2_t *v676; // r4
  ALima4 *v677; // r3
  unsigned __int32 v678; // t1
  unsigned int v679; // r0
  int v680; // t1
  int v681; // r1
  unsigned int v682; // r12
  ALima4 *v683; // r3
  int64x2_t *v684; // r2
  unsigned int v685; // r0
  int32x4_t *v686; // r5
  int16x4_t *v687; // r4
  int16x4_t v688; // d16
  ALsizei v689; // r4
  unsigned int v690; // r0
  int64x2_t *v691; // lr
  ALima4 *v692; // r6
  ALima4 *v693; // r0
  bool v694; // cf
  unsigned int v695; // r0
  int v696; // t1
  int64x2_t v697; // q8
  int v698; // r1
  unsigned int v699; // r12
  ALsizei v700; // r4
  unsigned int v701; // r0
  unsigned int *v702; // r3
  ALima4 *v703; // lr
  ALima4 *v704; // r6
  ALima4 *v705; // r0
  int64x2_t *v706; // r4
  bool v707; // cf
  unsigned int v708; // r0
  int16x4_t *v709; // r5
  int16x4_t v710; // d18
  unsigned int v711; // r0
  int v712; // t1
  int v713; // r1
  unsigned int v714; // r12
  ALima4 *v715; // r3
  int64x2_t *v716; // r2
  unsigned int v717; // r0
  int64x2_t *v718; // r5
  ALima4 *v719; // r4
  unsigned __int64 v720; // d16
  unsigned __int64 v721; // d17
  ALsizei v722; // r4
  unsigned int v723; // r0
  int64x2_t *v724; // lr
  ALima4 *v725; // r6
  ALima4 *v726; // r0
  bool v727; // cf
  unsigned int v728; // r0
  unsigned __int32 v729; // t1
  int64x2_t v730; // q8
  int v731; // r1
  unsigned int v732; // r12
  ALima4 *v733; // r3
  unsigned int *v734; // r2
  unsigned int v735; // r0
  int64x2_t *v736; // r5
  int64x2_t *v737; // r4
  int64x2_t v738; // q9
  ALsizei v739; // r4
  unsigned int v740; // r0
  int64x2_t *v741; // lr
  ALima4 *v742; // r6
  ALima4 *v743; // r0
  bool v744; // cf
  unsigned int v745; // r0
  int v746; // t1
  int v747; // r0
  ALsizei v748; // r1
  ALsizei v749; // r12
  int *v750; // r2
  float *v751; // r3
  float v752; // s4
  int v753; // r6
  int v754; // r0
  ALsizei v755; // r1
  ALsizei v756; // r12
  int *v757; // r2
  double *v758; // r3
  double v759; // d19
  int v760; // r6
  int v761; // r0
  ALsizei v762; // r1
  ALsizei v763; // lr
  int64x2_t *v764; // r2
  ALima4 *v765; // r3
  int v766; // r6
  int v767; // r5
  int n; // r0
  ALsizei v769; // r2
  unsigned int *v770; // r3
  ALima4 *v771; // r6
  int v772; // r5
  int v773; // r4
  int v774; // r0
  ALsizei v775; // r2
  ALsizei v776; // lr
  int64x2_t *v777; // r3
  ALima4 *v778; // r6
  int v779; // t1
  int v780; // r0
  ALsizei v781; // r2
  ALsizei v782; // lr
  int64x2_t *v783; // r3
  ALima4 *v784; // r6
  int v785; // t1
  unsigned int v786; // r4
  unsigned int v787; // r11
  unsigned int v788; // r5
  int64x2_t *v789; // r12
  ALshort *v790; // r6
  unsigned int v791; // r0
  unsigned int v792; // r3
  int64x2_t *v793; // r2
  ALshort *v794; // r1
  bool v795; // cf
  unsigned int v796; // r3
  int16x4_t *v797; // r1
  int32x4_t *v798; // r4
  int16x4_t v799; // d16
  int v800; // r1
  int v801; // r1
  unsigned int v802; // r12
  ALsizei v803; // r4
  unsigned int v804; // r0
  int64x2_t *v805; // r3
  ALima4 *v806; // r8
  ALima4 *v807; // r6
  unsigned int v808; // r0
  int32x4_t *v809; // r4
  ALima4 *v810; // r5
  unsigned __int32 v811; // t1
  unsigned int v812; // r0
  int v813; // t1
  int64x2_t v814; // q8
  int v815; // r1
  unsigned int v816; // r12
  ALsizei v817; // r4
  unsigned int v818; // r0
  unsigned int *v819; // r3
  ALima4 *v820; // lr
  ALima4 *v821; // r6
  ALima4 *v822; // r0
  int64x2_t *v823; // r4
  bool v824; // cf
  unsigned int v825; // r0
  int16x4_t *v826; // r5
  int16x4_t v827; // d18
  unsigned int v828; // r0
  int v829; // t1
  int v830; // r1
  unsigned int v831; // r12
  ALima4 *v832; // r3
  int64x2_t *v833; // r2
  unsigned int v834; // r0
  int32x4_t *v835; // r5
  int16x4_t *v836; // r4
  int16x4_t v837; // d16
  ALsizei v838; // r4
  unsigned int v839; // r0
  int64x2_t *v840; // lr
  ALima4 *v841; // r6
  ALima4 *v842; // r0
  bool v843; // cf
  unsigned int v844; // r0
  int v845; // t1
  int64x2_t v846; // q8
  int v847; // r1
  unsigned int v848; // r12
  ALima4 *v849; // r3
  unsigned int *v850; // r2
  unsigned int v851; // r0
  int64x2_t *v852; // r5
  int64x2_t *v853; // r4
  int64x2_t v854; // q9
  ALsizei v855; // r4
  unsigned int v856; // r0
  int64x2_t *v857; // lr
  ALima4 *v858; // r6
  ALima4 *v859; // r0
  bool v860; // cf
  unsigned int v861; // r0
  int v862; // t1
  int v863; // r1
  unsigned int v864; // r12
  ALima4 *v865; // r3
  int64x2_t *v866; // r2
  unsigned int v867; // r0
  int64x2_t *v868; // r5
  ALima4 *v869; // r4
  unsigned __int64 v870; // d16
  unsigned __int64 v871; // d17
  ALsizei v872; // r4
  unsigned int v873; // r0
  int64x2_t *v874; // lr
  ALima4 *v875; // r6
  ALima4 *v876; // r0
  bool v877; // cf
  unsigned int v878; // r0
  unsigned __int32 v879; // t1
  int v880; // r0
  ALsizei v881; // r1
  ALsizei v882; // r12
  unsigned int *v883; // r2
  float *v884; // r3
  float v885; // s4
  unsigned int v886; // r6
  int v887; // r0
  ALsizei v888; // r1
  ALsizei v889; // r12
  unsigned int *v890; // r2
  double *v891; // r3
  double v892; // d19
  unsigned int v893; // r6
  int ii; // r0
  ALsizei v895; // r2
  unsigned int *v896; // r3
  ALima4 *v897; // r6
  int v898; // r5
  int v899; // r4
  int v900; // r0
  ALsizei v901; // r1
  ALsizei v902; // lr
  int64x2_t *v903; // r2
  ALima4 *v904; // r3
  int v905; // r6
  int v906; // r5
  int jj; // r0
  ALsizei v908; // r3
  unsigned int *v909; // r6
  ALima4 *v910; // r5
  int v911; // t1
  int kk; // r0
  ALsizei v913; // r3
  unsigned int *v914; // r6
  ALima4 *v915; // r5
  int v916; // t1
  unsigned int v917; // r4
  unsigned int v918; // r11
  unsigned int v919; // r10
  int64x2_t v920; // q4
  int64x2_t *v921; // r12
  ALshort *v922; // r6
  unsigned int v923; // r0
  unsigned int v924; // r3
  unsigned int *v925; // r2
  ALshort *v926; // r1
  bool v927; // cf
  unsigned int v928; // r3
  int16x4_t *v929; // r1
  int64x2_t *v930; // r4
  int16x4_t v931; // d16
  int v932; // r1
  int v933; // r0
  ALsizei v934; // r1
  ALsizei v935; // r12
  float *v936; // r2
  ALima4 *v937; // r3
  int v938; // t1
  int v939; // r0
  ALsizei v940; // r1
  ALsizei v941; // r12
  float *v942; // r2
  ALima4 *v943; // r3
  int v944; // t1
  int v945; // r0
  ALsizei v946; // r1
  ALsizei v947; // r12
  float *v948; // r2
  ALima4 *v949; // r3
  int v950; // t1
  int v951; // r0
  ALsizei v952; // r1
  ALsizei v953; // r12
  float *v954; // r2
  int *v955; // r3
  int v956; // t1
  float v957; // s0
  int v958; // r0
  ALsizei v959; // r1
  ALsizei v960; // r12
  float *v961; // r2
  ALima4 *v962; // r3
  int v963; // t1
  float v964; // s0
  int v965; // r1
  unsigned int v966; // r12
  ALima4 *v967; // r3
  int64x2_t *v968; // r2
  unsigned int v969; // r0
  int64x2_t *v970; // r5
  ALima4 *v971; // r4
  unsigned __int64 v972; // d16
  unsigned __int64 v973; // d17
  ALsizei v974; // r4
  unsigned int v975; // r0
  int64x2_t *v976; // lr
  ALima4 *v977; // r6
  ALima4 *v978; // r0
  bool v979; // cf
  unsigned int v980; // r0
  unsigned __int32 v981; // t1
  int v982; // r1
  unsigned int v983; // r12
  ALsizei v984; // r4
  float *v985; // r6
  unsigned int v986; // r0
  double *v987; // lr
  ALima4 *v988; // r0
  bool v989; // cf
  double *v990; // r3
  float *v991; // r2
  unsigned int v992; // r0
  int64x2_t *v993; // r5
  double *v994; // r4
  double v995; // d16
  double v996; // d17
  unsigned __int64 v997; // d0
  unsigned int v998; // r0
  double v999; // d16
  float v1000; // s0
  int v1001; // r0
  ALsizei v1002; // r1
  ALsizei v1003; // lr
  float *v1004; // r2
  ALima4 *v1005; // r3
  unsigned __int16 v1006; // r5
  float v1007; // s0
  int v1008; // r0
  ALsizei v1009; // r1
  ALsizei v1010; // lr
  float *v1011; // r2
  ALima4 *v1012; // r3
  int v1013; // r6
  int v1014; // r5
  float v1015; // s0
  int v1016; // r0
  ALsizei v1017; // r2
  ALsizei v1018; // lr
  float *v1019; // r3
  ALima4 *v1020; // r6
  int v1021; // t1
  int v1022; // r0
  ALsizei v1023; // r2
  ALsizei v1024; // lr
  float *v1025; // r3
  ALima4 *v1026; // r6
  int v1027; // t1
  unsigned int v1028; // r4
  float *v1029; // r12
  ALshort *v1030; // r1
  unsigned int v1031; // r0
  ALsizei v1032; // r2
  ALshort *v1033; // r3
  float *v1034; // r6
  int v1035; // t1
  int v1036; // r0
  ALsizei v1037; // r1
  ALsizei v1038; // r12
  double *v1039; // r2
  ALima4 *v1040; // r3
  int v1041; // t1
  int v1042; // r0
  ALsizei v1043; // r1
  ALsizei v1044; // r12
  double *v1045; // r2
  ALima4 *v1046; // r3
  int v1047; // t1
  int v1048; // r0
  ALsizei v1049; // r1
  ALsizei v1050; // r12
  double *v1051; // r2
  ALima4 *v1052; // r3
  int v1053; // t1
  int v1054; // r0
  ALsizei v1055; // r1
  ALsizei v1056; // r12
  double *v1057; // r2
  int *v1058; // r3
  int v1059; // t1
  int v1060; // r0
  ALsizei v1061; // r1
  ALsizei v1062; // r12
  double *v1063; // r2
  ALima4 *v1064; // r3
  int v1065; // t1
  int v1066; // r1
  unsigned int v1067; // r12
  ALsizei v1068; // r4
  double *v1069; // r6
  unsigned int v1070; // r0
  float *v1071; // lr
  ALima4 *v1072; // r0
  bool v1073; // cf
  float *v1074; // r3
  double *v1075; // r2
  unsigned int v1076; // r0
  double *v1077; // r5
  ALima4 *v1078; // r4
  __int64 v1079; // d0
  unsigned int v1080; // r0
  float v1081; // s0
  int v1082; // r1
  unsigned int v1083; // r12
  ALsizei v1084; // r4
  int64x2_t *v1085; // r6
  unsigned int v1086; // r0
  ALima4 *v1087; // lr
  ALima4 *v1088; // r0
  bool v1089; // cf
  ALima4 *v1090; // r3
  unsigned __int64 *v1091; // r2
  unsigned int v1092; // r0
  int64x2_t *v1093; // r5
  ALima4 *v1094; // r4
  unsigned __int64 v1095; // d16
  unsigned __int64 v1096; // d17
  unsigned int v1097; // r0
  unsigned __int64 v1098; // d16
  int v1099; // r0
  ALsizei v1100; // r1
  ALsizei v1101; // lr
  double *v1102; // r2
  ALima4 *v1103; // r3
  unsigned __int16 v1104; // r5
  int v1105; // r0
  ALsizei v1106; // r1
  ALsizei v1107; // lr
  double *v1108; // r2
  ALima4 *v1109; // r3
  int v1110; // r6
  int v1111; // r5
  int v1112; // r0
  ALsizei v1113; // r2
  ALsizei v1114; // lr
  double *v1115; // r3
  ALima4 *v1116; // r6
  int v1117; // t1
  int v1118; // r0
  ALsizei v1119; // r2
  ALsizei v1120; // lr
  double *v1121; // r3
  ALima4 *v1122; // r6
  int v1123; // t1
  unsigned int v1124; // r4
  double *v1125; // r12
  ALshort *v1126; // r1
  unsigned int v1127; // r0
  ALsizei v1128; // r2
  ALshort *v1129; // r3
  double *v1130; // r6
  int v1131; // t1
  int v1132; // r1
  ALsizei v1133; // r2
  ALsizei v1134; // lr
  int64x2_t *v1135; // r3
  ALima4 *v1136; // r6
  char v1137; // t1
  int v1138; // r0
  ALsizei v1139; // r1
  ALsizei v1140; // lr
  int64x2_t *v1141; // r2
  ALima4 *v1142; // r3
  __int16 v1143; // t1
  int mm; // r0
  ALsizei v1145; // r2
  int64x2_t *v1146; // r3
  ALima4 *v1147; // r6
  __int16 v1148; // t1
  int v1149; // r0
  ALsizei v1150; // r1
  ALsizei v1151; // lr
  int64x2_t *v1152; // r2
  ALima4 *v1153; // r3
  unsigned int v1154; // t1
  int nn; // r0
  ALsizei v1156; // r2
  int64x2_t *v1157; // r3
  ALima4 *v1158; // r6
  unsigned int v1159; // t1
  int i1; // r1
  ALsizei v1161; // r2
  int64x2_t *v1162; // r5
  float *v1163; // r3
  float v1164; // s4
  int64x2_t *v1165; // r6
  unsigned int v1166; // r0
  int i2; // r1
  ALsizei v1168; // r2
  int64x2_t *v1169; // r5
  double *v1170; // r3
  double v1171; // d19
  int64x2_t *v1172; // r6
  unsigned int v1173; // r0
  int i3; // r0
  ALsizei v1175; // r1
  int64x2_t *v1176; // r2
  ALima4 *v1177; // r3
  unsigned __int16 v1178; // r6
  unsigned __int8 v1179; // r5
  int v1180; // r0
  ALsizei v1181; // r1
  ALsizei v1182; // lr
  int64x2_t *v1183; // r2
  ALima4 *v1184; // r3
  ALima4 v1185; // r6
  unsigned __int16 v1186; // r5
  int i4; // r0
  ALsizei v1188; // r2
  int64x2_t *v1189; // r3
  ALima4 *v1190; // r6
  int v1191; // t1
  ALshort v1192; // r5
  int i5; // r0
  ALsizei v1194; // r2
  int64x2_t *v1195; // r3
  ALima4 *v1196; // r6
  int v1197; // t1
  ALshort v1198; // r5
  ALsizei v1199; // r3
  unsigned int v1200; // r11
  int64x2_t *v1201; // r12
  ALshort *v1202; // r1
  unsigned int v1203; // r0
  ALsizei v1204; // r2
  ALshort *v1205; // r3
  int64x2_t *v1206; // r6
  __int16 v1207; // t1
  int v1208; // r1
  ALsizei v1209; // r2
  ALsizei v1210; // lr
  int64x2_t *v1211; // r3
  ALima4 *v1212; // r6
  unsigned __int8 v1213; // t1
  int i6; // r0
  ALsizei v1215; // r2
  int64x2_t *v1216; // r3
  ALima4 *v1217; // r6
  __int16 v1218; // t1
  int v1219; // r0
  ALsizei v1220; // r1
  ALsizei v1221; // lr
  int64x2_t *v1222; // r2
  ALima4 *v1223; // r3
  __int16 v1224; // t1
  int i7; // r0
  ALsizei v1226; // r2
  int64x2_t *v1227; // r3
  ALima4 *v1228; // r6
  unsigned int v1229; // t1
  int v1230; // r0
  ALsizei v1231; // r1
  ALsizei v1232; // lr
  int64x2_t *v1233; // r2
  ALima4 *v1234; // r3
  unsigned int v1235; // t1
  int i8; // r0
  ALsizei v1237; // r2
  int64x2_t *v1238; // r5
  float *v1239; // r3
  float v1240; // s4
  int64x2_t *v1241; // r6
  unsigned int v1242; // r4
  int i9; // r0
  ALsizei v1244; // r2
  int64x2_t *v1245; // r5
  double *v1246; // r3
  double v1247; // d19
  int64x2_t *v1248; // r6
  unsigned int v1249; // r4
  int v1250; // r0
  ALsizei v1251; // r1
  ALsizei v1252; // lr
  int64x2_t *v1253; // r2
  ALima4 *v1254; // r3
  ALima4 v1255; // r6
  unsigned __int16 v1256; // r5
  int v1257; // r0
  ALsizei v1258; // r1
  ALsizei v1259; // lr
  int64x2_t *v1260; // r2
  ALima4 *v1261; // r3
  unsigned __int16 v1262; // r6
  unsigned __int8 v1263; // r5
  int i10; // r12
  int64x2_t *v1265; // r6
  ALsizei v1266; // r3
  ALima4 *v1267; // r5
  int v1268; // t1
  ALshort v1269; // r4
  int i11; // r12
  int64x2_t *v1271; // r6
  ALsizei v1272; // r3
  ALima4 *v1273; // r5
  int v1274; // t1
  ALshort v1275; // r4
  ALsizei v1276; // r3
  ALsizei v1277; // r2
  unsigned int v1278; // r11
  unsigned int v1279; // r5
  int64x2_t *v1280; // lr
  ALshort *v1281; // r12
  unsigned int v1282; // r0
  ALshort *v1283; // r3
  int64x2_t *v1284; // r5
  __int16 v1285; // t1
  int i13; // r12
  ALsizei v1287; // r4
  int64x2_t *v1288; // r0
  ALima4 *v1289; // r1
  __int16 v1290; // t1
  int v1291; // r3
  int v1292; // r5
  unsigned int v1293; // r2
  int v1294; // r3
  int v1295; // r5
  int i14; // r12
  ALsizei v1297; // r5
  ALima4 *v1298; // r0
  int64x2_t *v1299; // r4
  int v1300; // r2
  unsigned int v1301; // t1
  int v1302; // r1
  int v1303; // r2
  int v1304; // r6
  int i15; // r12
  ALsizei v1306; // r5
  ALima4 *v1307; // r0
  int64x2_t *v1308; // r4
  __int16 v1309; // t1
  int v1310; // r2
  int v1311; // r6
  int v1312; // r1
  int v1313; // r2
  int v1314; // r6
  int i16; // r12
  ALsizei v1316; // r5
  int *v1317; // r0
  int64x2_t *v1318; // r4
  unsigned int v1319; // r6
  int v1320; // t1
  int v1321; // r2
  unsigned int v1322; // r1
  int v1323; // r2
  int v1324; // r2
  int v1325; // r6
  int i17; // r12
  ALsizei v1327; // r5
  ALima4 *v1328; // r0
  int64x2_t *v1329; // r4
  __int16 v1330; // r1
  int v1331; // r2
  int v1332; // r6
  int v1333; // r1
  int v1334; // r2
  int v1335; // r6
  int i18; // r12
  ALsizei v1337; // r5
  float *v1338; // r0
  int64x2_t *v1339; // r4
  float v1340; // s6
  int v1341; // r2
  int v1342; // r6
  unsigned int v1343; // r1
  int v1344; // r2
  int v1345; // r6
  int i19; // r12
  ALsizei v1347; // r5
  double *v1348; // r0
  int64x2_t *v1349; // r4
  double v1350; // d19
  int v1351; // r2
  int v1352; // r6
  unsigned int v1353; // r1
  int v1354; // r2
  int v1355; // r6
  int i20; // r12
  ALsizei v1357; // r5
  ALima4 *v1358; // r0
  int64x2_t *v1359; // r4
  int v1360; // r1
  int v1361; // r2
  int v1362; // r6
  int v1363; // r2
  unsigned int v1364; // r1
  int v1365; // r2
  int v1366; // r2
  int v1367; // r6
  int i21; // r12
  ALsizei v1369; // r4
  int64x2_t *v1370; // r0
  ALima4 *v1371; // r1
  int v1372; // r2
  int v1373; // r3
  unsigned int v1374; // r3
  int v1375; // r5
  unsigned int v1376; // r2
  int v1377; // r3
  int v1378; // r5
  int v1379; // r1
  unsigned int v1380; // r12
  ALima4 *v1381; // r3
  int64x2_t *v1382; // r2
  unsigned int v1383; // r0
  int64x2_t *v1384; // r5
  ALima4 *v1385; // r4
  unsigned __int64 v1386; // d16
  unsigned __int64 v1387; // d17
  ALsizei v1388; // r4
  unsigned int v1389; // r0
  int64x2_t *v1390; // lr
  ALima4 *v1391; // r6
  bool v1392; // cf
  unsigned int v1393; // r0
  unsigned __int8 v1394; // t1
  int i22; // r12
  ALsizei v1396; // r4
  int64x2_t *v1397; // r0
  ALima4 *v1398; // r1
  int v1399; // t1
  int v1400; // r3
  int v1401; // r2
  int v1402; // r3
  int v1403; // r5
  ALsizei v1404; // r3
  unsigned int v1405; // r1
  unsigned int v1406; // r6
  unsigned int v1407; // r11
  ALshort *v1408; // r12
  unsigned int v1409; // lr
  ALsizei v1410; // r2
  int64x2_t *v1411; // r5
  ALshort *v1412; // r3
  int v1413; // r0
  int v1414; // r1
  int v1415; // r0
  int v1416; // r6
  int i24; // lr
  int64x2_t *v1418; // r4
  ALima4 *v1419; // r6
  ALsizei v1420; // r5
  __int16 v1421; // t1
  int v1422; // r1
  int v1423; // r2
  unsigned int v1424; // r0
  int v1425; // r2
  char v1426; // r0
  unsigned __int8 v1427; // r3
  char v1428; // r1
  int i25; // lr
  int64x2_t *v1430; // r5
  ALsizei v1431; // r6
  ALima4 *v1432; // r4
  int v1433; // r1
  unsigned int v1434; // t1
  int v1435; // r0
  char v1436; // r3
  unsigned __int8 v1437; // r2
  char v1438; // r0
  int v1439; // r1
  int i26; // lr
  int64x2_t *v1441; // r5
  ALsizei v1442; // r6
  ALima4 *v1443; // r4
  __int16 v1444; // t1
  int v1445; // r1
  int v1446; // r3
  int v1447; // r0
  char v1448; // r3
  unsigned __int8 v1449; // r2
  char v1450; // r0
  int v1451; // r1
  int i27; // lr
  int64x2_t *v1453; // r5
  ALsizei v1454; // r6
  int *v1455; // r4
  unsigned int v1456; // r3
  int v1457; // t1
  int v1458; // r1
  unsigned int v1459; // r0
  int v1460; // r1
  char v1461; // r3
  unsigned __int8 v1462; // r2
  char v1463; // r0
  int v1464; // r1
  int i28; // lr
  int64x2_t *v1466; // r5
  ALsizei v1467; // r6
  ALima4 *v1468; // r4
  int v1469; // r1
  int v1470; // r3
  unsigned int v1471; // r0
  char v1472; // r3
  unsigned __int8 v1473; // r2
  char v1474; // r0
  int v1475; // r1
  int i29; // lr
  int64x2_t *v1477; // r5
  ALsizei v1478; // r6
  float *v1479; // r4
  float v1480; // s6
  int v1481; // r0
  int v1482; // r3
  unsigned int v1483; // r1
  char v1484; // r3
  int v1485; // r1
  unsigned __int8 v1486; // r2
  char v1487; // r0
  int v1488; // r1
  int i30; // lr
  int64x2_t *v1490; // r5
  ALsizei v1491; // r6
  double *v1492; // r4
  double v1493; // d19
  int v1494; // r0
  int v1495; // r3
  unsigned int v1496; // r1
  char v1497; // r3
  int v1498; // r1
  unsigned __int8 v1499; // r2
  char v1500; // r0
  int v1501; // r1
  int i31; // lr
  int64x2_t *v1503; // r5
  ALsizei v1504; // r6
  ALima4 *v1505; // r4
  int v1506; // r3
  int v1507; // r1
  unsigned int v1508; // r0
  int v1509; // r1
  char v1510; // r3
  unsigned __int8 v1511; // r2
  char v1512; // r0
  int v1513; // r1
  int i32; // lr
  int64x2_t *v1515; // r4
  ALima4 *v1516; // r6
  ALsizei v1517; // r5
  unsigned int v1518; // r1
  int v1519; // r2
  unsigned int v1520; // r0
  int v1521; // r2
  char v1522; // r0
  unsigned __int8 v1523; // r3
  char v1524; // r1
  int i33; // lr
  int64x2_t *v1526; // r4
  ALima4 *v1527; // r6
  ALsizei v1528; // r5
  int v1529; // t1
  int v1530; // r1
  int v1531; // r0
  int v1532; // r2
  char v1533; // r0
  unsigned __int8 v1534; // r3
  char v1535; // r1
  int v1536; // r1
  unsigned int v1537; // r12
  ALima4 *v1538; // r3
  int64x2_t *v1539; // r2
  unsigned int v1540; // r0
  int64x2_t *v1541; // r5
  ALima4 *v1542; // r4
  unsigned __int64 v1543; // d16
  unsigned __int64 v1544; // d17
  ALsizei v1545; // r4
  unsigned int v1546; // r0
  int64x2_t *v1547; // lr
  ALima4 *v1548; // r6
  bool v1549; // cf
  unsigned int v1550; // r0
  unsigned __int8 v1551; // t1
  ALsizei v1552; // r3
  ALsizei v1553; // r1
  unsigned int v1554; // r10
  unsigned int v1555; // r5
  ALshort *v1556; // r12
  unsigned int v1557; // lr
  int64x2_t *v1558; // r6
  ALsizei v1559; // r2
  ALshort *v1560; // r3
  int v1561; // r1
  int v1562; // r5
  char v1563; // r4
  unsigned __int8 v1564; // r0
  char v1565; // r5
  int v1566; // r1
  ALima4 *v1567; // r6
  int32x4_t v1568; // q4
  unsigned int v1569; // r9
  unsigned int v1570; // r5
  unsigned int v1571; // r4
  unsigned int v1572; // r1
  ALima4 *v1573; // r0
  uint8x8_t *v1574; // r3
  int16x4_t *v1575; // r1
  unsigned int v1576; // r2
  uint8x8_t v1577; // d16
  uint16x8_t v1578; // q8
  ALshort *v1579; // r2
  unsigned int v1580; // r1
  __int16 v1581; // t1
  ALima4 *v1582; // r4
  unsigned int v1583; // r8
  unsigned int v1584; // r5
  unsigned int v1585; // r6
  unsigned int v1586; // r1
  ALima4 *v1587; // r0
  ALima4 *v1588; // r3
  ALima4 *v1589; // r0
  bool v1590; // cf
  ALshort *v1591; // r1
  unsigned int v1592; // r2
  __int64 v1593; // d16
  __int64 v1594; // d17
  ALshort *v1595; // r2
  unsigned int v1596; // r1
  ALshort v1597; // t1
  ALima4 *v1598; // r4
  unsigned int v1599; // r8
  unsigned int v1600; // r5
  unsigned int v1601; // r6
  unsigned int v1602; // r1
  ALima4 *v1603; // r0
  ALima4 *v1604; // r3
  ALima4 *v1605; // r0
  bool v1606; // cf
  ALshort *v1607; // r1
  unsigned int v1608; // r2
  __int64 v1609; // d16
  __int64 v1610; // d17
  ALshort *v1611; // r2
  unsigned int v1612; // r1
  __int16 v1613; // t1
  ALima4 *v1614; // r4
  unsigned int v1615; // r8
  unsigned int v1616; // r5
  unsigned int v1617; // r6
  unsigned int v1618; // r1
  ALima4 *v1619; // r0
  int32x4_t *v1620; // r3
  ALima4 *v1621; // r0
  bool v1622; // cf
  int16x4_t *v1623; // r1
  unsigned int v1624; // r2
  int32x4_t v1625; // q8
  ALshort *v1626; // r2
  unsigned int v1627; // r1
  ALima4 *v1628; // r4
  unsigned int v1629; // r6
  unsigned int v1630; // r5
  unsigned int v1631; // r9
  unsigned int v1632; // r1
  ALima4 *v1633; // r0
  uint32x4_t *v1634; // r3
  ALima4 *v1635; // r0
  bool v1636; // cf
  int16x4_t *v1637; // r1
  unsigned int v1638; // r2
  uint32x4_t v1639; // q8
  uint32x4_t v1640; // q9
  ALshort *v1641; // r2
  unsigned int v1642; // r1
  __int16 v1643; // r3
  ALima4 *v1644; // r6
  unsigned int i34; // r4
  float *v1646; // r2
  ALshort *v1647; // r0
  int v1648; // r1
  float v1649; // s0
  int v1650; // r3
  ALima4 *v1651; // r6
  unsigned int i35; // r4
  double *v1653; // r2
  ALshort *v1654; // r0
  int v1655; // r1
  double v1656; // d16
  int v1657; // r3
  unsigned int i36; // r4
  ALima4 *v1659; // r2
  ALshort *v1660; // r5
  int v1661; // r1
  int v1662; // r3
  int v1663; // r6
  char *v1664; // r5
  unsigned int i37; // r10
  ALima4 *v1666; // r2
  ALshort *v1667; // r4
  int v1668; // r1
  int v1669; // r3
  int v1670; // r5
  char *v1671; // r4
  ALima4 *v1672; // r5
  unsigned int v1673; // r4
  int v1674; // r9
  ALima4 *v1675; // r2
  ALshort *v1676; // r0
  int v1677; // r1
  int v1678; // t1
  ALima4 *v1679; // r5
  unsigned int v1680; // r4
  int v1681; // r9
  ALima4 *v1682; // r2
  ALshort *v1683; // r0
  int v1684; // r1
  int v1685; // t1
  unsigned int v1686; // [sp+10h] [bp-540h]
  ALima4 *v1687; // [sp+18h] [bp-538h]
  int64x2_t *v1688; // [sp+1Ch] [bp-534h]
  ALshort v1689[585]; // [sp+36h] [bp-51Ah] BYREF
  __int64 index; // [sp+4C8h] [bp-88h] BYREF
  __int64 v1691; // [sp+4D0h] [bp-80h]
  __int64 v1692; // [sp+4D8h] [bp-78h]
  __int64 v1693; // [sp+4E0h] [bp-70h]
  int v1694; // [sp+4E8h] [bp-68h]
  __int64 sample; // [sp+4F0h] [bp-60h] BYREF
  __int64 v1696; // [sp+4F8h] [bp-58h]
  __int64 v1697; // [sp+500h] [bp-50h]
  __int64 v1698; // [sp+508h] [bp-48h]
  int v1699; // [sp+510h] [bp-40h]

  v1687 = (ALima4 *)src;
  v1688 = (int64x2_t *)dst;
  switch ( dstType )
  {
    case UserFmtByte:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( !len )
            return;
          v8 = 0;
          v9 = numchans & 0xFFFFFFF0;
          while ( 1 )
          {
            v132 = numchans;
            if ( numchans )
              break;
LABEL_189:
            if ( ++v8 == len )
              return;
          }
          v133 = 0;
          if ( (unsigned int)numchans < 0x10 )
          {
            v134 = v1688;
            v135 = v1687;
          }
          else
          {
            v134 = v1688;
            v135 = v1687;
            v126 = v1688;
            v125 = v1687;
            if ( !v9 )
              goto LABEL_186;
            v136 = v1688 >= (int64x2_t *)&v1687[numchans];
            if ( v1688 < (int64x2_t *)&v1687[numchans] )
              v136 = v1687 >= (ALima4 *)v1688 + numchans;
            if ( v136 )
            {
              v125 = &v1687[v9];
              v126 = (int64x2_t *)((char *)v1688 + v9);
              v127 = numchans & 0xFFFFFFF0;
              v128 = v1688;
              v129 = v1687;
              do
              {
                v130 = *(_QWORD *)v129;
                v131 = *((_QWORD *)v129 + 1);
                v129 += 16;
                v127 -= 16;
                v128->n128_u64[0] = v130;
                v128->n128_u64[1] = v131;
                ++v128;
              }
              while ( v127 );
              v132 = numchans;
              v133 = numchans & 0xFFFFFFF0;
              if ( v9 == numchans )
                goto LABEL_188;
              goto LABEL_186;
            }
            v133 = 0;
          }
          v126 = v134;
          v125 = v135;
LABEL_186:
          v137 = v132 - v133;
          do
          {
            v138 = *v125++;
            --v137;
            v126->n128_u8[0] = v138;
            v126 = (int64x2_t *)((char *)v126 + 1);
          }
          while ( v137 );
LABEL_188:
          v1688 = (int64x2_t *)((char *)v134 + v132);
          v1687 = &v135[v132];
          goto LABEL_189;
        case UserFmtUByte:
          if ( !len )
            return;
          v152.n128_u64[0] = 0x8080808080808080LL;
          v152.n128_u64[1] = 0x8080808080808080LL;
          v153 = 0;
          v154 = numchans & 0xFFFFFFF0;
          while ( 1 )
          {
            v161 = numchans;
            if ( numchans )
              break;
LABEL_227:
            if ( ++v153 == len )
              return;
          }
          v162 = 0;
          if ( (unsigned int)numchans < 0x10 )
          {
            v163 = v1688;
            v164 = v1687;
          }
          else
          {
            v163 = v1688;
            v164 = v1687;
            v156 = v1688;
            v155 = v1687;
            if ( !v154 )
              goto LABEL_224;
            v165 = v1688 >= (int64x2_t *)&v1687[numchans];
            if ( v1688 < (int64x2_t *)&v1687[numchans] )
              v165 = v1687 >= (ALima4 *)v1688 + numchans;
            if ( v165 )
            {
              v155 = &v1687[v154];
              v156 = (int64x2_t *)((char *)v1688 + v154);
              v157 = numchans & 0xFFFFFFF0;
              v158 = v1688;
              v159 = (int64x2_t *)v1687;
              do
              {
                v160 = *v159++;
                v157 -= 16;
                *v158++ = vorrq_s64(v160, v152);
              }
              while ( v157 );
              v161 = numchans;
              v162 = numchans & 0xFFFFFFF0;
              if ( v154 == numchans )
                goto LABEL_226;
              goto LABEL_224;
            }
            v162 = 0;
          }
          v156 = v163;
          v155 = v164;
LABEL_224:
          v166 = v161 - v162;
          do
          {
            v167 = *v155++;
            --v166;
            v156->n128_u8[0] = v167 + 0x80;
            v156 = (int64x2_t *)((char *)v156 + 1);
          }
          while ( v166 );
LABEL_226:
          v1688 = (int64x2_t *)((char *)v163 + v161);
          v1687 = &v164[v161];
          goto LABEL_227;
        case UserFmtShort:
          if ( !len )
            return;
          v168 = 0;
          v169 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v176 = numchans;
            if ( numchans )
              break;
LABEL_246:
            if ( ++v168 == len )
              return;
          }
          v177 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v178 = v1688;
            v179 = v1687;
          }
          else
          {
            v178 = v1688;
            v179 = v1687;
            v171 = v1688;
            v170 = v1687;
            if ( !v169 )
              goto LABEL_243;
            if ( v1688 >= (int64x2_t *)&v1687[2 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
            {
              v170 = &v1687[2 * v169];
              v171 = (int64x2_t *)((char *)v1688 + v169);
              v172 = numchans & 0xFFFFFFF8;
              v173 = (int8x8_t *)v1688;
              v174 = (int16x8_t *)v1687;
              do
              {
                v175 = *v174++;
                v172 -= 8;
                v173->n64_u64[0] = vshrn_n_s16(v175, 8u).n64_u64[0];
                ++v173;
              }
              while ( v172 );
              v176 = numchans;
              v177 = numchans & 0xFFFFFFF8;
              if ( v169 == numchans )
                goto LABEL_245;
              goto LABEL_243;
            }
            v177 = 0;
          }
          v171 = v178;
          v170 = v179;
LABEL_243:
          v180 = v176 - v177;
          do
          {
            --v180;
            v171->n128_u8[0] = v170[1];
            v171 = (int64x2_t *)((char *)v171 + 1);
            v170 += 2;
          }
          while ( v180 );
LABEL_245:
          v1688 = (int64x2_t *)((char *)v178 + v176);
          v1687 = &v179[2 * v176];
          goto LABEL_246;
        case UserFmtUShort:
          if ( !len )
            return;
          v181 = 0;
          v182 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v183 = numchans;
            if ( numchans )
              break;
LABEL_263:
            if ( ++v181 == len )
              return;
          }
          v184 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v186 = v1687;
            v185 = v1688;
            v187 = v1687;
          }
          else
          {
            v186 = v1687;
            v185 = v1688;
            v187 = v1687;
            if ( v182 )
            {
              v188 = (int8x8_t *)v1688;
              if ( v1688 >= (int64x2_t *)&v1687[2 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
              {
                v187 = &v1687[2 * v182];
                v185 = (int64x2_t *)((char *)v1688 + v182);
                v189 = numchans & 0xFFFFFFF8;
                v190 = (uint16x8_t *)v1687;
                do
                {
                  v191 = *v190++;
                  v192.n128_u64[0] = 0x80008000800080LL;
                  v192.n128_u64[1] = 0x80008000800080LL;
                  v189 -= 8;
                  v188->n64_u64[0] = vmovn_s16(vsraq_n_u16(v192, v191, 8u)).n64_u64[0];
                  ++v188;
                }
                while ( v189 );
                v183 = numchans;
                v184 = numchans & 0xFFFFFFF8;
                if ( v182 == numchans )
                  goto LABEL_262;
              }
              else
              {
                v185 = v1688;
                v184 = 0;
                v187 = v1687;
                v183 = numchans;
              }
            }
          }
          v193 = v183 - v184;
          do
          {
            v194 = *(_WORD *)v187;
            v187 += 2;
            --v193;
            v185->n128_u8[0] = HIBYTE(v194) + 0x80;
            v185 = (int64x2_t *)((char *)v185 + 1);
          }
          while ( v193 );
LABEL_262:
          v1688 = (int64x2_t *)((char *)v1688 + v183);
          v1687 = &v186[2 * v183];
          goto LABEL_263;
        case UserFmtInt:
          if ( !len )
            return;
          v195 = 0;
          v196 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v204 = numchans;
            if ( numchans )
              break;
LABEL_282:
            if ( ++v195 == len )
              return;
          }
          v205 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v206 = v1688;
            v207 = v1687;
          }
          else
          {
            v206 = v1688;
            v207 = v1687;
            v198 = v1688;
            v197 = v1687;
            if ( !v196 )
              goto LABEL_279;
            if ( v1688 >= (int64x2_t *)&v1687[4 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
            {
              v197 = &v1687[4 * v196];
              v198 = (int64x2_t *)((char *)v1688 + v196);
              v199 = numchans & 0xFFFFFFFC;
              v200 = v1688;
              v201 = (uint32x4_t *)v1687;
              do
              {
                v202 = *v201++;
                v199 -= 4;
                v203 = vshrq_n_u32(v202, 0x18u);
                v200->n128_u32[0] = (unsigned int)vuzp_s8(vmovn_s32(v203), *(int8x8_t *)&v203.n128_i8[8]);
                v200 = (int64x2_t *)((char *)v200 + 8);
              }
              while ( v199 );
              v204 = numchans;
              v205 = numchans & 0xFFFFFFFC;
              if ( v196 == numchans )
                goto LABEL_281;
              goto LABEL_279;
            }
            v205 = 0;
          }
          v198 = v206;
          v197 = v207;
LABEL_279:
          v208 = v204 - v205;
          do
          {
            --v208;
            v198->n128_u8[0] = v197[3];
            v198 = (int64x2_t *)((char *)v198 + 1);
            v197 += 4;
          }
          while ( v208 );
LABEL_281:
          v1688 = (int64x2_t *)((char *)v206 + v204);
          v1687 = &v207[4 * v204];
          goto LABEL_282;
        case UserFmtUInt:
          if ( !len )
            return;
          v209 = 0;
          v210 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v218 = numchans;
            if ( numchans )
              break;
LABEL_301:
            if ( ++v209 == len )
              return;
          }
          v219 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v220 = v1688;
            v221 = v1687;
          }
          else
          {
            v220 = v1688;
            v221 = v1687;
            v212 = v1688;
            v211 = v1687;
            if ( !v210 )
              goto LABEL_298;
            if ( v1688 >= (int64x2_t *)&v1687[4 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
            {
              v211 = &v1687[4 * v210];
              v212 = (int64x2_t *)((char *)v1688 + v210);
              v213 = numchans & 0xFFFFFFFC;
              v214 = v1688;
              v215 = (uint32x4_t *)v1687;
              do
              {
                v216 = *v215++;
                v217.n128_u64[0] = 0x8000000080LL;
                v217.n128_u64[1] = 0x8000000080LL;
                v213 -= 4;
                v214->n128_u32[0] = (unsigned int)vuzp_s8(
                                                    vmovn_s32(vsraq_n_u32(v217, v216, 0x18u)),
                                                    *(int8x8_t *)&v216.n128_i8[8]);
                v214 = (int64x2_t *)((char *)v214 + 8);
              }
              while ( v213 );
              v218 = numchans;
              v219 = numchans & 0xFFFFFFFC;
              if ( v210 == numchans )
                goto LABEL_300;
              goto LABEL_298;
            }
            v219 = 0;
          }
          v212 = v220;
          v211 = v221;
LABEL_298:
          v222 = v218 - v219;
          do
          {
            v223 = v211[3];
            --v222;
            v211 += 4;
            v212->n128_u8[0] = v223 + 0x80;
            v212 = (int64x2_t *)((char *)v212 + 1);
          }
          while ( v222 );
LABEL_300:
          v1688 = (int64x2_t *)((char *)v220 + v218);
          v1687 = &v221[4 * v218];
          goto LABEL_301;
        case UserFmtFloat:
          if ( len )
          {
            v224 = 0;
            do
            {
              v225 = numchans;
              if ( numchans )
              {
                v226 = len;
                v227 = v1688;
                v228 = (float *)v1687;
                do
                {
                  v229 = *v228++;
                  if ( v229 <= 1.0 )
                  {
                    if ( v229 >= -1.0 )
                      v230 = (int)(float)(v229 * 127.0);
                    else
                      LOBYTE(v230) = 0x80;
                  }
                  else
                  {
                    LOBYTE(v230) = 127;
                  }
                  v227->n128_u8[0] = v230;
                  v227 = (int64x2_t *)((char *)v227 + 1);
                  --v225;
                }
                while ( v225 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v226 = len;
              }
              ++v224;
            }
            while ( v224 != v226 );
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            v231 = 0;
            do
            {
              v232 = numchans;
              if ( numchans )
              {
                v233 = len;
                v234 = v1688;
                v235 = (double *)v1687;
                do
                {
                  v236 = *v235++;
                  if ( v236 <= 1.0 )
                  {
                    if ( v236 >= -1.0 )
                      v237 = (int)(v236 * 127.0);
                    else
                      LOBYTE(v237) = 0x80;
                  }
                  else
                  {
                    LOBYTE(v237) = 127;
                  }
                  v234->n128_u8[0] = v237;
                  v234 = (int64x2_t *)((char *)v234 + 1);
                  --v232;
                }
                while ( v232 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 8 * numchans;
              }
              else
              {
                v233 = len;
              }
              ++v231;
            }
            while ( v231 != v233 );
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            v238 = 0;
            do
            {
              v239 = numchans;
              if ( numchans )
              {
                v240 = len;
                v241 = v1688;
                v242 = v1687;
                do
                {
                  --v239;
                  v241->n128_u8[0] = v242[2];
                  v241 = (int64x2_t *)((char *)v241 + 1);
                  v242 += 3;
                }
                while ( v239 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v240 = len;
              }
              ++v238;
            }
            while ( v238 != v240 );
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            v243 = 0;
            do
            {
              v244 = numchans;
              if ( numchans )
              {
                v245 = len;
                v246 = v1688;
                v247 = v1687;
                do
                {
                  v248 = v247[2];
                  --v244;
                  v247 += 3;
                  v246->n128_u8[0] = v248 + 0x80;
                  v246 = (int64x2_t *)((char *)v246 + 1);
                }
                while ( v244 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v245 = len;
              }
              ++v243;
            }
            while ( v243 != v245 );
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            v249 = 0;
            do
            {
              v250 = numchans;
              if ( numchans )
              {
                v251 = len;
                v252 = v1688;
                v253 = v1687;
                do
                {
                  v254 = *v253++;
                  --v250;
                  v252->n128_u8[0] = HIBYTE(muLawDecompressionTable[v254]);
                  v252 = (int64x2_t *)((char *)v252 + 1);
                }
                while ( v250 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
              else
              {
                v251 = len;
              }
              ++v249;
            }
            while ( v249 != v251 );
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            v255 = 0;
            do
            {
              v256 = numchans;
              if ( numchans )
              {
                v257 = len;
                v258 = v1688;
                v259 = v1687;
                do
                {
                  v260 = *v259++;
                  --v256;
                  v258->n128_u8[0] = HIBYTE(aLawDecompressionTable[v260]);
                  v258 = (int64x2_t *)((char *)v258 + 1);
                }
                while ( v256 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
              else
              {
                v257 = len;
              }
              ++v255;
            }
            while ( v255 != v257 );
          }
          return;
        case UserFmtIMA4:
          v261 = numchans;
          if ( !len )
            return;
          v262 = numchans & 0xFFFFFFF8;
          v263 = 0;
          while ( 1 )
          {
            DecodeIMA4Block(v1689, v1687, v261);
            v1687 += 36 * numchans;
            if ( v263 < len )
              break;
            v264 = (int8x8_t *)v1688;
            v261 = numchans;
LABEL_387:
            v1688 = (int64x2_t *)v264;
            if ( v263 >= len )
              return;
          }
          v264 = (int8x8_t *)v1688;
          v261 = numchans;
          v265 = v1689;
          v266 = 0;
          break;
        default:
          return;
      }
      while ( 1 )
      {
        if ( !v261 )
          goto LABEL_383;
        v267 = 0;
        if ( v261 < 8 )
        {
          v268 = v264;
        }
        else
        {
          v268 = v264;
          if ( v262 )
          {
            if ( v264 >= (int8x8_t *)&v1689[v261 + v266 * v261] || (char *)v264 + v261 <= (char *)&v1689[v266 * v261] )
            {
              v268 = (int8x8_t *)((char *)v264 + v262);
              v269 = numchans & 0xFFFFFFF8;
              v270 = (int16x8_t *)v265;
              v271 = v264;
              do
              {
                v272 = *v270++;
                v269 -= 8;
                v271->n64_u64[0] = vshrn_n_s16(v272, 8u).n64_u64[0];
                ++v271;
              }
              while ( v269 );
              v261 = numchans;
              v267 = numchans & 0xFFFFFFF8;
              if ( v262 == numchans )
                goto LABEL_382;
            }
            else
            {
              v267 = 0;
              v268 = v264;
            }
          }
        }
        do
        {
          v273 = &v265[v267++];
          v268->n64_u8[0] = *((_BYTE *)v273 + 1);
          v268 = (int8x8_t *)((char *)v268 + 1);
        }
        while ( v261 != v267 );
LABEL_382:
        v264 = (int8x8_t *)((char *)v264 + v261);
LABEL_383:
        ++v266;
        ++v263;
        if ( v266 <= 0x40 )
        {
          v265 += numchans;
          if ( v263 < len )
            continue;
        }
        goto LABEL_387;
      }
    case UserFmtUByte:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( !len )
            return;
          v10.n128_u64[0] = 0x8080808080808080LL;
          v10.n128_u64[1] = 0x8080808080808080LL;
          v11 = 0;
          v12 = numchans & 0xFFFFFFF0;
          while ( 1 )
          {
            v145 = numchans;
            if ( numchans )
              break;
LABEL_207:
            if ( ++v11 == len )
              return;
          }
          v146 = 0;
          if ( (unsigned int)numchans < 0x10 )
          {
            v147 = v1688;
            v148 = v1687;
          }
          else
          {
            v147 = v1688;
            v148 = v1687;
            v140 = v1688;
            v139 = v1687;
            if ( !v12 )
              goto LABEL_204;
            v149 = v1688 >= (int64x2_t *)&v1687[numchans];
            if ( v1688 < (int64x2_t *)&v1687[numchans] )
              v149 = v1687 >= (ALima4 *)v1688 + numchans;
            if ( v149 )
            {
              v139 = &v1687[v12];
              v140 = (int64x2_t *)((char *)v1688 + v12);
              v141 = numchans & 0xFFFFFFF0;
              v142 = v1688;
              v143 = (int64x2_t *)v1687;
              do
              {
                v144 = *v143++;
                v141 -= 16;
                *v142++ = vorrq_s64(v144, v10);
              }
              while ( v141 );
              v145 = numchans;
              v146 = numchans & 0xFFFFFFF0;
              if ( v12 == numchans )
                goto LABEL_206;
              goto LABEL_204;
            }
            v146 = 0;
          }
          v140 = v147;
          v139 = v148;
LABEL_204:
          v150 = v145 - v146;
          do
          {
            v151 = *v139++;
            --v150;
            v140->n128_u8[0] = v151 + 0x80;
            v140 = (int64x2_t *)((char *)v140 + 1);
          }
          while ( v150 );
LABEL_206:
          v1688 = (int64x2_t *)((char *)v147 + v145);
          v1687 = &v148[v145];
          goto LABEL_207;
        case UserFmtUByte:
          if ( !len )
            return;
          v274 = 0;
          v275 = numchans & 0xFFFFFFF0;
          while ( 1 )
          {
            v283 = numchans;
            if ( numchans )
              break;
LABEL_407:
            if ( ++v274 == len )
              return;
          }
          v284 = 0;
          if ( (unsigned int)numchans < 0x10 )
          {
            v285 = v1688;
            v286 = v1687;
          }
          else
          {
            v285 = v1688;
            v286 = v1687;
            v277 = v1688;
            v276 = v1687;
            if ( !v275 )
              goto LABEL_404;
            v287 = v1688 >= (int64x2_t *)&v1687[numchans];
            if ( v1688 < (int64x2_t *)&v1687[numchans] )
              v287 = v1687 >= (ALima4 *)v1688 + numchans;
            if ( v287 )
            {
              v276 = &v1687[v275];
              v277 = (int64x2_t *)((char *)v1688 + v275);
              v278 = numchans & 0xFFFFFFF0;
              v279 = v1688;
              v280 = v1687;
              do
              {
                v281 = *(_QWORD *)v280;
                v282 = *((_QWORD *)v280 + 1);
                v280 += 16;
                v278 -= 16;
                v279->n128_u64[0] = v281;
                v279->n128_u64[1] = v282;
                ++v279;
              }
              while ( v278 );
              v283 = numchans;
              v284 = numchans & 0xFFFFFFF0;
              if ( v275 == numchans )
              