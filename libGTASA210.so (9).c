F8B4) --------------------------------------------------------
void CStreaming::Shutdown()
{
  void *v0; // r0

  CMemoryMgr::FreeAlign(CStreaming::ms_pStreamingBuffer[0]);
  CStreaming::ms_streamingBufferSize = 0;
  if ( CStreaming::ms_pExtraObjectsDir )
  {
    CDirectory::~CDirectory(CStreaming::ms_pExtraObjectsDir);
    sub_191374(v0);
  }
}
// 2CF8E4: variable 'v0' is possibly undefined

//----- (002CF8F4) --------------------------------------------------------
void CStreaming::ReInit()
{
  int m_nextIndex; // r0
  CStreamingInfo *v1; // r0
  int v2; // r1
  CStreamingInfo *v3; // r5
  int32 v4; // r2
  uint8 m_flags; // r2
  int32 i; // r4
  CStreamingInfo *v7; // r0
  CStreamingInfo *v8; // r3
  CStreamingInfo *v9; // r2
  unsigned int v10; // r12
  int j; // r4
  CBaseModelInfo *v12; // r6
  CBaseModelInfo *v13; // r6
  CBaseModelInfo *v14; // r6
  CBaseModelInfo *v15; // r6
  CBaseModelInfo *v16; // r6
  CBaseModelInfo *v17; // r6
  CBaseModelInfo *v18; // r6
  CBaseModelInfo *v19; // r6
  CBaseModelInfo *v20; // r6
  CBaseModelInfo *v21; // r6
  CBaseModelInfo *v22; // r6
  CBaseModelInfo *v23; // r6
  CBaseModelInfo *v24; // r6
  CBaseModelInfo *v25; // r6
  CBaseModelInfo *v26; // r6
  CBaseModelInfo *v27; // r6
  CBaseModelInfo *v28; // r6
  CBaseModelInfo *v29; // r6
  CBaseModelInfo *v30; // r6
  CBaseModelInfo *v31; // r5
  int32 v32; // r4
  CBaseModelInfo *v33; // r5
  int32 index; // [sp+14h] [bp-24h]

  CStreamedScripts::ReInitialise(&CTheScripts::StreamedScripts);
  m_nextIndex = CStreaming::ms_pStartRequestedList->m_nextIndex;
  if ( m_nextIndex == -1 )
    v1 = 0;
  else
    v1 = &CStreamingInfo::ms_pArrayBase[m_nextIndex];
  if ( v1 != CStreaming::ms_pEndRequestedList )
  {
    do
    {
      v2 = (unsigned __int16)v1->m_nextIndex;
      if ( v2 == 0xFFFF )
        v3 = 0;
      else
        v3 = &CStreamingInfo::ms_pArrayBase[(__int16)v2];
      CStreaming::RemoveModel(-858993459 * (((char *)v1 - (char *)CStreaming::ms_aInfoForModel) >> 2));
      v1 = v3;
    }
    while ( v3 != CStreaming::ms_pEndRequestedList );
  }
  CStreaming::FlushChannels();
  CStreaming::DeleteAllRwObjects();
  CStreaming::RemoveAllUnusedModels();
  v4 = 0;
  do
  {
    index = v4;
    m_flags = CStreaming::ms_aInfoForModel[v4].m_flags;
    if ( (m_flags & 4) != 0 )
    {
      for ( i = index; ; m_flags = CStreaming::ms_aInfoForModel[i].m_flags )
      {
        v7 = &CStreaming::ms_aInfoForModel[i];
        v7->m_flags = m_flags & 0xFB;
        if ( (m_flags & 2) != 0 )
          goto LABEL_17;
        if ( CStreaming::ms_aInfoForModel[i].m_status == 1 )
          break;
        if ( (m_flags & 8) == 0 )
          CStreaming::RemoveModel(i);
        if ( i > 19999 )
          goto LABEL_22;
LABEL_12:
        i = CModelInfo::ms_modelInfoPtrs[i]->m_txdIndex + 20000;
      }
      if ( (unsigned __int16)v7->m_nextIndex == 0xFFFF )
      {
        v8 = CStreamingInfo::ms_pArrayBase;
        v9 = CStreaming::ms_pStartLoadedList;
        v7->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v10 = -858993459 * ((unsigned int)((char *)v7 - (char *)v8) >> 2);
        CStreaming::ms_aInfoForModel[i].m_prevIndex = -13107 * ((unsigned int)((char *)v9 - (char *)v8) >> 2);
        v9->m_nextIndex = v10;
        CStreamingInfo::ms_pArrayBase[v7->m_nextIndex].m_prevIndex = v10;
      }
LABEL_17:
      if ( i > 19999 )
        goto LABEL_22;
      goto LABEL_12;
    }
LABEL_22:
    v4 = index + 1;
  }
  while ( index != 26315 );
  for ( j = 0; j != 82; ++j )
    CStreaming::RemoveModel(j + 26230);
  gGenerateCopsOnBikes = 0;
  gDisableCopsOnBikes = 0;
  gTimeBeforeChangeVehicles = 0;
  CStreaming::ms_currentZoneType = -1;
  CStreaming::ms_disableStreaming = 0;
  CStreaming::m_bBoatsNeeded = 0;
  CStreaming::RemoveModel(290);
  v12 = CModelInfo::ms_modelInfoPtrs[290];
  v12->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v12->m_modelName[0] = 0;
  CStreaming::RemoveModel(291);
  v13 = CModelInfo::ms_modelInfoPtrs[291];
  v13->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v13->m_modelName[0] = 0;
  CStreaming::RemoveModel(292);
  v14 = CModelInfo::ms_modelInfoPtrs[292];
  v14->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v14->m_modelName[0] = 0;
  CStreaming::RemoveModel(293);
  v15 = CModelInfo::ms_modelInfoPtrs[293];
  v15->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v15->m_modelName[0] = 0;
  CStreaming::RemoveModel(294);
  v16 = CModelInfo::ms_modelInfoPtrs[294];
  v16->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v16->m_modelName[0] = 0;
  CStreaming::RemoveModel(295);
  v17 = CModelInfo::ms_modelInfoPtrs[295];
  v17->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v17->m_modelName[0] = 0;
  CStreaming::RemoveModel(296);
  v18 = CModelInfo::ms_modelInfoPtrs[296];
  v18->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v18->m_modelName[0] = 0;
  CStreaming::RemoveModel(297);
  v19 = CModelInfo::ms_modelInfoPtrs[297];
  v19->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v19->m_modelName[0] = 0;
  CStreaming::RemoveModel(298);
  v20 = CModelInfo::ms_modelInfoPtrs[298];
  v20->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v20->m_modelName[0] = 0;
  CStreaming::RemoveModel(299);
  v21 = CModelInfo::ms_modelInfoPtrs[299];
  v21->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v21->m_modelName[0] = 0;
  CStreaming::RemoveModel(384);
  v22 = CModelInfo::ms_modelInfoPtrs[384];
  v22->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v22->m_modelName[0] = 0;
  CStreaming::RemoveModel(385);
  v23 = CModelInfo::ms_modelInfoPtrs[385];
  v23->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v23->m_modelName[0] = 0;
  CStreaming::RemoveModel(386);
  v24 = CModelInfo::ms_modelInfoPtrs[386];
  v24->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v24->m_modelName[0] = 0;
  CStreaming::RemoveModel(387);
  v25 = CModelInfo::ms_modelInfoPtrs[387];
  v25->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v25->m_modelName[0] = 0;
  CStreaming::RemoveModel(388);
  v26 = CModelInfo::ms_modelInfoPtrs[388];
  v26->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v26->m_modelName[0] = 0;
  CStreaming::RemoveModel(389);
  v27 = CModelInfo::ms_modelInfoPtrs[389];
  v27->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v27->m_modelName[0] = 0;
  CStreaming::RemoveModel(390);
  v28 = CModelInfo::ms_modelInfoPtrs[390];
  v28->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v28->m_modelName[0] = 0;
  CStreaming::RemoveModel(391);
  v29 = CModelInfo::ms_modelInfoPtrs[391];
  v29->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v29->m_modelName[0] = 0;
  CStreaming::RemoveModel(392);
  v30 = CModelInfo::ms_modelInfoPtrs[392];
  v30->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v30->m_modelName[0] = 0;
  CStreaming::RemoveModel(393);
  v31 = CModelInfo::ms_modelInfoPtrs[393];
  v31->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
  v32 = 300;
  v31->m_modelName[0] = 0;
  do
  {
    CStreaming::RemoveModel(v32);
    v33 = CModelInfo::ms_modelInfoPtrs[v32++];
    v33->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&byte_61CADE);
    v33->m_modelName[0] = 0;
  }
  while ( v32 != 320 );
}
// FC: using guessed type int elf_hash_bucket[16411];
// 61CADE: using guessed type char byte_61CADE;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002CFD84) --------------------------------------------------------
void CStreaming::FlushRequestList()
{
  int m_nextIndex; // r0
  CStreamingInfo *v1; // r0
  int v2; // r1
  CStreamingInfo *v3; // r6

  m_nextIndex = CStreaming::ms_pStartRequestedList->m_nextIndex;
  if ( m_nextIndex == -1 )
    v1 = 0;
  else
    v1 = &CStreamingInfo::ms_pArrayBase[m_nextIndex];
  if ( v1 != CStreaming::ms_pEndRequestedList )
  {
    do
    {
      v2 = (unsigned __int16)v1->m_nextIndex;
      if ( v2 == 0xFFFF )
        v3 = 0;
      else
        v3 = &CStreamingInfo::ms_pArrayBase[(__int16)v2];
      CStreaming::RemoveModel(-858993459 * (((char *)v1 - (char *)CStreaming::ms_aInfoForModel) >> 2));
      v1 = v3;
    }
    while ( v3 != CStreaming::ms_pEndRequestedList );
  }
  CStreaming::FlushChannels();
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002CFE2C) --------------------------------------------------------
void CStreaming::DeleteAllRwObjects()
{
  int i; // r9
  int j; // r5
  int v2; // r6
  CPtrNode *m_pHead; // r8
  CPtrNode v4; // kr00_8
  CPtrNode *v5; // r4
  CPtrNode v6; // kr08_8
  CPtrNode *v7; // r4
  CPtrNode v8; // kr10_8

  for ( i = 0; i != 120; ++i )
  {
    for ( j = 0; j != 120; ++j )
    {
      v2 = i + 120 * j;
      m_pHead = CWorld::ms_aSectors[v2].m_buildingPtrListArray.m_pHead;
      while ( m_pHead )
      {
        v4 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        if ( (*((_BYTE *)v4.m_pVoid + 29) & 0x24) == 0 )
          (*(void (__fastcall **)(void *))(*(_DWORD *)v4.m_pVoid + 36))(v4.m_pVoid);
      }
      v5 = CWorld::ms_aRepeatSectors[(unsigned __int8)(16 * j) | i & 0xF].m_ptrListArray[2].m_pHead;
      while ( v5 )
      {
        v6 = *v5;
        v5 = v5->m_pNext;
        if ( (*((_BYTE *)v6.m_pVoid + 29) & 0x24) == 0 )
          (*(void (__fastcall **)(void *))(*(_DWORD *)v6.m_pVoid + 36))(v6.m_pVoid);
      }
      v7 = CWorld::ms_aSectors[v2].m_dummyPtrListArray.m_pHead;
      while ( v7 )
      {
        v8 = *v7;
        v7 = v7->m_pNext;
        if ( (*((_BYTE *)v8.m_pVoid + 29) & 0x24) == 0 )
          (*(void (__fastcall **)(void *))(*(_DWORD *)v8.m_pVoid + 36))(v8.m_pVoid);
      }
    }
  }
}

//----- (002CFEF0) --------------------------------------------------------
void CStreaming::RemoveAllUnusedModels()
{
  uint8 *p_m_status; // r5
  int32 i; // r4

  p_m_status = &CStreaming::ms_aInfoForModel[1000].m_status;
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  CStreaming::RemoveLoadedVehicle();
  for ( i = 1000; i != 20000; ++i )
  {
    if ( *p_m_status == 1 && !CModelInfo::ms_modelInfoPtrs[i]->m_numRefs )
    {
      CStreaming::RemoveModel(i);
      *(p_m_status - 10) = 0;
    }
    p_m_status += 20;
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D0010) --------------------------------------------------------
void __fastcall CStreaming::SetMissionDoesntRequireModel(int32 a1)
{
  CStreamingInfo *v2; // r0
  uint8 m_flags; // r3
  CStreamingInfo *v4; // r2
  CStreamingInfo *v5; // lr
  int16 v6; // r10

  while ( 1 )
  {
    v2 = &CStreaming::ms_aInfoForModel[a1];
    m_flags = v2->m_flags;
    v2->m_flags = m_flags & 0xFB;
    if ( (m_flags & 2) != 0 )
    {
LABEL_6:
      if ( a1 > 19999 )
        return;
      goto LABEL_2;
    }
    if ( CStreaming::ms_aInfoForModel[a1].m_status != 1 )
      break;
    if ( (unsigned __int16)v2->m_nextIndex != 0xFFFF )
      goto LABEL_6;
    v4 = CStreaming::ms_pStartLoadedList;
    v5 = CStreamingInfo::ms_pArrayBase;
    v2->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
    v6 = -13107 * ((unsigned int)((char *)v2 - (char *)v5) >> 2);
    CStreaming::ms_aInfoForModel[a1].m_prevIndex = -13107 * ((unsigned int)((char *)v4 - (char *)v5) >> 2);
    v4->m_nextIndex = v6;
    CStreamingInfo::ms_pArrayBase[v2->m_nextIndex].m_prevIndex = v6;
    if ( a1 > 19999 )
      return;
LABEL_2:
    a1 = CModelInfo::ms_modelInfoPtrs[a1]->m_txdIndex + 20000;
  }
  if ( (m_flags & 8) == 0 )
    CStreaming::RemoveModel(a1);
  if ( a1 <= 19999 )
    goto LABEL_2;
}

//----- (002D0128) --------------------------------------------------------
void __fastcall CStreaming::RemoveModel(int32 index)
{
  int32 v2; // r5
  CStreamingInfo *v3; // r10
  int v4; // r1
  uint8 *p_m_status; // r10
  int m_status; // t1
  CBaseModelInfo *v7; // r9
  int m_nextIndex; // r2
  int i; // r0
  int32 *v10; // r6
  CStreamingInfo *v11; // r0
  CStreamingInfo *v12; // r1
  uint8 *p_m_flags; // r1
  uint8 v14; // r3
  uint8 m_flags; // t1
  CStreamingInfo *v16; // r3

  v2 = index;
  v3 = &CStreaming::ms_aInfoForModel[index];
  m_status = v3->m_status;
  p_m_status = &v3->m_status;
  v4 = m_status;
  if ( m_status )
  {
    if ( v4 == 1 )
    {
      if ( index > 19999 )
      {
        if ( index > 24999 )
        {
          if ( index > 25254 )
          {
            if ( index > 25510 )
            {
              if ( index > 25574 )
              {
                if ( index > 25754 )
                {
                  if ( index >= 26230 )
                    CStreamedScripts::RemoveStreamedScriptFromMemory(&CTheScripts::StreamedScripts, index - 26230);
                }
                else
                {
                  CAnimManager::RemoveAnimBlock(index - 25575);
                }
              }
              else
              {
                CPathFind::UnLoadPathFindData(&ThePaths, index - 25511);
              }
            }
            else
            {
              CIplStore::RemoveIpl(index - 25255);
            }
          }
          else
          {
            CColStore::RemoveCol(index - 25000);
          }
        }
        else
        {
          CTxdStore::RemoveTxd(index - 20000);
        }
      }
      else
      {
        v7 = CModelInfo::ms_modelInfoPtrs[index];
        (*((void (__fastcall **)(CBaseModelInfo *))v7->_vptr$CBaseModelInfo + 9))(v7);
        if ( (*((int (__fastcall **)(CBaseModelInfo *))v7->_vptr$CBaseModelInfo + 5))(v7) == 7 )
        {
          if ( CStreaming::ms_pedsLoaded[0] == index )
          {
            CStreaming::ms_pedsLoaded[0] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[1] == index )
          {
            CStreaming::ms_pedsLoaded[1] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[2] == index )
          {
            CStreaming::ms_pedsLoaded[2] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[3] == index )
          {
            CStreaming::ms_pedsLoaded[3] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[4] == index )
          {
            CStreaming::ms_pedsLoaded[4] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[5] == index )
          {
            CStreaming::ms_pedsLoaded[5] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[6] == index )
          {
            CStreaming::ms_pedsLoaded[6] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
          if ( CStreaming::ms_pedsLoaded[7] == index )
          {
            CStreaming::ms_pedsLoaded[7] = -1;
            --CStreaming::ms_numPedsLoaded;
          }
        }
        if ( (*((int (__fastcall **)(CBaseModelInfo *))v7->_vptr$CBaseModelInfo + 5))(v7) == 6 )
          CStreaming::RemoveCarModel(index);
      }
      CStreaming::ms_memoryUsed -= CStreaming::ms_aInfoForModel[v2].m_cdSize << 11;
      v4 = *p_m_status;
    }
    m_nextIndex = (unsigned __int16)CStreaming::ms_aInfoForModel[v2].m_nextIndex;
    if ( m_nextIndex == 0xFFFF )
    {
      if ( v4 == 3 )
      {
        for ( i = 0; i != 16; ++i )
        {
          v10 = &CStreaming::ms_channel[0].currentLoading[i];
          if ( *v10 == index )
            CStreaming::ms_channel[0].currentLoading[i] = -1;
          if ( v10[38] == index )
            v10[38] = -1;
        }
LABEL_62:
        *p_m_status = 0;
        return;
      }
    }
    else
    {
      v11 = &CStreaming::ms_aInfoForModel[v2];
      if ( v4 == 2 )
      {
        --CStreaming::ms_numModelsRequested;
        v12 = &CStreaming::ms_aInfoForModel[v2];
        m_flags = v12->m_flags;
        p_m_flags = &v12->m_flags;
        v14 = m_flags;
        if ( (m_flags & 0x10) != 0 )
        {
          *p_m_flags = v14 & 0xEF;
          --CStreaming::ms_numPriorityRequests;
        }
      }
      v16 = &CStreaming::ms_aInfoForModel[v2];
      CStreamingInfo::ms_pArrayBase[(__int16)m_nextIndex].m_prevIndex = v16->m_prevIndex;
      CStreamingInfo::ms_pArrayBase[v16->m_prevIndex].m_nextIndex = v11->m_nextIndex;
      v11->m_nextIndex = -1;
      v16->m_prevIndex = -1;
      v4 = *p_m_status;
    }
    if ( v4 == 4 )
    {
      if ( index > 19999 )
      {
        if ( index > 24999 )
        {
          if ( index > 25254 )
          {
            if ( index > 25510 )
            {
              if ( (unsigned int)(index - 25575) > 0xB3 )
              {
                if ( index >= 26230 )
                  CStreamedScripts::RemoveStreamedScriptFromMemory(&CTheScripts::StreamedScripts, index - 26230);
              }
              else
              {
                CAnimManager::RemoveAnimBlock(index - 25575);
              }
            }
            else
            {
              CIplStore::RemoveIpl(index - 25255);
            }
          }
          else
          {
            CColStore::RemoveCol(index - 25000);
          }
        }
        else
        {
          CTxdStore::RemoveTxd(index - 20000);
        }
      }
      else
      {
        RpClumpGtaCancelStream();
      }
    }
    goto LABEL_62;
  }
}

//----- (002D0558) --------------------------------------------------------
void CStreaming::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  double v2; // d17
  bool v3; // r1
  bool v4; // zf
  float v5; // s0
  CSimpleTransform *p_tx; // r0
  float v7; // s16
  CSimpleTransform *p_m_transform; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *v10; // r2
  CMatrix *v11; // r2
  CSimpleTransform *v12; // r0
  CMatrix *v13; // r1
  CSimpleTransform *v14; // r2
  CMatrix *v15; // r2
  CSimpleTransform *p_posn; // r0
  CVector *PlayerCoors; // r0
  int m_prevIndex; // r0
  CStreamingInfo *v19; // r0
  CStreamingInfo *v20; // r1
  int v21; // r2
  CStreamingInfo *v22; // r6
  CVector posn; // [sp+4h] [bp-2Ch] BYREF

  g_LoadMonitor.m_iCyclesThisFrame[2] = CStreaming::ms_numModelsRequested;
  v2 = OS_TimeAccurate();
  v3 = 0;
  v4 = gMobileMenu.screenStack.numEntries == 0;
  v0.n64_f32[0] = v2 - CStreaming::Update(void)::lastTime;
  CStreaming::Update(void)::lastTime = v2;
  if ( !gMobileMenu.screenStack.numEntries )
    v4 = gMobileMenu.pendingScreen == 0;
  if ( !v4 && !gMobileMenu.isMapMode )
    v3 = 1;
  v1.n64_u32[0] = 1036831949;
  TextureDatabaseRuntime::UpdateStreaming(vmin_f32(v0, v1).n64_f32[0], v3);
  if ( !((CTimer::m_UserPause || CTimer::m_CodePause) << 24) )
  {
    v5 = CCamera::CalculateGroundHeight(&TheCamera, 0);
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v7 = p_tx->m_translate.z - v5;
    if ( !((CRenderer::m_loadingPriority || CStreaming::ms_disableStreaming) << 24) )
    {
      if ( v7 < 50.0 || CWorld::Players[0].pRemoteVehicle )
      {
        if ( CRenderer::ms_bRenderOutsideTunnels )
          CStreaming::AddModelsToRequestList(&p_tx->m_translate, 0);
      }
      else if ( CGame::currArea == AREA_MAIN_MAP )
      {
        CStreaming::AddLodsToRequestList(&p_tx->m_translate, 0);
      }
    }
    if ( (CTimer::m_FrameCounter & 0x7F) == 106 )
    {
      CStreaming::m_bBoatsNeeded = 0;
      p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_m_transform = &TheCamera.m_transform;
      if ( p_m_transform->m_translate.z < 500.0 )
        CStreaming::m_bBoatsNeeded = CPathFind::IsWaterNodeNearby(&ThePaths, p_m_transform->m_translate, 80.0);
    }
    if ( !CStreaming::ms_disableStreaming
      && v7 < 50.0
      && !CCutsceneMgr::ms_cutsceneProcessing
      && CGame::currArea == AREA_MAIN_MAP )
    {
      FindPlayerCoors(&posn, -1);
      CStreaming::StreamVehiclesAndPeds_Always(&posn);
      if ( !CRenderer::m_loadingPriority && CStreaming::ms_numModelsRequested <= 5 )
      {
        CStreaming::StreamVehiclesAndPeds();
        PlayerCoors = FindPlayerCoors(&posn, -1);
        CStreaming::StreamZoneModels(PlayerCoors);
      }
    }
    CStreaming::LoadRequestedModels();
    FindPlayerCoors(&posn, -1);
    if ( CWorld::Players[0].pRemoteVehicle )
    {
      CColStore::AddCollisionNeededAtPosn(&posn);
      m_pMat = CWorld::Players[0].pRemoteVehicle->m_pMat;
      v10 = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        v10 = &CWorld::Players[0].pRemoteVehicle->m_transform;
      CColStore::LoadCollision(v10->m_translate, 0);
      v11 = CWorld::Players[0].pRemoteVehicle->m_pMat;
      v12 = (CSimpleTransform *)&v11->tx;
      if ( !v11 )
        v12 = &CWorld::Players[0].pRemoteVehicle->m_transform;
      CColStore::EnsureCollisionIsInMemory(&v12->m_translate);
      CIplStore::AddIplsNeededAtPosn(&posn);
      v13 = CWorld::Players[0].pRemoteVehicle->m_pMat;
      v14 = (CSimpleTransform *)&v13->tx;
      if ( !v13 )
        v14 = &CWorld::Players[0].pRemoteVehicle->m_transform;
      CIplStore::LoadIpls(v14->m_translate, 0);
      v15 = CWorld::Players[0].pRemoteVehicle->m_pMat;
      p_posn = (CSimpleTransform *)&v15->tx;
      if ( !v15 )
        p_posn = &CWorld::Players[0].pRemoteVehicle->m_transform;
    }
    else
    {
      CColStore::LoadCollision(posn, 0);
      CColStore::EnsureCollisionIsInMemory(&posn);
      CIplStore::LoadIpls(posn, 0);
      p_posn = (CSimpleTransform *)&posn;
    }
    CIplStore::EnsureIplsAreInMemory(&p_posn->m_translate);
    if ( CStreaming::ms_bEnableRequestListPurge )
    {
      m_prevIndex = CStreaming::ms_pEndRequestedList->m_prevIndex;
      v19 = m_prevIndex == -1 ? 0 : &CStreamingInfo::ms_pArrayBase[m_prevIndex];
      v20 = CStreaming::ms_pStartRequestedList;
      if ( v19 != CStreaming::ms_pStartRequestedList )
      {
        do
        {
          v21 = (unsigned __int16)v19->m_prevIndex;
          if ( v21 == 0xFFFF )
            v22 = 0;
          else
            v22 = &CStreamingInfo::ms_pArrayBase[(__int16)v21];
          if ( (v19->m_flags & 0x1E) == 0 )
          {
            CStreaming::RemoveModel(-858993459 * (((char *)v19 - (char *)CStreaming::ms_aInfoForModel) >> 2));
            v20 = CStreaming::ms_pStartRequestedList;
          }
          v19 = v22;
        }
        while ( v22 != v20 );
      }
    }
  }
}
// 2D05BA: variable 'v0' is possibly undefined
// 2D05BA: variable 'v1' is possibly undefined
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D0900) --------------------------------------------------------
void __fastcall CStreaming::AddModelsToRequestList(const CVector *posn, uint32 reqFlag)
{
  float x; // s26
  float y; // s28
  int *v4; // r1
  float v5; // s16
  float v6; // s18
  float v7; // s20
  float v8; // s22
  float v9; // s19
  float v10; // s24
  float v11; // r8
  float v12; // r10
  float v13; // r9
  float v14; // s30
  float v15; // s28
  float v16; // r0
  int v17; // r5
  int v18; // s26
  int v19; // s28
  int v20; // r2
  int v21; // s30
  int v22; // r1
  int v23; // r1
  uint16 v24; // r0
  unsigned int v25; // r10
  int v26; // r0
  int v27; // r0
  int v28; // r11
  int v29; // r4
  unsigned int v30; // r1
  int v31; // r0
  int v32; // r9
  CSector *v33; // r0
  int v34; // r2
  int v35; // [sp+14h] [bp-A4h]
  int v36; // [sp+18h] [bp-A0h]
  int v37; // [sp+1Ch] [bp-9Ch]
  int v38; // [sp+20h] [bp-98h]
  int v39; // [sp+30h] [bp-88h]
  int v42; // [sp+50h] [bp-68h]

  x = posn->x;
  y = posn->y;
  v4 = dword_2D0BD4;
  if ( CGame::currArea )
    v4 = &dword_2D0BD4[1];
  v5 = *(float *)v4;
  v6 = x - *(float *)v4;
  v7 = y - *(float *)v4;
  v8 = x + *(float *)v4;
  v9 = *(float *)v4 / 50.0;
  v10 = y + *(float *)v4;
  v11 = floorf((float)(v6 / 50.0) + 60.0);
  v12 = floorf((float)(v7 / 50.0) + 60.0);
  v13 = floorf((float)(v8 / 50.0) + 60.0);
  v14 = floorf((float)(x / 50.0) + 60.0);
  v15 = floorf((float)(y / 50.0) + 60.0);
  v16 = floorf((float)(v10 / 50.0) + 60.0);
  v17 = 119;
  v18 = (int)v9;
  v19 = (int)v15;
  v20 = 0;
  v21 = (int)v14;
  v22 = (int)v16;
  if ( (int)v16 >= 119 )
    v22 = 119;
  v35 = v22;
  if ( (int)v13 < 119 )
    v17 = (int)v13;
  v23 = (int)v12;
  if ( (int)v12 <= 0 )
    v23 = 0;
  v38 = v23;
  if ( (int)v11 > 0 )
    v20 = (int)v11;
  v36 = v20;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v24 = 1;
  }
  else
  {
    v24 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v24;
  if ( v38 <= v35 )
  {
    v25 = (v18 - 1) * (v18 - 1);
    v37 = v38 - v19;
    v39 = v17;
    do
    {
      if ( v36 <= v17 )
      {
        v26 = 119;
        if ( v38 < 119 )
          v26 = v38;
        v42 = 120 * v26;
        v27 = v36;
        do
        {
          v28 = v27;
          v29 = v27 & 0xF | (unsigned __int8)(16 * v38);
          v30 = v37 * v37 + (v27 - v21) * (v27 - v21);
          v31 = 119;
          if ( v28 < 119 )
            v31 = v28;
          v32 = v31 + v42;
          v33 = &CWorld::ms_aSectors[v31 + v42];
          if ( v30 <= v25 )
          {
            CStreaming::ProcessEntitiesInSectorList(&v33->m_buildingPtrListArray, reqFlag);
            CStreaming::ProcessEntitiesInSectorList(&CWorld::ms_aRepeatSectors[v29].m_ptrListArray[2], reqFlag);
            CStreaming::ProcessEntitiesInSectorList(&CWorld::ms_aSectors[v32].m_dummyPtrListArray, reqFlag);
          }
          else if ( v30 <= (v18 + 2) * (v18 + 2) )
          {
            CStreaming::ProcessEntitiesInSectorList(
              &v33->m_buildingPtrListArray,
              posn->x,
              posn->y,
              v6,
              v7,
              v8,
              v10,
              v5,
              reqFlag);
            CStreaming::ProcessEntitiesInSectorList(
              &CWorld::ms_aRepeatSectors[v29].m_ptrListArray[2],
              posn->x,
              posn->y,
              v6,
              v7,
              v8,
              v10,
              v5,
              reqFlag);
            v17 = v39;
            v25 = (v18 - 1) * (v18 - 1);
            CStreaming::ProcessEntitiesInSectorList(
              &CWorld::ms_aSectors[v32].m_dummyPtrListArray,
              posn->x,
              posn->y,
              v6,
              v7,
              v8,
              v10,
              v5,
              reqFlag);
          }
          v27 = v28 + 1;
        }
        while ( v28 < v17 );
      }
      v34 = v38;
      ++v37;
      ++v38;
    }
    while ( v34 < v35 );
  }
}
// 2D0BD4: using guessed type int dword_2D0BD4[2];

//----- (002D0C00) --------------------------------------------------------
void __fastcall CStreaming::AddLodsToRequestList(const CVector *posn, uint32 reqFlag)
{
  float y; // s2
  int v5; // r9
  int v6; // r2
  float v7; // s16
  float v8; // s24
  float v9; // s18
  float v10; // s20
  float v11; // s22
  int v12; // r1
  int v13; // r4
  uint16 v14; // r0
  CPtrListSingleLink *v15; // r11
  int v16; // r10
  CPtrList *v17; // r4
  int v18; // [sp+1Ch] [bp-54h]
  int v19; // [sp+20h] [bp-50h]
  int v20; // [sp+24h] [bp-4Ch]

  y = posn->y;
  v5 = 29;
  v6 = 0;
  v7 = CRenderer::ms_fFarClipPlane;
  v8 = posn->x - CRenderer::ms_fFarClipPlane;
  v9 = CRenderer::ms_fFarClipPlane + y;
  v10 = CRenderer::ms_fFarClipPlane + posn->x;
  v11 = y - CRenderer::ms_fFarClipPlane;
  v12 = (int)(float)((float)((float)(CRenderer::ms_fFarClipPlane + y) / 200.0) + 15.0);
  v13 = (int)(float)((float)((float)(y - CRenderer::ms_fFarClipPlane) / 200.0) + 15.0);
  if ( v12 >= 29 )
    v12 = 29;
  v19 = v12;
  if ( (int)(float)((float)(v10 / 200.0) + 15.0) < 29 )
    v5 = (int)(float)((float)(v10 / 200.0) + 15.0);
  if ( v13 <= 0 )
    v13 = 0;
  if ( (int)(float)((float)(v8 / 200.0) + 15.0) > 0 )
    v6 = (int)(float)((float)(v8 / 200.0) + 15.0);
  v18 = v6;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v14 = 1;
  }
  else
  {
    v14 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v14;
  if ( v13 <= v19 )
  {
    v15 = &CWorld::ms_aLodPtrLists[30 * v13 + v18];
    do
    {
      v20 = v13;
      if ( v18 <= v5 )
      {
        v16 = v18 - 1;
        v17 = v15;
        do
        {
          CStreaming::ProcessEntitiesInSectorList(v17, posn->x, posn->y, v8, v11, v10, v9, v7, reqFlag);
          ++v16;
          ++v17;
        }
        while ( v16 < v5 );
      }
      v15 += 30;
      v13 = v20 + 1;
    }
    while ( v20 < v19 );
  }
}

//----- (002D0D50) --------------------------------------------------------
void __fastcall CStreaming::StreamVehiclesAndPeds_Always(const CVector *posn)
{
  CVehicle *PlayerVehicle; // r0
  int32 m_vehicleType; // r1
  const CVector *v3; // r0

  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( !PlayerVehicle
    || (m_vehicleType = PlayerVehicle->m_vehicleType, m_vehicleType != 4)
    && (m_vehicleType != 3
     || sqrtf(
          (float)(PlayerVehicle->m_vecMoveSpeed.x * PlayerVehicle->m_vecMoveSpeed.x)
        + (float)(PlayerVehicle->m_vecMoveSpeed.y * PlayerVehicle->m_vecMoveSpeed.y)) <= 0.1) )
  {
    v3 = (const CVector *)((unsigned __int8)CTimer::m_FrameCounter << 26);
    if ( !v3 )
    {
      v3 = (const CVector *)CLoadedCarGroup::CountMembers(&CPopulation::m_AppropriateLoadedCars);
      if ( (int)v3 <= 2 )
        CStreaming::StreamOneNewCar();
    }
    CStreaming::StreamZoneModels_Gangs(v3);
    if ( CPopCycle::m_pCurrZoneInfo )
    {
      if ( CStreaming::StreamVehiclesAndPeds_Always(CVector const&)::LoadCarPopType != (*(_WORD *)((char *)CPopCycle::m_pCurrZoneInfo
                                                                                                 + 15) & 0x1F) )
      {
        CStreaming::ReclassifyLoadedCars();
        CStreaming::StreamVehiclesAndPeds_Always(CVector const&)::LoadCarPopType = *(_WORD *)((char *)CPopCycle::m_pCurrZoneInfo
                                                                                            + 15) & 0x1F;
      }
    }
  }
}
// 2D0DB0: variable 'v3' is possibly undefined
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;

//----- (002D0E0C) --------------------------------------------------------
bool CStreaming::IsVeryBusy()
{
  return CRenderer::m_loadingPriority || CStreaming::ms_numModelsRequested > 5;
}

//----- (002D0E38) --------------------------------------------------------
void CStreaming::StreamVehiclesAndPeds()
{
  CWanted *PlayerWanted; // r0
  char v1; // r0
  unsigned int v2; // r6
  char v3; // r0
  unsigned int v4; // r6
  CWanted *v5; // r0
  char v6; // r0
  unsigned int v7; // r6
  char v8; // r0
  unsigned int v9; // r6
  CWanted *v10; // r0
  char v11; // r0
  unsigned int v12; // r6
  char v13; // r0
  unsigned int v14; // r6
  bool v15; // zf
  char v16; // r0
  unsigned int v17; // r6
  CWanted *v18; // r0
  CWanted *v19; // r0
  char v20; // r0
  unsigned int v21; // r6
  char v22; // r0
  int *v23; // r0
  CStreamingInfo *v24; // r2
  unsigned int v25; // r5
  unsigned int v26; // r6
  int v27; // r4
  char v28; // r0
  int32 v29; // r0
  int v30; // r10
  UInt32 v31; // r0
  int v32; // r6
  int32 v33; // r0
  int32 v34; // r2
  CStreamingInfo *v35; // r1
  uint8 m_flags; // r5
  CStreamingInfo *v37; // r0
  CStreamingInfo *v38; // lr
  int16 v39; // r8
  int v40; // r0
  char v41; // r0

  CStreaming::StreamCopModels(CTheZones::m_CurrLevel);
  PlayerWanted = FindPlayerWanted(-1);
  if ( CWanted::AreSwatRequired(PlayerWanted) )
  {
    CStreaming::RequestModel(427, 2);
    CStreaming::RequestModel(285, 2);
    goto LABEL_18;
  }
  v1 = CStreaming::ms_aInfoForModel[427].m_flags & 0xFD;
  v15 = (CStreaming::ms_aInfoForModel[427].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[427].m_flags &= ~2u;
  if ( !v15 )
    goto LABEL_10;
  if ( CStreaming::ms_aInfoForModel[427].m_status == 1 )
  {
    if ( (unsigned __int16)CStreaming::ms_aInfoForModel[427].m_nextIndex != 0xFFFF )
      goto LABEL_18;
    CStreaming::ms_aInfoForModel[427].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
    v2 = -858993459
       * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[427] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
    CStreaming::ms_aInfoForModel[427].m_prevIndex = -13107
                                                  * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                  - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
    CStreaming::ms_pStartLoadedList->m_nextIndex = v2;
    CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[427].m_nextIndex].m_prevIndex = v2;
LABEL_10:
    if ( CStreaming::ms_aInfoForModel[427].m_status == 1 )
      goto LABEL_18;
    goto LABEL_11;
  }
  if ( (v1 & 8) == 0 )
  {
    CStreaming::RemoveModel(427);
    goto LABEL_10;
  }
LABEL_11:
  v3 = CStreaming::ms_aInfoForModel[285].m_flags & 0xFD;
  v15 = (CStreaming::ms_aInfoForModel[285].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[285].m_flags &= ~2u;
  if ( v15 )
  {
    if ( CStreaming::ms_aInfoForModel[285].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[285].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[285].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v4 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[285] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[285].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v4;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[285].m_nextIndex].m_prevIndex = v4;
      }
    }
    else if ( (v3 & 8) == 0 )
    {
      CStreaming::RemoveModel(285);
    }
  }
LABEL_18:
  v5 = FindPlayerWanted(-1);
  if ( CWanted::AreFbiRequired(v5) )
  {
    CStreaming::RequestModel(490, 2);
    CStreaming::RequestModel(286, 2);
    goto LABEL_35;
  }
  v6 = CStreaming::ms_aInfoForModel[490].m_flags & 0xFD;
  v15 = (CStreaming::ms_aInfoForModel[490].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[490].m_flags &= ~2u;
  if ( !v15 )
    goto LABEL_27;
  if ( CStreaming::ms_aInfoForModel[490].m_status == 1 )
  {
    if ( (unsigned __int16)CStreaming::ms_aInfoForModel[490].m_nextIndex != 0xFFFF )
      goto LABEL_35;
    CStreaming::ms_aInfoForModel[490].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
    v7 = -858993459
       * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[490] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
    CStreaming::ms_aInfoForModel[490].m_prevIndex = -13107
                                                  * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                  - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
    CStreaming::ms_pStartLoadedList->m_nextIndex = v7;
    CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[490].m_nextIndex].m_prevIndex = v7;
LABEL_27:
    if ( CStreaming::ms_aInfoForModel[490].m_status == 1 )
      goto LABEL_35;
    goto LABEL_28;
  }
  if ( (v6 & 8) == 0 )
  {
    CStreaming::RemoveModel(490);
    goto LABEL_27;
  }
LABEL_28:
  v8 = CStreaming::ms_aInfoForModel[286].m_flags & 0xFD;
  v15 = (CStreaming::ms_aInfoForModel[286].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[286].m_flags &= ~2u;
  if ( v15 )
  {
    if ( CStreaming::ms_aInfoForModel[286].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[286].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[286].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v9 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[286] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[286].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v9;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[286].m_nextIndex].m_prevIndex = v9;
      }
    }
    else if ( (v8 & 8) == 0 )
    {
      CStreaming::RemoveModel(286);
    }
  }
LABEL_35:
  v10 = FindPlayerWanted(-1);
  if ( CWanted::AreArmyRequired(v10) )
  {
    CStreaming::RequestModel(432, 2);
    CStreaming::RequestModel(433, 2);
    CStreaming::RequestModel(287, 2);
  }
  else
  {
    v11 = CStreaming::ms_aInfoForModel[433].m_flags & 0xFD;
    v15 = (CStreaming::ms_aInfoForModel[433].m_flags & 4) == 0;
    CStreaming::ms_aInfoForModel[433].m_flags &= ~2u;
    if ( v15 )
    {
      if ( CStreaming::ms_aInfoForModel[433].m_status == 1 )
      {
        if ( (unsigned __int16)CStreaming::ms_aInfoForModel[433].m_nextIndex == 0xFFFF )
        {
          CStreaming::ms_aInfoForModel[433].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
          v12 = -858993459
              * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[433] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
          CStreaming::ms_aInfoForModel[433].m_prevIndex = -13107
                                                        * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                        - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
          CStreaming::ms_pStartLoadedList->m_nextIndex = v12;
          CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[433].m_nextIndex].m_prevIndex = v12;
        }
      }
      else if ( (v11 & 8) == 0 )
      {
        CStreaming::RemoveModel(433);
      }
    }
    v13 = CStreaming::ms_aInfoForModel[432].m_flags & 0xFD;
    v15 = (CStreaming::ms_aInfoForModel[432].m_flags & 4) == 0;
    CStreaming::ms_aInfoForModel[432].m_flags &= ~2u;
    if ( v15 )
    {
      if ( CStreaming::ms_aInfoForModel[432].m_status == 1 )
      {
        if ( (unsigned __int16)CStreaming::ms_aInfoForModel[432].m_nextIndex == 0xFFFF )
        {
          CStreaming::ms_aInfoForModel[432].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
          v14 = -858993459
              * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[432] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
          CStreaming::ms_aInfoForModel[432].m_prevIndex = -13107
                                                        * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                        - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
          CStreaming::ms_pStartLoadedList->m_nextIndex = v14;
          CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[432].m_nextIndex].m_prevIndex = v14;
        }
      }
      else if ( (v13 & 8) == 0 )
      {
        CStreaming::RemoveModel(432);
      }
    }
    v15 = CStreaming::ms_aInfoForModel[433].m_status == 1;
    if ( CStreaming::ms_aInfoForModel[433].m_status != 1 )
      v15 = CStreaming::ms_aInfoForModel[432].m_status == 1;
    if ( !v15 )
    {
      v16 = CStreaming::ms_aInfoForModel[287].m_flags & 0xFD;
      v15 = (CStreaming::ms_aInfoForModel[287].m_flags & 4) == 0;
      CStreaming::ms_aInfoForModel[287].m_flags &= ~2u;
      if ( v15 )
      {
        if ( CStreaming::ms_aInfoForModel[287].m_status == 1 )
        {
          if ( (unsigned __int16)CStreaming::ms_aInfoForModel[287].m_nextIndex == 0xFFFF )
          {
            CStreaming::ms_aInfoForModel[287].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
            v17 = -858993459
                * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[287] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
            CStreaming::ms_aInfoForModel[287].m_prevIndex = -13107
                                                          * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                          - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
            CStreaming::ms_pStartLoadedList->m_nextIndex = v17;
            CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[287].m_nextIndex].m_prevIndex = v17;
          }
        }
        else if ( (v16 & 8) == 0 )
        {
          CStreaming::RemoveModel(287);
        }
      }
    }
  }
  v18 = FindPlayerWanted(-1);
  if ( CWanted::NumOfHelisRequired(v18) < 1 )
  {
    v20 = CStreaming::ms_aInfoForModel[488].m_flags & 0xFD;
    v15 = (CStreaming::ms_aInfoForModel[488].m_flags & 4) == 0;
    CStreaming::ms_aInfoForModel[488].m_flags &= ~2u;
    if ( v15 )
    {
      if ( CStreaming::ms_aInfoForModel[488].m_status == 1 )
      {
        if ( (unsigned __int16)CStreaming::ms_aInfoForModel[488].m_nextIndex == 0xFFFF )
        {
          CStreaming::ms_aInfoForModel[488].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
          v21 = -858993459
              * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[488] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
          CStreaming::ms_aInfoForModel[488].m_prevIndex = -13107
                                                        * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                        - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
          CStreaming::ms_pStartLoadedList->m_nextIndex = v21;
          CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[488].m_nextIndex].m_prevIndex = v21;
        }
      }
      else if ( (v20 & 8) == 0 )
      {
        CStreaming::RemoveModel(488);
      }
    }
    v28 = CStreaming::ms_aInfoForModel[497].m_flags & 0xFD;
    v15 = (CStreaming::ms_aInfoForModel[497].m_flags & 4) == 0;
    CStreaming::ms_aInfoForModel[497].m_flags &= ~2u;
    if ( !v15 )
      goto LABEL_88;
    if ( CStreaming::ms_aInfoForModel[497].m_status == 1 )
    {
      v23 = &elf_hash_bucket[2422];
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[497].m_nextIndex != 0xFFFF )
        goto LABEL_88;
      v24 = CStreaming::ms_pStartLoadedList;
      CStreaming::ms_aInfoForModel[497].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
      v25 = -858993459
          * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
      v26 = -858993459
          * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[497] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
      v27 = 9942;
      goto LABEL_82;
    }
    if ( (v28 & 8) != 0 )
      goto LABEL_88;
    v29 = 497;
LABEL_87:
    CStreaming::RemoveModel(v29);
    goto LABEL_88;
  }
  CStreaming::RequestModel(497, 2);
  v19 = FindPlayerWanted(-1);
  if ( CWanted::NumOfHelisRequired(v19) < 2 || !CWanted::bUseNewsHeliInAdditionToPolice )
  {
    v22 = CStreaming::ms_aInfoForModel[488].m_flags & 0xFD;
    v15 = (CStreaming::ms_aInfoForModel[488].m_flags & 4) == 0;
    CStreaming::ms_aInfoForModel[488].m_flags &= ~2u;
    if ( !v15 )
      goto LABEL_88;
    if ( CStreaming::ms_aInfoForModel[488].m_status == 1 )
    {
      v23 = &elf_hash_bucket[2377];
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[488].m_nextIndex != 0xFFFF )
        goto LABEL_88;
      v24 = CStreaming::ms_pStartLoadedList;
      v25 = -858993459
          * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
      CStreaming::ms_aInfoForModel[488].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
      v26 = -858993459
          * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[488] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
      v27 = 9762;
LABEL_82:
      *(int16 *)((char *)&CStreaming::ms_aInfoForModel[0].m_nextIndex + v27) = v25;
      v24->m_nextIndex = v26;
      CStreamingInfo::ms_pArrayBase[*(__int16 *)((char *)&CStreaming::ms_aInfoForModel[0].m_nextIndex + (_DWORD)v23)].m_prevIndex = v26;
      goto LABEL_88;
    }
    if ( (v22 & 8) != 0 )
      goto LABEL_88;
    v29 = 488;
    goto LABEL_87;
  }
  CStreaming::RequestModel(488, 2);
  if ( CPopCycle::m_NumDealers_Peds <= 0.03 )
    goto LABEL_94;
LABEL_88:
  if ( CWeather::WeatherRegion == 2 )
  {
    v30 = 3;
    goto LABEL_95;
  }
  if ( CPopCycle::m_pCurrZoneInfo )
  {
    if ( (*((_BYTE *)CPopCycle::m_pCurrZoneInfo + 16) & 1) != 0 )
      v30 = 0;
    else
      v30 = 2 - (((unsigned __int8)(*((_BYTE *)CPopCycle::m_pCurrZoneInfo + 16) & 0xF) >> 1) & 1);
  }
  else
  {
LABEL_94:
    v30 = -1;
  }
LABEL_95:
  v31 = CPopulation::m_TranslationArray[28][0];
  if ( CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[28][0]] >= 1 )
  {
    v32 = 0;
    do
    {
      v33 = CPopulation::m_PedGroups[v31][v32];
      if ( v30 == v32 )
      {
        CStreaming::RequestModel(v33, 2);
      }
      else
      {
        v34 = v33;
        v35 = &CStreaming::ms_aInfoForModel[v33];
        m_flags = v35->m_flags;
        v35->m_flags = m_flags & 0xFD;
        if ( (m_flags & 4) == 0 )
        {
          if ( CStreaming::ms_aInfoForModel[v33].m_status == 1 )
          {
            if ( (unsigned __int16)v35->m_nextIndex == 0xFFFF )
            {
              v37 = CStreaming::ms_pStartLoadedList;
              v38 = CStreamingInfo::ms_pArrayBase;
              v35->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v39 = -13107 * ((unsigned int)((char *)v35 - (char *)v38) >> 2);
              CStreaming::ms_aInfoForModel[v34].m_prevIndex = -13107 * ((unsigned int)((char *)v37 - (char *)v38) >> 2);
              v37->m_nextIndex = v39;
              CStreamingInfo::ms_pArrayBase[v35->m_nextIndex].m_prevIndex = v39;
            }
          }
          else if ( (m_flags & 8) == 0 )
          {
            CStreaming::RemoveModel(v33);
          }
        }
      }
      v31 = CPopulation::m_TranslationArray[28][0];
      ++v32;
    }
    while ( v32 < CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[28][0]] );
  }
  if ( CStreaming::StreamVehiclesAndPeds(void)::timeBeforeNextLoad >= 0 )
  {
    v40 = CStreaming::StreamVehiclesAndPeds(void)::timeBeforeNextLoad - 1;
LABEL_111:
    CStreaming::StreamVehiclesAndPeds(void)::timeBeforeNextLoad = v40;
    goto LABEL_112;
  }
  if ( CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) <= CStreaming::desiredNumVehiclesLoaded
    && CPopCycle::m_pCurrZoneInfo )
  {
    CStreaming::StreamOneNewCar();
    v40 = 350;
    goto LABEL_111;
  }
LABEL_112:
  if ( CStreaming::m_bStreamHarvesterModelsThisFrame )
  {
    CStreaming::RequestModel(MI_HARVESTERBODYPART1, 2);
    CStreaming::RequestModel(MI_HARVESTERBODYPART2, 2);
    CStreaming::RequestModel(MI_HARVESTERBODYPART3, 2);
    CStreaming::RequestModel(MI_HARVESTERBODYPART4, 2);
    v41 = 1;
LABEL_116:
    CStreaming::m_bHarvesterModelsRequested = v41;
    goto LABEL_117;
  }
  if ( CStreaming::m_bHarvesterModelsRequested )
  {
    CStreaming::RemoveModel(MI_HARVESTERBODYPART1);
    CStreaming::RemoveModel(MI_HARVESTERBODYPART2);
    CStreaming::RemoveModel(MI_HARVESTERBODYPART3);
    CStreaming::RemoveModel(MI_HARVESTERBODYPART4);
    v41 = 0;
    goto LABEL_116;
  }
LABEL_117:
  CStreaming::m_bStreamHarvesterModelsThisFrame = 0;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D193C) --------------------------------------------------------
void __fastcall CStreaming::StreamZoneModels(const CVector *posn)
{
  Int32 v1; // r0
  int32 v2; // r4
  int v3; // r6
  int v4; // r4
  CStreamingInfo *v5; // r12
  int32 v6; // r0
  int32 v7; // r2
  CStreamingInfo *v8; // r1
  uint8 m_flags; // r5
  CStreamingInfo *v10; // r0
  CStreamingInfo *v11; // r11
  unsigned int v12; // r8
  CStreamingInfo *v13; // r5
  int v14; // r8
  __int16 v15; // r0
  int i; // r5
  int32 v17; // r0
  Int32 v18; // r4
  Int32 v19; // r0
  int v20; // r2
  UInt32 *v21; // r9
  _DWORD *v22; // r9
  UInt32 v23; // t1
  int v24; // r10
  int v25; // r11
  int v26; // r5
  int v27; // r6
  int v28; // r4
  UInt16 (*v29)[21]; // r8
  bool v30; // zf
  int32 v31; // r0
  int32 v32; // r12
  CStreamingInfo *v33; // r1
  uint8 v34; // r2
  CStreamingInfo *v35; // r0
  CStreamingInfo *v36; // lr
  bool v37; // zf
  int32 v38; // r0
  int32 v39; // r5
  int32 v40; // r1
  CStreamingInfo *v41; // r0
  uint8 v42; // r3
  CStreamingInfo *v43; // r2
  CStreamingInfo *v44; // r4
  unsigned int v45; // r3
  Int32 *v46; // r0
  int v47; // t1
  int v48; // [sp+10h] [bp-48h]
  Int32 v49; // [sp+14h] [bp-44h]
  _DWORD *v50; // [sp+28h] [bp-30h]
  int v51; // [sp+2Ch] [bp-2Ch]
  unsigned int v52; // [sp+2Ch] [bp-2Ch]
  int v53; // [sp+30h] [bp-28h]

  if ( !CPopCycle::m_pCurrZoneInfo
    || (CCheat::m_aCheatsActive[52] | CCheat::m_aCheatsActive[47] | CCheat::m_aCheatsActive[48] | CCheat::m_aCheatsActive[49] | CCheat::m_aCheatsActive[50] | CCheat::m_aCheatsActive[53] | CCheat::m_aCheatsActive[78] | CCheat::m_aCheatsActive[83]) << 24 )
  {
    return;
  }
  if ( CStreaming::ms_currentZoneType != (*(_WORD *)((char *)CPopCycle::m_pCurrZoneInfo + 15) & 0x1F) )
  {
    v4 = 0;
    v51 = CStreaming::ms_numPedsLoaded;
    v5 = CStreaming::ms_aInfoForModel;
    do
    {
      v6 = CStreaming::ms_pedsLoaded[v4];
      if ( v6 >= 0 )
      {
        v7 = v6;
        v8 = &CStreaming::ms_aInfoForModel[v6];
        m_flags = v8->m_flags;
        v8->m_flags = m_flags & 0xFD;
        if ( (m_flags & 4) == 0 )
        {
          if ( v5[v6].m_status == 1 )
          {
            if ( (unsigned __int16)v8->m_nextIndex == 0xFFFF )
            {
              v10 = CStreaming::ms_pStartLoadedList;
              v11 = CStreamingInfo::ms_pArrayBase;
              v8->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v12 = -858993459 * ((unsigned int)((char *)v8 - (char *)v11) >> 2);
              CStreaming::ms_aInfoForModel[v7].m_prevIndex = -13107 * ((unsigned int)((char *)v10 - (char *)v11) >> 2);
              v10->m_nextIndex = v12;
              CStreamingInfo::ms_pArrayBase[v8->m_nextIndex].m_prevIndex = v12;
            }
          }
          else if ( (m_flags & 8) == 0 )
          {
            v13 = v5;
            CStreaming::RemoveModel(v6);
            v5 = v13;
          }
        }
        CStreaming::ms_pedsLoaded[v4] = -1;
      }
      ++v4;
    }
    while ( v4 != 8 );
    v14 = v51;
    v15 = *(_WORD *)((char *)CPopCycle::m_pCurrZoneInfo + 15);
    CStreaming::ms_numPedsLoaded = 0;
    CStreaming::ms_currentZoneType = v15 & 0x1F;
    if ( v51 <= 4 )
      v14 = 4;
    if ( v14 >= 1 )
    {
      for ( i = 0; i < v14; ++i )
      {
        v17 = CPopCycle::PickPedMIToStreamInForCurrentZone();
        v18 = v17;
        if ( v17 < 0 )
        {
          v18 = -1;
        }
        else
        {
          CStreaming::RequestModel(v17, 10);
          CStreaming::ms_aInfoForModel[v18].m_flags &= ~2u;
          ++CStreaming::ms_numPedsLoaded;
        }
        CStreaming::ms_pedsLoaded[i] = v18;
      }
    }
    v1 = 300;
    timeBeforeNextLoad = 300;
    goto LABEL_41;
  }
  v1 = timeBeforeNextLoad;
  if ( timeBeforeNextLoad > -1 )
  {
LABEL_41:
    v19 = v1 - 1;
LABEL_42:
    timeBeforeNextLoad = v19;
    goto LABEL_43;
  }
  v2 = CStreaming::ms_pedsLoaded[0];
  if ( CStreaming::ms_pedsLoaded[0] == -1 )
  {
    v2 = -1;
    goto LABEL_68;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[0]]->m_numRefs )
  {
LABEL_68:
    v3 = 0;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[1];
  if ( CStreaming::ms_pedsLoaded[1] == -1 )
  {
    v2 = -1;
    goto LABEL_70;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[1]]->m_numRefs )
  {
LABEL_70:
    v3 = 1;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[2];
  if ( CStreaming::ms_pedsLoaded[2] == -1 )
  {
    v2 = -1;
    goto LABEL_72;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[2]]->m_numRefs )
  {
LABEL_72:
    v3 = 2;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[3];
  if ( CStreaming::ms_pedsLoaded[3] == -1 )
  {
    v2 = -1;
    goto LABEL_74;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[3]]->m_numRefs )
  {
LABEL_74:
    v3 = 3;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[4];
  if ( CStreaming::ms_pedsLoaded[4] == -1 )
  {
    v2 = -1;
    goto LABEL_76;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[4]]->m_numRefs )
  {
LABEL_76:
    v3 = 4;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[5];
  if ( CStreaming::ms_pedsLoaded[5] == -1 )
  {
    v2 = -1;
    goto LABEL_78;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[5]]->m_numRefs )
  {
LABEL_78:
    v3 = 5;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[6];
  if ( CStreaming::ms_pedsLoaded[6] == -1 )
  {
    v2 = -1;
    goto LABEL_80;
  }
  if ( !CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[6]]->m_numRefs )
  {
LABEL_80:
    v3 = 6;
    goto LABEL_81;
  }
  v2 = CStreaming::ms_pedsLoaded[7];
  if ( CStreaming::ms_pedsLoaded[7] == -1 )
  {
    v2 = -1;
    v3 = 7;
  }
  else
  {
    if ( CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[7]]->m_numRefs )
      goto LABEL_43;
    v3 = 7;
  }
LABEL_81:
  v38 = CPopCycle::PickPedMIToStreamInForCurrentZone();
  v39 = v38;
  if ( v38 != v2 && v38 >= 0 )
  {
    CStreaming::RequestModel(v38, 10);
    CStreaming::ms_aInfoForModel[v39].m_flags &= ~2u;
    if ( CStreaming::ms_numPedsLoaded == 8 )
    {
      v40 = v2;
      v41 = &CStreaming::ms_aInfoForModel[v2];
      v42 = v41->m_flags;
      v41->m_flags = v42 & 0xFD;
      if ( (v42 & 4) == 0 )
      {
        if ( CStreaming::ms_aInfoForModel[v2].m_status == 1 )
        {
          if ( (unsigned __int16)v41->m_nextIndex == 0xFFFF )
          {
            v43 = CStreaming::ms_pStartLoadedList;
            v44 = CStreamingInfo::ms_pArrayBase;
            v41->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
            v45 = -858993459 * ((unsigned int)((char *)v41 - (char *)v44) >> 2);
            CStreaming::ms_aInfoForModel[v40].m_prevIndex = -13107 * ((unsigned int)((char *)v43 - (char *)v44) >> 2);
            v43->m_nextIndex = v45;
            CStreamingInfo::ms_pArrayBase[v41->m_nextIndex].m_prevIndex = v45;
          }
        }
        else if ( (v42 & 8) == 0 )
        {
          CStreaming::RemoveModel(v2);
        }
      }
      CStreaming::ms_pedsLoaded[v3] = -1;
    }
    else
    {
      ++CStreaming::ms_numPedsLoaded;
    }
    v46 = CStreaming::ms_pedsLoaded;
    do
      v47 = *v46++;
    while ( v47 > -1 );
    *(v46 - 1) = v39;
    v19 = 300;
    goto LABEL_42;
  }
LABEL_43:
  if ( timeBeforeNextGangLoad <= -1 )
  {
    v49 = CurrentGangMemberToLoad;
    v48 = CurrentGangMemberToLoad + 1;
    timeBeforeNextGangLoad = 550;
    v20 = 0;
    CurrentGangMemberToLoad = (CurrentGangMemberToLoad + 1) % 21;
    do
    {
      v53 = v20;
      if ( ((1 << v20) & CStreaming::ms_loadedGangs) != 0 )
      {
        v21 = CPopulation::m_TranslationArray[v20];
        v23 = v21[54];
        v22 = v21 + 54;
        v24 = CPopulation::m_nNumPedsInGroup[v23];
        v25 = v49 % v24;
        v26 = v48 % v24;
        v27 = CurrentGangMemberToLoad % v24;
        v28 = (CurrentGangMemberToLoad + 1) % v24;
        if ( v24 >= 1 )
        {
          v29 = CPopulation::m_PedGroups;
          v50 = v22;
          do
          {
            if ( !v28 )
              goto LABEL_57;
            v30 = v27 == 0;
            if ( v27 )
              v30 = v26 != 0 && v25 != 0;
            if ( v30 )
            {
LABEL_57:
              if ( v26 )
              {
                v37 = v25 == 0;
                if ( v25 )
                  v37 = v28 != 0 && v27 != 0;
                if ( !v37 )
                  CStreaming::RequestModel(v29[*v22][0], 2);
              }
            }
            else
            {
              v31 = v29[*v22][0];
              v32 = v31;
              v33 = &CStreaming::ms_aInfoForModel[v31];
              v34 = v33->m_flags;
              v33->m_flags = v34 & 0xFD;
              if ( (v34 & 4) == 0 )
              {
                if ( CStreaming::ms_aInfoForModel[v31].m_status == 1 )
                {
                  if ( (unsigned __int16)v33->m_nextIndex == 0xFFFF )
                  {
                    v35 = CStreaming::ms_pStartLoadedList;
                    v36 = CStreamingInfo::ms_pArrayBase;
                    v33->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                    v52 = -858993459 * ((unsigned int)((char *)v33 - (char *)v36) >> 2);
                    CStreaming::ms_aInfoForModel[v32].m_prevIndex = -13107
                                                                  * ((unsigned int)((char *)v35 - (char *)v36) >> 2);
                    v35->m_nextIndex = v52;
                    v22 = v50;
                    CStreamingInfo::ms_pArrayBase[v33->m_nextIndex].m_prevIndex = v52;
                  }
                }
                else if ( (v34 & 8) == 0 )
                {
                  CStreaming::RemoveModel(v31);
                }
              }
            }
            v29 = (UInt16 (*)[21])((char *)v29 + 2);
            --v28;
            --v27;
            --v26;
            --v24;
            --v25;
          }
          while ( v24 );
        }
      }
      v20 = v53 + 1;
    }
    while ( v53 != 9 );
  }
  else
  {
    --timeBeforeNextGangLoad;
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D2104) --------------------------------------------------------
void CStreaming::LoadRequestedModels()
{
  _BOOL4 v0; // r1
  int32 v1; // r0
  int32 v2; // r0
  int v3; // r1

  v0 = CStreaming::ms_bLoadingBigModel;
  if ( CStreaming::ms_bLoadingBigModel )
  {
    v1 = 0;
    CStreaming::LoadRequestedModels(void)::currentChannel = 0;
  }
  else
  {
    v1 = CStreaming::LoadRequestedModels(void)::currentChannel;
  }
  if ( CStreaming::ms_channel[v1].status )
  {
    CStreaming::ProcessLoadingChannel(v1);
    v0 = CStreaming::ms_bLoadingBigModel;
  }
  if ( !v0 )
  {
    v2 = CStreaming::LoadRequestedModels(void)::currentChannel;
    if ( CStreaming::ms_channel[1 - CStreaming::LoadRequestedModels(void)::currentChannel].status )
    {
      v3 = 1;
    }
    else
    {
      CStreaming::RequestModelStream(1 - CStreaming::LoadRequestedModels(void)::currentChannel);
      v3 = 0;
      v2 = CStreaming::LoadRequestedModels(void)::currentChannel;
      if ( !CStreaming::ms_bLoadingBigModel )
        v3 = 1;
    }
    if ( CStreaming::ms_channel[v2].status == STATUS_IDLE && v3 == 1 )
      CStreaming::RequestModelStream(v2);
  }
  if ( CStreaming::ms_channel[CStreaming::LoadRequestedModels(void)::currentChannel].status != STATUS_LOADING_LARGEFILE )
    CStreaming::LoadRequestedModels(void)::currentChannel = 1 - CStreaming::LoadRequestedModels(void)::currentChannel;
}

//----- (002D21F8) --------------------------------------------------------
void CStreaming::PurgeRequestList()
{
  int m_prevIndex; // r0
  CStreamingInfo *v1; // r0
  CStreamingInfo *v2; // r1
  int v3; // r2
  CStreamingInfo *v4; // r6

  m_prevIndex = CStreaming::ms_pEndRequestedList->m_prevIndex;
  if ( m_prevIndex == -1 )
    v1 = 0;
  else
    v1 = &CStreamingInfo::ms_pArrayBase[m_prevIndex];
  v2 = CStreaming::ms_pStartRequestedList;
  if ( v1 != CStreaming::ms_pStartRequestedList )
  {
    do
    {
      v3 = (unsigned __int16)v1->m_prevIndex;
      if ( v3 == 0xFFFF )
        v4 = 0;
      else
        v4 = &CStreamingInfo::ms_pArrayBase[(__int16)v3];
      if ( (v1->m_flags & 0x1E) == 0 )
      {
        CStreaming::RemoveModel(-858993459 * (((char *)v1 - (char *)CStreaming::ms_aInfoForModel) >> 2));
        v2 = CStreaming::ms_pStartRequestedList;
      }
      v1 = v4;
    }
    while ( v4 != v2 );
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D22A8) --------------------------------------------------------
void CStreaming::UpdateForAnimViewer()
{
  CVector posn; // [sp+4h] [bp-14h] BYREF

  memset(&posn, 0, sizeof(posn));
  CStreaming::AddModelsToRequestList(&posn, 0);
  CStreaming::LoadRequestedModels();
  sprintf(gString, "Requested %d, memory size %dK\n", CStreaming::ms_numModelsRequested, 2 * CStreaming::ms_memoryUsed);
}

//----- (002D2314) --------------------------------------------------------
void __fastcall CStreaming::RetryLoadFile(int32 ch)
{
  CStreaming::Status *p_status; // r5
  CStreaming::Status v3; // r0
  int Status; // r0
  CStreaming::StreamChannel *v5; // r6

  CPad::StopPadsShaking();
  if ( CStreaming::ms_channelError != -1 )
  {
    CLoadingScreen::Pause();
LABEL_4:
    while ( 2 )
    {
      if ( CStreaming::ms_channelError != -1 )
      {
        p_status = &CStreaming::ms_channel[ch].status;
        v3 = *p_status;
        while ( 1 )
        {
          if ( v3 == STATUS_IDLE )
            goto LABEL_12;
          if ( v3 == STATUS_LOADING )
            break;
          if ( v3 == STATUS_ERROR )
          {
            ++CStreaming::ms_channel[ch].attempts;
            Status = CdStreamGetStatus(ch);
            if ( Status != 250 && (Status != 255 || CdStreamGetStatus(ch) != 255) )
            {
LABEL_12:
              v5 = &CStreaming::ms_channel[ch];
              CdStreamRead(ch, CStreaming::ms_pStreamingBuffer[ch], v5->loadStart, v5->loadSize);
              *p_status = STATUS_LOADING;
              v5->loadTime = -600;
              goto LABEL_4;
            }
            goto LABEL_4;
          }
        }
        if ( !CStreaming::ProcessLoadingChannel(ch) )
          continue;
        if ( *p_status == STATUS_LOADING_LARGEFILE )
          CStreaming::ProcessLoadingChannel(ch);
        CStreaming::ms_channelError = -1;
      }
      break;
    }
  }
  sub_191304();
}

//----- (002D2410) --------------------------------------------------------
bool __fastcall CStreaming::ProcessLoadingChannel(int32 ch)
{
  int Status; // r1
  bool v3; // zf
  bool result; // r0
  int32 *currentLoading; // r5
  _DWORD *v6; // r6
  int32 v7; // r1
  CStreaming::StreamChannel *v8; // r0
  int v9; // r0
  uint8 *v10; // r4
  int32 v11; // r1
  int v12; // r9
  int32 v13; // r6
  uint32 m_cdSize; // r4
  CStreamingInfo *v15; // r1
  uint8 *p_m_flags; // r1
  uint8 m_flags; // t1
  uint32 v18; // r4
  int32 *v19; // r4
  int32 *v20; // r4
  int32 v21; // t1
  bool v22; // zf
  CStreaming::StreamChannel *v23; // [sp+14h] [bp-3Ch]
  _DWORD *v24; // [sp+1Ch] [bp-34h]
  int32 v25; // [sp+2Ch] [bp-24h]

  Status = CdStreamGetStatus(ch);
  v3 = Status == 255;
  result = 0;
  if ( Status != 255 )
    v3 = Status == 250;
  if ( !v3 )
  {
    if ( Status )
    {
      v8 = &CStreaming::ms_channel[ch];
      v8->error = Status;
      v8->status = STATUS_ERROR;
      if ( CStreaming::ms_channelError != -1 )
        return 0;
      CStreaming::ms_channelError = ch;
      CStreaming::RetryLoadFile(ch);
      return 1;
    }
    currentLoading = CStreaming::ms_channel[ch].currentLoading;
    v6 = currentLoading + 32;
    v24 = currentLoading + 32;
    if ( currentLoading[32] == 2 )
    {
      v7 = *currentLoading;
      *v6 = 0;
      CStreaming::FinishLoadingLargeFile(
        &CStreaming::ms_pStreamingBuffer[ch][2048 * CStreaming::ms_channel[ch].bufferOffset[0]],
        v7);
      *currentLoading = -1;
LABEL_28:
      v22 = !CStreaming::ms_bLoadingBigModel;
      if ( CStreaming::ms_bLoadingBigModel )
        v22 = *v24 == 2;
      if ( !v22 )
      {
        CStreaming::ms_bLoadingBigModel = 0;
        memset(&CStreaming::ms_channel[1], 255, 0x40u);
      }
      return 1;
    }
    v23 = &CStreaming::ms_channel[ch];
    v25 = ch;
    v9 = 0;
    *v6 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = v9;
        v13 = v23->currentLoading[v9];
        if ( v13 != -1 )
          break;
LABEL_27:
        v9 = v12 + 1;
        if ( v12 == 15 )
          goto LABEL_28;
      }
      m_cdSize = CStreaming::ms_aInfoForModel[v13].m_cdSize;
      if ( v13 <= 19999
        && (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[v13]->_vptr$CBaseModelInfo + 5))(CModelInfo::ms_modelInfoPtrs[v13]) == 6
        && CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) >= CStreaming::desiredNumVehiclesLoaded
        && !CStreaming::RemoveLoadedVehicle() )
      {
        v15 = &CStreaming::ms_aInfoForModel[v13];
        m_flags = v15->m_flags;
        p_m_flags = &v15->m_flags;
        if ( (m_flags & 6) == 0 )
        {
          v10 = p_m_flags;
          CStreaming::RemoveModel(v13);
          v11 = *v10;
          if ( (v11 & 6) != 0 )
            CStreaming::RequestModel(v13, v11);
          goto LABEL_27;
        }
      }
      if ( (unsigned int)(v13 - 25255) >= 0x100 )
      {
        v18 = m_cdSize << 11;
        while ( CStreaming::ms_memoryUsed >= CStreaming::ms_memoryAvailable - v18 )
        {
          if ( !CStreaming::RemoveLeastUsedModel(0x20u) )
          {
            CStreaming::DeleteRwObjectsBehindCamera(CStreaming::ms_memoryAvailable - v18);
            break;
          }
        }
      }
      emu_ArraysShareResource(1u);
      v19 = &v23->currentLoading[v12];
      v21 = v19[16];
      v20 = v19 + 16;
      CStreaming::ConvertBufferToObject(
        &CStreaming::ms_pStreamingBuffer[v25][2048 * v21],
        v13,
        (int32)CStreaming::ms_pStreamingBuffer);
      emu_ArraysShareResource(0);
      if ( CStreaming::ms_aInfoForModel[v13].m_status == 4 )
      {
        *v24 = 2;
        v23->bufferOffset[0] = *v20;
        v23->currentLoading[0] = v13;
        v9 = 1;
        if ( !v12 )
          continue;
      }
      v23->currentLoading[v12] = -1;
      goto LABEL_27;
    }
  }
  return result;
}

//----- (002D26B8) --------------------------------------------------------
int32 CStreaming::GetDiscInDrive()
{
  int Status; // r4
  CStreaming::Status v1; // r0

  Status = CdStreamGetStatus(0);
  v1 = CStreaming::ms_channel[0].status;
  if ( CStreaming::ms_channel[0].status == STATUS_LOADING )
  {
    CdStreamSync(0);
    CStreaming::ProcessLoadingChannel(0);
    v1 = CStreaming::ms_channel[0].status;
  }
  if ( v1 == STATUS_LOADING_LARGEFILE )
    CStreaming::ProcessLoadingChannel(0);
  if ( Status )
    return -1;
  CdStreamRead(0, CStreaming::ms_pStreamingBuffer[0], 0, 1u);
  return 0;
}

//----- (002D2724) --------------------------------------------------------
void __fastcall CStreaming::ProcessEntitiesInSectorList(CPtrList *list, uint32 reqFlag)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v3; // kr00_8
  int v4; // r0
  int v5; // r1
  int v6; // r3
  int v7; // r1
  _BOOL4 v8; // r2
  _BOOL4 v9; // r3
  bool v10; // zf
  CBaseModelInfo *v11; // r9
  uint8 *v12; // r0

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v3 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v3.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      v4 = *((__int16 *)v3.m_pVoid + 19);
      *((_WORD *)v3.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      if ( CStreaming::ms_aInfoForModel[v4].m_status != 1 )
      {
        v5 = *((_DWORD *)v3.m_pVoid + 7);
        if ( (v5 & 0x400) == 0 )
        {
          v6 = *((unsigned __int8 *)v3.m_pVoid + 51);
          v7 = v5 & 0x80080;
          v8 = CGame::currArea == v6;
          v9 = v6 == 13;
          v10 = v7 == 0x80;
          if ( v7 == 0x80 )
            v10 = v9 || v8;
          if ( v10 )
          {
            v11 = CModelInfo::ms_modelInfoPtrs[v4];
            v12 = (uint8 *)(*((int (__fastcall **)(CBaseModelInfo *, _DWORD, _BOOL4, _BOOL4))v11->_vptr$CBaseModelInfo
                            + 6))(
                             v11,
                             *((_DWORD *)v11->_vptr$CBaseModelInfo + 6),
                             v8,
                             v9);
            if ( !v12 || CClock::GetIsTimeInRange(*v12, v12[1]) )
            {
              if ( v11->m_pRwObject )
              {
                if ( !*((_DWORD *)v3.m_pVoid + 6) )
                  (*(void (__fastcall **)(void *))(*(_DWORD *)v3.m_pVoid + 32))(v3.m_pVoid);
              }
              CStreaming::RequestModel(*((__int16 *)v3.m_pVoid + 19), reqFlag);
            }
          }
        }
      }
    }
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D280C) --------------------------------------------------------
void __fastcall CStreaming::ProcessEntitiesInSectorList(
        CPtrList *list,
        float CenterX,
        float CenterY,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float radius,
        uint32 reqFlag)
{
  float32x2_t v9; // d2
  float32x2_t v10; // d11
  CPtrNode *m_pHead; // r4
  CPtrNode v15; // kr00_8
  int v16; // r0
  int v17; // r1
  int v18; // r3
  unsigned int v19; // r1
  _BOOL4 v20; // r2
  _BOOL4 v21; // r3
  bool v22; // zf
  CBaseModelInfo *v23; // r9
  uint8 *v24; // r0
  int v25; // r1
  float *v26; // r0
  float v27; // s0
  float v28; // s2

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v15 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v15.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      v16 = *((__int16 *)v15.m_pVoid + 19);
      *((_WORD *)v15.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      if ( CStreaming::ms_aInfoForModel[v16].m_status != 1 )
      {
        v17 = *((_DWORD *)v15.m_pVoid + 7);
        if ( (v17 & 0x400) == 0 )
        {
          v18 = *((unsigned __int8 *)v15.m_pVoid + 51);
          v19 = v17 & (unsigned int)"orCreateSubInterpolatorP18RtAnimInterpolatoriii";
          v20 = CGame::currArea == v18;
          v21 = v18 == 13;
          v22 = v19 == 0x80;
          if ( v19 == 0x80 )
            v22 = v21 || v20;
          if ( v22 )
          {
            v23 = CModelInfo::ms_modelInfoPtrs[v16];
            v24 = (uint8 *)(*((int (__fastcall **)(CBaseModelInfo *, _DWORD, _BOOL4, _BOOL4))v23->_vptr$CBaseModelInfo
                            + 6))(
                             v23,
                             *((_DWORD *)v23->_vptr$CBaseModelInfo + 6),
                             v20,
                             v21);
            if ( !v24 || CClock::GetIsTimeInRange(*v24, v24[1]) )
            {
              v25 = *((_DWORD *)v15.m_pVoid + 5);
              v26 = (float *)(v25 + 48);
              if ( !v25 )
                v26 = (float *)((char *)v15.m_pVoid + 4);
              v27 = *v26;
              if ( *v26 > MinX && v27 < MaxX )
              {
                v28 = v26[1];
                if ( v28 > MinY && v28 < MaxY )
                {
                  v9.n64_f32[0] = (float)(v23->m_lodDistance * TheCamera.LODDistMultiplier)
                                * (float)(v23->m_lodDistance * TheCamera.LODDistMultiplier);
                  v10.n64_f32[0] = radius * radius;
                  v9.n64_u64[0] = vmin_f32(v10, v9).n64_u64[0];
                  if ( (float)((float)((float)(CenterX - v27) * (float)(CenterX - v27))
                             + (float)((float)(CenterY - v28) * (float)(CenterY - v28))) < v9.n64_f32[0] )
                  {
                    if ( v23->m_pRwObject )
                    {
                      if ( !*((_DWORD *)v15.m_pVoid + 6) )
                        (*(void (__fastcall **)(void *))(*(_DWORD *)v15.m_pVoid + 32))(v15.m_pVoid);
                    }
                    CStreaming::RequestModel(*((__int16 *)v15.m_pVoid + 19), reqFlag);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
// 2D294A: variable 'v10' is possibly undefined
// 2D294A: variable 'v9' is possibly undefined
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D299C) --------------------------------------------------------
void __fastcall CStreaming::RequestModel(int32 index, int32 flags)
{
  int32 v3; // r6
  uint8 v4; // r4
  CStreamingInfo *v5; // r9
  int m_status; // r0
  CStreamingInfo *v7; // r0
  uint8 *p_m_flags; // r0
  uint8 v9; // r1
  uint8 m_flags; // t1
  CStreamingInfo *v11; // r8
  uint8 v12; // r1
  uint8 *v13; // r8
  uint8 v14; // t1
  int m_nextIndex; // r0
  CStreamingInfo *v16; // r4
  int16 *p_m_prevIndex; // r4
  int16 m_prevIndex; // t1
  CStreamingInfo *v19; // r1
  unsigned int v20; // r3
  unsigned int v21; // r2
  char v22; // r0
  int v23; // r0
  CStreamingInfo *v24; // r0
  CStreamingInfo *v25; // r3
  unsigned int v26; // r2

  v3 = index;
  v4 = flags;
  v5 = &CStreaming::ms_aInfoForModel[index];
  m_status = v5->m_status;
  if ( m_status == 2 )
  {
    if ( (flags & 0x10) != 0 )
    {
      v7 = &CStreaming::ms_aInfoForModel[v3];
      m_flags = v7->m_flags;
      p_m_flags = &v7->m_flags;
      v9 = m_flags;
      if ( (m_flags & 0x10) == 0 )
      {
        *p_m_flags = v9 | 0x10;
        ++CStreaming::ms_numPriorityRequests;
      }
    }
    CStreaming::ms_aInfoForModel[v3].m_flags |= v4;
    return;
  }
  v11 = &CStreaming::ms_aInfoForModel[v3];
  v14 = v11->m_flags;
  v13 = &v11->m_flags;
  v12 = v14;
  if ( v5->m_status )
    v4 &= ~0x10u;
  *v13 = v12 | v4;
  if ( (unsigned int)(m_status - 3) >= 2 )
  {
    if ( m_status )
    {
      if ( m_status == 1 )
      {
        m_nextIndex = v5->m_nextIndex;
        if ( m_nextIndex != -1 )
        {
          v16 = &CStreaming::ms_aInfoForModel[v3];
          m_prevIndex = v16->m_prevIndex;
          p_m_prevIndex = &v16->m_prevIndex;
          CStreamingInfo::ms_pArrayBase[m_nextIndex].m_prevIndex = m_prevIndex;
          CStreamingInfo::ms_pArrayBase[*p_m_prevIndex].m_nextIndex = v5->m_nextIndex;
          v5->m_nextIndex = -1;
          *p_m_prevIndex = -1;
          if ( (index > 19999
             || (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[index]->_vptr$CBaseModelInfo + 5))(CModelInfo::ms_modelInfoPtrs[index]) != 7
             && (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[index]->_vptr$CBaseModelInfo + 5))(CModelInfo::ms_modelInfoPtrs[index]) != 6)
            && (*v13 & 6) == 0 )
          {
            v19 = CStreaming::ms_pStartLoadedList;
            v20 = -858993459
                * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
            v21 = -858993459 * ((unsigned int)((char *)v5 - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
            v5->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
            *p_m_prevIndex = v20;
            v19->m_nextIndex = v21;
            CStreamingInfo::ms_pArrayBase[v5->m_nextIndex].m_prevIndex = v21;
          }
        }
        return;
      }
    }
    else
    {
      if ( (unsigned int)(index - 20000) <= 0x1387 )
      {
        v22 = 1;
LABEL_25:
        v5->m_status = v22;
        return;
      }
      if ( index <= 19999 )
      {
        v23 = (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[index]->_vptr$CBaseModelInfo + 15))(CModelInfo::ms_modelInfoPtrs[index]);
        if ( v23 != -1 )
          CStreaming::RequestModel(v23 + 25575, 8);
      }
      v24 = CStreaming::ms_pStartRequestedList;
      v25 = CStreamingInfo::ms_pArrayBase;
      v5->m_nextIndex = CStreaming::ms_pStartRequestedList->m_nextIndex;
      v26 = -858993459 * ((unsigned int)((char *)v5 - (char *)v25) >> 2);
      CStreaming::ms_aInfoForModel[v3].m_prevIndex = -13107 * ((unsigned int)((char *)v24 - (char *)v25) >> 2);
      v24->m_nextIndex = v26;
      CStreamingInfo::ms_pArrayBase[v5->m_nextIndex].m_prevIndex = v26;
      ++CStreaming::ms_numModelsRequested;
      if ( (v4 & 0x10) != 0 )
        ++CStreaming::ms_numPriorityRequests;
    }
    v22 = 2;
    *v13 = v4;
    goto LABEL_25;
  }
}

//----- (002D2BF8) --------------------------------------------------------
void __fastcall CStreaming::InstanceLoadedModels(const CVector *posn)
{
  int *v1; // r2
  float x; // s0
  float y; // s2
  float v4; // s20
  float v5; // s22
  float v6; // r4
  float v7; // s24
  float v8; // r4
  float v9; // r5
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r2
  int v14; // r0
  int v15; // r4
  int v16; // r0
  int v17; // r5
  CPtrNode *m_pHead; // r6
  CPtrNode v19; // kr00_8
  int v20; // r1
  bool v21; // zf
  CPtrNode *v22; // r6
  CPtrNode v23; // kr08_8
  int v24; // r1
  bool v25; // zf
  CPtrNode *v26; // r5
  CPtrNode v27; // kr10_8
  int v28; // r1
  bool v29; // zf
  int v31; // r2
  int v32; // [sp+4h] [bp-6Ch]
  int v33; // [sp+8h] [bp-68h]
  int v34; // [sp+Ch] [bp-64h]
  int v35; // [sp+20h] [bp-50h]
  int v36; // [sp+24h] [bp-4Ch]

  v1 = dword_2D2DFC;
  x = posn->x;
  y = posn->y;
  if ( CGame::currArea )
    v1 = &dword_2D2DFC[1];
  v4 = x + *(float *)v1;
  v5 = y + *(float *)v1;
  v6 = (float)((float)(y - *(float *)v1) / 50.0) + 60.0;
  v7 = floorf((float)((float)(x - *(float *)v1) / 50.0) + 60.0);
  v8 = floorf(v6);
  v9 = floorf((float)(v4 / 50.0) + 60.0);
  v10 = (int)floorf((float)(v5 / 50.0) + 60.0);
  v11 = (int)v9;
  v12 = (int)v8;
  if ( v10 >= 119 )
    v10 = 119;
  if ( v11 >= 119 )
    v11 = 119;
  v36 = v11;
  v13 = 0;
  if ( v12 <= 0 )
    v12 = 0;
  if ( (int)v7 > 0 )
    v13 = (int)v7;
  v32 = v10;
  v33 = v13;
  v34 = v12;
  if ( v12 <= v10 )
  {
    do
    {
      if ( v33 <= v36 )
      {
        v14 = 119;
        if ( v34 < 119 )
          v14 = v34;
        v15 = v33;
        v35 = 120 * v14;
        do
        {
          v16 = 119;
          if ( v15 < 119 )
            v16 = v15;
          v17 = v16 + v35;
          m_pHead = CWorld::ms_aSectors[v16 + v35].m_buildingPtrListArray.m_pHead;
          while ( m_pHead )
          {
            v19 = *m_pHead;
            m_pHead = m_pHead->m_pNext;
            v20 = *((unsigned __int8 *)v19.m_pVoid + 51);
            v21 = v20 == 13;
            if ( v20 != 13 )
              v21 = CGame::currArea == v20;
            if ( v21 && !*((_DWORD *)v19.m_pVoid + 6) )
              (*(void (__fastcall **)(void *))(*(_DWORD *)v19.m_pVoid + 32))(v19.m_pVoid);
          }
          v22 = CWorld::ms_aRepeatSectors[v15 & 0xF | (unsigned __int8)(16 * v34)].m_ptrListArray[2].m_pHead;
          while ( v22 )
          {
            v23 = *v22;
            v22 = v22->m_pNext;
            v24 = *((unsigned __int8 *)v23.m_pVoid + 51);
            v25 = v24 == 13;
            if ( v24 != 13 )
              v25 = CGame::currArea == v24;
            if ( v25 && !*((_DWORD *)v23.m_pVoid + 6) )
              (*(void (__fastcall **)(void *))(*(_DWORD *)v23.m_pVoid + 32))(v23.m_pVoid);
          }
          v26 = CWorld::ms_aSectors[v17].m_dummyPtrListArray.m_pHead;
          while ( v26 )
          {
            v27 = *v26;
            v26 = v26->m_pNext;
            v28 = *((unsigned __int8 *)v27.m_pVoid + 51);
            v29 = v28 == 13;
            if ( v28 != 13 )
              v29 = CGame::currArea == v28;
            if ( v29 && !*((_DWORD *)v27.m_pVoid + 6) )
              (*(void (__fastcall **)(void *))(*(_DWORD *)v27.m_pVoid + 32))(v27.m_pVoid);
          }
        }
        while ( v15++ < v36 );
      }
      v31 = v34++;
    }
    while ( v31 < v32 );
  }
}
// 2D2DFC: using guessed type int dword_2D2DFC[2];

//----- (002D2E24) --------------------------------------------------------
void __fastcall CStreaming::InstanceLoadedModelsInSectorList(CPtrList *list)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v2; // kr00_8
  int v3; // r1
  bool v4; // zf

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    while ( 1 )
    {
      v2 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v3 = *((unsigned __int8 *)v2.m_pVoid + 51);
      v4 = v3 == 13;
      if ( v3 != 13 )
        v4 = CGame::currArea == v3;
      if ( v4 && !*((_DWORD *)v2.m_pVoid + 6) )
        break;
      if ( !m_pHead )
        return;
    }
    (*(void (__fastcall **)(void *))(*(_DWORD *)v2.m_pVoid + 32))(v2.m_pVoid);
  }
}

//----- (002D2E64) --------------------------------------------------------
bool __fastcall CStreaming::IsObjectInCdImage(int32 index)
{
  return CStreaming::ms_aInfoForModel[index].m_cdSize != 0;
}

//----- (002D2E80) --------------------------------------------------------
void __fastcall CStreaming::RemoveCarModel(Int32 modelId)
{
  CLoadedCarGroup::RemoveMember(&CPopulation::m_AppropriateLoadedCars, modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_InAppropriateLoadedCars, modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedBoats, modelId);
  CLoadedCarGroup::RemoveMember(CPopulation::m_LoadedGangCars, modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[1], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[2], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[3], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[4], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[5], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[6], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[7], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[8], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[9], modelId);
  CLoadedCarGroup::RemoveMember(&CPopulation::m_LoadedGangCars[10], modelId);
  CLoadedCarGroup::RemoveMember(&CStreaming::ms_vehiclesLoaded, modelId);
  sub_19D648(modelId);
}

//----- (002D2F48) --------------------------------------------------------
void __fastcall CStreaming::RequestVehicleUpgrade(int32 modelId, int32 flags)
{
  int16 v3; // r5
  int32 OtherUpgrade; // r0

  v3 = modelId;
  CStreaming::RequestModel(modelId, flags);
  OtherUpgrade = CVehicleModelInfo::CLinkedUpgradeList::FindOtherUpgrade(&CVehicleModelInfo::ms_linkedUpgrades, v3);
  if ( OtherUpgrade != -1 )
    CStreaming::RequestModel(OtherUpgrade, flags);
}

//----- (002D2F74) --------------------------------------------------------
bool __fastcall CStreaming::HasVehicleUpgradeLoaded(int32 modelId)
{
  int m_status; // r0
  int OtherUpgrade; // r0

  if ( CStreaming::ms_aInfoForModel[modelId].m_status == 1 )
  {
    OtherUpgrade = CVehicleModelInfo::CLinkedUpgradeList::FindOtherUpgrade(
                     &CVehicleModelInfo::ms_linkedUpgrades,
                     modelId);
    if ( OtherUpgrade == -1 )
    {
      LOBYTE(m_status) = 1;
    }
    else
    {
      m_status = CStreaming::ms_aInfoForModel[OtherUpgrade].m_status;
      if ( m_status != 1 )
        LOBYTE(m_status) = 0;
    }
  }
  else
  {
    LOBYTE(m_status) = 0;
  }
  return m_status;
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D2FD0) --------------------------------------------------------
bool __fastcall CStreaming::ConvertBufferToObject(unsigned __int8 *pBuffer, int32 index, int32 ch)
{
  int32 v5; // r9
  CStreamingInfo *v6; // r10
  uint32 *p_m_cdSize; // r8
  Int32 v8; // r5
  RwStream_0 *v9; // r11
  CBaseModelInfo *v10; // r6
  int v11; // r0
  bool v12; // zf
  int32 v13; // r10
  char v14; // r0
  char v15; // r3
  int v16; // r5
  RwStream_0 *v17; // r8
  int32 m_txdIndex; // r11
  const unsigned __int8 *v19; // r1
  RtDict_0 *Dict; // r11
  _BOOL4 ClumpFile; // r0
  _BOOL4 AtomicFile; // r5
  RwStream_0 *v23; // r0
  int v24; // r0
  uint8 *p_m_flags; // r1
  char v26; // r2
  CStreamingInfo *v27; // r0
  CStreamingInfo *v28; // r3
  unsigned int v29; // r6
  int m_nextIndex; // r0
  bool result; // r0
  unsigned int v32; // r6
  CStreamingInfo *v33; // r0
  CStreamingInfo *v34; // r3
  CStreamingInfo *v35; // r1
  uint8 *p_m_status; // r1
  int m_status; // t1
  int v38; // [sp+Ch] [bp-44h]
  CStreamingInfo *v39; // [sp+10h] [bp-40h]
  uint32 *v40; // [sp+14h] [bp-3Ch]
  RwChunkHeaderInfo_0 chunkHeaderInfo; // [sp+18h] [bp-38h] BYREF
  int pData[9]; // [sp+2Ch] [bp-24h] BYREF

  v5 = index;
  pData[0] = (int)pBuffer;
  v6 = &CStreaming::ms_aInfoForModel[index];
  p_m_cdSize = &v6->m_cdSize;
  v8 = v6->m_cdSize << 11;
  pData[1] = v8;
  v9 = _rwStreamInitialize(&gStreamingStream, 0, 0x100000003LL, (RwUInt32)pData);
  if ( index > 19999 )
  {
    if ( (unsigned int)(index - 25000) > 0xFE )
    {
      if ( (unsigned int)(index - 25255) > 0xFF )
      {
        if ( (unsigned int)(index - 25511) > 0x3F )
        {
          v32 = index - 25575;
          if ( (unsigned int)(index - 25575) > 0xB3 )
          {
            if ( (unsigned int)(index - 25755) > 0x1DA )
            {
              if ( index < 26230 )
              {
                RwStreamClose(v9, pData);
                if ( index < 25000 )
                {
LABEL_63:
                  if ( (CStreaming::ms_aInfoForModel[v5].m_flags & 6) != 0 )
                    goto LABEL_66;
                  v33 = CStreaming::ms_pStartLoadedList;
                  v34 = CStreamingInfo::ms_pArrayBase;
                  v6->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                  v29 = -858993459 * ((unsigned int)((char *)v6 - (char *)v34) >> 2);
                  CStreaming::ms_aInfoForModel[v5].m_prevIndex = -13107
                                                               * ((unsigned int)((char *)v33 - (char *)v34) >> 2);
                  v33->m_nextIndex = v29;
                  m_nextIndex = v6->m_nextIndex;
                  goto LABEL_65;
                }
LABEL_61:
                if ( index <= 26229 && v32 > 0xB3 )
                  goto LABEL_66;
                goto LABEL_63;
              }
              CStreamedScripts::LoadStreamedScript(&CTheScripts::StreamedScripts, v9, index - 26230);
            }
            else
            {
              CVehicleRecording::Load(v9, index - 25755, v8);
            }
          }
          else
          {
            if ( (CStreaming::ms_aInfoForModel[v5].m_flags & 0xE) == 0
              && !CStreaming::AreAnimsUsedByRequestedModels(index - 25575) )
            {
              CStreaming::RemoveModel(index);
              goto LABEL_51;
            }
            CAnimManager::LoadAnimFile(v9, 1, 0);
            CAnimManager::CreateAnimAssocGroups();
          }
        }
        else
        {
          CPathFind::LoadPathFindData(&ThePaths, v9, index - 25511);
        }
      }
      else if ( !CIplStore::LoadIpl(index - 25255, pBuffer, v8) )
      {
        goto LABEL_14;
      }
    }
    else if ( !CColStore::LoadCol(index - 25000, pBuffer, v8) )
    {
      goto LABEL_14;
    }
    RwStreamClose(v9, pData);
    v32 = index - 25575;
    goto LABEL_61;
  }
  v39 = v6;
  v10 = CModelInfo::ms_modelInfoPtrs[index];
  v11 = (*((int (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 15))(v10);
  v12 = index == 16757;
  if ( index != 16757 )
    v12 = index == 17003;
  v13 = v11;
  v14 = 1;
  if ( !v12 && index != 17198 )
    v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( index == 13675 )
    v15 = 1;
  modelNightBoost = v14;
  modelForceColorAlpha = v15;
  if ( v13 != -1 )
  {
    if ( CAnimManager::ms_aAnimBlocks[v13].m_loaded )
    {
      v40 = p_m_cdSize;
      v17 = v9;
      CAnimManager::AddAnimBlockRef(v13);
      v16 = 1;
      goto LABEL_19;
    }
LABEL_14:
    CStreaming::RemoveModel(index);
LABEL_50:
    CStreaming::RequestModel(index, CStreaming::ms_aInfoForModel[v5].m_flags);
LABEL_51:
    RwStreamClose(v9, pData);
    return 0;
  }
  v40 = p_m_cdSize;
  v17 = v9;
LABEL_19:
  m_txdIndex = v10->m_txdIndex;
  v38 = v16;
  if ( *v40 )
  {
    strcpy(
      (char *)CStreaming::GetModelCDName(int)::name,
      (const char *)gCdImageNames
    + (((CStreaming::ms_aInfoForModel[v5].m_cdPosn + CStreaming::ms_files[CStreaming::ms_aInfoForModel[v5].m_image].m_lsn) >> 18) & 0x3FC0));
    CStreaming::GetModelCDName(int)::name[strlen((const char *)CStreaming::GetModelCDName(int)::name) - 4] = 0;
    (*((void (__fastcall **)(unsigned __int8 *))RwEngineInstance + 72))(CStreaming::GetModelCDName(int)::name);
    v19 = (const unsigned __int8 *)(strchr((const char *)CStreaming::GetModelCDName(int)::name, 92) + 1);
  }
  else
  {
    v19 = (const unsigned __int8 *)&off_2D3474;
  }
  CTxdStore::SetCurrentTxd(m_txdIndex, v19);
  if ( (*((int (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 10))(v10) == 1 )
  {
    RwStreamReadChunkHeaderInfo(v17, &chunkHeaderInfo);
    if ( chunkHeaderInfo.type == 43 )
    {
      Dict = RtDictSchemaStreamReadDict(&rpUVAnimDictSchema, v17);
      RtDictSchemaSetCurrentDict(&rpUVAnimDictSchema, Dict);
    }
    else
    {
      Dict = 0;
    }
    RwStreamClose(v17, pData);
    v23 = _rwStreamInitialize(&gStreamingStream, 0, 0x100000003LL, (RwUInt32)pData);
    AtomicFile = CFileLoader::LoadAtomicFile(v23, index);
    if ( Dict )
      RtDictDestroy(Dict);
    v9 = v17;
    p_m_cdSize = v40;
  }
  else
  {
    (*((void (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 5))(v10);
    v9 = v17;
    ClumpFile = CFileLoader::LoadClumpFile(v17, index);
    p_m_cdSize = v40;
    AtomicFile = ClumpFile;
  }
  if ( CStreaming::ms_aInfoForModel[v5].m_status == 4 )
  {
    if ( !AtomicFile )
    {
LABEL_49:
      CStreaming::RemoveModel(index);
      goto LABEL_50;
    }
  }
  else
  {
    if ( v38 == 1 )
      CAnimManager::RemoveAnimBlockRefWithoutDelete(v13);
    if ( !AtomicFile )
      goto LABEL_49;
    if ( (*((int (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 5))(v10) == 6 )
      CStreaming::AddToLoadedVehiclesList(index);
  }
  RwStreamClose(v9, pData);
  if ( (*((int (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 5))(v10) != 6
    && (*((int (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 5))(v10) != 7 )
  {
    v24 = (*((int (__fastcall **)(CBaseModelInfo *))v10->_vptr$CBaseModelInfo + 2))(v10);
    p_m_flags = &CStreaming::ms_aInfoForModel[v5].m_flags;
    if ( v24 )
    {
      v26 = *p_m_flags & 0x24;
      if ( v26 )
        v26 = -1;
      *(_BYTE *)(v24 + 34) = v26;
    }
    if ( (*p_m_flags & 6) == 0 )
    {
      v27 = CStreaming::ms_pStartLoadedList;
      v28 = CStreamingInfo::ms_pArrayBase;
      v39->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
      v29 = -858993459 * ((unsigned int)((char *)v39 - (char *)v28) >> 2);
      CStreaming::ms_aInfoForModel[v5].m_prevIndex = -13107 * ((unsigned int)((char *)v27 - (char *)v28) >> 2);
      v27->m_nextIndex = v29;
      m_nextIndex = v39->m_nextIndex;
LABEL_65:
      CStreamingInfo::ms_pArrayBase[m_nextIndex].m_prevIndex = v29;
    }
  }
LABEL_66:
  v35 = &CStreaming::ms_aInfoForModel[v5];
  result = 1;
  m_status = v35->m_status;
  p_m_status = &v35->m_status;
  if ( m_status != 4 )
  {
    *p_m_status = 1;
    CStreaming::ms_memoryUsed += *p_m_cdSize << 11;
  }
  return result;
}
// 2D3474: using guessed type void *off_2D3474;

//----- (002D34B4) --------------------------------------------------------
bool __fastcall CStreaming::AddToLoadedVehiclesList(Int32 MI)
{
  int v2; // r1
  CLoadedCarGroup **v3; // r0
  int v4; // r6
  UInt16 *v5; // r5
  int v6; // r0
  int v7; // r1

  LOBYTE(CModelInfo::ms_modelInfoPtrs[MI][1].m_lodDistance) = 0;
  if ( CPopulation::m_nNumCarsInGroup[29] < 1 )
  {
LABEL_5:
    if ( CStreaming::IsCarModelNeededInCurrentZone(MI) )
      v3 = &CPopulation::m_AppropriateLoadedCars;
    else
      v3 = &CPopulation::m_InAppropriateLoadedCars;
  }
  else
  {
    v2 = 0;
    while ( CPopulation::m_CarGroups[29][v2] != MI )
    {
      if ( ++v2 >= CPopulation::m_nNumCarsInGroup[29] )
        goto LABEL_5;
    }
    v3 = &CPopulation::m_LoadedBoats;
  }
  CLoadedCarGroup::AddMember(*v3, MI);
  v4 = 0;
  v5 = CPopulation::m_CarGroups[18];
  do
  {
    v6 = CPopulation::m_nNumCarsInGroup[v4 + 18];
    if ( v6 >= 1 )
    {
      v7 = 0;
      while ( v5[v7] != MI )
      {
        if ( ++v7 >= v6 )
          goto LABEL_16;
      }
      CLoadedCarGroup::AddMember(&CPopulation::m_LoadedGangCars[v4], MI);
    }
LABEL_16:
    ++v4;
    v5 += 23;
  }
  while ( v4 != 10 );
  CLoadedCarGroup::AddMember(&CStreaming::ms_vehiclesLoaded, MI);
  return 1;
}
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;
// 679EA4: using guessed type CLoadedCarGroup *CPopulation::m_InAppropriateLoadedCars;
// 679EBC: using guessed type CLoadedCarGroup *CPopulation::m_LoadedBoats;

//----- (002D35A4) --------------------------------------------------------
bool __fastcall CStreaming::AreAnimsUsedByRequestedModels(int32 index)
{
  CStreamingInfo *v2; // r4
  int m_nextIndex; // r0
  int v4; // r0
  int v5; // r4
  int v6; // r0
  int v7; // r0

  v2 = CStreaming::ms_pStartRequestedList;
  while ( 1 )
  {
    m_nextIndex = v2->m_nextIndex;
    v2 = m_nextIndex == -1 ? 0 : &CStreamingInfo::ms_pArrayBase[m_nextIndex];
    if ( v2 == CStreaming::ms_pEndRequestedList )
      break;
    if ( (char *)v2 - (char *)CStreaming::ms_aInfoForModel <= (int)&stru_61A7C.st_name + 3
      && (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[214748365
                                                                              * ((unsigned int)((char *)v2
                                                                                              - (char *)CStreaming::ms_aInfoForModel) >> 2)]->_vptr$CBaseModelInfo
          + 15))(CModelInfo::ms_modelInfoPtrs[214748365
                                            * ((unsigned int)((char *)v2 - (char *)CStreaming::ms_aInfoForModel) >> 2)]) == index )
    {
      return 1;
    }
  }
  v4 = 0;
  while ( 1 )
  {
    v5 = v4;
    v6 = CStreaming::ms_channel[0].currentLoading[v4];
    if ( v6 != -1
      && v6 <= 19999
      && (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[v6]->_vptr$CBaseModelInfo + 15))(CModelInfo::ms_modelInfoPtrs[v6]) == index )
    {
      break;
    }
    v7 = CStreaming::ms_channel[1].currentLoading[v5];
    if ( v7 != -1
      && v7 <= 19999
      && (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[v7]->_vptr$CBaseModelInfo + 15))(CModelInfo::ms_modelInfoPtrs[v7]) == index )
    {
      break;
    }
    v4 = v5 + 1;
    if ( v5 >= 15 )
      return 0;
  }
  return 1;
}
// 61A7C: using guessed type Elf32_Sym stru_61A7C;

//----- (002D36B0) --------------------------------------------------------
bool __fastcall CStreaming::FinishLoadingLargeFile(unsigned __int8 *pBuffer, int32 index)
{
  int Txd; // r10
  int32 v4; // r9
  CStreamingInfo *v5; // r6
  uint8 *p_m_status; // r6
  int m_status; // t1
  CStreamingInfo *v8; // r11
  uint32 *p_m_cdSize; // r11
  uint32 m_cdSize; // t1
  RwStream_0 *v11; // r8
  CBaseModelInfo *v12; // r5
  _BOOL4 ClumpFile; // r10
  int32 v14; // r0
  bool result; // r0
  int pData[9]; // [sp+4h] [bp-24h] BYREF

  v4 = index;
  v5 = &CStreaming::ms_aInfoForModel[index];
  m_status = v5->m_status;
  p_m_status = &v5->m_status;
  if ( m_status != 4 )
  {
    if ( index <= 19999 )
      CBaseModelInfo::RemoveRef(CModelInfo::ms_modelInfoPtrs[index]);
    return 0;
  }
  pData[0] = (int)pBuffer;
  v8 = &CStreaming::ms_aInfoForModel[index];
  m_cdSize = v8->m_cdSize;
  p_m_cdSize = &v8->m_cdSize;
  pData[1] = m_cdSize << 11;
  v11 = _rwStreamInitialize(&gStreamingStream, 0, 0x100000003LL, (RwUInt32)pData);
  if ( index > 19999 )
  {
    if ( index <= 24999 )
    {
      CTxdStore::AddRef(index - 20000);
      Txd = CTxdStore::FinishLoadTxd(index - 20000, v11);
      CTxdStore::RemoveRefWithoutDelete(index - 20000);
    }
  }
  else
  {
    v12 = CModelInfo::ms_modelInfoPtrs[index];
    CTxdStore::SetCurrentTxd(v12->m_txdIndex, 0);
    ClumpFile = CFileLoader::FinishLoadClumpFile(v11, index);
    if ( ClumpFile )
    {
      CStreaming::AddToLoadedVehiclesList(index);
      ClumpFile = 1;
    }
    CBaseModelInfo::RemoveRef(v12);
    CTxdStore::RemoveRefWithoutDelete(v12->m_txdIndex);
    Txd = ClumpFile;
    if ( (*((int (__fastcall **)(CBaseModelInfo *))v12->_vptr$CBaseModelInfo + 15))(v12) != -1 )
    {
      v14 = (*((int (__fastcall **)(CBaseModelInfo *))v12->_vptr$CBaseModelInfo + 15))(v12);
      CAnimManager::RemoveAnimBlockRefWithoutDelete(v14);
    }
  }
  RwStreamClose(v11, pData);
  result = 1;
  *p_m_status = 1;
  CStreaming::ms_memoryUsed += *p_m_cdSize << 11;
  if ( !(Txd << 31) )
  {
    CStreaming::RemoveModel(index);
    CStreaming::RequestModel(index, CStreaming::ms_aInfoForModel[v4].m_flags);
    return 0;
  }
  return result;
}
// 2D37C0: variable 'Txd' is possibly undefined

//----- (002D3804) --------------------------------------------------------
int CStreaming::RemoveLoadedVehicle()
{
  Int32 v0; // r4
  int32 Member; // r0
  Int32 v2; // r4
  Int32 v3; // r4
  Int32 v4; // r4
  CLoadedCarGroup v6; // [sp+0h] [bp-48h] BYREF

  if ( CLoadedCarGroup::CountMembers(&CPopulation::m_InAppropriateLoadedCars) >= 1 )
  {
    v0 = 0;
    do
    {
      Member = CLoadedCarGroup::GetMember(&CPopulation::m_InAppropriateLoadedCars, v0);
      if ( !CModelInfo::ms_modelInfoPtrs[Member]->m_numRefs
        && (CStreaming::ms_aInfoForModel[Member].m_flags & 6) == 0
        && CStreaming::ms_aInfoForModel[Member].m_status == 1 )
      {
        goto LABEL_24;
      }
    }
    while ( ++v0 < CLoadedCarGroup::CountMembers(&CPopulation::m_InAppropriateLoadedCars) );
  }
  v2 = CStreaming::m_bBoatsNeeded;
  if ( CStreaming::m_bBoatsNeeded )
    v2 = 2;
  if ( CLoadedCarGroup::CountMembers(&CPopulation::m_LoadedBoats) > v2
    && CLoadedCarGroup::CountMembers(&CPopulation::m_LoadedBoats) >= 1 )
  {
    v3 = 0;
    do
    {
      Member = CLoadedCarGroup::GetMember(&CPopulation::m_LoadedBoats, v3);
      if ( !CModelInfo::ms_modelInfoPtrs[Member]->m_numRefs
        && (CStreaming::ms_aInfoForModel[Member].m_flags & 6) == 0
        && CStreaming::ms_aInfoForModel[Member].m_status == 1 )
      {
        goto LABEL_24;
      }
    }
    while ( ++v3 < CLoadedCarGroup::CountMembers(&CPopulation::m_LoadedBoats) );
  }
  *(_QWORD *)&v6.aMembers[15] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[15];
  *(_QWORD *)&v6.aMembers[19] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[19];
  *(_QWORD *)v6.aMembers = *(_QWORD *)CPopulation::m_AppropriateLoadedCars.aMembers;
  *(_QWORD *)&v6.aMembers[4] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[4];
  *(_QWORD *)&v6.aMembers[8] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[8];
  *(_QWORD *)&v6.aMembers[12] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[12];
  CLoadedCarGroup::SortBasedOnUsage(&v6);
  if ( CLoadedCarGroup::CountMembers(&v6) >= 1 )
  {
    v4 = 0;
    while ( 1 )
    {
      Member = CLoadedCarGroup::GetMember(&v6, v4);
      if ( !CModelInfo::ms_modelInfoPtrs[Member]->m_numRefs
        && (CStreaming::ms_aInfoForModel[Member].m_flags & 6) == 0
        && CStreaming::ms_aInfoForModel[Member].m_status == 1 )
      {
        break;
      }
      if ( ++v4 >= CLoadedCarGroup::CountMembers(&v6) )
        return 0;
    }
LABEL_24:
    CStreaming::RemoveModel(Member);
    return 1;
  }
  return 0;
}

//----- (002D39E4) --------------------------------------------------------
void __fastcall CStreaming::MakeSpaceFor(int32 bytes)
{
  while ( CStreaming::ms_memoryUsed >= CStreaming::ms_memoryAvailable - bytes )
  {
    if ( !CStreaming::RemoveLeastUsedModel(0x20u) )
    {
      CStreaming::DeleteRwObjectsBehindCamera(CStreaming::ms_memoryAvailable - bytes);
      return;
    }
  }
}

//----- (002D3A38) --------------------------------------------------------
int32 __fastcall CStreaming::GetNextFileOnCd(int32 cdPosn, int bUsePriority)
{
  int v3; // r1
  int v4; // r6
  int m_nextIndex; // r0
  CStreamingInfo *v6; // r4
  uint32 v7; // r2
  CStreamingInfo *v8; // r0
  int v9; // r1
  int32 v10; // r1
  int v11; // r0
  int v12; // r11
  int v13; // r0
  int32 v14; // r0
  int v15; // r0
  int v16; // r3
  uint32 v17; // r0
  uint32 v18; // r2
  uint32 v21; // [sp+28h] [bp-40h]
  unsigned int v22; // [sp+2Ch] [bp-3Ch]
  int v23; // [sp+30h] [bp-38h]

  while ( 2 )
  {
    m_nextIndex = (unsigned __int16)CStreaming::ms_pStartRequestedList->m_nextIndex;
    if ( m_nextIndex == 0xFFFF )
      v6 = 0;
    else
      v6 = &CStreamingInfo::ms_pArrayBase[(__int16)m_nextIndex];
    if ( v6 == CStreaming::ms_pEndRequestedList )
    {
      v3 = -1;
      v4 = -1;
      goto LABEL_3;
    }
    v7 = -1;
    v4 = -1;
    v3 = -1;
    v22 = -1;
    do
    {
      v21 = v7;
      v23 = v3;
      while ( 1 )
      {
        v8 = v6;
        v9 = (unsigned __int16)v6->m_nextIndex;
        if ( v9 == 0xFFFF )
          v6 = 0;
        else
          v6 = &CStreamingInfo::ms_pArrayBase[(__int16)v9];
        v10 = CStreaming::ms_numPriorityRequests;
        if ( CStreaming::ms_numPriorityRequests )
          v10 = 1;
        if ( (bUsePriority & v10) != 0 && (v8->m_flags & 0x10) == 0 )
          goto LABEL_29;
        v11 = (char *)v8 - (char *)CStreaming::ms_aInfoForModel;
        v12 = -858993459 * (v11 >> 2);
        if ( v11 > 399999 )
          break;
        v13 = (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[214748365 * (v11 >> 2)]->_vptr$CBaseModelInfo
               + 15))(CModelInfo::ms_modelInfoPtrs[214748365 * (v11 >> 2)]);
        if ( v13 == -1 )
          goto LABEL_34;
        v14 = v13 + 25575;
LABEL_27:
        if ( (CStreaming::ms_aInfoForModel[v14].m_status | 2) == 3 )
          goto LABEL_34;
        CStreaming::RequestModel(v14, 8);
LABEL_29:
        if ( v6 == CStreaming::ms_pEndRequestedList )
        {
          v3 = v23;
          goto LABEL_3;
        }
      }
      if ( v11 <= 499999 )
      {
        v15 = *(unsigned __int16 *)&(*CTxdStore::ms_pTxdPool->m_aStorage)[-858993448 * (v11 >> 2) - 1119994];
        if ( v15 == 0xFFFF )
          goto LABEL_34;
        v14 = (__int16)v15 + 20000;
        goto LABEL_27;
      }
      if ( (unsigned int)(v11 - 511481) <= 0xE22
        && (CCutsceneMgr::ms_cutsceneProcessing || CStreaming::ms_aInfoForModel[7].m_status != 1) )
      {
        goto LABEL_29;
      }
LABEL_34:
      v16 = 0;
      v17 = *(&CStreaming::ms_aInfoForModel[0].m_cdPosn + 5 * v12)
          + CStreaming::ms_files[*(&CStreaming::ms_aInfoForModel[0].m_image + 20 * v12)].m_lsn;
      v18 = v22;
      if ( v17 >= v22 )
        v16 = 1;
      if ( !((v17 < cdPosn) | v16) )
        v18 = *(&CStreaming::ms_aInfoForModel[0].m_cdPosn + 5 * v12)
            + CStreaming::ms_files[*(&CStreaming::ms_aInfoForModel[0].m_image + 20 * v12)].m_lsn;
      v3 = v23;
      v22 = v18;
      if ( !((v17 < cdPosn) | v16) )
        v3 = v12;
      v7 = v21;
      if ( v17 < v21 )
      {
        v4 = v12;
        v7 = *(&CStreaming::ms_aInfoForModel[0].m_cdPosn + 5 * v12)
           + CStreaming::ms_files[*(&CStreaming::ms_aInfoForModel[0].m_image + 20 * v12)].m_lsn;
      }
    }
    while ( v6 != CStreaming::ms_pEndRequestedList );
LABEL_3:
    if ( v3 != -1 )
      v4 = v3;
    if ( v4 == -1 && CStreaming::ms_numPriorityRequests )
    {
      bUsePriority = 0;
      CStreaming::ms_numPriorityRequests = 0;
      continue;
    }
    return v4;
  }
}

//----- (002D3CD0) --------------------------------------------------------
int32 __fastcall CStreaming::GetCdImageOffset(int32 cdPosn)
{
  unsigned int v1; // r1
  unsigned int v2; // lr
  uint32 v3; // r4
  bool v4; // cc
  int v5; // r1
  uint32 v6; // r2
  signed int v7; // r4
  bool v8; // cc
  signed int v9; // r4
  bool v10; // cc
  signed int v11; // r4
  bool v12; // cc
  signed int v13; // r4
  bool v14; // cc
  signed int v15; // r5
  bool v16; // cc
  signed int v17; // r3
  signed int v18; // r3
  signed int v19; // r1
  signed int v20; // r3
  signed int v21; // r1
  signed int v22; // r5
  uint32 v23; // r0

  v1 = CStreaming::ms_imageOffsets[CStreaming::ms_lastImageRead];
  if ( v1 >= cdPosn || CStreaming::ms_imageSize + v1 < cdPosn )
  {
    if ( !CFileMgr::ms_dualLayer )
    {
      v2 = CStreaming::ms_imageOffsets[0];
      v5 = 0x7FFFFFFF;
      if ( CStreaming::ms_imageOffsets[0] != -1 )
      {
LABEL_81:
        v17 = v2 - cdPosn;
        if ( cdPosn > v2 )
          v17 = cdPosn - v2 - CStreaming::ms_imageSize;
        v6 = 0;
        if ( v17 < v5 )
          v5 = v17;
        else
          v6 = -1;
        goto LABEL_86;
      }
LABEL_27:
      v6 = -1;
LABEL_86:
      if ( CStreaming::ms_imageOffsets[1] == -1 )
      {
        v18 = v5;
      }
      else
      {
        v18 = CStreaming::ms_imageOffsets[1] - cdPosn;
        if ( cdPosn > CStreaming::ms_imageOffsets[1] )
          v18 = cdPosn - CStreaming::ms_imageOffsets[1] - CStreaming::ms_imageSize;
        if ( v18 >= v5 )
          v18 = v5;
        else
          v6 = 1;
      }
      if ( CStreaming::ms_imageOffsets[2] == -1 )
      {
        v19 = v18;
      }
      else
      {
        v19 = CStreaming::ms_imageOffsets[2] - cdPosn;
        if ( cdPosn > CStreaming::ms_imageOffsets[2] )
          v19 = cdPosn - CStreaming::ms_imageOffsets[2] - CStreaming::ms_imageSize;
        if ( v19 >= v18 )
          v19 = v18;
        else
          v6 = 2;
      }
      if ( CStreaming::ms_imageOffsets[3] == -1 )
      {
        v20 = v19;
      }
      else
      {
        v20 = CStreaming::ms_imageOffsets[3] - cdPosn;
        if ( cdPosn > CStreaming::ms_imageOffsets[3] )
          v20 = cdPosn - CStreaming::ms_imageOffsets[3] - CStreaming::ms_imageSize;
        if ( v20 >= v19 )
          v20 = v19;
        else
          v6 = 3;
      }
      if ( CStreaming::ms_imageOffsets[4] == -1 )
      {
        v21 = v20;
      }
      else
      {
        v21 = CStreaming::ms_imageOffsets[4] - cdPosn;
        if ( cdPosn > CStreaming::ms_imageOffsets[4] )
          v21 = cdPosn - CStreaming::ms_imageOffsets[4] - CStreaming::ms_imageSize;
        if ( v21 >= v20 )
          v21 = v20;
        else
          v6 = 4;
      }
      if ( CStreaming::ms_imageOffsets[5] != -1 )
      {
        v22 = CStreaming::ms_imageOffsets[5] - cdPosn;
        v4 = cdPosn > CStreaming::ms_imageOffsets[5];
        v23 = cdPosn - CStreaming::ms_imageOffsets[5];
        if ( v4 )
          v22 = v23 - CStreaming::ms_imageSize;
        if ( v22 < v21 )
          v6 = 5;
      }
      goto LABEL_119;
    }
    v2 = CStreaming::ms_imageOffsets[0];
    if ( CStreaming::ms_imageOffsets[0] == -1 )
      goto LABEL_14;
    v3 = CStreaming::ms_imageOffsets[0] - cdPosn;
    if ( cdPosn > CStreaming::ms_imageOffsets[0] )
      v3 = cdPosn - CStreaming::ms_imageOffsets[0] - CStreaming::ms_imageSize;
    v4 = CFileMgr::ms_layerStart > cdPosn;
    if ( CFileMgr::ms_layerStart > cdPosn )
      v4 = CStreaming::ms_imageOffsets[0] > CFileMgr::ms_layerStart;
    if ( v4 )
    {
LABEL_14:
      v5 = 0x7FFFFFFF;
    }
    else
    {
      v5 = 0x7FFFFFFF;
      if ( CFileMgr::ms_layerStart < cdPosn )
      {
        v6 = -1;
        if ( v3 == 0x7FFFFFFF || CStreaming::ms_imageOffsets[0] < CFileMgr::ms_layerStart )
          goto LABEL_16;
        goto LABEL_29;
      }
      if ( v3 != 0x7FFFFFFF )
      {
LABEL_29:
        v6 = 0;
        v5 = v3;
        goto LABEL_16;
      }
    }
    v6 = -1;
LABEL_16:
    if ( CStreaming::ms_imageOffsets[1] != -1 )
    {
      v7 = CStreaming::ms_imageOffsets[1] - cdPosn;
      if ( cdPosn > CStreaming::ms_imageOffsets[1] )
        v7 = cdPosn - CStreaming::ms_imageOffsets[1] - CStreaming::ms_imageSize;
      v8 = CFileMgr::ms_layerStart > cdPosn;
      if ( CFileMgr::ms_layerStart > cdPosn )
        v8 = CStreaming::ms_imageOffsets[1] > CFileMgr::ms_layerStart;
      if ( !v8 )
      {
        if ( CFileMgr::ms_layerStart < cdPosn )
        {
          if ( v7 >= v5 || CStreaming::ms_imageOffsets[1] < CFileMgr::ms_layerStart )
            goto LABEL_32;
          goto LABEL_31;
        }
        if ( v7 < v5 )
        {
LABEL_31:
          v6 = 1;
          v5 = v7;
        }
      }
    }
LABEL_32:
    if ( CStreaming::ms_imageOffsets[2] != -1 )
    {
      v9 = CStreaming::ms_imageOffsets[2] - cdPosn;
      if ( cdPosn > CStreaming::ms_imageOffsets[2] )
        v9 = cdPosn - CStreaming::ms_imageOffsets[2] - CStreaming::ms_imageSize;
      v10 = CFileMgr::ms_layerStart > cdPosn;
      if ( CFileMgr::ms_layerStart > cdPosn )
        v10 = CStreaming::ms_imageOffsets[2] > CFileMgr::ms_layerStart;
      if ( !v10 )
      {
        if ( CFileMgr::ms_layerStart < cdPosn )
        {
          if ( v9 >= v5 || CStreaming::ms_imageOffsets[2] < CFileMgr::ms_layerStart )
            goto LABEL_44;
          goto LABEL_43;
        }
        if ( v9 < v5 )
        {
LABEL_43:
          v6 = 2;
          v5 = v9;
        }
      }
    }
LABEL_44:
    if ( CStreaming::ms_imageOffsets[3] != -1 )
    {
      v11 = CStreaming::ms_imageOffsets[3] - cdPosn;
      if ( cdPosn > CStreaming::ms_imageOffsets[3] )
        v11 = cdPosn - CStreaming::ms_imageOffsets[3] - CStreaming::ms_imageSize;
      v12 = CFileMgr::ms_layerStart > cdPosn;
      if ( CFileMgr::ms_layerStart > cdPosn )
        v12 = CStreaming::ms_imageOffsets[3] > CFileMgr::ms_layerStart;
      if ( !v12 )
      {
        if ( CFileMgr::ms_layerStart < cdPosn )
        {
          if ( v11 >= v5 || CStreaming::ms_imageOffsets[3] < CFileMgr::ms_layerStart )
            goto LABEL_56;
          goto LABEL_55;
        }
        if ( v11 < v5 )
        {
LABEL_55:
          v6 = 3;
          v5 = v11;
        }
      }
    }
LABEL_56:
    if ( CStreaming::ms_imageOffsets[4] != -1 )
    {
      v13 = CStreaming::ms_imageOffsets[4] - cdPosn;
      if ( cdPosn > CStreaming::ms_imageOffsets[4] )
        v13 = cdPosn - CStreaming::ms_imageOffsets[4] - CStreaming::ms_imageSize;
      v14 = CFileMgr::ms_layerStart > cdPosn;
      if ( CFileMgr::ms_layerStart > cdPosn )
        v14 = CStreaming::ms_imageOffsets[4] > CFileMgr::ms_layerStart;
      if ( !v14 )
      {
        if ( CFileMgr::ms_layerStart < cdPosn )
        {
          if ( v13 >= v5 || CStreaming::ms_imageOffsets[4] < CFileMgr::ms_layerStart )
            goto LABEL_68;
          goto LABEL_67;
        }
        if ( v13 < v5 )
        {
LABEL_67:
          v6 = 4;
          v5 = v13;
        }
      }
    }
LABEL_68:
    if ( CStreaming::ms_imageOffsets[5] != -1 )
    {
      v15 = CStreaming::ms_imageOffsets[5] - cdPosn;
      if ( cdPosn > CStreaming::ms_imageOffsets[5] )
        v15 = cdPosn - CStreaming::ms_imageOffsets[5] - CStreaming::ms_imageSize;
      v16 = CFileMgr::ms_layerStart > cdPosn;
      if ( CFileMgr::ms_layerStart > cdPosn )
        v16 = CStreaming::ms_imageOffsets[5] > CFileMgr::ms_layerStart;
      if ( !v16 )
      {
        if ( CFileMgr::ms_layerStart >= cdPosn )
        {
          if ( v15 < v5 )
          {
LABEL_77:
            v6 = 5;
LABEL_119:
            v1 = CStreaming::ms_imageOffsets[v6];
            CStreaming::ms_lastImageRead = v6;
            return v1;
          }
        }
        else if ( v15 < v5 && CStreaming::ms_imageOffsets[5] >= CFileMgr::ms_layerStart )
        {
          goto LABEL_77;
        }
      }
    }
    if ( v6 != -1 )
      goto LABEL_119;
    if ( CStreaming::ms_imageOffsets[0] != -1 )
      goto LABEL_81;
    goto LABEL_27;
  }
  return v1;
}

//----- (002D3FBC) --------------------------------------------------------
void __fastcall CStreaming::ForceLayerToRead(int32 layer)
{
  gbForceLayerRead = 1;
}
// 792FBC: using guessed type char gbForceLayerRead;

//----- (002D3FCC) --------------------------------------------------------
void __fastcall CStreaming::RequestModelStream(int32 ch)
{
  uint32 v1; // r8
  int32 LastPosn; // r0
  int32 NextFileOnCd; // r6
  uint32 m_cdSize; // r1
  uint32 v5; // r12
  int32 v6; // r3
  int v7; // r8
  int v8; // r10
  CStreamingInfo *v9; // r11
  uint8 *p_m_status; // r11
  int m_status; // t1
  uint32 v12; // r5
  CBaseModelInfo *v13; // r4
  int v14; // r0
  bool v15; // zf
  uint32 v16; // r4
  _BOOL4 v17; // r0
  CStreamingInfo *v18; // r1
  Int32 v19; // r2
  uint8 *p_m_flags; // r1
  uint8 v21; // r2
  uint8 m_flags; // t1
  unsigned int v23; // r5
  int v24; // r1
  int m_nextModelOnCd; // r0
  CStreaming::StreamChannel *v26; // r1
  CStreaming::StreamChannel *v28; // [sp+38h] [bp-38h]
  int v29; // [sp+48h] [bp-28h]
  unsigned int v30; // [sp+4Ch] [bp-24h]
  unsigned int v31; // [sp+4Ch] [bp-24h]
  CStreamingInfo (**posn)[26316]; // [sp+50h] [bp-20h]

  LastPosn = CdStreamGetLastPosn();
  NextFileOnCd = CStreaming::GetNextFileOnCd(LastPosn, 1);
  if ( NextFileOnCd == -1 )
    return;
  posn = &CStreaming::ms_aInfoForModel;
  while ( (unsigned int)(NextFileOnCd - 25575) <= 0xB3
       && (CStreaming::ms_aInfoForModel[NextFileOnCd].m_flags & 0xE) == 0
       && !CStreaming::AreAnimsUsedByRequestedModels(NextFileOnCd - 25575) )
  {
    CStreaming::RemoveModel(NextFileOnCd);
    m_cdSize = v1;
    if ( CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdSize )
    {
      posn = (CStreamingInfo (**)[26316])(CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdPosn
                                        + CStreaming::ms_files[CStreaming::ms_aInfoForModel[NextFileOnCd].m_image].m_lsn);
      m_cdSize = CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdSize;
    }
    v1 = m_cdSize;
    NextFileOnCd = CStreaming::GetNextFileOnCd((int32)posn + m_cdSize, 1);
    if ( NextFileOnCd == -1 )
      return;
  }
  v5 = v1;
  if ( CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdSize )
  {
    v5 = CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdSize;
    posn = (CStreamingInfo (**)[26316])(CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdPosn
                                      + CStreaming::ms_files[CStreaming::ms_aInfoForModel[NextFileOnCd].m_image].m_lsn);
  }
  if ( v5 > CStreaming::ms_streamingBufferSize )
  {
    if ( ch == 1 || CStreaming::ms_channel[1].status )
      return;
    CStreaming::ms_bLoadingBigModel = 1;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v28 = &CStreaming::ms_channel[ch];
  v29 = 0;
  while ( 1 )
  {
    v9 = &CStreaming::ms_aInfoForModel[NextFileOnCd];
    m_status = v9->m_status;
    p_m_status = &v9->m_status;
    if ( m_status != 2 )
      goto LABEL_48;
    if ( CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdSize )
      v5 = CStreaming::ms_aInfoForModel[NextFileOnCd].m_cdSize;
    if ( CStreaming::ms_numPriorityRequests && (CStreaming::ms_aInfoForModel[NextFileOnCd].m_flags & 0x10) == 0 )
    {
LABEL_48:
      v24 = v8;
      v23 = v6;
      goto LABEL_49;
    }
    if ( NextFileOnCd <= 19999 )
      break;
    if ( (unsigned int)(NextFileOnCd - 25575) > 0xB3 )
    {
      if ( ((unsigned __int8)v7 & (v5 > 0xC8)) != 0 )
        goto LABEL_48;
    }
    else
    {
      v15 = !CCutsceneMgr::ms_cutsceneProcessing;
      if ( !CCutsceneMgr::ms_cutsceneProcessing )
        v15 = CStreaming::ms_aInfoForModel[7].m_status == 1;
      if ( !v15 )
        goto LABEL_48;
    }
LABEL_36:
    v28->currentLoading[v8] = NextFileOnCd;
    v28->bufferOffset[v8] = v6;
    if ( v8 >= 1 && (int)(v5 + v6) > CStreaming::ms_streamingBufferSize )
      goto LABEL_48;
    v31 = v5 + v6;
    if ( NextFileOnCd > 19999 )
    {
      v17 = v5 > 0xC8;
    }
    else
    {
      v16 = v5;
      v29 |= (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[NextFileOnCd]->_vptr$CBaseModelInfo
              + 5))(CModelInfo::ms_modelInfoPtrs[NextFileOnCd]) == 7;
      v15 = (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[NextFileOnCd]->_vptr$CBaseModelInfo
             + 5))(CModelInfo::ms_modelInfoPtrs[NextFileOnCd]) == 6;
      v17 = 0;
      v5 = v16;
      if ( v15 )
        v17 = 1;
    }
    *p_m_status = 3;
    v18 = &CStreaming::ms_aInfoForModel[NextFileOnCd];
    CStreamingInfo::ms_pArrayBase[v18->m_nextIndex].m_prevIndex = v18->m_prevIndex;
    CStreamingInfo::ms_pArrayBase[v18->m_prevIndex].m_nextIndex = v18->m_nextIndex;
    v18->m_nextIndex = -1;
    v19 = CStreaming::ms_numModelsRequested;
    v18->m_prevIndex = -1;
    CStreaming::ms_numModelsRequested = v19 - 1;
    m_flags = v18->m_flags;
    p_m_flags = &v18->m_flags;
    v21 = m_flags;
    if ( (m_flags & 0x10) != 0 )
    {
      *p_m_flags = v21 & 0xEF;
      --CStreaming::ms_numPriorityRequests;
    }
    v23 = v31;
    v24 = v8 + 1;
    if ( v8 <= 14 )
    {
      v7 |= v17;
      v6 = v31;
      ++v8;
      m_nextModelOnCd = (unsigned __int16)CStreaming::ms_aInfoForModel[NextFileOnCd].m_nextModelOnCd;
      NextFileOnCd = (__int16)m_nextModelOnCd;
      if ( m_nextModelOnCd != 0xFFFF )
        continue;
    }
    goto LABEL_49;
  }
  v12 = v5;
  v30 = v6;
  v13 = CModelInfo::ms_modelInfoPtrs[NextFileOnCd];
  if ( (!(v29 << 31)
     || (*((int (__fastcall **)(CBaseModelInfo *))v13->_vptr$CBaseModelInfo + 5))(CModelInfo::ms_modelInfoPtrs[NextFileOnCd]) != 7)
    && (!(v7 << 31) || (*((int (__fastcall **)(CBaseModelInfo *))v13->_vptr$CBaseModelInfo + 5))(v13) != 6) )
  {
    v14 = (*((int (__fastcall **)(CBaseModelInfo *))v13->_vptr$CBaseModelInfo + 15))(v13);
    v6 = v30;
    v5 = v12;
    if ( v14 != -1
      && (*((unsigned __int8 *)&CStreaming::ms_aInfoForModel[v14].m_nextIndex + (_DWORD)"Z16_rwGLHandleBlendP8RwRaster") | 2) != 3 )
    {
      goto LABEL_48;
    }
    goto LABEL_36;
  }
  v24 = v8;
  v23 = v30;
LABEL_49:
  if ( v24 <= 15 )
    memset(&CStreaming::ms_channel[ch].currentLoading[v24], 255, 4 * (16 - v24));
  CdStreamRead(ch, CStreaming::ms_pStreamingBuffer[ch], (unsigned int)posn, v23);
  v26 = &CStreaming::ms_channel[ch];
  v26->status = STATUS_LOADING;
  v26->loadTime = 0;
  v26->loadStart = (int32)posn;
  v26->loadSize = v23;
  v26->attempts = 0;
  if ( gbForceLayerRead == 1 )
    gbForceLayerRead = 0;
}
// 2D403C: variable 'v1' is possibly undefined
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 792FBC: using guessed type char gbForceLayerRead;

//----- (002D4428) --------------------------------------------------------
int __fastcall CompareRequest(const void *a, const void *b)
{
  int result; // r0
  CStreamingInfo **v3; // r3
  unsigned int v4; // r2

  if ( sorted > a || (v3 = &sorted[numberOfEntries], v3 < b) || sorted > b || v3 < a )
  {
    hasSortError = 1;
    return 0;
  }
  else
  {
    v4 = *((_DWORD *)a + 2) + CStreaming::ms_files[*((unsigned __int8 *)a + 7)].m_lsn;
    result = 1;
    if ( v4 < CStreaming::ms_files[*((unsigned __int8 *)b + 7)].m_lsn + *((_DWORD *)b + 2) )
      return -1;
  }
  return result;
}

//----- (002D44A8) --------------------------------------------------------
void __fastcall SortRequests(CStreamingInfo **start, CStreamingInfo **end)
{
  CStreamingInfo *v4; // r0
  CStreamingInfo *v5; // r1
  signed int v6; // r5
  int v7; // r6
  int m_nextIndex; // r3
  CStreamingInfo **v9; // r4
  int v10; // r0
  CStreamingInfo *v11; // r1
  int v12; // r1
  bool v13; // zf
  CStreamingInfo **v14; // r3
  int v15; // r1
  CStreamingInfo *v16; // r4
  CStreamingInfo *v17; // r3
  int v18; // r0
  CStreamingInfo *v19; // r3
  CStreamingInfo *v20; // r8
  CStreamingInfo *v21; // r0
  CStreamingInfo **v22; // [sp+0h] [bp-20h]

  if ( !SortRequests(CStreamingInfo **,CStreamingInfo **)::inSort )
  {
    SortRequests(CStreamingInfo **,CStreamingInfo **)::inSort = 1;
    v4 = *end;
    v5 = *start;
    if ( *start == *end )
    {
      numberOfEntries = 0;
    }
    else
    {
      v6 = -1;
      v7 = 0;
      do
      {
        m_nextIndex = (unsigned __int16)v5->m_nextIndex;
        ++v7;
        ++v6;
        v5 = &CStreamingInfo::ms_pArrayBase[(__int16)m_nextIndex];
        if ( m_nextIndex == 0xFFFF )
          v5 = 0;
      }
      while ( v5 != v4 );
      numberOfEntries = v6 + 1;
      if ( v6 >= 2 )
      {
        v9 = (CStreamingInfo **)malloc(v7 * 4 + 8);
        sorted = v9;
        memset(v9, 0, v7 * 4 + 8);
        v10 = 0;
        v11 = *start;
        do
        {
          v9[v10] = v11;
          v12 = (unsigned __int16)v11->m_nextIndex;
          if ( v12 == 0xFFFF )
            v11 = 0;
          else
            v11 = &CStreamingInfo::ms_pArrayBase[(__int16)v12];
          v9 = sorted;
          v13 = v10++ == v6;
        }
        while ( !v13 );
        sorted[v7] = v11;
        qsort(sorted + 1, v6, 4u, CompareRequest);
        if ( !hasSortError )
        {
          v22 = end;
          v14 = sorted;
          v15 = 0;
          do
          {
            v16 = v14[v15];
            v17 = v14[v15 + 1];
            LOWORD(v18) = -1;
            if ( v16 )
              v18 = -858993459 * (((char *)v16 - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
            v17->m_prevIndex = v18;
            v19 = sorted[v15];
            v20 = sorted[v15 + 1];
            LOWORD(v18) = -1;
            if ( v20 )
              v18 = -858993459 * (((char *)v20 - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
            v13 = v15++ == v6;
            v19->m_nextIndex = v18;
            v14 = sorted;
          }
          while ( !v13 );
          v21 = sorted[v7];
          *v22 = v21;
          v21->m_nextIndex = -1;
        }
        hasSortError = 0;
        free(sorted);
        sorted = 0;
      }
    }
    SortRequests(CStreamingInfo **,CStreamingInfo **)::inSort = 0;
  }
}
// 2D45A0: conditional instruction was optimized away because r5.4>=2
// 792FCD: using guessed type char SortRequests(CStreamingInfo **,CStreamingInfo **)::inSort;

//----- (002D46A8) --------------------------------------------------------
void __fastcall CStreaming::LoadAllRequestedModels(bool bPriorityRequestsOnly)
{
  int v1; // r6
  int v2; // r5
  int m_prevIndex; // r0
  CStreamingInfo *v4; // r0
  _BOOL4 v5; // r0
  CStreaming::StreamChannel *v6; // r9
  CStreaming::Status *p_status; // r9
  CStreaming::Status status; // t1
  _BOOL4 v9; // r0
  _BOOL4 v10; // [sp+8h] [bp-38h]

  v10 = bPriorityRequestsOnly;
  if ( !CStreaming::LoadAllRequestedModels(bool)::bInsideLoadAll )
  {
    CStreaming::LoadAllRequestedModels(bool)::bInsideLoadAll = 1;
    CStreaming::FlushChannels();
    v1 = 10;
    v2 = 0;
    if ( 2 * CStreaming::ms_numModelsRequested > 10 )
      v1 = 2 * CStreaming::ms_numModelsRequested;
    while ( 1 )
    {
      m_prevIndex = CStreaming::ms_pEndRequestedList->m_prevIndex;
      v4 = m_prevIndex == -1 ? 0 : &CStreamingInfo::ms_pArrayBase[m_prevIndex];
      v5 = ((unsigned int)v4 ^ (unsigned int)CStreaming::ms_pStartRequestedList | CStreaming::ms_channel[0].status | CStreaming::ms_channel[1].status) != 0;
      if ( v1 < 1 || !v5 )
        break;
      if ( CStreaming::ms_bLoadingBigModel )
        v2 = 0;
      v6 = &CStreaming::ms_channel[v2];
      status = v6->status;
      p_status = &v6->status;
      if ( status )
      {
        CdStreamSync(v2);
        CStreaming::ms_channel[v2].loadTime = 100;
        if ( *p_status == STATUS_LOADING )
        {
          CStreaming::ProcessLoadingChannel(v2);
          if ( *p_status == STATUS_LOADING_LARGEFILE )
            CStreaming::ProcessLoadingChannel(v2);
        }
      }
      if ( !CStreaming::ms_numPriorityRequests && v10 )
        break;
      if ( !CStreaming::ms_bLoadingBigModel )
      {
        if ( CStreaming::ms_channel[1 - v2].status )
        {
          v9 = 0;
        }
        else
        {
          CStreaming::RequestModelStream(1 - v2);
          v9 = CStreaming::ms_bLoadingBigModel;
        }
        if ( *p_status == STATUS_IDLE && !v9 )
          CStreaming::RequestModelStream(v2);
      }
      if ( !(CStreaming::ms_channel[0].status | CStreaming::ms_channel[1].status) )
        break;
      --v1;
      v2 = 1 - v2;
    }
    CStreaming::FlushChannels();
    CStreaming::LoadAllRequestedModels(bool)::bInsideLoadAll = 0;
    sub_19C804(0.0, 1);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 792FCE: using guessed type char CStreaming::LoadAllRequestedModels(bool)::bInsideLoadAll;

//----- (002D4878) --------------------------------------------------------
void CStreaming::FlushChannels()
{
  RenderQueue *v0; // r1
  unsigned __int8 *mainWorkPointer; // r2
  RenderQueue *v2; // r4
  __int64 v3; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v5; // r2
  CStreaming::Status status; // r0
  CStreaming::Status v7; // r0

  v0 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqCleanup;
  *(_DWORD *)mainWorkPointer = 49;
  v0->mainWorkPointer += 4;
  v2 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v3 = *(_QWORD *)&v2->mainPointer;
  p_mainPointer = (unsigned int *)&v2->mainPointer;
  __dmb(0xBu);
  do
    v5 = __ldrex(p_mainPointer);
  while ( __strex(v5 + HIDWORD(v3) - v3, p_mainPointer) );
  __dmb(0xBu);
  if ( v2->useMutex )
    OS_MutexRelease(v2->commandMutex);
  if ( !v2->multiThread )
    RenderQueue::Process(v2);
  if ( v2->mainPointer + 1024 > v2->queueEnd )
    RenderQueue::Flush(v2);
  if ( CStreaming::ms_channel[1].status == STATUS_LOADING_LARGEFILE )
    CStreaming::ProcessLoadingChannel(1);
  status = CStreaming::ms_channel[0].status;
  if ( CStreaming::ms_channel[0].status == STATUS_LOADING )
  {
    CdStreamSync(0);
    CStreaming::ms_channel[0].loadTime = 100;
    CStreaming::ProcessLoadingChannel(0);
    status = CStreaming::ms_channel[0].status;
  }
  if ( status == STATUS_LOADING_LARGEFILE )
    CStreaming::ProcessLoadingChannel(0);
  v7 = CStreaming::ms_channel[1].status;
  if ( CStreaming::ms_channel[1].status == STATUS_LOADING )
  {
    CdStreamSync(1);
    CStreaming::ms_channel[1].loadTime = 100;
    CStreaming::ProcessLoadingChannel(1);
    v7 = CStreaming::ms_channel[1].status;
  }
  if ( v7 == STATUS_LOADING_LARGEFILE )
    CStreaming::ProcessLoadingChannel(1);
  sub_19C804(0.0, 1);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002D49A0) --------------------------------------------------------
void __fastcall CStreaming::SetLoadVehiclesInLoadScene(bool bLoad)
{
  bLoadVehiclesWhenLoadingScene = bLoad;
}

//----- (002D49AC) --------------------------------------------------------
void __fastcall CStreaming::RequestFilesInChannel(int32 ch)
{
  int v1; // r6
  CStreaming::StreamChannel *v2; // r8
  int32 v3; // r4
  int32 m_flags; // r5

  v1 = 0;
  v2 = &CStreaming::ms_channel[ch];
  do
  {
    v3 = v2->currentLoading[v1];
    if ( v3 != -1 )
    {
      m_flags = CStreaming::ms_aInfoForModel[v3].m_flags;
      CStreaming::RemoveModel(v2->currentLoading[v1]);
      CStreaming::RequestModel(v3, m_flags);
    }
    ++v1;
  }
  while ( v1 != 16 );
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D4A00) --------------------------------------------------------
void __fastcall CStreaming::LoadScene(const CVector *posn)
{
  eLevelName LevelFromPosition; // r4
  int m_prevIndex; // r0
  CStreamingInfo *v4; // r0
  CStreamingInfo *v5; // r1
  int v6; // r2
  CStreamingInfo *v7; // r8
  CBuildingPool *v8; // r8
  int32 m_nSize; // r0
  int v10; // r6
  float farPlane; // r10
  int v12; // r4
  CPool<CBuilding,CBuilding>::StorageType *m_aStorage; // r5
  uint8 *v14; // r0
  bool v15; // zf
  CZoneInfo *ZoneInfo; // r6
  int32 v17; // r0
  int v18; // r0
  int32 v19; // r0
  int v20; // r0
  int32 v21; // r0
  int v22; // r0
  int32 v23; // r0
  int v24; // r0
  int32 v25; // r0
  int v26; // r0
  int v27; // r1
  uint8 *p_m_flags; // r0
  int32 v29; // [sp+4h] [bp-3Ch]
  CVector v30; // [sp+8h] [bp-38h] BYREF
  CVector pPoint; // [sp+18h] [bp-28h] BYREF

  LevelFromPosition = CTheZones::GetLevelFromPosition(posn);
  bLoadingScene = 1;
  memset(&pPoint, 0, sizeof(pPoint));
  if ( CWorld::Players[0].pPed )
  {
    FindPlayerCoors(&v30, -1);
    pPoint = v30;
  }
  m_prevIndex = CStreaming::ms_pEndRequestedList->m_prevIndex;
  v29 = LevelFromPosition;
  if ( m_prevIndex == -1 )
    v4 = 0;
  else
    v4 = &CStreamingInfo::ms_pArrayBase[m_prevIndex];
  v5 = CStreaming::ms_pStartRequestedList;
  if ( v4 != CStreaming::ms_pStartRequestedList )
  {
    do
    {
      v6 = (unsigned __int16)v4->m_prevIndex;
      if ( v6 == 0xFFFF )
        v7 = 0;
      else
        v7 = &CStreamingInfo::ms_pArrayBase[(__int16)v6];
      if ( (v4->m_flags & 0x3E) == 0 )
      {
        CStreaming::RemoveModel(-858993459 * (((char *)v4 - (char *)CStreaming::ms_aInfoForModel) >> 2));
        v5 = CStreaming::ms_pStartRequestedList;
      }
      v4 = v7;
    }
    while ( v7 != v5 );
  }
  CRenderer::m_loadingPriority = 0;
  CStreaming::DeleteAllRwObjects();
  v8 = CPools::ms_pBuildingPool;
  m_nSize = CPools::ms_pBuildingPool->m_nSize;
  if ( m_nSize )
  {
    v10 = m_nSize - 1;
    farPlane = TheCamera.m_pRwCamera->farPlane;
    v12 = 60 * m_nSize - 22;
    do
    {
      if ( (v8->m_aFlags[v10] & 0x80u) == 0 )
      {
        m_aStorage = v8->m_aStorage;
        v14 = &(*v8->m_aStorage)[v12];
        v15 = v14 == (_BYTE *)&dword_24 + 2;
        if ( v14 != (_BYTE *)&dword_24 + 2 )
          v15 = *(v14 - 9) << 31 == 0;
        if ( !v15 && CRenderer::ShouldModelBeStreamed((CEntity *)(v14 - 38), posn, farPlane) )
          CStreaming::RequestModel(*(__int16 *)&(*m_aStorage)[v12], 0);
      }
      --v10;
      v12 -= 60;
    }
    while ( v10 != -1 );
  }
  CIplStore::LoadIpls(*posn, 1);
  CStreaming::LoadAllRequestedModels(0);
  CStreaming::AddModelsToRequestList(posn, 0x20u);
  CRadar::StreamRadarSections(posn);
  CPathFind::LoadSceneForPathNodes(&ThePaths, *posn);
  if ( CGame::currArea == AREA_MAIN_MAP )
  {
    if ( bLoadVehiclesWhenLoadingScene )
    {
      ZoneInfo = CTheZones::GetZoneInfo(posn, 0);
      if ( ZoneInfo != CTheZones::GetZoneInfo(&pPoint, 0) )
      {
        if ( CPopCycle::m_pCurrZoneInfo )
        {
          CTheZones::GetZoneInfo(posn, 0);
          v17 = CPopCycle::PickARandomGroupOfOtherPeds();
          v18 = CCarCtrl::ChooseCarModelToLoad(v17);
          if ( v18 >= 0 )
            CStreaming::RequestModel(v18, 8);
          if ( CPopCycle::m_pCurrZoneInfo )
          {
            CTheZones::GetZoneInfo(posn, 0);
            v19 = CPopCycle::PickARandomGroupOfOtherPeds();
            v20 = CCarCtrl::ChooseCarModelToLoad(v19);
            if ( v20 >= 0 )
              CStreaming::RequestModel(v20, 8);
            if ( CPopCycle::m_pCurrZoneInfo )
            {
              CTheZones::GetZoneInfo(posn, 0);
              v21 = CPopCycle::PickARandomGroupOfOtherPeds();
              v22 = CCarCtrl::ChooseCarModelToLoad(v21);
              if ( v22 >= 0 )
                CStreaming::RequestModel(v22, 8);
              if ( CPopCycle::m_pCurrZoneInfo )
              {
                CTheZones::GetZoneInfo(posn, 0);
                v23 = CPopCycle::PickARandomGroupOfOtherPeds();
                v24 = CCarCtrl::ChooseCarModelToLoad(v23);
                if ( v24 >= 0 )
                  CStreaming::RequestModel(v24, 8);
                if ( CPopCycle::m_pCurrZoneInfo )
                {
                  CTheZones::GetZoneInfo(posn, 0);
                  v25 = CPopCycle::PickARandomGroupOfOtherPeds();
                  v26 = CCarCtrl::ChooseCarModelToLoad(v25);
                  if ( v26 >= 0 )
                    CStreaming::RequestModel(v26, 8);
                }
              }
            }
          }
        }
      }
    }
    CStreaming::StreamCopModels(v29);
  }
  CStreaming::LoadAllRequestedModels(0);
  CStreaming::InstanceLoadedModels(posn);
  v27 = 26316;
  p_m_flags = &CStreaming::ms_aInfoForModel[0].m_flags;
  do
  {
    --v27;
    *p_m_flags &= ~0x20u;
    p_m_flags += 20;
  }
  while ( v27 );
  bLoadingScene = 0;
  if ( CWorld::Players[0].pPed )
    CPopulation::ManageAllPopulation();
}
// 24: using guessed type int dword_24;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D4D00) --------------------------------------------------------
void __fastcall CStreaming::RequestBigBuildings(const CVector *posn)
{
  CBuildingPool *v2; // r10
  int32 m_nSize; // r0
  int v4; // r5
  float farPlane; // r9
  int v6; // r4
  CPool<CBuilding,CBuilding>::StorageType *m_aStorage; // r6
  uint8 *v8; // r0
  bool v9; // zf

  v2 = CPools::ms_pBuildingPool;
  m_nSize = CPools::ms_pBuildingPool->m_nSize;
  if ( m_nSize )
  {
    v4 = m_nSize - 1;
    farPlane = TheCamera.m_pRwCamera->farPlane;
    v6 = 60 * m_nSize - 22;
    do
    {
      if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v8 = &(*v2->m_aStorage)[v6];
        v9 = v8 == (_BYTE *)&dword_24 + 2;
        if ( v8 != (_BYTE *)&dword_24 + 2 )
          v9 = *(v8 - 9) << 31 == 0;
        if ( !v9 && CRenderer::ShouldModelBeStreamed((CEntity *)(v8 - 38), posn, farPlane) )
          CStreaming::RequestModel(*(__int16 *)&(*m_aStorage)[v6], 0);
      }
      --v4;
      v6 -= 60;
    }
    while ( v4 != -1 );
  }
}
// 24: using guessed type int dword_24;

//----- (002D4D84) --------------------------------------------------------
void __fastcall CStreaming::LoadZoneVehicle(const CVector *posn)
{
  int32 v1; // r0
  int v2; // r0

  if ( CPopCycle::m_pCurrZoneInfo )
  {
    CTheZones::GetZoneInfo(posn, 0);
    v1 = CPopCycle::PickARandomGroupOfOtherPeds();
    v2 = CCarCtrl::ChooseCarModelToLoad(v1);
    if ( v2 >= 0 )
      CStreaming::RequestModel(v2, 8);
  }
}

//----- (002D4DB8) --------------------------------------------------------
void __fastcall CStreaming::StreamCopModels(int32 level)
{
  CWanted *PlayerWanted; // r0
  uint32 v3; // r5
  int m_status; // r1
  bool v5; // zf
  int i; // r5
  int32 v7; // r0
  int32 v8; // r2
  CStreamingInfo *v9; // r1
  uint8 m_flags; // r6
  CStreamingInfo *v11; // r0
  CStreamingInfo *v12; // lr
  unsigned int v13; // r3
  int16 v14; // r6
  int32 v15; // r0
  int32 v16; // r2
  CStreamingInfo *v17; // r1
  uint8 v18; // r6
  CStreamingInfo *v19; // r0
  CStreamingInfo *v20; // r8
  unsigned int v21; // r3
  unsigned int v22; // r6
  int32 index; // [sp+1Ch] [bp-2Ch]
  int32 v24; // [sp+24h] [bp-24h]

  if ( CGame::currArea == AREA_MAIN_MAP )
  {
    if ( FindPlayerWanted(-1)
      && (PlayerWanted = FindPlayerWanted(-1), level)
      && PlayerWanted->m_WantedLevel <= WANTED_LEVEL2
      && !gDisableCopsOnBikes )
    {
      v3 = CTimer::m_snTimeInMilliseconds;
      if ( gTimeBeforeChangeVehicles < CTimer::m_snTimeInMilliseconds )
      {
        gGenerateCopsOnBikes ^= 1u;
        gTimeBeforeChangeVehicles = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 20000.0)
                                  + v3
                                  + 30000;
      }
      if ( gGenerateCopsOnBikes )
        level = 4;
    }
    else
    {
      gGenerateCopsOnBikes = 0;
    }
    v24 = gCopCarList[level];
    index = gCopList[level];
    m_status = CStreaming::ms_aInfoForModel[index].m_status;
    v5 = m_status == 1;
    if ( m_status == 1 )
      v5 = CStreaming::ms_aInfoForModel[v24].m_status == 1;
    if ( v5 )
    {
      for ( i = 0; i != 4; ++i )
      {
        if ( level != i )
        {
          if ( level != 4 )
          {
            v7 = gCopList[i];
            v8 = v7;
            v9 = &CStreaming::ms_aInfoForModel[v7];
            m_flags = v9->m_flags;
            v9->m_flags = m_flags & 0xFD;
            if ( (m_flags & 4) == 0 )
            {
              if ( CStreaming::ms_aInfoForModel[v7].m_status == 1 )
              {
                if ( (unsigned __int16)v9->m_nextIndex == 0xFFFF )
                {
                  v11 = CStreaming::ms_pStartLoadedList;
                  v12 = CStreamingInfo::ms_pArrayBase;
                  v13 = (char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase;
                  v9->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                  v14 = -13107 * ((unsigned int)((char *)v9 - (char *)v12) >> 2);
                  CStreaming::ms_aInfoForModel[v8].m_prevIndex = -13107 * (v13 >> 2);
                  v11->m_nextIndex = v14;
                  CStreamingInfo::ms_pArrayBase[v9->m_nextIndex].m_prevIndex = v14;
                }
              }
              else if ( (m_flags & 8) == 0 )
              {
                CStreaming::RemoveModel(v7);
              }
            }
          }
          v15 = gCopCarList[i];
          v16 = v15;
          v17 = &CStreaming::ms_aInfoForModel[v15];
          v18 = v17->m_flags;
          v17->m_flags = v18 & 0xFD;
          if ( (v18 & 4) == 0 )
          {
            if ( CStreaming::ms_aInfoForModel[v15].m_status == 1 )
            {
              if ( (unsigned __int16)v17->m_nextIndex == 0xFFFF )
              {
                v19 = CStreaming::ms_pStartLoadedList;
                v20 = CStreamingInfo::ms_pArrayBase;
                v21 = (char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase;
                v17->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                v22 = -858993459 * ((unsigned int)((char *)v17 - (char *)v20) >> 2);
                CStreaming::ms_aInfoForModel[v16].m_prevIndex = -13107 * (v21 >> 2);
                v19->m_nextIndex = v22;
                CStreamingInfo::ms_pArrayBase[v17->m_nextIndex].m_prevIndex = v22;
              }
            }
            else if ( (v18 & 8) == 0 )
            {
              CStreaming::RemoveModel(v15);
            }
          }
        }
      }
    }
    CStreaming::RequestModel(index, 2);
    CStreaming::RequestModel(v24, 2);
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D50B4) --------------------------------------------------------
void __fastcall CStreaming::ClearFlagForAll(uint32 flag)
{
  char v1; // r0
  int v2; // r2
  uint8 *p_m_flags; // r1

  v1 = ~(_BYTE)flag;
  v2 = 26316;
  p_m_flags = &CStreaming::ms_aInfoForModel[0].m_flags;
  do
  {
    --v2;
    *p_m_flags &= v1;
    p_m_flags += 20;
  }
  while ( v2 );
}

//----- (002D50D8) --------------------------------------------------------
void __fastcall CStreaming::LoadSceneCollision(const CVector *posn)
{
  CColStore::LoadCollision(*posn, 1);
  CIplStore::LoadIpls(*posn, 1);
  CStreaming::LoadAllRequestedModels(0);
}

//----- (002D50FE) --------------------------------------------------------
void __fastcall CStreaming::DeleteRwObjectsInSectorList(CPtrList *list, Int32 x, Int32 y)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v6; // kr00_8

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v6 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( (x < 0 || CEntity::LivesInThisNonOverlapSector((CEntity *)v6.m_pVoid, x, y))
      && (*((_BYTE *)v6.m_pVoid + 29) & 0x24) == 0 )
    {
      (*(void (__fastcall **)(void *))(*(_DWORD *)v6.m_pVoid + 36))(v6.m_pVoid);
    }
  }
}

//----- (002D5140) --------------------------------------------------------
void __fastcall CStreaming::DeleteRwObjectsAfterDeath(const CVector *posn)
{
  float y; // s18
  int v2; // r6
  int v3; // s2
  int v4; // r4
  int v5; // r8
  float v6; // s18
  int v7; // r9
  CPtrNode *m_pHead; // r10
  CPtrNode v9; // kr00_8
  CPtrNode *v10; // r5
  CPtrNode v11; // kr08_8
  CPtrNode *v12; // r5
  CPtrNode v13; // kr10_8

  y = posn->y;
  v2 = 0;
  v3 = (int)floorf((float)(posn->x / 50.0) + 60.0);
  v4 = (int)floorf((float)(y / 50.0) + 60.0);
  do
  {
    v5 = 0;
    v6 = fabsf((float)(v3 - v2));
    do
    {
      if ( v6 > 3.0 && fabsf((float)(v4 - v5)) > 3.0 )
      {
        v7 = v2 + 120 * v5;
        m_pHead = CWorld::ms_aSectors[v7].m_buildingPtrListArray.m_pHead;
        while ( m_pHead )
        {
          v9 = *m_pHead;
          m_pHead = m_pHead->m_pNext;
          if ( (*((_BYTE *)v9.m_pVoid + 29) & 0x24) == 0 )
            (*(void (__fastcall **)(void *))(*(_DWORD *)v9.m_pVoid + 36))(v9.m_pVoid);
        }
        v10 = CWorld::ms_aRepeatSectors[(unsigned __int8)(16 * v5) | v2 & 0xF].m_ptrListArray[2].m_pHead;
        while ( v10 )
        {
          v11 = *v10;
          v10 = v10->m_pNext;
          if ( (*((_BYTE *)v11.m_pVoid + 29) & 0x24) == 0 )
            (*(void (__fastcall **)(void *))(*(_DWORD *)v11.m_pVoid + 36))(v11.m_pVoid);
        }
        v12 = CWorld::ms_aSectors[v7].m_dummyPtrListArray.m_pHead;
        while ( v12 )
        {
          v13 = *v12;
          v12 = v12->m_pNext;
          if ( (*((_BYTE *)v13.m_pVoid + 29) & 0x24) == 0 )
            (*(void (__fastcall **)(void *))(*(_DWORD *)v13.m_pVoid + 36))(v13.m_pVoid);
        }
      }
      ++v5;
    }
    while ( v5 != 120 );
    ++v2;
  }
  while ( v2 != 120 );
}

//----- (002D52A0) --------------------------------------------------------
void CStreaming::RemoveBigBuildings()
{
  CBuildingPool *v0; // r9
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r5
  CBaseModelInfo *v4; // r10
  int v5; // r0
  CPool<CBuilding,CBuilding>::StorageType *m_aStorage; // r4
  uint8 *v7; // r1
  bool v8; // zf

  v0 = CPools::ms_pBuildingPool;
  m_nSize = CPools::ms_pBuildingPool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 60 * m_nSize - 22;
    do
    {
      v5 = (char)v0->m_aFlags[v2];
      if ( v5 >= 0 )
      {
        m_aStorage = v0->m_aStorage;
        v7 = &(*v0->m_aStorage)[v3];
        v8 = v7 == (_BYTE *)&dword_24 + 2;
        if ( v7 != (_BYTE *)&dword_24 + 2 )
        {
          v5 = *(_DWORD *)(v7 - 10);
          v8 = (v5 & 0x100) == 0;
        }
        if ( !v8 && (v5 & 0x2000) == 0 )
        {
          v4 = CModelInfo::ms_modelInfoPtrs[*(__int16 *)&(*m_aStorage)[v3]];
          (*(void (__fastcall **)(uint8 *))(*(_DWORD *)(v7 - 38) + 36))(v7 - 38);
          if ( !v4->m_numRefs )
            CStreaming::RemoveModel(*(__int16 *)&(*m_aStorage)[v3]);
        }
      }
      --v2;
      v3 -= 60;
    }
    while ( v2 != -1 );
  }
}
// 24: using guessed type int dword_24;

//----- (002D5328) --------------------------------------------------------
void __fastcall CStreaming::RemoveBuildingsNotInArea(int32 area)
{
  CBuildingPool *v2; // r5
  int32 m_nSize; // r0
  int v4; // r6
  int v5; // r4
  CPool<CBuilding,CBuilding>::StorageType *m_aStorage; // r0
  uint8 *v7; // r1
  int v8; // r2
  bool v9; // zf
  CObjectPool *v10; // r5
  int32 v11; // r0
  int v12; // r4
  int v13; // r6
  uint8 *v14; // r1
  int v15; // r2
  bool v16; // zf
  CDummyPool *v17; // r5
  int32 v18; // r0
  int v19; // r6
  int v20; // r4
  CPool<CDummy,CDummy>::StorageType *v21; // r0
  uint8 *v22; // r1
  int v23; // r2
  bool v24; // zf

  v2 = CPools::ms_pBuildingPool;
  m_nSize = CPools::ms_pBuildingPool->m_nSize;
  if ( m_nSize )
  {
    v4 = m_nSize - 1;
    v5 = 60 * m_nSize - 9;
    do
    {
      if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v7 = &(*v2->m_aStorage)[v5];
        if ( v7 != (_BYTE *)&word_32 + 1 )
        {
          v8 = *(_DWORD *)(v7 - 27);
          v9 = v8 == 0;
          if ( v8 )
          {
            m_aStorage = (CPool<CBuilding,CBuilding>::StorageType *)(*m_aStorage)[v5];
            v9 = m_aStorage == (_BYTE (*)[60])&byte_9[4];
          }
          if ( !v9 && m_aStorage != (CPool<CBuilding,CBuilding>::StorageType *)area && (*(v7 - 22) & 0x21) == 0 )
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)(v7 - 51) + 36))(v7 - 51);
        }
      }
      --v4;
      v5 -= 60;
    }
    while ( v4 != -1 );
  }
  v10 = CPools::ms_pObjectPool;
  v11 = CPools::ms_pObjectPool->m_nSize;
  if ( v11 )
  {
    v12 = v11 - 1;
    v13 = 420 * v11 - 100;
    do
    {
      if ( (v10->m_aFlags[v12] & 0x80u) == 0 )
      {
        v14 = &(*v10->m_aStorage)[v13];
        if ( v14 != (uint8 *)&elf_hash_bucket[17] )
        {
          v15 = *((_DWORD *)v14 - 74);
          v16 = v15 == 0;
          if ( v15 )
          {
            v15 = *(v14 - 269);
            v16 = v15 == 13;
          }
          if ( !v16 && v15 != area && (*(v14 - 291) & 0x20) == 0 && (*v10->m_aStorage)[v13] == 1 )
            (*(void (__fastcall **)(uint8 *))(*((_DWORD *)v14 - 80) + 36))(v14 - 320);
        }
      }
      --v12;
      v13 -= 420;
    }
    while ( v12 != -1 );
  }
  v17 = CPools::ms_pDummyPool;
  v18 = CPools::ms_pDummyPool->m_nSize;
  if ( v18 )
  {
    v19 = v18 - 1;
    v20 = 60 * v18 - 9;
    do
    {
      if ( (v17->m_aFlags[v19] & 0x80u) == 0 )
      {
        v21 = v17->m_aStorage;
        v22 = &(*v17->m_aStorage)[v20];
        if ( v22 != (_BYTE *)&word_32 + 1 )
        {
          v23 = *(_DWORD *)(v22 - 27);
          v24 = v23 == 0;
          if ( v23 )
          {
            v21 = (CPool<CDummy,CDummy>::StorageType *)(*v21)[v20];
            v24 = v21 == (_BYTE (*)[60])&byte_9[4];
          }
          if ( !v24 && v21 != (CPool<CDummy,CDummy>::StorageType *)area && (*(v22 - 22) & 0x20) == 0 )
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)(v22 - 51) + 36))(v22 - 51);
        }
      }
      --v19;
      v20 -= 60;
    }
    while ( v19 != -1 );
  }
}
// 32: using guessed type __int16 word_32;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002D5474) --------------------------------------------------------
void CStreaming::RequestAllModels()
{
  CBuildingPool *v0; // r5
  CDummyPool *v1; // r8
  int32 m_nSize; // r0
  int v3; // r4
  int v4; // r6
  int32 v5; // r0
  int v6; // r4
  int v7; // r5

  v0 = CPools::ms_pBuildingPool;
  v1 = CPools::ms_pDummyPool;
  m_nSize = CPools::ms_pBuildingPool->m_nSize;
  if ( m_nSize )
  {
    v3 = m_nSize - 1;
    v4 = 60 * m_nSize - 22;
    do
    {
      if ( (v0->m_aFlags[v3] & 0x80u) == 0 && &(*v0->m_aStorage)[v4] != (uint8 *)((char *)&dword_24 + 2) )
        CStreaming::RequestModel(*(__int16 *)&(*v0->m_aStorage)[v4], 0);
      --v3;
      v4 -= 60;
    }
    while ( v3 != -1 );
  }
  v5 = v1->m_nSize;
  if ( v5 )
  {
    v6 = v5 - 1;
    v7 = 60 * v5 - 22;
    do
    {
      if ( (v1->m_aFlags[v6] & 0x80u) == 0 && &(*v1->m_aStorage)[v7] != (uint8 *)((char *)&dword_24 + 2) )
        CStreaming::RequestModel(*(__int16 *)&(*v1->m_aStorage)[v7], 0);
      --v6;
      v7 -= 60;
    }
    while ( v6 != -1 );
  }
}
// 24: using guessed type int dword_24;

//----- (002D550C) --------------------------------------------------------
bool __fastcall CStreaming::RemoveLeastUsedModel(uint32 ignoreFlags)
{
  unsigned __int8 v1; // r3
  CStreamingInfo *v2; // r10
  CStreamingInfo *v3; // r12
  CStreamingInfo **v4; // r2
  int m_prevIndex; // r0
  int v6; // r0
  int32 v7; // r5
  CStreamingInfo **v8; // r11
  CStreamingInfo *v9; // r9
  int32 NumRefsToAnimBlock; // r0
  _BOOL4 v11; // r0
  CSimpleTransform *p_tx; // r2
  float z; // s16
  bool v14; // r5

  v1 = ignoreFlags;
  v2 = CStreaming::ms_pEndLoadedList;
  v3 = CStreaming::ms_aInfoForModel;
  v4 = &CStreamingInfo::ms_pArrayBase;
  while ( 1 )
  {
    m_prevIndex = v2->m_prevIndex;
    v2 = m_prevIndex == -1 ? 0 : &(*v4)[m_prevIndex];
    if ( v2 == CStreaming::ms_pStartLoadedList )
      break;
    if ( (v2->m_flags & v1) == 0 )
    {
      v6 = (char *)v2 - (char *)v3;
      v7 = -858993459 * (((char *)v2 - (char *)v3) >> 2);
      if ( (char *)v2 - (char *)v3 > (int)&stru_61A7C.st_name + 3 )
      {
        v8 = v4;
        if ( (unsigned int)(v6 - 511481) > 0xE22 )
        {
          if ( v6 >= (int)"ineLockP10RxPipeline"
            && !*((_BYTE *)&CTheScripts::StreamedScripts.ScriptStructures[-53687091 * (((char *)v2 - (char *)v3) >> 2)
                                                                        - 26229]
                - 28) )
          {
LABEL_16:
            CStreaming::RemoveModel(v7);
            return 1;
          }
        }
        else
        {
          v9 = v3;
          NumRefsToAnimBlock = CAnimManager::GetNumRefsToAnimBlock(v7 - 25575);
          v1 = ignoreFlags;
          v3 = v9;
          v4 = v8;
          if ( !NumRefsToAnimBlock )
          {
            v11 = CStreaming::AreAnimsUsedByRequestedModels(v7 - 25575);
            v4 = v8;
            v3 = v9;
            v1 = ignoreFlags;
            if ( !v11 )
              goto LABEL_16;
          }
        }
      }
      else if ( !CModelInfo::ms_modelInfoPtrs[214748365 * (((char *)v2 - (char *)v3) >> 2)]->m_numRefs )
      {
        goto LABEL_16;
      }
    }
  }
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  z = p_tx->m_translate.z;
  if ( ((float)(z - CCamera::CalculateGroundHeight(&TheCamera, 0)) <= 50.0
     || (CStreaming::ms_numPedsLoaded < 5 || !CStreaming::RemoveLoadedZoneModel())
     && (CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) < 5 || !CStreaming::RemoveLoadedVehicle()))
    && (bLoadingScene
     || !CStreaming::DeleteLeastUsedEntityRwObject(0, ignoreFlags)
     && (CStreaming::ms_numPedsLoaded < 5 || !CStreaming::RemoveLoadedZoneModel())
     && (CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) <= 7
      && (CGame::currArea == AREA_MAIN_MAP || CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) < 5)
      || !CStreaming::RemoveLoadedVehicle())) )
  {
    v14 = 1;
    if ( CStreaming::DeleteLeastUsedEntityRwObject(1, ignoreFlags) )
      return v14;
    if ( (CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) <= 7
       && (CGame::currArea == AREA_MAIN_MAP || CLoadedCarGroup::CountMembers(&CStreaming::ms_vehiclesLoaded) < 5)
       || !CStreaming::RemoveLoadedVehicle())
      && (CStreaming::ms_numPedsLoaded < 5 || !CStreaming::RemoveLoadedZoneModel()) )
    {
      return 0;
    }
  }
  return 1;
}
// 61A7C: using guessed type Elf32_Sym stru_61A7C;

//----- (002D5780) --------------------------------------------------------
int CStreaming::RemoveLoadedZoneModel()
{
  int32 v1; // r0

  if ( CStreaming::ms_currentZoneType == -1
    || (CCheat::m_aCheatsActive[52] | CCheat::m_aCheatsActive[50] | CCheat::m_aCheatsActive[48] | CCheat::m_aCheatsActive[47] | CCheat::m_aCheatsActive[49] | CCheat::m_aCheatsActive[53] | CCheat::m_aCheatsActive[78] | CCheat::m_aCheatsActive[83]) << 24 )
  {
    return 0;
  }
  v1 = CStreaming::ms_pedsLoaded[0];
  if ( CStreaming::ms_pedsLoaded[0] < 0
    || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[0]].m_status != 1
    || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[0]].m_flags & 6) != 0
    || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[0]]->m_numRefs )
  {
    v1 = CStreaming::ms_pedsLoaded[1];
    if ( CStreaming::ms_pedsLoaded[1] <= -1
      || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[1]].m_status != 1
      || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[1]].m_flags & 6) != 0
      || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[1]]->m_numRefs )
    {
      v1 = CStreaming::ms_pedsLoaded[2];
      if ( CStreaming::ms_pedsLoaded[2] < 0
        || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[2]].m_status != 1
        || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[2]].m_flags & 6) != 0
        || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[2]]->m_numRefs )
      {
        v1 = CStreaming::ms_pedsLoaded[3];
        if ( CStreaming::ms_pedsLoaded[3] < 0
          || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[3]].m_status != 1
          || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[3]].m_flags & 6) != 0
          || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[3]]->m_numRefs )
        {
          v1 = CStreaming::ms_pedsLoaded[4];
          if ( CStreaming::ms_pedsLoaded[4] < 0
            || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[4]].m_status != 1
            || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[4]].m_flags & 6) != 0
            || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[4]]->m_numRefs )
          {
            v1 = CStreaming::ms_pedsLoaded[5];
            if ( CStreaming::ms_pedsLoaded[5] < 0
              || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[5]].m_status != 1
              || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[5]].m_flags & 6) != 0
              || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[5]]->m_numRefs )
            {
              v1 = CStreaming::ms_pedsLoaded[6];
              if ( CStreaming::ms_pedsLoaded[6] < 0
                || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[6]].m_status != 1
                || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[6]].m_flags & 6) != 0
                || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[6]]->m_numRefs )
              {
                v1 = CStreaming::ms_pedsLoaded[7];
                if ( CStreaming::ms_pedsLoaded[7] < 0
                  || CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[7]].m_status != 1
                  || (CStreaming::ms_aInfoForModel[CStreaming::ms_pedsLoaded[7]].m_flags & 6) != 0
                  || CModelInfo::ms_modelInfoPtrs[CStreaming::ms_pedsLoaded[7]]->m_numRefs )
                {
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  CStreaming::RemoveModel(v1);
  return 1;
}

//----- (002D5A80) --------------------------------------------------------
bool __fastcall CStreaming::DeleteLeastUsedEntityRwObject(bool bVisibleOnly, uint32 ignoreFlags)
{
  CLinkList<CEntity *> *m_pPrev; // r10
  CPlayerPed *PlayerPed; // r0
  float farPlane; // s16
  CEntity *v5; // r1
  CEntity *v6; // r2
  CMatrix *m_pMat; // r3
  float *p_tx; // r4
  CSimpleTransform *p_m_transform; // r2
  float v10; // s22
  float v11; // s26
  float v12; // s24
  int32 v13; // r6
  float x; // s30
  float y; // s19
  float z; // s17
  CEntity *v17; // r0
  float i; // s28
  int v19; // r0
  bool v20; // zf
  float v21; // s0
  __int64 v22; // kr00_8
  CPedFlags *p_m_nPedFlags; // [sp+8h] [bp-88h]
  CPlayerPed *v25; // [sp+14h] [bp-7Ch]
  _BOOL4 v26; // [sp+20h] [bp-70h]
  unsigned __int8 v27; // [sp+28h] [bp-68h]

  v26 = bVisibleOnly;
  v27 = ignoreFlags;
  m_pPrev = (CLinkList<CEntity *> *)CStreaming::ms_rwObjectInstances.m_lastLink.m_pPrev;
  PlayerPed = FindPlayerPed(-1);
  if ( m_pPrev == &CStreaming::ms_rwObjectInstances )
    return 0;
  farPlane = TheCamera.m_pRwCamera->farPlane;
  p_m_nPedFlags = &PlayerPed->m_nPedFlags;
  v25 = PlayerPed;
  while ( 1 )
  {
    v22 = *(_QWORD *)&m_pPrev->m_firstLink.item;
    m_pPrev = (CLinkList<CEntity *> *)m_pPrev->m_firstLink.m_pPrev;
    if ( (*(_DWORD *)(v22 + 28) & 0x2400) == 0 )
    {
      v5 = *(CEntity **)(v22 + 52);
      v6 = v5;
      if ( !v5 )
        v6 = (CEntity *)v22;
      m_pMat = v6->m_pMat;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v6->m_transform.m_translate.x;
      p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      v10 = *p_tx;
      v11 = p_tx[1];
      v12 = p_tx[2];
      if ( !TheCamera.m_pMat )
        p_m_transform = &TheCamera.m_transform;
      v13 = *(__int16 *)(v22 + 38);
      x = p_m_transform->m_translate.x;
      y = p_m_transform->m_translate.y;
      z = p_m_transform->m_translate.z;
      v17 = (CEntity *)v22;
      for ( i = (float)(CModelInfo::ms_modelInfoPtrs[v13]->m_lodDistance * TheCamera.LODDistMultiplier)
              * CRenderer::ms_lowLodDistScale; v5; v5 = v5->m_pLod )
        v17 = v5;
      if ( (*(_DWORD *)(v22 + 28) & 0x100) == 0 )
        i = CModelInfo::ms_modelInfoPtrs[v13]->m_lodDistance * TheCamera.LODDistMultiplier;
      if ( bLoadingScene || v26 && !CEntity::GetIsOnScreen(v17) )
        goto LABEL_35;
      v19 = *(unsigned __int8 *)(v22 + 51);
      v20 = v19 == 13;
      if ( v19 != 13 )
        v20 = CGame::currArea == v19;
      if ( !v20
        || (v21 = sqrtf(
                    (float)((float)((float)(v10 - x) * (float)(v10 - x)) + (float)((float)(v11 - y) * (float)(v11 - y)))
                  + (float)((float)(v12 - z) * (float)(v12 - z))),
            v21 > (float)((float)(i + (float)(FadeDistMult * 22.0)) + (float)((float)(FadeDistMult * 22.0) + 10.0)))
        || v21 > (float)(farPlane
                       + CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v22 + 38)]->m_pColModel->m_sphereBound.m_fRadius) )
      {
LABEL_35:
        if ( (unsigned __int16)CStreaming::ms_aInfoForModel[v13].m_nextIndex != 0xFFFF
          && (CStreaming::ms_aInfoForModel[v13].m_flags & v27) == 0
          && (!v25 || *((unsigned __int8 *)p_m_nPedFlags + 1) << 31 || v25->m_pEntityStandingOn != (CEntity *)v22) )
        {
          (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v22 + 36))(v22);
          if ( !CModelInfo::ms_modelInfoPtrs[v13]->m_numRefs )
            break;
        }
      }
    }
    if ( m_pPrev == &CStreaming::ms_rwObjectInstances )
      return 0;
  }
  CStreaming::RemoveModel(v13);
  return 1;
}

//----- (002D5CD8) --------------------------------------------------------
void __fastcall CStreaming::DeleteRwObjectsBehindCamera(int32 memory)
{
  CSimpleTransform *p_tx; // r1
  float y; // s18
  float v4; // r5
  float v5; // r0
  float v6; // s6
  int v7; // r5
  float yy; // s18
  float xy; // s16
  int v10; // r3
  int v11; // r2
  int v12; // r0
  int v13; // r6
  int v14; // r10
  int v15; // r0
  int v16; // r0
  int v17; // r6
  int v18; // r0
  int v19; // r0
  uint16 v20; // r0
  uint16 v21; // r0
  int v22; // r10
  int v23; // r11
  int v24; // r0
  int v25; // r8
  int v26; // r5
  int v27; // r0
  int v28; // r6
  char v29; // r8
  int v30; // r11
  int v31; // r0
  int v32; // r9
  bool v33; // cc
  int v34; // r0
  int v35; // r11
  int v36; // r9
  int v37; // r0
  int v38; // r8
  uint16 v39; // r0
  uint16 v40; // r0
  uint16 v41; // r0
  int v42; // r0
  int v43; // r5
  int v44; // r11
  int v45; // r0
  int v46; // r6
  int v47; // r1
  int v48; // r0
  int v49; // r6
  int v50; // r11
  int v51; // r0
  int v52; // r5
  int v53; // r11
  char v54; // r8
  int v55; // r6
  int v56; // r0
  int v57; // r5
  _BOOL4 v58; // r0
  int v59; // r5
  int v60; // r6
  int v61; // r8
  char v62; // r11
  int v63; // r0
  int v64; // r10
  char v65; // [sp+4h] [bp-5Ch]
  char v66; // [sp+4h] [bp-5Ch]
  int v67; // [sp+8h] [bp-58h]
  int v68; // [sp+8h] [bp-58h]
  int v69; // [sp+Ch] [bp-54h]
  int v70; // [sp+Ch] [bp-54h]
  int v71; // [sp+Ch] [bp-54h]
  int v72; // [sp+Ch] [bp-54h]
  int v73; // [sp+Ch] [bp-54h]
  int v74; // [sp+10h] [bp-50h]
  int v75; // [sp+10h] [bp-50h]
  int v76; // [sp+10h] [bp-50h]
  int v77; // [sp+10h] [bp-50h]
  int v78; // [sp+14h] [bp-4Ch]
  int v79; // [sp+14h] [bp-4Ch]
  int v80; // [sp+14h] [bp-4Ch]
  int v81; // [sp+14h] [bp-4Ch]
  int v82; // [sp+14h] [bp-4Ch]
  int v83; // [sp+18h] [bp-48h]
  char v84; // [sp+18h] [bp-48h]
  int v85; // [sp+24h] [bp-3Ch]
  int v86; // [sp+24h] [bp-3Ch]

  if ( CStreaming::ms_memoryUsed < memory )
    return;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  v4 = floorf((float)(p_tx->m_translate.x / 50.0) + 60.0);
  v5 = floorf((float)(y / 50.0) + 60.0);
  v6 = v4;
  v7 = 119;
  yy = TheCamera.m_cameraMatrix.yy;
  xy = TheCamera.m_cameraMatrix.xy;
  v10 = (int)v5;
  v11 = (int)v6;
  if ( fabsf(TheCamera.m_cameraMatrix.xy) <= fabsf(TheCamera.m_cameraMatrix.yy) )
  {
    v16 = v11 + 10;
    v17 = 0;
    if ( v11 + 10 >= 119 )
      v16 = 119;
    v86 = v16;
    v18 = v11 - 10;
    if ( v11 - 10 <= 0 )
      v18 = 0;
    v83 = v18;
    if ( TheCamera.m_cameraMatrix.yy <= 0.0 )
    {
      v17 = v10 + 10;
      if ( v10 + 10 >= 119 )
        v17 = 119;
      if ( v10 + 2 < 119 )
        v7 = v10 + 2;
      v19 = -1;
    }
    else
    {
      v7 = v10 - 2;
      if ( v10 - 2 <= 0 )
        v7 = 0;
      if ( v10 - 10 > 0 )
        v17 = v10 - 10;
      v19 = 1;
    }
    v75 = v10;
    v78 = v19;
    if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
    {
      CWorld::ClearScanCodes();
      v21 = 1;
    }
    else
    {
      v21 = CWorld::ms_nCurrentScanCode + 1;
    }
    CWorld::ms_nCurrentScanCode = v21;
    if ( v17 == v7 )
    {
LABEL_50:
      if ( yy <= 0.0 )
      {
        v25 = v75 - 10;
        v26 = v75 + 2;
        v27 = -1;
        if ( v75 - 10 <= 0 )
          v25 = 0;
        if ( v26 >= 119 )
          v26 = 119;
      }
      else
      {
        v25 = v75 + 10;
        v26 = v75 - 2;
        v27 = 1;
        if ( v75 + 10 >= 119 )
          v25 = 119;
        if ( v26 <= 0 )
          v26 = 0;
      }
      v80 = v27;
      if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
      {
        CWorld::ClearScanCodes();
        v40 = 1;
      }
      else
      {
        v40 = CWorld::ms_nCurrentScanCode + 1;
      }
      CWorld::ms_nCurrentScanCode = v40;
      if ( v25 == v26 )
        goto LABEL_154;
      v70 = v25;
      v77 = v26;
      do
      {
        if ( v83 <= v86 )
        {
          v42 = v25;
          if ( v25 <= 0 )
            v42 = 0;
          if ( v42 >= 119 )
            v42 = 119;
          v43 = v83;
          v44 = 120 * v42;
          do
          {
            v45 = 119;
            if ( v43 < 119 )
              v45 = v43;
            v46 = v45 + v44;
            if ( CStreaming::DeleteRwObjectsNotInFrustumInSectorList(
                   &CWorld::ms_aSectors[v45 + v44].m_buildingPtrListArray,
                   memory)
              || CStreaming::DeleteRwObjectsNotInFrustumInSectorList(
                   &CWorld::ms_aSectors[v46].m_dummyPtrListArray,
                   memory)
              || CStreaming::DeleteRwObjectsNotInFrustumInSectorList(
                   &CWorld::ms_aRepeatSectors[v43 & 0xF | (unsigned __int8)(16 * v25)].m_ptrListArray[2],
                   memory) )
            {
              return;
            }
            v33 = v43++ < v86;
          }
          while ( v33 );
        }
        v25 -= v80;
      }
      while ( v25 != v77 );
      v47 = v70;
      if ( v70 == v77 )
        goto LABEL_154;
      while ( 1 )
      {
        v71 = v47;
        if ( v83 <= v86 )
          break;
LABEL_134:
        v47 = v71 - v80;
        if ( v71 - v80 == v77 )
          goto LABEL_154;
      }
      v48 = v47;
      if ( v47 <= 0 )
        v48 = 0;
      if ( v48 >= 119 )
        v48 = 119;
      v49 = v83;
      v50 = 120 * v48;
      while ( 1 )
      {
        v51 = 119;
        if ( v49 < 119 )
          v51 = v49;
        v52 = v51 + v50;
        if ( CStreaming::DeleteRwObjectsBehindCameraInSectorList(
               &CWorld::ms_aSectors[v51 + v50].m_buildingPtrListArray,
               memory)
          || CStreaming::DeleteRwObjectsBehindCameraInSectorList(&CWorld::ms_aSectors[v52].m_dummyPtrListArray, memory)
          || CStreaming::DeleteRwObjectsBehindCameraInSectorList(
               &CWorld::ms_aRepeatSectors[v49 & 0xF | (unsigned __int8)(16 * v71)].m_ptrListArray[2],
               memory) )
        {
          break;
        }
        v33 = v49++ < v86;
        if ( !v33 )
          goto LABEL_134;
      }
    }
    else
    {
      while ( v83 > v86 )
      {
LABEL_86:
        v17 += v78;
        if ( v17 == v7 )
          goto LABEL_50;
      }
      v34 = v17;
      if ( v17 <= 0 )
        v34 = 0;
      if ( v34 >= 119 )
        v34 = 119;
      v35 = v83;
      v36 = 120 * v34;
      while ( 1 )
      {
        v37 = 119;
        if ( v35 < 119 )
          v37 = v35;
        v38 = v37 + v36;
        if ( CStreaming::DeleteRwObjectsBehindCameraInSectorList(
               &CWorld::ms_aSectors[v37 + v36].m_buildingPtrListArray,
               memory)
          || CStreaming::DeleteRwObjectsBehindCameraInSectorList(&CWorld::ms_aSectors[v38].m_dummyPtrListArray, memory)
          || CStreaming::DeleteRwObjectsBehindCameraInSectorList(
               &CWorld::ms_aRepeatSectors[v35 & 0xF | (unsigned __int8)(16 * v17)].m_ptrListArray[2],
               memory) )
        {
          break;
        }
        v33 = v35++ < v86;
        if ( !v33 )
          goto LABEL_86;
      }
    }
  }
  else
  {
    v12 = v10 + 10;
    v13 = v10 - 10;
    v14 = 0;
    if ( v10 + 10 >= 119 )
      v12 = 119;
    v85 = v12;
    if ( v13 <= 0 )
      v13 = 0;
    if ( TheCamera.m_cameraMatrix.xy <= 0.0 )
    {
      v14 = v11 + 10;
      if ( v11 + 10 >= 119 )
        v14 = 119;
      if ( v11 + 2 < 119 )
        v7 = v11 + 2;
      v15 = -1;
    }
    else
    {
      v7 = v11 - 2;
      if ( v11 - 2 <= 0 )
        v7 = 0;
      if ( v11 - 10 > 0 )
        v14 = v11 - 10;
      v15 = 1;
    }
    v69 = (int)v6;
    v74 = v15;
    if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
    {
      CWorld::ClearScanCodes();
      v20 = 1;
    }
    else
    {
      v20 = CWorld::ms_nCurrentScanCode + 1;
    }
    CWorld::ms_nCurrentScanCode = v20;
    if ( v14 == v7 )
    {
LABEL_42:
      if ( xy <= 0.0 )
      {
        v22 = v69 - 10;
        v23 = v69 + 2;
        v24 = -1;
        if ( v69 - 10 <= 0 )
          v22 = 0;
        if ( v23 >= 119 )
          v23 = 119;
      }
      else
      {
        v22 = v69 + 10;
        v23 = v69 - 2;
        v24 = 1;
        if ( v69 + 10 >= 119 )
          v22 = 119;
        if ( v23 <= 0 )
          v23 = 0;
      }
      v76 = v24;
      if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
      {
        CWorld::ClearScanCodes();
        v39 = 1;
      }
      else
      {
        v39 = CWorld::ms_nCurrentScanCode + 1;
      }
      CWorld::ms_nCurrentScanCode = v39;
      if ( v22 == v23 )
      {
LABEL_102:
        if ( v39 == 0xFFFF )
        {
          CWorld::ClearScanCodes();
          v41 = 1;
        }
        else
        {
          v41 = v39 + 1;
        }
        CWorld::ms_nCurrentScanCode = v41;
        if ( v22 == v23 )
        {
LABEL_154:
          if ( CStreaming::ms_memoryUsed >= memory )
          {
            do
              v58 = CStreaming::RemoveLeastUsedModel(0);
            while ( CStreaming::ms_memoryUsed >= memory && v58 );
          }
          return;
        }
        v82 = v13;
        v84 = 16 * v13;
        v73 = v23;
        while ( 1 )
        {
          v68 = v22;
          if ( v13 <= v85 )
            break;
LABEL_172:
          v13 = v82;
          v22 = v68 - v76;
          if ( v68 - v76 == v73 )
            goto LABEL_154;
        }
        v59 = v22 & 0xF;
        v60 = v22;
        if ( v22 <= 0 )
          v60 = 0;
        if ( v60 >= 119 )
          v60 = 119;
        v61 = v82;
        v62 = v84;
        while ( 1 )
        {
          v63 = 119;
          if ( v61 < 119 )
            v63 = v61;
          v64 = v60 + 120 * v63;
          if ( CStreaming::DeleteRwObjectsBehindCameraInSectorList(
                 &CWorld::ms_aSectors[v64].m_buildingPtrListArray,
                 memory)
            || CStreaming::DeleteRwObjectsBehindCameraInSectorList(
                 &CWorld::ms_aSectors[v64].m_dummyPtrListArray,
                 memory)
            || CStreaming::DeleteRwObjectsBehindCameraInSectorList(
                 &CWorld::ms_aRepeatSectors[v62 & 0xF0 | v59].m_ptrListArray[2],
                 memory) )
          {
            break;
          }
          v62 += 16;
          v33 = v61++ < v85;
          if ( !v33 )
            goto LABEL_172;
        }
      }
      else
      {
        v66 = 16 * v13;
        v81 = v13;
        v67 = v22;
        v72 = v23;
        while ( v13 > v85 )
        {
LABEL_150:
          v23 = v72;
          v13 = v81;
          v22 -= v76;
          if ( v22 == v72 )
          {
            v22 = v67;
            v39 = CWorld::ms_nCurrentScanCode;
            goto LABEL_102;
          }
        }
        v53 = v22;
        if ( v22 <= 0 )
          v53 = 0;
        if ( v53 >= 119 )
          v53 = 119;
        v54 = v66;
        v55 = v81;
        while ( 1 )
        {
          v56 = 119;
          if ( v55 < 119 )
            v56 = v55;
          v57 = v53 + 120 * v56;
          if ( CStreaming::DeleteRwObjectsNotInFrustumInSectorList(
                 &CWorld::ms_aSectors[v57].m_buildingPtrListArray,
                 memory)
            || CStreaming::DeleteRwObjectsNotInFrustumInSectorList(
                 &CWorld::ms_aSectors[v57].m_dummyPtrListArray,
                 memory)
            || CStreaming::DeleteRwObjectsNotInFrustumInSectorList(
                 &CWorld::ms_aRepeatSectors[v54 & 0xF0 | v22 & 0xF].m_ptrListArray[2],
                 memory) )
          {
            break;
          }
          v54 += 16;
          v33 = v55++ < v85;
          if ( !v33 )
            goto LABEL_150;
        }
      }
    }
    else
    {
      v65 = 16 * v13;
      v79 = v13;
      while ( v13 > v85 )
      {
LABEL_70:
        v13 = v79;
        v14 += v74;
        if ( v14 == v7 )
          goto LABEL_42;
      }
      v28 = v14;
      if ( v14 <= 0 )
        v28 = 0;
      if ( v28 >= 119 )
        v28 = 119;
      v29 = v65;
      v30 = v79;
      while ( 1 )
      {
        v31 = 119;
        if ( v30 < 119 )
          v31 = v30;
        v32 = v28 + 120 * v31;
        if ( CStreaming::DeleteRwObjectsBehindCameraInSectorList(
               &CWorld::ms_aSectors[v32].m_buildingPtrListArray,
               memory)
          || CStreaming::DeleteRwObjectsBehindCameraInSectorList(&CWorld::ms_aSectors[v32].m_dummyPtrListArray, memory)
          || CStreaming::DeleteRwObjectsBehindCameraInSectorList(
               &CWorld::ms_aRepeatSectors[v29 & 0xF0 | v14 & 0xF].m_ptrListArray[2],
               memory) )
        {
          break;
        }
        v29 += 16;
        v33 = v30++ < v85;
        if ( !v33 )
          goto LABEL_70;
      }
    }
  }
}

//----- (002D64BC) --------------------------------------------------------
CLink<CEntity *> *__fastcall CStreaming::AddEntity(CEntity *pEntity)
{
  CLink<CEntity *> *result; // r0
  __int64 v3; // kr00_8
  CLinkList<CEntity *> *p_m_lastLink; // r1
  __int64 v5; // kr08_8

  if ( (*(_BYTE *)&pEntity->m_info & 6) == 2 )
    return 0;
  result = CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext;
  if ( CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext == &CStreaming::ms_rwObjectInstances.m_lastFreeLink )
    goto LABEL_4;
  v3 = *(_QWORD *)&CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->m_pPrev;
  CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->item = pEntity;
  *(_DWORD *)(HIDWORD(v3) + 4) = v3;
  result->m_pPrev->m_pNext = result->m_pNext;
  result->m_pNext = CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext;
  CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext->m_pPrev = result;
  result->m_pPrev = (CLink<CEntity *> *)&CStreaming::ms_rwObjectInstances;
  CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext = result;
  if ( !result )
  {
LABEL_4:
    p_m_lastLink = (CLinkList<CEntity *> *)&CStreaming::ms_rwObjectInstances.m_lastLink;
    while ( 1 )
    {
      p_m_lastLink = (CLinkList<CEntity *> *)p_m_lastLink->m_firstLink.m_pPrev;
      if ( p_m_lastLink == &CStreaming::ms_rwObjectInstances )
        break;
      if ( (*((_BYTE *)&p_m_lastLink->m_firstLink.item->m_nFlags + 1) & 0x24) == 0 )
      {
        (*((void (__fastcall **)(CEntity *))p_m_lastLink->m_firstLink.item->_vptr$CPlaceable + 9))(p_m_lastLink->m_firstLink.item);
        break;
      }
    }
    result = CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext;
    if ( CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext != &CStreaming::ms_rwObjectInstances.m_lastFreeLink )
    {
      v5 = *(_QWORD *)&CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->m_pPrev;
      CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->item = pEntity;
      *(_DWORD *)(HIDWORD(v5) + 4) = v5;
      result->m_pPrev->m_pNext = result->m_pNext;
      result->m_pNext = CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext;
      CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext->m_pPrev = result;
      result->m_pPrev = (CLink<CEntity *> *)&CStreaming::ms_rwObjectInstances;
      CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext = result;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (002D6578) --------------------------------------------------------
void CStreaming::StartRenderEntities()
{
  pCurrentRenderLink = (CLink<CEntity *> *)&CStreaming::ms_rwObjectInstances;
}

//----- (002D6590) --------------------------------------------------------
void __fastcall CStreaming::RenderEntity(CLink<CEntity *> *pLink)
{
  CLink<CEntity *> *v1; // r1

  if ( pLink )
  {
    v1 = pCurrentRenderLink;
    if ( pCurrentRenderLink != pLink )
    {
      pLink->m_pNext->m_pPrev = pLink->m_pPrev;
      pLink->m_pPrev->m_pNext = pLink->m_pNext;
      pLink->m_pNext = v1->m_pNext;
      v1->m_pNext->m_pPrev = pLink;
      pLink->m_pPrev = v1;
      v1->m_pNext = pLink;
      pCurrentRenderLink = pLink;
    }
  }
}

//----- (002D65C8) --------------------------------------------------------
void __fastcall CStreaming::RemoveEntity(CLink<CEntity *> *pLink)
{
  CLink<CEntity *> *m_pPrev; // r1

  if ( pLink )
  {
    m_pPrev = pLink->m_pPrev;
    if ( pCurrentRenderLink == pLink )
      pCurrentRenderLink = pLink->m_pPrev;
    pLink->m_pNext->m_pPrev = m_pPrev;
    pLink->m_pPrev->m_pNext = pLink->m_pNext;
    pLink->m_pNext = CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext;
    CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->m_pPrev = pLink;
    pLink->m_pPrev = &CStreaming::ms_rwObjectInstances.m_firstFreeLink;
    CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext = pLink;
  }
}

//----- (002D6610) --------------------------------------------------------
bool __fastcall CStreaming::DeleteRwObjectsBehindCameraInSectorList(CPtrList *list, int32 memory)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v3; // kr00_8
  char v4; // r1
  int32 v5; // r9

  m_pHead = list->m_pHead;
  if ( !list->m_pHead )
    return 0;
  while ( 1 )
  {
    v3 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v3.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      v4 = *((_BYTE *)v3.m_pVoid + 29);
      *((_WORD *)v3.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      if ( (v4 & 0x24) == 0 )
      {
        if ( *((_DWORD *)v3.m_pVoid + 6) )
        {
          v5 = *((__int16 *)v3.m_pVoid + 19);
          if ( (unsigned __int16)CStreaming::ms_aInfoForModel[v5].m_nextIndex != 0xFFFF
            && FindPlayerPed(-1)->m_pEntityStandingOn != v3.m_pVoid )
          {
            (*(void (__fastcall **)(void *))(*(_DWORD *)v3.m_pVoid + 36))(v3.m_pVoid);
            if ( !CModelInfo::ms_modelInfoPtrs[v5]->m_numRefs )
            {
              CStreaming::RemoveModel(v5);
              if ( CStreaming::ms_memoryUsed < memory )
                break;
            }
          }
        }
      }
    }
    if ( !m_pHead )
      return 0;
  }
  return 1;
}

//----- (002D66C8) --------------------------------------------------------
bool __fastcall CStreaming::DeleteRwObjectsNotInFrustumInSectorList(CPtrList *list, int32 memory)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v4; // kr00_8
  int32 v5; // r9

  m_pHead = list->m_pHead;
  if ( !list->m_pHead )
    return 0;
  while ( 1 )
  {
    v4 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v4.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      *((_WORD *)v4.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      if ( (*((_BYTE *)v4.m_pVoid + 29) & 0x24) == 0
        && *((_DWORD *)v4.m_pVoid + 6)
        && (!CEntity::IsVisible((CEntity *)v4.m_pVoid) || (*((_BYTE *)v4.m_pVoid + 30) & 2) != 0) )
      {
        v5 = *((__int16 *)v4.m_pVoid + 19);
        if ( (unsigned __int16)CStreaming::ms_aInfoForModel[v5].m_nextIndex != 0xFFFF )
        {
          (*(void (__fastcall **)(void *))(*(_DWORD *)v4.m_pVoid + 36))(v4.m_pVoid);
          if ( !CModelInfo::ms_modelInfoPtrs[v5]->m_numRefs )
          {
            CStreaming::RemoveModel(v5);
            if ( CStreaming::ms_memoryUsed < memory )
              break;
          }
        }
      }
    }
    if ( !m_pHead )
      return 0;
  }
  return 1;
}

//----- (002D6788) --------------------------------------------------------
void __fastcall CStreaming::SetModelIsDeletable(int32 index)
{
  int32 v1; // r12
  CStreamingInfo *v2; // r1
  uint8 m_flags; // r2
  CStreamingInfo *v4; // r0
  CStreamingInfo *v5; // r3
  int16 v6; // r4

  v1 = index;
  v2 = &CStreaming::ms_aInfoForModel[index];
  m_flags = v2->m_flags;
  v2->m_flags = m_flags & 0xFD;
  if ( (m_flags & 4) == 0 )
  {
    if ( CStreaming::ms_aInfoForModel[index].m_status == 1 )
    {
      if ( (unsigned __int16)v2->m_nextIndex == 0xFFFF )
      {
        v4 = CStreaming::ms_pStartLoadedList;
        v5 = CStreamingInfo::ms_pArrayBase;
        v2->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v6 = -13107 * ((unsigned int)((char *)v2 - (char *)v5) >> 2);
        CStreaming::ms_aInfoForModel[v1].m_prevIndex = -13107 * ((unsigned int)((char *)v4 - (char *)v5) >> 2);
        v4->m_nextIndex = v6;
        CStreamingInfo::ms_pArrayBase[v2->m_nextIndex].m_prevIndex = v6;
      }
    }
    else if ( (m_flags & 8) == 0 )
    {
      CStreaming::RemoveModel(index);
    }
  }
}

//----- (002D6834) --------------------------------------------------------
void __fastcall CStreaming::RequestSpecialModel(int32 index, const unsigned __int8 *pName, int32 flags)
{
  CBaseModelInfo *v6; // r8
  uint32 m_cdSize; // r0
  int32 m_nSize; // r0
  int v9; // r5
  int v10; // r4
  CPed *v11; // r6
  int32 v12; // r0
  int v13; // r4
  int v14; // r5
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r9
  CObject *v16; // r6
  uint32 m_hashKey; // r4
  int v18; // r1
  CBaseModelInfo *v19; // r0
  CBaseModelInfo *v20; // r3
  int m_txdIndex; // r0
  int32 v22; // r6
  const char *v23; // r2
  CBaseModelInfo *v24; // r0
  const unsigned __int8 *v25; // r1
  uint32 v26; // r1
  uint8 v27; // r2^3
  CStreamingInfo *v28; // r0
  unsigned __int8 *pString; // [sp+4h] [bp-2Ch]
  int32 v30; // [sp+8h] [bp-28h]
  uint32 v31; // [sp+Ch] [bp-24h] BYREF
  uint32 v32[8]; // [sp+10h] [bp-20h] BYREF

  v6 = CModelInfo::ms_modelInfoPtrs[index];
  if ( CKeyGen::GetUppercaseKey(pName) == v6->m_hashKey
    && (m_cdSize = CStreaming::ms_aInfoForModel[index].m_cdSize) != 0 )
  {
    v31 = CStreaming::ms_aInfoForModel[index].m_cdPosn
        + CStreaming::ms_files[CStreaming::ms_aInfoForModel[index].m_image].m_lsn;
    v32[0] = m_cdSize;
  }
  else
  {
    pString = (unsigned __int8 *)pName;
    v30 = flags;
    if ( v6->m_numRefs >= 1 )
    {
      m_nSize = CPools::ms_pPedPool->m_nSize;
      if ( m_nSize )
      {
        v9 = m_nSize - 1;
        v10 = 1996 * m_nSize - 1996;
        do
        {
          if ( (CPools::ms_pPedPool->m_aFlags[v9] & 0x80u) == 0 )
          {
            v11 = (CPed *)&(*CPools::ms_pPedPool->m_aStorage)[v10];
            if ( v11 )
            {
              if ( v11->m_nModelIndex == index && !CPed::IsPlayer(v11) && CPed::CanBeDeletedEvenInVehicle(v11) )
                CTheScripts::RemoveThisPed(v11);
            }
          }
          if ( --v9 == -1 )
            break;
          v10 -= 1996;
        }
        while ( v6->m_numRefs > 0 );
      }
      v12 = CPools::ms_pObjectPool->m_nSize;
      if ( v12 )
      {
        v13 = v12 - 1;
        v14 = 420 * v12 - 420;
        do
        {
          if ( v6->m_numRefs < 1 )
            break;
          if ( (CPools::ms_pObjectPool->m_aFlags[v13] & 0x80u) == 0 )
          {
            m_aStorage = CPools::ms_pObjectPool->m_aStorage;
            v16 = (CObject *)&(*CPools::ms_pObjectPool->m_aStorage)[v14];
            if ( v16 )
            {
              if ( v16->m_nModelIndex == index && CObject::CanBeDeleted(v16) )
              {
                CWorld::Remove(v16);
                CWorld::RemoveReferencesToDeletedObject(v16);
                (*(void (__fastcall **)(CObject *))(*(_DWORD *)&(*m_aStorage)[v14] + 4))(v16);
              }
            }
          }
          --v13;
          v14 -= 420;
        }
        while ( v13 != -1 );
      }
    }
    m_hashKey = v6->m_hashKey;
    v6->m_hashKey = CKeyGen::GetUppercaseKey(pString);
    strcpy((char *)v6->m_modelName, (const char *)pString);
    v18 = 0;
    v19 = 0;
    do
    {
      v20 = CModelInfo::ms_modelInfoPtrs[v18];
      if ( v20 && v20->m_hashKey == m_hashKey )
        v19 = CModelInfo::ms_modelInfoPtrs[v18];
      ++v18;
    }
    while ( v18 != 1000 );
    if ( v19 )
    {
      m_txdIndex = (unsigned __int16)v19->m_txdIndex;
      flags = v30;
      if ( m_txdIndex == 0xFFFF
        || (v22 = (__int16)m_txdIndex, !*(_DWORD *)&CTxdStore::ms_pTxdPool->m_aStorage[(__int16)m_txdIndex][0]) )
      {
        CStreaming::RemoveModel(index);
      }
      else
      {
        CTxdStore::AddRef((__int16)m_txdIndex);
        CStreaming::RemoveModel(index);
        CTxdStore::RemoveRefWithoutDelete(v22);
      }
    }
    else
    {
      CStreaming::RemoveModel(index);
      flags = v30;
    }
    CDirectory::FindItem(CStreaming::ms_pExtraObjectsDir, pString, &v31, v32);
    CBaseModelInfo::ClearTexDictionary(v6);
    if ( CTxdStore::FindTxdSlot(pString) == -1 )
    {
      v25 = "generic";
      v23 = "txd";
      v24 = v6;
    }
    else
    {
      v23 = "gta3";
      v24 = v6;
      v25 = pString;
    }
    CBaseModelInfo::SetTexDictionary(v24, v25, (const unsigned __int8 *)v23);
    v27 = HIBYTE(v31);
    v26 = v32[0];
    v28 = &CStreaming::ms_aInfoForModel[index];
    v28->m_cdPosn = v31 & 0xFFFFFF;
    v28->m_cdSize = v26;
    v28->m_image = v27;
    v28->m_nextModelOnCd = -1;
  }
  CStreaming::RequestModel(index, flags);
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 2D6834: using guessed type uint32 var_20[8];

//----- (002D6A9C) --------------------------------------------------------
void __fastcall CStreaming::RequestPlayerSection(int32 index, const unsigned __int8 *pName, int32 flags)
{
  CBaseModelInfo *v6; // r4
  uint32 v7; // r2
  uint8 v8; // r3^3
  CStreamingInfo *v9; // r0
  uint32 v10; // [sp+0h] [bp-18h] BYREF
  uint32 v11[5]; // [sp+4h] [bp-14h] BYREF

  v6 = CModelInfo::ms_modelInfoPtrs[index];
  if ( CKeyGen::GetUppercaseKey(pName) != v6->m_hashKey )
  {
    CStreaming::RemoveModel(index);
    v6->m_hashKey = CKeyGen::GetUppercaseKey(pName);
    strcpy((char *)v6->m_modelName, (const char *)pName);
    v6->m_flags |= 0x200u;
    CDirectory::FindItem(CStreaming::ms_pExtraObjectsDir, pName, &v10, v11);
    v8 = HIBYTE(v10);
    v7 = v11[0];
    v9 = &CStreaming::ms_aInfoForModel[index];
    v9->m_cdPosn = v10 & 0xFFFFFF;
    v9->m_cdSize = v7;
    v9->m_image = v8;
  }
  CStreaming::RequestModel(index, flags);
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 2D6A9C: using guessed type uint32 var_14[5];

//----- (002D6B30) --------------------------------------------------------
void __fastcall CStreaming::RequestFile(int32 index, int32 posn, int32 size, int32 image, int32 flags)
{
  int32 v7; // r0
  CStreamingInfo *v8; // r4
  int32 v9; // r1
  _DWORD *p_m_cdSize; // r4
  uint32 v11; // r6
  uint32 m_cdSize; // t1
  int *v13; // r8
  CStreamingInfo *v14; // r9
  int v15; // r0
  uint8 *p_m_image; // r9
  int m_image; // t1
  int32 v18; // r0
  uint8 v19; // r6

  v7 = index;
  v8 = &CStreaming::ms_aInfoForModel[v7];
  v9 = flags;
  m_cdSize = v8->m_cdSize;
  p_m_cdSize = &v8->m_cdSize;
  v11 = m_cdSize;
  v13 = p_m_cdSize - 1;
  if ( !m_cdSize )
  {
    p_m_image = &CStreaming::ms_aInfoForModel[v7].m_image;
LABEL_6:
    v19 = image;
    CStreaming::RemoveModel(index);
    *v13 = posn & 0xFFFFFF;
    *p_m_cdSize = size;
    v18 = index;
    *p_m_image = v19;
    v9 = flags;
    goto LABEL_7;
  }
  v14 = &CStreaming::ms_aInfoForModel[v7];
  m_image = v14->m_image;
  p_m_image = &v14->m_image;
  v15 = m_image;
  if ( v11 != size || CStreaming::ms_files[v15].m_lsn + *v13 != (posn | (image << 24)) )
    goto LABEL_6;
  v18 = index;
LABEL_7:
  CStreaming::RequestModel(v18, v9);
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D6BD8) --------------------------------------------------------
void CStreaming::LoadInitialPeds()
{
  CStreaming::RequestModel(7, 2);
  CStreaming::StreamCopModels(1);
}

//----- (002D6BEE) --------------------------------------------------------
void CStreaming::LoadInitialWeapons()
{
  CStreaming::RequestModel(346, 2);
  CStreaming::RequestModel(334, 2);
  CStreaming::RequestModel(345, 2);
}

//----- (002D6C14) --------------------------------------------------------
int32 CStreaming::GetDefaultCopModel()
{
  int32 result; // r0

  result = gCopList[CTheZones::m_CurrLevel];
  if ( CStreaming::ms_aInfoForModel[result].m_status != 1 )
  {
    if ( CStreaming::ms_aInfoForModel[283].m_status == 1 )
    {
      return 283;
    }
    else if ( CStreaming::ms_aInfoForModel[280].m_status == 1 )
    {
      return 280;
    }
    else if ( CStreaming::ms_aInfoForModel[281].m_status == 1 )
    {
      return 281;
    }
    else
    {
      result = -1;
      if ( CStreaming::ms_aInfoForModel[282].m_status == 1 )
        return 282;
    }
  }
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002D6CB4) --------------------------------------------------------
int32 __fastcall CStreaming::GetDefaultCopCarModel(Bool bNoBikes)
{
  bool v1; // zf
  int32 v3; // r1
  int v4; // r2
  int v5; // r0

  v1 = CStreaming::ms_aInfoForModel[284].m_status == 1;
  if ( CStreaming::ms_aInfoForModel[284].m_status == 1 )
    v1 = bNoBikes == 0;
  if ( v1 && gGenerateCopsOnBikes && CStreaming::ms_aInfoForModel[523].m_status == 1 )
    return 523;
  if ( CStreaming::ms_aInfoForModel[gCopList[CTheZones::m_CurrLevel]].m_status != 1
    || (v3 = gCopCarList[CTheZones::m_CurrLevel], CStreaming::ms_aInfoForModel[v3].m_status != 1) )
  {
    v4 = 5;
    if ( bNoBikes )
      v4 = 4;
    v5 = 0;
    while ( 1 )
    {
      if ( CStreaming::ms_aInfoForModel[gCopList[v5]].m_status == 1 )
      {
        v3 = gCopCarList[v5];
        if ( CStreaming::ms_aInfoForModel[v3].m_status == 1 )
          break;
      }
      if ( ++v5 >= v4 )
        return -1;
    }
  }
  return v3;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002D6DA8) --------------------------------------------------------
void __fastcall CStreaming::DisableCopBikes(bool disable)
{
  gDisableCopsOnBikes = disable;
}

//----- (002D6DB4) --------------------------------------------------------
int32 CStreaming::GetDefaultMedicModel()
{
  return gMedicList[CTheZones::m_CurrLevel];
}

//----- (002D6DD0) --------------------------------------------------------
int32 CStreaming::GetDefaultAmbulanceModel()
{
  return gAmbulanceList[CTheZones::m_CurrLevel];
}

//----- (002D6DEC) --------------------------------------------------------
int32 CStreaming::GetDefaultFiremanModel()
{
  return gFiremanList[CTheZones::m_CurrLevel];
}

//----- (002D6E08) --------------------------------------------------------
int32 CStreaming::GetDefaultCabDriverModel()
{
  int32 result; // r0
  eLevelName v1; // r5
  unsigned __int16 v2; // r0

  result = gCabDriverList[CStreaming::GetDefaultCabDriverModel(void)::lastCabbie];
  if ( !CStreaming::ms_aInfoForModel[result].m_status )
  {
    v1 = CTheZones::m_CurrLevel;
    if ( CTheZones::m_CurrLevel )
    {
      v2 = rand();
      CStreaming::GetDefaultCabDriverModel(void)::lastCabbie = (int)(float)((float)((float)v2 * 0.000015259)
                                                                          + (float)((float)v2 * 0.000015259))
                                                             + 2 * v1
                                                             - 2;
      return gCabDriverList[CStreaming::GetDefaultCabDriverModel(void)::lastCabbie];
    }
  }
  return result;
}

//----- (002D6E9C) --------------------------------------------------------
int32 CStreaming::GetDefaultFireEngineModel()
{
  return gFireEngineList[CTheZones::m_CurrLevel];
}

//----- (002D6EB8) --------------------------------------------------------
bool __fastcall CStreaming::StreamAmbulanceAndMedic(bool bInMemory)
{
  _BOOL4 v1; // r9
  eLevelName v2; // r10
  char v3; // r0
  unsigned int v4; // r6
  char v5; // r0
  unsigned int v6; // r6
  char v7; // r0
  unsigned int v8; // r6
  char v9; // r0
  unsigned int v10; // r0
  uint8 m_flags; // r2
  char v12; // r0
  unsigned int v13; // r6
  char v14; // r0
  unsigned int v15; // r6
  bool v16; // zf
  bool result; // r0
  int32 v18; // r5
  int32 v19; // r4

  v1 = bInMemory;
  v2 = CTheZones::m_CurrLevel;
  v3 = CStreaming::ms_aInfoForModel[274].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[274].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[274].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[274].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[274].m_nextIndex == 0xFFFF )
      {
        v4 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[274] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[274].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        CStreaming::ms_aInfoForModel[274].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v4;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[274].m_nextIndex].m_prevIndex = v4;
      }
    }
    else if ( (v3 & 8) == 0 )
    {
      CStreaming::RemoveModel(274);
    }
  }
  v5 = CStreaming::ms_aInfoForModel[276].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[276].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[276].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[276].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[276].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[276].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v6 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[276] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[276].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v6;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[276].m_nextIndex].m_prevIndex = v6;
      }
    }
    else if ( (v5 & 8) == 0 )
    {
      CStreaming::RemoveModel(276);
    }
  }
  v7 = CStreaming::ms_aInfoForModel[275].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[275].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[275].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[275].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[275].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[275].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v8 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[275] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[275].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v8;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[275].m_nextIndex].m_prevIndex = v8;
      }
    }
    else if ( (v7 & 8) == 0 )
    {
      CStreaming::RemoveModel(275);
    }
  }
  v9 = CStreaming::ms_aInfoForModel[416].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[416].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[416].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[416].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[416].m_nextIndex == 0xFFFF )
      {
        v10 = -858993459
            * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[416] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[416].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        CStreaming::ms_aInfoForModel[416].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v10;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[416].m_nextIndex].m_prevIndex = v10;
      }
    }
    else if ( (v9 & 8) == 0 )
    {
      CStreaming::RemoveModel(416);
    }
  }
  m_flags = CStreaming::ms_aInfoForModel[416].m_flags;
  v12 = CStreaming::ms_aInfoForModel[416].m_flags & 0xFD;
  CStreaming::ms_aInfoForModel[416].m_flags &= ~2u;
  if ( (m_flags & 4) == 0 )
  {
    if ( CStreaming::ms_aInfoForModel[416].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[416].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[416].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v13 = -858993459
            * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[416] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[416].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v13;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[416].m_nextIndex].m_prevIndex = v13;
      }
    }
    else if ( (v12 & 8) == 0 )
    {
      CStreaming::RemoveModel(416);
    }
  }
  v14 = CStreaming::ms_aInfoForModel[416].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[416].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[416].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[416].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[416].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[416].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v15 = -858993459
            * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[416] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[416].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v15;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[416].m_nextIndex].m_prevIndex = v15;
      }
    }
    else if ( (v14 & 8) == 0 )
    {
      CStreaming::RemoveModel(416);
    }
  }
  v16 = v2 == LEVEL_GENERIC;
  result = 0;
  if ( v2 )
    v16 = !v1;
  if ( !v16 )
  {
    v18 = gMedicList[v2];
    CStreaming::RequestModel(v18, 8);
    v19 = gAmbulanceList[v2];
    CStreaming::RequestModel(v19, 8);
    return CStreaming::ms_aInfoForModel[v18].m_status == 1 && CStreaming::ms_aInfoForModel[v19].m_status == 1;
  }
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D7354) --------------------------------------------------------
bool __fastcall CStreaming::StreamFireEngineAndFireman(bool bInMemory)
{
  _BOOL4 v1; // r9
  eLevelName v2; // r10
  char v3; // r0
  unsigned int v4; // r6
  char v5; // r0
  unsigned int v6; // r6
  char v7; // r0
  unsigned int v8; // r6
  char v9; // r0
  unsigned int v10; // r4
  uint8 m_flags; // r2
  char v12; // r0
  unsigned int v13; // r6
  char v14; // r0
  unsigned int v15; // r6
  bool v16; // zf
  bool result; // r0
  int32 v18; // r5
  int32 v19; // r4

  v1 = bInMemory;
  v2 = CTheZones::m_CurrLevel;
  v3 = CStreaming::ms_aInfoForModel[277].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[277].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[277].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[277].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[277].m_nextIndex == 0xFFFF )
      {
        v4 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[277] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[277].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        CStreaming::ms_aInfoForModel[277].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v4;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[277].m_nextIndex].m_prevIndex = v4;
      }
    }
    else if ( (v3 & 8) == 0 )
    {
      CStreaming::RemoveModel(277);
    }
  }
  v5 = CStreaming::ms_aInfoForModel[279].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[279].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[279].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[279].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[279].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[279].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v6 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[279] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[279].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v6;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[279].m_nextIndex].m_prevIndex = v6;
      }
    }
    else if ( (v5 & 8) == 0 )
    {
      CStreaming::RemoveModel(279);
    }
  }
  v7 = CStreaming::ms_aInfoForModel[278].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[278].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[278].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[278].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[278].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[278].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v8 = -858993459
           * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[278] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[278].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v8;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[278].m_nextIndex].m_prevIndex = v8;
      }
    }
    else if ( (v7 & 8) == 0 )
    {
      CStreaming::RemoveModel(278);
    }
  }
  v9 = CStreaming::ms_aInfoForModel[407].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[407].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[407].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[407].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[407].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[407].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v10 = -858993459
            * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[407] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[407].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v10;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[407].m_nextIndex].m_prevIndex = v10;
      }
    }
    else if ( (v9 & 8) == 0 )
    {
      CStreaming::RemoveModel(407);
    }
  }
  m_flags = CStreaming::ms_aInfoForModel[407].m_flags;
  v12 = CStreaming::ms_aInfoForModel[407].m_flags & 0xFD;
  CStreaming::ms_aInfoForModel[407].m_flags &= ~2u;
  if ( (m_flags & 4) == 0 )
  {
    if ( CStreaming::ms_aInfoForModel[407].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[407].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[407].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v13 = -858993459
            * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[407] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[407].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v13;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[407].m_nextIndex].m_prevIndex = v13;
      }
    }
    else if ( (v12 & 8) == 0 )
    {
      CStreaming::RemoveModel(407);
    }
  }
  v14 = CStreaming::ms_aInfoForModel[407].m_flags & 0xFD;
  v16 = (CStreaming::ms_aInfoForModel[407].m_flags & 4) == 0;
  CStreaming::ms_aInfoForModel[407].m_flags &= ~2u;
  if ( v16 )
  {
    if ( CStreaming::ms_aInfoForModel[407].m_status == 1 )
    {
      if ( (unsigned __int16)CStreaming::ms_aInfoForModel[407].m_nextIndex == 0xFFFF )
      {
        CStreaming::ms_aInfoForModel[407].m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v15 = -858993459
            * ((unsigned int)((char *)&CStreaming::ms_aInfoForModel[407] - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_aInfoForModel[407].m_prevIndex = -13107
                                                      * ((unsigned int)((char *)CStreaming::ms_pStartLoadedList
                                                                      - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
        CStreaming::ms_pStartLoadedList->m_nextIndex = v15;
        CStreamingInfo::ms_pArrayBase[CStreaming::ms_aInfoForModel[407].m_nextIndex].m_prevIndex = v15;
      }
    }
    else if ( (v14 & 8) == 0 )
    {
      CStreaming::RemoveModel(407);
    }
  }
  v16 = v2 == LEVEL_GENERIC;
  result = 0;
  if ( v2 )
    v16 = !v1;
  if ( !v16 )
  {
    v18 = gFiremanList[v2];
    CStreaming::RequestModel(v18, 8);
    v19 = gFireEngineList[v2];
    CStreaming::RequestModel(v19, 8);
    return CStreaming::ms_aInfoForModel[v18].m_status == 1 && CStreaming::ms_aInfoForModel[v19].m_status == 1;
  }
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D77E4) --------------------------------------------------------
void __fastcall CStreaming::StreamZoneModels_Gangs(const CVector *posn)
{
  __int64 v1; // d8
  __int64 v2; // d9
  __int64 v3; // d10
  __int64 v4; // d11
  Int32 v5; // r0
  Int32 v6; // r9
  int v7; // r11
  int8x8_t v8; // d10
  unsigned __int64 v9; // d11
  int16x8_t v10; // q4
  Int32 i; // r0
  int v12; // r5
  int v13; // r2
  int16 v14; // r0
  UInt32 *v15; // r10
  UInt32 v16; // r0
  UInt32 *v17; // r10
  UInt32 v18; // t1
  int v19; // r5
  int32 v20; // r0
  int32 v21; // r2
  CStreamingInfo *v22; // r1
  uint8 m_flags; // r4
  CStreamingInfo *v24; // r0
  CStreamingInfo *v25; // r9
  int16 v26; // r0
  CLoadedCarGroup *v27; // r4
  int v28; // r0
  int32 v29; // r0
  __int64 v30; // d16
  __int64 v31; // d17
  __int64 v32; // d18
  __int64 v33; // d19
  __int64 v34; // d21
  Int32 v35; // r10
  Int32 Member; // r4
  Int32 v37; // r5
  int v38; // r8
  _BOOL4 v39; // r0
  int32x4_t v40; // q8
  int v41; // r1
  int v42; // r2
  bool v43; // zf
  int16x8_t v44; // q9
  int16x8_t v45; // q10
  int32x4_t v46; // q13
  int32x4_t v47; // q14
  int8x8_t v48; // d22
  int8x8_t v49; // d23
  int16x8_t v50; // q9
  int16x8_t v51; // q10
  int16x8_t v52; // t2
  int16x8_t v53; // q9
  int v54; // r3
  int v55; // r3
  int v56; // r3
  int v57; // r3
  int v58; // r3
  int v59; // r3
  int v60; // r3
  CStreamingInfo *v61; // r0
  uint8 v62; // r3
  CStreamingInfo *v63; // r2
  CStreamingInfo *v64; // r3
  unsigned int v65; // r5
  Int32 v66; // [sp+4Ch] [bp-D4h]
  UInt32 *v67; // [sp+6Ch] [bp-B4h]
  unsigned int v68; // [sp+6Ch] [bp-B4h]
  CLoadedCarGroup v69; // [sp+A0h] [bp-80h] BYREF
  Int32 pRequiredGangs; // [sp+D4h] [bp-4Ch] BYREF
  __int64 v71; // [sp+D8h] [bp-48h]
  __int64 v72; // [sp+E0h] [bp-40h]
  __int64 v73; // [sp+E8h] [bp-38h]
  __int64 v74; // [sp+F0h] [bp-30h]

  if ( CPopCycle::m_pCurrZoneInfo )
  {
    v71 = v1;
    v72 = v2;
    v73 = v3;
    v74 = v4;
    pRequiredGangs = 0;
    v5 = CPopCycle::m_pCurrZoneInfo->aGangStrengths[0];
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[0] )
      v5 = 1;
    pRequiredGangs = v5;
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[1] )
    {
      v5 |= 2u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[2] )
    {
      v5 |= 4u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[3] )
    {
      v5 |= 8u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[4] )
    {
      v5 |= 0x10u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[5] )
    {
      v5 |= 0x20u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[6] )
    {
      v5 |= 0x40u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[7] )
    {
      v5 |= 0x80u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[8] )
    {
      v5 |= 0x100u;
      pRequiredGangs = v5;
    }
    if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[9] )
    {
      v5 |= 0x200u;
      pRequiredGangs = v5;
    }
    if ( CCheat::m_aCheatsActive[51] )
      pRequiredGangs = v5 | 0xFF;
    CGangWars::TellStreamingWhichGangsAreNeeded(&pRequiredGangs);
    v6 = pRequiredGangs;
    if ( pRequiredGangs != CStreaming::ms_loadedGangs || pRequiredGangs != CStreaming::ms_loadedGangCars )
    {
      v7 = 0;
      v8.n64_u64[0] = vneg_s8((int8x8_t)0x707070707070707LL).n64_u64[0];
      v9 = vdup_n_s8(0).n64_u64[0];
      v66 = pRequiredGangs;
      v10 = vdupq_n_s16(0x7D0u);
      for ( i = pRequiredGangs; ; i = pRequiredGangs )
      {
        v12 = 1 << v7;
        v13 = (1 << v7) & CStreaming::ms_loadedGangs;
        if ( (i & (1 << v7)) != 0 )
        {
          if ( v13 )
            goto LABEL_46;
          v67 = CPopulation::m_TranslationArray[v7];
          CStreaming::RequestModel(
            CPopulation::m_PedGroups[v67[54]][CurrentGangMemberToLoad % CPopulation::m_nNumPedsInGroup[v67[54]]],
            8);
          v6 = v66;
          CStreaming::RequestModel(
            CPopulation::m_PedGroups[v67[54]][(CurrentGangMemberToLoad + 1) % CPopulation::m_nNumPedsInGroup[v67[54]]],
            8);
          v14 = CStreaming::ms_loadedGangs | v12;
        }
        else
        {
          if ( !v13 )
            goto LABEL_46;
          v15 = CPopulation::m_TranslationArray[v7];
          v18 = v15[54];
          v17 = v15 + 54;
          v16 = v18;
          if ( CPopulation::m_nNumPedsInGroup[v18] < 1 )
          {
            v26 = CStreaming::ms_loadedGangs;
          }
          else
          {
            v19 = 0;
            do
            {
              v20 = CPopulation::m_PedGroups[v16][v19];
              v21 = v20;
              v22 = &CStreaming::ms_aInfoForModel[v20];
              m_flags = v22->m_flags;
              v22->m_flags = m_flags & 0xFD;
              if ( (m_flags & 4) == 0 )
              {
                if ( CStreaming::ms_aInfoForModel[v20].m_status == 1 )
                {
                  if ( (unsigned __int16)v22->m_nextIndex == 0xFFFF )
                  {
                    v24 = CStreaming::ms_pStartLoadedList;
                    v25 = CStreamingInfo::ms_pArrayBase;
                    v22->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                    v68 = -858993459 * ((unsigned int)((char *)v22 - (char *)v25) >> 2);
                    CStreaming::ms_aInfoForModel[v21].m_prevIndex = -13107
                                                                  * ((unsigned int)((char *)v24 - (char *)v25) >> 2);
                    v24->m_nextIndex = v68;
                    CStreamingInfo::ms_pArrayBase[v22->m_nextIndex].m_prevIndex = v68;
                  }
                }
                else if ( (m_flags & 8) == 0 )
                {
                  CStreaming::RemoveModel(v20);
                }
              }
              v16 = *v17;
              ++v19;
            }
            while ( v19 < CPopulation::m_nNumPedsInGroup[*v17] );
            v26 = CStreaming::ms_loadedGangs;
          }
          v12 = 1 << v7;
          v6 = v66;
          v14 = v26 & ~(unsigned __int16)(1 << v7);
        }
        CStreaming::ms_loadedGangs = v14;
LABEL_46:
        v27 = &CPopulation::m_LoadedGangCars[v7];
        if ( CLoadedCarGroup::CountMembers(v27) <= 0 )
        {
          v28 = CStreaming::ms_loadedGangCars & v12;
          if ( (v12 & v6) != 0 )
          {
            if ( !v28 )
            {
              v29 = CPopulation::m_CarGroups[v7 + 18][rand() % CPopulation::m_nNumCarsInGroup[v7 + 18]];
              if ( CStreaming::ms_aInfoForModel[v29].m_status != 1 )
                CStreaming::RequestModel(v29, 8);
            }
          }
          else if ( v28 )
          {
            v30 = *(_QWORD *)v27->aMembers;
            v31 = *(_QWORD *)&v27->aMembers[4];
            v32 = *(_QWORD *)&v27->aMembers[8];
            v33 = *(_QWORD *)&v27->aMembers[12];
            v34 = *(_QWORD *)&v27->aMembers[19];
            *(_QWORD *)&v69.aMembers[15] = *(_QWORD *)&v27->aMembers[15];
            *(_QWORD *)&v69.aMembers[19] = v34;
            *(_QWORD *)v69.aMembers = v30;
            *(_QWORD *)&v69.aMembers[4] = v31;
            *(_QWORD *)&v69.aMembers[8] = v32;
            *(_QWORD *)&v69.aMembers[12] = v33;
            if ( CLoadedCarGroup::CountMembers(&v69) >= 1 )
            {
              v35 = 0;
              do
              {
                Member = CLoadedCarGroup::GetMember(&v69, v35);
                if ( CLoadedCarGroup::CountMembers(&CPopulation::m_AppropriateLoadedCars) < 1 )
                {
                  v38 = 0;
                }
                else
                {
                  v37 = 0;
                  v38 = 0;
                  do
                  {
                    v39 = Member == CLoadedCarGroup::GetMember(&CPopulation::m_AppropriateLoadedCars, v37++);
                    v38 |= v39;
                  }
                  while ( v37 < CLoadedCarGroup::CountMembers(&CPopulation::m_AppropriateLoadedCars) );
                }
                v40 = vdupq_n_s32(Member);
                v41 = 0;
                v42 = 0;
                do
                {
                  v43 = v7 == v42;
                  if ( v7 != v42 )
                    v43 = ((1 << v42) & CStreaming::ms_loadedGangs) == 0;
                  if ( !v43 )
                  {
                    v44 = *(int16x8_t *)&CPopulation::m_CarGroups[v41 + 18][0];
                    v45 = *(int16x8_t *)&CPopulation::m_CarGroups[v41 + 18][8];
                    v46 = vceqq_s32(v40, vmovl_u16((uint16x4_t)v45.n128_u64[0]));
                    v47 = vceqq_s32(v40, vmovl_u16(*(uint16x4_t *)&v45.n128_i8[8]));
                    v48.n64_u64[0] = vmovn_s32(vceqq_s32(v40, vmovl_u16(*(uint16x4_t *)&v44.n128_i8[8]))).n64_u64[0];
                    v49.n64_u64[0] = vmovn_s32(vceqq_s32(v40, vmovl_u16((uint16x4_t)v44.n128_u64[0]))).n64_u64[0];
                    v50 = vceqq_s16(v44, v10);
                    v51 = vceqq_s16(v45, v10);
                    v52.n128_u64[0] = ~v50.n128_u64[0];
                    v52.n128_u64[1] = ~v50.n128_u64[1];
                    v53 = v52;
                    v52.n128_u64[0] = ~v51.n128_u64[0];
                    v52.n128_u64[1] = ~v51.n128_u64[1];
                    v54 = CPopulation::m_CarGroups[v41 + 18][16];
                    v51.n128_u64[1] = v9;
                    v51.n128_u8[8] = v38;
                    v53.n128_u64[0] = vshl_s8(v8, vshl_n_s8((int8x8_t)vuzp_s8(vmovn_s32(v46), vmovn_s32(v47)), 7u)).n64_u64[0] & vmovn_s16(v52).n64_u64[0] | vshl_s8(v8, vshl_n_s8((int8x8_t)vuzp_s8(v49, v48), 7u)).n64_u64[0] & vmovn_s16(v53).n64_u64[0] | v51.n128_u64[1];
                    v53.n128_u64[0] |= vext_s8((int8x8_t)v53.n128_u64[0], (int8x8_t)v40.n128_u64[0], 4u).n64_u64[0];
                    v53.n128_u64[0] |= vext_s8((int8x8_t)v53.n128_u64[0], (int8x8_t)v40.n128_u64[0], 2u).n64_u64[0];
                    v38 = (unsigned __int8)(vdup_lane_s8((int8x8_t)v53.n128_u64[0], 1).n64_u8[0] | v53.n128_u8[0]);
                    if ( v54 != 2000 )
                      v38 |= Member == v54;
                    v55 = CPopulation::m_CarGroups[v41 + 18][17];
                    if ( v55 != 2000 )
                      v38 |= Member == v55;
                    v56 = CPopulation::m_CarGroups[v41 + 18][18];
                    if ( v56 != 2000 )
                      v38 |= Member == v56;
                    v57 = CPopulation::m_CarGroups[v41 + 18][19];
                    if ( v57 != 2000 )
                      v38 |= Member == v57;
                    v58 = CPopulation::m_CarGroups[v41 + 18][20];
                    if ( v58 != 2000 )
                      v38 |= Member == v58;
                    v59 = CPopulation::m_CarGroups[v41 + 18][21];
                    if ( v59 != 2000 )
                      v38 |= Member == v59;
                    v60 = CPopulation::m_CarGroups[v41 + 18][22];
                    if ( v60 != 2000 )
                      v38 |= Member == v60;
                  }
                  ++v41;
                  ++v42;
                }
                while ( v41 != 10 );
                if ( !(v38 << 31) )
                {
                  v61 = &CStreaming::ms_aInfoForModel[Member];
                  v62 = v61->m_flags;
                  v61->m_flags = v62 & 0xFD;
                  if ( (v62 & 4) == 0 )
                  {
                    if ( CStreaming::ms_aInfoForModel[Member].m_status == 1 )
                    {
                      if ( (unsigned __int16)v61->m_nextIndex == 0xFFFF )
                      {
                        v63 = CStreaming::ms_pStartLoadedList;
                        v64 = CStreamingInfo::ms_pArrayBase;
                        v61->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                        v65 = -858993459 * ((unsigned int)((char *)v61 - (char *)v64) >> 2);
                        CStreaming::ms_aInfoForModel[Member].m_prevIndex = -13107
                                                                         * ((unsigned int)((char *)v63 - (char *)v64) >> 2);
                        v63->m_nextIndex = v65;
                        CStreamingInfo::ms_pArrayBase[v61->m_nextIndex].m_prevIndex = v65;
                      }
                    }
                    else if ( (v62 & 8) == 0 )
                    {
                      CStreaming::RemoveModel(Member);
                    }
                  }
                }
                ++v35;
              }
              while ( v35 < CLoadedCarGroup::CountMembers(&v69) );
            }
            v6 = v66;
          }
        }
        if ( ++v7 == 10 )
        {
          CStreaming::ms_loadedGangCars = v6;
          return;
        }
      }
    }
  }
}
// 2D77FE: variable 'v1' is possibly undefined
// 2D77FE: variable 'v2' is possibly undefined
// 2D77FE: variable 'v3' is possibly undefined
// 2D77FE: variable 'v4' is possibly undefined
// 32: using guessed type __int16 word_32;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;

//----- (002D7FB0) --------------------------------------------------------
void CStreaming::ReclassifyLoadedCars()
{
  Int32 v0; // r4
  Int32 Member; // r6
  CLoadedCarGroup *v2; // r0
  Int32 v3; // r4
  Int32 v4; // r6
  CLoadedCarGroup *v5; // r0
  CLoadedCarGroup v6; // [sp+0h] [bp-78h] BYREF
  CLoadedCarGroup v7; // [sp+30h] [bp-48h] BYREF

  *(_QWORD *)&v7.aMembers[15] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[15];
  *(_QWORD *)&v7.aMembers[19] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[19];
  *(_QWORD *)v7.aMembers = *(_QWORD *)CPopulation::m_AppropriateLoadedCars.aMembers;
  *(_QWORD *)&v7.aMembers[4] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[4];
  *(_QWORD *)&v7.aMembers[8] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[8];
  *(_QWORD *)&v7.aMembers[12] = *(_QWORD *)&CPopulation::m_AppropriateLoadedCars.aMembers[12];
  *(_QWORD *)&v6.aMembers[15] = *(_QWORD *)&CPopulation::m_InAppropriateLoadedCars.aMembers[15];
  *(_QWORD *)&v6.aMembers[19] = *(_QWORD *)&CPopulation::m_InAppropriateLoadedCars.aMembers[19];
  *(_QWORD *)v6.aMembers = *(_QWORD *)CPopulation::m_InAppropriateLoadedCars.aMembers;
  *(_QWORD *)&v6.aMembers[4] = *(_QWORD *)&CPopulation::m_InAppropriateLoadedCars.aMembers[4];
  *(_QWORD *)&v6.aMembers[8] = *(_QWORD *)&CPopulation::m_InAppropriateLoadedCars.aMembers[8];
  *(_QWORD *)&v6.aMembers[12] = *(_QWORD *)&CPopulation::m_InAppropriateLoadedCars.aMembers[12];
  CLoadedCarGroup::Clear(&CPopulation::m_AppropriateLoadedCars);
  CLoadedCarGroup::Clear(&CPopulation::m_InAppropriateLoadedCars);
  if ( CLoadedCarGroup::CountMembers(&v7) >= 1 )
  {
    v0 = 0;
    do
    {
      Member = CLoadedCarGroup::GetMember(&v7, v0);
      if ( CStreaming::IsCarModelNeededInCurrentZone(Member) )
        v2 = &CPopulation::m_AppropriateLoadedCars;
      else
        v2 = &CPopulation::m_InAppropriateLoadedCars;
      CLoadedCarGroup::AddMember(v2, Member);
      ++v0;
    }
    while ( v0 < CLoadedCarGroup::CountMembers(&v7) );
  }
  if ( CLoadedCarGroup::CountMembers(&v6) >= 1 )
  {
    v3 = 0;
    do
    {
      v4 = CLoadedCarGroup::GetMember(&v6, v3);
      if ( CStreaming::IsCarModelNeededInCurrentZone(v4) )
        v5 = &CPopulation::m_AppropriateLoadedCars;
      else
        v5 = &CPopulation::m_InAppropriateLoadedCars;
      CLoadedCarGroup::AddMember(v5, v4);
      ++v3;
    }
    while ( v3 < CLoadedCarGroup::CountMembers(&v6) );
  }
}
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;
// 679EA4: using guessed type CLoadedCarGroup *CPopulation::m_InAppropriateLoadedCars;
// 2D7FB0: using guessed type CLoadedCarGroup var_78;

//----- (002D80C8) --------------------------------------------------------
bool __fastcall CStreaming::IsCarModelNeededInCurrentZone(Int32 MI)
{
  int v1; // r2
  int v2; // r2
  int v3; // r3
  bool v4; // r1
  int v5; // r3
  int v6; // r3
  int v7; // r3
  UInt16 (*v8)[23]; // r1
  int v9; // r5
  int v10; // r4
  int v11; // r5
  int v12; // r6
  int v13; // r4
  UInt16 *v14; // r3
  int v15; // lr
  int v16; // r1
  int v17; // r4

  if ( CPopCycle::m_pCurrZoneInfo )
  {
    if ( CCheat::m_aCheatsActive[49] )
    {
      if ( CPopulation::m_nNumCarsInGroup[4] >= 1 )
      {
        v1 = 0;
        while ( CPopulation::m_CarGroups[4][v1] != MI )
        {
          if ( ++v1 >= CPopulation::m_nNumCarsInGroup[4] )
            return 0;
        }
        return 1;
      }
    }
    else if ( CCheat::m_aCheatsActive[83] )
    {
      if ( CPopulation::m_nNumCarsInGroup[3] >= 1 )
      {
        v2 = 0;
        while ( CPopulation::m_CarGroups[3][v2] != MI )
        {
          if ( ++v2 >= CPopulation::m_nNumCarsInGroup[3] )
            return 0;
        }
        return 1;
      }
    }
    else if ( CCheat::m_aCheatsActive[54] )
    {
      if ( CPopulation::m_nNumCarsInGroup[30] >= 1 )
      {
        v3 = 0;
        while ( CPopulation::m_CarGroups[30][v3] != MI )
        {
          ++v3;
          v4 = 0;
          if ( v3 >= CPopulation::m_nNumCarsInGroup[30] )
            return v4;
        }
        return 1;
      }
    }
    else if ( CCheat::m_aCheatsActive[55] )
    {
      if ( CPopulation::m_nNumCarsInGroup[31] >= 1 )
      {
        v5 = 0;
        while ( CPopulation::m_CarGroups[31][v5] != MI )
        {
          ++v5;
          v4 = 0;
          if ( v5 >= CPopulation::m_nNumCarsInGroup[31] )
            return v4;
        }
        return 1;
      }
    }
    else if ( CCheat::m_aCheatsActive[52] )
    {
      if ( CPopulation::m_nNumCarsInGroup[32] >= 1 )
      {
        v6 = 0;
        while ( CPopulation::m_CarGroups[32][v6] != MI )
        {
          ++v6;
          v4 = 0;
          if ( v6 >= CPopulation::m_nNumCarsInGroup[32] )
            return v4;
        }
        return 1;
      }
    }
    else
    {
      if ( !CCheat::m_aCheatsActive[78] )
      {
        v8 = CPopulation::m_CarGroups;
        v9 = 0;
        while ( 1 )
        {
          v10 = v9;
          if ( CPopCycle::m_nPercTypeGroup[CPopCycle::m_nCurrentTimeIndex][CPopCycle::m_nCurrentTimeOfWeek][*(_WORD *)((char *)CPopCycle::m_pCurrZoneInfo + 15) & 0x1F][v9] )
          {
            v11 = CPopulation::m_nNumCarsInGroup[v9];
            if ( v11 >= 1 )
              break;
          }
LABEL_45:
          ++v8;
          v9 = v10 + 1;
          if ( v10 >= 17 )
          {
            v13 = 0;
            v14 = CPopulation::m_CarGroups[18];
            while ( 1 )
            {
              v15 = v13;
              if ( CPopCycle::m_pCurrZoneInfo->aGangStrengths[v13] )
              {
                v16 = CPopulation::m_nNumCarsInGroup[v13 + 18];
                if ( v16 >= 1 )
                  break;
              }
LABEL_52:
              v14 += 23;
              v13 = v15 + 1;
              v4 = 0;
              if ( v15 >= 9 )
                return v4;
            }
            v17 = 0;
            while ( v14[v17] != MI )
            {
              if ( ++v17 >= v16 )
                goto LABEL_52;
            }
            return 1;
          }
        }
        v12 = 0;
        while ( (*v8)[v12] != MI )
        {
          if ( ++v12 >= v11 )
            goto LABEL_45;
        }
        return 1;
      }
      if ( CPopulation::m_nNumCarsInGroup[33] >= 1 )
      {
        v7 = 0;
        while ( CPopulation::m_CarGroups[33][v7] != MI )
        {
          ++v7;
          v4 = 0;
          if ( v7 >= CPopulation::m_nNumCarsInGroup[33] )
            return v4;
        }
        return 1;
      }
    }
  }
  return 0;
}

//----- (002D8360) --------------------------------------------------------
void CStreaming::RemoveCurrentZonesModels()
{
  int i; // r4
  int32 v1; // r0
  int32 v2; // r2
  CStreamingInfo *v3; // r1
  uint8 m_flags; // r6
  CStreamingInfo *v5; // r0
  CStreamingInfo *v6; // r12
  unsigned int v7; // r3
  int16 v8; // r6
  int v9; // r4
  CStreamingInfo *v10; // r12
  int v11; // r10
  UInt32 *v12; // r9
  int32 v13; // r0
  int32 v14; // r2
  CStreamingInfo *v15; // r1
  uint8 v16; // r4
  CStreamingInfo *v17; // r0
  CStreamingInfo *v18; // r3
  unsigned int v19; // r4
  CStreamingInfo *v20; // r4
  int v21; // [sp+4h] [bp-2Ch]

  for ( i = 0; i != 8; ++i )
  {
    v1 = CStreaming::ms_pedsLoaded[i];
    if ( v1 >= 0 )
    {
      v2 = v1;
      v3 = &CStreaming::ms_aInfoForModel[v1];
      m_flags = v3->m_flags;
      v3->m_flags = m_flags & 0xFD;
      if ( (m_flags & 4) == 0 )
      {
        if ( CStreaming::ms_aInfoForModel[v1].m_status == 1 )
        {
          if ( (unsigned __int16)v3->m_nextIndex == 0xFFFF )
          {
            v5 = CStreaming::ms_pStartLoadedList;
            v6 = CStreamingInfo::ms_pArrayBase;
            v7 = (char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase;
            v3->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
            v8 = -13107 * ((unsigned int)((char *)v3 - (char *)v6) >> 2);
            CStreaming::ms_aInfoForModel[v2].m_prevIndex = -13107 * (v7 >> 2);
            v5->m_nextIndex = v8;
            CStreamingInfo::ms_pArrayBase[v3->m_nextIndex].m_prevIndex = v8;
          }
        }
        else if ( (m_flags & 8) == 0 )
        {
          CStreaming::RemoveModel(v1);
        }
      }
      CStreaming::ms_pedsLoaded[i] = -1;
    }
  }
  v9 = 0;
  CStreaming::ms_numPedsLoaded = 0;
  CStreaming::RequestModel(7, 2);
  v10 = CStreaming::ms_aInfoForModel;
  do
  {
    v11 = 0;
    v21 = v9;
    v12 = CPopulation::m_TranslationArray[v9 + 18];
    do
    {
      v13 = CPopulation::m_PedGroups[*v12][v11];
      if ( v13 != 2000 )
      {
        v14 = v13;
        v15 = &CStreaming::ms_aInfoForModel[v13];
        v16 = v15->m_flags;
        v15->m_flags = v16 & 0xFD;
        if ( (v16 & 4) == 0 )
        {
          if ( v10[v13].m_status == 1 )
          {
            if ( (unsigned __int16)v15->m_nextIndex == 0xFFFF )
            {
              v17 = CStreaming::ms_pStartLoadedList;
              v18 = CStreamingInfo::ms_pArrayBase;
              v15->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v19 = -858993459 * ((unsigned int)((char *)v15 - (char *)v18) >> 2);
              CStreaming::ms_aInfoForModel[v14].m_prevIndex = -13107 * ((unsigned int)((char *)v17 - (char *)v18) >> 2);
              v17->m_nextIndex = v19;
              CStreamingInfo::ms_pArrayBase[v15->m_nextIndex].m_prevIndex = v19;
            }
          }
          else if ( (v16 & 8) == 0 )
          {
            v20 = v10;
            CStreaming::RemoveModel(v13);
            v10 = v20;
          }
        }
      }
      ++v11;
    }
    while ( v11 != 5 );
    v9 = v21 + 1;
  }
  while ( v21 != 9 );
  CStreaming::ms_loadedGangs = 0;
  CStreaming::ms_currentZoneType = -1;
  CStreaming::ms_loadedGangCars = 0;
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D85AC) --------------------------------------------------------
void CStreaming::RemoveInappropriatePedModels()
{
  int i; // r5
  Int32 v1; // r0
  int32 v2; // r0
  int32 v3; // r2
  CStreamingInfo *v4; // r1
  uint8 m_flags; // r4
  CStreamingInfo *v6; // r0
  CStreamingInfo *v7; // lr
  int16 v8; // r9
  int j; // r4
  int32 v10; // r0
  int32 v11; // r2
  CStreamingInfo *v12; // r1
  uint8 v13; // r6
  CStreamingInfo *v14; // r0
  CStreamingInfo *v15; // lr
  unsigned int v16; // r3
  int16 v17; // r6

  if ( CPopCycle::m_pCurrZoneInfo )
  {
    for ( i = 0; i != 8; ++i )
    {
      v1 = CStreaming::ms_pedsLoaded[i];
      if ( v1 >= 0 && !CPopCycle::IsPedAppropriateForCurrentZone(v1) )
      {
        v2 = CStreaming::ms_pedsLoaded[i];
        v3 = v2;
        v4 = &CStreaming::ms_aInfoForModel[v2];
        m_flags = v4->m_flags;
        v4->m_flags = m_flags & 0xFD;
        if ( (m_flags & 4) == 0 )
        {
          if ( CStreaming::ms_aInfoForModel[v2].m_status == 1 )
          {
            if ( (unsigned __int16)v4->m_nextIndex == 0xFFFF )
            {
              v6 = CStreaming::ms_pStartLoadedList;
              v7 = CStreamingInfo::ms_pArrayBase;
              v4->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v8 = -13107 * ((unsigned int)((char *)v4 - (char *)v7) >> 2);
              CStreaming::ms_aInfoForModel[v3].m_prevIndex = -13107 * ((unsigned int)((char *)v6 - (char *)v7) >> 2);
              v6->m_nextIndex = v8;
              CStreamingInfo::ms_pArrayBase[v4->m_nextIndex].m_prevIndex = v8;
            }
          }
          else if ( (m_flags & 8) == 0 )
          {
            CStreaming::RemoveModel(v2);
          }
        }
        CStreaming::ms_pedsLoaded[i] = -1;
        --CStreaming::ms_numPedsLoaded;
      }
    }
  }
  else
  {
    for ( j = 0; j != 8; ++j )
    {
      v10 = CStreaming::ms_pedsLoaded[j];
      if ( v10 >= 0 )
      {
        v11 = v10;
        v12 = &CStreaming::ms_aInfoForModel[v10];
        v13 = v12->m_flags;
        v12->m_flags = v13 & 0xFD;
        if ( (v13 & 4) == 0 )
        {
          if ( CStreaming::ms_aInfoForModel[v10].m_status == 1 )
          {
            if ( (unsigned __int16)v12->m_nextIndex == 0xFFFF )
            {
              v14 = CStreaming::ms_pStartLoadedList;
              v15 = CStreamingInfo::ms_pArrayBase;
              v16 = (char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase;
              v12->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v17 = -13107 * ((unsigned int)((char *)v12 - (char *)v15) >> 2);
              CStreaming::ms_aInfoForModel[v11].m_prevIndex = -13107 * (v16 >> 2);
              v14->m_nextIndex = v17;
              CStreamingInfo::ms_pArrayBase[v12->m_nextIndex].m_prevIndex = v17;
            }
          }
          else if ( (v13 & 8) == 0 )
          {
            CStreaming::RemoveModel(v10);
          }
        }
        CStreaming::ms_pedsLoaded[j] = -1;
      }
    }
    CStreaming::ms_numPedsLoaded = 0;
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D87F8) --------------------------------------------------------
void __fastcall CStreaming::RequestSpecialChar(int32 index, const unsigned __int8 *pName, int32 flags)
{
  CStreaming::RequestSpecialModel(index + 290, pName, flags);
}

//----- (002D8800) --------------------------------------------------------
bool __fastcall CStreaming::HasSpecialCharLoaded(int32 index)
{
  int m_status; // r0

  m_status = CStreaming::ms_aInfoForModel[index + 290].m_status;
  if ( m_status != 1 )
    LOBYTE(m_status) = 0;
  return m_status;
}

//----- (002D8820) --------------------------------------------------------
void __fastcall CStreaming::SetSpecialCharIsDeletable(int32 index)
{
  int32 v1; // r0
  int32 v2; // r12
  CStreamingInfo *v3; // r1
  uint8 m_flags; // r2
  CStreamingInfo *v5; // r0
  CStreamingInfo *v6; // r3
  int16 v7; // r4

  v1 = index + 290;
  v2 = v1;
  v3 = &CStreaming::ms_aInfoForModel[v1];
  m_flags = v3->m_flags;
  v3->m_flags = m_flags & 0xFD;
  if ( (m_flags & 4) == 0 )
  {
    if ( CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    {
      if ( (unsigned __int16)v3->m_nextIndex == 0xFFFF )
      {
        v5 = CStreaming::ms_pStartLoadedList;
        v6 = CStreamingInfo::ms_pArrayBase;
        v3->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
        v7 = -13107 * ((unsigned int)((char *)v3 - (char *)v6) >> 2);
        CStreaming::ms_aInfoForModel[v2].m_prevIndex = -13107 * ((unsigned int)((char *)v5 - (char *)v6) >> 2);
        v5->m_nextIndex = v7;
        CStreamingInfo::ms_pArrayBase[v3->m_nextIndex].m_prevIndex = v7;
      }
    }
    else if ( (m_flags & 8) == 0 )
    {
      CStreaming::RemoveModel(v1);
    }
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D88CC) --------------------------------------------------------
void __fastcall CStreaming::SetMissionDoesntRequireSpecialChar(int32 index)
{
  int32 i; // r4
  CStreamingInfo *v2; // r0
  uint8 m_flags; // r3
  CStreamingInfo *v4; // r2
  CStreamingInfo *v5; // lr
  int16 v6; // r10

  for ( i = index + 290; ; i = CModelInfo::ms_modelInfoPtrs[i]->m_txdIndex + 20000 )
  {
    v2 = &CStreaming::ms_aInfoForModel[i];
    m_flags = v2->m_flags;
    v2->m_flags = m_flags & 0xFB;
    if ( (m_flags & 2) != 0 )
    {
LABEL_6:
      if ( i > 19999 )
        return;
      continue;
    }
    if ( CStreaming::ms_aInfoForModel[i].m_status != 1 )
      break;
    if ( (unsigned __int16)v2->m_nextIndex != 0xFFFF )
      goto LABEL_6;
    v4 = CStreaming::ms_pStartLoadedList;
    v5 = CStreamingInfo::ms_pArrayBase;
    v2->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
    v6 = -13107 * ((unsigned int)((char *)v2 - (char *)v5) >> 2);
    CStreaming::ms_aInfoForModel[i].m_prevIndex = -13107 * ((unsigned int)((char *)v4 - (char *)v5) >> 2);
    v4->m_nextIndex = v6;
    CStreamingInfo::ms_pArrayBase[v2->m_nextIndex].m_prevIndex = v6;
    if ( i > 19999 )
      return;
LABEL_2:
    ;
  }
  if ( (m_flags & 8) == 0 )
    CStreaming::RemoveModel(i);
  if ( i <= 19999 )
    goto LABEL_2;
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D89E8) --------------------------------------------------------
void CStreaming::StreamOneNewCar()
{
  int32 v0; // r0
  int v1; // r4
  bool v2; // zf

  if ( !CPopCycle::m_pCurrZoneInfo )
    return;
  if ( CCheat::m_aCheatsActive[49] )
  {
    v0 = 4;
    goto LABEL_14;
  }
  if ( CCheat::m_aCheatsActive[83] )
  {
    v0 = 3;
    goto LABEL_14;
  }
  if ( CCheat::m_aCheatsActive[54] )
  {
    v0 = 30;
    goto LABEL_14;
  }
  if ( CCheat::m_aCheatsActive[55] )
  {
    v0 = 31;
    goto LABEL_14;
  }
  if ( CCheat::m_aCheatsActive[52] )
  {
    v0 = 32;
    goto LABEL_14;
  }
  if ( CCheat::m_aCheatsActive[78] )
  {
    v0 = 33;
    goto LABEL_14;
  }
  if ( CStreaming::m_bBoatsNeeded
    && (CLoadedCarGroup::CountMembers(&CPopulation::m_LoadedBoats) < 2
     || CLoadedCarGroup::CountMembers(&CPopulation::m_LoadedBoats) <= 2 && (rand() & 7) == 3) )
  {
    v1 = CCarCtrl::ChooseCarModelToLoad(29);
    if ( v1 > -1 )
      goto LABEL_15;
  }
  v2 = CStreaming::ms_aInfoForModel[420].m_status == 1;
  if ( CStreaming::ms_aInfoForModel[420].m_status != 1 )
    v2 = CStreaming::ms_aInfoForModel[438].m_status == 1;
  if ( !v2 )
  {
    if ( CStreaming::StreamOneNewCar(void)::LastLoadedTaxi == 420 )
    {
      v1 = 438;
      if ( !CStreaming::IsCarModelNeededInCurrentZone(438) )
      {
        v1 = 420;
        if ( !CStreaming::IsCarModelNeededInCurrentZone(420) )
          goto LABEL_32;
      }
    }
    else
    {
      v1 = 420;
      if ( !CStreaming::IsCarModelNeededInCurrentZone(420) )
      {
        v1 = 438;
        if ( !CStreaming::IsCarModelNeededInCurrentZone(438) )
          goto LABEL_32;
      }
    }
    CStreaming::StreamOneNewCar(void)::LastLoadedTaxi = v1;
    goto LABEL_15;
  }
LABEL_32:
  v0 = CPopCycle::PickARandomGroupOfOtherPeds();
LABEL_14:
  v1 = CCarCtrl::ChooseCarModelToLoad(v0);
  if ( v1 >= 0 )
  {
LABEL_15:
    CStreaming::RequestModel(v1, 8);
    sub_196130(v1);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 679EBC: using guessed type CLoadedCarGroup *CPopulation::m_LoadedBoats;

//----- (002D8B5C) --------------------------------------------------------
bool CStreaming::PlayerIsFlyingFast()
{
  CVehicle *PlayerVehicle; // r0
  int32 m_vehicleType; // r1
  _BOOL4 result; // r0

  PlayerVehicle = FindPlayerVehicle(-1, 0);
  result = 0;
  if ( PlayerVehicle )
  {
    m_vehicleType = PlayerVehicle->m_vehicleType;
    if ( m_vehicleType == 4
      || m_vehicleType == 3
      && sqrtf(
           (float)(PlayerVehicle->m_vecMoveSpeed.x * PlayerVehicle->m_vecMoveSpeed.x)
         + (float)(PlayerVehicle->m_vecMoveSpeed.y * PlayerVehicle->m_vecMoveSpeed.y)) > 0.1 )
    {
      return 1;
    }
  }
  return result;
}

//----- (002D8BAC) --------------------------------------------------------
void __fastcall CStreaming::PossiblyStreamCarOutAfterCreation(Int32 MI)
{
  Int32 v2; // r1
  CStreamingInfo *v3; // r0
  uint8 m_flags; // r3
  CStreamingInfo *v5; // r2
  CStreamingInfo *v6; // r4
  unsigned int v7; // r3

  if ( BYTE2(CModelInfo::ms_modelInfoPtrs[MI][1].m_pColModel) << 31 )
  {
    if ( (rand() & 1) != 0 )
    {
      v2 = MI;
      v3 = &CStreaming::ms_aInfoForModel[MI];
      m_flags = v3->m_flags;
      v3->m_flags = m_flags & 0xFD;
      if ( (m_flags & 4) == 0 )
      {
        if ( CStreaming::ms_aInfoForModel[MI].m_status == 1 )
        {
          if ( (unsigned __int16)v3->m_nextIndex == 0xFFFF )
          {
            v5 = CStreaming::ms_pStartLoadedList;
            v6 = CStreamingInfo::ms_pArrayBase;
            v3->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
            v7 = -858993459 * ((unsigned int)((char *)v3 - (char *)v6) >> 2);
            CStreaming::ms_aInfoForModel[v2].m_prevIndex = -13107 * ((unsigned int)((char *)v5 - (char *)v6) >> 2);
            v5->m_nextIndex = v7;
            CStreamingInfo::ms_pArrayBase[v3->m_nextIndex].m_prevIndex = v7;
          }
        }
        else if ( (m_flags & 8) == 0 )
        {
          CStreaming::RemoveModel(MI);
        }
      }
    }
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D8C80) --------------------------------------------------------
bool __fastcall CStreaming::WeAreTryingToPhaseVehicleOut(Int32 MI)
{
  Int32 v1; // r0

  v1 = MI;
  if ( CStreaming::ms_aInfoForModel[v1].m_status != 1 )
    return 0;
  if ( CStreaming::ms_aInfoForModel[v1].m_nextIndex <= -1 )
    return CStreaming::ms_aInfoForModel[v1].m_prevIndex > -1;
  return 1;
}

//----- (002D8CD4) --------------------------------------------------------
void __fastcall CStreaming::ClearSlots(Int32 SlotsToClear)
{
  Int32 v1; // r4
  int32 *v2; // r5
  int32 v3; // r0
  int32 v4; // r2
  CStreamingInfo *v5; // r1
  uint8 m_flags; // r6
  CStreamingInfo *v7; // r0
  CStreamingInfo *v8; // r12
  int16 v9; // r8
  int32 v10; // r0

  v1 = SlotsToClear;
  if ( SlotsToClear >= 1 )
  {
    v2 = CStreaming::ms_pedsLoaded;
    do
    {
      v3 = *v2;
      if ( *v2 >= 0 )
      {
        v4 = v3;
        v5 = &CStreaming::ms_aInfoForModel[v3];
        m_flags = v5->m_flags;
        v5->m_flags = m_flags & 0xFD;
        if ( (m_flags & 4) == 0 )
        {
          if ( CStreaming::ms_aInfoForModel[v3].m_status == 1 )
          {
            if ( (unsigned __int16)v5->m_nextIndex == 0xFFFF )
            {
              v7 = CStreaming::ms_pStartLoadedList;
              v8 = CStreamingInfo::ms_pArrayBase;
              v5->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v9 = -13107 * ((unsigned int)((char *)v5 - (char *)v8) >> 2);
              CStreaming::ms_aInfoForModel[v4].m_prevIndex = -13107 * ((unsigned int)((char *)v7 - (char *)v8) >> 2);
              v7->m_nextIndex = v9;
              CStreamingInfo::ms_pArrayBase[v5->m_nextIndex].m_prevIndex = v9;
            }
          }
          else if ( (m_flags & 8) == 0 )
          {
            CStreaming::RemoveModel(v3);
          }
        }
        v10 = CStreaming::ms_numPedsLoaded;
        *v2 = -1;
        CStreaming::ms_numPedsLoaded = v10 - 1;
      }
      --v1;
      ++v2;
    }
    while ( v1 );
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D8DF0) --------------------------------------------------------
void __fastcall CStreaming::StreamPedsForInterior(Int32 InteriorType)
{
  int v1; // r4
  int v2; // s0
  int v3; // r6
  int32 v4; // r8
  int v5; // r1
  int32 v6; // r5
  int v7; // r4
  int v8; // r6
  int32 v9; // r4
  int32 v10; // r0
  int32 v11; // r4
  int v12; // [sp+8h] [bp-20h]

  switch ( InteriorType )
  {
    case 2:
      CStreaming::ClearSlots(8);
      v7 = CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[30][0]];
      v8 = 0;
      v12 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v7);
      do
      {
        v9 = CPopulation::m_PedGroups[CPopulation::m_TranslationArray[30][CPopulation::CurrentWorldZone]][(v12 + v8) % CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[30][0]]];
        CStreaming::RequestModel(v9, 8);
        v10 = CStreaming::ms_numPedsLoaded;
        CStreaming::ms_pedsLoaded[v8++] = v9;
        CStreaming::ms_numPedsLoaded = v10 + 1;
      }
      while ( v8 != 8 );
      break;
    case 1:
      v11 = CPopulation::m_PedGroups[CPopulation::m_TranslationArray[29][CPopulation::CurrentWorldZone]][rand() % CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[29][0]]];
      CStreaming::ClearSlots(1);
      CStreaming::RequestModel(v11, 8);
      CStreaming::ms_pedsLoaded[0] = v11;
      ++CStreaming::ms_numPedsLoaded;
      break;
    case 0:
      v1 = rand() % CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[31][0]];
      v2 = (unsigned __int16)rand();
      v3 = CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[32][0]];
      v4 = CPopulation::m_PedGroups[CPopulation::m_TranslationArray[31][CPopulation::CurrentWorldZone]][v1];
      v5 = v1 + 3 - (int)(float)((float)((float)v2 * 0.000015259) * 6.0);
      if ( v5 <= 0 )
        v5 = 0;
      if ( v5 >= v3 )
        v5 = v3 - 1;
      v6 = CPopulation::m_PedGroups[CPopulation::m_TranslationArray[32][CPopulation::CurrentWorldZone]][v5];
      CStreaming::ClearSlots(2);
      CStreaming::RequestModel(v4, 8);
      CStreaming::ms_pedsLoaded[0] = v4;
      ++CStreaming::ms_numPedsLoaded;
      CStreaming::RequestModel(v6, 8);
      CStreaming::ms_pedsLoaded[1] = v6;
      ++CStreaming::ms_numPedsLoaded;
      break;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002D9044) --------------------------------------------------------
Int32 __fastcall CStreaming::FindMIPedSlotForInterior(Int32 Slot)
{
  Int32 v1; // r1

  v1 = CStreaming::ms_pedsLoaded[Slot - ((Slot + ((unsigned int)(Slot >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 1 - ((Slot + 1 + ((unsigned int)((Slot + 1) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 > -1 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 2 - ((Slot + 2 + ((unsigned int)((Slot + 2) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 3 - ((Slot + 3 + ((unsigned int)((Slot + 3) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 4 - ((Slot + 4 + ((unsigned int)((Slot + 4) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 5 - ((Slot + 5 + ((unsigned int)((Slot + 5) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 6 - ((Slot + 6 + ((unsigned int)((Slot + 6) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 && CStreaming::ms_aInfoForModel[v1].m_status == 1 )
    return v1;
  v1 = CStreaming::ms_pedsLoaded[Slot + 7 - ((Slot + 7 + ((unsigned int)((Slot + 7) >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( v1 >= 0 )
  {
    if ( CStreaming::ms_aInfoForModel[v1].m_status != 1 )
      return 7;
    return v1;
  }
  return 7;
}

//----- (002D921C) --------------------------------------------------------
void __fastcall CStreaming::StreamPedsIntoRandomSlots(Int32 *pMI)
{
  int i; // r5
  int32 v3; // r1
  int32 v4; // r0
  int32 v5; // r2
  CStreamingInfo *v6; // r1
  uint8 v7; // r6
  CStreamingInfo *v8; // r0
  CStreamingInfo *v9; // lr
  int16 v10; // r11
  int32 v11; // r0
  int32 v12; // r2
  CStreamingInfo *v13; // r1
  uint8 m_flags; // r6
  CStreamingInfo *v15; // r0
  CStreamingInfo *v16; // r12
  unsigned int v17; // lr

  for ( i = 0; i != 8; ++i )
  {
    v3 = pMI[i];
    if ( v3 < 0 )
    {
      if ( v3 == -2 )
      {
        v11 = CStreaming::ms_pedsLoaded[i];
        if ( v11 >= 0 )
        {
          v12 = v11;
          v13 = &CStreaming::ms_aInfoForModel[v11];
          m_flags = v13->m_flags;
          v13->m_flags = m_flags & 0xFD;
          if ( (m_flags & 4) == 0 )
          {
            if ( CStreaming::ms_aInfoForModel[v11].m_status == 1 )
            {
              if ( (unsigned __int16)v13->m_nextIndex == 0xFFFF )
              {
                v15 = CStreaming::ms_pStartLoadedList;
                v16 = CStreamingInfo::ms_pArrayBase;
                v13->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
                v17 = -858993459 * ((unsigned int)((char *)v13 - (char *)v16) >> 2);
                CStreaming::ms_aInfoForModel[v12].m_prevIndex = -13107
                                                              * ((unsigned int)((char *)v15 - (char *)v16) >> 2);
                v15->m_nextIndex = v17;
                CStreamingInfo::ms_pArrayBase[v13->m_nextIndex].m_prevIndex = v17;
              }
            }
            else if ( (m_flags & 8) == 0 )
            {
              CStreaming::RemoveModel(v11);
            }
          }
          CStreaming::ms_pedsLoaded[i] = -1;
          --CStreaming::ms_numPedsLoaded;
        }
      }
    }
    else
    {
      v4 = CStreaming::ms_pedsLoaded[i];
      if ( v4 >= 0 )
      {
        v5 = v4;
        v6 = &CStreaming::ms_aInfoForModel[v4];
        v7 = v6->m_flags;
        v6->m_flags = v7 & 0xFD;
        if ( (v7 & 4) == 0 )
        {
          if ( CStreaming::ms_aInfoForModel[v4].m_status == 1 )
          {
            if ( (unsigned __int16)v6->m_nextIndex == 0xFFFF )
            {
              v8 = CStreaming::ms_pStartLoadedList;
              v9 = CStreamingInfo::ms_pArrayBase;
              v6->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
              v10 = -13107 * ((unsigned int)((char *)v6 - (char *)v9) >> 2);
              CStreaming::ms_aInfoForModel[v5].m_prevIndex = -13107 * ((unsigned int)((char *)v8 - (char *)v9) >> 2);
              v8->m_nextIndex = v10;
              CStreamingInfo::ms_pArrayBase[v6->m_nextIndex].m_prevIndex = v10;
            }
          }
          else if ( (v7 & 8) == 0 )
          {
            CStreaming::RemoveModel(v4);
          }
        }
        CStreaming::ms_pedsLoaded[i] = -1;
        --CStreaming::ms_numPedsLoaded;
        v3 = pMI[i];
      }
      CStreaming::RequestModel(v3, 8);
      CStreaming::ms_pedsLoaded[i] = pMI[i];
      ++CStreaming::ms_numPedsLoaded;
    }
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D94A0) --------------------------------------------------------
void CStreaming::RemoveDodgyPedsFromRandomSlots()
{
  int v0; // r4
  CStreamingInfo *v1; // r9
  CStreamingInfo *v2; // r12
  int32 v3; // r0
  int32 v4; // r2
  CStreamingInfo *v5; // r1
  uint8 m_flags; // r6
  CStreamingInfo *v7; // r5
  CStreamingInfo *v8; // r0
  CStreamingInfo *v9; // r9
  unsigned int v10; // r3
  unsigned int v11; // r6
  CStreamingInfo *v12; // r6
  int32 v13; // r0

  v0 = 0;
  v1 = CStreaming::ms_aInfoForModel;
  v2 = CStreaming::ms_aInfoForModel;
  do
  {
    v3 = CStreaming::ms_pedsLoaded[v0];
    if ( (unsigned int)(v3 - 244) <= 0xD && ((1 << (v3 + 12)) & 0x3005) != 0 || v3 == 87 )
    {
      v4 = v3;
      v5 = &v1[v3];
      m_flags = v5->m_flags;
      v5->m_flags = m_flags & 0xFD;
      if ( (m_flags & 4) == 0 )
      {
        if ( v2[v3].m_status == 1 )
        {
          if ( (unsigned __int16)v5->m_nextIndex == 0xFFFF )
          {
            v7 = v1;
            v8 = CStreaming::ms_pStartLoadedList;
            v9 = CStreamingInfo::ms_pArrayBase;
            v10 = (char *)CStreaming::ms_pStartLoadedList - (char *)CStreamingInfo::ms_pArrayBase;
            v5->m_nextIndex = CStreaming::ms_pStartLoadedList->m_nextIndex;
            v11 = -858993459 * ((unsigned int)((char *)v5 - (char *)v9) >> 2);
            v1 = v7;
            CStreaming::ms_aInfoForModel[v4].m_prevIndex = -13107 * (v10 >> 2);
            v8->m_nextIndex = v11;
            CStreamingInfo::ms_pArrayBase[v5->m_nextIndex].m_prevIndex = v11;
          }
        }
        else if ( (m_flags & 8) == 0 )
        {
          v12 = v2;
          CStreaming::RemoveModel(v3);
          v2 = v12;
        }
      }
      v13 = CStreaming::ms_numPedsLoaded;
      CStreaming::ms_pedsLoaded[v0] = -1;
      CStreaming::ms_numPedsLoaded = v13 - 1;
    }
    ++v0;
  }
  while ( v0 != 8 );
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002D95E4) --------------------------------------------------------
bool __fastcall CStreaming::CarIsCandateForRemoval(Int32 MI)
{
  Int32 v1; // r0
  int m_status; // r0

  if ( CModelInfo::ms_modelInfoPtrs[MI]->m_numRefs || (v1 = MI, (CStreaming::ms_aInfoForModel[v1].m_flags & 6) != 0) )
  {
    LOBYTE(m_status) = 0;
  }
  else
  {
    m_status = CStreaming::ms_aInfoForModel[v1].m_status;
    if ( m_status != 1 )
      LOBYTE(m_status) = 0;
  }
  return m_status;
}

//----- (002D962C) --------------------------------------------------------
int32 CStreaming::GetGta3ImageIndex()
{
  return gGta3ImageIndex;
}

//----- (002D9638) --------------------------------------------------------
void __fastcall CBox::Set(CBox *this, const CVector *vecMin, const CVector *vecMax)
{
  __int64 v3; // d16
  __int64 v4; // d16

  v3 = *(_QWORD *)&vecMin->x;
  this->m_vecMin.z = vecMin->z;
  *(_QWORD *)&this->m_vecMin.x = v3;
  v4 = *(_QWORD *)&vecMax->x;
  this->m_vecMax.z = vecMax->z;
  *(_QWORD *)&this->m_vecMax.x = v4;
}

//----- (002D9652) --------------------------------------------------------
void __fastcall CBox::Recalc(CBox *this)
{
  float x; // s2
  float y; // s0
  float v3; // s2
  float z; // s0
  float v5; // s2

  x = this->m_vecMax.x;
  if ( this->m_vecMin.x > x )
  {
    this->m_vecMax.x = this->m_vecMin.x;
    this->m_vecMin.x = x;
  }
  y = this->m_vecMin.y;
  v3 = this->m_vecMax.y;
  if ( y > v3 )
  {
    this->m_vecMax.y = y;
    this->m_vecMin.y = v3;
  }
  z = this->m_vecMin.z;
  v5 = this->m_vecMax.z;
  if ( z > v5 )
  {
    this->m_vecMax.z = z;
    this->m_vecMin.z = v5;
  }
}

//----- (002D96A2) --------------------------------------------------------
void __fastcall CColBox::Set(
        CColBox *this,
        const CVector *vecMin,
        const CVector *vecMax,
        uint8 nSurfaceType,
        uint8 nPieceType,
        uint8 nLighting)
{
  __int64 v6; // d16
  __int64 v7; // d16

  v6 = *(_QWORD *)&vecMin->x;
  this->m_vecMin.z = vecMin->z;
  *(_QWORD *)&this->m_vecMin.x = v6;
  v7 = *(_QWORD *)&vecMax->x;
  this->m_vecMax.z = vecMax->z;
  this->m_data.m_nSurfaceType = nSurfaceType;
  this->m_data.m_nPieceType = nPieceType;
  this->m_data.m_lighting = nLighting;
  *(_QWORD *)&this->m_vecMax.x = v7;
}

//----- (002D96C8) --------------------------------------------------------
CColBox *__fastcall CColBox::operator=(CColBox *this, const CColBox *s)
{
  __int64 v2; // d16
  __int64 v3; // d16
  uint8 m_lighting; // r2
  __int16 v5; // r1

  v2 = *(_QWORD *)&s->m_vecMin.x;
  this->m_vecMin.z = s->m_vecMin.z;
  *(_QWORD *)&this->m_vecMin.x = v2;
  v3 = *(_QWORD *)&s->m_vecMax.x;
  this->m_vecMax.z = s->m_vecMax.z;
  *(_QWORD *)&this->m_vecMax.x = v3;
  m_lighting = s->m_data.m_lighting;
  v5 = *(_WORD *)&s->m_data.m_nSurfaceType;
  this->m_data.m_lighting = m_lighting;
  *(_WORD *)&this->m_data.m_nSurfaceType = v5;
  return this;
}

//----- (002D96EC) --------------------------------------------------------
void __fastcall CColLine::CColLine(CColLine *this, const CVector *vecStart, const CVector *vecEnd)
{
  __int64 v3; // d16
  __int64 v4; // d16

  v3 = *(_QWORD *)&vecStart->x;
  this->m_vecStart.z = vecStart->z;
  *(_QWORD *)&this->m_vecStart.x = v3;
  v4 = *(_QWORD *)&vecEnd->x;
  this->m_vecEnd.z = vecEnd->z;
  *(_QWORD *)&this->m_vecEnd.x = v4;
}

//----- (002D9706) --------------------------------------------------------
void __fastcall CColLine::Set(CColLine *this, const CVector *vecStart, const CVector *vecEnd)
{
  __int64 v3; // d16
  __int64 v4; // d16

  v3 = *(_QWORD *)&vecStart->x;
  this->m_vecStart.z = vecStart->z;
  *(_QWORD *)&this->m_vecStart.x = v3;
  v4 = *(_QWORD *)&vecEnd->x;
  this->m_vecEnd.z = vecEnd->z;
  *(_QWORD *)&this->m_vecEnd.x = v4;
}

//----- (002D9720) --------------------------------------------------------
void CCollision::Init()
{
  CLink<CCollisionData *> *v0; // r0
  CLink<CCollisionData *> *v1; // lr
  int v2; // r0
  unsigned int v3; // r1
  CLink<CCollisionData *> *m_pStore; // r4
  CLink<CCollisionData *> *v5; // r3

  v0 = (CLink<CCollisionData *> *)operator new[](0x258u);
  v1 = v0 + 48;
  CCollision::ms_colModelCache.m_pStore = v0;
  CCollision::ms_colModelCache.m_firstLink.m_pNext = &CCollision::ms_colModelCache.m_lastLink;
  CCollision::ms_colModelCache.m_lastLink.m_pPrev = (CLink<CCollisionData *> *)&CCollision::ms_colModelCache;
  CCollision::ms_colModelCache.m_lastFreeLink.m_pPrev = v0 + 49;
  v0[49].m_pPrev = &CCollision::ms_colModelCache.m_firstFreeLink;
  v0[49].m_pNext = &CCollision::ms_colModelCache.m_lastFreeLink;
  CCollision::ms_colModelCache.m_firstFreeLink.m_pNext = v0 + 49;
  v0[48].m_pNext = v0 + 49;
  CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->m_pPrev = v0 + 48;
  v0[48].m_pPrev = &CCollision::ms_colModelCache.m_firstFreeLink;
  v2 = 48;
  CCollision::ms_colModelCache.m_firstFreeLink.m_pNext = v1;
  v3 = 564;
  do
  {
    m_pStore = CCollision::ms_colModelCache.m_pStore;
    --v2;
    v5 = &CCollision::ms_colModelCache.m_pStore[v3 / 0xC];
    v3 -= 12;
    v5->m_pNext = v1;
    CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->m_pPrev = v5;
    v5->m_pPrev = &CCollision::ms_colModelCache.m_firstFreeLink;
    CCollision::ms_colModelCache.m_firstFreeLink.m_pNext = v5;
    v1 = &m_pStore[v2];
  }
  while ( v3 != -12 );
  CCollision::ms_collisionInMemory = LEVEL_GENERIC;
  sub_18CC84();
}

//----- (002D97C0) --------------------------------------------------------
void CCollision::Shutdown()
{
  CLinkList<CCollisionData *> *i; // r4

  for ( i = (CLinkList<CCollisionData *> *)CCollision::ms_colModelCache.m_lastLink.m_pPrev;
        i != &CCollision::ms_colModelCache;
        i = (CLinkList<CCollisionData *> *)i->m_firstLink.m_pPrev )
  {
    if ( i->m_firstLink.item )
      CCollisionData::RemoveTrianglePlanes(i->m_firstLink.item);
  }
  if ( CCollision::ms_colModelCache.m_pStore )
    operator delete[](CCollision::ms_colModelCache.m_pStore);
  CCollision::ms_colModelCache.m_pStore = 0;
  sub_1940E0();
}

//----- (002D981C) --------------------------------------------------------
void CCollision::SortOutCollisionAfterLoad()
{
  CColStore::LoadCollision(*(CVector *)&TheCamera.m_cameraMatrix.tx, 0);
  sub_19F678(0);
}

//----- (002D9848) --------------------------------------------------------
void __fastcall CCollision::CalculateTrianglePlanes(CColModel *pModel)
{
  CCollisionData *m_pColData; // r0

  m_pColData = pModel->m_pColData;
  if ( m_pColData )
    CCollision::CalculateTrianglePlanes(m_pColData);
}

//----- (002D9854) --------------------------------------------------------
void __fastcall CCollision::CalculateTrianglePlanes(CCollisionData *pColData)
{
  CLink<CCollisionData *> *LinkPtr; // r0
  CLinkList<CCollisionData *> *m_pNext; // r5
  __int64 v4; // r0
  __int64 v5; // r0

  if ( pColData->m_nNoOfTriangles )
  {
    if ( pColData->m_pTrianglePlaneArray )
    {
      LinkPtr = CCollisionData::GetLinkPtr(pColData);
      LinkPtr->m_pNext->m_pPrev = LinkPtr->m_pPrev;
      LinkPtr->m_pPrev->m_pNext = LinkPtr->m_pNext;
      LinkPtr->m_pNext = CCollision::ms_colModelCache.m_firstLink.m_pNext;
      CCollision::ms_colModelCache.m_firstLink.m_pNext->m_pPrev = LinkPtr;
      LinkPtr->m_pPrev = (CLink<CCollisionData *> *)&CCollision::ms_colModelCache;
      CCollision::ms_colModelCache.m_firstLink.m_pNext = LinkPtr;
    }
    else
    {
      m_pNext = (CLinkList<CCollisionData *> *)CCollision::ms_colModelCache.m_firstFreeLink.m_pNext;
      if ( CCollision::ms_colModelCache.m_firstFreeLink.m_pNext == &CCollision::ms_colModelCache.m_lastFreeLink )
        goto LABEL_7;
      v4 = *(_QWORD *)&CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->m_pPrev;
      CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->item = pColData;
      *(_DWORD *)(HIDWORD(v4) + 4) = v4;
      m_pNext->m_firstLink.m_pPrev->m_pNext = m_pNext->m_firstLink.m_pNext;
      m_pNext->m_firstLink.m_pNext = CCollision::ms_colModelCache.m_firstLink.m_pNext;
      CCollision::ms_colModelCache.m_firstLink.m_pNext->m_pPrev = &m_pNext->m_firstLink;
      m_pNext->m_firstLink.m_pPrev = (CLink<CCollisionData *> *)&CCollision::ms_colModelCache;
      CCollision::ms_colModelCache.m_firstLink.m_pNext = &m_pNext->m_firstLink;
      if ( !m_pNext )
      {
LABEL_7:
        m_pNext = (CLinkList<CCollisionData *> *)CCollision::ms_colModelCache.m_lastLink.m_pPrev;
        CCollisionData::RemoveTrianglePlanes(CCollision::ms_colModelCache.m_lastLink.m_pPrev->item);
        m_pNext->m_firstLink.m_pNext->m_pPrev = m_pNext->m_firstLink.m_pPrev;
        m_pNext->m_firstLink.m_pPrev->m_pNext = m_pNext->m_firstLink.m_pNext;
        m_pNext->m_firstLink.m_pNext = CCollision::ms_colModelCache.m_firstFreeLink.m_pNext;
        CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->m_pPrev = &m_pNext->m_firstLink;
        m_pNext->m_firstLink.m_pPrev = &CCollision::ms_colModelCache.m_firstFreeLink;
        CCollision::ms_colModelCache.m_firstFreeLink.m_pNext = &m_pNext->m_firstLink;
        if ( m_pNext == (CLinkList<CCollisionData *> *)&CCollision::ms_colModelCache.m_lastFreeLink )
        {
          m_pNext = 0;
        }
        else
        {
          v5 = *(_QWORD *)&m_pNext->m_firstLink.m_pPrev;
          m_pNext->m_firstLink.item = pColData;
          *(_DWORD *)(HIDWORD(v5) + 4) = v5;
          m_pNext->m_firstLink.m_pPrev->m_pNext = m_pNext->m_firstLink.m_pNext;
          m_pNext->m_firstLink.m_pNext = CCollision::ms_colModelCache.m_firstLink.m_pNext;
          CCollision::ms_colModelCache.m_firstLink.m_pNext->m_pPrev = &m_pNext->m_firstLink;
          m_pNext->m_firstLink.m_pPrev = (CLink<CCollisionData *> *)&CCollision::ms_colModelCache;
          CCollision::ms_colModelCache.m_firstLink.m_pNext = &m_pNext->m_firstLink;
        }
      }
      CCollisionData::CalculateTrianglePlanes(pColData);
      j_CCollisionData::SetLinkPtr(pColData, &m_pNext->m_firstLink);
    }
  }
}

//----- (002D9944) --------------------------------------------------------
void __fastcall CCollision::RemoveTrianglePlanes(CColModel *pModel)
{
  CCollisionData *m_pColData; // r4
  bool v2; // zf
  CLink<CCollisionData *> *LinkPtr; // r0

  m_pColData = pModel->m_pColData;
  v2 = m_pColData == 0;
  if ( m_pColData )
    v2 = m_pColData->m_pTrianglePlaneArray == 0;
  if ( !v2 )
  {
    LinkPtr = CCollisionData::GetLinkPtr(m_pColData);
    LinkPtr->m_pNext->m_pPrev = LinkPtr->m_pPrev;
    LinkPtr->m_pPrev->m_pNext = LinkPtr->m_pNext;
    LinkPtr->m_pNext = CCollision::ms_colModelCache.m_firstFreeLink.m_pNext;
    CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->m_pPrev = LinkPtr;
    LinkPtr->m_pPrev = &CCollision::ms_colModelCache.m_firstFreeLink;
    CCollision::ms_colModelCache.m_firstFreeLink.m_pNext = LinkPtr;
    sub_1A0688(m_pColData);
  }
}

//----- (002D998C) --------------------------------------------------------
void __fastcall CCollision::RemoveTrianglePlanes(CCollisionData *pColData)
{
  CLink<CCollisionData *> *LinkPtr; // r0

  if ( pColData->m_pTrianglePlaneArray )
  {
    LinkPtr = CCollisionData::GetLinkPtr(pColData);
    LinkPtr->m_pNext->m_pPrev = LinkPtr->m_pPrev;
    LinkPtr->m_pPrev->m_pNext = LinkPtr->m_pNext;
    LinkPtr->m_pNext = CCollision::ms_colModelCache.m_firstFreeLink.m_pNext;
    CCollision::ms_colModelCache.m_firstFreeLink.m_pNext->m_pPrev = LinkPtr;
    LinkPtr->m_pPrev = &CCollision::ms_colModelCache.m_firstFreeLink;
    CCollision::ms_colModelCache.m_firstFreeLink.m_pNext = LinkPtr;
    sub_1A0688(pColData);
  }
}

//----- (002D99D0) --------------------------------------------------------
bool __fastcall CCollision::TestSphereSphere(const CColSphere *sphereA, const CColSphere *sphereB)
{
  float v2; // s0
  float32x2_t v3; // d16
  float m_fRadius; // s4
  bool result; // r0
  float v6; // s2
  unsigned __int64 v7; // d2

  v2 = sphereA->m_vecCentre.x - sphereB->m_vecCentre.x;
  v3.n64_u64[0] = vsub_f32(*(float32x2_t *)&sphereA->m_vecCentre.y, *(float32x2_t *)&sphereB->m_vecCentre.y).n64_u64[0];
  m_fRadius = sphereA->m_fRadius;
  result = 0;
  v6 = m_fRadius + sphereB->m_fRadius;
  v7 = vmul_f32(v3, v3).n64_u64[0];
  if ( (float)((float)((float)(v2 * v2) + *(float *)&v7) + *((float *)&v7 + 1)) < (float)(v6 * v6) )
    return 1;
  return result;
}

//----- (002D9A18) --------------------------------------------------------
bool __fastcall CCollision::ProcessSphereSphere(
        const CColSphere *sphereA,
        const CColSphere *sphereB,
        CColPoint *colPoint,
        float *fDistanceSqr)
{
  float32x2_t v4; // d1
  float32x2_t v5; // d8
  float x; // s6
  bool result; // r0
  RwReal v12; // s0
  RwReal v13; // s4
  float v14; // s6
  float m_fRadius; // s20
  float v16; // s22
  RwReal v17; // s2
  RwReal v18; // s4
  __int64 v19; // d16
  __int16 v20; // r1
  __int16 v21; // r1
  CVector v22; // [sp+0h] [bp-40h] BYREF

  x = sphereA->m_vecCentre.x;
  result = 0;
  v12 = x - sphereB->m_vecCentre.x;
  v4.n64_f32[0] = sphereA->m_vecCentre.y - sphereB->m_vecCentre.y;
  v13 = sphereA->m_vecCentre.z - sphereB->m_vecCentre.z;
  v14 = v4.n64_f32[0] * v4.n64_f32[0];
  v22.y = v4.n64_f32[0];
  v22.x = v12;
  v22.z = v13;
  v4.n64_u32[0] = 0;
  m_fRadius = sphereA->m_fRadius;
  v5.n64_f32[0] = sqrtf((float)((float)(v12 * v12) + v14) + (float)(v13 * v13)) - sphereB->m_fRadius;
  v16 = vmax_f32(v5, v4).n64_f32[0];
  if ( v16 < m_fRadius )
  {
    CVector::Normalise(&v22);
    v17 = sphereA->m_vecCentre.y - (float)(v16 * v22.y);
    v18 = sphereA->m_vecCentre.z - (float)(v16 * v22.z);
    colPoint->m_vecPosition.x = sphereA->m_vecCentre.x - (float)(v16 * v22.x);
    colPoint->m_vecPosition.y = v17;
    colPoint->m_vecPosition.z = v18;
    v19 = *(_QWORD *)&v22.x;
    colPoint->m_vecNormal.z = v22.z;
    *(_QWORD *)&colPoint->m_vecNormal.x = v19;
    v20 = *(_WORD *)&sphereA->m_data.m_nSurfaceType;
    colPoint->m_dataA.m_lighting = sphereA->m_data.m_lighting;
    *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = v20;
    v21 = *(_WORD *)&sphereB->m_data.m_nSurfaceType;
    colPoint->m_dataB.m_lighting = sphereB->m_data.m_lighting;
    result = 1;
    *(_WORD *)&colPoint->m_dataB.m_nSurfaceType = v21;
    colPoint->m_fDepth = m_fRadius - v5.n64_f32[0];
    *fDistanceSqr = v16 * v16;
  }
  return result;
}
// 2D9A88: variable 'v5' is possibly undefined
// 2D9A88: variable 'v4' is possibly undefined

//----- (002D9B2C) --------------------------------------------------------
void __fastcall CalculateColPointInsideBox(const CBox *box, const CVector *vec, CColPoint *colPoint)
{
  const CBox *v3; // r12
  const CBox *v4; // r3
  float y; // s14
  float z; // s1
  float v7; // s0
  float v8; // s2
  float v9; // s4
  bool v10; // fzf
  bool v11; // fnf
  float x; // s6
  const CVector *p_m_vecMax; // r3
  float v14; // s12
  float v15; // s10
  float v16; // s8
  __int64 v17; // d16
  float v18; // s6
  RwReal v19; // s0
  RwReal v20; // s0
  RwReal v21; // s2

  v3 = box;
  v4 = box;
  y = vec->y;
  z = vec->z;
  v7 = y - (float)((float)(box->m_vecMax.y + box->m_vecMin.y) * 0.5);
  v8 = z - (float)((float)(box->m_vecMax.z + box->m_vecMin.z) * 0.5);
  v9 = vec->x - (float)((float)(box->m_vecMax.x + box->m_vecMin.x) * 0.5);
  if ( v7 > 0.0 )
    v3 = (const CBox *)vec;
  if ( v8 > 0.0 )
    z = box->m_vecMax.z;
  v10 = v9 == 0.0;
  v11 = v9 < 0.0;
  if ( v7 > 0.0 )
    y = box->m_vecMax.y;
  if ( !v11 && !v10 )
    v4 = (const CBox *)vec;
  x = v4->m_vecMin.x;
  p_m_vecMax = vec;
  if ( !v11 && !v10 )
    p_m_vecMax = &box->m_vecMax;
  v14 = v3->m_vecMin.y;
  v15 = p_m_vecMax->x - x;
  v16 = y - v14;
  if ( v8 > 0.0 )
    box = (const CBox *)vec;
  v17 = *(_QWORD *)&vec->x;
  v18 = z - box->m_vecMin.z;
  colPoint->m_vecPosition.z = vec->z;
  *(_QWORD *)&colPoint->m_vecPosition.x = v17;
  if ( v15 < (float)(y - v14) )
  {
    v20 = -1.0;
    if ( v9 > 0.0 )
      v20 = 1.0;
    colPoint->m_vecNormal.y = 0.0;
    colPoint->m_vecNormal.z = 0.0;
    colPoint->m_vecNormal.x = v20;
    colPoint->m_fDepth = v15;
  }
  else
  {
    colPoint->m_vecNormal.x = 0.0;
    if ( v16 < v15 )
    {
      v21 = -1.0;
      if ( v7 > 0.0 )
        v21 = 1.0;
      colPoint->m_vecNormal.z = 0.0;
      colPoint->m_vecNormal.y = v21;
      colPoint->m_fDepth = v16;
    }
    else
    {
      v19 = -1.0;
      if ( v8 > 0.0 )
        v19 = 1.0;
      colPoint->m_vecNormal.y = 0.0;
      colPoint->m_vecNormal.z = v19;
      colPoint->m_fDepth = v18;
    }
  }
}

//----- (002D9C8C) --------------------------------------------------------
bool __fastcall CCollision::TestSphereBox(const CSphere *sphere, const CBox *box)
{
  float m_fRadius; // s0
  float y; // s2
  float z; // s2
  bool result; // r0

  m_fRadius = sphere->m_fRadius;
  result = 0;
  if ( (float)(sphere->m_vecCentre.x + m_fRadius) >= box->m_vecMin.x
    && (float)(sphere->m_vecCentre.x - m_fRadius) <= box->m_vecMax.x )
  {
    y = sphere->m_vecCentre.y;
    if ( (float)(m_fRadius + y) >= box->m_vecMin.y && (float)(y - m_fRadius) <= box->m_vecMax.y )
    {
      z = sphere->m_vecCentre.z;
      if ( (float)(m_fRadius + z) >= box->m_vecMin.z && (float)(z - m_fRadius) <= box->m_vecMax.z )
        return 1;
    }
  }
  return result;
}

//----- (002D9D10) --------------------------------------------------------
bool __fastcall CCollision::ProcessSphereBox(
        const CColSphere *sphere,
        const CColBox *box,
        CColPoint *colPoint,
        float *fDistanceSqr)
{
  float x; // s2
  float m_fRadius; // s0
  float v10; // s8
  float v11; // s14
  float y; // s4
  float v13; // s12
  float v14; // s14
  float z; // s6
  float v16; // s10
  float v17; // s14
  float v18; // s6
  float v19; // s1
  float v20; // s1
  float v21; // s12
  float v22; // s1
  float v23; // s8
  float v24; // s3
  float v25; // s8
  float v26; // s14
  float v27; // s1
  float v28; // s14
  float v29; // s6
  float v30; // s2
  float v31; // s4
  __int16 v33; // r1
  __int16 v34; // r1
  float v35; // s4
  float v36; // s2
  float v37; // s6
  float v38; // s8
  float v39; // s0
  RwReal v40; // s2
  RwReal v41; // s4
  RwReal v42; // s0
  __int16 v43; // r1
  __int16 v44; // r1

  x = sphere->m_vecCentre.x;
  m_fRadius = sphere->m_fRadius;
  v10 = box->m_vecMin.x;
  if ( (float)(sphere->m_vecCentre.x + m_fRadius) < box->m_vecMin.x )
    return 0;
  v11 = box->m_vecMax.x;
  if ( (float)(x - m_fRadius) > v11 )
    return 0;
  if ( x >= v10 )
  {
    y = sphere->m_vecCentre.y;
    v13 = box->m_vecMin.y;
    v18 = m_fRadius + y;
    if ( x <= v11 )
    {
      if ( v18 < v13 )
        return 0;
      v14 = box->m_vecMax.y;
      if ( (float)(y - m_fRadius) > v14 )
        return 0;
      if ( y < v13 )
      {
        z = sphere->m_vecCentre.z;
        v16 = box->m_vecMin.z;
        if ( (float)(m_fRadius + z) < v16 )
          return 0;
        v17 = box->m_vecMax.z;
        if ( (float)(z - m_fRadius) > v17 )
          return 0;
        if ( z < v16 )
        {
          v10 = sphere->m_vecCentre.x;
          goto LABEL_71;
        }
        v10 = sphere->m_vecCentre.x;
LABEL_58:
        if ( z > v17 )
        {
          v16 = v17;
          goto LABEL_71;
        }
        goto LABEL_70;
      }
      z = sphere->m_vecCentre.z;
      v22 = box->m_vecMin.z;
      v25 = m_fRadius + z;
      if ( y > v14 )
      {
        if ( v25 < v22 )
          return 0;
        v16 = box->m_vecMax.z;
        if ( (float)(z - m_fRadius) > v16 )
          return 0;
        if ( z < v22 )
        {
          v10 = sphere->m_vecCentre.x;
LABEL_42:
          v13 = v14;
          v16 = v22;
          goto LABEL_71;
        }
        v10 = sphere->m_vecCentre.x;
        if ( z <= v16 )
          goto LABEL_66;
        goto LABEL_65;
      }
      if ( v25 < v22 )
        return 0;
      v16 = box->m_vecMax.z;
      if ( (float)(z - m_fRadius) > v16 )
        return 0;
      if ( z >= v22 )
      {
        v10 = sphere->m_vecCentre.x;
        v13 = sphere->m_vecCentre.y;
        if ( z <= v16 )
        {
          CalculateColPointInsideBox(box, &sphere->m_vecCentre, colPoint);
          v35 = colPoint->m_vecPosition.y;
          v36 = colPoint->m_vecPosition.x;
          v37 = colPoint->m_vecPosition.z;
          v38 = colPoint->m_vecNormal.x;
          colPoint->m_fDepth = colPoint->m_fDepth + sphere->m_fRadius;
          v39 = sphere->m_fRadius;
          v40 = v36 - (float)(v39 * v38);
          v41 = v35 - (float)(v39 * colPoint->m_vecNormal.y);
          v42 = v37 - (float)(v39 * colPoint->m_vecNormal.z);
          colPoint->m_vecPosition.x = v40;
          colPoint->m_vecPosition.y = v41;
          colPoint->m_vecPosition.z = v42;
          v43 = *(_WORD *)&sphere->m_data.m_nSurfaceType;
          colPoint->m_dataA.m_lighting = sphere->m_data.m_lighting;
          *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = v43;
          v44 = *(_WORD *)&box->m_data.m_nSurfaceType;
          colPoint->m_dataB.m_lighting = box->m_data.m_lighting;
          *(_WORD *)&colPoint->m_dataB.m_nSurfaceType = v44;
          *fDistanceSqr = 0.0;
          return 1;
        }
        goto LABEL_71;
      }
      v10 = sphere->m_vecCentre.x;
    }
    else
    {
      if ( v18 < v13 )
        return 0;
      v19 = box->m_vecMax.y;
      if ( (float)(y - m_fRadius) > v19 )
        return 0;
      if ( y < v13 )
      {
        z = sphere->m_vecCentre.z;
        v16 = box->m_vecMin.z;
        if ( (float)(m_fRadius + z) < v16 )
          return 0;
        v20 = box->m_vecMax.z;
        if ( (float)(z - m_fRadius) > v20 )
          return 0;
        if ( z < v16 )
        {
          v10 = box->m_vecMax.x;
          goto LABEL_71;
        }
        v10 = box->m_vecMax.x;
        if ( z > v20 )
        {
          v16 = box->m_vecMax.z;
          goto LABEL_71;
        }
        goto LABEL_70;
      }
      z = sphere->m_vecCentre.z;
      v16 = box->m_vecMin.z;
      v23 = m_fRadius + z;
      if ( y > v19 )
      {
        if ( v23 < v16 )
          return 0;
        v24 = box->m_vecMax.z;
        if ( (float)(z - m_fRadius) > v24 )
          return 0;
        if ( z < v16 )
        {
          v10 = box->m_vecMax.x;
          v13 = box->m_vecMax.y;
          goto LABEL_71;
        }
        v10 = box->m_vecMax.x;
        v13 = box->m_vecMax.y;
        if ( z > v24 )
        {
          v16 = box->m_vecMax.z;
          goto LABEL_71;
        }
        goto LABEL_70;
      }
      if ( v23 < v16 )
        return 0;
      v22 = box->m_vecMax.z;
      if ( (float)(z - m_fRadius) > v22 )
        return 0;
      if ( z < v16 )
      {
        v10 = box->m_vecMax.x;
        v13 = sphere->m_vecCentre.y;
        goto LABEL_71;
      }
      v10 = box->m_vecMax.x;
      if ( z <= v22 )
        goto LABEL_69;
    }
    v13 = sphere->m_vecCentre.y;
    v16 = v22;
    goto LABEL_71;
  }
  y = sphere->m_vecCentre.y;
  v13 = box->m_vecMin.y;
  if ( (float)(m_fRadius + y) < v13 )
    return 0;
  v14 = box->m_vecMax.y;
  if ( (float)(y - m_fRadius) > v14 )
    return 0;
  if ( y >= v13 )
  {
    z = sphere->m_vecCentre.z;
    v16 = box->m_vecMin.z;
    v21 = m_fRadius + z;
    if ( y > v14 )
    {
      if ( v21 < v16 )
        return 0;
      v22 = box->m_vecMax.z;
      if ( (float)(z - m_fRadius) > v22 )
        return 0;
      if ( z >= v16 )
      {
        if ( z > v22 )
          goto LABEL_42;
LABEL_66:
        v13 = v14;
LABEL_70:
        v16 = z;
        goto LABEL_71;
      }
LABEL_65:
      v13 = v14;
      goto LABEL_71;
    }
    if ( v21 < v16 )
      return 0;
    v26 = box->m_vecMax.z;
    if ( (float)(z - m_fRadius) > v26 )
      return 0;
    if ( z < v16 )
    {
      v13 = sphere->m_vecCentre.y;
      goto LABEL_71;
    }
    if ( z > v26 )
    {
      v13 = sphere->m_vecCentre.y;
      v16 = box->m_vecMax.z;
      goto LABEL_71;
    }
LABEL_69:
    v13 = y;
    goto LABEL_70;
  }
  z = sphere->m_vecCentre.z;
  v16 = box->m_vecMin.z;
  if ( (float)(m_fRadius + z) < v16 )
    return 0;
  v17 = box->m_vecMax.z;
  if ( (float)(z - m_fRadius) > v17 )
    return 0;
  if ( z >= v16 )
    goto LABEL_58;
LABEL_71:
  v27 = y - v13;
  v28 = x - v10;
  v29 = z - v16;
  v30 = (float)((float)(v28 * v28) + (float)(v27 * v27)) + (float)(v29 * v29);
  if ( v30 >= *fDistanceSqr )
    return 0;
  v31 = sqrtf(v30);
  if ( v31 > m_fRadius )
    return 0;
  colPoint->m_vecPosition.x = v10;
  colPoint->m_vecPosition.y = v13;
  colPoint->m_vecPosition.z = v16;
  colPoint->m_vecNormal.x = v28 * (float)(1.0 / v31);
  colPoint->m_vecNormal.y = v27 * (float)(1.0 / v31);
  colPoint->m_vecNormal.z = v29 * (float)(1.0 / v31);
  v33 = *(_WORD *)&sphere->m_data.m_nSurfaceType;
  colPoint->m_dataA.m_lighting = sphere->m_data.m_lighting;
  *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = v33;
  v34 = *(_WORD *)&box->m_data.m_nSurfaceType;
  colPoint->m_dataB.m_lighting = box->m_data.m_lighting;
  *(_WORD *)&colPoint->m_dataB.m_nSurfaceType = v34;
  colPoint->m_fDepth = sphere->m_fRadius - v31;
  *fDistanceSqr = v30;
  return 1;
}

//----- (002DA1E4) --------------------------------------------------------
bool __fastcall CCollision::PointInTriangle(CCollision *this, const CVector *testPoint, const CVector *triPts)
{
  float y; // s0
  float v4; // s12
  float v5; // s1
  float v6; // s14
  float v7; // s3
  float v8; // s2
  float z; // s4
  float v10; // s0
  float v11; // s6
  float v12; // s8
  float v13; // s4
  float v14; // s5
  float v15; // s10
  float v16; // s9
  float v17; // s1
  float v18; // s3
  float v19; // s12
  float v20; // s6
  float v21; // s10
  float v22; // s8
  bool result; // r0
  float v24; // s0
  float v25; // s2

  y = triPts->y;
  v4 = triPts[2].x - triPts->x;
  v5 = testPoint->x - triPts->x;
  v6 = triPts[2].y - y;
  v7 = testPoint->y - y;
  v8 = triPts[1].x - triPts->x;
  z = triPts->z;
  v10 = triPts[1].y - y;
  v11 = testPoint->z - z;
  v12 = triPts[2].z - z;
  v13 = triPts[1].z - z;
  v14 = (float)(v4 * v5) + (float)(v6 * v7);
  v15 = (float)(v8 * v4) + (float)(v10 * v6);
  v16 = v13 * v11;
  v17 = (float)(v8 * v5) + (float)(v10 * v7);
  v18 = (float)(v4 * v4) + (float)(v6 * v6);
  v19 = v14 + (float)(v12 * v11);
  v20 = v15 + (float)(v13 * v12);
  v21 = v18 + (float)(v12 * v12);
  v22 = (float)(v21 * (float)(v17 + v16)) - (float)(v20 * v19);
  if ( v22 < 0.0 )
    return 0;
  result = 0;
  v24 = (float)((float)(v8 * v8) + (float)(v10 * v10)) + (float)(v13 * v13);
  v25 = (float)(v24 * v19) - (float)(v20 * (float)(v17 + v16));
  if ( v25 >= 0.0 && (float)(v22 + v25) <= (float)((float)(v24 * v21) - (float)(v20 * v20)) )
    return 1;
  return result;
}

//----- (002DA2EE) --------------------------------------------------------
bool __fastcall CCollision::TestSphereTriangle(
        const CColSphere *sphere,
        const CollisionVector *aVectors,
        const CColTriangle *triangle,
        const CColTrianglePlane *plane)
{
  float x; // s0
  float y; // s2
  float z; // s4
  float m_fRadius; // s25
  const CollisionVector *v8; // r0
  float v9; // s6
  float v10; // s8
  float v11; // s10
  const CollisionVector *v12; // r0
  float v13; // s26
  float v14; // s12
  float v15; // s22
  float v16; // s14
  float v17; // s17
  float v18; // s1
  float v19; // s16
  const CollisionVector *v20; // r0
  float v21; // s18
  float v22; // s20
  float v23; // s28
  float v24; // s30
  float v25; // s24
  float v26; // s23
  float v27; // s21
  float v28; // s19
  float v29; // s0
  float v30; // s6
  float v31; // s10
  float v32; // s12
  float v33; // s6
  float v34; // s8
  float v35; // s4
  float v37; // s12
  float v38; // s7
  float v39; // s10
  float v40; // s14
  float v41; // s12
  float v42; // s1
  float v43; // s8
  float v44; // s14
  float v45; // s6
  float v46; // s10
  float v47; // s8
  float v48; // s12
  float v49; // s4
  float v50; // s10
  float v51; // s2
  float v52; // s6
  float v53; // s4
  float v54; // s8
  CVector v2; // [sp+4h] [bp-6Ch] BYREF
  CVector v1; // [sp+10h] [bp-60h] BYREF
  CVector v57; // [sp+1Ch] [bp-54h] BYREF

  x = sphere->m_vecCentre.x;
  y = sphere->m_vecCentre.y;
  z = sphere->m_vecCentre.z;
  m_fRadius = sphere->m_fRadius;
  v8 = &aVectors[triangle->m_nIndex1];
  v9 = v8->x;
  v10 = v8->y;
  v11 = v8->z;
  v12 = &aVectors[triangle->m_nIndex2];
  v13 = v9 - x;
  v14 = v12->x;
  v15 = v11 - z;
  v16 = v12->y;
  v17 = v10 - y;
  v18 = v12->z;
  v19 = v16 - y;
  v20 = &aVectors[triangle->m_nIndex3];
  v21 = v14 - x;
  v22 = v18 - z;
  v23 = v20->x - x;
  v24 = v20->y - y;
  v25 = v20->z - z;
  v26 = (float)(v16 - y) - (float)(v10 - y);
  v27 = (float)(v14 - x) - (float)(v9 - x);
  v28 = (float)(v18 - z) - (float)(v11 - z);
  v1.y = v26;
  v1.x = v27;
  v1.z = v28;
  v2.y = v24 - (float)(v10 - y);
  v2.x = v23 - (float)(v9 - x);
  v2.z = v25 - (float)(v11 - z);
  CrossProduct(&v57, &v1, &v2);
  v29 = m_fRadius * m_fRadius;
  v30 = (float)((float)(v13 * v57.x) + (float)((float)(v10 - y) * v57.y)) + (float)((float)(v11 - z) * v57.z);
  if ( (float)(v30 * v30) > (float)((float)(m_fRadius * m_fRadius)
                                  * (float)((float)((float)(v57.x * v57.x) + (float)(v57.y * v57.y))
                                          + (float)(v57.z * v57.z))) )
    return 0;
  v31 = (float)((float)(v13 * v21) + (float)(v17 * v19)) + (float)(v15 * v22);
  v32 = (float)((float)(v13 * v13) + (float)(v17 * v17)) + (float)(v15 * v15);
  if ( v31 > v32 && v32 > v29 )
    return 0;
  v33 = (float)((float)(v21 * v21) + (float)(v19 * v19)) + (float)(v22 * v22);
  v34 = (float)((float)(v21 * v23) + (float)(v19 * v24)) + (float)(v22 * v25);
  if ( v31 > v33 && v33 > v29 )
    return 0;
  v35 = (float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25);
  if ( v34 > v35 && v35 > v29 )
    return 0;
  v37 = v31 - v32;
  v38 = v28 * v37;
  v39 = (float)((float)(v27 * v27) + (float)(v26 * v26)) + (float)(v28 * v28);
  v40 = (float)(v17 * v39) - (float)(v26 * v37);
  v41 = (float)(v13 * v39) - (float)(v27 * v37);
  v42 = (float)(v15 * v39) - v38;
  if ( (float)((float)(v42 * v42) + (float)((float)(v41 * v41) + (float)(v40 * v40))) > (float)(v39 * (float)(v39 * v29))
    && (float)((float)(v42 * (float)((float)(v39 * v25) - v42))
             + (float)((float)(v41 * (float)((float)(v23 * v39) - v41))
                     + (float)(v40 * (float)((float)(v24 * v39) - v40)))) > 0.0 )
  {
    return 0;
  }
  v43 = v34 - v33;
  v44 = (float)(v25 - v22) * v43;
  v45 = (float)((float)((float)(v23 - v21) * (float)(v23 - v21)) + (float)((float)(v24 - v19) * (float)(v24 - v19)))
      + (float)((float)(v25 - v22) * (float)(v25 - v22));
  v46 = (float)(v19 * v45) - (float)((float)(v24 - v19) * v43);
  v47 = (float)(v21 * v45) - (float)((float)(v23 - v21) * v43);
  v48 = (float)(v22 * v45) - v44;
  if ( (float)((float)(v48 * v48) + (float)((float)(v47 * v47) + (float)(v46 * v46))) > (float)(v45 * (float)(v29 * v45))
    && (float)((float)(v48 * (float)((float)(v15 * v45) - v48))
             + (float)((float)(v47 * (float)((float)(v13 * v45) - v47))
                     + (float)(v46 * (float)((float)(v17 * v45) - v46)))) > 0.0 )
  {
    return 0;
  }
  v49 = (float)((float)((float)(v13 * v23) + (float)(v17 * v24)) + (float)(v15 * v25)) - v35;
  v50 = (float)(v15 - v25) * v49;
  v51 = (float)((float)((float)(v13 - v23) * (float)(v13 - v23)) + (float)((float)(v17 - v24) * (float)(v17 - v24)))
      + (float)((float)(v15 - v25) * (float)(v15 - v25));
  v52 = (float)(v24 * v51) - (float)((float)(v17 - v24) * v49);
  v53 = (float)(v23 * v51) - (float)((float)(v13 - v23) * v49);
  v54 = (float)(v25 * v51) - v50;
  return (float)((float)(v54 * v54) + (float)((float)(v53 * v53) + (float)(v52 * v52))) <= (float)(v51
                                                                                                 * (float)(v29 * v51))
      || (float)((float)(v54 * (float)((float)(v22 * v51) - v54))
               + (float)((float)(v53 * (float)((float)(v21 * v51) - v53))
                       + (float)(v52 * (float)((float)(v19 * v51) - v52)))) <= 0.0;
}

//----- (002DA6B8) --------------------------------------------------------
int __fastcall CCollision::ProcessSphereTriangle(
        const CColSphere *sphere,
        const CollisionVector *aVectors,
        const CColTriangle *triangle,
        const CColTrianglePlane *plane,
        int a5,
        float *a6)
{
  __int64 v6; // d16
  float v9; // s23
  float v10; // s22
  int v11; // r6
  float v12; // s30
  const CollisionVector *v13; // r0
  float x; // s16
  float y; // s18
  float z; // s20
  const CollisionVector *v17; // r0
  float v18; // s28
  float v19; // s27
  float v20; // s29
  float v21; // s31
  const CollisionVector *v22; // r0
  float v23; // s21
  float v24; // s19
  float v25; // s17
  float v26; // s25
  int v27; // r0
  float v28; // s3
  float v29; // s5
  float v30; // s12
  float v31; // s9
  float v32; // s0
  float v33; // s2
  float v34; // s7
  float v35; // s15
  float v36; // s13
  float v37; // s26
  float v38; // s1
  float v39; // s14
  float v40; // s12
  float v41; // s2
  float v42; // s0
  float v43; // s2
  float v44; // s0
  float v45; // s4
  float v46; // s0
  float v47; // s2
  float v48; // s2
  float v49; // s0
  float v50; // s2
  float v51; // s0
  float v52; // s2
  float v53; // s0
  float v54; // s2
  __int64 v55; // d16
  __int16 v56; // r1
  uint8 m_nSurfaceType; // r0
  float v59; // [sp+4h] [bp-9Ch]
  float v60; // [sp+8h] [bp-98h]
  float v61; // [sp+Ch] [bp-94h]
  float v62; // [sp+10h] [bp-90h]
  float v63; // [sp+14h] [bp-8Ch]
  CVector v64; // [sp+18h] [bp-88h] BYREF
  CVector v65; // [sp+28h] [bp-78h] BYREF
  CVector v1; // [sp+34h] [bp-6Ch] BYREF
  CVector v2; // [sp+40h] [bp-60h] BYREF

  v6 = *(_QWORD *)&plane->m_compressedNormal.x;
  v2.z = plane->m_compressedNormal.z;
  *(_QWORD *)&v2.x = v6;
  v9 = (float)((float)((float)(sphere->m_vecCentre.x * *(float *)&v6)
                     + (float)(sphere->m_vecCentre.y * *((float *)&v6 + 1)))
             + (float)(sphere->m_vecCentre.z * v2.z))
     - plane->m_compressedNormalOffset;
  v10 = fabsf(v9);
  if ( v10 > sphere->m_fRadius )
    return 0;
  v12 = v9 * v9;
  v11 = 0;
  if ( (float)(v9 * v9) > *a6 )
    return v11;
  v13 = &aVectors[triangle->m_nIndex1];
  x = v13->x;
  y = v13->y;
  z = v13->z;
  v17 = &aVectors[triangle->m_nIndex2];
  v18 = v17->x;
  v19 = v17->x - x;
  v20 = v17->y - y;
  v59 = v17->y;
  v21 = v17->z - z;
  v60 = v17->z;
  v22 = &aVectors[triangle->m_nIndex3];
  v23 = v22->x;
  v24 = v22->y;
  v25 = v22->z;
  v26 = sqrtf((float)((float)(v19 * v19) + (float)(v20 * v20)) + (float)(v21 * v21));
  v1.y = (float)(1.0 / v26) * v20;
  v1.x = v19 * (float)(1.0 / v26);
  v1.z = (float)(1.0 / v26) * v21;
  CrossProduct(&v65, &v1, &v2);
  v27 = 2;
  v28 = (float)((float)((float)(v23 - x) * v65.x) + (float)((float)(v24 - y) * v65.y))
      + (float)((float)(v25 - z) * v65.z);
  v29 = (float)((float)((float)(v23 - x) * v1.x) + (float)((float)(v24 - y) * v1.y)) + (float)((float)(v25 - z) * v1.z);
  v61 = sphere->m_vecCentre.y;
  v63 = sphere->m_vecCentre.x;
  v30 = sphere->m_vecCentre.x - x;
  v62 = sphere->m_vecCentre.z;
  v31 = (float)((float)(v65.x * v30) + (float)(v65.y * (float)(v61 - y))) + (float)(v65.z * (float)(v62 - z));
  v32 = (float)((float)(v1.x * v30) + (float)(v1.y * (float)(v61 - y))) + (float)(v1.z * (float)(v62 - z));
  v33 = v29 - v26;
  v34 = (float)((float)(v29 - v26) * v31) - (float)(v28 * (float)(v32 - v26));
  v35 = (float)(v26 * v31) - (float)(v32 * 0.0);
  v36 = v28 * v32;
  v37 = (float)(v28 * v32) - (float)(v29 * v31);
  if ( v35 < 0.0 )
    v27 = 1;
  else
    v11 = 1;
  if ( v37 < 0.0 )
    v27 = v11;
  if ( v34 >= 0.0 )
    ++v27;
  if ( v27 != 1 )
  {
    if ( v27 != 2 )
    {
      if ( v27 == 3 )
      {
        v38 = sphere->m_vecCentre.y;
        v39 = sphere->m_vecCentre.z;
        v40 = sphere->m_vecCentre.x;
        x = v63 - (float)(v9 * v2.x);
        y = v61 - (float)(v9 * v2.y);
        z = v62 - (float)(v9 * v2.z);
        goto LABEL_36;
      }
      v10 = *a6;
      goto LABEL_30;
    }
    if ( v35 < 0.0 )
    {
      v41 = (float)(v26 * v26) + 0.0;
      v42 = (float)((float)(v26 * v32) + (float)(v31 * 0.0)) / v41;
      if ( v42 > 0.0 )
      {
        if ( v42 < 1.0 )
        {
          v43 = sqrtf(v41);
          y = y + (float)(v20 * v42);
          v10 = sqrtf(v12 + (float)((float)(v35 / v43) * (float)(v35 / v43)));
          z = z + (float)(v21 * v42);
          x = x + (float)(v19 * v42);
LABEL_30:
          v40 = sphere->m_vecCentre.x;
          v39 = sphere->m_vecCentre.z;
          v38 = sphere->m_vecCentre.y;
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_29:
      v10 = sqrtf(
              (float)((float)(v30 * v30) + (float)((float)(v61 - y) * (float)(v61 - y)))
            + (float)((float)(v62 - z) * (float)(v62 - z)));
      goto LABEL_30;
    }
    if ( v37 < 0.0 )
    {
      v48 = (float)(v29 * v29) + (float)(v28 * v28);
      v49 = (float)((float)(v29 * v32) + (float)(v28 * v31)) / v48;
      if ( v49 <= 0.0 )
        goto LABEL_29;
      v40 = sphere->m_vecCentre.x;
      v39 = sphere->m_vecCentre.z;
      v38 = sphere->m_vecCentre.y;
      if ( v49 < 1.0 )
      {
        v50 = sqrtf(v48);
        y = y + (float)((float)(v24 - y) * v49);
        v10 = sqrtf(
                v12
              + (float)((float)((float)((float)(v29 * v31) - v36) / v50)
                      * (float)((float)((float)(v29 * v31) - v36) / v50)));
        z = z + (float)((float)(v25 - z) * v49);
        x = x + (float)((float)(v23 - x) * v49);
        goto LABEL_36;
      }
      goto LABEL_39;
    }
    v51 = v33 * (float)(v32 - v26);
    v52 = (float)(v33 * v33) + (float)(v28 * v28);
    v53 = (float)((float)(v28 * v31) + v51) / v52;
    if ( v53 > 0.0 )
    {
      v40 = sphere->m_vecCentre.x;
      v39 = sphere->m_vecCentre.z;
      v38 = sphere->m_vecCentre.y;
      if ( v53 < 1.0 )
      {
        v54 = sqrtf(v52);
        v10 = sqrtf(v12 + (float)((float)(v34 / v54) * (float)(v34 / v54)));
        z = v60 + (float)((float)(v25 - v60) * v53);
        y = v59 + (float)((float)(v24 - v59) * v53);
        x = v18 + (float)((float)(v23 - v18) * v53);
        goto LABEL_36;
      }
LABEL_39:
      v44 = v38 - v24;
      goto LABEL_24;
    }
LABEL_34:
    x = v18;
    v38 = sphere->m_vecCentre.y;
    v40 = sphere->m_vecCentre.x;
    y = v59;
    v39 = sphere->m_vecCentre.z;
    z = v60;
    v45 = v62 - v60;
    v46 = (float)(v61 - v59) * (float)(v61 - v59);
    v47 = (float)(v63 - v18) * (float)(v63 - v18);
    goto LABEL_35;
  }
  if ( v35 < 0.0 )
  {
    if ( v37 < 0.0 )
      goto LABEL_29;
    goto LABEL_34;
  }
  v38 = sphere->m_vecCentre.y;
  v40 = sphere->m_vecCentre.x;
  v44 = v61 - v24;
  v39 = sphere->m_vecCentre.z;
LABEL_24:
  v45 = v39 - v25;
  v46 = v44 * v44;
  v47 = (float)(v40 - v23) * (float)(v40 - v23);
  x = v23;
  y = v24;
  z = v25;
LABEL_35:
  v10 = sqrtf((float)(v47 + v46) + (float)(v45 * v45));
LABEL_36:
  v11 = 0;
  if ( v10 < sphere->m_fRadius )
  {
    v64.y = v38 - y;
    v64.x = v40 - x;
    v64.z = v39 - z;
    CVector::Normalise(&v64);
    *(float *)a5 = x;
    *(float *)(a5 + 4) = y;
    *(float *)(a5 + 8) = z;
    v55 = *(_QWORD *)&v64.x;
    *(RwReal *)(a5 + 24) = v64.z;
    *(_QWORD *)(a5 + 16) = v55;
    v56 = *(_WORD *)&sphere->m_data.m_nSurfaceType;
    *(_BYTE *)(a5 + 34) = sphere->m_data.m_lighting;
    *(_WORD *)(a5 + 32) = v56;
    m_nSurfaceType = triangle->m_nSurfaceType;
    *(_BYTE *)(a5 + 36) = 0;
    *(_BYTE *)(a5 + 35) = m_nSurfaceType;
    *(float *)(a5 + 40) = sphere->m_fRadius - v10;
    v11 = 1;
    *a6 = v10 * v10;
  }
  return v11;
}

//----- (002DABBC) --------------------------------------------------------
bool __fastcall CCollision::TestLineSphere(const CColLine *line, const CColSphere *sphere)
{
  float x; // s10
  float y; // s14
  float v4; // s6
  float z; // s4
  float v6; // s8
  float v7; // s9
  float v8; // s2
  float v9; // s5
  float v10; // s3
  float v11; // s12
  float v12; // s1
  float v13; // s0
  bool result; // r0
  float v15; // s0
  float v16; // s2
  float v17; // s4
  char v18; // r1
  float v19; // s0

  x = line->m_vecStart.x;
  y = line->m_vecStart.y;
  v4 = line->m_vecEnd.x - line->m_vecStart.x;
  z = line->m_vecStart.z;
  v6 = line->m_vecEnd.y - y;
  v7 = sphere->m_vecCentre.y;
  v8 = line->m_vecEnd.z - z;
  v9 = sphere->m_vecCentre.z;
  v10 = v7 - y;
  v11 = v9 - z;
  v12 = sphere->m_vecCentre.x - line->m_vecStart.x;
  v13 = sqrtf((float)((float)(v4 * v4) + (float)(v6 * v6)) + (float)(v8 * v8));
  if ( v13 < 0.000001 )
    return (float)((float)((float)(v12 * v12) + (float)(v10 * v10)) + (float)(v11 * v11)) <= (float)(sphere->m_fRadius * sphere->m_fRadius);
  result = 0;
  v15 = v13 * v13;
  v16 = (float)((float)((float)(v4 * v12) + (float)(v6 * v10)) + (float)(v8 * v11)) * -2.0;
  v17 = (float)(v16 * v16)
      + (float)((float)(v15 * -4.0)
              * (float)((float)((float)((float)((float)((float)(x * x) + (float)(y * y)) + (float)(z * z))
                                      + (float)((float)((float)(sphere->m_vecCentre.x * sphere->m_vecCentre.x)
                                                      + (float)(v7 * v7))
                                              + (float)(v9 * v9)))
                              + (float)((float)((float)((float)(x * sphere->m_vecCentre.x) + (float)(y * v7))
                                              + (float)(z * v9))
                                      * -2.0))
                      - (float)(sphere->m_fRadius * sphere->m_fRadius)));
  if ( v17 >= 0.0 )
  {
    v18 = 0;
    v19 = (float)((float)-v16 - sqrtf(v17)) / (float)(v15 + v15);
    if ( v19 <= 1.0 )
      v18 = 1;
    if ( v19 >= 0.0 )
      result = 1;
    return result & v18;
  }
  return result;
}

//----- (002DAD1C) --------------------------------------------------------
float __fastcall CCollision::DistToLine(const CVector *pVecStart, const CVector *pVecEnd, const CVector *pPoint)
{
  float y; // s12
  float v4; // s4
  float v5; // s7
  float v6; // s1
  float v7; // s14
  float v8; // s5
  float z; // s3
  float v10; // s12
  float v11; // s2
  float v12; // s10
  float v13; // s8
  float v14; // s9
  float v15; // s3
  float v16; // s5
  float v17; // s0

  y = pVecStart->y;
  v4 = pPoint->y;
  v5 = pVecEnd->x - pVecStart->x;
  v6 = pVecEnd->y;
  v7 = v4 - y;
  v8 = v6 - y;
  z = pVecStart->z;
  v10 = pPoint->x - pVecStart->x;
  v11 = pPoint->z;
  v12 = pVecEnd->z;
  v13 = v11 - z;
  v14 = v12 - z;
  v15 = (float)((float)(v5 * v10) + (float)(v8 * v7)) + (float)((float)(v12 - z) * (float)(v11 - z));
  if ( v15 <= 0.0 )
  {
    v17 = (float)((float)(v10 * v10) + (float)(v7 * v7)) + (float)(v13 * v13);
  }
  else
  {
    v16 = (float)((float)(v5 * v5) + (float)(v8 * v8)) + (float)(v14 * v14);
    if ( v15 >= v16 )
    {
      v17 = (float)((float)((float)(pPoint->x - pVecEnd->x) * (float)(pPoint->x - pVecEnd->x))
                  + (float)((float)(v4 - v6) * (float)(v4 - v6)))
          + (float)((float)(v11 - v12) * (float)(v11 - v12));
    }
    else
    {
      v17 = (float)((float)((float)(v10 * v10) + (float)(v7 * v7)) + (float)(v13 * v13))
          - (float)((float)(v15 * v15) / v16);
      if ( v17 <= 0.0 )
        return 0.0;
    }
  }
  return sqrtf(v17);
}

//----- (002DAE04) --------------------------------------------------------
float __fastcall CCollision::DistToLineSqr(const CVector *pVecStart, const CVector *pVecEnd, const CVector *pPoint)
{
  float y; // s12
  float v4; // s4
  float v5; // s7
  float v6; // s1
  float v7; // s14
  float v8; // s5
  float z; // s3
  float v10; // s12
  float v11; // s2
  float v12; // s10
  float v13; // s8
  float v14; // s9
  float v15; // s3
  float v16; // s5
  float v17; // s0

  y = pVecStart->y;
  v4 = pPoint->y;
  v5 = pVecEnd->x - pVecStart->x;
  v6 = pVecEnd->y;
  v7 = v4 - y;
  v8 = v6 - y;
  z = pVecStart->z;
  v10 = pPoint->x - pVecStart->x;
  v11 = pPoint->z;
  v12 = pVecEnd->z;
  v13 = v11 - z;
  v14 = v12 - z;
  v15 = (float)((float)(v5 * v10) + (float)(v8 * v7)) + (float)((float)(v12 - z) * (float)(v11 - z));
  if ( v15 <= 0.0 )
    return (float)((float)(v10 * v10) + (float)(v7 * v7)) + (float)(v13 * v13);
  v16 = (float)((float)(v5 * v5) + (float)(v8 * v8)) + (float)(v14 * v14);
  if ( v15 >= v16 )
    return (float)((float)((float)(pPoint->x - pVecEnd->x) * (float)(pPoint->x - pVecEnd->x))
                 + (float)((float)(v4 - v6) * (float)(v4 - v6)))
         + (float)((float)(v11 - v12) * (float)(v11 - v12));
  v17 = (float)((float)((float)(v10 * v10) + (float)(v7 * v7)) + (float)(v13 * v13)) - (float)((float)(v15 * v15) / v16);
  if ( v17 <= 0.0 )
    return 0.0;
  return v17;
}

//----- (002DAEF8) --------------------------------------------------------
float __fastcall CCollision::DistToMathematicalLine(
        const CVector *pVecStart,
        const CVector *pVecEnd,
        const CVector *pPoint)
{
  float y; // s2
  float v4; // s6
  float v5; // s8
  float v6; // s0
  float z; // s4
  float v8; // s2
  float v9; // s10
  float v10; // s4
  float v11; // s14
  float v12; // s1
  float v13; // s0
  float v14; // s4
  float v15; // s0
  float v16; // s2

  y = pVecStart->y;
  v4 = pPoint->x - pVecStart->x;
  v5 = pPoint->y - y;
  v6 = pVecEnd->x - pVecStart->x;
  z = pVecStart->z;
  v8 = pVecEnd->y - y;
  v9 = pPoint->z - z;
  v10 = pVecEnd->z - z;
  v11 = v6 * v4;
  v12 = v10 * v9;
  v13 = (float)((float)(v6 * v6) + (float)(v8 * v8)) + (float)(v10 * v10);
  v14 = 0.0;
  v15 = (float)((float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v9 * v9))
      - (float)((float)((float)((float)(v11 + (float)(v8 * v5)) + v12) * (float)((float)(v11 + (float)(v8 * v5)) + v12))
              / v13);
  v16 = sqrtf(v15);
  if ( v15 > 0.0 )
    return v16;
  return v14;
}

//----- (002DAF9C) --------------------------------------------------------
float __fastcall CCollision::DistToMathematicalLine2D(
        float LineStartX,
        float LineStartY,
        float LineDirX,
        float LineDirY,
        float PointX,
        float PointY)
{
  float v6; // s4
  float v7; // s0
  float v8; // s2

  v6 = 0.0;
  v7 = (float)((float)((float)(PointX - LineStartX) * (float)(PointX - LineStartX))
             + (float)((float)(PointY - LineStartY) * (float)(PointY - LineStartY)))
     - (float)((float)((float)((float)(PointX - LineStartX) * LineDirX)
                     + (float)((float)(PointY - LineStartY) * LineDirY))
             * (float)((float)((float)(PointX - LineStartX) * LineDirX)
                     + (float)((float)(PointY - LineStartY) * LineDirY)));
  v8 = sqrtf(v7);
  if ( v7 > 0.0 )
    return v8;
  return v6;
}

//----- (002DAFFC) --------------------------------------------------------
float __fastcall CCollision::DistAlongLine2D(
        float LineStartX,
        float LineStartY,
        float LineDirX,
        float LineDirY,
        float PointX,
        float PointY)
{
  return (float)((float)(PointX - LineStartX) * LineDirX) + (float)((float)(PointY - LineStartY) * LineDirY);
}

//----- (002DB030) --------------------------------------------------------
bool __fastcall CCollision::ProcessLineSphere(
        const CColLine *line,
        const CColSphere *sphere,
        CColPoint *colPoint,
        float *fCollisionRatio)
{
  float x; // s0
  float v6; // s6
  float y; // s4
  float v10; // s10
  float v11; // s7
  float z; // s2
  float v13; // s12
  float v14; // s8
  float v15; // s14
  float v16; // s1
  float v17; // s5
  float v18; // s3
  float v19; // s7
  bool result; // r0
  float v21; // s16
  RwReal v22; // s18
  RwReal v23; // s20
  RwReal v24; // s22
  __int64 v25; // d16
  uint8 m_lighting; // r1
  __int16 v27; // r2
  CVector v28; // [sp+0h] [bp-40h] BYREF

  x = line->m_vecStart.x;
  v6 = sphere->m_vecCentre.x;
  y = line->m_vecStart.y;
  v10 = sphere->m_vecCentre.y;
  v11 = sphere->m_vecCentre.x - line->m_vecStart.x;
  z = line->m_vecStart.z;
  v13 = line->m_vecEnd.x - line->m_vecStart.x;
  v14 = sphere->m_vecCentre.z;
  v15 = line->m_vecEnd.y - y;
  v16 = line->m_vecEnd.z - z;
  v17 = (float)((float)(v13 * v11) + (float)(v15 * (float)(v10 - y))) + (float)(v16 * (float)(v14 - z));
  v18 = (float)((float)(v13 * v13) + (float)(v15 * v15)) + (float)(v16 * v16);
  v19 = (float)(v17 * v17)
      - (float)(v18
              * (float)((float)((float)((float)(v11 * v11) + (float)((float)(v10 - y) * (float)(v10 - y)))
                              + (float)((float)(v14 - z) * (float)(v14 - z)))
                      - (float)(sphere->m_fRadius * sphere->m_fRadius)));
  if ( v19 < 0.0 )
    return 0;
  result = 0;
  v21 = (float)(v17 - sqrtf(v19)) / v18;
  if ( v21 <= 1.0 && v21 >= 0.0 && v21 < *fCollisionRatio )
  {
    v22 = y + (float)(v15 * v21);
    v23 = x + (float)(v13 * v21);
    v24 = z + (float)(v16 * v21);
    v28.y = v22 - v10;
    v28.x = v23 - v6;
    v28.z = v24 - v14;
    CVector::Normalise(&v28);
    colPoint->m_vecPosition.x = v23;
    colPoint->m_vecPosition.y = v22;
    colPoint->m_vecPosition.z = v24;
    v25 = *(_QWORD *)&v28.x;
    colPoint->m_vecNormal.z = v28.z;
    *(_QWORD *)&colPoint->m_vecNormal.x = v25;
    m_lighting = sphere->m_data.m_lighting;
    v27 = *(_WORD *)&sphere->m_data.m_nSurfaceType;
    *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = 0;
    *(_WORD *)&colPoint->m_dataB.m_nSurfaceType = v27;
    colPoint->m_dataB.m_lighting = m_lighting;
    *fCollisionRatio = v21;
    CCollision::ms_iProcessLineNumCrossings += 2;
    return 1;
  }
  return result;
}

//----- (002DB198) --------------------------------------------------------
bool __fastcall CCollision::TestLineBox_DW(const CColLine *line, const CBox *box)
{
  float x; // s7
  float v3; // s8
  float z; // s11
  float v5; // s1
  float v6; // s10
  float y; // s5
  float v8; // s2
  float v9; // s4
  float v10; // s3
  float v11; // s6
  float v12; // s0
  float v13; // s14
  float v14; // s16
  float v15; // s12
  float v16; // s18
  float v17; // s9
  unsigned int v18; // r0
  unsigned int v19; // r1
  float v21; // s11
  int v22; // r0
  float v23; // s5
  float v24; // s7
  float v25; // s20
  float v26; // s16
  float v27; // s15
  float v28; // s18
  float v29; // s15
  float v30; // s14
  float v31; // s12
  float v32; // s6
  float v33; // s0
  float v34; // s18
  float v35; // s22
  float v36; // s18
  float v37; // s16
  float v38; // s18
  float v39; // s16
  float v40; // s13
  float v41; // s15
  float v42; // s14
  float v43; // s3
  float v44; // s1

  x = line->m_vecEnd.x;
  v3 = box->m_vecMax.x;
  z = line->m_vecEnd.z;
  v5 = box->m_vecMax.z;
  v6 = box->m_vecMin.x;
  y = line->m_vecEnd.y;
  v8 = box->m_vecMax.y;
  v9 = box->m_vecMin.y;
  v10 = box->m_vecMin.z;
  v11 = line->m_vecStart.x;
  v12 = line->m_vecStart.y;
  v13 = line->m_vecStart.z;
  v14 = v3 - line->m_vecStart.x;
  v15 = v5 - v13;
  v16 = line->m_vecStart.x - box->m_vecMin.x;
  v17 = v13 - v10;
  v18 = (COERCE_UNSIGNED_INT(v3 - x) >> 30) & 2 | (COERCE_UNSIGNED_INT(x - box->m_vecMin.x) >> 31) | (COERCE_UNSIGNED_INT(v8 - y) >> 28) & 8 | (COERCE_UNSIGNED_INT(y - v9) >> 29) & 4 | (COERCE_UNSIGNED_INT(v5 - z) >> 26) & 0x20 | (COERCE_UNSIGNED_INT(z - v10) >> 27) & 0x10;
  v19 = (COERCE_UNSIGNED_INT(v8 - v12) >> 28) & 8 | (COERCE_UNSIGNED_INT(v3 - v11) >> 30) & 2 | (COERCE_UNSIGNED_INT(v5 - v13) >> 26) & 0x20 | (COERCE_UNSIGNED_INT(v11 - box->m_vecMin.x) >> 31) | (COERCE_UNSIGNED_INT(v12 - v9) >> 29) & 4 | (COERCE_UNSIGNED_INT(v13 - v10) >> 27) & 0x10;
  if ( (v18 & v19) != 0 )
    return 0;
  if ( !(v18 * v19) )
    return 1;
  v21 = z - v13;
  v22 = v18 | v19;
  v23 = y - v12;
  v24 = x - v11;
  if ( (v22 & 3) != 0 )
  {
    v25 = 1.0 / v24;
    if ( v22 << 31 )
    {
      v34 = v16 * v25;
      v35 = v12 - (float)(v23 * v34);
      if ( v35 > v9 && v35 < v8 )
      {
        v36 = v13 - (float)(v21 * v34);
        if ( v36 > v10 && v36 < v5 )
          return 1;
      }
    }
    if ( (v22 & 2) != 0 )
    {
      v37 = v14 * v25;
      v38 = (float)(v23 * v37) + v12;
      if ( v38 > v9 && v38 < v8 )
      {
        v39 = (float)(v21 * v37) + v13;
        if ( v39 > v10 && v39 < v5 )
          return 1;
      }
    }
  }
  if ( (v22 & 0xC) != 0 )
  {
    v26 = 1.0 / v23;
    if ( (v22 & 4) != 0 )
    {
      v27 = (float)(v12 - v9) * v26;
      v28 = v11 - (float)(v24 * v27);
      if ( v28 > v6 && v28 < v3 )
      {
        v29 = v13 - (float)(v21 * v27);
        if ( v29 > v10 && v29 < v5 )
          return 1;
      }
    }
    if ( (v22 & 8) != 0 )
    {
      v40 = (float)(v8 - v12) * v26;
      v41 = (float)(v24 * v40) + v11;
      if ( v41 > v6 && v41 < v3 )
      {
        v42 = (float)(v21 * v40) + v13;
        if ( v42 > v10 && v42 < v5 )
          return 1;
      }
    }
  }
  if ( (v22 & 0x30) != 0
    && ((v30 = 1.0 / v21, (v22 & 0x10) != 0)
     && (v43 = v11 - (float)(v24 * (float)(v17 * v30)), v43 > v6)
     && v43 < v3
     && (v44 = v12 - (float)(v23 * (float)(v17 * v30)), v44 > v9)
     && v44 < v8
     || (v22 & 0x20) != 0
     && (v31 = v15 * v30, v32 = (float)(v24 * v31) + v11, v32 > v6)
     && v32 < v3
     && (v33 = (float)(v23 * v31) + v12, v33 > v9)
     && v33 < v8) )
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (002DB47C) --------------------------------------------------------
bool __fastcall CCollision::TestVerticalLineBox(const CColLine *Line, const CBox *box)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float y; // s2

  if ( Line->m_vecStart.x <= box->m_vecMin.x )
    return 0;
  y = Line->m_vecStart.y;
  if ( y <= box->m_vecMin.y )
    return 0;
  if ( Line->m_vecStart.x >= box->m_vecMax.x )
    return 0;
  if ( y >= box->m_vecMax.y )
    return 0;
  v2.n64_u32[0] = LODWORD(Line->m_vecStart.z);
  v3.n64_u32[0] = LODWORD(Line->m_vecEnd.z);
  if ( vmin_f32(v2, v3).n64_f32[0] > box->m_vecMax.z )
    return 0;
  if ( v2.n64_f32[0] < v3.n64_f32[0] )
    v2.n64_u32[0] = LODWORD(Line->m_vecEnd.z);
  return v2.n64_f32[0] >= box->m_vecMin.z;
}
// 2DB4C8: variable 'v2' is possibly undefined
// 2DB4C8: variable 'v3' is possibly undefined

//----- (002DB4FC) --------------------------------------------------------
bool __fastcall CCollision::ProcessLineBox(
        const CColLine *line,
        const CColBox *box,
        CColPoint *colPoint,
        float *fCollisionRatio)
{
  float x; // s6
  float v8; // s8
  float y; // s4
  float v11; // s12
  float z; // s0
  float v13; // s14
  float v14; // s10
  float v15; // s12
  float v16; // s6
  float v17; // s4
  __int16 v18; // r2
  float v19; // s12
  float v20; // s2
  float v21; // s0
  float v22; // s4
  float v23; // s10
  float v24; // s14
  float v25; // s14
  float v26; // s5
  float v27; // s7
  RwReal *v28; // r12
  float v29; // s3
  RwReal *v30; // r0
  RwReal *p_y; // lr
  float v32; // s1
  float v33; // s9
  RwReal v34; // s10
  float v35; // s11
  int v36; // r5
  int v37; // r3
  int v38; // r3
  float v39; // s1
  float v40; // s9
  float v41; // s7
  RwReal v42; // s5
  float v43; // s9
  float v44; // s7
  float v45; // s11
  int v46; // r5
  int v47; // r3
  int v48; // r3
  float v49; // s7
  float v50; // s11
  float v51; // s9
  float v52; // s15
  float v53; // s13
  RwReal *p_z; // r3
  float v55; // s18
  float v56; // s13
  float v57; // s15
  float v58; // s16
  float v59; // s20
  int v60; // r5
  int v61; // r0
  int v62; // r0
  float v63; // s16
  float v64; // s20
  RwReal v65; // s15
  float v66; // s20
  float v67; // s18
  float v68; // s22
  int v69; // r5
  int v70; // r0
  int v71; // r0
  float v72; // s16
  float v73; // s13
  float v74; // s18
  float v75; // s13
  float v76; // s8
  float v77; // s6
  int v78; // r5
  int v79; // r0
  int v80; // r0
  bool result; // r0
  __int16 v82; // r5
  uint8 m_lighting; // r2
  float v84; // s0
  int v85; // r0

  x = box->m_vecMin.x;
  v8 = line->m_vecStart.x;
  if ( line->m_vecStart.x > box->m_vecMin.x )
  {
    y = box->m_vecMin.y;
    v11 = line->m_vecStart.y;
    if ( v11 > y )
    {
      z = box->m_vecMin.z;
      v13 = line->m_vecStart.z;
      if ( v13 > z && v8 < box->m_vecMax.x )
      {
        v14 = box->m_vecMax.y;
        if ( v11 < v14 )
        {
          v15 = box->m_vecMax.z;
          if ( v13 < v15 )
          {
            if ( line->m_vecEnd.x < x
              || (v16 = line->m_vecEnd.y, v16 < y)
              || (v17 = line->m_vecEnd.z, v17 > v15)
              || v16 > v14
              || v17 < z )
            {
              ++CCollision::ms_iProcessLineNumCrossings;
            }
            CalculateColPointInsideBox(box, &line->m_vecStart, colPoint);
            *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = 0;
            v18 = *(_WORD *)&box->m_data.m_nSurfaceType;
            colPoint->m_dataB.m_lighting = box->m_data.m_lighting;
            *(_WORD *)&colPoint->m_dataB.m_nSurfaceType = v18;
            *fCollisionRatio = 0.0;
            return 1;
          }
        }
      }
    }
  }
  v19 = line->m_vecEnd.x;
  v20 = x - v8;
  v21 = 1.0;
  v22 = x - v19;
  if ( (float)((float)(x - v8) * (float)(x - v19)) < 0.0 )
  {
    v23 = v20 / (float)(v20 - v22);
    v20 = line->m_vecStart.y + (float)(v23 * (float)(line->m_vecEnd.y - line->m_vecStart.y));
    v22 = box->m_vecMin.y;
    if ( v20 > v22 )
    {
      v22 = box->m_vecMax.y;
      if ( v20 < v22 )
      {
        v22 = line->m_vecStart.z + (float)(v23 * (float)(line->m_vecEnd.z - line->m_vecStart.z));
        if ( v22 > box->m_vecMin.z )
        {
          v21 = 1.0;
          v24 = 1.0;
          if ( v22 < box->m_vecMax.z )
            v24 = v23;
          if ( v23 < 1.0 )
            v21 = v24;
        }
      }
    }
  }
  v25 = box->m_vecMax.x;
  if ( (float)((float)(v8 - v25) * (float)(v19 - v25)) >= 0.0 )
  {
    v34 = -1.0;
    v26 = line->m_vecStart.y;
    v27 = line->m_vecEnd.y;
    p_y = &line->m_vecEnd.y;
    v30 = &line->m_vecStart.y;
    v29 = box->m_vecMin.y;
    v28 = &box->m_vecMin.y;
LABEL_36:
    v39 = box->m_vecMin.x;
    goto LABEL_37;
  }
  v26 = line->m_vecStart.y;
  v27 = line->m_vecEnd.y;
  v28 = &box->m_vecMin.y;
  v29 = box->m_vecMin.y;
  v30 = &line->m_vecStart.y;
  p_y = &line->m_vecEnd.y;
  v32 = (float)(v8 - v25) / (float)((float)(v8 - v25) - (float)(v19 - v25));
  v33 = v26 + (float)(v32 * (float)(v27 - v26));
  v34 = -1.0;
  if ( v33 <= v29 )
    goto LABEL_36;
  if ( v33 >= box->m_vecMax.y )
    goto LABEL_36;
  v35 = line->m_vecStart.z + (float)(v32 * (float)(line->m_vecEnd.z - line->m_vecStart.z));
  if ( v35 <= box->m_vecMin.z )
    goto LABEL_36;
  v36 = 0;
  v37 = 0;
  v34 = -1.0;
  if ( v32 < v21 )
    v36 = 1;
  if ( v35 < box->m_vecMax.z )
    v37 = 1;
  v38 = v37 & v36;
  if ( v38 )
  {
    v21 = (float)(v8 - v25) / (float)((float)(v8 - v25) - (float)(v19 - v25));
    v22 = line->m_vecStart.z + (float)(v32 * (float)(line->m_vecEnd.z - line->m_vecStart.z));
    v20 = v26 + (float)(v32 * (float)(v27 - v26));
  }
  v39 = box->m_vecMin.x;
  if ( v38 )
  {
    v39 = box->m_vecMax.x;
    v34 = 1.0;
  }
LABEL_37:
  v40 = v29 - v27;
  v41 = v29 - v26;
  v42 = 0.0;
  if ( (float)(v41 * v40) < 0.0 )
  {
    v43 = v41 / (float)(v41 - v40);
    v44 = v8 + (float)(v43 * (float)(v19 - v8));
    if ( v44 > x && v44 < v25 )
    {
      v45 = line->m_vecStart.z + (float)(v43 * (float)(line->m_vecEnd.z - line->m_vecStart.z));
      if ( v45 > box->m_vecMin.z )
      {
        v46 = 0;
        v47 = 0;
        if ( v43 < v21 )
          v46 = 1;
        if ( v45 < box->m_vecMax.z )
          v47 = 1;
        v48 = v47 & v46;
        if ( v48 )
        {
          v21 = v43;
          v22 = line->m_vecStart.z + (float)(v43 * (float)(line->m_vecEnd.z - line->m_vecStart.z));
        }
        if ( v48 )
        {
          v20 = v29;
          v39 = v8 + (float)(v43 * (float)(v19 - v8));
        }
        v42 = 0.0;
        if ( v48 )
        {
          v42 = -1.0;
          v34 = 0.0;
        }
      }
    }
  }
  v49 = box->m_vecMax.y;
  v50 = *p_y;
  v51 = *v30;
  v52 = *p_y - v49;
  v53 = *v30 - v49;
  if ( (float)(v53 * v52) >= 0.0 )
  {
    v56 = line->m_vecStart.z;
    p_z = &line->m_vecEnd.z;
    v57 = line->m_vecEnd.z;
  }
  else
  {
    p_z = &line->m_vecEnd.z;
    v55 = v53 / (float)(v53 - v52);
    v56 = line->m_vecStart.z;
    v57 = line->m_vecEnd.z;
    v58 = v8 + (float)(v55 * (float)(v19 - v8));
    if ( v58 > x && v58 < v25 )
    {
      v59 = v56 + (float)(v55 * (float)(v57 - v56));
      if ( v59 > box->m_vecMin.z )
      {
        v60 = 0;
        v61 = 0;
        if ( v55 < v21 )
          v60 = 1;
        if ( v59 < box->m_vecMax.z )
          v61 = 1;
        v62 = v61 & v60;
        if ( v62 )
        {
          v21 = v55;
          v22 = v56 + (float)(v55 * (float)(v57 - v56));
          v20 = box->m_vecMax.y;
          v39 = v8 + (float)(v55 * (float)(v19 - v8));
        }
        if ( v62 )
        {
          v42 = 1.0;
          v34 = 0.0;
        }
      }
    }
  }
  v63 = box->m_vecMin.z;
  v64 = v63 - v57;
  v65 = 0.0;
  if ( (float)((float)(v63 - v56) * v64) < 0.0 )
  {
    v66 = (float)(v63 - v56) / (float)((float)(v63 - v56) - v64);
    v67 = v8 + (float)(v66 * (float)(v19 - v8));
    if ( v67 > x && v67 < v25 )
    {
      v68 = v51 + (float)(v66 * (float)(v50 - v51));
      if ( v68 > v29 )
      {
        v69 = 0;
        v70 = 0;
        if ( v68 < v49 )
          v69 = 1;
        if ( v66 < v21 )
          v70 = 1;
        v71 = v70 & v69;
        if ( v71 )
        {
          v21 = v66;
          v22 = box->m_vecMin.z;
        }
        if ( v71 )
        {
          v20 = v51 + (float)(v66 * (float)(v50 - v51));
          v39 = v8 + (float)(v66 * (float)(v19 - v8));
        }
        v65 = 0.0;
        if ( v71 )
        {
          v65 = -1.0;
          v42 = 0.0;
          v34 = 0.0;
        }
      }
    }
  }
  v72 = box->m_vecMax.z;
  v73 = v56 - v72;
  v74 = *p_z - v72;
  if ( (float)(v73 * v74) < 0.0 )
  {
    v75 = v73 / (float)(v73 - v74);
    v76 = v8 + (float)(v75 * (float)(v19 - v8));
    if ( v76 > x && v76 < v25 )
    {
      v77 = v51 + (float)(v75 * (float)(v50 - v51));
      if ( v77 > v29 )
      {
        v78 = 0;
        v79 = 0;
        if ( v77 < v49 )
          v78 = 1;
        if ( v75 < v21 )
          v79 = 1;
        v80 = v79 & v78;
        if ( v80 )
        {
          v21 = v75;
          v22 = box->m_vecMax.z;
          v20 = v51 + (float)(v75 * (float)(v50 - v51));
          v39 = v76;
        }
        if ( v80 )
        {
          v65 = 1.0;
          v42 = 0.0;
          v34 = 0.0;
        }
      }
    }
  }
  result = 0;
  if ( v21 < *fCollisionRatio )
  {
    colPoint->m_vecPosition.x = v39;
    colPoint->m_vecPosition.y = v20;
    colPoint->m_vecPosition.z = v22;
    colPoint->m_vecNormal.x = v34;
    colPoint->m_vecNormal.y = v42;
    colPoint->m_vecNormal.z = v65;
    v82 = *(_WORD *)&box->m_data.m_nSurfaceType;
    m_lighting = box->m_data.m_lighting;
    *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = 0;
    colPoint->m_dataB.m_lighting = m_lighting;
    *(_WORD *)&colPoint->m_dataB.m_nSurfaceType = v82;
    *fCollisionRatio = v21;
    v84 = line->m_vecEnd.x;
    if ( v84 >= box->m_vecMin.x
      && *p_y >= *v28
      && *p_z >= box->m_vecMin.z
      && v84 <= box->m_vecMax.x
      && *p_y <= box->m_vecMax.y
      && *p_z <= box->m_vecMax.z )
    {
      v85 = 1;
    }
    else
    {
      v85 = 2;
    }
    CCollision::ms_iProcessLineNumCrossings += v85;
    return 1;
  }
  return result;
}

//----- (002DBB04) --------------------------------------------------------
int __fastcall CCollision::Test2DLineAgainst2DLine(
        float Start1X,
        float Start1Y,
        float Delta1X,
        float Delta1Y,
        float Start2X,
        float Start2Y,
        float Delta2X,
        float Delta2Y)
{
  float v9; // s3
  int result; // r0

  v9 = Start2X - Start1X;
  result = 0;
  if ( (float)((float)((float)(v9 * Delta1Y) - (float)((float)(Start2Y - Start1Y) * Delta1X))
             * (float)((float)((float)(v9 + Delta2X) * Delta1Y)
                     - (float)((float)((float)(Start2Y - Start1Y) + Delta2Y) * Delta1X))) <= 0.0
    && (float)((float)((float)((float)(Start1X - Start2X) * Delta2Y) - (float)((float)(Start1Y - Start2Y) * Delta2X))
             * (float)((float)((float)((float)(Start1X - Start2X) + Delta1X) * Delta2Y)
                     - (float)((float)((float)(Start1Y - Start2Y) + Delta1Y) * Delta2X))) <= 0.0 )
  {
    return 1;
  }
  return result;
}

//----- (002DBB98) --------------------------------------------------------
int __fastcall ProcessDiscCollision(
        CColPoint *tempTriCol,
        const CMatrix *matBA,
        const CColDisk *disk,
        CColPoint *colPoint,
        bool *lineCollision,
        float *lineRatio,
        CColPoint *lineColPoint)
{
  float x; // s18
  float y; // s20
  float z; // s16
  float v14; // s0
  float v15; // s4
  float v16; // s2
  float v17; // s6
  float v18; // s8
  float v19; // s0
  CVector v21; // [sp+4h] [bp-34h] BYREF

  operator*(&v21, matBA, &tempTriCol->m_vecPosition);
  x = v21.x;
  y = v21.y;
  z = v21.z;
  Multiply3x3(&v21, matBA, &tempTriCol->m_vecNormal);
  v14 = disk->m_vecThickness.x;
  v15 = disk->m_vecThickness.y;
  v16 = disk->m_vecThickness.z;
  if ( fabsf((float)((float)(v21.x * v14) + (float)(v21.y * v15)) + (float)(v21.z * v16)) >= 0.77
    || (v17 = x - disk->m_vecCentre.x,
        v18 = y - disk->m_vecCentre.y,
        fabsf((float)((float)(v14 * v17) + (float)(v15 * v18)) + (float)(v16 * (float)(z - disk->m_vecCentre.z))) >= disk->m_fThickness) )
  {
    if ( disk->m_data.m_nPieceType <= 0x10u && tempTriCol->m_fDepth > colPoint->m_fDepth )
    {
      CColPoint::operator=(colPoint, tempTriCol);
      colPoint->m_fDepth = tempTriCol->m_fDepth;
      colPoint->m_dataB.m_nSurfaceType = 60;
      return 1;
    }
  }
  else
  {
    v19 = z + sqrtf((float)((float)(disk->m_fRadius * disk->m_fRadius) - (float)(v18 * v18)) - (float)(v17 * v17));
    if ( v19 >= *lineRatio )
    {
      *lineCollision = 1;
      *lineRatio = v19;
      CColPoint::operator=(lineColPoint, tempTriCol);
      lineColPoint->m_fDepth = tempTriCol->m_fDepth;
    }
  }
  return 0;
}

//----- (002DBCD8) --------------------------------------------------------
bool __fastcall CCollision::TestLineTriangle(
        const CColLine *line,
        const CollisionVector *aVectors,
        const CColTriangle *triangle,
        const CColTrianglePlane *plane)
{
  float x; // s14
  float v5; // s2
  float y; // s10
  float v7; // s3
  float v8; // s9
  float v9; // s4
  float z; // s8
  float v11; // s1
  float v12; // s0
  float m_compressedNormalOffset; // s12
  float v14; // s3
  float v15; // s14
  float v16; // s1
  float v17; // s12
  float v18; // s6
  float v19; // s8
  float v20; // s10
  float v21; // s6
  float v22; // s0
  float v23; // s1
  float v24; // s3
  const CollisionVector *v25; // r3
  int32 m_nIndex1; // r0
  const CollisionVector *v27; // r2
  const CollisionVector *v28; // r3
  const CollisionVector *v29; // r2
  const CollisionVector *v30; // r0
  const CollisionVector *v31; // r3
  int32 v32; // r0
  const CollisionVector *v33; // r2
  const CollisionVector *v34; // r3
  const CollisionVector *v35; // r2
  const CollisionVector *v36; // r0
  const CollisionVector *v37; // r3
  int32 v38; // r0
  const CollisionVector *v39; // r2
  const CollisionVector *v40; // r3
  const CollisionVector *v41; // r2
  const CollisionVector *v42; // r0
  bool result; // r0

  x = line->m_vecEnd.x;
  v5 = line->m_vecStart.x;
  y = plane->m_compressedNormal.y;
  v7 = line->m_vecEnd.y;
  v8 = plane->m_compressedNormal.x * line->m_vecStart.x;
  v9 = line->m_vecStart.y;
  z = plane->m_compressedNormal.z;
  v11 = line->m_vecEnd.z;
  v12 = line->m_vecStart.z;
  m_compressedNormalOffset = plane->m_compressedNormalOffset;
  if ( (float)((float)((float)((float)(v8 + (float)(y * v9)) + (float)(z * v12)) - m_compressedNormalOffset)
             * (float)((float)((float)((float)(plane->m_compressedNormal.x * x) + (float)(y * v7)) + (float)(z * v11))
                     - m_compressedNormalOffset)) > 0.0 )
    return 0;
  v14 = v7 - v9;
  v15 = x - v5;
  v16 = v11 - v12;
  v17 = (float)(m_compressedNormalOffset - v8) - (float)(y * v9);
  v18 = (float)(v17 - (float)(z * v12))
      / (float)((float)((float)(plane->m_compressedNormal.x * v15) + (float)(y * v14)) + (float)(z * v16));
  v19 = v16 * v18;
  v20 = v14 * v18;
  v21 = v15 * v18;
  v22 = v12 + v19;
  v23 = v9 + v20;
  v24 = v5 + v21;
  switch ( plane->m_nPrincipalAxis )
  {
    case 0u:
      v25 = &aVectors[triangle->m_nIndex2];
      m_nIndex1 = triangle->m_nIndex1;
      v21 = v25->y;
      v27 = &aVectors[triangle->m_nIndex3];
      v19 = v25->z;
      v5 = v27->y;
      v9 = v27->z;
      goto LABEL_5;
    case 1u:
      v28 = &aVectors[triangle->m_nIndex2];
      m_nIndex1 = triangle->m_nIndex1;
      v5 = v28->y;
      v29 = &aVectors[triangle->m_nIndex3];
      v9 = v28->z;
      v21 = v29->y;
      v19 = v29->z;
LABEL_5:
      v30 = &aVectors[m_nIndex1];
      v20 = v23;
      v17 = v30->y;
      v15 = v30->z;
      break;
    case 2u:
      v31 = &aVectors[triangle->m_nIndex2];
      v32 = triangle->m_nIndex1;
      v19 = v31->x;
      v33 = &aVectors[triangle->m_nIndex3];
      v21 = v31->z;
      v9 = v33->x;
      v5 = v33->z;
      goto LABEL_8;
    case 3u:
      v34 = &aVectors[triangle->m_nIndex2];
      v32 = triangle->m_nIndex1;
      v9 = v34->x;
      v35 = &aVectors[triangle->m_nIndex3];
      v5 = v34->z;
      v19 = v35->x;
      v21 = v35->z;
LABEL_8:
      v36 = &aVectors[v32];
      v20 = v22;
      v22 = v24;
      v15 = v36->x;
      v17 = v36->z;
      break;
    case 4u:
      v37 = &aVectors[triangle->m_nIndex2];
      v38 = triangle->m_nIndex1;
      v21 = v37->x;
      v39 = &aVectors[triangle->m_nIndex3];
      v19 = v37->y;
      v5 = v39->x;
      v9 = v39->y;
      goto LABEL_11;
    case 5u:
      v40 = &aVectors[triangle->m_nIndex2];
      v38 = triangle->m_nIndex1;
      v5 = v40->x;
      v41 = &aVectors[triangle->m_nIndex3];
      v9 = v40->y;
      v21 = v41->x;
      v19 = v41->y;
LABEL_11:
      v20 = v24;
      v42 = &aVectors[v38];
      v22 = v23;
      v17 = v42->x;
      v15 = v42->y;
      break;
    default:
      break;
  }
  if ( (float)((float)((float)(v22 - v15) * (float)(v5 - v17)) - (float)((float)(v20 - v17) * (float)(v9 - v15))) < 0.0 )
    return 0;
  result = 0;
  if ( (float)((float)((float)(v22 - v15) * (float)(v21 - v17)) - (float)((float)(v20 - v17) * (float)(v19 - v15))) <= 0.0
    && (float)((float)((float)(v22 - v9) * (float)(v21 - v5)) - (float)((float)(v20 - v5) * (float)(v19 - v9))) >= 0.0 )
  {
    return 1;
  }
  return result;
}

//----- (002DBF50) --------------------------------------------------------
int __fastcall CCollision::ProcessLineTriangle(
        const CColLine *line,
        const CollisionVector *aVectors,
        const CColTriangle *triangle,
        const CColTrianglePlane *plane,
        CColPoint *colPoint,
        float *fCollisionRatio,
        CStoredCollPoly *pStoredPoly)
{
  float x; // s2
  float v8; // s14
  float v9; // s12
  float y; // s4
  float v11; // s3
  float v12; // s9
  float v13; // s10
  float z; // s6
  float v15; // s1
  float v16; // s8
  float m_compressedNormalOffset; // s0
  float v18; // s7
  float v19; // s13
  float v20; // s14
  float v21; // s3
  float v22; // s1
  float v23; // s11
  float v24; // s0
  float v25; // s9
  float v26; // s5
  float v27; // s0
  float v28; // s1
  float v29; // s3
  float v30; // s14
  float v31; // s8
  float v32; // s10
  float v33; // s12
  const CollisionVector *v34; // r3
  int32 m_nIndex1; // r12
  const CollisionVector *v36; // r0
  const CollisionVector *v37; // r3
  const CollisionVector *v38; // r0
  const CollisionVector *v39; // r0
  const CollisionVector *v40; // r3
  int32 v41; // r12
  const CollisionVector *v42; // r0
  const CollisionVector *v43; // r3
  const CollisionVector *v44; // r0
  const CollisionVector *v45; // r0
  const CollisionVector *v46; // r3
  int32 v47; // r12
  const CollisionVector *v48; // r0
  const CollisionVector *v49; // r3
  const CollisionVector *v50; // r0
  const CollisionVector *v51; // r0
  int result; // r0
  uint8 m_nSurfaceType; // r0
  uint8 m_nLighting; // r0
  const CollisionVector *v55; // r0
  __int64 v56; // d16
  const CollisionVector *v57; // r0
  __int64 v58; // d16
  const CollisionVector *v59; // r0
  __int64 v60; // d16

  x = plane->m_compressedNormal.x;
  v8 = line->m_vecEnd.x;
  v9 = line->m_vecStart.x;
  y = plane->m_compressedNormal.y;
  v11 = line->m_vecEnd.y;
  v12 = plane->m_compressedNormal.x * line->m_vecStart.x;
  v13 = line->m_vecStart.y;
  z = plane->m_compressedNormal.z;
  v15 = line->m_vecEnd.z;
  v16 = line->m_vecStart.z;
  m_compressedNormalOffset = plane->m_compressedNormalOffset;
  v18 = z * v16;
  v19 = (float)((float)(v12 + (float)(y * v13)) + (float)(z * v16)) - m_compressedNormalOffset;
  if ( (float)(v19
             * (float)((float)((float)((float)(plane->m_compressedNormal.x * v8) + (float)(y * v11)) + (float)(z * v15))
                     - m_compressedNormalOffset)) > 0.0 )
    return 0;
  v20 = v8 - v9;
  v21 = v11 - v13;
  v22 = v15 - v16;
  v23 = x * v20;
  v24 = (float)(m_compressedNormalOffset - v12) - (float)(y * v13);
  v25 = (float)(x * v20) + (float)(y * v21);
  v26 = v25 + (float)(z * v22);
  v27 = (float)(v24 - v18) / v26;
  v28 = v22 * v27;
  v29 = v21 * v27;
  v30 = v20 * v27;
  v31 = v16 + v28;
  v32 = v13 + v29;
  v33 = v9 + v30;
  switch ( plane->m_nPrincipalAxis )
  {
    case 0u:
      v34 = &aVectors[triangle->m_nIndex2];
      m_nIndex1 = triangle->m_nIndex1;
      v29 = v34->y;
      v36 = &aVectors[triangle->m_nIndex3];
      v26 = v34->z;
      v30 = v36->y;
      v28 = v36->z;
      goto LABEL_5;
    case 1u:
      v37 = &aVectors[triangle->m_nIndex2];
      m_nIndex1 = triangle->m_nIndex1;
      v30 = v37->y;
      v38 = &aVectors[triangle->m_nIndex3];
      v28 = v37->z;
      v29 = v38->y;
      v26 = v38->z;
LABEL_5:
      v39 = &aVectors[m_nIndex1];
      v18 = v32;
      v23 = v31;
      v25 = v39->y;
      v19 = v39->z;
      break;
    case 2u:
      v40 = &aVectors[triangle->m_nIndex2];
      v41 = triangle->m_nIndex1;
      v26 = v40->x;
      v42 = &aVectors[triangle->m_nIndex3];
      v29 = v40->z;
      v28 = v42->x;
      v30 = v42->z;
      goto LABEL_8;
    case 3u:
      v43 = &aVectors[triangle->m_nIndex2];
      v41 = triangle->m_nIndex1;
      v28 = v43->x;
      v44 = &aVectors[triangle->m_nIndex3];
      v30 = v43->z;
      v26 = v44->x;
      v29 = v44->z;
LABEL_8:
      v45 = &aVectors[v41];
      v18 = v31;
      v23 = v33;
      v19 = v45->x;
      v25 = v45->z;
      break;
    case 4u:
      v46 = &aVectors[triangle->m_nIndex2];
      v47 = triangle->m_nIndex1;
      v29 = v46->x;
      v48 = &aVectors[triangle->m_nIndex3];
      v26 = v46->y;
      v30 = v48->x;
      v28 = v48->y;
      goto LABEL_11;
    case 5u:
      v49 = &aVectors[triangle->m_nIndex2];
      v47 = triangle->m_nIndex1;
      v30 = v49->x;
      v50 = &aVectors[triangle->m_nIndex3];
      v28 = v49->y;
      v29 = v50->x;
      v26 = v50->y;
LABEL_11:
      v18 = v33;
      v51 = &aVectors[v47];
      v23 = v32;
      v25 = v51->x;
      v19 = v51->y;
      break;
    default:
      break;
  }
  if ( (float)((float)((float)(v23 - v19) * (float)(v30 - v25)) - (float)((float)(v18 - v25) * (float)(v28 - v19))) < 0.0
    || (float)((float)((float)(v23 - v19) * (float)(v29 - v25)) - (float)((float)(v18 - v25) * (float)(v26 - v19))) > 0.0 )
  {
    return 0;
  }
  result = 0;
  if ( (float)((float)((float)(v23 - v28) * (float)(v29 - v30)) - (float)((float)(v18 - v30) * (float)(v26 - v28))) >= 0.0
    && v27 < *fCollisionRatio )
  {
    colPoint->m_vecPosition.x = v33;
    colPoint->m_vecPosition.y = v32;
    colPoint->m_vecPosition.z = v31;
    colPoint->m_vecNormal.x = x;
    colPoint->m_vecNormal.y = y;
    colPoint->m_vecNormal.z = z;
    m_nSurfaceType = triangle->m_nSurfaceType;
    colPoint->m_dataB.m_nPieceType = 0;
    colPoint->m_dataB.m_nSurfaceType = m_nSurfaceType;
    m_nLighting = triangle->m_nLighting;
    *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = 0;
    colPoint->m_dataB.m_lighting = m_nLighting;
    if ( pStoredPoly )
    {
      v55 = &aVectors[triangle->m_nIndex1];
      v56 = *(_QWORD *)&v55->x;
      pStoredPoly->V1.z = v55->z;
      *(_QWORD *)&pStoredPoly->V1.x = v56;
      v57 = &aVectors[triangle->m_nIndex2];
      v58 = *(_QWORD *)&v57->x;
      pStoredPoly->V2.z = v57->z;
      *(_QWORD *)&pStoredPoly->V2.x = v58;
      v59 = &aVectors[triangle->m_nIndex3];
      v60 = *(_QWORD *)&v59->x;
      pStoredPoly->V3.z = v59->z;
      pStoredPoly->bValidPolyStored = 1;
      *(_QWORD *)&pStoredPoly->V3.x = v60;
      pStoredPoly->lighting = triangle->m_nLighting;
    }
    result = 1;
    *fCollisionRatio = v27;
  }
  return result;
}

//----- (002DC27C) --------------------------------------------------------
int __fastcall CCollision::TestLineOfSight(
        const CColLine *line,
        const CMatrix *mat,
        CColModel *colModel,
        int bSeeThroughStuff,
        int a5)
{
  CCollisionData *m_pColData; // r5
  char v10; // r0
  const CColLine *v11; // r0
  int v12; // r6
  int v13; // r9
  int v14; // r6
  int v15; // r9
  int v16; // r6
  int v17; // r9
  int v18; // r8
  CVector v20; // [sp+4h] [bp-54h] BYREF
  CVector v21; // [sp+10h] [bp-48h] BYREF
  CColLine v22; // [sp+1Ch] [bp-3Ch] BYREF

  m_pColData = colModel->m_pColData;
  if ( !m_pColData )
    return 0;
  v10 = `guard variable for'CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform;
  __dmb(0xBu);
  if ( (v10 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform) )
  {
    CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform.m_pRwMat = 0;
    CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform.m_owner = 0;
    _cxa_atexit(
      (void (__fastcall *)(void *))CMatrix::~CMatrix,
      &CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform,
      &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform);
  }
  Invert(mat, &CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform);
  operator*(
    &v21,
    &CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform,
    &line->m_vecStart);
  operator*(
    &v20,
    &CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform,
    &line->m_vecEnd);
  CColLine::CColLine(&v22, &v21, &v20);
  if ( !CCollision::TestLineBox_DW(v11, &colModel->m_boxBound) )
    return 0;
  if ( m_pColData->m_nNoOfSpheres >= 1 )
  {
    v12 = 0;
    v13 = 16;
    while ( bSeeThroughStuff == 1
         && SurfaceInfos_c::IsSeeThrough(
              &g_surfaceInfos,
              *((unsigned __int8 *)&m_pColData->m_pSphereArray->m_vecCentre.x + v13))
         || a5 == 1
         && SurfaceInfos_c::IsShootThrough(
              &g_surfaceInfos,
              *((unsigned __int8 *)&m_pColData->m_pSphereArray->m_vecCentre.x + v13))
         || !CCollision::TestLineSphere(&v22, (const CColSphere *)((char *)m_pColData->m_pSphereArray + v13 - 16)) )
    {
      ++v12;
      v13 += 20;
      if ( v12 >= m_pColData->m_nNoOfSpheres )
        goto LABEL_14;
    }
    return 1;
  }
LABEL_14:
  if ( m_pColData->m_nNoOfBoxes >= 1 )
  {
    v14 = 0;
    v15 = 24;
    while ( bSeeThroughStuff == 1
         && SurfaceInfos_c::IsSeeThrough(
              &g_surfaceInfos,
              *((unsigned __int8 *)&m_pColData->m_pBoxArray->m_vecMin.x + v15))
         || a5 == 1
         && SurfaceInfos_c::IsShootThrough(
              &g_surfaceInfos,
              *((unsigned __int8 *)&m_pColData->m_pBoxArray->m_vecMin.x + v15))
         || !CCollision::TestLineBox_DW(&v22, (const CBox *)((char *)m_pColData->m_pBoxArray + v15 - 24)) )
    {
      ++v14;
      v15 += 28;
      if ( v14 >= m_pColData->m_nNoOfBoxes )
        goto LABEL_22;
    }
    return 1;
  }
LABEL_22:
  CCollision::CalculateTrianglePlanes(m_pColData);
  if ( m_pColData->m_nNoOfTriangles < 1 )
    return 0;
  v16 = 12;
  v17 = 0;
  v18 = 0;
  while ( bSeeThroughStuff == 1
       && SurfaceInfos_c::IsSeeThrough(
            &g_surfaceInfos,
            *((unsigned __int8 *)&m_pColData->m_pTriangleArray->m_nIndex1 + v16))
       || a5 == 1
       && SurfaceInfos_c::IsShootThrough(
            &g_surfaceInfos,
            *((unsigned __int8 *)&m_pColData->m_pTriangleArray->m_nIndex1 + v16))
       || !CCollision::TestLineTriangle(
             &v22,
             m_pColData->m_pTriCompressedVectorArray,
             (const CColTriangle *)((char *)m_pColData->m_pTriangleArray + v16 - 12),
             &m_pColData->m_pTrianglePlaneArray[v17]) )
  {
    ++v18;
    ++v17;
    v16 += 16;
    if ( v18 >= m_pColData->m_nNoOfTriangles )
      return 0;
  }
  return 1;
}
// 2DC308: variable 'v11' is possibly undefined
// 793074: using guessed type char `guard variable for'CCollision::TestLineOfSight(CColLine const&,CMatrix const&,CColModel &,bool,bool)::matTransform;

//----- (002DC494) --------------------------------------------------------
int __fastcall CCollision::ProcessLineOfSight(
        const CColLine *line,
        const CMatrix *mat,
        CColModel *colModel,
        CColPoint *colPoint,
        float *fCollisionRatio,
        int bSeeThroughStuff,
        int bShootThroughStuff)
{
  char v10; // r0
  CCollisionData *m_pColData; // r6
  const CColLine *v12; // r0
  int v13; // r4
  int v14; // r5
  int v15; // r4
  int v16; // r5
  int v17; // r8
  int v18; // r9
  int v19; // r4
  RwReal x; // s16
  __int64 v21; // d16
  __int64 v22; // d16
  int result; // r0
  CVector v25; // [sp+1Ch] [bp-64h] BYREF
  CVector v26; // [sp+28h] [bp-58h] BYREF
  CColLine v27; // [sp+38h] [bp-48h] BYREF

  v10 = `guard variable for'CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform;
  __dmb(0xBu);
  if ( (v10 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform) )
  {
    CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform.m_pRwMat = 0;
    CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform.m_owner = 0;
    _cxa_atexit(
      (void (__fastcall *)(void *))CMatrix::~CMatrix,
      &CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform,
      &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform);
  }
  m_pColData = colModel->m_pColData;
  if ( !m_pColData )
    return 0;
  Invert(
    mat,
    &CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform);
  operator*(
    &v26,
    &CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform,
    &line->m_vecStart);
  operator*(
    &v25,
    &CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform,
    &line->m_vecEnd);
  CColLine::CColLine(&v27, &v26, &v25);
  if ( !CCollision::TestLineBox_DW(v12, &colModel->m_boxBound) )
    return 0;
  v25.x = *fCollisionRatio;
  if ( m_pColData->m_nNoOfSpheres >= 1 )
  {
    v13 = 0;
    v14 = 16;
    do
    {
      if ( (bSeeThroughStuff != 1
         || !SurfaceInfos_c::IsSeeThrough(
               &g_surfaceInfos,
               *((unsigned __int8 *)&m_pColData->m_pSphereArray->m_vecCentre.x + v14)))
        && (bShootThroughStuff != 1
         || !SurfaceInfos_c::IsShootThrough(
               &g_surfaceInfos,
               *((unsigned __int8 *)&m_pColData->m_pSphereArray->m_vecCentre.x + v14))) )
      {
        CCollision::ProcessLineSphere(
          &v27,
          (const CColSphere *)((char *)m_pColData->m_pSphereArray + v14 - 16),
          colPoint,
          &v25.x);
      }
      ++v13;
      v14 += 20;
    }
    while ( v13 < m_pColData->m_nNoOfSpheres );
  }
  if ( m_pColData->m_nNoOfBoxes >= 1 )
  {
    v15 = 0;
    v16 = 24;
    do
    {
      if ( (bSeeThroughStuff != 1
         || !SurfaceInfos_c::IsSeeThrough(
               &g_surfaceInfos,
               *((unsigned __int8 *)&m_pColData->m_pBoxArray->m_vecMin.x + v16)))
        && (bShootThroughStuff != 1
         || !SurfaceInfos_c::IsShootThrough(
               &g_surfaceInfos,
               *((unsigned __int8 *)&m_pColData->m_pBoxArray->m_vecMin.x + v16))) )
      {
        CCollision::ProcessLineBox(
          &v27,
          (const CColBox *)((char *)m_pColData->m_pBoxArray + v16 - 24),
          colPoint,
          &v25.x);
      }
      ++v15;
      v16 += 28;
    }
    while ( v15 < m_pColData->m_nNoOfBoxes );
  }
  CCollision::CalculateTrianglePlanes(m_pColData);
  if ( m_pColData->m_nNoOfTriangles >= 1 )
  {
    v17 = 12;
    v18 = 0;
    v19 = 0;
    do
    {
      if ( (bSeeThroughStuff != 1
         || !SurfaceInfos_c::IsSeeThrough(
               &g_surfaceInfos,
               *((unsigned __int8 *)&m_pColData->m_pTriangleArray->m_nIndex1 + v17)))
        && (bShootThroughStuff != 1
         || !SurfaceInfos_c::IsShootThrough(
               &g_surfaceInfos,
               *((unsigned __int8 *)&m_pColData->m_pTriangleArray->m_nIndex1 + v17)))
        && CCollision::ProcessLineTriangle(
             &v27,
             m_pColData->m_pTriCompressedVectorArray,
             (const CColTriangle *)((char *)m_pColData->m_pTriangleArray + v17 - 12),
             &m_pColData->m_pTrianglePlaneArray[v18],
             colPoint,
             &v25.x,
             0) == 1 )
      {
        ++CCollision::ms_iProcessLineNumCrossings;
      }
      ++v19;
      ++v18;
      v17 += 16;
    }
    while ( v19 < m_pColData->m_nNoOfTriangles );
  }
  x = v25.x;
  if ( v25.x >= *fCollisionRatio )
    return 0;
  operator*(&v26, mat, &colPoint->m_vecPosition);
  v21 = *(_QWORD *)&v26.x;
  colPoint->m_vecPosition.z = v26.z;
  *(_QWORD *)&colPoint->m_vecPosition.x = v21;
  Multiply3x3(&v26, mat, &colPoint->m_vecNormal);
  v22 = *(_QWORD *)&v26.x;
  colPoint->m_vecNormal.z = v26.z;
  result = 1;
  *(_QWORD *)&colPoint->m_vecNormal.x = v22;
  *fCollisionRatio = x;
  return result;
}
// 2DC524: variable 'v12' is possibly undefined
// 7930C0: using guessed type char `guard variable for'CCollision::ProcessLineOfSight(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool)::matTransform;
// 2DC494: using guessed type _DWORD bSeeThroughStuff_0;

//----- (002DC72C) --------------------------------------------------------
int __fastcall CCollision::ProcessVerticalLineTriangle(
        const CColLine *line,
        const CollisionVector *aVectors,
        const CColTriangle *triangle,
        const CColTrianglePlane *plane,
        CColPoint *colPoint,
        float *fCollisionRatio,
        CStoredCollPoly *pStoredPoly)
{
  float x; // s3
  const CollisionVector *v8; // r4
  float v9; // s4
  const CollisionVector *v10; // r5
  const CollisionVector *v11; // r1
  float y; // s6
  RwReal v13; // s12
  RwReal v14; // s0
  float v15; // s2
  RwReal z; // s10
  RwReal v17; // s8
  float v18; // s14
  RwReal v19; // s1
  float v20; // s5
  float v21; // s15
  float v22; // s11
  float v23; // s26
  float v24; // s16
  float v25; // s18
  float v26; // s7
  float v27; // s13
  float m_compressedNormalOffset; // s20
  float v29; // s20
  float v30; // s26
  float v31; // s28
  float v32; // s30
  float v33; // s17
  float v34; // s19
  float v35; // s24
  float v36; // s7
  float v37; // s20
  float v38; // s26
  float v39; // s18
  float v40; // s20
  float v41; // s22
  int result; // r0
  uint8 m_nSurfaceType; // r5
  uint8 m_nLighting; // r5

  x = line->m_vecStart.x;
  v8 = &aVectors[triangle->m_nIndex2];
  v9 = v8->x;
  v10 = &aVectors[triangle->m_nIndex3];
  v11 = &aVectors[triangle->m_nIndex1];
  y = v8->y;
  v13 = v11->x;
  v14 = v10->x;
  v15 = v10->y;
  z = v10->z;
  v17 = v8->z;
  v18 = v11->y;
  v19 = v11->z;
  if ( line->m_vecStart.x >= v11->x )
  {
    if ( x > v9 )
      return 0;
  }
  else if ( x < v9 )
  {
    return 0;
  }
  v20 = line->m_vecStart.y;
  if ( v20 < v18 )
  {
    if ( v20 >= y || v20 >= v15 )
      goto LABEL_10;
    return 0;
  }
  if ( v20 > y )
    return 0;
LABEL_10:
  v21 = line->m_vecEnd.x;
  v22 = plane->m_compressedNormal.y;
  v23 = plane->m_compressedNormal.x * x;
  v24 = line->m_vecEnd.y;
  v25 = line->m_vecStart.z;
  v26 = line->m_vecEnd.z;
  v27 = plane->m_compressedNormal.z;
  m_compressedNormalOffset = plane->m_compressedNormalOffset;
  if ( (float)((float)((float)((float)(v23 + (float)(v22 * v20)) + (float)(v27 * v25)) - m_compressedNormalOffset)
             * (float)((float)((float)((float)(plane->m_compressedNormal.x * v21) + (float)(v22 * v24))
                             + (float)(v27 * v26))
                     - m_compressedNormalOffset)) > 0.0 )
    return 0;
  v29 = m_compressedNormalOffset - v23;
  v30 = v26 - v25;
  v31 = v11->z;
  v32 = v10->z;
  v33 = v8->y;
  v34 = v8->z;
  v35 = v11->y;
  v36 = (float)((float)(v29 - (float)(v22 * v20)) - (float)(v27 * v25)) / (float)(v27 * (float)(v26 - v25));
  v37 = v30 * v36;
  v38 = v10->y;
  v39 = v25 + v37;
  v40 = line->m_vecStart.y;
  v41 = v39;
  switch ( plane->m_nPrincipalAxis )
  {
    case 1u:
      v40 = line->m_vecStart.y;
      v41 = v39;
      v35 = v11->y;
      v31 = v11->z;
      v38 = v8->y;
      v32 = v8->z;
      v33 = v10->y;
      v34 = v10->z;
      break;
    case 2u:
      v40 = v39;
      v41 = line->m_vecStart.x;
      v35 = v11->z;
      v31 = v11->x;
      v38 = v10->z;
      v32 = v10->x;
      v33 = v8->z;
      v34 = v8->x;
      break;
    case 3u:
      v40 = v39;
      v41 = line->m_vecStart.x;
      v35 = v11->z;
      v31 = v11->x;
      v38 = v8->z;
      v32 = v8->x;
      v33 = v10->z;
      v34 = v10->x;
      break;
    case 4u:
      v40 = line->m_vecStart.x;
      v41 = line->m_vecStart.y;
      v35 = v11->x;
      v31 = v11->y;
      v38 = v10->x;
      v32 = v10->y;
      v33 = v8->x;
      v34 = v8->y;
      break;
    case 5u:
      v40 = line->m_vecStart.x;
      v41 = line->m_vecStart.y;
      v35 = v11->x;
      v31 = v11->y;
      v38 = v8->x;
      v32 = v8->y;
      v33 = v10->x;
      v34 = v10->y;
      break;
    default:
      break;
  }
  if ( (float)((float)((float)(v41 - v31) * (float)(v38 - v35)) - (float)((float)(v40 - v35) * (float)(v32 - v31))) < 0.0
    || (float)((float)((float)(v41 - v31) * (float)(v33 - v35)) - (float)((float)(v40 - v35) * (float)(v34 - v31))) > 0.0 )
  {
    return 0;
  }
  result = 0;
  if ( (float)((float)((float)(v41 - v32) * (float)(v33 - v38)) - (float)((float)(v40 - v38) * (float)(v34 - v32))) >= 0.0
    && v36 < *fCollisionRatio )
  {
    colPoint->m_vecNormal.x = plane->m_compressedNormal.x;
    colPoint->m_vecNormal.y = v22;
    colPoint->m_vecNormal.z = v27;
    colPoint->m_vecPosition.x = x + (float)(v36 * (float)(v21 - x));
    colPoint->m_vecPosition.y = v20 + (float)(v36 * (float)(v24 - v20));
    colPoint->m_vecPosition.z = v39;
    m_nSurfaceType = triangle->m_nSurfaceType;
    colPoint->m_dataB.m_nPieceType = 0;
    colPoint->m_dataB.m_nSurfaceType = m_nSurfaceType;
    m_nLighting = triangle->m_nLighting;
    *(_WORD *)&colPoint->m_dataA.m_nSurfaceType = 0;
    colPoint->m_dataB.m_lighting = m_nLighting;
    if ( pStoredPoly )
    {
      pStoredPoly->V3.z = z;
      pStoredPoly->V1.x = v13;
      pStoredPoly->V1.y = v18;
      pStoredPoly->V1.z = v19;
      pStoredPoly->V2.x = v9;
      pStoredPoly->V2.y = y;
      pStoredPoly->V2.z = v17;
      pStoredPoly->V3.x = v14;
      pStoredPoly->V3.y = v15;
      pStoredPoly->bValidPolyStored = 1;
      pStoredPoly->lighting = triangle->m_nLighting;
    }
    result = 1;
    *fCollisionRatio = v36;
  }
  return result;
}

//----- (002DCA54) --------------------------------------------------------
int __fastcall CCollision::ProcessVerticalLine(
        const CColLine *Line,
        const CMatrix *mat,
        CColModel *colModel,
        CColPoint *colPoint,
        float *fCollisionRatio,
        int bSeeThroughStuff,
        bool bShootThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  CCollisionData *m_pColData; // r6
  char v13; // r0
  float tx; // s6
  float ty; // s8
  float v16; // s0
  float xx; // s12
  float v18; // s2
  float yx; // s14
  float tz; // s10
  float zx; // s1
  float v22; // s4
  float xy; // s3
  float yy; // s5
  float zy; // s7
  float xz; // s9
  float yz; // s11
  float zz; // s13
  float v29; // s0
  float v30; // s2
  float v31; // s4
  int v32; // r5
  int v33; // r8
  int v34; // r5
  int v35; // r8
  int v36; // r4
  int v37; // r9
  int v38; // r8
  float v39; // s16
  __int64 v40; // d16
  __int64 v41; // d16
  __int64 v42; // d21
  __int64 v43; // d16
  __int64 v44; // d17
  __int64 v45; // d18
  __int64 v46; // d19
  __int64 v47; // d16
  __int64 v48; // d16
  __int64 v49; // d16
  int result; // r0
  CMatrix *m; // [sp+Ch] [bp-5Ch]
  CVector v52; // [sp+10h] [bp-58h] BYREF
  float v53; // [sp+1Ch] [bp-4Ch] BYREF
  CColLine v54; // [sp+20h] [bp-48h] BYREF

  m_pColData = colModel->m_pColData;
  if ( !m_pColData )
    return 0;
  v13 = `guard variable for'CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly;
  __dmb(0xBu);
  if ( (v13 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly);
  }
  tx = mat->tx;
  ty = mat->ty;
  v16 = Line->m_vecStart.x - tx;
  xx = mat->xx;
  v18 = Line->m_vecStart.y - ty;
  yx = mat->yx;
  tz = mat->tz;
  zx = mat->zx;
  v22 = Line->m_vecStart.z - tz;
  v54.m_vecStart.x = (float)((float)(v16 * mat->xx) + (float)(v18 * yx)) + (float)(v22 * zx);
  xy = mat->xy;
  yy = mat->yy;
  zy = mat->zy;
  v54.m_vecStart.y = (float)((float)(v16 * xy) + (float)(v18 * yy)) + (float)(v22 * zy);
  xz = mat->xz;
  yz = mat->yz;
  zz = mat->zz;
  v54.m_vecStart.z = (float)((float)(v16 * xz) + (float)(v18 * yz)) + (float)(v22 * zz);
  v29 = Line->m_vecEnd.x - tx;
  v30 = Line->m_vecEnd.y - ty;
  v31 = Line->m_vecEnd.z - tz;
  v54.m_vecEnd.z = (float)((float)(v29 * xz) + (float)(v30 * yz)) + (float)(v31 * zz);
  v54.m_vecEnd.y = (float)((float)(v29 * xy) + (float)(v30 * yy)) + (float)(v31 * zy);
  v54.m_vecEnd.x = (float)((float)(v29 * xx) + (float)(v30 * yx)) + (float)(v31 * zx);
  if ( !CCollision::TestLineBox_DW(&v54, &colModel->m_boxBound) )
    return 0;
  m = (CMatrix *)mat;
  v53 = *fCollisionRatio;
  if ( m_pColData->m_nNoOfSpheres >= 1 )
  {
    v32 = 0;
    v33 = 0;
    do
    {
      if ( bSeeThroughStuff != 1
        || !SurfaceInfos_c::IsSeeThrough(&g_surfaceInfos, m_pColData->m_pSphereArray[v32].m_data.m_nSurfaceType) )
      {
        CCollision::ProcessLineSphere(&v54, &m_pColData->m_pSphereArray[v32], colPoint, &v53);
      }
      ++v33;
      ++v32;
    }
    while ( v33 < m_pColData->m_nNoOfSpheres );
  }
  if ( m_pColData->m_nNoOfBoxes >= 1 )
  {
    v34 = 0;
    v35 = 0;
    do
    {
      if ( bSeeThroughStuff != 1
        || !SurfaceInfos_c::IsSeeThrough(&g_surfaceInfos, m_pColData->m_pBoxArray[v34].m_data.m_nSurfaceType) )
      {
        CCollision::ProcessLineBox(&v54, &m_pColData->m_pBoxArray[v34], colPoint, &v53);
      }
      ++v35;
      ++v34;
    }
    while ( v35 < m_pColData->m_nNoOfBoxes );
  }
  CCollision::CalculateTrianglePlanes(m_pColData);
  CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.bValidPolyStored = 0;
  if ( m_pColData->m_nNoOfTriangles >= 1 )
  {
    v36 = 0;
    v37 = 0;
    v38 = 0;
    do
    {
      if ( bSeeThroughStuff != 1
        || !SurfaceInfos_c::IsSeeThrough(&g_surfaceInfos, m_pColData->m_pTriangleArray[v37].m_nSurfaceType) )
      {
        CCollision::ProcessLineTriangle(
          &v54,
          m_pColData->m_pTriCompressedVectorArray,
          &m_pColData->m_pTriangleArray[v37],
          &m_pColData->m_pTrianglePlaneArray[v36],
          colPoint,
          &v53,
          &CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly);
      }
      ++v38;
      ++v36;
      ++v37;
    }
    while ( v38 < m_pColData->m_nNoOfTriangles );
  }
  v39 = v53;
  if ( v53 >= *fCollisionRatio )
    return 0;
  operator*(&v52, m, &colPoint->m_vecPosition);
  v40 = *(_QWORD *)&v52.x;
  colPoint->m_vecPosition.z = v52.z;
  *(_QWORD *)&colPoint->m_vecPosition.x = v40;
  Multiply3x3(&v52, m, &colPoint->m_vecNormal);
  v41 = *(_QWORD *)&v52.x;
  colPoint->m_vecNormal.z = v52.z;
  *(_QWORD *)&colPoint->m_vecNormal.x = v41;
  if ( pStoredPoly )
  {
    if ( CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.bValidPolyStored )
    {
      v42 = *(_QWORD *)&CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.bValidPolyStored;
      v43 = *(_QWORD *)&CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.V1.x;
      v44 = *(_QWORD *)&CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.V1.z;
      v45 = *(_QWORD *)&CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.V2.y;
      v46 = *(_QWORD *)&CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.V3.x;
      *(_QWORD *)&pStoredPoly->V3.y = *(_QWORD *)&CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly.V3.y;
      *(_QWORD *)&pStoredPoly->bValidPolyStored = v42;
      *(_QWORD *)&pStoredPoly->V1.x = v43;
      *(_QWORD *)&pStoredPoly->V1.z = v44;
      *(_QWORD *)&pStoredPoly->V2.y = v45;
      *(_QWORD *)&pStoredPoly->V3.x = v46;
      operator*(&v52, m, &pStoredPoly->V1);
      v47 = *(_QWORD *)&v52.x;
      pStoredPoly->V1.z = v52.z;
      *(_QWORD *)&pStoredPoly->V1.x = v47;
      operator*(&v52, m, &pStoredPoly->V2);
      v48 = *(_QWORD *)&v52.x;
      pStoredPoly->V2.z = v52.z;
      *(_QWORD *)&pStoredPoly->V2.x = v48;
      operator*(&v52, m, &pStoredPoly->V3);
      v49 = *(_QWORD *)&v52.x;
      pStoredPoly->V3.z = v52.z;
      *(_QWORD *)&pStoredPoly->V3.x = v49;
    }
  }
  result = 1;
  *fCollisionRatio = v39;
  return result;
}
// 7930F4: using guessed type char `guard variable for'CCollision::ProcessVerticalLine(CColLine const&,CMatrix const&,CColModel &,CColPoint &,float &,bool,bool,CStoredCollPoly *)::TempStoredPoly;
// 2DCA54: using guessed type _DWORD bSeeThroughStuff_0;

//----- (002DCDA4) --------------------------------------------------------
bool __fastcall CCollision::IsStoredPolyStillValidVerticalLine(
        const CVector *vecStart,
        float zEnd,
        CColPoint *colPoint,
        CStoredCollPoly *pStoredPoly)
{
  float v4; // s9
  float y; // s2
  RwReal v9; // s12
  float z; // s4
  RwReal v11; // s14
  RwReal v12; // s0
  RwReal v13; // s1
  RwReal v14; // s2
  float x; // s16
  RwReal v16; // s4
  float v17; // s18
  float v18; // s20
  float v19; // s1
  float v20; // s0
  float v21; // s14
  float v22; // s12
  char v23; // r0
  float v24; // s3
  bool result; // r0
  float v26; // s14
  float v27; // s1
  float v28; // s7
  float v29; // s5
  float v30; // s7
  float v31; // s5
  float v32; // s3
  float v33; // s12
  float v34; // s2
  float v35; // s6
  float v36; // s2
  float v37; // s4
  float v38; // s6
  CVector v39; // [sp+0h] [bp-60h] BYREF
  CVector v1; // [sp+Ch] [bp-54h] BYREF
  CVector v41; // [sp+18h] [bp-48h] BYREF
  CVector v42; // [sp+28h] [bp-38h] BYREF

  if ( !pStoredPoly->bValidPolyStored )
    return 0;
  y = pStoredPoly->V1.y;
  v9 = pStoredPoly->V3.x - pStoredPoly->V1.x;
  z = pStoredPoly->V1.z;
  v11 = pStoredPoly->V3.y - y;
  v12 = pStoredPoly->V2.x - pStoredPoly->V1.x;
  v13 = pStoredPoly->V3.z - z;
  v14 = pStoredPoly->V2.y - y;
  x = vecStart->x;
  v16 = pStoredPoly->V2.z - z;
  v17 = vecStart->y;
  v18 = vecStart->z;
  v1.y = v11;
  v1.x = v9;
  v1.z = v13;
  v39.y = v14;
  v39.x = v12;
  v39.z = v16;
  CrossProduct(&v41, &v1, &v39);
  v42 = v41;
  CVector::Normalise(&v42);
  v19 = fabsf(v42.x);
  v20 = pStoredPoly->V1.z;
  v21 = fabsf(v42.y);
  v22 = (float)((float)(v42.x * pStoredPoly->V1.x) + (float)(v42.y * pStoredPoly->V1.y)) + (float)(v42.z * v20);
  if ( v19 <= v21 || v19 <= fabsf(v42.z) )
  {
    v24 = v42.z;
    if ( v42.z < 0.0 )
      v24 = -v42.z;
    if ( v21 <= v24 )
    {
      v23 = 5;
      if ( v42.z > 0.0 )
        v23 = 4;
    }
    else
    {
      v23 = 3;
      if ( v42.y > 0.0 )
        v23 = 2;
    }
  }
  else
  {
    v23 = v42.x <= 0.0;
  }
  v26 = v17 * v42.y;
  v27 = v18 * v42.z;
  v28 = (float)(x * v42.x) + (float)(v17 * v42.y);
  v29 = v28 + (float)(v42.z * zEnd);
  v30 = (float)(v28 + (float)(v18 * v42.z)) - v22;
  if ( (float)(v30 * (float)(v29 - v22)) > 0.0 )
    goto LABEL_28;
  v31 = 0.0;
  v32 = zEnd - v18;
  v33 = (float)(v22 - (float)(x * v42.x)) - v26;
  v34 = (float)(v33 - v27)
      / (float)((float)((float)(v42.x * 0.0) + (float)(v42.y * 0.0)) + (float)((float)(zEnd - v18) * v42.z));
  v35 = v34 * 0.0;
  v36 = v18 + (float)((float)(zEnd - v18) * v34);
  v37 = v17 + v35;
  v38 = x + v35;
  switch ( v23 & 7 )
  {
    case 0:
      v27 = pStoredPoly->V2.y;
      v32 = pStoredPoly->V2.z;
      v33 = pStoredPoly->V3.y;
      v26 = pStoredPoly->V3.z;
      goto LABEL_18;
    case 1:
      v33 = pStoredPoly->V2.y;
      v26 = pStoredPoly->V2.z;
      v27 = pStoredPoly->V3.y;
      v32 = pStoredPoly->V3.z;
LABEL_18:
      v31 = v37;
      v30 = v36;
      v4 = pStoredPoly->V1.y;
      break;
    case 2:
      v32 = pStoredPoly->V2.x;
      v27 = pStoredPoly->V2.z;
      v26 = pStoredPoly->V3.x;
      v33 = pStoredPoly->V3.z;
      goto LABEL_21;
    case 3:
      v26 = pStoredPoly->V2.x;
      v33 = pStoredPoly->V2.z;
      v32 = pStoredPoly->V3.x;
      v27 = pStoredPoly->V3.z;
LABEL_21:
      v4 = pStoredPoly->V1.z;
      v31 = v36;
      v30 = v38;
      v20 = pStoredPoly->V1.x;
      break;
    case 4:
      v27 = pStoredPoly->V2.x;
      v32 = pStoredPoly->V2.y;
      v33 = pStoredPoly->V3.x;
      v26 = pStoredPoly->V3.y;
      goto LABEL_24;
    case 5:
      v33 = pStoredPoly->V2.x;
      v26 = pStoredPoly->V2.y;
      v27 = pStoredPoly->V3.x;
      v32 = pStoredPoly->V3.y;
LABEL_24:
      v31 = v38;
      v30 = v37;
      v4 = pStoredPoly->V1.x;
      v20 = pStoredPoly->V1.y;
      break;
    default:
      break;
  }
  if ( (float)((float)((float)(v30 - v20) * (float)(v33 - v4)) - (float)((float)(v31 - v4) * (float)(v26 - v20))) >= 0.0
    && (float)((float)((float)(v30 - v20) * (float)(v27 - v4)) - (float)((float)(v31 - v4) * (float)(v32 - v20))) <= 0.0
    && (float)((float)((float)(v30 - v26) * (float)(v27 - v33)) - (float)((float)(v31 - v33) * (float)(v32 - v26))) >= 0.0 )
  {
    colPoint->m_vecPosition.x = v38;
    result = 1;
    colPoint->m_vecPosition.y = v37;
    colPoint->m_vecPosition.z = v36;
  }
  else
  {
LABEL_28:
    result = 0;
    pStoredPoly->bValidPolyStored = 0;
  }
  return result;
}
// 2DD000: variable 'v4' is possibly undefined

//----- (002DD090) --------------------------------------------------------
int32 __fastcall CCollision::ProcessColModels(
        const CMatrix *matA,
        CColModel *colModelA,
        const CMatrix *matB,
        CColModel *colModelB,
        CColPoint *aColPoints,
        CColPoint *aLineColPoints,
        float *aLineRatios,
        int bReturnAllCollisions)
{
  CCollisionData *v8; // r9
  char v13; // r0
  char v14; // r0
  char v15; // r0
  char v16; // r0
  char v17; // r0
  CCollisionData *m_pColData; // r10
  int v19; // r4
  bool v20; // zf
  CMatrix *v21; // r0
  float v22; // s16
  float v23; // s18
  float v24; // s20
  float v25; // s22
  float v26; // s24
  float v27; // s26
  CMatrix *v28; // r0
  int v29; // r5
  int v30; // r4
  CColSphere *v31; // r6
  __int64 v32; // d16
  int v33; // r0
  uint8 v34; // r1
  int m_nNoOfSpheres; // r0
  RwReal *p_z; // r1
  float x; // s0
  float y; // s2
  float z; // s4
  float v40; // s6
  float v41; // s8
  float v42; // s10
  int32 v43; // r2
  float v44; // s12
  float v45; // s14
  float v46; // s14
  int v47; // r0
  int v48; // r5
  int v49; // r4
  CColSphere *v50; // r6
  __int64 v51; // d16
  int v52; // r0
  uint8 v53; // r1
  int32 v54; // r2
  RwReal *v55; // r1
  float v56; // s0
  float v57; // s2
  float v58; // s4
  float v59; // s6
  float v60; // s8
  float v61; // s10
  float v62; // s12
  float v63; // s14
  float v64; // s14
  int v65; // r5
  int i; // r6
  __int64 v67; // d16
  CColSphere *v68; // r0
  int v69; // r0
  char *v70; // r1
  __int16 v71; // r2
  CColSphere *v72; // r0
  int m_nNoOfLines; // r0
  int v74; // r6
  int v75; // r10
  float v76; // s0
  float v77; // s2
  float v78; // s4
  float v79; // s6
  float v80; // s8
  float v81; // s10
  RwReal *v82; // r1
  int32 j; // r2
  float v84; // s12
  float v85; // s14
  float v86; // s14
  int m_nNoOfBoxes; // r0
  int32 v88; // r2
  float *p_x; // r1
  bool v90; // cc
  bool v91; // zf
  const CColTrianglePlane *v92; // r3
  char v93; // r0
  CCollisionData *v94; // r2
  int v95; // r5
  int32 v96; // r6
  int v97; // r6
  int v98; // r4
  __int16 *v99; // r4
  int v100; // t1
  int v101; // r1
  int32 v102; // r11
  int v103; // r5
  int v104; // r12
  CColPoint *v105; // r6
  CColPoint *v106; // r8
  int v107; // r11
  int32 *v108; // r5
  int v109; // r4
  int v110; // r10
  int32 v111; // r1
  int32 v112; // r0
  const CColSphere *v113; // r1
  int32 v114; // r0
  bool v115; // zf
  int v116; // r5
  int32 *v117; // r4
  CColSphere *v118; // r0
  ColData *p_m_data; // r8
  int v120; // r10
  int32 v121; // r2
  CColPoint *v122; // r6
  __int16 v123; // r1
  int v124; // r8
  int32 *v125; // r9
  int v126; // r10
  int v127; // r0
  bool v128; // zf
  CCollisionData *v129; // r10
  int v130; // r0
  int v131; // r4
  signed int v132; // r6
  __int64 v133; // d16
  CColLine *v134; // r5
  __int64 v135; // d16
  signed int v136; // r0
  float *v137; // r6
  int v139; // r0
  int v140; // r1
  float v141; // r3
  int v142; // r2
  int v143; // r5
  CColSphere *v144; // r4
  int v145; // r6
  __int64 v146; // d16
  int v147; // r0
  uint8 v148; // r1
  int v149; // r0
  int v150; // r8
  signed int v151; // r3
  int32x4_t v152; // q9
  int32x4_t v153; // q8
  int32 *v154; // r1
  unsigned int v155; // r2
  CColPoint *v156; // r9
  int v157; // r4
  int32 *v158; // r5
  int v159; // r4
  int32 *v160; // r5
  int v161; // r4
  int32 *v162; // r5
  CColPoint *v163; // r6
  __int64 v164; // d16
  CColPoint *v165; // r4
  __int64 v166; // d16
  int v167; // r4
  int32 *v168; // r5
  float32x2_t v169; // d13
  float zx; // s28
  float32x2_t *v171; // r0
  float32x2_t v172; // d16
  unsigned __int64 v173; // d1
  float v174; // s0
  __int16 v175; // r0
  float v176; // s26
  int v177; // r9
  int32 *v178; // r10
  float32x2_t v179; // d15
  float v180; // s28
  float32x2_t *v181; // r0
  float32x2_t v182; // d16
  float v183; // s2
  unsigned __int64 v184; // d2
  float v185; // s0
  CColSphere *v186; // r11
  __int16 v187; // r0
  __int16 v188; // r0
  __int16 v189; // r0
  __int64 v190; // d16
  __int64 v191; // d17
  __int64 v192; // d18
  __int64 v193; // d19
  __int64 v194; // d21
  int32 *v195; // r5
  int v196; // r4
  CColTrianglePlane *v197; // r1
  float v198; // s0
  __int64 v199; // r0
  float *v200; // r2
  CColPoint *v201; // r6
  int v202; // r4
  __int64 v203; // d16
  __int64 v204; // d16
  CColPoint *v205; // r1
  float *p_m_fDepth; // r6
  float m_fRadius; // s0
  float v208; // s2
  float v209; // s2
  int v210; // r9
  CColPoint *v211; // r6
  int v212; // r4
  __int64 v213; // d16
  __int64 v214; // d16
  float v215; // r6
  const CColTrianglePlane *v216; // r3
  int16 m_nNoOfTriangles; // r1
  CCollisionData *v218; // r0
  CCollisionData *v219; // r2
  int v220; // r4
  int32 v221; // r5
  int v222; // r0
  CCollisionData *v223; // r10
  float v224; // s8
  float v225; // s4
  CColBox *m_pBoxArray; // r1
  float v227; // s0
  float v228; // s2
  float v229; // s6
  int v230; // r2
  float v231; // s10
  float *v232; // r1
  int32 v233; // r3
  int v234; // r0
  int v235; // r11
  int32 *v236; // r12
  CColPoint *v237; // r8
  int v238; // r5
  int32 *v239; // r10
  int v240; // r6
  int v241; // t1
  int32 *v242; // r4
  RwReal v243; // s2
  RwReal v244; // s4
  CMatrix *v245; // r11
  int v246; // r5
  int32 v247; // r0
  int v248; // r8
  CColPoint *v249; // r6
  RwReal v250; // s0
  RwReal v251; // s2
  RwReal v252; // s4
  int v253; // r0
  __int16 v254; // r1
  __int16 v255; // r1
  int v256; // r6
  CColPoint *v257; // r5
  __int64 v258; // d16
  __int64 v259; // d16
  ColData *p_m_dataB; // r5
  __int16 v261; // t1
  uint8 m_lighting; // r3
  ColData *v263; // r1
  uint8 v264; // r0
  CColLine *m_pLineArray; // [sp+Ch] [bp-134h]
  CColPoint *v266; // [sp+14h] [bp-12Ch]
  ColData *p_m_dataA; // [sp+18h] [bp-128h]
  __int16 *v268; // [sp+1Ch] [bp-124h]
  CColPoint *v269; // [sp+24h] [bp-11Ch]
  CColPoint *v270; // [sp+24h] [bp-11Ch]
  int v271; // [sp+30h] [bp-110h]
  CMatrix *m; // [sp+34h] [bp-10Ch]
  CColTrianglePlane *m_pTrianglePlaneArray; // [sp+38h] [bp-108h]
  CColModel *v274; // [sp+3Ch] [bp-104h]
  int v275; // [sp+40h] [bp-100h]
  CVector *v; // [sp+44h] [bp-FCh]
  int32 lineCollision; // [sp+48h] [bp-F8h]
  bool *lineCollisiona; // [sp+48h] [bp-F8h]
  CColSphere *m_pSphereArray; // [sp+4Ch] [bp-F4h]
  float *v280; // [sp+4Ch] [bp-F4h]
  int v281; // [sp+4Ch] [bp-F4h]
  int fDistanceSqr; // [sp+50h] [bp-F0h]
  int v283; // [sp+54h] [bp-ECh]
  unsigned __int8 *p_m_nPieceType; // [sp+58h] [bp-E8h]
  int v285; // [sp+58h] [bp-E8h]
  int v286; // [sp+58h] [bp-E8h]
  int v287; // [sp+58h] [bp-E8h]
  CCollisionData *v288; // [sp+5Ch] [bp-E4h]
  CMatrix *m2; // [sp+60h] [bp-E0h]
  int m2a; // [sp+60h] [bp-E0h]
  CMatrix *m2b; // [sp+60h] [bp-E0h]
  CColModel *v292; // [sp+64h] [bp-DCh]
  int v293; // [sp+64h] [bp-DCh]
  CColPoint *p; // [sp+68h] [bp-D8h]
  CColPoint *pa; // [sp+68h] [bp-D8h]
  CColPoint *pb; // [sp+68h] [bp-D8h]
  CColPoint *pc; // [sp+68h] [bp-D8h]
  CCollisionData *pColData; // [sp+6Ch] [bp-D4h]
  CVector v299; // [sp+70h] [bp-D0h] BYREF
  float lineRatio; // [sp+7Ch] [bp-C4h] BYREF
  CColSphere sphere; // [sp+80h] [bp-C0h] BYREF
  CMatrix v302; // [sp+98h] [bp-A8h] BYREF

  v13 = `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA;
  __dmb(0xBu);
  if ( (v13 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA);
  }
  v14 = `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB;
  __dmb(0xBu);
  if ( (v14 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB);
  }
  v15 = `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA;
  __dmb(0xBu);
  if ( (v15 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA);
  }
  v16 = `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB;
  __dmb(0xBu);
  if ( (v16 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB) )
  {
    CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB.m_pRwMat = 0;
    CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB.m_owner = 0;
    _cxa_atexit(
      (void (__fastcall *)(void *))CMatrix::~CMatrix,
      &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
      &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB);
  }
  v17 = `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA;
  __dmb(0xBu);
  if ( (v17 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA) )
  {
    CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA.m_pRwMat = 0;
    CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA.m_owner = 0;
    _cxa_atexit(
      (void (__fastcall *)(void *))CMatrix::~CMatrix,
      &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
      &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA);
  }
  m_pColData = colModelA->m_pColData;
  v19 = 0;
  v20 = m_pColData == 0;
  if ( m_pColData )
  {
    v8 = colModelB->m_pColData;
    v20 = v8 == 0;
  }
  if ( v20 )
    return v19;
  m2 = (CMatrix *)matB;
  v21 = Invert(
          matB,
          &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB);
  CMatrix::operator=(
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
    v21);
  v292 = colModelB;
  operator*(
    &v302,
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
    matA);
  CMatrix::operator=(
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
    &v302);
  CMatrix::~CMatrix(&v302);
  sphere.m_fRadius = colModelA->m_sphereBound.m_fRadius;
  operator*(
    (CVector *)&v302,
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
    &colModelA->m_sphereBound.m_vecCentre);
  sphere.m_vecCentre.z = v302.zx;
  *(_QWORD *)&sphere.m_vecCentre.x = *(_QWORD *)&v302.xx;
  v22 = v302.xx + sphere.m_fRadius;
  if ( (float)(v302.xx + sphere.m_fRadius) < colModelB->m_boxBound.m_vecMin.x )
    return 0;
  v23 = v302.xx - sphere.m_fRadius;
  if ( (float)(v302.xx - sphere.m_fRadius) > colModelB->m_boxBound.m_vecMax.x )
    return 0;
  v24 = sphere.m_vecCentre.y + sphere.m_fRadius;
  if ( (float)(sphere.m_vecCentre.y + sphere.m_fRadius) < colModelB->m_boxBound.m_vecMin.y )
    return 0;
  v25 = sphere.m_vecCentre.y - sphere.m_fRadius;
  if ( (float)(sphere.m_vecCentre.y - sphere.m_fRadius) > colModelB->m_boxBound.m_vecMax.y )
    return 0;
  v26 = sphere.m_vecCentre.z + sphere.m_fRadius;
  if ( (float)(sphere.m_vecCentre.z + sphere.m_fRadius) < colModelB->m_boxBound.m_vecMin.z )
    return 0;
  v27 = sphere.m_vecCentre.z - sphere.m_fRadius;
  if ( (float)(sphere.m_vecCentre.z - sphere.m_fRadius) > colModelB->m_boxBound.m_vecMax.z )
    return 0;
  v28 = Invert(
          matA,
          &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA);
  CMatrix::operator=(
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
    v28);
  operator*(
    &v302,
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
    matB);
  CMatrix::operator=(
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
    &v302);
  CMatrix::~CMatrix(&v302);
  m = (CMatrix *)matA;
  v288 = m_pColData;
  pColData = v8;
  v274 = colModelA;
  if ( m_pColData->m_nNoOfSpheres < 1 )
  {
    v = 0;
  }
  else
  {
    v29 = 0;
    v30 = 0;
    do
    {
      v31 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v29];
      CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v29].m_fRadius = m_pColData->m_pSphereArray[v29].m_fRadius;
      operator*(
        (CVector *)&v302,
        &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
        &m_pColData->m_pSphereArray[v29].m_vecCentre);
      v32 = *(_QWORD *)&v302.xx;
      ++v30;
      v31->m_vecCentre.z = v302.zx;
      *(_QWORD *)&v31->m_vecCentre.x = v32;
      v33 = (int)&m_pColData->m_pSphereArray[v29++];
      v34 = *(_BYTE *)(v33 + 18);
      LOWORD(v33) = *(_WORD *)(v33 + 16);
      v31->m_data.m_lighting = v34;
      *(_WORD *)&v31->m_data.m_nSurfaceType = v33;
      m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
    }
    while ( v30 < m_nNoOfSpheres );
    if ( m_nNoOfSpheres < 1 )
    {
      v = 0;
    }
    else
    {
      p_z = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[0].m_vecCentre.z;
      x = v292->m_boxBound.m_vecMin.x;
      y = v292->m_boxBound.m_vecMin.y;
      z = v292->m_boxBound.m_vecMin.z;
      v40 = v292->m_boxBound.m_vecMax.x;
      v41 = v292->m_boxBound.m_vecMax.y;
      v42 = v292->m_boxBound.m_vecMax.z;
      v43 = 0;
      v = 0;
      do
      {
        v44 = p_z[1];
        v45 = *(p_z - 2);
        if ( (float)(v45 + v44) >= x && (float)(v45 - v44) <= v40 )
        {
          v46 = *(p_z - 1);
          if ( (float)(v44 + v46) >= y
            && (float)(v46 - v44) <= v41
            && (float)(v44 + *p_z) >= z
            && (float)(*p_z - v44) <= v42 )
          {
            CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesA[(_DWORD)v] = v43;
            v = (CVector *)((char *)v + 1);
          }
        }
        ++v43;
        p_z += 5;
      }
      while ( v43 < m_nNoOfSpheres );
    }
  }
  v47 = v8->m_nNoOfSpheres;
  if ( v47 < 1 )
  {
    v283 = 0;
  }
  else
  {
    v48 = 0;
    v49 = 0;
    do
    {
      v50 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v48];
      CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v48].m_fRadius = v8->m_pSphereArray[v48].m_fRadius;
      operator*(
        (CVector *)&v302,
        &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
        &v8->m_pSphereArray[v48].m_vecCentre);
      v51 = *(_QWORD *)&v302.xx;
      ++v49;
      v50->m_vecCentre.z = v302.zx;
      *(_QWORD *)&v50->m_vecCentre.x = v51;
      v52 = (int)&v8->m_pSphereArray[v48++];
      v53 = *(_BYTE *)(v52 + 18);
      LOWORD(v52) = *(_WORD *)(v52 + 16);
      v50->m_data.m_lighting = v53;
      *(_WORD *)&v50->m_data.m_nSurfaceType = v52;
      v47 = v8->m_nNoOfSpheres;
    }
    while ( v49 < v47 );
    if ( v47 < 1 )
    {
      v283 = 0;
    }
    else
    {
      v54 = 0;
      v55 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[0].m_vecCentre.z;
      v56 = colModelA->m_boxBound.m_vecMin.x;
      v57 = colModelA->m_boxBound.m_vecMin.y;
      v58 = colModelA->m_boxBound.m_vecMin.z;
      v59 = colModelA->m_boxBound.m_vecMax.x;
      v60 = colModelA->m_boxBound.m_vecMax.y;
      v61 = colModelA->m_boxBound.m_vecMax.z;
      v283 = 0;
      do
      {
        v62 = v55[1];
        v63 = *(v55 - 2);
        if ( (float)(v63 + v62) >= v56 && (float)(v63 - v62) <= v59 )
        {
          v64 = *(v55 - 1);
          if ( (float)(v62 + v64) >= v57
            && (float)(v64 - v62) <= v60
            && (float)(v62 + *v55) >= v58
            && (float)(*v55 - v62) <= v61 )
          {
            CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB[v283++] = v54;
          }
        }
        ++v54;
        v55 += 5;
      }
      while ( v54 < v47 );
    }
  }
  if ( !v )
  {
    v91 = v283 == 0;
    if ( !v283 )
      v91 = m_pColData->_anon_0.m_nNoOfLines == 0;
    if ( v91 )
      return 0;
  }
  if ( *((unsigned __int8 *)v8 + 7) << 31 && v8->_anon_0.m_nNoOfLines >= 1 )
  {
    v65 = 0;
    for ( i = 12; ; i += 36 )
    {
      CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v65 + (__int16)v47].m_fRadius = *(float *)((char *)&v8->_anon_1.m_pLineArray->m_vecStart.x + i);
      operator*(
        (CVector *)&v302,
        &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
        (const CVector *)((char *)v8->_anon_1.m_pLineArray + i - 12));
      v67 = *(_QWORD *)&v302.xx;
      v68 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v8->m_nNoOfSpheres + v65];
      v68->m_vecCentre.z = v302.zx;
      *(_QWORD *)&v68->m_vecCentre.x = v67;
      v69 = v8->m_nNoOfSpheres + v65++;
      v70 = (char *)v8->_anon_1.m_pLineArray + i;
      v71 = *((_WORD *)v70 + 2);
      v72 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v69];
      v72->m_data.m_lighting = v70[6];
      *(_WORD *)&v72->m_data.m_nSurfaceType = v71;
      m_nNoOfLines = v8->_anon_0.m_nNoOfLines;
      if ( v65 >= m_nNoOfLines )
        break;
      LOWORD(v47) = v8->m_nNoOfSpheres;
    }
    if ( m_nNoOfLines < 1 )
    {
      v75 = 0;
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = colModelA->m_boxBound.m_vecMin.x;
      v77 = colModelA->m_boxBound.m_vecMin.y;
      v78 = colModelA->m_boxBound.m_vecMin.z;
      v79 = colModelA->m_boxBound.m_vecMax.x;
      v80 = colModelA->m_boxBound.m_vecMax.y;
      v81 = colModelA->m_boxBound.m_vecMax.z;
      v82 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v8->m_nNoOfSpheres].m_vecCentre.z;
      for ( j = 0; j < m_nNoOfLines; ++j )
      {
        v84 = v82[1];
        v85 = *(v82 - 2);
        if ( (float)(v85 + v84) >= v76 && (float)(v85 - v84) <= v79 )
        {
          v86 = *(v82 - 1);
          if ( (float)(v84 + v86) >= v77
            && (float)(v86 - v84) <= v80
            && (float)(v84 + *v82) >= v78
            && (float)(*v82 - v84) <= v81 )
          {
            ++v75;
            CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB[v74] = j;
            if ( v74 > 126 )
              break;
            ++v74;
          }
        }
        v82 += 5;
      }
    }
  }
  else
  {
    v75 = 0;
  }
  m_nNoOfBoxes = v8->m_nNoOfBoxes;
  if ( m_nNoOfBoxes < 1 )
  {
    v275 = 0;
  }
  else
  {
    v88 = 0;
    p_x = &v8->m_pBoxArray->m_vecMax.x;
    v275 = 0;
    do
    {
      if ( v22 >= *(p_x - 3) && v23 <= *p_x && v24 >= *(p_x - 2) && v25 <= p_x[1] && v26 >= *(p_x - 1) && v27 <= p_x[2] )
      {
        v90 = v275 <= 62;
        CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesB[v275++] = v88;
        if ( !v90 )
          break;
      }
      ++v88;
      p_x += 7;
    }
    while ( v88 < m_nNoOfBoxes );
  }
  CCollision::CalculateTrianglePlanes(v8);
  m_pTrianglePlaneArray = v8->m_pTrianglePlaneArray;
  if ( !v8->m_nNoOfTriangles )
    goto LABEL_103;
  v93 = *((_BYTE *)v8 + 7);
  if ( (v93 & 2) == 0 )
  {
    if ( v8->m_nNoOfTriangles >= 1 )
    {
      v94 = v8;
      v95 = 0;
      v96 = 0;
      fDistanceSqr = 0;
      do
      {
        if ( CCollision::TestSphereTriangle(&sphere, v94->m_pTriCompressedVectorArray, &v94->m_pTriangleArray[v95], v92) )
        {
          v94 = v8;
          v90 = fDistanceSqr <= 597;
          CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesB[fDistanceSqr++] = v96;
          if ( !v90 )
            goto LABEL_124;
        }
        else
        {
          v94 = v8;
        }
        ++v96;
        ++v95;
      }
      while ( v96 < v94->m_nNoOfTriangles );
      goto LABEL_124;
    }
LABEL_103:
    fDistanceSqr = 0;
    goto LABEL_124;
  }
  v97 = 0;
  fDistanceSqr = 0;
  if ( (*((_BYTE *)v8 + 7) & 2) == 0 )
    goto LABEL_123;
  while ( v97 < *v8->m_modelSec )
  {
    while ( 1 )
    {
      v98 = (int)&v8->m_modelSec[8 * ~v97 + 1 + v97];
      if ( v22 >= *(float *)v98
        && v23 <= *(float *)(v98 + 12)
        && v24 >= *(float *)(v98 + 4)
        && v25 <= *(float *)(v98 + 16)
        && v26 >= *(float *)(v98 + 8)
        && v27 <= *(float *)(v98 + 20) )
      {
        v100 = *(__int16 *)(v98 + 26);
        v99 = (__int16 *)(v98 + 26);
        v101 = *(v99 - 1);
        if ( v101 <= v100 )
        {
          v102 = v101 - 1;
          v103 = v101;
          do
          {
            ++v102;
            if ( CCollision::TestSphereTriangle(
                   &sphere,
                   v8->m_pTriCompressedVectorArray,
                   &v8->m_pTriangleArray[v103],
                   v92) )
            {
              v90 = fDistanceSqr <= 597;
              CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesB[fDistanceSqr++] = v102;
              if ( !v90 )
                break;
            }
            ++v103;
          }
          while ( v102 < *v99 );
          colModelA = v274;
          v93 = *((_BYTE *)v8 + 7);
        }
      }
      ++v97;
      if ( (v93 & 2) != 0 )
        break;
LABEL_123:
      if ( v97 >= 0 )
        goto LABEL_124;
    }
  }
LABEL_124:
  if ( !(v283 | v275 | fDistanceSqr) )
    return 0;
  v271 = v75;
  v104 = 0;
  aColPoints->m_fDepth = -1.0;
  if ( (int)v >= 1 )
  {
    v105 = 0;
    while ( 1 )
    {
      m_pSphereArray = v288->m_pSphereArray;
      lineCollision = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesA[(_DWORD)v105];
      v302.xx = 1.0e24;
      if ( v283 >= 1 )
      {
        v106 = &aColPoints[v104];
        v107 = 0;
        v108 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB;
        v109 = v283;
        v110 = v104;
        while ( 1 )
        {
          v111 = v8->m_nNoOfSpheres;
          v112 = *v108;
          if ( *v108 >= v111 )
          {
            v115 = *((unsigned __int8 *)v8 + 7) << 31 == 0;
            if ( *((unsigned __int8 *)v8 + 7) << 31 )
              v115 = v8->_anon_0.m_nNoOfLines == 0;
            if ( v115 )
              goto LABEL_136;
            v113 = (const CColSphere *)((char *)v8->_anon_1.m_pLineArray + 36 * (v112 - v111));
            v114 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesA[(_DWORD)v105];
          }
          else
          {
            v113 = &v8->m_pSphereArray[v112];
            v114 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesA[(_DWORD)v105];
          }
          v107 |= CCollision::ProcessSphereSphere(
                    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v114],
                    v113,
                    v106,
                    &v302.xx);
          v104 = v110;
LABEL_136:
          --v109;
          ++v108;
          if ( !v109 )
            goto LABEL_139;
        }
      }
      v107 = 0;
LABEL_139:
      p = v105;
      if ( v275 >= 1 )
      {
        v116 = v275;
        v117 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesB;
        v118 = &m_pSphereArray[lineCollision];
        p_m_data = &v118->m_data;
        p_m_nPieceType = &v118->m_data.m_nPieceType;
        do
        {
          v120 = v104;
          v121 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesA[(_DWORD)v105];
          v122 = &aColPoints[v104];
          if ( CCollision::ProcessSphereBox(
                 &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v121],
                 &v8->m_pBoxArray[*v117],
                 v122,
                 &v302.xx)
            && (v107 = 1,
                v123 = *(_WORD *)&p_m_data->m_nSurfaceType,
                v122->m_dataA.m_lighting = p_m_data->m_lighting,
                *(_WORD *)&v122->m_dataA.m_nSurfaceType = v123,
                bReturnAllCollisions) )
          {
            v104 = v120;
            if ( v120 <= 30 )
            {
              v105 = p;
              if ( *p_m_nPieceType <= 2u )
              {
                v104 = v120 + 1;
                v107 = 0;
                v302.xx = 1.0e24;
                aColPoints[v120 + 1].m_fDepth = -1.0;
              }
              goto LABEL_148;
            }
          }
          else
          {
            v104 = v120;
          }
          v105 = p;
LABEL_148:
          --v116;
          ++v117;
        }
        while ( v116 );
      }
      if ( fDistanceSqr >= 1 )
        break;
LABEL_160:
      if ( v107 << 31 )
      {
        v8 = pColData;
        colModelA = v274;
        if ( v104 > 30 )
          goto LABEL_165;
        aColPoints[++v104].m_fDepth = -1.0;
      }
      else
      {
        v8 = pColData;
        colModelA = v274;
      }
      v105 = (CColPoint *)((char *)v105 + 1);
      if ( (int)v105 >= (int)v )
        goto LABEL_165;
    }
    v124 = fDistanceSqr;
    v125 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesB;
    while ( 1 )
    {
      v126 = v104;
      v127 = CCollision::ProcessSphereTriangle(
               &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesA[(_DWORD)v105]],
               pColData->m_pTriCompressedVectorArray,
               &pColData->m_pTriangleArray[*v125],
               &pColData->m_pTrianglePlaneArray[*v125],
               (int)&aColPoints[v104],
               &v302.xx);
      v128 = v127 == 1;
      v107 |= v127;
      if ( v127 == 1 )
        v128 = bReturnAllCollisions == 1;
      if ( v128 )
      {
        v104 = v126;
        v107 = 1;
        if ( v126 <= 30 )
        {
          v105 = p;
          if ( m_pSphereArray[lineCollision].m_data.m_nPieceType <= 2u )
          {
            v104 = v126 + 1;
            v107 = 0;
            v302.xx = 1.0e24;
            aColPoints[v126 + 1].m_fDepth = -1.0;
          }
          goto LABEL_159;
        }
      }
      else
      {
        v104 = v126;
      }
      v105 = p;
LABEL_159:
      --v124;
      ++v125;
      if ( !v124 )
        goto LABEL_160;
    }
  }
LABEL_165:
  v129 = v288;
  v130 = v288->_anon_0.m_nNoOfLines;
  if ( !(*((unsigned __int8 *)v288 + 7) << 31) )
  {
    if ( v130 < 1 )
      goto LABEL_260;
    v131 = 0;
    v132 = 0;
    v285 = v104;
    do
    {
      operator*(
        (CVector *)&v302,
        &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
        &v288->_anon_1.m_pLineArray[v131].m_vecStart);
      v133 = *(_QWORD *)&v302.xx;
      v134 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA[v131];
      v134->m_vecStart.z = v302.zx;
      *(_QWORD *)&v134->m_vecStart.x = v133;
      operator*(
        (CVector *)&v302,
        &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
        &v288->_anon_1.m_pLineArray[v131].m_vecEnd);
      v135 = *(_QWORD *)&v302.xx;
      ++v131;
      ++v132;
      v134->m_vecEnd.z = v302.zx;
      *(_QWORD *)&v134->m_vecEnd.x = v135;
      v136 = v288->_anon_0.m_nNoOfLines;
    }
    while ( v132 < v136 );
    colModelA = v274;
    if ( (char)v136 < 1 )
      goto LABEL_211;
    v104 = v285;
    if ( (unsigned __int8)v136 > 3u )
    {
      v137 = aLineRatios;
      v151 = v136 & 0xFFFFFFFC;
      if ( (v136 & 0xFFFFFFFC) != 0 )
      {
        v152.n128_u64[0] = 0x400000004LL;
        v152.n128_u64[1] = 0x400000004LL;
        v153.n128_u64[0] = 0x100000000LL;
        v153.n128_u64[1] = 0x300000002LL;
        v154 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA;
        v155 = v136 & 0xFFFFFFFC;
        do
        {
          *(int32x4_t *)v154 = v153;
          v154 += 4;
          v153 = vaddq_s32(v153, v152);
          v155 -= 4;
        }
        while ( v155 );
        if ( v151 == v136 )
          goto LABEL_190;
        goto LABEL_189;
      }
    }
    else
    {
      v137 = aLineRatios;
    }
    v151 = 0;
    do
    {
LABEL_189:
      CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[v151] = v151;
      ++v151;
    }
    while ( v151 < v136 );
LABEL_190:
    if ( v151 - 1 >= 0 )
    {
      v156 = 0;
      pa = (CColPoint *)v151;
      do
      {
        CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[(_DWORD)v156] = 0;
        if ( v283 >= 1 )
        {
          v157 = v283;
          v158 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB;
          do
          {
            if ( CCollision::ProcessLineSphere(
                   &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   &pColData->m_pSphereArray[*v158],
                   &aLineColPoints[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   &v137[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]]) )
            {
              CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[(_DWORD)v156] = 1;
            }
            --v157;
            ++v158;
          }
          while ( v157 );
        }
        if ( v275 >= 1 )
        {
          v159 = v275;
          v160 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesB;
          do
          {
            if ( CCollision::ProcessLineBox(
                   &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   &pColData->m_pBoxArray[*v160],
                   &aLineColPoints[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   &v137[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]]) )
            {
              CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[(_DWORD)v156] = 1;
            }
            --v159;
            ++v160;
          }
          while ( v159 );
        }
        if ( fDistanceSqr >= 1 )
        {
          v161 = fDistanceSqr;
          v162 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesB;
          do
          {
            if ( CCollision::ProcessLineTriangle(
                   &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   pColData->m_pTriCompressedVectorArray,
                   &pColData->m_pTriangleArray[*v162],
                   &pColData->m_pTrianglePlaneArray[*v162],
                   &aLineColPoints[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   &aLineRatios[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]],
                   0) == 1 )
              CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[(_DWORD)v156] = 1;
            --v161;
            ++v162;
          }
          while ( v161 );
        }
        if ( CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[(_DWORD)v156] )
        {
          v163 = &aLineColPoints[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]];
          operator*((CVector *)&v302, m2, &v163->m_vecPosition);
          v164 = *(_QWORD *)&v302.xx;
          v163->m_vecPosition.z = v302.zx;
          *(_QWORD *)&v163->m_vecPosition.x = v164;
          v165 = &aLineColPoints[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLineIndicesA[(_DWORD)v156]];
          Multiply3x3((CVector *)&v302, m2, &v165->m_vecNormal);
          v166 = *(_QWORD *)&v302.xx;
          v165->m_vecNormal.z = v302.zx;
          *(_QWORD *)&v165->m_vecNormal.x = v166;
        }
        v156 = (CColPoint *)((char *)v156 + 1);
        v137 = aLineRatios;
      }
      while ( v156 != pa );
      v129 = v288;
      colModelA = v274;
      goto LABEL_211;
    }
    v129 = v288;
    colModelA = v274;
    goto LABEL_260;
  }
  if ( v130 >= 1 )
  {
    v139 = 0;
    v140 = 8;
    do
    {
      v141 = aLineRatios[v139++];
      *(float *)((char *)&v288->_anon_1.m_pLineArray->m_vecStart.x + v140) = v141;
      v140 += 36;
      v142 = v288->_anon_0.m_nNoOfLines;
    }
    while ( v139 < v142 );
    if ( v142 >= 1 )
    {
      v143 = 0;
      v144 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA;
      v145 = 12;
      v285 = v104;
      do
      {
        v144->m_fRadius = *(float *)((char *)&v288->_anon_1.m_pLineArray->m_vecStart.x + v145);
        operator*(
          (CVector *)&v302,
          &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB,
          (const CVector *)((char *)v288->_anon_1.m_pLineArray + v145 - 12));
        v146 = *(_QWORD *)&v302.xx;
        ++v143;
        v144->m_vecCentre.z = v302.zx;
        *(_QWORD *)&v144->m_vecCentre.x = v146;
        v147 = (int)v288->_anon_1.m_pLineArray + v145;
        v145 += 36;
        v148 = *(_BYTE *)(v147 + 6);
        LOWORD(v147) = *(_WORD *)(v147 + 4);
        v144->m_data.m_lighting = v148;
        *(_WORD *)&v144->m_data.m_nSurfaceType = v147;
        ++v144;
        v149 = v288->_anon_0.m_nNoOfLines;
      }
      while ( v143 < v149 );
      if ( v149 < 1 )
      {
LABEL_211:
        v104 = v285;
        goto LABEL_260;
      }
      v104 = v285;
      v150 = 0;
      do
      {
        v205 = &aColPoints[v104];
        CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[v150] = 0;
        v205->m_fDepth = -1.0;
        p_m_fDepth = &v205->m_fDepth;
        v186 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150];
        m_fRadius = v186->m_fRadius;
        if ( (float)(v186->m_vecCentre.x + m_fRadius) >= v292->m_boxBound.m_vecMin.x
          && (float)(v186->m_vecCentre.x - m_fRadius) <= v292->m_boxBound.m_vecMax.x
          && (pb = &aColPoints[v104],
              v208 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150].m_vecCentre.y,
              (float)(m_fRadius + v208) >= v292->m_boxBound.m_vecMin.y)
          && (float)(v208 - m_fRadius) <= v292->m_boxBound.m_vecMax.y
          && (v209 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150].m_vecCentre.z,
              (float)(m_fRadius + v209) >= v292->m_boxBound.m_vecMin.z)
          && (float)(v209 - m_fRadius) <= v292->m_boxBound.m_vecMax.z )
        {
          v286 = v104;
          lineCollisiona = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aCollided[v150];
          m_pLineArray = v129->_anon_1.m_pLineArray;
          lineRatio = 1.0e24;
          if ( v283 >= 1 )
          {
            v167 = v283;
            v168 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB;
            v269 = &aLineColPoints[v150];
            v280 = &aLineRatios[v150];
            do
            {
              if ( CCollision::ProcessSphereSphere(
                     &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150],
                     &pColData->m_pSphereArray[*v168],
                     pb,
                     &lineRatio) )
              {
                operator*(
                  (CVector *)&v302,
                  &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
                  &pb->m_vecPosition);
                v169.n64_u64[0] = *(unsigned __int64 *)&v302.xx;
                zx = v302.zx;
                Multiply3x3(
                  (CVector *)&v302,
                  &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
                  &pb->m_vecNormal);
                v171 = (float32x2_t *)((char *)v288->_anon_1.m_pLineArray + 36 * v150);
                v172.n64_u64[0] = vsub_f32(v169, (float32x2_t)v171->n64_u64[0]).n64_u64[0];
                v173 = vmul_f32(v172, v172).n64_u64[0];
                v174 = zx
                     + sqrtf(
                         (float)((float)(v171[1].n64_f32[1] * v171[1].n64_f32[1]) - *((float *)&v173 + 1))
                       - *(float *)&v173);
                if ( v174 >= *v280 )
                {
                  *lineCollisiona = 1;
                  *v280 = v174;
                  CColPoint::operator=(v269, pb);
                  v269->m_fDepth = *p_m_fDepth;
                  v175 = *((_WORD *)&m_pLineArray->m_vecEnd.x + 18 * v150);
                  v269->m_dataA.m_lighting = *((_BYTE *)&m_pLineArray->m_vecEnd.x + 36 * v150 + 2);
                  *(_WORD *)&v269->m_dataA.m_nSurfaceType = v175;
                }
                lineRatio = 1.0e24;
              }
              --v167;
              ++v168;
            }
            while ( v167 );
          }
          if ( v275 < 1 )
          {
            v281 = 0;
          }
          else
          {
            v176 = 1.0e24;
            v177 = v275;
            v178 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesB;
            v266 = &aLineColPoints[v150];
            p_m_dataA = &pb->m_dataA;
            v270 = (CColPoint *)&aLineRatios[v150];
            v268 = (__int16 *)(&m_pLineArray->m_vecEnd + 3 * v150);
            v281 = 0;
            do
            {
              if ( CCollision::ProcessSphereBox(v186, &pColData->m_pBoxArray[*v178], pb, &lineRatio) )
              {
                operator*(
                  (CVector *)&v302,
                  &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
                  &pb->m_vecPosition);
                v179.n64_u64[0] = *(unsigned __int64 *)&v302.xx;
                v180 = v302.zx;
                Multiply3x3(
                  (CVector *)&v302,
                  &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
                  &pb->m_vecNormal);
                if ( v302.zx <= 0.5
                  || (v181 = (float32x2_t *)((char *)v288->_anon_1.m_pLineArray + 36 * v150), v180 >= v181[1].n64_f32[0]) )
                {
                  v186 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150];
                  if ( lineRatio < v176 )
                  {
                    v176 = lineRatio;
                    v187 = *v268;
                    pb->m_dataA.m_lighting = *((_BYTE *)&m_pLineArray->m_vecEnd.x + 36 * v150 + 2);
                    *(_WORD *)&p_m_dataA->m_nSurfaceType = v187;
                    v281 = 1;
                  }
                }
                else
                {
                  v182.n64_u64[0] = vsub_f32(v179, (float32x2_t)v181->n64_u64[0]).n64_u64[0];
                  v183 = v181[1].n64_f32[1];
                  v184 = vmul_f32(v182, v182).n64_u64[0];
                  v185 = v180 + sqrtf((float)((float)(v183 * v183) - *((float *)&v184 + 1)) - *(float *)&v184);
                  if ( v185 >= v270->m_vecPosition.x )
                  {
                    v186 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150];
                    if ( (float)(v185 - v270->m_vecPosition.x) > (float)(v183 * 0.35) )
                    {
                      v176 = lineRatio;
                      v188 = *v268;
                      pb->m_dataA.m_lighting = *((_BYTE *)&m_pLineArray->m_vecEnd.x + 36 * v150 + 2);
                      *(_WORD *)&p_m_dataA->m_nSurfaceType = v188;
                      v281 = 1;
                    }
                    *lineCollisiona = 1;
                    v270->m_vecPosition.x = v185;
                    CColPoint::operator=(v266, pb);
                    v266->m_fDepth = *p_m_fDepth;
                    v189 = *v268;
                    v266->m_dataA.m_lighting = *((_BYTE *)&m_pLineArray->m_vecEnd.x + 36 * v150 + 2);
                    *(_WORD *)&v266->m_dataA.m_nSurfaceType = v189;
                  }
                  else
                  {
                    v186 = &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA[v150];
                  }
                }
              }
              --v177;
              ++v178;
              lineRatio = 1.0e24;
            }
            while ( v177 );
          }
          v190 = *(_QWORD *)&pb->m_vecPosition.x;
          v191 = *(_QWORD *)&pb->m_vecPosition.z;
          v192 = *(_QWORD *)&pb->m_vecNormal.x;
          v193 = *(_QWORD *)&pb->m_vecNormal.z;
          v194 = *(_QWORD *)&pb->m_dataB.m_nPieceType;
          *(_QWORD *)&v302.pad2 = *(_QWORD *)&pb->pad2;
          *(_QWORD *)&v302.yz = v194;
          *(_QWORD *)&v302.xx = v190;
          *(_QWORD *)&v302.zx = v191;
          *(_QWORD *)&v302.xy = v192;
          *(_QWORD *)&v302.zy = v193;
          if ( fDistanceSqr < 1 )
          {
            v200 = aLineRatios;
          }
          else
          {
            v195 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesB;
            v196 = fDistanceSqr;
            do
            {
              v302.zz = -1.0;
              if ( CCollision::ProcessSphereTriangle(
                     v186,
                     pColData->m_pTriCompressedVectorArray,
                     &pColData->m_pTriangleArray[*v195],
                     &pColData->m_pTrianglePlaneArray[*v195],
                     (int)&v302,
                     &lineRatio) == 1 )
              {
                v197 = &m_pTrianglePlaneArray[*v195];
                v198 = v197->m_compressedNormal.z;
                if ( v198 > 0.3 && m2->zz > 0.9 )
                {
                  *(RwReal *)&v199 = m_pTrianglePlaneArray[*v195].m_compressedNormal.x;
                  HIDWORD(v199) = LODWORD(v197->m_compressedNormal.y);
                  *(_QWORD *)&v302.xy = v199;
                  v302.zy = v198;
                }
                v281 |= ProcessDiscCollision(
                          (CColPoint *)&v302,
                          &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
                          (const CColDisk *)v288->_anon_1.m_pLineArray + v150,
                          pb,
                          lineCollisiona,
                          &aLineRatios[v150],
                          &aLineColPoints[v150]);
              }
              v200 = aLineRatios;
              --v196;
              ++v195;
            }
            while ( v196 );
          }
          v104 = v286;
          if ( v286 > 30 )
          {
            v129 = v288;
            colModelA = v274;
          }
          else
          {
            v129 = v288;
            colModelA = v274;
            if ( v281 << 31 )
            {
              v104 = v286 + 1;
              aColPoints[v286 + 1].m_fDepth = -1.0;
            }
          }
          if ( *lineCollisiona )
          {
            v201 = &aLineColPoints[v150];
            v202 = v104;
            operator*(&v299, m2, &v201->m_vecPosition);
            v203 = *(_QWORD *)&v299.x;
            v201->m_vecPosition.z = v299.z;
            *(_QWORD *)&v201->m_vecPosition.x = v203;
            Multiply3x3(&v299, m2, &v201->m_vecNormal);
            v204 = *(_QWORD *)&v299.x;
            v104 = v202;
            v201->m_vecNormal.z = v299.z;
            *(_QWORD *)&v201->m_vecNormal.x = v204;
          }
          else
          {
            v200[v150] = -100000000.0;
          }
        }
        else
        {
          colModelA = v274;
        }
        ++v150;
      }
      while ( v150 < v129->_anon_0.m_nNoOfLines );
    }
  }
LABEL_260:
  v210 = v104;
  if ( v104 >= 1 )
  {
    v211 = aColPoints;
    v212 = v104;
    do
    {
      operator*((CVector *)&v302, m2, &v211->m_vecPosition);
      v213 = *(_QWORD *)&v302.xx;
      v211->m_vecPosition.z = v302.zx;
      *(_QWORD *)&v211->m_vecPosition.x = v213;
      Multiply3x3((CVector *)&v302, m2, &v211->m_vecNormal);
      v214 = *(_QWORD *)&v302.xx;
      --v212;
      v211->m_vecNormal.z = v302.zx;
      *(_QWORD *)&v211->m_vecNormal.x = v214;
      ++v211;
    }
    while ( v212 );
  }
  if ( v283 < 1 || !*(_DWORD *)&v129->m_nNoOfBoxes )
    return v210;
  v215 = v292->m_sphereBound.m_fRadius;
  v302.pad1 = v215;
  operator*(
    &v299,
    &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA,
    &v292->m_sphereBound.m_vecCentre);
  v302.zx = v299.z;
  *(_QWORD *)&v302.xx = *(_QWORD *)&v299.x;
  m_nNoOfTriangles = v129->m_nNoOfTriangles;
  if ( m_nNoOfTriangles )
  {
    v218 = colModelA->m_pColData;
    if ( v218 )
    {
      CCollision::CalculateTrianglePlanes(v218);
      m_nNoOfTriangles = v129->m_nNoOfTriangles;
    }
    if ( m_nNoOfTriangles >= 1 )
    {
      v219 = v288;
      v220 = 0;
      v221 = 0;
      m2a = 0;
      do
      {
        if ( CCollision::TestSphereTriangle(
               (const CColSphere *)&v302,
               v219->m_pTriCompressedVectorArray,
               &v219->m_pTriangleArray[v220],
               v216) )
        {
          v219 = v288;
          v90 = m2a <= 597;
          CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesA[m2a++] = v221;
          if ( !v90 )
            goto LABEL_280;
        }
        else
        {
          v219 = v288;
        }
        ++v221;
        ++v220;
      }
      while ( v221 < v219->m_nNoOfTriangles );
      goto LABEL_280;
    }
    v219 = v288;
  }
  else
  {
    v219 = v129;
  }
  m2a = 0;
LABEL_280:
  v222 = v219->m_nNoOfBoxes;
  v223 = v219;
  if ( v222 < 1 )
  {
    v19 = v210;
    pc = 0;
    v230 = m2a;
  }
  else
  {
    v224 = v302.xx - v215;
    v225 = v302.yx - v215;
    m_pBoxArray = v219->m_pBoxArray;
    v227 = v302.zx - v215;
    v228 = v302.zx + v215;
    pc = 0;
    v229 = v302.yx + v215;
    v230 = m2a;
    v231 = v302.xx + v215;
    v232 = &m_pBoxArray->m_vecMax.x;
    v233 = 0;
    v19 = v210;
    do
    {
      if ( v231 >= *(v232 - 3)
        && v224 <= *v232
        && v229 >= *(v232 - 2)
        && v225 <= v232[1]
        && v228 >= *(v232 - 1)
        && v227 <= v232[2] )
      {
        CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesA[(_DWORD)pc] = v233;
        pc = (CColPoint *)((char *)pc + 1);
      }
      ++v233;
      v232 += 7;
    }
    while ( v233 < v222 );
  }
  if ( v230 )
  {
    aColPoints[v19].m_fDepth = -1.0;
    v234 = v283;
    if ( v283 - v271 < 1 )
    {
      v293 = 0;
    }
    else
    {
      v235 = 0;
      v236 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB;
      v293 = 0;
      do
      {
        v299.x = 1.0e24;
        if ( v230 >= 1 )
        {
          v237 = &aColPoints[v19];
          v238 = 0;
          v239 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aTriangleIndicesA;
          v240 = v230;
          v287 = v19;
          do
          {
            v241 = *v239++;
            v242 = v236;
            v238 |= CCollision::ProcessSphereTriangle(
                      &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v236[v235]],
                      v288->m_pTriCompressedVectorArray,
                      &v288->m_pTriangleArray[v241],
                      &v288->m_pTrianglePlaneArray[v241],
                      (int)v237,
                      &v299.x);
            --v240;
            v236 = v242;
          }
          while ( v240 );
          if ( v238 << 31 )
          {
            v243 = -v237->m_vecNormal.y;
            v244 = -v237->m_vecNormal.z;
            v237->m_vecNormal.x = -v237->m_vecNormal.x;
            v237->m_vecNormal.y = v243;
            v237->m_vecNormal.z = v244;
            v19 = v287;
            v223 = v288;
            if ( v287 > 30 )
              goto LABEL_306;
            v19 = v287 + 1;
            aColPoints[v287 + 1].m_fDepth = -1.0;
            ++v293;
            v234 = v283;
          }
          else
          {
            v234 = v283;
            v19 = v287;
            v223 = v288;
          }
          v230 = m2a;
        }
        ++v235;
      }
      while ( v235 < v283 - v271 );
    }
  }
  else
  {
    v293 = 0;
LABEL_306:
    v234 = v283;
  }
  if ( pc )
  {
    m2b = (CMatrix *)(v234 - v271);
    if ( v234 - v271 >= 1 )
    {
      v245 = 0;
      do
      {
        v299.x = 1.0e24;
        if ( (int)pc >= 1 )
        {
          v246 = 0;
          v247 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB[(_DWORD)v245];
          v248 = (int)&pColData->m_pSphereArray[v247].m_data;
          while ( 1 )
          {
            v249 = &aColPoints[v19];
            if ( CCollision::ProcessSphereBox(
                   &CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB[v247],
                   &v223->m_pBoxArray[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesA[v246]],
                   v249,
                   &v299.x) )
            {
              v250 = -v249->m_vecNormal.x;
              v251 = -v249->m_vecNormal.y;
              v252 = -v249->m_vecNormal.z;
              v253 = (int)&v223->m_pBoxArray[CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aBoxIndicesA[v246]];
              v254 = *(_WORD *)(v253 + 24);
              v249->m_dataA.m_lighting = *(_BYTE *)(v253 + 26);
              *(_WORD *)&v249->m_dataA.m_nSurfaceType = v254;
              v255 = *(_WORD *)v248;
              v249->m_dataB.m_lighting = *(_BYTE *)(v248 + 2);
              *(_WORD *)&v249->m_dataB.m_nSurfaceType = v255;
              v249->m_vecNormal.x = v250;
              v249->m_vecNormal.y = v251;
              v249->m_vecNormal.z = v252;
              if ( v19 > 30 )
                break;
              aColPoints[++v19].m_fDepth = -1.0;
              ++v293;
            }
            if ( ++v246 >= (int)pc )
              break;
            v247 = CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSphereIndicesB[(_DWORD)v245];
          }
        }
        v245 = (CMatrix *)((char *)v245 + 1);
      }
      while ( v245 != m2b );
    }
  }
  if ( v293 >= 1 )
  {
    v256 = v19 - v293;
    v257 = &aColPoints[v19 - v293];
    do
    {
      operator*((CVector *)&v302, m, &v257->m_vecPosition);
      v258 = *(_QWORD *)&v302.xx;
      v257->m_vecPosition.z = v302.zx;
      *(_QWORD *)&v257->m_vecPosition.x = v258;
      Multiply3x3((CVector *)&v302, m, &v257->m_vecNormal);
      v259 = *(_QWORD *)&v302.xx;
      ++v256;
      v257->m_vecNormal.z = v302.zx;
      *(_QWORD *)&v257->m_vecNormal.x = v259;
      v261 = *(_WORD *)&v257->m_dataB.m_nSurfaceType;
      p_m_dataB = &v257->m_dataB;
      m_lighting = p_m_dataB->m_lighting;
      v263 = p_m_dataB - 1;
      v264 = p_m_dataB[-1].m_lighting;
      *(_WORD *)&p_m_dataB->m_nSurfaceType = *(_WORD *)&p_m_dataB[-1].m_nSurfaceType;
      *(_WORD *)&v263->m_nSurfaceType = v261;
      v263->m_lighting = m_lighting;
      p_m_dataB->m_lighting = v264;
      v257 = (CColPoint *)&p_m_dataB[3];
    }
    while ( v256 < v19 );
  }
  return v19;
}
// 2DD2DE: variable 'v8' is possibly undefined
// 2DD770: variable 'v92' is possibly undefined
// 2DE500: variable 'v216' is possibly undefined
// 793AF8: using guessed type char `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresA;
// 7944FC: using guessed type char `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aSpheresB;
// 794700: using guessed type char `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::aLinesA;
// 79605C: using guessed type char `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matAB;
// 7960A8: using guessed type char `guard variable for'CCollision::ProcessColModels(CMatrix const&,CColModel &,CMatrix const&,CColModel &,CColPoint *,CColPoint *,float *,bool)::matBA;

//----- (002DE954) --------------------------------------------------------
void __fastcall CCollision::GetBoundingBoxFromTwoSpheres(CColBox *pBox, CColSphere *pA, CColSphere *pB)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d2
  CColSphere *v5; // r3
  float m_fRadius; // s2
  bool v7; // nf
  RwReal *p_y; // r3
  RwReal *p_z; // r1

  v3.n64_u32[0] = LODWORD(pA->m_vecCentre.x);
  v5 = pA;
  v4.n64_u32[0] = LODWORD(pB->m_vecCentre.x);
  m_fRadius = pA->m_fRadius;
  v7 = pA->m_vecCentre.x < pB->m_vecCentre.x;
  pBox->m_vecMin.x = vmin_f32(v3, v4).n64_f32[0] - m_fRadius;
  if ( v7 )
    v5 = pB;
  v3.n64_u32[0] = LODWORD(v5->m_vecCentre.x);
  p_y = &pA->m_vecCentre.y;
  pBox->m_vecMax.x = m_fRadius + v3.n64_f32[0];
  v3.n64_u32[0] = LODWORD(pB->m_vecCentre.y);
  v4.n64_u32[0] = LODWORD(pA->m_vecCentre.y);
  pBox->m_vecMin.y = vmin_f32(v4, v3).n64_f32[0] - m_fRadius;
  if ( v4.n64_f32[0] < v3.n64_f32[0] )
    p_y = &pB->m_vecCentre.y;
  pBox->m_vecMax.y = m_fRadius + *p_y;
  v4.n64_u32[0] = LODWORD(pA->m_vecCentre.z);
  p_z = &pA->m_vecCentre.z;
  v3.n64_u32[0] = LODWORD(pB->m_vecCentre.z);
  pBox->m_vecMin.z = vmin_f32(v4, v3).n64_f32[0] - m_fRadius;
  if ( v4.n64_f32[0] < v3.n64_f32[0] )
    p_z = &pB->m_vecCentre.z;
  pBox->m_vecMax.z = m_fRadius + *p_z;
}
// 2DE96A: variable 'v3' is possibly undefined
// 2DE96A: variable 'v4' is possibly undefined

//----- (002DE9E8) --------------------------------------------------------
int __fastcall CCollision::CheckCameraCollisionBuildings(
        int32 X,
        int32 Y,
        CColBox *pBox,
        CColSphere *pSph,
        CColSphere *pA,
        CColSphere *pB)
{
  int v6; // r8
  CPtrNode *m_pHead; // r9
  CVehicle *PlayerVehicle; // r0
  CEntity *m_pVoid; // r5
  float m_fRadius; // r6
  float32x2_t v12; // d16
  unsigned __int64 v13; // d2
  int v15; // [sp+20h] [bp-40h]
  CVector v16; // [sp+24h] [bp-3Ch] BYREF
  CColSphere v17; // [sp+30h] [bp-30h] BYREF

  v6 = 0;
  if ( X <= 0 )
    X = 0;
  if ( X >= 119 )
    X = 119;
  if ( Y <= 0 )
    Y = 0;
  if ( Y >= 119 )
    Y = 119;
  m_pHead = CWorld::ms_aSectors[120 * Y + X].m_buildingPtrListArray.m_pHead;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( PlayerVehicle )
    v6 = *((_BYTE *)&PlayerVehicle->m_nPhysicalFlags + 3) & 1;
  if ( m_pHead )
  {
    v15 = 0;
    do
    {
      m_pVoid = (CEntity *)m_pHead->m_pVoid;
      if ( *((unsigned __int16 *)m_pHead->m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        m_pVoid->m_nScanCode = CWorld::ms_nCurrentScanCode;
        if ( (!v6 || !CEntity::DoesNotCollideWithFlyers(m_pVoid)) && CWorld::pIgnoreEntity != m_pVoid )
        {
          m_fRadius = CModelInfo::ms_modelInfoPtrs[m_pVoid->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
          CEntity::GetBoundCentre(&v16, m_pVoid);
          CColSphere::Set(&v17, m_fRadius, &v16, 0, 0, 0xFFu);
          v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&pSph->m_vecCentre.y, *(float32x2_t *)&v17.m_vecCentre.y).n64_u64[0];
          v13 = vmul_f32(v12, v12).n64_u64[0];
          if ( (float)((float)((float)((float)(pSph->m_vecCentre.x - v17.m_vecCentre.x)
                                     * (float)(pSph->m_vecCentre.x - v17.m_vecCentre.x))
                             + *(float *)&v13)
                     + *((float *)&v13 + 1)) < (float)((float)(pSph->m_fRadius + v17.m_fRadius)
                                                     * (float)(pSph->m_fRadius + v17.m_fRadius)) )
            v15 |= CCollision::SphereCastVsEntity(pA, pB, m_pVoid);
        }
      }
      m_pHead = m_pHead->m_pNext;
    }
    while ( m_pHead );
  }
  else
  {
    LOBYTE(v15) = 0;
  }
  return v15 & 1;
}

//----- (002DEB50) --------------------------------------------------------
bool __fastcall CCollision::SphereCastVsEntity(CColSphere *pA, CColSphere *pB, CEntity *pEntity)
{
  int v6; // r10
  CMatrix *m_pMat; // r0
  CColModel *ColModel; // r0
  CColModel *v10; // r9
  CCollisionData *m_pColData; // r5
  const CColLine *v12; // r0
  int v13; // r11
  int m_nNoOfSpheres; // r5
  CColCacheEntry *v15; // r0
  bool v16; // zf
  CEntity *v17; // r1
  int32 v18; // r0
  int v19; // r10
  _BOOL4 v20; // r0
  CCollisionData *v21; // r0
  CCollisionData *v22; // r2
  int m_nNoOfTriangles; // r1
  char v24; // r0
  int v25; // r9
  int v26; // r11
  CColTriangle *v27; // r6
  CColTrianglePlane *v28; // r5
  int v29; // r1
  CColCacheEntry *v30; // r0
  CEntity *v31; // r2
  int32 v32; // r0
  CColCacheEntry *v33; // r0
  CEntity *v34; // r1
  int32 v35; // r0
  int32 i; // r5
  int32 v37; // r0
  int v38; // r6
  const CColLine *v39; // r0
  int v40; // r11
  __int16 *v41; // r6
  int v42; // t1
  int v43; // r0
  uint16 v44; // r4
  int v45; // r10
  CColTriangle *v46; // r5
  CColTrianglePlane *v47; // r9
  CColCacheEntry *v48; // r0
  CEntity *v49; // r1
  int32 v50; // r0
  CColCacheEntry *v51; // r0
  CEntity *v52; // r1
  int32 v53; // r0
  int v54; // r11
  int m_nNoOfBoxes; // r6
  CColCacheEntry *v56; // r0
  CEntity *v57; // r1
  int32 v58; // r0
  int v59; // r10
  __int64 *v60; // r0
  __int64 v61; // d16
  __int64 v62; // d17
  __int64 v63; // d19
  const CColLine *v64; // r0
  CColTriangle *m_pTriangleArray; // [sp+Ch] [bp-11Ch]
  CColTrianglePlane *m_pTrianglePlaneArray; // [sp+10h] [bp-118h]
  int32 v67; // [sp+20h] [bp-108h]
  CColCacheEntry *v68; // [sp+2Ch] [bp-FCh]
  CEntity *v69; // [sp+30h] [bp-F8h]
  int v70; // [sp+34h] [bp-F4h]
  CollisionVector *pVerts; // [sp+38h] [bp-F0h]
  CCollisionData *v72; // [sp+3Ch] [bp-ECh]
  CVector vecCentre; // [sp+40h] [bp-E8h] BYREF
  CColLine v74; // [sp+50h] [bp-D8h] BYREF
  CColLine v75; // [sp+70h] [bp-B8h] BYREF
  CMatrix output; // [sp+90h] [bp-98h] BYREF
  CColSphere vecEnd; // [sp+D8h] [bp-50h] BYREF
  CColSphere vecStart[3]; // [sp+ECh] [bp-3Ch] BYREF

  if ( *(_BYTE *)&pEntity->m_nFlags << 31 && !CCamera::IsExtraEntityToIgnore(&TheCamera, pEntity) )
  {
    m_pMat = pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    LOBYTE(v6) = 0;
    output.m_pRwMat = 0;
    output.m_owner = 0;
    Invert(m_pMat, &output);
    CColLine::CColLine(&v75, &pA->m_vecCentre, &pB->m_vecCentre);
    operator*(&vecStart[0].m_vecCentre, &output, &v75.m_vecStart);
    operator*(&vecEnd.m_vecCentre, &output, &v75.m_vecEnd);
    CColLine::CColLine(&v74, &vecStart[0].m_vecCentre, &vecEnd.m_vecCentre);
    vecCentre = v74.m_vecStart;
    CColSphere::Set(vecStart, pA->m_fRadius, &vecCentre, 0, 0, 0xFFu);
    vecCentre = v74.m_vecEnd;
    CColSphere::Set(&vecEnd, pA->m_fRadius, &vecCentre, 0, 0, 0xFFu);
    CMatrix::~CMatrix(&output);
    ColModel = CEntity::GetColModel(pEntity);
    v10 = ColModel;
    m_pColData = ColModel->m_pColData;
    if ( m_pColData )
    {
      CColBox::Set((CColBox *)&v74, &ColModel->m_boxBound.m_vecMin, &ColModel->m_boxBound.m_vecMax, 0, 0, 0xFFu);
      v75.m_vecEnd.z = v74.m_vecEnd.z;
      v75.m_vecStart.y = v74.m_vecStart.y - vecStart[0].m_fRadius;
      v75.m_vecEnd.x = vecStart[0].m_fRadius + v74.m_vecEnd.x;
      v75.m_vecStart.x = v74.m_vecStart.x - vecStart[0].m_fRadius;
      v75.m_vecStart.z = v74.m_vecStart.z - vecStart[0].m_fRadius;
      *(float *)&v75.m_pad = vecStart[0].m_fRadius + *(float *)&v74.m_pad;
      v75.m_vecEnd.y = vecStart[0].m_fRadius + v74.m_vecEnd.y;
      CColLine::CColLine((CColLine *)&output, &vecStart[0].m_vecCentre, &vecEnd.m_vecCentre);
      if ( CCollision::TestLineBox_DW(v12, (const CBox *)&v75) )
      {
        v13 = 0;
        v69 = pEntity;
        v72 = m_pColData;
        m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
        v68 = gpColCache;
LABEL_14:
        v19 = 20 * m_nNoOfSpheres - 20;
        while ( m_nNoOfSpheres >= 1 )
        {
          --m_nNoOfSpheres;
          v20 = CCollision::SphereCastVsSphere(vecStart, &vecEnd, (CColSphere *)((char *)v72->m_pSphereArray + v19));
          v19 -= 20;
          if ( v20 )
          {
            if ( gNumColCacheEntries > 98 )
            {
LABEL_71:
              LOBYTE(v6) = 1;
              return v6 & 1;
            }
            v15 = &v68[gNumColCacheEntries];
            v15->type = 0;
            v16 = v13 << 31 == 0;
            v13 = 1;
            v17 = pEntity;
            if ( !v16 )
              v17 = 0;
            v15->pEnt = v17;
            v18 = gNumColCacheEntries++;
            v68[v18].type = 2;
            v68[v18].sphId = m_nNoOfSpheres;
            goto LABEL_14;
          }
        }
        v21 = v10->m_pColData;
        v70 = (unsigned __int8)gbTryDoubleSidedCollision;
        if ( v21 )
          CCollision::CalculateTrianglePlanes(v21);
        v22 = v72;
        v6 = v13;
        m_nNoOfTriangles = v72->m_nNoOfTriangles;
        if ( v72->m_nNoOfTriangles )
        {
          pVerts = v72->m_pTriCompressedVectorArray;
          m_pTriangleArray = v72->m_pTriangleArray;
          m_pTrianglePlaneArray = v72->m_pTrianglePlaneArray;
          v24 = *((_BYTE *)v72 + 7);
          if ( (v24 & 2) != 0 )
          {
            for ( i = 0; ; i = v67 + 1 )
            {
              v37 = (v24 & 2) != 0 ? *v22->m_modelSec : 0;
              if ( i >= v37 )
                break;
              v38 = (int)&v22->m_modelSec[8 * ~i + 1 + i];
              CColBox::Set((CColBox *)&v74, (const CVector *)v38, (const CVector *)(v38 + 12), 0, 0, 0xFFu);
              v75.m_vecEnd.z = v74.m_vecEnd.z;
              v75.m_vecStart.y = v74.m_vecStart.y - vecStart[0].m_fRadius;
              v75.m_vecEnd.x = vecStart[0].m_fRadius + v74.m_vecEnd.x;
              v75.m_vecStart.x = v74.m_vecStart.x - vecStart[0].m_fRadius;
              v75.m_vecStart.z = v74.m_vecStart.z - vecStart[0].m_fRadius;
              *(float *)&v75.m_pad = vecStart[0].m_fRadius + *(float *)&v74.m_pad;
              v75.m_vecEnd.y = vecStart[0].m_fRadius + v74.m_vecEnd.y;
              CColLine::CColLine((CColLine *)&output, &vecStart[0].m_vecCentre, &vecEnd.m_vecCentre);
              v40 = v6;
              v67 = i;
              if ( CCollision::TestLineBox_DW(v39, (const CBox *)&v75) )
              {
                v42 = *(__int16 *)(v38 + 26);
                v41 = (__int16 *)(v38 + 26);
                v43 = *(v41 - 1);
                if ( v43 <= v42 )
                {
                  v44 = -1 - v43;
                  v45 = v43 - 1;
                  v46 = &m_pTriangleArray[v43];
                  v47 = &m_pTrianglePlaneArray[v43];
                  do
                  {
                    ++v45;
                    if ( CCollision::SphereCastVersusVsPoly(vecStart, &vecEnd, v46, v47, pVerts) )
                    {
                      if ( gNumColCacheEntries > 98 )
                        goto LABEL_71;
                      v48 = &v68[gNumColCacheEntries];
                      v48->type = 0;
                      v16 = v40 << 31 == 0;
                      v40 = 1;
                      v49 = v69;
                      if ( !v16 )
                        v49 = 0;
                      v48->pEnt = v49;
                      v50 = gNumColCacheEntries++;
                      v68[v50].type = 1;
                      v68[v50].triId = v45;
                    }
                    if ( v70 == 1
                      && fabsf(v47->m_compressedNormal.z) < 0.05
                      && CCollision::SphereCastVersusVsPoly(&vecEnd, vecStart, v46, v47, pVerts) )
                    {
                      if ( gNumColCacheEntries > 98 )
                        goto LABEL_71;
                      v51 = &v68[gNumColCacheEntries];
                      v51->type = 0;
                      v16 = v40 << 31 == 0;
                      v40 = 1;
                      v52 = v69;
                      if ( !v16 )
                        v52 = 0;
                      v51->pEnt = v52;
                      v53 = gNumColCacheEntries++;
                      v68[v53].type = 1;
                      v68[v53].triId = v44;
                    }
                    --v44;
                    ++v47;
                    ++v46;
                  }
                  while ( v45 < *v41 );
                }
              }
              v22 = v72;
              v6 = v40;
              v24 = *((_BYTE *)v72 + 7);
            }
          }
          else if ( m_nNoOfTriangles >= 1 )
          {
            v25 = m_nNoOfTriangles + 1;
            v26 = -m_nNoOfTriangles;
            v27 = &m_pTriangleArray[m_nNoOfTriangles - 1];
            v28 = &m_pTrianglePlaneArray[m_nNoOfTriangles - 1];
            do
            {
              if ( CCollision::SphereCastVersusVsPoly(vecStart, &vecEnd, v27, v28, pVerts) )
              {
                v29 = v6;
                v6 = 1;
                if ( gNumColCacheEntries > 98 )
                  return v6 & 1;
                v30 = &v68[gNumColCacheEntries];
                v30->type = 0;
                v31 = pEntity;
                if ( v29 << 31 )
                  v31 = 0;
                v30->pEnt = v31;
                v32 = gNumColCacheEntries++;
                v68[v32].type = 1;
                v68[v32].triId = v25 - 2;
              }
              if ( v70 == 1
                && fabsf(v28->m_compressedNormal.z) < 0.05
                && CCollision::SphereCastVersusVsPoly(&vecEnd, vecStart, v27, v28, pVerts) )
              {
                if ( gNumColCacheEntries > 98 )
                  goto LABEL_71;
                v33 = &v68[gNumColCacheEntries];
                v33->type = 0;
                v16 = v6 << 31 == 0;
                v34 = pEntity;
                v6 = 1;
                if ( !v16 )
                  v34 = 0;
                v33->pEnt = v34;
                v35 = gNumColCacheEntries++;
                v68[v35].type = 1;
                v68[v35].triId = v26;
              }
              --v25;
              --v27;
              --v28;
              LOWORD(v26) = v26 + 1;
            }
            while ( v25 > 1 );
          }
        }
        v54 = v6;
        m_nNoOfBoxes = v72->m_nNoOfBoxes;
LABEL_66:
        v59 = 28 * m_nNoOfBoxes - 28;
        while ( m_nNoOfBoxes >= 1 )
        {
          --m_nNoOfBoxes;
          v60 = (__int64 *)((char *)v72->m_pBoxArray + v59);
          v61 = *v60;
          v62 = v60[1];
          v60 = (__int64 *)((char *)v60 + 12);
          v63 = v60[1];
          *(_QWORD *)&v75.m_pad = *v60;
          v75.m_vecEnd.z = *((RwReal *)&v63 + 1);
          v75.m_vecEnd.x = vecStart[0].m_fRadius + v75.m_vecEnd.x;
          v75.m_vecStart.y = *((float *)&v61 + 1) - vecStart[0].m_fRadius;
          v75.m_vecStart.x = *(float *)&v61 - vecStart[0].m_fRadius;
          v75.m_vecStart.z = *(float *)&v62 - vecStart[0].m_fRadius;
          *(float *)&v75.m_pad = vecStart[0].m_fRadius + *((float *)&v62 + 1);
          v75.m_vecEnd.y = vecStart[0].m_fRadius + *(float *)&v63;
          CColLine::CColLine((CColLine *)&output, &vecStart[0].m_vecCentre, &vecEnd.m_vecCentre);
          v59 -= 28;
          if ( CCollision::TestLineBox_DW(v64, (const CBox *)&v75) )
          {
            if ( gNumColCacheEntries > 98 )
              goto LABEL_71;
            v56 = &v68[gNumColCacheEntries];
            v56->type = 0;
            v16 = v54 << 31 == 0;
            v54 = 1;
            v57 = v69;
            if ( !v16 )
              v57 = 0;
            v56->pEnt = v57;
            v58 = gNumColCacheEntries++;
            v68[v58].type = 3;
            v68[v58].boxId = m_nNoOfBoxes;
            goto LABEL_66;
          }
        }
        LOBYTE(v6) = v54;
      }
    }
  }
  else
  {
    LOBYTE(v6) = 0;
  }
  return v6 & 1;
}
// 2DECCA: variable 'v12' is possibly undefined
// 2DEFA2: variable 'v39' is possibly undefined
// 2DF188: variable 'v64' is possibly undefined
// 796100: using guessed type char gbTryDoubleSidedCollision;

//----- (002DF1E0) --------------------------------------------------------
bool __fastcall CCollision::IsThisVehicleSittingOnMe(CVehicle *pVehicleMe, CVehicle *pVehicleTest)
{
  bool v2; // zf
  bool v3; // r2
  int32 m_baseVehicleType; // r2
  CVehicle *SoundPtr; // r2
  bool v7; // zf
  CVehicle *v8; // r2
  bool v9; // zf

  v2 = pVehicleMe == 0;
  v3 = 0;
  if ( pVehicleMe )
    v2 = pVehicleTest == 0;
  if ( v2 )
    return v3;
  m_baseVehicleType = pVehicleTest->m_baseVehicleType;
  if ( m_baseVehicleType )
  {
    if ( m_baseVehicleType != 9 )
      return 0;
    if ( *(CVehicle **)&pVehicleTest[1].m_VehicleAudioEntity.m_EngineSounds[0].EngineSoundType != pVehicleMe )
    {
      SoundPtr = (CVehicle *)pVehicleTest[1].m_VehicleAudioEntity.m_EngineSounds[0].SoundPtr;
      v7 = SoundPtr == pVehicleMe;
      if ( SoundPtr != pVehicleMe )
        v7 = *(_DWORD *)&pVehicleTest[1].m_VehicleAudioEntity.m_EngineSounds[1].EngineSoundType == (_DWORD)pVehicleMe;
      if ( !v7 )
        return pVehicleTest[1].m_VehicleAudioEntity.m_EngineSounds[1].SoundPtr == (CAESound *)pVehicleMe;
    }
    return 1;
  }
  v8 = *(CVehicle **)&pVehicleTest[1].m_VehicleAudioEntity.m_SkidSound.m_bCurrentlyInUse;
  v9 = v8 == pVehicleMe;
  if ( v8 != pVehicleMe )
    v9 = *(_DWORD *)&pVehicleTest[1].m_VehicleAudioEntity.m_SkidSound.m_nSecondLength == (_DWORD)pVehicleMe;
  if ( v9 || *(CVehicle **)&pVehicleTest[1].m_VehicleAudioEntity.m_SkidSound.m_MaxSwapTime == pVehicleMe )
    return 1;
  return pVehicleTest[1].m_VehicleAudioEntity.m_SkidSound.m_SwapTime == (_DWORD)pVehicleMe;
}

//----- (002DF250) --------------------------------------------------------
int __fastcall CCollision::CheckCameraCollisionVehicles(
        int32 X,
        int32 Y,
        CColBox *pBox,
        CColSphere *pSph,
        CColSphere *pA,
        CColSphere *pB,
        CVector *pMyVel)
{
  CPtrNode *m_pHead; // r8
  CVector *v8; // r2
  int v9; // r10
  CEntity *m_pVoid; // r5
  int (**v11)(void); // r1
  CEntity *m_nFlags; // r1
  bool v13; // zf
  CEntity *m_pRwObject; // r1
  bool v15; // zf
  float32x2_t v16; // d16
  unsigned __int64 v17; // d1
  float m_fRadius; // r6
  float32x2_t v19; // d16
  unsigned __int64 v20; // d2
  float v21; // r6
  float32x2_t v22; // d16
  unsigned __int64 v23; // d2
  float32x2_t *p_y; // [sp+20h] [bp-48h]
  CVector v27; // [sp+2Ch] [bp-3Ch] BYREF
  CColSphere v28; // [sp+38h] [bp-30h] BYREF

  m_pHead = CWorld::ms_aRepeatSectors[X & 0xF | (16 * (Y & 0xF))].m_ptrListArray[0].m_pHead;
  if ( m_pHead )
  {
    v8 = pMyVel;
    v9 = 0;
    p_y = (float32x2_t *)&pSph->m_vecCentre.y;
    while ( 1 )
    {
      m_pVoid = (CEntity *)m_pHead->m_pVoid;
      if ( *((unsigned __int16 *)m_pHead->m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        m_pVoid->m_nScanCode = CWorld::ms_nCurrentScanCode;
        if ( CWorld::pIgnoreEntity != m_pVoid )
        {
          if ( !CWorld::pIgnoreEntity )
            goto LABEL_19;
          v11 = m_pVoid[24]._vptr$CPlaceable;
          if ( v11 )
          {
            if ( v11 != (int (**)(void))byte_9 )
              goto LABEL_19;
            if ( (CEntity *)m_pVoid[33].m_pRwObject != CWorld::pIgnoreEntity )
            {
              m_nFlags = (CEntity *)m_pVoid[33].m_nFlags;
              v13 = m_nFlags == CWorld::pIgnoreEntity;
              if ( m_nFlags != CWorld::pIgnoreEntity )
                v13 = m_pVoid[33].m_nFlags.bdummy == (_DWORD)CWorld::pIgnoreEntity;
              if ( !v13 && *(CEntity **)&m_pVoid[33].RandomSeed != CWorld::pIgnoreEntity )
                goto LABEL_19;
            }
          }
          else if ( (CEntity *)m_pVoid[38].m_pMat != CWorld::pIgnoreEntity )
          {
            m_pRwObject = (CEntity *)m_pVoid[38].m_pRwObject;
            v15 = m_pRwObject == CWorld::pIgnoreEntity;
            if ( m_pRwObject != CWorld::pIgnoreEntity )
              v15 = m_pVoid[38].m_nFlags == (_DWORD)CWorld::pIgnoreEntity;
            if ( !v15 && (CEntity *)m_pVoid[38].m_nFlags.bdummy != CWorld::pIgnoreEntity )
            {
LABEL_19:
              if ( CCollision::CheckCameraCollisionVehicles(int,int,CColBox *,CColSphere *,CColSphere *,CColSphere *,CVector *)::gpLastSittingOnEntity == m_pVoid )
              {
                v13 = CCollision::CheckCameraCollisionVehicles(int,int,CColBox *,CColSphere *,CColSphere *,CColSphere *,CVector *)::gFramesSittingOnTimeOut-- == 0;
                if ( v13 )
                  CCollision::CheckCameraCollisionVehicles(int,int,CColBox *,CColSphere *,CColSphere *,CColSphere *,CVector *)::gpLastSittingOnEntity = 0;
              }
              else if ( v8 )
              {
                v16.n64_u64[0] = vsub_f32(*(float32x2_t *)&pMyVel->y, *(float32x2_t *)&m_pVoid[1].m_transform.m_heading).n64_u64[0];
                v17 = vmul_f32(v16, v16).n64_u64[0];
                if ( (float)((float)((float)((float)(v8->x - m_pVoid[1].m_transform.m_translate.z)
                                           * (float)(v8->x - m_pVoid[1].m_transform.m_translate.z))
                                   + *(float *)&v17)
                           + *((float *)&v17 + 1)) < CCollision::relVelCamCollisionVehiclesSqr )
                {
                  m_fRadius = CModelInfo::ms_modelInfoPtrs[m_pVoid->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
                  CEntity::GetBoundCentre(&v27, m_pVoid);
                  CColSphere::Set(&v28, m_fRadius, &v27, 0, 0, 0xFFu);
                  v19.n64_u64[0] = vsub_f32((float32x2_t)p_y->n64_u64[0], *(float32x2_t *)&v28.m_vecCentre.y).n64_u64[0];
                  v20 = vmul_f32(v19, v19).n64_u64[0];
                  if ( (float)((float)((float)((float)(pSph->m_vecCentre.x - v28.m_vecCentre.x)
                                             * (float)(pSph->m_vecCentre.x - v28.m_vecCentre.x))
                                     + *(float *)&v20)
                             + *((float *)&v20 + 1)) < (float)((float)(pSph->m_fRadius + v28.m_fRadius)
                                                             * (float)(pSph->m_fRadius + v28.m_fRadius)) )
                    v9 |= CCollision::SphereCastVsEntity(pA, pB, m_pVoid);
                  v8 = pMyVel;
                }
              }
              else
              {
                v21 = CModelInfo::ms_modelInfoPtrs[m_pVoid->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
                CEntity::GetBoundCentre(&v27, m_pVoid);
                CColSphere::Set(&v28, v21, &v27, 0, 0, 0xFFu);
                v22.n64_u64[0] = vsub_f32((float32x2_t)p_y->n64_u64[0], *(float32x2_t *)&v28.m_vecCentre.y).n64_u64[0];
                v23 = vmul_f32(v22, v22).n64_u64[0];
                if ( (float)((float)((float)((float)(pSph->m_vecCentre.x - v28.m_vecCentre.x)
                                           * (float)(pSph->m_vecCentre.x - v28.m_vecCentre.x))
                                   + *(float *)&v23)
                           + *((float *)&v23 + 1)) < (float)((float)(pSph->m_fRadius + v28.m_fRadius)
                                                           * (float)(pSph->m_fRadius + v28.m_fRadius)) )
                  v9 |= CCollision::SphereCastVsEntity(pA, pB, m_pVoid);
                v8 = pMyVel;
              }
              goto LABEL_34;
            }
          }
          CCollision::CheckCameraCollisionVehicles(int,int,CColBox *,CColSphere *,CColSphere *,CColSphere *,CVector *)::gFramesSittingOnTimeOut = 30;
          CCollision::CheckCameraCollisionVehicles(int,int,CColBox *,CColSphere *,CColSphere *,CColSphere *,CVector *)::gpLastSittingOnEntity = m_pVoid;
        }
      }
LABEL_34:
      m_pHead = m_pHead->m_pNext;
      if ( !m_pHead )
        return v9 & 1;
    }
  }
  LOBYTE(v9) = 0;
  return v9 & 1;
}

//----- (002DF528) --------------------------------------------------------
int __fastcall CCollision::CheckCameraCollisionObjects(
        int32 X,
        int32 Y,
        CColBox *pBox,
        CColSphere *pSph,
        CColSphere *pA,
        CColSphere *pB)
{
  CPtrNode *m_pHead; // r8
  CEntity *m_pVoid; // r5
  float m_fRadius; // r6
  float32x2_t v10; // d16
  unsigned __int64 v11; // d2
  float32x2_t *p_y; // [sp+10h] [bp-48h]
  int v14; // [sp+18h] [bp-40h]
  CVector v15; // [sp+1Ch] [bp-3Ch] BYREF
  CColSphere v16; // [sp+28h] [bp-30h] BYREF

  m_pHead = CWorld::ms_aRepeatSectors[X & 0xF | (16 * (Y & 0xF))].m_ptrListArray[2].m_pHead;
  if ( m_pHead )
  {
    p_y = (float32x2_t *)&pSph->m_vecCentre.y;
    v14 = 0;
    do
    {
      m_pVoid = (CEntity *)m_pHead->m_pVoid;
      if ( *((unsigned __int16 *)m_pHead->m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        m_pVoid->m_nScanCode = CWorld::ms_nCurrentScanCode;
        if ( !CWorld::CameraToIgnoreThisObject(m_pVoid) && CWorld::pIgnoreEntity != m_pVoid )
        {
          m_fRadius = CModelInfo::ms_modelInfoPtrs[m_pVoid->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
          CEntity::GetBoundCentre(&v15, m_pVoid);
          CColSphere::Set(&v16, m_fRadius, &v15, 0, 0, 0xFFu);
          v10.n64_u64[0] = vsub_f32((float32x2_t)p_y->n64_u64[0], *(float32x2_t *)&v16.m_vecCentre.y).n64_u64[0];
          v11 = vmul_f32(v10, v10).n64_u64[0];
          if ( (float)((float)((float)((float)(pSph->m_vecCentre.x - v16.m_vecCentre.x)
                                     * (float)(pSph->m_vecCentre.x - v16.m_vecCentre.x))
                             + *(float *)&v11)
                     + *((float *)&v11 + 1)) < (float)((float)(pSph->m_fRadius + v16.m_fRadius)
                                                     * (float)(pSph->m_fRadius + v16.m_fRadius)) )
            v14 |= CCollision::SphereCastVsEntity(pA, pB, m_pVoid);
        }
      }
      m_pHead = m_pHead->m_pNext;
    }
    while ( m_pHead );
  }
  else
  {
    LOBYTE(v14) = 0;
  }
  return v14 & 1;
}

//----- (002DF650) --------------------------------------------------------
bool __fastcall CCollision::CheckCameraCollisionPeds(
        int32 X,
        int32 Y,
        CVector *pPos,
        CVector *pNorm,
        float *pNearestDist)
{
  char v6; // r8
  float v7; // s16
  CPtrNode *m_pHead; // r5
  float v9; // s16
  CPed *m_pVoid; // r6
  char m_nFlags; // r1
  bool v12; // zf
  float32x2_t v13; // d16
  unsigned __int64 v14; // d0
  int32 v15; // r0
  CTaskSimpleHoldEntity *TaskHold; // r0
  CEntity::CFlags *p_m_nFlags; // r1
  int v18; // r2
  CEntity *m_pHoldEntity; // r0
  bool v20; // zf
  CEntity::CFlags v21; // r2
  int32 v22; // r1
  CVector v24; // [sp+10h] [bp-48h] BYREF
  CVector v25; // [sp+20h] [bp-38h] BYREF

  v6 = 0;
  v7 = gPedCylinderWidth;
  m_pHead = CWorld::ms_aRepeatSectors[X & 0xF | (16 * (Y & 0xF))].m_ptrListArray[1].m_pHead;
  *(_QWORD *)&v25.x = *(_QWORD *)&pNorm->x;
  v25.z = 0.0;
  CVector::Normalise(&v25);
  if ( m_pHead )
  {
    v9 = v7 * v7;
    v6 = 0;
    do
    {
      m_pVoid = (CPed *)m_pHead->m_pVoid;
      if ( *((unsigned __int16 *)m_pHead->m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        m_nFlags = (char)m_pVoid->m_nFlags;
        m_pVoid->m_nScanCode = CWorld::ms_nCurrentScanCode;
        v12 = (m_nFlags & 0x80) == 0;
        if ( (m_nFlags & 0x80) != 0 )
          v12 = CWorld::pIgnoreEntity == m_pVoid;
        if ( !v12 && !CPed::IsPlayer(m_pVoid) )
        {
          CEntity::GetBoundCentre(&v24, m_pVoid);
          v13.n64_u64[0] = vsub_f32(*(float32x2_t *)&pPos->x, *(float32x2_t *)&v24.x).n64_u64[0];
          v14 = vmul_f32(v13, v13).n64_u64[0];
          if ( (float)(*(float *)&v14 + *((float *)&v14 + 1)) < v9
            && GetNearestDistanceOfPedSphereToCameraNearClip(m_pVoid) <= 0.0 )
          {
            v15 = gNumEntitiesSetInvisible;
            gpMadeInvisibleEntities[gNumEntitiesSetInvisible] = m_pVoid;
            CEntity::RegisterReference(m_pVoid, &gpMadeInvisibleEntities[v15]);
            ++gNumEntitiesSetInvisible;
            TaskHold = CPedIntelligence::GetTaskHold(m_pVoid->m_pPedIntelligence, 0);
            if ( TaskHold )
            {
              m_pHoldEntity = TaskHold->m_pHoldEntity;
              v20 = m_pHoldEntity == 0;
              if ( m_pHoldEntity )
              {
                p_m_nFlags = &m_pHoldEntity->m_nFlags;
                v18 = (int)m_pHoldEntity->m_nFlags;
                v20 = (v18 & 0x80) == 0;
              }
              if ( !v20 )
              {
                v21.bdummy = p_m_nFlags->bdummy;
                *(_DWORD *)&v21 = v18 & 0xFFFFFF7F;
                *p_m_nFlags = v21;
                v22 = gNumEntitiesSetInvisible;
                gpMadeInvisibleEntities[gNumEntitiesSetInvisible] = m_pHoldEntity;
                CEntity::RegisterReference(m_pHoldEntity, &gpMadeInvisibleEntities[v22]);
                ++gNumEntitiesSetInvisible;
              }
            }
            v6 = 1;
            *(_DWORD *)&m_pVoid->m_nFlags &= ~0x80u;
          }
        }
      }
      m_pHead = m_pHead->m_pNext;
    }
    while ( m_pHead );
  }
  return v6 & 1;
}
// 2DF77A: variable 'p_m_nFlags' is possibly undefined
// 2DF77C: variable 'v18' is possibly undefined

//----- (002DF7E4) --------------------------------------------------------
bool __fastcall CCollision::BuildCacheOfCameraCollision(CColSphere *pA, CColSphere *pB)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d4
  float32x2_t v6; // d5
  float32x2_t v7; // d6
  int v10; // r4
  float m_fRadius; // s6
  float v12; // s18
  float v13; // s16
  float v14; // s22
  float v15; // s20
  float v16; // s0
  float v17; // s2
  float v18; // s0
  float v19; // s18
  float v20; // r6
  float v21; // r5
  int v22; // s2
  int v23; // s4
  int32 v24; // r6
  int v25; // r3
  int32 v26; // r5
  uint16 v27; // lr
  CPlayerPed *PlayerPed; // r4
  CTaskComplexEnterCar *ActiveTaskByType; // r0
  CColBox *v30; // r2
  const CVector *PlayerSpeed; // r0
  double v32; // d16
  double *v33; // r0
  int v34; // r11
  int32 v35; // r5
  CEntity *v38; // [sp+Ch] [bp-9Ch]
  int v39; // [sp+14h] [bp-94h]
  int32 v40; // [sp+18h] [bp-90h]
  CVector *pMyVel; // [sp+1Ch] [bp-8Ch]
  _BOOL4 v42; // [sp+20h] [bp-88h]
  _BOOL4 v43; // [sp+24h] [bp-84h]
  _BOOL4 v44; // [sp+28h] [bp-80h]
  int v45; // [sp+2Ch] [bp-7Ch]
  double v46; // [sp+30h] [bp-78h] BYREF
  RwReal z; // [sp+38h] [bp-70h]
  CVector vecCentre; // [sp+40h] [bp-68h] BYREF
  CColSphere pSph; // [sp+4Ch] [bp-5Ch] BYREF

  v2.n64_u32[0] = LODWORD(pA->m_vecCentre.x);
  v3.n64_u32[0] = LODWORD(pA->m_vecCentre.y);
  v10 = 0;
  v6.n64_u32[0] = LODWORD(pB->m_vecCentre.y);
  v5.n64_u32[0] = LODWORD(pB->m_vecCentre.x);
  m_fRadius = pA->m_fRadius;
  v4.n64_u32[0] = LODWORD(pA->m_vecCentre.z);
  v7.n64_u32[0] = LODWORD(pB->m_vecCentre.z);
  v12 = vmin_f32(v3, v6).n64_f32[0] - m_fRadius;
  v13 = m_fRadius + vmax_f32(v3, v6).n64_f32[0];
  v14 = vmin_f32(v2, v5).n64_f32[0] - m_fRadius;
  v15 = m_fRadius + vmax_f32(v2, v5).n64_f32[0];
  v16 = vmin_f32(v4, v7).n64_f32[0] - m_fRadius;
  v17 = (float)(m_fRadius + vmax_f32(v4, v7).n64_f32[0]) - v16;
  vecCentre.y = v12 + (float)((float)(v13 - v12) * 0.5);
  vecCentre.x = v14 + (float)((float)(v15 - v14) * 0.5);
  vecCentre.z = v16 + (float)(v17 * 0.5);
  CColSphere::Set(
    &pSph,
    sqrtf(
      (float)((float)((float)(v15 - v14) * (float)(v15 - v14)) + (float)((float)(v13 - v12) * (float)(v13 - v12)))
    + (float)(v17 * v17))
  * 0.5,
    &vecCentre,
    0,
    0,
    0xFFu);
  v18 = (float)(v12 / 50.0) + 60.0;
  v19 = floorf((float)(v14 / 50.0) + 60.0);
  v20 = floorf(v18);
  v21 = floorf((float)(v15 / 50.0) + 60.0);
  v22 = (int)floorf((float)(v13 / 50.0) + 60.0);
  v23 = (int)v21;
  v24 = (int)v20;
  if ( v24 <= 0 )
    v24 = 0;
  gnBottom = v24;
  if ( (int)v19 > 0 )
    v10 = (int)v19;
  v25 = (int)v21;
  gnLeft = v10;
  v26 = 119;
  v39 = v10;
  if ( v23 >= 119 )
    v25 = 119;
  gnRight = v25;
  v45 = v25;
  if ( v22 < 119 )
    v26 = v22;
  gnTop = v26;
  v40 = v26;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v27 = 1;
  }
  else
  {
    v27 = CWorld::ms_nCurrentScanCode + 1;
  }
  v44 = CCollision::bCamCollideWithObjects;
  v43 = CCollision::bCamCollideWithVehicles;
  gNumColCacheEntries = 0;
  v42 = CCollision::bCamCollideWithBuildings;
  CWorld::ms_nCurrentScanCode = v27;
  v38 = CWorld::pIgnoreEntity;
  if ( !CWorld::pIgnoreEntity )
  {
    PlayerPed = FindPlayerPed(0);
    ActiveTaskByType = (CTaskComplexEnterCar *)CTaskManager::FindActiveTaskByType(
                                                 &PlayerPed->m_pPedIntelligence->m_taskManager,
                                                 701);
    if ( ActiveTaskByType
      || (ActiveTaskByType = (CTaskComplexEnterCar *)CTaskManager::FindActiveTaskByType(
                                                       &PlayerPed->m_pPedIntelligence->m_taskManager,
                                                       700)) != 0 )
    {
      CWorld::pIgnoreEntity = CTaskComplexEnterCar::GetCameraAvoidVehicle(ActiveTaskByType);
    }
  }
  if ( FindPlayerVehicle(0, 0) )
  {
    PlayerSpeed = FindPlayerSpeed(0);
    v32 = *(double *)&PlayerSpeed->x;
    z = PlayerSpeed->z;
    v33 = &v46;
    v46 = v32;
  }
  else
  {
    v33 = 0;
  }
  pMyVel = (CVector *)v33;
  LOBYTE(v34) = 0;
  if ( v24 <= v26 )
  {
    v34 = 0;
    do
    {
      v35 = v39 - 1;
      if ( v39 <= v45 )
      {
        do
        {
          ++v35;
          if ( v42 )
          {
            gbTryDoubleSidedCollision = 1;
            v34 |= CCollision::CheckCameraCollisionBuildings(v35, v24, v30, &pSph, pA, pB);
            gbTryDoubleSidedCollision = 0;
          }
          if ( v43 )
            v34 |= CCollision::CheckCameraCollisionVehicles(v35, v24, v30, &pSph, pA, pB, pMyVel);
          if ( v44 )
            v34 |= CCollision::CheckCameraCollisionObjects(v35, v24, v30, &pSph, pA, pB);
        }
        while ( v35 < v45 );
      }
    }
    while ( v24++ < v40 );
  }
  CWorld::pIgnoreEntity = v38;
  return v34 & 1;
}
// 2DF810: variable 'v3' is possibly undefined
// 2DF810: variable 'v6' is possibly undefined
// 2DF820: variable 'v2' is possibly undefined
// 2DF820: variable 'v5' is possibly undefined
// 2DF83C: variable 'v4' is possibly undefined
// 2DF83C: variable 'v7' is possibly undefined
// 2DFA64: variable 'v30' is possibly undefined
// 796100: using guessed type char gbTryDoubleSidedCollision;

//----- (002DFB10) --------------------------------------------------------
bool __fastcall CCollision::CheckPeds(CVector *pSource, CVector *pNorm, float *pNearest)
{
  int32 v5; // r6
  char v6; // r5
  int32 v7; // r11
  int32 v8; // r9
  int32 v9; // r4
  bool v10; // cc
  float *v12; // [sp+0h] [bp-28h]
  int32 v13; // [sp+8h] [bp-20h]

  if ( CCollision::bCamCollideWithPeds && (v5 = gnBottom, v13 = gnTop, gnBottom <= gnTop) )
  {
    v6 = 0;
    v7 = gnRight;
    v8 = gnLeft;
    do
    {
      v9 = v8;
      if ( v8 <= v7 )
      {
        do
        {
          v6 |= CCollision::CheckCameraCollisionPeds(v9, v5, pSource, pNorm, v12);
          v10 = v9++ < v7;
        }
        while ( v10 );
      }
      v10 = v5++ < v13;
    }
    while ( v10 );
  }
  else
  {
    v6 = 0;
  }
  return v6 & 1;
}
// 2DFB66: variable 'v12' is possibly undefined

//----- (002DFBA0) --------------------------------------------------------
void ResetMadeInvisibleObjects()
{
  int32 v0; // r1
  int32 v1; // r5
  CEntity **v2; // r4

  v0 = gNumEntitiesSetInvisible;
  if ( gNumEntitiesSetInvisible >= 1 )
  {
    v1 = 0;
    v2 = gpMadeInvisibleEntities;
    do
    {
      if ( *v2 )
      {
        *(_DWORD *)&(*v2)->m_nFlags |= 0x80u;
        if ( *v2 )
        {
          CEntity::CleanUpOldReference(*v2, v2);
          v0 = gNumEntitiesSetInvisible;
        }
        *v2 = 0;
      }
      ++v1;
      ++v2;
    }
    while ( v1 < v0 );
  }
  gNumEntitiesSetInvisible = 0;
}

//----- (002DFC0C) --------------------------------------------------------
bool __fastcall CCollision::CameraConeCastVsWorldCollision(CColSphere *pA, CColSphere *pB, float *pDist, float minDist)
{
  _BOOL4 v8; // r0
  float v9; // s18
  float v10; // s26
  float v11; // s28
  float v12; // s0
  float v13; // s24
  float v14; // s20
  CColCacheEntry *v15; // r8
  int32 v16; // r6
  CColCacheEntry *v17; // r4
  float v18; // s22
  CColCacheEntry *v19; // r5
  float m_fRadius; // s16
  __int64 v21; // d16
  float v22; // s17
  _BOOL4 v23; // r0
  float v24; // s2
  float *v26; // [sp+Ch] [bp-D0Ch]
  int32 pNumWrite; // [sp+10h] [bp-D08h] BYREF
  CVector pVel; // [sp+14h] [bp-D04h] BYREF
  CColSphere v29; // [sp+20h] [bp-CF8h] BYREF
  char v30; // [sp+34h] [bp-CE4h] BYREF
  char v31; // [sp+674h] [bp-6A4h] BYREF

  gpColCache2 = (CColCacheEntry *)&v30;
  gpColCache = (CColCacheEntry *)&v31;
  v8 = CCollision::BuildCacheOfCameraCollision(pA, pB);
  if ( v8 )
  {
    v9 = 1.0;
    v26 = pDist;
    v10 = minDist;
    v11 = pB->m_vecCentre.x - pA->m_vecCentre.x;
    v12 = 1.0 - minDist;
    v13 = pB->m_vecCentre.y - pA->m_vecCentre.y;
    v14 = pB->m_vecCentre.z - pA->m_vecCentre.z;
    v15 = gpColCache;
    v16 = gNumColCacheEntries;
    v17 = gpColCache2;
    v18 = gLimitPrecisionOfBinarySearch;
    v19 = gpColCache;
    m_fRadius = pA->m_fRadius;
    v21 = *(_QWORD *)&pA->m_vecCentre.x;
    v29.m_vecCentre.z = pA->m_vecCentre.z;
    *(_QWORD *)&v29.m_vecCentre.x = v21;
    do
    {
      pNumWrite = 0;
      v22 = (float)(v12 * 0.5) + v10;
      v29.m_fRadius = m_fRadius * v22;
      pVel.y = v13 * v22;
      pVel.x = v11 * v22;
      pVel.z = v14 * v22;
      v23 = CCollision::SphereCastVsCaches(&v29, &pVel, v16, v15, &pNumWrite, v17);
      v24 = v22;
      if ( v23 )
      {
        v24 = v10;
        v9 = (float)(v12 * 0.5) + v10;
        v19 = v17;
      }
      v12 = v9 - v24;
      v10 = v24;
      if ( v23 )
      {
        v17 = v15;
        v16 = pNumWrite;
      }
      v15 = v19;
    }
    while ( v12 > v18 );
    *v26 = v22;
    gLastRadiusUsedInCollisionPreventionOfCamera = v29.m_fRadius;
    LOBYTE(v8) = 1;
  }
  return v8;
}

//----- (002DFD74) --------------------------------------------------------
bool __fastcall CCollision::SphereCastVsCaches(
        CColSphere *pA,
        CVector *pVel,
        int32 numTest,
        CColCacheEntry *pTest,
        int32 *pNumWrite,
        CColCacheEntry *pWrite)
{
  __int64 v7; // d17
  int v8; // r2
  RwReal v9; // s4
  float m_fRadius; // r0
  uint16 *p_triId; // r11
  CEntity *v12; // r8
  const CMatrix *m_pMat; // r10
  CCollisionData *m_pColData; // r1
  CColCacheEntry *v15; // r0
  int v16; // r0
  unsigned int v17; // r5
  int v19; // r5
  CColCacheEntry *v20; // r3
  int32 *v21; // r2
  int32 v22; // r0
  int v23; // r8
  __int64 *v24; // r0
  __int64 v25; // d16
  __int64 v26; // d17
  __int64 v27; // d19
  const CColLine *v28; // r0
  int32 v29; // r0
  int32 v30; // r0
  int32 v31; // r0
  CColTrianglePlane *m_pTrianglePlaneArray; // [sp+10h] [bp-130h]
  CColTriangle *m_pTriangleArray; // [sp+14h] [bp-12Ch]
  CollisionVector *pVerts; // [sp+18h] [bp-128h]
  CCollisionData *v36; // [sp+1Ch] [bp-124h]
  CVector v37; // [sp+20h] [bp-120h] BYREF
  CVector v38; // [sp+2Ch] [bp-114h] BYREF
  CColLine v39; // [sp+38h] [bp-108h] BYREF
  CColLine v40; // [sp+58h] [bp-E8h] BYREF
  CMatrix output; // [sp+78h] [bp-C8h] BYREF
  CColSphere vecEnd; // [sp+C0h] [bp-80h] BYREF
  CColSphere pB; // [sp+D8h] [bp-68h] BYREF
  CColSphere v44; // [sp+F0h] [bp-50h]
  CColSphere v45; // [sp+108h] [bp-38h]

  v7 = *(_QWORD *)&pA->m_vecCentre.z;
  v8 = *(_DWORD *)&pA->m_data.m_nSurfaceType;
  *(_QWORD *)&pB.m_vecCentre.x = *(_QWORD *)&pA->m_vecCentre.x;
  *(_QWORD *)&pB.m_vecCentre.z = v7;
  *(_DWORD *)&pB.m_data.m_nSurfaceType = v8;
  v9 = pA->m_vecCentre.z + pVel->z;
  *(_QWORD *)&vecEnd.m_vecCentre.x = __PAIR64__(pA->m_vecCentre.y + pVel->y, pA->m_vecCentre.x + pVel->x);
  vecEnd.m_vecCentre.z = v9;
  m_fRadius = pA->m_fRadius;
  *(_QWORD *)&v45.m_vecCentre.x = *(_QWORD *)&pB.m_vecCentre.x;
  *(_QWORD *)&v45.m_vecCentre.z = v7;
  vecEnd.m_fRadius = m_fRadius;
  *(_DWORD *)&v45.m_data.m_nSurfaceType = v8;
  v44 = vecEnd;
  if ( numTest >= 1 )
  {
    p_triId = &pTest->triId;
    pVerts = 0;
    m_pTrianglePlaneArray = 0;
    m_pTriangleArray = 0;
    v36 = 0;
    do
    {
      v12 = (CEntity *)*((_DWORD *)p_triId - 1);
      if ( v12 )
      {
        pB = v45;
        vecEnd = v44;
        m_pMat = v12->m_pMat;
        if ( !m_pMat )
        {
          CPlaceable::AllocateMatrix(v12);
          CSimpleTransform::UpdateMatrix(&v12->m_transform, v12->m_pMat);
          m_pMat = v12->m_pMat;
        }
        m_pColData = CEntity::GetColModel(v12)->m_pColData;
        if ( !m_pColData )
        {
          v36 = 0;
          goto LABEL_22;
        }
        pVerts = m_pColData->m_pTriCompressedVectorArray;
        m_pTriangleArray = m_pColData->m_pTriangleArray;
        v36 = m_pColData;
        m_pTrianglePlaneArray = m_pColData->m_pTrianglePlaneArray;
        output.m_pRwMat = 0;
        output.m_owner = 0;
        Invert(m_pMat, &output);
        CColLine::CColLine(&v40, &pB.m_vecCentre, &vecEnd.m_vecCentre);
        operator*(&v38, &output, &v40.m_vecStart);
        operator*(&v37, &output, &v40.m_vecEnd);
        CColLine::CColLine(&v39, &v38, &v37);
        pB.m_vecCentre.z = v39.m_vecStart.z;
        *(_QWORD *)&pB.m_vecCentre.x = *(_QWORD *)&v39.m_vecStart.x;
        vecEnd.m_vecCentre = v39.m_vecEnd;
        v15 = &pWrite[*pNumWrite];
        v15->type = 0;
        v15->pEnt = v12;
        CMatrix::~CMatrix(&output);
      }
      v16 = *((unsigned __int8 *)p_triId - 8);
      switch ( v16 )
      {
        case 3:
          v23 = p_triId[2];
          v24 = (__int64 *)&v36->m_pBoxArray[v23];
          v25 = *v24;
          v26 = v24[1];
          v24 = (__int64 *)((char *)v24 + 12);
          v27 = v24[1];
          *(_QWORD *)&v40.m_pad = *v24;
          v40.m_vecEnd.z = *((RwReal *)&v27 + 1);
          v40.m_vecEnd.x = pB.m_fRadius + v40.m_vecEnd.x;
          v40.m_vecStart.y = *((float *)&v25 + 1) - pB.m_fRadius;
          v40.m_vecStart.x = *(float *)&v25 - pB.m_fRadius;
          v40.m_vecStart.z = *(float *)&v26 - pB.m_fRadius;
          *(float *)&v40.m_pad = pB.m_fRadius + *((float *)&v26 + 1);
          v40.m_vecEnd.y = pB.m_fRadius + *(float *)&v27;
          CColLine::CColLine((CColLine *)&output, &pB.m_vecCentre, &vecEnd.m_vecCentre);
          if ( CCollision::TestLineBox_DW(v28, (const CBox *)&v40) )
          {
            v20 = pWrite;
            v21 = pNumWrite;
            v29 = (*pNumWrite)++;
            pWrite[v29].type = 3;
            pWrite[v29].boxId = v23;
            goto LABEL_21;
          }
          break;
        case 2:
          v19 = p_triId[1];
          if ( CCollision::SphereCastVsSphere(&pB, &vecEnd, &v36->m_pSphereArray[v19]) )
          {
            v20 = pWrite;
            v21 = pNumWrite;
            v22 = (*pNumWrite)++;
            pWrite[v22].type = 2;
            pWrite[v22].sphId = v19;
LABEL_21:
            v31 = *v21;
            v20[v31].type = 0;
            v20[v31].pEnt = 0;
          }
          break;
        case 1:
          v17 = *p_triId;
          if ( !(v17 > 0x7FFE ? CCollision::SphereCastVersusVsPoly(
                                  &vecEnd,
                                  &pB,
                                  &m_pTriangleArray[v17 ^ 0xFFFF],
                                  &m_pTrianglePlaneArray[v17 ^ 0xFFFF],
                                  pVerts) : CCollision::SphereCastVersusVsPoly(
                                              &pB,
                                              &vecEnd,
                                              &m_pTriangleArray[v17],
                                              &m_pTrianglePlaneArray[v17],
                                              pVerts)) )
            break;
          v20 = pWrite;
          v21 = pNumWrite;
          v30 = (*pNumWrite)++;
          pWrite[v30].type = 1;
          pWrite[v30].triId = v17;
          goto LABEL_21;
        default:
          break;
      }
LABEL_22:
      p_triId += 8;
      --numTest;
    }
    while ( numTest );
  }
  return *pNumWrite > 0;
}
// 2E0008: variable 'v28' is possibly undefined

//----- (002E00B0) --------------------------------------------------------
bool __fastcall CCollision::SphereCastVsBBox(CColSphere *pA, CColSphere *pB, CColBox *pBox)
{
  __int64 v3; // d17
  __int64 v4; // d18
  __int64 v5; // d19
  float m_fRadius; // s6
  const CColLine *v7; // r0
  CColLine v9; // [sp+0h] [bp-48h] BYREF
  __int64 v10; // [sp+20h] [bp-28h] BYREF
  float v11; // [sp+28h] [bp-20h]
  __int64 v12; // [sp+2Ch] [bp-1Ch]
  __int64 v13; // [sp+34h] [bp-14h]

  v3 = *(_QWORD *)&pBox->m_vecMin.z;
  v4 = *(_QWORD *)&pBox->m_vecMax.x;
  v5 = *(_QWORD *)&pBox->m_vecMax.z;
  v10 = *(_QWORD *)&pBox->m_vecMin.x;
  v11 = *(float *)&v3;
  v12 = v4;
  v13 = v5;
  m_fRadius = pA->m_fRadius;
  *(float *)&v10 = *(float *)&v10 - m_fRadius;
  *((float *)&v10 + 1) = *((float *)&v10 + 1) - m_fRadius;
  v11 = *(float *)&v3 - m_fRadius;
  *(float *)&v12 = m_fRadius + *(float *)&v4;
  *((float *)&v12 + 1) = m_fRadius + *((float *)&v4 + 1);
  *(float *)&v13 = m_fRadius + *(float *)&v5;
  CColLine::CColLine(&v9, &pA->m_vecCentre, &pB->m_vecCentre);
  return CCollision::TestLineBox_DW(v7, (const CBox *)&v10);
}
// 2E012C: variable 'v7' is possibly undefined

//----- (002E0134) --------------------------------------------------------
bool __fastcall CCollision::SphereCastVsSphere(CColSphere *pA, CColSphere *pB, CColSphere *pS)
{
  float x; // s2
  float y; // s6
  float z; // s4
  float m_fRadius; // s0
  __int64 v10; // d17
  int v11; // r2
  const CColLine *v12; // r0
  CColSphere v13; // [sp+0h] [bp-40h] BYREF
  CColLine v14; // [sp+18h] [bp-28h] BYREF

  x = pS->m_vecCentre.x;
  y = pS->m_vecCentre.y;
  z = pS->m_vecCentre.z;
  m_fRadius = pS->m_fRadius;
  if ( (float)((float)((float)((float)(pA->m_vecCentre.x - x) * (float)(pA->m_vecCentre.x - x))
                     + (float)((float)(pA->m_vecCentre.y - y) * (float)(pA->m_vecCentre.y - y)))
             + (float)((float)(pA->m_vecCentre.z - z) * (float)(pA->m_vecCentre.z - z))) < (float)((float)(pA->m_fRadius + m_fRadius)
                                                                                                 * (float)(pA->m_fRadius + m_fRadius))
    || (float)((float)((float)((float)(pB->m_vecCentre.x - x) * (float)(pB->m_vecCentre.x - x))
                     + (float)((float)(pB->m_vecCentre.y - y) * (float)(pB->m_vecCentre.y - y)))
             + (float)((float)(pB->m_vecCentre.z - z) * (float)(pB->m_vecCentre.z - z))) < (float)((float)(m_fRadius + pB->m_fRadius)
                                                                                                 * (float)(m_fRadius + pB->m_fRadius)) )
  {
    return 1;
  }
  CColLine::CColLine(&v14, &pA->m_vecCentre, &pB->m_vecCentre);
  v10 = *(_QWORD *)&pS->m_vecCentre.z;
  v11 = *(_DWORD *)&pS->m_data.m_nSurfaceType;
  *(_QWORD *)&v13.m_vecCentre.x = *(_QWORD *)&pS->m_vecCentre.x;
  *(_QWORD *)&v13.m_vecCentre.z = v10;
  *(_DWORD *)&v13.m_data.m_nSurfaceType = v11;
  v13.m_fRadius = pA->m_fRadius + *((float *)&v10 + 1);
  return CCollision::TestLineSphere(v12, &v13);
}
// 2E0202: variable 'v12' is possibly undefined

//----- (002E020A) --------------------------------------------------------
int32 __fastcall CCollision::RayPolyPOP(CVector *pRS, CVector *pRD, CColTriangle *pP, CVector *pNormal, CVector *pVert)
{
  float y; // s4
  float v6; // s12
  float z; // s2
  float v8; // s10
  float v9; // s8
  float v10; // s3
  float v11; // s1
  float v12; // s6
  float v13; // s6

  y = pRS->y;
  v6 = pNormal->y;
  z = pRS->z;
  v8 = pNormal->z;
  v9 = (float)((float)((float)(pVert->x - pRS->x) * pNormal->x) + (float)((float)(pVert->y - y) * v6))
     + (float)((float)(pVert->z - z) * v8);
  if ( v9 > 0.0 )
    return 0;
  v10 = pRD->y;
  v11 = pRD->z;
  v12 = (float)((float)(pNormal->x * pRD->x) + (float)(v6 * v10)) + (float)(v8 * v11);
  if ( v9 <= v12 )
    return 0;
  v13 = v9 / v12;
  pRS->x = pRS->x + (float)(pRD->x * v13);
  pRS->y = (float)(v10 * v13) + y;
  pRS->z = (float)(v11 * v13) + z;
  return 1;
}

//----- (002E02B4) --------------------------------------------------------
int32 __fastcall CCollision::GetPrincipleAxis(CVector *pNormal)
{
  int32 v1; // r1
  float v2; // s2
  float v3; // s4
  float v4; // s0
  int32 result; // r0

  v1 = 4;
  v2 = fabsf(pNormal->y);
  v3 = fabsf(pNormal->z);
  v4 = fabsf(pNormal->x);
  if ( v2 > v3 )
    v1 = 2;
  result = v1;
  if ( v4 > v3 )
    result = 0;
  if ( v4 <= v2 )
    return v1;
  return result;
}

//----- (002E02F6) --------------------------------------------------------
bool __fastcall CCollision::PointInPoly(CVector *pP, CColTriangle *pPoly, CVector *pNormal, CVector *pV)
{
  float v4; // s2
  float x; // s0
  float v6; // s4
  int v7; // r2
  float v8; // s0
  int v9; // r1
  char v10; // r2
  float v11; // s8
  int v12; // r1
  float v13; // s10
  float z; // s12
  float v15; // s1
  float v16; // s14
  float v17; // s5
  float v18; // s2
  int v19; // r0
  float v20; // s3
  float v21; // s4
  float v22; // s6
  float v23; // s11
  float v24; // s0
  float v25; // s10
  float v26; // s8
  float v27; // s14
  float v28; // s0
  float v29; // s0
  float y; // s2
  float v31; // s4
  float v32; // s6
  float v33; // s8
  float v34; // s10
  float v35; // s12
  float v36; // s14
  float v37; // s1
  float v38; // s5
  float v39; // s3
  float v40; // s8
  float v41; // s11
  float v42; // s4
  float v43; // s0
  float v44; // s12
  float v45; // s8
  float v46; // s10
  float v47; // s0

  v4 = fabsf(pNormal->y);
  x = pNormal->x;
  v6 = fabsf(pNormal->z);
  v7 = 4;
  v8 = fabsf(x);
  if ( v4 > v6 )
    v7 = 2;
  v9 = v7;
  if ( v8 > v6 )
    v9 = 0;
  if ( v8 <= v4 )
    v9 = v7;
  if ( v9 )
  {
    if ( v9 != 4 )
    {
      v10 = 0;
      v11 = pV[2].x;
      v12 = 0;
      v13 = pP->x;
      z = pP->z;
      v15 = pV->x - v11;
      v16 = pV[2].z;
      v17 = pP->x - v11;
      v18 = pV->z;
      v19 = 0;
      v20 = z - v16;
      v21 = pV[1].x;
      v22 = pV[1].z;
      v23 = v13 - v21;
      v24 = v13 - pV->x;
      v25 = (float)(v18 - v16) * v17;
      v26 = (float)(z - v22) * (float)(v11 - v21);
      v27 = v23 * (float)(v16 - v22);
      v28 = (float)(v24 * (float)(v22 - v18)) - (float)((float)(z - v18) * (float)(v21 - pV->x));
      if ( (float)(v25 - (float)(v20 * v15)) <= 0.0 )
        v10 = 1;
      if ( (float)(v27 - v26) <= 0.0 )
        v19 = 1;
      if ( v28 <= 0.0 )
        v12 = 1;
      goto LABEL_24;
    }
    v29 = pV->x;
    y = pV->y;
    v31 = pV[1].x;
    v32 = pV[1].y;
    v33 = pV[2].x;
    v34 = pV[2].y;
    v35 = pP->x;
    v36 = pP->y;
  }
  else
  {
    v29 = pV->y;
    y = pV->z;
    v31 = pV[1].y;
    v32 = pV[1].z;
    v33 = pV[2].y;
    v34 = pV[2].z;
    v35 = pP->y;
    v36 = pP->z;
  }
  v37 = v29 - v33;
  v10 = 0;
  v38 = v35 - v33;
  v19 = 0;
  v39 = v36 - v34;
  v12 = 0;
  v40 = v33 - v31;
  v41 = v35 - v31;
  v42 = v31 - v29;
  v43 = v35 - v29;
  v44 = (float)(y - v34) * v38;
  v45 = (float)(v36 - v32) * v40;
  v46 = v41 * (float)(v34 - v32);
  v47 = (float)(v43 * (float)(v32 - y)) - (float)((float)(v36 - y) * v42);
  if ( (float)(v44 - (float)(v39 * v37)) >= 0.0 )
    v10 = 1;
  if ( (float)(v46 - v45) >= 0.0 )
    v19 = 1;
  if ( v47 >= 0.0 )
    v12 = 1;
LABEL_24:
  if ( v19 == v12 )
    return (v10 ^ v12 ^ 1) & 1;
  else
    return 0;
}
// 2E0340: conditional instruction was optimized away because r1.4==2

//----- (002E04BE) --------------------------------------------------------
void __fastcall CCollision::ClosestPointOnLine(CVector *pP, CVector *pS, CVector *pE, CVector *pClosest)
{
  float y; // s4
  float v5; // s12
  float z; // s2
  float v7; // s8
  float v8; // s14
  float v9; // s6
  float v10; // s8
  float v11; // s10
  float v12; // s12
  float v13; // s14
  RwReal v14; // r0
  __int64 v15; // d16

  y = pS->y;
  v5 = pE->x - pS->x;
  z = pS->z;
  v7 = pE->y - y;
  v8 = pE->z - z;
  v9 = sqrtf((float)((float)(v5 * v5) + (float)(v7 * v7)) + (float)(v8 * v8));
  v10 = v7 * (float)(1.0 / v9);
  v11 = v5 * (float)(1.0 / v9);
  v12 = v8 * (float)(1.0 / v9);
  v13 = (float)((float)(pP->z - z) * v12)
      + (float)((float)((float)(pP->x - pS->x) * v11) + (float)((float)(pP->y - y) * v10));
  if ( v13 < 0.0 )
  {
    v14 = pS->z;
    v15 = *(_QWORD *)&pS->x;
LABEL_5:
    pClosest->z = v14;
    *(_QWORD *)&pClosest->x = v15;
    return;
  }
  if ( v13 > v9 )
  {
    v15 = *(_QWORD *)&pE->x;
    v14 = pE->z;
    goto LABEL_5;
  }
  pClosest->x = pS->x + (float)(v11 * v13);
  pClosest->y = y + (float)(v10 * v13);
  pClosest->z = z + (float)(v12 * v13);
}

//----- (002E058A) --------------------------------------------------------
void __fastcall CCollision::ClosestPointsOnPoly(CColTriangle *pP, CVector *pV, CVector *pClosest, CVector *pVec)
{
  CVector *v4; // r12
  float x; // s2
  float y; // s6
  float v7; // s14
  float v8; // s12
  float z; // s4
  float v10; // s1
  float v11; // s8
  float v12; // s10
  float v13; // s12
  float v14; // s14
  float v15; // s1
  RwReal v16; // r0
  __int64 v17; // d16
  float v18; // s2
  CVector *v19; // lr
  float v20; // s4
  float v21; // s14
  float v22; // s10
  float v23; // s6
  float v24; // s1
  float v25; // s8
  float v26; // s12
  float v27; // s10
  float v28; // s14
  float v29; // s1
  RwReal v30; // r0
  __int64 v31; // d16
  float v32; // s4
  float v33; // s14
  float v34; // s6
  float v35; // s10
  float v36; // s12
  float v37; // s8
  float v38; // s12
  float v39; // s0
  float v40; // s10
  float v41; // s14
  __int64 v42; // d16
  RwReal v43; // r1

  v4 = pV + 1;
  x = pV[1].x;
  y = pV[1].y;
  v7 = pV->x - x;
  v8 = pV->y - y;
  z = pV[1].z;
  v10 = pV->z - z;
  v11 = sqrtf((float)((float)(v7 * v7) + (float)(v8 * v8)) + (float)(v10 * v10));
  v12 = v8 * (float)(1.0 / v11);
  v13 = v7 * (float)(1.0 / v11);
  v14 = v10 * (float)(1.0 / v11);
  v15 = (float)((float)(pClosest->z - z) * v14)
      + (float)((float)((float)(pClosest->x - x) * v13) + (float)((float)(pClosest->y - y) * v12));
  if ( v15 < 0.0 )
  {
    v16 = pV[1].z;
    v17 = *(_QWORD *)&v4->x;
LABEL_5:
    pVec->z = v16;
    *(_QWORD *)&pVec->x = v17;
    goto LABEL_7;
  }
  if ( v15 > v11 )
  {
    v17 = *(_QWORD *)&pV->x;
    v16 = pV->z;
    goto LABEL_5;
  }
  pVec->x = x + (float)(v13 * v15);
  pVec->y = y + (float)(v12 * v15);
  pVec->z = z + (float)(v14 * v15);
LABEL_7:
  v18 = pV[2].x;
  v19 = pV + 2;
  v20 = pV[2].y;
  v21 = pV[1].x - v18;
  v22 = pV[1].y - v20;
  v23 = pV[2].z;
  v24 = pV[1].z - v23;
  v25 = sqrtf((float)((float)(v21 * v21) + (float)(v22 * v22)) + (float)(v24 * v24));
  v26 = v21 * (float)(1.0 / v25);
  v27 = v22 * (float)(1.0 / v25);
  v28 = v24 * (float)(1.0 / v25);
  v29 = (float)((float)(pClosest->z - v23) * v28)
      + (float)((float)((float)(pClosest->x - v18) * v26) + (float)((float)(pClosest->y - v20) * v27));
  if ( v29 < 0.0 )
  {
    v30 = pV[2].z;
    v31 = *(_QWORD *)&v19->x;
LABEL_11:
    pVec[1].z = v30;
    *(_QWORD *)&pVec[1].x = v31;
    goto LABEL_13;
  }
  if ( v29 > v25 )
  {
    v31 = *(_QWORD *)&v4->x;
    v30 = pV[1].z;
    goto LABEL_11;
  }
  pVec[1].x = v18 + (float)(v26 * v29);
  pVec[1].y = v20 + (float)(v27 * v29);
  pVec[1].z = v23 + (float)(v28 * v29);
LABEL_13:
  v32 = pV->y;
  v33 = pV[2].x - pV->x;
  v34 = pV->z;
  v35 = pV[2].y - v32;
  v36 = pV[2].z - v34;
  v37 = sqrtf((float)((float)(v33 * v33) + (float)(v35 * v35)) + (float)(v36 * v36));
  v38 = v36 * (float)(1.0 / v37);
  v39 = v35 * (float)(1.0 / v37);
  v40 = v33 * (float)(1.0 / v37);
  v41 = (float)((float)(pClosest->z - v34) * v38)
      + (float)((float)((float)(pClosest->x - pV->x) * v40) + (float)((float)(pClosest->y - v32) * v39));
  if ( v41 < 0.0 )
  {
    v42 = *(_QWORD *)&pV->x;
    v43 = pV->z;
LABEL_17:
    pVec[2].z = v43;
    *(_QWORD *)&pVec[2].x = v42;
    return;
  }
  if ( v41 > v37 )
  {
    v42 = *(_QWORD *)&v19->x;
    v43 = pV[2].z;
    goto LABEL_17;
  }
  pVec[2].x = pV->x + (float)(v40 * v41);
  pVec[2].y = v32 + (float)(v39 * v41);
  pVec[2].z = v34 + (float)(v38 * v41);
}

//----- (002E07FE) --------------------------------------------------------
void __fastcall CCollision::Closest3(CVector *pP, CVector *pClosest)
{
  float y; // s2
  float z; // s4
  float v4; // s1
  float v5; // s8
  float v6; // s4
  float v7; // s0
  float v8; // s2
  __int64 v9; // d16
  RwReal v10; // r0

  y = pClosest->y;
  z = pClosest->z;
  v4 = (float)(z - pP[1].z) * (float)(z - pP[1].z);
  v5 = (float)(z - pP[2].z) * (float)(z - pP[2].z);
  v6 = (float)((float)((float)(pClosest->x - pP->x) * (float)(pClosest->x - pP->x))
             + (float)((float)(y - pP->y) * (float)(y - pP->y)))
     + (float)((float)(z - pP->z) * (float)(z - pP->z));
  v7 = (float)((float)((float)(pClosest->x - pP[1].x) * (float)(pClosest->x - pP[1].x))
             + (float)((float)(y - pP[1].y) * (float)(y - pP[1].y)))
     + v4;
  v8 = (float)((float)((float)(pClosest->x - pP[2].x) * (float)(pClosest->x - pP[2].x))
             + (float)((float)(y - pP[2].y) * (float)(y - pP[2].y)))
     + v5;
  if ( v6 >= v7 )
  {
    if ( v7 >= v8 )
    {
LABEL_7:
      v9 = *(_QWORD *)&pP[2].x;
      v10 = pP[2].z;
      goto LABEL_8;
    }
    ++pP;
  }
  else if ( v6 >= v8 )
  {
    goto LABEL_7;
  }
  v9 = *(_QWORD *)&pP->x;
  v10 = pP->z;
LABEL_8:
  pClosest->z = v10;
  *(_QWORD *)&pClosest->x = v9;
}

//----- (002E08CA) --------------------------------------------------------
void __fastcall CCollision::ClosestPointOnPoly(CColTriangle *pP, CVector *pVerts, CVector *pClosest)
{
  float *v4; // r0
  float y; // s2
  float z; // s4
  float v7; // s10
  float v8; // s0
  float v9; // s4
  float v10; // s2
  __int64 v11; // d16
  RwReal v12; // r0
  CVector v13; // [sp+0h] [bp-30h] BYREF
  float v14; // [sp+Ch] [bp-24h] BYREF
  float v15; // [sp+10h] [bp-20h]
  float v16; // [sp+14h] [bp-1Ch]
  float v17; // [sp+18h] [bp-18h] BYREF
  float v18; // [sp+1Ch] [bp-14h]
  float v19; // [sp+20h] [bp-10h]

  CCollision::ClosestPointsOnPoly(pP, pVerts, pClosest, &v13);
  v4 = &v17;
  y = pClosest->y;
  z = pClosest->z;
  v7 = (float)(z - v19) * (float)(z - v19);
  v8 = (float)((float)((float)(pClosest->x - v14) * (float)(pClosest->x - v14))
             + (float)((float)(y - v15) * (float)(y - v15)))
     + (float)((float)(z - v16) * (float)(z - v16));
  v9 = (float)((float)((float)(pClosest->x - v13.x) * (float)(pClosest->x - v13.x))
             + (float)((float)(y - v13.y) * (float)(y - v13.y)))
     + (float)((float)(z - v13.z) * (float)(z - v13.z));
  v10 = (float)((float)((float)(pClosest->x - v17) * (float)(pClosest->x - v17))
              + (float)((float)(y - v18) * (float)(y - v18)))
      + v7;
  if ( v9 >= v8 )
  {
    if ( v8 < v10 )
      v4 = &v14;
    goto LABEL_6;
  }
  if ( v9 >= v10 )
  {
LABEL_6:
    v11 = *(_QWORD *)v4;
    v12 = v4[2];
    goto LABEL_7;
  }
  v11 = *(_QWORD *)&v13.x;
  v12 = v13.z;
LABEL_7:
  pClosest->z = v12;
  *(_QWORD *)&pClosest->x = v11;
}

//----- (002E09A8) --------------------------------------------------------
float __fastcall ClosestSquaredDistanceBetweenFiniteLines(CVector *p1, CVector *p3, CVector *p4, CVector *u, float a)
{
  float y; // s14
  float v6; // s4
  float z; // s1
  float v8; // s2
  float v9; // s10
  float v10; // s0
  float v11; // s8
  float v12; // s14
  float v13; // s1
  float v14; // s12
  float v15; // s3
  float v16; // s15
  float v17; // s7
  float v18; // s11
  float v19; // s16
  float v20; // s13
  float v21; // s9
  float v22; // s18
  float v23; // s3
  float v24; // s9
  float v25; // s7
  float v26; // s10
  float v27; // s8

  y = p3->y;
  v6 = p4->y - y;
  z = p3->z;
  v8 = p4->x - p3->x;
  v9 = u->y;
  v10 = p4->z - z;
  v11 = u->z;
  v12 = p1->y - y;
  v13 = p1->z - z;
  v14 = p1->x - p3->x;
  v15 = (float)((float)(v8 * v8) + (float)(v6 * v6)) + (float)(v10 * v10);
  v16 = (float)((float)(v8 * u->x) + (float)(v6 * v9)) + (float)(v10 * v11);
  v17 = a;
  v18 = (float)(v15 * a) - (float)(v16 * v16);
  v19 = (float)((float)(v14 * u->x) + (float)(v12 * v9)) + (float)(v13 * v11);
  v20 = 0.0;
  v21 = (float)((float)(v8 * v14) + (float)(v6 * v12)) + (float)(v10 * v13);
  if ( v18 >= 0.00001 )
  {
    v22 = (float)(v21 * v16) - (float)(v15 * v19);
    if ( v22 >= 0.0 )
    {
      if ( v22 <= v18 )
      {
        v20 = (float)(v21 * v16) - (float)(v15 * v19);
        v21 = (float)(v21 * a) - (float)(v16 * v19);
        v15 = (float)(v15 * a) - (float)(v16 * v16);
      }
      else
      {
        v21 = v21 + v16;
        v20 = (float)(v15 * a) - (float)(v16 * v16);
      }
    }
  }
  else
  {
    v18 = 1.0;
  }
  if ( v21 >= 0.0 )
  {
    if ( v21 <= v15 )
    {
      v17 = v18;
    }
    else
    {
      v20 = v16 - v19;
      if ( (float)(v16 - v19) >= 0.0 )
      {
        if ( v20 > a )
        {
          v20 = v18;
          v17 = v18;
        }
      }
      else
      {
        v20 = 0.0;
        v17 = v18;
      }
      v21 = v15;
    }
  }
  else
  {
    v21 = 0.0;
    if ( v19 <= -0.0 )
    {
      v20 = -v19;
      if ( (float)-v19 > a )
      {
        v20 = v18;
        v17 = v18;
      }
    }
    else
    {
      v17 = v18;
      v20 = 0.0;
    }
  }
  v23 = v21 / v15;
  v24 = fabsf(v21);
  v25 = v20 / v17;
  if ( fabsf(v20) < 0.00001 )
    v25 = 0.0;
  v26 = v12 + (float)(v9 * v25);
  v27 = v13 + (float)(v11 * v25);
  if ( v24 < 0.00001 )
    v23 = 0.0;
  return (float)((float)(v27 - (float)(v10 * v23)) * (float)(v27 - (float)(v10 * v23)))
       + (float)((float)((float)((float)(v14 + (float)(u->x * v25)) - (float)(v8 * v23))
                       * (float)((float)(v14 + (float)(u->x * v25)) - (float)(v8 * v23)))
               + (float)((float)(v26 - (float)(v6 * v23)) * (float)(v26 - (float)(v6 * v23))));
}

//----- (002E0BB4) --------------------------------------------------------
bool __fastcall CCollision::SphereCastVersusVsPoly(
        CColSphere *pA,
        CColSphere *pB,
        CColTriangle *pP,
        CColTrianglePlane *pPlane,
        CollisionVector *pVerts)
{
  float v5; // s18
  float v6; // s20
  float v7; // s22
  __int64 v8; // d16
  float m_fRadius; // s16
  __int64 v10; // kr00_8
  float v11; // s12
  float m_compressedNormalOffset; // s14
  CollisionVector *v13; // r1
  __int64 v14; // d16
  float v15; // s12
  float v16; // s8
  float v17; // s6
  float v18; // s10
  float v19; // s12
  float v20; // s0
  float v21; // s0
  __int64 v22; // kr08_8
  CollisionVector *v23; // r1
  __int64 v24; // d16
  CollisionVector *v25; // r0
  __int64 v26; // d16
  float v27; // s18
  float v28; // s16
  CVector p1; // [sp+8h] [bp-80h] BYREF
  CVector v31; // [sp+14h] [bp-74h] BYREF
  CVector pNormal; // [sp+20h] [bp-68h] BYREF
  CVector pV; // [sp+30h] [bp-58h] BYREF
  CVector v34; // [sp+3Ch] [bp-4Ch] BYREF
  CVector v35; // [sp+48h] [bp-40h] BYREF
  CVector u; // [sp+54h] [bp-34h] BYREF

  v5 = pB->m_vecCentre.x - pA->m_vecCentre.x;
  v6 = pB->m_vecCentre.y - pA->m_vecCentre.y;
  v7 = pB->m_vecCentre.z - pA->m_vecCentre.z;
  u.y = v6;
  u.x = v5;
  u.z = v7;
  v8 = *(_QWORD *)&pA->m_vecCentre.x;
  p1.z = pA->m_vecCentre.z;
  *(_QWORD *)&p1.x = v8;
  m_fRadius = pA->m_fRadius;
  pNormal = pPlane->m_compressedNormal;
  v10 = v8;
  v11 = (float)(*(float *)&v8 * pNormal.x) + (float)(*((float *)&v8 + 1) * pNormal.y);
  m_compressedNormalOffset = pPlane->m_compressedNormalOffset;
  v13 = &pVerts[pP->m_nIndex1];
  v14 = *(_QWORD *)&v13->x;
  pV.z = v13->z;
  *(_QWORD *)&pV.x = v14;
  v15 = (float)(v11 + (float)(p1.z * pNormal.z)) - m_compressedNormalOffset;
  if ( fabsf(v15) <= m_fRadius )
  {
    v31.y = *((float *)&v10 + 1) - (float)(v15 * pNormal.y);
    v31.x = *(float *)&v10 - (float)(v15 * pNormal.x);
    v31.z = p1.z - (float)(v15 * pNormal.z);
  }
  else
  {
    v16 = *((float *)&v10 + 1) - (float)(m_fRadius * pNormal.y);
    v17 = *(float *)&v10 - (float)(m_fRadius * pNormal.x);
    v18 = p1.z - (float)(m_fRadius * pNormal.z);
    v31.y = v16;
    v31.x = v17;
    v31.z = v18;
    v19 = (float)((float)((float)(pV.x - v17) * pNormal.x) + (float)((float)(pV.y - v16) * pNormal.y))
        + (float)((float)(pV.z - v18) * pNormal.z);
    if ( v19 > 0.0 )
      return 0;
    v20 = (float)((float)(pNormal.x * v5) + (float)(pNormal.y * v6)) + (float)(pNormal.z * v7);
    if ( v19 <= v20 )
      return 0;
    v21 = v19 / v20;
    v31.y = (float)(v6 * v21) + v16;
    v31.x = v17 + (float)(v5 * v21);
    v31.z = (float)(v7 * v21) + v18;
  }
  v22 = *(_QWORD *)&pP->m_nIndex2;
  v23 = &pVerts[v22];
  v24 = *(_QWORD *)&v23->x;
  v34.z = v23->z;
  *(_QWORD *)&v34.x = v24;
  v25 = &pVerts[HIDWORD(v22)];
  v26 = *(_QWORD *)&v25->x;
  v35.z = v25->z;
  *(_QWORD *)&v35.x = v26;
  if ( CCollision::PointInPoly(&v31, (CColTriangle *)(3 * HIDWORD(v22)), &pNormal, &pV) )
    return 1;
  v27 = (float)((float)(v5 * v5) + (float)(v6 * v6)) + (float)(v7 * v7);
  v28 = m_fRadius * m_fRadius;
  return ClosestSquaredDistanceBetweenFiniteLines(&p1, &pV, &v34, &u, v27) < v28
      || ClosestSquaredDistanceBetweenFiniteLines(&p1, &v35, &v34, &u, v27) < v28
      || ClosestSquaredDistanceBetweenFiniteLines(&p1, &pV, &v35, &u, v27) < v28;
}

//----- (002E0DF4) --------------------------------------------------------
bool __fastcall CCollision::SphereVsEntity(CColSphere *pA, CEntity *pEntity)
{
  float v2; // s0
  float32x2_t v3; // d16
  bool v5; // r5
  CMatrix *m_pMat; // r0
  CCollisionData *m_pColData; // r4
  int m_nNoOfSpheres; // r0
  float v10; // s0
  unsigned __int64 v11; // d1
  int v12; // r1
  int v13; // r0
  int v14; // r1
  float v15; // s4
  int m_nNoOfBoxes; // r1
  int v17; // r2
  int v18; // r1
  float *p_y; // r0
  const CColTrianglePlane *v20; // r3
  int m_nNoOfTriangles; // r1
  __int64 v22; // kr00_8
  char v23; // r0
  int v24; // r5
  const CColTriangle *v25; // r2
  const CColTriangle *v26; // r6
  _BOOL4 v27; // r0
  int32 i; // r5
  int32 v29; // r1
  int v30; // r6
  __int16 *v31; // r6
  int v32; // t1
  int v33; // r1
  const CColTriangle *v34; // r11
  int v35; // r8
  CMatrix v36; // [sp+0h] [bp-80h] BYREF

  if ( !(*(_BYTE *)&pEntity->m_nFlags << 31) || CCamera::IsExtraEntityToIgnore(&TheCamera, pEntity) )
    return 0;
  m_pMat = pEntity->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(pEntity);
    CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
    m_pMat = pEntity->m_pMat;
  }
  v5 = 0;
  v36.m_pRwMat = 0;
  v36.m_owner = 0;
  Invert(m_pMat, &v36);
  CMatrix::~CMatrix(&v36);
  m_pColData = CEntity::GetColModel(pEntity)->m_pColData;
  if ( m_pColData )
  {
    m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
    v10 = v2 * v2;
    v11 = vmul_f32(v3, v3).n64_u64[0];
    v12 = 5 * m_nNoOfSpheres;
    v13 = m_nNoOfSpheres + 1;
    v14 = 4 * v12 - 20;
    while ( --v13 >= 1 )
    {
      v15 = *(float *)((char *)&m_pColData->m_pSphereArray->m_fRadius + v14);
      v14 -= 20;
      if ( (float)((float)(v10 + *(float *)&v11) + *((float *)&v11 + 1)) < (float)((float)(v15 + v10)
                                                                                 * (float)(v15 + v10)) )
        return 1;
    }
    m_nNoOfBoxes = m_pColData->m_nNoOfBoxes;
    if ( m_nNoOfBoxes >= 1 )
    {
      v10 = v10 + v10;
      v17 = m_nNoOfBoxes;
      v18 = m_nNoOfBoxes + 1;
      p_y = &m_pColData->m_pBoxArray[v17 - 1].m_vecMax.y;
      while ( *(p_y - 4) > v10
           || *(p_y - 1) < v10
           || *(p_y - 3) > (float)(v10 + v10)
           || *p_y < v10
           || *(p_y - 2) > (float)(v10 + v10)
           || p_y[1] < v10 )
      {
        --v18;
        p_y -= 7;
        if ( v18 <= 1 )
          goto LABEL_21;
      }
      return 1;
    }
LABEL_21:
    CCollision::CalculateTrianglePlanes(m_pColData);
    m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
    if ( m_pColData->m_nNoOfTriangles )
    {
      v22 = *(_QWORD *)&m_pColData->m_pTriCompressedVectorArray;
      v23 = *((_BYTE *)m_pColData + 7);
      if ( (v23 & 2) != 0 )
      {
        for ( i = 0; ; ++i )
        {
          v29 = (v23 & 2) != 0 ? *m_pColData->m_modelSec : 0;
          if ( i >= v29 )
            break;
          v30 = (int)&m_pColData->m_modelSec[8 * ~i + 1 + i];
          if ( *(float *)v30 <= (float)(v10 + v10)
            && *(float *)(v30 + 4) <= (float)(v10 + v10)
            && *(float *)(v30 + 8) <= (float)(v10 + v10) )
          {
            v32 = *(__int16 *)(v30 + 26);
            v31 = (__int16 *)(v30 + 26);
            v33 = *(v31 - 1);
            if ( v33 <= v32 )
            {
              v34 = (const CColTriangle *)(HIDWORD(v22) + 16 * v33);
              v35 = v33 - 1;
              while ( !CCollision::TestSphereTriangle((const CColSphere *)&v36, (const CollisionVector *)v22, v34, v20) )
              {
                ++v35;
                ++v34;
                if ( v35 >= *v31 )
                {
                  v23 = *((_BYTE *)m_pColData + 7);
                  goto LABEL_28;
                }
              }
              return 1;
            }
          }
LABEL_28:
          ;
        }
      }
      else
      {
        v24 = m_nNoOfTriangles + 1;
        v25 = (const CColTriangle *)(HIDWORD(v22) + 16 * m_nNoOfTriangles - 16);
        while ( --v24 >= 1 )
        {
          v26 = v25 - 1;
          v27 = CCollision::TestSphereTriangle((const CColSphere *)&v36, (const CollisionVector *)v22, v25, v20);
          v25 = v26;
          if ( v27 )
            return 1;
        }
      }
    }
    return 0;
  }
  return v5;
}
// 2E0E64: variable 'v2' is possibly undefined
// 2E0E68: variable 'v3' is possibly undefined
// 2E0F62: variable 'v20' is possibly undefined

//----- (002E1034) --------------------------------------------------------
int CCollisionPlugin::PluginAttach()
{
  RpClumpRegisterPlugin(
    0,
    0x253F2FAu,
    ClumpCollisionConstructor,
    ClumpCollisionDestructor,
    ClumpCollisionCopyConstructor);
  RpClumpRegisterPluginStream(
    0x253F2FAu,
    ClumpCollisionStreamRead,
    ClumpCollisionStreamWrite,
    ClumpCollisionStreamGetSize);
  return 1;
}

//----- (002E1094) --------------------------------------------------------
RwStream_0 *__fastcall ClumpCollisionStreamRead(
        RwStream_0 *pStream,
        RwInt32 len,
        void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  CColModel *v7; // r5
  int *v8; // r0

  CMemoryMgr::LockScratchPad();
  RwStreamRead(pStream, PC_Scratch, len);
  v7 = (CColModel *)CColModel::operator new(0x30u);
  CColModel::CColModel(v7);
  if ( PC_Scratch[0] == 843861827 )
  {
    CFileLoader::LoadCollisionModelVer2((uint8 *)&PC_Scratch[8], PC_Scratch[1] - 24, v7, 0);
  }
  else if ( PC_Scratch[0] == 860639043 )
  {
    CFileLoader::LoadCollisionModelVer3((uint8 *)&PC_Scratch[8], PC_Scratch[1] - 24, v7, 0);
  }
  else
  {
    if ( PC_Scratch[0] == 1280069443 )
      v8 = &PC_Scratch[8];
    else
      v8 = PC_Scratch;
    CFileLoader::LoadCollisionModel((uint8 *)v8, v7, 0);
  }
  CColModel::MakeMultipleAlloc(v7);
  CBaseModelInfo::SetColModel(gpCollisionModelInfo, v7, 1);
  gpCollisionModelInfo->m_flags |= 0x800u;
  CMemoryMgr::ReleaseScratchPad();
  return pStream;
}

//----- (002E116E) --------------------------------------------------------
RwInt32 __fastcall ClumpCollisionStreamGetSize(const void *pData, RwInt32 offset, RwInt32 size)
{
  return -1;
}

//----- (002E1174) --------------------------------------------------------
void __fastcall CCollisionPlugin::SetModelInfo(CClumpModelInfo *pModelInfo)
{
  gpCollisionModelInfo = pModelInfo;
}

//----- (002E1180) --------------------------------------------------------
void __fastcall CBoundingBox::CBoundingBox(CBoundingBox *this)
{
  this->m_boxBound.m_vecMax.z = -1.0;
  *(_QWORD *)&this->m_boxBound.m_vecMin.x = 0x3F8000003F800000LL;
  *(_QWORD *)&this->m_boxBound.m_vecMin.z = 0xBF8000003F800000LL;
  this->m_boxBound.m_vecMax.y = -1.0;
}

//----- (002E11B0) --------------------------------------------------------
void __fastcall CCollisionData::CCollisionData(CCollisionData *this)
{
  char v1; // r2

  this->_anon_0.m_nNoOfLines = 0;
  this->m_nNoOfTriangles = 0;
  *(_DWORD *)&this->m_nNoOfSpheres = 0;
  this->m_pShadTriangleArray = 0;
  v1 = *((_BYTE *)this + 7);
  *(_QWORD *)&this->m_pTriangleArray = 0LL;
  *(_QWORD *)&this->m_nNoOfShadTriangles = 0LL;
  *(_QWORD *)&this->m_pSphereArray = 0LL;
  *(_QWORD *)&this->_anon_1.m_pLineArray = 0LL;
  this->m_pTriCompressedShadVectorArray = 0;
  *((_BYTE *)this + 7) = v1 & 0xF8;
}

//----- (002E11DA) --------------------------------------------------------
void __fastcall CCollisionData::RemoveCollisionVolumes(CCollisionData *this)
{
  CColSphere *m_pSphereArray; // r0
  CColSphere **p_m_pSphereArray; // r5
  CColLine *m_pLineArray; // r0
  CColBox *m_pBoxArray; // r0
  CollisionVector *m_pTriCompressedVectorArray; // r0
  CColTriangle *m_pTriangleArray; // r0
  CColTriangle *m_pShadTriangleArray; // r0
  CollisionVector *m_pTriCompressedShadVectorArray; // r0

  p_m_pSphereArray = &this->m_pSphereArray;
  m_pSphereArray = this->m_pSphereArray;
  if ( m_pSphereArray )
    CMemoryMgr::Free(m_pSphereArray);
  m_pLineArray = this->_anon_1.m_pLineArray;
  if ( m_pLineArray )
    CMemoryMgr::Free(m_pLineArray);
  m_pBoxArray = this->m_pBoxArray;
  if ( m_pBoxArray )
    CMemoryMgr::Free(m_pBoxArray);
  m_pTriCompressedVectorArray = this->m_pTriCompressedVectorArray;
  if ( m_pTriCompressedVectorArray )
    CMemoryMgr::Free(m_pTriCompressedVectorArray);
  m_pTriangleArray = this->m_pTriangleArray;
  if ( m_pTriangleArray )
    CMemoryMgr::Free(m_pTriangleArray);
  m_pShadTriangleArray = this->m_pShadTriangleArray;
  if ( m_pShadTriangleArray )
    CMemoryMgr::Free(m_pShadTriangleArray);
  m_pTriCompressedShadVectorArray = this->m_pTriCompressedShadVectorArray;
  if ( m_pTriCompressedShadVectorArray )
    CMemoryMgr::Free(m_pTriCompressedShadVectorArray);
  CCollision::RemoveTrianglePlanes(this);
  this->m_pTriCompressedShadVectorArray = 0;
  this->m_pShadTriangleArray = 0;
  this->_anon_0.m_nNoOfLines = 0;
  this->m_nNoOfTriangles = 0;
  *(_DWORD *)&this->m_nNoOfSpheres = 0;
  *(_QWORD *)p_m_pSphereArray = 0LL;
  *((_QWORD *)p_m_pSphereArray + 1) = 0LL;
  p_m_pSphereArray[4] = 0;
}

//----- (002E1248) --------------------------------------------------------
CCollisionData *__fastcall CCollisionData::Copy(CCollisionData *this, const CCollisionData *cCol)
{
  int m_nNoOfSpheres; // r1
  CColSphere *m_pSphereArray; // r0
  CColSphere *v6; // r0
  int v7; // r1
  int v8; // r0
  unsigned int v9; // r1
  CColSphere *v10; // r6
  CColSphere *v11; // r3
  __int64 v12; // d16
  __int64 v13; // d17
  __int16 v14; // r2
  CColSphere *v15; // r0
  int m_nNoOfLines; // r1
  int v17; // r0
  _BYTE *v18; // r8
  bool v19; // zf
  CColLine *v20; // r0
  CColLine *v21; // r0
  int v22; // r1
  int v23; // r0
  unsigned int v24; // r1
  CColLine *v25; // r2
  __int64 v26; // d16
  __int64 v27; // d17
  __int64 v28; // d18
  __int64 v29; // d19
  CColLine *v30; // r2
  CColLine *v31; // r0
  CColLine *m_pLineArray; // r0
  CColLine *v33; // r0
  int v34; // r1
  int v35; // r0
  unsigned int v36; // r1
  char *v37; // r3
  int v38; // r2
  __int64 v39; // d16
  __int64 v40; // d17
  __int64 v41; // d18
  __int64 v42; // d19
  char *v43; // r3
  char v44; // r0
  int m_nNoOfBoxes; // r1
  CColBox *m_pBoxArray; // r0
  CColBox *v47; // r0
  int v48; // r1
  int v49; // r6
  unsigned int v50; // r5
  CColBox *v51; // r0
  int v52; // r6
  unsigned int v53; // r2
  int32 *p_m_nIndex2; // r1
  int v55; // r3
  __int64 v56; // kr00_8
  CollisionVector *m_pTriCompressedVectorArray; // r0
  unsigned __int16 v58; // r5
  CollisionVector *v59; // r0
  CollisionVector *v60; // r1
  __int64 v61; // d16
  int v62; // r0
  int v63; // r1
  CollisionVector *v64; // r2
  CollisionVector *v65; // r3
  __int64 v66; // d16
  int m_nNoOfTriangles; // r1
  int v68; // r2
  CColTriangle *m_pTriangleArray; // r0
  CColTriangle *v70; // r0
  int v71; // r0
  unsigned int v72; // r1
  CColTriangle *v73; // r2
  __int64 v74; // d16
  __int64 v75; // d17
  CColTriangle *v76; // r2
  CColTriangle *v77; // r0
  CollisionVector *v78; // r0
  unsigned int m_nNoOfShadTriangles; // r12
  CColTriangle *v80; // r0
  CollisionVector *v81; // r0
  int v82; // r6
  unsigned int v83; // r2
  int32 *v84; // r1
  int v85; // r3
  __int64 v86; // kr08_8
  CollisionVector *m_pTriCompressedShadVectorArray; // r0
  unsigned __int16 v88; // r5
  CollisionVector *v89; // r0
  CollisionVector *v90; // r1
  __int64 v91; // d16
  int v92; // r0
  int v93; // r1
  CollisionVector *v94; // r2
  CollisionVector *v95; // r3
  __int64 v96; // d16
  int32 v97; // r1
  int32 v98; // r2
  CColTriangle *m_pShadTriangleArray; // r0
  CColTriangle *v100; // r0
  int v101; // r0
  unsigned int v102; // r1
  CColTriangle *v103; // r2
  __int64 v104; // d16
  __int64 v105; // d17
  CColTriangle *v106; // r2

  m_nNoOfSpheres = (unsigned __int16)cCol->m_nNoOfSpheres;
  if ( m_nNoOfSpheres )
  {
    if ( (unsigned __int16)this->m_nNoOfSpheres == m_nNoOfSpheres )
      goto LABEL_6;
    m_pSphereArray = this->m_pSphereArray;
    this->m_nNoOfSpheres = m_nNoOfSpheres;
    if ( m_pSphereArray )
    {
      CMemoryMgr::Free(m_pSphereArray);
      LOWORD(m_nNoOfSpheres) = this->m_nNoOfSpheres;
    }
    v6 = (CColSphere *)CMemoryMgr::Malloc(20 * (__int16)m_nNoOfSpheres);
    v7 = (unsigned __int16)this->m_nNoOfSpheres;
    this->m_pSphereArray = v6;
    if ( v7 )
    {
LABEL_6:
      v8 = 0;
      v9 = 0;
      do
      {
        ++v9;
        v10 = &cCol->m_pSphereArray[v8];
        v11 = &this->m_pSphereArray[v8++];
        v12 = *(_QWORD *)&v10->m_vecCentre.x;
        v13 = *(_QWORD *)&v10->m_vecCentre.z;
        v14 = *(_WORD *)&v10->m_data.m_nSurfaceType;
        v11->m_data.m_lighting = v10->m_data.m_lighting;
        *(_QWORD *)&v11->m_vecCentre.x = v12;
        *(_QWORD *)&v11->m_vecCentre.z = v13;
        *(_WORD *)&v11->m_data.m_nSurfaceType = v14;
      }
      while ( v9 < this->m_nNoOfSpheres );
    }
  }
  else
  {
    v15 = this->m_pSphereArray;
    this->m_nNoOfSpheres = 0;
    if ( v15 )
      CMemoryMgr::Free(v15);
    this->m_pSphereArray = 0;
  }
  m_nNoOfLines = (unsigned __int8)cCol->_anon_0.m_nNoOfLines;
  if ( cCol->_anon_0.m_nNoOfLines )
  {
    v17 = (unsigned __int8)this->_anon_0.m_nNoOfLines;
    v18 = (char *)cCol + 7;
    if ( (*((_BYTE *)cCol + 7) & 1) != 0 )
    {
      if ( v17 == m_nNoOfLines && *((unsigned __int8 *)this + 7) << 31 )
        goto LABEL_31;
      m_pLineArray = this->_anon_1.m_pLineArray;
      this->_anon_0.m_nNoOfLines = m_nNoOfLines;
      if ( m_pLineArray )
      {
        CMemoryMgr::Free(m_pLineArray);
        LOBYTE(m_nNoOfLines) = this->_anon_0.m_nNoOfLines;
      }
      v33 = (CColLine *)CMemoryMgr::Malloc(36 * (char)m_nNoOfLines);
      v34 = (unsigned __int8)this->_anon_0.m_nNoOfLines;
      this->_anon_1.m_pLineArray = v33;
      if ( v34 )
      {
LABEL_31:
        v35 = 0;
        v36 = 0;
        do
        {
          ++v36;
          v37 = (char *)cCol->_anon_1.m_pLineArray + v35;
          v38 = *((_DWORD *)v37 + 8);
          v39 = *(_QWORD *)v37;
          v40 = *((_QWORD *)v37 + 1);
          v37 += 16;
          v41 = *(_QWORD *)v37;
          v42 = *((_QWORD *)v37 + 1);
          v43 = (char *)this->_anon_1.m_pLineArray + v35;
          v35 += 36;
          *((_DWORD *)v43 + 8) = v38;
          *(_QWORD *)v43 = v39;
          *((_QWORD *)v43 + 1) = v40;
          v43 += 16;
          *(_QWORD *)v43 = v41;
          *((_QWORD *)v43 + 1) = v42;
        }
        while ( v36 < this->_anon_0.m_nNoOfLines );
      }
    }
    else
    {
      v19 = v17 == m_nNoOfLines;
      if ( v17 == m_nNoOfLines )
        v19 = *((unsigned __int8 *)this + 7) << 31 == 0;
      if ( v19 )
        goto LABEL_20;
      v20 = this->_anon_1.m_pLineArray;
      this->_anon_0.m_nNoOfLines = m_nNoOfLines;
      if ( v20 )
      {
        CMemoryMgr::Free(v20);
        LOBYTE(m_nNoOfLines) = this->_anon_0.m_nNoOfLines;
      }
      v21 = (CColLine *)CMemoryMgr::Malloc(32 * (char)m_nNoOfLines);
      v22 = (unsigned __int8)this->_anon_0.m_nNoOfLines;
      this->_anon_1.m_pLineArray = v21;
      if ( v22 )
      {
LABEL_20:
        v23 = 0;
        v24 = 0;
        do
        {
          ++v24;
          v25 = &cCol->_anon_1.m_pLineArray[v23];
          v26 = *(_QWORD *)&v25->m_vecStart.x;
          v27 = *(_QWORD *)&v25->m_vecStart.z;
          v25 = (CColLine *)((char *)v25 + 16);
          v28 = *(_QWORD *)&v25->m_vecStart.x;
          v29 = *(_QWORD *)&v25->m_vecStart.z;
          v30 = &this->_anon_1.m_pLineArray[v23++];
          *(_QWORD *)&v30->m_vecStart.x = v26;
          *(_QWORD *)&v30->m_vecStart.z = v27;
          v30 = (CColLine *)((char *)v30 + 16);
          *(_QWORD *)&v30->m_vecStart.x = v28;
          *(_QWORD *)&v30->m_vecStart.z = v29;
        }
        while ( v24 < this->_anon_0.m_nNoOfLines );
      }
    }
  }
  else
  {
    v31 = this->_anon_1.m_pLineArray;
    this->_anon_0.m_nNoOfLines = 0;
    if ( v31 )
      CMemoryMgr::Free(v31);
    this->_anon_1.m_pLineArray = 0;
    v18 = (char *)cCol + 7;
  }
  v44 = *((_BYTE *)this + 7) & 0xFE | *v18 & 1;
  *((_BYTE *)this + 7) = v44;
  *((_BYTE *)this + 7) = v44 & 0xFB | *v18 & 4;
  m_nNoOfBoxes = (unsigned __int16)cCol->m_nNoOfBoxes;
  if ( cCol->m_nNoOfBoxes )
  {
    if ( (unsigned __int16)this->m_nNoOfBoxes == m_nNoOfBoxes )
      goto LABEL_38;
    m_pBoxArray = this->m_pBoxArray;
    this->m_nNoOfBoxes = m_nNoOfBoxes;
    if ( m_pBoxArray )
    {
      CMemoryMgr::Free(m_pBoxArray);
      LOWORD(m_nNoOfBoxes) = this->m_nNoOfBoxes;
    }
    v47 = (CColBox *)CMemoryMgr::Malloc(28 * (__int16)m_nNoOfBoxes);
    v48 = (unsigned __int16)this->m_nNoOfBoxes;
    this->m_pBoxArray = v47;
    if ( v48 )
    {
LABEL_38:
      v49 = 0;
      v50 = 0;
      do
      {
        CColBox::operator=(&this->m_pBoxArray[v49], &cCol->m_pBoxArray[v49]);
        ++v50;
        ++v49;
      }
      while ( v50 < this->m_nNoOfBoxes );
    }
  }
  else
  {
    v51 = this->m_pBoxArray;
    this->m_nNoOfBoxes = 0;
    if ( v51 )
      CMemoryMgr::Free(v51);
    this->m_pBoxArray = 0;
  }
  if ( cCol->m_nNoOfTriangles )
  {
    v52 = 0;
    v53 = 0;
    p_m_nIndex2 = &cCol->m_pTriangleArray->m_nIndex2;
    do
    {
      v55 = *(p_m_nIndex2 - 1);
      v56 = *(_QWORD *)p_m_nIndex2;
      p_m_nIndex2 += 4;
      ++v53;
      if ( v55 > (unsigned __int16)v52 )
        v52 = v55;
      if ( (int)v56 > (unsigned __int16)v52 )
        v52 = v56;
      if ( SHIDWORD(v56) > (unsigned __int16)v52 )
        v52 = HIDWORD(v56);
    }
    while ( v53 < cCol->m_nNoOfTriangles );
    m_pTriCompressedVectorArray = this->m_pTriCompressedVectorArray;
    v58 = v52 + 1;
    if ( m_pTriCompressedVectorArray )
      CMemoryMgr::Free(m_pTriCompressedVectorArray);
    if ( (_WORD)v52 != 0xFFFF )
    {
      v59 = (CollisionVector *)CMemoryMgr::Malloc(12 * v58);
      this->m_pTriCompressedVectorArray = v59;
      v60 = cCol->m_pTriCompressedVectorArray;
      v61 = *(_QWORD *)&v60->x;
      v59->z = v60->z;
      *(_QWORD *)&v59->x = v61;
      if ( v52 << 16 )
      {
        v62 = v58 - 1;
        v63 = 1;
        do
        {
          --v62;
          v64 = &cCol->m_pTriCompressedVectorArray[v63];
          v65 = &this->m_pTriCompressedVectorArray[v63++];
          v66 = *(_QWORD *)&v64->x;
          v65->z = v64->z;
          *(_QWORD *)&v65->x = v66;
        }
        while ( v62 );
      }
    }
    m_nNoOfTriangles = (unsigned __int16)cCol->m_nNoOfTriangles;
    v68 = (unsigned __int16)this->m_nNoOfTriangles;
    if ( v68 != m_nNoOfTriangles )
    {
      m_pTriangleArray = this->m_pTriangleArray;
      this->m_nNoOfTriangles = m_nNoOfTriangles;
      if ( m_pTriangleArray )
      {
        CMemoryMgr::Free(m_pTriangleArray);
        LOWORD(m_nNoOfTriangles) = this->m_nNoOfTriangles;
      }
      v70 = (CColTriangle *)CMemoryMgr::Malloc(16 * (__int16)m_nNoOfTriangles);
      v68 = (unsigned __int16)this->m_nNoOfTriangles;
      this->m_pTriangleArray = v70;
    }
    if ( v68 )
    {
      v71 = 0;
      v72 = 0;
      do
      {
        ++v72;
        v73 = &cCol->m_pTriangleArray[v71];
        v74 = *(_QWORD *)&v73->m_nIndex1;
        v75 = *(_QWORD *)&v73->m_nIndex3;
        v76 = &this->m_pTriangleArray[v71++];
        *(_QWORD *)&v76->m_nIndex1 = v74;
        *(_QWORD *)&v76->m_nIndex3 = v75;
      }
      while ( v72 < this->m_nNoOfTriangles );
    }
  }
  else
  {
    v77 = this->m_pTriangleArray;
    this->m_nNoOfTriangles = 0;
    if ( v77 )
      CMemoryMgr::Free(v77);
    v78 = this->m_pTriCompressedVectorArray;
    this->m_pTriangleArray = 0;
    if ( v78 )
      CMemoryMgr::Free(v78);
    this->m_pTriCompressedVectorArray = 0;
  }
  m_nNoOfShadTriangles = cCol->m_nNoOfShadTriangles;
  if ( m_nNoOfShadTriangles && (*v18 & 4) != 0 )
  {
    v82 = 0;
    v83 = 0;
    v84 = &cCol->m_pShadTriangleArray->m_nIndex2;
    do
    {
      v85 = *(v84 - 1);
      v86 = *(_QWORD *)v84;
      v84 += 4;
      ++v83;
      if ( v85 > (unsigned __int16)v82 )
        v82 = v85;
      if ( (int)v86 > (unsigned __int16)v82 )
        v82 = v86;
      if ( SHIDWORD(v86) > (unsigned __int16)v82 )
        v82 = HIDWORD(v86);
    }
    while ( v83 < m_nNoOfShadTriangles );
    m_pTriCompressedShadVectorArray = this->m_pTriCompressedShadVectorArray;
    v88 = v82 + 1;
    if ( m_pTriCompressedShadVectorArray )
      CMemoryMgr::Free(m_pTriCompressedShadVectorArray);
    if ( (_WORD)v82 != 0xFFFF )
    {
      v89 = (CollisionVector *)CMemoryMgr::Malloc(12 * v88);
      this->m_pTriCompressedShadVectorArray = v89;
      v90 = cCol->m_pTriCompressedShadVectorArray;
      v91 = *(_QWORD *)&v90->x;
      v89->z = v90->z;
      *(_QWORD *)&v89->x = v91;
      if ( v82 << 16 )
      {
        v92 = v88 - 1;
        v93 = 1;
        do
        {
          --v92;
          v94 = &cCol->m_pTriCompressedShadVectorArray[v93];
          v95 = &this->m_pTriCompressedShadVectorArray[v93++];
          v96 = *(_QWORD *)&v94->x;
          v95->z = v94->z;
          *(_QWORD *)&v95->x = v96;
        }
        while ( v92 );
      }
    }
    v97 = cCol->m_nNoOfShadTriangles;
    v98 = this->m_nNoOfShadTriangles;
    if ( v98 != v97 )
    {
      m_pShadTriangleArray = this->m_pShadTriangleArray;
      this->m_nNoOfShadTriangles = v97;
      if ( m_pShadTriangleArray )
      {
        CMemoryMgr::Free(m_pShadTriangleArray);
        v97 = this->m_nNoOfShadTriangles;
      }
      v100 = (CColTriangle *)CMemoryMgr::Malloc(16 * v97);
      v98 = this->m_nNoOfShadTriangles;
      this->m_pShadTriangleArray = v100;
    }
    if ( v98 )
    {
      v101 = 0;
      v102 = 0;
      do
      {
        ++v102;
        v103 = &cCol->m_pShadTriangleArray[v101];
        v104 = *(_QWORD *)&v103->m_nIndex1;
        v105 = *(_QWORD *)&v103->m_nIndex3;
        v106 = &this->m_pShadTriangleArray[v101++];
        *(_QWORD *)&v106->m_nIndex1 = v104;
        *(_QWORD *)&v106->m_nIndex3 = v105;
      }
      while ( v102 < this->m_nNoOfShadTriangles );
    }
    this->m_nNoOfShadTriangleVerts = cCol->m_nNoOfShadTriangleVerts;
  }
  else
  {
    v80 = this->m_pShadTriangleArray;
    this->m_nNoOfShadTriangles = 0;
    this->m_nNoOfShadTriangleVerts = 0;
    if ( v80 )
      CMemoryMgr::Free(v80);
    v81 = this->m_pTriCompressedShadVectorArray;
    this->m_pShadTriangleArray = 0;
    if ( v81 )
      CMemoryMgr::Free(v81);
    this->m_pTriCompressedShadVectorArray = 0;
  }
  return this;
}

//----- (002E1698) --------------------------------------------------------
void __fastcall CCollisionData::CalculateTrianglePlanes(CCollisionData *this)
{
  CColTrianglePlane *v2; // r0
  int m_nNoOfTriangles; // r1
  int v4; // r5
  int v5; // r6
  int v6; // r4

  v2 = (CColTrianglePlane *)CMemoryMgr::Malloc(20 * this->m_nNoOfTriangles + 20);
  m_nNoOfTriangles = this->m_nNoOfTriangles;
  this->m_pTrianglePlaneArray = v2;
  if ( m_nNoOfTriangles >= 1 )
  {
    CColTrianglePlane::Set(v2, this->m_pTriCompressedVectorArray, this->m_pTriangleArray);
    if ( this->m_nNoOfTriangles >= 2 )
    {
      v4 = 1;
      v5 = 1;
      v6 = 1;
      do
      {
        CColTrianglePlane::Set(
          &this->m_pTrianglePlaneArray[v6],
          this->m_pTriCompressedVectorArray,
          &this->m_pTriangleArray[v5]);
        ++v4;
        ++v6;
        ++v5;
      }
      while ( v4 < this->m_nNoOfTriangles );
    }
  }
}

//----- (002E16FA) --------------------------------------------------------
void __fastcall CCollisionData::GetTrianglePoint(const CCollisionData *this, CVector *pt, int32 index)
{
  *pt = this->m_pTriCompressedVectorArray[index];
}

//----- (002E171C) --------------------------------------------------------
void __fastcall CCollisionData::GetShadTrianglePoint(const CCollisionData *this, CVector *pt, int32 index)
{
  *pt = this->m_pTriCompressedShadVectorArray[index];
}

//----- (002E173E) --------------------------------------------------------
void __fastcall CCollisionData::RemoveTrianglePlanes(CCollisionData *this)
{
  CColTrianglePlane *m_pTrianglePlaneArray; // r0

  m_pTrianglePlaneArray = this->m_pTrianglePlaneArray;
  if ( m_pTrianglePlaneArray )
    CMemoryMgr::Free(m_pTrianglePlaneArray);
  this->m_pTrianglePlaneArray = 0;
}

//----- (002E1754) --------------------------------------------------------
void __fastcall CCollisionData::SetLinkPtr(CCollisionData *this, CLink<CCollisionData *> *pLink)
{
  *(_DWORD *)(((int)&this->m_pTrianglePlaneArray[this->m_nNoOfTriangles].m_compressedNormal.x + 3) & 0xFFFFFFFC) = pLink;
}

//----- (002E176C) --------------------------------------------------------
CLink<CCollisionData *> *__fastcall CCollisionData::GetLinkPtr(CCollisionData *this)
{
  return *(CLink<CCollisionData *> **)(((int)&this->m_pTrianglePlaneArray[this->m_nNoOfTriangles].m_compressedNormal.x
                                      + 3) & 0xFFFFFFFC);
}

//----- (002E1790) --------------------------------------------------------
void __fastcall CColModel::CColModel(CColModel *this)
{
  char v1; // r1

  *(_QWORD *)&this->m_boxBound.m_vecMin.x = 0x3F8000003F800000LL;
  *(_QWORD *)&this->m_boxBound.m_vecMin.z = 0xBF8000003F800000LL;
  this->m_boxBound.m_vecMax.y = -1.0;
  this->m_boxBound.m_vecMax.z = -1.0;
  v1 = *((_BYTE *)this + 41);
  this->m_pColData = 0;
  this->m_level = 0;
  *((_BYTE *)this + 41) = v1 & 0xF8;
}

//----- (002E17D0) --------------------------------------------------------
void __fastcall CColModel::~CColModel(CColModel *this)
{
  CCollisionData *m_pColData; // r0
  char v3; // r1
  CCollisionData *v4; // r0

  m_pColData = this->m_pColData;
  if ( m_pColData )
  {
    v3 = *((_BYTE *)this + 41);
    if ( (v3 & 4) != 0 )
    {
      if ( m_pColData->m_pTriCompressedVectorArray )
      {
        free(m_pColData->m_pTriCompressedVectorArray);
        m_pColData = this->m_pColData;
      }
      if ( m_pColData->m_pTriangleArray )
      {
        free(m_pColData->m_pTriangleArray);
        m_pColData = this->m_pColData;
      }
      if ( m_pColData->m_pTriCompressedShadVectorArray )
      {
        free(m_pColData->m_pTriCompressedShadVectorArray);
        m_pColData = this->m_pColData;
      }
      if ( m_pColData->m_pShadTriangleArray )
      {
        free(m_pColData->m_pShadTriangleArray);
        m_pColData = this->m_pColData;
      }
      v3 = *((_BYTE *)this + 41) & 0xFB;
      *((_BYTE *)this + 41) = v3;
    }
    if ( (v3 & 2) != 0 )
    {
      CCollision::RemoveTrianglePlanes(m_pColData);
      CMemoryMgr::Free(this->m_pColData);
    }
    else
    {
      CCollisionData::RemoveCollisionVolumes(m_pColData);
      v4 = this->m_pColData;
      if ( v4 )
        operator delete(v4);
    }
  }
}

//----- (002E1844) --------------------------------------------------------
void __fastcall CColModel::MakeMultipleAlloc(CColModel *this)
{
  int v2; // r5
  CCollisionData *m_pColData; // r1
  CollisionVector *m_pTriCompressedVectorArray; // r0
  CColTriangle *m_pTriangleArray; // r0
  CollisionVector *m_pTriCompressedShadVectorArray; // r0
  CColTriangle *m_pShadTriangleArray; // r0
  char v8; // r0

  if ( (*((_BYTE *)this + 41) & 2) != 0 )
  {
    v2 = operator new(0x34u);
    *(_QWORD *)(v2 + 32) = 0LL;
    *(_QWORD *)(v2 + 40) = 0LL;
    *(_QWORD *)v2 = 0LL;
    *(_QWORD *)(v2 + 8) = 0LL;
    *(_QWORD *)(v2 + 16) = 0LL;
    *(_QWORD *)(v2 + 24) = 0LL;
    CCollisionData::Copy((CCollisionData *)v2, this->m_pColData);
    if ( (*((_BYTE *)this + 41) & 4) != 0 )
    {
      m_pColData = this->m_pColData;
      m_pTriCompressedVectorArray = m_pColData->m_pTriCompressedVectorArray;
      if ( m_pTriCompressedVectorArray )
      {
        free(m_pTriCompressedVectorArray);
        m_pColData = this->m_pColData;
      }
      m_pTriangleArray = m_pColData->m_pTriangleArray;
      if ( m_pTriangleArray )
      {
        free(m_pTriangleArray);
        m_pColData = this->m_pColData;
      }
      m_pTriCompressedShadVectorArray = m_pColData->m_pTriCompressedShadVectorArray;
      if ( m_pTriCompressedShadVectorArray )
      {
        free(m_pTriCompressedShadVectorArray);
        m_pColData = this->m_pColData;
      }
      m_pShadTriangleArray = m_pColData->m_pShadTriangleArray;
      if ( m_pShadTriangleArray )
        free(m_pShadTriangleArray);
      *((_BYTE *)this + 41) &= ~4u;
    }
    CMemoryMgr::Free(this->m_pColData);
    v8 = *((_BYTE *)this + 41);
    this->m_pColData = (CCollisionData *)v2;
    *((_BYTE *)this + 41) = v8 & 0xF9;
  }
}

//----- (002E18D0) --------------------------------------------------------
void *__fastcall CColModel::operator new(size_t nSize)
{
  int v1; // lr
  CColModelPool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pColModelPool;
  result = (void *)CPools::ms_pColModelPool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pColModelPool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (002E1934) --------------------------------------------------------
void __fastcall CColModel::operator delete(void *pVoid)
{
  CColModelPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pColModelPool;
  v2 = -1431655765 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pColModelPool->m_aStorage) >> 4);
  CPools::ms_pColModelPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (002E1964) --------------------------------------------------------
CColModel *__fastcall CColModel::operator=(CColModel *this, const CColModel *cCol)
{
  __int64 v3; // d17
  CSphere *p_m_sphereBound; // r0
  __int64 v5; // d17
  __int64 v6; // d18
  CCollisionData *m_pColData; // r0

  v3 = *(_QWORD *)&cCol->m_sphereBound.m_vecCentre.z;
  p_m_sphereBound = &this->m_sphereBound;
  *(_QWORD *)&p_m_sphereBound->m_vecCentre.x = *(_QWORD *)&cCol->m_sphereBound.m_vecCentre.x;
  *(_QWORD *)&p_m_sphereBound->m_vecCentre.z = v3;
  v5 = *(_QWORD *)&cCol->m_boxBound.m_vecMin.z;
  v6 = *(_QWORD *)&cCol->m_boxBound.m_vecMax.y;
  m_pColData = this->m_pColData;
  *(_QWORD *)&this->m_boxBound.m_vecMin.x = *(_QWORD *)&cCol->m_boxBound.m_vecMin.x;
  *(_QWORD *)&this->m_boxBound.m_vecMin.z = v5;
  *(_QWORD *)&this->m_boxBound.m_vecMax.y = v6;
  if ( m_pColData )
    CCollisionData::Copy(m_pColData, cCol->m_pColData);
  return this;
}

//----- (002E199E) --------------------------------------------------------
void __fastcall CColModel::AllocateData(CColModel *this)
{
  int v2; // r0

  *((_BYTE *)this + 41) &= 0xF9u;
  v2 = operator new(0x34u);
  *(_QWORD *)(v2 + 32) = 0LL;
  *(_QWORD *)(v2 + 40) = 0LL;
  *(_QWORD *)v2 = 0LL;
  *(_QWORD *)(v2 + 8) = 0LL;
  *(_QWORD *)(v2 + 16) = 0LL;
  *(_QWORD *)(v2 + 24) = 0LL;
  this->m_pColData = (CCollisionData *)v2;
}

//----- (002E19D0) --------------------------------------------------------
void __fastcall CColModel::AllocateData(
        CColModel *this,
        int32 numSpheres,
        int32 numBoxes,
        int32 numLines,
        int32 numVertices,
        int32 numTriangles,
        int bUseDisksNotLines)
{
  int16 v8; // r10
  int32 v11; // r11
  int v12; // r9
  unsigned int v13; // r5
  int v14; // r1
  CCollisionData *v15; // r0
  CCollisionData *m_pColData; // r0
  char v17; // r3
  CCollisionData *v18; // r0
  CCollisionData *v19; // r0
  CCollisionData *v20; // r0
  int v21; // [sp+0h] [bp-28h]
  int v22; // [sp+4h] [bp-24h]

  v8 = numSpheres;
  *((_BYTE *)this + 41) = *((_BYTE *)this + 41) & 0xF9 | 2;
  v11 = numTriangles;
  v12 = 32 * numLines;
  v13 = 20 * numSpheres + 52;
  v22 = 7 * numBoxes;
  v14 = 32 * numLines;
  v21 = 9 * numLines;
  if ( bUseDisksNotLines )
    v14 = 36 * numLines;
  v15 = (CCollisionData *)CMemoryMgr::Malloc(v13 + 28 * numBoxes + 12 * numVertices + 16 * numTriangles + v14);
  this->m_pColData = v15;
  v15->m_nNoOfSpheres = v8;
  this->m_pColData->_anon_0.m_nNoOfLines = numLines;
  this->m_pColData->m_nNoOfBoxes = numBoxes;
  this->m_pColData->m_nNoOfTriangles = numTriangles;
  this->m_pColData->m_pSphereArray = (CColSphere *)&this->m_pColData[1];
  m_pColData = this->m_pColData;
  if ( numLines )
  {
    m_pColData->_anon_1.m_pLineArray = (CColLine *)((char *)m_pColData + v13);
    v17 = bUseDisksNotLines;
    if ( bUseDisksNotLines == 1 )
      v13 += 4 * v21;
    else
      v13 += v12;
  }
  else
  {
    v17 = bUseDisksNotLines;
    m_pColData->_anon_1.m_pLineArray = 0;
  }
  v18 = this->m_pColData;
  if ( numBoxes )
  {
    v18->m_pBoxArray = (CColBox *)((char *)v18 + v13);
    v13 += 4 * v22;
  }
  else
  {
    v18->m_pBoxArray = 0;
  }
  v19 = this->m_pColData;
  if ( numVertices )
  {
    v19->m_pTriCompressedVectorArray = (CollisionVector *)((char *)v19 + v13);
    v13 = (((12 * numVertices) | 3) + v13) & 0xFFFFFFFC;
  }
  else
  {
    v19->m_pTriCompressedVectorArray = 0;
  }
  v20 = this->m_pColData;
  if ( numTriangles )
    v11 = (int32)v20 + v13;
  v20->m_pTriangleArray = (CColTriangle *)v11;
  this->m_pColData->m_pTrianglePlaneArray = 0;
  *((_BYTE *)this->m_pColData + 7) = *((_BYTE *)this->m_pColData + 7) & 0xFE | v17;
}

//----- (002E1AD8) --------------------------------------------------------
void __fastcall CColModel::AllocateData(CColModel *this, int32 size)
{
  *((_BYTE *)this + 41) = *((_BYTE *)this + 41) & 0xF9 | 2;
  this->m_pColData = (CCollisionData *)CMemoryMgr::Malloc(size);
}

//----- (002E1AF8) --------------------------------------------------------
void __fastcall CColModel::RemoveCollisionVolumes(CColModel *this)
{
  CCollisionData *m_pColData; // r0
  char v3; // r1
  CCollisionData *v4; // r0

  m_pColData = this->m_pColData;
  if ( m_pColData )
  {
    v3 = *((_BYTE *)this + 41);
    if ( (v3 & 4) != 0 )
    {
      if ( m_pColData->m_pTriCompressedVectorArray )
      {
        free(m_pColData->m_pTriCompressedVectorArray);
        m_pColData = this->m_pColData;
      }
      if ( m_pColData->m_pTriangleArray )
      {
        free(m_pColData->m_pTriangleArray);
        m_pColData = this->m_pColData;
      }
      if ( m_pColData->m_pTriCompressedShadVectorArray )
      {
        free(m_pColData->m_pTriCompressedShadVectorArray);
        m_pColData = this->m_pColData;
      }
      if ( m_pColData->m_pShadTriangleArray )
      {
        free(m_pColData->m_pShadTriangleArray);
        m_pColData = this->m_pColData;
      }
      v3 = *((_BYTE *)this + 41) & 0xFB;
      *((_BYTE *)this + 41) = v3;
    }
    if ( (v3 & 2) != 0 )
    {
      CCollision::RemoveTrianglePlanes(m_pColData);
      CMemoryMgr::Free(this->m_pColData);
    }
    else
    {
      CCollisionData::RemoveCollisionVolumes(m_pColData);
      v4 = this->m_pColData;
      if ( v4 )
        operator delete(v4);
    }
    this->m_pColData = 0;
  }
}

//----- (002E1B70) --------------------------------------------------------
void __fastcall CColModel::CalculateTrianglePlanes(CColModel *this)
{
  CCollisionData *m_pColData; // r8
  CColTrianglePlane *v2; // r0
  int m_nNoOfTriangles; // r1
  int v4; // r5
  int v5; // r6
  int v6; // r4

  m_pColData = this->m_pColData;
  if ( m_pColData )
  {
    v2 = (CColTrianglePlane *)CMemoryMgr::Malloc(20 * m_pColData->m_nNoOfTriangles + 20);
    m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
    m_pColData->m_pTrianglePlaneArray = v2;
    if ( m_nNoOfTriangles >= 1 )
    {
      CColTrianglePlane::Set(v2, m_pColData->m_pTriCompressedVectorArray, m_pColData->m_pTriangleArray);
      if ( m_pColData->m_nNoOfTriangles >= 2 )
      {
        v4 = 1;
        v5 = 1;
        v6 = 1;
        do
        {
          CColTrianglePlane::Set(
            &m_pColData->m_pTrianglePlaneArray[v5],
            m_pColData->m_pTriCompressedVectorArray,
            &m_pColData->m_pTriangleArray[v6]);
          ++v4;
          ++v6;
          ++v5;
        }
        while ( v4 < m_pColData->m_nNoOfTriangles );
      }
    }
  }
}

//----- (002E1BDA) --------------------------------------------------------
void __fastcall CColModel::RemoveTrianglePlanes(CColModel *this)
{
  CCollisionData *m_pColData; // r4
  CColTrianglePlane *m_pTrianglePlaneArray; // r0

  m_pColData = this->m_pColData;
  if ( m_pColData )
  {
    m_pTrianglePlaneArray = m_pColData->m_pTrianglePlaneArray;
    if ( m_pTrianglePlaneArray )
      CMemoryMgr::Free(m_pTrianglePlaneArray);
    m_pColData->m_pTrianglePlaneArray = 0;
  }
}

//----- (002E1BF6) --------------------------------------------------------
int32 __fastcall CCollisionData::GetNoVectors(const CCollisionData *this)
{
  int m_nNoOfTriangles; // r12
  int v3; // r2
  int v4; // r3
  int32 *p_m_nIndex2; // r0
  int v6; // r1
  __int64 v7; // kr00_8

  m_nNoOfTriangles = this->m_nNoOfTriangles;
  if ( m_nNoOfTriangles < 1 )
    return 1;
  v3 = 0;
  v4 = 0;
  p_m_nIndex2 = &this->m_pTriangleArray->m_nIndex2;
  do
  {
    v6 = *(p_m_nIndex2 - 1);
    ++v3;
    v7 = *(_QWORD *)p_m_nIndex2;
    p_m_nIndex2 += 4;
    if ( v6 > v4 )
      v4 = v6;
    if ( (int)v7 > v4 )
      v4 = v7;
    if ( SHIDWORD(v7) > v4 )
      v4 = HIDWORD(v7);
  }
  while ( v3 < m_nNoOfTriangles );
  return v4 + 1;
}

//----- (002E1C36) --------------------------------------------------------
int32 __fastcall CCollisionData::GetNoShadVectors(const CCollisionData *this)
{
  int32 m_nNoOfShadTriangles; // r12
  int32 v3; // r2
  int v4; // r3
  int32 *p_m_nIndex2; // r0
  int v6; // r1
  __int64 v7; // kr00_8

  m_nNoOfShadTriangles = this->m_nNoOfShadTriangles;
  if ( m_nNoOfShadTriangles < 1 )
    return 1;
  v3 = 0;
  v4 = 0;
  p_m_nIndex2 = &this->m_pShadTriangleArray->m_nIndex2;
  do
  {
    v6 = *(p_m_nIndex2 - 1);
    ++v3;
    v7 = *(_QWORD *)p_m_nIndex2;
    p_m_nIndex2 += 4;
    if ( v6 > v4 )
      v4 = v6;
    if ( (int)v7 > v4 )
      v4 = v7;
    if ( SHIDWORD(v7) > v4 )
      v4 = HIDWORD(v7);
  }
  while ( v3 < m_nNoOfShadTriangles );
  return v4 + 1;
}

//----- (002E1C78) --------------------------------------------------------
CColPoint *__fastcall CColPoint::operator=(CColPoint *this, const CColPoint *p)
{
  __int64 v2; // d16
  __int64 v3; // d16
  __int16 v4; // r3
  __int16 v5; // r3

  v2 = *(_QWORD *)&p->m_vecPosition.x;
  this->m_vecPosition.z = p->m_vecPosition.z;
  *(_QWORD *)&this->m_vecPosition.x = v2;
  v3 = *(_QWORD *)&p->m_vecNormal.x;
  this->m_vecNormal.z = p->m_vecNormal.z;
  *(_QWORD *)&this->m_vecNormal.x = v3;
  v4 = *(_WORD *)&p->m_dataA.m_nSurfaceType;
  this->m_dataA.m_lighting = p->m_dataA.m_lighting;
  *(_WORD *)&this->m_dataA.m_nSurfaceType = v4;
  v5 = *(_WORD *)&p->m_dataB.m_nSurfaceType;
  this->m_dataB.m_lighting = p->m_dataB.m_lighting;
  *(_WORD *)&this->m_dataB.m_nSurfaceType = v5;
  this->m_fDepth = p->m_fDepth;
  return this;
}

//----- (002E1CB4) --------------------------------------------------------
void __fastcall CSphere::Set(CSphere *this, float fRadius, const CVector *vecCentre)
{
  __int64 v3; // d16

  this->m_fRadius = fRadius;
  v3 = *(_QWORD *)&vecCentre->x;
  this->m_vecCentre.z = vecCentre->z;
  *(_QWORD *)&this->m_vecCentre.x = v3;
}

//----- (002E1CC4) --------------------------------------------------------
void __fastcall CColSphere::Set(
        CColSphere *this,
        float fRadius,
        const CVector *vecCentre,
        uint8 nSurfaceType,
        uint8 nPieceType,
        uint8 nLighting)
{
  __int64 v6; // d16

  this->m_fRadius = fRadius;
  v6 = *(_QWORD *)&vecCentre->x;
  this->m_vecCentre.z = vecCentre->z;
  this->m_data.m_nSurfaceType = nSurfaceType;
  this->m_data.m_nPieceType = nPieceType;
  this->m_data.m_lighting = nLighting;
  *(_QWORD *)&this->m_vecCentre.x = v6;
}

//----- (002E1CE0) --------------------------------------------------------
int __fastcall CColSphere::IntersectRay(
        const CColSphere *this,
        const CVector *v,
        const CVector *w,
        CVector *v1,
        CVector *v2)
{
  float v8; // s0
  float v9; // s2
  float v10; // s4
  RwReal v11; // s4
  RwReal v12; // s0
  RwReal v13; // s2
  RwReal v14; // s4
  float xplus; // [sp+8h] [bp-18h] BYREF
  float xminus[5]; // [sp+Ch] [bp-14h] BYREF

  v8 = v->x - this->m_vecCentre.x;
  v9 = v->y - this->m_vecCentre.y;
  v10 = v->z - this->m_vecCentre.z;
  if ( CGeneral::SolveQuadratic(
         1.0,
         (float)((float)((float)(v8 * w->x) + (float)(v9 * w->y)) + (float)(v10 * w->z))
       + (float)((float)((float)(v8 * w->x) + (float)(v9 * w->y)) + (float)(v10 * w->z)),
         (float)((float)((float)(v8 * v8) + (float)(v9 * v9)) + (float)(v10 * v10))
       - (float)(this->m_fRadius * this->m_fRadius),
         xminus,
         &xplus) != 1 )
    return 0;
  v11 = (float)(xminus[0] * w->y) + v->y;
  v12 = (float)(xminus[0] * w->z) + v->z;
  v1->x = (float)(xminus[0] * w->x) + v->x;
  v1->y = v11;
  v1->z = v12;
  v13 = (float)(xplus * w->y) + v->y;
  v14 = (float)(xplus * w->z) + v->z;
  v2->x = (float)(xplus * w->x) + v->x;
  v2->y = v13;
  v2->z = v14;
  return 1;
}
// 2E1CE0: using guessed type float xminus[5];

//----- (002E1E02) --------------------------------------------------------
int __fastcall CColSphere::IntersectEdge(
        const CColSphere *this,
        const CVector *start,
        const CVector *end,
        CVector *v1,
        CVector *v2)
{
  float x; // s30
  float y; // s17
  float v10; // s16
  float z; // s19
  float v12; // s18
  float v13; // s22
  float v14; // s20
  float v15; // s24
  float v16; // s26
  float m_fRadius; // s28
  float v18; // s0
  float v19; // s2
  float v20; // s0
  int result; // r0
  float v22; // s6
  float v23; // s4
  float v24; // s0
  float v25; // s2
  __int64 v26; // d16
  __int64 v27; // d16
  float v28; // s4
  RwReal v29; // s4
  RwReal v30; // s6
  RwReal v31; // s2
  __int64 v32; // d16
  __int64 v33; // d16
  float v34; // s2
  RwReal v35; // s2
  RwReal v36; // s4
  RwReal v37; // s0
  CVector v38; // [sp+0h] [bp-60h] BYREF

  x = start->x;
  y = start->y;
  v10 = end->x - start->x;
  z = start->z;
  v12 = end->y - y;
  v13 = this->m_vecCentre.x;
  v14 = end->z - z;
  v15 = this->m_vecCentre.y;
  v16 = this->m_vecCentre.z;
  m_fRadius = this->m_fRadius;
  v38.x = v10;
  v38.y = v12;
  v38.z = v14;
  CVector::Normalise(&v38);
  v18 = (float)((float)((float)(x - v13) * v38.x) + (float)((float)(y - v15) * v38.y))
      + (float)((float)(z - v16) * v38.z);
  v19 = v18 + v18;
  v20 = (float)(v19 * v19)
      + (float)((float)((float)((float)((float)((float)(x - v13) * (float)(x - v13))
                                      + (float)((float)(y - v15) * (float)(y - v15)))
                              + (float)((float)(z - v16) * (float)(z - v16)))
                      - (float)(m_fRadius * m_fRadius))
              * -4.0);
  if ( v20 < 0.0 )
    return 0;
  result = 0;
  v22 = sqrtf(v20);
  v23 = sqrtf((float)(v14 * v14) + (float)((float)(v10 * v10) + (float)(v12 * v12)));
  v24 = (float)((float)-v19 - v22) * 0.5;
  if ( v24 <= v23 )
  {
    v25 = (float)(v22 - v19) * 0.5;
    if ( v25 >= 0.0 )
    {
      v26 = *(_QWORD *)&end->x;
      v2->z = end->z;
      *(_QWORD *)&v2->x = v26;
      if ( v25 < v23 )
      {
        v27 = *(_QWORD *)&v38.x;
        v2->z = v38.z;
        v28 = v2->z;
        *(_QWORD *)&v2->x = v27;
        v29 = v25 * v28;
        v30 = v25 * v2->x;
        v31 = v25 * v2->y;
        v2->x = v30;
        v2->y = v31;
        v2->z = v29;
        v2->x = start->x + v30;
        v2->y = start->y + v31;
        v2->z = start->z + v29;
      }
      v32 = *(_QWORD *)&start->x;
      v1->z = start->z;
      *(_QWORD *)&v1->x = v32;
      if ( v24 > 0.0 )
      {
        v33 = *(_QWORD *)&v38.x;
        v1->z = v38.z;
        v34 = v1->z;
        *(_QWORD *)&v1->x = v33;
        v35 = v24 * v34;
        v36 = v24 * v1->x;
        v37 = v24 * v1->y;
        v1->x = v36;
        v1->y = v37;
        v1->z = v35;
        v1->x = start->x + v36;
        v1->y = start->y + v37;
        v1->z = start->z + v35;
      }
      return 1;
    }
  }
  return result;
}

//----- (002E1FF4) --------------------------------------------------------
bool __fastcall CColSphere::IntersectPoint(const CColSphere *this, const CVector *v)
{
  float v2; // s0
  float32x2_t v3; // d16
  float m_fRadius; // s4
  bool result; // r0
  unsigned __int64 v6; // d1

  v2 = this->m_vecCentre.x - v->x;
  v3.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vecCentre.y, *(float32x2_t *)&v->y).n64_u64[0];
  m_fRadius = this->m_fRadius;
  result = 0;
  v6 = vmul_f32(v3, v3).n64_u64[0];
  if ( (float)((float)((float)(v2 * v2) + *(float *)&v6) + *((float *)&v6 + 1)) < (float)(m_fRadius * m_fRadius) )
    return 1;
  return result;
}

//----- (002E2034) --------------------------------------------------------
bool __fastcall CColSphere::IntersectSphere(const CColSphere *this, const CColSphere *otherSphere)
{
  float v2; // s0
  float32x2_t v3; // d16
  float m_fRadius; // s4
  bool result; // r0
  float v6; // s2
  unsigned __int64 v7; // d2

  v2 = this->m_vecCentre.x - otherSphere->m_vecCentre.x;
  v3.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vecCentre.y, *(float32x2_t *)&otherSphere->m_vecCentre.y).n64_u64[0];
  m_fRadius = this->m_fRadius;
  result = 0;
  v6 = m_fRadius + otherSphere->m_fRadius;
  v7 = vmul_f32(v3, v3).n64_u64[0];
  if ( (float)((float)((float)(v2 * v2) + *(float *)&v7) + *((float *)&v7 + 1)) < (float)(v6 * v6) )
    return 1;
  return result;
}

//----- (002E207C) --------------------------------------------------------
void __fastcall CColDisk::Set(
        CColDisk *this,
        float fRadius,
        const CVector *vecCentre,
        const CVector *vecThickness,
        float fThickness,
        uint8 nSurfaceType,
        uint8 nPieceType,
        uint8 nLighting)
{
  __int64 v8; // d16
  __int64 v9; // d16

  this->m_fRadius = fRadius;
  v8 = *(_QWORD *)&vecCentre->x;
  this->m_vecCentre.z = vecCentre->z;
  *(_QWORD *)&this->m_vecCentre.x = v8;
  v9 = *(_QWORD *)&vecThickness->x;
  this->m_vecThickness.z = vecThickness->z;
  this->m_fThickness = fThickness;
  this->m_data.m_nSurfaceType = nSurfaceType;
  this->m_data.m_nPieceType = nPieceType;
  this->m_data.m_lighting = nLighting;
  *(_QWORD *)&this->m_vecThickness.x = v9;
}

//----- (002E20B0) --------------------------------------------------------
void CColStore::Initialise()
{
  CPool<ColDef,ColDef> *v0; // r4
  uint8 *v1; // r0
  uint8 v2; // r1
  int i; // r0
  CQuadTreeNode *v4; // r0
  CQuadTreeNode *v5; // r0
  CRect v6; // [sp+0h] [bp-18h] BYREF

  *(_QWORD *)&v6.left = 0x453B8000C53B8000LL;
  *(_QWORD *)&v6.right = 0xC53B8000453B8000LL;
  gCheckCollisionPosn = 0;
  if ( !CColStore::ms_pColPool )
  {
    v0 = (CPool<ColDef,ColDef> *)operator new(0x14u);
    v0->m_aStorage = (CPool<ColDef,ColDef>::StorageType *)operator new[](0x2BD4u);
    v1 = (uint8 *)operator new[](0xFFu);
    v0->m_bOwnsArrays = 1;
    v0->m_aFlags = v1;
    v0->m_nSize = 255;
    v0->m_nFreeIndex = -1;
    v2 = v1[1];
    *v1 = 0x80;
    v1[1] = v2 | 0x80;
    v0->m_aFlags[1] &= 0x80u;
    for ( i = 2; i != 255; ++i )
    {
      v0->m_aFlags[i] |= 0x80u;
      v0->m_aFlags[i] &= 0x80u;
    }
    CColStore::ms_pColPool = v0;
  }
  CColStore::AddColSlot("generic");
  v4 = (CQuadTreeNode *)CQuadTreeNode::operator new(0x28u);
  CQuadTreeNode::CQuadTreeNode(v4, &v6, 3);
  CColStore::ms_pQuadTree = v5;
}
// 2E215C: variable 'v5' is possibly undefined
// 796124: using guessed type char gCheckCollisionPosn;

//----- (002E21A0) --------------------------------------------------------
int32 __fastcall CColStore::AddColSlot(const unsigned __int8 *pName)
{
  int v2; // r2
  CPool<ColDef,ColDef> *v3; // r0
  int32 m_nSize; // r1
  int32 m_nFreeIndex; // r5
  uint8 *m_aFlags; // r3
  int v7; // r4

  v2 = 0;
  v3 = CColStore::ms_pColPool;
  m_nFreeIndex = CColStore::ms_pColPool->m_nFreeIndex;
  m_nSize = CColStore::ms_pColPool->m_nSize;
  do
  {
    v3->m_nFreeIndex = ++m_nFreeIndex;
    if ( m_nFreeIndex == m_nSize )
    {
      m_nFreeIndex = 0;
      v3->m_nFreeIndex = 0;
      if ( v2 << 31 )
        goto LABEL_7;
      v2 = 1;
    }
    m_aFlags = v3->m_aFlags;
    v7 = (char)m_aFlags[m_nFreeIndex];
  }
  while ( v7 > -1 );
  m_aFlags[m_nFreeIndex] = v7 & 0x7F;
  v3->m_aFlags[v3->m_nFreeIndex] = (v3->m_aFlags[v3->m_nFreeIndex] + 1) & 0x7F | v3->m_aFlags[v3->m_nFreeIndex] & 0x80;
  m_nFreeIndex = (int32)v3->m_aStorage[v3->m_nFreeIndex];
LABEL_7:
  *(_DWORD *)(m_nFreeIndex + 40) = 0;
  *(_DWORD *)(m_nFreeIndex + 34) = -2147450881;
  *(_WORD *)(m_nFreeIndex + 38) = 0;
  *(_QWORD *)m_nFreeIndex = 0xC974240049742400LL;
  *(_QWORD *)(m_nFreeIndex + 8) = 0x49742400C9742400LL;
  if ( !strcasecmp((const char *)pName, "procobj")
    || !strcasecmp((const char *)pName, "proc_int")
    || !strcasecmp((const char *)pName, "proc_int2") )
  {
    *(_BYTE *)(m_nFreeIndex + 42) = 1;
  }
  if ( !strncasecmp((const char *)pName, "int_la", 6u)
    || !strncasecmp((const char *)pName, "int_sf", 6u)
    || !strncasecmp((const char *)pName, "int_veg", 7u)
    || !strncasecmp((const char *)pName, "int_cont", 8u)
    || !strncasecmp((const char *)pName, "gen_int1", 8u)
    || !strncasecmp((const char *)pName, "gen_int2", 8u)
    || !strncasecmp((const char *)pName, "gen_int3", 8u)
    || !strncasecmp((const char *)pName, "gen_int4", 8u)
    || !strncasecmp((const char *)pName, "gen_int5", 8u)
    || !strncasecmp((const char *)pName, "gen_intb", 8u)
    || !strncasecmp((const char *)pName, "savehous", 8u)
    || !strcasecmp((const char *)pName, "props")
    || !strcasecmp((const char *)pName, "props2")
    || !strncasecmp((const char *)pName, "levelmap", 8u)
    || !strncasecmp((const char *)pName, "stadint", 7u) )
  {
    *(_BYTE *)(m_nFreeIndex + 43) = 1;
  }
  return -1171354717 * ((signed int)(m_nFreeIndex - (unsigned int)CColStore::ms_pColPool->m_aStorage) >> 2);
}

//----- (002E23F4) --------------------------------------------------------
void CColStore::Shutdown()
{
  CPool<ColDef,ColDef>::StorageType *v0; // r6
  int32 v1; // r5
  CPool<ColDef,ColDef> *v2; // r4
  uint8 *m_aFlags; // r0
  uint8 **p_m_aFlags; // r5
  void *v5; // r0

  v0 = 0;
  v1 = 0;
  v2 = CColStore::ms_pColPool;
  do
  {
    if ( (v2->m_aFlags[v1] & 0x80u) == 0 && v2->m_aStorage != v0 )
    {
      CColStore::RemoveColSlot(v1);
      v2 = CColStore::ms_pColPool;
    }
    ++v1;
    --v0;
  }
  while ( v1 != 255 );
  if ( v2 )
  {
    if ( v2->m_nSize >= 1 )
    {
      if ( v2->m_bOwnsArrays )
      {
        if ( v2->m_aStorage )
          operator delete[](v2->m_aStorage);
        p_m_aFlags = &v2->m_aFlags;
        m_aFlags = v2->m_aFlags;
        if ( m_aFlags )
          operator delete[](m_aFlags);
      }
      else
      {
        p_m_aFlags = &v2->m_aFlags;
      }
      v2->m_aStorage = 0;
      *p_m_aFlags = 0;
      v2->m_nSize = 0;
      v2->m_nFreeIndex = 0;
    }
    operator delete(v2);
  }
  CColStore::ms_pColPool = 0;
  if ( CColStore::ms_pQuadTree )
  {
    CQuadTreeNode::~CQuadTreeNode(CColStore::ms_pQuadTree);
    CQuadTreeNode::operator delete(v5);
  }
  CColStore::ms_pQuadTree = 0;
}
// 2E2480: variable 'v5' is possibly undefined

//----- (002E24A8) --------------------------------------------------------
void __fastcall CColStore::RemoveColSlot(int32 index)
{
  CPool<ColDef,ColDef> *v2; // r2
  uint8 *v3; // r5
  CColModel *m_pColModel; // r0
  int v5; // r1
  CColModel *v6; // r4
  CBaseModelInfo *v7; // r2
  bool v8; // zf
  uint8 *v9; // r1
  CPool<ColDef,ColDef> *v10; // r0
  uint8 *m_aFlags; // r1
  uint8 *v12; // r3
  int v13; // r2

  v2 = CColStore::ms_pColPool;
  v3 = CColStore::ms_pColPool->m_aStorage[index];
  if ( v3[40] )
  {
    if ( (CColStore::ms_pColPool->m_aFlags[index] & 0x80u) != 0 )
      v3 = 0;
    m_pColModel = (CColModel *)*(__int16 *)((char *)&dword_20 + (_DWORD)v3 + 2);
    v5 = *(__int16 *)((char *)&dword_24 + (_DWORD)v3);
    *((_BYTE *)&word_28 + (_DWORD)v3) = 0;
    if ( (int)m_pColModel <= v5 )
    {
      do
      {
        v6 = m_pColModel;
        v7 = CModelInfo::ms_modelInfoPtrs[(_DWORD)m_pColModel];
        v8 = v7 == 0;
        if ( v7 )
        {
          m_pColModel = v7->m_pColModel;
          v8 = m_pColModel == 0;
        }
        if ( !v8 && (v7->m_flags & 0x80) != 0 && m_pColModel->m_level == index )
        {
          CColModel::RemoveCollisionVolumes(m_pColModel);
          LOWORD(v5) = *(_WORD *)((char *)&dword_24 + (_DWORD)v3);
        }
        m_pColModel = (CColModel *)((char *)&v6->m_boxBound.m_vecMin.x + 1);
      }
      while ( (int)v6 < (__int16)v5 );
      v2 = CColStore::ms_pColPool;
    }
  }
  if ( (v2->m_aFlags[index] & 0x80u) != 0 )
    v9 = 0;
  else
    v9 = v2->m_aStorage[index];
  CQuadTreeNode::DeleteItem(CColStore::ms_pQuadTree, v9);
  v10 = CColStore::ms_pColPool;
  m_aFlags = CColStore::ms_pColPool->m_aFlags;
  if ( (char)m_aFlags[index] <= -1 )
    v12 = 0;
  else
    v12 = CColStore::ms_pColPool->m_aStorage[index];
  v13 = -1171354717 * ((v12 - (uint8 *)CColStore::ms_pColPool->m_aStorage) >> 2);
  m_aFlags[v13] |= 0x80u;
  if ( v13 < v10->m_nFreeIndex )
    v10->m_nFreeIndex = v13;
}
// 20: using guessed type int dword_20;
// 24: using guessed type int dword_24;
// 28: using guessed type __int16 word_28;

//----- (002E25A0) --------------------------------------------------------
void __fastcall CColStore::RemoveCol(int32 index)
{
  uint8 *v2; // r5
  CColModel *m_pColModel; // r0
  int v4; // r1
  CColModel *v5; // r4
  CBaseModelInfo *v6; // r2
  bool v7; // zf

  if ( (CColStore::ms_pColPool->m_aFlags[index] & 0x80u) != 0 )
    v2 = 0;
  else
    v2 = CColStore::ms_pColPool->m_aStorage[index];
  m_pColModel = (CColModel *)*((__int16 *)v2 + 17);
  v4 = *((__int16 *)v2 + 18);
  v2[40] = 0;
  if ( (int)m_pColModel <= v4 )
  {
    do
    {
      v5 = m_pColModel;
      v6 = CModelInfo::ms_modelInfoPtrs[(_DWORD)m_pColModel];
      v7 = v6 == 0;
      if ( v6 )
      {
        m_pColModel = v6->m_pColModel;
        v7 = m_pColModel == 0;
      }
      if ( !v7 && (v6->m_flags & 0x80) != 0 && m_pColModel->m_level == index )
      {
        CColModel::RemoveCollisionVolumes(m_pColModel);
        LOWORD(v4) = *((_WORD *)v2 + 18);
      }
      m_pColModel = (CColModel *)((char *)&v5->m_boxBound.m_vecMin.x + 1);
    }
    while ( (int)v5 < (__int16)v4 );
  }
}

//----- (002E261C) --------------------------------------------------------
int32 __fastcall CColStore::FindColSlot(const unsigned __int8 *pName)
{
  return -1;
}

//----- (002E2624) --------------------------------------------------------
void __fastcall CColStore::LoadCol(int32 index, const unsigned __int8 *pFilename)
{
  uint8 *v2; // r4

  if ( (CColStore::ms_pColPool->m_aFlags[index] & 0x80u) != 0 )
    v2 = 0;
  else
    v2 = CColStore::ms_pColPool->m_aStorage[index];
  CFileLoader::LoadCollisionFile(pFilename, index);
  v2[40] = 1;
}

//----- (002E265C) --------------------------------------------------------
bool __fastcall CColStore::LoadCol(int32 index, uint8 *pBuffer, int32 size)
{
  uint8 *v3; // r5
  bool result; // r0

  if ( (CColStore::ms_pColPool->m_aFlags[index] & 0x80u) != 0 )
    v3 = 0;
  else
    v3 = CColStore::ms_pColPool->m_aStorage[index];
  if ( *((__int16 *)v3 + 17) <= *((__int16 *)v3 + 18) )
  {
    if ( !CFileLoader::LoadCollisionFile(pBuffer, size, index) )
      return 0;
  }
  else if ( !CFileLoader::LoadCollisionFileFirstTime(pBuffer, size, index) )
  {
    return 0;
  }
  result = 1;
  v3[40] = 1;
  return result;
}

//----- (002E26C0) --------------------------------------------------------
void __fastcall CColStore::AddRef(int32 index)
{
  ++*(_WORD *)&CColStore::ms_pColPool->m_aStorage[index][38];
}

//----- (002E26DC) --------------------------------------------------------
void __fastcall CColStore::RemoveRef(int32 index)
{
  --*(_WORD *)&CColStore::ms_pColPool->m_aStorage[index][38];
}

//----- (002E26F8) --------------------------------------------------------
CRect *__fastcall CColStore::GetBoundingBox(int32 index)
{
  if ( (CColStore::ms_pColPool->m_aFlags[index] & 0x80u) == 0 )
    return (CRect *)CColStore::ms_pColPool->m_aStorage[index];
  else
    return 0;
}

//----- (002E2718) --------------------------------------------------------
void __fastcall CColStore::IncludeModelIndex(int32 index, int32 modelIndex)
{
  uint8 *v2; // r0

  if ( (CColStore::ms_pColPool->m_aFlags[index] & 0x80u) != 0 )
    v2 = 0;
  else
    v2 = CColStore::ms_pColPool->m_aStorage[index];
  if ( *((__int16 *)v2 + 17) > modelIndex )
    *((_WORD *)v2 + 17) = modelIndex;
  if ( *((__int16 *)v2 + 18) < modelIndex )
    *((_WORD *)v2 + 18) = modelIndex;
}

//----- (002E2750) --------------------------------------------------------
void __fastcall CColStore::AddCollisionNeededAtPosn(const CVector *posn)
{
  __int64 v1; // d16

  gCheckCollisionPosn = 1;
  v1 = *(_QWORD *)&posn->x;
  gCollisionPosn.z = posn->z;
  *(_QWORD *)&gCollisionPosn.x = v1;
}
// 796124: using guessed type char gCheckCollisionPosn;

//----- (002E2774) --------------------------------------------------------
void __fastcall SetIfCollisionIsRequired(const CVector2D *posn, void *data)
{
  float y; // s0

  if ( (entityAreaCode || !*((_BYTE *)data + 43)) && posn->x >= *(float *)data && posn->x <= *((float *)data + 2) )
  {
    y = posn->y;
    if ( y >= *((float *)data + 3) && y <= *((float *)data + 1) )
      *((_BYTE *)data + 41) = 1;
  }
}

//----- (002E27D4) --------------------------------------------------------
void __fastcall SetIfInteriorCollisionIsRequired(const CVector2D *posn, void *data)
{
  float y; // s0

  if ( *((_BYTE *)data + 43) )
  {
    if ( posn->x >= *(float *)data && posn->x <= *((float *)data + 2) )
    {
      y = posn->y;
      if ( y >= *((float *)data + 3) && y <= *((float *)data + 1) )
        *((_BYTE *)data + 41) = 1;
    }
  }
}

//----- (002E2824) --------------------------------------------------------
void __fastcall SetIfCollisionIsRequiredReducedBB(const CVector2D *posn, void *data)
{
  float y; // s0

  if ( posn->x >= (float)(*(float *)data + 80.0) && posn->x <= (float)(*((float *)data + 2) + -80.0) )
  {
    y = posn->y;
    if ( y >= (float)(*((float *)data + 3) + 80.0) && y <= (float)(*((float *)data + 1) + -80.0) )
    {
      if ( entityAreaCode )
      {
        if ( !*((_BYTE *)data + 43) )
          return;
      }
      else if ( *((_BYTE *)data + 43) )
      {
        return;
      }
      *((_BYTE *)data + 41) = 1;
    }
  }
}

//----- (002E28A8) --------------------------------------------------------
void __fastcall CColStore::SetCollisionRequired(const CVector *posn, int32 areaCode)
{
  CPlayerPed *PlayerPed; // r0
  void **v4; // r2
  void (*v5)(const CVector2D *, void *); // r2
  float y; // r3
  CVector2D v7; // [sp+0h] [bp-10h] BYREF

  if ( areaCode == -1 )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed )
      areaCode = PlayerPed->m_areaCode;
    else
      areaCode = CGame::currArea;
  }
  entityAreaCode = areaCode;
  if ( areaCode == CGame::currArea )
    v4 = &SetIfCollisionIsRequired;
  else
    v4 = &SetIfCollisionIsRequiredReducedBB;
  v5 = (void (*)(const CVector2D *, void *))*v4;
  y = posn->y;
  v7.x = posn->x;
  v7.y = y;
  CQuadTreeNode::ForAllMatching((int)CColStore::ms_pQuadTree, &v7, v5);
}
// 6790C0: using guessed type void *SetIfCollisionIsRequired;
// 6792EC: using guessed type void *SetIfCollisionIsRequiredReducedBB;

//----- (002E291C) --------------------------------------------------------
void __fastcall CColStore::LoadCollision(CVector posn, int bLoadScene)
{
  RwReal x; // r5
  RwReal y; // r6
  CVehicle *PlayerVehicle; // r0
  CPlayerPed *PlayerPed; // r0
  CQuadTreeNode *v7; // r0
  void **v8; // r2
  void (*v9)(const CVector2D *, void *); // r2
  int32 v10; // r1
  CQuadTreeNode *v11; // r0
  void **v12; // r2
  void (*v13)(const CVector2D *, void *); // r2
  int i; // r4
  int Type; // r0
  Int32 v16; // r1
  uint8 *v17; // r1
  Int32 Id; // r1
  int v19; // r3
  unsigned int v20; // r1
  CVector2D *v21; // r2
  CVector2D *v22; // r3
  int v23; // r6
  int v24; // r4
  uint8 *v25; // r5
  bool v26; // zf
  CPlayerPed *v27; // r0
  CVector2D posna; // [sp+Ch] [bp-24h] BYREF

  x = posn.x;
  y = posn.y;
  if ( CStreaming::ms_disableStreaming )
    return;
  if ( FindPlayerPed(-1) )
  {
    if ( !bLoadScene )
    {
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      if ( PlayerVehicle )
      {
        y = (float)(PlayerVehicle->m_vecMoveSpeed.y * 20.0) + y;
        x = (float)(PlayerVehicle->m_vecMoveSpeed.x * 20.0) + x;
      }
    }
  }
  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed )
  {
    entityAreaCode = PlayerPed->m_areaCode;
    v7 = CColStore::ms_pQuadTree;
    if ( CGame::currArea == entityAreaCode )
      v8 = &SetIfCollisionIsRequired;
    else
      v8 = &SetIfCollisionIsRequiredReducedBB;
  }
  else
  {
    entityAreaCode = CGame::currArea;
    v7 = CColStore::ms_pQuadTree;
    v8 = &SetIfCollisionIsRequired;
  }
  v9 = (void (*)(const CVector2D *, void *))*v8;
  posna.y = y;
  posna.x = x;
  CQuadTreeNode::ForAllMatching((int)v7, &posna, v9);
  if ( gCheckCollisionPosn != 1 )
    goto LABEL_16;
  v10 = CGame::currArea;
  if ( CGame::currArea != -1 )
    goto LABEL_13;
  v27 = FindPlayerPed(-1);
  if ( !v27 )
  {
    v10 = CGame::currArea;
LABEL_13:
    entityAreaCode = v10;
    v11 = CColStore::ms_pQuadTree;
    goto LABEL_14;
  }
  entityAreaCode = v27->m_areaCode;
  v11 = CColStore::ms_pQuadTree;
  if ( CGame::currArea != entityAreaCode )
  {
    v12 = &SetIfCollisionIsRequiredReducedBB;
    goto LABEL_15;
  }
LABEL_14:
  v12 = &SetIfCollisionIsRequired;
LABEL_15:
  v13 = (void (*)(const CVector2D *, void *))*v12;
  posna = *(CVector2D *)&gCollisionPosn.x;
  CQuadTreeNode::ForAllMatching((int)v11, &posna, v13);
LABEL_16:
  for ( i = 0; i != 75; ++i )
  {
    Type = CTheScripts::MissionCleanUp.cleanup_entities[i].Type;
    if ( Type == 2 )
    {
      Id = CTheScripts::MissionCleanUp.cleanup_entities[i].Id;
      if ( Id < 0 )
      {
        v17 = 0;
      }
      else
      {
        v19 = (unsigned __int8)Id;
        v20 = (unsigned int)Id >> 8;
        if ( CPools::ms_pPedPool->m_aFlags[v20] != v19 )
          continue;
        v17 = CPools::ms_pPedPool->m_aStorage[v20];
        if ( !v17 || (*((_DWORD *)v17 + 275) & 0xFFFFFFFE) == 54 )
          continue;
      }
    }
    else
    {
      if ( Type != 1 )
        continue;
      v16 = CTheScripts::MissionCleanUp.cleanup_entities[i].Id;
      if ( v16 < 0 || CPools::ms_pVehiclePool->m_aFlags[(unsigned int)v16 >> 8] != (unsigned __int8)v16 )
        continue;
      v17 = CPools::ms_pVehiclePool->m_aStorage[(unsigned int)v16 >> 8];
      if ( v17 )
      {
        if ( (v17[58] & 0xF8) == 40 )
          continue;
        goto LABEL_32;
      }
    }
    if ( !v17 )
      continue;
LABEL_32:
    if ( (v17[69] & 0x60) == 0 )
    {
      entityAreaCode = v17[51];
      v21 = (CVector2D *)*((_DWORD *)v17 + 5);
      v22 = v21 + 6;
      if ( !v21 )
        v22 = (CVector2D *)(v17 + 4);
      posna = *v22;
      CQuadTreeNode::ForAllMatching((int)CColStore::ms_pQuadTree, &posna, SetIfCollisionIsRequiredReducedBB);
    }
  }
  v23 = 0;
  v24 = 0;
  do
  {
    if ( (CColStore::ms_pColPool->m_aFlags[v23 + 1] & 0x80u) == 0 )
    {
      v25 = CColStore::ms_pColPool->m_aStorage[v24];
      v26 = v25[85] == 0;
      if ( !v25[85] )
        v26 = v25[86] == 0;
      if ( v26 && *((__int16 *)v25 + 41) < 1 )
      {
        if ( v25[84] )
          CStreaming::RemoveModel(v23 + 25001);
      }
      else
      {
        if ( !v25[84] )
          CStreaming::RequestModel(v23 + 25001, 24);
        v25[85] = 0;
      }
    }
    ++v23;
    ++v24;
  }
  while ( v23 != 254 );
  if ( !bLoadScene )
    gCheckCollisionPosn = 0;
}
// 6790C0: using guessed type void *SetIfCollisionIsRequired;
// 6792EC: using guessed type void *SetIfCollisionIsRequiredReducedBB;
// 796124: using guessed type char gCheckCollisionPosn;

//----- (002E2C50) --------------------------------------------------------
void __fastcall CColStore::EnsureCollisionIsInMemory(const CVector *posn)
{
  CPlayerPed *PlayerPed; // r0
  CQuadTreeNode *v3; // r0
  void **v4; // r2
  void (*v5)(const CVector2D *, void *); // r2
  float y; // r3
  int v7; // r5
  int v8; // r9
  uint8 *p_m_status; // r6
  CMenuManager *v10; // r3
  CPool<ColDef,ColDef>::StorageType *m_aStorage; // r10
  uint8 *v12; // r0
  float v13; // s0
  CMenuManager *v14; // [sp+0h] [bp-40h]
  CVector2D v15; // [sp+8h] [bp-38h] BYREF

  if ( !CStreaming::ms_disableStreaming && (!FindPlayerPed(-1) || CGame::currArea == FindPlayerPed(-1)->m_areaCode) )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed )
    {
      entityAreaCode = PlayerPed->m_areaCode;
      v3 = CColStore::ms_pQuadTree;
      if ( CGame::currArea == entityAreaCode )
        v4 = &SetIfCollisionIsRequired;
      else
        v4 = &SetIfCollisionIsRequiredReducedBB;
    }
    else
    {
      entityAreaCode = CGame::currArea;
      v3 = CColStore::ms_pQuadTree;
      v4 = &SetIfCollisionIsRequired;
    }
    v5 = (void (*)(const CVector2D *, void *))*v4;
    y = posn->y;
    v15.x = posn->x;
    v15.y = y;
    CQuadTreeNode::ForAllMatching((int)v3, &v15, v5);
    v7 = 85;
    v8 = 0;
    p_m_status = &CStreaming::ms_aInfoForModel[25001].m_status;
    v10 = &FrontEndMenuManager;
    do
    {
      if ( (CColStore::ms_pColPool->m_aFlags[v8 + 1] & 0x80u) == 0 )
      {
        m_aStorage = CColStore::ms_pColPool->m_aStorage;
        if ( (*CColStore::ms_pColPool->m_aStorage)[v7] )
        {
          v12 = &(*m_aStorage)[v7];
          if ( posn->x >= (float)(*(float *)&(*m_aStorage)[v7 - 41] + 110.0)
            && posn->x <= (float)(*(float *)(v12 - 33) + -110.0) )
          {
            v13 = posn->y;
            if ( v13 >= (float)(*(float *)(v12 - 29) + 110.0)
              && v13 <= (float)(*(float *)(v12 - 37) + -110.0)
              && *p_m_status != 1 )
            {
              v14 = v10;
              CStreaming::RequestModel(v8 + 25001, 24);
              if ( !CCamera::GetScreenFadeStatus(&TheCamera) )
                CMenuManager::MessageScreen(v14, "LOADCOL", 0, 0);
              CTimer::Suspend();
              CStreaming::LoadAllRequestedModels(1);
              CTimer::Resume();
              v10 = v14;
            }
          }
          (*m_aStorage)[v7] = 0;
        }
      }
      ++v8;
      v7 += 44;
      p_m_status += 20;
    }
    while ( v8 != 254 );
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 6790C0: using guessed type void *SetIfCollisionIsRequired;
// 6792EC: using guessed type void *SetIfCollisionIsRequiredReducedBB;

//----- (002E2E50) --------------------------------------------------------
void __fastcall CColStore::RequestCollision(const CVector *posn, int32 areaCode)
{
  CPlayerPed *PlayerPed; // r0
  void **v4; // r2
  void (*v5)(const CVector2D *, void *); // r2
  float y; // r3
  int v7; // r6
  int i; // r4
  CPool<ColDef,ColDef>::StorageType *m_aStorage; // r5
  uint8 *v10; // r0
  float v11; // s0
  CVector2D v12; // [sp+0h] [bp-38h] BYREF

  if ( areaCode == -1 )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed )
      areaCode = PlayerPed->m_areaCode;
    else
      areaCode = CGame::currArea;
  }
  entityAreaCode = areaCode;
  if ( areaCode == CGame::currArea )
    v4 = &SetIfCollisionIsRequired;
  else
    v4 = &SetIfCollisionIsRequiredReducedBB;
  v5 = (void (*)(const CVector2D *, void *))*v4;
  y = posn->y;
  v12.x = posn->x;
  v12.y = y;
  CQuadTreeNode::ForAllMatching((int)CColStore::ms_pQuadTree, &v12, v5);
  v7 = 85;
  for ( i = 0; i != 254; ++i )
  {
    if ( (CColStore::ms_pColPool->m_aFlags[i + 1] & 0x80u) == 0 )
    {
      m_aStorage = CColStore::ms_pColPool->m_aStorage;
      if ( (*CColStore::ms_pColPool->m_aStorage)[v7] )
      {
        v10 = &(*m_aStorage)[v7];
        if ( posn->x >= (float)(*(float *)&(*m_aStorage)[v7 - 41] + 110.0)
          && posn->x <= (float)(*(float *)(v10 - 33) + -110.0) )
        {
          v11 = posn->y;
          if ( v11 >= (float)(*(float *)(v10 - 29) + 110.0) && v11 <= (float)(*(float *)(v10 - 37) + -110.0) )
            CStreaming::RequestModel(i + 25001, 24);
        }
        (*m_aStorage)[v7] = 0;
      }
    }
    v7 += 44;
  }
}
// 6790C0: using guessed type void *SetIfCollisionIsRequired;
// 6792EC: using guessed type void *SetIfCollisionIsRequiredReducedBB;

//----- (002E2F90) --------------------------------------------------------
bool __fastcall CColStore::HasCollisionLoaded(const CVector *posn, int32 areaCode)
{
  CPlayerPed *PlayerPed; // r0
  void **v4; // r2
  void (*v5)(const CVector2D *, void *); // r2
  float y; // r3
  int v7; // r2
  int i; // r1
  int v9; // r3
  CPool<ColDef,ColDef>::StorageType *m_aStorage; // r2
  uint8 *v11; // r4
  uint8 *v12; // r2
  float v13; // s4
  bool result; // r0
  int v15; // r3
  CVector2D v16; // [sp+0h] [bp-10h] BYREF

  if ( areaCode == -1 )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed )
      areaCode = PlayerPed->m_areaCode;
    else
      areaCode = CGame::currArea;
  }
  entityAreaCode = areaCode;
  if ( areaCode == CGame::currArea )
    v4 = &SetIfCollisionIsRequired;
  else
    v4 = &SetIfCollisionIsRequiredReducedBB;
  v5 = (void (*)(const CVector2D *, void *))*v4;
  y = posn->y;
  v16.x = posn->x;
  v16.y = y;
  CQuadTreeNode::ForAllMatching((int)CColStore::ms_pQuadTree, &v16, v5);
  v7 = 1;
  for ( i = 85; ; i += 44 )
  {
    v9 = v7;
    if ( (CColStore::ms_pColPool->m_aFlags[v7] & 0x80u) == 0 )
    {
      m_aStorage = CColStore::ms_pColPool->m_aStorage;
      if ( (*CColStore::ms_pColPool->m_aStorage)[i] )
      {
        v11 = &(*m_aStorage)[i];
        v12 = &(*m_aStorage)[i];
        *v12 = 0;
        if ( posn->x >= (float)(*(float *)(v12 - 41) + 110.0) && posn->x <= (float)(*(float *)(v11 - 33) + -110.0) )
        {
          v13 = posn->y;
          if ( v13 >= (float)(*(float *)(v11 - 29) + 110.0)
            && v13 <= (float)(*(float *)(v11 - 37) + -110.0)
            && !*(v11 - 1) )
          {
            break;
          }
        }
      }
    }
    v7 = v9 + 1;
    if ( v9 >= 254 )
      return 1;
  }
  result = 0;
  if ( v9 <= 254 )
  {
    v15 = v9 - 1;
    do
    {
      if ( (CColStore::ms_pColPool->m_aFlags[v15 + 1] & 0x80u) == 0
        && &(*CColStore::ms_pColPool->m_aStorage)[i] != (uint8 *)((char *)&word_28 + 1) )
      {
        (*CColStore::ms_pColPool->m_aStorage)[i] = 0;
      }
      ++v15;
      i += 44;
      result = 0;
    }
    while ( v15 < 254 );
  }
  return result;
}
// 28: using guessed type __int16 word_28;
// 6790C0: using guessed type void *SetIfCollisionIsRequired;
// 6792EC: using guessed type void *SetIfCollisionIsRequiredReducedBB;

//----- (002E30E8) --------------------------------------------------------
void CColStore::RemoveAllCollision()
{
  int v0; // r5
  uint8 *p_m_flags; // r4

  v0 = 0;
  p_m_flags = &CStreaming::ms_aInfoForModel[25001].m_flags;
  do
  {
    if ( (CColStore::ms_pColPool->m_aFlags[v0 + 1] & 0x80u) == 0 && (*p_m_flags & 6) == 0 )
      CStreaming::RemoveModel(v0 + 25001);
    ++v0;
    p_m_flags += 20;
  }
  while ( v0 != 254 );
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002E3140) --------------------------------------------------------
void CColStore::LoadAllBoundingBoxes()
{
  int i; // r5

  if ( CColAccel::isCacheLoading() )
  {
    sub_19A90C();
  }
  else
  {
    for ( i = 0; i != 254; ++i )
    {
      if ( (CColStore::ms_pColPool->m_aFlags[i + 1] & 0x80u) == 0 )
      {
        CStreaming::RequestModel(i + 25001, 16);
        CStreaming::LoadAllRequestedModels(1);
        CStreaming::RemoveModel(i + 25001);
      }
    }
  }
}

//----- (002E319C) --------------------------------------------------------
void CColStore::LoadAllCollision()
{
  int i; // r5

  for ( i = 0; i != 254; ++i )
  {
    if ( (CColStore::ms_pColPool->m_aFlags[i + 1] & 0x80u) == 0 )
    {
      CStreaming::RequestModel(i + 25001, 16);
      CStreaming::LoadAllRequestedModels(1);
      CStreaming::RemoveModel(i + 25001);
    }
  }
}

//----- (002E31F0) --------------------------------------------------------
void CColStore::BoundingBoxesPostProcess()
{
  int v0; // r4
  int v1; // r5
  float32x4_t v2; // q4
  CPool<ColDef,ColDef>::StorageType *m_aStorage; // r9
  __int64 v4; // kr00_8
  __int64 v5; // kr08_8
  __int64 v6; // kr10_8
  float32x4_t *v7; // r0
  float32x4_t v8; // q8
  int v9; // [sp+20h] [bp-38h]

  v0 = 1;
  v1 = 84;
  v2.n128_u64[0] = 0x42F00000C2F00000LL;
  v2.n128_u64[1] = 0xC2F0000042F00000LL;
  do
  {
    if ( (CColStore::ms_pColPool->m_aFlags[v0] & 0x80u) == 0 )
    {
      m_aStorage = CColStore::ms_pColPool->m_aStorage;
      if ( CColAccel::isCacheLoading() )
      {
        CColAccel::getColDef((ColDef *)&(*m_aStorage)[v1 - 40]);
      }
      else
      {
        v9 = *(_DWORD *)&(*m_aStorage)[v1];
        v4 = *(_QWORD *)&(*m_aStorage)[v1 - 24];
        v5 = *(_QWORD *)&(*m_aStorage)[v1 - 16];
        v6 = *(_QWORD *)&(*m_aStorage)[v1 - 8];
        v7 = (float32x4_t *)&(*m_aStorage)[v1 - 40];
        v8 = vaddq_f32(*v7, v2);
        *v7 = v8;
        CColAccel::addColDef(
          v8.n128_f32[0],
          v8.n128_i32[1],
          v8.n128_i32[2],
          v8.n128_i32[3],
          v4,
          SHIDWORD(v4),
          v5,
          SHIDWORD(v5),
          v6,
          SWORD2(v6),
          v9);
      }
      CQuadTreeNode::AddItem(CColStore::ms_pQuadTree, &(*m_aStorage)[v1 - 40], (const CRect *)&(*m_aStorage)[v1 - 40]);
    }
    ++v0;
    v1 += 44;
  }
  while ( v0 != 255 );
}

//----- (002E32D8) --------------------------------------------------------
void __fastcall CColTrianglePlane::Set(CColTrianglePlane *this, const CollisionVector *aVectors, CColTriangle *tri)
{
  __int64 v4; // kr00_8
  const CollisionVector *v5; // r0
  const CollisionVector *v6; // r2
  float x; // s16
  float y; // s18
  float z; // s20
  const CollisionVector *v10; // r0
  RwReal v11; // s0
  RwReal v12; // s4
  float v13; // s10
  RwReal v14; // s6
  RwReal v15; // s8
  __int64 v16; // d16
  __int64 v17; // kr08_8
  float v18; // s2
  float v19; // s8
  float v20; // s4
  uint8 v21; // r0
  float v22; // s8
  CVector v23; // [sp+0h] [bp-58h] BYREF
  CVector v1; // [sp+Ch] [bp-4Ch] BYREF
  CVector v25; // [sp+18h] [bp-40h] BYREF
  CVector v26; // [sp+28h] [bp-30h] BYREF

  v4 = *(_QWORD *)&tri->m_nIndex1;
  v5 = &aVectors[tri->m_nIndex1];
  v6 = &aVectors[tri->m_nIndex3];
  x = v5->x;
  y = v5->y;
  z = v5->z;
  v10 = &aVectors[HIDWORD(v4)];
  v11 = v6->x - x;
  v12 = v6->z - z;
  v13 = v10->z;
  v14 = v10->x - x;
  v15 = v10->y - y;
  v1.y = v6->y - y;
  v1.x = v11;
  v1.z = v12;
  v23.y = v15;
  v23.x = v14;
  v23.z = v13 - z;
  CrossProduct(&v25, &v1, &v23);
  v26 = v25;
  CVector::Normalise(&v26);
  v16 = *(_QWORD *)&v26.x;
  this->m_compressedNormal.z = v26.z;
  *(_QWORD *)&this->m_compressedNormal.x = v16;
  v17 = *(_QWORD *)&v26.x;
  v18 = v26.z;
  v19 = fabsf(v26.x);
  v20 = fabsf(v26.y);
  this->m_compressedNormalOffset = (float)((float)(x * v26.x) + (float)(y * v26.y)) + (float)(z * v26.z);
  if ( v19 <= v20 || v19 <= fabsf(v18) )
  {
    v22 = v18;
    if ( v18 < 0.0 )
      v22 = -v18;
    if ( v20 <= v22 )
    {
      v21 = 5;
      if ( v18 > 0.0 )
        v21 = 4;
    }
    else
    {
      v21 = 3;
      if ( *((float *)&v17 + 1) > 0.0 )
        v21 = 2;
    }
  }
  else
  {
    v21 = *(float *)&v17 <= 0.0;
  }
  this->m_nPrincipalAxis = v21;
}

//----- (002E341C) --------------------------------------------------------
void CTempColModels::Shutdown()
{
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelBBox);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelPed1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelPed2);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelDoor1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelBumper1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelPanel1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelBonnet1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelBoot1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelWheel1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelBodyPart1);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelBodyPart2);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelWeapon);
  CColModel::RemoveCollisionVolumes(CTempColModels::ms_colModelCutObj);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[1]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[2]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[3]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[4]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[5]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[6]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[7]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[8]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[9]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[10]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[11]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[12]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[13]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[14]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[15]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[16]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[17]);
  CColModel::RemoveCollisionVolumes(&CTempColModels::ms_colModelCutObj[18]);
  sub_195058(&CTempColModels::ms_colModelCutObj[19]);
}

//----- (002E3574) --------------------------------------------------------
void __fastcall CAutoPilot::ModifySpeed(CAutoPilot *this, float NewSpeed)
{
  float32x2_t v2; // d2
  float32x2_t v3; // d9
  float TimeToGetToNextLink; // s0
  float v6; // s2
  unsigned int Address; // r0
  unsigned int v8; // r2
  float v9; // s16
  int v10; // r11
  CCarPathLink *v11; // r9
  CCarPathLink *v12; // r5
  int DirXb; // s22
  float v14; // r8
  int NewLane; // r6
  float v16; // r0
  float ActualSpeed; // s20
  float v18; // s4
  RwReal v19; // s0
  RwReal v20; // s2
  float v21; // s6
  float CoorsY; // s0
  float CoorsX; // s4
  Int32 v24; // s2
  int v25; // [sp+Ch] [bp-7Ch]
  int v26; // [sp+10h] [bp-78h]
  int InvertDirOldLink; // [sp+14h] [bp-74h]
  int OldLane; // [sp+18h] [bp-70h]
  int DirYb; // [sp+1Ch] [bp-6Ch]
  int InvertDirNewLink; // [sp+20h] [bp-68h]
  CCarPathLink *v31; // [sp+24h] [bp-64h]
  CCarPathLink *v32; // [sp+28h] [bp-60h]
  int v33; // [sp+2Ch] [bp-5Ch]
  CVector endCoors; // [sp+30h] [bp-58h] BYREF
  CVector startCoors; // [sp+3Ch] [bp-4Ch] BYREF

  v2.n64_f32[0] = NewSpeed;
  v3.n64_u32[0] = 1008981770;
  TimeToGetToNextLink = (float)this->TimeToGetToNextLink;
  v6 = (float)(CTimer::m_snTimeInMilliseconds - this->TimeToLeaveLink);
  Address = this->OldLink.Address;
  LODWORD(this->ActualSpeed) = vmax_f32(v2, v3).n64_u32[0];
  if ( ThePaths.pNodes[Address >> 10] )
  {
    v8 = this->NewLink.Address;
    if ( ThePaths.pNodes[v8 >> 10] )
    {
      v9 = v6 / TimeToGetToNextLink;
      v33 = v8 & 0x3FF;
      v10 = Address & 0x3FF;
      v11 = ThePaths.pLinks[Address >> 10];
      v32 = ThePaths.pLinks[v8 >> 10];
      v12 = &v11[Address & 0x3FF];
      v31 = &v32[v8 & 0x3FF];
      DirXb = v31->DirXb;
      InvertDirNewLink = this->InvertDirNewLink;
      OldLane = this->OldLane;
      InvertDirOldLink = this->InvertDirOldLink;
      DirYb = v31->DirYb;
      v26 = v12->DirYb;
      v25 = v12->DirXb;
      v14 = CCarPathLink::OneWayLaneOffset(v12);
      NewLane = this->NewLane;
      v16 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[this->NewLink.Address >> 10][this->NewLink.Address & 0x3FF]);
      ActualSpeed = this->ActualSpeed;
      v18 = (float)(v14 + (float)OldLane) * 5.4;
      v19 = (float)((float)((float)((float)v26 * 0.01) * (float)InvertDirOldLink) * v18)
          + (float)((float)v11[v10].CoorsX * 0.125);
      v20 = (float)((float)v12->CoorsY * 0.125)
          - (float)((float)((float)((float)v25 * 0.01) * (float)InvertDirOldLink) * v18);
      v21 = (float)(v16 + (float)NewLane) * 5.4;
      startCoors.z = 0.0;
      startCoors.y = v20;
      startCoors.x = v19;
      CoorsY = (float)v31->CoorsY;
      CoorsX = (float)v32[v33].CoorsX;
      endCoors.z = 0.0;
      endCoors.y = (float)(CoorsY * 0.125)
                 - (float)((float)((float)((float)DirXb * 0.01) * (float)InvertDirNewLink) * v21);
      endCoors.x = (float)((float)((float)((float)DirYb * 0.01) * (float)InvertDirNewLink) * v21)
                 + (float)(CoorsX * 0.125);
      v24 = (int)(float)((float)(1000.0 / ActualSpeed)
                       * CCurves::CalcSpeedScaleFactor(
                           &startCoors,
                           &endCoors,
                           (float)((float)v12->DirXb * 0.01) * (float)this->InvertDirOldLink,
                           (float)((float)v12->DirYb * 0.01) * (float)this->InvertDirOldLink,
                           (float)((float)v31->DirXb * 0.01) * (float)this->InvertDirNewLink,
                           (float)((float)v31->DirYb * 0.01) * (float)this->InvertDirNewLink));
      this->TimeToGetToNextLink = v24;
      this->TimeToLeaveLink = (int)(float)((float)CTimer::m_snTimeInMilliseconds - (float)(v9 * (float)v24));
    }
  }
}
// 2E359A: variable 'v2' is possibly undefined
// 2E359A: variable 'v3' is possibly undefined

//----- (002E3860) --------------------------------------------------------
void __fastcall CAutoPilot::RemoveOnePathNode(CAutoPilot *this)
{
  Int16 v1; // r1
  int v2; // r1
  CNodeAddress *v3; // r2

  v1 = this->NumPathNodes - 1;
  this->NumPathNodes = v1;
  if ( v1 >= 1 )
  {
    v2 = 0;
    do
    {
      v3 = &this->OldNode + v2;
      v2 = (__int16)(v2 + 1);
      v3[26] = v3[27];
    }
    while ( v2 < this->NumPathNodes );
  }
}

//----- (002E3890) --------------------------------------------------------
int CBridge::ShouldLightsBeFlashing()
{
  return 0;
}

//----- (002E3896) --------------------------------------------------------
bool __fastcall CBridge::ThisIsABridgeObjectMovingUp(UInt32 MI)
{
  return 0;
}

//----- (002E389C) --------------------------------------------------------
float __fastcall CCarAI::FindSwitchDistanceClose(CVehicle *pVehicle)
{
  return (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance;
}

//----- (002E38B0) --------------------------------------------------------
float __fastcall CCarAI::FindSwitchDistanceFar(CVehicle *pVehicle)
{
  if ( *(_BYTE *)&pVehicle->m_nVehicleFlags << 31 )
    return 50.0;
  else
    return (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
}

//----- (002E38E0) --------------------------------------------------------
bool __fastcall CCarAI::EntitiesGoHeadOn(CEntity *pEnt1, CEntity *pEnt2)
{
  CMatrix *m_pMat; // r0
  CMatrix *v5; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r0
  float z; // s4
  float v9; // s10
  RwReal v10; // s0
  CMatrix *v11; // r0
  float xy; // s4
  float yy; // s2
  float zy; // s0
  float m_heading; // r5
  float v16; // r6
  float x; // s16
  float y; // s20
  float v19; // s18
  CMatrix *v21; // r0
  float v22; // s4
  float v23; // s2
  float v24; // s0
  float v25; // r4
  float v26; // r5
  CVector v27; // [sp+4h] [bp-34h] BYREF

  m_pMat = pEnt2->m_pMat;
  v5 = pEnt1->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pEnt2->m_transform;
  p_m_transform = (CSimpleTransform *)&v5->tx;
  z = p_tx->m_translate.z;
  if ( !v5 )
    p_m_transform = &pEnt1->m_transform;
  v9 = p_m_transform->m_translate.z;
  v10 = p_m_transform->m_translate.x - p_tx->m_translate.x;
  v27.y = p_m_transform->m_translate.y - p_tx->m_translate.y;
  v27.x = v10;
  v27.z = v9 - z;
  CVector::Normalise(&v27);
  v11 = pEnt1->m_pMat;
  if ( v11 )
  {
    xy = v11->xy;
    yy = v11->yy;
    zy = v11->zy;
  }
  else
  {
    m_heading = pEnt1->m_transform.m_heading;
    v16 = sinf(m_heading);
    yy = cosf(m_heading);
    zy = 0.0;
    LODWORD(xy) = LODWORD(v16) ^ 0x80000000;
  }
  x = v27.x;
  y = v27.y;
  v19 = v27.z;
  if ( (float)((float)((float)(xy * v27.x) + (float)(yy * v27.y)) + (float)(zy * v27.z)) > -0.8 )
    return 0;
  v21 = pEnt2->m_pMat;
  if ( v21 )
  {
    v22 = v21->xy;
    v23 = v21->yy;
    v24 = v21->zy;
  }
  else
  {
    v25 = pEnt2->m_transform.m_heading;
    v26 = sinf(v25);
    v23 = cosf(v25);
    v24 = 0.0;
    LODWORD(v22) = LODWORD(v26) ^ 0x80000000;
  }
  return (float)((float)((float)(v22 * x) + (float)(v23 * y)) + (float)(v24 * v19)) >= 0.8;
}

//----- (002E3A14) --------------------------------------------------------
void __fastcall CCarAI::BackToCruisingIfNoWantedLevel(CVehicle *pVehicle)
{
  if ( *(_BYTE *)&pVehicle->m_nVehicleFlags << 31
    && ((*((_BYTE *)FindPlayerWanted(-1) + 30) & 4) != 0
     || *(_BYTE *)&pVehicle->m_nVehicleFlags << 31
     && (FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN
      || *((unsigned __int8 *)FindPlayerWanted(-1) + 30) << 29
      || CCullZones::NoPolice() == 1)) )
  {
    CCarCtrl::JoinCarWithRoadSystem(pVehicle);
    *(_WORD *)&pVehicle->AutoPilot.DrivingMode = 256;
    *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) &= ~0x8000u;
    if ( CCullZones::NoPolice() == 1 )
      pVehicle->AutoPilot.Mission = 0;
  }
}

//----- (002E3A8C) --------------------------------------------------------
void __fastcall CCarAI::UpdateCarAI(CVehicle *pVehicle)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float32x2_t v4; // d8
  int RecordingNumber; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r10
  int Mission; // r0
  eWantedLevel m_WantedLevel; // r1
  int v10; // r0
  float v11; // s0
  float v12; // s0
  float v13; // s2
  unsigned int v14; // r0
  int v15; // r0
  CMatrix *v16; // r0
  CSimpleTransform *v17; // r5
  int (**v18)(void); // s16
  CSimpleTransform *v19; // r1
  float v20; // s18
  CMatrix *v21; // r0
  CSimpleTransform *v22; // r1
  float v23; // s20
  float v24; // s22
  CMatrix *v25; // r0
  CSimpleTransform *v26; // r1
  float v27; // s24
  float v28; // s26
  CMatrix *v29; // r0
  float v30; // s0
  float v31; // s2
  CMatrix *v32; // r0
  CSimpleTransform *v33; // r5
  int (**v34)(void); // s16
  CSimpleTransform *v35; // r1
  float v36; // s18
  CMatrix *v37; // r0
  CSimpleTransform *v38; // r1
  float v39; // s20
  float v40; // s22
  CMatrix *v41; // r0
  CSimpleTransform *v42; // r1
  float v43; // s24
  float v44; // s26
  CMatrix *v45; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r5
  int (**v48)(void); // s16
  CSimpleTransform *p_tx; // r1
  float x; // s18
  CMatrix *v51; // r0
  CSimpleTransform *v52; // r1
  float v53; // s20
  float v54; // s22
  CMatrix *v55; // r0
  CSimpleTransform *v56; // r1
  float y; // s24
  float v58; // s26
  CMatrix *v59; // r0
  float v60; // s16
  CEntity *PlayerEntity; // r0
  _BOOL4 v62; // r0
  Int8 v63; // r0
  CMatrix *v64; // r0
  CSimpleTransform *v65; // r5
  int (**v66)(void); // s16
  CSimpleTransform *v67; // r1
  float v68; // s18
  CMatrix *v69; // r0
  CSimpleTransform *v70; // r1
  float v71; // s20
  float v72; // s22
  CMatrix *v73; // r0
  CSimpleTransform *v74; // r1
  float v75; // s24
  float v76; // s26
  CMatrix *v77; // r0
  float v78; // s16
  float v79; // s0
  CMatrix *v80; // r0
  CSimpleTransform *v81; // r5
  int (**v82)(void); // s16
  CSimpleTransform *v83; // r1
  float v84; // s18
  CMatrix *v85; // r0
  CSimpleTransform *v86; // r1
  float v87; // s20
  float v88; // s22
  CMatrix *v89; // r0
  CSimpleTransform *v90; // r1
  float v91; // s24
  float v92; // s26
  CMatrix *v93; // r0
  float v94; // s16
  CEntity *v95; // r0
  _BOOL4 v96; // r0
  CMatrix *v97; // r0
  CSimpleTransform *v98; // r5
  int (**v99)(void); // s16
  CSimpleTransform *v100; // r1
  float v101; // s18
  CMatrix *v102; // r0
  CSimpleTransform *v103; // r1
  float v104; // s20
  float v105; // s22
  CMatrix *v106; // r0
  CSimpleTransform *v107; // r1
  float v108; // s24
  float v109; // s26
  CMatrix *v110; // r0
  float v111; // s0
  CMatrix *v112; // r0
  CSimpleTransform *v113; // r5
  CSimpleTransform *v114; // r1
  CMatrix *v115; // r0
  CSimpleTransform *v116; // r1
  float v117; // s0
  CMatrix *v118; // r0
  CSimpleTransform *v119; // r1
  float32x2_t v120; // d16
  CMatrix *v121; // r0
  CSimpleTransform *v122; // r1
  float32x2_t v123; // d16
  CMatrix *v124; // r0
  CSimpleTransform *v125; // r1
  float32x2_t v126; // d16
  CMatrix *v127; // r0
  CSimpleTransform *v128; // r1
  float32x2_t v129; // d16
  unsigned int v130; // r0
  CEntity *pTargetEntity; // r0
  CMatrix *v132; // r1
  CMatrix *v133; // r2
  CSimpleTransform *v134; // r3
  float *p_x; // r1
  CVehicle *v136; // r5
  CEntity *v137; // r1
  CMatrix *v138; // r0
  CMatrix *v139; // r2
  CSimpleTransform *v140; // r3
  float *v141; // r0
  float v142; // s0
  float v143; // s2
  CEntity *v144; // r0
  CMatrix *v145; // r1
  CMatrix *v146; // r2
  CSimpleTransform *v147; // r3
  float *v148; // r1
  CEntity *v149; // r0
  CMatrix *v150; // r1
  CMatrix *v151; // r2
  CSimpleTransform *v152; // r3
  float *v153; // r1
  float v154; // s6
  float v155; // s0
  CVehicle::CVehicleFlags v156; // r0
  float v157; // s0
  float v158; // s2
  eWantedLevel v159; // r1
  UInt8 v160; // r0
  CMatrix *v161; // r0
  CSimpleTransform *v162; // r1
  float32x2_t v163; // d16
  CMatrix *v164; // r0
  CSimpleTransform *v165; // r5
  int (**v166)(void); // s16
  CSimpleTransform *v167; // r1
  float v168; // s18
  CMatrix *v169; // r0
  CSimpleTransform *v170; // r1
  float v171; // s20
  float v172; // s22
  CMatrix *v173; // r0
  CSimpleTransform *v174; // r1
  float v175; // s24
  float v176; // s26
  CMatrix *v177; // r0
  float v178; // s16
  CMatrix *v179; // r0
  CSimpleTransform *v180; // r5
  int (**v181)(void); // s16
  CSimpleTransform *v182; // r1
  float v183; // s18
  CMatrix *v184; // r0
  int m_iAccumulatedTime; // s20
  float v186; // s22
  float v187; // s0
  float v188; // s4
  float v189; // s16
  float v190; // s20
  CMatrix *v191; // r0
  CSimpleTransform *v192; // r5
  int (**v193)(void); // s16
  CSimpleTransform *v194; // r1
  float v195; // s18
  CMatrix *v196; // r0
  CSimpleTransform *v197; // r1
  float v198; // s20
  float v199; // s22
  CMatrix *v200; // r0
  CSimpleTransform *v201; // r1
  float v202; // s24
  float v203; // s26
  CMatrix *v204; // r0
  CMatrix *v205; // r0
  CSimpleTransform *v206; // r5
  int (**v207)(void); // s16
  CSimpleTransform *v208; // r1
  float v209; // s18
  CMatrix *v210; // r0
  CSimpleTransform *v211; // r1
  float v212; // s20
  float v213; // s22
  CMatrix *v214; // r0
  CSimpleTransform *v215; // r1
  float v216; // s24
  float v217; // s26
  CMatrix *v218; // r0
  float v219; // s16
  float v220; // s0
  CEntity *v221; // r0
  CMatrix *v222; // r1
  CMatrix *v223; // r2
  CSimpleTransform *v224; // r3
  float *v225; // r1
  CEntity *v226; // r0
  CMatrix *v227; // r1
  CMatrix *v228; // r2
  CSimpleTransform *v229; // r3
  float *v230; // r1
  float v231; // s0
  float v232; // s2
  CEntity *v233; // r0
  CMatrix *v234; // r1
  CMatrix *v235; // r2
  CSimpleTransform *v236; // r3
  float *v237; // r1
  CEntity *v238; // r0
  CMatrix *v239; // r1
  CMatrix *v240; // r2
  CSimpleTransform *v241; // r3
  float *v242; // r1
  float v243; // s0
  float v244; // s2
  CEntity *v245; // r0
  CMatrix *v246; // r1
  CMatrix *v247; // r2
  CSimpleTransform *v248; // r3
  float *v249; // r1
  float v250; // s0
  float v251; // s2
  CEntity *v252; // r0
  CMatrix *v253; // r1
  CMatrix *v254; // r2
  CSimpleTransform *v255; // r3
  float *v256; // r1
  Int8 v257; // r0
  int v258; // r0
  Int8 v259; // r1
  int v260; // r0
  Int8 v261; // r1
  CVehicle *PlayerVehicle; // r0
  CVehicle *v263; // r0
  float v264; // s0
  float v265; // s2
  float v266; // s4
  int v267; // r1
  CVehicle *v268; // r0
  CVehicle *v269; // r0
  CVehicle *v270; // r0
  CVehicle *v271; // r0
  CVehicle *v272; // r0
  float v273; // s4
  float v274; // s0
  float v275; // s2
  CVehicle *v276; // r0
  CVehicle *v277; // r0
  float *v278; // r5
  CVehicle *v279; // r0
  Int8 v280; // r0
  CPed *pDriver; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  CTaskComplexSequence *v283; // r5
  CTaskComplexSequence *v284; // r8
  CTaskComplexEnterCarAsDriver *v285; // r5
  CTaskSimpleGangDriveBy *v286; // r5
  CPlayerPed *PlayerPed; // r0
  float v288; // s0
  UInt32 v289; // r0
  unsigned int v290; // r2
  UInt32 LastTimeMoving; // r0
  CVehicle *v292; // r0
  UInt32 v293; // r0
  int TempAction; // r0
  bool v295; // zf
  int v296; // r0
  bool v297; // cc
  CMatrix *v298; // r0
  __int64 v299; // d16
  UInt32 v300; // r0
  int DrivingMode; // r1
  int v302; // r3
  float m_heading; // r5
  const CVector *PlayerSpeed; // r0
  const CVector *v305; // r0
  float xy; // s16
  float v307; // s18
  CMatrix *v308; // r1
  CMatrix *v309; // r0
  CSimpleTransform *v310; // r5
  CSimpleTransform *v311; // r1
  float v312; // s16
  CMatrix *v313; // r0
  CSimpleTransform *v314; // r1
  float v315; // s18
  float v316; // s20
  float v317; // s16
  float v318; // s18
  float v319; // s24
  const CVector *v320; // r0
  CMatrix *v321; // r0
  CSimpleTransform *v322; // r1
  float32x2_t v323; // d16
  unsigned __int64 v324; // d1
  CMatrix *v325; // r0
  CSimpleTransform *v326; // r1
  float32x2_t v327; // d16
  float32x2_t v328; // d1
  const CVector *v329; // r0
  float v330; // s16
  float v331; // s18
  float z; // s20
  const CVector *v333; // r0
  const CVector *v334; // r0
  float v335; // s2
  float v336; // s0
  CMatrix *v337; // r0
  float ATanOfXY; // s16
  const CVector *v339; // r0
  CMatrix *v340; // r0
  CSimpleTransform *v341; // r5
  CSimpleTransform *v342; // r1
  float32x2_t v343; // d16
  unsigned __int64 v344; // d1
  CMatrix *v345; // r0
  float v346; // s16
  float v347; // s18
  float v348; // s20
  float v349; // s22
  float v350; // s24
  float v351; // s26
  float xx; // s0
  float yx; // s2
  float zx; // s4
  float v355; // r5
  float v356; // r8
  float v357; // s0
  Int8 v358; // r0
  float SpeedMultiplierWithSpeedFromNodes; // s0
  float SpeedMultiplier; // s2
  float v361; // s4
  CVehicle *v362; // r0
  int v363; // r6
  CPlayerPed *v364; // r0
  int v365; // r5
  CVehicle *v366; // r0
  CVehicle *v367; // r0
  int v368; // r0
  bool v369; // zf
  int32 m_nSize; // r2
  int v371; // lr
  int v372; // r6
  int v373; // r5
  uint8 *v374; // r6
  CMatrix *v375; // r0
  int v376; // r1
  CSimpleTransform *v377; // r3
  uint8 *v378; // r0
  float32x2_t v379; // d16
  unsigned __int64 v380; // d2
  UInt8 v381; // r0
  UInt8 v382; // r3
  CMatrix *v383; // r0
  CSimpleTransform *v384; // r1
  _BOOL4 v385; // r0
  CMatrix *v386; // r0
  CSimpleTransform *v387; // r1
  CMatrix *v388; // r0
  float v389; // s0
  Int8 v390; // r2
  int v391; // r3
  int v392; // r2
  CMatrix *v393; // r0
  eWantedLevel v394; // r1
  int v395; // r0
  float v396; // s0
  CEntity::CEntityInfo v397; // r0
  int VehicleCreatedBy; // r0
  CEntity::CEntityInfo v399; // r0
  float v400; // s0
  float v401; // s2
  CEntity::CEntityInfo m_info; // r1
  eWantedLevel v403; // r5
  Int8 v404; // r1
  char v405; // r0
  eWantedLevel v406; // r0
  char v407; // r0
  char v408; // r0
  char v409; // r0
  CVector v410; // [sp+Ch] [bp-94h] BYREF
  CEventScriptCommand v411; // [sp+18h] [bp-88h] BYREF
  CVector v412; // [sp+30h] [bp-70h] BYREF
  CVector v413; // [sp+40h] [bp-60h] BYREF
  CVector v414; // [sp+4Ch] [bp-54h] BYREF

  RecordingNumber = pVehicle->AutoPilot.RecordingNumber;
  if ( RecordingNumber >= 0 && !CVehicleRecording::bUseCarAI[RecordingNumber] || pVehicle->m_vehicleType == 3 )
    return;
  if ( pVehicle->AutoPilot.Mission == 59
    && (FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel < WANTED_LEVEL3 || !FindPlayerVehicle(-1, 0)) )
  {
    pVehicle->AutoPilot.Mission = 22;
    pVehicle->AutoPilot.TargetCoors.x = -6000.0;
    pVehicle->AutoPilot.TargetCoors.y = 10000.0;
    pVehicle->AutoPilot.TargetCoors.z = 500.0;
  }
  p_m_nVehicleFlags = &pVehicle->m_nVehicleFlags;
  if ( *(_BYTE *)&pVehicle->m_nVehicleFlags << 31 )
  {
    if ( (Mission = (unsigned __int8)pVehicle->AutoPilot.Mission, (unsigned int)(Mission - 43) <= 0xC)
      && ((1 << (Mission - 43)) & 0x1803) != 0
      || (unsigned int)(Mission - 2) < 4 )
    {
      m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
      LOBYTE(v10) = 25;
      switch ( m_WantedLevel )
      {
        case WANTED_CLEAN:
          v11 = (float)((float)((float)rand() * 4.6566e-10) * 4.0) + 12.0;
          goto LABEL_22;
        case WANTED_LEVEL1:
          break;
        case WANTED_LEVEL2:
          LOBYTE(v10) = 34;
          break;
        case WANTED_LEVEL3:
          v12 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
          v13 = 0.9;
          goto LABEL_21;
        case WANTED_LEVEL4:
          v12 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
          v13 = 1.2;
          goto LABEL_21;
        case WANTED_LEVEL5:
          v11 = (float)(pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0) * 1.25;
          goto LABEL_22;
        case WANTED_LEVEL6:
          v12 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
          v13 = 1.3;
LABEL_21:
          v11 = v12 * v13;
LABEL_22:
          v10 = (int)v11;
          break;
        default:
          LOBYTE(v10) = 0;
          break;
      }
      pVehicle->AutoPilot.CruiseSpeed = v10;
    }
  }
  v14 = *(_BYTE *)&pVehicle->m_info >> 3;
  if ( v14 <= 0xC )
  {
    v15 = 1 << v14;
    if ( (v15 & 0x100C) != 0 )
    {
      switch ( pVehicle->AutoPilot.Mission )
      {
        case 2:
          FindPlayerCoors((CVector *)&v411, -1);
          m_pMat = pVehicle->m_pMat;
          p_m_transform = &pVehicle->m_transform;
          v48 = v411._vptr$CEvent;
          p_tx = &pVehicle->m_transform;
          if ( m_pMat )
            p_tx = (CSimpleTransform *)&m_pMat->tx;
          x = p_tx->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v51 = pVehicle->m_pMat;
          v52 = &pVehicle->m_transform;
          v53 = v414.x;
          if ( v51 )
            v52 = (CSimpleTransform *)&v51->tx;
          v54 = v52->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v55 = pVehicle->m_pMat;
          v56 = &pVehicle->m_transform;
          y = v413.y;
          if ( v55 )
            v56 = (CSimpleTransform *)&v55->tx;
          v58 = v56->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v59 = pVehicle->m_pMat;
          if ( v59 )
            p_m_transform = (CSimpleTransform *)&v59->tx;
          v60 = sqrtf(
                  (float)((float)(*(float *)&v48 - x) * (float)(v53 - v54))
                + (float)((float)(y - v58) * (float)(v412.y - p_m_transform->m_translate.y)));
          if ( v60 >= (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
          {
            PlayerEntity = FindPlayerEntity(-1);
            v62 = CCarAI::EntitiesGoHeadOn(PlayerEntity, pVehicle);
            if ( v60 >= 40.0 || !v62 )
              goto LABEL_367;
          }
          v63 = 3;
          goto LABEL_201;
        case 3:
          FindPlayerCoors((CVector *)&v411, -1);
          v64 = pVehicle->m_pMat;
          v65 = &pVehicle->m_transform;
          v66 = v411._vptr$CEvent;
          v67 = &pVehicle->m_transform;
          if ( v64 )
            v67 = (CSimpleTransform *)&v64->tx;
          v68 = v67->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v69 = pVehicle->m_pMat;
          v70 = &pVehicle->m_transform;
          v71 = v414.x;
          if ( v69 )
            v70 = (CSimpleTransform *)&v69->tx;
          v72 = v70->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v73 = pVehicle->m_pMat;
          v74 = &pVehicle->m_transform;
          v75 = v413.y;
          if ( v73 )
            v74 = (CSimpleTransform *)&v73->tx;
          v76 = v74->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v77 = pVehicle->m_pMat;
          if ( v77 )
            v65 = (CSimpleTransform *)&v77->tx;
          v78 = sqrtf(
                  (float)((float)(*(float *)&v66 - v68) * (float)(v71 - v72))
                + (float)((float)(v75 - v76) * (float)(v412.y - v65->m_translate.y)));
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
            v79 = 50.0;
          else
            v79 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v78 > v79 )
          {
            FindPlayerCoors((CVector *)&v411, -1);
            if ( CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, (const CVector *)&v411, 1, 0) )
              goto LABEL_365;
            v257 = 2;
            goto LABEL_276;
          }
          if ( FindPlayerVehicle(-1, 0) )
          {
            PlayerVehicle = FindPlayerVehicle(-1, 0);
            if ( CPhysical::GetHasCollidedWith(pVehicle, PlayerVehicle)
              && (unsigned __int8)(pVehicle->AutoPilot.TempAction - 7) >= 2u )
            {
              v263 = FindPlayerVehicle(-1, 0);
              v264 = v263->m_vecMoveSpeed.x * v263->m_vecMoveSpeed.x;
              v265 = v263->m_vecMoveSpeed.y * v263->m_vecMoveSpeed.y;
              v266 = v263->m_vecMoveSpeed.z * v263->m_vecMoveSpeed.z;
              pVehicle->AutoPilot.TempAction = 3;
              v267 = 50;
              if ( sqrtf((float)(v264 + v265) + v266) < 0.05 )
                v267 = 800;
              pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + v267;
            }
          }
          if ( FindPlayerVehicle(-1, 0)
            && (v268 = FindPlayerVehicle(-1, 0),
                sqrtf(
                  (float)((float)(v268->m_vecMoveSpeed.x * v268->m_vecMoveSpeed.x)
                        + (float)(v268->m_vecMoveSpeed.y * v268->m_vecMoveSpeed.y))
                + (float)(v268->m_vecMoveSpeed.z * v268->m_vecMoveSpeed.z)) < 0.05) )
          {
            pVehicle->GetOutOfCarTimer = (unsigned int)(float)((float)(CTimer::ms_fTimeStep * 16.667)
                                                             + (float)pVehicle->GetOutOfCarTimer);
          }
          else
          {
            pVehicle->GetOutOfCarTimer = 0;
          }
          if ( FindPlayerVehicle(-1, 0) )
          {
            v271 = FindPlayerVehicle(-1, 0);
            if ( !CVehicle::IsUpsideDown(v271) )
            {
              v272 = FindPlayerVehicle(-1, 0);
              v273 = v272->m_vecMoveSpeed.z * v272->m_vecMoveSpeed.z;
              v274 = (float)(v272->m_vecMoveSpeed.x * v272->m_vecMoveSpeed.x)
                   + (float)(v272->m_vecMoveSpeed.y * v272->m_vecMoveSpeed.y);
              v275 = 0.05;
              goto LABEL_315;
            }
          }
          goto LABEL_317;
        case 4:
          FindPlayerCoors((CVector *)&v411, -1);
          v80 = pVehicle->m_pMat;
          v81 = &pVehicle->m_transform;
          v82 = v411._vptr$CEvent;
          v83 = &pVehicle->m_transform;
          if ( v80 )
            v83 = (CSimpleTransform *)&v80->tx;
          v84 = v83->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v85 = pVehicle->m_pMat;
          v86 = &pVehicle->m_transform;
          v87 = v414.x;
          if ( v85 )
            v86 = (CSimpleTransform *)&v85->tx;
          v88 = v86->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v89 = pVehicle->m_pMat;
          v90 = &pVehicle->m_transform;
          v91 = v413.y;
          if ( v89 )
            v90 = (CSimpleTransform *)&v89->tx;
          v92 = v90->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v93 = pVehicle->m_pMat;
          if ( v93 )
            v81 = (CSimpleTransform *)&v93->tx;
          v94 = sqrtf(
                  (float)((float)(*(float *)&v82 - v84) * (float)(v87 - v88))
                + (float)((float)(v91 - v92) * (float)(v412.y - v81->m_translate.y)));
          if ( v94 >= (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
          {
            v95 = FindPlayerEntity(-1);
            v96 = CCarAI::EntitiesGoHeadOn(v95, pVehicle);
            if ( v94 >= 40.0 || !v96 )
              goto LABEL_367;
          }
          v63 = 5;
          goto LABEL_201;
        case 5:
          FindPlayerCoors((CVector *)&v411, -1);
          v97 = pVehicle->m_pMat;
          v98 = &pVehicle->m_transform;
          v99 = v411._vptr$CEvent;
          v100 = &pVehicle->m_transform;
          if ( v97 )
            v100 = (CSimpleTransform *)&v97->tx;
          v101 = v100->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v102 = pVehicle->m_pMat;
          v103 = &pVehicle->m_transform;
          v104 = v414.x;
          if ( v102 )
            v103 = (CSimpleTransform *)&v102->tx;
          v105 = v103->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v106 = pVehicle->m_pMat;
          v107 = &pVehicle->m_transform;
          v108 = v413.y;
          if ( v106 )
            v107 = (CSimpleTransform *)&v106->tx;
          v109 = v107->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v110 = pVehicle->m_pMat;
          if ( v110 )
            v98 = (CSimpleTransform *)&v110->tx;
          v78 = sqrtf(
                  (float)((float)(*(float *)&v99 - v101) * (float)(v104 - v105))
                + (float)((float)(v108 - v109) * (float)(v412.y - v98->m_translate.y)));
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
            v111 = 50.0;
          else
            v111 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v78 <= v111 )
          {
            if ( FindPlayerVehicle(-1, 0)
              && (v269 = FindPlayerVehicle(-1, 0),
                  sqrtf(
                    (float)((float)(v269->m_vecMoveSpeed.x * v269->m_vecMoveSpeed.x)
                          + (float)(v269->m_vecMoveSpeed.y * v269->m_vecMoveSpeed.y))
                  + (float)(v269->m_vecMoveSpeed.z * v269->m_vecMoveSpeed.z)) < 0.04) )
            {
              pVehicle->GetOutOfCarTimer = (unsigned int)(float)((float)(CTimer::ms_fTimeStep * 16.667)
                                                               + (float)pVehicle->GetOutOfCarTimer);
            }
            else
            {
              pVehicle->GetOutOfCarTimer = 0;
            }
            if ( !FindPlayerVehicle(-1, 0) )
              goto LABEL_317;
            v276 = FindPlayerVehicle(-1, 0);
            if ( CVehicle::IsUpsideDown(v276) )
              goto LABEL_317;
            v277 = FindPlayerVehicle(-1, 0);
            v273 = v277->m_vecMoveSpeed.z * v277->m_vecMoveSpeed.z;
            v274 = (float)(v277->m_vecMoveSpeed.x * v277->m_vecMoveSpeed.x)
                 + (float)(v277->m_vecMoveSpeed.y * v277->m_vecMoveSpeed.y);
            v275 = 0.04;
LABEL_315:
            if ( sqrtf(v274 + v273) < v275 && pVehicle->GetOutOfCarTimer >= 0x9C5u )
            {
LABEL_317:
              if ( !(*(_BYTE *)p_m_nVehicleFlags << 31) )
                goto LABEL_365;
              if ( pVehicle->m_nModelIndex == 432 )
              {
                if ( v78 >= 10.0 || pVehicle->RandomSeed <= 0x2710u )
                  goto LABEL_365;
              }
              else if ( v78 >= 10.0 )
              {
                goto LABEL_365;
              }
              CCarAI::TellOccupantsToLeaveCar(pVehicle);
              pVehicle->AutoPilot.Mission = 0;
              pVehicle->AutoPilot.CruiseSpeed = 0;
              if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel <= WANTED_LEVEL1 )
                *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) &= ~0x8000u;
            }
          }
          else
          {
            FindPlayerCoors((CVector *)&v411, -1);
            if ( !CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, (const CVector *)&v411, 1, 0) )
            {
              v257 = 4;
LABEL_276:
              pVehicle->AutoPilot.Mission = v257;
              *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) &= ~0x8000u;
              pVehicle->m_cHorn = 0;
            }
          }
LABEL_365:
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
          {
LABEL_366:
            CCarAI::MellowOutChaseSpeed(pVehicle);
LABEL_367:
            CCarAI::BackToCruisingIfNoWantedLevel(pVehicle);
          }
          break;
        case 8:
          v118 = pVehicle->m_pMat;
          v119 = (CSimpleTransform *)&v118->tx;
          if ( !v118 )
            v119 = &pVehicle->m_transform;
          v120.n64_u64[0] = vsub_f32(
                              *(float32x2_t *)&pVehicle->AutoPilot.TargetCoors.x,
                              *(float32x2_t *)&v119->m_translate.x).n64_u64[0];
          v1.n64_u64[0] = vmul_f32(v120, v120).n64_u64[0];
          if ( sqrtf(v1.n64_f32[0] + v1.n64_f32[1]) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            pVehicle->AutoPilot.Mission = 9;
          break;
        case 9:
          v121 = pVehicle->m_pMat;
          v122 = (CSimpleTransform *)&v121->tx;
          if ( !v121 )
            v122 = &pVehicle->m_transform;
          v123.n64_u64[0] = vsub_f32(
                              *(float32x2_t *)&pVehicle->AutoPilot.TargetCoors.x,
                              *(float32x2_t *)&v122->m_translate.x).n64_u64[0];
          v1.n64_u64[0] = vmul_f32(v123, v123).n64_u64[0];
          v1.n64_f32[0] = sqrtf(v1.n64_f32[0] + v1.n64_f32[1]);
          if ( v1.n64_f32[0] >= 3.0 )
          {
            if ( v1.n64_f32[0] > (float)((float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0)
              && !((unsigned __int8)CTimer::m_FrameCounter << 29) )
            {
              pVehicle->AutoPilot.TempAction = 0;
              v258 = CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, &pVehicle->AutoPilot.TargetCoors, 1, 0);
              v259 = 8;
              if ( v258 )
                v259 = 9;
              pVehicle->AutoPilot.Mission = v259;
            }
          }
          else
          {
            *(_WORD *)&pVehicle->AutoPilot.Mission = 0;
          }
          break;
        case 0xA:
        case 0x1B:
        case 0x1C:
          break;
        case 0xC:
          v124 = pVehicle->m_pMat;
          v125 = (CSimpleTransform *)&v124->tx;
          if ( !v124 )
            v125 = &pVehicle->m_transform;
          v126.n64_u64[0] = vsub_f32(
                              *(float32x2_t *)&pVehicle->AutoPilot.TargetCoors.x,
                              *(float32x2_t *)&v125->m_translate.x).n64_u64[0];
          v1.n64_u64[0] = vmul_f32(v126, v126).n64_u64[0];
          if ( sqrtf(v1.n64_f32[0] + v1.n64_f32[1]) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            pVehicle->AutoPilot.Mission = 13;
          break;
        case 0xD:
          v127 = pVehicle->m_pMat;
          v128 = (CSimpleTransform *)&v127->tx;
          if ( !v127 )
            v128 = &pVehicle->m_transform;
          v129.n64_u64[0] = vsub_f32(
                              *(float32x2_t *)&pVehicle->AutoPilot.TargetCoors.x,
                              *(float32x2_t *)&v128->m_translate.x).n64_u64[0];
          v1.n64_u64[0] = vmul_f32(v129, v129).n64_u64[0];
          v1.n64_f32[0] = sqrtf(v1.n64_f32[0] + v1.n64_f32[1]);
          if ( v1.n64_f32[0] >= 1.0 )
          {
            if ( v1.n64_f32[0] > (float)((float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0)
              && !((unsigned __int8)CTimer::m_FrameCounter << 29) )
            {
              pVehicle->AutoPilot.TempAction = 0;
              v260 = CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, &pVehicle->AutoPilot.TargetCoors, 1, 0);
              v261 = 12;
              if ( v260 )
                v261 = 13;
              pVehicle->AutoPilot.Mission = v261;
            }
            break;
          }
          *(_WORD *)&pVehicle->AutoPilot.Mission = 0;
          if ( (*((_BYTE *)&pVehicle->m_nVehicleFlags + 4) & 4) == 0 )
            break;
          CCarAI::TellOccupantsToLeaveCar(pVehicle);
          v130 = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) & 0xFFFFFFFB;
          goto LABEL_149;
        case 0xF:
          pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
          if ( !pTargetEntity )
            goto LABEL_259;
          v132 = pVehicle->m_pMat;
          v133 = pTargetEntity->m_pMat;
          v134 = (CSimpleTransform *)&v132->tx;
          if ( !v132 )
            v134 = &pVehicle->m_transform;
          p_x = &v133->tx;
          if ( !v133 )
            p_x = &pTargetEntity->m_transform.m_translate.x;
          if ( sqrtf(
                 (float)((float)(*p_x - v134->m_translate.x) * (float)(*p_x - v134->m_translate.x))
               + (float)((float)(p_x[1] - v134->m_translate.y) * (float)(p_x[1] - v134->m_translate.y))) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            pVehicle->AutoPilot.Mission = 16;
          break;
        case 0x10:
          v136 = (CVehicle *)pVehicle->AutoPilot.pTargetEntity;
          if ( v136 )
          {
            if ( v136 == FindPlayerVehicle(-1, 0) )
              CCarAI::BackToCruisingIfNoWantedLevel(pVehicle);
            v137 = pVehicle->AutoPilot.pTargetEntity;
            v138 = pVehicle->m_pMat;
            v139 = v137->m_pMat;
            v140 = (CSimpleTransform *)&v138->tx;
            if ( !v138 )
              v140 = &pVehicle->m_transform;
            v141 = &v139->tx;
            if ( !v139 )
              v141 = &v137->m_transform.m_translate.x;
            v142 = sqrtf(
                     (float)((float)(*v141 - v140->m_translate.x) * (float)(*v141 - v140->m_translate.x))
                   + (float)((float)(v141[1] - v140->m_translate.y) * (float)(v141[1] - v140->m_translate.y)));
            if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
              v143 = 50.0;
            else
              v143 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
            if ( v142 <= v143 )
            {
              if ( CPhysical::GetHasCollidedWith(pVehicle, v137)
                && sqrtf(
                     (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                           + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                   + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z)) < 0.04 )
              {
                pVehicle->AutoPilot.TempAction = 3;
                pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 800;
              }
            }
            else
            {
              v280 = 15;
LABEL_348:
              pVehicle->AutoPilot.Mission = v280;
LABEL_349:
              CCarCtrl::JoinCarWithRoadSystem(pVehicle);
            }
          }
          else
          {
            pVehicle->AutoPilot.Mission = 1;
          }
          break;
        case 0x11:
          v144 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v144 )
            goto LABEL_259;
          v145 = pVehicle->m_pMat;
          v146 = v144->m_pMat;
          v147 = (CSimpleTransform *)&v145->tx;
          if ( !v145 )
            v147 = &pVehicle->m_transform;
          v148 = &v146->tx;
          if ( !v146 )
            v148 = &v144->m_transform.m_translate.x;
          if ( sqrtf(
                 (float)((float)(*v148 - v147->m_translate.x) * (float)(*v148 - v147->m_translate.x))
               + (float)((float)(v148[1] - v147->m_translate.y) * (float)(v148[1] - v147->m_translate.y))) >= (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            break;
          pVehicle->AutoPilot.Mission = 18;
          if ( !CVehicle::UsesSiren(pVehicle) )
            break;
          v130 = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) | 0x8000;
          goto LABEL_149;
        case 0x12:
          v149 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v149 )
            goto LABEL_259;
          v150 = pVehicle->m_pMat;
          v151 = v149->m_pMat;
          v152 = (CSimpleTransform *)&v150->tx;
          if ( !v150 )
            v152 = &pVehicle->m_transform;
          v153 = &v151->tx;
          if ( !v151 )
            v153 = &v149->m_transform.m_translate.x;
          v154 = v153[1];
          v155 = *v153 - v152->m_translate.x;
          v156 = *p_m_nVehicleFlags;
          v157 = sqrtf(
                   (float)(v155 * v155)
                 + (float)((float)(v154 - v152->m_translate.y) * (float)(v154 - v152->m_translate.y)));
          if ( (*(_DWORD *)p_m_nVehicleFlags & 1) != 0 )
            v158 = 50.0;
          else
            v158 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v157 <= v158 )
            break;
          *((_DWORD *)&v156 + 1) &= ~0x8000u;
          pVehicle->AutoPilot.Mission = 17;
          *p_m_nVehicleFlags = v156;
          pVehicle->m_cHorn = 0;
          goto LABEL_349;
        case 0x15:
          if ( !(*(_BYTE *)p_m_nVehicleFlags << 31) )
            break;
          if ( !FindPlayerVehicle(-1, 0) )
            pVehicle->AutoPilot.Mission = 64;
          v159 = FindPlayerWanted(-1)->m_WantedLevel;
          v160 = 8;
          switch ( v159 )
          {
            case WANTED_CLEAN:
              goto LABEL_536;
            case WANTED_LEVEL1:
              goto LABEL_263;
            case WANTED_LEVEL2:
              pVehicle->AutoPilot.CruiseSpeed = 15;
              goto LABEL_367;
            case WANTED_LEVEL3:
              pVehicle->AutoPilot.CruiseSpeed = 20;
              goto LABEL_367;
            case WANTED_LEVEL4:
              pVehicle->AutoPilot.CruiseSpeed = 25;
              goto LABEL_367;
            case WANTED_LEVEL5:
              pVehicle->AutoPilot.CruiseSpeed = 30;
              goto LABEL_367;
            case WANTED_LEVEL6:
              v160 = 40;
LABEL_536:
              pVehicle->AutoPilot.CruiseSpeed = v160;
              break;
            default:
              goto LABEL_367;
          }
          goto LABEL_367;
        case 0x18:
          v161 = pVehicle->m_pMat;
          v162 = (CSimpleTransform *)&v161->tx;
          if ( !v161 )
            v162 = &pVehicle->m_transform;
          v163.n64_u64[0] = vsub_f32(
                              *(float32x2_t *)&pVehicle->AutoPilot.TargetCoors.x,
                              *(float32x2_t *)&v162->m_translate.x).n64_u64[0];
          v1.n64_u64[0] = vmul_f32(v163, v163).n64_u64[0];
          if ( sqrtf(v1.n64_f32[0] + v1.n64_f32[1]) < 1.5 )
            pVehicle->AutoPilot.Mission = 25;
          goto LABEL_367;
        case 0x19:
          FindPlayerCoors((CVector *)&v411, -1);
          v164 = pVehicle->m_pMat;
          v165 = &pVehicle->m_transform;
          v166 = v411._vptr$CEvent;
          v167 = &pVehicle->m_transform;
          if ( v164 )
            v167 = (CSimpleTransform *)&v164->tx;
          v168 = v167->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v169 = pVehicle->m_pMat;
          v170 = &pVehicle->m_transform;
          v171 = v414.x;
          if ( v169 )
            v170 = (CSimpleTransform *)&v169->tx;
          v172 = v170->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v173 = pVehicle->m_pMat;
          v174 = &pVehicle->m_transform;
          v175 = v413.y;
          if ( v173 )
            v174 = (CSimpleTransform *)&v173->tx;
          v176 = v174->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v177 = pVehicle->m_pMat;
          if ( v177 )
            v165 = (CSimpleTransform *)&v177->tx;
          v178 = sqrtf(
                   (float)((float)(*(float *)&v166 - v168) * (float)(v171 - v172))
                 + (float)((float)(v175 - v176) * (float)(v412.y - v165->m_translate.y)));
          if ( v178 < 13.0 )
          {
            CCarAI::TellOccupantsToLeaveCar(pVehicle);
            pVehicle->AutoPilot.Mission = 11;
            pVehicle->AutoPilot.CruiseSpeed = 0;
          }
          if ( v178 > 70.0
            || (*((_BYTE *)FindPlayerWanted(-1) + 30) & 4) != 0
            || *(_BYTE *)p_m_nVehicleFlags << 31
            && (FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN
             || *((unsigned __int8 *)FindPlayerWanted(-1) + 30) << 29
             || CCullZones::NoPolice() == 1) )
          {
            CCarAI::TellOccupantsToLeaveCar(pVehicle);
            pVehicle->AutoPilot.Mission = 11;
            pVehicle->AutoPilot.CruiseSpeed = 0;
          }
          break;
        case 0x1A:
          FindPlayerCoors((CVector *)&v411, -1);
          v179 = pVehicle->m_pMat;
          v180 = &pVehicle->m_transform;
          v181 = v411._vptr$CEvent;
          v182 = &pVehicle->m_transform;
          if ( v179 )
            v182 = (CSimpleTransform *)&v179->tx;
          v183 = v182->m_translate.x;
          FindPlayerCoors((CVector *)&v411, -1);
          v184 = pVehicle->m_pMat;
          m_iAccumulatedTime = v411.m_iAccumulatedTime;
          if ( v184 )
            v180 = (CSimpleTransform *)&v184->tx;
          v186 = v180->m_translate.y;
          if ( !FindPlayerVehicle(-1, 0)
            || (v187 = *(float *)&v181 - v183,
                v3.n64_u32[0] = 981668463,
                v2.n64_f32[0] = sqrtf(
                                  (float)(v187 * v187)
                                + (float)((float)(*(float *)&m_iAccumulatedTime - v186)
                                        * (float)(*(float *)&m_iAccumulatedTime - v186))),
                v188 = vmax_f32(v2, v3).n64_f32[0],
                v189 = (float)(*(float *)&m_iAccumulatedTime - v186) / v188,
                v190 = FindPlayerSpeed(-1)->x,
                (float)((float)((float)(v187 / v188) * v190) + (float)(v189 * FindPlayerSpeed(-1)->y)) > 0.05) )
          {
            pVehicle->AutoPilot.Mission = 5;
          }
          goto LABEL_367;
        case 0x1D:
        case 0x1E:
        case 0x1F:
        case 0x20:
          if ( pVehicle->AutoPilot.AISwitchToStraightLineDistance <= 0xEFu )
          {
            FindPlayerCoors((CVector *)&v411, -1);
            v16 = pVehicle->m_pMat;
            v17 = &pVehicle->m_transform;
            v18 = v411._vptr$CEvent;
            v19 = &pVehicle->m_transform;
            if ( v16 )
              v19 = (CSimpleTransform *)&v16->tx;
            v20 = v19->m_translate.x;
            FindPlayerCoors(&v414, -1);
            v21 = pVehicle->m_pMat;
            v22 = &pVehicle->m_transform;
            v23 = v414.x;
            if ( v21 )
              v22 = (CSimpleTransform *)&v21->tx;
            v24 = v22->m_translate.x;
            FindPlayerCoors(&v413, -1);
            v25 = pVehicle->m_pMat;
            v26 = &pVehicle->m_transform;
            v27 = v413.y;
            if ( v25 )
              v26 = (CSimpleTransform *)&v25->tx;
            v28 = v26->m_translate.y;
            FindPlayerCoors(&v412, -1);
            v29 = pVehicle->m_pMat;
            if ( v29 )
              v17 = (CSimpleTransform *)&v29->tx;
            v30 = sqrtf(
                    (float)((float)(*(float *)&v18 - v20) * (float)(v23 - v24))
                  + (float)((float)(v27 - v28) * (float)(v412.y - v17->m_translate.y)));
            if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
              v31 = 50.0;
            else
              v31 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
            if ( v30 > v31 )
            {
              FindPlayerCoors((CVector *)&v411, -1);
              if ( !CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, (const CVector *)&v411, 1, 0) )
                pVehicle->AutoPilot.Mission += 36;
            }
          }
          break;
        case 0x2B:
          FindPlayerCoors((CVector *)&v411, -1);
          v191 = pVehicle->m_pMat;
          v192 = &pVehicle->m_transform;
          v193 = v411._vptr$CEvent;
          v194 = &pVehicle->m_transform;
          if ( v191 )
            v194 = (CSimpleTransform *)&v191->tx;
          v195 = v194->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v196 = pVehicle->m_pMat;
          v197 = &pVehicle->m_transform;
          v198 = v414.x;
          if ( v196 )
            v197 = (CSimpleTransform *)&v196->tx;
          v199 = v197->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v200 = pVehicle->m_pMat;
          v201 = &pVehicle->m_transform;
          v202 = v413.y;
          if ( v200 )
            v201 = (CSimpleTransform *)&v200->tx;
          v203 = v201->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v204 = pVehicle->m_pMat;
          if ( v204 )
            v192 = (CSimpleTransform *)&v204->tx;
          if ( sqrtf(
                 (float)((float)(*(float *)&v193 - v195) * (float)(v198 - v199))
               + (float)((float)(v202 - v203) * (float)(v412.y - v192->m_translate.y))) >= (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            goto LABEL_367;
          v63 = 44;
LABEL_201:
          pVehicle->AutoPilot.Mission = v63;
          if ( CVehicle::UsesSiren(pVehicle) )
            *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) |= 0x8000u;
          goto LABEL_367;
        case 0x2C:
          FindPlayerCoors((CVector *)&v411, -1);
          v205 = pVehicle->m_pMat;
          v206 = &pVehicle->m_transform;
          v207 = v411._vptr$CEvent;
          v208 = &pVehicle->m_transform;
          if ( v205 )
            v208 = (CSimpleTransform *)&v205->tx;
          v209 = v208->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v210 = pVehicle->m_pMat;
          v211 = &pVehicle->m_transform;
          v212 = v414.x;
          if ( v210 )
            v211 = (CSimpleTransform *)&v210->tx;
          v213 = v211->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v214 = pVehicle->m_pMat;
          v215 = &pVehicle->m_transform;
          v216 = v413.y;
          if ( v214 )
            v215 = (CSimpleTransform *)&v214->tx;
          v217 = v215->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v218 = pVehicle->m_pMat;
          if ( v218 )
            v206 = (CSimpleTransform *)&v218->tx;
          v219 = sqrtf(
                   (float)((float)(*(float *)&v207 - v209) * (float)(v212 - v213))
                 + (float)((float)(v216 - v217) * (float)(v412.y - v206->m_translate.y)));
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
            v220 = 50.0;
          else
            v220 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v219 <= v220 )
          {
            if ( FindPlayerVehicle(-1, 0)
              && (v270 = FindPlayerVehicle(-1, 0),
                  sqrtf(
                    (float)((float)(v270->m_vecMoveSpeed.x * v270->m_vecMoveSpeed.x)
                          + (float)(v270->m_vecMoveSpeed.y * v270->m_vecMoveSpeed.y))
                  + (float)(v270->m_vecMoveSpeed.z * v270->m_vecMoveSpeed.z)) < 0.05) )
            {
              pVehicle->GetOutOfCarTimer += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
            }
            else
            {
              pVehicle->GetOutOfCarTimer = 0;
            }
            v278 = (float *)&loc_2E5164;
            if ( pVehicle->m_nModelIndex == 523 )
              v278 = (float *)&loc_2E5168;
            if ( (!FindPlayerVehicle(-1, 0)
               || (v279 = FindPlayerVehicle(-1, 0), CVehicle::IsUpsideDown(v279))
               || *v278 < (float)pVehicle->GetOutOfCarTimer)
              && v219 < 10.0
              && (*(_DWORD *)p_m_nVehicleFlags & 1) != 0 )
            {
              CCarAI::TellOccupantsToLeaveCar(pVehicle);
              pVehicle->AutoPilot.Mission = 0;
              pVehicle->AutoPilot.CruiseSpeed = 0;
              if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel <= WANTED_LEVEL1 )
                *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) &= ~0x8000u;
            }
            else if ( pVehicle->m_nModelIndex == 523 )
            {
              pDriver = pVehicle->pDriver;
              if ( pDriver )
              {
                m_pPedIntelligence = pDriver->m_pPedIntelligence;
                v283 = (CTaskComplexSequence *)m_pPedIntelligence->m_taskManager.m_tasks[3];
                if ( !v283
                  || (*((int (__fastcall **)(CTask *))v283->_vptr$CTask + 5))(m_pPedIntelligence->m_taskManager.m_tasks[3]) != 244
                  || !CTaskComplexSequence::Contains(v283, 701) && !CTaskComplexSequence::Contains(v283, 1022) )
                {
                  v284 = (CTaskComplexSequence *)CTask::operator new(0x40u);
                  CTaskComplexSequence::CTaskComplexSequence(v284);
                  v285 = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x50u);
                  CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(v285, pVehicle);
                  CTaskComplexSequence::AddTask(v284, v285);
                  v286 = (CTaskSimpleGangDriveBy *)CTask::operator new(0x44u);
                  PlayerPed = FindPlayerPed(-1);
                  CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(v286, PlayerPed, 0, 50.0, 50, 8, 0);
                  CTaskComplexSequence::AddTask(v284, v286);
                  CEventScriptCommand::CEventScriptCommand(&v411, 3, v284, 0);
                  CEventGroup::Add(&pVehicle->pDriver->m_pPedIntelligence->m_eventGroup, &v411, 0);
                  CPed::SetCurrentWeapon(pVehicle->pDriver, WEAPONTYPE_PISTOL);
                  CEventScriptCommand::~CEventScriptCommand(&v411);
                }
              }
            }
          }
          else
          {
            FindPlayerCoors((CVector *)&v411, -1);
            if ( !CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, (const CVector *)&v411, 1, 0) )
            {
              pVehicle->AutoPilot.Mission = 43;
              *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) &= ~0x8000u;
              pVehicle->m_cHorn = 0;
            }
          }
          if ( !(*(_BYTE *)p_m_nVehicleFlags << 31) )
            goto LABEL_367;
          goto LABEL_366;
        case 0x34:
          v221 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v221 )
            goto LABEL_259;
          v222 = pVehicle->m_pMat;
          v223 = v221->m_pMat;
          v224 = (CSimpleTransform *)&v222->tx;
          if ( !v222 )
            v224 = &pVehicle->m_transform;
          v225 = &v223->tx;
          if ( !v223 )
            v225 = &v221->m_transform.m_translate.x;
          if ( sqrtf(
                 (float)((float)(*v225 - v224->m_translate.x) * (float)(*v225 - v224->m_translate.x))
               + (float)((float)(v225[1] - v224->m_translate.y) * (float)(v225[1] - v224->m_translate.y))) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            pVehicle->AutoPilot.Mission = 53;
          break;
        case 0x35:
          v226 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v226 )
            goto LABEL_259;
          v227 = pVehicle->m_pMat;
          v228 = v226->m_pMat;
          v229 = (CSimpleTransform *)&v227->tx;
          if ( !v227 )
            v229 = &pVehicle->m_transform;
          v230 = &v228->tx;
          if ( !v228 )
            v230 = &v226->m_transform.m_translate.x;
          v231 = sqrtf(
                   (float)((float)(*v230 - v229->m_translate.x) * (float)(*v230 - v229->m_translate.x))
                 + (float)((float)(v230[1] - v229->m_translate.y) * (float)(v230[1] - v229->m_translate.y)));
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
            v232 = 50.0;
          else
            v232 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v231 <= v232 )
            break;
          v280 = 52;
          goto LABEL_348;
        case 0x36:
          v233 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v233 )
            goto LABEL_259;
          v234 = pVehicle->m_pMat;
          v235 = v233->m_pMat;
          v236 = (CSimpleTransform *)&v234->tx;
          if ( !v234 )
            v236 = &pVehicle->m_transform;
          v237 = &v235->tx;
          if ( !v235 )
            v237 = &v233->m_transform.m_translate.x;
          if ( sqrtf(
                 (float)((float)(*v237 - v236->m_translate.x) * (float)(*v237 - v236->m_translate.x))
               + (float)((float)(v237[1] - v236->m_translate.y) * (float)(v237[1] - v236->m_translate.y))) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            pVehicle->AutoPilot.Mission = 55;
          break;
        case 0x37:
          v238 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v238 )
            goto LABEL_259;
          v239 = pVehicle->m_pMat;
          v240 = v238->m_pMat;
          v241 = (CSimpleTransform *)&v239->tx;
          if ( !v239 )
            v241 = &pVehicle->m_transform;
          v242 = &v240->tx;
          if ( !v240 )
            v242 = &v238->m_transform.m_translate.x;
          v243 = sqrtf(
                   (float)((float)(*v242 - v241->m_translate.x) * (float)(*v242 - v241->m_translate.x))
                 + (float)((float)(v242[1] - v241->m_translate.y) * (float)(v242[1] - v241->m_translate.y)));
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
            v244 = 50.0;
          else
            v244 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v243 <= v244 )
            break;
          v280 = 54;
          goto LABEL_348;
        case 0x3C:
          v245 = pVehicle->AutoPilot.pTargetEntity;
          if ( !v245 )
            goto LABEL_259;
          v246 = pVehicle->m_pMat;
          v247 = v245->m_pMat;
          v248 = (CSimpleTransform *)&v246->tx;
          if ( !v246 )
            v248 = &pVehicle->m_transform;
          v249 = &v247->tx;
          if ( !v247 )
            v249 = &v245->m_transform.m_translate.x;
          v250 = sqrtf(
                   (float)((float)(*v249 - v248->m_translate.x) * (float)(*v249 - v248->m_translate.x))
                 + (float)((float)(v249[1] - v248->m_translate.y) * (float)(v249[1] - v248->m_translate.y)));
          if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
            v251 = 50.0;
          else
            v251 = (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance + 5.0;
          if ( v250 <= v251 )
            break;
          v280 = 61;
          goto LABEL_348;
        case 0x3D:
          v252 = pVehicle->AutoPilot.pTargetEntity;
          if ( v252 )
          {
            v253 = pVehicle->m_pMat;
            v254 = v252->m_pMat;
            v255 = (CSimpleTransform *)&v253->tx;
            if ( !v253 )
              v255 = &pVehicle->m_transform;
            v256 = &v254->tx;
            if ( !v254 )
              v256 = &v252->m_transform.m_translate.x;
            if ( sqrtf(
                   (float)((float)(*v256 - v255->m_translate.x) * (float)(*v256 - v255->m_translate.x))
                 + (float)((float)(v256[1] - v255->m_translate.y) * (float)(v256[1] - v255->m_translate.y))) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
              pVehicle->AutoPilot.Mission = 60;
          }
          else
          {
LABEL_259:
            pVehicle->AutoPilot.Mission = 0;
          }
          break;
        case 0x40:
          if ( !(*(_BYTE *)p_m_nVehicleFlags << 31) )
            break;
          if ( FindPlayerVehicle(-1, 0) )
            pVehicle->AutoPilot.Mission = 21;
LABEL_263:
          pVehicle->AutoPilot.CruiseSpeed = 10;
          goto LABEL_367;
        case 0x41:
        case 0x42:
        case 0x43:
        case 0x44:
          FindPlayerCoors((CVector *)&v411, -1);
          v32 = pVehicle->m_pMat;
          v33 = &pVehicle->m_transform;
          v34 = v411._vptr$CEvent;
          v35 = &pVehicle->m_transform;
          if ( v32 )
            v35 = (CSimpleTransform *)&v32->tx;
          v36 = v35->m_translate.x;
          FindPlayerCoors(&v414, -1);
          v37 = pVehicle->m_pMat;
          v38 = &pVehicle->m_transform;
          v39 = v414.x;
          if ( v37 )
            v38 = (CSimpleTransform *)&v37->tx;
          v40 = v38->m_translate.x;
          FindPlayerCoors(&v413, -1);
          v41 = pVehicle->m_pMat;
          v42 = &pVehicle->m_transform;
          v43 = v413.y;
          if ( v41 )
            v42 = (CSimpleTransform *)&v41->tx;
          v44 = v42->m_translate.y;
          FindPlayerCoors(&v412, -1);
          v45 = pVehicle->m_pMat;
          if ( v45 )
            v33 = (CSimpleTransform *)&v45->tx;
          if ( sqrtf(
                 (float)((float)(*(float *)&v34 - v36) * (float)(v39 - v40))
               + (float)((float)(v43 - v44) * (float)(v412.y - v33->m_translate.y))) < (float)pVehicle->AutoPilot.AISwitchToStraightLineDistance )
            pVehicle->AutoPilot.Mission -= 36;
          break;
        default:
          if ( !(*(_BYTE *)p_m_nVehicleFlags << 31)
            || FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel < WANTED_LEVEL1
            || CCullZones::NoPolice() )
          {
            break;
          }
          FindPlayerCoors((CVector *)&v411, -1);
          v112 = pVehicle->m_pMat;
          v113 = &pVehicle->m_transform;
          v114 = &pVehicle->m_transform;
          if ( v112 )
            v114 = (CSimpleTransform *)&v112->tx;
          if ( (float)(*(float *)&v411._vptr$CEvent - v114->m_translate.x) >= 0.0 )
          {
            FindPlayerCoors(&v413, -1);
            v383 = pVehicle->m_pMat;
            v384 = &pVehicle->m_transform;
            if ( v383 )
              v384 = (CSimpleTransform *)&v383->tx;
            v117 = v413.x - v384->m_translate.x;
          }
          else
          {
            FindPlayerCoors(&v414, -1);
            v115 = pVehicle->m_pMat;
            v116 = &pVehicle->m_transform;
            if ( v115 )
              v116 = (CSimpleTransform *)&v115->tx;
            v117 = -(float)(v414.x - v116->m_translate.x);
          }
          if ( v117 <= 10.0 )
          {
            FindPlayerCoors(&v412, -1);
            v386 = pVehicle->m_pMat;
            v387 = &pVehicle->m_transform;
            if ( v386 )
              v387 = (CSimpleTransform *)&v386->tx;
            if ( (float)(v412.y - v387->m_translate.y) >= 0.0 )
            {
              FindPlayerCoors(&v410, -1);
              v393 = pVehicle->m_pMat;
              if ( v393 )
                v113 = (CSimpleTransform *)&v393->tx;
              v389 = v410.y - v113->m_translate.y;
            }
            else
            {
              FindPlayerCoors(&v410, -1);
              v388 = pVehicle->m_pMat;
              if ( v388 )
                v113 = (CSimpleTransform *)&v388->tx;
              v389 = -(float)(v410.y - v113->m_translate.y);
            }
            v385 = v389 > 10.0;
          }
          else
          {
            v385 = 1;
          }
          if ( v385 )
          {
            v394 = FindPlayerWanted(-1)->m_WantedLevel;
            LOBYTE(v395) = 25;
            switch ( v394 )
            {
              case WANTED_CLEAN:
                v396 = (float)((float)((float)rand() * 4.6566e-10) * 4.0) + 12.0;
                goto LABEL_567;
              case WANTED_LEVEL1:
                break;
              case WANTED_LEVEL2:
                LOBYTE(v395) = 34;
                break;
              case WANTED_LEVEL3:
                v400 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
                v401 = 0.9;
                goto LABEL_566;
              case WANTED_LEVEL4:
                v400 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
                v401 = 1.2;
                goto LABEL_566;
              case WANTED_LEVEL5:
                v396 = (float)(pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0) * 1.25;
                goto LABEL_567;
              case WANTED_LEVEL6:
                v400 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
                v401 = 1.3;
LABEL_566:
                v396 = v400 * v401;
LABEL_567:
                v395 = (int)v396;
                break;
              default:
                LOBYTE(v395) = 0;
                break;
            }
            m_info = pVehicle->m_info;
            pVehicle->AutoPilot.CruiseSpeed = v395;
            if ( (*(_BYTE *)&m_info & 0xF8) != 96 )
              pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
            if ( CVehicle::GetVehicleAppearance(pVehicle) == APR_BOAT )
            {
              v403 = FindPlayerWanted(-1)->m_WantedLevel;
              v295 = FindPlayerVehicle(-1, 0) == 0;
              v404 = 64;
              v405 = 64;
              if ( !v295 )
              {
                v405 = 21;
                v404 = 4;
              }
              if ( (unsigned int)(v403 - 2) < 5 )
                v404 = v405;
            }
            else if ( CVehicle::GetVehicleAppearance(pVehicle) == APR_BIKE )
            {
              v404 = 43;
            }
            else
            {
              v406 = FindPlayerWanted(-1)->m_WantedLevel;
              if ( (unsigned int)(v406 - 4) >= 3 )
              {
                if ( v406 == WANTED_LEVEL3 )
                {
                  v409 = rand();
                  v404 = 2;
                  if ( (v409 & 2u) < 2 )
                    v404 = 4;
                }
                else if ( v406 == WANTED_LEVEL2 )
                {
                  v408 = rand();
                  v404 = 4;
                  if ( (v408 & 3) == 3 )
                    v404 = 2;
                }
                else
                {
                  v404 = 4;
                }
              }
              else
              {
                v407 = rand();
                v404 = 2;
                if ( (v407 & 3) == 0 )
                  v404 = 4;
              }
            }
            pVehicle->AutoPilot.DrivingMode = 2;
            pVehicle->AutoPilot.TempAction = 0;
            pVehicle->AutoPilot.Mission = v404;
          }
          else if ( pVehicle->AutoPilot.Mission == 1 )
          {
            v397 = pVehicle->m_info;
            if ( (*(_BYTE *)&v397 & 0xF8) != 96 )
              pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v397 & 7 | 0x18);
            CCarAI::TellOccupantsToLeaveCar(pVehicle);
            pVehicle->AutoPilot.Mission = 0;
            pVehicle->AutoPilot.CruiseSpeed = 0;
            if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel <= WANTED_LEVEL1 )
            {
              v130 = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) & 0xFFFF7FFF;
LABEL_149:
              *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) = v130;
            }
          }
          break;
      }
    }
    else if ( (v15 & 0x30) != 0 )
    {
      pVehicle->AutoPilot.CruiseSpeed = 0;
      pVehicle->AutoPilot.Mission = 0;
    }
  }
  if ( *(_BYTE *)p_m_nVehicleFlags << 31
    && FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL1
    && CCullZones::PoliceAbandonCars() == 1 )
  {
    CCarAI::TellOccupantsToLeaveCar(pVehicle);
    pVehicle->AutoPilot.Mission = 0;
    pVehicle->AutoPilot.CruiseSpeed = 0;
  }
  v288 = (float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
       + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y);
  if ( v288 > 0.0025 )
  {
    v289 = CTimer::m_snTimeInMilliseconds;
    pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
    pVehicle->AutoPilot.LastTimeMoving = v289;
  }
  if ( !pVehicle->AutoPilot.TempAction )
  {
    v290 = (unsigned __int8)pVehicle->AutoPilot.Mission;
    if ( (v290 > 0xB || ((1 << v290) & 0x841) == 0)
      && pVehicle->AutoPilot.CruiseSpeed
      && (v290 - 27 > 0x1A || ((1 << (v290 - 27)) & 0x400003F) == 0) )
    {
      v300 = CTimer::m_snTimeInMilliseconds;
      if ( CTimer::m_snTimeInMilliseconds - pVehicle->m_LastCollisionTime > 0x1F4 )
        pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
      if ( v288 < 0.000144 )
      {
        DrivingMode = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
        v302 = (DrivingMode | 4) == 4 ? 500 * (pVehicle->RandomSeed & 0xF) + 20000 : 1000;
        if ( (int)(v300 - pVehicle->AutoPilot.LastTimeNotStuck) > v302 )
        {
          if ( v300 >= pVehicle->AutoPilot.LastTimeWeStartedTempActReverse + 10000 )
            v382 = 0;
          else
            v382 = (pVehicle->AutoPilot.WhatToTryForReverse + 1) & 3;
          pVehicle->AutoPilot.LastTimeWeStartedTempActReverse = v300;
          pVehicle->AutoPilot.WhatToTryForReverse = v382;
          if ( v290 <= 1 && pVehicle->VehicleCreatedBy != 2 && (*((_BYTE *)&pVehicle->m_nVehicleFlags + 6) & 8) == 0 )
          {
            v390 = 3;
            v391 = 700;
            goto LABEL_553;
          }
          v392 = v382 & 3;
          switch ( v392 )
          {
            case 1:
              v390 = 3;
              v391 = 4000;
              goto LABEL_553;
            case 2:
              v390 = 13;
              break;
            case 3:
              v390 = 14;
              break;
            default:
              v390 = 3;
              v391 = 1500;
LABEL_553:
              pVehicle->AutoPilot.LastTimeNotStuck = v300;
              pVehicle->AutoPilot.TempActionFinish = v300 + v391;
              VehicleCreatedBy = pVehicle->VehicleCreatedBy;
              pVehicle->AutoPilot.TempAction = v390;
              if ( VehicleCreatedBy == 1 && (unsigned int)(char)DrivingMode <= 6 && ((1 << DrivingMode) & 0x53) != 0 )
                pVehicle->AutoPilot.DrivingMode = 2;
              v399 = pVehicle->m_info;
              if ( (*(_BYTE *)&v399 & 0xF8) == 16 )
                pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v399 & 7 | 0x18);
              (*((void (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 55))(pVehicle);
              goto LABEL_377;
          }
          v391 = 2500;
          goto LABEL_553;
        }
      }
    }
  }
LABEL_377:
  if ( !(LOBYTE(pVehicle->RandomSeed) << 29) )
  {
    LastTimeMoving = pVehicle->AutoPilot.LastTimeMoving;
    if ( CTimer::m_snTimeInMilliseconds - LastTimeMoving >= 0x7531
      && CTimer::m_snPreviousTimeInMilliseconds - LastTimeMoving <= 0x7530
      && pVehicle->AutoPilot.Mission == 1
      && !CTrafficLights::ShouldCarStopForBridge(pVehicle) )
    {
      CCarCtrl::SwitchVehicleToRealPhysics(pVehicle);
      pVehicle->AutoPilot.TempAction = 3;
      pVehicle->AutoPilot.DrivingMode = 2;
      pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 400;
    }
  }
  if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
  {
    if ( (pVehicle->AutoPilot.Mission & 0xFE) == 2 )
    {
      if ( FindPlayerVehicle(-1, 0) )
      {
        v292 = FindPlayerVehicle(-1, 0);
        if ( CVehicle::GetVehicleAppearance(v292) == APR_BIKE )
          pVehicle->AutoPilot.Mission = 4;
      }
    }
  }
  if ( pVehicle->m_pMat->zz < -0.7 )
  {
    pVehicle->AutoPilot.TempAction = 1;
    v293 = CTimer::m_snTimeInMilliseconds + 1000;
LABEL_390:
    pVehicle->AutoPilot.TempActionFinish = v293;
    goto LABEL_451;
  }
  TempAction = (unsigned __int8)pVehicle->AutoPilot.TempAction;
  v295 = TempAction == 23;
  if ( TempAction != 23 )
    v295 = TempAction == 0;
  if ( v295 )
  {
    v296 = pVehicle->AutoPilot.Mission;
    v297 = (unsigned int)(v296 - 2) > 4;
    if ( (unsigned int)(v296 - 2) >= 4 )
      v297 = (unsigned int)(v296 - 43) > 1;
    if ( !v297 && FindPlayerVehicle(-1, 0) )
    {
      *(_QWORD *)&v411._vptr$CEvent = *(_QWORD *)&FindPlayerVehicle(-1, 0)->m_pMat->xy;
      *(_DWORD *)&v411.m_bIsPersistent = 0;
      CVector::Normalise((CVector *)&v411);
      v298 = pVehicle->m_pMat;
      if ( v298 )
      {
        v299 = *(_QWORD *)&v298->xy;
        v412.z = v298->zy;
        *(_QWORD *)&v412.x = v299;
      }
      else
      {
        m_heading = pVehicle->m_transform.m_heading;
        v412.z = 0.0;
        v412.y = cosf(m_heading);
        LODWORD(v412.x) = COERCE_UNSIGNED_INT(sinf(m_heading)) ^ 0x80000000;
      }
      v412.z = 0.0;
      CVector::Normalise(&v412);
      PlayerSpeed = FindPlayerSpeed(-1);
      if ( sqrtf(
             (float)((float)(PlayerSpeed->x * PlayerSpeed->x) + (float)(PlayerSpeed->y * PlayerSpeed->y))
           + (float)(PlayerSpeed->z * PlayerSpeed->z)) > sqrtf(
                                                           (float)((float)(pVehicle->m_vecMoveSpeed.x
                                                                         * pVehicle->m_vecMoveSpeed.x)
                                                                 + (float)(pVehicle->m_vecMoveSpeed.y
                                                                         * pVehicle->m_vecMoveSpeed.y))
                                                         + (float)(pVehicle->m_vecMoveSpeed.z
                                                                 * pVehicle->m_vecMoveSpeed.z)) )
      {
        v305 = FindPlayerSpeed(-1);
        if ( sqrtf((float)((float)(v305->x * v305->x) + (float)(v305->y * v305->y)) + (float)(v305->z * v305->z)) > 0.1 )
        {
          xy = FindPlayerVehicle(-1, 0)->m_pMat->xy;
          v307 = pVehicle->m_pMat->xy;
          v308 = FindPlayerVehicle(-1, 0)->m_pMat;
          v309 = pVehicle->m_pMat;
          if ( (float)((float)(xy * v307) + (float)(v308->yy * v309->yy)) > 0.0 )
          {
            v310 = &pVehicle->m_transform;
            v311 = &pVehicle->m_transform;
            if ( v309 )
              v311 = (CSimpleTransform *)&v309->tx;
            v312 = v311->m_translate.x;
            FindPlayerCoors(&v410, -1);
            v313 = pVehicle->m_pMat;
            v314 = &pVehicle->m_transform;
            v315 = v410.x;
            if ( v313 )
              v314 = (CSimpleTransform *)&v313->tx;
            v316 = v314->m_translate.y;
            FindPlayerCoors(&v410, -1);
            v317 = v312 - v315;
            v318 = v316 - v410.y;
            v319 = FindPlayerSpeed(-1)->x;
            v320 = FindPlayerSpeed(-1);
            if ( (float)((float)(v317 * v319) + (float)(v318 * v320->y)) > (float)((float)(sqrtf(
                                                                                             (float)(v317 * v317)
                                                                                           + (float)(v318 * v318))
                                                                                         * 0.5)
                                                                                 * sqrtf(
                                                                                     (float)(v319 * v319)
                                                                                   + (float)(v320->y * v320->y))) )
            {
              FindPlayerCoors(&v410, -1);
              v321 = pVehicle->m_pMat;
              v322 = &pVehicle->m_transform;
              if ( v321 )
                v322 = (CSimpleTransform *)&v321->tx;
              v323.n64_u64[0] = vsub_f32(*(float32x2_t *)&v410.y, *(float32x2_t *)&v322->m_translate.y).n64_u64[0];
              v324 = vmul_f32(v323, v323).n64_u64[0];
              if ( sqrtf(
                     (float)((float)((float)(v410.x - v322->m_translate.x) * (float)(v410.x - v322->m_translate.x))
                           + *(float *)&v324)
                   + *((float *)&v324 + 1)) > 12.0 )
              {
                pVehicle->AutoPilot.TempAction = 1;
                pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 250;
              }
              FindPlayerCoors(&v410, -1);
              v325 = pVehicle->m_pMat;
              v326 = &pVehicle->m_transform;
              if ( v325 )
                v326 = (CSimpleTransform *)&v325->tx;
              v327.n64_u64[0] = vsub_f32(*(float32x2_t *)&v410.y, *(float32x2_t *)&v326->m_translate.y).n64_u64[0];
              v328.n64_u64[0] = vmul_f32(v327, v327).n64_u64[0];
              if ( sqrtf(
                     (float)((float)((float)(v410.x - v326->m_translate.x) * (float)(v410.x - v326->m_translate.x))
                           + v328.n64_f32[0])
                   + v328.n64_f32[1]) < 20.0
                && (float)((float)((float)(*(float *)&v411._vptr$CEvent * v412.x)
                                 + (float)(*(float *)&v411.m_iAccumulatedTime * v412.y))
                         + (float)(*(float *)&v411.m_bIsPersistent * v412.z)) > 0.8 )
              {
                v329 = FindPlayerSpeed(-1);
                if ( sqrtf((float)((float)(v329->x * v329->x) + (float)(v329->y * v329->y)) + (float)(v329->z * v329->z)) > 0.6 )
                {
                  v330 = pVehicle->m_vecMoveSpeed.x;
                  v331 = pVehicle->m_vecMoveSpeed.y;
                  z = pVehicle->m_vecMoveSpeed.z;
                  v333 = FindPlayerSpeed(-1);
                  if ( sqrtf((float)((float)(v330 * v330) + (float)(v331 * v331)) + (float)(z * z)) < (float)(sqrtf((float)((float)(v333->x * v333->x) + (float)(v333->y * v333->y)) + (float)(v333->z * v333->z)) + -0.2) )
                  {
                    pVehicle->AutoPilot.TempAction = 23;
                    pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 250;
                    FindPlayerCoors(&v410, -1);
                    v334 = FindPlayerSpeed(-1);
                    v335 = v334->x * 120.0;
                    v336 = v334->y * 120.0;
                    v337 = pVehicle->m_pMat;
                    if ( v337 )
                      v310 = (CSimpleTransform *)&v337->tx;
                    ATanOfXY = CGeneral::GetATanOfXY(
                                 (float)(v335 + v410.x) - v310->m_translate.x,
                                 (float)(v336 + v410.y) - v310->m_translate.y);
                    for ( v4.n64_f32[0] = ATanOfXY - CGeneral::GetATanOfXY(pVehicle->m_pMat->xy, pVehicle->m_pMat->yy);
                          v4.n64_f32[0] < -3.1416;
                          v4.n64_f32[0] = v4.n64_f32[0] + 6.2832 )
                    {
                      ;
                    }
                    for ( ; v4.n64_f32[0] > 3.1416; v4.n64_f32[0] = v4.n64_f32[0] + -6.2832 )
                      ;
                    v1.n64_u32[0] = CCarCtrl::FindMaxSteerAngle(pVehicle);
                    v328.n64_f32[0] = -v1.n64_f32[0];
                    LODWORD(pVehicle->m_fSteerAngle) = vmin_f32(vmax_f32(v4, v328), v1).n64_u32[0];
                  }
                }
              }
            }
          }
        }
      }
      if ( (float)((float)((float)(*(float *)&v411._vptr$CEvent * v412.x)
                         + (float)(*(float *)&v411.m_iAccumulatedTime * v412.y))
                 + (float)(*(float *)&v411.m_bIsPersistent * v412.z)) < -0.8 )
      {
        v339 = FindPlayerSpeed(-1);
        if ( sqrtf((float)((float)(v339->x * v339->x) + (float)(v339->y * v339->y)) + (float)(v339->z * v339->z)) > 0.3 )
        {
          FindPlayerCoors(&v410, -1);
          v340 = pVehicle->m_pMat;
          v341 = &pVehicle->m_transform;
          v342 = &pVehicle->m_transform;
          if ( v340 )
            v342 = (CSimpleTransform *)&v340->tx;
          v343.n64_u64[0] = vsub_f32(*(float32x2_t *)&v410.y, *(float32x2_t *)&v342->m_translate.y).n64_u64[0];
          v344 = vmul_f32(v343, v343).n64_u64[0];
          if ( sqrtf(
                 (float)((float)((float)(v410.x - v342->m_translate.x) * (float)(v410.x - v342->m_translate.x))
                       + *(float *)&v344)
               + *((float *)&v344 + 1)) < 45.0 )
          {
            FindPlayerCoors(&v410, -1);
            v345 = pVehicle->m_pMat;
            v346 = v410.x;
            v347 = v410.y;
            v348 = v410.z;
            if ( v345 )
              v341 = (CSimpleTransform *)&v345->tx;
            v349 = v341->m_translate.x;
            v350 = v341->m_translate.y;
            v351 = v341->m_translate.z;
            if ( v345 )
            {
              xx = v345->xx;
              yx = v345->yx;
              zx = v345->zx;
            }
            else
            {
              v355 = pVehicle->m_transform.m_heading;
              v356 = cosf(v355);
              yx = sinf(v355);
              zx = 0.0;
              xx = v356;
            }
            if ( sqrtf(
                   (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                         + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                 + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z)) > 0.5 )
            {
              v357 = (float)((float)((float)(v346 - v349) * xx) + (float)((float)(v347 - v350) * yx))
                   + (float)((float)(v348 - v351) * zx);
              if ( fabsf(v357) < 15.0 )
              {
                v358 = 5;
                if ( v357 < 0.0 )
                  v358 = 4;
                pVehicle->AutoPilot.TempAction = v358;
              }
              v293 = CTimer::m_snTimeInMilliseconds + 2000;
              goto LABEL_390;
            }
          }
        }
      }
    }
  }
LABEL_451:
  if ( (*((_BYTE *)&pVehicle->m_nVehicleFlags + 5) & 0x80) != 0
    && (unsigned __int8)(rand() ^ pVehicle->RandomSeed) == 173 )
  {
    pVehicle->m_cHorn = 45;
  }
  if ( pVehicle->AutoPilot.Mission == 1 )
    SpeedMultiplierWithSpeedFromNodes = CCarCtrl::FindSpeedMultiplierWithSpeedFromNodes(pVehicle->AutoPilot.SpeedFromNodes);
  else
    SpeedMultiplierWithSpeedFromNodes = 1.0;
  SpeedMultiplier = pVehicle->AutoPilot.SpeedMultiplier;
  v361 = CTimer::ms_fTimeStep * 0.01;
  if ( fabsf(SpeedMultiplier - SpeedMultiplierWithSpeedFromNodes) >= (float)(CTimer::ms_fTimeStep * 0.01) )
  {
    if ( SpeedMultiplier > SpeedMultiplierWithSpeedFromNodes )
      v361 = -v361;
    SpeedMultiplierWithSpeedFromNodes = SpeedMultiplier + v361;
  }
  pVehicle->AutoPilot.SpeedMultiplier = SpeedMultiplierWithSpeedFromNodes;
  if ( *(_BYTE *)p_m_nVehicleFlags << 31 && FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL1 )
  {
    if ( FindPlayerVehicle(-1, 0) )
    {
      v362 = FindPlayerVehicle(-1, 0);
      if ( CVehicle::GetVehicleAppearance(v362) == APR_CAR )
      {
        v363 = 1;
      }
      else
      {
        v363 = 0;
        v366 = FindPlayerVehicle(-1, 0);
        if ( CVehicle::GetVehicleAppearance(v366) == APR_BIKE )
          v363 = 1;
      }
      v365 = 0;
      v367 = FindPlayerVehicle(-1, 0);
      if ( CVehicle::GetVehicleAppearance(v367) == APR_BOAT )
        v365 = 1;
      if ( v363 )
      {
LABEL_478:
        if ( CVehicle::GetVehicleAppearance(pVehicle) != APR_BOAT )
          goto LABEL_480;
        goto LABEL_479;
      }
    }
    else
    {
      v364 = FindPlayerPed(-1);
      if ( !CPedIntelligence::GetTaskSwim(v364->m_pPedIntelligence) )
        goto LABEL_478;
      v365 = 1;
    }
    if ( v365 != 1
      || CVehicle::GetVehicleAppearance(pVehicle) != APR_CAR && CVehicle::GetVehicleAppearance(pVehicle) != APR_BIKE )
    {
      goto LABEL_480;
    }
LABEL_479:
    pVehicle->AutoPilot.TempAction = 1;
    pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 1000;
  }
LABEL_480:
  if ( (CTimer::m_FrameCounter & 0xF) == 14
    && *(_BYTE *)p_m_nVehicleFlags << 31
    && (*(_BYTE *)&pVehicle->m_info & 0xF0) == 16 )
  {
    v368 = (unsigned __int8)pVehicle->AutoPilot.Mission;
    v369 = v368 == 1;
    if ( v368 == 1 )
      v369 = pVehicle->m_vehicleType == 0;
    if ( v369 && CPopCycle::m_bCurrentZoneIsGangArea )
    {
      m_nSize = CPools::ms_pPedPool->m_nSize;
      if ( m_nSize )
      {
        v371 = 0;
        do
        {
          v372 = 1996 * m_nSize--;
          v373 = v372 - 1996;
          while ( 1 )
          {
            if ( (CPools::ms_pPedPool->m_aFlags[m_nSize] & 0x80u) == 0 )
            {
              v374 = &(*CPools::ms_pPedPool->m_aStorage)[v373];
              if ( v374 )
              {
                if ( (unsigned int)(*((_DWORD *)v374 + 359) - 7) < 0xB )
                {
                  v375 = pVehicle->m_pMat;
                  v376 = *((_DWORD *)v374 + 5);
                  v377 = (CSimpleTransform *)&v375->tx;
                  if ( !v375 )
                    v377 = &pVehicle->m_transform;
                  v378 = (uint8 *)(v376 + 48);
                  if ( !v376 )
                    v378 = v374 + 4;
                  v379.n64_u64[0] = vsub_f32(*(float32x2_t *)&v377->m_translate.y, *(float32x2_t *)(v378 + 4)).n64_u64[0];
                  v380 = vmul_f32(v379, v379).n64_u64[0];
                  if ( sqrtf(
                         (float)((float)((float)(v377->m_translate.x - *(float *)v378)
                                       * (float)(v377->m_translate.x - *(float *)v378))
                               + *(float *)&v380)
                       + *((float *)&v380 + 1)) < 10.0 )
                    break;
                }
              }
            }
            --m_nSize;
            v373 -= 1996;
            if ( m_nSize == -1 )
              goto LABEL_504;
          }
          ++v371;
        }
        while ( m_nSize );
      }
      else
      {
        v371 = 0;
      }
LABEL_504:
      v381 = 10 - v371;
      if ( 10 - v371 <= 1 )
        v381 = 1;
      pVehicle->AutoPilot.CruiseSpeed = v381;
    }
  }
}
// 2E46FE: variable 'v2' is possibly undefined
// 2E46FE: variable 'v3' is possibly undefined
// 2E593E: variable 'v4' is possibly undefined
// 2E5942: variable 'v1' is possibly undefined
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (002E6138) --------------------------------------------------------
Int32 __fastcall CCarAI::FindPoliceCarSpeedForWantedLevel(CVehicle *pVehicle)
{
  eWantedLevel m_WantedLevel; // r1
  Int32 result; // r0
  float v4; // s0
  float v5; // s0
  float v6; // s2

  m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
  result = 25;
  switch ( m_WantedLevel )
  {
    case WANTED_CLEAN:
      v4 = (float)((float)((float)rand() * 4.6566e-10) * 4.0) + 12.0;
      goto LABEL_10;
    case WANTED_LEVEL1:
      return result;
    case WANTED_LEVEL2:
      return 34;
    case WANTED_LEVEL3:
      v5 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
      v6 = 0.9;
      goto LABEL_9;
    case WANTED_LEVEL4:
      v5 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
      v6 = 1.2;
      goto LABEL_9;
    case WANTED_LEVEL5:
      v4 = (float)(pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0) * 1.25;
      goto LABEL_10;
    case WANTED_LEVEL6:
      v5 = pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0;
      v6 = 1.3;
LABEL_9:
      v4 = v5 * v6;
LABEL_10:
      result = (int)v4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (002E6204) --------------------------------------------------------
void __fastcall CCarAI::TellOccupantsToLeaveCar(CVehicle *pVehicle)
{
  CPed *pDriver; // r0
  CTask *TaskByType; // r0
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplexLeaveCar *v5; // r5
  int v6; // r6
  int (***v7)(void); // r5
  int (**v8)(void); // r0
  CTask *v9; // r0
  int (*v10)(void); // r10
  CTaskComplexLeaveCar *v11; // r5

  pDriver = pVehicle->pDriver;
  if ( pDriver )
  {
    TaskByType = CPedIntelligence::FindTaskByType(pDriver->m_pPedIntelligence, 1106);
    if ( TaskByType )
    {
      LOBYTE(TaskByType[6]._vptr$CTask) |= 2u;
    }
    else
    {
      m_pPedIntelligence = pVehicle->pDriver->m_pPedIntelligence;
      v5 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v5, pVehicle, 0, 0, 1, 0);
      CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v5, 3, 0);
    }
  }
  if ( pVehicle->m_nMaxPassengers )
  {
    v6 = 0;
    do
    {
      v7 = &pVehicle->_vptr$CPlaceable + v6;
      v8 = v7[282];
      if ( v8 )
      {
        v9 = CPedIntelligence::FindTaskByType((const CPedIntelligence *)v8[272], 1106);
        if ( v9 )
        {
          LOBYTE(v9[6]._vptr$CTask) |= 2u;
        }
        else
        {
          v10 = v7[282][272];
          v11 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
          CTaskComplexLeaveCar::CTaskComplexLeaveCar(v11, pVehicle, 0, 0, 1, 0);
          CTaskManager::SetTask((CTaskManager *)((char *)v10 + 4), v11, 3, 0);
          rand();
        }
      }
      ++v6;
    }
    while ( v6 < pVehicle->m_nMaxPassengers );
  }
}

//----- (002E62DC) --------------------------------------------------------
void __fastcall CCarAI::MellowOutChaseSpeed(CVehicle *pVehicle)
{
  CMatrix *m_pMat; // r5
  CSimpleTransform *p_tx; // r0
  float v4; // s16
  UInt8 v5; // r0
  CMatrix *v6; // r5
  CSimpleTransform *p_m_transform; // r0
  float v8; // s16
  CPlayerPed *PlayerPed; // r0
  CMatrix *v10; // r0
  CSimpleTransform *v11; // r1
  float32x2_t v12; // d16
  unsigned __int64 v13; // d1
  unsigned int CruiseSpeed; // r0
  CVector v15; // [sp+4h] [bp-1Ch] BYREF

  if ( FindPlayerWanted(-1)->m_WantedLevel == WANTED_LEVEL1 )
  {
    m_pMat = pVehicle->m_pMat;
    FindPlayerCoors(&v15, -1);
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pVehicle->m_transform;
    v4 = sqrtf(
           (float)((float)((float)(p_tx->m_translate.x - v15.x) * (float)(p_tx->m_translate.x - v15.x))
                 + (float)((float)(p_tx->m_translate.y - v15.y) * (float)(p_tx->m_translate.y - v15.y)))
         + (float)((float)(p_tx->m_translate.z - v15.z) * (float)(p_tx->m_translate.z - v15.z)));
    if ( FindPlayerVehicle(-1, 0) )
    {
      if ( v4 >= 10.0 )
      {
        v5 = 25;
        if ( v4 < 20.0 )
          v5 = 22;
      }
      else
      {
        v5 = 15;
      }
      goto LABEL_27;
    }
    if ( v4 >= 20.0 )
    {
      v5 = 25;
      if ( v4 < 40.0 )
        v5 = 13;
      goto LABEL_27;
    }
LABEL_21:
    v5 = 5;
LABEL_27:
    pVehicle->AutoPilot.CruiseSpeed = v5;
    goto LABEL_28;
  }
  if ( FindPlayerWanted(-1)->m_WantedLevel == WANTED_LEVEL2 )
  {
    v6 = pVehicle->m_pMat;
    FindPlayerCoors(&v15, -1);
    p_m_transform = (CSimpleTransform *)&v6->tx;
    if ( !v6 )
      p_m_transform = &pVehicle->m_transform;
    v8 = sqrtf(
           (float)((float)((float)(p_m_transform->m_translate.x - v15.x) * (float)(p_m_transform->m_translate.x - v15.x))
                 + (float)((float)(p_m_transform->m_translate.y - v15.y) * (float)(p_m_transform->m_translate.y - v15.y)))
         + (float)((float)(p_m_transform->m_translate.z - v15.z) * (float)(p_m_transform->m_translate.z - v15.z)));
    if ( FindPlayerVehicle(-1, 0) )
    {
      if ( v8 >= 10.0 )
      {
        v5 = 34;
        if ( v8 < 20.0 )
          v5 = 30;
      }
      else
      {
        v5 = 27;
      }
      goto LABEL_27;
    }
    if ( v8 >= 20.0 )
    {
      v5 = 34;
      if ( v8 < 40.0 )
        v5 = 18;
      goto LABEL_27;
    }
    goto LABEL_21;
  }
LABEL_28:
  if ( !FindPlayerVehicle(-1, 0) )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( sqrtf(
           (float)((float)(PlayerPed->m_vecMoveSpeed.x * PlayerPed->m_vecMoveSpeed.x)
                 + (float)(PlayerPed->m_vecMoveSpeed.y * PlayerPed->m_vecMoveSpeed.y))
         + (float)(PlayerPed->m_vecMoveSpeed.z * PlayerPed->m_vecMoveSpeed.z)) < 0.07 )
    {
      FindPlayerCoors(&v15, -1);
      v10 = pVehicle->m_pMat;
      v11 = (CSimpleTransform *)&v10->tx;
      if ( !v10 )
        v11 = &pVehicle->m_transform;
      v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&v15.y, *(float32x2_t *)&v11->m_translate.y).n64_u64[0];
      v13 = vmul_f32(v12, v12).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(v15.x - v11->m_translate.x) * (float)(v15.x - v11->m_translate.x)) + *(float *)&v13)
           + *((float *)&v13 + 1)) < 30.0 )
      {
        CruiseSpeed = pVehicle->AutoPilot.CruiseSpeed;
        if ( CruiseSpeed >= 0xA )
          LOBYTE(CruiseSpeed) = 10;
        pVehicle->AutoPilot.CruiseSpeed = CruiseSpeed;
      }
    }
  }
}

//----- (002E6514) --------------------------------------------------------
void __fastcall CCarAI::MellowOutChaseSpeedBoat(CVehicle *pVehicle)
{
  eWantedLevel m_WantedLevel; // r1
  UInt8 v3; // r0

  m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
  v3 = 8;
  switch ( m_WantedLevel )
  {
    case WANTED_CLEAN:
      goto LABEL_3;
    case WANTED_LEVEL1:
      v3 = 10;
LABEL_3:
      pVehicle->AutoPilot.CruiseSpeed = v3;
      break;
    case WANTED_LEVEL2:
      pVehicle->AutoPilot.CruiseSpeed = 15;
      break;
    case WANTED_LEVEL3:
      pVehicle->AutoPilot.CruiseSpeed = 20;
      break;
    case WANTED_LEVEL4:
      pVehicle->AutoPilot.CruiseSpeed = 25;
      break;
    case WANTED_LEVEL5:
      pVehicle->AutoPilot.CruiseSpeed = 30;
      break;
    case WANTED_LEVEL6:
      pVehicle->AutoPilot.CruiseSpeed = 40;
      break;
  }
}

//----- (002E6568) --------------------------------------------------------
int CCarAI::FindPoliceBoatMissionForWantedLevel()
{
  eWantedLevel m_WantedLevel; // r4
  bool v1; // zf
  int v2; // r1
  int v3; // r0

  m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
  v1 = FindPlayerVehicle(-1, 0) == 0;
  v2 = 64;
  v3 = 64;
  if ( !v1 )
  {
    v3 = 21;
    v2 = 4;
  }
  if ( (unsigned int)(m_WantedLevel - 2) < 5 )
    return v3;
  return v2;
}

//----- (002E659E) --------------------------------------------------------
int CCarAI::FindPoliceBikeMissionForWantedLevel()
{
  return 43;
}

//----- (002E65A2) --------------------------------------------------------
int CCarAI::FindPoliceCarMissionForWantedLevel()
{
  eWantedLevel m_WantedLevel; // r0
  char v1; // r1
  int result; // r0
  int v3; // r1
  unsigned int v4; // r1

  m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
  if ( (unsigned int)(m_WantedLevel - 4) >= 3 )
  {
    if ( m_WantedLevel == WANTED_LEVEL3 )
    {
      v4 = rand() & 2;
      result = 2;
      if ( v4 < 2 )
        return 4;
    }
    else if ( m_WantedLevel == WANTED_LEVEL2 )
    {
      v3 = rand() & 3;
      result = 4;
      if ( v3 == 3 )
        return 2;
    }
    else
    {
      return 4;
    }
  }
  else
  {
    v1 = rand();
    result = 2;
    if ( (v1 & 3) == 0 )
      return 4;
  }
  return result;
}

//----- (002E65F8) --------------------------------------------------------
void __fastcall CCarAI::CarHasReasonToStop(CVehicle *pVehicle)
{
  pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
}

//----- (002E660C) --------------------------------------------------------
float __fastcall CCarAI::GetCarToGoToCoors(
        CVehicle *pVehicle,
        CVector *pTargetCoors,
        const int iDrivingStyle,
        const bool bSetCruiseSpeed)
{
  int Mission; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d0
  CEntity::CEntityInfo m_info; // r0
  int v13; // r0
  Int8 v14; // r1

  Mission = pVehicle->AutoPilot.Mission;
  if ( ((unsigned int)(Mission - 45) > 5 || ((1 << (Mission - 45)) & 0x33) == 0)
    && ((Mission & 0xFE) != 8
     || fabsf(pTargetCoors->x - pVehicle->AutoPilot.TargetCoors.x) > 5.0
     || fabsf(pTargetCoors->y - pVehicle->AutoPilot.TargetCoors.y) > 5.0) )
  {
    pVehicle->AutoPilot.TempAction = 0;
    pVehicle->AutoPilot.DrivingMode = iDrivingStyle;
    if ( bSetCruiseSpeed )
      pVehicle->AutoPilot.CruiseSpeed = 20;
    m_info = pVehicle->m_info;
    pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
    if ( (*(_BYTE *)&m_info & 0xF8) != 96 )
      pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
    v13 = CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, pTargetCoors, 0, 0);
    v14 = 8;
    if ( v13 )
      v14 = 9;
    pVehicle->AutoPilot.Mission = v14;
  }
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&pTargetCoors->x).n64_u64[0];
  v10 = vmul_f32(v9, v9).n64_u64[0];
  return sqrtf(*(float *)&v10 + *((float *)&v10 + 1));
}

//----- (002E66F8) --------------------------------------------------------
float __fastcall CCarAI::GetCarToGoToCoorsStraightLine(
        CVehicle *pVehicle,
        CVector *pTargetCoors,
        const int iDrivingStyle,
        const bool bSetCruiseSpeed)
{
  float x; // s0
  __int64 v5; // d16
  CEntity::CEntityInfo m_info; // r2
  __int64 v7; // d16
  CMatrix *m_pMat; // r2
  float y; // s2
  CSimpleTransform *p_tx; // r1

  if ( pVehicle->AutoPilot.Mission == 9 )
  {
    x = pTargetCoors->x;
    if ( fabsf(pTargetCoors->x - pVehicle->AutoPilot.TargetCoors.x) > 2.0
      || fabsf(pTargetCoors->y - pVehicle->AutoPilot.TargetCoors.y) > 2.0 )
    {
      v5 = *(_QWORD *)&pTargetCoors->x;
      pVehicle->AutoPilot.TargetCoors.z = pTargetCoors->z;
      *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x = v5;
    }
  }
  else
  {
    pVehicle->AutoPilot.TempAction = 0;
    pVehicle->AutoPilot.DrivingMode = iDrivingStyle;
    if ( bSetCruiseSpeed )
      pVehicle->AutoPilot.CruiseSpeed = 20;
    m_info = pVehicle->m_info;
    pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
    if ( (*(_BYTE *)&m_info & 0xF8) != 96 )
      pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
    v7 = *(_QWORD *)&pTargetCoors->x;
    pVehicle->AutoPilot.TargetCoors.z = pTargetCoors->z;
    pVehicle->AutoPilot.Mission = 9;
    *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x = v7;
    x = pTargetCoors->x;
  }
  m_pMat = pVehicle->m_pMat;
  y = pTargetCoors->y;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  return sqrtf(
           (float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
         + (float)((float)(p_tx->m_translate.y - y) * (float)(p_tx->m_translate.y - y)));
}

//----- (002E67D8) --------------------------------------------------------
float __fastcall CCarAI::GetCarToGoToCoorsAccurate(
        CVehicle *pVehicle,
        CVector *pTargetCoors,
        const int iDrivingStyle,
        const bool bSetCruiseSpeed)
{
  float x; // s0
  __int64 v7; // d16
  CEntity::CEntityInfo m_info; // r0
  int v9; // r0
  Int8 v10; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1

  if ( (pVehicle->AutoPilot.Mission & 0xFE) == 12 )
  {
    x = pTargetCoors->x;
    if ( fabsf(pTargetCoors->x - pVehicle->AutoPilot.TargetCoors.x) > 2.0
      || fabsf(pTargetCoors->y - pVehicle->AutoPilot.TargetCoors.y) > 2.0 )
    {
      v7 = *(_QWORD *)&pTargetCoors->x;
      pVehicle->AutoPilot.TargetCoors.z = pTargetCoors->z;
      *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x = v7;
    }
  }
  else
  {
    pVehicle->AutoPilot.TempAction = 0;
    pVehicle->AutoPilot.DrivingMode = iDrivingStyle;
    if ( bSetCruiseSpeed )
      pVehicle->AutoPilot.CruiseSpeed = 20;
    m_info = pVehicle->m_info;
    pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
    if ( (*(_BYTE *)&m_info & 0xF8) != 96 )
      pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
    v9 = CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, pTargetCoors, 0, 0);
    v10 = 12;
    if ( v9 )
      v10 = 13;
    pVehicle->AutoPilot.Mission = v10;
    x = pTargetCoors->x;
  }
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  return sqrtf(
           (float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
         + (float)((float)(p_tx->m_translate.y - pTargetCoors->y) * (float)(p_tx->m_translate.y - pTargetCoors->y)));
}

//----- (002E68C4) --------------------------------------------------------
float __fastcall CCarAI::GetCarToGoToCoorsRacing(
        CVehicle *pVehicle,
        CVector *pTargetCoors,
        const int iDrivingStyle,
        const bool bSetCruiseSpeed)
{
  int Mission; // r0
  bool v7; // zf
  float x; // s0
  __int64 v9; // d16
  CEntity::CEntityInfo m_info; // r0
  __int64 v11; // d16
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1

  Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
  v7 = Mission == 33;
  if ( Mission != 33 )
    v7 = Mission == 9;
  if ( v7 )
  {
    x = pTargetCoors->x;
    if ( fabsf(pTargetCoors->x - pVehicle->AutoPilot.TargetCoors.x) > 2.0
      || fabsf(pTargetCoors->y - pVehicle->AutoPilot.TargetCoors.y) > 2.0 )
    {
      v9 = *(_QWORD *)&pTargetCoors->x;
      pVehicle->AutoPilot.TargetCoors.z = pTargetCoors->z;
      *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x = v9;
    }
  }
  else
  {
    pVehicle->AutoPilot.TempAction = 0;
    pVehicle->AutoPilot.DrivingMode = iDrivingStyle;
    if ( bSetCruiseSpeed )
      pVehicle->AutoPilot.CruiseSpeed = 20;
    m_info = pVehicle->m_info;
    pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
    if ( (*(_BYTE *)&m_info & 0xF8) != 96 )
      pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
    v11 = *(_QWORD *)&pTargetCoors->x;
    pVehicle->AutoPilot.TargetCoors.z = pTargetCoors->z;
    pVehicle->AutoPilot.Mission = 33;
    *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x = v11;
    CCarCtrl::JoinCarWithRoadSystemGotoCoors(pVehicle, pTargetCoors, 0, 0);
    x = pTargetCoors->x;
  }
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  return sqrtf(
           (float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
         + (float)((float)(p_tx->m_translate.y - pTargetCoors->y) * (float)(p_tx->m_translate.y - pTargetCoors->y)));
}

//----- (002E69B8) --------------------------------------------------------
float __fastcall CCarAI::GetCarToParkAtCoors(CVehicle *pVehicle, CVector *pTargetCoors)
{
  CMatrix *m_pMat; // r2
  int v5; // r0
  CSimpleTransform *p_tx; // r0
  float32x2_t v7; // d16
  unsigned __int64 v8; // d0

  CCarAI::GetCarToGoToCoors(pVehicle, pTargetCoors, 0, 1);
  m_pMat = pVehicle->m_pMat;
  v5 = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) | 4;
  pVehicle->AutoPilot.CruiseSpeed = 10;
  *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) = v5;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&pTargetCoors->x).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  return sqrtf(*(float *)&v8 + *((float *)&v8 + 1));
}

//----- (002E6A04) --------------------------------------------------------
void __fastcall CCarAI::AddPoliceCarOccupants(CVehicle *pVehicle, bool bAlwaysCreatePassenger)
{
  _BOOL4 v3; // r6
  int m_nVehicleFlags; // r0
  CVehicle::CVehicleFlags v5; // r0
  int m_nModelIndex; // r0
  CPed *v7; // r6
  CTaskSimpleCarSetPedOut *v8; // r0
  CPedIntelligence *m_pPedIntelligence; // r5
  CTaskComplexKillPedFromBoat *v10; // r6
  CPlayerPed *PlayerPed; // r0
  CPed *v12; // r8
  CPed *v13; // r10
  CPed *v14; // r0
  CPedIntelligence *v15; // r6
  CTaskComplexCopInCar *v16; // r5
  CPlayerPed *v17; // r0
  CPedIntelligence *v18; // r6
  CTaskComplexCopInCar *v19; // r5
  CPlayerPed *v20; // r0
  CTaskSimpleCarSetPedOut v21; // [sp+10h] [bp-48h] BYREF
  CVector cvector; // 0:r2.8,8:^0.4

  v3 = bAlwaysCreatePassenger;
  m_nVehicleFlags = (int)pVehicle->m_nVehicleFlags;
  if ( (m_nVehicleFlags & 0x400000) != 0 )
    return;
  *((_DWORD *)&v5 + 1) = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1);
  *(_DWORD *)&v5 = m_nVehicleFlags | 0x400000;
  pVehicle->m_nVehicleFlags = v5;
  m_nModelIndex = pVehicle->m_nModelIndex;
  if ( m_nModelIndex <= 522 )
  {
    switch ( pVehicle->m_nModelIndex )
    {
      case 0x1AB:
        goto LABEL_18;
      case 0x1AC:
      case 0x1AD:
      case 0x1AF:
        return;
      case 0x1AE:
        if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL2 )
        {
          v7 = CVehicle::SetUpDriver(pVehicle, -1, 0, 0);
          CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(&v21, pVehicle, 10, 1);
          CTaskSimpleCarSetPedOut::ProcessPed(v8, v7);
          cvector.z = 2.0;
          *(_QWORD *)&cvector.x = 0x4040000000000000LL;
          CPed::AttachPedToEntity(v7, pVehicle, cvector, 0, 6.2832, WEAPONTYPE_PISTOL);
          m_pPedIntelligence = v7->m_pPedIntelligence;
          *(_DWORD *)&v7->m_nPedFlags |= 0x200000u;
          v10 = (CTaskComplexKillPedFromBoat *)CTask::operator new(0x10u);
          PlayerPed = FindPlayerPed(-1);
          CTaskComplexKillPedFromBoat::CTaskComplexKillPedFromBoat(v10, PlayerPed);
          CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v10, 3, 0);
          CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(&v21);
        }
        CVehicle::SetUpDriver(pVehicle, -1, 0, 0);
        return;
      case 0x1B0:
        goto LABEL_16;
      case 0x1B1:
        goto LABEL_8;
      default:
        if ( m_nModelIndex == 490 )
        {
LABEL_18:
          CVehicle::SetUpDriver(pVehicle, -1, 0, 0);
          CVehicle::SetupPassenger(pVehicle, 0, -1, 0, 0);
          CVehicle::SetupPassenger(pVehicle, 1, -1, 0, 0);
          CVehicle::SetupPassenger(pVehicle, 2, -1, 0, 0);
        }
        break;
    }
    return;
  }
  if ( (unsigned int)(m_nModelIndex - 596) < 4 )
  {
LABEL_8:
    v12 = CVehicle::SetUpDriver(pVehicle, -1, 0, 0);
    if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel < WANTED_LEVEL2 )
    {
      if ( v3 || (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 49 )
        CVehicle::SetupPassenger(pVehicle, 0, -1, 0, 0);
      return;
    }
    v13 = CVehicle::SetupPassenger(pVehicle, 0, -1, 0, 0);
    if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL3 )
    {
      if ( (float)((float)((float)rand() * 4.6566e-10) + 0.0) < 0.25 )
      {
        v14 = v12;
LABEL_22:
        CPed::GiveDelayedWeapon(v14, WEAPONTYPE_SHOTGUN, 0x3E8u);
        goto LABEL_23;
      }
      if ( (float)((float)((float)rand() * 4.6566e-10) + 0.0) < 0.25 )
      {
        v14 = v13;
        goto LABEL_22;
      }
    }
LABEL_23:
    CPedIntelligence::ClearTasks(v12->m_pPedIntelligence, 1, 1);
    v15 = v12->m_pPedIntelligence;
    v16 = (CTaskComplexCopInCar *)CTask::operator new(0x34u);
    v17 = FindPlayerPed(-1);
    CTaskComplexCopInCar::CTaskComplexCopInCar(v16, pVehicle, v13, v17, 1);
    CTaskManager::SetTask(&v15->m_taskManager, v16, 3, 1);
    CPedIntelligence::ClearTasks(v13->m_pPedIntelligence, 1, 1);
    v18 = v13->m_pPedIntelligence;
    v19 = (CTaskComplexCopInCar *)CTask::operator new(0x34u);
    v20 = FindPlayerPed(-1);
    CTaskComplexCopInCar::CTaskComplexCopInCar(v19, pVehicle, v12, v20, 0);
    sub_1951C0(&v18->m_taskManager, v19, 3, 1);
    return;
  }
  if ( m_nModelIndex == 523 )
LABEL_16:
    sub_1931CC(pVehicle, -1, 0, 0);
}
// 2E6A8E: variable 'v8' is possibly undefined

//----- (002E6CF8) --------------------------------------------------------
void __fastcall CCarAI::AddAmbulanceOccupants(CVehicle *pVehicle)
{
  CPed *v2; // r8
  CPed *v3; // r9
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskSimpleCarDrive *v5; // r5
  CPedIntelligence *v6; // r6
  CTaskComplexMedicTreatInjuredPed *v7; // r5
  CPedIntelligence *v8; // r6
  CTaskSimpleCarDrive *v9; // r5
  CPedIntelligence *v10; // r6
  CTaskComplexMedicTreatInjuredPed *v11; // r5

  v2 = CVehicle::SetUpDriver(pVehicle, -1, 0, 0);
  v3 = CVehicle::SetupPassenger(pVehicle, 1, -1, 0, 0);
  m_pPedIntelligence = v2->m_pPedIntelligence;
  v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v5, pVehicle, 0, 0);
  CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v5, 4, 0);
  v6 = v2->m_pPedIntelligence;
  v7 = (CTaskComplexMedicTreatInjuredPed *)CTask::operator new(0x2Cu);
  CTaskComplexMedicTreatInjuredPed::CTaskComplexMedicTreatInjuredPed(v7, pVehicle, v3, 1);
  CTaskManager::SetTask(&v6->m_taskManager, v7, 3, 0);
  v8 = v3->m_pPedIntelligence;
  v9 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v9, pVehicle, 0, 0);
  CTaskManager::SetTask(&v8->m_taskManager, v9, 4, 0);
  v10 = v3->m_pPedIntelligence;
  v11 = (CTaskComplexMedicTreatInjuredPed *)CTask::operator new(0x2Cu);
  CTaskComplexMedicTreatInjuredPed::CTaskComplexMedicTreatInjuredPed(v11, pVehicle, v2, 0);
  sub_1951C0(&v10->m_taskManager, v11, 3, 0);
}

//----- (002E6DB8) --------------------------------------------------------
void __fastcall CCarAI::AddFiretruckOccupants(CVehicle *pVehicle)
{
  CPed *v2; // r8
  CPed *v3; // r9
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskSimpleCarDrive *v5; // r5
  CPedIntelligence *v6; // r6
  CTaskComplexDriveFireTruck *v7; // r5
  CPedIntelligence *v8; // r6
  CTaskSimpleCarDrive *v9; // r5
  CPedIntelligence *v10; // r6
  CTaskComplexDriveFireTruck *v11; // r5

  v2 = CVehicle::SetUpDriver(pVehicle, -1, 0, 0);
  v3 = CVehicle::SetupPassenger(pVehicle, 0, -1, 0, 0);
  m_pPedIntelligence = v2->m_pPedIntelligence;
  v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v5, pVehicle, 0, 0);
  CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v5, 4, 0);
  v6 = v2->m_pPedIntelligence;
  v7 = (CTaskComplexDriveFireTruck *)CTask::operator new(0x1Cu);
  CTaskComplexDriveFireTruck::CTaskComplexDriveFireTruck(v7, pVehicle, v3, 1);
  CTaskManager::SetTask(&v6->m_taskManager, v7, 3, 0);
  v8 = v3->m_pPedIntelligence;
  v9 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v9, pVehicle, 0, 0);
  CTaskManager::SetTask(&v8->m_taskManager, v9, 4, 0);
  v10 = v3->m_pPedIntelligence;
  v11 = (CTaskComplexDriveFireTruck *)CTask::operator new(0x1Cu);
  CTaskComplexDriveFireTruck::CTaskComplexDriveFireTruck(v11, pVehicle, v2, 0);
  sub_1951C0(&v10->m_taskManager, v11, 3, 0);
}

//----- (002E6E78) --------------------------------------------------------
void __fastcall CCarAI::TellCarToRamOtherCar(CVehicle *pOurVehicle, CVehicle *pTargetVehicle)
{
  unsigned int CruiseSpeed; // r0
  int m_nVehicleFlags; // r1
  int v5; // r2
  unsigned int v6; // r0

  pOurVehicle->AutoPilot.pTargetEntity = pTargetVehicle;
  CEntity::RegisterReference(pTargetVehicle, &pOurVehicle->AutoPilot.pTargetEntity);
  CCarCtrl::JoinCarWithRoadSystem(pOurVehicle);
  pOurVehicle->AutoPilot.Mission = 15;
  CruiseSpeed = pOurVehicle->AutoPilot.CruiseSpeed;
  m_nVehicleFlags = (int)pOurVehicle->m_nVehicleFlags;
  v5 = *((_DWORD *)&pOurVehicle->m_nVehicleFlags + 1);
  if ( CruiseSpeed <= 6 )
    LOBYTE(CruiseSpeed) = 6;
  pOurVehicle->AutoPilot.CruiseSpeed = CruiseSpeed;
  v6 = m_nVehicleFlags & 0xFFFFFFEF;
  if ( (v5 & 0x200) == 0 )
    v6 = m_nVehicleFlags | 0x10;
  *(_DWORD *)&pOurVehicle->m_nVehicleFlags = v6;
}

//----- (002E6EC4) --------------------------------------------------------
void __fastcall CCarAI::TellCarToBlockOtherCar(CVehicle *pOurVehicle, CVehicle *pTargetVehicle)
{
  unsigned int CruiseSpeed; // r0
  int m_nVehicleFlags; // r1
  int v5; // r2
  unsigned int v6; // r0

  pOurVehicle->AutoPilot.pTargetEntity = pTargetVehicle;
  CEntity::RegisterReference(pTargetVehicle, &pOurVehicle->AutoPilot.pTargetEntity);
  CCarCtrl::JoinCarWithRoadSystem(pOurVehicle);
  pOurVehicle->AutoPilot.Mission = 17;
  CruiseSpeed = pOurVehicle->AutoPilot.CruiseSpeed;
  m_nVehicleFlags = (int)pOurVehicle->m_nVehicleFlags;
  v5 = *((_DWORD *)&pOurVehicle->m_nVehicleFlags + 1);
  if ( CruiseSpeed <= 6 )
    LOBYTE(CruiseSpeed) = 6;
  pOurVehicle->AutoPilot.CruiseSpeed = CruiseSpeed;
  v6 = m_nVehicleFlags & 0xFFFFFFEF;
  if ( (v5 & 0x200) == 0 )
    v6 = m_nVehicleFlags | 0x10;
  *(_DWORD *)&pOurVehicle->m_nVehicleFlags = v6;
}

//----- (002E6F10) --------------------------------------------------------
void __fastcall CCarAI::TellCarToFollowOtherCar(CVehicle *pOurVehicle, CVehicle *pTargetVehicle, float FollowDistance)
{
  unsigned int CruiseSpeed; // r0
  int m_nVehicleFlags; // r1
  int v7; // r2
  unsigned int v8; // r0

  pOurVehicle->AutoPilot.pTargetEntity = pTargetVehicle;
  CEntity::RegisterReference(pTargetVehicle, &pOurVehicle->AutoPilot.pTargetEntity);
  CCarCtrl::JoinCarWithRoadSystem(pOurVehicle);
  pOurVehicle->AutoPilot.Mission = 52;
  pOurVehicle->AutoPilot.FollowCarDistance = (unsigned int)FollowDistance;
  CruiseSpeed = pOurVehicle->AutoPilot.CruiseSpeed;
  m_nVehicleFlags = (int)pOurVehicle->m_nVehicleFlags;
  v7 = *((_DWORD *)&pOurVehicle->m_nVehicleFlags + 1);
  if ( CruiseSpeed <= 6 )
    LOBYTE(CruiseSpeed) = 6;
  pOurVehicle->AutoPilot.CruiseSpeed = CruiseSpeed;
  v8 = m_nVehicleFlags & 0xFFFFFFEF;
  if ( (v7 & 0x200) == 0 )
    v8 = m_nVehicleFlags | 0x10;
  *(_DWORD *)&pOurVehicle->m_nVehicleFlags = v8;
}

//----- (002E6F70) --------------------------------------------------------
void __fastcall CCarAI::MakeWayForCarWithSiren(CVehicle *pVehicleWithSiren)
{
  float x; // s2
  float y; // s0
  float v3; // s4
  CVehiclePool *v4; // r1
  int32 m_nSize; // r3
  float v6; // s0
  int v7; // r2
  int v8; // r3
  float v9; // s2
  float v10; // s4
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r8
  int v12; // r6
  uint8 *v13; // r11
  int v14; // r5
  bool v15; // zf
  uint8 v16; // lr
  int v17; // r9
  int v18; // r6
  int v19; // r12
  float *v20; // r9
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r5
  float *v23; // r6
  float v24; // s1
  float v25; // s3
  float v26; // s9
  float v27; // s5
  float v28; // s7
  float v29; // s9
  uint8 *v30; // r6
  int v31; // r5
  bool v32; // zf
  uint8 *v33; // r6
  int v34; // r5
  bool v35; // zf
  uint8 *v36; // r12
  int v37; // r6
  int v38; // r5

  x = pVehicleWithSiren->m_vecMoveSpeed.x;
  y = pVehicleWithSiren->m_vecMoveSpeed.y;
  v3 = sqrtf((float)(x * x) + (float)(y * y));
  if ( v3 >= 0.1 )
  {
    v4 = CPools::ms_pVehiclePool;
    m_nSize = CPools::ms_pVehiclePool->m_nSize;
    if ( m_nSize )
    {
      v6 = y / v3;
      v7 = 2604 * m_nSize;
      v8 = m_nSize - 1;
      v9 = x / v3;
      v10 = (float)(v3 * 45.0) + 40.0;
      do
      {
        if ( (v4->m_aFlags[v8] & 0x80u) != 0 )
          goto LABEL_50;
        m_aStorage = v4->m_aStorage;
        v12 = (int)&(*v4->m_aStorage)[-2604];
        if ( !(v12 + v7) )
          goto LABEL_50;
        v13 = m_aStorage[v7 / 0xA2Cu];
        v14 = *(_DWORD *)&m_aStorage[v7 / 0xA2Cu - 1][1440];
        v15 = v14 == 9;
        if ( v14 != 9 )
          v15 = v14 == 0;
        if ( !v15 )
          goto LABEL_50;
        v16 = (*m_aStorage)[v7 - 2546];
        if ( (v16 & 0xF0) != 16 || *(v13 - 1412) != 1 || (*((_DWORD *)v13 - 384) & 1) != 0 )
          goto LABEL_50;
        v17 = v12 - (_DWORD)pVehicleWithSiren + v7;
        v18 = *((_DWORD *)v13 - 370);
        if ( v18 )
        {
          if ( *(_BYTE *)(v18 + 1096) == 1 && v17 )
          {
LABEL_18:
            if ( !(*((_DWORD *)v13 - 383) & 0x80000 | *((_DWORD *)v13 - 384) & 6) )
            {
              v19 = (int)&(*m_aStorage)[v7 - 2600];
              if ( BYTE1(CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v19 + 34)][1].m_pColModel) != 5 )
              {
                v20 = *(float **)(v19 + 16);
                m_pMat = pVehicleWithSiren->m_pMat;
                p_tx = (CSimpleTransform *)&m_pMat->tx;
                if ( !m_pMat )
                  p_tx = &pVehicleWithSiren->m_transform;
                v23 = (float *)&(*m_aStorage)[v7 - 2600];
                if ( v20 )
                  v23 = v20 + 12;
                if ( fabsf(p_tx->m_translate.z - v23[2]) < 5.0 )
                {
                  v24 = *v23 - p_tx->m_translate.x;
                  v25 = v23[1] - p_tx->m_translate.y;
                  v26 = sqrtf((float)(v24 * v24) + (float)(v25 * v25));
                  if ( v26 < v10 )
                  {
                    v27 = *(float *)(v19 + 68);
                    v28 = *((float *)v13 - 632);
                    if ( sqrtf((float)(v27 * v27) + (float)(v28 * v28)) > 0.05 )
                    {
                      if ( (float)((float)((float)(v9 * v24) + (float)(v6 * v25)) / v26) <= 0.8 )
                      {
                        if ( (float)((float)(v24 * v27) + (float)(v25 * v28)) < 0.0 )
                        {
                          v33 = &(*m_aStorage)[-1645];
                          v34 = (*m_aStorage)[v7 - 1645];
                          v35 = v34 == 1;
                          if ( v34 != 1 )
                            v35 = v34 == 24;
                          if ( !v35 )
                          {
                            v33[v7] = 1;
                            *(_DWORD *)&v33[v7 + 1] = CTimer::m_snTimeInMilliseconds + 2000;
                          }
                        }
                      }
                      else
                      {
                        v29 = (float)(v9 * v20[4]) + (float)(v6 * v20[5]);
                        if ( v29 > 0.7 || v29 < -0.9 )
                        {
                          v36 = &(*m_aStorage)[-1645];
                          if ( ((*m_aStorage)[v7 - 1645] & 0xFE) != 20 )
                          {
                            v37 = 20;
                            v38 = 21;
                            if ( (float)((float)(v6 * v24) - (float)(v9 * v25)) > 0.0 )
                            {
                              v37 = 21;
                              v38 = 20;
                            }
                            if ( v29 < 0.0 )
                              v38 = v37;
                            if ( v38 == 21 )
                              LOBYTE(v38) = 1;
                            v36[v7] = v38;
                            *(_DWORD *)&v36[v7 + 1] = CTimer::m_snTimeInMilliseconds + 2500;
                          }
                          if ( (v16 & 0xF8) != 96 )
                            (*m_aStorage)[v7 - 2546] = v16 & 7 | 0x18;
                        }
                        else if ( (float)((float)(v24 * v27) + (float)(v25 * v28)) < 0.0 )
                        {
                          v30 = &(*m_aStorage)[-1645];
                          v31 = (*m_aStorage)[v7 - 1645];
                          v32 = v31 == 1;
                          if ( v31 != 1 )
                            v32 = v31 == 24;
                          if ( !v32 )
                          {
                            v30[v7] = 1;
                            *(_DWORD *)&v30[v7 + 1] = CTimer::m_snTimeInMilliseconds + 4000;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else if ( v17 )
        {
          goto LABEL_18;
        }
LABEL_50:
        --v8;
        v7 -= 2604;
      }
      while ( v8 != -1 );
    }
  }
}

//----- (002E7300) --------------------------------------------------------
bool __fastcall CTaskComplexSequence::Contains(CTaskComplexSequence *this, const int iTaskType)
{
  CTask *v4; // r0
  CTask *v5; // r0
  CTask *v6; // r0
  CTask *v7; // r0
  CTask *v8; // r0
  CTask *v9; // r0
  CTask *v10; // r0
  CTask *v11; // r0
  bool result; // r0

  v4 = this->m_tasks[0];
  result = 1;
  if ( !v4 || (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 5))(v4) != iTaskType )
  {
    v5 = this->m_tasks[1];
    if ( !v5 || (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 5))(v5) != iTaskType )
    {
      v6 = this->m_tasks[2];
      if ( !v6 || (*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 5))(v6) != iTaskType )
      {
        v7 = this->m_tasks[3];
        if ( !v7 || (*((int (__fastcall **)(CTask *))v7->_vptr$CTask + 5))(v7) != iTaskType )
        {
          v8 = this->m_tasks[4];
          if ( !v8 || (*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 5))(v8) != iTaskType )
          {
            v9 = this->m_tasks[5];
            if ( !v9 || (*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 5))(v9) != iTaskType )
            {
              v10 = this->m_tasks[6];
              if ( !v10 || (*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 5))(v10) != iTaskType )
              {
                v11 = this->m_tasks[7];
                if ( !v11 || (*((int (__fastcall **)(CTask *))v11->_vptr$CTask + 5))(v11) != iTaskType )
                  return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (002E7380) --------------------------------------------------------
void CCarCtrl::Init()
{
  int v0; // r0

  CCarCtrl::NumRandomCars = 0;
  CCarCtrl::CarDensityMultiplier = 1.0;
  CCarCtrl::NumAmbulancesOnDuty = 0;
  CCarCtrl::NumParkedCars = 0;
  CCarCtrl::NumPermanentVehicles = 0;
  CCarCtrl::NumLawEnforcerCars = 0;
  CCarCtrl::NumFireTrucksOnDuty = 0;
  CCarCtrl::LastTimeAmbulanceCreated = 0;
  CCarCtrl::LastTimeFireTruckCreated = 0;
  CCarCtrl::NumMissionCars = 0;
  v0 = rand();
  apCarsToKeep[0] = 0;
  apCarsToKeep[1] = 0;
  CCarCtrl::bAllowEmergencyServicesToBeCreated = 1;
  CCarCtrl::CountDownToCarsAtStart = 2;
  CCarCtrl::bCarsGeneratedAroundCamera = 0;
  CCarCtrl::TimeNextMadDriverChaseCreated = (float)((float)((float)v0 * 4.6566e-10) * 600.0) + 600.0;
  CLoadedCarGroup::Clear(CPopulation::m_LoadedGangCars);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[1]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[2]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[3]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[4]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[5]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[6]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[7]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[8]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[9]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[10]);
  CLoadedCarGroup::Clear(&CPopulation::m_AppropriateLoadedCars);
  CLoadedCarGroup::Clear(&CPopulation::m_InAppropriateLoadedCars);
  sub_19AE84(&CPopulation::m_LoadedBoats);
}
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;
// 677AB4: using guessed type int CCarCtrl::NumParkedCars[2];
// 67816C: using guessed type int *CCarCtrl::NumMissionCars;
// 679B78: using guessed type int *CCarCtrl::NumPermanentVehicles;
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;
// 679EA4: using guessed type CLoadedCarGroup *CPopulation::m_InAppropriateLoadedCars;
// 679EBC: using guessed type CLoadedCarGroup *CPopulation::m_LoadedBoats;

//----- (002E7514) --------------------------------------------------------
void CCarCtrl::ReInit()
{
  CCarCtrl::NumRandomCars = 0;
  CCarCtrl::CarDensityMultiplier = 1.0;
  apCarsToKeep[0] = 0;
  apCarsToKeep[1] = 0;
  CCarCtrl::NumAmbulancesOnDuty = 0;
  CCarCtrl::NumFireTrucksOnDuty = 0;
  CCarCtrl::LastTimeLawEnforcerCreated = 0;
  CCarCtrl::NumLawEnforcerCars = 0;
  CCarCtrl::NumMissionCars = 0;
  CCarCtrl::NumParkedCars = 0;
  CCarCtrl::NumPermanentVehicles = 0;
  CCarCtrl::bAllowEmergencyServicesToBeCreated = 1;
  CCarCtrl::CountDownToCarsAtStart = 2;
  CLoadedCarGroup::Clear(CPopulation::m_LoadedGangCars);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[1]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[2]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[3]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[4]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[5]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[6]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[7]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[8]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[9]);
  CLoadedCarGroup::Clear(&CPopulation::m_LoadedGangCars[10]);
  CLoadedCarGroup::Clear(&CPopulation::m_AppropriateLoadedCars);
  CLoadedCarGroup::Clear(&CPopulation::m_InAppropriateLoadedCars);
  sub_19AE84(&CPopulation::m_LoadedBoats);
}
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;
// 677AB4: using guessed type int CCarCtrl::NumParkedCars[2];
// 67816C: using guessed type int *CCarCtrl::NumMissionCars;
// 679B78: using guessed type int *CCarCtrl::NumPermanentVehicles;
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;
// 679EA4: using guessed type CLoadedCarGroup *CPopulation::m_InAppropriateLoadedCars;
// 679EBC: using guessed type CLoadedCarGroup *CPopulation::m_LoadedBoats;

//----- (002E765C) --------------------------------------------------------
CVehicle *__fastcall CCarCtrl::GetNewVehicleDependingOnCarModel(Int32 CarModel, UInt8 CreatedBy)
{
  CMonsterTruck *v4; // r0
  CVehicle *result; // r0
  CQuadBike *v6; // r0
  CHeli *v7; // r0
  CPlane *v8; // r0
  CBoat *v9; // r0
  CTrain *v10; // r0
  CAutomobile *v11; // r0
  CBike *v12; // r0
  CBmx *v13; // r0
  CTrailer *v14; // r0

  switch ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[CarModel][1].m_modelName[20] )
  {
    case 1:
      v4 = (CMonsterTruck *)CVehicle::operator new(0x9B0u);
      CMonsterTruck::CMonsterTruck(v4, CarModel, CreatedBy);
      break;
    case 2:
      v6 = (CQuadBike *)CVehicle::operator new(0x9D0u);
      CQuadBike::CQuadBike(v6, CarModel, CreatedBy);
      break;
    case 3:
      v7 = (CHeli *)CVehicle::operator new(0xA2Cu);
      CHeli::CHeli(v7, CarModel, CreatedBy);
      break;
    case 4:
      v8 = (CPlane *)CVehicle::operator new(0xA18u);
      CPlane::CPlane(v8, CarModel, CreatedBy);
      break;
    case 5:
      v9 = (CBoat *)CVehicle::operator new(0x7FCu);
      CBoat::CBoat(v9, CarModel, CreatedBy);
      break;
    case 6:
      v10 = (CTrain *)CVehicle::operator new(0x6C0u);
      CTrain::CTrain(v10, CarModel, CreatedBy);
      break;
    case 9:
      v12 = (CBike *)CVehicle::operator new(0x828u);
      CBike::CBike(v12, CarModel, CreatedBy);
      goto LABEL_11;
    case 0xA:
      v13 = (CBmx *)CVehicle::operator new(0x84Cu);
      CBmx::CBmx(v13, CarModel, CreatedBy);
LABEL_11:
      LOBYTE(result[1].m_vecTurnFriction.z) |= 0x10u;
      break;
    case 0xB:
      v14 = (CTrailer *)CVehicle::operator new(0xA08u);
      CTrailer::CTrailer(v14, CarModel, CreatedBy);
      break;
    default:
      v11 = (CAutomobile *)CVehicle::operator new(0x99Cu);
      CAutomobile::CAutomobile(v11, CarModel, CreatedBy, 1u);
      break;
  }
  return result;
}
// 2E7728: variable 'result' is possibly undefined

//----- (002E774C) --------------------------------------------------------
void __fastcall CCarCtrl::InitSequence(Int32 NumElements)
{
  SequenceElements = NumElements;
  SequenceRandomOffset = rand() % NumElements;
  bSequenceOtherWay = (rand() & 0x10) != 0;
}

//----- (002E7788) --------------------------------------------------------
Int32 __fastcall CCarCtrl::FindSequenceElement(Int32 Element)
{
  int v1; // r0
  Int32 v2; // r1

  if ( bSequenceOtherWay )
  {
    v1 = Element + SequenceRandomOffset;
    v2 = SequenceElements;
  }
  else
  {
    v2 = SequenceElements;
    v1 = SequenceRandomOffset - Element + SequenceElements;
  }
  return v1 % v2;
}

//----- (002E77D0) --------------------------------------------------------
int __fastcall CCarCtrl::GenerateCarCreationCoors2(
        CVector Center,
        float DirectionX,
        float DirectionY,
        float RequiredDotProduct,
        int bRequiredInside,
        float CreationDistOnScreen,
        float CreationDistOffScreen,
        CVector *pResult,
        CNodeAddress *pFromNode,
        CNodeAddress *pToNode,
        float *pFraction,
        int bIgnoreSwitchedOff,
        int bNoWater)
{
  int16x4_t v13; // d16
  int16x4_t v14; // d17
  float x; // r11
  RwReal z; // r9
  float y; // r10
  char v19; // r0
  char v20; // r0
  char v21; // r0
  char v22; // r0
  char v23; // r0
  float v24; // s18
  CPathNode *v25; // r0
  unsigned int Address; // r2
  int v27; // r6
  CCarPathLink *v28; // r3
  CCarPathLink *v29; // r2
  __int16 v30; // r4
  bool v31; // cf
  float v32; // s2
  int v33; // r0
  float v34; // s20
  int v35; // r0
  bool v36; // zf
  CNodeAddress *NodeClosestToCoors; // r2
  char v38; // r0
  CNodeAddress *v39; // r0
  int result; // r0
  float v41; // s17
  float v42; // s24
  int v43; // r8
  float v47; // s30
  CPathNode *v48; // r0
  CNodeAddress *v49; // r5
  __int16 *v50; // r9
  Int32 v51; // r11
  int v52; // r6
  char *v53; // r0
  Int32 v54; // r5
  int v55; // r0
  int v56; // r2
  unsigned int v57; // r12
  CPathNode *v58; // r0
  unsigned int v59; // r2
  int v60; // r3
  int v61; // r5
  CPathNode *v62; // r4
  Int16 *p_CoorsX; // r4
  int CoorsX; // t1
  __int16 *v65; // r3
  float v66; // s0
  __int16 *v67; // r5
  float v68; // s8
  __int16 *v69; // r2
  float v70; // s22
  __int16 *v71; // lr
  float v72; // s24
  float v73; // s17
  float v74; // s27
  float v75; // s25
  float v76; // s4
  float v77; // s2
  float v78; // s0
  float v79; // s31
  float v80; // s29
  float v81; // s21
  float v82; // s10
  unsigned int v83; // r6
  float v84; // s26
  float v85; // s6
  float v86; // s14
  float v87; // s8
  float v88; // s0
  float v89; // s10
  _BOOL4 IsSphereVisible; // r0
  float v91; // s0
  float v92; // s2
  float v93; // s29
  float v94; // s2
  __int16 *v95; // r9
  unsigned int v96; // r11
  float v97; // s21
  float v98; // s14
  RwReal v99; // s0
  RwReal v100; // s4
  float v101; // s2
  _BOOL4 v102; // r0
  int32x2_t v103; // d18
  float32x2_t v104; // d16
  unsigned __int64 v105; // d0
  int32x2_t v106; // d18
  float32x2_t v107; // d16
  unsigned __int64 v108; // d0
  CNodeAddress v109; // r4
  CNodeAddress v110; // r6
  CPathNode *v111; // r3
  int v112; // r1
  float v113; // s0
  float v114; // s2
  float v115; // s4
  int Region; // r2
  CPathNode *v117; // r3
  int v118; // r0
  int v119; // r6
  CNodeAddress *v120; // r1
  int v121; // r3
  int v122; // r0
  UInt16 *p_Index; // r8
  bool v124; // [sp+1Ch] [bp-12Ch]
  CNodeAddress v125; // [sp+2Ch] [bp-11Ch]
  __int16 *v126; // [sp+40h] [bp-108h]
  _DWORD *v127; // [sp+60h] [bp-E8h]
  int v128; // [sp+64h] [bp-E4h]
  int v129; // [sp+64h] [bp-E4h]
  unsigned int v130; // [sp+6Ch] [bp-DCh]
  CNodeAddress *v131; // [sp+70h] [bp-D8h] BYREF
  __int16 v132; // [sp+74h] [bp-D4h]
  __int16 v133; // [sp+78h] [bp-D0h]
  __int16 v134; // [sp+7Ch] [bp-CCh]
  __int16 v135; // [sp+80h] [bp-C8h]
  __int16 v136; // [sp+84h] [bp-C4h]
  __int16 v137; // [sp+88h] [bp-C0h]
  __int16 v138; // [sp+8Ch] [bp-BCh]
  __int16 v139; // [sp+90h] [bp-B8h]
  __int16 v140; // [sp+94h] [bp-B4h]
  __int16 v141; // [sp+98h] [bp-B0h]
  __int16 v142; // [sp+9Ch] [bp-ACh]
  __int16 v143; // [sp+A0h] [bp-A8h]
  __int16 v144; // [sp+A4h] [bp-A4h]
  __int16 v145; // [sp+A8h] [bp-A0h]
  __int16 v146; // [sp+ACh] [bp-9Ch]
  __int16 v147; // [sp+B0h] [bp-98h]
  __int16 v148; // [sp+B4h] [bp-94h]
  __int16 v149; // [sp+B8h] [bp-90h]
  __int16 v150; // [sp+BCh] [bp-8Ch]
  __int16 v151; // [sp+C0h] [bp-88h]
  __int16 v152; // [sp+C4h] [bp-84h]
  __int16 v153; // [sp+C8h] [bp-80h]
  __int16 v154; // [sp+CCh] [bp-7Ch]
  __int16 v155; // [sp+D0h] [bp-78h]
  __int16 v156; // [sp+D4h] [bp-74h]
  __int16 v157; // [sp+D8h] [bp-70h]
  __int16 v158; // [sp+DCh] [bp-6Ch]
  __int16 v159; // [sp+E0h] [bp-68h]
  __int16 v160; // [sp+E4h] [bp-64h]
  CVector v161; // 0:r1.12
  CVector v162; // 0:r1.12
  CVector cvectorb; // 0:r2.8,8:^0.4

  x = Center.x;
  z = Center.z;
  y = Center.y;
  v19 = `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode;
  __dmb(0xBu);
  if ( (v19 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode) )
  {
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode.Region = -1;
    _cxa_guard_release((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode);
  }
  v20 = `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode;
  __dmb(0xBu);
  if ( (v20 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode) )
  {
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode.Region = -1;
    _cxa_guard_release((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode);
  }
  v21 = `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff;
  __dmb(0xBu);
  if ( (v21 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff) )
  {
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff.Region = -1;
    _cxa_guard_release((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff);
  }
  v22 = `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff;
  __dmb(0xBu);
  if ( (v22 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff) )
  {
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff.Region = -1;
    _cxa_guard_release((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff);
  }
  v23 = `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors;
  __dmb(0xBu);
  if ( (v23 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors);
  }
  v24 = x;
  if ( sqrtf(
         (float)((float)(x
                       - CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.x)
               * (float)(x
                       - CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.x))
       + (float)((float)(y
                       - CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.y)
               * (float)(y
                       - CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.y))) > 10.0
    || CTimer::m_snTimeInMilliseconds > CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateTime )
  {
    v161.x = x;
    *(_QWORD *)&v161.y = __PAIR64__(LODWORD(z), LODWORD(y));
    CPathFind::Find2NodesForCarCreation(
      &ThePaths,
      v161,
      &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode,
      &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode,
      COERCE_FLOAT(1));
    *(_QWORD *)&v162.y = __PAIR64__(LODWORD(z), LODWORD(y));
    v162.x = x;
    CPathFind::Find2NodesForCarCreation(
      &ThePaths,
      v162,
      &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff,
      &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff,
      0.0);
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.x = x;
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.y = y;
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors.z = z;
    CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateTime = CTimer::m_snTimeInMilliseconds + 5000;
    if ( CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode.Region != 0xFFFF )
    {
      v25 = ThePaths.pNodes[CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode.Region];
      if ( v25 )
      {
        Address = ThePaths.pAdjacentLinks[v25[HIWORD(*(unsigned int *)&CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode)].Address.Region][v25[HIWORD(*(unsigned int *)&CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode)].IndexAdjacentNodes].Address;
        if ( ThePaths.pNodes[Address >> 10] )
        {
          v27 = Address & 0x3FF;
          v28 = ThePaths.pLinks[Address >> 10];
          v29 = &v28[Address & 0x3FF];
          v30 = *(_WORD *)((char *)v29 + 11);
          v31 = (v30 & 6) != 0;
          if ( (v30 & 6u) <= 1 )
            v31 = (v30 & 0x30u) >= 9;
          if ( v31
            && (v32 = (float)((float)v28[v27].CoorsX * 0.125) - x,
                sqrtf(
                  (float)(v32 * v32)
                + (float)((float)((float)((float)v29->CoorsY * 0.125) - y)
                        * (float)((float)((float)v29->CoorsY * 0.125) - y))) < 40.0) )
          {
            v33 = (*((unsigned __int16 *)&v25[HIWORD(*(unsigned int *)&CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode)]
                   + 12) >> 13) & 1;
          }
          else
          {
            LOBYTE(v33) = 0;
          }
          CPopulation::m_bMoreCarsAndFewerPeds = v33;
        }
      }
    }
  }
  v34 = CreationDistOnScreen;
  v35 = rand() & 0xF;
  v36 = v35 == 4;
  if ( v35 == 4 )
    v36 = bNoWater == 0;
  if ( v36 )
  {
    cvectorb.z = 0.0;
    *(_QWORD *)&cvectorb.x = __PAIR64__(LODWORD(z), LODWORD(y));
    NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                           (CNodeAddress *)&ThePaths,
                           (CPathFind *)LODWORD(x),
                           cvectorb,
                           50.0,
                           0.0,
                           0,
                           0,
                           1,
                           1,
                           v124);
    v34 = CreationDistOnScreen * 1.5;
  }
  else
  {
    v38 = rand();
    if ( (v38 & 3) != 0 )
    {
      if ( bIgnoreSwitchedOff == 1 )
        v39 = &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode;
      else
        v39 = &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff;
    }
    else if ( bIgnoreSwitchedOff == 1 )
    {
      v39 = &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode;
    }
    else
    {
      v39 = &CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff;
    }
    NodeClosestToCoors = (CNodeAddress *)*v39;
  }
  if ( (unsigned __int16)NodeClosestToCoors == 0xFFFF )
    return 0;
  result = 0;
  if ( ThePaths.pNodes[(unsigned __int16)NodeClosestToCoors] )
  {
    v133 = -1;
    v132 = -1;
    v41 = 0.5;
    v134 = -1;
    v42 = DirectionX;
    v135 = -1;
    v136 = -1;
    v43 = 1;
    v137 = -1;
    v138 = -1;
    v139 = -1;
    v140 = -1;
    v141 = -1;
    v142 = -1;
    v143 = -1;
    v144 = -1;
    v145 = -1;
    v146 = -1;
    v147 = -1;
    v148 = -1;
    v149 = -1;
    v150 = -1;
    v152 = -1;
    v151 = -1;
    v153 = -1;
    v154 = -1;
    v155 = -1;
    v156 = -1;
    v157 = -1;
    v158 = -1;
    v159 = -1;
    v160 = -1;
    v47 = 0.0;
    v131 = NodeClosestToCoors;
    while ( 1 )
    {
      v48 = ThePaths.pNodes[(unsigned __int16)NodeClosestToCoors];
      if ( !v48 )
        return 0;
      v128 = (unsigned __int16)NodeClosestToCoors;
      v49 = NodeClosestToCoors;
      v50 = (__int16 *)&v48[HIWORD(NodeClosestToCoors)];
      SequenceElements = v50[12] & 0xF;
      v51 = SequenceElements;
      SequenceRandomOffset = rand() % SequenceElements;
      v130 = ((unsigned int)rand() >> 4) & 1;
      bSequenceOtherWay = v130;
      if ( !v51 )
        return 0;
      v125 = (CNodeAddress)v49;
      v52 = 0;
      v126 = v50;
      v53 = (char *)&ThePaths + 4 * v128;
      v127 = v53 + 3492;
      v129 = *((_DWORD *)v53 + 657);
      v54 = v51;
      while ( 1 )
      {
        v55 = SequenceRandomOffset + v52;
        if ( !v130 )
          v55 = SequenceRandomOffset - v52 + SequenceElements;
        v56 = v55 % SequenceElements + v50[8];
        v57 = *(_DWORD *)(v129 + 4 * v56);
        v58 = ThePaths.pNodes[(unsigned __int16)v57];
        if ( v58 )
        {
          if ( ThePaths.pNodes[*(_WORD *)(*v127 + 2 * v56) >> 10] )
          {
            v59 = HIWORD(v57);
            v60 = 0;
            v61 = 0;
            do
            {
              if ( LOWORD((&v131)[v60]) == (unsigned __int16)v57 )
                v61 |= HIWORD((&v131)[v60]) == v59;
              ++v60;
            }
            while ( v43 != v60 );
            v36 = v61 << 31 == 0;
            v54 = v51;
            if ( v36 )
              break;
          }
        }
        if ( ++v52 >= v54 )
          return 0;
      }
      v62 = &v58[v59];
      CoorsX = v62->CoorsX;
      p_CoorsX = &v62->CoorsX;
      v65 = p_CoorsX + 1;
      v66 = (float)CoorsX;
      v67 = v50 + 4;
      v68 = (float)v50[5];
      if ( (p_CoorsX[8] & 0x20) != 0 )
      {
        if ( bIgnoreSwitchedOff )
          goto LABEL_70;
      }
      else if ( !(((v50[12] & 0x20) == 0) | bIgnoreSwitchedOff ^ 1) )
      {
        goto LABEL_70;
      }
      v69 = p_CoorsX + 2;
      v70 = v42;
      v71 = v50 + 6;
      v72 = v41;
      v73 = CreationDistOffScreen;
      v74 = DirectionY;
      v75 = RequiredDotProduct;
      v76 = (float)p_CoorsX[1] * 0.125;
      v77 = (float)v50[4] * 0.125;
      v78 = v66 * 0.125;
      v79 = sqrtf((float)((float)(v24 - v78) * (float)(v24 - v78)) + (float)((float)(y - v76) * (float)(y - v76)));
      v80 = sqrtf(
              (float)((float)(v24 - v77) * (float)(v24 - v77))
            + (float)((float)(y - (float)(v68 * 0.125)) * (float)(y - (float)(v68 * 0.125))));
      if ( (float)((float)(v80 - v34) * (float)(v79 - v34)) >= 0.0 )
        goto LABEL_66;
      v81 = fabsf(v80 - v34);
      v82 = fabsf(v79 - v34);
      v83 = v57;
      v84 = v81 + v82;
      v85 = v82 * (float)(v68 * 0.125);
      v86 = 1.0 / (float)(v81 + v82);
      v87 = v82 * (float)((float)*v71 * 0.125);
      v88 = (float)(v81 * v78) + (float)(v82 * v77);
      v89 = v81 * (float)((float)*v69 * 0.125);
      pResult->x = v86 * v88;
      pResult->y = v86 * (float)((float)(v81 * v76) + v85);
      pResult->z = v86 * (float)(v89 + v87);
      IsSphereVisible = CCamera::IsSphereVisible(&TheCamera, pResult, 5.0);
      v65 = p_CoorsX + 1;
      v69 = p_CoorsX + 2;
      v57 = v83;
      if ( IsSphereVisible )
      {
        v91 = v81 / v84;
        RequiredDotProduct = v75;
        DirectionY = v74;
        CreationDistOffScreen = v73;
        v41 = v72;
        v42 = v70;
      }
      else
      {
LABEL_66:
        v92 = v79 - v73;
        CreationDistOffScreen = v73;
        RequiredDotProduct = v75;
        DirectionY = v74;
        v41 = v72;
        v42 = v70;
        if ( (float)((float)(v80 - CreationDistOffScreen) * v92) >= 0.0 )
          goto LABEL_70;
        v93 = fabsf(v80 - CreationDistOffScreen);
        v94 = fabsf(v92);
        v95 = v69;
        v96 = v57;
        v97 = v93 + v94;
        v98 = 1.0 / (float)(v93 + v94);
        v99 = v98
            * (float)((float)(v93 * (float)((float)*v65 * 0.125)) + (float)(v94 * (float)((float)v126[5] * 0.125)));
        v100 = v98
             * (float)((float)(v93 * (float)((float)*p_CoorsX * 0.125)) + (float)(v94 * (float)((float)*v67 * 0.125)));
        v101 = (float)(v93 * (float)((float)*v69 * 0.125)) + (float)(v94 * (float)((float)*v71 * 0.125));
        pResult->x = v100;
        pResult->y = v99;
        pResult->z = v98 * v101;
        v102 = CCamera::IsSphereVisible(&TheCamera, pResult, 5.0);
        v69 = v95;
        v57 = v96;
        if ( v102 )
          goto LABEL_70;
        v91 = v93 / v97;
      }
      *pFraction = v91;
      v13.n64_u32[0] = *(_DWORD *)p_CoorsX;
      v14.n64_u32[0] = *(_DWORD *)v67;
      v103.n64_u64[0] = vmovl_s16(v13).n128_u64[0];
      v104.n64_u64[0] = vcvt_f32_s32((int32x2_t)vmovl_s16(v14).n128_u64[0]).n64_u64[0];
      v14.n64_u64[0] = vmul_f32(vcvt_f32_s32(v103), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
      v13.n64_u64[0] = vsub_f32(vmul_f32(v104, (float32x2_t)0x3E0000003E000000LL), v14).n64_u64[0];
      v105 = vmul_f32(v13, v13).n64_u64[0];
      if ( fabsf((float)((float)*v71 * 0.125) - (float)((float)*v69 * 0.125)) <= (float)(sqrtf(
                                                                                           *(float *)&v105
                                                                                         + *((float *)&v105 + 1))
                                                                                       * v41) )
      {
        v109 = (CNodeAddress)v57;
        if ( (rand() & 8) != 0 )
        {
          v110 = v109;
          *pFromNode = v125;
          *pToNode = v109;
        }
        else
        {
          *pFromNode = v109;
          *pToNode = v125;
          *pFraction = 1.0 - *pFraction;
          v110 = *pToNode;
        }
        v111 = ThePaths.pNodes[v110.Region];
        if ( (*((_WORD *)&v111[HIWORD(*(unsigned int *)&v110)] + 12) & 0x10) != 0
          && CPathFind::ThisNodeWillLeadIntoADeadEnd(
               &ThePaths,
               &v111[HIWORD(*(unsigned int *)&v110)],
               &ThePaths.pNodes[pFromNode->Region][HIWORD(*(unsigned int *)pFromNode)])
          && bIgnoreSwitchedOff )
        {
          return 0;
        }
        v112 = 0;
        v113 = pResult->x - v24;
        result = 0;
        v114 = pResult->y - y;
        v115 = sqrtf((float)(v113 * v113) + (float)(v114 * v114));
        if ( (float)((float)((float)(v113 / v115) * v42) + (float)((float)(v114 / v115) * DirectionY)) > RequiredDotProduct )
          v112 = 1;
        if ( (v112 & bRequiredInside) == (v112 | bRequiredInside) )
        {
          Region = pFromNode->Region;
          v117 = ThePaths.pNodes[Region];
          v118 = *((_WORD *)&v117[HIWORD(*(unsigned int *)pFromNode)] + 12) & 0xF;
          if ( v118 )
          {
            v119 = 0;
            v120 = &ThePaths.pAdjacentNodes[Region][v117[HIWORD(*(unsigned int *)pFromNode)].IndexAdjacentNodes];
            v121 = v118 & 0xFFFFFF;
            p_Index = &pToNode->Index;
            v122 = pToNode->Region;
            do
            {
              if ( v120[v119].Region == v122 && v120[v119].Index == *p_Index )
                break;
              ++v119;
            }
            while ( v119 < v121 );
          }
          else
          {
            p_Index = &pToNode->Index;
            v122 = pToNode->Region;
          }
          sprintf(gString, "tell Obbe it happened again %d/%d %d/%d", Region, pFromNode->Index, v122, *p_Index);
          return 1;
        }
        return result;
      }
LABEL_70:
      v13.n64_u32[0] = *(_DWORD *)v67;
      v14.n64_u32[0] = *(_DWORD *)p_CoorsX;
      (&v131)[v43] = (CNodeAddress *)v57;
      if ( v43 <= 28 )
      {
        v106.n64_u64[0] = vmovl_s16(v13).n128_u64[0];
        ++v43;
        NodeClosestToCoors = (CNodeAddress *)v57;
        v107.n64_u64[0] = vcvt_f32_s32((int32x2_t)vmovl_s16(v14).n128_u64[0]).n64_u64[0];
        v14.n64_u64[0] = vmul_f32(vcvt_f32_s32(v106), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
        v13.n64_u64[0] = vsub_f32(vmul_f32(v107, (float32x2_t)0x3E0000003E000000LL), v14).n64_u64[0];
        v108 = vmul_f32(v13, v13).n64_u64[0];
        v47 = v47 + sqrtf(*(float *)&v108 + *((float *)&v108 + 1));
        if ( v47 < 230.0 )
          continue;
      }
      return 0;
    }
  }
  return result;
}
// 2E7AC8: variable 'v124' is possibly undefined
// 2E7FF2: variable 'v13' is possibly undefined
// 2E7FFA: variable 'v14' is possibly undefined
// 7967CC: using guessed type char `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode;
// 7967D4: using guessed type char `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode;
// 7967DC: using guessed type char `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredNearestNode_IncludingSwitchedOff;
// 7967E4: using guessed type char `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::StoredSecondNearestNode_IncludingSwitchedOff;
// 7967F4: using guessed type char `guard variable for'CCarCtrl::GenerateCarCreationCoors2(CVector,float,float,float,bool,float,float,CVector*,CNodeAddress *,CNodeAddress *,float *,bool,bool)::UpdateCoors;

//----- (002E833C) --------------------------------------------------------
void CCarCtrl::GenerateRandomCars()
{
  _BOOL4 active; // r0
  float v1; // s0
  int v2; // r4

  if ( CCutsceneMgr::ms_running )
  {
    CCarCtrl::CountDownToCarsAtStart = 2;
  }
  else if ( !__PAIR64__(CGame::currArea, CGangWars::DontCreateCivilians()) )
  {
    active = CGameLogic::LaRiotsActiveHere();
    v1 = CCarCtrl::TimeNextMadDriverChaseCreated;
    if ( active && CCarCtrl::TimeNextMadDriverChaseCreated > 480.0 )
    {
      v1 = (float)((float)((float)rand() * 4.6566e-10) * 240.0) + 240.0;
      CCarCtrl::TimeNextMadDriverChaseCreated = v1;
    }
    CCarCtrl::TimeNextMadDriverChaseCreated = v1 + (float)(CTimer::ms_fTimeStep / -50.0);
    if ( CCarCtrl::NumRandomCars <= 44 )
    {
      if ( CCarCtrl::CountDownToCarsAtStart )
      {
        if ( !--CCarCtrl::CountDownToCarsAtStart )
        {
          v2 = 0;
          do
            CCarCtrl::GenerateOneRandomCar();
          while ( (__int16)v2++ < 99 );
          CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter = 20;
        }
      }
      else
      {
        CCarCtrl::GenerateOneRandomCar();
        CCarCtrl::GenerateOneRandomCar();
      }
    }
    CTrain::DoTrainGenerationAndRemoval();
    CPlane::DoPlaneGenerationAndRemoval();
    if ( (CTimer::m_snTimeInMilliseconds ^ CTimer::m_snPreviousTimeInMilliseconds) >= 0x1000 )
      CCarCtrl::GenerateEmergencyServicesCar();
  }
}
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;

//----- (002E848C) --------------------------------------------------------
void CCarCtrl::GenerateOneRandomCar()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d4
  float32x2_t v3; // d5
  float32x2_t v4; // d13
  int16x4_t v5; // d16
  int16x4_t v6; // d18
  const CVector *PlayerCentreOfWorld; // r0
  RwReal x; // r10
  RwReal z; // r11
  const CVector *PlayerSpeed; // r0
  float v11; // s16
  float y; // s18
  int v13; // r4
  int32 v14; // r9
  int32 v15; // r6
  int32 v16; // r5
  float v17; // s20
  float v18; // s22
  float v19; // s24
  float v20; // s22
  int v21; // r4
  unsigned int m_nCopsInPursuit; // r4
  int32 v23; // r4
  bool v24; // zf
  float CamFrontYNorm; // s20
  int v26; // s22
  int bRequiredInside; // r9
  float CamFrontXNorm; // s24
  CVehicle *PlayerVehicle; // r0
  float v30; // s0
  float v31; // s2
  float v32; // s4
  _BOOL4 v33; // r0
  float v34; // s26
  unsigned int v35; // r6
  unsigned int v36; // r9
  unsigned int v37; // r5
  unsigned int Region; // r10
  CNodeAddress v39; // r0
  unsigned int v40; // r4
  CPathNode **v41; // r4
  int v42; // r0
  int v43; // r11
  float v44; // s2
  int v45; // r1
  int v46; // r0
  int v47; // r2
  int v48; // r6
  __int16 v49; // r12
  int v50; // r0
  int v51; // r1
  UInt16 Address; // r6
  unsigned __int16 *v53; // r1
  unsigned int v54; // r0
  int v55; // r5
  bool v56; // zf
  int v57; // r9
  int v58; // r0
  CVehicle *NewVehicleDependingOnCarModel; // r11
  Int8 PoliceBikeMissionForWantedLevel; // r0
  CPathNode **v61; // r8
  int v62; // r0
  Int8 PoliceBoatMissionForWantedLevel; // r0
  int v64; // r1
  int32 v65; // r4
  unsigned int v66; // r0
  float v67; // s24
  float v68; // s26
  int v69; // r0
  float v70; // s24
  int m_nModelIndex; // r1
  CColModel *m_pColModel; // r2
  bool v73; // zf
  float v74; // s26
  int v75; // r1
  int v76; // r6
  eVehicleAppearance VehicleAppearance; // r0
  int v78; // r12
  int v79; // s0
  float v80; // s22
  int v81; // r1
  CPathNode *v82; // r0
  int CoorsX; // r2
  int CoorsY; // s0
  CColModel *v85; // r0
  float v86; // s0
  float v87; // s2
  float v88; // s0
  float v89; // s4
  float32x2_t v90; // d1
  Int8 *p_InvertDirNewLink; // r2
  char v92; // r0
  unsigned int Index; // r8
  unsigned int v94; // r9
  unsigned int v95; // r5
  char *v96; // r0
  _DWORD *v97; // r10
  _DWORD *v98; // r4
  int v99; // r0
  int v100; // r6
  int v101; // r1
  int v102; // r0
  CNodeAddress *v103; // r0
  int v104; // r1
  unsigned int v105; // r2
  Int8 *p_InvertDirOldLink; // r9
  char v107; // r0
  CPathNode *v108; // r0
  int v109; // r2
  int v110; // r3
  CPathNode *v111; // r1
  int CoorsZ; // r0
  int v113; // r6
  int v114; // r5
  int v115; // r1
  float v116; // s26
  float v117; // s0
  float v118; // s2
  UInt16 v119; // r12
  int32x4_t v120; // q9
  float32x2_t v121; // d16
  float32x2_t v122; // d0
  float32x2_t v123; // d16
  unsigned __int64 v124; // d2
  float v125; // s6
  float32x2_t v126; // d1
  UInt16 v127; // r0
  CCarPathLink *v128; // r2
  int v129; // r6
  int v130; // r2
  float v131; // s4
  float v132; // s0
  float v133; // s28
  CCarPathLink *v134; // r5
  CCarPathLink *v135; // r3
  CPathNode *v136; // r2
  int v137; // r6
  float v138; // s6
  float v139; // s4
  float v140; // s8
  float v141; // s10
  float v142; // s0
  CCarPathLink *v143; // r0
  CCarPathLink *v144; // r1
  int OldLane; // r9
  int v146; // r11
  int v147; // r10
  float v148; // r4
  int NewLane; // r5
  float v150; // s4
  float v151; // s2
  int v152; // r1
  float v153; // s6
  float CruiseSpeed; // s0
  float v155; // s0
  UInt16 v156; // r0
  CCarPathLink *v157; // r1
  int v158; // r0
  int v159; // r2
  CCarPathLink *v160; // r0
  float v161; // s10
  float v162; // s25
  float v163; // s29
  CCarPathLink *v164; // r2
  int v165; // r1
  int v166; // r3
  CCarPathLink *v167; // r1
  float v168; // s8
  float v169; // s31
  float v170; // s23
  float32x2_t v171; // d16
  float v172; // s6
  uint32 v173; // r0
  float v174; // s2
  UInt16 v175; // r1
  CCarPathLink *v176; // r2
  int v177; // r1
  float v178; // s4
  float v179; // s8
  CCarPathLink *v180; // r2
  int v181; // r1
  int v182; // r3
  float v183; // s4
  CNodeAddress v184; // r10
  CPathNode *v185; // r0
  CPathNode *v186; // r1
  float v187; // s8
  float v188; // s10
  float v189; // s2
  float v190; // s4
  float32x2_t v191; // d0
  float v192; // s2
  float v193; // s22
  RwReal v194; // r0
  CMatrix *m_pMat; // r2
  float *p_tz; // r0
  unsigned int v197; // r6
  float v198; // s26
  float v199; // s30
  float v200; // s28
  float v201; // s17
  CEntity::CEntityInfo *p_m_info; // r0
  char v203; // r1
  CEntity::CEntityInfo v204; // r1
  char v205; // r2
  CEntity::CEntityInfo m_info; // r1
  _BOOL4 v207; // r0
  const CVector *v208; // r2
  _BOOL4 v209; // r1
  const CVector *p_m_translate; // r0
  float v211; // s2
  float v212; // s4
  CSimpleTransform *p_tx; // r3
  int v214; // r1
  CEntity::CEntityInfo v215; // r1
  CEntity::CEntityInfo v216; // r1
  int v217; // r2
  int v218; // r1
  _BOOL4 active; // r4
  float v220; // s0
  float v221; // s2
  int v222; // r0
  bool v223; // zf
  CAutomobile *v224; // r0
  bool v225; // r1
  float *p_xx; // r0
  UInt8 v227; // r5
  float v228; // s2
  float v229; // s0
  float m_heading; // r4
  float v231; // r8
  float v232; // s4
  _BOOL4 v233; // r0
  bool v234; // zf
  CPed *pDriver; // r0
  bool v236; // zf
  CBaseModelInfo *v237; // r0
  int m_lodDistance_low; // r1
  char v239; // r1
  int v240; // [sp+24h] [bp-134h]
  int v241; // [sp+2Ch] [bp-12Ch]
  int v242; // [sp+30h] [bp-128h]
  int v243; // [sp+38h] [bp-120h]
  int v244; // [sp+3Ch] [bp-11Ch]
  int v245; // [sp+40h] [bp-118h]
  int DirXb; // [sp+40h] [bp-118h]
  unsigned int v247; // [sp+44h] [bp-114h]
  int DirYb; // [sp+44h] [bp-114h]
  int v249; // [sp+48h] [bp-110h]
  CNodeAddress v250; // [sp+4Ch] [bp-10Ch]
  Int8 *v251; // [sp+4Ch] [bp-10Ch]
  CNodeAddress v252; // [sp+50h] [bp-108h]
  int v253; // [sp+54h] [bp-104h]
  int32 v254; // [sp+58h] [bp-100h]
  unsigned int v255; // [sp+58h] [bp-100h]
  Int8 *v256; // [sp+58h] [bp-100h]
  float v257; // [sp+58h] [bp-100h]
  float Center; // [sp+60h] [bp-F8h]
  int32 Center_4; // [sp+64h] [bp-F4h]
  CVehicle *Center_4a; // [sp+64h] [bp-F4h]
  float Center_8; // [sp+68h] [bp-F0h]
  CVector endDir; // [sp+70h] [bp-E8h] BYREF
  CVector startDir; // [sp+7Ch] [bp-DCh] BYREF
  Int16 pNum; // [sp+8Ah] [bp-CEh] BYREF
  CColPoint startCoors; // [sp+8Ch] [bp-CCh] BYREF
  CVector v266; // [sp+B8h] [bp-A0h] BYREF
  CVector endCoors; // [sp+C4h] [bp-94h] BYREF
  CVector v268; // [sp+D0h] [bp-88h] BYREF
  CVector Coors; // [sp+DCh] [bp-7Ch] BYREF
  int32 v270; // [sp+E8h] [bp-70h] BYREF
  unsigned int v271; // [sp+ECh] [bp-6Ch] BYREF
  CNodeAddress pFromNode; // [sp+F0h] [bp-68h] BYREF
  float pFraction[25]; // [sp+F4h] [bp-64h] BYREF
  CVector v274; // 0:r0.12

  pFromNode.Region = -1;
  LOWORD(v271) = -1;
  PlayerCentreOfWorld = FindPlayerCentreOfWorld(CWorld::PlayerInFocus);
  x = PlayerCentreOfWorld->x;
  Center_8 = PlayerCentreOfWorld->y;
  z = PlayerCentreOfWorld->z;
  PlayerSpeed = FindPlayerSpeed(-1);
  v11 = PlayerSpeed->x;
  y = PlayerSpeed->y;
  v13 = CCarCtrl::NumLawEnforcerCars + CCarCtrl::NumRandomCars;
  v14 = CCarCtrl::NumFireTrucksOnDuty;
  v15 = CCarCtrl::NumAmbulancesOnDuty;
  v16 = CCarCtrl::NumMissionCars;
  v17 = CCarCtrl::CarDensityMultiplier;
  v18 = CCarCtrl::CarDensityMultiplier * 0.6;
  if ( CCullZones::FewerCars() )
    v17 = v18;
  v19 = v17 * (float)CCarCtrl::MaxNumberOfCarsInUse;
  v20 = (float)(v13 + v16 + v15 + v14);
  if ( (float)(CPopulation::FindCarMultiplierMotorway() * v19) <= v20
    || (float)((float)(v17 * CPopulation::FindCarMultiplierMotorway())
             * (float)((float)((float)(CPopCycle::m_NumDealers_Cars + CPopCycle::m_NumGangs_Cars)
                             + CPopCycle::m_NumCops_Cars)
                     + CPopCycle::m_NumOther_Cars)) <= v20 )
  {
    return;
  }
  if ( FindPlayerWanted(-1)->m_WantedLevel < WANTED_LEVEL2
    || (v21 = CCarCtrl::NumLawEnforcerCars, v21 >= FindPlayerWanted(-1)->m_nMaxCopCarsInPursuit)
    || (m_nCopsInPursuit = FindPlayerWanted(-1)->m_nCopsInPursuit,
        m_nCopsInPursuit >= FindPlayerWanted(-1)->m_nMaxCopsInPursuit)
    || CGame::currArea
    || CGangWars::GangWarFightingGoingOn()
    || FindPlayerWanted(-1)->m_WantedLevel <= WANTED_LEVEL3
    && (FindPlayerWanted(-1)->m_WantedLevel <= WANTED_LEVEL2
     || CTimer::m_snTimeInMilliseconds <= CCarCtrl::LastTimeLawEnforcerCreated + 5000)
    && CTimer::m_snTimeInMilliseconds <= CCarCtrl::LastTimeLawEnforcerCreated + 8000 )
  {
    Center_4 = CCarCtrl::ChooseModel(&v270);
    if ( Center_4 == -1 )
      return;
    v23 = v270;
    v24 = v270 == 24;
    if ( v270 != 24 )
      v24 = v270 == 13;
    if ( v24 && FindPlayerWanted(-1)->m_WantedLevel > WANTED_CLEAN )
      return;
  }
  else
  {
    v23 = 13;
    Center_4 = CCarCtrl::ChoosePoliceCarModel(0);
    v270 = 13;
  }
  if ( CGameLogic::LaRiotsActiveHere() && !gbLARiots_NoPoliceCars && (rand() & 0x7Fu) <= 0x36 )
  {
    v23 = 13;
    Center_4 = CCarCtrl::ChoosePoliceCarModel(0);
    v270 = 13;
  }
  Center = x;
  if ( TheCamera.m_cameraMatrix.zy >= -0.9 )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    if ( PlayerVehicle )
    {
      v30 = PlayerVehicle->m_vecMoveSpeed.x;
      v31 = PlayerVehicle->m_vecMoveSpeed.y;
      v32 = sqrtf((float)(v30 * v30) + (float)(v31 * v31));
      if ( v32 > 0.4 )
      {
        CamFrontYNorm = v31 / v32;
        CamFrontXNorm = v30 / v32;
        if ( (CTimer::m_FrameCounter & 3) != 3 )
        {
          if ( (CTimer::m_FrameCounter & 3) != 2 )
          {
LABEL_31:
            v26 = 1062836634;
LABEL_40:
            bRequiredInside = 1;
            v253 = 0;
            goto LABEL_41;
          }
          goto LABEL_39;
        }
        goto LABEL_36;
      }
      if ( v32 > 0.1 )
      {
        CamFrontYNorm = v31 / v32;
        CamFrontXNorm = v30 / v32;
        if ( (CTimer::m_FrameCounter & 3) == 0 )
          goto LABEL_31;
        if ( (CTimer::m_FrameCounter & 3) == 1 )
        {
LABEL_39:
          v26 = 1060437492;
          goto LABEL_40;
        }
LABEL_36:
        v26 = 1060437492;
        v253 = 0;
        bRequiredInside = 0;
        goto LABEL_41;
      }
      v26 = 1060437492;
      v253 = 0;
    }
    else
    {
      v253 = 0;
      v26 = 1060437492;
    }
    CamFrontXNorm = TheCamera.CamFrontXNorm;
    CamFrontYNorm = TheCamera.CamFrontYNorm;
    bRequiredInside = (unsigned __int8)CTimer::m_FrameCounter << 31 == 0;
    goto LABEL_41;
  }
  CamFrontYNorm = 0.707;
  v26 = -1.0;
  v253 = 1;
  bRequiredInside = 1;
  CamFrontXNorm = 0.707;
LABEL_41:
  v254 = v23;
  v33 = 0;
  v34 = TheCamera.GenerationDistMultiplier * 160.0;
  if ( v23 == 13 )
    v33 = FindPlayerWanted(-1)->m_WantedLevel > WANTED_CLEAN;
  v274.z = z;
  v240 = !v33;
  *(_QWORD *)&v274.x = __PAIR64__(LODWORD(Center_8), LODWORD(x));
  if ( CCarCtrl::GenerateCarCreationCoors2(
         v274,
         CamFrontXNorm,
         CamFrontYNorm,
         *(float *)&v26,
         bRequiredInside,
         v34,
         38.0,
         &Coors,
         &pFromNode,
         (CNodeAddress *)&v271,
         pFraction,
         v240,
         0) == 1 )
  {
    v35 = HIWORD(v271);
    v36 = (unsigned __int16)v271;
    v37 = HIWORD(*(unsigned int *)&pFromNode);
    Region = pFromNode.Region;
    v252 = (CNodeAddress)v271;
    v250 = pFromNode;
    v39 = (CNodeAddress)v271;
    if ( (*((_BYTE *)&ThePaths.pNodes[pFromNode.Region][HIWORD(*(unsigned int *)&pFromNode)] + 26) & 0xFu) < (*((_BYTE *)&ThePaths.pNodes[(unsigned __int16)v271][HIWORD(v271)] + 26) & 0xFu) )
      v39 = pFromNode;
    v40 = *((_BYTE *)&ThePaths.pNodes[v39.Region][HIWORD(*(unsigned int *)&v39)] + 26) & 0xF;
    if ( (rand() & 0xFu) <= v40 )
    {
      v41 = &ThePaths.pNodes[Region];
      v247 = v35;
      v42 = 0;
      if ( (*((_WORD *)&(*v41)[v37] + 12) & 0x80) != 0 )
      {
        if ( v254 == 13 )
        {
          v270 = 24;
          if ( CStreaming::ms_aInfoForModel[430].m_status != 1 )
          {
            CStreaming::RequestModel(430, 8);
            return;
          }
          Center_4 = 430;
        }
        else
        {
          Center_4 = CLoadedCarGroup::PickLeastUsedModel(&CPopulation::m_LoadedBoats, 1);
          if ( Center_4 == -1 || CStreaming::ms_aInfoForModel[Center_4].m_status != 1 )
            return;
        }
        v42 = 1;
      }
      v245 = v37;
      v43 = v42;
      v255 = v36;
      v44 = 8.0;
      if ( v42 )
        v44 = 40.0;
      CWorld::FindObjectsKindaColliding(&Coors, v44, 1, &pNum, 2, 0, 0, 1, 1, 0, 0);
      if ( !pNum )
      {
        v45 = (int)&(*v41)[v37];
        v46 = *(_WORD *)(v45 + 24) & 0xF;
        if ( v46 )
        {
          v47 = *(__int16 *)(v45 + 16);
          v48 = v46 & 0xFFFFFF;
          v49 = *(_WORD *)(v45 + 16);
          v50 = 0;
          v51 = 0;
          do
          {
            if ( __PAIR64__(
                   ThePaths.pAdjacentNodes[Region][v51 + v47].Index,
                   ThePaths.pAdjacentNodes[Region][v51 + v47].Region) == __PAIR64__(HIWORD(v271), v36) )
              break;
            v51 = (__int16)++v50;
          }
          while ( (__int16)v50 < v48 );
        }
        else
        {
          v49 = *(_WORD *)(v45 + 16);
          v51 = 0;
        }
        Address = ThePaths.pAdjacentLinks[Region][v51 + v49].Address;
        v53 = (unsigned __int16 *)&ThePaths.pLinks[Address >> 10][Address & 0x3FF];
        if ( v53[2] == v36 )
        {
          v54 = *(unsigned __int16 *)((char *)v53 + 11);
          if ( v53[3] != HIWORD(v271) )
            v54 >>= 3;
        }
        else
        {
          v54 = *(unsigned __int16 *)((char *)v53 + 11) >> 3;
        }
        v55 = v54 & 7;
        if ( (unsigned int)v55 >= 2 )
        {
          if ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[Center_4][1].m_modelName[20] == 10 )
            return;
LABEL_76:
          v243 = v43;
          if ( CPopCycle::m_pCurrZone )
          {
            v57 = 0;
            v58 = *(_WORD *)((char *)CTheZones::GetZoneInfo(&Coors, 0) + 15) & 0x1F;
            if ( (unsigned int)(v58 - 17) <= 2 )
            {
              if ( CPopCycle::m_nCurrentZoneType != v58 )
                return;
              v57 = 1;
            }
          }
          else
          {
            v57 = 0;
          }
          NewVehicleDependingOnCarModel = CCarCtrl::GetNewVehicleDependingOnCarModel(Center_4, 1u);
          NewVehicleDependingOnCarModel->AutoPilot.OldNode = v250;
          NewVehicleDependingOnCarModel->AutoPilot.VeryOldNode.Region = -1;
          NewVehicleDependingOnCarModel->AutoPilot.NewNode = v252;
          if ( v270 == 24 )
          {
            v61 = &ThePaths.pNodes[Region];
            NewVehicleDependingOnCarModel->AutoPilot.TempAction = 0;
            v62 = rand();
            NewVehicleDependingOnCarModel->AutoPilot.DrivingMode = 2;
            NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = (unsigned int)(float)((float)((float)((float)v62 * 4.6566e-10)
                                                                                               * 4.0)
                                                                                       + 14.0);
            PoliceBoatMissionForWantedLevel = CCarAI::FindPoliceBoatMissionForWantedLevel();
            v64 = *((_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags + 1);
            v65 = 24;
            NewVehicleDependingOnCarModel->AutoPilot.Mission = PoliceBoatMissionForWantedLevel;
            *((_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags + 1) = v64 | 1;
            goto LABEL_110;
          }
          if ( v270 == 13 )
          {
            NewVehicleDependingOnCarModel->AutoPilot.TempAction = 0;
            if ( FindPlayerWanted(-1)->m_WantedLevel )
            {
              NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = CCarAI::FindPoliceCarSpeedForWantedLevel(NewVehicleDependingOnCarModel);
              if ( CVehicle::GetVehicleAppearance(NewVehicleDependingOnCarModel) == APR_BIKE )
                PoliceBikeMissionForWantedLevel = CCarAI::FindPoliceBikeMissionForWantedLevel();
              else
                PoliceBikeMissionForWantedLevel = CCarAI::FindPoliceCarMissionForWantedLevel();
              NewVehicleDependingOnCarModel->AutoPilot.DrivingMode = 2;
              NewVehicleDependingOnCarModel->AutoPilot.Mission = PoliceBikeMissionForWantedLevel;
            }
            else
            {
              v69 = rand();
              *(_WORD *)&NewVehicleDependingOnCarModel->AutoPilot.DrivingMode = 256;
              NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = (unsigned int)(float)((float)((float)((float)v69 * 4.6566e-10)
                                                                                                 * 6.0)
                                                                                         + 18.0);
            }
            v61 = &ThePaths.pNodes[Region];
            v65 = 13;
            if ( Center_4 == 490 )
              *(_WORD *)&NewVehicleDependingOnCarModel->m_colour1 = 0;
            *((_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags + 1) |= 1u;
            goto LABEL_110;
          }
          v61 = &ThePaths.pNodes[Region];
          v66 = (unsigned int)(float)((float)((float)((float)rand() * 4.6566e-10) * 8.0) + 13.0);
          NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = v66;
          v65 = v270;
          if ( v270 == 1 )
          {
            v67 = 10.0;
            v68 = 5.0;
          }
          else
          {
            if ( v270 != 3 )
              goto LABEL_93;
            v67 = 18.0;
            v68 = 9.0;
          }
          v66 = (unsigned int)(float)(v67 + (float)(v68 * (float)((float)rand() * 4.6566e-10)));
          NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = v66;
LABEL_93:
          v70 = 10.0;
          m_nModelIndex = NewVehicleDependingOnCarModel->m_nModelIndex;
          m_pColModel = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel;
          if ( (float)(m_pColModel->m_boxBound.m_vecMax.y - m_pColModel->m_boxBound.m_vecMin.y) > 10.0 || v65 == 5 )
            NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = (3 * v66) >> 2;
          if ( v243 == 1 )
          {
            if ( m_nModelIndex == 446 )
              goto LABEL_102;
            v73 = m_nModelIndex == 493;
            if ( m_nModelIndex != 493 )
              v73 = m_nModelIndex == 452;
            if ( v73 )
            {
LABEL_102:
              v74 = 25.0;
            }
            else
            {
              v74 = 15.0;
              v70 = 9.0;
            }
            NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = (unsigned int)(float)(v74
                                                                                       + (float)(v70
                                                                                               * (float)((float)rand() * 4.6566e-10)));
          }
          NewVehicleDependingOnCarModel->AutoPilot.TempAction = 0;
          *(_WORD *)&NewVehicleDependingOnCarModel->AutoPilot.DrivingMode = 256;
LABEL_110:
          if ( NewVehicleDependingOnCarModel->m_nModelIndex == 423 )
            *((_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags + 1) |= 0x8000u;
          NewVehicleDependingOnCarModel->AutoPilot.NewLink.Address = Address;
          v75 = rand() % v55;
          NewVehicleDependingOnCarModel->AutoPilot.OldLane = v75;
          NewVehicleDependingOnCarModel->AutoPilot.NewLane = v75;
          if ( CGameLogic::LaRiotsActiveHere() )
          {
            v76 = 80;
          }
          else
          {
            VehicleAppearance = CVehicle::GetVehicleAppearance(NewVehicleDependingOnCarModel);
            v76 = 200;
            if ( VehicleAppearance == APR_BOAT )
              v76 = 10;
            if ( VehicleAppearance == APR_BIKE )
              v76 = 50;
          }
          v78 = 0;
          if ( !((v65 == 13) | v243 | v57) )
          {
            v79 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v76);
            if ( CCheat::m_aCheatsActive[38] || !v79 )
            {
              v78 = 1;
              pFraction[0] = 1.0;
            }
            else
            {
              v78 = 0;
            }
          }
          v80 = 1.0;
          v81 = (int)&(*v61)[v245];
          v82 = &ThePaths.pNodes[v255][v247];
          CoorsX = v82->CoorsX;
          CoorsY = v82->CoorsY;
          v85 = CModelInfo::ms_modelInfoPtrs[NewVehicleDependingOnCarModel->m_nModelIndex]->m_pColModel;
          v86 = (float)((float)*(__int16 *)(v81 + 10) * 0.125) - (float)((float)CoorsY * 0.125);
          v87 = (float)((float)*(__int16 *)(v81 + 8) * 0.125) - (float)((float)CoorsX * 0.125);
          v1.n64_f32[0] = sqrtf((float)(v87 * v87) + (float)(v86 * v86));
          v88 = 0.5;
          v89 = (float)((float)(v85->m_boxBound.m_vecMax.y - v85->m_boxBound.m_vecMin.y) * 0.5) + 1.0;
          if ( (float)(v1.n64_f32[0] * 0.5) >= v89 )
          {
            v0.n64_f32[0] = v89 / v1.n64_f32[0];
            v1.n64_f32[0] = pFraction[0];
            v90.n64_u64[0] = vmax_f32(v1, v0).n64_u64[0];
            v0.n64_f32[0] = 1.0 - v0.n64_f32[0];
            pFraction[0] = v90.n64_f32[0];
            LODWORD(v88) = vmin_f32(v90, v0).n64_u32[0];
          }
          pFraction[0] = v88;
          if ( Region < v255 )
          {
            p_InvertDirNewLink = &NewVehicleDependingOnCarModel->AutoPilot.InvertDirNewLink;
LABEL_130:
            v92 = -1;
LABEL_132:
            *p_InvertDirNewLink = v92;
            Index = pFromNode.Index;
            if ( (*((_WORD *)&ThePaths.pNodes[pFromNode.Region][pFromNode.Index] + 12) & 0xF) == 1 )
              goto LABEL_139;
            v256 = p_InvertDirNewLink;
            v241 = v57;
            v242 = v78;
            v94 = pFromNode.Region;
            v95 = HIWORD(*(unsigned int *)&pFromNode);
            v96 = (char *)&ThePaths + 4 * pFromNode.Region;
            v97 = v96 + 3492;
            v98 = v96 + 2052;
            do
            {
              v99 = rand();
              v100 = *v98 + 28 * v95;
              v101 = v99 % (*(_WORD *)(v100 + 24) & 0xF);
              v102 = *(unsigned __int16 *)(*v97 + 2 * (*(__int16 *)(v100 + 16) + (__int16)v101));
            }
            while ( v102 == NewVehicleDependingOnCarModel->AutoPilot.NewLink.Address );
            NewVehicleDependingOnCarModel->AutoPilot.OldLink.Address = v102;
            if ( !ThePaths.pNodes[(unsigned __int16)v102 >> 10] )
            {
LABEL_139:
              (*((void (__fastcall **)(CVehicle *))NewVehicleDependingOnCarModel->_vptr$CPlaceable + 1))(NewVehicleDependingOnCarModel);
              return;
            }
            v103 = ThePaths.pAdjacentNodes[v94];
            v104 = ThePaths.pNodes[pFromNode.Region][HIWORD(*(unsigned int *)&pFromNode)].IndexAdjacentNodes
                 + (__int16)v101;
            v105 = v103[v104].Region;
            if ( v105 < v94 )
            {
              p_InvertDirOldLink = &NewVehicleDependingOnCarModel->AutoPilot.InvertDirOldLink;
LABEL_138:
              v107 = -1;
              goto LABEL_144;
            }
            if ( v105 == v94 )
            {
              p_InvertDirOldLink = &NewVehicleDependingOnCarModel->AutoPilot.InvertDirOldLink;
              if ( v103[v104].Index < Index )
                goto LABEL_138;
            }
            else
            {
              p_InvertDirOldLink = &NewVehicleDependingOnCarModel->AutoPilot.InvertDirOldLink;
            }
            v107 = 1;
LABEL_144:
            *p_InvertDirOldLink = v107;
            v108 = &ThePaths.pNodes[pFromNode.Region][HIWORD(*(unsigned int *)&pFromNode)];
            v109 = v108->CoorsX;
            v110 = v108->CoorsY;
            v111 = &ThePaths.pNodes[(unsigned __int16)v271][HIWORD(v271)];
            CoorsZ = v108->CoorsZ;
            v113 = v111->CoorsX;
            v114 = v111->CoorsY;
            v115 = v111->CoorsZ;
            v116 = (float)((float)v114 * 0.125) - (float)((float)v110 * 0.125);
            v117 = (float)((float)v113 * 0.125) - (float)((float)v109 * 0.125);
            v268.y = v116;
            v268.x = v117;
            v118 = sqrtf((float)(v117 * v117) + (float)(v116 * v116));
            v268.z = (float)((float)v115 * 0.125) - (float)((float)CoorsZ * 0.125);
            if ( v118 != 0.0 )
            {
              v116 = v116 / v118;
              v80 = v117 / v118;
            }
            CVector::Normalise(&v268);
            *(CVector *)&NewVehicleDependingOnCarModel->m_pMat->xy = v268;
            NewVehicleDependingOnCarModel->m_pMat->xx = v116;
            NewVehicleDependingOnCarModel->m_pMat->yx = -v80;
            NewVehicleDependingOnCarModel->m_pMat->zx = 0.0;
            NewVehicleDependingOnCarModel->m_pMat->xz = 0.0;
            NewVehicleDependingOnCarModel->m_pMat->yz = 0.0;
            NewVehicleDependingOnCarModel->m_pMat->zz = 1.0;
            v119 = NewVehicleDependingOnCarModel->AutoPilot.NewLink.Address;
            v5.n64_u32[0] = *(_DWORD *)&ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&NewVehicleDependingOnCarModel->AutoPilot.NewNode][HIWORD(*(_DWORD *)&NewVehicleDependingOnCarModel->AutoPilot.NewNode)].CoorsX;
            v6.n64_u32[0] = *(_DWORD *)&ThePaths.pLinks[v119 >> 10][v119 & 0x3FF].CoorsX;
            v120 = vmovl_s16(v6);
            v120.n128_u32[2] = *(_DWORD *)&ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&NewVehicleDependingOnCarModel->AutoPilot.OldNode][HIWORD(*(_DWORD *)&NewVehicleDependingOnCarModel->AutoPilot.OldNode)].CoorsX;
            v120.n128_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)v120.n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
            v121.n64_u64[0] = vsub_f32(
                                (float32x2_t)v120.n128_u64[0],
                                vmul_f32(
                                  vcvt_f32_s32((int32x2_t)vmovl_s16(v5).n128_u64[0]),
                                  (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
            v122.n64_u64[0] = vmul_f32(
                                vcvt_f32_s32((int32x2_t)vmovl_s16(*(int16x4_t *)&v120.n128_i8[8]).n128_u64[0]),
                                (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
            v126.n64_u64[0] = vmul_f32(v121, v121).n64_u64[0];
            v123.n64_u64[0] = vsub_f32((float32x2_t)v120.n128_u64[0], v122).n64_u64[0];
            v124 = vmul_f32(v123, v123).n64_u64[0];
            v125 = sqrtf(v126.n64_f32[0] + v126.n64_f32[1]);
            v126.n64_f32[0] = sqrtf(*(float *)&v124 + *((float *)&v124 + 1));
            if ( pFraction[0] >= (float)(v126.n64_f32[0] / (float)(v126.n64_f32[0] + v125)) )
            {
              CCarCtrl::PickNextNodeRandomly(NewVehicleDependingOnCarModel);
              v119 = NewVehicleDependingOnCarModel->AutoPilot.NewLink.Address;
              v127 = NewVehicleDependingOnCarModel->AutoPilot.OldLink.Address;
              v134 = ThePaths.pLinks[v119 >> 10];
              v135 = ThePaths.pLinks[v127 >> 10];
              v136 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&NewVehicleDependingOnCarModel->AutoPilot.OldNode][HIWORD(*(_DWORD *)&NewVehicleDependingOnCarModel->AutoPilot.OldNode)];
              v137 = v135[v127 & 0x3FF].CoorsX;
              v138 = (float)v136->CoorsX * 0.125;
              v139 = (float)v136->CoorsY * 0.125;
              v140 = (float)((float)v134[v119 & 0x3FF].CoorsY * 0.125) - v139;
              v141 = (float)((float)v134[v119 & 0x3FF].CoorsX * 0.125) - v138;
              v142 = sqrtf(
                       (float)((float)((float)((float)v137 * 0.125) - v138)
                             * (float)((float)((float)v137 * 0.125) - v138))
                     + (float)((float)((float)((float)v135[v127 & 0x3FF].CoorsY * 0.125) - v139)
                             * (float)((float)((float)v135[v127 & 0x3FF].CoorsY * 0.125) - v139)));
              v4.n64_f32[0] = sqrtf((float)(v141 * v141) + (float)(v140 * v140)) + v142;
              v133 = v142
                   - sqrtf(
                       (float)((float)(Coors.x - v138) * (float)(Coors.x - v138))
                     + (float)((float)(Coors.y - v139) * (float)(Coors.y - v139)));
            }
            else
            {
              v127 = NewVehicleDependingOnCarModel->AutoPilot.OldLink.Address;
              v128 = ThePaths.pLinks[v127 >> 10];
              v129 = v128[v127 & 0x3FF].CoorsX;
              v130 = v128[v127 & 0x3FF].CoorsY;
              v131 = sqrtf(
                       (float)((float)(Coors.x - v122.n64_f32[0]) * (float)(Coors.x - v122.n64_f32[0]))
                     + (float)((float)(Coors.y - v122.n64_f32[1]) * (float)(Coors.y - v122.n64_f32[1])));
              v132 = sqrtf(
                       (float)((float)((float)((float)v129 * 0.125) - v122.n64_f32[0])
                             * (float)((float)((float)v129 * 0.125) - v122.n64_f32[0]))
                     + (float)((float)((float)((float)v130 * 0.125) - v122.n64_f32[1])
                             * (float)((float)((float)v130 * 0.125) - v122.n64_f32[1])));
              v133 = v131 + v132;
              v4.n64_f32[0] = v126.n64_f32[0] + v132;
            }
            v143 = &ThePaths.pLinks[v127 >> 10][v127 & 0x3FF];
            v144 = &ThePaths.pLinks[v119 >> 10][v119 & 0x3FF];
            v249 = *v256;
            DirYb = v144->DirYb;
            DirXb = v144->DirXb;
            v244 = *p_InvertDirOldLink;
            v251 = p_InvertDirOldLink;
            OldLane = NewVehicleDependingOnCarModel->AutoPilot.OldLane;
            Center_4a = NewVehicleDependingOnCarModel;
            v146 = v143->DirYb;
            v147 = v143->DirXb;
            v148 = CCarPathLink::OneWayLaneOffset(v143);
            NewLane = Center_4a->AutoPilot.NewLane;
            v150 = 1.0;
            v151 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[Center_4a->AutoPilot.NewLink.Address >> 10][Center_4a->AutoPilot.NewLink.Address & 0x3FF]);
            v152 = (*((unsigned __int16 *)&ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&Center_4a->AutoPilot.NewNode][HIWORD(*(_DWORD *)&Center_4a->AutoPilot.NewNode)]
                    + 12) >> 12) & 3;
            if ( !v152 )
              v150 = 0.65;
            Center_4a->AutoPilot.SpeedFromNodes = v152;
            if ( v152 == 2 )
              v150 = 2.3;
            v126.n64_f32[0] = (float)(v151 + (float)NewLane) * 5.4;
            v153 = (float)(v148 + (float)OldLane) * 5.4;
            if ( Center_4a->m_vehicleType == 10 )
            {
              v126.n64_f32[0] = v126.n64_f32[0] + 1.458;
              v153 = v153 + 1.458;
            }
            CruiseSpeed = (float)Center_4a->AutoPilot.CruiseSpeed;
            Center_4a->AutoPilot.SpeedMultiplier = v150;
            v155 = v150 * CruiseSpeed;
            Center_4a->AutoPilot.ActualSpeed = v155;
            v156 = Center_4a->AutoPilot.OldLink.Address;
            v157 = ThePaths.pLinks[v156 >> 10];
            v158 = v156 & 0x3FF;
            v159 = v157[v158].CoorsX;
            v160 = &v157[v158];
            v161 = (float)v160->CoorsY;
            startCoors.m_vecPosition.z = 0.0;
            v191.n64_f32[1] = (float)v146 * 0.01;
            v162 = (float)((float)((float)v147 * 0.01) * (float)v244) * v153;
            v163 = (float)(v191.n64_f32[1] * (float)v244) * v153;
            startCoors.m_vecPosition.y = (float)(v161 * 0.125) - v162;
            startCoors.m_vecPosition.x = v163 + (float)((float)v159 * 0.125);
            LOWORD(v157) = Center_4a->AutoPilot.NewLink.Address;
            v164 = ThePaths.pLinks[(unsigned __int16)v157 >> 10];
            v165 = (unsigned __int16)v157 & 0x3FF;
            v166 = v164[v165].CoorsX;
            v167 = &v164[v165];
            v168 = (float)v167->CoorsY;
            endCoors.z = 0.0;
            v169 = (float)((float)((float)DirXb * 0.01) * (float)v249) * v126.n64_f32[0];
            v170 = (float)((float)((float)DirYb * 0.01) * (float)v249) * v126.n64_f32[0];
            endCoors.y = (float)(v168 * 0.125) - v169;
            endCoors.x = v170 + (float)((float)v166 * 0.125);
            v126.n64_f32[0] = v133 / v4.n64_f32[0];
            v4.n64_u32[0] = 0;
            v191.n64_f32[0] = (float)(1000.0 / v155)
                            * CCurves::CalcSpeedScaleFactor(
                                &startCoors.m_vecPosition,
                                &endCoors,
                                (float)((float)v160->DirXb * 0.01) * (float)*v251,
                                (float)((float)v160->DirYb * 0.01) * (float)*v251,
                                (float)((float)v167->DirXb * 0.01) * (float)*v256,
                                (float)((float)v167->DirYb * 0.01) * (float)*v256);
            v171.n64_u64[0] = vmax_f32(v126, v4).n64_u64[0];
            v126.n64_u32[0] = 1.0;
            v172 = (float)(int)v191.n64_f32[0];
            Center_4a->AutoPilot.TimeToGetToNextLink = (int)v191.n64_f32[0];
            v173 = CTimer::m_snTimeInMilliseconds;
            v174 = (float)CTimer::m_snTimeInMilliseconds - (float)(vmin_f32(v171, v126).n64_f32[0] * v172);
            Center_4a->AutoPilot.TimeToLeaveLink = (int)v174;
            v175 = Center_4a->AutoPilot.OldLink.Address;
            v176 = ThePaths.pLinks[v175 >> 10];
            v177 = 7 * (v175 & 0x3FF);
            v178 = (float)*(&v176->CoorsY + v177);
            v179 = (float)*(&v176->CoorsX + v177);
            startCoors.m_vecPosition.z = 0.0;
            startCoors.m_vecPosition.y = (float)(v178 * 0.125) - v162;
            startCoors.m_vecPosition.x = v163 + (float)(v179 * 0.125);
            LOWORD(v177) = Center_4a->AutoPilot.NewLink.Address;
            v180 = ThePaths.pLinks[(unsigned __int16)v177 >> 10];
            v181 = v177 & 0x3FF;
            v182 = v180[v181].CoorsX;
            v183 = (float)v180[v181].CoorsY;
            endCoors.z = 0.0;
            endCoors.y = (float)(v183 * 0.125) - v169;
            startDir.y = v191.n64_f32[1] * (float)v244;
            startDir.x = (float)((float)v147 * 0.01) * (float)v244;
            endDir.y = (float)((float)DirYb * 0.01) * (float)v249;
            endDir.x = (float)((float)DirXb * 0.01) * (float)v249;
            endCoors.x = v170 + (float)((float)v182 * 0.125);
            startDir.z = 0.0;
            endDir.z = 0.0;
            CCurves::CalcCurvePoint(
              &startCoors.m_vecPosition,
              &endCoors,
              &startDir,
              &endDir,
              (float)(v173 - (int)v174) / v172,
              (int)v191.n64_f32[0],
              &Coors,
              &v266);
            v184 = pFromNode;
            v185 = &ThePaths.pNodes[(unsigned __int16)v271][HIWORD(v271)];
            v186 = &ThePaths.pNodes[pFromNode.Region][HIWORD(*(unsigned int *)&pFromNode)];
            v187 = (float)v185->CoorsZ * 0.125;
            v188 = (float)v186->CoorsZ * 0.125;
            v189 = (float)((float)v186->CoorsY * 0.125) - (float)((float)v185->CoorsY * 0.125);
            v191.n64_f32[0] = (float)((float)v186->CoorsX * 0.125) - (float)((float)v185->CoorsX * 0.125);
            v190 = 2.0
                 / sqrtf(
                     (float)((float)(v191.n64_f32[0] * v191.n64_f32[0]) + (float)(v189 * v189))
                   + (float)((float)(v188 - v187) * (float)(v188 - v187)));
            v191.n64_f32[0] = Coors.x + (float)(v191.n64_f32[0] * v190);
            v192 = Coors.y + (float)(v189 * v190);
            LODWORD(endCoors.x) = v191.n64_u32[0];
            endCoors.y = v192;
            endCoors.z = (float)(v188 * (float)(1.0 - pFraction[0])) + (float)(pFraction[0] * v187);
            if ( v243 )
            {
              if ( CWaterLevel::GetWaterLevel(
                     v191.n64_f32[0],
                     v192,
                     (float)(v188 * (float)(1.0 - pFraction[0])) + (float)(pFraction[0] * v187),
                     &startCoors.m_vecPosition.x,
                     1,
                     0) != 1 )
              {
LABEL_165:
                (*((void (__fastcall **)(CVehicle *))Center_4a->_vptr$CPlaceable + 1))(Center_4a);
                return;
              }
              v193 = startCoors.m_vecPosition.x;
            }
            else
            {
              v193 = 1000000000.0;
              if ( CWorld::ProcessVerticalLine(
                     &endCoors,
                     1000.0,
                     &startCoors,
                     (CEntity **)&startDir,
                     1,
                     0,
                     0,
                     0,
                     1,
                     0,
                     0) )
              {
                v193 = startCoors.m_vecPosition.z;
              }
              if ( CWorld::ProcessVerticalLine(
                     &endCoors,
                     -1000.0,
                     &startCoors,
                     (CEntity **)&startDir,
                     1,
                     0,
                     0,
                     0,
                     1,
                     0,
                     0)
                && fabsf(startCoors.m_vecPosition.z - endCoors.z) < fabsf(v193 - endCoors.z) )
              {
                v193 = startCoors.m_vecPosition.z;
              }
            }
            if ( v193 == 1000000000.0 || fabsf(v193 - endCoors.z) > 7.0 )
              goto LABEL_165;
            v257 = 0.0;
            if ( CModelInfo::IsBoatModel(Center_4a->m_nModelIndex) )
            {
              endCoors.z = v193;
              Center_4a->ExtendedRemovalRange = 255;
            }
            else
            {
              v193 = v193 + (*((float (__fastcall **)(CVehicle *))Center_4a->_vptr$CPlaceable + 54))(Center_4a);
              endCoors.z = v193;
            }
            v194 = endCoors.y;
            m_pMat = Center_4a->m_pMat;
            if ( m_pMat )
            {
              m_pMat->tx = endCoors.x;
              Center_4a->m_pMat->ty = v194;
              p_tz = &Center_4a->m_pMat->tz;
            }
            else
            {
              Center_4a->m_transform.m_translate.x = endCoors.x;
              Center_4a->m_transform.m_translate.y = v194;
              p_tz = &Center_4a->m_transform.m_translate.z;
            }
            *p_tz = v193;
            Center_4a->m_vecMoveSpeed.x = 0.0;
            Center_4a->m_vecMoveSpeed.y = 0.0;
            Center_4a->m_vecMoveSpeed.z = 0.0;
            v197 = v270;
            v198 = v266.x;
            v199 = v266.y;
            v200 = Coors.x;
            v201 = Coors.y;
            if ( v270 == 24 )
            {
              v205 = 3;
              p_m_info = &Center_4a->m_info;
              m_info = Center_4a->m_info;
            }
            else
            {
              if ( v270 == 13 )
              {
                p_m_info = &Center_4a->m_info;
                v203 = *(_BYTE *)&Center_4a->m_info & 7;
                if ( Center_4a->AutoPilot.Mission == 1 )
                  v204 = (CEntity::CEntityInfo)(v203 | 0x10);
                else
                  v204 = (CEntity::CEntityInfo)(v203 | 0x18);
                goto LABEL_184;
              }
              p_m_info = &Center_4a->m_info;
              m_info = Center_4a->m_info;
              if ( v243 == 1 )
              {
                v205 = 3;
              }
              else
              {
                if ( (*(_BYTE *)&m_info & 0xF8) == 24 )
                {
LABEL_185:
                  CVisibilityPlugins::SetClumpAlpha((RpClump_0 *)Center_4a->m_pRwObject, 0);
                  if ( CCheat::m_aCheatsActive[78] && !Center_4a->m_baseVehicleType )
                    CVehicle::AddVehicleUpgrade(Center_4a, MI_HYDRAULICS);
                  v207 = CEntity::GetIsOnScreen(Center_4a);
                  v208 = (const CVector *)Center_4a->m_pMat;
                  v209 = v207;
                  p_m_translate = v208 + 4;
                  if ( !v208 )
                    p_m_translate = &Center_4a->m_transform.m_translate;
                  v211 = p_m_translate->y;
                  v2.n64_f32[0] = (float)Center_4a->ExtendedRemovalRange;
                  v212 = sqrtf(
                           (float)((float)(Center - p_m_translate->x) * (float)(Center - p_m_translate->x))
                         + (float)((float)(Center_8 - v211) * (float)(Center_8 - v211)));
                  if ( v209 )
                  {
                    v3.n64_u32[0] = 1126825984;
                    if ( v212 > (float)(vmax_f32(v2, v3).n64_f32[0] * TheCamera.GenerationDistMultiplier)
                      || v212 < (float)(TheCamera.GenerationDistMultiplier * 150.0) )
                    {
                      goto LABEL_226;
                    }
                    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
                    if ( !TheCamera.m_pMat )
                      p_tx = &TheCamera.m_transform;
                    if ( (sqrtf(
                            (float)((float)(p_tx->m_translate.x - p_m_translate->x)
                                  * (float)(p_tx->m_translate.x - p_m_translate->x))
                          + (float)((float)(p_tx->m_translate.y - v211) * (float)(p_tx->m_translate.y - v211))) < (float)(TheCamera.GenerationDistMultiplier * 120.0)) | v253 )
                      goto LABEL_226;
                    v214 = (unsigned __int16)Center_4a->m_nModelIndex;
                    if ( v214 == 484 )
                      goto LABEL_226;
                  }
                  else
                  {
                    v191.n64_u32[0] = 1126825984;
                    if ( !((v212 <= (float)((float)(vmax_f32(v2, v191).n64_f32[0] / 170.0) * 45.0)) | v253) )
                      goto LABEL_226;
                    LOWORD(v214) = Center_4a->m_nModelIndex;
                  }
                  CWorld::FindObjectsKindaColliding(
                    p_m_translate,
                    CModelInfo::ms_modelInfoPtrs[(__int16)v214]->m_pColModel->m_sphereBound.m_fRadius,
                    1,
                    &pNum,
                    2,
                    0,
                    0,
                    1,
                    1,
                    0,
                    0);
                  if ( !pNum
                    && (float)((float)((float)((float)(v198 * 0.016667) - v11) * (float)(v200 - Center))
                             + (float)((float)((float)(v199 * 0.016667) - y) * (float)(v201 - Center_8))) < 0.0 )
                  {
                    CVehicleModelInfo::ChooseVehicleColour(
                      (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[Center_4a->m_nModelIndex],
                      &Center_4a->m_colour1,
                      &Center_4a->m_colour2,
                      &Center_4a->m_colour3,
                      &Center_4a->m_colour4,
                      1);
                    CWorld::Add(Center_4a);
                    if ( (unsigned int)(Center_4a->m_nModelIndex - 531) < 2 || Center_4a->m_vehicleType == 10 )
                      Center_4a->AutoPilot.CruiseSpeed /= 3u;
                    if ( CGameLogic::LaRiotsActiveHere() )
                      Center_4a->m_nHealth = (float)(rand() % 1000);
                    if ( v197 == 13 )
                      CCarCtrl::LastTimeLawEnforcerCreated = CTimer::m_snTimeInMilliseconds;
                    if ( Center_4a->m_nModelIndex == 457 )
                    {
                      v215 = Center_4a->m_info;
                      Center_4a->AutoPilot.DrivingMode = 2;
                      Center_4a->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v215 & 7 | 0x18);
                    }
                    if ( !Center_4a->m_baseVehicleType && v197 <= 0x17 )
                    {
                      if ( ((1 << v197) & 0xFFC002) != 0 )
                      {
                        if ( !(int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 8.0) )
                        {
                          v224 = (CAutomobile *)Center_4a;
                          v225 = 1;
LABEL_250:
                          CAutomobile::SetRandomDamage(v224, v225);
                        }
                      }
                      else if ( ((1 << v197) & 0x2071) != 0
                             && !(int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 20.0) )
                      {
                        v224 = (CAutomobile *)Center_4a;
                        v225 = 0;
                        goto LABEL_250;
                      }
                    }
                    if ( Center_4a->m_vehicleType == 9 && !Center_4a->AutoPilot.DrivingMode )
                    {
                      v216 = Center_4a->m_info;
                      Center_4a->AutoPilot.DrivingMode = 6;
                      Center_4a->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v216 & 7 | 0x18);
                    }
                    if ( ((v197 != 13) & (v243 ^ 1)) == 1
                      && FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN )
                    {
                      v217 = 0;
                      v218 = 0;
                      if ( CCarCtrl::TimeNextMadDriverChaseCreated > 0.0 )
                        v217 = 1;
                      if ( !CCheat::m_aCheatsActive[38] )
                        v218 = 1;
                      if ( !(v218 & v217 | v241) && CCarCtrl::CreatePoliceChase(Center_4a, v197, v184) == 1 )
                      {
                        active = CGameLogic::LaRiotsActiveHere();
                        v220 = (float)rand();
                        v221 = 600.0;
                        if ( active )
                          v221 = 240.0;
                        CCarCtrl::TimeNextMadDriverChaseCreated = v221 + (float)(v221 * (float)(v220 * 4.6566e-10));
                        goto LABEL_261;
                      }
                    }
                    if ( v242 != 1 )
                    {
                      v223 = v197 == 24;
                      if ( v197 != 24 )
                        v223 = v197 == 13;
                      if ( v223 )
                      {
                        CCarAI::AddPoliceCarOccupants(Center_4a, 0);
                      }
                      else
                      {
                        CCarCtrl::bCarIsBeingCreated = 1;
                        CCarCtrl::SetUpDriverAndPassengersForVehicle(Center_4a, v197, 0, 0, 0, 99);
                        CCarCtrl::bCarIsBeingCreated = 0;
                      }
                      goto LABEL_261;
                    }
                    v222 = Center_4a->m_nModelIndex;
                    if ( v222 <= 520 )
                    {
                      if ( v222 != 461 && v222 != 463 )
                      {
LABEL_251:
                        if ( (unsigned __int16)v222 != 586 )
                          goto LABEL_252;
                      }
                    }
                    else if ( (unsigned int)(v222 - 521) >= 2 && v222 != 581 )
                    {
                      goto LABEL_251;
                    }
                    if ( !gbLARiots
                      && !(int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 7.0)
                      && CCarCtrl::CreateConvoy(Center_4a, v197) )
                    {
                      CCarCtrl::SetUpDriverAndPassengersForVehicle(Center_4a, v197, 1, 1, 0, 99);
LABEL_261:
                      v236 = v197 == 24;
                      if ( v197 != 24 )
                        v236 = v197 == 13;
                      if ( v236 )
                        CVehicle::ChangeLawEnforcerState(Center_4a, 1u);
                      CStreaming::PossiblyStreamCarOutAfterCreation(Center_4a->m_nModelIndex);
                      v237 = CModelInfo::ms_modelInfoPtrs[Center_4a->m_nModelIndex];
                      m_lodDistance_low = SLOBYTE(v237[1].m_lodDistance);
                      if ( m_lodDistance_low > 118 )
                        v239 = 120;
                      else
                        v239 = m_lodDistance_low + 1;
                      LOBYTE(v237[1].m_lodDistance) = v239;
                      return;
                    }
LABEL_252:
                    CCarCtrl::SetUpDriverAndPassengersForVehicle(Center_4a, v197, 1, 1, 0, 99);
                    Center_4a->AutoPilot.DrivingMode = 2;
                    p_xx = &Center_4a->m_pMat->xx;
                    v227 = Center_4a->AutoPilot.CruiseSpeed + 10;
                    Center_4a->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&Center_4a->m_info & 7 | 0x18);
                    Center_4a->AutoPilot.CruiseSpeed = v227;
                    if ( p_xx )
                    {
                      v228 = p_xx[4];
                      v229 = p_xx[5];
                      v257 = p_xx[6];
                    }
                    else
                    {
                      m_heading = Center_4a->m_transform.m_heading;
                      v231 = sinf(m_heading);
                      v229 = cosf(m_heading);
                      LODWORD(v228) = LODWORD(v231) ^ 0x80000000;
                    }
                    v232 = (float)v227;
                    Center_4a->m_vecMoveSpeed.x = (float)(v228 * v232) * 0.02;
                    Center_4a->m_vecMoveSpeed.y = (float)(v229 * v232) * 0.02;
                    Center_4a->m_vecMoveSpeed.z = (float)(v257 * v232) * 0.02;
                    v233 = CGameLogic::LaRiotsActiveHere();
                    v234 = CCheat::m_aCheatsActive[38] == 0;
                    if ( !CCheat::m_aCheatsActive[38] )
                      v234 = !v233;
                    if ( !v234 )
                    {
                      pDriver = Center_4a->pDriver;
                      if ( pDriver )
                        *((_DWORD *)&pDriver->m_nPedFlags + 3) |= 0x800u;
                    }
                    *((_DWORD *)&Center_4a->m_nVehicleFlags + 1) |= 0x80000u;
                    goto LABEL_261;
                  }
LABEL_226:
                  (*((void (__fastcall **)(CVehicle *))Center_4a->_vptr$CPlaceable + 1))(Center_4a);
                  return;
                }
                v205 = 2;
              }
            }
            v204 = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | (8 * v205));
LABEL_184:
            *p_m_info = v204;
            goto LABEL_185;
          }
          if ( Region == v255 )
          {
            p_InvertDirNewLink = &NewVehicleDependingOnCarModel->AutoPilot.InvertDirNewLink;
            if ( pFromNode.Index < (unsigned int)HIWORD(v271) )
              goto LABEL_130;
          }
          else
          {
            p_InvertDirNewLink = &NewVehicleDependingOnCarModel->AutoPilot.InvertDirNewLink;
          }
          v92 = 1;
          goto LABEL_132;
        }
        if ( Center_4 != 431 )
        {
          v56 = Center_4 == 437;
          if ( Center_4 != 437 )
            v56 = v55 == 0;
          if ( !v56 )
            goto LABEL_76;
        }
      }
    }
  }
}
// 2E8E8E: variable 'v1' is possibly undefined
// 2E8E8E: variable 'v0' is possibly undefined
// 2E915E: variable 'v6' is possibly undefined
// 2E9134: variable 'v5' is possibly undefined
// 2E9704: variable 'v4' is possibly undefined
// 2E9B64: variable 'v2' is possibly undefined
// 2E9B64: variable 'v3' is possibly undefined
// 24: using guessed type int dword_24;
// FC: using guessed type int elf_hash_bucket[16411];
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;
// 6767A0: using guessed type __int16 *MI_HYDRAULICS_ptr[3];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 67816C: using guessed type int *CCarCtrl::NumMissionCars;
// 679EBC: using guessed type CLoadedCarGroup *CPopulation::m_LoadedBoats;
// 2E848C: using guessed type float var_64[25];

//----- (002EA10C) --------------------------------------------------------
void CCarCtrl::GenerateEmergencyServicesCar()
{
  const CAccidentManager *AccidentManager; // r0
  CAccidentManager *v1; // r4
  CAccident *NearestFreeAccident; // r4
  UInt32 DefaultAmbulanceModel; // r0
  CMatrix *m_pMat; // r2
  CVector *p_tx; // r3
  CFire *NearestFire; // r4
  UInt32 DefaultFireEngineModel; // r0
  CVector v8; // [sp+4h] [bp-14h] BYREF

  if ( CCarCtrl::bAllowEmergencyServicesToBeCreated
    && !CGangWars::GangWarFightingGoingOn()
    && FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel <= WANTED_LEVEL3
    && CGame::currArea == AREA_MAIN_MAP
    && CTheZones::m_CurrLevel
    && CCarCtrl::NumLawEnforcerCars
     + CCarCtrl::NumRandomCars
     + CCarCtrl::NumMissionCars
     + CCarCtrl::NumParkedCars
     + CCarCtrl::NumAmbulancesOnDuty
     + CCarCtrl::NumFireTrucksOnDuty <= CCarCtrl::MaxNumberOfCarsInUse )
  {
    if ( !CCarCtrl::NumAmbulancesOnDuty )
    {
      AccidentManager = GetAccidentManager();
      if ( CAccidentManager::ComputeNoOfFreeAccidents(AccidentManager) < 2 )
      {
        CStreaming::StreamAmbulanceAndMedic(0);
      }
      else
      {
        v1 = GetAccidentManager();
        FindPlayerCoors(&v8, -1);
        NearestFreeAccident = CAccidentManager::GetNearestFreeAccident(v1, &v8, 0);
        if ( NearestFreeAccident
          && CStreaming::StreamAmbulanceAndMedic(1)
          && CTimer::m_snTimeInMilliseconds > CCarCtrl::LastTimeAmbulanceCreated + 30000 )
        {
          DefaultAmbulanceModel = CStreaming::GetDefaultAmbulanceModel();
          m_pMat = NearestFreeAccident->m_pInjuredPed->m_pMat;
          p_tx = (CVector *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &NearestFreeAccident->m_pInjuredPed->m_transform.m_translate;
          if ( CCarCtrl::GenerateOneEmergencyServicesCar(DefaultAmbulanceModel, *p_tx) )
            CCarCtrl::LastTimeAmbulanceCreated = CTimer::m_snTimeInMilliseconds;
        }
      }
    }
    if ( !CCarCtrl::NumFireTrucksOnDuty )
    {
      if ( CFireManager::GetNumOfNonScriptFires(&gFireManager) < 3u )
      {
        CStreaming::StreamFireEngineAndFireman(0);
      }
      else
      {
        FindPlayerCoors(&v8, -1);
        NearestFire = CFireManager::FindNearestFire(&gFireManager, &v8, 1, 1);
        if ( NearestFire
          && CStreaming::StreamFireEngineAndFireman(1)
          && CTimer::m_snTimeInMilliseconds > CCarCtrl::LastTimeFireTruckCreated + 35000 )
        {
          DefaultFireEngineModel = CStreaming::GetDefaultFireEngineModel();
          if ( CCarCtrl::GenerateOneEmergencyServicesCar(DefaultFireEngineModel, NearestFire->m_vLocation) )
            CCarCtrl::LastTimeFireTruckCreated = CTimer::m_snTimeInMilliseconds;
        }
      }
    }
  }
}
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;
// 677AB4: using guessed type int CCarCtrl::NumParkedCars[2];
// 67816C: using guessed type int *CCarCtrl::NumMissionCars;

//----- (002EA314) --------------------------------------------------------
int32 __fastcall CCarCtrl::ChoosePoliceCarModel(Bool bNoBikes)
{
  CWanted *PlayerWanted; // r0
  bool v3; // zf
  CWanted *v5; // r0
  bool v6; // zf
  CWanted *v7; // r0
  bool v8; // zf

  PlayerWanted = FindPlayerWanted(-1);
  if ( CWanted::AreSwatRequired(PlayerWanted) )
  {
    v3 = CStreaming::ms_aInfoForModel[427].m_status == 1;
    if ( CStreaming::ms_aInfoForModel[427].m_status == 1 )
      v3 = CStreaming::ms_aInfoForModel[285].m_status == 1;
    if ( v3 )
    {
      if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0) == 2 )
        return 427;
      return sub_18AAB4(bNoBikes);
    }
  }
  v5 = FindPlayerWanted(-1);
  if ( CWanted::AreFbiRequired(v5) )
  {
    v6 = CStreaming::ms_aInfoForModel[490].m_status == 1;
    if ( CStreaming::ms_aInfoForModel[490].m_status == 1 )
      v6 = CStreaming::ms_aInfoForModel[286].m_status == 1;
    if ( v6 )
      return 490;
  }
  v7 = FindPlayerWanted(-1);
  if ( !CWanted::AreArmyRequired(v7) )
    return sub_18AAB4(bNoBikes);
  v8 = CStreaming::ms_aInfoForModel[432].m_status == 1;
  if ( CStreaming::ms_aInfoForModel[432].m_status == 1 )
    v8 = CStreaming::ms_aInfoForModel[433].m_status == 1;
  if ( !v8 || CStreaming::ms_aInfoForModel[287].m_status != 1 )
    return sub_18AAB4(bNoBikes);
  return rand() & 1 | 0x1B0;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002EA400) --------------------------------------------------------
int32 __fastcall CCarCtrl::ChooseModel(int32 *CarRating)
{
  int v2; // s16
  float v3; // s16
  float v4; // s0
  _BOOL4 v6; // r0
  bool v7; // zf
  int v8; // r5
  unsigned __int16 v9; // r0
  int v10; // r1
  int v11; // r0
  Int32 v12; // r5
  int v13; // r3
  int v14; // r8
  int32 *v15; // r1
  int m_status; // r0

  v2 = (int)(float)((float)((float)(CPopCycle::m_NumDealers_Cars + CPopCycle::m_NumGangs_Cars)
                          + CPopCycle::m_NumCops_Cars)
                  + CPopCycle::m_NumOther_Cars);
  if ( v2 < 1
    || CCheat::m_aCheatsActive[82] && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) )
  {
    return -1;
  }
  v3 = (float)v2;
  v4 = (float)((float)rand() * 4.6566e-10) + 0.0;
  if ( !CCheat::m_aCheatsActive[51] && v4 < (float)(CPopCycle::m_NumDealers_Cars / v3) )
  {
    *CarRating = 25;
    CarRating = (int32 *)CPopulation::m_CarGroups[28][0];
    if ( CStreaming::ms_aInfoForModel[CPopulation::m_CarGroups[28][0]].m_status != 1 )
      return -1;
    return (int32)CarRating;
  }
  if ( CCheat::m_aCheatsActive[51]
    || v4 < (float)((float)(CPopCycle::m_NumDealers_Cars + CPopCycle::m_NumGangs_Cars) / v3) )
  {
    if ( !CPopulation::m_bDontCreateRandomGangMembers )
    {
      v8 = CPopCycle::m_pCurrZoneInfo->aGangStrengths[4]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[0]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[1]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[2]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[3]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[5]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[6]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[7]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[8]
         + CPopCycle::m_pCurrZoneInfo->aGangStrengths[9];
      if ( v8 >= 1 )
      {
        v9 = rand();
        v10 = CPopCycle::m_pCurrZoneInfo->aGangStrengths[0];
        v11 = (int)(float)((float)((float)v9 * 0.000015259) * (float)v8);
        if ( v11 <= v10 )
        {
          v12 = 0;
        }
        else
        {
          v12 = 0;
          do
          {
            v13 = CPopCycle::m_pCurrZoneInfo->aGangStrengths[v12 + 1];
            v11 -= v10;
            ++v12;
            v10 = v13;
          }
          while ( v11 > v13 );
        }
        if ( CCheat::m_aCheatsActive[51] )
          v12 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 9.0);
        *CarRating = v12 + 14;
        if ( CPopulation::PickGangCar(v12) >= 0 )
        {
          v14 = 0;
          while ( 1 )
          {
            do
            {
              do
                v15 = (int32 *)CPopulation::m_CarGroups[v12 + 18][(float)((float)((float)(unsigned __int16)rand()
                                                                                * 0.000015259)
                                                                        * 23.0)];
              while ( v15 == &elf_hash_bucket[437] );
              m_status = CStreaming::ms_aInfoForModel[(_DWORD)v15].m_status;
              if ( m_status == 1 )
                CarRating = v15;
              else
                m_status = 10;
            }
            while ( (m_status & 0xF) == 0 );
            if ( m_status != 10 )
              break;
            if ( v14++ >= 9 )
              return -1;
          }
          return (int32)CarRating;
        }
      }
    }
    return -1;
  }
  if ( v4 >= (float)((float)((float)(CPopCycle::m_NumDealers_Cars + CPopCycle::m_NumGangs_Cars)
                           + CPopCycle::m_NumCops_Cars)
                   / v3) )
  {
    *CarRating = 0;
    CarRating = (int32 *)CTheScripts::ForceRandomCarModel;
    if ( CTheScripts::ForceRandomCarModel != -1 )
      return (int32)CarRating;
    return sub_19CAA8(&CPopulation::m_AppropriateLoadedCars, 1, 0);
  }
  else
  {
    v6 = CGangWars::GangWarFightingGoingOn();
    v7 = !CPopulation::m_bDontCreateRandomCops;
    if ( !CPopulation::m_bDontCreateRandomCops )
      v7 = !v6;
    if ( !v7 )
      return -1;
    *CarRating = 13;
    return CCarCtrl::ChoosePoliceCarModel(0);
  }
}
// 2EA6DC: conditional instruction was optimized away because r0.4 is in (==1|==A)
// 2EA6C2: masking with 0xF was optimized away because r0.4 <= 0xA
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;

//----- (002EA744) --------------------------------------------------------
int32 CCarCtrl::ChooseBoatModel()
{
  return sub_192B7C(&CPopulation::m_LoadedBoats, 1);
}

//----- (002EA754) --------------------------------------------------------
void __fastcall CCarCtrl::PickNextNodeRandomly(CVehicle *pVehicle)
{
  unsigned int ForcedRandomSeed; // r0
  char *v3; // r10
  CNodeAddress NewNode; // r11
  char *v5; // r9
  int v6; // r1
  unsigned int Address; // r0
  unsigned __int16 *v8; // r2
  int v9; // r0
  _BOOL4 v10; // r1
  unsigned int v11; // r8
  int v12; // r5
  int m_nModelIndex; // r12
  unsigned int v14; // r6
  int NewLane; // r3
  int v16; // r2
  unsigned int v17; // r6
  bool v18; // cf
  unsigned int v19; // r6
  int v20; // r6
  unsigned int v21; // r0
  int v22; // r8
  int v23; // r11
  char *v24; // r1
  int v25; // r0
  int v26; // r6
  CNodeAddress v27; // r2
  int PathDirection; // r9
  unsigned int v29; // r5
  unsigned __int16 *v30; // r1
  int v31; // r2
  bool v32; // zf
  int v33; // r0
  __int16 v34; // r2
  int bGoingAgainstTraffic; // r1
  int v36; // r6
  int IsThisAnAppropriateNode; // r0
  bool v38; // zf
  int v39; // r4
  int v40; // r11
  char *v41; // r0
  int v42; // r0
  Int32 v43; // r1
  int v44; // r6
  CNodeAddress v45; // r2
  unsigned __int16 *v46; // r0
  __int16 v47; // r1
  int v48; // r0
  int v49; // r4
  int v50; // r11
  char *v51; // r0
  int v52; // r0
  Int32 v53; // r1
  int v54; // r6
  CNodeAddress v55; // r2
  unsigned __int16 *v56; // r0
  __int16 v57; // r1
  int v58; // r0
  CEntity::CEntityInfo m_info; // r0
  uint32 v60; // r0
  int v61; // r1
  int v62; // r0
  CEntity::CEntityInfo v63; // r1
  __int16 v64; // r1
  CEntity::CEntityInfo v65; // r1
  CEntity::CEntityInfo v66; // r1
  uint32 v67; // r0
  CEntity::CEntityInfo v68; // r1
  Int8 InvertDirOldLink; // r6
  UInt16 v70; // r10
  Int8 InvertDirNewLink; // lr
  Int8 v72; // r12
  __int64 v73; // kr00_8
  unsigned int v74; // r0
  float v75; // s16
  unsigned int v76; // r9
  int v77; // r8
  CPathNode *v78; // r1
  CPathNode *v79; // r2
  int CoorsX; // s6
  float CoorsY; // s2
  CCarPathLink *v82; // r1
  float DirYb; // s22
  CCarPathLink *v84; // r0
  float v85; // s0
  float DirXb; // s24
  float v87; // s2
  float v88; // s26
  float v89; // s28
  float v90; // s30
  Int8 v91; // r0
  int v92; // r0
  char v93; // r0
  Int8 v94; // r1
  char v95; // r2
  int v96; // r1
  __int16 v97; // r3
  Int8 v98; // r2
  int OldLane; // r5
  float v100; // s24
  float v101; // s22
  float v102; // s26
  float v103; // s28
  float v104; // r0
  float v105; // s0
  int v106; // r5
  float v107; // s30
  float v108; // r0
  UInt16 v109; // r1
  float ActualSpeed; // s16
  CCarPathLink *v111; // r2
  int v112; // r3
  CCarPathLink *v113; // r1
  RwReal v114; // s4
  RwReal v115; // s2
  float v116; // s0
  CCarPathLink *v117; // r6
  float v118; // s2
  float v119; // s4
  int v120; // r0
  int v121; // [sp+10h] [bp-D8h]
  CNodeAddress v122; // [sp+20h] [bp-C8h]
  unsigned int v123; // [sp+24h] [bp-C4h]
  int v124; // [sp+28h] [bp-C0h]
  int v125; // [sp+2Ch] [bp-BCh]
  _DWORD *v126; // [sp+3Ch] [bp-ACh]
  unsigned int Region; // [sp+40h] [bp-A8h]
  _DWORD *v128; // [sp+48h] [bp-A0h]
  _DWORD *v129; // [sp+48h] [bp-A0h]
  _DWORD *v130; // [sp+50h] [bp-98h]
  _DWORD *v131; // [sp+50h] [bp-98h]
  _DWORD *v132; // [sp+50h] [bp-98h]
  CAutoPilot *p_AutoPilot; // [sp+54h] [bp-94h]
  unsigned int v134; // [sp+58h] [bp-90h]
  CNodeAddress OldNode; // [sp+5Ch] [bp-8Ch]
  int v136; // [sp+60h] [bp-88h]
  _DWORD *v137; // [sp+64h] [bp-84h]
  CVehicle *v138; // [sp+68h] [bp-80h]
  CVector endCoors; // [sp+6Ch] [bp-7Ch] BYREF
  CVector startCoors; // [sp+78h] [bp-70h] BYREF
  bool pSharpTurn[97]; // [sp+87h] [bp-61h] BYREF

  ForcedRandomSeed = pVehicle->ForcedRandomSeed;
  if ( ForcedRandomSeed )
    srand(ForcedRandomSeed);
  OldNode = pVehicle->AutoPilot.OldNode;
  v3 = (char *)&ThePaths + 4 * OldNode.Region;
  if ( *((_DWORD *)v3 + 513) )
  {
    NewNode = pVehicle->AutoPilot.NewNode;
    Region = NewNode.Region;
    v5 = (char *)&ThePaths + 4 * NewNode.Region;
    v6 = *((_DWORD *)v5 + 513);
    if ( v6 )
    {
      Address = pVehicle->AutoPilot.NewLink.Address;
      if ( ThePaths.pNodes[Address >> 10] )
      {
        v134 = HIWORD(*(unsigned int *)&NewNode);
        v136 = *(_WORD *)(v6 + 28 * HIWORD(*(unsigned int *)&NewNode) + 24) & 0xF;
        v8 = (unsigned __int16 *)&ThePaths.pLinks[Address >> 10][Address & 0x3FF];
        v9 = 0;
        v10 = 0;
        if ( v8[2] == NewNode.Region )
          v10 = v8[3] == v134;
        p_AutoPilot = &pVehicle->AutoPilot;
        v11 = *(unsigned __int16 *)((char *)v8 + 11);
        v12 = 0;
        m_nModelIndex = pVehicle->m_nModelIndex;
        LOBYTE(v14) = v11;
        NewLane = pVehicle->AutoPilot.NewLane;
        pVehicle->AutoPilot.VeryOldNode = OldNode;
        v16 = 0;
        pVehicle->AutoPilot.OldNode = NewNode;
        if ( !v10 )
          v14 = v11 >> 3;
        v17 = v14 & 7;
        v18 = v17 >= 3;
        v19 = v17 - 1;
        if ( !v18 )
          v12 = 1;
        if ( !NewLane )
          v16 = 4;
        if ( v19 == NewLane )
          v16 |= 2u;
        v20 = 7;
        if ( !v16 )
          v9 = 1;
        v125 = v9 | v12 | v16;
        if ( v10 )
          v20 = 56;
        v138 = pVehicle;
        switch ( m_nModelIndex )
        {
          case 403:
          case 406:
          case 431:
          case 437:
          case 443:
          case 455:
            goto LABEL_23;
          case 404:
          case 405:
          case 407:
          case 408:
          case 409:
          case 410:
          case 411:
          case 412:
          case 413:
          case 414:
          case 415:
          case 416:
          case 417:
          case 418:
          case 419:
          case 420:
          case 421:
          case 422:
          case 423:
          case 424:
          case 425:
          case 426:
          case 427:
          case 428:
          case 429:
          case 430:
          case 432:
          case 433:
          case 434:
          case 435:
          case 436:
          case 438:
          case 439:
          case 440:
          case 441:
          case 442:
          case 444:
          case 445:
          case 446:
          case 447:
          case 448:
          case 449:
          case 450:
          case 451:
          case 452:
          case 453:
          case 454:
            break;
          default:
            if ( (unsigned int)(m_nModelIndex - 514) <= 0xA && ((1 << (m_nModelIndex - 2)) & 0x403) != 0 )
LABEL_23:
              v125 = 1;
            break;
        }
        v123 = HIWORD(*(unsigned int *)&OldNode);
        SequenceElements = v136;
        SequenceRandomOffset = rand() % v136;
        v21 = ((unsigned int)rand() >> 4) & 1;
        bSequenceOtherWay = v21;
        v137 = v5 + 2052;
        v121 = v11 & v20;
        v22 = 0;
        v122 = NewNode;
        v23 = 1;
        v24 = (char *)&ThePaths + 4 * Region;
        v130 = v24 + 2628;
        v126 = v24 + 3492;
        while ( 1 )
        {
          v25 = v21 << 24 ? v23 + SequenceRandomOffset - 1 : SequenceRandomOffset + SequenceElements + v22;
          v26 = v25 % SequenceElements;
          v27 = *(CNodeAddress *)(*v130 + 4 * (*(__int16 *)(*v137 + 28 * v134 + 16) + v25 % SequenceElements));
          pVehicle->AutoPilot.NewNode = v27;
          if ( ThePaths.pNodes[v27.Region] )
          {
            PathDirection = CCarCtrl::FindPathDirection(OldNode, p_AutoPilot->OldNode, v27, pSharpTurn);
            v29 = *(unsigned __int16 *)(*v126 + 2 * (*(__int16 *)(*v137 + 28 * v134 + 16) + v26));
            if ( ThePaths.pNodes[v29 >> 10] )
            {
              if ( (*(_BYTE *)&pVehicle->m_info & 0xF8) != 16 || !pSharpTurn[0] )
              {
                v30 = (unsigned __int16 *)&ThePaths.pLinks[v29 >> 10][v29 & 0x3FF];
                if ( v30[2] == Region )
                {
                  v31 = v30[3];
                  v32 = v31 == v134;
                  v33 = 56;
                  if ( v31 == v134 )
                    v33 = 7;
                  v34 = 7;
                  v124 = v33;
                  if ( v32 )
                    v34 = 56;
                }
                else
                {
                  v34 = 7;
                  v124 = 56;
                }
                v32 = (unsigned __int16)(*(unsigned __int16 *)((char *)v30 + 11) & v34) << 16 == 0;
                bGoingAgainstTraffic = 0;
                v36 = *(unsigned __int16 *)((char *)&ThePaths.pLinks[(unsigned __int16)v29 >> 10][v29 & 0x3FF] + 11);
                if ( v32 )
                  bGoingAgainstTraffic = 1;
                IsThisAnAppropriateNode = CCarCtrl::IsThisAnAppropriateNode(
                                            pVehicle,
                                            OldNode,
                                            v122,
                                            pVehicle->AutoPilot.NewNode,
                                            bGoingAgainstTraffic,
                                            0);
                v38 = (PathDirection & v125) == 0;
                if ( (PathDirection & v125) != 0 )
                  v38 = IsThisAnAppropriateNode == 0;
                if ( !v38 && (v124 & v36 | v121) << 16 )
                  break;
              }
            }
          }
          if ( v23 >= v136 )
          {
            v39 = 0;
            v40 = 0;
            v41 = (char *)&ThePaths + 4 * Region;
            v131 = v41 + 2628;
            v128 = v41 + 3492;
            while ( 1 )
            {
              if ( bSequenceOtherWay )
              {
                v42 = SequenceRandomOffset + v40;
                v43 = SequenceElements;
              }
              else
              {
                v43 = SequenceElements;
                v42 = SequenceRandomOffset + SequenceElements + v39;
              }
              v44 = v42 % v43;
              v45 = *(CNodeAddress *)(*v131 + 4 * (*(__int16 *)(*v137 + 28 * v134 + 16) + v42 % v43));
              v138->AutoPilot.NewNode = v45;
              if ( ThePaths.pNodes[v45.Region] )
              {
                CCarCtrl::FindPathDirection(OldNode, p_AutoPilot->OldNode, v45, pSharpTurn);
                v29 = *(unsigned __int16 *)(*v128 + 2 * (*(__int16 *)(*v137 + 28 * v134 + 16) + v44));
                if ( ThePaths.pNodes[v29 >> 10] )
                {
                  v46 = (unsigned __int16 *)&ThePaths.pLinks[v29 >> 10][v29 & 0x3FF];
                  if ( v46[2] == Region )
                  {
                    v47 = 7;
                    if ( v46[3] == v134 )
                      v47 = 56;
                  }
                  else
                  {
                    v47 = 7;
                  }
                  v48 = (unsigned __int16)(*(unsigned __int16 *)((char *)v46 + 11) & v47);
                  if ( (v138->AutoPilot.NewNode.Region != OldNode.Region || v138->AutoPilot.NewNode.Index != v123)
                    && v48 << 16
                    && ((*((_WORD *)&ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&v138->AutoPilot.NewNode][HIWORD(*(_DWORD *)&v138->AutoPilot.NewNode)]
                         + 12) & 0x20) == 0
                     || (*(_WORD *)(*((_DWORD *)v3 + 513) + 28 * v123 + 24) & 0x20) != 0) )
                  {
                    goto LABEL_80;
                  }
                }
              }
              ++v40;
              --v39;
              if ( v40 >= v136 )
              {
                v49 = 0;
                v50 = 0;
                v51 = (char *)&ThePaths + 4 * Region;
                v132 = v51 + 2628;
                v129 = v51 + 3492;
                while ( 1 )
                {
                  if ( bSequenceOtherWay )
                  {
                    v52 = SequenceRandomOffset + v50;
                    v53 = SequenceElements;
                  }
                  else
                  {
                    v53 = SequenceElements;
                    v52 = SequenceRandomOffset + SequenceElements + v49;
                  }
                  v54 = v52 % v53;
                  v55 = *(CNodeAddress *)(*v132 + 4 * (*(__int16 *)(*v137 + 28 * v134 + 16) + v52 % v53));
                  v138->AutoPilot.NewNode = v55;
                  if ( ThePaths.pNodes[v55.Region] )
                  {
                    CCarCtrl::FindPathDirection(OldNode, p_AutoPilot->OldNode, v55, pSharpTurn);
                    v29 = *(unsigned __int16 *)(*v129 + 2 * (*(__int16 *)(*v137 + 28 * v134 + 16) + v54));
                    if ( ThePaths.pNodes[v29 >> 10] )
                    {
                      v56 = (unsigned __int16 *)&ThePaths.pLinks[v29 >> 10][v29 & 0x3FF];
                      if ( v56[2] == Region )
                      {
                        v57 = 7;
                        if ( v56[3] == v134 )
                          v57 = 56;
                      }
                      else
                      {
                        v57 = 7;
                      }
                      v58 = (unsigned __int16)(*(unsigned __int16 *)((char *)v56 + 11) & v57);
                      if ( v138->AutoPilot.NewNode.Region != OldNode.Region || v138->AutoPilot.NewNode.Index != v123 )
                      {
                        if ( v58 << 16 )
                          goto LABEL_80;
                      }
                    }
                  }
                  ++v50;
                  --v49;
                  if ( v50 >= v136 )
                  {
                    v29 = v138->AutoPilot.NewLink.Address;
                    v138->AutoPilot.NewNode = OldNode;
                    goto LABEL_80;
                  }
                }
              }
            }
          }
          ++v23;
          --v22;
          v21 = bSequenceOtherWay;
        }
LABEL_80:
        if ( FindPlayerVehicle(-1, 0) != v138
          && v138->AutoPilot.NewNode.Region == OldNode.Region
          && v138->AutoPilot.NewNode.Index == v123 )
        {
          m_info = v138->m_info;
          if ( (*(_BYTE *)&m_info & 0xF8) != 24 )
          {
            v138->AutoPilot.TempAction = 0;
            v138->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
            v60 = CTimer::m_snTimeInMilliseconds;
            v138->m_nNoOfStaticFrames = 0;
            v138->AutoPilot.LastTimeNotStuck = v60 + 2000;
            v138->AutoPilot.LastTimeMoving = v60;
          }
        }
        v61 = *((unsigned __int8 *)&ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&v138->AutoPilot.NewNode][HIWORD(*(_DWORD *)&v138->AutoPilot.NewNode)]
              + 26);
        v62 = (unsigned __int16)v61 >> 4;
        if ( (unsigned int)(v61 << 16) >> 20 == 10 )
        {
          v138->AutoPilot.TempAction = 1;
          v65 = v138->m_info;
          v138->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 10000;
          if ( (*(_BYTE *)&v65 & 0xF8) == 16 )
            CAutoPilot::ModifySpeed(p_AutoPilot, 0.0);
        }
        else
        {
          if ( v62 == 2 )
          {
            v66 = v138->m_info;
            v138->AutoPilot.TempAction = 0;
            v138->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v66 & 7 | 0x18);
            v64 = 11520;
            goto LABEL_92;
          }
          if ( v62 == 1 )
          {
            v63 = v138->m_info;
            v138->AutoPilot.TempAction = 0;
            v138->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v63 & 7 | 0x18);
            v64 = 11776;
LABEL_92:
            v67 = CTimer::m_snTimeInMilliseconds;
            *(_WORD *)&v138->AutoPilot.DrivingMode = v64;
            v138->m_nNoOfStaticFrames = 0;
            v138->AutoPilot.LastTimeNotStuck = v67 + 2000;
            v138->AutoPilot.LastTimeMoving = v67;
          }
        }
        if ( ((*((unsigned __int8 *)&ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&p_AutoPilot->OldNode][HIWORD(*(_DWORD *)&p_AutoPilot->OldNode)]
               + 26) << 16) & 0xF00000) == 9437184
          && v138->VehicleCreatedBy != 2 )
        {
          v138->AutoPilot.TempAction = 1;
          v68 = v138->m_info;
          v138->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 4500;
          if ( (*(_BYTE *)&v68 & 0xF8) == 16 )
            CAutoPilot::ModifySpeed(p_AutoPilot, 0.0);
        }
        InvertDirOldLink = v138->AutoPilot.InvertDirOldLink;
        v70 = v138->AutoPilot.NewLink.Address;
        InvertDirNewLink = v138->AutoPilot.InvertDirNewLink;
        v72 = v138->AutoPilot.NewLane;
        v73 = *(_QWORD *)&v138->AutoPilot.TimeToLeaveLink;
        v74 = v138->AutoPilot.NewNode.Region;
        v138->AutoPilot.VeryOldLink.Address = v138->AutoPilot.OldLink.Address;
        v138->AutoPilot.InvertDirVeryOldLink = InvertDirOldLink;
        v138->AutoPilot.OldLink.Address = v70;
        v138->AutoPilot.InvertDirOldLink = InvertDirNewLink;
        v138->AutoPilot.OldLane = v72;
        v138->AutoPilot.NewLink.Address = v29;
        v138->AutoPilot.TimeToLeaveLink = HIDWORD(v73) + v73;
        if ( v74 > Region || v74 == Region && v138->AutoPilot.NewNode.Index > v134 )
        {
          v75 = -1.0;
          v76 = v29 >> 10;
          v138->AutoPilot.InvertDirNewLink = -1;
          if ( ThePaths.pNodes[v29 >> 10] )
            v77 = (*(unsigned __int16 *)((char *)&ThePaths.pLinks[v76][v29 & 0x3FF] + 11) >> 3) & 7;
          else
            LOWORD(v77) = 1;
        }
        else
        {
          v75 = 1.0;
          v76 = v29 >> 10;
          LOWORD(v77) = 1;
          v138->AutoPilot.InvertDirNewLink = 1;
          if ( ThePaths.pNodes[v29 >> 10] )
            LOWORD(v77) = *(_WORD *)((char *)&ThePaths.pLinks[v76][v29 & 0x3FF] + 11) & 7;
        }
        v78 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&v138->AutoPilot.NewNode][HIWORD(*(_DWORD *)&v138->AutoPilot.NewNode)];
        v79 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&v138->AutoPilot.OldNode][HIWORD(*(_DWORD *)&v138->AutoPilot.OldNode)];
        CoorsX = v78->CoorsX;
        CoorsY = (float)v78->CoorsY;
        v82 = &ThePaths.pLinks[v76][v29 & 0x3FF];
        DirYb = (float)v82->DirYb;
        v84 = &ThePaths.pLinks[v70 >> 10][v70 & 0x3FF];
        v85 = (float)(CoorsY * 0.125) - (float)((float)v79->CoorsY * 0.125);
        DirXb = (float)v82->DirXb;
        v87 = (float)((float)CoorsX * 0.125) - (float)((float)v79->CoorsX * 0.125);
        v88 = (float)v84->DirYb;
        v89 = (float)v84->DirXb;
        v90 = (float)InvertDirNewLink;
        if ( (float)((float)(v87 * v87) + (float)(v85 * v85)) <= 256.0 )
        {
          LOBYTE(v92) = v72;
        }
        else
        {
          v91 = v138->AutoPilot.LaneChangeCounter - 1;
          v138->AutoPilot.LaneChangeCounter = v91;
          v32 = v91 == 0;
          LOBYTE(v92) = v72;
          if ( v32 )
          {
            v138->AutoPilot.LaneChangeCounter = rand() & 3 | 4;
            v93 = rand();
            v94 = v138->AutoPilot.NewLane;
            v95 = -1;
            if ( (v93 & 1) != 0 )
              v95 = 1;
            LOBYTE(v92) = v95 + v94;
            v138->AutoPilot.NewLane = v95 + v94;
          }
        }
        v96 = (unsigned __int16)v77 - 1;
        v92 = (char)v92;
        v97 = *(_WORD *)((char *)&v138->AutoPilot + 75);
        if ( v96 <= (char)v92 )
          v92 = (unsigned __int16)v77 - 1;
        v98 = 0;
        if ( v92 <= 0 )
          LOBYTE(v92) = 0;
        v138->AutoPilot.NewLane = v92;
        if ( (v97 & 8) == 0 )
        {
          if ( (v97 & 0x10) == 0 )
            goto LABEL_122;
          if ( v96 <= 0 )
            LOBYTE(v96) = 0;
          v98 = v96;
        }
        v138->AutoPilot.NewLane = v98;
LABEL_122:
        if ( (*(_BYTE *)&v138->m_info & 0xF8) == 16 )
        {
          OldLane = v138->AutoPilot.OldLane;
          v100 = (float)(DirXb * 0.01) * v75;
          v101 = (float)(DirYb * 0.01) * v75;
          v102 = (float)(v88 * 0.01) * v90;
          v103 = (float)(v89 * 0.01) * v90;
          v104 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[v138->AutoPilot.OldLink.Address >> 10][v138->AutoPilot.OldLink.Address & 0x3FF]);
          v105 = (float)OldLane;
          v106 = v138->AutoPilot.NewLane;
          v107 = v104 + v105;
          v108 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[v138->AutoPilot.NewLink.Address >> 10][v138->AutoPilot.NewLink.Address & 0x3FF]);
          v109 = v138->AutoPilot.OldLink.Address;
          ActualSpeed = v138->AutoPilot.ActualSpeed;
          v111 = ThePaths.pLinks[v109 >> 10];
          v112 = v109 & 0x3FF;
          v113 = &v111[v109 & 0x3FF];
          v114 = (float)((float)v113->CoorsY * 0.125) - (float)(v103 * (float)(v107 * 5.4));
          v115 = (float)(v102 * (float)(v107 * 5.4)) + (float)((float)v111[v112].CoorsX * 0.125);
          startCoors.z = 0.0;
          startCoors.y = v114;
          startCoors.x = v115;
          v116 = (float)(v108 + (float)v106) * 5.4;
          v117 = &ThePaths.pLinks[v138->AutoPilot.NewLink.Address >> 10][v138->AutoPilot.NewLink.Address & 0x3FF];
          v118 = (float)v117->CoorsY;
          v119 = (float)v117->CoorsX;
          endCoors.z = 0.0;
          endCoors.y = (float)(v118 * 0.125) - (float)(v100 * v116);
          endCoors.x = (float)(v101 * v116) + (float)(v119 * 0.125);
          v120 = (int)(float)((float)(1000.0 / ActualSpeed)
                            * CCurves::CalcSpeedScaleFactor(
                                &startCoors,
                                &endCoors,
                                (float)((float)v113->DirXb * 0.01) * (float)v138->AutoPilot.InvertDirOldLink,
                                (float)((float)v113->DirYb * 0.01) * (float)v138->AutoPilot.InvertDirOldLink,
                                (float)((float)v117->DirXb * 0.01) * (float)v138->AutoPilot.InvertDirNewLink,
                                (float)((float)v117->DirYb * 0.01) * (float)v138->AutoPilot.InvertDirNewLink));
          if ( v120 <= 10 )
            v120 = 10;
          v138->AutoPilot.TimeToGetToNextLink = v120;
        }
      }
    }
  }
}
// 2EAC84: conditional instruction was optimized away because %var_88.4 is in (1..F)
// 2EA918: conditional instruction was optimized away because %var_88.4 is in (1..F)
// 2EAAF2: conditional instruction was optimized away because %var_88.4 is in (1..F)

//----- (002EB480) --------------------------------------------------------
float __fastcall CCarCtrl::FindSpeedMultiplierWithSpeedFromNodes(Int8 SpeedFromNodes)
{
  unsigned int v1; // r0

  v1 = SpeedFromNodes + 1;
  if ( v1 <= 3 )
    return *(float *)&dword_2EB494[v1];
  else
    return 1.0;
}
// 2EB494: using guessed type int dword_2EB494[4];

//----- (002EB4A4) --------------------------------------------------------
int __fastcall CCarCtrl::CreatePoliceChase(CVehicle *pLeader, Int32 CarRating, CNodeAddress FromNode)
{
  int32 v6; // r0
  CVehicle *NewVehicleDependingOnCarModel; // r0
  int v8; // r5
  CPathNode *v9; // r0
  int CoorsX; // s4
  int CoorsZ; // s6
  float z; // s16
  __int16 *v13; // r5
  float m_fRadius; // s16
  int v16; // r1
  CMatrix *m_pMat; // r0
  UInt8 v18; // r4
  float xy; // s2
  float yy; // s0
  float zy; // s4
  float m_heading; // r10
  float v23; // r8
  float v24; // s6
  RwReal y; // r1
  int v26; // r3
  RwReal v27; // r0
  RwReal *v28; // r1
  char v29; // r1
  int v30; // r0
  __int64 v31; // d16
  CPed *pDriver; // r0
  int v33; // r2
  int v34; // r6
  int v35; // r3
  uint8 m_nMaxPassengers; // r0
  int v37; // r3
  CPed *v38; // r6
  int v39; // r6
  CTaskComplexCarDriveWander *v40; // r4
  __int16 *v41; // [sp+20h] [bp-88h]
  CEventAcquaintancePed v42; // [sp+24h] [bp-84h] BYREF
  Int16 pNum; // [sp+3Ah] [bp-6Eh] BYREF
  CEntity *refEntityPtr; // [sp+3Ch] [bp-6Ch] BYREF
  CColPoint colPoint; // [sp+40h] [bp-68h] BYREF
  CVector vecStart; // [sp+6Ch] [bp-3Ch] BYREF

  if ( (unsigned int)(CarRating - 14) >= 0xA
    && CPopCycle::m_NumGangs_Cars != 0.0
    && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 4.0) )
  {
    return 0;
  }
  v6 = CCarCtrl::ChoosePoliceCarModel(1u);
  if ( v6 < 0 || CStreaming::ms_aInfoForModel[v6].m_status != 1 )
    return 0;
  NewVehicleDependingOnCarModel = CCarCtrl::GetNewVehicleDependingOnCarModel(v6, 1u);
  v8 = 0;
  if ( NewVehicleDependingOnCarModel )
  {
    v41 = (__int16 *)NewVehicleDependingOnCarModel;
    v9 = &ThePaths.pNodes[FromNode.Region][HIWORD(*(unsigned int *)&FromNode)];
    CoorsX = v9->CoorsX;
    CoorsZ = v9->CoorsZ;
    vecStart.y = (float)v9->CoorsY * 0.125;
    vecStart.x = (float)CoorsX * 0.125;
    vecStart.z = (float)CoorsZ * 0.125;
    z = 1000000000.0;
    if ( CWorld::ProcessVerticalLine(&vecStart, 1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
      z = colPoint.m_vecPosition.z;
    if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    {
      v13 = v41;
      if ( fabsf(colPoint.m_vecPosition.z - vecStart.z) < fabsf(z - vecStart.z) )
        z = colPoint.m_vecPosition.z;
    }
    else
    {
      v13 = v41;
    }
    if ( z > 1000000000.0 )
      goto LABEL_19;
    vecStart.z = z + (*(float (__fastcall **)(__int16 *))(*(_DWORD *)v13 + 216))(v13);
    m_fRadius = CModelInfo::ms_modelInfoPtrs[v13[19]]->m_pColModel->m_sphereBound.m_fRadius;
    if ( !CEntity::GetIsOnScreen(pLeader) && CCamera::IsSphereVisible(&TheCamera, &vecStart, m_fRadius) )
    {
      pNum = 1;
LABEL_19:
      (*(void (__fastcall **)(__int16 *))(*(_DWORD *)v13 + 4))(v13);
      return 0;
    }
    CWorld::FindObjectsKindaColliding(&vecStart, m_fRadius, 1, &pNum, 2, 0, 0, 1, 1, 0, 0);
    if ( pNum )
      goto LABEL_19;
    v16 = *((_DWORD *)&pLeader->m_nVehicleFlags + 1);
    m_pMat = pLeader->m_pMat;
    pLeader->AutoPilot.DrivingMode = 2;
    v18 = pLeader->AutoPilot.CruiseSpeed + 10;
    pLeader->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&pLeader->m_info & 7 | 0x18);
    pLeader->AutoPilot.CruiseSpeed = v18;
    *((_DWORD *)&pLeader->m_nVehicleFlags + 1) = v16 | 0x80000;
    if ( m_pMat )
    {
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      zy = m_pMat->zy;
    }
    else
    {
      m_heading = pLeader->m_transform.m_heading;
      v23 = sinf(m_heading);
      yy = cosf(m_heading);
      zy = 0.0;
      LODWORD(xy) = LODWORD(v23) ^ 0x80000000;
    }
    v24 = (float)v18;
    pLeader->m_vecMoveSpeed.x = (float)(xy * v24) * 0.02;
    pLeader->m_vecMoveSpeed.y = (float)(yy * v24) * 0.02;
    pLeader->m_vecMoveSpeed.z = (float)(zy * v24) * 0.02;
    CCarCtrl::SetUpDriverAndPassengersForVehicle(pLeader, CarRating, 2, 1, 1, 99);
    CMatrix::operator=(*((CMatrix **)v13 + 5), pLeader->m_pMat);
    y = vecStart.y;
    v26 = *((_DWORD *)v13 + 5);
    v27 = vecStart.z;
    if ( v26 )
    {
      *(RwReal *)(v26 + 48) = vecStart.x;
      *(RwReal *)(*((_DWORD *)v13 + 5) + 52) = y;
      v28 = (RwReal *)(*((_DWORD *)v13 + 5) + 56);
    }
    else
    {
      *((_DWORD *)v13 + 1) = LODWORD(vecStart.x);
      *((RwReal *)v13 + 2) = y;
      v28 = (RwReal *)(v13 + 6);
    }
    *v28 = v27;
    v29 = *((_BYTE *)v13 + 58);
    v30 = *((_DWORD *)v13 + 268) | 1;
    v31 = *(_QWORD *)&pLeader->m_vecMoveSpeed.x;
    *((_DWORD *)v13 + 20) = LODWORD(pLeader->m_vecMoveSpeed.z);
    *((_DWORD *)v13 + 268) = v30;
    *((_BYTE *)v13 + 58) = v29 & 7 | 0x18;
    *((_QWORD *)v13 + 9) = v31;
    CVehicle::ChangeLawEnforcerState((CVehicle *)v13, 1u);
    CWorld::Add((CEntity *)v13);
    if ( *((_DWORD *)v13 + 360) == 9 )
      CBike::PlaceOnRoadProperly((CBike *)v13);
    else
      CAutomobile::PlaceOnRoadProperly((CAutomobile *)v13);
    CCarAI::AddPoliceCarOccupants((CVehicle *)v13, 1);
    pDriver = pLeader->pDriver;
    v33 = *((_DWORD *)&pDriver->m_nPedFlags + 1);
    v34 = *((_DWORD *)&pDriver->m_nPedFlags + 3) | 0x800;
    v35 = *((_DWORD *)&pDriver->m_nPedFlags + 2);
    *(_DWORD *)&pDriver->m_nPedFlags = pDriver->m_nPedFlags;
    *((_DWORD *)&pDriver->m_nPedFlags + 1) = v33;
    *((_DWORD *)&pDriver->m_nPedFlags + 2) = v35;
    *((_DWORD *)&pDriver->m_nPedFlags + 3) = v34;
    m_nMaxPassengers = pLeader->m_nMaxPassengers;
    if ( m_nMaxPassengers )
    {
      v37 = 0;
      do
      {
        v38 = pLeader->pPassengers[v37++];
        if ( v38 )
        {
          *((_DWORD *)&v38->m_nPedFlags + 3) |= 0x800u;
          m_nMaxPassengers = pLeader->m_nMaxPassengers;
        }
      }
      while ( v37 < m_nMaxPassengers );
    }
    v39 = *(_DWORD *)(*((_DWORD *)v13 + 281) + 1088);
    v40 = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
    CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(v40, (CVehicle *)v13, 0, 10.0);
    CTaskManager::SetTask((CTaskManager *)(v39 + 4), v40, 4, 0);
    CEventAcquaintancePed::CEventAcquaintancePed(&v42, pLeader->pDriver);
    v42.m_iTaskType = 1105;
    v42._vptr$CEvent = (int (**)(void))&off_665394;
    CEventGroup::Add((CEventGroup *)(*(_DWORD *)(*((_DWORD *)v13 + 281) + 1088) + 104), (CEvent *)&v42, 0);
    v13[600] = 255;
    *((_DWORD *)v13 + 268) |= 0x40u;
    CEventAcquaintancePed::~CEventAcquaintancePed(&v42);
    return 1;
  }
  return v8;
}
// 665394: using guessed type void *off_665394;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002EB8DC) --------------------------------------------------------
bool __fastcall CCarCtrl::CreateConvoy(CVehicle *pLeader, Int32 CarRating)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d11
  int v5; // r6
  float v6; // s0
  int16 m_nModelIndex; // r0
  int v8; // r5
  CVehicle *v9; // r4
  float m_fRadius; // s16
  float v11; // s18
  CVehicle *NewVehicleDependingOnCarModel; // r8
  float v13; // s0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v16; // s4
  float z; // s10
  float v18; // s2
  float v19; // s0
  float x; // s6
  float v21; // s26
  int v22; // r1
  CMatrix *v23; // r6
  float xy; // s2
  float yy; // s0
  float zy; // s4
  float m_heading; // r5
  float v28; // r10
  float CruiseSpeed; // s6
  RwReal y; // r1
  CMatrix *v31; // r3
  RwReal v32; // r0
  RwReal *p_tz; // r1
  int v34; // r2
  __int64 v35; // d16
  int v36; // r1
  CEntity::CEntityInfo m_info; // r3
  CEntity::CEntityInfo v38; // r0
  int32 m_baseVehicleType; // r0
  CPedIntelligence *m_pPedIntelligence; // r9
  CTaskComplexCarDriveWander *v41; // r6
  UInt16 ForcedRandomSeed; // r0
  int v45; // [sp+2Ch] [bp-A4h]
  int v46; // [sp+30h] [bp-A0h]
  int v47; // [sp+34h] [bp-9Ch]
  int v48; // [sp+38h] [bp-98h]
  Int16 pNum; // [sp+42h] [bp-8Eh] BYREF
  CEntity *refEntityPtr; // [sp+44h] [bp-8Ch] BYREF
  CColPoint colPoint; // [sp+48h] [bp-88h] BYREF
  CVector vecStart; // [sp+74h] [bp-5Ch] BYREF

  v5 = 3;
  v6 = (float)(unsigned __int16)rand();
  m_nModelIndex = pLeader->m_nModelIndex;
  v8 = 0;
  v9 = pLeader;
  v3.n64_u32[0] = 0;
  m_fRadius = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
  v11 = (float)(m_fRadius + m_fRadius) + 2.5;
  pLeader->ForcedRandomSeed = pLeader->RandomSeed;
  if ( (int)(float)((float)(v6 * 0.000015259) * 100.0) < 51 )
    v5 = 2;
  v47 = v5;
  v45 = 0;
  while ( 1 )
  {
    NewVehicleDependingOnCarModel = CCarCtrl::GetNewVehicleDependingOnCarModel(m_nModelIndex, 1u);
    if ( NewVehicleDependingOnCarModel )
      break;
    v22 = v8 + 1;
    NewVehicleDependingOnCarModel = v9;
    if ( v8 + 1 >= v5 )
      return v45 & 1;
LABEL_4:
    m_nModelIndex = pLeader->m_nModelIndex;
    v8 = v22;
    v9 = NewVehicleDependingOnCarModel;
  }
  v46 = v8;
  v48 = v8 + 1;
  v13 = (float)(v8 + 1);
  m_pMat = pLeader->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pLeader->m_transform;
  v16 = m_pMat->yy * v13;
  z = p_tx->m_translate.z;
  v18 = m_pMat->xy * v13;
  v19 = m_pMat->zy * v13;
  x = p_tx->m_translate.x;
  vecStart.y = p_tx->m_translate.y - (float)(v11 * v16);
  vecStart.x = x - (float)(v11 * v18);
  vecStart.z = z - (float)(v11 * v19);
  v21 = 1000000000.0;
  if ( CWorld::ProcessVerticalLine(&vecStart, 1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    v21 = colPoint.m_vecPosition.z;
  if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
  {
    v5 = v47;
    if ( fabsf(colPoint.m_vecPosition.z - vecStart.z) < fabsf(v21 - vecStart.z) )
      v21 = colPoint.m_vecPosition.z;
  }
  else
  {
    v5 = v47;
  }
  if ( v21 > 1000000000.0
    || (vecStart.z = v21
                   + (*((float (__fastcall **)(CVehicle *))NewVehicleDependingOnCarModel->_vptr$CPlaceable + 54))(NewVehicleDependingOnCarModel),
        CWorld::FindObjectsKindaColliding(&vecStart, m_fRadius, 1, &pNum, 2, 0, 0, 1, 1, 0, 0),
        pNum) )
  {
    (*((void (__fastcall **)(CVehicle *))NewVehicleDependingOnCarModel->_vptr$CPlaceable + 1))(NewVehicleDependingOnCarModel);
    NewVehicleDependingOnCarModel = v9;
  }
  else
  {
    if ( v45 << 31 )
    {
      v23 = pLeader->m_pMat;
    }
    else
    {
      pLeader->AutoPilot.DrivingMode = 2;
      v23 = pLeader->m_pMat;
      pLeader->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&pLeader->m_info & 7 | 0x18);
      if ( v23 )
      {
        xy = v23->xy;
        yy = v23->yy;
        zy = v23->zy;
      }
      else
      {
        m_heading = pLeader->m_transform.m_heading;
        v28 = sinf(m_heading);
        zy = 0.0;
        yy = cosf(m_heading);
        LODWORD(xy) = LODWORD(v28) ^ 0x80000000;
      }
      CruiseSpeed = (float)pLeader->AutoPilot.CruiseSpeed;
      pLeader->m_vecMoveSpeed.x = (float)(xy * CruiseSpeed) * 0.02;
      pLeader->m_vecMoveSpeed.y = (float)(yy * CruiseSpeed) * 0.02;
      pLeader->m_vecMoveSpeed.z = (float)(zy * CruiseSpeed) * 0.02;
    }
    CMatrix::operator=(NewVehicleDependingOnCarModel->m_pMat, v23);
    y = vecStart.y;
    v31 = NewVehicleDependingOnCarModel->m_pMat;
    v32 = vecStart.z;
    if ( v31 )
    {
      v31->tx = vecStart.x;
      NewVehicleDependingOnCarModel->m_pMat->ty = y;
      p_tz = &NewVehicleDependingOnCarModel->m_pMat->tz;
    }
    else
    {
      NewVehicleDependingOnCarModel->m_transform.m_translate.x = vecStart.x;
      NewVehicleDependingOnCarModel->m_transform.m_translate.y = y;
      p_tz = &NewVehicleDependingOnCarModel->m_transform.m_translate.z;
    }
    *p_tz = v32;
    v34 = *((_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags + 1);
    v35 = *(_QWORD *)&pLeader->m_vecMoveSpeed.x;
    v36 = *(_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags | 0x8000000;
    m_info = NewVehicleDependingOnCarModel->m_info;
    NewVehicleDependingOnCarModel->m_vecMoveSpeed.z = pLeader->m_vecMoveSpeed.z;
    *(_QWORD *)&NewVehicleDependingOnCarModel->m_vecMoveSpeed.x = v35;
    v38 = pLeader->m_info;
    *(_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags = v36;
    *((_DWORD *)&NewVehicleDependingOnCarModel->m_nVehicleFlags + 1) = v34;
    NewVehicleDependingOnCarModel->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v38 & 0xF8 | *(_BYTE *)&m_info & 7);
    CWorld::Add(NewVehicleDependingOnCarModel);
    m_baseVehicleType = NewVehicleDependingOnCarModel->m_baseVehicleType;
    if ( m_baseVehicleType )
    {
      if ( m_baseVehicleType == 9 )
        CBike::PlaceOnRoadProperly((CBike *)NewVehicleDependingOnCarModel);
    }
    else
    {
      CAutomobile::PlaceOnRoadProperly((CAutomobile *)NewVehicleDependingOnCarModel);
    }
    v45 = 1;
    CCarCtrl::SetUpDriverAndPassengersForVehicle(NewVehicleDependingOnCarModel, CarRating, 0, 1, 0, 99);
    m_pPedIntelligence = NewVehicleDependingOnCarModel->pDriver->m_pPedIntelligence;
    v41 = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
    CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(v41, NewVehicleDependingOnCarModel, 0, 10.0);
    CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v41, 4, 0);
    NewVehicleDependingOnCarModel->AutoPilot.CruiseSpeed = pLeader->AutoPilot.CruiseSpeed;
    v2.n64_f32[0] = pLeader->AutoPilot.ActualSpeed - (float)v46;
    v2.n64_u64[0] = vmax_f32(v2, v3).n64_u64[0];
    LODWORD(NewVehicleDependingOnCarModel->AutoPilot.ActualSpeed) = v2.n64_u32[0];
    NewVehicleDependingOnCarModel->AutoPilot.DrivingMode = pLeader->AutoPilot.DrivingMode;
    NewVehicleDependingOnCarModel->AutoPilot.Mission = pLeader->AutoPilot.Mission;
    NewVehicleDependingOnCarModel->RandomSeed = pLeader->RandomSeed;
    ForcedRandomSeed = pLeader->ForcedRandomSeed;
    NewVehicleDependingOnCarModel->AutoPilot.pTargetEntity = v9;
    NewVehicleDependingOnCarModel->ForcedRandomSeed = ForcedRandomSeed;
    CEntity::RegisterReference(v9, &NewVehicleDependingOnCarModel->AutoPilot.pTargetEntity);
    v5 = v47;
  }
  v22 = v48;
  if ( v48 < v5 )
    goto LABEL_4;
  return v45 & 1;
}
// 2EBC68: variable 'v2' is possibly undefined
// 2EBC68: variable 'v3' is possibly undefined

//----- (002EBCCC) --------------------------------------------------------
void __fastcall CCarCtrl::SetUpDriverAndPassengersForVehicle(
        CVehicle *pNewVehicle,
        Int32 CarRating,
        Int32 MinPassengers,
        bool bMustBeMale,
        int bCriminal,
        Int32 MaxPassengers)
{
  int m_nMaxPassengers; // r6
  Int32 v11; // r5
  int m_nModelIndex; // r4
  int32 AnimationBlockIndex; // r5
  int v14; // r0
  int v15; // r1
  int32 i; // r4
  CPed *v17; // r0
  CPed *v18; // r5

  CVehicle::SetUpDriver(pNewVehicle, CarRating, bMustBeMale, bCriminal);
  m_nMaxPassengers = MaxPassengers;
  if ( (unsigned int)(CarRating - 14) <= 9 && (rand() & 1) != 0 )
    CPed::GiveObjectToPedToHold(pNewVehicle->pDriver, MI_GANG_SMOKE, 1u);
  if ( pNewVehicle->m_nMaxPassengers < MaxPassengers )
    m_nMaxPassengers = pNewVehicle->m_nMaxPassengers;
  if ( m_nMaxPassengers <= MinPassengers )
  {
    v11 = MinPassengers;
  }
  else
  {
    v11 = MinPassengers;
    do
    {
      ++MinPassengers;
      if ( (float)((float)((float)rand() * 4.6566e-10) + 0.0) < 0.125 )
        ++v11;
    }
    while ( MinPassengers < m_nMaxPassengers );
  }
  m_nModelIndex = pNewVehicle->m_nModelIndex;
  if ( v11 < m_nMaxPassengers )
    m_nMaxPassengers = v11;
  if ( CModelInfo::IsCarModel(pNewVehicle->m_nModelIndex) )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)&dword_2EBDF8);
    v14 = (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->_vptr$CBaseModelInfo
           + 15))(CModelInfo::ms_modelInfoPtrs[m_nModelIndex]);
    v15 = m_nMaxPassengers;
    if ( m_nMaxPassengers >= 1 )
      v15 = 1;
    if ( v14 == AnimationBlockIndex )
      m_nMaxPassengers = v15;
  }
  if ( m_nMaxPassengers >= 1 )
  {
    for ( i = 0; i != m_nMaxPassengers; ++i )
    {
      v17 = CVehicle::SetupPassenger(pNewVehicle, i, CarRating, bMustBeMale, bCriminal);
      v18 = v17;
      if ( v17 )
      {
        CPed::UpdateStatEnteringVehicle(v17);
        if ( (unsigned int)(CarRating - 14) <= 9 && (rand() & 1) != 0 )
          CPed::GiveObjectToPedToHold(v18, MI_GANG_SMOKE, 1u);
      }
    }
  }
}
// 2EBDF8: using guessed type int dword_2EBDF8;
// 679000: using guessed type __int16 *MI_GANG_SMOKE_ptr;

//----- (002EBE04) --------------------------------------------------------
CVehicle *__fastcall CCarCtrl::CreateCarForScript(Int32 ModelIndex, CVector vecPosition, int bAddToMissionCleanup)
{
  float y; // r8
  float x; // r6
  float z; // s16
  char *NewVehicleDependingOnCarModel; // r4
  float v8; // s0
  int v9; // r0
  float *v10; // r0
  float v11; // s0
  int v12; // r0
  float *v13; // r0
  char v14; // r2
  int v15; // r1
  int v16; // r0
  char v17; // r1
  int v18; // r1
  unsigned int v19; // r0
  CVector Coors; // [sp+4h] [bp-2Ch] BYREF

  y = vecPosition.y;
  x = vecPosition.x;
  Coors = vecPosition;
  z = vecPosition.z;
  if ( CModelInfo::IsBoatModel(ModelIndex) )
  {
    NewVehicleDependingOnCarModel = (char *)CVehicle::operator new(0x7FCu);
    CBoat::CBoat((CBoat *)NewVehicleDependingOnCarModel, ModelIndex, 2u);
    if ( z <= -100.0 )
    {
      z = CWorld::FindGroundZForCoord(x, y);
      Coors.z = z;
    }
    v8 = CEntity::GetDistanceFromCentreOfMassToBaseOfModel((CEntity *)NewVehicleDependingOnCarModel) + z;
    Coors.z = v8;
    v9 = *((_DWORD *)NewVehicleDependingOnCarModel + 5);
    if ( v9 )
    {
      *(float *)(v9 + 48) = x;
      *(float *)(*((_DWORD *)NewVehicleDependingOnCarModel + 5) + 52) = y;
      v10 = (float *)(*((_DWORD *)NewVehicleDependingOnCarModel + 5) + 56);
    }
    else
    {
      v10 = (float *)(NewVehicleDependingOnCarModel + 12);
      *((float *)NewVehicleDependingOnCarModel + 1) = x;
      *((float *)NewVehicleDependingOnCarModel + 2) = y;
    }
    *v10 = v8;
    CTheScripts::ClearSpaceForMissionEntity(&Coors, (CEntity *)NewVehicleDependingOnCarModel);
    v14 = NewVehicleDependingOnCarModel[58];
    *((_DWORD *)NewVehicleDependingOnCarModel + 267) = *((_DWORD *)NewVehicleDependingOnCarModel + 267) & 0xFFFFFFE7 | 8;
    NewVehicleDependingOnCarModel[58] = v14 & 7 | 0x20;
    CCarCtrl::JoinCarWithRoadSystem((CVehicle *)NewVehicleDependingOnCarModel);
    *((_DWORD *)NewVehicleDependingOnCarModel + 243) = 1101004800;
    *((_WORD *)NewVehicleDependingOnCarModel + 479) = 0;
    NewVehicleDependingOnCarModel[980] = 20;
    if ( bAddToMissionCleanup )
    {
      v15 = *((_DWORD *)NewVehicleDependingOnCarModel + 7);
      *(_WORD *)(NewVehicleDependingOnCarModel + 991) |= 0x100u;
      *((_DWORD *)NewVehicleDependingOnCarModel + 7) = v15 | 0x40000;
      CWorld::Add((CEntity *)NewVehicleDependingOnCarModel);
      CMissionCleanup::AddEntityToList(
        &CTheScripts::MissionCleanUp,
        CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                        * ((NewVehicleDependingOnCarModel - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * ((NewVehicleDependingOnCarModel - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)),
        1u);
    }
    else
    {
      *(_WORD *)(NewVehicleDependingOnCarModel + 991) |= 0x100u;
      CWorld::Add((CEntity *)NewVehicleDependingOnCarModel);
    }
    return (CVehicle *)NewVehicleDependingOnCarModel;
  }
  NewVehicleDependingOnCarModel = (char *)CCarCtrl::GetNewVehicleDependingOnCarModel(ModelIndex, 2u);
  if ( z <= -100.0 )
  {
    z = CWorld::FindGroundZForCoord(x, y);
    Coors.z = z;
  }
  v11 = CEntity::GetDistanceFromCentreOfMassToBaseOfModel((CEntity *)NewVehicleDependingOnCarModel) + z;
  Coors.z = v11;
  v12 = *((_DWORD *)NewVehicleDependingOnCarModel + 5);
  if ( v12 )
  {
    *(float *)(v12 + 48) = x;
    *(float *)(*((_DWORD *)NewVehicleDependingOnCarModel + 5) + 52) = y;
    v13 = (float *)(*((_DWORD *)NewVehicleDependingOnCarModel + 5) + 56);
  }
  else
  {
    v13 = (float *)(NewVehicleDependingOnCarModel + 12);
    *((float *)NewVehicleDependingOnCarModel + 1) = x;
    *((float *)NewVehicleDependingOnCarModel + 2) = y;
  }
  *v13 = v11;
  if ( !bAddToMissionCleanup )
  {
    v16 = *((_DWORD *)NewVehicleDependingOnCarModel + 360);
    if ( v16 == 9 )
    {
      CBike::PlaceOnRoadProperly((CBike *)NewVehicleDependingOnCarModel);
    }
    else
    {
      if ( v16 )
        goto LABEL_17;
      CAutomobile::PlaceOnRoadProperly((CAutomobile *)NewVehicleDependingOnCarModel);
    }
  }
  v16 = *((_DWORD *)NewVehicleDependingOnCarModel + 360);
LABEL_17:
  if ( v16 == 6 )
    *((_WORD *)NewVehicleDependingOnCarModel + 742) |= 0x100u;
  CTheScripts::ClearSpaceForMissionEntity(&Coors, (CEntity *)NewVehicleDependingOnCarModel);
  v17 = NewVehicleDependingOnCarModel[58];
  *((_DWORD *)NewVehicleDependingOnCarModel + 267) |= 8u;
  NewVehicleDependingOnCarModel[58] = v17 & 7 | 0x20;
  CCarCtrl::JoinCarWithRoadSystem((CVehicle *)NewVehicleDependingOnCarModel);
  NewVehicleDependingOnCarModel[959] = 0;
  *((_DWORD *)NewVehicleDependingOnCarModel + 243) = 1095761920;
  NewVehicleDependingOnCarModel[980] = 13;
  v18 = *((_DWORD *)NewVehicleDependingOnCarModel + 267);
  *(_DWORD *)(NewVehicleDependingOnCarModel + 955) = 0;
  *((_DWORD *)NewVehicleDependingOnCarModel + 267) = v18 & 0xFFFDFFEF | 0x20000;
  if ( bAddToMissionCleanup )
  {
    *((_DWORD *)NewVehicleDependingOnCarModel + 7) |= 0x40000u;
    CWorld::Add((CEntity *)NewVehicleDependingOnCarModel);
    CMissionCleanup::AddEntityToList(
      &CTheScripts::MissionCleanUp,
      CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                      * ((NewVehicleDependingOnCarModel - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * ((NewVehicleDependingOnCarModel - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)),
      1u);
  }
  else
  {
    CWorld::Add((CEntity *)NewVehicleDependingOnCarModel);
  }
  v19 = *((_DWORD *)NewVehicleDependingOnCarModel + 361);
  if ( v19 > 6 || ((1 << v19) & 0x58) == 0 )
    *(_WORD *)(NewVehicleDependingOnCarModel + 991) |= 0x100u;
  return (CVehicle *)NewVehicleDependingOnCarModel;
}

//----- (002EC0A4) --------------------------------------------------------
void __fastcall CCarCtrl::JoinCarWithRoadSystem(CVehicle *pVehicle)
{
  unsigned int v1; // r8
  __int128 v2; // q8
  int16x4_t v3; // d18
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r3
  unsigned int NodeClosestToCoorsFavourDirection; // r0
  char *v8; // r2
  int v9; // r3
  bool v10; // zf
  _DWORD *v11; // r10
  int v12; // r4
  float v13; // s0
  UInt16 Region; // r9
  int v15; // r1
  CNodeAddress v16; // r4
  CPathNode *v17; // r12
  unsigned __int64 v18; // d1
  float v19; // s2
  float32x2_t v20; // d0
  float xy; // s4
  float32x2_t v22; // d16
  unsigned __int64 v23; // d0
  UInt16 v24; // r2

  pVehicle->AutoPilot.OldLink.Address = -1;
  pVehicle->AutoPilot.NewNode.Region = -1;
  pVehicle->AutoPilot.VeryOldLink.Address = -1;
  pVehicle->AutoPilot.NewLink.Address = -1;
  m_pMat = pVehicle->m_pMat;
  pVehicle->AutoPilot.NumPathNodes = 0;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  pVehicle->AutoPilot.OldNode.Region = -1;
  pVehicle->AutoPilot.VeryOldNode.Region = -1;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  NodeClosestToCoorsFavourDirection = (unsigned int)CPathFind::FindNodeClosestToCoorsFavourDirection(
                                                      &ThePaths,
                                                      p_tx->m_translate,
                                                      0,
                                                      m_pMat->xy,
                                                      m_pMat->yy);
  if ( (unsigned __int16)NodeClosestToCoorsFavourDirection != 0xFFFF )
  {
    v8 = (char *)&ThePaths + 4 * (unsigned __int16)NodeClosestToCoorsFavourDirection;
    v9 = *((_DWORD *)v8 + 513);
    v10 = v9 == 0;
    if ( v9 )
    {
      v8 = (char *)(v9 + 28 * HIWORD(NodeClosestToCoorsFavourDirection));
      v9 = *((_WORD *)v8 + 12) & 0xF;
      v10 = v9 == 0;
    }
    if ( !v10 )
    {
      v11 = v8 + 8;
      DWORD1(v2) = 1040187392;
      v12 = 0;
      v13 = 1000000.0;
      Region = -1;
      v15 = 0;
      do
      {
        v16 = ThePaths.pAdjacentNodes[(unsigned __int16)NodeClosestToCoorsFavourDirection][v12 + *((__int16 *)v8 + 8)];
        v17 = ThePaths.pNodes[v16.Region];
        if ( v17 )
        {
          DWORD2(v2) = *v11;
          v3.n64_u32[0] = *(_DWORD *)&v17[HIWORD(*(unsigned int *)&v16)].CoorsX;
          v3.n64_u64[0] = vmul_f32(
                            vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                            (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
          *((float32x2_t *)&v2 + 1) = vsub_f32(
                                        v3,
                                        vmul_f32(
                                          vcvt_f32_s32((int32x2_t)vmovl_s16(*((int16x4_t *)&v2 + 1)).n128_u64[0]),
                                          (float32x2_t)0x3E0000003E000000LL));
          v18 = vmul_f32(*((float32x2_t *)&v2 + 1), *((float32x2_t *)&v2 + 1)).n64_u64[0];
          v19 = sqrtf(*(float *)&v18 + *((float *)&v18 + 1));
          if ( v19 < v13 )
          {
            Region = v16.Region;
            v1 = HIWORD(*(unsigned int *)&v16);
            v13 = v19;
          }
        }
        v12 = (__int16)++v15;
      }
      while ( (__int16)v15 < v9 );
      if ( Region != 0xFFFF )
      {
        LODWORD(v2) = *v11;
        DWORD2(v2) = *(_DWORD *)&ThePaths.pNodes[Region][(unsigned __int16)v1].CoorsX;
        v20.n64_u64[0] = *(unsigned __int64 *)&pVehicle->m_pMat->xy;
        xy = pVehicle->m_pMat->xy;
        v22.n64_u64[0] = vsub_f32(
                           vmul_f32(
                             vcvt_f32_s32((int32x2_t)vmovl_s16(*(int16x4_t *)&v2).n128_u64[0]),
                             (float32x2_t)0x3E0000003E000000LL),
                           vmul_f32(
                             vcvt_f32_s32((int32x2_t)vmovl_s16(*((int16x4_t *)&v2 + 1)).n128_u64[0]),
                             (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
        if ( v20.n64_f32[1] == 0.0 )
          xy = 1.0;
        if ( v20.n64_f32[0] == 0.0 )
          v20.n64_f32[0] = xy;
        v23 = vmul_f32(v20, v22).n64_u64[0];
        if ( (float)(*(float *)&v23 + *((float *)&v23 + 1)) >= 0.0 )
        {
          v24 = NodeClosestToCoorsFavourDirection;
        }
        else
        {
          v24 = Region;
          Region = NodeClosestToCoorsFavourDirection;
        }
        pVehicle->AutoPilot.OldNode = (CNodeAddress)Region;
        pVehicle->AutoPilot.VeryOldNode.Region = -1;
        pVehicle->AutoPilot.NewNode = (CNodeAddress)v24;
        CCarCtrl::FindLinksToGoWithTheseNodes(pVehicle);
        *(_WORD *)&pVehicle->AutoPilot.OldLane = 0;
      }
    }
  }
}
// 2EC198: variable 'v3' is possibly undefined
// 2EC186: variable 'v2' is possibly undefined
// 2EC1E4: variable 'v1' is possibly undefined

//----- (002EC2B8) --------------------------------------------------------
void __fastcall CCarCtrl::SetCoordsOfScriptCar(
        CVehicle *pVehicle,
        float NewX,
        float NewY,
        float NewZ,
        int bClearCarOrientation,
        int bAddOffset)
{
  float GroundZForCoord; // s20
  int v11; // r8
  int32 m_baseVehicleType; // r5
  int32 v13; // r0
  CVector Coors; // [sp+4h] [bp-44h] BYREF

  GroundZForCoord = NewZ;
  v11 = CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                        * (((char *)pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * (((char *)pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2));
  if ( NewZ <= -100.0 )
    GroundZForCoord = CWorld::FindGroundZForCoord(NewX, NewY);
  if ( bAddOffset )
    GroundZForCoord = GroundZForCoord + CEntity::GetDistanceFromCentreOfMassToBaseOfModel(pVehicle);
  (*((void (__fastcall **)(CVehicle *, _DWORD))pVehicle->_vptr$CPlaceable + 5))(pVehicle, 0);
  CStuckCarCheck::ClearStuckFlagForCar(&CTheScripts::StuckCars, v11);
  m_baseVehicleType = pVehicle->m_baseVehicleType;
  (*((void (__fastcall **)(CVehicle *, _DWORD, _DWORD, float, int))pVehicle->_vptr$CPlaceable + 15))(
    pVehicle,
    LODWORD(NewX),
    LODWORD(NewY),
    COERCE_FLOAT(LODWORD(GroundZForCoord)),
    bClearCarOrientation);
  if ( m_baseVehicleType != 5 )
  {
    v13 = pVehicle->m_baseVehicleType;
    switch ( v13 )
    {
      case 11:
        goto LABEL_10;
      case 9:
        CBike::PlaceOnRoadProperly((CBike *)pVehicle);
        break;
      case 0:
LABEL_10:
        CAutomobile::PlaceOnRoadProperly((CAutomobile *)pVehicle);
        break;
    }
    Coors.y = NewY;
    Coors.x = NewX;
    Coors.z = GroundZForCoord;
    CTheScripts::ClearSpaceForMissionEntity(&Coors, pVehicle);
    CCarCtrl::JoinCarWithRoadAccordingToMission(pVehicle);
    goto LABEL_13;
  }
  Coors.y = NewY;
  Coors.x = NewX;
  Coors.z = GroundZForCoord;
  CTheScripts::ClearSpaceForMissionEntity(&Coors, pVehicle);
LABEL_13:
  pVehicle->AutoPilot.TempAction = 0;
}

//----- (002EC3D0) --------------------------------------------------------
void __fastcall CCarCtrl::JoinCarWithRoadAccordingToMission(CVehicle *pVehicle)
{
  CEntity *pTargetEntity; // r0
  CMatrix *m_pMat; // r2
  CVector *p_TargetCoors; // r1
  bool v5; // zf
  bool v6; // r3
  CVehicle *v7; // r0
  CVector v8; // [sp+4h] [bp-14h] BYREF

  switch ( pVehicle->AutoPilot.Mission )
  {
    case 0:
    case 1:
    case 7:
    case 0xA:
    case 0xB:
    case 0x22:
    case 0x2D:
    case 0x2E:
    case 0x31:
    case 0x32:
      CCarCtrl::JoinCarWithRoadSystem(pVehicle);
      return;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 0x15:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x2B:
    case 0x2C:
    case 0x40:
      FindPlayerCoors(&v8, -1);
      v6 = 0;
      p_TargetCoors = &v8;
      v7 = pVehicle;
      if ( pVehicle->m_vehicleType == 5 )
        v6 = 1;
      goto LABEL_14;
    case 8:
    case 9:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x21:
      v6 = 0;
      p_TargetCoors = &pVehicle->AutoPilot.TargetCoors;
      v5 = pVehicle->m_vehicleType == 5;
      goto LABEL_11;
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x3C:
    case 0x3D:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
      pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
      if ( !pTargetEntity )
        return;
      m_pMat = pTargetEntity->m_pMat;
      p_TargetCoors = (CVector *)&m_pMat->tx;
      if ( !m_pMat )
        p_TargetCoors = &pTargetEntity->m_transform.m_translate;
      v5 = pVehicle->m_vehicleType == 5;
      v6 = 0;
LABEL_11:
      if ( v5 )
        v6 = 1;
      v7 = pVehicle;
LABEL_14:
      CCarCtrl::JoinCarWithRoadSystemGotoCoors(v7, p_TargetCoors, 0, v6);
      return;
    default:
      return;
  }
}

//----- (002EC490) --------------------------------------------------------
int32 __fastcall CCarCtrl::ChooseCarModelToLoad(int32 CarGroup)
{
  int v2; // r5
  UInt16 *v3; // r10
  int v4; // r6
  int32 result; // r0

  v2 = -1;
  v3 = CPopulation::m_CarGroups[CarGroup];
  while ( 1 )
  {
    v4 = CPopulation::m_nNumCarsInGroup[CarGroup];
    result = v3[(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v4)];
    if ( CStreaming::ms_aInfoForModel[result].m_status != 1 )
      break;
    if ( ++v2 > 14 )
      return -1;
  }
  return result;
}

//----- (002EC524) --------------------------------------------------------
void CCarCtrl::RemoveDistantCars()
{
  CVehiclePool *v0; // r8
  int32 m_nSize; // r0
  int v2; // r5
  int v3; // r6
  uint8 *v4; // r11
  float32x2_t *v5; // r4
  float32x2_t *PlayerCentreOfWorld; // r0
  float32x2_t *v7; // r1
  float32x2_t v8; // d16
  unsigned __int64 v9; // d0
  ePedType v10; // r2

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = m_nSize;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        v4 = v0->m_aStorage[v3];
        if ( v4 != (uint8 *)&elf_hash_bucket[588] )
        {
          CCarCtrl::PossiblyRemoveVehicle((CVehicle *)(v4 - 2604));
          if ( (*(v4 - 1534) & 0x10) != 0 )
          {
            v5 = (float32x2_t *)(v4 - 2600);
            PlayerCentreOfWorld = (float32x2_t *)FindPlayerCentreOfWorld(CWorld::PlayerInFocus);
            v7 = (float32x2_t *)*((_DWORD *)v4 - 646);
            if ( v7 )
              v5 = v7 + 6;
            v8.n64_u64[0] = vsub_f32((float32x2_t)v5->n64_u64[0], (float32x2_t)PlayerCentreOfWorld->n64_u64[0]).n64_u64[0];
            v9 = vmul_f32(v8, v8).n64_u64[0];
            if ( sqrtf(*(float *)&v9 + *((float *)&v9 + 1)) < 75.5 )
            {
              if ( CVehicle::IsLawEnforcementVehicle((const CVehicle *)(v4 - 2604)) )
                v10 = PEDTYPE_COP;
              else
                v10 = PEDTYPE_GANG1;
              CRoadBlocks::GenerateRoadBlockPedsForCar((CVehicle *)(v4 - 2604), *(v4 - 1397), v10);
              *((_DWORD *)v4 - 384) &= ~0x100000u;
            }
          }
        }
      }
      --v2;
      --v3;
    }
    while ( v2 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002EC620) --------------------------------------------------------
void __fastcall CCarCtrl::PossiblyRemoveVehicle(CVehicle *pVehicle)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float x; // s16
  float y; // s18
  float z; // s20
  int m_nVehicleFlags; // r0
  bool v8; // zf
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r5
  const CVector *PlayerCentreOfWorld; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r0
  float v14; // s22
  int LookDirection; // r0
  bool v16; // zf
  int m_nModelIndex; // r0
  bool v18; // zf
  float v19; // s0
  float v20; // s2
  CMatrix *v21; // r0
  __int64 v22; // d16
  unsigned int m_info; // r0
  bool v24; // zf
  unsigned int v25; // r0
  CMatrix *v26; // r0
  CSimpleTransform *v27; // r6
  CSimpleTransform *v28; // r1
  bool v29; // zf
  CMatrix *v30; // r0
  __int64 v31; // d16
  uint32 m_nTimeOfDeath; // r0
  uint32 v33; // r0
  bool v34; // cc
  CMatrix *v35; // r1
  CSimpleTransform *v36; // r0
  __int64 v37; // d16
  bool v38; // zf
  CVector v40[5]; // [sp+0h] [bp-40h] BYREF

  if ( !pVehicle->m_nNumGettingIn )
  {
    m_nVehicleFlags = (int)pVehicle->m_nVehicleFlags;
    v8 = (m_nVehicleFlags & 0x8000000) == 0;
    if ( (m_nVehicleFlags & 0x8000000) != 0 )
      v8 = pVehicle->AutoPilot.pTargetEntity == 0;
    if ( v8 )
    {
      p_m_nVehicleFlags = &pVehicle->m_nVehicleFlags;
      if ( (m_nVehicleFlags & 8) == 0
        && CVehicle::CanBeDeleted(pVehicle)
        && !CCranes::IsThisCarBeingTargettedByAnyCrane(pVehicle) )
      {
        if ( (*((_BYTE *)&pVehicle->m_nVehicleFlags + 2) & 4) != 0
          && !CVisibilityPlugins::GetClumpAlpha((RpClump_0 *)pVehicle->m_pRwObject) )
        {
          goto LABEL_83;
        }
        PlayerCentreOfWorld = FindPlayerCentreOfWorld(CWorld::PlayerInFocus);
        m_pMat = pVehicle->m_pMat;
        p_m_transform = &pVehicle->m_transform;
        x = PlayerCentreOfWorld->x;
        y = PlayerCentreOfWorld->y;
        z = PlayerCentreOfWorld->z;
        p_tx = &pVehicle->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        v14 = sqrtf(
                (float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
              + (float)((float)(p_tx->m_translate.y - y) * (float)(p_tx->m_translate.y - y)));
        if ( CEntity::GetIsOnScreen(pVehicle)
          || TheCamera.Cams[TheCamera.ActiveCam].LookingLeft
          || TheCamera.Cams[TheCamera.ActiveCam].LookingRight
          || TheCamera.Cams[TheCamera.ActiveCam].LookingBehind )
        {
          goto LABEL_25;
        }
        LookDirection = CCamera::GetLookDirection(&TheCamera);
        v16 = LookDirection == 0;
        if ( LookDirection )
          v16 = pVehicle->VehicleCreatedBy == 3;
        if ( v16 )
          goto LABEL_25;
        m_nModelIndex = pVehicle->m_nModelIndex;
        v18 = m_nModelIndex == 407;
        if ( m_nModelIndex != 407 )
          v18 = m_nModelIndex == 416;
        if ( v18
          || (*(_DWORD *)p_m_nVehicleFlags & 0x2000001) != 0
          || (*((_DWORD *)&pVehicle->m_nVehicleFlags + 1) & 0x40) != 0
          || CTimer::m_snTimeInMilliseconds < pVehicle->DontUseSmallerRemovalRange )
        {
LABEL_25:
          v19 = TheCamera.GenerationDistMultiplier * 170.0;
        }
        else
        {
          v19 = 45.0;
        }
        v1.n64_u32[0] = 1126825984;
        v2.n64_f32[0] = (float)pVehicle->ExtendedRemovalRange;
        v20 = vmax_f32(v2, v1).n64_f32[0] / 170.0;
        if ( TheCamera.m_cameraMatrix.zy < -0.9 )
          v19 = 70.0;
        if ( v14 > (float)(v19 * v20) && pVehicle->AutoPilot.Mission != 59 )
        {
          v21 = pVehicle->m_pMat;
          if ( v21 )
            p_m_transform = (CSimpleTransform *)&v21->tx;
          v22 = *(_QWORD *)&p_m_transform->m_translate.x;
          v40[0].z = p_m_transform->m_translate.z;
          *(_QWORD *)&v40[0].x = v22;
          if ( !CGarages::IsPointWithinHideOutGarage(v40) )
          {
            v38 = apCarsToKeep[0] == pVehicle;
            if ( apCarsToKeep[0] != pVehicle )
              v38 = apCarsToKeep[1] == pVehicle;
            if ( v38 )
            {
              pVehicle->m_nNoOfStaticFrames = 10;
              return;
            }
            if ( CEntity::GetIsOnScreen(pVehicle) )
            {
              *(_DWORD *)p_m_nVehicleFlags |= 0x40000u;
              return;
            }
            goto LABEL_83;
          }
        }
        m_info = (unsigned __int8)pVehicle->m_info;
        if ( (m_info & 0xF8) == 16 && fabsf(pVehicle->m_pMat->zz) < 0.74 )
        {
LABEL_83:
          CWorld::Remove(pVehicle);
          (*((void (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 1))(pVehicle);
          return;
        }
        v24 = m_info >> 3 == 5;
        if ( m_info >> 3 != 5 )
          v24 = m_info >> 3 == 3;
        if ( v24 && (unsigned int)(pVehicle->m_vehicleType - 3) <= 1 && (*(_BYTE *)&pVehicle->m_nFlags & 0x10) != 0 )
        {
          CWorld::Remove(pVehicle);
          (*((void (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 1))(pVehicle);
          CDebug::DebugLog("Removed random plane/heli that was stuck in map\n");
          return;
        }
      }
      if ( (unsigned int)(pVehicle->m_vehicleType - 3) < 2 )
        goto LABEL_89;
      if ( pVehicle->AutoPilot.TempAction == 12 )
        goto LABEL_89;
      v25 = (unsigned __int8)pVehicle->m_info;
      if ( v25 >> 3 != 2 && (v25 >> 3 != 3 || ((unsigned __int8)pVehicle->AutoPilot.DrivingMode | 4) != 4) )
        goto LABEL_89;
      if ( CTimer::m_snTimeInMilliseconds - pVehicle->AutoPilot.LastTimeMoving < 0x1389
        || pVehicle->DontUseSmallerRemovalRange
        || !CTimer::m_snTimeInMilliseconds
        || CEntity::GetIsOnScreen(pVehicle) )
      {
        goto LABEL_89;
      }
      v26 = pVehicle->m_pMat;
      v27 = &pVehicle->m_transform;
      v28 = &pVehicle->m_transform;
      if ( v26 )
        v28 = (CSimpleTransform *)&v26->tx;
      if ( sqrtf(
             (float)((float)(v28->m_translate.x - x) * (float)(v28->m_translate.x - x))
           + (float)((float)(v28->m_translate.y - y) * (float)(v28->m_translate.y - y))) <= 22.0 )
        goto LABEL_89;
      v29 = apCarsToKeep[0] == pVehicle;
      if ( apCarsToKeep[0] != pVehicle )
        v29 = apCarsToKeep[1] == pVehicle;
      if ( v29
        || (*(_BYTE *)p_m_nVehicleFlags & 8) != 0
        || !CVehicle::CanBeDeleted(pVehicle)
        || CTrafficLights::ShouldCarStopForLight(pVehicle, 1)
        || CTrafficLights::ShouldCarStopForBridge(pVehicle) )
      {
        goto LABEL_89;
      }
      v30 = pVehicle->m_pMat;
      if ( v30 )
        v27 = (CSimpleTransform *)&v30->tx;
      v31 = *(_QWORD *)&v27->m_translate.x;
      v40[0].z = v27->m_translate.z;
      *(_QWORD *)&v40[0].x = v31;
      if ( CGarages::IsPointWithinHideOutGarage(v40) )
      {
LABEL_89:
        if ( (*(_BYTE *)&pVehicle->m_info & 0xF8) != 40 )
          return;
        m_nTimeOfDeath = pVehicle->m_nTimeOfDeath;
        if ( !m_nTimeOfDeath )
          return;
        v33 = m_nTimeOfDeath + 60000;
        v34 = CTimer::m_snTimeInMilliseconds > v33;
        if ( CTimer::m_snTimeInMilliseconds > v33 )
          v34 = CTimer::m_snTimeInMilliseconds > pVehicle->DontUseSmallerRemovalRange;
        if ( !v34 || CEntity::GetIsOnScreen(pVehicle) )
          return;
        v35 = pVehicle->m_pMat;
        v36 = (CSimpleTransform *)&v35->tx;
        if ( !v35 )
          v36 = &pVehicle->m_transform;
        if ( (float)((float)((float)((float)(v36->m_translate.x - x) * (float)(v36->m_translate.x - x))
                           + (float)((float)(v36->m_translate.y - y) * (float)(v36->m_translate.y - y)))
                   + (float)((float)(v36->m_translate.z - z) * (float)(v36->m_translate.z - z))) <= 42.25 )
          return;
        v37 = *(_QWORD *)&v36->m_translate.x;
        v40[0].z = v36->m_translate.z;
        *(_QWORD *)&v40[0].x = v37;
        if ( CGarages::IsPointWithinHideOutGarage(v40) )
          return;
      }
      goto LABEL_83;
    }
  }
}
// 2EC776: variable 'v2' is possibly undefined
// 2EC776: variable 'v1' is possibly undefined
// 2EC898: variable 'x' is possibly undefined
// 2EC89C: variable 'y' is possibly undefined
// 2EC970: variable 'z' is possibly undefined

//----- (002ECA8C) --------------------------------------------------------
void CCarCtrl::RemoveCarsIfThePoolGetsFull()
{
  unsigned __int64 v0; // d19
  CVehiclePool *v1; // r9
  int32 m_nSize; // r0
  int v3; // r6
  int8x16_t v4; // q8
  unsigned int v5; // r2
  int64x2_t v6; // q10
  uint8 *m_aFlags; // r1
  int v8; // t1
  int32x4_t v9; // q8
  unsigned __int32 v10; // r3
  uint8 *v11; // r1
  int v12; // r2
  unsigned int v13; // t1
  int v14; // r6
  int v15; // r4
  float v16; // s16
  uint8 *v17; // r11
  CVehicle *v18; // r5
  bool v19; // zf
  uint8 *v20; // r0
  int v21; // r1
  CSimpleTransform *p_tx; // r1
  float32x2_t v23; // d16
  unsigned __int64 v24; // d1
  float v25; // s0
  CEntity *pEntity; // [sp+8h] [bp-30h]

  if ( (CTimer::m_FrameCounter & 7) != 3 )
    return;
  v1 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize < 1 )
  {
    v10 = 0;
    goto LABEL_14;
  }
  if ( (unsigned int)m_nSize < 4 || (v3 = m_nSize & 0x7FFFFFFC, (m_nSize & 0xFFFFFFFC) == 0) )
  {
    v3 = 0;
    v10 = 0;
LABEL_10:
    v11 = &CPools::ms_pVehiclePool->m_aFlags[v3];
    v12 = m_nSize - v3;
    do
    {
      v13 = *v11++;
      --v12;
      v10 += (v13 >> 7) ^ 1;
    }
    while ( v12 );
    goto LABEL_14;
  }
  v4 = 0uLL;
  v5 = m_nSize & 0xFFFFFFFC;
  v6.n128_u64[0] = 0xFF000000FFLL;
  v6.n128_u64[1] = 0xFF000000FFLL;
  m_aFlags = CPools::ms_pVehiclePool->m_aFlags;
  do
  {
    v8 = *(_DWORD *)m_aFlags;
    m_aFlags += 4;
    v5 -= 4;
    LODWORD(v0) = v8;
    v0 = vshr_n_u16((uint16x4_t)vmovl_u8((uint8x8_t)v0).n128_u64[0], 7u).n64_u64[0] ^ 0x1000100010001LL;
    v4 = vaddq_s32(v4, vandq_s64(vmovl_u16((uint16x4_t)v0), v6));
  }
  while ( v5 );
  v9 = vaddq_s32(v4, vextq_s8(v4, v4, 8u));
  v10 = vaddq_s32(v9, vdupq_lane_s32((int32x2_t)v9.n128_u64[0], 1)).n128_u32[0];
  if ( m_nSize != v3 )
    goto LABEL_10;
LABEL_14:
  if ( (int)(m_nSize - v10) <= 7 && m_nSize )
  {
    v14 = m_nSize - 1;
    v15 = m_nSize;
    pEntity = 0;
    v16 = 10000000.0;
    do
    {
      if ( (v1->m_aFlags[v14] & 0x80u) == 0 )
      {
        v17 = v1->m_aStorage[v15];
        v18 = (CVehicle *)(v17 - 2604);
        if ( v17 != (uint8 *)&elf_hash_bucket[588] )
        {
          v19 = v18 == apCarsToKeep[0];
          if ( v18 != apCarsToKeep[0] )
            v19 = v18 == apCarsToKeep[1];
          if ( !v19
            && (*(v17 - 1536) & 8) == 0
            && CVehicle::CanBeDeleted((const CVehicle *)(v17 - 2604))
            && !CCranes::IsThisCarBeingTargettedByAnyCrane((CVehicle *)(v17 - 2604)) )
          {
            v20 = v17 - 2600;
            v21 = *((_DWORD *)v17 - 646);
            if ( v21 )
              v20 = (uint8 *)(v21 + 48);
            p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              p_tx = &TheCamera.m_transform;
            v23.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)(v20 + 4)).n64_u64[0];
            v24 = vmul_f32(v23, v23).n64_u64[0];
            v25 = sqrtf(
                    (float)((float)((float)(p_tx->m_translate.x - *(float *)v20)
                                  * (float)(p_tx->m_translate.x - *(float *)v20))
                          + *(float *)&v24)
                  + *((float *)&v24 + 1));
            if ( v25 < v16 )
            {
              v16 = v25;
              pEntity = (CEntity *)(v17 - 2604);
            }
          }
        }
      }
      --v14;
      --v15;
    }
    while ( v14 != -1 );
    if ( pEntity )
    {
      CWorld::Remove(pEntity);
      (*((void (__fastcall **)(CEntity *))pEntity->_vptr$CPlaceable + 1))(pEntity);
    }
  }
}
// 2ECAC8: mask 0xFFFFFFFC is shortened because r0.4 <= 0x7FFFFFFF
// 2ECAEC: variable 'v0' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002ECC5C) --------------------------------------------------------
UInt8 __fastcall CCarCtrl::IsThisVehicleInteresting(CVehicle *pVeh)
{
  return apCarsToKeep[0] == pVeh || apCarsToKeep[1] == pVeh;
}

//----- (002ECC84) --------------------------------------------------------
void __fastcall CCarCtrl::UpdateCarOnRails(CVehicle *pVehicle)
{
  CAutoPilot *p_AutoPilot; // r0
  int Address; // r2
  CPathNode *v4; // r2
  bool v5; // zf
  CPathNode *v6; // r2
  bool v7; // zf
  CPathNode *v8; // r2
  bool v9; // zf
  __int16 v10; // r1
  int TempAction; // r1
  UInt32 v12; // r0
  int v13; // r1
  CCarPathLink *v14; // r1
  int DirXb; // r6
  CCarPathLink *v16; // r0
  int InvertDirNewLink; // r5
  int InvertDirOldLink; // r11
  int v19; // r8
  float TimeToGetToNextLink; // s16
  int v21; // r10
  int RandomSeed; // r0
  unsigned int v23; // r1
  unsigned int v24; // r0
  float v25; // s22
  float v26; // s24
  float v27; // s18
  float v28; // s20
  UInt16 v29; // r0
  CCarPathLink *v30; // r1
  int v31; // r0
  float v32; // s6
  float v33; // s0
  float v34; // s4
  float v35; // s2
  UInt16 v36; // r0
  CCarPathLink *v37; // r1
  int v38; // r0
  int CoorsX; // s4
  float CoorsY; // s2
  __int64 v41; // d16
  int DirYb; // [sp+10h] [bp-B0h]
  float v43; // [sp+14h] [bp-ACh]
  int NewLane; // [sp+18h] [bp-A8h]
  int32 m_vehicleType; // [sp+1Ch] [bp-A4h]
  float v46; // [sp+20h] [bp-A0h]
  int OldLane; // [sp+24h] [bp-9Ch]
  Int32 TimeToLeaveLink; // [sp+28h] [bp-98h]
  uint32 v49; // [sp+2Ch] [bp-94h]
  CVector endCoors; // [sp+30h] [bp-90h] BYREF
  CVector startCoors; // [sp+3Ch] [bp-84h] BYREF
  CVector v52; // [sp+48h] [bp-78h] BYREF
  CVector v53; // [sp+54h] [bp-6Ch] BYREF
  CVector resultSpeed; // [sp+60h] [bp-60h] BYREF
  CVector v55[7]; // [sp+6Ch] [bp-54h] BYREF

  p_AutoPilot = &pVehicle->AutoPilot;
  Address = pVehicle->AutoPilot.OldLink.Address;
  if ( Address == 0xFFFF )
    goto LABEL_14;
  v4 = ThePaths.pNodes[(unsigned __int16)Address >> 10];
  v5 = v4 == 0;
  if ( v4 )
  {
    v4 = (CPathNode *)pVehicle->AutoPilot.NewLink.Address;
    v5 = v4 == (CPathNode *)((char *)&elf_hash_bucket[16320] + 3);
  }
  if ( v5 )
    goto LABEL_14;
  v6 = ThePaths.pNodes[(unsigned __int16)v4 >> 10];
  v7 = v6 == 0;
  if ( v6 )
    v7 = p_AutoPilot->OldNode.Region == 0xFFFF;
  if ( v7 )
    goto LABEL_14;
  v8 = ThePaths.pNodes[p_AutoPilot->OldNode.Region];
  v9 = v8 == 0;
  if ( v8 )
    v9 = pVehicle->AutoPilot.NewNode.Region == 0xFFFF;
  if ( v9 || !ThePaths.pNodes[pVehicle->AutoPilot.NewNode.Region] )
  {
LABEL_14:
    v10 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75) | 0x100;
    *(_WORD *)((char *)&pVehicle->AutoPilot + 75) = v10;
    if ( (v10 & 0x100) != 0 )
      return;
  }
  else if ( (*(_WORD *)((char *)&pVehicle->AutoPilot + 75) & 0x100) != 0 )
  {
    return;
  }
  TempAction = pVehicle->AutoPilot.TempAction;
  switch ( TempAction )
  {
    case 24:
      goto LABEL_18;
    case 12:
      pVehicle->m_vecMoveSpeed.x = 0.0;
      pVehicle->m_vecMoveSpeed.y = 0.0;
      pVehicle->m_vecMoveSpeed.z = 0.0;
      CAutoPilot::ModifySpeed(p_AutoPilot, 0.0);
      return;
    case 1:
LABEL_18:
      pVehicle->m_vecMoveSpeed.x = 0.0;
      pVehicle->m_vecMoveSpeed.y = 0.0;
      pVehicle->m_vecMoveSpeed.z = 0.0;
      CAutoPilot::ModifySpeed(p_AutoPilot, 0.0);
      v12 = CTimer::m_snTimeInMilliseconds;
      if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
      {
        pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
        pVehicle->AutoPilot.LastTimeMoving = v12;
        pVehicle->AutoPilot.TempAction = 0;
      }
      break;
    default:
      CCarCtrl::SlowCarOnRailsDownForTrafficAndLights(pVehicle);
      v13 = pVehicle->AutoPilot.TimeToLeaveLink + pVehicle->AutoPilot.TimeToGetToNextLink;
      if ( -((v13 >> 31) + !__CFSHR__(v13, 31)) < 0 == __OFSUB__(0, v13 >> 31, __CFSHR__(v13, 31)) )
        CCarCtrl::PickNextNodeAccordingStrategy(pVehicle);
      if ( (*(_BYTE *)&pVehicle->m_info & 0xF8) != 24 )
      {
        v49 = CTimer::m_snTimeInMilliseconds;
        v14 = &ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF];
        DirYb = v14->DirYb;
        DirXb = v14->DirXb;
        TimeToLeaveLink = pVehicle->AutoPilot.TimeToLeaveLink;
        v16 = &ThePaths.pLinks[pVehicle->AutoPilot.OldLink.Address >> 10][pVehicle->AutoPilot.OldLink.Address & 0x3FF];
        OldLane = pVehicle->AutoPilot.OldLane;
        InvertDirNewLink = pVehicle->AutoPilot.InvertDirNewLink;
        InvertDirOldLink = pVehicle->AutoPilot.InvertDirOldLink;
        v19 = v16->DirYb;
        TimeToGetToNextLink = (float)pVehicle->AutoPilot.TimeToGetToNextLink;
        v21 = v16->DirXb;
        v46 = CCarPathLink::OneWayLaneOffset(v16);
        NewLane = pVehicle->AutoPilot.NewLane;
        v43 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF]);
        m_vehicleType = pVehicle->m_vehicleType;
        RandomSeed = pVehicle->RandomSeed;
        v23 = pVehicle->AutoPilot.NewLink.Address + RandomSeed;
        v24 = RandomSeed + pVehicle->AutoPilot.OldLink.Address;
        v52.z = 0.0;
        v25 = (float)((float)v21 * 0.01) * (float)InvertDirOldLink;
        v26 = (float)((float)v19 * 0.01) * (float)InvertDirOldLink;
        v27 = (float)((float)DirXb * 0.01) * (float)InvertDirNewLink;
        v28 = (float)((float)DirYb * 0.01) * (float)InvertDirNewLink;
        v53.x = v25 + (float)((float)(int)((v24 & 7) - 3) * 0.009);
        v53.y = v26 + (float)((float)(int)(((v24 >> 3) & 7) - 3) * 0.009);
        v53.z = 0.0;
        v52.x = v27 + (float)((float)(int)((v23 & 7) - 3) * 0.009);
        v52.y = v28 + (float)((float)(int)(((v23 >> 3) & 7) - 3) * 0.009);
        CVector::Normalise(&v53);
        CVector::Normalise(&v52);
        v29 = pVehicle->AutoPilot.OldLink.Address;
        v30 = ThePaths.pLinks[v29 >> 10];
        v31 = v29 & 0x3FF;
        v32 = (float)(v46 + (float)OldLane) * 5.4;
        v33 = (float)(v43 + (float)NewLane) * 5.4;
        if ( m_vehicleType == 10 )
          v32 = v32 + 1.458;
        v34 = (float)((float)v30[v31].CoorsY * 0.125) - (float)(v25 * v32);
        v35 = (float)(v26 * v32) + (float)((float)v30[v31].CoorsX * 0.125);
        if ( m_vehicleType == 10 )
          v33 = v33 + 1.458;
        startCoors.z = 0.0;
        startCoors.y = v34;
        startCoors.x = v35;
        v36 = pVehicle->AutoPilot.NewLink.Address;
        v37 = ThePaths.pLinks[v36 >> 10];
        v38 = v36 & 0x3FF;
        CoorsX = v37[v38].CoorsX;
        CoorsY = (float)v37[v38].CoorsY;
        endCoors.z = 0.0;
        endCoors.y = (float)(CoorsY * 0.125) - (float)(v27 * v33);
        endCoors.x = (float)(v28 * v33) + (float)((float)CoorsX * 0.125);
        CCurves::CalcCurvePoint(
          &startCoors,
          &endCoors,
          &v53,
          &v52,
          (float)(v49 - TimeToLeaveLink) / TimeToGetToNextLink,
          pVehicle->AutoPilot.TimeToGetToNextLink,
          v55,
          &resultSpeed);
        v55[0].z = 15.0;
        CCarCtrl::DragCarToPoint(pVehicle, v55);
        resultSpeed.x = resultSpeed.x * 0.016667;
        resultSpeed.y = resultSpeed.y * 0.016667;
        resultSpeed.z = resultSpeed.z * 0.016667;
        if ( pVehicle->AutoPilot.OldLink.Address != pVehicle->AutoPilot.NewLink.Address )
        {
          v41 = *(_QWORD *)&resultSpeed.x;
          pVehicle->m_vecMoveSpeed.z = resultSpeed.z;
          *(_QWORD *)&pVehicle->m_vecMoveSpeed.x = v41;
        }
      }
      break;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002ED0FC) --------------------------------------------------------
bool __fastcall CCarCtrl::StopCarIfNodesAreInvalid(CVehicle *pVehicle)
{
  int Address; // r2
  CPathNode *v2; // r2
  bool v3; // zf
  CPathNode *v4; // r2
  bool v5; // zf
  CPathNode *v6; // r2
  bool v7; // zf

  Address = pVehicle->AutoPilot.OldLink.Address;
  if ( Address != 0xFFFF )
  {
    v2 = ThePaths.pNodes[(unsigned __int16)Address >> 10];
    v3 = v2 == 0;
    if ( v2 )
    {
      v2 = (CPathNode *)pVehicle->AutoPilot.NewLink.Address;
      v3 = v2 == (CPathNode *)((char *)&elf_hash_bucket[16320] + 3);
    }
    if ( !v3 )
    {
      v4 = ThePaths.pNodes[(unsigned __int16)v2 >> 10];
      v5 = v4 == 0;
      if ( v4 )
        v5 = pVehicle->AutoPilot.OldNode.Region == 0xFFFF;
      if ( !v5 )
      {
        v6 = ThePaths.pNodes[pVehicle->AutoPilot.OldNode.Region];
        v7 = v6 == 0;
        if ( v6 )
          v7 = pVehicle->AutoPilot.NewNode.Region == 0xFFFF;
        if ( !v7 && ThePaths.pNodes[pVehicle->AutoPilot.NewNode.Region] )
          return 0;
      }
    }
  }
  *(_WORD *)((char *)&pVehicle->AutoPilot + 75) |= 0x100u;
  return 1;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002ED19C) --------------------------------------------------------
void __fastcall CCarCtrl::SlowCarOnRailsDownForTrafficAndLights(CVehicle *pVehicle)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  unsigned __int32 v4; // s0
  float v5; // r1

  if ( (CTimer::m_FrameCounter + pVehicle->RandomSeed) << 30 )
  {
    v1.n64_u32[0] = LODWORD(pVehicle->AutoPilot.MaxSpeedBuffer);
  }
  else
  {
    if ( CTrafficLights::ShouldCarStopForLight(pVehicle, 0) || CTrafficLights::ShouldCarStopForBridge(pVehicle) )
    {
      CCarAI::CarHasReasonToStop(pVehicle);
      v1.n64_u32[0] = 0;
    }
    else
    {
      v1.n64_u32[0] = CCarCtrl::FindMaximumSpeedForThisCarInTraffic(pVehicle);
    }
    LODWORD(pVehicle->AutoPilot.MaxSpeedBuffer) = v1.n64_u32[0];
  }
  v2.n64_u32[0] = LODWORD(pVehicle->AutoPilot.ActualSpeed);
  if ( v1.n64_f32[0] >= v2.n64_f32[0] )
  {
    if ( v1.n64_f32[0] <= v2.n64_f32[0] )
      return;
    v2.n64_f32[0] = v2.n64_f32[0] + (float)(CTimer::ms_fTimeStep * 0.05);
    v4 = vmin_f32(v2, v1).n64_u32[0];
    goto LABEL_13;
  }
  if ( v2.n64_f32[0] != 0.0 )
  {
    if ( v2.n64_f32[0] < 0.1 )
    {
      v5 = 0.0;
      goto LABEL_14;
    }
    v2.n64_f32[0] = v2.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.7);
    v4 = vmax_f32(v2, v1).n64_u32[0];
LABEL_13:
    v5 = *(float *)&v4;
LABEL_14:
    sub_1903A4(&pVehicle->AutoPilot, v5);
  }
}
// 2ED21E: variable 'v2' is possibly undefined
// 2ED21E: variable 'v1' is possibly undefined

//----- (002ED280) --------------------------------------------------------
bool __fastcall CCarCtrl::PickNextNodeAccordingStrategy(CVehicle *pVehicle)
{
  CNodeAddress NewNode; // r1
  char *v3; // r0
  int v4; // r1
  int v5; // r2
  int Mission; // r3
  CEntity *pTargetEntity; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r3
  bool result; // r0
  float x; // r8
  float y; // r6
  float z; // r5
  CVehicle *v14; // [sp+0h] [bp-38h]
  CVector v15; // [sp+4h] [bp-34h] BYREF
  CVector v16; // [sp+10h] [bp-28h] BYREF
  CVector v17; // [sp+1Ch] [bp-1Ch] BYREF

  NewNode = pVehicle->AutoPilot.NewNode;
  v3 = (char *)&ThePaths + 4 * NewNode.Region;
  v4 = 7 * HIWORD(*(unsigned int *)&NewNode);
  v5 = (*(unsigned __int16 *)(*((_DWORD *)v3 + 513) + 4 * v4 + 24) >> 12) & 3;
  pVehicle->AutoPilot.SpeedFromNodes = v5;
  Mission = pVehicle->AutoPilot.Mission;
  if ( ((*(unsigned __int8 *)(*((_DWORD *)v3 + 513) + 4 * v4 + 26) << 16) & 0xE00000) == 0x800000 )
    LOBYTE(v5) = -1;
  pVehicle->AutoPilot.SpeedFromNodes = v5;
  switch ( Mission )
  {
    case 2:
    case 4:
    case 43:
      FindPlayerCoors(&v17, -1);
      x = v17.x;
      FindPlayerCoors(&v16, -1);
      y = v16.y;
      FindPlayerCoors(&v15, -1);
      z = v15.z;
      FindPlayerVehicle(-1, 0);
      result = CCarCtrl::PickNextNodeToChaseCar(pVehicle, x, y, z, v14);
      break;
    case 8:
    case 12:
      result = CCarCtrl::PickNextNodeToFollowPath(pVehicle);
      break;
    case 15:
    case 17:
    case 52:
    case 54:
    case 61:
    case 65:
    case 66:
    case 67:
    case 68:
      pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
      m_pMat = pTargetEntity->m_pMat;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pTargetEntity->m_transform.m_translate.x;
      result = CCarCtrl::PickNextNodeToChaseCar(pVehicle, *p_tx, p_tx[1], p_tx[2], v14);
      break;
    default:
      CCarCtrl::PickNextNodeRandomly(pVehicle);
      result = 0;
      break;
  }
  return result;
}
// 2ED340: variable 'v14' is possibly undefined

//----- (002ED3A8) --------------------------------------------------------
void __fastcall CCarCtrl::DragCarToPoint(CVehicle *pVehicle, CVector *pCoors)
{
  float32x2_t d0_0; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d8
  int FramesFloating; // r8
  CSimpleTransform *p_m_transform; // r9
  CColModel *m_pColModel; // r0
  float y; // s0
  float v10; // s2
  CMatrix *m_pMat; // r0
  __int64 v12; // d16
  CSimpleTransform *p_tx; // r2
  float zy; // s28
  float v15; // s22
  float xy; // s0
  float yy; // s2
  float x; // s8
  float v19; // s10
  __int64 v20; // kr00_8
  float v21; // s24
  float v22; // s26
  _BOOL4 v23; // r0
  float v24; // s19
  float v25; // s24
  float v26; // s26
  float v27; // s0
  CMatrix *v28; // r0
  CSimpleTransform *v29; // r1
  float v30; // s21
  float z; // s0
  float v32; // s23
  RwReal LastFrontHeight; // s28
  CEntity *v34; // r0
  CEntity::CFlags m_nFlags; // r2
  int v36; // r0
  CMatrix *v37; // r0
  float v38; // s0
  float v39; // s21
  float v40; // s0
  float v41; // s19
  RwReal LastRearHeight; // s30
  CEntity *v43; // r0
  CEntity::CFlags v44; // r2
  int v45; // r0
  float v46; // r5
  float v47; // r0
  float v48; // r1
  float v49; // r2
  float v50; // r5
  CMatrix *v51; // r0
  float v52; // s2
  float v53; // s4
  float *p_tz; // r0
  CVector v55; // [sp+20h] [bp-110h] BYREF
  CColPoint colPoint; // [sp+2Ch] [bp-104h] BYREF
  float fCollisionRatio; // [sp+58h] [bp-D8h] BYREF
  CColSphere sphere; // [sp+5Ch] [bp-D4h] BYREF
  CColLine line; // [sp+70h] [bp-C0h] BYREF
  CVector v2; // [sp+90h] [bp-A0h] BYREF
  CVector vecStart; // [sp+9Ch] [bp-94h] BYREF
  CEntity *refEntityPtr; // [sp+A8h] [bp-88h] BYREF
  CColPoint v63; // [sp+ACh] [bp-84h] BYREF

  v4.n64_u32[0] = 0.5;
  FramesFloating = pVehicle->AutoPilot.FramesFloating;
  p_m_transform = &pVehicle->m_transform;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel;
  y = m_pColModel->m_boxBound.m_vecMin.y;
  v10 = m_pColModel->m_boxBound.m_vecMax.y;
  m_pMat = pVehicle->m_pMat;
  v12 = *(_QWORD *)&m_pMat->xy;
  v2.z = m_pMat->zy;
  p_tx = &pVehicle->m_transform;
  *(_QWORD *)&v2.x = v12;
  zy = m_pMat->zy;
  v15 = (float)(v10 - y) * 0.95;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  x = p_tx->m_translate.x;
  v19 = p_tx->m_translate.y;
  v20 = *(_QWORD *)&pCoors->x;
  line.m_vecStart.z = 0.0;
  line.m_vecEnd.z = 0.0;
  v21 = x - (float)((float)(v15 * xy) * 0.5);
  v22 = v19 - (float)((float)(v15 * yy) * 0.5);
  line.m_vecStart.y = v22;
  line.m_vecStart.x = v21;
  line.m_vecEnd.x = (float)(xy * 1.5) + v21;
  line.m_vecEnd.y = (float)(yy * 1.5) + v22;
  *(_QWORD *)&sphere.m_vecCentre.x = v20;
  sphere.m_vecCentre.z = 0.0;
  fCollisionRatio = 1.0;
  sphere.m_fRadius = v15;
  v23 = CCollision::ProcessLineSphere(&line, &sphere, &colPoint, &fCollisionRatio);
  v24 = 3.0;
  if ( FramesFloating > 16 )
    v24 = 100.0;
  if ( v23 )
  {
    v25 = colPoint.m_vecPosition.x;
    v26 = colPoint.m_vecPosition.y;
  }
  else
  {
    v27 = v15
        / sqrtf(
            (float)((float)(*(float *)&v20 - v21) * (float)(*(float *)&v20 - v21))
          + (float)((float)(*((float *)&v20 + 1) - v22) * (float)(*((float *)&v20 + 1) - v22)));
    v26 = (float)((float)(v22 - *((float *)&v20 + 1)) * v27) + *((float *)&v20 + 1);
    v25 = (float)((float)(v21 - *(float *)&v20) * v27) + *(float *)&v20;
  }
  v28 = pVehicle->m_pMat;
  v29 = p_m_transform;
  if ( v28 )
    v29 = (CSimpleTransform *)&v28->tx;
  v30 = (float)(v15 * zy) * 0.5;
  z = v29->m_translate.z;
  *(_QWORD *)&vecStart.x = v20;
  v32 = v30 + z;
  vecStart.z = v24 + (float)(v30 + z);
  ++pVehicle->AutoPilot.FramesFloating;
  if ( CCollision::IsStoredPolyStillValidVerticalLine(
         &vecStart,
         (float)(v30 + z) - v24,
         &v63,
         pVehicle->StoredCollPolys) )
  {
    LastFrontHeight = v63.m_vecPosition.z;
  }
  else
  {
    vecStart.z = v32 + 1.5;
    if ( CWorld::ProcessVerticalLine(
           &vecStart,
           v32 + -2.0,
           &v63,
           &refEntityPtr,
           1,
           0,
           0,
           0,
           0,
           0,
           pVehicle->StoredCollPolys)
      || (vecStart.z = v24 + (float)(v30 + z),
          CWorld::ProcessVerticalLine(
            &vecStart,
            (float)(v30 + z) - v24,
            &v63,
            &refEntityPtr,
            1,
            0,
            0,
            0,
            0,
            0,
            pVehicle->StoredCollPolys)) )
    {
      v34 = refEntityPtr;
      LastFrontHeight = v63.m_vecPosition.z;
      pVehicle->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
      m_nFlags = pVehicle->m_nFlags;
      *(_DWORD *)&m_nFlags = *(_DWORD *)&m_nFlags & 0xBFFFFFFF | (((*(_DWORD *)&v34->m_nFlags >> 30) & 1) << 30);
      pVehicle->m_nFlags = m_nFlags;
      v36 = (int)v34->m_nFlags;
      pVehicle->AutoPilot.FramesFloating = 0;
      *(_DWORD *)&pVehicle->m_nFlags = v36 & 0x80000000 | *(_DWORD *)&m_nFlags & 0x7FFFFFFF;
      pVehicle->m_nFlags.bdummy = m_nFlags.bdummy;
    }
    else
    {
      LastFrontHeight = pVehicle->LastFrontHeight;
    }
  }
  v37 = pVehicle->m_pMat;
  pVehicle->LastFrontHeight = LastFrontHeight;
  if ( v37 )
    p_m_transform = (CSimpleTransform *)&v37->tx;
  v38 = p_m_transform->m_translate.z;
  vecStart.y = v26;
  v39 = v38 - v30;
  vecStart.x = v25;
  v40 = v39 - v24;
  v41 = v24 + v39;
  vecStart.z = v41;
  if ( CCollision::IsStoredPolyStillValidVerticalLine(&vecStart, v40, &v63, &pVehicle->StoredCollPolys[1]) )
  {
    LastRearHeight = v63.m_vecPosition.z;
  }
  else
  {
    vecStart.z = v39 + 1.5;
    if ( CWorld::ProcessVerticalLine(
           &vecStart,
           v39 + -2.0,
           &v63,
           &refEntityPtr,
           1,
           0,
           0,
           0,
           0,
           0,
           &pVehicle->StoredCollPolys[1])
      || (vecStart.z = v41,
          CWorld::ProcessVerticalLine(
            &vecStart,
            v40,
            &v63,
            &refEntityPtr,
            1,
            0,
            0,
            0,
            0,
            0,
            &pVehicle->StoredCollPolys[1])) )
    {
      v43 = refEntityPtr;
      LastRearHeight = v63.m_vecPosition.z;
      pVehicle->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
      v44 = pVehicle->m_nFlags;
      *(_DWORD *)&v44 = *(_DWORD *)&v44 & 0xBFFFFFFF | (((*(_DWORD *)&v43->m_nFlags >> 30) & 1) << 30);
      pVehicle->m_nFlags = v44;
      v45 = (int)v43->m_nFlags;
      pVehicle->AutoPilot.FramesFloating = 0;
      *(_DWORD *)&pVehicle->m_nFlags = v45 & 0x80000000 | *(_DWORD *)&v44 & 0x7FFFFFFF;
      pVehicle->m_nFlags.bdummy = v44.bdummy;
    }
    else
    {
      LastRearHeight = pVehicle->LastRearHeight;
    }
  }
  pVehicle->LastRearHeight = LastRearHeight;
  v46 = atanf((float)(LastFrontHeight - LastRearHeight) / v15);
  pVehicle->m_pMat->xx = (float)(*((float *)&v20 + 1) - v26) / v15;
  pVehicle->m_pMat->yx = (float)-(float)(*(float *)&v20 - v25) / v15;
  pVehicle->m_pMat->zx = 0.0;
  v47 = cosf(v46);
  pVehicle->m_pMat->xy = -(float)(v47 * pVehicle->m_pMat->yx);
  pVehicle->m_pMat->yy = v47 * pVehicle->m_pMat->xx;
  pVehicle->m_pMat->zy = sinf(v46);
  CrossProduct(&v55, (const CVector *)pVehicle->m_pMat, (const CVector *)&pVehicle->m_pMat->xy);
  v48 = v55.y;
  v49 = v55.z;
  pVehicle->m_pMat->xz = v55.x;
  pVehicle->m_pMat->yz = v48;
  pVehicle->m_pMat->zz = v49;
  v50 = COERCE_FLOAT((*((int (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 54))(pVehicle));
  CVehicle::UpdateLightingFromStoredPolys(pVehicle);
  v51 = pVehicle->m_pMat;
  v52 = (float)(v26 + *((float *)&v20 + 1)) * 0.5;
  v53 = (float)(v25 + *(float *)&v20) * 0.5;
  if ( v51 )
  {
    v51->tx = v53;
    pVehicle->m_pMat->ty = v52;
    p_tz = &pVehicle->m_pMat->tz;
  }
  else
  {
    p_tz = &pVehicle->m_transform.m_translate.z;
    pVehicle->m_transform.m_translate.x = v53;
    pVehicle->m_transform.m_translate.y = v52;
  }
  *p_tz = (float)((float)(LastFrontHeight + LastRearHeight) * 0.5) + v50;
  CrossProduct(&v55, (const CVector *)&pVehicle->m_pMat->xy, &v2);
  d0_0.n64_f32[0] = v55.z * -10.0;
  v3.n64_u32[0] = -0.5;
  LODWORD(pVehicle->m_fSteerAngle) = vmax_f32(vmin_f32(d0_0, v4), v3).n64_u32[0];
}
// 2ED7DA: variable 'd0_0' is possibly undefined
// 2ED7DA: variable 'v4' is possibly undefined
// 2ED7DE: variable 'v3' is possibly undefined

//----- (002ED7FC) --------------------------------------------------------
float __fastcall CCarCtrl::FindMaximumSpeedForThisCarInTraffic(CVehicle *pVehicle)
{
  unsigned int DrivingMode; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s4
  float v8; // s20
  float v9; // s22
  float v10; // s16
  float v11; // s18
  float v12; // s28
  float v13; // r5
  float v14; // s24
  float v15; // r0
  int v16; // r2
  int v17; // r1
  int v18; // r1
  int v19; // r2
  uint16 v20; // r0
  int v21; // r8
  int v22; // r10
  CRepeatSector *v23; // r5
  int v25; // r1
  int v26; // [sp+18h] [bp-78h]
  int v27; // [sp+1Ch] [bp-74h]
  int v28; // [sp+20h] [bp-70h]
  int v29; // [sp+30h] [bp-60h]
  float pMaxSpeed[23]; // [sp+34h] [bp-5Ch] BYREF

  DrivingMode = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
  if ( DrivingMode <= 5 && ((1 << DrivingMode) & 0x2C) != 0 )
    return pVehicle->AutoPilot.SpeedMultiplier * (float)pVehicle->AutoPilot.CruiseSpeed;
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  y = p_tx->m_translate.y;
  v8 = p_tx->m_translate.x + -14.0;
  v9 = y + -14.0;
  v10 = p_tx->m_translate.x + 14.0;
  v11 = y + 14.0;
  v12 = floorf((float)(v8 / 50.0) + 60.0);
  v13 = floorf((float)((float)(y + -14.0) / 50.0) + 60.0);
  v14 = floorf((float)(v10 / 50.0) + 60.0);
  v15 = floorf((float)((float)(y + 14.0) / 50.0) + 60.0);
  v16 = 119;
  v17 = (int)v15;
  if ( (int)v15 >= 119 )
    v17 = 119;
  v27 = v17;
  if ( (int)v14 < 119 )
    v16 = (int)v14;
  v18 = (int)v13;
  v29 = v16;
  v19 = 0;
  if ( (int)v13 <= 0 )
    v18 = 0;
  v28 = v18;
  if ( (int)v12 > 0 )
    v19 = (int)v12;
  v26 = v19;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v20 = 1;
  }
  else
  {
    v20 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v20;
  pMaxSpeed[0] = pVehicle->AutoPilot.SpeedMultiplier * (float)pVehicle->AutoPilot.CruiseSpeed;
  if ( v28 <= v27 )
  {
    do
    {
      if ( v26 <= v29 )
      {
        v21 = v26 - 1;
        do
        {
          v22 = ++v21 & 0xF | (unsigned __int8)(16 * v28);
          if ( pVehicle->AutoPilot.DrivingMode != 6 )
            CCarCtrl::SlowCarDownForCarsSectorList(
              (CPtrList *)&CWorld::ms_aRepeatSectors[v22],
              pVehicle,
              v8,
              v9,
              v10,
              v11,
              pMaxSpeed,
              pVehicle->AutoPilot.SpeedMultiplier * (float)pVehicle->AutoPilot.CruiseSpeed);
          v23 = &CWorld::ms_aRepeatSectors[v22];
          CCarCtrl::SlowCarDownForPedsSectorList(
            &v23->m_ptrListArray[1],
            pVehicle,
            v8,
            v9,
            v10,
            v11,
            pMaxSpeed,
            pVehicle->AutoPilot.SpeedMultiplier * (float)pVehicle->AutoPilot.CruiseSpeed);
          CCarCtrl::SlowCarDownForObjectsSectorList(
            &v23->m_ptrListArray[2],
            pVehicle,
            v8,
            v9,
            v10,
            v11,
            pMaxSpeed,
            pVehicle->AutoPilot.SpeedMultiplier * (float)pVehicle->AutoPilot.CruiseSpeed);
        }
        while ( v21 < v29 );
      }
    }
    while ( v28++ < v27 );
  }
  v25 = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
  *(_DWORD *)&pVehicle->m_nVehicleFlags |= 0x2000u;
  if ( (v25 | 4) == 4 )
    return pMaxSpeed[0];
  else
    return (float)(pMaxSpeed[0] + (float)(pVehicle->AutoPilot.SpeedMultiplier * (float)pVehicle->AutoPilot.CruiseSpeed))
         * 0.5;
}

//----- (002EDABC) --------------------------------------------------------
void __fastcall CCarCtrl::SlowCarDownForCarsSectorList(
        CPtrList *list,
        CVehicle *pVehicle,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float *pMaxSpeed,
        float OriginalMaxSpeed)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v12; // kr00_8
  int v13; // r1
  bool v14; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  float v17; // r0
  CMatrix *v18; // r1
  float v19; // s0
  CSimpleTransform *p_tx; // r0
  float zy; // s4
  CVector v22; // [sp+Ch] [bp-64h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    while ( 1 )
    {
      v12 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      if ( v12.m_pVoid != pVehicle )
      {
        v13 = *((unsigned __int16 *)v12.m_pVoid + 24);
        v14 = v13 == CWorld::ms_nCurrentScanCode;
        if ( v13 != CWorld::ms_nCurrentScanCode )
          v14 = *((unsigned __int8 *)v12.m_pVoid + 28) << 31 == 0;
        if ( !v14 )
        {
          *((_WORD *)v12.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
          CEntity::GetBoundCentre(&v22, (const CEntity *)v12.m_pVoid);
          if ( v22.x > MinX && v22.x < MaxX && v22.y > MinY && v22.y < MaxY )
          {
            m_pMat = pVehicle->m_pMat;
            p_m_transform = &pVehicle->m_transform;
            if ( m_pMat )
              p_m_transform = (CSimpleTransform *)&m_pMat->tx;
            if ( fabsf(v22.z - p_m_transform->m_translate.z) < 10.0 )
            {
              v17 = CCollision::DistAlongLine2D(
                      p_m_transform->m_translate.x,
                      p_m_transform->m_translate.y,
                      m_pMat->xy,
                      m_pMat->yy,
                      v22.x,
                      v22.y);
              v18 = pVehicle->m_pMat;
              v19 = v17;
              p_tx = &pVehicle->m_transform;
              zy = 0.0;
              if ( v18 )
                p_tx = (CSimpleTransform *)&v18->tx;
              if ( v18 )
                zy = v18->zy;
              if ( fabsf(v22.z - (float)(p_tx->m_translate.z + (float)(v19 * zy))) < 3.0 )
                break;
            }
          }
        }
      }
      if ( !m_pHead )
        return;
    }
    CCarCtrl::SlowCarDownForOtherCar((CEntity *)v12.m_pVoid, pVehicle, pMaxSpeed, OriginalMaxSpeed);
  }
}

//----- (002EDC00) --------------------------------------------------------
void __fastcall CCarCtrl::SlowCarDownForPedsSectorList(
        CPtrList *list,
        CVehicle *pVehicle,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float *pMaxSpeed,
        float OriginalMaxSpeed)
{
  float32x2_t v8; // d1
  float32x2_t v9; // d11
  CMatrix *m_pMat; // r0
  float x; // s18
  float xy; // s24
  float yy; // s28
  float zy; // s26
  float y; // s22
  float z; // s20
  float v21; // s16
  unsigned int m_baseVehicleType; // r1
  _BOOL4 v23; // r0
  int DrivingMode; // r0
  bool v25; // zf
  CPtrNode *m_pHead; // r5
  float v27; // s0
  float v28; // s17
  int v29; // r6
  float v30; // s0
  int v31; // r2
  float v32; // s21
  CPtrNode v33; // kr00_8
  int v34; // r1
  bool v35; // zf
  int v36; // r1
  char *v37; // r11
  float *v38; // r0
  float v39; // s20
  float v40; // s24
  float v41; // s31
  CSimpleTransform *p_m_transform; // r1
  CMatrix *v43; // r0
  float v44; // r0
  float v45; // s4
  CMatrix *v46; // r1
  float v47; // s2
  CSimpleTransform *p_tx; // r0
  float v49; // s0
  float v50; // s31
  float v51; // s29
  float v52; // s24
  unsigned int v53; // r0
  float v54; // s20
  bool v55; // fzf
  bool v56; // fnf
  float v57; // s0
  float v58; // s4
  float v59; // s8
  int v60; // r0
  float v61; // s0
  CPed *pDriver; // r0
  int v63; // r0
  unsigned int v64; // r1
  unsigned int v65; // r2
  CMatrix *v66; // r0
  CSimpleTransform *v67; // r2
  int v68; // r1
  float32x2_t v69; // d16
  char v70; // r1
  float v71; // [sp+20h] [bp-88h]
  float v72; // [sp+2Ch] [bp-7Ch]
  int v73; // [sp+30h] [bp-78h]
  CEventPotentialGetRunOver v74; // [sp+34h] [bp-74h] BYREF

  m_pMat = pVehicle->m_pMat;
  x = pVehicle->m_vecMoveSpeed.x;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  zy = m_pMat->zy;
  y = pVehicle->m_vecMoveSpeed.y;
  z = pVehicle->m_vecMoveSpeed.z;
  v21 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x;
  if ( FindPlayerVehicle(-1, 0) == pVehicle )
  {
LABEL_9:
    v23 = 1;
    goto LABEL_10;
  }
  m_baseVehicleType = pVehicle->m_baseVehicleType;
  if ( m_baseVehicleType > 6 || (v23 = 1, ((1 << m_baseVehicleType) & 0x58) == 0) )
  {
    DrivingMode = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
    v25 = DrivingMode == 6;
    if ( DrivingMode != 6 )
      v25 = DrivingMode == 0;
    if ( v25 )
    {
      v23 = (*(_BYTE *)&pVehicle->m_info & 0xF8) == 24;
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_10:
  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v27 = yy * y;
    v28 = MinY;
    v29 = 1;
    v9.n64_u32[0] = 0;
    v30 = (float)((float)(xy * x) + v27) + (float)(zy * z);
    v71 = fabsf(v30) * 50.0;
    v72 = (float)(v30 * 50.0) * 4.0;
    v31 = 0;
    v32 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y;
    if ( v30 < 0.0 )
      v29 = -1;
    if ( v30 != 0.0 )
      v31 = 1;
    v73 = v23 & v31;
    while ( 1 )
    {
      v33 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v34 = *((unsigned __int16 *)v33.m_pVoid + 24);
      v35 = v34 == CWorld::ms_nCurrentScanCode;
      if ( v34 != CWorld::ms_nCurrentScanCode )
        v35 = *((unsigned __int8 *)v33.m_pVoid + 28) << 31 == 0;
      if ( v35 )
        goto LABEL_20;
      v36 = *((_DWORD *)v33.m_pVoid + 5);
      v37 = (char *)v33.m_pVoid + 4;
      *((_WORD *)v33.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      v38 = (float *)((char *)v33.m_pVoid + 4);
      if ( v36 )
        v38 = (float *)(v36 + 48);
      v39 = *v38;
      if ( *v38 <= MinX )
        goto LABEL_20;
      if ( v39 >= MaxX )
        goto LABEL_20;
      v40 = v38[1];
      if ( v40 <= v28 || v40 >= MaxY )
        goto LABEL_20;
      v41 = v38[2];
      p_m_transform = &pVehicle->m_transform;
      v43 = pVehicle->m_pMat;
      if ( v43 )
        p_m_transform = (CSimpleTransform *)&v43->tx;
      if ( fabsf(v41 - p_m_transform->m_translate.z) >= 6.0 )
        goto LABEL_20;
      v44 = CCollision::DistAlongLine2D(
              p_m_transform->m_translate.x,
              p_m_transform->m_translate.y,
              v43->xy,
              v43->yy,
              v39,
              v40);
      v45 = 0.0;
      v46 = pVehicle->m_pMat;
      v47 = v44;
      p_tx = &pVehicle->m_transform;
      if ( v46 )
        p_tx = (CSimpleTransform *)&v46->tx;
      v49 = p_tx->m_translate.z;
      if ( v46 )
        v45 = v46->zy;
      if ( fabsf(v41 - (float)(v49 + (float)(v47 * v45))) >= 3.0 )
        goto LABEL_20;
      v50 = v41 - v49;
      v51 = v40 - p_tx->m_translate.y;
      v52 = v39 - p_tx->m_translate.x;
      v53 = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
      v54 = (float)((float)(v52 * v46->xy) + (float)(v51 * v46->yy)) + (float)(v50 * v46->zy);
      if ( v53 <= 6 && ((1 << v53) & 0x53) != 0 )
      {
        v55 = v54 == v32;
        v56 = v54 < v32;
        if ( v33.m_pVoid == FindPlayerPed(-1) )
        {
          if ( !v56 && !v55 && CWorld::Players[CWorld::PlayerInFocus].pLastTargetVehicle != pVehicle )
          {
LABEL_44:
            v57 = v54 - v32;
            if ( (float)(v54 - v32) < v72 )
            {
              if ( pVehicle->m_baseVehicleType == 9 )
                v21 = v21 * 1.6;
              if ( v57 < 13.0
                && fabsf(
                     (float)((float)(v52 * pVehicle->m_pMat->xx) + (float)(v51 * pVehicle->m_pMat->yx))
                   + (float)(v50 * pVehicle->m_pMat->zx)) <= (float)(v21 + 0.5) )
              {
                v8.n64_f32[0] = v57 + -1.0;
                v8.n64_u64[0] = vmax_f32(v8, v9).n64_u64[0];
                v8.n64_f32[0] = (float)(v8.n64_f32[0] / 13.0) * OriginalMaxSpeed;
                v58 = v8.n64_f32[0];
                v59 = 1.0;
                if ( v8.n64_f32[0] < 1.0 )
                  v58 = 1.0;
                if ( *pMaxSpeed < v58 )
                  v59 = *pMaxSpeed;
                if ( v8.n64_f32[0] < 1.0 )
                  v8.n64_f32[0] = v59;
                if ( *pMaxSpeed < v58 )
                  v8.n64_f32[0] = v59;
                *pMaxSpeed = v8.n64_f32[0];
                *(_WORD *)((char *)&pVehicle->AutoPilot + 75) |= 2u;
                if ( v57 < 4.0 )
                {
                  pVehicle->AutoPilot.TempAction = 1;
                  pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 4000;
                }
                if ( v57 < 2.5 )
                {
                  pVehicle->AutoPilot.TempAction = 24;
                  pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 4000;
                }
              }
            }
          }
        }
        else if ( !v56 && !v55 )
        {
          goto LABEL_44;
        }
      }
      if ( (*((_BYTE *)v33.m_pVoid + 58) & 7) != 3 )
        goto LABEL_20;
      if ( FindPlayerVehicle(-1, 0) == pVehicle && pVehicle->m_cHorn )
      {
        v66 = pVehicle->m_pMat;
        v67 = &pVehicle->m_transform;
        v68 = *((_DWORD *)v33.m_pVoid + 5);
        if ( v66 )
          v67 = (CSimpleTransform *)&v66->tx;
        if ( v68 )
          v37 = (char *)(v68 + 48);
        v69.n64_u64[0] = vsub_f32(*(float32x2_t *)(v37 + 4), *(float32x2_t *)&v67->m_translate.y).n64_u64[0];
        v8.n64_u64[0] = vmul_f32(v69, v69).n64_u64[0];
        if ( (float)((float)((float)((float)(*(float *)v37 - v67->m_translate.x)
                                   * (float)(*(float *)v37 - v67->m_translate.x))
                           + v8.n64_f32[0])
                   + v8.n64_f32[1]) < 49.0 )
        {
          CEventPotentialGetRunOver::CEventPotentialGetRunOver(&v74, pVehicle);
          CEventGroup::Add((CEventGroup *)(*((_DWORD *)v33.m_pVoid + 272) + 104), (CEvent *)&v74, 0);
          CEventPotentialGetRunOver::~CEventPotentialGetRunOver(&v74);
        }
      }
      if ( v73 != 1 )
        goto LABEL_20;
      v60 = 1;
      if ( v54 < 0.0 )
        v60 = -1;
      if ( v60 == v29
        && (v61 = fabsf(v54), (float)(v61 - v32) < v71)
        && v61 > v32
        && fabsf(
             (float)((float)(v52 * pVehicle->m_pMat->xx) + (float)(v51 * pVehicle->m_pMat->yx))
           + (float)(v50 * pVehicle->m_pMat->zx)) <= (float)(v21 + 0.35) )
      {
        CEventPotentialGetRunOver::CEventPotentialGetRunOver(&v74, pVehicle);
        CEventGroup::Add((CEventGroup *)(*((_DWORD *)v33.m_pVoid + 272) + 104), (CEvent *)&v74, 0);
        pDriver = pVehicle->pDriver;
        if ( pDriver )
        {
          if ( CPed::IsPlayer(pDriver) )
          {
            v63 = *((_DWORD *)v33.m_pVoid + 272);
            if ( *(_BYTE *)(v63 + 384) )
            {
              if ( *(_BYTE *)(v63 + 385) )
              {
                v64 = CTimer::m_snTimeInMilliseconds;
                *(_BYTE *)(v63 + 385) = 0;
                *(_DWORD *)(v63 + 376) = v64;
                v65 = v64;
              }
              else
              {
                v65 = *(_DWORD *)(v63 + 376);
                v64 = CTimer::m_snTimeInMilliseconds;
              }
              if ( v65 + *(_DWORD *)(v63 + 380) <= v64 )
              {
                *(_DWORD *)(v63 + 376) = v64;
                *(_DWORD *)(v63 + 380) = 3000;
                v70 = *(_BYTE *)(v63 + 372);
                *(_BYTE *)(v63 + 384) = 1;
                *(_BYTE *)(v63 + 372) = v70 + 2;
              }
            }
          }
        }
        CEventPotentialGetRunOver::~CEventPotentialGetRunOver(&v74);
        if ( !m_pHead )
          return;
      }
      else
      {
LABEL_20:
        if ( !m_pHead )
          return;
      }
    }
  }
}
// 2EDF64: variable 'v8' is possibly undefined
// 2EDF64: variable 'v9' is possibly undefined

//----- (002EE1F4) --------------------------------------------------------
void __fastcall CCarCtrl::SlowCarDownForObjectsSectorList(
        CPtrList *list,
        CVehicle *pVehicle,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float *pMaxSpeed,
        float OriginalMaxSpeed)
{
  CPtrNode *m_pHead; // r6
  int v12; // r0
  bool v13; // zf
  CMatrix *m_pMat; // r0
  float *p_x; // r1
  float v16; // r0
  CMatrix *v17; // r1
  float v18; // s0
  CSimpleTransform *p_tx; // r0
  float zy; // s4
  CPtrNode v21; // kr00_8
  CSimpleTransform *p_m_transform; // [sp+10h] [bp-68h]
  CVector v23; // [sp+14h] [bp-64h] BYREF

  m_pHead = list->m_pHead;
  if ( list->m_pHead )
  {
    p_m_transform = &pVehicle->m_transform;
    do
    {
      while ( 1 )
      {
        v21 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        if ( *((unsigned __int16 *)v21.m_pVoid + 24) == CWorld::ms_nCurrentScanCode )
          break;
        v12 = *((__int16 *)v21.m_pVoid + 19);
        *((_WORD *)v21.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        v13 = v12 == MI_ROADWORKBARRIER1;
        if ( v12 != MI_ROADWORKBARRIER1 )
          v13 = v12 == MI_ROADBLOCKFUCKEDCAR1;
        if ( !v13 && v12 != MI_ROADBLOCKFUCKEDCAR2 )
          break;
        CEntity::GetBoundCentre(&v23, (const CEntity *)v21.m_pVoid);
        if ( v23.x <= MinX || v23.x >= MaxX || v23.y <= MinY || v23.y >= MaxY )
          break;
        m_pMat = pVehicle->m_pMat;
        p_x = &p_m_transform->m_translate.x;
        if ( m_pMat )
          p_x = &m_pMat->tx;
        if ( fabsf(v23.z - p_x[2]) >= 10.0 )
          break;
        v16 = CCollision::DistAlongLine2D(*p_x, p_x[1], m_pMat->xy, m_pMat->yy, v23.x, v23.y);
        v17 = pVehicle->m_pMat;
        v18 = v16;
        p_tx = p_m_transform;
        zy = 0.0;
        if ( v17 )
          p_tx = (CSimpleTransform *)&v17->tx;
        if ( v17 )
          zy = v17->zy;
        if ( fabsf(v23.z - (float)(p_tx->m_translate.z + (float)(v18 * zy))) >= 3.0 )
          break;
        CCarCtrl::SlowCarDownForObject((CEntity *)v21.m_pVoid, pVehicle, pMaxSpeed, OriginalMaxSpeed);
        if ( !m_pHead )
          return;
      }
    }
    while ( m_pHead );
  }
}

//----- (002EE374) --------------------------------------------------------
void __fastcall CCarCtrl::ScanForPedDanger(CVehicle *pVehicle)
{
  int v2; // r10
  CVehicle *PlayerVehicle; // r0
  float v4; // s0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  float y; // s4
  float v8; // s20
  float v9; // s22
  float v10; // s16
  float v11; // s18
  float v12; // r9
  float v13; // s24
  float v14; // s26
  int v15; // r4
  int v16; // s0
  int v17; // r1
  int v18; // r1
  uint16 v19; // r0
  float v20; // r2
  int v21; // r8
  float v22; // r6
  __int16 v24; // r1
  __int16 v25; // [sp+14h] [bp-74h]
  int v26; // [sp+20h] [bp-68h]
  int v27; // [sp+24h] [bp-64h]
  float pMaxSpeed[23]; // [sp+2Ch] [bp-5Ch] BYREF

  v2 = 0;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  v4 = 11.0;
  m_pMat = pVehicle->m_pMat;
  if ( PlayerVehicle == pVehicle )
    v4 = 44.0;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  y = p_tx->m_translate.y;
  v8 = p_tx->m_translate.x - v4;
  v9 = y - v4;
  v10 = v4 + p_tx->m_translate.x;
  v11 = v4 + y;
  v12 = floorf((float)(v8 / 50.0) + 60.0);
  v13 = floorf((float)((float)(y - v4) / 50.0) + 60.0);
  v14 = floorf((float)((float)(v4 + y) / 50.0) + 60.0);
  v15 = 119;
  v16 = (int)floorf((float)(v10 / 50.0) + 60.0);
  v25 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75);
  v17 = (int)v14;
  if ( (int)v14 >= 119 )
    v17 = 119;
  v26 = v17;
  if ( v16 < 119 )
    v15 = v16;
  v18 = (int)v13;
  if ( (int)v13 <= 0 )
    v18 = 0;
  v27 = v18;
  if ( (int)v12 > 0 )
    v2 = (int)v12;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v19 = 1;
  }
  else
  {
    v19 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v19;
  pMaxSpeed[0] = (float)pVehicle->AutoPilot.CruiseSpeed;
  if ( v27 <= v26 )
  {
    v20 = v8;
    do
    {
      if ( v2 <= v15 )
      {
        v21 = v2 - 1;
        do
        {
          ++v21;
          v22 = v20;
          CCarCtrl::SlowCarDownForPedsSectorList(
            &CWorld::ms_aRepeatSectors[v21 & 0xF | (unsigned __int8)(16 * v27)].m_ptrListArray[1],
            pVehicle,
            v20,
            v9,
            v10,
            v11,
            pMaxSpeed,
            (float)pVehicle->AutoPilot.CruiseSpeed);
          v20 = v22;
        }
        while ( v21 < v15 );
      }
    }
    while ( v27++ < v26 );
  }
  v24 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75);
  *(_DWORD *)&pVehicle->m_nVehicleFlags |= 0x2000u;
  *(_WORD *)((char *)&pVehicle->AutoPilot + 75) = v25 & 2 | v24 & 0xFFFD;
}
// 2EE374: using guessed type float var_5C[23];

//----- (002EE570) --------------------------------------------------------
void __fastcall CCarCtrl::SlowCarDownForOtherCar(
        CEntity *pEntity,
        CVehicle *pVehicle,
        float *pMaxSpeed,
        float OriginalMaxSpeed)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  float32x2_t v7; // d9
  CMatrix *m_pMat; // r1
  float y; // s18
  float v13; // s2
  float v14; // s20
  CMatrix *v15; // r0
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float z; // s24
  float m_heading; // s28
  float xy; // s26
  float v22; // s4
  float v23; // s2
  float v24; // s6
  float v25; // s10
  float v26; // s18
  __int16 v27; // r0
  CSimpleTransform *v28; // r5
  CMatrix *v29; // r1
  CMatrix *v30; // r0
  float v31; // s18
  float v32; // s22
  float yy; // s20
  float v34; // s24
  CVehicle *PlayerVehicle; // r0
  CEntity::CEntityInfo m_info; // r0
  UInt32 v37; // r0
  CVector v38; // [sp+10h] [bp-70h] BYREF
  CVector pOurFront; // [sp+1Ch] [bp-64h] BYREF

  m_pMat = pVehicle->m_pMat;
  pOurFront.x = m_pMat->xy;
  pOurFront.y = m_pMat->yy;
  y = pOurFront.y;
  v13 = sqrtf((float)(pOurFront.x * pOurFront.x) + (float)(y * y));
  if ( v13 == 0.0 )
  {
    v14 = 1.0;
    pOurFront.x = 1.0;
  }
  else
  {
    y = pOurFront.y / v13;
    v14 = pOurFront.x / v13;
    pOurFront.y = pOurFront.y / v13;
    pOurFront.x = pOurFront.x / v13;
  }
  v15 = pEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  p_m_transform = &pEntity->m_transform;
  if ( v15 )
    p_m_transform = (CSimpleTransform *)&v15->tx;
  if ( (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x) * v14)
             + (float)((float)(p_m_transform->m_translate.y - p_tx->m_translate.y) * y)) >= 0.0 )
  {
    pOurFront.z = 0.0;
    z = pEntity[1].m_transform.m_translate.z;
    m_heading = pEntity[1].m_transform.m_heading;
    if ( v15 )
    {
      xy = v15->xy;
    }
    else
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v15 = pEntity->m_pMat;
      xy = v15->xy;
      if ( !v15 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v15 = pEntity->m_pMat;
      }
    }
    v4.n64_f32[0] = y * OriginalMaxSpeed;
    v38.y = v15->yy;
    v22 = v14 * OriginalMaxSpeed;
    v38.x = xy;
    v23 = m_heading * 60.0;
    v38.z = 0.0;
    v24 = z * 60.0;
    v25 = sqrtf((float)(xy * xy) + (float)(v38.y * v38.y));
    if ( v25 == 0.0 )
    {
      v38.x = 1.0;
    }
    else
    {
      v38.y = v38.y / v25;
      v38.x = xy / v25;
    }
    v7.n64_u32[0] = CCarCtrl::TestCollisionBetween2MovingRects_OnlyFrontBumper(
                      (CVehicle *)pEntity,
                      pVehicle,
                      v24 - v22,
                      v23 - v4.n64_f32[0],
                      &pOurFront,
                      &v38);
    v4.n64_u32[0] = CCarCtrl::TestCollisionBetween2MovingRects(
                      pVehicle,
                      (CVehicle *)pEntity,
                      -(float)(v24 - v22),
                      -(float)(v23 - v4.n64_f32[0]),
                      &v38,
                      &pOurFront);
    v26 = vmin_f32(v7, v4).n64_f32[0];
    if ( v26 < 0.0 || v26 >= 1.5 )
    {
      v28 = &pEntity->m_transform;
    }
    else
    {
      v27 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75);
      pVehicle->AutoPilot.pObstructingEntity = pEntity;
      *(_WORD *)((char *)&pVehicle->AutoPilot + 75) = v27 | 1;
      CEntity::RegisterReference(pEntity, &pVehicle->AutoPilot.pObstructingEntity);
      v4.n64_u32[0] = 1.0;
      if ( v26 >= (float)(1.0 / OriginalMaxSpeed) )
      {
        if ( v26 >= (float)(3.0 / OriginalMaxSpeed) )
        {
          v6.n64_u32[0] = 0;
          v4.n64_f32[0] = (float)(v26 + -0.2) * 0.76923;
          v26 = vmax_f32(v4, v6).n64_f32[0];
          v4.n64_f32[0] = *pMaxSpeed;
          v5.n64_f32[0] = v26 * OriginalMaxSpeed;
          v4.n64_u64[0] = vmin_f32(v4, v5).n64_u64[0];
        }
        else
        {
          v5.n64_f32[0] = *pMaxSpeed;
          v4.n64_u64[0] = vmin_f32(v5, v4).n64_u64[0];
        }
      }
      else
      {
        v4.n64_u32[0] = 0;
      }
      v28 = &pEntity->m_transform;
      *pMaxSpeed = v4.n64_f32[0];
    }
    if ( v26 >= 0.0
      && v26 < 0.5
      && (*(_BYTE *)&pEntity->m_info & 7) == 2
      && CTimer::m_snTimeInMilliseconds - pVehicle->AutoPilot.LastTimeMoving >= 0x3A99
      && CTimer::m_snTimeInMilliseconds - *(_DWORD *)&pEntity[15].m_nScanCode >= 0x3A99 )
    {
      v29 = pVehicle->m_pMat;
      v30 = pEntity->m_pMat;
      v31 = v29->xy;
      if ( !v30 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(v28, pEntity->m_pMat);
        v29 = pVehicle->m_pMat;
        v30 = pEntity->m_pMat;
      }
      v32 = v30->xy;
      yy = v29->yy;
      if ( !v30 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(v28, pEntity->m_pMat);
        v30 = pEntity->m_pMat;
      }
      v34 = v30->yy;
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      if ( pVehicle < pEntity && PlayerVehicle != pEntity && (float)((float)(v31 * v32) + (float)(yy * v34)) < -0.5 )
      {
        v5.n64_f32[0] = *pMaxSpeed;
        v4.n64_f32[0] = OriginalMaxSpeed * 0.2;
        *(_DWORD *)pMaxSpeed = vmax_f32(v5, v4).n64_u32[0];
        m_info = pVehicle->m_info;
        if ( (*(_BYTE *)&m_info & 0xF8) == 16 )
        {
          pVehicle->AutoPilot.TempAction = 0;
          pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
          v37 = CTimer::m_snTimeInMilliseconds;
          pVehicle->m_nNoOfStaticFrames = 0;
          pVehicle->AutoPilot.LastTimeNotStuck = v37 + 2000;
          pVehicle->AutoPilot.LastTimeMoving = v37;
        }
        else
        {
          v37 = CTimer::m_snTimeInMilliseconds;
        }
        pVehicle->AutoPilot.TempActionFinish = v37 + 1000;
        pVehicle->AutoPilot.DrivingMode = 2;
      }
    }
  }
}
// 2EE70E: variable 'v7' is possibly undefined
// 2EE70E: variable 'v4' is possibly undefined
// 2EE776: variable 'v5' is possibly undefined
// 2EE790: variable 'v6' is possibly undefined

//----- (002EE8F0) --------------------------------------------------------
float __fastcall CCarCtrl::TestCollisionBetween2MovingRects_OnlyFrontBumper(
        CVehicle *pHis,
        CVehicle *pOurs,
        float HisSpeedX,
        float HisSpeedY,
        CVector *pOurFront,
        CVector *pHisFront)
{
  float32x2_t v6; // d2
  float v7; // s15
  float v8; // s16
  float32x2_t v9; // d9
  CMatrix *m_pMat; // r5
  float x; // s0
  float y; // s2
  CColModel *m_pColModel; // r4
  float v14; // s6
  float v15; // s4
  CSimpleTransform *p_tx; // r4
  float v17; // s9
  float v18; // s7
  CColModel *v19; // r1
  float v20; // s11
  float v21; // s13
  CMatrix *v23; // r2
  float v25; // s14
  float v26; // s8
  CSimpleTransform *p_m_transform; // r3
  float v28; // s10
  float v29; // s1
  float v30; // s3
  int v31; // r0
  float v32; // s7
  float v33; // s13
  float v34; // s9
  float v35; // s11
  float v36; // s16
  float v37; // s18
  float v38; // s15
  float v39; // s16
  float v40; // s18
  float v41; // s20
  float v42; // s16
  float v43; // s18
  float v44; // s15
  float v45; // s16
  float v46; // s18
  float v47; // s20
  float v48; // s16
  float v49; // s18
  float v50; // s16
  float v51; // s18
  float v52; // s20

  m_pMat = pOurs->m_pMat;
  x = pOurFront->x;
  y = pOurFront->y;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[pOurs->m_nModelIndex]->m_pColModel;
  v14 = m_pColModel->m_boxBound.m_vecMax.y;
  v15 = m_pColModel->m_boxBound.m_vecMax.x;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pOurs->m_transform;
  v17 = v15 * y;
  v18 = v15 * x;
  v6.n64_u32[0] = 1.0;
  v19 = CModelInfo::ms_modelInfoPtrs[pHis->m_nModelIndex]->m_pColModel;
  v20 = p_tx->m_translate.x + (float)(v14 * pOurFront->x);
  v21 = p_tx->m_translate.y + (float)(v14 * y);
  v23 = pHis->m_pMat;
  v25 = -v19->m_boxBound.m_vecMin.y;
  v26 = v19->m_boxBound.m_vecMax.x;
  p_m_transform = (CSimpleTransform *)&v23->tx;
  v28 = v19->m_boxBound.m_vecMax.y;
  if ( !v23 )
    p_m_transform = &pHis->m_transform;
  v29 = v20 - v17;
  v30 = v18 + v21;
  v31 = 0;
  v32 = v21 - v18;
  v33 = p_m_transform->m_translate.y;
  v34 = v20 + v17;
  v35 = p_m_transform->m_translate.x;
  do
  {
    switch ( v31 )
    {
      case 0:
        v36 = pHisFront->y;
        v37 = v28 * v36;
        v38 = v26 * pHisFront->x;
        v39 = v26 * v36;
        v40 = v33 + v37;
        v41 = v35 + (float)(v28 * pHisFront->x);
        goto LABEL_10;
      case 1:
        v42 = pHisFront->y;
        v43 = v28 * v42;
        v44 = v26 * pHisFront->x;
        v45 = v26 * v42;
        v46 = v33 + v43;
        v47 = v35 + (float)(v28 * pHisFront->x);
        goto LABEL_12;
      case 2:
        v48 = pHisFront->y;
        v49 = v48 * v25;
        v38 = v26 * pHisFront->x;
        v39 = v26 * v48;
        v40 = v33 - v49;
        v41 = v35 - (float)(pHisFront->x * v25);
LABEL_10:
        v7 = v40 - v38;
        v8 = v41 + v39;
        break;
      case 3:
        v50 = pHisFront->y;
        v51 = v50 * v25;
        v44 = v26 * pHisFront->x;
        v45 = v26 * v50;
        v46 = v33 - v51;
        v47 = v35 - (float)(pHisFront->x * v25);
LABEL_12:
        v7 = v44 + v46;
        v8 = v47 - v45;
        break;
      default:
        break;
    }
    v9.n64_f32[0] = (float)(x * (float)(v8 - v34)) + (float)(y * (float)(v7 - v32));
    if ( v9.n64_f32[0] > 0.0 )
    {
      v52 = (float)(x * (float)((float)(v8 + HisSpeedX) - v34)) + (float)(y * (float)((float)(v7 + HisSpeedY) - v32));
      if ( v52 < 0.0
        && (float)((float)((float)((float)(v34 - v8) * HisSpeedY) - (float)((float)(v32 - v7) * HisSpeedX))
                 * (float)((float)((float)(v29 - v8) * HisSpeedY) - (float)((float)(v30 - v7) * HisSpeedX))) < 0.0 )
      {
        v9.n64_f32[0] = v9.n64_f32[0] / (float)(v9.n64_f32[0] - v52);
        v6.n64_u64[0] = vmin_f32(v6, v9).n64_u64[0];
      }
    }
    ++v31;
  }
  while ( v31 != 4 );
  return v6.n64_f32[0];
}
// 2EEA34: variable 'v8' is possibly undefined
// 2EEA30: variable 'v7' is possibly undefined
// 2EEAB2: variable 'v6' is possibly undefined
// 2EEAB2: variable 'v9' is possibly undefined

//----- (002EEAD0) --------------------------------------------------------
float __fastcall CCarCtrl::TestCollisionBetween2MovingRects(
        CVehicle *pHis,
        CVehicle *pOurs,
        float HisSpeedX,
        float HisSpeedY,
        CVector *pOurFront,
        CVector *pHisFront)
{
  float32x2_t v6; // d8
  float v7; // s18
  float v8; // s20
  float32x2_t v9; // d12
  unsigned __int64 v10; // d13
  unsigned __int64 v11; // d14
  float32x2_t v12; // d15
  float x; // s0
  float y; // s2
  float v16; // s12
  CMatrix *m_pMat; // r4
  CColModel *m_pColModel; // r2
  float v19; // s10
  float v20; // s4
  float v21; // s8
  float v22; // s12
  float v23; // s6
  CMatrix *v24; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float v27; // s14
  float v28; // s1
  float v29; // s11
  float v30; // s7
  CColModel *v31; // r1
  float v32; // s5
  float v33; // s11
  float v34; // s13
  int v35; // r1
  float v36; // s20
  float v37; // s22
  float v38; // s20
  float v39; // s22
  float v40; // s26
  float v41; // s22
  float v42; // s22
  float v43; // s28
  float v44; // s26
  float v45; // s26
  bool v46; // nf
  unsigned __int32 v47; // s26

  x = pOurFront->x;
  y = pOurFront->y;
  v16 = pOurFront->x * HisSpeedX;
  m_pMat = pHis->m_pMat;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[pOurs->m_nModelIndex]->m_pColModel;
  v19 = v16 + (float)(y * HisSpeedY);
  v20 = m_pColModel->m_boxBound.m_vecMin.y;
  v21 = m_pColModel->m_boxBound.m_vecMax.y;
  v22 = (float)(y * HisSpeedX) - (float)(pOurFront->x * HisSpeedY);
  v23 = m_pColModel->m_boxBound.m_vecMax.x;
  v24 = pOurs->m_pMat;
  p_tx = (CSimpleTransform *)&v24->tx;
  if ( !v24 )
    p_tx = &pOurs->m_transform;
  p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_m_transform = &pHis->m_transform;
  v27 = (float)(v21 - v20) / v19;
  v28 = (float)(v23 + v23) / v22;
  v29 = p_m_transform->m_translate.y;
  v30 = p_m_transform->m_translate.x - p_tx->m_translate.x;
  v31 = CModelInfo::ms_modelInfoPtrs[pHis->m_nModelIndex]->m_pColModel;
  v32 = v29 - p_tx->m_translate.y;
  v33 = v31->m_boxBound.m_vecMax.x;
  v34 = v31->m_boxBound.m_vecMax.y;
  v35 = 0;
  v6.n64_u32[0] = 1.0;
  do
  {
    if ( v35 == 1 )
    {
      v38 = pHisFront->y;
      v39 = v32 + (float)(v34 * v38);
      v8 = (float)(v30 + (float)(v34 * pHisFront->x)) - (float)(v33 * v38);
      v7 = (float)(v33 * pHisFront->x) + v39;
    }
    else if ( !v35 )
    {
      v36 = pHisFront->y;
      v37 = v32 + (float)(v34 * v36);
      v8 = (float)(v30 + (float)(v34 * pHisFront->x)) + (float)(v33 * v36);
      v7 = v37 - (float)(v33 * pHisFront->x);
    }
    v40 = (float)(v8 * y) - (float)(v7 * x);
    if ( v40 <= v23 )
    {
      if ( v40 >= (float)-v23 )
      {
        if ( v22 <= 0.0 )
        {
          v41 = 1.0;
          v9.n64_u32[0] = 0;
          if ( v22 >= 0.0 )
            goto LABEL_26;
          v42 = -(float)(v23 + v40);
        }
        else
        {
          v42 = v23 - v40;
        }
        v41 = v42 / v22;
        v9.n64_u32[0] = 0;
      }
      else
      {
        v41 = 1.0;
        v9.n64_u32[0] = 1.0;
        if ( v22 > 0.0 )
        {
          v9.n64_u32[0] = 1.0;
          *(float *)&v10 = (float)-(float)(v23 + v40) / v22;
          v41 = 1.0;
          if ( *(float *)&v10 < 1.0 )
          {
            v41 = v28 + *(float *)&v10;
            if ( (float)(v28 + *(float *)&v10) >= 1.0 )
              v41 = 1.0;
            goto LABEL_20;
          }
        }
      }
    }
    else
    {
      v41 = 1.0;
      v9.n64_u32[0] = 1.0;
      if ( v22 < 0.0 )
      {
        v9.n64_u32[0] = 1.0;
        *(float *)&v10 = (float)-(float)(v40 - v23) / v22;
        v41 = 1.0;
        if ( *(float *)&v10 < 1.0 )
        {
          v41 = *(float *)&v10 - v28;
          if ( (float)(*(float *)&v10 - v28) >= 1.0 )
            v41 = 1.0;
LABEL_20:
          v9.n64_u64[0] = v10;
        }
      }
    }
LABEL_26:
    v43 = (float)(v8 * x) + (float)(v7 * y);
    if ( v43 <= v21 )
    {
      if ( v43 >= v20 )
      {
        if ( v19 <= 0.0 )
        {
          v44 = 1.0;
          v12.n64_u32[0] = 0;
          if ( v19 >= 0.0 )
            goto LABEL_42;
          v45 = -(float)(v43 - v20);
        }
        else
        {
          v45 = v21 - v43;
        }
        v44 = v45 / v19;
        v12.n64_u32[0] = 0;
      }
      else
      {
        v44 = 1.0;
        v12.n64_u32[0] = 1.0;
        if ( v19 > 0.0 )
        {
          v12.n64_u32[0] = 1.0;
          *(float *)&v11 = (float)-(float)(v43 - v20) / v19;
          v44 = 1.0;
          if ( *(float *)&v11 < 1.0 )
          {
            v44 = v27 + *(float *)&v11;
            if ( (float)(v27 + *(float *)&v11) >= 1.0 )
              v44 = 1.0;
            goto LABEL_36;
          }
        }
      }
    }
    else
    {
      v44 = 1.0;
      v12.n64_u32[0] = 1.0;
      if ( v19 < 0.0 )
      {
        v12.n64_u32[0] = 1.0;
        *(float *)&v11 = (float)-(float)(v43 - v21) / v19;
        v44 = 1.0;
        if ( *(float *)&v11 < 1.0 )
        {
          v44 = *(float *)&v11 - v27;
          if ( (float)(*(float *)&v11 - v27) >= 1.0 )
            v44 = 1.0;
LABEL_36:
          v12.n64_u64[0] = v11;
        }
      }
    }
LABEL_42:
    v9.n64_u64[0] = vmax_f32(v9, v12).n64_u64[0];
    ++v35;
    v11 = vmin_f32(v6, v9).n64_u64[0];
    v46 = v9.n64_f32[0] < v44;
    v47 = v6.n64_u32[0];
    if ( v46 )
      v47 = v11;
    if ( v9.n64_f32[0] < v41 )
      v6.n64_u32[0] = v47;
  }
  while ( v35 != 2 );
  return v6.n64_f32[0];
}
// 2EEBE6: variable 'v8' is possibly undefined
// 2EEBE2: variable 'v7' is possibly undefined
// 2EEC88: variable 'v10' is possibly undefined
// 2EED5E: variable 'v11' is possibly undefined
// 2EED8E: variable 'v9' is possibly undefined
// 2EED8E: variable 'v12' is possibly undefined
// 2EED94: variable 'v6' is possibly undefined

//----- (002EEDD0) --------------------------------------------------------
void __fastcall CCarCtrl::SwitchVehicleToRealPhysics(CVehicle *pVeh)
{
  CEntity::CEntityInfo m_info; // r2
  UInt32 v2; // r1

  m_info = pVeh->m_info;
  pVeh->AutoPilot.TempAction = 0;
  pVeh->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
  v2 = CTimer::m_snTimeInMilliseconds;
  pVeh->m_nNoOfStaticFrames = 0;
  pVeh->AutoPilot.LastTimeNotStuck = v2 + 2000;
  pVeh->AutoPilot.LastTimeMoving = v2;
}

//----- (002EEE00) --------------------------------------------------------
void __fastcall CCarCtrl::SlowCarDownForObject(
        CEntity *pEntity,
        CVehicle *pVehicle,
        float *pMaxSpeed,
        float OriginalMaxSpeed)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d2
  CMatrix *m_pMat; // r12
  CMatrix *v7; // lr
  CSimpleTransform *p_tx; // r4
  CSimpleTransform *p_m_transform; // r5
  float v10; // s4
  float v11; // s2
  float v12; // s6
  unsigned __int32 v13; // s0

  m_pMat = pVehicle->m_pMat;
  v7 = pEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  p_m_transform = (CSimpleTransform *)&v7->tx;
  if ( !v7 )
    p_m_transform = &pEntity->m_transform;
  v10 = p_m_transform->m_translate.y - p_tx->m_translate.y;
  v11 = p_m_transform->m_translate.x - p_tx->m_translate.x;
  v12 = p_m_transform->m_translate.z - p_tx->m_translate.z;
  v4.n64_f32[0] = (float)((float)(v11 * m_pMat->xy) + (float)(v10 * m_pMat->yy)) + (float)(v12 * m_pMat->zy);
  if ( v4.n64_f32[0] > 0.0
    && v4.n64_f32[0] < 20.0
    && fabsf((float)((float)(v11 * m_pMat->xx) + (float)(v10 * m_pMat->yx)) + (float)(v12 * m_pMat->zx)) < (float)(CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius + CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x) )
  {
    if ( v4.n64_f32[0] >= 7.0 )
    {
      v5.n64_f32[0] = *pMaxSpeed;
      v4.n64_f32[0] = (float)((float)((float)(v4.n64_f32[0] + -7.0) / -13.0) + 1.0) * OriginalMaxSpeed;
      v13 = vmin_f32(v5, v4).n64_u32[0];
    }
    else
    {
      v13 = 0;
    }
    *(_DWORD *)pMaxSpeed = v13;
  }
}
// 2EEF0E: variable 'v5' is possibly undefined
// 2EEF0E: variable 'v4' is possibly undefined

//----- (002EEF20) --------------------------------------------------------
float __fastcall CCarCtrl::FindAngleToWeaveThroughTraffic(
        CVehicle *pVehicle,
        CPhysical *pException,
        float Direction,
        float CarOrientation,
        float CheckDistMult)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d3
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r1
  float y; // s4
  float v13; // s0
  float v14; // s18
  float v15; // s20
  float v16; // s22
  float v17; // s24
  float v18; // s28
  float v19; // r10
  float v20; // r4
  float v21; // r0
  int v22; // r2
  float v23; // s16
  int v24; // s2
  int v25; // r0
  int v26; // r4
  int v27; // r2
  uint16 v28; // r0
  float v29; // s0
  float v30; // s26
  float v31; // s2
  float v32; // r5
  float v33; // s30
  float v34; // s17
  int v35; // r0
  int v36; // r0
  CPhysical *v37; // r8
  int v38; // r9
  CPtrNode *m_pHead; // r11
  CPtrNode v40; // kr00_8
  bool v41; // zf
  int v42; // r2
  float *v43; // r1
  float v44; // s0
  CMatrix *v45; // r2
  float v46; // s0
  CSimpleTransform *p_tx; // r1
  CVehicle *v48; // r1
  bool v49; // zf
  bool v51; // fzf
  float i; // s4
  float j; // s4
  float k; // s10
  float m; // s12
  float n; // s6
  float v57; // s8
  int v59; // [sp+14h] [bp-A4h]
  int v61; // [sp+1Ch] [bp-9Ch]
  int v62; // [sp+20h] [bp-98h]
  int v63; // [sp+24h] [bp-94h]
  CSimpleTransform *v64; // [sp+2Ch] [bp-8Ch]
  int v65; // [sp+44h] [bp-74h]
  CRepeatSector *list; // [sp+48h] [bp-70h]
  int v67; // [sp+4Ch] [bp-6Ch]
  float pRightAngle; // [sp+50h] [bp-68h] BYREF
  float pLeftAngle[25]; // [sp+54h] [bp-64h] BYREF

  v6.n64_u32[0] = 2.0;
  m_pMat = pVehicle->m_pMat;
  p_m_transform = &pVehicle->m_transform;
  v64 = &pVehicle->m_transform;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  v5.n64_f32[0] = (float)(sqrtf(
                            (float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                          + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                        / 0.4)
                + 1.0;
  y = p_m_transform->m_translate.y;
  v13 = (float)(vmin_f32(v5, v6).n64_f32[0] * 12.0) * CheckDistMult;
  v14 = p_m_transform->m_translate.x - v13;
  v15 = y - v13;
  v16 = p_m_transform->m_translate.x + v13;
  v17 = y + v13;
  v18 = floorf((float)(v14 / 50.0) + 60.0);
  v19 = floorf((float)((float)(y - v13) / 50.0) + 60.0);
  v20 = floorf((float)(v16 / 50.0) + 60.0);
  v21 = floorf((float)((float)(y + v13) / 50.0) + 60.0);
  pRightAngle = Direction;
  v22 = 119;
  v23 = Direction;
  pLeftAngle[0] = Direction;
  v24 = (int)v20;
  v25 = (int)v21;
  v26 = (int)v19;
  if ( v25 >= 119 )
    v25 = 119;
  v61 = v25;
  if ( v24 < 119 )
    v22 = v24;
  v65 = v22;
  v27 = 0;
  if ( v26 <= 0 )
    v26 = 0;
  if ( (int)v18 > 0 )
    v27 = (int)v18;
  v62 = v27;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v28 = 1;
  }
  else
  {
    v28 = CWorld::ms_nCurrentScanCode + 1;
  }
  v29 = -9999.9;
  v30 = CarOrientation;
  v31 = -9999.9;
  CWorld::ms_nCurrentScanCode = v28;
  if ( Direction != -9999.9 )
  {
    v32 = v14;
    v29 = Direction;
    v59 = v26;
    v33 = Direction;
    while ( 1 )
    {
      v34 = v29;
      v31 = v33;
      if ( v26 <= v61 )
      {
        v63 = v26;
        do
        {
          if ( v62 <= v65 )
          {
            v35 = v62;
            do
            {
              v67 = v35;
              v36 = v35 & 0xF | (unsigned __int8)(16 * v63);
              v37 = pException;
              v38 = v36;
              list = &CWorld::ms_aRepeatSectors[v36];
              CCarCtrl::WeaveThroughCarsSectorList(
                (CPtrList *)list,
                pVehicle,
                pException,
                v32,
                v15,
                v16,
                v17,
                pLeftAngle,
                &pRightAngle);
              if ( pVehicle->AutoPilot.DrivingMode != 6 )
              {
                m_pHead = CWorld::ms_aRepeatSectors[v38].m_ptrListArray[1].m_pHead;
                while ( m_pHead )
                {
                  v40 = *m_pHead;
                  m_pHead = m_pHead->m_pNext;
                  if ( *((unsigned __int16 *)v40.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
                  {
                    v41 = v40.m_pVoid == v37;
                    if ( v40.m_pVoid != v37 )
                      v41 = (*((_DWORD *)v40.m_pVoid + 7) & 1) == 0;
                    if ( !v41 )
                    {
                      v42 = *((_DWORD *)v40.m_pVoid + 5);
                      *((_WORD *)v40.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                      v43 = (float *)(v42 + 48);
                      if ( !v42 )
                        v43 = (float *)((char *)v40.m_pVoid + 4);
                      if ( *v43 > v14 && *v43 < v16 )
                      {
                        v44 = v43[1];
                        if ( v44 > v15 && v44 < v17 )
                        {
                          v45 = pVehicle->m_pMat;
                          v46 = v43[2];
                          p_tx = v64;
                          if ( v45 )
                            p_tx = (CSimpleTransform *)&v45->tx;
                          if ( fabsf(v46 - p_tx->m_translate.z) < 4.0 )
                          {
                            v48 = (CVehicle *)*((_DWORD *)v40.m_pVoid + 354);
                            v49 = v48 == pVehicle;
                            if ( v48 != pVehicle )
                              v49 = *((_DWORD *)v40.m_pVoid + 64) == (_DWORD)pVehicle;
                            if ( !v49 )
                              CCarCtrl::WeaveForPed((CEntity *)v40.m_pVoid, pVehicle, pLeftAngle, &pRightAngle);
                          }
                        }
                      }
                    }
                  }
                }
              }
              v32 = v14;
              CCarCtrl::WeaveThroughObjectsSectorList(
                &CWorld::ms_aRepeatSectors[v38].m_ptrListArray[2],
                pVehicle,
                v14,
                v15,
                v16,
                v17,
                pLeftAngle,
                &pRightAngle);
              pException = v37;
              CCarCtrl::WeaveThroughCarsSectorList(
                (CPtrList *)list,
                pVehicle,
                v37,
                v14,
                v15,
                v16,
                v17,
                pLeftAngle,
                &pRightAngle);
              v35 = v67 + 1;
            }
            while ( v67 < v65 );
          }
        }
        while ( v63++ < v61 );
        v26 = v59;
        v29 = pRightAngle;
        v31 = pLeftAngle[0];
      }
      v51 = v33 == v31;
      v33 = v31;
      if ( v51 )
      {
        v33 = v31;
        if ( v34 == v29 )
          break;
      }
    }
  }
  for ( i = v30 - v23; i < -3.1416; i = i + 6.2832 )
    ;
  for ( ; i > 3.1416; i = i + -6.2832 )
    ;
  for ( j = (float)(i * 0.5) + v23; j < -3.1416; j = j + 6.2832 )
    ;
  for ( ; j > 3.1416; j = j + -6.2832 )
    ;
  for ( k = v31 - j; k < -3.1416; k = k + 6.2832 )
    ;
  for ( m = v29 - j; k > 3.1416; k = k + -6.2832 )
    ;
  for ( ; m < -3.1416; m = m + 6.2832 )
    ;
  for ( n = fabsf(k); m > 3.1416; m = m + -6.2832 )
    ;
  v57 = fabsf(m);
  if ( n <= 1.5708 )
  {
    if ( fabsf(n - v57) >= 0.08 )
    {
      j = v31;
      if ( n >= v57 )
        return v29;
    }
    else
    {
      return v29;
    }
  }
  return j;
}
// 2EEF82: variable 'v5' is possibly undefined
// 2EEF82: variable 'v6' is possibly undefined

//----- (002EF408) --------------------------------------------------------
void __fastcall CCarCtrl::WeaveThroughCarsSectorList(
        CPtrList *list,
        CVehicle *pVehicle,
        CPhysical *pException,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float *pLeftAngle,
        float *pRightAngle)
{
  CPtrNode *m_pHead; // r5
  CPtrNode v13; // kr00_8
  int v14; // r1
  bool v15; // zf
  CMatrix *m_pMat; // r1
  int v17; // r2
  CSimpleTransform *p_tx; // r0
  float *v19; // r1
  bool v20; // nf
  CVector v21; // [sp+4h] [bp-54h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    while ( 1 )
    {
      v13 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v14 = *((unsigned __int16 *)v13.m_pVoid + 24);
      v15 = v14 == CWorld::ms_nCurrentScanCode;
      if ( v14 != CWorld::ms_nCurrentScanCode )
        v15 = v13.m_pVoid == pException;
      if ( !v15 && (*((_DWORD *)v13.m_pVoid + 7) & 1) != 0 )
      {
        *((_WORD *)v13.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        CEntity::GetBoundCentre(&v21, (const CEntity *)v13.m_pVoid);
        if ( v21.x > MinX && v21.x < MaxX && v21.y > MinY && v21.y < MaxY )
        {
          m_pMat = pVehicle->m_pMat;
          v17 = *((_DWORD *)v13.m_pVoid + 5);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pVehicle->m_transform;
          v19 = (float *)(v17 + 48);
          if ( !v17 )
            v19 = (float *)((char *)v13.m_pVoid + 4);
          if ( v13.m_pVoid != pVehicle && fabsf(v19[2] - p_tx->m_translate.z) < 8.0 )
          {
            v20 = (*((_BYTE *)&pVehicle->m_nVehicleFlags + 3) & 8) != 0;
            if ( (*((_BYTE *)&pVehicle->m_nVehicleFlags + 3) & 8) != 0 )
              v20 = (*((_BYTE *)v13.m_pVoid + 1071) & 8) != 0;
            if ( !v20 )
              break;
          }
        }
      }
      if ( !m_pHead )
        return;
    }
    CCarCtrl::WeaveForOtherCar((CEntity *)v13.m_pVoid, pVehicle, pLeftAngle, pRightAngle);
  }
}

//----- (002EF510) --------------------------------------------------------
void __fastcall CCarCtrl::WeaveThroughPedsSectorList(
        CPtrList *list,
        CVehicle *pVehicle,
        CPhysical *pException,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float *pLeftAngle,
        float *pRightAngle)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v13; // kr00_8
  int v14; // r2
  bool v15; // zf
  int v16; // r2
  float *v17; // r1
  float v18; // s0
  CMatrix *m_pMat; // r2
  float v20; // s0
  CSimpleTransform *p_tx; // r1
  CVehicle *v22; // r1
  bool v23; // zf

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    while ( 1 )
    {
      v13 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v14 = *((unsigned __int16 *)v13.m_pVoid + 24);
      v15 = v14 == CWorld::ms_nCurrentScanCode;
      if ( v14 != CWorld::ms_nCurrentScanCode )
        v15 = v13.m_pVoid == pException;
      if ( !v15 && (*((_DWORD *)v13.m_pVoid + 7) & 1) != 0 )
      {
        v16 = *((_DWORD *)v13.m_pVoid + 5);
        *((_WORD *)v13.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        v17 = (float *)(v16 + 48);
        if ( !v16 )
          v17 = (float *)((char *)v13.m_pVoid + 4);
        if ( *v17 > MinX && *v17 < MaxX )
        {
          v18 = v17[1];
          if ( v18 > MinY && v18 < MaxY )
          {
            m_pMat = pVehicle->m_pMat;
            v20 = v17[2];
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &pVehicle->m_transform;
            if ( fabsf(v20 - p_tx->m_translate.z) < 4.0 )
            {
              v22 = (CVehicle *)*((_DWORD *)v13.m_pVoid + 354);
              v23 = v22 == pVehicle;
              if ( v22 != pVehicle )
                v23 = *((_DWORD *)v13.m_pVoid + 64) == (_DWORD)pVehicle;
              if ( !v23 )
                break;
            }
          }
        }
      }
      if ( !m_pHead )
        return;
    }
    CCarCtrl::WeaveForPed((CEntity *)v13.m_pVoid, pVehicle, pLeftAngle, pRightAngle);
  }
}

//----- (002EF5F8) --------------------------------------------------------
void __fastcall CCarCtrl::WeaveThroughObjectsSectorList(
        CPtrList *list,
        CVehicle *pVehicle,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float *pLeftAngle,
        float *pRightAngle)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v12; // kr00_8
  int v13; // r0
  bool v14; // zf
  int v15; // r0
  float *v16; // r1
  float v17; // s0
  CMatrix *m_pMat; // r2
  float v19; // s0
  CSimpleTransform *p_tx; // r1

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    while ( 1 )
    {
      v12 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v13 = *((unsigned __int16 *)v12.m_pVoid + 24);
      v14 = v13 == CWorld::ms_nCurrentScanCode;
      if ( v13 != CWorld::ms_nCurrentScanCode )
        v14 = *((unsigned __int8 *)v12.m_pVoid + 28) << 31 == 0;
      if ( !v14 )
      {
        v15 = *((_DWORD *)v12.m_pVoid + 5);
        *((_WORD *)v12.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        v16 = (float *)((char *)v12.m_pVoid + 4);
        if ( v15 )
          v16 = (float *)(v15 + 48);
        if ( *v16 > MinX && *v16 < MaxX )
        {
          v17 = v16[1];
          if ( v17 > MinY && v17 < MaxY )
          {
            m_pMat = pVehicle->m_pMat;
            v19 = v16[2];
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &pVehicle->m_transform;
            if ( fabsf(v19 - p_tx->m_translate.z) < 8.0 )
            {
              if ( !v15 )
              {
                CPlaceable::AllocateMatrix((CPlaceable *)v12.m_pVoid);
                CSimpleTransform::UpdateMatrix(
                  (const CSimpleTransform *)((char *)v12.m_pVoid + 4),
                  *((CMatrix **)v12.m_pVoid + 5));
                v15 = *((_DWORD *)v12.m_pVoid + 5);
              }
              if ( *(float *)(v15 + 40) > 0.9 )
                break;
            }
          }
        }
      }
      if ( !m_pHead )
        return;
    }
    CCarCtrl::WeaveForObject((CEntity *)v12.m_pVoid, pVehicle, pLeftAngle, pRightAngle);
  }
}

//----- (002EF6FC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall TestForThisAngle(
        float Angle,
        CVector *pLine1Start,
        CVector *pLine1Delta,
        CVector *pLine2Start,
        CVector *pLine2Delta,
        CVector *pLine1Start_Other,
        CVector *pLine1Delta_Other,
        CVector *pLine2Start_Other,
        CVector *pLine2Delta_Other,
        float OtherCarMoveSpeedX,
        float OtherCarMoveSpeedY,
        float OurMoveSpeed,
        int bSwapRound)
{
  float v17; // r5
  float v18; // s2
  float v19; // s0
  unsigned __int64 v20; // r10
  CVector *v21; // r4
  CVector *v22; // r5
  float v23; // s18
  float v24; // s16
  CVector *v25; // r0
  CVector *v26; // r1
  float x; // s17
  float y; // s2
  float v29; // s19
  float v30; // s22
  float v31; // s20
  float v32; // s24
  float v33; // s26
  float v34; // s28
  float v35; // s30
  float v36; // s28
  float v37; // s30
  float v38; // s2
  float v39; // s22
  float v40; // s20
  float v41; // s24
  float v42; // s26
  float v43; // s21
  float v44; // s23
  float v45; // s18
  float v46; // s16
  CVector *v48; // [sp+1Ch] [bp-64h]

  v17 = cosf(Angle);
  v18 = sinf(Angle) * OurMoveSpeed;
  v19 = v17 * OurMoveSpeed;
  v20 = *(_QWORD *)&pLine2Start_Other;
  v21 = pLine1Start_Other;
  v22 = pLine1Delta_Other;
  v23 = (float)(OtherCarMoveSpeedY - v18) * 100.0;
  v24 = (float)(OtherCarMoveSpeedX - v19) * 100.0;
  if ( bSwapRound == 1 )
  {
    v23 = -v23;
    v25 = pLine1Delta;
    v24 = -v24;
    v26 = pLine1Start;
    v48 = pLine2Delta;
  }
  else
  {
    v48 = pLine2Delta_Other;
    v25 = pLine1Delta_Other;
    v26 = pLine1Start_Other;
    v20 = __PAIR64__((unsigned int)pLine2Delta, (unsigned int)pLine2Start);
    pLine2Start = pLine2Start_Other;
    v22 = pLine1Delta;
    v21 = pLine1Start;
  }
  x = v26->x;
  y = v25->y;
  v29 = v26->y;
  v30 = v26->x + v25->x;
  v31 = v29 + y;
  if ( CCollision::Test2DLineAgainst2DLine(v21->x, v21->y, v22->x, v22->y, x, v29, v30 - x, (float)(v29 + y) - v29) )
    return 1;
  v32 = v23 + v29;
  v33 = v24 + x;
  if ( CCollision::Test2DLineAgainst2DLine(
         v21->x,
         v21->y,
         v22->x,
         v22->y,
         v30,
         v29 + y,
         (float)(v24 + x) - v30,
         (float)(v23 + v29) - v31) )
  {
    return 1;
  }
  v34 = v23 + v31;
  v35 = v24 + v30;
  if ( CCollision::Test2DLineAgainst2DLine(
         v21->x,
         v21->y,
         v22->x,
         v22->y,
         v24 + x,
         v23 + v29,
         (float)(v24 + v30) - v33,
         (float)(v23 + v31) - v32) )
  {
    return 1;
  }
  if ( CCollision::Test2DLineAgainst2DLine(v21->x, v21->y, v22->x, v22->y, v24 + v30, v23 + v31, x - v35, v29 - v34) )
    return 1;
  if ( CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         x,
         v29,
         v30 - x,
         (float)(v29 + y) - v29) )
  {
    return 1;
  }
  if ( CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         v30,
         v31,
         (float)(v24 + x) - v30,
         (float)(v23 + v29) - v31) )
  {
    return 1;
  }
  if ( CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         v24 + x,
         v23 + v29,
         (float)(v24 + v30) - v33,
         (float)(v23 + v31) - v32) )
  {
    return 1;
  }
  if ( CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         v24 + v30,
         v23 + v31,
         x - v35,
         v29 - v34) )
  {
    return 1;
  }
  v36 = pLine2Start->x;
  v37 = pLine2Start->y;
  v38 = v48->y;
  v39 = pLine2Start->x + v48->x;
  v40 = v37 + v38;
  if ( CCollision::Test2DLineAgainst2DLine(
         v21->x,
         v21->y,
         v22->x,
         v22->y,
         pLine2Start->x,
         v37,
         v39 - pLine2Start->x,
         (float)(v37 + v38) - v37) )
  {
    return 1;
  }
  v41 = v23 + v37;
  v42 = v24 + v36;
  v43 = (float)(v23 + v37) - v40;
  v44 = (float)(v24 + v36) - v39;
  if ( CCollision::Test2DLineAgainst2DLine(v21->x, v21->y, v22->x, v22->y, v39, v37 + v38, v44, v43) )
    return 1;
  v45 = v23 + v40;
  v46 = v24 + v39;
  if ( CCollision::Test2DLineAgainst2DLine(v21->x, v21->y, v22->x, v22->y, v42, v41, v46 - v42, v45 - v41)
    || CCollision::Test2DLineAgainst2DLine(v21->x, v21->y, v22->x, v22->y, v46, v45, v36 - v46, v37 - v45)
    || CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         v36,
         v37,
         v39 - v36,
         (float)(v37 + v38) - v37)
    || CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         v39,
         v37 + v38,
         v44,
         v43)
    || CCollision::Test2DLineAgainst2DLine(
         *(float *)v20,
         *(float *)(v20 + 4),
         *(float *)HIDWORD(v20),
         *(float *)(HIDWORD(v20) + 4),
         v42,
         v41,
         v46 - v42,
         v45 - v41) )
  {
    return 1;
  }
  else
  {
    return CCollision::Test2DLineAgainst2DLine(
             *(float *)v20,
             *(float *)(v20 + 4),
             *(float *)HIDWORD(v20),
             *(float *)(HIDWORD(v20) + 4),
             v46,
             v45,
             v36 - v46,
             v37 - v45);
  }
}
// 2EF6FC: variables would overlap: ^94.4 and ^94.8

//----- (002EFA40) --------------------------------------------------------
bool __fastcall CCarCtrl::PickNextNodeToChaseCar(
        CVehicle *pVehicle,
        float CarX,
        float CarY,
        float CarZ,
        CVehicle *pCarWeChase)
{
  __int128 v5; // q8
  unsigned int ForcedRandomSeed; // r0
  CNodeAddress StartNode; // r1
  float v12; // s20
  unsigned int v13; // r11
  int v14; // s2
  char *v15; // r8
  __int16 *v16; // r3
  unsigned __int16 *v17; // r5
  int v18; // s6
  int v19; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  _DWORD *v22; // r3
  bool v23; // zf
  __int16 v24; // r8
  UInt16 v25; // r4
  CNodeAddress *v26; // r1
  int v27; // r2
  bool v28; // zf
  CNodeAddress *v29; // r1
  int v30; // r2
  CMatrix *v31; // r0
  CSimpleTransform *p_m_transform; // r1
  float ATanOfXY; // r0
  int *j; // r12
  int v35; // r1
  int v36; // r4
  float v37; // s18
  UInt16 v38; // r5
  float v39; // s20
  __int16 v40; // r11
  int v41; // r0
  __int16 *v42; // r1
  CNodeAddress v43; // r10
  CPathNode *v44; // r0
  float i; // s0
  float v46; // s0
  CNodeAddress v47; // r1
  CNodeAddress NewNode; // r12
  __int64 v49; // r2
  UInt16 Address; // r0
  unsigned int InvertDirOldLink; // r5
  Int8 InvertDirNewLink; // r6
  Int8 NewLane; // lr
  unsigned int v54; // r1
  unsigned int v55; // r2
  CPathNode *v56; // r0
  bool v57; // zf
  unsigned int v58; // r6
  CPathNode *v59; // r0
  bool v60; // zf
  CPathNode *v61; // r0
  bool v62; // zf
  int v63; // r2
  CCarPathLink *v64; // r5
  int v66; // r4
  float32x2_t v67; // d16
  unsigned __int64 v68; // d0
  int v69; // r0
  __int16 v70; // r2
  Int8 v71; // r1
  Int8 v72; // r0
  char v73; // r0
  Int8 v74; // r1
  char v75; // r2
  CVector v76; // [sp+8h] [bp-D0h]
  unsigned int v77; // [sp+40h] [bp-98h]
  __int16 v78; // [sp+48h] [bp-90h]
  unsigned int Region; // [sp+4Ch] [bp-8Ch]
  CPathFind *v80; // [sp+50h] [bp-88h]
  unsigned __int16 v81; // [sp+50h] [bp-88h]
  CNodeAddress OldNode; // [sp+58h] [bp-80h]
  int *v83; // [sp+5Ch] [bp-7Ch]
  int v84; // [sp+64h] [bp-74h]
  float pDistance; // [sp+70h] [bp-68h] BYREF
  unsigned __int16 v86; // [sp+76h] [bp-62h] BYREF
  unsigned int v87; // [sp+78h] [bp-60h] BYREF
  unsigned int v88; // [sp+7Ch] [bp-5Ch]
  CVector v89; // 0:r2.8,8:^0.4

  LOWORD(v88) = -1;
  LOWORD(v87) = -1;
  ForcedRandomSeed = pVehicle->ForcedRandomSeed;
  if ( ForcedRandomSeed )
    srand(ForcedRandomSeed);
  OldNode = pVehicle->AutoPilot.OldNode;
  StartNode = pVehicle->AutoPilot.NewNode;
  v12 = CarX;
  v13 = HIWORD(*(unsigned int *)&StartNode);
  if ( ((unsigned __int16)CWeather::WeatherRegion | 4) == 4 )
    v14 = 1112014848;
  else
    v14 = 1232348158;
  Region = StartNode.Region;
  v15 = (char *)&ThePaths + 4 * StartNode.Region;
  v84 = 7 * HIWORD(*(unsigned int *)&StartNode);
  v16 = (__int16 *)(*((_DWORD *)v15 + 513) + 28 * HIWORD(*(unsigned int *)&StartNode));
  v17 = &v86;
  v89.x = (float)v16[4] * 0.125;
  v18 = v16[6];
  v89.y = (float)v16[5] * 0.125;
  v76.x = v12;
  *(_QWORD *)&v76.y = __PAIR64__(LODWORD(CarZ), LODWORD(CarY));
  v89.z = (float)v18 * 0.125;
  CPathFind::DoPathSearch(
    &ThePaths,
    0.0,
    v89,
    StartNode,
    v76,
    (CNodeAddress *)&v87,
    (Int16 *)&v86,
    2,
    &pDistance,
    *(float *)&v14,
    0,
    1000000.0,
    0,
    EmptyNodeAddress,
    pVehicle->m_nModelIndex == 539,
    0);
  if ( ((unsigned __int16)CWeather::WeatherRegion | 4) == 4 )
  {
    v19 = v86;
    if ( !v86 )
      return 1;
    m_pMat = pVehicle->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pVehicle->m_transform;
    if ( pDistance > (float)(sqrtf(
                               (float)((float)(v12 - p_tx->m_translate.x) * (float)(v12 - p_tx->m_translate.x))
                             + (float)((float)(CarY - p_tx->m_translate.y) * (float)(CarY - p_tx->m_translate.y)))
                           * 3.0) )
      return 1;
  }
  else
  {
    v19 = v86;
  }
  v22 = v15 + 2052;
  v83 = (int *)(v15 + 2052);
  if ( (unsigned __int16)(v19 - 1) <= 1u )
  {
    v23 = (unsigned __int16)v87 == Region;
    if ( (unsigned __int16)v87 == Region )
      v23 = HIWORD(v87) == v13;
    if ( !v23 )
    {
      v24 = 0;
      v25 = v87;
      v17 = (unsigned __int16 *)HIWORD(v87);
      v26 = ThePaths.pAdjacentNodes[Region];
      while ( 1 )
      {
        v27 = *(__int16 *)(*v22 + 4 * v84 + 16) + v24;
        if ( v26[v27].Region == (unsigned __int16)v87 && (unsigned __int16 *)v26[v27].Index == v17 )
          break;
        ++v24;
      }
      goto LABEL_50;
    }
    if ( v19 == 2 )
    {
      v28 = (unsigned __int16)v88 == Region;
      if ( (unsigned __int16)v88 == Region )
        v28 = HIWORD(v88) == v13;
      if ( !v28 )
      {
        v24 = 0;
        v25 = v88;
        v17 = (unsigned __int16 *)HIWORD(v88);
        v29 = ThePaths.pAdjacentNodes[Region];
        while ( 1 )
        {
          v30 = *(__int16 *)(*v22 + 4 * v84 + 16) + v24;
          if ( v29[v30].Region == (unsigned __int16)v88 && (unsigned __int16 *)v29[v30].Index == v17 )
            break;
          ++v24;
        }
        goto LABEL_50;
      }
    }
  }
  v31 = pVehicle->m_pMat;
  p_m_transform = (CSimpleTransform *)&v31->tx;
  if ( !v31 )
    p_m_transform = &pVehicle->m_transform;
  ATanOfXY = CGeneral::GetATanOfXY(v12 - p_m_transform->m_translate.x, CarY - p_m_transform->m_translate.y);
  j = (int *)(v15 + 2052);
  v35 = *v83;
  v36 = *(_WORD *)(*v83 + 4 * v84 + 24) & 0xF;
  if ( v36 )
  {
    v77 = v13;
    v37 = ATanOfXY;
    v38 = OldNode.Region;
    v39 = 10.0;
    v40 = 0;
    v24 = 0;
    v41 = 0;
    v80 = &ThePaths;
    v78 = -1;
    while ( 1 )
    {
      v42 = (__int16 *)(v35 + 4 * v84);
      v43 = ThePaths.pAdjacentNodes[Region][v41 + v42[8]];
      if ( v43.Region != v38 || v36 == 1 || HIWORD(*(unsigned int *)&v43) != HIWORD(*(unsigned int *)&OldNode) )
      {
        v44 = ThePaths.pNodes[v43.Region];
        if ( v44 )
        {
          for ( i = CGeneral::GetATanOfXY(
                      (float)((float)v44[HIWORD(*(unsigned int *)&v43)].CoorsX * 0.125) - (float)((float)v42[4] * 0.125),
                      (float)((float)v44[HIWORD(*(unsigned int *)&v43)].CoorsY * 0.125) - (float)((float)v42[5] * 0.125))
                  - v37; i > 3.1416; i = i + -6.2832 )
            ;
          for ( j = v83; i < -3.1416; i = i + 6.2832 )
            ;
          v46 = fabsf(i);
          v38 = OldNode.Region;
          if ( v46 <= v39 )
          {
            v78 = v43.Region;
            v80 = (CPathFind *)HIWORD(*(unsigned int *)&v43);
            v39 = v46;
            v24 = v40;
          }
        }
      }
      v41 = ++v40;
      if ( v40 >= v36 )
        break;
      v35 = *j;
    }
    v13 = v77;
    LOWORD(v17) = (_WORD)v80;
    v25 = v78;
  }
  else
  {
    v24 = 0;
    v25 = -1;
  }
LABEL_50:
  v47 = pVehicle->AutoPilot.OldNode;
  NewNode = pVehicle->AutoPilot.NewNode;
  v49 = *(_QWORD *)&pVehicle->AutoPilot.TimeToLeaveLink;
  Address = pVehicle->AutoPilot.OldLink.Address;
  v81 = (unsigned __int16)v17;
  InvertDirOldLink = (unsigned __int8)pVehicle->AutoPilot.InvertDirOldLink;
  pVehicle->AutoPilot.NewNode = (CNodeAddress)v25;
  InvertDirNewLink = pVehicle->AutoPilot.InvertDirNewLink;
  pVehicle->AutoPilot.VeryOldLink.Address = Address;
  NewLane = pVehicle->AutoPilot.NewLane;
  pVehicle->AutoPilot.VeryOldNode = v47;
  pVehicle->AutoPilot.OldNode = NewNode;
  pVehicle->AutoPilot.InvertDirOldLink = InvertDirNewLink;
  v54 = pVehicle->AutoPilot.NewLink.Address;
  pVehicle->AutoPilot.OldLane = NewLane;
  pVehicle->AutoPilot.OldLink.Address = v54;
  pVehicle->AutoPilot.InvertDirVeryOldLink = InvertDirOldLink;
  pVehicle->AutoPilot.TimeToLeaveLink = v49 + HIDWORD(v49);
  v55 = ThePaths.pAdjacentLinks[Region][*(__int16 *)(*v83 + 4 * v84 + 16) + v24].Address;
  pVehicle->AutoPilot.NewLink.Address = v55;
  if ( v54 == 0xFFFF )
    goto LABEL_65;
  v56 = ThePaths.pNodes[v54 >> 10];
  v57 = v56 == 0;
  if ( v56 )
    v57 = v55 == 0xFFFF;
  if ( v57 )
    goto LABEL_65;
  v58 = v55 >> 10;
  v59 = ThePaths.pNodes[v55 >> 10];
  v60 = v59 == 0;
  if ( v59 )
  {
    InvertDirOldLink = NewNode.Region;
    v60 = NewNode.Region == 0xFFFF;
  }
  if ( v60 )
    goto LABEL_65;
  v61 = ThePaths.pNodes[InvertDirOldLink];
  v62 = v61 == 0;
  if ( v61 )
  {
    InvertDirOldLink = v25;
    v62 = v25 == 0xFFFF;
  }
  if ( v62 || !ThePaths.pNodes[InvertDirOldLink] )
  {
LABEL_65:
    *(_WORD *)((char *)&pVehicle->AutoPilot + 75) |= 0x100u;
    return 1;
  }
  if ( InvertDirOldLink > Region || InvertDirOldLink == Region && v81 > v13 )
  {
    v63 = v55 & 0x3FF;
    pVehicle->AutoPilot.InvertDirNewLink = -1;
    v64 = ThePaths.pLinks[v58];
    LOWORD(v58) = *(_WORD *)((char *)&v64[v63] + 11);
  }
  else
  {
    v63 = v55 & 0x3FF;
    pVehicle->AutoPilot.InvertDirNewLink = 1;
    v64 = ThePaths.pLinks[v58];
    v58 = *(unsigned __int16 *)((char *)&v64[v63] + 11) >> 3;
  }
  v66 = v58 & 7;
  LODWORD(v5) = *(_DWORD *)&v64[v63].CoorsX;
  DWORD2(v5) = *(_DWORD *)&ThePaths.pLinks[v54 >> 10][v54 & 0x3FF].CoorsX;
  v67.n64_u64[0] = vsub_f32(
                     vmul_f32(
                       vcvt_f32_s32((int32x2_t)vmovl_s16(*(int16x4_t *)&v5).n128_u64[0]),
                       (float32x2_t)0x3E0000003E000000LL),
                     vmul_f32(
                       vcvt_f32_s32((int32x2_t)vmovl_s16(*((int16x4_t *)&v5 + 1)).n128_u64[0]),
                       (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
  v68 = vmul_f32(v67, v67).n64_u64[0];
  if ( (float)(*(float *)&v68 + *((float *)&v68 + 1)) > 256.0 )
  {
    switch ( pVehicle->AutoPilot.Mission )
    {
      case 2:
      case 4:
      case 0xF:
      case 0x11:
      case 0x2B:
      case 0x34:
      case 0x36:
      case 0x3D:
        break;
      default:
        v72 = pVehicle->AutoPilot.LaneChangeCounter - 1;
        pVehicle->AutoPilot.LaneChangeCounter = v72;
        if ( !v72 )
        {
          pVehicle->AutoPilot.LaneChangeCounter = rand() & 3 | 4;
          v73 = rand();
          v74 = pVehicle->AutoPilot.NewLane;
          v75 = -1;
          if ( (v73 & 1) != 0 )
            v75 = 1;
          NewLane = v75 + v74;
          pVehicle->AutoPilot.NewLane = v75 + v74;
        }
        break;
    }
  }
  v69 = v66 - 1;
  v70 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75);
  if ( v66 - 1 > NewLane )
    v69 = NewLane;
  v71 = 0;
  if ( v69 <= 0 )
    LOBYTE(v69) = 0;
  pVehicle->AutoPilot.NewLane = v69;
  if ( (v70 & 8) == 0 )
  {
    if ( (v70 & 0x10) == 0 && pVehicle->m_vehicleType != 10 )
      goto LABEL_81;
    if ( (v58 & 7) != 0 )
      LOBYTE(v66) = v66 - 1;
    v71 = v66;
  }
  pVehicle->AutoPilot.NewLane = v71;
LABEL_81:
  CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.OldLink.Address >> 10][pVehicle->AutoPilot.OldLink.Address & 0x3FF]);
  CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF]);
  return 0;
}
// 2EFFD4: variable 'v5' is possibly undefined

//----- (002F0168) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __fastcall CCarCtrl::PickNextNodeToFollowPath(CVehicle *pVehicle)
{
  __int128 v1; // q8
  unsigned int ForcedRandomSeed; // r0
  CAutoPilot *p_AutoPilot; // r6
  CNodeAddress NewNode; // r4
  CNodeAddress *aPathNodeList; // r5
  CNodeAddress v7; // r0
  CNodeAddress OldNode; // r2
  __int64 v9; // kr00_8
  int v10; // r5
  int v11; // r11
  Int8 InvertDirOldLink; // r0
  UInt16 Address; // r9
  Int8 InvertDirNewLink; // r12
  Int8 NewLane; // lr
  CNodeAddress *v16; // r1
  unsigned int Index; // r3
  CPathNode *v18; // r0
  __int16 v19; // r2
  int IndexAdjacentNodes; // r6
  unsigned int v21; // r0
  int v22; // r5
  UInt16 v23; // r5
  int v24; // r1
  int v25; // r5
  float v26; // s18
  CCarPathLink *v27; // r6
  int v28; // r3
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r5
  int v31; // r6
  RwReal x; // r2
  RwReal y; // r3
  RwReal z; // lr
  int Region; // r0
  int v36; // r1
  int v37; // r1
  CCarPathLink *v38; // r1
  int v39; // r2
  int v40; // r9
  CCarPathLink *v41; // r0
  int v42; // r5
  int v43; // r4
  float32x2_t v44; // d18
  CCarPathLink *v45; // r0
  int DirXb; // s6
  float v47; // s20
  float32x2_t v48; // d16
  float v49; // s26
  float v50; // s22
  unsigned __int64 v51; // d0
  float v52; // s24
  char v53; // r0
  Int8 v54; // r1
  char v55; // r2
  float v56; // s20
  int v57; // r2
  float v58; // s24
  float v59; // s18
  float v60; // s26
  __int16 v61; // r1
  Int8 v62; // r0
  int OldLane; // r4
  float v64; // r0
  int v65; // r5
  float v66; // s28
  float v67; // r0
  UInt16 v68; // r1
  float ActualSpeed; // s22
  int v70; // s12
  bool v71; // r5
  CCarPathLink *v72; // r2
  int v73; // r1
  int CoorsX; // r3
  CCarPathLink *v75; // r1
  float CoorsY; // s6
  float v77; // s12
  CCarPathLink *v78; // r3
  float v79; // s2
  float v80; // s6
  float v81; // s2
  CNodeAddress v82; // r0
  Int32 v83; // r1
  CPathNode *v84; // r1
  CEntity::CEntityInfo m_info; // r1
  UInt32 v86; // r0
  RwReal v88; // [sp+0h] [bp-C0h]
  CVector endCoors; // [sp+50h] [bp-70h] BYREF
  CVector startCoors; // [sp+5Ch] [bp-64h] BYREF

  ForcedRandomSeed = pVehicle->ForcedRandomSeed;
  if ( ForcedRandomSeed )
    srand(ForcedRandomSeed);
  p_AutoPilot = &pVehicle->AutoPilot;
  NewNode = pVehicle->AutoPilot.NewNode;
  if ( pVehicle->AutoPilot.NumPathNodes < 1 )
  {
    m_pMat = pVehicle->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pVehicle->m_transform;
    v31 = 0;
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    if ( pVehicle->m_nModelIndex == 539 )
      v31 = 1;
    aPathNodeList = pVehicle->AutoPilot.aPathNodeList;
    v88 = z;
    CPathFind::DoPathSearch(
      &ThePaths,
      0.0,
      *(CVector *)&x,
      NewNode,
      pVehicle->AutoPilot.TargetCoors,
      pVehicle->AutoPilot.aPathNodeList,
      &pVehicle->AutoPilot.NumPathNodes,
      8,
      0,
      1000000.0,
      0,
      1000000.0,
      (*(unsigned __int16 *)((char *)&pVehicle->AutoPilot + 75) >> 6) & 1,
      EmptyNodeAddress,
      v31,
      0);
    if ( pVehicle->AutoPilot.NumPathNodes < 2 )
      return 1;
    Region = pVehicle->AutoPilot.aPathNodeList[0].Region;
    v36 = pVehicle->AutoPilot.NewNode.Region;
    if ( v36 == Region )
    {
      p_AutoPilot = &pVehicle->AutoPilot;
      if ( pVehicle->AutoPilot.NewNode.Index == pVehicle->AutoPilot.aPathNodeList[0].Index )
      {
        CAutoPilot::RemoveOnePathNode(&pVehicle->AutoPilot);
        if ( pVehicle->AutoPilot.NewNode.Region != pVehicle->AutoPilot.aPathNodeList[0].Region )
          goto LABEL_47;
      }
    }
    else
    {
      p_AutoPilot = &pVehicle->AutoPilot;
      if ( v36 != Region )
        goto LABEL_47;
    }
    if ( pVehicle->AutoPilot.NewNode.Index == pVehicle->AutoPilot.aPathNodeList[0].Index )
      CAutoPilot::RemoveOnePathNode(p_AutoPilot);
LABEL_47:
    if ( pVehicle->AutoPilot.NumPathNodes >= 1 )
    {
      v7 = pVehicle->AutoPilot.NewNode;
      goto LABEL_5;
    }
    return 1;
  }
  aPathNodeList = pVehicle->AutoPilot.aPathNodeList;
  v7 = pVehicle->AutoPilot.NewNode;
LABEL_5:
  pVehicle->AutoPilot.VeryOldNode = pVehicle->AutoPilot.OldNode;
  pVehicle->AutoPilot.OldNode = v7;
  pVehicle->AutoPilot.NewNode = *aPathNodeList;
  CAutoPilot::RemoveOnePathNode(p_AutoPilot);
  OldNode = pVehicle->AutoPilot.OldNode;
  v9 = *(_QWORD *)&pVehicle->AutoPilot.TimeToLeaveLink;
  v10 = pVehicle->AutoPilot.OldNode.Region;
  v11 = OldNode.Region;
  InvertDirOldLink = pVehicle->AutoPilot.InvertDirOldLink;
  Address = pVehicle->AutoPilot.NewLink.Address;
  pVehicle->AutoPilot.VeryOldLink.Address = pVehicle->AutoPilot.OldLink.Address;
  InvertDirNewLink = pVehicle->AutoPilot.InvertDirNewLink;
  pVehicle->AutoPilot.InvertDirVeryOldLink = InvertDirOldLink;
  pVehicle->AutoPilot.TimeToLeaveLink = HIDWORD(v9) + v9;
  NewLane = pVehicle->AutoPilot.NewLane;
  pVehicle->AutoPilot.OldLink.Address = Address;
  pVehicle->AutoPilot.InvertDirOldLink = InvertDirNewLink;
  pVehicle->AutoPilot.OldLane = NewLane;
  v16 = ThePaths.pAdjacentNodes[v10];
  Index = pVehicle->AutoPilot.NewNode.Index;
  v18 = &ThePaths.pNodes[OldNode.Region][HIWORD(*(unsigned int *)&OldNode)];
  v19 = 0;
  IndexAdjacentNodes = v18->IndexAdjacentNodes;
  v21 = pVehicle->AutoPilot.NewNode.Region;
  while ( 1 )
  {
    v22 = IndexAdjacentNodes + v19;
    if ( v16[v22].Region == v21 && v16[v22].Index == Index )
      break;
    ++v19;
  }
  v23 = ThePaths.pAdjacentLinks[v11][v22].Address;
  pVehicle->AutoPilot.NewLink.Address = v23;
  if ( v21 > NewNode.Region || v21 == NewNode.Region && Index > HIWORD(*(unsigned int *)&NewNode) )
  {
    pVehicle->AutoPilot.InvertDirNewLink = -1;
    v24 = v23 >> 10;
    v25 = v23 & 0x3FF;
    v26 = -1.0;
    v27 = ThePaths.pLinks[v24];
    v28 = *(unsigned __int16 *)((char *)&v27[v25] + 11) >> 3;
  }
  else
  {
    pVehicle->AutoPilot.InvertDirNewLink = 1;
    v37 = v23 >> 10;
    v25 = v23 & 0x3FF;
    v26 = 1.0;
    v27 = ThePaths.pLinks[v37];
    LOWORD(v28) = *(_WORD *)((char *)&v27[v25] + 11);
  }
  v38 = &v27[v25];
  DWORD2(v1) = *(_DWORD *)&v38->CoorsX;
  v39 = Address >> 10;
  v40 = Address & 0x3FF;
  v41 = ThePaths.pLinks[v39];
  v42 = v28 & 7;
  v43 = *(_DWORD *)&v41[v40].CoorsX;
  v44.n64_u64[0] = vmul_f32(
                     vcvt_f32_s32((int32x2_t)vmovl_s16(*((int16x4_t *)&v1 + 1)).n128_u64[0]),
                     (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
  v45 = &v41[v40];
  DWORD2(v1) = v43;
  DirXb = v45->DirXb;
  v47 = (float)v38->DirYb * 0.01;
  v48.n64_u64[0] = vsub_f32(
                     v44,
                     vmul_f32(
                       vcvt_f32_s32((int32x2_t)vmovl_s16(*((int16x4_t *)&v1 + 1)).n128_u64[0]),
                       (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
  v49 = (float)InvertDirNewLink;
  v50 = (float)v38->DirXb * 0.01;
  v51 = vmul_f32(v48, v48).n64_u64[0];
  v52 = (float)v45->DirYb * 0.01;
  if ( (float)(*(float *)&v51 + *((float *)&v51 + 1)) > 256.0 )
  {
    if ( (rand() & 0x600) != 0 )
    {
      NewLane = pVehicle->AutoPilot.NewLane;
    }
    else
    {
      v53 = rand();
      v54 = pVehicle->AutoPilot.NewLane;
      v55 = -1;
      if ( (v53 & 1) != 0 )
        v55 = 1;
      NewLane = v55 + v54;
      pVehicle->AutoPilot.NewLane = v55 + v54;
    }
  }
  v56 = v47 * v26;
  v57 = v42 - 1;
  v58 = v52 * v49;
  v59 = v50 * v26;
  v60 = (float)((float)DirXb * 0.01) * v49;
  v61 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75);
  if ( v42 - 1 > NewLane )
    v57 = NewLane;
  v62 = 0;
  if ( v57 <= 0 )
    LOBYTE(v57) = 0;
  pVehicle->AutoPilot.NewLane = v57;
  if ( (v61 & 8) != 0 )
    goto LABEL_38;
  if ( (v61 & 0x10) != 0 )
  {
    if ( v42 )
      LOBYTE(v42) = v42 - 1;
    v62 = v42;
LABEL_38:
    pVehicle->AutoPilot.NewLane = v62;
  }
  OldLane = pVehicle->AutoPilot.OldLane;
  v64 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.OldLink.Address >> 10][pVehicle->AutoPilot.OldLink.Address & 0x3FF]);
  v65 = pVehicle->AutoPilot.NewLane;
  v66 = v64 + (float)OldLane;
  v67 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF]);
  v68 = pVehicle->AutoPilot.OldLink.Address;
  ActualSpeed = pVehicle->AutoPilot.ActualSpeed;
  v70 = v65;
  v71 = 0;
  v72 = ThePaths.pLinks[v68 >> 10];
  v73 = v68 & 0x3FF;
  CoorsX = v72[v73].CoorsX;
  v75 = &v72[v73];
  CoorsY = (float)v75->CoorsY;
  v77 = (float)v70;
  startCoors.z = 0.0;
  startCoors.y = (float)(CoorsY * 0.125) - (float)(v60 * (float)(v66 * 5.4));
  startCoors.x = (float)(v58 * (float)(v66 * 5.4)) + (float)((float)CoorsX * 0.125);
  v78 = &ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF];
  v79 = (float)v78->CoorsY;
  v80 = (float)v78->CoorsX;
  endCoors.z = 0.0;
  endCoors.y = (float)(v79 * 0.125) - (float)(v59 * (float)((float)(v67 + v77) * 5.4));
  endCoors.x = (float)(v56 * (float)((float)(v67 + v77) * 5.4)) + (float)(v80 * 0.125);
  v81 = CCurves::CalcSpeedScaleFactor(
          &startCoors,
          &endCoors,
          (float)((float)v75->DirXb * 0.01) * (float)pVehicle->AutoPilot.InvertDirOldLink,
          (float)((float)v75->DirYb * 0.01) * (float)pVehicle->AutoPilot.InvertDirOldLink,
          (float)((float)v78->DirXb * 0.01) * (float)pVehicle->AutoPilot.InvertDirNewLink,
          (float)((float)v78->DirYb * 0.01) * (float)pVehicle->AutoPilot.InvertDirNewLink);
  v82 = pVehicle->AutoPilot.NewNode;
  v83 = (int)(float)((float)(1000.0 / ActualSpeed) * v81);
  if ( v83 <= 10 )
    v83 = 10;
  pVehicle->AutoPilot.TimeToGetToNextLink = v83;
  v84 = ThePaths.pNodes[v82.Region];
  if ( v84 )
  {
    v71 = 0;
    if ( ((*((unsigned __int8 *)&v84[HIWORD(*(unsigned int *)&v82)] + 26) << 16) & 0xF00000) == 0x200000 )
    {
      m_info = pVehicle->m_info;
      pVehicle->AutoPilot.TempAction = 0;
      pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
      v86 = CTimer::m_snTimeInMilliseconds;
      pVehicle->AutoPilot.Mission = 45;
      pVehicle->m_nNoOfStaticFrames = 0;
      pVehicle->AutoPilot.LastTimeNotStuck = v86 + 2000;
      pVehicle->AutoPilot.LastTimeMoving = v86;
    }
  }
  return v71;
}
// 2F0168: fragmented variable at r2.4 may be wrong
// 2F0168: fragmented variable at r3.4 may be wrong

//----- (002F075C) --------------------------------------------------------
int __fastcall CCarCtrl::IsThisAnAppropriateNode(
        CVehicle *pVehicle,
        CNodeAddress VeryOldNode,
        CNodeAddress OldNode,
        CNodeAddress CandidateNode,
        int bGoingAgainstTraffic,
        bool bGoingDownOneWayStreet)
{
  int16x4_t v6; // d16
  CPathNode *v8; // r0
  int Index; // r6
  bool v10; // zf
  int v11; // r3
  CPathNode *v12; // r5
  CPathNode *v13; // r6
  int v14; // r2
  unsigned int v15; // r1
  int Mission; // r0
  bool v17; // zf
  int v18; // r4
  CColModel *m_pColModel; // r3
  CPed *pDriver; // r0
  __int16 *v21; // r0
  float v22; // s12
  RwReal v23; // s4
  RwReal v24; // s6
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s6
  float v28; // s2
  float v29; // s0
  float x; // s4
  CPed *v31; // r0
  int32 m_nSize; // r1
  int v33; // r3
  unsigned int v34; // r4
  CPed *v35; // r0
  CMatrix *v36; // r5
  float32x2_t v37; // d0
  float xx; // s2
  float m_heading; // r9
  CSimpleTransform *p_m_transform; // r0
  unsigned __int64 v41; // d0
  CPed *v42; // r0
  int32 v44; // r1
  int v45; // r3
  unsigned int v46; // r4
  RwReal v47; // s4
  RwReal v48; // s0
  CVector v2; // [sp+24h] [bp-3Ch] BYREF
  CVector v1; // [sp+30h] [bp-30h] BYREF
  CVector Coors; // [sp+3Ch] [bp-24h] BYREF

  v8 = ThePaths.pNodes[CandidateNode.Region];
  if ( v8 )
  {
    Index = CandidateNode.Index;
    v10 = VeryOldNode.Region == CandidateNode.Region;
    if ( VeryOldNode.Region == CandidateNode.Region )
      v10 = VeryOldNode.Index == CandidateNode.Index;
    if ( !v10 )
    {
      v11 = OldNode.Index;
      v12 = ThePaths.pNodes[OldNode.Region];
      v13 = &v8[Index];
      v14 = *((unsigned __int16 *)&v12[OldNode.Index] + 12) | (*((unsigned __int8 *)&v12[OldNode.Index] + 26) << 16);
      v15 = *((unsigned __int16 *)v13 + 12) | (*((unsigned __int8 *)v13 + 26) << 16);
      if ( ((v15 ^ v14) & 0x80) == 0 || pVehicle->m_nModelIndex == 539 )
      {
        switch ( (v15 & 0xF00000) >> 20 )
        {
          case 1u:
            if ( pVehicle->VehicleCreatedBy == 2 )
              return 0;
            pDriver = pVehicle->pDriver;
            if ( pDriver )
            {
              if ( pDriver->CharCreatedBy == 2 )
                return 0;
            }
            if ( BYTE1(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex][1].m_pColModel) == 5 )
              return 0;
            if ( !bGoingAgainstTraffic )
            {
              v21 = (__int16 *)&v12[v11];
              v22 = (float)v13->CoorsZ * 0.125;
              v23 = (float)((float)v13->CoorsX * 0.125) - (float)((float)v21[4] * 0.125);
              v24 = v22 - (float)((float)v21[6] * 0.125);
              v1.y = (float)((float)v13->CoorsY * 0.125) - (float)((float)v21[5] * 0.125);
              v1.x = v23;
              v1.z = v24;
              m_pMat = pVehicle->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &pVehicle->m_transform;
              y = p_tx->m_translate.y;
              v28 = (float)v13->CoorsY * 0.125;
              v29 = (float)v13->CoorsX * 0.125;
              x = p_tx->m_translate.x;
              v2.z = v22 - p_tx->m_translate.z;
              v2.y = v28 - y;
              v2.x = v29 - x;
              CrossProduct(&Coors, &v1, &v2);
              if ( Coors.z < 0.0 )
                return 0;
            }
            if ( CVehicle::IsLawEnforcementVehicle(pVehicle) )
              return 0;
            if ( BYTE1(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex][1].m_pColModel) == 5 )
              return 0;
            v31 = pVehicle->pDriver;
            if ( v31 )
            {
              if ( v31->m_nPedType == 20 )
                return 0;
            }
            m_nSize = CPools::ms_pVehiclePool->m_nSize;
            if ( !m_nSize )
              goto LABEL_68;
            v33 = 2604 * m_nSize - 2604;
            while ( 1 )
            {
              if ( (CPools::ms_pVehiclePool->m_aFlags[m_nSize - 1] & 0x80u) == 0 )
              {
                if ( &(*CPools::ms_pVehiclePool->m_aStorage)[v33] )
                {
                  v34 = (unsigned __int8)((*CPools::ms_pVehiclePool->m_aStorage)[v33 + 958] - 45);
                  if ( v34 < 6 )
                  {
                    if ( 0x33u >> v34 << 31 )
                      return 0;
                  }
                }
              }
              --m_nSize;
              v33 -= 2604;
              if ( !m_nSize )
                goto LABEL_68;
            }
          case 2u:
            if ( pVehicle->VehicleCreatedBy == 2 )
              return 0;
            v35 = pVehicle->pDriver;
            if ( v35 )
            {
              if ( v35->CharCreatedBy == 2 )
                return 0;
            }
            if ( !bGoingAgainstTraffic )
            {
              v36 = pVehicle->m_pMat;
              if ( v36 )
              {
                v37.n64_u64[0] = *(unsigned __int64 *)&v36->yx;
                xx = v36->xx;
              }
              else
              {
                m_heading = pVehicle->m_transform.m_heading;
                xx = cosf(m_heading);
                v37.n64_u64[0] = COERCE_UNSIGNED_INT(sinf(m_heading));
              }
              p_m_transform = (CSimpleTransform *)&v36->tx;
              if ( !v36 )
                p_m_transform = &pVehicle->m_transform;
              v6.n64_u32[0] = *(_DWORD *)&v13->CoorsY;
              v41 = vmul_f32(
                      v37,
                      vsub_f32(
                        vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v6).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL),
                        *(float32x2_t *)&p_m_transform->m_translate.y)).n64_u64[0];
              if ( (float)((float)((float)(xx
                                         * (float)((float)((float)v13->CoorsX * 0.125) - p_m_transform->m_translate.x))
                                 + *(float *)&v41)
                         + *((float *)&v41 + 1)) < 0.0 )
                return 0;
            }
            if ( CVehicle::IsLawEnforcementVehicle(pVehicle) )
              return 0;
            if ( BYTE1(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex][1].m_pColModel) == 5 )
              return 0;
            v42 = pVehicle->pDriver;
            if ( v42 )
            {
              if ( v42->m_nPedType == 20 )
                return 0;
            }
            v44 = CPools::ms_pVehiclePool->m_nSize;
            if ( !v44 )
              goto LABEL_68;
            v45 = 2604 * v44 - 2604;
            break;
          case 5u:
          case 0xAu:
            if ( bGoingAgainstTraffic
              || CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.z < 2.0 )
            {
              return 0;
            }
            goto LABEL_10;
          case 8u:
          case 9u:
            if ( bGoingAgainstTraffic )
              return 0;
            m_pColModel = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel;
            if ( m_pColModel->m_boxBound.m_vecMax.z > 1.5
              || m_pColModel->m_boxBound.m_vecMax.x > 2.0
              || m_pColModel->m_boxBound.m_vecMax.y > 4.0 )
            {
              return 0;
            }
            goto LABEL_10;
          default:
LABEL_10:
            if ( pVehicle->VehicleCreatedBy == 2 && (*((_WORD *)v13 + 12) & 0x400) != 0 )
            {
              Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
              v17 = Mission == 1;
              if ( Mission == 1 )
                v17 = (v14 & 0x400) == 0;
              if ( v17 )
                return 0;
            }
            v18 = 0;
            if ( (*((_WORD *)v13 + 12) & 0x10) == 0 || (v14 & 0x10) != 0 )
            {
              if ( (v14 & 0x20) == 0 )
                v18 = 1;
              return (v18 & (v15 >> 5) | bGoingAgainstTraffic) ^ 1;
            }
            return v18;
        }
        while ( 1 )
        {
          if ( (CPools::ms_pVehiclePool->m_aFlags[v44 - 1] & 0x80u) == 0 )
          {
            if ( &(*CPools::ms_pVehiclePool->m_aStorage)[v45] )
            {
              v46 = (unsigned __int8)((*CPools::ms_pVehiclePool->m_aStorage)[v45 + 958] - 45);
              if ( v46 < 6 )
              {
                if ( 0x33u >> v46 << 31 )
                  break;
              }
            }
          }
          --v44;
          v45 -= 2604;
          if ( !v44 )
          {
LABEL_68:
            v18 = 0;
            v47 = (float)v13->CoorsX * 0.125;
            v48 = (float)v13->CoorsZ * 0.125;
            Coors.y = (float)v13->CoorsY * 0.125;
            Coors.x = v47;
            Coors.z = v48;
            CWorld::FindObjectsKindaColliding(&Coors, 5.0, 1, (Int16 *)&v1, 2, 0, 0, 1, 0, 0, 0);
            if ( !LOWORD(v1.x) )
              return 1;
            return v18;
          }
        }
      }
    }
  }
  return 0;
}
// 2F0AE8: variable 'v6' is possibly undefined

//----- (002F0C40) --------------------------------------------------------
int CCarCtrl::IsAnyoneParking()
{
  int32 m_nSize; // r1
  int i; // r3
  unsigned int v3; // r0

  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  for ( i = 2604 * m_nSize - 2604; ; i -= 2604 )
  {
    if ( (CPools::ms_pVehiclePool->m_aFlags[m_nSize - 1] & 0x80u) == 0 )
    {
      if ( &(*CPools::ms_pVehiclePool->m_aStorage)[i] )
      {
        v3 = (unsigned __int8)((*CPools::ms_pVehiclePool->m_aStorage)[i + 958] - 45);
        if ( v3 <= 5 )
        {
          if ( 0x33u >> v3 << 31 )
            break;
        }
      }
    }
    if ( !--m_nSize )
      return 0;
  }
  return 1;
}

//----- (002F0CA8) --------------------------------------------------------
bool __fastcall CCarCtrl::ThisVehicleShouldTryNotToTurn(CVehicle *pVehicle)
{
  int m_nModelIndex; // r2
  bool result; // r0

  m_nModelIndex = pVehicle->m_nModelIndex;
  result = 1;
  switch ( m_nModelIndex )
  {
    case 403:
    case 406:
    case 431:
    case 437:
    case 443:
    case 455:
      return result;
    case 404:
    case 405:
    case 407:
    case 408:
    case 409:
    case 410:
    case 411:
    case 412:
    case 413:
    case 414:
    case 415:
    case 416:
    case 417:
    case 418:
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
    case 427:
    case 428:
    case 429:
    case 430:
    case 432:
    case 433:
    case 434:
    case 435:
    case 436:
    case 438:
    case 439:
    case 440:
    case 441:
    case 442:
    case 444:
    case 445:
    case 446:
    case 447:
    case 448:
    case 449:
    case 450:
    case 451:
    case 452:
    case 453:
    case 454:
      goto LABEL_6;
    default:
      if ( (unsigned int)(m_nModelIndex - 514) > 0xA )
      {
LABEL_6:
        result = 0;
      }
      else if ( ((1 << (m_nModelIndex - 2)) & 0x403) == 0 )
      {
        result = 0;
      }
      break;
  }
  return result;
}

//----- (002F0D10) --------------------------------------------------------
int __fastcall CCarCtrl::FindPathDirection(
        CNodeAddress OldNode,
        CNodeAddress CurrentNode,
        CNodeAddress NewNode,
        bool *pSharpTurn)
{
  int Region; // r8
  int16x4_t v5; // d16
  int16x4_t v6; // d17
  unsigned __int8 v7; // r12
  bool v8; // zf
  CPathNode *v9; // lr
  CPathNode *v10; // r5
  CPathNode *v11; // r12
  int16x4_t v12; // d18
  float32x2_t v13; // d17
  float32x2_t v14; // d0
  unsigned __int64 v15; // d1
  float v16; // s2
  float32x2_t v17; // d2
  unsigned __int64 v18; // d3
  float v19; // s8
  float v21; // s6
  float v22; // s0
  float v23; // s2
  float v24; // s8
  float v25; // s4
  float v26; // s0

  v7 = 0;
  *pSharpTurn = 0;
  if ( OldNode.Region != 0xFFFF )
  {
    v8 = CurrentNode.Region == 0xFFFF;
    if ( CurrentNode.Region != 0xFFFF )
    {
      Region = NewNode.Region;
      v8 = NewNode.Region == 0xFFFF;
    }
    if ( !v8 )
    {
      v9 = ThePaths.pNodes[OldNode.Region];
      if ( !v9 )
        return 0;
      v10 = ThePaths.pNodes[CurrentNode.Region];
      if ( !v10 )
        return 0;
      v11 = ThePaths.pNodes[Region];
      if ( !v11 )
        return 0;
      v5.n64_u32[0] = *(_DWORD *)&v9[OldNode.Index].CoorsX;
      v6.n64_u32[0] = *(_DWORD *)&v10[CurrentNode.Index].CoorsX;
      v12.n64_u64[0] = vcvt_f32_s32((int32x2_t)vmovl_s16(v6).n128_u64[0]).n64_u64[0];
      v13.n64_u64[0] = vmul_f32(v12, (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
      v14.n64_u64[0] = vsub_f32(
                         v13,
                         vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v5).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
      v15 = vmul_f32(v14, v14).n64_u64[0];
      v16 = sqrtf(*(float *)&v15 + *((float *)&v15 + 1));
      if ( v16 == 0.0 )
        return 0;
      v12.n64_u32[0] = *(_DWORD *)&v11[NewNode.Index].CoorsX;
      v17.n64_u64[0] = vsub_f32(
                         vmul_f32(
                           vcvt_f32_s32((int32x2_t)vmovl_s16(v12).n128_u64[0]),
                           (float32x2_t)0x3E0000003E000000LL),
                         v13).n64_u64[0];
      v18 = vmul_f32(v17, v17).n64_u64[0];
      v19 = sqrtf(*(float *)&v18 + *((float *)&v18 + 1));
      if ( v19 != 0.0 )
      {
        v21 = v14.n64_f32[1] / v16;
        v22 = v14.n64_f32[0] / v16;
        v23 = v17.n64_f32[1] / v19;
        v24 = v17.n64_f32[0] / v19;
        v25 = (float)(v22 * v24) + (float)(v21 * v23);
        if ( v25 <= 0.4 )
        {
          v7 = 2;
          v26 = (float)(v22 * v23) - (float)(v21 * v24);
          if ( v25 < -0.3 )
            *pSharpTurn = 1;
          if ( v26 > 0.0 )
            return 4;
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v7;
}
// 2F0D64: variable 'Region' is possibly undefined
// 2F0D9E: variable 'v6' is possibly undefined
// 2F0D96: variable 'v5' is possibly undefined

//----- (002F0E88) --------------------------------------------------------
void __fastcall CCarCtrl::PickNextNodeForPlayer(CVehicle *pVehicle)
{
  char *v1; // r11
  CNodeAddress NewNode; // r12
  char *v3; // r10
  int v4; // r1
  unsigned int Address; // r6
  int v6; // r8
  int v7; // r5
  unsigned __int16 *v8; // r0
  int v9; // r9
  unsigned int v10; // r0
  CVehicle *v11; // r4
  int v12; // r10
  int v13; // r8
  char *v14; // r1
  int v15; // r0
  Int32 v16; // r1
  int v17; // r5
  CNodeAddress v18; // r2
  int PathDirection; // r11
  unsigned int v20; // r6
  unsigned __int16 *v21; // r1
  int v22; // r2
  __int16 v23; // r12
  int v24; // r0
  int bGoingAgainstTraffic; // r1
  int v26; // r4
  int IsThisAnAppropriateNode; // r0
  bool v28; // zf
  unsigned int v29; // r5
  CVehicle *v30; // r4
  int v31; // r6
  int v32; // r8
  char *v33; // r0
  _DWORD *v34; // r11
  int v35; // r0
  Int32 v36; // r1
  int v37; // r5
  CNodeAddress v38; // r2
  unsigned __int16 *v39; // r0
  __int16 v40; // r1
  int v41; // r0
  unsigned int v42; // r3
  int v43; // r6
  int v44; // r8
  char *v45; // r0
  _DWORD *v46; // r11
  int v47; // r0
  Int32 v48; // r1
  int v49; // r5
  CNodeAddress v50; // r2
  unsigned __int16 *v51; // r0
  __int16 v52; // r1
  int v53; // r0
  Int8 InvertDirOldLink; // r12
  UInt16 v55; // r6
  UInt16 v56; // r10
  Int8 InvertDirNewLink; // lr
  Int8 NewLane; // r4
  Int32 TimeToLeaveLink; // r0
  Int32 TimeToGetToNextLink; // r1
  CVehicle *v61; // r12
  float v62; // s16
  unsigned int v63; // r9
  int v64; // r8
  CPathNode *v65; // r0
  CPathNode *v66; // r1
  int CoorsX; // s6
  int CoorsY; // s2
  float v69; // s0
  float v70; // s4
  CCarPathLink *v71; // r1
  float DirYb; // s22
  CCarPathLink *v73; // r0
  float DirXb; // s24
  float v75; // s26
  float v76; // s28
  float v77; // s30
  CVehicle *v78; // r4
  Int8 v79; // r0
  int v80; // r0
  char v81; // r0
  Int8 v82; // r1
  char v83; // r2
  int v84; // r1
  __int16 v85; // r3
  Int8 v86; // r2
  CVehicle *v87; // r8
  UInt16 v88; // r1
  int OldLane; // r4
  float v90; // s24
  float v91; // s22
  float v92; // s26
  float v93; // s28
  float v94; // r0
  int v95; // r6
  float v96; // s30
  float v97; // r0
  UInt16 v98; // r1
  float ActualSpeed; // s16
  CCarPathLink *v100; // r2
  int v101; // r3
  CCarPathLink *v102; // r1
  RwReal v103; // s4
  RwReal v104; // s2
  float v105; // s0
  CCarPathLink *v106; // r6
  float v107; // s2
  float v108; // s4
  int v109; // r0
  _DWORD *v110; // [sp+Ch] [bp-D4h]
  int v111; // [sp+10h] [bp-D0h]
  CNodeAddress v112; // [sp+1Ch] [bp-C4h]
  unsigned int v113; // [sp+20h] [bp-C0h]
  int v114; // [sp+24h] [bp-BCh]
  _DWORD *v115; // [sp+38h] [bp-A8h]
  unsigned int Region; // [sp+3Ch] [bp-A4h]
  _DWORD *v117; // [sp+4Ch] [bp-94h]
  _DWORD *v118; // [sp+4Ch] [bp-94h]
  _DWORD *v119; // [sp+4Ch] [bp-94h]
  unsigned int v120; // [sp+50h] [bp-90h]
  CNodeAddress OldNode; // [sp+54h] [bp-8Ch]
  int v122; // [sp+58h] [bp-88h]
  _DWORD *v123; // [sp+5Ch] [bp-84h]
  Int8 v124; // [sp+5Ch] [bp-84h]
  CVector endCoors; // [sp+64h] [bp-7Ch] BYREF
  CVector startCoors; // [sp+70h] [bp-70h] BYREF
  bool pSharpTurn[97]; // [sp+7Fh] [bp-61h] BYREF

  OldNode = pVehicle->AutoPilot.OldNode;
  v1 = (char *)&ThePaths + 4 * OldNode.Region;
  if ( !*((_DWORD *)v1 + 513) )
    return;
  NewNode = pVehicle->AutoPilot.NewNode;
  Region = NewNode.Region;
  v3 = (char *)&ThePaths + 4 * NewNode.Region;
  v4 = *((_DWORD *)v3 + 513);
  if ( !v4 )
    return;
  Address = pVehicle->AutoPilot.NewLink.Address;
  if ( !ThePaths.pNodes[Address >> 10] )
    return;
  v120 = HIWORD(*(unsigned int *)&NewNode);
  v6 = 7;
  v7 = *(_WORD *)(v4 + 28 * HIWORD(*(unsigned int *)&NewNode) + 24) & 0xF;
  v8 = (unsigned __int16 *)&ThePaths.pLinks[Address >> 10][Address & 0x3FF];
  if ( v8[2] == NewNode.Region && v8[3] == v120 )
    v6 = 56;
  v9 = *(unsigned __int16 *)((char *)v8 + 11);
  v112 = NewNode;
  pVehicle->AutoPilot.OldNode = NewNode;
  pVehicle->AutoPilot.VeryOldNode = OldNode;
  SequenceElements = v7;
  SequenceRandomOffset = rand() % v7;
  v10 = ((unsigned int)rand() >> 4) & 1;
  bSequenceOtherWay = v10;
  v11 = pVehicle;
  v110 = v1 + 2052;
  v123 = v3 + 2052;
  v12 = 1;
  v122 = v7;
  v113 = HIWORD(*(unsigned int *)&OldNode);
  v111 = v9 & v6;
  v13 = 0;
  v14 = (char *)&ThePaths + 4 * Region;
  v117 = v14 + 2628;
  v115 = v14 + 3492;
  while ( 1 )
  {
    if ( v10 << 24 )
    {
      v15 = v12 + SequenceRandomOffset - 1;
      v16 = SequenceElements;
    }
    else
    {
      v16 = SequenceElements;
      v15 = SequenceRandomOffset + SequenceElements + v13;
    }
    v17 = v15 % v16;
    v18 = *(CNodeAddress *)(*v117 + 4 * (*(__int16 *)(*v123 + 28 * v120 + 16) + v15 % v16));
    v11->AutoPilot.NewNode = v18;
    if ( ThePaths.pNodes[v18.Region] )
    {
      PathDirection = CCarCtrl::FindPathDirection(OldNode, pVehicle->AutoPilot.OldNode, v18, pSharpTurn);
      v20 = *(unsigned __int16 *)(*v115 + 2 * (*(__int16 *)(*v123 + 28 * v120 + 16) + v17));
      if ( ThePaths.pNodes[v20 >> 10] )
      {
        if ( (*(_BYTE *)&pVehicle->m_info & 0xF8) != 16 || !pSharpTurn[0] )
        {
          v21 = (unsigned __int16 *)&ThePaths.pLinks[v20 >> 10][v20 & 0x3FF];
          if ( v21[2] == Region )
          {
            v22 = v21[3];
            v23 = 7;
            v24 = 56;
            if ( v22 == v120 )
              v24 = 7;
            v114 = v24;
            if ( v22 == v120 )
              v23 = 56;
          }
          else
          {
            v23 = 7;
            v114 = 56;
          }
          v28 = (unsigned __int16)(*(unsigned __int16 *)((char *)v21 + 11) & v23) << 16 == 0;
          bGoingAgainstTraffic = 0;
          v26 = *(unsigned __int16 *)((char *)&ThePaths.pLinks[(unsigned __int16)v20 >> 10][v20 & 0x3FF] + 11);
          if ( v28 )
            bGoingAgainstTraffic = 1;
          IsThisAnAppropriateNode = CCarCtrl::IsThisAnAppropriateNode(
                                      pVehicle,
                                      OldNode,
                                      v112,
                                      pVehicle->AutoPilot.NewNode,
                                      bGoingAgainstTraffic,
                                      0);
          v28 = PathDirection << 31 == 0;
          v29 = v20;
          if ( PathDirection << 31 )
            v28 = IsThisAnAppropriateNode == 0;
          if ( !v28 && (v114 & v26 | v111) << 16 )
          {
            v30 = pVehicle;
            LOWORD(v42) = pVehicle->AutoPilot.NewNode.Region;
            goto LABEL_63;
          }
        }
      }
    }
    if ( v12 >= v122 )
      break;
    ++v12;
    --v13;
    v11 = pVehicle;
    v10 = bSequenceOtherWay;
  }
  v30 = pVehicle;
  v31 = 0;
  v32 = 0;
  v33 = (char *)&ThePaths + 4 * Region;
  v34 = v33 + 3492;
  v118 = v33 + 2628;
  while ( 1 )
  {
    if ( bSequenceOtherWay )
    {
      v35 = SequenceRandomOffset + v32;
      v36 = SequenceElements;
    }
    else
    {
      v36 = SequenceElements;
      v35 = SequenceRandomOffset + SequenceElements + v31;
    }
    v37 = v35 % v36;
    v38 = *(CNodeAddress *)(*v118 + 4 * (*(__int16 *)(*v123 + 28 * v120 + 16) + v35 % v36));
    pVehicle->AutoPilot.NewNode = v38;
    if ( ThePaths.pNodes[v38.Region] )
    {
      CCarCtrl::FindPathDirection(OldNode, pVehicle->AutoPilot.OldNode, v38, pSharpTurn);
      v29 = *(unsigned __int16 *)(*v34 + 2 * (*(__int16 *)(*v123 + 28 * v120 + 16) + v37));
      if ( ThePaths.pNodes[v29 >> 10] )
      {
        v39 = (unsigned __int16 *)&ThePaths.pLinks[v29 >> 10][v29 & 0x3FF];
        if ( v39[2] == Region )
        {
          v40 = 7;
          if ( v39[3] == v120 )
            v40 = 56;
        }
        else
        {
          v40 = 7;
        }
        v41 = (unsigned __int16)(*(unsigned __int16 *)((char *)v39 + 11) & v40);
        if ( pVehicle->AutoPilot.NewNode.Region != OldNode.Region || pVehicle->AutoPilot.NewNode.Index != v113 )
        {
          if ( v41 << 16 )
          {
            v42 = (unsigned int)pVehicle->AutoPilot.NewNode;
            if ( (*((_WORD *)&ThePaths.pNodes[(unsigned __int16)v42][HIWORD(v42)] + 12) & 0x20) == 0
              || (*(_WORD *)(*v110 + 28 * v113 + 24) & 0x20) != 0 )
            {
              break;
            }
          }
        }
      }
    }
    ++v32;
    --v31;
    if ( v32 >= v122 )
    {
      v43 = 0;
      v44 = 0;
      v45 = (char *)&ThePaths + 4 * Region;
      v46 = v45 + 3492;
      v119 = v45 + 2628;
      while ( 1 )
      {
        if ( bSequenceOtherWay )
        {
          v47 = SequenceRandomOffset + v44;
          v48 = SequenceElements;
        }
        else
        {
          v48 = SequenceElements;
          v47 = SequenceRandomOffset + SequenceElements + v43;
        }
        v49 = v47 % v48;
        v50 = *(CNodeAddress *)(*v119 + 4 * (*(__int16 *)(*v123 + 28 * v120 + 16) + v47 % v48));
        pVehicle->AutoPilot.NewNode = v50;
        if ( ThePaths.pNodes[v50.Region] )
        {
          CCarCtrl::FindPathDirection(OldNode, pVehicle->AutoPilot.OldNode, v50, pSharpTurn);
          v29 = *(unsigned __int16 *)(*v46 + 2 * (*(__int16 *)(*v123 + 28 * v120 + 16) + v49));
          if ( ThePaths.pNodes[v29 >> 10] )
          {
            v51 = (unsigned __int16 *)&ThePaths.pLinks[v29 >> 10][v29 & 0x3FF];
            if ( v51[2] == Region )
            {
              v52 = 7;
              if ( v51[3] == v120 )
                v52 = 56;
            }
            else
            {
              v52 = 7;
            }
            v42 = pVehicle->AutoPilot.NewNode.Region;
            v53 = (unsigned __int16)(*(unsigned __int16 *)((char *)v51 + 11) & v52);
            if ( v42 != OldNode.Region || pVehicle->AutoPilot.NewNode.Index != v113 )
            {
              if ( v53 << 16 )
                goto LABEL_63;
            }
          }
        }
        ++v44;
        --v43;
        if ( v44 >= v122 )
        {
          v29 = pVehicle->AutoPilot.NewLink.Address;
          pVehicle->AutoPilot.NewNode = OldNode;
          LOWORD(v42) = OldNode.Region;
          goto LABEL_63;
        }
      }
    }
  }
LABEL_63:
  InvertDirOldLink = pVehicle->AutoPilot.InvertDirOldLink;
  v55 = v30->AutoPilot.OldLink.Address;
  v56 = v30->AutoPilot.NewLink.Address;
  InvertDirNewLink = pVehicle->AutoPilot.InvertDirNewLink;
  NewLane = pVehicle->AutoPilot.NewLane;
  TimeToLeaveLink = pVehicle->AutoPilot.TimeToLeaveLink;
  TimeToGetToNextLink = pVehicle->AutoPilot.TimeToGetToNextLink;
  pVehicle->AutoPilot.VeryOldLink.Address = v55;
  pVehicle->AutoPilot.OldLink.Address = v56;
  pVehicle->AutoPilot.InvertDirVeryOldLink = InvertDirOldLink;
  v61 = pVehicle;
  pVehicle->AutoPilot.InvertDirOldLink = InvertDirNewLink;
  pVehicle->AutoPilot.NewLink.Address = v29;
  pVehicle->AutoPilot.OldLane = NewLane;
  pVehicle->AutoPilot.TimeToLeaveLink = TimeToLeaveLink + TimeToGetToNextLink;
  v124 = NewLane;
  if ( (unsigned __int16)v42 > Region || (unsigned __int16)v42 == Region && pVehicle->AutoPilot.NewNode.Index > v120 )
  {
    v62 = -1.0;
    v63 = v29 >> 10;
    pVehicle->AutoPilot.InvertDirNewLink = -1;
    if ( ThePaths.pNodes[v29 >> 10] )
      v64 = (*(unsigned __int16 *)((char *)&ThePaths.pLinks[v63][v29 & 0x3FF] + 11) >> 3) & 7;
    else
      LOWORD(v64) = 1;
  }
  else
  {
    v62 = 1.0;
    v63 = v29 >> 10;
    LOWORD(v64) = 1;
    pVehicle->AutoPilot.InvertDirNewLink = 1;
    if ( ThePaths.pNodes[v29 >> 10] )
      LOWORD(v64) = *(_WORD *)((char *)&ThePaths.pLinks[v63][v29 & 0x3FF] + 11) & 7;
  }
  v65 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&pVehicle->AutoPilot.NewNode][HIWORD(*(_DWORD *)&pVehicle->AutoPilot.NewNode)];
  v66 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&pVehicle->AutoPilot.OldNode][HIWORD(*(_DWORD *)&pVehicle->AutoPilot.OldNode)];
  CoorsX = v65->CoorsX;
  CoorsY = v65->CoorsY;
  v69 = (float)v66->CoorsY;
  v70 = (float)v66->CoorsX;
  v71 = &ThePaths.pLinks[v63][v29 & 0x3FF];
  DirYb = (float)v71->DirYb;
  v73 = &ThePaths.pLinks[v56 >> 10][v56 & 0x3FF];
  DirXb = (float)v71->DirXb;
  v75 = (float)v73->DirYb;
  v76 = (float)v73->DirXb;
  v77 = (float)InvertDirNewLink;
  if ( (float)((float)((float)((float)((float)CoorsX * 0.125) - (float)(v70 * 0.125))
                     * (float)((float)((float)CoorsX * 0.125) - (float)(v70 * 0.125)))
             + (float)((float)((float)((float)CoorsY * 0.125) - (float)(v69 * 0.125))
                     * (float)((float)((float)CoorsY * 0.125) - (float)(v69 * 0.125)))) <= 256.0 )
  {
    v78 = pVehicle;
    LOBYTE(v80) = v124;
  }
  else
  {
    v78 = pVehicle;
    v79 = pVehicle->AutoPilot.LaneChangeCounter - 1;
    pVehicle->AutoPilot.LaneChangeCounter = v79;
    v28 = v79 == 0;
    LOBYTE(v80) = v124;
    if ( v28 )
    {
      v61->AutoPilot.LaneChangeCounter = rand() & 3 | 4;
      v81 = rand();
      v82 = pVehicle->AutoPilot.NewLane;
      v83 = -1;
      if ( (v81 & 1) != 0 )
        v83 = 1;
      LOBYTE(v80) = v83 + v82;
      pVehicle->AutoPilot.NewLane = v83 + v82;
    }
  }
  v84 = (unsigned __int16)v64 - 1;
  v80 = (char)v80;
  v85 = *(_WORD *)((char *)&v78->AutoPilot + 75);
  if ( v84 <= (char)v80 )
    v80 = (unsigned __int16)v64 - 1;
  v86 = 0;
  if ( v80 <= 0 )
    LOBYTE(v80) = 0;
  v78->AutoPilot.NewLane = v80;
  if ( (v85 & 8) == 0 )
  {
    if ( (v85 & 0x10) == 0 )
      goto LABEL_88;
    if ( v84 <= 0 )
      LOBYTE(v84) = 0;
    v86 = v84;
  }
  v78->AutoPilot.NewLane = v86;
LABEL_88:
  if ( (*(_BYTE *)&v78->m_info & 0xF8) == 16 )
  {
    v87 = v78;
    v88 = v78->AutoPilot.OldLink.Address;
    OldLane = v78->AutoPilot.OldLane;
    v90 = (float)(DirXb * 0.01) * v62;
    v91 = (float)(DirYb * 0.01) * v62;
    v92 = (float)(v75 * 0.01) * v77;
    v93 = (float)(v76 * 0.01) * v77;
    v94 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[v88 >> 10][v88 & 0x3FF]);
    v95 = v87->AutoPilot.NewLane;
    v96 = v94 + (float)OldLane;
    v97 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[v87->AutoPilot.NewLink.Address >> 10][v87->AutoPilot.NewLink.Address & 0x3FF]);
    v98 = v87->AutoPilot.OldLink.Address;
    ActualSpeed = v87->AutoPilot.ActualSpeed;
    v100 = ThePaths.pLinks[v98 >> 10];
    v101 = v98 & 0x3FF;
    v102 = &v100[v98 & 0x3FF];
    v103 = (float)((float)v102->CoorsY * 0.125) - (float)(v93 * (float)(v96 * 5.4));
    v104 = (float)(v92 * (float)(v96 * 5.4)) + (float)((float)v100[v101].CoorsX * 0.125);
    startCoors.z = 0.0;
    startCoors.y = v103;
    startCoors.x = v104;
    v105 = (float)(v97 + (float)v95) * 5.4;
    v106 = &ThePaths.pLinks[v87->AutoPilot.NewLink.Address >> 10][v87->AutoPilot.NewLink.Address & 0x3FF];
    v107 = (float)v106->CoorsY;
    v108 = (float)v106->CoorsX;
    endCoors.z = 0.0;
    endCoors.y = (float)(v107 * 0.125) - (float)(v90 * v105);
    endCoors.x = (float)(v91 * v105) + (float)(v108 * 0.125);
    v109 = (int)(float)((float)(1000.0 / ActualSpeed)
                      * CCurves::CalcSpeedScaleFactor(
                          &startCoors,
                          &endCoors,
                          (float)((float)v102->DirXb * 0.01) * (float)v87->AutoPilot.InvertDirOldLink,
                          (float)((float)v102->DirYb * 0.01) * (float)v87->AutoPilot.InvertDirOldLink,
                          (float)((float)v106->DirXb * 0.01) * (float)v87->AutoPilot.InvertDirNewLink,
                          (float)((float)v106->DirYb * 0.01) * (float)v87->AutoPilot.InvertDirNewLink));
    if ( v109 <= 10 )
      v109 = 10;
    v87->AutoPilot.TimeToGetToNextLink = v109;
  }
}
// 2F116E: conditional instruction was optimized away because %var_88.4 is in (1..F)
// 2F12F6: conditional instruction was optimized away because %var_88.4 is in (1..F)
// 2F0F88: conditional instruction was optimized away because r5.4 is in (1..F)

//----- (002F196C) --------------------------------------------------------
void __fastcall CCarCtrl::SwitchBetweenPhysicsAndGhost(CVehicle *pVehicle)
{
  unsigned int m_info; // r0
  CMatrix *v3; // r1
  CSimpleTransform *p_m_transform; // r0
  int32 m_vehicleType; // r2
  CDamageManager *v6; // r4
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  int32 m_baseVehicleType; // r0

  if ( (*((_BYTE *)&pVehicle->m_nPhysicalFlags + 1) & 0x40) != 0
    && pVehicle->VehicleCreatedBy == 2
    && (unsigned int)(pVehicle->m_vehicleType - 3) >= 3 )
  {
    m_info = (unsigned __int8)pVehicle->m_info;
    if ( m_info >> 3 == 12 )
    {
      m_pMat = pVehicle->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pVehicle->m_transform;
      if ( CColStore::HasCollisionLoaded(&p_tx->m_translate, 0) )
      {
        m_baseVehicleType = pVehicle->m_baseVehicleType;
        pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&pVehicle->m_info & 7 | 0x18);
        if ( m_baseVehicleType )
        {
          if ( m_baseVehicleType == 9 )
            sub_19D798((CBike *)pVehicle);
        }
        else
        {
          sub_19F668((CAutomobile *)pVehicle);
        }
      }
    }
    else if ( m_info >> 3 == 3 )
    {
      v3 = pVehicle->m_pMat;
      p_m_transform = (CSimpleTransform *)&v3->tx;
      if ( !v3 )
        p_m_transform = &pVehicle->m_transform;
      if ( !CColStore::HasCollisionLoaded(&p_m_transform->m_translate, 0) )
      {
        m_vehicleType = pVehicle->m_vehicleType;
        pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&pVehicle->m_info & 7 | 0x60);
        if ( !m_vehicleType )
        {
          v6 = (CDamageManager *)&pVehicle[1];
          CDamageManager::SetWheelStatus(v6, 0, 0);
          CDamageManager::SetWheelStatus(v6, 1, 0);
          CDamageManager::SetWheelStatus(v6, 2, 0);
          sub_18A19C(v6, 3, 0);
        }
      }
    }
  }
}

//----- (002F1A44) --------------------------------------------------------
float __fastcall CCarCtrl::FindGhostRoadHeight(CVehicle *pVehicle)
{
  int Region; // r2
  bool v2; // zf
  CNodeAddress OldNode; // r1
  CPathNode *v5; // r2
  CNodeAddress NewNode; // lr
  CPathNode *v7; // r12
  __int16 *v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // s2
  __int16 *v13; // r2
  float v14; // s4
  int v15; // r3
  int v16; // r4
  int v17; // r2
  float v18; // s6
  CMatrix *m_pMat; // r4
  float v20; // s8
  float v21; // s4
  CSimpleTransform *p_tx; // r3
  float v23; // s2
  float y; // s12
  float v25; // s2
  float v26; // s4

  Region = pVehicle->AutoPilot.OldNode.Region;
  v2 = Region == 0xFFFF;
  if ( Region != 0xFFFF )
    v2 = pVehicle->AutoPilot.NewNode.Region == 0xFFFF;
  if ( v2 )
    return 0.0;
  OldNode = pVehicle->AutoPilot.OldNode;
  v5 = ThePaths.pNodes[OldNode.Region];
  if ( !v5 )
    return 0.0;
  NewNode = pVehicle->AutoPilot.NewNode;
  v7 = ThePaths.pNodes[NewNode.Region];
  if ( !v7 )
    return 0.0;
  v8 = (__int16 *)&v5[HIWORD(*(unsigned int *)&OldNode)];
  v9 = v8[4];
  v10 = v8[5];
  v11 = v8[6];
  v12 = v9;
  v13 = (__int16 *)&v7[HIWORD(*(unsigned int *)&NewNode)];
  v14 = (float)v10;
  v15 = v13[4];
  v16 = v13[5];
  v17 = v13[6];
  v18 = (float)v16;
  m_pMat = pVehicle->m_pMat;
  v20 = (float)v15;
  v21 = v14 * 0.125;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  v23 = (float)v12 * 0.125;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  y = p_tx->m_translate.y;
  v25 = sqrtf(
          (float)((float)(v23 - p_tx->m_translate.x) * (float)(v23 - p_tx->m_translate.x))
        + (float)((float)(v21 - y) * (float)(v21 - y)));
  v26 = sqrtf(
          (float)((float)((float)(v20 * 0.125) - p_tx->m_translate.x)
                * (float)((float)(v20 * 0.125) - p_tx->m_translate.x))
        + (float)((float)((float)(v18 * 0.125) - y) * (float)((float)(v18 * 0.125) - y)));
  return (float)((float)((float)((float)v11 * 0.125) * v26) + (float)((float)((float)v17 * 0.125) * v25))
       / (float)(v26 + v25);
}

//----- (002F1B88) --------------------------------------------------------
bool __fastcall CCarCtrl::ThisRoadObjectCouldMove(UInt32 ModelIndex)
{
  return 0;
}

//----- (002F1B8C) --------------------------------------------------------
float __fastcall CCarCtrl::FindSpeedMultiplier(float Angle, float MaxAngle, float MinAngle, float MinSpeed)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d4
  float v6; // s0
  float v7; // s4

  for ( v4.n64_f32[0] = Angle; v4.n64_f32[0] < -3.1416; v4.n64_f32[0] = v4.n64_f32[0] + 6.2832 )
    ;
  for ( ; v4.n64_f32[0] > 3.1416; v4.n64_f32[0] = v4.n64_f32[0] + -6.2832 )
    ;
  v5.n64_u32[0] = 0;
  v4.n64_f32[0] = fabsf(v4.n64_f32[0]) - MaxAngle;
  v6 = vmax_f32(v4, v5).n64_f32[0];
  v7 = 1.0 - (float)((float)(1.0 - MinSpeed) * (float)(v6 / (float)(MinAngle - MaxAngle)));
  if ( v6 > (float)(MinAngle - MaxAngle) )
    return MinSpeed;
  return v7;
}
// 2F1BEC: variable 'v4' is possibly undefined
// 2F1BEC: variable 'v5' is possibly undefined

//----- (002F1C2C) --------------------------------------------------------
UInt8 __fastcall CCarCtrl::JoinCarWithRoadSystemGotoCoors(
        CVehicle *pVehicle,
        const CVector *TargetCoors,
        bool bUseClosestLane,
        bool bBoat)
{
  _BOOL4 v5; // r8
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_m_transform; // r6
  __int64 v8; // d16
  unsigned int v9; // lr
  CSimpleTransform *p_tx; // r5
  UInt8 v11; // r8
  CMatrix *v12; // r0
  CNodeAddress v13; // r0
  int v15; // [sp+3Ch] [bp-24h]

  v5 = bBoat;
  m_pMat = pVehicle->m_pMat;
  p_m_transform = &pVehicle->m_transform;
  v8 = *(_QWORD *)&TargetCoors->x;
  v9 = *(unsigned __int16 *)((char *)&pVehicle->AutoPilot + 75);
  pVehicle->AutoPilot.TargetCoors.z = TargetCoors->z;
  p_tx = &pVehicle->m_transform;
  *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x = v8;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v15 = v5;
  v11 = 0;
  CPathFind::DoPathSearch(
    &ThePaths,
    0.0,
    p_tx->m_translate,
    EmptyNodeAddress,
    *TargetCoors,
    pVehicle->AutoPilot.aPathNodeList,
    &pVehicle->AutoPilot.NumPathNodes,
    8,
    0,
    1000000.0,
    0,
    1000000.0,
    (v9 >> 6) & 1,
    EmptyNodeAddress,
    pVehicle->m_nModelIndex == 539,
    v15);
  v12 = pVehicle->m_pMat;
  if ( v12 )
    p_m_transform = (CSimpleTransform *)&v12->tx;
  CPathFind::RemoveBadStartNode(
    (int)&ThePaths,
    LODWORD(p_m_transform->m_translate.x),
    LODWORD(p_m_transform->m_translate.y),
    LODWORD(p_m_transform->m_translate.z),
    (_DWORD *)pVehicle->AutoPilot.aPathNodeList,
    &pVehicle->AutoPilot.NumPathNodes);
  if ( pVehicle->AutoPilot.NumPathNodes < 2 )
  {
    CCarCtrl::JoinCarWithRoadSystem(pVehicle);
    pVehicle->AutoPilot.NumPathNodes = 0;
    return 1;
  }
  else
  {
    v13 = pVehicle->AutoPilot.aPathNodeList[0];
    pVehicle->AutoPilot.VeryOldNode.Region = -1;
    pVehicle->AutoPilot.OldNode = v13;
    CAutoPilot::RemoveOnePathNode(&pVehicle->AutoPilot);
    pVehicle->AutoPilot.NewNode = pVehicle->AutoPilot.aPathNodeList[0];
    CAutoPilot::RemoveOnePathNode(&pVehicle->AutoPilot);
    CCarCtrl::FindLinksToGoWithTheseNodes(pVehicle);
    *(_WORD *)&pVehicle->AutoPilot.OldLane = 0;
  }
  return v11;
}

//----- (002F1D50) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysics(CVehicle *pVehicle)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  int RecordingNumber; // r0
  int Mission; // r0
  int v6; // r8
  __int16 v7; // r1
  bool v8; // zf
  CNodeAddress OldNode; // r2
  CNodeAddress NewNode; // r3
  uint32 v11; // r0
  int v12; // r1
  int v13; // r12
  bool v14; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  int v17; // r1
  int m_nVehicleFlags; // r3
  int v19; // r5
  int m_nModelIndex; // r0
  float v21; // s0
  float m_fSteerAngle; // r6
  UInt32 TempActionFinish; // r2
  UInt32 v24; // r0
  float v25; // s4
  float v26; // s2
  float v27; // s0
  uint32 v28; // r1
  float v29; // s0
  float *p_m_fSteerAngle; // r0
  UInt32 v31; // r1
  double v32; // d16
  float v33; // s0
  double v34; // d17
  double v35; // d16
  float v36; // s2
  float v37; // s2
  float v38; // s0
  CMatrix *v39; // r0
  float xy; // s4
  float yy; // s0
  float zy; // s2
  UInt32 v43; // r0
  float m_heading; // r5
  float v45; // r8
  UInt32 v46; // r1
  RwReal v47; // s2
  RwReal v48; // s0
  char v49; // [sp+Bh] [bp-1Dh] BYREF
  float pBrakePedal; // [sp+Ch] [bp-1Ch] BYREF
  float pGasPedal; // [sp+10h] [bp-18h] BYREF
  float pSteerAngle[5]; // [sp+14h] [bp-14h] BYREF

  pSteerAngle[0] = 0.0;
  pBrakePedal = 0.0;
  pGasPedal = 0.0;
  v49 = 0;
  RecordingNumber = pVehicle->AutoPilot.RecordingNumber;
  if ( RecordingNumber < 0 || CVehicleRecording::bUseCarAI[RecordingNumber] )
  {
    CCarCtrl::SwitchBetweenPhysicsAndGhost(pVehicle);
    Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
    v6 = 1045220557;
    pVehicle->AutoPilot.pObstructingEntity = 0;
    switch ( (char)Mission )
    {
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 37:
      case 52:
      case 53:
      case 54:
      case 55:
        if ( !pVehicle->AutoPilot.pTargetEntity )
        {
          Mission = 0;
          goto LABEL_6;
        }
        break;
      case 39:
        if ( !pVehicle->AutoPilot.pTargetEntity )
        {
          Mission = 42;
LABEL_6:
          pVehicle->AutoPilot.Mission = Mission;
        }
        break;
      default:
        break;
    }
    v7 = *(_WORD *)((char *)&pVehicle->AutoPilot + 75);
    if ( (v7 & 0x100) != 0 )
    {
      m_fSteerAngle = 0.0;
      v49 = 0;
      pSteerAngle[0] = 0.0;
      pBrakePedal = 0.2;
      pGasPedal = 0.0;
      m_pMat = pVehicle->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pVehicle->m_transform;
      if ( CPathFind::AreNodesLoadedForArea(
             &ThePaths,
             p_tx->m_translate.x + -270.0,
             p_tx->m_translate.x + 270.0,
             p_tx->m_translate.y + -270.0,
             p_tx->m_translate.y + 270.0) )
      {
        *(_WORD *)((char *)&pVehicle->AutoPilot + 75) &= ~0x100u;
        CCarCtrl::JoinCarWithRoadAccordingToMission(pVehicle);
        m_fSteerAngle = 0.0;
      }
LABEL_23:
      v13 = 0;
    }
    else
    {
      if ( (*(_WORD *)((char *)&pVehicle->AutoPilot + 75) & 0x200) != 0 )
      {
        v8 = Mission == 0;
        if ( Mission )
          v8 = Mission == 11;
        if ( !v8 )
        {
          OldNode = pVehicle->AutoPilot.OldNode;
          NewNode = pVehicle->AutoPilot.NewNode;
          pVehicle->AutoPilot.TempAction = 22;
          v11 = CTimer::m_snTimeInMilliseconds;
          pVehicle->AutoPilot.OldNode = NewNode;
          *(_WORD *)((char *)&pVehicle->AutoPilot + 75) = v7 & 0xFDFF;
          pVehicle->AutoPilot.NewNode = OldNode;
          pVehicle->AutoPilot.VeryOldNode = OldNode;
          pVehicle->AutoPilot.TempActionFinish = v11 + 2000;
        }
      }
      LOBYTE(v12) = pVehicle->AutoPilot.TempAction;
      v13 = -1086324736;
      switch ( (char)v12 )
      {
        case 1:
          m_fSteerAngle = 0.0;
          v49 = 0;
          pGasPedal = 0.0;
          pSteerAngle[0] = 0.0;
          pBrakePedal = 0.2;
          v24 = CTimer::m_snTimeInMilliseconds;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
          {
            pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
            pVehicle->AutoPilot.LastTimeMoving = v24;
            pVehicle->AutoPilot.TempAction = 0;
          }
          goto LABEL_23;
        case 3:
          CCarCtrl::SteerAICarWithPhysics_OnlyMission(pVehicle, pSteerAngle, &pGasPedal, &pBrakePedal, (bool *)&v49);
          v17 = 0;
          v49 = 0;
          pSteerAngle[0] = -pSteerAngle[0];
          m_fSteerAngle = pSteerAngle[0];
          v25 = -0.5;
          v26 = 0.0;
          if ( (float)((float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_pMat->xy)
                             + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_pMat->yy))
                     + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_pMat->zy)) > 0.04 )
          {
            v26 = 0.5;
            v25 = 0.0;
          }
          pGasPedal = v25;
          v6 = LODWORD(v26);
          pBrakePedal = v26;
          v13 = LODWORD(v25);
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
          {
            pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
            pVehicle->AutoPilot.TempAction = 0;
          }
          goto LABEL_25;
        case 4:
          v49 = 1;
          m_fSteerAngle = 1.0;
          v13 = 0;
          pSteerAngle[0] = 1.0;
          pBrakePedal = 0.0;
          pGasPedal = 0.0;
          if ( CTimer::m_snTimeInMilliseconds <= pVehicle->AutoPilot.TempActionFinish )
          {
            v17 = 32;
          }
          else
          {
            pVehicle->AutoPilot.TempAction = 0;
            v17 = 32;
            m_fSteerAngle = 1.0;
          }
          v6 = 0;
          goto LABEL_25;
        case 5:
          v49 = 1;
          v6 = 0;
          pSteerAngle[0] = -1.0;
          m_fSteerAngle = -1.0;
          pBrakePedal = 0.0;
          pGasPedal = 0.0;
          v13 = 0;
          v17 = 32;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
            pVehicle->AutoPilot.TempAction = 0;
          goto LABEL_25;
        case 6:
          m_fSteerAngle = 0.0;
          v49 = 1;
          pSteerAngle[0] = 0.0;
          pBrakePedal = 0.0;
          pGasPedal = 0.0;
          v13 = 0;
          v6 = 0;
          v17 = 32;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
            pVehicle->AutoPilot.TempAction = 0;
          goto LABEL_25;
        case 7:
          v6 = 0;
          m_fSteerAngle = 1.0;
          v49 = 0;
          pSteerAngle[0] = 1.0;
          pBrakePedal = 0.0;
          pGasPedal = 1.0;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
          {
            pVehicle->AutoPilot.TempAction = 0;
            m_fSteerAngle = 1.0;
          }
          goto LABEL_95;
        case 8:
          v6 = 0;
          pSteerAngle[0] = -1.0;
          v49 = 0;
          m_fSteerAngle = -1.0;
          pBrakePedal = 0.0;
          pGasPedal = 1.0;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
            pVehicle->AutoPilot.TempAction = 0;
          goto LABEL_95;
        case 9:
          m_fSteerAngle = 0.0;
          v13 = 1056964608;
          v49 = 0;
          pSteerAngle[0] = 0.0;
          pBrakePedal = 0.0;
          pGasPedal = 0.5;
          v6 = 0;
          v17 = 0;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
          {
            pVehicle->AutoPilot.TempAction = 0;
            v13 = 1056964608;
          }
          goto LABEL_25;
        case 10:
        case 11:
        case 20:
        case 21:
          v12 = (unsigned __int8)v12;
          v49 = 0;
          v14 = (unsigned __int8)v12 == 21;
          pSteerAngle[0] = -0.25;
          if ( (unsigned __int8)v12 != 21 )
            v14 = v12 == 11;
          if ( v14 )
          {
            v21 = 0.25;
            m_fSteerAngle = 0.25;
            pSteerAngle[0] = 0.25;
          }
          else
          {
            v21 = -0.25;
            m_fSteerAngle = -0.25;
          }
          v6 = 981668463;
          pGasPedal = 0.0;
          pBrakePedal = 0.001;
          TempActionFinish = pVehicle->AutoPilot.TempActionFinish;
          if ( CTimer::m_snTimeInMilliseconds > TempActionFinish - 1250 )
          {
            m_fSteerAngle = -v21;
            pSteerAngle[0] = -v21;
          }
          if ( CTimer::m_snTimeInMilliseconds <= TempActionFinish )
            goto LABEL_23;
          if ( (v12 & 0xFE) == 20 )
          {
            pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 4000;
            pVehicle->AutoPilot.TempAction = 1;
            goto LABEL_23;
          }
          v13 = 0;
          goto LABEL_91;
        case 13:
          v6 = 0;
          pGasPedal = -0.75;
          pBrakePedal = 0.0;
          v49 = 0;
          v2.n64_u32[0] = 1060320051;
          v27 = sqrtf(
                  (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                        + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z));
          v1.n64_f32[0] = 0.9 - v27;
          if ( v27 > 0.7 )
            v1.n64_u32[0] = 1045220557;
          v28 = CTimer::m_snTimeInMilliseconds;
          LODWORD(m_fSteerAngle) = vmin_f32(v1, v2).n64_u32[0];
          pSteerAngle[0] = m_fSteerAngle;
          goto LABEL_69;
        case 14:
          v6 = 0;
          pGasPedal = -0.75;
          pBrakePedal = 0.0;
          v49 = 0;
          v2.n64_u32[0] = 1060320051;
          v29 = sqrtf(
                  (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                        + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z));
          v1.n64_f32[0] = 0.9 - v29;
          if ( v29 > 0.7 )
            v1.n64_u32[0] = 1045220557;
          v28 = CTimer::m_snTimeInMilliseconds;
          m_fSteerAngle = -vmin_f32(v1, v2).n64_f32[0];
          pSteerAngle[0] = m_fSteerAngle;
LABEL_69:
          if ( v28 <= pVehicle->AutoPilot.TempActionFinish )
            break;
          pVehicle->AutoPilot.LastTimeNotStuck = v28;
          v17 = 0;
          pVehicle->AutoPilot.TempAction = 0;
          goto LABEL_25;
        case 15:
        case 16:
        case 17:
        case 18:
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
            pVehicle->AutoPilot.TempAction = 0;
          goto LABEL_30;
        case 19:
          v49 = 0;
          pGasPedal = 0.0;
          p_m_fSteerAngle = &pVehicle->m_fSteerAngle;
          v31 = pVehicle->AutoPilot.TempActionFinish;
          v32 = CTimer::ms_fTimeStep * 0.05;
          v33 = 0.0;
          if ( CTimer::m_snTimeInMilliseconds > v31 )
            v33 = 1.0;
          pBrakePedal = v33;
          v34 = *p_m_fSteerAngle;
          if ( *p_m_fSteerAngle <= 0.0 )
          {
            v35 = v34 - v32;
            if ( v35 < -0.5 )
            {
              v36 = -0.5;
              goto LABEL_90;
            }
          }
          else
          {
            v35 = v32 + v34;
            if ( v35 > 0.5 )
            {
              v36 = 0.5;
              goto LABEL_90;
            }
          }
          v36 = v35;
LABEL_90:
          v6 = LODWORD(v33);
          v13 = 0;
          m_fSteerAngle = v36;
          pSteerAngle[0] = v36;
          if ( CTimer::m_snTimeInMilliseconds > v31 )
LABEL_91:
            pVehicle->AutoPilot.TempAction = 0;
          break;
        case 22:
          m_fSteerAngle = 0.0;
          v49 = 0;
          pSteerAngle[0] = 0.0;
          v37 = -0.5;
          v38 = 0.0;
          if ( (float)((float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_pMat->xy)
                             + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_pMat->yy))
                     + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_pMat->zy)) > 0.1 )
          {
            v38 = 0.5;
            v37 = 0.0;
          }
          v6 = LODWORD(v38);
          pGasPedal = v37;
          v13 = LODWORD(v37);
          pBrakePedal = v38;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
            pVehicle->AutoPilot.TempAction = 0;
          break;
        case 23:
          v49 = 0;
          m_fSteerAngle = pVehicle->m_fSteerAngle;
          pSteerAngle[0] = m_fSteerAngle;
          pBrakePedal = 0.0;
          pGasPedal = 1.0;
          v39 = pVehicle->m_pMat;
          if ( v39 )
          {
            xy = v39->xy;
            yy = v39->yy;
            zy = v39->zy;
          }
          else
          {
            m_heading = pVehicle->m_transform.m_heading;
            v45 = sinf(m_heading);
            yy = cosf(m_heading);
            zy = 0.0;
            LODWORD(xy) = LODWORD(v45) ^ 0x80000000;
          }
          v6 = 0;
          v46 = pVehicle->AutoPilot.TempActionFinish;
          v47 = (float)(zy * (float)(CTimer::ms_fTimeStep * 0.012)) + pVehicle->m_vecMoveSpeed.z;
          v48 = pVehicle->m_vecMoveSpeed.y + (float)(yy * (float)(CTimer::ms_fTimeStep * 0.012));
          pVehicle->m_vecMoveSpeed.x = pVehicle->m_vecMoveSpeed.x + (float)(xy * (float)(CTimer::ms_fTimeStep * 0.012));
          pVehicle->m_vecMoveSpeed.y = v48;
          pVehicle->m_vecMoveSpeed.z = v47;
          if ( CTimer::m_snTimeInMilliseconds > v46 )
            pVehicle->AutoPilot.TempAction = 0;
LABEL_95:
          v13 = 1065353216;
          break;
        case 24:
          m_fSteerAngle = 0.0;
          v6 = 1065353216;
          v49 = 0;
          pGasPedal = 0.0;
          pSteerAngle[0] = 0.0;
          pBrakePedal = 1.0;
          v43 = CTimer::m_snTimeInMilliseconds;
          if ( CTimer::m_snTimeInMilliseconds > pVehicle->AutoPilot.TempActionFinish )
          {
            pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
            pVehicle->AutoPilot.LastTimeMoving = v43;
            pVehicle->AutoPilot.TempAction = 0;
            v6 = 1065353216;
          }
          goto LABEL_23;
        default:
LABEL_30:
          CCarCtrl::SteerAICarWithPhysics_OnlyMission(pVehicle, pSteerAngle, &pGasPedal, &pBrakePedal, (bool *)&v49);
          v6 = LODWORD(pBrakePedal);
          v13 = LODWORD(pGasPedal);
          m_fSteerAngle = pSteerAngle[0];
          v17 = (unsigned __int8)(32 * v49);
          goto LABEL_25;
      }
    }
    v17 = 0;
LABEL_25:
    m_nVehicleFlags = (int)pVehicle->m_nVehicleFlags;
    v19 = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1);
    pVehicle->m_fSteerAngle = m_fSteerAngle;
    LODWORD(pVehicle->m_fGasPedal) = v13;
    LODWORD(pVehicle->m_fBrakePedal) = v6;
    m_nModelIndex = (unsigned __int16)pVehicle->m_nModelIndex;
    *(_DWORD *)&pVehicle->m_nVehicleFlags = v17 | m_nVehicleFlags & 0xFFFFFFDF;
    *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) = v19;
    if ( m_nModelIndex == 539 )
    {
      *(float *)&pVehicle[1].AutoPilot.ConstrainAreaMaxX = m_fSteerAngle;
      LODWORD(pVehicle[1].AutoPilot.TargetCoors.y) = v13;
    }
  }
}
// 2F226C: variable 'v1' is possibly undefined
// 2F226C: variable 'v2' is possibly undefined

//----- (002F2594) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysics_OnlyMission(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *a5)
{
  float32x2_t v5; // d0
  unsigned __int64 v10; // r2
  CVehicle *v11; // r0
  CVehicle *pTargetEntity; // r1
  CMatrix *v13; // r0
  unsigned __int64 *p_m_transform; // r3
  CVehicle *PlayerVehicle; // r0
  uint16 RandomSeed; // r9
  float v17; // s16
  CVehicle *v18; // r0
  uint16 v19; // r9
  float v20; // s18
  float v21; // s0
  float v22; // s0
  float x; // s16
  float y; // s18
  float v25; // s20
  float v26; // s0
  float v27; // s2
  float v28; // s2
  float v29; // s16
  float v30; // s18
  float v31; // r9
  float v32; // r11
  const CVector *PlayerSpeed; // r0
  CEntity *v34; // r0
  float z; // s2
  float m_heading; // s0
  CMatrix *v37; // r1
  float *p_x; // r2
  float v39; // s8
  float v40; // s8
  CMatrix *v41; // r0
  CSimpleTransform *v42; // r1
  Int8 v43; // r1
  CEntity *v44; // r0
  CMatrix *v45; // r1
  float *v46; // r2
  CMatrix *v47; // r0
  CSimpleTransform *v48; // r1
  RwReal v49; // r9
  CEntity *v50; // r0
  CMatrix *v51; // r1
  CMatrix *v52; // r2
  CSimpleTransform *v53; // r3
  float *v54; // r1
  float ATanOfXY; // r0
  CEntity *v56; // r1
  CMatrix *v57; // r0
  CSimpleTransform *v58; // r2
  CMatrix *v59; // r0
  CSimpleTransform *v60; // r5
  float v61; // s16
  CSimpleTransform *v62; // r1
  float v63; // s18
  CMatrix *v64; // r0
  float v65; // r0
  CMatrix *v66; // r0
  CSimpleTransform *v67; // r9
  CSimpleTransform *v68; // r1
  float32x2_t v69; // d16
  unsigned __int64 v70; // d1
  CPhysical *v71; // r1
  CMatrix *v72; // r0
  float *v73; // r3
  CEntity *v74; // r0
  CMatrix *v75; // r1
  CMatrix *v76; // r2
  CSimpleTransform *v77; // r3
  CSimpleTransform *v78; // r1
  float32x2_t v79; // d16
  float v80; // s0
  float32x2_t v81; // d1
  float v82; // s0
  float v83; // s0
  float v84; // s8
  float v85; // s4
  float v86; // s2
  RwReal v87; // s0
  RwReal v88; // s0
  float v89; // s4
  CEntity *v90; // r0
  CMatrix *v91; // r1
  float *v92; // r2
  CMatrix *v93; // r0
  float v94; // s16
  CSimpleTransform *v95; // r1
  float v96; // s18
  float v97; // s2
  RwReal v98; // s0
  float v99; // s2
  float v100; // s0
  float v101; // s4
  CEntity *PlayerPed; // r0
  CMatrix *v103; // r11
  CSimpleTransform *v104; // r0
  float v105; // s16
  float xy; // s18
  CMatrix *v107; // r1
  CMatrix *v108; // r1
  CMatrix *v109; // r0
  float v110; // s8
  float v111; // s10
  __int64 v112; // d16
  RwReal v113; // r0
  CVehicle *v114; // r0
  float32x2_t v115; // d16
  float v116; // s0
  CMatrix *m_pMat; // r0
  float32x2_t v118; // d16
  CSimpleTransform *p_tx; // r1
  unsigned __int64 v120; // d4
  float v121; // s16
  CVehicle *v122; // r0
  CVehicle *v123; // r0
  CPed *v124; // r0
  float TargetX; // [sp+18h] [bp-78h]
  CVector v126; // [sp+1Ch] [bp-74h] BYREF
  CVector v; // [sp+28h] [bp-68h] BYREF
  CVector v128; // [sp+38h] [bp-58h] BYREF
  CVector v129; // [sp+48h] [bp-48h] BYREF

  switch ( pVehicle->AutoPilot.Mission )
  {
    case 0:
    case 0xA:
    case 0xB:
      *pSteerAngle = 0.0;
      *pGasPedal = 0.0;
      *a5 = 1;
      *pBrakePedal = 0.5;
      return;
    case 1:
    case 2:
    case 4:
    case 8:
    case 0xC:
    case 0xF:
    case 0x11:
    case 0x2B:
    case 0x34:
    case 0x36:
    case 0x3D:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
      CCarCtrl::SteerAICarWithPhysicsFollowPath(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 3:
      FindPlayerCoors(&v129, -1);
      if ( FindPlayerVehicle(-1, 0) )
      {
        PlayerVehicle = FindPlayerVehicle(-1, 0);
        RandomSeed = pVehicle->RandomSeed;
        v17 = (float)((float)(PlayerVehicle->m_pMat->xy * pVehicle->m_pMat->xy)
                    + (float)(PlayerVehicle->m_pMat->yy * pVehicle->m_pMat->yy))
            + (float)(PlayerVehicle->m_pMat->zy * pVehicle->m_pMat->zy);
        v18 = FindPlayerVehicle(-1, 0);
        if ( (RandomSeed & 1) != 0 && v17 > 0.5 )
        {
          v19 = pVehicle->RandomSeed;
          v20 = (float)(CModelInfo::ms_modelInfoPtrs[v18->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x
                      + CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x)
              + -0.2;
          v21 = v20 * FindPlayerVehicle(-1, 0)->m_pMat->xx;
          if ( (v19 & 2) != 0 )
          {
            v129.x = v129.x + v21;
            v22 = v129.y + (float)(v20 * FindPlayerVehicle(-1, 0)->m_pMat->yx);
          }
          else
          {
            v129.x = v129.x - v21;
            v22 = v129.y - (float)(v20 * FindPlayerVehicle(-1, 0)->m_pMat->yx);
          }
          v129.y = v22;
          v114 = FindPlayerVehicle(-1, 0);
          v115.n64_u64[0] = *(unsigned __int64 *)&v114->m_vecMoveSpeed.y;
          v116 = v114->m_vecMoveSpeed.x - pVehicle->m_vecMoveSpeed.x;
          m_pMat = pVehicle->m_pMat;
          v118.n64_u64[0] = vsub_f32(v115, *(float32x2_t *)&pVehicle->m_vecMoveSpeed.y).n64_u64[0];
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pVehicle->m_transform;
          v120 = vmul_f32(v118, v118).n64_u64[0];
          if ( sqrtf(
                 (float)((float)(p_tx->m_translate.x - v129.x) * (float)(p_tx->m_translate.x - v129.x))
               + (float)((float)(p_tx->m_translate.y - v129.y) * (float)(p_tx->m_translate.y - v129.y))) < (float)((float)(sqrtf((float)((float)(v116 * v116) + *(float *)&v120) + *((float *)&v120 + 1)) * 12.0) + 2.0)
            && !pVehicle->AutoPilot.TempAction )
          {
            pVehicle->AutoPilot.TempAction = 8 - ((pVehicle->RandomSeed & 2) != 0);
            pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 250;
          }
        }
        else
        {
          v129.x = v129.x + (float)((float)(v18->m_pMat->xx * 0.00625) * (float)(LOBYTE(pVehicle->RandomSeed) - 128));
          v129.y = v129.y
                 + (float)((float)(FindPlayerVehicle(-1, 0)->m_pMat->yx * 0.00625)
                         * (float)(LOBYTE(pVehicle->RandomSeed) - 128));
        }
        if ( v17 < 0.0 )
        {
          v121 = v17 * -0.02;
          v129.x = v129.x + (float)(v121 * FindPlayerSpeed(-1)->x);
          v129.y = v129.y + (float)(v121 * FindPlayerSpeed(-1)->y);
        }
        if ( *(_BYTE *)&pVehicle->m_nVehicleFlags << 31 )
        {
          v122 = FindPlayerVehicle(-1, 0);
          if ( sqrtf(
                 (float)(v122->m_vecMoveSpeed.x * v122->m_vecMoveSpeed.x)
               + (float)(v122->m_vecMoveSpeed.y * v122->m_vecMoveSpeed.y)) > 0.4 )
          {
            v123 = FindPlayerVehicle(-1, 0);
            v124 = CVehicle::PickRandomPassenger(v123);
            if ( v124 )
              CPed::Say(v124, 0x26u, 0, 1.0, 0, 0, 0);
          }
        }
      }
      goto LABEL_129;
    case 5:
      FindPlayerEntity(-1);
      FindPlayerCoors(&v129, -1);
      x = v129.x;
      FindPlayerCoors(&v128, -1);
      y = v128.y;
      v25 = FindPlayerSpeed(-1)->x;
      v26 = FindPlayerSpeed(-1)->y;
      v27 = sqrtf((float)(v25 * v25) + (float)(v26 * v26));
      if ( v27 > 0.13 )
      {
        v28 = 0.13 / v27;
        v26 = v26 * v28;
        v25 = v25 * v28;
      }
      v29 = x + (float)(v25 * 60.0);
      v30 = y + (float)(v26 * 60.0);
      goto LABEL_30;
    case 6:
      FindPlayerCoors(&v129, -1);
      TargetX = v129.x;
      FindPlayerCoors(&v128, -1);
      v31 = v128.y;
      v32 = FindPlayerSpeed(-1)->x;
      PlayerSpeed = FindPlayerSpeed(-1);
      CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop(
        pVehicle,
        TargetX,
        v31,
        v32,
        PlayerSpeed->y,
        pSteerAngle,
        pGasPedal,
        pBrakePedal,
        a5);
      return;
    case 9:
    case 0xD:
    case 0x18:
      v10 = *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x;
      goto LABEL_4;
    case 0xE:
      CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget(
        pVehicle,
        pVehicle->AutoPilot.TargetCoors.x,
        pVehicle->AutoPilot.TargetCoors.y,
        pSteerAngle,
        pGasPedal,
        pBrakePedal);
      *a5 = 0;
      return;
    case 0x10:
    case 0x37:
      pTargetEntity = (CVehicle *)pVehicle->AutoPilot.pTargetEntity;
      v13 = pTargetEntity->m_pMat;
      p_m_transform = (unsigned __int64 *)&v13->tx;
      if ( !v13 )
        p_m_transform = (unsigned __int64 *)&pTargetEntity->m_transform;
      v10 = *p_m_transform;
      goto LABEL_130;
    case 0x12:
      v34 = pVehicle->AutoPilot.pTargetEntity;
      z = v34[1].m_transform.m_translate.z;
      m_heading = v34[1].m_transform.m_heading;
      v37 = v34->m_pMat;
      p_x = &v37->tx;
      if ( !v37 )
        p_x = &v34->m_transform.m_translate.x;
      v39 = sqrtf((float)(z * z) + (float)(m_heading * m_heading));
      if ( v39 > 0.13 )
      {
        v40 = 0.13 / v39;
        m_heading = m_heading * v40;
        z = z * v40;
      }
      v29 = *p_x + (float)(z * 60.0);
      v30 = p_x[1] + (float)(m_heading * 60.0);
LABEL_30:
      pVehicle->AutoPilot.DrivingMode = 2;
      CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(pVehicle, 0, v29, v30, pSteerAngle, pGasPedal, pBrakePedal, a5);
      v41 = pVehicle->m_pMat;
      v42 = (CSimpleTransform *)&v41->tx;
      if ( !v41 )
        v42 = &pVehicle->m_transform;
      if ( (float)((float)((float)(v29 - v42->m_translate.x) * (float)(v29 - v42->m_translate.x))
                 + (float)((float)(v30 - v42->m_translate.y) * (float)(v30 - v42->m_translate.y))) < 25.0 )
      {
        v43 = 6;
        if ( pVehicle->AutoPilot.Mission == 18 )
          v43 = 19;
        pVehicle->AutoPilot.Mission = v43;
      }
      return;
    case 0x13:
      v44 = pVehicle->AutoPilot.pTargetEntity;
      v45 = v44->m_pMat;
      v46 = &v45->tx;
      if ( !v45 )
        v46 = &v44->m_transform.m_translate.x;
      CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop(
        pVehicle,
        *v46,
        v46[1],
        v44[1].m_transform.m_translate.z,
        v44[1].m_transform.m_heading,
        pSteerAngle,
        pGasPedal,
        pBrakePedal,
        a5);
      return;
    case 0x14:
      CCarCtrl::SteerAIHeliTowardsTargetCoors((CAutomobile *)pVehicle);
      return;
    case 0x15:
      CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 0x16:
      v47 = pVehicle->m_pMat;
      v48 = (CSimpleTransform *)&v47->tx;
      if ( !v47 )
        v48 = &pVehicle->m_transform;
      *(float *)&pVehicle[1].AutoPilot.aPathNodeList[6] = CGeneral::GetATanOfXY(
                                                            pVehicle->AutoPilot.TargetCoors.x - v48->m_translate.x,
                                                            pVehicle->AutoPilot.TargetCoors.y - v48->m_translate.y);
      goto LABEL_61;
    case 0x17:
    case 0x38:
      CCarCtrl::GetAIHeliToAttackPlayer((CAutomobile *)pVehicle);
      return;
    case 0x19:
      FindPlayerCoors(&v129, -1);
      v49 = v129.x;
      FindPlayerCoors(&v128, -1);
      v11 = pVehicle;
      pTargetEntity = 0;
      v10 = __PAIR64__(LODWORD(v128.y), LODWORD(v49));
      goto LABEL_131;
    case 0x1A:
      CCarCtrl::SteerAICarBlockingPlayerForwardAndBack(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 0x1D:
      CCarCtrl::SteerAICarTowardsPointInEscort(
        pVehicle,
        (CVehicle *)pVehicle->AutoPilot.pTargetEntity,
        -(float)((float)(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x
                       + CModelInfo::ms_modelInfoPtrs[pVehicle->AutoPilot.pTargetEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x)
               + 2.0),
        0.0,
        (bool *)pSteerAngle,
        pGasPedal,
        (int *)pBrakePedal,
        a5);
      return;
    case 0x1E:
      CCarCtrl::SteerAICarTowardsPointInEscort(
        pVehicle,
        (CVehicle *)pVehicle->AutoPilot.pTargetEntity,
        (float)(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x
              + CModelInfo::ms_modelInfoPtrs[pVehicle->AutoPilot.pTargetEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x)
      + 2.0,
        0.0,
        (bool *)pSteerAngle,
        pGasPedal,
        (int *)pBrakePedal,
        a5);
      return;
    case 0x1F:
      CCarCtrl::SteerAICarTowardsPointInEscort(
        pVehicle,
        (CVehicle *)pVehicle->AutoPilot.pTargetEntity,
        0.0,
        -(float)((float)(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y
                       + CModelInfo::ms_modelInfoPtrs[pVehicle->AutoPilot.pTargetEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y)
               + 7.0),
        (bool *)pSteerAngle,
        pGasPedal,
        (int *)pBrakePedal,
        a5);
      return;
    case 0x20:
      CCarCtrl::SteerAICarTowardsPointInEscort(
        pVehicle,
        (CVehicle *)pVehicle->AutoPilot.pTargetEntity,
        0.0,
        (float)(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y
              + CModelInfo::ms_modelInfoPtrs[pVehicle->AutoPilot.pTargetEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y)
      + 7.0,
        (bool *)pSteerAngle,
        pGasPedal,
        (int *)pBrakePedal,
        a5);
      return;
    case 0x21:
      CCarCtrl::SteerAICarWithPhysicsFollowPath_Racing(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 0x22:
      CCarCtrl::SteerAICarWithPhysicsFollowPreRecordedPath(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 0x23:
    case 0x3B:
      CCarCtrl::GetAIPlaneToAttackPlayer((CAutomobile *)pVehicle);
      return;
    case 0x24:
      goto LABEL_61;
    case 0x25:
      v50 = pVehicle->AutoPilot.pTargetEntity;
      v51 = pVehicle->m_pMat;
      v52 = v50->m_pMat;
      v53 = (CSimpleTransform *)&v51->tx;
      if ( !v51 )
        v53 = &pVehicle->m_transform;
      v54 = &v52->tx;
      if ( !v52 )
        v54 = &v50->m_transform.m_translate.x;
      ATanOfXY = CGeneral::GetATanOfXY(*v54 - v53->m_translate.x, v54[1] - v53->m_translate.y);
      v56 = pVehicle->AutoPilot.pTargetEntity;
      *(float *)&pVehicle[1].AutoPilot.aPathNodeList[6] = ATanOfXY;
      v57 = v56->m_pMat;
      v58 = (CSimpleTransform *)&v57->tx;
      if ( !v57 )
        v58 = &v56->m_transform;
      pVehicle[1].AutoPilot.aPathNodeList[3] = (CNodeAddress)LODWORD(v58->m_translate.z);
LABEL_61:
      CCarCtrl::FlyAIPlaneInCertainDirection((CPlane *)pVehicle);
      return;
    case 0x26:
      CCarCtrl::FlyAIHeliInCertainDirection(
        (CHeli *)pVehicle,
        *(float *)&pVehicle[1].AutoPilot.aPathNodeList[6],
        1000.0,
        0);
      return;
    case 0x27:
    case 0x29:
      CCarCtrl::SteerAIHeliToFollowEntity((CAutomobile *)pVehicle);
      return;
    case 0x28:
      CCarCtrl::SteerAIHeliAsPoliceHeli((CAutomobile *)pVehicle);
      return;
    case 0x2A:
      FindPlayerCoors(&v129, -1);
      v59 = pVehicle->m_pMat;
      v60 = &pVehicle->m_transform;
      v61 = v129.x;
      v62 = &pVehicle->m_transform;
      if ( v59 )
        v62 = (CSimpleTransform *)&v59->tx;
      v63 = v62->m_translate.x;
      FindPlayerCoors(&v128, -1);
      v64 = pVehicle->m_pMat;
      if ( v64 )
        v60 = (CSimpleTransform *)&v64->tx;
      v65 = CGeneral::GetATanOfXY(v61 - v63, v128.y - v60->m_translate.y);
      CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVehicle, v65 + 3.1416, 1000.0, 0);
      return;
    case 0x2C:
      FindPlayerCoors(&v129, -1);
      v66 = pVehicle->m_pMat;
      v67 = &pVehicle->m_transform;
      v68 = &pVehicle->m_transform;
      if ( v66 )
        v68 = (CSimpleTransform *)&v66->tx;
      v69.n64_u64[0] = vsub_f32(*(float32x2_t *)&v129.y, *(float32x2_t *)&v68->m_translate.y).n64_u64[0];
      v70 = vmul_f32(v69, v69).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(v129.x - v68->m_translate.x) * (float)(v129.x - v68->m_translate.x))
                   + *(float *)&v70)
           + *((float *)&v70 + 1)) >= 10.0 )
      {
        FindPlayerCoors(&v129, -1);
        if ( FindPlayerVehicle(-1, 0) )
        {
          v103 = pVehicle->m_pMat;
          FindPlayerCoors(&v128, -1);
          v104 = &pVehicle->m_transform;
          if ( v103 )
            v104 = (CSimpleTransform *)&v103->tx;
          v105 = v104->m_translate.x - v128.x;
          xy = FindPlayerVehicle(-1, 0)->m_pMat->xy;
          if ( (float)((float)(v105 * xy) + (float)(v105 * FindPlayerVehicle(-1, 0)->m_pMat->yy)) > 0.0 )
          {
            v107 = FindPlayerVehicle(-1, 0)->m_pMat;
            v.y = 0.0;
            v.x = 4.0;
            v.z = 0.0;
            operator*(&v128, v107, &v);
            v108 = FindPlayerVehicle(-1, 0)->m_pMat;
            v126.y = 0.0;
            v126.x = -4.0;
            v126.z = 0.0;
            operator*(&v, v108, &v126);
            v109 = pVehicle->m_pMat;
            if ( v109 )
              v67 = (CSimpleTransform *)&v109->tx;
            v110 = v67->m_translate.y;
            v111 = v67->m_translate.z;
            if ( sqrtf(
                   (float)((float)((float)(v67->m_translate.x - v128.x) * (float)(v67->m_translate.x - v128.x))
                         + (float)((float)(v110 - v128.y) * (float)(v110 - v128.y)))
                 + (float)((float)(v111 - v128.z) * (float)(v111 - v128.z))) >= sqrtf(
                                                                                  (float)((float)((float)(v67->m_translate.x - v.x)
                                                                                                * (float)(v67->m_translate.x - v.x))
                                                                                        + (float)((float)(v110 - v.y)
                                                                                                * (float)(v110 - v.y)))
                                                                                + (float)((float)(v111 - v.z)
                                                                                        * (float)(v111 - v.z))) )
            {
              v113 = v.z;
              v112 = *(_QWORD *)&v.x;
            }
            else
            {
              v112 = *(_QWORD *)&v128.x;
              v113 = v128.z;
            }
            v129.z = v113;
            *(_QWORD *)&v129.x = v112;
          }
        }
LABEL_129:
        pTargetEntity = FindPlayerVehicle(-1, 0);
        v10 = *(_QWORD *)&v129.x;
LABEL_130:
        v11 = pVehicle;
LABEL_131:
        CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
          v11,
          pTargetEntity,
          *(float *)&v10,
          *((float *)&v10 + 1),
          pSteerAngle,
          pGasPedal,
          pBrakePedal,
          a5);
      }
      else
      {
        *pSteerAngle = 0.0;
        *pGasPedal = 0.0;
        *pBrakePedal = 1.0;
        *a5 = 0;
      }
      return;
    case 0x2D:
    case 0x31:
      CCarCtrl::SteerAICarParkPerpendicular(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 0x2E:
    case 0x32:
      CCarCtrl::SteerAICarParkParallel(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    case 0x2F:
    case 0x30:
      CCarCtrl::SteerAIHeliToLand((CAutomobile *)pVehicle);
      return;
    case 0x33:
      CCarCtrl::SteerAIHeliToKeepEntityInView((CAutomobile *)pVehicle);
      return;
    case 0x35:
      v71 = (CPhysical *)pVehicle->AutoPilot.pTargetEntity;
      v72 = v71->m_pMat;
      v73 = &v72->tx;
      if ( !v72 )
        v73 = &v71->m_transform.m_translate.x;
      CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
        pVehicle,
        v71,
        *v73,
        v73[1],
        pSteerAngle,
        pGasPedal,
        pBrakePedal,
        a5);
      v74 = pVehicle->AutoPilot.pTargetEntity;
      v75 = pVehicle->m_pMat;
      v76 = v74->m_pMat;
      v77 = (CSimpleTransform *)&v75->tx;
      if ( !v75 )
        v77 = &pVehicle->m_transform;
      v78 = (CSimpleTransform *)&v76->tx;
      if ( !v76 )
        v78 = &v74->m_transform;
      v79.n64_u64[0] = vsub_f32(*(float32x2_t *)&v77->m_translate.y, *(float32x2_t *)&v78->m_translate.y).n64_u64[0];
      v81.n64_u64[0] = vmul_f32(v79, v79).n64_u64[0];
      v80 = (float)((float)((float)(v77->m_translate.x - v78->m_translate.x)
                          * (float)(v77->m_translate.x - v78->m_translate.x))
                  + v81.n64_f32[0])
          + v81.n64_f32[1];
      v81.n64_f32[0] = (float)pVehicle->AutoPilot.FollowCarDistance;
      v82 = sqrtf(v80);
      if ( v82 < (float)(v81.n64_f32[0] + 10.0) )
      {
        v83 = v82 - v81.n64_f32[0];
        v84 = 2.0;
        v85 = sqrtf(
                (float)(v74[1].m_transform.m_translate.z * v74[1].m_transform.m_translate.z)
              + (float)(v74[1].m_transform.m_heading * v74[1].m_transform.m_heading));
        v86 = sqrtf(
                (float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
              + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y));
        if ( v83 < 0.0 )
          v84 = 5.0;
        v5.n64_f32[0] = (float)((float)(v83 * v84) + (float)(v85 * 60.0)) - (float)(v86 * 60.0);
        if ( v5.n64_f32[0] >= 0.0 )
        {
          v5.n64_f32[0] = v5.n64_f32[0] / 20.0;
          v81.n64_u32[0] = 1.0;
          *(_DWORD *)pGasPedal = vmin_f32(v5, v81).n64_u32[0];
          *pBrakePedal = 0.0;
        }
        else
        {
          *pGasPedal = 0.0;
          v5.n64_f32[0] = v5.n64_f32[0] / -10.0;
          v81.n64_u32[0] = 1.0;
          *(_DWORD *)pBrakePedal = vmin_f32(v5, v81).n64_u32[0];
        }
      }
      return;
    case 0x39:
      v87 = -1.0;
      if ( (pVehicle->RandomSeed & 1) != 0 )
        v87 = 1.0;
      *(_DWORD *)&pVehicle[1].AutoPilot.ConstrainAreaMaxY = -1097229926;
      pVehicle[1].AutoPilot.TargetCoors.y = -0.0;
      pVehicle[1].AutoPilot.TargetCoors.x = v87;
      *(RwReal *)&pVehicle[1].AutoPilot.ConstrainAreaMaxX = v87;
      return;
    case 0x3A:
      v88 = -1.0;
      v89 = -*(float *)&pVehicle[1].pPassengers[3];
      if ( (pVehicle->RandomSeed & 1) != 0 )
      {
        v88 = 1.0;
        v89 = *(float *)&pVehicle[1].pPassengers[3];
      }
      pVehicle[1].AutoPilot.TargetCoors.x = -0.3;
      pVehicle[1].AutoPilot.TargetCoors.z = -0.5;
      pVehicle[1].AutoPilot.TargetCoors.y = v88;
      *(float *)&pVehicle[1].AutoPilot.ConstrainAreaMaxY = v89;
      return;
    case 0x3C:
      v90 = pVehicle->AutoPilot.pTargetEntity;
      if ( !v90 )
        return;
      v91 = v90->m_pMat;
      v92 = &v91->tx;
      if ( !v91 )
        v92 = &v90->m_transform.m_translate.x;
      v93 = pVehicle->m_pMat;
      v94 = *v92;
      v95 = (CSimpleTransform *)&v93->tx;
      v96 = v92[1];
      if ( !v93 )
        v95 = &pVehicle->m_transform;
      v97 = v95->m_translate.y;
      v98 = v95->m_translate.x - v94;
      v129.z = 0.0;
      v129.y = v98;
      v129.x = v96 - v97;
      CVector::Normalise(&v129);
      v99 = v129.x * 10.0;
      v100 = v129.y * 10.0;
      v101 = v129.z * 10.0;
      v129.x = v129.x * 10.0;
      v129.y = v129.y * 10.0;
      v129.z = v129.z * 10.0;
      if ( LOBYTE(pVehicle->RandomSeed) << 31 )
      {
        v100 = -v100;
        v99 = -v99;
        v129.y = v100;
        v129.x = v99;
        v129.z = -v101;
      }
      *(float *)&v10 = v94 + v99;
      *((float *)&v10 + 1) = v96 + v100;
LABEL_4:
      v11 = pVehicle;
      pTargetEntity = 0;
      goto LABEL_131;
    case 0x3E:
      goto LABEL_112;
    case 0x3F:
      if ( FindPlayerVehicle(-1, 0) )
        PlayerPed = FindPlayerVehicle(-1, 0);
      else
        PlayerPed = FindPlayerPed(-1);
      pVehicle->AutoPilot.pTargetEntity = PlayerPed;
LABEL_112:
      CCarCtrl::GetAIPlaneToDoDogFight((CAutomobile *)pVehicle);
      return;
    case 0x40:
      CCarCtrl::SteerAIBoatWithPhysicsCirclingPlayer(pVehicle, pSteerAngle, pGasPedal, pBrakePedal, a5);
      return;
    default:
      return;
  }
}
// 2F2EA0: variable 'v5' is possibly undefined

//----- (002F33D8) --------------------------------------------------------
float __fastcall CCarCtrl::FindMaxSteerAngle(CVehicle *pVehicle)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float v3; // s0
  float result; // r0

  v2.n64_u32[0] = 1060320051;
  v3 = sqrtf(
         (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
               + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
       + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z));
  v1.n64_f32[0] = 0.9 - v3;
  if ( v3 > 0.7 )
    v1.n64_u32[0] = 1045220557;
  LODWORD(result) = vmin_f32(v1, v2).n64_u32[0];
  return result;
}
// 2F341A: variable 'v1' is possibly undefined
// 2F341A: variable 'v2' is possibly undefined

//----- (002F3430) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
        CVehicle *pVehicle,
        CPhysical *pException,
        float TargetX,
        float TargetY,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *pHandBrake)
{
  float32x2_t v8; // d1
  float32x2_t v9; // d2
  float32x2_t v10; // d3
  float32x2_t v11; // d13
  CMatrix *m_pMat; // r0
  float xy; // s0
  float yy; // s20
  float v19; // s2
  float v20; // s22
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  float ATanOfXY; // r6
  float v24; // r0
  float AngleToWeaveThroughTraffic; // s22
  float v26; // r3
  unsigned int DrivingMode; // r0
  float v28; // s20
  float x; // s28
  float y; // s17
  float z; // s30
  CMatrix *v32; // r0
  float v33; // r0
  float v34; // s0
  float32x2_t v35; // d0
  unsigned __int32 i; // s0
  float CruiseSpeed; // s14
  float32x2_t v38; // d2
  unsigned __int32 v39; // s2
  float v40; // s8
  float v41; // s10

  *pHandBrake = 0;
  m_pMat = pVehicle->m_pMat;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  v19 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  if ( v19 == 0.0 )
  {
    v20 = 1.0;
  }
  else
  {
    yy = yy / v19;
    v20 = xy / v19;
  }
  p_m_transform = &pVehicle->m_transform;
  p_tx = &pVehicle->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  ATanOfXY = CGeneral::GetATanOfXY(TargetX - p_tx->m_translate.x, TargetY - p_tx->m_translate.y);
  v24 = v20;
  AngleToWeaveThroughTraffic = ATanOfXY;
  v26 = CGeneral::GetATanOfXY(v24, yy);
  DrivingMode = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
  v28 = v26;
  if ( DrivingMode <= 6 && ((1 << DrivingMode) & 0x64) != 0 )
    AngleToWeaveThroughTraffic = CCarCtrl::FindAngleToWeaveThroughTraffic(pVehicle, pException, ATanOfXY, v26, 1.0);
  for ( v11.n64_f32[0] = AngleToWeaveThroughTraffic - v28;
        v11.n64_f32[0] < -3.1416;
        v11.n64_f32[0] = v11.n64_f32[0] + 6.2832 )
  {
    ;
  }
  for ( ; v11.n64_f32[0] > 3.1416; v11.n64_f32[0] = v11.n64_f32[0] + -6.2832 )
    ;
  x = pVehicle->m_vecMoveSpeed.x;
  y = pVehicle->m_vecMoveSpeed.y;
  z = pVehicle->m_vecMoveSpeed.z;
  if ( sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z)) > 0.3 && fabsf(v11.n64_f32[0]) > 0.7 )
  {
    *pHandBrake = 1;
    x = pVehicle->m_vecMoveSpeed.x;
    y = pVehicle->m_vecMoveSpeed.y;
    z = pVehicle->m_vecMoveSpeed.z;
  }
  v32 = pVehicle->m_pMat;
  if ( v32 )
    p_m_transform = (CSimpleTransform *)&v32->tx;
  v33 = CGeneral::GetATanOfXY(TargetX - p_m_transform->m_translate.x, TargetY - p_m_transform->m_translate.y);
  v10.n64_u32[0] = 1060320051;
  v34 = sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z));
  v9.n64_f32[0] = 0.9 - v34;
  if ( v34 > 0.7 )
    v9.n64_u32[0] = 1045220557;
  v8.n64_f32[0] = v33 - v28;
  v35.n64_u64[0] = vmin_f32(v9, v10).n64_u64[0];
  v9.n64_f32[0] = -v35.n64_f32[0];
  for ( i = vmin_f32(vmax_f32(v11, v9), v35).n64_u32[0]; v8.n64_f32[0] < -3.1416; v8.n64_f32[0] = v8.n64_f32[0] + 6.2832 )
    ;
  for ( ; v8.n64_f32[0] > 3.1416; v8.n64_f32[0] = v8.n64_f32[0] + -6.2832 )
    ;
  v10.n64_u32[0] = 0;
  v8.n64_f32[0] = fabsf(v8.n64_f32[0]) + -0.4;
  CruiseSpeed = (float)pVehicle->AutoPilot.CruiseSpeed;
  v38.n64_u64[0] = vmax_f32(v8, v10).n64_u64[0];
  v39 = 1.0;
  v40 = sqrtf(
          (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
        + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z));
  v41 = (float)((float)(v38.n64_f32[0] / 0.8) * -0.6) + 1.0;
  if ( v38.n64_f32[0] > 0.8 )
    v41 = 0.4;
  *pBrakePedal = 0.0;
  v38.n64_f32[0] = (float)(v41 * CruiseSpeed) - (float)(v40 * 60.0);
  if ( v38.n64_f32[0] <= 0.0 )
  {
    *pGasPedal = 0.0;
    v8.n64_f32[0] = v38.n64_f32[0] / -20.0;
    v38.n64_u32[0] = 0.5;
    *(_DWORD *)pBrakePedal = vmin_f32(v8, v38).n64_u32[0];
  }
  else
  {
    if ( (float)(v40 * 60.0) < 25.0 )
    {
      v10.n64_u32[0] = 1.0;
      v8.n64_f32[0] = v38.n64_f32[0] / 10.0;
      v39 = vmin_f32(v8, v10).n64_u32[0];
    }
    *(_DWORD *)pGasPedal = v39;
    if ( v38.n64_f32[0] > 3.0
      && pVehicle->m_vehicleType == 10
      && *(float *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType <= 0.0 )
    {
      *(_DWORD *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType = 1092616192;
    }
  }
  *(_DWORD *)pSteerAngle = i;
}
// 2F35EC: variable 'v9' is possibly undefined
// 2F35EC: variable 'v10' is possibly undefined
// 2F35FC: variable 'v11' is possibly undefined
// 2F366C: variable 'v8' is possibly undefined

//----- (002F3778) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget(
        CVehicle *pVehicle,
        CEntity *pTargetEntity,
        float TargetX,
        float TargetY,
        float TargetVelX,
        float TargetVelY,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *pHandBrake)
{
  float v10; // s0
  float v12; // s2
  float v14; // s8
  float v15; // s8
  float v16; // s2
  float v17; // s18
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  Int8 v20; // r1

  v10 = TargetVelY;
  v12 = TargetVelX;
  v14 = sqrtf((float)(v12 * v12) + (float)(v10 * v10));
  if ( v14 > 0.13 )
  {
    v15 = 0.13 / v14;
    v10 = v15 * TargetVelY;
    v12 = v15 * TargetVelX;
  }
  pVehicle->AutoPilot.DrivingMode = 2;
  v16 = v12 * 60.0;
  v17 = (float)(v10 * 60.0) + TargetY;
  CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
    pVehicle,
    0,
    v16 + TargetX,
    v17,
    pSteerAngle,
    pGasPedal,
    pBrakePedal,
    pHandBrake);
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  if ( (float)((float)((float)((float)(v16 + TargetX) - p_tx->m_translate.x)
                     * (float)((float)(v16 + TargetX) - p_tx->m_translate.x))
             + (float)((float)(v17 - p_tx->m_translate.y) * (float)(v17 - p_tx->m_translate.y))) < 25.0 )
  {
    v20 = 6;
    if ( pVehicle->AutoPilot.Mission == 18 )
      v20 = 19;
    pVehicle->AutoPilot.Mission = v20;
  }
}

//----- (002F3850) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysicsTryingToBlockTarget_Stop(
        CVehicle *pVehicle,
        float TargetX,
        float TargetY,
        float TargetVelX,
        float TargetVelY,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *pHandBrake)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  int Mission; // r0
  float v15; // s16
  Int8 v16; // r1
  CPed *pDriver; // r0
  CTask *ActiveTask; // r0
  CVehicle *PlayerVehicle; // r0
  CVehicle *v20; // r0
  CVehicle *v21; // r0

  *pSteerAngle = 0.0;
  *pGasPedal = 0.0;
  *pBrakePedal = 1.0;
  *pHandBrake = 1;
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
  v15 = (float)((float)(p_tx->m_translate.x - TargetX) * (float)(p_tx->m_translate.x - TargetX))
      + (float)((float)(p_tx->m_translate.y - TargetY) * (float)(p_tx->m_translate.y - TargetY));
  if ( v15 > 100.0 )
  {
    v16 = 5;
    if ( Mission == 19 )
      v16 = 18;
    pVehicle->AutoPilot.Mission = v16;
    return;
  }
  if ( Mission == 19 )
  {
    pDriver = pVehicle->pDriver;
    if ( pDriver )
    {
      ActiveTask = CTaskManager::GetActiveTask(&pDriver->m_pPedIntelligence->m_taskManager);
      if ( ActiveTask )
      {
        if ( (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) == 1105 )
          return;
      }
    }
    if ( (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
               + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y)) >= 0.0001
      || (float)((float)(TargetVelX * TargetVelX) + (float)(TargetVelY * TargetVelY)) >= 0.0004
      || !(*(_BYTE *)&pVehicle->m_nVehicleFlags << 31) )
    {
      return;
    }
LABEL_23:
    CCarAI::TellOccupantsToLeaveCar(pVehicle);
    pVehicle->AutoPilot.Mission = 0;
    pVehicle->AutoPilot.CruiseSpeed = 0;
    return;
  }
  if ( FindPlayerVehicle(-1, 0)
    && (PlayerVehicle = FindPlayerVehicle(-1, 0),
        sqrtf(
          (float)((float)(PlayerVehicle->m_vecMoveSpeed.x * PlayerVehicle->m_vecMoveSpeed.x)
                + (float)(PlayerVehicle->m_vecMoveSpeed.y * PlayerVehicle->m_vecMoveSpeed.y))
        + (float)(PlayerVehicle->m_vecMoveSpeed.z * PlayerVehicle->m_vecMoveSpeed.z)) < 0.05) )
  {
    pVehicle->GetOutOfCarTimer = (unsigned int)(float)((float)(CTimer::ms_fTimeStep * 16.667)
                                                     + (float)pVehicle->GetOutOfCarTimer);
  }
  else
  {
    pVehicle->GetOutOfCarTimer = 0;
  }
  if ( !FindPlayerVehicle(-1, 0)
    || (v20 = FindPlayerVehicle(-1, 0), CVehicle::IsUpsideDown(v20))
    || (v21 = FindPlayerVehicle(-1, 0),
        sqrtf(
          (float)((float)(v21->m_vecMoveSpeed.x * v21->m_vecMoveSpeed.x)
                + (float)(v21->m_vecMoveSpeed.y * v21->m_vecMoveSpeed.y))
        + (float)(v21->m_vecMoveSpeed.z * v21->m_vecMoveSpeed.z)) < 0.05)
    && pVehicle->GetOutOfCarTimer >= 0x9C5u )
  {
    if ( v15 < 100.0 && (*(_DWORD *)&pVehicle->m_nVehicleFlags & 1) != 0 )
      goto LABEL_23;
  }
}

//----- (002F3A70) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysicsFollowPath(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *pHandBrake)
{
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  float32x2_t v7; // d3
  float32x2_t v8; // d4
  float32x2_t v9; // d12
  float32x2_t v10; // d15
  unsigned int Address; // r0
  CPathNode *v16; // r2
  bool v17; // zf
  CPathNode *v18; // r5
  bool v19; // zf
  CPathNode *v20; // r3
  bool v21; // zf
  CMatrix *m_pMat; // r3
  float xy; // s0
  float yy; // s26
  float v25; // s2
  float v26; // s19
  float InvertDirOldLink; // s20
  float OldLane; // s16
  CCarPathLink *v29; // r0
  CCarPathLink *v30; // r1
  float DirXb; // s18
  float DirYb; // s22
  int v33; // s24
  float v34; // s28
  float v35; // r0
  int NewLane; // s4
  float v37; // s21
  float v38; // s17
  float v39; // r0
  int v40; // r12
  int v41; // r2
  float v42; // s18
  CCarPathLink *v43; // r1
  int32 m_vehicleType; // r5
  float v45; // s16
  float v46; // s0
  CCarPathLink *v47; // r3
  int CoorsY; // r6
  float v49; // s20
  float CoorsX; // s6
  float v51; // s12
  CSimpleTransform *p_m_transform; // r0
  CMatrix *v53; // r1
  float v54; // s14
  float v55; // s6
  float v56; // s8
  float v57; // s10
  float v58; // s12
  float32x2_t v59; // d0
  float v60; // s22
  float v61; // s14
  float32x2_t v62; // d14
  float v63; // s2
  float v64; // s4
  CEntity *v65; // r1
  CMatrix *v66; // r0
  __int64 *v67; // r3
  unsigned int v68; // r0
  int v69; // r5
  float v70; // s2
  CCarPathLink *v71; // r2
  CSimpleTransform *v72; // r0
  float v73; // s0
  float v74; // s4
  float v75; // s6
  CCarPathLink *v76; // r0
  float v77; // s0
  float v78; // s10
  int v79; // r2
  int v80; // r12
  CCarPathLink *v81; // r0
  int v82; // r3
  int v83; // s2
  CSimpleTransform *p_tx; // r0
  float v85; // s2
  float v86; // s4
  float v87; // s6
  float ATanOfXY; // r9
  float AngleToWeaveThroughTraffic; // s24
  float v90; // r3
  unsigned int DrivingMode; // r0
  float v92; // s26
  float x; // s17
  float z; // s23
  CMatrix *v95; // r0
  float v96; // s0
  bool v97; // cc
  unsigned int v98; // r0
  float32x2_t v99; // d1
  Int8 v100; // r1
  float MaximumSpeedForThisCarInTraffic; // r0
  int v102; // r5
  float v103; // s2
  UInt16 v104; // r1
  CCarPathLink *v105; // r0
  int v106; // r1
  CSimpleTransform *v107; // r6
  int v108; // r2
  CCarPathLink *v109; // r0
  CSimpleTransform *v110; // r1
  float v111; // s4
  CMatrix *v112; // r0
  float v113; // s17
  float v114; // r9
  float v115; // s26
  float v116; // s18
  float v117; // r0
  unsigned __int32 i; // s0
  float v119; // s2
  float v120; // s8
  unsigned int CruiseSpeed; // s4
  float32x2_t v122; // d3
  int v123; // r0
  bool v124; // zf
  CMatrix *v125; // r0
  float y; // s4
  float v127; // s2
  float v128; // s6
  Int8 v129; // r0
  __int64 v130; // r2
  Int8 v131; // r0
  CEntity *pTargetEntity; // r0
  Int8 v133; // r1
  CMatrix *v134; // r1
  float v135; // [sp+14h] [bp-9Ch]
  float32x2_t v136; // [sp+18h] [bp-98h]
  float v137; // [sp+24h] [bp-8Ch]
  float v138; // [sp+28h] [bp-88h]
  float zy; // [sp+2Ch] [bp-84h]
  float32x2_t v140; // [sp+30h] [bp-80h]
  int InvertDirNewLink; // [sp+38h] [bp-78h]
  float32x2_t v142; // [sp+38h] [bp-78h]
  CVector v143; // [sp+44h] [bp-6Ch] BYREF

  Address = pVehicle->AutoPilot.OldLink.Address;
  if ( Address == 0xFFFF )
    goto LABEL_14;
  v16 = ThePaths.pNodes[Address >> 10];
  v17 = v16 == 0;
  if ( v16 )
  {
    v16 = (CPathNode *)pVehicle->AutoPilot.NewLink.Address;
    v17 = v16 == (CPathNode *)((char *)&elf_hash_bucket[16320] + 3);
  }
  if ( v17 )
    goto LABEL_14;
  v18 = ThePaths.pNodes[(unsigned int)v16 >> 10];
  v19 = v18 == 0;
  if ( v18 )
    v19 = pVehicle->AutoPilot.OldNode.Region == 0xFFFF;
  if ( v19 )
    goto LABEL_14;
  v20 = ThePaths.pNodes[pVehicle->AutoPilot.OldNode.Region];
  v21 = v20 == 0;
  if ( v20 )
    v21 = pVehicle->AutoPilot.NewNode.Region == 0xFFFF;
  if ( v21 || !ThePaths.pNodes[pVehicle->AutoPilot.NewNode.Region] )
  {
LABEL_14:
    *(_WORD *)((char *)&pVehicle->AutoPilot + 75) |= 0x100u;
    return;
  }
  m_pMat = pVehicle->m_pMat;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  v25 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  if ( v25 == 0.0 )
  {
    v26 = 1.0;
  }
  else
  {
    yy = yy / v25;
    v26 = xy / v25;
  }
  InvertDirNewLink = pVehicle->AutoPilot.InvertDirNewLink;
  InvertDirOldLink = (float)pVehicle->AutoPilot.InvertDirOldLink;
  OldLane = (float)pVehicle->AutoPilot.OldLane;
  v29 = &ThePaths.pLinks[Address >> 10][Address & 0x3FF];
  v30 = &ThePaths.pLinks[(unsigned int)v16 >> 10][(unsigned __int16)v16 & 0x3FF];
  DirXb = (float)v29->DirXb;
  DirYb = (float)v29->DirYb;
  v33 = v30->DirXb;
  v34 = (float)v30->DirYb;
  v35 = CCarPathLink::OneWayLaneOffset(v29);
  NewLane = pVehicle->AutoPilot.NewLane;
  v37 = (float)InvertDirNewLink;
  v38 = (float)(v35 + OldLane) * 5.4;
  v39 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF]);
  v40 = pVehicle->AutoPilot.OldLink.Address;
  v41 = pVehicle->AutoPilot.NewLink.Address;
  v42 = (float)(DirXb * 0.01) * InvertDirOldLink;
  v43 = ThePaths.pLinks[(unsigned __int16)v40 >> 10];
  m_vehicleType = pVehicle->m_vehicleType;
  v45 = 0.125;
  v46 = (float)(v39 + (float)NewLane) * 5.4;
  v47 = ThePaths.pLinks[(unsigned __int16)v41 >> 10];
  CoorsY = v43[pVehicle->AutoPilot.OldLink.Address & 0x3FF].CoorsY;
  v49 = (float)(DirYb * 0.01) * InvertDirOldLink;
  if ( m_vehicleType == 10 )
    v38 = v38 + 1.458;
  CoorsX = (float)v43[pVehicle->AutoPilot.OldLink.Address & 0x3FF].CoorsX;
  v51 = v49 * v38;
  p_m_transform = &pVehicle->m_transform;
  if ( m_vehicleType == 10 )
    v46 = v46 + 1.458;
  v53 = pVehicle->m_pMat;
  v54 = CoorsX * 0.125;
  if ( v53 )
    p_m_transform = (CSimpleTransform *)&v53->tx;
  v55 = (float)((float)CoorsY * 0.125) - (float)(v42 * v38);
  v56 = v51 + v54;
  v57 = p_m_transform->m_translate.y - v55;
  v58 = p_m_transform->m_translate.x - (float)(v51 + v54);
  v59.n64_f32[1] = v58 * v58;
  v60 = sqrtf((float)(v58 * v58) + (float)(v57 * v57));
  if ( v60 >= 5.0 )
  {
    v61 = v34 * 0.01;
    v62.n64_f32[0] = (float)((float)v33 * 0.01) * v37;
    v59.n64_f32[1] = v61 * v37;
    v63 = (float)((float)((float)v47[pVehicle->AutoPilot.NewLink.Address & 0x3FF].CoorsY * 0.125)
                - (float)(v62.n64_f32[0] * v46))
        - v55;
    v64 = (float)((float)((float)(v61 * v37) * v46)
                + (float)((float)v47[pVehicle->AutoPilot.NewLink.Address & 0x3FF].CoorsX * 0.125))
        - v56;
    v59.n64_f32[0] = (float)(v64 * v58) + (float)(v63 * v57);
    if ( (v59.n64_f32[0] <= 0.0 || v60 >= 8.0)
      && (float)(v59.n64_f32[0] / (float)(v60 * sqrtf((float)(v64 * v64) + (float)(v63 * v63)))) <= 0.7
      && v41 != v40 )
    {
      v135 = v61 * v37;
LABEL_39:
      v79 = (unsigned __int16)v40 >> 10;
      v80 = v40 & 0x3FF;
      v81 = ThePaths.pLinks[v79];
      v82 = v81[v80].CoorsX;
      v83 = v81[v80].CoorsY;
      p_tx = &pVehicle->m_transform;
      v85 = (float)((float)v83 * 0.125) - (float)(v38 * v42);
      v86 = (float)((float)(v38 * v49) + (float)((float)v82 * 0.125)) - (float)((float)(v42 * v60) * 0.35);
      v87 = v85 - (float)((float)(v49 * v60) * 0.35);
      if ( v60 > 40.0 )
      {
        v86 = (float)(v38 * v49) + (float)((float)v82 * 0.125);
        v87 = v85;
      }
      if ( v53 )
        p_tx = (CSimpleTransform *)&v53->tx;
      ATanOfXY = CGeneral::GetATanOfXY(v86 - p_tx->m_translate.x, v87 - p_tx->m_translate.y);
      AngleToWeaveThroughTraffic = ATanOfXY;
      v90 = CGeneral::GetATanOfXY(v26, yy);
      DrivingMode = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
      v92 = v90;
      if ( DrivingMode <= 6 && ((1 << DrivingMode) & 0x64) != 0 )
        AngleToWeaveThroughTraffic = CCarCtrl::FindAngleToWeaveThroughTraffic(pVehicle, 0, ATanOfXY, v90, 1.0);
      for ( v9.n64_f32[0] = AngleToWeaveThroughTraffic - v92;
            v9.n64_f32[0] < -3.1416;
            v9.n64_f32[0] = v9.n64_f32[0] + 6.2832 )
      {
        ;
      }
      for ( ; v9.n64_f32[0] > 3.1416; v9.n64_f32[0] = v9.n64_f32[0] + -6.2832 )
        ;
      x = pVehicle->m_vecMoveSpeed.x;
      v62.n64_u32[1] = LODWORD(pVehicle->m_vecMoveSpeed.y);
      z = pVehicle->m_vecMoveSpeed.z;
      v95 = pVehicle->m_pMat;
      v138 = v95->xy;
      v137 = v95->yy;
      v6.n64_u32[0] = 1060320051;
      zy = v95->zy;
      v96 = sqrtf((float)((float)(x * x) + (float)(v62.n64_f32[1] * v62.n64_f32[1])) + (float)(z * z));
      v97 = v96 <= 0.7;
      v5.n64_f32[0] = 0.9 - v96;
      v59.n64_u32[0] = 1.0;
      if ( !v97 )
        v5.n64_u32[0] = 1045220557;
      v98 = pVehicle->AutoPilot.DrivingMode;
      v99.n64_u64[0] = vmin_f32(v5, v6).n64_u64[0];
      v100 = pVehicle->AutoPilot.DrivingMode;
      v140.n64_u64[0] = v99.n64_u64[0];
      if ( v98 <= 6 && ((1 << v98) & 0x53) != 0 )
      {
        MaximumSpeedForThisCarInTraffic = CCarCtrl::FindMaximumSpeedForThisCarInTraffic(pVehicle);
        v100 = pVehicle->AutoPilot.DrivingMode;
        v59.n64_f32[0] = MaximumSpeedForThisCarInTraffic / (float)pVehicle->AutoPilot.CruiseSpeed;
      }
      v142.n64_u64[0] = v59.n64_u64[0];
      if ( (unsigned int)v100 <= 6 && ((1 << v100) & 0x63) != 0 && CTrafficLights::ShouldCarStopForLight(pVehicle, 0) )
      {
        CCarAI::CarHasReasonToStop(pVehicle);
        v59.n64_u32[0] = 0;
        v142.n64_u64[0] = v59.n64_u64[0];
      }
      v10.n64_f32[0] = -v99.n64_f32[0];
      v136.n64_u64[0] = vmax_f32(v9, v10).n64_u64[0];
      if ( CTrafficLights::ShouldCarStopForBridge(pVehicle) )
      {
        CCarAI::CarHasReasonToStop(pVehicle);
        v59.n64_u32[0] = 0;
        v142.n64_u64[0] = v59.n64_u64[0];
      }
      v102 = pVehicle->AutoPilot.OldLane;
      v103 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.OldLink.Address >> 10][pVehicle->AutoPilot.OldLink.Address & 0x3FF]);
      v104 = pVehicle->AutoPilot.OldLink.Address;
      v105 = ThePaths.pLinks[v104 >> 10];
      v106 = v104 & 0x3FF;
      v107 = &pVehicle->m_transform;
      v108 = v105[v106].CoorsX;
      v109 = &v105[v106];
      v110 = &pVehicle->m_transform;
      v111 = (float)v109->CoorsY;
      v112 = pVehicle->m_pMat;
      if ( v112 )
        v110 = (CSimpleTransform *)&v112->tx;
      for ( v59.n64_f32[0] = CGeneral::GetATanOfXY(
                               (float)((float)(v49 * (float)((float)(v103 + (float)v102) * 5.4))
                                     + (float)((float)v108 * 0.125))
                             - v110->m_translate.x,
                               (float)((float)(v111 * 0.125) - (float)(v42 * (float)((float)(v103 + (float)v102) * 5.4)))
                             - v110->m_translate.y)
                           - v92; v59.n64_f32[0] < -3.1416; v59.n64_f32[0] = v59.n64_f32[0] + 6.2832 )
        ;
      for ( ; v59.n64_f32[0] > 3.1416; v59.n64_f32[0] = v59.n64_f32[0] + -6.2832 )
        ;
      v113 = (float)(x * v138) + (float)(v62.n64_f32[1] * v137);
      v6.n64_u32[0] = 0;
      v114 = v62.n64_f32[0];
      v62.n64_u32[0] = 1.0;
      v59.n64_f32[0] = fabsf(v59.n64_f32[0]) + -0.4;
      v115 = vmax_f32(v59, v6).n64_f32[0];
      v9.n64_f32[0] = (float)((float)(v115 / 0.8) * -0.6) + 1.0;
      v116 = CGeneral::GetATanOfXY(v42, v49);
      v117 = CGeneral::GetATanOfXY(v114, v135);
      v6.n64_f32[0] = v116 - v117;
      if ( v115 > 0.8 )
        v9.n64_u32[0] = 1053609165;
      if ( (float)(v116 - v117) < -3.1416 )
      {
        do
          v6.n64_f32[0] = v6.n64_f32[0] + 6.2832;
        while ( v6.n64_f32[0] < -3.1416 );
      }
      for ( i = vmin_f32(v136, v140).n64_u32[0]; v6.n64_f32[0] > 3.1416; v6.n64_f32[0] = v6.n64_f32[0] + -6.2832 )
        ;
      v119 = (float)(v113 + (float)(z * zy)) * 60.0;
      if ( v60 <= 40.0 && pVehicle->AutoPilot.CruiseSpeed >= 0xCu )
      {
        v6.n64_f32[0] = fabsf(v6.n64_f32[0]) + -0.1;
        v7.n64_u32[0] = 0;
        v6.n64_u64[0] = vmax_f32(v6, v7).n64_u64[0];
        v120 = 1.0 - (float)(1.0 - (float)((float)(v6.n64_f32[0] / 1.1) * 0.6));
        if ( v6.n64_f32[0] > 1.1 )
          v120 = 0.6;
        v62.n64_f32[0] = 1.0 - (float)((float)((float)(v60 / -40.0) + 1.0) * v120);
      }
      CruiseSpeed = pVehicle->AutoPilot.CruiseSpeed;
      *pBrakePedal = 0.0;
      v122.n64_u64[0] = vmin_f32(vmin_f32(v9, v62), v142).n64_u64[0];
      v122.n64_f32[0] = v122.n64_f32[0] * (float)CruiseSpeed;
      v6.n64_f32[0] = v122.n64_f32[0] - v119;
      if ( v122.n64_f32[0] >= 0.05 )
      {
        if ( v6.n64_f32[0] <= 0.0 )
        {
          *pGasPedal = 0.0;
          v99.n64_f32[0] = v6.n64_f32[0] / -12.0;
          v6.n64_u32[0] = 0.5;
          *(_DWORD *)pBrakePedal = vmin_f32(v99, v6).n64_u32[0];
        }
        else
        {
          v122.n64_u32[0] = 1.0;
          if ( v119 < 2.0 )
            v45 = 0.25;
          v8.n64_f32[0] = v45 * v6.n64_f32[0];
          *(_DWORD *)pGasPedal = vmin_f32(v8, v122).n64_u32[0];
          if ( v6.n64_f32[0] > 3.0
            && pVehicle->m_vehicleType == 10
            && *(float *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType <= 0.0 )
          {
            *(_DWORD *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType = 1092616192;
          }
        }
      }
      else
      {
        *pBrakePedal = 1.0;
        *pGasPedal = 0.0;
      }
      *(_DWORD *)pSteerAngle = i;
      *pHandBrake = 0;
      v123 = (unsigned __int8)pVehicle->AutoPilot.Mission | 4;
      v124 = v123 == 12;
      if ( v123 == 12 )
        v124 = pVehicle->AutoPilot.TempAction == 0;
      if ( v124 )
      {
        v125 = pVehicle->m_pMat;
        if ( v125 )
          v107 = (CSimpleTransform *)&v125->tx;
        y = v107->m_translate.y;
        v127 = v107->m_translate.z;
        v128 = sqrtf(
                 (float)((float)((float)(v107->m_translate.x - pVehicle->AutoPilot.TargetCoors.x)
                               * (float)(v107->m_translate.x - pVehicle->AutoPilot.TargetCoors.x))
                       + (float)((float)(y - pVehicle->AutoPilot.TargetCoors.y)
                               * (float)(y - pVehicle->AutoPilot.TargetCoors.y)))
               + (float)((float)(v127 - pVehicle->AutoPilot.TargetCoors.z)
                       * (float)(v127 - pVehicle->AutoPilot.TargetCoors.z)));
        if ( v128 < 8.0
          && (float)(fabsf(
                       (float)((float)(v107->m_translate.x * v125->xy) + (float)(y * v125->yy))
                     + (float)(v127 * v125->zy))
                   / v128) < 0.2 )
        {
          pVehicle->AutoPilot.TempAction = 3;
          pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 2000;
        }
      }
      return;
    }
  }
  if ( !CCarCtrl::PickNextNodeAccordingStrategy(pVehicle) )
  {
LABEL_34:
    v68 = pVehicle->AutoPilot.OldLink.Address;
    if ( !ThePaths.pNodes[v68 >> 10] || !ThePaths.pNodes[pVehicle->AutoPilot.NewLink.Address >> 10] )
    {
      *pBrakePedal = 1.0;
      *pGasPedal = 0.0;
      *pSteerAngle = 0.0;
      *pHandBrake = 0;
      return;
    }
    v69 = pVehicle->AutoPilot.OldLane;
    v70 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[v68 >> 10][v68 & 0x3FF]);
    LOWORD(v40) = pVehicle->AutoPilot.OldLink.Address;
    v71 = &ThePaths.pLinks[(unsigned __int16)v40 >> 10][v40 & 0x3FF];
    v72 = &pVehicle->m_transform;
    v38 = (float)(v70 + (float)v69) * 5.4;
    v53 = pVehicle->m_pMat;
    if ( v53 )
      v72 = (CSimpleTransform *)&v53->tx;
    v73 = (float)((float)v71->CoorsY * 0.125) - (float)(v42 * v38);
    v74 = v72->m_translate.x;
    v75 = v72->m_translate.y;
    v76 = &ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF];
    v60 = sqrtf(
            (float)((float)((float)((float)(v49 * v38) + (float)((float)v71->CoorsX * 0.125)) - v74)
                  * (float)((float)((float)(v49 * v38) + (float)((float)v71->CoorsX * 0.125)) - v74))
          + (float)((float)(v73 - v75) * (float)(v73 - v75)));
    v77 = (float)pVehicle->AutoPilot.InvertDirNewLink;
    v78 = (float)pVehicle->AutoPilot.InvertDirOldLink;
    v62.n64_f32[0] = (float)((float)v76->DirXb * 0.01) * v77;
    v49 = (float)((float)v71->DirYb * 0.01) * v78;
    v42 = (float)((float)v71->DirXb * 0.01) * v78;
    v135 = (float)((float)v76->DirYb * 0.01) * v77;
    goto LABEL_39;
  }
  switch ( pVehicle->AutoPilot.Mission )
  {
    case 2:
      v129 = 3;
      goto LABEL_111;
    case 4:
      v129 = 5;
      goto LABEL_111;
    case 8:
      v130 = *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x;
      v131 = 9;
      goto LABEL_104;
    case 0xC:
      v130 = *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x;
      v131 = 13;
LABEL_104:
      pVehicle->AutoPilot.Mission = v131;
      goto LABEL_112;
    case 0xF:
      pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
      v133 = 16;
      goto LABEL_107;
    case 0x11:
      pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
      v133 = 18;
LABEL_107:
      pVehicle->AutoPilot.Mission = v133;
      v134 = pTargetEntity->m_pMat;
      v67 = (__int64 *)&v134->tx;
      if ( !v134 )
        v67 = (__int64 *)&pTargetEntity->m_transform;
      goto LABEL_109;
    case 0x2B:
      v129 = 44;
LABEL_111:
      pVehicle->AutoPilot.Mission = v129;
      FindPlayerCoors(&v143, -1);
      v130 = *(_QWORD *)&v143.x;
      goto LABEL_112;
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
      v65 = pVehicle->AutoPilot.pTargetEntity;
      pVehicle->AutoPilot.Mission -= 36;
      v66 = v65->m_pMat;
      v67 = (__int64 *)&v66->tx;
      if ( !v66 )
        v67 = (__int64 *)&v65->m_transform;
LABEL_109:
      v130 = *v67;
LABEL_112:
      CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
        pVehicle,
        0,
        *(float *)&v130,
        *((float *)&v130 + 1),
        pSteerAngle,
        pGasPedal,
        pBrakePedal,
        pHandBrake);
      break;
    default:
      goto LABEL_34;
  }
}
// 2F4188: variable 'v5' is possibly undefined
// 2F4188: variable 'v6' is possibly undefined
// 2F41F2: variable 'v9' is possibly undefined
// 2F41F2: variable 'v10' is possibly undefined
// 2F4416: variable 'v7' is possibly undefined
// 2F44E0: variable 'v8' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002F46C8) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysicsFollowPath_Racing(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *pHandBrake)
{
  CAutoPilot *p_AutoPilot; // r9
  unsigned int v6; // r10
  float32x2_t v7; // d2
  float32x2_t v8; // d3
  int16x4_t v9; // d16
  CVehicle *v10; // r4
  unsigned int Address; // r0
  CPathNode *v13; // r1
  bool v14; // zf
  CPathNode *v15; // r1
  bool v16; // zf
  CPathNode *v17; // r1
  bool v18; // zf
  float *p_xx; // r8
  float x; // s28
  float y; // s17
  float v22; // s18
  float v23; // s26
  float v24; // s24
  float z; // s30
  float v26; // s0
  float v27; // s20
  float v28; // s22
  float v29; // s16
  CCarPathLink *v30; // r3
  CCarPathLink *v31; // r6
  CVector *p_m_translate; // r1
  float v33; // s10
  float v34; // s12
  float v35; // s1
  float v36; // s14
  float v37; // s4
  float v38; // s3
  float v39; // s8
  float v40; // s6
  CNodeAddress *aPathNodeList; // r5
  CNodeAddress v42; // r0
  CNodeAddress v43; // r1
  CNodeAddress v44; // r6
  unsigned int Region; // r12
  Int8 InvertDirOldLink; // r3
  unsigned int InvertDirNewLink; // r8
  Int8 NewLane; // r1
  CPathNode *v49; // r2
  unsigned int Index; // r6
  unsigned int v51; // r1
  CNodeAddress *v52; // r3
  int i; // r2
  bool v54; // zf
  bool v55; // cc
  Int16 *v56; // r12
  char v57; // r6
  __int64 v58; // r2
  int v59; // r2
  unsigned int Link4; // r9
  signed int v61; // r6
  float v62; // s18
  char *v63; // r0
  CNodeAddress v64; // r2
  unsigned int v65; // r5
  int *v66; // r10
  CNodeAddress v67; // r4
  unsigned __int16 *v68; // r11
  int v69; // r10
  __int16 *v70; // r2
  int v71; // r5
  int v72; // r0
  float ATanOfXY; // r8
  float v74; // s20
  CVehicle *v75; // r10
  float32x2_t *p_tx; // r4
  float *v77; // r9
  CLinkAddress v78; // r1
  CCarPathLink *v79; // r0
  CMatrix *m_pMat; // r0
  int32x2_t v81; // d16
  float32x2_t v82; // d0
  float32x2_t v83; // d16
  float32x2_t v84; // d1
  float v85; // s2
  float32x2_t *v86; // r4
  CCarPathLink *v87; // r0
  CCarPathLink *v88; // r1
  CCarPathLink *v89; // r1
  CCarPathLink *v90; // r1
  CLinkAddress v91; // r1
  CCarPathLink *v92; // r0
  CLinkAddress v93; // r1
  CMatrix *v94; // r0
  int32x2_t v95; // d16
  float32x2_t v96; // d0
  float32x2_t v97; // d16
  float v98; // s2
  UInt16 v99; // r2
  float v100; // s10
  float v101; // s0
  int v102; // r3
  int v103; // r2
  CCarPathLink *v104; // r0
  int v105; // s6
  int v106; // s8
  CVehicle *v107; // r0
  Int8 v108; // r2
  float v109; // s6
  float v110; // s2
  float v111; // s4
  UInt16 v112; // r1
  int v113; // r2
  int v114; // r1
  float v115; // s2
  CCarPathLink *v116; // r0
  float CoorsY; // s4
  int CoorsX; // r0
  float v119; // s10
  int v120; // s8
  float v121; // s4
  float j; // s20
  int v123; // r4
  int v124; // r6
  float v125; // s0
  float32x2_t v126; // d0
  float CruiseSpeed; // s2
  float v128; // s2
  float32x2_t v129; // d0
  bool *v130; // r2
  float v131; // s0
  float *v132; // [sp+40h] [bp-E0h]
  CSimpleTransform *p_m_transform; // [sp+44h] [bp-DCh]
  CVehicle *v136; // [sp+50h] [bp-D0h]
  Int16 *p_NumPathNodes; // [sp+54h] [bp-CCh]
  CNodeAddress NewNode; // [sp+58h] [bp-C8h]
  CPathFind *OldNode; // [sp+5Ch] [bp-C4h]
  int v140[2]; // [sp+68h] [bp-B8h] BYREF
  __int16 v141; // [sp+70h] [bp-B0h]
  __int16 v142; // [sp+74h] [bp-ACh]
  __int16 v143; // [sp+78h] [bp-A8h]
  __int16 v144; // [sp+7Ch] [bp-A4h]
  __int16 v145; // [sp+80h] [bp-A0h]
  __int16 v146; // [sp+84h] [bp-9Ch]
  __int16 v147[2]; // [sp+88h] [bp-98h] BYREF
  int v148; // [sp+8Ch] [bp-94h] BYREF
  int v149; // [sp+90h] [bp-90h]
  int v150; // [sp+94h] [bp-8Ch]
  CVector pInPoint; // [sp+98h] [bp-88h] BYREF
  float pSpeedMultiplierBend; // [sp+A4h] [bp-7Ch] BYREF
  float pDistToBend; // [sp+A8h] [bp-78h] BYREF
  float pBendAngle; // [sp+ACh] [bp-74h] BYREF
  float pTargetOrientation; // [sp+B0h] [bp-70h] BYREF
  char v156[2]; // [sp+B4h] [bp-6Ch] BYREF
  Int8 v157; // [sp+B6h] [bp-6Ah] BYREF
  Int8 v158[5]; // [sp+B7h] [bp-69h]

  v10 = pVehicle;
  Address = pVehicle->AutoPilot.OldLink.Address;
  if ( Address == 0xFFFF )
    goto LABEL_14;
  v13 = ThePaths.pNodes[Address >> 10];
  v14 = v13 == 0;
  if ( v13 )
  {
    v6 = v10->AutoPilot.NewLink.Address;
    v14 = v6 == 0xFFFF;
  }
  if ( v14 )
    goto LABEL_14;
  v15 = ThePaths.pNodes[v6 >> 10];
  v16 = v15 == 0;
  if ( v15 )
  {
    p_AutoPilot = &v10->AutoPilot;
    v16 = v10->AutoPilot.OldNode.Region == 0xFFFF;
  }
  if ( v16 )
    goto LABEL_14;
  v17 = ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&p_AutoPilot->OldNode];
  v18 = v17 == 0;
  if ( v17 )
    v18 = v10->AutoPilot.NewNode.Region == 0xFFFF;
  if ( v18 || (NewNode = v10->AutoPilot.NewNode, !ThePaths.pNodes[NewNode.Region]) )
  {
LABEL_14:
    *(_WORD *)((char *)&v10->AutoPilot + 75) |= 0x100u;
    return;
  }
  OldNode = (CPathFind *)p_AutoPilot->OldNode;
  p_xx = &v10->m_pMat->xx;
  x = v10->m_vecMoveSpeed.x;
  y = v10->m_vecMoveSpeed.y;
  v22 = p_xx[4];
  v23 = p_xx[5];
  v24 = p_xx[6];
  z = v10->m_vecMoveSpeed.z;
  v26 = sqrtf((float)(v22 * v22) + (float)(v23 * v23));
  if ( v26 == 0.0 )
  {
    v28 = 1.0;
    v27 = p_xx[5];
  }
  else
  {
    v27 = v23 / v26;
    v28 = v22 / v26;
  }
  v29 = 0.125;
  v30 = ThePaths.pLinks[Address >> 10];
  v31 = ThePaths.pLinks[v6 >> 10];
  p_m_translate = &v10->m_transform.m_translate;
  v33 = (float)v30[Address & 0x3FF].CoorsY * 0.125;
  v34 = (float)v30[Address & 0x3FF].CoorsX * 0.125;
  p_m_transform = &v10->m_transform;
  if ( p_xx )
    p_m_translate = (CVector *)(p_xx + 12);
  v35 = p_m_translate->x - v34;
  v136 = v10;
  v36 = p_m_translate->y - v33;
  v37 = sqrtf((float)(v35 * v35) + (float)(v36 * v36));
  if ( v37 < 8.0
    || (v38 = (float)v31[v6 & 0x3FF].CoorsX * 0.125,
        v39 = (float)((float)v31[v6 & 0x3FF].CoorsY * 0.125) - v33,
        v40 = (float)((float)(v38 - v34) * v35) + (float)(v39 * v36),
        v40 > 0.0)
    && v37 < 12.0
    || (float)(v40 / (float)(sqrtf((float)((float)(v38 - v34) * (float)(v38 - v34)) + (float)(v39 * v39)) * v37)) > 0.7
    || v6 == Address )
  {
    p_NumPathNodes = &v10->AutoPilot.NumPathNodes;
    if ( v10->AutoPilot.NumPathNodes >= 4 )
    {
      aPathNodeList = v10->AutoPilot.aPathNodeList;
      v43 = v10->AutoPilot.NewNode;
      v42 = p_AutoPilot->OldNode;
    }
    else
    {
      aPathNodeList = v10->AutoPilot.aPathNodeList;
      CPathFind::DoPathSearch(
        &ThePaths,
        0.0,
        *p_m_translate,
        NewNode,
        v10->AutoPilot.TargetCoors,
        v10->AutoPilot.aPathNodeList,
        &v10->AutoPilot.NumPathNodes,
        8,
        0,
        1000000.0,
        0,
        1000000.0,
        (*(unsigned __int16 *)((char *)&v10->AutoPilot + 75) >> 6) & 1,
        EmptyNodeAddress,
        v10->m_nModelIndex == 539,
        0);
      if ( v10->AutoPilot.NumPathNodes < 1
        || (CAutoPilot::RemoveOnePathNode(p_AutoPilot), *p_NumPathNodes < 1)
        || v10->AutoPilot.NewNode.Region == v10->AutoPilot.aPathNodeList[0].Region
        && v10->AutoPilot.NewNode.Index == v10->AutoPilot.aPathNodeList[0].Index
        && (CAutoPilot::RemoveOnePathNode(p_AutoPilot), *p_NumPathNodes < 1) )
      {
        v58 = *(_QWORD *)&v10->AutoPilot.TargetCoors.x;
        v10->AutoPilot.Mission = 9;
        CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
          v10,
          0,
          *(float *)&v58,
          *((float *)&v58 + 1),
          pSteerAngle,
          pGasPedal,
          pBrakePedal,
          pHandBrake);
        return;
      }
      v42 = v10->AutoPilot.OldNode;
      v43 = v10->AutoPilot.NewNode;
    }
    v10->AutoPilot.OldNode = v43;
    v10->AutoPilot.VeryOldNode = v42;
    v10->AutoPilot.NewNode = *aPathNodeList;
    CAutoPilot::RemoveOnePathNode(p_AutoPilot);
    v44 = v10->AutoPilot.OldNode;
    LOWORD(Address) = v10->AutoPilot.NewLink.Address;
    Region = v44.Region;
    InvertDirOldLink = v10->AutoPilot.InvertDirOldLink;
    InvertDirNewLink = (unsigned __int8)v10->AutoPilot.InvertDirNewLink;
    NewLane = v10->AutoPilot.NewLane;
    v10->AutoPilot.VeryOldLink.Address = v10->AutoPilot.OldLink.Address;
    v10->AutoPilot.OldLink.Address = Address;
    v10->AutoPilot.InvertDirVeryOldLink = InvertDirOldLink;
    v10->AutoPilot.InvertDirOldLink = InvertDirNewLink;
    v10->AutoPilot.OldLane = NewLane;
    OldNode = (CPathFind *)v44;
    v49 = &ThePaths.pNodes[v44.Region][HIWORD(*(unsigned int *)&v44)];
    Index = v10->AutoPilot.NewNode.Index;
    v51 = v10->AutoPilot.NewNode.Region;
    v52 = ThePaths.pAdjacentNodes[v10->AutoPilot.OldNode.Region];
    for ( i = v49->IndexAdjacentNodes; v52[i].Region != v51 || v52[i].Index != Index; ++i )
      ;
    v54 = v51 == Region;
    v55 = v51 > Region;
    LOWORD(v6) = ThePaths.pAdjacentLinks[Region][i].Address;
    v10->AutoPilot.NewLink.Address = v6;
    v56 = &v10->AutoPilot.NumPathNodes;
    if ( v55 || v54 && v10->AutoPilot.OldNode.Index < Index )
      v57 = -1;
    else
      v57 = 1;
    v59 = (int)v10->AutoPilot.NewNode;
    v10->AutoPilot.InvertDirNewLink = v57;
  }
  else
  {
    InvertDirNewLink = (unsigned __int8)v10->AutoPilot.InvertDirOldLink;
    v56 = &v10->AutoPilot.NumPathNodes;
    v57 = v10->AutoPilot.InvertDirNewLink;
    v59 = (int)v10->AutoPilot.NewNode;
  }
  v150 = -1;
  v148 = -1;
  v149 = -1;
  v147[0] = Address;
  v142 = -1;
  v141 = -1;
  v143 = -1;
  v144 = -1;
  v145 = -1;
  v146 = -1;
  v140[1] = v59;
  v140[0] = (int)OldNode;
  Link4 = (unsigned int)&v148;
  v156[0] = InvertDirNewLink;
  v156[1] = v57;
  v61 = 0;
  v147[1] = v6;
  v62 = (float)((float)((float)(x * v22) + (float)(y * v23)) + (float)(z * v24)) * 60.0;
  do
  {
    if ( v61 >= *v56 || (v64 = v10->AutoPilot.aPathNodeList[v61], v65 = v64.Region, v64.Region == 0xFFFF) )
    {
      *((_WORD *)&v148 + v61) = -1;
      LOWORD(v140[v61 + 2]) = -1;
    }
    else
    {
      v66 = &v140[v61];
      InvertDirNewLink = (unsigned int)v56;
      v66[2] = (int)v64;
      v67 = (CNodeAddress)v66[1];
      *((_WORD *)&v148 + v61) = CPathFind::FindLinkBetweenNodes(&ThePaths, v67, v64);
      if ( v67.Region >= v65 )
      {
        if ( v67.Region != v65 )
        {
          v10 = v136;
          v56 = (Int16 *)InvertDirNewLink;
          v158[v61 - 1] = 1;
          goto LABEL_56;
        }
        v63 = &v156[v61 + 2];
        v56 = (Int16 *)InvertDirNewLink;
        if ( *((unsigned __int16 *)v66 + 3) >= (unsigned int)*((unsigned __int16 *)v66 + 5) )
        {
          v10 = v136;
          *v63 = 1;
          goto LABEL_56;
        }
        v10 = v136;
      }
      else
      {
        v56 = (Int16 *)InvertDirNewLink;
        v10 = v136;
        v63 = &v158[v61 - 1];
      }
      *v63 = -1;
    }
LABEL_56:
    ++v61;
  }
  while ( v61 != 4 );
  v132 = pSteerAngle;
  v150 = -1;
  pSpeedMultiplierBend = 1.0;
  v68 = (unsigned __int16 *)&v148 + 1;
  v69 = 0;
  v145 = -1;
  v146 = -1;
  do
  {
    if ( v69 >= 4 )
    {
      ATanOfXY = CGeneral::GetATanOfXY(v28, v27);
      v74 = ATanOfXY;
      goto LABEL_68;
    }
    v70 = &v147[v69];
    Link4 = Link4 & 0xFFFF0000 | *v68;
    v71 = *(v68 - 3);
    v10 = (CVehicle *)((unsigned int)v10 & 0xFFFF0000 | v71);
    v61 = v61 & 0xFFFF0000 | (unsigned __int16)v70[1];
    InvertDirNewLink = InvertDirNewLink & 0xFFFF0000 | (unsigned __int16)v70[2];
    v72 = CCarCtrl::DealWithBend_Racing(
            v136,
            (CLinkAddress)v10,
            (CLinkAddress)v61,
            (CLinkAddress)InvertDirNewLink,
            (CLinkAddress)Link4,
            v156[v69],
            v156[v69 + 1],
            v156[v69 + 2],
            v158[v69],
            v62,
            &pTargetOrientation,
            &pSpeedMultiplierBend,
            &pBendAngle,
            &pDistToBend,
            &pInPoint);
    ++v68;
    ++v69;
  }
  while ( v72 != 1 );
  ATanOfXY = CGeneral::GetATanOfXY(v28, v27);
  v74 = ATanOfXY;
  if ( v71 != 0xFFFF )
  {
    v75 = v136;
    v77 = v132;
    p_tx = (float32x2_t *)p_m_transform;
    if ( v136->AutoPilot.OldLink.Address != v71 )
    {
      v78.Address = v136->AutoPilot.NewLink.Address;
      v79 = ThePaths.pLinks[v78.Address >> 10];
      CCarCtrl::ClipTargetOrientationToLink(
        v136,
        v78,
        v136->AutoPilot.InvertDirNewLink,
        &pTargetOrientation,
        (float)v79[v78.Address & 0x3FF].CoorsX * 0.125,
        (float)v79[v78.Address & 0x3FF].CoorsY * 0.125);
      LOWORD(v71) = v136->AutoPilot.OldLink.Address;
    }
    v9.n64_u32[0] = *(_DWORD *)&ThePaths.pLinks[(unsigned __int16)v71 >> 10][v71 & 0x3FF].CoorsX;
    m_pMat = v136->m_pMat;
    v81.n64_u64[0] = vmovl_s16(v9).n128_u64[0];
    if ( m_pMat )
      p_tx = (float32x2_t *)&m_pMat->tx;
    v82.n64_u64[0] = vmul_f32(vcvt_f32_s32(v81), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
    v83.n64_u64[0] = vsub_f32(v82, (float32x2_t)p_tx->n64_u64[0]).n64_u64[0];
    v84.n64_u64[0] = vmul_f32(v83, v83).n64_u64[0];
    v84.n64_f32[0] = sqrtf(v84.n64_f32[0] + v84.n64_f32[1]);
    if ( v84.n64_f32[0] >= 5.0 )
    {
      if ( v84.n64_f32[0] >= 15.0 )
        v85 = 3.0;
      else
        v85 = (float)((float)((float)((float)(v84.n64_f32[0] + -5.0) * 0.5) / 10.0) + 0.5) + 2.0;
    }
    else
    {
      v85 = 2.5;
    }
    v112 = v136->AutoPilot.NewLink.Address;
    v113 = v112 >> 10;
    v114 = v112 & 0x3FF;
    v115 = v85 / 3.0;
    v116 = ThePaths.pLinks[v113];
    CoorsY = (float)v116[v114].CoorsY;
    CoorsX = v116[v114].CoorsX;
    v119 = v115 * v82.n64_f32[1];
    v101 = v115 * v82.n64_f32[0];
    v93.Address = v71;
    v120 = CoorsX;
    v107 = v136;
    v108 = v136->AutoPilot.InvertDirOldLink;
    v121 = (float)(1.0 - v115) * (float)(CoorsY * 0.125);
    v110 = (float)(1.0 - v115) * (float)((float)v120 * 0.125);
    v111 = v119 + v121;
    goto LABEL_88;
  }
LABEL_68:
  v75 = v136;
  v77 = v132;
  v86 = (float32x2_t *)p_m_transform;
  pTargetOrientation = v74;
  if ( HIWORD(v149) != 0xFFFF )
  {
    v87 = ThePaths.pLinks[HIWORD(v149) >> 10];
    CCarCtrl::ClipTargetOrientationToLink(
      v136,
      *(CLinkAddress *)((char *)&v149 + 2),
      v158[2],
      &pTargetOrientation,
      (float)v87[HIWORD(v149) & 0x3FF].CoorsX * 0.125,
      (float)v87[HIWORD(v149) & 0x3FF].CoorsY * 0.125);
  }
  if ( (unsigned __int16)v149 != 0xFFFF )
  {
    v88 = ThePaths.pLinks[(unsigned __int16)v149 >> 10];
    CCarCtrl::ClipTargetOrientationToLink(
      v136,
      (CLinkAddress)v149,
      v158[1],
      &pTargetOrientation,
      (float)v88[v149 & 0x3FF].CoorsX * 0.125,
      (float)v88[v149 & 0x3FF].CoorsY * 0.125);
  }
  if ( HIWORD(v148) != 0xFFFF )
  {
    v89 = ThePaths.pLinks[HIWORD(v148) >> 10];
    CCarCtrl::ClipTargetOrientationToLink(
      v136,
      *(CLinkAddress *)((char *)&v148 + 2),
      v158[0],
      &pTargetOrientation,
      (float)v89[HIWORD(v148) & 0x3FF].CoorsX * 0.125,
      (float)v89[HIWORD(v148) & 0x3FF].CoorsY * 0.125);
  }
  if ( (unsigned __int16)v148 != 0xFFFF )
  {
    v90 = ThePaths.pLinks[(unsigned __int16)v148 >> 10];
    CCarCtrl::ClipTargetOrientationToLink(
      v136,
      (CLinkAddress)v148,
      v157,
      &pTargetOrientation,
      (float)v90[v148 & 0x3FF].CoorsX * 0.125,
      (float)v90[v148 & 0x3FF].CoorsY * 0.125);
  }
  v91.Address = v136->AutoPilot.NewLink.Address;
  v92 = ThePaths.pLinks[v91.Address >> 10];
  CCarCtrl::ClipTargetOrientationToLink(
    v136,
    v91,
    v136->AutoPilot.InvertDirNewLink,
    &pTargetOrientation,
    (float)v92[v91.Address & 0x3FF].CoorsX * 0.125,
    (float)v92[v91.Address & 0x3FF].CoorsY * 0.125);
  v93.Address = v136->AutoPilot.OldLink.Address;
  v9.n64_u32[0] = *(_DWORD *)&ThePaths.pLinks[v93.Address >> 10][v93.Address & 0x3FF].CoorsX;
  v94 = v136->m_pMat;
  v95.n64_u64[0] = vmovl_s16(v9).n128_u64[0];
  if ( v94 )
    v86 = (float32x2_t *)&v94->tx;
  v96.n64_u64[0] = vmul_f32(vcvt_f32_s32(v95), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
  v97.n64_u64[0] = vsub_f32(v96, (float32x2_t)v86->n64_u64[0]).n64_u64[0];
  v84.n64_u64[0] = vmul_f32(v97, v97).n64_u64[0];
  v84.n64_f32[0] = sqrtf(v84.n64_f32[0] + v84.n64_f32[1]);
  if ( v84.n64_f32[0] >= 5.0 )
  {
    if ( v84.n64_f32[0] >= 15.0 )
      v98 = 1.0;
    else
      v98 = (float)((float)((float)(v84.n64_f32[0] + -5.0) * 0.5) / 10.0) + 0.5;
  }
  else
  {
    v98 = 0.5;
  }
  v99 = v136->AutoPilot.NewLink.Address;
  v100 = v98 * v96.n64_f32[1];
  v101 = v98 * v96.n64_f32[0];
  v102 = v99 >> 10;
  v103 = v99 & 0x3FF;
  v104 = ThePaths.pLinks[v102];
  v105 = v104[v103].CoorsY;
  v106 = v104[v103].CoorsX;
  v107 = v136;
  v108 = v136->AutoPilot.InvertDirOldLink;
  v109 = (float)(1.0 - v98) * (float)((float)v105 * 0.125);
  v110 = (float)(1.0 - v98) * (float)((float)v106 * 0.125);
  v111 = v100 + v109;
LABEL_88:
  CCarCtrl::ClipTargetOrientationToLink(v107, v93, v108, &pTargetOrientation, v101 + v110, v111);
  pTargetOrientation = CCarCtrl::FindAngleToWeaveThroughTraffic(v75, 0, pTargetOrientation, ATanOfXY, 2.0);
  for ( j = pTargetOrientation - v74; j < -3.1416; j = j + 6.2832 )
    ;
  for ( ; j > 3.1416; j = j + -6.2832 )
    ;
  v123 = 0;
  v124 = 0;
  v7.n64_u32[0] = 1060320051;
  v125 = sqrtf(
           (float)((float)(v75->m_vecMoveSpeed.x * v75->m_vecMoveSpeed.x)
                 + (float)(v75->m_vecMoveSpeed.y * v75->m_vecMoveSpeed.y))
         + (float)(v75->m_vecMoveSpeed.z * v75->m_vecMoveSpeed.z));
  v84.n64_f32[0] = 0.9 - v125;
  if ( v125 > 0.7 )
    v84.n64_u32[0] = 1045220557;
  v126.n64_u64[0] = vmin_f32(v84, v7).n64_u64[0];
  if ( j < (float)-v126.n64_f32[0] )
  {
    j = -v126.n64_f32[0];
    v123 = 1;
  }
  if ( j > v126.n64_f32[0] )
  {
    j = v126.n64_f32[0];
    v124 = 1;
  }
  if ( CTrafficLights::ShouldCarStopForBridge(v75) )
  {
    CCarAI::CarHasReasonToStop(v75);
    v126.n64_u32[0] = 0;
  }
  else
  {
    v126.n64_u32[0] = 1.0;
  }
  CruiseSpeed = (float)v75->AutoPilot.CruiseSpeed;
  v7.n64_f32[0] = pSpeedMultiplierBend;
  v129.n64_u64[0] = vmin_f32(v126, v7).n64_u64[0];
  *pBrakePedal = 0.0;
  v128 = v129.n64_f32[0] * CruiseSpeed;
  v129.n64_f32[0] = v128 - v62;
  if ( v128 >= 0.05 )
  {
    if ( v129.n64_f32[0] <= 0.0 )
    {
      v131 = -v129.n64_f32[0];
      *pGasPedal = 0.0;
      v130 = pHandBrake;
      if ( v75->m_vehicleType == 10 )
      {
        v129.n64_f32[0] = v131 / 15.0;
        v84.n64_u32[0] = 1.0;
      }
      else
      {
        v129.n64_f32[0] = v131 / 20.0;
        v84.n64_u32[0] = 0.5;
      }
      *(_DWORD *)pBrakePedal = vmin_f32(v129, v84).n64_u32[0];
    }
    else if ( ((v123 | v124) & (v62 > 7.0)) == 1 )
    {
      *pGasPedal = 0.0;
      v130 = pHandBrake;
    }
    else
    {
      v130 = pHandBrake;
      if ( v62 < 2.0 )
        v29 = 0.25;
      v7.n64_u32[0] = 1.0;
      v8.n64_f32[0] = v29 * v129.n64_f32[0];
      *(_DWORD *)pGasPedal = vmin_f32(v8, v7).n64_u32[0];
      if ( v129.n64_f32[0] > 3.0
        && v75->m_vehicleType == 10
        && *(float *)&v75[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType <= 0.0 )
      {
        *(_DWORD *)&v75[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType = 1097859072;
      }
    }
  }
  else
  {
    v130 = pHandBrake;
    *pBrakePedal = 1.0;
    *pGasPedal = 0.0;
  }
  *v77 = j;
  *v130 = 0;
}
// 2F4718: variable 'v6' is possibly undefined
// 2F473C: variable 'p_AutoPilot' is possibly undefined
// 2F4D82: variable 'v9' is possibly undefined
// 2F524A: variable 'v7' is possibly undefined
// 2F535A: variable 'v8' is possibly undefined

//----- (002F5424) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarWithPhysicsFollowPreRecordedPath(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        _BYTE *a5)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  float32x2_t v8; // d3
  float32x2_t v9; // d4
  float32x2_t v10; // d5
  float32x2_t v11; // d6
  Int32 RecordingNumber; // r5
  float *v14; // r9
  UInt8 *v15; // r0
  CSimpleTransform *p_m_transform; // r8
  CMatrix *m_pMat; // r1
  Int32 v18; // r12
  CSimpleTransform *p_tx; // r2
  UInt8 *v20; // r11
  float y; // s6
  float v22; // s0
  float z; // s4
  float v24; // s8
  int v25; // r3
  unsigned int v26; // lr
  unsigned int v27; // r0
  float *v28; // r0
  CSimpleTransform *v29; // r2
  float v30; // s6
  float v31; // s4
  float v32; // s8
  float ATanOfXY; // r10
  CMatrix *v34; // r0
  float v35; // r0
  _BYTE *v36; // r2
  float v37; // s4
  float v38; // s6
  float v39; // s8
  float v40; // s4
  unsigned __int32 v41; // s12
  float32x2_t v42; // d3
  unsigned __int32 v43; // s0
  float v44; // s4
  _DWORD *v45; // r0
  unsigned __int32 v46; // s2
  float *v48; // [sp+8h] [bp-20h]

  RecordingNumber = pVehicle->AutoPilot.RecordingNumber;
  v14 = pBrakePedal;
  if ( RecordingNumber <= -1 || (v15 = CVehicleRecording::pPlaybackBuffer[RecordingNumber]) == 0 )
  {
    *pBrakePedal = 0.0;
    *pGasPedal = 0.0;
LABEL_6:
    *pSteerAngle = 0.0;
    *a5 = 0;
    pVehicle->AutoPilot.Mission = 11;
    return;
  }
  if ( CVehicleRecording::bPlaybackPaused[RecordingNumber] )
  {
    *pGasPedal = 0.0;
    *pSteerAngle = 0.0;
    *pBrakePedal = 0.5;
    *a5 = 0;
    return;
  }
  v48 = pSteerAngle;
  p_m_transform = &pVehicle->m_transform;
  m_pMat = pVehicle->m_pMat;
  v18 = CVehicleRecording::PlaybackIndex[RecordingNumber];
  p_tx = &pVehicle->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v20 = &v15[v18];
  y = p_tx->m_translate.y;
  v22 = p_tx->m_translate.x - *(float *)&v15[v18 + 20];
  z = p_tx->m_translate.z;
  v24 = sqrtf(
          (float)((float)(v22 * v22)
                + (float)((float)(y - *(float *)&v15[v18 + 24]) * (float)(y - *(float *)&v15[v18 + 24])))
        + (float)((float)(z - *(float *)&v15[v18 + 28]) * (float)(z - *(float *)&v15[v18 + 28])));
  if ( v24 < 10.0
    || sqrtf(
         (float)((float)(z - *((float *)v20 + 15)) * (float)(z - *((float *)v20 + 15)))
       + (float)((float)((float)(p_tx->m_translate.x - *((float *)v20 + 13))
                       * (float)(p_tx->m_translate.x - *((float *)v20 + 13)))
               + (float)((float)(y - *((float *)v20 + 14)) * (float)(y - *((float *)v20 + 14))))) < v24 )
  {
    v25 = 0;
    v26 = CVehicleRecording::PlaybackBufferSize[RecordingNumber] - 32;
    while ( 1 )
    {
      v27 = v18 + v25 + 32;
      CVehicleRecording::PlaybackIndex[RecordingNumber] = v27;
      if ( v27 >= v26 )
        break;
      m_pMat = pVehicle->m_pMat;
      v28 = (float *)&v20[v25];
      v29 = &pVehicle->m_transform;
      v25 += 32;
      if ( m_pMat )
        v29 = (CSimpleTransform *)&m_pMat->tx;
      v30 = v29->m_translate.y;
      v31 = v29->m_translate.z;
      v32 = sqrtf(
              (float)((float)((float)(v29->m_translate.x - v28[13]) * (float)(v29->m_translate.x - v28[13]))
                    + (float)((float)(v30 - v28[14]) * (float)(v30 - v28[14])))
            + (float)((float)(v31 - v28[15]) * (float)(v31 - v28[15])));
      if ( v32 >= 10.0
        && sqrtf(
             (float)((float)(v31 - v28[23]) * (float)(v31 - v28[23]))
           + (float)((float)((float)(v29->m_translate.x - v28[21]) * (float)(v29->m_translate.x - v28[21]))
                   + (float)((float)(v30 - v28[22]) * (float)(v30 - v28[22])))) >= v32 )
      {
        goto LABEL_17;
      }
    }
    CVehicleRecording::StopPlaybackWithIndex(RecordingNumber);
    pVehicle->AutoPilot.RecordingNumber = -1;
    *v14 = 0.0;
    *pGasPedal = 0.0;
    pSteerAngle = v48;
    goto LABEL_6;
  }
LABEL_17:
  ATanOfXY = CGeneral::GetATanOfXY(m_pMat->xy, m_pMat->yy);
  v34 = pVehicle->m_pMat;
  if ( v34 )
    p_m_transform = (CSimpleTransform *)&v34->tx;
  v35 = CGeneral::GetATanOfXY(
          *((float *)v20 + 5) - p_m_transform->m_translate.x,
          *((float *)v20 + 6) - p_m_transform->m_translate.y);
  v5.n64_f32[0] = CCarCtrl::FindAngleToWeaveThroughTraffic(pVehicle, 0, v35, ATanOfXY, 2.0) - ATanOfXY;
  if ( v5.n64_f32[0] >= -3.1416 )
  {
    v36 = a5;
  }
  else
  {
    v36 = a5;
    do
      v5.n64_f32[0] = v5.n64_f32[0] + 6.2832;
    while ( v5.n64_f32[0] < -3.1416 );
  }
  for ( ; v5.n64_f32[0] > 3.1416; v5.n64_f32[0] = v5.n64_f32[0] + -6.2832 )
    ;
  v11.n64_u32[0] = 5.0;
  v6.n64_f32[0] = (float)*((__int16 *)v20 + 3) / 16384.0;
  v37 = (float)*((__int16 *)v20 + 2) / 16384.0;
  v38 = (float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
      + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y);
  v6.n64_f32[0] = sqrtf((float)(v37 * v37) + (float)(v6.n64_f32[0] * v6.n64_f32[0]));
  v39 = sqrtf(v38 + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z));
  v40 = sqrtf(v38) * 60.0;
  v8.n64_u32[0] = 1060320051;
  v6.n64_f32[0] = (float)(CVehicleRecording::PlaybackSpeed[RecordingNumber] * 60.0) * v6.n64_f32[0];
  v10.n64_f32[0] = 0.9 - v39;
  v41 = vmax_f32(v6, v11).n64_u32[0];
  if ( (unsigned int)CVehicleRecording::PlaybackIndex[RecordingNumber] <= 0x320 )
    v6.n64_u32[0] = v41;
  v6.n64_f32[0] = v6.n64_f32[0] - v40;
  if ( v39 > 0.7 )
    v10.n64_u32[0] = 1045220557;
  v42.n64_u64[0] = vmin_f32(v10, v8).n64_u64[0];
  *v14 = 0.0;
  v9.n64_f32[0] = -v42.n64_f32[0];
  v43 = vmin_f32(vmax_f32(v5, v9), v42).n64_u32[0];
  if ( v6.n64_f32[0] <= 0.0 )
  {
    *pGasPedal = 0.0;
    v45 = v48;
    v6.n64_f32[0] = v6.n64_f32[0] / -20.0;
    v7.n64_u32[0] = 0.5;
    v46 = vmin_f32(v6, v7).n64_u32[0];
  }
  else
  {
    v42.n64_u32[0] = 1.0;
    if ( v40 >= 2.0 )
      v44 = 0.125;
    else
      v44 = 0.25;
    v14 = pGasPedal;
    v45 = v48;
    v6.n64_f32[0] = v6.n64_f32[0] * v44;
    v46 = vmin_f32(v6, v42).n64_u32[0];
  }
  *(_DWORD *)v14 = v46;
  *v45 = v43;
  *v36 = 0;
}
// 2F5722: variable 'v6' is possibly undefined
// 2F5722: variable 'v11' is possibly undefined
// 2F5746: variable 'v10' is possibly undefined
// 2F5746: variable 'v8' is possibly undefined
// 2F5752: variable 'v5' is possibly undefined
// 2F5752: variable 'v9' is possibly undefined
// 2F5796: variable 'v7' is possibly undefined

//----- (002F5804) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliTowardsTargetCoors(CAutomobile *pVeh)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  float ATanOfXY; // r1
  CMatrix *v6; // r0

  if ( pVeh->HeliRequestedOrientation >= 0.0 )
  {
    CCarCtrl::FlyAIHeliToTarget_FixedOrientation(
      (CHeli *)pVeh,
      pVeh->HeliRequestedOrientation,
      pVeh->AutoPilot.TargetCoors,
      0);
  }
  else
  {
    m_pMat = pVeh->m_pMat;
    p_m_transform = &pVeh->m_transform;
    p_tx = &pVeh->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    ATanOfXY = CGeneral::GetATanOfXY(
                 pVeh->AutoPilot.TargetCoors.x - p_tx->m_translate.x,
                 pVeh->AutoPilot.TargetCoors.y - p_tx->m_translate.y);
    v6 = pVeh->m_pMat;
    if ( v6 )
      p_m_transform = (CSimpleTransform *)&v6->tx;
    CCarCtrl::FlyAIHeliInCertainDirection(
      (CHeli *)pVeh,
      ATanOfXY,
      sqrtf(
        (float)((float)(pVeh->AutoPilot.TargetCoors.x - p_m_transform->m_translate.x)
              * (float)(pVeh->AutoPilot.TargetCoors.x - p_m_transform->m_translate.x))
      + (float)((float)(pVeh->AutoPilot.TargetCoors.y - p_m_transform->m_translate.y)
              * (float)(pVeh->AutoPilot.TargetCoors.y - p_m_transform->m_translate.y))),
      1);
  }
}

//----- (002F58B4) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIPlaneTowardsTargetCoors(CAutomobile *pVeh)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1

  m_pMat = pVeh->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVeh->m_transform;
  *(float *)&pVeh[1].m_pLastRenderedLink = CGeneral::GetATanOfXY(
                                             pVeh->AutoPilot.TargetCoors.x - p_tx->m_translate.x,
                                             pVeh->AutoPilot.TargetCoors.y - p_tx->m_translate.y);
  CCarCtrl::FlyAIPlaneInCertainDirection((CPlane *)pVeh);
}

//----- (002F58F8) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIBoatWithPhysicsHeadingForTarget(
        CVehicle *pBoat,
        float TargetX,
        float TargetY,
        float *pSteerAngle,
        float *pGas,
        float *pBrake)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d3
  float32x2_t v8; // d4
  CMatrix *m_pMat; // r0
  float xy; // s4
  float yy; // s16
  float v15; // s6
  float v16; // s18
  CSimpleTransform *p_tx; // r1
  float ATanOfXY; // r0
  float CruiseSpeed; // s4
  float v20; // s2
  float v21; // s0
  float v22; // s2
  float *v23; // r2
  float v24; // s2

  m_pMat = pBoat->m_pMat;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  v15 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  if ( v15 == 0.0 )
  {
    v16 = 1.0;
  }
  else
  {
    yy = yy / v15;
    v16 = xy / v15;
  }
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pBoat->m_transform;
  ATanOfXY = CGeneral::GetATanOfXY(TargetX - p_tx->m_translate.x, TargetY - p_tx->m_translate.y);
  for ( v6.n64_f32[0] = ATanOfXY - CGeneral::GetATanOfXY(v16, yy);
        v6.n64_f32[0] < -3.1416;
        v6.n64_f32[0] = v6.n64_f32[0] + 6.2832 )
  {
    ;
  }
  for ( ; v6.n64_f32[0] > 3.1416; v6.n64_f32[0] = v6.n64_f32[0] + -6.2832 )
    ;
  v8.n64_u32[0] = 0.5;
  CruiseSpeed = (float)pBoat->AutoPilot.CruiseSpeed;
  v7.n64_u32[0] = -0.5;
  v20 = CruiseSpeed
      + (float)(sqrtf(
                  (float)((float)(pBoat->m_vecMoveSpeed.x * pBoat->m_vecMoveSpeed.x)
                        + (float)(pBoat->m_vecMoveSpeed.y * pBoat->m_vecMoveSpeed.y))
                + 0.0)
              * -60.0);
  LODWORD(v21) = vmin_f32(vmax_f32(v6, v7), v8).n64_u32[0];
  if ( v20 <= 0.0 )
  {
    v23 = (float *)sub_2F5A88;
    v21 = -v21;
    if ( v20 < -5.0 )
      v23 = (float *)sub_2F5A8C;
    v24 = *v23;
    goto LABEL_17;
  }
  v22 = v20 / CruiseSpeed;
  if ( v22 <= 0.25 )
  {
    v24 = (float)((float)(0.25 - v22) * -4.0) + 1.0;
LABEL_17:
    *pGas = v24;
    goto LABEL_18;
  }
  *pGas = 1.0;
LABEL_18:
  *pBrake = 0.0;
  *pSteerAngle = v21;
}
// 2F59FE: variable 'v6' is possibly undefined
// 2F59FE: variable 'v7' is possibly undefined
// 2F5A06: variable 'v8' is possibly undefined
// 2F5A88: using guessed type int sub_2F5A88();
// 2F5A8C: using guessed type int sub_2F5A8C();

//----- (002F5A90) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIBoatWithPhysicsAttackingPlayer(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGas,
        float *pBrake,
        bool *pHandBrake)
{
  float32x2_t v5; // d2
  float32x2_t v6; // d3
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  float yy; // s18
  float32x2_t v15; // d16
  unsigned __int64 v16; // d1
  float v17; // s16
  float xy; // s0
  float v19; // s2
  float v20; // s22
  float v21; // s20
  float x; // s24
  float v23; // s26
  float y; // s28
  float v25; // s0
  CMatrix *v26; // r0
  float ATanOfXY; // r0
  float i; // s0
  float CruiseSpeed; // s4
  float v30; // s2
  float v31; // s2
  float v32; // s2
  CVector v33; // [sp+4h] [bp-5Ch] BYREF

  FindPlayerCoors(&v33, -1);
  m_pMat = pVehicle->m_pMat;
  p_m_transform = &pVehicle->m_transform;
  p_tx = &pVehicle->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  yy = m_pMat->yy;
  v15.n64_u64[0] = vsub_f32(*(float32x2_t *)&v33.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v16 = vmul_f32(v15, v15).n64_u64[0];
  v17 = sqrtf(
          (float)((float)((float)(v33.x - p_tx->m_translate.x) * (float)(v33.x - p_tx->m_translate.x)) + *(float *)&v16)
        + *((float *)&v16 + 1));
  xy = m_pMat->xy;
  v5.n64_f32[0] = v17 / 20.0;
  v19 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  v6.n64_u32[0] = 2.0;
  LODWORD(v20) = vmin_f32(v5, v6).n64_u32[0];
  if ( v19 == 0.0 )
  {
    v21 = 1.0;
  }
  else
  {
    yy = yy / v19;
    v21 = xy / v19;
  }
  FindPlayerCoors(&v33, -1);
  x = v33.x;
  v23 = FindPlayerSpeed(-1)->x;
  FindPlayerCoors(&v33, -1);
  y = v33.y;
  v25 = v20 * FindPlayerSpeed(-1)->y;
  v26 = pVehicle->m_pMat;
  if ( v26 )
    p_m_transform = (CSimpleTransform *)&v26->tx;
  ATanOfXY = CGeneral::GetATanOfXY(
               (float)(x + (float)((float)(v20 * v23) * 60.0)) - p_m_transform->m_translate.x,
               (float)(y + (float)(v25 * 60.0)) - p_m_transform->m_translate.y);
  for ( i = ATanOfXY - CGeneral::GetATanOfXY(v21, yy); i < -3.1416; i = i + 6.2832 )
    ;
  for ( ; i > 3.1416; i = i + -6.2832 )
    ;
  CruiseSpeed = (float)pVehicle->AutoPilot.CruiseSpeed;
  v30 = CruiseSpeed
      + (float)(sqrtf(
                  (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                        + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                + 0.0)
              * -60.0);
  if ( v30 <= 0.0 )
  {
    if ( v30 >= -5.0 )
      v32 = -0.1;
    else
      v32 = -0.2;
  }
  else
  {
    v31 = v30 / CruiseSpeed;
    if ( v31 <= 0.25 )
      v32 = (float)((float)(0.25 - v31) * -4.0) + 1.0;
    else
      v32 = 1.0;
  }
  *pGas = v32;
  *pBrake = 0.0;
  *pSteerAngle = i;
  *pHandBrake = 0;
  if ( pVehicle->m_nModelIndex == 430 && v17 < 40.0 && i < 0.15 )
    CVehicle::FireFixedMachineGuns(pVehicle);
}
// 2F5B16: variable 'v5' is possibly undefined
// 2F5B16: variable 'v6' is possibly undefined

//----- (002F5CF4) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIBoatWithPhysicsCirclingPlayer(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGas,
        float *pBrake,
        bool *pHandBrake)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  RwReal v12; // s2
  float v13; // s0
  RwReal v14; // s2
  CMatrix *v15; // r0
  float xy; // s4
  float yy; // s16
  float v18; // s6
  float v19; // s18
  float ATanOfXY; // r0
  float i; // s0
  float CruiseSpeed; // s4
  float v23; // s2
  float v24; // s2
  float v25; // s2
  CVector v26; // [sp+0h] [bp-40h] BYREF
  CVector v27; // [sp+Ch] [bp-34h] BYREF

  FindPlayerCoors(&v26, -1);
  m_pMat = pVehicle->m_pMat;
  p_m_transform = &pVehicle->m_transform;
  p_tx = &pVehicle->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v12 = v26.y - p_tx->m_translate.y;
  v27.x = v26.x - p_tx->m_translate.x;
  v27.y = v12;
  v27.z = 0.0;
  CVector::Normalise(&v27);
  v13 = -12.0;
  if ( (pVehicle->RandomSeed & 1) == 0 )
    v13 = 26.0;
  v14 = -(float)(v27.x * v13);
  v27.x = v13 * v27.y;
  v27.y = v14;
  v27.z = v13 * v27.z;
  FindPlayerCoors(&v26, -1);
  v15 = pVehicle->m_pMat;
  xy = v15->xy;
  yy = v15->yy;
  v18 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  if ( v18 == 0.0 )
  {
    v19 = 1.0;
  }
  else
  {
    yy = yy / v18;
    v19 = xy / v18;
  }
  if ( v15 )
    p_m_transform = (CSimpleTransform *)&v15->tx;
  ATanOfXY = CGeneral::GetATanOfXY(
               (float)(v26.x + v27.x) - p_m_transform->m_translate.x,
               (float)(v26.y + v27.y) - p_m_transform->m_translate.y);
  for ( i = ATanOfXY - CGeneral::GetATanOfXY(v19, yy); i < -3.1416; i = i + 6.2832 )
    ;
  for ( ; i > 3.1416; i = i + -6.2832 )
    ;
  CruiseSpeed = (float)pVehicle->AutoPilot.CruiseSpeed;
  v23 = CruiseSpeed
      + (float)(sqrtf(
                  (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                        + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                + 0.0)
              * -60.0);
  if ( v23 <= 0.0 )
  {
    if ( v23 >= -5.0 )
      v25 = -0.1;
    else
      v25 = -0.2;
  }
  else
  {
    v24 = v23 / CruiseSpeed;
    if ( v24 <= 0.25 )
      v25 = (float)((float)(0.25 - v24) * -4.0) + 1.0;
    else
      v25 = 1.0;
  }
  *pGas = v25;
  *pBrake = 0.0;
  *pSteerAngle = i;
  *pHandBrake = 0;
}

//----- (002F5F1C) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarBlockingPlayerForwardAndBack(
        CVehicle *pCar,
        float *pSteerAngle,
        float *pGas,
        float *pBrake,
        _BYTE *a5)
{
  const CVector *PlayerSpeed; // r0
  float x; // s18
  float y; // s20
  CEntity *PlayerEntity; // r4
  CMatrix *m_pMat; // r0
  float xy; // s22
  float yy; // s24
  CSimpleTransform *p_m_transform; // r4
  CMatrix *v16; // r0
  CSimpleTransform *p_tx; // r1
  float v18; // s20
  float v19; // s18
  float v20; // s2
  float v21; // s0
  float v22; // s22
  CMatrix *v23; // r0
  float32x2_t v24; // d3
  float32x2_t v25; // d1
  float32x2_t v26; // d0
  unsigned __int32 v27; // s0
  float v28; // s0
  CVector v29; // [sp+4h] [bp-6Ch] BYREF
  CVector v30; // [sp+10h] [bp-60h] BYREF
  CVector v31; // [sp+20h] [bp-50h] BYREF

  *pSteerAngle = 0.0;
  *a5 = 0;
  PlayerSpeed = FindPlayerSpeed(-1);
  x = PlayerSpeed->x;
  y = PlayerSpeed->y;
  PlayerEntity = FindPlayerEntity(-1);
  m_pMat = PlayerEntity->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(PlayerEntity);
    CSimpleTransform::UpdateMatrix(&PlayerEntity->m_transform, PlayerEntity->m_pMat);
    m_pMat = PlayerEntity->m_pMat;
  }
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  *(_QWORD *)&v31.x = *(_QWORD *)&pCar->m_pMat->xx;
  v31.z = 0.0;
  CVector::Normalise(&v31);
  *(_QWORD *)&v30.x = *(_QWORD *)&pCar->m_pMat->xy;
  v30.z = 0.0;
  CVector::Normalise(&v30);
  FindPlayerCoors(&v29, -1);
  p_m_transform = &pCar->m_transform;
  v16 = pCar->m_pMat;
  p_tx = &pCar->m_transform;
  v18 = y + (float)(yy * 0.1);
  v19 = x + (float)(xy * 0.1);
  if ( v16 )
    p_tx = (CSimpleTransform *)&v16->tx;
  v20 = (float)((float)(v19 * v31.x) + (float)(v18 * v31.y)) + (float)(v31.z * 0.0);
  v21 = -(float)((float)((float)((float)(v29.x - p_tx->m_translate.x) * v31.x)
                       + (float)((float)(v29.y - p_tx->m_translate.y) * v31.y))
               + (float)((float)(v29.z - p_tx->m_translate.z) * v31.z));
  if ( v20 == 0.0 )
    v20 = 0.01;
  v22 = v21 / v20;
  if ( (float)(v21 / v20) < 0.0 )
  {
    *pGas = 0.0;
LABEL_19:
    *pBrake = 0.0;
    return;
  }
  FindPlayerCoors(&v29, -1);
  v23 = pCar->m_pMat;
  if ( v23 )
    p_m_transform = (CSimpleTransform *)&v23->tx;
  v25.n64_f32[1] = v30.x * pCar->m_vecMoveSpeed.x;
  v26.n64_f32[1] = v30.y * pCar->m_vecMoveSpeed.y;
  v24.n64_f32[1] = v30.z * 0.0;
  v25.n64_f32[0] = (float)(v25.n64_f32[1] + v26.n64_f32[1]) + (float)(v30.z * pCar->m_vecMoveSpeed.z);
  v26.n64_f32[0] = (float)((float)((float)((float)((float)(v29.x - p_m_transform->m_translate.x) * v30.x)
                                         + (float)((float)(v29.y - p_m_transform->m_translate.y) * v30.y))
                                 + (float)((float)(v29.z - p_m_transform->m_translate.z) * v30.z))
                         + (float)(v22
                                 * (float)((float)((float)(v19 * v30.x) + (float)(v18 * v30.y)) + (float)(v30.z * 0.0))))
                 - (float)(v22 * v25.n64_f32[0]);
  if ( v26.n64_f32[0] > 0.0 )
  {
    v25.n64_u32[0] = 1.0;
    v26.n64_f32[0] = v26.n64_f32[0] * 0.1;
    v27 = vmin_f32(v26, v25).n64_u32[0];
LABEL_18:
    *(_DWORD *)pGas = v27;
    goto LABEL_19;
  }
  if ( v25.n64_f32[0] <= 0.0 )
  {
    v25.n64_u32[0] = -1.0;
    v26.n64_f32[0] = v26.n64_f32[0] * 0.1;
    v27 = vmax_f32(v26, v25).n64_u32[0];
    goto LABEL_18;
  }
  v24.n64_u32[0] = 1.0;
  v26.n64_f32[0] = v26.n64_f32[0] * -0.1;
  *pGas = 0.0;
  v28 = vmin_f32(v26, v24).n64_f32[0];
  *pBrake = v28;
  if ( v28 > 0.95 )
    *a5 = 1;
}

//----- (002F616C) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarTowardsPointInEscort(
        CVehicle *pCar,
        CVehicle *pTargetCar,
        float OffsetX,
        float OffsetY,
        bool *pHandBrake,
        _DWORD *a6,
        int *a7,
        _BYTE *a8)
{
  float32x2_t v8; // d0
  float32x2_t v9; // d1
  float32x2_t v10; // d2
  float32x2_t v11; // d3
  float32x2_t v12; // d4
  float32x2_t v13; // d8
  float32x2_t v14; // d9
  CMatrix *m_pMat; // r1
  float y; // s6
  float v19; // s10
  float v20; // s22
  CMatrix *v21; // r0
  float v22; // s24
  float xy; // s0
  float yy; // s18
  float v25; // s2
  float v26; // s20
  CMatrix *v27; // r1
  CSimpleTransform *p_m_transform; // r4
  float v29; // s2
  float v30; // s4
  CSimpleTransform *p_tx; // r1
  float ATanOfXY; // r6
  float v33; // r5
  CSimpleTransform *v34; // r1
  CMatrix *v35; // r0
  float x; // s26
  float v37; // s28
  float z; // s30
  CMatrix *v39; // r0
  float v40; // s8
  float v41; // s4
  float v42; // s0
  float v43; // s6
  float v44; // s10
  bool v45; // cc
  float v46; // s10
  int v47; // s2
  float v48; // s6
  float32x2_t v49; // d1
  float v50; // s8
  float v51; // s10
  float32x2_t v52; // d16
  float v53; // s4
  unsigned __int32 v54; // s2
  float v55; // s8
  CVector v; // [sp+8h] [bp-70h] BYREF
  CVector v57; // [sp+14h] [bp-64h] BYREF

  m_pMat = pTargetCar->m_pMat;
  v.x = OffsetX;
  v.y = OffsetY;
  v.z = 0.0;
  operator*(&v57, m_pMat, &v);
  y = v57.y;
  v19 = pTargetCar->m_vecMoveSpeed.y;
  v20 = v57.x + pTargetCar->m_vecMoveSpeed.x;
  *a8 = 0;
  v21 = pCar->m_pMat;
  v22 = y + v19;
  xy = v21->xy;
  yy = v21->yy;
  v25 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  if ( v25 == 0.0 )
  {
    v26 = 1.0;
  }
  else
  {
    yy = yy / v25;
    v26 = xy / v25;
  }
  v27 = pTargetCar->m_pMat;
  p_m_transform = &pCar->m_transform;
  v29 = v27->xy;
  v30 = v27->yy;
  p_tx = &pCar->m_transform;
  if ( v21 )
    p_tx = (CSimpleTransform *)&v21->tx;
  ATanOfXY = CGeneral::GetATanOfXY(
               (float)(v20 + (float)(v29 * 3.0)) - p_tx->m_translate.x,
               (float)(v22 + (float)(v30 * 3.0)) - p_tx->m_translate.y);
  v33 = CGeneral::GetATanOfXY(v26, yy);
  for ( v13.n64_f32[0] = CCarCtrl::FindAngleToWeaveThroughTraffic(pCar, 0, ATanOfXY, v33, 1.0) - v33;
        v13.n64_f32[0] < -3.1416;
        v13.n64_f32[0] = v13.n64_f32[0] + 6.2832 )
  {
    ;
  }
  for ( ; v13.n64_f32[0] > 3.1416; v13.n64_f32[0] = v13.n64_f32[0] + -6.2832 )
    ;
  v34 = &pCar->m_transform;
  v35 = pCar->m_pMat;
  if ( v35 )
    v34 = (CSimpleTransform *)&v35->tx;
  x = pCar->m_vecMoveSpeed.x;
  v37 = pCar->m_vecMoveSpeed.y;
  z = pCar->m_vecMoveSpeed.z;
  CGeneral::GetATanOfXY(v20 - v34->m_translate.x, v22 - v34->m_translate.y);
  v39 = pCar->m_pMat;
  if ( v39 )
    p_m_transform = (CSimpleTransform *)&v39->tx;
  v40 = v22 - p_m_transform->m_translate.y;
  v41 = v20 - p_m_transform->m_translate.x;
  v42 = sqrtf((float)((float)(x * x) + (float)(v37 * v37)) + (float)(z * z));
  v43 = sqrtf((float)(v41 * v41) + (float)(v40 * v40));
  v9.n64_f32[0] = 0.9 - v42;
  v44 = v26 * v41;
  v10.n64_u32[0] = 1060320051;
  v45 = v42 <= 0.7;
  v8.n64_u32[0] = 0.5;
  v12.n64_f32[0] = v44 + (float)(yy * v40);
  if ( !v45 )
    v9.n64_u32[0] = 1045220557;
  if ( v12.n64_f32[0] > 0.5 )
  {
    v46 = sqrtf(
            (float)((float)(pTargetCar->m_vecMoveSpeed.x * pTargetCar->m_vecMoveSpeed.x)
                  + (float)(pTargetCar->m_vecMoveSpeed.y * pTargetCar->m_vecMoveSpeed.y))
          + (float)(pTargetCar->m_vecMoveSpeed.z * pTargetCar->m_vecMoveSpeed.z))
        * 60.0;
    if ( v43 >= 15.0 )
    {
      v11.n64_u32[0] = 1133903872;
    }
    else
    {
      v14.n64_u32[0] = 4.0;
      v12.n64_f32[0] = (float)(v12.n64_f32[0] + -0.5) + -0.1;
      v11.n64_f32[0] = v43 * 3.5;
      v12.n64_u64[0] = vmin_f32(v12, v14).n64_u64[0];
      v12.n64_f32[0] = v12.n64_f32[0] + v46;
      if ( v12.n64_f32[0] > v11.n64_f32[0] )
        v11.n64_u64[0] = v12.n64_u64[0];
    }
    v12.n64_f32[0] = v46 + 10.0;
    LODWORD(v48) = vmin_f32(v11, v12).n64_u32[0];
    goto LABEL_28;
  }
  if ( v43 >= 15.0 )
  {
    v48 = 8.0;
LABEL_28:
    v49.n64_u64[0] = vmin_f32(v9, v10).n64_u64[0];
    v50 = pCar->m_vecMoveSpeed.y * pCar->m_vecMoveSpeed.y;
    v51 = pCar->m_vecMoveSpeed.z * pCar->m_vecMoveSpeed.z;
    v10.n64_f32[0] = -v49.n64_f32[0];
    v52.n64_u64[0] = vmax_f32(v13, v10).n64_u64[0];
    v53 = pCar->m_vecMoveSpeed.x;
    *a7 = 0;
    v54 = vmin_f32(v52, v49).n64_u32[0];
    v55 = sqrtf((float)((float)(v53 * v53) + v50) + v51) * 60.0;
    v10.n64_f32[0] = v48 - v55;
    if ( (float)(v48 - v55) <= 0.0 )
    {
      *a6 = 0;
      v10.n64_f32[0] = v10.n64_f32[0] / -20.0;
      *a7 = vmin_f32(v10, v8).n64_u32[0];
    }
    else if ( v55 >= 25.0 )
    {
      *a6 = 1065353216;
    }
    else
    {
      v8.n64_f32[0] = v10.n64_f32[0] / 10.0;
      v10.n64_u32[0] = 1.0;
      *a6 = vmin_f32(v8, v10).n64_u32[0];
    }
    *(_DWORD *)pHandBrake = v54;
    return;
  }
  v47 = 1036831949;
  if ( v12.n64_f32[0] < -3.0 )
    v47 = 1.0;
  *(_DWORD *)pHandBrake = 0;
  *a6 = 0;
  *a7 = v47;
}
// 2F63A8: variable 'v12' is possibly undefined
// 2F63A8: variable 'v14' is possibly undefined
// 2F6402: variable 'v11' is possibly undefined
// 2F640C: variable 'v9' is possibly undefined
// 2F640C: variable 'v10' is possibly undefined
// 2F6426: variable 'v13' is possibly undefined
// 2F6474: variable 'v8' is possibly undefined

//----- (002F64D4) --------------------------------------------------------
void __fastcall CCarCtrl::GetAIPlaneToAttackPlayer(CAutomobile *pVeh)
{
  const CVector *PlayerSpeed; // r0
  float v3; // s0
  float v4; // s2
  float z; // s18
  CMatrix *m_pMat; // r0
  float v7; // s20
  CSimpleTransform *p_tx; // r1
  CVehicle *PlayerVehicle; // r0
  CVehicle *v10; // r0
  CVehicle *v11; // r0
  CVehicle *v12; // r0
  CVector v13; // [sp+4h] [bp-2Ch] BYREF

  FindPlayerCoors(&v13, -1);
  PlayerSpeed = FindPlayerSpeed(-1);
  v3 = PlayerSpeed->x * 50.0;
  v4 = PlayerSpeed->y * 50.0;
  z = PlayerSpeed->z;
  m_pMat = pVeh->m_pMat;
  v7 = v13.z;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVeh->m_transform;
  *(float *)&pVeh[1].m_pLastRenderedLink = CGeneral::GetATanOfXY(
                                             (float)(v3 + v13.x) - p_tx->m_translate.x,
                                             (float)(v4 + v13.y) - p_tx->m_translate.y);
  *(float *)&pVeh[1].m_nFlags.bdummy = (float)(z * 50.0) + v7;
  CCarCtrl::FlyAIPlaneInCertainDirection((CPlane *)pVeh);
  if ( FindPlayerVehicle(-1, 0) )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    if ( CVehicle::GetVehicleAppearance(PlayerVehicle) == APR_PLANE )
    {
      v10 = FindPlayerVehicle(-1, 0);
      CCarCtrl::TriggerDogFightMoves(pVeh, v10);
    }
  }
  v11 = FindPlayerVehicle(-1, 0);
  CCarCtrl::TestWhetherToFirePlaneGuns(pVeh, v11);
  v12 = FindPlayerVehicle(-1, 0);
  CCarCtrl::PossiblyFireHSMissile(pVeh, v12);
}

//----- (002F65C4) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIPlaneToFollowEntity(CAutomobile *pVeh)
{
  CEntity *pTargetEntity; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v4; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float ATanOfXY; // r0
  CEntity *v8; // r1
  CMatrix *v9; // r0
  CSimpleTransform *p_m_transform; // r2

  pTargetEntity = pVeh->AutoPilot.pTargetEntity;
  m_pMat = pVeh->m_pMat;
  v4 = pTargetEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVeh->m_transform;
  p_x = &v4->tx;
  if ( !v4 )
    p_x = &pTargetEntity->m_transform.m_translate.x;
  ATanOfXY = CGeneral::GetATanOfXY(*p_x - p_tx->m_translate.x, p_x[1] - p_tx->m_translate.y);
  v8 = pVeh->AutoPilot.pTargetEntity;
  *(float *)&pVeh[1].m_pLastRenderedLink = ATanOfXY;
  v9 = v8->m_pMat;
  p_m_transform = (CSimpleTransform *)&v9->tx;
  if ( !v9 )
    p_m_transform = &v8->m_transform;
  pVeh[1].m_nFlags.bdummy = LODWORD(p_m_transform->m_translate.z);
  CCarCtrl::FlyAIPlaneInCertainDirection((CPlane *)pVeh);
}

//----- (002F662E) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIPlaneToCrashAndBurn(CAutomobile *pVeh)
{
  RwReal v1; // s0

  v1 = -1.0;
  if ( (pVeh->RandomSeed & 1) != 0 )
    v1 = 1.0;
  pVeh[1].m_transform.m_translate.x = -0.3;
  pVeh[1].m_transform.m_translate.z = -0.0;
  *(RwReal *)&pVeh[1]._vptr$CPlaceable = v1;
  pVeh[1].m_transform.m_translate.y = v1;
}

//----- (002F6668) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliToCrashAndBurn(CAutomobile *pVeh)
{
  RwReal v1; // s0
  float z; // s4

  v1 = -1.0;
  z = -pVeh[1].m_vecAverageTurnSpeed.z;
  if ( (pVeh->RandomSeed & 1) != 0 )
  {
    v1 = 1.0;
    z = pVeh[1].m_vecAverageTurnSpeed.z;
  }
  pVeh[1].m_transform.m_translate.y = -0.3;
  pVeh[1].m_transform.m_heading = -0.5;
  pVeh[1].m_transform.m_translate.z = v1;
  pVeh[1].m_transform.m_translate.x = z;
}

//----- (002F66B4) --------------------------------------------------------
void __fastcall CCarCtrl::GetAIHeliToAttackPlayer(CAutomobile *pVeh)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  float x; // s16
  CSimpleTransform *p_tx; // r1
  float v6; // s18
  CMatrix *v7; // r0
  CSimpleTransform *v8; // r1
  float ATanOfXY; // r5
  CMatrix *v10; // r0
  CSimpleTransform *v11; // r1
  float v12; // s16
  float v13; // s18
  CMatrix *v14; // r0
  CSimpleTransform *v15; // r1
  float v16; // s20
  float v17; // s22
  CMatrix *v18; // r0
  CSimpleTransform *v19; // r1
  float y; // s24
  float v21; // s26
  CMatrix *v22; // r0
  float v23; // s28
  float v24; // s30
  __int64 v25; // d16
  int Mission; // r0
  float v27; // s2
  float v28; // s0
  bool v29; // nf
  CEntity *PlayerEntity; // r0
  CEntity *v31; // r0
  CVector v32; // [sp+4h] [bp-84h] BYREF
  CVector v33; // [sp+10h] [bp-78h] BYREF
  CVector v34; // [sp+1Ch] [bp-6Ch] BYREF
  CVector v35; // [sp+28h] [bp-60h] BYREF

  FindPlayerCoors(&v35, -1);
  m_pMat = pVeh->m_pMat;
  p_m_transform = &pVeh->m_transform;
  x = v35.x;
  p_tx = &pVeh->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v6 = p_tx->m_translate.x;
  FindPlayerCoors(&v34, -1);
  v7 = pVeh->m_pMat;
  v8 = &pVeh->m_transform;
  if ( v7 )
    v8 = (CSimpleTransform *)&v7->tx;
  ATanOfXY = CGeneral::GetATanOfXY(x - v6, v34.y - v8->m_translate.y);
  FindPlayerCoors(&v35, -1);
  v10 = pVeh->m_pMat;
  v11 = &pVeh->m_transform;
  v12 = v35.x;
  if ( v10 )
    v11 = (CSimpleTransform *)&v10->tx;
  v13 = v11->m_translate.x;
  FindPlayerCoors(&v34, -1);
  v14 = pVeh->m_pMat;
  v15 = &pVeh->m_transform;
  v16 = v34.x;
  if ( v14 )
    v15 = (CSimpleTransform *)&v14->tx;
  v17 = v15->m_translate.x;
  FindPlayerCoors(&v33, -1);
  v18 = pVeh->m_pMat;
  v19 = &pVeh->m_transform;
  y = v33.y;
  if ( v18 )
    v19 = (CSimpleTransform *)&v18->tx;
  v21 = v19->m_translate.y;
  FindPlayerCoors(&v32, -1);
  v22 = pVeh->m_pMat;
  v23 = v32.y;
  if ( v22 )
    p_m_transform = (CSimpleTransform *)&v22->tx;
  v24 = p_m_transform->m_translate.y;
  FindPlayerCoors(&v35, -1);
  pVeh[1].m_nFlags.bdummy = LODWORD(v35.z);
  FindPlayerCoors(&v35, -1);
  v25 = *(_QWORD *)&v35.x;
  pVeh->AutoPilot.TargetCoors.z = v35.z;
  *(_QWORD *)&pVeh->AutoPilot.TargetCoors.x = v25;
  Mission = pVeh->AutoPilot.Mission;
  v27 = ATanOfXY;
  v28 = sqrtf((float)((float)(v12 - v13) * (float)(v16 - v17)) + (float)((float)(y - v21) * (float)(v23 - v24)));
  if ( Mission == 56 )
  {
    v27 = ATanOfXY + 3.1416;
    if ( v28 > 18.0 )
      pVeh->AutoPilot.Mission = 23;
  }
  else if ( Mission == 23 )
  {
    v29 = v28 < 15.0;
    v28 = v28 + 50.0;
    if ( v29 )
      pVeh->AutoPilot.Mission = 56;
  }
  CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVeh, v27, v28, 0);
  PlayerEntity = FindPlayerEntity(-1);
  CCarCtrl::TestWhetherToFirePlaneGuns(pVeh, PlayerEntity);
  v31 = FindPlayerEntity(-1);
  CCarCtrl::FireHeliRocketsAtTarget(pVeh, v31);
}

//----- (002F6864) --------------------------------------------------------
void __fastcall CCarCtrl::GetAIHeliToFlyInDirection(CAutomobile *pVeh)
{
  CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVeh, *(float *)&pVeh[1].m_pLastRenderedLink, 1000.0, 0);
}

//----- (002F6874) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliToFollowEntity(CAutomobile *pVeh)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d8
  CEntity *pTargetEntity; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  int AimAheadOfTarget; // r0
  __int64 v9; // d16
  CMatrix *v10; // r1
  float v11; // s0
  float v12; // s4
  float v13; // s6
  float x; // s0
  float y; // s2
  RwReal v16; // s4
  CMatrix *v17; // r0
  CSimpleTransform *v18; // r8
  CSimpleTransform *p_tx; // r1
  float ATanOfXY; // r1
  CEntity *v21; // r0
  CMatrix *v22; // r2
  CSimpleTransform *v23; // r5
  CVector *p_m_translate; // r6
  CMatrix *v25; // r3
  float32x2_t *v26; // r2
  float32x2_t v27; // d16
  float32x2_t v28; // d2
  unsigned __int64 v29; // d0
  unsigned __int32 v30; // s2
  float v31; // s0
  float HeliRequestedOrientation; // s2
  CMatrix *v33; // r0
  __int16 v34; // r0
  CEntity *v35; // r1
  CMatrix *v36; // r2
  CMatrix *v37; // r3
  float32x2_t *v38; // r2
  float32x2_t v39; // d16
  unsigned __int64 v40; // d0
  CEntity::CEntityInfo m_info; // r0
  int v42; // r2
  bool v43; // zf
  CTask *ActiveTask; // r0
  CTask *v45; // r5

  pTargetEntity = pVeh->AutoPilot.pTargetEntity;
  m_pMat = pTargetEntity->m_pMat;
  p_m_transform = &pTargetEntity->m_transform;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  AimAheadOfTarget = (unsigned __int8)pVeh->AutoPilot.AimAheadOfTarget;
  v9 = *(_QWORD *)&p_m_transform->m_translate.x;
  pVeh->AutoPilot.TargetCoors.z = p_m_transform->m_translate.z;
  *(_QWORD *)&pVeh->AutoPilot.TargetCoors.x = v9;
  if ( AimAheadOfTarget )
  {
    v10 = pTargetEntity->m_pMat;
    if ( !v10 )
    {
      CPlaceable::AllocateMatrix(pTargetEntity);
      CSimpleTransform::UpdateMatrix(&pTargetEntity->m_transform, pTargetEntity->m_pMat);
      LOBYTE(AimAheadOfTarget) = pVeh->AutoPilot.AimAheadOfTarget;
      v10 = pTargetEntity->m_pMat;
    }
    v11 = (float)(char)AimAheadOfTarget;
    v12 = v10->yy * v11;
    v13 = v11 * 0.0;
    x = pVeh->AutoPilot.TargetCoors.x + (float)(v10->xy * v11);
    y = v12 + pVeh->AutoPilot.TargetCoors.y;
    v16 = v13 + pVeh->AutoPilot.TargetCoors.z;
    pVeh->AutoPilot.TargetCoors.x = x;
    pVeh->AutoPilot.TargetCoors.y = y;
    pVeh->AutoPilot.TargetCoors.z = v16;
  }
  else
  {
    x = pVeh->AutoPilot.TargetCoors.x;
    y = pVeh->AutoPilot.TargetCoors.y;
  }
  v17 = pVeh->m_pMat;
  v18 = &pVeh->m_transform;
  p_tx = &pVeh->m_transform;
  if ( v17 )
    p_tx = (CSimpleTransform *)&v17->tx;
  ATanOfXY = CGeneral::GetATanOfXY(x - p_tx->m_translate.x, y - p_tx->m_translate.y);
  v21 = pVeh->AutoPilot.pTargetEntity;
  v22 = pVeh->m_pMat;
  v23 = &pVeh->m_transform;
  p_m_translate = &v21->m_transform.m_translate;
  v25 = v21->m_pMat;
  if ( v22 )
    v23 = (CSimpleTransform *)&v22->tx;
  v26 = (float32x2_t *)&v21->m_transform;
  if ( v25 )
    v26 = (float32x2_t *)&v25->tx;
  v1.n64_u32[0] = 6.0;
  v3.n64_u32[0] = 25.0;
  v27.n64_u64[0] = vsub_f32((float32x2_t)v26->n64_u64[0], *(float32x2_t *)&v23->m_translate.x).n64_u64[0];
  v2.n64_u32[0] = v26[1].n64_u32[0];
  v28.n64_u64[0] = vmax_f32(v2, v1).n64_u64[0];
  v29 = vmul_f32(v27, v27).n64_u64[0];
  v30 = vmax_f32(v28, v3).n64_u32[0];
  v31 = sqrtf(*(float *)&v29 + *((float *)&v29 + 1));
  if ( v31 > 50.0 )
    v28.n64_u32[0] = v30;
  HeliRequestedOrientation = pVeh->HeliRequestedOrientation;
  pVeh[1].m_nFlags.bdummy = v28.n64_u32[0];
  if ( HeliRequestedOrientation >= 0.0 )
  {
    v33 = v21->m_pMat;
    if ( v33 )
      p_m_translate = (CVector *)&v33->tx;
    CCarCtrl::FlyAIHeliToTarget_FixedOrientation((CHeli *)pVeh, HeliRequestedOrientation, *p_m_translate, 0);
  }
  else
  {
    CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVeh, ATanOfXY, v31, 1);
  }
  v34 = *(_WORD *)((char *)&pVeh->AutoPilot + 75);
  if ( (v34 & 0x20) != 0 )
  {
    v35 = pVeh->AutoPilot.pTargetEntity;
    v36 = pVeh->m_pMat;
    v37 = v35->m_pMat;
    if ( v36 )
      v18 = (CSimpleTransform *)&v36->tx;
    v38 = (float32x2_t *)&v37->tx;
    if ( !v37 )
      v38 = (float32x2_t *)&v35->m_transform;
    v39.n64_u64[0] = vsub_f32(*(float32x2_t *)&v18->m_translate.x, (float32x2_t)v38->n64_u64[0]).n64_u64[0];
    v40 = vmul_f32(v39, v39).n64_u64[0];
    if ( sqrtf(*(float *)&v40 + *((float *)&v40 + 1)) < 25.0 )
    {
      m_info = v35->m_info;
      v42 = *(_BYTE *)&m_info & 7;
      if ( v42 == 3 )
      {
        ActiveTask = CTaskManager::GetActiveTask((const CTaskManager *)(LODWORD(v35[18].m_transform.m_translate.y) + 4));
        v45 = ActiveTask;
        if ( ActiveTask && (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) == 912 )
          v45[1].m_pParent = (CTask *)&byte_7;
      }
      else
      {
        v43 = v42 == 2;
        if ( v42 == 2 )
          v43 = (*(_BYTE *)&m_info & 0xF0) == 16;
        if ( v43 )
        {
          LOBYTE(v35[16].m_pMat) = 100;
          *(_WORD *)&v35[15].numLodChildrenRendered = 258;
          v35->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
        }
      }
      v34 = *(_WORD *)((char *)&pVeh->AutoPilot + 75) & 0xFFDF;
      *(_WORD *)((char *)&pVeh->AutoPilot + 75) = v34;
    }
  }
  if ( (v34 & 0x80) != 0 && CTimer::m_snTimeInMilliseconds > pVeh->m_TimeOfCreation + 50000 )
  {
    pVeh->AutoPilot.Mission = 42;
    *(_WORD *)((char *)&pVeh->AutoPilot + 75) = v34 & 0xFF7F;
  }
  if ( pVeh->AutoPilot.Mission == 41 && pVeh->m_nHealth < 300.0 )
    pVeh->AutoPilot.Mission = 42;
}
// 2F6980: variable 'v2' is possibly undefined
// 2F6980: variable 'v1' is possibly undefined
// 2F6988: variable 'v3' is possibly undefined
// 7: using guessed type char byte_7;

//----- (002F6AF4) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliAsPoliceHeli(CAutomobile *pVeh)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  CSimpleTransform *p_m_transform; // r5
  CEntity *pTargetEntity; // r0
  CMatrix *m_pMat; // r1
  float *p_x; // r3
  CMatrix *v9; // r2
  float *p_tx; // r1
  float ATanOfXY; // r12
  CEntity *v12; // r0
  CMatrix *v13; // r2
  CSimpleTransform *v14; // r3
  CMatrix *v15; // r1
  float32x2_t *v16; // r2
  float32x2_t v17; // d16
  float32x2_t v18; // d2
  unsigned __int64 v19; // d0
  unsigned __int32 v20; // s2
  float v21; // r2
  CMatrix *v22; // r0
  __int64 v23; // d16

  p_m_transform = &pVeh->m_transform;
  pTargetEntity = pVeh->AutoPilot.pTargetEntity;
  m_pMat = pVeh->m_pMat;
  p_x = &p_m_transform->m_translate.x;
  v9 = pTargetEntity->m_pMat;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  p_tx = &v9->tx;
  if ( !v9 )
    p_tx = &pTargetEntity->m_transform.m_translate.x;
  ATanOfXY = CGeneral::GetATanOfXY(*p_tx - *p_x, p_tx[1] - p_x[1]);
  v12 = pVeh->AutoPilot.pTargetEntity;
  v13 = pVeh->m_pMat;
  v2.n64_u32[0] = 6.0;
  v14 = &v12->m_transform;
  v15 = v12->m_pMat;
  if ( v13 )
    p_m_transform = (CSimpleTransform *)&v13->tx;
  v16 = (float32x2_t *)&v12->m_transform;
  if ( v15 )
    v16 = (float32x2_t *)&v15->tx;
  v1.n64_u32[0] = 25.0;
  v17.n64_u64[0] = vsub_f32((float32x2_t)v16->n64_u64[0], *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
  v3.n64_u32[0] = v16[1].n64_u32[0];
  v18.n64_u64[0] = vmax_f32(v3, v2).n64_u64[0];
  v19 = vmul_f32(v17, v17).n64_u64[0];
  v20 = vmax_f32(v18, v1).n64_u32[0];
  v21 = sqrtf(*(float *)&v19 + *((float *)&v19 + 1));
  if ( v21 > 50.0 )
    v18.n64_u32[0] = v20;
  pVeh[1].m_nFlags.bdummy = v18.n64_u32[0];
  v22 = v12->m_pMat;
  if ( v22 )
    v14 = (CSimpleTransform *)&v22->tx;
  v23 = *(_QWORD *)&v14->m_translate.x;
  pVeh->AutoPilot.TargetCoors.z = v14->m_translate.z;
  *(_QWORD *)&pVeh->AutoPilot.TargetCoors.x = v23;
  CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVeh, ATanOfXY, v21, 1);
  if ( pVeh->m_nHealth < 230.0 )
    pVeh->AutoPilot.Mission = 42;
}
// 2F6B7A: variable 'v3' is possibly undefined
// 2F6B7A: variable 'v2' is possibly undefined
// 2F6B82: variable 'v1' is possibly undefined

//----- (002F6BEC) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliFlyingAwayFromPlayer(CAutomobile *pVeh)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r5
  float x; // s16
  CSimpleTransform *p_tx; // r1
  float v6; // s18
  CMatrix *v7; // r0
  float ATanOfXY; // r0
  CVector v9; // [sp+0h] [bp-30h] BYREF
  CVector v10; // [sp+Ch] [bp-24h] BYREF

  FindPlayerCoors(&v10, -1);
  m_pMat = pVeh->m_pMat;
  p_m_transform = &pVeh->m_transform;
  x = v10.x;
  p_tx = &pVeh->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v6 = p_tx->m_translate.x;
  FindPlayerCoors(&v9, -1);
  v7 = pVeh->m_pMat;
  if ( v7 )
    p_m_transform = (CSimpleTransform *)&v7->tx;
  ATanOfXY = CGeneral::GetATanOfXY(x - v6, v9.y - p_m_transform->m_translate.y);
  CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVeh, ATanOfXY + 3.1416, 1000.0, 0);
}

//----- (002F6C74) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarParkPerpendicular(
        CVehicle *pCar,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *pHandBrake)
{
  CNodeAddress NewNode; // r2
  CPathNode *v10; // r1
  CNodeAddress OldNode; // r3
  CPathNode *v12; // r0
  unsigned int v13; // r2
  float *v14; // r6
  CPathNode *v15; // r2
  float CoorsX; // s2
  int CoorsY; // t1
  CPathNode *v18; // r11
  Int16 *v19; // r11
  int v20; // t1
  __int16 *v21; // r9
  float v22; // s4
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r10
  CSimpleTransform *p_tx; // r2
  float v26; // r0
  Int16 *p_CoorsY; // r1
  __int16 *p_CoorsX; // r8
  CPathNode *v29; // r0
  __int16 *v30; // r6
  unsigned int CruiseSpeed; // r0
  CPed *pDriver; // r0
  int m_nVehicleFlags; // r1
  __int16 v34; // r2
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplex *v36; // r5
  CPed **pPassengers; // r11
  int i; // r6
  CPed *v39; // r0
  CPedIntelligence *v40; // r5
  CTaskComplex *v41; // r4
  Int16 *v42; // [sp+10h] [bp-58h]
  Int16 *v43; // [sp+14h] [bp-54h]
  CMatrix **p_m_pMat; // [sp+18h] [bp-50h]
  CVector pPoint; // [sp+1Ch] [bp-4Ch] BYREF
  CVector pVecEnd; // [sp+28h] [bp-40h] BYREF
  CVector pVecStart; // [sp+34h] [bp-34h] BYREF

  NewNode = pCar->AutoPilot.NewNode;
  v10 = ThePaths.pNodes[NewNode.Region];
  if ( !v10 || (OldNode = pCar->AutoPilot.OldNode, (v12 = ThePaths.pNodes[OldNode.Region]) == 0) )
  {
    pCar->AutoPilot.Mission = 11;
    *pBrakePedal = 0.0;
    *pGasPedal = 0.0;
    *pSteerAngle = 0.0;
    return;
  }
  v13 = HIWORD(*(unsigned int *)&NewNode);
  if ( pCar->AutoPilot.Mission != 45 )
  {
    p_m_transform = &pCar->m_transform;
    v29 = &v10[v13];
    p_CoorsY = &v29->CoorsY;
    p_CoorsX = &v29->CoorsX;
    p_m_pMat = &pCar->m_pMat;
    goto LABEL_11;
  }
  v14 = pGasPedal;
  v15 = &v10[v13];
  v43 = &v15->CoorsX;
  CoorsX = (float)v15->CoorsX;
  CoorsY = v15->CoorsY;
  v42 = &v15->CoorsY;
  v18 = &v12[HIWORD(*(unsigned int *)&OldNode)];
  pVecStart.z = 0.0;
  pVecStart.x = CoorsX * 0.125;
  pVecStart.y = (float)CoorsY * 0.125;
  v20 = v18->CoorsY;
  v19 = &v18->CoorsY;
  v21 = v19 - 1;
  v22 = (float)*(v19 - 1);
  pVecEnd.z = 0.0;
  pVecEnd.y = (float)v20 * 0.125;
  pVecEnd.x = v22 * 0.125;
  m_pMat = pCar->m_pMat;
  p_m_transform = &pCar->m_transform;
  p_m_pMat = &pCar->m_pMat;
  p_tx = &pCar->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  *(_QWORD *)&pPoint.x = *(_QWORD *)&p_tx->m_translate.x;
  pPoint.z = 0.0;
  v26 = CCollision::DistToMathematicalLine(&pVecStart, &pVecEnd, &pPoint);
  p_CoorsY = v42;
  p_CoorsX = v43;
  pGasPedal = v14;
  if ( v26 < 6.0 )
  {
    pCar->AutoPilot.Mission = 49;
LABEL_11:
    v21 = p_CoorsX;
    v19 = p_CoorsY;
    goto LABEL_12;
  }
  if ( pCar->AutoPilot.Mission != 45 )
    goto LABEL_11;
LABEL_12:
  v30 = p_CoorsY;
  CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
    pCar,
    0,
    (float)*v21 * 0.125,
    (float)*v19 * 0.125,
    pSteerAngle,
    pGasPedal,
    pBrakePedal,
    pHandBrake);
  CruiseSpeed = pCar->AutoPilot.CruiseSpeed;
  if ( CruiseSpeed >= 8 )
    LOBYTE(CruiseSpeed) = 8;
  pCar->AutoPilot.CruiseSpeed = CruiseSpeed;
  if ( *p_m_pMat )
    p_m_transform = (CSimpleTransform *)&(*p_m_pMat)->tx;
  if ( sqrtf(
         (float)((float)((float)((float)*p_CoorsX * 0.125) - p_m_transform->m_translate.x)
               * (float)((float)((float)*p_CoorsX * 0.125) - p_m_transform->m_translate.x))
       + (float)((float)((float)((float)*v30 * 0.125) - p_m_transform->m_translate.y)
               * (float)((float)((float)*v30 * 0.125) - p_m_transform->m_translate.y))) < 2.0 )
  {
    pDriver = pCar->pDriver;
    m_nVehicleFlags = (int)pCar->m_nVehicleFlags;
    v34 = *(_WORD *)((char *)&pCar->AutoPilot + 75);
    pCar->AutoPilot.Mission = 11;
    *(_WORD *)((char *)&pCar->AutoPilot + 75) = v34 | 0x200;
    *(_DWORD *)&pCar->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFAF;
    if ( pDriver )
    {
      m_pPedIntelligence = pDriver->m_pPedIntelligence;
      v36 = (CTaskComplex *)CTask::operator new(0x14u);
      CTaskComplex::CTaskComplex(v36);
      v36[1]._vptr$CTask = 0;
      v36->_vptr$CTask = (int (**)(void))&off_66AF80;
      LOWORD(v36[1].m_pParent) = 1;
      CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v36, 3, 0);
    }
    pPassengers = pCar->pPassengers;
    for ( i = 0; i != 8; ++i )
    {
      v39 = pPassengers[i];
      if ( v39 )
      {
        v40 = v39->m_pPedIntelligence;
        v41 = (CTaskComplex *)CTask::operator new(0x14u);
        CTaskComplex::CTaskComplex(v41);
        v41[1]._vptr$CTask = 0;
        v41->_vptr$CTask = (int (**)(void))&off_66AF80;
        LOWORD(v41[1].m_pParent) = 1;
        CTaskManager::SetTask(&v40->m_taskManager, v41, 3, 0);
      }
    }
  }
}
// 66AF80: using guessed type void *off_66AF80;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (002F6F2C) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAICarParkParallel(
        CVehicle *pCar,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *a5)
{
  int16x4_t v5; // d16
  CNodeAddress NewNode; // r1
  CPathNode *v11; // r0
  CNodeAddress OldNode; // r2
  CPathNode *v13; // r3
  unsigned int v14; // r1
  CPathNode *v15; // r6
  __int16 *v16; // r0
  int CoorsX; // t1
  RwReal v18; // s4
  RwReal v19; // s0
  unsigned __int64 v20; // d8
  unsigned int CruiseSpeed; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  float v24; // s0
  CPed *pDriver; // r0
  int m_nVehicleFlags; // r1
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplex *v28; // r5
  CPed **pPassengers; // r11
  int i; // r6
  CPed *v31; // r0
  CPedIntelligence *v32; // r5
  CTaskComplex *v33; // r4
  CVector v34; // [sp+10h] [bp-38h] BYREF

  NewNode = pCar->AutoPilot.NewNode;
  v11 = ThePaths.pNodes[NewNode.Region];
  if ( v11 && (OldNode = pCar->AutoPilot.OldNode, (v13 = ThePaths.pNodes[OldNode.Region]) != 0) )
  {
    v14 = HIWORD(*(unsigned int *)&NewNode);
    if ( pCar->AutoPilot.Mission == 46 )
    {
      v15 = &v11[v14];
      v16 = (__int16 *)&v13[HIWORD(*(unsigned int *)&OldNode)];
      CoorsX = v15->CoorsX;
      v15 = (CPathNode *)((char *)v15 + 8);
      v18 = (float)((float)SHIWORD(v15->pNext) * 0.125) - (float)((float)v16[5] * 0.125);
      v19 = (float)((float)SLOWORD(v15->pPrevious) * 0.125) - (float)((float)v16[6] * 0.125);
      v34.x = (float)((float)CoorsX * 0.125) - (float)((float)v16[4] * 0.125);
      v34.y = v18;
      v34.z = v19;
      CVector::Normalise(&v34);
      v5.n64_u32[0] = (unsigned __int32)v15->pNext;
      v20 = vadd_f32(
              vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v5).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL),
              *(float32x2_t *)&v34.x).n64_u64[0];
    }
    else
    {
      v5.n64_u32[0] = *(_DWORD *)&v11[v14].CoorsX;
      v20 = vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v5).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
    }
    CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
      pCar,
      0,
      *(float *)&v20,
      *((float *)&v20 + 1),
      pSteerAngle,
      pGasPedal,
      pBrakePedal,
      a5);
    CruiseSpeed = pCar->AutoPilot.CruiseSpeed;
    m_pMat = pCar->m_pMat;
    if ( CruiseSpeed >= 8 )
      LOBYTE(CruiseSpeed) = 8;
    pCar->AutoPilot.CruiseSpeed = CruiseSpeed;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pCar->m_transform;
    v24 = sqrtf(
            (float)((float)(*(float *)&v20 - p_tx->m_translate.x) * (float)(*(float *)&v20 - p_tx->m_translate.x))
          + (float)((float)(*((float *)&v20 + 1) - p_tx->m_translate.y)
                  * (float)(*((float *)&v20 + 1) - p_tx->m_translate.y)));
    if ( pCar->AutoPilot.Mission == 46 )
    {
      if ( v24 < 4.0 )
        pCar->AutoPilot.Mission = 50;
    }
    else if ( v24 < 2.0 )
    {
      pDriver = pCar->pDriver;
      m_nVehicleFlags = (int)pCar->m_nVehicleFlags;
      pCar->AutoPilot.Mission = 11;
      *(_DWORD *)&pCar->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFAF;
      if ( pDriver )
      {
        m_pPedIntelligence = pDriver->m_pPedIntelligence;
        v28 = (CTaskComplex *)CTask::operator new(0x14u);
        CTaskComplex::CTaskComplex(v28);
        v28[1]._vptr$CTask = 0;
        v28->_vptr$CTask = (int (**)(void))&off_66AF80;
        LOWORD(v28[1].m_pParent) = 1;
        CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v28, 3, 0);
      }
      pPassengers = pCar->pPassengers;
      for ( i = 0; i != 8; ++i )
      {
        v31 = pPassengers[i];
        if ( v31 )
        {
          v32 = v31->m_pPedIntelligence;
          v33 = (CTaskComplex *)CTask::operator new(0x14u);
          CTaskComplex::CTaskComplex(v33);
          v33[1]._vptr$CTask = 0;
          v33->_vptr$CTask = (int (**)(void))&off_66AF80;
          LOWORD(v33[1].m_pParent) = 1;
          CTaskManager::SetTask(&v32->m_taskManager, v33, 3, 0);
        }
      }
    }
  }
  else
  {
    pCar->AutoPilot.Mission = 11;
    *pBrakePedal = 0.0;
    *pGasPedal = 0.0;
    *pSteerAngle = 0.0;
  }
}
// 2F701A: variable 'v5' is possibly undefined
// 66AF80: using guessed type void *off_66AF80;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (002F7198) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliToLand(CAutomobile *pVeh)
{
  CSimpleTransform *p_m_transform; // r5
  CMatrix *m_pMat; // r0
  float *p_x; // r1
  float ATanOfXY; // r1
  CMatrix *v6; // r0
  float32x2_t v7; // d16
  unsigned __int64 v8; // d0
  float v9; // s16
  float v10; // s2

  p_m_transform = &pVeh->m_transform;
  m_pMat = pVeh->m_pMat;
  p_x = &p_m_transform->m_translate.x;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  ATanOfXY = CGeneral::GetATanOfXY(pVeh->AutoPilot.TargetCoors.x - *p_x, pVeh->AutoPilot.TargetCoors.y - p_x[1]);
  v6 = pVeh->m_pMat;
  if ( v6 )
    p_m_transform = (CSimpleTransform *)&v6->tx;
  v7.n64_u64[0] = vsub_f32(
                    *(float32x2_t *)&pVeh->AutoPilot.TargetCoors.x,
                    *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  v9 = sqrtf(*(float *)&v8 + *((float *)&v8 + 1));
  CCarCtrl::FlyAIHeliInCertainDirection((CHeli *)pVeh, ATanOfXY, v9, 1);
  if ( v9 < 10.0
    && sqrtf(
         (float)(pVeh->m_vecMoveSpeed.x * pVeh->m_vecMoveSpeed.x)
       + (float)(pVeh->m_vecMoveSpeed.y * pVeh->m_vecMoveSpeed.y)) < 0.05 )
  {
    v10 = pVeh->m_aWheelRatios[0];
    pVeh[1].m_nFlags.bdummy = 0;
    pVeh[1].pReferences = 0;
    if ( v10 < 1.0 || pVeh->m_aWheelRatios[1] < 1.0 || pVeh->m_aWheelRatios[2] < 1.0 || pVeh->m_aWheelRatios[3] < 1.0 )
    {
      *(_QWORD *)&pVeh[1].m_transform.m_translate.x = 0LL;
      *(_QWORD *)&pVeh[1].m_transform.m_translate.z = 0LL;
    }
  }
}

//----- (002F72A4) --------------------------------------------------------
void __fastcall CCarCtrl::SteerAIHeliToKeepEntityInView(CAutomobile *pVeh)
{
  CSimpleTransform *p_m_transform; // r8
  CEntity *pTargetEntity; // r0
  CMatrix *m_pMat; // r1
  float *p_x; // r3
  CMatrix *v6; // r2
  float *p_tx; // r1
  float ATanOfXY; // r0
  CEntity *v9; // r2
  float32x2_t *v10; // r5
  CMatrix *v11; // r1
  CMatrix *v12; // r3
  float32x2_t *v13; // r6
  float32x2_t v14; // d16
  unsigned __int64 v15; // d0
  float v16; // s16
  float i; // s0
  float v18; // s18
  float *v19; // r1
  float *p_m_heading; // r5
  float v21; // s4
  float v22; // s2
  float v23; // s6
  CEntity *v24; // r0
  CSimpleTransform *v25; // r2
  CMatrix *v26; // r1
  CSimpleTransform *v27; // r3
  float v28; // s0
  CMatrix *v29; // r0
  CMatrix *v30; // r1
  float v31; // s2
  __int64 v32; // d16
  float v33; // s4
  float v34; // s0
  int v35; // r0
  float v36; // s4
  float v37; // s2
  float v38; // s2
  float v39; // s6
  float HooverDistFromTarget; // s0

  p_m_transform = &pVeh->m_transform;
  pTargetEntity = pVeh->AutoPilot.pTargetEntity;
  m_pMat = pVeh->m_pMat;
  p_x = &p_m_transform->m_translate.x;
  v6 = pTargetEntity->m_pMat;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  p_tx = &v6->tx;
  if ( !v6 )
    p_tx = &pTargetEntity->m_transform.m_translate.x;
  ATanOfXY = CGeneral::GetATanOfXY(*p_tx - *p_x, p_tx[1] - p_x[1]);
  v9 = pVeh->AutoPilot.pTargetEntity;
  v10 = (float32x2_t *)p_m_transform;
  v11 = pVeh->m_pMat;
  v12 = v9->m_pMat;
  if ( v11 )
    v10 = (float32x2_t *)&v11->tx;
  v13 = (float32x2_t *)&v12->tx;
  if ( !v12 )
    v13 = (float32x2_t *)&v9->m_transform;
  v14.n64_u64[0] = vsub_f32((float32x2_t)v13->n64_u64[0], (float32x2_t)v10->n64_u64[0]).n64_u64[0];
  v15 = vmul_f32(v14, v14).n64_u64[0];
  v16 = sqrtf(*(float *)&v15 + *((float *)&v15 + 1));
  if ( v16 <= (float)((float)pVeh->AutoPilot.HooverDistFromTarget + (float)pVeh->AutoPilot.HooverDistFromTarget) )
  {
    for ( i = (float)(ATanOfXY + 1.5708) - CGeneral::GetATanOfXY(v11->xy, v11->yy); i > 3.1416; i = i + -6.2832 )
      ;
    for ( ; i < -3.1416; i = i + 6.2832 )
      ;
    v18 = 1.0;
    v19 = &pVeh[1].m_transform.m_translate.x;
    p_m_heading = &pVeh[1].m_transform.m_heading;
    v21 = 1.0;
    if ( i > 1.0 )
      v21 = -1.0;
    v22 = 1.0;
    if ( i > -1.0 )
      v22 = v21;
    v23 = v22;
    if ( i > -1.0 )
      v23 = -i;
    if ( i > 1.0 )
      v23 = v22;
    v24 = pVeh->AutoPilot.pTargetEntity;
    *v19 = -i;
    *v19 = v23;
    v25 = &v24->m_transform;
    v26 = v24->m_pMat;
    v27 = &v24->m_transform;
    if ( v26 )
      v27 = (CSimpleTransform *)&v26->tx;
    v28 = v27->m_translate.z + 15.0;
    *(float *)&pVeh[1].m_nFlags.bdummy = v28;
    v29 = v24->m_pMat;
    v30 = pVeh->m_pMat;
    if ( v29 )
      v25 = (CSimpleTransform *)&v29->tx;
    v31 = pVeh->m_vecMoveSpeed.z * 100.0;
    v32 = *(_QWORD *)&v25->m_translate.x;
    pVeh->AutoPilot.TargetCoors.z = v25->m_translate.z;
    *(float *)&pVeh[1].RandomSeed = v28;
    *(_QWORD *)&pVeh->AutoPilot.TargetCoors.x = v32;
    if ( v30 )
      p_m_transform = (CSimpleTransform *)&v30->tx;
    v33 = 5.0;
    v34 = v28 - (float)(p_m_transform->m_translate.z + v31);
    if ( v34 > 0.0 )
      v33 = 10.0;
    *p_m_heading = (float)(v34 / v33) + 0.3;
    v35 = (rand() & 0xF) - 7;
    v36 = *p_m_heading + (float)((float)v35 * 0.002);
    v37 = 1.0;
    if ( v36 < 0.0 )
      v37 = 0.0;
    if ( v36 < 1.0 )
      v18 = v37;
    v38 = 0.5;
    v39 = v18;
    if ( v36 < 1.0 )
      v39 = *p_m_heading + (float)((float)v35 * 0.002);
    HooverDistFromTarget = (float)pVeh->AutoPilot.HooverDistFromTarget;
    if ( v36 < 0.0 )
      v39 = v18;
    *p_m_heading = v39;
    if ( v16 >= (float)(HooverDistFromTarget * 0.5) )
    {
      if ( v16 <= HooverDistFromTarget )
        v38 = (float)((float)(pVeh->m_vecMoveSpeed.x * pVeh->m_pMat->xx)
                    + (float)(pVeh->m_vecMoveSpeed.y * pVeh->m_pMat->yx))
            + (float)(pVeh->m_vecMoveSpeed.z * pVeh->m_pMat->zx);
      else
        v38 = -0.5;
    }
    pVeh[1].m_transform.m_translate.y = 0.0;
    pVeh[1].m_transform.m_translate.z = v38;
    if ( v16 < (float)(HooverDistFromTarget * 1.5) )
      pVeh[1].m_transform.m_translate.y = (float)((float)(pVeh->m_vecMoveSpeed.x * pVeh->m_pMat->xy)
                                                + (float)(pVeh->m_vecMoveSpeed.y * pVeh->m_pMat->yy))
                                        + (float)(pVeh->m_vecMoveSpeed.z * pVeh->m_pMat->zy);
  }
  else
  {
    CCarCtrl::SteerAIHeliToFollowEntity(pVeh);
  }
}

//----- (002F75DC) --------------------------------------------------------
void __fastcall CCarCtrl::GetAIPlaneToDoDogFight(CAutomobile *pVeh)
{
  CEntity *pTargetEntity; // r4
  CMatrix *m_pMat; // r1
  float *p_tx; // r0
  CMatrix *v5; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *v7; // r1
  float ATanOfXY; // r0
  CMatrix *v9; // r1
  float32x2_t v10; // d16
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s0
  float v14; // s6
  float v15; // s2
  float v16; // s8
  float v17; // s10
  CMatrix *v18; // r0
  CSimpleTransform *v19; // r1
  float v20; // s20

  pTargetEntity = pVeh->AutoPilot.pTargetEntity;
  m_pMat = pTargetEntity->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pTargetEntity->m_transform.m_translate.x;
  if ( pVeh->AutoPilot.Diversion == 1 )
  {
    v5 = pVeh->m_pMat;
    p_m_transform = &pVeh->m_transform;
    v7 = &pVeh->m_transform;
    if ( v5 )
      v7 = (CSimpleTransform *)&v5->tx;
    ATanOfXY = CGeneral::GetATanOfXY(
                 pVeh->AutoPilot.TargetCoors.x - v7->m_translate.x,
                 pVeh->AutoPilot.TargetCoors.y - v7->m_translate.y);
    v9 = pVeh->m_pMat;
    v10.n64_u64[0] = *(unsigned __int64 *)&pVeh->AutoPilot.TargetCoors.x;
    *(float *)&pVeh[1].m_pLastRenderedLink = ATanOfXY;
    pVeh[1].m_nFlags.bdummy = LODWORD(pVeh->AutoPilot.TargetCoors.z);
    if ( v9 )
      p_m_transform = (CSimpleTransform *)&v9->tx;
    v11.n64_u64[0] = vsub_f32(v10, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
    v12 = vmul_f32(v11, v11).n64_u64[0];
    if ( sqrtf(*(float *)&v12 + *((float *)&v12 + 1)) < 50.0 )
      pVeh->AutoPilot.Diversion = 0;
  }
  else
  {
    v13 = pTargetEntity[1].m_transform.m_translate.z * 50.0;
    v14 = *p_tx;
    v15 = pTargetEntity[1].m_transform.m_heading * 50.0;
    v16 = p_tx[1];
    v17 = p_tx[2];
    v18 = pVeh->m_pMat;
    v19 = (CSimpleTransform *)&v18->tx;
    if ( !v18 )
      v19 = &pVeh->m_transform;
    v20 = (float)(*(float *)&pTargetEntity[1].m_pMat * 50.0) + v17;
    *(float *)&pVeh[1].m_pLastRenderedLink = CGeneral::GetATanOfXY(
                                               (float)(v13 + v14) - v19->m_translate.x,
                                               (float)(v15 + v16) - v19->m_translate.y);
    *(float *)&pVeh[1].m_nFlags.bdummy = v20;
    if ( (rand() & 0x3FF) == 500 )
    {
      pVeh->AutoPilot.Diversion = 1;
      pVeh->AutoPilot.TargetCoors.x = (float)(v13 + v14)
                                    + (float)((float)((float)((float)rand() * 4.6566e-10) * 600.0) + -300.0);
      pVeh->AutoPilot.TargetCoors.y = (float)(v15 + v16)
                                    + (float)((float)((float)((float)rand() * 4.6566e-10) * 600.0) + -300.0);
      pVeh->AutoPilot.TargetCoors.z = v20 + 50.0;
    }
  }
  CCarCtrl::FlyAIPlaneInCertainDirection((CPlane *)pVeh);
  CCarCtrl::TestWhetherToFirePlaneGuns(pVeh, pTargetEntity);
  CCarCtrl::PossiblyFireHSMissile(pVeh, pTargetEntity);
}

//----- (002F7778) --------------------------------------------------------
void __fastcall CCarCtrl::GetAIPlaneToDoDogFightAgainstPlayer(CAutomobile *pVeh)
{
  CEntity *PlayerVehicle; // r0

  if ( FindPlayerVehicle(-1, 0) )
    PlayerVehicle = FindPlayerVehicle(-1, 0);
  else
    PlayerVehicle = FindPlayerPed(-1);
  pVeh->AutoPilot.pTargetEntity = PlayerVehicle;
  CCarCtrl::GetAIPlaneToDoDogFight(pVeh);
}

//----- (002F77AC) --------------------------------------------------------
void __fastcall CCarCtrl::SteerPlayerWhilstCruising(
        CVehicle *pVehicle,
        float *pSteerAngle,
        float *pGasPedal,
        float *pBrakePedal,
        bool *a5)
{
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  float32x2_t v7; // d3
  float32x2_t v8; // d4
  float32x2_t v9; // d12
  float32x2_t v10; // d15
  CMatrix *m_pMat; // r0
  float xy; // s0
  float yy; // s26
  float v17; // s2
  float v18; // s19
  unsigned int Address; // r0
  unsigned int v20; // r2
  int InvertDirNewLink; // r8
  float InvertDirOldLink; // s20
  float OldLane; // s16
  CCarPathLink *v24; // r0
  CCarPathLink *v25; // r1
  float DirXb; // s18
  float DirYb; // s22
  int v28; // s24
  float v29; // s28
  float v30; // r0
  int NewLane; // s4
  float v32; // s21
  float v33; // s17
  float v34; // r0
  int v35; // r6
  int v36; // r2
  float v37; // s18
  CCarPathLink *v38; // r1
  CCarPathLink *v39; // r3
  float v40; // s16
  float v41; // s0
  int32 m_vehicleType; // r4
  int CoorsY; // r5
  float v44; // s20
  float CoorsX; // s6
  CSimpleTransform *p_m_transform; // r4
  float v47; // s12
  CSimpleTransform *p_tx; // r0
  CMatrix *v49; // r1
  float v50; // s14
  float v51; // s6
  float v52; // s8
  float v53; // s10
  float v54; // s12
  float32x2_t v55; // d0
  float v56; // s22
  float v57; // s14
  float32x2_t v58; // d14
  float v59; // s2
  float v60; // s4
  CEntity *v61; // r1
  CMatrix *v62; // r0
  __int64 *v63; // r3
  unsigned int v64; // r0
  float v65; // s2
  float v66; // s0
  CCarPathLink *v67; // r2
  CSimpleTransform *v68; // r0
  float v69; // s0
  float v70; // s4
  float v71; // s6
  CCarPathLink *v72; // r0
  float v73; // s0
  float v74; // s10
  int v75; // r2
  int v76; // r6
  CCarPathLink *v77; // r0
  int v78; // r3
  int v79; // s2
  CSimpleTransform *v80; // r0
  float v81; // s2
  float v82; // s4
  float v83; // s6
  float ATanOfXY; // r6
  float AngleToWeaveThroughTraffic; // s24
  float v86; // r3
  unsigned int DrivingMode; // r0
  float v88; // s26
  float x; // s17
  float z; // s23
  CMatrix *v91; // r0
  float v92; // s0
  bool v93; // cc
  unsigned int v94; // r0
  float32x2_t v95; // d1
  Int8 v96; // r1
  float MaximumSpeedForThisCarInTraffic; // r0
  int v98; // r5
  float v99; // s2
  UInt16 v100; // r1
  CCarPathLink *v101; // r0
  int v102; // r1
  int v103; // r2
  CCarPathLink *v104; // r0
  CSimpleTransform *v105; // r1
  float v106; // s4
  CMatrix *v107; // r0
  float v108; // s17
  float v109; // r6
  float v110; // s26
  float v111; // s18
  float v112; // r0
  bool *v113; // r2
  float *v114; // r3
  unsigned __int32 i; // s0
  float v116; // s2
  float v117; // s8
  unsigned int CruiseSpeed; // s4
  float32x2_t v119; // d3
  int v120; // r0
  bool v121; // zf
  CMatrix *v122; // r0
  float y; // s4
  float v124; // s2
  float v125; // s6
  Int8 v126; // r0
  __int64 v127; // r2
  Int8 v128; // r0
  CEntity *pTargetEntity; // r0
  Int8 v130; // r1
  CMatrix *v131; // r1
  float v132; // [sp+14h] [bp-9Ch]
  float32x2_t v133; // [sp+18h] [bp-98h]
  float v134; // [sp+24h] [bp-8Ch]
  float v135; // [sp+28h] [bp-88h]
  float zy; // [sp+2Ch] [bp-84h]
  float32x2_t v137; // [sp+30h] [bp-80h]
  float32x2_t v138; // [sp+38h] [bp-78h]
  CVector v140; // [sp+44h] [bp-6Ch] BYREF

  m_pMat = pVehicle->m_pMat;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  v17 = sqrtf((float)(xy * xy) + (float)(yy * yy));
  if ( v17 == 0.0 )
  {
    v18 = 1.0;
  }
  else
  {
    yy = yy / v17;
    v18 = xy / v17;
  }
  Address = pVehicle->AutoPilot.OldLink.Address;
  if ( !ThePaths.pNodes[Address >> 10] || (v20 = pVehicle->AutoPilot.NewLink.Address, !ThePaths.pNodes[v20 >> 10]) )
  {
    *pBrakePedal = 1.0;
    *pGasPedal = 0.0;
    *pSteerAngle = 0.0;
    *a5 = 0;
    return;
  }
  InvertDirNewLink = pVehicle->AutoPilot.InvertDirNewLink;
  InvertDirOldLink = (float)pVehicle->AutoPilot.InvertDirOldLink;
  OldLane = (float)pVehicle->AutoPilot.OldLane;
  v24 = &ThePaths.pLinks[Address >> 10][Address & 0x3FF];
  v25 = &ThePaths.pLinks[v20 >> 10][v20 & 0x3FF];
  DirXb = (float)v24->DirXb;
  DirYb = (float)v24->DirYb;
  v28 = v25->DirXb;
  v29 = (float)v25->DirYb;
  v30 = CCarPathLink::OneWayLaneOffset(v24);
  NewLane = pVehicle->AutoPilot.NewLane;
  v32 = (float)InvertDirNewLink;
  v33 = (float)(v30 + OldLane) * 5.4;
  v34 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF]);
  v35 = pVehicle->AutoPilot.OldLink.Address;
  v36 = pVehicle->AutoPilot.NewLink.Address;
  v37 = (float)(DirXb * 0.01) * InvertDirOldLink;
  v38 = ThePaths.pLinks[(unsigned __int16)v35 >> 10];
  v39 = ThePaths.pLinks[(unsigned __int16)v36 >> 10];
  v40 = 0.125;
  v41 = (float)(v34 + (float)NewLane) * 5.4;
  m_vehicleType = pVehicle->m_vehicleType;
  CoorsY = v38[pVehicle->AutoPilot.OldLink.Address & 0x3FF].CoorsY;
  v44 = (float)(DirYb * 0.01) * InvertDirOldLink;
  if ( m_vehicleType == 10 )
    v33 = v33 + 1.458;
  CoorsX = (float)v38[pVehicle->AutoPilot.OldLink.Address & 0x3FF].CoorsX;
  v121 = m_vehicleType == 10;
  p_m_transform = &pVehicle->m_transform;
  v47 = v44 * v33;
  p_tx = &pVehicle->m_transform;
  if ( v121 )
    v41 = v41 + 1.458;
  v49 = pVehicle->m_pMat;
  v50 = CoorsX * 0.125;
  if ( v49 )
    p_tx = (CSimpleTransform *)&v49->tx;
  v51 = (float)((float)CoorsY * 0.125) - (float)(v37 * v33);
  v52 = v47 + v50;
  v53 = p_tx->m_translate.y - v51;
  v54 = p_tx->m_translate.x - (float)(v47 + v50);
  v55.n64_f32[1] = v54 * v54;
  v56 = sqrtf((float)(v54 * v54) + (float)(v53 * v53));
  if ( v56 >= 5.0 )
  {
    v57 = v29 * 0.01;
    v58.n64_f32[0] = (float)((float)v28 * 0.01) * v32;
    v55.n64_f32[1] = v57 * v32;
    v59 = (float)((float)((float)v39[pVehicle->AutoPilot.NewLink.Address & 0x3FF].CoorsY * 0.125)
                - (float)(v58.n64_f32[0] * v41))
        - v51;
    v60 = (float)((float)((float)(v57 * v32) * v41)
                + (float)((float)v39[pVehicle->AutoPilot.NewLink.Address & 0x3FF].CoorsX * 0.125))
        - v52;
    v55.n64_f32[0] = (float)(v60 * v54) + (float)(v59 * v53);
    if ( (v55.n64_f32[0] <= 0.0 || v56 >= 8.0)
      && (float)(v55.n64_f32[0] / (float)(v56 * sqrtf((float)(v60 * v60) + (float)(v59 * v59)))) <= 0.7
      && v36 != v35 )
    {
      v132 = v57 * v32;
LABEL_29:
      v75 = (unsigned __int16)v35 >> 10;
      v76 = v35 & 0x3FF;
      v77 = ThePaths.pLinks[v75];
      v78 = v77[v76].CoorsX;
      v79 = v77[v76].CoorsY;
      v80 = &pVehicle->m_transform;
      v81 = (float)((float)v79 * 0.125) - (float)(v33 * v37);
      v82 = (float)((float)(v33 * v44) + (float)((float)v78 * 0.125)) - (float)((float)(v37 * v56) * 0.35);
      v83 = v81 - (float)((float)(v44 * v56) * 0.35);
      if ( v56 > 40.0 )
      {
        v82 = (float)(v33 * v44) + (float)((float)v78 * 0.125);
        v83 = v81;
      }
      if ( v49 )
        v80 = (CSimpleTransform *)&v49->tx;
      ATanOfXY = CGeneral::GetATanOfXY(v82 - v80->m_translate.x, v83 - v80->m_translate.y);
      AngleToWeaveThroughTraffic = ATanOfXY;
      v86 = CGeneral::GetATanOfXY(v18, yy);
      DrivingMode = (unsigned __int8)pVehicle->AutoPilot.DrivingMode;
      v88 = v86;
      if ( DrivingMode <= 6 && ((1 << DrivingMode) & 0x64) != 0 )
        AngleToWeaveThroughTraffic = CCarCtrl::FindAngleToWeaveThroughTraffic(pVehicle, 0, ATanOfXY, v86, 1.0);
      for ( v9.n64_f32[0] = AngleToWeaveThroughTraffic - v88;
            v9.n64_f32[0] < -3.1416;
            v9.n64_f32[0] = v9.n64_f32[0] + 6.2832 )
      {
        ;
      }
      for ( ; v9.n64_f32[0] > 3.1416; v9.n64_f32[0] = v9.n64_f32[0] + -6.2832 )
        ;
      x = pVehicle->m_vecMoveSpeed.x;
      v58.n64_u32[1] = LODWORD(pVehicle->m_vecMoveSpeed.y);
      z = pVehicle->m_vecMoveSpeed.z;
      v91 = pVehicle->m_pMat;
      v135 = v91->xy;
      v134 = v91->yy;
      v6.n64_u32[0] = 1060320051;
      zy = v91->zy;
      v92 = sqrtf((float)((float)(x * x) + (float)(v58.n64_f32[1] * v58.n64_f32[1])) + (float)(z * z));
      v93 = v92 <= 0.7;
      v5.n64_f32[0] = 0.9 - v92;
      v55.n64_u32[0] = 1.0;
      if ( !v93 )
        v5.n64_u32[0] = 1045220557;
      v94 = pVehicle->AutoPilot.DrivingMode;
      v95.n64_u64[0] = vmin_f32(v5, v6).n64_u64[0];
      v96 = pVehicle->AutoPilot.DrivingMode;
      v137.n64_u64[0] = v95.n64_u64[0];
      if ( v94 <= 6 && ((1 << v94) & 0x53) != 0 )
      {
        MaximumSpeedForThisCarInTraffic = CCarCtrl::FindMaximumSpeedForThisCarInTraffic(pVehicle);
        v96 = pVehicle->AutoPilot.DrivingMode;
        v55.n64_f32[0] = MaximumSpeedForThisCarInTraffic / (float)pVehicle->AutoPilot.CruiseSpeed;
      }
      v138.n64_u64[0] = v55.n64_u64[0];
      if ( (unsigned int)v96 <= 6 && ((1 << v96) & 0x63) != 0 && CTrafficLights::ShouldCarStopForLight(pVehicle, 0) )
      {
        CCarAI::CarHasReasonToStop(pVehicle);
        v55.n64_u32[0] = 0;
        v138.n64_u64[0] = v55.n64_u64[0];
      }
      v10.n64_f32[0] = -v95.n64_f32[0];
      v133.n64_u64[0] = vmax_f32(v9, v10).n64_u64[0];
      if ( CTrafficLights::ShouldCarStopForBridge(pVehicle) )
      {
        CCarAI::CarHasReasonToStop(pVehicle);
        v55.n64_u32[0] = 0;
        v138.n64_u64[0] = v55.n64_u64[0];
      }
      v98 = pVehicle->AutoPilot.OldLane;
      v99 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[pVehicle->AutoPilot.OldLink.Address >> 10][pVehicle->AutoPilot.OldLink.Address & 0x3FF]);
      v100 = pVehicle->AutoPilot.OldLink.Address;
      v101 = ThePaths.pLinks[v100 >> 10];
      v102 = v100 & 0x3FF;
      v103 = v101[v102].CoorsX;
      v104 = &v101[v102];
      v105 = &pVehicle->m_transform;
      v106 = (float)v104->CoorsY;
      v107 = pVehicle->m_pMat;
      if ( v107 )
        v105 = (CSimpleTransform *)&v107->tx;
      for ( v55.n64_f32[0] = CGeneral::GetATanOfXY(
                               (float)((float)(v44 * (float)((float)(v99 + (float)v98) * 5.4))
                                     + (float)((float)v103 * 0.125))
                             - v105->m_translate.x,
                               (float)((float)(v106 * 0.125) - (float)(v37 * (float)((float)(v99 + (float)v98) * 5.4)))
                             - v105->m_translate.y)
                           - v88; v55.n64_f32[0] < -3.1416; v55.n64_f32[0] = v55.n64_f32[0] + 6.2832 )
        ;
      for ( ; v55.n64_f32[0] > 3.1416; v55.n64_f32[0] = v55.n64_f32[0] + -6.2832 )
        ;
      v108 = (float)(x * v135) + (float)(v58.n64_f32[1] * v134);
      v6.n64_u32[0] = 0;
      v109 = v58.n64_f32[0];
      v58.n64_u32[0] = 1.0;
      v55.n64_f32[0] = fabsf(v55.n64_f32[0]) + -0.4;
      v110 = vmax_f32(v55, v6).n64_f32[0];
      v9.n64_f32[0] = (float)((float)(v110 / 0.8) * -0.6) + 1.0;
      v111 = CGeneral::GetATanOfXY(v37, v44);
      v112 = CGeneral::GetATanOfXY(v109, v132);
      v6.n64_f32[0] = v111 - v112;
      if ( v110 > 0.8 )
        v9.n64_u32[0] = 1053609165;
      if ( (float)(v111 - v112) < -3.1416 )
      {
        v113 = a5;
        v114 = pSteerAngle;
        do
          v6.n64_f32[0] = v6.n64_f32[0] + 6.2832;
        while ( v6.n64_f32[0] < -3.1416 );
      }
      else
      {
        v113 = a5;
        v114 = pSteerAngle;
      }
      for ( i = vmin_f32(v133, v137).n64_u32[0]; v6.n64_f32[0] > 3.1416; v6.n64_f32[0] = v6.n64_f32[0] + -6.2832 )
        ;
      v116 = (float)(v108 + (float)(z * zy)) * 60.0;
      if ( v56 <= 40.0 && pVehicle->AutoPilot.CruiseSpeed >= 0xCu )
      {
        v6.n64_f32[0] = fabsf(v6.n64_f32[0]) + -0.1;
        v7.n64_u32[0] = 0;
        v6.n64_u64[0] = vmax_f32(v6, v7).n64_u64[0];
        v117 = 1.0 - (float)(1.0 - (float)((float)(v6.n64_f32[0] / 1.1) * 0.6));
        if ( v6.n64_f32[0] > 1.1 )
          v117 = 0.6;
        v58.n64_f32[0] = 1.0 - (float)((float)((float)(v56 / -40.0) + 1.0) * v117);
      }
      CruiseSpeed = pVehicle->AutoPilot.CruiseSpeed;
      *pBrakePedal = 0.0;
      v119.n64_u64[0] = vmin_f32(vmin_f32(v9, v58), v138).n64_u64[0];
      v119.n64_f32[0] = v119.n64_f32[0] * (float)CruiseSpeed;
      v6.n64_f32[0] = v119.n64_f32[0] - v116;
      if ( v119.n64_f32[0] >= 0.05 )
      {
        if ( v6.n64_f32[0] <= 0.0 )
        {
          *pGasPedal = 0.0;
          v95.n64_f32[0] = v6.n64_f32[0] / -12.0;
          v6.n64_u32[0] = 0.5;
          *(_DWORD *)pBrakePedal = vmin_f32(v95, v6).n64_u32[0];
        }
        else
        {
          v119.n64_u32[0] = 1.0;
          if ( v116 < 2.0 )
            v40 = 0.25;
          v8.n64_f32[0] = v40 * v6.n64_f32[0];
          *(_DWORD *)pGasPedal = vmin_f32(v8, v119).n64_u32[0];
          if ( v6.n64_f32[0] > 3.0
            && pVehicle->m_vehicleType == 10
            && *(float *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType <= 0.0 )
          {
            *(_DWORD *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[11].EngineSoundType = 1092616192;
          }
        }
      }
      else
      {
        *pBrakePedal = 1.0;
        *pGasPedal = 0.0;
      }
      *(_DWORD *)v114 = i;
      *v113 = 0;
      v120 = (unsigned __int8)pVehicle->AutoPilot.Mission | 4;
      v121 = v120 == 12;
      if ( v120 == 12 )
        v121 = pVehicle->AutoPilot.TempAction == 0;
      if ( v121 )
      {
        v122 = pVehicle->m_pMat;
        if ( v122 )
          p_m_transform = (CSimpleTransform *)&v122->tx;
        y = p_m_transform->m_translate.y;
        v124 = p_m_transform->m_translate.z;
        v125 = sqrtf(
                 (float)((float)((float)(p_m_transform->m_translate.x - pVehicle->AutoPilot.TargetCoors.x)
                               * (float)(p_m_transform->m_translate.x - pVehicle->AutoPilot.TargetCoors.x))
                       + (float)((float)(y - pVehicle->AutoPilot.TargetCoors.y)
                               * (float)(y - pVehicle->AutoPilot.TargetCoors.y)))
               + (float)((float)(v124 - pVehicle->AutoPilot.TargetCoors.z)
                       * (float)(v124 - pVehicle->AutoPilot.TargetCoors.z)));
        if ( v125 < 8.0
          && (float)(fabsf(
                       (float)((float)(p_m_transform->m_translate.x * v122->xy) + (float)(y * v122->yy))
                     + (float)(v124 * v122->zy))
                   / v125) < 0.2 )
        {
          pVehicle->AutoPilot.TempAction = 3;
          pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 2000;
        }
      }
      return;
    }
  }
  if ( !CCarCtrl::PickNextNodeAccordingStrategy(pVehicle) )
  {
LABEL_24:
    v64 = pVehicle->AutoPilot.OldLink.Address;
    if ( !ThePaths.pNodes[v64 >> 10] || !ThePaths.pNodes[pVehicle->AutoPilot.NewLink.Address >> 10] )
    {
      *pBrakePedal = 1.0;
      *pGasPedal = 0.0;
      *pSteerAngle = 0.0;
      *a5 = 0;
      return;
    }
    v35 = pVehicle->AutoPilot.OldLane;
    v65 = CCarPathLink::OneWayLaneOffset(&ThePaths.pLinks[v64 >> 10][v64 & 0x3FF]);
    v66 = (float)v35;
    LOWORD(v35) = pVehicle->AutoPilot.OldLink.Address;
    v67 = &ThePaths.pLinks[(unsigned __int16)v35 >> 10][v35 & 0x3FF];
    v68 = &pVehicle->m_transform;
    v33 = (float)(v65 + v66) * 5.4;
    v49 = pVehicle->m_pMat;
    if ( v49 )
      v68 = (CSimpleTransform *)&v49->tx;
    v69 = (float)((float)v67->CoorsY * 0.125) - (float)(v37 * v33);
    v70 = v68->m_translate.x;
    v71 = v68->m_translate.y;
    v72 = &ThePaths.pLinks[pVehicle->AutoPilot.NewLink.Address >> 10][pVehicle->AutoPilot.NewLink.Address & 0x3FF];
    v56 = sqrtf(
            (float)((float)((float)((float)(v44 * v33) + (float)((float)v67->CoorsX * 0.125)) - v70)
                  * (float)((float)((float)(v44 * v33) + (float)((float)v67->CoorsX * 0.125)) - v70))
          + (float)((float)(v69 - v71) * (float)(v69 - v71)));
    v73 = (float)pVehicle->AutoPilot.InvertDirNewLink;
    v74 = (float)pVehicle->AutoPilot.InvertDirOldLink;
    v58.n64_f32[0] = (float)((float)v72->DirXb * 0.01) * v73;
    v44 = (float)((float)v67->DirYb * 0.01) * v74;
    v37 = (float)((float)v67->DirXb * 0.01) * v74;
    v132 = (float)((float)v72->DirYb * 0.01) * v73;
    goto LABEL_29;
  }
  switch ( pVehicle->AutoPilot.Mission )
  {
    case 2:
      v126 = 3;
      goto LABEL_103;
    case 4:
      v126 = 5;
      goto LABEL_103;
    case 8:
      v127 = *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x;
      v128 = 9;
      goto LABEL_96;
    case 0xC:
      v127 = *(_QWORD *)&pVehicle->AutoPilot.TargetCoors.x;
      v128 = 13;
LABEL_96:
      pVehicle->AutoPilot.Mission = v128;
      goto LABEL_104;
    case 0xF:
      pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
      v130 = 16;
      goto LABEL_99;
    case 0x11:
      pTargetEntity = pVehicle->AutoPilot.pTargetEntity;
      v130 = 18;
LABEL_99:
      pVehicle->AutoPilot.Mission = v130;
      v131 = pTargetEntity->m_pMat;
      v63 = (__int64 *)&v131->tx;
      if ( !v131 )
        v63 = (__int64 *)&pTargetEntity->m_transform;
      goto LABEL_101;
    case 0x2B:
      v126 = 44;
LABEL_103:
      pVehicle->AutoPilot.Mission = v126;
      FindPlayerCoors(&v140, -1);
      v127 = *(_QWORD *)&v140.x;
      goto LABEL_104;
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
      v61 = pVehicle->AutoPilot.pTargetEntity;
      pVehicle->AutoPilot.Mission -= 36;
      v62 = v61->m_pMat;
      v63 = (__int64 *)&v62->tx;
      if ( !v62 )
        v63 = (__int64 *)&v61->m_transform;
LABEL_101:
      v127 = *v63;
LABEL_104:
      CCarCtrl::SteerAICarWithPhysicsHeadingForTarget(
        pVehicle,
        0,
        *(float *)&v127,
        *((float *)&v127 + 1),
        pSteerAngle,
        pGasPedal,
        pBrakePedal,
        a5);
      break;
    default:
      goto LABEL_24;
  }
}
// 2F7E78: variable 'v5' is possibly undefined
// 2F7E78: variable 'v6' is possibly undefined
// 2F7EE2: variable 'v9' is possibly undefined
// 2F7EE2: variable 'v10' is possibly undefined
// 2F8126: variable 'v7' is possibly undefined
// 2F81D6: variable 'v8' is possibly undefined

//----- (002F83B8) --------------------------------------------------------
int __fastcall CCarCtrl::DealWithBend_Racing(
        CVehicle *pVehicle,
        CLinkAddress Link1,
        CLinkAddress Link2,
        CLinkAddress Link3,
        CLinkAddress Link4,
        int InvertDirLink1,
        Int8 InvertDirLink2,
        Int8 InvertDirLink3,
        Int8 InvertDirLink4,
        float Speed,
        float *pTargetOrientation,
        float *pSpeedMultiplierBend,
        float *pBendAngle,
        float *pDistToBend,
        CVector *pInPoint)
{
  int16x4_t v15; // d16
  bool v16; // zf
  int result; // r0
  int *v19; // r8
  int32 m_vehicleType; // r4
  int *v21; // r10
  int *v22; // r6
  int v23; // r0
  int v24; // r5
  int v25; // r12
  CSimpleTransform *p_m_transform; // r1
  CCarPathLink *v27; // lr
  CMatrix *m_pMat; // r0
  int32x4_t v29; // q8
  CCarPathLink *v30; // r5
  float32x2_t v31; // d8
  unsigned __int64 v32; // d0
  CCarPathLink *v34; // r5
  CCarPathLink *v35; // r1
  int16x4_t v36; // d18
  int16x4_t v37; // d17
  unsigned __int64 v38; // d0
  CCarPathLink *v39; // r2
  float32x2_t v40; // d16
  unsigned __int64 v41; // d1
  float DirXb; // s0
  float DirYb; // s2
  float v44; // s4
  int CoorsX; // r4
  int CoorsY; // r5
  float v47; // s0
  float v48; // s2
  __int64 v49; // r0
  float v50; // s18
  int v51; // r9
  int v52; // r11
  float ATanOfXY; // r6
  float v54; // r0
  float v55; // s0
  float v56; // s8
  float v57; // s24
  float i; // s6
  float v59; // s10
  CSimpleTransform *j; // r10
  float v61; // s12
  __int16 *v62; // r4
  int v63; // r5
  float v64; // s20
  float v65; // s30
  float v66; // r8
  __int16 v67; // r11
  float v68; // s26
  float v69; // r9
  unsigned int v70; // r5
  float v71; // s31
  float v72; // s19
  float v73; // s25
  float v74; // r0
  float v75; // s28
  float y; // s26
  float v77; // s0
  float v78; // s25
  float v79; // s27
  float v80; // s2
  float v81; // s0
  float v82; // s4
  float v83; // s4
  int v84; // r5
  float v85; // r8
  __int16 v86; // r4
  float v87; // s19
  float v88; // r11
  unsigned int v89; // r5
  float v90; // s6
  float v91; // s20
  float v92; // s30
  float v93; // s29
  float v94; // s0
  float v95; // s2
  float v96; // s12
  float *v97; // r0
  float *v98; // r1
  float v99; // s14
  float v100; // s4
  float v101; // s0
  float v102; // s2
  float v103; // s0
  float v104; // s6
  float v105; // s2
  float v106; // s12
  bool v107; // cc
  float v108; // s6
  float v109; // s4
  int v110; // s6
  float v111; // s1
  float v112; // s14
  float v113; // s6
  float *p_tx; // r1
  CMatrix *v115; // r0
  float v116; // s0
  float *p_x; // r1
  float v118; // [sp+0h] [bp-98h]
  float v119; // [sp+4h] [bp-94h]
  float v120; // [sp+8h] [bp-90h]
  float v121; // [sp+Ch] [bp-8Ch]
  CVehicle *v122; // [sp+10h] [bp-88h]
  CSimpleTransform *v123; // [sp+14h] [bp-84h]
  CCarPathLink *v124; // [sp+18h] [bp-80h]
  int *v125; // [sp+1Ch] [bp-7Ch]
  float v126; // [sp+1Ch] [bp-7Ch]
  CCarPathLink *v127; // [sp+20h] [bp-78h]
  CCarPathLink *v128; // [sp+20h] [bp-78h]

  v16 = Link1.Address == 0xFFFF;
  if ( Link1.Address != 0xFFFF )
    v16 = Link2.Address == 0xFFFF;
  result = 0;
  if ( !v16 )
  {
    v19 = dword_2F8B84;
    m_vehicleType = pVehicle->m_vehicleType;
    v21 = dword_2F8B8C;
    *pSpeedMultiplierBend = 1.0;
    v22 = dword_2F8B7C;
    if ( m_vehicleType == 10 )
    {
      v22 = &dword_2F8B7C[1];
      v19 = &dword_2F8B84[1];
    }
    if ( m_vehicleType == 10 )
      v21 = &dword_2F8B8C[1];
    v23 = Link1.Address >> 10;
    if ( !ThePaths.pNodes[v23] )
      return 0;
    v24 = Link2.Address >> 10;
    if ( !ThePaths.pNodes[v24] )
      return 0;
    v125 = v22;
    v25 = Link1.Address & 0x3FF;
    p_m_transform = &pVehicle->m_transform;
    v27 = ThePaths.pLinks[v23];
    v15.n64_u32[0] = *(_DWORD *)&v27[v25].CoorsX;
    m_pMat = pVehicle->m_pMat;
    v29 = vmovl_s16(v15);
    if ( m_pMat )
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    v30 = ThePaths.pLinks[v24];
    v31.n64_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)v29.n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
    v29.n128_u64[0] = vsub_f32(v31, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
    v32 = vmul_f32((float32x2_t)v29.n128_u64[0], (float32x2_t)v29.n128_u64[0]).n64_u64[0];
    *(float *)&v32 = sqrtf(*(float *)&v32 + *((float *)&v32 + 1));
    *(_DWORD *)pDistToBend = v32;
    if ( *(float *)&v32 > 60.0 )
      return 0;
    v123 = &pVehicle->m_transform;
    v34 = &v30[Link2.Address & 0x3FF];
    v127 = &v27[v25];
    if ( Link3.Address != 0xFFFF )
    {
      v29.n128_u32[0] = *(_DWORD *)&v34->CoorsX;
      v35 = ThePaths.pLinks[Link3.Address >> 10];
      v36.n64_u64[0] = vmul_f32(
                         vcvt_f32_s32((int32x2_t)vmovl_s16((int16x4_t)v29.n128_u64[0]).n128_u64[0]),
                         (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
      v29.n128_u32[2] = *(_DWORD *)&v35[Link3.Address & 0x3FF].CoorsX;
      v37.n64_u64[0] = vsub_f32(
                         v36,
                         vmul_f32(
                           vcvt_f32_s32((int32x2_t)vmovl_s16(*(int16x4_t *)&v29.n128_i8[8]).n128_u64[0]),
                           (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
      v38 = vmul_f32(v37, v37).n64_u64[0];
      if ( (float)(*(float *)&v38 + *((float *)&v38 + 1)) < 100.0 )
      {
        InvertDirLink2 = InvertDirLink3;
        v34 = &v35[Link3.Address & 0x3FF];
      }
      if ( Link4.Address != 0xFFFF )
      {
        v39 = ThePaths.pLinks[Link4.Address >> 10];
        v37.n64_u32[0] = *(_DWORD *)&v34->CoorsX;
        v36.n64_u32[0] = *(_DWORD *)&v39[Link4.Address & 0x3FF].CoorsX;
        v40.n64_u64[0] = vsub_f32(
                           vmul_f32(
                             vcvt_f32_s32((int32x2_t)vmovl_s16(v37).n128_u64[0]),
                             (float32x2_t)0x3E0000003E000000LL),
                           vmul_f32(
                             vcvt_f32_s32((int32x2_t)vmovl_s16(v36).n128_u64[0]),
                             (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
        v41 = vmul_f32(v40, v40).n64_u64[0];
        if ( (float)(*(float *)&v41 + *((float *)&v41 + 1)) < 100.0 )
        {
          InvertDirLink2 = InvertDirLink4;
          v34 = &v39[Link4.Address & 0x3FF];
        }
      }
    }
    DirXb = (float)v34->DirXb;
    DirYb = (float)v34->DirYb;
    v44 = (float)InvertDirLink2;
    CoorsX = v34->CoorsX;
    v124 = v34;
    CoorsY = v34->CoorsY;
    v47 = DirXb * 0.01;
    v122 = pVehicle;
    v48 = DirYb * 0.01;
    v49 = *(_QWORD *)&pVehicle->m_pMat->xy;
    v50 = v47 * v44;
    v51 = v127->DirXb;
    v52 = v127->DirYb;
    ATanOfXY = CGeneral::GetATanOfXY(*(float *)&v49, *((float *)&v49 + 1));
    v54 = CGeneral::GetATanOfXY(v47 * v44, v48 * v44);
    v55 = (float)CoorsX;
    v56 = (float)CoorsY;
    v57 = ATanOfXY - v54;
    for ( i = (float)InvertDirLink1; v57 > 3.1416; v57 = v57 + -6.2832 )
      ;
    v59 = *(float *)v21;
    for ( j = v123; v57 < -3.1416; v57 = v57 + 6.2832 )
      ;
    v61 = fabsf(v57);
    if ( v61 >= v59
      && ((v62 = (__int16 *)((char *)v127 + 11),
           ((*(unsigned __int16 *)((char *)v124 + 11) >> 3) & 7) + (*(_WORD *)((char *)v124 + 11) & 7u) < 4)
       || v61 >= *(float *)v19
       || (unsigned __int16)((*v62 & 7) + (((unsigned __int16)*v62 >> 3) & 7)) <= 3u) )
    {
      v121 = v48 * v44;
      *pBendAngle = v57;
      v63 = *v62 & 7;
      v64 = (float)((float)v52 * 0.01) * i;
      v65 = (float)((float)v51 * 0.01) * i;
      v66 = CCarPathLink::OneWayLaneOffset(v127);
      v67 = *v62;
      v68 = (float)(unsigned int)v63;
      v69 = CCarPathLink::OneWayLaneOffset(v127);
      v70 = (unsigned __int16)*v62;
      v71 = CCarPathLink::OneWayLaneOffset(v127);
      v72 = v66 + (float)(v68 + -1.0);
      v73 = (float)(((unsigned __int16)*v62 >> 3) & 7) + -1.0;
      v74 = CCarPathLink::OneWayLaneOffset(v127);
      *(float *)&v128 = v64;
      v120 = v65;
      v118 = v55 * 0.125;
      v119 = v56 * 0.125;
      v75 = v31.n64_f32[0] + (float)((float)(v64 * v72) * 5.4);
      y = v31.n64_f32[1] - (float)((float)(v65 * (float)(v69 + (float)((float)(v67 & 7) + -1.0))) * 5.4);
      v78 = v31.n64_f32[1] + (float)((float)(v65 * (float)(v74 + v73)) * 5.4);
      v77 = v78;
      v79 = v31.n64_f32[0] - (float)((float)(v64 * (float)(v71 + (float)((float)((v70 >> 3) & 7) + -1.0))) * 5.4);
      if ( (float)((float)((float)(v75 - v118) * (float)(v75 - v118))
                 + (float)((float)(y - (float)(v56 * 0.125)) * (float)(y - (float)(v56 * 0.125)))) < (float)((float)((float)(v79 - v118) * (float)(v79 - v118)) + (float)((float)(v77 - (float)(v56 * 0.125)) * (float)(v77 - (float)(v56 * 0.125)))) )
      {
        v78 = v31.n64_f32[1] - (float)((float)(v65 * (float)(v69 + (float)((float)(v67 & 7) + -1.0))) * 5.4);
        y = v77;
        v79 = v31.n64_f32[0] + (float)((float)(v64 * v72) * 5.4);
        v75 = v31.n64_f32[0] - (float)((float)(v64 * (float)(v71 + (float)((float)((v70 >> 3) & 7) + -1.0))) * 5.4);
      }
      v80 = y - v78;
      v81 = v75 - v79;
      v82 = sqrtf((float)(v81 * v81) + (float)(v80 * v80));
      if ( v82 > 11.0 )
      {
        v83 = 11.0 / v82;
        y = v78 + (float)(v80 * v83);
        v75 = v79 + (float)(v81 * v83);
      }
      v126 = *(float *)v125;
      v84 = *(_WORD *)((char *)v124 + 11) & 7;
      v85 = CCarPathLink::OneWayLaneOffset(v124);
      v86 = *(_WORD *)((char *)v124 + 11);
      v87 = (float)(unsigned int)v84;
      v88 = CCarPathLink::OneWayLaneOffset(v124);
      v89 = *(unsigned __int16 *)((char *)v124 + 11);
      v90 = v87 + -1.0;
      v91 = CCarPathLink::OneWayLaneOffset(v124);
      v92 = (float)(v86 & 7) + -1.0;
      v93 = (float)((*(unsigned __int16 *)((char *)v124 + 11) >> 3) & 7) + -1.0;
      v94 = v118 - (float)((float)(v121 * (float)(v91 + (float)((float)((v89 >> 3) & 7) + -1.0))) * 5.4);
      v95 = v119 + (float)((float)(v50 * (float)(CCarPathLink::OneWayLaneOffset(v124) + v93)) * 5.4);
      v96 = fabsf(v120 - v50);
      if ( (float)((float)((float)((float)(v118 + (float)((float)(v121 * (float)(v85 + v90)) * 5.4)) - v31.n64_f32[0])
                         * (float)((float)(v118 + (float)((float)(v121 * (float)(v85 + v90)) * 5.4)) - v31.n64_f32[0]))
                 + (float)((float)((float)(v119 - (float)((float)(v50 * (float)(v88 + v92)) * 5.4)) - v31.n64_f32[1])
                         * (float)((float)(v119 - (float)((float)(v50 * (float)(v88 + v92)) * 5.4)) - v31.n64_f32[1]))) < (float)((float)((float)(v94 - v31.n64_f32[0]) * (float)(v94 - v31.n64_f32[0])) + (float)((float)(v95 - v31.n64_f32[1]) * (float)(v95 - v31.n64_f32[1]))) )
      {
        v95 = v119 - (float)((float)(v50 * (float)(v88 + v92)) * 5.4);
        v94 = v118 + (float)((float)(v121 * (float)(v85 + v90)) * 5.4);
      }
      if ( v96 >= 0.1 || fabsf(*(float *)&v128 - v121) == 0.0 )
      {
        v100 = (float)(v120 * v121) - (float)(*(float *)&v128 * v50);
        if ( v100 == 0.0 )
          v101 = 0.0;
        else
          v101 = (float)((float)(v121 * (float)(v94 - v79)) - (float)(v50 * (float)(v95 - v78))) / v100;
        v97 = pSpeedMultiplierBend;
        v98 = pDistToBend;
        v99 = v126;
        pInPoint->x = v79 + (float)(v120 * v101);
        pInPoint->y = v78 + (float)(*(float *)&v128 * v101);
      }
      else
      {
        pInPoint->x = v79;
        pInPoint->y = v78;
        v97 = pSpeedMultiplierBend;
        v98 = pDistToBend;
        v99 = v126;
      }
      v102 = *v98;
      v103 = (float)(v57 + v57) / 3.1416;
      if ( *v98 >= v99 )
      {
        v108 = -v103;
      }
      else
      {
        v104 = fabsf(v103);
        v105 = v99 - v102;
        v106 = v104 * 0.6;
        v107 = v104 <= 1.0;
        v108 = -v103;
        if ( !v107 )
          v106 = 0.6;
        *v97 = 1.0 - (float)((float)(v106 * v105) / v99);
        v102 = *v98;
      }
      v109 = Speed / 30.0;
      if ( v103 < 0.0 )
        v103 = v108;
      v110 = 1045220557;
      v111 = Speed / 30.0;
      v112 = 1.0;
      if ( v109 > 1.0 )
        v110 = 1.0;
      if ( v109 < 0.2 )
        v112 = *(float *)&v110;
      v113 = v103 * 20.0;
      if ( v109 > 1.0 )
        v111 = v112;
      if ( v103 > 1.0 )
        v113 = 20.0;
      if ( v109 < 0.2 )
        v111 = v112;
      if ( v102 >= (float)(v111 * v113) )
      {
        p_x = &v123->m_translate.x;
        v115 = v122->m_pMat;
        if ( v115 )
          p_x = &v115->tx;
        v116 = v75 - *p_x;
      }
      else
      {
        p_tx = &v123->m_translate.x;
        y = pInPoint->y;
        v115 = v122->m_pMat;
        if ( v115 )
          p_tx = &v115->tx;
        v116 = pInPoint->x - *p_tx;
      }
      if ( v115 )
        j = (CSimpleTransform *)&v115->tx;
      *pTargetOrientation = CGeneral::GetATanOfXY(v116, y - j->m_translate.y);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 2F847A: variable 'v15' is possibly undefined
// 2F8B7C: using guessed type int dword_2F8B7C[2];
// 2F8B84: using guessed type int dword_2F8B84[2];
// 2F8B8C: using guessed type int dword_2F8B8C[2];

//----- (002F8BB8) --------------------------------------------------------
void __fastcall CCarCtrl::ClipTargetOrientationToLink(
        CVehicle *pVehicle,
        CLinkAddress Link,
        int InvertDirLink,
        float *pTargetOrientation,
        float LinkCoorsX,
        float LinkCoorsY)
{
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  int v10; // r3
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r11
  int v14; // r1
  CSimpleTransform *p_tx; // r2
  CCarPathLink *v16; // r6
  int DirXb; // r5
  int DirYb; // r4
  unsigned int v19; // r1
  bool v20; // zf
  unsigned int v21; // r0
  int v22; // r1
  float v23; // s22
  float v24; // s20
  unsigned __int8 v25; // r2
  float v26; // s24
  float v27; // s0
  float v28; // s0
  CSimpleTransform *v29; // r1
  float v30; // s0
  CMatrix *v31; // r0
  float ATanOfXY; // r0
  CMatrix *v33; // r1
  float v34; // s16
  float v35; // r0
  float i; // s0
  unsigned __int32 v37; // s2

  v10 = Link.Address >> 10;
  if ( !ThePaths.pNodes[v10] )
    return;
  m_pMat = pVehicle->m_pMat;
  p_m_transform = &pVehicle->m_transform;
  v14 = Link.Address & 0x3FF;
  p_tx = &pVehicle->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v16 = &ThePaths.pLinks[v10][v14];
  DirXb = v16->DirXb;
  DirYb = v16->DirYb;
  CGeneral::GetATanOfXY(LinkCoorsX - p_tx->m_translate.x, LinkCoorsY - p_tx->m_translate.y);
  v19 = *(unsigned __int16 *)((char *)v16 + 11);
  LOBYTE(v21) = v19 & 7;
  v20 = (v19 & 7) == 0;
  v22 = (v19 >> 3) & 7;
  v23 = (float)((float)DirYb * 0.01) * (float)InvertDirLink;
  v24 = (float)((float)DirXb * 0.01) * (float)InvertDirLink;
  if ( v20 )
  {
    v28 = 0.5;
    v21 = (unsigned __int8)v22;
  }
  else
  {
    if ( v22 )
    {
      v25 = v22;
      if ( !InvertDirLink )
        v25 = v21;
      if ( !InvertDirLink )
        LOBYTE(v21) = v22;
      v26 = (float)(unsigned __int8)v21;
      v27 = (float)((float)v16->Width / 86.4) + (float)v25;
      goto LABEL_14;
    }
    v28 = 0.5;
    v21 = (unsigned __int8)v21;
  }
  v26 = (float)v21 * v28;
  v27 = v26;
LABEL_14:
  v29 = &pVehicle->m_transform;
  v30 = v27 + -0.3;
  v31 = pVehicle->m_pMat;
  if ( v31 )
    v29 = (CSimpleTransform *)&v31->tx;
  ATanOfXY = CGeneral::GetATanOfXY(
               (float)((float)((float)(v23 * v30) * 5.4) + LinkCoorsX) - v29->m_translate.x,
               (float)(LinkCoorsY - (float)((float)(v24 * v30) * 5.4)) - v29->m_translate.y);
  v33 = pVehicle->m_pMat;
  if ( v33 )
    p_m_transform = (CSimpleTransform *)&v33->tx;
  v34 = ATanOfXY;
  v35 = CGeneral::GetATanOfXY(
          (float)(LinkCoorsX - (float)((float)(v23 * (float)(v26 + -0.3)) * 5.4)) - p_m_transform->m_translate.x,
          (float)((float)((float)(v24 * (float)(v26 + -0.3)) * 5.4) + LinkCoorsY) - p_m_transform->m_translate.y);
  i = *pTargetOrientation;
  for ( v6.n64_f32[0] = v34 - *pTargetOrientation; v6.n64_f32[0] > 3.1416; v6.n64_f32[0] = v6.n64_f32[0] + -6.2832 )
    ;
  for ( v7.n64_f32[0] = v35 - i; v6.n64_f32[0] < -3.1416; v6.n64_f32[0] = v6.n64_f32[0] + 6.2832 )
    ;
  for ( ; v7.n64_f32[0] > 3.1416; v7.n64_f32[0] = v7.n64_f32[0] + -6.2832 )
    ;
  for ( ; v7.n64_f32[0] < -3.1416; v7.n64_f32[0] = v7.n64_f32[0] + 6.2832 )
    ;
  if ( v6.n64_f32[0] >= 0.0 )
  {
    if ( v6.n64_f32[0] <= 0.0 )
      goto LABEL_33;
    v37 = vmin_f32(v6, v7).n64_u32[0];
  }
  else
  {
    v37 = vmax_f32(v6, v7).n64_u32[0];
  }
  for ( i = i + *(float *)&v37; ; i = i + 6.2832 )
  {
    *pTargetOrientation = i;
LABEL_33:
    if ( i >= 0.0 )
      break;
  }
  if ( i > 6.2832 )
  {
    do
      i = i + -6.2832;
    while ( i > 6.2832 );
    *pTargetOrientation = i;
  }
}
// 2F8E06: variable 'v6' is possibly undefined
// 2F8E06: variable 'v7' is possibly undefined

//----- (002F8E94) --------------------------------------------------------
float __fastcall CCarCtrl::FindPercDependingOnDistToLink(CVehicle *pVehicle, CLinkAddress Link)
{
  int16x4_t v2; // d16
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  int32x2_t v5; // d16
  float32x2_t v6; // d16
  unsigned __int64 v7; // d0
  float v8; // s0

  v2.n64_u32[0] = *(_DWORD *)&ThePaths.pLinks[Link.Address >> 10][Link.Address & 0x3FF].CoorsX;
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  v5.n64_u64[0] = vmovl_s16(v2).n128_u64[0];
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  v6.n64_u64[0] = vsub_f32(
                    vmul_f32(vcvt_f32_s32(v5), (float32x2_t)0x3E0000003E000000LL),
                    *(float32x2_t *)&p_tx->m_translate.x).n64_u64[0];
  v7 = vmul_f32(v6, v6).n64_u64[0];
  v8 = sqrtf(*(float *)&v7 + *((float *)&v7 + 1));
  if ( v8 < 5.0 )
    return 0.5;
  if ( v8 >= 15.0 )
    return 1.0;
  return (float)((float)((float)(v8 + -5.0) * 0.5) / 10.0) + 0.5;
}
// 2F8ECC: variable 'v2' is possibly undefined

//----- (002F8F3C) --------------------------------------------------------
void __fastcall CCarCtrl::FindIntersection2Lines(
        float Center1X,
        float Center1Y,
        float Dir1X,
        float Dir1Y,
        float Center2X,
        float Center2Y,
        float Dir2X,
        float Dir2Y,
        float *pResultX,
        float *pResultY)
{
  float v10; // s12
  float v11; // s8

  v10 = (float)(Dir1X * Dir2Y) - (float)(Dir1Y * Dir2X);
  if ( v10 == 0.0 )
    v11 = 0.0;
  else
    v11 = (float)((float)((float)(Center2X - Center1X) * Dir2Y) - (float)((float)(Center2Y - Center1Y) * Dir2X)) / v10;
  *pResultX = (float)(v11 * Dir1X) + Center1X;
  *pResultY = (float)(v11 * Dir1Y) + Center1Y;
}

//----- (002F8FB4) --------------------------------------------------------
bool __fastcall FindHeightForVerticalAngle(CPlane *pPlane, float Angle, float Orientation, float *pResult)
{
  float v7; // s4
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float y; // s8
  RwReal v11; // s18
  RwReal v12; // s20
  bool v13; // r5
  float v14; // r4
  float v15; // r0
  CVector vecEnd; // [sp+24h] [bp-7Ch] BYREF
  CVector v18; // [sp+30h] [bp-70h] BYREF
  CVector vecStart; // [sp+3Ch] [bp-64h] BYREF
  CEntity *refEntityPtr; // [sp+48h] [bp-58h] BYREF
  CColPoint colPoint; // [sp+4Ch] [bp-54h] BYREF

  v7 = pPlane->m_vecMoveSpeed.y * 50.0;
  m_pMat = pPlane->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPlane->m_transform;
  y = p_tx->m_translate.y;
  v11 = (float)(pPlane->m_vecMoveSpeed.x * 50.0) + p_tx->m_translate.x;
  v12 = (float)(pPlane->m_vecMoveSpeed.z * 50.0) + p_tx->m_translate.z;
  vecStart.y = v7 + y;
  vecStart.x = v11;
  vecStart.z = v12;
  v18.y = sinf(Orientation);
  v18.x = cosf(Orientation);
  v13 = 0;
  v18.z = 0.0;
  CVector::Normalise(&v18);
  v14 = cosf(Angle);
  v15 = sinf(Angle);
  vecEnd.y = (float)(v7 + y) + (float)((float)((float)(v14 * v18.y) + (float)(v15 * 0.0)) * 200.0);
  vecEnd.x = v11 + (float)((float)((float)(v14 * v18.x) + (float)(v15 * 0.0)) * 200.0);
  vecEnd.z = (float)((float)((float)(v14 * v18.z) + v15) * 200.0) + v12;
  if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) == 1 )
  {
    *pResult = colPoint.m_vecPosition.z;
    return 1;
  }
  return v13;
}

//----- (002F90DC) --------------------------------------------------------
float __fastcall FindFlightHeight(CPlane *pPlane, float Orientation)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d8
  _BOOL4 HeightForVerticalAngle; // r0
  float v8; // r1
  _BOOL4 v9; // r0
  float v10; // r1
  _BOOL4 v11; // r0
  float v12; // r1
  float pResult[5]; // [sp+4h] [bp-14h] BYREF

  if ( FindHeightForVerticalAngle(pPlane, 0.10472, Orientation, pResult) )
  {
    v4.n64_u32[0] = 1203982336;
  }
  else
  {
    if ( FindHeightForVerticalAngle(pPlane, 0.05236, Orientation, pResult) )
    {
      v2.n64_u32[0] = 0;
      v3.n64_f32[0] = pResult[0];
      v4.n64_u64[0] = vmax_f32(v3, v2).n64_u64[0];
    }
    else
    {
      v4.n64_u32[0] = 0;
    }
    HeightForVerticalAngle = FindHeightForVerticalAngle(pPlane, 0.0, Orientation, pResult);
    LOWORD(v8) = -18237;
    if ( HeightForVerticalAngle )
    {
      v2.n64_f32[0] = pResult[0];
      v4.n64_u64[0] = vmax_f32(v4, v2).n64_u64[0];
    }
    HIWORD(v8) = -16718;
    v9 = FindHeightForVerticalAngle(pPlane, v8, Orientation, pResult);
    LOWORD(v10) = -18237;
    if ( v9 )
    {
      v2.n64_f32[0] = pResult[0];
      v4.n64_u64[0] = vmax_f32(v4, v2).n64_u64[0];
    }
    HIWORD(v10) = -16590;
    v11 = FindHeightForVerticalAngle(pPlane, v10, Orientation, pResult);
    LOWORD(v12) = 2706;
    if ( v11 )
    {
      v2.n64_f32[0] = pResult[0];
      v4.n64_u64[0] = vmax_f32(v4, v2).n64_u64[0];
    }
    HIWORD(v12) = -16506;
    if ( FindHeightForVerticalAngle(pPlane, v12, Orientation, pResult) )
    {
      v2.n64_f32[0] = pResult[0];
      v4.n64_u32[0] = vmax_f32(v4, v2).n64_u32[0];
    }
  }
  return v4.n64_f32[0];
}
// 2F911E: variable 'v3' is possibly undefined
// 2F911E: variable 'v2' is possibly undefined
// 2F9142: variable 'v4' is possibly undefined

//----- (002F91B0) --------------------------------------------------------
void __fastcall CCarCtrl::FlyAIPlaneInCertainDirection(CPlane *pPlane)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d8
  float32x2_t v6; // d10
  float ATanOfXY; // r0
  float *p_m_FlightDirection; // r11
  int TempAction; // r1
  float m_FlightDirection; // s2
  float v12; // s16
  float v13; // s4
  float v14; // s0
  float *p_m_FlightDirectionAvoidingTerrain; // r10
  float v16; // s18
  unsigned int v17; // r0
  int v18; // r9
  int v19; // s0
  int *v20; // r0
  float v21; // s0
  float v22; // s22
  unsigned int v23; // r0
  int v24; // r6
  bool v25; // zf
  int v26; // s0
  int *v27; // r0
  float v28; // s0
  float v29; // s22
  int v30; // r6
  float v31; // r0
  CMatrix *m_pMat; // r5
  float v33; // s22
  float v34; // s0
  UInt32 m_OnGroundTimer; // r1
  uint32 v36; // r2
  float v37; // s18
  float v38; // s28
  CSimpleTransform *p_tx; // r1
  float z; // s2
  float v41; // r0
  float32x2_t v42; // d16
  float v43; // s2
  int v44; // r0
  int *v45; // r0
  float32x2_t v46; // d0
  float *p_m_fPitchControl; // r0
  float32x2_t v48; // d1
  float v49; // s4
  float v50; // s28
  float v51; // s0
  float v52; // s0
  float i; // s2
  float v54; // s8
  float32x2_t v55; // d5
  bool v56; // cc
  int v57; // r1
  float *p_m_MinHeightAboveTerrain; // [sp+0h] [bp-60h]
  float *p_m_LowestFlightHeight; // [sp+4h] [bp-5Ch]

  if ( (CTimer::m_snTimeInMilliseconds + pPlane->RandomSeed) % 0x3E8 >= (CTimer::m_snPreviousTimeInMilliseconds
                                                                       + pPlane->RandomSeed)
                                                                      % 0x3E8 )
    goto LABEL_36;
  ATanOfXY = CGeneral::GetATanOfXY(pPlane->m_pMat->xy, pPlane->m_pMat->yy);
  p_m_FlightDirection = &pPlane->m_FlightDirection;
  TempAction = pPlane->AutoPilot.TempAction;
  m_FlightDirection = pPlane->m_FlightDirection;
  if ( TempAction == 18 )
  {
    v13 = 2.0;
LABEL_9:
    v12 = ATanOfXY + v13;
    goto LABEL_10;
  }
  if ( TempAction == 17 )
  {
    v13 = -2.0;
    goto LABEL_9;
  }
  v12 = pPlane->m_FlightDirection;
  if ( TempAction == 16 )
    v12 = ATanOfXY;
LABEL_10:
  v14 = ATanOfXY - v12;
  p_m_FlightDirectionAvoidingTerrain = &pPlane->m_FlightDirectionAvoidingTerrain;
  pPlane->m_DesiredHeight = 500.0;
  for ( pPlane->m_FlightDirectionAvoidingTerrain = m_FlightDirection + 3.1416; v14 > 3.1416; v14 = v14 + -6.2832 )
    ;
  for ( ; v14 < -3.1416; v14 = v14 + 6.2832 )
    ;
  v16 = v14 * 1.5;
  if ( fabsf(v14) < 0.5236 )
    v16 = 0.0;
  p_m_LowestFlightHeight = &pPlane->m_LowestFlightHeight;
  p_m_MinHeightAboveTerrain = &pPlane->m_MinHeightAboveTerrain;
  v17 = 1;
  while ( 1 )
  {
    v18 = v17;
    v19 = v17 >> 1;
    v20 = dword_2F9858;
    v21 = (float)v19;
    if ( (v18 & 1) == 0 )
      v20 = &dword_2F9858[1];
    if ( (v22 = *(float *)v20 * v21, v22 < 0.0) && v22 > v16 || v22 > 0.0 && v22 < v16 )
    {
      v1.n64_u32[0] = FindFlightHeight(pPlane, v12 + v22);
      if ( v1.n64_f32[0] < 150.0 )
        break;
    }
    v17 = v18 + 1;
    if ( v18 >= 19 )
      goto LABEL_27;
  }
  *p_m_FlightDirectionAvoidingTerrain = (float)(v22 * 1.1) + *p_m_FlightDirection;
  v1.n64_f32[0] = v1.n64_f32[0] + *p_m_MinHeightAboveTerrain;
  v3.n64_f32[0] = *p_m_LowestFlightHeight;
  v1.n64_u64[0] = vmax_f32(v1, v3).n64_u64[0];
  LODWORD(pPlane->m_DesiredHeight) = v1.n64_u32[0];
LABEL_27:
  v23 = 1;
  while ( 1 )
  {
    v24 = v23;
    v25 = (v23 & 1) == 0;
    v26 = v23 >> 1;
    v27 = dword_2F9858;
    v28 = (float)v26;
    if ( v25 )
      v27 = &dword_2F9858[1];
    v29 = *(float *)v27 * v28;
    if ( (v29 >= 0.0 || v29 <= v16) && (v29 <= 0.0 || v29 >= v16) )
    {
      v1.n64_u32[0] = FindFlightHeight(pPlane, v12 + v29);
      if ( v1.n64_f32[0] < 150.0 )
        break;
    }
    v23 = v24 + 1;
    if ( v24 >= 19 )
      goto LABEL_36;
  }
  *p_m_FlightDirectionAvoidingTerrain = (float)(v29 * 1.1) + *p_m_FlightDirection;
  v1.n64_f32[0] = v1.n64_f32[0] + *p_m_MinHeightAboveTerrain;
  v3.n64_f32[0] = *p_m_LowestFlightHeight;
  v1.n64_u64[0] = vmax_f32(v1, v3).n64_u64[0];
  LODWORD(pPlane->m_DesiredHeight) = v1.n64_u32[0];
LABEL_36:
  v30 = *((_DWORD *)&pPlane->m_nVehicleFlags + 1);
  v31 = CGeneral::GetATanOfXY(pPlane->m_pMat->xy, pPlane->m_pMat->yy);
  m_pMat = pPlane->m_pMat;
  v5.n64_u32[0] = 1.0;
  v33 = 7.0;
  if ( (v30 & 0x80) == 0 )
    v33 = 32.0;
  v34 = (float)(m_pMat->xy * pPlane->m_vecMoveSpeed.x) + (float)(m_pMat->yy * pPlane->m_vecMoveSpeed.y);
  if ( pPlane->m_aWheelRatios[0] >= 1.0
    && pPlane->m_aWheelRatios[1] >= 1.0
    && pPlane->m_aWheelRatios[2] >= 1.0
    && pPlane->m_aWheelRatios[3] >= 1.0 )
  {
    m_OnGroundTimer = pPlane->m_OnGroundTimer;
    v36 = CTimer::m_snTimeInMilliseconds;
  }
  else
  {
    m_OnGroundTimer = CTimer::m_snTimeInMilliseconds;
    pPlane->m_OnGroundTimer = CTimer::m_snTimeInMilliseconds;
    v36 = m_OnGroundTimer;
  }
  v37 = v34 * 60.0;
  v38 = v31;
  if ( v36 - m_OnGroundTimer <= 0xFA0 )
  {
    v45 = dword_2F986C;
    if ( v37 < v33 )
      v45 = &dword_2F986C[1];
    v6.n64_u32[0] = *v45;
    LODWORD(pPlane->m_fPitchControl) = *v45;
    v44 = 1;
  }
  else
  {
    if ( pPlane->m_fLGearAngle != 1.0 )
    {
      CPlane::SetGearUp(pPlane);
      m_pMat = pPlane->m_pMat;
    }
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPlane->m_transform;
    v1.n64_f32[0] = pPlane->m_vecMoveSpeed.z * 100.0;
    z = p_tx->m_translate.z;
    v41 = asinf(m_pMat->zy);
    v1.n64_f32[0] = (float)(pPlane->m_DesiredHeight - (float)(z + v1.n64_f32[0])) / 30.0;
    v3.n64_u32[0] = 1053609165;
    v42.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
    v1.n64_u32[0] = -1093874483;
    v3.n64_u32[0] = 0.25;
    v1.n64_u64[0] = vmax_f32(v42, v1).n64_u64[0];
    v43 = v41 + (float)((float)(v41 - pPlane->m_OldTilt) * (float)(100.0 / CTimer::ms_fTimeStep));
    v3.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
    if ( v37 < v33 )
      v1.n64_u32[0] = v3.n64_u32[0];
    pPlane->m_OldTilt = v41;
    v6.n64_f32[0] = (float)(v1.n64_f32[0] - v43) * 0.5;
    pPlane->m_fPitchControl = v6.n64_f32[0];
    v44 = 0;
  }
  for ( v1.n64_f32[0] = pPlane->m_FlightDirectionAvoidingTerrain - v38;
        v1.n64_f32[0] < -3.1416;
        v1.n64_f32[0] = v1.n64_f32[0] + 6.2832 )
  {
    ;
  }
  for ( ; v1.n64_f32[0] > 3.1416; v1.n64_f32[0] = v1.n64_f32[0] + -6.2832 )
    ;
  if ( v44 == 1 )
  {
    v1.n64_u32[0] = LODWORD(pPlane->m_TakeOffDirection);
    pPlane->m_fRollControl = 0.0;
    v1.n64_f32[0] = (float)(v1.n64_f32[0] - v38) * -10.0;
    v2.n64_u32[0] = -1.0;
    v46.n64_u64[0] = vmax_f32(vmin_f32(v1, v5), v2).n64_u64[0];
    LODWORD(pPlane->m_fYawControl) = v46.n64_u32[0];
    p_m_fPitchControl = &pPlane->m_fPitchControl;
  }
  else
  {
    v3.n64_u32[0] = 1063675494;
    v1.n64_f32[0] = v1.n64_f32[0] * -1.5;
    v2.n64_u32[0] = -1083808154;
    v48.n64_u64[0] = vmax_f32(vmin_f32(v1, v3), v2).n64_u64[0];
    if ( (*((_BYTE *)&pPlane->m_nVehicleFlags + 4) & 0x80) != 0 )
    {
      v1.n64_u32[0] = 1060320051;
      v3.n64_u32[0] = -1087163597;
      v48.n64_u64[0] = vmax_f32(vmin_f32(v48, v1), v3).n64_u64[0];
    }
    v49 = fabsf(v48.n64_f32[0]);
    v50 = -v48.n64_f32[0];
    if ( v49 < 0.1 )
      v48.n64_f32[0] = v48.n64_f32[0] * 4.0;
    v51 = 0.0;
    if ( v49 < 0.1 )
      v50 = 0.0;
    LODWORD(pPlane->m_fYawControl) = v48.n64_u32[0];
    if ( v37 < (float)(v33 * 1.2) )
    {
      v48.n64_f32[0] = (float)((float)((float)(v33 * 1.2) - v37) / (float)(v33 * -0.5)) + 1.0;
      v3.n64_u32[0] = 0;
      v48.n64_u64[0] = vmax_f32(v48, v3).n64_u64[0];
      v50 = v48.n64_f32[0] * v50;
    }
    if ( m_pMat )
    {
      v52 = sqrtf((float)(m_pMat->xx * m_pMat->xx) + (float)(m_pMat->yx * m_pMat->yx));
      if ( m_pMat->zz < 0.0 )
        v52 = -v52;
      v51 = atan2f(m_pMat->zx, v52);
    }
    v3.n64_f32[0] = CTimer::ms_fTimeStep;
    for ( i = v50
            - (float)(v51 + (float)((float)(v51 - pPlane->m_fPreviousRoll) * (float)(30.0 / vmax_f32(v3, v5).n64_f32[0])));
          i > 3.1416;
          i = i + -6.2832 )
    {
      ;
    }
    for ( ; i < -3.1416; i = i + 6.2832 )
      ;
    v4.n64_u32[0] = -1.0;
    v54 = -i;
    v55.n64_u64[0] = v5.n64_u64[0];
    v56 = i <= -1.0;
    v48.n64_f32[0] = fabsf(v51 * 0.23) + v6.n64_f32[0];
    if ( !v56 )
      v55.n64_f32[0] = v54;
    pPlane->m_fPreviousRoll = v51;
    v46.n64_u64[0] = vmax_f32(v55, v4).n64_u64[0];
    LODWORD(pPlane->m_fRollControl) = v46.n64_u32[0];
    p_m_fPitchControl = &pPlane->m_fPitchControl;
    LODWORD(pPlane->m_fPitchControl) = v48.n64_u32[0];
    if ( v6.n64_f32[0] < 0.0 )
    {
      v46.n64_f32[0] = v6.n64_f32[0] * 0.5;
      v6.n64_u64[0] = vmin_f32(v48, v46).n64_u64[0];
      *p_m_fPitchControl = v6.n64_f32[0];
    }
    else
    {
      v6.n64_u64[0] = v48.n64_u64[0];
    }
  }
  v46.n64_u32[0] = -1.0;
  *(_DWORD *)p_m_fPitchControl = vmax_f32(vmin_f32(v6, v5), v46).n64_u32[0];
  v57 = (unsigned __int8)pPlane->AutoPilot.TempAction;
  pPlane->m_fThrottleControl = pPlane->m_fScriptThrottleControl;
  if ( v57 == 15 )
  {
    *p_m_fPitchControl = 1.0;
    if ( v37 < 20.0 )
      pPlane->AutoPilot.TempAction = 0;
  }
}
// 2F936E: variable 'v1' is possibly undefined
// 2F936E: variable 'v3' is possibly undefined
// 2F95DE: variable 'v5' is possibly undefined
// 2F95E2: variable 'v2' is possibly undefined
// 2F9786: variable 'v4' is possibly undefined
// 2F97BA: variable 'v6' is possibly undefined
// 2F9858: using guessed type int dword_2F9858[2];
// 2F986C: using guessed type int dword_2F986C[2];

//----- (002F98A4) --------------------------------------------------------
void __fastcall CCarCtrl::TriggerDogFightMoves(CVehicle *pPlane, CVehicle *pTargetPlane)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CMatrix *v6; // r1
  CSimpleTransform *v7; // r4
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *v9; // r0
  RwReal v10; // s0
  RwReal v11; // s4
  CMatrix *v12; // r0
  CMatrix *v13; // r1
  float v14; // s0
  uint32 v15; // r4
  UInt32 v16; // r0
  Int8 v17; // r1
  uint32 v18; // r4
  uint32 v19; // r4
  CVector v20; // [sp+4h] [bp-4Ch] BYREF

  if ( !pPlane->AutoPilot.TempAction )
  {
    m_pMat = pTargetPlane->m_pMat;
    p_m_transform = &pTargetPlane->m_transform;
    v6 = pPlane->m_pMat;
    v7 = &pPlane->m_transform;
    p_tx = &pTargetPlane->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v9 = &pPlane->m_transform;
    if ( v6 )
      v9 = (CSimpleTransform *)&v6->tx;
    v10 = v9->m_translate.x - p_tx->m_translate.x;
    v11 = v9->m_translate.z - p_tx->m_translate.z;
    v20.y = v9->m_translate.y - p_tx->m_translate.y;
    v20.x = v10;
    v20.z = v11;
    if ( sqrtf((float)((float)(v10 * v10) + (float)(v20.y * v20.y)) + (float)(v11 * v11)) < 70.0 )
    {
      CVector::Normalise(&v20);
      v12 = pTargetPlane->m_pMat;
      v13 = pPlane->m_pMat;
      if ( v12 )
        p_m_transform = (CSimpleTransform *)&v12->tx;
      if ( v13 )
        v7 = (CSimpleTransform *)&v13->tx;
      if ( fabsf(v7->m_translate.z - p_m_transform->m_translate.z) < 15.0 )
      {
        v14 = (float)((float)(v20.x * v12->xy) + (float)(v20.y * v12->yy)) + (float)(v20.z * v12->zy);
        switch ( (unsigned __int8)rand() )
        {
          case 0xCu:
            if ( v14 > 0.0 )
            {
              pPlane->AutoPilot.TempAction = 16;
              v15 = CTimer::m_snTimeInMilliseconds;
              v16 = (rand() & 0x3FF) + v15 + 1500;
              goto LABEL_22;
            }
            break;
          case 0xDu:
            if ( v14 > 0.0 )
            {
              v17 = 17;
              goto LABEL_19;
            }
            break;
          case 0xEu:
            if ( v14 > 0.0 )
            {
              v17 = 18;
LABEL_19:
              pPlane->AutoPilot.TempAction = v17;
              v18 = CTimer::m_snTimeInMilliseconds;
              v16 = (rand() & 0x1FF) + v18 + 700;
              goto LABEL_22;
            }
            break;
          case 0xFu:
            if ( v14 > 0.7 )
            {
              pPlane->AutoPilot.TempAction = 15;
              v19 = CTimer::m_snTimeInMilliseconds;
              v16 = (rand() & 0x7FF) + v19 + 3000;
LABEL_22:
              pPlane->AutoPilot.TempActionFinish = v16;
            }
            break;
          default:
            return;
        }
      }
    }
  }
}

//----- (002F9A6C) --------------------------------------------------------
void __fastcall CCarCtrl::TestWhetherToFirePlaneGuns(CVehicle *pPlane, CEntity *pTargetEntity)
{
  int m_SelectedWeapon; // r0
  CMatrix *m_pMat; // r0
  CMatrix *v5; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  RwReal v8; // s0
  RwReal v9; // s4
  CVector v10; // [sp+4h] [bp-14h] BYREF

  m_SelectedWeapon = pPlane->m_SelectedWeapon;
  *((_DWORD *)&pPlane->m_nVehicleFlags + 1) &= ~0x10u;
  if ( m_SelectedWeapon )
  {
    if ( !pTargetEntity || m_SelectedWeapon != 1 )
      return;
  }
  else if ( !pTargetEntity )
  {
    return;
  }
  m_pMat = pPlane->m_pMat;
  v5 = pTargetEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPlane->m_transform;
  p_m_transform = (CSimpleTransform *)&v5->tx;
  if ( !v5 )
    p_m_transform = &pTargetEntity->m_transform;
  v8 = p_m_transform->m_translate.x - p_tx->m_translate.x;
  v9 = p_m_transform->m_translate.z - p_tx->m_translate.z;
  v10.y = p_m_transform->m_translate.y - p_tx->m_translate.y;
  v10.x = v8;
  v10.z = v9;
  if ( sqrtf((float)((float)(v8 * v8) + (float)(v10.y * v10.y)) + (float)(v9 * v9)) < 150.0 )
  {
    CVector::Normalise(&v10);
    if ( (float)((float)((float)(v10.x * pPlane->m_pMat->xy) + (float)(v10.y * pPlane->m_pMat->yy))
               + (float)(v10.z * pPlane->m_pMat->zy)) > 0.8 )
      *((_DWORD *)&pPlane->m_nVehicleFlags + 1) |= 0x10u;
  }
}

//----- (002F9B60) --------------------------------------------------------
void __fastcall CCarCtrl::PossiblyFireHSMissile(CVehicle *pPlane, CEntity *pTargetEntity)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CMatrix *v6; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *v8; // r0
  float v9; // s2
  float v10; // s0
  float v11; // s4
  float v12; // s0
  CMatrix *v13; // r1
  float xy; // s4
  float yy; // s2
  float zy; // s0
  CVector v17; // [sp+14h] [bp-1Ch] BYREF
  CVector v18; // 0:r2.8,8:^0.4

  if ( pTargetEntity )
  {
    m_pMat = pPlane->m_pMat;
    p_m_transform = &pPlane->m_transform;
    v6 = pTargetEntity->m_pMat;
    p_tx = &pPlane->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v8 = (CSimpleTransform *)&v6->tx;
    if ( !v6 )
      v8 = &pTargetEntity->m_transform;
    v9 = v8->m_translate.x - p_tx->m_translate.x;
    v10 = v8->m_translate.y - p_tx->m_translate.y;
    v11 = v8->m_translate.z - p_tx->m_translate.z;
    v17.y = v10;
    v17.x = v9;
    v17.z = v11;
    if ( CTimer::m_snTimeInMilliseconds / 0x7D0 != CTimer::m_snPreviousTimeInMilliseconds / 0x7D0 )
    {
      v12 = sqrtf((float)((float)(v9 * v9) + (float)(v10 * v10)) + (float)(v11 * v11));
      if ( v12 < 160.0 && v12 > 30.0 )
      {
        CVector::Normalise(&v17);
        v13 = pPlane->m_pMat;
        xy = v13->xy;
        yy = v13->yy;
        zy = v13->zy;
        if ( (float)((float)((float)(v17.x * xy) + (float)(v17.y * yy)) + (float)(v17.z * zy)) > 0.8 )
        {
          if ( v13 )
            p_m_transform = (CSimpleTransform *)&v13->tx;
          v18.x = (float)((float)(xy * 4.0) + p_m_transform->m_translate.x) - (float)(v13->xz * 3.0);
          v18.y = (float)((float)(yy * 4.0) + p_m_transform->m_translate.y) - (float)(v13->yz * 3.0);
          v18.z = (float)((float)(zy * 4.0) + p_m_transform->m_translate.z) - (float)(v13->zz * 3.0);
          CProjectileInfo::AddProjectile(pPlane, WEAPONTYPE_ROCKET_HS, v18, 1.0, (CVector *)&v13->xy, pTargetEntity);
        }
      }
    }
  }
}

//----- (002F9CF0) --------------------------------------------------------
void __fastcall CCarCtrl::FlyAIHeliInCertainDirection(
        CHeli *pHeli,
        float Orientation,
        float Distance,
        bool bSlowDownAtTarget)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  float32x2_t v7; // d3
  float32x2_t v8; // d4
  float32x2_t v9; // d10
  float32x2_t v10; // d11
  int Mission; // r0
  float v14; // s16
  _BOOL4 v15; // r8
  int v16; // r12
  CSimpleTransform *p_m_transform; // r9
  int v18; // r4
  CSimpleTransform *p_tx; // r1
  CMatrix *m_pMat; // r0
  RwReal v21; // s0
  RwReal v22; // s2
  float v23; // r5
  float v24; // r6
  float *p_m_DesiredHeight; // r0
  float m_MinHeightAboveTerrain; // s6
  float v27; // s20
  float v28; // s4
  float v29; // s6
  float v30; // s22
  CSimpleTransform *v31; // r0
  CMatrix *v32; // r1
  RwReal v33; // s4
  RwReal v34; // s0
  float v35; // s24
  CMatrix *v36; // r0
  RwReal v37; // s0
  RwReal v38; // s4
  float v39; // s0
  float ATanOfXY; // r5
  CSimpleTransform *v41; // r6
  CMatrix *v42; // r0
  CSimpleTransform *v43; // r1
  float v44; // s4
  float *p_m_fThrottleControl; // r4
  float v46; // s0
  float v47; // s4
  float v48; // s0
  float32x2_t v49; // d4
  float v50; // s14
  float v51; // s0
  float v52; // s12
  float v53; // s3
  CMatrix *v54; // r1
  float32x2_t v55; // d16
  float32x2_t v56; // d16
  float v57; // s12
  float v58; // s12
  float *p_m_fPitchControl; // r5
  float v60; // s2
  CMatrix *v61; // r0
  float x; // s2
  float y; // s6
  float z; // s4
  float v65; // s10
  float v66; // s12
  bool v67; // fnf
  float v68; // s8
  float v69; // s12
  float v70; // s0
  float v71; // s2
  unsigned __int32 v72; // s2
  CVector v73; // [sp+28h] [bp-B8h] BYREF
  CVector vecEnd; // [sp+38h] [bp-A8h] BYREF
  CVector v75; // [sp+44h] [bp-9Ch] BYREF
  CVector vecStart; // [sp+50h] [bp-90h] BYREF
  CEntity *refEntityPtr; // [sp+5Ch] [bp-84h] BYREF
  CColPoint colPoint; // [sp+60h] [bp-80h] BYREF

  Mission = (unsigned __int8)pHeli->AutoPilot.Mission;
  v14 = Orientation;
  v15 = bSlowDownAtTarget;
  if ( Mission == 41
    && (float)pHeli->AutoPilot.TargetReachedDist > Distance
    && sqrtf(
         (float)(pHeli->m_vecMoveSpeed.x * pHeli->m_vecMoveSpeed.x)
       + (float)(pHeli->m_vecMoveSpeed.y * pHeli->m_vecMoveSpeed.y)) < 0.01 )
  {
    v16 = 1;
    v14 = Orientation + 1.5708;
  }
  else
  {
    v16 = 0;
  }
  if ( (CTimer::m_snTimeInMilliseconds + pHeli->RandomSeed) % 0x1F4 < (CTimer::m_snPreviousTimeInMilliseconds
                                                                     + pHeli->RandomSeed)
                                                                    % 0x1F4 )
  {
    p_m_transform = &pHeli->m_transform;
    pHeli->m_DesiredHeight = pHeli->m_LowestFlightHeight;
    v18 = v16;
    p_tx = &pHeli->m_transform;
    m_pMat = pHeli->m_pMat;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v21 = (float)(pHeli->m_vecMoveSpeed.x * 50.0) + p_tx->m_translate.x;
    v22 = (float)(pHeli->m_vecMoveSpeed.z * 50.0) + p_tx->m_translate.z;
    vecStart.y = (float)(pHeli->m_vecMoveSpeed.y * 50.0) + p_tx->m_translate.y;
    vecStart.x = v21;
    vecStart.z = v22;
    v23 = sinf(v14);
    v75.y = v23;
    v24 = cosf(v14);
    v75.x = v24;
    v75.z = -1.0;
    CVector::Normalise(&v75);
    vecEnd.x = (float)(v75.x * 60.0) + vecStart.x;
    vecEnd.y = (float)(v75.y * 60.0) + vecStart.y;
    vecEnd.z = (float)(v75.z * 60.0) + vecStart.z;
    if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) == 1 )
    {
      p_m_DesiredHeight = &pHeli->m_DesiredHeight;
      m_MinHeightAboveTerrain = pHeli->m_MinHeightAboveTerrain;
      if ( v18 )
        m_MinHeightAboveTerrain = m_MinHeightAboveTerrain * 0.5;
      v8.n64_f32[0] = *p_m_DesiredHeight;
      v6.n64_f32[0] = colPoint.m_vecPosition.z + m_MinHeightAboveTerrain;
      v6.n64_u64[0] = vmax_f32(v8, v6).n64_u64[0];
      *p_m_DesiredHeight = v6.n64_f32[0];
    }
    v75.y = v23;
    v75.x = v24;
    v75.z = 0.0;
    v27 = 0.0;
    v28 = (float)(pHeli->m_vecMoveSpeed.x * pHeli->m_vecMoveSpeed.x)
        + (float)(pHeli->m_vecMoveSpeed.y * pHeli->m_vecMoveSpeed.y);
    v29 = 5.0;
    if ( (*((_DWORD *)&pHeli->m_nVehicleFlags + 1) & 0x80) == 0 )
      v29 = 30.0;
    pHeli->m_bStopFlyingForAWhile = 1;
    v30 = v29 + (float)(sqrtf(v28 + 0.0) * 100.0);
    vecEnd.y = vecStart.y + (float)(v23 * v30);
    vecEnd.x = vecStart.x + (float)(v24 * v30);
    vecEnd.z = (float)(v30 * 0.0) + vecStart.z;
    if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) == 1 )
    {
      *(_QWORD *)&v73.x = *(_QWORD *)&pHeli->m_pMat->xx;
      v73.z = 0.0;
      CVector::Normalise(&v73);
      v31 = &pHeli->m_transform;
      v32 = pHeli->m_pMat;
      if ( v32 )
        v31 = (CSimpleTransform *)&v32->tx;
      v33 = (float)(v73.z * 10.0) + v31->m_translate.z;
      v34 = (float)(v73.x * 10.0) + v31->m_translate.x;
      vecStart.y = (float)(v73.y * 10.0) + v31->m_translate.y;
      vecStart.x = v34;
      vecStart.z = v33;
      vecEnd.y = (float)(v30 * v75.y) + vecStart.y;
      vecEnd.x = (float)(v30 * v75.x) + v34;
      vecEnd.z = v33 + (float)(v30 * v75.z);
      v35 = 0.0;
      if ( !CWorld::ProcessLineOfSight(&v31->m_translate, &vecStart, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) )
      {
        if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) == 1 )
          v35 = sqrtf(
                  (float)((float)((float)(colPoint.m_vecPosition.x - vecStart.x)
                                * (float)(colPoint.m_vecPosition.x - vecStart.x))
                        + (float)((float)(colPoint.m_vecPosition.y - vecStart.y)
                                * (float)(colPoint.m_vecPosition.y - vecStart.y)))
                + (float)((float)(colPoint.m_vecPosition.z - vecStart.z) * (float)(colPoint.m_vecPosition.z - vecStart.z)));
        else
          v35 = 1000.0;
      }
      v36 = pHeli->m_pMat;
      if ( v36 )
        p_m_transform = (CSimpleTransform *)&v36->tx;
      v37 = p_m_transform->m_translate.x - (float)(v73.x * 10.0);
      v38 = p_m_transform->m_translate.z - (float)(v73.z * 10.0);
      vecStart.y = p_m_transform->m_translate.y - (float)(v73.y * 10.0);
      vecStart.x = v37;
      vecStart.z = v38;
      vecEnd.y = (float)(v30 * v75.y) + vecStart.y;
      vecEnd.x = (float)(v30 * v75.x) + v37;
      vecEnd.z = v38 + (float)(v30 * v75.z);
      if ( !CWorld::ProcessLineOfSight(
              &p_m_transform->m_translate,
              &vecStart,
              &colPoint,
              &refEntityPtr,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              1) )
      {
        if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) == 1 )
          v27 = sqrtf(
                  (float)((float)((float)(colPoint.m_vecPosition.x - vecStart.x)
                                * (float)(colPoint.m_vecPosition.x - vecStart.x))
                        + (float)((float)(colPoint.m_vecPosition.y - vecStart.y)
                                * (float)(colPoint.m_vecPosition.y - vecStart.y)))
                + (float)((float)(colPoint.m_vecPosition.z - vecStart.z) * (float)(colPoint.m_vecPosition.z - vecStart.z)));
        else
          v27 = 1000.0;
      }
      v39 = -0.5;
      if ( v27 > v35 )
        v39 = 0.5;
      pHeli->m_fRollControl = v39;
    }
    else
    {
      pHeli->m_fRollControl = 0.0;
      pHeli->m_bStopFlyingForAWhile = 0;
    }
    Mission = (unsigned __int8)pHeli->AutoPilot.Mission;
  }
  if ( Mission == 48 )
  {
    pHeli->m_fRollControl = 0.0;
    pHeli->m_bStopFlyingForAWhile = 0;
  }
  ATanOfXY = CGeneral::GetATanOfXY(pHeli->m_pMat->xy, pHeli->m_pMat->yy);
  v41 = &pHeli->m_transform;
  v42 = pHeli->m_pMat;
  v43 = &pHeli->m_transform;
  v44 = 5.0;
  if ( v42 )
    v43 = (CSimpleTransform *)&v42->tx;
  p_m_fThrottleControl = &pHeli->m_fThrottleControl;
  v10.n64_u32[0] = 0;
  v46 = pHeli->m_DesiredHeight - (float)(v43->m_translate.z + (float)(pHeli->m_vecMoveSpeed.z * 100.0));
  if ( v46 > 0.0 )
    v44 = 10.0;
  *p_m_fThrottleControl = (float)(v46 / v44) + 0.0;
  v9.n64_u32[0] = 1.0;
  v47 = ATanOfXY;
  v7.n64_f32[0] = *p_m_fThrottleControl + (float)((float)((rand() & 0xF) - 7) * 0.002);
  v5.n64_u32[0] = -1097229926;
  v48 = v14 - ATanOfXY;
  v49.n64_u64[0] = vmax_f32(vmin_f32(v7, v9), v5).n64_u64[0];
  for ( *p_m_fThrottleControl = v49.n64_f32[0]; v48 > 3.1416; v48 = v48 + -6.2832 )
    ;
  for ( ; v48 < -3.1416; v48 = v48 + 6.2832 )
    ;
  v50 = 1.0;
  v51 = v48 * -2.0;
  v52 = 1.0;
  if ( v51 < 1.0 )
    v52 = v51;
  if ( v52 < -1.0 )
    v50 = -1.0;
  v53 = v50;
  if ( v51 < 1.0 )
    v53 = v51;
  v4.n64_u32[0] = -1085485875;
  if ( v52 < -1.0 )
    v53 = v50;
  pHeli->m_fYawControl = v53;
  if ( Distance <= 60.0 && v15 )
  {
    v54 = pHeli->m_pMat;
    v55.n64_u64[0] = vmul_f32(*(float32x2_t *)&pHeli->m_vecMoveSpeed.x, (float32x2_t)0x4248000042480000LL).n64_u64[0];
    if ( v54 )
      v41 = (CSimpleTransform *)&v54->tx;
    v56.n64_u64[0] = vsub_f32(
                       vadd_f32(v55, *(float32x2_t *)&v41->m_translate.x),
                       *(float32x2_t *)&pHeli->AutoPilot.TargetCoors.x).n64_u64[0];
    v4.n64_u64[0] = vmul_f32(v56, v56).n64_u64[0];
    v57 = sqrtf((float)(v4.n64_f32[0] + v4.n64_f32[1]) + 0.0);
    v4.n64_f32[0] = (float)pHeli->AutoPilot.TargetReachedDist;
    v58 = v57 - v4.n64_f32[0];
    if ( v58 < 0.0 )
    {
      p_m_fPitchControl = &pHeli->m_fPitchControl;
      v4.n64_u32[0] = LODWORD(pHeli->m_fPitchControl);
      goto LABEL_59;
    }
    v4.n64_u32[1] = -1085485875;
    v4.n64_f32[0] = (float)(v58 * -0.8) / (float)(30.0 - v4.n64_f32[0]);
  }
  p_m_fPitchControl = &pHeli->m_fPitchControl;
  LODWORD(pHeli->m_fPitchControl) = v4.n64_u32[0];
LABEL_59:
  v7.n64_f32[0] = v7.n64_f32[0] + -0.5;
  if ( v4.n64_f32[0] < 0.0 )
  {
    for ( v6.n64_f32[0] = v47 - v14; v6.n64_f32[0] < -3.1416; v6.n64_f32[0] = v6.n64_f32[0] + 6.2832 )
      ;
    for ( ; v6.n64_f32[0] > 3.1416; v6.n64_f32[0] = v6.n64_f32[0] + -6.2832 )
      ;
    v60 = fabsf(v6.n64_f32[0]);
    v6.n64_f32[0] = (float)(v60 / -0.47124) + 1.0;
    v4.n64_f32[0] = vmax_f32(v6, v10).n64_f32[0] * v4.n64_f32[0];
    *p_m_fPitchControl = v4.n64_f32[0];
    if ( v60 > 1.5708
      && (float)((float)((float)(pHeli->m_vecMoveSpeed.x * pHeli->m_pMat->xy)
                       + (float)(pHeli->m_vecMoveSpeed.y * pHeli->m_pMat->yy))
               + (float)(pHeli->m_vecMoveSpeed.z * pHeli->m_pMat->zy)) > 0.0 )
    {
      v4.n64_u32[0] = 1050253722;
      *p_m_fPitchControl = 0.3;
    }
  }
  if ( v7.n64_f32[0] > 0.0 )
  {
    v4.n64_f32[0] = (float)(1.0 - vmin_f32(v7, v9).n64_f32[0]) * v4.n64_f32[0];
    *p_m_fPitchControl = v4.n64_f32[0];
  }
  if ( v4.n64_f32[0] < 0.0 )
  {
    v61 = pHeli->m_pMat;
    x = pHeli->m_vecMoveSpeed.x;
    y = pHeli->m_vecMoveSpeed.y;
    z = pHeli->m_vecMoveSpeed.z;
    v65 = 0.0;
    v66 = 1.0;
    v49.n64_f32[0] = (float)((float)pHeli->AutoPilot.CruiseSpeed
                           + (float)((float)((float)((float)(x * v61->xy) + (float)(y * v61->yy)) + (float)(z * v61->zy))
                                   * -60.0))
                   / 10.0;
    if ( v49.n64_f32[0] > 1.0 )
      v65 = 1.0;
    if ( v49.n64_f32[0] < 0.0 )
      v66 = v65;
    v67 = v49.n64_f32[0] < 0.0;
    if ( v49.n64_f32[0] > 1.0 )
      v49.n64_f32[0] = v66;
    if ( v67 )
      v49.n64_f32[0] = v66;
    v49.n64_f32[0] = -v49.n64_f32[0];
    v4.n64_u32[0] = vmax_f32(v4, v49).n64_u32[0];
    *p_m_fPitchControl = v4.n64_f32[0];
    if ( pHeli->AutoPilot.SpeedCheat && v4.n64_f32[0] < -0.2 && !pHeli->m_bStopFlyingForAWhile )
    {
      v68 = (float)((float)pHeli->AutoPilot.SpeedCheat * 0.001) * CTimer::ms_fTimeStep;
      v69 = v61->yy * v68;
      pHeli->m_vecMoveSpeed.x = x + (float)(v61->xy * v68);
      pHeli->m_vecMoveSpeed.y = y + v69;
      pHeli->m_vecMoveSpeed.z = (float)(v68 * 0.0) + z;
    }
  }
  if ( pHeli->m_bStopFlyingForAWhile )
  {
    *(_QWORD *)&colPoint.m_vecPosition.x = *(_QWORD *)&pHeli->m_pMat->xy;
    colPoint.m_vecPosition.z = 0.0;
    CVector::Normalise(&colPoint.m_vecPosition);
    v70 = (float)((float)(colPoint.m_vecPosition.x * pHeli->m_vecMoveSpeed.x)
                + (float)(colPoint.m_vecPosition.y * pHeli->m_vecMoveSpeed.y))
        + (float)(colPoint.m_vecPosition.z * pHeli->m_vecMoveSpeed.z);
    v4.n64_f32[0] = v70 + v70;
    *p_m_fPitchControl = v4.n64_f32[0];
  }
  v71 = 1.0;
  if ( v4.n64_f32[0] < -1.0 )
    v71 = -1.0;
  if ( v4.n64_f32[0] < 1.0 )
    v9.n64_f32[0] = v71;
  v72 = v9.n64_u32[0];
  if ( v4.n64_f32[0] < 1.0 )
    v72 = v4.n64_u32[0];
  if ( v4.n64_f32[0] < -1.0 )
    v72 = v9.n64_u32[0];
  *(_DWORD *)p_m_fPitchControl = v72;
}
// 2F9EC2: variable 'v8' is possibly undefined
// 2F9EC2: variable 'v6' is possibly undefined
// 2FA284: variable 'v7' is possibly undefined
// 2FA284: variable 'v9' is possibly undefined
// 2FA288: variable 'v5' is possibly undefined
// 2FA41A: variable 'v10' is possibly undefined
// 2FA530: variable 'v4' is possibly undefined

//----- (002FA688) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CCarCtrl::FlyAIHeliToTarget_FixedOrientation(
        CHeli *pHeli,
        float Orientation,
        CVector Target,
        bool bSlowDownAtTarget)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d2
  float x; // r8
  float y; // r9
  CSimpleTransform *p_m_transform; // r10
  CSimpleTransform *p_tx; // r1
  CMatrix *m_pMat; // r0
  RwReal v14; // s16
  RwReal v15; // s20
  RwReal v16; // s22
  float *p_m_DesiredHeight; // r6
  float ATanOfXY; // r5
  CSimpleTransform *v19; // r1
  CMatrix *v20; // r0
  float v21; // s4
  float v22; // s2
  float *p_m_fThrottleControl; // r6
  float v24; // s0
  int v25; // r0
  float v26; // s2
  float v27; // s0
  int v28; // s6
  float v29; // s8
  float v30; // s4
  float v31; // s6
  float v32; // s8
  float v33; // s4
  float v34; // s8
  CMatrix *v35; // r0
  float v36; // s8
  float v37; // s10
  float v38; // s4
  float v39; // s2
  float yx; // s3
  float z; // s12
  float v42; // s6
  float zx; // s5
  float xy; // s7
  float yy; // s14
  float v46; // s1
  float zy; // s3
  float v48; // s6
  float v49; // s4
  float v50; // s2
  float v51; // s8
  float v52; // s4
  float v53; // s8
  float v54; // s12
  float v55; // s14
  float v56; // s6
  float v57; // s4
  float v58; // s6
  float v59; // s8
  CVector vecEnd; // [sp+24h] [bp-94h] BYREF
  CVector v61; // [sp+30h] [bp-88h] BYREF
  CVector vecStart; // [sp+3Ch] [bp-7Ch] BYREF
  CEntity *refEntityPtr; // [sp+48h] [bp-70h] BYREF
  CColPoint colPoint; // [sp+4Ch] [bp-6Ch] BYREF

  x = Target.x;
  y = Target.y;
  if ( (CTimer::m_snTimeInMilliseconds + pHeli->RandomSeed) % 0x1F4 >= (CTimer::m_snPreviousTimeInMilliseconds
                                                                      + pHeli->RandomSeed)
                                                                     % 0x1F4 )
  {
    p_m_DesiredHeight = &pHeli->m_DesiredHeight;
    p_m_transform = &pHeli->m_transform;
  }
  else
  {
    p_m_transform = &pHeli->m_transform;
    pHeli->m_DesiredHeight = pHeli->m_LowestFlightHeight;
    p_tx = &pHeli->m_transform;
    m_pMat = pHeli->m_pMat;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v15 = (float)(pHeli->m_vecMoveSpeed.x * 50.0) + p_tx->m_translate.x;
    v16 = (float)(pHeli->m_vecMoveSpeed.z * 50.0) + p_tx->m_translate.z;
    vecStart.y = (float)(pHeli->m_vecMoveSpeed.y * 50.0) + p_tx->m_translate.y;
    v14 = vecStart.y;
    vecStart.x = v15;
    vecStart.z = v16;
    v61.y = sinf(Orientation);
    v61.x = cosf(Orientation);
    v61.z = -1.0;
    CVector::Normalise(&v61);
    vecEnd.x = (float)(v61.x * 60.0) + v15;
    vecEnd.y = (float)(v61.y * 60.0) + v14;
    vecEnd.z = (float)(v61.z * 60.0) + v16;
    p_m_DesiredHeight = &pHeli->m_DesiredHeight;
    if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) == 1 )
    {
      v5.n64_f32[0] = *p_m_DesiredHeight;
      v4.n64_f32[0] = colPoint.m_vecPosition.z + pHeli->m_MinHeightAboveTerrain;
      *(_DWORD *)p_m_DesiredHeight = vmax_f32(v5, v4).n64_u32[0];
    }
  }
  ATanOfXY = CGeneral::GetATanOfXY(pHeli->m_pMat->xy, pHeli->m_pMat->yy);
  v19 = p_m_transform;
  v20 = pHeli->m_pMat;
  if ( v20 )
    v19 = (CSimpleTransform *)&v20->tx;
  v21 = 5.0;
  v22 = *p_m_DesiredHeight;
  p_m_fThrottleControl = &pHeli->m_fThrottleControl;
  v24 = v22 - (float)(v19->m_translate.z + (float)(pHeli->m_vecMoveSpeed.z * 100.0));
  if ( v24 > 0.0 )
    v21 = 10.0;
  *p_m_fThrottleControl = (float)(v24 / v21) + 0.0;
  v25 = (rand() & 0xF) - 7;
  v26 = 1.0;
  v27 = *p_m_fThrottleControl + (float)((float)v25 * 0.002);
  v28 = 1.0;
  v29 = 1.0;
  if ( v27 < -0.3 )
    v28 = -1097229926;
  v30 = Orientation - ATanOfXY;
  if ( v27 < 1.0 )
    v29 = *(float *)&v28;
  v31 = v29;
  if ( v27 < 1.0 )
    v31 = *p_m_fThrottleControl + (float)((float)v25 * 0.002);
  if ( v27 < -0.3 )
    v31 = v29;
  for ( *p_m_fThrottleControl = v31; v30 > 3.1416; v30 = v30 + -6.2832 )
    ;
  for ( ; v30 < -3.1416; v30 = v30 + 6.2832 )
    ;
  v32 = 1.0;
  v33 = v30 * -0.5;
  if ( v33 < -1.0 )
    v32 = -1.0;
  if ( v33 < 1.0 )
    v26 = v32;
  v34 = v26;
  if ( v33 < 1.0 )
    v34 = v33;
  if ( v33 < -1.0 )
    v34 = v26;
  v35 = pHeli->m_pMat;
  pHeli->m_fYawControl = v34;
  if ( v35 )
    p_m_transform = (CSimpleTransform *)&v35->tx;
  v36 = pHeli->m_vecMoveSpeed.x;
  v37 = pHeli->m_vecMoveSpeed.y;
  v38 = x - p_m_transform->m_translate.x;
  v39 = y - p_m_transform->m_translate.y;
  yx = v35->yx;
  z = pHeli->m_vecMoveSpeed.z;
  v42 = yx * v37;
  zx = v35->zx;
  xy = v35->xy;
  yy = v35->yy;
  v46 = (float)(v38 * v35->xx) + (float)(v39 * yx);
  zy = v35->zy;
  v48 = (float)((float)(v35->xx * v36) + v42) + (float)(zx * z);
  v49 = (float)(v38 * xy) + (float)(v39 * yy);
  v50 = (float)((float)(xy * v36) + (float)(yy * v37)) + (float)(zy * z);
  v51 = (float)(v46 + (float)(zx * 0.0)) + (float)(v48 * 80.0);
  v52 = (float)(v49 + (float)(zy * 0.0)) + (float)(v50 * 80.0);
  if ( fabsf(v51) >= 5.0 )
    v48 = v51 * -0.02;
  v53 = 0.75;
  v54 = 0.75;
  if ( v48 < 0.75 )
    v54 = v48;
  if ( v54 < -0.75 )
    v53 = -0.75;
  v55 = v53;
  if ( v48 < 0.75 )
    v55 = v48;
  v56 = fabsf(v52);
  if ( v54 < -0.75 )
    v55 = v53;
  pHeli->m_fRollControl = v55;
  if ( v56 >= 5.0 )
    v50 = v52 * -0.015;
  v57 = 0.5;
  v58 = 0.5;
  if ( v50 < 0.5 )
    v58 = v50;
  if ( v58 < -0.5 )
    v57 = -0.5;
  v59 = v57;
  if ( v50 < 0.5 )
    v59 = v50;
  if ( v58 < -0.5 )
    v59 = v57;
  pHeli->m_fPitchControl = v59;
}
// 2FA688: fragmented variable at 0:r2.8,8:^C0.4 may be wrong

//----- (002FAB10) --------------------------------------------------------
void __fastcall CCarCtrl::FireHeliRocketsAtTarget(CAutomobile *pVeh, CEntity *pTarget)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CMatrix *v5; // r3
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *v7; // r0
  float y; // s4
  float z; // s2
  RwReal v10; // s0
  RwReal v11; // s2
  CMatrix *v12; // r1
  float v13; // s0
  float v14; // s6
  float v15; // s4
  CVector pVecEnd; // [sp+14h] [bp-1Ch] BYREF
  CVector v17; // 0:r2.8,8:^0.4

  if ( (pVeh->m_SelectedWeapon | 4) == 4
    && CTimer::m_snTimeInMilliseconds / 0xFA != CTimer::m_snPreviousTimeInMilliseconds / 0xFA )
  {
    m_pMat = pTarget->m_pMat;
    p_m_transform = &pVeh->m_transform;
    v5 = pVeh->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pTarget->m_transform;
    v7 = &pVeh->m_transform;
    if ( v5 )
      v7 = (CSimpleTransform *)&v5->tx;
    y = v7->m_translate.y;
    z = v7->m_translate.z;
    if ( sqrtf(
           (float)((float)((float)(v7->m_translate.x - p_tx->m_translate.x)
                         * (float)(v7->m_translate.x - p_tx->m_translate.x))
                 + (float)((float)(y - p_tx->m_translate.y) * (float)(y - p_tx->m_translate.y)))
         + (float)((float)(z - p_tx->m_translate.z) * (float)(z - p_tx->m_translate.z))) < 80.0 )
    {
      v10 = v7->m_translate.x + v5->xy;
      v11 = z + v5->zy;
      pVecEnd.y = y + v5->yy;
      pVecEnd.x = v10;
      pVecEnd.z = v11;
      if ( CCollision::DistToMathematicalLine(&v7->m_translate, &pVecEnd, &p_tx->m_translate) < 7.0 )
      {
        v12 = pVeh->m_pMat;
        if ( v12 )
          p_m_transform = (CSimpleTransform *)&v12->tx;
        v13 = v12->zx * 1.5;
        v14 = v12->xx * 1.5;
        v15 = v12->yx * 1.5;
        if ( (CTimer::m_snTimeInMilliseconds / 0xFA) << 31 )
        {
          v13 = -v13;
          v15 = -v15;
          v14 = -v14;
        }
        v17.x = (float)((float)(v12->xy * 4.0) + p_m_transform->m_translate.x) + v14;
        v17.y = (float)((float)(v12->yy * 4.0) + p_m_transform->m_translate.y) + v15;
        v17.z = (float)((float)(v12->zy * 4.0) + p_m_transform->m_translate.z) + v13;
        CProjectileInfo::AddProjectile(pVeh, WEAPONTYPE_ROCKET, v17, 1.0, (CVector *)&v12->xy, 0);
      }
    }
  }
}

//----- (002FACB8) --------------------------------------------------------
void __fastcall CCarCtrl::RegisterVehicleOfInterest(CVehicle *pVeh)
{
  _BOOL4 v1; // r1
  CVehicle **v2; // r2

  if ( apCarsToKeep[0] == pVeh )
  {
    v1 = 0;
  }
  else if ( apCarsToKeep[1] == pVeh )
  {
    v1 = 1;
  }
  else
  {
    if ( apCarsToKeep[0] )
    {
      if ( apCarsToKeep[1] )
      {
        v1 = aCarsToKeepTime[1] < aCarsToKeepTime[0];
        v2 = &apCarsToKeep[v1];
      }
      else
      {
        v2 = &apCarsToKeep[1];
        v1 = 1;
      }
    }
    else
    {
      v2 = apCarsToKeep;
      v1 = 0;
    }
    *v2 = pVeh;
  }
  aCarsToKeepTime[v1] = CTimer::m_snTimeInMilliseconds;
}

//----- (002FAD48) --------------------------------------------------------
void __fastcall CCarCtrl::RemoveFromInterestingVehicleList(CVehicle *pVeh)
{
  if ( apCarsToKeep[0] == pVeh )
    apCarsToKeep[0] = 0;
  if ( apCarsToKeep[1] == pVeh )
    apCarsToKeep[1] = 0;
}

//----- (002FAD88) --------------------------------------------------------
void CCarCtrl::ClearInterestingVehicleList()
{
  apCarsToKeep[0] = 0;
  apCarsToKeep[1] = 0;
}

//----- (002FAD9C) --------------------------------------------------------
void CCarCtrl::PruneVehiclesOfInterest()
{
  CVector v0; // [sp+4h] [bp-14h] BYREF

  if ( (CTimer::m_FrameCounter & 0x3F) == 19 )
  {
    FindPlayerCoors(&v0, -1);
    if ( v0.z < 950.0 )
    {
      if ( apCarsToKeep[0] && CTimer::m_snTimeInMilliseconds > (unsigned int)&stru_2BF1C.st_value + aCarsToKeepTime[0] )
        apCarsToKeep[0] = 0;
      if ( apCarsToKeep[1] )
      {
        if ( CTimer::m_snTimeInMilliseconds > (unsigned int)&stru_2BF1C.st_value + aCarsToKeepTime[1] )
          apCarsToKeep[1] = 0;
      }
    }
  }
}
// 2BF1C: using guessed type Elf32_Sym stru_2BF1C;

//----- (002FAE50) --------------------------------------------------------
UInt8 __fastcall CCarCtrl::IsThisVehicleOnRadar(CVehicle *pVeh, int32 *pColourCode)
{
  unsigned int m_nVehicleFlags; // r2
  int v3; // r0

  m_nVehicleFlags = (unsigned int)pVeh->m_nVehicleFlags;
  v3 = 2;
  if ( (m_nVehicleFlags & 1) == 0 )
    v3 = (m_nVehicleFlags >> 2) & 2 | 1;
  *pColourCode = v3;
  return 1;
}

//----- (002FAE6C) --------------------------------------------------------
void __fastcall CCarCtrl::FindLinksToGoWithTheseNodes(CVehicle *pVehicle)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d8
  unsigned int ForcedRandomSeed; // r0
  CNodeAddress OldNode; // r1
  unsigned int Region; // r0
  CNodeAddress *v7; // r3
  int IndexAdjacentNodes; // r2
  unsigned int v9; // r1
  int v10; // r3
  Int8 *p_InvertDirNewLink; // r0
  char v12; // r1
  CNodeAddress v13; // r0
  unsigned int v14; // r1
  CPathNode *v15; // r2
  int v16; // r10
  int v17; // r1
  char *v18; // r2
  int v19; // r6
  int v20; // r5
  CNodeAddress v21; // r1
  bool v22; // zf
  CPathNode *v23; // r2
  CPathNode *v24; // r0
  int CoorsX; // r3
  int CoorsY; // r5
  int CoorsZ; // s4
  __int16 *v28; // r0
  RwReal v29; // s2
  RwReal v30; // s4
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  bool v33; // nf
  int v34; // r1
  CPathNode *v35; // r2
  unsigned int v36; // r3
  CNodeAddress *v37; // r0
  int v38; // r1
  unsigned int v39; // r2
  Int8 *p_InvertDirOldLink; // r0
  CNodeAddress *v41; // r1
  char v42; // r1
  CVector pVecEnd; // [sp+8h] [bp-48h] BYREF
  CVector pVecStart; // [sp+14h] [bp-3Ch] BYREF

  ForcedRandomSeed = pVehicle->ForcedRandomSeed;
  if ( ForcedRandomSeed )
    srand(ForcedRandomSeed);
  OldNode = pVehicle->AutoPilot.OldNode;
  Region = OldNode.Region;
  v7 = ThePaths.pAdjacentNodes[pVehicle->AutoPilot.OldNode.Region];
  IndexAdjacentNodes = ThePaths.pNodes[OldNode.Region][HIWORD(*(unsigned int *)&OldNode)].IndexAdjacentNodes;
  v9 = pVehicle->AutoPilot.NewNode.Region;
  if ( v7[IndexAdjacentNodes].Region == v9 && v7[IndexAdjacentNodes].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 0;
  }
  else if ( v7[IndexAdjacentNodes + 1].Region == v9
         && v7[IndexAdjacentNodes + 1].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 1;
  }
  else if ( v7[IndexAdjacentNodes + 2].Region == v9
         && v7[IndexAdjacentNodes + 2].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 2;
  }
  else if ( v7[IndexAdjacentNodes + 3].Region == v9
         && v7[IndexAdjacentNodes + 3].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 3;
  }
  else if ( v7[IndexAdjacentNodes + 4].Region == v9
         && v7[IndexAdjacentNodes + 4].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 4;
  }
  else if ( v7[IndexAdjacentNodes + 5].Region == v9
         && v7[IndexAdjacentNodes + 5].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 5;
  }
  else if ( v7[IndexAdjacentNodes + 6].Region == v9
         && v7[IndexAdjacentNodes + 6].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 6;
  }
  else if ( v7[IndexAdjacentNodes + 7].Region == v9
         && v7[IndexAdjacentNodes + 7].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 7;
  }
  else if ( v7[IndexAdjacentNodes + 8].Region == v9
         && v7[IndexAdjacentNodes + 8].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 8;
  }
  else if ( v7[IndexAdjacentNodes + 9].Region == v9
         && v7[IndexAdjacentNodes + 9].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 9;
  }
  else if ( v7[IndexAdjacentNodes + 10].Region == v9
         && v7[IndexAdjacentNodes + 10].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 10;
  }
  else if ( v7[IndexAdjacentNodes + 11].Region == v9
         && v7[IndexAdjacentNodes + 11].Index == pVehicle->AutoPilot.NewNode.Index )
  {
    v10 = 11;
  }
  else
  {
    v10 = 12;
  }
  pVehicle->AutoPilot.NewLink.Address = ThePaths.pAdjacentLinks[Region][IndexAdjacentNodes + v10].Address;
  if ( v9 > Region )
  {
    p_InvertDirNewLink = &pVehicle->AutoPilot.InvertDirNewLink;
LABEL_45:
    v12 = -1;
    goto LABEL_47;
  }
  if ( v9 == Region )
  {
    p_InvertDirNewLink = &pVehicle->AutoPilot.InvertDirNewLink;
    if ( pVehicle->AutoPilot.OldNode.Index < (unsigned int)pVehicle->AutoPilot.NewNode.Index )
      goto LABEL_45;
  }
  else
  {
    p_InvertDirNewLink = &pVehicle->AutoPilot.InvertDirNewLink;
  }
  v12 = 1;
LABEL_47:
  *p_InvertDirNewLink = v12;
  v13 = pVehicle->AutoPilot.OldNode;
  v14 = HIWORD(*(unsigned int *)&v13);
  v15 = ThePaths.pNodes[v13.Region];
  if ( (*((_WORD *)&v15[HIWORD(*(unsigned int *)&v13)] + 12) & 0xF) != 0 )
  {
    if ( (*((_WORD *)&v15[HIWORD(*(unsigned int *)&v13)] + 12) & 0xF) == 1 )
    {
      v16 = 0;
      v17 = v15[v14].IndexAdjacentNodes;
      v18 = (char *)&ThePaths + 4 * v13.Region;
      goto LABEL_64;
    }
    v2.n64_u32[0] = 1232348158;
    v19 = 0;
    v16 = -1;
    do
    {
      v20 = pVehicle->AutoPilot.NewNode.Region;
      v21 = ThePaths.pAdjacentNodes[v13.Region][v15[v14].IndexAdjacentNodes + v19];
      v22 = v20 == v21.Region;
      if ( v20 == v21.Region )
        v22 = pVehicle->AutoPilot.NewNode.Index == HIWORD(*(unsigned int *)&v21);
      if ( !v22 )
      {
        v23 = ThePaths.pNodes[v21.Region];
        if ( v23 )
        {
          v24 = &ThePaths.pNodes[v13.Region][HIWORD(*(unsigned int *)&v13)];
          CoorsX = v24->CoorsX;
          CoorsY = v24->CoorsY;
          CoorsZ = v24->CoorsZ;
          v28 = (__int16 *)&v23[HIWORD(*(unsigned int *)&v21)];
          pVecStart.y = (float)CoorsY * 0.125;
          pVecStart.x = (float)CoorsX * 0.125;
          pVecStart.z = (float)CoorsZ * 0.125;
          v29 = (float)v28[4] * 0.125;
          v30 = (float)v28[6] * 0.125;
          pVecEnd.y = (float)v28[5] * 0.125;
          pVecEnd.x = v29;
          pVecEnd.z = v30;
          m_pMat = pVehicle->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pVehicle->m_transform;
          v1.n64_u32[0] = CCollision::DistToLine(&pVecStart, &pVecEnd, &p_tx->m_translate);
          v13 = pVehicle->AutoPilot.OldNode;
          v33 = v1.n64_f32[0] < v2.n64_f32[0];
          v2.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
          if ( v33 )
            v16 = v19;
        }
      }
      ++v19;
      v14 = HIWORD(*(unsigned int *)&v13);
      v15 = ThePaths.pNodes[v13.Region];
    }
    while ( v19 < (*((_WORD *)&v15[HIWORD(*(unsigned int *)&v13)] + 12) & 0xF) );
  }
  else
  {
    v16 = -1;
  }
  v34 = v15[v14].IndexAdjacentNodes;
  if ( v16 <= 0 )
    v16 = 0;
  v18 = (char *)&ThePaths + 4 * v13.Region;
  v17 = v34 + v16;
LABEL_64:
  pVehicle->AutoPilot.OldLink.Address = *(_WORD *)(*((_DWORD *)v18 + 873) + 2 * v17);
  v35 = &ThePaths.pNodes[v13.Region][HIWORD(*(unsigned int *)&v13)];
  v36 = v13.Region;
  v37 = ThePaths.pAdjacentNodes[v13.Region];
  v38 = v16 + v35->IndexAdjacentNodes;
  v39 = v37[v38].Region;
  if ( v39 >= v36 )
  {
    if ( v39 == v36 )
    {
      v41 = &v37[v38];
      p_InvertDirOldLink = &pVehicle->AutoPilot.InvertDirOldLink;
      if ( v41->Index < (unsigned int)pVehicle->AutoPilot.OldNode.Index )
        goto LABEL_69;
    }
    else
    {
      p_InvertDirOldLink = &pVehicle->AutoPilot.InvertDirOldLink;
    }
    v42 = 1;
    goto LABEL_71;
  }
  p_InvertDirOldLink = &pVehicle->AutoPilot.InvertDirOldLink;
LABEL_69:
  v42 = -1;
LABEL_71:
  *p_InvertDirOldLink = v42;
}
// 2FB1C6: variable 'v1' is possibly undefined
// 2FB1C6: variable 'v2' is possibly undefined

//----- (002FB2C8) --------------------------------------------------------
CAutomobile *__fastcall CCarCtrl::GenerateOneEmergencyServicesCar(UInt32 ModelIndex, CVector TargetCoors)
{
  const CVector *PlayerCentreOfWorld; // r0
  RwReal z; // r6
  __int16 v4; // r11
  int v5; // r5
  int v6; // r0
  CAutomobile *v7; // r5
  RwReal v8; // r1
  CMatrix *m_pMat; // r3
  RwReal v10; // r0
  float v11; // s0
  float v12; // s2
  RwReal *p_tz; // r1
  float v14; // s2
  float v15; // s4
  float v16; // s6
  float v17; // s4
  float v18; // s16
  float DistanceFromCentreOfMassToBaseOfModel; // s0
  RwReal v20; // r0
  float v21; // s0
  CMatrix *v22; // r2
  float *p_z; // r0
  float y; // [sp+2Ch] [bp-94h]
  float x; // [sp+30h] [bp-90h]
  RwReal v28; // [sp+3Ch] [bp-84h]
  RwReal v29; // [sp+40h] [bp-80h]
  Int16 pNum; // [sp+46h] [bp-7Ah] BYREF
  CNodeAddress pToNode; // [sp+48h] [bp-78h] BYREF
  CNodeAddress pFromNode; // [sp+4Ch] [bp-74h] BYREF
  CVector Coors; // [sp+50h] [bp-70h] BYREF
  float pFraction; // [sp+5Ch] [bp-64h] BYREF
  CColPoint colPoint; // [sp+60h] [bp-60h] BYREF
  CEntity *refEntityPtr[13]; // [sp+8Ch] [bp-34h] BYREF
  CVector v37; // 0:r0.12

  y = TargetCoors.y;
  x = TargetCoors.x;
  pFromNode.Region = -1;
  pToNode.Region = -1;
  PlayerCentreOfWorld = FindPlayerCentreOfWorld(CWorld::PlayerInFocus);
  v29 = PlayerCentreOfWorld->x;
  v28 = PlayerCentreOfWorld->y;
  z = PlayerCentreOfWorld->z;
  v4 = 0;
  v5 = 0;
  do
  {
    v37.z = z;
    *(_QWORD *)&v37.x = __PAIR64__(LODWORD(v28), LODWORD(v29));
    if ( CCarCtrl::GenerateCarCreationCoors2(
           v37,
           0.707,
           0.707,
           -1.0,
           1,
           160.0,
           160.0,
           &Coors,
           &pFromNode,
           &pToNode,
           &pFraction,
           0,
           0) == 1
      && (*((_WORD *)&ThePaths.pNodes[pFromNode.Region][HIWORD(*(unsigned int *)&pFromNode)] + 12) & 0x80) == 0 )
    {
      CWorld::FindObjectsKindaColliding(&Coors, 10.0, 1, &pNum, 2, 0, 0, 1, 1, 0, 0);
      v5 |= pNum == 0;
    }
    v6 = v4;
    if ( v4 > 3 )
      break;
    ++v4;
  }
  while ( !(v5 << 31) );
  if ( v6 > 3 )
    return 0;
  v7 = (CAutomobile *)CVehicle::operator new(0x99Cu);
  CAutomobile::CAutomobile(v7, ModelIndex, 1u, 1u);
  v8 = Coors.y;
  m_pMat = v7->m_pMat;
  v10 = Coors.z;
  v11 = Coors.x;
  if ( m_pMat )
  {
    m_pMat->tx = Coors.x;
    v12 = v8;
    v7->m_pMat->ty = v8;
    p_tz = &v7->m_pMat->tz;
  }
  else
  {
    v7->m_transform.m_translate.x = Coors.x;
    v7->m_transform.m_translate.y = v8;
    p_tz = &v7->m_transform.m_translate.z;
    v12 = Coors.y;
  }
  *p_tz = v10;
  v14 = y - v12;
  v15 = x - v11;
  v16 = sqrtf((float)(v15 * v15) + (float)(v14 * v14));
  if ( v16 == 0.0 )
  {
    v17 = 1.0;
  }
  else
  {
    v14 = v14 / v16;
    v17 = v15 / v16;
  }
  v7->m_pMat->xy = v17;
  v7->m_pMat->yy = v14;
  v7->m_pMat->zy = 0.0;
  v7->m_pMat->xx = v14;
  v7->m_pMat->yx = -v17;
  v7->m_pMat->zx = 0.0;
  v7->m_pMat->xz = 0.0;
  v7->m_pMat->yz = 0.0;
  v7->m_pMat->zz = 1.0;
  Coors.z = (float)((float)((float)ThePaths.pNodes[pFromNode.Region][HIWORD(*(unsigned int *)&pFromNode)].CoorsZ * 0.125)
                  * (float)(1.0 - pFraction))
          + (float)(pFraction
                  * (float)((float)ThePaths.pNodes[pToNode.Region][HIWORD(*(unsigned int *)&pToNode)].CoorsZ * 0.125));
  v18 = 1000000000.0;
  if ( CWorld::ProcessVerticalLine(&Coors, 1000.0, &colPoint, refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    v18 = colPoint.m_vecPosition.z;
  if ( CWorld::ProcessVerticalLine(&Coors, -1000.0, &colPoint, refEntityPtr, 1, 0, 0, 0, 1, 0, 0)
    && fabsf(colPoint.m_vecPosition.z - Coors.z) < fabsf(v18 - Coors.z) )
  {
    v18 = colPoint.m_vecPosition.z;
  }
  if ( v18 == 1000000000.0 )
  {
    (*((void (__fastcall **)(CAutomobile *))v7->_vptr$CPlaceable + 1))(v7);
    return 0;
  }
  DistanceFromCentreOfMassToBaseOfModel = CEntity::GetDistanceFromCentreOfMassToBaseOfModel(v7);
  v20 = Coors.y;
  v21 = v18 + DistanceFromCentreOfMassToBaseOfModel;
  Coors.z = v21;
  v22 = v7->m_pMat;
  if ( v22 )
  {
    v22->tx = Coors.x;
    v7->m_pMat->ty = v20;
    p_z = &v7->m_pMat->tz;
  }
  else
  {
    v7->m_transform.m_translate.x = Coors.x;
    v7->m_transform.m_translate.y = v20;
    p_z = &v7->m_transform.m_translate.z;
  }
  *p_z = v21;
  v7->m_vecMoveSpeed.x = 0.0;
  v7->m_vecMoveSpeed.y = 0.0;
  v7->m_vecMoveSpeed.z = 0.0;
  CAutomobile::PlaceOnRoadProperly(v7);
  CWorld::Add(v7);
  if ( (int)ModelIndex <= 522 )
  {
    if ( ModelIndex == 407 )
    {
      *(_DWORD *)&v7->m_nVehicleFlags |= 4u;
      ++CCarCtrl::NumFireTrucksOnDuty;
      CCarAI::AddFiretruckOccupants(v7);
      goto LABEL_33;
    }
    if ( ModelIndex == 416 )
    {
      *(_DWORD *)&v7->m_nVehicleFlags |= 2u;
      ++CCarCtrl::NumAmbulancesOnDuty;
      CCarAI::AddAmbulanceOccupants(v7);
      goto LABEL_33;
    }
    if ( ModelIndex != 427 )
      return v7;
LABEL_32:
    CCarAI::AddPoliceCarOccupants(v7, 0);
LABEL_33:
    *((_DWORD *)&v7->m_nVehicleFlags + 1) |= 0x8000u;
    return v7;
  }
  if ( ModelIndex - 596 < 4 || ModelIndex == 523 )
    goto LABEL_32;
  return v7;
}

//----- (002FB68C) --------------------------------------------------------
int __fastcall CCarCtrl::ScriptGenerateOneEmergencyServicesCar(UInt32 a1, CVector a2)
{
  CAutomobile *OneEmergencyServicesCar; // r0
  CAutomobile *v3; // r4
  __int64 v4; // d16
  int v5; // r0
  char v6; // r1
  int result; // r0
  CVector v8; // [sp+0h] [bp-18h] BYREF

  v8 = a2;
  if ( CStreaming::ms_aInfoForModel[a1].m_status != 1 )
    return 0;
  OneEmergencyServicesCar = CCarCtrl::GenerateOneEmergencyServicesCar(a1, a2);
  v3 = OneEmergencyServicesCar;
  if ( !OneEmergencyServicesCar )
    return 0;
  v4 = *(_QWORD *)&v8.x;
  OneEmergencyServicesCar->AutoPilot.TargetCoors.z = v8.z;
  *(_QWORD *)&OneEmergencyServicesCar->AutoPilot.TargetCoors.x = v4;
  v5 = CCarCtrl::JoinCarWithRoadSystemGotoCoors(OneEmergencyServicesCar, &v8, 0, 0);
  v6 = 8;
  if ( v5 )
    v6 = 9;
  result = 1;
  v3->AutoPilot.Mission = v6;
  return result;
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002FB6EC) --------------------------------------------------------
void __fastcall CCarCtrl::UpdateCarCount(CVehicle *pVeh, UInt8 AddOrSub)
{
  int v2; // r1
  int **v3; // r0
  int **v4; // r0
  int *v5; // r0
  int v6; // r1
  int m_nVehicleFlags; // r1
  int v8; // r2
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r0

  if ( !AddOrSub )
  {
    switch ( pVeh->VehicleCreatedBy )
    {
      case 1u:
        if ( *(_BYTE *)&pVeh->m_nVehicleFlags << 31 )
          ++CCarCtrl::NumLawEnforcerCars;
        v4 = &CCarCtrl::NumRandomCars;
        goto LABEL_23;
      case 2u:
        m_nVehicleFlags = (int)pVeh->m_nVehicleFlags;
        if ( (m_nVehicleFlags & 1) != 0 )
        {
          v8 = *((_DWORD *)&pVeh->m_nVehicleFlags + 1);
          p_m_nVehicleFlags = &pVeh->m_nVehicleFlags;
          *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFFE;
          *((_DWORD *)p_m_nVehicleFlags + 1) = v8;
          --CCarCtrl::NumLawEnforcerCars;
        }
        v4 = &CCarCtrl::NumMissionCars;
        goto LABEL_23;
      case 3u:
        v4 = (int **)CCarCtrl::NumParkedCars;
        goto LABEL_23;
      case 4u:
        v4 = &CCarCtrl::NumPermanentVehicles;
LABEL_23:
        v5 = *v4;
        v6 = *v5 + 1;
        goto LABEL_24;
      default:
        return;
    }
  }
  switch ( pVeh->VehicleCreatedBy )
  {
    case 1u:
      if ( *(_BYTE *)&pVeh->m_nVehicleFlags << 31 )
      {
        v2 = CCarCtrl::NumLawEnforcerCars - 1;
        if ( CCarCtrl::NumLawEnforcerCars - 1 <= 0 )
          v2 = 0;
        CCarCtrl::NumLawEnforcerCars = v2;
      }
      v3 = &CCarCtrl::NumRandomCars;
      break;
    case 2u:
      v3 = &CCarCtrl::NumMissionCars;
      break;
    case 3u:
      v3 = (int **)CCarCtrl::NumParkedCars;
      break;
    case 4u:
      v3 = &CCarCtrl::NumPermanentVehicles;
      break;
  }
  v5 = *v3;
  v6 = *v5 - 1;
  if ( v6 <= 0 )
    v6 = 0;
LABEL_24:
  *v5 = v6;
}
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;
// 677AB4: using guessed type int CCarCtrl::NumParkedCars[2];
// 67816C: using guessed type int *CCarCtrl::NumMissionCars;
// 679B78: using guessed type int *CCarCtrl::NumPermanentVehicles;

//----- (002FB7D4) --------------------------------------------------------
bool __fastcall CCarCtrl::MapCouldMoveInThisArea(float TestX, float TestY)
{
  return 0;
}

//----- (002FB7D8) --------------------------------------------------------
bool __fastcall CCarCtrl::BoatWithTallMast(UInt32 MI)
{
  bool result; // r0

  result = 1;
  if ( MI != 454 && MI != 484 )
    return 0;
  return result;
}

//----- (002FB7F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CCarCtrl::ReconsiderRoute(CVehicle *pVeh)
{
  RwReal x; // r10
  int Region; // r0
  RwReal z; // r2
  int Index; // r6
  bool v6; // zf
  RwReal y; // r3
  int v8; // r5
  bool v9; // zf
  int v10; // r5
  bool v11; // zf
  UInt8 v12; // r0
  CEntity *pTargetEntity; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CMatrix *v16; // r1
  CSimpleTransform *p_m_transform; // r8
  RwReal v18; // r9
  CSimpleTransform *v19; // r0
  int bAmphibiousVehicle; // r1
  RwReal v21; // r2
  RwReal v22; // r12
  RwReal v23; // r0
  CNodeAddress v24; // r6
  RwReal v25; // r3
  CNodeAddress v26; // r0
  CMatrix *v27; // r0
  RwReal v28; // [sp+0h] [bp-80h]
  CVector TargetCoors; // [sp+8h] [bp-78h]
  CVector TargetCoorsa; // [sp+8h] [bp-78h]
  CVector pNumNodesGiven; // [sp+44h] [bp-3Ch] BYREF
  CVector pDistance; // [sp+50h] [bp-30h] BYREF
  CNodeAddress BestNewNode; // [sp+5Ch] [bp-24h] BYREF
  CNodeAddress BestOldNode; // [sp+60h] [bp-20h] BYREF

  if ( (CTimer::m_snTimeInMilliseconds + pVeh->RandomSeed) / 0x7D0 != (CTimer::m_snPreviousTimeInMilliseconds
                                                                     + pVeh->RandomSeed)
                                                                    / 0x7D0 )
  {
    switch ( pVeh->AutoPilot.Mission )
    {
      case 2:
      case 4:
      case 8:
      case 0xF:
      case 0x11:
      case 0x2B:
      case 0x34:
      case 0x36:
      case 0x3D:
        BestOldNode.Region = -1;
        BestNewNode.Region = -1;
        CCarCtrl::FindNodesThisCarIsNearestTo(pVeh, &BestOldNode, &BestNewNode);
        if ( BestOldNode.Region != 0xFFFF )
        {
          Region = pVeh->AutoPilot.OldNode.Region;
          if ( Region == BestOldNode.Region
            && pVeh->AutoPilot.OldNode.Index == BestOldNode.Index
            && pVeh->AutoPilot.NewNode.Region == BestNewNode.Region
            && pVeh->AutoPilot.NewNode.Index == BestNewNode.Index )
          {
            goto LABEL_30;
          }
          LODWORD(z) = BestNewNode.Region;
          if ( Region == BestNewNode.Region )
          {
            Index = pVeh->AutoPilot.OldNode.Index;
            v6 = Index == BestNewNode.Index;
            if ( Index == BestNewNode.Index )
              v6 = pVeh->AutoPilot.NewNode.Region == BestOldNode.Region;
            if ( v6 && pVeh->AutoPilot.NewNode.Index == BestOldNode.Index )
              goto LABEL_30;
          }
          LODWORD(y) = pVeh->AutoPilot.VeryOldNode.Region;
          if ( LODWORD(y) == BestOldNode.Region )
          {
            v8 = pVeh->AutoPilot.VeryOldNode.Index;
            v9 = v8 == BestOldNode.Index;
            if ( v8 == BestOldNode.Index )
              v9 = Region == BestNewNode.Region;
            if ( v9 && pVeh->AutoPilot.OldNode.Index == BestNewNode.Index )
              goto LABEL_30;
          }
          if ( LODWORD(y) == BestNewNode.Region )
          {
            v10 = pVeh->AutoPilot.VeryOldNode.Index;
            v11 = v10 == BestNewNode.Index;
            if ( v10 == BestNewNode.Index )
              v11 = Region == BestOldNode.Region;
            if ( v11 && pVeh->AutoPilot.OldNode.Index == BestOldNode.Index )
              goto LABEL_30;
          }
          if ( Region == BestNewNode.Region && pVeh->AutoPilot.OldNode.Index == BestNewNode.Index
            || LODWORD(y) == BestNewNode.Region && pVeh->AutoPilot.VeryOldNode.Index == BestNewNode.Index )
          {
            goto LABEL_30;
          }
          v12 = pVeh->AutoPilot.NumTimesWantingToChangeNodes + 1;
          pVeh->AutoPilot.NumTimesWantingToChangeNodes = v12;
          if ( v12 >= 5u )
          {
            switch ( pVeh->AutoPilot.Mission )
            {
              case 2:
              case 4:
              case 0x2B:
                FindPlayerCoors(&pDistance, -1);
                x = pDistance.x;
                y = pDistance.y;
                z = pDistance.z;
                break;
              case 8:
                y = pVeh->AutoPilot.TargetCoors.y;
                x = pVeh->AutoPilot.TargetCoors.x;
                z = pVeh->AutoPilot.TargetCoors.z;
                break;
              case 0xF:
              case 0x11:
              case 0x34:
              case 0x36:
              case 0x3D:
                pTargetEntity = pVeh->AutoPilot.pTargetEntity;
                m_pMat = pTargetEntity->m_pMat;
                p_tx = (CSimpleTransform *)&m_pMat->tx;
                if ( !m_pMat )
                  p_tx = &pTargetEntity->m_transform;
                y = p_tx->m_translate.y;
                x = p_tx->m_translate.x;
                z = p_tx->m_translate.z;
                break;
              default:
                break;
            }
            v16 = pVeh->m_pMat;
            p_m_transform = &pVeh->m_transform;
            v18 = z;
            v19 = &pVeh->m_transform;
            if ( v16 )
              v19 = (CSimpleTransform *)&v16->tx;
            bAmphibiousVehicle = 0;
            v22 = v19->m_translate.y;
            v21 = v19->m_translate.x;
            v23 = v19->m_translate.z;
            if ( pVeh->m_nModelIndex == 539 )
              bAmphibiousVehicle = 1;
            v24 = BestNewNode;
            pNumNodesGiven.x = x;
            v28 = v23;
            TargetCoors.x = x;
            pNumNodesGiven.y = y;
            *(_QWORD *)&TargetCoors.y = __PAIR64__(LODWORD(v18), LODWORD(y));
            v25 = v22;
            CPathFind::DoPathSearch(
              &ThePaths,
              0.0,
              *(CVector *)&v21,
              BestNewNode,
              TargetCoors,
              0,
              (Int16 *)&pNumNodesGiven.z + 1,
              0,
              &pDistance.x,
              1000000.0,
              0,
              1000000.0,
              (*(unsigned __int16 *)((char *)&pVeh->AutoPilot + 75) >> 6) & 1,
              pVeh->AutoPilot.OldNode,
              bAmphibiousVehicle,
              0);
            if ( pDistance.x < 90000.0 && SHIWORD(pNumNodesGiven.z) >= 2 )
            {
              v26 = BestOldNode;
              pVeh->AutoPilot.NewNode = v24;
              pVeh->AutoPilot.OldNode = v26;
              CCarCtrl::FindLinksToGoWithTheseNodes(pVeh);
              v27 = pVeh->m_pMat;
              if ( v27 )
                p_m_transform = (CSimpleTransform *)&v27->tx;
              *(_QWORD *)&TargetCoorsa.x = *(_QWORD *)&pNumNodesGiven.x;
              TargetCoorsa.z = v18;
              CPathFind::DoPathSearch(
                &ThePaths,
                0.0,
                p_m_transform->m_translate,
                v24,
                TargetCoorsa,
                pVeh->AutoPilot.aPathNodeList,
                &pVeh->AutoPilot.NumPathNodes,
                8,
                0,
                1000000.0,
                0,
                1000000.0,
                (*(unsigned __int16 *)((char *)&pVeh->AutoPilot + 75) >> 6) & 1,
                pVeh->AutoPilot.OldNode,
                pVeh->m_nModelIndex == 539,
                0);
              CAutoPilot::RemoveOnePathNode(&pVeh->AutoPilot);
            }
            pVeh->AutoPilot.NumTimesWantingToChangeNodes = 0;
          }
        }
        break;
      default:
LABEL_30:
        pVeh->AutoPilot.NumTimesWantingToChangeNodes = 0;
        break;
    }
  }
}
// 2FB7F0: fragmented variable at r2.4 may be wrong
// 2FB7F0: fragmented variable at r3.4 may be wrong

//----- (002FBB38) --------------------------------------------------------
void __fastcall CCarCtrl::FindNodesThisCarIsNearestTo(
        CVehicle *pVeh,
        CNodeAddress *BestOldNode,
        CNodeAddress *BestNewNode)
{
  int16x4_t v3; // d16
  CSimpleTransform *p_m_transform; // r4
  CMatrix *m_pMat; // r0
  float *p_x; // r1
  int XRegionForCoors; // r8
  CMatrix *v9; // r0
  CSimpleTransform *p_tx; // r1
  int YRegionForCoors; // r6
  CMatrix *v12; // r0
  float *v13; // r1
  float v14; // s16
  float XCoorsForRegion; // s0
  CMatrix *v16; // r0
  CSimpleTransform *v17; // r1
  float v18; // s16
  float y; // s18
  float YCoorsForRegion; // r0
  int v21; // r2
  float v22; // s2
  int v23; // r3
  int v24; // r6
  float v25; // s20
  int v26; // r0
  int v27; // r4
  char *v28; // r0
  int v29; // r1
  int *v30; // r2
  float *p_xx; // r0
  __int16 *v32; // r1
  __int16 *v33; // r8
  __int16 *v34; // r5
  float *v35; // r2
  unsigned __int64 v36; // d1
  int v37; // r9
  CNodeAddress v38; // r11
  CPathNode *v39; // r1
  __int16 *v40; // r4
  float v41; // s2
  float v42; // s4
  __int16 *v43; // r5
  float v44; // s4
  float *v45; // r1
  RwReal v46; // s2
  float v47; // s6
  float v48; // r10
  int v49; // r0
  int v50; // r1
  int v51; // r2
  RwReal v52; // s2
  RwReal v53; // s4
  int v57; // [sp+8h] [bp-F0h]
  int v58; // [sp+Ch] [bp-ECh]
  int v59; // [sp+14h] [bp-E4h]
  int v60; // [sp+18h] [bp-E0h]
  int v61; // [sp+24h] [bp-D4h]
  int *v62; // [sp+28h] [bp-D0h]
  _DWORD *v63; // [sp+2Ch] [bp-CCh]
  unsigned __int16 Region; // [sp+38h] [bp-C0h]
  unsigned __int16 v65; // [sp+3Ch] [bp-BCh]
  unsigned __int16 v66; // [sp+40h] [bp-B8h]
  int v67; // [sp+44h] [bp-B4h]
  CVehicle *v68; // [sp+48h] [bp-B0h]
  CSimpleTransform *v69; // [sp+50h] [bp-A8h]
  CNodeAddress **v70; // [sp+5Ch] [bp-9Ch]
  __int16 *v71; // [sp+60h] [bp-98h]
  int v72; // [sp+64h] [bp-94h]
  CVector v73; // [sp+6Ch] [bp-8Ch] BYREF
  CVector pPoint; // [sp+78h] [bp-80h] BYREF
  CVector pVecEnd; // [sp+88h] [bp-70h] BYREF
  CVector pVecStart; // [sp+94h] [bp-64h] BYREF

  p_m_transform = &pVeh->m_transform;
  m_pMat = pVeh->m_pMat;
  p_x = &p_m_transform->m_translate.x;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  XRegionForCoors = CPathFind::FindXRegionForCoors(&ThePaths, *p_x);
  v9 = pVeh->m_pMat;
  p_tx = p_m_transform;
  if ( v9 )
    p_tx = (CSimpleTransform *)&v9->tx;
  YRegionForCoors = CPathFind::FindYRegionForCoors(&ThePaths, p_tx->m_translate.y);
  v12 = pVeh->m_pMat;
  v13 = &p_m_transform->m_translate.x;
  if ( v12 )
    v13 = &v12->tx;
  v14 = *v13;
  v68 = pVeh;
  XCoorsForRegion = CPathFind::FindXCoorsForRegion(&ThePaths, XRegionForCoors);
  v16 = pVeh->m_pMat;
  v17 = p_m_transform;
  v69 = p_m_transform;
  v18 = v14 - XCoorsForRegion;
  if ( v16 )
    v17 = (CSimpleTransform *)&v16->tx;
  y = v17->m_translate.y;
  YCoorsForRegion = CPathFind::FindYCoorsForRegion(&ThePaths, YRegionForCoors);
  v21 = XRegionForCoors;
  v22 = y - YCoorsForRegion;
  v23 = YRegionForCoors;
  if ( v18 > 550.0 )
    v21 = XRegionForCoors + 1;
  if ( v21 >= 7 )
    v21 = 7;
  if ( v18 < 200.0 )
    --XRegionForCoors;
  if ( XRegionForCoors <= 0 )
    XRegionForCoors = 0;
  if ( v22 > 550.0 )
    v23 = YRegionForCoors + 1;
  if ( v23 >= 7 )
    v23 = 7;
  v59 = v23;
  if ( v22 < 200.0 )
    --YRegionForCoors;
  if ( YRegionForCoors <= 0 )
    YRegionForCoors = 0;
  v58 = YRegionForCoors;
  v65 = -1;
  v57 = v21;
  if ( XRegionForCoors <= v21 )
  {
    v24 = v23;
    v25 = 100000.0;
    Region = -1;
    do
    {
      v26 = v58;
      v60 = XRegionForCoors;
      if ( v58 <= v24 )
      {
        do
        {
          v61 = v26;
          v27 = XRegionForCoors + 8 * v26;
          v28 = (char *)&ThePaths + 4 * v27;
          v29 = *((_DWORD *)v28 + 513);
          if ( v29 )
          {
            v30 = (int *)((char *)&ThePaths + 4 * v27);
            if ( v30[1089] >= 1 )
            {
              v62 = (int *)(v28 + 2052);
              v63 = v30 + 1089;
              p_xx = &v68->m_pMat->xx;
              v70 = &ThePaths.pAdjacentNodes[v27];
              v66 = v27;
              v67 = 0;
              while ( 1 )
              {
                v32 = (__int16 *)(v29 + 28 * v67);
                v33 = v32 + 5;
                v34 = v32 + 4;
                v35 = &v69->m_translate.x;
                if ( p_xx )
                  v35 = p_xx + 12;
                v3.n64_u32[0] = *(_DWORD *)(v32 + 5);
                v3.n64_u64[0] = vsub_f32(
                                  vmul_f32(
                                    vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                                    (float32x2_t)0x3E0000003E000000LL),
                                  *(float32x2_t *)(v35 + 1)).n64_u64[0];
                v36 = vmul_f32(v3, v3).n64_u64[0];
                if ( sqrtf(
                       (float)((float)((float)((float)((float)v32[4] * 0.125) - *v35)
                                     * (float)((float)((float)v32[4] * 0.125) - *v35))
                             + *(float *)&v36)
                     + *((float *)&v36 + 1)) < 150.0 )
                {
                  v72 = v32[12] & 0xF;
                  if ( v72 )
                  {
                    v37 = 0;
                    v71 = v32 + 8;
                    do
                    {
                      v38 = (*v70)[*v71 + v37];
                      v39 = ThePaths.pNodes[v38.Region];
                      if ( v39 )
                      {
                        v40 = v34;
                        v41 = (float)*v34;
                        v42 = (float)v33[1];
                        v43 = (__int16 *)&v39[HIWORD(*(unsigned int *)&v38)];
                        pVecStart.y = (float)*v33 * 0.125;
                        pVecStart.x = v41 * 0.125;
                        pVecStart.z = v42 * 0.125;
                        v44 = (float)(v42 * 0.125) * 3.0;
                        v45 = &v69->m_translate.x;
                        v46 = (float)v43[4] * 0.125;
                        v47 = (float)v43[6] * 0.125;
                        pVecEnd.y = (float)v43[5] * 0.125;
                        pVecEnd.x = v46;
                        if ( p_xx )
                          v45 = p_xx + 12;
                        v3.n64_u64[0] = *(unsigned __int64 *)v45;
                        pPoint.z = v45[2];
                        pVecStart.z = v44;
                        pVecEnd.z = v47 * 3.0;
                        *(int16x4_t *)&pPoint.x = v3;
                        pPoint.z = pPoint.z * 3.0;
                        v48 = CCollision::DistToLine(&pVecStart, &pVecEnd, &pPoint);
                        v49 = v43[4];
                        v50 = v43[5];
                        v51 = v43[6];
                        v34 = v40;
                        v52 = (float)((float)v49 * 0.125) - (float)((float)*v40 * 0.125);
                        v53 = (float)((float)v51 * 0.125) - (float)((float)v33[1] * 0.125);
                        v73.y = (float)((float)v50 * 0.125) - (float)((float)*v33 * 0.125);
                        v73.x = v52;
                        v73.z = v53;
                        CVector::Normalise(&v73);
                        p_xx = &v68->m_pMat->xx;
                        if ( (float)(v48
                                   + (float)((float)(1.0
                                                   - (float)((float)((float)(v73.x * p_xx[4]) + (float)(v73.y * p_xx[5]))
                                                           + (float)(v73.z * p_xx[6])))
                                           * 5.0)) < v25 )
                        {
                          v25 = v48
                              + (float)((float)(1.0
                                              - (float)((float)((float)(v73.x * p_xx[4]) + (float)(v73.y * p_xx[5]))
                                                      + (float)(v73.z * p_xx[6])))
                                      * 5.0);
                          v65 = v66;
                          Region = v38.Region;
                        }
                      }
                      ++v37;
                    }
                    while ( v72 != v37 );
                  }
                }
                if ( ++v67 >= *v63 )
                  break;
                v29 = *v62;
              }
              v24 = v59;
              XRegionForCoors = v60;
            }
          }
          v26 = v61 + 1;
        }
        while ( v61 < v24 );
      }
    }
    while ( XRegionForCoors++ < v57 );
  }
  else
  {
    Region = -1;
  }
  *BestOldNode = (CNodeAddress)v65;
  *BestNewNode = (CNodeAddress)Region;
}
// 2FBD2A: variable 'v3' is possibly undefined

//----- (002FBFC0) --------------------------------------------------------
bool __fastcall CCarCtrl::IsPoliceVehicleInPursuit(Int32 Range)
{
  CVehiclePool *v1; // r5
  int32 m_nSize; // r1
  int v3; // r4
  float v4; // s16
  int v5; // r6
  uint8 *v6; // r8
  bool v7; // zf
  uint8 *v8; // r0
  int v9; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1
  bool result; // r0
  CVector v13; // [sp+4h] [bp-34h] BYREF

  v1 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  v3 = m_nSize;
  v4 = (float)Range;
  v5 = m_nSize - 1;
  while ( 1 )
  {
    if ( (v1->m_aFlags[v5] & 0x80u) == 0 )
    {
      v6 = v1->m_aStorage[v3];
      v7 = v6 == (uint8 *)&elf_hash_bucket[588];
      if ( v6 != (uint8 *)&elf_hash_bucket[588] )
        v7 = *(v6 - 1536) << 31 == 0;
      if ( !v7 )
        break;
    }
LABEL_11:
    --v5;
    --v3;
    if ( v5 == -1 )
      return 0;
  }
  switch ( *(v6 - 1646) )
  {
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 0x15u:
    case 0x17u:
    case 0x1Au:
    case 0x23u:
    case 0x28u:
    case 0x2Bu:
    case 0x2Cu:
    case 0x3Bu:
    case 0x40u:
      FindPlayerCoors(&v13, -1);
      v8 = v6 - 2600;
      v9 = *((_DWORD *)v6 - 646);
      if ( v9 )
        v8 = (uint8 *)(v9 + 48);
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&v13.y, *(float32x2_t *)(v8 + 4)).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(v13.x - *(float *)v8) * (float)(v13.x - *(float *)v8)) + *(float *)&v11)
           + *((float *)&v11 + 1)) > v4 )
        goto LABEL_11;
      result = 1;
      break;
    default:
      goto LABEL_11;
  }
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002FC0EC) --------------------------------------------------------
bool __fastcall CCamera::IsSphereVisible(CCamera *this, const CVector *posn, float radius)
{
  float m_sphereMapRadius; // s0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  bool result; // r0
  float32x2_t v10; // d16
  unsigned __int64 v11; // d3
  RwReal y; // r1
  RwReal z; // r2
  RwReal v14; // r1
  RwReal v15; // r2
  RwV3d_0 pointsIn; // [sp+4h] [bp-1Ch] BYREF

  m_sphereMapRadius = this->m_sphereMapRadius;
  if ( m_sphereMapRadius == 0.0 )
  {
    y = posn->y;
    z = posn->z;
    pointsIn.x = posn->x;
    pointsIn.y = y;
    pointsIn.z = z;
    RwV3dTransformPoints(&pointsIn, &pointsIn, 1, (const RwMatrix *)&this->m_matInverse);
    if ( (float)(pointsIn.y + radius) < CDraw::ms_fNearClipZ
      || (float)(pointsIn.y - radius) > CDraw::ms_fFarClipZ
      || (float)((float)(pointsIn.x * this->m_vecFrustumNormals[0].x)
               + (float)(pointsIn.y * this->m_vecFrustumNormals[0].y)) > radius
      || (float)((float)(pointsIn.x * this->m_vecFrustumNormals[1].x)
               + (float)(pointsIn.y * this->m_vecFrustumNormals[1].y)) > radius
      || (float)((float)(pointsIn.y * this->m_vecFrustumNormals[2].y)
               + (float)(pointsIn.z * this->m_vecFrustumNormals[2].z)) > radius
      || (float)((float)(pointsIn.y * this->m_vecFrustumNormals[3].y)
               + (float)(pointsIn.z * this->m_vecFrustumNormals[3].z)) > radius )
    {
      if ( this->m_bMirrorActive
        && (v14 = posn->y,
            v15 = posn->z,
            pointsIn.x = posn->x,
            pointsIn.y = v14,
            pointsIn.z = v15,
            RwV3dTransformPoints(&pointsIn, &pointsIn, 1, (const RwMatrix *)&this->m_matMirrorInverse),
            (float)(pointsIn.y + radius) >= CDraw::ms_fNearClipZ)
        && (float)(pointsIn.y - radius) <= CDraw::ms_fFarClipZ
        && (float)((float)(pointsIn.x * this->m_vecFrustumNormals[0].x)
                 + (float)(pointsIn.y * this->m_vecFrustumNormals[0].y)) <= radius
        && (float)((float)(pointsIn.x * this->m_vecFrustumNormals[1].x)
                 + (float)(pointsIn.y * this->m_vecFrustumNormals[1].y)) <= radius )
      {
        result = 0;
        if ( (float)((float)(pointsIn.y * this->m_vecFrustumNormals[2].y)
                   + (float)(pointsIn.z * this->m_vecFrustumNormals[2].z)) <= radius
          && (float)((float)(pointsIn.y * this->m_vecFrustumNormals[3].y)
                   + (float)(pointsIn.z * this->m_vecFrustumNormals[3].z)) <= radius )
        {
          return 1;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    result = 0;
    v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&posn->y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v11 = vmul_f32(v10, v10).n64_u64[0];
    if ( (float)((float)((float)((float)(posn->x - p_tx->m_translate.x) * (float)(posn->x - p_tx->m_translate.x))
                       + *(float *)&v11)
               + *((float *)&v11 + 1)) < (float)((float)(radius * radius) + m_sphereMapRadius) )
      return 1;
  }
  return result;
}

//----- (002FC360) --------------------------------------------------------
void __fastcall CCarCtrl::WeaveForOtherCar(CEntity *pEntity, CVehicle *pVehicle, float *pLeftAngle, float *pRightAngle)
{
  int Mission; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v8; // r0
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r3
  float v11; // s20
  float v12; // s22
  float v13; // s0
  float v14; // s24
  CColModel *m_pColModel; // r0
  float x; // s2
  float v17; // s4
  float y; // s4
  CMatrix *v19; // r1
  CColModel *v20; // r0
  float v21; // s2
  float v22; // s0
  CMatrix *v23; // r1
  CColModel *v24; // r0
  float v25; // s2
  RwReal v26; // s0
  float v27; // s2
  RwReal v28; // s0
  CMatrix *v29; // r1
  CColModel *v30; // r0
  float v31; // s2
  float v32; // s0
  CMatrix *v33; // r1
  float v34; // s4
  float v35; // s20
  CColModel *v36; // r0
  float v37; // s0
  float v38; // s2
  CMatrix *v39; // r1
  CColModel *v40; // r0
  float v41; // s2
  float v42; // s0
  CMatrix *v43; // r1
  CColModel *v44; // r0
  float v45; // s2
  RwReal v46; // s0
  float v47; // s2
  RwReal v48; // s0
  CMatrix *v49; // r1
  CColModel *v50; // r0
  float v51; // s0
  float v52; // s2
  int v53; // r10
  float v54; // s20
  float v55; // s18
  float v56; // s16
  float v57; // s0
  int v58; // r4
  float v59; // s0
  CVector v62; // [sp+2Ch] [bp-ECh] BYREF
  CVector v63; // [sp+38h] [bp-E0h] BYREF
  CVector v64; // [sp+48h] [bp-D0h] BYREF
  CVector v65; // [sp+58h] [bp-C0h] BYREF
  CVector pLine2Start_Other; // [sp+68h] [bp-B0h] BYREF
  CVector pLine1Start_Other; // [sp+78h] [bp-A0h] BYREF
  CVector pLine2Delta; // [sp+88h] [bp-90h] BYREF
  CVector v; // [sp+98h] [bp-80h] BYREF
  CVector pLine2Start; // [sp+A8h] [bp-70h] BYREF
  CVector pLine1Start; // [sp+B8h] [bp-60h] BYREF

  Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
  if ( Mission == 3 )
  {
    if ( FindPlayerVehicle(-1, 0) == pEntity )
      return;
    Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
  }
  if ( Mission == 55 )
  {
    if ( (*(_BYTE *)&pEntity->m_info & 7) == 3
      && BYTE1(pEntity[19].m_transform.m_heading) << 31
      && pEntity[23].m_pLastRenderedLink == (CLink<CEntity *> *)pVehicle->AutoPilot.pTargetEntity )
    {
      return;
    }
  }
  else if ( Mission == 53 )
  {
    if ( pVehicle->AutoPilot.pTargetEntity == pEntity
      || (*(_BYTE *)&pEntity->m_info & 7) == 2 && (pEntity[17].m_areaCode & 8) != 0 )
    {
      return;
    }
  }
  else if ( Mission == 16 && pVehicle->AutoPilot.pTargetEntity == pEntity )
  {
    return;
  }
  if ( (unsigned __int8)(*(_BYTE *)&pEntity[15].m_info - 27) > 5u || *(CVehicle **)&pEntity[17].RandomSeed != pVehicle )
  {
    m_pMat = pVehicle->m_pMat;
    v8 = pEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pVehicle->m_transform;
    p_m_transform = (CSimpleTransform *)&v8->tx;
    if ( !v8 )
      p_m_transform = &pEntity->m_transform;
    v11 = p_m_transform->m_translate.x - p_tx->m_translate.x;
    v12 = p_m_transform->m_translate.y - p_tx->m_translate.y;
    v13 = (float)(v11 * m_pMat->xy) + (float)(v12 * m_pMat->yy);
    if ( v13 >= 0.0 )
    {
      v14 = (float)(v11 * m_pMat->xx) + (float)(v12 * m_pMat->yx);
      m_pColModel = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel;
      if ( v13 <= 0.0 )
      {
        y = m_pColModel->m_boxBound.m_vecMin.y;
        x = m_pColModel->m_boxBound.m_vecMin.x;
        v.z = 0.0;
        v.y = y + -0.2;
      }
      else
      {
        x = m_pColModel->m_boxBound.m_vecMin.x;
        v17 = m_pColModel->m_boxBound.m_vecMax.y;
        v.z = 0.0;
        v.y = v17 + 0.2;
      }
      v.x = x + -0.2;
      operator*(&pLine2Start, m_pMat, &v);
      pLine1Start = pLine2Start;
      v19 = pVehicle->m_pMat;
      v20 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel;
      v21 = v20->m_boxBound.m_vecMax.x;
      v22 = v20->m_boxBound.m_vecMin.x;
      pLine2Delta.y = 0.0;
      pLine2Delta.z = 0.0;
      pLine2Delta.x = (float)((float)(v21 + 0.2) - v22) + -0.2;
      Multiply3x3(&pLine2Start, v19, &pLine2Delta);
      v = pLine2Start;
      v23 = pVehicle->m_pMat;
      v24 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel;
      if ( v14 <= 0.0 )
      {
        v27 = v24->m_boxBound.m_vecMin.y;
        v28 = v24->m_boxBound.m_vecMin.x + -0.2;
        pLine1Start_Other.z = 0.0;
        pLine1Start_Other.y = v27 + -0.2;
        pLine1Start_Other.x = v28;
      }
      else
      {
        v25 = v24->m_boxBound.m_vecMax.x;
        v26 = v24->m_boxBound.m_vecMin.y + -0.2;
        pLine1Start_Other.z = 0.0;
        pLine1Start_Other.y = v26;
        pLine1Start_Other.x = v25 + 0.2;
      }
      operator*(&pLine2Delta, v23, &pLine1Start_Other);
      pLine2Start = pLine2Delta;
      v29 = pVehicle->m_pMat;
      v30 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel;
      v31 = v30->m_boxBound.m_vecMax.y;
      v32 = v30->m_boxBound.m_vecMin.y;
      pLine2Start_Other.x = 0.0;
      pLine2Start_Other.z = 0.0;
      pLine2Start_Other.y = (float)((float)(v31 + 0.2) - v32) + -0.2;
      Multiply3x3(&pLine1Start_Other, v29, &pLine2Start_Other);
      pLine2Delta = pLine1Start_Other;
      v33 = pEntity->m_pMat;
      v34 = (float)(v11 * v33->xy) + (float)(v12 * v33->yy);
      v35 = (float)(v11 * v33->xx) + (float)(v12 * v33->yx);
      v36 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
      v37 = v36->m_boxBound.m_vecMin.x;
      if ( v34 >= 0.0 )
        v38 = v36->m_boxBound.m_vecMin.y + -0.2;
      else
        v38 = v36->m_boxBound.m_vecMax.y + 0.2;
      v65.z = 0.0;
      v65.y = v38;
      v65.x = v37 + -0.2;
      operator*(&pLine2Start_Other, v33, &v65);
      pLine1Start_Other = pLine2Start_Other;
      v39 = pEntity->m_pMat;
      v40 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
      v41 = v40->m_boxBound.m_vecMax.x;
      v42 = v40->m_boxBound.m_vecMin.x;
      v64.y = 0.0;
      v64.z = 0.0;
      v64.x = (float)((float)(v41 + 0.2) - v42) + -0.2;
      Multiply3x3(&pLine2Start_Other, v39, &v64);
      v65 = pLine2Start_Other;
      v43 = pEntity->m_pMat;
      v44 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
      if ( v35 >= 0.0 )
      {
        v47 = v44->m_boxBound.m_vecMin.y;
        v48 = v44->m_boxBound.m_vecMin.x + -0.2;
        v63.z = 0.0;
        v63.y = v47 + -0.2;
        v63.x = v48;
      }
      else
      {
        v45 = v44->m_boxBound.m_vecMax.x;
        v46 = v44->m_boxBound.m_vecMin.y + -0.2;
        v63.z = 0.0;
        v63.y = v46;
        v63.x = v45 + 0.2;
      }
      operator*(&v64, v43, &v63);
      pLine2Start_Other = v64;
      v49 = pEntity->m_pMat;
      v50 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
      v51 = v50->m_boxBound.m_vecMin.y;
      v52 = v50->m_boxBound.m_vecMax.y + 0.2;
      v62.x = 0.0;
      v62.z = 0.0;
      v62.y = (float)(v52 - v51) + -0.2;
      Multiply3x3(&v63, v49, &v62);
      v64 = v63;
      v53 = -1;
      v54 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x;
      v55 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x;
      v56 = sqrtf(
              (float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
            + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y));
      v57 = *pLeftAngle;
      do
      {
        if ( !TestForThisAngle(
                v57,
                &pLine1Start,
                &v,
                &pLine2Start,
                &pLine2Delta,
                &pLine1Start_Other,
                &v65,
                &pLine2Start_Other,
                &v64,
                pEntity[1].m_transform.m_translate.z,
                pEntity[1].m_transform.m_heading,
                v56,
                v54 < v55) )
          break;
        ++v53;
        v57 = *pLeftAngle + -0.10472;
        if ( v57 < 0.0 )
          v57 = v57 + 6.2832;
        *pLeftAngle = v57;
      }
      while ( v53 < 7 );
      v58 = -1;
      v59 = *pRightAngle;
      do
      {
        if ( TestForThisAngle(
               v59,
               &pLine1Start,
               &v,
               &pLine2Start,
               &pLine2Delta,
               &pLine1Start_Other,
               &v65,
               &pLine2Start_Other,
               &v64,
               pEntity[1].m_transform.m_translate.z,
               pEntity[1].m_transform.m_heading,
               v56,
               v54 < v55) != 1 )
          break;
        ++v58;
        v59 = *pRightAngle + 0.10472;
        if ( v59 > 6.2832 )
          v59 = v59 + -6.2832;
        *pRightAngle = v59;
      }
      while ( v58 < 7 );
    }
  }
}

//----- (002FC92C) --------------------------------------------------------
void __fastcall CCarCtrl::WeaveForPed(CEntity *pEntity, CVehicle *pVehicle, float *pLeftAngle, float *pRightAngle)
{
  int Mission; // r0
  bool v9; // zf
  CMatrix *m_pMat; // r0
  CMatrix *v11; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r0
  float y; // s2
  float v15; // s6
  float v16; // s16
  float ATanOfXY; // r0
  float v18; // s2
  float i; // s6
  float j; // s8
  float v21; // s12
  float v22; // s6
  float v23; // s8
  float k; // s8
  float v25; // s0

  Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
  if ( Mission == 3 )
  {
    if ( FindPlayerPed(-1) == pEntity )
      return;
    Mission = (unsigned __int8)pVehicle->AutoPilot.Mission;
  }
  v9 = Mission == 55;
  if ( Mission == 55 )
    v9 = pVehicle->AutoPilot.pTargetEntity == pEntity;
  if ( !v9 )
  {
    m_pMat = pVehicle->m_pMat;
    v11 = pEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pVehicle->m_transform;
    p_m_transform = (CSimpleTransform *)&v11->tx;
    y = p_tx->m_translate.y;
    if ( !v11 )
      p_m_transform = &pEntity->m_transform;
    v15 = p_m_transform->m_translate.y;
    v16 = p_m_transform->m_translate.x - p_tx->m_translate.x;
    ATanOfXY = CGeneral::GetATanOfXY(v16, v15 - y);
    v18 = sqrtf((float)(v16 * v16) + (float)((float)(v15 - y) * (float)(v15 - y)));
    if ( v18 >= 1.0 )
    {
      for ( i = ATanOfXY - *pLeftAngle; i < -3.1416; i = i + 6.2832 )
        ;
      for ( j = (float)((float)(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x
                              * 2.4)
                      + 0.8)
              / v18; i > 3.1416; i = i + -6.2832 )
        ;
      v21 = fabsf(i);
      v22 = j * 0.5;
      if ( v21 < (float)(j * 0.5) )
      {
        v23 = ATanOfXY - v22;
        *pLeftAngle = ATanOfXY - v22;
        if ( (float)(ATanOfXY - v22) < -3.1416 )
        {
          do
            v23 = v23 + 6.2832;
          while ( v23 < -3.1416 );
          *pLeftAngle = v23;
        }
      }
      for ( k = ATanOfXY - *pRightAngle; k < -3.1416; k = k + 6.2832 )
        ;
      for ( ; k > 3.1416; k = k + -6.2832 )
        ;
      if ( fabsf(k) < v22 )
      {
        v25 = ATanOfXY + v22;
        *pRightAngle = ATanOfXY + v22;
        if ( (float)(ATanOfXY + v22) > 3.1416 )
        {
          do
            v25 = v25 + -6.2832;
          while ( v25 > 3.1416 );
          *pRightAngle = v25;
        }
      }
    }
  }
}

//----- (002FCB14) --------------------------------------------------------
void __fastcall CCarCtrl::WeaveForObject(CEntity *pEntity, CVehicle *pVehicle, float *pLeftAngle, float *pRightAngle)
{
  int m_nModelIndex; // r0
  float v9; // s18
  float v10; // s16
  int v11; // r2
  int v12; // r1
  int v13; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  float x; // s22
  float y; // s20
  float v18; // s24
  float v19; // s22
  float v20; // s18
  float yx; // s0
  CMatrix *v22; // r0
  float v23; // s0
  CSimpleTransform *p_tx; // r1
  float v25; // s4
  float v26; // s16
  float v27; // s0
  float ATanOfXY; // r0
  float v29; // s2
  float i; // s6
  float j; // s8
  float v32; // s12
  float v33; // s6
  float v34; // s8
  float k; // s8
  float v36; // s0

  m_nModelIndex = pEntity->m_nModelIndex;
  if ( m_nModelIndex == MI_TRAFFICLIGHTS )
  {
    v9 = 0.147;
    v10 = 2.957;
    goto LABEL_17;
  }
  v9 = 0.0;
  if ( m_nModelIndex == MI_SINGLESTREETLIGHTS1 )
  {
    v10 = 0.744;
    goto LABEL_17;
  }
  if ( m_nModelIndex == MI_SINGLESTREETLIGHTS2 )
  {
    v10 = 0.043;
    goto LABEL_17;
  }
  if ( m_nModelIndex == MI_SINGLESTREETLIGHTS3 )
  {
    v9 = 0.145;
    v10 = 1.143;
    goto LABEL_17;
  }
  if ( m_nModelIndex == MI_DOUBLESTREETLIGHTS )
  {
    v9 = -0.048;
    v10 = 0.0;
    goto LABEL_17;
  }
  v11 = 0;
  v12 = 0;
  v13 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_flags & 0x7800;
  if ( v13 != 2048 )
    v11 = 1;
  if ( v13 == 4096 )
    v12 = 1;
  if ( v12 == v11 )
  {
    v10 = 0.0;
    v9 = 0.0;
LABEL_17:
    m_pMat = pEntity->m_pMat;
    p_m_transform = &pEntity->m_transform;
    if ( m_pMat )
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    x = p_m_transform->m_translate.x;
    y = p_m_transform->m_translate.y;
    if ( m_pMat )
    {
      v18 = v9 * m_pMat->xy;
    }
    else
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
      v18 = v9 * m_pMat->xy;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        m_pMat = pEntity->m_pMat;
        v19 = x + (float)(v18 + (float)(v10 * m_pMat->xx));
        if ( !m_pMat )
        {
          CPlaceable::AllocateMatrix(pEntity);
          CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
          m_pMat = pEntity->m_pMat;
          v20 = v9 * m_pMat->yy;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          goto LABEL_24;
        }
LABEL_23:
        v20 = v9 * m_pMat->yy;
LABEL_24:
        yx = m_pMat->yx;
        v22 = pVehicle->m_pMat;
        v23 = v10 * yx;
        p_tx = (CSimpleTransform *)&v22->tx;
        if ( !v22 )
          p_tx = &pVehicle->m_transform;
        v25 = p_tx->m_translate.y;
        v26 = v19 - p_tx->m_translate.x;
        v27 = y + (float)(v20 + v23);
        ATanOfXY = CGeneral::GetATanOfXY(v26, v27 - v25);
        v29 = sqrtf((float)(v26 * v26) + (float)((float)(v27 - v25) * (float)(v27 - v25)));
        for ( i = ATanOfXY - *pLeftAngle; i < -3.1416; i = i + 6.2832 )
          ;
        for ( j = (float)((float)(CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x
                                * 2.4)
                        + 0.3)
                / v29; i > 3.1416; i = i + -6.2832 )
          ;
        v32 = fabsf(i);
        v33 = j * 0.5;
        if ( v32 < (float)(j * 0.5) )
        {
          v34 = ATanOfXY - v33;
          *pLeftAngle = ATanOfXY - v33;
          if ( (float)(ATanOfXY - v33) < -3.1416 )
          {
            do
              v34 = v34 + 6.2832;
            while ( v34 < -3.1416 );
            *pLeftAngle = v34;
          }
        }
        for ( k = ATanOfXY - *pRightAngle; k < -3.1416; k = k + 6.2832 )
          ;
        for ( ; k > 3.1416; k = k + -6.2832 )
          ;
        if ( fabsf(k) < v33 )
        {
          v36 = ATanOfXY + v33;
          *pRightAngle = ATanOfXY + v33;
          if ( (float)(ATanOfXY + v33) > 3.1416 )
          {
            do
              v36 = v36 + -6.2832;
            while ( v36 > 3.1416 );
            *pRightAngle = v36;
          }
        }
        return;
      }
    }
    v19 = x + (float)(v18 + (float)(v10 * m_pMat->xx));
    goto LABEL_23;
  }
}

//----- (002FCE48) --------------------------------------------------------
void __fastcall CEventAcquaintancePedHate::~CEventAcquaintancePedHate(CEventAcquaintancePedHate *this)
{
  void *v1; // r0

  CEventAcquaintancePed::~CEventAcquaintancePed(this);
  sub_1978E4(v1);
}
// 2FCE54: variable 'v1' is possibly undefined

//----- (002FCE58) --------------------------------------------------------
int __fastcall CEventAcquaintancePedHate::GetEventType(const CEventAcquaintancePedHate *this)
{
  return 36;
}

//----- (002FCE5C) --------------------------------------------------------
int __fastcall CEventAcquaintancePedHate::GetEventPriority(const CEventAcquaintancePedHate *this)
{
  return 26;
}

//----- (002FCE60) --------------------------------------------------------
int __fastcall CEventAcquaintancePed::GetLifeTime(const CEventAcquaintancePed *this)
{
  return 0;
}

//----- (002FCE64) --------------------------------------------------------
CEvent *__fastcall CEventEditableResponse::Clone(const CEventEditableResponse *this)
{
  CEvent *result; // r0

  result = (CEvent *)(*((int (__fastcall **)(const CEventEditableResponse *))this->_vptr$CEvent + 17))(this);
  *((_WORD *)&result->m_bIsPersistent + 1) = this->m_iTaskType;
  LOWORD(result[1]._vptr$CEvent) = this->m_iFacialTaskType;
  *(&result->m_bIsPersistent + 1) = this->m_bWitnessedFirstHand;
  return result;
}

//----- (002FCE80) --------------------------------------------------------
bool __fastcall CEvent::IsCriminalEvent(const CEvent *this)
{
  return 0;
}

//----- (002FCE86) --------------------------------------------------------
bool __fastcall CEventEditableResponse::HasEditableResponse(const CEventEditableResponse *this)
{
  return 1;
}

//----- (002FCE8A) --------------------------------------------------------
CEntity *__fastcall CEventAcquaintancePed::GetSourceEntity(const CEventAcquaintancePed *this)
{
  return this->m_pAcquaintancePed;
}

//----- (002FCE8E) --------------------------------------------------------
float __fastcall CEvent::GetLocalSoundLevel(const CEvent *this)
{
  return 0.0;
}

//----- (002FCE92) --------------------------------------------------------
bool __fastcall CEvent::DoInformVehicleOccupants(const CEvent *this, CPed *pPed)
{
  return 0;
}

//----- (002FCE96) --------------------------------------------------------
bool __fastcall CEventAcquaintancePed::CanBeInterruptedBySameEvent(const CEventAcquaintancePed *this)
{
  return 1;
}

//----- (002FCE9C) --------------------------------------------------------
CEvent *__fastcall CEventAcquaintancePedHate::CloneEditable(const CEventAcquaintancePedHate *this)
{
  CEventAcquaintancePed *v2; // r0
  CEvent *result; // r0

  v2 = (CEventAcquaintancePed *)CEvent::operator new(0x14u);
  CEventAcquaintancePed::CEventAcquaintancePed(v2, this->m_pAcquaintancePed);
  result->_vptr$CEvent = (int (**)(void))&off_665394;
  return result;
}
// 2FCEB6: variable 'result' is possibly undefined
// 665394: using guessed type void *off_665394;
// 676218: using guessed type void *`vtable for'CEventAcquaintancePedHate;

//----- (002FCEC0) --------------------------------------------------------
int IsCheatMenuOpen()
{
  return 0;
}

//----- (002FCEC4) --------------------------------------------------------
void CCheat::WeaponCheat1()
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v1; // r0
  CPlayerPed *v2; // r0
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0
  CPlayerPed *v5; // r0
  CPlayerPed *v6; // r0
  CPlayerPed *v7; // r0
  CPlayerPed *v8; // r0
  CPlayerPed *v9; // r0
  CPlayerPed *v10; // r0
  CPlayerPed *v11; // r0
  CPlayerPed *v12; // r0
  CPlayerPed *v13; // r0
  CPlayerPed *v14; // r0
  CPlayerPed *v15; // r0
  CPlayerPed *v16; // r0
  CPlayerPed *v17; // r0
  CPlayerPed *v18; // r0
  CPlayerPed *v19; // r0

  CStreaming::RequestModel(331, 2);
  CStreaming::RequestModel(336, 2);
  CStreaming::RequestModel(344, 2);
  CStreaming::RequestModel(346, 2);
  CStreaming::RequestModel(349, 2);
  CStreaming::RequestModel(352, 2);
  CStreaming::RequestModel(355, 2);
  CStreaming::RequestModel(357, 2);
  CStreaming::RequestModel(359, 2);
  CStreaming::RequestModel(365, 2);
  CStreaming::LoadAllRequestedModels(0);
  PlayerPed = FindPlayerPed(-1);
  CPed::GiveWeapon(PlayerPed, WEAPONTYPE_BRASSKNUCKLE, 1u, 1);
  v1 = FindPlayerPed(-1);
  CPed::GiveWeapon(v1, WEAPONTYPE_BASEBALLBAT, 1u, 1);
  v2 = FindPlayerPed(-1);
  CPed::GiveWeapon(v2, WEAPONTYPE_MOLOTOV, 0xAu, 1);
  v3 = FindPlayerPed(-1);
  CPed::GiveWeapon(v3, WEAPONTYPE_PISTOL, 0x64u, 1);
  v4 = FindPlayerPed(-1);
  CPed::GiveWeapon(v4, WEAPONTYPE_SHOTGUN, 0x32u, 1);
  v5 = FindPlayerPed(-1);
  CPed::GiveWeapon(v5, WEAPONTYPE_MICRO_UZI, 0x96u, 1);
  v6 = FindPlayerPed(-1);
  CPed::GiveWeapon(v6, WEAPONTYPE_AK47, 0x78u, 1);
  v7 = FindPlayerPed(-1);
  CPed::GiveWeapon(v7, WEAPONTYPE_COUNTRYRIFLE, 0x19u, 1);
  v8 = FindPlayerPed(-1);
  CPed::GiveWeapon(v8, WEAPONTYPE_ROCKETLAUNCHER, 0xC8u, 1);
  v9 = FindPlayerPed(-1);
  CPed::GiveWeapon(v9, WEAPONTYPE_SPRAYCAN, 0xC8u, 1);
  if ( FindPlayerPed(1) )
  {
    v10 = FindPlayerPed(1);
    CPed::GiveWeapon(v10, WEAPONTYPE_BRASSKNUCKLE, 1u, 1);
    v11 = FindPlayerPed(1);
    CPed::GiveWeapon(v11, WEAPONTYPE_BASEBALLBAT, 1u, 1);
    v12 = FindPlayerPed(1);
    CPed::GiveWeapon(v12, WEAPONTYPE_MOLOTOV, 0xAu, 1);
    v13 = FindPlayerPed(1);
    CPed::GiveWeapon(v13, WEAPONTYPE_PISTOL, 0x64u, 1);
    v14 = FindPlayerPed(1);
    CPed::GiveWeapon(v14, WEAPONTYPE_SHOTGUN, 0x32u, 1);
    v15 = FindPlayerPed(1);
    CPed::GiveWeapon(v15, WEAPONTYPE_MICRO_UZI, 0x96u, 1);
    v16 = FindPlayerPed(1);
    CPed::GiveWeapon(v16, WEAPONTYPE_AK47, 0x78u, 1);
    v17 = FindPlayerPed(1);
    CPed::GiveWeapon(v17, WEAPONTYPE_COUNTRYRIFLE, 0x19u, 1);
    v18 = FindPlayerPed(1);
    CPed::GiveWeapon(v18, WEAPONTYPE_ROCKETLAUNCHER, 0xC8u, 1);
    v19 = FindPlayerPed(1);
    CPed::GiveWeapon(v19, WEAPONTYPE_SPRAYCAN, 0xC8u, 1);
  }
  CStreaming::SetModelIsDeletable(331);
  CStreaming::SetModelIsDeletable(352);
  CStreaming::SetModelIsDeletable(336);
  CStreaming::SetModelIsDeletable(344);
  CStreaming::SetModelIsDeletable(349);
  CStreaming::SetModelIsDeletable(355);
  CStreaming::SetModelIsDeletable(357);
  CStreaming::SetModelIsDeletable(359);
  sub_19BC38(365);
}

//----- (002FD0DC) --------------------------------------------------------
void CCheat::WeaponCheat2()
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v1; // r0
  CPlayerPed *v2; // r0
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0
  CPlayerPed *v5; // r0
  CPlayerPed *v6; // r0
  CPlayerPed *v7; // r0
  CPlayerPed *v8; // r0
  CPlayerPed *v9; // r0
  CPlayerPed *v10; // r0
  CPlayerPed *v11; // r0
  CPlayerPed *v12; // r0
  CPlayerPed *v13; // r0
  CPlayerPed *v14; // r0
  CPlayerPed *v15; // r0
  CPlayerPed *v16; // r0
  CPlayerPed *v17; // r0

  CStreaming::RequestModel(335, 2);
  CStreaming::RequestModel(342, 2);
  CStreaming::RequestModel(348, 2);
  CStreaming::RequestModel(350, 2);
  CStreaming::RequestModel(372, 2);
  CStreaming::RequestModel(356, 2);
  CStreaming::RequestModel(358, 2);
  CStreaming::RequestModel(361, 2);
  CStreaming::RequestModel(366, 2);
  CStreaming::LoadAllRequestedModels(0);
  PlayerPed = FindPlayerPed(-1);
  CPed::GiveWeapon(PlayerPed, WEAPONTYPE_KNIFE, 0, 1);
  v1 = FindPlayerPed(-1);
  CPed::GiveWeapon(v1, WEAPONTYPE_GRENADE, 0xAu, 1);
  v2 = FindPlayerPed(-1);
  CPed::GiveWeapon(v2, WEAPONTYPE_DESERT_EAGLE, 0x28u, 1);
  v3 = FindPlayerPed(-1);
  CPed::GiveWeapon(v3, WEAPONTYPE_SAWNOFF_SHOTGUN, 0x28u, 1);
  v4 = FindPlayerPed(-1);
  CPed::GiveWeapon(v4, WEAPONTYPE_TEC9, 0x96u, 1);
  v5 = FindPlayerPed(-1);
  CPed::GiveWeapon(v5, WEAPONTYPE_M4, 0x96u, 1);
  v6 = FindPlayerPed(-1);
  CPed::GiveWeapon(v6, WEAPONTYPE_SNIPERRIFLE, 0x15u, 1);
  v7 = FindPlayerPed(-1);
  CPed::GiveWeapon(v7, WEAPONTYPE_FLAMETHROWER, 0x1F4u, 1);
  v8 = FindPlayerPed(-1);
  CPed::GiveWeapon(v8, WEAPONTYPE_EXTINGUISHER, 0xC8u, 1);
  if ( FindPlayerPed(1) )
  {
    v9 = FindPlayerPed(1);
    CPed::GiveWeapon(v9, WEAPONTYPE_KNIFE, 0, 1);
    v10 = FindPlayerPed(1);
    CPed::GiveWeapon(v10, WEAPONTYPE_GRENADE, 0xAu, 1);
    v11 = FindPlayerPed(1);
    CPed::GiveWeapon(v11, WEAPONTYPE_DESERT_EAGLE, 0x28u, 1);
    v12 = FindPlayerPed(1);
    CPed::GiveWeapon(v12, WEAPONTYPE_SAWNOFF_SHOTGUN, 0x28u, 1);
    v13 = FindPlayerPed(1);
    CPed::GiveWeapon(v13, WEAPONTYPE_TEC9, 0x96u, 1);
    v14 = FindPlayerPed(1);
    CPed::GiveWeapon(v14, WEAPONTYPE_M4, 0x96u, 1);
    v15 = FindPlayerPed(1);
    CPed::GiveWeapon(v15, WEAPONTYPE_SNIPERRIFLE, 0x15u, 1);
    v16 = FindPlayerPed(1);
    CPed::GiveWeapon(v16, WEAPONTYPE_FLAMETHROWER, 0x1F4u, 1);
    v17 = FindPlayerPed(1);
    CPed::GiveWeapon(v17, WEAPONTYPE_EXTINGUISHER, 0xC8u, 1);
  }
  CStreaming::SetModelIsDeletable(335);
  CStreaming::SetModelIsDeletable(342);
  CStreaming::SetModelIsDeletable(348);
  CStreaming::SetModelIsDeletable(350);
  CStreaming::SetModelIsDeletable(372);
  CStreaming::SetModelIsDeletable(356);
  CStreaming::SetModelIsDeletable(358);
  CStreaming::SetModelIsDeletable(361);
  sub_19BC38(366);
}

//----- (002FD2CC) --------------------------------------------------------
void CCheat::WeaponCheat3()
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v1; // r0
  CPlayerPed *v2; // r0
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0
  CPlayerPed *v5; // r0
  CPlayerPed *v6; // r0
  CPlayerPed *v7; // r0
  CPlayerPed *v8; // r0
  CPlayerPed *v9; // r0
  CPlayerPed *v10; // r0
  CPlayerPed *v11; // r0
  CPlayerPed *v12; // r0
  CPlayerPed *v13; // r0

  CStreaming::RequestModel(341, 2);
  CStreaming::RequestModel(347, 2);
  CStreaming::RequestModel(351, 2);
  CStreaming::RequestModel(353, 2);
  CStreaming::RequestModel(356, 2);
  CStreaming::RequestModel(360, 2);
  CStreaming::RequestModel(363, 2);
  CStreaming::RequestModel(364, 2);
  CStreaming::LoadAllRequestedModels(0);
  PlayerPed = FindPlayerPed(-1);
  CPed::GiveWeapon(PlayerPed, WEAPONTYPE_CHAINSAW, 0, 1);
  v1 = FindPlayerPed(-1);
  CPed::GiveWeapon(v1, WEAPONTYPE_REMOTE_SATCHEL_CHARGE, 5u, 1);
  v2 = FindPlayerPed(-1);
  CPed::GiveWeapon(v2, WEAPONTYPE_PISTOL_SILENCED, 0x28u, 1);
  v3 = FindPlayerPed(-1);
  CPed::GiveWeapon(v3, WEAPONTYPE_SPAS12_SHOTGUN, 0x1Eu, 1);
  v4 = FindPlayerPed(-1);
  CPed::GiveWeapon(v4, WEAPONTYPE_MP5, 0x64u, 1);
  v5 = FindPlayerPed(-1);
  CPed::GiveWeapon(v5, WEAPONTYPE_M4, 0x96u, 1);
  v6 = FindPlayerPed(-1);
  CPed::GiveWeapon(v6, WEAPONTYPE_ROCKETLAUNCHER_HS, 0xC8u, 1);
  if ( FindPlayerPed(1) )
  {
    v7 = FindPlayerPed(1);
    CPed::GiveWeapon(v7, WEAPONTYPE_CHAINSAW, 0, 1);
    v8 = FindPlayerPed(1);
    CPed::GiveWeapon(v8, WEAPONTYPE_REMOTE_SATCHEL_CHARGE, 5u, 1);
    v9 = FindPlayerPed(1);
    CPed::GiveWeapon(v9, WEAPONTYPE_PISTOL_SILENCED, 0x28u, 1);
    v10 = FindPlayerPed(1);
    CPed::GiveWeapon(v10, WEAPONTYPE_SPAS12_SHOTGUN, 0x1Eu, 1);
    v11 = FindPlayerPed(1);
    CPed::GiveWeapon(v11, WEAPONTYPE_MP5, 0x64u, 1);
    v12 = FindPlayerPed(1);
    CPed::GiveWeapon(v12, WEAPONTYPE_M4, 0x96u, 1);
    v13 = FindPlayerPed(1);
    CPed::GiveWeapon(v13, WEAPONTYPE_ROCKETLAUNCHER_HS, 0xC8u, 1);
  }
  CStreaming::SetModelIsDeletable(341);
  CStreaming::SetModelIsDeletable(347);
  CStreaming::SetModelIsDeletable(351);
  CStreaming::SetModelIsDeletable(353);
  CStreaming::SetModelIsDeletable(356);
  CStreaming::SetModelIsDeletable(360);
  CStreaming::SetModelIsDeletable(363);
  sub_19BC38(364);
}

//----- (002FD460) --------------------------------------------------------
void CCheat::WeaponCheat4()
{
  int32 v0; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v2; // r1
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0

  v0 = 369;
  if ( CCheat::WeaponCheat4(void)::bNVGoggles )
    v0 = 368;
  CStreaming::RequestModel(v0, 2);
  CStreaming::RequestModel(362, 2);
  CStreaming::RequestModel(322, 2);
  CStreaming::LoadAllRequestedModels(0);
  PlayerPed = FindPlayerPed(-1);
  v2 = WEAPONTYPE_INFRARED;
  if ( CCheat::WeaponCheat4(void)::bNVGoggles )
    v2 = WEAPONTYPE_NIGHTVISION;
  CPed::GiveWeapon(PlayerPed, v2, 1u, 1);
  v3 = FindPlayerPed(-1);
  CPed::GiveWeapon(v3, WEAPONTYPE_MINIGUN, 0x1F4u, 1);
  v4 = FindPlayerPed(-1);
  CPed::GiveWeapon(v4, WEAPONTYPE_DILDO2, 0, 1);
  CCheat::WeaponCheat4(void)::bNVGoggles ^= 1u;
}

//----- (002FD4E8) --------------------------------------------------------
void CCheat::TimeTravelCheat()
{
  sub_18DEBC(CClock::ms_nGameClockHours + 4, CClock::ms_nGameClockMinutes, CClock::ms_nGameClockDays);
}

//----- (002FD514) --------------------------------------------------------
void CCheat::ScriptBypassCheat()
{
  CCheat::m_nLastScriptBypasstime = CTimer::m_snTimeInMilliseconds;
}

//----- (002FD530) --------------------------------------------------------
void CCheat::ShowMappingsCheat()
{
  CCheat::m_bShowMappings ^= 1u;
}

//----- (002FD544) --------------------------------------------------------
void CCheat::TogglePlayerInvincibility()
{
  bool v0; // r5

  FindPlayerPed(-1);
  v0 = CPlayerPed::bDebugPlayerInvincible;
  FindPlayerPed(-1);
  CPlayerPed::bDebugPlayerInvincible = !v0;
}

//----- (002FD56C) --------------------------------------------------------
void CCheat::ToggleShowTapToTarget()
{
  bool v0; // r5

  FindPlayerPed(-1);
  v0 = CPlayerPed::bDebugTapToTarget;
  FindPlayerPed(-1);
  CPlayerPed::bDebugTapToTarget = !v0;
}

//----- (002FD594) --------------------------------------------------------
void CCheat::ToggleShowTargeting()
{
  bool v0; // r5

  FindPlayerPed(-1);
  v0 = CPlayerPed::bDebugTargetting;
  FindPlayerPed(-1);
  CPlayerPed::bDebugTargetting = !v0;
}

//----- (002FD5BC) --------------------------------------------------------
void CCheat::MoneyArmourHealthCheat()
{
  float MaxArmour; // s16

  CWorld::Players[CWorld::PlayerInFocus].Score += 250000;
  MaxArmour = (float)CWorld::Players[0].MaxArmour;
  FindPlayerPed(-1)->m_nArmour = MaxArmour;
  CCheat::HealthCheat();
}

//----- (002FD618) --------------------------------------------------------
void CCheat::WantedLevelUpCheat()
{
  CPlayerPed *PlayerPed; // r4
  Int32 v1; // r1

  PlayerPed = FindPlayerPed(-1);
  if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel > WANTED_LEVEL3 )
    v1 = 6;
  else
    v1 = FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel + 2;
  sub_19CDB4(PlayerPed, v1);
}

//----- (002FD65A) --------------------------------------------------------
void CCheat::WantedLevelDownCheat()
{
  CPlayerPed *PlayerPed; // r0

  PlayerPed = FindPlayerPed(-1);
  sub_19CDB4(PlayerPed, 0);
}

//----- (002FD670) --------------------------------------------------------
void CCheat::SunnyWeatherCheat()
{
  sub_195940(1);
}

//----- (002FD676) --------------------------------------------------------
void CCheat::ExtraSunnyWeatherCheat()
{
  sub_195940(0);
}

//----- (002FD67C) --------------------------------------------------------
void CCheat::CloudyWeatherCheat()
{
  sub_195940(4);
}

//----- (002FD682) --------------------------------------------------------
void CCheat::RainyWeatherCheat()
{
  sub_195940(16);
}

//----- (002FD688) --------------------------------------------------------
void CCheat::FoggyWeatherCheat()
{
  sub_195940(9);
}

//----- (002FD690) --------------------------------------------------------
void CCheat::FastTimeCheat()
{
  if ( CTimer::ms_fTimeScale < 4.0 )
    CTimer::ms_fTimeScale = CTimer::ms_fTimeScale + CTimer::ms_fTimeScale;
}

//----- (002FD6C4) --------------------------------------------------------
void CCheat::SlowTimeCheat()
{
  if ( CTimer::ms_fTimeScale > 0.25 )
    CTimer::ms_fTimeScale = CTimer::ms_fTimeScale * 0.5;
}

//----- (002FD6FC) --------------------------------------------------------
void CCheat::MayhemCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPedPool *v2; // r9
  int32 m_nSize; // r0
  int v4; // r6
  int v5; // r4
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r10
  uint8 *v7; // r5
  CAcquaintance *v8; // r5
  uint32 PedFlag; // r0
  uint32 v10; // r0
  uint32 v11; // r0
  uint32 v12; // r0
  uint32 v13; // r0
  uint32 v14; // r0
  uint32 v15; // r0
  uint32 v16; // r0
  uint32 v17; // r0
  uint32 v18; // r0
  uint32 v19; // r0
  uint32 v20; // r0
  uint32 v21; // r0
  uint32 v22; // r0
  uint32 v23; // r0
  uint32 v24; // r0
  uint32 v25; // r0
  uint32 v26; // r0
  uint32 v27; // r0
  CPed *ClosestPedInRange; // r1
  CEventAcquaintancePed v29[2]; // [sp+0h] [bp-30h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[21] == 0;
  if ( !CCheat::m_aCheatsActive[21] )
    v0 = 1;
  CCheat::m_aCheatsActive[21] = v0;
  if ( v1 )
  {
    CPedType::SetPedTypeAsAcquaintance(4, 4, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 5, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 6, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 7, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 8, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 9, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 10, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 11, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 12, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 13, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 14, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 15, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 16, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 17, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 18, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 19, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 20, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 21, (uint32)"Ev");
    CPedType::SetPedTypeAsAcquaintance(4, 22, (uint32)"Ev");
    v2 = CPools::ms_pPedPool;
    m_nSize = CPools::ms_pPedPool->m_nSize;
    if ( m_nSize )
    {
      v4 = m_nSize - 1;
      v5 = 1996 * m_nSize - 908;
      do
      {
        if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
        {
          m_aStorage = v2->m_aStorage;
          v7 = &(*v2->m_aStorage)[v5];
          if ( v7 != (uint8 *)&elf_hash_bucket[209] && !CPed::IsPlayer((const CPed *)(v7 - 1088)) )
          {
            v8 = (CAcquaintance *)(v7 + 172);
            PedFlag = CPedType::GetPedFlag(4);
            CAcquaintance::SetAsAcquaintance(v8, 4, PedFlag);
            v10 = CPedType::GetPedFlag(5);
            CAcquaintance::SetAsAcquaintance(v8, 4, v10);
            v11 = CPedType::GetPedFlag(6);
            CAcquaintance::SetAsAcquaintance(v8, 4, v11);
            v12 = CPedType::GetPedFlag(7);
            CAcquaintance::SetAsAcquaintance(v8, 4, v12);
            v13 = CPedType::GetPedFlag(8);
            CAcquaintance::SetAsAcquaintance(v8, 4, v13);
            v14 = CPedType::GetPedFlag(9);
            CAcquaintance::SetAsAcquaintance(v8, 4, v14);
            v15 = CPedType::GetPedFlag(10);
            CAcquaintance::SetAsAcquaintance(v8, 4, v15);
            v16 = CPedType::GetPedFlag(11);
            CAcquaintance::SetAsAcquaintance(v8, 4, v16);
            v17 = CPedType::GetPedFlag(12);
            CAcquaintance::SetAsAcquaintance(v8, 4, v17);
            v18 = CPedType::GetPedFlag(13);
            CAcquaintance::SetAsAcquaintance(v8, 4, v18);
            v19 = CPedType::GetPedFlag(14);
            CAcquaintance::SetAsAcquaintance(v8, 4, v19);
            v20 = CPedType::GetPedFlag(15);
            CAcquaintance::SetAsAcquaintance(v8, 4, v20);
            v21 = CPedType::GetPedFlag(16);
            CAcquaintance::SetAsAcquaintance(v8, 4, v21);
            v22 = CPedType::GetPedFlag(17);
            CAcquaintance::SetAsAcquaintance(v8, 4, v22);
            v23 = CPedType::GetPedFlag(18);
            CAcquaintance::SetAsAcquaintance(v8, 4, v23);
            v24 = CPedType::GetPedFlag(19);
            CAcquaintance::SetAsAcquaintance(v8, 4, v24);
            v25 = CPedType::GetPedFlag(20);
            CAcquaintance::SetAsAcquaintance(v8, 4, v25);
            v26 = CPedType::GetPedFlag(21);
            CAcquaintance::SetAsAcquaintance(v8, 4, v26);
            v27 = CPedType::GetPedFlag(22);
            CAcquaintance::SetAsAcquaintance(v8, 4, v27);
            ClosestPedInRange = CPedScanner::GetClosestPedInRange((const CPedScanner *)(*(_DWORD *)&(*m_aStorage)[v5]
                                                                                      + 292));
            if ( ClosestPedInRange )
            {
              CEventAcquaintancePed::CEventAcquaintancePed(v29, ClosestPedInRange);
              v29[0].m_iTaskType = 1000;
              v29[0]._vptr$CEvent = (int (**)(void))&off_665394;
              CEventGroup::Add((CEventGroup *)(*(_DWORD *)&(*m_aStorage)[v5] + 104), (CEvent *)v29, 0);
              CEventAcquaintancePed::~CEventAcquaintancePed(v29);
            }
          }
        }
        --v4;
        v5 -= 1996;
      }
      while ( v4 != -1 );
    }
  }
}
// 14: using guessed type int dword_14;
// FC: using guessed type int elf_hash_bucket[16411];
// 665394: using guessed type void *off_665394;
// 676218: using guessed type void *`vtable for'CEventAcquaintancePedHate;

//----- (002FD9C0) --------------------------------------------------------
void CCheat::EverybodyAttacksPlayerCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPedPool *v2; // r11
  int32 m_nSize; // r0
  int v4; // r5
  int v5; // r4
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r10
  uint8 *v7; // r6
  uint32 PedFlag; // r0
  CPlayerPed *PlayerPed; // r0
  CEventAcquaintancePed v10[2]; // [sp+8h] [bp-30h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[22] == 0;
  if ( !CCheat::m_aCheatsActive[22] )
    v0 = 1;
  CCheat::m_aCheatsActive[22] = v0;
  if ( v1 )
  {
    v2 = CPools::ms_pPedPool;
    m_nSize = CPools::ms_pPedPool->m_nSize;
    if ( m_nSize )
    {
      v4 = m_nSize - 1;
      v5 = 1996 * m_nSize - 908;
      do
      {
        if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
        {
          m_aStorage = v2->m_aStorage;
          v7 = &(*v2->m_aStorage)[v5];
          if ( v7 != (uint8 *)&elf_hash_bucket[209] && !CPed::IsPlayer((const CPed *)(v7 - 1088)) )
          {
            PedFlag = CPedType::GetPedFlag(0);
            CAcquaintance::SetAsAcquaintance((CAcquaintance *)(v7 + 172), 4, PedFlag);
            PlayerPed = FindPlayerPed(-1);
            CEventAcquaintancePed::CEventAcquaintancePed(v10, PlayerPed);
            v10[0].m_iTaskType = 1000;
            v10[0]._vptr$CEvent = (int (**)(void))&off_665394;
            CEventGroup::Add((CEventGroup *)(*(_DWORD *)&(*m_aStorage)[v5] + 104), (CEvent *)v10, 0);
            CEventAcquaintancePed::~CEventAcquaintancePed(v10);
          }
        }
        --v4;
        v5 -= 1996;
      }
      while ( v4 != -1 );
    }
  }
}
// 14: using guessed type int dword_14;
// FC: using guessed type int elf_hash_bucket[16411];
// 665394: using guessed type void *off_665394;
// 676218: using guessed type void *`vtable for'CEventAcquaintancePedHate;

//----- (002FDA90) --------------------------------------------------------
void CCheat::TankCheat()
{
  CCheat::VehicleCheat(432);
}

//----- (002FDA98) --------------------------------------------------------
void CCheat::StockCarCheat()
{
  CCheat::VehicleCheat(504);
}

//----- (002FDAA0) --------------------------------------------------------
void CCheat::StockCar2Cheat()
{
  CCheat::VehicleCheat(505);
}

//----- (002FDAA8) --------------------------------------------------------
void CCheat::StockCar3Cheat()
{
  CCheat::VehicleCheat(502);
}

//----- (002FDAB0) --------------------------------------------------------
void CCheat::StockCar4Cheat()
{
  CCheat::VehicleCheat(503);
}

//----- (002FDAB8) --------------------------------------------------------
void CCheat::HearseCheat()
{
  CCheat::VehicleCheat(442);
}

//----- (002FDAC0) --------------------------------------------------------
void CCheat::LovefistCheat()
{
  CCheat::VehicleCheat(409);
}

//----- (002FDAC8) --------------------------------------------------------
void CCheat::TrashmasterCheat()
{
  CCheat::VehicleCheat(408);
}

//----- (002FDAD0) --------------------------------------------------------
void CCheat::GolfcartCheat()
{
  CCheat::VehicleCheat(457);
}

//----- (002FDAD8) --------------------------------------------------------
void CCheat::BlowUpCarsCheat()
{
  CVehiclePool *v0; // r4
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r5

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 2604 * m_nSize - 2604;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        if ( &(*v0->m_aStorage)[v3] )
          (*(void (__fastcall **)(uint8 *, _DWORD, _DWORD))(*(_DWORD *)&(*v0->m_aStorage)[v3] + 168))(
            &(*v0->m_aStorage)[v3],
            0,
            0);
      }
      --v2;
      v3 -= 2604;
    }
    while ( v2 != -1 );
  }
}

//----- (002FDB28) --------------------------------------------------------
void CCheat::SuicideCheat()
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v1; // r0
  CPlayerPed *v2; // r0
  CEventDamage v3; // [sp+14h] [bp-5Ch] BYREF
  CPedDamageResponseCalculator v4; // [sp+54h] [bp-1Ch] BYREF

  CPedDamageResponseCalculator::CPedDamageResponseCalculator(&v4, 0, 1000.0, WEAPONTYPE_UNARMED, PED_SPHERE_CHEST, 0);
  CEventDamage::CEventDamage(&v3, 0, CTimer::m_snTimeInMilliseconds, WEAPONTYPE_UNARMED, PED_SPHERE_CHEST, 0, 0, 0);
  PlayerPed = FindPlayerPed(-1);
  if ( CEventDamage::AffectsPed(&v3, PlayerPed) )
  {
    v1 = FindPlayerPed(-1);
    CPedDamageResponseCalculator::ComputeDamageResponse(&v4, v1, &v3.m_pedDamageResponse, 1);
  }
  else
  {
    v3.m_pedDamageResponse.m_bDamageCalculated = 1;
  }
  v2 = FindPlayerPed(-1);
  CEventGroup::Add(&v2->m_pPedIntelligence->m_eventGroup, (CEvent *)&v3, 0);
  CEventDamage::~CEventDamage(&v3);
  CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v4);
}

//----- (002FDBC0) --------------------------------------------------------
void CCheat::PinkCarsCheat()
{
  bool v0; // zf

  v0 = CCheat::m_aCheatsActive[39] == 0;
  CCheat::m_aCheatsActive[39] = CCheat::m_aCheatsActive[39] == 0;
  if ( v0 )
    CCheat::m_aCheatsActive[40] = 0;
}
// 24: using guessed type int dword_24;

//----- (002FDBF4) --------------------------------------------------------
void CCheat::BlackCarsCheat()
{
  bool v0; // zf

  v0 = CCheat::m_aCheatsActive[40] == 0;
  CCheat::m_aCheatsActive[40] = CCheat::m_aCheatsActive[40] == 0;
  if ( v0 )
    CCheat::m_aCheatsActive[39] = 0;
}

//----- (002FDC28) --------------------------------------------------------
void CCheat::FatCheat()
{
  CPlayerPed *PlayerPed; // r0

  CStats::SetStatValue(0x15u, 1000.0);
  if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
  {
    PlayerPed = FindPlayerPed(-1);
    sub_19D9D8(PlayerPed, 0);
  }
}

//----- (002FDC5C) --------------------------------------------------------
void CCheat::MuscleCheat()
{
  CPlayerPed *PlayerPed; // r0

  CStats::SetStatValue(0x17u, 1000.0);
  if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
  {
    PlayerPed = FindPlayerPed(-1);
    sub_19D9D8(PlayerPed, 0);
  }
}

//----- (002FDC90) --------------------------------------------------------
void CCheat::TheGamblerCheat()
{
  sub_195D58(0x51u, 1000.0);
}

//----- (002FDC9C) --------------------------------------------------------
void CCheat::SkinnyCheat()
{
  CPlayerPed *PlayerPed; // r0

  CStats::SetStatValue(0x15u, 0.0);
  CStats::SetStatValue(0x17u, 0.0);
  if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
  {
    PlayerPed = FindPlayerPed(-1);
    sub_19D9D8(PlayerPed, 0);
  }
}

//----- (002FDCD4) --------------------------------------------------------
void CCheat::ElvisLivesCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  _QWORD v2[5]; // [sp-28h] [bp-28h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[47] == 0;
  if ( !CCheat::m_aCheatsActive[47] )
    v0 = 1;
  CCheat::m_aCheatsActive[47] = v0;
  if ( v1 )
  {
    v2[0] = *(_QWORD *)"R";
    v2[1] = 0xFFFFFFFE00000054LL;
    v2[2] = unk_60FA18;
    v2[3] = unk_60FA20;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v2);
  }
}
// 2E: using guessed type __int16 word_2E;

//----- (002FDD20) --------------------------------------------------------
void CCheat::VillagePeopleCheat()
{
  bool v0; // zf
  _QWORD v1[5]; // [sp-28h] [bp-28h] BYREF

  v0 = CCheat::m_aCheatsActive[48] == 0;
  CCheat::m_aCheatsActive[48] = CCheat::m_aCheatsActive[48] == 0;
  if ( v0 )
  {
    v1[0] = unk_60FA28;
    v1[1] = unk_60FA30;
    v1[2] = unk_60FA38;
    v1[3] = unk_60FA40;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v1);
    CCheat::EverybodyAttacksPlayerCheat();
    CCheat::m_aCheatsActive[23] = 1;
  }
  else
  {
    CCheat::m_aCheatsActive[23] = 0;
    CCheat::EverybodyAttacksPlayerCheat();
  }
}

//----- (002FDD8C) --------------------------------------------------------
void CCheat::BeachPartyCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0
  CPlayerPed *v5; // r0
  CPlayerPed *v6; // r0
  _QWORD v7[5]; // [sp-28h] [bp-28h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[49] == 0;
  if ( !CCheat::m_aCheatsActive[49] )
    v0 = 1;
  CCheat::m_aCheatsActive[49] = v0;
  if ( v1 )
  {
    v7[0] = unk_60FA48;
    v7[1] = unk_60FA50;
    v7[2] = unk_60FA58;
    v7[3] = unk_60FA60;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v7);
    PlayerPed = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(PlayerPed->m_pPlayerData->m_pClothes, "torso", 0, 0);
    v3 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v3->m_pPlayerData->m_pClothes, "shortskhaki", "shorts", 2);
    v4 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v4->m_pPlayerData->m_pClothes, "flipflop", "flipflop", 3);
    v5 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v5->m_pPlayerData->m_pClothes, "glasses04dark", "glasses04", 15);
    if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
    {
      v6 = FindPlayerPed(-1);
      CClothes::RebuildPlayer(v6, 0);
    }
    CWeather::ForceWeatherNow(0);
    CCheat::ClearVehiclePopulationCheats(BEACHPARTY_CHEAT);
    CStreaming::ReclassifyLoadedCars();
  }
}
// 30: using guessed type __int16 word_30;

//----- (002FDEA8) --------------------------------------------------------
void CCheat::GangsCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  _QWORD v2[5]; // [sp-28h] [bp-28h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[50] == 0;
  if ( !CCheat::m_aCheatsActive[50] )
    v0 = 1;
  CCheat::m_aCheatsActive[50] = v0;
  if ( v1 )
  {
    v2[0] = unk_60FA68;
    v2[1] = unk_60FA70;
    v2[2] = unk_60FA78;
    v2[3] = unk_60FA80;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v2);
  }
}

//----- (002FDEF4) --------------------------------------------------------
void CCheat::GangLandCheat()
{
  CPopulation::m_bOnlyCreateRandomGangMembers = CCheat::m_aCheatsActive[51] == 0;
  CCheat::m_aCheatsActive[51] = CCheat::m_aCheatsActive[51] == 0;
}
// 32: using guessed type __int16 word_32;

//----- (002FDF1C) --------------------------------------------------------
void CCheat::NinjaCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v3; // r0
  _QWORD v4[5]; // [sp-28h] [bp-28h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[52] == 0;
  if ( !CCheat::m_aCheatsActive[52] )
    v0 = 1;
  CCheat::m_aCheatsActive[52] = v0;
  if ( v1 )
  {
    v4[0] = 0x7600000075LL;
    v4[1] = unk_60FA90;
    v4[2] = unk_60FA98;
    v4[3] = unk_60FAA0;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v4);
    if ( CCheat::m_aCheatsActive[49] )
      CCheat::BeachPartyCheat();
    if ( CCheat::m_aCheatsActive[54] )
      CCheat::m_aCheatsActive[54] = 0;
    if ( CCheat::m_aCheatsActive[55] )
      CCheat::m_aCheatsActive[55] = 0;
    if ( CCheat::m_aCheatsActive[78] )
      CCheat::FunhouseCheat();
    if ( CCheat::m_aCheatsActive[83] )
      CCheat::CountrysideInvasionCheat();
    CStreaming::ReclassifyLoadedCars();
    if ( !CCheat::m_aCheatsActive[40] )
      *(_WORD *)&CCheat::m_aCheatsActive[39] = 256;
    CStreaming::RequestModel(339, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    CPed::GiveWeapon(PlayerPed, WEAPONTYPE_KATANA, 0, 1);
    v3 = FindPlayerPed(-1);
    CPed::SetCurrentWeapon(v3, WEAPONTYPE_KATANA);
  }
  else if ( CCheat::m_aCheatsActive[40] )
  {
    CCheat::m_aCheatsActive[40] = 0;
  }
}

//----- (002FE060) --------------------------------------------------------
void CCheat::LoveConquersAllCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v3; // r0
  _QWORD v4[5]; // [sp-28h] [bp-28h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[53] == 0;
  if ( !CCheat::m_aCheatsActive[53] )
    v0 = 1;
  CCheat::m_aCheatsActive[53] = v0;
  if ( v1 )
  {
    v4[0] = 0x3F000000F9LL;
    v4[1] = unk_60FAB0;
    v4[2] = unk_60FAB8;
    v4[3] = unk_60FAC0;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v4);
    PlayerPed = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(PlayerPed->m_pPlayerData->m_pClothes, "gimpleg", "gimpleg", 17);
    if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
    {
      v3 = FindPlayerPed(-1);
      CClothes::RebuildPlayer(v3, 0);
    }
  }
}
// 34: using guessed type int dword_34;

//----- (002FE0EC) --------------------------------------------------------
void CCheat::AllCarsAreShitCheat()
{
  bool8 v0; // r2
  bool v1; // zf

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[54] == 0;
  if ( !CCheat::m_aCheatsActive[54] )
    v0 = 1;
  CCheat::m_aCheatsActive[54] = v0;
  if ( v1 )
  {
    CCheat::ClearVehiclePopulationCheats(ALLCARSARESHIT_CHEAT);
    sub_19E3C4();
  }
}
// 34: using guessed type int dword_34;

//----- (002FE11C) --------------------------------------------------------
void CCheat::AllCarsAreGreatCheat()
{
  bool8 v0; // r2
  bool v1; // zf

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[55] == 0;
  if ( !CCheat::m_aCheatsActive[55] )
    v0 = 1;
  CCheat::m_aCheatsActive[55] = v0;
  if ( v1 )
  {
    CCheat::ClearVehiclePopulationCheats(ALLCARSAREGREAT_CHEAT);
    sub_19E3C4();
  }
}
// 34: using guessed type int dword_34;

//----- (002FE14C) --------------------------------------------------------
void CCheat::FlyboyCheat()
{
  CCheat::VehicleCheat(520);
}

//----- (002FE154) --------------------------------------------------------
void CCheat::VortexCheat()
{
  CCheat::VehicleCheat(539);
}

//----- (002FE15C) --------------------------------------------------------
void CCheat::MidnightCheat()
{
  bool v0; // zf

  v0 = CCheat::m_aCheatsActive[63] == 0;
  CCheat::m_aCheatsActive[63] = CCheat::m_aCheatsActive[63] == 0;
  if ( v0 )
  {
    CClock::ms_nGameClockMinutes = 0;
    CClock::ms_nGameClockHours = 0;
    CClock::ms_nGameClockSeconds = 0;
  }
}
// 3C: using guessed type void *off_3C;

//----- (002FE1A4) --------------------------------------------------------
void CCheat::DuskCheat()
{
  bool v0; // zf

  v0 = CCheat::m_aCheatsActive[64] == 0;
  CCheat::m_aCheatsActive[64] = CCheat::m_aCheatsActive[64] == 0;
  if ( v0 )
  {
    CClock::ms_nGameClockMinutes = 0;
    CClock::ms_nGameClockHours = 21;
    CClock::ms_nGameClockSeconds = 0;
  }
}

//----- (002FE1F0) --------------------------------------------------------
void CCheat::StormCheat()
{
  CWeather::ForceWeatherNow(16);
  CWeather::Wind = 1.0;
  CWeather::Rain = 1.0;
}

//----- (002FE218) --------------------------------------------------------
void CCheat::SandstormCheat()
{
  sub_195940(19);
}

//----- (002FE220) --------------------------------------------------------
void CCheat::ParachuteCheat()
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v1; // r0

  CStreaming::RequestModel(371, 2);
  CStreaming::LoadAllRequestedModels(0);
  PlayerPed = FindPlayerPed(-1);
  CPed::GiveWeapon(PlayerPed, WEAPONTYPE_PARACHUTE, 0, 1);
  v1 = FindPlayerPed(-1);
  sub_19173C(v1, WEAPONTYPE_PARACHUTE);
}

//----- (002FE258) --------------------------------------------------------
void CCheat::JetpackCheat()
{
  CPlayerPed *PlayerPed; // r0
  CTaskSimpleJetPack *v1; // r4
  CPlayerPed *v2; // r0
  CEventScriptCommand v3; // [sp+8h] [bp-20h] BYREF

  PlayerPed = FindPlayerPed(-1);
  if ( !CPedIntelligence::GetTaskJetPack(PlayerPed->m_pPedIntelligence) )
  {
    v1 = (CTaskSimpleJetPack *)CTask::operator new(0x70u);
    CTaskSimpleJetPack::CTaskSimpleJetPack(v1, 0, 10.0, 0, 0);
    CEventScriptCommand::CEventScriptCommand(&v3, 3, v1, 0);
    v2 = FindPlayerPed(-1);
    CEventGroup::Add(&v2->m_pPedIntelligence->m_eventGroup, &v3, 0);
    CEventScriptCommand::~CEventScriptCommand(&v3);
  }
}

//----- (002FE2C0) --------------------------------------------------------
void CCheat::NotWantedCheat()
{
  CPlayerPed *PlayerPed; // r0
  bool8 v1; // r4

  PlayerPed = FindPlayerPed(-1);
  v1 = 0;
  CPlayerPed::CheatWantedLevel(PlayerPed, 0);
  if ( !CCheat::m_aCheatsActive[73] )
    v1 = 1;
  CCheat::m_aCheatsActive[73] = v1;
}
// 48: using guessed type int dword_48;

//----- (002FE2F0) --------------------------------------------------------
void CCheat::WantedCheat()
{
  CPlayerPed *PlayerPed; // r0

  PlayerPed = FindPlayerPed(-1);
  sub_19CDB4(PlayerPed, 6);
}

//----- (002FE308) --------------------------------------------------------
void CCheat::RiotCheat()
{
  CCheat::m_aCheatsActive[77] = CCheat::m_aCheatsActive[77] == 0;
}
// 4C: using guessed type int;

//----- (002FE324) --------------------------------------------------------
void CCheat::FunhouseCheat()
{
  bool v0; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v2; // r0
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0
  CPlayerPed *v5; // r0
  CPlayerPed *v6; // r0
  _QWORD v7[5]; // [sp-20h] [bp-30h] BYREF

  v0 = CCheat::m_aCheatsActive[78] == 0;
  CCheat::m_aCheatsActive[78] = CCheat::m_aCheatsActive[78] == 0;
  if ( v0 )
  {
    v7[0] = unk_60FAC8;
    v7[1] = unk_60FAD0;
    v7[2] = unk_60FAD8;
    v7[3] = unk_60FAE0;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v7);
    PlayerPed = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(PlayerPed->m_pPlayerData->m_pClothes, "torso", "torso", 0);
    v2 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v2->m_pPlayerData->m_pClothes, "legsheart", "legs", 2);
    v3 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v3->m_pPlayerData->m_pClothes, "timberhike", "bask1", 3);
    v4 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v4->m_pPlayerData->m_pClothes, "groucho", "grouchos", 15);
    v5 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v5->m_pPlayerData->m_pClothes, "hairpink", "head", 1);
    if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
    {
      v6 = FindPlayerPed(-1);
      CClothes::RebuildPlayer(v6, 0);
    }
    CCheat::ClearVehiclePopulationCheats(FUNHOUSE_CHEAT);
    CStreaming::ReclassifyLoadedCars();
    CWeather::ForceWeatherNow(0);
    CPostEffects::m_bHeatHazeFX = 1;
  }
  else
  {
    CPostEffects::m_bHeatHazeFX = 0;
  }
}
// 4C: using guessed type int;

//----- (002FE484) --------------------------------------------------------
void CCheat::AdrenalineCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPlayerPed *PlayerPed; // r0

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[79] == 0;
  if ( !CCheat::m_aCheatsActive[79] )
    v0 = 1;
  CCheat::m_aCheatsActive[79] = v0;
  if ( v1 )
  {
    CPickups::GivePlayerGoodiesWithPickUpMI(MI_PICKUP_ADRENALINE, 0);
  }
  else
  {
    PlayerPed = FindPlayerPed(-1);
    *((_WORD *)PlayerPed->m_pPlayerData + 26) &= ~2u;
  }
}
// 4C: using guessed type int;

//----- (002FE4D0) --------------------------------------------------------
void CCheat::DrivebyCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v3; // r0

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[81] == 0;
  if ( !CCheat::m_aCheatsActive[81] )
    v0 = 1;
  CCheat::m_aCheatsActive[81] = v0;
  if ( v1 && FindPlayerPed(-1)->m_WeaponSlots[4].m_eWeaponType == WEAPONTYPE_UNARMED )
  {
    PlayerPed = FindPlayerPed(-1);
    CPed::GiveDelayedWeapon(PlayerPed, WEAPONTYPE_MICRO_UZI, 0x96u);
    v3 = FindPlayerPed(-1);
    sub_19173C(v3, WEAPONTYPE_MICRO_UZI);
  }
}
// 50: using guessed type int dword_50;

//----- (002FE524) --------------------------------------------------------
void CCheat::CountrysideInvasionCheat()
{
  bool8 v0; // r2
  bool v1; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v3; // r0
  CPlayerPed *v4; // r0
  CPlayerPed *v5; // r0
  _QWORD v6[5]; // [sp-28h] [bp-28h] BYREF

  v0 = 0;
  v1 = CCheat::m_aCheatsActive[83] == 0;
  if ( !CCheat::m_aCheatsActive[83] )
    v0 = 1;
  CCheat::m_aCheatsActive[83] = v0;
  if ( v1 )
  {
    v6[0] = 0xC5000000C4LL;
    v6[1] = unk_60FAF0;
    v6[2] = unk_60FAF8;
    v6[3] = unk_60FB00;
    CStreaming::StreamPedsIntoRandomSlots((Int32 *)v6);
    PlayerPed = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(PlayerPed->m_pPlayerData->m_pClothes, "timberfawn", "bask1", 3);
    v3 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v3->m_pPlayerData->m_pClothes, "captruck", "captruck", 16);
    v4 = FindPlayerPed(-1);
    CPedClothesDesc::SetTextureAndModel(v4->m_pPlayerData->m_pClothes, "countrytr", "countrytr", 17);
    if ( FindPlayerPed(-1)->m_nPedState != PED_DRIVING )
    {
      v5 = FindPlayerPed(-1);
      CClothes::RebuildPlayer(v5, 0);
    }
    CCheat::ClearVehiclePopulationCheats(COUNTRYSIDEINVASION_CHEAT);
    CStreaming::ReclassifyLoadedCars();
  }
}
// 50: using guessed type int dword_50;

//----- (002FE60C) --------------------------------------------------------
void CCheat::StaminaCheat()
{
  CStats::SetStatValue(0x16u, 1000.0);
  sub_195D58(0xE1u, 1000.0);
}

//----- (002FE62A) --------------------------------------------------------
void CCheat::WeaponSkillsCheat()
{
  CStats::SetStatValue(0x45u, 1000.0);
  CStats::SetStatValue(0x46u, 1000.0);
  CStats::SetStatValue(0x47u, 1000.0);
  CStats::SetStatValue(0x48u, 1000.0);
  CStats::SetStatValue(0x49u, 1000.0);
  CStats::SetStatValue(0x4Au, 1000.0);
  CStats::SetStatValue(0x4Bu, 1000.0);
  CStats::SetStatValue(0x4Cu, 1000.0);
  CStats::SetStatValue(0x4Du, 1000.0);
  CStats::SetStatValue(0x4Eu, 1000.0);
  sub_195D58(0x4Fu, 1000.0);
}

//----- (002FE690) --------------------------------------------------------
void CCheat::VehicleSkillsCheat()
{
  CStats::SetStatValue(0xA0u, 1000.0);
  CStats::SetStatValue(0xDFu, 1000.0);
  CStats::SetStatValue(0xE5u, 1000.0);
  sub_195D58(0xE6u, 1000.0);
}

//----- (002FE6BE) --------------------------------------------------------
void CCheat::ApacheCheat()
{
  CCheat::VehicleCheat(425);
}

//----- (002FE6C6) --------------------------------------------------------
void CCheat::QuadCheat()
{
  CCheat::VehicleCheat(471);
}

//----- (002FE6D0) --------------------------------------------------------
void CCheat::TankerCheat()
{
  CVehicle *v0; // r4
  char *v1; // r5
  CMatrix *m_pMat; // r0
  int v3; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v5; // kr00_8
  RwReal z; // r2
  RwReal *v7; // r1
  CMatrix *v8; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float *v12; // r0
  float v13; // s2
  float v14; // s4

  v0 = CCheat::VehicleCheat(514);
  if ( v0 )
  {
    CStreaming::RequestModel(584, 0);
    CStreaming::LoadAllRequestedModels(0);
    if ( CStreaming::ms_aInfoForModel[584].m_status == 1 )
    {
      v1 = (char *)CVehicle::operator new(0xA08u);
      CTrailer::CTrailer((CTrailer *)v1, 584, 1u);
      if ( v1 )
      {
        m_pMat = v0->m_pMat;
        v3 = *((_DWORD *)v1 + 5);
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v0->m_transform;
        v5 = *(_QWORD *)&p_tx->m_translate.x;
        z = p_tx->m_translate.z;
        if ( v3 )
        {
          *(_DWORD *)(v3 + 48) = v5;
          *(_DWORD *)(*((_DWORD *)v1 + 5) + 52) = HIDWORD(v5);
          v7 = (RwReal *)(*((_DWORD *)v1 + 5) + 56);
        }
        else
        {
          v7 = (RwReal *)(v1 + 12);
          *(_QWORD *)(v1 + 4) = v5;
        }
        *v7 = z;
        v8 = (CMatrix *)*((_DWORD *)v1 + 5);
        if ( v8 )
        {
          tx = v8->tx;
          ty = v8->ty;
          tz = v8->tz;
          CMatrix::SetRotate(v8, 0.0, 0.0, 3.4907);
          v12 = (float *)*((_DWORD *)v1 + 5);
          v13 = ty + v12[13];
          v14 = tz + v12[14];
          v12[12] = tx + v12[12];
          v12[13] = v13;
          v12[14] = v14;
        }
        else
        {
          *((_DWORD *)v1 + 4) = 1079994099;
        }
        v1[58] = v1[58] & 7 | 0x20;
        CWorld::Add((CEntity *)v1);
        (*(void (__fastcall **)(char *, CVehicle *, int))(*(_DWORD *)v1 + 248))(v1, v0, 1);
      }
    }
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002FE7CC) --------------------------------------------------------
void CCheat::DozerCheat()
{
  CCheat::VehicleCheat(486);
}

//----- (002FE7D4) --------------------------------------------------------
void CCheat::StuntPlaneCheat()
{
  CCheat::VehicleCheat(513);
}

//----- (002FE7DC) --------------------------------------------------------
void CCheat::MonsterTruckCheat()
{
  CCheat::VehicleCheat(556);
}

//----- (002FE7E4) --------------------------------------------------------
void CCheat::WeaponSlotCheat()
{
  int v0; // r4
  const char *v1; // r3
  int v2; // r1
  const char *v3; // r0
  int v4; // r2
  __int64 v5; // d17
  __int64 v6; // d16
  unsigned __int8 *v7; // r1
  __int64 v8; // d17
  __int64 v9; // d16
  __int64 v10; // d17
  __int64 v11; // d16
  unsigned __int8 *pszEntries[2]; // [sp+8h] [bp-518h] BYREF
  __int64 v13; // [sp+10h] [bp-510h]
  const char *v14; // [sp+18h] [bp-508h]
  const char *v15; // [sp+1Ch] [bp-504h]
  const char *v16; // [sp+20h] [bp-500h]
  unsigned __int8 pszAsciiName[260]; // [sp+408h] [bp-118h] BYREF

  nWeaponSlot = CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[154], pszAsciiName) - 100;
  CTouchInterface::DeleteWidget(WIDGET_CHEATS);
  v0 = 0;
  v1 = "AK47";
  v2 = 2;
  v3 = "M4";
  v4 = 1;
  switch ( nWeaponSlot )
  {
    case 0:
      LODWORD(v5) = "NIGHTSTICK";
      LODWORD(v6) = "BRASS KNUCKLES";
      HIDWORD(v5) = "POOL CUE";
      HIDWORD(v6) = "BASEBALL BAT";
      v1 = "CHAINSAW";
      v3 = "KATANA";
      *(_QWORD *)pszEntries = v6;
      v13 = v5;
      v14 = "GOLF CLUB";
      v4 = 8;
      v15 = "SHOVEL";
      v16 = "KNIFE";
      v2 = 9;
      v0 = 7;
      goto LABEL_15;
    case 1:
      v7 = (unsigned __int8 *)&dword_2FEA98;
      v1 = "DESERT EAGLE";
      v3 = "SLIENCED 9MM";
      goto LABEL_7;
    case 2:
      v1 = (const char *)&dword_2FEA8C;
      pszEntries[0] = "TEC-9";
      v3 = "MICRO SMG";
      goto LABEL_8;
    case 3:
      v7 = "SHOTGUN";
      v1 = "SPAS";
      v3 = (const char *)&unk_60F96E;
LABEL_7:
      pszEntries[0] = v7;
LABEL_8:
      v4 = 2;
      v2 = 3;
      v0 = 1;
      goto LABEL_15;
    case 4:
      goto LABEL_15;
    case 5:
      v4 = 1;
      v2 = 2;
      v3 = "RIFLE";
      v1 = "SNIPER RIFLE";
      v0 = 0;
      goto LABEL_15;
    case 6:
      pszEntries[1] = "GRENADE";
      pszEntries[0] = "MOLOTOV COCKTAIL";
      v1 = (const char *)&aC4;
      v4 = 3;
      v2 = 4;
      v3 = "TEAR GAS";
      v0 = 2;
      goto LABEL_15;
    case 7:
      pszEntries[1] = "MINI GUN";
      pszEntries[0] = "FLAME THROWER";
      v1 = "HS ROCKET LAUNCHER";
      v4 = 3;
      v2 = 4;
      v3 = "ROCKET LAUNCHER";
      v0 = 2;
      goto LABEL_15;
    case 8:
      v1 = "NIGHT-VISION GOGGLES";
      LODWORD(v10) = "FIRE EXTINGUISHER";
      LODWORD(v11) = "SPRAY CAN";
      v2 = 6;
      HIDWORD(v10) = "PARACHUTE";
      v4 = 5;
      HIDWORD(v11) = "CAMERA";
      *(_QWORD *)pszEntries = v11;
      v13 = v10;
      v3 = "THERMAL GOGGLES";
      goto LABEL_14;
    case 9:
      v1 = "VIBRA2";
      LODWORD(v8) = "DILDO1";
      LODWORD(v9) = "CANE";
      v2 = 6;
      HIDWORD(v8) = "DILDO2";
      v4 = 5;
      HIDWORD(v9) = "FLOWERS";
      *(_QWORD *)pszEntries = v9;
      v13 = v8;
      v3 = "VIBRA1";
LABEL_14:
      v0 = 4;
LABEL_15:
      pszEntries[v0] = (unsigned __int8 *)v3;
      pszEntries[v4] = (unsigned __int8 *)v1;
      break;
    default:
      v2 = 0;
      break;
  }
  CTouchInterface::CreateListTextWidget((const unsigned __int8 **)pszEntries, v2, WIDGET_WEAPON_SLOT_CHEATS, 0, 0, 1);
  CTimer::StartUserPause();
}
// 2FEA5C: using guessed type void *aC4;
// 2FEA8C: using guessed type int dword_2FEA8C;
// 2FEA98: using guessed type int dword_2FEA98;
// 2FE7E4: using guessed type unsigned __int8 pszAsciiName[260];

//----- (002FEAC4) --------------------------------------------------------
void CCheat::xboxHelperCheat()
{
  CStats::SetStatValue(0x85u, 49.0);
  CStats::SetStatValue(0x1Eu, 6968.0);
  sub_195D58(0x79u, 3999.0);
}

//----- (002FEAF4) --------------------------------------------------------
int __fastcall CCheat::FindCheatIndex(const unsigned __int8 *label)
{
  int v2; // r4

  v2 = 0;
  while ( strcmp((const char *)label, (const char *)CCheat::CheatLabel[v2]) )
  {
    if ( v2++ >= 110 )
      return -1;
  }
  return v2;
}

//----- (002FEB2C) --------------------------------------------------------
void CCheat::DoCheats()
{
  RsKeyCodes_0 i; // r4
  OSKeyboardKey v1; // r0

  for ( i = 0; i != 256; ++i )
  {
    CPad::GetPad(0);
    v1 = RsKeyToOSWKey(i);
    if ( v1 != KK_MAX )
    {
      if ( LIB_KeyboardPressed(v1) )
        CCheat::AddToCheatString(i);
    }
  }
}

//----- (002FEB60) --------------------------------------------------------
void __fastcall CCheat::AddToCheatString(unsigned __int8 NewChar)
{
  int i; // r1
  int v2; // r4
  int v3; // r0
  int v4; // r1
  int v5; // r6
  uint32 Key; // r0
  bool v7; // cc
  GxtChar *v8; // r0
  GxtChar *v9; // r0
  GxtChar *v10; // r0
  void (*v11)(void); // r0
  char v12[8]; // [sp+Eh] [bp-3Ah] BYREF

  if ( !CCutsceneMgr::ms_running )
  {
    for ( i = 29; i > 0; --i )
      CCheat::m_CheatString[i] = CCheat::m_CheatString[i - 1];
    CCheat::m_CheatString[29] = 0;
    CCheat::m_CheatString[0] = NewChar;
    v2 = strlen((const char *)CCheat::m_CheatString);
    v3 = 0;
    v4 = 0;
    if ( v2 > 5 )
      v3 = 1;
    if ( (unsigned int)v2 > 5 )
      v4 = 1;
    if ( (v4 & v3) != 0 )
    {
LABEL_9:
      strncpy(v12, (const char *)CCheat::m_CheatString, v2);
      v5 = 0;
      v12[v2] = 0;
      Key = CKeyGen::GetKey((const unsigned __int8 *)v12);
      while ( CCheat::m_aCheatHashKeys[v5] != Key )
      {
        v7 = v5++ < 110;
        if ( !v7 )
        {
          v7 = v2-- <= 6;
          v12[v2] = 0;
          if ( v7 )
            return;
          goto LABEL_9;
        }
      }
      if ( CCheat::m_aCheatsActive[v5] )
      {
        v8 = CText::Get(&TheText, "CHEAT8");
        CHud::SetHelpMessage("CHEAT8", v8, 1, 0, 0, 0);
      }
      else
      {
        v9 = CText::Get(&TheText, "CHEAT1");
        CHud::SetHelpMessage("CHEAT1", v9, 1, 0, 0, 0);
        if ( !CCheat::AddToCheatString(char)::bDisplayedCheatWarning )
        {
          v10 = CText::Get(&TheText, "YOUCHTD");
          CHud::SetHelpMessage("YOUCHTD", v10, 1, 0, 0, 0);
          CCheat::AddToCheatString(char)::bDisplayedCheatWarning = 1;
        }
      }
      CStats::IncrementStat(0x89u, 1.0);
      CCheat::m_bHasPlayerCheated = 1;
      v11 = CCheat::m_aCheatFunctions[v5];
      if ( v11 )
        v11();
      else
        CCheat::m_aCheatsActive[v5] = CCheat::m_aCheatsActive[v5] == 0;
      CCheat::m_CheatString[0] = 0;
    }
  }
}
// 796894: using guessed type char CCheat::AddToCheatString(char)::bDisplayedCheatWarning;
// 2FEB60: using guessed type char var_3A[8];

//----- (002FED44) --------------------------------------------------------
void CCheat::ResetCheats()
{
  *(_QWORD *)&CCheat::m_aCheatsActive[95] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[103] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[80] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[88] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[64] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[72] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[48] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[56] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[32] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[40] = 0LL;
  *(_QWORD *)CCheat::m_aCheatsActive = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[8] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[16] = 0LL;
  *(_QWORD *)&CCheat::m_aCheatsActive[24] = 0LL;
  CWeather::ReleaseWeather();
  CCheat::m_CheatString[0] = 0;
  CTimer::ms_fTimeScale = 1.0;
  CCheat::m_bHasPlayerCheated = 0;
}

//----- (002FEDB8) --------------------------------------------------------
void __fastcall DebugHelpSystem(const unsigned __int8 *pszcmd, const unsigned __int8 *pszString, int nFlags)
{
  int v5; // r10
  int v6; // r11
  int v7; // r5
  int v8; // r4
  int v9; // r0
  int v10; // r8
  __int64 v11; // r0
  int32 value; // r0
  GxtChar *v13; // r0
  GxtChar *v14; // r0

  v5 = strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_TOUCH");
  v6 = strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_HID");
  v7 = strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_TOUCH_CLASSIC");
  v8 = strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_TOUCH_ADAPTED");
  v9 = strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_HID_JOYPAD");
  v10 = 2680;
  if ( v5 )
    v10 = 0;
  if ( !v6 )
    v10 = 2681;
  if ( !v7 )
    v10 = 2682;
  if ( !v8 )
    v10 = 2683;
  if ( !v9 )
    v10 = 2684;
  if ( !strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_HID_KEYBOARD") )
    v10 = 2685;
  if ( !strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_TOUCH_ANALOG") )
    v10 = 2686;
  if ( !strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_TOUCH_DIGITAL") )
    v10 = 2687;
  if ( !strcasecmp((const char *)pszcmd, "PRINT_HELP_FOREVER_CONDITIONAL_TOUCH_FLICK") )
    v10 = 2688;
  switch ( v10 )
  {
    case 2680:
      if ( !CHID::GetInputType() )
        goto LABEL_38;
      return;
    case 2681:
      if ( CHID::GetInputType() == 1 )
        goto LABEL_38;
      goto LABEL_23;
    case 2682:
      LODWORD(v11) = CHID::GetInputType();
      HIDWORD(v11) = MobileSettings::settings[9].value;
      goto LABEL_30;
    case 2683:
      if ( CHID::GetInputType() )
        return;
      value = MobileSettings::settings[9].value;
      goto LABEL_34;
    case 2684:
      value = CHID::GetInputType();
      goto LABEL_34;
    case 2685:
LABEL_23:
      if ( CHID::GetInputType() != 2 )
        return;
      goto LABEL_38;
    case 2686:
      LODWORD(v11) = CHID::GetInputType();
      HIDWORD(v11) = MobileSettings::settings[3].value;
LABEL_30:
      if ( !v11 )
        goto LABEL_38;
      return;
    case 2687:
      if ( CHID::GetInputType() )
        return;
      value = MobileSettings::settings[3].value;
LABEL_34:
      if ( value == 1 )
      {
LABEL_38:
        v13 = CText::Get(&TheText, pszString);
        CHud::SetHelpMessage(pszString, v13, 0, 1, 0, nFlags);
        v14 = CText::Get(&TheText, pszString);
        CMessages::AddToPreviousBriefArray(pszString, v14, -1, -1, -1, -1, -1, -1, 0);
      }
      return;
    case 2688:
      if ( !CHID::GetInputType() && MobileSettings::settings[3].value == 2 )
        goto LABEL_38;
      return;
    default:
      goto LABEL_38;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002FF010) --------------------------------------------------------
void CCheat::HealthCheat()
{
  float MaxHealth; // s16
  int32 m_baseVehicleType; // r5
  CVehicle *PlayerVehicle; // r0
  CVehicle *v3; // r0

  MaxHealth = (float)CWorld::Players[0].MaxHealth;
  FindPlayerPed(-1)->m_nHealth = MaxHealth;
  if ( FindPlayerVehicle(-1, 0) )
  {
    FindPlayerVehicle(-1, 0)->m_nHealth = 1000.0;
    if ( !FindPlayerVehicle(-1, 0)->m_baseVehicleType || FindPlayerVehicle(-1, 0)->m_baseVehicleType == 9 )
    {
      m_baseVehicleType = FindPlayerVehicle(-1, 0)->m_baseVehicleType;
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      if ( m_baseVehicleType )
        *(_DWORD *)&PlayerVehicle[1].m_VehicleAudioEntity.m_DummySlot = 0;
      else
        PlayerVehicle[1].m_VehicleAudioEntity.m_SkidSound.m_pAudioEntity = 0;
      v3 = FindPlayerVehicle(-1, 0);
      (*((void (__fastcall **)(CVehicle *))v3->_vptr$CPlaceable + 51))(v3);
    }
  }
}

//----- (002FF0C8) --------------------------------------------------------
CVehicle *__fastcall CCheat::VehicleCheat(int32 modelId)
{
  __int128 v1; // q9
  CMonsterTruck *v3; // r4
  int32 m_nSize; // r0
  int v6; // r4
  int8x16_t v7; // q8
  unsigned int v8; // r2
  int64x2_t v9; // q10
  uint8 *m_aFlags; // r1
  int v11; // t1
  int32x4_t v12; // q8
  int v13; // r3
  uint8 *v14; // r1
  int v15; // r0
  unsigned int v16; // t1
  CStreamingInfo *v17; // r5
  uint8 m_flags; // r6
  float m_fRadius; // s16
  CPlayerPed *PlayerPed; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v23; // d16
  float v24; // s16
  CMatrix *v25; // r0
  float v26; // s4
  float v27; // s2
  float v28; // s0
  CMatrix *v29; // r0
  float *p_tz; // r0
  float m_fCurrentHeading; // s2
  CMatrix *v32; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float *p_xx; // r0
  float v37; // s2
  float v38; // s4
  CEntity::CEntityInfo m_info; // r1
  int32 m_baseVehicleType; // r0
  CVector Coors; // [sp+8h] [bp-38h] BYREF

  if ( FindPlayerPed(-1)->m_areaCode )
    return 0;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize >= 1 )
  {
    if ( (unsigned int)m_nSize >= 4 && (v6 = m_nSize & 0x7FFFFFFC, (m_nSize & 0xFFFFFFFC) != 0) )
    {
      v7 = 0uLL;
      LODWORD(v1) = 65537;
      WORD2(v1) = 1;
      WORD3(v1) = 1;
      v8 = m_nSize & 0xFFFFFFFC;
      v9.n128_u64[0] = 0xFF000000FFLL;
      v9.n128_u64[1] = 0xFF000000FFLL;
      m_aFlags = CPools::ms_pVehiclePool->m_aFlags;
      do
      {
        v11 = *(_DWORD *)m_aFlags;
        m_aFlags += 4;
        v8 -= 4;
        DWORD2(v1) = v11;
        *((_QWORD *)&v1 + 1) = v1 ^ vshr_n_u16((uint16x4_t)vmovl_u8(*((uint8x8_t *)&v1 + 1)).n128_u64[0], 7u).n64_u64[0];
        v7 = vaddq_s32(v7, vandq_s64(vmovl_u16(*((uint16x4_t *)&v1 + 1)), v9));
      }
      while ( v8 );
      v12 = vaddq_s32(v7, vextq_s8(v7, v7, 8u));
      v13 = vaddq_s32(v12, vdupq_lane_s32((int32x2_t)v12.n128_u64[0], 1)).n128_u32[0];
      if ( m_nSize == v6 )
      {
LABEL_14:
        if ( v13 > 50 )
          return 0;
        goto LABEL_15;
      }
    }
    else
    {
      v6 = 0;
      v13 = 0;
    }
    v14 = &CPools::ms_pVehiclePool->m_aFlags[v6];
    v15 = m_nSize - v6;
    do
    {
      v16 = *v14++;
      --v15;
      v13 += (v16 >> 7) ^ 1;
    }
    while ( v15 );
    goto LABEL_14;
  }
LABEL_15:
  v17 = &CStreaming::ms_aInfoForModel[modelId];
  m_flags = v17->m_flags;
  CStreaming::RequestModel(modelId, 2);
  v3 = 0;
  CStreaming::LoadAllRequestedModels(0);
  if ( v17->m_status == 1 )
  {
    if ( (m_flags & 2) == 0 )
    {
      CStreaming::SetModelIsDeletable(modelId);
      CStreaming::SetModelTxdIsDeletable(modelId);
    }
    switch ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[modelId][1].m_modelName[20] )
    {
      case 1:
        v3 = (CMonsterTruck *)CVehicle::operator new(0x9B0u);
        CMonsterTruck::CMonsterTruck(v3, modelId, 1u);
        if ( v3 )
          goto LABEL_36;
        return v3;
      case 2:
        v3 = (CMonsterTruck *)CVehicle::operator new(0x9D0u);
        CQuadBike::CQuadBike((CQuadBike *)v3, modelId, 1u);
        if ( v3 )
          goto LABEL_36;
        return v3;
      case 3:
        v3 = (CMonsterTruck *)CVehicle::operator new(0xA2Cu);
        CHeli::CHeli((CHeli *)v3, modelId, 1u);
        if ( v3 )
          goto LABEL_36;
        return v3;
      case 4:
        v3 = (CMonsterTruck *)CVehicle::operator new(0xA18u);
        CPlane::CPlane((CPlane *)v3, modelId, 1u);
        if ( v3 )
          goto LABEL_36;
        return v3;
      case 5:
        v3 = (CMonsterTruck *)CVehicle::operator new(0x7FCu);
        CBoat::CBoat((CBoat *)v3, modelId, 1u);
        if ( v3 )
          goto LABEL_36;
        return v3;
      case 9:
        v3 = (CMonsterTruck *)CVehicle::operator new(0x828u);
        CBike::CBike((CBike *)v3, modelId, 1u);
        goto LABEL_33;
      case 0xA:
        v3 = (CMonsterTruck *)CVehicle::operator new(0x84Cu);
        CBmx::CBmx((CBmx *)v3, modelId, 1u);
LABEL_33:
        LOBYTE(v3->Door[3].m_fAngVel) |= 0x10u;
        if ( !v3 )
          return v3;
        goto LABEL_36;
      case 0xB:
        v3 = (CMonsterTruck *)CVehicle::operator new(0xA08u);
        CTrailer::CTrailer((CTrailer *)v3, modelId, 1u);
        if ( v3 )
          goto LABEL_36;
        return v3;
      default:
        v3 = (CMonsterTruck *)CVehicle::operator new(0x99Cu);
        CAutomobile::CAutomobile(v3, modelId, 1u, 1u);
        if ( !v3 )
          return v3;
LABEL_36:
        m_fRadius = CModelInfo::ms_modelInfoPtrs[v3->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
        PlayerPed = FindPlayerPed(-1);
        m_pMat = PlayerPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &PlayerPed->m_transform;
        v23 = *(_QWORD *)&p_tx->m_translate.x;
        Coors.z = p_tx->m_translate.z;
        v24 = m_fRadius + 2.0;
        *(_QWORD *)&Coors.x = v23;
        v25 = FindPlayerPed(-1)->m_pMat;
        v26 = (float)(v24 * v25->xy) + *(float *)&v23;
        v27 = (float)(v24 * v25->yy) + *((float *)&v23 + 1);
        v28 = (float)(v24 * v25->zy) + Coors.z;
        Coors.x = v26;
        Coors.y = v27;
        Coors.z = v28;
        v29 = v3->m_pMat;
        if ( v29 )
        {
          v29->tx = v26;
          v3->m_pMat->ty = v27;
          p_tz = &v3->m_pMat->tz;
        }
        else
        {
          p_tz = &v3->m_transform.m_translate.z;
          v3->m_transform.m_translate.x = v26;
          v3->m_transform.m_translate.y = v27;
        }
        *p_tz = v28;
        m_fCurrentHeading = FindPlayerPed(-1)->m_fCurrentHeading;
        v32 = v3->m_pMat;
        if ( v32 )
        {
          tx = v32->tx;
          ty = v32->ty;
          tz = v32->tz;
          CMatrix::SetRotate(v32, 0.0, 0.0, m_fCurrentHeading + 1.5708);
          p_xx = &v3->m_pMat->xx;
          v37 = ty + p_xx[13];
          v38 = tz + p_xx[14];
          p_xx[12] = tx + p_xx[12];
          p_xx[13] = v37;
          p_xx[14] = v38;
        }
        else
        {
          v3->m_transform.m_heading = m_fCurrentHeading + 1.5708;
        }
        m_info = v3->m_info;
        v3->m_eDoorLockState = CARLOCK_UNLOCKED;
        v3->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x20);
        CWorld::Add(v3);
        CTheScripts::ClearSpaceForMissionEntity(&Coors, v3);
        m_baseVehicleType = v3->m_baseVehicleType;
        if ( m_baseVehicleType != 5 )
        {
          if ( m_baseVehicleType == 9 )
            CBike::PlaceOnRoadProperly((CBike *)v3);
          else
            CAutomobile::PlaceOnRoadProperly(v3);
        }
        break;
    }
  }
  return v3;
}
// 2FF10C: mask 0xFFFFFFFC is shortened because r0.4 <= 0x7FFFFFFF
// 2FF130: variable 'v1' is possibly undefined
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002FF414) --------------------------------------------------------
void CCheat::ClearMissionSkip()
{
  CPlayerPed *PlayerPed; // r0

  CPad::m_fLastMissionSkipScroll = CWidgetListText::m_fLastScroll;
  CTouchInterface::DeleteWidget(WIDGET_MISSION_SKIP);
  CTimer::EndUserPause();
  if ( CHID::GetInputType() == 1 )
  {
    PlayerPed = FindPlayerPed(-1);
    sub_18B1E4(PlayerPed);
  }
}

//----- (002FF454) --------------------------------------------------------
void CCheat::EndPause()
{
  CPlayerPed *PlayerPed; // r0

  CTimer::EndUserPause();
  if ( CHID::GetInputType() == 1 )
  {
    PlayerPed = FindPlayerPed(-1);
    sub_18B1E4(PlayerPed);
  }
}

//----- (002FF478) --------------------------------------------------------
void CCheat::ClearGameCheatsList()
{
  CPlayerPed *PlayerPed; // r0

  CPad::m_fLastCheatScroll = CWidgetListText::m_fLastScroll;
  CTouchInterface::DeleteWidget(WIDGET_CHEATS);
  CTimer::EndUserPause();
  if ( CHID::GetInputType() == 1 )
  {
    PlayerPed = FindPlayerPed(-1);
    sub_18B1E4(PlayerPed);
  }
}

//----- (002FF4B8) --------------------------------------------------------
void CCheat::HandleGameCheats()
{
  CPlayerPed *PlayerPed; // r0
  int v1; // r0
  int v2; // r1
  unsigned __int8 *v3; // r3
  unsigned __int8 *pszEntries[258]; // [sp+8h] [bp-408h] BYREF

  if ( CTouchInterface::m_pWidgets[154] )
  {
    CPad::m_fLastCheatScroll = CWidgetListText::m_fLastScroll;
    CTouchInterface::DeleteWidget(WIDGET_CHEATS);
    CTimer::EndUserPause();
    if ( CHID::GetInputType() == 1 )
    {
      PlayerPed = FindPlayerPed(-1);
      sub_18B1E4(PlayerPed);
    }
  }
  else
  {
    v1 = 0;
    v2 = 0;
    do
    {
      v3 = (unsigned __int8 *)CCheat::CheatLabel[v1++];
      if ( v3 )
        pszEntries[v2++] = v3;
    }
    while ( v1 != 111 );
    CWidgetListText::m_fLastScroll = CPad::m_fLastCheatScroll;
    CTouchInterface::CreateListTextWidget((const unsigned __int8 **)pszEntries, v2, WIDGET_CHEATS, 0, 0, 1);
    CTimer::StartUserPause();
  }
}

//----- (002FF568) --------------------------------------------------------
void CCheat::HandleCarCheat()
{
  CPlayerPed *PlayerPed; // r0
  int v1; // r0
  int v2; // r1
  CBaseModelInfo **v3; // r3
  CBaseModelInfo *v4; // r3
  unsigned __int8 *pszEntries[258]; // [sp+8h] [bp-408h] BYREF

  if ( CTouchInterface::m_pWidgets[152] )
  {
    CPad::m_fLastCarCheatScroll = CWidgetListText::m_fLastScroll;
    CTouchInterface::DeleteWidget(WIDGET_CAR_CHEATS);
    CTimer::EndUserPause();
    if ( CHID::GetInputType() == 1 )
    {
      PlayerPed = FindPlayerPed(-1);
      sub_18B1E4(PlayerPed);
    }
  }
  else
  {
    v1 = 0;
    v2 = 0;
    do
    {
      v3 = &CModelInfo::ms_modelInfoPtrs[v1++];
      v4 = v3[400];
      if ( v4 )
        pszEntries[v2++] = &v4[1].m_modelName[10];
    }
    while ( v1 != 212 );
    CWidgetListText::m_fLastScroll = CPad::m_fLastCarCheatScroll;
    CTouchInterface::CreateListTextWidget((const unsigned __int8 **)pszEntries, v2, WIDGET_CAR_CHEATS, 1, 1, 0);
    CTimer::StartUserPause();
  }
}

//----- (002FF620) --------------------------------------------------------
void __fastcall CCheat::HandleMissionJump(bool TriggerMissionJumpWidget, int MissionPage)
{
  CPlayerPed *PlayerPed; // r0
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r10
  int v7; // r4
  const char *v8; // r1
  char *v9; // r5
  unsigned __int8 *pszEntries[263]; // [sp+Ch] [bp-41Ch] BYREF

  if ( TriggerMissionJumpWidget )
  {
    if ( CTouchInterface::m_pWidgets[153] )
    {
      CPad::m_fLastMissionSkipScroll = CWidgetListText::m_fLastScroll;
      CTouchInterface::DeleteWidget(WIDGET_MISSION_SKIP);
      CTimer::EndUserPause();
      if ( CHID::GetInputType() == 1 )
      {
        PlayerPed = FindPlayerPed(-1);
        sub_18B1E4(PlayerPed);
      }
    }
    else
    {
      v3 = MissionPage - 1;
      SkipToMissionPage = MissionPage;
      v4 = numMissions[MissionPage - 1];
      currentMissionPage = v3;
      if ( v4 < 1 )
      {
        v7 = 0;
      }
      else
      {
        v5 = 0;
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = (const char *)missionLabel[v3][v5];
          if ( v8 )
          {
            v9 = (char *)missionList[v5];
            strcpy(v9, v8);
            pszEntries[v7++] = (unsigned __int8 *)v9;
            v3 = currentMissionPage;
          }
          v5 = (unsigned __int16)++v6;
        }
        while ( numMissions[v3] > (unsigned __int16)v6 );
      }
      CWidgetListText::m_fLastScroll = CPad::m_fLastMissionSkipScroll;
      CTouchInterface::CreateListTextWidget((const unsigned __int8 **)pszEntries, v7, WIDGET_MISSION_SKIP, 0, 1, 1);
      CTimer::StartUserPause();
    }
  }
}
// 6792C4: using guessed type int *SkipToMissionPage_ptr;

//----- (002FF760) --------------------------------------------------------
void __fastcall CCheat::HandleCheatMenu(bool force)
{
  _BOOL4 v1; // r4
  CPad *Pad; // r0
  CTouchInterface::WidgetIDs v3; // r0
  CPlayerPed *PlayerPed; // r0
  __int64 v5; // d17
  __int64 v6; // d19
  __int64 v7; // d16
  __int64 v8; // d18
  WidgetPosition WidgetPos; // [sp+10h] [bp-418h] BYREF
  __int64 pszEntries[128]; // [sp+20h] [bp-408h] BYREF

  v1 = force;
  if ( CPad::GetPad(0)->NewState.RightShoulder2 && (Pad = CPad::GetPad(0), Pad->NewState.DPadDown) )
  {
    if ( !Pad->OldState.DPadDown || v1 )
      goto LABEL_8;
  }
  else if ( v1 )
  {
    goto LABEL_9;
  }
  if ( !CTouchInterface::IsDoubleTapped(WIDGET_CHEATS_RECT, 0, 1) )
    return;
LABEL_8:
  if ( !v1 )
  {
    if ( CTouchInterface::m_pWidgets[153] )
    {
      CCheat::HandleMissionJump(1, 0);
      goto LABEL_22;
    }
    if ( CTouchInterface::m_pWidgets[154] )
    {
      CCheat::HandleGameCheats();
      goto LABEL_22;
    }
    if ( CTouchInterface::m_pWidgets[152] )
    {
      CCheat::HandleCarCheat();
      goto LABEL_22;
    }
  }
LABEL_9:
  if ( CTouchInterface::m_pWidgets[155] )
  {
    v3 = WIDGET_CHEAT_MENU;
    goto LABEL_15;
  }
  if ( CTouchInterface::m_pWidgets[151] )
  {
    v3 = WIDGET_WEAPON_SLOT_CHEATS;
LABEL_15:
    CTouchInterface::DeleteWidget(v3);
    CTimer::EndUserPause();
    if ( CHID::GetInputType() == 1 )
    {
      PlayerPed = FindPlayerPed(-1);
      CPlayerPed::ClearWeaponTarget(PlayerPed);
    }
    goto LABEL_22;
  }
  LODWORD(v5) = "CHT_MJ0";
  LODWORD(v6) = "CHT_MJ4";
  LODWORD(v7) = "CHT_GAM";
  LODWORD(v8) = "CHT_MJ2";
  HIDWORD(v5) = "CHT_MJ1";
  HIDWORD(v7) = "CHT_CAR";
  HIDWORD(v6) = "CHT_FPS";
  HIDWORD(v8) = "CHT_MJ3";
  pszEntries[0] = v7;
  pszEntries[1] = v5;
  pszEntries[2] = v8;
  pszEntries[3] = v6;
  CWidgetListText::m_fLastScroll = 0.0;
  *(_QWORD *)&WidgetPos.m_fOriginX = 0x435C000043A00000LL;
  *(_QWORD *)&WidgetPos.m_fScaleX = 0x42B4000042A00000LL;
  CTouchInterface::CreateListTextWidget((const unsigned __int8 **)pszEntries, 8, WIDGET_CHEAT_MENU, &WidgetPos, 0, 1, 0);
  CTimer::StartUserPause();
LABEL_22:
  CTouchInterface::ClearTapHistory(WIDGET_CHEATS_RECT);
}

//----- (002FF8EC) --------------------------------------------------------
void CCheat::ProcessDebugCarCheats()
{
  CWidgetList *v0; // r4
  int v1; // r5
  CBaseModelInfo *v2; // r0
  int32 v3; // r0
  CPlayerPed *PlayerPed; // r0
  unsigned __int8 v6[260]; // [sp+0h] [bp-118h] BYREF

  v0 = (CWidgetList *)CTouchInterface::m_pWidgets[152];
  if ( CTouchInterface::m_pWidgets[152]
    && (CTouchInterface::IsReleased(WIDGET_CAR_CHEATS, 0, 1) || CHID::IsReleased(HID_MAPPING_ACCEPT))
    && CWidgetList::GetSelectedEntry(v0, v6) != -1 )
  {
    v1 = 400;
    while ( 1 )
    {
      v2 = CModelInfo::ms_modelInfoPtrs[v1];
      if ( v2 )
      {
        if ( !strcasecmp((const char *)&v2[1].m_modelName[10], (const char *)v6) )
          break;
      }
      v3 = v1 + 1;
      if ( v1++ > 628 )
        goto LABEL_11;
    }
    v3 = v1;
LABEL_11:
    CPad::m_fLastCarCheatScroll = CWidgetListText::m_fLastScroll;
    CCheat::VehicleCheat(v3);
    CTouchInterface::DeleteWidget(WIDGET_CAR_CHEATS);
    CTimer::EndUserPause();
    if ( CHID::GetInputType() == 1 )
    {
      PlayerPed = FindPlayerPed(-1);
      CPlayerPed::ClearWeaponTarget(PlayerPed);
    }
  }
}

//----- (002FF9C0) --------------------------------------------------------
void CCheat::ProcessDebugMissionSkip()
{
  CWidgetList *v0; // r4
  int SelectedEntry; // r0
  CPlayerPed *PlayerPed; // r0
  unsigned __int8 v3[260]; // [sp+0h] [bp-110h] BYREF

  v0 = (CWidgetList *)CTouchInterface::m_pWidgets[153];
  if ( CTouchInterface::m_pWidgets[153]
    && (CTouchInterface::IsReleased(WIDGET_MISSION_SKIP, 0, 1) || CHID::IsReleased(HID_MAPPING_ACCEPT)) )
  {
    SelectedEntry = CWidgetList::GetSelectedEntry(v0, v3);
    if ( SelectedEntry != -1 )
    {
      SkipToMissionNumber = SelectedEntry;
      currentSkipToMissionNumber = SelectedEntry;
      missionReplaySetting = 0;
      CPad::m_fLastMissionSkipScroll = CWidgetListText::m_fLastScroll;
      if ( CTheScripts::IsPlayerOnAMission() )
        DoMissionCleanup = 1;
      CPad::m_fLastMissionSkipScroll = CWidgetListText::m_fLastScroll;
      CTouchInterface::DeleteWidget(WIDGET_MISSION_SKIP);
      CTimer::EndUserPause();
      if ( CHID::GetInputType() == 1 )
      {
        PlayerPed = FindPlayerPed(-1);
        CPlayerPed::ClearWeaponTarget(PlayerPed);
      }
    }
  }
}
// 2FF9C0: using guessed type unsigned __int8 anonymous_0[260];

//----- (002FFAB4) --------------------------------------------------------
void CCheat::ProcessCheatMenu()
{
  CWidgetList *v0; // r4
  int SelectedEntry; // r4
  char v2[260]; // [sp+0h] [bp-110h] BYREF

  v0 = (CWidgetList *)CTouchInterface::m_pWidgets[155];
  if ( CTouchInterface::m_pWidgets[155] )
  {
    CPad::GetPad(0)->bHasCheated = 1;
    if ( CTouchInterface::IsReleased(WIDGET_CHEAT_MENU, 0, 1) || CHID::IsReleased(HID_MAPPING_ACCEPT) )
    {
      SelectedEntry = CWidgetList::GetSelectedEntry(v0, (unsigned __int8 *)v2);
      if ( SelectedEntry != -1 )
      {
        CCheat::HandleCheatMenu(1);
        switch ( SelectedEntry )
        {
          case 0:
            CCheat::HandleGameCheats();
            break;
          case 1:
            CCheat::HandleCarCheat();
            break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            CCheat::HandleMissionJump(1, SelectedEntry - 1);
            break;
          case 7:
            ToggleDebugFPS();
            break;
          default:
            return;
        }
      }
    }
  }
}
// 2FFAB4: using guessed type unsigned __int8 anonymous_0[260];

//----- (002FFB54) --------------------------------------------------------
int CCheat::ProcessCheats()
{
  CWidgetList *v0; // r4
  int v1; // r5
  void (*v4)(void); // r0
  CPlayerPed *PlayerPed; // r0
  unsigned __int8 v6[260]; // [sp+0h] [bp-118h] BYREF

  v0 = (CWidgetList *)CTouchInterface::m_pWidgets[154];
  if ( !CTouchInterface::m_pWidgets[154]
    || !CTouchInterface::IsReleased(WIDGET_CHEATS, 0, 1) && !CHID::IsReleased(HID_MAPPING_ACCEPT) )
  {
    return 0;
  }
  if ( CWidgetList::GetSelectedEntry(v0, v6) != -1 )
  {
    v1 = 0;
    while ( strcmp((const char *)v6, (const char *)CCheat::CheatLabel[v1]) )
    {
      if ( v1++ >= 110 )
        return 1;
    }
    if ( v1 != -1 )
    {
      v4 = CCheat::m_aCheatFunctions[v1];
      if ( v4 )
        v4();
      else
        CCheat::m_aCheatsActive[v1] = CCheat::m_aCheatsActive[v1] == 0;
      CPad::m_fLastCheatScroll = CWidgetListText::m_fLastScroll;
      CTouchInterface::DeleteWidget(WIDGET_CHEATS);
      CTimer::EndUserPause();
      if ( CHID::GetInputType() == 1 )
      {
        PlayerPed = FindPlayerPed(-1);
        CPlayerPed::ClearWeaponTarget(PlayerPed);
      }
    }
  }
  return 1;
}

//----- (002FFC4C) --------------------------------------------------------
void HandleSlotMelee()
{
  CPlayerPed *PlayerPed; // r0
  eWeaponType v1; // r1
  unsigned __int8 v2[260]; // [sp+0h] [bp-110h] BYREF

  switch ( CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v2) )
  {
    case 0:
      CStreaming::RequestModel(331, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_BRASSKNUCKLE;
      goto LABEL_11;
    case 1:
      CStreaming::RequestModel(336, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_BASEBALLBAT;
      goto LABEL_11;
    case 2:
      CStreaming::RequestModel(334, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_NIGHTSTICK;
      goto LABEL_11;
    case 3:
      CStreaming::RequestModel(338, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_POOL_CUE;
      goto LABEL_11;
    case 4:
      CStreaming::RequestModel(333, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_GOLFCLUB;
      goto LABEL_11;
    case 5:
      CStreaming::RequestModel(337, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_SHOVEL;
      goto LABEL_11;
    case 6:
      CStreaming::RequestModel(335, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_KNIFE;
      goto LABEL_11;
    case 7:
      CStreaming::RequestModel(339, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_KATANA;
      goto LABEL_11;
    case 8:
      CStreaming::RequestModel(341, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_CHAINSAW;
LABEL_11:
      CPed::GiveWeapon(PlayerPed, v1, 1u, 1);
      break;
    default:
      return;
  }
}
// 2FFC4C: using guessed type unsigned __int8 anonymous_0[260];

//----- (002FFDA4) --------------------------------------------------------
void HandleSlotHandguns()
{
  int SelectedEntry; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v2; // r1
  unsigned __int8 v3[260]; // [sp+0h] [bp-110h] BYREF

  SelectedEntry = CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v3);
  if ( SelectedEntry == 2 )
  {
    CStreaming::RequestModel(348, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_DESERT_EAGLE;
  }
  else if ( SelectedEntry == 1 )
  {
    CStreaming::RequestModel(347, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_PISTOL_SILENCED;
  }
  else
  {
    if ( SelectedEntry )
      return;
    CStreaming::RequestModel(346, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_PISTOL;
  }
  CPed::GiveWeapon(PlayerPed, v2, 0x1F4u, 1);
}
// 2FFDA4: using guessed type unsigned __int8 anonymous_0[260];

//----- (002FFE4C) --------------------------------------------------------
void HandleSlotSubmachineGuns()
{
  int SelectedEntry; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v2; // r1
  unsigned __int8 v3[260]; // [sp+0h] [bp-110h] BYREF

  SelectedEntry = CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v3);
  if ( SelectedEntry == 2 )
  {
    CStreaming::RequestModel(353, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_MP5;
  }
  else if ( SelectedEntry == 1 )
  {
    CStreaming::RequestModel(352, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_MICRO_UZI;
  }
  else
  {
    if ( SelectedEntry )
      return;
    CStreaming::RequestModel(372, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_TEC9;
  }
  CPed::GiveWeapon(PlayerPed, v2, 0x1F4u, 1);
}
// 2FFE4C: using guessed type unsigned __int8 anonymous_0[260];

//----- (002FFEF4) --------------------------------------------------------
void HandleSlotShotguns()
{
  int SelectedEntry; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v2; // r1
  unsigned __int8 v3[260]; // [sp+0h] [bp-110h] BYREF

  SelectedEntry = CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v3);
  if ( SelectedEntry == 2 )
  {
    CStreaming::RequestModel(351, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_SPAS12_SHOTGUN;
  }
  else if ( SelectedEntry == 1 )
  {
    CStreaming::RequestModel(350, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_SAWNOFF_SHOTGUN;
  }
  else
  {
    if ( SelectedEntry )
      return;
    CStreaming::RequestModel(349, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_SHOTGUN;
  }
  CPed::GiveWeapon(PlayerPed, v2, 0x1F4u, 1);
}
// 2FFEF4: using guessed type unsigned __int8 anonymous_0[260];

//----- (002FFF9C) --------------------------------------------------------
void HandleSlotAssaultRifles()
{
  int SelectedEntry; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v2; // r1
  unsigned __int8 v3[260]; // [sp+0h] [bp-110h] BYREF

  SelectedEntry = CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v3);
  if ( SelectedEntry == 1 )
  {
    CStreaming::RequestModel(355, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_AK47;
  }
  else
  {
    if ( SelectedEntry )
      return;
    CStreaming::RequestModel(356, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_M4;
  }
  CPed::GiveWeapon(PlayerPed, v2, 0x1F4u, 1);
}
// 2FFF9C: using guessed type unsigned __int8 anonymous_0[260];

//----- (00300024) --------------------------------------------------------
void HandleSlotLongRifles()
{
  int SelectedEntry; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v2; // r1
  unsigned __int8 v3[260]; // [sp+0h] [bp-110h] BYREF

  SelectedEntry = CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v3);
  if ( SelectedEntry == 1 )
  {
    CStreaming::RequestModel(358, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_SNIPERRIFLE;
  }
  else
  {
    if ( SelectedEntry )
      return;
    CStreaming::RequestModel(357, 2);
    CStreaming::LoadAllRequestedModels(0);
    PlayerPed = FindPlayerPed(-1);
    v2 = WEAPONTYPE_COUNTRYRIFLE;
  }
  CPed::GiveWeapon(PlayerPed, v2, 0x1F4u, 1);
}
// 300024: using guessed type unsigned __int8 anonymous_0[260];

//----- (003000AC) --------------------------------------------------------
void HandleSlotThrow()
{
  CPlayerPed *PlayerPed; // r0
  eWeaponType v1; // r1
  unsigned __int8 v2[260]; // [sp+0h] [bp-110h] BYREF

  switch ( CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v2) )
  {
    case 0:
      CStreaming::RequestModel(344, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_MOLOTOV;
      goto LABEL_6;
    case 1:
      CStreaming::RequestModel(342, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_GRENADE;
      goto LABEL_6;
    case 2:
      CStreaming::RequestModel(343, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_TEARGAS;
      goto LABEL_6;
    case 3:
      CStreaming::RequestModel(363, 2);
      CStreaming::RequestModel(364, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_REMOTE_SATCHEL_CHARGE;
LABEL_6:
      CPed::GiveWeapon(PlayerPed, v1, 0x1F4u, 1);
      break;
    default:
      return;
  }
}
// 3000AC: using guessed type unsigned __int8 anonymous_0[260];

//----- (0030017C) --------------------------------------------------------
void HandleSlotArtillery()
{
  CPlayerPed *PlayerPed; // r0
  eWeaponType v1; // r1
  unsigned __int8 v2[260]; // [sp+0h] [bp-110h] BYREF

  switch ( CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v2) )
  {
    case 0:
      CStreaming::RequestModel(361, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_FLAMETHROWER;
      goto LABEL_6;
    case 1:
      CStreaming::RequestModel(362, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_MINIGUN;
      goto LABEL_6;
    case 2:
      CStreaming::RequestModel(359, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_ROCKETLAUNCHER;
      goto LABEL_6;
    case 3:
      CStreaming::RequestModel(360, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_ROCKETLAUNCHER_HS;
LABEL_6:
      CPed::GiveWeapon(PlayerPed, v1, 0x1F4u, 1);
      break;
    default:
      return;
  }
}
// 30017C: using guessed type unsigned __int8 anonymous_0[260];

//----- (00300244) --------------------------------------------------------
void HandleSlotEquipment()
{
  CPlayerPed *PlayerPed; // r0
  eWeaponType v1; // r1
  unsigned __int8 v2[260]; // [sp+0h] [bp-110h] BYREF

  switch ( CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v2) )
  {
    case 0:
      CStreaming::RequestModel(365, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_SPRAYCAN;
      goto LABEL_8;
    case 1:
      CStreaming::RequestModel(367, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_CAMERA;
      goto LABEL_8;
    case 2:
      CStreaming::RequestModel(366, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_EXTINGUISHER;
      goto LABEL_8;
    case 3:
      CStreaming::RequestModel(371, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_PARACHUTE;
      goto LABEL_8;
    case 4:
      CStreaming::RequestModel(369, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_INFRARED;
      goto LABEL_8;
    case 5:
      CStreaming::RequestModel(368, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_NIGHTVISION;
LABEL_8:
      CPed::GiveWeapon(PlayerPed, v1, 0x1F4u, 1);
      break;
    default:
      return;
  }
}
// 300244: using guessed type unsigned __int8 anonymous_0[260];

//----- (00300344) --------------------------------------------------------
void HandleSlotOther()
{
  CPlayerPed *PlayerPed; // r0
  eWeaponType v1; // r1
  unsigned __int8 v2[260]; // [sp+0h] [bp-110h] BYREF

  switch ( CWidgetList::GetSelectedEntry((CWidgetList *)CTouchInterface::m_pWidgets[151], v2) )
  {
    case 0:
      CStreaming::RequestModel(326, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_CANE;
      goto LABEL_8;
    case 1:
      CStreaming::RequestModel(325, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_FLOWERS;
      goto LABEL_8;
    case 2:
      CStreaming::RequestModel(321, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_DILDO1;
      goto LABEL_8;
    case 3:
      CStreaming::RequestModel(322, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_DILDO2;
      goto LABEL_8;
    case 4:
      CStreaming::RequestModel(323, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_VIBE1;
      goto LABEL_8;
    case 5:
      CStreaming::RequestModel(324, 2);
      CStreaming::LoadAllRequestedModels(0);
      PlayerPed = FindPlayerPed(-1);
      v1 = WEAPONTYPE_VIBE2;
LABEL_8:
      CPed::GiveWeapon(PlayerPed, v1, 0x1F4u, 1);
      break;
    default:
      return;
  }
}
// 300344: using guessed type unsigned __int8 anonymous_0[260];

//----- (00300444) --------------------------------------------------------
void CCheat::ProcessWeaponSlotCheats()
{
  CPlayerPed *PlayerPed; // r0

  if ( CTouchInterface::m_pWidgets[151] )
  {
    if ( !CTimer::m_UserPause )
      CTimer::StartUserPause();
    if ( CTouchInterface::IsReleased(WIDGET_WEAPON_SLOT_CHEATS, 0, 1) || CHID::IsReleased(HID_MAPPING_ACCEPT) )
    {
      switch ( nWeaponSlot )
      {
        case 0:
          HandleSlotMelee();
          break;
        case 1:
          HandleSlotHandguns();
          break;
        case 2:
          HandleSlotSubmachineGuns();
          break;
        case 3:
          HandleSlotShotguns();
          break;
        case 4:
          HandleSlotAssaultRifles();
          break;
        case 5:
          HandleSlotLongRifles();
          break;
        case 6:
          HandleSlotThrow();
          break;
        case 7:
          HandleSlotArtillery();
          break;
        case 8:
          HandleSlotEquipment();
          break;
        case 9:
          HandleSlotOther();
          break;
        default:
          break;
      }
      nWeaponSlot = -1;
      CTouchInterface::DeleteWidget(WIDGET_WEAPON_SLOT_CHEATS);
      CTimer::EndUserPause();
      if ( CHID::GetInputType() == 1 )
      {
        PlayerPed = FindPlayerPed(-1);
        sub_18B1E4(PlayerPed);
      }
    }
  }
}

//----- (00300510) --------------------------------------------------------
void __fastcall CCheat::ClearVehiclePopulationCheats(CCheat::eCheat thisCheat)
{
  if ( thisCheat != BEACHPARTY_CHEAT && CCheat::m_aCheatsActive[49] )
    CCheat::BeachPartyCheat();
  if ( thisCheat != ALLCARSARESHIT_CHEAT && CCheat::m_aCheatsActive[54] )
    CCheat::m_aCheatsActive[54] = 0;
  if ( thisCheat != ALLCARSAREGREAT_CHEAT && CCheat::m_aCheatsActive[55] )
    CCheat::m_aCheatsActive[55] = 0;
  if ( thisCheat != FUNHOUSE_CHEAT && CCheat::m_aCheatsActive[78] )
    CCheat::FunhouseCheat();
  if ( thisCheat != COUNTRYSIDEINVASION_CHEAT )
  {
    if ( CCheat::m_aCheatsActive[83] )
      sub_191C50();
  }
}

//----- (003005B4) --------------------------------------------------------
void __fastcall CConversationNode::Clear(CConversationNode *this)
{
  this->m_Name[0] = 0;
  *(_DWORD *)&this->m_NodeYes = -1;
  this->m_Speech = 0;
  this->m_SpeechY = 0;
  this->m_SpeechN = 0;
}

//----- (003005C8) --------------------------------------------------------
void __fastcall CConversationNode::ClearRecursively(CConversationNode *this)
{
  int m_NodeYes; // r0
  int m_NodeNo; // r0

  m_NodeYes = this->m_NodeYes;
  if ( m_NodeYes >= 0 )
    CConversationNode::ClearRecursively(&CConversations::m_aNodes[m_NodeYes]);
  m_NodeNo = this->m_NodeNo;
  if ( m_NodeNo > -1 )
    CConversationNode::ClearRecursively(&CConversations::m_aNodes[m_NodeNo]);
  this->m_NodeNo = -1;
  this->m_Name[0] = 0;
  this->m_NodeYes = -1;
  this->m_Speech = 0;
  this->m_SpeechY = 0;
  this->m_SpeechN = 0;
}

//----- (00300620) --------------------------------------------------------
void __fastcall CConversationForPed::Clear(CConversationForPed *this, bool bDontClearNodes)
{
  if ( !bDontClearNodes )
    CConversationNode::ClearRecursively(&CConversations::m_aNodes[this->m_FirstNode]);
  this->m_FirstNode = -1;
  this->m_CurrentNode = -1;
  this->m_pPed = 0;
  this->m_LastChange = 0;
  this->m_LastTimeWeWereCloseEnough = 0;
}

//----- (00300654) --------------------------------------------------------
void CConversations::Clear()
{
  int v0; // r3
  CConversationForPed *v1; // r2
  int v2; // r3
  CConversationNode *v3; // r1

  v0 = 0;
  do
  {
    CConversations::m_aConversations[v0].m_FirstNode = -1;
    v1 = &CConversations::m_aConversations[v0++];
    v1->m_CurrentNode = -1;
    v1->m_pPed = 0;
    v1->m_LastChange = 0;
    v1->m_LastTimeWeWereCloseEnough = 0;
  }
  while ( v0 != 14 );
  v2 = 0;
  do
  {
    CConversations::m_aNodes[v2].m_Name[0] = 0;
    v3 = &CConversations::m_aNodes[v2++];
    v3->m_NodeNo = -1;
    v3->m_NodeYes = -1;
    v3->m_Speech = 0;
    v3->m_SpeechY = 0;
    v3->m_SpeechN = 0;
  }
  while ( v2 != 50 );
  CConversations::m_AwkwardSayStatus = 0;
  CConversations::m_bSettingUpConversation = 0;
}

//----- (003006C4) --------------------------------------------------------
void CConversations::Update()
{
  if ( CConversations::m_AwkwardSayStatus == 2 )
  {
    if ( !CAudioEngine::IsMissionAudioSampleFinished(&AudioEngine, 0) )
      return;
    CConversations::m_AwkwardSayStatus = 0;
    goto LABEL_8;
  }
  if ( CConversations::m_AwkwardSayStatus != 1 )
  {
LABEL_8:
    CConversationForPed::Update(CConversations::m_aConversations);
    CConversationForPed::Update(&CConversations::m_aConversations[1]);
    CConversationForPed::Update(&CConversations::m_aConversations[2]);
    CConversationForPed::Update(&CConversations::m_aConversations[3]);
    CConversationForPed::Update(&CConversations::m_aConversations[4]);
    CConversationForPed::Update(&CConversations::m_aConversations[5]);
    CConversationForPed::Update(&CConversations::m_aConversations[6]);
    CConversationForPed::Update(&CConversations::m_aConversations[7]);
    CConversationForPed::Update(&CConversations::m_aConversations[8]);
    CConversationForPed::Update(&CConversations::m_aConversations[9]);
    CConversationForPed::Update(&CConversations::m_aConversations[10]);
    CConversationForPed::Update(&CConversations::m_aConversations[11]);
    CConversationForPed::Update(&CConversations::m_aConversations[12]);
    CConversationForPed::Update(&CConversations::m_aConversations[13]);
    return;
  }
  if ( CAudioEngine::GetMissionAudioLoadingStatus(&AudioEngine, 0) == 1 )
  {
    CAudioEngine::PlayLoadedMissionAudio(&AudioEngine, 0);
    CConversations::m_AwkwardSayStatus = 2;
  }
}

//----- (003007B0) --------------------------------------------------------
void __fastcall CConversationForPed::Update(CConversationForPed *this)
{
  CPed *m_pPed; // r0
  bool v3; // zf
  UInt32 v4; // r0
  Int32 *p_m_Status; // r6
  CPad *v6; // r0
  CPad *v7; // r0
  Int32 *p_m_CurrentNode; // r6
  CConversationNode *v9; // r5
  GxtChar *v10; // r0
  Int32 m_Speech; // r1
  CPed *v12; // r5
  UInt32 v13; // r0
  Int32 m_CurrentNode; // r0
  CPad *Pad; // r0
  GxtChar *v16; // r0
  Int32 v17; // r0
  Int32 m_SpeechN; // r5
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v20; // r8
  _BOOL4 m_bSuppressSubtitles; // r1
  Int32 m_NodeNo; // r0
  CPad *v23; // r0
  GxtChar *v24; // r0
  Int32 v25; // r0
  Int32 m_SpeechY; // r5
  CPlayerPed *v27; // r0
  CPlayerPed *v28; // r8
  _BOOL4 v29; // r1
  CConversationNode *v30; // r5
  GxtChar *v31; // r0
  Int32 m_Status; // r1

  m_pPed = this->m_pPed;
  v3 = m_pPed == 0;
  if ( m_pPed )
    v3 = !this->m_bEnabled;
  if ( v3 )
  {
    this->m_Status = 0;
    return;
  }
  if ( !CConversationForPed::IsPlayerInPositionForConversation(this, 0) )
  {
    this->m_Status = 0;
    return;
  }
  v4 = CTimer::m_snTimeInMilliseconds;
  if ( CTimer::m_snTimeInMilliseconds > this->m_LastTimeWeWereCloseEnough + 10000 )
    goto LABEL_10;
  p_m_Status = &this->m_Status;
  if ( this->m_Status != 1 )
  {
LABEL_24:
    if ( v4 > this->m_LastChange + 400 )
    {
      if ( (unsigned int)*p_m_Status > 3 || *p_m_Status == 1 )
        goto LABEL_49;
      m_CurrentNode = this->m_CurrentNode;
      if ( CConversations::m_aNodes[m_CurrentNode].m_NodeNo >= 0 )
      {
        Pad = CPad::GetPad(0);
        if ( CPad::ConversationNoJustDown(Pad) )
        {
          if ( !this->m_bSuppressSubtitles )
          {
            CMessages::ClearSmallMessagesOnly();
            strcpy((char *)gString, (const char *)&CConversations::m_aNodes[this->m_CurrentNode]);
            *(_WORD *)&gString[strlen((const char *)gString)] = 78;
            v16 = CText::Get(&TheText, gString);
            CMessages::AddMessageJumpQ(gString, v16, 0xFA0u, 3u, 1);
          }
          v17 = this->m_CurrentNode;
          m_SpeechN = CConversations::m_aNodes[v17].m_SpeechN;
          if ( m_SpeechN >= 1 )
          {
            PlayerPed = FindPlayerPed(-1);
            CPed::Say(PlayerPed, CConversations::m_aNodes[this->m_CurrentNode].m_SpeechN, 0, 1.0, 0, 0, 0);
            v17 = this->m_CurrentNode;
            m_SpeechN = CConversations::m_aNodes[v17].m_SpeechN;
          }
          if ( m_SpeechN <= -1 )
          {
            v20 = FindPlayerPed(-1);
            CAudioEngine::PreloadMissionAudio(&AudioEngine, 0, -m_SpeechN);
            CAudioEngine::AttachMissionAudioToPed(&AudioEngine, 0, v20);
            CConversations::m_AwkwardSayStatus = 1;
            v17 = this->m_CurrentNode;
          }
          m_bSuppressSubtitles = this->m_bSuppressSubtitles;
          m_NodeNo = CConversations::m_aNodes[v17].m_NodeNo;
          this->m_CurrentNode = m_NodeNo;
          this->m_LastChange = CTimer::m_snTimeInMilliseconds;
          if ( m_bSuppressSubtitles )
            goto LABEL_48;
          goto LABEL_47;
        }
        m_CurrentNode = this->m_CurrentNode;
      }
      if ( CConversations::m_aNodes[m_CurrentNode].m_NodeYes > -1 )
      {
        v23 = CPad::GetPad(0);
        if ( CPad::ConversationYesJustDown(v23) )
        {
          if ( !this->m_bSuppressSubtitles )
          {
            CMessages::ClearSmallMessagesOnly();
            strcpy((char *)gString, (const char *)&CConversations::m_aNodes[this->m_CurrentNode]);
            *(_WORD *)&gString[strlen((const char *)gString)] = 89;
            v24 = CText::Get(&TheText, gString);
            CMessages::AddMessageJumpQ(gString, v24, 0xFA0u, 3u, 1);
          }
          v25 = this->m_CurrentNode;
          m_SpeechY = CConversations::m_aNodes[v25].m_SpeechY;
          if ( m_SpeechY >= 1 )
          {
            v27 = FindPlayerPed(-1);
            CPed::Say(v27, CConversations::m_aNodes[this->m_CurrentNode].m_SpeechY, 0, 1.0, 0, 0, 0);
            v25 = this->m_CurrentNode;
            m_SpeechY = CConversations::m_aNodes[v25].m_SpeechY;
          }
          if ( m_SpeechY <= -1 )
          {
            v28 = FindPlayerPed(-1);
            CAudioEngine::PreloadMissionAudio(&AudioEngine, 0, -m_SpeechY);
            CAudioEngine::AttachMissionAudioToPed(&AudioEngine, 0, v28);
            CConversations::m_AwkwardSayStatus = 1;
            v25 = this->m_CurrentNode;
          }
          v29 = this->m_bSuppressSubtitles;
          m_NodeNo = CConversations::m_aNodes[v25].m_NodeYes;
          this->m_CurrentNode = m_NodeNo;
          this->m_LastChange = CTimer::m_snTimeInMilliseconds;
          if ( v29 )
            goto LABEL_48;
LABEL_47:
          v30 = &CConversations::m_aNodes[m_NodeNo];
          v31 = CText::Get(&TheText, v30->m_Name);
          CMessages::AddMessage(v30->m_Name, v31, 0xFA0u, 1u, 1);
LABEL_48:
          *p_m_Status = 1;
LABEL_49:
          this->m_LastTimeWeWereCloseEnough = CTimer::m_snTimeInMilliseconds;
          return;
        }
      }
    }
    m_Status = this->m_Status;
    v13 = CTimer::m_snTimeInMilliseconds;
    this->m_LastTimeWeWereCloseEnough = CTimer::m_snTimeInMilliseconds;
    if ( m_Status != 2 )
      return;
    goto LABEL_20;
  }
  if ( CTimer::m_snTimeInMilliseconds <= this->m_LastChange + 4000 )
  {
    v6 = CPad::GetPad(0);
    if ( !CPad::ConversationNoJustDown(v6) )
    {
      v7 = CPad::GetPad(0);
      if ( !CPad::ConversationYesJustDown(v7) )
      {
        v4 = CTimer::m_snTimeInMilliseconds;
        goto LABEL_24;
      }
    }
  }
LABEL_10:
  if ( this->m_bSuppressSubtitles )
  {
    p_m_CurrentNode = &this->m_CurrentNode;
  }
  else
  {
    CMessages::ClearSmallMessagesOnly();
    p_m_CurrentNode = &this->m_CurrentNode;
    v9 = &CConversations::m_aNodes[this->m_CurrentNode];
    v10 = CText::Get(&TheText, v9->m_Name);
    CMessages::AddMessageJumpQ(v9->m_Name, v10, 0xFA0u, 1u, 1);
  }
  m_Speech = CConversations::m_aNodes[*p_m_CurrentNode].m_Speech;
  if ( m_Speech >= 1 )
  {
    CPed::Say(this->m_pPed, m_Speech, 0, 1.0, 0, 0, 0);
    m_Speech = CConversations::m_aNodes[this->m_CurrentNode].m_Speech;
  }
  if ( m_Speech <= -1 )
  {
    v12 = this->m_pPed;
    CAudioEngine::PreloadMissionAudio(&AudioEngine, 0, -m_Speech);
    CAudioEngine::AttachMissionAudioToPed(&AudioEngine, 0, v12);
    CConversations::m_AwkwardSayStatus = 1;
  }
  this->m_Status = 2;
  p_m_Status = &this->m_Status;
  v13 = CTimer::m_snTimeInMilliseconds;
  this->m_LastChange = CTimer::m_snTimeInMilliseconds;
  this->m_LastTimeWeWereCloseEnough = v13;
LABEL_20:
  if ( v13 > this->m_LastChange + 4000 )
    *p_m_Status = 3;
}

//----- (00300C50) --------------------------------------------------------
bool __fastcall CConversationForPed::IsPlayerInPositionForConversation(
        CConversationForPed *this,
        bool bRandomConversation)
{
  _BOOL4 v3; // r4
  CPed *m_pPed; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float32x2_t v7; // d16
  unsigned __int64 v8; // d1
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v10; // r0
  CPlayerPed *pLastDamageEntity; // r6
  CPlayerPed *v12; // r0
  CPlayerPed *v13; // r0
  bool result; // r0
  CVector v15; // [sp+4h] [bp-1Ch] BYREF

  v3 = bRandomConversation;
  FindPlayerCoors(&v15, -1);
  m_pPed = this->m_pPed;
  m_pMat = m_pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pPed->m_transform;
  v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&v15.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  result = sqrtf(
             (float)((float)((float)(v15.x - p_tx->m_translate.x) * (float)(v15.x - p_tx->m_translate.x)) + *(float *)&v8)
           + *((float *)&v8 + 1)) <= 4.0
        && (PlayerPed = FindPlayerPed(-1),
            (float)((float)((float)(PlayerPed->m_pMat->xy * this->m_pPed->m_pMat->xy)
                          + (float)(PlayerPed->m_pMat->yy * this->m_pPed->m_pMat->yy))
                  + (float)(PlayerPed->m_pMat->zy * this->m_pPed->m_pMat->zy)) <= 0.0)
        && (v10 = FindPlayerPed(-1),
            sqrtf(
              (float)(v10->m_vecMoveSpeed.x * v10->m_vecMoveSpeed.x)
            + (float)(v10->m_vecMoveSpeed.y * v10->m_vecMoveSpeed.y)) <= 0.01)
        && ((pLastDamageEntity = (CPlayerPed *)this->m_pPed->pLastDamageEntity, pLastDamageEntity != FindPlayerPed(-1))
         || CTimer::m_snTimeInMilliseconds >= this->m_pPed->LastDamagedTime + 6000)
        && (!v3
         || (v12 = FindPlayerPed(-1),
             CPedGroupMembership::CountMembersExcludingLeader(&CPedGroups::ms_groups[v12->m_pPlayerData->m_PlayerGroup].m_membership) <= 0))
        && (v13 = FindPlayerPed(-1), CPed::PedIsReadyForConversation(v13, v3))
        && CPed::PedIsReadyForConversation(this->m_pPed, v3);
  return result;
}

//----- (00300DA8) --------------------------------------------------------
void __fastcall CConversations::AwkwardSay(Int32 WhatToSay, CPed *pSpeakingPed)
{
  CAudioEngine::PreloadMissionAudio(&AudioEngine, 0, WhatToSay);
  CAudioEngine::AttachMissionAudioToPed(&AudioEngine, 0, pSpeakingPed);
  CConversations::m_AwkwardSayStatus = 1;
}

//----- (00300DDC) --------------------------------------------------------
bool __fastcall CPed::PedIsReadyForConversation(CPed *this, bool bRandomConversation)
{
  _BOOL4 v3; // r5

  v3 = bRandomConversation;
  return !(*((unsigned __int8 *)&this->m_nPedFlags + 1) << 31)
      && !CPedIntelligence::GetTaskFighting(this->m_pPedIntelligence)
      && (!v3 || FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN)
      && (unsigned int)(this->m_eMoveState - 5) >= 3
      && (this->CharCreatedBy == 2
       || !CPedIntelligence::FindTaskByType(this->m_pPedIntelligence, 1204)
       && !CEventGroup::GetEventOfType(&this->m_pPedIntelligence->m_eventGroup, 19));
}

//----- (00300E4C) --------------------------------------------------------
void __fastcall CConversations::StartSettingUpConversation(CPed *pPed)
{
  CConversations::m_pSettingUpConversationPed = pPed;
  CEntity::RegisterReference(pPed, &CConversations::m_pSettingUpConversationPed);
  CConversations::m_bSettingUpConversation = 1;
  CConversations::m_SettingUpConversationNumNodes = 0;
}

//----- (00300E80) --------------------------------------------------------
void __fastcall CConversations::DoneSettingUpConversation(bool bSuppressSubtitles)
{
  int v1; // r10
  int v2; // r2
  CTempConversationNode *v3; // r4
  CTempConversationNode *v4; // r11
  int v5; // r8
  Int16 *p_m_NodeNo; // r11
  bool v7; // zf
  const char *v8; // r1
  CConversationForPed *v9; // r0
  int v10; // r0
  int i; // r0
  unsigned __int8 *v12; // r4
  int v13; // r5
  CTempConversationNode *v15; // r2
  Int32 v16; // r6
  Int32 *p_m_FinalSlot; // r5
  int v18; // r0
  Int32 m_FinalSlot; // r1
  CConversationNode *v20; // r0
  int v21; // r2
  Int32 v22; // r1
  Int32 v23; // r2
  CPed *v24; // r0
  uint32 v25; // r0
  char *v27; // [sp+4h] [bp-24h]
  int v28; // [sp+8h] [bp-20h]

  v1 = CConversations::m_SettingUpConversationNumNodes;
  if ( CConversations::m_SettingUpConversationNumNodes >= 1 )
  {
    v2 = 0;
    do
    {
      v3 = CConversations::m_aTempNodes;
      v4 = &CConversations::m_aTempNodes[v2];
      v5 = 0;
      v28 = v2;
      v4->m_NodeNo = -1;
      p_m_NodeNo = &v4->m_NodeNo;
      *(p_m_NodeNo - 1) = -1;
      do
      {
        v7 = strcmp((const char *)p_m_NodeNo - 22, (const char *)v3) == 0;
        v8 = (const char *)v3;
        if ( v7 )
          *(p_m_NodeNo - 1) = v5;
        ++v3;
        if ( !strcmp((const char *)p_m_NodeNo - 14, v8) )
          *p_m_NodeNo = v5;
        ++v5;
      }
      while ( v5 < v1 );
      v2 = v28 + 1;
    }
    while ( v28 + 1 < v1 );
  }
  if ( CConversations::m_aConversations[0].m_pPed )
  {
    if ( CConversations::m_aConversations[1].m_pPed )
    {
      if ( CConversations::m_aConversations[2].m_pPed )
      {
        if ( CConversations::m_aConversations[3].m_pPed )
        {
          if ( CConversations::m_aConversations[4].m_pPed )
          {
            if ( CConversations::m_aConversations[5].m_pPed )
            {
              if ( CConversations::m_aConversations[6].m_pPed )
              {
                if ( CConversations::m_aConversations[7].m_pPed )
                {
                  if ( CConversations::m_aConversations[8].m_pPed )
                  {
                    if ( CConversations::m_aConversations[9].m_pPed )
                    {
                      if ( CConversations::m_aConversations[10].m_pPed )
                      {
                        if ( CConversations::m_aConversations[11].m_pPed )
                        {
                          if ( CConversations::m_aConversations[12].m_pPed )
                          {
                            if ( CConversations::m_aConversations[13].m_pPed )
                            {
                              v9 = 0;
                              goto LABEL_40;
                            }
                            v10 = 13;
                          }
                          else
                          {
                            v10 = 12;
                          }
                        }
                        else
                        {
                          v10 = 11;
                        }
                      }
                      else
                      {
                        v10 = 10;
                      }
                    }
                    else
                    {
                      v10 = 9;
                    }
                  }
                  else
                  {
                    v10 = 8;
                  }
                }
                else
                {
                  v10 = 7;
                }
              }
              else
              {
                v10 = 6;
              }
            }
            else
            {
              v10 = 5;
            }
          }
          else
          {
            v10 = 4;
          }
        }
        else
        {
          v10 = 3;
        }
      }
      else
      {
        v10 = 2;
      }
    }
    else
    {
      v10 = 1;
    }
  }
  else
  {
    v10 = 0;
  }
  v9 = &CConversations::m_aConversations[v10];
LABEL_40:
  v27 = (char *)v9;
  if ( v1 >= 1 )
  {
    for ( i = 0; i < v1; ++i )
    {
      v12 = &CConversations::m_aNodes[0].m_Name[1];
      v13 = 0;
      while ( *(v12 - 1) )
      {
        v12 += 24;
        if ( v13++ >= 49 )
        {
          v13 = 0;
          goto LABEL_47;
        }
      }
      *(_WORD *)(v12 - 1) = 88;
LABEL_47:
      v15 = &CConversations::m_aTempNodes[i];
      v15->m_FinalSlot = v13;
    }
    v16 = 0;
    p_m_FinalSlot = &CConversations::m_aTempNodes[0].m_FinalSlot;
    do
    {
      strcpy((char *)&CConversations::m_aNodes[*p_m_FinalSlot], (const char *)p_m_FinalSlot - 24);
      v18 = *((__int16 *)p_m_FinalSlot + 2);
      LOWORD(m_FinalSlot) = -1;
      ++v16;
      if ( v18 > -1 )
        m_FinalSlot = CConversations::m_aTempNodes[(__int16)v18].m_FinalSlot;
      v20 = &CConversations::m_aNodes[*p_m_FinalSlot];
      v20->m_NodeYes = m_FinalSlot;
      LOWORD(m_FinalSlot) = -1;
      v21 = *((__int16 *)p_m_FinalSlot + 3);
      if ( v21 > -1 )
        m_FinalSlot = CConversations::m_aTempNodes[(__int16)v21].m_FinalSlot;
      v20->m_NodeNo = m_FinalSlot;
      v20->m_Speech = p_m_FinalSlot[2];
      v20->m_SpeechY = p_m_FinalSlot[3];
      v22 = p_m_FinalSlot[4];
      p_m_FinalSlot += 11;
      v20->m_SpeechN = v22;
    }
    while ( v16 < CConversations::m_SettingUpConversationNumNodes );
  }
  v23 = CConversations::m_aTempNodes[0].m_FinalSlot;
  v24 = CConversations::m_pSettingUpConversationPed;
  *(_DWORD *)v27 = CConversations::m_aTempNodes[0].m_FinalSlot;
  *((_DWORD *)v27 + 1) = v23;
  *((_DWORD *)v27 + 2) = v24;
  CEntity::RegisterReference(v24, (CEntity **)v27 + 2);
  v25 = CTimer::m_snTimeInMilliseconds;
  v27[24] = 1;
  v27[25] = bSuppressSubtitles;
  *((_DWORD *)v27 + 3) = v25;
  *((_DWORD *)v27 + 4) = 0;
  *((_DWORD *)v27 + 5) = 0;
  CConversations::m_bSettingUpConversation = 0;
  CConversations::m_SettingUpConversationNumNodes = 0;
}
// 30103A: conditional instruction was optimized away because r10.4>=1

//----- (003011B0) --------------------------------------------------------
CConversationForPed *CConversations::FindFreeConversationSlot()
{
  int v1; // r0

  if ( CConversations::m_aConversations[0].m_pPed )
  {
    if ( CConversations::m_aConversations[1].m_pPed )
    {
      if ( CConversations::m_aConversations[2].m_pPed )
      {
        if ( CConversations::m_aConversations[3].m_pPed )
        {
          if ( CConversations::m_aConversations[4].m_pPed )
          {
            if ( CConversations::m_aConversations[5].m_pPed )
            {
              if ( CConversations::m_aConversations[6].m_pPed )
              {
                if ( CConversations::m_aConversations[7].m_pPed )
                {
                  if ( CConversations::m_aConversations[8].m_pPed )
                  {
                    if ( CConversations::m_aConversations[9].m_pPed )
                    {
                      if ( CConversations::m_aConversations[10].m_pPed )
                      {
                        if ( CConversations::m_aConversations[11].m_pPed )
                        {
                          if ( CConversations::m_aConversations[12].m_pPed )
                          {
                            if ( CConversations::m_aConversations[13].m_pPed )
                              return 0;
                            v1 = 13;
                          }
                          else
                          {
                            v1 = 12;
                          }
                        }
                        else
                        {
                          v1 = 11;
                        }
                      }
                      else
                      {
                        v1 = 10;
                      }
                    }
                    else
                    {
                      v1 = 9;
                    }
                  }
                  else
                  {
                    v1 = 8;
                  }
                }
                else
                {
                  v1 = 7;
                }
              }
              else
              {
                v1 = 6;
              }
            }
            else
            {
              v1 = 5;
            }
          }
          else
          {
            v1 = 4;
          }
        }
        else
        {
          v1 = 3;
        }
      }
      else
      {
        v1 = 2;
      }
    }
    else
    {
      v1 = 1;
    }
  }
  else
  {
    v1 = 0;
  }
  return &CConversations::m_aConversations[v1];
}

//----- (003012E0) --------------------------------------------------------
Int32 CConversations::FindFreeNodeSlot()
{
  unsigned __int8 *v0; // r1
  Int32 result; // r0
  bool v2; // cc

  v0 = &CConversations::m_aNodes[0].m_Name[1];
  result = 0;
  while ( *(v0 - 1) )
  {
    v2 = result < 49;
    v0 += 24;
    ++result;
    if ( !v2 )
      return 0;
  }
  *(_WORD *)(v0 - 1) = 88;
  return result;
}

//----- (00301310) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CConversations::SetUpConversationNode(
        unsigned __int8 *pName,
        unsigned __int8 *pLinkYes,
        unsigned __int8 *pLinkNo,
        Int32 Speech,
        Int32 SpeechY,
        Int32 SpeechN)
{
  CTempConversationNode *v9; // r0
  char *m_NameNodeYes; // r0
  Int32 v11; // r1
  unsigned __int8 *m_NameNodeNo; // r0

  strncpy(
    (char *)&CConversations::m_aTempNodes[CConversations::m_SettingUpConversationNumNodes],
    (const char *)pName,
    6u);
  MakeUpperCase(CConversations::m_aTempNodes[CConversations::m_SettingUpConversationNumNodes].m_Name);
  v9 = &CConversations::m_aTempNodes[CConversations::m_SettingUpConversationNumNodes];
  v9->m_Speech = Speech;
  *(_QWORD *)&v9->m_SpeechY = *(_QWORD *)&SpeechY;
  m_NameNodeYes = (char *)v9->m_NameNodeYes;
  if ( pLinkYes )
  {
    strncpy(m_NameNodeYes, (const char *)pLinkYes, 6u);
  }
  else
  {
    *m_NameNodeYes = 0;
    MakeUpperCase((unsigned __int8 *)m_NameNodeYes);
  }
  v11 = CConversations::m_SettingUpConversationNumNodes;
  m_NameNodeNo = CConversations::m_aTempNodes[CConversations::m_SettingUpConversationNumNodes].m_NameNodeNo;
  if ( pLinkNo )
  {
    strncpy((char *)m_NameNodeNo, (const char *)pLinkNo, 6u);
    MakeUpperCase(CConversations::m_aTempNodes[CConversations::m_SettingUpConversationNumNodes].m_NameNodeNo);
    v11 = CConversations::m_SettingUpConversationNumNodes;
  }
  else
  {
    *m_NameNodeNo = 0;
  }
  CConversations::m_SettingUpConversationNumNodes = v11 + 1;
}
// 301310: variables would overlap: ^20.4 and ^20.8

//----- (003013E4) --------------------------------------------------------
bool __fastcall CConversations::IsConversationAtNode(unsigned __int8 *pName, CPed *pPed)
{
  CConversationForPed *v3; // r6
  int v4; // r0
  bool v5; // r5

  if ( CConversations::m_aConversations[0].m_pPed == pPed )
  {
    v4 = 0;
  }
  else if ( CConversations::m_aConversations[1].m_pPed == pPed )
  {
    v4 = 1;
  }
  else if ( CConversations::m_aConversations[2].m_pPed == pPed )
  {
    v4 = 2;
  }
  else if ( CConversations::m_aConversations[3].m_pPed == pPed )
  {
    v4 = 3;
  }
  else if ( CConversations::m_aConversations[4].m_pPed == pPed )
  {
    v4 = 4;
  }
  else if ( CConversations::m_aConversations[5].m_pPed == pPed )
  {
    v4 = 5;
  }
  else if ( CConversations::m_aConversations[6].m_pPed == pPed )
  {
    v4 = 6;
  }
  else if ( CConversations::m_aConversations[7].m_pPed == pPed )
  {
    v4 = 7;
  }
  else if ( CConversations::m_aConversations[8].m_pPed == pPed )
  {
    v4 = 8;
  }
  else if ( CConversations::m_aConversations[9].m_pPed == pPed )
  {
    v4 = 9;
  }
  else if ( CConversations::m_aConversations[10].m_pPed == pPed )
  {
    v4 = 10;
  }
  else if ( CConversations::m_aConversations[11].m_pPed == pPed )
  {
    v4 = 11;
  }
  else if ( CConversations::m_aConversations[12].m_pPed == pPed )
  {
    v4 = 12;
  }
  else
  {
    if ( CConversations::m_aConversations[13].m_pPed != pPed )
    {
      v3 = 0;
      goto LABEL_31;
    }
    v4 = 13;
  }
  v3 = &CConversations::m_aConversations[v4];
LABEL_31:
  if ( v3->m_CurrentNode < 0 )
    return 0;
  v5 = 0;
  if ( v3->m_Status != 1 )
  {
    MakeUpperCase(pName);
    if ( !strcmp((const char *)pName, (const char *)&CConversations::m_aNodes[v3->m_CurrentNode]) )
      return 1;
  }
  return v5;
}

//----- (0030156C) --------------------------------------------------------
CConversationForPed *__fastcall CConversations::FindConversationForPed(CPed *pPed)
{
  int v2; // r0

  if ( CConversations::m_aConversations[0].m_pPed == pPed )
  {
    v2 = 0;
  }
  else if ( CConversations::m_aConversations[1].m_pPed == pPed )
  {
    v2 = 1;
  }
  else if ( CConversations::m_aConversations[2].m_pPed == pPed )
  {
    v2 = 2;
  }
  else if ( CConversations::m_aConversations[3].m_pPed == pPed )
  {
    v2 = 3;
  }
  else if ( CConversations::m_aConversations[4].m_pPed == pPed )
  {
    v2 = 4;
  }
  else if ( CConversations::m_aConversations[5].m_pPed == pPed )
  {
    v2 = 5;
  }
  else if ( CConversations::m_aConversations[6].m_pPed == pPed )
  {
    v2 = 6;
  }
  else if ( CConversations::m_aConversations[7].m_pPed == pPed )
  {
    v2 = 7;
  }
  else if ( CConversations::m_aConversations[8].m_pPed == pPed )
  {
    v2 = 8;
  }
  else if ( CConversations::m_aConversations[9].m_pPed == pPed )
  {
    v2 = 9;
  }
  else if ( CConversations::m_aConversations[10].m_pPed == pPed )
  {
    v2 = 10;
  }
  else if ( CConversations::m_aConversations[11].m_pPed == pPed )
  {
    v2 = 11;
  }
  else if ( CConversations::m_aConversations[12].m_pPed == pPed )
  {
    v2 = 12;
  }
  else
  {
    if ( CConversations::m_aConversations[13].m_pPed != pPed )
      return 0;
    v2 = 13;
  }
  return &CConversations::m_aConversations[v2];
}

//----- (003016AC) --------------------------------------------------------
void __fastcall CConversations::RemoveConversationForPed(CPed *pPed)
{
  int i; // r4
  CConversationForPed *v3; // r0

  for ( i = 0; i != 14; ++i )
  {
    if ( CConversations::m_aConversations[i].m_pPed == pPed )
    {
      CConversationNode::ClearRecursively(&CConversations::m_aNodes[CConversations::m_aConversations[i].m_FirstNode]);
      v3 = &CConversations::m_aConversations[i];
      CConversations::m_aConversations[i].m_FirstNode = -1;
      v3->m_CurrentNode = -1;
      CConversations::m_aConversations[i].m_pPed = 0;
      v3->m_LastChange = 0;
      v3->m_LastTimeWeWereCloseEnough = 0;
    }
  }
}

//----- (0030171C) --------------------------------------------------------
bool __fastcall CConversations::IsPlayerInPositionForConversation(CPed *pPed, bool bRandomConversation)
{
  CConversationForPed *v2; // r0
  int v3; // r0

  if ( CConversations::m_aConversations[0].m_pPed == pPed )
  {
    v3 = 0;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[1].m_pPed == pPed )
  {
    v3 = 1;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[2].m_pPed == pPed )
  {
    v3 = 2;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[3].m_pPed == pPed )
  {
    v3 = 3;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[4].m_pPed == pPed )
  {
    v3 = 4;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[5].m_pPed == pPed )
  {
    v3 = 5;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[6].m_pPed == pPed )
  {
    v3 = 6;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[7].m_pPed == pPed )
  {
    v3 = 7;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[8].m_pPed == pPed )
  {
    v3 = 8;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[9].m_pPed == pPed )
  {
    v3 = 9;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[10].m_pPed == pPed )
  {
    v3 = 10;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[11].m_pPed == pPed )
  {
    v3 = 11;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[12].m_pPed == pPed )
  {
    v3 = 12;
    goto LABEL_31;
  }
  if ( CConversations::m_aConversations[13].m_pPed == pPed )
  {
    v3 = 13;
LABEL_31:
    v2 = &CConversations::m_aConversations[v3];
    return CConversationForPed::IsPlayerInPositionForConversation(v2, bRandomConversation);
  }
  v2 = 0;
  return CConversationForPed::IsPlayerInPositionForConversation(v2, bRandomConversation);
}

//----- (00301860) --------------------------------------------------------
void __fastcall CConversations::EnableConversation(CPed *pPed, bool bEnable)
{
  int v2; // r2

  if ( CConversations::m_aConversations[0].m_pPed == pPed )
  {
    v2 = 0;
  }
  else if ( CConversations::m_aConversations[1].m_pPed == pPed )
  {
    v2 = 1;
  }
  else if ( CConversations::m_aConversations[2].m_pPed == pPed )
  {
    v2 = 2;
  }
  else if ( CConversations::m_aConversations[3].m_pPed == pPed )
  {
    v2 = 3;
  }
  else if ( CConversations::m_aConversations[4].m_pPed == pPed )
  {
    v2 = 4;
  }
  else if ( CConversations::m_aConversations[5].m_pPed == pPed )
  {
    v2 = 5;
  }
  else if ( CConversations::m_aConversations[6].m_pPed == pPed )
  {
    v2 = 6;
  }
  else if ( CConversations::m_aConversations[7].m_pPed == pPed )
  {
    v2 = 7;
  }
  else if ( CConversations::m_aConversations[8].m_pPed == pPed )
  {
    v2 = 8;
  }
  else if ( CConversations::m_aConversations[9].m_pPed == pPed )
  {
    v2 = 9;
  }
  else if ( CConversations::m_aConversations[10].m_pPed == pPed )
  {
    v2 = 10;
  }
  else if ( CConversations::m_aConversations[11].m_pPed == pPed )
  {
    v2 = 11;
  }
  else
  {
    v2 = 13;
    if ( CConversations::m_aConversations[12].m_pPed == pPed )
      v2 = 12;
  }
  CConversations::m_aConversations[v2].m_bEnabled = bEnable;
}

//----- (0030198C) --------------------------------------------------------
Int32 __fastcall CConversations::GetConversationStatus(CPed *pPed)
{
  int v1; // r1

  if ( CConversations::m_aConversations[0].m_pPed == pPed )
  {
    v1 = 0;
  }
  else if ( CConversations::m_aConversations[1].m_pPed == pPed )
  {
    v1 = 1;
  }
  else if ( CConversations::m_aConversations[2].m_pPed == pPed )
  {
    v1 = 2;
  }
  else if ( CConversations::m_aConversations[3].m_pPed == pPed )
  {
    v1 = 3;
  }
  else if ( CConversations::m_aConversations[4].m_pPed == pPed )
  {
    v1 = 4;
  }
  else if ( CConversations::m_aConversations[5].m_pPed == pPed )
  {
    v1 = 5;
  }
  else if ( CConversations::m_aConversations[6].m_pPed == pPed )
  {
    v1 = 6;
  }
  else if ( CConversations::m_aConversations[7].m_pPed == pPed )
  {
    v1 = 7;
  }
  else if ( CConversations::m_aConversations[8].m_pPed == pPed )
  {
    v1 = 8;
  }
  else if ( CConversations::m_aConversations[9].m_pPed == pPed )
  {
    v1 = 9;
  }
  else if ( CConversations::m_aConversations[10].m_pPed == pPed )
  {
    v1 = 10;
  }
  else if ( CConversations::m_aConversations[11].m_pPed == pPed )
  {
    v1 = 11;
  }
  else
  {
    v1 = 13;
    if ( CConversations::m_aConversations[12].m_pPed == pPed )
      v1 = 12;
  }
  return CConversations::m_aConversations[v1].m_Status;
}

//----- (00301AB8) --------------------------------------------------------
bool CConversations::IsConversationGoingOn()
{
  return (CConversations::m_aConversations[7].m_Status | CConversations::m_aConversations[0].m_Status | CConversations::m_aConversations[1].m_Status | CConversations::m_aConversations[2].m_Status | CConversations::m_aConversations[3].m_Status | CConversations::m_aConversations[4].m_Status | CConversations::m_aConversations[5].m_Status | CConversations::m_aConversations[6].m_Status | CConversations::m_aConversations[8].m_Status | CConversations::m_aConversations[9].m_Status | CConversations::m_aConversations[10].m_Status | CConversations::m_aConversations[11].m_Status | CConversations::m_aConversations[12].m_Status | CConversations::m_aConversations[13].m_Status) != 0;
}

//----- (00301B24) --------------------------------------------------------
void CPedToPlayerConversations::Clear()
{
  if ( CPedToPlayerConversations::m_State )
  {
    CAEPedSpeechAudioEntity::ReleasePlayerConversation();
    CPedToPlayerConversations::m_State = 0;
  }
  CPedToPlayerConversations::m_TimeOfLastPlayerConversation = 0;
  CPedToPlayerConversations::m_pPed = 0;
}

//----- (00301B68) --------------------------------------------------------
void CPedToPlayerConversations::Update()
{
  CPlayerPed *PlayerPed; // r4
  int v1; // r8
  CPedPool *v2; // r6
  int v3; // r0
  int v4; // r10
  _BOOL4 IsReadyForConversation; // r0
  bool v6; // zf
  float *v7; // r9
  float v8; // s0
  float v9; // s2
  float v10; // s4
  float v11; // r11
  float v12; // r5
  float *p_xx; // r0
  float *v14; // r11
  float *p_x; // r1
  float v16; // s25
  float v17; // s29
  float v18; // s27
  float v19; // s31
  float v20; // s24
  float v21; // s22
  float v22; // s0
  float v23; // s2
  float v24; // s4
  float32x2_t v25; // d16
  unsigned __int64 v26; // d1
  unsigned int v27; // r0
  unsigned __int16 v28; // r0
  int v29; // r1
  CMatrix *m_pMat; // r2
  float32x2_t *v31; // r3
  CSimpleTransform *p_tx; // r1
  float32x2_t v33; // d16
  unsigned __int64 v34; // d0
  unsigned int v35; // r1
  int v36; // r1
  int v37; // r0
  float v38; // s0
  CPlayerPed *v39; // r0
  int v40; // s22
  float StatValue; // r11
  float v42; // s22
  float v43; // s0
  int v44; // r0
  int v45; // r1
  int v46; // r0
  int v47; // r0
  CPlayerPed *v48; // r0
  int v49; // r0
  CPad *Pad; // r0
  CPad *v51; // r0
  int32 m_nPedType; // r0
  bool v53; // zf
  int32 v54; // r0
  bool v55; // zf
  int32 v56; // r0
  bool v57; // zf
  CTaskComplexSequence *v58; // r5
  CTaskSimpleStandStill *v59; // r6
  CTaskComplexKillPedOnFoot *v60; // r6
  UInt32 v61; // r3
  CTaskComplexSequence *v62; // r5
  CTaskSimpleStandStill *v63; // r6
  CTaskComplexKillPedOnFoot *v64; // r6
  UInt16 v65; // r1
  float x; // [sp+20h] [bp-A0h]
  float v67; // [sp+24h] [bp-9Ch]
  float32x2_t **v68; // [sp+2Ch] [bp-94h]
  CEventScriptCommand v69[5]; // [sp+48h] [bp-78h] BYREF

  PlayerPed = FindPlayerPed(-1);
  if ( FindPlayerVehicle(-1, 0) )
  {
    CPedToPlayerConversations::Update(void)::pLastVehicle = FindPlayerVehicle(-1, 0);
    CEntity::RegisterReference(
      CPedToPlayerConversations::Update(void)::pLastVehicle,
      &CPedToPlayerConversations::Update(void)::pLastVehicle);
  }
  switch ( CPedToPlayerConversations::m_State )
  {
    case 0u:
      if ( CTimer::m_snTimeInMilliseconds <= CPedToPlayerConversations::m_TimeOfLastPlayerConversation + 30000
        || FindPlayerVehicle(-1, 0)
        || FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel
        || CConversations::m_aConversations[7].m_Status | CConversations::m_aConversations[0].m_Status | CConversations::m_aConversations[1].m_Status | CConversations::m_aConversations[2].m_Status | CConversations::m_aConversations[3].m_Status | CConversations::m_aConversations[4].m_Status | CConversations::m_aConversations[5].m_Status | CConversations::m_aConversations[6].m_Status | CConversations::m_aConversations[8].m_Status | CConversations::m_aConversations[9].m_Status | CConversations::m_aConversations[10].m_Status | CConversations::m_aConversations[11].m_Status | CConversations::m_aConversations[12].m_Status | CConversations::m_aConversations[13].m_Status
        || !CPed::PedIsReadyForConversation(PlayerPed, 1)
        || CGangWars::bGangWarsActive )
      {
        return;
      }
      v1 = -1;
      v2 = CPools::ms_pPedPool;
      while ( 2 )
      {
        v3 = CPedToPlayerConversations::Update(void)::RandomPed + 1;
        if ( CPedToPlayerConversations::Update(void)::RandomPed + 1 >= v2->m_nSize )
          v3 = 0;
        CPedToPlayerConversations::Update(void)::RandomPed = v3;
        if ( (v2->m_aFlags[v3] & 0x80u) != 0 )
          goto LABEL_106;
        v4 = (int)v2->m_aStorage[v3];
        if ( !v4 || *(_BYTE *)(v4 + 1096) != 1 )
          goto LABEL_106;
        IsReadyForConversation = CPed::PedIsReadyForConversation((CPed *)v4, 1);
        v6 = IsReadyForConversation;
        if ( IsReadyForConversation )
          v6 = *(unsigned __int8 *)(v4 + 1166) >> 7 == 0;
        if ( !v6 || !CEntity::GetIsOnScreen((CEntity *)v4) )
          goto LABEL_106;
        v7 = *(float **)(v4 + 20);
        v68 = (float32x2_t **)(v4 + 20);
        if ( v7 )
        {
          v8 = v7[4];
          v9 = v7[5];
          v10 = v7[6];
        }
        else
        {
          v11 = *(float *)(v4 + 16);
          v12 = sinf(v11);
          v10 = 0.0;
          v9 = cosf(v11);
          LODWORD(v8) = LODWORD(v12) ^ 0x80000000;
        }
        p_xx = &PlayerPed->m_pMat->xx;
        v14 = (float *)(v4 + 4);
        p_x = p_xx + 12;
        if ( !p_xx )
          p_x = &PlayerPed->m_transform.m_translate.x;
        v16 = *p_x;
        v17 = p_x[1];
        v18 = p_x[2];
        if ( v7 )
          v14 = v7 + 12;
        v19 = *v14;
        v20 = v14[1];
        v21 = v14[2];
        if ( (float)((float)((float)(v8 * (float)(v16 - *v14)) + (float)(v9 * (float)(v17 - v20)))
                   + (float)(v10 * (float)(v18 - v21))) <= 0.0 )
          goto LABEL_106;
        if ( p_xx )
        {
          v22 = p_xx[4];
          v23 = p_xx[5];
          v24 = p_xx[6];
        }
        else
        {
          x = PlayerPed->m_transform.m_heading;
          v67 = sinf(x);
          v24 = 0.0;
          v23 = cosf(x);
          LODWORD(v22) = LODWORD(v67) ^ 0x80000000;
        }
        if ( (float)((float)((float)(v22 * (float)(v19 - v16)) + (float)(v23 * (float)(v20 - v17)))
                   + (float)(v24 * (float)(v21 - v18))) <= 0.0 )
          goto LABEL_106;
        FindPlayerCoors((CVector *)v69, -1);
        v25.n64_u64[0] = vsub_f32(*(float32x2_t *)(v14 + 1), *(float32x2_t *)&v69[0].m_iAccumulatedTime).n64_u64[0];
        v26 = vmul_f32(v25, v25).n64_u64[0];
        if ( sqrtf(
               (float)((float)((float)(*v14 - *(float *)&v69[0]._vptr$CEvent)
                             * (float)(*v14 - *(float *)&v69[0]._vptr$CEvent))
                     + *(float *)&v26)
             + *((float *)&v26 + 1)) >= 7.0 )
          goto LABEL_106;
        v27 = *(_DWORD *)(v4 + 1436);
        if ( v27 <= 0x10 && ((1 << v27) & (unsigned int)&elf_hash_chain[16198]) != 0 )
        {
          v28 = rand();
          v29 = (int)(float)((float)((float)v28 * 0.000015259) + (float)((float)v28 * 0.000015259)) + 8;
        }
        else
        {
          v29 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 7.0);
        }
        CPedToPlayerConversations::m_Topic = v29;
        if ( !CAEPedSpeechAudioEntity::WillPedChatAboutTopic((CAEPedSpeechAudioEntity *)(v4 + 664), v29) )
          goto LABEL_106;
        switch ( CPedToPlayerConversations::m_Topic )
        {
          case 0u:
            if ( !CPedToPlayerConversations::Update(void)::pLastVehicle )
              goto LABEL_105;
            m_pMat = CPedToPlayerConversations::Update(void)::pLastVehicle->m_pMat;
            v31 = (float32x2_t *)(v4 + 4);
            if ( *v68 )
              v31 = *v68 + 6;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &CPedToPlayerConversations::Update(void)::pLastVehicle->m_transform;
            v33.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)v31->n64_u64[0]).n64_u64[0];
            v34 = vmul_f32(v33, v33).n64_u64[0];
            if ( sqrtf(*(float *)&v34 + *((float *)&v34 + 1)) >= 20.0 )
              goto LABEL_105;
            v35 = SBYTE1(CModelInfo::ms_modelInfoPtrs[CPedToPlayerConversations::Update(void)::pLastVehicle->m_nModelIndex][1].m_pColModel);
            if ( v35 > 9 )
              goto LABEL_105;
            v36 = 1 << v35;
            if ( (v36 & 0x72) != 0 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x30u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            if ( (v36 & 0x20C) != 0
              && CPedToPlayerConversations::Update(void)::pLastVehicle->m_nHealth > 800.0
              && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 57;
              goto LABEL_174;
            }
            goto LABEL_105;
          case 1u:
            v37 = (int)(float)((float)(CStats::GetStatValue(0x42u) + (float)(*(_WORD *)(v4 + 36) & 0x1FF)) + -256.0);
            if ( v37 > 500 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 58;
              goto LABEL_174;
            }
            if ( v37 <= 149 && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x31u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            goto LABEL_105;
          case 2u:
            v38 = CStats::GetStatValue(0x42u) + (float)(*(_WORD *)(v4 + 36) & 0x1FF);
            v39 = FindPlayerPed(-1);
            v40 = (int)(float)(v38 + -256.0);
            if ( !CPedClothesDesc::HasVisibleNewHairCut(v39->m_pPlayerData->m_pClothes, 0) )
              goto LABEL_105;
            if ( v40 > 500 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 59;
              goto LABEL_174;
            }
            if ( (v40 < 150 || CStats::GetStatValue(0x1Fu) < 5.0)
              && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x32u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            goto LABEL_105;
          case 3u:
            StatValue = CStats::GetStatValue(0x17u);
            v42 = (float)*(unsigned __int8 *)(v4 + 36);
            v43 = (float)(CStats::GetStatValue(0x15u) + v42) + -128.0;
            v44 = (int)(float)((float)(StatValue + v42) + -128.0);
            v45 = (int)v43;
            if ( v44 > 400 && v45 <= 249 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 60;
              goto LABEL_174;
            }
            if ( v45 > 500 && v44 - v45 <= 199 && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x33u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            goto LABEL_105;
          case 4u:
            v46 = (int)(float)((float)(CStats::GetStatValue(0x42u) + (float)(*(_WORD *)(v4 + 36) & 0x3FF)) + -512.0);
            if ( v46 > 700 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 61;
              goto LABEL_174;
            }
            if ( v46 < 300 && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x34u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            goto LABEL_105;
          case 5u:
            v47 = (int)(float)((float)(CStats::GetStatValue(0x19u) + (float)(*(_WORD *)(v4 + 36) & 0x1FF)) + -256.0);
            if ( v47 > 700 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 62;
              goto LABEL_174;
            }
            if ( v47 < 300 && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x35u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            goto LABEL_105;
          case 6u:
            v48 = FindPlayerPed(-1);
            if ( !CPedClothesDesc::HasVisibleTattoo(v48->m_pPlayerData->m_pClothes) )
              goto LABEL_105;
            v49 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0);
            if ( v49 > 700 )
            {
              if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
                goto LABEL_105;
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 63;
              goto LABEL_174;
            }
            if ( v49 < 300 && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 0;
              CPed::Say((CPed *)v4, 0x36u, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
            goto LABEL_105;
          case 7u:
            if ( CWeather::Wind >= 0.1 )
            {
              if ( CWeather::Wind > 0.5 && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
              {
                CPedToPlayerConversations::m_bPositiveOpening = 0;
                CPed::Say((CPed *)v4, 0x37u, 0, 1.0, 1, 0, 0);
LABEL_175:
                CPedToPlayerConversations::m_pPed = (CPed *)v4;
                CPedToPlayerConversations::m_State = 1;
                CEntity::RegisterReference((CEntity *)v4, &CPedToPlayerConversations::m_pPed);
                CPedToPlayerConversations::m_TimeOfLastPlayerConversation = CTimer::m_snTimeInMilliseconds;
                CPedToPlayerConversations::m_StartTime = CTimer::m_snTimeInMilliseconds;
                CPed::DisablePedSpeech((CPed *)v4, 0);
                IKChainManager_c::LookAt(
                  &g_ikChainMan,
                  "Ped2Pl_Conversation",
                  (CPed *)v4,
                  PlayerPed,
                  (int32)&elf_hash_chain[8526],
                  5,
                  0,
                  0,
                  0.25,
                  500,
                  8,
                  0);
                IKChainManager_c::LookAt(
                  &g_ikChainMan,
                  "Ped2Pl_ConversationP",
                  PlayerPed,
                  (CEntity *)v4,
                  (int32)&elf_hash_chain[8526],
                  5,
                  0,
                  0,
                  0.25,
                  500,
                  8,
                  0);
                return;
              }
            }
            else if ( (unsigned __int8)(CClock::ms_nGameClockHours - 7) <= 0xCu
                   && CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
            {
              CPedToPlayerConversations::m_bPositiveOpening = 1;
              v65 = 64;
LABEL_174:
              CPed::Say((CPed *)v4, v65, 0, 1.0, 1, 0, 0);
              goto LABEL_175;
            }
LABEL_105:
            if ( (rand() & 0xFFF) != 3 )
            {
LABEL_106:
              if ( ++v1 >= 7 )
                return;
              continue;
            }
            CPed::Say((CPed *)v4, 0x58u, 0, 1.0, 0, 0, 0);
            break;
          case 8u:
            if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
              goto LABEL_105;
            CPed::Say((CPed *)v4, 0xFBu, 0, 1.0, 1, 0, 0);
            goto LABEL_172;
          case 9u:
            if ( !CAEPedSpeechAudioEntity::RequestPlayerConversation((CPed *)v4) )
              goto LABEL_105;
            CPed::Say((CPed *)v4, 0xFCu, 0, 1.0, 1, 0, 0);
LABEL_172:
            CPedToPlayerConversations::m_bPositiveOpening = 1;
            goto LABEL_175;
          default:
            goto LABEL_105;
        }
        return;
      }
    case 1u:
      if ( CPedToPlayerConversations::m_pPed )
      {
        if ( CTimer::m_snTimeInMilliseconds > CPedToPlayerConversations::m_StartTime + 4000 )
        {
          CPedToPlayerConversations::m_State = 0;
          CAEPedSpeechAudioEntity::ReleasePlayerConversation();
          CPed::EnablePedSpeech(CPedToPlayerConversations::m_pPed);
          if ( IKChainManager_c::IsLooking(&g_ikChainMan, PlayerPed) )
            IKChainManager_c::AbortLookAt(&g_ikChainMan, PlayerPed, 250);
          if ( IKChainManager_c::IsLooking(&g_ikChainMan, CPedToPlayerConversations::m_pPed) )
          {
            IKChainManager_c::AbortLookAt(&g_ikChainMan, CPedToPlayerConversations::m_pPed, 250);
            if ( CPedToPlayerConversations::m_bPositiveOpening )
              CPed::Say(CPedToPlayerConversations::m_pPed, 0x38u, 0, 1.0, 0, 0, 0);
          }
          return;
        }
        Pad = CPad::GetPad(0);
        if ( CPad::ConversationYesJustDown(Pad) )
        {
          if ( CPedToPlayerConversations::m_bPositiveOpening )
          {
            switch ( CPedToPlayerConversations::m_Topic )
            {
              case 0u:
                CPed::Say(PlayerPed, 0x81u, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 1u:
                CPed::Say(PlayerPed, 0x82u, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 2u:
                CPed::Say(PlayerPed, 0x86u, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 3u:
                CPed::Say(PlayerPed, 0x89u, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 4u:
                CPed::Say(PlayerPed, 0x8Au, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 5u:
                CPed::Say(PlayerPed, 0x8Bu, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 6u:
                CPed::Say(PlayerPed, 0x8Cu, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 7u:
                CPed::Say(PlayerPed, 0xEAu, 0, 1.0, 1, 0, 0);
                goto LABEL_162;
              case 8u:
                CPed::Say(PlayerPed, 0xECu, 0, 1.0, 1, 0, 0);
                if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 74 )
                  goto LABEL_168;
                goto LABEL_169;
              case 9u:
                CPed::Say(PlayerPed, 0x6Bu, 0, 1.0, 1, 0, 0);
                if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 74 )
                {
LABEL_168:
                  v62 = (CTaskComplexSequence *)CTask::operator new(0x40u);
                  CTaskComplexSequence::CTaskComplexSequence(v62);
                  v63 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
                  CTaskSimpleStandStill::CTaskSimpleStandStill(v63, 2000, 0, 0, 8.0);
                  CTaskComplexSequence::AddTask(v62, v63);
                  v64 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
                  CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v64, PlayerPed, -1, 0, 0, 0, 0);
                  CTaskComplexSequence::AddTask(v62, v64);
                  CEventScriptCommand::CEventScriptCommand(v69, 3, v62, 0);
                  CEventGroup::Add(&CPedToPlayerConversations::m_pPed->m_pPedIntelligence->m_eventGroup, v69, 0);
                  CEventScriptCommand::~CEventScriptCommand(v69);
                }
LABEL_169:
                CPedToPlayerConversations::EndConversation();
                break;
              default:
                goto LABEL_162;
            }
            return;
          }
          m_nPedType = CPedToPlayerConversations::m_pPed->m_nPedType;
          v53 = m_nPedType == 22;
          if ( m_nPedType != 22 )
            v53 = m_nPedType == 5;
          if ( v53 )
            CPed::Say(PlayerPed, 0x83u, 0, 1.0, 1, 0, 0);
          else
            CPed::Say(PlayerPed, 0x84u, 0, 1.0, 1, 0, 0);
        }
        else
        {
          v51 = CPad::GetPad(0);
          if ( !CPad::ConversationNoJustDown(v51) )
            return;
          if ( CPedToPlayerConversations::m_bPositiveOpening )
          {
            if ( CPedToPlayerConversations::m_Topic == 9 )
            {
              CPed::Say(PlayerPed, 0x6Au, 0, 1.0, 1, 0, 0);
            }
            else
            {
              if ( CPedToPlayerConversations::m_Topic != 8 )
              {
                v56 = CPedToPlayerConversations::m_pPed->m_nPedType;
                v57 = v56 == 22;
                if ( v56 != 22 )
                  v57 = v56 == 5;
                if ( v57 )
                  CPed::Say(PlayerPed, 0x83u, 0, 1.0, 1, 0, 0);
                else
                  CPed::Say(PlayerPed, 0x84u, 0, 1.0, 1, 0, 0);
                v61 = 2;
                goto LABEL_163;
              }
              CPed::Say(PlayerPed, 0xEBu, 0, 1.0, 1, 0, 0);
            }
LABEL_121:
            CPedToPlayerConversations::EndConversation();
            return;
          }
          v54 = CPedToPlayerConversations::m_pPed->m_nPedType;
          v55 = v54 == 22;
          if ( v54 != 22 )
            v55 = v54 == 5;
          if ( v55 )
            CPed::Say(PlayerPed, 0x87u, 0, 1.0, 1, 0, 0);
          else
            CPed::Say(PlayerPed, 0x88u, 0, 1.0, 1, 0, 0);
          if ( CPedToPlayerConversations::m_pPed->m_nPedType != 8
            && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 39 )
          {
            v58 = (CTaskComplexSequence *)CTask::operator new(0x40u);
            CTaskComplexSequence::CTaskComplexSequence(v58);
            v59 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
            CTaskSimpleStandStill::CTaskSimpleStandStill(v59, 2000, 0, 0, 8.0);
            CTaskComplexSequence::AddTask(v58, v59);
            v60 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
            CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v60, PlayerPed, -1, 0, 0, 0, 0);
            CTaskComplexSequence::AddTask(v58, v60);
            CEventScriptCommand::CEventScriptCommand(v69, 3, v58, 0);
            CEventGroup::Add(&CPedToPlayerConversations::m_pPed->m_pPedIntelligence->m_eventGroup, v69, 0);
            CEventScriptCommand::~CEventScriptCommand(v69);
          }
        }
LABEL_162:
        v61 = 3;
LABEL_163:
        CPedToPlayerConversations::m_State = v61;
        CPedToPlayerConversations::m_StartTime = CTimer::m_snTimeInMilliseconds;
        return;
      }
      CPedToPlayerConversations::m_State = 0;
      CAEPedSpeechAudioEntity::ReleasePlayerConversation();
      if ( IKChainManager_c::IsLooking(&g_ikChainMan, PlayerPed) )
LABEL_125:
        sub_1A0E80(&g_ikChainMan, PlayerPed, 250);
      return;
    case 2u:
      if ( CPedToPlayerConversations::m_pPed )
      {
        if ( CTimer::m_snTimeInMilliseconds > CPedToPlayerConversations::m_StartTime + 3000
          && !CPed::GetPedTalking(CPedToPlayerConversations::m_pPed) )
        {
          CPed::Say(CPedToPlayerConversations::m_pPed, 0x85u, 0, 1.0, 1, 0, 0);
          goto LABEL_162;
        }
        return;
      }
      CPedToPlayerConversations::m_State = 0;
      CAEPedSpeechAudioEntity::ReleasePlayerConversation();
      if ( !IKChainManager_c::IsLooking(&g_ikChainMan, PlayerPed) )
        return;
      goto LABEL_125;
    case 3u:
      if ( CTimer::m_snTimeInMilliseconds > CPedToPlayerConversations::m_StartTime + 2500
        || !CPedToPlayerConversations::m_pPed )
      {
        goto LABEL_121;
      }
      return;
    default:
      return;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00302E04) --------------------------------------------------------
void CPedToPlayerConversations::EndConversation()
{
  CPlayerPed *PlayerPed; // r4

  PlayerPed = FindPlayerPed(-1);
  CPedToPlayerConversations::m_State = 0;
  CAEPedSpeechAudioEntity::ReleasePlayerConversation();
  if ( CPedToPlayerConversations::m_pPed )
    CPed::EnablePedSpeech(CPedToPlayerConversations::m_pPed);
  if ( IKChainManager_c::IsLooking(&g_ikChainMan, PlayerPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, PlayerPed, 250);
  if ( CPedToPlayerConversations::m_pPed )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, CPedToPlayerConversations::m_pPed) )
      sub_1A0E80(&g_ikChainMan, CPedToPlayerConversations::m_pPed, 250);
  }
}

//----- (00302EA0) --------------------------------------------------------
bool __fastcall CPed::PedIsInvolvedInConversation(CPed *this)
{
  return CPedToPlayerConversations::m_pPed == this;
}

//----- (00302EBA) --------------------------------------------------------
float __fastcall CCurves::DistForLineToCrossOtherLine(
        float LineBaseX,
        float LineBaseY,
        float LineDirX,
        float LineDirY,
        float OtherLineBaseX,
        float OtherLineBaseY,
        float OtherLineDirX,
        float OtherLineDirY)
{
  float v8; // s4

  v8 = (float)(LineDirX * OtherLineDirY) - (float)(LineDirY * OtherLineDirX);
  if ( v8 == 0.0 )
    return -1.0;
  else
    return (float)-(float)((float)((float)(LineBaseX - OtherLineBaseX) * OtherLineDirY)
                         - (float)((float)(LineBaseY - OtherLineBaseY) * OtherLineDirX))
         / v8;
}

//----- (00302F1C) --------------------------------------------------------
float __fastcall CCurves::CalcSpeedVariationInBend(
        const CVector *startCoors,
        const CVector *endCoors,
        float StartDirX,
        float StartDirY,
        float EndDirX,
        float EndDirY)
{
  float v6; // s4
  float v7; // s0

  v6 = (float)(StartDirX * EndDirX) + (float)(StartDirY * EndDirY);
  if ( v6 <= 0.0 )
    return 0.33333;
  if ( v6 <= 0.7 )
    v7 = (float)(v6 / -0.7) + 1.0;
  else
    v7 = CCollision::DistToMathematicalLine2D(endCoors->x, endCoors->y, EndDirX, EndDirY, startCoors->x, startCoors->y)
       / sqrtf(
           (float)((float)(startCoors->x - endCoors->x) * (float)(startCoors->x - endCoors->x))
         + (float)((float)(startCoors->y - endCoors->y) * (float)(startCoors->y - endCoors->y)));
  return v7 * 0.33333;
}

//----- (00302FE0) --------------------------------------------------------
float __fastcall CCurves::CalcSpeedScaleFactor(
        const CVector *startCoors,
        const CVector *endCoors,
        float StartDirX,
        float StartDirY,
        float EndDirX,
        float EndDirY)
{
  float32x2_t v6; // d5
  float32x2_t v7; // d6
  float v12; // s0
  float v13; // s0
  float v14; // s0
  float v15; // s12
  float x; // s2
  float y; // s4
  float v18; // s6
  float v19; // s8
  float v20; // s0
  float v21; // s2
  float v22; // s4
  float32x2_t v23; // d0
  float v24; // s0

  v12 = (float)(StartDirX * EndDirX) + (float)(StartDirY * EndDirY);
  if ( v12 <= 0.0 )
  {
    v14 = 0.33333;
  }
  else
  {
    if ( v12 <= 0.7 )
      v13 = (float)(v12 / -0.7) + 1.0;
    else
      v13 = CCollision::DistToMathematicalLine2D(
              endCoors->x,
              endCoors->y,
              EndDirX,
              EndDirY,
              startCoors->x,
              startCoors->y)
          / sqrtf(
              (float)((float)(startCoors->x - endCoors->x) * (float)(startCoors->x - endCoors->x))
            + (float)((float)(startCoors->y - endCoors->y) * (float)(startCoors->y - endCoors->y)));
    v14 = v13 * 0.33333;
  }
  v15 = (float)(StartDirX * EndDirY) - (float)(StartDirY * EndDirX);
  if ( v15 == 0.0 )
  {
    x = endCoors->x;
    y = endCoors->y;
    v18 = startCoors->x;
    v19 = startCoors->y;
  }
  else
  {
    x = endCoors->x;
    v18 = startCoors->x;
    y = endCoors->y;
    v19 = startCoors->y;
    v6.n64_f32[0] = (float)-(float)((float)((float)(startCoors->x - endCoors->x) * EndDirY)
                                  - (float)((float)(v19 - y) * EndDirX))
                  / v15;
    if ( v6.n64_f32[0] > 0.0 )
    {
      v23.n64_f32[1] = (float)(x - v18) * StartDirY;
      v7.n64_f32[0] = (float)-(float)(v23.n64_f32[1] - (float)((float)(y - v19) * StartDirX)) / v15;
      if ( v7.n64_f32[0] > 0.0 )
      {
        v23.n64_u32[0] = 5.0;
        v24 = vmin_f32(vmin_f32(v6, v7), v23).n64_f32[0];
        v21 = v7.n64_f32[0] - v24;
        v22 = v6.n64_f32[0] - v24;
        v20 = v24 + v24;
        return v20 + (float)(v21 + v22);
      }
    }
  }
  v20 = sqrtf((float)((float)(v18 - x) * (float)(v18 - x)) + (float)((float)(v19 - y) * (float)(v19 - y)))
      / (float)(1.0 - v14);
  v21 = 0.0;
  v22 = 0.0;
  return v20 + (float)(v21 + v22);
}
// 303146: variable 'v6' is possibly undefined
// 303146: variable 'v7' is possibly undefined

//----- (00303180) --------------------------------------------------------
void __fastcall CCurves::CalcCurvePoint(
        const CVector *startCoors,
        const CVector *endCoors,
        const CVector *startDir,
        const CVector *endDir,
        float Time,
        Int32 TraverselTimeInMillis,
        CVector *resultCoor,
        CVector *resultSpeed)
{
  float32x2_t v8; // d0
  float32x2_t v9; // d1
  float32x2_t v10; // d2
  float32x2_t v11; // d3
  float32x2_t v12; // d9
  float32x2_t v13; // d10
  float x; // s22
  float v17; // s26
  float y; // s24
  float v21; // s28
  float v22; // s0
  float v23; // s16
  float v24; // r0
  float v25; // s0
  float v26; // s0
  Int32 v27; // r0
  float v28; // s2
  float v29; // s23
  float v30; // s25
  float v31; // s27
  float v32; // s29
  float v33; // s30
  float v34; // s31
  float v35; // s0
  float v36; // s2
  float v37; // s18
  float v38; // r0
  float v39; // s4
  float v40; // s20
  float v41; // s16
  float v42; // r4
  float v43; // s0
  float v44; // s4
  float v45; // s2
  float v46; // s6
  float v47; // s10
  float v48; // s14
  float v49; // s8
  float v50; // s12
  float v51; // s0
  float v52; // s2
  float v53; // s4
  float v54; // s6
  float v55; // s0
  float v56; // s0
  float v57; // s4
  float v58; // s6
  float v59; // s2
  float v60; // s2
  float v61; // s8
  float v62; // s6
  float v63; // s4
  float v64; // s8
  float v65; // s10
  float v66; // s4
  float v67; // s12
  float v68; // s14
  float v69; // s6
  float v70; // s1
  float v71; // s2
  float v72; // s4
  float v73; // s6
  float v74; // s8

  x = endDir->x;
  v13.n64_u32[0] = 1.0;
  v17 = startDir->x;
  y = endDir->y;
  v21 = startDir->y;
  v12.n64_u32[0] = 0;
  v22 = (float)(startDir->x * endDir->x) + (float)(v21 * y);
  v9.n64_f32[0] = Time;
  LODWORD(v23) = vmin_f32(vmax_f32(v9, v12), v13).n64_u32[0];
  if ( v22 <= 0.0 )
  {
    v26 = 0.33333;
  }
  else
  {
    if ( v22 <= 0.7 )
    {
      v25 = (float)(v22 / -0.7) + 1.0;
    }
    else
    {
      v24 = CCollision::DistToMathematicalLine2D(
              endCoors->x,
              endCoors->y,
              endDir->x,
              endDir->y,
              startCoors->x,
              startCoors->y);
      x = endDir->x;
      y = endDir->y;
      v17 = startDir->x;
      v21 = startDir->y;
      v25 = v24
          / sqrtf(
              (float)((float)(startCoors->x - endCoors->x) * (float)(startCoors->x - endCoors->x))
            + (float)((float)(startCoors->y - endCoors->y) * (float)(startCoors->y - endCoors->y)));
    }
    v26 = v25 * 0.33333;
  }
  v27 = TraverselTimeInMillis;
  v28 = (float)(v17 * y) - (float)(v21 * x);
  if ( v28 == 0.0 )
  {
    v29 = endCoors->x;
    v30 = endCoors->y;
    v31 = startCoors->x;
    v32 = startCoors->y;
  }
  else
  {
    v29 = endCoors->x;
    v31 = startCoors->x;
    v30 = endCoors->y;
    v32 = startCoors->y;
    v10.n64_f32[0] = (float)-(float)((float)(y * (float)(startCoors->x - endCoors->x)) - (float)(x * (float)(v32 - v30)))
                   / v28;
    if ( v10.n64_f32[0] > 0.0 )
    {
      v11.n64_f32[0] = (float)-(float)((float)(v21 * (float)(v29 - v31)) - (float)(v17 * (float)(v30 - v32))) / v28;
      if ( v11.n64_f32[0] > 0.0 )
      {
        v8.n64_u32[0] = 5.0;
        v60 = vmin_f32(vmin_f32(v10, v11), v8).n64_f32[0];
        v55 = v10.n64_f32[0] - v60;
        v33 = v60 + v60;
        v12.n64_f32[0] = v11.n64_f32[0] - v60;
        v61 = (float)(v10.n64_f32[0] - v60) + (float)(v60 + v60);
        v62 = (float)(v11.n64_f32[0] - v60) + v61;
        v63 = v23 * v62;
        if ( (float)(v23 * v62) >= v55 )
        {
          if ( v63 >= v61 )
          {
            v71 = v63 - v62;
            v72 = (float)(v63 - v62) * endDir->z;
            v73 = v71 * y;
            v74 = v71 * x;
            v52 = v72 + endCoors->z;
            v53 = v73 + v30;
            v54 = v74 + v29;
          }
          else
          {
            v66 = (float)(v63 - v55) / v33;
            v67 = (float)(1.0 - v66) * (float)((float)(v60 * (float)(v66 * v21)) + (float)((float)(v55 * v21) + v32));
            v68 = v66
                * (float)((float)(v30 - (float)(v12.n64_f32[0] * y)) - (float)(v60 * (float)((float)(1.0 - v66) * y)));
            v69 = (float)(1.0 - v66) * (float)((float)(v60 * (float)(v66 * v17)) + (float)((float)(v55 * v17) + v31));
            v70 = v66
                * (float)((float)(v29 - (float)(v12.n64_f32[0] * x)) - (float)(v60 * (float)((float)(1.0 - v66) * x)));
            v52 = (float)((float)(1.0 - v66)
                        * (float)((float)(v60 * (float)(v66 * startDir->z))
                                + (float)((float)(v55 * startDir->z) + startCoors->z)))
                + (float)(v66
                        * (float)((float)(endCoors->z - (float)(v12.n64_f32[0] * endDir->z))
                                - (float)(v60 * (float)((float)(1.0 - v66) * endDir->z))));
            v53 = v67 + v68;
            v54 = v69 + v70;
          }
        }
        else
        {
          v64 = v63 * v17;
          v65 = v63 * startDir->z;
          v53 = (float)(v63 * v21) + v32;
          v54 = v64 + v31;
          v52 = v65 + startCoors->z;
        }
        goto LABEL_13;
      }
    }
  }
  v33 = sqrtf((float)((float)(v31 - v29) * (float)(v31 - v29)) + (float)((float)(v32 - v30) * (float)(v32 - v30)));
  v34 = v33 / (float)(1.0 - v26);
  if ( v34 >= 0.00001 )
  {
    v37 = v23 * v34;
    v38 = (float)((float)(v23 * v34) * 6.2832) / v34;
    v39 = (float)((float)(v26 * -2.0) + 1.0) + 1.0;
    v40 = v23;
    v41 = v26 * (float)(v34 / 6.2832);
    v42 = sinf(v38);
    v43 = cosf((float)(v37 / v34) * 3.1416);
    v27 = TraverselTimeInMillis;
    v44 = (float)(v39 * 0.5) * v37;
    v45 = v41 * v42;
    v23 = v40;
    v13.n64_u32[0] = 1.0;
    v35 = 0.5 - (float)(v43 * 0.5);
    v12.n64_u32[0] = 0;
    v36 = v44 + v45;
  }
  else
  {
    v35 = 0.5;
    v36 = 0.0;
  }
  v46 = (float)(v13.n64_f32[0] - v35) * (float)((float)(v36 * startDir->z) + startCoors->z);
  v47 = (float)(v13.n64_f32[0] - v35) * (float)((float)(v36 * v21) + v32);
  v48 = (float)(v13.n64_f32[0] - v35) * (float)((float)(v36 * v17) + v31);
  v49 = v35 * (float)((float)((float)(v36 - v33) * endDir->z) + endCoors->z);
  v50 = v35 * (float)((float)((float)(v36 - v33) * y) + v30);
  v51 = v35 * (float)((float)((float)(v36 - v33) * x) + v29);
  v52 = v46 + v49;
  v53 = v47 + v50;
  v54 = v48 + v51;
  v55 = 0.0;
LABEL_13:
  resultCoor->x = v54;
  resultCoor->y = v53;
  resultCoor->z = v52;
  v56 = v12.n64_f32[0] + (float)(v33 + v55);
  v57 = (float)v27 * 0.001;
  resultSpeed->x = (float)(v56 * (float)((float)((float)(v13.n64_f32[0] - v23) * startDir->x) + (float)(v23 * endDir->x)))
                 / v57;
  v58 = startDir->y;
  v59 = v23 * endDir->y;
  resultSpeed->z = 0.0;
  resultSpeed->y = (float)(v56 * (float)((float)((float)(v13.n64_f32[0] - v23) * v58) + v59)) / v57;
}
// 3031C0: variable 'v9' is possibly undefined
// 3031C0: variable 'v12' is possibly undefined
// 3031C4: variable 'v13' is possibly undefined
// 303490: variable 'v10' is possibly undefined
// 303490: variable 'v11' is possibly undefined
// 303494: variable 'v8' is possibly undefined

//----- (003035EC) --------------------------------------------------------
float __fastcall CCurves::CalcCorrectedDist(float Current, float Total, float SpeedVariation, float *pInterPol)
{
  float v6; // s2
  float v7; // s0
  float v9; // s22
  float v10; // s24
  float v11; // r5
  float result; // r0

  if ( Total >= 0.00001 )
  {
    v9 = (float)(Total / 6.2832) * SpeedVariation;
    v10 = (float)((float)((float)(SpeedVariation * -2.0) + 1.0) + 1.0) * 0.5;
    v11 = sinf((float)(Current * 6.2832) / Total);
    v7 = 0.5 - (float)(cosf((float)(Current / Total) * 3.1416) * 0.5);
    v6 = (float)(v10 * Current) + (float)(v9 * v11);
  }
  else
  {
    v6 = 0.0;
    v7 = 0.5;
  }
  result = v6;
  *pInterPol = v7;
  return result;
}

//----- (003036A4) --------------------------------------------------------
void CDarkel::Init()
{
  CDarkel::Status = 0;
}

//----- (003036B4) --------------------------------------------------------
void CDarkel::Update()
{
  bool v0; // zf
  CPlayerPed *PlayerPed; // r0
  signed int v2; // kr00_4

  v0 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v0 = CDarkel::Status == 1;
  if ( v0 )
  {
    if ( (CDarkel::TimeLimit < 0
       || (int)(CDarkel::TimeOfFrenzyStart - CTimer::m_snTimeInMilliseconds + CDarkel::TimeLimit) >= 1)
      && (CDarkel::Status != 4 || CWorld::Players[1].pPed) )
    {
      v2 = CDarkel::TimeOfFrenzyStart - CTimer::m_snTimeInMilliseconds + CDarkel::TimeLimit;
      if ( v2 / 1000 != CDarkel::PreviousTime )
      {
        if ( CDarkel::PreviousTime <= 11 )
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 33, 0.0, 1.0);
        CDarkel::PreviousTime = v2 / 1000;
      }
    }
    else
    {
      if ( CDarkel::Status == 4 )
      {
        CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
        CGameLogic::GameState = 3;
      }
      CPopulation::m_AllRandomPedsThisType = -1;
      CDarkel::Status = 3;
      CDarkel::TimeOfFrenzyStart = CTimer::m_snTimeInMilliseconds;
      CDarkel::DealWithWeaponChangeAtEndOfFrenzy();
    }
    if ( CDarkel::KillsNeeded <= 0 )
    {
      if ( CDarkel::Status == 4 )
      {
        CGameLogic::GameState = 4;
        CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
      }
      CPopulation::m_AllRandomPedsThisType = -1;
      CDarkel::Status = 2;
      if ( CDarkel::bProperKillFrenzy )
        CStats::IncrementStat(0xA8u, 1.0);
      CDarkel::TimeOfFrenzyStart = CTimer::m_snTimeInMilliseconds;
      PlayerPed = FindPlayerPed(-1);
      CPlayerPed::SetWantedLevel(PlayerPed, 0);
      CDarkel::DealWithWeaponChangeAtEndOfFrenzy();
    }
  }
}

//----- (00303858) --------------------------------------------------------
void CDarkel::DealWithWeaponChangeAtEndOfFrenzy()
{
  int32 v0; // r4
  CWeaponInfo *WeaponInfo; // r0
  unsigned int m_nWeaponSlot_low; // r6
  CPlayerPed *PlayerPed; // r5
  CPlayerPed *v4; // r0
  CWeaponInfo *v5; // r0
  CPlayerPed *v6; // r0
  CWeaponInfo *v7; // r0
  int32 m_nWeaponSlot; // r4
  CPlayerPed *v9; // r0
  CPlayerPed *v10; // r4
  CPlayerPed *v11; // r0
  CWeaponInfo *v12; // r0
  eWeaponType m_eWeaponType; // r4
  CPlayerPedData *m_pPlayerData; // r0
  char v15; // r1
  CPlayerPed *v16; // r4
  CPlayerPed *v17; // r0
  CPlayerPed *v18; // r4
  CPlayerPed *v19; // r0

  v0 = CDarkel::WeaponType;
  if ( CDarkel::WeaponType == WEAPONTYPE_UZI_DRIVEBY )
    v0 = 28;
  if ( CDarkel::InterruptedWeaponType && v0 <= 46 )
  {
    WeaponInfo = CWeaponInfo::GetWeaponInfo(CDarkel::InterruptedWeaponType, 1);
    CBaseModelInfo::RemoveRef(CModelInfo::ms_modelInfoPtrs[WeaponInfo->m_modelId]);
  }
  if ( v0 <= 46 )
  {
    m_nWeaponSlot_low = LOBYTE(CWeaponInfo::GetWeaponInfo((eWeaponType)v0, 1)->m_nWeaponSlot);
    PlayerPed = FindPlayerPed(-1);
    v4 = FindPlayerPed(-1);
    v5 = CWeaponInfo::GetWeaponInfo(v4->m_WeaponSlots[m_nWeaponSlot_low].m_eWeaponType, 1);
    CPed::RemoveWeaponModel(PlayerPed, v5->m_modelId);
    FindPlayerPed(-1)->m_WeaponSlots[m_nWeaponSlot_low].m_eWeaponType = WEAPONTYPE_UNARMED;
    FindPlayerPed(-1)->m_WeaponSlots[m_nWeaponSlot_low].m_nAmmoTotal = 0;
    FindPlayerPed(-1)->m_WeaponSlots[m_nWeaponSlot_low].m_nAmmoInClip = 0;
    FindPlayerPed(-1)->m_WeaponSlots[m_nWeaponSlot_low].m_eState = WEAPONSTATE_READY;
    v6 = FindPlayerPed(-1);
    CPed::RemoveWeaponAnims(v6, v0, -1000.0);
    if ( CModelInfo::ms_modelInfoPtrs[CWeaponInfo::GetWeaponInfo((eWeaponType)v0, 1)->m_modelId]->m_numRefs >= 1 )
    {
      v7 = CWeaponInfo::GetWeaponInfo((eWeaponType)v0, 1);
      CBaseModelInfo::RemoveRef(CModelInfo::ms_modelInfoPtrs[v7->m_modelId]);
    }
    m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(CDarkel::InterruptedWeaponTypeSelected, 1)->m_nWeaponSlot;
    FindPlayerPed(-1)->m_pPlayerData->m_nChosenWeapon = m_nWeaponSlot;
    v9 = FindPlayerPed(-1);
    CPed::GiveWeapon(v9, CDarkel::InterruptedWeaponType, CDarkel::AmmoInterruptedWeapon, 1);
  }
  if ( FindPlayerVehicle(-1, 0) )
  {
    v10 = FindPlayerPed(-1);
    v11 = FindPlayerPed(-1);
    v12 = CWeaponInfo::GetWeaponInfo(v11->m_WeaponSlots[v11->m_nCurrentWeapon].m_eWeaponType, 1);
    CPed::RemoveWeaponModel(v10, v12->m_modelId);
    m_eWeaponType = FindPlayerPed(-1)->m_WeaponSlots[4].m_eWeaponType;
    m_pPlayerData = FindPlayerPed(-1)->m_pPlayerData;
    if ( m_eWeaponType )
      v15 = 4;
    else
      v15 = 0;
    m_pPlayerData->m_nChosenWeapon = v15;
    v16 = FindPlayerPed(-1);
    v17 = FindPlayerPed(-1);
    CPed::SetCurrentWeapon(v16, v17->m_pPlayerData->m_nChosenWeapon);
    v18 = FindPlayerPed(-1);
    v19 = FindPlayerPed(-1);
    sub_19AC7C(v18, v19->m_WeaponSlots[v19->m_nCurrentWeapon].m_eWeaponType);
  }
}

//----- (00303A6C) --------------------------------------------------------
void CDarkel::DrawMessages()
{
  uint32 v0; // r0
  GxtChar *v1; // r0
  float bottom; // s16
  float left; // s24
  float v4; // s0
  float right; // s20
  float v6; // s18
  CRGBA v7; // r0
  float v8; // s28
  float v9; // s30
  float v10; // s0
  float v11; // s24
  GxtChar *v12; // r0
  UInt32 v13; // r6
  float v14; // s20
  float Height; // r0
  float v16; // s16
  float v17; // s0
  GxtChar *v18; // r0
  float v19; // r0
  CRGBA v20; // [sp+8h] [bp-88h] BYREF
  CRGBA v21; // [sp+Ch] [bp-84h] BYREF
  CRGBA v22; // [sp+10h] [bp-80h] BYREF
  CRGBA v23; // [sp+14h] [bp-7Ch] BYREF
  CRGBA v24; // [sp+18h] [bp-78h] BYREF
  CRGBA v25; // [sp+1Ch] [bp-74h] BYREF
  CRect Rectangle; // [sp+20h] [bp-70h] BYREF

  if ( CDarkel::Status == 4 )
    goto LABEL_4;
  if ( CDarkel::Status != 2 )
  {
    if ( CDarkel::Status != 1 )
      return;
LABEL_4:
    v0 = CTimer::m_snTimeInMilliseconds - CDarkel::TimeOfFrenzyStart;
    if ( CDarkel::bStandardSoundAndMessages )
    {
      if ( v0 >= 0xBB8 && v0 <= 0x2AF7 )
      {
LABEL_12:
        if ( CDarkel::pStartMessage )
          CMessages::AddBigMessage(CDarkel::pStartMessage, 0xBB8u, 0);
      }
    }
    else if ( v0 >> 6 <= 0x7C )
    {
      goto LABEL_12;
    }
    if ( CTouchInterface::m_pWidgets[176] && !CHud::bDrawingVitalStats && CDarkel::TimeLimit >= 1 )
    {
      bottom = CTouchInterface::m_pWidgets[176]->m_RectScreen.bottom;
      left = CTouchInterface::m_pWidgets[176]->m_RectScreen.left;
      v4 = CTouchInterface::m_pWidgets[176]->m_RectScreen.top - bottom;
      right = CTouchInterface::m_pWidgets[176]->m_RectScreen.right;
      Rectangle.bottom = bottom;
      Rectangle.left = left;
      Rectangle.right = right;
      v6 = (float)(fabsf(v4) + -2.0) / 3.0;
      Rectangle.top = bottom + v6;
      CRGBA::CRGBA(&v25, 0, 0, 0, 0x80u);
      CRGBA::CRGBA(&v24, 0, 0, 0, 0x80u);
      CRGBA::CRGBA(&v23, 0, 0, 0, 0xFFu);
      CRGBA::CRGBA(&v22, 0, 0, 0, 0xFFu);
      CSprite2d::DrawRect(&Rectangle, &v25, &v24, &v23, &v22);
      Rectangle.top = (float)(bottom + (float)(v6 + v6)) + 1.0;
      Rectangle.left = left;
      Rectangle.right = right;
      Rectangle.bottom = (float)(bottom + v6) + 1.0;
      CRGBA::CRGBA(&v25, 0, 0, 0, 0x80u);
      CRGBA::CRGBA(&v24, 0, 0, 0, 0x80u);
      CRGBA::CRGBA(&v23, 0, 0, 0, 0xFFu);
      CRGBA::CRGBA(&v22, 0, 0, 0, 0xFFu);
      CSprite2d::DrawRect(&Rectangle, &v25, &v24, &v23, &v22);
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetFontStyle(2u);
      CFont::SetRightJustifyWrap(0.0);
      CFont::SetEdge(0);
      CFont::SetWrapx((float)RsGlobal.screenWidth);
      CRGBA::CRGBA(&v21, 0, 0, 0, 0xFFu);
      CFont::SetDropColor(v7);
      CHudColours::GetRGBA(&v20, &HudColour, 5u);
      CFont::SetColor((CRGBA)&v20);
      CFont::SetScale(v6 * 0.0325);
      CFont::SetOrientation(1u);
      v8 = v6 * 0.5;
      v9 = fabsf(right - left) * 0.03;
      v10 = CFont::GetHeight(0) * 0.5;
      v11 = left + v9;
      v12 = CText::Get(&TheText, "RAC_TIM");
      CFont::PrintString(v11, (float)(bottom + (float)(v6 * 0.5)) - v10, v12);
      CFont::SetOrientation(2u);
      v13 = CDarkel::TimeOfFrenzyStart - CTimer::m_snTimeInMilliseconds + CDarkel::TimeLimit;
      sprintf(gString, "%d:%02d", v13 / 0xEA60, v13 % 0xEA60 / 0x3E8);
      AsciiToGxtChar(gString, gGxtString);
      if ( v13 > 0xFA0 || (unsigned __int8)CTimer::m_FrameCounter << 31 )
      {
        Height = CFont::GetHeight(0);
        v14 = right - v9;
        CFont::PrintString(v14, (float)(bottom + v8) + (float)(Height * -0.5), gGxtString);
      }
      else
      {
        v14 = right - v9;
      }
      CFont::SetOrientation(1u);
      v16 = v8 + (float)(bottom + (float)(v6 + 1.0));
      v17 = CFont::GetHeight(0) * 0.5;
      v18 = CText::Get(&TheText, "COOPKIL");
      CFont::PrintString(v11, v16 - v17, v18);
      CFont::SetOrientation(2u);
      sprintf(gString, (const unsigned __int8 *)&dword_303F18);
      AsciiToGxtChar(gString, gGxtString);
      v19 = CFont::GetHeight(0);
      CFont::PrintString(v14, v16 - (float)(v19 * 0.5), gGxtString);
    }
    return;
  }
  if ( CDarkel::bStandardSoundAndMessages && CTimer::m_snTimeInMilliseconds - CDarkel::TimeOfFrenzyStart <= 0x1387 )
  {
    v1 = CText::Get(&TheText, "KILLPA");
    sub_1975F4(v1, 0xBB8u, 0);
  }
}
// 303CC8: variable 'v7' is possibly undefined
// 303F18: using guessed type int dword_303F18;

//----- (00303F20) --------------------------------------------------------
int CDarkel::ReadStatus()
{
  return CDarkel::Status;
}

//----- (00303F30) --------------------------------------------------------
int CDarkel::FrenzyOnGoing()
{
  int v0; // r1
  int v1; // r0

  v0 = 0;
  v1 = CDarkel::Status;
  if ( CDarkel::Status == 4 )
    v0 = 1;
  if ( CDarkel::Status != 1 )
    v1 = 0;
  return v1 | v0;
}

//----- (00303F50) --------------------------------------------------------
void CDarkel::ResetOnPlayerDeath()
{
  bool v0; // zf

  CHud::SetHelpMessage(0, 0, 1, 0, 0, 0);
  v0 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v0 = CDarkel::Status == 1;
  if ( v0 )
  {
    CPopulation::m_AllRandomPedsThisType = -1;
    CDarkel::Status = 3;
    CDarkel::TimeOfFrenzyStart = CTimer::m_snTimeInMilliseconds;
    CDarkel::DealWithWeaponChangeAtEndOfFrenzy();
  }
}

//----- (00303FC4) --------------------------------------------------------
void CDarkel::FailKillFrenzy()
{
  bool v0; // zf

  if ( CDarkel::Status == 4 )
  {
    CGameLogic::GameState = 3;
    CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
  }
  CHud::SetHelpMessage(0, 0, 1, 0, 0, 0);
  v0 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v0 = CDarkel::Status == 1;
  if ( v0 )
  {
    CPopulation::m_AllRandomPedsThisType = -1;
    CDarkel::Status = 3;
    CDarkel::TimeOfFrenzyStart = CTimer::m_snTimeInMilliseconds;
    CDarkel::DealWithWeaponChangeAtEndOfFrenzy();
  }
}

//----- (0030406C) --------------------------------------------------------
void __fastcall CDarkel::RegisterKillByPlayer(
        const CPed *pKilledPed,
        eWeaponType WeaponUsed,
        bool bHeadShot,
        Int32 PlayerNo)
{
  unsigned int m_nPedType; // r0
  _BOOL4 v7; // r8
  UInt16 v9; // r0
  int v10; // r1
  bool v11; // zf
  bool v12; // zf
  bool v13; // zf
  bool v14; // zf
  bool v15; // zf
  bool v16; // zf
  CPlayerPed *PlayerPed; // r0
  bool v18; // zf
  bool v19; // zf
  int m_nModelIndex; // r0
  bool v21; // zf
  UInt16 v22; // r0
  Int16 *v23; // r0
  UInt32 *v24; // r0

  m_nPedType = pKilledPed->m_nPedType;
  v7 = bHeadShot;
  if ( m_nPedType <= 0x11 )
  {
    if ( ((1 << m_nPedType) & (unsigned int)&elf_hash_chain[16198]) != 0 )
    {
      CStats::IncrementStat(0x44u, 0.75);
      v9 = 239;
      v10 = 1065353216;
LABEL_4:
      CStats::IncrementStat(v9, *(float *)&v10);
      goto LABEL_5;
    }
    if ( ((1 << m_nPedType) & 0x20040) != 0 )
    {
      v9 = 68;
      v10 = 1069547520;
      goto LABEL_4;
    }
    if ( m_nPedType == 8 )
    {
      CStats::DecrementStat(0x44u, 5.0);
      CStats::IncrementStat(0xF0u, 1.0);
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pKilledPed) )
      {
        CStats::IncrementStat(0xA3u, 1.0);
        CStats::DisplayScriptStatUpdateMessage(0, 0x150u, 1.0);
      }
    }
  }
LABEL_5:
  v11 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v11 = CDarkel::Status == 1;
  if ( v11 )
  {
    if ( WeaponUsed != -1 && (CDarkel::WeaponType | 1) == 57 )
    {
      if ( CDarkel::WeaponType == WEAPONTYPE_ANYWEAPON )
      {
        if ( (unsigned int)WeaponUsed < WEAPONTYPE_PARACHUTE || (unsigned int)(WeaponUsed - 51) < 2 )
          goto LABEL_36;
      }
      else if ( CDarkel::WeaponType == WEAPONTYPE_ANYMELEE && (unsigned int)WeaponUsed < WEAPONTYPE_GRENADE )
      {
        goto LABEL_36;
      }
    }
    v12 = WeaponUsed == WEAPONTYPE_EXPLOSION;
    if ( WeaponUsed != WEAPONTYPE_EXPLOSION )
      v12 = CDarkel::WeaponType == WeaponUsed;
    if ( !v12 )
    {
      v13 = WeaponUsed == WEAPONTYPE_UZI_DRIVEBY;
      if ( WeaponUsed == WEAPONTYPE_UZI_DRIVEBY )
        v13 = CDarkel::WeaponType == WEAPONTYPE_MICRO_UZI;
      if ( !v13 )
      {
        v14 = WeaponUsed == WEAPONTYPE_RAMMEDBYCAR;
        if ( WeaponUsed == WEAPONTYPE_RAMMEDBYCAR )
          v14 = CDarkel::WeaponType == WEAPONTYPE_RUNOVERBYCAR;
        if ( !v14 )
        {
          v15 = WeaponUsed == WEAPONTYPE_RUNOVERBYCAR;
          if ( WeaponUsed == WEAPONTYPE_RUNOVERBYCAR )
            v15 = CDarkel::WeaponType == WEAPONTYPE_RAMMEDBYCAR;
          if ( !v15 )
          {
            v16 = WeaponUsed == WEAPONTYPE_FLAMETHROWER;
            if ( WeaponUsed == WEAPONTYPE_FLAMETHROWER )
              v16 = CDarkel::WeaponType == WEAPONTYPE_MOLOTOV;
            if ( !v16 )
              goto LABEL_56;
          }
        }
      }
    }
LABEL_36:
    v18 = CDarkel::Status == 4;
    if ( CDarkel::Status != 4 )
      v18 = CDarkel::Status == 1;
    if ( v18 )
    {
      m_nModelIndex = CDarkel::ModelToKill + 1;
      v19 = CDarkel::ModelToKill == -1;
      if ( CDarkel::ModelToKill != -1 )
      {
        m_nModelIndex = pKilledPed->m_nModelIndex;
        v19 = CDarkel::ModelToKill == m_nModelIndex;
      }
      if ( v19
        || CDarkel::ModelToKill2 == m_nModelIndex
        || CDarkel::ModelToKill3 == m_nModelIndex
        || CDarkel::ModelToKill4 == m_nModelIndex )
      {
        if ( pKilledPed->m_nPedType < 2u )
          goto LABEL_54;
        v21 = !CDarkel::bNeedHeadShot;
        if ( CDarkel::bNeedHeadShot )
          v21 = v7;
        if ( v21 )
        {
          --CDarkel::KillsNeeded;
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 43, 0.0, 1.0);
        }
      }
    }
    if ( pKilledPed->m_nPedType == 6 )
    {
      v22 = 206;
LABEL_55:
      CStats::IncrementStat(v22, 1.0);
      goto LABEL_56;
    }
LABEL_54:
    v22 = 205;
    goto LABEL_55;
  }
LABEL_56:
  v23 = CDarkel::RegisteredKills[pKilledPed->m_nModelIndex];
  ++v23[PlayerNo];
  CStats::IncrementStat(0x79u, 1.0);
  if ( (*((_BYTE *)&pKilledPed->m_nPedFlags + 5) & 4) != 0 )
    v24 = &CStats::PedsKilledOfThisType[20];
  else
    v24 = &CStats::PedsKilledOfThisType[pKilledPed->m_nPedType];
  ++*v24;
  if ( v7 )
    CStats::IncrementStat(0x82u, 1.0);
  CStats::IncrementStat(0xB0u, 1.0);
  if ( !PlayerNo && !(*((unsigned __int8 *)&CWorld::Players[0].pPed->m_nPedFlags + 1) << 31) )
    CGangWars::AddKillToProvocation(pKilledPed->m_nPedType);
  if ( pKilledPed->m_nPedType >= 17 )
    sub_1957DC();
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (003042E4) --------------------------------------------------------
bool __fastcall CDarkel::CheckDamagedWeaponType(Int32 DamagedBy, Int32 GeneralWeaponType)
{
  bool result; // r0

  if ( DamagedBy == -1 )
    return 0;
  if ( GeneralWeaponType != 57 )
    return GeneralWeaponType == 56 && (unsigned int)(DamagedBy - 16) >= 0x28 && (unsigned int)DamagedBy < 0x10;
  switch ( DamagedBy )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 51:
    case 52:
      result = 1;
      break;
    default:
      return 0;
  }
  return result;
}

//----- (0030435C) --------------------------------------------------------
bool __fastcall CDarkel::ThisPedShouldBeKilledForFrenzy(const CPed *pPed)
{
  bool v1; // zf
  bool v2; // zf
  int m_nModelIndex; // r1

  v1 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v1 = CDarkel::Status == 1;
  if ( !v1 )
    return 0;
  m_nModelIndex = CDarkel::ModelToKill + 1;
  v2 = CDarkel::ModelToKill == -1;
  if ( CDarkel::ModelToKill != -1 )
  {
    m_nModelIndex = pPed->m_nModelIndex;
    v2 = CDarkel::ModelToKill == m_nModelIndex;
  }
  return (v2
       || CDarkel::ModelToKill2 == m_nModelIndex
       || CDarkel::ModelToKill3 == m_nModelIndex
       || CDarkel::ModelToKill4 == m_nModelIndex)
      && pPed->m_nPedType > 1u;
}

//----- (003043CC) --------------------------------------------------------
void __fastcall CDarkel::RegisterKillNotByPlayer(const CPed *pKilledPed, eWeaponType WeaponUsed)
{
  CPlayerPed *PlayerPed; // r0
  int32 m_nPedType; // r0
  UInt16 v5; // r0

  if ( FindPlayerPed(-1) != pKilledPed )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( CPedGroupMembership::IsMember(
           &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
           pKilledPed) )
    {
      CStats::DecrementStat(0x44u, 2.0);
      CStats::IncrementStat(0xA3u, 1.0);
      CStats::DisplayScriptStatUpdateMessage(0, 0x150u, 1.0);
    }
  }
  CStats::IncrementStat(0x78u, 1.0);
  m_nPedType = pKilledPed->m_nPedType;
  if ( (unsigned int)(m_nPedType - 9) < 8 )
    goto LABEL_5;
  if ( m_nPedType == 8 )
  {
    v5 = 240;
    goto LABEL_6;
  }
  if ( m_nPedType == 7 )
  {
LABEL_5:
    v5 = 239;
LABEL_6:
    sub_194CA0(v5, 1.0);
  }
}

//----- (00304460) --------------------------------------------------------
void __fastcall CDarkel::RegisterCarBlownUpByPlayer(CVehicle *pDestroyedAuto, Int32 Player)
{
  bool v4; // zf
  bool v5; // zf
  int m_nModelIndex; // r1
  bool v7; // zf
  Int16 *v8; // r0
  UInt16 v9; // r0
  bool v10; // zf
  UInt16 v11; // r0

  v4 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v4 = CDarkel::Status == 1;
  if ( v4 )
  {
    m_nModelIndex = CDarkel::ModelToKill + 2;
    v5 = CDarkel::ModelToKill == -2;
    if ( CDarkel::ModelToKill != -2 )
    {
      m_nModelIndex = pDestroyedAuto->m_nModelIndex;
      v5 = CDarkel::ModelToKill == m_nModelIndex;
    }
    if ( v5
      || CDarkel::ModelToKill2 == m_nModelIndex
      || CDarkel::ModelToKill3 == m_nModelIndex
      || CDarkel::ModelToKill4 == m_nModelIndex )
    {
      goto LABEL_15;
    }
    v7 = CDarkel::ModelToKill == -3;
    if ( CDarkel::ModelToKill == -3 )
      v7 = pDestroyedAuto->m_vehicleType == 9;
    if ( v7 )
    {
LABEL_15:
      --CDarkel::KillsNeeded;
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 43, 0.0, 1.0);
    }
  }
  v8 = CDarkel::RegisteredKills[pDestroyedAuto->m_nModelIndex];
  ++v8[Player];
  switch ( CVehicle::GetVehicleAppearance(pDestroyedAuto) )
  {
    case APR_CAR:
    case APR_BIKE:
      v9 = 122;
      goto LABEL_20;
    case APR_HELI:
    case APR_PLANE:
      v9 = 124;
      goto LABEL_20;
    case APR_BOAT:
      v9 = 123;
LABEL_20:
      CStats::IncrementStat(v9, 1.0);
      break;
    default:
      break;
  }
  v10 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v10 = CDarkel::Status == 1;
  if ( v10 )
  {
    if ( pDestroyedAuto->m_nModelIndex == 432 )
    {
      v11 = 209;
    }
    else if ( CVehicle::IsLawEnforcementVehicle(pDestroyedAuto) )
    {
      v11 = 208;
    }
    else
    {
      v11 = 207;
    }
    sub_194CA0(v11, 1.0);
  }
}

//----- (00304574) --------------------------------------------------------
bool __fastcall CDarkel::ThisVehicleShouldBeKilledForFrenzy(const CVehicle *pVeh)
{
  bool v1; // zf
  int m_nModelIndex; // r3
  bool v4; // r12
  bool v5; // zf

  v1 = CDarkel::Status == 4;
  if ( CDarkel::Status != 4 )
    v1 = CDarkel::Status == 1;
  if ( v1 )
  {
    if ( CDarkel::ModelToKill == -2 )
      return 1;
    m_nModelIndex = pVeh->m_nModelIndex;
    v4 = 1;
    if ( CDarkel::ModelToKill == m_nModelIndex
      || CDarkel::ModelToKill2 == m_nModelIndex
      || CDarkel::ModelToKill3 == m_nModelIndex
      || CDarkel::ModelToKill4 == m_nModelIndex )
    {
      return v4;
    }
    v5 = CDarkel::ModelToKill == -3;
    if ( CDarkel::ModelToKill == -3 )
      v5 = pVeh->m_vehicleType == 9;
    if ( v5 )
      return 1;
  }
  return 0;
}

//----- (003045F0) --------------------------------------------------------
void __fastcall CDarkel::StartFrenzy(
        eWeaponType ArgWeaponType,
        Int32 ArgTimeLimit,
        Int32 NumKillsRequired,
        Int32 ArgModelToKill,
        GxtChar *pArgStartMessage,
        Int32 Arg2ndModelToKill,
        Int32 Arg3rdModelToKill,
        Int32 Arg4thModelToKill,
        bool ArgStandardSoundAndMessages,
        bool bArgNeedHeadShot)
{
  eWeaponType v12; // r4
  char v13; // r8
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v15; // r0
  CPlayerPed *v16; // r4
  CPlayerPed *v17; // r4
  CWeaponInfo *WeaponInfo; // r0
  CPlayerPed *v19; // r0
  CPlayerPed *v20; // r0
  CPlayerPed *v21; // r0
  CPlayerPed *v22; // r0
  CPlayerPed *v23; // r0
  CPlayerPed *v24; // r0
  CPlayerPed *v25; // r4
  CPlayerPed *v26; // r0
  CPlayerPed *v27; // r0
  int32 m_nAmmoTotal; // r4
  CPlayerPed *v29; // r0
  int32 m_nAmmo; // r5
  CPlayerPed *v31; // r0
  char *v32; // r0
  int32 v33; // r4
  CPlayerPed *v34; // r0
  CPlayerPed *v35; // r0
  Int32 v38; // [sp+1Ch] [bp-24h]
  eWeaponType v39; // [sp+20h] [bp-20h]

  CGameLogic::ClearSkip(0);
  v12 = ArgWeaponType;
  if ( ArgWeaponType == WEAPONTYPE_UZI_DRIVEBY )
    v12 = WEAPONTYPE_MICRO_UZI;
  v39 = v12;
  v38 = ArgTimeLimit;
  if ( CGameLogic::IsCoopGameGoingOn() == 1 )
  {
    CDarkel::Status = 4;
    CGameLogic::DoWeaponStuffAtStartOf2PlayerGame(0);
  }
  else
  {
    CDarkel::Status = 1;
  }
  CDarkel::KillsNeeded = NumKillsRequired;
  CDarkel::WeaponType = ArgWeaponType;
  CDarkel::ModelToKill = ArgModelToKill;
  CDarkel::ModelToKill2 = Arg2ndModelToKill;
  CDarkel::ModelToKill3 = Arg3rdModelToKill;
  CDarkel::ModelToKill4 = Arg4thModelToKill;
  CDarkel::pStartMessage = pArgStartMessage;
  v13 = 0;
  if ( CText::Get(&TheText, "PAGE_00") == pArgStartMessage )
  {
    CDarkel::pStartMessage = 0;
    v13 = 1;
  }
  CDarkel::bStandardSoundAndMessages = ArgStandardSoundAndMessages;
  CDarkel::bProperKillFrenzy = v13;
  CDarkel::bNeedHeadShot = bArgNeedHeadShot;
  CDarkel::TimeLimit = v38;
  CDarkel::TimeOfFrenzyStart = CTimer::m_snTimeInMilliseconds;
  CDarkel::PreviousTime = v38 / 1000;
  if ( v12 <= WEAPONTYPE_PARACHUTE )
  {
    PlayerPed = FindPlayerPed(-1);
    CDarkel::InterruptedWeaponTypeSelected = PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType;
    v15 = FindPlayerPed(-1);
    CPed::RemoveWeaponAnims(v15, CDarkel::InterruptedWeaponTypeSelected, -1000.0);
    v16 = FindPlayerPed(-1);
    CDarkel::InterruptedWeaponType = v16->m_WeaponSlots[CWeaponInfo::GetWeaponInfo(v39, 1)->m_nWeaponSlot].m_eWeaponType;
    v17 = FindPlayerPed(-1);
    CDarkel::AmmoInterruptedWeapon = v17->m_WeaponSlots[CWeaponInfo::GetWeaponInfo(v39, 1)->m_nWeaponSlot].m_nAmmoTotal;
    if ( CDarkel::InterruptedWeaponType )
    {
      WeaponInfo = CWeaponInfo::GetWeaponInfo(CDarkel::InterruptedWeaponType, 1);
      CBaseModelInfo::AddRef(CModelInfo::ms_modelInfoPtrs[WeaponInfo->m_modelId]);
    }
    if ( FindPlayerPed(0) )
    {
      v19 = FindPlayerPed(0);
      CPed::GiveWeapon(v19, v39, 0x7530u, 1);
      v20 = FindPlayerPed(0);
      CPed::SetCurrentWeapon(v20, v39);
      v21 = FindPlayerPed(0);
      CPlayerPed::MakeChangesForNewWeapon(v21, v39);
    }
    if ( FindPlayerPed(1) )
    {
      v22 = FindPlayerPed(1);
      CPed::GiveWeapon(v22, v39, 0x7530u, 1);
      v23 = FindPlayerPed(1);
      CPed::SetCurrentWeapon(v23, v39);
      v24 = FindPlayerPed(1);
      CPlayerPed::MakeChangesForNewWeapon(v24, v39);
    }
    if ( FindPlayerVehicle(-1, 0) )
    {
      v25 = FindPlayerPed(-1);
      v26 = FindPlayerPed(-1);
      CPed::SetCurrentWeapon(v25, v26->m_pPlayerData->m_nChosenWeapon);
      v27 = FindPlayerPed(-1);
      m_nAmmoTotal = v27->m_WeaponSlots[v27->m_nCurrentWeapon].m_nAmmoTotal;
      v29 = FindPlayerPed(-1);
      m_nAmmo = CWeaponInfo::GetWeaponInfo(v29->m_WeaponSlots[v29->m_nCurrentWeapon].m_eWeaponType, 1)->m_nAmmo;
      v31 = FindPlayerPed(-1);
      v32 = (char *)v31 + 28 * v31->m_nCurrentWeapon;
      if ( m_nAmmoTotal >= m_nAmmo )
        v33 = CWeaponInfo::GetWeaponInfo(*((eWeaponType *)v32 + 361), 1)->m_nAmmo;
      else
        v33 = *((_DWORD *)v32 + 364);
      v34 = FindPlayerPed(-1);
      v34->m_WeaponSlots[v34->m_nCurrentWeapon].m_nAmmoInClip = v33;
      v35 = FindPlayerPed(-1);
      sub_18B1E4(v35);
    }
  }
}

//----- (00304950) --------------------------------------------------------
void __fastcall CDarkel::ResetModelsKilledByPlayer(Int32 PlayerIndex)
{
  int v1; // r2
  char *v2; // r0

  v1 = 0;
  v2 = (char *)CDarkel::RegisteredKills + 2 * PlayerIndex;
  do
    *(_WORD *)&v2[4 * v1++] = 0;
  while ( v1 != 800 );
}

//----- (00304970) --------------------------------------------------------
Int16 __fastcall CDarkel::QueryModelsKilledByPlayer(Int32 ModelIndex, Int32 PlayerIndex)
{
  return CDarkel::RegisteredKills[ModelIndex][PlayerIndex];
}

//----- (00304984) --------------------------------------------------------
Int32 __fastcall CDarkel::FindTotalPedsKilledByPlayer(Int32 PlayerIndex)
{
  int8x16_t v1; // q8
  int i; // r2
  const __int16 *v3; // r3
  unsigned __int64 v4; // d18
  int32x4_t v5; // q8

  v1 = 0uLL;
  for ( i = 0; i != 792; i += 8 )
  {
    v3 = &CDarkel::RegisteredKills[0][PlayerIndex + i];
    v4 = (unsigned __int64)vld2_s16(v3);
    v1 = vaddw_s16(v1, (int16x4_t)v4);
  }
  v5 = vaddq_s32(v1, vextq_s8(v1, v1, 8u));
  return CDarkel::RegisteredKills[399][PlayerIndex]
       + CDarkel::RegisteredKills[398][PlayerIndex]
       + CDarkel::RegisteredKills[396][PlayerIndex]
       + vaddq_s32(v5, vdupq_lane_s32((int32x2_t)v5.n128_u64[0], 1)).n128_u32[0]
       + CDarkel::RegisteredKills[397][PlayerIndex];
}

//----- (003049E8) --------------------------------------------------------
UInt8 __fastcall CDarkel::CalcFade(UInt32 Time, UInt32 Start, UInt32 End)
{
  bool v3; // cf
  int v4; // r3
  UInt32 v5; // r0

  v3 = Time >= Start;
  LOBYTE(v4) = 0;
  if ( Time >= Start )
    v3 = End >= Time;
  if ( v3 )
  {
    if ( Start + 500 <= Time )
    {
      if ( End - 500 >= Time )
        return -1;
      v5 = End - Time;
    }
    else
    {
      v5 = Time - Start;
    }
    return 255 * v5 / 0x1F4;
  }
  return v4;
}

//----- (00304A30) --------------------------------------------------------
void CEntryExitManager::Init()
{
  CQuadTreeNode *v0; // r0
  CQuadTreeNode *v1; // r0
  CEntryExitPool *v2; // r4
  uint8 *v3; // r0
  uint8 v4; // r1
  int v5; // r0
  int v6; // r1
  CRect v7; // [sp+0h] [bp-18h] BYREF

  *(_QWORD *)&v7.left = 0x453B8000C53B8000LL;
  *(_QWORD *)&v7.right = 0xC53B8000453B8000LL;
  v0 = (CQuadTreeNode *)CQuadTreeNode::operator new(0x28u);
  CQuadTreeNode::CQuadTreeNode(v0, &v7, 4);
  CEntryExitManager::mp_QuadTree = v1;
  CEntryExitManager::ms_exitEnterState = 0;
  CEntryExitManager::ms_bDisabled = 0;
  CEntryExitManager::ms_entryExitStackPosn = 0;
  CEntryExitManager::ms_bBurglaryHousesEnabled = 0;
  v2 = (CEntryExitPool *)operator new(0x14u);
  v2->m_aStorage = (CPool<CEntryExit,CEntryExit>::StorageType *)operator new[](0x6AA4u);
  v3 = (uint8 *)operator new[](0x1C7u);
  v2->m_bOwnsArrays = 1;
  v2->m_aFlags = v3;
  v2->m_nSize = 455;
  v2->m_nFreeIndex = -1;
  v4 = v3[1];
  *v3 = 0x80;
  v3[1] = v4 | 0x80;
  v2->m_aFlags[1] &= 0x80u;
  v5 = -453;
  do
  {
    v2->m_aFlags[v5 + 455] |= 0x80u;
    v6 = (int)&v2->m_aFlags[v5++];
    *(_BYTE *)(v6 + 455) &= 0x80u;
  }
  while ( v5 );
  CEntryExitManager::mp_poolEntryExits = v2;
  v2->m_bDealWithNoMemory = 1;
}
// 304A7E: variable 'v1' is possibly undefined

//----- (00304B38) --------------------------------------------------------
void CEntryExitManager::Shutdown()
{
  CEntryExitPool *v0; // r4
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r5
  uint8 *m_aFlags; // r0
  uint8 **p_m_aFlags; // r5
  void *v6; // r0

  v0 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 60 * m_nSize - 60;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 && &(*v0->m_aStorage)[v3] )
      {
        CQuadTreeNode::DeleteItem(CEntryExitManager::mp_QuadTree, &(*v0->m_aStorage)[v3]);
        v0 = CEntryExitManager::mp_poolEntryExits;
      }
      --v2;
      v3 -= 60;
    }
    while ( v2 != -1 );
  }
  if ( v0 )
  {
    if ( v0->m_nSize >= 1 )
    {
      if ( v0->m_bOwnsArrays )
      {
        if ( v0->m_aStorage )
          operator delete[](v0->m_aStorage);
        p_m_aFlags = &v0->m_aFlags;
        m_aFlags = v0->m_aFlags;
        if ( m_aFlags )
          operator delete[](m_aFlags);
      }
      else
      {
        p_m_aFlags = &v0->m_aFlags;
      }
      v0->m_aStorage = 0;
      *p_m_aFlags = 0;
    }
    operator delete(v0);
  }
  CEntryExitManager::mp_poolEntryExits = 0;
  if ( CEntryExitManager::mp_QuadTree )
  {
    CQuadTreeNode::~CQuadTreeNode(CEntryExitManager::mp_QuadTree);
    CQuadTreeNode::operator delete(v6);
  }
  CEntryExitManager::ms_entryExitStackPosn = 0;
  CEntryExitManager::mp_QuadTree = 0;
}
// 304BD8: variable 'v6' is possibly undefined

//----- (00304C10) --------------------------------------------------------
void CEntryExitManager::ShutdownForRestart()
{
  CEntryExitPool *v0; // r0
  int32 m_nSize; // r1
  int v2; // r6
  int v3; // r5
  CPool<CEntryExit,CEntryExit>::StorageType *m_aStorage; // r0
  int v5; // r1
  uint8 *v6; // r8
  CEntryExitPool *v7; // r0
  int v8; // r1
  int32 v9; // r2
  int v10; // r1
  int v11; // r2
  int i; // r1
  CPool<CEntryExit,CEntryExit>::StorageType *v13; // r0
  __int16 v14; // r6
  bool v15; // zf
  int32 v16; // r0
  uint8 v17; // r1
  CEntity **v18; // r3

  v0 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 60 * m_nSize - 12;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        m_aStorage = v0->m_aStorage;
        if ( &(*m_aStorage)[v3] != (uint8 *)&word_30 )
        {
          v5 = *(__int16 *)&(*m_aStorage)[v3];
          *(_WORD *)&(*m_aStorage)[v3] = v5 | 0x4000;
          if ( v5 <= -1 && (CEntryExitManager::mp_poolEntryExits->m_aFlags[v2] & 0x80u) == 0 )
          {
            v6 = &(*CEntryExitManager::mp_poolEntryExits->m_aStorage)[v3 - 48];
            CQuadTreeNode::DeleteItem(CEntryExitManager::mp_QuadTree, v6);
            v7 = CEntryExitManager::mp_poolEntryExits;
            v8 = -286331153 * ((v6 - (uint8 *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
            CEntryExitManager::mp_poolEntryExits->m_aFlags[v8] = CEntryExitManager::mp_poolEntryExits->m_aFlags[-286331153 * ((v6 - (uint8 *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2)] | 0x80;
            if ( v8 < v7->m_nFreeIndex )
              v7->m_nFreeIndex = v8;
          }
        }
      }
      v0 = CEntryExitManager::mp_poolEntryExits;
      --v2;
      v3 -= 60;
    }
    while ( v2 != -1 );
    v9 = CEntryExitManager::mp_poolEntryExits->m_nSize;
    CEntryExitManager::ms_bBurglaryHousesEnabled = 0;
    if ( v9 )
    {
      v10 = 15 * v9;
      v11 = v9 - 1;
      for ( i = 4 * v10 - 12; ; i -= 60 )
      {
        if ( (v0->m_aFlags[v11] & 0x80u) == 0 )
        {
          v13 = v0->m_aStorage;
          v14 = (_WORD)v13 + i;
          v15 = &(*v13)[i] == (uint8 *)&word_30;
          if ( &(*v13)[i] != (uint8 *)&word_30 )
          {
            v14 = *(_WORD *)&(*v13)[i];
            v15 = (v14 & 0x1000) == 0;
          }
          if ( !v15 )
            *(_WORD *)&(*v13)[i] = v14 & 0xBFFF;
        }
        if ( !v11 )
          break;
        v0 = CEntryExitManager::mp_poolEntryExits;
        --v11;
      }
    }
  }
  else
  {
    CEntryExitManager::ms_bBurglaryHousesEnabled = 0;
  }
  if ( CEntryExitManager::mp_Active )
  {
    v16 = CEntryExitManager::ms_numVisibleEntities;
    v15 = CEntryExitManager::ms_numVisibleEntities-- == 0;
    if ( !v15 )
    {
      v17 = CEntryExitManager::ms_oldAreaCode;
      do
      {
        v18 = &CEntryExitManager::ms_visibleEntityList[v16--];
        (*(v18 - 1))->m_areaCode = v17;
      }
      while ( v16 );
      CEntryExitManager::ms_numVisibleEntities = -1;
    }
    CEntryExitManager::mp_Active = 0;
    CEntryExitManager::ms_exitEnterState = 0;
  }
  CEntryExitManager::ms_entryExitStackPosn = 0;
  CEntryExitManager::ms_bDisabled = 0;
}
// 30: using guessed type __int16 word_30;

//----- (00304DD0) --------------------------------------------------------
void __fastcall CEntryExitManager::DeleteOne(int32 index)
{
  uint8 *v1; // r4
  CEntryExitPool *v2; // r0
  int v3; // r1

  if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[index] & 0x80u) == 0 )
  {
    v1 = CEntryExitManager::mp_poolEntryExits->m_aStorage[index];
    CQuadTreeNode::DeleteItem(CEntryExitManager::mp_QuadTree, v1);
    v2 = CEntryExitManager::mp_poolEntryExits;
    v3 = -286331153 * ((v1 - (uint8 *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
    CEntryExitManager::mp_poolEntryExits->m_aFlags[v3] = CEntryExitManager::mp_poolEntryExits->m_aFlags[-286331153 * ((v1 - (uint8 *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2)] | 0x80;
    if ( v3 < v2->m_nFreeIndex )
      v2->m_nFreeIndex = v3;
  }
}

//----- (00304E3C) --------------------------------------------------------
void __fastcall CEntryExitManager::EnableBurglaryHouses(bool bEnable)
{
  __int16 v1; // lr
  CEntryExitPool *v2; // r3
  int32 m_nSize; // r2
  int v4; // r12
  int v5; // r2
  int i; // r4
  CPool<CEntryExit,CEntryExit>::StorageType *m_aStorage; // r3
  bool v8; // zf
  __int16 v9; // r1

  v2 = CEntryExitManager::mp_poolEntryExits;
  CEntryExitManager::ms_bBurglaryHousesEnabled = bEnable;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize )
  {
    v4 = 15 * m_nSize;
    v5 = m_nSize - 1;
    for ( i = 4 * v4 - 12; ; i -= 60 )
    {
      if ( (v2->m_aFlags[v5] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v8 = &(*m_aStorage)[i] == (uint8 *)&word_30;
        if ( &(*m_aStorage)[i] != (uint8 *)&word_30 )
        {
          v1 = *(_WORD *)&(*m_aStorage)[i];
          v8 = (v1 & 0x1000) == 0;
        }
        if ( !v8 )
        {
          v9 = v1 & 0xBFFF;
          if ( bEnable )
            v9 = v1 | 0x4000;
          *(_WORD *)&(*m_aStorage)[i] = v9;
        }
      }
      if ( !v5 )
        break;
      --v5;
      v2 = CEntryExitManager::mp_poolEntryExits;
    }
  }
}
// 304E94: variable 'v1' is possibly undefined
// 30: using guessed type __int16 word_30;

//----- (00304EB4) --------------------------------------------------------
void CEntryExitManager::ResetAreaCodeForVisibleObjects()
{
  int32 v0; // r0
  uint8 v2; // r1
  CEntity **v3; // r3

  v0 = CEntryExitManager::ms_numVisibleEntities;
  if ( CEntryExitManager::ms_numVisibleEntities-- != 0 )
  {
    v2 = CEntryExitManager::ms_oldAreaCode;
    do
    {
      v3 = &CEntryExitManager::ms_visibleEntityList[v0--];
      (*(v3 - 1))->m_areaCode = v2;
    }
    while ( v0 );
    CEntryExitManager::ms_numVisibleEntities = -1;
  }
}

//----- (00304F10) --------------------------------------------------------
void CEntryExitManager::Update()
{
  int v0; // r8
  CSimpleTransform *p_tx; // r1
  float32x4_t v2; // q8
  float32x4_t v3; // q2
  CPtrNode *i; // r5
  u_native m_pVoid; // r6
  int v6; // r0
  float v7; // s2
  float v8; // s6
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  CPlayerPed *PlayerPed; // r9
  CMatrix *v13; // r0
  CSimpleTransform *v14; // r1
  float z; // r0
  __int64 v16; // d16
  CVehicle *m_pMyVehicle; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *v19; // r2
  CPtrNode *m_pHead; // r4
  int v21; // r5
  CEntryExit *v22; // r6
  int32 v23; // r2
  CVector posn; // [sp+20h] [bp-68h] BYREF
  CRect bb; // [sp+30h] [bp-58h] BYREF
  CPtrListSingleLink Matches; // [sp+44h] [bp-44h] BYREF

  if ( CCutsceneMgr::ms_cutsceneProcessing || CPad::GetPad(0)->DisablePlayerControls || CGameLogic::IsCoopGameGoingOn() )
  {
    v0 = 1;
  }
  else
  {
    v0 = CEntryExitManager::ms_bDisabled;
    if ( CEntryExitManager::ms_bDisabled )
      v0 = 1;
  }
  if ( !CEntryExitManager::ms_exitEnterState )
  {
    Matches.m_pHead = 0;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v2.n128_u64[0] = 0x41F00000C1F00000LL;
    v2.n128_u64[1] = 0xC1F0000041F00000LL;
    v3.n128_f32[1] = (float)(TheCamera.m_cameraMatrix.yy * 30.0) + p_tx->m_translate.y;
    v3.n128_f32[0] = (float)(TheCamera.m_cameraMatrix.xy * 30.0) + p_tx->m_translate.x;
    v3.n128_f32[2] = v3.n128_f32[0];
    v3.n128_f32[3] = v3.n128_f32[1];
    bb = (CRect)vaddq_f32(v3, v2);
    CQuadTreeNode::GetAllMatching(CEntryExitManager::mp_QuadTree, &bb, &Matches);
    for ( i = Matches.m_pHead; i; i = i->m_pNext )
    {
      m_pVoid = (u_native)i->m_pVoid;
      if ( (*((_BYTE *)i->m_pVoid + 49) & 0x40) != 0 )
      {
        v6 = *(unsigned __int8 *)(m_pVoid + 50);
        if ( *(_DWORD *)(m_pVoid + 56) )
        {
          if ( CGame::currArea == v6 )
            goto LABEL_14;
        }
        else if ( CGame::currArea != v6 )
        {
LABEL_14:
          v7 = *(float *)(m_pVoid + 12);
          v8 = *(float *)(m_pVoid + 20);
          posn.x = (float)(*(float *)(m_pVoid + 8) + *(float *)(m_pVoid + 16)) * 0.5;
          posn.y = (float)(v7 + v8) * 0.5;
          posn.z = *(RwReal *)(m_pVoid + 24);
          if ( !(!CCamera::IsSphereVisible(&TheCamera, &posn, 1.0) | v0)
            && CClock::GetIsTimeInRange(*(_BYTE *)(m_pVoid + 52), *(_BYTE *)(m_pVoid + 53)) )
          {
            p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              p_m_transform = &TheCamera.m_transform;
            v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&posn.x, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
            v11 = vmul_f32(v10, v10).n64_u64[0];
            if ( (float)((float)(*(float *)&v11 + *((float *)&v11 + 1)) + 0.0) < 1600.0 )
            {
              posn.z = posn.z + 1.0;
              C3dMarkers::PlaceMarkerCone(m_pVoid, &posn, 2.0, 0xFFu, 0xFFu, 0, 0xFFu, 0x400u, 1.0, 5, 0);
            }
          }
        }
      }
    }
    CPtrListSingleLink::Flush(&Matches);
  }
  PlayerPed = FindPlayerPed(-1);
  if ( CEntryExitManager::mp_Active )
  {
    if ( CEntryExit::TransitionFinished(CEntryExitManager::mp_Active, PlayerPed) )
      CEntryExitManager::mp_Active = 0;
  }
  else
  {
    Matches.m_pHead = 0;
    if ( *((unsigned __int8 *)&PlayerPed->m_nPedFlags + 1) << 31 )
    {
      m_pMyVehicle = PlayerPed->m_pMyVehicle;
      m_pMat = m_pMyVehicle->m_pMat;
      v19 = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        v19 = &m_pMyVehicle->m_transform;
      v16 = *(_QWORD *)&v19->m_translate.x;
      z = v19->m_translate.z;
    }
    else
    {
      v13 = PlayerPed->m_pMat;
      v14 = (CSimpleTransform *)&v13->tx;
      if ( !v13 )
        v14 = &PlayerPed->m_transform;
      z = v14->m_translate.z;
      v16 = *(_QWORD *)&v14->m_translate.x;
    }
    bb.right = z;
    *(_QWORD *)&bb.left = v16;
    *(_QWORD *)&posn.x = v16;
    CQuadTreeNode::GetAllMatching(CEntryExitManager::mp_QuadTree, (const CVector2D *)&posn, &Matches);
    m_pHead = Matches.m_pHead;
    if ( Matches.m_pHead )
    {
      v21 = 0;
      do
      {
        v22 = (CEntryExit *)m_pHead->m_pVoid;
        if ( CEntryExit::IsInArea((CEntryExit *)m_pHead->m_pVoid, (const CVector *)&bb) )
        {
          if ( ((v22->flags & 0x4000) == 0) | v0 )
          {
            v21 |= (unsigned __int16)(v22->flags & 0x4000) >> 14;
          }
          else
          {
            if ( CEntryExit::TransitionStarted(v22, PlayerPed) )
            {
              CEntryExitManager::mp_Active = v22;
              goto LABEL_44;
            }
            v21 = 1;
          }
        }
        m_pHead = m_pHead->m_pNext;
      }
      while ( m_pHead );
      if ( v21 << 31 )
        goto LABEL_44;
    }
    v23 = 0;
    if ( CEntryExitManager::ms_exitEnterState == 3 )
      v23 = 4;
    CEntryExitManager::ms_exitEnterState = v23;
LABEL_44:
    CPtrListSingleLink::Flush(&Matches);
  }
}

//----- (00305250) --------------------------------------------------------
bool __fastcall CEntryExit::TransitionFinished(CEntryExit *this, CPed *pPed)
{
  float spawnz; // r0
  CEntity *EntityThatThisPedIsHolding; // r0
  bool v6; // zf
  CPedGroup *v7; // r6
  CEventAreaCodes *v8; // r5
  GxtChar *v9; // r0
  bool v10; // r4
  CVehicle *m_pMyVehicle; // r1
  CEntryExit *v12; // r0
  CEntryExit *pLink; // r1
  int32 v14; // r0
  int spawny_low; // r3
  float v16; // r6
  float spawnrot; // r1
  int32 ObjectsInFrustum; // r5
  CPlayerPed *PlayerPed; // r0
  int32 v20; // r1
  int v21; // r6
  int v22; // r2
  CEntity **v23; // r3
  CEntity *v24; // r5
  CEntity *v25; // r5
  CPedGroup *PedsGroup; // r5
  CEventAreaCodes *v27; // r4
  CPad *Pad; // r0
  RwReal y; // r1
  RwReal z; // r0
  CMatrix *m_pMat; // r3
  RwReal *p_tz; // r1
  int32 v33; // r0
  uint8 v34; // r1
  CEntity **v35; // r3
  RwReal FarClipForCoors; // r0
  int v37; // r3
  float v38; // r6
  float v39; // r1
  CMatrix *v40; // r0
  float v41; // s0
  CVehicle *v42; // r6
  RwReal x; // r5
  RwReal v44; // r10
  float v45; // s16
  float v46; // r0
  CTask *v47; // r0
  CMatrix *v48; // r1
  CSimpleTransform *p_tx; // r0
  uint16 flags; // r0
  CEntryExit *v51; // r0
  CEntryExit *v52; // r0
  signed __int16 v53; // r1
  int v54; // r0
  uint8 *v55; // r4
  CEntryExitPool *v56; // r0
  int v57; // r1
  CTaskComplexFacial *TaskSecondary; // r0
  CEventGroupEvent v60; // [sp+8h] [bp-40h] BYREF
  CVector posn; // [sp+1Ch] [bp-2Ch] BYREF

  spawnz = CEntryExit::ms_spawnPoint->spawnz;
  *(_QWORD *)&posn.x = *(_QWORD *)&CEntryExit::ms_spawnPoint->spawnx;
  posn.z = spawnz;
  EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(pPed);
  if ( EntityThatThisPedIsHolding )
    EntityThatThisPedIsHolding->m_areaCode = CEntryExit::ms_spawnPoint->areacode;
  v6 = (this->flags & 0x202) == 0;
  if ( (this->flags & 0x202) == 0 )
    v6 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( v6 )
  {
    CColStore::AddCollisionNeededAtPosn(&posn);
    CIplStore::AddIplsNeededAtPosn(&posn);
    if ( CEntryExit::ms_bWarping )
    {
      CRenderer::m_loadingPriority = 0;
      CStreaming::AddModelsToRequestList(&posn, 0x20u);
      spawny_low = LODWORD(CEntryExit::ms_spawnPoint->spawny);
      v16 = CEntryExit::ms_spawnPoint->spawnz;
      spawnrot = CEntryExit::ms_spawnPoint->spawnrot;
      v60._vptr$CEvent = (int (**)(void))LODWORD(CEntryExit::ms_spawnPoint->spawnx);
      v60.m_iAccumulatedTime = spawny_low;
      *(float *)&v60.m_bIsPersistent = v16;
      CRenderer::RequestObjectsInDirection((const CVector *)&v60, spawnrot, 32);
      CPathFind::SetPathsNeededAtPosition(&ThePaths, &posn);
    }
    switch ( CEntryExitManager::ms_exitEnterState )
    {
      case 2:
        if ( CCamera::GetFading(&TheCamera) )
          return 0;
        CEntryExitManager::ms_exitEnterState = 3;
        break;
      case 1:
        v47 = pPed->m_pPedIntelligence->m_taskManager.m_tasks[3];
        if ( !v47 || (*((int (__fastcall **)(CTask *))v47->_vptr$CTask + 5))(v47) != 932 )
        {
          CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
          CCamera::Fade(&TheCamera, 1.0, 0);
          CEntryExitManager::ms_exitEnterState = 2;
        }
        if ( CEntryExit::ms_spawnPoint->areacode )
        {
          if ( this->cTitle[0] )
          {
            if ( !this->areacode )
              goto LABEL_16;
            if ( CEntryExitManager::ms_entryExitStackPosn < 2 )
              goto LABEL_16;
            if ( CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 1] != CEntryExit::ms_spawnPoint )
              goto LABEL_16;
            this = CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 2];
            if ( this )
              goto LABEL_16;
          }
        }
        return 0;
      case 0:
        ObjectsInFrustum = CRenderer::GetObjectsInFrustum((CEntity **)&PC_Scratch[256], 6.0, 0);
        PlayerPed = FindPlayerPed(-1);
        v20 = CGame::currArea;
        CEntryExitManager::ms_numVisibleEntities = 0;
        if ( ObjectsInFrustum )
        {
          v21 = 0;
          v22 = 1 - ObjectsInFrustum;
          v23 = (CEntity **)&PC_Scratch[256];
          do
          {
            v24 = *v23;
            if ( *v23 != PlayerPed && v20 == v24->m_areaCode )
            {
              CEntryExitManager::ms_visibleEntityList[v21] = v24;
              v25 = *v23;
              CEntryExitManager::ms_numVisibleEntities = ++v21;
              v25->m_areaCode = 13;
            }
            if ( !v22 )
              break;
            ++v22;
            ++v23;
          }
          while ( v21 < 32 );
        }
        CEntryExitManager::ms_exitEnterState = 1;
        CEntryExitManager::ms_oldAreaCode = v20;
        CGame::currArea = CEntryExit::ms_spawnPoint->areacode;
        PedsGroup = CPedGroups::GetPedsGroup(pPed);
        if ( PedsGroup )
        {
          v27 = (CEventAreaCodes *)CEvent::operator new(0x10u);
          CEventAreaCodes::CEventAreaCodes(v27, pPed);
          v27->_vptr$CEvent = (int (**)(void))&off_66719C;
          CEventGroupEvent::CEventGroupEvent(&v60, pPed, v27);
          CPedGroupIntelligence::AddEvent(&PedsGroup->m_intelligence, &v60);
          CEventGroupEvent::~CEventGroupEvent(&v60);
        }
        return 0;
    }
  }
  else
  {
    if ( CEntryExitManager::ms_exitEnterState == 2 )
    {
      if ( !CCamera::GetFading(&TheCamera) )
      {
        v10 = 0;
        CEntryExitManager::ms_exitEnterState = 3;
        return v10;
      }
      return 0;
    }
    if ( !CEntryExitManager::ms_exitEnterState )
    {
      CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
      CCamera::Fade(&TheCamera, 0.5, 0);
      CEntryExitManager::ms_exitEnterState = 2;
      v7 = CPedGroups::GetPedsGroup(pPed);
      if ( v7 )
      {
        v8 = (CEventAreaCodes *)CEvent::operator new(0x10u);
        CEventAreaCodes::CEventAreaCodes(v8, pPed);
        v8->_vptr$CEvent = (int (**)(void))&off_66719C;
        CEventGroupEvent::CEventGroupEvent(&v60, pPed, v8);
        CPedGroupIntelligence::AddEvent(&v7->m_intelligence, &v60);
        CEventGroupEvent::~CEventGroupEvent(&v60);
      }
      if ( CEntryExit::ms_spawnPoint->areacode )
      {
        if ( this->cTitle[0] )
        {
          if ( !this->areacode
            || CEntryExitManager::ms_entryExitStackPosn < 2
            || CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 1] != CEntryExit::ms_spawnPoint
            || (this = CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 2]) != 0 )
          {
LABEL_16:
            v9 = CText::Get(&TheText, this->cTitle);
            CHud::SetZoneName(v9, 1u);
            return 0;
          }
        }
      }
      return 0;
    }
    CGame::currArea = CEntryExit::ms_spawnPoint->areacode;
    CEntryExitManager::ms_numVisibleEntities = 0;
  }
  m_pMyVehicle = pPed->m_pMyVehicle;
  v12 = (CEntryExit *)CGame::currArea;
  pPed->m_areaCode = CGame::currArea;
  if ( m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    m_pMyVehicle->m_areaCode = (unsigned __int8)v12;
  if ( v12 )
    v12 = this;
  pPed->m_pLastEntryExit = v12;
  pLink = this->pLink;
  v14 = CEntryExitManager::ms_entryExitStackPosn;
  if ( !pLink )
    pLink = this;
  if ( CEntryExitManager::ms_entryExitStackPosn >= 1
    && CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 1] == pLink )
  {
    --CEntryExitManager::ms_entryExitStackPosn;
  }
  else if ( pLink->areacode )
  {
    ++CEntryExitManager::ms_entryExitStackPosn;
    CEntryExitManager::ms_entryExitStack[v14] = this;
  }
  else
  {
    CEntryExitManager::ms_entryExitStackPosn = 0;
  }
  *((_DWORD *)&pPed->m_nPedFlags + 2) |= 0x4000000u;
  Pad = CPad::GetPad(0);
  Pad->DisablePlayerControls &= ~8u;
  CClothes::RebuildPlayerIfNeeded((CPlayerPed *)pPed);
  if ( (this->flags & 0x200) != 0 )
  {
    v10 = 1;
    CEntryExit::ms_spawnPoint->flags &= ~0x2000u;
    return v10;
  }
  y = posn.y;
  z = posn.z;
  m_pMat = TheCamera.m_pMat;
  if ( TheCamera.m_pMat )
  {
    TheCamera.m_pMat->tx = posn.x;
    m_pMat->ty = y;
    p_tz = &m_pMat->tz;
  }
  else
  {
    TheCamera.m_transform.m_translate.x = posn.x;
    TheCamera.m_transform.m_translate.y = posn.y;
    p_tz = &TheCamera.m_transform.m_translate.z;
  }
  *p_tz = z;
  CCamera::RestoreWithJumpCut(&TheCamera);
  CAudioZones::Update(1, posn);
  CWaterLevel::FindNearestWaterAndItsFlow();
  CGarages::CloseHideOutGaragesBeforeSave();
  v33 = CEntryExitManager::ms_numVisibleEntities;
  v6 = CEntryExitManager::ms_numVisibleEntities-- == 0;
  if ( !v6 )
  {
    v34 = CEntryExitManager::ms_oldAreaCode;
    do
    {
      v35 = &CEntryExitManager::ms_visibleEntityList[v33--];
      (*(v35 - 1))->m_areaCode = v34;
    }
    while ( v33 );
    CEntryExitManager::ms_numVisibleEntities = -1;
  }
  InteriorManager_c::SetEntryExitPtr(&g_interiorMan, this);
  CPopulation::RemoveAllRandomPeds();
  CEntryExit::RequestAmbientPeds(this);
  bLoadingScene = 1;
  CStreaming::LoadAllRequestedModels(0);
  bLoadingScene = 0;
  CTimer::Suspend();
  if ( CGame::currArea == AREA_MAIN_MAP )
  {
    FarClipForCoors = CTimeCycle::FindFarClipForCoors(posn);
    RwCameraSetFarClipPlane(TheCamera.m_pRwCamera, FarClipForCoors);
  }
  v37 = LODWORD(CEntryExit::ms_spawnPoint->spawny);
  v38 = CEntryExit::ms_spawnPoint->spawnz;
  v39 = CEntryExit::ms_spawnPoint->spawnrot;
  v60._vptr$CEvent = (int (**)(void))LODWORD(CEntryExit::ms_spawnPoint->spawnx);
  v60.m_iAccumulatedTime = v37;
  *(float *)&v60.m_bIsPersistent = v38;
  CRenderer::RequestObjectsInDirection((const CVector *)&v60, v39, 32);
  CStreaming::LoadScene(&posn);
  CStreaming::LoadAllRequestedModels(0);
  CEntryExit::GenerateAmbientPeds(this, &posn);
  if ( InteriorManager_c::Update(&g_interiorMan) )
  {
    CStreaming::SetLoadVehiclesInLoadScene(0);
    CStreaming::LoadScene(&posn);
    CStreaming::SetLoadVehiclesInLoadScene(1);
  }
  CTimer::Resume();
  CStreaming::ClearFlagForAll(0x20u);
  if ( CEntryExit::ms_spawnPoint->extracol )
    CTimeCycle::StartExtraColour(CEntryExit::ms_spawnPoint->extracol - 1, 0);
  else
    CTimeCycle::StopExtraColour(0);
  CRubbish::SetVisibility(CEntryExit::ms_spawnPoint->flags & 1);
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v42 = pPed->m_pMyVehicle;
    x = posn.x;
    v44 = posn.y;
    v45 = posn.z + -1.0;
    v46 = (*((float (__fastcall **)(CVehicle *))v42->_vptr$CPlaceable + 54))(v42);
    (*((void (__fastcall **)(CVehicle *, RwReal, RwReal, _DWORD, _DWORD))v42->_vptr$CPlaceable + 15))(
      v42,
      COERCE_RWREAL(LODWORD(x)),
      COERCE_RWREAL(LODWORD(v44)),
      v45 + v46,
      0);
    v40 = v42->m_pMat;
    v41 = (float)(CEntryExit::ms_spawnPoint->spawnrot * 3.1416) / 180.0;
    if ( !v40 )
    {
      v42->m_transform.m_heading = v41;
      goto LABEL_82;
    }
    goto LABEL_68;
  }
  CEntryExit::FindValidTeleportPoint(0, &posn);
  (*((void (__fastcall **)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))pPed->_vptr$CPlaceable + 15))(
    pPed,
    LODWORD(posn.x),
    LODWORD(posn.y),
    LODWORD(posn.z),
    0);
  v40 = pPed->m_pMat;
  v41 = (float)(CEntryExit::ms_spawnPoint->spawnrot * 3.1416) / 180.0;
  pPed->m_fDesiredHeading = v41;
  pPed->m_fCurrentHeading = v41;
  if ( v40 )
  {
LABEL_68:
    CMatrix::SetRotateZOnly(v40, v41);
    goto LABEL_82;
  }
  pPed->m_transform.m_heading = v41;
LABEL_82:
  CCamera::Fade(&TheCamera, 1.0, 1);
  v48 = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&v48->tx;
  if ( !v48 )
    p_tx = &pPed->m_transform;
  CTheScripts::ClearSpaceForMissionEntity(&p_tx->m_translate, pPed);
  flags = CEntryExit::ms_spawnPoint->flags;
  if ( (flags & 0x10) != 0 )
  {
    CShopping::RemoveLoadedShop();
  }
  else if ( (flags & 8) != 0 )
  {
    CShopping::LoadShop(this->cTitle);
    if ( this->pLink )
      this->flags |= 0x10u;
  }
  CPopulation::ManageAllPopulation();
  CTheScripts::Process();
  v51 = (CEntryExit *)(HIBYTE(CEntryExit::ms_spawnPoint->flags) << 31);
  if ( v51 )
    CEntryExit::WarpGangWithPlayer(v51, pPed);
  CEntryExit::ProcessStealableObjects(v51, pPed);
  v52 = CEntryExit::ms_spawnPoint;
  v53 = CEntryExit::ms_spawnPoint->flags;
  CEntryExit::ms_spawnPoint->flags = v53 & 0xDFFF;
  if ( v53 <= -1 )
  {
    v54 = -286331153 * (((char *)v52 - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
    if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[v54] & 0x80u) == 0 )
    {
      v55 = &(*CEntryExitManager::mp_poolEntryExits->m_aStorage)[60 * v54];
      CQuadTreeNode::DeleteItem(CEntryExitManager::mp_QuadTree, v55);
      v56 = CEntryExitManager::mp_poolEntryExits;
      v57 = -286331153 * ((v55 - (uint8 *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
      CEntryExitManager::mp_poolEntryExits->m_aFlags[v57] = CEntryExitManager::mp_poolEntryExits->m_aFlags[-286331153 * ((v55 - (uint8 *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2)] | 0x80;
      if ( v57 < v56->m_nFreeIndex )
        v56->m_nFreeIndex = v57;
    }
  }
  TaskSecondary = (CTaskComplexFacial *)CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 3);
  CTaskComplexFacial::StopAll(TaskSecondary);
  v10 = 1;
  CGame::TidyUpMemory(1, 1);
  return v10;
}
// 30599C: variable 'v51' is possibly undefined
// 66719C: using guessed type void *;

//----- (00305B64) --------------------------------------------------------
bool __fastcall CEntryExit::IsInArea(CEntryExit *this, const CVector *posn)
{
  float y; // s0
  float prot; // r1
  float bottom; // s8
  float x; // s0
  float v9; // s4
  float v10; // s18
  float v11; // s2
  float v12; // s0
  CVector v13; // [sp+0h] [bp-88h] BYREF
  CMatrix v14; // [sp+10h] [bp-78h] BYREF
  CVector v; // [sp+58h] [bp-30h] BYREF

  if ( this->prot == 0.0 )
  {
    if ( posn->x >= this->rect.left && posn->x <= this->rect.right )
    {
      y = posn->y;
      if ( y >= this->rect.bottom && y <= this->rect.top && fabsf(posn->z - this->pz) < 1.0 )
        return 1;
    }
  }
  else
  {
    prot = this->prot;
    bottom = this->rect.bottom;
    x = posn->x;
    v9 = (float)(this->rect.top - bottom) * 0.5;
    v10 = this->rect.left + (float)((float)(this->rect.right - this->rect.left) * 0.5);
    v11 = posn->y;
    v.z = posn->z;
    v.y = v11 - (float)(bottom + v9);
    v.x = x - v10;
    v14.m_pRwMat = 0;
    v14.m_owner = 0;
    CMatrix::SetRotateZ(&v14, prot);
    operator*(&v13, &v14, &v);
    v12 = (float)(bottom + v9) + v13.y;
    v.x = v10 + v13.x;
    v.y = v12;
    v.z = v13.z + 0.0;
    if ( (float)(v10 + v13.x) >= this->rect.left
      && (float)(v10 + v13.x) <= this->rect.right
      && v12 >= this->rect.bottom
      && v12 <= this->rect.top
      && fabsf(posn->z - this->pz) < 1.0 )
    {
      CMatrix::~CMatrix(&v14);
      return 1;
    }
    CMatrix::~CMatrix(&v14);
  }
  return 0;
}

//----- (00305D00) --------------------------------------------------------
bool __fastcall CEntryExit::TransitionStarted(CEntryExit *this, CPed *pPed)
{
  bool v4; // nf
  bool result; // r0
  CEntryExit *pLink; // r0
  CEntryExit **p_pLink; // r0
  CVehicle *m_pMyVehicle; // r1
  int32 m_baseVehicleType; // r0
  bool v10; // zf
  uint16 flags; // r1
  bool v12; // zf
  float v13; // s0
  float v14; // s2
  float z; // s20
  float v16; // s18
  float v17; // s22
  float v18; // s24
  float v19; // s26
  int CanPlayerStartMission; // r1
  int m_nPedFlags; // r0
  bool v22; // zf
  float v23; // s0
  CObject *NearestDoor; // r6
  CTaskComplexGotoDoorAndOpen *v25; // r5
  CMatrix *m_pMat; // r0
  float *p_tx; // r1
  float v28; // s6
  RwReal v29; // s0
  CPad *Pad; // r0
  CTaskSimple *v31; // r5
  CTaskComplexGotoDoorAndOpen *v32; // r5
  CEventScriptCommand v33; // [sp+0h] [bp-90h] BYREF
  CVector TargetCoors; // [sp+18h] [bp-78h] BYREF
  CVector CamPosToGoTo; // [sp+24h] [bp-6Ch] BYREF
  CVector v36; // [sp+30h] [bp-60h] BYREF
  CVector target1; // [sp+3Ch] [bp-54h] BYREF

  v4 = (this->flags & 0x4000) != 0;
  result = 0;
  if ( !v4 || CEntryExitManager::ms_exitEnterState )
    return result;
  if ( !CClock::GetIsTimeInRange(this->openTime, this->shutTime) )
    return 0;
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
  {
    if ( (this->flags & 0x800) == 0 )
      goto LABEL_7;
    return 0;
  }
  m_pMyVehicle = pPed->m_pMyVehicle;
  m_baseVehicleType = m_pMyVehicle->m_baseVehicleType;
  v10 = m_baseVehicleType == 9;
  if ( m_baseVehicleType != 9 )
    v10 = m_baseVehicleType == 0;
  if ( !v10 || (m_pMyVehicle->pHandling->mFlags & 8) != 0 )
    return 0;
  flags = this->flags;
  v12 = (flags & 0x20) == 0;
  if ( (flags & 0x20) == 0 )
    v12 = m_baseVehicleType == 0;
  if ( v12 || (flags & 0x40) == 0 && m_baseVehicleType == 9 )
    return 0;
LABEL_7:
  pLink = this->pLink;
  if ( pLink )
  {
    CEntryExit::ms_spawnPoint = this->pLink;
    p_pLink = &pLink->pLink;
  }
  else
  {
    p_pLink = &CEntryExit::ms_spawnPoint;
  }
  *p_pLink = this;
  v13 = this->rect.left + this->rect.right;
  v14 = this->rect.bottom + this->rect.top;
  target1.z = this->pz;
  z = target1.z;
  v16 = v13 * 0.5;
  target1.y = v14 * 0.5;
  target1.x = v13 * 0.5;
  v17 = CEntryExit::ms_spawnPoint->spawnx - (float)(v13 * 0.5);
  v18 = CEntryExit::ms_spawnPoint->spawny - (float)(v14 * 0.5);
  v19 = CEntryExit::ms_spawnPoint->spawnz - target1.z;
  v36.y = v18;
  v36.x = v17;
  v36.z = v19;
  CanPlayerStartMission = CPlayerPed::CanPlayerStartMission((CPlayerPed *)pPed);
  result = 0;
  if ( CanPlayerStartMission )
  {
    this->flags |= 0x2000u;
    CEntryExit::ms_pDoor = 0;
    m_nPedFlags = (int)pPed->m_nPedFlags;
    *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x4000000u;
    v22 = (m_nPedFlags & 0x100) == 0;
    if ( (m_nPedFlags & 0x100) == 0 )
      v22 = (this->flags & 0x202) == 0;
    v23 = sqrtf((float)((float)(v17 * v17) + (float)(v18 * v18)) + (float)(v19 * v19));
    if ( v22 )
    {
      CEntryExit::ms_bWarping = v23 > 10.0;
      CVector::Normalise(&v36);
      NearestDoor = (CObject *)CEntryExitManager::FindNearestDoor(this, 10.0);
      if ( NearestDoor )
      {
        v25 = (CTaskComplexGotoDoorAndOpen *)CTask::operator new(0x38u);
        CTaskComplexGotoDoorAndOpen::CTaskComplexGotoDoorAndOpen(v25, NearestDoor);
        CEventScriptCommand::CEventScriptCommand(&v33, 3, v25, 0);
        CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v33, 0);
        CEntryExit::ms_pDoor = NearestDoor;
        m_pMat = NearestDoor->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &NearestDoor->m_transform.m_translate.x;
        v28 = p_tx[1];
        v29 = *p_tx - target1.x;
        v36.z = 0.0;
        v36.x = v29;
        v36.y = v28 - target1.y;
        CVector::Normalise(&v36);
      }
      else
      {
        if ( CEntryExit::ms_bWarping )
        {
          this->flags |= 2u;
          return 1;
        }
        v32 = (CTaskComplexGotoDoorAndOpen *)CTask::operator new(0x38u);
        *(float *)&v33._vptr$CEvent = (float)(v36.x * 4.0) + v16;
        *(float *)&v33.m_iAccumulatedTime = (float)(v36.y * 4.0) + (float)(v14 * 0.5);
        *(float *)&v33.m_bIsPersistent = (float)(v36.z * 4.0) + z;
        CTaskComplexGotoDoorAndOpen::CTaskComplexGotoDoorAndOpen(v32, &target1, (const CVector *)&v33);
        CEventScriptCommand::CEventScriptCommand(&v33, 3, v32, 0);
        CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v33, 0);
      }
      CEventScriptCommand::~CEventScriptCommand(&v33);
      CamPosToGoTo.y = target1.y - (float)(v36.y * 3.0);
      CamPosToGoTo.x = target1.x - (float)(v36.x * 3.0);
      TargetCoors.y = v36.y + target1.y;
      TargetCoors.x = v36.x + target1.x;
      TargetCoors.z = v36.z + target1.z;
      CamPosToGoTo.z = (float)(target1.z - (float)(v36.z * 3.0)) + 1.0;
      if ( fabsf((float)(v36.x + target1.x) + -2229.0) < 1.0 )
      {
        TargetCoors.y = (float)(v36.y + target1.y) + -0.5;
        TargetCoors.x = (float)(v36.x + target1.x) + 1.875;
      }
      memset(&v33, 0, 12);
      CCamera::SetCamPositionForFixedMode(&TheCamera, &CamPosToGoTo, (const CVector *)&v33);
      CCamera::TakeControlNoEntity(&TheCamera, &TargetCoors, 2, 1);
    }
    else if ( v23 > 10.0 )
    {
      CEntryExit::ms_bWarping = 1;
    }
    Pad = CPad::GetPad(0);
    Pad->DisablePlayerControls |= 8u;
    if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    {
      v31 = (CTaskSimple *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple(v31);
      v31->_vptr$CTask = (int (**)(void))&off_6653E4;
      CEventScriptCommand::CEventScriptCommand(&v33, 3, v31, 0);
      CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v33, 0);
      CEventScriptCommand::~CEventScriptCommand(&v33);
    }
    return 1;
  }
  return result;
}
// 6653E4: using guessed type void *;

//----- (003060D4) --------------------------------------------------------
void __fastcall CEntryExitManager::SetEnabledByName(const unsigned __int8 *p_cName, bool enabled)
{
  _BOOL4 v3; // r8
  CEntryExitPool *v4; // r0
  int32 m_nSize; // r1
  int v6; // r10
  int v7; // r4
  int i; // r5
  CPool<CEntryExit,CEntryExit>::StorageType *m_aStorage; // r6
  __int16 v10; // r0
  __int16 v11; // r1

  v3 = enabled;
  v4 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize >= 1 )
  {
    v6 = m_nSize - 1;
    v7 = 0;
    for ( i = 48; ; i += 60 )
    {
      if ( (v4->m_aFlags[v7] & 0x80u) == 0
        && (m_aStorage = v4->m_aStorage,
            !strncasecmp((const char *)&(*v4->m_aStorage)[i - 48], (const char *)p_cName, 8u)) )
      {
        v10 = *(_WORD *)&(*m_aStorage)[i];
        v11 = v10 & 0xBFFF;
        if ( v3 )
          v11 = v10 | 0x4000;
        *(_WORD *)&(*m_aStorage)[i] = v11;
        if ( v6 == v7 )
          return;
      }
      else if ( v6 == v7 )
      {
        return;
      }
      ++v7;
      v4 = CEntryExitManager::mp_poolEntryExits;
    }
  }
}

//----- (00306150) --------------------------------------------------------
void __fastcall CEntryExitManager::SetEntryExitFlag(const unsigned __int8 *pName, uint32 flag, bool bSet)
{
  __int16 v4; // r10
  CEntryExitPool *v5; // r0
  int32 m_nSize; // r1
  int v7; // r4
  int v8; // r5
  int i; // r6
  CPool<CEntryExit,CEntryExit>::StorageType *m_aStorage; // r9
  __int16 v11; // r0
  __int16 v12; // r1
  _BOOL4 v13; // [sp+8h] [bp-20h]

  v13 = bSet;
  v4 = flag;
  v5 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize >= 1 )
  {
    v7 = m_nSize - 1;
    v8 = 0;
    for ( i = 48; ; i += 60 )
    {
      if ( (v5->m_aFlags[v8] & 0x80u) == 0
        && (m_aStorage = v5->m_aStorage, !strncasecmp((const char *)&(*v5->m_aStorage)[i - 48], (const char *)pName, 8u)) )
      {
        v11 = *(_WORD *)&(*m_aStorage)[i];
        v12 = ~v4 & v11;
        if ( v13 )
          v12 = v11 | v4;
        *(_WORD *)&(*m_aStorage)[i] = v12;
        if ( v7 == v8 )
          return;
      }
      else if ( v7 == v8 )
      {
        return;
      }
      ++v8;
      v5 = CEntryExitManager::mp_poolEntryExits;
    }
  }
}

//----- (003061E0) --------------------------------------------------------
void __fastcall CEntryExitManager::SetEnabled(int32 index, bool enabled)
{
  uint8 *v2; // r0
  __int16 v3; // r2
  __int16 v4; // r3

  v2 = CEntryExitManager::mp_poolEntryExits->m_aStorage[index];
  v3 = *((_WORD *)v2 + 24);
  v4 = v3 & 0xBFFF;
  if ( enabled )
    v4 = v3 | 0x4000;
  *((_WORD *)v2 + 24) = v4;
}

//----- (00306208) --------------------------------------------------------
void __fastcall CEntryExitManager::SetEntryExitFlagWithIndex(const int32 index, uint32 flag, bool bSet)
{
  uint8 *v3; // r0
  bool v4; // zf
  _WORD *v5; // r0
  __int16 v6; // r2
  __int16 v7; // t1
  __int16 v8; // r1

  if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[index] & 0x80u) != 0 )
    v3 = 0;
  else
    v3 = CEntryExitManager::mp_poolEntryExits->m_aStorage[index];
  v4 = bSet;
  v7 = *((_WORD *)v3 + 24);
  v5 = v3 + 48;
  v6 = v7;
  if ( v4 )
    v8 = flag | v6;
  else
    v8 = v6 & ~(_WORD)flag;
  *v5 = v8;
}

//----- (00306244) --------------------------------------------------------
int32 __fastcall CEntryExitManager::AddOne(
        float px,
        float py,
        float pz,
        float prot,
        float wx,
        float wy,
        float wz,
        float spawnx,
        float spawny,
        float spawnz,
        float spawnrot,
        int32 areacode,
        int32 flags,
        int32 extracol,
        int32 openTime,
        int32 shutTime,
        Int32 ArgNumRandomPedsToCreate,
        const unsigned __int8 *p_cTitle)
{
  char v21; // r5
  char v22; // r9
  const unsigned __int8 *v25; // r12
  __int16 v26; // r10
  CEntryExitPool *v27; // r1
  int v28; // r2
  int32 result; // r0
  int32 m_nSize; // r3
  uint8 *m_aFlags; // r4
  int v32; // r6
  int v33; // r8
  char v34; // r0
  float v35; // s0
  float v36; // s17
  float v37; // s0
  int v38; // r9
  int v39; // r0
  float v40; // s2
  bool v41; // fnf
  CEntryExitPool *v42; // r9
  int32 v43; // r6
  uint8 *v44; // r10
  int v45; // r4
  uint8 *v46; // r11
  CPool<CEntryExit,CEntryExit>::StorageType *m_aStorage; // r4
  CRect v48; // [sp+8h] [bp-D0h] BYREF
  CMatrix v49; // [sp+18h] [bp-C0h] BYREF
  CVector v; // [sp+60h] [bp-78h] BYREF
  CVector v51; // [sp+6Ch] [bp-6Ch] BYREF

  v21 = openTime;
  v22 = shutTime;
  v25 = p_cTitle;
  v26 = flags;
  v27 = CEntryExitManager::mp_poolEntryExits;
  v28 = 0;
  result = CEntryExitManager::mp_poolEntryExits->m_nFreeIndex;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  do
  {
    v27->m_nFreeIndex = ++result;
    if ( result == m_nSize )
    {
      result = 0;
      v27->m_nFreeIndex = 0;
      if ( v28 << 31 )
        return result;
      v28 = 1;
    }
    m_aFlags = v27->m_aFlags;
    v32 = (char)m_aFlags[result];
  }
  while ( v32 > -1 );
  m_aFlags[result] = v32 & 0x7F;
  v27->m_aFlags[v27->m_nFreeIndex] = (v27->m_aFlags[v27->m_nFreeIndex] + 1) & 0x7F | v27->m_aFlags[v27->m_nFreeIndex] & 0x80;
  v33 = (int)v27->m_aStorage[v27->m_nFreeIndex];
  if ( !v33 )
    return 0;
  if ( (flags & 0x1000) != 0 )
  {
    v21 = 0;
    v22 = 24;
  }
  if ( (flags & 0x1400) == 1024 )
  {
    v34 = rand();
    v25 = p_cTitle;
    if ( (v34 & 1) != 0 )
    {
      v21 = 0;
      v22 = 0;
    }
  }
  v35 = prot * 3.1416;
  v36 = wx * 0.5;
  v37 = v35 / 180.0;
  if ( (flags & 0x1000) == 0 )
    v26 = flags | 0x4000;
  if ( CEntryExitManager::ms_bBurglaryHousesEnabled )
    v26 = flags | 0x4000;
  *(_WORD *)(v33 + 48) = v26;
  *(float *)(v33 + 44) = spawnrot;
  *(_BYTE *)(v33 + 50) = areacode;
  *(_BYTE *)(v33 + 51) = extracol;
  *(_BYTE *)(v33 + 52) = v21;
  *(_BYTE *)(v33 + 53) = v22;
  *(_BYTE *)(v33 + 54) = ArgNumRandomPedsToCreate;
  *(float *)(v33 + 40) = spawnz + 1.0;
  *(float *)(v33 + 8) = px - v36;
  *(float *)(v33 + 12) = (float)(wy * 0.5) + py;
  *(float *)(v33 + 16) = v36 + px;
  *(float *)(v33 + 20) = py - (float)(wy * 0.5);
  *(float *)(v33 + 24) = pz + 1.0;
  *(float *)(v33 + 28) = v37;
  *(float *)(v33 + 32) = spawnx;
  *(float *)(v33 + 36) = spawny;
  *(_DWORD *)(v33 + 56) = 0;
  if ( v25 )
    strncpy((char *)v33, (const char *)v25, 8u);
  else
    *(_BYTE *)v33 = 0;
  v38 = 0;
  v.z = 0.0;
  v51.x = wx * 0.5;
  v51.z = 0.0;
  v51.y = wy * 0.5;
  v.y = wy * -0.5;
  v.x = wx * -0.5;
  v49.m_pRwMat = 0;
  v49.m_owner = 0;
  CMatrix::SetRotateZ(&v49, prot);
  operator*((CVector *)&v48, &v49, &v);
  v.z = v48.right;
  v.x = v48.left + px;
  v.y = v48.top + py;
  operator*((CVector *)&v48, &v49, &v51);
  v51.z = v48.right;
  v39 = 0;
  v40 = v48.top + py;
  v51.x = v48.left + px;
  v51.y = v48.top + py;
  v41 = v.x < (float)(v48.left + px);
  if ( v.x >= (float)(v48.left + px) )
    v39 = 1;
  v48.left = *(&v.x + (v39 | (2 * v39)));
  v48.right = *(&v.x + (v41 | (2 * v41)));
  v48.bottom = *(&v.y + ((v.y >= v40) | (2 * (v.y >= v40))));
  if ( v.y < v40 )
    v38 = 1;
  v48.top = *(&v.y + (v38 | (2 * v38)));
  CQuadTreeNode::AddItem(CEntryExitManager::mp_QuadTree, (void *)v33, &v48);
  if ( (*(_BYTE *)(v33 + 48) & 4) != 0 )
  {
    v42 = CEntryExitManager::mp_poolEntryExits;
    v43 = CEntryExitManager::mp_poolEntryExits->m_nSize;
    if ( v43 )
    {
      v44 = CEntryExitManager::mp_poolEntryExits->m_aFlags;
      v45 = 60 * v43 - 12;
      while ( 1 )
      {
        if ( (v44[v43 - 1] & 0x80u) == 0 )
        {
          v46 = &(*v42->m_aStorage)[v45];
          if ( v46 != (uint8 *)&word_30
            && (*(_WORD *)&(*v42->m_aStorage)[v45] & 0x4004) == 0x4000
            && !strncasecmp((const char *)v46 - 48, (const char *)v33, 8u) )
          {
            break;
          }
        }
        --v43;
        v45 -= 60;
        if ( !v43 )
          goto LABEL_32;
      }
      *(_DWORD *)(v33 + 56) = v46 - 48;
      if ( !*((_DWORD *)v46 + 2) )
        *((_DWORD *)v46 + 2) = v33;
      *((_WORD *)v46 + 2) = 6144;
    }
  }
LABEL_32:
  m_aStorage = CEntryExitManager::mp_poolEntryExits->m_aStorage;
  CMatrix::~CMatrix(&v49);
  return -286331153 * ((v33 - (int)m_aStorage) >> 2);
}
// 30: using guessed type __int16 word_30;

//----- (003065B4) --------------------------------------------------------
void __fastcall CEntryExitManager::LinkEntryExit(CEntryExit *pEntryExit)
{
  CEntryExitPool *v2; // r9
  int32 m_nSize; // r4
  uint8 *m_aFlags; // r10
  int i; // r6
  uint8 *v6; // r8

  v2 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize )
  {
    m_aFlags = CEntryExitManager::mp_poolEntryExits->m_aFlags;
    for ( i = 60 * m_nSize - 12; ; i -= 60 )
    {
      if ( (m_aFlags[m_nSize - 1] & 0x80u) == 0 )
      {
        v6 = &(*v2->m_aStorage)[i];
        if ( v6 != (uint8 *)&word_30
          && (*(_WORD *)&(*v2->m_aStorage)[i] & 0x4004) == 0x4000
          && !strncasecmp((const char *)v6 - 48, (const char *)pEntryExit, 8u) )
        {
          break;
        }
      }
      if ( !--m_nSize )
        return;
    }
    pEntryExit->pLink = (CEntryExit *)(v6 - 48);
    if ( !*((_DWORD *)v6 + 2) )
      *((_DWORD *)v6 + 2) = pEntryExit;
    *((_WORD *)v6 + 2) = 6144;
  }
}
// 30: using guessed type __int16 word_30;

//----- (0030664C) --------------------------------------------------------
int32 __fastcall CEntryExitManager::GetEntryExitIndex(const unsigned __int8 *pName, uint16 flagsSet, uint16 flagsClear)
{
  int v4; // r9
  int v5; // r11
  CEntryExitPool *v6; // r10
  int32 m_nSize; // r0
  uint8 *m_aFlags; // r4
  int32 v9; // r6
  int i; // r5
  uint8 *v11; // r0
  int v12; // r1
  bool v13; // zf

  v4 = flagsClear;
  v5 = flagsSet;
  v6 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( !m_nSize )
    return -1;
  m_aFlags = CEntryExitManager::mp_poolEntryExits->m_aFlags;
  v9 = m_nSize - 1;
  for ( i = 60 * m_nSize - 12; ; i -= 60 )
  {
    if ( (m_aFlags[v9] & 0x80u) == 0 )
    {
      v11 = &(*v6->m_aStorage)[i];
      if ( v11 != (uint8 *)&word_30 )
      {
        v12 = *(unsigned __int16 *)&(*v6->m_aStorage)[i];
        v13 = (v12 & v5) == v5;
        if ( (v12 & v5) == v5 )
          v13 = (v12 & v4) == 0;
        if ( v13 && !strncasecmp((const char *)v11 - 48, (const char *)pName, 8u) )
          break;
      }
    }
    if ( --v9 == -1 )
      return -1;
  }
  return v9;
}
// 30: using guessed type __int16 word_30;

//----- (003066C4) --------------------------------------------------------
void CEntryExitManager::PostEntryExitsCreation()
{
  CEntryExitPool *v0; // r0
  int32 m_nSize; // r6
  uint8 *m_aFlags; // r4
  int v3; // r11
  int32 v4; // r10
  int v5; // r9

  v0 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize )
  {
    while ( 1 )
    {
      m_aFlags = v0->m_aFlags;
      if ( (m_aFlags[--m_nSize] & 0x80u) == 0
        && (v3 = (int)v0->m_aStorage[m_nSize]) != 0
        && (*(_BYTE *)(v3 + 48) & 4) != 0
        && !*(_DWORD *)(v3 + 56)
        && (v4 = v0->m_nSize) != 0 )
      {
        v5 = (int)&v0->m_aStorage[v4 - 1][48];
        while ( (m_aFlags[v4 - 1] & 0x80u) != 0
             || v5 == 48
             || (*(_WORD *)v5 & 0x4004) != 0x4000
             || strncasecmp((const char *)(v5 - 48), (const char *)v3, 8u) )
        {
          --v4;
          v5 -= 60;
          if ( !v4 )
            goto LABEL_3;
        }
        *(_DWORD *)(v3 + 56) = v5 - 48;
        if ( !*(_DWORD *)(v5 + 8) )
          *(_DWORD *)(v5 + 8) = v3;
        *(_WORD *)(v5 + 4) = 6144;
        if ( !m_nSize )
          return;
      }
      else
      {
LABEL_3:
        if ( !m_nSize )
          return;
      }
      v0 = CEntryExitManager::mp_poolEntryExits;
    }
  }
}

//----- (003067B0) --------------------------------------------------------
void __fastcall CEntryExitManager::GotoEntryExit(CEntryExit *pEE)
{
  char v2; // r0
  CVector v3; // [sp+4h] [bp-1Ch] BYREF

  v2 = `guard variable for'CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE;
  __dmb(0xBu);
  if ( (v2 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE) )
  {
    *(_QWORD *)&CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.rect.left = 0xC974240049742400LL;
    *(_QWORD *)&CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.rect.right = 0x49742400C9742400LL;
    _cxa_guard_release((__guard *)&`guard variable for'CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE);
  }
  if ( !CEntryExitManager::mp_Active )
  {
    CEntryExitManager::ms_entryExitStackPosn = 0;
    FindPlayerCoors(&v3, 0);
    CEntryExit::ms_pDoor = 0;
    CEntryExit::ms_spawnPoint = pEE;
    CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.extracol = 0;
    CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.areacode = CGame::currArea;
    CEntryExit::ms_bWarping = 1;
    *(CVector *)&CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.spawnx = v3;
    strncpy((char *)&CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE, (const char *)pEE, 7u);
    CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.flags = 16386;
    CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.flags = (2 * pEE->flags) & 0x10 | 0x4002;
    pEE->pLink = &CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE;
    CEntryExitManager::mp_Active = &CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE;
    CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE.pLink = pEE;
  }
}
// 7A1F04: using guessed type char `guard variable for'CEntryExitManager::GotoEntryExit(CEntryExit *)::gDummyEE;

//----- (003068C0) --------------------------------------------------------
void __fastcall CEntryExitManager::GotoEntryExitVC(const unsigned __int8 *pName)
{
  CEntryExitPool *v2; // r9
  int32 m_nSize; // r4
  uint8 *m_aFlags; // r10
  int i; // r6
  uint8 *v6; // r0
  CEntryExit *v7; // r5

  v2 = CEntryExitManager::mp_poolEntryExits;
  m_nSize = CEntryExitManager::mp_poolEntryExits->m_nSize;
  if ( m_nSize )
  {
    m_aFlags = CEntryExitManager::mp_poolEntryExits->m_aFlags;
    for ( i = 60 * m_nSize - 12; ; i -= 60 )
    {
      if ( (m_aFlags[m_nSize - 1] & 0x80u) == 0 )
      {
        v6 = &(*v2->m_aStorage)[i];
        if ( v6 != (uint8 *)&word_30 && ((*v2->m_aStorage)[i] & 4) == 0 )
        {
          v7 = (CEntryExit *)(v6 - 48);
          if ( !strncasecmp((const char *)v6 - 48, (const char *)pName, 8u) )
            break;
        }
      }
      if ( !--m_nSize )
        return;
    }
    CEntryExitManager::GotoEntryExit(v7);
  }
}
// 30: using guessed type __int16 word_30;

//----- (00306934) --------------------------------------------------------
void CEntryExitManager::GotoNextEntryExit()
{
  CEntryExitPool *v0; // r0
  int v1; // r1
  __int64 v2; // kr00_8
  int32 m_nSize; // r2
  int v4; // r4
  CEntryExit *v5; // r0

  if ( gpEntryExitCycle )
  {
    v0 = CEntryExitManager::mp_poolEntryExits;
    v1 = -286331153 * (((char *)gpEntryExitCycle - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
  }
  else
  {
    v1 = 0;
    v0 = CEntryExitManager::mp_poolEntryExits;
  }
  v2 = *(_QWORD *)&v0->m_aStorage;
  m_nSize = v0->m_nSize;
  while ( 1 )
  {
    if ( ++v1 == m_nSize )
      v1 = 0;
    if ( *(char *)(HIDWORD(v2) + v1) >= 0 )
    {
      v4 = v2 + 60 * v1;
      if ( v4 )
      {
        if ( (*(_BYTE *)(v4 + 48) & 4) != 0 )
        {
          v5 = *(CEntryExit **)(v4 + 56);
          if ( v5 )
            break;
        }
      }
    }
  }
  CEntryExitManager::GotoEntryExit(v5);
  gpEntryExitCycle = (CEntryExit *)v4;
}

//----- (003069B0) --------------------------------------------------------
void CEntryExitManager::GotoPreviousEntryExit()
{
  CEntryExitPool *v0; // r12
  int m_nSize; // r2
  __int64 v2; // kr00_8
  int v3; // r4
  CEntryExit *v4; // r0

  if ( gpEntryExitCycle )
  {
    v0 = CEntryExitManager::mp_poolEntryExits;
    m_nSize = -286331153 * (((char *)gpEntryExitCycle - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
  }
  else
  {
    m_nSize = 0;
    v0 = CEntryExitManager::mp_poolEntryExits;
  }
  v2 = *(_QWORD *)&v0->m_aStorage;
  while ( 1 )
  {
    if ( !m_nSize )
      m_nSize = v0->m_nSize;
    --m_nSize;
    if ( *(char *)(HIDWORD(v2) + m_nSize) >= 0 )
    {
      v3 = v2 + 60 * m_nSize;
      if ( v3 )
      {
        if ( (*(_BYTE *)(v3 + 48) & 4) != 0 )
        {
          v4 = *(CEntryExit **)(v3 + 56);
          if ( v4 )
            break;
        }
      }
    }
  }
  CEntryExitManager::GotoEntryExit(v4);
  gpEntryExitCycle = (CEntryExit *)v3;
}

//----- (00306A34) --------------------------------------------------------
int32 CEntryExitManager::WeAreInInteriorTransition()
{
  int32 result; // r0

  result = CEntryExitManager::ms_exitEnterState;
  if ( CEntryExitManager::ms_exitEnterState )
    return 1;
  return result;
}

//----- (00306A48) --------------------------------------------------------
void __fastcall CEntryExitManager::AddEntryExitToStack(CEntryExit *pEE)
{
  CEntryExit *pLink; // r2
  int32 v2; // r1

  pLink = pEE->pLink;
  v2 = CEntryExitManager::ms_entryExitStackPosn;
  if ( !pLink )
    pLink = pEE;
  if ( CEntryExitManager::ms_entryExitStackPosn >= 1
    && CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 1] == pLink )
  {
    --CEntryExitManager::ms_entryExitStackPosn;
  }
  else if ( pLink->areacode )
  {
    ++CEntryExitManager::ms_entryExitStackPosn;
    CEntryExitManager::ms_entryExitStack[v2] = pEE;
  }
  else
  {
    CEntryExitManager::ms_entryExitStackPosn = 0;
  }
}

//----- (00306AC0) --------------------------------------------------------
void __fastcall CEntryExitManager::GetPositionRelativeToOutsideWorld(CVector *posn)
{
  int32 v1; // lr
  CEntryExit **v2; // r2
  int v3; // r2
  int v4; // r3
  RwReal v5; // s10
  RwReal v6; // s2
  RwReal v7; // s4
  RwReal v8; // s4
  RwReal v9; // s6

  v1 = CEntryExitManager::ms_entryExitStackPosn;
  while ( v1 )
  {
    v2 = &CEntryExitManager::ms_entryExitStack[v1--];
    v3 = (int)*(v2 - 1);
    v4 = *(_DWORD *)(v3 + 56);
    if ( !v4 )
      v4 = v3;
    if ( *(_BYTE *)(v4 + 50) )
    {
      v5 = *(float *)(v3 + 24) + posn->z;
      v6 = posn->x + (float)((float)(*(float *)(v3 + 8) + *(float *)(v3 + 16)) * 0.5);
      v7 = (float)((float)(*(float *)(v3 + 12) + *(float *)(v3 + 20)) * 0.5) + posn->y;
      posn->x = v6;
      posn->y = v7;
      posn->z = v5;
      v8 = v7 - *(float *)(v4 + 36);
      v9 = v5 - *(float *)(v4 + 40);
      posn->x = v6 - *(float *)(v4 + 32);
      posn->y = v8;
      posn->z = v9;
    }
  }
}

//----- (00306B78) --------------------------------------------------------
void __fastcall CEntryExit::GetPositionRelativeToOutsideWorld(CEntryExit *this, CVector *posn)
{
  CEntryExit *pLink; // r2
  RwReal v3; // s8
  RwReal v4; // s0
  RwReal v5; // s2
  RwReal v6; // s2
  RwReal v7; // s4

  pLink = this->pLink;
  if ( !pLink )
    pLink = this;
  if ( pLink->areacode )
  {
    v3 = this->pz + posn->z;
    v4 = posn->x + (float)((float)(this->rect.left + this->rect.right) * 0.5);
    v5 = (float)((float)(this->rect.top + this->rect.bottom) * 0.5) + posn->y;
    posn->x = v4;
    posn->y = v5;
    posn->z = v3;
    v6 = v5 - pLink->spawny;
    v7 = v3 - pLink->spawnz;
    posn->x = v4 - pLink->spawnx;
    posn->y = v6;
    posn->z = v7;
  }
}

//----- (00306BFC) --------------------------------------------------------
CEntity *__fastcall CEntryExitManager::FindNearestDoor(const CEntryExit *entryExit, float range)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float top; // s2
  float bottom; // s6
  CEntity *v7; // r4
  Int16 v8; // r0
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r5
  float32x2_t v11; // d17
  unsigned __int64 v12; // d3
  bool v13; // nf
  CEntity *v14; // r2
  CVector Coors; // [sp+20h] [bp-1B0h] BYREF
  Int16 pNum; // [sp+2Eh] [bp-1A2h] BYREF
  CEntity *v18[104]; // [sp+30h] [bp-1A0h] BYREF

  top = entryExit->rect.top;
  bottom = entryExit->rect.bottom;
  v7 = 0;
  Coors.x = (float)(entryExit->rect.left + entryExit->rect.right) * 0.5;
  Coors.y = (float)(top + bottom) * 0.5;
  Coors.z = entryExit->pz;
  CWorld::FindObjectsInRange(&Coors, range, 0, &pNum, 100, v18, 0, 0, 0, 1, 0);
  v8 = pNum;
  v2.n64_f32[0] = range;
  while ( v8 )
  {
    v14 = v18[--v8];
    if ( (LOBYTE(v14[1].m_transform.m_translate.y) & 0x20) != 0 )
    {
      pNum = v8;
      m_pMat = v14->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v14->m_transform;
      v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
      v12 = vmul_f32(v11, v11).n64_u64[0];
      v3.n64_f32[0] = sqrtf(
                        (float)((float)((float)(Coors.x - p_tx->m_translate.x) * (float)(Coors.x - p_tx->m_translate.x))
                              + *(float *)&v12)
                      + *((float *)&v12 + 1));
      v13 = v3.n64_f32[0] < v2.n64_f32[0];
      v2.n64_u64[0] = vmin_f32(v3, v2).n64_u64[0];
      if ( v13 )
        v7 = v14;
    }
  }
  return v7;
}
// 306CAE: variable 'v3' is possibly undefined
// 306CAE: variable 'v2' is possibly undefined

//----- (00306CDC) --------------------------------------------------------
CEntryExit *__fastcall CEntryExit::GetEntryExitToDisplayNameOf(CEntryExit *this)
{
  bool v1; // zf

  v1 = CEntryExit::ms_spawnPoint->areacode == 0;
  if ( CEntryExit::ms_spawnPoint->areacode )
    v1 = this->cTitle[0] == 0;
  if ( v1 )
    return 0;
  if ( this->areacode
    && CEntryExitManager::ms_entryExitStackPosn >= 2
    && CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 1] == CEntryExit::ms_spawnPoint )
  {
    return CEntryExitManager::ms_entryExitStack[CEntryExitManager::ms_entryExitStackPosn - 2];
  }
  return this;
}

//----- (00306D3C) --------------------------------------------------------
void __fastcall CEntryExit::RequestObjectsInFrustum(CEntryExit *this)
{
  float spawnz; // r1
  CVector posn; // [sp+4h] [bp-14h] BYREF

  spawnz = CEntryExit::ms_spawnPoint->spawnz;
  *(_QWORD *)&posn.x = *(_QWORD *)&CEntryExit::ms_spawnPoint->spawnx;
  posn.z = spawnz;
  CRenderer::RequestObjectsInDirection(&posn, this->spawnrot, 32);
}

//----- (00306D68) --------------------------------------------------------
void CEntryExitManager::SetAreaCodeForVisibleObjects()
{
  int32 ObjectsInFrustum; // r4
  CPlayerPed *PlayerPed; // r0
  int32 v2; // r1
  int v3; // r2
  CEntity **v4; // r3
  int v5; // r4
  CEntity *v6; // r6
  int32 v7; // r5
  CEntity *v8; // r4

  ObjectsInFrustum = CRenderer::GetObjectsInFrustum((CEntity **)&PC_Scratch[256], 6.0, 0);
  PlayerPed = FindPlayerPed(-1);
  v2 = CGame::currArea;
  CEntryExitManager::ms_numVisibleEntities = 0;
  if ( ObjectsInFrustum )
  {
    v3 = 1 - ObjectsInFrustum;
    v4 = (CEntity **)&PC_Scratch[256];
    v5 = 0;
    do
    {
      v6 = *v4;
      if ( *v4 != PlayerPed && v2 == v6->m_areaCode )
      {
        v7 = v5 + 1;
        CEntryExitManager::ms_visibleEntityList[v5] = v6;
        v8 = *v4;
        CEntryExitManager::ms_numVisibleEntities = v7;
        v8->m_areaCode = 13;
        v5 = v7;
      }
      if ( !v3 )
        break;
      ++v3;
      ++v4;
    }
    while ( v5 < 32 );
  }
  CEntryExitManager::ms_oldAreaCode = v2;
}

//----- (00306E20) --------------------------------------------------------
void __fastcall CEntryExit::RequestAmbientPeds(CEntryExit *this)
{
  __int64 v2; // [sp+0h] [bp-28h] BYREF
  __int64 v3; // [sp+8h] [bp-20h]
  __int64 v4; // [sp+10h] [bp-18h]
  __int64 v5; // [sp+18h] [bp-10h]

  if ( CGame::currArea )
  {
    if ( !strcasecmp("bar1", (const char *)this) )
    {
      v2 = unk_60FB08;
      v3 = unk_60FB10;
      v4 = unk_60FB18;
      v5 = unk_60FB20;
      CStreaming::StreamPedsIntoRandomSlots((Int32 *)&v2);
    }
    if ( !strcasecmp("strip2", (const char *)this) )
    {
      v2 = 0x10100000100LL;
      v3 = unk_60FB30;
      v4 = unk_60FB38;
      v5 = unk_60FB40;
      CStreaming::StreamPedsIntoRandomSlots((Int32 *)&v2);
    }
    if ( !strcasecmp("LAstrip", (const char *)this) )
    {
      v2 = unk_60FB48;
      v3 = unk_60FB50;
      v4 = unk_60FB58;
      v5 = unk_60FB60;
      CStreaming::StreamPedsIntoRandomSlots((Int32 *)&v2);
    }
    if ( !strcasecmp("MAFCAS", (const char *)this) )
    {
      v2 = unk_60FB68;
      v3 = unk_60FB70;
      v4 = unk_60FB78;
      v5 = unk_60FB80;
      CStreaming::StreamPedsIntoRandomSlots((Int32 *)&v2);
    }
    if ( !strcasecmp("TRICAS", (const char *)this) )
    {
      v2 = unk_60FB88;
      v3 = unk_60FB90;
      v4 = unk_60FB98;
      v5 = unk_60FBA0;
      CStreaming::StreamPedsIntoRandomSlots((Int32 *)&v2);
    }
  }
  else
  {
    sub_18BEC4();
  }
}

//----- (00306F40) --------------------------------------------------------
void __fastcall CEntryExit::GenerateAmbientPeds(CEntryExit *this, const CVector *spawn)
{
  CEntryExit *pLink; // r1
  Int32 NumRandomPedsToCreate; // r6
  CVector v6; // 0:r0.12

  if ( CGame::currArea )
  {
    CPopulation::bInPoliceStation = 0;
    if ( !strcasecmp("POLICE1", (const char *)this)
      || !strcasecmp("POLICE2", (const char *)this)
      || !strcasecmp("POLICE3", (const char *)this)
      || !strcasecmp("POLICE4", (const char *)this) )
    {
      CPopulation::bInPoliceStation = 1;
    }
    pLink = this->pLink;
    if ( !pLink )
      pLink = this;
    NumRandomPedsToCreate = pLink->NumRandomPedsToCreate;
    if ( !strcasecmp("LAstrip", (const char *)this) || !strcasecmp("MAFCAS", (const char *)this) )
    {
      NumRandomPedsToCreate = 40;
    }
    else if ( !strcasecmp("TRICAS", (const char *)this) )
    {
      NumRandomPedsToCreate = 40;
    }
    CPopulation::NumberOfPedsInUseInterior = NumRandomPedsToCreate;
    sub_1A170C(NumRandomPedsToCreate, *spawn);
  }
  else
  {
    CPopulation::bInPoliceStation = 0;
    CPopulation::NumberOfPedsInUseInterior = 0;
    *(_QWORD *)&v6.x = *(_QWORD *)&spawn->x;
    v6.z = spawn->z;
    sub_192B20(v6, (float)(CEntryExit::ms_spawnPoint->spawnrot * 3.1416) / 180.0);
  }
}

//----- (00307078) --------------------------------------------------------
void __fastcall CEntryExit::FindValidTeleportPoint(CEntryExit *this, CVector *posn)
{
  int v3; // r4
  float v4; // s22
  float v5; // r0
  RwReal v6; // s0
  int v7; // r4
  float v8; // s20
  float v9; // r0
  RwReal v10; // s0
  __int64 v11; // d16
  CVector v12[6]; // [sp+20h] [bp-50h] BYREF
  CVector v13; // 0:r0.12
  CVector v14; // 0:r0.12
  CVector v15; // 0:r0.12

  v13 = *(CVector *)&CEntryExit::ms_spawnPoint->spawnx;
  *posn = v13;
  if ( CWorld::TestSphereAgainstWorld(v13, 0.35, 0, 1, 1, 1, 1, 1, 0) )
  {
    v3 = -1;
    while ( 1 )
    {
      ++v3;
      v4 = cosf((float)((float)((float)v3 * 3.1416) + (float)((float)v3 * 3.1416)) * 0.125);
      v5 = sinf((float)((float)((float)v3 * 3.1416) + (float)((float)v3 * 3.1416)) * 0.125);
      v12[0] = *posn;
      v14.z = v12[0].z;
      v6 = (float)(v5 * 1.25) + v12[0].y;
      v12[0].x = (float)(v4 * 1.25) + v12[0].x;
      v14.x = v12[0].x;
      v14.y = v6;
      v12[0].y = v6;
      if ( !CWorld::TestSphereAgainstWorld(v14, 0.35, 0, 1, 1, 1, 1, 1, 0)
        && CWorld::GetIsLineOfSightClear(posn, v12, 1, 1, 0, 1, 1, 0, 0) )
      {
        break;
      }
      if ( v3 >= 7 )
      {
        v7 = -1;
        while ( 1 )
        {
          ++v7;
          v8 = cosf((float)((float)((float)v7 * 3.1416) + (float)((float)v7 * 3.1416)) * 0.125);
          v9 = sinf((float)((float)((float)v7 * 3.1416) + (float)((float)v7 * 3.1416)) * 0.125);
          v12[0] = *posn;
          v15.z = v12[0].z;
          v10 = (float)(v9 + v9) + v12[0].y;
          v12[0].x = (float)(v8 + v8) + v12[0].x;
          v15.x = v12[0].x;
          v15.y = v10;
          v12[0].y = v10;
          if ( !CWorld::TestSphereAgainstWorld(v15, 0.35, 0, 1, 1, 1, 1, 1, 0)
            && CWorld::GetIsLineOfSightClear(posn, v12, 1, 1, 0, 1, 1, 0, 0) )
          {
            break;
          }
          if ( v7 >= 7 )
            return;
        }
        break;
      }
    }
    v11 = *(_QWORD *)&v12[0].x;
    posn->z = v12[0].z;
    *(_QWORD *)&posn->x = v11;
  }
}

//----- (00307254) --------------------------------------------------------
void __fastcall CEntryExit::WarpGangWithPlayer(CEntryExit *this, CPed *pPed)
{
  Int32 m_PlayerGroup; // r0
  int v4; // r9
  int v5; // r8
  CPed *Member; // r0
  CPed *v7; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r10
  float *p_x; // r0
  unsigned int v11; // s0
  unsigned int v12; // s2
  int v13; // r6
  CMatrix *v14; // r0
  CSimpleTransform *p_tx; // r4
  float *v16; // r0
  unsigned int v17; // s0
  unsigned int v18; // s2
  CMatrix *v19; // r0
  CSimpleTransform *v20; // r4
  float *v21; // r0
  unsigned int v22; // s0
  unsigned int v23; // s2
  CMatrix *v24; // r0
  CMatrix *v25; // r1
  float *v26; // r2
  CSimpleTransform *v27; // r0
  float v28; // s2
  float y; // s6
  float RadianAngleBetweenPoints; // r0
  float v31; // r4
  CMatrix *v32; // r0
  const CPedGroupMembership *p_m_membership; // [sp+34h] [bp-44h]
  CVector v34; // [sp+38h] [bp-40h] BYREF
  CVector vecEnd; // [sp+44h] [bp-34h] BYREF
  CVector v36; // 0:r0.12
  CVector v37; // 0:r0.12
  CVector v38; // 0:r0.12

  m_PlayerGroup = pPed->m_pPlayerData->m_PlayerGroup;
  if ( CPedGroups::ms_activeGroups[m_PlayerGroup] )
  {
    p_m_membership = &CPedGroups::ms_groups[m_PlayerGroup].m_membership;
    if ( CPedGroupMembership::IsLeader(p_m_membership, pPed) )
    {
      v4 = -1;
      v5 = 0;
      do
      {
        Member = CPedGroupMembership::GetMember(p_m_membership, ++v4);
        v7 = Member;
        if ( Member && v5 <= 7 && Member != pPed )
        {
          m_pMat = pPed->m_pMat;
          p_m_transform = &pPed->m_transform;
          if ( m_pMat )
            p_m_transform = (CSimpleTransform *)&m_pMat->tx;
          p_x = &CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[v5].x;
          *(float *)&v11 = *p_x + p_m_transform->m_translate.x;
          *(float *)&v12 = p_x[1] + p_m_transform->m_translate.y;
          vecEnd.z = p_m_transform->m_translate.z + 0.0;
          v36.z = vecEnd.z;
          *(_QWORD *)&v36.x = __PAIR64__(v12, v11);
          LODWORD(vecEnd.y) = v12;
          LODWORD(vecEnd.x) = v11;
          v13 = v5 + 1;
          if ( CWorld::TestSphereAgainstWorld(v36, 0.35, 0, 1, 1, 1, 1, 1, 0)
            || !CWorld::GetIsLineOfSightClear(&p_m_transform->m_translate, &vecEnd, 1, 1, 0, 1, 1, 0, 0) )
          {
            if ( v5 > 6 )
              return;
            v14 = pPed->m_pMat;
            p_tx = &pPed->m_transform;
            if ( v14 )
              p_tx = (CSimpleTransform *)&v14->tx;
            v16 = &CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[v13].x;
            *(float *)&v17 = *v16 + p_tx->m_translate.x;
            *(float *)&v18 = v16[1] + p_tx->m_translate.y;
            vecEnd.z = p_tx->m_translate.z + 0.0;
            v37.z = vecEnd.z;
            *(_QWORD *)&v37.x = __PAIR64__(v18, v17);
            LODWORD(vecEnd.y) = v18;
            LODWORD(vecEnd.x) = v17;
            v13 = v5 + 2;
            if ( CWorld::TestSphereAgainstWorld(v37, 0.35, 0, 1, 1, 1, 1, 1, 0)
              || !CWorld::GetIsLineOfSightClear(&p_tx->m_translate, &vecEnd, 1, 1, 0, 1, 1, 0, 0) )
            {
              if ( v5 > 5 )
                return;
              v19 = pPed->m_pMat;
              v20 = &pPed->m_transform;
              if ( v19 )
                v20 = (CSimpleTransform *)&v19->tx;
              v21 = &CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[v13].x;
              *(float *)&v22 = *v21 + v20->m_translate.x;
              *(float *)&v23 = v21[1] + v20->m_translate.y;
              vecEnd.z = v20->m_translate.z + 0.0;
              v38.z = vecEnd.z;
              *(_QWORD *)&v38.x = __PAIR64__(v23, v22);
              LODWORD(vecEnd.y) = v23;
              LODWORD(vecEnd.x) = v22;
              if ( CWorld::TestSphereAgainstWorld(v38, 0.35, 0, 1, 1, 1, 1, 1, 0)
                || !CWorld::GetIsLineOfSightClear(&v20->m_translate, &vecEnd, 1, 1, 0, 1, 1, 0, 0) )
              {
                return;
              }
              v13 = v5 + 3;
            }
          }
          v24 = v7->m_pMat;
          v25 = pPed->m_pMat;
          v26 = &v24->tx;
          if ( !v24 )
            v26 = &v7->m_transform.m_translate.x;
          v27 = &pPed->m_transform;
          v28 = v26[1];
          if ( v25 )
            v27 = (CSimpleTransform *)&v25->tx;
          y = v27->m_translate.y;
          v34.x = v27->m_translate.x - *v26;
          v34.z = 0.0;
          v34.y = y - v28;
          CVector::Normalise(&v34);
          RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v34.x, v34.y, 0.0, 0.0);
          v31 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
          (*((void (__fastcall **)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))v7->_vptr$CPlaceable + 15))(
            v7,
            LODWORD(vecEnd.x),
            LODWORD(vecEnd.y),
            LODWORD(vecEnd.z),
            0);
          CPedIntelligence::FlushImmediately(v7->m_pPedIntelligence, 0);
          v32 = v7->m_pMat;
          v7->m_fCurrentHeading = v31;
          v7->m_fDesiredHeading = v31;
          if ( v32 )
            CMatrix::SetRotateZOnly(v32, v31);
          else
            v7->m_transform.m_heading = v31;
          v7->m_areaCode = pPed->m_areaCode;
          v5 = v13;
          v7->m_pLastEntryExit = pPed->m_pLastEntryExit;
        }
      }
      while ( v4 < 6 );
    }
  }
}

//----- (00307580) --------------------------------------------------------
void __fastcall CEntryExit::ProcessStealableObjects(CEntryExit *this, CPed *pPed)
{
  CEntity *EntityThatThisPedIsHolding; // r0
  CEntity *v3; // r4
  CEntity *v4; // r1
  bool8 v5; // r2

  EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(pPed);
  v3 = EntityThatThisPedIsHolding;
  if ( EntityThatThisPedIsHolding
    && (*(_BYTE *)&EntityThatThisPedIsHolding->m_info & 7) == 4
    && (BYTE1(EntityThatThisPedIsHolding[5].m_pRwObject) & 0x20) != 0 )
  {
    if ( (LOBYTE(EntityThatThisPedIsHolding[5].m_pMat) | 4) != 6 )
    {
      if ( !CEntryExit::ms_spawnPoint->areacode )
      {
        v4 = EntityThatThisPedIsHolding;
        v5 = 1;
        goto LABEL_9;
      }
      if ( InteriorManager_c::FindStealableObjectId(&g_interiorMan, EntityThatThisPedIsHolding) != -1 )
      {
        v4 = v3;
        v5 = 0;
LABEL_9:
        InteriorManager_c::SetStealableObjectStolen(&g_interiorMan, v4, v5);
      }
    }
    v3->m_areaCode = CEntryExit::ms_spawnPoint->areacode;
  }
}

//----- (0030760C) --------------------------------------------------------
bool __fastcall IsTeleportPointValid(const CVector *initPosn, const CVector *posn)
{
  return !CWorld::TestSphereAgainstWorld(*posn, 0.35, 0, 1, 1, 1, 1, 1, 0)
      && CWorld::GetIsLineOfSightClear(initPosn, posn, 1, 1, 0, 1, 1, 0, 0);
}

//----- (00307660) --------------------------------------------------------
int32 __fastcall CEntryExitManager::FindNearestEntryExit(const CVector2D *pos, float range, int32 areaLeaving)
{
  float32x2_t v3; // d0
  void *m_pVoid; // r6
  float y; // s2
  float v9; // s6
  float v10; // s0
  CPtrNode *m_pHead; // r0
  float32x2_t v12; // d18
  float32x2_t v13; // d1
  bool v14; // nf
  CPtrNode v15; // kr00_8
  int v16; // r2
  int v17; // r2
  int32 v18; // r4
  CRect bb; // [sp+4h] [bp-2Ch] BYREF
  CPtrListSingleLink Matches; // [sp+14h] [bp-1Ch] BYREF

  m_pVoid = 0;
  Matches.m_pHead = 0;
  y = pos->y;
  v9 = pos->x - range;
  v10 = pos->x + range;
  bb.bottom = y - range;
  bb.left = v9;
  bb.right = v10;
  bb.top = y + range;
  CQuadTreeNode::GetAllMatching(CEntryExitManager::mp_QuadTree, &bb, &Matches);
  v3.n64_f32[0] = range + range;
  m_pHead = Matches.m_pHead;
  while ( m_pHead )
  {
    v15 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    v16 = *((_DWORD *)v15.m_pVoid + 14);
    if ( v16 )
      v17 = *(unsigned __int8 *)(v16 + 50);
    else
      v17 = *((unsigned __int8 *)v15.m_pVoid + 50);
    if ( v17 != areaLeaving )
    {
      v12.n64_u64[0] = vsub_f32(
                         *(float32x2_t *)pos,
                         vmul_f32(
                           vadd_f32(*((float32x2_t *)v15.m_pVoid + 1), *((float32x2_t *)v15.m_pVoid + 2)),
                           (float32x2_t)0x3F0000003F000000LL)).n64_u64[0];
      v13.n64_u64[0] = vmul_f32(v12, v12).n64_u64[0];
      v13.n64_f32[0] = sqrtf(v13.n64_f32[0] + v13.n64_f32[1]);
      v14 = v13.n64_f32[0] < v3.n64_f32[0];
      v3.n64_u64[0] = vmin_f32(v13, v3).n64_u64[0];
      if ( v14 )
        m_pVoid = v15.m_pVoid;
    }
  }
  if ( m_pVoid )
    v18 = -286331153
        * ((signed int)((int)m_pVoid - (unsigned int)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
  else
    v18 = -1;
  CPtrListSingleLink::Flush(&Matches);
  return v18;
}
// 3076EA: variable 'v3' is possibly undefined

//----- (00307750) --------------------------------------------------------
void __fastcall CTaskSimpleUninterruptable::~CTaskSimpleUninterruptable(CTaskSimpleUninterruptable *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 30775C: variable 'v1' is possibly undefined

//----- (00307760) --------------------------------------------------------
CTask *__fastcall CTaskSimpleUninterruptable::Clone(const CTaskSimpleUninterruptable *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(8u);
  CTaskSimple::CTaskSimple(v1);
  result->_vptr$CTask = (int (**)(void))&off_6653E4;
  return result;
}
// 307776: variable 'result' is possibly undefined
// 6653E4: using guessed type void *off_6653E4;

//----- (00307780) --------------------------------------------------------
CTask *__fastcall CTaskSimple::GetSubTask(const CTaskSimple *this)
{
  return 0;
}

//----- (00307784) --------------------------------------------------------
bool __fastcall CTaskSimple::IsSimpleTask(const CTaskSimple *this)
{
  return 1;
}

//----- (00307788) --------------------------------------------------------
int __fastcall CTaskSimpleUninterruptable::GetTaskType(const CTaskSimpleUninterruptable *this)
{
  return 201;
}

//----- (0030778E) --------------------------------------------------------
bool __fastcall CTaskSimpleUninterruptable::MakeAbortable(
        CTaskSimpleUninterruptable *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return iPriority == 2;
}

//----- (00307798) --------------------------------------------------------
bool __fastcall CTaskSimpleUninterruptable::ProcessPed(CTaskSimpleUninterruptable *this, CPed *pPed)
{
  return 0;
}

//----- (0030779C) --------------------------------------------------------
bool __fastcall CTaskSimple::SetPedPosition(CTaskSimple *this, CPed *pPed)
{
  return 0;
}

//----- (003077A0) --------------------------------------------------------
void CGameLogic::InitAtStartOfGame()
{
  CGameLogic::SkipState = 0;
  CGameLogic::GameState = 0;
  CGameLogic::NumAfterDeathStartPoints = 0;
  CGameLogic::ActivePlayers = 1;
  CGameLogic::TimeOfLastEvent = 0;
  CGameLogic::nPrintFocusHelpTimer = 0;
  CGameLogic::nPrintFocusHelpCounter = 0;
  CGameLogic::bScriptCoopGameGoingOn = 0;
}

//----- (00307824) --------------------------------------------------------
void CGameLogic::ResetStuffUponResurrection()
{
  __int16 v0; // r5
  CPlayerPed *pPed; // r0
  CMatrix *m_pMat; // r1
  CVector *p_tx; // r3
  CPlayerPed *v4; // r0
  CMatrix *v5; // r1
  const CVector *p_m_translate; // r4
  float m_heading; // s0
  CPad *Pad; // r0
  CVector v9; // [sp+Ch] [bp-24h] BYREF

  v0 = CWorld::PlayerInFocus;
  CMessages::ClearMessages(0);
  CCarCtrl::ClearInterestingVehicleList();
  CPlayerInfo::GetPos(&v9, &CWorld::Players[v0]);
  CWorld::ClearExcitingStuffFromArea(&v9, 4000.0, 1u);
  CGameLogic::PassTime(0x2D0u);
  pPed = CWorld::Players[v0].pPed;
  m_pMat = pPed->m_pMat;
  p_tx = (CVector *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform.m_translate;
  CGameLogic::RestorePlayerStuffDuringResurrection(pPed, *p_tx, (float)(pPed->m_fCurrentHeading * 180.0) / 3.1416);
  v4 = CWorld::Players[v0].pPed;
  v5 = v4->m_pMat;
  p_m_translate = (const CVector *)&v5->tx;
  if ( v5 )
  {
    m_heading = atan2f(COERCE_FLOAT(LODWORD(v5->xy) ^ 0x80000000), v5->yy);
  }
  else
  {
    p_m_translate = &v4->m_transform.m_translate;
    m_heading = v4->m_transform.m_heading;
  }
  CGameLogic::SortOutStreamingAndMemory(p_m_translate, m_heading);
  TheCamera.m_fCamShakeForce = 0.0;
  CCamera::SetMotionBlur(&TheCamera, 0, 0, 0, 0, 0);
  Pad = CPad::GetPad(0);
  CPad::StopShaking(Pad, 0);
  CReferences::RemoveReferencesToPlayer();
  CPopulation::m_CountDownToPedsAtStart = 10;
  CCarCtrl::CountDownToCarsAtStart = 10;
  CPad::GetPad(CWorld::PlayerInFocus)->DisablePlayerControls = 0;
  CGameLogic::TimeOfLastEvent = 0;
  CGameLogic::GameState = 0;
}

//----- (00307960) --------------------------------------------------------
void __fastcall CGameLogic::PassTime(UInt32 GameMinutes)
{
  int v2; // r4
  int v3; // r6
  signed int v4; // r5
  int v5; // r1
  __int64 v6; // r0
  int v7; // r2
  uint8 v8; // r0
  bool v9; // cc

  v2 = CClock::CurrentDay;
  v3 = CClock::ms_nGameClockHours;
  v4 = CClock::ms_nGameClockMinutes + GameMinutes;
  if ( v4 >= 60 )
  {
    v5 = ~v4;
    if ( ~v4 < -120 || v4 == 119 )
      v5 = -120;
    v6 = 2290649225LL * (CClock::ms_nGameClockMinutes + v5 + GameMinutes + 60);
    v3 = CClock::ms_nGameClockHours + (HIDWORD(v6) >> 5) + 1;
    v4 = v4 - 60 * (HIDWORD(v6) >> 5) - 60;
  }
  if ( v3 < 24 )
  {
    v8 = v3;
    LOBYTE(v7) = CClock::CurrentDay;
  }
  else
  {
    do
    {
      CStats::IncrementStat(0x86u, 1.0);
      v7 = v2 + 1;
      v8 = v3 - 24;
      if ( v2 > 6 )
        v7 = 1;
      v9 = v3 <= 47;
      v2 = v7;
      v3 -= 24;
    }
    while ( !v9 );
  }
  CClock::SetGameClock(v8, v4, v7);
  sub_191214(1000 * GameMinutes);
}

//----- (00307A10) --------------------------------------------------------
void __fastcall CGameLogic::RestorePlayerStuffDuringResurrection(
        CPlayerPed *pPlayerPed,
        CVector NewCoors,
        float NewHeading)
{
  CPad *Pad; // r0
  CPlayerInfo *PlayerInfoForThisPlayerPed; // r8
  CPlayerPedData *m_pPlayerData; // r1
  int m_nFlags; // r3
  unsigned int v8; // r0
  int m_nPedFlags; // r2
  CFire *m_pFire; // r0
  CVehicle *m_pMyVehicle; // r0
  CPlayerPedData *v12; // r0
  CWanted *m_Wanted; // r0
  float v14; // s0
  CMatrix *m_pMat; // r0
  CPedClothesDesc *m_pClothes; // r0
  CVector Coors; // [sp+4h] [bp-24h] BYREF

  Coors = NewCoors;
  if ( CGameLogic::SkipState == 2 )
  {
    CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
    CCamera::Fade(&TheCamera, 0.5, 1);
  }
  CGameLogic::SkipState = 0;
  Pad = CPad::GetPad(0);
  Pad->DisablePlayerControls &= ~0x100u;
  if ( pPlayerPed->m_nHealth <= 0.0 )
    CStats::UpdateStatsOnRespawn();
  PlayerInfoForThisPlayerPed = CPlayerPed::GetPlayerInfoForThisPlayerPed(pPlayerPed);
  pPlayerPed->m_nHealth = (float)PlayerInfoForThisPlayerPed->MaxHealth;
  m_pPlayerData = pPlayerPed->m_pPlayerData;
  m_nFlags = (int)pPlayerPed->m_nFlags;
  v8 = *(_DWORD *)&pPlayerPed->m_nPhysicalFlags & 0xDFFFFFFF;
  m_nPedFlags = (int)pPlayerPed->m_nPedFlags;
  pPlayerPed->m_nTimeOfDeath = 0;
  pPlayerPed->m_nArmour = 0.0;
  pPlayerPed->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)v8;
  *(_DWORD *)&pPlayerPed->m_nFlags = m_nFlags | 0x80;
  *(_DWORD *)&pPlayerPed->m_nPedFlags = m_nPedFlags & 0xEFFFFFFF;
  m_pPlayerData->m_nDrunkenness = 0;
  pPlayerPed->m_pPlayerData->m_bFadeDrunkenness = 0;
  CMBlur::ClearDrunkBlur();
  pPlayerPed->m_pPlayerData->m_nDrugLevel = 0;
  CPlayerPed::ClearAdrenaline(pPlayerPed);
  CPlayerPed::ResetSprintEnergy(pPlayerPed);
  m_pFire = pPlayerPed->m_pFire;
  if ( m_pFire )
  {
    *(_BYTE *)m_pFire &= ~2u;
    CFire::Extinguish(pPlayerPed->m_pFire);
    pPlayerPed->m_pFire = 0;
  }
  CAEPedAudioEntity::TurnOffJetPack(&pPlayerPed->m_PedAudioEntity);
  *(_DWORD *)&pPlayerPed->m_nPedFlags &= ~0x100u;
  m_pMyVehicle = pPlayerPed->m_pMyVehicle;
  if ( m_pMyVehicle )
    CEntity::CleanUpOldReference(m_pMyVehicle, &pPlayerPed->m_pMyVehicle);
  v12 = pPlayerPed->m_pPlayerData;
  pPlayerPed->m_pMyVehicle = 0;
  if ( v12 )
    m_Wanted = v12->m_Wanted;
  else
    m_Wanted = 0;
  CWanted::Reset(m_Wanted);
  CPed::RestartNonPartialAnims(pPlayerPed);
  CPlayerInfo::MakePlayerSafe(PlayerInfoForThisPlayerPed, 0, 10000.0);
  *(_DWORD *)&pPlayerPed->m_nFlags &= ~0x800u;
  CPlayerPed::ClearWeaponTarget(pPlayerPed);
  CPlayerPed::SetInitialState(pPlayerPed, 0);
  pPlayerPed->m_acquaintances = *CPedType::GetPedTypeAcquaintances(pPlayerPed->m_nPedType);
  CCarCtrl::ClearInterestingVehicleList();
  (*((void (__fastcall **)(CPlayerPed *, _DWORD, _DWORD, _DWORD, _DWORD))pPlayerPed->_vptr$CPlaceable + 15))(
    pPlayerPed,
    Coors.x + 0.0,
    Coors.y + 0.0,
    Coors.z + 1.0,
    0);
  pPlayerPed->m_vecMoveSpeed.x = 0.0;
  pPlayerPed->m_vecMoveSpeed.y = 0.0;
  pPlayerPed->m_vecMoveSpeed.z = 0.0;
  v14 = (float)(NewHeading * 3.1416) / 180.0;
  pPlayerPed->m_fDesiredHeading = v14;
  m_pMat = pPlayerPed->m_pMat;
  pPlayerPed->m_fCurrentHeading = v14;
  if ( m_pMat )
    CMatrix::SetRotateZOnly(m_pMat, (float)(NewHeading * 3.1416) / 180.0);
  else
    pPlayerPed->m_transform.m_heading = v14;
  CTheScripts::ClearSpaceForMissionEntity(&Coors, pPlayerPed);
  CWorld::ClearExcitingStuffFromArea(&Coors, 4000.0, 1u);
  CPed::RestoreHeadingRate(pPlayerPed);
  pPlayerPed->m_pLastEntryExit = 0;
  pPlayerPed->m_areaCode = 0;
  CPopulation::bInPoliceStation = 0;
  CGame::currArea = AREA_MAIN_MAP;
  CEntryExitManager::ms_entryExitStackPosn = 0;
  CStreaming::RemoveBuildingsNotInArea(0);
  CCamera::SetCameraDirectlyBehindForFollowPed_CamOnAString(&TheCamera);
  CCamera::RestoreWithJumpCut(&TheCamera);
  CReferences::RemoveReferencesToPlayer();
  CGarages::PlayerArrestedOrDied();
  CStats::SetStatValue(0xB0u, 0.0);
  CShopping::RemoveLoadedShop();
  CWorld::Remove(pPlayerPed);
  CWorld::Add(pPlayerPed);
  CHud::ResetWastedText();
  CStreaming::StreamZoneModels(&Coors);
  CPostEffects::m_waterEnable = 0;
  CTimeCycle::StopExtraColour(0);
  CPostEffects::ScriptResetForEffects();
  m_pClothes = pPlayerPed->m_pPlayerData->m_pClothes;
  if ( m_pClothes->modelsKeyArray[9] )
  {
    CPedClothesDesc::SetTextureAndModel(m_pClothes, 0, 0, 17);
    CClothes::RebuildPlayer(pPlayerPed, 0);
  }
  else
  {
    CClothes::RebuildPlayerIfNeeded(pPlayerPed);
  }
  CAudioZones::Update(1, Coors);
  CAudioEngine::StopPoliceScanner(&AudioEngine, 1u);
  CWaterLevel::FindNearestWaterAndItsFlow();
  TheCamera.DistanceToWater = 100000.0;
}

//----- (00307D30) --------------------------------------------------------
void __fastcall CGameLogic::SortOutStreamingAndMemory(const CVector *posn, float heading)
{
  RwReal FarClipForCoors; // r0

  CTimer::Stop();
  FarClipForCoors = CTimeCycle::FindFarClipForCoors(*posn);
  RwCameraSetFarClipPlane(TheCamera.m_pRwCamera, FarClipForCoors);
  CStreaming::FlushRequestList();
  CStreaming::DeleteRwObjectsAfterDeath(posn);
  CStreaming::RemoveUnusedModelsInLoadedList();
  CGame::DrasticTidyUpMemory(1);
  CStreaming::LoadSceneCollision(posn);
  CRenderer::RequestObjectsInDirection(posn, heading, 32);
  CStreaming::LoadScene(posn);
  sub_1928E0();
}

//----- (00307D8C) --------------------------------------------------------
void CGameLogic::Update()
{
  float32x2_t v0; // d3
  float32x2_t v1; // d10
  CPlayerPed *pPed; // r1
  bool v3; // zf
  CMatrix *m_pMat; // r2
  CMatrix *v5; // r3
  float32x2_t *p_tx; // r6
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v8; // d16
  unsigned __int64 v9; // d0
  float v10; // s16
  GxtChar *v11; // r0
  GxtChar *v12; // r0
  int v13; // r3
  GxtChar *v14; // r0
  CPlayerPed *v15; // r0
  ePedState m_nPedState; // r1
  CPlayerPed *v17; // r0
  ePedState v18; // r1
  GxtChar *v19; // r0
  unsigned int m_nBustedAudioStatus; // r1
  uint32 v21; // r5
  _BOOL4 IsPlayerOnAMission; // r0
  CPlayerPed *v23; // r2
  bool v24; // zf
  unsigned __int32 v25; // r0
  int *v26; // r0
  uint32 v27; // r5
  bool v28; // zf
  CVehicle *m_pMyVehicle; // r0
  uint32 v30; // r5
  unsigned int v31; // r0
  unsigned int v32; // r2
  CPlayerPed *v33; // r0
  CVehicle *v34; // r0
  CEntity::CEntityInfo m_info; // r1
  CMatrix *v36; // r1
  CSimpleTransform *v37; // r2
  __int64 v38; // d16
  CEntryExit *m_pLastEntryExit; // r0
  CPlayerPed *v40; // r0
  bool v41; // zf
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v43; // r0
  int v44; // r3
  int v45; // r5
  int v46; // r2
  CMatrix *v47; // r1
  CSimpleTransform *v48; // r4
  float m_heading; // s0
  CPad *Pad; // r0
  Int32 v51; // r0
  bool v52; // zf
  CVehicle *v53; // r0
  CPlayerPed *v54; // r0
  CMatrix *v55; // r1
  CSimpleTransform *v56; // r2
  __int64 v57; // d16
  CEntryExit *v58; // r0
  CPlayerPed *v59; // r0
  bool v60; // zf
  CPlayerPed *v61; // r0
  CPlayerPed *v62; // r0
  int v63; // r3
  int v64; // r5
  int v65; // r2
  CMatrix *v66; // r1
  CSimpleTransform *v67; // r4
  float v68; // s0
  CPad *v69; // r0
  Int32 v70; // r0
  bool v71; // zf
  CVehicle *v72; // r0
  CPlayerPed *v73; // r0
  CMatrix *v74; // r1
  CSimpleTransform *v75; // r2
  __int64 v76; // d16
  CEntryExit *v77; // r0
  CPlayerPed *v78; // r0
  bool v79; // zf
  CPlayerPed *v80; // r0
  CPlayerPed *v81; // r0
  int v82; // r3
  int v83; // r5
  int v84; // r2
  CMatrix *v85; // r1
  CSimpleTransform *v86; // r4
  float v87; // s0
  CPad *v88; // r0
  bool v89; // zf
  int v90; // r3
  CMatrix *v91; // r6
  float *v92; // r0
  CSimpleTransform *v93; // r1
  float v94; // s0
  float v95; // s2
  float y; // s6
  RwReal v97; // s0
  RwReal v98; // s4
  CVehicle *v99; // r1
  float x; // s16
  float v101; // s18
  CPlayerPed *v102; // r4
  int m_nPedFlags; // r0
  bool v104; // zf
  float v105; // s0
  float v106; // s2
  float z; // s4
  float v108; // s8
  float v109; // s16
  float v110; // s18
  CPlayerPed *v111; // r4
  int v112; // r0
  bool v113; // zf
  float v114; // s0
  float v115; // s2
  float v116; // s4
  float v117; // s6
  float v118; // s8
  CVector ClosestPoint; // [sp+10h] [bp-48h] BYREF
  CVector posn; // [sp+20h] [bp-38h] BYREF
  float pHeading[11]; // [sp+2Ch] [bp-2Ch] BYREF

  CStats::UpdateRespectStat(0);
  CStats::UpdateSexAppealStat();
  CGameLogic::SetPlayerWantedLevelForForbiddenTerritories(0);
  if ( CCutsceneMgr::ms_cutsceneProcessing )
    return;
  pPed = (CPlayerPed *)CWorld::Players;
  v3 = CWorld::Players[0].pPed == 0;
  if ( CWorld::Players[0].pPed )
  {
    pPed = CWorld::Players[1].pPed;
    v3 = CWorld::Players[1].pPed == 0;
  }
  if ( v3 )
  {
    CGameLogic::UpdateSkip();
    goto LABEL_30;
  }
  m_pMat = pPed->m_pMat;
  v5 = CWorld::Players[0].pPed->m_pMat;
  p_tx = (float32x2_t *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = (float32x2_t *)&pPed->m_transform;
  p_m_transform = (CSimpleTransform *)&v5->tx;
  if ( !v5 )
    p_m_transform = &CWorld::Players[0].pPed->m_transform;
  v8.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.x, (float32x2_t)p_tx->n64_u64[0]).n64_u64[0];
  v9 = vmul_f32(v8, v8).n64_u64[0];
  v10 = sqrtf(*(float *)&v9 + *((float *)&v9 + 1));
  if ( v10 > 100.0 )
  {
    if ( CGameLogic::GameState != 3 )
    {
      CGameLogic::GameState = 3;
      CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
    }
    goto LABEL_26;
  }
  if ( v10 > 85.0 && CGameLogic::Update(void)::OldDistBetweenPlayers <= 85.0 )
  {
    v11 = CText::Get(&TheText, "WRN_2P");
    CHud::SetHelpMessage("WRN_2P", v11, 0, 0, 0, 0);
    goto LABEL_26;
  }
  if ( v10 <= CGameLogic::MaxPlayerDistance || CGameLogic::nPrintFocusHelpCounter > 4 )
    goto LABEL_26;
  if ( CGameLogic::Update(void)::OldDistBetweenPlayers > CGameLogic::MaxPlayerDistance
    || CTimer::m_snTimeInMilliseconds <= CGameLogic::nPrintFocusHelpTimer )
  {
    if ( CTimer::m_snTimeInMilliseconds <= CGameLogic::nPrintFocusHelpTimer )
      goto LABEL_26;
    v14 = CText::Get(&TheText, "WRN2_2P");
    CHud::SetHelpMessage("WRN2_2P", v14, 0, 0, 0, 0);
    v13 = 60000;
  }
  else
  {
    v12 = CText::Get(&TheText, "WRN1_2P");
    CHud::SetHelpMessage("WRN1_2P", v12, 0, 0, 0, 0);
    v13 = 15000;
  }
  CGameLogic::nPrintFocusHelpTimer = CTimer::m_snTimeInMilliseconds + v13;
  ++CGameLogic::nPrintFocusHelpCounter;
LABEL_26:
  if ( CGameLogic::n2PlayerPedInFocus != 2 && CGameLogic::nPrintFocusHelpTimer )
    CGameLogic::nPrintFocusHelpTimer = CTimer::m_snTimeInMilliseconds + 30000;
  CGameLogic::Update(void)::OldDistBetweenPlayers = v10;
LABEL_30:
  if ( !CWorld::Players[0].pPed || CWorld::Players[0].PlayerState )
    goto LABEL_38;
  CTaskManager::GetSimplestActiveTask(&CWorld::Players[0].pPed->m_pPedIntelligence->m_taskManager);
  v15 = CWorld::Players[0].pPed;
  m_nPedState = CWorld::Players[0].pPed->m_nPedState;
  if ( m_nPedState != PED_DEAD )
  {
    if ( m_nPedState != PED_DIE )
      goto LABEL_36;
    if ( (*((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 3) & 0x20) == 0 )
      goto LABEL_38;
  }
  CPlayerPed::ClearAdrenaline(CWorld::Players[0].pPed);
  CPlayerInfo::KillPlayer(CWorld::Players);
  v15 = CWorld::Players[0].pPed;
  CGameLogic::GameState = 1;
  CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
  m_nPedState = CWorld::Players[0].pPed->m_nPedState;
LABEL_36:
  if ( m_nPedState == PED_ARRESTED )
  {
    CPlayerPed::ClearAdrenaline(v15);
    CPlayerInfo::ArrestPlayer(CWorld::Players);
    CPed::Say(CWorld::Players[0].pPed, 0xFu, 0x8FCu, 1.0, 1, 1, 1);
    CGameLogic::GameState = 2;
    CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
  }
LABEL_38:
  if ( !CWorld::Players[1].pPed || CWorld::Players[1].PlayerState )
    goto LABEL_47;
  CTaskManager::GetSimplestActiveTask(&CWorld::Players[1].pPed->m_pPedIntelligence->m_taskManager);
  v17 = CWorld::Players[1].pPed;
  v18 = CWorld::Players[1].pPed->m_nPedState;
  if ( v18 != PED_DEAD )
  {
    if ( v18 != PED_DIE )
      goto LABEL_44;
    if ( (*((_DWORD *)&CWorld::Players[1].pPed->m_nPedFlags + 3) & 0x20) == 0 )
      goto LABEL_47;
  }
  CPlayerPed::ClearAdrenaline(CWorld::Players[1].pPed);
  CPlayerInfo::KillPlayer(&CWorld::Players[1]);
  v17 = CWorld::Players[1].pPed;
  CGameLogic::GameState = 1;
  CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
  v18 = CWorld::Players[1].pPed->m_nPedState;
LABEL_44:
  if ( v18 == PED_ARRESTED )
  {
    CPlayerPed::ClearAdrenaline(v17);
    CPlayerInfo::ArrestPlayer(&CWorld::Players[1]);
    CPed::Say(CWorld::Players[1].pPed, 0xFu, 0x8FCu, 1.0, 1, 1, 1);
    CGameLogic::GameState = 2;
    CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds;
    if ( CHud::m_BigMessage[2][0] )
      goto LABEL_50;
    v19 = CText::Get(&TheText, "BUSTED");
    CMessages::AddBigMessage(v19, 0x1388u, 2u);
  }
LABEL_47:
  m_nBustedAudioStatus = CGameLogic::GameState - 3;
  if ( m_nBustedAudioStatus < 2 )
  {
    v27 = CTimer::m_snTimeInMilliseconds - CGameLogic::TimeOfLastEvent;
    m_nBustedAudioStatus = 3000;
    if ( CTimer::m_snPreviousTimeInMilliseconds - CGameLogic::TimeOfLastEvent <= 0xBB8 && v27 >= 0xBB9 )
    {
      CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
      CCamera::Fade(&TheCamera, 2.0, 0);
    }
    if ( v27 >= 0xBB9 && !TheCamera.m_bFading )
    {
      CGameLogic::GameState = 0;
      CWorld::Players[0].PlayerState = 0;
      m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&CWorld::Players[0].pPed->m_nPedFlags + 1) << 31);
      v28 = m_pMyVehicle == 0;
      if ( m_pMyVehicle )
      {
        m_pMyVehicle = CWorld::Players[0].pPed->m_pMyVehicle;
        v28 = m_pMyVehicle == 0;
      }
      if ( !v28 )
      {
        if ( m_pMyVehicle->pDriver == CWorld::Players[0].pPed )
        {
          CEntity::CleanUpOldReference(CWorld::Players[0].pPed, &m_pMyVehicle->pDriver);
          v33 = CWorld::Players[0].pPed;
          CWorld::Players[0].pPed->m_pMyVehicle->pDriver = 0;
          v34 = v33->m_pMyVehicle;
          m_info = v34->m_info;
          if ( (*(_BYTE *)&m_info & 0xF8) != 40 )
            v34->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x20);
        }
        else
        {
          CVehicle::RemovePassenger(m_pMyVehicle, CWorld::Players[0].pPed);
        }
      }
      CMessages::ClearMessages(0);
      CCarCtrl::ClearInterestingVehicleList();
      CGarages::CloseHideOutGaragesBeforeSave();
      CPlayerInfo::GetPos(&posn, CWorld::Players);
      CWorld::ClearExcitingStuffFromArea(&posn, 4000.0, 1u);
      v36 = CWorld::Players[0].pPed->m_pMat;
      v37 = (CSimpleTransform *)&v36->tx;
      if ( !v36 )
        v37 = &CWorld::Players[0].pPed->m_transform;
      v38 = *(_QWORD *)&v37->m_translate.x;
      posn.z = v37->m_translate.z;
      *(_QWORD *)&posn.x = v38;
      m_pLastEntryExit = CWorld::Players[0].pPed->m_pLastEntryExit;
      if ( m_pLastEntryExit )
        CEntryExit::GetPositionRelativeToOutsideWorld(m_pLastEntryExit, &posn);
      CRestart::FindClosestPoliceRestartPoint(posn, &ClosestPoint, pHeading);
      v40 = CWorld::Players[1].pPed;
      v41 = CWorld::Players[0].pPed == 0;
      if ( CWorld::Players[0].pPed )
        v41 = CWorld::Players[1].pPed == 0;
      if ( !v41 )
      {
        ClosestPoint = CGameLogic::vec2PlayerStartLocation;
        pHeading[0] = (float)(CGameLogic::f2PlayerStartHeading * 180.0) / 3.1416;
        PlayerPed = FindPlayerPed(0);
        CGameLogic::RestorePedsWeapons(PlayerPed);
        v40 = CWorld::Players[1].pPed;
      }
      if ( v40 )
      {
        CWorld::Remove(v40);
        if ( CWorld::Players[1].pPed )
          (*((void (__fastcall **)(CPlayerPed *))CWorld::Players[1].pPed->_vptr$CPlaceable + 1))(CWorld::Players[1].pPed);
        CWorld::Players[1].pPed = 0;
        CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
        v43 = CWorld::Players[0].pPed;
        v44 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 2);
        v45 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 3);
        v46 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 1);
        *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags = CWorld::Players[0].pPed->m_nPedFlags;
        *((_DWORD *)&v43->m_nPedFlags + 1) = v46;
        *((_DWORD *)&v43->m_nPedFlags + 2) = v44 & 0xE7FFFFFF;
        *((_DWORD *)&v43->m_nPedFlags + 3) = v45;
      }
      else
      {
        v43 = CWorld::Players[0].pPed;
      }
      CGameLogic::n2PlayerPedInFocus = 2;
      CGameLogic::RestorePlayerStuffDuringResurrection(v43, ClosestPoint, pHeading[0]);
      v47 = CWorld::Players[0].pPed->m_pMat;
      v48 = (CSimpleTransform *)&v47->tx;
      if ( v47 )
      {
        m_heading = atan2f(COERCE_FLOAT(LODWORD(v47->xy) ^ 0x80000000), v47->yy);
      }
      else
      {
        v48 = &CWorld::Players[0].pPed->m_transform;
        m_heading = CWorld::Players[0].pPed->m_transform.m_heading;
      }
      CGameLogic::SortOutStreamingAndMemory(&v48->m_translate, m_heading);
      TheCamera.m_fCamShakeForce = 0.0;
      CCamera::SetMotionBlur(&TheCamera, 0, 0, 0, 0, 0);
      Pad = CPad::GetPad(0);
      CPad::StopShaking(Pad, 0);
      CReferences::RemoveReferencesToPlayer();
      CPopulation::m_CountDownToPedsAtStart = 10;
      CCarCtrl::CountDownToCarsAtStart = 10;
      CPad::GetPad(CWorld::PlayerInFocus)->DisablePlayerControls = 0;
      goto LABEL_169;
    }
    goto LABEL_170;
  }
  if ( CGameLogic::GameState == 1 )
  {
    CWeaponEffects::ClearCrossHairs();
    v30 = CTimer::m_snTimeInMilliseconds - CGameLogic::TimeOfLastEvent;
    m_nBustedAudioStatus = 3000;
    if ( CTimer::m_snPreviousTimeInMilliseconds - CGameLogic::TimeOfLastEvent <= 0xBB8 && v30 >= 0xBB9 )
    {
      CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
      CCamera::Fade(&TheCamera, 2.0, 0);
    }
    if ( v30 >= 0xBB9 && !TheCamera.m_bFading )
    {
      v31 = (unsigned int)CWorld::Players[1].pPed;
      v32 = (unsigned int)CWorld::Players[0].pPed;
      if ( CWorld::Players[1].pPed )
        v31 = 1;
      if ( CWorld::Players[0].pPed )
        v32 = 1;
      if ( (v32 & v31) == 0 && CGameLogic::bPenaltyForDeathApplies )
      {
        if ( CWorld::Players[0].bFreeHealthCare )
        {
          CWorld::Players[0].bFreeHealthCare = 0;
        }
        else if ( CWorld::Players[0].Score >= 1 )
        {
          v70 = CWorld::Players[0].Score - 100;
          if ( CWorld::Players[0].Score < 100 )
            v70 = 0;
          CWorld::Players[0].Score = v70;
        }
      }
      CGameLogic::GameState = 0;
      CWorld::Players[0].PlayerState = 0;
      v72 = (CVehicle *)(*((unsigned __int8 *)&CWorld::Players[0].pPed->m_nPedFlags + 1) << 31);
      v71 = v72 == 0;
      if ( v72 )
      {
        v72 = CWorld::Players[0].pPed->m_pMyVehicle;
        v71 = v72 == 0;
      }
      if ( !v71 )
      {
        if ( v72->pDriver == CWorld::Players[0].pPed )
        {
          CEntity::CleanUpOldReference(CWorld::Players[0].pPed, &v72->pDriver);
          v73 = CWorld::Players[0].pPed;
          CWorld::Players[0].pPed->m_pMyVehicle->pDriver = 0;
          if ( (*(_BYTE *)&v73->m_pMyVehicle->m_info & 0xF8) != 40 )
            v73->m_pMyVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v73->m_pMyVehicle->m_info & 7 | 0x20);
        }
        else
        {
          CVehicle::RemovePassenger(v72, CWorld::Players[0].pPed);
        }
      }
      CMessages::ClearMessages(0);
      CHud::SetHelpMessage(0, 0, 1, 0, 0, 0);
      CCarCtrl::ClearInterestingVehicleList();
      CGarages::CloseHideOutGaragesBeforeSave();
      CPlayerInfo::GetPos(&posn, CWorld::Players);
      CWorld::ClearExcitingStuffFromArea(&posn, 4000.0, 1u);
      v74 = CWorld::Players[0].pPed->m_pMat;
      v75 = (CSimpleTransform *)&v74->tx;
      if ( !v74 )
        v75 = &CWorld::Players[0].pPed->m_transform;
      v76 = *(_QWORD *)&v75->m_translate.x;
      posn.z = v75->m_translate.z;
      *(_QWORD *)&posn.x = v76;
      v77 = CWorld::Players[0].pPed->m_pLastEntryExit;
      if ( v77 )
        CEntryExit::GetPositionRelativeToOutsideWorld(v77, &posn);
      CRestart::FindClosestHospitalRestartPoint(posn, &ClosestPoint, pHeading);
      v78 = CWorld::Players[1].pPed;
      v79 = CWorld::Players[0].pPed == 0;
      if ( CWorld::Players[0].pPed )
        v79 = CWorld::Players[1].pPed == 0;
      if ( !v79 )
      {
        ClosestPoint = CGameLogic::vec2PlayerStartLocation;
        pHeading[0] = (float)(CGameLogic::f2PlayerStartHeading * 180.0) / 3.1416;
        v80 = FindPlayerPed(0);
        CGameLogic::RestorePedsWeapons(v80);
        v78 = CWorld::Players[1].pPed;
      }
      if ( v78 )
      {
        CWorld::Remove(v78);
        if ( CWorld::Players[1].pPed )
          (*((void (__fastcall **)(CPlayerPed *))CWorld::Players[1].pPed->_vptr$CPlaceable + 1))(CWorld::Players[1].pPed);
        CWorld::Players[1].pPed = 0;
        CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
        v81 = CWorld::Players[0].pPed;
        v82 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 2);
        v83 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 3);
        v84 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 1);
        *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags = CWorld::Players[0].pPed->m_nPedFlags;
        *((_DWORD *)&v81->m_nPedFlags + 1) = v84;
        *((_DWORD *)&v81->m_nPedFlags + 2) = v82 & 0xE7FFFFFF;
        *((_DWORD *)&v81->m_nPedFlags + 3) = v83;
      }
      CGameLogic::n2PlayerPedInFocus = 2;
      CGameLogic::PassTime(0x2D0u);
      CWorld::Players[CWorld::PlayerInFocus].TimeLastEaten = 0;
      CGameLogic::RestorePlayerStuffDuringResurrection(CWorld::Players[0].pPed, ClosestPoint, pHeading[0]);
      v85 = CWorld::Players[0].pPed->m_pMat;
      v86 = (CSimpleTransform *)&v85->tx;
      if ( v85 )
      {
        v87 = atan2f(COERCE_FLOAT(LODWORD(v85->xy) ^ 0x80000000), v85->yy);
      }
      else
      {
        v86 = &CWorld::Players[0].pPed->m_transform;
        v87 = CWorld::Players[0].pPed->m_transform.m_heading;
      }
      CGameLogic::SortOutStreamingAndMemory(&v86->m_translate, v87);
      TheCamera.m_fCamShakeForce = 0.0;
      CCamera::SetMotionBlur(&TheCamera, 0, 0, 0, 0, 0);
      v88 = CPad::GetPad(0);
      CPad::StopShaking(v88, 0);
      CReferences::RemoveReferencesToPlayer();
      CPopulation::m_CountDownToPedsAtStart = 10;
      CCarCtrl::CountDownToCarsAtStart = 10;
      CPopulation::m_bIsHospital = 1;
      CPad::GetPad(CWorld::PlayerInFocus)->DisablePlayerControls = 0;
      m_nBustedAudioStatus = (unsigned int)&CRestart::bFadeInAfterNextDeath;
      if ( !CRestart::bFadeInAfterNextDeath )
      {
        CRestart::bFadeInAfterNextDeath = 1;
        goto LABEL_170;
      }
      goto LABEL_169;
    }
    goto LABEL_170;
  }
  if ( CGameLogic::GameState != 2 )
    goto LABEL_170;
LABEL_50:
  CWeaponEffects::ClearCrossHairs();
  v21 = CTimer::m_snTimeInMilliseconds - CGameLogic::TimeOfLastEvent;
  if ( CTimer::m_snPreviousTimeInMilliseconds - CGameLogic::TimeOfLastEvent <= 0xBB8 && v21 >= 0xBB9 )
  {
    CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
    CCamera::Fade(&TheCamera, 2.0, 0);
  }
  IsPlayerOnAMission = CTheScripts::IsPlayerOnAMission();
  m_nBustedAudioStatus = CWorld::Players[0].m_nBustedAudioStatus;
  if ( (IsPlayerOnAMission | CWorld::Players[0].m_nBustedAudioStatus) << 24 )
  {
    if ( v21 < 0xFA0 )
      goto LABEL_170;
  }
  else if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 4.0) )
  {
    m_nBustedAudioStatus = 2;
    CWorld::Players[0].m_nBustedAudioStatus = 2;
    if ( v21 < 0xFA0 )
      goto LABEL_170;
  }
  else
  {
    CWorld::Players[0].m_nBustedAudioStatus = 1;
    m_nBustedAudioStatus = CWorld::Players[0].m_nLastBustMessageNumber % 0x1Cu + 1;
    CWorld::Players[0].m_nLastBustMessageNumber = CWorld::Players[0].m_nLastBustMessageNumber % 0x1Cu + 1;
    if ( v21 < 0xFA0 )
      goto LABEL_170;
  }
  if ( !TheCamera.m_bFading )
  {
    v23 = CWorld::Players[0].pPed;
    v24 = CWorld::Players[0].pPed == 0;
    CGameLogic::GameState = 0;
    CWorld::Players[0].PlayerState = 0;
    if ( CWorld::Players[0].pPed )
      v24 = CWorld::Players[1].pPed == 0;
    if ( v24 )
    {
      v25 = CWorld::Players[0].PlayerPedData.m_Wanted->m_WantedLevel - 2;
      v26 = v25 > 4 ? &dword_64 : (&off_308F0C)[v25];
      if ( CGameLogic::bPenaltyForArrestApplies )
      {
        if ( CWorld::Players[0].bGetOutOfJailFree )
        {
          CWorld::Players[0].bGetOutOfJailFree = 0;
        }
        else
        {
          if ( CWorld::Players[0].Score >= 1 )
          {
            v51 = CWorld::Players[0].Score - (_DWORD)v26;
            if ( v51 <= 0 )
              v51 = 0;
            CWorld::Players[0].Score = v51;
          }
          CPed::ClearWeapons(CWorld::Players[0].pPed);
          v23 = CWorld::Players[0].pPed;
        }
      }
    }
    v53 = (CVehicle *)(*((unsigned __int8 *)&v23->m_nPedFlags + 1) << 31);
    v52 = v53 == 0;
    if ( v53 )
    {
      v53 = v23->m_pMyVehicle;
      v52 = v53 == 0;
    }
    if ( !v52 )
    {
      if ( v53->pDriver == v23 )
      {
        CEntity::CleanUpOldReference(v23, &v53->pDriver);
        v54 = CWorld::Players[0].pPed;
        CWorld::Players[0].pPed->m_pMyVehicle->pDriver = 0;
        if ( (*(_BYTE *)&v54->m_pMyVehicle->m_info & 0xF8) != 40 )
          v54->m_pMyVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v54->m_pMyVehicle->m_info & 7 | 0x20);
      }
      else
      {
        CVehicle::RemovePassenger(v53, v23);
      }
    }
    CMessages::ClearMessages(0);
    CHud::SetHelpMessage(0, 0, 1, 0, 0, 0);
    CCarCtrl::ClearInterestingVehicleList();
    CGarages::CloseHideOutGaragesBeforeSave();
    CPlayerInfo::GetPos(&posn, CWorld::Players);
    CWorld::ClearExcitingStuffFromArea(&posn, 4000.0, 1u);
    v55 = CWorld::Players[0].pPed->m_pMat;
    v56 = (CSimpleTransform *)&v55->tx;
    if ( !v55 )
      v56 = &CWorld::Players[0].pPed->m_transform;
    v57 = *(_QWORD *)&v56->m_translate.x;
    posn.z = v56->m_translate.z;
    *(_QWORD *)&posn.x = v57;
    v58 = CWorld::Players[0].pPed->m_pLastEntryExit;
    if ( v58 )
      CEntryExit::GetPositionRelativeToOutsideWorld(v58, &posn);
    CRestart::FindClosestPoliceRestartPoint(posn, &ClosestPoint, pHeading);
    v59 = CWorld::Players[1].pPed;
    v60 = CWorld::Players[0].pPed == 0;
    if ( CWorld::Players[0].pPed )
      v60 = CWorld::Players[1].pPed == 0;
    if ( !v60 )
    {
      ClosestPoint = CGameLogic::vec2PlayerStartLocation;
      pHeading[0] = (float)(CGameLogic::f2PlayerStartHeading * 180.0) / 3.1416;
      v61 = FindPlayerPed(0);
      CGameLogic::RestorePedsWeapons(v61);
      v59 = CWorld::Players[1].pPed;
    }
    if ( v59 )
    {
      CWorld::Remove(v59);
      if ( CWorld::Players[1].pPed )
        (*((void (__fastcall **)(CPlayerPed *))CWorld::Players[1].pPed->_vptr$CPlaceable + 1))(CWorld::Players[1].pPed);
      CWorld::Players[1].pPed = 0;
      CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
      v62 = CWorld::Players[0].pPed;
      v63 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 2);
      v64 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 3);
      v65 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 1);
      *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags = CWorld::Players[0].pPed->m_nPedFlags;
      *((_DWORD *)&v62->m_nPedFlags + 1) = v65;
      *((_DWORD *)&v62->m_nPedFlags + 2) = v63 & 0xE7FFFFFF;
      *((_DWORD *)&v62->m_nPedFlags + 3) = v64;
    }
    CGameLogic::n2PlayerPedInFocus = 2;
    CGameLogic::PassTime(0x2D0u);
    CGameLogic::RestorePlayerStuffDuringResurrection(CWorld::Players[0].pPed, ClosestPoint, pHeading[0]);
    v66 = CWorld::Players[0].pPed->m_pMat;
    v67 = (CSimpleTransform *)&v66->tx;
    if ( v66 )
    {
      v68 = atan2f(COERCE_FLOAT(LODWORD(v66->xy) ^ 0x80000000), v66->yy);
    }
    else
    {
      v67 = &CWorld::Players[0].pPed->m_transform;
      v68 = CWorld::Players[0].pPed->m_transform.m_heading;
    }
    CGameLogic::SortOutStreamingAndMemory(&v67->m_translate, v68);
    TheCamera.m_fCamShakeForce = 0.0;
    CCamera::SetMotionBlur(&TheCamera, 0, 0, 0, 0, 0);
    v69 = CPad::GetPad(0);
    CPad::StopShaking(v69, 0);
    CReferences::RemoveReferencesToPlayer();
    CPopulation::m_CountDownToPedsAtStart = 10;
    CCarCtrl::CountDownToCarsAtStart = 10;
    CPad::GetPad(CWorld::PlayerInFocus)->DisablePlayerControls = 0;
    if ( !CRestart::bFadeInAfterNextArrest )
    {
      m_nBustedAudioStatus = 1;
      CRestart::bFadeInAfterNextArrest = 1;
      goto LABEL_170;
    }
LABEL_169:
    CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
    CCamera::Fade(&TheCamera, 3.0, 1);
  }
LABEL_170:
  if ( !CGameLogic::bLimitPlayerDistance )
    return;
  v89 = CWorld::Players[0].pPed == 0;
  if ( CWorld::Players[0].pPed )
  {
    m_nBustedAudioStatus = (unsigned int)CWorld::Players[1].pPed;
    v89 = CWorld::Players[1].pPed == 0;
  }
  if ( v89 )
    return;
  v90 = *(_DWORD *)(m_nBustedAudioStatus + 20);
  v91 = CWorld::Players[0].pPed->m_pMat;
  v92 = (float *)(v90 + 48);
  if ( !v90 )
    v92 = (float *)(m_nBustedAudioStatus + 4);
  v93 = (CSimpleTransform *)&v91->tx;
  v94 = *v92;
  v95 = v92[1];
  if ( !v91 )
    v93 = &CWorld::Players[0].pPed->m_transform;
  y = v93->m_translate.y;
  if ( sqrtf(
         (float)((float)(v93->m_translate.x - v94) * (float)(v93->m_translate.x - v94))
       + (float)((float)(y - v95) * (float)(y - v95))) <= CGameLogic::MaxPlayerDistance )
    return;
  v97 = v94 - v93->m_translate.x;
  v98 = v92[2] - v93->m_translate.z;
  ClosestPoint.y = v95 - y;
  ClosestPoint.x = v97;
  ClosestPoint.z = v98;
  CVector::Normalise(&ClosestPoint);
  x = ClosestPoint.x;
  v101 = ClosestPoint.y;
  v1.n64_u32[0] = LODWORD(ClosestPoint.z);
  v102 = CWorld::Players[0].pPed;
  m_nPedFlags = (int)CWorld::Players[0].pPed->m_nPedFlags;
  v104 = (m_nPedFlags & 0x100) == 0;
  if ( (m_nPedFlags & 0x100) != 0 )
  {
    v99 = CWorld::Players[0].pPed->m_pMyVehicle;
    v104 = v99 == 0;
  }
  if ( !v104 )
  {
    v102 = (CPlayerPed *)v99;
LABEL_185:
    v105 = v102->m_vecMoveSpeed.x;
    v106 = v102->m_vecMoveSpeed.y;
    v0.n64_u32[0] = 0;
    z = v102->m_vecMoveSpeed.z;
    v0.n64_u64[0] = vmax_f32(v1, v0).n64_u64[0];
    v108 = (float)((float)(x * v105) + (float)(v101 * v106)) + (float)(v0.n64_f32[0] * z);
    if ( v108 < 0.0 )
    {
      z = z - (float)(v0.n64_f32[0] * v108);
      v106 = v106 - (float)(v101 * v108);
      v105 = v105 - (float)(x * v108);
    }
    v102->m_vecMoveSpeed.x = v105;
    v102->m_vecMoveSpeed.y = v106;
    v102->m_vecMoveSpeed.z = z;
    goto LABEL_188;
  }
  if ( m_nPedFlags << 31 || CPedIntelligence::GetTaskJetPack(CWorld::Players[0].pPed->m_pPedIntelligence) )
    goto LABEL_185;
LABEL_188:
  v109 = -ClosestPoint.x;
  v110 = -ClosestPoint.y;
  v1.n64_f32[0] = -ClosestPoint.z;
  v111 = CWorld::Players[1].pPed;
  ClosestPoint.x = -ClosestPoint.x;
  ClosestPoint.y = -ClosestPoint.y;
  ClosestPoint.z = -ClosestPoint.z;
  v112 = (int)CWorld::Players[1].pPed->m_nPedFlags;
  v113 = (v112 & 0x100) == 0;
  if ( (v112 & 0x100) != 0 )
  {
    v99 = CWorld::Players[1].pPed->m_pMyVehicle;
    v113 = v99 == 0;
  }
  if ( v113 )
  {
    if ( !(v112 << 31) && !CPedIntelligence::GetTaskJetPack(CWorld::Players[1].pPed->m_pPedIntelligence) )
      return;
  }
  else
  {
    v111 = (CPlayerPed *)v99;
  }
  v114 = v111->m_vecMoveSpeed.x;
  v115 = v111->m_vecMoveSpeed.y;
  v0.n64_u32[0] = 0;
  v116 = v111->m_vecMoveSpeed.z;
  v117 = vmax_f32(v1, v0).n64_f32[0];
  v118 = (float)((float)(v114 * v109) + (float)(v115 * v110)) + (float)(v117 * v116);
  if ( v118 < 0.0 )
  {
    v116 = v116 - (float)(v117 * v118);
    v115 = v115 - (float)(v118 * v110);
    v114 = v114 - (float)(v118 * v109);
  }
  v111->m_vecMoveSpeed.x = v114;
  v111->m_vecMoveSpeed.y = v115;
  v111->m_vecMoveSpeed.z = v116;
}
// 308C3C: variable 'm_nBustedAudioStatus' is possibly undefined
// 308D28: variable 'v99' is possibly undefined
// 308D42: variable 'v1' is possibly undefined
// 308D42: variable 'v0' is possibly undefined
// 64: using guessed type int dword_64;
// FC: using guessed type int elf_hash_bucket[16411];
// 308F0C: using guessed type int *off_308F0C;

//----- (0030906C) --------------------------------------------------------
void __fastcall CGameLogic::SetPlayerWantedLevelForForbiddenTerritories(bool bAlways)
{
  _BOOL4 v1; // r4
  CPlayerPed *PlayerPed; // r0
  int v3; // r4
  float x; // r10
  float y; // r11
  int v6; // r6
  float *p_y; // r5
  int v8; // r0
  CPlayerPed *v9; // r0
  int v10; // r4
  float v11; // r10
  float v12; // r11
  int v13; // r6
  float *v14; // r5
  int v15; // r0
  CPlayerPed *v16; // r0
  _BOOL4 v17; // [sp+14h] [bp-44h]
  CVector v18; // [sp+18h] [bp-40h] BYREF
  CVector v19; // [sp+24h] [bp-34h] BYREF
  CVector v20; // [sp+30h] [bp-28h] BYREF

  v1 = bAlways;
  if ( bAlways || (CTimer::m_FrameCounter & 0x1F) == 18 )
  {
    FindPlayerCoors(&v20, -1);
    if ( v20.z <= 950.0 )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( !CPedIntelligence::GetTaskSwim(PlayerPed->m_pPedIntelligence)
        && FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel <= WANTED_LEVEL3 )
      {
        v17 = v1;
        if ( CStats::GetStatValue(0xB5u) <= 1.0 )
        {
          FindPlayerCoors(&v19, -1);
          v3 = 0;
          x = v19.x;
          y = v19.y;
          v6 = 1;
          p_y = &AreaLasVegas[0].y;
          do
          {
            v8 = v6;
            if ( v6 == 10 )
              v8 = 0;
            ++v6;
            v3 += CCollision::Test2DLineAgainst2DLine(
                    x,
                    y,
                    1000000.0,
                    0.0,
                    *(p_y - 1),
                    *p_y,
                    AreaLasVegas[v8].x - *(p_y - 1),
                    AreaLasVegas[v8].y - *p_y);
            p_y += 3;
          }
          while ( v6 != 11 );
          if ( v3 << 31 )
          {
            v9 = FindPlayerPed(-1);
            CPlayerPed::SetWantedLevel(v9, 4);
            if ( v17 )
              FindPlayerWanted(-1)->m_LastTimeWantedLevelChanged = 0;
          }
        }
        if ( CStats::GetStatValue(0xB5u) <= 0.0 )
        {
          FindPlayerCoors(&v18, -1);
          v10 = 0;
          v11 = v18.x;
          v12 = v18.y;
          v13 = 1;
          v14 = &AreaSanFran[0].y;
          do
          {
            v15 = v13;
            if ( v13 == 9 )
              v15 = 0;
            ++v13;
            v10 += CCollision::Test2DLineAgainst2DLine(
                     v11,
                     v12,
                     1000000.0,
                     0.0,
                     *(v14 - 1),
                     *v14,
                     AreaSanFran[v15].x - *(v14 - 1),
                     AreaSanFran[v15].y - *v14);
            v14 += 3;
          }
          while ( v13 != 10 );
          if ( v10 << 31 )
          {
            v16 = FindPlayerPed(-1);
            CPlayerPed::SetWantedLevel(v16, 4);
            if ( v17 )
              FindPlayerWanted(-1)->m_LastTimeWantedLevelChanged = 0;
          }
        }
      }
    }
  }
}

//----- (0030926C) --------------------------------------------------------
int CGameLogic::IsCoopGameGoingOn()
{
  char pPed; // r0

  pPed = (char)CWorld::Players[1].pPed;
  if ( CWorld::Players[1].pPed )
    pPed = 1;
  return (unsigned __int8)pPed & (CWorld::Players[0].pPed != 0);
}

//----- (0030928C) --------------------------------------------------------
void CGameLogic::UpdateSkip()
{
  Int32 v0; // r0
  float32x2_t v1; // d16
  unsigned __int64 v2; // d0
  int v3; // r0
  float v4; // s16
  CVehicle *PlayerVehicle; // r0
  CVehicle *v6; // r0
  CVehicle *v7; // r0
  Int32 v8; // r1
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v10; // r0
  float GroundZForCoord; // s2
  CPlayerPed *v12; // r0
  CMatrix *v13; // r1
  CSimpleTransform *p_tx; // r2
  int32 m_baseVehicleType; // r4
  CBike *v16; // r0
  CAutomobile *v17; // r0
  CVehicle *v18; // r4
  CMatrix *m_pMat; // r0
  RwReal v20; // s4
  RwReal v21; // s6
  CVehicle *v22; // r0
  CMatrix *v23; // r1
  float m_heading; // s0
  CPad *Pad; // r0
  CVector v26; // [sp+8h] [bp-30h] BYREF

  v0 = CGameLogic::SkipState;
  if ( CGameLogic::SkipState == 1 )
  {
    FindPlayerCoors(&v26, -1);
    v1.n64_u64[0] = vsub_f32(*(float32x2_t *)&v26.x, *(float32x2_t *)&CGameLogic::SkipDestination.x).n64_u64[0];
    v2 = vmul_f32(v1, v1).n64_u64[0];
    if ( sqrtf(*(float *)&v2 + *((float *)&v2 + 1)) < 25.0 )
    {
LABEL_6:
      CGameLogic::SkipState = 0;
      return;
    }
    v0 = CGameLogic::SkipState;
  }
  v3 = v0 - 1;
  switch ( v3 )
  {
    case 0:
    case 3:
      if ( CTimer::m_snTimeInMilliseconds > CGameLogic::SkipTimer + 35000 )
        goto LABEL_6;
      switch ( v3 )
      {
        case 0:
        case 3:
          CGameLogic::SkipCanBeActivated();
          break;
        case 1:
          goto LABEL_9;
        case 2:
          goto LABEL_13;
        default:
          return;
      }
      break;
    case 1:
LABEL_9:
      if ( CTimer::m_snTimeInMilliseconds > CGameLogic::SkipTimer )
      {
        CTimer::Suspend();
        CStreaming::LoadSceneCollision(&CGameLogic::SkipDestination);
        CStreaming::LoadScene(&CGameLogic::SkipDestination);
        FindPlayerCoors(&v26, -1);
        v4 = sqrtf(
               (float)((float)(CGameLogic::SkipDestination.x - v26.x) * (float)(CGameLogic::SkipDestination.x - v26.x))
             + (float)((float)(CGameLogic::SkipDestination.y - v26.y) * (float)(CGameLogic::SkipDestination.y - v26.y)));
        if ( FindPlayerVehicle(-1, 0) )
        {
          PlayerVehicle = FindPlayerVehicle(-1, 0);
          CTheScripts::ClearSpaceForMissionEntity(&CGameLogic::SkipDestination, PlayerVehicle);
          v6 = FindPlayerVehicle(-1, 0);
          (*((void (__fastcall **)(CVehicle *, _DWORD, _DWORD, _DWORD, _DWORD))v6->_vptr$CPlaceable + 15))(
            v6,
            LODWORD(CGameLogic::SkipDestination.x),
            LODWORD(CGameLogic::SkipDestination.y),
            LODWORD(CGameLogic::SkipDestination.z),
            0);
          v7 = FindPlayerVehicle(-1, 0);
          if ( v7->m_pMat )
            CMatrix::SetRotateZOnly(v7->m_pMat, (float)(CGameLogic::SkipDestinationOrientation * 3.1416) / 180.0);
          else
            v7->m_transform.m_heading = (float)(CGameLogic::SkipDestinationOrientation * 3.1416) / 180.0;
          m_baseVehicleType = FindPlayerVehicle(-1, 0)->m_baseVehicleType;
          v16 = (CBike *)FindPlayerVehicle(-1, 0);
          if ( m_baseVehicleType == 9 )
          {
            CBike::PlaceOnRoadProperly(v16);
          }
          else if ( !v16->m_baseVehicleType )
          {
            v17 = (CAutomobile *)FindPlayerVehicle(-1, 0);
            CAutomobile::PlaceOnRoadProperly(v17);
          }
          v18 = FindPlayerVehicle(-1, 0);
          m_pMat = FindPlayerVehicle(-1, 0)->m_pMat;
          v20 = m_pMat->yy * 0.4;
          v21 = m_pMat->zy * 0.4;
          v18->m_vecMoveSpeed.x = m_pMat->xy * 0.4;
          v18->m_vecMoveSpeed.y = v20;
          v18->m_vecMoveSpeed.z = v21;
          v22 = FindPlayerVehicle(-1, 0);
          v23 = v22->m_pMat;
          if ( v23 )
            m_heading = atan2f(COERCE_FLOAT(LODWORD(v23->xy) ^ 0x80000000), v23->yy);
          else
            m_heading = v22->m_transform.m_heading;
          TheCamera.Cams[TheCamera.ActiveCam].Beta = m_heading + -1.5708;
        }
        else
        {
          PlayerPed = FindPlayerPed(-1);
          CTheScripts::ClearSpaceForMissionEntity(&CGameLogic::SkipDestination, PlayerPed);
          v10 = FindPlayerPed(-1);
          (*((void (__fastcall **)(CPlayerPed *, _DWORD, _DWORD, _DWORD, _DWORD))v10->_vptr$CPlaceable + 15))(
            v10,
            LODWORD(CGameLogic::SkipDestination.x),
            LODWORD(CGameLogic::SkipDestination.y),
            LODWORD(CGameLogic::SkipDestination.z),
            0);
          GroundZForCoord = CWorld::FindGroundZForCoord(CGameLogic::SkipDestination.x, CGameLogic::SkipDestination.y);
          v12 = FindPlayerPed(-1);
          v13 = v12->m_pMat;
          p_tx = (CSimpleTransform *)&v13->tx;
          if ( !v13 )
            p_tx = &v12->m_transform;
          p_tx->m_translate.z = GroundZForCoord + 1.0;
        }
        CGameLogic::SkipTimer = CTimer::m_snTimeInMilliseconds + 1500;
        CHud::SetMessage(0);
        CTimer::Resume();
        CGameLogic::PassTime((unsigned int)(float)((float)(v4 / 20.0) + 23.0));
        if ( CGameLogic::SkipToBeFinishedByScript )
        {
          v8 = 5;
          goto LABEL_29;
        }
        CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
        CCamera::Fade(&TheCamera, 1.5, 1);
        CGameLogic::SkipState = 3;
      }
      break;
    case 2:
LABEL_13:
      if ( CTimer::m_snTimeInMilliseconds > CGameLogic::SkipTimer )
      {
        v8 = 0;
LABEL_29:
        CGameLogic::SkipState = v8;
        Pad = CPad::GetPad(0);
        Pad->DisablePlayerControls &= ~0x100u;
      }
      break;
    default:
      return;
  }
}

//----- (0030963C) --------------------------------------------------------
void __fastcall CGameLogic::RestorePedsWeapons(CPed *pPed)
{
  int i; // r5
  int32 m_modelId; // r4
  int32 m_modelId2; // r0

  CPed::ClearWeapons(pPed);
  for ( i = 0; i != 13; ++i )
  {
    m_modelId = CWeaponInfo::GetWeaponInfo(CGameLogic::SavedWeaponSlots[i].m_eWeaponType, 1)->m_modelId;
    m_modelId2 = CWeaponInfo::GetWeaponInfo(CGameLogic::SavedWeaponSlots[i].m_eWeaponType, 1)->m_modelId2;
    if ( (m_modelId == -1 || CStreaming::ms_aInfoForModel[m_modelId].m_status == 1)
      && (m_modelId2 == -1 || CStreaming::ms_aInfoForModel[m_modelId].m_status == 1) )
    {
      CPed::GiveWeapon(
        pPed,
        CGameLogic::SavedWeaponSlots[i].m_eWeaponType,
        CGameLogic::SavedWeaponSlots[i].m_nAmmoTotal,
        1);
    }
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (003096D8) --------------------------------------------------------
void CGameLogic::Remove2ndPlayerIfPresent()
{
  CPlayerPed *pPed; // r0
  int v1; // r4
  int v2; // r2
  unsigned int v3; // r3

  if ( CWorld::Players[1].pPed )
  {
    CWorld::Remove(CWorld::Players[1].pPed);
    if ( CWorld::Players[1].pPed )
      (*((void (__fastcall **)(CPlayerPed *))CWorld::Players[1].pPed->_vptr$CPlaceable + 1))(CWorld::Players[1].pPed);
    CWorld::Players[1].pPed = 0;
    CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
    pPed = CWorld::Players[0].pPed;
    v1 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 3);
    v2 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 1);
    v3 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 2) & 0xE7FFFFFF;
    *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags = CWorld::Players[0].pPed->m_nPedFlags;
    *((_DWORD *)&pPed->m_nPedFlags + 1) = v2;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v3;
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v1;
  }
  CGameLogic::n2PlayerPedInFocus = 2;
}

//----- (0030975C) --------------------------------------------------------
void __fastcall CGameLogic::StopPlayerMovingFromDirection(Int32 Player, CVector VecToOther)
{
  float32x2_t v2; // d5
  float32x2_t v3; // d8
  float y; // r6
  float x; // r5
  RwReal z; // r8
  CPlayerPed *pPed; // r4
  bool v8; // zf
  int m_pMyVehicle; // r0
  float v10; // s0
  float v11; // s2
  float v12; // s4
  float v13; // s10
  float v14; // s12

  y = VecToOther.y;
  x = VecToOther.x;
  z = VecToOther.z;
  pPed = CWorld::Players[Player].pPed;
  m_pMyVehicle = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31;
  v8 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
  {
    m_pMyVehicle = (int)pPed->m_pMyVehicle;
    v8 = m_pMyVehicle == 0;
  }
  if ( v8 )
  {
    if ( !(*(_BYTE *)&pPed->m_nPedFlags << 31) && !CPedIntelligence::GetTaskJetPack(pPed->m_pPedIntelligence) )
      return;
  }
  else
  {
    pPed = (CPlayerPed *)m_pMyVehicle;
  }
  v10 = pPed->m_vecMoveSpeed.x;
  v11 = pPed->m_vecMoveSpeed.y;
  v2.n64_u32[0] = 0;
  v12 = pPed->m_vecMoveSpeed.z;
  v3.n64_f32[0] = z;
  v13 = vmax_f32(v3, v2).n64_f32[0];
  v14 = (float)((float)(v10 * x) + (float)(v11 * y)) + (float)(v13 * v12);
  if ( v14 < 0.0 )
  {
    v12 = v12 - (float)(v13 * v14);
    v11 = v11 - (float)(v14 * y);
    v10 = v10 - (float)(v14 * x);
  }
  pPed->m_vecMoveSpeed.x = v10;
  pPed->m_vecMoveSpeed.y = v11;
  pPed->m_vecMoveSpeed.z = v12;
}
// 3097C6: variable 'v3' is possibly undefined
// 3097C6: variable 'v2' is possibly undefined

//----- (00309818) --------------------------------------------------------
void CGameLogic::ForceDeathRestart()
{
  CWorld::Players[CWorld::PlayerInFocus].PlayerState = 1;
  CGameLogic::GameState = 1;
  CGameLogic::TimeOfLastEvent = CTimer::m_snTimeInMilliseconds - 3001;
  CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
  sub_19EE28(&TheCamera, 4.0, 0);
}

//----- (0030989C) --------------------------------------------------------
int __fastcall CGameLogic::IsPlayerAllowedToGoInThisDirection(CPlayerPed *pPlayerPed, CVector Dir, float fExtraDist)
{
  float y; // r5
  float x; // r10
  float z; // r8
  CPlayerPed *v7; // r2
  int result; // r0
  CPlayerPed *pPed; // r1
  bool v10; // zf
  CVector *GameCamPosition; // r0
  CMatrix *m_pMat; // r3
  CMatrix *v13; // r6
  float *p_tx; // r0
  float *p_x; // r2
  float v16; // s0
  float v17; // s2
  float v18; // s6
  float v19; // s10
  int v20; // r2
  float v21; // s0
  RwV3d_0 posn; // [sp+14h] [bp-24h] BYREF

  y = Dir.y;
  x = Dir.x;
  z = Dir.z;
  v7 = (CPlayerPed *)CWorld::Players;
  result = 1;
  pPed = CWorld::Players[0].pPed;
  v10 = CWorld::Players[0].pPed == 0;
  if ( CWorld::Players[0].pPed )
  {
    v7 = CWorld::Players[1].pPed;
    v10 = CWorld::Players[1].pPed == 0;
  }
  if ( !v10 && CGameLogic::bLimitPlayerDistance )
  {
    if ( CGameLogic::n2PlayerPedInFocus <= 1 )
    {
      if ( CWorld::Players[CGameLogic::n2PlayerPedInFocus].pPed == pPlayerPed )
        return 1;
      posn.x = 0.0;
      posn.y = 0.0;
      posn.z = 0.2;
      CPed::GetTransformedBonePosition(pPlayerPed, &posn, 5u, 0);
      if ( !CEntity::GetIsOnScreen(pPlayerPed) )
        return 0;
      GameCamPosition = CCamera::GetGameCamPosition(&TheCamera);
      if ( !CWorld::GetIsLineOfSightClear(GameCamPosition, (const CVector *)&posn, 1, 0, 0, 0, 0, 1, 0) )
        return 0;
      pPed = CWorld::Players[0].pPed;
      v7 = CWorld::Players[1].pPed;
    }
    m_pMat = v7->m_pMat;
    v13 = pPed->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v7->m_transform.m_translate.x;
    p_x = &v13->tx;
    if ( !v13 )
      p_x = &pPed->m_transform.m_translate.x;
    v16 = *p_x - *p_tx;
    v17 = p_x[1] - p_tx[1];
    if ( sqrtf((float)(v16 * v16) + (float)(v17 * v17)) < (float)(CGameLogic::MaxPlayerDistance + fExtraDist) )
      return 1;
    v18 = p_tx[2];
    v19 = p_x[2];
    result = 0;
    v20 = 0;
    v21 = (float)((float)(v16 * x) + (float)(v17 * y)) + (float)((float)(v19 - v18) * z);
    if ( v21 < 0.0 )
      v20 = 1;
    if ( v21 > 0.0 )
      result = 1;
    if ( pPed == pPlayerPed )
      return v20;
  }
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00309A1C) --------------------------------------------------------
bool __fastcall CGameLogic::IsPlayerUse2PlayerControls(CPlayerPed *pPlayerPed)
{
  bool v1; // r1
  bool v2; // zf

  v1 = 0;
  v2 = CWorld::Players[0].pPed == 0;
  if ( CWorld::Players[0].pPed )
    v2 = CWorld::Players[1].pPed == 0;
  if ( !v2 )
  {
    if ( CGameLogic::n2PlayerPedInFocus == 2 )
      return 1;
    return CWorld::Players[CGameLogic::n2PlayerPedInFocus].pPed != pPlayerPed;
  }
  return v1;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00309A6C) --------------------------------------------------------
bool CGameLogic::IsScriptCoopGameGoingOn()
{
  return CGameLogic::bScriptCoopGameGoingOn;
}

//----- (00309A7C) --------------------------------------------------------
int CGameLogic::Disable2ndControllerForDebug()
{
  return 1;
}

//----- (00309A80) --------------------------------------------------------
void __fastcall CGameLogic::ClearSkip(bool bLeaveAfterMission)
{
  CPad *Pad; // r0

  if ( CGameLogic::SkipState != 4 || !bLeaveAfterMission )
  {
    if ( CGameLogic::SkipState == 2 )
    {
      CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
      CCamera::Fade(&TheCamera, 0.5, 1);
    }
    CGameLogic::SkipState = 0;
    Pad = CPad::GetPad(0);
    Pad->DisablePlayerControls &= ~0x100u;
  }
}

//----- (00309AE8) --------------------------------------------------------
void __fastcall CGameLogic::SetUpSkip(
        CVector DestCoors,
        float DestOrientation,
        int bAfterMission,
        CVehicle *pSpecificVehicle,
        bool bScriptToFinish)
{
  RwReal x; // r11
  RwReal z; // r9
  RwReal y; // r10
  CPad *Pad; // r0
  Int32 v10; // r0

  x = DestCoors.x;
  z = DestCoors.z;
  y = DestCoors.y;
  if ( CGameLogic::SkipState == 2 )
  {
    CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
    CCamera::Fade(&TheCamera, 0.5, 1);
  }
  CGameLogic::SkipState = 0;
  Pad = CPad::GetPad(0);
  Pad->DisablePlayerControls &= ~0x100u;
  v10 = 1;
  if ( bAfterMission )
    v10 = 4;
  CGameLogic::SkipState = v10;
  CGameLogic::SkipDestination.x = x;
  CGameLogic::SkipDestination.y = y;
  CGameLogic::SkipDestination.z = z;
  CGameLogic::SkipDestinationOrientation = DestOrientation;
  CGameLogic::SkipVehicle = pSpecificVehicle;
  CGameLogic::SkipTimer = CTimer::m_snTimeInMilliseconds;
  if ( pSpecificVehicle )
    CEntity::RegisterReference(pSpecificVehicle, &CGameLogic::SkipVehicle);
  CGameLogic::SkipToBeFinishedByScript = bScriptToFinish;
}

//----- (00309BDC) --------------------------------------------------------
bool CGameLogic::SkipCanBeActivated()
{
  _BOOL4 result; // r0
  Int32 v1; // r0
  bool v2; // zf
  CVehicle *v3; // r4
  CPlayerPed *PlayerPed; // r0

  result = 0;
  if ( CGame::currArea == AREA_MAIN_MAP && !TheCamera.m_bFading )
  {
    v1 = CGameLogic::SkipState;
    v2 = CGameLogic::SkipState == 4;
    if ( CGameLogic::SkipState != 4 )
      v2 = CGameLogic::SkipState == 1;
    if ( v2 )
    {
      if ( FindPlayerVehicle(-1, 0) )
      {
        v3 = CGameLogic::SkipVehicle;
        if ( (!CGameLogic::SkipVehicle || v3 == FindPlayerVehicle(-1, 0))
          && (FindPlayerVehicle(-1, 0)->m_vehicleType == 9
           || !FindPlayerVehicle(-1, 0)->m_vehicleType
           || FindPlayerVehicle(-1, 0)->m_vehicleType == 1
           || FindPlayerVehicle(-1, 0)->m_vehicleType == 2
           || FindPlayerVehicle(-1, 0)->m_vehicleType == 10) )
        {
          return 1;
        }
      }
      v1 = CGameLogic::SkipState;
    }
    if ( v1 != 4 )
      return 0;
    PlayerPed = FindPlayerPed(-1);
    return CPedIntelligence::GetTaskSwim(PlayerPed->m_pPedIntelligence) != 0;
  }
  return result;
}

//----- (00309CC4) --------------------------------------------------------
int CGameLogic::IsSkipWaitingForScriptToFadeIn()
{
  int result; // r0

  result = 0;
  if ( CGameLogic::SkipState == 5 )
  {
    CGameLogic::SkipState = 0;
    return 1;
  }
  return result;
}

//----- (00309CE8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall CGameLogic::IsPointWithinLineArea(CVector *pPointArray, Int32 NumPoints, CVector TestPoint)
{
  float y; // r10
  float x; // r11
  int v6; // r4
  char v7; // r9
  float *p_y; // r5
  int v9; // r0
  int v10; // r8
  bool v11; // zf
  float v12; // r2
  int v13; // r0

  y = TestPoint.y;
  x = TestPoint.x;
  if ( NumPoints < 1 )
    return 0;
  v6 = NumPoints - 1;
  v7 = 0;
  p_y = &pPointArray->y;
  v9 = 0;
  do
  {
    v10 = v9 + 1;
    v11 = v6 == v9;
    LOWORD(v12) = 9216;
    v13 = v9 + 1;
    if ( v11 )
      v13 = 0;
    HIWORD(v12) = 18804;
    v7 += CCollision::Test2DLineAgainst2DLine(
            x,
            y,
            v12,
            0.0,
            *(p_y - 1),
            *p_y,
            pPointArray[v13].x - *(p_y - 1),
            pPointArray[v13].y - *p_y);
    p_y += 3;
    v9 = v10;
  }
  while ( NumPoints != v10 );
  return v7 & 1;
}
// 309CE8: fragmented variable at 0:r2.8,8:^38.4 may be wrong

//----- (00309D74) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __fastcall CGameLogic::CalcDistanceToForbiddenTrainCrossing(
        CVector Point,
        CVector Forward,
        int bIgnoreSpeed,
        CVector *pVecToBarrier)
{
  float x; // r6
  float v5; // r8
  float z; // r5
  float y; // r4
  float v8; // s16
  float v9; // s6
  float v10; // s6
  float v11; // s6

  x = Point.x;
  v5 = Forward.x;
  z = Point.z;
  y = Point.y;
  v8 = 100000.0;
  if ( CStats::GetStatValue(0xB5u) == 0.0
    && ((float)((float)((float)(0.0 - z) * Forward.z)
              + (float)((float)((float)(82.0 - x) * v5) + (float)((float)(-1021.0 - y) * Forward.y))) > 0.0
     || bIgnoreSpeed == 1) )
  {
    v8 = 100000.0;
    v9 = sqrtf((float)((float)(x + -82.0) * (float)(x + -82.0)) + (float)((float)(y + 1021.0) * (float)(y + 1021.0)));
    if ( v9 < 100000.0 )
    {
      v8 = v9;
      pVecToBarrier->x = 82.0 - x;
      pVecToBarrier->y = -1021.0 - y;
      pVecToBarrier->z = 0.0 - z;
    }
  }
  if ( CStats::GetStatValue(0xB5u) == 1.0
    && ((float)((float)((float)(0.0 - z) * Forward.z)
              + (float)((float)((float)(-1568.0 - x) * v5) + (float)((float)(537.0 - y) * Forward.y))) > 0.0
     || bIgnoreSpeed == 1) )
  {
    v10 = sqrtf((float)((float)(x + 1568.0) * (float)(x + 1568.0)) + (float)((float)(y + -537.0) * (float)(y + -537.0)));
    if ( v10 < v8 )
    {
      v8 = v10;
      pVecToBarrier->x = -1568.0 - x;
      pVecToBarrier->y = 537.0 - y;
      pVecToBarrier->z = 0.0 - z;
    }
  }
  if ( CStats::GetStatValue(0xB5u) <= 1.0
    && ((float)((float)((float)(0.0 - z) * Forward.z)
              + (float)((float)((float)(2770.0 - x) * v5) + (float)((float)(277.0 - y) * Forward.y))) > 0.0
     || bIgnoreSpeed == 1) )
  {
    v11 = sqrtf((float)((float)(x + -2770.0) * (float)(x + -2770.0)) + (float)((float)(y + -277.0) * (float)(y + -277.0)));
    if ( v11 < v8 )
    {
      v8 = v11;
      pVecToBarrier->x = 2770.0 - x;
      pVecToBarrier->y = 277.0 - y;
      pVecToBarrier->z = 0.0 - z;
    }
  }
  return v8;
}
// 309D74: fragmented variable at 0:r3.4,4:^38.8 may be wrong
// 309D74: variables would overlap: 0:r3.4,4:^38.8 and ^38.4
// 309D74: variables would overlap: 0:r3.4,4:^38.8 and ^3C.4

//----- (00309FD4) --------------------------------------------------------
Int32 __fastcall CGameLogic::FindCityClosestToPoint(CVector Point)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float v3; // s10
  float v4; // s6
  Int32 result; // r0
  float v6; // s4
  float v7; // s6
  float v8; // s4

  v1.n64_f32[0] = Point.x + -1670.0;
  v3 = Point.x + -2161.0;
  v4 = Point.x + 1810.0;
  LODWORD(Point.x) = 1;
  v6 = (float)(v4 * v4) + (float)((float)(Point.y + -884.0) * (float)(Point.y + -884.0));
  v1.n64_f32[0] = sqrtf(
                    (float)(v1.n64_f32[0] * v1.n64_f32[0])
                  + (float)((float)(Point.y + 1137.0) * (float)(Point.y + 1137.0)));
  v2.n64_f32[0] = sqrtf((float)(v3 * v3) + (float)((float)(Point.y + -2140.0) * (float)(Point.y + -2140.0)));
  LODWORD(v7) = vmin_f32(v2, v1).n64_u32[0];
  v8 = sqrtf(v6);
  if ( v2.n64_f32[0] < v1.n64_f32[0] )
    result = 3;
  if ( v8 < v7 )
    return 2;
  return result;
}
// 30A042: variable 'v2' is possibly undefined
// 30A042: variable 'v1' is possibly undefined

//----- (0030A074) --------------------------------------------------------
bool CGameLogic::LaRiotsActiveHere()
{
  _BOOL4 result; // r0
  CVector v1; // [sp+4h] [bp-14h] BYREF

  FindPlayerCoors(&v1, -1);
  result = 0;
  if ( v1.z <= 950.0 )
  {
    if ( CCheat::m_aCheatsActive[77] )
      return 1;
    if ( gbLARiots )
    {
      FindPlayerCoors(&v1, -1);
      if ( v1.x > 1620.0 && v1.x < 2824.0 && v1.y > -2178.0 && v1.y < -1067.0 )
        return 1;
      if ( v1.x > 157.0 && v1.x < 1630.0 && v1.y > -1950.0 && v1.y < -1192.0 )
        return 1;
    }
  }
  return result;
}

//----- (0030A170) --------------------------------------------------------
void __fastcall CGameLogic::DoWeaponStuffAtStartOf2PlayerGame(bool bGivePlayer2Weapons)
{
  _BOOL4 v1; // r4
  CPlayerPed *PlayerPed; // r0
  __int64 v3; // d17
  __int64 v4; // d18
  __int64 v5; // d19
  __int64 v6; // d16
  __int64 v7; // d17
  __int64 v8; // d19
  __int64 v9; // d16
  __int64 v10; // d17
  __int64 v11; // d19
  __int64 v12; // d16
  __int64 v13; // d17
  __int64 v14; // d19
  __int64 v15; // d16
  __int64 v16; // d17
  __int64 v17; // d19
  __int64 v18; // d16
  __int64 v19; // d17
  __int64 v20; // d19
  __int64 v21; // d16
  __int64 v22; // d17
  __int64 v23; // d19
  __int64 v24; // d16
  __int64 v25; // d17
  __int64 v26; // d19
  __int64 v27; // d16
  __int64 v28; // d17
  __int64 v29; // d19
  __int64 v30; // d16
  __int64 v31; // d17
  __int64 v32; // d19
  __int64 v33; // d16
  __int64 v34; // d17
  __int64 v35; // d19
  __int64 v36; // d16
  __int64 v37; // d17
  __int64 v38; // d19
  CWeapon *v39; // r2
  __int64 v40; // d19
  __int64 v41; // d16
  __int64 v42; // d17
  CPlayerPed *v43; // r0
  int i; // r6
  CPlayerPed *v45; // r4
  eWeaponType v46; // r5
  CPlayerPed *v47; // r0
  int8 m_nChosenWeapon; // r4

  v1 = bGivePlayer2Weapons;
  PlayerPed = FindPlayerPed(0);
  v3 = *(_QWORD *)&PlayerPed->m_WeaponSlots[0].m_nAmmoInClip;
  v4 = *(_QWORD *)&PlayerPed->m_WeaponSlots[0].m_nAmmoTotal;
  v5 = *(_QWORD *)&PlayerPed->m_WeaponSlots[0].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_eWeaponType = *(_QWORD *)&PlayerPed->m_WeaponSlots[0].m_eWeaponType;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_nAmmoInClip = v3;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_nAmmoTotal = v4;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_bFirstPersonWeaponModeSelected = v5;
  v6 = *(_QWORD *)&PlayerPed->m_WeaponSlots[1].m_eWeaponType;
  v7 = *(_QWORD *)&PlayerPed->m_WeaponSlots[1].m_nAmmoInClip;
  v8 = *(_QWORD *)&PlayerPed->m_WeaponSlots[1].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[1].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_bFirstPersonWeaponModeSelected = v8;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_eWeaponType = v6;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_nAmmoInClip = v7;
  v9 = *(_QWORD *)&PlayerPed->m_WeaponSlots[2].m_eWeaponType;
  v10 = *(_QWORD *)&PlayerPed->m_WeaponSlots[2].m_nAmmoInClip;
  v11 = *(_QWORD *)&PlayerPed->m_WeaponSlots[2].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[2].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_bFirstPersonWeaponModeSelected = v11;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_eWeaponType = v9;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_nAmmoInClip = v10;
  v12 = *(_QWORD *)&PlayerPed->m_WeaponSlots[3].m_eWeaponType;
  v13 = *(_QWORD *)&PlayerPed->m_WeaponSlots[3].m_nAmmoInClip;
  v14 = *(_QWORD *)&PlayerPed->m_WeaponSlots[3].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[3].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_bFirstPersonWeaponModeSelected = v14;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_eWeaponType = v12;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_nAmmoInClip = v13;
  v15 = *(_QWORD *)&PlayerPed->m_WeaponSlots[4].m_eWeaponType;
  v16 = *(_QWORD *)&PlayerPed->m_WeaponSlots[4].m_nAmmoInClip;
  v17 = *(_QWORD *)&PlayerPed->m_WeaponSlots[4].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[4].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_bFirstPersonWeaponModeSelected = v17;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_eWeaponType = v15;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_nAmmoInClip = v16;
  v18 = *(_QWORD *)&PlayerPed->m_WeaponSlots[5].m_eWeaponType;
  v19 = *(_QWORD *)&PlayerPed->m_WeaponSlots[5].m_nAmmoInClip;
  v20 = *(_QWORD *)&PlayerPed->m_WeaponSlots[5].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[5].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_bFirstPersonWeaponModeSelected = v20;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_eWeaponType = v18;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_nAmmoInClip = v19;
  v21 = *(_QWORD *)&PlayerPed->m_WeaponSlots[6].m_eWeaponType;
  v22 = *(_QWORD *)&PlayerPed->m_WeaponSlots[6].m_nAmmoInClip;
  v23 = *(_QWORD *)&PlayerPed->m_WeaponSlots[6].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[6].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_bFirstPersonWeaponModeSelected = v23;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_eWeaponType = v21;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_nAmmoInClip = v22;
  v24 = *(_QWORD *)&PlayerPed->m_WeaponSlots[7].m_eWeaponType;
  v25 = *(_QWORD *)&PlayerPed->m_WeaponSlots[7].m_nAmmoInClip;
  v26 = *(_QWORD *)&PlayerPed->m_WeaponSlots[7].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[7].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_bFirstPersonWeaponModeSelected = v26;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_eWeaponType = v24;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_nAmmoInClip = v25;
  v27 = *(_QWORD *)&PlayerPed->m_WeaponSlots[8].m_eWeaponType;
  v28 = *(_QWORD *)&PlayerPed->m_WeaponSlots[8].m_nAmmoInClip;
  v29 = *(_QWORD *)&PlayerPed->m_WeaponSlots[8].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[8].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_bFirstPersonWeaponModeSelected = v29;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_eWeaponType = v27;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_nAmmoInClip = v28;
  v30 = *(_QWORD *)&PlayerPed->m_WeaponSlots[9].m_eWeaponType;
  v31 = *(_QWORD *)&PlayerPed->m_WeaponSlots[9].m_nAmmoInClip;
  v32 = *(_QWORD *)&PlayerPed->m_WeaponSlots[9].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[9].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_bFirstPersonWeaponModeSelected = v32;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_eWeaponType = v30;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_nAmmoInClip = v31;
  v33 = *(_QWORD *)&PlayerPed->m_WeaponSlots[10].m_eWeaponType;
  v34 = *(_QWORD *)&PlayerPed->m_WeaponSlots[10].m_nAmmoInClip;
  v35 = *(_QWORD *)&PlayerPed->m_WeaponSlots[10].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[10].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_bFirstPersonWeaponModeSelected = v35;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_eWeaponType = v33;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_nAmmoInClip = v34;
  v36 = *(_QWORD *)&PlayerPed->m_WeaponSlots[11].m_eWeaponType;
  v37 = *(_QWORD *)&PlayerPed->m_WeaponSlots[11].m_nAmmoInClip;
  v38 = *(_QWORD *)&PlayerPed->m_WeaponSlots[11].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_nAmmoTotal = *(_QWORD *)&PlayerPed->m_WeaponSlots[11].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_bFirstPersonWeaponModeSelected = v38;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_eWeaponType = v36;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_nAmmoInClip = v37;
  v39 = &PlayerPed->m_WeaponSlots[12];
  PlayerPed = (CPlayerPed *)((char *)PlayerPed + 1792);
  v40 = *(_QWORD *)&PlayerPed->m_transform.m_translate.y;
  v41 = *(_QWORD *)&v39->m_eWeaponType;
  v42 = *(_QWORD *)&v39->m_nAmmoInClip;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_nAmmoTotal = *(_QWORD *)&PlayerPed->_vptr$CPlaceable;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_bFirstPersonWeaponModeSelected = v40;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_eWeaponType = v41;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_nAmmoInClip = v42;
  if ( v1 )
  {
    v43 = FindPlayerPed(0);
    for ( i = 1444; i != 1808; i += 28 )
    {
      if ( *(int (***)(void))((char *)&v43->_vptr$CPlaceable + i) )
      {
        v45 = FindPlayerPed(1);
        v46 = *(eWeaponType *)((char *)&FindPlayerPed(0)->_vptr$CPlaceable + i);
        v47 = FindPlayerPed(0);
        CPed::GiveWeapon(v45, v46, *(_DWORD *)((char *)&v47->m_transform.m_translate.z + i), 1);
      }
      v43 = FindPlayerPed(0);
    }
    CPlayerPed::PickWeaponAllowedFor2Player(v43);
    m_nChosenWeapon = FindPlayerPed(0)->m_pPlayerData->m_nChosenWeapon;
    FindPlayerPed(1)->m_pPlayerData->m_nChosenWeapon = m_nChosenWeapon;
  }
}

//----- (0030A390) --------------------------------------------------------
void __fastcall CGameLogic::StorePedsWeapons(CPed *pPed)
{
  __int64 v1; // d17
  __int64 v2; // d18
  __int64 v3; // d19
  __int64 v4; // d16
  __int64 v5; // d17
  __int64 v6; // d19
  __int64 v7; // d16
  __int64 v8; // d17
  __int64 v9; // d19
  __int64 v10; // d16
  __int64 v11; // d17
  __int64 v12; // d19
  __int64 v13; // d16
  __int64 v14; // d17
  __int64 v15; // d19
  __int64 v16; // d16
  __int64 v17; // d17
  __int64 v18; // d19
  __int64 v19; // d16
  __int64 v20; // d17
  __int64 v21; // d19
  __int64 v22; // d16
  __int64 v23; // d17
  __int64 v24; // d19
  __int64 v25; // d16
  __int64 v26; // d17
  __int64 v27; // d19
  __int64 v28; // d16
  __int64 v29; // d17
  __int64 v30; // d19
  __int64 v31; // d16
  __int64 v32; // d17
  __int64 v33; // d19
  __int64 v34; // d16
  __int64 v35; // d17
  __int64 v36; // d19
  CWeapon *v37; // r2
  int32 *p_m_nAmmoTotal; // r0
  __int64 v39; // d19
  __int64 v40; // d16
  __int64 v41; // d17

  v1 = *(_QWORD *)&pPed->m_WeaponSlots[0].m_nAmmoInClip;
  v2 = *(_QWORD *)&pPed->m_WeaponSlots[0].m_nAmmoTotal;
  v3 = *(_QWORD *)&pPed->m_WeaponSlots[0].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_eWeaponType = *(_QWORD *)&pPed->m_WeaponSlots[0].m_eWeaponType;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_nAmmoInClip = v1;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_nAmmoTotal = v2;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[0].m_bFirstPersonWeaponModeSelected = v3;
  v4 = *(_QWORD *)&pPed->m_WeaponSlots[1].m_eWeaponType;
  v5 = *(_QWORD *)&pPed->m_WeaponSlots[1].m_nAmmoInClip;
  v6 = *(_QWORD *)&pPed->m_WeaponSlots[1].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[1].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_bFirstPersonWeaponModeSelected = v6;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_eWeaponType = v4;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[1].m_nAmmoInClip = v5;
  v7 = *(_QWORD *)&pPed->m_WeaponSlots[2].m_eWeaponType;
  v8 = *(_QWORD *)&pPed->m_WeaponSlots[2].m_nAmmoInClip;
  v9 = *(_QWORD *)&pPed->m_WeaponSlots[2].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[2].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_bFirstPersonWeaponModeSelected = v9;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_eWeaponType = v7;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[2].m_nAmmoInClip = v8;
  v10 = *(_QWORD *)&pPed->m_WeaponSlots[3].m_eWeaponType;
  v11 = *(_QWORD *)&pPed->m_WeaponSlots[3].m_nAmmoInClip;
  v12 = *(_QWORD *)&pPed->m_WeaponSlots[3].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[3].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_bFirstPersonWeaponModeSelected = v12;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_eWeaponType = v10;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[3].m_nAmmoInClip = v11;
  v13 = *(_QWORD *)&pPed->m_WeaponSlots[4].m_eWeaponType;
  v14 = *(_QWORD *)&pPed->m_WeaponSlots[4].m_nAmmoInClip;
  v15 = *(_QWORD *)&pPed->m_WeaponSlots[4].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[4].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_bFirstPersonWeaponModeSelected = v15;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_eWeaponType = v13;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[4].m_nAmmoInClip = v14;
  v16 = *(_QWORD *)&pPed->m_WeaponSlots[5].m_eWeaponType;
  v17 = *(_QWORD *)&pPed->m_WeaponSlots[5].m_nAmmoInClip;
  v18 = *(_QWORD *)&pPed->m_WeaponSlots[5].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[5].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_bFirstPersonWeaponModeSelected = v18;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_eWeaponType = v16;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[5].m_nAmmoInClip = v17;
  v19 = *(_QWORD *)&pPed->m_WeaponSlots[6].m_eWeaponType;
  v20 = *(_QWORD *)&pPed->m_WeaponSlots[6].m_nAmmoInClip;
  v21 = *(_QWORD *)&pPed->m_WeaponSlots[6].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[6].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_bFirstPersonWeaponModeSelected = v21;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_eWeaponType = v19;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[6].m_nAmmoInClip = v20;
  v22 = *(_QWORD *)&pPed->m_WeaponSlots[7].m_eWeaponType;
  v23 = *(_QWORD *)&pPed->m_WeaponSlots[7].m_nAmmoInClip;
  v24 = *(_QWORD *)&pPed->m_WeaponSlots[7].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[7].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_bFirstPersonWeaponModeSelected = v24;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_eWeaponType = v22;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[7].m_nAmmoInClip = v23;
  v25 = *(_QWORD *)&pPed->m_WeaponSlots[8].m_eWeaponType;
  v26 = *(_QWORD *)&pPed->m_WeaponSlots[8].m_nAmmoInClip;
  v27 = *(_QWORD *)&pPed->m_WeaponSlots[8].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[8].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_bFirstPersonWeaponModeSelected = v27;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_eWeaponType = v25;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[8].m_nAmmoInClip = v26;
  v28 = *(_QWORD *)&pPed->m_WeaponSlots[9].m_eWeaponType;
  v29 = *(_QWORD *)&pPed->m_WeaponSlots[9].m_nAmmoInClip;
  v30 = *(_QWORD *)&pPed->m_WeaponSlots[9].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[9].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_bFirstPersonWeaponModeSelected = v30;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_eWeaponType = v28;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[9].m_nAmmoInClip = v29;
  v31 = *(_QWORD *)&pPed->m_WeaponSlots[10].m_eWeaponType;
  v32 = *(_QWORD *)&pPed->m_WeaponSlots[10].m_nAmmoInClip;
  v33 = *(_QWORD *)&pPed->m_WeaponSlots[10].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[10].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_bFirstPersonWeaponModeSelected = v33;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_eWeaponType = v31;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[10].m_nAmmoInClip = v32;
  v34 = *(_QWORD *)&pPed->m_WeaponSlots[11].m_eWeaponType;
  v35 = *(_QWORD *)&pPed->m_WeaponSlots[11].m_nAmmoInClip;
  v36 = *(_QWORD *)&pPed->m_WeaponSlots[11].m_bFirstPersonWeaponModeSelected;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_nAmmoTotal = *(_QWORD *)&pPed->m_WeaponSlots[11].m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_bFirstPersonWeaponModeSelected = v36;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_eWeaponType = v34;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[11].m_nAmmoInClip = v35;
  v37 = &pPed->m_WeaponSlots[12];
  p_m_nAmmoTotal = &pPed->m_WeaponSlots[12].m_nAmmoTotal;
  v39 = *((_QWORD *)p_m_nAmmoTotal + 1);
  v40 = *(_QWORD *)&v37->m_eWeaponType;
  v41 = *(_QWORD *)&v37->m_nAmmoInClip;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_nAmmoTotal = *(_QWORD *)p_m_nAmmoTotal;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_bFirstPersonWeaponModeSelected = v39;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_eWeaponType = v40;
  *(_QWORD *)&CGameLogic::SavedWeaponSlots[12].m_nAmmoInClip = v41;
}

//----- (0030A538) --------------------------------------------------------
void CGangWars::InitAtStartOfGame()
{
  CGangWars::State = 0;
  CGangWars::bGangWarsActive = 0;
  CGangWars::State2 = 0;
  CGangWars::Provocation = 0.0;
  CGangWars::NumSpecificZones = 0;
  CGangWars::bIsPlayerOnAMission = 0;
}

//----- (0030A598) --------------------------------------------------------
void CGangWars::StartOffensiveGangWar()
{
  CZoneInfo *ZoneInfo; // r0
  int v1; // r2
  int v2; // r3
  unsigned int v3; // r2
  unsigned int v4; // r1
  int v5; // r3
  int v6; // r5
  int v7; // r6
  int v8; // r3
  int v9; // r2
  int v10; // r1
  int v11; // r5
  Int32 *v12; // r6
  int v13; // r3
  int v14; // r2
  int v15; // r5
  Int32 *v16; // r1
  int v17; // r6
  int v18; // r1
  int v19; // r5
  Int32 *v20; // r2
  int v21; // r3
  int v22; // r2
  int v23; // r5
  Int32 *v24; // r1
  signed int v25; // r6
  signed int v26; // r1
  int v27; // r5
  Int32 *v28; // r2
  signed int v29; // r3
  signed int v30; // r10
  int v31; // r9
  Int32 *v32; // r0
  signed int v33; // r2
  GxtChar *v34; // r0
  GxtChar *v35; // r0
  CPedPool *v36; // r4
  int32 m_nSize; // r0
  int v38; // r6
  int v39; // r5
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r11
  uint8 *v41; // r8
  CTask *ActiveTaskByType; // r0
  int v43; // r1
  Int32 v44; // r1
  CZoneInfo *v45; // r0
  __int16 v46; // r2
  signed int v47; // [sp+14h] [bp-2Ch]
  CVector v48; // [sp+18h] [bp-28h] BYREF

  FindPlayerCoors(&v48, -1);
  CGangWars::CoorsOfPlayerAtStartOfWar = v48;
  ZoneInfo = CTheZones::GetZoneInfo(&CGangWars::CoorsOfPlayerAtStartOfWar, &CGangWars::pZoneToFightOver);
  CGangWars::pZoneInfoToFightOver = ZoneInfo;
  CGangWars::Difficulty = CGangWars::TerritoryUnderControlPercentage;
  if ( CGangWars::bTrainingMission )
  {
    if ( &CTheZones::ZoneInfoArray[CGangWars::ZoneInfoForTraining] != ZoneInfo )
    {
LABEL_3:
      CGangWars::Provocation = 0.0;
      return;
    }
  }
  else if ( CGangWars::NumSpecificZones )
  {
    if ( CGangWars::NumSpecificZones < 1 )
      goto LABEL_3;
    v1 = 0;
    while ( &CTheZones::ZoneInfoArray[CTheZones::NavigationZoneArray[CGangWars::aSpecificZones[v1]].ZoneInfoIndex] != ZoneInfo )
    {
      if ( ++v1 >= CGangWars::NumSpecificZones )
        goto LABEL_3;
    }
  }
  v2 = ZoneInfo->aGangStrengths[0];
  v3 = 0;
  if ( ZoneInfo->aGangStrengths[0] )
  {
    CGangWars::Gang2 = CGangWars::Gang1;
    CGangWars::Gang1 = 0;
    v3 = ZoneInfo->aGangStrengths[0];
  }
  v4 = ZoneInfo->aGangStrengths[2];
  v5 = v2 + v4;
  if ( v3 >= v4 )
  {
    if ( ZoneInfo->aGangStrengths[2] )
      CGangWars::Gang2 = 2;
    else
      v4 = 0;
    v6 = v3;
  }
  else
  {
    CGangWars::Gang2 = CGangWars::Gang1;
    CGangWars::Gang1 = 2;
    v4 = v3;
    v6 = ZoneInfo->aGangStrengths[2];
  }
  v7 = ZoneInfo->aGangStrengths[3];
  v8 = v5 + v7;
  if ( v6 >= v7 )
  {
    if ( (int)v4 >= v7 )
    {
      v9 = v6;
      v7 = v4;
    }
    else
    {
      CGangWars::Gang2 = 3;
      v9 = v6;
    }
  }
  else
  {
    CGangWars::Gang2 = CGangWars::Gang1;
    CGangWars::Gang1 = 3;
    v7 = v6;
    v9 = ZoneInfo->aGangStrengths[3];
  }
  v10 = ZoneInfo->aGangStrengths[4];
  v11 = v8 + v10;
  if ( v9 < v10 )
  {
    v12 = &CGangWars::Gang1;
    CGangWars::Gang2 = CGangWars::Gang1;
    v13 = v10;
    v10 = v9;
LABEL_27:
    *v12 = 4;
    goto LABEL_29;
  }
  if ( v7 < v10 )
  {
    v12 = &CGangWars::Gang2;
    v13 = v9;
    goto LABEL_27;
  }
  v13 = v9;
  v10 = v7;
LABEL_29:
  v14 = ZoneInfo->aGangStrengths[5];
  v15 = v11 + v14;
  if ( v13 < v14 )
  {
    v16 = &CGangWars::Gang1;
    CGangWars::Gang2 = CGangWars::Gang1;
    v17 = v14;
    v14 = v13;
LABEL_33:
    *v16 = 5;
    goto LABEL_35;
  }
  if ( v10 < v14 )
  {
    v17 = v13;
    v16 = &CGangWars::Gang2;
    goto LABEL_33;
  }
  v17 = v13;
  v14 = v10;
LABEL_35:
  v18 = ZoneInfo->aGangStrengths[6];
  v19 = v15 + v18;
  if ( v17 < v18 )
  {
    v20 = &CGangWars::Gang1;
    CGangWars::Gang2 = CGangWars::Gang1;
    v21 = v18;
    v18 = v17;
LABEL_39:
    *v20 = 6;
    goto LABEL_41;
  }
  if ( v14 < v18 )
  {
    v21 = v17;
    v20 = &CGangWars::Gang2;
    goto LABEL_39;
  }
  v21 = v17;
  v18 = v14;
LABEL_41:
  v22 = ZoneInfo->aGangStrengths[7];
  v23 = v19 + v22;
  if ( v21 < v22 )
  {
    v24 = &CGangWars::Gang1;
    CGangWars::Gang2 = CGangWars::Gang1;
    v25 = v22;
    v22 = v21;
LABEL_45:
    *v24 = 7;
    goto LABEL_47;
  }
  if ( v18 < v22 )
  {
    v25 = v21;
    v24 = &CGangWars::Gang2;
    goto LABEL_45;
  }
  v25 = v21;
  v22 = v18;
LABEL_47:
  v26 = ZoneInfo->aGangStrengths[8];
  v27 = v23 + v26;
  if ( v25 < v26 )
  {
    v28 = &CGangWars::Gang1;
    CGangWars::Gang2 = CGangWars::Gang1;
    v29 = v26;
    v26 = v25;
LABEL_51:
    *v28 = 8;
    goto LABEL_53;
  }
  if ( v22 < v26 )
  {
    v29 = v25;
    v28 = &CGangWars::Gang2;
    goto LABEL_51;
  }
  v29 = v25;
  v26 = v22;
LABEL_53:
  v30 = ZoneInfo->aGangStrengths[9];
  v31 = v27 + v30;
  if ( v29 >= v30 )
  {
    if ( v26 >= v30 )
    {
      v33 = v29;
      v30 = v26;
      goto LABEL_59;
    }
    v33 = v29;
    v32 = &CGangWars::Gang2;
  }
  else
  {
    v32 = &CGangWars::Gang1;
    CGangWars::Gang2 = CGangWars::Gang1;
    v33 = v30;
    v30 = v29;
  }
  *v32 = 9;
LABEL_59:
  CGangWars::Provocation = 0.0;
  if ( v31 <= 0 || (CGangWars::Gang1 | 2) != 2 || CGangWars::State2 )
    return;
  v47 = v33;
  v34 = CText::Get(&TheText, "GW_PROV");
  CMessages::AddMessage("GW_PROV", v34, 0x1194u, 1u, 1);
  v35 = CText::Get(&TheText, "GW_PROV");
  CMessages::AddToPreviousBriefArray("GW_PROV", v35, -1, -1, -1, -1, -1, -1, 0);
  v36 = CPools::ms_pPedPool;
  CGangWars::State = 1;
  CGangWars::TimeStarted = CTimer::m_snTimeInMilliseconds;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v38 = m_nSize - 1;
    v39 = 1996 * m_nSize - 908;
    do
    {
      if ( (v36->m_aFlags[v38] & 0x80u) == 0 )
      {
        m_aStorage = v36->m_aStorage;
        v41 = &(*v36->m_aStorage)[v39];
        if ( v41 != (uint8 *)&elf_hash_bucket[209]
          && !CPed::IsPlayer((const CPed *)(v41 - 1088))
          && (*((_DWORD *)v41 + 87) & 0xFFFFFFFE) == 4 )
        {
          ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                               (const CTaskManager *)(*(_DWORD *)&(*m_aStorage)[v39] + 4),
                               912);
          if ( ActiveTaskByType )
            ActiveTaskByType[1].m_pParent = (CTask *)&byte_7;
        }
      }
      --v38;
      v39 -= 1996;
    }
    while ( v38 != -1 );
  }
  v43 = v31 / 15;
  if ( v31 > 44 )
    v43 = 2;
  CGangWars::WarFerocity = v43;
  if ( CStats::GetStatValue(0xB5u) < 0.0 )
  {
    if ( CGangWars::TerritoryUnderControlPercentage <= 0.4 )
    {
      v44 = 0;
      goto LABEL_78;
    }
    if ( CGangWars::TerritoryUnderControlPercentage >= 0.5 )
    {
      v44 = 5;
LABEL_78:
      CGangWars::WarFerocity = v44;
    }
  }
  if ( CGangWars::bTrainingMission )
    CGangWars::WarFerocity = 0;
  if ( v47 > (int)(v30 / 3u) )
    CGangWars::Gang2 = CGangWars::Gang1;
  CGangWars::TellGangMembersTo(0);
  v45 = CGangWars::pZoneInfoToFightOver;
  v46 = *(_WORD *)((char *)CGangWars::pZoneInfoToFightOver + 15);
  *(_DWORD *)&CGangWars::pZoneInfoToFightOver->RadarRed = -1610612481;
  *(_WORD *)((char *)v45 + 15) = v46 & 0xFF9F | 0x40;
  pDriveByCar = 0;
}
// 7: using guessed type char byte_7;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030AB10) --------------------------------------------------------
bool __fastcall CGangWars::CanPlayerStartAGangWarHere(CZoneInfo *pZoneToTest)
{
  int v2; // r2

  if ( CGangWars::bTrainingMission )
    return &CTheZones::ZoneInfoArray[CGangWars::ZoneInfoForTraining] == pZoneToTest;
  if ( CGangWars::NumSpecificZones )
  {
    if ( CGangWars::NumSpecificZones < 1 )
      return 0;
    v2 = 0;
    while ( &CTheZones::ZoneInfoArray[CTheZones::NavigationZoneArray[CGangWars::aSpecificZones[v2]].ZoneInfoIndex] != pZoneToTest )
    {
      if ( ++v2 >= CGangWars::NumSpecificZones )
        return 0;
    }
  }
  return 1;
}

//----- (0030ABA8) --------------------------------------------------------
void CGangWars::ClearTheStreets()
{
  CPedPool *v0; // r9
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r5
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r10
  uint8 *v5; // r4
  CTask *ActiveTaskByType; // r0

  v0 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 1996 * m_nSize - 908;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        m_aStorage = v0->m_aStorage;
        v5 = &(*v0->m_aStorage)[v3];
        if ( v5 != (uint8 *)&elf_hash_bucket[209]
          && !CPed::IsPlayer((const CPed *)(v5 - 1088))
          && (*((_DWORD *)v5 + 87) & 0xFFFFFFFE) == 4 )
        {
          ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                               (const CTaskManager *)(*(_DWORD *)&(*m_aStorage)[v3] + 4),
                               912);
          if ( ActiveTaskByType )
            ActiveTaskByType[1].m_pParent = (CTask *)&byte_7;
        }
      }
      --v2;
      v3 -= 1996;
    }
    while ( v2 != -1 );
  }
}
// 7: using guessed type char byte_7;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030AC2C) --------------------------------------------------------
void __fastcall CGangWars::TellGangMembersTo(Int32 ToDoWhat)
{
  CPedPool *v2; // r10
  int32 m_nSize; // r0
  int v4; // r8
  int i; // r5
  int v6; // r0
  CPlayerPed *PlayerPed; // r11
  CTaskComplexKillPedOnFoot *v8; // r6
  CPed *v9; // r1
  int v10; // r0
  CTaskComplexCarDriveWander *v11; // r6
  unsigned __int16 v12; // r0
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r9
  uint8 *v14; // r4
  Int32 v15; // [sp+Ch] [bp-54h]
  CEventScriptCommand v16; // [sp+10h] [bp-50h] BYREF

  v2 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v4 = m_nSize - 1;
    v15 = ToDoWhat;
    for ( i = 1996 * m_nSize - 908; ; i -= 1996 )
    {
      if ( (v2->m_aFlags[v4] & 0x80u) != 0 )
        goto LABEL_19;
      m_aStorage = v2->m_aStorage;
      v14 = &(*v2->m_aStorage)[i];
      if ( v14 == (uint8 *)&elf_hash_bucket[209] )
        goto LABEL_19;
      if ( CPed::IsPlayer((const CPed *)(v14 - 1088)) )
        goto LABEL_19;
      v6 = *((_DWORD *)v14 + 87);
      if ( v6 == 8 || (unsigned int)(v6 - 7) > 9 )
        goto LABEL_19;
      if ( ToDoWhat != 1 )
      {
        if ( !ToDoWhat )
        {
          PlayerPed = FindPlayerPed(-1);
          v8 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
          v9 = PlayerPed;
          ToDoWhat = v15;
          CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v8, v9, -1, 0, 0, 0, 2);
          CEventScriptCommand::CEventScriptCommand(&v16, 3, v8, 0);
          CEventGroup::Add((CEventGroup *)(*(_DWORD *)&(*m_aStorage)[i] + 104), &v16, 0);
          CEventScriptCommand::~CEventScriptCommand(&v16);
        }
        goto LABEL_19;
      }
      v10 = *((_DWORD *)v14 + 17);
      if ( (v10 & 0x100) == 0 )
        goto LABEL_12;
      if ( !CVehicle::IsDriver(*((const CVehicle **)v14 + 84), (const CPed *)(v14 - 1088)) )
        break;
      v11 = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
      CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(v11, *((CVehicle **)v14 + 84), 0, 10.0);
LABEL_15:
      CEventScriptCommand::CEventScriptCommand(&v16, 3, v11, 0);
      CEventGroup::Add((CEventGroup *)(*(_DWORD *)&(*m_aStorage)[i] + 104), &v16, 0);
      CEventScriptCommand::~CEventScriptCommand(&v16);
      ToDoWhat = v15;
LABEL_19:
      if ( --v4 == -1 )
        return;
    }
    v10 = *((_DWORD *)v14 + 17);
LABEL_12:
    if ( (v10 & 0x100) != 0 )
    {
      v11 = (CTaskComplexCarDriveWander *)CTask::operator new(0x60u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v11, *((CVehicle **)v14 + 84), 0, 0);
    }
    else
    {
      v11 = (CTaskComplexCarDriveWander *)CTask::operator new(0x38u);
      v12 = rand();
      CTaskComplexWanderGang::CTaskComplexWanderGang(
        (CTaskComplexWanderGang *)v11,
        4,
        (int)(float)((float)((float)v12 * 0.000015259) * 8.0),
        5000,
        1,
        0.5);
    }
    goto LABEL_15;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030ADF0) --------------------------------------------------------
void CGangWars::StartDefensiveGangWar()
{
  GxtChar *v0; // r0
  int v1; // r0
  int32 v2; // r1
  CZoneInfo *v3; // r0
  __int16 v4; // r1
  CVector v5; // [sp+Ch] [bp-1Ch] BYREF

  if ( CTheScripts::IsPlayerOnAMission() || CGangWars::PickZoneToAttack() != 1 )
  {
    CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10)
                                                                               * 0.9)
                                                                       + 0.6)
                                                               * 1080000.0);
  }
  else
  {
    CGangWars::Difficulty = CGangWars::TerritoryUnderControlPercentage;
    v0 = CText::Get(&TheText, "GW_ATK");
    CHud::SetHelpMessage("GW_ATK", v0, 1, 0, 1, 0);
    CGangWars::State2 = 1;
    FindPlayerCoors(&v5, -1);
    CGangWars::FightTimer = (int)(float)((float)(sqrtf(
                                                   (float)((float)(v5.x - CGangWars::PointOfAttack.x)
                                                         * (float)(v5.x - CGangWars::PointOfAttack.x))
                                                 + (float)((float)(v5.y - CGangWars::PointOfAttack.y)
                                                         * (float)(v5.y - CGangWars::PointOfAttack.y)))
                                               * 200.0)
                                       + 240000.0);
    v1 = CRadar::SetCoordBlip(
           4,
           SLODWORD(CGangWars::PointOfAttack.x),
           SLODWORD(CGangWars::PointOfAttack.y),
           SLODWORD(CGangWars::PointOfAttack.z),
           (gaGangColoursR[CGangWars::Gang1] << 24) | (gaGangColoursG[CGangWars::Gang1] << 16) | (gaGangColoursB[CGangWars::Gang1] << 8) | 0xFF,
           2);
    CGangWars::RadarBlip = v1;
    switch ( CGangWars::Gang1 )
    {
      case 0:
        v2 = 59;
        break;
      case 2:
      case 4:
        v2 = 60;
        break;
      case 3:
        v2 = 58;
        break;
      default:
        v2 = 19;
        break;
    }
    CRadar::SetBlipSprite(v1, v2);
    v3 = CGangWars::pZoneInfoToFightOver;
    CGangWars::bPlayerIsCloseby = 0;
    v4 = *(_WORD *)((char *)CGangWars::pZoneInfoToFightOver + 15);
    *(_DWORD *)&CGangWars::pZoneInfoToFightOver->RadarRed = -1610612481;
    *(_WORD *)((char *)v3 + 15) = v4 & 0xFF9F | 0x40;
  }
}

//----- (0030AFF4) --------------------------------------------------------
int CGangWars::PickZoneToAttack()
{
  Int32 v0; // r4
  CZone *v1; // r6
  CZone *v2; // r5
  int v3; // r10
  CZoneInfo *v4; // r9
  unsigned int v5; // r0
  unsigned int v6; // r1
  bool v7; // cc
  Int32 v8; // r0
  int x2; // r2
  int y2; // r3
  int y1; // r1
  float v12; // s2
  float32x2_t v13; // d16
  unsigned __int64 v14; // d0
  CZoneInfo *v16; // [sp+28h] [bp-50h]
  CVector v17; // [sp+30h] [bp-48h] BYREF

  CCarCtrl::InitSequence(CTheZones::TotalNumberOfNavigationZones);
  if ( !CTheZones::TotalNumberOfNavigationZones )
    return 0;
  v0 = 0;
  while ( 1 )
  {
    v1 = &CTheZones::NavigationZoneArray[CCarCtrl::FindSequenceElement(v0)];
    if ( v1->ZoneInfoIndex )
    {
      v16 = &CTheZones::ZoneInfoArray[v1->ZoneInfoIndex];
      if ( v16->aGangStrengths[2] + (unsigned int)v16->aGangStrengths[0] >= 0x14 )
      {
        if ( CTheZones::TotalNumberOfNavigationZones )
          break;
      }
    }
LABEL_18:
    if ( ++v0 >= CTheZones::TotalNumberOfNavigationZones )
      return 0;
  }
  v2 = CTheZones::NavigationZoneArray;
  v3 = 0;
  while ( 1 )
  {
    if ( v2->ZoneInfoIndex && (v2->x1 > 2500 || v2->x2 < 2500 || v2->y1 > -1666 || v2->y2 < -1666) )
    {
      v4 = &CTheZones::ZoneInfoArray[v2->ZoneInfoIndex];
      if ( v4->aGangStrengths[1] >= 0x10u && CTheZones::Calc2DDistanceBetween2Zones(v1, v2) < 10.0 )
      {
        v5 = v16->aGangStrengths[2];
        v6 = v16->aGangStrengths[0];
        CGangWars::pZoneInfoToFightOver = v4;
        v7 = v6 > v5;
        v8 = 2;
        if ( v7 )
          v8 = 0;
        x2 = v2->x2;
        y2 = v2->y2;
        CGangWars::Gang1 = v8;
        y1 = v2->y1;
        CGangWars::pZoneToFightOver = v2;
        v12 = (float)(v2->x1 + x2);
        CGangWars::PointOfAttack.z = 10.0;
        CGangWars::PointOfAttack.x = v12 * 0.5;
        CGangWars::PointOfAttack.y = (float)(y1 + y2) * 0.5;
        FindPlayerCoors(&v17, -1);
        v13.n64_u64[0] = vsub_f32(*(float32x2_t *)&CGangWars::PointOfAttack.x, *(float32x2_t *)&v17.x).n64_u64[0];
        v14 = vmul_f32(v13, v13).n64_u64[0];
        if ( sqrtf(*(float *)&v14 + *((float *)&v14 + 1)) > 60.0 )
          return 1;
      }
    }
    ++v3;
    ++v2;
    if ( v3 >= CTheZones::TotalNumberOfNavigationZones )
      goto LABEL_18;
  }
}

//----- (0030B214) --------------------------------------------------------
UInt32 CGangWars::CalculateTimeTillNextAttack()
{
  return (unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10) * 0.9) + 0.6) * 1080000.0);
}

//----- (0030B260) --------------------------------------------------------
void CGangWars::DoStuffWhenPlayerVictorious()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  int v2; // r2
  CVehiclePool *v3; // r4
  int32 m_nSize; // r0
  int v5; // r5
  int v6; // r6
  uint8 *v7; // r1
  CVehicle *v8; // r0
  bool v9; // zf
  int v10; // r3
  uint8 *v11; // r1
  GxtChar *v12; // r0
  GxtChar *v13; // r0

  CGangWars::ReleasePedsInAttackWave(1, 0);
  v3 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v5 = m_nSize;
    v6 = m_nSize - 1;
    do
    {
      if ( (v3->m_aFlags[v6] & 0x80u) == 0 )
      {
        v7 = v3->m_aStorage[v5];
        v8 = (CVehicle *)(v7 - 2604);
        v9 = v7 == (uint8 *)&elf_hash_bucket[588];
        if ( v7 != (uint8 *)&elf_hash_bucket[588] )
        {
          v2 = *((_DWORD *)v7 - 383);
          v9 = (v2 & 0x800) == 0;
        }
        if ( !v9 )
        {
          v10 = *((_DWORD *)v7 - 384);
          v11 = v7 - 1536;
          *(_DWORD *)v11 = v10;
          *((_DWORD *)v11 + 1) = v2 & 0xFFFFF7FF;
          CVehicle::SetVehicleCreatedBy(v8, 1, 0);
        }
      }
      --v6;
      --v5;
    }
    while ( v6 != -1 );
  }
  CGangWars::CheerVictory();
  CGangWars::State = 0;
  v12 = CText::Get(&TheText, "GW_YRS");
  CMessages::AddMessage("GW_YRS", v12, 0x1194u, 1u, 1);
  v13 = CText::Get(&TheText, "GW_YRS");
  CMessages::AddToPreviousBriefArray("GW_YRS", v13, -1, -1, -1, -1, -1, -1, 0);
  CGangWars::Provocation = 0.0;
  CGangWars::TellGangMembersTo(1);
  CStats::IncrementStat(0x44u, 45.0);
  CTheZones::FillZonesWithGangColours(0);
  v1.n64_u32[0] = 1189765120;
  v0.n64_f32[0] = CGangWars::TimeTillNextAttack + -240000.0;
  LODWORD(CGangWars::TimeTillNextAttack) = vmax_f32(v0, v1).n64_u32[0];
}
// 30B2C6: variable 'v2' is possibly undefined
// 30B370: variable 'v0' is possibly undefined
// 30B370: variable 'v1' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030B3A4) --------------------------------------------------------
Int32 __fastcall CGangWars::ReleasePedsInAttackWave(bool bKillAllBlips, const bool bMakePedsWanderAway)
{
  _BOOL4 v2; // r3
  _BOOL4 v3; // r12
  Int32 v4; // r2
  CPedPool *v5; // r6
  int32 m_nSize; // r4
  int v7; // r1
  int i; // r9
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r11
  uint8 *v10; // r8
  _DWORD *v11; // r10
  int v12; // r1
  int v13; // r3
  int v14; // r12
  __int64 v15; // kr00_8
  CTaskComplexWander *WanderTaskByPedType; // r0
  _BOOL4 v17; // r9
  Int32 v18; // r5
  int v19; // r1
  int v20; // r3
  unsigned int v21; // r12
  _BOOL4 v23; // [sp+8h] [bp-48h]
  Int32 v24; // [sp+Ch] [bp-44h]
  _BOOL4 v25; // [sp+10h] [bp-40h]
  CEventScriptCommand v26; // [sp+1Ch] [bp-34h] BYREF

  v2 = bKillAllBlips;
  v3 = bMakePedsWanderAway;
  v4 = 0;
  v5 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  while ( m_nSize )
  {
    v7 = 1996 * m_nSize--;
    for ( i = v7 - 908; ; i -= 1996 )
    {
      if ( (char)v5->m_aFlags[m_nSize] > -1 )
      {
        m_aStorage = v5->m_aStorage;
        v10 = &(*v5->m_aStorage)[i];
        if ( v10 != (uint8 *)&elf_hash_bucket[209] )
          break;
      }
      if ( --m_nSize == -1 )
        return v4;
    }
    v11 = v10 + 68;
    v12 = *((_DWORD *)v10 + 19);
    if ( (v12 & 0x1000) != 0 )
    {
      v25 = v2;
      v23 = v3;
      v13 = *((_DWORD *)v10 + 18);
      v14 = *((_DWORD *)v10 + 20);
      *v11 = *((_DWORD *)v10 + 17);
      *((_DWORD *)v10 + 18) = v13;
      *((_DWORD *)v10 + 19) = v12 & 0xFFFFEFFF;
      *((_DWORD *)v10 + 20) = v14;
      v24 = v4;
      CPed::SetCharCreatedBy((CPed *)(v10 - 1088), 1u);
      CRadar::ClearBlipForEntity(
        BLIPTYPE_CHAR,
        CPools::ms_pPedPool->m_aFlags[-1093107909 * ((v10 - 1088 - (uint8 *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * ((v10 - 1088 - (uint8 *)CPools::ms_pPedPool->m_aStorage) >> 2)));
      v15 = *(_QWORD *)(v10 + 76);
      v4 = v24 + 1;
      *(_QWORD *)v11 = *(_QWORD *)v11;
      *((_DWORD *)v10 + 19) = v15 & 0xFFFFDFFF;
      v3 = v23;
      *((_DWORD *)v10 + 20) = HIDWORD(v15);
      if ( v23 )
      {
        WanderTaskByPedType = CTaskComplexWander::GetWanderTaskByPedType((const CPed *)(v10 - 1088));
        CEventScriptCommand::CEventScriptCommand(&v26, 3, WanderTaskByPedType, 0);
        CEventGroup::Add((CEventGroup *)(*(_DWORD *)&(*m_aStorage)[i] + 104), &v26, 0);
        *(CAcquaintance *)(v10 + 172) = *CPedType::GetPedTypeAcquaintances(*((_DWORD *)v10 + 87));
        CEventScriptCommand::~CEventScriptCommand(&v26);
        v3 = 1;
        v4 = v24 + 1;
      }
      v2 = v25;
    }
    if ( v2 && (v10[77] & 0x20) != 0 )
    {
      v17 = v3;
      v18 = v4;
      CRadar::ClearBlipForEntity(
        BLIPTYPE_CHAR,
        CPools::ms_pPedPool->m_aFlags[-1093107909 * ((v10 - 1088 - (uint8 *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * ((v10 - 1088 - (uint8 *)CPools::ms_pPedPool->m_aStorage) >> 2)));
      v19 = *((_DWORD *)v10 + 18);
      v4 = v18;
      v20 = *((_DWORD *)v10 + 20);
      v21 = *((_DWORD *)v10 + 19) & 0xFFFFDFFF;
      *v11 = *v11;
      *((_DWORD *)v10 + 18) = v19;
      *((_DWORD *)v10 + 19) = v21;
      *((_DWORD *)v10 + 20) = v20;
      v2 = 1;
      v3 = v17;
    }
  }
  return v4;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030B580) --------------------------------------------------------
void __fastcall CGangWars::ReleaseCarsInAttackWave(int a1, int a2, int a3)
{
  CVehiclePool *v3; // r4
  int32 m_nSize; // r0
  int v5; // r5
  int v6; // r6
  uint8 *v7; // r1
  CVehicle *v8; // r0
  bool v9; // zf
  int v10; // r3
  uint8 *v11; // r1

  v3 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v5 = m_nSize;
    v6 = m_nSize - 1;
    do
    {
      if ( (v3->m_aFlags[v6] & 0x80u) == 0 )
      {
        v7 = v3->m_aStorage[v5];
        v8 = (CVehicle *)(v7 - 2604);
        v9 = v7 == (uint8 *)&elf_hash_bucket[588];
        if ( v7 != (uint8 *)&elf_hash_bucket[588] )
        {
          a3 = *((_DWORD *)v7 - 383);
          v9 = (a3 & 0x800) == 0;
        }
        if ( !v9 )
        {
          v10 = *((_DWORD *)v7 - 384);
          v11 = v7 - 1536;
          *(_DWORD *)v11 = v10;
          *((_DWORD *)v11 + 1) = a3 & 0xFFFFF7FF;
          CVehicle::SetVehicleCreatedBy(v8, 1, 0);
        }
      }
      --v6;
      --v5;
    }
    while ( v6 != -1 );
  }
}
// 30B5D4: variable 'a3' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030B5F8) --------------------------------------------------------
void CGangWars::CheerVictory()
{
  CPlayerPed *PlayerPed; // r0
  CPed *v1; // r4
  const char *v2; // r5
  UInt16 v3; // r1
  CPed *ppNearestPed; // [sp+Ch] [bp-Ch] BYREF

  ppNearestPed = 0;
  PlayerPed = FindPlayerPed(-1);
  CPedGroup::FindDistanceToNearestMember(&CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup], &ppNearestPed);
  v1 = ppNearestPed;
  if ( ppNearestPed )
  {
    v2 = (const char *)CGangWars::pZoneToFightOver;
    if ( !strcasecmp((const char *)CGangWars::pZoneToFightOver, (const char *)&dword_30B710) )
    {
      v3 = 208;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B714) )
    {
      v3 = 209;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B718) )
    {
      v3 = 210;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B71C) )
    {
      v3 = 211;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B720) )
    {
      v3 = 212;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B724) )
    {
      v3 = 213;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B728) )
    {
      v3 = 214;
    }
    else if ( !strcasecmp(v2, (const char *)&dword_30B72C) )
    {
      v3 = 215;
    }
    else if ( !strcasecmp(v2, "LMEX") )
    {
      v3 = 216;
    }
    else if ( !strcasecmp(v2, "LIND") )
    {
      v3 = 217;
    }
    else if ( !strcasecmp(v2, "PLS") )
    {
      v3 = 218;
    }
    else
    {
      if ( strcasecmp(v2, "SUN") )
        return;
      v3 = 219;
    }
    CPed::Say(v1, v3, 0, 1.0, 0, 0, 0);
  }
}
// 30B710: using guessed type int dword_30B710;
// 30B714: using guessed type int dword_30B714;
// 30B718: using guessed type int dword_30B718;
// 30B71C: using guessed type int dword_30B71C;
// 30B720: using guessed type int dword_30B720;
// 30B724: using guessed type int dword_30B724;
// 30B728: using guessed type int dword_30B728;
// 30B72C: using guessed type int dword_30B72C;

//----- (0030B748) --------------------------------------------------------
void CGangWars::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d0
  Int32 v4; // r0
  Int32 v5; // r3
  int v6; // r2
  CVehiclePool *v7; // r4
  int32 m_nSize; // r0
  int v9; // r5
  int v10; // r6
  uint8 *v11; // r1
  CVehicle *v12; // r0
  bool v13; // zf
  int v14; // r3
  uint8 *v15; // r1
  GxtChar *v16; // r0
  GxtChar *v17; // r0
  Int32 v18; // r0
  int v19; // r2
  CVehiclePool *v20; // r4
  int32 v21; // r0
  int v22; // r5
  int v23; // r6
  uint8 *v24; // r1
  CVehicle *v25; // r0
  bool v26; // zf
  int v27; // r3
  uint8 *v28; // r1
  GxtChar *v29; // r0
  GxtChar *v30; // r0
  Int32 v31; // r0
  int v32; // r4
  int v33; // r2
  CVehiclePool *v34; // r4
  int32 v35; // r0
  int v36; // r5
  int v37; // r6
  uint8 *v38; // r1
  CVehicle *v39; // r0
  bool v40; // zf
  int v41; // r3
  uint8 *v42; // r1
  GxtChar *v43; // r0
  GxtChar *v44; // r1
  GxtChar *v45; // r0
  GxtChar *v46; // r1
  float v47; // s0
  GxtChar *v48; // r0
  GxtChar *v49; // r0
  unsigned int v50; // r1
  int v51; // r2
  unsigned int v52; // r1
  float32x2_t v53; // d16
  unsigned __int64 v54; // d0
  int v55; // r6
  GxtChar *v56; // r0
  GxtChar *v57; // r0
  Int32 v58; // r8
  char v59; // r0
  unsigned int v60; // r2
  int v61; // r3
  int v62; // r5
  GxtChar *v63; // r0
  GxtChar *v64; // r0
  int v65; // r5
  unsigned int v66; // r2
  int v67; // r3
  int v68; // r6
  float v69; // s2
  char v70; // r1
  eBlipDisplay v71; // r1
  float32x2_t v72; // d16
  unsigned __int64 v73; // d0
  char v74; // r0
  CVector v75; // [sp+14h] [bp-64h] BYREF
  CVector v76; // [sp+20h] [bp-58h] BYREF
  CVector v77; // [sp+2Ch] [bp-4Ch] BYREF
  CVector v78; // [sp+38h] [bp-40h] BYREF

  if ( CTheScripts::IsPlayerOnAMission() && !CGangWars::bIsPlayerOnAMission && !CGangWars::NumSpecificZones )
    CGangWars::EndGangWar(1);
  CGangWars::bIsPlayerOnAMission = CTheScripts::IsPlayerOnAMission();
  if ( CCutsceneMgr::ms_cutsceneProcessing )
    return;
  if ( (unsigned __int8)CTimer::m_FrameCounter == 56 )
    CGangWars::UpdateTerritoryUnderControlPercentage();
  if ( !CGangWars::bGangWarsActive || CGameLogic::IsCoopGameGoingOn() )
    return;
  v2.n64_u32[0] = 0;
  v0.n64_f32[0] = CGangWars::Provocation + (float)(CTimer::ms_fTimeStep * -0.0005);
  v3.n64_u64[0] = vmax_f32(v0, v2).n64_u64[0];
  CGangWars::Provocation = v3.n64_f32[0];
  switch ( CGangWars::State )
  {
    case 0:
      if ( v3.n64_f32[0] <= 2.1 )
        goto LABEL_80;
      CGangWars::StartOffensiveGangWar();
      goto LABEL_55;
    case 1:
      if ( CTimer::m_snTimeInMilliseconds <= CGangWars::TimeStarted + 10000 )
        goto LABEL_55;
      v4 = CGangWars::WarFerocity;
      if ( CGangWars::WarFerocity <= 0 )
        v4 = 0;
      if ( !CGangWars::CreateAttackWave(v4, 0) )
        goto LABEL_55;
      v5 = 2;
      goto LABEL_51;
    case 2:
      if ( !CGangWars::AttackWaveOvercome() )
        goto LABEL_55;
      CGangWars::ReleasePedsInAttackWave(0, 0);
      v7 = CPools::ms_pVehiclePool;
      m_nSize = CPools::ms_pVehiclePool->m_nSize;
      if ( m_nSize )
      {
        v9 = m_nSize;
        v10 = m_nSize - 1;
        do
        {
          if ( (v7->m_aFlags[v10] & 0x80u) == 0 )
          {
            v11 = v7->m_aStorage[v9];
            v12 = (CVehicle *)(v11 - 2604);
            v13 = v11 == (uint8 *)&elf_hash_bucket[588];
            if ( v11 != (uint8 *)&elf_hash_bucket[588] )
            {
              v6 = *((_DWORD *)v11 - 383);
              v13 = (v6 & 0x800) == 0;
            }
            if ( !v13 )
            {
              v14 = *((_DWORD *)v11 - 384);
              v15 = v11 - 1536;
              *(_DWORD *)v15 = v14;
              *((_DWORD *)v15 + 1) = v6 & 0xFFFFF7FF;
              CVehicle::SetVehicleCreatedBy(v12, 1, 0);
            }
          }
          --v10;
          --v9;
        }
        while ( v10 != -1 );
      }
      if ( CGangWars::MakePlayerGainInfluenceInZone(0.3) )
        goto LABEL_54;
      v16 = CText::Get(&TheText, "GW_CLR1");
      CMessages::AddMessage("GW_CLR1", v16, 0x1194u, 1u, 1);
      v17 = CText::Get(&TheText, "GW_CLR1");
      CMessages::AddToPreviousBriefArray("GW_CLR1", v17, -1, -1, -1, -1, -1, -1, 0);
      v5 = 3;
      goto LABEL_51;
    case 3:
      if ( CTimer::m_snTimeInMilliseconds <= CGangWars::TimeStarted + 10000 )
        goto LABEL_55;
      v18 = CGangWars::WarFerocity + 1;
      if ( CGangWars::WarFerocity + 1 <= 0 )
        v18 = 0;
      if ( !CGangWars::CreateAttackWave(v18, 1) )
        goto LABEL_55;
      v5 = 4;
      goto LABEL_51;
    case 4:
      if ( !CGangWars::AttackWaveOvercome() )
        goto LABEL_55;
      CGangWars::ReleasePedsInAttackWave(0, 0);
      v20 = CPools::ms_pVehiclePool;
      v21 = CPools::ms_pVehiclePool->m_nSize;
      if ( v21 )
      {
        v22 = v21;
        v23 = v21 - 1;
        do
        {
          if ( (v20->m_aFlags[v23] & 0x80u) == 0 )
          {
            v24 = v20->m_aStorage[v22];
            v25 = (CVehicle *)(v24 - 2604);
            v26 = v24 == (uint8 *)&elf_hash_bucket[588];
            if ( v24 != (uint8 *)&elf_hash_bucket[588] )
            {
              v19 = *((_DWORD *)v24 - 383);
              v26 = (v19 & 0x800) == 0;
            }
            if ( !v26 )
            {
              v27 = *((_DWORD *)v24 - 384);
              v28 = v24 - 1536;
              *(_DWORD *)v28 = v27;
              *((_DWORD *)v28 + 1) = v19 & 0xFFFFF7FF;
              CVehicle::SetVehicleCreatedBy(v25, 1, 0);
            }
          }
          --v23;
          --v22;
        }
        while ( v23 != -1 );
      }
      if ( CGangWars::MakePlayerGainInfluenceInZone(0.3) )
        goto LABEL_54;
      v29 = CText::Get(&TheText, "GW_CLR2");
      CMessages::AddMessage("GW_CLR2", v29, 0x1194u, 1u, 1);
      v30 = CText::Get(&TheText, "GW_CLR2");
      CMessages::AddToPreviousBriefArray("GW_CLR2", v30, -1, -1, -1, -1, -1, -1, 0);
      v5 = 5;
LABEL_51:
      CGangWars::State = v5;
      CGangWars::TimeStarted = CTimer::m_snTimeInMilliseconds;
      goto LABEL_56;
    case 5:
      if ( CTimer::m_snTimeInMilliseconds <= CGangWars::TimeStarted + 10000 )
        goto LABEL_55;
      v31 = CGangWars::WarFerocity + 2;
      if ( CGangWars::WarFerocity + 2 <= 0 )
        v31 = 0;
      if ( !CGangWars::CreateAttackWave(v31, 2) )
        goto LABEL_55;
      v5 = 6;
      goto LABEL_51;
    case 6:
      if ( !CGangWars::AttackWaveOvercome() )
        goto LABEL_55;
      CGangWars::MakePlayerGainInfluenceInZone(1.0);
LABEL_54:
      CGangWars::DoStuffWhenPlayerVictorious();
LABEL_55:
      if ( !CGangWars::State )
        goto LABEL_80;
LABEL_56:
      FindPlayerCoors(&v78, -1);
      if ( v78.x >= (float)((float)CGangWars::pZoneToFightOver->x1 + -50.0)
        && (FindPlayerCoors(&v77, -1), v77.x <= (float)((float)CGangWars::pZoneToFightOver->x2 + 50.0)) )
      {
        FindPlayerCoors(&v76, -1);
        v32 = 0;
        if ( v76.y >= (float)((float)CGangWars::pZoneToFightOver->y1 + -50.0) )
        {
          FindPlayerCoors(&v75, -1);
          if ( v75.y <= (float)((float)CGangWars::pZoneToFightOver->y2 + 50.0) )
            v32 = 1;
        }
      }
      else
      {
        v32 = 0;
      }
      if ( v32 || CGame::currArea )
      {
        CGangWars::LastTimeInArea = CTimer::m_snTimeInMilliseconds;
      }
      else if ( CTimer::m_snTimeInMilliseconds - CGangWars::LastTimeInArea < 0x7531 )
      {
        if ( CTimer::m_snTimeInMilliseconds - CGangWars::LastTimeInArea >= 0x2711
          && CTimer::m_snPreviousTimeInMilliseconds - CGangWars::LastTimeInArea <= 0x2710 )
        {
          v45 = CText::Get(&TheText, "GW_WARN");
          CMessages::AddMessage("GW_WARN", v45, 0x1194u, 1u, 1);
          v46 = CText::Get(&TheText, "GW_WARN");
          CMessages::AddToPreviousBriefArray("GW_WARN", v46, -1, -1, -1, -1, -1, -1, 0);
        }
      }
      else
      {
        CGangWars::Provocation = 0.0;
        CGangWars::State = 0;
        CGangWars::ReleasePedsInAttackWave(1, 0);
        v34 = CPools::ms_pVehiclePool;
        v35 = CPools::ms_pVehiclePool->m_nSize;
        if ( v35 )
        {
          v36 = v35;
          v37 = v35 - 1;
          do
          {
            if ( (v34->m_aFlags[v37] & 0x80u) == 0 )
            {
              v38 = v34->m_aStorage[v36];
              v39 = (CVehicle *)(v38 - 2604);
              v40 = v38 == (uint8 *)&elf_hash_bucket[588];
              if ( v38 != (uint8 *)&elf_hash_bucket[588] )
              {
                v33 = *((_DWORD *)v38 - 383);
                v40 = (v33 & 0x800) == 0;
              }
              if ( !v40 )
              {
                v41 = *((_DWORD *)v38 - 384);
                v42 = v38 - 1536;
                *(_DWORD *)v42 = v41;
                *((_DWORD *)v42 + 1) = v33 & 0xFFFFF7FF;
                CVehicle::SetVehicleCreatedBy(v39, 1, 0);
              }
            }
            --v37;
            --v36;
          }
          while ( v37 != -1 );
        }
        CTheZones::FillZonesWithGangColours(0);
        v43 = CText::Get(&TheText, "GW_FLEE");
        CMessages::AddMessage("GW_FLEE", v43, 0x1194u, 1u, 1);
        v44 = CText::Get(&TheText, "GW_FLEE");
        CMessages::AddToPreviousBriefArray("GW_FLEE", v44, -1, -1, -1, -1, -1, -1, 0);
      }
      if ( CGangWars::State )
        goto LABEL_82;
LABEL_80:
      if ( CTheScripts::IsPlayerOnAMission() || (FindPlayerCoors(&v78, -1), v78.z > 950.0) )
      {
LABEL_82:
        v3.n64_u32[0] = 1189765120;
        v1.n64_f32[0] = CGangWars::TimeTillNextAttack;
        LODWORD(CGangWars::TimeTillNextAttack) = vmax_f32(v1, v3).n64_u32[0];
      }
      if ( CGangWars::State2 != 2 )
      {
        if ( CGangWars::State2 != 1 )
        {
          if ( !CGangWars::State2
            && !((CTheScripts::IsPlayerOnAMission() || CGangWars::bTrainingMission) << 24)
            && (!FindPlayerVehicle(-1, 0)
             || FindPlayerVehicle(-1, 0)->m_vehicleType != 3 && FindPlayerVehicle(-1, 0)->m_vehicleType != 4) )
          {
            if ( CGangWars::State )
            {
              v47 = CGangWars::TimeTillNextAttack;
            }
            else
            {
              v69 = (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * 0.06;
              if ( CWeather::WeatherRegion == 1 )
                v69 = (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
              v47 = CGangWars::TimeTillNextAttack - v69;
              CGangWars::TimeTillNextAttack = CGangWars::TimeTillNextAttack - v69;
            }
            if ( v47 < 0.0 )
              CGangWars::StartDefensiveGangWar();
          }
          goto LABEL_141;
        }
        FindPlayerCoors(&v78, -1);
        v53.n64_u64[0] = vsub_f32(*(float32x2_t *)&v78.x, *(float32x2_t *)&CGangWars::PointOfAttack.x).n64_u64[0];
        v54 = vmul_f32(v53, v53).n64_u64[0];
        if ( sqrtf(*(float *)&v54 + *((float *)&v54 + 1)) < 70.0 )
        {
          if ( CGangWars::CreateDefendingGroup((Int32)&CGangWars::PointOfAttack) )
          {
            CGangWars::State2 = 2;
            CGangWars::FightTimer += 30000;
          }
          goto LABEL_141;
        }
        CGangWars::FightTimer -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        if ( CGangWars::FightTimer > -1 )
          goto LABEL_141;
        v63 = CText::Get(&TheText, "GW_NOSH");
        CMessages::AddMessage("GW_NOSH", v63, 0x1194u, 1u, 1);
        v64 = CText::Get(&TheText, "GW_NOSH");
        v65 = 0;
        CMessages::AddToPreviousBriefArray("GW_NOSH", v64, -1, -1, -1, -1, -1, -1, 0);
        CGangWars::State2 = 0;
        v66 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
        if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
        {
          v67 = CGangWars::pZoneInfoToFightOver->aGangStrengths[0];
          v68 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2];
          if ( v68 + v67 <= v66 )
            v65 = 1;
        }
        else
        {
          if ( !CGangWars::pZoneInfoToFightOver )
          {
LABEL_139:
            CTheZones::FillZonesWithGangColours(0);
            CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)rand()
                                                                                               * 4.6566e-10)
                                                                                       * 0.9)
                                                                               + 0.6)
                                                                       * 1080000.0);
            goto LABEL_140;
          }
          v67 = CGangWars::pZoneInfoToFightOver->aGangStrengths[0];
          v66 = 0;
          v68 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2];
          v65 = 0;
        }
        if ( v67 + v68 + v66 )
        {
          CGangWars::pZoneInfoToFightOver->aGangStrengths[CGangWars::Gang1] += 30;
          if ( v65 )
          {
            if ( !CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
              || CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
               + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] > CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
            {
              CStats::IncrementStat(0xEBu, 1.0);
            }
          }
        }
        goto LABEL_139;
      }
      if ( !CGangWars::AttackWaveOvercome() )
      {
        CGangWars::FightTimer -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        if ( CGangWars::FightTimer > -1 )
          goto LABEL_141;
        v55 = 0;
        CGangWars::State2 = 0;
        CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10)
                                                                                   * 0.9)
                                                                           + 0.6)
                                                                   * 1080000.0);
        v56 = CText::Get(&TheText, "GW_SLOW");
        CMessages::AddMessage("GW_SLOW", v56, 0x1194u, 1u, 1);
        v57 = CText::Get(&TheText, "GW_SLOW");
        CMessages::AddToPreviousBriefArray("GW_SLOW", v57, -1, -1, -1, -1, -1, -1, 0);
        v58 = CGangWars::Gang1;
        v59 = CGangWars::ReleasePedsInAttackWave(1, 0);
        v60 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
        if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
        {
          v61 = CGangWars::pZoneInfoToFightOver->aGangStrengths[0];
          v62 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2];
          if ( v62 + v61 <= v60 )
            v55 = 1;
        }
        else
        {
          if ( !CGangWars::pZoneInfoToFightOver )
          {
LABEL_131:
            CTheZones::FillZonesWithGangColours(0);
LABEL_140:
            CStats::DecrementStat(0x44u, 30.0);
            goto LABEL_141;
          }
          v61 = CGangWars::pZoneInfoToFightOver->aGangStrengths[0];
          v60 = 0;
          v62 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2];
          v55 = 0;
        }
        if ( v61 + v62 + v60 )
        {
          CGangWars::pZoneInfoToFightOver->aGangStrengths[v58] += 3 * v59;
          if ( v55 )
          {
            if ( !CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
              || CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
               + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] > CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
            {
              CStats::IncrementStat(0xEBu, 1.0);
            }
          }
        }
        goto LABEL_131;
      }
      CGangWars::State2 = 0;
      CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10)
                                                                                 * 0.9)
                                                                         + 0.6)
                                                                 * 1080000.0);
      v48 = CText::Get(&TheText, "GW_WON");
      CMessages::AddMessage("GW_WON", v48, 0x1194u, 1u, 1);
      v49 = CText::Get(&TheText, "GW_WON");
      CMessages::AddToPreviousBriefArray("GW_WON", v49, -1, -1, -1, -1, -1, -1, 0);
      v50 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
      if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
        && CGangWars::pZoneInfoToFightOver->aGangStrengths[0]
         + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[2] <= v50 )
      {
        v51 = 1;
        if ( v50 <= 0x36 )
          goto LABEL_96;
      }
      else
      {
        v51 = 0;
        if ( v50 <= 0x36 )
        {
LABEL_96:
          v52 = v50 + 10;
          if ( v52 >= 0x37 )
            LOBYTE(v52) = 55;
          CGangWars::pZoneInfoToFightOver->aGangStrengths[1] = v52;
        }
      }
      if ( !v51
        && CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
        && CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
         + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] <= CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
      {
        CStats::IncrementStat(0xEAu, 1.0);
      }
      CTheZones::FillZonesWithGangColours(0);
      CGangWars::ReleasePedsInAttackWave(1, 0);
LABEL_141:
      if ( CGangWars::RadarBlip )
      {
        if ( (CGangWars::State2 | 2) == 2 )
        {
          CRadar::ClearBlip(CGangWars::RadarBlip);
          CGangWars::RadarBlip = 0;
        }
        else
        {
          if ( CGangWars::FightTimer <= (int)&elf_hash_chain[13526] )
          {
            if ( CGangWars::FightTimer <= 60000 )
            {
              v70 = 7;
              if ( CGangWars::FightTimer > 30000 )
                v70 = 8;
            }
            else
            {
              v70 = 9;
            }
          }
          else
          {
            v70 = 10;
          }
          if ( (CTimer::m_snTimeInMilliseconds & (1 << v70)) != 0 )
            v71 = BLIPDISPLAY_NEITHER;
          else
            v71 = BLIPDISPLAY_BLIPONLY;
          CRadar::ChangeBlipDisplay(CGangWars::RadarBlip, v71);
        }
      }
      if ( CGangWars::State2 )
      {
        FindPlayerCoors(&v78, -1);
        v72.n64_u64[0] = vsub_f32(*(float32x2_t *)&v78.x, *(float32x2_t *)&CGangWars::PointOfAttack.x).n64_u64[0];
        v73 = vmul_f32(v72, v72).n64_u64[0];
        if ( sqrtf(*(float *)&v73 + *((float *)&v73 + 1)) >= 150.0 )
        {
          v74 = 0;
          goto LABEL_159;
        }
        if ( !CGangWars::bPlayerIsCloseby )
        {
          FindPlayerCoors(&v78, -1);
          CStreaming::StreamZoneModels_Gangs(&v78);
          v74 = 1;
LABEL_159:
          CGangWars::bPlayerIsCloseby = v74;
        }
      }
      return;
    default:
      goto LABEL_56;
  }
}
// 30B80A: variable 'v0' is possibly undefined
// 30B80A: variable 'v2' is possibly undefined
// 30B8F4: variable 'v6' is possibly undefined
// 30BA3C: variable 'v19' is possibly undefined
// 30BC94: variable 'v33' is possibly undefined
// 30BE16: variable 'v1' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0030C5DC) --------------------------------------------------------
void __fastcall CGangWars::EndGangWar(const bool bMakePedsWanderAway)
{
  int v2; // r0
  Int32 v3; // r10
  char v4; // r0
  unsigned int v5; // r2
  int v6; // r3
  int v7; // r4
  int v8; // r5
  int v9; // r2
  CVehiclePool *v10; // r4
  int32 m_nSize; // r0
  int v12; // r5
  int v13; // r6
  uint8 *v14; // r1
  CVehicle *v15; // r0
  bool v16; // zf
  int v17; // r3
  uint8 *v18; // r1

  CGangWars::State = 0;
  if ( CGangWars::State2 )
  {
    CGangWars::State2 = 0;
    v2 = rand();
    v3 = CGangWars::Gang1;
    CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)v2 * 4.6566e-10) * 0.9)
                                                                       + 0.6)
                                                               * 1080000.0);
    v4 = CGangWars::ReleasePedsInAttackWave(1, 0);
    v5 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
    if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
    {
      v6 = CGangWars::pZoneInfoToFightOver->aGangStrengths[0];
      v7 = 0;
      v8 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2];
      if ( v8 + v6 <= v5 )
        v7 = 1;
    }
    else
    {
      if ( !CGangWars::pZoneInfoToFightOver )
        goto LABEL_13;
      v6 = CGangWars::pZoneInfoToFightOver->aGangStrengths[0];
      v5 = 0;
      v8 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2];
      v7 = 0;
    }
    if ( v6 + v8 + v5 )
    {
      CGangWars::pZoneInfoToFightOver->aGangStrengths[v3] += 3 * v4;
      if ( v7 )
      {
        if ( !CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
          || CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
           + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] > CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
        {
          CStats::IncrementStat(0xEBu, 1.0);
        }
      }
    }
  }
LABEL_13:
  CGangWars::Provocation = 0.0;
  CTheZones::FillZonesWithGangColours(0);
  CGangWars::ReleasePedsInAttackWave(1, bMakePedsWanderAway);
  v10 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v12 = m_nSize;
    v13 = m_nSize - 1;
    do
    {
      if ( (v10->m_aFlags[v13] & 0x80u) == 0 )
      {
        v14 = v10->m_aStorage[v12];
        v15 = (CVehicle *)(v14 - 2604);
        v16 = v14 == (uint8 *)&elf_hash_bucket[588];
        if ( v14 != (uint8 *)&elf_hash_bucket[588] )
        {
          v9 = *((_DWORD *)v14 - 383);
          v16 = (v9 & 0x800) == 0;
        }
        if ( !v16 )
        {
          v17 = *((_DWORD *)v14 - 384);
          v18 = v14 - 1536;
          *(_DWORD *)v18 = v17;
          *((_DWORD *)v18 + 1) = v9 & 0xFFFFF7FF;
          CVehicle::SetVehicleCreatedBy(v15, 1, 0);
        }
      }
      --v13;
      --v12;
    }
    while ( v13 != -1 );
  }
}
// 30C71C: variable 'v9' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030C770) --------------------------------------------------------
void CGangWars::UpdateTerritoryUnderControlPercentage()
{
  int v0; // r10
  Int32 v1; // r9
  Int32 v2; // r8
  int v3; // r3
  UInt16 *p_ZoneInfoIndex; // r1
  int v5; // r0
  unsigned int v6; // r5
  CZoneInfo *v7; // r0
  unsigned int v8; // r4
  unsigned int v9; // r6
  bool v10; // zf
  unsigned int v11; // r0
  float StatValue; // s0
  int v13; // r0
  int v14; // r3
  Int32 v15; // r0
  Int32 *v16; // r6
  Int32 *v17; // r5
  Int32 *v18; // r4
  Int32 v19; // r1
  Int32 v20; // r2

  if ( CTheZones::TotalNumberOfNavigationZones )
  {
    v0 = 0;
    v1 = 0;
    v2 = 0;
    v3 = 0;
    p_ZoneInfoIndex = &CTheZones::NavigationZoneArray[0].ZoneInfoIndex;
    do
    {
      if ( *p_ZoneInfoIndex )
      {
        v5 = *p_ZoneInfoIndex;
        v6 = CTheZones::ZoneInfoArray[v5].aGangStrengths[0];
        v7 = &CTheZones::ZoneInfoArray[v5];
        v8 = v7->aGangStrengths[1];
        v9 = v7->aGangStrengths[2];
        v10 = v8 == 0;
        v11 = v9 + v6;
        if ( !v8 )
          v10 = v11 == 0;
        if ( !v10 )
        {
          if ( v11 <= v8 )
          {
            ++v0;
          }
          else if ( v6 > v9 )
          {
            ++v1;
          }
          else
          {
            ++v2;
          }
        }
      }
      ++v3;
      p_ZoneInfoIndex += 16;
    }
    while ( v3 < CTheZones::TotalNumberOfNavigationZones );
  }
  else
  {
    v2 = 0;
    v1 = 0;
    v0 = 0;
  }
  CStats::SetStatValue(0xECu, (float)v0);
  StatValue = (float)v0;
  if ( CStats::GetStatValue(0xEDu) >= (float)v0 )
    StatValue = CStats::GetStatValue(0xEDu);
  CStats::SetStatValue(0xEDu, StatValue);
  if ( v1 + v2 + v0 )
  {
    v13 = 0;
    CGangWars::GangRatings[0] = 1;
    CGangWars::GangRatings[1] = 0;
    CGangWars::GangRatings[2] = 2;
    CGangWars::GangRatingStrength[0] = v0;
    CGangWars::GangRatingStrength[1] = v1;
    v14 = 0;
    CGangWars::GangRatingStrength[2] = v2;
    CGangWars::TerritoryUnderControlPercentage = (float)v0 / (float)(v1 + v2 + v0);
    do
    {
LABEL_22:
      v16 = &CGangWars::GangRatings[v14];
      v17 = &CGangWars::GangRatingStrength[v14 + 1];
      while ( v14 < 2 )
      {
        v18 = v17 + 1;
        v19 = *(v17 - 1);
        v20 = *v17;
        ++v16;
        ++v14;
        ++v17;
        if ( v19 < v20 )
        {
          v15 = *(v16 - 1);
          *(v16 - 1) = *v16;
          *v16 = v15;
          v13 = 1;
          *(v18 - 2) = v20;
          *(v18 - 1) = v19;
          goto LABEL_22;
        }
      }
      v10 = v13 << 24 == 0;
      v14 = 0;
      v13 = 0;
    }
    while ( !v10 );
  }
  else
  {
    CGangWars::TerritoryUnderControlPercentage = 0.0;
  }
}

//----- (0030C900) --------------------------------------------------------
bool __fastcall CGangWars::CreateAttackWave(Int32 Ferocity, Int32 Number)
{
  float v2; // s16
  int (**v3)(void); // s20
  int m_iAccumulatedTime; // s22
  CPlayerPed *PlayerPed; // r9
  Int32 v8; // r0
  UInt32 v9; // r1
  int v10; // r2
  int v11; // r6
  UInt32 v12; // r0
  int v13; // r1
  int v14; // r3
  int v15; // r1
  int v16; // r6
  int32 v17; // r0
  int32 v18; // r5
  int v19; // r3
  UInt32 v20; // r1
  int v21; // r0
  bool v22; // r4
  UInt16 *v23; // r1
  int v24; // r2
  UInt32 v25; // r1
  int v26; // r0
  UInt16 *v27; // r1
  int v28; // r2
  float v29; // s29
  float v30; // s31
  float v31; // s24
  float v32; // s24
  float v33; // r8
  UInt32 v34; // r3
  int v35; // r4
  int v36; // r5
  Int32 v37; // r0
  float y; // s24
  float z; // s31
  float x; // s29
  int v41; // r4
  int v42; // r10
  float GroundZFor3DCoord; // r6
  CCivilianPed *v44; // r8
  CMatrix *m_pMat; // r0
  float *p_tz; // r0
  CTaskComplexKillPedOnFoot *v47; // r6
  eWeaponType v48; // r4
  float v49; // s0
  int v50; // r6
  unsigned int v51; // r4
  float v52; // s17
  float v53; // s2
  float v54; // s0
  int v55; // r6
  int v56; // r5
  int v57; // r1
  float v58; // s6
  float v59; // s8
  float v60; // s31
  float v61; // s4
  float v62; // s2
  float v63; // s29
  float v64; // s24
  UInt32 v65; // r11
  Int32 v66; // r0
  UInt32 v67; // r4
  CAutomobile *OneEmergencyServicesCar; // r0
  CAutomobile *v69; // r6
  CAutomobile *v70; // r0
  int v71; // r1
  CPlayerPed *v72; // r0
  CAutomobile *v73; // r2
  int v74; // r0
  CEntity::CEntityInfo m_info; // r3
  CPed *pDriver; // r0
  int i; // r4
  CPed *v78; // r0
  CTaskSimpleGangDriveBy *v79; // r6
  CPlayerPed *v80; // r0
  int v81; // r4
  unsigned int v82; // r5
  Int32 v84; // [sp+3Ch] [bp-10Ch]
  float v85; // [sp+48h] [bp-100h]
  Int32 v86; // [sp+4Ch] [bp-FCh]
  eWeaponType weaponType; // [sp+58h] [bp-F0h]
  int v88; // [sp+5Ch] [bp-ECh]
  int v89; // [sp+80h] [bp-C8h]
  int v90; // [sp+84h] [bp-C4h]
  Int32 v91; // [sp+88h] [bp-C0h]
  Int32 v92; // [sp+88h] [bp-C0h]
  int v93; // [sp+8Ch] [bp-BCh]
  unsigned int v94; // [sp+94h] [bp-B4h]
  Int32 v95; // [sp+98h] [bp-B0h]
  UInt32 *v96; // [sp+98h] [bp-B0h]
  CVector v97; // [sp+A4h] [bp-A4h] BYREF
  CEventScriptCommand pResult; // [sp+B0h] [bp-98h] BYREF
  CVector pFromNode; // [sp+C8h] [bp-80h] BYREF
  float pFraction; // [sp+D4h] [bp-74h] BYREF
  CNodeAddress pToNode; // [sp+D8h] [bp-70h] BYREF
  CVector v102; // [sp+DCh] [bp-6Ch] BYREF
  CVector v103; // 0:r0.12

  FindPlayerCoors(&v102, -1);
  PlayerPed = FindPlayerPed(-1);
  if ( CGame::currArea
    || v102.z > 950.0
    || !CPathFind::AreNodesLoadedForArea(&ThePaths, v102.x + -20.0, v102.x + 20.0, v102.y + -20.0, v102.y + 20.0) )
  {
    return 0;
  }
  v8 = CGangWars::Gang1;
  v9 = CPopulation::m_TranslationArray[CGangWars::Gang1 + 18][0];
  v10 = CPopulation::m_nNumPedsInGroup[v9];
  if ( v10 < 1 )
  {
LABEL_8:
    CStreaming::RequestModel(CPopulation::m_PedGroups[v9][0], 8);
    v8 = CGangWars::Gang1;
  }
  else
  {
    v11 = 0;
    while ( CStreaming::ms_aInfoForModel[CPopulation::m_PedGroups[v9][v11]].m_status != 1 )
    {
      if ( ++v11 >= v10 )
        goto LABEL_8;
    }
  }
  if ( v8 != CGangWars::Gang2 )
  {
    v12 = CPopulation::m_TranslationArray[CGangWars::Gang2 + 18][0];
    v13 = CPopulation::m_nNumPedsInGroup[v12];
    if ( v13 < 1 )
    {
LABEL_14:
      CStreaming::RequestModel(CPopulation::m_PedGroups[v12][0], 8);
    }
    else
    {
      v14 = 0;
      while ( CStreaming::ms_aInfoForModel[CPopulation::m_PedGroups[v12][v14]].m_status != 1 )
      {
        if ( ++v14 >= v13 )
          goto LABEL_14;
      }
    }
  }
  v15 = Ferocity - 1;
  if ( (unsigned int)(Ferocity - 1) > 4 )
  {
    v17 = 336;
    v16 = 5;
    v18 = 346;
    v19 = 22;
  }
  else
  {
    v16 = dword_30D4BC[v15];
    v17 = dword_30D4A8[v15];
    v18 = (int32)*(&off_30D4D0 + v15);
    v19 = dword_30D4E4[v15];
  }
  if ( CGangWars::bTrainingMission )
  {
    if ( Ferocity )
    {
      if ( Ferocity == 1 )
      {
        v18 = 346;
        v19 = 22;
        v16 = 22;
        v17 = 346;
      }
      else
      {
        v18 = 372;
        v19 = 32;
        v16 = 32;
        v17 = 372;
      }
    }
    else
    {
      v18 = 336;
      v19 = 5;
      v16 = 5;
      v17 = 336;
    }
  }
  if ( CStreaming::ms_aInfoForModel[v17].m_status != 1 || CStreaming::ms_aInfoForModel[v18].m_status != 1 )
  {
    v22 = 0;
    CStreaming::RequestModel(v17, 0);
    CStreaming::RequestModel(v18, 0);
    return v22;
  }
  weaponType = v16;
  v88 = v19;
  v20 = CPopulation::m_TranslationArray[CGangWars::Gang1 + 18][0];
  v21 = CPopulation::m_nNumPedsInGroup[v20];
  if ( v21 < 1 )
    return 0;
  v22 = 0;
  v23 = CPopulation::m_PedGroups[v20];
  v24 = 0;
  while ( CStreaming::ms_aInfoForModel[v23[v24]].m_status != 1 )
  {
    if ( ++v24 >= v21 )
      return v22;
  }
  v91 = CGangWars::Gang2;
  v25 = CPopulation::m_TranslationArray[CGangWars::Gang2 + 18][0];
  v26 = CPopulation::m_nNumPedsInGroup[v25];
  if ( v26 < 1 )
    return 0;
  v22 = 0;
  v27 = CPopulation::m_PedGroups[v25];
  v28 = 0;
  while ( CStreaming::ms_aInfoForModel[v27[v28]].m_status != 1 )
  {
    if ( ++v28 >= v26 )
      return v22;
  }
  v95 = CGangWars::Gang1;
  v29 = 1000000.0;
  v30 = 1000000.0;
  v31 = 1000000.0;
  v85 = (float)(Ferocity + 3);
  v84 = Number;
  v86 = Ferocity;
  v89 = 0;
  v90 = 0;
  while ( 2 )
  {
    v35 = 0;
    v36 = 0;
    do
    {
      while ( 1 )
      {
        LOWORD(pFromNode.x) = -1;
        pToNode.Region = -1;
        ++v36;
        if ( CCarCtrl::GenerateCarCreationCoors2(
               v102,
               1.0,
               0.0,
               -1.0,
               1,
               50.0,
               50.0,
               (CVector *)&pResult,
               (CNodeAddress *)&pFromNode,
               &pToNode,
               &pFraction,
               0,
               1) != 1 )
          goto LABEL_61;
        if ( CCamera::IsSphereVisible(&TheCamera, (const CVector *)&pResult, 7.0) )
          break;
        v3 = pResult._vptr$CEvent;
        m_iAccumulatedTime = pResult.m_iAccumulatedTime;
        v2 = *(float *)&pResult.m_bIsPersistent;
        if ( sqrtf(
               (float)((float)((float)(v31 - *(float *)&pResult._vptr$CEvent)
                             * (float)(v31 - *(float *)&pResult._vptr$CEvent))
                     + (float)((float)(v30 - *(float *)&pResult.m_iAccumulatedTime)
                             * (float)(v30 - *(float *)&pResult.m_iAccumulatedTime)))
             + (float)((float)(v29 - *(float *)&pResult.m_bIsPersistent)
                     * (float)(v29 - *(float *)&pResult.m_bIsPersistent))) <= 15.0 )
          goto LABEL_63;
        v35 = 1;
        v36 = 20;
LABEL_61:
        if ( v36 >= 20 )
          goto LABEL_64;
      }
      if ( !(v35 << 31) )
      {
        v3 = pResult._vptr$CEvent;
        m_iAccumulatedTime = pResult.m_iAccumulatedTime;
        v2 = *(float *)&pResult.m_bIsPersistent;
      }
LABEL_63:
      v35 = 1;
    }
    while ( v36 < 20 );
LABEL_64:
    v37 = v91;
    if ( !v90 )
      v37 = v95;
    v92 = v37;
    if ( v35 << 31 )
    {
      pFromNode.z = 0.0;
      pFromNode.x = v102.y - *(float *)&m_iAccumulatedTime;
      pFromNode.y = *(float *)&v3 - v102.x;
      CVector::Normalise(&pFromNode);
      y = pFromNode.y * 1.2;
      z = pFromNode.z * 1.2;
      x = pFromNode.x * 1.2;
      pFromNode.x = pFromNode.x * 1.2;
      pFromNode.y = pFromNode.y * 1.2;
      pFromNode.z = pFromNode.z * 1.2;
      v41 = (int)(float)((float)((float)(CGangWars::Difficulty * 0.3) + 0.7) * v85);
      if ( CGangWars::bTrainingMission )
        v41 = 2;
      if ( Ferocity == 5 )
        v41 = 10;
      if ( v41 >= 1 )
      {
        v42 = 0;
        v93 = v41;
        v96 = CPopulation::m_TranslationArray[v92 + 18];
        v94 = (unsigned int)v41 >> 1;
        while ( 1 )
        {
          v52 = (float)rand();
          v53 = (float)rand();
          v54 = (float)(int)(2 * (v42 - v94));
          v55 = CPopulation::m_nNumPedsInGroup[*v96];
          if ( v55 >= 1 )
          {
            v56 = 0;
            v57 = CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry;
            v58 = *(float *)&v3 + (float)(x * v54);
            v59 = *(float *)&m_iAccumulatedTime + (float)(y * v54);
            v60 = v2 + (float)(z * v54);
            v61 = (float)((float)(v52 * 4.6566e-10) * 3.0) + -1.5;
            v62 = (float)((float)(v53 * 4.6566e-10) * 3.0) + -1.5;
            v63 = v58 + v61;
            v64 = v59 + v62;
            while ( 1 )
            {
              v57 = (v57 + 1) % v55;
              v65 = CPopulation::m_PedGroups[*v96][v57];
              if ( CStreaming::ms_aInfoForModel[v65].m_status == 1 )
                break;
              if ( ++v56 >= v55 )
              {
                CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry = v57;
                goto LABEL_80;
              }
            }
            CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry = v57;
            GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(v58 + v61, v59 + v62, v60 + 2.0, 0, 0);
            v44 = (CCivilianPed *)CPed::operator new(0x7A4u);
            CCivilianPed::CCivilianPed(v44, (ePedType)(CGangWars::Gang1 + 7), v65);
            m_pMat = v44->m_pMat;
            if ( m_pMat )
            {
              m_pMat->tx = v63;
              v44->m_pMat->ty = v64;
              p_tz = &v44->m_pMat->tz;
            }
            else
            {
              p_tz = &v44->m_transform.m_translate.z;
              v44->m_transform.m_translate.x = v63;
              v44->m_transform.m_translate.y = v64;
            }
            *p_tz = GroundZFor3DCoord + 1.3;
            CPed::SetCharCreatedBy(v44, 2u);
            CWorld::Add(v44);
            v47 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
            CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v47, PlayerPed, -1, 0, 0, 0, 2);
            CEventScriptCommand::CEventScriptCommand(&pResult, 3, v47, 0);
            CEventGroup::Add(&v44->m_pPedIntelligence->m_eventGroup, &pResult, 0);
            if ( (float)((float)((float)((float)rand() * 4.6566e-10) * 1.6) + -0.3) > CGangWars::Difficulty )
              v48 = weaponType;
            else
              v48 = v88;
            CPed::GiveWeapon(v44, v48, 0x1388u, 0);
            CPed::SetCurrentWeapon(v44, v48);
            v49 = CGangWars::Difficulty * 25.0;
            *((_DWORD *)&v44->m_nPedFlags + 2) |= 0x3000u;
            v44->m_nMaxHealth = 120.0;
            v44->m_nHealth = 120.0;
            v44->m_nShootingAccuracy = (unsigned int)(float)(v49 + 70.0);
            v50 = (gaGangColoursR[v92] << 24) | (gaGangColoursG[v92] << 16) | (gaGangColoursB[v92] << 8) | 0xFF;
            v51 = CRadar::SetEntityBlip(
                    BLIPTYPE_CHAR,
                    CPools::ms_pPedPool->m_aFlags[-1093107909
                                                * (((char *)v44 - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * (((char *)v44 - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)),
                    v50,
                    BLIPDISPLAY_BLIPONLY,
                    (Char *)"CODEGW2");
            CRadar::ChangeBlipScale(v51, 2);
            CRadar::ChangeBlipColour(v51, v50);
            CEventScriptCommand::~CEventScriptCommand(&pResult);
            v89 = 1;
LABEL_80:
            v41 = v93;
          }
          if ( ++v42 == v41 )
            break;
          x = pFromNode.x;
          y = pFromNode.y;
          z = pFromNode.z;
        }
        Number = v84;
      }
      v32 = (float)rand();
      v33 = *(float *)&m_iAccumulatedTime + (float)((float)((float)((float)rand() * 4.6566e-10) * 4.0) + -2.0);
      v103.z = CWorld::FindGroundZFor3DCoord(
                 *(float *)&v3 + (float)((float)((float)(v32 * 4.6566e-10) * 4.0) + -2.0),
                 v33,
                 v2 + 1.0,
                 0,
                 0)
             + 0.75;
      if ( Number )
      {
        if ( Number == 1 )
        {
          if ( !v90 )
          {
            LODWORD(v103.x) = &MI_PICKUP_BODYARMOUR;
            goto LABEL_49;
          }
        }
        else if ( Number == 2 )
        {
          LODWORD(v103.x) = &MI_PICKUP_BODYARMOUR;
          if ( !v90 )
            LODWORD(v103.x) = &MI_PICKUP_HEALTH;
LABEL_49:
          v34 = (unsigned __int16)*(_WORD *)LODWORD(v103.x);
          v103.x = *(float *)&v3 + (float)((float)((float)(v32 * 4.6566e-10) * 4.0) + -2.0);
          v103.y = v33;
          CPickups::GenerateNewOne(v103, v34, 5, 0, 0, 0, 0);
        }
      }
      else if ( !v90 )
      {
        LODWORD(v103.x) = &MI_PICKUP_HEALTH;
        goto LABEL_49;
      }
      v31 = *(float *)&v3;
      Ferocity = v86;
      v30 = *(float *)&m_iAccumulatedTime;
      v29 = v2;
    }
    if ( ++v90 != 2 )
    {
      v91 = CGangWars::Gang2;
      v95 = CGangWars::Gang1;
      continue;
    }
    break;
  }
  if ( !(v89 << 31) )
    return 0;
  v22 = 1;
  if ( !CGangWars::bTrainingMission && !pDriveByCar )
  {
    v66 = CPopulation::PickGangCar(CGangWars::Gang1);
    v67 = v66;
    if ( v66 < 0 || CStreaming::ms_aInfoForModel[v66].m_status != 1 )
      return 1;
    FindPlayerCoors(&v97, -1);
    OneEmergencyServicesCar = CCarCtrl::GenerateOneEmergencyServicesCar(v67, v97);
    v22 = 1;
    pDriveByCar = OneEmergencyServicesCar;
    if ( OneEmergencyServicesCar )
    {
      CEntity::RegisterReference(OneEmergencyServicesCar, &pDriveByCar);
      v69 = pDriveByCar;
      FindPlayerCoors((CVector *)&pResult, -1);
      CCarCtrl::JoinCarWithRoadSystemGotoCoors(v69, (const CVector *)&pResult, 0, 0);
      v70 = pDriveByCar;
      pDriveByCar->AutoPilot.CruiseSpeed = 10;
      v71 = *((_DWORD *)&v70->m_nVehicleFlags + 1);
      v70->AutoPilot.Mission = 61;
      *((_DWORD *)&v70->m_nVehicleFlags + 1) = v71 | 0x800;
      v72 = FindPlayerPed(-1);
      v73 = pDriveByCar;
      pDriveByCar->AutoPilot.pTargetEntity = v72;
      v73->AutoPilot.DrivingMode = 2;
      v74 = *((_DWORD *)&v73->m_nVehicleFlags + 1);
      v73->AutoPilot.AISwitchToStraightLineDistance = 30;
      m_info = v73->m_info;
      *((_DWORD *)&v73->m_nVehicleFlags + 1) = v74 | 0x40;
      v73->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
      CCarCtrl::SetUpDriverAndPassengersForVehicle(v73, CGangWars::Gang1 + 14, 1, 0, 0, 1);
      pDriver = pDriveByCar->pDriver;
      if ( pDriver )
        CPedIntelligence::SetPedDecisionMakerType(pDriver->m_pPedIntelligence, -1);
      for ( i = 282; i != 290; ++i )
      {
        v78 = (CPed *)*((_DWORD *)&pDriveByCar->_vptr$CPlaceable + i);
        if ( v78 )
        {
          CPed::GiveDelayedWeapon(v78, WEAPONTYPE_MICRO_UZI, 0x5DCu);
          CPed::SetCurrentWeapon(*((CPed **)&pDriveByCar->_vptr$CPlaceable + i), WEAPONTYPE_MICRO_UZI);
          v79 = (CTaskSimpleGangDriveBy *)CTask::operator new(0x44u);
          v80 = FindPlayerPed(-1);
          CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(v79, v80, 0, 100.0, 50, 8, (i - 282) << 31 == 0);
          CEventScriptCommand::CEventScriptCommand(&pResult, 3, v79, 0);
          CEventGroup::Add(
            (CEventGroup *)(*(_DWORD *)(*((_DWORD *)&pDriveByCar->_vptr$CPlaceable + i) + 1088) + 104),
            &pResult,
            0);
          CEventScriptCommand::~CEventScriptCommand(&pResult);
        }
      }
      v81 = (gaGangColoursR[v92] << 24) | (gaGangColoursG[v92] << 16) | (gaGangColoursB[v92] << 8) | 0xFF;
      v82 = CRadar::SetEntityBlip(
              BLIPTYPE_CHAR,
              CPools::ms_pPedPool->m_aFlags[-1093107909
                                          * (((char *)pDriveByCar->pDriver - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * (((char *)pDriveByCar->pDriver - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)),
              v81,
              BLIPDISPLAY_BLIPONLY,
              (Char *)"CODEGW3");
      CRadar::ChangeBlipScale(v82, 3);
      CRadar::ChangeBlipColour(v82, v81);
      *((_DWORD *)&pDriveByCar->pDriver->m_nPedFlags + 2) |= 0x2000u;
      return 1;
    }
  }
  return v22;
}
// 30CDA0: variable 'm_iAccumulatedTime' is possibly undefined
// 30CDA8: variable 'v3' is possibly undefined
// 30CDA4: variable 'v2' is possibly undefined
// 30D4A8: using guessed type int dword_30D4A8[];
// 30D4BC: using guessed type int dword_30D4BC[5];
// 30D4D0: using guessed type void *off_30D4D0;
// 30D4E4: using guessed type int dword_30D4E4[5];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (0030D5CC) --------------------------------------------------------
bool CGangWars::AttackWaveOvercome()
{
  CPedPool *v0; // r11
  int32 m_nSize; // r4
  int v2; // r0
  int i; // r8
  int *v4; // r9
  int v5; // r3
  int v6; // r5
  int v7; // r6
  float32x2_t *v8; // r8
  float32x2_t *v9; // r0
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  int v13; // [sp+0h] [bp-40h]
  int v14; // [sp+4h] [bp-3Ch]
  CVector v15; // [sp+8h] [bp-38h] BYREF

  v0 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  v13 = 0;
  v14 = 0;
  while ( m_nSize )
  {
    v2 = 1996 * m_nSize--;
    for ( i = v2 - 896; ; i -= 1996 )
    {
      if ( (v0->m_aFlags[m_nSize] & 0x80u) != 0 )
        goto LABEL_9;
      v4 = (int *)&(*v0->m_aStorage)[i];
      if ( v4 == &elf_hash_bucket[212] )
        goto LABEL_9;
      v5 = v4[16];
      if ( (v5 & 0x1000) == 0 )
        goto LABEL_9;
      if ( (*(_DWORD *)&(*v0->m_aStorage)[i] & 0xFFFFFFFE) != 54 )
        break;
      v6 = v4[15];
      v7 = v4[17];
      v4[14] = v4[14];
      v4[15] = v6;
      v4[16] = v5 & 0xFFFFEFFF;
      v4[17] = v7;
      CPed::SetCharCreatedBy((CPed *)(v4 - 275), 1u);
LABEL_9:
      if ( --m_nSize == -1 )
        return v13 == 0 && v14 < 2;
    }
    v8 = (float32x2_t *)*(v4 - 270);
    FindPlayerCoors(&v15, -1);
    v9 = v8 + 6;
    if ( !v8 )
      v9 = (float32x2_t *)(v4 - 274);
    v10.n64_u64[0] = vsub_f32((float32x2_t)v9->n64_u64[0], *(float32x2_t *)&v15.x).n64_u64[0];
    ++v14;
    v11 = vmul_f32(v10, v10).n64_u64[0];
    if ( sqrtf(*(float *)&v11 + *((float *)&v11 + 1)) < 45.0 )
      ++v13;
  }
  return v13 == 0 && v14 < 2;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0030D6E4) --------------------------------------------------------
bool __fastcall CGangWars::MakePlayerGainInfluenceInZone(float Perc)
{
  CZoneInfo *v1; // r1
  _BOOL4 v2; // r12
  int v3; // r4
  int v4; // r5
  float v5; // s0
  UInt8 v6; // r6
  CZoneInfo *v7; // r1
  unsigned int v8; // r0
  int v9; // r0

  v1 = CGangWars::pZoneInfoToFightOver;
  v2 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
    && CGangWars::pZoneInfoToFightOver->aGangStrengths[0]
     + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[2] <= CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
  v3 = 0;
  v4 = 0;
  v5 = 1.0 - Perc;
  do
  {
    if ( v4 == 1 )
      v4 = 2;
    v6 = v1->aGangStrengths[v4];
    v1->aGangStrengths[v4] = (unsigned int)(float)(v5 * (float)v6);
    v7 = CGangWars::pZoneInfoToFightOver;
    v8 = CGangWars::pZoneInfoToFightOver->aGangStrengths[v4];
    if ( v8 < 4 )
    {
      CGangWars::pZoneInfoToFightOver->aGangStrengths[v4] = 0;
      v7 = CGangWars::pZoneInfoToFightOver;
      LOBYTE(v8) = CGangWars::pZoneInfoToFightOver->aGangStrengths[v4];
    }
    v7->aGangStrengths[1] += v6 - v8;
    v1 = CGangWars::pZoneInfoToFightOver;
    v9 = CGangWars::pZoneInfoToFightOver->aGangStrengths[v4++];
    v3 += v9;
  }
  while ( v4 != 10 );
  if ( !v2
    && CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
    && CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
     + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] <= CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
  {
    CStats::IncrementStat(0xEAu, 1.0);
  }
  return v3 == 0;
}

//----- (0030D7B8) --------------------------------------------------------
bool __fastcall CGangWars::CreateDefendingGroup(Int32 Ferocity)
{
  int16x4_t v1; // d16
  UInt32 v2; // r0
  int v3; // r1
  int v4; // r3
  bool v5; // r4
  CNodeAddress *NodeClosestToCoors; // r0
  CPathNode *v8; // r0
  int CoorsZ; // r4
  float32x2_t v10; // d8
  int16x4_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s24
  int i; // r9
  UInt32 v15; // r6
  int v16; // r5
  int v17; // r8
  int v18; // r1
  UInt32 v19; // r4
  float v20; // s27
  float v21; // s29
  float v22; // r5
  float v23; // s0
  float v24; // s31
  float v25; // s29
  float GroundZFor3DCoord; // r6
  CCivilianPed *v27; // r5
  CMatrix *m_pMat; // r0
  float *p_tz; // r0
  CMatrix *v30; // r0
  CTaskComplexKillPedOnFoot *v31; // r4
  CPlayerPed *PlayerPed; // r0
  uint32 PedFlag; // r0
  CPed *v34; // r0
  eWeaponType v35; // r1
  int v36; // r4
  unsigned int v37; // r5
  int bIgnoreBetweenLevels; // r9
  CNodeAddress *NthNodeClosestToCoors; // r0
  CPathNode *v40; // r0
  int v41; // r5
  float32x2_t v42; // d13
  unsigned __int64 v43; // d0
  Int32 v44; // r0
  Int32 v45; // r6
  CVehicle *CarForScript; // r5
  int16x4_t *v47; // r0
  CMatrix *v48; // r0
  float v49; // s0
  float v50; // s6
  float v51; // r5
  float v52; // s2
  UInt16 *v53; // r4
  bool bIgnoreInteriors; // [sp+1Ch] [bp-ACh]
  float v55; // [sp+20h] [bp-A8h]
  int v56; // [sp+4Ch] [bp-7Ch]
  CEventScriptCommand v57[5]; // [sp+50h] [bp-78h] BYREF
  CVector v58; // 0:r0.12
  CVector v59; // 0:r1.12
  CVector v60; // 0:r2.8,8:^0.4
  CVector v61; // 0:r2.8,8:^0.4

  v2 = CPopulation::m_TranslationArray[CGangWars::Gang1 + 18][0];
  v3 = CPopulation::m_nNumPedsInGroup[v2];
  if ( v3 < 1 )
  {
LABEL_5:
    CStreaming::RequestModel(CPopulation::m_PedGroups[v2][0], 8);
    return 0;
  }
  v4 = 0;
  while ( CStreaming::ms_aInfoForModel[CPopulation::m_PedGroups[v2][v4]].m_status != 1 )
  {
    if ( ++v4 >= v3 )
      goto LABEL_5;
  }
  v5 = 0;
  if ( CPathFind::AreNodesLoadedForArea(
         &ThePaths,
         CGangWars::PointOfAttack.x,
         CGangWars::PointOfAttack.x,
         CGangWars::PointOfAttack.y,
         CGangWars::PointOfAttack.y) )
  {
    *(_QWORD *)&v60.x = *(_QWORD *)&CGangWars::PointOfAttack.y;
    v60.z = 0.0;
    NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                           (CNodeAddress *)&ThePaths,
                           (CPathFind *)LODWORD(CGangWars::PointOfAttack.x),
                           v60,
                           400.0,
                           0.0,
                           0,
                           0,
                           0,
                           1,
                           bIgnoreInteriors);
    if ( (unsigned __int16)NodeClosestToCoors != 0xFFFF )
    {
      v8 = &ThePaths.pNodes[(unsigned __int16)NodeClosestToCoors][(unsigned int)NodeClosestToCoors >> 16];
      CoorsZ = v8->CoorsZ;
      v1.n64_u32[0] = *(_DWORD *)&v8->CoorsX;
      FindPlayerCoors((CVector *)v57, -1);
      v10.n64_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v1).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
      v11.n64_u64[0] = vsub_f32(v10, *(float32x2_t *)&v57[0]._vptr$CEvent).n64_u64[0];
      v12 = vmul_f32(v11, v11).n64_u64[0];
      if ( sqrtf(*(float *)&v12 + *((float *)&v12 + 1)) > 40.0 )
      {
        v55 = (float)CoorsZ * 0.125;
        v56 = (int)(float)((float)((float)(CGangWars::Difficulty * 0.4) + 0.6) * 10.0);
        if ( v56 >= 1 )
        {
          v13 = (float)(int)(float)((float)((float)(CGangWars::Difficulty * 0.4) + 0.6) * 10.0);
          for ( i = 0; i != v56; ++i )
          {
            v15 = CPopulation::m_TranslationArray[CGangWars::Gang1 + 18][0];
            v16 = CPopulation::m_nNumPedsInGroup[v15];
            if ( v16 >= 1 )
            {
              v17 = 0;
              v18 = CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry;
              while ( 1 )
              {
                v18 = (v18 + 1) % v16;
                v19 = CPopulation::m_PedGroups[v15][v18];
                if ( CStreaming::ms_aInfoForModel[v19].m_status == 1 )
                  break;
                if ( ++v17 >= v16 )
                {
                  CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry = v18;
                  goto LABEL_31;
                }
              }
              CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry = v18;
              v20 = (float)((float)i * 6.2832) / v13;
              v21 = (float)((float)((float)rand() * 4.6566e-10) * 3.0) + 2.0;
              v22 = sinf(v20);
              v23 = (float)((float)rand() * 4.6566e-10) * 3.0;
              v24 = v10.n64_f32[0] + (float)(v22 * v21);
              v25 = v10.n64_f32[1] + (float)(cosf(v20) * (float)(v23 + 2.0));
              GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(v24, v25, v55 + 2.0, 0, 0);
              v27 = (CCivilianPed *)CPed::operator new(0x7A4u);
              CCivilianPed::CCivilianPed(v27, (ePedType)(CGangWars::Gang1 + 7), v19);
              m_pMat = v27->m_pMat;
              if ( m_pMat )
              {
                m_pMat->tx = v24;
                v27->m_pMat->ty = v25;
                p_tz = &v27->m_pMat->tz;
              }
              else
              {
                p_tz = &v27->m_transform.m_translate.z;
                v27->m_transform.m_translate.x = v24;
                v27->m_transform.m_translate.y = v25;
              }
              *p_tz = GroundZFor3DCoord + 1.0;
              v30 = v27->m_pMat;
              v27->m_fCurrentHeading = v20;
              v27->m_fDesiredHeading = v20;
              if ( v30 )
                CMatrix::SetRotateZOnly(v30, v20);
              else
                v27->m_transform.m_heading = v20;
              CPed::SetCharCreatedBy(v27, 2u);
              CWorld::Add(v27);
              v31 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
              PlayerPed = FindPlayerPed(-1);
              CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v31, PlayerPed, -1, 0, 0, 0, 2);
              CEventScriptCommand::CEventScriptCommand(v57, 3, v31, 0);
              CEventGroup::Add(&v27->m_pPedIntelligence->m_eventGroup, v57, 0);
              v27->m_nShootingAccuracy = (unsigned int)(float)((float)(CGangWars::Difficulty * -60.0) + 90.0);
              PedFlag = CPedType::GetPedFlag(0);
              CAcquaintance::SetAsAcquaintance(&v27->m_acquaintances, 4, PedFlag);
              switch ( i % 4 )
              {
                case 0:
                  CPed::GiveDelayedWeapon(v27, WEAPONTYPE_PISTOL, 0x1388u);
                  v34 = v27;
                  v35 = WEAPONTYPE_PISTOL;
                  goto LABEL_29;
                case 1:
                  CPed::GiveDelayedWeapon(v27, WEAPONTYPE_MICRO_UZI, 0x1388u);
                  v34 = v27;
                  v35 = WEAPONTYPE_MICRO_UZI;
                  goto LABEL_29;
                case 2:
                  CPed::GiveDelayedWeapon(v27, WEAPONTYPE_SHOTGUN, 0x1388u);
                  v34 = v27;
                  v35 = WEAPONTYPE_SHOTGUN;
                  goto LABEL_29;
                case 3:
                  CPed::GiveDelayedWeapon(v27, WEAPONTYPE_MP5, 0x1388u);
                  v34 = v27;
                  v35 = WEAPONTYPE_MP5;
LABEL_29:
                  CPed::SetCurrentWeapon(v34, v35);
                  break;
                default:
                  break;
              }
              *((_DWORD *)&v27->m_nPedFlags + 2) |= 0x3000u;
              v36 = (gaGangColoursR[CGangWars::Gang1] << 24) | (gaGangColoursG[CGangWars::Gang1] << 16) | (gaGangColoursB[CGangWars::Gang1] << 8) | 0xFF;
              v37 = CRadar::SetEntityBlip(
                      BLIPTYPE_CHAR,
                      CPools::ms_pPedPool->m_aFlags[-1093107909
                                                  * (((char *)v27 - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * (((char *)v27 - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)),
                      v36,
                      BLIPDISPLAY_BLIPONLY,
                      (Char *)"CODEGW3");
              CRadar::ChangeBlipScale(v37, 2);
              CRadar::ChangeBlipColour(v37, v36);
              CEventScriptCommand::~CEventScriptCommand(v57);
            }
LABEL_31:
            ;
          }
        }
        for ( bIgnoreBetweenLevels = 1; bIgnoreBetweenLevels != 4; ++bIgnoreBetweenLevels )
        {
          *(_QWORD *)&v61.x = *(_QWORD *)&CGangWars::PointOfAttack.y;
          v61.z = 0.0;
          NthNodeClosestToCoors = CPathFind::FindNthNodeClosestToCoors(
                                    (CNodeAddress *)&ThePaths,
                                    (CPathFind *)LODWORD(CGangWars::PointOfAttack.x),
                                    v61,
                                    100.0,
                                    0.0,
                                    0,
                                    bIgnoreBetweenLevels,
                                    0,
                                    1,
                                    0,
                                    (CNodeAddress *)LODWORD(v55));
          v40 = &ThePaths.pNodes[(unsigned __int16)NthNodeClosestToCoors][(unsigned int)NthNodeClosestToCoors >> 16];
          v41 = v40->CoorsZ;
          v11.n64_u32[0] = *(_DWORD *)&v40->CoorsX;
          FindPlayerCoors((CVector *)v57, -1);
          v42.n64_u64[0] = vmul_f32(
                             vcvt_f32_s32((int32x2_t)vmovl_s16(v11).n128_u64[0]),
                             (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
          v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&v57[0]._vptr$CEvent, v42).n64_u64[0];
          v43 = vmul_f32(v11, v11).n64_u64[0];
          if ( sqrtf(*(float *)&v43 + *((float *)&v43 + 1)) > 25.0 )
          {
            v44 = CPopulation::PickGangCar(CGangWars::Gang1);
            v45 = v44;
            if ( v44 > -1 && CStreaming::ms_aInfoForModel[v44].m_status == 1 )
            {
              *(_DWORD *)&v57[0].m_bIsPersistent = 0;
              *(float *)&v57[0].m_iAccumulatedTime = v10.n64_f32[0] - v42.n64_f32[0];
              *(float *)&v57[0]._vptr$CEvent = v42.n64_f32[1] - v10.n64_f32[1];
              CVector::Normalise((CVector *)v57);
              LODWORD(v59.y) = v42.n64_u32[1];
              v59.z = (float)v41 * 0.125;
              LODWORD(v59.x) = v42.n64_u32[0];
              CarForScript = CCarCtrl::CreateCarForScript(v45, v59, 0);
              v11.n64_u64[0] = *(unsigned __int64 *)&v57[0]._vptr$CEvent;
              v47 = (int16x4_t *)CarForScript->m_pMat;
              v47[3].n64_u32[0] = *(_DWORD *)&v57[0].m_bIsPersistent;
              v47[2].n64_u64[0] = v11.n64_u64[0];
              v48 = CarForScript->m_pMat;
              v49 = -*(float *)&v57[0]._vptr$CEvent;
              LODWORD(v48->xx) = v57[0].m_iAccumulatedTime;
              v48->zx = 0.0;
              v48->yx = v49;
              CAutomobile::PlaceOnRoadProperly((CAutomobile *)CarForScript);
              *(_DWORD *)&CarForScript->m_nVehicleFlags &= ~8u;
              CVehicle::SetVehicleCreatedBy(CarForScript, 2, 0);
              *((_DWORD *)&CarForScript->m_nVehicleFlags + 1) |= 0x800u;
            }
          }
        }
        v50 = (float)((float)((float)rand() * 4.6566e-10) * 4.0) + -2.0;
        v51 = v10.n64_f32[1] + (float)((float)((float)((float)rand() * 4.6566e-10) * 4.0) + -2.0);
        v52 = CWorld::FindGroundZFor3DCoord(v10.n64_f32[0] + v50, v51, v55 + 1.0, 0, 0);
        v53 = &MI_PICKUP_BODYARMOUR;
        if ( (rand() & 1) != 0 )
          v53 = &MI_PICKUP_HEALTH;
        v58.y = v51;
        v58.z = v52 + 0.75;
        v58.x = v10.n64_f32[0] + v50;
        CPickups::GenerateNewOne(v58, *v53, 5, 0, 0, 0, 0);
        return 1;
      }
      return 0;
    }
  }
  return v5;
}
// 30D8A0: variable 'bIgnoreInteriors' is possibly undefined
// 30D8DC: variable 'v1' is possibly undefined
// 30DD1A: variable 'v55' is possibly undefined
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (0030DF74) --------------------------------------------------------
void __fastcall CGangWars::MakeEnemyGainInfluenceInZone(Int32 Gang, Int32 Points)
{
  unsigned int v2; // lr
  _BOOL4 v3; // r12

  v2 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
  if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
  {
    v3 = CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
       + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] <= v2;
  }
  else
  {
    if ( !CGangWars::pZoneInfoToFightOver )
      return;
    v3 = 0;
  }
  if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[0] + CGangWars::pZoneInfoToFightOver->aGangStrengths[2] + v2 )
  {
    CGangWars::pZoneInfoToFightOver->aGangStrengths[Gang] += Points;
    if ( v3
      && (!CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
       || CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
        + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] > CGangWars::pZoneInfoToFightOver->aGangStrengths[1]) )
    {
      sub_194CA0(0xEBu, 1.0);
    }
  }
}

//----- (0030DFF0) --------------------------------------------------------
void __fastcall CGangWars::StrengthenPlayerInfluenceInZone(Int32 Amount)
{
  unsigned int v1; // r2
  int v2; // r3
  int v3; // r0

  v1 = CGangWars::pZoneInfoToFightOver->aGangStrengths[1];
  if ( CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
    && CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
     + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] <= v1 )
  {
    v2 = 1;
    if ( v1 > 0x36 )
      goto LABEL_7;
  }
  else
  {
    v2 = 0;
    if ( v1 > 0x36 )
      goto LABEL_7;
  }
  v3 = Amount + v1;
  if ( v3 >= 55 )
    LOBYTE(v3) = 55;
  CGangWars::pZoneInfoToFightOver->aGangStrengths[1] = v3;
LABEL_7:
  if ( !v2
    && CGangWars::pZoneInfoToFightOver->aGangStrengths[1]
    && CGangWars::pZoneInfoToFightOver->aGangStrengths[2]
     + (unsigned int)CGangWars::pZoneInfoToFightOver->aGangStrengths[0] <= CGangWars::pZoneInfoToFightOver->aGangStrengths[1] )
  {
    sub_194CA0(0xEAu, 1.0);
  }
}

//----- (0030E050) --------------------------------------------------------
void __fastcall CGangWars::AddKillToProvocation(Int32 PedType)
{
  bool v2; // zf
  int v3; // r2

  if ( CGangWars::bCanTriggerGangWarWhenOnAMission || !CTheScripts::IsPlayerOnAMission() )
  {
    v2 = PedType == 9;
    if ( PedType != 9 )
      v2 = PedType == 7;
    if ( v2 )
    {
      if ( CGangWars::NumSpecificZones )
      {
        if ( CGangWars::NumSpecificZones < 1 )
          return;
        v3 = 0;
        while ( !CTheZones::ZoneInfoArray[CTheZones::NavigationZoneArray[CGangWars::aSpecificZones[v3]].ZoneInfoIndex
                                        - 1].aGangStrengths[PedType + 10] )
        {
          if ( ++v3 >= CGangWars::NumSpecificZones )
            return;
        }
      }
      CGangWars::Provocation = CGangWars::Provocation + 1.0;
    }
  }
}

//----- (0030E0FC) --------------------------------------------------------
Int32 CGangWars::DontCreateCivilians()
{
  Int32 result; // r0

  result = CGangWars::State;
  if ( CGangWars::State )
    return 1;
  return result;
}

//----- (0030E110) --------------------------------------------------------
bool __fastcall CGangWars::PedStreamedInForThisGang(Int32 Gang)
{
  UInt32 v1; // r1
  int v2; // r12
  UInt16 *v4; // r1
  int i; // r2

  v1 = CPopulation::m_TranslationArray[Gang + 18][0];
  v2 = CPopulation::m_nNumPedsInGroup[v1];
  if ( v2 < 1 )
    return 0;
  v4 = CPopulation::m_PedGroups[v1];
  for ( i = 0; i < v2; ++i )
  {
    if ( CStreaming::ms_aInfoForModel[v4[i]].m_status == 1 )
      return 1;
  }
  return 0;
}

//----- (0030E17C) --------------------------------------------------------
bool __fastcall CGangWars::PickStreamedInPedForThisGang(Int32 Gang, Int32 *pMI)
{
  UInt32 *v3; // r10
  UInt32 v4; // r0
  UInt32 *v5; // r10
  UInt32 v6; // t1
  int v7; // r2
  int v8; // r6
  int v9; // r1
  Int32 v10; // r0
  bool result; // r0

  v3 = CPopulation::m_TranslationArray[Gang];
  v6 = v3[54];
  v5 = v3 + 54;
  v4 = v6;
  v7 = CPopulation::m_nNumPedsInGroup[v6];
  if ( v7 < 1 )
    return 0;
  v8 = 0;
  v9 = CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry;
  while ( 1 )
  {
    v9 = (v9 + 1) % v7;
    v10 = CPopulation::m_PedGroups[v4][v9];
    *pMI = v10;
    if ( CStreaming::ms_aInfoForModel[v10].m_status == 1 )
      break;
    v4 = *v5;
    ++v8;
    v7 = CPopulation::m_nNumPedsInGroup[*v5];
    if ( v8 >= v7 )
    {
      result = 0;
      goto LABEL_8;
    }
  }
  result = 1;
LABEL_8:
  CGangWars::PickStreamedInPedForThisGang(int,int *)::ModelToTry = v9;
  return result;
}

//----- (0030E22C) --------------------------------------------------------
void __fastcall CGangWars::SetGangWarsActive(bool bActive)
{
  _BOOL4 v1; // r4

  v1 = bActive;
  if ( bActive != CGangWars::bGangWarsActive )
  {
    CTheZones::FillZonesWithGangColours(!bActive);
    CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10)
                                                                               * 0.9)
                                                                       + 0.6)
                                                               * 1080000.0);
    if ( !v1 )
      CGangWars::EndGangWar(0);
  }
  CGangWars::bGangWarsActive = v1;
}

//----- (0030E2B4) --------------------------------------------------------
void CGangWars::SwitchGangWarsActive()
{
  _BOOL4 v0; // r4

  v0 = CGangWars::bGangWarsActive;
  CTheZones::FillZonesWithGangColours(CGangWars::bGangWarsActive);
  CGangWars::TimeTillNextAttack = (float)(unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10) * 0.9)
                                                                     + 0.6)
                                                             * 1080000.0);
  if ( v0 )
    CGangWars::EndGangWar(0);
  CGangWars::bGangWarsActive = !v0;
}

//----- (0030E338) --------------------------------------------------------
int CGangWars::GangWarGoingOn()
{
  int result; // r0

  result = CGangWars::State | CGangWars::State2;
  if ( CGangWars::State | CGangWars::State2 )
    return 1;
  return result;
}

//----- (0030E358) --------------------------------------------------------
bool CGangWars::GangWarFightingGoingOn()
{
  return CGangWars::State != 0 || CGangWars::State2 == 2;
}

//----- (0030E384) --------------------------------------------------------
bool __fastcall CGangWars::DoesPlayerControlThisZone(CZoneInfo *pZoneInfo)
{
  return pZoneInfo->aGangStrengths[1]
      && pZoneInfo->aGangStrengths[2] + (unsigned int)pZoneInfo->aGangStrengths[0] <= pZoneInfo->aGangStrengths[1];
}

//----- (0030E39C) --------------------------------------------------------
void __fastcall CGangWars::TellStreamingWhichGangsAreNeeded(Int32 *pRequiredGangs)
{
  float32x2_t v2; // d16
  unsigned __int64 v3; // d0
  CVector v4[2]; // [sp+0h] [bp-18h] BYREF

  if ( CGangWars::State2 )
  {
    FindPlayerCoors(v4, -1);
    v2.n64_u64[0] = vsub_f32(*(float32x2_t *)&v4[0].x, *(float32x2_t *)&CGangWars::PointOfAttack.x).n64_u64[0];
    v3 = vmul_f32(v2, v2).n64_u64[0];
    if ( sqrtf(*(float *)&v3 + *((float *)&v3 + 1)) < 150.0 )
      *pRequiredGangs |= 1 << CGangWars::Gang1;
  }
}

//----- (0030E40C) --------------------------------------------------------
void CGangWars::ClearSpecificZonesToTriggerGangWar()
{
  CGangWars::NumSpecificZones = 0;
  sub_199EFC(0);
}

//----- (0030E420) --------------------------------------------------------
void __fastcall CGangWars::SetSpecificZoneToTriggerGangWar(Int32 Zone)
{
  Int32 v1; // r3

  v1 = CGangWars::NumSpecificZones++;
  CGangWars::aSpecificZones[v1] = Zone;
  sub_199EFC(0);
}

//----- (0030E448) --------------------------------------------------------
void CGarages::Init()
{
  int v0; // r4
  _WORD *v1; // r5

  *(_QWORD *)CGarages::CarTypesCollected = 0LL;
  *(_QWORD *)&CGarages::CarTypesCollected[2] = 0LL;
  CGarages::MessageEndTime = 0;
  CGarages::BankVansCollected = 0;
  CGarages::CrushedCarId = -1;
  CGarages::LastGaragePlayerWasIn = -1;
  CGarages::NumGarages = 0;
  CGarages::MessageStartTime = 0;
  CGarages::PoliceCarsCollected = 0;
  CGarages::LastTimeHelpMessage = 0;
  CGarages::NoResprays = 0;
  v0 = 0;
  CGarages::PlayerInGarage = 0;
  CGarages::BombsAreFree = 0;
  CGarages::CarsCollected = 0;
  do
  {
    v1 = (_WORD *)((char *)CGarages::aCarsInSafeHouse + v0);
    v0 += 64;
    v1[2057] = 0;
    v1[2185] = 0;
    v1[2313] = 0;
    v1[2441] = 0;
    v1[137] = 0;
    v1[9] = 0;
    v1[265] = 0;
    v1[393] = 0;
    v1[521] = 0;
    v1[649] = 0;
    v1[777] = 0;
    v1[905] = 0;
    v1[1033] = 0;
    v1[1289] = 0;
    v1[1161] = 0;
    v1[1417] = 0;
    v1[1545] = 0;
    v1[1673] = 0;
    v1[1801] = 0;
    v1[1929] = 0;
  }
  while ( v0 != 256 );
}

//----- (0030E574) --------------------------------------------------------
void CGarages::Shutdown()
{
  int v0; // r4

  v0 = 80;
  CGarages::NumGarages = 0;
  do
  {
    CAEDoorAudioEntity::Reset((CAEDoorAudioEntity *)((char *)CGarages::aGarages + v0));
    v0 += 216;
  }
  while ( v0 != 10880 );
}

//----- (0030E5A4) --------------------------------------------------------
void CGarages::Init_AfterRestart()
{
  UInt32 v0; // r5
  CAEDoorAudioEntity *p_m_DoorAudioEntity; // r4
  int m_fDoorTurnSpeedLastFrame_high; // r1
  char v3; // r0
  char v4; // r0
  float v5; // s0
  int v6; // r4
  _WORD *v7; // r2

  if ( CGarages::NumGarages )
  {
    v0 = 0;
    p_m_DoorAudioEntity = &CGarages::aGarages[0].m_DoorAudioEntity;
    do
    {
      m_fDoorTurnSpeedLastFrame_high = HIBYTE(p_m_DoorAudioEntity[-1].m_fDoorTurnSpeedLastFrame);
      v3 = BYTE2(p_m_DoorAudioEntity[-1].m_fDoorTurnSpeedLastFrame);
      BYTE1(p_m_DoorAudioEntity[-1].m_fDoorTurnSpeedLastFrame) = 0;
      p_m_DoorAudioEntity[-1].ScratchSound.m_fHeadroom = 0.0;
      LOBYTE(p_m_DoorAudioEntity[-1].m_fDoorTurnSpeedLastFrame) = m_fDoorTurnSpeedLastFrame_high;
      BYTE2(p_m_DoorAudioEntity[-1].m_fDoorTurnSpeedLastFrame) = v3 & 0x39 | 0x40;
      v4 = 1;
      v5 = 1.0;
      switch ( m_fDoorTurnSpeedLastFrame_high )
      {
        case 1:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
          v5 = 0.0;
          v4 = 0;
          goto LABEL_5;
        case 2:
        case 3:
        case 4:
        case 5:
LABEL_5:
          *(float *)&p_m_DoorAudioEntity[-1].ScratchSound.m_bRequestedStopped = v5;
          BYTE1(p_m_DoorAudioEntity[-1].m_fDoorTurnSpeedLastFrame) = v4;
          break;
        default:
          break;
      }
      CAEDoorAudioEntity::Reset(p_m_DoorAudioEntity);
      ++v0;
      p_m_DoorAudioEntity = (CAEDoorAudioEntity *)((char *)p_m_DoorAudioEntity + 216);
    }
    while ( v0 < CGarages::NumGarages );
  }
  v6 = 0;
  CGarages::NoResprays = 0;
  do
  {
    v7 = (_WORD *)((char *)CGarages::aCarsInSafeHouse + v6);
    v6 += 64;
    v7[2057] = 0;
    v7[2185] = 0;
    v7[2313] = 0;
    v7[2441] = 0;
    v7[137] = 0;
    v7[9] = 0;
    v7[265] = 0;
    v7[393] = 0;
    v7[521] = 0;
    v7[649] = 0;
    v7[777] = 0;
    v7[905] = 0;
    v7[1033] = 0;
    v7[1289] = 0;
    v7[1161] = 0;
    v7[1417] = 0;
    v7[1545] = 0;
    v7[1673] = 0;
    v7[1801] = 0;
    v7[1929] = 0;
  }
  while ( v6 != 256 );
}

//----- (0030E6F0) --------------------------------------------------------
void __fastcall CGarage::InitDoorsAtStart(CGarage *this)
{
  int Type; // r1
  char v2; // r2
  int v3; // r2
  float v4; // s0
  UInt8 v5; // r1

  Type = this->Type;
  v2 = *(_BYTE *)&this->Flags & 0x39;
  this->TimeOfNextEvent = 0;
  this->State = 0;
  this->Flags = (CGarageFlags)(v2 | 0x40);
  v3 = Type - 1;
  v4 = 1.0;
  v5 = 1;
  switch ( v3 )
  {
    case 0:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
      v4 = 0.0;
      v5 = 0;
      goto LABEL_3;
    case 1:
    case 2:
    case 3:
    case 4:
LABEL_3:
      this->Openness = v4;
      this->State = v5;
      break;
    case 12:
      return;
  }
}

//----- (0030E760) --------------------------------------------------------
void CGarages::Update()
{
  Int32 v0; // r5
  CGarage *v1; // r4
  CGarage *pToGarageWeAreIn; // r3
  UInt32 v3; // r0
  CSimpleTransform *p_tx; // r1

  if ( !CGameLogic::IsCoopGameGoingOn() )
  {
    v0 = 0;
    v1 = CGarages::aGarages;
    pToGarageWeAreIn = TheCamera.pToGarageWeAreIn;
    TheCamera.pToGarageWeAreIn = 0;
    CGarages::bCamShouldBeOutside = 0;
    TheCamera.pToGarageWeAreInForHackAvoidFirstPerson = 0;
    pOldToGarageWeAreIn = pToGarageWeAreIn;
    do
    {
      if ( v1->Type )
        CGarage::Update(v1, v0);
      ++v0;
      ++v1;
    }
    while ( v0 != 50 );
    if ( (CTimer::m_FrameCounter & 0xF) == 12 )
    {
      v3 = CGarages::Update(void)::GarageToBeTidied + 1;
      if ( CGarages::Update(void)::GarageToBeTidied + 1 > 0x31 )
        v3 = 0;
      CGarages::Update(void)::GarageToBeTidied = v3;
      if ( CGarages::aGarages[v3].Type )
      {
        p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_tx = &TheCamera.m_transform;
        if ( fabsf(p_tx->m_translate.x - CGarages::aGarages[v3].MinX) <= 40.0
          && fabsf(p_tx->m_translate.y - CGarages::aGarages[v3].MinY) <= 40.0 )
        {
          CGarage::TidyUpGarageClose(&CGarages::aGarages[v3]);
        }
        else
        {
          CGarage::TidyUpGarage(&CGarages::aGarages[v3]);
        }
      }
    }
  }
}

//----- (0030E8A0) --------------------------------------------------------
void __fastcall CGarage::Update(CGarage *this, Int32 MyIndex)
{
  int v2; // r10
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  CVehicle *PlayerVehicle; // r6
  CEntity *PlayerPed; // r5
  CMatrix *m_pMat; // r1
  float *p_tx; // r0
  float v11; // s4
  CGarageFlags Flags; // r0
  int State; // r1
  CGarageFlags v14; // r0
  int Type; // r0
  float v16; // s16
  float v17; // s2
  float v18; // s2
  float v19; // s16
  float v20; // s2
  float v21; // s2
  CEntity *v22; // r0
  tAudioEvent v23; // r1
  float v24; // s16
  float v25; // s2
  float v26; // s16
  CVehicle *v27; // r0
  int v28; // r1
  int v29; // r0
  CVehicle *v30; // r0
  CAutomobile *v31; // r1
  CVehicle *v32; // r0
  CMatrix *v33; // r1
  float *v34; // r2
  float v35; // s16
  CVehicle *v36; // r0
  CMatrix *v37; // r1
  float v38; // s2
  CSimpleTransform *v39; // r2
  float v40; // s0
  float v41; // s2
  float v42; // s16
  float v43; // s2
  float v44; // s16
  int v45; // r1
  int v46; // r0
  float MinX; // s16
  float MaxX; // s18
  float m_red; // s20
  float v50; // s22
  float v51; // s24
  float x; // s26
  float MinY; // s28
  float MaxY; // s30
  float y; // s17
  CAutomobile *pCarToCollect; // r1
  eWantedLevel m_WantedLevel; // r8
  CWanted *v58; // r0
  char v59; // r11
  int v60; // r0
  float BaseZ; // r0
  float v62; // r2
  float v63; // r3
  float v64; // r6
  float CeilingZ; // r0
  int v66; // r6
  int v67; // r0
  CVehicle *v68; // r0
  CAutomobile *v69; // r1
  CVehicle *v70; // r0
  CMatrix *v71; // r1
  float *v72; // r2
  float v73; // s16
  CVehicle *v74; // r0
  CMatrix *v75; // r1
  float v76; // s2
  CSimpleTransform *v77; // r2
  float v78; // s0
  float v79; // s2
  int v80; // r0
  CAutomobile *v81; // r1
  CVehicle *v82; // r0
  int v83; // r0
  float v84; // s16
  float v85; // s18
  float v86; // s20
  float v87; // s22
  float v88; // s24
  float v89; // s26
  float v90; // s28
  float v91; // s30
  float v92; // s17
  UInt8 v93; // r0
  float v94; // s4
  float v95; // s0
  float v96; // s16
  CVehicle *v97; // r0
  Int32 v98; // r0
  int v99; // r2
  CVehicle *v100; // r0
  CAutomobile *v101; // r1
  float v102; // s16
  float v103; // s18
  float v104; // s20
  float v105; // s22
  float v106; // s24
  float v107; // s26
  float v108; // s28
  float v109; // s30
  float v110; // s17
  CVehicle *v111; // r0
  int v112; // r1
  int v113; // r0
  CPad *v114; // r0
  CWanted *v115; // r0
  CEntity *v116; // r0
  int v117; // r0
  uint32 v118; // r1
  tAudioEvent v119; // r1
  CVehicle *v120; // r0
  float v121; // s4
  float v122; // s0
  float v123; // s0
  CVehicle *v124; // r0
  int v125; // r5
  Int32 v126; // r6
  int v127; // r0
  float v128; // s2
  float v129; // s18
  UInt8 v130; // r1
  int v131; // r0
  unsigned __int8 v132; // r1
  float v133; // s16
  float v134; // s18
  float v135; // s20
  float v136; // s22
  float v137; // s24
  float v138; // s26
  float v139; // s28
  float v140; // s30
  float v141; // s17
  CAutomobile *v142; // r5
  CAutomobile *v143; // r1
  float v144; // r0
  float v145; // r2
  float v146; // r3
  float v147; // r6
  float v148; // r0
  int v149; // r6
  CPad *v150; // r0
  CAutomobile *v151; // r1
  CAutomobile *v152; // r0
  float v153; // s16
  float v154; // s18
  float v155; // s20
  float v156; // s22
  float v157; // s24
  float v158; // s26
  float v159; // s28
  float v160; // s30
  float v161; // s17
  CAutomobile *v162; // r1
  float v163; // s2
  float v164; // s18
  unsigned __int8 v165; // r0
  int v166; // r0
  float v167; // r5
  int v168; // r0
  int v169; // r4
  float *v170; // r1
  float v171; // s16
  CVehicle *v172; // r0
  CMatrix *v173; // r1
  int v174; // r2
  float *v175; // r3
  float *v176; // r0
  float v177; // s18
  float v178; // s20
  CVehicle *v179; // r0
  CMatrix *v180; // r1
  int v181; // r2
  float *v182; // r3
  int v183; // r0
  float v184; // s22
  float v185; // s24
  CVehicle *v186; // r0
  CMatrix *v187; // r1
  int v188; // r2
  CSimpleTransform *v189; // r3
  float v190; // s26
  float v191; // s28
  CVehicle *v192; // r0
  CMatrix *v193; // r1
  CSimpleTransform *v194; // r2
  RwReal v195; // r5
  int v196; // r0
  int v197; // r4
  float *v198; // r1
  float v199; // s16
  CVehicle *v200; // r0
  CMatrix *v201; // r1
  int v202; // r2
  float *v203; // r3
  float *v204; // r0
  float v205; // s18
  float v206; // s20
  CVehicle *v207; // r0
  CMatrix *v208; // r1
  int v209; // r2
  float *v210; // r3
  int v211; // r0
  float v212; // s22
  float v213; // s24
  CVehicle *v214; // r0
  CMatrix *v215; // r1
  int v216; // r2
  CSimpleTransform *v217; // r3
  float v218; // s26
  float v219; // s28
  CVehicle *v220; // r0
  CMatrix *v221; // r1
  CSimpleTransform *v222; // r2
  CVehicle *v223; // r0
  CVehicle *v224; // r0
  GxtChar *v225; // r0
  CVehicle *v226; // r0
  CAutomobile *v227; // r1
  bool v228; // zf
  CVehicle *v229; // r0
  unsigned __int8 v230; // r0
  int v231; // r0
  _BOOL4 IsStaticPlayerCarEntirelyInside; // r6
  CVehicle *v233; // r5
  int v234; // r0
  uint32 v235; // r1
  CVehicle *v236; // r0
  float StatValue; // r0
  CVehicle *v238; // r0
  int v239; // r1
  float v240; // s4
  float v241; // s0
  float v242; // s0
  float v243; // s2
  CPlayerInfo *v244; // r0
  Int32 *p_Score; // r0
  int v246; // r1
  int Score; // t1
  bool v248; // cc
  int v249; // r1
  UInt8 v250; // r5
  CVehicle *v251; // r0
  CPlayerPed *v252; // r5
  CPlayerPed *v253; // r5
  int32 m_nWeaponSlot; // r6
  int v255; // r0
  const char *v256; // r4
  GxtChar *v257; // r0
  float v258; // s4
  float v259; // s0
  CVehicle *v260; // r0
  CGarageFlags v261; // r0
  CEntity *v262; // r0
  CPad *v263; // r0
  CPad *v264; // r0
  CWanted *v265; // r0
  CPad *Pad; // r0
  CWanted *PlayerWanted; // r0
  CGarageFlags v268; // r0
  int v269; // r0
  tAudioEvent v270; // r1
  float m_nHealth; // s16
  char v272; // r8
  int32 m_baseVehicleType; // r5
  CVehicle *v274; // r0
  CVehicle *v275; // r0
  float xz; // s0
  float yz; // s0
  float zz; // s0
  float xx; // s0
  float yx; // s0
  float zx; // s0
  CVehicle *v282; // r9
  int v283; // r10
  CWanted *v284; // r0
  CWanted *v285; // r0
  CVehicle *v286; // r0
  CMatrix *v287; // r1
  float *p_x; // r2
  float v289; // s16
  CVehicle *v290; // r0
  CMatrix *v291; // r1
  float v292; // s0
  CSimpleTransform *v293; // r2
  float v294; // s4
  float v295; // s6
  float v296; // s2
  float v297; // s2
  float v298; // s4
  float v299; // s8
  int v300; // r0
  uint32 v301; // r1
  uint8 *p_m_colour2; // r12
  int m_colour2; // r2
  int m_colour3; // r3
  int m_colour4; // r1
  int v306; // r5
  int v307; // r11
  RwRGBA_0 *v308; // r0
  unsigned int green; // r1
  float blue; // s6
  CMatrix *v311; // r0
  CSimpleTransform *p_m_transform; // r1
  __int64 v313; // d16
  int v314; // r0
  CPlayerInfo *v315; // r0
  Int32 *v316; // r0
  int v317; // r1
  int v318; // t1
  int v319; // r1
  int v320; // r0
  uint32 v321; // r1
  int v322; // r0
  int v323; // r0
  int v324; // r0
  int v325; // r0
  int v326; // r0
  uint32 v327; // r1
  CPad *v328; // r0
  char v329; // [sp+20h] [bp-D0h]
  eWantedLevel v330; // [sp+24h] [bp-CCh]
  CVector v331; // [sp+28h] [bp-C8h] BYREF
  uint8 v332; // [sp+35h] [bp-BBh] BYREF
  uint8 col3; // [sp+36h] [bp-BAh] BYREF
  uint8 col2; // [sp+37h] [bp-B9h] BYREF
  FxPrtMult_c ppResults[2]; // [sp+38h] [bp-B8h] BYREF
  CVector CoorsMax; // [sp+78h] [bp-78h] BYREF
  CVector CoorsMin; // [sp+84h] [bp-6Ch] BYREF

  if ( this->Type != 13 && this->State <= 5u && FindPlayerPed(-1) && (*(_BYTE *)&this->Flags & 0x20) == 0 )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    PlayerPed = FindPlayerPed(-1);
    if ( *((unsigned __int8 *)&FindPlayerPed(-1)->m_nPedFlags + 1) << 31
      && FindPlayerPed(-1)->m_pMyVehicle
      && FindPlayerPed(-1)->m_pMyVehicle->m_nModelIndex == 571 )
    {
      PlayerPed = FindPlayerPed(-1)->m_pMyVehicle;
    }
    if ( CGarage::IsEntityEntirelyInside3D(this, PlayerPed, 0.25) )
    {
      TheCamera.pToGarageWeAreIn = this;
      CGarages::bCamShouldBeOutside = 1;
    }
    if ( PlayerVehicle )
    {
      if ( !CGarage::IsEntityEntirelyOutside(this, PlayerVehicle, 0.0) )
        TheCamera.pToGarageWeAreInForHackAvoidFirstPerson = this;
      if ( PlayerVehicle->m_nModelIndex == 423 )
      {
        m_pMat = PlayerVehicle->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &PlayerVehicle->m_transform.m_translate.x;
        if ( *p_tx > (float)(this->MinX + -0.5) && *p_tx < (float)(this->MaxX + 0.5) )
        {
          v11 = p_tx[1];
          if ( v11 > (float)(this->MinY + -0.5) && v11 < (float)(this->MaxY + 0.5) )
          {
            TheCamera.pToGarageWeAreIn = this;
            CGarages::bCamShouldBeOutside = 1;
          }
        }
      }
    }
  }
  Flags = this->Flags;
  if ( (*(_BYTE *)&Flags & 2) == 0 || this->State )
  {
    if ( (*(_BYTE *)&this->Flags & 8) != 0 )
    {
      State = this->State;
      if ( State == 1 || State == 3 && this->Openness > 0.4 )
        v14 = (CGarageFlags)(*(_BYTE *)&Flags & 0xBF);
      else
        v14 = (CGarageFlags)(*(_BYTE *)&Flags | 0x40);
      this->Flags = v14;
    }
    Type = this->Type;
    switch ( this->Type )
    {
      case 1u:
        switch ( this->State )
        {
          case 0u:
            goto LABEL_105;
          case 1u:
            FindPlayerCoors((CVector *)ppResults, -1);
            MinX = this->MinX;
            MaxX = this->MaxX;
            m_red = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v50 = this->MinX;
            v51 = this->MaxX;
            x = CoorsMin.x;
            FindPlayerCoors(&CoorsMax, -1);
            MinY = this->MinY;
            MaxY = this->MaxY;
            y = CoorsMax.y;
            FindPlayerCoors(&v331, -1);
            if ( (float)((float)((float)(m_red - (float)((float)(MinX + MaxX) * 0.5))
                               * (float)(x - (float)((float)(v50 + v51) * 0.5)))
                       + (float)((float)(y - (float)((float)(MinY + MaxY) * 0.5))
                               * (float)(v331.y - (float)((float)(this->MinY + this->MaxY) * 0.5)))) > 900.0 )
            {
              if ( (unsigned __int8)CTimer::m_FrameCounter << 27 )
                return;
              pCarToCollect = this->pCarToCollect;
              if ( pCarToCollect )
              {
                if ( CGarage::IsEntityTouching3D(this, pCarToCollect) )
                  return;
              }
              goto LABEL_422;
            }
            v226 = FindPlayerVehicle(-1, 0);
            v227 = this->pCarToCollect;
            v228 = v227 == 0;
            if ( v227 )
              v228 = v226 == v227;
            if ( v228 || !CGarage::IsEntityEntirelyInside3D(this, v227, 0.0) )
              return;
            v229 = FindPlayerVehicle(-1, 0) ? FindPlayerVehicle(-1, 0) : (CVehicle *)FindPlayerPed(-1);
            if ( !CGarage::IsEntityEntirelyOutside(this, v229, 2.0) )
              return;
            break;
          case 2u:
            v151 = this->pCarToCollect;
            if ( v151 )
              CGarage::ThrowCarsNearDoorOutOfGarage(this, v151);
            if ( !CGarage::SlideDoorClosed(this) )
              return;
            if ( *(_BYTE *)&this->Flags << 31 )
              goto LABEL_151;
            v152 = this->pCarToCollect;
            if ( !v152 )
              goto LABEL_386;
            this->State = 5;
            DestroyVehicleAndDriverAndPassengers(v152);
            this->pCarToCollect = 0;
            goto LABEL_163;
          case 3u:
            goto LABEL_128;
          default:
            return;
        }
LABEL_433:
        Pad = CPad::GetPad(0);
        Pad->DisablePlayerControls |= 4u;
        PlayerWanted = FindPlayerWanted(-1);
        *((_BYTE *)PlayerWanted + 30) |= 2u;
        goto LABEL_434;
      case 2u:
      case 3u:
      case 4u:
        switch ( this->State )
        {
          case 0u:
            if ( CTimer::m_snTimeInMilliseconds <= this->TimeOfNextEvent )
              return;
            switch ( Type )
            {
              case 2:
                v23 = 18;
                break;
              case 3:
                v23 = 19;
                break;
              case 4:
                if ( CStreaming::ms_aInfoForModel[364].m_status != 1 )
                {
LABEL_181:
                  CStreaming::RequestModel(364, 2);
                  return;
                }
                v23 = 20;
                break;
              default:
                goto LABEL_348;
            }
            CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, v23, 0.0, 1.0);
LABEL_348:
            this->State = 3;
            if ( !CGarages::BombsAreFree )
            {
              v244 = &CWorld::Players[CWorld::PlayerInFocus];
              Score = v244->Score;
              p_Score = &v244->Score;
              v246 = Score;
              if ( Score >= 1 )
              {
                v248 = v246 < 500;
                v249 = v246 - 500;
                if ( v248 )
                  v249 = 0;
                *p_Score = v249;
              }
            }
            if ( FindPlayerVehicle(-1, 0)
              && (!FindPlayerVehicle(-1, 0)->m_baseVehicleType || FindPlayerVehicle(-1, 0)->m_baseVehicleType == 9) )
            {
              v250 = this->Type;
              v251 = FindPlayerVehicle(-1, 0);
              *((_BYTE *)v251 + 1202) = *((_BYTE *)v251 + 1202) & 0xF8 | (v250 + 7) & 7;
              v252 = FindPlayerPed(-1);
              FindPlayerVehicle(-1, 0)->pBombOwner = v252;
              if ( this->Type == 4 )
              {
                v253 = FindPlayerPed(-1);
                m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_DETONATOR, 1)->m_nWeaponSlot;
                CPed::GiveWeapon(v253, WEAPONTYPE_DETONATOR, 1u, 1);
                v253->m_WeaponSlots[m_nWeaponSlot].m_eState = WEAPONSTATE_READY;
                v253->m_pPlayerData->m_nChosenWeapon = m_nWeaponSlot;
                if ( v253->m_eStoredWeapon != WEAPONTYPE_UNIDENTIFIED )
                  v253->m_eStoredWeapon = WEAPONTYPE_DETONATOR;
              }
              CStats::IncrementStat(0x7Fu, 10.0);
            }
            v255 = this->Type;
            switch ( v255 )
            {
              case 4:
                v256 = "GA_8";
                break;
              case 3:
                v256 = "GA_7";
                break;
              case 2:
                v256 = "GA_6";
                break;
              default:
                return;
            }
            v257 = CText::Get(&TheText, (const unsigned __int8 *)v256);
            CHud::SetHelpMessage((const unsigned __int8 *)v256, v257, 0, 0, 1, 0);
            return;
          case 1u:
            if ( !CGarage::IsStaticPlayerCarEntirelyInside(this)
              || !FindPlayerVehicle(-1, 0)
              || FindPlayerVehicle(-1, 0)->m_vehicleType == 9
              || FindPlayerVehicle(-1, 0)->m_vehicleType == 10 )
            {
              return;
            }
            if ( *((unsigned __int8 *)FindPlayerVehicle(-1, 0) + 1202) << 29 )
            {
              v117 = strcmp("GA_5", (const char *)CGarages::MessageIDString);
              v118 = CTimer::m_snTimeInMilliseconds;
              if ( v117
                || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
              {
                strcpy((char *)CGarages::MessageIDString, "GA_5");
              }
              else
              {
                if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                  goto LABEL_174;
                v118 = CTimer::m_snTimeInMilliseconds - 500;
              }
              CGarages::MessageEndTime = v118 + 4000;
              CGarages::MessageStartTime = v118;
              CGarages::MessageNumberInString = -1;
              CGarages::MessageNumberInString2 = -1;
LABEL_174:
              this->State = 4;
              v119 = 17;
LABEL_175:
              CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, v119, 0.0, 1.0);
              return;
            }
            if ( CGarages::BombsAreFree || CWorld::Players[CWorld::PlayerInFocus].Score >= 500 )
            {
              this->State = 2;
              v264 = CPad::GetPad(0);
              v264->DisablePlayerControls |= 4u;
              v265 = FindPlayerWanted(-1);
              *((_BYTE *)v265 + 30) |= 2u;
              return;
            }
            v300 = strcmp("GA_4", (const char *)CGarages::MessageIDString);
            v301 = CTimer::m_snTimeInMilliseconds;
            if ( v300
              || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
              || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
            {
              strcpy((char *)CGarages::MessageIDString, "GA_4");
            }
            else
            {
              if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                goto LABEL_492;
              v301 = CTimer::m_snTimeInMilliseconds - 500;
            }
            CGarages::MessageEndTime = v301 + 4000;
            CGarages::MessageStartTime = v301;
            CGarages::MessageNumberInString = -1;
            CGarages::MessageNumberInString2 = -1;
LABEL_492:
            this->State = 4;
            v119 = 14;
            goto LABEL_175;
          case 2u:
            if ( FindPlayerVehicle(-1, 0) )
            {
              v120 = FindPlayerVehicle(-1, 0);
              CGarage::ThrowCarsNearDoorOutOfGarage(this, v120);
            }
            if ( CGarage::SlideDoorClosed(this) )
            {
              this->State = 0;
              this->TimeOfNextEvent = CTimer::m_snTimeInMilliseconds + 2000;
            }
            if ( this->Type == 4 )
              goto LABEL_181;
            return;
          case 3u:
            goto LABEL_160;
          case 4u:
            goto LABEL_164;
          default:
            return;
        }
      case 5u:
        FindPlayerCoors((CVector *)ppResults, -1);
        if ( ppResults[0].m_blue >= 950.0 )
          return;
        switch ( this->State )
        {
          case 0u:
            if ( CGarages::NoResprays )
              return;
            if ( CTimer::m_snTimeInMilliseconds <= this->TimeOfNextEvent )
              goto LABEL_338;
            this->State = 3;
            m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
            if ( m_WantedLevel )
            {
              v58 = FindPlayerWanted(-1);
              CWanted::ClearWantedLevelAndGoOnParole(v58);
              v59 = 1;
            }
            else
            {
              v59 = 0;
            }
            if ( !FindPlayerVehicle(-1, 0)
              || FindPlayerVehicle(-1, 0)->m_baseVehicleType && FindPlayerVehicle(-1, 0)->m_baseVehicleType != 9 )
            {
              goto LABEL_513;
            }
            v330 = m_WantedLevel;
            m_nHealth = FindPlayerVehicle(-1, 0)->m_nHealth;
            v3.n64_u32[0] = 1148846080;
            v4.n64_u32[0] = LODWORD(FindPlayerVehicle(-1, 0)->m_nHealth);
            v272 = 0;
            LODWORD(FindPlayerVehicle(-1, 0)->m_nHealth) = vmax_f32(v4, v3).n64_u32[0];
            if ( m_nHealth < 970.0 )
              v272 = 1;
            m_baseVehicleType = FindPlayerVehicle(-1, 0)->m_baseVehicleType;
            v274 = FindPlayerVehicle(-1, 0);
            if ( m_baseVehicleType )
              *(_DWORD *)&v274[1].m_VehicleAudioEntity.m_DummySlot = 0;
            else
              v274[1].m_VehicleAudioEntity.m_SkidSound.m_pAudioEntity = 0;
            v275 = FindPlayerVehicle(-1, 0);
            (*((void (__fastcall **)(CVehicle *))v275->_vptr$CPlaceable + 51))(v275);
            CStats::IncrementStat(0x8Au, 1.0);
            if ( FindPlayerVehicle(-1, 0)->m_pMat->zz < 0.0 )
            {
              xz = FindPlayerVehicle(-1, 0)->m_pMat->xz;
              FindPlayerVehicle(-1, 0)->m_pMat->xz = -xz;
              yz = FindPlayerVehicle(-1, 0)->m_pMat->yz;
              FindPlayerVehicle(-1, 0)->m_pMat->yz = -yz;
              zz = FindPlayerVehicle(-1, 0)->m_pMat->zz;
              FindPlayerVehicle(-1, 0)->m_pMat->zz = -zz;
              xx = FindPlayerVehicle(-1, 0)->m_pMat->xx;
              FindPlayerVehicle(-1, 0)->m_pMat->xx = -xx;
              yx = FindPlayerVehicle(-1, 0)->m_pMat->yx;
              FindPlayerVehicle(-1, 0)->m_pMat->yx = -yx;
              zx = FindPlayerVehicle(-1, 0)->m_pMat->zx;
              FindPlayerVehicle(-1, 0)->m_pMat->zx = -zx;
            }
            v59 |= v272;
            v282 = FindPlayerVehicle(-1, 0);
            m_WantedLevel = v330;
            v283 = 0;
            if ( (v282[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_BankSlotID & 2) != 0 )
              goto LABEL_512;
            v329 = v59;
            if ( CVehicle::GetRemapIndex(v282) > -1 )
            {
              v283 = 0;
LABEL_511:
              v59 = v329;
              m_WantedLevel = v330;
LABEL_512:
              v314 = *((_DWORD *)&v282->m_nVehicleFlags + 1);
              v282->nBodyDirtLevel = 0.0;
              *((_DWORD *)&v282->m_nVehicleFlags + 1) = v314 & 0xFF7FFFFF;
              v2 = v283 != 0;
LABEL_513:
              if ( *(_BYTE *)&this->Flags > -1 )
              {
                if ( ((unsigned __int8)v59 & !CGarages::RespraysAreFree) == 1 )
                {
                  v315 = &CWorld::Players[CWorld::PlayerInFocus];
                  v318 = v315->Score;
                  v316 = &v315->Score;
                  v317 = v318;
                  if ( v318 >= 1 )
                  {
                    v248 = v317 < 100;
                    v319 = v317 - 100;
                    if ( v248 )
                      v319 = 0;
                    *v316 = v319;
                  }
                  CStats::IncrementStat(0x10u, 100.0);
                  if ( m_WantedLevel )
                  {
                    v320 = strcmp("GA_2", (const char *)CGarages::MessageIDString);
                    v321 = CTimer::m_snTimeInMilliseconds;
                    if ( v320
                      || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                      || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
                    {
                      strcpy((char *)CGarages::MessageIDString, "GA_2");
                    }
                    else
                    {
                      if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                        goto LABEL_537;
                      v321 = CTimer::m_snTimeInMilliseconds - 500;
                    }
                  }
                  else
                  {
                    v324 = strcmp("GA_XX", (const char *)CGarages::MessageIDString);
                    v321 = CTimer::m_snTimeInMilliseconds;
                    if ( v324
                      || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                      || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
                    {
                      strcpy((char *)CGarages::MessageIDString, "GA_XX");
                    }
                    else
                    {
                      if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                        goto LABEL_537;
                      v321 = CTimer::m_snTimeInMilliseconds - 500;
                    }
                  }
                  goto LABEL_536;
                }
                if ( v2 << 31 )
                {
                  if ( (rand() & 1) != 0 )
                  {
                    v325 = strcmp("GA_15", (const char *)CGarages::MessageIDString);
                    v321 = CTimer::m_snTimeInMilliseconds;
                    if ( v325
                      || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                      || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
                    {
                      strcpy((char *)CGarages::MessageIDString, "GA_15");
                    }
                    else
                    {
                      if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                        goto LABEL_537;
                      v321 = CTimer::m_snTimeInMilliseconds - 500;
                    }
                  }
                  else
                  {
                    v323 = strcmp("GA_16", (const char *)CGarages::MessageIDString);
                    v321 = CTimer::m_snTimeInMilliseconds;
                    if ( v323
                      || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                      || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
                    {
                      strcpy((char *)CGarages::MessageIDString, "GA_16");
                    }
                    else
                    {
                      if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                        goto LABEL_537;
                      v321 = CTimer::m_snTimeInMilliseconds - 500;
                    }
                  }
                  goto LABEL_536;
                }
LABEL_537:
                *(_BYTE *)&this->Flags |= 4u;
                if ( !FindPlayerVehicle(-1, 0) )
                  goto LABEL_338;
                v238 = FindPlayerVehicle(-1, 0);
                v239 = *((_DWORD *)&v238->m_nVehicleFlags + 1) | 0x1000000;
                goto LABEL_337;
              }
              v322 = strcmp("GA_22", (const char *)CGarages::MessageIDString);
              v321 = CTimer::m_snTimeInMilliseconds;
              if ( v322
                || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
              {
                strcpy((char *)CGarages::MessageIDString, "GA_22");
              }
              else
              {
                if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                  goto LABEL_537;
                v321 = CTimer::m_snTimeInMilliseconds - 500;
              }
LABEL_536:
              CGarages::MessageEndTime = v321 + 4000;
              CGarages::MessageStartTime = v321;
              CGarages::MessageNumberInString = -1;
              CGarages::MessageNumberInString2 = -1;
              goto LABEL_537;
            }
            CVehicleModelInfo::ChooseVehicleColour(
              (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[v282->m_nModelIndex],
              (uint8 *)&v331,
              &col2,
              &col3,
              &v332,
              1);
            if ( v282->m_colour1 == LOBYTE(v331.x) )
            {
              p_m_colour2 = &v282->m_colour2;
              m_colour2 = v282->m_colour2;
              if ( m_colour2 == col2 )
              {
                m_colour3 = v282->m_colour3;
                if ( m_colour3 == col3 )
                {
                  m_colour4 = v282->m_colour4;
                  if ( m_colour4 == v332 )
                  {
                    v306 = 0;
                    goto LABEL_505;
                  }
                }
              }
              else
              {
                LOBYTE(m_colour2) = col2;
              }
            }
            else
            {
              LOBYTE(m_colour2) = col2;
              p_m_colour2 = &v282->m_colour2;
            }
            LOBYTE(m_colour4) = v332;
            v306 = 1;
            LOBYTE(m_colour3) = col3;
LABEL_505:
            v282->m_colour1 = LOBYTE(v331.x);
            *p_m_colour2 = m_colour2;
            v282->m_colour4 = m_colour4;
            v282->m_colour3 = m_colour3;
            CVehicle::SetRemap(v282, -1);
            v283 = 0;
            if ( v306 )
            {
              FxPrtMult_c::FxPrtMult_c(ppResults, 1.0, 0.0, 0.0, 0.6, 0.7, 1.0, 0.4);
              v307 = 10;
              v308 = &CVehicleModelInfo::ms_vehicleColourTable[v282->m_colour1];
              green = v308->_anon_0._anon_0.green;
              blue = (float)v308->_anon_0._anon_0.blue;
              ppResults[0].m_red = (float)v308->_anon_0._anon_0.red / 255.0;
              ppResults[0].m_green = (float)green / 255.0;
              ppResults[0].m_blue = blue / 255.0;
              memset(&CoorsMin, 0, sizeof(CoorsMin));
              do
              {
                v311 = v282->m_pMat;
                p_m_transform = (CSimpleTransform *)&v311->tx;
                if ( !v311 )
                  p_m_transform = &v282->m_transform;
                v313 = *(_QWORD *)&p_m_transform->m_translate.x;
                CoorsMax.z = p_m_transform->m_translate.z;
                *(_QWORD *)&CoorsMax.x = v313;
                CoorsMax.x = *(float *)&v313 + (float)((float)((float)((float)rand() * 4.6566e-10) * 6.0) + -3.0);
                CoorsMax.y = CoorsMax.y + (float)((float)((float)((float)rand() * 4.6566e-10) * 6.0) + -3.0);
                CoorsMin.z = (float)((float)((float)rand() * 4.6566e-10) * 0.05) + 0.0;
                FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &CoorsMax, &CoorsMin, 0.0, ppResults, -1.0, 1.2, 0.6, 0);
                --v307;
              }
              while ( v307 );
              v283 = v306;
            }
            goto LABEL_511;
          case 1u:
            if ( CGarages::NoResprays )
              return;
            IsStaticPlayerCarEntirelyInside = CGarage::IsStaticPlayerCarEntirelyInside(this);
            v233 = FindPlayerVehicle(-1, 0);
            if ( IsStaticPlayerCarEntirelyInside )
            {
              if ( v233->m_nHealth < 250.0
                || CVehicle::IsLawEnforcementVehicle(v233)
                || v233->m_vehicleType == 10
                || (unsigned int)(v233->m_nModelIndex - 407) <= 0x1E
                && ((1 << (v233->m_nModelIndex + 105)) & 0x41000201) != 0 )
              {
                if ( FindPlayerVehicle(-1, 0)->m_vehicleType == 10 )
                {
                  v234 = strcmp("GA_1B", (const char *)CGarages::MessageIDString);
                  v235 = CTimer::m_snTimeInMilliseconds;
                  if ( v234
                    || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                    || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
                  {
                    strcpy((char *)CGarages::MessageIDString, "GA_1B");
                  }
                  else
                  {
                    if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                      goto LABEL_442;
                    v235 = CTimer::m_snTimeInMilliseconds - 500;
                  }
                }
                else
                {
                  v269 = strcmp("GA_1", (const char *)CGarages::MessageIDString);
                  v235 = CTimer::m_snTimeInMilliseconds;
                  if ( v269
                    || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                    || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
                  {
                    strcpy((char *)CGarages::MessageIDString, "GA_1");
                  }
                  else
                  {
                    if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                      goto LABEL_442;
                    v235 = CTimer::m_snTimeInMilliseconds - 500;
                  }
                }
                CGarages::MessageEndTime = v235 + 4000;
                CGarages::MessageStartTime = v235;
                CGarages::MessageNumberInString = -1;
                CGarages::MessageNumberInString2 = -1;
LABEL_442:
                this->State = 4;
                v270 = 15;
LABEL_443:
                CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, v270, 0.0, 1.0);
LABEL_463:
                v285 = FindPlayerWanted(-1);
                *((_BYTE *)v285 + 30) |= 2u;
                CGarages::LastGaragePlayerWasIn = MyIndex;
                goto LABEL_464;
              }
              if ( CWorld::Players[CWorld::PlayerInFocus].Score > 99 || CGarages::RespraysAreFree )
              {
                this->State = 2;
                v328 = CPad::GetPad(0);
                v328->DisablePlayerControls |= 4u;
                FindPlayerVehicle(-1, 0)->nBodyDirtLevel = 0.0;
                goto LABEL_463;
              }
              v326 = strcmp("GA_3", (const char *)CGarages::MessageIDString);
              v327 = CTimer::m_snTimeInMilliseconds;
              if ( v326
                || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
                || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
              {
                strcpy((char *)CGarages::MessageIDString, "GA_3");
              }
              else
              {
                if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime <= 0x1F4 )
                  goto LABEL_560;
                v327 = CTimer::m_snTimeInMilliseconds - 500;
              }
              CGarages::MessageEndTime = v327 + 4000;
              CGarages::MessageStartTime = v327;
              CGarages::MessageNumberInString = -1;
              CGarages::MessageNumberInString2 = -1;
LABEL_560:
              this->State = 4;
              v270 = 14;
              goto LABEL_443;
            }
            if ( v233 )
              v262 = FindPlayerVehicle(-1, 0);
            else
              v262 = FindPlayerPed(-1);
            if ( !CGarage::IsEntityEntirelyOutside(this, v262, 0.0) )
              goto LABEL_463;
            if ( CGarages::LastGaragePlayerWasIn == MyIndex )
            {
              v284 = FindPlayerWanted(-1);
              *((_BYTE *)v284 + 30) &= ~2u;
            }
LABEL_464:
            if ( FindPlayerVehicle(-1, 0) )
            {
              v286 = FindPlayerVehicle(-1, 0);
              v287 = v286->m_pMat;
              p_x = &v287->tx;
              if ( !v287 )
                p_x = &v286->m_transform.m_translate.x;
              v289 = *p_x;
              v290 = FindPlayerVehicle(-1, 0);
              v291 = v290->m_pMat;
              v292 = this->MinX;
              v293 = (CSimpleTransform *)&v291->tx;
              if ( !v291 )
                v293 = &v290->m_transform;
              v294 = v293->m_translate.y;
              if ( v292 <= v289 )
              {
                v296 = this->MaxX;
                if ( v296 >= v289 )
                  v295 = 0.0;
                else
                  v295 = v289 - v296;
              }
              else
              {
                v295 = v289 - v292;
              }
              v297 = this->MinY;
              if ( v297 <= v294 )
              {
                v299 = this->MaxY;
                if ( v299 >= v294 )
                  v298 = 0.0;
                else
                  v298 = v294 - v299;
              }
              else
              {
                v298 = v294 - v297;
              }
              if ( (float)((float)(v295 * v295) + (float)(v298 * v298)) < 64.0 )
                CWorld::CallOffChaseForArea(v292 + -10.0, v297 + -10.0, this->MaxX + 10.0, this->MaxY + 10.0);
            }
            break;
          case 2u:
            if ( FindPlayerVehicle(-1, 0) )
            {
              v236 = FindPlayerVehicle(-1, 0);
              CGarage::ThrowCarsNearDoorOutOfGarage(this, v236);
            }
            if ( CGarage::SlideDoorClosed(this) )
            {
              this->State = 0;
              CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 16, 0.0, 1.0);
              this->TimeOfNextEvent = CTimer::m_snTimeInMilliseconds + 2000;
              StatValue = CStats::GetStatValue(0xB0u);
              CStats::IncrementStat(0xB1u, StatValue);
              CStats::SetStatValue(0xB0u, 0.0);
            }
            if ( FindPlayerVehicle(-1, 0) )
            {
              FindPlayerVehicle(-1, 0)[1].m_VehicleAudioEntity.m_SkidSound.m_pAudioEntity = 0;
              v238 = FindPlayerVehicle(-1, 0);
              v239 = *((_DWORD *)&v238->m_nVehicleFlags + 1) | 0x800000;
LABEL_337:
              *((_DWORD *)&v238->m_nVehicleFlags + 1) = v239;
            }
LABEL_338:
            CWorld::CallOffChaseForArea(this->MinX + -10.0, this->MinY + -10.0, this->MaxX + 10.0, this->MaxY + 10.0);
            return;
          case 3u:
LABEL_160:
            if ( CGarage::SlideDoorOpen(this) )
              this->State = 4;
            if ( this->Openness > 0.5 )
              goto LABEL_163;
            return;
          case 4u:
LABEL_164:
            if ( FindPlayerVehicle(-1, 0) )
              v116 = FindPlayerVehicle(-1, 0);
            else
              v116 = FindPlayerPed(-1);
            if ( CGarage::IsEntityEntirelyOutside(this, v116, 0.0) )
              goto LABEL_129;
            return;
          default:
            return;
        }
        return;
      case 0xBu:
        v60 = this->State;
        if ( v60 == 3 )
          goto LABEL_128;
        if ( v60 != 2 )
        {
          if ( v60 != 1 )
            return;
          BaseZ = this->BaseZ;
          v62 = this->MaxX;
          v63 = this->MinY;
          v64 = this->MaxY;
          CoorsMin.x = this->MinX;
          CoorsMin.y = v63;
          CoorsMin.z = BaseZ;
          CeilingZ = this->CeilingZ;
          CoorsMax.x = v62;
          CoorsMax.y = v64;
          CoorsMax.z = CeilingZ;
          CWorld::FindObjectsIntersectingCube(
            &CoorsMin,
            &CoorsMax,
            (Int16 *)&v331,
            16,
            (CEntity **)ppResults,
            0,
            1,
            1,
            0,
            0);
          if ( SLOWORD(v331.x) >= 1 )
          {
            LOWORD(v66) = 0;
            do
            {
              if ( CGarage::IsEntityTouching3D(this, *((CEntity **)&ppResults[0].m_red + (__int16)v66)) )
                return;
              v66 = (__int16)(v66 + 1);
            }
            while ( v66 < SLOWORD(v331.x) );
          }
          goto LABEL_228;
        }
        if ( CGarage::SlideDoorClosed(this) )
          this->State = 0;
        v144 = this->BaseZ;
        v145 = this->MaxX;
        v146 = this->MinY;
        v147 = this->MaxY;
        CoorsMin.x = this->MinX;
        CoorsMin.y = v146;
        CoorsMin.z = v144;
        v148 = this->CeilingZ;
        CoorsMax.x = v145;
        CoorsMax.y = v147;
        CoorsMax.z = v148;
        CWorld::FindObjectsIntersectingCube(
          &CoorsMin,
          &CoorsMax,
          (Int16 *)&v331,
          16,
          (CEntity **)ppResults,
          0,
          1,
          1,
          0,
          0);
        if ( SLOWORD(v331.x) < 1 )
          return;
        LOWORD(v149) = 0;
        while ( !CGarage::IsEntityTouching3D(this, *((CEntity **)&ppResults[0].m_red + (__int16)v149)) )
        {
          v149 = (__int16)(v149 + 1);
          if ( v149 >= SLOWORD(v331.x) )
            return;
        }
LABEL_414:
        v93 = 3;
        goto LABEL_415;
      case 0xEu:
      case 0x15u:
        switch ( this->State )
        {
          case 0u:
            v30 = FindPlayerVehicle(-1, 0);
            v31 = this->pCarToCollect;
            if ( !v31 || v30 != v31 )
              return;
            v32 = FindPlayerVehicle(-1, 0);
            v33 = v32->m_pMat;
            v34 = &v33->tx;
            if ( !v33 )
              v34 = &v32->m_transform.m_translate.x;
            v35 = *v34;
            v36 = FindPlayerVehicle(-1, 0);
            v37 = v36->m_pMat;
            v38 = this->MinX;
            v39 = (CSimpleTransform *)&v37->tx;
            if ( !v37 )
              v39 = &v36->m_transform;
            v40 = v39->m_translate.y;
            if ( v38 <= v35 && (v38 = this->MaxX, v38 >= v35) )
              v41 = 0.0;
            else
              v41 = v35 - v38;
            v258 = this->MinY;
            if ( v258 <= v40 && (v258 = this->MaxY, v258 >= v40) )
              v259 = 0.0;
            else
              v259 = v40 - v258;
            v242 = (float)(v41 * v41) + (float)(v259 * v259);
            v243 = 289.0;
            goto LABEL_393;
          case 1u:
            FindPlayerCoors((CVector *)ppResults, -1);
            v133 = this->MinX;
            v134 = this->MaxX;
            v135 = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v136 = this->MinX;
            v137 = this->MaxX;
            v138 = CoorsMin.x;
            FindPlayerCoors(&CoorsMax, -1);
            v139 = this->MinY;
            v140 = this->MaxY;
            v141 = CoorsMax.y;
            FindPlayerCoors(&v331, -1);
            if ( (float)((float)((float)(v135 - (float)((float)(v133 + v134) * 0.5))
                               * (float)(v138 - (float)((float)(v136 + v137) * 0.5)))
                       + (float)((float)(v141 - (float)((float)(v139 + v140) * 0.5))
                               * (float)(v331.y - (float)((float)(this->MinY + this->MaxY) * 0.5)))) > 900.0 )
              goto LABEL_422;
            v142 = this->pCarToCollect;
            if ( !v142 )
              goto LABEL_422;
            if ( v142 == FindPlayerVehicle(-1, 0)
              && CGarage::IsStaticPlayerCarEntirelyInside(this)
              && !CGarage::IsAnyCarBlockingDoor(this) )
            {
              goto LABEL_433;
            }
            return;
          case 2u:
            v143 = this->pCarToCollect;
            if ( v143 )
              CGarage::ThrowCarsNearDoorOutOfGarage(this, v143);
            if ( !CGarage::SlideDoorClosed(this) )
              return;
            if ( *(_BYTE *)&this->Flags << 31 )
              goto LABEL_151;
            if ( this->pCarToCollect )
            {
              this->State = 5;
              *(_QWORD *)&this->TimeOfNextEvent = CTimer::m_snTimeInMilliseconds + 2000;
            }
            else
            {
LABEL_386:
              this->State = 0;
            }
LABEL_163:
            v114 = CPad::GetPad(0);
            v114->DisablePlayerControls &= ~4u;
            v115 = FindPlayerWanted(-1);
            *((_BYTE *)v115 + 30) &= ~2u;
            break;
          case 3u:
            goto LABEL_128;
          case 5u:
            if ( Type == 14 && CTimer::m_snTimeInMilliseconds > this->TimeOfNextEvent )
              goto LABEL_414;
            return;
          default:
            return;
        }
        return;
      case 0xFu:
        if ( this->State == 3 )
          goto LABEL_128;
        return;
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Cu:
      case 0x2Du:
        switch ( this->State )
        {
          case 0u:
            FindPlayerCoors((CVector *)ppResults, -1);
            if ( ppResults[0].m_blue >= 950.0 )
              return;
            FindPlayerCoors((CVector *)ppResults, -1);
            v16 = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v17 = this->MinX;
            if ( v17 <= v16 && (v17 = this->MaxX, v17 >= v16) )
              v18 = 0.0;
            else
              v18 = v16 - v17;
            v121 = this->MinY;
            if ( v121 <= CoorsMin.y && (v121 = this->MaxY, v121 >= CoorsMin.y) )
              v122 = 0.0;
            else
              v122 = CoorsMin.y - v121;
            v123 = (float)(v18 * v18) + (float)(v122 * v122);
            if ( v123 >= 12.25
              && (v123 >= 100.0 || !FindPlayerVehicle(-1, 0) || FindPlayerVehicle(-1, 0)->m_vehicleType == 10) )
            {
              return;
            }
            v124 = FindPlayerVehicle(-1, 0);
            v125 = this->Type;
            if ( !v124 )
              goto LABEL_193;
            if ( v125 == 44 )
              goto LABEL_414;
            v126 = 4;
            if ( v125 == 16 )
              v126 = 2;
            if ( CGarages::CountCarsInHideoutGarage(this->Type) >= v126 )
            {
              CGarage::FindDoorsWithGarage(this, (CObject **)ppResults, (CObject **)&CoorsMin);
              v167 = ppResults[0].m_red;
              if ( LODWORD(ppResults[0].m_red) )
              {
                v168 = *(_DWORD *)(LODWORD(ppResults[0].m_red) + 20);
                v169 = LODWORD(ppResults[0].m_red) + 4;
                v170 = (float *)(LODWORD(ppResults[0].m_red) + 4);
                if ( v168 )
                  v170 = (float *)(v168 + 48);
                v171 = *v170;
                v172 = FindPlayerVehicle(-1, 0);
                v173 = v172->m_pMat;
                v174 = *(_DWORD *)(LODWORD(v167) + 20);
                v175 = &v173->tx;
                if ( !v173 )
                  v175 = &v172->m_transform.m_translate.x;
                v176 = (float *)(LODWORD(v167) + 4);
                v177 = *v175;
                if ( v174 )
                  v176 = (float *)(v174 + 48);
                v178 = *v176;
                v179 = FindPlayerVehicle(-1, 0);
                v180 = v179->m_pMat;
                v181 = *(_DWORD *)(LODWORD(v167) + 20);
                v182 = &v180->tx;
                if ( !v180 )
                  v182 = &v179->m_transform.m_translate.x;
                v183 = LODWORD(v167) + 4;
                v184 = *v182;
                if ( v181 )
                  v183 = v181 + 48;
                v185 = *(float *)(v183 + 4);
                v186 = FindPlayerVehicle(-1, 0);
                v187 = v186->m_pMat;
                v188 = *(_DWORD *)(LODWORD(v167) + 20);
                v189 = (CSimpleTransform *)&v187->tx;
                if ( !v187 )
                  v189 = &v186->m_transform;
                v190 = v189->m_translate.y;
                if ( v188 )
                  v169 = v188 + 48;
                v191 = *(float *)(v169 + 4);
                v192 = FindPlayerVehicle(-1, 0);
                v193 = v192->m_pMat;
                v194 = (CSimpleTransform *)&v193->tx;
                if ( !v193 )
                  v194 = &v192->m_transform;
                if ( (float)((float)((float)(v171 - v177) * (float)(v178 - v184))
                           + (float)((float)(v185 - v190) * (float)(v191 - v194->m_translate.y))) < 25.0 )
                  goto LABEL_568;
              }
              v195 = CoorsMin.x;
              if ( LODWORD(CoorsMin.x) )
              {
                v196 = *(_DWORD *)(LODWORD(CoorsMin.x) + 20);
                v197 = LODWORD(CoorsMin.x) + 4;
                v198 = (float *)(LODWORD(CoorsMin.x) + 4);
                if ( v196 )
                  v198 = (float *)(v196 + 48);
                v199 = *v198;
                v200 = FindPlayerVehicle(-1, 0);
                v201 = v200->m_pMat;
                v202 = *(_DWORD *)(LODWORD(v195) + 20);
                v203 = &v201->tx;
                if ( !v201 )
                  v203 = &v200->m_transform.m_translate.x;
                v204 = (float *)(LODWORD(v195) + 4);
                v205 = *v203;
                if ( v202 )
                  v204 = (float *)(v202 + 48);
                v206 = *v204;
                v207 = FindPlayerVehicle(-1, 0);
                v208 = v207->m_pMat;
                v209 = *(_DWORD *)(LODWORD(v195) + 20);
                v210 = &v208->tx;
                if ( !v208 )
                  v210 = &v207->m_transform.m_translate.x;
                v211 = LODWORD(v195) + 4;
                v212 = *v210;
                if ( v209 )
                  v211 = v209 + 48;
                v213 = *(float *)(v211 + 4);
                v214 = FindPlayerVehicle(-1, 0);
                v215 = v214->m_pMat;
                v216 = *(_DWORD *)(LODWORD(v195) + 20);
                v217 = (CSimpleTransform *)&v215->tx;
                if ( !v215 )
                  v217 = &v214->m_transform;
                v218 = v217->m_translate.y;
                if ( v216 )
                  v197 = v216 + 48;
                v219 = *(float *)(v197 + 4);
                v220 = FindPlayerVehicle(-1, 0);
                v221 = v220->m_pMat;
                v222 = (CSimpleTransform *)&v221->tx;
                if ( !v221 )
                  v222 = &v220->m_transform;
                if ( (float)((float)((float)(v199 - v205) * (float)(v206 - v212))
                           + (float)((float)(v213 - v218) * (float)(v219 - v222->m_translate.y))) < 25.0 )
                {
LABEL_568:
                  if ( CTimer::m_snTimeInMilliseconds - CGarages::LastTimeHelpMessage >= 0x4651 )
                  {
                    v223 = FindPlayerVehicle(-1, 0);
                    if ( CVehicle::GetVehicleAppearance(v223) != APR_HELI )
                    {
                      v224 = FindPlayerVehicle(-1, 0);
                      if ( CVehicle::GetVehicleAppearance(v224) != APR_PLANE )
                      {
                        v225 = CText::Get(&TheText, "GA_21");
                        CHud::SetHelpMessage("GA_21", v225, 0, 0, 1, 0);
                        CGarages::LastTimeHelpMessage = CTimer::m_snTimeInMilliseconds;
                      }
                    }
                  }
                }
              }
              return;
            }
LABEL_193:
            v127 = 0;
            switch ( v125 )
            {
              case 17:
                v127 = 1;
                break;
              case 18:
                v127 = 2;
                break;
              case 24:
                v127 = 3;
                break;
              case 25:
                v127 = 4;
                break;
              case 26:
                v127 = 5;
                break;
              case 27:
                v127 = 6;
                break;
              case 28:
                v127 = 7;
                break;
              case 29:
                v127 = 8;
                break;
              case 30:
                v127 = 9;
                break;
              case 31:
                v127 = 10;
                break;
              case 32:
                v127 = 11;
                break;
              case 33:
                v127 = 12;
                break;
              case 34:
                v127 = 13;
                break;
              case 35:
                v127 = 14;
                break;
              case 39:
                v127 = 15;
                break;
              case 40:
                v127 = 16;
                break;
              case 41:
                v127 = 17;
                break;
              case 42:
                v127 = 18;
                break;
              case 44:
                goto LABEL_414;
              case 45:
                v127 = (int)&word_12 + 1;
                break;
              default:
                break;
            }
            if ( !CGarage::RestoreCarsForThisHideOut((CGarage *)v127, CGarages::aCarsInSafeHouse[v127]) )
              return;
            break;
          case 1u:
            FindPlayerCoors((CVector *)ppResults, -1);
            v19 = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v20 = this->MinX;
            if ( v20 <= v19 && (v20 = this->MaxX, v20 >= v19) )
              v21 = 0.0;
            else
              v21 = v19 - v20;
            v94 = this->MinY;
            if ( v94 <= CoorsMin.y && (v94 = this->MaxY, v94 >= CoorsMin.y) )
              v95 = 0.0;
            else
              v95 = CoorsMin.y - v94;
            v96 = (float)(v21 * v21) + (float)(v95 * v95);
            if ( (v96 > 225.0
               || v96 > 16.0 && (!FindPlayerVehicle(-1, 0) || FindPlayerVehicle(-1, 0)->m_vehicleType == 10))
              && !CGarage::IsAnyCarBlockingDoor(this) )
            {
              goto LABEL_228;
            }
            if ( FindPlayerVehicle(-1, 0) )
            {
              v97 = FindPlayerVehicle(-1, 0);
              v98 = CGarage::CountCarsWithCenterPointWithinGarage(this, v97);
              v99 = 4;
              if ( this->Type == 16 )
                v99 = 2;
              if ( v98 >= v99 )
              {
                v100 = FindPlayerVehicle(-1, 0) ? FindPlayerVehicle(-1, 0) : (CVehicle *)FindPlayerPed(-1);
                if ( CGarage::IsEntityEntirelyOutside(this, v100, 0.25) )
                  goto LABEL_228;
              }
            }
            if ( v96 > 4900.0 )
            {
              this->State = 2;
              CGarage::RemoveCarsBlockingDoorNotInside(this);
            }
            return;
          case 2u:
            CGarage::SlideDoorClosed(this);
            if ( FindPlayerVehicle(-1, 0) )
              v22 = FindPlayerVehicle(-1, 0);
            else
              v22 = FindPlayerPed(-1);
            if ( !CGarage::IsEntityEntirelyOutside(this, v22, 0.0) )
              goto LABEL_414;
            if ( this->Openness == 0.0 )
            {
              v45 = this->Type;
              v46 = 0;
              this->State = 0;
              switch ( v45 )
              {
                case 17:
                  v46 = 1;
                  goto LABEL_385;
                case 18:
                  v46 = 2;
                  goto LABEL_385;
                case 24:
                  v46 = 3;
                  goto LABEL_385;
                case 25:
                  v46 = 4;
                  goto LABEL_385;
                case 26:
                  v46 = 5;
                  goto LABEL_385;
                case 27:
                  v46 = 6;
                  goto LABEL_385;
                case 28:
                  v46 = 7;
                  goto LABEL_385;
                case 29:
                  v46 = 8;
                  goto LABEL_385;
                case 30:
                  v46 = 9;
                  goto LABEL_385;
                case 31:
                  v46 = 10;
                  goto LABEL_385;
                case 32:
                  v46 = 11;
                  goto LABEL_385;
                case 33:
                  v46 = 12;
                  goto LABEL_385;
                case 34:
                  v46 = 13;
                  goto LABEL_385;
                case 35:
                  v46 = 14;
                  goto LABEL_385;
                case 39:
                  v46 = 15;
                  goto LABEL_385;
                case 40:
                  v46 = 16;
                  goto LABEL_385;
                case 41:
                  v46 = 17;
                  goto LABEL_385;
                case 42:
                  v46 = 18;
                  goto LABEL_385;
                case 44:
                  return;
                case 45:
                  v46 = 19;
                  goto LABEL_385;
                default:
LABEL_385:
                  CGarage::StoreAndRemoveCarsForThisHideOut(this, CGarages::aCarsInSafeHouse[v46], 4);
                  break;
              }
            }
            return;
          case 3u:
            goto LABEL_128;
          default:
            return;
        }
        goto LABEL_414;
      case 0x13u:
        v67 = this->State;
        if ( v67 == 3 )
          goto LABEL_128;
        if ( v67 != 2 )
          return;
        goto LABEL_150;
      case 0x14u:
        switch ( this->State )
        {
          case 0u:
LABEL_105:
            v68 = FindPlayerVehicle(-1, 0);
            v69 = this->pCarToCollect;
            if ( v69 && v68 == v69 )
              goto LABEL_107;
            break;
          case 1u:
            FindPlayerCoors((CVector *)ppResults, -1);
            v153 = this->MinX;
            v154 = this->MaxX;
            v155 = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v156 = this->MinX;
            v157 = this->MaxX;
            v158 = CoorsMin.x;
            FindPlayerCoors(&CoorsMax, -1);
            v159 = this->MinY;
            v160 = this->MaxY;
            v161 = CoorsMax.y;
            FindPlayerCoors(&v331, -1);
            if ( (float)((float)((float)(v155 - (float)((float)(v153 + v154) * 0.5))
                               * (float)(v158 - (float)((float)(v156 + v157) * 0.5)))
                       + (float)((float)(v161 - (float)((float)(v159 + v160) * 0.5))
                               * (float)(v331.y - (float)((float)(this->MinY + this->MaxY) * 0.5)))) > 900.0 )
            {
              v162 = this->pCarToCollect;
              if ( v162 )
              {
                if ( CGarage::IsEntityEntirelyOutside(this, v162, 0.0) )
                  goto LABEL_422;
              }
            }
            break;
          case 2u:
            v101 = this->pCarToCollect;
            if ( !v101 )
              goto LABEL_150;
            goto LABEL_149;
          case 3u:
            goto LABEL_128;
          default:
            return;
        }
        return;
      case 0x17u:
        v80 = this->State;
        switch ( v80 )
        {
          case 3:
            goto LABEL_128;
          case 2:
            if ( CGarage::SlideDoorClosed(this) )
            {
              this->State = 0;
              v150 = CPad::GetPad(0);
              v150->DisablePlayerControls &= ~4u;
            }
            break;
          case 1:
            v81 = this->pCarToCollect;
            if ( v81 )
            {
              if ( CGarage::IsEntityEntirelyInside3D(this, v81, 0.0) && !CGarage::IsAnyCarBlockingDoor(this) )
              {
                v82 = FindPlayerVehicle(-1, 0) ? FindPlayerVehicle(-1, 0) : (CVehicle *)FindPlayerPed(-1);
                if ( CGarage::IsEntityEntirelyOutside(this, v82, 0.0) )
                {
                  v263 = CPad::GetPad(0);
                  v263->DisablePlayerControls |= 4u;
LABEL_434:
                  v268 = this->Flags;
                  this->State = 2;
                  this->Flags = (CGarageFlags)(*(_BYTE *)&v268 & 0xFE);
                }
              }
            }
            break;
        }
        return;
      case 0x21u:
      case 0x22u:
      case 0x23u:
        if ( (unsigned int)this->State - 1 >= 2 )
        {
          if ( !this->State )
          {
            FindPlayerCoors((CVector *)ppResults, -1);
            v42 = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v43 = this->MinX;
            if ( v43 <= v42 && (v43 = this->MaxX, v43 >= v42) )
              v44 = 0.0;
            else
              v44 = v42 - v43;
            v163 = this->MinY;
            if ( v163 <= CoorsMin.y && (v163 = this->MaxY, v163 >= CoorsMin.y) )
              v164 = 0.0;
            else
              v164 = CoorsMin.y - v163;
            FindPlayerCoors((CVector *)ppResults, -1);
            if ( ppResults[0].m_blue < (float)(this->CeilingZ + -2.0) )
            {
              FindPlayerCoors(&CoorsMin, -1);
              if ( (float)((float)(v44 * v44) + (float)(v164 * v164)) < 3600.0 && CoorsMin.z > this->BaseZ )
              {
                v165 = this->Type - 17;
                v166 = v165 > 0x1Cu ? 0 : dword_60FBD0[(char)v165];
                CGarage::NeatlyLineUpStoredCars(this, CGarages::aCarsInSafeHouse[v166]);
                v230 = this->Type - 17;
                v231 = v230 > 0x1Cu ? 0 : dword_60FBD0[(char)v230];
                if ( CGarage::RestoreCarsForThisImpoundingGarage(this, CGarages::aCarsInSafeHouse[v231]) )
                  goto LABEL_129;
              }
            }
          }
        }
        else
        {
          FindPlayerCoors((CVector *)ppResults, -1);
          v24 = ppResults[0].m_red;
          FindPlayerCoors(&CoorsMin, -1);
          v25 = this->MinX;
          if ( v25 <= v24 && (v25 = this->MaxX, v25 >= v24) )
            v26 = 0.0;
          else
            v26 = v24 - v25;
          v128 = this->MinY;
          if ( v128 <= CoorsMin.y && (v128 = this->MaxY, v128 >= CoorsMin.y) )
            v129 = 0.0;
          else
            v129 = CoorsMin.y - v128;
          FindPlayerCoors((CVector *)ppResults, -1);
          if ( ppResults[0].m_blue >= (float)(this->CeilingZ + -2.0)
            || (FindPlayerCoors(&CoorsMin, -1), (float)((float)(v26 * v26) + (float)(v129 * v129)) > 4225.0)
            || CoorsMin.z <= this->BaseZ
            || this->State == 2 )
          {
            v130 = this->Type;
            v131 = 0;
            this->State = 0;
            v132 = v130 - 17;
            if ( v132 <= 0x1Cu )
              v131 = dword_60FBD0[(char)v132];
            CGarage::StoreAndRemoveCarsForThisImpoundingGarage(this, CGarages::aCarsInSafeHouse[v131], 3);
          }
        }
        return;
      case 0x24u:
      case 0x25u:
      case 0x26u:
        switch ( this->State )
        {
          case 0u:
            v27 = FindPlayerVehicle(-1, 0);
            if ( !v27 )
              return;
            v28 = this->Type;
            v29 = *((unsigned __int8 *)&CModelInfo::ms_modelInfoPtrs[v27->m_nModelIndex][1].m_flags + 2);
            if ( v28 == 38 )
            {
              if ( (mod_HandlingManager.m_aHandlingData[v29].hFlags & 0x6000000) != 0 )
                return;
            }
            else if ( v28 == 37 )
            {
              if ( (mod_HandlingManager.m_aHandlingData[v29].hFlags & 0x4000000) == 0 )
                return;
            }
            else if ( v28 != 36 || (mod_HandlingManager.m_aHandlingData[v29].hFlags & 0x2000000) == 0 )
            {
              return;
            }
LABEL_107:
            v70 = FindPlayerVehicle(-1, 0);
            v71 = v70->m_pMat;
            v72 = &v71->tx;
            if ( !v71 )
              v72 = &v70->m_transform.m_translate.x;
            v73 = *v72;
            v74 = FindPlayerVehicle(-1, 0);
            v75 = v74->m_pMat;
            v76 = this->MinX;
            v77 = (CSimpleTransform *)&v75->tx;
            if ( !v75 )
              v77 = &v74->m_transform;
            v78 = v77->m_translate.y;
            if ( v76 <= v73 && (v76 = this->MaxX, v76 >= v73) )
              v79 = 0.0;
            else
              v79 = v73 - v76;
            v240 = this->MinY;
            if ( v240 <= v78 && (v240 = this->MaxY, v240 >= v78) )
              v241 = 0.0;
            else
              v241 = v78 - v240;
            v242 = (float)(v79 * v79) + (float)(v241 * v241);
            v243 = 64.0;
LABEL_393:
            if ( v242 < v243 )
              goto LABEL_414;
            return;
          case 1u:
            FindPlayerCoors((CVector *)ppResults, -1);
            v102 = this->MinX;
            v103 = this->MaxX;
            v104 = ppResults[0].m_red;
            FindPlayerCoors(&CoorsMin, -1);
            v105 = this->MinX;
            v106 = this->MaxX;
            v107 = CoorsMin.x;
            FindPlayerCoors(&CoorsMax, -1);
            v108 = this->MinY;
            v109 = this->MaxY;
            v110 = CoorsMax.y;
            FindPlayerCoors(&v331, -1);
            if ( (float)((float)((float)(v104 - (float)((float)(v102 + v103) * 0.5))
                               * (float)(v107 - (float)((float)(v105 + v106) * 0.5)))
                       + (float)((float)(v110 - (float)((float)(v108 + v109) * 0.5))
                               * (float)(v331.y - (float)((float)(this->MinY + this->MaxY) * 0.5)))) <= 900.0
              || (unsigned __int8)CTimer::m_FrameCounter << 27 )
            {
              return;
            }
            v111 = FindPlayerVehicle(-1, 0);
            if ( !v111 )
              goto LABEL_421;
            v112 = this->Type;
            v113 = *((unsigned __int8 *)&CModelInfo::ms_modelInfoPtrs[v111->m_nModelIndex][1].m_flags + 2);
            if ( v112 == 38 )
            {
              if ( (mod_HandlingManager.m_aHandlingData[v113].hFlags & 0x6000000) != 0 )
                goto LABEL_421;
            }
            else if ( v112 == 37 )
            {
              if ( (mod_HandlingManager.m_aHandlingData[v113].hFlags & 0x4000000) == 0 )
                goto LABEL_421;
            }
            else if ( v112 != 36 || (mod_HandlingManager.m_aHandlingData[v113].hFlags & 0x2000000) == 0 )
            {
              goto LABEL_421;
            }
            v260 = FindPlayerVehicle(-1, 0);
            if ( CGarage::IsEntityTouching3D(this, v260) )
              return;
LABEL_421:
            if ( !CGarage::IsAnyOtherCarTouchingGarage(this, 0) )
            {
LABEL_422:
              v261 = this->Flags;
              this->State = 2;
              this->Flags = (CGarageFlags)(*(_BYTE *)&v261 | 1);
            }
            break;
          case 2u:
            goto LABEL_147;
          case 3u:
            goto LABEL_128;
          default:
            return;
        }
        return;
      case 0x2Bu:
        v83 = this->State;
        if ( v83 == 3 )
        {
LABEL_128:
          if ( !CGarage::SlideDoorOpen(this) )
            return;
LABEL_129:
          v93 = 1;
          goto LABEL_415;
        }
        if ( v83 != 2 )
        {
          if ( v83 != 1 )
            return;
          FindPlayerCoors((CVector *)ppResults, -1);
          v84 = this->MinX;
          v85 = this->MaxX;
          v86 = ppResults[0].m_red;
          FindPlayerCoors(&CoorsMin, -1);
          v87 = this->MinX;
          v88 = this->MaxX;
          v89 = CoorsMin.x;
          FindPlayerCoors(&CoorsMax, -1);
          v90 = this->MinY;
          v91 = this->MaxY;
          v92 = CoorsMax.y;
          FindPlayerCoors(&v331, -1);
          if ( (float)((float)((float)(v86 - (float)((float)(v84 + v85) * 0.5))
                             * (float)(v89 - (float)((float)(v87 + v88) * 0.5)))
                     + (float)((float)(v92 - (float)((float)(v90 + v91) * 0.5))
                             * (float)(v331.y - (float)((float)(this->MinY + this->MaxY) * 0.5)))) <= 900.0
            || CGarage::IsAnyOtherCarTouchingGarage(this, 0) )
          {
            return;
          }
LABEL_228:
          v93 = 2;
LABEL_415:
          this->State = v93;
          return;
        }
LABEL_147:
        if ( FindPlayerVehicle(-1, 0) )
        {
          v101 = (CAutomobile *)FindPlayerVehicle(-1, 0);
LABEL_149:
          CGarage::ThrowCarsNearDoorOutOfGarage(this, v101);
        }
LABEL_150:
        if ( CGarage::SlideDoorClosed(this) )
        {
LABEL_151:
          v93 = 0;
          goto LABEL_415;
        }
        break;
      default:
        return;
    }
  }
}
// 310602: variable 'v4' is possibly undefined
// 310602: variable 'v3' is possibly undefined
// 310D06: variable 'v2' is possibly undefined
// 12: using guessed type __int16 word_12;
// FC: using guessed type int elf_hash_bucket[16411];
// 60FBD0: using guessed type _DWORD dword_60FBD0[29];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (003111B4) --------------------------------------------------------
void __fastcall CGarage::TidyUpGarage(CGarage *this)
{
  CVehiclePool *v2; // r9
  int32 m_nSize; // r0
  int v4; // r4
  int v5; // r6
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r10
  uint8 *v7; // r5
  int v8; // r0
  bool v9; // zf
  int v10; // r0
  float *v11; // r1
  float v12; // s0
  float v13; // s0
  float v14; // s2
  float v15; // s4
  float v16; // s0

  v2 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  v4 = m_nSize - 1;
  if ( m_nSize != 1 )
  {
    v5 = 2604 * m_nSize - 2604;
    do
    {
      if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v7 = &(*v2->m_aStorage)[v5];
        if ( v7 )
        {
          v8 = *((_DWORD *)v7 + 360);
          v9 = v8 == 9;
          if ( v8 != 9 )
            v9 = v8 == 0;
          if ( v9 )
          {
            v10 = *((_DWORD *)v7 + 5);
            v11 = (float *)(v10 + 48);
            if ( !v10 )
              v11 = (float *)(v7 + 4);
            v12 = v11[2];
            if ( this->BaseZ <= v12 && this->CeilingZ >= v12 )
            {
              v13 = *v11 - this->BaseX;
              v14 = v11[1] - this->BaseY;
              v15 = (float)(v13 * this->Delta1X) + (float)(v14 * this->Delta1Y);
              if ( v15 >= 0.0 && v15 <= this->Delta1Length )
              {
                v16 = (float)(v13 * this->Delta2X) + (float)(v14 * this->Delta2Y);
                if ( v16 >= 0.0 && v16 <= this->Delta2Length && ((v7[58] & 0xF8) == 40 || *(float *)(v10 + 40) < 0.5) )
                {
                  CWorld::Remove((CEntity *)&(*v2->m_aStorage)[v5]);
                  (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[v5] + 4))(v7);
                }
              }
            }
          }
        }
      }
      v5 -= 2604;
      --v4;
    }
    while ( v4 );
  }
}

//----- (003112E0) --------------------------------------------------------
void __fastcall CGarage::TidyUpGarageClose(CGarage *this)
{
  CVehiclePool *v1; // r6
  int32 m_nSize; // r0
  int v3; // r5
  int v4; // r11
  int v5; // r0
  bool v6; // zf
  CCollisionData *m_pColData; // r4
  int v8; // r8
  CColSphere *m_pSphereArray; // r0
  int v10; // r10
  int v11; // r9
  float m_fRadius; // s0
  float v13; // s2
  float v14; // s4
  float v15; // s8
  float v16; // s2
  CVector v18; // [sp+10h] [bp-28h] BYREF

  v1 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  v3 = m_nSize - 1;
  if ( m_nSize != 1 )
  {
    do
    {
      if ( (v1->m_aFlags[v3] & 0x80u) == 0 )
      {
        v4 = (int)v1->m_aStorage[v3];
        if ( v4 )
        {
          v5 = *(_DWORD *)(v4 + 1440);
          v6 = v5 == 9;
          if ( v5 != 9 )
            v6 = v5 == 0;
          if ( v6
            && (*(_BYTE *)(v4 + 58) & 0xF8) == 40
            && CGarage::IsEntityTouching3D(this, (CEntity *)v1->m_aStorage[v3]) )
          {
            if ( !this->State )
              goto LABEL_24;
            m_pColData = CEntity::GetColModel((CEntity *)v4)->m_pColData;
            if ( m_pColData->m_nNoOfSpheres >= 1 )
            {
              v8 = 0;
              m_pSphereArray = m_pColData->m_pSphereArray;
              v10 = 0;
              v11 = 0;
              do
              {
                operator*(&v18, *(const CMatrix **)(v4 + 20), &m_pSphereArray[v8].m_vecCentre);
                m_pSphereArray = m_pColData->m_pSphereArray;
                m_fRadius = m_pSphereArray[v8].m_fRadius;
                if ( (float)(this->BaseZ - m_fRadius) <= v18.z
                  && (float)(m_fRadius + this->CeilingZ) >= v18.z
                  && (v13 = v18.x - this->BaseX,
                      v14 = v18.y - this->BaseY,
                      v15 = (float)(v13 * this->Delta1X) + (float)(v14 * this->Delta1Y),
                      v15 >= (float)-m_fRadius)
                  && v15 <= (float)(m_fRadius + this->Delta1Length)
                  && (v16 = (float)(v13 * this->Delta2X) + (float)(v14 * this->Delta2Y), v16 >= (float)-m_fRadius) )
                {
                  if ( v16 > (float)(m_fRadius + this->Delta2Length) )
                    v11 = 1;
                }
                else
                {
                  v11 = 1;
                }
                ++v10;
                ++v8;
              }
              while ( v10 < m_pColData->m_nNoOfSpheres );
              if ( v11 << 31 )
              {
LABEL_24:
                CWorld::Remove((CEntity *)v4);
                (*(void (__fastcall **)(int))(*(_DWORD *)v4 + 4))(v4);
              }
            }
          }
        }
      }
      --v3;
    }
    while ( v3 );
  }
}

//----- (00311480) --------------------------------------------------------
UInt32 __fastcall CGarages::AddOne(
        float BaseX,
        float BaseY,
        float BaseZ,
        float Point1X,
        float Point1Y,
        float Point2X,
        float Point2Y,
        float CeilingZ,
        UInt8 Type,
        UInt32 ModelIndexToBeCollected,
        unsigned __int8 *pName,
        UInt32 FlagsFromMax)
{
  float32x2_t v12; // d5
  float32x2_t v13; // d6
  float32x2_t v14; // d7
  float32x2_t v15; // d8
  float32x2_t v16; // d9
  float32x2_t v17; // d10
  float v18; // s4
  float32x2_t v19; // d18
  CGarage *v20; // r3
  float32x2_t v21; // d17
  float32x2_t v22; // d16
  float32x2_t v23; // d19
  float v24; // s0
  float v25; // s2
  UInt32 result; // r0
  CGarage *v27; // r1
  CGarageFlags Flags; // r2
  char v29; // r6
  char v30; // r2
  CGarageFlags v31; // r6

  v13.n64_f32[0] = Point1Y;
  v14.n64_f32[0] = BaseY;
  v15.n64_f32[0] = Point2Y;
  v12.n64_f32[0] = BaseX;
  v17.n64_f32[0] = Point1X;
  v16.n64_f32[0] = Point2X;
  v18 = Point1X - BaseX;
  v19.n64_u64[0] = vmax_f32(vmax_f32(v12, v17), v16).n64_u64[0];
  v20 = &CGarages::aGarages[CGarages::NumGarages];
  v21.n64_u64[0] = vmin_f32(vmin_f32(v14, v13), v15).n64_u64[0];
  v22.n64_u64[0] = vmax_f32(vmax_f32(v14, v13), v15).n64_u64[0];
  v23.n64_u64[0] = vmin_f32(vmin_f32(v12, v17), v16).n64_u64[0];
  v20->BaseX = BaseX;
  v24 = sqrtf((float)(v18 * v18) + (float)((float)(Point1Y - BaseY) * (float)(Point1Y - BaseY)));
  v25 = sqrtf(
          (float)((float)(Point2X - BaseX) * (float)(Point2X - BaseX))
        + (float)((float)(Point2Y - BaseY) * (float)(Point2Y - BaseY)));
  v14.n64_f32[0] = (float)(Point1Y + Point2Y) - BaseY;
  v12.n64_f32[0] = (float)(v17.n64_f32[0] + Point2X) - BaseX;
  LODWORD(v20->MaxX) = vmax_f32(v19, v12).n64_u32[0];
  LODWORD(v20->MinY) = vmin_f32(v21, v14).n64_u32[0];
  LODWORD(v20->MaxY) = vmax_f32(v22, v14).n64_u32[0];
  v20->BaseY = BaseY;
  v20->BaseZ = BaseZ;
  v20->Type = Type;
  v20->OriginalType = Type;
  v20->Delta1X = v18 / v24;
  v20->Delta1Y = (float)(Point1Y - BaseY) / v24;
  v20->Delta2X = (float)(Point2X - BaseX) / v25;
  v20->Delta2Y = (float)(Point2Y - BaseY) / v25;
  v20->CeilingZ = CeilingZ;
  v20->Delta1Length = v24;
  v20->Delta2Length = v25;
  LODWORD(v20->MinX) = vmin_f32(v23, v12).n64_u32[0];
  strncpy((char *)v20->Name, (const char *)pName, 7u);
  result = CGarages::NumGarages;
  v27 = &CGarages::aGarages[CGarages::NumGarages];
  Flags = v27->Flags;
  v29 = *(_BYTE *)&Flags & 0xF7;
  if ( (FlagsFromMax & 1) != 0 )
    v29 = *(_BYTE *)&Flags | 8;
  v30 = v29 & 0xEF;
  if ( (FlagsFromMax & 2) != 0 )
    v30 = v29 | 0x10;
  v31 = (CGarageFlags)(v30 & 0xDF);
  if ( (FlagsFromMax & 4) != 0 )
    v31 = (CGarageFlags)(v30 | 0x20);
  v27->Flags = v31;
  CGarages::NumGarages = result + 1;
  return (__int16)result;
}
// 3114CC: variable 'v12' is possibly undefined
// 3114CC: variable 'v17' is possibly undefined
// 3114F6: variable 'v16' is possibly undefined
// 3114C4: variable 'v14' is possibly undefined
// 3114C4: variable 'v13' is possibly undefined
// 3114FE: variable 'v15' is possibly undefined

//----- (003115E8) --------------------------------------------------------
bool __fastcall CGarage::SlideDoorOpen(CGarage *this)
{
  int Type; // r0
  float v3; // s0
  int *v4; // r2
  float v5; // s0
  CMatrix *v6; // r1
  CSimpleTransform *p_m_transform; // r2
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CObject *ppDoor2; // [sp+8h] [bp-10h] BYREF
  CObject *ppDoor1[3]; // [sp+Ch] [bp-Ch] BYREF

  Type = this->Type;
  if ( Type == 44 )
  {
    v3 = CTimer::ms_fTimeStep * 0.0011;
  }
  else
  {
    v4 = dword_3116B8;
    if ( Type == 45 )
      v4 = &dword_3116B8[1];
    v3 = *(float *)v4 * CTimer::ms_fTimeStep;
  }
  v5 = v3 + this->Openness;
  this->Openness = v5;
  if ( v5 >= 1.0 )
  {
    this->Openness = 1.0;
    ppDoor2 = 0;
    ppDoor1[0] = 0;
    CGarage::FindDoorsWithGarage(this, ppDoor1, &ppDoor2);
    if ( ppDoor1[0] )
    {
      m_pMat = ppDoor1[0]->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &ppDoor1[0]->m_transform;
      CAEDoorAudioEntity::AddAudioEvent(&this->m_DoorAudioEntity, 160, &p_tx->m_translate, 0.0, 1.0);
    }
    return 1;
  }
  else
  {
    ppDoor2 = 0;
    ppDoor1[0] = 0;
    CGarage::FindDoorsWithGarage(this, ppDoor1, &ppDoor2);
    if ( ppDoor1[0] )
    {
      v6 = ppDoor1[0]->m_pMat;
      p_m_transform = (CSimpleTransform *)&v6->tx;
      if ( !v6 )
        p_m_transform = &ppDoor1[0]->m_transform;
      CAEDoorAudioEntity::AddAudioEvent(&this->m_DoorAudioEntity, 159, &p_m_transform->m_translate, 0.0, 1.0);
    }
    return 0;
  }
}
// 3116B8: using guessed type int dword_3116B8[2];

//----- (003116C8) --------------------------------------------------------
void __fastcall CGarage::FindDoorsWithGarage(CGarage *this, CObject **ppDoor1, CObject **ppDoor2)
{
  CObjectPool *v3; // r12
  int32 m_nSize; // r3
  float v5; // s2
  float v6; // s0
  float v7; // s12
  int v8; // r10
  float v9; // s4
  float v10; // s6
  float v11; // s0
  float v12; // s2
  int v13; // r0
  int i; // r5
  uint8 *v15; // r4
  int v16; // r0
  float *v17; // r6
  float v18; // s8
  CObject **v19; // r5

  *ppDoor2 = 0;
  *ppDoor1 = 0;
  v3 = CPools::ms_pObjectPool;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  if ( m_nSize )
  {
    v5 = this->Delta1Length * 0.5;
    v6 = this->Delta2Length * 0.5;
    v7 = this->Delta2X * v6;
    v8 = (char)(19 * ((unsigned int)((char *)this - (char *)CGarages::aGarages) >> 3));
    v9 = 100000.0;
    v10 = 100000.0;
    v11 = (float)(this->BaseY + (float)(this->Delta1Y * v5)) + (float)(this->Delta2Y * v6);
    v12 = (float)(this->BaseX + (float)(this->Delta1X * v5)) + v7;
    do
    {
      v13 = 420 * m_nSize--;
      for ( i = v13 - 89; ; i -= 420 )
      {
        if ( (v3->m_aFlags[m_nSize] & 0x80u) == 0 )
        {
          v15 = &(*v3->m_aStorage)[i];
          if ( v15 != (_BYTE *)&elf_hash_bucket[19] + 3 && v8 == (char)(*v3->m_aStorage)[i] )
          {
            v16 = *(_DWORD *)(v15 - 311);
            v17 = (float *)(v16 + 48);
            if ( !v16 )
              v17 = (float *)(v15 - 327);
            v18 = sqrtf(
                    (float)((float)(v12 - *v17) * (float)(v12 - *v17))
                  + (float)((float)(v11 - v17[1]) * (float)(v11 - v17[1])));
            if ( !*ppDoor1 )
              goto LABEL_16;
            if ( v18 < v9 )
            {
              v10 = v9;
              *ppDoor2 = *ppDoor1;
LABEL_16:
              v19 = ppDoor1;
              v9 = v18;
              goto LABEL_18;
            }
            if ( v18 < v10 || !*ppDoor2 )
              break;
          }
        }
        if ( --m_nSize == -1 )
          return;
      }
      v10 = v18;
      v19 = ppDoor2;
LABEL_18:
      *v19 = (CObject *)(v15 - 331);
    }
    while ( m_nSize );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00311814) --------------------------------------------------------
bool __fastcall CGarage::SlideDoorClosed(CGarage *this)
{
  int Type; // r0
  float v3; // s0
  int *v4; // r2
  float v5; // s0
  CMatrix *v6; // r1
  CSimpleTransform *p_m_transform; // r2
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CObject *ppDoor2; // [sp+8h] [bp-10h] BYREF
  CObject *ppDoor1[3]; // [sp+Ch] [bp-Ch] BYREF

  Type = this->Type;
  if ( Type == 44 )
  {
    v3 = CTimer::ms_fTimeStep * 0.0013;
  }
  else
  {
    v4 = dword_3118DC;
    if ( Type == 45 )
      v4 = &dword_3118DC[1];
    v3 = *(float *)v4 * CTimer::ms_fTimeStep;
  }
  v5 = this->Openness - v3;
  this->Openness = v5;
  if ( v5 <= 0.0 )
  {
    this->Openness = 0.0;
    ppDoor2 = 0;
    ppDoor1[0] = 0;
    CGarage::FindDoorsWithGarage(this, ppDoor1, &ppDoor2);
    if ( ppDoor1[0] )
    {
      m_pMat = ppDoor1[0]->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &ppDoor1[0]->m_transform;
      CAEDoorAudioEntity::AddAudioEvent(&this->m_DoorAudioEntity, 162, &p_tx->m_translate, 0.0, 1.0);
    }
    return 1;
  }
  else
  {
    ppDoor2 = 0;
    ppDoor1[0] = 0;
    CGarage::FindDoorsWithGarage(this, ppDoor1, &ppDoor2);
    if ( ppDoor1[0] )
    {
      v6 = ppDoor1[0]->m_pMat;
      p_m_transform = (CSimpleTransform *)&v6->tx;
      if ( !v6 )
        p_m_transform = &ppDoor1[0]->m_transform;
      CAEDoorAudioEntity::AddAudioEvent(&this->m_DoorAudioEntity, 161, &p_m_transform->m_translate, 0.0, 1.0);
    }
    return 0;
  }
}
// 3118DC: using guessed type int dword_3118DC[2];

//----- (003118EC) --------------------------------------------------------
Int16 __fastcall CGarages::FindGarageIndex(unsigned __int8 *pName)
{
  Int16 v2; // r8
  unsigned int v3; // r6
  int v4; // r0
  Int16 v5; // r4

  v2 = -1;
  v3 = CGarages::NumGarages;
  if ( CGarages::NumGarages )
  {
    v4 = 0;
    v5 = 0;
    while ( strcasecmp((const char *)pName, (const char *)CGarages::aGarages[v4].Name) )
    {
      v4 = ++v5;
      if ( v3 <= v5 )
        return v2;
    }
    return v5;
  }
  return v2;
}

//----- (00311940) --------------------------------------------------------
void __fastcall CGarages::ChangeGarageType(Int16 NumGarage, UInt8 NewType, UInt32 ModelIndexToBeCollected)
{
  CGarage *v3; // r1
  UInt8 *p_State; // r1
  int State; // t1
  CGarage *v6; // r0

  CGarages::aGarages[NumGarage].Type = NewType;
  if ( (unsigned int)(NewType - 2) >= 4 )
  {
    if ( NewType != 43 )
    {
      v6 = &CGarages::aGarages[NumGarage];
      v6->Openness = 0.0;
      v6->State = 0;
    }
  }
  else
  {
    v3 = &CGarages::aGarages[NumGarage];
    State = v3->State;
    p_State = &v3->State;
    if ( !State )
    {
      *p_State = 1;
      CGarages::aGarages[NumGarage].Openness = 1.0;
    }
  }
}

//----- (003119B0) --------------------------------------------------------
bool __fastcall CGarage::IsEntityEntirelyInside3D(CGarage *this, CEntity *pEntity, float Margin)
{
  CMatrix *m_pMat; // r1
  float v7; // s2
  CSimpleTransform *p_m_transform; // r0
  float y; // s0
  float z; // s0
  bool result; // r0
  CCollisionData *m_pColData; // r9
  int v13; // r10
  CMatrix *v14; // r1
  float v15; // s0
  float v16; // s4
  float v17; // s2
  float v18; // s2
  CVector v19; // [sp+4h] [bp-34h] BYREF

  m_pMat = pEntity->m_pMat;
  v7 = this->MinX - Margin;
  p_m_transform = &pEntity->m_transform;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  if ( p_m_transform->m_translate.x >= v7 && p_m_transform->m_translate.x <= (float)(this->MaxX + Margin) )
  {
    y = p_m_transform->m_translate.y;
    if ( y >= (float)(this->MinY - Margin) && y <= (float)(this->MaxY + Margin) )
    {
      z = p_m_transform->m_translate.z;
      if ( z >= (float)(this->BaseZ - Margin) && z <= (float)(this->CeilingZ + Margin) )
      {
        m_pColData = CEntity::GetColModel(pEntity)->m_pColData;
        if ( !m_pColData || m_pColData->m_nNoOfSpheres < 1 )
          return 1;
        v13 = 0;
        while ( 1 )
        {
          v14 = pEntity->m_pMat;
          if ( !v14 )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            v14 = pEntity->m_pMat;
          }
          operator*(&v19, v14, &m_pColData->m_pSphereArray[v13].m_vecCentre);
          v15 = Margin - m_pColData->m_pSphereArray[v13].m_fRadius;
          if ( (float)(this->BaseZ - v15) > v19.z )
            break;
          if ( (float)(v15 + this->CeilingZ) < v19.z )
            break;
          v16 = v19.y - this->BaseY;
          v17 = v19.x - this->BaseX;
          if ( (float)((float)(v17 * this->Delta1X) + (float)(v16 * this->Delta1Y)) > (float)(v15 + this->Delta1Length) )
            break;
          v18 = (float)(v17 * this->Delta2X) + (float)(v16 * this->Delta2Y);
          if ( v18 < (float)-v15 || v18 > (float)(v15 + this->Delta2Length) )
            break;
          v13 = (__int16)(v13 + 1);
          result = 1;
          if ( m_pColData->m_nNoOfSpheres <= v13 )
            return result;
        }
      }
    }
  }
  return 0;
}

//----- (00311B80) --------------------------------------------------------
bool __fastcall CGarage::IsEntityEntirelyOutside(CGarage *this, CEntity *pEntity, float Margin)
{
  CMatrix *m_pMat; // r1
  float v7; // s2
  CSimpleTransform *p_m_transform; // r0
  float y; // s0
  CCollisionData *m_pColData; // r6
  int v12; // r4
  CMatrix *v13; // r1
  float v14; // s0
  float v15; // s2
  float v16; // s4
  float v17; // s8
  float v18; // s2
  CVector v19; // [sp+4h] [bp-34h] BYREF

  m_pMat = pEntity->m_pMat;
  v7 = this->MinX - Margin;
  p_m_transform = &pEntity->m_transform;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  if ( p_m_transform->m_translate.x > v7 && p_m_transform->m_translate.x < (float)(this->MaxX + Margin) )
  {
    y = p_m_transform->m_translate.y;
    if ( y > (float)(this->MinY - Margin) && y < (float)(this->MaxY + Margin) )
      return 0;
  }
  m_pColData = CEntity::GetColModel(pEntity)->m_pColData;
  if ( m_pColData && m_pColData->m_nNoOfSpheres >= 1 )
  {
    v12 = 0;
    while ( 1 )
    {
      v13 = pEntity->m_pMat;
      if ( !v13 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v13 = pEntity->m_pMat;
      }
      operator*(&v19, v13, &m_pColData->m_pSphereArray[v12].m_vecCentre);
      v14 = m_pColData->m_pSphereArray[v12].m_fRadius + Margin;
      if ( (float)(this->BaseZ - v14) <= v19.z && (float)(v14 + this->CeilingZ) >= v19.z )
      {
        v15 = v19.x - this->BaseX;
        v16 = v19.y - this->BaseY;
        v17 = (float)(v15 * this->Delta1X) + (float)(v16 * this->Delta1Y);
        if ( v17 >= (float)-v14 && v17 <= (float)(v14 + this->Delta1Length) )
        {
          v18 = (float)(v15 * this->Delta2X) + (float)(v16 * this->Delta2Y);
          if ( v18 >= (float)-v14 && v18 <= (float)(v14 + this->Delta2Length) )
            break;
        }
      }
      v12 = (__int16)(v12 + 1);
      if ( m_pColData->m_nNoOfSpheres <= v12 )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (00311D14) --------------------------------------------------------
bool __fastcall CGarage::IsStaticPlayerCarEntirelyInside(CGarage *this)
{
  CPlayerPed *PlayerPed; // r0
  CVehicle *PlayerVehicle; // r1
  CMatrix *m_pMat; // r2
  float *p_tx; // r0
  float v6; // s0
  float v7; // s0
  float v8; // s4
  float v9; // s6

  if ( !FindPlayerVehicle(-1, 0)
    || FindPlayerVehicle(-1, 0)->m_baseVehicleType && FindPlayerVehicle(-1, 0)->m_baseVehicleType != 9 )
  {
    return 0;
  }
  PlayerPed = FindPlayerPed(-1);
  if ( CTaskManager::FindActiveTaskByType(&PlayerPed->m_pPedIntelligence->m_taskManager, 704) )
    return 0;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  m_pMat = PlayerVehicle->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &PlayerVehicle->m_transform.m_translate.x;
  if ( *p_tx >= this->MinX
    && *p_tx <= this->MaxX
    && (v6 = p_tx[1], v6 >= this->MinY)
    && v6 <= this->MaxY
    && (v7 = fabsf(PlayerVehicle->m_vecMoveSpeed.x), v7 <= 0.01)
    && (v8 = fabsf(PlayerVehicle->m_vecMoveSpeed.y), v8 <= 0.01)
    && (v9 = fabsf(PlayerVehicle->m_vecMoveSpeed.z), v9 <= 0.01)
    && (float)((float)((float)(v7 * v7) + (float)(v8 * v8)) + (float)(v9 * v9)) <= 0.0001 )
  {
    return CGarage::IsEntityEntirelyInside3D(this, PlayerVehicle, 0.0);
  }
  else
  {
    return 0;
  }
}

//----- (00311E30) --------------------------------------------------------
bool __fastcall CGarages::IsCarSprayable(CVehicle *pCar)
{
  _BOOL4 v2; // r0

  if ( pCar->m_nHealth < 250.0 || CVehicle::IsLawEnforcementVehicle(pCar) || pCar->m_vehicleType == 10 )
  {
    LOBYTE(v2) = 0;
  }
  else if ( (unsigned int)(pCar->m_nModelIndex - 407) <= 0x1E )
  {
    return (0x3EFFFDFEu >> (pCar->m_nModelIndex + 105)) & 1;
  }
  else
  {
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (00311E8C) --------------------------------------------------------
void __fastcall CGarages::TriggerMessage(
        unsigned __int8 *pMessageID,
        Int16 NumberInString,
        UInt16 Duration,
        Int16 NumberInString2)
{
  Int32 v5; // r5
  Int32 v6; // r8
  int v7; // r6
  uint32 v8; // r0

  v5 = NumberInString;
  v6 = NumberInString2;
  v7 = Duration;
  if ( strcmp((const char *)pMessageID, (const char *)CGarages::MessageIDString)
    || CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
    || CTimer::m_snTimeInMilliseconds > CGarages::MessageEndTime )
  {
    strcpy((char *)CGarages::MessageIDString, (const char *)pMessageID);
    v8 = CTimer::m_snTimeInMilliseconds;
LABEL_3:
    CGarages::MessageEndTime = v7 + v8;
    CGarages::MessageStartTime = v8;
    CGarages::MessageNumberInString = v5;
    CGarages::MessageNumberInString2 = v6;
    return;
  }
  if ( CTimer::m_snTimeInMilliseconds - CGarages::MessageStartTime > 0x1F4 )
  {
    v8 = CTimer::m_snTimeInMilliseconds - 500;
    goto LABEL_3;
  }
}

//----- (00311F40) --------------------------------------------------------
bool __fastcall CGarage::IsPlayerOutsideGarage(CGarage *this, float Margin)
{
  CEntity *PlayerVehicle; // r0

  if ( FindPlayerVehicle(-1, 0) )
    PlayerVehicle = FindPlayerVehicle(-1, 0);
  else
    PlayerVehicle = FindPlayerPed(-1);
  return CGarage::IsEntityEntirelyOutside(this, PlayerVehicle, Margin);
}

//----- (00311F74) --------------------------------------------------------
float __fastcall CGarage::CalcDistToGarageRectangleSquared(CGarage *this, float X, float Y)
{
  float MinX; // s4
  float v4; // s2
  float MinY; // s4
  float v6; // s0

  MinX = this->MinX;
  if ( MinX <= X && (MinX = this->MaxX, MinX >= X) )
    v4 = 0.0;
  else
    v4 = X - MinX;
  MinY = this->MinY;
  if ( MinY <= Y && (MinY = this->MaxY, MinY >= Y) )
    v6 = 0.0;
  else
    v6 = Y - MinY;
  return (float)(v4 * v4) + (float)(v6 * v6);
}

//----- (00311FE0) --------------------------------------------------------
void __fastcall CGarage::ThrowCarsNearDoorOutOfGarage(CGarage *this, CVehicle *pException)
{
  int32 m_nSize; // r1
  CVehicle *v4; // r4
  bool v5; // zf
  CCollisionData *m_pColData; // r11
  float *p_z; // r0
  float *p_y; // r10
  float *p_x; // r8
  CSimpleTransform *p_m_transform; // r6
  const CMatrix **p_m_pMat; // r4
  int m_nNoOfSpheres; // r9
  float v13; // s0
  float v14; // s2
  float v15; // s4
  float v16; // s0
  float *p_tx; // r1
  float MinY; // s4
  float MaxY; // s6
  float v20; // s2
  int v21; // r1
  float v22; // s2
  float v23; // s2
  float v24; // s4
  CVehiclePool *v26; // [sp+4h] [bp-5Ch]
  int32 v27; // [sp+8h] [bp-58h]
  float *v28; // [sp+10h] [bp-50h]
  CVector v29; // [sp+14h] [bp-4Ch] BYREF

  v26 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    do
    {
      v27 = m_nSize - 1;
      if ( (v26->m_aFlags[m_nSize - 1] & 0x80u) == 0 )
      {
        v4 = (CVehicle *)v26->m_aStorage[v27];
        v5 = v4 == 0;
        if ( v4 )
          v5 = v4 == pException;
        if ( !v5 && CGarage::IsEntityTouching3D(this, (CEntity *)v26->m_aStorage[v27]) )
        {
          m_pColData = CEntity::GetColModel(v4)->m_pColData;
          if ( m_pColData->m_nNoOfSpheres >= 1 )
          {
            p_z = &v4->m_vecMoveSpeed.z;
            p_y = &v4->m_vecMoveSpeed.y;
            p_x = &v4->m_vecMoveSpeed.x;
            p_m_transform = &v4->m_transform;
            p_m_pMat = (const CMatrix **)&v4->m_pMat;
            m_nNoOfSpheres = 0;
            v28 = p_z;
            do
            {
              operator*(&v29, *p_m_pMat, &m_pColData->m_pSphereArray[m_nNoOfSpheres].m_vecCentre);
              if ( this->BaseZ > v29.z
                || (float)(this->CeilingZ + 0.0) < v29.z
                || (v13 = v29.x - this->BaseX,
                    v14 = v29.y - this->BaseY,
                    v15 = (float)(v13 * this->Delta1X) + (float)(v14 * this->Delta1Y),
                    v15 < -0.0)
                || v15 > (float)(this->Delta1Length + 0.0)
                || (v16 = (float)(v13 * this->Delta2X) + (float)(v14 * this->Delta2Y), v16 < -0.0)
                || v16 > (float)(this->Delta2Length + 0.0) )
              {
                p_tx = &p_m_transform->m_translate.x;
                MinY = this->MinY;
                MaxY = this->MaxY;
                if ( *p_m_pMat )
                  p_tx = &(*p_m_pMat)->tx;
                v20 = *p_tx;
                v21 = (int)p_m_transform;
                v29.x = v20 - (float)((float)(this->MinX + this->MaxX) * 0.5);
                if ( *p_m_pMat )
                  v21 = (int)&(*p_m_pMat)->tx;
                v22 = *(float *)(v21 + 4);
                v29.z = 0.0;
                v29.y = v22 - (float)((float)(MinY + MaxY) * 0.5);
                CVector::Normalise(&v29);
                v23 = (float)((float)(v29.y * 0.02) * CTimer::ms_fTimeStep) + *p_y;
                v24 = (float)((float)(v29.z * 0.02) * CTimer::ms_fTimeStep) + *v28;
                *p_x = *p_x + (float)((float)(v29.x * 0.02) * CTimer::ms_fTimeStep);
                *p_y = v23;
                *v28 = v24;
                m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
              }
              ++m_nNoOfSpheres;
            }
            while ( m_nNoOfSpheres < m_pColData->m_nNoOfSpheres );
          }
        }
      }
      m_nSize = v27;
    }
    while ( v27 );
  }
}

//----- (00312218) --------------------------------------------------------
void CGarages::GivePlayerDetonator()
{
  CPlayerPed *PlayerPed; // r4
  int32 m_nWeaponSlot; // r6

  PlayerPed = FindPlayerPed(-1);
  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_DETONATOR, 1)->m_nWeaponSlot;
  CPed::GiveWeapon(PlayerPed, WEAPONTYPE_DETONATOR, 1u, 1);
  PlayerPed->m_WeaponSlots[m_nWeaponSlot].m_eState = WEAPONSTATE_READY;
  PlayerPed->m_pPlayerData->m_nChosenWeapon = m_nWeaponSlot;
  if ( PlayerPed->m_eStoredWeapon != WEAPONTYPE_UNIDENTIFIED )
    PlayerPed->m_eStoredWeapon = WEAPONTYPE_DETONATOR;
}

//----- (0031226C) --------------------------------------------------------
bool __fastcall CGarage::IsEntityTouching3D(CGarage *this, CEntity *pEntity)
{
  float MinX; // s2
  CSimpleTransform *p_m_transform; // r10
  CBaseModelInfo *v6; // r0
  CMatrix *m_pMat; // r1
  float m_fRadius; // s0
  float *p_x; // r0
  float v10; // s2
  float v11; // s2
  CCollisionData *m_pColData; // r9
  int v13; // r6
  int v14; // r11
  CMatrix *v15; // r1
  float v16; // s0
  float v17; // s2
  float v18; // s4
  float v19; // s8
  float v20; // s2
  bool result; // r0
  CVector v22; // [sp+0h] [bp-28h] BYREF

  MinX = this->MinX;
  p_m_transform = &pEntity->m_transform;
  v6 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex];
  m_pMat = pEntity->m_pMat;
  m_fRadius = v6->m_pColModel->m_sphereBound.m_fRadius;
  p_x = &p_m_transform->m_translate.x;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  if ( *p_x < (float)(MinX - m_fRadius) )
    return 0;
  if ( *p_x > (float)(m_fRadius + this->MaxX) )
    return 0;
  v10 = p_x[1];
  if ( v10 < (float)(this->MinY - m_fRadius) )
    return 0;
  if ( v10 > (float)(m_fRadius + this->MaxY) )
    return 0;
  v11 = p_x[2];
  if ( v11 < (float)(this->BaseZ - m_fRadius) )
    return 0;
  if ( v11 > (float)(m_fRadius + this->CeilingZ) )
    return 0;
  m_pColData = CEntity::GetColModel(pEntity)->m_pColData;
  if ( m_pColData->m_nNoOfSpheres < 1 )
    return 0;
  v13 = 0;
  v14 = 0;
  while ( 1 )
  {
    v15 = pEntity->m_pMat;
    if ( !v15 )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(p_m_transform, pEntity->m_pMat);
      v15 = pEntity->m_pMat;
    }
    operator*(&v22, v15, &m_pColData->m_pSphereArray[v13].m_vecCentre);
    v16 = m_pColData->m_pSphereArray[v13].m_fRadius;
    if ( (float)(this->BaseZ - v16) <= v22.z && (float)(v16 + this->CeilingZ) >= v22.z )
    {
      v17 = v22.x - this->BaseX;
      v18 = v22.y - this->BaseY;
      v19 = (float)(v17 * this->Delta1X) + (float)(v18 * this->Delta1Y);
      if ( v19 >= (float)-v16 && v19 <= (float)(v16 + this->Delta1Length) )
      {
        v20 = (float)(v17 * this->Delta2X) + (float)(v18 * this->Delta2Y);
        if ( v20 >= (float)-v16 && v20 <= (float)(v16 + this->Delta2Length) )
          break;
      }
    }
    ++v14;
    ++v13;
    result = 0;
    if ( v14 >= m_pColData->m_nNoOfSpheres )
      return result;
  }
  return 1;
}

//----- (0031242C) --------------------------------------------------------
bool __fastcall CGarage::IsGarageEmpty(CGarage *this)
{
  float *p_MinX; // r6
  float BaseZ; // r0
  bool v4; // r5
  RwReal v5; // r1
  RwReal v6; // r2
  RwReal v7; // r3
  RwReal v8; // r6
  float CeilingZ; // r0
  int v10; // r5
  CVector CoorsMax; // [sp+1Ch] [bp-6Ch] BYREF
  CVector CoorsMin; // [sp+28h] [bp-60h] BYREF
  CEntity *ppResults[16]; // [sp+34h] [bp-54h] BYREF
  Int16 pNum[9]; // [sp+76h] [bp-12h] BYREF

  p_MinX = &this->MinX;
  BaseZ = this->BaseZ;
  v4 = 1;
  v5 = *p_MinX;
  v6 = p_MinX[1];
  v7 = p_MinX[2];
  v8 = p_MinX[3];
  CoorsMin.x = v5;
  CoorsMin.y = v7;
  CoorsMin.z = BaseZ;
  CeilingZ = this->CeilingZ;
  CoorsMax.x = v6;
  CoorsMax.y = v8;
  CoorsMax.z = CeilingZ;
  CWorld::FindObjectsIntersectingCube(&CoorsMin, &CoorsMax, pNum, 16, ppResults, 0, 1, 1, 0, 0);
  if ( pNum[0] >= 1 )
  {
    LOWORD(v10) = 0;
    while ( !CGarage::IsEntityTouching3D(this, ppResults[(__int16)v10]) )
    {
      v10 = (__int16)(v10 + 1);
      if ( v10 >= pNum[0] )
        return 1;
    }
    return 0;
  }
  return v4;
}
// 31242C: using guessed type Int16 pNum[9];

//----- (003124A4) --------------------------------------------------------
bool __fastcall CGarage::IsAnyCarBlockingDoor(CGarage *this)
{
  CVehiclePool *v2; // r9
  int32 m_nSize; // r5
  CEntity *v4; // r6
  CCollisionData *m_pColData; // r11
  CColSphere *m_pSphereArray; // r0
  const CMatrix **p_m_pMat; // r6
  int v8; // r10
  int v9; // r8
  float m_fRadius; // s0
  float v11; // s4
  float v12; // s2
  float v13; // s2
  CVector v15; // [sp+0h] [bp-28h] BYREF

  v2 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  while ( 1 )
  {
    if ( (v2->m_aFlags[--m_nSize] & 0x80u) == 0 )
    {
      v4 = (CEntity *)v2->m_aStorage[m_nSize];
      if ( v4 )
      {
        if ( CGarage::IsEntityTouching3D(this, (CEntity *)v2->m_aStorage[m_nSize]) )
        {
          m_pColData = CEntity::GetColModel(v4)->m_pColData;
          if ( m_pColData->m_nNoOfSpheres >= 1 )
            break;
        }
      }
    }
LABEL_15:
    if ( !m_nSize )
      return 0;
  }
  m_pSphereArray = m_pColData->m_pSphereArray;
  p_m_pMat = (const CMatrix **)&v4->m_pMat;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    operator*(&v15, *p_m_pMat, &m_pSphereArray[v8].m_vecCentre);
    m_pSphereArray = m_pColData->m_pSphereArray;
    m_fRadius = m_pSphereArray[v8].m_fRadius;
    if ( (float)(this->BaseZ - m_fRadius) > v15.z )
      return 1;
    if ( (float)(m_fRadius + this->CeilingZ) < v15.z )
      return 1;
    v11 = v15.y - this->BaseY;
    v12 = v15.x - this->BaseX;
    if ( (float)((float)(v12 * this->Delta1X) + (float)(v11 * this->Delta1Y)) > (float)(m_fRadius + this->Delta1Length) )
      return 1;
    v13 = (float)(v12 * this->Delta2X) + (float)(v11 * this->Delta2Y);
    if ( v13 < (float)-m_fRadius || v13 > (float)(m_fRadius + this->Delta2Length) )
      return 1;
    ++v9;
    ++v8;
    if ( v9 >= m_pColData->m_nNoOfSpheres )
      goto LABEL_15;
  }
}

//----- (003125F8) --------------------------------------------------------
Int32 __fastcall CGarage::CountCarsWithCenterPointWithinGarage(CGarage *this, CEntity *pException)
{
  int32 m_nSize; // r3
  int32 v3; // r4
  int v4; // r9
  Int32 v5; // r8
  uint8 *v6; // r1
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r1
  uint8 *v8; // r5
  bool v9; // zf
  int v10; // r5
  int v11; // r2
  float *v12; // r1
  float v13; // s0
  float v14; // s0
  float v15; // s2
  float v16; // s4
  float v17; // s0

  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  v3 = m_nSize;
  v4 = -2604 - (_DWORD)pException;
  v5 = 0;
  do
  {
    v6 = &CPools::ms_pVehiclePool->m_aFlags[m_nSize--];
    if ( (*(v6 - 1) & 0x80u) == 0 )
    {
      m_aStorage = CPools::ms_pVehiclePool->m_aStorage;
      v8 = CPools::ms_pVehiclePool->m_aStorage[v3];
      v9 = v8 == (uint8 *)&elf_hash_bucket[588];
      if ( v8 != (uint8 *)&elf_hash_bucket[588] )
        v9 = &(*m_aStorage)[v4 + v3 * 2604] == 0;
      if ( !v9 )
      {
        v10 = (int)&(*m_aStorage)[v3 * 2604 - 2604];
        v11 = *(_DWORD *)(v10 + 20);
        v12 = (float *)(v11 + 48);
        if ( !v11 )
          v12 = (float *)(v10 + 4);
        v13 = v12[2];
        if ( this->BaseZ <= v13 && this->CeilingZ >= v13 )
        {
          v14 = *v12 - this->BaseX;
          v15 = v12[1] - this->BaseY;
          v16 = (float)(v14 * this->Delta1X) + (float)(v15 * this->Delta1Y);
          if ( v16 >= 0.0 && v16 <= this->Delta1Length )
          {
            v17 = (float)(v14 * this->Delta2X) + (float)(v15 * this->Delta2Y);
            if ( v17 >= 0.0 && v17 <= this->Delta2Length )
              ++v5;
          }
        }
      }
    }
    --v3;
  }
  while ( m_nSize );
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0031270C) --------------------------------------------------------
Int32 __fastcall CGarage::FindMaxNumStoredCarsForGarage(CGarage *this)
{
  int Type; // r1
  Int32 result; // r0

  Type = this->Type;
  result = 4;
  if ( Type == 16 )
    return 2;
  return result;
}

//----- (0031271C) --------------------------------------------------------
void __fastcall CGarage::RemoveCarsBlockingDoorNotInside(CGarage *this)
{
  CVehiclePool *v2; // r9
  int32 m_nSize; // r0
  int v4; // r4
  int v5; // r6
  uint8 *v6; // r11
  float *v7; // r0
  int v8; // r1
  float v9; // s0
  float v10; // s0
  float v11; // s2
  float v12; // s4
  float v13; // s0

  v2 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v4 = m_nSize;
    v5 = m_nSize - 1;
    while ( 1 )
    {
      if ( (v2->m_aFlags[v5] & 0x80u) == 0 )
      {
        v6 = v2->m_aStorage[v4];
        if ( v6 != (uint8 *)&elf_hash_bucket[588] && CGarage::IsEntityTouching3D(this, (CEntity *)(v6 - 2604)) )
        {
          v7 = (float *)(v6 - 2600);
          v8 = *((_DWORD *)v6 - 646);
          if ( v8 )
            v7 = (float *)(v8 + 48);
          v9 = v7[2];
          if ( this->BaseZ > v9
            || this->CeilingZ < v9
            || (v10 = *v7 - this->BaseX,
                v11 = v7[1] - this->BaseY,
                v12 = (float)(v10 * this->Delta1X) + (float)(v11 * this->Delta1Y),
                v12 < 0.0)
            || v12 > this->Delta1Length
            || (v13 = (float)(v10 * this->Delta2X) + (float)(v11 * this->Delta2Y), v13 < 0.0)
            || v13 > this->Delta2Length )
          {
            if ( (*(v6 - 1536) & 8) == 0 && CVehicle::CanBeDeleted((const CVehicle *)(v6 - 2604)) )
              break;
          }
        }
      }
      --v5;
      --v4;
      if ( v5 == -1 )
        return;
    }
    CWorld::Remove((CEntity *)(v6 - 2604));
    (*(void (__fastcall **)(uint8 *))(*((_DWORD *)v6 - 651) + 4))(v6 - 2604);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00312858) --------------------------------------------------------
void __fastcall CGarage::StoreAndRemoveCarsForThisHideOut(CGarage *this, CStoredCar *aStoredCars, Int32 MaxNumStored)
{
  CVehiclePool *v4; // r4
  int32 m_nSize; // r0
  int v6; // r11
  Int32 v7; // r12
  int v8; // r8
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r9
  CVehicle *v10; // r5
  CMatrix *m_pMat; // r3
  float *p_tx; // r0
  float v13; // s0
  float v14; // s0
  float v15; // s2
  float v16; // s4
  float v17; // s0
  CStoredCar *v18; // r0
  int v19; // r1
  UInt16 *p_ModelIndex; // r0
  Int32 v21; // [sp+0h] [bp-30h]
  CStoredCar *v22; // [sp+4h] [bp-2Ch]
  Int32 v23; // [sp+Ch] [bp-24h]

  aStoredCars[1].ModelIndex = 0;
  aStoredCars->ModelIndex = 0;
  aStoredCars[2].ModelIndex = 0;
  aStoredCars[3].ModelIndex = 0;
  v4 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
  {
    v7 = 0;
LABEL_24:
    v18 = &aStoredCars[v7];
    v19 = v7 - 1;
    p_ModelIndex = &v18->ModelIndex;
    do
    {
      ++v19;
      *p_ModelIndex = 0;
      p_ModelIndex += 32;
    }
    while ( v19 < 3 );
    return;
  }
  v6 = m_nSize - 1;
  if ( MaxNumStored >= 4 )
    MaxNumStored = 4;
  v7 = 0;
  v8 = 2604 * m_nSize - 2604;
  do
  {
    if ( (v4->m_aFlags[v6] & 0x80u) == 0 )
    {
      m_aStorage = v4->m_aStorage;
      v10 = (CVehicle *)&(*v4->m_aStorage)[v8];
      if ( v10 )
      {
        m_pMat = v10->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v10->m_transform.m_translate.x;
        v13 = p_tx[2];
        if ( this->BaseZ <= v13 && this->CeilingZ >= v13 )
        {
          v14 = *p_tx - this->BaseX;
          v15 = p_tx[1] - this->BaseY;
          v16 = (float)(v14 * this->Delta1X) + (float)(v15 * this->Delta1Y);
          if ( v16 >= 0.0 && v16 <= this->Delta1Length )
          {
            v17 = (float)(v14 * this->Delta2X) + (float)(v15 * this->Delta2Y);
            if ( v17 >= 0.0 && v17 <= this->Delta2Length && v10->VehicleCreatedBy != 2 )
            {
              v21 = MaxNumStored;
              v22 = aStoredCars;
              v23 = v7;
              if ( v7 < MaxNumStored && !CGarage::EntityHasASphereWayOutsideGarage(this, v10, 1.0) )
                CStoredCar::StoreCar(&v22[v23++], v10);
              CPlayerInfo::CancelPlayerEnteringCars(&CWorld::Players[CWorld::PlayerInFocus], v10);
              CWorld::Remove(v10);
              (*(void (__fastcall **)(CVehicle *))(*(_DWORD *)&(*m_aStorage)[v8] + 4))(v10);
              MaxNumStored = v21;
              aStoredCars = v22;
              v7 = v23;
            }
          }
        }
      }
    }
    --v6;
    v8 -= 2604;
  }
  while ( v6 != -1 );
  if ( v7 < 4 )
    goto LABEL_24;
}

//----- (00312A10) --------------------------------------------------------
Int32 __fastcall CGarages::FindSafeHouseIndexForGarageType(Int32 GarageType)
{
  unsigned int v1; // r0

  v1 = GarageType - 17;
  if ( v1 <= 0x1C )
    return dword_60FBD0[v1];
  else
    return 0;
}
// 60FBD0: using guessed type _DWORD dword_60FBD0[29];

//----- (00312A28) --------------------------------------------------------
Int32 __fastcall CGarages::CountCarsInHideoutGarage(UInt8 Type)
{
  unsigned __int8 v1; // r0
  int v2; // r3
  int v3; // r4
  UInt16 *p_ModelIndex; // r2
  UInt16 *v5; // r0
  UInt16 *v6; // r3
  int v7; // r2
  Int32 result; // r0

  v1 = Type - 17;
  if ( v1 > 0x1Cu )
  {
    v3 = 0;
    p_ModelIndex = &CGarages::aCarsInSafeHouse[0][2].ModelIndex;
    v5 = &CGarages::aCarsInSafeHouse[0][1].ModelIndex;
    v6 = &CGarages::aCarsInSafeHouse[0][0].ModelIndex;
  }
  else
  {
    v2 = (char)v1;
    v3 = dword_60FBD0[(char)v1];
    p_ModelIndex = (UInt16 *)*(&off_665510 + (char)v1);
    v5 = (UInt16 *)*(&off_665490 + (char)v1);
    v6 = (UInt16 *)*(&off_665410 + v2);
  }
  v7 = *p_ModelIndex;
  result = *v5 != 0;
  if ( *v6 )
    ++result;
  if ( v7 )
    ++result;
  if ( CGarages::aCarsInSafeHouse[v3][3].ModelIndex )
    ++result;
  return result;
}
// 60FBD0: using guessed type _DWORD dword_60FBD0[29];
// 665410: using guessed type void *off_665410;
// 665490: using guessed type void *off_665490;
// 665510: using guessed type void *off_665510;

//----- (00312ABC) --------------------------------------------------------
bool __fastcall CGarage::RestoreCarsForThisHideOut(CGarage *this, CStoredCar *aStoredCars)
{
  CEntity *v3; // r0
  CEntity *v4; // r0
  CEntity *v5; // r0
  CEntity *v6; // r0
  bool v7; // zf

  if ( aStoredCars->ModelIndex )
  {
    v3 = CStoredCar::RestoreCar(aStoredCars);
    if ( v3 )
    {
      v3[17].m_pLod = (CEntity *)((int)v3[17].m_pLod & ~0x2000u);
      CWorld::Add(v3);
      aStoredCars->ModelIndex = 0;
    }
  }
  if ( aStoredCars[1].ModelIndex )
  {
    v4 = CStoredCar::RestoreCar(aStoredCars + 1);
    if ( v4 )
    {
      v4[17].m_pLod = (CEntity *)((int)v4[17].m_pLod & ~0x2000u);
      CWorld::Add(v4);
      aStoredCars[1].ModelIndex = 0;
    }
  }
  if ( aStoredCars[2].ModelIndex )
  {
    v5 = CStoredCar::RestoreCar(aStoredCars + 2);
    if ( v5 )
    {
      v5[17].m_pLod = (CEntity *)((int)v5[17].m_pLod & ~0x2000u);
      CWorld::Add(v5);
      aStoredCars[2].ModelIndex = 0;
    }
  }
  if ( aStoredCars[3].ModelIndex )
  {
    v6 = CStoredCar::RestoreCar(aStoredCars + 3);
    if ( v6 )
    {
      v6[17].m_pLod = (CEntity *)((int)v6[17].m_pLod & ~0x2000u);
      CWorld::Add(v6);
      aStoredCars[3].ModelIndex = 0;
    }
  }
  if ( aStoredCars->ModelIndex )
    return 0;
  v7 = aStoredCars[1].ModelIndex == 0;
  if ( !aStoredCars[1].ModelIndex )
    v7 = aStoredCars[2].ModelIndex == 0;
  return v7 && aStoredCars[3].ModelIndex == 0;
}

//----- (00312B7C) --------------------------------------------------------
void __fastcall CGarage::StoreAndRemoveCarsForThisImpoundingGarage(
        CGarage *this,
        CStoredCar *aStoredCars,
        Int32 MaxNumStored)
{
  CVehiclePool *v4; // r4
  int32 m_nSize; // r0
  int v6; // r11
  Int32 v7; // r12
  int v8; // r8
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r9
  CVehicle *v10; // r5
  CMatrix *m_pMat; // r3
  float *p_tx; // r0
  float v13; // s0
  float v14; // s0
  float v15; // s2
  float v16; // s4
  float v17; // s0
  CStoredCar *v18; // r0
  int v19; // r1
  UInt16 *p_ModelIndex; // r0
  Int32 v21; // [sp+0h] [bp-30h]
  CStoredCar *v22; // [sp+4h] [bp-2Ch]
  Int32 v23; // [sp+Ch] [bp-24h]

  aStoredCars[1].ModelIndex = 0;
  aStoredCars->ModelIndex = 0;
  aStoredCars[2].ModelIndex = 0;
  aStoredCars[3].ModelIndex = 0;
  v4 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
  {
    v7 = 0;
LABEL_24:
    v18 = &aStoredCars[v7];
    v19 = v7 - 1;
    p_ModelIndex = &v18->ModelIndex;
    do
    {
      ++v19;
      *p_ModelIndex = 0;
      p_ModelIndex += 32;
    }
    while ( v19 < 3 );
    return;
  }
  v6 = m_nSize - 1;
  if ( MaxNumStored >= 4 )
    MaxNumStored = 4;
  v7 = 0;
  v8 = 2604 * m_nSize - 2604;
  do
  {
    if ( (v4->m_aFlags[v6] & 0x80u) == 0 )
    {
      m_aStorage = v4->m_aStorage;
      v10 = (CVehicle *)&(*v4->m_aStorage)[v8];
      if ( v10 )
      {
        m_pMat = v10->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v10->m_transform.m_translate.x;
        v13 = p_tx[2];
        if ( this->BaseZ <= v13 && this->CeilingZ >= v13 )
        {
          v14 = *p_tx - this->BaseX;
          v15 = p_tx[1] - this->BaseY;
          v16 = (float)(v14 * this->Delta1X) + (float)(v15 * this->Delta1Y);
          if ( v16 >= 0.0 && v16 <= this->Delta1Length )
          {
            v17 = (float)(v14 * this->Delta2X) + (float)(v15 * this->Delta2Y);
            if ( v17 >= 0.0 && v17 <= this->Delta2Length && v10->VehicleCreatedBy != 2 )
            {
              v21 = MaxNumStored;
              v22 = aStoredCars;
              v23 = v7;
              if ( v7 < MaxNumStored && !CGarage::EntityHasASphereWayOutsideGarage(this, v10, 1.0) )
                CStoredCar::StoreCar(&v22[v23++], v10);
              CPlayerInfo::CancelPlayerEnteringCars(&CWorld::Players[CWorld::PlayerInFocus], v10);
              CWorld::Remove(v10);
              (*(void (__fastcall **)(CVehicle *))(*(_DWORD *)&(*m_aStorage)[v8] + 4))(v10);
              MaxNumStored = v21;
              aStoredCars = v22;
              v7 = v23;
            }
          }
        }
      }
    }
    --v6;
    v8 -= 2604;
  }
  while ( v6 != -1 );
  if ( v7 < 4 )
    goto LABEL_24;
}

//----- (00312D34) --------------------------------------------------------
void __fastcall CGarage::NeatlyLineUpStoredCars(CGarage *this, CStoredCar *aStoredCars)
{
  float BaseX; // s16
  float BaseY; // s18
  float BaseZ; // s22
  float Delta1X; // s28
  float Delta1Y; // s30
  float Delta2X; // s20
  float Delta2Y; // s24
  float Delta1Length; // s17
  float Delta2Length; // s26
  float y; // s12
  float x; // s14
  float v14; // s0
  float v15; // s2
  float v16; // s4
  UInt16 *p_ModelIndex; // r2
  int v18; // r3
  int v19; // s14
  int v20; // s12
  int v21; // r4
  CVector v22; // [sp+4h] [bp-5Ch] BYREF

  BaseX = this->BaseX;
  BaseY = this->BaseY;
  BaseZ = this->BaseZ;
  Delta1X = this->Delta1X;
  Delta1Y = this->Delta1Y;
  Delta2X = this->Delta2X;
  Delta2Y = this->Delta2Y;
  Delta1Length = this->Delta1Length;
  Delta2Length = this->Delta2Length;
  v22.z = 0.0;
  v22.y = Delta1Y;
  v22.x = Delta1X;
  CVector::Normalise(&v22);
  y = v22.y;
  x = v22.x;
  v14 = v22.z * 4.0;
  v15 = v22.y * 4.0;
  v16 = v22.x * 4.0;
  v22.x = v22.x * 4.0;
  v22.y = v22.y * 4.0;
  v22.z = v22.z * 4.0;
  if ( aStoredCars->ModelIndex )
  {
    p_ModelIndex = &aStoredCars[1].ModelIndex;
    v18 = 0;
    v19 = (int)(float)(x * -100.0);
    v20 = (int)(float)(y * 100.0);
    do
    {
      *((_BYTE *)p_ModelIndex - 21) = v19;
      *((_BYTE *)p_ModelIndex - 22) = v20;
      *((_BYTE *)p_ModelIndex - 20) = 0;
      v21 = *p_ModelIndex;
      *(float *)(p_ModelIndex - 39) = (float)((float)((float)(BaseY + (float)((float)(Delta1Y * Delta1Length) * 0.5))
                                                    + (float)((float)(Delta2Y * Delta2Length) * 0.5))
                                            - v15)
                                    + (float)(v15 * (float)v18);
      *(float *)(p_ModelIndex - 41) = (float)((float)((float)(BaseX + (float)((float)(Delta1X * Delta1Length) * 0.5))
                                                    + (float)((float)(Delta2X * Delta2Length) * 0.5))
                                            - v16)
                                    + (float)(v16 * (float)v18);
      *(float *)(p_ModelIndex - 37) = (float)((float)((float)((float)(BaseZ + 0.5)
                                                            + (float)((float)(Delta1Length * 0.0) * 0.5))
                                                    + (float)((float)(Delta2Length * 0.0) * 0.5))
                                            - v14)
                                    + (float)(v14 * (float)v18);
      if ( v18 > 1 )
        break;
      p_ModelIndex += 32;
      ++v18;
    }
    while ( v21 );
  }
}

//----- (00312E98) --------------------------------------------------------
bool __fastcall CGarage::RestoreCarsForThisImpoundingGarage(CGarage *this, CStoredCar *aStoredCars)
{
  CEntity *v3; // r0
  CBike *v4; // r5
  int32 m_vehicleType; // r0
  CEntity *v6; // r0
  CBike *v7; // r5
  int32 v8; // r0
  CEntity *v9; // r0
  CBike *v10; // r5
  int32 v11; // r0
  bool v12; // zf

  if ( aStoredCars->ModelIndex )
  {
    v3 = CStoredCar::RestoreCar(aStoredCars);
    v4 = (CBike *)v3;
    if ( v3 )
    {
      v3[17].m_pLod = (CEntity *)((int)v3[17].m_pLod | 0x2000);
      CWorld::Add(v3);
      m_vehicleType = v4->m_vehicleType;
      if ( m_vehicleType == 9 )
      {
        CBike::PlaceOnRoadProperly(v4);
      }
      else if ( !m_vehicleType )
      {
        CAutomobile::PlaceOnRoadProperly((CAutomobile *)v4);
      }
      aStoredCars->ModelIndex = 0;
    }
  }
  if ( aStoredCars[1].ModelIndex )
  {
    v6 = CStoredCar::RestoreCar(aStoredCars + 1);
    v7 = (CBike *)v6;
    if ( v6 )
    {
      v6[17].m_pLod = (CEntity *)((int)v6[17].m_pLod | 0x2000);
      CWorld::Add(v6);
      v8 = v7->m_vehicleType;
      if ( v8 )
      {
        if ( v8 == 9 )
          CBike::PlaceOnRoadProperly(v7);
      }
      else
      {
        CAutomobile::PlaceOnRoadProperly((CAutomobile *)v7);
      }
      aStoredCars[1].ModelIndex = 0;
    }
  }
  if ( aStoredCars[2].ModelIndex )
  {
    v9 = CStoredCar::RestoreCar(aStoredCars + 2);
    v10 = (CBike *)v9;
    if ( v9 )
    {
      v9[17].m_pLod = (CEntity *)((int)v9[17].m_pLod | 0x2000);
      CWorld::Add(v9);
      v11 = v10->m_vehicleType;
      if ( v11 )
      {
        if ( v11 == 9 )
          CBike::PlaceOnRoadProperly(v10);
      }
      else
      {
        CAutomobile::PlaceOnRoadProperly((CAutomobile *)v10);
      }
      aStoredCars[2].ModelIndex = 0;
    }
  }
  v12 = aStoredCars->ModelIndex == 0;
  if ( !aStoredCars->ModelIndex )
    v12 = aStoredCars[1].ModelIndex == 0;
  return v12 && aStoredCars[2].ModelIndex == 0;
}

//----- (00312F80) --------------------------------------------------------
bool __fastcall CGarage::RightModTypeForThisGarage(CGarage *this, CVehicle *pVeh)
{
  CBaseModelInfo *v2; // r2
  int Type; // r1
  int v4; // r0

  if ( !pVeh )
    return 0;
  v2 = CModelInfo::ms_modelInfoPtrs[pVeh->m_nModelIndex];
  Type = this->Type;
  v4 = *((unsigned __int8 *)&v2[1].m_flags + 2);
  if ( Type == 38 )
    return (mod_HandlingManager.m_aHandlingData[v4].hFlags & 0x6000000) == 0;
  if ( Type != 37 )
    return Type == 36 && (mod_HandlingManager.m_aHandlingData[v4].hFlags & 0x2000000) != 0;
  return (mod_HandlingManager.m_aHandlingData[v4].hFlags & 0x4000000) != 0;
}

//----- (00313010) --------------------------------------------------------
bool __fastcall CGarage::IsAnyOtherCarTouchingGarage(CGarage *this, CVehicle *pException)
{
  CVehiclePool *v3; // r10
  int32 m_nSize; // r6
  CVehicle *v5; // r4
  bool v6; // zf
  CCollisionData *m_pColData; // r11
  CColSphere *m_pSphereArray; // r0
  const CMatrix **p_m_pMat; // r4
  int v10; // r8
  int v11; // r9
  float m_fRadius; // s0
  float v13; // s2
  float v14; // s4
  float v15; // s8
  float v16; // s2
  CVector v19; // [sp+8h] [bp-28h] BYREF

  v3 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  while ( 1 )
  {
    if ( (v3->m_aFlags[--m_nSize] & 0x80u) == 0 )
    {
      v5 = (CVehicle *)v3->m_aStorage[m_nSize];
      if ( v5 )
      {
        v6 = v5 == pException;
        if ( v5 != pException )
          v6 = (*(_BYTE *)&v5->m_info & 0xF8) == 40;
        if ( !v6 && CGarage::IsEntityTouching3D(this, (CEntity *)v3->m_aStorage[m_nSize]) )
        {
          m_pColData = CEntity::GetColModel(v5)->m_pColData;
          if ( m_pColData->m_nNoOfSpheres >= 1 )
            break;
        }
      }
    }
LABEL_17:
    if ( !m_nSize )
      return 0;
  }
  m_pSphereArray = m_pColData->m_pSphereArray;
  p_m_pMat = (const CMatrix **)&v5->m_pMat;
  v10 = 0;
  v11 = 0;
  while ( 1 )
  {
    operator*(&v19, *p_m_pMat, &m_pSphereArray[v10].m_vecCentre);
    m_pSphereArray = m_pColData->m_pSphereArray;
    m_fRadius = m_pSphereArray[v10].m_fRadius;
    if ( (float)(this->BaseZ - m_fRadius) <= v19.z && (float)(m_fRadius + this->CeilingZ) >= v19.z )
    {
      v13 = v19.x - this->BaseX;
      v14 = v19.y - this->BaseY;
      v15 = (float)(v13 * this->Delta1X) + (float)(v14 * this->Delta1Y);
      if ( v15 >= (float)-m_fRadius && v15 <= (float)(m_fRadius + this->Delta1Length) )
      {
        v16 = (float)(v13 * this->Delta2X) + (float)(v14 * this->Delta2Y);
        if ( v16 >= (float)-m_fRadius && v16 <= (float)(m_fRadius + this->Delta2Length) )
          return 1;
      }
    }
    ++v11;
    ++v10;
    if ( v11 >= m_pColData->m_nNoOfSpheres )
      goto LABEL_17;
  }
}

//----- (00313174) --------------------------------------------------------
int __fastcall CGarage::IsPointInsideGarage(CGarage *this, CVector Point, float Margin)
{
  float v3; // s6
  float v4; // s4
  float v5; // s8
  int v7; // r1
  float v8; // s4

  if ( (float)(this->BaseZ - Margin) > Point.z )
    return 0;
  if ( (float)(this->CeilingZ + Margin) < Point.z )
    return 0;
  v3 = Point.y - this->BaseY;
  v4 = Point.x - this->BaseX;
  v5 = (float)(v4 * this->Delta1X) + (float)(v3 * this->Delta1Y);
  if ( v5 < (float)-Margin || v5 > (float)(this->Delta1Length + Margin) )
    return 0;
  v7 = 0;
  v8 = (float)(v4 * this->Delta2X) + (float)(v3 * this->Delta2Y);
  if ( v8 >= (float)-Margin && v8 <= (float)(this->Delta2Length + Margin) )
    return 1;
  return v7;
}

//----- (0031322A) --------------------------------------------------------
bool __fastcall CGarage::IsPlayerEntirelyInsideGarage(CGarage *this)
{
  CEntity *PlayerVehicle; // r0

  if ( FindPlayerVehicle(-1, 0) )
    PlayerVehicle = FindPlayerVehicle(-1, 0);
  else
    PlayerVehicle = FindPlayerPed(-1);
  return CGarage::IsEntityEntirelyInside3D(this, PlayerVehicle, 0.0);
}

//----- (0031325E) --------------------------------------------------------
bool __fastcall CGarage::EntityHasASphereWayOutsideGarage(CGarage *this, CEntity *pEntity, float Margin)
{
  CCollisionData *m_pColData; // r11
  int v7; // r4
  int v8; // r6
  CMatrix *m_pMat; // r1
  float v10; // s0
  float v11; // s4
  float v12; // s2
  float v13; // s2
  CVector v15; // [sp+4h] [bp-34h] BYREF

  m_pColData = CEntity::GetColModel(pEntity)->m_pColData;
  if ( m_pColData->m_nNoOfSpheres < 1 )
    return 0;
  v7 = 0;
  v8 = 0;
  while ( 1 )
  {
    m_pMat = pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    operator*(&v15, m_pMat, &m_pColData->m_pSphereArray[v7].m_vecCentre);
    v10 = m_pColData->m_pSphereArray[v7].m_fRadius + Margin;
    if ( (float)(this->BaseZ - v10) > v15.z )
      break;
    if ( (float)(v10 + this->CeilingZ) < v15.z )
      break;
    v11 = v15.y - this->BaseY;
    v12 = v15.x - this->BaseX;
    if ( (float)((float)(v12 * this->Delta1X) + (float)(v11 * this->Delta1Y)) > (float)(v10 + this->Delta1Length) )
      break;
    v13 = (float)(v12 * this->Delta2X) + (float)(v11 * this->Delta2Y);
    if ( v13 < (float)-v10 || v13 > (float)(v10 + this->Delta2Length) )
      break;
    ++v8;
    ++v7;
    if ( v8 >= m_pColData->m_nNoOfSpheres )
      return 0;
  }
  return 1;
}

//----- (00313394) --------------------------------------------------------
bool __fastcall CGarage::IsAnyOtherPedTouchingGarage(CGarage *this, CPed *pException)
{
  CPedPool *v3; // r10
  int32 m_nSize; // r6
  CPed *v5; // r4
  bool v6; // zf
  CCollisionData *m_pColData; // r11
  CColSphere *m_pSphereArray; // r0
  const CMatrix **p_m_pMat; // r4
  int v10; // r8
  int v11; // r9
  float m_fRadius; // s0
  float v13; // s2
  float v14; // s4
  float v15; // s8
  float v16; // s2
  CVector v19; // [sp+8h] [bp-28h] BYREF

  v3 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( !m_nSize )
    return 0;
  while ( 1 )
  {
    if ( (v3->m_aFlags[--m_nSize] & 0x80u) == 0 )
    {
      v5 = (CPed *)v3->m_aStorage[m_nSize];
      v6 = v5 == 0;
      if ( v5 )
        v6 = v5 == pException;
      if ( !v6 && CGarage::IsEntityTouching3D(this, (CEntity *)v3->m_aStorage[m_nSize]) )
      {
        m_pColData = CEntity::GetColModel(v5)->m_pColData;
        if ( m_pColData->m_nNoOfSpheres >= 1 )
          break;
      }
    }
LABEL_16:
    if ( !m_nSize )
      return 0;
  }
  m_pSphereArray = m_pColData->m_pSphereArray;
  p_m_pMat = (const CMatrix **)&v5->m_pMat;
  v10 = 0;
  v11 = 0;
  while ( 1 )
  {
    operator*(&v19, *p_m_pMat, &m_pSphereArray[v10].m_vecCentre);
    m_pSphereArray = m_pColData->m_pSphereArray;
    m_fRadius = m_pSphereArray[v10].m_fRadius;
    if ( (float)(this->BaseZ - m_fRadius) <= v19.z && (float)(m_fRadius + this->CeilingZ) >= v19.z )
    {
      v13 = v19.x - this->BaseX;
      v14 = v19.y - this->BaseY;
      v15 = (float)(v13 * this->Delta1X) + (float)(v14 * this->Delta1Y);
      if ( v15 >= (float)-m_fRadius && v15 <= (float)(m_fRadius + this->Delta1Length) )
      {
        v16 = (float)(v13 * this->Delta2X) + (float)(v14 * this->Delta2Y);
        if ( v16 >= (float)-m_fRadius && v16 <= (float)(m_fRadius + this->Delta2Length) )
          return 1;
      }
    }
    ++v11;
    ++v10;
    if ( v11 >= m_pColData->m_nNoOfSpheres )
      goto LABEL_16;
  }
}

//----- (003134EC) --------------------------------------------------------
bool __fastcall CGarage::IsPointInsideGarage(CGarage *this, CVector Point)
{
  float v2; // s0
  float v3; // s2
  float v4; // s4
  bool v6; // r1
  float v7; // s0

  if ( this->BaseZ > Point.z )
    return 0;
  if ( this->CeilingZ < Point.z )
    return 0;
  v2 = Point.x - this->BaseX;
  v3 = Point.y - this->BaseY;
  v4 = (float)(v2 * this->Delta1X) + (float)(v3 * this->Delta1Y);
  if ( v4 < 0.0 || v4 > this->Delta1Length )
    return 0;
  v6 = 0;
  v7 = (float)(v2 * this->Delta2X) + (float)(v3 * this->Delta2Y);
  if ( v7 >= 0.0 && v7 <= this->Delta2Length )
    return 1;
  return v6;
}

//----- (0031358C) --------------------------------------------------------
void CGarages::PrintMessages()
{
  CRGBA v0; // r0
  GxtChar *v1; // r0
  GxtChar *v2; // r0
  GxtChar *v3; // r2
  float v4; // r0
  float v5; // r1
  RwInt32 screenWidth; // r4
  float v7; // s0
  CRGBA v8; // [sp+10h] [bp-18h] BYREF
  CRGBA v9[5]; // [sp+14h] [bp-14h] BYREF

  if ( CTimer::m_snTimeInMilliseconds < CGarages::MessageStartTime
    || CTimer::m_snTimeInMilliseconds >= CGarages::MessageEndTime )
  {
    CGarages::MessageIDString[0] = 0;
    return;
  }
  CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.4);
  CFont::SetProportional(1u);
  CFont::SetBackground(0, 0);
  CFont::SetCentreSize((float)RsGlobal.screenWidth + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 230.0));
  CFont::SetOrientation(0);
  CFont::SetFontStyle(2u);
  CHudColours::GetRGBA(v9, &HudColour, 3u);
  CFont::SetColor((CRGBA)v9);
  CFont::SetEdge(2);
  CRGBA::CRGBA(&v8, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v0);
  if ( CGarages::MessageNumberInString2 < 0 )
  {
    if ( CGarages::MessageNumberInString < 0 )
    {
      screenWidth = RsGlobal.screenWidth;
      v7 = (float)RsGlobal.screenHeight / 448.0;
      v3 = CText::Get(&TheText, CGarages::MessageIDString);
      v5 = v7 * 155.0;
      v4 = (float)(screenWidth / 2);
      goto LABEL_9;
    }
    v2 = CText::Get(&TheText, CGarages::MessageIDString);
    CMessages::InsertNumberInString(v2, CGarages::MessageNumberInString, -1, -1, -1, -1, -1, gGxtString);
  }
  else
  {
    v1 = CText::Get(&TheText, CGarages::MessageIDString);
    CMessages::InsertNumberInString(
      v1,
      CGarages::MessageNumberInString,
      CGarages::MessageNumberInString2,
      -1,
      -1,
      -1,
      -1,
      gGxtString);
  }
  v3 = gGxtString;
  v4 = (float)(RsGlobal.screenWidth / 2);
  v5 = (float)((float)RsGlobal.screenHeight / 448.0) * 155.0;
LABEL_9:
  CFont::PrintString(v4, v5, v3);
}
// 31364A: variable 'v0' is possibly undefined

//----- (003137DC) --------------------------------------------------------
void __fastcall CGarage::BuildRotatedDoorMatrix(CEntity *pDoor, float RotationAmount)
{
  float v3; // r5
  float v4; // r6
  float v5; // s16
  CMatrix *m_pMat; // r0
  float v7; // s20
  float xy; // s0
  CMatrix *v9; // r0
  RwReal x; // r5
  CMatrix *v11; // r0
  RwReal y; // r5
  CMatrix *v13; // r0
  RwReal z; // r5
  CMatrix *v15; // r0
  RwReal v16; // r5
  CMatrix *v17; // r0
  RwReal v18; // r5
  CMatrix *v19; // r0
  RwReal v20; // r5
  CVector v21; // [sp+0h] [bp-40h] BYREF
  CVector v2; // [sp+Ch] [bp-34h] BYREF

  v3 = RotationAmount * -1.5708;
  v4 = sinf(RotationAmount * -1.5708);
  v5 = cosf(v3);
  m_pMat = pDoor->m_pMat;
  if ( m_pMat )
  {
    v7 = -(float)(v4 * m_pMat->yy);
  }
  else
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    m_pMat = pDoor->m_pMat;
    v7 = -(float)(v4 * m_pMat->yy);
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pDoor);
      CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
      m_pMat = pDoor->m_pMat;
    }
  }
  xy = m_pMat->xy;
  v2.x = v7;
  v2.z = v5;
  v2.y = v4 * xy;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    m_pMat = pDoor->m_pMat;
  }
  CrossProduct(&v21, (const CVector *)&m_pMat->xy, &v2);
  v9 = pDoor->m_pMat;
  x = v21.x;
  if ( !v9 )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    v9 = pDoor->m_pMat;
  }
  v9->xx = x;
  v11 = pDoor->m_pMat;
  y = v21.y;
  if ( !v11 )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    v11 = pDoor->m_pMat;
  }
  v11->yx = y;
  v13 = pDoor->m_pMat;
  z = v21.z;
  if ( !v13 )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    v13 = pDoor->m_pMat;
  }
  v13->zx = z;
  v15 = pDoor->m_pMat;
  v16 = v2.x;
  if ( !v15 )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    v15 = pDoor->m_pMat;
  }
  v15->xz = v16;
  v17 = pDoor->m_pMat;
  v18 = v2.y;
  if ( !v17 )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    v17 = pDoor->m_pMat;
  }
  v17->yz = v18;
  v19 = pDoor->m_pMat;
  v20 = v2.z;
  if ( !v19 )
  {
    CPlaceable::AllocateMatrix(pDoor);
    CSimpleTransform::UpdateMatrix(&pDoor->m_transform, pDoor->m_pMat);
    v19 = pDoor->m_pMat;
  }
  v19->zz = v20;
}

//----- (00313924) --------------------------------------------------------
void __fastcall CGarages::SetTargetCarForMissionGarage(Int16 NumGarage, CAutomobile *pCar)
{
  CAutomobile **p_pCarToCollect; // r2
  CGarage *v4; // r0
  UInt8 *p_State; // r0
  int State; // t1

  p_pCarToCollect = &CGarages::aGarages[NumGarage].pCarToCollect;
  if ( pCar )
  {
    *p_pCarToCollect = pCar;
    CEntity::RegisterReference(pCar, p_pCarToCollect);
    v4 = &CGarages::aGarages[NumGarage];
    State = v4->State;
    p_State = &v4->State;
    if ( State == 5 )
      *p_State = 0;
  }
  else
  {
    *p_pCarToCollect = 0;
  }
}

//----- (00313970) --------------------------------------------------------
bool __fastcall CGarages::HasCarBeenDroppedOffYet(Int16 NumGarage)
{
  return CGarages::aGarages[NumGarage].State == 5;
}

//----- (00313990) --------------------------------------------------------
void __fastcall CGarages::DeActivateGarage(Int16 NumGarage)
{
  *(_BYTE *)&CGarages::aGarages[NumGarage].Flags |= 2u;
}

//----- (003139B0) --------------------------------------------------------
void __fastcall CGarages::ActivateGarage(Int16 NumGarage)
{
  CGarage *v1; // r2
  int Type; // r3
  CGarage *v3; // r0
  UInt8 *p_State; // r0
  int State; // t1

  v1 = &CGarages::aGarages[NumGarage];
  Type = v1->Type;
  *(_BYTE *)&v1->Flags &= ~2u;
  if ( Type == 11 )
  {
    v3 = &CGarages::aGarages[NumGarage];
    State = v3->State;
    p_State = &v3->State;
    if ( !State )
      *p_State = 3;
  }
}

//----- (003139F4) --------------------------------------------------------
bool __fastcall CGarages::IsGarageOpen(Int16 NumGarage)
{
  int State; // r1

  State = CGarages::aGarages[NumGarage].State;
  return State == 1 || State == 4;
}

//----- (00313A1C) --------------------------------------------------------
bool __fastcall CGarages::IsGarageClosed(Int16 NumGarage)
{
  return CGarages::aGarages[NumGarage].State == 0;
}

//----- (00313A3C) --------------------------------------------------------
void __fastcall CGarage::OpenThisGarage(CGarage *this)
{
  unsigned int State; // r1

  State = this->State;
  if ( State <= 5 && ((1 << State) & 0x25) != 0 )
    this->State = 3;
}

//----- (00313A5A) --------------------------------------------------------
void __fastcall CGarage::CloseThisGarage(CGarage *this)
{
  if ( (this->State | 2) == 3 )
    this->State = 2;
}

//----- (00313A70) --------------------------------------------------------
bool __fastcall CGarages::HasResprayHappened(Int16 NumGarage)
{
  CGarage *v1; // r0
  unsigned int Flags; // r1

  v1 = &CGarages::aGarages[NumGarage];
  Flags = (unsigned __int8)v1->Flags;
  v1->Flags = (CGarageFlags)(Flags & 0xFB);
  return (Flags >> 2) & 1;
}

//----- (00313A94) --------------------------------------------------------
bool __fastcall CGarages::IsThisCarWithinGarageArea(Int16 NumGarage, CEntity *pEntity)
{
  return CGarage::IsEntityEntirelyInside3D(&CGarages::aGarages[NumGarage], pEntity, 0.0);
}

//----- (00313AAC) --------------------------------------------------------
void __fastcall CStoredCar::StoreCar(CStoredCar *this, CVehicle *pCar)
{
  UInt16 m_nModelIndex; // r0
  CSimpleTransform *p_m_transform; // r1
  CMatrix *m_pMat; // r0
  float *p_x; // r2
  float v8; // r0
  CSimpleTransform *p_tx; // r2
  CMatrix *v10; // r0
  CMatrix *v11; // r0
  int8 m_comp2; // r0
  int v13; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  uint32 hFlagsLocal; // r1
  int32 m_baseVehicleType; // r0
  bool v17; // zf

  m_nModelIndex = pCar->m_nModelIndex;
  p_m_transform = &pCar->m_transform;
  this->ModelIndex = m_nModelIndex;
  m_pMat = pCar->m_pMat;
  p_x = &p_m_transform->m_translate.x;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  v8 = *p_x;
  p_tx = p_m_transform;
  this->CoorX = v8;
  v10 = pCar->m_pMat;
  if ( v10 )
    p_tx = (CSimpleTransform *)&v10->tx;
  this->CoorY = p_tx->m_translate.y;
  v11 = pCar->m_pMat;
  if ( v11 )
    p_m_transform = (CSimpleTransform *)&v11->tx;
  this->CoorZ = p_m_transform->m_translate.z;
  this->iFrontX = (int)(float)(pCar->m_pMat->xy * 100.0);
  this->iFrontY = (int)(float)(pCar->m_pMat->yy * 100.0);
  this->iFrontZ = (int)(float)(pCar->m_pMat->zy * 100.0);
  this->Colour1 = pCar->m_colour1;
  this->Colour2 = pCar->m_colour2;
  this->Colour3 = pCar->m_colour3;
  this->Colour4 = pCar->m_colour4;
  this->RadioStation = pCar->m_VehicleAudioEntity.m_VehicleAudioSetting.RadioStation;
  this->FlagsLocal = pCar->hFlagsLocal;
  this->Comp1 = pCar->m_comp1;
  m_comp2 = pCar->m_comp2;
  this->Bits = 0;
  this->Comp2 = m_comp2;
  v13 = (*(_DWORD *)&pCar->m_nPhysicalFlags >> 18) & 1;
  this->Bits = v13;
  m_nPhysicalFlags = pCar->m_nPhysicalFlags;
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x80000) != 0 )
  {
    LOWORD(v13) = v13 | 2;
    this->Bits = v13;
    m_nPhysicalFlags = pCar->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x800000) != 0 )
  {
    LOWORD(v13) = v13 | 4;
    this->Bits = v13;
    m_nPhysicalFlags = pCar->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x100000) != 0 )
  {
    LOWORD(v13) = v13 | 8;
    this->Bits = v13;
    m_nPhysicalFlags = pCar->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x200000) != 0 )
  {
    LOWORD(v13) = v13 | 0x10;
    this->Bits = v13;
  }
  if ( (*((_BYTE *)&pCar->m_nVehicleFlags + 6) & 0x10) != 0 )
  {
    LOWORD(v13) = v13 | 0x20;
    this->Bits = v13;
  }
  hFlagsLocal = pCar->hFlagsLocal;
  if ( (hFlagsLocal & 0x20000) != 0 )
  {
    LOWORD(v13) = v13 | 0x40;
    this->Bits = v13;
    hFlagsLocal = pCar->hFlagsLocal;
  }
  if ( (hFlagsLocal & 0x80000) != 0 )
    this->Bits = v13 | 0x80;
  m_baseVehicleType = pCar->m_baseVehicleType;
  v17 = m_baseVehicleType == 0;
  if ( m_baseVehicleType )
    v17 = m_baseVehicleType == 9;
  if ( v17 )
    this->BombOnBoard = *((_BYTE *)pCar + 1202) & 7;
  this->CarMods[0] = pCar->m_upgrades[0];
  this->CarMods[1] = pCar->m_upgrades[1];
  this->CarMods[2] = pCar->m_upgrades[2];
  this->CarMods[3] = pCar->m_upgrades[3];
  this->CarMods[4] = pCar->m_upgrades[4];
  this->CarMods[5] = pCar->m_upgrades[5];
  this->CarMods[6] = pCar->m_upgrades[6];
  this->CarMods[7] = pCar->m_upgrades[7];
  this->CarMods[8] = pCar->m_upgrades[8];
  this->CarMods[9] = pCar->m_upgrades[9];
  this->CarMods[10] = pCar->m_upgrades[10];
  this->CarMods[11] = pCar->m_upgrades[11];
  this->CarMods[12] = pCar->m_upgrades[12];
  this->CarMods[13] = pCar->m_upgrades[13];
  this->CarMods[14] = pCar->m_upgrades[14];
  this->PaintJob = CVehicle::GetRemapIndex(pCar);
  this->m_nNitroBoosts = pCar->m_nNitroBoosts;
}

//----- (00313C60) --------------------------------------------------------
CVehicle *__fastcall CStoredCar::RestoreCar(CStoredCar *this)
{
  int i; // r4
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  char *v19; // r5
  __int64 v21; // kr00_8
  int v22; // r3
  float CoorZ; // r0
  float *v24; // r1
  float v25; // s0
  float v26; // s4
  float v27; // s2
  int v28; // r0
  int v29; // r3
  int v30; // r1
  unsigned int v31; // r2
  UInt32 FlagsLocal; // r0
  UInt16 Bits; // r3
  unsigned int *v34; // r6
  __int64 v35; // r0

  CStreaming::RequestModel(this->ModelIndex, 8);
  for ( i = 0; i != 15; ++i )
  {
    v3 = (unsigned __int16)this->CarMods[i];
    if ( v3 != 0xFFFF )
      CStreaming::RequestVehicleUpgrade((__int16)v3, 0);
  }
  if ( CStreaming::ms_aInfoForModel[this->ModelIndex].m_status != 1 )
    return 0;
  v4 = (unsigned __int16)this->CarMods[0];
  if ( v4 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v4) )
    return 0;
  v5 = (unsigned __int16)this->CarMods[1];
  if ( v5 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v5) )
    return 0;
  v6 = (unsigned __int16)this->CarMods[2];
  if ( v6 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v6) )
    return 0;
  v7 = (unsigned __int16)this->CarMods[3];
  if ( v7 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v7) )
    return 0;
  v8 = (unsigned __int16)this->CarMods[4];
  if ( v8 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v8) )
    return 0;
  v9 = (unsigned __int16)this->CarMods[5];
  if ( v9 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v9) )
    return 0;
  v10 = (unsigned __int16)this->CarMods[6];
  if ( v10 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v10) )
    return 0;
  v11 = (unsigned __int16)this->CarMods[7];
  if ( v11 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v11) )
    return 0;
  v12 = (unsigned __int16)this->CarMods[8];
  if ( v12 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v12) )
    return 0;
  v13 = (unsigned __int16)this->CarMods[9];
  if ( v13 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v13) )
    return 0;
  v14 = (unsigned __int16)this->CarMods[10];
  if ( v14 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v14) )
    return 0;
  v15 = (unsigned __int16)this->CarMods[11];
  if ( v15 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v15) )
    return 0;
  v16 = (unsigned __int16)this->CarMods[12];
  if ( v16 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v16) )
    return 0;
  v17 = (unsigned __int16)this->CarMods[13];
  if ( v17 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v17) )
    return 0;
  v18 = (unsigned __int16)this->CarMods[14];
  if ( v18 != 0xFFFF && !CStreaming::HasVehicleUpgradeLoaded((__int16)v18) )
    return 0;
  *(_WORD *)CVehicleModelInfo::ms_compsToUse = *(_WORD *)&this->Comp1;
  switch ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[this->ModelIndex][1].m_modelName[20] )
  {
    case 1:
      v19 = (char *)CVehicle::operator new(0x9B0u);
      CMonsterTruck::CMonsterTruck((CMonsterTruck *)v19, this->ModelIndex, 1u);
      break;
    case 2:
      v19 = (char *)CVehicle::operator new(0x9D0u);
      CQuadBike::CQuadBike((CQuadBike *)v19, this->ModelIndex, 1u);
      break;
    case 3:
      v19 = (char *)CVehicle::operator new(0xA2Cu);
      CHeli::CHeli((CHeli *)v19, this->ModelIndex, 1u);
      break;
    case 4:
      v19 = (char *)CVehicle::operator new(0xA18u);
      CPlane::CPlane((CPlane *)v19, this->ModelIndex, 1u);
      break;
    case 5:
      v19 = (char *)CVehicle::operator new(0x7FCu);
      CBoat::CBoat((CBoat *)v19, this->ModelIndex, 1u);
      break;
    case 9:
      v19 = (char *)CVehicle::operator new(0x828u);
      CBike::CBike((CBike *)v19, this->ModelIndex, 1u);
      goto LABEL_47;
    case 0xA:
      v19 = (char *)CVehicle::operator new(0x84Cu);
      CBmx::CBmx((CBmx *)v19, this->ModelIndex, 1u);
LABEL_47:
      v19[1576] |= 0x10u;
      break;
    case 0xB:
      v19 = (char *)CVehicle::operator new(0xA08u);
      CTrailer::CTrailer((CTrailer *)v19, this->ModelIndex, 1u);
      break;
    default:
      v19 = (char *)CVehicle::operator new(0x99Cu);
      CAutomobile::CAutomobile((CAutomobile *)v19, this->ModelIndex, 1u, 1u);
      break;
  }
  v21 = *(_QWORD *)&this->CoorX;
  v22 = *((_DWORD *)v19 + 5);
  CoorZ = this->CoorZ;
  if ( v22 )
  {
    *(_DWORD *)(v22 + 48) = v21;
    *(_DWORD *)(*((_DWORD *)v19 + 5) + 52) = HIDWORD(v21);
    v24 = (float *)(*((_DWORD *)v19 + 5) + 56);
  }
  else
  {
    *(_QWORD *)(v19 + 4) = v21;
    v24 = (float *)(v19 + 12);
  }
  *v24 = CoorZ;
  v25 = (float)this->iFrontX / 100.0;
  v26 = (float)this->iFrontY / 100.0;
  v27 = (float)this->iFrontZ / 100.0;
  *(float *)(*((_DWORD *)v19 + 5) + 16) = v25;
  *(float *)(*((_DWORD *)v19 + 5) + 20) = v26;
  *(float *)(*((_DWORD *)v19 + 5) + 24) = v27;
  **((float **)v19 + 5) = v26;
  *(float *)(*((_DWORD *)v19 + 5) + 4) = -v25;
  *(_DWORD *)(*((_DWORD *)v19 + 5) + 8) = 0;
  v28 = *((_DWORD *)v19 + 5);
  v19[58] = v19[58] & 7 | 0x20;
  *(_DWORD *)(v28 + 32) = 0;
  *(_DWORD *)(*((_DWORD *)v19 + 5) + 36) = 0;
  *(_DWORD *)(*((_DWORD *)v19 + 5) + 40) = 1065353216;
  *((_DWORD *)v19 + 281) = 0;
  v29 = *((_DWORD *)v19 + 360);
  v30 = *((_DWORD *)v19 + 268);
  v31 = *((_DWORD *)v19 + 267) & 0xFFFDFF7F | 0x20000;
  v19[470] = this->RadioStation;
  FlagsLocal = this->FlagsLocal;
  *((_DWORD *)v19 + 228) = FlagsLocal;
  *((_DWORD *)v19 + 267) = v31;
  *((_DWORD *)v19 + 322) = 1;
  if ( !v29 )
    v19[1202] = this->BombOnBoard & 7 | v19[1202] & 0xF8;
  Bits = this->Bits;
  if ( (Bits & 1) != 0 )
  {
    *((_DWORD *)v19 + 17) |= 0x40000u;
    Bits = this->Bits;
  }
  if ( (Bits & 2) != 0 )
  {
    *((_DWORD *)v19 + 17) |= 0x80000u;
    Bits = this->Bits;
  }
  if ( (Bits & 4) != 0 )
  {
    *((_DWORD *)v19 + 17) |= 0x800000u;
    Bits = this->Bits;
  }
  if ( (Bits & 8) != 0 )
  {
    *((_DWORD *)v19 + 17) |= 0x100000u;
    Bits = this->Bits;
  }
  v34 = (unsigned int *)(v19 + 1068);
  if ( (Bits & 0x10) != 0 )
  {
    *((_DWORD *)v19 + 17) |= 0x200000u;
    Bits = this->Bits;
  }
  if ( (Bits & 0x20) != 0 )
  {
    *v34 = v31;
    *((_DWORD *)v19 + 268) = v30 | 0x100000;
    v19[450] = 1;
    Bits = this->Bits;
  }
  if ( (Bits & 0x40) != 0 )
  {
    FlagsLocal |= 0x20000u;
    *((_DWORD *)v19 + 228) = FlagsLocal;
    Bits = this->Bits;
  }
  if ( (Bits & 0x80) != 0 )
    *((_DWORD *)v19 + 228) = FlagsLocal | 0x80000;
  *((_WORD *)v19 + 543) = this->CarMods[0];
  *((_WORD *)v19 + 544) = this->CarMods[1];
  *((_WORD *)v19 + 545) = this->CarMods[2];
  *((_WORD *)v19 + 546) = this->CarMods[3];
  *((_WORD *)v19 + 547) = this->CarMods[4];
  *((_WORD *)v19 + 548) = this->CarMods[5];
  *((_WORD *)v19 + 549) = this->CarMods[6];
  *((_WORD *)v19 + 550) = this->CarMods[7];
  *((_WORD *)v19 + 551) = this->CarMods[8];
  *((_WORD *)v19 + 552) = this->CarMods[9];
  *((_WORD *)v19 + 553) = this->CarMods[10];
  *((_WORD *)v19 + 554) = this->CarMods[11];
  *((_WORD *)v19 + 555) = this->CarMods[12];
  *((_WORD *)v19 + 556) = this->CarMods[13];
  *((_WORD *)v19 + 557) = this->CarMods[14];
  CVehicle::SetupUpgradesAfterLoad((CVehicle *)v19);
  CVehicle::SetRemap((CVehicle *)v19, this->PaintJob);
  HIDWORD(v35) = *((_DWORD *)v19 + 268) | 0x4000000;
  LODWORD(v35) = *v34 & 0xFFFFFFEF;
  *v34 = v35;
  v19[1166] = this->m_nNitroBoosts;
  v19[1080] = this->Colour1;
  v19[1081] = this->Colour2;
  v19[1082] = this->Colour3;
  v19[1083] = this->Colour4;
  *(_QWORD *)v34 = v35;
  return (CVehicle *)v19;
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (0031412C) --------------------------------------------------------
int __fastcall CGarages::IsPointInAGarageCameraZone(CVector Coors)
{
  float x; // s2
  float y; // s0
  float v4; // s10
  float v5; // s12
  float v6; // s14
  float v7; // s10

  x = Coors.x;
  y = Coors.y;
  Coors.y = NAN;
  LODWORD(Coors.x) = CGarages::aGarages;
  while ( 1 )
  {
    if ( ((unsigned int)*(unsigned __int8 *)(LODWORD(Coors.x) + 76) - 8 < 3 || *(_BYTE *)(LODWORD(Coors.x) + 76))
      && (float)(*(float *)(LODWORD(Coors.x) + 8) + -0.5) <= Coors.z
      && (float)(*(float *)(LODWORD(Coors.x) + 28) + 0.5) >= Coors.z )
    {
      v4 = x - *(float *)LODWORD(Coors.x);
      v5 = y - *(float *)(LODWORD(Coors.x) + 4);
      v6 = (float)(v4 * *(float *)(LODWORD(Coors.x) + 12)) + (float)(v5 * *(float *)(LODWORD(Coors.x) + 16));
      if ( v6 >= -0.5 && v6 <= (float)(*(float *)(LODWORD(Coors.x) + 32) + 0.5) )
      {
        v7 = (float)(v4 * *(float *)(LODWORD(Coors.x) + 20)) + (float)(v5 * *(float *)(LODWORD(Coors.x) + 24));
        if ( v7 >= -0.5 && v7 <= (float)(*(float *)(LODWORD(Coors.x) + 36) + 0.5) )
          break;
      }
    }
    ++LODWORD(Coors.y);
    LODWORD(Coors.x) += 216;
    if ( SLODWORD(Coors.y) >= 49 )
      return 0;
  }
  return 1;
}

//----- (00314208) --------------------------------------------------------
bool CGarages::CameraShouldBeOutside()
{
  return CGarages::bCamShouldBeOutside;
}

//----- (00314218) --------------------------------------------------------
float __fastcall CGarages::FindDoorHeightForMI(UInt32 MI)
{
  CColModel *m_pColModel; // r0

  m_pColModel = CModelInfo::ms_modelInfoPtrs[MI]->m_pColModel;
  return (float)(m_pColModel->m_boxBound.m_vecMax.z - m_pColModel->m_boxBound.m_vecMin.z) + -0.1;
}

//----- (00314248) --------------------------------------------------------
void CGarages::PlayerArrestedOrDied()
{
  int v0; // r1
  UInt8 *p_State; // r0
  unsigned int v2; // r3

  v0 = 50;
  p_State = &CGarages::aGarages[0].State;
  do
  {
    switch ( *(p_State - 1) )
    {
      case 1u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
        if ( (unsigned int)*p_State - 1 <= 2 )
          *p_State = 2;
        break;
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 0xDu:
        v2 = *p_State;
        if ( v2 <= 3 && v2 != 1 )
          *p_State = 3;
        break;
      default:
        break;
    }
    p_State += 216;
    --v0;
  }
  while ( v0 );
  CGarages::MessageStartTime = 0;
  CGarages::MessageEndTime = 0;
}

//----- (003142E0) --------------------------------------------------------
void __fastcall CGarage::PlayerArrestedOrDied(CGarage *this)
{
  UInt8 v1; // r1
  unsigned int State; // r1

  switch ( this->Type )
  {
    case 1u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
    case 0x27u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
      if ( (unsigned int)this->State - 1 <= 2 )
      {
        v1 = 2;
        goto LABEL_4;
      }
      break;
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 0xDu:
      State = this->State;
      if ( State <= 3 && State != 1 )
      {
        v1 = 3;
LABEL_4:
        this->State = v1;
      }
      break;
    default:
      return;
  }
}

//----- (00314340) --------------------------------------------------------
void __fastcall CGarage::CenterCarInGarage(CGarage *this, CVehicle *pVehicle)
{
  CVehicle *PlayerVehicle; // r0
  CPlayerPed *PlayerPed; // r0
  CMatrix *m_pMat; // r1
  float v7; // s4
  float *p_tx; // r0
  bool v9; // zf
  CSimpleTransform *p_m_transform; // r1
  float v11; // s2
  __int64 v12; // kr00_8
  RwReal z; // r8
  float v14; // s0
  float v15; // s6
  float v16; // s4
  float v17; // s8
  CMatrix *v18; // r0
  CMatrix *v19; // r0
  float *p_tz; // r0

  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( !CGarage::IsAnyOtherCarTouchingGarage(this, PlayerVehicle) )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( !CGarage::IsAnyOtherPedTouchingGarage(this, PlayerPed) )
    {
      m_pMat = pVehicle->m_pMat;
      v7 = this->MinY + this->MaxY;
      p_tx = &m_pMat->tx;
      v9 = m_pMat == 0;
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
      if ( v9 )
        p_m_transform = &pVehicle->m_transform;
      v11 = (float)(this->MinX + this->MaxX) * 0.5;
      v12 = *(_QWORD *)&p_m_transform->m_translate.x;
      z = p_m_transform->m_translate.z;
      v14 = v7 * 0.5;
      v15 = v11 - p_m_transform->m_translate.x;
      v16 = (float)(v7 * 0.5) - p_m_transform->m_translate.y;
      v17 = sqrtf((float)((float)(v15 * v15) + (float)(v16 * v16)) + 0.0);
      if ( v17 >= 0.4 )
      {
        *p_tx = (float)(v15 * (float)(0.4 / v17)) + *p_tx;
        v18 = pVehicle->m_pMat;
        v14 = (float)(v16 * (float)(0.4 / v17)) + v18->ty;
      }
      else
      {
        *p_tx = v11;
        v18 = pVehicle->m_pMat;
      }
      v18->ty = v14;
      if ( !CGarage::IsEntityEntirelyInside3D(this, pVehicle, 0.3) )
      {
        v19 = pVehicle->m_pMat;
        if ( v19 )
        {
          LODWORD(v19->tx) = v12;
          pVehicle->m_pMat->ty = *((float *)&v12 + 1);
          p_tz = &pVehicle->m_pMat->tz;
        }
        else
        {
          p_tz = &pVehicle->m_transform.m_translate.z;
          *(_QWORD *)&pVehicle->m_transform.m_translate.x = v12;
        }
        *p_tz = z;
      }
    }
  }
}

//----- (00314454) --------------------------------------------------------
void CGarages::CloseHideOutGaragesBeforeSave()
{
  int v0; // r5
  CGarage *v1; // r4
  int Type; // r0
  int v3; // r1
  bool v4; // zf
  unsigned __int8 v5; // r0
  int v6; // r1

  v0 = 50;
  v1 = CGarages::aGarages;
  do
  {
    Type = v1->Type;
    if ( (unsigned int)(Type - 16) <= 0x1D )
    {
      v3 = 1 << (Type - 16);
      v4 = (v3 & 0x2781FF07) == 0;
      if ( (v3 & 0x2781FF07) != 0 )
        v4 = v1->State == 0;
      if ( !v4 )
      {
        v5 = Type - 17;
        v6 = 0;
        v1->State = 0;
        if ( v5 <= 0x1Cu )
          v6 = dword_60FBD0[(char)v5];
        CGarage::StoreAndRemoveCarsForThisHideOut(v1, CGarages::aCarsInSafeHouse[v6], 4);
        CGarage::RemoveCarsBlockingDoorNotInside(v1);
        v1->Openness = 0.0;
      }
    }
    ++v1;
    --v0;
  }
  while ( v0 );
}
// 60FBD0: using guessed type _DWORD dword_60FBD0[29];

//----- (003144E4) --------------------------------------------------------
void __fastcall CGarages::StopCarFromBlowingUp(CAutomobile *pCar)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  CDamageManager *p_Damage; // r4
  uint32 EngineStatus; // r1

  v1.n64_u32[0] = 1133903872;
  p_Damage = &pCar->Damage;
  v2.n64_u32[0] = LODWORD(pCar->m_nHealth);
  pCar->m_BlowUpTimer = 0.0;
  LODWORD(pCar->m_nHealth) = vmax_f32(v2, v1).n64_u32[0];
  if ( CDamageManager::GetEngineStatus(&pCar->Damage) > 0x112 )
    EngineStatus = CDamageManager::GetEngineStatus(p_Damage);
  else
    EngineStatus = 275;
  sub_1918B8(p_Damage, EngineStatus);
}
// 314500: variable 'v2' is possibly undefined
// 314500: variable 'v1' is possibly undefined

//----- (00314530) --------------------------------------------------------
bool __fastcall CGarages::IsPointWithinHideOutGarage(CVector *Point)
{
  float x; // s0
  float y; // s2
  float z; // s4
  UInt8 *p_Type; // r0
  int v5; // r1
  unsigned int v7; // r2
  float v8; // s6
  float v9; // s8
  float v10; // s10
  float v11; // s6

  x = Point->x;
  y = Point->y;
  z = Point->z;
  p_Type = &CGarages::aGarages[0].Type;
  v5 = -1;
  while ( 1 )
  {
    v7 = *p_Type - 16;
    if ( v7 <= 0x1D && ((1 << v7) & 0x2781FF07) != 0 && *((float *)p_Type - 17) <= z && *((float *)p_Type - 12) >= z )
    {
      v8 = x - *((float *)p_Type - 19);
      v9 = y - *((float *)p_Type - 18);
      v10 = (float)(v8 * *((float *)p_Type - 16)) + (float)(v9 * *((float *)p_Type - 15));
      if ( v10 >= 0.0 && v10 <= *((float *)p_Type - 11) )
      {
        v11 = (float)(v8 * *((float *)p_Type - 14)) + (float)(v9 * *((float *)p_Type - 13));
        if ( v11 >= 0.0 && v11 <= *((float *)p_Type - 10) )
          break;
      }
    }
    ++v5;
    p_Type += 216;
    if ( v5 >= 49 )
      return 0;
  }
  return 1;
}

//----- (00314604) --------------------------------------------------------
bool __fastcall CGarages::IsPointWithinAnyGarage(CVector *Point)
{
  float x; // s0
  float y; // s2
  float z; // s4
  UInt8 *p_Type; // r0
  int v5; // r1
  float v7; // s6
  float v8; // s8
  float v9; // s10
  float v10; // s6

  x = Point->x;
  y = Point->y;
  z = Point->z;
  p_Type = &CGarages::aGarages[0].Type;
  v5 = -1;
  while ( 1 )
  {
    if ( *p_Type )
    {
      if ( *((float *)p_Type - 17) <= z && *((float *)p_Type - 12) >= z )
      {
        v7 = x - *((float *)p_Type - 19);
        v8 = y - *((float *)p_Type - 18);
        v9 = (float)(v7 * *((float *)p_Type - 16)) + (float)(v8 * *((float *)p_Type - 15));
        if ( v9 >= 0.0 && v9 <= *((float *)p_Type - 11) )
        {
          v10 = (float)(v7 * *((float *)p_Type - 14)) + (float)(v8 * *((float *)p_Type - 13));
          if ( v10 >= 0.0 && v10 <= *((float *)p_Type - 10) )
            break;
        }
      }
    }
    ++v5;
    p_Type += 216;
    if ( v5 >= 49 )
      return 0;
  }
  return 1;
}

//----- (003146C0) --------------------------------------------------------
Int32 __fastcall CGarages::FindGarageForObject(CObject *pObject)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d8
  CMatrix *m_pMat; // r12
  CSimpleTransform *p_tx; // lr
  CGarage *v5; // r3
  unsigned int v6; // r2
  float x; // s0
  Int32 result; // r0
  float y; // s4
  float z; // s6
  float BaseZ; // s1
  float BaseY; // s7
  float v13; // s18
  float Delta1X; // s9
  float Delta1Y; // s11
  float v16; // s13
  float Delta1Length; // s15
  float Delta2X; // s13
  float v19; // s18
  float Delta2Length; // s20
  float v21; // s15
  bool v22; // nf

  if ( !CGarages::NumGarages )
    return -1;
  m_pMat = pObject->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pObject->m_transform;
  v5 = CGarages::aGarages;
  v1.n64_u32[0] = 1203982323;
  v6 = 0;
  x = p_tx->m_translate.x;
  result = -1;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  do
  {
    BaseZ = v5->BaseZ;
    if ( (float)(BaseZ + -7.0) <= z && (float)(v5->CeilingZ + 7.0) >= z )
    {
      BaseY = v5->BaseY;
      v13 = x - v5->BaseX;
      Delta1X = v5->Delta1X;
      Delta1Y = v5->Delta1Y;
      v16 = (float)(v13 * Delta1X) + (float)((float)(y - BaseY) * Delta1Y);
      if ( v16 >= -7.0 )
      {
        Delta1Length = v5->Delta1Length;
        if ( v16 <= (float)(Delta1Length + 7.0) )
        {
          Delta2X = v5->Delta2X;
          v2.n64_u32[0] = LODWORD(v5->Delta2Y);
          v19 = (float)(v13 * Delta2X) + (float)((float)(y - BaseY) * v2.n64_f32[0]);
          if ( v19 >= -7.0 )
          {
            Delta2Length = v5->Delta2Length;
            if ( v19 <= (float)(Delta2Length + 7.0) )
            {
              v21 = Delta1Length * 0.5;
              v2.n64_f32[0] = sqrtf(
                                (float)((float)((float)(x
                                                      - (float)((float)(v5->BaseX + (float)(Delta1X * v21))
                                                              + (float)(Delta2X * (float)(Delta2Length * 0.5))))
                                              * (float)(x
                                                      - (float)((float)(v5->BaseX + (float)(Delta1X * v21))
                                                              + (float)(Delta2X * (float)(Delta2Length * 0.5)))))
                                      + (float)((float)(y
                                                      - (float)((float)(BaseY + (float)(Delta1Y * v21))
                                                              + (float)(v2.n64_f32[0] * (float)(Delta2Length * 0.5))))
                                              * (float)(y
                                                      - (float)((float)(BaseY + (float)(Delta1Y * v21))
                                                              + (float)(v2.n64_f32[0] * (float)(Delta2Length * 0.5))))))
                              + (float)((float)(z
                                              - (float)((float)(BaseZ + (float)(v21 * 0.0))
                                                      + (float)((float)(Delta2Length * 0.5) * 0.0)))
                                      * (float)(z
                                              - (float)((float)(BaseZ + (float)(v21 * 0.0))
                                                      + (float)((float)(Delta2Length * 0.5) * 0.0)))));
              v22 = v2.n64_f32[0] < v1.n64_f32[0];
              v1.n64_u64[0] = vmin_f32(v2, v1).n64_u64[0];
              if ( v22 )
                result = v6;
            }
          }
        }
      }
    }
    ++v6;
    ++v5;
  }
  while ( v6 < CGarages::NumGarages );
  return result;
}
// 31480C: variable 'v2' is possibly undefined
// 31480C: variable 'v1' is possibly undefined

//----- (00314844) --------------------------------------------------------
void __fastcall CGarages::StoreCarInNearestImpoundingGarage(CVehicle *pVeh)
{
  float32x2_t v1; // d0
  UInt32 v3; // r3
  int v4; // r2
  float32x2_t *v5; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r4
  float32x2_t v8; // d16
  float32x2_t v9; // d1
  bool v10; // nf
  unsigned __int8 v11; // r0
  int v12; // r0
  CStoredCar *v13; // r2
  int v14; // r1
  CStoredCar *v15; // r1
  __int64 v16; // d17
  __int64 v17; // d24
  __int64 v18; // d25
  __int64 v19; // d28
  __int64 v20; // d29
  __int64 v21; // d18
  __int64 v22; // d19
  __int64 v23; // d20
  __int64 v24; // d21
  __int64 v25; // d22
  __int64 v26; // d23
  __int64 v27; // d26
  __int64 v28; // d27
  __int64 v29; // d30
  __int64 v30; // d31

  if ( CGarages::NumGarages )
  {
    v3 = 0;
    v1.n64_u32[0] = 1203982323;
    v4 = -1;
    v5 = (float32x2_t *)CGarages::aGarages;
    do
    {
      if ( (unsigned int)v5[9].n64_u8[4] - 33 <= 2 )
      {
        m_pMat = pVeh->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pVeh->m_transform;
        v8.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)v5->n64_u64[0]).n64_u64[0];
        v9.n64_u64[0] = vmul_f32(v8, v8).n64_u64[0];
        v9.n64_f32[0] = sqrtf(v9.n64_f32[0] + v9.n64_f32[1]);
        v10 = v9.n64_f32[0] < v1.n64_f32[0];
        v1.n64_u64[0] = vmin_f32(v9, v1).n64_u64[0];
        if ( v10 )
          v4 = v3;
      }
      ++v3;
      v5 += 27;
    }
    while ( v3 < CGarages::NumGarages );
    if ( v4 > -1 )
    {
      v11 = CGarages::aGarages[v4].Type - 17;
      if ( v11 > 0x1Cu )
        v12 = 0;
      else
        v12 = dword_60FBD0[(char)v11];
      v13 = CGarages::aCarsInSafeHouse[v12];
      v14 = v13[1].ModelIndex != 0;
      if ( v13->ModelIndex )
        ++v14;
      if ( v13[2].ModelIndex )
        ++v14;
      if ( v14 == 3 )
      {
        v15 = CGarages::aCarsInSafeHouse[v12];
        v16 = *(_QWORD *)&v15[2].CoorZ;
        v17 = *(_QWORD *)&v15[2].Bits;
        v18 = *(_QWORD *)&v15[2].CarMods[2];
        v19 = *(_QWORD *)&v15[2].CarMods[6];
        v20 = *(_QWORD *)&v15[2].CarMods[10];
        v21 = *(_QWORD *)&v15[1].CoorX;
        v22 = *(_QWORD *)&v15[1].CoorZ;
        v23 = *(_QWORD *)&v15[1].CarMods[14];
        v24 = *(_QWORD *)&v15[1].Comp2;
        v25 = *(_QWORD *)&v15[1].CarMods[6];
        v26 = *(_QWORD *)&v15[1].CarMods[10];
        v27 = *(_QWORD *)&v15[1].Bits;
        v28 = *(_QWORD *)&v15[1].CarMods[2];
        v29 = *(_QWORD *)&v15[2].CarMods[14];
        v30 = *(_QWORD *)&v15[2].Comp2;
        *(_QWORD *)&v15[1].CoorX = *(_QWORD *)&v15[2].CoorX;
        *(_QWORD *)&v15[1].CoorZ = v16;
        *(_QWORD *)&v15->CarMods[14] = v23;
        *(_QWORD *)&v15->Comp2 = v24;
        *(_QWORD *)&v15->CarMods[6] = v25;
        *(_QWORD *)&v15->CarMods[10] = v26;
        *(_QWORD *)&v15[1].Bits = v17;
        *(_QWORD *)&v15[1].CarMods[2] = v18;
        *(_QWORD *)&v15[1].CarMods[6] = v19;
        *(_QWORD *)&v15[1].CarMods[10] = v20;
        *(_QWORD *)&v15[1].CarMods[14] = v29;
        *(_QWORD *)&v15[1].Comp2 = v30;
        *(_QWORD *)&v15->CoorX = v21;
        *(_QWORD *)&v15->CoorZ = v22;
        v15 = (CStoredCar *)((char *)v15 + 16);
        *(_QWORD *)&v15->CoorX = v27;
        *(_QWORD *)&v15->CoorZ = v28;
        v14 = 2;
      }
      CStoredCar::StoreCar(&CGarages::aCarsInSafeHouse[v12][v14], pVeh);
    }
  }
}
// 3148A4: variable 'v1' is possibly undefined
// 60FBD0: using guessed type _DWORD dword_60FBD0[29];

//----- (003149C0) --------------------------------------------------------
void __fastcall CObject::ProcessGarageDoorBehaviour(CObject *this)
{
  int m_Garage; // lr
  Int8 GarageForObject; // r0
  CDummyObject *m_pRelatedDummy; // r3
  CMatrix *m_pMat; // r0
  CColModel *m_pColModel; // r1
  float *p_tx; // r2
  float v8; // s2
  float v9; // s0
  int Type; // r1
  float v11; // s0
  CGarage *v12; // r0
  float Openness; // s2
  __int64 v14; // kr00_8
  CMatrix *v15; // r0
  RwMatrix *v16; // r1

  m_Garage = this->m_Garage;
  if ( m_Garage > -1
    || (GarageForObject = CGarages::FindGarageForObject(this),
        LOWORD(m_Garage) = GarageForObject,
        this->m_Garage = GarageForObject,
        GarageForObject >= 0) )
  {
    m_pRelatedDummy = this->m_pRelatedDummy;
    m_pMat = m_pRelatedDummy->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pRelatedDummy->m_transform.m_translate.x;
    m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
    v8 = (float)(m_pColModel->m_boxBound.m_vecMax.z - m_pColModel->m_boxBound.m_vecMin.z) + -0.1;
    v9 = p_tx[2];
    if ( (*(_BYTE *)&CGarages::aGarages[(__int16)m_Garage].Flags & 8) != 0 )
    {
      this->m_pMat->tz = v9 + (float)((float)(v8 * CGarages::aGarages[(__int16)m_Garage].Openness) * 0.48);
      v12 = &CGarages::aGarages[this->m_Garage];
      Openness = -v12->Openness;
      if ( (*(_BYTE *)&v12->Flags & 0x10) == 0 )
        Openness = v12->Openness;
      CGarage::BuildRotatedDoorMatrix(this, Openness);
    }
    else
    {
      Type = CGarages::aGarages[(__int16)m_Garage].Type;
      if ( Type == 45 )
      {
        this->m_pMat->tx = *p_tx
                         + (float)((float)(CGarages::aGarages[(__int16)m_Garage].Openness * this->m_pMat->xx) * -14.0);
      }
      else
      {
        if ( Type == 44 )
          v11 = v9 - (float)(v8 * CGarages::aGarages[(__int16)m_Garage].Openness);
        else
          v11 = v9 + (float)((float)(v8 * CGarages::aGarages[(__int16)m_Garage].Openness) / 1.1);
        this->m_pMat->tz = v11;
      }
    }
    v14 = *(_QWORD *)&this->m_pRwObject;
    *(_DWORD *)&this->m_nFlags = HIDWORD(v14) & 0xFFFFFFFE | (*(_BYTE *)&CGarages::aGarages[this->m_Garage].Flags >> 6) & 1;
    if ( (_DWORD)v14 )
    {
      v15 = this->m_pMat;
      v16 = (RwMatrix *)(*(_DWORD *)(v14 + 4) + 16);
      if ( v15 )
        CMatrix::UpdateRwMatrix(v15, v16);
      else
        CSimpleTransform::UpdateRwMatrix(&this->m_transform, v16);
    }
    j_CEntity::UpdateRwFrame(this);
  }
}

//----- (00314B78) --------------------------------------------------------
bool __fastcall CGarages::IsModelIndexADoor(Int32 MI)
{
  CBaseModelInfo *v1; // r4
  bool result; // r0

  result = 0;
  if ( MI >= 0 )
  {
    v1 = CModelInfo::ms_modelInfoPtrs[MI];
    if ( v1 )
    {
      if ( (*((int (__fastcall **)(CBaseModelInfo *))v1->_vptr$CBaseModelInfo + 2))(CModelInfo::ms_modelInfoPtrs[MI])
        && (*(_WORD *)((*((int (__fastcall **)(CBaseModelInfo *))v1->_vptr$CBaseModelInfo + 2))(v1) + 40) & 0x7800) == 14336 )
      {
        return 1;
      }
    }
  }
  return result;
}

//----- (00314BB8) --------------------------------------------------------
void __fastcall CGarages::AllRespraysCloseOrOpen(bool bOpen)
{
  UInt32 v1; // r12
  UInt32 v2; // r3
  UInt8 *p_Type; // r2

  v1 = CGarages::NumGarages;
  if ( CGarages::NumGarages )
  {
    v2 = 0;
    p_Type = &CGarages::aGarages[0].Type;
    do
    {
      ++v2;
      if ( *p_Type == 5 )
        p_Type[1] = bOpen;
      p_Type += 216;
    }
    while ( v2 < v1 );
  }
}

//----- (00314BF0) --------------------------------------------------------
void __fastcall COnscreenTimerEntry::ProcessForDisplayClock(COnscreenTimerEntry *this)
{
  sprintf(
    this->ClockString,
    "%02d:%02d",
    *(_DWORD *)&CTheScripts::ScriptSpace[this->ClockIndex] / 60000 % 100,
    *(_DWORD *)&CTheScripts::ScriptSpace[this->ClockIndex] / 1000 % 60);
}

//----- (00314C6C) --------------------------------------------------------
void __fastcall COnscreenCounterEntry::ProcessForDisplayCounter(
        COnscreenCounterEntry *this,
        UInt16 CounterDisplayMethod)
{
  int v2; // r2

  v2 = *(_DWORD *)&CTheScripts::ScriptSpace[this->CounterIndex];
  if ( v2 <= 0 )
    v2 = 0;
  if ( CounterDisplayMethod >= 2u )
  {
    if ( CounterDisplayMethod == 2 )
      sprintf(this->CounterString, "%d / %d", v2);
  }
  else
  {
    sprintf(this->CounterString, (const unsigned __int8 *)&dword_314CA8, v2);
  }
}
// 314CA8: using guessed type int dword_314CA8;

//----- (00314CB4) --------------------------------------------------------
void __fastcall COnscreenCounterEntry::SetColourID(COnscreenCounterEntry *this, uint8 iCol_id)
{
  this->iColour_id = iCol_id;
}

//----- (00314CBC) --------------------------------------------------------
void __fastcall COnscreenTimerEntry::Process(COnscreenTimerEntry *this)
{
  UInt32 ClockIndex; // r1
  int v2; // r12
  unsigned int v3; // r3

  ClockIndex = this->ClockIndex;
  if ( this->ClockIndex )
  {
    v2 = *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex];
    v3 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    if ( this->bCountDown )
    {
      *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex] = v2 - v3;
      if ( *(int *)&CTheScripts::ScriptSpace[this->ClockIndex] <= -1 )
      {
        *(_DWORD *)&CTheScripts::ScriptSpace[this->ClockIndex] = 0;
        this->ClockTextKey[0] = 0;
        this->ClockIndex = 0;
        this->Clock = 0;
      }
      else if ( v2 / 1000 < this->SecsToStartBeeping && !TheCamera.m_WideScreenOn )
      {
        sub_18FDC4(&AudioEngine, 33, 0.0, 1.0);
      }
    }
    else
    {
      *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex] = v2 + v3;
    }
  }
}

//----- (00314D8C) --------------------------------------------------------
void __fastcall COnscreenTimer::Init(COnscreenTimer *this)
{
  this->CounterEntry[0].Counter = 0;
  this->FreezeTimers = 0;
  *(_DWORD *)&this->CounterEntry[0].CounterTextKey[8] = 0;
  this->CounterEntry[0].bFlashWhenFirstDisplayed = 1;
  *(_DWORD *)&this->CounterEntry[1].CounterTextKey[8] = 0;
  this->CounterEntry[1].Counter = 0;
  this->CounterEntry[1].bFlashWhenFirstDisplayed = 1;
  this->CounterEntry[2].Counter = 0;
  *(_DWORD *)&this->CounterEntry[2].CounterTextKey[8] = 0;
  this->CounterEntry[2].bFlashWhenFirstDisplayed = 1;
  this->CounterEntry[3].Counter = 0;
  this->CounterEntry[3].bFlashWhenFirstDisplayed = 1;
  *(_DWORD *)&this->CounterEntry[3].CounterTextKey[8] = 0;
  *(_QWORD *)&this->CounterEntry[0].CounterIndex = 0LL;
  *(_QWORD *)this->CounterEntry[0].CounterTextKey = 0LL;
  *(_QWORD *)&this->CounterEntry[1].CounterIndex = 0LL;
  *(_QWORD *)this->CounterEntry[1].CounterTextKey = 0LL;
  *(_QWORD *)&this->CounterEntry[2].CounterIndex = 0LL;
  *(_QWORD *)this->CounterEntry[2].CounterTextKey = 0LL;
  *(_QWORD *)&this->CounterEntry[3].CounterIndex = 0LL;
  *(_QWORD *)this->CounterEntry[3].CounterTextKey = 0LL;
  this->TimerEntry[0].ClockIndex = 0;
  *(_DWORD *)this->TimerEntry[0].ClockTextKey = 0;
  *(_WORD *)&this->TimerEntry[0].Clock = 256;
  *(_DWORD *)&this->TimerEntry[0].ClockTextKey[6] = 0;
  *(_DWORD *)&this->TimerEntry[0].ClockTextKey[2] = 0;
  this->TimerEntry[0].SecsToStartBeeping = 12;
}

//----- (00314E00) --------------------------------------------------------
void __fastcall COnscreenTimer::ProcessForDisplay(COnscreenTimer *this)
{
  UInt32 ClockIndex; // r0
  UInt32 CounterIndex; // r0
  int v4; // r2
  unsigned int CounterDisplayMethod; // r0
  UInt32 v6; // r0
  int v7; // r2
  unsigned int v8; // r0
  UInt32 v9; // r0
  int v10; // r2
  unsigned int v11; // r0
  UInt32 v12; // r0
  int v13; // r2
  int v14; // r0
  unsigned int v15; // r1

  if ( CHud::m_Wants_To_Draw_Hud )
  {
    ClockIndex = this->TimerEntry[0].ClockIndex;
    this->TimerEntry[0].Clock = 0;
    this->ClockOrCountersToDisplay = 0;
    if ( ClockIndex )
    {
      sprintf(
        this->TimerEntry[0].ClockString,
        "%02d:%02d",
        *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex] / 60000 % 100,
        *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex] / 1000 % 60);
      this->TimerEntry[0].Clock = 1;
      this->ClockOrCountersToDisplay = 1;
    }
    CounterIndex = this->CounterEntry[0].CounterIndex;
    this->CounterEntry[0].Counter = 0;
    if ( CounterIndex )
    {
      v4 = *(_DWORD *)&CTheScripts::ScriptSpace[CounterIndex];
      CounterDisplayMethod = this->CounterEntry[0].CounterDisplayMethod;
      if ( v4 <= 0 )
        v4 = 0;
      if ( CounterDisplayMethod >= 2 )
      {
        if ( CounterDisplayMethod == 2 )
          sprintf(
            this->CounterEntry[0].CounterString,
            "%d / %d",
            v4,
            *(_DWORD *)&CTheScripts::ScriptSpace[this->CounterEntry[0].CounterIndex2]);
      }
      else
      {
        sprintf(this->CounterEntry[0].CounterString, (const unsigned __int8 *)&dword_314FF4, v4);
      }
      this->ClockOrCountersToDisplay = 1;
      this->CounterEntry[0].Counter = 1;
    }
    v6 = this->CounterEntry[1].CounterIndex;
    this->CounterEntry[1].Counter = 0;
    if ( v6 )
    {
      v7 = *(_DWORD *)&CTheScripts::ScriptSpace[v6];
      v8 = this->CounterEntry[1].CounterDisplayMethod;
      if ( v7 <= 0 )
        v7 = 0;
      if ( v8 >= 2 )
      {
        if ( v8 == 2 )
          sprintf(
            this->CounterEntry[1].CounterString,
            "%d / %d",
            v7,
            *(_DWORD *)&CTheScripts::ScriptSpace[this->CounterEntry[1].CounterIndex2]);
      }
      else
      {
        sprintf(this->CounterEntry[1].CounterString, (const unsigned __int8 *)&dword_314FF4, v7);
      }
      this->ClockOrCountersToDisplay = 1;
      this->CounterEntry[1].Counter = 1;
    }
    v9 = this->CounterEntry[2].CounterIndex;
    this->CounterEntry[2].Counter = 0;
    if ( v9 )
    {
      v10 = *(_DWORD *)&CTheScripts::ScriptSpace[v9];
      v11 = this->CounterEntry[2].CounterDisplayMethod;
      if ( v10 <= 0 )
        v10 = 0;
      if ( v11 >= 2 )
      {
        if ( v11 == 2 )
          sprintf(
            this->CounterEntry[2].CounterString,
            "%d / %d",
            v10,
            *(_DWORD *)&CTheScripts::ScriptSpace[this->CounterEntry[2].CounterIndex2]);
      }
      else
      {
        sprintf(this->CounterEntry[2].CounterString, (const unsigned __int8 *)&dword_314FF4, v10);
      }
      this->ClockOrCountersToDisplay = 1;
      this->CounterEntry[2].Counter = 1;
    }
    v12 = this->CounterEntry[3].CounterIndex;
    v13 = 0;
    this->CounterEntry[3].Counter = 0;
    if ( v12 )
    {
      v14 = *(_DWORD *)&CTheScripts::ScriptSpace[v12];
      v15 = this->CounterEntry[3].CounterDisplayMethod;
      if ( v14 > 0 )
        v13 = v14;
      if ( v15 >= 2 )
      {
        if ( v15 == 2 )
          sprintf(
            this->CounterEntry[3].CounterString,
            "%d / %d",
            v13,
            *(_DWORD *)&CTheScripts::ScriptSpace[this->CounterEntry[3].CounterIndex2]);
      }
      else
      {
        sprintf(this->CounterEntry[3].CounterString, (const unsigned __int8 *)&dword_314FF4);
      }
      this->ClockOrCountersToDisplay = 1;
      this->CounterEntry[3].Counter = 1;
    }
  }
}
// 314FF4: using guessed type int dword_314FF4;

//----- (00315024) --------------------------------------------------------
void __fastcall COnscreenTimer::Process(COnscreenTimer *this)
{
  UInt32 ClockIndex; // r1
  int v2; // r12
  unsigned int v3; // r3

  if ( !this->FreezeTimers )
  {
    ClockIndex = this->TimerEntry[0].ClockIndex;
    if ( this->TimerEntry[0].ClockIndex )
    {
      v2 = *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex];
      v3 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
      if ( this->TimerEntry[0].bCountDown )
      {
        *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex] = v2 - v3;
        if ( *(int *)&CTheScripts::ScriptSpace[this->TimerEntry[0].ClockIndex] <= -1 )
        {
          *(_DWORD *)&CTheScripts::ScriptSpace[this->TimerEntry[0].ClockIndex] = 0;
          this->TimerEntry[0].ClockTextKey[0] = 0;
          this->TimerEntry[0].ClockIndex = 0;
          this->TimerEntry[0].Clock = 0;
        }
        else if ( v2 / 1000 < this->TimerEntry[0].SecsToStartBeeping && !TheCamera.m_WideScreenOn )
        {
          sub_18FDC4(&AudioEngine, 33, 0.0, 1.0);
        }
      }
      else
      {
        *(_DWORD *)&CTheScripts::ScriptSpace[ClockIndex] = v2 + v3;
      }
    }
  }
}

//----- (003150FC) --------------------------------------------------------
void __fastcall COnscreenTimer::AddClock(COnscreenTimer *this, UInt32 NewClockIndex, Char *pTextKey, bool bCountdown)
{
  char *ClockTextKey; // r0

  if ( !this->TimerEntry[0].ClockIndex )
  {
    this->TimerEntry[0].bCountDown = bCountdown;
    this->TimerEntry[0].ClockIndex = NewClockIndex;
    ClockTextKey = (char *)this->TimerEntry[0].ClockTextKey;
    if ( pTextKey )
      sub_19F6E8(ClockTextKey, (const char *)pTextKey, 0xAu);
    else
      *ClockTextKey = 0;
  }
}

//----- (00315122) --------------------------------------------------------
void __fastcall COnscreenTimer::AddCounter(
        COnscreenTimer *this,
        UInt32 NewCounterIndex,
        UInt16 DisplayMethod,
        Char *pTextKey,
        int CounterSlot)
{
  char *v6; // r5
  char *v7; // r0

  v6 = (char *)this + 68 * CounterSlot;
  if ( !*((_DWORD *)v6 + 16) )
  {
    *((_DWORD *)v6 + 16) = NewCounterIndex;
    v7 = v6 + 72;
    if ( pTextKey )
      strncpy(v7, (const char *)pTextKey, 0xAu);
    else
      *v7 = 0;
    *((_WORD *)v6 + 41) = DisplayMethod;
    *((_DWORD *)v6 + 17) = 0;
    *(_WORD *)(v6 + 127) = 769;
  }
}

//----- (00315166) --------------------------------------------------------
void __fastcall COnscreenTimer::AddCounterCounter(
        COnscreenTimer *this,
        UInt32 NewCounterIndex1,
        UInt32 NewCounterIndex2,
        Char *pTextKey,
        int CounterSlot)
{
  char *v5; // r5
  char *v6; // r0

  v5 = (char *)this + 68 * CounterSlot;
  if ( !*((_DWORD *)v5 + 16) )
  {
    *((_DWORD *)v5 + 16) = NewCounterIndex1;
    v6 = v5 + 72;
    *((_DWORD *)v5 + 17) = NewCounterIndex2;
    if ( pTextKey )
      strncpy(v6, (const char *)pTextKey, 0xAu);
    else
      *v6 = 0;
    v5[127] = 1;
    *((_WORD *)v5 + 41) = 2;
  }
}

//----- (003151A8) --------------------------------------------------------
void __fastcall COnscreenTimer::ClearClock(COnscreenTimer *this, UInt32 ClockIndex)
{
  if ( this->TimerEntry[0].ClockIndex == ClockIndex )
  {
    this->TimerEntry[0].ClockTextKey[0] = 0;
    this->TimerEntry[0].ClockIndex = 0;
    this->TimerEntry[0].Clock = 0;
    this->TimerEntry[0].bCountDown = 1;
  }
}

//----- (003151C2) --------------------------------------------------------
void __fastcall COnscreenTimer::ClearCounter(COnscreenTimer *this, UInt32 CounterIndex)
{
  if ( this->CounterEntry[0].CounterIndex == CounterIndex )
  {
    this->CounterEntry[0].CounterTextKey[0] = 0;
    this->CounterEntry[0].CounterDisplayMethod = 0;
    this->CounterEntry[0].Counter = 0;
    this->CounterEntry[0].CounterIndex = 0;
    this->CounterEntry[0].CounterIndex2 = 0;
  }
  if ( this->CounterEntry[1].CounterIndex == CounterIndex )
  {
    this->CounterEntry[1].CounterTextKey[0] = 0;
    this->CounterEntry[1].CounterDisplayMethod = 0;
    this->CounterEntry[1].Counter = 0;
    this->CounterEntry[1].CounterIndex = 0;
    this->CounterEntry[1].CounterIndex2 = 0;
  }
  if ( this->CounterEntry[2].CounterIndex == CounterIndex )
  {
    this->CounterEntry[2].CounterTextKey[0] = 0;
    this->CounterEntry[2].CounterDisplayMethod = 0;
    this->CounterEntry[2].Counter = 0;
    this->CounterEntry[2].CounterIndex = 0;
    this->CounterEntry[2].CounterIndex2 = 0;
  }
  if ( this->CounterEntry[3].CounterIndex == CounterIndex )
  {
    this->CounterEntry[3].CounterTextKey[0] = 0;
    this->CounterEntry[3].CounterDisplayMethod = 0;
    this->CounterEntry[3].Counter = 0;
    this->CounterEntry[3].CounterIndex = 0;
    this->CounterEntry[3].CounterIndex2 = 0;
  }
}

//----- (0031522C) --------------------------------------------------------
void __fastcall COnscreenTimer::SetCounterFlashWhenFirstDisplayed(
        COnscreenTimer *this,
        UInt32 CounterIndex,
        Bool8 bFlash)
{
  if ( this->CounterEntry[0].CounterIndex == CounterIndex )
    this->CounterEntry[0].bFlashWhenFirstDisplayed = bFlash;
  if ( this->CounterEntry[1].CounterIndex == CounterIndex )
    this->CounterEntry[1].bFlashWhenFirstDisplayed = bFlash;
  if ( this->CounterEntry[2].CounterIndex == CounterIndex )
    this->CounterEntry[2].bFlashWhenFirstDisplayed = bFlash;
  if ( this->CounterEntry[3].CounterIndex == CounterIndex )
    this->CounterEntry[3].bFlashWhenFirstDisplayed = bFlash;
}

//----- (0031525C) --------------------------------------------------------
void __fastcall COnscreenTimer::SetClockBeepCountdownSecs(COnscreenTimer *this, UInt32 TimerIndex, UInt32 Secs)
{
  if ( this->TimerEntry[0].ClockIndex == TimerIndex )
    this->TimerEntry[0].SecsToStartBeeping = Secs;
}

//----- (00315266) --------------------------------------------------------
void __fastcall COnscreenTimer::SetCounterColourID(COnscreenTimer *this, UInt32 CounterIndex, uint8 ColourID)
{
  if ( this->CounterEntry[0].CounterIndex == CounterIndex )
    this->CounterEntry[0].iColour_id = ColourID;
  if ( this->CounterEntry[1].CounterIndex == CounterIndex )
    this->CounterEntry[1].iColour_id = ColourID;
  if ( this->CounterEntry[2].CounterIndex == CounterIndex )
    this->CounterEntry[2].iColour_id = ColourID;
  if ( this->CounterEntry[3].CounterIndex == CounterIndex )
    this->CounterEntry[3].iColour_id = ColourID;
}

//----- (0031529C) --------------------------------------------------------
void __fastcall CPathFind::Init(CPathFind *this)
{
  int v1; // r2
  UInt8 *v2; // r3

  NumTempExternalNodes = 0;
  this->bActiveRequestForRegions = 0;
  this->NumNodeSwitches = 0;
  v1 = 0;
  do
  {
    v2 = &this->ColourGroups[v1];
    v1 += 4;
    *((_DWORD *)v2 + 585) = 0;
    *((_DWORD *)v2 + 513) = 0;
    *((_DWORD *)v2 + 657) = 0;
    *((_DWORD *)v2 + 729) = 0;
    *((_DWORD *)v2 + 801) = 0;
    *((_DWORD *)v2 + 873) = 0;
    *((_DWORD *)v2 + 945) = 0;
  }
  while ( v1 != 288 );
  this->InteriorID[7] = -1;
  this->InteriorID[6] = -1;
  this->InteriorID[5] = -1;
  this->InteriorID[4] = -1;
  this->InteriorID[3] = -1;
  this->InteriorID[2] = -1;
  this->InteriorID[1] = -1;
  this->InteriorID[0] = -1;
}

//----- (00315314) --------------------------------------------------------
void __fastcall CPathFind::ReInit(CPathFind *this)
{
  this->NumNodeSwitches = 0;
  this->bActiveRequestForRegions = 0;
}

//----- (00315324) --------------------------------------------------------
void __fastcall CPathFind::ReleaseRequestedNodes(CPathFind *this)
{
  this->bActiveRequestForRegions = 0;
}

//----- (00315330) --------------------------------------------------------
void __fastcall CPathFind::LoadPathFindData(CPathFind *this, Int32 Region)
{
  RwStream_0 *v4; // r6

  CTimer::Suspend();
  sprintf(gString, "data\\paths\\nodes%d.dat", Region);
  v4 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, gString);
  CPathFind::LoadPathFindData(this, v4, Region);
  RwStreamClose(v4, 0);
  sub_19F744();
}

//----- (00315398) --------------------------------------------------------
void __fastcall CPathFind::LoadPathFindData(CPathFind *this, RwStream_0 *pStream, Int32 Region)
{
  char *v5; // r11
  int *v6; // r8
  _DWORD *v7; // r4
  _DWORD *v8; // r5
  int v9; // r0
  void *v10; // r0
  void *v11; // r0
  _DWORD *v12; // r11
  int v13; // r1
  int v14; // r2
  int v15; // r6
  char v16; // r3
  CPathFind *v17; // r0
  float *p_MaxY; // r10
  unsigned int v19; // r5
  Int32 v20; // r6
  UInt8 *v21; // r0

  v5 = (char *)this + 4 * Region;
  v6 = (int *)(v5 + 4068);
  RwStreamReadInt32(pStream, (RwInt32 *)v5 + 1017, 4u);
  RwStreamReadInt32(pStream, (RwInt32 *)v5 + 1089, 4u);
  RwStreamReadInt32(pStream, (RwInt32 *)v5 + 1161, 4u);
  v7 = v5 + 4932;
  RwStreamReadInt32(pStream, (RwInt32 *)v5 + 1233, 4u);
  v8 = v5 + 5220;
  RwStreamReadInt32(pStream, (RwInt32 *)v5 + 1305, 4u);
  v9 = *((_DWORD *)v5 + 1017);
  if ( v9 )
  {
    v10 = CMemoryMgr::Malloc(28 * v9);
    *((_DWORD *)v5 + 513) = v10;
    RwStreamRead(pStream, v10, 28 * *v6);
  }
  else
  {
    *((_DWORD *)v5 + 513) = CMemoryMgr::Malloc(0x1Cu);
  }
  if ( *v7 )
  {
    v11 = CMemoryMgr::Malloc(14 * *v7);
    *((_DWORD *)v5 + 585) = v11;
    RwStreamRead(pStream, v11, 14 * *v7);
  }
  else
  {
    *((_DWORD *)v5 + 585) = 0;
  }
  if ( *v8 )
  {
    *((_DWORD *)v5 + 657) = CMemoryMgr::Malloc(4 * *v8 + 768);
    *((_DWORD *)v5 + 873) = CMemoryMgr::Malloc(2 * *v8);
    *((_DWORD *)v5 + 729) = CMemoryMgr::Malloc(*v8 + 192);
    *((_DWORD *)v5 + 801) = CMemoryMgr::Malloc(*v8 + 192);
    RwStreamRead(pStream, *((void **)v5 + 657), 4 * *v8 + 768);
    RwStreamRead(pStream, *((void **)v5 + 873), 2 * *v8);
    RwStreamRead(pStream, *((void **)v5 + 729), *v8 + 192);
    RwStreamRead(pStream, *((void **)v5 + 801), *v8 + 192);
  }
  else
  {
    *((_DWORD *)v5 + 873) = 0;
    *((_DWORD *)v5 + 657) = 0;
    *((_DWORD *)v5 + 729) = 0;
    *((_DWORD *)v5 + 801) = 0;
  }
  if ( *v6 >= 1 )
  {
    v12 = v5 + 2052;
    v13 = 0;
    v14 = 24;
    do
    {
      ++v13;
      v15 = *v12 + v14;
      v16 = *(_BYTE *)(v15 + 2);
      *(_WORD *)v15 = *(_WORD *)v15 & 0xFEFF | (8 * *(_WORD *)v15) & 0x100;
      v14 += 28;
      *(_BYTE *)(v15 + 2) = v16;
    }
    while ( v13 < *v6 );
  }
  v17 = this;
  if ( this->NumNodeSwitches >= 1 )
  {
    v19 = 0;
    v20 = 0;
    do
    {
      p_MaxY = &this->NodeSwitches[0].MaxY;
      CPathFind::SwitchRoadsOffInAreaForOneRegion(
        v17,
        p_MaxY[v19 / 4 - 3],
        p_MaxY[v19 / 4 - 2],
        p_MaxY[v19 / 4 - 1],
        p_MaxY[v19 / 4],
        p_MaxY[v19 / 4 + 1],
        v17->NodeSwitches[v19 / 0x1C].MaxZ,
        LOBYTE(p_MaxY[v19 / 4 + 3]),
        BYTE1(p_MaxY[v19 / 4 + 3]),
        Region,
        0);
      v17 = this;
      v19 += 28;
      ++v20;
    }
    while ( v20 < this->NumNodeSwitches );
  }
  v21 = &v17->ColourGroups[64 * Region];
  *(_QWORD *)(v21 + 9604) = -1LL;
  *(_QWORD *)(v21 + 9612) = -1LL;
  *(_QWORD *)(v21 + 5508) = -1LL;
  *(_QWORD *)(v21 + 5516) = -1LL;
  *(_QWORD *)(v21 + 9620) = -1LL;
  *(_QWORD *)(v21 + 9628) = -1LL;
  *(_QWORD *)(v21 + 5524) = -1LL;
  *(_QWORD *)(v21 + 5532) = -1LL;
  *(_QWORD *)(v21 + 9652) = -1LL;
  *(_QWORD *)(v21 + 9660) = -1LL;
  *(_QWORD *)(v21 + 5540) = -1LL;
  *(_QWORD *)(v21 + 5548) = -1LL;
  *(_QWORD *)(v21 + 9636) = -1LL;
  *(_QWORD *)(v21 + 9644) = -1LL;
  v21 += 5556;
  *(_QWORD *)v21 = -1LL;
  *((_QWORD *)v21 + 1) = -1LL;
}

//----- (003155E0) --------------------------------------------------------
void __fastcall CPathFind::SwitchRoadsOffInAreaForOneRegion(
        CPathFind *this,
        float MinX,
        float MaxX,
        float MinY,
        float MaxY,
        float MinZ,
        float MaxZ,
        int SwitchRoadsOff,
        int bCars,
        Int32 Region,
        int bBackToOriginal)
{
  char *v12; // r12
  int v13; // r0
  int *v14; // r6
  int v15; // r5
  int v16; // lr
  int *i; // r4
  int v21; // r1
  float v22; // s2
  float v23; // s2
  float v24; // s0
  unsigned int v25; // r0
  int v26; // r6
  int v27; // r0
  CPathNode *j; // r1
  CPathNode *ppNextNode1; // [sp+10h] [bp-60h] BYREF
  CPathNode *v30[23]; // [sp+14h] [bp-5Ch] BYREF

  v12 = (char *)this + 4 * Region;
  v13 = *((_DWORD *)v12 + 513);
  if ( v13 )
  {
    v14 = (int *)(v12 + 4356);
    if ( bCars )
    {
      v15 = 0;
    }
    else
    {
      v15 = *v14;
      v14 = (int *)(v12 + 4068);
    }
    v16 = *v14;
    if ( v15 < *v14 )
    {
      for ( i = (int *)(v12 + 2052); ; v13 = *i )
      {
        v21 = v13 + 28 * v15;
        v22 = (float)*(__int16 *)(v21 + 8) * 0.125;
        if ( v22 >= MinX && v22 <= MaxX )
        {
          v23 = (float)*(__int16 *)(v21 + 10) * 0.125;
          if ( v23 >= MinY && v23 <= MaxY )
          {
            v24 = (float)*(__int16 *)(v21 + 12) * 0.125;
            if ( v24 >= MinZ && v24 <= MaxZ )
            {
              v25 = *(unsigned __int16 *)(v21 + 24) | (*(unsigned __int8 *)(v21 + 26) << 16);
              if ( (((v25 >> 20) - 1) & 0xFFFFFF) >= 2 )
              {
                v26 = (v25 >> 5) & 1;
                if ( bBackToOriginal )
                  v27 = (v25 >> 8) & 1;
                else
                  v27 = SwitchRoadsOff;
                if ( v26 != v27 )
                {
                  CPathFind::SwitchOffNodeAndNeighbours(
                    this,
                    (CPathNode *)v21,
                    v30,
                    &ppNextNode1,
                    SwitchRoadsOff,
                    bBackToOriginal);
                  while ( v30[0] )
                    CPathFind::SwitchOffNodeAndNeighbours(this, v30[0], v30, 0, SwitchRoadsOff, bBackToOriginal);
                  for ( j = ppNextNode1; ppNextNode1; j = ppNextNode1 )
                    CPathFind::SwitchOffNodeAndNeighbours(this, j, &ppNextNode1, 0, SwitchRoadsOff, bBackToOriginal);
                }
              }
            }
          }
        }
        if ( ++v15 == v16 )
          break;
      }
    }
  }
}

//----- (00315754) --------------------------------------------------------
void __fastcall CPathFind::UnLoadPathFindData(CPathFind *this, Int32 Region)
{
  UInt8 *v2; // r4
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  _DWORD *v8; // r10
  _DWORD *v9; // r6
  _DWORD *v10; // r8
  _DWORD *v11; // r9
  _DWORD *v12; // r5
  void *v13; // r0
  _DWORD *v14; // r4

  v2 = &this->ColourGroups[4 * Region];
  v3 = (void *)*((_DWORD *)v2 + 513);
  if ( v3 )
    CMemoryMgr::Free(v3);
  v4 = (void *)*((_DWORD *)v2 + 585);
  if ( v4 )
    CMemoryMgr::Free(v4);
  v5 = (void *)*((_DWORD *)v2 + 657);
  if ( v5 )
    CMemoryMgr::Free(v5);
  v6 = (void *)*((_DWORD *)v2 + 873);
  if ( v6 )
    CMemoryMgr::Free(v6);
  v7 = (void *)*((_DWORD *)v2 + 729);
  v8 = v2 + 2052;
  v9 = v2 + 2340;
  v10 = v2 + 2628;
  v11 = v2 + 3492;
  v12 = v2 + 2916;
  if ( v7 )
    CMemoryMgr::Free(v7);
  v13 = (void *)*((_DWORD *)v2 + 801);
  v14 = v2 + 3204;
  if ( v13 )
    CMemoryMgr::Free(v13);
  *v8 = 0;
  *v9 = 0;
  *v10 = 0;
  *v11 = 0;
  *v12 = 0;
  *v14 = 0;
}

//----- (003157DC) --------------------------------------------------------
void __fastcall CPathFind::ComputeRoute(
        CPathFind *this,
        RwReal GraphType,
        const CVector *StartCoors,
        const CVector *TargetCoors,
        const CNodeAddress *StartNode,
        CNodeRoute *route)
{
  int v6; // r1
  int v7; // r2
  int v8; // r3
  CNodeAddress v9; // [sp+44h] [bp-3Ch] BYREF
  __int16 v10; // [sp+48h] [bp-38h]
  __int16 v11; // [sp+4Ch] [bp-34h]
  __int16 v12; // [sp+50h] [bp-30h]
  __int16 v13; // [sp+54h] [bp-2Ch]
  __int16 v14; // [sp+58h] [bp-28h]
  __int16 v15; // [sp+5Ch] [bp-24h]
  __int16 v16; // [sp+60h] [bp-20h]
  Int16 pNumNodesGiven[13]; // [sp+66h] [bp-1Ah] BYREF

  v10 = -1;
  v9.Region = -1;
  v11 = -1;
  v12 = -1;
  v13 = -1;
  v14 = -1;
  v15 = -1;
  pNumNodesGiven[0] = 0;
  v16 = -1;
  CPathFind::DoPathSearch(
    this,
    GraphType,
    *StartCoors,
    *StartNode,
    *TargetCoors,
    &v9,
    pNumNodesGiven,
    8,
    0,
    1000000.0,
    0,
    1000000.0,
    0,
    EmptyNodeAddress,
    0,
    0);
  route->m_iRouteSize = 0;
  v6 = pNumNodesGiven[0];
  if ( pNumNodesGiven[0] >= 1 )
  {
    v7 = 0;
    v8 = 0;
    do
    {
      if ( v7 <= 7 )
      {
        route->m_routePoints[v7] = *(&v9 + v8);
        v7 = route->m_iRouteSize + 1;
        route->m_iRouteSize = v7;
      }
      ++v8;
    }
    while ( v8 < v6 );
  }
}
// 3157DC: using guessed type Int16 var_1A[13];

//----- (00315898) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CPathFind::DoPathSearch(
        CPathFind *this,
        RwReal GraphType,
        CVector StartCoors,
        CNodeAddress StartNode,
        CVector TargetCoors,
        CNodeAddress *pNodeList,
        Int16 *pNumNodesGiven,
        Int32 NumNodesRequested,
        float *pDistance,
        float CutoffDistForNodeSearch,
        CNodeAddress *pGivenTargetNode,
        float MaxSearchDistance,
        int bDontGoAgainstTraffic,
        CNodeAddress NodeToAvoid,
        int bAmphibiousVehicle,
        int bBoat)
{
  bool v17; // zf
  CNodeAddress *NodeClosestToCoors; // r6
  CNodeAddress *v19; // r0
  unsigned int v20; // r2
  bool v21; // zf
  unsigned int v22; // r1
  CPathFind *v23; // r4
  CPathNode *v24; // r11
  int v25; // r6
  CNodeAddress *v26; // r10
  CPathNode *v27; // r0
  Int16 *v28; // lr
  int v29; // r0
  int v30; // r3
  int v31; // r5
  Int32 *v32; // r1
  Int32 v33; // r10
  int v34; // r2
  int v35; // r12
  int v36; // r9
  int v37; // r11
  UInt8 *v38; // r0
  unsigned int v39; // r1
  CPathNode *v40; // r5
  unsigned int v41; // lr
  unsigned int v42; // r2
  char *v43; // r4
  unsigned __int16 *v44; // r2
  unsigned int v45; // r3
  _BOOL4 v46; // r3
  bool v47; // zf
  int v48; // r3
  Int16 *p_DistanceToTarget; // r0
  int DistanceToTarget; // r1
  int v51; // r6
  CPathFind *v52; // r12
  int v53; // r4
  int v54; // r2
  int v55; // r1
  char *v56; // r1
  CPathNode *v57; // r1
  CPathNode *v58; // t1
  bool v59; // cc
  CNodeAddress *v60; // r0
  unsigned int v61; // t1
  int v62; // r8
  int v63; // r0
  int v64; // r0
  int IndexAdjacentNodes; // r2
  char *v66; // r6
  unsigned int v67; // r5
  CPathNode *v68; // r1
  int v69; // r0
  CNodeAddress *v70; // r0
  unsigned int v71; // t1
  bool v72; // [sp+1Ch] [bp-54h]
  CPathNode *v73; // [sp+1Ch] [bp-54h]
  int v74; // [sp+20h] [bp-50h]
  CPathNode *v75; // [sp+24h] [bp-4Ch]
  int v76; // [sp+28h] [bp-48h]
  int v77; // [sp+2Ch] [bp-44h]
  Int32 *p_NodesOnListDuringPathfinding; // [sp+34h] [bp-3Ch]
  int v79; // [sp+38h] [bp-38h]
  RwReal x; // [sp+40h] [bp-30h]
  RwReal y; // [sp+44h] [bp-2Ch]
  CVector v83; // 0:r2.8,8:^0.4
  CVector v84; // 0:r2.8,8:^0.4

  x = StartCoors.x;
  y = StartCoors.y;
  v17 = pGivenTargetNode == 0;
  this->NodesOnListDuringPathfinding = 0;
  if ( pGivenTargetNode )
    v17 = pGivenTargetNode->Region == 0xFFFF;
  if ( v17 || (NodeClosestToCoors = (CNodeAddress *)*pGivenTargetNode, !this->pNodes[pGivenTargetNode->Region]) )
  {
    *(_QWORD *)&v83.x = *(_QWORD *)&TargetCoors.y;
    v83.z = GraphType;
    NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                           (CNodeAddress *)this,
                           (CPathFind *)LODWORD(TargetCoors.x),
                           v83,
                           CutoffDistForNodeSearch,
                           0.0,
                           0,
                           0,
                           bBoat,
                           0,
                           v72);
  }
  if ( (unsigned __int16)NodeClosestToCoors == 0xFFFF )
  {
    *pNumNodesGiven = 0;
    goto LABEL_12;
  }
  v19 = (CNodeAddress *)StartNode;
  if ( StartNode.Region == 0xFFFF || !this->pNodes[StartNode.Region] )
  {
    v84.z = GraphType;
    *(_QWORD *)&v84.x = __PAIR64__(LODWORD(StartCoors.z), LODWORD(y));
    v19 = CPathFind::FindNodeClosestToCoors(
            (CNodeAddress *)this,
            (CPathFind *)LODWORD(x),
            v84,
            CutoffDistForNodeSearch,
            0.0,
            0,
            0,
            bBoat,
            0,
            v72);
    if ( (unsigned __int16)v19 == 0xFFFF )
    {
      *pNumNodesGiven = 0;
LABEL_12:
      if ( pDistance )
        *pDistance = 100000.0;
      return;
    }
  }
  v20 = (unsigned int)v19 >> 16;
  v21 = (unsigned __int16)v19 == (unsigned __int16)NodeClosestToCoors;
  v22 = (unsigned int)NodeClosestToCoors >> 16;
  if ( (unsigned __int16)v19 == (unsigned __int16)NodeClosestToCoors )
    v21 = v20 == v22;
  if ( v21 )
  {
    *pNumNodesGiven = 0;
    if ( pDistance )
      *pDistance = 0.0;
  }
  else
  {
    v23 = this;
    v24 = &this->pNodes[(unsigned __int16)v19][v20];
    if ( this->pNodes[(unsigned __int16)NodeClosestToCoors][v22].Group == v24->Group )
    {
      p_NodesOnListDuringPathfinding = &this->NodesOnListDuringPathfinding;
      v73 = &this->pNodes[(unsigned __int16)NodeClosestToCoors][v22];
      memset(this->apHashTable, 0, sizeof(this->apHashTable));
      v25 = 0;
      v26 = pNodeList;
      v73->pNext = 0;
      v73->pPrevious = (CPathNode *)this->apHashTable;
      v27 = this->apHashTable[0];
      v28 = pNumNodesGiven;
      if ( v27 )
        v27->pPrevious = v73;
      this->apHashTable[0] = v73;
      v73->DistanceToTarget = 0;
      v29 = *p_NodesOnListDuringPathfinding + 1;
      *p_NodesOnListDuringPathfinding = v29;
      v30 = 0;
      aNodesToBeCleared[0] = v73->Address;
      v31 = 1;
      v32 = 0;
      v75 = v24;
      while ( !(v25 << 31) )
      {
        v32 = (Int32 *)((char *)v23 + 4 * (_DWORD)v32);
        v33 = v32[1];
        if ( v33 )
        {
          v25 = 0;
          v74 = v30;
          v79 = v31;
          do
          {
            v77 = v25;
            v34 = 0;
            v35 = *(unsigned __int16 *)(v33 + 24) | (*(unsigned __int8 *)(v33 + 26) << 16);
            if ( (CPathNode *)v33 == v24 )
              v34 = 1;
            v76 = v34;
            if ( (*(_WORD *)(v33 + 24) & 0xF) != 0 )
            {
              v36 = 0;
              do
              {
                v37 = *(__int16 *)(v33 + 16);
                v38 = &v23->ColourGroups[4 * *(unsigned __int16 *)(v33 + 18)];
                v39 = *(_DWORD *)(*((_DWORD *)v38 + 657) + 4 * (v36 + v37));
                v40 = v23->pNodes[(unsigned __int16)v39];
                if ( v40 )
                {
                  v41 = HIWORD(v39);
                  if ( bDontGoAgainstTraffic == 1 )
                  {
                    v42 = *(unsigned __int16 *)(*((_DWORD *)v38 + 873) + 2 * (v36 + v37));
                    v43 = (char *)v23 + 4 * (v42 >> 10);
                    if ( *((_DWORD *)v43 + 513) )
                    {
                      v44 = (unsigned __int16 *)(*((_DWORD *)v43 + 585) + 14 * (v42 & 0x3FF));
                      if ( v44[2] == (unsigned __int16)v39 )
                      {
                        v45 = *(unsigned __int16 *)((char *)v44 + 11);
                        if ( v44[3] == v41 )
                          v45 >>= 3;
                      }
                      else
                      {
                        v45 = *(unsigned __int16 *)((char *)v44 + 11);
                      }
                      v23 = this;
                      v46 = v45 << 29 == 0;
                    }
                    else
                    {
                      v46 = 0;
                      v23 = this;
                    }
                  }
                  else
                  {
                    v46 = 0;
                  }
                  if ( (v39 ^ *(_DWORD *)&NodeToAvoid | HIWORD(*(unsigned int *)&NodeToAvoid) ^ v41) << 16 )
                  {
                    v47 = !v46;
                    if ( !v46 )
                    {
                      v40 += v41;
                      v47 = ((bAmphibiousVehicle ^ 1) & ((*((unsigned __int16 *)v40 + 12) ^ (unsigned int)v35) >> 7)) == 0;
                    }
                    if ( v47 )
                    {
                      v48 = *((_DWORD *)v38 + 729);
                      p_DistanceToTarget = &v40->DistanceToTarget;
                      DistanceToTarget = v40->DistanceToTarget;
                      v51 = *(unsigned __int8 *)(v48 + v37 + v36) + *(__int16 *)(v33 + 14);
                      if ( v51 < DistanceToTarget )
                      {
                        v52 = v23;
                        v53 = v79;
                        v54 = (unsigned __int16)DistanceToTarget;
                        v55 = 32766;
                        if ( v54 != 32766 )
                        {
                          v40->pPrevious->pNext = v40->pNext;
                          if ( v40->pNext )
                            v40->pNext->pPrevious = v40->pPrevious;
                          --*p_NodesOnListDuringPathfinding;
                          v55 = (unsigned __int16)*p_DistanceToTarget;
                        }
                        if ( v79 <= 4999 && v55 == 32766 )
                        {
                          aNodesToBeCleared[v79] = v40->Address;
                          v53 = v79 + 1;
                        }
                        v79 = v53;
                        v23 = v52;
                        v56 = (char *)v52 + 4 * (v51 & 0x1FF);
                        v58 = (CPathNode *)*((_DWORD *)v56 + 1);
                        v57 = (CPathNode *)(v56 + 4);
                        v40->pNext = v58;
                        v40->pPrevious = v57;
                        if ( v57->pNext )
                          v57->pNext->pPrevious = v40;
                        v57->pNext = v40;
                        *p_DistanceToTarget = v51;
                        ++*p_NodesOnListDuringPathfinding;
                        v35 = *(unsigned __int16 *)(v33 + 24) | (*(unsigned __int8 *)(v33 + 26) << 16);
                      }
                    }
                  }
                }
                ++v36;
              }
              while ( v36 < (v35 & 0xF) );
            }
            v25 = v77 | v76;
            **(_DWORD **)(v33 + 4) = *(_DWORD *)v33;
            if ( *(_DWORD *)v33 )
              *(_DWORD *)(*(_DWORD *)v33 + 4) = *(_DWORD *)(v33 + 4);
            v32 = &this->NodesOnListDuringPathfinding;
            v29 = *p_NodesOnListDuringPathfinding - 1;
            *p_NodesOnListDuringPathfinding = v29;
            v33 = *(_DWORD *)v33;
            v24 = v75;
          }
          while ( v33 );
          v31 = v79;
          v30 = v74;
        }
        else
        {
          v25 = 0;
        }
        v28 = pNumNodesGiven;
        v26 = pNodeList;
        if ( v29 )
        {
          v59 = (float)++v30 < MaxSearchDistance;
          if ( (float)v30 <= MaxSearchDistance )
          {
            v32 = (Int32 *)(v30 & 0x1FF);
            v59 = v31 < 4950;
          }
          if ( v59 )
            continue;
        }
        *pNumNodesGiven = 0;
        if ( v31 >= 1 )
        {
          v60 = aNodesToBeCleared;
          do
          {
            v61 = (unsigned int)*v60++;
            --v31;
            v23->pNodes[(unsigned __int16)v61][HIWORD(v61)].DistanceToTarget = 32766;
          }
          while ( v31 );
        }
        return;
      }
      *v28 = 0;
      v62 = v31;
      if ( pDistance )
        *pDistance = (float)v24->DistanceToTarget;
      if ( v26 )
      {
        v63 = *v28;
        *v28 = v63 + 1;
        v26[v63] = v24->Address;
      }
      while ( v24 != v73 )
      {
        if ( *v28 >= NumNodesRequested )
          break;
        if ( *((unsigned __int16 *)v24 + 12) << 28 )
        {
          v64 = 0;
          do
          {
            IndexAdjacentNodes = v24->IndexAdjacentNodes;
            v66 = (char *)v23 + 4 * v24->Address.Region;
            v67 = *(_DWORD *)(*((_DWORD *)v66 + 657) + 4 * (v64 + IndexAdjacentNodes));
            v68 = v23->pNodes[(unsigned __int16)v67];
            if ( v68 )
            {
              v23 = this;
              if ( v24->DistanceToTarget - *(unsigned __int8 *)(*((_DWORD *)v66 + 729) + v64 + IndexAdjacentNodes) == v68[HIWORD(v67)].DistanceToTarget )
              {
                v69 = *v28;
                *v28 = v69 + 1;
                v24 = &v68[HIWORD(v67)];
                v26[v69] = v24->Address;
                v64 = 29030;
              }
            }
            ++v64;
          }
          while ( v64 < (*((_WORD *)v24 + 12) & 0xF) );
        }
      }
      if ( v62 >= 1 )
      {
        v70 = aNodesToBeCleared;
        do
        {
          v71 = (unsigned int)*v70++;
          --v62;
          v23->pNodes[(unsigned __int16)v71][HIWORD(v71)].DistanceToTarget = 32766;
        }
        while ( v62 );
      }
    }
    else
    {
      *pNumNodesGiven = 0;
      if ( pDistance )
        *pDistance = 100000.0;
    }
  }
}
// 315898: fragmented variable at 0:r2.8,8:^78.4 may be wrong
// 315898: variables would overlap: 0:r2.8,8:^78.4 and ^78.4
// 315898: variables would overlap: ^8C.4 and ^8C.8

//----- (00315D90) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CNodeAddress *__fastcall CPathFind::FindNodeClosestToCoors(
        CNodeAddress *retstr,
        CPathFind *this,
        CVector SearchCoors,
        float GraphType,
        float CutoffDist,
        bool bIgnoreSwitchedOff,
        int bIgnoreBetweenLevels,
        int bIgnoreAlreadyFound,
        int bBoatNodes,
        bool bIgnoreInteriors)
{
  float32x2_t v10; // d0
  float32x2_t v11; // d1
  float32x2_t v12; // d2
  float32x2_t v13; // d3
  float x; // s20
  int v16; // r11
  int v18; // r5
  int v19; // r4
  int v20; // r9
  float v22; // s18
  int v23; // r0
  int v24; // r1
  int v25; // r5
  int v26; // r10
  int v27; // r9
  int v28; // r1
  int v29; // r4
  int v30; // r6
  UInt16 v31; // r5
  unsigned int v32; // r11
  int v33; // r4
  UInt16 v34; // r5
  unsigned int v35; // r4
  UInt16 v36; // r6
  int v37; // r11
  int v38; // r4
  RwReal v40; // [sp+0h] [bp-98h]
  RwReal y; // [sp+4h] [bp-94h]
  int v42; // [sp+24h] [bp-74h]
  int v43; // [sp+28h] [bp-70h]
  int v44; // [sp+2Ch] [bp-6Ch]
  int v45; // [sp+30h] [bp-68h]
  int v46; // [sp+34h] [bp-64h]
  UInt16 v47; // [sp+38h] [bp-60h]
  UInt16 v48; // [sp+3Ch] [bp-5Ch]
  UInt16 v49; // [sp+40h] [bp-58h]
  int v50; // [sp+44h] [bp-54h]
  int v51; // [sp+48h] [bp-50h]
  __int64 v52; // [sp+4Ch] [bp-4Ch]
  float pClosestDist; // [sp+58h] [bp-40h] BYREF
  CNodeAddress pNodeFound; // [sp+5Ch] [bp-3Ch] BYREF
  CVector v56; // 0:r3.4,4:^0.8
  CVector v57; // 0:r3.4,4:^0.8
  CVector v58; // 0:r3.4,4:^0.8
  CVector v59; // 0:r3.4,4:^0.8
  CVector v60; // 0:r3.4,4:^0.8
  CVector v61; // 0:r3.4,4:^0.8
  CVector v62; // 0:r3.4,4:^0.8
  CVector v63; // 0:r3.4,4:^0.8
  CVector v64; // 0:r3.4,4:^0.8
  CVector v65; // 0:r3.4,4:^0.8
  CVector v66; // 0:r3.4,4:^0.8
  CVector v67; // 0:r3.4,4:^0.8

  pClosestDist = GraphType;
  x = SearchCoors.x;
  v16 = 7;
  pNodeFound.Region = -1;
  HIDWORD(v52) = LODWORD(SearchCoors.y);
  v40 = SearchCoors.x;
  y = SearchCoors.y;
  v18 = 7;
  v19 = (int)(float)((float)(*(float *)&this + 3000.0) / 750.0);
  if ( v19 <= 0 )
    v19 = 0;
  *(RwReal *)&v52 = SearchCoors.x;
  v20 = (int)(float)((float)(SearchCoors.x + 3000.0) / 750.0);
  if ( v20 <= 0 )
    v20 = 0;
  if ( v20 < 7 )
    v16 = v20;
  if ( v19 < 7 )
    v18 = v19;
  CPathFind::FindNodeClosestInRegion(
    (CPathFind *)retstr,
    &pNodeFound,
    v18 | (8 * v16),
    *(CVector *)&this,
    SLODWORD(SearchCoors.z),
    &pClosestDist,
    SLODWORD(CutoffDist),
    bIgnoreBetweenLevels,
    bIgnoreAlreadyFound,
    0);
  v46 = v18;
  v11.n64_f32[0] = (float)((float)((float)(v18 + 1) * 7