&CClouds::ms_vc.bUsed[12 * v25];
    v29 = v28[90];
    v30 = v28[91];
    v31 = v29 + (float)(CWeather::WindDir.x * CClouds::m_fVolumetricCloudWindMoveFactor);
    v32 = (float)((float)((float)(v29 - x) * (float)(v29 - x)) + (float)((float)(v30 - y) * (float)(v30 - y)))
        + (float)((float)(v28[92] - z) * (float)(v28[92] - z));
    v33 = CClouds::m_fVolumetricCloudWindMoveFactor * CWeather::WindDir.y;
    v28[90] = v31;
    v34 = sqrtf(v32);
    v28[91] = v30 + v33;
    v35 = &CClouds::ms_vc.bJustCreated[v25];
    v36 = CClouds::m_fVolumetricCloudMaxDistance;
    if ( !*v35 && v34 > CClouds::m_fVolumetricCloudMaxDistance )
    {
      v37 = v25;
      if ( v25 >= 179 )
        v37 = 179;
      CClouds::ms_vc.bUsed[v37] = 0;
      CClouds::ms_vc.bJustCreated[v37] = 0;
      goto LABEL_89;
    }
    if ( v34 < CClouds::m_fVolumetricCloudMaxDistance )
    {
      *v35 = 0;
    }
    else if ( v34 > (float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0) )
    {
      *v35 = 0;
    }
    v38 = 0;
    if ( CClouds::ms_vc.alpha[v25] - (int)CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader > 0 )
      v38 = CClouds::ms_vc.alpha[v25] - (int)CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader;
    if ( v34 <= (float)(v36 + -100.0) )
    {
      v39 = v38;
    }
    else
    {
      if ( v34 > v36
        || CClouds::ms_vc.alpha[v25] - (int)CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader < 1 )
      {
        goto LABEL_89;
      }
      v39 = (int)(float)(int)(float)((float)((float)((float)(v36 - (float)(v36 + -100.0))
                                                   - (float)(v34 - (float)(v36 + -100.0)))
                                           * (float)v38)
                                   / (float)(v36 - (float)(v36 + -100.0)));
      if ( v39 <= 0 )
        v39 = 0;
      if ( v39 > v38 )
        v39 = v38;
      if ( !v39 )
        goto LABEL_89;
    }
    v40 = v28[91];
    v41 = v28[90];
    v42 = v40 - y;
    v43 = v28[92];
    v44 = v41 - x;
    v45 = v43 - z;
    v46 = (float *)&CClouds::ms_vc.bUsed[12 * v25];
    v47 = v46 + 632;
    v48 = v46[631];
    v49 = 0;
    v50 = v46[630];
    v51 = 0;
    v52 = *v47;
    v53 = (float)v39;
    pPos.y = v40 - y;
    pPos.x = v41 - x;
    v54 = v43 - z;
    pPos.z = v43 - z;
    v55 = v40 - y;
    v56 = v41 - x;
    if ( (float)(v40 - y) != 0.0 )
      v51 = 1;
    if ( (float)(v41 - x) != 0.0 )
      v49 = 1;
    LODWORD(v57) = v51 | v49;
    HIDWORD(v57) = v45 != 0.0;
    v58 = v57 | HIDWORD(v57);
    if ( v57 )
    {
      CVector::Normalise(&pPos);
      v56 = pPos.x;
      v55 = pPos.y;
      v54 = pPos.z;
    }
    pPos.y = v40 - y;
    v59 = (float)(CClouds::ms_vc.quadNormal[0].x * v56) + (float)(CClouds::ms_vc.quadNormal[0].y * v55);
    v60 = v40 - y;
    v61 = v59 + (float)(CClouds::ms_vc.quadNormal[0].z * v54);
    v62 = v41 - x;
    v63 = (int)(float)(fabsf(v61) * v53);
    pPos.x = v41 - x;
    v64 = v43 - z;
    pPos.z = v43 - z;
    if ( v58 )
    {
      CVector::Normalise(&pPos);
      v62 = pPos.x;
      v60 = pPos.y;
      v64 = pPos.z;
    }
    v65 = v63;
    pPos.y = v40 - y;
    pPos.x = v41 - x;
    pPos.z = v43 - z;
    v66 = (int)(float)(fabsf(
                         (float)((float)(CClouds::ms_vc.quadNormal[1].x * v62)
                               + (float)(CClouds::ms_vc.quadNormal[1].y * v60))
                       + (float)(CClouds::ms_vc.quadNormal[1].z * v64))
                     * v53);
    if ( v58 )
    {
      CVector::Normalise(&pPos);
      v44 = pPos.x;
      v42 = pPos.y;
      v45 = pPos.z;
    }
    v67 = CClouds::ms_vc.quadNormal[2].z;
    v68 = CClouds::ms_vc.quadNormal[2].x;
    v69 = CClouds::ms_vc.quadNormal[2].y;
    alpha = v65;
    v71 = blue;
    CRGBA::CRGBA((CRGBA *)&pPos, blue, blue, blue, alpha);
    CRGBA::CRGBA((CRGBA *)&pPos.y, v71, v71, v71, v66);
    CRGBA::CRGBA(
      (CRGBA *)&pPos.z,
      v71,
      v71,
      v71,
      (int)(float)(fabsf((float)((float)(v68 * v44) + (float)(v69 * v42)) + (float)(v67 * v45)) * v53));
    v72 = 0;
    v73 = -18;
    v74 = 0;
    do
    {
      while ( 1 )
      {
        HIDWORD(v75) = LODWORD(CClouds::ms_vc.modelV[v73]);
        ++v72;
        v76 = &TempVertexBuffer.m_3d[v26];
        v77 = *(float *)((char *)&CClouds::ms_vc + v73 * 4 + 5800);
        LODWORD(v75) = *((_DWORD *)&pPos.x + v74);
        v78 = v40 + (float)(v48 * CClouds::ms_vc.modelZ[v73]);
        v79 = v43 + (float)(v52 * CClouds::ms_vc.modelU[v73]);
        v76->position.x = v41 + (float)(v50 * CClouds::ms_vc.modelY[v73]);
        v76->position.y = v78;
        v76->position.z = v79;
        *(_QWORD *)&v76->color._anon_0._anon_0.red = v75;
        v76->texCoords.v = v77;
        v80 = v26 + 1;
        if ( v72 == 6 )
        {
          ++v74;
          v72 = 0;
        }
        if ( v26 >= 0 )
          break;
        ++v26;
        if ( !(++v73 * 4) )
          goto LABEL_88;
      }
      ++v26;
      if ( v80 == 2034 )
      {
        v26 = 0;
        if ( RwIm3DTransform(TempVertexBuffer.m_3d, 0x7F2u, 0, 9u) )
        {
          RwIm3DRenderPrimitive(rwPRIMTYPETRILIST);
          RwIm3DEnd();
          v26 = 0;
        }
      }
      ++v73;
    }
    while ( v73 * 4 );
LABEL_88:
    v24 = CClouds::m_VolumetricCloudsUsedNum;
LABEL_89:
    ++v25;
  }
  while ( v25 < v24 );
  if ( v26 >= 1 )
  {
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, v26, 0, 9u) )
    {
      RwIm3DRenderPrimitive(rwPRIMTYPETRILIST);
      RwIm3DEnd();
    }
  }
LABEL_93:
  CPostEffects::ImmediateModeRenderStatesReStore();
}
// 5A0ECC: variable 'v1' is possibly undefined
// 5A0ECC: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;
// A25AE0: using guessed type char `guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastCamera;
// A25AF4: using guessed type char `guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastPlayer;

//----- (005A1890) --------------------------------------------------------
float CClouds::MovingFog_GetFXIntensity()
{
  return CWeather::Foggyness_SF;
}

//----- (005A18A0) --------------------------------------------------------
CVector *__fastcall CClouds::MovingFog_GetWind(CVector *retstr)
{
  *retstr = CClouds::ms_mf.windVector;
  return retstr;
}

//----- (005A18C0) --------------------------------------------------------
Int32 CClouds::MovingFog_GetFirstFreeSlot()
{
  Int32 result; // r0

  result = 0;
  while ( CClouds::ms_mf.bUsed[result] )
  {
    if ( result++ >= 49 )
      return -1;
  }
  return result;
}

//----- (005A18E4) --------------------------------------------------------
void __fastcall CClouds::MovingFog_Delete(Int32 id)
{
  if ( id <= 0 )
    id = 0;
  if ( id >= 49 )
    id = (Int32)&word_30 + 1;
  CClouds::ms_mf.bUsed[id] = 0;
}
// 30: using guessed type __int16 word_30;

//----- (005A1900) --------------------------------------------------------
void __fastcall CClouds::MovingFog_Create(CVector *pPos)
{
  int v1; // r5
  int v2; // r6
  int v3; // r4
  float x; // s18
  float y; // s20
  float z; // s22
  float *v8; // r6
  int v9; // r0
  float v10; // s4
  int v11; // r0
  bool *v12; // r5

  v1 = 0;
  v2 = 0;
  v3 = 0;
  while ( CClouds::ms_mf.bUsed[v3] )
  {
    v1 += 4;
    v2 += 12;
    if ( v3++ >= 49 )
      return;
  }
  if ( v2 != -12 )
  {
    x = pPos->x;
    y = pPos->y;
    z = pPos->z;
    v8 = (float *)&CClouds::ms_mf.bUsed[v2];
    v8[13] = (float)((float)((float)rand() * 4.6566e-10) * 116.0) + -58.0;
    v8[14] = (float)((float)((float)rand() * 4.6566e-10) * 116.0) + -58.0;
    v9 = rand();
    v10 = y + v8[14];
    v8[13] = x + v8[13];
    v8[14] = v10;
    v8[15] = z + (float)((float)((float)((float)v9 * 4.6566e-10) * 10.0) + -5.0);
    v11 = rand();
    v12 = &CClouds::ms_mf.bUsed[v1];
    *((_DWORD *)v12 + 213) = 1065353216;
    *((float *)v12 + 163) = (float)((float)((float)v11 * 4.6566e-10) * 6.0) + 4.0;
    *((float *)v12 + 263) = (float)((float)((float)rand() * 4.6566e-10) * 12.0) + 8.0;
    *((float *)v12 + 316) = (float)((float)((float)rand() * 4.6566e-10) * 0.7) + 0.5;
    CClouds::ms_mf.bUsed[v3] = 1;
  }
}

//----- (005A1A74) --------------------------------------------------------
void CClouds::MovingFog_Update()
{
  __int64 v0; // d8
  __int64 v1; // d9
  __int64 v2; // d10
  __int64 v3; // d11
  __int64 v4; // d12
  __int64 v5; // d13
  signed int v6; // r5
  float y; // s16
  CSimpleTransform *p_tx; // r6
  float x; // s18
  __int64 v10; // d16
  int v11; // r11
  float v12; // s20
  int v13; // r9
  float v14; // s22
  float z; // s24
  int v16; // r8
  float *v17; // r1
  float *v18; // r0
  float *v19; // r2
  float v20; // s0
  float v21; // s2
  float v22; // s6
  float v23; // s4
  float v24; // s0
  float v25; // s0
  int v26; // r0
  float v27; // s2
  float *v28; // r1
  CVector pPos; // [sp+8h] [bp-68h] BYREF
  __int64 v30; // [sp+18h] [bp-58h]
  __int64 v31; // [sp+20h] [bp-50h]
  __int64 v32; // [sp+28h] [bp-48h]
  __int64 v33; // [sp+30h] [bp-40h]
  __int64 v34; // [sp+38h] [bp-38h]
  __int64 v35; // [sp+40h] [bp-30h]

  if ( CWeather::Foggyness_SF != 0.0 )
  {
    v30 = v0;
    v31 = v1;
    v32 = v2;
    v33 = v3;
    v34 = v4;
    v35 = v5;
    v6 = 50;
    y = CClouds::ms_mf.windVector.y;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    x = CClouds::ms_mf.windVector.x;
    v10 = *(_QWORD *)&p_tx->m_translate.x;
    pPos.z = *(RwReal *)&byte_8[(_DWORD)p_tx];
    *(_QWORD *)&pPos.x = v10;
    if ( !MobileSettings::settings[0].value )
      v6 = 25;
    if ( MobileSettings::settings[0].value == 1 )
      v6 = (unsigned int)(3 * v6) >> 2;
    if ( v6 )
    {
      v11 = 0;
      v12 = pPos.x;
      v13 = 0;
      v14 = pPos.y;
      z = pPos.z;
      v16 = 0;
      do
      {
        if ( CClouds::ms_mf.bUsed[v16] )
        {
          v17 = (float *)&CClouds::ms_mf.bUsed[v11 * 4];
          v18 = (float *)&CClouds::ms_mf.bUsed[v13 * 4];
          v19 = &CClouds::ms_mf.fSpeedFactor[v13];
          v20 = CClouds::ms_mf.fSize[v11 - 150];
          v21 = CClouds::ms_mf.fSize[v11 - 149];
          v22 = y * *v19;
          v23 = sqrtf(
                  (float)((float)((float)(v20 - v12) * (float)(v20 - v12))
                        + (float)((float)(v21 - v14) * (float)(v21 - v14)))
                + (float)((float)(CClouds::ms_mf.fSize[v11 - 148] - z) * (float)(CClouds::ms_mf.fSize[v11 - 148] - z)));
          v17[13] = v20 + (float)(x * *v19);
          v17[14] = v22 + v21;
          v24 = CClouds::ms_mf.fAlpha[v13];
          if ( v23 <= 60.0 )
          {
            v27 = CTimer::ms_fTimeStep + v24;
            v28 = &CClouds::ms_mf.fAlphaMax[v13];
            v18[213] = CTimer::ms_fTimeStep + v24;
            if ( v27 > *v28 )
              v18[213] = *v28;
          }
          else
          {
            v25 = v24 - CTimer::ms_fTimeStep;
            v18[213] = v25;
            if ( v25 <= 0.0 )
            {
              v26 = v16;
              if ( v16 >= 49 )
                v26 = 49;
              CClouds::ms_mf.bUsed[v26] = 0;
            }
          }
        }
        else
        {
          CClouds::MovingFog_Create(&pPos);
        }
        ++v16;
        v11 += 3;
        ++v13;
      }
      while ( v16 < v6 );
    }
  }
}
// 5A1A94: variable 'v0' is possibly undefined
// 5A1A94: variable 'v1' is possibly undefined
// 5A1A94: variable 'v2' is possibly undefined
// 5A1A94: variable 'v3' is possibly undefined
// 5A1A94: variable 'v4' is possibly undefined
// 5A1A94: variable 'v5' is possibly undefined

//----- (005A1C38) --------------------------------------------------------
void CClouds::MovingFogRender()
{
  float v0; // s19
  float v1; // s21
  float v2; // s23
  float v3; // s25
  float v4; // s27
  float v5; // s16
  float v6; // s0
  int v7; // r1
  float m_heading; // r4
  float v9; // r5
  int v10; // r2
  signed int v11; // r4
  int v12; // r9
  unsigned int v13; // r1
  unsigned int v14; // r3
  int v15; // r1
  int v16; // r10
  float *v17; // r0
  float v18; // s2
  float v19; // s0
  float *v20; // r0
  float v21; // s14
  float v22; // s8
  float v23; // s12
  float v24; // s4
  float v25; // s6
  float v26; // s10
  float v27; // s1
  float v28; // s3
  float v29; // s0
  float v30; // s5
  float v31; // s7
  float v32; // s9
  float v33; // s8
  float v34; // s4
  float v35; // s6
  int v36; // r6
  RwIm3DVertex *v37; // r0
  int v38; // r0
  float zx; // [sp+4h] [bp-94h]
  float xz; // [sp+8h] [bp-90h]
  float yz; // [sp+Ch] [bp-8Ch]
  float zz; // [sp+10h] [bp-88h]
  float xx; // [sp+14h] [bp-84h]
  float yx; // [sp+18h] [bp-80h]
  int v45; // [sp+24h] [bp-74h]

  if ( CWeather::Foggyness_SF == 0.0 || CGame::currArea || FindPlayerPed(-1)->m_areaCode )
    return;
  v5 = CTimer::ms_fTimeStep * 0.0033333;
  if ( CCullZones::CamNoRain() == 1 && CCullZones::PlayerNoRain() )
  {
    v6 = fgMovingFogAlphaFader - v5;
    fgMovingFogAlphaFader = fgMovingFogAlphaFader - v5;
    if ( fgMovingFogAlphaFader >= 0.0 )
      goto LABEL_11;
    v7 = 0;
    v6 = 0.0;
  }
  else
  {
    v6 = v5 + fgMovingFogAlphaFader;
    fgMovingFogAlphaFader = v5 + fgMovingFogAlphaFader;
    if ( fgMovingFogAlphaFader <= 1.0 )
      goto LABEL_11;
    v7 = 1065353216;
    v6 = 1.0;
  }
  LODWORD(fgMovingFogAlphaFader) = v7;
LABEL_11:
  if ( CWeather::UnderWaterness >= CPostEffects::m_fWaterFXStartUnderWaterness )
  {
    fgMovingFogAlphaFader = 0.0;
  }
  else if ( v6 != 0.0 )
  {
    if ( TheCamera.m_pMat )
    {
      xx = TheCamera.m_pMat->xx;
      yx = TheCamera.m_pMat->yx;
      zx = TheCamera.m_pMat->zx;
      xz = TheCamera.m_pMat->xz;
      yz = TheCamera.m_pMat->yz;
      zz = TheCamera.m_pMat->zz;
    }
    else
    {
      m_heading = TheCamera.m_transform.m_heading;
      v9 = cosf(TheCamera.m_transform.m_heading);
      zz = 1.0;
      yx = sinf(m_heading);
      xx = v9;
      xz = 0.0;
      yz = 0.0;
      zx = 0.0;
    }
    CPostEffects::ImmediateModeRenderStatesStore();
    CPostEffects::ImmediateModeRenderStatesSet();
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCloudTex[1]->raster);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    v10 = 255;
    v11 = 0;
    v12 = 0;
    v13 = CTimeCycle::m_CurrentColours.m_nSkyBottomGreen + 132;
    v14 = CTimeCycle::m_CurrentColours.m_nSkyBottomRed + 132;
    if ( v13 >= 0xFF )
      v13 = 255;
    if ( v14 >= 0xFF )
      v14 = 255;
    v15 = v14 | (v13 << 8);
    if ( (unsigned int)CTimeCycle::m_CurrentColours.m_nSkyBottomBlue + 132 < 0xFF )
      v10 = CTimeCycle::m_CurrentColours.m_nSkyBottomBlue + 132;
    v45 = v15 | (v10 << 16);
    do
    {
      if ( CClouds::ms_mf.bUsed[v12] )
      {
        v16 = 0;
        v17 = (float *)&CClouds::ms_mf.bUsed[4 * v12];
        v18 = v17[213];
        v19 = v17[163] * 0.5;
        v20 = (float *)&CClouds::ms_mf.bUsed[12 * v12];
        v21 = v20[15];
        v22 = v20[13];
        v23 = v20[14];
        v24 = zx * v19;
        v25 = yx * v19;
        v26 = xx * v19;
        v27 = zz * v19;
        v28 = yz * v19;
        v29 = xz * v19;
        v30 = v21 - v24;
        v31 = v23 - v25;
        v32 = v22 - v26;
        v33 = v22 + v26;
        v34 = v24 + v21;
        v35 = v23 + v25;
        v36 = v45 | ((int)(float)((float)(v18 * CWeather::Foggyness_SF) * fgMovingFogAlphaFader) << 24);
        do
        {
          switch ( CClouds::ms_mf.quadVT[v16] )
          {
            case 0:
              v0 = v29 + v33;
              v1 = v28 + v35;
              v2 = v27 + v34;
              v3 = 0.0;
              goto LABEL_32;
            case 1:
              v0 = v33 - v29;
              v1 = v35 - v28;
              v2 = v34 - v27;
              v3 = 0.0;
              v4 = 1.0;
              break;
            case 2:
              v0 = v32 - v29;
              v1 = v31 - v28;
              v2 = v30 - v27;
              v3 = 1.0;
              v4 = 1.0;
              break;
            case 3:
              v3 = 1.0;
              v0 = v29 + v32;
              v1 = v28 + v31;
              v2 = v27 + v30;
LABEL_32:
              v4 = 0.0;
              break;
            default:
              break;
          }
          v37 = &TempVertexBuffer.m_3d[v11];
          v37->position.x = v0;
          v37->position.y = v1;
          v37->position.z = v2;
          v37->color = (RwRGBA_0)v36;
          v37->texCoords.u = v4;
          v37->texCoords.v = v3;
          v38 = v11 + 1;
          if ( v11 < 0 )
          {
            ++v11;
          }
          else
          {
            ++v11;
            if ( v38 == 2046 )
            {
              v11 = 0;
              if ( RwIm3DTransform(TempVertexBuffer.m_3d, 0x7FEu, 0, 9u) )
              {
                RwIm3DRenderPrimitive(rwPRIMTYPETRILIST);
                RwIm3DEnd();
                v11 = 0;
              }
            }
          }
          ++v16;
        }
        while ( v16 != 6 );
      }
      ++v12;
    }
    while ( v12 != 50 );
    if ( v11 > 0 )
    {
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, v11, 0, 9u) )
      {
        RwIm3DRenderPrimitive(rwPRIMTYPETRILIST);
        RwIm3DEnd();
      }
    }
    CPostEffects::ImmediateModeRenderStatesReStore();
    CClouds::MovingFog_Update();
  }
}
// 5A1F96: variable 'v0' is possibly undefined
// 5A1F9A: variable 'v1' is possibly undefined
// 5A1F9E: variable 'v2' is possibly undefined
// 5A1FA4: variable 'v4' is possibly undefined
// 5A1FA8: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005A208C) --------------------------------------------------------
void __fastcall CRGBA::CRGBA(CRGBA *this, UInt8 red, UInt8 green, UInt8 blue, UInt8 alpha)
{
  this->_anon_0._anon_0.green = green;
  this->_anon_0._anon_0.red = red;
  this->_anon_0._anon_0.blue = blue;
  this->_anon_0._anon_0.alpha = alpha;
}

//----- (005A209C) --------------------------------------------------------
void __fastcall CRegisteredCorona::Update(CRegisteredCorona *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  char v5; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v7; // d16
  CSimpleTransform *p_m_transform; // r2
  unsigned int Intensity; // r0
  bool v10; // zf
  unsigned int FadedIntensity; // r1
  unsigned int v12; // s0
  CVector vecEnd; // [sp+18h] [bp-18h] BYREF

  if ( !this->RegisteredThisFrame )
    this->Intensity = 0;
  if ( (*((_BYTE *)this + 54) & 0x10) != 0 && !this->pEntityAttachedTo )
  {
    this->Identifier = 0;
    --CCoronas::NumCoronas;
    return;
  }
  v5 = *((_BYTE *)this + 52);
  if ( (v5 & 1) != 0 )
  {
    if ( CCoronas::SunBlockedByClouds && this->Identifier == 2 )
      goto LABEL_17;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v7 = *(_QWORD *)&p_tx->m_translate.x;
    vecEnd.z = *(RwReal *)&byte_8[(_DWORD)p_tx];
    *(_QWORD *)&vecEnd.x = v7;
    if ( !CWorld::GetIsLineOfSightClear(&this->Coordinates, &vecEnd, 1, 0, 0, 0, 0, 0, 0) )
      goto LABEL_17;
    v5 = *((_BYTE *)this + 52);
  }
  if ( (v5 & 2) == 0 )
  {
    if ( (*((_BYTE *)this + 54) & 2) == 0 )
      goto LABEL_23;
    p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_m_transform = &TheCamera.m_transform;
    if ( p_m_transform->m_translate.z <= this->Coordinates.z )
    {
LABEL_23:
      Intensity = this->Intensity;
      FadedIntensity = this->FadedIntensity;
      if ( Intensity <= FadedIntensity )
      {
        if ( Intensity >= FadedIntensity )
        {
          Intensity = this->FadedIntensity;
LABEL_32:
          if ( this->Identifier == 2 )
          {
            v3.n64_u32[0] = 1058642330;
            v1.n64_f32[0] = CCoronas::ScreenMult + (float)(CTimer::ms_fTimeStep * -0.06);
            LODWORD(CCoronas::ScreenMult) = vmax_f32(v1, v3).n64_u32[0];
          }
          goto LABEL_18;
        }
        v2.n64_f32[0] = (float)Intensity;
        v1.n64_f32[0] = (float)this->FadedIntensity - (float)(CTimer::ms_fTimeStep * this->FadeSpeed);
        v1.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
      }
      else
      {
        v2.n64_f32[0] = (float)Intensity;
        v1.n64_f32[0] = (float)(CTimer::ms_fTimeStep * this->FadeSpeed) + (float)this->FadedIntensity;
        v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
      }
      v12 = (unsigned int)v1.n64_f32[0];
      this->FadedIntensity = v12;
      if ( !CCoronas::bChangeBrightnessImmediately )
        Intensity = v12;
      this->FadedIntensity = Intensity;
      goto LABEL_32;
    }
  }
LABEL_17:
  v2.n64_u32[0] = 0;
  v1.n64_f32[0] = (float)this->FadedIntensity - (float)(CTimer::ms_fTimeStep * this->FadeSpeed);
  Intensity = (unsigned int)vmax_f32(v1, v2).n64_f32[0];
  this->FadedIntensity = Intensity;
LABEL_18:
  v10 = Intensity == 0;
  if ( !Intensity )
    v10 = this->JustCreated == 0;
  if ( v10 )
  {
    this->Identifier = 0;
    --CCoronas::NumCoronas;
  }
  this->RegisteredThisFrame = 0;
  this->JustCreated = 0;
}
// 5A2176: variable 'v1' is possibly undefined
// 5A2176: variable 'v2' is possibly undefined
// 5A227C: variable 'v3' is possibly undefined

//----- (005A22C8) --------------------------------------------------------
void CCoronas::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  unsigned __int8 *v2; // r1
  int v3; // r6
  Int32 v4; // r4
  int v5; // r5
  int LookDirection; // r0
  int v7; // r0
  int v8; // r4

  v1.n64_u32[0] = 1.0;
  v0.n64_f32[0] = CCoronas::ScreenMult + (float)(CTimer::ms_fTimeStep * 0.03);
  LODWORD(CCoronas::ScreenMult) = vmin_f32(v0, v1).n64_u32[0];
  v2 = (unsigned __int8 *)&TheCamera + 528 * TheCamera.ActiveCam;
  v3 = v2[375];
  v4 = v2[376];
  v5 = v2[377];
  LookDirection = CCamera::GetLookDirection(&TheCamera);
  if ( v5 )
    v4 |= 2u;
  if ( v3 )
    v4 |= 4u;
  if ( !LookDirection )
    v4 |= 8u;
  if ( v4 == CCoronas::Update(void)::LastCamLook )
  {
    v7 = CCoronas::bChangeBrightnessImmediately - 1;
    if ( CCoronas::bChangeBrightnessImmediately - 1 <= 0 )
      v7 = 0;
  }
  else
  {
    v7 = 3;
  }
  CCoronas::Update(void)::LastCamLook = v4;
  v8 = 0;
  CCoronas::bChangeBrightnessImmediately = v7;
  do
  {
    if ( CCoronas::aCoronas[v8].Identifier )
      CRegisteredCorona::Update(&CCoronas::aCoronas[v8]);
    ++v8;
  }
  while ( v8 != 64 );
}
// 5A2304: variable 'v0' is possibly undefined
// 5A2304: variable 'v1' is possibly undefined

//----- (005A23B8) --------------------------------------------------------
void CCoronas::Render()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d14
  __int64 v2; // r4
  float v3; // s16
  float v4; // s20
  float v5; // s22
  int v6; // r10
  CRegisteredCorona *v7; // r8
  CRegisteredCorona *v8; // r5
  UInt8 *p_FadedIntensity; // r5
  int FadedIntensity; // t1
  CEntity *pEntityAttachedTo; // r9
  int v12; // r0
  bool v13; // zf
  const CMatrix *p_m_transform; // r1
  RwReal z; // r0
  __int64 v16; // d16
  int v17; // r0
  CRegisteredCorona *v18; // r1
  _BYTE *v19; // r1
  int v20; // r2
  int v21; // t1
  float x; // s0
  int v23; // r0
  float v24; // s31
  float Range; // s0
  float v26; // s2
  float v27; // s0
  int v28; // r0
  int v29; // r0
  char *v30; // r1
  CRegisteredCorona *v31; // r6
  void ***p_pTex; // r6
  RwTexture_0 *pTex; // t1
  float v34; // s30
  CSimpleTransform *p_tx; // r1
  RwReal v36; // s2
  RwReal v37; // s4
  float PullTowardsCam; // s6
  CRegisteredCorona *v39; // r0
  CRegisteredCorona *v40; // r1
  int v41; // r0
  UInt8 *p_FlareType; // r1
  int FlareType; // t1
  CFlareDefinition *v44; // r6
  unsigned int v45; // r4
  int v46; // r8
  float v47; // s2
  float v48; // s0
  float *p_Sprite; // r5
  CRegisteredCorona *v50; // r0
  UInt8 *p_Blue; // r8
  UInt8 *p_Green; // r4
  UInt8 *p_Red; // r6
  float v54; // s31
  unsigned int v55; // s0
  CSimpleTransform *v56; // r1
  int v57; // t1
  float v58; // s0
  CRegisteredCorona *v59; // r0
  UInt8 *v60; // r11
  Int16 *i; // r6
  float v62; // s2
  unsigned int v63; // s0
  float v64; // s2
  float v65; // r3
  __int16 v66; // r1
  unsigned int v67; // s0
  float v68; // s2
  __int16 v69; // r3
  float v70; // r2
  int v71; // [sp+68h] [bp-E8h]
  UInt8 *v72; // [sp+8Ch] [bp-C4h]
  UInt8 *v73; // [sp+8Ch] [bp-C4h]
  int Intensity16; // [sp+90h] [bp-C0h]
  CEntity *refEntityPtr; // [sp+94h] [bp-BCh] BYREF
  CColPoint v76; // [sp+98h] [bp-B8h] BYREF
  CVector v77; // [sp+C4h] [bp-8Ch] BYREF
  RwV3d_0 In; // [sp+D0h] [bp-80h] BYREF
  float pScaleY; // [sp+DCh] [bp-74h] BYREF
  float pScaleX; // [sp+E0h] [bp-70h] BYREF
  RwV3d_0 pResult; // [sp+E4h] [bp-6Ch] BYREF

  v2 = *(_QWORD *)&Scene.camera->frameBuffer->width;
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  v3 = (float)SHIDWORD(v2);
  v4 = (float)(SHIDWORD(v2) / 2);
  v5 = (float)((int)v2 / 2);
  v6 = 0;
  v71 = 1;
  do
  {
    v7 = &CCoronas::aCoronas[v6];
    if ( v7->Identifier )
    {
      v8 = &CCoronas::aCoronas[v6];
      FadedIntensity = v8->FadedIntensity;
      p_FadedIntensity = &v8->FadedIntensity;
      if ( FadedIntensity || CCoronas::aCoronas[v6].Intensity )
      {
        pEntityAttachedTo = CCoronas::aCoronas[v6].pEntityAttachedTo;
        if ( pEntityAttachedTo )
        {
          v12 = *(_BYTE *)&pEntityAttachedTo->m_info & 7;
          v13 = v12 == 2;
          if ( v12 == 2 )
            v13 = LODWORD(pEntityAttachedTo[24].m_transform.m_translate.x) == 9;
          if ( v13 )
          {
            p_m_transform = (const CMatrix *)&pEntityAttachedTo[25].m_transform;
          }
          else
          {
            p_m_transform = pEntityAttachedTo->m_pMat;
            if ( !p_m_transform )
            {
              CPlaceable::AllocateMatrix(CCoronas::aCoronas[v6].pEntityAttachedTo);
              CSimpleTransform::UpdateMatrix(&pEntityAttachedTo->m_transform, pEntityAttachedTo->m_pMat);
              p_m_transform = pEntityAttachedTo->m_pMat;
            }
          }
          operator*(&v76.m_vecPosition, p_m_transform, &CCoronas::aCoronas[v6].Coordinates);
          v16 = *(_QWORD *)&v76.m_vecPosition.x;
          z = v76.m_vecPosition.z;
        }
        else
        {
          z = v7->Coordinates.z;
          v16 = *(_QWORD *)&v7->Coordinates.x;
        }
        In.z = z;
        *(_QWORD *)&In.x = v16;
        v17 = CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 1, 1);
        v18 = &CCoronas::aCoronas[v6];
        v21 = *((unsigned __int8 *)v18 + 52);
        v19 = (char *)v18 + 52;
        v20 = v21;
        if ( v17 != 1 )
        {
          *v19 = v20 | 2;
          goto LABEL_59;
        }
        x = pResult.x;
        v23 = v20 & 0xFD;
        *v19 = v20 & 0xFD;
        if ( x < 0.0 || pResult.y > v3 || pResult.y < 0.0 )
        {
          v23 = v20 | 2;
          *v19 = v20 | 2;
        }
        if ( *p_FadedIntensity )
        {
          v24 = pResult.z;
          Range = CCoronas::aCoronas[v6].Range;
          if ( pResult.z < Range )
          {
            v26 = Range * 0.5;
            v27 = 1.0;
            if ( pResult.z >= v26 )
              v27 = 1.0 - (float)((float)(pResult.z - v26) / v26);
            Intensity16 = (int)(float)(v27 * (float)*p_FadedIntensity);
            if ( v23 << 31 )
            {
              if ( !(v71 << 31) )
              {
                v28 = 0;
                goto LABEL_32;
              }
              v29 = 0;
              v30 = 0;
            }
            else
            {
              if ( v71 << 31 )
              {
                v28 = 1;
LABEL_32:
                v71 = v28;
                goto LABEL_33;
              }
              v29 = 1;
              v30 = (char *)&dword_0 + 1;
            }
            v71 = v29;
            RwRenderStateSet(rwRENDERSTATEZTESTENABLE, v30);
LABEL_33:
            v31 = &CCoronas::aCoronas[v6];
            pTex = v31->pTex;
            p_pTex = (void ***)&v31->pTex;
            if ( pTex )
            {
              v1.n64_u32[0] = LODWORD(pResult.z);
              v34 = CWeather::Foggyness;
              if ( v7->Identifier == 1 )
                pResult.z = Scene.camera->farPlane * 0.95;
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
              RwRenderStateSet(rwRENDERSTATETEXTURERASTER, **p_pTex);
              v76.m_vecPosition = (CVector)In;
              p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              if ( !TheCamera.m_pMat )
                p_tx = &TheCamera.m_transform;
              v36 = In.y - p_tx->m_translate.y;
              v37 = In.z - p_tx->m_translate.z;
              v77.x = In.x - p_tx->m_translate.x;
              v77.y = v36;
              v77.z = v37;
              CVector::Normalise(&v77);
              PullTowardsCam = CCoronas::aCoronas[v6].PullTowardsCam;
              v76.m_vecPosition.x = v76.m_vecPosition.x - (float)(PullTowardsCam * v77.x);
              v76.m_vecPosition.y = v76.m_vecPosition.y - (float)(PullTowardsCam * v77.y);
              v76.m_vecPosition.z = v76.m_vecPosition.z - (float)(PullTowardsCam * v77.z);
              if ( CSprite::CalcScreenCoors(&v76.m_vecPosition, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
              {
                v0.n64_u32[0] = 1109393408;
                v39 = &CCoronas::aCoronas[v6];
                v0.n64_u64[0] = vmin_f32(v1, v0).n64_u64[0];
                v0.n64_f32[0] = (float)((float)(v34 * v0.n64_f32[0]) / 40.0) + 1.0;
                CSprite::RenderOneXLUSprite_Rotate_Aspect(
                  pResult.x,
                  pResult.y,
                  pResult.z,
                  v39->Size * pScaleX,
                  v0.n64_f32[0] * (float)(v39->Size * pScaleY),
                  (unsigned int)(float)((float)v39->Red / v0.n64_f32[0]),
                  (unsigned int)(float)((float)v39->Green / v0.n64_f32[0]),
                  (unsigned int)(float)((float)v39->Blue / v0.n64_f32[0]),
                  Intensity16,
                  (float)(1.0 / v24) * 20.0,
                  0.0,
                  0xFFu);
              }
            }
            v40 = &CCoronas::aCoronas[v6];
            FlareType = v40->FlareType;
            p_FlareType = &v40->FlareType;
            v41 = FlareType;
            if ( FlareType )
            {
              v44 = SunFlareDef;
              if ( v41 != 1 )
              {
                if ( v41 == 2 )
                  v44 = HeadLightsFlareDef;
                else
                  v44 = 0;
              }
              v72 = p_FlareType;
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
              v45 = *p_FadedIntensity;
              v46 = rand();
              RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaTexture[0]->raster);
              v47 = (float)v46;
              v48 = (float)v45;
              if ( v44->Sprite )
              {
                p_Sprite = (float *)&v44[1].Sprite;
                v50 = &CCoronas::aCoronas[v6];
                p_Blue = &v50->Blue;
                p_Green = &v50->Green;
                p_Red = &v50->Red;
                v54 = (float)((float)((float)((float)(v47 * 4.6566e-10) * 0.3) + 0.7) * v48) * 0.000015259;
                do
                {
                  LOBYTE(v77.x) = (unsigned int)(float)(v54 * (float)(*((__int16 *)p_Sprite - 14) * *p_Red));
                  BYTE1(v77.x) = (unsigned int)(float)(v54 * (float)(*((__int16 *)p_Sprite - 13) * *p_Green));
                  v55 = (unsigned int)(float)(v54 * (float)(*((__int16 *)p_Sprite - 12) * *p_Blue));
                  HIBYTE(v77.x) = -1;
                  BYTE2(v77.x) = v55;
                  v56 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
                  if ( !TheCamera.m_pMat )
                    v56 = &TheCamera.m_transform;
                  if ( !CWorld::ProcessLineOfSight(
                          (const CVector *)&In,
                          &v56->m_translate,
                          &v76,
                          &refEntityPtr,
                          0,
                          1,
                          1,
                          0,
                          0,
                          0,
                          0,
                          1) )
                    CSprite::RenderBufferedOneXLUSprite2D(
                      (float)(*(p_Sprite - 9) * (float)(pResult.x - v5)) + v5,
                      (float)(*(p_Sprite - 9) * (float)(pResult.y - v4)) + v4,
                      *(p_Sprite - 8) * 4.0,
                      *(p_Sprite - 8) * 4.0,
                      (const RwRGBA_0 *)&v77,
                      255,
                      0xFFu);
                  v57 = *(unsigned __int16 *)p_Sprite;
                  p_Sprite += 5;
                }
                while ( v57 );
              }
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
              if ( HeadLightsFlareDef[0].Sprite )
              {
                if ( *v72 == 2 )
                {
                  v58 = CWeather::HeadLightsSpectrum;
                  if ( CWeather::HeadLightsSpectrum != 0.0 && CGame::currArea == AREA_MAIN_MAP )
                  {
                    v59 = &CCoronas::aCoronas[v6];
                    v60 = &v59->Red;
                    v73 = &v59->Blue;
                    for ( i = &HeadLightsFlareDef[1].Sprite; ; i += 10 )
                    {
                      v62 = (float)(*(i - 14) * *v60);
                      *(_WORD *)((char *)&v76.m_vecPosition.x + 1) = 0;
                      v63 = (unsigned int)(float)((float)(v58 * v62) * 0.0039062);
                      v64 = *((float *)i - 9) + 0.05;
                      HIBYTE(v76.m_vecPosition.x) = -1;
                      v65 = *((float *)i - 8);
                      LOBYTE(v76.m_vecPosition.x) = v63;
                      CSprite::RenderBufferedOneXLUSprite2D(
                        (float)(v64 * (float)(pResult.x - v5)) + v5,
                        (float)(v64 * (float)(pResult.y - v4)) + v4,
                        v65,
                        v65,
                        (const RwRGBA_0 *)&v76,
                        (*(i - 11) * (__int16)Intensity16) >> 8,
                        0xFFu);
                      v66 = *(i - 12);
                      LOWORD(v76.m_vecPosition.x) = 0;
                      v67 = (unsigned int)(float)((float)(CWeather::HeadLightsSpectrum * (float)(v66 * *v73)) * 0.0039062);
                      v68 = *((float *)i - 9) + -0.05;
                      HIBYTE(v76.m_vecPosition.x) = -1;
                      v69 = *(i - 11);
                      v70 = *((float *)i - 8);
                      BYTE2(v76.m_vecPosition.x) = v67;
                      CSprite::RenderBufferedOneXLUSprite2D(
                        (float)(v68 * (float)(pResult.x - v5)) + v5,
                        (float)(v68 * (float)(pResult.y - v4)) + v4,
                        v70,
                        v70,
                        (const RwRGBA_0 *)&v76,
                        (v69 * (__int16)Intensity16) >> 8,
                        0xFFu);
                      if ( !*i )
                        break;
                      v58 = CWeather::HeadLightsSpectrum;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_59:
    ++v6;
  }
  while ( v6 != 64 );
  CSprite::FlushSpriteBuffer();
}
// 5A27EC: variable 'v1' is possibly undefined
// 5A27EC: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005A2C04) --------------------------------------------------------
void CCoronas::RenderReflections()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  __int64 v2; // d8
  __int64 v3; // d9
  __int64 v4; // d10
  float32x2_t v5; // d11
  __int64 v6; // d12
  float32x2_t v7; // d13
  __int64 v8; // d14
  float32x2_t v9; // d15
  int v10; // r8
  int v11; // r4
  CEntity *pEntityAttachedTo; // r6
  const CMatrix *m_pMat; // r1
  __int64 v14; // d16
  RwReal z; // r0
  CRegisteredCorona *v16; // r6
  float HeightAboveGround; // s17
  CSimpleTransform *p_tx; // r1
  float v19; // s4
  CRegisteredCorona *v20; // r6
  float v21; // s17
  float v22; // r0
  int i; // r0
  CRegisteredCorona *v24; // r2
  float y; // [sp+20h] [bp-108h]
  float x; // [sp+24h] [bp-104h]
  CVector v27; // [sp+60h] [bp-C8h] BYREF
  CVector vecStart; // [sp+70h] [bp-B8h] BYREF
  CEntity *refEntityPtr; // [sp+7Ch] [bp-ACh] BYREF
  CColPoint colPoint; // [sp+80h] [bp-A8h] BYREF
  float pScaleY; // [sp+ACh] [bp-7Ch] BYREF
  float pScaleX; // [sp+B0h] [bp-78h] BYREF
  RwV3d_0 pResult; // [sp+B4h] [bp-74h] BYREF
  __int64 v34; // [sp+C0h] [bp-68h]
  __int64 v35; // [sp+C8h] [bp-60h]
  __int64 v36; // [sp+D0h] [bp-58h]
  unsigned __int64 v37; // [sp+D8h] [bp-50h]
  __int64 v38; // [sp+E0h] [bp-48h]
  unsigned __int64 v39; // [sp+E8h] [bp-40h]
  __int64 v40; // [sp+F0h] [bp-38h]
  unsigned __int64 v41; // [sp+F8h] [bp-30h]

  if ( CWeather::WetRoads <= 0.0 )
  {
    for ( i = 0; i != 64; ++i )
    {
      v24 = &CCoronas::aCoronas[i];
      *((_BYTE *)v24 + 54) &= ~4u;
    }
  }
  else
  {
    v34 = v2;
    v35 = v3;
    v36 = v4;
    v37 = v5.n64_u64[0];
    v38 = v6;
    v39 = v7.n64_u64[0];
    v40 = v8;
    v41 = v9.n64_u64[0];
    CSprite::InitSpriteBuffer();
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaTexture[3]->raster);
    v7.n64_u32[0] = 1.0;
    v10 = 0;
    v5.n64_u32[0] = 1113325568;
    v11 = 0;
    v9.n64_u32[0] = 0;
    do
    {
      if ( CCoronas::aCoronas[v10].Identifier
        && (CCoronas::aCoronas[v10].FadedIntensity || CCoronas::aCoronas[v10].Intensity)
        && CCoronas::aCoronas[v10].ReflectionType )
      {
        pEntityAttachedTo = CCoronas::aCoronas[v10].pEntityAttachedTo;
        if ( pEntityAttachedTo )
        {
          m_pMat = pEntityAttachedTo->m_pMat;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(CCoronas::aCoronas[v10].pEntityAttachedTo);
            CSimpleTransform::UpdateMatrix(&pEntityAttachedTo->m_transform, pEntityAttachedTo->m_pMat);
            m_pMat = pEntityAttachedTo->m_pMat;
          }
          operator*(&v27, m_pMat, &CCoronas::aCoronas[v10].Coordinates);
          v14 = *(_QWORD *)&v27.x;
          z = v27.z;
        }
        else
        {
          v14 = *(_QWORD *)&CCoronas::aCoronas[v10].Coordinates.x;
          z = CCoronas::aCoronas[v10].Coordinates.z;
        }
        vecStart.z = z;
        *(_QWORD *)&vecStart.x = v14;
        v16 = &CCoronas::aCoronas[v10];
        if ( (*((_BYTE *)&CCoronas::aCoronas[v10] + 54) & 4) != 0 )
        {
          if ( !((CTimer::m_FrameCounter + v11) << 28)
            && CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
          {
            CCoronas::aCoronas[v10].HeightAboveGround = vecStart.z - colPoint.m_vecPosition.z;
          }
        }
        else if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
        {
          CCoronas::aCoronas[v10].HeightAboveGround = vecStart.z - colPoint.m_vecPosition.z;
          *((_BYTE *)v16 + 54) |= 4u;
        }
        if ( (*((_BYTE *)v16 + 54) & 4) != 0 )
        {
          HeightAboveGround = CCoronas::aCoronas[v10].HeightAboveGround;
          if ( HeightAboveGround < 20.0 )
          {
            p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              p_tx = &TheCamera.m_transform;
            if ( p_tx->m_translate.z >= (float)(vecStart.z - HeightAboveGround) )
            {
              *(_QWORD *)&v27.x = *(_QWORD *)&vecStart.x;
              v27.z = vecStart.z + (float)(HeightAboveGround * -2.0);
              if ( CSprite::CalcScreenCoors(&v27, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
              {
                v1.n64_f32[0] = CCoronas::aCoronas[v10].Range * 0.75;
                v1.n64_u64[0] = vmin_f32(v1, v5).n64_u64[0];
                if ( pResult.z < v1.n64_f32[0] )
                {
                  v19 = v1.n64_f32[0] * 0.5;
                  v1.n64_u64[0] = v7.n64_u64[0];
                  if ( pResult.z >= v19 )
                  {
                    v0.n64_f32[0] = 1.0 - (float)((float)(pResult.z - v19) / v19);
                    v1.n64_u64[0] = vmax_f32(vmin_f32(v0, v7), v9).n64_u64[0];
                  }
                  x = pResult.x;
                  y = pResult.y;
                  v20 = &CCoronas::aCoronas[v10];
                  v21 = (float)(20.0 - HeightAboveGround) * (float)((float)(v1.n64_f32[0] * CWeather::WetRoads) * 230.0);
                  v22 = RwIm2DGetNearScreenZ();
                  CSprite::RenderBufferedOneXLUSprite(
                    x,
                    y,
                    v22,
                    (float)(v20->Size * pScaleX) * 0.75,
                    (float)(v20->Size + v20->Size) * pScaleY,
                    (unsigned __int16)(v20->Red * (unsigned __int16)(int)(float)(v21 / 20.0)) >> 8,
                    (unsigned __int16)(v20->Green * (unsigned __int16)(int)(float)(v21 / 20.0)) >> 8,
                    (unsigned __int16)(v20->Blue * (unsigned __int16)(int)(float)(v21 / 20.0)) >> 8,
                    128,
                    1.0 / Scene.camera->nearPlane,
                    0xFFu);
                }
              }
            }
          }
        }
      }
      ++v10;
      ++v11;
    }
    while ( v10 != 64 );
    CSprite::FlushSpriteBuffer();
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  }
}
// 5A2C26: variable 'v2' is possibly undefined
// 5A2C26: variable 'v3' is possibly undefined
// 5A2C26: variable 'v4' is possibly undefined
// 5A2C26: variable 'v5' is possibly undefined
// 5A2C26: variable 'v6' is possibly undefined
// 5A2C26: variable 'v7' is possibly undefined
// 5A2C26: variable 'v8' is possibly undefined
// 5A2C26: variable 'v9' is possibly undefined
// 5A2EB4: variable 'v1' is possibly undefined
// 5A2EE0: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005A3058) --------------------------------------------------------
void CCoronas::RenderOutGeometryBufferForReflections()
{
  if ( TempBufferIndicesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
  }
}

//----- (005A30D4) --------------------------------------------------------
float __fastcall FadeVectorLocation(CVector Location, float Range)
{
  float y; // s0
  float v3; // s0

  y = Location.y;
  LODWORD(Location.y) = &TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    LODWORD(Location.y) = &TheCamera.m_transform;
  v3 = sqrtf(
         (float)((float)(*(float *)LODWORD(Location.y) - Location.x)
               * (float)(*(float *)LODWORD(Location.y) - Location.x))
       + (float)((float)(*(float *)(LODWORD(Location.y) + 4) - y) * (float)(*(float *)(LODWORD(Location.y) + 4) - y)));
  if ( v3 >= (float)(Range + 100.0) )
    return 1.0;
  if ( v3 > Range )
    return (float)(v3 - Range) / 100.0;
  return 0.0;
}

//----- (005A3164) --------------------------------------------------------
void CCoronas::RenderSunReflection()
{
  __int64 v0; // d8
  __int64 v1; // d9
  __int64 v2; // d10
  __int64 v3; // d11
  __int64 v4; // d12
  __int64 v5; // d13
  __int64 v6; // d14
  float z; // s0
  float v8; // s22
  float v9; // s16
  float v10; // s2
  CSimpleTransform *p_tx; // r3
  float x; // s20
  float y; // s18
  float v14; // s4
  float v15; // s6
  float v16; // s2
  float v17; // s4
  float v18; // s6
  float v19; // s2
  float v20; // s4
  float v21; // s6
  float v22; // s2
  float v23; // s6
  float v24; // s4
  float v25; // s28
  float v26; // s6
  CVector *v27; // r0
  int m_nSunCoreBlue; // r8
  float v29; // s24
  float v30; // s26
  int m_nSunCoronaBlue; // r9
  int m_nSunCoreGreen; // r10
  int m_nSunCoronaGreen; // r4
  int m_nSunCoreRed; // r5
  int m_nSunCoronaRed; // r6
  int v36; // s4
  int v37; // r10
  int v38; // r0
  RwImVertexIndex *v39; // r8
  unsigned int v40; // r9
  unsigned int v41; // r6
  float v42; // s0
  float v43; // s16
  float v44; // s18
  unsigned int v45; // kr00_4
  unsigned int v46; // r6
  int v47; // r5
  float v48; // s24
  float v49; // s22
  float v50; // s20
  unsigned int v51; // r4
  float v52; // s4
  float v53; // s0
  __int16 v54; // r6
  int v55; // r5
  unsigned int v56; // kr04_4
  float v57; // r0
  float v58; // s0
  RwImVertexIndex v59; // r1
  float v60; // s2
  char *v61; // r0
  float v62; // s4
  float v63; // s0
  float v64; // s6
  float v65; // s2
  CVector v66; // [sp+8h] [bp-70h] BYREF
  __int64 v67; // [sp+18h] [bp-60h]
  __int64 v68; // [sp+20h] [bp-58h]
  __int64 v69; // [sp+28h] [bp-50h]
  __int64 v70; // [sp+30h] [bp-48h]
  __int64 v71; // [sp+38h] [bp-40h]
  __int64 v72; // [sp+40h] [bp-38h]
  __int64 v73; // [sp+48h] [bp-30h]

  z = CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].z;
  if ( z > -0.05 )
  {
    v67 = v0;
    v68 = v1;
    v69 = v2;
    v70 = v3;
    v71 = v4;
    v72 = v5;
    v73 = v6;
    v8 = 1.0;
    v9 = CWeather::Wind;
    v10 = (float)(1.0 - CWeather::Wind)
        * (float)((float)(1.0 - CWeather::Foggyness)
                * (float)((float)(1.0 - CWeather::CloudCoverage) * (float)((float)(0.3 - fabsf(z + -0.25)) * 3.333)));
    if ( v10 > 0.0 )
    {
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      x = p_tx->m_translate.x;
      y = p_tx->m_translate.y;
      v14 = 1.0;
      v15 = sqrtf(
              (float)((float)(p_tx->m_translate.x + -611.0) * (float)(p_tx->m_translate.x + -611.0))
            + (float)((float)(y + -875.0) * (float)(y + -875.0)));
      if ( v15 < 350.0 )
      {
        if ( v15 <= 250.0 )
          v14 = 0.0;
        else
          v14 = (float)(v15 + -250.0) / 100.0;
      }
      v16 = v10 * v14;
      v17 = 1.0;
      v18 = sqrtf((float)((float)(x + 929.0) * (float)(x + 929.0)) + (float)((float)(y + -2364.0) * (float)(y + -2364.0)));
      if ( v18 < 350.0 )
      {
        if ( v18 <= 250.0 )
          v17 = 0.0;
        else
          v17 = (float)(v18 + -250.0) / 100.0;
      }
      v19 = v16 * v17;
      v20 = 1.0;
      v21 = sqrtf((float)((float)(x + 1034.0) * (float)(x + 1034.0)) + (float)((float)(y + -2640.0)
                                                                             * (float)(y + -2640.0)));
      if ( v21 < 350.0 )
      {
        if ( v21 <= 250.0 )
          v20 = 0.0;
        else
          v20 = (float)(v21 + -250.0) / 100.0;
      }
      v22 = v19 * v20;
      v23 = sqrtf((float)((float)(x + -2372.0) * (float)(x + -2372.0)) + (float)((float)(y + 1854.0)
                                                                               * (float)(y + 1854.0)));
      v24 = 1.0;
      if ( v23 < 450.0 )
      {
        if ( v23 <= 350.0 )
          v24 = 0.0;
        else
          v24 = (float)(v23 + -350.0) / 100.0;
      }
      v25 = v22 * v24;
      v26 = sqrtf((float)((float)(x + 1633.0) * (float)(x + 1633.0)) + (float)((float)(y + -106.0) * (float)(y + -106.0)));
      if ( v26 < 350.0 )
      {
        if ( v26 <= 250.0 )
          v8 = 0.0;
        else
          v8 = (float)(v26 + -250.0) / 100.0;
      }
      v27 = &CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue];
      m_nSunCoreBlue = CTimeCycle::m_CurrentColours.m_nSunCoreBlue;
      v30 = v27->y;
      m_nSunCoronaBlue = CTimeCycle::m_CurrentColours.m_nSunCoronaBlue;
      m_nSunCoreGreen = CTimeCycle::m_CurrentColours.m_nSunCoreGreen;
      m_nSunCoronaGreen = CTimeCycle::m_CurrentColours.m_nSunCoronaGreen;
      m_nSunCoreRed = CTimeCycle::m_CurrentColours.m_nSunCoreRed;
      m_nSunCoronaRed = CTimeCycle::m_CurrentColours.m_nSunCoronaRed;
      v66.x = v27->x;
      v29 = v66.x;
      v66.y = v30;
      v66.z = 0.0;
      CVector::Normalise(&v66);
      v36 = m_nSunCoreGreen + m_nSunCoronaGreen;
      v37 = 0;
      v38 = m_nSunCoreBlue + m_nSunCoronaBlue;
      v39 = &TempBufferRenderIndexList[11];
      v40 = 0;
      v41 = (unsigned int)(float)((float)((float)(v25 * v8) * 0.25) * (float)(m_nSunCoreRed + m_nSunCoronaRed));
      v42 = v9 * 0.5;
      v43 = (float)(v29 * 40.0) + x;
      v44 = (float)(v30 * 40.0) + y;
      v45 = (unsigned int)(float)((float)((float)(v25 * v8) * 0.25) * (float)v36)
          + v41
          + (unsigned int)(float)((float)((float)(v25 * v8) * 0.25) * (float)v38);
      *(_DWORD *)TempBufferRenderIndexList = 65538;
      *(_DWORD *)&TempBufferRenderIndexList[2] = 0x20000;
      v46 = v41 + v45 / 3;
      *(_DWORD *)&TempBufferRenderIndexList[4] = 65539;
      v47 = (unsigned __int8)((v45 / 3 + (unsigned __int8)(v46 >> 1)) >> 1);
      v48 = v66.y;
      v49 = v66.x;
      v50 = v42 + 0.1;
      v51 = (unsigned __int8)(v46 >> 1) | (v47 << 8) | (v47 << 16) | 0xFF000000;
      v52 = v44 + (float)(v66.y * 60.0);
      v53 = v43 + (float)(v66.x * 60.0);
      TempVertexBuffer.m_3d[0].position.x = v43 + (float)(v66.y * 30.0);
      TempVertexBuffer.m_3d[0].position.y = v44 - (float)(v66.x * 30.0);
      TempVertexBuffer.m_3d[0].position.z = v50;
      TempVertexBuffer.m_3d[1].position.x = v43 - (float)(v66.y * 30.0);
      TempVertexBuffer.m_3d[1].position.y = v44 + (float)(v66.x * 30.0);
      TempVertexBuffer.m_3d[1].position.z = v50;
      TempVertexBuffer.m_3d[2].position.x = v53 + (float)(v66.y * 30.0);
      TempVertexBuffer.m_3d[2].position.y = v52 - (float)(v66.x * 30.0);
      TempVertexBuffer.m_3d[2].position.z = v50;
      TempVertexBuffer.m_3d[1].color = (RwRGBA_0)v51;
      TempVertexBuffer.m_3d[2].color = (RwRGBA_0)v51;
      TempVertexBuffer.m_3d[3].color = (RwRGBA_0)v51;
      TempVertexBuffer.m_3d[3].position.x = v53 - (float)(v66.y * 30.0);
      TempVertexBuffer.m_3d[3].position.y = (float)(v66.x * 30.0) + v52;
      TempVertexBuffer.m_3d[3].position.z = v50;
      TempVertexBuffer.m_3d[2].texCoords.v = 0.5;
      TempVertexBuffer.m_3d[3].texCoords.v = 0.5;
      TempVertexBuffer.m_3d[0].color = (RwRGBA_0)v51;
      TempVertexBuffer.m_3d[0].texCoords.u = 0.0;
      TempVertexBuffer.m_3d[0].texCoords.v = 1.0;
      TempVertexBuffer.m_3d[1].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[1].texCoords.v = 1.0;
      TempVertexBuffer.m_3d[2].texCoords.u = 0.0;
      TempVertexBuffer.m_3d[3].texCoords.u = 1.0;
      v54 = CTimer::m_snTimeInMilliseconds;
      TempBufferVerticesStored = 4;
      v55 = 0;
      TempBufferIndicesStored = 6;
      do
      {
        v56 = v40;
        v57 = sinf((float)(v54 & 0x7FF) * 0.003068);
        v40 += 970;
        v58 = (float)(v37 + 60);
        v59 = (unsigned __int16)&elf_hash_bucket[16321] + 3 + v55;
        *(v39 - 4) = v59;
        v54 += 900;
        *(v39 - 3) = (unsigned __int16)&elf_hash_bucket[16321] + 2 + v55;
        *(v39 - 5) = v55 + 4;
        *(v39 - 2) = v55 + 4;
        *(v39 - 1) = v55 + 5;
        v60 = (float)(v57 * 10.0) + (float)(int)(v56 / 0x14 + 30);
        *v39 = v59;
        v61 = (char *)&TempVertexBuffer + v37;
        v37 += 72;
        v55 += 2;
        v39 += 6;
        *((_DWORD *)v61 + 42) = v51;
        *((_DWORD *)v61 + 43) = 0;
        v62 = v44 + (float)(v48 * v58);
        v63 = v43 + (float)(v49 * v58);
        *((_DWORD *)v61 + 44) = 1056964608;
        v64 = v60 * v48;
        *((_DWORD *)v61 + 51) = v51;
        v65 = v60 * v49;
        *((_DWORD *)v61 + 52) = 1065353216;
        *((_DWORD *)v61 + 53) = 1056964608;
        *((float *)v61 + 36) = v63 + v64;
        *((float *)v61 + 37) = v62 - v65;
        *((float *)v61 + 38) = v50;
        *((float *)v61 + 45) = v63 - v64;
        *((float *)v61 + 46) = v65 + v62;
        *((float *)v61 + 47) = v50;
      }
      while ( v37 != 1440 );
      TempBufferIndicesStored = 126;
      TempBufferVerticesStored = 44;
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEFOGTYPE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaTexture[4]->raster);
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
      TempBufferIndicesStored = 0;
      TempBufferVerticesStored = 0;
    }
  }
}
// 5A319C: variable 'v0' is possibly undefined
// 5A319C: variable 'v1' is possibly undefined
// 5A319C: variable 'v2' is possibly undefined
// 5A319C: variable 'v3' is possibly undefined
// 5A319C: variable 'v4' is possibly undefined
// 5A319C: variable 'v5' is possibly undefined
// 5A319C: variable 'v6' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005A3840) --------------------------------------------------------
void CCoronas::Init()
{
  int32 TxdSlot; // r0
  int v1; // r4
  RwTexture_0 **v2; // r5
  int i; // r2
  CRegisteredCorona *v4; // r3

  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  v1 = 0;
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  v2 = gpCoronaTexture;
  do
  {
    if ( !*v2 && aCoronaSpriteNames[v1][0] )
      *v2 = RwTextureRead(aCoronaSpriteNames[v1], aCoronaSpriteNamesm[v1]);
    ++v1;
    ++v2;
  }
  while ( v1 != 10 );
  CTxdStore::PopCurrentTxd();
  for ( i = 0; i != 64; ++i )
  {
    v4 = &CCoronas::aCoronas[i];
    v4->Identifier = 0;
  }
  CCoronas::NumCoronas = 0;
}

//----- (005A38D4) --------------------------------------------------------
void CCoronas::Shutdown()
{
  if ( gpCoronaTexture[0] )
  {
    RwTextureDestroy(gpCoronaTexture[0]);
    gpCoronaTexture[0] = 0;
  }
  if ( gpCoronaTexture[1] )
  {
    RwTextureDestroy(gpCoronaTexture[1]);
    gpCoronaTexture[1] = 0;
  }
  if ( gpCoronaTexture[2] )
  {
    RwTextureDestroy(gpCoronaTexture[2]);
    gpCoronaTexture[2] = 0;
  }
  if ( gpCoronaTexture[3] )
  {
    RwTextureDestroy(gpCoronaTexture[3]);
    gpCoronaTexture[3] = 0;
  }
  if ( gpCoronaTexture[4] )
  {
    RwTextureDestroy(gpCoronaTexture[4]);
    gpCoronaTexture[4] = 0;
  }
  if ( gpCoronaTexture[5] )
  {
    RwTextureDestroy(gpCoronaTexture[5]);
    gpCoronaTexture[5] = 0;
  }
  if ( gpCoronaTexture[6] )
  {
    RwTextureDestroy(gpCoronaTexture[6]);
    gpCoronaTexture[6] = 0;
  }
  if ( gpCoronaTexture[7] )
  {
    RwTextureDestroy(gpCoronaTexture[7]);
    gpCoronaTexture[7] = 0;
  }
  if ( gpCoronaTexture[8] )
  {
    RwTextureDestroy(gpCoronaTexture[8]);
    gpCoronaTexture[8] = 0;
  }
  if ( gpCoronaTexture[9] )
  {
    RwTextureDestroy(gpCoronaTexture[9]);
    gpCoronaTexture[9] = 0;
  }
}

//----- (005A3A20) --------------------------------------------------------
void __fastcall CCoronas::RegisterCorona(
        u_native ID,
        CEntity *pAttachedToEntity,
        UInt8 R,
        UInt8 G,
        UInt8 B,
        unsigned int Intensity,
        const CVector *Coors,
        float Size,
        float Range,
        int CoronaType,
        UInt8 FlareType,
        UInt8 ReflType,
        UInt8 LOSCheck,
        UInt8 UsesTrails,
        float fNormalAngle,
        int bNeonFade,
        float ArgPullTowardsCam,
        bool bFullBrightAtStart,
        float FadeSpeed,
        bool bOnlyFromBelow,
        bool bWhiteCore)
{
  CCoronas::RegisterCorona(
    ID,
    pAttachedToEntity,
    R,
    G,
    B,
    Intensity,
    Coors,
    Size,
    Range,
    gpCoronaTexture[CoronaType],
    FlareType,
    ReflType,
    LOSCheck,
    0,
    fNormalAngle,
    bNeonFade,
    ArgPullTowardsCam,
    bFullBrightAtStart,
    FadeSpeed,
    bOnlyFromBelow,
    bWhiteCore);
}

//----- (005A3AAC) --------------------------------------------------------
void __fastcall CCoronas::RegisterCorona(
        u_native ID,
        CEntity *pAttachedToEntity,
        UInt8 R,
        UInt8 G,
        UInt8 B,
        unsigned int Intensity,
        const CVector *Coors,
        float Size,
        float Range,
        RwTexture_0 *pCoronaTex,
        UInt8 FlareType,
        UInt8 ReflType,
        UInt8 LOSCheck,
        UInt8 UsesTrails,
        float fNormalAngle,
        int bNeonFade,
        float ArgPullTowardsCam,
        bool bFullBrightAtStart,
        float FadeSpeed,
        bool bOnlyFromBelow,
        bool bWhiteCore)
{
  CMatrix *m_pMat; // r1
  float32x2_t v26; // d16
  float z; // s0
  CSimpleTransform *p_tx; // r2
  float32x2_t v29; // d16
  unsigned __int64 v30; // d1
  float v31; // s2
  unsigned int v32; // r1
  float v33; // s0
  unsigned __int16 v34; // lr
  bool v35; // r6
  u_native *p_Identifier; // r11
  int v37; // r2
  int v38; // r3
  u_native *v39; // r3
  int v40; // r2
  int v41; // r6
  char v42; // r11
  CRegisteredCorona *v43; // r2
  char v44; // r0
  CRegisteredCorona *v45; // r2
  __int64 v46; // d16
  char v47; // r1
  _BYTE *v48; // r2
  char v49; // t1
  char v50; // r0
  CRegisteredCorona *v51; // r1
  char v52; // [sp+4h] [bp-3Ch]
  CVector v53; // [sp+8h] [bp-38h] BYREF

  if ( pAttachedToEntity )
  {
    m_pMat = pAttachedToEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pAttachedToEntity);
      CSimpleTransform::UpdateMatrix(&pAttachedToEntity->m_transform, pAttachedToEntity->m_pMat);
      m_pMat = pAttachedToEntity->m_pMat;
    }
    operator*(&v53, m_pMat, Coors);
    v26.n64_u64[0] = *(unsigned __int64 *)&v53.x;
    z = v53.z;
  }
  else
  {
    v26.n64_u64[0] = *(unsigned __int64 *)&Coors->x;
    z = Coors->z;
  }
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v29.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, v26).n64_u64[0];
  v30 = vmul_f32(v29, v29).n64_u64[0];
  v31 = *(float *)&v30 + *((float *)&v30 + 1);
  if ( v31 <= (float)(Range * Range) )
  {
    v32 = Intensity;
    if ( bNeonFade == 1 )
    {
      v33 = sqrtf(v31 + (float)((float)(p_tx->m_translate.z - z) * (float)(p_tx->m_translate.z - z)));
      if ( v33 < 35.0 )
        return;
      if ( v33 < 50.0 )
        v32 = (unsigned int)(float)((float)((float)(v33 + -35.0) / 15.0) * (float)Intensity);
    }
    v34 = 0;
    v35 = bOnlyFromBelow;
    p_Identifier = &CCoronas::aCoronas[0].Identifier;
    v37 = 0;
    do
    {
      if ( *p_Identifier == ID )
      {
        v38 = v37;
        goto LABEL_24;
      }
      ++v34;
      p_Identifier += 15;
      ++v37;
      v38 = v34;
    }
    while ( v34 < 0x40u );
    if ( v34 == 64 )
    {
      if ( !v32 )
        return;
      v34 = 0;
      v39 = &CCoronas::aCoronas[0].Identifier;
      v40 = 0;
      do
      {
        if ( !*v39 )
        {
          v41 = v40;
          goto LABEL_27;
        }
        ++v34;
        v39 += 15;
        ++v40;
        v41 = v34;
      }
      while ( v34 < 0x40u );
      if ( v34 == 64 )
        return;
LABEL_27:
      v42 = bNeonFade;
      v43 = &CCoronas::aCoronas[v41];
      v52 = *((_BYTE *)v43 + 54);
      v44 = *((_BYTE *)v43 + 52);
      v43->FadedIntensity = -bFullBrightAtStart;
      v43->JustCreated = 1;
      v43->Identifier = ID;
      *((_BYTE *)v43 + 52) = v44 | 2;
      v35 = bOnlyFromBelow;
      *((_BYTE *)v43 + 54) = v52 & 0xFB;
      ++CCoronas::NumCoronas;
      goto LABEL_28;
    }
LABEL_24:
    v42 = bNeonFade;
    if ( !((CCoronas::aCoronas[v38].FadedIntensity | v32) << 24) )
    {
      CCoronas::aCoronas[v38].Identifier = 0;
      --CCoronas::NumCoronas;
      return;
    }
LABEL_28:
    v45 = &CCoronas::aCoronas[v34];
    v45->Green = G;
    v45->Red = R;
    v45->Blue = B;
    v45->Intensity = v32;
    v46 = *(_QWORD *)&Coors->x;
    v47 = *((_BYTE *)v45 + 52);
    v45->Coordinates.z = Coors->z;
    v45->RegisteredThisFrame = 1;
    v45->Size = Size;
    v45->NormalAngle = fNormalAngle;
    v45->Range = Range;
    v45->pTex = pCoronaTex;
    v45->FlareType = FlareType;
    v45->ReflectionType = ReflType;
    *(_QWORD *)&v45->Coordinates.x = v46;
    *((_BYTE *)v45 + 52) = v47 & 0xFE | LOSCheck & 1;
    v49 = *((_BYTE *)v45 + 54);
    v48 = (char *)v45 + 54;
    *(float *)(v48 - 22) = ArgPullTowardsCam;
    *(float *)(v48 - 14) = FadeSpeed;
    v50 = v49 & 0xF4 | v42 | (8 * bWhiteCore) | (2 * v35);
    *v48 = v50;
    if ( pAttachedToEntity )
    {
      *v48 = v50 | 0x10;
      v51 = &CCoronas::aCoronas[v34];
      v51->pEntityAttachedTo = pAttachedToEntity;
      CEntity::RegisterReference(pAttachedToEntity, &v51->pEntityAttachedTo);
    }
    else
    {
      *v48 = v50 & 0xEF;
      CCoronas::aCoronas[v34].pEntityAttachedTo = 0;
    }
  }
}

//----- (005A3D98) --------------------------------------------------------
void __fastcall CCoronas::UpdateCoronaCoors(UInt32 ID, const CVector *Coors, float Range, float fNormalAngle)
{
  CSimpleTransform *p_tx; // r4
  float32x2_t v5; // d16
  unsigned __int64 v6; // d1
  int v8; // lr
  u_native *p_Identifier; // r3
  unsigned __int16 i; // r2
  int v11; // r12
  __int64 v12; // d16
  CRegisteredCorona *v13; // r0

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v5.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&Coors->x).n64_u64[0];
  v6 = vmul_f32(v5, v5).n64_u64[0];
  if ( (float)(*(float *)&v6 + *((float *)&v6 + 1)) <= (float)(Range * Range) )
  {
    v8 = 0;
    p_Identifier = &CCoronas::aCoronas[0].Identifier;
    for ( i = 0; i < 0x40u; v11 = i )
    {
      if ( *p_Identifier == ID )
      {
        v11 = v8;
        goto LABEL_10;
      }
      ++i;
      p_Identifier += 15;
      ++v8;
    }
    if ( i == 64 )
      return;
LABEL_10:
    v12 = *(_QWORD *)&Coors->x;
    v13 = &CCoronas::aCoronas[v11];
    v13->Coordinates.z = Coors->z;
    *(_QWORD *)&v13->Coordinates.x = v12;
    v13->NormalAngle = fNormalAngle;
  }
}

//----- (005A3E40) --------------------------------------------------------
void CCoronas::DoSunAndMoon()
{
  CVector *v0; // r0
  __int64 v1; // d16
  float v2; // s2
  CSimpleTransform *p_tx; // r2
  float y; // s10
  float z; // s12
  RwV3d_0 In; // [sp+48h] [bp-40h] BYREF
  RwV3d_0 pResult; // [sp+54h] [bp-34h] BYREF
  float pScaleY; // [sp+60h] [bp-28h] BYREF
  float pScaleX[9]; // [sp+64h] [bp-24h] BYREF

  v0 = &CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue];
  In.z = v0->z;
  v1 = *(_QWORD *)&v0->x;
  v2 = (float)(CDraw::ms_fFarClipZ * 0.95) * In.z;
  *(_QWORD *)&In.x = *(_QWORD *)&v0->x;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  In.z = v2;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  In.x = p_tx->m_translate.x + (float)(*(float *)&v1 * (float)(CDraw::ms_fFarClipZ * 0.95));
  In.y = y + (float)((float)(CDraw::ms_fFarClipZ * 0.95) * *((float *)&v1 + 1));
  In.z = z + v2;
  if ( CGame::CanSeeOutSideFromCurrArea() )
  {
    if ( CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].z > -0.1 )
    {
      CCoronas::RegisterCorona(
        1u,
        0,
        CTimeCycle::m_CurrentColours.m_nSunCoreRed,
        CTimeCycle::m_CurrentColours.m_nSunCoreGreen,
        CTimeCycle::m_CurrentColours.m_nSunCoreBlue,
        0xFFu,
        (const CVector *)&In,
        (float)(CTimeCycle::m_CurrentColours.m_fSunSize / 10.0) * 27.335,
        1000000.0,
        gpCoronaTexture[0],
        0,
        0,
        0,
        0,
        0.0,
        0,
        1.5,
        0,
        15.0,
        0,
        0);
      if ( CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].z > 0.0 && CGame::currArea == AREA_MAIN_MAP )
        CCoronas::RegisterCorona(
          2u,
          0,
          CTimeCycle::m_CurrentColours.m_nSunCoronaRed,
          CTimeCycle::m_CurrentColours.m_nSunCoronaGreen,
          CTimeCycle::m_CurrentColours.m_nSunCoronaBlue,
          0xFFu,
          (const CVector *)&In,
          (float)(CTimeCycle::m_CurrentColours.m_fSunSize / 10.0) * 60.0,
          1000000.0,
          gpCoronaTexture[0],
          1u,
          0,
          1u,
          0,
          0.0,
          0,
          1.5,
          0,
          15.0,
          0,
          0);
    }
    if ( CSprite::CalcScreenCoors(&In, &pResult, pScaleX, &pScaleY, 1, 1) == 1 )
    {
      CCoronas::SunScreenX = pResult.x;
      CCoronas::SunScreenY = pResult.y;
    }
    else
    {
      CCoronas::SunScreenX = 1000000.0;
      CCoronas::SunScreenY = 1000000.0;
    }
  }
}
// 5A3E40: using guessed type float pScaleX[9];

//----- (005A40AC) --------------------------------------------------------
float GetDayNightBalance()
{
  float v0; // s2
  float v1; // s0

  v0 = (float)((float)CClock::ms_nGameClockSeconds / 60.0)
     + (float)(CClock::ms_nGameClockMinutes + 60 * CClock::ms_nGameClockHours);
  v1 = 1.0;
  if ( v0 >= 360.0 )
  {
    if ( v0 < 420.0 )
      return (float)(420.0 - v0) / 60.0;
    if ( v0 < 1200.0 )
      return 0.0;
    if ( v0 < 1260.0 )
      return (float)((float)(1260.0 - v0) / -60.0) + 1.0;
  }
  return v1;
}

//----- (005A4180) --------------------------------------------------------
void __fastcall CEntity::ProcessLightsForEntity(CEntity *this)
{
  CEntity *v1; // r9
  float v2; // s16
  float v3; // s0
  CMatrix *m_pMat; // r0
  CBaseModelInfo *v5; // r11
  CSimpleTransform *p_m_transform; // r10
  int32 v7; // r6
  unsigned int v8; // r0
  float v9; // s0
  float v10; // s27
  float v11; // s0
  int z_high; // r5
  unsigned int green; // r4
  float v14; // s1
  float v15; // s27
  float m_size; // s0
  float *p_m_size; // r5
  unsigned int red; // r0
  C2dEffect *v19; // r8
  const CMatrix *v20; // r1
  int RandomSeed; // r4
  __int64 v22; // d16
  const CMatrix *v23; // r1
  __int64 v24; // d16
  uint16 m_flags; // r0
  int v26; // r1
  float v27; // s18
  int v28; // r0
  char v29; // r1
  int v30; // r9
  int v31; // r10
  int v32; // r5
  int v33; // r4
  CMatrix *v34; // r1
  CSimpleTransform *v35; // r2
  int v36; // r1
  int v37; // r0
  CMatrix *v38; // r0
  float *p_x; // r1
  RwReal v40; // s2
  RwReal v41; // s4
  CSimpleTransform *p_tx; // r1
  float v43; // s0
  float v44; // s2
  float v45; // s4
  float v46; // s27
  float v47; // s18
  float v48; // s23
  float v49; // s31
  float v50; // s0
  float v51; // s0
  char v52; // r2
  uint32 v53; // r0
  int v54; // r2
  uint32 v55; // r0
  uint32 v56; // r0
  uint32 v57; // r0
  int v58; // r0
  _BOOL4 active; // r0
  bool v60; // zf
  int v61; // r0
  RwReal m_lightDirX; // s2
  RwReal m_lightDirZ; // s4
  CMatrix *v64; // r1
  CSimpleTransform *v65; // r1
  unsigned __int64 v66; // d1
  CSimpleTransform *v67; // r1
  float32x2_t v68; // d16
  unsigned __int64 v69; // d1
  u_native *p_Identifier; // r2
  unsigned int v71; // r0
  __int64 v72; // d16
  CRegisteredCorona *v73; // r0
  uint16 v74; // r0
  CVector B; // [sp+0h] [bp-150h] BYREF
  int v76; // [sp+A0h] [bp-B0h]
  CSimpleTransform *v77; // [sp+B8h] [bp-98h]
  CPlaceable *v78; // [sp+BCh] [bp-94h]
  CVector Coors; // [sp+C0h] [bp-90h] BYREF
  CVector v; // [sp+D0h] [bp-80h] BYREF
  CVector v81; // [sp+E0h] [bp-70h] BYREF

  v1 = this;
  v2 = 1.0;
  v3 = (float)((float)CClock::ms_nGameClockSeconds / 60.0)
     + (float)(CClock::ms_nGameClockMinutes + 60 * CClock::ms_nGameClockHours);
  if ( v3 >= 360.0 )
  {
    if ( v3 >= 420.0 )
    {
      if ( v3 >= 1200.0 )
      {
        if ( v3 < 1260.0 )
          v2 = (float)((float)(1260.0 - v3) / -60.0) + 1.0;
      }
      else
      {
        v2 = 0.0;
      }
    }
    else
    {
      v2 = (float)(420.0 - v3) / 60.0;
    }
  }
  if ( (*(_DWORD *)&this->m_nFlags & 0x280) == 0x80 )
  {
    if ( (*(_BYTE *)&this->m_info & 7) == 2 )
    {
      if ( (HIBYTE(this[1].m_transform.m_translate.y) & 0x20) != 0 )
        return;
      goto LABEL_14;
    }
    m_pMat = this->m_pMat;
    if ( !m_pMat || m_pMat->zz >= 0.96 )
    {
LABEL_14:
      v5 = CModelInfo::ms_modelInfoPtrs[v1->m_nModelIndex];
      if ( !v5->m_num2dEffects )
        return;
      v76 = (int)&v1->m_nFlags.bdummy + 1;
      p_m_transform = &v1->m_transform;
      v7 = 0;
      v77 = &v1->m_transform;
      v78 = v1;
      do
      {
        v19 = CBaseModelInfo::Get2dEffect(v5, v7);
        if ( v19->m_type == 4 )
        {
          if ( CWeather::SunGlare >= 0.0 )
          {
            v23 = v1->m_pMat;
            if ( v23 )
            {
              v24 = *(_QWORD *)&v19->m_posn.x;
              v.z = v19->m_posn.z;
              *(_QWORD *)&v.x = v24;
              operator*(&v81, v23, &v);
              Coors = v81;
            }
            else
            {
              TransformPoint(&Coors, p_m_transform, &v19->m_posn);
            }
            v38 = v1->m_pMat;
            p_x = &p_m_transform->m_translate.x;
            if ( v38 )
              p_x = &v38->tx;
            v40 = Coors.y - p_x[1];
            v41 = Coors.z - p_x[2];
            v81.x = Coors.x - *p_x;
            v81.y = v40;
            v81.z = v41;
            CVector::Normalise(&v81);
            p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              p_tx = &TheCamera.m_transform;
            v43 = p_tx->m_translate.x - Coors.x;
            v44 = p_tx->m_translate.y - Coors.y;
            v45 = p_tx->m_translate.z - Coors.z;
            v46 = sqrtf((float)((float)(v43 * v43) + (float)(v44 * v44)) + (float)(v45 * v45));
            v47 = v43 * (float)(2.0 / v46);
            v48 = v44 * (float)(2.0 / v46);
            v49 = v45 * (float)(2.0 / v46);
            v81.x = v81.x + v47;
            v81.y = v81.y + v48;
            v81.z = v81.z + v49;
            CVector::Normalise(&v81);
            v50 = (float)((float)(v81.x * CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].x)
                        + (float)(v81.y * CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].y))
                + (float)(v81.z * CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].z);
            if ( v50 < -0.0 )
            {
              v51 = sqrtf(-v50) * CWeather::SunGlare;
              Coors.x = v47 + Coors.x;
              Coors.y = v48 + Coors.y;
              Coors.z = v49 + Coors.z;
              CCoronas::RegisterCorona(
                v76 + v7,
                0,
                (unsigned int)(float)((float)(v51 * (float)(CTimeCycle::m_CurrentColours.m_nSunCoreRed + 510)) / 3.0),
                (unsigned int)(float)((float)(v51 * (float)(CTimeCycle::m_CurrentColours.m_nSunCoreGreen + 510)) / 3.0),
                (unsigned int)(float)((float)(v51 * (float)(CTimeCycle::m_CurrentColours.m_nSunCoreBlue + 510)) / 3.0),
                0xFFu,
                &Coors,
                sqrtf(v46) * (float)(CWeather::SunGlare * 0.5),
                120.0,
                gpCoronaTexture[0],
                0,
                0,
                0,
                0,
                0.0,
                0,
                1.5,
                0,
                15.0,
                0,
                0);
            }
          }
        }
        else if ( !v19->m_type )
        {
          v20 = v1->m_pMat;
          RandomSeed = v1->RandomSeed;
          if ( v20 )
          {
            v22 = *(_QWORD *)&v19->m_posn.x;
            v.z = v19->m_posn.z;
            *(_QWORD *)&v.x = v22;
            operator*(&v81, v20, &v);
            Coors = v81;
          }
          else
          {
            TransformPoint(&Coors, p_m_transform, &v19->m_posn);
          }
          m_flags = v19->attr.l.m_flags;
          if ( (m_flags & 0x60) == 96 )
          {
            v26 = 1;
            v27 = 1.0;
          }
          else if ( v2 < 1.0 && (m_flags & 0x20) != 0 )
          {
            v26 = 1;
            v27 = 1.0 - v2;
          }
          else
          {
            v28 = m_flags & 0x40;
            v29 = 0;
            v27 = 1.0;
            if ( v2 > 0.0 )
              v29 = 1;
            v26 = (unsigned __int8)v29 & (v28 != 0);
            if ( v26 )
              v27 = v2;
          }
          if ( !v26 && (v19->attr.l.m_flashiness != 2 || CWeather::WetRoads <= 0.5) )
          {
LABEL_58:
            CGameLogic::LaRiotsActiveHere();
            goto LABEL_131;
          }
          v30 = 1;
          v10 = 1.0;
          v31 = 0;
          v32 = CEntity::ProcessLightsForEntity(void)::RandomSeedRandomiser[v7 & 7] ^ RandomSeed;
          v33 = 0;
          switch ( v19->attr.l.m_flashiness )
          {
            case 0u:
              goto LABEL_101;
            case 1u:
            case 2u:
              v33 = 0;
              v52 = CTimer::m_snTimeInMilliseconds ^ v32;
              v53 = (unsigned __int16)v32 ^ (CTimer::m_snTimeInMilliseconds >> 11);
              goto LABEL_73;
            case 3u:
              v33 = 0;
              v31 = 0;
              v55 = CTimer::m_snTimeInMilliseconds + (v7 << 7);
              if ( (v55 & 0x200) == 0 )
                v33 = 1;
              v30 = (v55 >> 9) & 1;
              goto LABEL_84;
            case 4u:
              v33 = 0;
              v31 = 0;
              v56 = CTimer::m_snTimeInMilliseconds + (v7 << 8);
              if ( (v56 & 0x400) == 0 )
                v33 = 1;
              v30 = (v56 >> 10) & 1;
              goto LABEL_84;
            case 5u:
              v33 = 0;
              v31 = 0;
              v57 = CTimer::m_snTimeInMilliseconds + (v7 << 9);
              if ( (v57 & 0x800) == 0 )
                v33 = 1;
              v30 = (v57 >> 11) & 1;
              goto LABEL_84;
            case 6u:
              v33 = 0;
              if ( (unsigned __int8)v32 > 0x10u )
              {
                v30 = 1;
                goto LABEL_99;
              }
              v52 = CTimer::m_snTimeInMilliseconds ^ (8 * v32);
              v53 = (unsigned __int16)v32 ^ (CTimer::m_snTimeInMilliseconds >> 11);
LABEL_73:
              v54 = v52 & 0x60;
              v30 = (v53 & 3 | v54) != 0;
              v31 = v54 == 0;
LABEL_84:
              v10 = 1.0;
              goto LABEL_101;
            case 8u:
              v33 = 0;
              v58 = 0;
              if ( (BYTE2(v78[2].m_transform.m_translate.y) & 7) == 4 )
              {
                if ( (BYTE1(v78[13].m_transform.m_translate.z) & 8) != 0 )
                  v58 = ((unsigned __int8)v7 ^ (unsigned __int8)(CTimer::m_snTimeInMilliseconds >> 10)) & 1;
                else
                  v58 = 0;
              }
              v30 = v7 < 4 && v58 != 0;
              goto LABEL_99;
            case 9u:
              if ( CBridge::ShouldLightsBeFlashing() != 1 )
                goto LABEL_58;
              v30 = 0;
              v33 = 0;
              if ( (CTimer::m_snTimeInMilliseconds & 0x1FC) < 0x3C )
                v30 = 1;
              goto LABEL_99;
            case 0xAu:
              v10 = CWeather::Rain;
              if ( CWeather::Rain <= 0.0001 )
                goto LABEL_58;
              goto LABEL_95;
            case 0xBu:
            case 0xCu:
            case 0xDu:
              v34 = v78->m_pMat;
              v35 = v77;
              if ( v34 )
                v35 = (CSimpleTransform *)&v34->tx;
              v36 = (int)(float)((float)(v35->m_translate.y * 10.0)
                               + (float)(int)(float)((float)(v35->m_translate.x * 20.0)
                                                   + (float)(int)(3333 * v19->attr.l.m_flashiness
                                                                + CTimer::m_snTimeInMilliseconds
                                                                - 36663)))
                  % 10000;
              v37 = 9 * v36 / 10000;
              if ( (unsigned int)(v37 - 1) < 2 )
              {
                v30 = 1;
                v33 = 0;
LABEL_99:
                v10 = 1.0;
              }
              else
              {
                v10 = (float)(v36 - 1111 * v37) / 1111.0;
                if ( v37 )
                {
                  if ( v37 != 3 )
                    goto LABEL_58;
                  v10 = 1.0 - v10;
                }
LABEL_95:
                v30 = 1;
                v33 = 0;
              }
              v31 = 0;
LABEL_101:
              active = CGameLogic::LaRiotsActiveHere();
              v60 = v30 == 1;
              if ( v30 == 1 )
                v60 = active;
              if ( !v60 || (BYTE2(v78[2].m_transform.m_translate.y) & 7) == 2 )
                goto LABEL_113;
              if ( (v32 & 3) == 0 )
                goto LABEL_112;
              if ( (v32 & 3) == 1 )
              {
                v61 = ((unsigned __int8)CTimer::m_snTimeInMilliseconds ^ (unsigned __int8)(8 * v32)) & 0x60;
                if ( (((unsigned __int8)CTimer::m_snTimeInMilliseconds ^ (unsigned __int8)(8 * v32)) & 0x60) != 0 )
                  v61 = 1;
                v31 |= v61;
                if ( (((unsigned __int8)CTimer::m_snTimeInMilliseconds ^ (unsigned __int8)(8 * v32)) & 0x60) != 0 )
                {
LABEL_111:
                  if ( v31 )
                    goto LABEL_112;
                  if ( v33 != 1 )
                  {
LABEL_131:
                    p_m_size = &v19->attr.l.m_size;
                    green = 1;
LABEL_132:
                    v74 = v19->attr.l.m_flags;
                    if ( (v74 & 4) != 0 )
                    {
                      memset(&B, 0, sizeof(B));
                      CPointLights::AddLight(
                        3u,
                        Coors,
                        B,
                        0.0,
                        (float)v19->attr.l.m_colour._anon_0._anon_0.red * 0.0039062,
                        (float)v19->attr.l.m_colour._anon_0._anon_0.green * 0.0039062,
                        (float)v19->attr.l.m_colour._anon_0._anon_0.blue * 0.0039062,
                        2u,
                        1,
                        0);
                      p_m_transform = v77;
                      v1 = (CEntity *)v78;
                    }
                    else
                    {
                      p_m_transform = v77;
                      v1 = (CEntity *)v78;
                      if ( !(((v74 & 2) == 0) | green) && *p_m_size == 0.0 )
                      {
                        memset(&B, 0, sizeof(B));
                        CPointLights::AddLight(
                          4u,
                          Coors,
                          B,
                          0.0,
                          (float)v19->attr.l.m_colour._anon_0._anon_0.red * 0.0039062,
                          (float)v19->attr.l.m_colour._anon_0._anon_0.green * 0.0039062,
                          (float)v19->attr.l.m_colour._anon_0._anon_0.blue * 0.0039062,
                          1u,
                          1,
                          0);
                      }
                    }
                    break;
                  }
LABEL_123:
                  v67 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
                  if ( !TheCamera.m_pMat )
                    v67 = &TheCamera.m_transform;
                  v68.n64_u64[0] = vsub_f32(*(float32x2_t *)&v67->m_translate.x, *(float32x2_t *)&Coors.x).n64_u64[0];
                  v69 = vmul_f32(v68, v68).n64_u64[0];
                  if ( (float)(*(float *)&v69 + *((float *)&v69 + 1)) <= (float)(v19->attr.l.m_lodDistance
                                                                               * v19->attr.l.m_lodDistance) )
                  {
                    p_Identifier = &CCoronas::aCoronas[0].Identifier;
                    v71 = 0;
                    while ( (CPlaceable *)*p_Identifier != (CPlaceable *)((char *)v78 + v7) )
                    {
                      ++v71;
                      p_Identifier += 15;
                      if ( v71 >= 0x40 )
                      {
                        if ( (unsigned __int16)v71 == 64 )
                          goto LABEL_131;
                        break;
                      }
                    }
                    v72 = *(_QWORD *)&Coors.x;
                    v73 = &CCoronas::aCoronas[v71];
                    v73->Coordinates.z = Coors.z;
                    *(_QWORD *)&v73->Coordinates.x = v72;
                    v73->NormalAngle = 0.0;
                  }
                  goto LABEL_131;
                }
              }
              else
              {
LABEL_113:
                if ( v30 != 1 )
                  goto LABEL_111;
              }
              v8 = v19->attr.l.m_flags;
              v1 = (CEntity *)v78;
              if ( (v8 & 0x800) == 0 )
                goto LABEL_17;
              m_lightDirX = (float)v19->attr.l.m_lightDirX;
              m_lightDirZ = (float)v19->attr.l.m_lightDirZ;
              v81.y = (float)v19->attr.l.m_lightDirY;
              v81.x = m_lightDirX;
              v81.z = m_lightDirZ;
              v64 = v78->m_pMat;
              if ( !v64 )
              {
                CPlaceable::AllocateMatrix(v78);
                CSimpleTransform::UpdateMatrix(v77, v78->m_pMat);
                v64 = v78->m_pMat;
              }
              Multiply3x3(&v, v64, &v81);
              v65 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              if ( !TheCamera.m_pMat )
                v65 = &TheCamera.m_transform;
              v66 = vmul_f32(
                      vsub_f32(*(float32x2_t *)&v65->m_translate.y, *(float32x2_t *)&Coors.y),
                      *(float32x2_t *)&v.y).n64_u64[0];
              if ( (float)((float)((float)((float)(v65->m_translate.x - Coors.x) * v.x) + *(float *)&v66)
                         + *((float *)&v66 + 1)) >= 0.0 )
              {
                v8 = v19->attr.l.m_flags;
LABEL_17:
                if ( (v8 & 0x80) != 0 )
                {
                  v9 = (float)(rand() & 0x1F);
                  v8 = v19->attr.l.m_flags;
                  v10 = v10 * (float)((float)(v9 * -0.012) + 1.0);
                }
                if ( (v8 & 0x200) != 0 )
                {
                  v11 = 0.0;
                  if ( !((CTimer::m_FrameCounter + v32) << 30) )
                    v11 = v10;
                  if ( (v8 & 0x1000) != 0 )
                    goto LABEL_25;
                }
                else
                {
                  v11 = v10;
                  if ( (v8 & 0x1000) == 0 )
                    goto LABEL_29;
LABEL_25:
                  if ( (((_BYTE)CTimer::m_FrameCounter + (_BYTE)v32) & 0x3F) != 0 )
                  {
                    if ( (((_BYTE)CTimer::m_FrameCounter + (_BYTE)v32) & 0x3F) == 1 )
                      v11 = v11 * 0.5;
                    else
                      v11 = 0.0;
                  }
                }
LABEL_29:
                z_high = HIWORD(v78[1].m_transform.m_translate.z);
                if ( z_high == 464 )
                  v11 = v11 * 1.9;
                green = 0;
                v14 = 1.0;
                if ( z_high == 464 )
                  v14 = 2.0;
                v15 = v11 * (float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0);
                CCoronas::RegisterCorona(
                  (u_native)v78 + v7,
                  0,
                  (unsigned int)(float)(v15 * (float)v19->attr.l.m_colour._anon_0._anon_0.red),
                  (unsigned int)(float)(v15 * (float)v19->attr.l.m_colour._anon_0._anon_0.green),
                  (unsigned int)(float)(v15 * (float)v19->attr.l.m_colour._anon_0._anon_0.blue),
                  (unsigned int)(float)(v27 * 255.0),
                  &Coors,
                  v14 * v19->attr.l.m_coronaSize,
                  v19->attr.l.m_lodDistance,
                  v19->attr.l.m_pCoronaTex,
                  v19->attr.l.m_lensFlareType,
                  v19->attr.l.m_reflectionType,
                  v8 & 1,
                  0,
                  0.0,
                  (v8 >> 4) & 1,
                  0.8,
                  0,
                  15.0,
                  v8 & 0x100,
                  (v8 & 0x400) != 0);
                m_size = v19->attr.l.m_size;
                p_m_size = &v19->attr.l.m_size;
                if ( m_size != 0.0 )
                {
                  red = v19->attr.l.m_colour._anon_0._anon_0.red;
                  green = v19->attr.l.m_colour._anon_0._anon_0.green;
                  if ( red | green || (green = 0, v19->attr.l.m_colour._anon_0._anon_0.blue) )
                  {
                    memset(&B, 0, sizeof(B));
                    CPointLights::AddLight(
                      0,
                      Coors,
                      B,
                      m_size,
                      (float)((float)(v27 * v15) * 0.0039062) * (float)red,
                      (float)((float)(v27 * v15) * 0.0039062) * (float)green,
                      (float)((float)(v27 * v15) * 0.0039062) * (float)v19->attr.l.m_colour._anon_0._anon_0.blue,
                      (v19->attr.l.m_flags >> 1) & 3,
                      1,
                      0);
                    p_m_transform = v77;
                    break;
                  }
                  memset(&B, 0, sizeof(B));
                  CPointLights::AddLight(2u, Coors, B, m_size, 0.0, 0.0, 0.0, 0, 1, 0);
                }
                goto LABEL_132;
              }
              if ( v31 == 1 )
              {
LABEL_112:
                CCoronas::RegisterCorona(
                  (u_native)v78 + v7,
                  0,
                  0,
                  0,
                  0,
                  0xFFu,
                  &Coors,
                  v19->attr.l.m_coronaSize,
                  v19->attr.l.m_lodDistance,
                  v19->attr.l.m_pCoronaTex,
                  v19->attr.l.m_lensFlareType,
                  v19->attr.l.m_reflectionType,
                  v19->attr.l.m_flags & 1,
                  0,
                  0.0,
                  (v19->attr.l.m_flags >> 4) & 1,
                  1.5,
                  0,
                  15.0,
                  0,
                  0);
                goto LABEL_131;
              }
              goto LABEL_123;
            default:
              goto LABEL_58;
          }
        }
        ++v7;
      }
      while ( v7 < v5->m_num2dEffects );
    }
  }
}

//----- (005A4EBC) --------------------------------------------------------
void CCredits::Start()
{
  CCredits::bCreditsGoing = 1;
  CCredits::CreditsStartTime = CTimer::m_snTimeInMilliseconds;
}

//----- (005A4EE4) --------------------------------------------------------
void CCredits::Stop()
{
  CCredits::bCreditsGoing = 0;
}

//----- (005A4EF4) --------------------------------------------------------
void CCredits::Update()
{
  bool v0; // zf

  if ( CCredits::bCreditsGoing )
  {
    v0 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v0 = gMobileMenu.pendingScreen == 0;
    if ( v0 && CTouchInterface::IsReleased(WIDGET_SKIP_CUTSCENE, 0, 2) )
      CCredits::bCreditsGoing = 0;
  }
}

//----- (005A4F3C) --------------------------------------------------------
bool CCustomCarPlateMgr::Initialise()
{
  int32 TxdSlot; // r4
  RwTexture_0 *v1; // r0
  RwTexture_0 *v2; // r0
  RwTexture_0 *v3; // r0
  RwTexture_0 *v4; // r0

  TxdSlot = CTxdStore::FindTxdSlot("vehicle");
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  v1 = RwTextureRead((const RwChar *)"platecharset", 0);
  LOWORD(v1->filterAddressing) = 13057;
  CCustomCarPlateMgr::pCharsetTex = v1;
  v2 = RwTextureRead((const RwChar *)"plateback1", 0);
  LOWORD(v2->filterAddressing) = 13058;
  CCustomCarPlateMgr::pPlatebackTexTab[0] = v2;
  v3 = RwTextureRead((const RwChar *)"plateback2", 0);
  LOWORD(v3->filterAddressing) = 13058;
  CCustomCarPlateMgr::pPlatebackTexTab[1] = v3;
  v4 = RwTextureRead((const RwChar *)"plateback3", 0);
  LOWORD(v4->filterAddressing) = 13058;
  CCustomCarPlateMgr::pPlatebackTexTab[2] = v4;
  CTxdStore::PopCurrentTxd();
  pLockedCharsetRaster = RwRasterLock(CCustomCarPlateMgr::pCharsetTex->raster, 0, 2);
  return pLockedCharsetRaster != 0;
}

//----- (005A500C) --------------------------------------------------------
bool8 __fastcall CCustomCarPlateMgr::GeneratePlateText(unsigned __int8 *pDestBuf, int32 maxNumChars)
{
  int v5; // r6
  unsigned __int8 *v6; // r4
  int32 v7; // r0

  if ( maxNumChars < 4 )
    return 0;
  *pDestBuf = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 23.0) + 65;
  pDestBuf[1] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 23.0) + 65;
  pDestBuf[2] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 9.0) + 48;
  pDestBuf[3] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 9.0) + 48;
  if ( maxNumChars != 4 )
  {
    v5 = 0;
    do
    {
      v6 = &pDestBuf[v5];
      pDestBuf[v5 + 4] = 32;
      v6[5] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 9.0) + 48;
      v6[6] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 23.0) + 65;
      v6[7] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 23.0) + 65;
      v7 = v5 + 8;
      v5 += 4;
    }
    while ( v7 < maxNumChars );
  }
  return 1;
}

//----- (005A5150) --------------------------------------------------------
void CCustomCarPlateMgr::Shutdown()
{
  int32 TxdSlot; // r0

  if ( CCustomCarPlateMgr::pCharsetTex )
  {
    RwRasterUnlock(CCustomCarPlateMgr::pCharsetTex->raster);
    pLockedCharsetRaster = 0;
    RwTextureDestroy(CCustomCarPlateMgr::pCharsetTex);
    CCustomCarPlateMgr::pCharsetTex = 0;
  }
  if ( CCustomCarPlateMgr::pPlatebackTexTab[0] )
  {
    RwTextureDestroy(CCustomCarPlateMgr::pPlatebackTexTab[0]);
    CCustomCarPlateMgr::pPlatebackTexTab[0] = 0;
  }
  if ( CCustomCarPlateMgr::pPlatebackTexTab[1] )
  {
    RwTextureDestroy(CCustomCarPlateMgr::pPlatebackTexTab[1]);
    CCustomCarPlateMgr::pPlatebackTexTab[1] = 0;
  }
  if ( CCustomCarPlateMgr::pPlatebackTexTab[2] )
  {
    RwTextureDestroy(CCustomCarPlateMgr::pPlatebackTexTab[2]);
    CCustomCarPlateMgr::pPlatebackTexTab[2] = 0;
  }
  TxdSlot = CTxdStore::FindTxdSlot("vehicle");
  if ( TxdSlot != -1 )
    sub_1A09BC(TxdSlot);
}

//----- (005A5200) --------------------------------------------------------
RpMaterial_0 *__fastcall CCustomCarPlateMgr::SetupClump(RpClump_0 *pClump, unsigned __int8 *pText, uint8 plateDesign)
{
  currentCarPlateDesign = plateDesign;
  pPlateMaterial = 0;
  RpClumpForAllAtomics(pClump, SetCustomCarPlateCB, pText);
  return pPlateMaterial;
}

//----- (005A5234) --------------------------------------------------------
RpAtomic_0 *__fastcall SetCustomCarPlateCB(RpAtomic_0 *pAtomic, void *pData)
{
  RpGeometryForAllMaterials(pAtomic->geometry, SetCarPlateMatCB, pData);
  return pAtomic;
}

//----- (005A5250) --------------------------------------------------------
bool8 __fastcall CCustomCarPlateMgr::SetupClumpAfterVehicleUpgrade(
        RpClump_0 *pClump,
        RpMaterial_0 *pCarPlateMaterial,
        uint8 plateDesign)
{
  if ( !pCarPlateMaterial )
    return 0;
  pPlateMaterial = pCarPlateMaterial;
  currentCarPlateDesign = plateDesign;
  RpClumpForAllAtomics(pClump, SetCustomCarPlateAfterUpgradeCB, 0);
  return 1;
}

//----- (005A528C) --------------------------------------------------------
RpAtomic_0 *__fastcall SetCustomCarPlateAfterUpgradeCB(RpAtomic_0 *pAtomic, void *pData)
{
  RpGeometryForAllMaterials(pAtomic->geometry, SetCarPlateMatAfterUpgradeCB, pAtomic->geometry);
  return pAtomic;
}

//----- (005A52A8) --------------------------------------------------------
RpMaterial_0 *__fastcall CCustomCarPlateMgr::SetupMaterialPlatebackTexture(RpMaterial_0 *pMaterial, uint8 plateDesign)
{
  unsigned int v3; // r0

  if ( plateDesign == 255 )
  {
    v3 = CWeather::WeatherRegion - 1;
    if ( v3 > 3 )
      plateDesign = 0;
    else
      *(_DWORD *)&plateDesign = 0x1010002u >> (8 * v3);
  }
  RpMaterialSetTexture(pMaterial, CCustomCarPlateMgr::pPlatebackTexTab[plateDesign]);
  return pMaterial;
}

//----- (005A52F0) --------------------------------------------------------
int CCustomCarPlateMgr::GetMapRegionPlateDesign()
{
  unsigned int v0; // r0

  v0 = CWeather::WeatherRegion - 1;
  if ( v0 <= 3 )
    return (unsigned __int8)(0x1010002u >> (8 * v0));
  else
    return 0;
}

//----- (005A5318) --------------------------------------------------------
RpMaterial_0 *__fastcall CCustomCarPlateMgr::SetupMaterialPlateTexture(
        RpMaterial_0 *pMaterial,
        unsigned __int8 *PlateText,
        uint8 plateDesign)
{
  RwTexture_0 *PlateTexture; // r5

  if ( !pMaterial )
    return 0;
  PlateTexture = CCustomCarPlateMgr::CreatePlateTexture(PlateText, plateDesign);
  if ( !PlateTexture )
    return 0;
  RpMaterialSetTexture(pMaterial, PlateTexture);
  RwTextureDestroy(PlateTexture);
  return pMaterial;
}

//----- (005A5344) --------------------------------------------------------
RwTexture_0 *__fastcall CCustomCarPlateMgr::CreatePlateTexture(unsigned __int8 *PlateText, uint8 plateDesign)
{
  RwRaster_0 *v3; // r10
  RwRaster_0 *raster; // r4
  RwUInt8 *v5; // r0
  RwInt32 v6; // r2
  RwInt32 stride; // r1
  bool v8; // zf
  uint8 *v9; // r12
  RwUInt8 *v10; // r11
  int i; // r3
  unsigned __int8 v12; // r0
  int v13; // r4
  int v14; // r0
  int v15; // r4
  int v16; // r0
  int v17; // r4
  uint8 *v18; // r6
  RwUInt8 *v19; // r0
  uint8 v20; // r5
  RwTexture_0 *v21; // r0
  RwTexture_0 *v22; // r5

  v3 = RwRasterCreate(64, 16, 32, 5380);
  if ( !v3 )
    return 0;
  raster = CCustomCarPlateMgr::pCharsetTex->raster;
  if ( !CCustomCarPlateMgr::pCharsetTex->raster )
    goto LABEL_17;
  v5 = RwRasterLock(v3, 0, 5);
  if ( !v5 || !pLockedCharsetRaster )
    goto LABEL_17;
  stride = raster->stride;
  v8 = stride == 0;
  if ( stride )
  {
    v6 = v3->stride;
    v8 = v6 == 0;
  }
  if ( v8 )
  {
LABEL_17:
    RwRasterDestroy(v3);
    return 0;
  }
  v9 = pLockedCharsetRaster + 31;
  v10 = v5 + 31;
  for ( i = 0; i != 8; ++i )
  {
    v12 = PlateText[i] - 32;
    if ( v12 > 0x5Au )
    {
      v14 = 18432;
      v15 = 0;
    }
    else
    {
      v13 = (char)v12;
      v14 = (int)*(&off_61F440 + (char)v12);
      v15 = dword_61F2D0[v13];
    }
    v16 = v14 + v15;
    v17 = 16;
    v18 = &v9[v16];
    v19 = v10;
    do
    {
      --v17;
      *(v19 - 31) = *(v18 - 31);
      *(v19 - 30) = *(v18 - 30);
      *(v19 - 29) = *(v18 - 29);
      *(v19 - 28) = *(v18 - 28);
      *(v19 - 27) = *(v18 - 27);
      *(v19 - 26) = *(v18 - 26);
      *(v19 - 25) = *(v18 - 25);
      *(v19 - 24) = *(v18 - 24);
      *(v19 - 23) = *(v18 - 23);
      *(v19 - 22) = *(v18 - 22);
      *(v19 - 21) = *(v18 - 21);
      *(v19 - 20) = *(v18 - 20);
      *(v19 - 19) = *(v18 - 19);
      *(v19 - 18) = *(v18 - 18);
      *(v19 - 17) = *(v18 - 17);
      *(v19 - 16) = *(v18 - 16);
      *(v19 - 15) = *(v18 - 15);
      *(v19 - 14) = *(v18 - 14);
      *(v19 - 13) = *(v18 - 13);
      *(v19 - 12) = *(v18 - 12);
      *(v19 - 11) = *(v18 - 11);
      *(v19 - 10) = *(v18 - 10);
      *(v19 - 9) = *(v18 - 9);
      *(v19 - 8) = *(v18 - 8);
      *(v19 - 7) = *(v18 - 7);
      *(v19 - 6) = *(v18 - 6);
      *(v19 - 5) = *(v18 - 5);
      *(v19 - 4) = *(v18 - 4);
      *(v19 - 3) = *(v18 - 3);
      *(v19 - 2) = *(v18 - 2);
      *(v19 - 1) = *(v18 - 1);
      v20 = *v18;
      v18 += stride;
      *v19 = v20;
      v19 += v6;
    }
    while ( v17 );
    v10 += 32;
  }
  RwRasterUnlock(v3);
  v3->privateFlags |= 0x200u;
  v21 = RwTextureCreate(v3);
  v22 = v21;
  if ( !v21 )
    return 0;
  RwTextureSetName(v21, PlateText);
  LOBYTE(v22->filterAddressing) = 1;
  return v22;
}
// 5A54E2: variable 'v6' is possibly undefined
// 61F2D0: using guessed type _DWORD dword_61F2D0[92];
// 61F440: using guessed type void *off_61F440;

//----- (005A5544) --------------------------------------------------------
bool8 __fastcall CCustomCarPlateMgr::LoadPlatecharsetDat(
        const unsigned __int8 *pFilename,
        uint8 *pDstPal,
        int32 maxNumPalettes,
        int32 maxNumPalColors)
{
  unsigned __int8 v4; // r8
  unsigned __int8 v5; // r10
  unsigned __int8 v6; // r11
  u_native v9; // r5
  unsigned __int8 *Line; // r0
  char *v11; // r6
  unsigned int v12; // r9
  char *v13; // r0
  unsigned __int16 v14; // r0
  unsigned __int16 v15; // r0
  unsigned __int16 v16; // r0
  uint8 *v18; // [sp+0h] [bp-28h]
  int i; // [sp+4h] [bp-24h]
  char v20[32]; // [sp+8h] [bp-20h] BYREF

  CFileMgr::SetDir("DATA");
  v9 = CFileMgr::OpenFile(pFilename, "r");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  for ( i = 0; ; ++i )
  {
    do
    {
      Line = CFileLoader::LoadLine(v9);
      v11 = (char *)Line;
      if ( !Line || !strcmp((const char *)Line, ";the end") )
      {
        CFileMgr::CloseFile(v9);
        return 1;
      }
    }
    while ( *v11 == 59 );
    v18 = pDstPal;
    v12 = 0;
    strcpy(v20, " \t");
    v13 = strtok(v11, v20);
    do
    {
      switch ( v12 )
      {
        case 2u:
          v15 = atoi(v13);
          v4 = v15;
          if ( v15 >= 0xFFu )
            v4 = -1;
          break;
        case 1u:
          v16 = atoi(v13);
          v5 = v16;
          if ( v16 >= 0xFFu )
            v5 = -1;
          break;
        case 0u:
          v14 = atoi(v13);
          v6 = v14;
          if ( v14 >= 0xFFu )
            v6 = -1;
          break;
      }
      v13 = strtok(0, v20);
      ++v12;
    }
    while ( v13 );
    if ( v12 < 3 )
      break;
    pDstPal = v18;
    *(_DWORD *)&v18[4 * i] = (v4 << 16) | (v5 << 8) | v6 | 0x80000000;
  }
  return 0;
}
// 5A5578: variable 'v4' is possibly undefined
// 5A557C: variable 'v5' is possibly undefined
// 5A5586: variable 'v6' is possibly undefined
// 61CADE: using guessed type char byte_61CADE;

//----- (005A5660) --------------------------------------------------------
RpMaterial_0 *__fastcall SetCarPlateMatCB(RpMaterial_0 *pMaterial, void *pData)
{
  RwTexture_0 *texture; // r1
  const char *name; // r6
  unsigned int v6; // r0
  unsigned int v7; // r0
  RwTexture_0 *PlateTexture; // r5

  texture = pMaterial->texture;
  if ( pMaterial->texture )
  {
    name = (const char *)texture->name;
    if ( !strcasecmp("carplate", (const char *)texture->name) )
    {
      pPlateMaterial = pMaterial;
      PlateTexture = CCustomCarPlateMgr::CreatePlateTexture((unsigned __int8 *)pData, currentCarPlateDesign);
      if ( PlateTexture )
      {
        RpMaterialSetTexture(pMaterial, PlateTexture);
        RwTextureDestroy(PlateTexture);
      }
    }
    else if ( !strcasecmp("carpback", name) )
    {
      LOBYTE(v6) = currentCarPlateDesign;
      if ( currentCarPlateDesign == 255 )
      {
        v7 = CWeather::WeatherRegion - 1;
        if ( v7 > 3 )
          LOBYTE(v6) = 0;
        else
          v6 = 0x1010002u >> (8 * v7);
      }
      RpMaterialSetTexture(pMaterial, CCustomCarPlateMgr::pPlatebackTexTab[(unsigned __int8)v6]);
    }
  }
  return pMaterial;
}

//----- (005A5714) --------------------------------------------------------
RpMaterial_0 *__fastcall SetCarPlateMatAfterUpgradeCB(RpMaterial_0 *pMaterial, void *pData)
{
  RwTexture_0 *texture; // r1
  const char *name; // r6
  unsigned int v6; // r0
  unsigned int v7; // r0

  texture = pMaterial->texture;
  if ( pMaterial->texture )
  {
    name = (const char *)texture->name;
    if ( !strcasecmp("carplate", (const char *)texture->name) )
    {
      RpGeometryReplaceOldMaterialWithNewMaterial((RpGeometry_0 *)pData, pMaterial, pPlateMaterial);
    }
    else if ( !strcasecmp("carpback", name) )
    {
      LOBYTE(v6) = currentCarPlateDesign;
      if ( currentCarPlateDesign == 255 )
      {
        v7 = CWeather::WeatherRegion - 1;
        if ( v7 > 3 )
          LOBYTE(v6) = 0;
        else
          v6 = 0x1010002u >> (8 * v7);
      }
      RpMaterialSetTexture(pMaterial, CCustomCarPlateMgr::pPlatebackTexTab[(unsigned __int8)v6]);
    }
  }
  return pMaterial;
}

//----- (005A57B0) --------------------------------------------------------
int CCustomRoadsignMgr::Initialise()
{
  int32 TxdSlot; // r4
  RwTexture_0 *v1; // r0

  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  v1 = RwTextureRead((const RwChar *)"roadsignfont", 0);
  LOWORD(v1->filterAddressing) = 13057;
  CCustomRoadsignMgr::pCharsetTex = v1;
  CTxdStore::PopCurrentTxd();
  pLockedCharsetRaster = RwRasterLock(CCustomRoadsignMgr::pCharsetTex->raster, 0, 2);
  return 1;
}

//----- (005A5820) --------------------------------------------------------
void CCustomRoadsignMgr::Shutdown()
{
  RwTexture_0 *v0; // r0
  RwRaster_0 *raster; // r0

  v0 = CCustomRoadsignMgr::pCharsetTex;
  if ( CCustomRoadsignMgr::pCharsetTex )
  {
    if ( pLockedCharsetRaster )
    {
      raster = CCustomRoadsignMgr::pCharsetTex->raster;
      pLockedCharsetRaster = 0;
      RwRasterUnlock(raster);
      v0 = CCustomRoadsignMgr::pCharsetTex;
    }
    RwTextureDestroy(v0);
    CCustomRoadsignMgr::pCharsetTex = 0;
  }
}

//----- (005A5878) --------------------------------------------------------
bool8 __fastcall CCustomRoadsignMgr::RenderTest(const CVector *campos)
{
  return 1;
}

//----- (005A5880) --------------------------------------------------------
RwTexture_0 *__fastcall CCustomRoadsignMgr::CreateRoadsignTexture(unsigned __int8 *PlateText, int32 numLettersInLine)
{
  int32 v3; // r11
  RwRaster_0 *v4; // r10
  RwRaster_0 *raster; // r4
  RwUInt8 *v6; // r0
  uint8 **v7; // r1
  uint8 *v8; // r9
  RwInt32 stride; // r2
  bool v10; // zf
  uint8 **v11; // r3
  unsigned __int8 *v12; // r8
  unsigned __int8 v13; // r1
  int v14; // r5
  int v15; // r1
  int v16; // r5
  uint8 *v17; // r1
  RwUInt8 *v18; // r12
  int v19; // r6
  uint8 *v20; // r1
  int v21; // r5
  uint8 *v22; // r5
  uint8 *v23; // r1
  int v24; // r6
  char *v25; // r5
  int v26; // r5
  uint8 *v27; // r6
  uint8 *v28; // r1
  int v29; // r4
  char *v30; // r6
  int v31; // r6
  uint8 *v32; // r5
  uint8 *v33; // r1
  int v34; // r4
  char *v35; // r6
  uint8 *v36; // r5
  uint8 *v37; // r1
  int v38; // r4
  char *v39; // r6
  uint8 *v40; // r5
  uint8 *v41; // r1
  int v42; // r4
  char *v43; // r6
  uint8 *v44; // r5
  uint8 *v45; // r1
  int v46; // r4
  char *v47; // r6
  uint8 *v48; // r5
  uint8 *v49; // r1
  int v50; // r4
  char *v51; // r6
  uint8 *v52; // r5
  int v53; // r1
  int v54; // r4
  char *v55; // r6
  uint8 *v56; // r5
  int v57; // r1
  int v58; // r4
  char *v59; // r6
  uint8 *v60; // r5
  int v61; // r1
  int v62; // r4
  char *v63; // r6
  uint8 *v64; // r5
  int v65; // r1
  int v66; // r4
  char *v67; // r6
  uint8 *v68; // r5
  int v69; // r1
  int v70; // r4
  char *v71; // r6
  uint8 *v72; // r5
  int v73; // r1
  int v74; // r4
  char *v75; // r6
  uint8 *v76; // r5
  int v77; // r1
  int v78; // r4
  char *v79; // r6
  uint8 *v80; // r5
  int v81; // r1
  int v82; // r4
  char *v83; // r6
  RwTexture_0 *v84; // r6
  char *v86; // [sp+4h] [bp-34h]
  int v87[2]; // [sp+8h] [bp-30h] BYREF
  __int16 v88; // [sp+10h] [bp-28h]
  char v89; // [sp+12h] [bp-26h]

  v3 = numLettersInLine;
  v4 = RwRasterCreate(8 * numLettersInLine, 16, 32, 5380);
  if ( !v4 )
    return 0;
  raster = CCustomRoadsignMgr::pCharsetTex->raster;
  if ( !CCustomRoadsignMgr::pCharsetTex->raster )
    goto LABEL_16;
  v6 = RwRasterLock(v4, 0, 5);
  if ( !v6 )
    goto LABEL_16;
  v7 = &pLockedCharsetRaster;
  v8 = pLockedCharsetRaster;
  if ( !pLockedCharsetRaster )
    goto LABEL_16;
  stride = raster->stride;
  v10 = stride == 0;
  if ( stride )
  {
    v7 = (uint8 **)v4->stride;
    v10 = v7 == 0;
  }
  if ( v10 )
    goto LABEL_16;
  v86 = (char *)PlateText;
  if ( v3 >= 1 )
  {
    v11 = v7 - 6;
    v12 = PlateText;
    do
    {
      v13 = *v12 - 33;
      if ( v13 > 0x5Du )
      {
        v15 = 53248;
        v16 = 0;
      }
      else
      {
        v14 = (char)v13;
        v15 = *((_DWORD *)&unk_61F740 + (char)v13);
        v16 = *((_DWORD *)&unk_61F5C0 + v14);
      }
      v17 = &v8[v15];
      v18 = v6 + 24;
      ++v12;
      --v3;
      v19 = *(_DWORD *)&v17[v16];
      v20 = &v17[v16];
      v21 = *((_DWORD *)v20 + 1);
      *(_DWORD *)v6 = v19;
      *((_DWORD *)v6 + 1) = v21;
      *((_QWORD *)v6 + 1) = *((_QWORD *)v20 + 1);
      *((_QWORD *)v6 + 2) = *((_QWORD *)v20 + 2);
      *((_QWORD *)v6 + 3) = *((_QWORD *)v20 + 3);
      v6 += 32;
      v22 = *(uint8 **)&v20[stride];
      v23 = &v20[stride];
      v24 = *((_DWORD *)v23 + 1);
      *(uint8 **)((char *)v11 + (_DWORD)v18) = v22;
      v25 = (char *)v11 + (_DWORD)v18;
      *((_DWORD *)v25 + 1) = v24;
      *((_QWORD *)v25 + 1) = *((_QWORD *)v23 + 1);
      *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
      *((_QWORD *)v25 + 3) = *((_QWORD *)v23 + 3);
      v26 = (int)v11 + (_DWORD)v18 + 24;
      v27 = *(uint8 **)&v23[stride];
      v28 = &v23[stride];
      v29 = *((_DWORD *)v28 + 1);
      *(uint8 **)((char *)v11 + v26) = v27;
      v30 = (char *)v11 + v26;
      *((_DWORD *)v30 + 1) = v29;
      *((_QWORD *)v30 + 1) = *((_QWORD *)v28 + 1);
      *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
      *((_QWORD *)v30 + 3) = *((_QWORD *)v28 + 3);
      v31 = (int)v11 + v26 + 24;
      v32 = *(uint8 **)&v28[stride];
      v33 = &v28[stride];
      v34 = *((_DWORD *)v33 + 1);
      *(uint8 **)((char *)v11 + v31) = v32;
      v35 = (char *)v11 + v31;
      *((_DWORD *)v35 + 1) = v34;
      *((_QWORD *)v35 + 1) = *((_QWORD *)v33 + 1);
      *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
      *((_QWORD *)v35 + 3) = *((_QWORD *)v33 + 3);
      v35 += 24;
      v36 = *(uint8 **)&v33[stride];
      v37 = &v33[stride];
      v38 = *((_DWORD *)v37 + 1);
      *(uint8 **)((char *)v11 + (_DWORD)v35) = v36;
      v39 = (char *)v11 + (_DWORD)v35;
      *((_DWORD *)v39 + 1) = v38;
      *((_QWORD *)v39 + 1) = *((_QWORD *)v37 + 1);
      *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
      *((_QWORD *)v39 + 3) = *((_QWORD *)v37 + 3);
      v39 += 24;
      v40 = *(uint8 **)&v37[stride];
      v41 = &v37[stride];
      v42 = *((_DWORD *)v41 + 1);
      *(uint8 **)((char *)v11 + (_DWORD)v39) = v40;
      v43 = (char *)v11 + (_DWORD)v39;
      *((_DWORD *)v43 + 1) = v42;
      *((_QWORD *)v43 + 1) = *((_QWORD *)v41 + 1);
      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
      *((_QWORD *)v43 + 3) = *((_QWORD *)v41 + 3);
      v43 += 24;
      v44 = *(uint8 **)&v41[stride];
      v45 = &v41[stride];
      v46 = *((_DWORD *)v45 + 1);
      *(uint8 **)((char *)v11 + (_DWORD)v43) = v44;
      v47 = (char *)v11 + (_DWORD)v43;
      *((_DWORD *)v47 + 1) = v46;
      *((_QWORD *)v47 + 1) = *((_QWORD *)v45 + 1);
      *((_QWORD *)v47 + 2) = *((_QWORD *)v45 + 2);
      *((_QWORD *)v47 + 3) = *((_QWORD *)v45 + 3);
      v47 += 24;
      v48 = *(uint8 **)&v45[stride];
      v49 = (int)&v45[stride];
      v50 = *(_DWORD *)(v49 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v47) = v48;
      v51 = (char *)v11 + (_DWORD)v47;
      *((_DWORD *)v51 + 1) = v50;
      *((_QWORD *)v51 + 1) = *(_QWORD *)(v49 + 8);
      *((_QWORD *)v51 + 2) = *(_QWORD *)(v49 + 16);
      *((_QWORD *)v51 + 3) = *(_QWORD *)(v49 + 24);
      v51 += 24;
      v52 = *(uint8 **)(v49 + stride);
      v53 = v49 + stride;
      v54 = *(_DWORD *)(v53 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v51) = v52;
      v55 = (char *)v11 + (_DWORD)v51;
      *((_DWORD *)v55 + 1) = v54;
      *((_QWORD *)v55 + 1) = *(_QWORD *)(v53 + 8);
      *((_QWORD *)v55 + 2) = *(_QWORD *)(v53 + 16);
      *((_QWORD *)v55 + 3) = *(_QWORD *)(v53 + 24);
      v55 += 24;
      v56 = *(uint8 **)(v53 + stride);
      v57 = v53 + stride;
      v58 = *(_DWORD *)(v57 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v55) = v56;
      v59 = (char *)v11 + (_DWORD)v55;
      *((_DWORD *)v59 + 1) = v58;
      *((_QWORD *)v59 + 1) = *(_QWORD *)(v57 + 8);
      *((_QWORD *)v59 + 2) = *(_QWORD *)(v57 + 16);
      *((_QWORD *)v59 + 3) = *(_QWORD *)(v57 + 24);
      v59 += 24;
      v60 = *(uint8 **)(v57 + stride);
      v61 = v57 + stride;
      v62 = *(_DWORD *)(v61 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v59) = v60;
      v63 = (char *)v11 + (_DWORD)v59;
      *((_DWORD *)v63 + 1) = v62;
      *((_QWORD *)v63 + 1) = *(_QWORD *)(v61 + 8);
      *((_QWORD *)v63 + 2) = *(_QWORD *)(v61 + 16);
      *((_QWORD *)v63 + 3) = *(_QWORD *)(v61 + 24);
      v63 += 24;
      v64 = *(uint8 **)(v61 + stride);
      v65 = v61 + stride;
      v66 = *(_DWORD *)(v65 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v63) = v64;
      v67 = (char *)v11 + (_DWORD)v63;
      *((_DWORD *)v67 + 1) = v66;
      *((_QWORD *)v67 + 1) = *(_QWORD *)(v65 + 8);
      *((_QWORD *)v67 + 2) = *(_QWORD *)(v65 + 16);
      *((_QWORD *)v67 + 3) = *(_QWORD *)(v65 + 24);
      v67 += 24;
      v68 = *(uint8 **)(v65 + stride);
      v69 = v65 + stride;
      v70 = *(_DWORD *)(v69 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v67) = v68;
      v71 = (char *)v11 + (_DWORD)v67;
      *((_DWORD *)v71 + 1) = v70;
      *((_QWORD *)v71 + 1) = *(_QWORD *)(v69 + 8);
      *((_QWORD *)v71 + 2) = *(_QWORD *)(v69 + 16);
      *((_QWORD *)v71 + 3) = *(_QWORD *)(v69 + 24);
      v71 += 24;
      v72 = *(uint8 **)(v69 + stride);
      v73 = v69 + stride;
      v74 = *(_DWORD *)(v73 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v71) = v72;
      v75 = (char *)v11 + (_DWORD)v71;
      *((_DWORD *)v75 + 1) = v74;
      *((_QWORD *)v75 + 1) = *(_QWORD *)(v73 + 8);
      *((_QWORD *)v75 + 2) = *(_QWORD *)(v73 + 16);
      *((_QWORD *)v75 + 3) = *(_QWORD *)(v73 + 24);
      v75 += 24;
      v76 = *(uint8 **)(v73 + stride);
      v77 = v73 + stride;
      v78 = *(_DWORD *)(v77 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v75) = v76;
      v79 = (char *)v11 + (_DWORD)v75;
      *((_DWORD *)v79 + 1) = v78;
      *((_QWORD *)v79 + 1) = *(_QWORD *)(v77 + 8);
      *((_QWORD *)v79 + 2) = *(_QWORD *)(v77 + 16);
      *((_QWORD *)v79 + 3) = *(_QWORD *)(v77 + 24);
      v79 += 24;
      v80 = *(uint8 **)(v77 + stride);
      v81 = v77 + stride;
      v82 = *(_DWORD *)(v81 + 4);
      *(uint8 **)((char *)v11 + (_DWORD)v79) = v80;
      v83 = (char *)v11 + (_DWORD)v79;
      *((_DWORD *)v83 + 1) = v82;
      *((_QWORD *)v83 + 1) = *(_QWORD *)(v81 + 8);
      *((_QWORD *)v83 + 2) = *(_QWORD *)(v81 + 16);
      *((_QWORD *)v83 + 3) = *(_QWORD *)(v81 + 24);
    }
    while ( v3 );
  }
  RwRasterUnlock(v4);
  v4->privateFlags |= 0x200u;
  v84 = RwTextureCreate(v4);
  if ( !v84 )
  {
LABEL_16:
    RwRasterDestroy(v4);
    return 0;
  }
  v87[0] = 0;
  v87[1] = 0;
  v89 = 0;
  v88 = 0;
  strncpy((char *)v87, v86, 0xAu);
  RwTextureSetName(v84, (const RwChar *)v87);
  LOBYTE(v84->filterAddressing) = 2;
  return v84;
}
// 5A5880: too many cbuild loops

//----- (005A5C40) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomRoadsignMgr::SetupRoadsignAtomic(
        RpAtomic_0 *pAtomic,
        unsigned __int8 *RoadsignText,
        int32 nNumLetters)
{
  RpGeometry_0 *geometry; // r5
  RwTexture_0 *RoadsignTexture; // r2

  geometry = pAtomic->geometry;
  RoadsignTexture = CCustomRoadsignMgr::CreateRoadsignTexture(RoadsignText, nNumLetters);
  if ( !RoadsignTexture )
    return 0;
  RpGeometryForAllMaterials(geometry, SetTextureMatCB, RoadsignTexture);
  return pAtomic;
}

//----- (005A5C6C) --------------------------------------------------------
RpMaterial_0 *__fastcall SetTextureMatCB(RpMaterial_0 *pMaterial, void *pData)
{
  RpMaterialSetTexture(pMaterial, (RwTexture_0 *)pData);
  return pMaterial;
}

//----- (005A5C7C) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomRoadsignMgr::SetAtomicAlpha(RpAtomic_0 *pAtomic, uint8 alpha)
{
  RpGeometryForAllMaterials(pAtomic->geometry, SetMaterialAlphaCB, (void *)alpha);
  return pAtomic;
}

//----- (005A5C98) --------------------------------------------------------
RpMaterial_0 *__fastcall SetMaterialAlphaCB(RpMaterial_0 *pMaterial, void *data)
{
  pMaterial->color._anon_0._anon_0.alpha = (unsigned __int8)data;
  return pMaterial;
}

//----- (005A5CA0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RpAtomic_0 *__fastcall CCustomRoadsignMgr::CreateRoadsignAtomicA(
        float fRsWidth,
        float fRsHeight,
        int32 nNumLines,
        unsigned __int8 *RoadsignText1,
        unsigned __int8 *RoadsignText2,
        unsigned __int8 *RoadsignText3,
        unsigned __int8 *RoadsignText4,
        int32 nNumLettersInLine,
        uint8 nPalID)
{
  int32 v9; // r9
  int32 v10; // r11
  unsigned int v11; // r10
  RpMaterial_0 *v12; // r4
  char v13; // r0
  unsigned int v14; // r1
  RwTexture_0 *RoadsignTexture; // r6
  RpGeometry_0 *v16; // r11
  float *v17; // r2
  unsigned int v18; // r3
  float v19; // s2
  float v20; // s4
  float v21; // s8
  RwV3d_0 *verts; // r0
  float v23; // s12
  float v24; // s5
  float v25; // s7
  float v26; // s9
  RwReal v27; // s11
  RwReal v28; // s9
  _QWORD *p_u; // r0
  int32 v30; // r1
  _QWORD *v31; // r2
  _QWORD *v32; // r0
  RpTriangle_0 *triangles; // r6
  unsigned int v34; // r8
  RpMaterial_0 *v35; // r5
  __int64 v36; // d17
  RpAtomic_0 *v37; // r0
  RpAtomic_0 *v38; // r5
  RwFrame_0 *v39; // r4
  RpMorphTarget_0 *morphTarget; // [sp+Ch] [bp-54h]
  RwSphere_0 v44; // [sp+10h] [bp-50h] BYREF
  RpMaterial_0 *material[2]; // [sp+20h] [bp-40h]
  __int64 v46; // [sp+28h] [bp-38h]
  _DWORD v47[2]; // [sp+34h] [bp-2Ch]
  __int64 v48; // [sp+3Ch] [bp-24h]

  v9 = nNumLines;
  v47[0] = RoadsignText1;
  v47[1] = RoadsignText2;
  v48 = *(_QWORD *)&RoadsignText3;
  *(_QWORD *)material = 0LL;
  v46 = 0LL;
  if ( nNumLines >= 1 )
  {
    v10 = 0;
    v11 = (unsigned __int8)(nPalID - 1);
    do
    {
      v12 = RpMaterialCreate();
      if ( !v12 )
        goto LABEL_33;
      CRGBA::CRGBA((CRGBA *)&v44, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      v13 = -1;
      if ( v11 < 3 )
        v13 = (nPalID - 1) << 7;
      LOBYTE(v14) = -1;
      BYTE1(v44.center.x) = v13;
      if ( v11 < 3 )
        v14 = 0xFF8000u >> (8 * v11);
      LOBYTE(v44.center.x) = v14;
      BYTE2(v44.center.x) = v13;
      v12->color = (RwRGBA_0)LODWORD(v44.center.x);
      RoadsignTexture = CCustomRoadsignMgr::CreateRoadsignTexture((unsigned __int8 *)v47[v10], nNumLettersInLine);
      if ( !RoadsignTexture )
      {
        if ( material[0] )
          RpMaterialDestroy(material[0]);
        if ( material[1] )
          RpMaterialDestroy(material[1]);
        if ( (_DWORD)v46 )
          RpMaterialDestroy((RpMaterial_0 *)v46);
        if ( HIDWORD(v46) )
          RpMaterialDestroy((RpMaterial_0 *)HIDWORD(v46));
        return 0;
      }
      RpMaterialSetTexture(v12, RoadsignTexture);
      RwTextureDestroy(RoadsignTexture);
      v12->surfaceProps.ambient = 0.3;
      v12->surfaceProps.specular = 0.3;
      v12->surfaceProps.diffuse = 0.7;
      material[v10++] = v12;
    }
    while ( v10 < v9 );
  }
  v16 = RpGeometryCreate(4 * v9, 2 * v9, 0x4Eu);
  if ( !v16 )
  {
LABEL_33:
    if ( material[0] )
      RpMaterialDestroy(material[0]);
    if ( material[1] )
      RpMaterialDestroy(material[1]);
    if ( (_DWORD)v46 )
      RpMaterialDestroy((RpMaterial_0 *)v46);
    if ( HIDWORD(v46) )
      RpMaterialDestroy((RpMaterial_0 *)HIDWORD(v46));
    return 0;
  }
  morphTarget = v16->morphTarget;
  if ( v9 >= 1 )
  {
    v17 = (float *)dword_5A60B8;
    v18 = 0;
    v19 = fRsHeight / (float)v9;
    v20 = v19 * 0.95;
    v21 = fRsWidth * 0.0;
    verts = morphTarget->verts;
    v23 = (float)(v19 * 0.95) * 0.0;
    v24 = (float)(fRsWidth * -0.5) + (float)(fRsWidth * 0.0);
    v25 = (float)(fRsWidth * -0.5) + fRsWidth;
    do
    {
      v26 = 0.0;
      verts[1].z = 0.0;
      verts->z = 0.0;
      verts[2].z = 0.0;
      verts[3].z = 0.0;
      verts->x = v21;
      verts->y = v23;
      verts[1].x = fRsWidth;
      verts[1].y = v23;
      verts[2].x = fRsWidth;
      verts[2].y = v20;
      verts[3].x = v21;
      verts[3].y = v20;
      switch ( v9 )
      {
        case 1:
          v26 = v19 * -0.5;
          break;
        case 2:
          v26 = -v19;
          if ( v18 != 1 )
          {
            v26 = 0.0;
            if ( !v18 )
              v26 = v19 * 0.0;
          }
          break;
        case 3:
          v26 = 0.0;
          if ( v18 <= 2 )
            v26 = v19 * *v17;
          break;
        case 4:
          v26 = fRsHeight / (float)v9;
          switch ( v18 )
          {
            case 1u:
              v26 = v19 * 0.0;
              break;
            case 2u:
              v26 = -v19;
              break;
            case 3u:
              v26 = v19 * -2.0;
              break;
            default:
              goto LABEL_25;
          }
          break;
        default:
          break;
      }
LABEL_25:
      v27 = v26 + v23;
      verts->x = v24;
      v28 = v26 + v20;
      verts->z = 0.0;
      verts[1].z = 0.0;
      ++v18;
      verts[2].z = 0.0;
      ++v17;
      verts[3].z = 0.0;
      verts->y = v27;
      verts[1].x = v25;
      verts[1].y = v27;
      verts[2].x = v25;
      verts[2].y = v28;
      verts[3].x = v24;
      verts[3].y = v28;
      verts += 4;
    }
    while ( v9 != v18 );
    p_u = (_QWORD *)&v16->texCoords[0]->u;
    v30 = v9;
    do
    {
      v31 = p_u + 4;
      *p_u = 0x3F80000000000000LL;
      p_u[1] = 0x3F8000003F800000LL;
      v32 = p_u + 2;
      --v30;
      *v32 = 1065353216LL;
      v32[1] = 0LL;
      p_u = v31;
    }
    while ( v30 );
    memset(v16->preLitLum, 255, 16 * v9);
    triangles = v16->triangles;
    v34 = 0;
    do
    {
      RpGeometryTriangleSetVertexIndices(v16, triangles, v34, v34 + 1, v34 + 2);
      RpGeometryTriangleSetMaterial(v16, triangles, material[v34 / 4]);
      RpGeometryTriangleSetVertexIndices(v16, triangles + 1, v34, v34 + 2, v34 + 3);
      v35 = material[v34 / 4];
      RpGeometryTriangleSetMaterial(v16, triangles + 1, v35);
      RpMaterialDestroy(v35);
      triangles += 2;
      material[v34 / 4] = 0;
      --v9;
      v34 += 4;
    }
    while ( v9 );
  }
  RpMorphTargetCalcBoundingSphere(morphTarget, &v44);
  v36 = *(_QWORD *)&v44.center.z;
  *(_QWORD *)&morphTarget->boundingSphere.center.x = *(_QWORD *)&v44.center.x;
  *(_QWORD *)&morphTarget->boundingSphere.center.z = v36;
  RpGeometryUnlock(v16);
  v37 = RpAtomicCreate();
  v38 = v37;
  if ( !v37 )
  {
    if ( material[0] )
      RpMaterialDestroy(material[0]);
    if ( material[1] )
      RpMaterialDestroy(material[1]);
    if ( (_DWORD)v46 )
      RpMaterialDestroy((RpMaterial_0 *)v46);
    if ( HIDWORD(v46) )
      RpMaterialDestroy((RpMaterial_0 *)HIDWORD(v46));
    RpGeometryDestroy(v16);
    return 0;
  }
  if ( !RpAtomicSetGeometry(v37, v16, 0) )
  {
    if ( material[0] )
      RpMaterialDestroy(material[0]);
    if ( material[1] )
      RpMaterialDestroy(material[1]);
    if ( (_DWORD)v46 )
      RpMaterialDestroy((RpMaterial_0 *)v46);
    if ( HIDWORD(v46) )
      RpMaterialDestroy((RpMaterial_0 *)HIDWORD(v46));
    RpGeometryDestroy(v16);
    RpAtomicDestroy(v38);
    return 0;
  }
  RpGeometryDestroy(v16);
  v38->object.object.flags = 4;
  v39 = RwFrameCreate();
  RwFrameSetIdentity(v39);
  RpAtomicSetFrame(v38, v39);
  return v38;
}
// 5A5EC6: conditional instruction was optimized away because r9.4>=1
// 5A5EF0: conditional instruction was optimized away because r9.4>=1
// 5A5CA0: variables would overlap: ^6C.4 and ^6C.8
// 5A60B8: using guessed type int dword_5A60B8[3];
// 5A5CA0: using guessed type _DWORD var_2C[2];

//----- (005A60C4) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomRoadsignMgr::CreateRoadsignAtomic(
        float rsWidth,
        float rsHeight,
        int32 nNumLines,
        unsigned __int8 *text1,
        __int64 text2,
        unsigned __int8 *text4,
        int32 nNumLettersInLine,
        uint8 nPalID)
{
  unsigned __int8 *RoadsignText4; // r4
  unsigned __int8 *RoadsignText2; // r5
  unsigned __int8 *v10; // r6
  __int64 RoadsignText1[2]; // [sp+18h] [bp-30h] BYREF

  RoadsignText4 = text4;
  v10 = (unsigned __int8 *)HIDWORD(text2);
  RoadsignText2 = (unsigned __int8 *)text2;
  RoadsignText1[0] = unk_61F5B0;
  RoadsignText1[1] = unk_61F5B8;
  if ( !text4 )
    RoadsignText4 = (unsigned __int8 *)RoadsignText1;
  if ( !HIDWORD(text2) )
    v10 = (unsigned __int8 *)RoadsignText1;
  if ( !(_DWORD)text2 )
    RoadsignText2 = (unsigned __int8 *)RoadsignText1;
  if ( !text1 )
    text1 = (unsigned __int8 *)RoadsignText1;
  return CCustomRoadsignMgr::CreateRoadsignAtomicA(
           rsWidth,
           rsHeight,
           nNumLines,
           text1,
           RoadsignText2,
           v10,
           RoadsignText4,
           nNumLettersInLine,
           nPalID);
}

//----- (005A614C) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomRoadsignMgr::RenderRoadsignAtomic(RpAtomic_0 *pAtomic, const CVector *camPos)
{
  char *parent; // r0
  float32x2_t v4; // d16
  unsigned __int64 v5; // d1
  float v6; // s0
  unsigned int v7; // r2
  RpGeometry_0 *geometry; // r0

  parent = (char *)pAtomic->object.object.parent;
  v4.n64_u64[0] = vsub_f32(*(float32x2_t *)&camPos->y, *(float32x2_t *)(parent + 68)).n64_u64[0];
  v5 = vmul_f32(v4, v4).n64_u64[0];
  v6 = (float)((float)((float)(camPos->x - *((float *)parent + 16)) * (float)(camPos->x - *((float *)parent + 16)))
             + *(float *)&v5)
     + *((float *)&v5 + 1);
  if ( v6 <= 250000.0 )
  {
    if ( v6 >= 1600.0 )
    {
      geometry = pAtomic->geometry;
      v7 = (unsigned int)(float)((float)((float)(250000.0 - v6) / 248400.0) * 254.0);
    }
    else
    {
      RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, &dword_64);
      v7 = 255;
      geometry = pAtomic->geometry;
    }
    RpGeometryForAllMaterials(geometry, SetMaterialAlphaCB, (void *)v7);
    pAtomic->renderCallBack(pAtomic);
  }
  return pAtomic;
}
// 64: using guessed type int dword_64;

//----- (005A61F4) --------------------------------------------------------
void __fastcall CDraw::SetFOV(float fFOV, bool isCinematic)
{
  CDraw::ms_fFOV = (float)((float)((float)(CDraw::ms_fAspectRatio + -1.3333) * 11.0) / 0.44444) + fFOV;
}

//----- (005A623C) --------------------------------------------------------
float CDraw::CalculateAspectRatio()
{
  float Width; // s16
  float result; // r0

  CDraw::ms_fAspectRatio = 0.0;
  Width = (float)(unsigned int)OS_ScreenGetWidth();
  result = Width / (float)(unsigned int)OS_ScreenGetHeight();
  CDraw::ms_fAspectRatio = result;
  return result;
}

//----- (005A627C) --------------------------------------------------------
void CMovingThings::Init()
{
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[10] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[4] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[6] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[10] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[4] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[6] = 0LL;
  *(_QWORD *)CPlaneTrails::aArray[1].aTimeWhenAdded = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[2] = 0LL;
  *(_QWORD *)CPlaneTrails::aArray[0].aTimeWhenAdded = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[2] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[10] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[4] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[6] = 0LL;
  *(_QWORD *)CPlaneTrails::aArray[2].aTimeWhenAdded = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[2] = 0LL;
  CPointLights::Init();
  CEscalators::Init();
}

//----- (005A62F8) --------------------------------------------------------
void CPlaneTrails::Init()
{
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[10] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[4] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[6] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[10] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[4] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[6] = 0LL;
  *(_QWORD *)CPlaneTrails::aArray[1].aTimeWhenAdded = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[1].aTimeWhenAdded[2] = 0LL;
  *(_QWORD *)CPlaneTrails::aArray[0].aTimeWhenAdded = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[0].aTimeWhenAdded[2] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[10] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[4] = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[6] = 0LL;
  *(_QWORD *)CPlaneTrails::aArray[2].aTimeWhenAdded = 0LL;
  *(_QWORD *)&CPlaneTrails::aArray[2].aTimeWhenAdded[2] = 0LL;
}

//----- (005A6368) --------------------------------------------------------
void CEscalators::Init()
{
  int v0; // r9
  CObject **pSteps; // r4
  CEscalator *v2; // r2
  bool *p_bActive; // r2
  _BOOL4 bActive; // t1
  CEscalator *v5; // r10
  Int32 v6; // r1
  Int32 *p_NumNormalStepsNeeded; // r10
  Int32 NumNormalStepsNeeded; // t1
  Int32 v9; // r2
  Int32 v10; // r3
  int v11; // r5
  CEntity *v12; // r0
  CObject *v13; // r0
  CEscalator *v14; // r0
  int v15; // r8
  CObject **v16; // r4
  CEscalator *v17; // r2
  bool *v18; // r2
  _BOOL4 v19; // t1
  CEscalator *v20; // r11
  Int32 v21; // r1
  Int32 *v22; // r11
  Int32 v23; // t1
  Int32 v24; // r2
  Int32 v25; // r3
  int v26; // r6
  CEntity *v27; // r0
  CObject *v28; // r0
  bool *v29; // [sp+Ch] [bp-24h]
  bool *v30; // [sp+Ch] [bp-24h]

  v0 = 0;
  pSteps = CEscalators::aArray[0].pSteps;
  do
  {
    v2 = &CEscalators::aArray[v0];
    bActive = v2->bActive;
    p_bActive = &v2->bActive;
    if ( bActive )
    {
      v5 = &CEscalators::aArray[v0];
      v29 = p_bActive;
      NumNormalStepsNeeded = v5->NumNormalStepsNeeded;
      p_NumNormalStepsNeeded = &v5->NumNormalStepsNeeded;
      v6 = NumNormalStepsNeeded;
      v9 = p_NumNormalStepsNeeded[1];
      v10 = p_NumNormalStepsNeeded[2];
      if ( v9 + NumNormalStepsNeeded + v10 >= 1 )
      {
        v11 = 0;
        do
        {
          v12 = pSteps[v11];
          if ( v12 )
          {
            CWorld::Remove(v12);
            deletingEscalator = 1;
            v13 = pSteps[v11];
            if ( v13 )
              (*((void (__fastcall **)(CObject *))v13->_vptr$CPlaceable + 1))(v13);
            pSteps[v11] = 0;
            v10 = p_NumNormalStepsNeeded[2];
            v9 = p_NumNormalStepsNeeded[1];
            v6 = *p_NumNormalStepsNeeded;
            deletingEscalator = 0;
          }
          ++v11;
        }
        while ( v11 < v9 + v10 + v6 );
      }
      *v29 = 0;
    }
    pSteps += 84;
    v14 = &CEscalators::aArray[v0++];
    v14->bUsed = 0;
  }
  while ( v0 != 32 );
  v15 = 0;
  v16 = CEscalators::aArray[0].pSteps;
  do
  {
    v17 = &CEscalators::aArray[v15];
    v19 = v17->bActive;
    v18 = &v17->bActive;
    if ( v19 )
    {
      v20 = &CEscalators::aArray[v15];
      v30 = v18;
      v23 = v20->NumNormalStepsNeeded;
      v22 = &v20->NumNormalStepsNeeded;
      v21 = v23;
      v24 = v22[1];
      v25 = v22[2];
      if ( v24 + v23 + v25 >= 1 )
      {
        v26 = 0;
        do
        {
          v27 = v16[v26];
          if ( v27 )
          {
            CWorld::Remove(v27);
            deletingEscalator = 1;
            v28 = v16[v26];
            if ( v28 )
              (*((void (__fastcall **)(CObject *))v28->_vptr$CPlaceable + 1))(v28);
            v16[v26] = 0;
            v25 = v22[2];
            v24 = v22[1];
            v21 = *v22;
            deletingEscalator = 0;
          }
          ++v26;
        }
        while ( v26 < v24 + v25 + v21 );
      }
      *v30 = 0;
    }
    ++v15;
    v16 += 84;
  }
  while ( v15 != 32 );
}

//----- (005A6530) --------------------------------------------------------
void CMovingThings::Shutdown()
{
  int v0; // r9
  CObject **pSteps; // r4
  CEscalator *v2; // r2
  bool *p_bActive; // r2
  _BOOL4 bActive; // t1
  CEscalator *v5; // r10
  Int32 v6; // r1
  Int32 *p_NumNormalStepsNeeded; // r10
  Int32 NumNormalStepsNeeded; // t1
  Int32 v9; // r2
  Int32 v10; // r3
  int v11; // r5
  CEntity *v12; // r0
  CObject *v13; // r0
  CEscalator *v14; // r0
  bool *v15; // [sp+Ch] [bp-24h]

  v0 = 0;
  pSteps = CEscalators::aArray[0].pSteps;
  do
  {
    v2 = &CEscalators::aArray[v0];
    bActive = v2->bActive;
    p_bActive = &v2->bActive;
    if ( bActive )
    {
      v5 = &CEscalators::aArray[v0];
      v15 = p_bActive;
      NumNormalStepsNeeded = v5->NumNormalStepsNeeded;
      p_NumNormalStepsNeeded = &v5->NumNormalStepsNeeded;
      v6 = NumNormalStepsNeeded;
      v9 = p_NumNormalStepsNeeded[1];
      v10 = p_NumNormalStepsNeeded[2];
      if ( v9 + NumNormalStepsNeeded + v10 >= 1 )
      {
        v11 = 0;
        do
        {
          v12 = pSteps[v11];
          if ( v12 )
          {
            CWorld::Remove(v12);
            deletingEscalator = 1;
            v13 = pSteps[v11];
            if ( v13 )
              (*((void (__fastcall **)(CObject *))v13->_vptr$CPlaceable + 1))(v13);
            pSteps[v11] = 0;
            v10 = p_NumNormalStepsNeeded[2];
            v9 = p_NumNormalStepsNeeded[1];
            v6 = *p_NumNormalStepsNeeded;
            deletingEscalator = 0;
          }
          ++v11;
        }
        while ( v11 < v9 + v10 + v6 );
      }
      *v15 = 0;
    }
    pSteps += 84;
    v14 = &CEscalators::aArray[v0++];
    v14->bUsed = 0;
  }
  while ( v0 != 32 );
}

//----- (005A6628) --------------------------------------------------------
void CEscalators::Shutdown()
{
  int v0; // r9
  CObject **pSteps; // r4
  CEscalator *v2; // r2
  bool *p_bActive; // r2
  _BOOL4 bActive; // t1
  CEscalator *v5; // r10
  Int32 v6; // r1
  Int32 *p_NumNormalStepsNeeded; // r10
  Int32 NumNormalStepsNeeded; // t1
  Int32 v9; // r2
  Int32 v10; // r3
  int v11; // r5
  CEntity *v12; // r0
  CObject *v13; // r0
  CEscalator *v14; // r0
  bool *v15; // [sp+Ch] [bp-24h]

  v0 = 0;
  pSteps = CEscalators::aArray[0].pSteps;
  do
  {
    v2 = &CEscalators::aArray[v0];
    bActive = v2->bActive;
    p_bActive = &v2->bActive;
    if ( bActive )
    {
      v5 = &CEscalators::aArray[v0];
      v15 = p_bActive;
      NumNormalStepsNeeded = v5->NumNormalStepsNeeded;
      p_NumNormalStepsNeeded = &v5->NumNormalStepsNeeded;
      v6 = NumNormalStepsNeeded;
      v9 = p_NumNormalStepsNeeded[1];
      v10 = p_NumNormalStepsNeeded[2];
      if ( v9 + NumNormalStepsNeeded + v10 >= 1 )
      {
        v11 = 0;
        do
        {
          v12 = pSteps[v11];
          if ( v12 )
          {
            CWorld::Remove(v12);
            deletingEscalator = 1;
            v13 = pSteps[v11];
            if ( v13 )
              (*((void (__fastcall **)(CObject *))v13->_vptr$CPlaceable + 1))(v13);
            pSteps[v11] = 0;
            v10 = p_NumNormalStepsNeeded[2];
            v9 = p_NumNormalStepsNeeded[1];
            v6 = *p_NumNormalStepsNeeded;
            deletingEscalator = 0;
          }
          ++v11;
        }
        while ( v11 < v9 + v10 + v6 );
      }
      *v15 = 0;
    }
    pSteps += 84;
    v14 = &CEscalators::aArray[v0++];
    v14->bUsed = 0;
  }
  while ( v0 != 32 );
}

//----- (005A6720) --------------------------------------------------------
void CMovingThings::Update()
{
  int i; // r4

  CPlaneTrails::Update();
  for ( i = 0; i != 32; ++i )
  {
    if ( CEscalators::aArray[i].bUsed )
      CEscalator::Update(&CEscalators::aArray[i]);
  }
}

//----- (005A6764) --------------------------------------------------------
void CPlaneTrails::Update()
{
  __int64 v0; // d8
  float v1; // r4
  float v2; // r5
  float v3; // r0
  float v4; // r5
  float v5; // r6
  float v6; // r0
  float v7; // r5
  float v8; // r6
  float v9; // r0
  CVector Coors; // [sp+44h] [bp-2Ch] BYREF
  __int64 v11; // [sp+50h] [bp-20h]
  CVector v12; // 0:r1.12
  CVector v13; // 0:r1.12
  CVector v14; // 0:r1.12

  if ( MobileSettings::settings[0].value >= 2 )
  {
    v11 = v0;
    v1 = (float)(CTimer::m_snTimeInMilliseconds & 0x1FFFF) * 0.000047937;
    v2 = sinf(v1);
    v3 = cosf(v1);
    Coors.z = 550.0;
    v12.z = 550.0;
    v12.x = v2 * 2590.0;
    Coors.x = v2 * 2590.0;
    v12.y = v3 * 2200.0;
    Coors.y = v3 * 2200.0;
    CPlaneTrail::RegisterPoint(CPlaneTrails::aArray, v12);
    if ( (unsigned __int8)(CClock::ms_nGameClockHours - 7) >= 0x10u )
    {
      if ( (CTimer::m_snTimeInMilliseconds & 0x200) != 0 )
        CCoronas::RegisterCorona(
          0x65u,
          0,
          0xFFu,
          0,
          0,
          0xFFu,
          &Coors,
          5.0,
          2000.0,
          1,
          0,
          0,
          0,
          0,
          0.0,
          0,
          1.5,
          0,
          15.0,
          0,
          0);
      else
        CCoronas::UpdateCoronaCoors(0x65u, &Coors, 2000.0, 0.0);
    }
    v4 = (float)(CTimer::m_snTimeInMilliseconds & 0x1FFFF) * 0.000047937;
    v5 = sinf(v4);
    v6 = cosf(v4);
    v13.z = 500.0;
    Coors.z = 500.0;
    v13.x = v5 * 2000.0;
    Coors.x = v5 * 2000.0;
    v13.y = v6 * -2600.0;
    Coors.y = v6 * -2600.0;
    CPlaneTrail::RegisterPoint(&CPlaneTrails::aArray[1], v13);
    if ( (unsigned __int8)(CClock::ms_nGameClockHours - 7) >= 0xFu )
    {
      if ( ((CTimer::m_snTimeInMilliseconds + 350) & 0x200) != 0 )
        CCoronas::RegisterCorona(
          0x66u,
          0,
          0xFFu,
          0xFFu,
          0x80u,
          0xFFu,
          &Coors,
          5.0,
          2000.0,
          1,
          0,
          0,
          0,
          0,
          0.0,
          0,
          1.5,
          0,
          15.0,
          0,
          0);
      else
        CCoronas::UpdateCoronaCoors(0x66u, &Coors, 2000.0, 0.0);
    }
    v7 = (float)(CTimer::m_snTimeInMilliseconds & 0x1FFFF) * 0.000047937;
    v8 = cosf(v7);
    v9 = sinf(v7);
    Coors.z = 600.0;
    v14.z = 600.0;
    v14.x = v8 * 2100.0;
    Coors.x = v8 * 2100.0;
    v14.y = v9 * 1300.0;
    Coors.y = v9 * 1300.0;
    CPlaneTrail::RegisterPoint(&CPlaneTrails::aArray[2], v14);
    if ( (unsigned __int8)(CClock::ms_nGameClockHours - 6) >= 0xFu )
    {
      if ( ((CTimer::m_snTimeInMilliseconds + 200) & 0x200) != 0 )
        CCoronas::RegisterCorona(
          0x67u,
          0,
          0xFFu,
          0xFFu,
          0xFFu,
          0xFFu,
          &Coors,
          5.0,
          2000.0,
          1,
          0,
          0,
          0,
          0,
          0.0,
          0,
          1.5,
          0,
          15.0,
          0,
          0);
      else
        CCoronas::UpdateCoronaCoors(0x67u, &Coors, 2000.0, 0.0);
    }
  }
}
// 5A677A: variable 'v0' is possibly undefined

//----- (005A6AA0) --------------------------------------------------------
void CEscalators::Update()
{
  int i; // r4

  for ( i = 0; i != 32; ++i )
  {
    if ( CEscalators::aArray[i].bUsed )
      CEscalator::Update(&CEscalators::aArray[i]);
  }
}

//----- (005A6AE4) --------------------------------------------------------
void CPlaneTrails::Render()
{
  float32x2_t v0; // d1
  float32x2_t v1; // d4
  float v2; // s4
  unsigned int m_nSkyBottomGreen; // r0
  unsigned int m_nSkyBottomBlue; // r1
  unsigned int v5; // r2
  float v6; // s2

  v2 = CWeather::Foggyness;
  m_nSkyBottomGreen = CTimeCycle::m_CurrentColours.m_nSkyBottomGreen;
  m_nSkyBottomBlue = CTimeCycle::m_CurrentColours.m_nSkyBottomBlue;
  if ( CTimeCycle::m_CurrentColours.m_nSkyBottomRed > (unsigned int)CTimeCycle::m_CurrentColours.m_nSkyBottomGreen )
    m_nSkyBottomGreen = CTimeCycle::m_CurrentColours.m_nSkyBottomRed;
  v5 = CTimeCycle::m_CurrentColours.m_nSkyBottomBlue;
  if ( m_nSkyBottomGreen > CTimeCycle::m_CurrentColours.m_nSkyBottomBlue )
    v5 = m_nSkyBottomGreen;
  if ( (float)(1.0 - CWeather::CloudCoverage) < (float)(1.0 - CWeather::Foggyness) )
    v2 = CWeather::CloudCoverage;
  v1.n64_f32[0] = 1.0 - CWeather::Rain;
  v0.n64_f32[0] = 1.0 - v2;
  v6 = vmin_f32(v0, v1).n64_f32[0];
  if ( v6 >= (float)((float)v5 * 0.0039062) )
  {
    if ( m_nSkyBottomGreen > CTimeCycle::m_CurrentColours.m_nSkyBottomBlue )
      m_nSkyBottomBlue = m_nSkyBottomGreen;
    v6 = (float)m_nSkyBottomBlue * 0.0039062;
  }
  if ( v6 > 0.0001 )
  {
    CPlaneTrail::Render(CPlaneTrails::aArray, v6);
    CPlaneTrail::Render(&CPlaneTrails::aArray[1], v6);
    CPlaneTrail::Render(&CPlaneTrails::aArray[2], v6);
  }
}
// 5A6B4E: variable 'v0' is possibly undefined
// 5A6B4E: variable 'v1' is possibly undefined

//----- (005A6BCA) --------------------------------------------------------
void __fastcall CPlaneTrail::Init(CPlaneTrail *this)
{
  UInt32 *v1; // r1
  UInt32 *aTimeWhenAdded; // r0

  *(_QWORD *)&this->aTimeWhenAdded[12] = 0LL;
  *(_QWORD *)&this->aTimeWhenAdded[14] = 0LL;
  *(_QWORD *)&this->aTimeWhenAdded[8] = 0LL;
  *(_QWORD *)&this->aTimeWhenAdded[10] = 0LL;
  v1 = &this->aTimeWhenAdded[4];
  aTimeWhenAdded = this->aTimeWhenAdded;
  *(_QWORD *)v1 = 0LL;
  *((_QWORD *)v1 + 1) = 0LL;
  *(_QWORD *)aTimeWhenAdded = 0LL;
  *((_QWORD *)aTimeWhenAdded + 1) = 0LL;
}

//----- (005A6BF0) --------------------------------------------------------
void __fastcall CPlaneTrail::Render(CPlaneTrail *this, float WeatherAlpha)
{
  float32x2_t v2; // d3
  float32x2_t v3; // d4
  float v4; // s0
  UInt32 *aTimeWhenAdded; // r0
  int v6; // r1
  unsigned int v7; // r6
  uint32 v8; // r11
  signed int v9; // r10
  UInt32 v10; // r5
  unsigned int v11; // r3
  signed int v12; // r5
  _DWORD *p_x; // r4
  UInt32 v14; // r12
  UInt32 v15; // r2

  if ( (int)(float)(WeatherAlpha * 110.0) )
  {
    v4 = (float)(int)(float)(WeatherAlpha * 110.0);
    v2.n64_u32[0] = 1.0;
    aTimeWhenAdded = this->aTimeWhenAdded;
    v6 = -48;
    v7 = 0;
    v8 = CTimer::m_snTimeInMilliseconds;
    v9 = 0;
    do
    {
      v10 = aTimeWhenAdded[v7 / 4];
      v11 = v8 - v10;
      if ( v8 - v10 < 0x7531 )
      {
        if ( v10 )
        {
          v12 = v9;
          p_x = (_DWORD *)&TempVertexBuffer.m_3d[v9++].position.x;
          v3.n64_f32[0] = (float)(30000.0 - (float)v11) / 10000.0;
          v3.n64_u64[0] = vmin_f32(v3, v2).n64_u64[0];
          p_x[6] = ((int)(float)(v3.n64_f32[0] * v4) << 24) | 0xFFFFFF;
          v14 = aTimeWhenAdded[v6 + 2];
          v15 = aTimeWhenAdded[3 * v7 / 4 - 47];
          LODWORD(TempVertexBuffer.m_3d[v12].position.x) = aTimeWhenAdded[v6];
          p_x[1] = v15;
          p_x[2] = v14;
        }
      }
      else
      {
        aTimeWhenAdded[v7 / 4] = 0;
      }
      v7 += 4;
      v6 += 3;
    }
    while ( v6 * 4 );
    if ( v9 >= 2 )
    {
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, v9, 0, 0x18u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPELINELIST, TrailIndices, 2 * v9 - 2);
        sub_18D77C();
      }
    }
  }
}
// 5A6C7A: variable 'v3' is possibly undefined
// 5A6C7A: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005A6D2C) --------------------------------------------------------
void __fastcall CPlaneTrail::RegisterPoint(CPlaneTrail *this, CVector Coors)
{
  UInt32 v2; // r12
  __int64 v3; // kr00_8
  RwReal z; // r11
  RwReal v5; // r8
  __int64 v6; // d16
  UInt32 v7; // r9
  __int64 v8; // d17
  __int64 v9; // d18
  __int64 v10; // d19
  __int64 v11; // d20
  __int64 v12; // d21
  RwReal v13; // r4
  UInt32 v14; // lr
  RwReal v15; // r5
  UInt32 v16; // r10
  RwReal v17; // r6
  UInt32 v18; // r6
  RwReal v19; // r5
  __int64 v20; // d16
  UInt32 v21; // r6
  RwReal v22; // r5
  __int64 v23; // d17
  UInt32 v24; // r6
  RwReal v25; // r5
  __int64 v26; // d16
  UInt32 v27; // r6
  RwReal v28; // r5
  __int64 v29; // d17
  UInt32 v30; // r6
  RwReal v31; // r5
  __int64 v32; // d16
  UInt32 v33; // r6
  RwReal v34; // r5
  __int64 v35; // d17
  UInt32 v36; // r6
  RwReal v37; // r5
  __int64 v38; // d16
  UInt32 v39; // r6
  RwReal v40; // r5
  __int64 v41; // d17
  __int64 v42; // d16
  UInt32 v43; // r6
  RwReal v44; // r5

  v2 = this->aTimeWhenAdded[0];
  if ( !v2 )
    goto LABEL_4;
  if ( CTimer::m_snTimeInMilliseconds - v2 > 0x7D0 )
  {
    v3 = *(_QWORD *)&this->aTimeWhenAdded[13];
    z = this->aPoints[13].z;
    v5 = this->aPoints[12].z;
    v6 = *(_QWORD *)&this->aPoints[14].x;
    v7 = this->aTimeWhenAdded[12];
    v8 = *(_QWORD *)&this->aPoints[13].x;
    v9 = *(_QWORD *)&this->aPoints[9].x;
    v10 = *(_QWORD *)&this->aPoints[10].x;
    v11 = *(_QWORD *)&this->aPoints[11].x;
    v12 = *(_QWORD *)&this->aPoints[12].x;
    v13 = this->aPoints[11].z;
    this->aPoints[15].z = this->aPoints[14].z;
    v14 = this->aTimeWhenAdded[11];
    this->aTimeWhenAdded[14] = v3;
    v15 = this->aPoints[10].z;
    this->aTimeWhenAdded[15] = HIDWORD(v3);
    v16 = this->aTimeWhenAdded[10];
    this->aPoints[14].z = z;
    v17 = this->aPoints[9].z;
    this->aPoints[13].z = v5;
    this->aTimeWhenAdded[13] = v7;
    *(_QWORD *)&this->aPoints[15].x = v6;
    *(_QWORD *)&this->aPoints[14].x = v8;
    *(_QWORD *)&this->aPoints[13].x = v12;
    this->aPoints[12].z = v13;
    *(_QWORD *)&this->aPoints[12].x = v11;
    this->aTimeWhenAdded[12] = v14;
    this->aPoints[11].z = v15;
    *(_QWORD *)&this->aPoints[11].x = v10;
    this->aTimeWhenAdded[11] = v16;
    this->aPoints[10].z = v17;
    v18 = this->aTimeWhenAdded[9];
    v19 = this->aPoints[8].z;
    v20 = *(_QWORD *)&this->aPoints[8].x;
    *(_QWORD *)&this->aPoints[10].x = v9;
    this->aTimeWhenAdded[10] = v18;
    this->aPoints[9].z = v19;
    v21 = this->aTimeWhenAdded[8];
    v22 = this->aPoints[7].z;
    v23 = *(_QWORD *)&this->aPoints[7].x;
    *(_QWORD *)&this->aPoints[9].x = v20;
    this->aTimeWhenAdded[9] = v21;
    this->aPoints[8].z = v22;
    v24 = this->aTimeWhenAdded[7];
    v25 = this->aPoints[6].z;
    v26 = *(_QWORD *)&this->aPoints[6].x;
    *(_QWORD *)&this->aPoints[8].x = v23;
    this->aTimeWhenAdded[8] = v24;
    this->aPoints[7].z = v25;
    v27 = this->aTimeWhenAdded[6];
    v28 = this->aPoints[5].z;
    v29 = *(_QWORD *)&this->aPoints[5].x;
    *(_QWORD *)&this->aPoints[7].x = v26;
    this->aTimeWhenAdded[7] = v27;
    this->aPoints[6].z = v28;
    v30 = this->aTimeWhenAdded[5];
    v31 = this->aPoints[4].z;
    v32 = *(_QWORD *)&this->aPoints[4].x;
    *(_QWORD *)&this->aPoints[6].x = v29;
    this->aTimeWhenAdded[6] = v30;
    this->aPoints[5].z = v31;
    v33 = this->aTimeWhenAdded[4];
    v34 = this->aPoints[3].z;
    v35 = *(_QWORD *)&this->aPoints[3].x;
    *(_QWORD *)&this->aPoints[5].x = v32;
    this->aTimeWhenAdded[5] = v33;
    this->aPoints[4].z = v34;
    v36 = this->aTimeWhenAdded[3];
    v37 = this->aPoints[2].z;
    v38 = *(_QWORD *)&this->aPoints[2].x;
    *(_QWORD *)&this->aPoints[4].x = v35;
    this->aTimeWhenAdded[4] = v36;
    this->aPoints[3].z = v37;
    v39 = this->aTimeWhenAdded[2];
    v40 = this->aPoints[1].z;
    v41 = *(_QWORD *)&this->aPoints[1].x;
    *(_QWORD *)&this->aPoints[3].x = v38;
    this->aTimeWhenAdded[3] = v39;
    this->aPoints[2].z = v40;
    v42 = *(_QWORD *)&this->aPoints[0].x;
    v43 = this->aTimeWhenAdded[1];
    v44 = this->aPoints[0].z;
    *(_QWORD *)&this->aPoints[2].x = v41;
    this->aTimeWhenAdded[2] = v43;
    this->aPoints[1].z = v44;
    *(_QWORD *)&this->aPoints[1].x = v42;
    this->aTimeWhenAdded[1] = v2;
LABEL_4:
    this->aPoints[0] = Coors;
    this->aTimeWhenAdded[0] = CTimer::m_snTimeInMilliseconds;
    return;
  }
  this->aPoints[0] = Coors;
}

//----- (005A6EBC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CPlaneTrails::RegisterPoint(CVector Coors, UInt32 ID)
{
  RwReal z; // r12
  int v3; // r3
  RwReal v4; // r3

  z = Coors.z;
  Coors.z = Coors.y;
  Coors.y = Coors.x;
  LODWORD(Coors.x) = &CPlaneTrails::aArray[v3];
  v4 = z;
  CPlaneTrail::RegisterPoint((CPlaneTrail *)LODWORD(Coors.x), *(CVector *)&Coors.y);
}
// 5A6EBC: variables would overlap: 0:r0.12 and r0.16

//----- (005A6EE4) --------------------------------------------------------
void __fastcall CEscalator::SwitchOff(CEscalator *this)
{
  Int32 NumNormalStepsNeeded; // r1
  Int32 NumBiggerStepsNeeded1; // r2
  Int32 NumBiggerStepsNeeded2; // r3
  CObject **pSteps; // r5
  int v6; // r6
  CEntity *v7; // r0
  CObject *v8; // r0

  if ( this->bActive )
  {
    NumNormalStepsNeeded = this->NumNormalStepsNeeded;
    NumBiggerStepsNeeded1 = this->NumBiggerStepsNeeded1;
    NumBiggerStepsNeeded2 = this->NumBiggerStepsNeeded2;
    if ( NumBiggerStepsNeeded1 + NumNormalStepsNeeded + NumBiggerStepsNeeded2 >= 1 )
    {
      pSteps = this->pSteps;
      v6 = 0;
      do
      {
        v7 = pSteps[v6];
        if ( v7 )
        {
          CWorld::Remove(v7);
          deletingEscalator = 1;
          v8 = pSteps[v6];
          if ( v8 )
            (*((void (__fastcall **)(CObject *))v8->_vptr$CPlaceable + 1))(v8);
          deletingEscalator = 0;
          pSteps[v6] = 0;
          NumNormalStepsNeeded = this->NumNormalStepsNeeded;
          NumBiggerStepsNeeded1 = this->NumBiggerStepsNeeded1;
          NumBiggerStepsNeeded2 = this->NumBiggerStepsNeeded2;
        }
        ++v6;
      }
      while ( v6 < NumBiggerStepsNeeded1 + NumNormalStepsNeeded + NumBiggerStepsNeeded2 );
    }
    this->bActive = 0;
  }
}

//----- (005A6F6C) --------------------------------------------------------
void __fastcall CEntity::RemoveEscalatorsForEntity(CEntity *this)
{
  CEntity *v1; // r1
  int v2; // r8
  CObject **pSteps; // r5
  CEscalator *v4; // r9
  bool *p_bUsed; // r9
  _BOOL4 bUsed; // t1
  CEscalator *v7; // r4
  bool *p_bActive; // r4
  _BOOL4 bActive; // t1
  CEscalator *v10; // r4
  Int32 v11; // r1
  Int32 *p_NumNormalStepsNeeded; // r4
  Int32 NumNormalStepsNeeded; // t1
  Int32 v14; // r2
  Int32 v15; // r3
  int v16; // r10
  CEntity *v17; // r0
  CObject *v18; // r0
  bool *v20; // [sp+18h] [bp-28h]

  v1 = this;
  v2 = 0;
  pSteps = CEscalators::aArray[0].pSteps;
  do
  {
    v4 = &CEscalators::aArray[v2];
    bUsed = v4->bUsed;
    p_bUsed = &v4->bUsed;
    if ( bUsed && CEscalators::aArray[v2].pOwnerEntity == v1 )
    {
      v7 = &CEscalators::aArray[v2];
      bActive = v7->bActive;
      p_bActive = &v7->bActive;
      if ( bActive )
      {
        v20 = p_bActive;
        v10 = &CEscalators::aArray[v2];
        NumNormalStepsNeeded = v10->NumNormalStepsNeeded;
        p_NumNormalStepsNeeded = &v10->NumNormalStepsNeeded;
        v11 = NumNormalStepsNeeded;
        v14 = p_NumNormalStepsNeeded[1];
        v15 = p_NumNormalStepsNeeded[2];
        if ( v14 + NumNormalStepsNeeded + v15 >= 1 )
        {
          v16 = 0;
          do
          {
            v17 = pSteps[v16];
            if ( v17 )
            {
              CWorld::Remove(v17);
              deletingEscalator = 1;
              v18 = pSteps[v16];
              if ( v18 )
                (*((void (__fastcall **)(CObject *))v18->_vptr$CPlaceable + 1))(v18);
              pSteps[v16] = 0;
              deletingEscalator = 0;
              v15 = p_NumNormalStepsNeeded[2];
              v14 = p_NumNormalStepsNeeded[1];
              v11 = *p_NumNormalStepsNeeded;
            }
            ++v16;
          }
          while ( v16 < v14 + v15 + v11 );
        }
        v1 = this;
        *v20 = 0;
      }
      *p_bUsed = 0;
    }
    ++v2;
    pSteps += 84;
  }
  while ( v2 != 32 );
}

//----- (005A7090) --------------------------------------------------------
void __fastcall CEscalator::Update(CEscalator *this)
{
  __int128 v1; // q9
  CSimpleTransform *p_tx; // r2
  float32x2_t v4; // d16
  unsigned __int64 v5; // d1
  int32 m_nSize; // r0
  int v7; // r6
  int8x16_t v8; // q8
  unsigned int v9; // r2
  int64x2_t v10; // q10
  uint8 *m_aFlags; // r1
  int v12; // t1
  int32x4_t v13; // q8
  unsigned __int32 v14; // r3
  uint8 *v15; // r1
  int v16; // r2
  unsigned int v17; // t1
  Int32 NumBiggerStepsNeeded1; // r1
  Int32 NumNormalStepsNeeded; // r6
  Int32 NumBiggerStepsNeeded2; // r2
  CObject **pSteps; // r10
  Int32 v22; // r6
  CObject *v23; // r0
  int v24; // r0
  __int64 v25; // kr08_8
  int v26; // r5
  RwReal z; // r1
  RwReal *v28; // r0
  int v29; // r5
  CObject *v30; // r0
  CObject **v31; // r6
  int v32; // r0
  int v33; // r1
  __int64 v34; // kr18_8
  int v35; // r0
  RwReal v36; // r12
  RwReal *v37; // r1
  float v38; // s0
  float StepShift; // s2
  float v40; // s2
  float v41; // s0
  Int32 v42; // r6
  CObject **v43; // r10
  int i; // r5
  RwReal v45; // s0
  RwReal v46; // s4
  float x; // s30
  float y; // s17
  float v49; // s26
  float v50; // s28
  float v51; // s24
  float v52; // s22
  CObject *v53; // r0
  float v54; // s19
  float v55; // s21
  float v56; // s23
  float v57; // s25
  float v58; // s0
  float *v59; // r0
  CObject *v60; // r2
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *m_pMat; // r0
  RwMatrix *v64; // r1
  Int32 v65; // r5
  int v66; // r11
  int j; // r10
  RwReal v68; // s0
  RwReal v69; // s4
  float v70; // s28
  float v71; // s30
  float v72; // s24
  float v73; // s26
  float v74; // s22
  float v75; // s20
  char *v76; // r5
  int v77; // r0
  CEntity **v78; // r5
  int v79; // t1
  float v80; // s17
  float v81; // s19
  float v82; // s21
  float v83; // s23
  float v84; // s0
  float *v85; // r0
  CEntity *v86; // r2
  RwObject_0 *v87; // r0
  char *v88; // r1
  const CMatrix *v89; // r0
  RwMatrix *v90; // r1
  Int32 v91; // r1
  int v92; // r11
  int k; // r10
  RwReal v94; // s0
  Int32 v95; // r6
  RwReal v96; // s4
  float v97; // s28
  float v98; // s30
  float v99; // s24
  float v100; // s26
  float v101; // s22
  float v102; // s20
  char *v103; // r5
  int v104; // r0
  CEntity **v105; // r5
  int v106; // t1
  float v107; // s17
  float v108; // s19
  float v109; // s21
  float v110; // s23
  float v111; // s0
  float *v112; // r0
  CEntity *v113; // r2
  RwObject_0 *v114; // r0
  char *v115; // r1
  const CMatrix *v116; // r0
  RwMatrix *v117; // r1
  CSimpleTransform *p_m_transform; // r3
  float32x2_t v119; // d16
  unsigned __int64 v120; // d1
  __int64 v121; // r2
  CObject **v122; // r5
  int v123; // r6
  CEntity *v124; // r0
  CObject *v125; // r0
  CVector v126; // [sp+4h] [bp-6Ch] BYREF

  if ( !this->bActive )
  {
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v4.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&this->SpriteCenter.y).n64_u64[0];
    v5 = vmul_f32(v4, v4).n64_u64[0];
    if ( sqrtf(
           (float)((float)((float)(p_tx->m_translate.x - this->SpriteCenter.x)
                         * (float)(p_tx->m_translate.x - this->SpriteCenter.x))
                 + *(float *)&v5)
         + *((float *)&v5 + 1)) >= (float)(this->SpriteSize + 20.0) )
    {
LABEL_35:
      if ( !this->bActive )
        return;
      goto LABEL_36;
    }
    m_nSize = CPools::ms_pObjectPool->m_nSize;
    if ( m_nSize < 1 )
    {
      v14 = 0;
      goto LABEL_17;
    }
    if ( (unsigned int)m_nSize >= 4 && (v7 = m_nSize & 0x7FFFFFFC, (m_nSize & 0xFFFFFFFC) != 0) )
    {
      v8 = 0uLL;
      LODWORD(v1) = 65537;
      WORD2(v1) = 1;
      WORD3(v1) = 1;
      v9 = m_nSize & 0xFFFFFFFC;
      v10.n128_u64[0] = 0xFF000000FFLL;
      v10.n128_u64[1] = 0xFF000000FFLL;
      m_aFlags = CPools::ms_pObjectPool->m_aFlags;
      do
      {
        v12 = *(_DWORD *)m_aFlags;
        m_aFlags += 4;
        v9 -= 4;
        DWORD2(v1) = v12;
        *((_QWORD *)&v1 + 1) = v1 ^ vshr_n_u16((uint16x4_t)vmovl_u8(*((uint8x8_t *)&v1 + 1)).n128_u64[0], 7u).n64_u64[0];
        v8 = vaddq_s32(v8, vandq_s64(vmovl_u16(*((uint16x4_t *)&v1 + 1)), v10));
      }
      while ( v9 );
      v13 = vaddq_s32(v8, vextq_s8(v8, v8, 8u));
      v14 = vaddq_s32(v13, vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 1)).n128_u32[0];
      if ( m_nSize == v7 )
      {
LABEL_17:
        NumBiggerStepsNeeded1 = this->NumBiggerStepsNeeded1;
        NumNormalStepsNeeded = this->NumNormalStepsNeeded;
        NumBiggerStepsNeeded2 = this->NumBiggerStepsNeeded2;
        if ( (int)(m_nSize - v14) > NumNormalStepsNeeded + NumBiggerStepsNeeded1 + NumBiggerStepsNeeded2 + 10 )
        {
          this->StepShift = 0.0;
          this->bActive = 1;
          if ( NumNormalStepsNeeded >= 1 )
          {
            pSteps = this->pSteps;
            v22 = 0;
            do
            {
              v23 = (CObject *)CObject::operator new(0x184u);
              CObject::CObject(v23, MI_ESCALATORSTEP, 1);
              pSteps[v22] = (CObject *)v24;
              if ( v24 )
              {
                v25 = *(_QWORD *)&this->Point2.x;
                v26 = *(_DWORD *)(v24 + 20);
                z = this->Point2.z;
                if ( v26 )
                {
                  *(_DWORD *)(v26 + 48) = v25;
                  *(_DWORD *)(*(_DWORD *)(v24 + 20) + 52) = HIDWORD(v25);
                  v28 = (RwReal *)(*(_DWORD *)(v24 + 20) + 56);
                }
                else
                {
                  *(_QWORD *)(v24 + 4) = v25;
                  v28 = (RwReal *)(v24 + 12);
                }
                *v28 = z;
                CWorld::Add(pSteps[v22]);
                pSteps[v22]->ObjectCreatedBy = 5;
              }
              ++v22;
            }
            while ( v22 < this->NumNormalStepsNeeded );
            NumBiggerStepsNeeded2 = this->NumBiggerStepsNeeded2;
            NumBiggerStepsNeeded1 = this->NumBiggerStepsNeeded1;
          }
          if ( NumBiggerStepsNeeded2 + NumBiggerStepsNeeded1 >= 1 )
          {
            v29 = 0;
            do
            {
              v30 = (CObject *)CObject::operator new(0x184u);
              CObject::CObject(v30, MI_ESCALATORSTEP8, 1);
              v31 = this->pSteps;
              *((_DWORD *)&this->pSteps[this->NumNormalStepsNeeded] + v29) = v32;
              v33 = *((_DWORD *)&this->pSteps[this->NumNormalStepsNeeded] + v29);
              if ( v33 )
              {
                v34 = *(_QWORD *)&this->Point2.x;
                v35 = *(_DWORD *)(v33 + 20);
                v36 = this->Point2.z;
                if ( v35 )
                {
                  *(_DWORD *)(v35 + 48) = v34;
                  *(_DWORD *)(*(_DWORD *)(v33 + 20) + 52) = HIDWORD(v34);
                  v37 = (RwReal *)(*(_DWORD *)(v33 + 20) + 56);
                }
                else
                {
                  *(_QWORD *)(v33 + 4) = v34;
                  v37 = (RwReal *)(v33 + 12);
                }
                *v37 = v36;
                CWorld::Add(*(&v31[this->NumNormalStepsNeeded] + v29));
                (*(&v31[this->NumNormalStepsNeeded] + v29))->ObjectCreatedBy = 5;
              }
              ++v29;
            }
            while ( v29 < this->NumBiggerStepsNeeded1 + this->NumBiggerStepsNeeded2 );
          }
        }
        goto LABEL_35;
      }
    }
    else
    {
      v7 = 0;
      v14 = 0;
    }
    v15 = &CPools::ms_pObjectPool->m_aFlags[v7];
    v16 = m_nSize - v7;
    do
    {
      v17 = *v15++;
      --v16;
      v14 += (v17 >> 7) ^ 1;
    }
    while ( v16 );
    goto LABEL_17;
  }
LABEL_36:
  v38 = CTimer::ms_fTimeStep * 0.04;
  StepShift = this->StepShift;
  if ( this->bGoingDown )
  {
    v40 = StepShift - v38;
    this->StepShift = v40;
    v41 = v40 + 1.0;
  }
  else
  {
    v41 = v38 + StepShift;
  }
  v42 = this->NumNormalStepsNeeded;
  this->StepShift = v41 - (float)(int)v41;
  if ( v42 >= 1 )
  {
    v43 = this->pSteps;
    for ( i = 0; i < v42; ++i )
    {
      v45 = this->Point3.x - this->Point2.x;
      v46 = this->Point3.z - this->Point2.z;
      v126.y = this->Point3.y - this->Point2.y;
      v126.x = v45;
      v126.z = v46;
      CVector::Normalise(&v126);
      x = v126.x;
      y = v126.y;
      v49 = v126.x * 0.016;
      v50 = v126.z;
      v51 = v126.y * 0.016;
      v52 = v126.z * 0.016;
      if ( this->bGoingDown )
      {
        v52 = -v52;
        v51 = -v51;
        v49 = -v49;
      }
      v53 = v43[i];
      if ( v53 )
      {
        v54 = this->Point3.x;
        v55 = this->Point3.y;
        v56 = this->Point3.z;
        v57 = this->StepShift;
        CMatrix::operator=(v53->m_pMat, &this->StepMatrix);
        v58 = (float)((float)((float)i - v57) + 1.0) * 0.4;
        v43[i]->m_pMat->tx = v54 - (float)(x * v58);
        v43[i]->m_pMat->ty = v55 - (float)(y * v58);
        v43[i]->m_pMat->tz = v56 - (float)(v50 * v58);
        v59 = (float *)v43[i];
        v59[18] = v49;
        v59[19] = v51;
        v59[20] = v52;
        v60 = v43[i];
        m_pRwObject = v60->m_pRwObject;
        if ( m_pRwObject )
        {
          parent = (char *)m_pRwObject->parent;
          m_pMat = v60->m_pMat;
          v64 = (RwMatrix *)(parent + 16);
          if ( m_pMat )
            CMatrix::UpdateRwMatrix(m_pMat, v64);
          else
            CSimpleTransform::UpdateRwMatrix(&v60->m_transform, v64);
        }
        CEntity::UpdateRwFrame(v43[i]);
        CPhysical::RemoveAndAdd(v43[i]);
      }
      v42 = this->NumNormalStepsNeeded;
    }
  }
  v65 = this->NumBiggerStepsNeeded1;
  if ( v65 >= 1 )
  {
    v66 = 1;
    for ( j = 4; ; j += 8 )
    {
      v68 = this->Point2.x - this->Point1.x;
      v69 = this->Point2.z - this->Point1.z;
      v126.y = this->Point2.y - this->Point1.y;
      v126.x = v68;
      v126.z = v69;
      CVector::Normalise(&v126);
      v70 = v126.x;
      v71 = v126.y;
      v72 = v126.x * 0.016;
      v73 = v126.z;
      v74 = v126.y * 0.016;
      v75 = v126.z * 0.016;
      v76 = (char *)this + 4 * v42 + 4 * v66 - 4;
      if ( this->bGoingDown )
      {
        v75 = -v75;
        v74 = -v74;
        v72 = -v72;
      }
      v79 = *((_DWORD *)v76 + 42);
      v78 = (CEntity **)(v76 + 168);
      v77 = v79;
      if ( v79 )
      {
        v80 = this->Point1.x;
        v81 = this->Point1.y;
        v82 = this->Point1.z;
        v83 = this->StepShift;
        CMatrix::operator=(*(CMatrix **)(v77 + 20), &this->StepMatrix);
        v84 = (float)((float)j * 0.4) + (float)(v83 * 0.4);
        (*v78)->m_pMat->tx = (float)(v70 * v84) + v80;
        (*v78)->m_pMat->ty = (float)(v71 * v84) + v81;
        (*v78)->m_pMat->tz = (float)(v84 * v73) + v82;
        v85 = (float *)*v78;
        v85[18] = v72;
        v85[19] = v74;
        v85[20] = v75;
        v86 = *v78;
        v87 = (*v78)->m_pRwObject;
        if ( v87 )
        {
          v88 = (char *)v87->parent;
          v89 = v86->m_pMat;
          v90 = (RwMatrix *)(v88 + 16);
          if ( v89 )
            CMatrix::UpdateRwMatrix(v89, v90);
          else
            CSimpleTransform::UpdateRwMatrix(&v86->m_transform, v90);
        }
        CEntity::UpdateRwFrame(*v78);
        CPhysical::RemoveAndAdd((CPhysical *)*v78);
      }
      v65 = this->NumBiggerStepsNeeded1;
      if ( v66 >= v65 )
        break;
      v42 = this->NumNormalStepsNeeded;
      ++v66;
    }
  }
  v91 = this->NumBiggerStepsNeeded2;
  if ( v91 >= 1 )
  {
    v92 = 1;
    for ( k = 4; ; k += 8 )
    {
      v94 = this->Point4.x - this->Point3.x;
      v95 = this->NumNormalStepsNeeded;
      v96 = this->Point4.z - this->Point3.z;
      v126.y = this->Point4.y - this->Point3.y;
      v126.x = v94;
      v126.z = v96;
      CVector::Normalise(&v126);
      v97 = v126.x;
      v98 = v126.y;
      v99 = v126.x * 0.016;
      v100 = v126.z;
      v101 = v126.y * 0.016;
      v102 = v126.z * 0.016;
      v103 = (char *)this + 4 * v65 + 4 * v95 + 4 * v92 - 4;
      if ( this->bGoingDown )
      {
        v102 = -v102;
        v101 = -v101;
        v99 = -v99;
      }
      v106 = *((_DWORD *)v103 + 42);
      v105 = (CEntity **)(v103 + 168);
      v104 = v106;
      if ( v106 )
      {
        v107 = this->Point3.x;
        v108 = this->Point3.y;
        v109 = this->Point3.z;
        v110 = this->StepShift;
        CMatrix::operator=(*(CMatrix **)(v104 + 20), &this->StepMatrix);
        v111 = (float)((float)k * 0.4) + (float)(v110 * 0.4);
        (*v105)->m_pMat->tx = (float)(v97 * v111) + v107;
        (*v105)->m_pMat->ty = (float)(v98 * v111) + v108;
        (*v105)->m_pMat->tz = (float)(v111 * v100) + v109;
        v112 = (float *)*v105;
        v112[18] = v99;
        v112[19] = v101;
        v112[20] = v102;
        v113 = *v105;
        v114 = (*v105)->m_pRwObject;
        if ( v114 )
        {
          v115 = (char *)v114->parent;
          v116 = v113->m_pMat;
          v117 = (RwMatrix *)(v115 + 16);
          if ( v116 )
            CMatrix::UpdateRwMatrix(v116, v117);
          else
            CSimpleTransform::UpdateRwMatrix(&v113->m_transform, v117);
        }
        CEntity::UpdateRwFrame(*v105);
        CPhysical::RemoveAndAdd((CPhysical *)*v105);
      }
      v91 = this->NumBiggerStepsNeeded2;
      if ( v92 >= v91 )
        break;
      v65 = this->NumBiggerStepsNeeded1;
      ++v92;
    }
  }
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  v119.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&this->SpriteCenter.y).n64_u64[0];
  v120 = vmul_f32(v119, v119).n64_u64[0];
  if ( sqrtf(
         (float)((float)((float)(p_m_transform->m_translate.x - this->SpriteCenter.x)
                       * (float)(p_m_transform->m_translate.x - this->SpriteCenter.x))
               + *(float *)&v120)
       + *((float *)&v120 + 1)) > (float)(this->SpriteSize + 23.0)
    && this->bActive )
  {
    v121 = *(_QWORD *)&this->NumNormalStepsNeeded;
    if ( (int)v121 + v91 + HIDWORD(v121) >= 1 )
    {
      v122 = this->pSteps;
      v123 = 0;
      do
      {
        v124 = v122[v123];
        if ( v124 )
        {
          CWorld::Remove(v124);
          deletingEscalator = 1;
          v125 = v122[v123];
          if ( v125 )
            (*((void (__fastcall **)(CObject *))v125->_vptr$CPlaceable + 1))(v125);
          deletingEscalator = 0;
          v122[v123] = 0;
          v121 = *(_QWORD *)&this->NumNormalStepsNeeded;
          v91 = this->NumBiggerStepsNeeded2;
        }
        ++v123;
      }
      while ( v123 < HIDWORD(v121) + v91 + (int)v121 );
    }
    this->bActive = 0;
  }
}
// 5A711C: mask 0xFFFFFFFC is shortened because r0.4 <= 0x7FFFFFFF
// 5A7140: variable 'v1' is possibly undefined
// 5A71E2: variable 'v24' is possibly undefined
// 5A7252: variable 'v32' is possibly undefined

//----- (005A77AC) --------------------------------------------------------
void __fastcall CEscalators::AddOne(
        const CVector *Point1,
        const CVector *Point2,
        const CVector *Point3,
        const CVector *Point4,
        bool a5,
        CEntity *a6)
{
  int v9; // r5
  CEscalator *i; // r0

  v9 = -1;
  for ( i = CEscalators::aArray; i->bUsed; ++i )
  {
    if ( ++v9 >= 31 )
      return;
  }
  CEscalator::AddThisOne(i, Point1, Point2, Point3, Point4, a5, a6);
}

//----- (005A77F4) --------------------------------------------------------
void __fastcall CEscalator::AddThisOne(
        CEscalator *this,
        const CVector *ArgPoint1,
        const CVector *ArgPoint2,
        const CVector *ArgPoint3,
        const CVector *ArgPoint4,
        bool ArgGoingDown,
        CEntity *pOwner)
{
  __int64 v8; // d16
  __int64 v9; // d16
  __int64 v10; // d16
  __int64 v11; // d16
  float z; // s2
  RwReal v13; // s0
  RwReal v14; // s4
  RwReal v15; // s6
  float y; // s8
  RwReal v17; // s2
  float v18; // s3
  float v19; // s1
  float x; // s14
  float v21; // s5
  Int32 v22; // r3
  float v23; // s2
  float v24; // s6
  RwReal v25; // s0
  float v26; // s0
  float v27; // s2
  float v28; // s6
  float v29; // s4
  float v30; // s8
  float v31; // s10
  RwReal v32; // r1
  RwReal v33; // s6
  float v34; // r2
  RwReal v35; // s8
  RwReal v36; // s10
  CVector v37; // [sp+4h] [bp-14h] BYREF

  this->bUsed = 1;
  v8 = *(_QWORD *)&ArgPoint1->x;
  this->Point1.z = ArgPoint1->z;
  *(_QWORD *)&this->Point1.x = v8;
  v9 = *(_QWORD *)&ArgPoint2->x;
  this->Point2.z = ArgPoint2->z;
  *(_QWORD *)&this->Point2.x = v9;
  v10 = *(_QWORD *)&ArgPoint3->x;
  this->Point3.z = ArgPoint3->z;
  *(_QWORD *)&this->Point3.x = v10;
  v11 = *(_QWORD *)&ArgPoint4->x;
  this->Point4.z = ArgPoint4->z;
  *(_QWORD *)&this->Point4.x = v11;
  z = CModelInfo::ms_modelInfoPtrs[MI_ESCALATORSTEP]->m_pColModel->m_boxBound.m_vecMax.z;
  v13 = this->Point1.z - z;
  this->Point1.z = v13;
  v14 = this->Point2.z - z;
  this->Point2.z = v14;
  v15 = this->Point3.z - z;
  this->Point3.z = v15;
  y = this->Point4.y;
  v17 = this->Point4.z - z;
  this->Point4.z = v17;
  v18 = this->Point3.y;
  v19 = this->Point2.y;
  x = this->Point2.x;
  v21 = this->Point3.x;
  v22 = (int)(float)(sqrtf(
                       (float)((float)((float)(v21 - this->Point4.x) * (float)(v21 - this->Point4.x))
                             + (float)((float)(v18 - y) * (float)(v18 - y)))
                     + (float)((float)(v15 - v17) * (float)(v15 - v17)))
                   / 3.2)
      + 1;
  this->NumBiggerStepsNeeded1 = (int)(float)(sqrtf(
                                               (float)((float)((float)(this->Point1.x - x) * (float)(this->Point1.x - x))
                                                     + (float)((float)(this->Point1.y - v19)
                                                             * (float)(this->Point1.y - v19)))
                                             + (float)((float)(v13 - v14) * (float)(v13 - v14)))
                                           / 3.2)
                              + 1;
  this->NumBiggerStepsNeeded2 = v22;
  this->NumNormalStepsNeeded = (int)(float)((float)(sqrtf(
                                                      (float)((float)((float)(x - v21) * (float)(x - v21))
                                                            + (float)((float)(v19 - v18) * (float)(v19 - v18)))
                                                    + (float)((float)(v14 - v15) * (float)(v14 - v15)))
                                                  / 0.4)
                                          + 1.0);
  v23 = ArgPoint2->y;
  v24 = ArgPoint1->y;
  v25 = ArgPoint1->x - ArgPoint2->x;
  v37.z = 0.0;
  v37.y = v24 - v23;
  v37.x = v25;
  CVector::Normalise(&v37);
  v26 = this->Point1.x;
  v27 = this->Point1.y;
  v28 = this->Point1.x + this->Point4.x;
  v29 = this->Point1.z;
  v30 = v27 + this->Point4.y;
  v31 = this->Point4.z;
  this->StepMatrix.xz = 0.0;
  this->StepMatrix.yz = 0.0;
  this->StepMatrix.zz = 1.0;
  v32 = v37.x;
  this->StepMatrix.xy = v37.x;
  v33 = v28 * 0.5;
  v34 = v37.y;
  v35 = v30 * 0.5;
  this->StepMatrix.yy = v37.y;
  this->StepMatrix.zy = 0.0;
  this->StepMatrix.xx = v34;
  LODWORD(this->StepMatrix.yx) = LODWORD(v32) ^ 0x80000000;
  v36 = (float)(v29 + v31) * 0.5;
  this->StepMatrix.zx = 0.0;
  this->StepMatrix.tx = 0.0;
  this->StepMatrix.ty = 0.0;
  this->StepMatrix.tz = 0.0;
  this->bGoingDown = ArgGoingDown;
  this->SpriteCenter.x = v33;
  this->SpriteCenter.y = v35;
  this->SpriteCenter.z = v36;
  this->pOwnerEntity = pOwner;
  this->SpriteSize = sqrtf(
                       (float)((float)((float)(v26 - v33) * (float)(v26 - v33))
                             + (float)((float)(v27 - v35) * (float)(v27 - v35)))
                     + (float)((float)(v29 - v36) * (float)(v29 - v36)));
  CEntity::RegisterReference(pOwner, &this->pOwnerEntity);
}

//----- (005A7A30) --------------------------------------------------------
int __fastcall GetJIndex(uint16 C)
{
  int v2; // r2
  int v3; // r1
  uint16 *p_unicode; // r3
  int v5; // r2

  if ( (CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage) << 24 )
  {
    if ( (unsigned __int16)(C + 32588) > 2u )
    {
      if ( (C & 0x8000) != 0 )
      {
        return C & 0x7FFF;
      }
      else
      {
        v3 = 32;
        if ( jCount + 32 > C )
          return C - 32;
        return v3;
      }
    }
    else
    {
      return C + jCount - 32951;
    }
  }
  else if ( CFont::UsingRussianLanguage )
  {
    v2 = 32;
    if ( jCount + 32 > C )
      return C - 32;
    return v2;
  }
  else if ( jCount < 1 )
  {
    return 31;
  }
  else
  {
    p_unicode = &JMet[0].unicode;
    v5 = 0;
    while ( *p_unicode != C )
    {
      ++v5;
      p_unicode += 24;
      if ( v5 >= jCount )
        return 31;
    }
    return v5;
  }
}

//----- (005A7B00) --------------------------------------------------------
bool __fastcall containsNonAscii(GxtChar *pCharacters, int length)
{
  bool result; // r0
  int v3; // r2
  GxtChar *v4; // r12
  int v5; // r3

  if ( CFont::UsingJapaneseLanguage )
    return 1;
  if ( (CFont::UsingRussianLanguage | CFont::UsingKoreanLanguage) << 24 )
    return 0;
  LOWORD(v3) = *pCharacters;
  if ( !*pCharacters )
    return 0;
  v4 = pCharacters + 1;
  v5 = 0;
  if ( length != -1 )
    goto LABEL_10;
  while ( (unsigned __int16)v3 <= 0x7Fu )
  {
    v3 = v4[v5];
    result = 0;
    ++v5;
    if ( !v3 )
      return result;
    if ( length != -1 )
    {
LABEL_10:
      if ( v5 >= length )
        return 0;
    }
  }
  return 1;
}

//----- (005A7B64) --------------------------------------------------------
bool __fastcall isJapanesePunctuation(GxtChar c)
{
  int v2; // r2

  if ( numOfPunctIndexes < 1 )
    return 0;
  v2 = 0;
  do
  {
    if ( JPNIndexPunct[v2] == c )
      return 1;
    ++v2;
  }
  while ( v2 < numOfPunctIndexes );
  return 0;
}

//----- (005A7BA0) --------------------------------------------------------
bool __fastcall IsPunctuation(GxtChar chr)
{
  int v2; // r2
  bool result; // r0
  int v4; // r3
  int v5; // r1

  v2 = chr - 33;
  result = 1;
  switch ( v2 )
  {
    case 0:
    case 3:
    case 11:
    case 13:
    case 14:
    case 25:
    case 30:
    case 59:
      return result;
    default:
      if ( CFont::UsingJapaneseLanguage && numOfPunctIndexes >= 1 )
      {
        v4 = 0;
        v5 = (unsigned __int16)(chr - 32);
        while ( JPNIndexPunct[v4] != v5 )
        {
          ++v4;
          result = 0;
          if ( v4 >= numOfPunctIndexes )
            return result;
        }
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
  }
  return result;
}

//----- (005A7C40) --------------------------------------------------------
float __fastcall GetJapaneseWidth(GxtChar Character, bool UseFullSpacePuntuation)
{
  int v2; // r3
  uint16 *p_unicode; // r4
  float width; // s0
  float v6; // s4
  float v7; // s2
  int v8; // r4

  if ( (CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage) << 24 )
  {
    if ( (unsigned __int16)(Character + 32588) <= 2u )
    {
      v2 = jCount + Character - 32951;
      goto LABEL_17;
    }
    if ( (Character & 0x8000) != 0 )
    {
      v2 = Character & 0x7FFF;
      goto LABEL_16;
    }
    goto LABEL_7;
  }
  if ( CFont::UsingRussianLanguage )
  {
LABEL_7:
    v2 = 32;
    if ( jCount + 32 > Character )
      v2 = Character - 32;
    goto LABEL_16;
  }
  if ( jCount < 1 )
  {
LABEL_15:
    v2 = 31;
  }
  else
  {
    p_unicode = &JMet[0].unicode;
    v2 = 0;
    while ( *p_unicode != Character )
    {
      ++v2;
      p_unicode += 24;
      if ( v2 >= jCount )
        goto LABEL_15;
    }
  }
LABEL_16:
  if ( Character == 32 )
    return 15.0;
LABEL_17:
  if ( Character - 32 == FullWidthSpaceChar )
    return 15.0;
  if ( UseFullSpacePuntuation )
  {
    width = 20.0;
    switch ( Character )
    {
      case '!':
      case ',':
      case '/':
      case '?':
      case '\\':
        return width;
      case '$':
      case '.':
      case ':':
        goto LABEL_21;
      default:
        if ( !CFont::UsingJapaneseLanguage || numOfPunctIndexes < 1 )
          goto LABEL_21;
        v8 = 0;
        break;
    }
    while ( JPNIndexPunct[v8] != (unsigned __int16)(Character - 32) )
    {
      if ( ++v8 >= numOfPunctIndexes )
        goto LABEL_21;
    }
  }
  else
  {
LABEL_21:
    width = (float)JMet[v2].width;
    v6 = width;
    if ( printingCredits )
      v6 = width * 1.5;
    v7 = (float)JMet[v2].width;
    if ( CFont::UsingRussianLanguage )
      v7 = v6;
    if ( Character < 0x80u )
      return v7;
  }
  return width;
}

//----- (005A7E08) --------------------------------------------------------
void __fastcall ReadMetFile(unsigned __int8 *filename, int textureSize)
{
  u_native v3; // r6
  int v4; // r10
  float v5; // s16
  int v6; // r9
  bool v7; // r0
  unsigned __int16 v8; // r0
  jChar_st *v9; // r1
  int v10; // r2
  float v11; // s2
  float v12; // s0
  float v13; // s4
  float v14; // s6
  float v15; // s2
  float v16; // s4
  float v17; // s6
  bool v18; // zf
  bool v19; // zf
  bool v20; // zf
  bool v21; // zf
  int v22; // r2
  bool v23; // cc
  int v24; // r0
  unsigned __int16 v25; // [sp+20h] [bp-108h] BYREF
  int v26; // [sp+24h] [bp-104h] BYREF
  int v27; // [sp+28h] [bp-100h] BYREF
  int v28; // [sp+2Ch] [bp-FCh] BYREF
  int v29; // [sp+30h] [bp-F8h] BYREF
  unsigned __int8 pLine[200]; // [sp+34h] [bp-F4h] BYREF

  v3 = CFileMgr::OpenFile(filename, (const unsigned __int8 *)&dword_5A8070);
  v4 = 0;
  v5 = (float)textureSize;
  v6 = 0;
  ForiegnCharFontStart = 0;
  numOfPunctIndexes = 0;
  FullWidthSpaceChar = 0;
  while ( CFileMgr::ReadLine(v3, pLine, 200) )
  {
    if ( v4 << 31 )
    {
      if ( strlen((const char *)pLine) < 0xA )
        break;
      sscanf((const char *)pLine, "%d %d %d %d %d", &v25, &v29, &v27, &v28, &v26);
      v8 = v25;
      v9 = &JMet[v6];
      v10 = v29;
      v9->unicode = v25;
      v11 = (float)v28;
      v9->width = v28 - v10;
      v12 = (float)v10 / v5;
      v13 = (float)v27;
      v14 = (float)v26;
      v9->height = v26 - v27;
      v15 = v11 / v5;
      v16 = v13 / v5;
      v17 = v14 / v5;
      v9->tu1 = v12;
      v9->tv1 = v16;
      v9->tu2 = v15;
      v9->tv2 = v16;
      v9->tu3 = v12;
      v9->tv3 = v17;
      v9->tu4 = v15;
      v9->tv4 = v17;
      if ( CFont::UsingJapaneseLanguage )
      {
        v18 = JPNUnicodePunct[0] == v8;
        if ( JPNUnicodePunct[0] != v8 )
          v18 = JPNUnicodePunct[1] == v8;
        if ( v18 )
          goto LABEL_19;
        v19 = JPNUnicodePunct[2] == v8;
        if ( JPNUnicodePunct[2] != v8 )
          v19 = JPNUnicodePunct[3] == v8;
        if ( v19 )
          goto LABEL_19;
        v20 = JPNUnicodePunct[4] == v8;
        if ( JPNUnicodePunct[4] != v8 )
          v20 = JPNUnicodePunct[5] == v8;
        if ( v20 )
          goto LABEL_19;
        v21 = JPNUnicodePunct[6] == v8;
        if ( JPNUnicodePunct[6] != v8 )
          v21 = JPNUnicodePunct[7] == v8;
        if ( v21 || JPNUnicodePunct[8] == v8 )
        {
LABEL_19:
          v22 = numOfPunctIndexes++;
          JPNIndexPunct[v22] = v6;
        }
        if ( v8 == 12288 )
          FullWidthSpaceChar = v6;
      }
      if ( ForiegnCharFontStart <= 0 && v8 >= 0x80u )
        ForiegnCharFontStart = v6;
      v23 = v6 <= 1798;
      v24 = 0;
      ++v6;
      if ( !v23 )
        v24 = 3;
      if ( v24 )
        break;
    }
    else
    {
      v4 = 0;
      if ( strncmp((const char *)pLine, "METRICS1", 8u) )
      {
        v4 = 0;
        if ( strncmp((const char *)pLine, "JapaneseFont", 0xCu) )
        {
          v7 = strncmp((const char *)pLine, "RussianFont", 0xBu) != 0;
          v4 = v7 && pLine[0] == 53;
        }
      }
    }
  }
  jCount = v6;
  CFileMgr::CloseFile(v3);
}
// 0: using guessed type int dword_0;
// 5A8070: using guessed type int dword_5A8070;

//----- (005A80E0) --------------------------------------------------------
void CFont::ClearSpecialLanguages()
{
  CFont::UsingRussianLanguage = 0;
  CFont::UsingJapaneseLanguage = 0;
  CFont::UsingKoreanLanguage = 0;
  CFont::UsingEFIGSLanguage = 0;
}

//----- (005A8118) --------------------------------------------------------
void CFont::AddJapaneseTexture()
{
  if ( IsInitialized && !CFont::UsingJapaneseLanguage )
  {
    CFont::UsingRussianLanguage = 0;
    CFont::UsingJapaneseLanguage = 0;
    CFont::UsingKoreanLanguage = 0;
    CFont::UsingEFIGSLanguage = 0;
    CFont::AddStandardTexture();
    CFont::UsingJapaneseLanguage = 1;
    CSprite2d::SetTexture(&CFont::Sprite[2], "Textures\\Fonts\\JapaneseFont.png");
    ReadMetFile("Textures\\Fonts\\JapaneseFont.met", 1024);
  }
}

//----- (005A81D8) --------------------------------------------------------
void CFont::AddStandardTexture()
{
  bool v0; // zf
  int32 v1; // r4

  v0 = CFont::Sprite[0].mpTexture == 0;
  if ( CFont::Sprite[0].mpTexture )
    v0 = CFont::Sprite[1].mpTexture == 0;
  if ( v0 )
  {
    v1 = CTxdStore::AddTxdSlot("fonts", (const unsigned __int8 *)&off_5A8240, 0);
    CTxdStore::LoadTxd(v1, "MODELS/FONTS.TXD");
    CTxdStore::AddRef(v1);
    CTxdStore::PushCurrentTxd();
    CTxdStore::SetCurrentTxd(v1, 0);
    CSprite2d::SetTexture(CFont::Sprite, "font2", "font2m");
    CSprite2d::SetTexture(&CFont::Sprite[1], "font1", "font1m");
    sub_1979B0();
  }
}
// 5A8240: using guessed type void *off_5A8240;

//----- (005A827C) --------------------------------------------------------
void CFont::AddEFIGSFont()
{
  if ( IsInitialized && !CFont::UsingEFIGSLanguage )
  {
    CFont::UsingRussianLanguage = 0;
    CFont::UsingJapaneseLanguage = 0;
    CFont::UsingKoreanLanguage = 0;
    CFont::UsingEFIGSLanguage = 1;
    CFont::AddStandardTexture();
    sub_19CD8C(&CFont::Sprite[2]);
  }
}

//----- (005A82F4) --------------------------------------------------------
void CFont::AddRussianTexture()
{
  if ( IsInitialized && !CFont::UsingRussianLanguage )
  {
    CFont::UsingRussianLanguage = 0;
    CFont::UsingJapaneseLanguage = 0;
    CFont::UsingKoreanLanguage = 0;
    CFont::UsingEFIGSLanguage = 0;
    CFont::AddStandardTexture();
    ReadMetFile("Textures\\Fonts\\RussianFont.met", 512);
    CSprite2d::SetTexture(&CFont::Sprite[2], "Textures\\Fonts\\RussianFont.png");
  }
  CFont::UsingRussianLanguage = 1;
}

//----- (005A83C0) --------------------------------------------------------
void __fastcall AsciiToGxtChar(const Char *aStr, GxtChar *pOutput)
{
  Char v2; // r2
  const Char *v3; // r0
  int v4; // t1

  if ( aStr )
  {
    v2 = *aStr;
    if ( *aStr )
    {
      v3 = aStr + 1;
      do
      {
        *pOutput++ = v2;
        v4 = *v3++;
        v2 = v4;
      }
      while ( v4 );
    }
    *pOutput = 0;
  }
}

//----- (005A83E0) --------------------------------------------------------
GxtChar *__fastcall GxtCharStrcat(GxtChar *Base, GxtChar *Tail)
{
  GxtChar *v2; // r2
  GxtChar *v3; // r12
  GxtChar v5; // lr
  GxtChar *v6; // r12
  int v7; // r1
  GxtChar *v8; // r3

  v2 = Base;
  do
    v3 = v2;
  while ( *v2++ );
  v5 = *Tail;
  if ( *Tail )
  {
    v6 = Tail + 1;
    v7 = -1;
    do
    {
      v8 = &v6[v7];
      v2[v7++] = v5;
      v5 = v8[1];
    }
    while ( v5 );
    v3 = &v2[v7];
  }
  *v3 = 0;
  return Base;
}

//----- (005A8422) --------------------------------------------------------
GxtChar *__fastcall GxtCharStrcpy(GxtChar *Dest, const GxtChar *Src)
{
  GxtChar v2; // r2
  GxtChar *v3; // r3
  const GxtChar *v4; // r1
  int v5; // t1

  v2 = *Src;
  v3 = Dest;
  if ( *Src )
  {
    v4 = Src + 1;
    v3 = Dest;
    do
    {
      *v3++ = v2;
      v5 = *v4++;
      v2 = v5;
    }
    while ( v5 );
  }
  *v3 = 0;
  return Dest;
}

//----- (005A843E) --------------------------------------------------------
uint32 __fastcall GxtCharStrlen(const GxtChar *str)
{
  uint32 result; // r0
  const GxtChar *v2; // r1

  if ( !*str )
    return 0;
  v2 = str + 1;
  result = 0;
  while ( v2[result++] )
    ;
  return result;
}

//----- (005A8458) --------------------------------------------------------
GxtChar *__fastcall GxtCharOvrStr(GxtChar *Base, GxtChar *Tail, int place)
{
  GxtChar v3; // r12
  GxtChar *v4; // r3
  GxtChar *v5; // r1
  int v6; // t1

  v3 = *Tail;
  v4 = Base;
  if ( place > 0 )
    v4 = &Base[place];
  if ( *Tail )
  {
    v5 = Tail + 1;
    do
    {
      *v4++ = v3;
      v6 = *v5++;
      v3 = v6;
    }
    while ( v6 );
  }
  *v4 = 0;
  return Base;
}

//----- (005A8482) --------------------------------------------------------
GxtChar *__fastcall GxtCharMakeUpperCase(GxtChar *Dest, const GxtChar *Src)
{
  GxtChar v2; // r2
  GxtChar *v3; // r3
  const GxtChar *v4; // lr
  int v5; // t1

  v2 = *Src;
  v3 = Dest;
  if ( *Src )
  {
    v4 = Src + 1;
    v3 = Dest;
    do
    {
      if ( (unsigned __int16)(v2 - 97) <= 0x19u )
        v2 -= 32;
      *v3++ = v2;
      v5 = *v4++;
      v2 = v5;
    }
    while ( v5 );
  }
  *v3 = 0;
  return Dest;
}

//----- (005A84B6) --------------------------------------------------------
void __fastcall MakeUpperCase(unsigned __int8 *pString)
{
  unsigned __int8 v1; // r1
  unsigned __int8 *v2; // r0
  int v3; // t1

  v1 = *pString;
  if ( *pString )
  {
    v2 = pString + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 97) <= 0x19u )
        *(v2 - 1) = v1 - 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
}

//----- (005A84DA) --------------------------------------------------------
void __fastcall MakeLowerCase(unsigned __int8 *pString)
{
  unsigned __int8 v1; // r1
  unsigned __int8 *v2; // r0
  int v3; // t1

  v1 = *pString;
  if ( *pString )
  {
    v2 = pString + 1;
    do
    {
      if ( (unsigned __int8)(v1 - 65) <= 0x19u )
        *(v2 - 1) = v1 + 32;
      v3 = *v2++;
      v1 = v3;
    }
    while ( v3 );
  }
}

//----- (005A8500) --------------------------------------------------------
float __fastcall CFont::GetCharacterSize(GxtChar Character, bool fromRenderState)
{
  _BOOL4 v2; // r6
  __int16 Style; // r5
  GxtChar v4; // r0
  Int8 *p_EdgeAmount; // r5
  float JapaneseWidth; // s2
  float *p_ScaleX; // r0
  float v8; // s0
  float ScaleX; // s2

  v2 = fromRenderState;
  Style = CFont::Details.Style;
  if ( CFont::Details.Style == 2
    && (CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage) << 24 )
  {
    v4 = Character + 32;
    p_EdgeAmount = &CFont::Details.EdgeAmount;
    if ( fromRenderState )
      p_EdgeAmount = &CFont::RenderState.EdgeAmount;
    JapaneseWidth = GetJapaneseWidth(v4, CFont::UsingJapaneseLanguage != 0);
    p_ScaleX = &CFont::Details.ScaleX;
    if ( v2 )
      p_ScaleX = &CFont::RenderState.ScaleX;
    v8 = JapaneseWidth + (float)*p_EdgeAmount;
    ScaleX = *p_ScaleX;
  }
  else
  {
    if ( Character == 63 )
      *(_DWORD *)&Character = 0;
    if ( CFont::Details.ExtraFont )
    {
      *(_DWORD *)&Character = CFont::FindSubFontCharacter(Character, CFont::Details.ExtraFont);
    }
    else if ( Character == 145 )
    {
      *(_DWORD *)&Character = 64;
    }
    else if ( Character > 0x9Bu )
    {
      *(_DWORD *)&Character = 0;
    }
    if ( CFont::Details.Proportional )
      v8 = (float)CFont::Size[Style].x[Character] + (float)CFont::Details.EdgeAmount;
    else
      v8 = (float)CFont::Size[Style].NonProportionalWidth + (float)CFont::Details.EdgeAmount;
    ScaleX = CFont::Details.ScaleX;
  }
  return ScaleX * v8;
}

//----- (005A8658) --------------------------------------------------------
GxtChar __fastcall CFont::FindSubFontCharacter(GxtChar Character, uint8 subfont_type)
{
  GxtChar v2; // r2
  GxtChar v3; // r2

  if ( subfont_type == 1 )
  {
    if ( Character != 26 )
    {
      if ( (Character & 0xFFFFFFFE) == 8 )
      {
        Character += 86;
      }
      else
      {
        v2 = 206;
        switch ( Character )
        {
          case 1u:
            Character = 208;
            break;
          case 2u:
          case 3u:
          case 5u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
          case 0xDu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x20u:
          case 0x21u:
          case 0x22u:
          case 0x23u:
          case 0x24u:
          case 0x25u:
          case 0x26u:
          case 0x27u:
          case 0x28u:
          case 0x29u:
          case 0x2Au:
          case 0x2Bu:
          case 0x2Cu:
          case 0x2Du:
          case 0x2Eu:
          case 0x2Fu:
          case 0x30u:
          case 0x31u:
          case 0x32u:
          case 0x33u:
          case 0x34u:
          case 0x35u:
          case 0x36u:
          case 0x37u:
          case 0x38u:
          case 0x39u:
          case 0x3Au:
          case 0x3Bu:
          case 0x3Cu:
          case 0x3Du:
            goto LABEL_14;
          case 4u:
            Character += 89;
            break;
          case 6u:
            goto LABEL_16;
          case 7u:
            return v2;
          case 0xEu:
            Character = 207;
            break;
          case 0x1Fu:
            goto LABEL_10;
          case 0x3Eu:
            goto LABEL_19;
          default:
            goto LABEL_12;
        }
      }
      return Character;
    }
LABEL_15:
    Character += 128;
    return Character;
  }
  if ( (int)Character <= 61 )
  {
    if ( Character == 6 )
    {
LABEL_16:
      v3 = Character + 4;
      if ( subfont_type == 2 )
        return 206;
      return v3;
    }
    if ( Character == 31 )
    {
LABEL_10:
      Character += 60;
      return Character;
    }
    goto LABEL_14;
  }
  if ( Character != 62 )
  {
LABEL_12:
    if ( Character == 143 )
      return 205;
LABEL_14:
    if ( (unsigned __int16)(Character - 16) > 9u )
    {
      if ( (unsigned __int16)(Character - 33) > 0x19u )
      {
        if ( (unsigned __int16)(Character - 65) > 0x19u )
        {
          if ( (unsigned __int16)(Character - 96) > 0x16u )
          {
            if ( (unsigned __int16)(Character - 119) > 0x15u )
            {
              if ( (unsigned __int16)(Character - 141) < 2u )
                return 204;
            }
            else
            {
              Character += 62;
            }
          }
          else
          {
            Character += 85;
          }
        }
        else
        {
          Character += 90;
        }
      }
      else
      {
        Character += 122;
      }
      return Character;
    }
    goto LABEL_15;
  }
LABEL_19:
  v2 = 62;
  if ( subfont_type == 1 )
    return 32;
  return v2;
}

//----- (005A877A) --------------------------------------------------------
GxtChar __fastcall CFont::RemapCharacterWithoutGraphic(GxtChar Character)
{
  if ( Character == 145 )
    return 64;
  if ( Character > 0x9Bu )
    return 0;
  return Character;
}

//----- (005A878C) --------------------------------------------------------
void CFont::LoadFontValues()
{
  u_native v0; // r8
  const char *Line; // r0
  int *v2; // r9
  int v3; // r1
  bool v4; // zf
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r0
  unsigned __int8 *v7; // r0
  unsigned __int8 *v8; // r0
  int *v9; // r5
  unsigned int i; // r9
  unsigned __int8 *v11; // r0
  CFontSize *v12; // r0
  uint8 *v13; // r0
  unsigned __int8 v14; // [sp+34h] [bp-7Ch]
  int v15; // [sp+50h] [bp-60h] BYREF
  int v16; // [sp+54h] [bp-5Ch] BYREF
  int v17; // [sp+58h] [bp-58h] BYREF
  int v18; // [sp+5Ch] [bp-54h] BYREF
  int v19; // [sp+60h] [bp-50h] BYREF
  int v20; // [sp+64h] [bp-4Ch] BYREF
  int v21; // [sp+68h] [bp-48h] BYREF
  int v22; // [sp+6Ch] [bp-44h] BYREF
  char v23[32]; // [sp+70h] [bp-40h] BYREF

  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v0 = CFileMgr::OpenFile("DATA\\FONTS.DAT", "rb");
  Line = (const char *)CFileLoader::LoadLine(v0);
  if ( Line )
  {
    v2 = &v15;
    v14 = 0;
    do
    {
      v3 = *(unsigned __int8 *)Line;
      v4 = v3 == 0;
      if ( *Line )
        v4 = v3 == 35;
      if ( !v4 )
      {
        sscanf(Line, "%s", v23);
        if ( !strcmp(v23, "[TOTAL_FONTS]") )
        {
          v6 = CFileLoader::LoadLine(v0);
          sscanf((const char *)v6, "%d", v2);
        }
        else if ( !strcmp(v23, "[FONT_ID]") )
        {
          v7 = CFileLoader::LoadLine(v0);
          sscanf((const char *)v7, "%d", v2);
          v14 = v15;
        }
        else if ( !strcmp(v23, "[REPLACEMENT_SPACE_CHAR]") )
        {
          v8 = CFileLoader::LoadLine(v0);
          sscanf((const char *)v8, "%d", v2);
          CFont::Size[v14].x[208] = v15;
        }
        else if ( !strcmp(v23, "[PROP]") )
        {
          v9 = v2;
          for ( i = 0; i < 0xD0; i = (unsigned __int16)(i + 8) )
          {
            v11 = CFileLoader::LoadLine(v0);
            sscanf((const char *)v11, "%d  %d  %d  %d  %d  %d  %d  %d", v9, &v16, &v17, &v18, &v19, &v20, &v21, &v22);
            v12 = &CFont::Size[v14];
            v12->x[i] = v15;
            v13 = &v12->x[i];
            v13[1] = v16;
            v13[2] = v17;
            v13[3] = v18;
            v13[4] = v19;
            v13[5] = v20;
            v13[6] = v21;
            v13[7] = v22;
          }
          v2 = v9;
        }
        else if ( !strcmp(v23, "[UNPROP]") )
        {
          v5 = CFileLoader::LoadLine(v0);
          sscanf((const char *)v5, "%d", v2);
          CFont::Size[v14].NonProportionalWidth = v15;
        }
      }
      Line = (const char *)CFileLoader::LoadLine(v0);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v0);
}
// 61CADE: using guessed type char byte_61CADE;

//----- (005A8A0C) --------------------------------------------------------
void CFont::Shutdown()
{
  int32 TxdSlot; // r0
  int32 v1; // r0

  CSprite2d::Delete(CFont::Sprite);
  CSprite2d::Delete(&CFont::Sprite[1]);
  TxdSlot = CTxdStore::FindTxdSlot("fonts");
  CTxdStore::RemoveTxdSlot(TxdSlot);
  CSprite2d::Delete(&CFont::PS2Sprite[1]);
  CSprite2d::Delete(&CFont::PS2Sprite[2]);
  CSprite2d::Delete(&CFont::PS2Sprite[3]);
  CSprite2d::Delete(&CFont::PS2Sprite[4]);
  v1 = CTxdStore::FindTxdSlot("ps2btns");
  sub_197460(v1);
}

//----- (005A8A74) --------------------------------------------------------
void CFont::InitPerFrame()
{
  pFontBufferPosn = fontBuffer;
  CFont::PS2Symbol = 0;
  CFont::Details.EdgeSpace = 0;
  CFont::Details.EdgeAmount = 0;
  CFont::Details.DropAmount = 0;
  CFont::NewLine = 0;
  CFont::RenderState.Style = -1;
  sub_197450();
}

//----- (005A8ADC) --------------------------------------------------------
void __fastcall CFont::SetDropShadowPosition(int8 Amount)
{
  CFont::Details.DropAmount = Amount;
  *(_WORD *)&CFont::Details.EdgeAmount = 0;
}

//----- (005A8AF8) --------------------------------------------------------
void __fastcall CFont::PrintChar(float x, float y, GxtChar Character)
{
  unsigned int v3; // r4
  float ScaleY; // s26
  float v6; // s22
  bool v8; // zf
  int v9; // r8
  unsigned int Style; // r6
  float v11; // s0
  CFontSize *v12; // r0
  uint8 *p_NonProportionalWidth; // r2
  unsigned __int16 v14; // r1
  int v15; // r0
  unsigned int v16; // r0
  float v17; // s6
  float v18; // s2
  float v19; // s0
  float v20; // r2
  float v21; // s6
  float v22; // s0
  float v23; // r3
  int v24; // r2
  uint16 *p_unicode; // r3
  jChar_st *v26; // r0
  float tu3; // s4
  float tv3; // s6
  float tu4; // s8
  float tv4; // s10
  float tv2; // s2
  float v32; // [sp+0h] [bp-68h]
  float v33; // [sp+4h] [bp-64h]
  float v34; // [sp+8h] [bp-60h]
  float v35; // [sp+Ch] [bp-5Ch]
  float v36; // [sp+10h] [bp-58h]
  float v37; // [sp+14h] [bp-54h]
  CRect Rectangle; // [sp+18h] [bp-50h] BYREF

  v3 = Character;
  ScaleY = CFont::RenderState.ScaleY;
  v6 = (float)(CFont::RenderState.ScaleY * 32.0) * 0.5;
  if ( (float)-(float)((float)(ScaleY + ScaleY) + v6) > y
    || (float)RsGlobal.screenHeight < y
    || COERCE_FLOAT(COERCE_UNSIGNED_INT(CFont::GetCharacterSize(Character, 1)) ^ 0x80000000) > x
    || (float)RsGlobal.screenWidth < x
    || CFont::PS2Symbol )
  {
    return;
  }
  v8 = v3 == 63;
  if ( v3 != 63 )
    v8 = v3 == 0;
  if ( v8 )
  {
    v3 = 0;
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  Style = (unsigned __int16)CFont::RenderState.Style;
  if ( CFont::RenderState.Style == 2
    && (CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage) << 24 )
  {
    v11 = GetJapaneseWidth(v3 + 32, CFont::UsingJapaneseLanguage != 0) * 0.03125;
  }
  else
  {
    v12 = &CFont::Size[CFont::RenderState.Style];
    p_NonProportionalWidth = &v12->NonProportionalWidth;
    if ( CFont::RenderState.Proportional == 1 )
      p_NonProportionalWidth = &v12->x[v3];
    v11 = (float)*p_NonProportionalWidth * 0.03125;
    if ( CFont::RenderState.Style != 2 )
      goto LABEL_23;
  }
  if ( CFont::UsingRussianLanguage | CFont::UsingKoreanLanguage || CFont::UsingJapaneseLanguage && IsJapanese )
  {
    v14 = v3 + 32;
    if ( CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage )
    {
      if ( (unsigned __int16)(v3 + 32620) > 2u )
      {
        if ( (v14 & 0x8000) != 0 )
        {
          v15 = v14 & 0x7FFF;
        }
        else
        {
          v24 = 32;
          if ( jCount + 32 > v14 )
            v24 = v14 - 32;
          v15 = v24;
        }
      }
      else
      {
        v15 = v14 + jCount - 32951;
      }
    }
    else if ( CFont::UsingRussianLanguage )
    {
      v15 = 32;
      if ( jCount + 32 > v14 )
        v15 = v14 - 32;
    }
    else if ( jCount < 1 )
    {
LABEL_49:
      v15 = 31;
    }
    else
    {
      p_unicode = &JMet[0].unicode;
      v15 = 0;
      while ( *p_unicode != v14 )
      {
        ++v15;
        p_unicode += 24;
        if ( v15 >= jCount )
          goto LABEL_49;
      }
    }
    Rectangle.left = x;
    Rectangle.bottom = y;
    v26 = &JMet[v15];
    tu3 = v26->tu3;
    tv3 = v26->tv3;
    tu4 = v26->tu4;
    tv4 = v26->tv4;
    Rectangle.top = v6 + y;
    tv2 = v26->tv2;
    Rectangle.right = (float)(GLOBAL_FONT_SCALE * (float)(v11 * (float)(CFont::RenderState.ScaleX * 32.0))) + x;
    CSprite2d::AddToBuffer(
      &Rectangle,
      &CFont::RenderState.Colour,
      v26->tu1,
      v26->tv1,
      v26->tu2,
      tv2,
      tu3,
      tv3,
      tu4,
      tv4);
    return;
  }
LABEL_23:
  v16 = v3;
  if ( CFont::RenderState.ExtraFont == 1 )
    v16 = 0;
  if ( v3 != 208 )
    v16 = v3;
  v17 = (float)((__int16)v16 >> 4);
  v18 = (float)(v16 & 0xF) * 0.0625;
  if ( Style > 2 )
  {
    if ( v9 )
      return;
    v20 = (float)(v16 & 0xF) * 0.0625;
    Rectangle.left = x;
    Rectangle.bottom = y;
    v23 = v17 * 0.0625;
    v32 = (float)(v11 * 0.0625) + v18;
    Rectangle.top = v6 + y;
    v33 = v17 * 0.0625;
    v34 = v20;
    v35 = (float)(v17 * 0.0625) + 0.0625;
    Rectangle.right = (float)(v11 * (float)(CFont::RenderState.ScaleX * 32.0)) + x;
    v36 = v32 + -0.0001;
    v37 = v35 + -0.0001;
  }
  else
  {
    v19 = v17 / 12.8;
    if ( v9 || CFont::RenderState.Slope != 0.0 )
    {
      if ( v9 )
        return;
      v20 = (float)(v16 & 0xF) * 0.0625;
      Rectangle.left = x;
      v23 = v19 + 0.00055;
      Rectangle.bottom = y + 0.015;
      v32 = (float)(v18 + 0.0625) + -0.001;
      Rectangle.right = (float)(CFont::RenderState.ScaleX * 32.0) + x;
      Rectangle.top = (float)(y + 0.015) + (float)((float)(ScaleY * 40.0) * 0.5);
      v33 = (float)(v19 + 0.0021) + 0.01;
      v34 = v20;
      v35 = (float)(v19 + 0.078125) + -0.009;
      v36 = v32;
      v37 = (float)((float)(v19 + 0.078125) + -0.0021) + 0.01;
    }
    else
    {
      v20 = (float)(v16 & 0xF) * 0.0625;
      if ( v16 < 0xC0 )
      {
        Rectangle.left = x;
        Rectangle.bottom = y;
        v23 = v19 + 0.0021;
        v32 = (float)(v18 + 0.0625) + -0.001;
        v33 = v19 + 0.0021;
        v34 = (float)(v16 & 0xF) * 0.0625;
        v35 = (float)(v19 + 0.078125) + -0.0021;
        v36 = v32;
        v37 = v35;
        Rectangle.right = (float)(CFont::RenderState.ScaleX * 32.0) + x;
        Rectangle.top = (float)((float)(ScaleY * 40.0) * 0.5) + y;
      }
      else
      {
        v21 = v19 + 0.0021;
        v22 = v19 + 0.078125;
        Rectangle.left = x;
        Rectangle.bottom = y;
        v23 = v21;
        Rectangle.top = v6 + y;
        v32 = (float)(v18 + 0.0625) + -0.001;
        v33 = v21;
        v34 = (float)(v16 & 0xF) * 0.0625;
        v35 = v22 + -0.016;
        v36 = v32;
        v37 = v22 + -0.015;
        Rectangle.right = (float)(CFont::RenderState.ScaleX * 32.0) + x;
      }
    }
  }
  CSprite2d::AddToBuffer(&Rectangle, &CFont::RenderState.Colour, v20, v23, v32, v33, v34, v35, v36, v37);
}

//----- (005A90D8) --------------------------------------------------------
float __fastcall CFont::GetHeight(bool UseRenderState)
{
  float *p_ScaleY; // r1

  p_ScaleY = &CFont::Details.ScaleY;
  if ( UseRenderState )
    p_ScaleY = &CFont::RenderState.ScaleY;
  return (float)(*p_ScaleY + *p_ScaleY) + (float)((float)(*p_ScaleY * 32.0) * 0.5);
}

//----- (005A9120) --------------------------------------------------------
void CFont::RenderFontBuffer()
{
  __int64 v0; // d8
  __int64 v1; // d9
  __int64 v2; // d10
  __int64 v3; // d11
  float x; // s20
  float v5; // s22
  GxtChar *v6; // r1
  GxtChar *v7; // r6
  int v8; // r0
  GxtChar *v9; // r0
  GxtChar *v10; // r6
  __int64 v11; // d17
  float v12; // r0
  __int64 v13; // d18
  __int64 v14; // d19
  int v15; // t1
  int v16; // r11
  Char *v17; // r0
  GxtChar *v18; // r0
  int Shadow; // r1
  GxtChar *v20; // r5
  int SubFontCharacter; // r4
  bool v22; // zf
  float JapaneseWidth; // s0
  CFontSize *v24; // r0
  unsigned int NonProportionalWidth; // r0
  CRGBA color; // [sp+7Ch] [bp-4Ch] BYREF
  __int64 v27; // [sp+80h] [bp-48h]
  __int64 v28; // [sp+88h] [bp-40h]
  __int64 v29; // [sp+90h] [bp-38h]
  __int64 v30; // [sp+98h] [bp-30h]

  if ( pFontBufferPosn != fontBuffer )
  {
    v27 = v0;
    v28 = v1;
    v29 = v2;
    v30 = v3;
    CSprite2d::SetRenderState(&CFont::Sprite[CFont::RenderState.Style]);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    *(_QWORD *)&CFont::RenderState.id = *(_QWORD *)fontBuffer;
    *(_QWORD *)&CFont::RenderState.y = *(_QWORD *)&fontBuffer[4];
    CFont::RenderState.Colour = *(CRGBA *)&fontBuffer[10];
    CFont::RenderState.ScaleY = *(float *)&fontBuffer[8];
    *(_QWORD *)((char *)&CFont::RenderState.SlopeRefY + 3) = *(_QWORD *)((char *)&fontBuffer[19] + 1);
    x = *(float *)&fontBuffer[2];
    v5 = *(float *)&fontBuffer[4];
    *(_QWORD *)&CFont::RenderState.PixelsToAdd = *(_QWORD *)&fontBuffer[12];
    *(_QWORD *)&CFont::RenderState.SlopeRefX = *(_QWORD *)&fontBuffer[16];
    v6 = pFontBufferPosn;
    color = *(CRGBA *)&fontBuffer[10];
    if ( pFontBufferPosn > &fontBuffer[24] )
    {
      v7 = &fontBuffer[24];
      while ( 1 )
      {
        v8 = *v7;
        if ( !*v7 )
        {
          v9 = v7 + 12;
          do
          {
            v10 = v9 + 1;
            v22 = (_DWORD)(v9 - 11) << 30 == 0;
            ++v9;
          }
          while ( !v22 );
          if ( v10 - 12 >= v6 )
            goto LABEL_65;
          v11 = *((_QWORD *)v10 - 2);
          v12 = *((float *)v10 - 2);
          *(_QWORD *)&CFont::RenderState.id = *((_QWORD *)v10 - 3);
          *(_QWORD *)&CFont::RenderState.y = v11;
          CFont::RenderState.ScaleY = v12;
          CFont::RenderState.Colour = (CRGBA)*((_DWORD *)v10 - 1);
          v13 = *(_QWORD *)v10;
          v14 = *((_QWORD *)v10 + 1);
          x = CFont::RenderState.x;
          v5 = *(float *)&v11;
          *(_QWORD *)((char *)&CFont::RenderState.SlopeRefY + 3) = *(_QWORD *)((char *)v10 + 15);
          color = CFont::RenderState.Colour;
          *(_QWORD *)&CFont::RenderState.PixelsToAdd = v13;
          *(_QWORD *)&CFont::RenderState.SlopeRefX = v14;
          v15 = v10[12];
          v7 = v10 + 12;
          v8 = v15;
        }
        v16 = 0;
        CFont::PS2Symbol = 0;
        if ( v8 != 126 )
          break;
        if ( v7[1] == 109 )
        {
          v17 = GxtCharToAscii(v7, 0);
          CTouchInterface::DrawHelpIcon(
            v17,
            x,
            v5,
            (float)(CFont::RenderState.ScaleY + CFont::RenderState.ScaleY)
          + (float)((float)(CFont::RenderState.ScaleY * 32.0) * 0.5),
            CFont::RenderState.Colour._anon_0._anon_0.alpha);
          v16 = CFont::PS2Symbol;
          v8 = *v7;
          x = x
            + (float)((float)(CFont::RenderState.ScaleY + CFont::RenderState.ScaleY)
                    + (float)((float)(CFont::RenderState.ScaleY * 32.0) * 0.5));
          if ( v8 != 126 )
            break;
        }
        else
        {
          v8 = 126;
          v16 = 0;
        }
        if ( v16 )
          break;
        v18 = CFont::ParseToken(v7, &color, CFont::RenderState.Shadow, 0);
        Shadow = CFont::RenderState.Shadow;
        v20 = v18;
        if ( !CFont::RenderState.Shadow )
          CFont::RenderState.Colour = color;
        v8 = *v18;
        v16 = CFont::PS2Symbol;
        while ( v8 == 126 )
        {
          if ( v16 )
            break;
          if ( v20[1] == 109 )
          {
            CFont::PS2Symbol = 10;
            if ( !(Shadow << 24) )
              goto LABEL_22;
          }
          else
          {
            v20 = CFont::ParseToken(v20, &color, Shadow, 0);
            Shadow = CFont::RenderState.Shadow;
            if ( !(CFont::RenderState.Shadow << 24) )
LABEL_22:
              CFont::RenderState.Colour = color;
          }
          v8 = *v20;
          v16 = CFont::PS2Symbol;
        }
LABEL_27:
        if ( (unsigned __int16)(v8 - 1) > 0x1Eu )
        {
          if ( v8 )
          {
            SubFontCharacter = v8 + 65504;
            if ( CFont::RenderState.Style != 2
              || !((CFont::UsingJapaneseLanguage | CFont::UsingKoreanLanguage | CFont::UsingRussianLanguage) << 24) )
            {
              if ( CFont::RenderState.ExtraFont )
              {
                SubFontCharacter = CFont::FindSubFontCharacter(v8 - 32, CFont::RenderState.ExtraFont);
              }
              else if ( (unsigned __int16)(v8 - 32) == 145 )
              {
                SubFontCharacter = 64;
              }
              else if ( (unsigned __int16)(v8 - 32) > 0x9Bu )
              {
                SubFontCharacter = 0;
              }
            }
            if ( CFont::RenderState.Slope != 0.0 )
              v5 = CFont::RenderState.SlopeRefY
                 + (float)(CFont::RenderState.Slope * (float)(CFont::RenderState.SlopeRefX - x));
            v22 = v16 == 0;
            if ( v16 )
              v22 = CFont::RenderState.Shadow == 0;
            if ( v22 )
            {
              CFont::PrintChar(x, v5, SubFontCharacter);
              v16 = CFont::PS2Symbol;
              if ( !CFont::PS2Symbol )
              {
                if ( CFont::RenderState.Style == 2
                  && (CFont::UsingRussianLanguage | CFont::UsingJapaneseLanguage | CFont::UsingKoreanLanguage) << 24 )
                {
                  JapaneseWidth = GetJapaneseWidth(SubFontCharacter + 32, CFont::UsingJapaneseLanguage != 0);
                }
                else
                {
                  if ( CFont::RenderState.Proportional == 1 )
                  {
                    v24 = &CFont::Size[CFont::RenderState.Style];
                    if ( (unsigned __int16)SubFontCharacter != 63 )
                      v24 = (CFontSize *)((char *)v24 + (unsigned __int16)SubFontCharacter);
                    NonProportionalWidth = v24->x[0];
                  }
                  else
                  {
                    NonProportionalWidth = CFont::Size[CFont::RenderState.Style].NonProportionalWidth;
                  }
                  JapaneseWidth = (float)NonProportionalWidth;
                }
                v16 = 0;
                x = x
                  + (float)(CFont::RenderState.ScaleX * (float)(JapaneseWidth + (float)CFont::RenderState.EdgeAmount));
              }
            }
            v7 = v20 + 1;
            if ( !(SubFontCharacter << 16) )
              x = x + CFont::RenderState.PixelsToAdd;
            if ( v16 )
              v7 = v20;
            if ( !*v20 )
              v7 = v20;
            if ( v16 )
            {
              CFont::PS2Symbol = 0;
              CSprite2d::SetRenderState(&CFont::Sprite[CFont::RenderState.Style]);
            }
          }
          else
          {
            v7 = v20;
          }
        }
        else
        {
          v7 = v20 + 1;
        }
        v6 = pFontBufferPosn;
        if ( v7 >= pFontBufferPosn )
          goto LABEL_65;
      }
      v20 = v7;
      goto LABEL_27;
    }
LABEL_65:
    CSprite::FlushSpriteBuffer();
    CSprite2d::RenderVertexBuffer();
    pFontBufferPosn = fontBuffer;
  }
}
// 5A913E: variable 'v0' is possibly undefined
// 5A913E: variable 'v1' is possibly undefined
// 5A913E: variable 'v2' is possibly undefined
// 5A913E: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0;
// 14: using guessed type int dword_14;
// 676D1C: using guessed type char *CFont::PS2Symbol;

//----- (005A9724) --------------------------------------------------------
float __fastcall CFont::ComputeHeight(float fHeight)
{
  return (float)(fHeight + fHeight) + (float)((float)(fHeight * 32.0) * 0.5);
}

//----- (005A974C) --------------------------------------------------------
GxtChar *__fastcall CFont::ParseToken(GxtChar *pCharacters, CRGBA *color, bool8 shadow, unsigned __int8 *latest_token)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  float32x2_t v7; // d4
  unsigned __int8 *v8; // r4
  __int16 v11; // r0
  char v12; // r1
  RwUInt8 alpha; // r3
  uint8 v14; // r2
  unsigned int red; // r1
  unsigned int green; // r0
  unsigned int v17; // r1
  unsigned int v18; // r3
  char **v19; // r0
  uint8 *v20; // r0
  CRGBA v22; // [sp+4h] [bp-14h] BYREF

  v8 = (unsigned __int8 *)(pCharacters + 1);
  if ( pCharacters[2] == 126 )
  {
    v11 = *(_WORD *)v8;
    switch ( *(_WORD *)v8 )
    {
      case '<':
        CFont::PS2Symbol = 3;
        v11 = 60;
        goto LABEL_51;
      case '>':
        CFont::PS2Symbol = 4;
        v11 = 62;
        goto LABEL_51;
      case 'A':
      case 'a':
        v12 = 11;
        goto LABEL_36;
      case 'B':
      case 'b':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 2;
        break;
      case 'C':
      case 'c':
        v12 = 14;
        goto LABEL_36;
      case 'D':
      case 'd':
        v12 = 2;
        goto LABEL_36;
      case 'F':
      case 'f':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 4;
        break;
      case 'G':
      case 'g':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 1;
        break;
      case 'H':
      case 'h':
        if ( shadow )
          goto LABEL_46;
        red = color->_anon_0._anon_0.red;
        green = color->_anon_0._anon_0.green;
        if ( (red & green) == 255 && (green = 255, color->_anon_0._anon_0.blue == 255) )
        {
          LOBYTE(v17) = -36;
          LOBYTE(v18) = -36;
        }
        else
        {
          v7.n64_u32[0] = 1132396544;
          v5.n64_f32[0] = (float)red * 1.5;
          v6.n64_f32[0] = (float)green * 1.5;
          v4.n64_f32[0] = (float)color->_anon_0._anon_0.blue * 1.5;
          green = (unsigned int)vmin_f32(v6, v7).n64_f32[0];
          v17 = (unsigned int)vmin_f32(v5, v7).n64_f32[0];
          v18 = (unsigned int)vmin_f32(v4, v7).n64_f32[0];
        }
        CRGBA::CRGBA(&v22, v17, green, v18, color->_anon_0._anon_0.alpha);
        goto LABEL_45;
      case 'J':
      case 'j':
        v12 = 12;
        goto LABEL_36;
      case 'K':
      case 'k':
        v12 = 9;
        goto LABEL_36;
      case 'M':
      case 'm':
        v12 = 10;
        goto LABEL_36;
      case 'N':
      case 'n':
        v19 = &CFont::NewLine;
        goto LABEL_31;
      case 'O':
      case 'o':
        v12 = 6;
        goto LABEL_36;
      case 'P':
      case 'p':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 8;
        break;
      case 'Q':
      case 'q':
        v12 = 7;
        goto LABEL_36;
      case 'R':
      case 'r':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 0;
        break;
      case 'S':
      case 's':
        if ( !shadow )
          goto LABEL_34;
        goto LABEL_46;
      case 'T':
      case 't':
        v12 = 8;
        goto LABEL_36;
      case 'U':
      case 'u':
        v19 = &CFont::PS2Symbol;
LABEL_31:
        v20 = (uint8 *)*v19;
        v12 = 1;
        goto LABEL_37;
      case 'V':
      case 'v':
        v12 = 13;
        goto LABEL_36;
      case 'W':
      case 'w':
        if ( shadow )
          goto LABEL_46;
LABEL_34:
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 5;
        break;
      case 'X':
      case 'x':
        v12 = 5;
LABEL_36:
        v20 = &CFont::PS2Symbol;
LABEL_37:
        *v20 = v12;
        goto LABEL_50;
      case 'Y':
      case 'y':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 12;
        break;
      case 'l':
        if ( shadow )
          goto LABEL_46;
        alpha = color->_anon_0._anon_0.alpha;
        v14 = 6;
        break;
      default:
        goto LABEL_51;
    }
    CHudColours::GetRGB(&v22, &HudColour, v14, alpha);
LABEL_45:
    *color = v22;
LABEL_46:
    if ( latest_token )
      *latest_token = *v8;
  }
  do
  {
LABEL_50:
    v11 = *(_WORD *)v8;
LABEL_51:
    v8 += 2;
  }
  while ( v11 != 126 );
  return (GxtChar *)v8;
}
// 5A988C: variable 'v6' is possibly undefined
// 5A988C: variable 'v7' is possibly undefined
// 5A9888: variable 'v5' is possibly undefined
// 5A9890: variable 'v4' is possibly undefined
// 676D1C: using guessed type char *CFont::PS2Symbol;
// 6788B4: using guessed type char *CFont::NewLine;

//----- (005A9A28) --------------------------------------------------------
void __fastcall CFont::RenderString(
        float x,
        float y,
        GxtChar *pCharacterStart,
        GxtChar *pCharacterEnd,
        float PixelsToAdd)
{
  float v9; // s18
  float v10; // s20
  Int8 DropAmount; // r10
  CRGBA v12; // r11
  int v13; // r9
  RwUInt8 blue; // r6
  RwInt32 screenHeight; // r0
  RwInt32 screenWidth; // r1
  float v17; // s0
  Int8 EdgeAmount; // r12
  CRGBA v19; // r1
  RwUInt8 red; // r6
  RwInt32 v21; // r0
  RwInt32 v22; // r1
  float v23; // s22
  Int8 v24; // r5
  RwUInt8 v25; // r9
  GxtChar *v26; // r0
  unsigned int v27; // r11
  unsigned int v28; // r10
  unsigned int v29; // r5
  RwUInt8 alpha; // r2
  float SlopeRefX; // r3
  float SlopeRefY; // r6
  GxtChar *v33; // r0
  CFontDetails *v34; // r5
  CFontRenderState *v35; // r6
  int v36; // r3
  GxtChar *v37; // r2
  bool8 Shadow; // r2
  GxtChar *v39; // r0
  unsigned int v40; // r3
  unsigned int v41; // r12
  GxtChar *v42; // r2
  unsigned int v43; // r6
  GxtChar *v44; // lr
  unsigned int v45; // r1
  unsigned int v46; // r3
  GxtChar *v47; // r5
  bool v48; // cf
  GxtChar *v49; // r5
  GxtChar *v50; // r3
  int v51; // r10
  unsigned int v52; // lr
  GxtChar *v53; // r1
  __int64 v54; // d16
  __int64 v55; // d17
  bool v56; // zf
  GxtChar v57; // t1
  GxtChar *v58; // r1
  GxtChar *v59; // [sp+Ch] [bp-7Ch]
  CFontRenderState *v60; // [sp+10h] [bp-78h]
  CFontDetails *v61; // [sp+14h] [bp-74h]
  unsigned int v62; // [sp+18h] [bp-70h]
  unsigned int v63; // [sp+24h] [bp-64h]
  unsigned int v64; // [sp+28h] [bp-60h]
  unsigned int v65; // [sp+28h] [bp-60h]
  unsigned int v66; // [sp+2Ch] [bp-5Ch]
  unsigned int v67; // [sp+2Ch] [bp-5Ch]
  CRGBA v68; // [sp+30h] [bp-58h]
  CRGBA color; // [sp+34h] [bp-54h] BYREF

  v68 = CFont::Details.Color;
  if ( CFont::RenderState.Style != CFont::Details.Style )
  {
    CFont::RenderFontBuffer();
    CFont::RenderState.Style = CFont::Details.Style;
  }
  v9 = y;
  v10 = x;
  DropAmount = CFont::Details.DropAmount;
  if ( CFont::Details.DropAmount )
  {
    v12 = CFont::Details.Color;
    CFont::Details.Shadow = 1;
    v13 = *(_DWORD *)&CFont::Details.Color >> 8;
    CFont::Details.DropAmount = 0;
    blue = CFont::Details.Color._anon_0._anon_0.blue;
    CFont::Details.Color = CFont::Details.DropColor;
    if ( CFont::Details.Slope == 0.0 )
    {
      v17 = (float)DropAmount;
      screenHeight = RsGlobal.screenHeight;
      screenWidth = RsGlobal.screenWidth;
    }
    else
    {
      screenHeight = RsGlobal.screenHeight;
      screenWidth = RsGlobal.screenWidth;
      v17 = (float)DropAmount;
      CFont::Details.SlopeRefX = CFont::Details.SlopeRefX + (float)((float)((float)RsGlobal.screenWidth / 640.0) * v17);
      CFont::Details.SlopeRefY = CFont::Details.SlopeRefY + (float)((float)((float)RsGlobal.screenHeight / 448.0) * v17);
    }
    CFont::RenderString(
      (float)((float)((float)screenWidth / 640.0) * v17) + v10,
      (float)((float)((float)screenHeight / 448.0) * v17) + v9,
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::Details.Color._anon_0._anon_0.green = v13;
    CFont::Details.Color._anon_0._anon_0.red = v12._anon_0._anon_0.red;
    CFont::Details.Color._anon_0._anon_0.blue = blue;
    CFont::Details.Color._anon_0._anon_0.alpha = v12._anon_0._anon_0.alpha;
    CFont::Details.DropAmount = DropAmount;
LABEL_13:
    CFont::Details.Shadow = 0;
    goto LABEL_14;
  }
  EdgeAmount = CFont::Details.EdgeAmount;
  if ( CFont::Details.EdgeAmount )
  {
    v19 = CFont::Details.Color;
    CFont::Details.Shadow = 1;
    CFont::Details.EdgeAmount = 0;
    CFont::Details.Color = CFont::Details.DropColor;
    red = v19._anon_0._anon_0.red;
    v66 = HIBYTE(*(unsigned int *)&v19);
    v63 = *(unsigned int *)&v19 >> 8;
    v64 = HIWORD(*(unsigned int *)&v19);
    if ( CFont::Details.Slope == 0.0 )
    {
      v23 = (float)EdgeAmount;
      v21 = RsGlobal.screenHeight;
      v22 = RsGlobal.screenWidth;
    }
    else
    {
      v21 = RsGlobal.screenHeight;
      v22 = RsGlobal.screenWidth;
      v23 = (float)EdgeAmount;
      CFont::Details.SlopeRefX = CFont::Details.SlopeRefX + (float)((float)((float)RsGlobal.screenWidth / 640.0) * v23);
      CFont::Details.SlopeRefY = CFont::Details.SlopeRefY + (float)((float)((float)RsGlobal.screenHeight / 448.0) * v23);
    }
    v24 = EdgeAmount;
    CFont::RenderString(
      (float)((float)((float)v22 / 640.0) * v23) + x,
      y - (float)((float)((float)v21 / 448.0) * v23),
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      x - (float)((float)((float)RsGlobal.screenWidth / 640.0) * v23),
      y - (float)((float)((float)RsGlobal.screenHeight / 448.0) * v23),
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      (float)((float)((float)RsGlobal.screenWidth / 640.0) * v23) + x,
      (float)((float)((float)RsGlobal.screenHeight / 448.0) * v23) + y,
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      x - (float)((float)((float)RsGlobal.screenWidth / 640.0) * v23),
      (float)((float)((float)RsGlobal.screenHeight / 448.0) * v23) + y,
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      (float)((float)((float)RsGlobal.screenWidth / 640.0) * v23) + x,
      y,
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      x - (float)((float)((float)RsGlobal.screenWidth / 640.0) * v23),
      y,
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      x,
      (float)((float)((float)RsGlobal.screenHeight / 448.0) * v23) + y,
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::RenderString(
      x,
      y - (float)((float)((float)RsGlobal.screenHeight / 448.0) * v23),
      pCharacterStart,
      pCharacterEnd,
      PixelsToAdd);
    CFont::Details.Color._anon_0._anon_0.green = v63;
    CFont::Details.Color._anon_0._anon_0.red = red;
    CFont::Details.Color._anon_0._anon_0.blue = v64;
    CFont::Details.Color._anon_0._anon_0.alpha = v66;
    CFont::Details.EdgeAmount = v24;
    goto LABEL_13;
  }
LABEL_14:
  v25 = v68._anon_0._anon_0.red;
  v26 = pFontBufferPosn;
  v27 = HIBYTE(*(unsigned int *)&v68);
  v28 = HIWORD(*(unsigned int *)&v68);
  v29 = *(unsigned int *)&v68 >> 8;
  if ( pFontBufferPosn >= &fontBuffer[-26 - ((unsigned int)((char *)pCharacterEnd - (char *)pCharacterStart) >> 1) + 512] )
  {
    CFont::RenderFontBuffer();
    v26 = pFontBufferPosn;
  }
  *((float *)v26 + 1) = v10;
  *((float *)v26 + 2) = v9;
  *(_QWORD *)(v26 + 6) = *(_QWORD *)&CFont::Details.ScaleX;
  v26[10] = *(_WORD *)&CFont::Details.Color._anon_0._anon_0.red;
  *((_BYTE *)v26 + 22) = CFont::Details.Color._anon_0._anon_0.blue;
  alpha = CFont::Details.Color._anon_0._anon_0.alpha;
  *((float *)v26 + 6) = PixelsToAdd;
  *((_BYTE *)v26 + 23) = alpha;
  SlopeRefX = CFont::Details.SlopeRefX;
  SlopeRefY = CFont::Details.SlopeRefY;
  *((_DWORD *)v26 + 7) = LODWORD(CFont::Details.Slope);
  *((float *)v26 + 8) = SlopeRefX;
  *((float *)v26 + 9) = SlopeRefY;
  *((_BYTE *)v26 + 41) = CFont::Details.ExtraFont;
  *((_BYTE *)v26 + 42) = CFont::Details.Proportional;
  v26[22] = CFont::Details.Style;
  *((_BYTE *)v26 + 40) = CFont::Details.Shadow;
  *((_BYTE *)v26 + 46) = CFont::Details.EdgeSpace;
  v33 = v26 + 24;
  pFontBufferPosn = v33;
  if ( pCharacterStart >= pCharacterEnd )
    goto LABEL_42;
  v65 = *(unsigned int *)&v68 >> 8;
  v67 = HIBYTE(*(unsigned int *)&v68);
  v34 = &CFont::Details;
  v35 = &CFont::RenderState;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v36 = *pCharacterStart;
        if ( v36 == 126 )
          break;
        v37 = pFontBufferPosn;
        ++pCharacterStart;
        v33 = ++pFontBufferPosn;
        *v37 = v36;
        if ( pCharacterStart >= pCharacterEnd )
          goto LABEL_41;
      }
      Shadow = v35->Shadow;
      color = v34->Color;
      v39 = CFont::ParseToken(pCharacterStart, &color, Shadow, 0);
      if ( !((v34->Shadow | CFont::PS2Symbol) << 24) )
      {
        v25 = color._anon_0._anon_0.red;
        v28 = color._anon_0._anon_0.blue;
        *(_WORD *)&CFont::Details.Color._anon_0._anon_0.red = *(_WORD *)&color._anon_0._anon_0.red;
        LOBYTE(v67) = CFont::Details.Color._anon_0._anon_0.alpha;
        LOBYTE(v65) = color._anon_0._anon_0.green;
        CFont::Details.Color._anon_0._anon_0.blue = color._anon_0._anon_0.blue;
      }
      CFont::PS2Symbol = 0;
      if ( pCharacterStart == v39 )
        break;
      v60 = v35;
      v40 = (char *)(v39 - 1) - (char *)pCharacterStart;
      v41 = v40 >> 1;
      v42 = pFontBufferPosn;
      v43 = (v40 >> 1) + 1;
      v61 = v34;
      v62 = v28;
      v44 = pFontBufferPosn + 1;
      if ( v43 < 8 )
        goto LABEL_35;
      v45 = v43 & 0xFFFFFFF8;
      if ( (v43 & 0xFFFFFFF8) == 0 )
        goto LABEL_35;
      v46 = v40 & 0xFFFFFFFE;
      v47 = (GxtChar *)((char *)pCharacterStart + v46 + 2);
      v48 = pFontBufferPosn >= v47;
      if ( pFontBufferPosn < v47 )
        v48 = pCharacterStart >= (GxtChar *)((char *)pFontBufferPosn + v46 + 2);
      if ( v48 )
      {
        v49 = &pCharacterStart[v45];
        v50 = &pFontBufferPosn[v45];
        v59 = pFontBufferPosn + 1;
        v51 = 0;
        v52 = v43 & 0xFFFFFFF8;
        do
        {
          v53 = &v42[v51];
          v54 = *(_QWORD *)&pCharacterStart[v51];
          v55 = *(_QWORD *)&pCharacterStart[v51 + 4];
          v52 -= 8;
          v51 += 8;
          *(_QWORD *)v53 = v54;
          *((_QWORD *)v53 + 1) = v55;
        }
        while ( v52 );
        v56 = v43 == (v43 & 0xFFFFFFF8);
        v35 = v60;
        v44 = v59;
        if ( v56 )
          goto LABEL_37;
      }
      else
      {
LABEL_35:
        v50 = pFontBufferPosn;
        v49 = pCharacterStart;
        v35 = v60;
      }
      do
      {
        v57 = *v49++;
        *v50++ = v57;
      }
      while ( v39 != v49 );
LABEL_37:
      pFontBufferPosn = &v44[v41];
      v34 = v61;
      v28 = v62;
      pCharacterStart += v41 + 1;
      if ( pCharacterStart >= pCharacterEnd )
        goto LABEL_40;
    }
  }
  while ( pCharacterStart < pCharacterEnd );
LABEL_40:
  v33 = pFontBufferPosn;
LABEL_41:
  LOBYTE(v29) = v65;
  LOBYTE(v27) = v67;
LABEL_42:
  v58 = v33 + 1;
  pFontBufferPosn = v33 + 1;
  *v33 = 0;
  if ( ((unsigned int)(v33 + 1) & 3) != 0 )
  {
    do
      ++v58;
    while ( ((unsigned __int8)v58 & 3) != 0 );
    pFontBufferPosn = v58;
  }
  if ( !CFont::Details.Shadow )
  {
    CFont::Details.Color._anon_0._anon_0.green = v29;
    CFont::Details.Color._anon_0._anon_0.red = v25;
    CFont::Details.Color._anon_0._anon_0.blue = v28;
    CFont::Details.Color._anon_0._anon_0.alpha = v27;
  }
}
// 676D1C: using guessed type char *CFont::PS2Symbol;

//----- (005AA150) --------------------------------------------------------
void __fastcall CFont::PrintStringFromBottom(float x, float Bottomy, GxtChar *pCharacters)
{
  float v5; // s2

  v5 = Bottomy
     - (float)((float)((float)(CFont::Details.ScaleY + CFont::Details.ScaleY)
                     + (float)((float)(CFont::Details.ScaleY * 32.0) * 0.5))
             * (float)CFont::ProcessCurrentString(0, x, Bottomy, pCharacters));
  if ( CFont::Details.Slope != 0.0 )
    v5 = v5 - (float)(CFont::Details.SlopeRefY + (float)(CFont::Details.Slope * (float)(CFont::Details.SlopeRefX - x)));
  CFont::PrintString(x, v5, pCharacters);
}

//----- (005AA1F0) --------------------------------------------------------
Int16 __fastcall CFont::GetNumberLines(float x, float y, GxtChar *pCharacters)
{
  return CFont::ProcessCurrentString(0, x, y, pCharacters);
}

//----- (005AA200) --------------------------------------------------------
void __fastcall CFont::PrintString(float x, float y, GxtChar *pCharacters)
{
  int v5; // r0
  bool v7; // zf
  unsigned __int8 v8; // r0
  float v9; // s0
  float v10; // s2
  float v11; // s0
  float v12; // s4
  CRGBA colour; // [sp+Ch] [bp-3Ch] BYREF
  CRect Rectangle; // [sp+10h] [bp-38h] BYREF

  v5 = *pCharacters;
  v7 = v5 == 0;
  if ( *pCharacters )
    v7 = v5 == 42;
  if ( !v7 )
  {
    if ( CFont::Details.Background )
    {
      *(_WORD *)&CFont::RenderState.Colour._anon_0._anon_0.red = *(_WORD *)&CFont::Details.Color._anon_0._anon_0.red;
      CFont::RenderState.Colour._anon_0._anon_0.blue = CFont::Details.Color._anon_0._anon_0.blue;
      *(_QWORD *)&Rectangle.left = 0xC974240049742400LL;
      *(_QWORD *)&Rectangle.right = 0x49742400C9742400LL;
      v8 = CFont::ProcessCurrentString(0, x, y, pCharacters);
      if ( CFont::Details.Centre )
      {
        v9 = (float)(CFont::Details.Centrex * 0.5) + 4.0;
        v10 = x - v9;
        v11 = v9 + x;
      }
      else if ( CFont::Details.RightJustify )
      {
        v10 = CFont::Details.RightJustifyWrap + -4.0;
        v11 = x + 4.0;
      }
      else
      {
        v10 = x + -4.0;
        v11 = CFont::Details.WrapEnd + 4.0;
      }
      Rectangle.left = v10;
      Rectangle.right = v11;
      v12 = (float)((float)(CFont::Details.ScaleY + CFont::Details.ScaleY)
                  + (float)((float)(CFont::Details.ScaleY * 32.0) * 0.5))
          * (float)v8;
      Rectangle.top = y + -4.0;
      Rectangle.bottom = (float)(v12 + y) + 4.0;
      if ( CFont::Details.BackgroundOutline )
      {
        colour = CFont::Details.BGColor;
        Rectangle.left = v10 + -1.0;
        Rectangle.bottom = (float)((float)(v12 + y) + 4.0) + 1.0;
        Rectangle.top = (float)(y + -4.0) + -1.0;
        Rectangle.right = v11 + 1.0;
        CMenuManager::DrawWindow(&FrontEndMenuManager, &Rectangle, 0, 0, (CRGBA)&colour, 0, 1);
      }
      else
      {
        CSprite2d::DrawRect(&Rectangle, &CFont::Details.BGColor);
      }
      CFont::Details.Background = 0;
    }
    CFont::ProcessCurrentString(1u, x, y, pCharacters);
  }
}
// 18: using guessed type int (*off_18)();

//----- (005AA404) --------------------------------------------------------
void __fastcall CFont::GetTextRect(CRect *pRect, float x, float y, GxtChar *pCharacters)
{
  unsigned __int8 v7; // r0
  float v8; // s2

  v7 = CFont::ProcessCurrentString(0, x, y, pCharacters);
  if ( CFont::Details.Centre )
  {
    pRect->left = x - (float)((float)(CFont::Details.Centrex * 0.5) + 4.0);
    v8 = (float)((float)(CFont::Details.Centrex * 0.5) + 4.0) + x;
  }
  else if ( CFont::Details.RightJustify )
  {
    v8 = x + 4.0;
    pRect->left = CFont::Details.RightJustifyWrap + -4.0;
  }
  else
  {
    pRect->left = x + -4.0;
    v8 = CFont::Details.WrapEnd + 4.0;
  }
  pRect->right = v8;
  pRect->top = y + -4.0;
  pRect->bottom = (float)((float)((float)((float)(CFont::Details.ScaleY + CFont::Details.ScaleY)
                                        + (float)((float)(CFont::Details.ScaleY * 32.0) * 0.5))
                                * (float)v7)
                        + y)
                + 4.0;
}

//----- (005AA518) --------------------------------------------------------
void __fastcall CFont::ProcessStringToDisplay(float x, float y, GxtChar *pCharacters)
{
  CFont::ProcessCurrentString(1u, x, y, pCharacters);
}

//----- (005AA524) --------------------------------------------------------
Int16 __fastcall CFont::ProcessCurrentString(bool8 PrintTheString, float x, float y, GxtChar *NewStringChars)
{
  GxtChar *NextSpace; // r5
  float v6; // s28
  char v7; // r0
  float v9; // s30
  int v10; // r10
  __int16 v11; // r11
  float StringWidth; // r8
  GxtChar *v13; // r9
  float Centrex; // s2
  float v15; // s17
  float PixelsToAdd; // s17
  GxtChar *v17; // r5
  float v18; // s0
  int v19; // r6
  unsigned __int8 v20; // r0
  unsigned __int8 *v21; // r2
  CRGBA *p_color; // r1
  int v23; // t1
  unsigned __int8 *v24; // r2
  char *v25; // r1
  int v26; // t1
  float v27; // s0
  bool v28; // zf
  float CharacterSize; // s0
  __int16 *v30; // r0
  int v31; // t1
  int v32; // r1
  int v33; // r2
  int v34; // r3
  GxtChar v36; // r1
  GxtChar *v37; // r0
  int v38; // t1
  CRGBA v39; // [sp+Ch] [bp-424h]
  int v40; // [sp+80h] [bp-3B0h]
  GxtChar *pCharacterStart; // [sp+90h] [bp-3A0h]
  int v42; // [sp+94h] [bp-39Ch]
  CRGBA color; // [sp+98h] [bp-398h] BYREF
  GxtChar v44; // [sp+9Ch] [bp-394h]
  __int16 v45; // [sp+AEh] [bp-382h] BYREF
  char v46[800]; // [sp+B0h] [bp-380h] BYREF
  int v47; // [sp+3D0h] [bp-60h] BYREF

  v40 = PrintTheString;
  NextSpace = NewStringChars;
  v6 = 0.0;
  if ( !((CFont::Details.RightJustify | CFont::Details.Centre) << 24) )
    v6 = x;
  HIBYTE(v45) = 0;
  if ( CFont::Details.Style == 2
    && CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage )
  {
    if ( !CFont::UsingJapaneseLanguage )
    {
      if ( CFont::UsingKoreanLanguage | CFont::UsingRussianLanguage || (v36 = *NewStringChars) == 0 )
      {
LABEL_8:
        v7 = 0;
        goto LABEL_9;
      }
      v37 = NewStringChars + 1;
      while ( v36 <= 0x7Fu )
      {
        v38 = *v37++;
        v36 = v38;
        if ( !v38 )
          goto LABEL_8;
      }
    }
    v7 = 1;
LABEL_9:
    IsJapanese = v7;
  }
  v39 = CFont::Details.Color;
  if ( *NewStringChars )
  {
    v9 = 0.0;
    v10 = 1;
    v11 = 0;
    pCharacterStart = NewStringChars;
    v42 = 0;
    while ( 1 )
    {
      CFont::PS2Symbol = 0;
      StringWidth = CFont::GetStringWidth(NextSpace, 0, 0);
      if ( *NextSpace == 126 )
        v13 = CFont::ParseToken(NextSpace, &color, 1u, (unsigned __int8 *)&v45 + 1);
      else
        v13 = NextSpace;
      if ( CFont::Details.Centre )
      {
        Centrex = CFont::Details.Centrex;
      }
      else if ( CFont::Details.RightJustify )
      {
        Centrex = x - CFont::Details.RightJustifyWrap;
      }
      else
      {
        Centrex = CFont::Details.WrapEnd;
      }
      v15 = v6 + StringWidth;
      if ( !(v10 << 24) && v15 > Centrex )
      {
        switch ( *v13 )
        {
          case '!':
          case '$':
          case ',':
          case '.':
          case '/':
          case ':':
          case '?':
          case '\\':
            goto LABEL_23;
          default:
            if ( !CFont::UsingJapaneseLanguage || numOfPunctIndexes < 1 )
              goto LABEL_24;
            v34 = 0;
            break;
        }
        while ( JPNIndexPunct[v34] != (unsigned __int16)(*v13 - 32) )
        {
          if ( ++v34 >= numOfPunctIndexes )
            goto LABEL_24;
        }
      }
LABEL_23:
      if ( CFont::NewLine )
      {
LABEL_24:
        PixelsToAdd = 0.0;
        if ( CFont::PS2Symbol )
          v13 -= 3;
        v17 = v13;
        if ( CFont::NewLine )
          v17 = v13 - 3;
        if ( CFont::Details.Justify )
        {
          PixelsToAdd = 0.0;
          if ( !CFont::Details.Centre )
            PixelsToAdd = (float)(CFont::Details.WrapEnd - v9) / (float)v11;
        }
        if ( CFont::Details.Centre )
        {
          v18 = x + (float)(v6 * -0.5);
        }
        else
        {
          v18 = x;
          if ( CFont::Details.RightJustify )
            v18 = x - (float)(v6 - CFont::GetCharacterSize(0, 0));
        }
        if ( v40 )
          CFont::RenderString(v18, y, pCharacterStart, v17, PixelsToAdd);
        ++v42;
        if ( HIBYTE(v45) )
        {
          sprintf(gString, "~%c~", HIBYTE(v45));
          v20 = gString[0];
          if ( CFont::NewLine )
            v17 += 3;
          if ( v46 > (char *)v17 || &v47 <= (int *)v17 )
          {
            if ( gString[0] )
            {
              v24 = &gString[1];
              v25 = v46;
              do
              {
                *(_WORD *)v25 = v20;
                v25 += 2;
                v26 = *v24++;
                v20 = v26;
              }
              while ( v26 );
            }
            else
            {
              v25 = v46;
            }
            v30 = &v45;
            *(_WORD *)v25 = 0;
            do
            {
              v31 = (unsigned __int16)v30[1];
              ++v30;
            }
            while ( v31 );
            LOWORD(v32) = *v17;
            if ( *v17 )
            {
              v33 = 0;
              do
              {
                v30[v33] = v32;
                v32 = v17[++v33];
              }
              while ( v32 );
              v30 = (__int16 *)((char *)v30 + v33 * 2);
            }
            NextSpace = (GxtChar *)v46;
            *v30 = 0;
          }
          else
          {
            if ( gString[0] )
            {
              v21 = &gString[1];
              p_color = &color;
              do
              {
                *(_WORD *)&p_color->_anon_0._anon_0.red = v20;
                p_color = (CRGBA *)((char *)p_color + 2);
                v23 = *v21++;
                v20 = v23;
              }
              while ( v23 );
            }
            else
            {
              p_color = &color;
            }
            *(_WORD *)&p_color->_anon_0._anon_0.red = 0;
            *(v17 - 3) = *(_WORD *)&color._anon_0._anon_0.red;
            NextSpace = v17 - 3;
            NextSpace[1] = *(_WORD *)&color._anon_0.col[2];
            NextSpace[2] = v44;
          }
          HIBYTE(v45) = 0;
        }
        else
        {
          NextSpace = v13;
        }
        v6 = 0.0;
        v11 = 0;
        v10 = 1;
        v9 = 0.0;
        if ( !((CFont::Details.Centre | CFont::Details.RightJustify) << 24) )
          v6 = x;
        pCharacterStart = NextSpace;
        CFont::NewLine = 0;
        y = y
          + (float)((float)(CFont::Details.ScaleY + CFont::Details.ScaleY)
                  + (float)((float)(CFont::Details.ScaleY * 32.0) * 0.5));
        goto LABEL_92;
      }
      NextSpace = CFont::GetNextSpace(v13);
      v19 = *NextSpace;
      if ( !*NextSpace )
      {
        if ( CFont::Details.Centre )
        {
          v27 = x + (float)(v15 * -0.5);
        }
        else
        {
          v27 = x - v15;
          if ( !CFont::Details.RightJustify )
            v27 = x;
        }
        ++v42;
        if ( v40 )
          CFont::RenderString(v27, y, pCharacterStart, NextSpace, 0.0);
        v6 = v6 + StringWidth;
        goto LABEL_92;
      }
      if ( v10 << 24 )
      {
        if ( v19 == 126 )
          goto LABEL_63;
      }
      else
      {
        v11 += !IsJapanese || CFont::UsingJapaneseLanguage == 0 || v19 == 32;
        if ( v19 == 126 )
          goto LABEL_63;
      }
      v28 = CFont::UsingJapaneseLanguage == 0;
      if ( CFont::UsingJapaneseLanguage )
        v28 = !IsJapanese;
      if ( v28 )
      {
        v10 = 0;
        CharacterSize = CFont::GetCharacterSize(v19 - 32, 0);
        if ( v19 == 32 )
          ++NextSpace;
        goto LABEL_91;
      }
      if ( v19 == 32 )
      {
        v10 = 0;
        CharacterSize = CFont::GetCharacterSize(0, 0);
        ++NextSpace;
LABEL_91:
        v9 = v15 + CharacterSize;
        v6 = v15 + CharacterSize;
        goto LABEL_92;
      }
LABEL_63:
      v10 = 0;
      v9 = v6 + StringWidth;
      v6 = v6 + StringWidth;
LABEL_92:
      if ( CFont::PS2Symbol )
        CFont::PS2Symbol = 0;
      if ( !*NextSpace )
        goto LABEL_97;
    }
  }
  LOWORD(v42) = 0;
LABEL_97:
  if ( v40 )
  {
    CFont::Details.Color = v39;
    if ( CFont::Details.AlphaFade < 255.0 )
      CFont::Details.Color._anon_0._anon_0.alpha = (unsigned int)(float)((float)(CFont::Details.AlphaFade
                                                                               * (float)HIBYTE(*(unsigned int *)&v39))
                                                                       / 255.0);
  }
  return v42;
}
// 676D1C: using guessed type char *CFont::PS2Symbol;
// 6788B4: using guessed type char *CFont::NewLine;

//----- (005AABEC) --------------------------------------------------------
float __fastcall CFont::GetStringWidth(GxtChar *pInCharacters, bool8 bIncludeSpaces, bool8 bUsingWithScriptValues)
{
  GxtChar *v3; // r6
  int v4; // r4
  float CharacterSize; // r0
  float v6; // s16
  float v7; // r5
  bool v8; // zf
  int v9; // t1
  bool v10; // zf
  unsigned int GxtStringLength; // r0
  int v12; // r5
  int v13; // r8
  int v14; // r1
  unsigned int v15; // r0
  __int16 *v16; // r6
  char v17; // r9
  float v18; // s18
  intro_text_line *v19; // r10
  Int32 *p_ScriptTextFontStyle; // r11
  Int8 *p_ScriptTextEdge; // r12
  int v22; // r0
  char v23; // r2
  GxtChar SubFontCharacter; // r0
  Int32 v25; // r1
  int ScriptTextProportional; // r3
  float ScriptTextXScale; // s20
  __int16 v28; // r11
  uint8 v29; // r1
  float v30; // s0
  CFontSize *v31; // r1
  uint8 *p_NonProportionalWidth; // r0
  int v33; // r1
  int v34; // r3
  _BOOL4 v35; // r3
  bool v36; // zf
  __int16 v37; // r1
  int v38; // t1
  GxtChar v40; // r1
  GxtChar *v41; // r0
  int v42; // t1
  int v43; // [sp+0h] [bp-370h]
  Int8 v44; // [sp+4h] [bp-36Ch]
  Int32 *v45; // [sp+8h] [bp-368h]
  Int8 *v46; // [sp+Ch] [bp-364h]
  int v47; // [sp+14h] [bp-35Ch]
  _WORD v48[428]; // [sp+18h] [bp-358h] BYREF

  v3 = pInCharacters;
  v4 = bIncludeSpaces;
  v47 = bUsingWithScriptValues;
  if ( CFont::Details.Style == 2
    && CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage )
  {
    if ( CFont::UsingJapaneseLanguage )
    {
LABEL_4:
      IsJapanese = 1;
      CharacterSize = COERCE_FLOAT(CFont::GetNextSpace(v3));
      v6 = 0.0;
      v7 = CharacterSize;
      while ( (unsigned int)v3 >= LODWORD(v7) )
      {
        v8 = v4 == 0;
        if ( v4 )
        {
          LODWORD(CharacterSize) = *v3;
          v8 = LODWORD(CharacterSize) == 0;
        }
        if ( v8 )
          return v6;
        if ( LODWORD(CharacterSize) == 126 )
          goto LABEL_12;
LABEL_15:
        v10 = LODWORD(CharacterSize) == 0;
        if ( CharacterSize != 0.0 )
          v10 = LODWORD(CharacterSize) == 126;
        if ( !v10 )
        {
          CharacterSize = CFont::GetCharacterSize(LOWORD(CharacterSize) - 32, 0);
          ++v3;
          v6 = v6 + CharacterSize;
        }
      }
      LODWORD(CharacterSize) = *v3;
      if ( LODWORD(CharacterSize) != 126 )
        goto LABEL_15;
LABEL_12:
      ++v3;
      do
        v9 = *v3++;
      while ( v9 != 126 );
      LODWORD(CharacterSize) = *v3;
      goto LABEL_15;
    }
    if ( !(CFont::UsingKoreanLanguage | CFont::UsingRussianLanguage) )
    {
      v40 = *pInCharacters;
      if ( *pInCharacters )
      {
        v41 = pInCharacters + 1;
        while ( v40 <= 0x7Fu )
        {
          v42 = *v41++;
          v40 = v42;
          if ( !v42 )
            goto LABEL_20;
        }
        goto LABEL_4;
      }
    }
LABEL_20:
    IsJapanese = 0;
  }
  GxtStringLength = CMessages::GetGxtStringLength(v3);
  v12 = GxtStringLength;
  if ( GxtStringLength > 0x18E )
    v12 = 399;
  v13 = 0;
  if ( v12 < 1 )
  {
    v12 = 0;
  }
  else
  {
    v14 = -400;
    v15 = ~GxtStringLength;
    if ( v15 > 0xFFFFFE70 )
      v14 = v15;
    qmemcpy(v48, v3, -2 - 2 * v14);
  }
  v16 = v48;
  v48[v12] = 0;
  v17 = 0;
  v6 = 0.0;
  if ( !v4 )
    v17 = 1;
  v18 = CFont::Details.ScaleY * 20.0;
  v19 = &CTheScripts::IntroTextLines[CTheScripts::NumberOfIntroTextLinesThisFrame];
  p_ScriptTextFontStyle = &v19->ScriptTextFontStyle;
  p_ScriptTextEdge = &v19->ScriptTextEdge;
  v22 = 0;
LABEL_53:
  while ( 2 )
  {
    LOWORD(v33) = *v16;
    while ( 1 )
    {
      v34 = (unsigned __int16)v33 ^ 0x20 | v4;
      v35 = v34 != 0;
      v36 = (unsigned __int16)v33 == 0;
      if ( (_WORD)v33 )
        v36 = !v35;
      if ( v36 )
        return v6;
      if ( (unsigned __int16)v33 != 126 )
        break;
      if ( !v4 && (v22 | v13) << 24 )
        return v6;
      v38 = (unsigned __int16)v16[1];
      ++v16;
      v37 = v38;
      if ( v38 == 109 )
      {
        v6 = v6 + v18;
        v22 = 1;
        v37 = 109;
      }
      while ( 1 )
      {
        ++v16;
        if ( v37 == 126 )
          break;
        v37 = *v16;
      }
      if ( v22 << 24 )
      {
        v13 = 1;
        goto LABEL_53;
      }
      v33 = (unsigned __int16)*v16;
      v22 = 0;
      if ( v33 == 126 )
      {
        v13 = 1;
        goto LABEL_53;
      }
    }
    v23 = v13;
    if ( (_BYTE)v13 )
      v23 = 1;
    if ( (((unsigned __int16)v33 == 32) & (unsigned __int8)v23 & (unsigned __int8)v17) == 0 )
    {
      SubFontCharacter = v33 - 32;
      v46 = p_ScriptTextEdge;
      if ( !v47 )
      {
        v30 = CFont::GetCharacterSize(SubFontCharacter, 0);
LABEL_52:
        v6 = v6 + v30;
        ++v16;
        v22 = 1;
        p_ScriptTextEdge = v46;
        continue;
      }
      if ( SubFontCharacter == 63 )
        SubFontCharacter = 0;
      v25 = *p_ScriptTextFontStyle;
      ScriptTextProportional = v19->ScriptTextProportional;
      ScriptTextXScale = v19->ScriptTextXScale;
      v45 = p_ScriptTextFontStyle;
      v44 = *p_ScriptTextEdge;
      if ( *p_ScriptTextFontStyle == 3 )
      {
        v43 = v19->ScriptTextProportional;
        v29 = 1;
        v28 = 1;
      }
      else
      {
        if ( v25 != 2 )
        {
          v28 = (unsigned __int8)v25;
          if ( SubFontCharacter == 145 )
          {
            SubFontCharacter = 64;
          }
          else if ( SubFontCharacter > 0x9Bu )
          {
            SubFontCharacter = 0;
          }
          goto LABEL_44;
        }
        v28 = 0;
        v29 = 2;
        v43 = v19->ScriptTextProportional;
      }
      SubFontCharacter = CFont::FindSubFontCharacter(SubFontCharacter, v29);
      ScriptTextProportional = v43;
LABEL_44:
      v31 = &CFont::Size[v28];
      p_NonProportionalWidth = &v31->x[SubFontCharacter];
      if ( !ScriptTextProportional )
        p_NonProportionalWidth = &v31->NonProportionalWidth;
      p_ScriptTextFontStyle = v45;
      v30 = ScriptTextXScale * (float)((float)v44 + (float)*p_NonProportionalWidth);
      goto LABEL_52;
    }
    return v6;
  }
}
// 5AABEC: using guessed type _WORD var_358[428];

//----- (005AAED4) --------------------------------------------------------
GxtChar *__fastcall CFont::GetNextSpace(GxtChar *pCharacters)
{
  unsigned int v1; // r1
  __int16 v2; // lr
  int v3; // t1
  int v4; // r1
  int v5; // r2
  int v6; // t1
  GxtChar v7; // t1
  int v8; // r1
  bool v9; // zf
  GxtChar *v10; // r3
  GxtChar v11; // r2
  int v12; // t1

  if ( CFont::Details.Style != 2
    || !(CFont::UsingKoreanLanguage | CFont::UsingJapaneseLanguage | CFont::UsingRussianLanguage) )
  {
    goto LABEL_24;
  }
  if ( !CFont::UsingJapaneseLanguage )
  {
    if ( !(CFont::UsingKoreanLanguage | CFont::UsingRussianLanguage) )
    {
      v1 = *pCharacters;
      if ( *pCharacters )
      {
        v10 = pCharacters + 1;
        v11 = *pCharacters;
        while ( v11 <= 0x7Fu )
        {
          v12 = *v10++;
          v11 = v12;
          if ( !v12 )
            goto LABEL_23;
        }
        goto LABEL_5;
      }
    }
LABEL_23:
    IsJapanese = 0;
LABEL_24:
    while ( 1 )
    {
      v8 = *pCharacters;
      if ( !*pCharacters )
        break;
      v9 = v8 == 32;
      if ( v8 != 32 )
        v9 = v8 == 126;
      if ( v9 )
        break;
      ++pCharacters;
    }
    return pCharacters;
  }
  v1 = *pCharacters;
LABEL_5:
  IsJapanese = 1;
  if ( v1 >= 0x80 && CFont::UsingJapaneseLanguage )
  {
    while ( 1 )
    {
      v3 = pCharacters[1];
      ++pCharacters;
      v2 = v3;
      switch ( v3 )
      {
        case '!':
        case '$':
        case ',':
        case '.':
        case '/':
        case ':':
        case '?':
        case '\\':
          continue;
        default:
          if ( numOfPunctIndexes < 1 )
            return pCharacters;
          v4 = 0;
          break;
      }
      while ( 1 )
      {
        v5 = JPNIndexPunct[v4++];
        if ( v5 == (unsigned __int16)(v2 - 32) )
          break;
        if ( v4 >= numOfPunctIndexes )
          return pCharacters;
      }
    }
  }
  while ( v1 == 126 )
  {
    ++pCharacters;
    do
      v6 = *pCharacters++;
    while ( v6 != 126 );
    v1 = *pCharacters;
  }
  while ( ((unsigned __int16)v1 | 0x20) != 32 && (unsigned __int16)v1 <= 0x7Fu && (unsigned __int16)v1 != 126 )
  {
    v7 = pCharacters[1];
    ++pCharacters;
    LOWORD(v1) = v7;
  }
  return pCharacters;
}

//----- (005AB038) --------------------------------------------------------
void __fastcall CFont::SetColor(CRGBA Color)
{
  unsigned int v1; // r0

  *(_WORD *)&CFont::Details.Color._anon_0._anon_0.red = **(_WORD **)&Color;
  CFont::Details.Color._anon_0._anon_0.blue = *(_BYTE *)(*(_DWORD *)&Color + 2);
  v1 = *(unsigned __int8 *)(*(_DWORD *)&Color + 3);
  CFont::Details.Color._anon_0._anon_0.alpha = v1;
  if ( CFont::Details.AlphaFade < 255.0 )
    CFont::Details.Color._anon_0._anon_0.alpha = (unsigned int)(float)((float)(CFont::Details.AlphaFade * (float)v1)
                                                                     / 255.0);
}

//----- (005AB090) --------------------------------------------------------
float __fastcall CFont::GetStringWidth(
        GxtChar *pCharacters,
        bool8 bIncludeSpaces,
        bool8 bUsingWithScriptValues,
        bool8 isAscii)
{
  int v4; // r4
  GxtChar *v5; // r5
  float CharacterSize; // r0
  float v7; // s16
  float v8; // r6
  bool v9; // zf
  int v10; // t1
  bool v11; // zf

  v4 = bIncludeSpaces;
  v5 = pCharacters;
  CharacterSize = COERCE_FLOAT(CFont::GetNextSpace(pCharacters));
  v7 = 0.0;
  v8 = CharacterSize;
  while ( 1 )
  {
    if ( (unsigned int)v5 < LODWORD(v8) )
    {
      LODWORD(CharacterSize) = *v5;
      if ( LODWORD(CharacterSize) != 126 )
        goto LABEL_12;
      goto LABEL_9;
    }
    v9 = v4 == 0;
    if ( v4 )
    {
      LODWORD(CharacterSize) = *v5;
      v9 = LODWORD(CharacterSize) == 0;
    }
    if ( v9 )
      return v7;
    if ( LODWORD(CharacterSize) != 126 )
      goto LABEL_12;
LABEL_9:
    ++v5;
    do
      v10 = *v5++;
    while ( v10 != 126 );
    LODWORD(CharacterSize) = *v5;
LABEL_12:
    v11 = LODWORD(CharacterSize) == 0;
    if ( CharacterSize != 0.0 )
      v11 = LODWORD(CharacterSize) == 126;
    if ( !v11 )
    {
      CharacterSize = CFont::GetCharacterSize(LOWORD(CharacterSize) - 32, 0);
      ++v5;
      v7 = v7 + CharacterSize;
    }
  }
}

//----- (005AB108) --------------------------------------------------------
void __fastcall CFont::FilterOutTokensFromString(GxtChar *String)
{
  GxtChar v1; // r1
  GxtChar *v2; // r3
  GxtChar *v3; // r2
  int v4; // t1
  int v5; // r1
  unsigned __int16 *i; // r2
  int v7; // r3
  int v8; // t1
  _BYTE v9[512]; // [sp+0h] [bp-200h] BYREF

  v1 = *String;
  if ( *String )
  {
    v2 = String + 1;
    v3 = (GxtChar *)v9;
    do
    {
      *v3++ = v1;
      v4 = *v2++;
      v1 = v4;
    }
    while ( v4 );
  }
  else
  {
    v3 = (GxtChar *)v9;
  }
  v5 = 0;
  *v3 = 0;
  for ( i = (unsigned __int16 *)v9; ; ++i )
  {
    while ( 1 )
    {
      v7 = *i;
      if ( v7 != 126 )
        break;
      do
      {
        v8 = i[1];
        ++i;
      }
      while ( v8 != 126 );
      ++i;
    }
    if ( !*i )
      break;
    String[v5++] = v7;
  }
  String[v5] = 0;
}

//----- (005AB158) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
GxtChar __fastcall CFont::character_code(UInt8 a)
{
  GxtChar result; // r0

  if ( (a & 0x80u) != 0 )
    *(_WORD *)&a = foreign_table[a - 128];
  LOBYTE(result) = a;
  return result;
}
// 5AB158: bad return variable

//----- (005AB178) --------------------------------------------------------
void __fastcall CFont::SetScale(float fHeight)
{
  CFont::Details.ScaleY = fHeight;
  CFont::Details.ScaleX = fHeight * 0.54;
}

//----- (005AB19C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CFont::SetSlantRefPoint(float x, float y)
{
  *(_QWORD *)&CFont::Details.SlopeRefX = *(_QWORD *)&x;
}
// 5AB19C: variables would overlap: r0.4 and r0.8

//----- (005AB1AC) --------------------------------------------------------
void __fastcall CFont::SetSlant(float angle)
{
  CFont::Details.Slope = angle;
}

//----- (005AB1BC) --------------------------------------------------------
void __fastcall CFont::SetFontStyle(uint8 NewStyle)
{
  unsigned int v1; // r0
  char v2; // r0
  unsigned int v3; // r1
  int v4; // r2

  if ( (CFont::UsingJapaneseLanguage | CFont::UsingKoreanLanguage | CFont::UsingRussianLanguage) << 24 )
  {
    v1 = (unsigned __int8)(NewStyle - 4);
    if ( v1 >= 3 )
    {
      LOBYTE(v3) = 0;
      NewStyle = 2;
    }
    else
    {
      v2 = 8 * v1;
      v3 = 0x100u >> v2;
      *(_DWORD *)&NewStyle = (unsigned int)&elf_hash_bucket[16385] >> v2;
    }
  }
  else
  {
    v4 = NewStyle - 2;
    LOBYTE(v3) = 2;
    NewStyle = 0;
    switch ( v4 )
    {
      case 0:
        break;
      case 1:
      case 3:
        NewStyle = 1;
        LOBYTE(v3) = 1;
        break;
      case 2:
        NewStyle = 0;
        LOBYTE(v3) = 0;
        break;
      case 4:
        LOBYTE(v3) = 0;
        NewStyle = 1;
        break;
      default:
        LOBYTE(v3) = 0;
        break;
    }
  }
  CFont::Details.ExtraFont = v3;
  CFont::Details.Style = NewStyle;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005AB248) --------------------------------------------------------
void __fastcall CFont::SetWrapx(float x)
{
  CFont::Details.WrapEnd = x;
}

//----- (005AB258) --------------------------------------------------------
void __fastcall CFont::SetCentreSize(float x)
{
  CFont::Details.Centrex = x;
}

//----- (005AB268) --------------------------------------------------------
void __fastcall CFont::SetRightJustifyWrap(float Wrap)
{
  CFont::Details.RightJustifyWrap = Wrap;
}

//----- (005AB278) --------------------------------------------------------
void __fastcall CFont::SetAlphaFade(float Alpha)
{
  CFont::Details.AlphaFade = Alpha;
}

//----- (005AB288) --------------------------------------------------------
void __fastcall CFont::SetDropColor(CRGBA Color)
{
  CFont::Details.DropColor = **(CRGBA **)&Color;
  if ( CFont::Details.AlphaFade < 255.0 )
    CFont::Details.DropColor._anon_0._anon_0.alpha = (unsigned int)(float)((float)(CFont::Details.AlphaFade
                                                                                 * (float)CFont::Details.Color._anon_0._anon_0.alpha)
                                                                         / 255.0);
}

//----- (005AB2EC) --------------------------------------------------------
void __fastcall CFont::SetEdge(int8 Amount)
{
  int8 v1; // r1

  CFont::Details.DropAmount = 0;
  v1 = Amount;
  if ( CFont::UsingJapaneseLanguage )
    v1 = 1;
  if ( Amount <= 1 )
    v1 = Amount;
  CFont::Details.EdgeAmount = v1;
  CFont::Details.EdgeSpace = v1;
}
// 38: using guessed type int dword_38;

//----- (005AB320) --------------------------------------------------------
void __fastcall CFont::SetProportional(bool8 prop)
{
  CFont::Details.Proportional = prop;
}

//----- (005AB330) --------------------------------------------------------
void __fastcall CFont::SetBackground(bool8 bground, bool8 outline)
{
  CFont::Details.BackgroundOutline = outline;
  CFont::Details.Background = bground;
}

//----- (005AB340) --------------------------------------------------------
void __fastcall CFont::SetBackgroundColor(CRGBA Color)
{
  CFont::Details.BGColor = **(CRGBA **)&Color;
}

//----- (005AB364) --------------------------------------------------------
void __fastcall CFont::SetJustify(bool8 justify)
{
  CFont::Details.Justify = justify;
}

//----- (005AB374) --------------------------------------------------------
void __fastcall CFont::SetOrientation(uint8 orientation)
{
  char v1; // r0

  if ( orientation <= 2u )
  {
    v1 = 8 * orientation;
    CFont::Details.RightJustify = 0x10000u >> v1;
    CFont::Details.Centre = 1u >> v1;
  }
}

//----- (005AB3A0) --------------------------------------------------------
void CGlass::Init()
{
  CGlass::aGlassPanes[1].Active = 0;
  CGlass::aGlassPanes[0].Active = 0;
  CGlass::aGlassPanes[2].Active = 0;
  CGlass::aGlassPanes[3].Active = 0;
  CGlass::aGlassPanes[4].Active = 0;
  CGlass::aGlassPanes[5].Active = 0;
  CGlass::aGlassPanes[6].Active = 0;
  CGlass::aGlassPanes[7].Active = 0;
  CGlass::aGlassPanes[8].Active = 0;
  CGlass::aGlassPanes[9].Active = 0;
  CGlass::aGlassPanes[10].Active = 0;
  CGlass::aGlassPanes[11].Active = 0;
  CGlass::aGlassPanes[12].Active = 0;
  CGlass::aGlassPanes[13].Active = 0;
  CGlass::aGlassPanes[14].Active = 0;
  CGlass::aGlassPanes[15].Active = 0;
  CGlass::aGlassPanes[16].Active = 0;
  CGlass::aGlassPanes[17].Active = 0;
  CGlass::aGlassPanes[36].Active = 0;
  CGlass::aGlassPanes[19].Active = 0;
  CGlass::aGlassPanes[18].Active = 0;
  CGlass::aGlassPanes[20].Active = 0;
  CGlass::aGlassPanes[21].Active = 0;
  CGlass::aGlassPanes[22].Active = 0;
  CGlass::aGlassPanes[23].Active = 0;
  CGlass::aGlassPanes[24].Active = 0;
  CGlass::aGlassPanes[25].Active = 0;
  CGlass::aGlassPanes[26].Active = 0;
  CGlass::aGlassPanes[27].Active = 0;
  CGlass::aGlassPanes[28].Active = 0;
  CGlass::aGlassPanes[29].Active = 0;
  CGlass::aGlassPanes[30].Active = 0;
  CGlass::aGlassPanes[31].Active = 0;
  CGlass::aGlassPanes[32].Active = 0;
  CGlass::aGlassPanes[33].Active = 0;
  CGlass::aGlassPanes[34].Active = 0;
  CGlass::aGlassPanes[35].Active = 0;
  CGlass::aGlassPanes[38].Active = 0;
  CGlass::aGlassPanes[37].Active = 0;
  CGlass::aGlassPanes[39].Active = 0;
  CGlass::aGlassPanes[40].Active = 0;
  CGlass::aGlassPanes[41].Active = 0;
  CGlass::aGlassPanes[42].Active = 0;
  CGlass::aGlassPanes[43].Active = 0;
  CGlass::aGlassPanes[44].Active = 0;
  CentersWithTriangle[8] = 0.9;
  CentersWithTriangle[9] = 0.33333;
  *(_QWORD *)CentersWithTriangle = 0x3F0000003E088889LL;
  *(_QWORD *)&CentersWithTriangle[2] = 0x3F5555553EEEEEEFLL;
  *(_QWORD *)&CentersWithTriangle[4] = 0x3E2AAAAB3EBBBBBCLL;
  *(_QWORD *)&CentersWithTriangle[6] = 0x3F0000003F333333LL;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005AB4C8) --------------------------------------------------------
void CGlass::Update()
{
  int v0; // r5
  CFallingGlassPane *v1; // r4

  v0 = 45;
  v1 = CGlass::aGlassPanes;
  do
  {
    if ( v1->Active )
      CFallingGlassPane::Update(v1);
    --v0;
    ++v1;
  }
  while ( v0 );
}

//----- (005AB4F4) --------------------------------------------------------
void __fastcall CFallingGlassPane::Update(CFallingGlassPane *this)
{
  float v2; // s0
  int *v3; // r2
  float z; // s14
  float v5; // s2
  float v6; // s4
  float v7; // s0
  float v8; // s2
  float v9; // s4
  float v10; // s2
  float v11; // s4
  float v12; // s2
  float tz; // s6
  float v14; // s4
  float GroundZ; // s0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  CRGBA v20; // [sp+4h] [bp-4Ch] BYREF
  CVector vPosition; // [sp+8h] [bp-48h] BYREF
  CVector v22; // [sp+18h] [bp-38h] BYREF

  if ( CTimer::m_snTimeInMilliseconds >= this->TimeOfActivation )
  {
    v2 = 1.0;
    v3 = dword_5AB77C;
    z = this->MoveSpeed.z;
    if ( this->bWindScreen )
      v2 = 0.35;
    if ( this->bWindScreen )
      v3 = &dword_5AB77C[1];
    v5 = this->Matrix.tx + (float)(v2 * (float)(this->MoveSpeed.x * CTimer::ms_fTimeStep));
    v6 = this->Matrix.ty + (float)(v2 * (float)(this->MoveSpeed.y * CTimer::ms_fTimeStep));
    v7 = this->Matrix.tz + (float)(v2 * (float)(z * CTimer::ms_fTimeStep));
    this->MoveSpeed.z = z - (float)(*(float *)v3 * CTimer::ms_fTimeStep);
    this->Matrix.tx = v5;
    this->Matrix.ty = v6;
    this->Matrix.tz = v7;
    CrossProduct(&v22, &this->Spin, (const CVector *)this);
    v8 = v22.y + this->Matrix.yx;
    v9 = v22.z + this->Matrix.zx;
    this->Matrix.xx = v22.x + this->Matrix.xx;
    this->Matrix.yx = v8;
    this->Matrix.zx = v9;
    CrossProduct(&vPosition, &this->Spin, (const CVector *)&this->Matrix.xy);
    v22 = vPosition;
    v10 = vPosition.y + this->Matrix.yy;
    v11 = vPosition.z + this->Matrix.zy;
    this->Matrix.xy = vPosition.x + this->Matrix.xy;
    this->Matrix.yy = v10;
    this->Matrix.zy = v11;
    CrossProduct(&vPosition, &this->Spin, (const CVector *)&this->Matrix.xz);
    v22 = vPosition;
    v12 = vPosition.y + this->Matrix.yz;
    tz = this->Matrix.tz;
    v14 = vPosition.z + this->Matrix.zz;
    GroundZ = this->GroundZ;
    this->Matrix.xz = vPosition.x + this->Matrix.xz;
    this->Matrix.yz = v12;
    this->Matrix.zz = v14;
    if ( tz < GroundZ )
    {
      this->Active = 0;
      *(_QWORD *)&vPosition.x = *(_QWORD *)&this->Matrix.tx;
      vPosition.z = GroundZ;
      CAudioEngine::ReportGlassCollisionEvent(&AudioEngine, 127, &vPosition);
      if ( !this->bWindScreen )
      {
        CRGBA::CRGBA(&v20, 0xFFu, 0xFFu, 0xFFu, 0x20u);
        v16 = rand();
        Fx_c::AddGlass(&g_fx, &vPosition, &v20, (float)((float)((float)v16 * 4.6566e-10) * 0.04) + 0.02, 1);
        v17 = rand();
        Fx_c::AddGlass(&g_fx, &vPosition, &v20, (float)((float)((float)v17 * 4.6566e-10) * 0.04) + 0.02, 1);
        v18 = rand();
        Fx_c::AddGlass(&g_fx, &vPosition, &v20, (float)((float)((float)v18 * 4.6566e-10) * 0.04) + 0.02, 1);
        v19 = rand();
        Fx_c::AddGlass(&g_fx, &vPosition, &v20, (float)((float)((float)v19 * 4.6566e-10) * 0.04) + 0.02, 1);
      }
    }
  }
}
// 5AB77C: using guessed type int dword_5AB77C[2];

//----- (005AB798) --------------------------------------------------------
void CGlass::Render()
{
  int v0; // r5
  CFallingGlassPane *v1; // r4

  TempBufferIndicesStoredHiLight = 0;
  TempBufferVerticesStoredShattered = 1024;
  TempBufferIndicesStoredShattered = 2048;
  TempBufferVerticesStoredReflection = 1536;
  TempBufferIndicesStoredReflection = 3072;
  TempBufferVerticesStoredHiLight = 0;
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(
    rwRENDERSTATEFOGCOLOR,
    (void *)(CTimeCycle::m_CurrentColours.m_nSkyBottomBlue | (CTimeCycle::m_CurrentColours.m_nSkyBottomRed << 16) | (CTimeCycle::m_CurrentColours.m_nSkyBottomGreen << 8) | 0xFF000000));
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  v0 = 45;
  v1 = CGlass::aGlassPanes;
  do
  {
    if ( v1->Active )
      CFallingGlassPane::Render(v1);
    --v0;
    ++v1;
  }
  while ( v0 );
  CGlass::RenderHiLightPolys();
  CGlass::RenderShatteredPolys();
  CGlass::RenderReflectionPolys();
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  sub_192840(rwRENDERSTATEFOGENABLE, 0);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005AB8A8) --------------------------------------------------------
void __fastcall CFallingGlassPane::Render(CFallingGlassPane *this)
{
  __int64 v2; // d16
  float tx; // s16
  float ty; // s20
  float tz; // s18
  CSimpleTransform *p_tx; // r2
  float x; // s22
  float y; // s26
  float z; // s24
  signed int TimeOfActivation; // r0
  int v11; // r2
  float v12; // s10
  float v13; // s0
  unsigned int v14; // s0
  float v15; // s4
  unsigned int v16; // r0
  _DWORD *p_x; // r1
  int v18; // r0
  int TriangleType; // r0
  float *v20; // r2
  float *v21; // r1
  RwReal v22; // s0
  RwReal v23; // s2
  RwReal v24; // r10
  RwReal v25; // r11
  int v26; // r0
  float v27; // s0
  float v28; // s2
  float *v29; // r0
  float v30; // s6
  RwReal v31; // r8
  RwReal v32; // r9
  int v33; // r0
  float v34; // s0
  float v35; // s2
  float *v36; // r0
  float v37; // s6
  RwReal v38; // r2
  RwReal v39; // lr
  Int32 v40; // r0
  RwReal v41; // r3
  RwReal *v42; // r1
  Int32 v43; // r3
  RwImVertexIndex *v44; // r1
  float v45; // s16
  unsigned int v46; // r6
  int v47; // r6
  Int32 v48; // r3
  RwIm3DVertex *v49; // r2
  float v50; // s0
  float ScaleShatteredTexture; // s2
  Int32 v52; // r2
  RwImVertexIndex v53; // r5
  RwImVertexIndex v54; // r4
  RwReal *v55; // r1
  Int32 v56; // r1
  RwImVertexIndex *v57; // r0
  RwReal v58; // [sp+4h] [bp-9Ch]
  RwReal v59; // [sp+8h] [bp-98h]
  RwReal v60; // [sp+10h] [bp-90h]
  RwReal v61; // [sp+14h] [bp-8Ch]
  CVector v; // [sp+20h] [bp-80h] BYREF
  CVector v63; // [sp+2Ch] [bp-74h] BYREF
  CVector v64; // [sp+38h] [bp-68h] BYREF

  v2 = *(_QWORD *)&this->Matrix.xy;
  tx = this->Matrix.tx;
  ty = this->Matrix.ty;
  tz = this->Matrix.tz;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  v64.z = this->Matrix.zy;
  *(_QWORD *)&v64.x = v2;
  CVector::Normalise(&v64);
  TimeOfActivation = this->TimeOfActivation;
  v11 = CTimer::m_snTimeInMilliseconds - TimeOfActivation;
  v12 = (float)((float)(TheCamera.m_cameraMatrix.xy * v64.x) + (float)(TheCamera.m_cameraMatrix.yy * v64.y))
      + (float)(TheCamera.m_cameraMatrix.zy * v64.z);
  v13 = (float)((float)((float)(TheCamera.m_cameraMatrix.xy - (float)(v64.x * (float)(v12 + v12))) * 0.57)
              + (float)((float)(TheCamera.m_cameraMatrix.yy - (float)(v64.y * (float)(v12 + v12))) * 0.57))
      - (float)((float)(TheCamera.m_cameraMatrix.zy - (float)(v64.z * (float)(v12 + v12))) * 0.57);
  v14 = (unsigned int)(float)((float)((float)(v13 * (float)(v13 * (float)(v13 * (float)(v13 * (float)(v13 * v13)))))
                                    * 235.0)
                            + 20.0);
  if ( (int)CTimer::m_snTimeInMilliseconds < TimeOfActivation || (v15 = 500.0, v11 <= 500) )
  {
    v15 = (float)v11;
    if ( (int)CTimer::m_snTimeInMilliseconds < TimeOfActivation )
      v15 = 0.0;
  }
  if ( TempBufferIndicesStoredHiLight > 2040 )
  {
    CGlass::RenderHiLightPolys();
  }
  else if ( TempBufferVerticesStoredHiLight >= 1020 )
  {
    CGlass::RenderHiLightPolys();
  }
  v16 = (unsigned int)(float)((float)(v15 / 500.0) * (float)v14);
  if ( this->bWindScreen && (unsigned int)(float)((float)(v15 / 500.0) * (float)v14) <= 0x40 )
    v16 = 64;
  p_x = (_DWORD *)&TempVertexBuffer.m_3d[TempBufferVerticesStoredHiLight].position.x;
  v18 = v16 | (v16 << 16) | (v16 << 24) | (v16 << 8);
  p_x[6] = v18;
  p_x[7] = 1056964608;
  p_x[8] = 1056964608;
  p_x[15] = v18;
  p_x[16] = 1056964608;
  p_x[17] = 1058642330;
  p_x[24] = v18;
  p_x[25] = 1058642330;
  p_x[26] = 1058642330;
  TriangleType = this->TriangleType;
  v20 = &CentersWithTriangle[2 * TriangleType];
  v21 = (float *)((char *)CentersWithTriangle + ((8 * TriangleType) | 4));
  TriangleType *= 3;
  v22 = CoorsWithTriangle[2 * TriangleType] - *v20;
  v23 = *(float *)((char *)CoorsWithTriangle + ((8 * TriangleType) | 4)) - *v21;
  v.y = 0.0;
  v.x = v22;
  v.z = v23;
  operator*(&v63, &this->Matrix, &v);
  v24 = v63.x;
  v25 = v63.y;
  v61 = v63.z;
  v26 = this->TriangleType;
  v.y = 0.0;
  v27 = *(float *)((char *)CentersWithTriangle + ((8 * v26) | 4));
  v28 = CentersWithTriangle[2 * v26];
  v29 = &CoorsWithTriangle[6 * v26];
  v30 = v29[3];
  v.x = v29[2] - v28;
  v.z = v30 - v27;
  operator*(&v63, &this->Matrix, &v);
  v60 = v63.x;
  v31 = v63.y;
  v32 = v63.z;
  v33 = this->TriangleType;
  v.y = 0.0;
  v34 = *(float *)((char *)CentersWithTriangle + ((8 * v33) | 4));
  v35 = CentersWithTriangle[2 * v33];
  v36 = &CoorsWithTriangle[6 * v33];
  v37 = v36[5];
  v.x = v36[4] - v35;
  v.z = v37 - v34;
  operator*(&v63, &this->Matrix, &v);
  v39 = v63.x;
  v38 = v63.y;
  v40 = TempBufferVerticesStoredHiLight;
  v41 = v63.z;
  TempVertexBuffer.m_3d[TempBufferVerticesStoredHiLight].position.x = v24;
  v42 = &TempVertexBuffer.m_3d[v40].position.x;
  v42[1] = v25;
  v42[2] = v61;
  v42[9] = v60;
  v42[10] = v31;
  v42[11] = v32;
  v42[18] = v39;
  v42[19] = v38;
  v59 = v38;
  v42[20] = v41;
  v58 = v41;
  v43 = TempBufferIndicesStoredHiLight;
  TempBufferRenderIndexList[TempBufferIndicesStoredHiLight] = v40;
  v44 = &TempBufferRenderIndexList[v43];
  v44[2] = v40 + 2;
  v44[4] = v40 + 2;
  v44[1] = v40 + 1;
  v44[3] = v40;
  TempBufferVerticesStoredHiLight = v40 + 3;
  v44[5] = v40 + 1;
  TempBufferIndicesStoredHiLight = v43 + 6;
  if ( this->bShattered )
  {
    v45 = sqrtf(
            (float)((float)((float)(x - tx) * (float)(x - tx)) + (float)((float)(y - ty) * (float)(y - ty)))
          + (float)((float)(z - tz) * (float)(z - tz)));
    if ( TempBufferIndicesStoredShattered > 3064 || TempBufferVerticesStoredShattered >= 1532 )
      CGlass::RenderShatteredPolys();
    if ( v45 <= 30.0 )
      v46 = 140;
    else
      v46 = (unsigned int)(float)((float)((float)((float)((float)(v45 + -30.0) * -4.0) / 40.0) + 1.0) * 140.0);
    v47 = v46 | (v46 << 16) | (v46 << 24) | (v46 << 8);
    v48 = TempBufferVerticesStoredShattered;
    v49 = &TempVertexBuffer.m_3d[TempBufferVerticesStoredShattered];
    v49[1].color = (RwRGBA_0)v47;
    v49->color = (RwRGBA_0)v47;
    v49[2].color = (RwRGBA_0)v47;
    v49->texCoords.u = (float)(CoorsWithTriangle[6 * this->TriangleType] * 4.0) * this->ScaleShatteredTexture;
    v49->texCoords.v = (float)(*(float *)((char *)CoorsWithTriangle + ((24 * this->TriangleType) | 4)) * 4.0)
                     * this->ScaleShatteredTexture;
    v49[1].texCoords.u = (float)(CoorsWithTriangle[6 * this->TriangleType + 2] * 4.0) * this->ScaleShatteredTexture;
    v49[1].texCoords.v = (float)(CoorsWithTriangle[6 * this->TriangleType + 3] * 4.0) * this->ScaleShatteredTexture;
    v49[2].texCoords.u = (float)(CoorsWithTriangle[6 * this->TriangleType + 4] * 4.0) * this->ScaleShatteredTexture;
    v50 = CoorsWithTriangle[6 * this->TriangleType + 5] * 4.0;
    ScaleShatteredTexture = this->ScaleShatteredTexture;
    TempVertexBuffer.m_3d[v48].position.x = v24;
    v49[1].position.x = v60;
    v49[1].position.y = v31;
    v49[1].position.z = v32;
    v49->position.y = v25;
    v49->position.z = v61;
    v49[2].texCoords.v = v50 * ScaleShatteredTexture;
    v52 = TempBufferVerticesStoredShattered;
    v53 = TempBufferVerticesStoredShattered - 1022;
    v54 = TempBufferVerticesStoredShattered - 1023;
    v55 = &TempVertexBuffer.m_3d[TempBufferVerticesStoredShattered].position.x;
    v55[18] = v39;
    v55[19] = v59;
    v55[20] = v58;
    v56 = TempBufferIndicesStoredShattered;
    TempBufferRenderIndexList[TempBufferIndicesStoredShattered] = v52 - 1024;
    v57 = &TempBufferRenderIndexList[v56];
    v57[1] = v54;
    v57[2] = v53;
    v57[3] = v52 - 1024;
    v57[4] = v53;
    v57[5] = v54;
    TempBufferVerticesStoredShattered = v52 + 3;
    TempBufferIndicesStoredShattered = v56 + 6;
  }
}

//----- (005ABE20) --------------------------------------------------------
void CGlass::RenderHiLightPolys()
{
  if ( TempBufferVerticesStoredHiLight )
  {
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpShadowExplosionTex->raster);
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStoredHiLight, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStoredHiLight);
      RwIm3DEnd();
    }
    TempBufferVerticesStoredHiLight = 0;
    TempBufferIndicesStoredHiLight = 0;
  }
}
// 0: using guessed type int dword_0;

//----- (005ABEBC) --------------------------------------------------------
void CGlass::RenderShatteredPolys()
{
  if ( TempBufferVerticesStoredShattered != 1024 )
  {
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCrackedGlassTex->raster);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    if ( RwIm3DTransform(&TempVertexBuffer.m_3d[1024], TempBufferVerticesStoredShattered - 1024, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(
        rwPRIMTYPETRILIST,
        &TempBufferRenderIndexList[2048],
        TempBufferIndicesStoredShattered - 2048);
      RwIm3DEnd();
    }
    TempBufferIndicesStoredShattered = 2048;
    TempBufferVerticesStoredShattered = 1024;
  }
}
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005ABF70) --------------------------------------------------------
void CGlass::RenderReflectionPolys()
{
  if ( TempBufferVerticesStoredReflection != 1536 )
  {
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpShadowHeadLightsTex->raster);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    if ( RwIm3DTransform(&TempVertexBuffer.m_3d[1536], TempBufferVerticesStoredReflection - 1536, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(
        rwPRIMTYPETRILIST,
        &TempBufferRenderIndexList[3072],
        TempBufferIndicesStoredReflection - 3072);
      RwIm3DEnd();
    }
    TempBufferIndicesStoredReflection = 3072;
    TempBufferVerticesStoredReflection = 1536;
  }
}
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005AC024) --------------------------------------------------------
CFallingGlassPane *CGlass::FindFreePane()
{
  int v0; // r1
  CFallingGlassPane *result; // r0

  v0 = -1;
  for ( result = CGlass::aGlassPanes; result->Active; ++result )
  {
    if ( ++v0 >= 44 )
      return 0;
  }
  return result;
}

//----- (005AC048) --------------------------------------------------------
UInt8 __fastcall CGlass::CalcAlphaWithNormal(CVector *pNormal)
{
  float y; // s2
  float z; // s4
  float v3; // s10
  float v4; // s0

  y = pNormal->y;
  z = pNormal->z;
  v3 = (float)((float)(TheCamera.m_cameraMatrix.xy * pNormal->x) + (float)(TheCamera.m_cameraMatrix.yy * y))
     + (float)(TheCamera.m_cameraMatrix.zy * z);
  v4 = (float)((float)((float)(TheCamera.m_cameraMatrix.xy - (float)(pNormal->x * (float)(v3 + v3))) * 0.57)
             + (float)((float)(TheCamera.m_cameraMatrix.yy - (float)(y * (float)(v3 + v3))) * 0.57))
     - (float)((float)(TheCamera.m_cameraMatrix.zy - (float)(z * (float)(v3 + v3))) * 0.57);
  return (unsigned int)(float)((float)((float)(v4 * (float)(v4 * (float)(v4 * (float)(v4 * (float)(v4 * v4))))) * 235.0)
                             + 20.0);
}

//----- (005AC0F4) --------------------------------------------------------
void __fastcall CGlass::GeneratePanesForWindow(
        UInt32 TypeOfAccident,
        CVector BaseCoors,
        CVector UpVec,
        CVector SideVec,
        CVector InitialSpeed,
        CVector CollisionPoint,
        float ExplodingForce,
        bool bShattered,
        int bExplosion,
        Int32 NumberMultiplier,
        bool bArgWindScreen)
{
  float32x2_t v11; // d0
  float32x2_t v12; // d1
  float32x2_t v13; // d2
  RwReal y; // r9
  float x; // r5
  unsigned int v17; // r4
  unsigned int v18; // r6
  float z; // r10
  float v20; // s0
  float v21; // s2
  unsigned int v22; // r0
  unsigned int v23; // r1
  float GroundZFor3DCoord; // s4
  float v25; // s17
  unsigned int v26; // r1
  unsigned int v27; // r0
  int v28; // r6
  float v29; // s31
  bool *p_bWindScreen; // r9
  int v31; // r0
  float *v32; // r4
  float v33; // s0
  float v34; // s2
  float v35; // s22
  char v36; // r0
  RwReal v37; // s2
  RwReal v38; // s4
  float v39; // s4
  float v40; // s2
  float v41; // s22
  float v42; // s16
  char v43; // r0
  unsigned int v44; // r0
  float v45; // [sp+4h] [bp-104h]
  float v46; // [sp+8h] [bp-100h]
  unsigned int v47; // [sp+Ch] [bp-FCh]
  unsigned int v48; // [sp+10h] [bp-F8h]
  unsigned int v49; // [sp+14h] [bp-F4h]
  float v50; // [sp+18h] [bp-F0h]
  float v51; // [sp+1Ch] [bp-ECh]
  unsigned int v52; // [sp+20h] [bp-E8h]
  float v53; // [sp+60h] [bp-A8h]
  float v54; // [sp+6Ch] [bp-9Ch]
  float *v55; // [sp+74h] [bp-94h]
  CVector v56; // [sp+78h] [bp-90h] BYREF
  bool pBool; // [sp+8Bh] [bp-7Dh] BYREF
  CVector v58; // [sp+8Ch] [bp-7Ch] BYREF
  CVector v59; // [sp+98h] [bp-70h] BYREF

  y = BaseCoors.y;
  x = BaseCoors.x;
  v17 = 3;
  v18 = 3;
  z = BaseCoors.z;
  v46 = sqrtf((float)(UpVec.z * UpVec.z) + (float)((float)(UpVec.x * UpVec.x) + (float)(UpVec.y * UpVec.y)));
  v12.n64_u32[0] = 1.0;
  v51 = sqrtf((float)(SideVec.z * SideVec.z) + (float)((float)(SideVec.x * SideVec.x) + (float)(SideVec.y * SideVec.y)));
  v13.n64_f32[0] = v46 + 0.75;
  v11.n64_f32[0] = v51 + 0.75;
  v20 = vmax_f32(v11, v12).n64_f32[0];
  v21 = vmax_f32(v13, v12).n64_f32[0];
  v22 = (unsigned int)v20 * NumberMultiplier;
  v23 = NumberMultiplier * (unsigned int)v21;
  if ( v22 < 3 )
    v17 = (unsigned int)v20 * NumberMultiplier;
  if ( v23 < 3 )
    v18 = NumberMultiplier * (unsigned int)v21;
  if ( bExplosion == 1 )
  {
    if ( v18 )
      v23 = 1;
    if ( v17 )
      v22 = 1;
    v18 = v23;
    v17 = v22;
  }
  GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(x, BaseCoors.y, BaseCoors.z, &pBool, 0);
  v50 = (float)v17;
  v45 = (float)v18;
  if ( !pBool )
    GroundZFor3DCoord = z + -2.0;
  v54 = GroundZFor3DCoord;
  if ( v18 )
  {
    v49 = v17;
    v47 = v18;
    v25 = v46 / v45;
    v53 = y;
    v48 = 0;
    v26 = v17;
    do
    {
      if ( !v26 )
        goto LABEL_34;
      v27 = 0;
      do
      {
        v52 = v27;
        v28 = 0;
        v29 = (float)(v51 * (float)v27) / v50;
        do
        {
          p_bWindScreen = &CGlass::aGlassPanes[0].bWindScreen;
          v31 = -1;
          while ( *(p_bWindScreen - 2) )
          {
            ++v31;
            p_bWindScreen += 112;
            if ( v31 >= 44 )
              goto LABEL_32;
          }
          if ( p_bWindScreen != (_BYTE *)&dword_6C + 3 )
          {
            *(p_bWindScreen - 3) = v28;
            *(float *)(p_bWindScreen - 111) = (float)((float)(v51 / v50) * SideVec.x) / v51;
            *(float *)(p_bWindScreen - 107) = (float)((float)(v51 / v50) * SideVec.y) / v51;
            *(float *)(p_bWindScreen - 103) = (float)((float)(v51 / v50) * SideVec.z) / v51;
            *(float *)(p_bWindScreen - 79) = (float)((float)(v46 / v45) * UpVec.x) / v46;
            *(float *)(p_bWindScreen - 75) = (float)((float)(v46 / v45) * UpVec.y) / v46;
            *(float *)(p_bWindScreen - 71) = (float)((float)(v46 / v45) * UpVec.z) / v46;
            CrossProduct(&v56, (const CVector *)(p_bWindScreen - 111), (const CVector *)(p_bWindScreen - 79));
            v59 = v56;
            CVector::Normalise(&v59);
            *(CVector *)(p_bWindScreen - 95) = v59;
            v32 = (float *)(p_bWindScreen - 55);
            v55 = (float *)(p_bWindScreen - 59);
            v33 = (float)((float)(v46 * (float)v48) / v45)
                + (float)(v25 * *(float *)((char *)CentersWithTriangle + ((8 * v28) | 4)));
            v34 = v29 + (float)((float)(v51 / v50) * CentersWithTriangle[2 * v28]);
            *(float *)(p_bWindScreen - 59) = (float)((float)((float)(UpVec.y / v46) * v33) + v53)
                                           + (float)((float)(SideVec.y / v51) * v34);
            *(float *)(p_bWindScreen - 63) = (float)((float)((float)(UpVec.x / v46) * v33) + x)
                                           + (float)((float)(SideVec.x / v51) * v34);
            *(float *)(p_bWindScreen - 55) = (float)((float)((float)(UpVec.z / v46) * v33) + z)
                                           + (float)((float)(SideVec.z / v51) * v34);
            v35 = (float)((rand() & 0x7F) - 64);
            v36 = rand();
            *(float *)(p_bWindScreen - 31) = InitialSpeed.z + 0.0;
            *(float *)(p_bWindScreen - 39) = (float)(v35 * 0.0015) + InitialSpeed.x;
            *(float *)(p_bWindScreen - 35) = (float)((float)((v36 & 0x7F) - 64) * 0.0015) + InitialSpeed.y;
            if ( ExplodingForce != 0.0 )
            {
              v37 = *v55 - CollisionPoint.y;
              v38 = *v32 - CollisionPoint.z;
              v58.x = *(float *)(p_bWindScreen - 63) - CollisionPoint.x;
              v58.y = v37;
              v58.z = v38;
              CVector::Normalise(&v58);
              v39 = v58.z;
              v40 = v58.y * ExplodingForce;
              *(float *)(p_bWindScreen - 39) = (float)(v58.x * ExplodingForce) + *(float *)(p_bWindScreen - 39);
              *(float *)(p_bWindScreen - 35) = v40 + *(float *)(p_bWindScreen - 35);
              *(float *)(p_bWindScreen - 31) = (float)(v39 * ExplodingForce) + *(float *)(p_bWindScreen - 31);
            }
            v41 = (float)((rand() & 0x7F) - 64);
            v42 = (float)((rand() & 0x7F) - 64);
            v43 = rand();
            *(float *)(p_bWindScreen - 27) = v41 * 0.002;
            *(float *)(p_bWindScreen - 23) = v42 * 0.002;
            *(float *)(p_bWindScreen - 19) = (float)((v43 & 0x7F) - 64) * 0.002;
            switch ( TypeOfAccident )
            {
              case 2u:
LABEL_28:
                v44 = CTimer::m_snTimeInMilliseconds;
                break;
              case 1u:
                v44 = (unsigned int)(float)((float)(sqrtf(
                                                      (float)((float)((float)(*(float *)(p_bWindScreen - 63)
                                                                            - CollisionPoint.x)
                                                                    * (float)(*(float *)(p_bWindScreen - 63)
                                                                            - CollisionPoint.x))
                                                            + (float)((float)(*v55 - CollisionPoint.y)
                                                                    * (float)(*v55 - CollisionPoint.y)))
                                                    + (float)((float)(*v32 - CollisionPoint.z)
                                                            * (float)(*v32 - CollisionPoint.z)))
                                                  * 100.0)
                                          + (float)CTimer::m_snTimeInMilliseconds);
                break;
              case 0u:
                goto LABEL_28;
              default:
LABEL_31:
                *(p_bWindScreen - 1) = bShattered;
                *(p_bWindScreen - 2) = 1;
                *p_bWindScreen = bArgWindScreen;
                *(float *)(p_bWindScreen - 7) = v25;
                *(float *)(p_bWindScreen - 11) = v54;
                goto LABEL_32;
            }
            *(_DWORD *)(p_bWindScreen - 15) = v44;
            goto LABEL_31;
          }
LABEL_32:
          ++v28;
        }
        while ( v28 != 5 );
        v26 = v49;
        v27 = v52 + 1;
      }
      while ( v52 + 1 != v49 );
LABEL_34:
      ++v48;
    }
    while ( v48 != v47 );
  }
}
// 5AC172: variable 'v11' is possibly undefined
// 5AC172: variable 'v12' is possibly undefined
// 5AC176: variable 'v13' is possibly undefined
// 6C: using guessed type int dword_6C;

//----- (005AC684) --------------------------------------------------------
void __fastcall CGlass::AskForObjectToBeRenderedInGlass(CEntity *pEntity)
{
  uint32 v1; // r1

  v1 = CGlass::NumGlassEntities;
  if ( CGlass::NumGlassEntities <= 0x1E )
  {
    CGlass::apEntitiesToBeRendered[CGlass::NumGlassEntities] = pEntity;
    CGlass::NumGlassEntities = v1 + 1;
  }
}

//----- (005AC6B4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CGlass::WindowRespondsToCollision(
        CEntity *pEntity,
        float ImpulsMagnitude,
        CVector OtherGuysSpeed,
        CVector CollisionCoors,
        int bExplosion)
{
  float32x2_t v5; // d2
  float32x2_t v6; // d3
  float32x2_t v7; // d5
  float32x2_t v8; // d7
  float32x2_t v9; // d8
  float32x2_t v10; // d9
  RwObject_0 *m_pRwObject; // r0
  __int64 v13; // r8
  unsigned int v15; // r0
  int m_nModelIndex; // r2
  CCollisionData *m_pColData; // r1
  CollisionVector *m_pTriCompressedVectorArray; // r0
  int v19; // r6
  double v20; // d16
  double v21; // d16
  CollisionVector *v22; // r0
  double v23; // d16
  float32x2_t v24; // d18
  CMatrix *m_pMat; // r1
  float v26; // s16
  float v27; // s18
  float v28; // s4
  float v29; // s8
  RwReal v30; // r0
  RwReal v31; // r2
  CMatrix *v32; // r1
  RwReal v33; // r0
  CMatrix *v34; // r1
  CSimpleTransform *p_tx; // r2
  int m_nFlags; // r1
  CVector UpVec; // [sp+0h] [bp-D0h]
  CVector SideVec; // [sp+Ch] [bp-C4h]
  CVector InitialSpeed; // [sp+18h] [bp-B8h]
  CVector v40; // [sp+44h] [bp-8Ch] BYREF
  CVector v; // [sp+50h] [bp-80h] BYREF
  CVector v42; // [sp+5Ch] [bp-74h] BYREF
  double v43; // [sp+68h] [bp-68h] BYREF
  unsigned __int32 z_low; // [sp+70h] [bp-60h]
  double v45; // [sp+74h] [bp-5Ch]
  unsigned __int32 v46; // [sp+7Ch] [bp-54h]
  double v47; // [sp+80h] [bp-50h]
  unsigned __int32 v48; // [sp+88h] [bp-48h]
  double v49; // [sp+8Ch] [bp-44h]
  unsigned __int32 v50; // [sp+94h] [bp-3Ch]

  m_pRwObject = pEntity[5].m_pRwObject;
  v13 = *(_QWORD *)&OtherGuysSpeed.x;
  if ( ((unsigned __int8)m_pRwObject & 0x20) == 0 )
  {
    v15 = (unsigned int)m_pRwObject | 0x10;
    m_nModelIndex = pEntity->m_nModelIndex;
    pEntity[5].m_pRwObject = (RwObject_0 *)v15;
    m_pColData = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel->m_pColData;
    if ( m_pColData && m_pColData->m_nNoOfTriangles == 2 )
    {
      m_pTriCompressedVectorArray = m_pColData->m_pTriCompressedVectorArray;
      v19 = 1;
      v20 = *(double *)&m_pTriCompressedVectorArray->x;
      z_low = LODWORD(m_pTriCompressedVectorArray->z);
      v43 = v20;
      v21 = *(double *)&m_pTriCompressedVectorArray[1].x;
      v46 = LODWORD(m_pTriCompressedVectorArray[1].z);
      v45 = v21;
      v22 = m_pColData->m_pTriCompressedVectorArray;
      v23 = *(double *)&v22[2].x;
      v48 = LODWORD(v22[2].z);
      v47 = v23;
      v5.n64_u32[0] = z_low;
      v50 = LODWORD(v22[3].z);
      v8.n64_u32[0] = v50;
      v49 = *(double *)&v22[3].x;
      v9.n64_u32[0] = v46;
      v10.n64_u32[0] = v48;
      v24.n64_u64[0] = vmin_f32(v5, v9).n64_u64[0];
      m_pMat = pEntity->m_pMat;
      LODWORD(v26) = vmax_f32(vmax_f32(v5, v9), vmax_f32(v10, v8)).n64_u32[0];
      LODWORD(v27) = vmin_f32(v24, vmin_f32(v10, v8)).n64_u32[0];
      v7.n64_f32[0] = sqrtf(
                        (float)((float)(*(float *)&v23 - *(float *)&v43) * (float)(*(float *)&v23 - *(float *)&v43))
                      + (float)((float)(*((float *)&v23 + 1) - *((float *)&v43 + 1))
                              * (float)(*((float *)&v23 + 1) - *((float *)&v43 + 1))));
      v6.n64_f32[0] = sqrtf(
                        (float)((float)(*(float *)&v45 - *(float *)&v43) * (float)(*(float *)&v45 - *(float *)&v43))
                      + (float)((float)(*((float *)&v45 + 1) - *((float *)&v43 + 1))
                              * (float)(*((float *)&v45 + 1) - *((float *)&v43 + 1))));
      LODWORD(v28) = vmax_f32(v7, v6).n64_u32[0];
      v29 = sqrtf(
              (float)((float)(*(float *)&v49 - *(float *)&v43) * (float)(*(float *)&v49 - *(float *)&v43))
            + (float)((float)(*((float *)&v49 + 1) - *((float *)&v43 + 1))
                    * (float)(*((float *)&v49 + 1) - *((float *)&v43 + 1))));
      if ( v7.n64_f32[0] > v6.n64_f32[0] )
        v19 = 2;
      if ( v29 > v28 )
        v19 = 3;
      if ( m_pMat )
      {
        v31 = *((float *)&v43 + 1);
        v30 = *(float *)&v43;
      }
      else
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v31 = *((float *)&v43 + 1);
        v30 = *(float *)&v43;
        m_pMat = pEntity->m_pMat;
      }
      v.x = v30;
      v.y = v31;
      v.z = v27;
      operator*(&v42, m_pMat, &v);
      v32 = pEntity->m_pMat;
      if ( !v32 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v32 = pEntity->m_pMat;
      }
      v33 = *((float *)&v43 + 3 * v19 + 1);
      v40.x = *((RwReal *)&v43 + 3 * v19);
      v40.y = v33;
      v40.z = v27;
      operator*(&v, v32, &v40);
      v34 = pEntity->m_pMat;
      p_tx = (CSimpleTransform *)&v34->tx;
      if ( !v34 )
        p_tx = &pEntity->m_transform;
      CAudioEngine::ReportGlassCollisionEvent(&AudioEngine, 126, &p_tx->m_translate);
      *(_QWORD *)&InitialSpeed.x = v13;
      *(_QWORD *)&UpVec.x = 0LL;
      InitialSpeed.z = OtherGuysSpeed.z;
      SideVec.z = v.z - v42.z;
      UpVec.z = v26 - v27;
      SideVec.x = v.x - v42.x;
      SideVec.y = v.y - v42.y;
      CGlass::GeneratePanesForWindow(
        ImpulsMagnitude <= 300.0,
        v42,
        UpVec,
        SideVec,
        InitialSpeed,
        CollisionCoors,
        0.1,
        ((int)pEntity[5].m_pRwObject & 0x10) != 0,
        bExplosion,
        1,
        0);
      v15 = (unsigned int)pEntity[5].m_pRwObject;
    }
    m_nFlags = (int)pEntity->m_nFlags;
    pEntity[5].m_pRwObject = (RwObject_0 *)(v15 | 0x20);
    *(_DWORD *)&pEntity->m_nFlags = m_nFlags & 0xFFFFFF7E;
  }
}
// 5AC6B4: fragmented variable at 0:r2.8,8:^D8.4 may be wrong
// 5AC6B4: variables would overlap: 0:r2.8,8:^D8.4 and ^D8.4

//----- (005AC974) --------------------------------------------------------
void __fastcall CGlass::WindowRespondsToSoftCollision(CEntity *pEntity, float ImpulsMagnitude)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2

  if ( ImpulsMagnitude > 50.0 && (*(_DWORD *)&pEntity->m_nFlags & 1) != 0 && ((int)pEntity[5].m_pRwObject & 0x10) == 0 )
  {
    m_pMat = pEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pEntity->m_transform;
    CAudioEngine::ReportGlassCollisionEvent(&AudioEngine, 123, &p_tx->m_translate);
    pEntity[5].m_pRwObject = (RwObject_0 *)((int)pEntity[5].m_pRwObject | 0x10);
  }
}

//----- (005AC9CC) --------------------------------------------------------
void __fastcall CGlass::WasGlassHitByBullet(CEntity *pEntity, CVector CoorsOfImpact)
{
  RwReal z; // r8
  RwReal y; // r6
  RwReal x; // r5
  CBaseModelInfo *v6; // r0
  int v7; // r0
  RwObject_0 *m_pRwObject; // r0
  CVector v9; // [sp+4h] [bp-24h]
  CVector v10; // 0:r2.8,8:^0.4

  z = CoorsOfImpact.z;
  y = CoorsOfImpact.y;
  x = CoorsOfImpact.x;
  if ( (*(_BYTE *)&pEntity->m_info & 7) == 4 )
  {
    v6 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex];
    v7 = (*((int (__fastcall **)(CBaseModelInfo *))v6->_vptr$CBaseModelInfo + 2))(v6);
    if ( v7 )
    {
      if ( (*(_WORD *)(v7 + 40) & 0x7000 | 0x800) == 10240 && *(_BYTE *)&pEntity->m_nFlags << 31 )
      {
        m_pRwObject = pEntity[5].m_pRwObject;
        if ( ((unsigned __int8)m_pRwObject & 0x10) != 0 )
        {
          if ( (rand() & 3) == 2 )
          {
            v10.z = 0.0;
            v9.x = x;
            *(_QWORD *)&v9.y = __PAIR64__(LODWORD(z), LODWORD(y));
            *(_QWORD *)&v10.x = 0LL;
            CGlass::WindowRespondsToCollision(pEntity, 0.0, v10, v9, 0);
          }
        }
        else
        {
          pEntity[5].m_pRwObject = (RwObject_0 *)((unsigned int)m_pRwObject | 0x10);
        }
      }
    }
  }
}

//----- (005ACA58) --------------------------------------------------------
void __fastcall CGlass::WindowRespondsToExplosion(CEntity *pEntity, CVector CoorsOfExplosion)
{
  CMatrix *m_pMat; // r12
  float y; // s6
  RwReal v4; // s0
  float v5; // s2
  float v6; // s10
  float v7; // s4
  float v8; // s6
  float v9; // s8
  float v10; // s12
  float v11; // s12
  CVector v12; // [sp+4h] [bp-1Ch]
  CVector v13; // 0:r2.8,8:^0.4

  if ( *(_BYTE *)&pEntity->m_nFlags << 31 )
  {
    m_pMat = pEntity->m_pMat;
    y = CoorsOfExplosion.y;
    LODWORD(CoorsOfExplosion.y) = &m_pMat->tx;
    if ( !m_pMat )
      LODWORD(CoorsOfExplosion.y) = &pEntity->m_transform;
    v4 = *(float *)LODWORD(CoorsOfExplosion.y);
    v5 = *(float *)(LODWORD(CoorsOfExplosion.y) + 4);
    v6 = *(float *)LODWORD(CoorsOfExplosion.y) - CoorsOfExplosion.x;
    v7 = *(float *)(LODWORD(CoorsOfExplosion.y) + 8);
    v8 = v5 - y;
    v9 = v7 - CoorsOfExplosion.z;
    v10 = sqrtf((float)((float)(v6 * v6) + (float)(v8 * v8)) + (float)(v9 * v9));
    if ( v10 >= 10.0 )
    {
      if ( v10 < 30.0 )
        pEntity[5].m_pRwObject = (RwObject_0 *)((int)pEntity[5].m_pRwObject | 0x10);
    }
    else
    {
      v11 = 0.3 / v10;
      v13.x = v6 * v11;
      v13.y = v8 * v11;
      v13.z = v9 * v11;
      v12.x = v4;
      *(_QWORD *)&v12.y = __PAIR64__(LODWORD(v7), LODWORD(v5));
      CGlass::WindowRespondsToCollision(pEntity, 10000.0, v13, v12, 1);
    }
  }
}

//----- (005ACB24) --------------------------------------------------------
void __fastcall CGlass::CarWindscreenShatters(CVehicle *pVehicle, bool bExplosion)
{
  float32x2_t v2; // d7
  float32x2_t v3; // d8
  float32x2_t v4; // d10
  float32x2_t v5; // d11
  float32x2_t v6; // d12
  float32x2_t v7; // d13
  float32x2_t v8; // d14
  float32x2_t v9; // d15
  CCollisionData *m_pColData; // r4
  int v11; // r5
  CColTriangle *v12; // r10
  int v13; // r9
  CColTriangle *m_pTriangleArray; // r8
  CColTriangle *v15; // r6
  CColTrianglePlane *m_pTrianglePlaneArray; // r0
  CColTrianglePlane *v17; // r0
  __int64 v18; // d16
  CollisionVector *m_pTriCompressedVectorArray; // r1
  CollisionVector *v20; // r0
  __int64 v21; // d16
  CollisionVector *v22; // r0
  __int64 v23; // d16
  int v24; // r0
  __int64 v25; // d16
  int v26; // r0
  __int64 v27; // d16
  int v28; // r0
  __int64 v29; // d16
  int v30; // r0
  __int64 v31; // d16
  int v32; // r5
  unsigned __int64 v33; // d2
  unsigned __int64 v34; // d3
  float32x2_t v35; // d4
  unsigned __int64 v36; // d1
  float32x2_t v37; // d3
  float32x2_t v38; // d2
  float32x2_t v39; // d5
  float32x2_t v40; // d6
  float v41; // s0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float v44; // s19
  float v45; // s18
  float v46; // s0
  float v47; // s4
  CVector v48; // [sp+0h] [bp-180h]
  CVector v49; // [sp+Ch] [bp-174h]
  CVector v50; // [sp+24h] [bp-15Ch]
  float32x2_t v51; // [sp+48h] [bp-138h]
  float32x2_t v52; // [sp+50h] [bp-130h]
  float32x2_t v53; // [sp+58h] [bp-128h]
  CColModel *pModel; // [sp+68h] [bp-118h]
  float32x2_t pModela; // [sp+68h] [bp-118h]
  __int16 v57; // [sp+70h] [bp-110h]
  float32x2_t v58; // [sp+70h] [bp-110h]
  float v59[6]; // [sp+78h] [bp-108h]
  CVector v60; // [sp+90h] [bp-F0h] BYREF
  float v61; // [sp+9Ch] [bp-E4h]
  float v62; // [sp+A0h] [bp-E0h]
  float v63; // [sp+A4h] [bp-DCh]
  CVector v64; // [sp+A8h] [bp-D8h] BYREF
  CVector v65; // [sp+B8h] [bp-C8h] BYREF
  CVector v; // [sp+C8h] [bp-B8h] BYREF
  CVector v67; // [sp+D8h] [bp-A8h] BYREF
  CVector v68; // [sp+E4h] [bp-9Ch] BYREF
  CVector v69; // [sp+F0h] [bp-90h] BYREF
  CVector v70; // [sp+FCh] [bp-84h] BYREF
  CVector v71; // [sp+108h] [bp-78h] BYREF
  CVector v72; // [sp+114h] [bp-6Ch] BYREF
  CVector v73; // 0:r1.12

  pModel = CEntity::GetColModel(pVehicle);
  m_pColData = pModel->m_pColData;
  if ( !m_pColData || m_pColData->m_nNoOfTriangles < 2 )
    return;
  v11 = 0;
  v57 = -1;
  v12 = 0;
  v13 = 0;
  while ( !SurfaceInfos_c::IsGlass(&g_surfaceInfos, m_pColData->m_pTriangleArray[v11].m_nSurfaceType) )
  {
LABEL_7:
    ++v13;
    ++v11;
    if ( v13 >= m_pColData->m_nNoOfTriangles )
      return;
  }
  m_pTriangleArray = m_pColData->m_pTriangleArray;
  v15 = &m_pTriangleArray[v11];
  if ( !v12 )
  {
    v12 = &m_pTriangleArray[v11];
    v57 = v13;
    goto LABEL_7;
  }
  if ( v15 )
  {
    CCollision::CalculateTrianglePlanes(pModel);
    m_pTrianglePlaneArray = m_pColData->m_pTrianglePlaneArray;
    if ( m_pTrianglePlaneArray )
    {
      v17 = &m_pTrianglePlaneArray[v57];
      v18 = *(_QWORD *)&v17->m_compressedNormal.x;
      v.z = v17->m_compressedNormal.z;
      *(_QWORD *)&v.x = v18;
      Multiply3x3(&v67, pVehicle->m_pMat, &v);
      v = v67;
      CrossProduct(&v67, (const CVector *)pVehicle->m_pMat, &v);
      v65 = v67;
      CVector::Normalise(&v65);
      CrossProduct(&v67, &v, (const CVector *)&pVehicle->m_pMat->xz);
      v64 = v67;
      CVector::Normalise(&v64);
      m_pTriCompressedVectorArray = m_pColData->m_pTriCompressedVectorArray;
      v20 = &m_pTriCompressedVectorArray[v12->m_nIndex1];
      v21 = *(_QWORD *)&v20->x;
      v67.z = v20->z;
      *(_QWORD *)&v67.x = v21;
      v22 = &m_pTriCompressedVectorArray[v12->m_nIndex2];
      v23 = *(_QWORD *)&v22->x;
      v68.z = v22->z;
      *(_QWORD *)&v68.x = v23;
      v24 = (int)&m_pColData->m_pTriCompressedVectorArray[v12->m_nIndex3];
      v25 = *(_QWORD *)v24;
      v69.z = *(RwReal *)(v24 + 8);
      *(_QWORD *)&v69.x = v25;
      v26 = (int)&m_pColData->m_pTriCompressedVectorArray[m_pTriangleArray[v11].m_nIndex1];
      v27 = *(_QWORD *)v26;
      v70.z = *(RwReal *)(v26 + 8);
      *(_QWORD *)&v70.x = v27;
      v28 = (int)&m_pColData->m_pTriCompressedVectorArray[v15->m_nIndex2];
      v29 = *(_QWORD *)v28;
      v71.z = *(RwReal *)(v28 + 8);
      *(_QWORD *)&v71.x = v29;
      v30 = (int)&m_pColData->m_pTriCompressedVectorArray[v15->m_nIndex3];
      v31 = *(_QWORD *)v30;
      v72.z = *(RwReal *)(v30 + 8);
      *(_QWORD *)&v72.x = v31;
      operator*(&v60, pVehicle->m_pMat, &v67);
      v67 = v60;
      operator*(&v60, pVehicle->m_pMat, &v68);
      v68 = v60;
      operator*(&v60, pVehicle->m_pMat, &v69);
      v69 = v60;
      operator*(&v60, pVehicle->m_pMat, &v70);
      v70 = v60;
      operator*(&v60, pVehicle->m_pMat, &v71);
      v71 = v60;
      operator*(&v60, pVehicle->m_pMat, &v72);
      v32 = 0;
      v72 = v60;
      HIDWORD(v33) = LODWORD(v64.z);
      v35.n64_f32[1] = v68.x * v65.x;
      *((float *)&v34 + 1) = (float)(v68.x * v65.x) + (float)(v68.y * v65.y);
      v60.x = (float)((float)(v67.x * v65.x) + (float)(v67.y * v65.y)) + (float)(v67.z * v65.z);
      v3.n64_f32[0] = *((float *)&v34 + 1) + (float)(v68.z * v65.z);
      v60.y = v3.n64_f32[0];
      v52.n64_u64[0] = v3.n64_u64[0];
      *(float *)&v34 = (float)((float)(v68.x * v64.x) + (float)(v68.y * v64.y)) + (float)(v68.z * v64.z);
      v59[0] = (float)((float)(v67.x * v64.x) + (float)(v67.y * v64.y)) + (float)(v67.z * v64.z);
      v59[1] = *(float *)&v34;
      pModela.n64_u64[0] = v34;
      v9.n64_f32[0] = (float)((float)(v69.x * v65.x) + (float)(v69.y * v65.y)) + (float)(v69.z * v65.z);
      v8.n64_f32[0] = (float)((float)(v69.x * v64.x) + (float)(v69.y * v64.y)) + (float)(v69.z * v64.z);
      v37.n64_f32[1] = v70.z * v65.z;
      LODWORD(v60.z) = v9.n64_u32[0];
      v59[2] = v8.n64_f32[0];
      v7.n64_f32[0] = (float)((float)(v70.x * v65.x) + (float)(v70.y * v65.y)) + (float)(v70.z * v65.z);
      v6.n64_f32[0] = (float)((float)(v70.x * v64.x) + (float)(v70.y * v64.y)) + (float)(v70.z * v64.z);
      v61 = v7.n64_f32[0];
      v59[3] = v6.n64_f32[0];
      v4.n64_f32[0] = (float)((float)(v71.x * v65.x) + (float)(v71.y * v65.y)) + (float)(v71.z * v65.z);
      v2.n64_f32[0] = (float)((float)(v71.x * v64.x) + (float)(v71.y * v64.y)) + (float)(v71.z * v64.z);
      v62 = v4.n64_f32[0];
      v59[4] = v2.n64_f32[0];
      v58.n64_u64[0] = v2.n64_u64[0];
      v2.n64_f32[0] = v4.n64_f32[0] + v2.n64_f32[0];
      v35.n64_f32[0] = v7.n64_f32[0] + v6.n64_f32[0];
      v5.n64_f32[0] = (float)((float)(v72.x * v65.x) + (float)(v72.y * v65.y)) + (float)(v72.z * v65.z);
      v63 = v5.n64_f32[0];
      v37.n64_f32[0] = v60.x;
      v51.n64_u64[0] = v37.n64_u64[0];
      v3.n64_f32[0] = (float)((float)(v72.x * v64.x) + (float)(v72.y * v64.y)) + (float)(v72.z * v64.z);
      HIDWORD(v36) = pModela.n64_u32[1];
      v59[5] = v3.n64_f32[0];
      *(float *)&v33 = v59[0];
      *(float *)&v36 = v60.x + v59[0];
      v53.n64_u64[0] = v33;
      v37.n64_f32[0] = v9.n64_f32[0] + v8.n64_f32[0];
      v38.n64_u64[0] = v36;
      if ( (float)(v52.n64_f32[0] + pModela.n64_f32[0]) < (float)(v60.x + v59[0]) )
        v38.n64_f32[0] = v52.n64_f32[0] + pModela.n64_f32[0];
      v39.n64_u64[0] = vmin_f32(v37, v38).n64_u64[0];
      v40.n64_u64[0] = vmin_f32(v35, v39).n64_u64[0];
      LODWORD(v41) = vmin_f32(v2, v40).n64_u32[0];
      if ( (float)(v52.n64_f32[0] + pModela.n64_f32[0]) < *(float *)&v36 )
        v32 = 1;
      m_pMat = pVehicle->m_pMat;
      if ( v37.n64_f32[0] < v38.n64_f32[0] )
        v32 = 2;
      if ( v35.n64_f32[0] < v39.n64_f32[0] )
        v32 = 3;
      if ( v2.n64_f32[0] < v40.n64_f32[0] )
        v32 = 4;
      if ( (float)(v5.n64_f32[0] + v3.n64_f32[0]) < v41 )
        v32 = 5;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      v44 = v59[v32];
      v45 = *(&v60.x + v32);
      if ( !m_pMat )
        p_tx = &pVehicle->m_transform;
      CAudioEngine::ReportGlassCollisionEvent(&AudioEngine, 126, &p_tx->m_translate);
      v73 = *(&v67 + v32);
      v46 = vmax_f32(v5, vmax_f32(v4, vmax_f32(v7, vmax_f32(v9, vmax_f32(v52, v51))))).n64_f32[0] - v45;
      v47 = vmax_f32(v3, vmax_f32(v58, vmax_f32(v6, vmax_f32(v8, vmax_f32(pModela, v53))))).n64_f32[0] - v44;
      v48.x = v46 * v65.x;
      v48.y = v46 * v65.y;
      v48.z = v46 * v65.z;
      v49.x = v47 * v64.x;
      v49.y = v47 * v64.y;
      v49.z = v47 * v64.z;
      v50.x = (float)((float)(v47 * 0.5) * v64.x) + (float)((float)((float)(v46 * 0.5) * v65.x) + v73.x);
      v50.y = (float)((float)(v47 * 0.5) * v64.y) + (float)((float)((float)(v46 * 0.5) * v65.y) + *(&v67.y + 3 * v32));
      v50.z = (float)((float)(v47 * 0.5) * v64.z) + (float)((float)((float)(v46 * 0.5) * v65.z) + *(&v67.z + 3 * v32));
      CGlass::GeneratePanesForWindow(2u, v73, v48, v49, pVehicle->m_vecMoveSpeed, v50, 0.1, 0, 0, 2, 1);
    }
  }
}
// 5ACDF0: variable 'v3' is possibly undefined
// 5ACEE0: variable 'v2' is possibly undefined
// 5AD002: variable 'v5' is possibly undefined
// 5ACFFE: variable 'v4' is possibly undefined
// 5ACFFA: variable 'v7' is possibly undefined
// 5ACFF2: variable 'v9' is possibly undefined
// 5AD006: variable 'v6' is possibly undefined
// 5ACFF6: variable 'v8' is possibly undefined

//----- (005AD0FC) --------------------------------------------------------
bool __fastcall CGlass::HasGlassBeenShatteredAtCoors(float CoorsX, float CoorsY, float CoorsZ)
{
  float v6; // s24
  float v7; // s26
  float v8; // s28
  float v9; // r5
  float v10; // r6
  float v11; // r4
  float v12; // r0
  int v13; // r2
  int v14; // s6
  int v15; // r5
  int v16; // s2
  int v17; // r4
  int v18; // r6
  uint16 v19; // r0
  float v20; // s22
  float v21; // s20
  int v22; // r0
  int v23; // r8
  int v24; // r1
  CPtrNode *m_pHead; // r6
  int v26; // r4
  CPtrNode v27; // kr00_8
  CBaseModelInfo *v28; // r0
  int v29; // r0
  int v30; // r1
  float *v31; // r0
  float v32; // s0
  CPtrNode *v33; // r4
  CPtrNode v34; // kr08_8
  CBaseModelInfo *v35; // r0
  int v36; // r0
  int v37; // r1
  float *v38; // r0
  float v39; // s0
  _BOOL4 v41; // r0
  int v43; // [sp+4h] [bp-84h]
  int v44; // [sp+8h] [bp-80h]
  int v45; // [sp+Ch] [bp-7Ch]
  int v46; // [sp+20h] [bp-68h]
  int v47; // [sp+24h] [bp-64h]
  int v48; // [sp+28h] [bp-60h]
  _BYTE *m_pVoid; // [sp+2Ch] [bp-5Ch]

  v6 = CoorsY + -30.0;
  v7 = CoorsY + 30.0;
  v8 = CoorsX + 30.0;
  v9 = floorf((float)((float)(CoorsX + -30.0) / 50.0) + 60.0);
  v10 = floorf((float)(v6 / 50.0) + 60.0);
  v11 = floorf((float)(v8 / 50.0) + 60.0);
  v12 = floorf((float)(v7 / 50.0) + 60.0);
  v13 = 119;
  v14 = (int)v9;
  v15 = 0;
  v16 = (int)v11;
  v17 = (int)v12;
  v18 = (int)v10;
  if ( (int)v12 >= 119 )
    v17 = 119;
  if ( v16 < 119 )
    v13 = v16;
  v48 = v13;
  if ( v18 <= 0 )
    v18 = 0;
  if ( v14 > 0 )
    v15 = v14;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v19 = 1;
  }
  else
  {
    v19 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v19;
  if ( v18 > v17 )
    goto LABEL_46;
  v20 = 20.0;
  m_pVoid = 0;
  v21 = CoorsZ;
  v43 = v15;
  v44 = v17;
  do
  {
    v45 = v18;
    if ( v15 <= v48 )
    {
      v22 = 119;
      if ( v18 < 119 )
        v22 = v18;
      v23 = v15;
      v47 = 120 * v22;
      v46 = (unsigned __int8)(16 * v18);
      do
      {
        v24 = 119;
        if ( v23 < 119 )
          v24 = v23;
        m_pHead = CWorld::ms_aRepeatSectors[v23 & 0xF | v46].m_ptrListArray[2].m_pHead;
        v26 = v24 + v47;
        while ( m_pHead )
        {
          v27 = *m_pHead;
          m_pHead = m_pHead->m_pNext;
          if ( (*((_BYTE *)v27.m_pVoid + 58) & 7) == 4 )
          {
            v28 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v27.m_pVoid + 19)];
            v29 = (*((int (__fastcall **)(CBaseModelInfo *))v28->_vptr$CBaseModelInfo + 2))(v28);
            if ( v29 )
            {
              if ( (*(_WORD *)(v29 + 40) & 0x7000 | 0x800) == 10240
                && *((unsigned __int16 *)v27.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v30 = *((_DWORD *)v27.m_pVoid + 5);
                *((_WORD *)v27.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v31 = (float *)(v30 + 48);
                if ( !v30 )
                  v31 = (float *)((char *)v27.m_pVoid + 4);
                v32 = sqrtf(
                        (float)((float)((float)(CoorsX - *v31) * (float)(CoorsX - *v31))
                              + (float)((float)(CoorsY - v31[1]) * (float)(CoorsY - v31[1])))
                      + (float)((float)(v21 - v31[2]) * (float)(v21 - v31[2])));
                if ( v32 < v20 )
                {
                  m_pVoid = v27.m_pVoid;
                  v20 = v32;
                }
              }
            }
          }
        }
        v33 = CWorld::ms_aSectors[v26].m_dummyPtrListArray.m_pHead;
        while ( v33 )
        {
          v34 = *v33;
          v33 = v33->m_pNext;
          if ( (*((_BYTE *)v34.m_pVoid + 58) & 7) == 4 )
          {
            v35 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v34.m_pVoid + 19)];
            v36 = (*((int (__fastcall **)(CBaseModelInfo *))v35->_vptr$CBaseModelInfo + 2))(v35);
            if ( v36 )
            {
              if ( (*(_WORD *)(v36 + 40) & 0x7000 | 0x800) == 10240
                && *((unsigned __int16 *)v34.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v37 = *((_DWORD *)v34.m_pVoid + 5);
                *((_WORD *)v34.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v38 = (float *)(v37 + 48);
                if ( !v37 )
                  v38 = (float *)((char *)v34.m_pVoid + 4);
                v39 = sqrtf(
                        (float)((float)((float)(CoorsX - *v38) * (float)(CoorsX - *v38))
                              + (float)((float)(CoorsY - v38[1]) * (float)(CoorsY - v38[1])))
                      + (float)((float)(v21 - v38[2]) * (float)(v21 - v38[2])));
                if ( v39 < v20 )
                {
                  m_pVoid = v34.m_pVoid;
                  v20 = v39;
                }
              }
            }
          }
        }
      }
      while ( v23++ < v48 );
    }
    v15 = v43;
    v18 = v45 + 1;
  }
  while ( v45 < v44 );
  if ( m_pVoid )
  {
    if ( (m_pVoid[58] & 7) == 5 )
      LOBYTE(v41) = 0;
    else
      return ((unsigned __int8)m_pVoid[324] >> 5) & 1;
  }
  else
  {
LABEL_46:
    LOBYTE(v41) = 0;
  }
  return v41;
}

//----- (005AD424) --------------------------------------------------------
void __fastcall CGlass::FindWindowSectorList(
        CPtrList *list,
        float *pClosestDist,
        CEntity **ppNearestGlassEnt,
        float CoorsX,
        float CoorsY,
        float CoorsZ)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v10; // kr00_8
  CBaseModelInfo *v11; // r0
  int v12; // r0
  int v13; // r1
  float *v14; // r0
  float v15; // s0

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v10 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( (*((_BYTE *)v10.m_pVoid + 58) & 7) == 4 )
    {
      v11 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v10.m_pVoid + 19)];
      v12 = (*((int (__fastcall **)(CBaseModelInfo *))v11->_vptr$CBaseModelInfo + 2))(v11);
      if ( v12 )
      {
        if ( (*(_WORD *)(v12 + 40) & 0x7000 | 0x800) == 10240
          && *((unsigned __int16 *)v10.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
        {
          v13 = *((_DWORD *)v10.m_pVoid + 5);
          *((_WORD *)v10.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
          v14 = (float *)(v13 + 48);
          if ( !v13 )
            v14 = (float *)((char *)v10.m_pVoid + 4);
          v15 = sqrtf(
                  (float)((float)((float)(CoorsX - *v14) * (float)(CoorsX - *v14))
                        + (float)((float)(CoorsY - v14[1]) * (float)(CoorsY - v14[1])))
                + (float)((float)(CoorsZ - v14[2]) * (float)(CoorsZ - v14[2])));
          if ( v15 < *pClosestDist )
          {
            *pClosestDist = v15;
            *ppNearestGlassEnt = (CEntity *)v10.m_pVoid;
          }
        }
      }
    }
  }
}

//----- (005AD4F8) --------------------------------------------------------
void __fastcall CGlass::BreakGlassPhysically(CVector Coors, float Radius)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d15
  RwReal x; // r11
  RwReal y; // r9
  RwReal z; // r8
  CObjectPool *v9; // r6
  int32 m_nSize; // r2
  float v11; // s16
  float v12; // s18
  float v13; // s20
  int v14; // r5
  CBaseModelInfo *v15; // r0
  int v16; // r0
  CColModel *m_pColModel; // r0
  CCollisionData *m_pColData; // r10
  float *v19; // r1
  int v20; // r6
  float *v21; // r2
  float v22; // s0
  float v23; // s2
  float v24; // s4
  int v25; // r8
  int v26; // r11
  int v27; // r4
  int v28; // r9
  _DWORD *v29; // r6
  CVector *v30; // r2
  CollisionVector *m_pTriCompressedVectorArray; // r0
  double v32; // d16
  __int64 v33; // d16
  __int64 v34; // d16
  __int64 v35; // d16
  const CMatrix *v36; // r1
  float v37; // s28
  float v38; // s26
  float v39; // s22
  __int64 v40; // kr08_8
  __int64 v41; // kr10_8
  int v42; // r0
  const CMatrix *v43; // r1
  float v44; // s6
  float v45; // s4
  int v46; // r0
  RwReal v47; // r2
  RwReal v48; // r0
  CVector *p_tx; // r2
  CVector UpVec; // [sp+0h] [bp-170h]
  CVector v51; // [sp+Ch] [bp-164h]
  CVector InitialSpeed; // [sp+18h] [bp-158h] BYREF
  float32x2_t v53; // [sp+48h] [bp-128h]
  float32x2_t v54; // [sp+50h] [bp-120h]
  float32x2_t v55; // [sp+58h] [bp-118h]
  CVector CollisionPoint; // [sp+64h] [bp-10Ch]
  const CMatrix **v57; // [sp+70h] [bp-100h]
  CObjectPool *v58; // [sp+9Ch] [bp-D4h]
  int32 v59; // [sp+A0h] [bp-D0h]
  CVector v60; // [sp+A4h] [bp-CCh] BYREF
  CVector v; // [sp+B0h] [bp-C0h] BYREF
  CVector v62; // [sp+BCh] [bp-B4h] BYREF
  double v63; // [sp+C8h] [bp-A8h] BYREF
  unsigned __int32 z_low; // [sp+D0h] [bp-A0h]
  __int64 v65; // [sp+D4h] [bp-9Ch]
  RwReal v66; // [sp+DCh] [bp-94h]
  __int64 v67; // [sp+E0h] [bp-90h]
  RwReal v68; // [sp+E8h] [bp-88h]
  __int64 v69; // [sp+ECh] [bp-84h]
  RwReal v70; // [sp+F4h] [bp-7Ch]
  CColSphere sphere; // [sp+FCh] [bp-74h] BYREF

  x = Coors.x;
  y = Coors.y;
  z = Coors.z;
  v9 = CPools::ms_pObjectPool;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  if ( CTimer::m_snTimeInMilliseconds < CGlass::BreakGlassPhysically(CVector,float)::LastTimeGlassBroken
    || CTimer::m_snTimeInMilliseconds >= CGlass::BreakGlassPhysically(CVector,float)::LastTimeGlassBroken + 1000 )
  {
    sphere.m_data.m_nPieceType = 0;
    sphere.m_fRadius = Radius;
    sphere.m_data.m_nSurfaceType = 0;
    if ( m_nSize )
    {
      v11 = z;
      v12 = Coors.y;
      v13 = Coors.x;
      v58 = CPools::ms_pObjectPool;
      do
      {
        if ( (v9->m_aFlags[--m_nSize] & 0x80u) == 0 )
        {
          v14 = (int)v9->m_aStorage[m_nSize];
          if ( v14 )
          {
            if ( (*(_BYTE *)(v14 + 58) & 7) == 4 )
            {
              v15 = CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v14 + 38)];
              v59 = m_nSize;
              v16 = (*((int (__fastcall **)(CBaseModelInfo *))v15->_vptr$CBaseModelInfo + 2))(v15);
              m_nSize = v59;
              v9 = v58;
              if ( v16 )
              {
                if ( (*(_WORD *)(v16 + 40) & 0x7000 | 0x800) == 10240 && (*(_BYTE *)(v14 + 28) & 1) != 0 )
                {
                  m_pColModel = CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v14 + 38)]->m_pColModel;
                  m_pColData = m_pColModel->m_pColData;
                  if ( m_pColData )
                  {
                    if ( m_pColData->m_nNoOfTriangles >= 2 )
                    {
                      v20 = v14 + 20;
                      v19 = *(float **)(v14 + 20);
                      v21 = (float *)(v14 + 4);
                      if ( v19 )
                        v21 = v19 + 12;
                      v22 = v13 - *v21;
                      v23 = v12 - v21[1];
                      v24 = v11 - v21[2];
                      sphere.m_vecCentre.x = (float)((float)(v22 * *v19) + (float)(v23 * v19[1]))
                                           + (float)(v24 * v19[2]);
                      v57 = (const CMatrix **)(v14 + 20);
                      sphere.m_vecCentre.y = (float)((float)(v22 * *(float *)(*(_DWORD *)v20 + 16))
                                                   + (float)(v23 * *(float *)(*(_DWORD *)v20 + 20)))
                                           + (float)(v24 * *(float *)(*(_DWORD *)v20 + 24));
                      sphere.m_vecCentre.z = (float)((float)(v22 * *(float *)(*(_DWORD *)v20 + 32))
                                                   + (float)(v23 * *(float *)(*(_DWORD *)v20 + 36)))
                                           + (float)(v24 * *(float *)(*(_DWORD *)v20 + 40));
                      CCollision::CalculateTrianglePlanes(m_pColModel);
                      m_nSize = v59;
                      v9 = v58;
                      if ( m_pColData->m_nNoOfTriangles >= 1 )
                      {
                        CollisionPoint.x = x;
                        *(_QWORD *)&CollisionPoint.y = __PAIR64__(LODWORD(z), LODWORD(y));
                        v25 = 0;
                        v26 = 0;
                        v27 = 0;
                        v28 = 0;
                        do
                        {
                          v27 |= CCollision::TestSphereTriangle(
                                   &sphere,
                                   m_pColData->m_pTriCompressedVectorArray,
                                   &m_pColData->m_pTriangleArray[v26],
                                   &m_pColData->m_pTrianglePlaneArray[v25]);
                          ++v28;
                          ++v25;
                          ++v26;
                        }
                        while ( v28 < m_pColData->m_nNoOfTriangles );
                        z = CollisionPoint.z;
                        x = CollisionPoint.x;
                        y = CollisionPoint.y;
                        v9 = v58;
                        m_nSize = v59;
                        if ( v27 << 31 )
                        {
                          v29 = (_DWORD *)(v14 + 324);
                          CGlass::BreakGlassPhysically(CVector,float)::LastTimeGlassBroken = CTimer::m_snTimeInMilliseconds;
                          if ( (*(_BYTE *)(v14 + 324) & 0x10) != 0 )
                          {
                            m_pTriCompressedVectorArray = m_pColData->m_pTriCompressedVectorArray;
                            v32 = *(double *)&m_pTriCompressedVectorArray->x;
                            z_low = LODWORD(m_pTriCompressedVectorArray->z);
                            v63 = v32;
                            v33 = *(_QWORD *)&m_pTriCompressedVectorArray[1].x;
                            v66 = m_pTriCompressedVectorArray[1].z;
                            v65 = v33;
                            v34 = *(_QWORD *)&m_pTriCompressedVectorArray[2].x;
                            v68 = m_pTriCompressedVectorArray[2].z;
                            v67 = v34;
                            v35 = *(_QWORD *)&m_pTriCompressedVectorArray[3].x;
                            v70 = m_pTriCompressedVectorArray[3].z;
                            v69 = v35;
                            v2.n64_f32[0] = v66;
                            v3.n64_u32[0] = z_low;
                            v4.n64_f32[0] = v70;
                            v5.n64_f32[0] = v68;
                            v53.n64_u64[0] = v2.n64_u64[0];
                            v54.n64_u64[0] = v3.n64_u64[0];
                            v55.n64_u64[0] = v4.n64_u64[0];
                            v36 = *v57;
                            v37 = *((float *)&v63 + 1);
                            LODWORD(v38) = vmin_f32(vmin_f32(v3, v2), vmin_f32(v5, v4)).n64_u32[0];
                            v39 = *(float *)&v63;
                            *(double *)&v.x = v63;
                            v40 = v65;
                            v41 = v67;
                            v.z = v38;
                            operator*(&v62, v36, &v);
                            v42 = 1;
                            v43 = *v57;
                            v2.n64_f32[0] = sqrtf(
                                              (float)((float)(*(float *)&v40 - v39) * (float)(*(float *)&v40 - v39))
                                            + (float)((float)(*((float *)&v40 + 1) - v37)
                                                    * (float)(*((float *)&v40 + 1) - v37)));
                            v3.n64_f32[0] = sqrtf(
                                              (float)((float)(*(float *)&v41 - v39) * (float)(*(float *)&v41 - v39))
                                            + (float)((float)(*((float *)&v41 + 1) - v37)
                                                    * (float)(*((float *)&v41 + 1) - v37)));
                            LODWORD(v44) = vmax_f32(v3, v2).n64_u32[0];
                            v45 = sqrtf(
                                    (float)((float)(*(float *)&v35 - v39) * (float)(*(float *)&v35 - v39))
                                  + (float)((float)(*((float *)&v35 + 1) - v37) * (float)(*((float *)&v35 + 1) - v37)));
                            if ( v3.n64_f32[0] > v2.n64_f32[0] )
                              v42 = 2;
                            if ( v45 > v44 )
                              v42 = 3;
                            v46 = 3 * v42;
                            v47 = *((float *)&v63 + v46);
                            v48 = *((float *)&v63 + v46 + 1);
                            v60.x = v47;
                            v60.y = v48;
                            v60.z = v38;
                            operator*(&v, v43, &v60);
                            p_tx = (CVector *)(v14 + 4);
                            if ( *v57 )
                              p_tx = (CVector *)&(*v57)->tx;
                            CAudioEngine::ReportGlassCollisionEvent(&AudioEngine, 126, p_tx);
                            memset(&InitialSpeed, 0, sizeof(InitialSpeed));
                            UpVec.z = vmax_f32(vmax_f32(v54, v53), vmax_f32(v5, v55)).n64_f32[0] - v38;
                            *(_QWORD *)&UpVec.x = 0LL;
                            v51.z = v.z - v62.z;
                            v51.y = v.y - v62.y;
                            v51.x = v.x - v62.x;
                            CGlass::GeneratePanesForWindow(
                              1u,
                              v62,
                              UpVec,
                              v51,
                              InitialSpeed,
                              CollisionPoint,
                              0.1,
                              (*v29 & 0x10) != 0,
                              0,
                              1,
                              0);
                            *v29 |= 0x20u;
                            *(_DWORD *)(v14 + 28) &= 0xFFFFFF7E;
                          }
                          else
                          {
                            v30 = (CVector *)(v14 + 4);
                            if ( *v57 )
                              v30 = (CVector *)&(*v57)->tx;
                            CAudioEngine::ReportGlassCollisionEvent(&AudioEngine, 123, v30);
                            *v29 |= 0x10u;
                          }
                          v9 = v58;
                          m_nSize = v59;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      while ( m_nSize );
    }
  }
}
// 5AD7D2: variable 'v2' is possibly undefined
// 5AD7DA: variable 'v3' is possibly undefined
// 5AD7DE: variable 'v4' is possibly undefined
// 5AD7D6: variable 'v5' is possibly undefined

//----- (005AD998) --------------------------------------------------------
void CGridRef::Init()
{
  u_native v0; // r4
  const char *i; // r0
  int v2; // r1
  bool v3; // zf
  sgrid *v4; // r9
  const char *v5; // r0
  int v6; // [sp+8h] [bp-48h] BYREF
  unsigned __int8 v7; // [sp+Fh] [bp-41h] BYREF
  char v8[32]; // [sp+10h] [bp-40h] BYREF

  v7 = 0;
  v6 = 0;
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v0 = CFileMgr::OpenFile("DATA\\GRIDREF.DAT", "rb");
  for ( i = (const char *)CFileLoader::LoadLine(v0); i; i = (const char *)CFileLoader::LoadLine(v0) )
  {
    v2 = *(unsigned __int8 *)i;
    v3 = v2 == 0;
    if ( *i )
      v3 = v2 == 35;
    if ( !v3 )
    {
      sscanf(i, "%c%d %s", &v7, &v6, v8);
      v4 = &GridRefList[v7].grid[v6];
      v5 = (const char *)(*((int (__fastcall **)(char *))RwEngineInstance + 72))(v8);
      strcpy((char *)&v4[-651], v5);
    }
  }
  CFileMgr::CloseFile(v0);
}
// 61CADE: using guessed type char byte_61CADE;
// 5AD998: using guessed type char var_40[32];

//----- (005ADA84) --------------------------------------------------------
void __fastcall CGridRef::GetGridRefPositions(CVector Coors, uint8 *pGridX, uint8 *pGridY)
{
  *pGridX = (unsigned int)(float)((float)(Coors.x + 3000.0) / 600.0);
  *pGridY = 9 - (unsigned int)(float)((float)(Coors.y + 3000.0) / 600.0);
}

//----- (005ADAC8) --------------------------------------------------------
void __fastcall CGridRef::GetGridRefPositions(uint8 *pGridX, uint8 *pGridY)
{
  unsigned int v4; // s0
  CVector v5; // [sp+0h] [bp-20h] BYREF
  CVector v6; // [sp+Ch] [bp-14h] BYREF

  FindPlayerCoors(&v6, -1);
  FindPlayerCoors(&v5, -1);
  v4 = (unsigned int)(float)((float)(v5.y + 3000.0) / 600.0);
  *pGridX = (unsigned int)(float)((float)(v5.x + 3000.0) / 600.0);
  *pGridY = 9 - v4;
}

//----- (005ADB2C) --------------------------------------------------------
unsigned __int8 *__fastcall CGridRef::GetAreaName(uint8 grid_pos_x, uint8 grid_pos_y)
{
  bool v2; // cc
  unsigned __int8 *v3; // r2

  v2 = grid_pos_x > 9u;
  if ( grid_pos_x <= 9u )
    v2 = grid_pos_y > 9u;
  if ( v2 )
    return 0;
  v3 = (unsigned __int8 *)&byte_61CADE;
  if ( grid_pos_y == 255 )
    v3 = 0;
  if ( grid_pos_x == 255 )
    return 0;
  return v3;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (005ADB50) --------------------------------------------------------
int __fastcall CGridRef::GetArtistBugstarID(uint8 grid_pos_x, uint8 grid_pos_y)
{
  bool v2; // cf
  bool v3; // zf

  v2 = grid_pos_x >= 9u;
  v3 = grid_pos_x == 9;
  if ( grid_pos_x <= 9u )
  {
    v2 = grid_pos_y >= 9u;
    v3 = grid_pos_y == 9;
  }
  if ( !v3 && v2 )
    return 0;
  else
    return sub_19A810((const char *)&GridRefList[grid_pos_x].grid[grid_pos_y]);
}

//----- (005ADB78) --------------------------------------------------------
void __fastcall CLines::RenderLineNoClipping(
        float StartX,
        float StartY,
        float StartZ,
        float EndX,
        float EndY,
        float EndZ,
        UInt32 Colour1,
        UInt32 Colour2)
{
  v[1].color = (RwRGBA_0)bswap32(Colour2);
  v[0].color = (RwRGBA_0)bswap32(Colour1);
  v[0].position.x = StartX;
  v[0].position.y = StartY;
  v[0].position.z = StartZ;
  v[1].position.x = EndX;
  v[1].position.y = EndY;
  v[1].position.z = EndZ;
  LittleTest();
  if ( RwIm3DTransform(v, 2u, 0, 0) )
  {
    RwIm3DRenderLine(0, 1);
    sub_18D77C();
  }
}

//----- (005ADBD8) --------------------------------------------------------
void __fastcall CLines::RenderLineWithClipping(
        float StartX,
        float StartY,
        float StartZ,
        float EndX,
        float EndY,
        float EndZ,
        UInt32 Colour1,
        UInt32 Colour2)
{
  float32x2_t v8; // d6
  float32x2_t v9; // d8
  int v12; // s5
  int v13; // r6
  float v14; // s12
  float v15; // s14
  float v16; // s1
  float v17; // s3
  VertexBuffer *v18; // r1
  int v19; // r2
  float v20; // s5
  float v21; // s7
  float v22; // s9
  float v23; // s11
  float v24; // s6
  float v25; // s8
  float v26; // s10
  float v27; // s13
  int v28; // r3
  float v29; // s15
  float v30; // s16

  v9.n64_u32[0] = 7.0;
  v8.n64_f32[0] = (float)(sqrtf(
                            (float)((float)((float)(StartX - EndX) * (float)(StartX - EndX))
                                  + (float)((float)(StartY - EndY) * (float)(StartY - EndY)))
                          + (float)((float)(StartZ - EndZ) * (float)(StartZ - EndZ)))
                        / 2.5)
                + 1.0;
  v12 = (int)vmin_f32(v8, v9).n64_f32[0];
  v13 = v12;
  if ( v12 >= 1 )
  {
    v14 = (float)(unsigned __int8)Colour1;
    v15 = (float)BYTE1(Colour1);
    v16 = (float)BYTE2(Colour1);
    v17 = (float)HIBYTE(Colour1);
    v18 = &TempVertexBuffer;
    v19 = 0;
    v20 = (float)v12;
    v21 = (float)((unsigned __int8)Colour2 - (unsigned __int8)Colour1);
    v22 = (float)(int)(HIBYTE(Colour2) - HIBYTE(Colour1));
    v23 = (float)(BYTE1(Colour2) - BYTE1(Colour1));
    v24 = EndZ - StartZ;
    v25 = EndY - StartY;
    v26 = EndX - StartX;
    v27 = (float)(BYTE2(Colour2) - BYTE2(Colour1));
    do
    {
      v28 = (__int16)v19++;
      v29 = (float)v28 / v20;
      v30 = (float)v19 / v20;
      v18->m_3d[0].position.x = (float)(v26 * v29) + StartX;
      v18->m_3d[0].position.y = (float)(v25 * v29) + StartY;
      v18->m_3d[0].position.z = (float)(v24 * v29) + StartZ;
      v18->m_3d[1].position.x = (float)(v26 * v30) + StartX;
      v18->m_3d[1].position.y = (float)(v25 * v30) + StartY;
      v18->m_3d[1].position.z = (float)(v24 * v30) + StartZ;
      _R5 = (unsigned int)(float)((float)(v29 * v23) + v15) << 16;
      __asm { UXTB16.W        R5, R5 }
      v18->m_3d[0].color = (RwRGBA_0)((unsigned __int8)(unsigned int)(float)((float)(v29 * v22) + v17) | ((unsigned int)(float)((float)(v29 * v21) + v14) << 24) | _R5 | (unsigned __int16)((unsigned __int16)(unsigned int)(float)((float)(v29 * v27) + v16) << 8));
      _R5 = (unsigned int)(float)((float)(v30 * v23) + v15) << 16;
      __asm { UXTB16.W        R5, R5 }
      v18->m_3d[1].color = (RwRGBA_0)((unsigned __int8)(unsigned int)(float)((float)(v30 * v22) + v17) | ((unsigned int)(float)((float)(v30 * v21) + v14) << 24) | _R5 | (unsigned __int16)((unsigned __int16)(unsigned int)(float)((float)(v30 * v27) + v16) << 8));
      v18 = (VertexBuffer *)((char *)v18 + 72);
    }
    while ( !_ZF );
  }
  LittleTest();
  if ( RwIm3DTransform(TempVertexBuffer.m_3d, 2 * v13, 0, 0) )
  {
    RwIm3DRenderIndexedPrimitive(rwPRIMTYPELINELIST, LIndices, 2 * v13);
    sub_18D77C();
  }
}
// 5ADC36: variable 'v8' is possibly undefined
// 5ADC36: variable 'v9' is possibly undefined

//----- (005ADE3C) --------------------------------------------------------
void __fastcall CLines::ImmediateLine2D(
        Int32 StartX,
        Int32 StartY,
        Int32 EndX,
        Int32 EndY,
        UInt8 Red1,
        UInt8 Green1,
        UInt8 Blue1,
        UInt8 Alpha1,
        UInt8 Red2,
        UInt8 Green2,
        UInt8 Blue2,
        UInt8 Alpha2)
{
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  LinesVertexBuffer[0].r = Red1;
  LinesVertexBuffer[0].a = Alpha1;
  LinesVertexBuffer[0].b = Blue1;
  LinesVertexBuffer[1].r = Red2;
  LinesVertexBuffer[1].g = Green2;
  LinesVertexBuffer[1].b = Blue2;
  LinesVertexBuffer[1].a = Alpha2;
  LinesVertexBuffer[0].x = (float)StartX;
  LinesVertexBuffer[0].y = (float)StartY;
  LinesVertexBuffer[1].x = (float)EndX;
  LinesVertexBuffer[1].y = (float)EndY;
  LinesVertexBuffer[0].g = Green1;
  RwIm2DRenderLine_BUGFIX(LinesVertexBuffer, 2, 0, 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  sub_192840(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005ADF10) --------------------------------------------------------
bool __fastcall CalcScreenCoors(const COccVector *In, COccVector *pResult, float *pScaleX, float *pScaleY)
{
  __int64 v7; // d16
  float z; // s2
  float y; // s6
  bool result; // r0
  CVector v11; // [sp+0h] [bp-20h] BYREF

  operator*(&v11, &TheCamera.m_viewMatrix, In);
  v7 = *(_QWORD *)&v11.x;
  pResult->z = v11.z;
  *(_QWORD *)&pResult->x = v7;
  z = pResult->z;
  if ( z <= 1.0 )
    return 0;
  y = pResult->y;
  pResult->x = pResult->x * (float)((float)(1.0 / z) * (float)RsGlobal.screenWidth);
  pResult->y = y * (float)((float)(1.0 / z) * (float)RsGlobal.screenHeight);
  *pScaleX = (float)(1.0 / z) * (float)RsGlobal.screenWidth;
  *pScaleY = (float)(1.0 / z) * (float)RsGlobal.screenHeight;
  *pScaleX = *pScaleX * (float)(70.0 / CDraw::ms_fFOV);
  result = 1;
  *pScaleY = *pScaleY * (float)(70.0 / CDraw::ms_fFOV);
  return result;
}

//----- (005ADFFC) --------------------------------------------------------
bool __fastcall CalcScreenCoors(const COccVector *In, COccVector *pResult)
{
  __int64 v3; // d16
  float z; // s2
  float y; // s6
  bool result; // r0
  CVector v7; // [sp+0h] [bp-18h] BYREF

  operator*(&v7, &TheCamera.m_viewMatrix, In);
  v3 = *(_QWORD *)&v7.x;
  pResult->z = v7.z;
  *(_QWORD *)&pResult->x = v3;
  z = pResult->z;
  if ( z <= 1.0 )
    return 0;
  y = pResult->y;
  pResult->x = pResult->x * (float)((float)(1.0 / z) * (float)RsGlobal.screenWidth);
  result = 1;
  pResult->y = y * (float)((float)(1.0 / z) * (float)RsGlobal.screenHeight);
  return result;
}

//----- (005AE084) --------------------------------------------------------
bool __fastcall DoesInfiniteLineCrossFiniteLine(
        float Finite1X,
        float Finite1Y,
        float Finite2X,
        float Finite2Y,
        float BaseX,
        float BaseY,
        float DeltaX,
        float DeltaY)
{
  return (float)((float)((float)((float)(Finite1X - BaseX) * DeltaY) - (float)((float)(Finite1Y - BaseY) * DeltaX))
               * (float)((float)((float)(Finite2X - BaseX) * DeltaY) - (float)((float)(Finite2Y - BaseY) * DeltaX))) < 0.0;
}

//----- (005AE0E0) --------------------------------------------------------
bool __fastcall DoesInfiniteLineTouchScreen(float BaseX, float BaseY, float DeltaX, float DeltaY)
{
  float v4; // s12
  float v5; // s8
  float v6; // s2
  float v7; // s6
  float v8; // s4
  float v9; // s2
  bool result; // r0

  result = BaseX > 0.0 && BaseY > 0.0 && (float)RsGlobal.screenHeight > BaseY
        || (v4 = (float)(0.0 - BaseY) * DeltaX,
            v5 = (float)(0.0 - BaseX) * DeltaY,
            v6 = (float)((float)RsGlobal.screenWidth - BaseX) * DeltaY,
            v7 = v6 - v4,
            (float)((float)(v5 - v4) * (float)(v6 - v4)) < 0.0)
        || (v8 = (float)((float)RsGlobal.screenHeight - BaseY) * DeltaX,
            (float)((float)(v5 - v4) * (float)(v5 - v8)) < 0.0)
        || (v9 = v6 - v8, (float)(v7 * v9) < 0.0)
        || (float)((float)(v5 - v8) * v9) < 0.0;
  return result;
}

//----- (005AE1D8) --------------------------------------------------------
void COcclusion::Init()
{
  COcclusion::NumInteriorOccludersOnMap = 0;
  COcclusion::NumOccludersOnMap = 0;
  COcclusion::FarAwayList = -1;
  COcclusion::NearbyList = -1;
  COcclusion::ListWalkThroughFA = -1;
  COcclusion::PreviousListWalkThroughFA = -1;
}

//----- (005AE23C) --------------------------------------------------------
void __fastcall COcclusion::AddOne(
        float X,
        float Y,
        float Z,
        float ArgWidth,
        float ArgLength,
        float ArgHeight,
        float ZRot,
        float YRot,
        float XRot,
        UInt32 Flags,
        int bInterior)
{
  int v11; // r12
  unsigned int v12; // lr
  int v13; // s0
  int v14; // s2
  int v15; // s4
  float i; // s6
  float v20; // s6
  float v21; // s8
  float v22; // s12
  Int32 v24; // r5
  int v25; // r0
  float v26; // s10
  COccluder *v27; // r2
  Int32 v28; // r0
  COccluder *v29; // r1
  __int16 v30; // r3

  v11 = 1;
  v12 = 0;
  v13 = (int)COERCE_FLOAT(LODWORD(ArgWidth) & 0x7FFFFFFF);
  v14 = (int)fabsf(ArgLength);
  v15 = (int)fabsf(ArgHeight);
  if ( !v14 )
  {
    v11 = 2;
    v12 = 1;
  }
  if ( !v13 )
    v12 = v11;
  if ( !v15 )
    ++v12;
  if ( v12 <= 1 )
  {
    for ( i = ZRot; i < 0.0; i = i + 360.0 )
      ;
    for ( ; i > 360.0; i = i + -360.0 )
      ;
    while ( YRot < 0.0 )
      YRot = YRot + 360.0;
    for ( ; YRot > 360.0; YRot = YRot + -360.0 )
      ;
    while ( XRot < 0.0 )
      XRot = XRot + 360.0;
    for ( ; XRot > 360.0; XRot = XRot + -360.0 )
      ;
    v20 = i * 0.017453;
    v21 = YRot * 0.017453;
    v22 = XRot * 0.017453;
    if ( bInterior )
    {
      if ( COcclusion::NumInteriorOccludersOnMap <= 39 )
      {
        v24 = COcclusion::NumInteriorOccludersOnMap;
        v25 = COcclusion::NumInteriorOccludersOnMap + 1;
        v26 = Z * 4.0;
        COcclusion::aInteriorOccluders[v24].iCenterX = (int)(float)(X * 4.0);
        v27 = &COcclusion::aInteriorOccluders[v24];
        v27->iRotX = (unsigned int)(float)(v22 * 40.744);
        v27->iRotY = (unsigned int)(float)(v21 * 40.744);
        v27->iRotZ = (unsigned int)(float)(v20 * 40.744);
        v27->iCenterY = (int)(float)(Y * 4.0);
        v27->iCenterZ = (int)v26;
        COcclusion::NumInteriorOccludersOnMap = v25;
        v27->iLength = (int)(float)((float)v14 * 4.0);
        v27->iWidth = (int)(float)((float)v13 * 4.0);
        v27->iHeight = (int)(float)((float)v15 * 4.0);
      }
    }
    else
    {
      v28 = COcclusion::NumOccludersOnMap;
      if ( COcclusion::NumOccludersOnMap < 1000 )
      {
        v29 = &COcclusion::aOccluders[COcclusion::NumOccludersOnMap];
        v29->iRotX = (unsigned int)(float)(v22 * 40.744);
        v29->iRotY = (unsigned int)(float)(v21 * 40.744);
        v29->iRotZ = (unsigned int)(float)(v20 * 40.744);
        COcclusion::aOccluders[v28].iCenterX = (int)(float)(X * 4.0);
        v29->iCenterY = (int)(float)(Y * 4.0);
        v29->iCenterZ = (int)(float)(Z * 4.0);
        v29->iLength = (int)(float)((float)v14 * 4.0);
        v29->iWidth = (int)(float)((float)v13 * 4.0);
        v29->iHeight = (int)(float)((float)v15 * 4.0);
        v30 = COcclusion::FarAwayList & 0x7FFF;
        if ( Flags )
          v30 |= 0x8000u;
        COcclusion::FarAwayList = v28;
        *((_WORD *)v29 + 8) = v30;
        COcclusion::NumOccludersOnMap = v28 + 1;
      }
    }
  }
}

//----- (005AE528) --------------------------------------------------------
bool __fastcall IsPointInsideLine(
        float LineBaseX,
        float LineBaseY,
        float LineDeltaX,
        float LineDeltaY,
        float TestPointX,
        float TestPointY,
        float Radius)
{
  return (float)((float)((float)(TestPointX - LineBaseX) * LineDeltaY)
               - (float)((float)(TestPointY - LineBaseY) * LineDeltaX)) >= Radius;
}

//----- (005AE568) --------------------------------------------------------
void COcclusion::ProcessBeforeRendering()
{
  float32x2_t v0; // d2
  float32x2_t v1; // d5
  int16x4_t v2; // d16
  int16x4_t v3; // d17
  Int32 v4; // r0
  Int32 v5; // r5
  COccluder *v6; // r4
  int v7; // r11
  int v8; // r1
  COccluder *v9; // r5
  float iCenterX; // s6
  unsigned __int32 v11; // r4
  unsigned __int32 v12; // r5
  CSimpleTransform *p_tx; // r4
  int16x4_t v14; // d17
  unsigned __int64 v15; // d4
  float v16; // s6
  float32x2_t v17; // d4
  COccluder *v18; // r8
  int v19; // r4
  _WORD *v20; // r8
  int v21; // t1
  int v22; // r6
  Int16 v23; // r2
  int v24; // r5
  Int16 v25; // r6
  float32x2_t v26; // d9
  __int16 v27; // r8
  COccluder *v28; // r0
  float v29; // s0
  unsigned __int32 v30; // r3
  CSimpleTransform *p_m_transform; // r2
  _WORD *v32; // r0
  int v33; // r1
  int v34; // t1
  int16x4_t v35; // d16
  unsigned __int64 v36; // d1
  float v37; // s0
  float32x2_t v38; // d1
  Int16 v39; // r2
  int v40; // r5
  int v41; // r11
  int i; // r4
  int v43; // r6
  CActiveOccluder *v44; // r4
  unsigned __int32 v45; // [sp+34h] [bp-44h]

  COcclusion::NumActiveOccluders = 0;
  if ( CGame::currArea )
  {
    if ( COcclusion::NumInteriorOccludersOnMap >= 1 )
    {
      v4 = 0;
      v5 = 1;
      v6 = COcclusion::aInteriorOccluders;
LABEL_5:
      if ( COccluder::ProcessOneOccluder(v6, &COcclusion::aActiveOccluders[v4]) )
        ++COcclusion::NumActiveOccluders;
      while ( v5 < COcclusion::NumInteriorOccludersOnMap )
      {
        ++v5;
        v4 = COcclusion::NumActiveOccluders;
        ++v6;
        if ( COcclusion::NumActiveOccluders <= 27 )
          goto LABEL_5;
      }
    }
  }
  else
  {
    LOWORD(v7) = COcclusion::ListWalkThroughFA;
    if ( (unsigned __int16)COcclusion::ListWalkThroughFA != 0xFFFF
      || (LOWORD(v7) = COcclusion::FarAwayList,
          COcclusion::PreviousListWalkThroughFA = -1,
          COcclusion::ListWalkThroughFA = COcclusion::FarAwayList,
          (unsigned __int16)COcclusion::FarAwayList != 0xFFFF) )
    {
      v2.n64_f32[0] = 0.25;
      v2.n64_f32[1] = 0.25;
      v8 = -1;
      do
      {
        if ( (unsigned __int16)v7 == 0xFFFF )
          break;
        v9 = &COcclusion::aOccluders[(__int16)v7];
        v11 = *(_DWORD *)&v9->iCenterY;
        v12 = *(_DWORD *)&v9->iLength;
        v45 = v11;
        p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_tx = &TheCamera.m_transform;
        v3.n64_u32[0] = v45;
        v14.n64_u64[0] = vsub_f32(
                           *(float32x2_t *)&p_tx->m_translate.y,
                           vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]), v2)).n64_u64[0];
        v15 = vmul_f32(v14, v14).n64_u64[0];
        v14.n64_u32[0] = v12;
        v3.n64_u64[0] = vcvt_f32_s32((int32x2_t)vmovl_s16(v14).n128_u64[0]).n64_u64[0];
        iCenterX = (float)COcclusion::aOccluders[(__int16)v7].iCenterX;
        v16 = (float)((float)((float)(p_tx->m_translate.x + (float)(iCenterX * -0.25))
                            * (float)(p_tx->m_translate.x + (float)(iCenterX * -0.25)))
                    + *(float *)&v15)
            + *((float *)&v15 + 1);
        v17.n64_u64[0] = vmul_f32(v3, v2).n64_u64[0];
        v1.n64_u32[0] = v17.n64_u32[1];
        if ( (float)(sqrtf(v16) + (float)(vmax_f32(v17, v1).n64_f32[0] * -0.5)) >= 250.0 )
        {
          COcclusion::PreviousListWalkThroughFA = v7;
          v7 = *((unsigned __int16 *)&COcclusion::aOccluders[(__int16)v7] + 8) << 17 >> 17;
          COcclusion::ListWalkThroughFA = v7;
        }
        else
        {
          v18 = &COcclusion::aOccluders[(__int16)v7];
          v21 = *((unsigned __int16 *)v18 + 8);
          v20 = (_WORD *)((char *)v18 + 16);
          v19 = v21;
          v22 = v21 << 17 >> 17;
          if ( (unsigned __int16)COcclusion::PreviousListWalkThroughFA == 0xFFFF )
          {
            COcclusion::FarAwayList = v22;
          }
          else
          {
            *((_WORD *)&COcclusion::aOccluders[COcclusion::PreviousListWalkThroughFA] + 8) = *((_WORD *)&COcclusion::aOccluders[COcclusion::PreviousListWalkThroughFA]
                                                                                             + 8) & 0x8000 | v22 & 0x7FFF;
            v19 = (unsigned __int16)*v20;
          }
          v23 = COcclusion::NearbyList;
          COcclusion::NearbyList = v7;
          v7 = v19 << 17 >> 17;
          *v20 = v23 & 0x7FFF | v19 & 0x8000;
          COcclusion::ListWalkThroughFA = (__int16)(2 * v19) >> 1;
        }
        ++v8;
      }
      while ( v8 < 15 );
    }
    v24 = COcclusion::NearbyList;
    v25 = COcclusion::NearbyList;
    if ( (unsigned __int16)COcclusion::NearbyList != 0xFFFF )
    {
      v26.n64_f32[0] = 0.25;
      v26.n64_f32[1] = 0.25;
      v27 = -1;
      do
      {
        while ( 1 )
        {
          if ( COcclusion::NumActiveOccluders <= 27
            && COccluder::ProcessOneOccluder(
                 &COcclusion::aOccluders[v24],
                 &COcclusion::aActiveOccluders[COcclusion::NumActiveOccluders]) )
          {
            ++COcclusion::NumActiveOccluders;
          }
          v28 = &COcclusion::aOccluders[v24];
          v29 = (float)v28->iCenterX;
          v30 = *(_DWORD *)&v28->iLength;
          p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            p_m_transform = &TheCamera.m_transform;
          v2.n64_u32[0] = *(_DWORD *)&v28->iCenterY;
          v34 = *((unsigned __int16 *)v28 + 8);
          v32 = (_WORD *)((char *)v28 + 16);
          v33 = v34;
          v35.n64_u64[0] = vsub_f32(
                             *(float32x2_t *)&p_m_transform->m_translate.y,
                             vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v2).n128_u64[0]), v26)).n64_u64[0];
          v36 = vmul_f32(v35, v35).n64_u64[0];
          v35.n64_u32[0] = v30;
          v24 = v34 << 17 >> 17;
          v2.n64_u64[0] = vcvt_f32_s32((int32x2_t)vmovl_s16(v35).n128_u64[0]).n64_u64[0];
          v37 = (float)((float)((float)(p_m_transform->m_translate.x + (float)(v29 * -0.25))
                              * (float)(p_m_transform->m_translate.x + (float)(v29 * -0.25)))
                      + *(float *)&v36)
              + *((float *)&v36 + 1);
          v38.n64_u64[0] = vmul_f32(v2, v26).n64_u64[0];
          v0.n64_u32[0] = v38.n64_u32[1];
          if ( (float)(sqrtf(v37) + (float)(vmax_f32(v38, v0).n64_f32[0] * -0.5)) >= 250.0 )
            break;
          v27 = v25;
          v25 = v24;
          if ( (unsigned __int16)v24 == 0xFFFF )
            goto LABEL_36;
        }
        if ( (unsigned __int16)v27 == 0xFFFF )
        {
          COcclusion::NearbyList = v24;
        }
        else
        {
          *((_WORD *)&COcclusion::aOccluders[v27] + 8) = *((_WORD *)&COcclusion::aOccluders[v27] + 8) & 0x8000 | v24 & 0x7FFF;
          v33 = (unsigned __int16)*v32;
        }
        v39 = COcclusion::FarAwayList;
        COcclusion::FarAwayList = v25;
        *v32 = v39 & 0x7FFF | v33 & 0x8000;
        v24 = v33 << 17 >> 17;
        v25 = v24;
      }
      while ( (unsigned __int16)((__int16)(2 * v33) >> 1) != 0xFFFF );
    }
  }
LABEL_36:
  v40 = COcclusion::NumActiveOccluders;
  if ( COcclusion::NumActiveOccluders >= 1 )
  {
    v41 = 0;
    do
    {
      if ( v40 >= 1 )
      {
        for ( i = 0; i < v40; ++i )
        {
          if ( v41 == i )
          {
            i = v41;
          }
          else if ( COcclusion::aActiveOccluders[i].DistToCam < COcclusion::aActiveOccluders[v41].DistToCam
                 && COcclusion::OccluderHidesBehind(
                      &COcclusion::aActiveOccluders[v41],
                      &COcclusion::aActiveOccluders[i]) )
          {
            if ( v41 < --v40 )
            {
              v43 = v41;
              v44 = &COcclusion::aActiveOccluders[v41 + 1];
              do
              {
                qmemcpy(&v44[-1], v44, sizeof(CActiveOccluder));
                ++v43;
                ++v44;
              }
              while ( v43 < v40 );
            }
            --v41;
            i = v40;
            COcclusion::NumActiveOccluders = v40;
          }
        }
      }
      ++v41;
    }
    while ( v41 < v40 );
  }
}
// 5AE70A: variable 'v3' is possibly undefined
// 5AE754: variable 'v1' is possibly undefined
// 5AE8F0: variable 'v2' is possibly undefined
// 5AE942: variable 'v0' is possibly undefined

//----- (005AEAFC) --------------------------------------------------------
bool __fastcall COccluder::NearCamera(COccluder *this)
{
  float32x2_t v1; // d3
  int16x4_t v2; // d16
  float v3; // s0
  float32x2_t v4; // d16
  float32x2_t v5; // d17
  CSimpleTransform *p_tx; // r3
  int16x4_t v7; // d16
  unsigned __int64 v8; // d1
  bool result; // r0
  float32x2_t v10; // d2

  v2.n64_u32[0] = *(_DWORD *)&this->iCenterY;
  v3 = (float)this->iCenterX * -0.25;
  v4.n64_u64[0] = vcvt_f32_s32((int32x2_t)vmovl_s16(v2).n128_u64[0]).n64_u64[0];
  v5.n64_f32[0] = 0.25;
  v5.n64_f32[1] = 0.25;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, vmul_f32(v4, v5)).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  v7.n64_u32[0] = *(_DWORD *)&this->iLength;
  result = 0;
  v10.n64_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v7).n128_u64[0]), v5).n64_u64[0];
  v1.n64_u32[0] = v10.n64_u32[1];
  if ( (float)(sqrtf(
                 (float)((float)((float)(p_tx->m_translate.x + v3) * (float)(p_tx->m_translate.x + v3)) + *(float *)&v8)
               + *((float *)&v8 + 1))
             + (float)(vmax_f32(v10, v1).n64_f32[0] * -0.5)) < 250.0 )
    return 1;
  return result;
}
// 5AEB1E: variable 'v2' is possibly undefined
// 5AEB86: variable 'v1' is possibly undefined

//----- (005AEBB0) --------------------------------------------------------
bool __fastcall COccluder::ProcessOneOccluder(COccluder *this, CActiveOccluder *pActive)
{
  bool v3; // r5
  int iCenterX; // s2
  RwReal v6; // s4
  float v7; // s2
  float v8; // s4
  float v9; // s6
  float v10; // s0
  float v11; // s20
  float iWidth; // s0
  float iHeight; // s0
  bool v14; // r0
  bool v15; // r0
  bool v16; // r0
  COccluder *v17; // r0
  __int64 v18; // d16
  float v19; // s0
  float v20; // s2
  float v21; // s4
  float v22; // s0
  float v23; // s10
  float v24; // s2
  float v25; // s0
  int v26; // r4
  float v27; // s0
  float v28; // s0
  float xx; // s4
  float v30; // s14
  float yx; // s0
  float zx; // s2
  CSimpleTransform *p_tx; // r2
  float y; // s3
  char v35; // r0
  float x; // s14
  float z; // s1
  bool *v38; // r5
  float v39; // s7
  float v40; // s20
  float v41; // s5
  float v42; // s9
  char v43; // r0
  float v44; // s8
  float v45; // s9
  float v46; // s7
  float v47; // s18
  float v48; // s13
  float v49; // s14
  float v50; // s11
  float v51; // s12
  float v52; // s3
  float v53; // s8
  float v54; // s1
  __int64 v55; // d16
  __int64 v56; // d16
  COccVector *v57; // r1
  float v58; // s0
  float v59; // s0
  COccVector *v60; // r0
  float v61; // s6
  _BOOL4 v62; // r0
  COccluder *v63; // r4
  COccluder *v64; // r9
  COccluder *v65; // r8
  _BOOL4 v67; // r0
  COccluder *v68; // r5
  CMatrix *v69; // r10
  int v70; // r5
  __int64 v71; // d16
  float v72; // s16
  float v73; // s18
  __int64 v74; // kr00_8
  float v75; // s24
  float v76; // s26
  __int64 v77; // d16
  char *v78; // r0
  int v79; // r4
  COccluder *v80; // [sp+4h] [bp-264h]
  COccluder *v81; // [sp+8h] [bp-260h]
  CActiveOccluder *v82; // [sp+Ch] [bp-25Ch]
  CVector v83; // [sp+10h] [bp-258h] BYREF
  CMatrix v84; // [sp+20h] [bp-248h] BYREF
  CMatrix m; // [sp+68h] [bp-200h] BYREF
  CMatrix v86; // [sp+B0h] [bp-1B8h] BYREF
  CMatrix v87; // [sp+F8h] [bp-170h] BYREF
  CMatrix v88; // [sp+140h] [bp-128h] BYREF
  CMatrix v89; // [sp+188h] [bp-E0h] BYREF
  unsigned __int8 v90; // [sp+1D6h] [bp-92h]
  unsigned __int8 v91; // [sp+1D7h] [bp-91h]
  unsigned __int8 v92; // [sp+1D8h] [bp-90h]
  bool v93; // [sp+1D9h] [bp-8Fh]
  bool v94; // [sp+1DAh] [bp-8Eh]
  bool v95; // [sp+1DBh] [bp-8Dh]
  CVector v; // [sp+1DCh] [bp-8Ch] BYREF
  CVector v2; // [sp+1E8h] [bp-80h] BYREF
  CVector v1; // [sp+1F8h] [bp-70h] BYREF

  v3 = 0;
  pActive->LinesUsed = 0;
  iCenterX = this->iCenterX;
  v6 = (float)this->iCenterZ * 0.25;
  v.y = (float)this->iCenterY * 0.25;
  v.x = (float)iCenterX * 0.25;
  v.z = v6;
  operator*((CVector *)&v89, &TheCamera.m_viewMatrix, &v);
  gCenterOnScreen.z = v89.zx;
  *(_QWORD *)&gCenterOnScreen.x = *(_QWORD *)&v89.xx;
  if ( v89.zx > 1.0 )
  {
    v3 = 0;
    gCenterOnScreen.x = gCenterOnScreen.x * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenWidth);
    gCenterOnScreen.y = gCenterOnScreen.y * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenHeight);
    if ( v89.zx >= -150.0 && v89.zx <= 300.0 )
    {
      v7 = (float)this->iWidth * 0.25;
      v8 = (float)this->iLength * 0.25;
      v9 = (float)this->iHeight * 0.25;
      v82 = pActive;
      pActive->DistToCam = (int)(float)(v89.zx - sqrtf((float)((float)(v8 * v8) + (float)(v7 * v7)) + (float)(v9 * v9)));
      v88.m_pRwMat = 0;
      v88.m_owner = 0;
      v87.m_pRwMat = 0;
      v87.m_owner = 0;
      v86.m_pRwMat = 0;
      v86.m_owner = 0;
      m.m_pRwMat = 0;
      m.m_owner = 0;
      CMatrix::SetRotateX(&v88, (float)this->iRotX * 0.024544);
      CMatrix::SetRotateY(&v87, (float)this->iRotY * 0.024544);
      CMatrix::SetRotateZ(&v86, (float)this->iRotZ * 0.024544);
      operator*(&v84, &v87, &v88);
      operator*(&v89, &v84, &v86);
      CMatrix::operator=(&m, &v89);
      CMatrix::~CMatrix(&v89);
      CMatrix::~CMatrix(&v84);
      gMaxYInOccluder = -1000000.0;
      gMaxXInOccluder = -1000000.0;
      gMinXInOccluder = 1000000.0;
      gMinYInOccluder = 1000000.0;
      v10 = (float)this->iLength * 0.25;
      if ( v10 == 0.0 )
      {
        v11 = 0.5;
        iWidth = (float)this->iWidth;
        v84.yx = 0.0;
        v84.zx = 0.0;
        v84.xx = (float)(iWidth * 0.25) * 0.5;
        operator*((CVector *)&v89, &m, (const CVector *)&v84);
        v1.z = v89.zx;
        *(_QWORD *)&v1.x = *(_QWORD *)&v89.xx;
        iHeight = (float)this->iHeight;
        v84.xx = 0.0;
        v84.yx = 0.0;
      }
      else
      {
        if ( (float)((float)this->iWidth * 0.25) != 0.0 && (float)((float)this->iHeight * 0.25) != 0.0 )
        {
          v26 = 0;
          v84.xx = 0.0;
          v84.zx = 0.0;
          v84.yx = v10 * 0.5;
          operator*((CVector *)&v89, &m, (const CVector *)&v84);
          v1.z = v89.zx;
          *(_QWORD *)&v1.x = *(_QWORD *)&v89.xx;
          v27 = (float)this->iWidth;
          v84.yx = 0.0;
          v84.zx = 0.0;
          v84.xx = (float)(v27 * 0.25) * 0.5;
          operator*((CVector *)&v89, &m, (const CVector *)&v84);
          v2.z = v89.zx;
          *(_QWORD *)&v2.x = *(_QWORD *)&v89.xx;
          v28 = (float)this->iHeight;
          v84.xx = 0.0;
          v84.yx = 0.0;
          v84.zx = (float)(v28 * 0.25) * 0.5;
          operator*((CVector *)&v89, &m, (const CVector *)&v84);
          xx = v89.xx;
          v30 = -v89.xx;
          yx = v89.yx;
          zx = v89.zx;
          v89.zx = v1.z;
          *(_QWORD *)&v89.xx = *(_QWORD *)&v1.x;
          *(CVector *)&v89.zy = v2;
          v89.yy = -v1.z;
          v89.xy = -v1.y;
          v89.pad1 = -v1.x;
          v89.pad3 = -v2.z;
          v89.yz = -v2.x;
          v89.tz = zx;
          v89.ty = yx;
          v89.tx = xx;
          v89.zz = -v2.y;
          *(float *)&v89.m_owner = -zx;
          *(float *)&v89.m_pRwMat = -yx;
          v89.pad4 = v30;
          p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            p_tx = &TheCamera.m_transform;
          y = p_tx->m_translate.y;
          v35 = 0;
          x = p_tx->m_translate.x;
          z = p_tx->m_translate.z;
          v38 = gOccluderCoorsValid;
          v39 = v2.x * (float)((float)(v.x + v2.x) - p_tx->m_translate.x);
          v40 = xx * (float)((float)(v.x + xx) - p_tx->m_translate.x);
          v41 = (float)((float)-(float)(v1.x * (float)((float)(v.x - v1.x) - p_tx->m_translate.x))
                      - (float)((float)((float)(v.y - v1.y) - y) * v1.y))
              - (float)((float)((float)(v.z - v1.z) - z) * v1.z);
          v42 = -(float)(v2.x * (float)((float)(v.x - v2.x) - p_tx->m_translate.x));
          if ( (float)((float)((float)(v1.x * (float)((float)(v.x + v1.x) - p_tx->m_translate.x))
                             + (float)(v1.y * (float)((float)(v.y + v1.y) - y)))
                     + (float)(v1.z * (float)((float)(v.z + v1.z) - z))) < 0.0 )
            v35 = 1;
          v90 = v35;
          v43 = 0;
          v44 = (float)(v42 - (float)((float)((float)(v.y - v2.y) - y) * v2.y))
              - (float)((float)((float)(v.z - v2.z) - z) * v2.z);
          v45 = (float)(v40 + (float)(yx * (float)((float)(v.y + yx) - y)))
              + (float)(zx * (float)((float)(v.z + zx) - z));
          v46 = v39 + (float)(v89.pad2 * (float)((float)(v.y + v89.pad2) - y));
          if ( v41 < 0.0 )
            v43 = 1;
          v91 = v43;
          v93 = v44 < 0.0;
          v81 = (COccluder *)(v45 < 0.0);
          v94 = v45 < 0.0;
          v92 = (float)(v46 + (float)(v89.xz * (float)((float)(v.z + v89.xz) - z))) < 0.0;
          v80 = (COccluder *)((float)((float)((float)(v89.pad4 * (float)((float)(v.x + v89.pad4) - x))
                                            + (float)(*(float *)&v89.m_pRwMat
                                                    * (float)((float)(v.y + *(float *)&v89.m_pRwMat) - y)))
                                    + (float)(*(float *)&v89.m_owner * (float)((float)(v.z + *(float *)&v89.m_owner) - z))) < 0.0);
          v95 = (float)((float)((float)(v89.pad4 * (float)((float)(v.x + v89.pad4) - x))
                              + (float)(*(float *)&v89.m_pRwMat * (float)((float)(v.y + *(float *)&v89.m_pRwMat) - y)))
                      + (float)(*(float *)&v89.m_owner * (float)((float)(v.z + *(float *)&v89.m_owner) - z))) < 0.0;
          v47 = (float)(v.y - v1.y) + v2.y;
          v48 = (float)(v.y + v1.y) - v2.y;
          v49 = (float)(v.y - v1.y) - v2.y;
          v50 = (float)(v.z + v1.z) - v2.z;
          v51 = (float)(v.z - v1.z) + v2.z;
          v52 = (float)(v.z + v1.z) + v2.z;
          gOccluderCoors[0].x = xx + (float)((float)(v.x + v1.x) + v2.x);
          v53 = (float)(v.z - v1.z) - v2.z;
          gOccluderCoors[1].x = xx + (float)((float)(v.x - v1.x) + v2.x);
          v54 = (float)(v.y + v1.y) + v2.y;
          gOccluderCoors[2].x = xx + (float)((float)(v.x + v1.x) - v2.x);
          gOccluderCoors[3].x = xx + (float)((float)(v.x - v1.x) - v2.x);
          gOccluderCoors[4].x = (float)((float)(v.x + v1.x) + v2.x) - xx;
          gOccluderCoors[0].y = yx + v54;
          gOccluderCoors[0].z = zx + v52;
          gOccluderCoors[1].z = zx + v51;
          gOccluderCoors[1].y = yx + v47;
          gOccluderCoors[2].z = zx + v50;
          gOccluderCoors[2].y = yx + v48;
          gOccluderCoors[3].z = zx + v53;
          gOccluderCoors[3].y = yx + v49;
          gOccluderCoors[4].z = v52 - zx;
          gOccluderCoors[4].y = v54 - yx;
          gOccluderCoors[5].x = (float)((float)(v.x - v1.x) + v2.x) - xx;
          gOccluderCoors[5].y = v47 - yx;
          gOccluderCoors[5].z = v51 - zx;
          gOccluderCoors[6].x = (float)((float)(v.x + v1.x) - v2.x) - xx;
          gOccluderCoors[6].y = v48 - yx;
          gOccluderCoors[6].z = v50 - zx;
          gOccluderCoors[7].x = (float)((float)(v.x - v1.x) - v2.x) - xx;
          gOccluderCoors[7].y = v49 - yx;
          gOccluderCoors[7].z = v53 - zx;
          do
          {
            v55 = *(_QWORD *)&gOccluderCoors[v26].x;
            v83.z = gOccluderCoors[v26].z;
            *(_QWORD *)&v83.x = v55;
            operator*((CVector *)&v84, &TheCamera.m_viewMatrix, &v83);
            v56 = *(_QWORD *)&v84.xx;
            v57 = &gOccluderCoorsOnScreen[v26];
            v57->z = v84.zx;
            *(_QWORD *)&v57->x = v56;
            v58 = gOccluderCoorsOnScreen[v26].z;
            if ( v58 <= 1.0 )
            {
              v62 = 0;
            }
            else
            {
              v59 = 1.0 / v58;
              v60 = &gOccluderCoorsOnScreen[v26];
              v61 = gOccluderCoorsOnScreen[v26].y;
              v60->x = gOccluderCoorsOnScreen[v26].x * (float)(v59 * (float)RsGlobal.screenWidth);
              v60->y = v61 * (float)(v59 * (float)RsGlobal.screenHeight);
              v62 = 1;
            }
            ++v26;
            *v38++ = v62;
          }
          while ( v26 != 8 );
          v63 = (COccluder *)v90;
          v64 = (COccluder *)v92;
          if ( v90 != v92 )
          {
            v3 = 0;
            v62 = COccluder::ProcessLineSegment((COccluder *)v62, 0, 4, v82);
            if ( v62 )
              goto LABEL_50;
          }
          v65 = (COccluder *)v93;
          if ( v63 == (COccluder *)v93 || !COccluder::ProcessLineSegment((COccluder *)v62, 2, 6, v82) )
          {
            if ( v63 != v81 )
            {
              v3 = 0;
              if ( COccluder::ProcessLineSegment(v81, 0, 2, v82) )
                goto LABEL_50;
            }
            v67 = (_BOOL4)v80;
            if ( v63 == v80 || !(v67 = COccluder::ProcessLineSegment(v80, 4, 6, v82)) )
            {
              v68 = (COccluder *)v91;
              if ( ((COccluder *)v91 == v64 || !(v67 = COccluder::ProcessLineSegment((COccluder *)v67, 1, 5, v82)))
                && (v68 == v65 || !COccluder::ProcessLineSegment((COccluder *)v67, 3, 7, v82))
                && (v68 == v81 || !COccluder::ProcessLineSegment(v81, 1, 3, v82))
                && (v68 == v80 || !COccluder::ProcessLineSegment(v80, 5, 7, v82)) )
              {
                if ( v64 != v81 )
                {
                  v3 = 0;
                  if ( COccluder::ProcessLineSegment(v81, 0, 1, v82) )
                    goto LABEL_50;
                }
                if ( (v65 == v81 || !COccluder::ProcessLineSegment(v81, 2, 3, v82))
                  && (v65 == v80 || !COccluder::ProcessLineSegment(v80, 6, 7, v82))
                  && (v64 == v80 || !COccluder::ProcessLineSegment(v80, 4, 5, v82))
                  && (float)(gMaxXInOccluder - gMinXInOccluder) >= (float)((float)RsGlobal.screenWidth * 0.15) )
                {
                  v3 = 0;
                  if ( (float)(gMaxYInOccluder - gMinYInOccluder) >= (float)((float)RsGlobal.screenHeight * 0.1) )
                  {
                    v69 = &v89;
                    v82->FacesUsed = 0;
                    v70 = 1;
                    if ( !((_DWORD)v63 << 24) )
                      goto LABEL_75;
                    while ( 1 )
                    {
                      v71 = *(_QWORD *)&v69->xx;
                      v84.zx = v69->zx;
                      v72 = v84.zx;
                      *(_QWORD *)&v84.xx = v71;
                      v73 = v.z;
                      v74 = v71;
                      v75 = v.x;
                      v76 = v.y;
                      CVector::Normalise((CVector *)&v84);
                      v77 = *(_QWORD *)&v84.xx;
                      v78 = (char *)v82 + 12 * v82->FacesUsed;
                      *((_DWORD *)v78 + 33) = LODWORD(v84.zx);
                      *(_QWORD *)(v78 + 124) = v77;
                      v82->FaceOffset[v82->FacesUsed++] = (float)((float)((float)(v75 + *(float *)&v74) * v84.xx)
                                                                + (float)((float)(v76 + *((float *)&v74 + 1)) * v84.yx))
                                                        + (float)((float)(v73 + v72) * v84.zx);
                      if ( v70 == 6 )
                        break;
                      while ( 1 )
                      {
                        v79 = *(&v90 + v70);
                        v69 = (CMatrix *)((char *)v69 + 12);
                        ++v70;
                        if ( v79 << 24 )
                          break;
LABEL_75:
                        if ( v70 == 6 )
                          goto LABEL_76;
                      }
                    }
LABEL_76:
                    v3 = 1;
                  }
                  goto LABEL_50;
                }
              }
            }
          }
          goto LABEL_25;
        }
        if ( (float)((float)this->iWidth * 0.25) != 0.0 )
        {
          if ( (float)((float)this->iHeight * 0.25) == 0.0 )
          {
            v84.xx = 0.0;
            v84.zx = 0.0;
            v84.yx = v10 * 0.5;
            operator*((CVector *)&v89, &m, (const CVector *)&v84);
            v1.z = v89.zx;
            *(_QWORD *)&v1.x = *(_QWORD *)&v89.xx;
            v25 = (float)this->iWidth;
            v84.yx = 0.0;
            v84.zx = 0.0;
            v84.xx = (float)(v25 * 0.25) * 0.5;
            operator*((CVector *)&v89, &m, (const CVector *)&v84);
            v2.z = v89.zx;
            *(_QWORD *)&v2.x = *(_QWORD *)&v89.xx;
          }
          goto LABEL_11;
        }
        v11 = 0.5;
        v84.xx = 0.0;
        v84.zx = 0.0;
        v84.yx = v10 * 0.5;
        operator*((CVector *)&v89, &m, (const CVector *)&v84);
        v1.z = v89.zx;
        *(_QWORD *)&v1.x = *(_QWORD *)&v89.xx;
        iHeight = (float)this->iHeight;
        v84.xx = 0.0;
        v84.yx = 0.0;
      }
      v84.zx = (float)(iHeight * 0.25) * v11;
      operator*((CVector *)&v89, &m, (const CVector *)&v84);
      v2.z = v89.zx;
      *(_QWORD *)&v2.x = *(_QWORD *)&v89.xx;
LABEL_11:
      gOccluderCoors[0].x = (float)(v.x + v1.x) + v2.x;
      gOccluderCoors[0].y = (float)(v.y + v1.y) + v2.y;
      gOccluderCoors[0].z = (float)(v.z + v1.z) + v2.z;
      gOccluderCoors[1].x = (float)(v.x - v1.x) + v2.x;
      gOccluderCoors[1].y = (float)(v.y - v1.y) + v2.y;
      gOccluderCoors[1].z = (float)(v.z - v1.z) + v2.z;
      gOccluderCoors[2].x = (float)(v.x - v1.x) - v2.x;
      gOccluderCoors[2].y = (float)(v.y - v1.y) - v2.y;
      gOccluderCoors[2].z = (float)(v.z - v1.z) - v2.z;
      gOccluderCoors[3].x = (float)(v.x + v1.x) - v2.x;
      gOccluderCoors[3].y = (float)(v.y + v1.y) - v2.y;
      gOccluderCoors[3].z = (float)(v.z + v1.z) - v2.z;
      v84.zx = (float)(v.z + v1.z) + v2.z;
      *(_QWORD *)&v84.xx = *(_QWORD *)&gOccluderCoors[0].x;
      operator*((CVector *)&v89, &TheCamera.m_viewMatrix, (const CVector *)&v84);
      gOccluderCoorsOnScreen[0].z = v89.zx;
      *(_QWORD *)&gOccluderCoorsOnScreen[0].x = *(_QWORD *)&v89.xx;
      if ( v89.zx <= 1.0 )
      {
        v14 = 0;
      }
      else
      {
        gOccluderCoorsOnScreen[0].x = gOccluderCoorsOnScreen[0].x
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenWidth);
        gOccluderCoorsOnScreen[0].y = gOccluderCoorsOnScreen[0].y
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenHeight);
        v14 = 1;
      }
      gOccluderCoorsValid[0] = v14;
      v84.zx = gOccluderCoors[1].z;
      *(_QWORD *)&v84.xx = *(_QWORD *)&gOccluderCoors[1].x;
      operator*((CVector *)&v89, &TheCamera.m_viewMatrix, (const CVector *)&v84);
      gOccluderCoorsOnScreen[1].z = v89.zx;
      *(_QWORD *)&gOccluderCoorsOnScreen[1].x = *(_QWORD *)&v89.xx;
      if ( v89.zx <= 1.0 )
      {
        v15 = 0;
      }
      else
      {
        gOccluderCoorsOnScreen[1].x = gOccluderCoorsOnScreen[1].x
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenWidth);
        gOccluderCoorsOnScreen[1].y = gOccluderCoorsOnScreen[1].y
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenHeight);
        v15 = 1;
      }
      gOccluderCoorsValid[1] = v15;
      v84.zx = gOccluderCoors[2].z;
      *(_QWORD *)&v84.xx = *(_QWORD *)&gOccluderCoors[2].x;
      operator*((CVector *)&v89, &TheCamera.m_viewMatrix, (const CVector *)&v84);
      gOccluderCoorsOnScreen[2].z = v89.zx;
      *(_QWORD *)&gOccluderCoorsOnScreen[2].x = *(_QWORD *)&v89.xx;
      if ( v89.zx <= 1.0 )
      {
        v16 = 0;
      }
      else
      {
        gOccluderCoorsOnScreen[2].x = gOccluderCoorsOnScreen[2].x
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenWidth);
        gOccluderCoorsOnScreen[2].y = gOccluderCoorsOnScreen[2].y
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenHeight);
        v16 = 1;
      }
      gOccluderCoorsValid[2] = v16;
      v84.zx = gOccluderCoors[3].z;
      *(_QWORD *)&v84.xx = *(_QWORD *)&gOccluderCoors[3].x;
      operator*((CVector *)&v89, &TheCamera.m_viewMatrix, (const CVector *)&v84);
      gOccluderCoorsOnScreen[3].z = v89.zx;
      *(_QWORD *)&gOccluderCoorsOnScreen[3].x = *(_QWORD *)&v89.xx;
      if ( v89.zx <= 1.0 )
      {
        v17 = 0;
      }
      else
      {
        gOccluderCoorsOnScreen[3].x = gOccluderCoorsOnScreen[3].x
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenWidth);
        gOccluderCoorsOnScreen[3].y = gOccluderCoorsOnScreen[3].y
                                    * (float)((float)(1.0 / v89.zx) * (float)RsGlobal.screenHeight);
        v17 = (COccluder *)(&dword_0 + 1);
      }
      v3 = 0;
      gOccluderCoorsValid[3] = (char)v17;
      if ( COccluder::ProcessLineSegment(v17, 0, 1, pActive) )
        goto LABEL_50;
      if ( !COccluder::ProcessLineSegment(0, 1, 2, pActive) )
      {
        v3 = 0;
        if ( COccluder::ProcessLineSegment(0, 2, 3, pActive) || COccluder::ProcessLineSegment(0, 3, 0, pActive) )
          goto LABEL_50;
        if ( (float)(gMaxXInOccluder - gMinXInOccluder) >= (float)((float)RsGlobal.screenWidth * 0.1)
          && (float)(gMaxYInOccluder - gMinYInOccluder) >= (float)((float)RsGlobal.screenHeight * 0.07) )
        {
          CrossProduct((CVector *)&v89, &v1, &v2);
          CVector::Normalise((CVector *)&v89);
          v18 = *(_QWORD *)&v89.xx;
          v3 = 1;
          v19 = v.x;
          v20 = v.y;
          v21 = v.z;
          pActive->FaceNormals[0].z = v89.zx;
          *(_QWORD *)&pActive->FaceNormals[0].x = v18;
          v22 = v19 * v89.xx;
          v23 = v89.zx;
          v24 = v20 * v89.yx;
          pActive->FacesUsed = 1;
          pActive->FaceOffset[0] = (float)(v22 + v24) + (float)(v21 * v23);
          goto LABEL_50;
        }
      }
LABEL_25:
      v3 = 0;
LABEL_50:
      CMatrix::~CMatrix(&m);
      CMatrix::~CMatrix(&v86);
      CMatrix::~CMatrix(&v87);
      CMatrix::~CMatrix(&v88);
    }
  }
  return v3;
}
// 0: using guessed type int dword_0;

//----- (005AFBB8) --------------------------------------------------------
bool __fastcall COcclusion::OccluderHidesBehind(CActiveOccluder *pTestOcc, CActiveOccluder *pHideOcc)
{
  int LinesUsed; // lr
  int v3; // r3
  float *p_DeltaX; // r12
  int v5; // r8
  int v6; // r6
  float *p_BaseX; // r2
  float *v8; // r1
  float *v9; // r4
  float *v10; // r5
  float v11; // s0
  float v12; // s2
  float *v13; // r2
  float v14; // s4
  float v15; // s10
  float v16; // s8
  bool v17; // r1

  LinesUsed = pTestOcc->LinesUsed;
  if ( !pTestOcc->LinesUsed )
    return pHideOcc->LinesUsed == 0;
  if ( LinesUsed < 1 )
    return 1;
  v3 = pHideOcc->LinesUsed;
  p_DeltaX = &pHideOcc->Lines[0].DeltaX;
  v5 = 0;
  while ( v3 < 1 )
  {
LABEL_9:
    ++v5;
    v17 = 1;
    if ( v5 >= LinesUsed )
      return v17;
  }
  v6 = 0;
  p_BaseX = &pTestOcc->Lines[v5].BaseX;
  v8 = p_BaseX + 3;
  v9 = p_BaseX + 4;
  v10 = p_BaseX + 2;
  v11 = *p_BaseX;
  v12 = p_BaseX[1];
  v13 = p_DeltaX;
  while ( 1 )
  {
    v14 = *(v13 - 2);
    v15 = *(v13 - 1);
    v16 = v13[1];
    if ( (float)((float)(v16 * (float)(v11 - v14)) - (float)(*v13 * (float)(v12 - v15))) < 0.0
      || (float)((float)(v16 * (float)((float)(v11 + (float)(*v10 * *v9)) - v14))
               - (float)(*v13 * (float)((float)(v12 + (float)(*v9 * *v8)) - v15))) < 0.0 )
    {
      return 0;
    }
    ++v6;
    v13 += 5;
    if ( v6 >= v3 )
      goto LABEL_9;
  }
}

//----- (005AFC98) --------------------------------------------------------
bool __fastcall COccluder::ProcessLineSegment(COccluder *this, Int32 Pnt1, Int32 Pnt2, CActiveOccluder *pActive)
{
  float32x2_t v4; // d4
  float32x2_t v5; // d5
  float32x2_t v6; // d6
  float32x2_t v7; // d7
  float32x2_t v11; // d8
  float32x2_t v12; // d0
  COccVector *v13; // r5
  float z; // s16
  COccVector *v15; // r4
  float v16; // s0
  float v17; // s0
  RwReal v18; // s6
  RwReal v19; // s4
  RwReal v20; // s0
  COccVector *v21; // r5
  float v22; // s18
  COccVector *v23; // r6
  float v24; // s0
  float v25; // s0
  RwReal v26; // s6
  RwReal v27; // s4
  RwReal v28; // s0
  float v29; // s2
  float v30; // s4
  float32x2_t v31; // d17
  float32x2_t v32; // d16
  float32x2_t v33; // d19
  float v34; // s0
  COcclusionLine *v36; // r0
  float Length; // s6
  float v38; // s2
  float v39; // s4
  float screenWidth; // s6
  float v41; // s8
  float v42; // s14
  float v43; // s10
  float v44; // s3
  CVector v45; // [sp+0h] [bp-58h] BYREF
  CVector v; // [sp+Ch] [bp-4Ch] BYREF
  CVector v47; // [sp+18h] [bp-40h] BYREF

  if ( gOccluderCoorsValid[Pnt1] )
  {
    v11.n64_u64[0] = *(unsigned __int64 *)&gOccluderCoorsOnScreen[Pnt1].x;
  }
  else
  {
    if ( !gOccluderCoorsValid[Pnt2] )
      return 1;
    v13 = &gOccluderCoors[Pnt1];
    operator*(&v47, &TheCamera.m_viewMatrix, v13);
    z = v47.z;
    v15 = &gOccluderCoors[Pnt2];
    operator*(&v47, &TheCamera.m_viewMatrix, v15);
    v16 = fabsf(v47.z + -1.1);
    v17 = v16 / (float)(fabsf(z + -1.1) + v16);
    v18 = (float)(v13->y * v17) + (float)((float)(1.0 - v17) * v15->y);
    v19 = (float)(v13->x * v17) + (float)(v15->x * (float)(1.0 - v17));
    v20 = (float)(v13->z * v17) + (float)((float)(1.0 - v17) * v15->z);
    v.y = v18;
    v.x = v19;
    v.z = v20;
    operator*(&v47, &TheCamera.m_viewMatrix, &v);
    if ( v47.z <= 1.0 )
      return 1;
    v11.n64_u64[0] = vmul_f32(
                       *(float32x2_t *)&v47.x,
                       vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v47.z)).n64_u64[0];
  }
  if ( gOccluderCoorsValid[Pnt2] )
  {
    v12.n64_u64[0] = *(unsigned __int64 *)&gOccluderCoorsOnScreen[Pnt2].x;
    goto LABEL_10;
  }
  v21 = &gOccluderCoors[Pnt1];
  operator*(&v47, &TheCamera.m_viewMatrix, v21);
  v22 = v47.z;
  v23 = &gOccluderCoors[Pnt2];
  operator*(&v47, &TheCamera.m_viewMatrix, v23);
  v24 = fabsf(v47.z + -1.1);
  v25 = v24 / (float)(fabsf(v22 + -1.1) + v24);
  v26 = (float)(v21->y * v25) + (float)((float)(1.0 - v25) * v23->y);
  v27 = (float)(v21->x * v25) + (float)(v23->x * (float)(1.0 - v25));
  v28 = (float)(v21->z * v25) + (float)((float)(1.0 - v25) * v23->z);
  v45.y = v26;
  v45.x = v27;
  v45.z = v28;
  operator*(&v47, &TheCamera.m_viewMatrix, &v45);
  if ( v47.z <= 1.0 )
    return 1;
  v12.n64_u64[0] = vmul_f32(
                     *(float32x2_t *)&v47.x,
                     vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v47.z)).n64_u64[0];
LABEL_10:
  v29 = v12.n64_f32[0] - v11.n64_f32[0];
  v5.n64_u32[0] = v11.n64_u32[1];
  v30 = v12.n64_f32[1] - v11.n64_f32[1];
  v7.n64_f32[0] = gMaxYInOccluder;
  v31.n64_u64[0] = vmax_f32(v7, v5).n64_u64[0];
  v6.n64_f32[0] = gMinYInOccluder;
  v32.n64_u64[0] = vmin_f32(v6, v5).n64_u64[0];
  v5.n64_f32[0] = gMinXInOccluder;
  v4.n64_f32[0] = gMaxXInOccluder;
  v33.n64_u64[0] = vmax_f32(v4, v11).n64_u64[0];
  v4.n64_u32[0] = v12.n64_u32[1];
  LODWORD(gMinXInOccluder) = vmin_f32(vmin_f32(v5, v11), v12).n64_u32[0];
  LODWORD(gMaxXInOccluder) = vmax_f32(v33, v12).n64_u32[0];
  LODWORD(gMaxYInOccluder) = vmax_f32(v31, v4).n64_u32[0];
  LODWORD(gMinYInOccluder) = vmin_f32(v32, v4).n64_u32[0];
  if ( (float)((float)((float)(v12.n64_f32[1] - v11.n64_f32[1]) * (float)(gCenterOnScreen.x - v11.n64_f32[0]))
             - (float)((float)(v12.n64_f32[0] - v11.n64_f32[0]) * (float)(gCenterOnScreen.y - v11.n64_f32[1]))) < 0.0 )
  {
    v34 = v11.n64_f32[1] + v30;
    v11.n64_f32[0] = v11.n64_f32[0] + v29;
    v30 = -v30;
    v29 = -v29;
  }
  else
  {
    v34 = v11.n64_f32[1];
  }
  pActive->Lines[pActive->LinesUsed].Length = sqrtf((float)(v29 * v29) + (float)(v30 * v30));
  v36 = &pActive->Lines[pActive->LinesUsed];
  Length = v36->Length;
  LODWORD(v36->BaseX) = v11.n64_u32[0];
  v38 = v29 / Length;
  v39 = v30 / Length;
  pActive->Lines[pActive->LinesUsed].BaseY = v34;
  pActive->Lines[pActive->LinesUsed].DeltaX = v38;
  pActive->Lines[pActive->LinesUsed].DeltaY = v39;
  screenWidth = (float)RsGlobal.screenWidth;
  if ( v11.n64_f32[0] <= 0.0 || v11.n64_f32[0] >= screenWidth || v34 >= (float)RsGlobal.screenHeight )
  {
    v41 = v39 * (float)(screenWidth - v11.n64_f32[0]);
    v42 = (float)(0.0 - v11.n64_f32[0]) * v39;
    v43 = (float)(0.0 - v34) * v38;
    if ( (float)((float)(v42 - v43) * (float)(v41 - v43)) >= 0.0 )
    {
      v44 = v38 * (float)((float)RsGlobal.screenHeight - v34);
      if ( (float)((float)(v42 - v43) * (float)(v42 - v44)) >= 0.0
        && (float)((float)(v41 - v43) * (float)(v41 - v44)) >= 0.0 )
      {
        return (float)((float)(v39 * (float)((float)(screenWidth * 0.5) - v11.n64_f32[0]))
                     - (float)(v38 * (float)((float)((float)RsGlobal.screenHeight * 0.5) - v34))) < 0.0;
      }
    }
  }
  ++pActive->LinesUsed;
  return 0;
}
// 5AFF10: variable 'v7' is possibly undefined
// 5AFF10: variable 'v5' is possibly undefined
// 5AFF20: variable 'v6' is possibly undefined
// 5AFF38: variable 'v4' is possibly undefined

//----- (005B0148) --------------------------------------------------------
bool __fastcall CActiveOccluder::IsPointWithinOcclusionArea(
        CActiveOccluder *this,
        float PointX,
        float PointY,
        float Radius)
{
  int LinesUsed; // r12
  float *p_DeltaX; // r0
  int i; // r1

  LinesUsed = this->LinesUsed;
  if ( LinesUsed < 1 )
    return 1;
  p_DeltaX = &this->Lines[0].DeltaX;
  for ( i = 0; i < LinesUsed; ++i )
  {
    if ( (float)((float)((float)(PointX - *(p_DeltaX - 2)) * p_DeltaX[1])
               - (float)((float)(PointY - *(p_DeltaX - 1)) * *p_DeltaX)) < Radius )
      return 0;
    p_DeltaX += 5;
  }
  return 1;
}

//----- (005B01A8) --------------------------------------------------------
int __fastcall CActiveOccluder::IsPointBehindOccluder(CActiveOccluder *this, CVector Pos, float Radius)
{
  int FacesUsed; // r12
  CVector *FaceNormals; // lr
  float x; // s2
  float *FaceOffset; // r4
  CSimpleTransform *p_tx; // r1
  int result; // r0
  float v9; // s8
  float y; // s10
  float z; // s12
  int v12; // r1
  float v13; // s3
  float v14; // s1
  float v15; // s7

  FacesUsed = this->FacesUsed;
  if ( FacesUsed < 1 )
    return 1;
  FaceNormals = this->FaceNormals;
  x = Pos.x;
  FaceOffset = this->FaceOffset;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  result = 0;
  v9 = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  v12 = 0;
  while ( 1 )
  {
    v13 = FaceNormals->y;
    v14 = FaceNormals->z;
    v15 = (float)((float)((float)(FaceNormals->x * x) + (float)(v13 * Pos.y)) + (float)(v14 * Pos.z)) - *FaceOffset;
    if ( fabsf(v15) < Radius
      || (float)(v15
               * (float)((float)((float)((float)(FaceNormals->x * v9) + (float)(v13 * y)) + (float)(v14 * z))
                       - *FaceOffset)) >= 0.0 )
    {
      break;
    }
    ++v12;
    ++FaceNormals;
    ++FaceOffset;
    if ( v12 >= FacesUsed )
      return 1;
  }
  return result;
}

//----- (005B0268) --------------------------------------------------------
bool __fastcall CEntity::IsEntityOccluded(CEntity *this)
{
  float32x2_t v1; // d4
  float32x2_t v2; // d6
  CVector *v4; // r4
  float z; // s18
  int v6; // r8
  float v7; // s2
  CColModel *m_pColModel; // r2
  CActiveOccluder *v9; // r11
  float *p_DeltaX; // r10
  float *FaceOffset; // r12
  CVector *FaceNormals; // lr
  float v13; // s10
  float m_fRadius; // s0
  float v15; // s22
  float v16; // s20
  float v17; // s24
  CActiveOccluder *v18; // r1
  CVector *v19; // r6
  int LinesUsed; // r0
  int v21; // r1
  float *v22; // r3
  int FacesUsed; // r1
  CSimpleTransform *p_tx; // r5
  int v25; // r3
  float x; // s8
  float *v27; // r4
  float y; // s10
  float v29; // s12
  float *i; // r5
  float v31; // s3
  float v32; // s1
  float v33; // s7
  int v34; // r1
  float *v35; // r3
  CMatrix *m_pMat; // r1
  float v37; // s0
  int v38; // r0
  float32x2_t *v39; // r2
  int v40; // r1
  float32x2_t v41; // d16
  float32x2_t v42; // d0
  unsigned __int64 v43; // d0
  int v44; // r0
  CSimpleTransform *v45; // r2
  int v46; // r1
  float v47; // s6
  float *v48; // r3
  float v49; // s8
  float v50; // s10
  float *p_x; // r2
  int v52; // r5
  CMatrix *v53; // r1
  float v54; // s0
  int v55; // r0
  float32x2_t *v56; // r2
  int v57; // r1
  float32x2_t v58; // d16
  float32x2_t v59; // d0
  unsigned __int64 v60; // d0
  int v61; // r0
  CSimpleTransform *v62; // r2
  int v63; // r1
  float v64; // s6
  float *v65; // r3
  float v66; // s8
  float v67; // s10
  float *v68; // r2
  int v69; // r5
  CMatrix *v70; // r1
  CColModel *v71; // r0
  __int64 v72; // kr00_8
  float v73; // s0
  int v74; // r0
  float32x2_t *v75; // r2
  int v76; // r1
  float32x2_t v77; // d16
  float32x2_t v78; // d0
  unsigned __int64 v79; // d0
  int v80; // r0
  CSimpleTransform *v81; // r2
  int v82; // r1
  float v83; // s6
  float *v84; // r3
  float v85; // s8
  float v86; // s10
  float *v87; // r2
  int v88; // r5
  CMatrix *v89; // r1
  CColModel *v90; // r0
  __int64 v91; // r2
  float v92; // s0
  int v93; // r0
  float32x2_t *v94; // r2
  int v95; // r1
  float32x2_t v96; // d16
  float32x2_t v97; // d0
  unsigned __int64 v98; // d0
  CActiveOccluder *v99; // r6
  int v100; // r0
  Int8 *p_FacesUsed; // r6
  int v102; // t1
  CSimpleTransform *v103; // r2
  int v104; // r1
  float v105; // s6
  float *v106; // r3
  float v107; // s8
  float v108; // s10
  float *v109; // r2
  CColModel *v110; // r0
  CMatrix *v111; // r1
  __int64 v112; // r2
  RwReal v113; // r0
  float v114; // s0
  int v115; // r0
  float32x2_t *v116; // r2
  int v117; // r1
  float32x2_t v118; // d16
  float32x2_t v119; // d0
  unsigned __int64 v120; // d0
  int v121; // r0
  CSimpleTransform *v122; // r2
  int v123; // r1
  float v124; // s6
  float *v125; // r3
  float v126; // s8
  float v127; // s10
  float *v128; // r2
  int v129; // r5
  CMatrix *v130; // r1
  CColModel *v131; // r0
  RwReal v132; // r2
  RwReal v133; // r3
  RwReal v134; // r0
  float v135; // s0
  int v136; // r0
  float32x2_t *v137; // r2
  int v138; // r1
  float32x2_t v139; // d16
  float32x2_t v140; // d0
  unsigned __int64 v141; // d0
  int v142; // r0
  CSimpleTransform *v143; // r2
  int v144; // r1
  float v145; // s6
  float *v146; // r3
  float v147; // s8
  float v148; // s10
  float *j; // r2
  const CSimpleTransform *p_m_transform; // [sp+7Ch] [bp-ACh]
  Int8 *p_LinesUsed; // [sp+84h] [bp-A4h]
  float *v153; // [sp+8Ch] [bp-9Ch]
  CVector v154; // [sp+9Ch] [bp-8Ch] BYREF
  CVector v; // [sp+A8h] [bp-80h] BYREF
  CVector centre; // [sp+B4h] [bp-74h] BYREF
  CVector v157; // [sp+C0h] [bp-68h] BYREF

  CEntity::GetBoundCentre(this, &centre);
  if ( COcclusion::NumActiveOccluders )
  {
    v4 = &v157;
    operator*(&v157, &TheCamera.m_viewMatrix, &centre);
    z = v157.z;
    if ( v157.z > 1.0 && COcclusion::NumActiveOccluders >= 1 )
    {
      v6 = 0;
      v7 = (float)(1.0 / v157.z) * (float)RsGlobal.screenWidth;
      m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
      v9 = COcclusion::aActiveOccluders;
      p_DeltaX = &COcclusion::aActiveOccluders[0].Lines[0].DeltaX;
      FaceOffset = COcclusion::aActiveOccluders[0].FaceOffset;
      FaceNormals = COcclusion::aActiveOccluders[0].FaceNormals;
      v13 = (float)(1.0 / v157.z) * (float)RsGlobal.screenHeight;
      m_fRadius = m_pColModel->m_sphereBound.m_fRadius;
      p_m_transform = &this->m_transform;
      v15 = v157.x * v7;
      v2.n64_f32[0] = v13 * (float)(70.0 / CDraw::ms_fFOV);
      v1.n64_f32[0] = v7 * (float)(70.0 / CDraw::ms_fFOV);
      v16 = v157.y * v13;
      v17 = (float)(vmax_f32(v1, v2).n64_f32[0] * m_fRadius) * 0.9;
      while ( 1 )
      {
        if ( (float)(z - m_fRadius) <= (float)COcclusion::aActiveOccluders[v6].DistToCam )
          goto LABEL_117;
        v18 = &COcclusion::aActiveOccluders[v6];
        v19 = v4;
        LinesUsed = v18->LinesUsed;
        p_LinesUsed = &v18->LinesUsed;
        if ( LinesUsed < 1 )
        {
LABEL_11:
          FacesUsed = COcclusion::aActiveOccluders[v6].FacesUsed;
          if ( FacesUsed < 1 )
            return 1;
          p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            p_tx = &TheCamera.m_transform;
          v25 = 0;
          x = p_tx->m_translate.x;
          v27 = FaceOffset;
          y = p_tx->m_translate.y;
          v29 = p_tx->m_translate.z;
          for ( i = &FaceNormals->x; ; i += 3 )
          {
            v31 = i[1];
            v32 = i[2];
            v33 = (float)((float)((float)(centre.x * *i) + (float)(centre.y * v31)) + (float)(centre.z * v32)) - *v27;
            if ( fabsf(v33) < m_fRadius
              || (float)(v33 * (float)((float)((float)((float)(x * *i) + (float)(y * v31)) + (float)(v29 * v32)) - *v27)) >= 0.0 )
            {
              break;
            }
            ++v25;
            ++v27;
            if ( v25 >= FacesUsed )
              return 1;
          }
        }
        else
        {
          v21 = 0;
          v22 = p_DeltaX;
          while ( (float)((float)((float)(v15 - *(v22 - 2)) * v22[1]) - (float)((float)(v16 - *(v22 - 1)) * *v22)) >= v17 )
          {
            ++v21;
            v22 += 5;
            if ( v21 >= LinesUsed )
              goto LABEL_11;
          }
        }
        v4 = v19;
        if ( LinesUsed >= 1 )
        {
          v34 = 0;
          v35 = p_DeltaX;
          while ( (float)((float)((float)(v15 - *(v35 - 2)) * v35[1]) - (float)((float)(v16 - *(v35 - 1)) * *v35)) >= 0.0 )
          {
            ++v34;
            v35 += 5;
            if ( v34 >= LinesUsed )
              goto LABEL_23;
          }
          goto LABEL_117;
        }
LABEL_23:
        v153 = FaceOffset;
        m_pMat = this->m_pMat;
        if ( !m_pMat )
        {
          CPlaceable::AllocateMatrix(this);
          CSimpleTransform::UpdateMatrix(p_m_transform, this->m_pMat);
          m_pMat = this->m_pMat;
          m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        }
        operator*(&v, m_pMat, &m_pColModel->m_boxBound.m_vecMin);
        operator*(v19, &TheCamera.m_viewMatrix, &v);
        v37 = v19->z;
        if ( v37 > 1.0 )
        {
          v38 = *p_LinesUsed;
          if ( v38 < 1 )
          {
LABEL_30:
            v44 = COcclusion::aActiveOccluders[v6].FacesUsed;
            if ( v44 < 1 )
            {
LABEL_36:
              v52 = 0;
              goto LABEL_38;
            }
            v45 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              v45 = &TheCamera.m_transform;
            v46 = 0;
            v47 = v45->m_translate.x;
            v48 = v153;
            v49 = v45->m_translate.y;
            v50 = v45->m_translate.z;
            p_x = &FaceNormals->x;
            while ( (float)((float)((float)((float)((float)(v.x * *p_x) + (float)(v.y * p_x[1])) + (float)(v.z * p_x[2]))
                                  - *v48)
                          * (float)((float)((float)((float)(v47 * *p_x) + (float)(v49 * p_x[1])) + (float)(v50 * p_x[2]))
                                  - *v48)) < 0.0 )
            {
              ++v46;
              p_x += 3;
              ++v48;
              if ( v46 >= v44 )
                goto LABEL_36;
            }
          }
          else
          {
            v39 = (float32x2_t *)v9;
            v40 = 0;
            v41.n64_u64[0] = vmul_f32(
                               *(float32x2_t *)&v19->x,
                               vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v37)).n64_u64[0];
            while ( 1 )
            {
              v42.n64_u32[0] = v39[1].n64_u32[1];
              v42.n64_u32[1] = v39[1].n64_u32[0];
              v43 = vmul_f32(vsub_f32(v41, (float32x2_t)v39->n64_u64[0]), v42).n64_u64[0];
              if ( (float)(*(float *)&v43 - *((float *)&v43 + 1)) < 0.0 )
                break;
              ++v40;
              v39 = (float32x2_t *)((char *)v39 + 20);
              if ( v40 >= v38 )
                goto LABEL_30;
            }
          }
        }
        v52 = 1;
LABEL_38:
        v53 = this->m_pMat;
        if ( !v53 )
        {
          CPlaceable::AllocateMatrix(this);
          CSimpleTransform::UpdateMatrix(p_m_transform, this->m_pMat);
          v53 = this->m_pMat;
        }
        operator*(v19, v53, &CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax);
        v = v157;
        if ( !v52 )
        {
          operator*(v19, &TheCamera.m_viewMatrix, &v);
          v54 = v19->z;
          if ( v54 > 1.0 )
          {
            v55 = *p_LinesUsed;
            if ( v55 < 1 )
            {
LABEL_46:
              v61 = COcclusion::aActiveOccluders[v6].FacesUsed;
              if ( v61 < 1 )
              {
LABEL_52:
                v69 = 0;
                goto LABEL_54;
              }
              v62 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              if ( !TheCamera.m_pMat )
                v62 = &TheCamera.m_transform;
              v63 = 0;
              v64 = v62->m_translate.x;
              v65 = v153;
              v66 = v62->m_translate.y;
              v67 = v62->m_translate.z;
              v68 = &FaceNormals->x;
              while ( (float)((float)((float)((float)((float)(v.x * *v68) + (float)(v.y * v68[1]))
                                            + (float)(v.z * v68[2]))
                                    - *v65)
                            * (float)((float)((float)((float)(v64 * *v68) + (float)(v66 * v68[1]))
                                            + (float)(v67 * v68[2]))
                                    - *v65)) < 0.0 )
              {
                ++v63;
                v68 += 3;
                ++v65;
                if ( v63 >= v61 )
                  goto LABEL_52;
              }
            }
            else
            {
              v56 = (float32x2_t *)v9;
              v57 = 0;
              v58.n64_u64[0] = vmul_f32(
                                 *(float32x2_t *)&v19->x,
                                 vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v54)).n64_u64[0];
              while ( 1 )
              {
                v59.n64_u32[0] = v56[1].n64_u32[1];
                v59.n64_u32[1] = v56[1].n64_u32[0];
                v60 = vmul_f32(vsub_f32(v58, (float32x2_t)v56->n64_u64[0]), v59).n64_u64[0];
                if ( (float)(*(float *)&v60 - *((float *)&v60 + 1)) < 0.0 )
                  break;
                ++v57;
                v56 = (float32x2_t *)((char *)v56 + 20);
                if ( v57 >= v55 )
                  goto LABEL_46;
              }
            }
          }
        }
        v69 = 1;
LABEL_54:
        v70 = this->m_pMat;
        if ( !v70 )
        {
          CPlaceable::AllocateMatrix(this);
          CSimpleTransform::UpdateMatrix(p_m_transform, this->m_pMat);
          v70 = this->m_pMat;
        }
        v71 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        v72 = *(_QWORD *)&v71->m_boxBound.m_vecMax.y;
        v154.x = v71->m_boxBound.m_vecMin.x;
        *(_QWORD *)&v154.y = v72;
        operator*(v19, v70, &v154);
        v = v157;
        if ( !v69 )
        {
          operator*(v19, &TheCamera.m_viewMatrix, &v);
          v73 = v19->z;
          if ( v73 > 1.0 )
          {
            v74 = *p_LinesUsed;
            if ( v74 < 1 )
            {
LABEL_62:
              v80 = COcclusion::aActiveOccluders[v6].FacesUsed;
              if ( v80 < 1 )
              {
LABEL_68:
                v88 = 0;
                goto LABEL_70;
              }
              v81 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              if ( !TheCamera.m_pMat )
                v81 = &TheCamera.m_transform;
              v82 = 0;
              v83 = v81->m_translate.x;
              v84 = v153;
              v85 = v81->m_translate.y;
              v86 = v81->m_translate.z;
              v87 = &FaceNormals->x;
              while ( (float)((float)((float)((float)((float)(v.x * *v87) + (float)(v.y * v87[1]))
                                            + (float)(v.z * v87[2]))
                                    - *v84)
                            * (float)((float)((float)((float)(v83 * *v87) + (float)(v85 * v87[1]))
                                            + (float)(v86 * v87[2]))
                                    - *v84)) < 0.0 )
              {
                ++v82;
                v87 += 3;
                ++v84;
                if ( v82 >= v80 )
                  goto LABEL_68;
              }
            }
            else
            {
              v75 = (float32x2_t *)v9;
              v76 = 0;
              v77.n64_u64[0] = vmul_f32(
                                 *(float32x2_t *)&v19->x,
                                 vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v73)).n64_u64[0];
              while ( 1 )
              {
                v78.n64_u32[0] = v75[1].n64_u32[1];
                v78.n64_u32[1] = v75[1].n64_u32[0];
                v79 = vmul_f32(vsub_f32(v77, (float32x2_t)v75->n64_u64[0]), v78).n64_u64[0];
                if ( (float)(*(float *)&v79 - *((float *)&v79 + 1)) < 0.0 )
                  break;
                ++v76;
                v75 = (float32x2_t *)((char *)v75 + 20);
                if ( v76 >= v74 )
                  goto LABEL_62;
              }
            }
          }
        }
        v88 = 1;
LABEL_70:
        v89 = this->m_pMat;
        if ( !v89 )
        {
          CPlaceable::AllocateMatrix(this);
          CSimpleTransform::UpdateMatrix(p_m_transform, this->m_pMat);
          v89 = this->m_pMat;
        }
        v90 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        v91 = *(_QWORD *)&v90->m_boxBound.m_vecMin.y;
        v154.x = v90->m_boxBound.m_vecMax.x;
        *(_QWORD *)&v154.y = v91;
        operator*(v19, v89, &v154);
        v = v157;
        FaceOffset = v153;
        if ( v88 )
          goto LABEL_117;
        operator*(v19, &TheCamera.m_viewMatrix, &v);
        FaceOffset = v153;
        v92 = v19->z;
        if ( v92 <= 1.0 )
          goto LABEL_117;
        v93 = *p_LinesUsed;
        if ( v93 >= 1 )
        {
          v94 = (float32x2_t *)v9;
          v95 = 0;
          v96.n64_u64[0] = vmul_f32(
                             *(float32x2_t *)&v19->x,
                             vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v92)).n64_u64[0];
          do
          {
            v97.n64_u32[0] = v94[1].n64_u32[1];
            v97.n64_u32[1] = v94[1].n64_u32[0];
            v98 = vmul_f32(vsub_f32(v96, (float32x2_t)v94->n64_u64[0]), v97).n64_u64[0];
            if ( (float)(*(float *)&v98 - *((float *)&v98 + 1)) < 0.0 )
              goto LABEL_117;
            ++v95;
            v94 = (float32x2_t *)((char *)v94 + 20);
          }
          while ( v95 < v93 );
        }
        v99 = &COcclusion::aActiveOccluders[v6];
        v102 = v99->FacesUsed;
        p_FacesUsed = &v99->FacesUsed;
        v100 = v102;
        if ( v102 >= 1 )
        {
          v103 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            v103 = &TheCamera.m_transform;
          v104 = 0;
          v105 = v103->m_translate.x;
          v106 = v153;
          v107 = v103->m_translate.y;
          v108 = v103->m_translate.z;
          v109 = &FaceNormals->x;
          while ( (float)((float)((float)((float)((float)(v.x * *v109) + (float)(v.y * v109[1])) + (float)(v.z * v109[2]))
                                - *v106)
                        * (float)((float)((float)((float)(v105 * *v109) + (float)(v107 * v109[1]))
                                        + (float)(v108 * v109[2]))
                                - *v106)) < 0.0 )
          {
            ++v104;
            v109 += 3;
            ++v106;
            if ( v104 >= v100 )
              goto LABEL_84;
          }
          goto LABEL_117;
        }
LABEL_84:
        v110 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        if ( (float)(v110->m_boxBound.m_vecMax.x - v110->m_boxBound.m_vecMin.x) <= 60.0
          && (float)(v110->m_boxBound.m_vecMax.y - v110->m_boxBound.m_vecMin.y) <= 60.0
          || (float)(v110->m_boxBound.m_vecMax.z - v110->m_boxBound.m_vecMin.z) <= 30.0 )
        {
          return 1;
        }
        v111 = this->m_pMat;
        if ( !v111 )
        {
          CPlaceable::AllocateMatrix(this);
          CSimpleTransform::UpdateMatrix(p_m_transform, this->m_pMat);
          v111 = this->m_pMat;
          v110 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        }
        v112 = *(_QWORD *)&v110->m_boxBound.m_vecMin.x;
        v113 = v110->m_boxBound.m_vecMax.z;
        *(_QWORD *)&v154.x = v112;
        v154.z = v113;
        operator*(v4, v111, &v154);
        v = v157;
        operator*(v4, &TheCamera.m_viewMatrix, &v);
        v114 = v4->z;
        if ( v114 > 1.0 )
        {
          v115 = *p_LinesUsed;
          if ( v115 < 1 )
          {
LABEL_94:
            v121 = *p_FacesUsed;
            if ( v121 < 1 )
            {
LABEL_100:
              v129 = 0;
              goto LABEL_102;
            }
            v122 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              v122 = &TheCamera.m_transform;
            v123 = 0;
            v124 = v122->m_translate.x;
            v125 = v153;
            v126 = v122->m_translate.y;
            v127 = v122->m_translate.z;
            v128 = &FaceNormals->x;
            while ( (float)((float)((float)((float)((float)(v.x * *v128) + (float)(v.y * v128[1]))
                                          + (float)(v.z * v128[2]))
                                  - *v125)
                          * (float)((float)((float)((float)(v124 * *v128) + (float)(v126 * v128[1]))
                                          + (float)(v127 * v128[2]))
                                  - *v125)) < 0.0 )
            {
              ++v123;
              v128 += 3;
              ++v125;
              if ( v123 >= v121 )
                goto LABEL_100;
            }
          }
          else
          {
            v116 = (float32x2_t *)v9;
            v117 = 0;
            v118.n64_u64[0] = vmul_f32(
                                *(float32x2_t *)&v4->x,
                                vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v114)).n64_u64[0];
            while ( 1 )
            {
              v119.n64_u32[0] = v116[1].n64_u32[1];
              v119.n64_u32[1] = v116[1].n64_u32[0];
              v120 = vmul_f32(vsub_f32(v118, (float32x2_t)v116->n64_u64[0]), v119).n64_u64[0];
              if ( (float)(*(float *)&v120 - *((float *)&v120 + 1)) < 0.0 )
                break;
              ++v117;
              v116 = (float32x2_t *)((char *)v116 + 20);
              if ( v117 >= v115 )
                goto LABEL_94;
            }
          }
        }
        v129 = 1;
LABEL_102:
        v130 = this->m_pMat;
        if ( !v130 )
        {
          CPlaceable::AllocateMatrix(this);
          CSimpleTransform::UpdateMatrix(p_m_transform, this->m_pMat);
          v130 = this->m_pMat;
        }
        v131 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        v132 = v131->m_boxBound.m_vecMin.y;
        v133 = v131->m_boxBound.m_vecMax.x;
        v134 = v131->m_boxBound.m_vecMax.z;
        v154.x = v133;
        v154.y = v132;
        v154.z = v134;
        operator*(v4, v130, &v154);
        v = v157;
        FaceOffset = v153;
        if ( !v129 )
        {
          operator*(v4, &TheCamera.m_viewMatrix, &v);
          FaceOffset = v153;
          v135 = v4->z;
          if ( v135 > 1.0 )
          {
            v136 = *p_LinesUsed;
            if ( v136 < 1 )
            {
LABEL_110:
              v142 = *p_FacesUsed;
              if ( v142 < 1 )
                return 1;
              v143 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              if ( !TheCamera.m_pMat )
                v143 = &TheCamera.m_transform;
              v144 = 0;
              v145 = v143->m_translate.x;
              v146 = v153;
              v147 = v143->m_translate.y;
              v148 = v143->m_translate.z;
              for ( j = &FaceNormals->x;
                    (float)((float)((float)((float)((float)(v.x * *j) + (float)(v.y * j[1])) + (float)(v.z * j[2]))
                                  - *v146)
                          * (float)((float)((float)((float)(v145 * *j) + (float)(v147 * j[1])) + (float)(v148 * j[2]))
                                  - *v146)) < 0.0;
                    j += 3 )
              {
                ++v144;
                ++v146;
                if ( v144 >= v142 )
                  return 1;
              }
            }
            else
            {
              v137 = (float32x2_t *)v9;
              v138 = 0;
              v139.n64_u64[0] = vmul_f32(
                                  *(float32x2_t *)&v4->x,
                                  vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v135)).n64_u64[0];
              while ( 1 )
              {
                v140.n64_u32[0] = v137[1].n64_u32[1];
                v140.n64_u32[1] = v137[1].n64_u32[0];
                v141 = vmul_f32(vsub_f32(v139, (float32x2_t)v137->n64_u64[0]), v140).n64_u64[0];
                if ( (float)(*(float *)&v141 - *((float *)&v141 + 1)) < 0.0 )
                  break;
                ++v138;
                v137 = (float32x2_t *)((char *)v137 + 20);
                if ( v138 >= v136 )
                  goto LABEL_110;
              }
            }
          }
        }
LABEL_117:
        if ( ++v6 >= COcclusion::NumActiveOccluders )
          return 0;
        ++v9;
        FaceNormals = (CVector *)((char *)FaceNormals + 172);
        FaceOffset += 43;
        p_DeltaX += 43;
        m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        m_fRadius = m_pColModel->m_sphereBound.m_fRadius;
      }
    }
  }
  return 0;
}
// 5B0370: variable 'v1' is possibly undefined
// 5B0370: variable 'v2' is possibly undefined

//----- (005B0F68) --------------------------------------------------------
int __fastcall COcclusion::IsPositionOccluded(RwReal a1, RwReal a2, RwReal a3, float Radius)
{
  float32x2_t v4; // d3
  Int32 v9; // r4
  CActiveOccluder *v10; // r2
  float v11; // s10
  float *FaceOffset; // r9
  float v13; // s8
  float32x2_t v14; // d17
  float32x2_t v15; // d1
  CSimpleTransform *p_tx; // r11
  float32x2_t v17; // d16
  CVector *FaceNormals; // r3
  float v19; // s2
  float v20; // s6
  float v21; // s2
  int LinesUsed; // r0
  int v23; // r1
  float32x2_t *v24; // r5
  float32x2_t v25; // d6
  unsigned __int64 v26; // d6
  int FacesUsed; // r0
  int v28; // r1
  float *p_x; // r5
  float *i; // r6
  float v31; // s7
  float v32; // s5
  float v33; // s11
  int result; // r0
  CVector v; // [sp+4h] [bp-34h] BYREF
  CVector v36; // [sp+10h] [bp-28h] BYREF

  if ( COcclusion::NumActiveOccluders )
  {
    v.x = a1;
    v.y = a2;
    v.z = a3;
    operator*(&v36, &TheCamera.m_viewMatrix, &v);
    if ( v36.z > 1.0 && COcclusion::NumActiveOccluders >= 1 )
    {
      v9 = 0;
      v10 = COcclusion::aActiveOccluders;
      v11 = a1;
      FaceOffset = COcclusion::aActiveOccluders[0].FaceOffset;
      v13 = a2;
      v14.n64_u64[0] = vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&RsGlobal.screenWidth), 1.0 / v36.z).n64_u64[0];
      v15.n64_u64[0] = vmul_n_f32(v14, 70.0 / CDraw::ms_fFOV).n64_u64[0];
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      v17.n64_u64[0] = vmul_f32(*(float32x2_t *)&v36.x, v14).n64_u64[0];
      FaceNormals = COcclusion::aActiveOccluders[0].FaceNormals;
      v4.n64_u32[0] = v15.n64_u32[1];
      v19 = vmax_f32(v15, v4).n64_f32[0];
      v20 = a3;
      v21 = v19 * Radius;
      while ( 1 )
      {
        if ( (float)(v36.z - Radius) > (float)COcclusion::aActiveOccluders[v9].DistToCam )
        {
          LinesUsed = COcclusion::aActiveOccluders[v9].LinesUsed;
          if ( LinesUsed < 1 )
          {
LABEL_12:
            FacesUsed = COcclusion::aActiveOccluders[v9].FacesUsed;
            if ( FacesUsed < 1 )
              return 1;
            v28 = 0;
            p_x = &FaceNormals->x;
            for ( i = FaceOffset; ; ++i )
            {
              v31 = p_x[1];
              v32 = p_x[2];
              v33 = (float)((float)((float)(*p_x * v11) + (float)(v31 * v13)) + (float)(v32 * v20)) - *i;
              if ( fabsf(v33) < Radius
                || (float)(v33
                         * (float)((float)((float)((float)(p_tx->m_translate.x * *p_x)
                                                 + (float)(p_tx->m_translate.y * v31))
                                         + (float)(p_tx->m_translate.z * v32))
                                 - *i)) >= 0.0 )
              {
                break;
              }
              ++v28;
              p_x += 3;
              if ( v28 >= FacesUsed )
                return 1;
            }
          }
          else
          {
            v23 = 0;
            v24 = (float32x2_t *)v10;
            while ( 1 )
            {
              v25.n64_u32[0] = v24[1].n64_u32[1];
              v25.n64_u32[1] = v24[1].n64_u32[0];
              v26 = vmul_f32(vsub_f32(v17, (float32x2_t)v24->n64_u64[0]), v25).n64_u64[0];
              if ( (float)(*(float *)&v26 - *((float *)&v26 + 1)) < v21 )
                break;
              ++v23;
              v24 = (float32x2_t *)((char *)v24 + 20);
              if ( v23 >= LinesUsed )
                goto LABEL_12;
            }
          }
        }
        ++v9;
        FaceNormals = (CVector *)((char *)FaceNormals + 172);
        FaceOffset += 43;
        ++v10;
        result = 0;
        if ( v9 >= COcclusion::NumActiveOccluders )
          return result;
      }
    }
  }
  return 0;
}
// 5B1044: variable 'v4' is possibly undefined

//----- (005B1188) --------------------------------------------------------
void CPlayerSkin::Initialise()
{
  CPlayerSkin::m_txdSlot = CTxdStore::AddTxdSlot("skin", "player", 0);
  CTxdStore::Create(CPlayerSkin::m_txdSlot);
  sub_196558(CPlayerSkin::m_txdSlot);
}

//----- (005B11C0) --------------------------------------------------------
void CPlayerSkin::Shutdown()
{
  sub_197460(CPlayerSkin::m_txdSlot);
}

//----- (005B11D0) --------------------------------------------------------
RwTexture_0 *__fastcall CPlayerSkin::GetSkinTexture(const unsigned __int8 *pName)
{
  RwTexture_0 *v2; // r5
  int v4; // r0
  bool v5; // zf

  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(CPlayerSkin::m_txdSlot, 0);
  v2 = RwTextureRead(pName, 0);
  CTxdStore::PopCurrentTxd();
  if ( v2 )
    return v2;
  v4 = strcmp((const char *)pName, "$$\"\"");
  v5 = v4 == 0;
  if ( v4 )
    v5 = *pName == 0;
  if ( v5 )
    sprintf(gString, "models\\generic\\player.bmp");
  else
    sprintf(gString, "skins\\%s.bmp", pName);
  return 0;
}

//----- (005B126C) --------------------------------------------------------
void CPlayerSkin::RenderFrontendSkinEdit()
{
  char *parent; // r2
  float v1; // s0
  RwRGBAReal_0 v2; // [sp+0h] [bp-38h] BYREF
  RwV3d_0 translation; // [sp+10h] [bp-28h] BYREF
  RwV3d_0 axis; // [sp+20h] [bp-18h] BYREF

  parent = (char *)Scene.camera->object.object.parent;
  axis.z = 0.0;
  *(_QWORD *)&axis.x = unk_61F938;
  translation.z = 7.725;
  *(_QWORD *)&translation.x = unk_61F948;
  strcpy((char *)&v2, "ff&?ff&?ff&?");
  BYTE1(v2.alpha) = 0;
  HIWORD(v2.alpha) = unk_61F966;
  if ( CTimer::m_snTimeInMillisecondsPauseMode - CPlayerSkin::RenderFrontendSkinEdit(void)::LastFlash >= 8 )
  {
    v1 = CPlayerSkin::RenderFrontendSkinEdit(void)::rotation + 2.0;
    if ( (float)(CPlayerSkin::RenderFrontendSkinEdit(void)::rotation + 2.0) > 360.0 )
      v1 = (float)(CPlayerSkin::RenderFrontendSkinEdit(void)::rotation + 2.0) + -360.0;
    CPlayerSkin::RenderFrontendSkinEdit(void)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
    CPlayerSkin::RenderFrontendSkinEdit(void)::rotation = v1;
  }
  RwFrameTransform(
    (RwFrame_0 *)((char *)&elf_hash_bucket[16385] + 1),
    (const RwMatrix *)(parent + 16),
    rwCOMBINEREPLACE);
  RwFrameTranslate((RwFrame_0 *)((char *)&elf_hash_bucket[16385] + 1), &translation, rwCOMBINEPRECONCAT);
  RwFrameRotate(
    (RwFrame_0 *)((char *)&elf_hash_bucket[16385] + 1),
    &axis,
    CPlayerSkin::RenderFrontendSkinEdit(void)::rotation,
    rwCOMBINEPRECONCAT);
  RwFrameUpdateObjects((RwFrame_0 *)((char *)&elf_hash_bucket[16385] + 1));
  SetAmbientColours(&v2);
  RpClumpRender(0);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005B1368) --------------------------------------------------------
void CPointLights::Init()
{
  memset(CPointLights::aCachedMapReads, 0, sizeof(CPointLights::aCachedMapReads));
  CPointLights::NextCachedValue = 0;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[28] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[30] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[24] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[26] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[20] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[22] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[16] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[18] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[12] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[14] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[8] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[10] = 0LL;
  *(_QWORD *)CPointLights::aCachedMapReadResults = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[2] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[4] = 0LL;
  *(_QWORD *)&CPointLights::aCachedMapReadResults[6] = 0LL;
}

//----- (005B13D4) --------------------------------------------------------
void __fastcall CPointLights::AddLight(
        UInt8 Type,
        CVector Coors,
        CVector Dir,
        float Range,
        float Red,
        float Green,
        float Blue,
        UInt8 FogEffect,
        bool bCastsShadowFromPlayerCarAndPed,
        CEntity *pArgCastingEntity)
{
  float v10; // s2
  CSimpleTransform *p_tx; // lr
  float v12; // s4
  float v13; // s6
  Int32 v14; // r12
  float v15; // s8
  float v16; // s4
  int v17; // r1
  float v18; // s0

  v10 = Range + 15.0;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v12 = Coors.x - p_tx->m_translate.x;
  if ( v12 < v10 && v12 > (float)-v10 )
  {
    v13 = Coors.y - p_tx->m_translate.y;
    if ( v13 < v10 && v13 > (float)-v10 )
    {
      v14 = CPointLights::NumLights;
      if ( CPointLights::NumLights <= 31 )
      {
        v15 = sqrtf(
                (float)((float)(v12 * v12) + (float)(v13 * v13))
              + (float)((float)(Coors.z - p_tx->m_translate.z) * (float)(Coors.z - p_tx->m_translate.z)));
        if ( v15 < v10 )
        {
          v16 = Blue;
          CPointLights::aLights[CPointLights::NumLights].Coors.x = Coors.x;
          LODWORD(Coors.x) = &CPointLights::aLights[v14];
          *(_BYTE *)(LODWORD(Coors.x) + 45) = FogEffect;
          *(_BYTE *)(LODWORD(Coors.x) + 44) = Type;
          *(RwReal *)(LODWORD(Coors.x) + 4) = Coors.y;
          *(RwReal *)(LODWORD(Coors.x) + 8) = Coors.z;
          *(CVector *)(LODWORD(Coors.x) + 12) = Dir;
          *(_BYTE *)(LODWORD(Coors.x) + 46) = bCastsShadowFromPlayerCarAndPed;
          *(float *)(LODWORD(Coors.x) + 24) = Range;
          *(_DWORD *)(LODWORD(Coors.x) + 40) = pArgCastingEntity;
          if ( v15 >= (float)(v10 * 0.75) )
          {
            v18 = (float)((float)((float)(v15 / v10) + -0.75) * -4.0) + 1.0;
            v16 = v18 * Blue;
            *(float *)(v17 + 28) = v18 * Red;
            *(float *)(v17 + 32) = v18 * Green;
          }
          else
          {
            *(float *)(v17 + 28) = Red;
            *(float *)(v17 + 32) = Green;
          }
          CPointLights::aLights[v14].Blue = v16;
          CPointLights::NumLights = v14 + 1;
        }
      }
    }
  }
}

//----- (005B1578) --------------------------------------------------------
float __fastcall CPointLights::GenerateLightsAffectingObject(
        const CVector *pCoors,
        float *pPointLightsTotal,
        CEntity *pEntity)
{
  float32x2_t v3; // d4
  float32x2_t v4; // d10
  int v7; // r0
  int v8; // r9
  GlobalScene *v9; // r12
  float v10; // s22
  CRegisteredPointLight *v11; // r3
  float Range; // s6
  float v13; // s0
  float v14; // s8
  float v15; // s2
  float v16; // s4
  float v17; // s8
  float v18; // s6
  float v19; // s6
  CRegisteredPointLight *v20; // r2
  float v21; // s10
  float v22; // s10
  float v23; // s8
  float v24; // s6
  float v25; // s4
  float v26; // s2
  float v27; // s0
  int v28; // r0
  CRegisteredPointLight *v29; // r1
  UInt8 *p_Type; // r1
  int v31; // r2
  int Type; // t1
  GlobalScene *v34; // [sp+10h] [bp-60h]

  if ( CPointLights::NumLights < 1 )
    return 1.0;
  v4.n64_u32[0] = 0;
  v7 = 0;
  v8 = 0;
  v9 = &Scene;
  v10 = 1.0;
  do
  {
    v28 = v7;
    v29 = &CPointLights::aLights[v28];
    Type = v29->Type;
    p_Type = &v29->Type;
    v31 = Type;
    if ( (unsigned __int8)(Type - 3) >= 2u )
    {
      v11 = &CPointLights::aLights[v28];
      Range = v11->Range;
      v13 = v11->Coors.x - pCoors->x;
      v14 = -Range;
      if ( v13 > (float)-Range && v13 < Range )
      {
        v15 = CPointLights::aLights[v28].Coors.y - pCoors->y;
        if ( v15 > v14 && v15 < Range )
        {
          v16 = CPointLights::aLights[v28].Coors.z - pCoors->z;
          if ( v16 > v14 && v16 < Range )
          {
            v17 = sqrtf((float)((float)(v13 * v13) + (float)(v15 * v15)) + (float)(v16 * v16));
            if ( v17 < Range )
            {
              v18 = v17 / Range;
              if ( v31 == 2 )
              {
                v10 = v10 * v18;
              }
              else
              {
                v19 = 1.0 - v18;
                if ( pPointLightsTotal )
                {
                  v20 = &CPointLights::aLights[v28];
                  v21 = *pPointLightsTotal + (float)((float)(v19 * v20->Red) * 0.33333);
                  *pPointLightsTotal = v21;
                  v22 = v21 + (float)((float)(v19 * v20->Green) * 0.33333);
                  *pPointLightsTotal = v22;
                  *pPointLightsTotal = v22 + (float)((float)(v19 * v20->Blue) * 0.33333);
                }
                if ( v17 != 0.0 )
                {
                  v23 = 1.0 / v17;
                  v24 = v19 * v19;
                  v25 = v16 * v23;
                  v26 = v15 * v23;
                  v27 = v13 * v23;
                  if ( *p_Type == 1 && CPointLights::aLights[v28].pCastingEntity != pEntity )
                  {
                    v3.n64_f32[0] = -0.5
                                  - (float)((float)((float)(v27 * CPointLights::aLights[v28].Dir.x)
                                                  + (float)(v26 * CPointLights::aLights[v28].Dir.y))
                                          + (float)(v25 * CPointLights::aLights[v28].Dir.z));
                    v3.n64_f32[0] = v3.n64_f32[0] + v3.n64_f32[0];
                    v3.n64_u64[0] = vmax_f32(v3, v4).n64_u64[0];
                    v24 = v24 * v3.n64_f32[0];
                  }
                  if ( v24 > 0.0 )
                  {
                    v34 = v9;
                    AddAnExtraDirectionalLight(
                      v9->world,
                      v27,
                      v26,
                      v25,
                      v24 * CPointLights::aLights[v28].Red,
                      v24 * CPointLights::aLights[v28].Green,
                      v24 * CPointLights::aLights[v28].Blue);
                    v9 = v34;
                  }
                }
              }
            }
          }
        }
      }
    }
    v7 = (__int16)++v8;
  }
  while ( CPointLights::NumLights > (__int16)v8 );
  return v10;
}
// 5B1766: variable 'v3' is possibly undefined
// 5B1766: variable 'v4' is possibly undefined

//----- (005B1838) --------------------------------------------------------
float __fastcall CPointLights::GetLightMultiplier(const CVector *pCoors)
{
  int v1; // r4
  float v2; // s4
  int v3; // r5
  float v4; // s0
  int v5; // r6
  int Type; // r4
  CRegisteredPointLight *v7; // r3
  float Range; // s8
  float v9; // s10
  float v10; // s12
  float v11; // s14
  float v12; // s1
  float v13; // s10
  float v14; // s8

  if ( CPointLights::NumLights < 1 )
  {
    v2 = 1.0;
    v4 = 0.0;
  }
  else
  {
    v1 = 0;
    v2 = 1.0;
    v3 = 0;
    v4 = 0.0;
    do
    {
      v5 = v1;
      Type = CPointLights::aLights[v1].Type;
      if ( (unsigned __int8)(Type - 3) >= 2u )
      {
        v7 = &CPointLights::aLights[v5];
        Range = v7->Range;
        v9 = v7->Coors.x - pCoors->x;
        v10 = -Range;
        if ( v9 > (float)-Range && v9 < Range )
        {
          v11 = CPointLights::aLights[v5].Coors.y - pCoors->y;
          if ( v11 > v10 && v11 < Range )
          {
            v12 = CPointLights::aLights[v5].Coors.z - pCoors->z;
            if ( v12 > v10 && v12 < Range )
            {
              v13 = sqrtf((float)((float)(v9 * v9) + (float)(v11 * v11)) + (float)(v12 * v12));
              if ( v13 < Range )
              {
                v14 = v13 / Range;
                if ( Type == 2 )
                  v2 = v2 * v14;
                else
                  v4 = (float)((float)(v4
                                     + (float)((float)((float)(1.0 - v14) * CPointLights::aLights[v5].Red) * 0.33333))
                             + (float)((float)((float)(1.0 - v14) * CPointLights::aLights[v5].Green) * 0.33333))
                     + (float)((float)((float)(1.0 - v14) * CPointLights::aLights[v5].Blue) * 0.33333);
              }
            }
          }
        }
      }
      v1 = (__int16)++v3;
    }
    while ( CPointLights::NumLights > (__int16)v3 );
  }
  return v4 + v2;
}

//----- (005B19BC) --------------------------------------------------------
void CPointLights::RemoveLightsAffectingObject()
{
  sub_18F844(Scene.world);
}

//----- (005B19D0) --------------------------------------------------------
void CPointLights::RenderFogEffect()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  __int64 v2; // d8
  __int64 v3; // d9
  __int64 v4; // d10
  __int64 v5; // d11
  __int64 v6; // d12
  __int64 v7; // d13
  __int64 v8; // d14
  __int64 v9; // d15
  float v10; // s29
  int v11; // r1
  int v12; // r9
  CRegisteredPointLight *v13; // r3
  int FogEffect; // r0
  float v15; // s16
  float v16; // s27
  int Type; // r0
  CRegisteredPointLight *v18; // r0
  float v19; // s4
  signed int v20; // r6
  float y; // s0
  float *p_y; // r2
  float *v23; // r8
  float v24; // s4
  float *p_x; // r10
  float v26; // s2
  CRegisteredPointLight *v27; // r0
  int v28; // r9
  float v29; // s20
  int v30; // r11
  float v31; // s0
  float v32; // s2
  float v33; // s4
  float v34; // s2
  float *v35; // r4
  _BOOL4 v36; // r0
  float v37; // s4
  float v38; // s8
  float v39; // s2
  float v40; // s10
  float v41; // s6
  float v42; // s18
  float v43; // s30
  float v44; // s23
  float v45; // s0
  float v46; // s0
  float v47; // s4
  float v48; // s2
  float v49; // s23
  CRegisteredPointLight *v50; // r5
  float *v51; // r5
  RwReal v52; // t1
  int v53; // r0
  float *v54; // r3
  signed int v55; // r6
  CRegisteredPointLight *v56; // r0
  float v57; // s20
  float v58; // s16
  int v59; // r9
  float v60; // s18
  int v61; // r11
  unsigned int v62; // r0
  int v63; // r10
  float v64; // s29
  CSimpleTransform *p_tx; // r1
  float v66; // s2
  float v67; // s30
  float v68; // s0
  float v69; // s2
  float *p_Red; // [sp+30h] [bp-108h]
  float *p_Green; // [sp+34h] [bp-104h]
  float *p_Blue; // [sp+54h] [bp-E4h]
  float *v73; // [sp+54h] [bp-E4h]
  float *p_z; // [sp+58h] [bp-E0h]
  float *v75; // [sp+58h] [bp-E0h]
  int v76; // [sp+5Ch] [bp-DCh]
  float *v77; // [sp+5Ch] [bp-DCh]
  signed int v78; // [sp+60h] [bp-D8h]
  int v79; // [sp+60h] [bp-D8h]
  int v80; // [sp+64h] [bp-D4h]
  float *v81; // [sp+68h] [bp-D0h]
  signed int v82; // [sp+68h] [bp-D0h]
  CRegisteredPointLight *v83; // [sp+6Ch] [bp-CCh]
  RwV3d_0 In; // [sp+74h] [bp-C4h] BYREF
  float pScaleY; // [sp+80h] [bp-B8h] BYREF
  float pScaleX; // [sp+84h] [bp-B4h] BYREF
  CVector vecStart; // [sp+88h] [bp-B0h] BYREF
  CEntity *refEntityPtr; // [sp+94h] [bp-A4h] BYREF
  CColPoint colPoint; // [sp+98h] [bp-A0h] BYREF
  RwV3d_0 pResult; // [sp+C4h] [bp-74h] BYREF
  __int64 v91; // [sp+D0h] [bp-68h]
  __int64 v92; // [sp+D8h] [bp-60h]
  __int64 v93; // [sp+E0h] [bp-58h]
  __int64 v94; // [sp+E8h] [bp-50h]
  __int64 v95; // [sp+F0h] [bp-48h]
  __int64 v96; // [sp+F8h] [bp-40h]
  __int64 v97; // [sp+100h] [bp-38h]
  __int64 v98; // [sp+108h] [bp-30h]
  CVector v99; // 0:r0.12

  if ( !CCutsceneMgr::ms_running )
  {
    v91 = v2;
    v92 = v3;
    v93 = v4;
    v94 = v5;
    v95 = v6;
    v96 = v7;
    v97 = v8;
    v98 = v9;
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCloudTex[0]->raster);
    CSprite::InitSpriteBuffer();
    if ( CPointLights::NumLights >= 1 )
    {
      v10 = 3.0;
      v11 = 0;
      do
      {
        v12 = v11;
        v80 = v11;
        v13 = &CPointLights::aLights[v11];
        FogEffect = v13->FogEffect;
        if ( (unsigned __int8)(FogEffect - 1) <= 1u )
        {
          v15 = 0.4;
          v16 = v10;
          if ( FogEffect == 1 )
            v15 = CWeather::Foggyness;
          if ( FogEffect == 1 )
            v16 = 9.0;
          if ( v15 != 0.0 )
          {
            v83 = &CPointLights::aLights[v11];
            Type = v83->Type;
            if ( (unsigned int)(Type - 3) >= 2 && CPointLights::aLights[v11].Type )
            {
              if ( Type == 1 )
              {
                v1.n64_u32[0] = LODWORD(v13->Coors.x);
                v18 = &CPointLights::aLights[v11];
                v0.n64_f32[0] = (float)(v18->Dir.x * 12.0) + v13->Coors.x;
                v19 = vmin_f32(v0, v1).n64_f32[0];
                v0.n64_u64[0] = vmax_f32(v0, v1).n64_u64[0];
                v20 = ((int)(float)(v19 + -5.0) + ((unsigned int)((int)(float)(v19 + -5.0) >> 31) >> 30)) & 0xFFFFFFFC;
                v76 = (int)(float)(v0.n64_f32[0] + 5.0) + 4;
                if ( v20 <= v76 )
                {
                  y = v18->Coors.y;
                  p_y = &v18->Coors.y;
                  v23 = &v18->Dir.y;
                  v24 = y;
                  p_x = &v18->Dir.x;
                  v26 = (float)(v18->Dir.y * 12.0) + y;
                  if ( v26 < y )
                  {
                    v24 = (float)(v18->Dir.y * 12.0) + y;
                    v26 = v18->Coors.y;
                  }
                  v78 = ((int)(float)(v24 + -5.0) + ((unsigned int)((int)(float)(v24 + -5.0) >> 31) >> 30)) & 0xFFFFFFFC;
                  v27 = &CPointLights::aLights[v11];
                  p_Blue = &v27->Blue;
                  p_Green = &v27->Green;
                  p_Red = &v27->Red;
                  p_z = &v27->Dir.z;
                  v81 = &v27->Coors.z;
                  v28 = (int)(float)(v26 + 5.0) + 4;
                  do
                  {
                    if ( v78 <= v28 )
                    {
                      v29 = (float)v20;
                      v30 = v78;
                      do
                      {
                        if ( ((v30 ^ v20) & 4) != 0 )
                        {
                          v31 = v29 - v13->Coors.x;
                          v32 = (float)v30 - *p_y;
                          v33 = (float)(v31 * *p_x) + (float)(v32 * *v23);
                          if ( v33 > 0.0
                            && v33 < 12.0
                            && (float)((float)((float)(v31 * v31) + (float)(v32 * v32)) - (float)(v33 * v33)) < 25.0 )
                          {
                            vecStart.y = (float)v30;
                            vecStart.x = (float)v20;
                            v34 = (float)(*v81 + 10.0) + -20.0;
                            vecStart.z = *v81 + 10.0;
                            v35 = p_y;
                            v36 = CWorld::ProcessVerticalLine(
                                    &vecStart,
                                    v34,
                                    &colPoint,
                                    &refEntityPtr,
                                    1,
                                    0,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0);
                            v13 = v83;
                            p_y = v35;
                            if ( v36 )
                            {
                              v37 = (float)v30 - *v35;
                              v38 = *v23;
                              v39 = v29 - v83->Coors.x;
                              v40 = *p_x;
                              v41 = (float)(colPoint.m_vecPosition.z + 1.3) - *v81;
                              vecStart.z = colPoint.m_vecPosition.z + 1.3;
                              v42 = (float)((float)(v39 * v40) + (float)(v37 * v38)) + (float)(v41 * *p_z);
                              if ( v42 > 0.0 && v42 < 12.0 )
                              {
                                v43 = (float)((float)(v39 * v39) + (float)(v37 * v37)) + (float)(v41 * v41);
                                v44 = v43 - (float)(v42 * v42);
                                if ( v44 < 25.0 )
                                {
                                  In.y = (float)v30;
                                  In.x = (float)v20;
                                  In.z = colPoint.m_vecPosition.z + 1.3;
                                  if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
                                  {
                                    v45 = sqrtf(v44);
                                    v46 = (float)((float)((float)((float)(v15 * 50.0) * v42) / sqrtf(v43))
                                                * (float)(1.0 - (float)((float)(v42 / 12.0) * (float)(v42 / 12.0))))
                                        * (float)(1.0 - (float)((float)(v45 / 5.0) * (float)(v45 / 5.0)));
                                    v47 = FogSizes[((v30 ^ (unsigned int)v20) >> 3) & 7];
                                    v48 = (double)(CTimer::m_snTimeInMilliseconds & 0x1FFF) * 0.000766601563;
                                    CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(
                                      pResult.x,
                                      pResult.y,
                                      pResult.z,
                                      v47 * pScaleX,
                                      v47 * pScaleY,
                                      (unsigned int)(float)(v46 * *p_Red),
                                      (unsigned int)(float)(v46 * *p_Green),
                                      (unsigned int)(float)(v46 * *p_Blue),
                                      (int)v46,
                                      1.0 / pResult.z,
                                      v48,
                                      0xFFu);
                                  }
                                  v13 = v83;
                                  p_y = v35;
                                }
                              }
                            }
                          }
                        }
                        v30 += 4;
                      }
                      while ( v30 <= v28 );
                    }
                    v20 += 4;
                  }
                  while ( v20 <= v76 );
                }
              }
            }
            else
            {
              v49 = v10;
              v50 = &CPointLights::aLights[v11];
              v99.x = v13->Coors.x;
              v52 = v50->Coors.y;
              v51 = &v50->Coors.y;
              v99.y = v52;
              v99.z = v51[1];
              v53 = CPointLights::ProcessVerticalLineUsingCache(v99, &In.x);
              v54 = &v83->Coors.x;
              if ( v53 == 1 )
              {
                v79 = (int)(float)(v16 + v83->Coors.x) + 2;
                v55 = ((int)(float)(v83->Coors.x - v16) + ((unsigned int)(int)(float)(v83->Coors.x - v16) >> 31)) & 0xFFFFFFFE;
                if ( v55 <= v79 )
                {
                  v56 = &CPointLights::aLights[v12];
                  v77 = &v56->Blue;
                  v75 = &v56->Green;
                  v57 = In.x + 1.6;
                  v73 = &v56->Red;
                  v58 = v15 * 37.0;
                  v59 = (int)(float)(v16 + *v51) + 2;
                  v82 = ((int)(float)(*v51 - v16) + ((unsigned int)(int)(float)(*v51 - v16) >> 31)) & 0xFFFFFFFE;
                  do
                  {
                    if ( v82 <= v59 )
                    {
                      v60 = (float)v55;
                      v61 = v82;
                      do
                      {
                        v62 = (v55 / 2) ^ (v61 / 2);
                        if ( (v62 & 1) != 0 )
                        {
                          v63 = (v62 >> 1) & 7;
                          v64 = sqrtf(
                                  (float)((float)(v60 - *v54) * (float)(v60 - *v54))
                                + (float)((float)((float)v61 - *v51) * (float)((float)v61 - *v51)));
                          if ( v64 < v16 )
                          {
                            p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
                            if ( !TheCamera.m_pMat )
                              p_tx = &TheCamera.m_transform;
                            v66 = sqrtf(
                                    (float)((float)(v60 - p_tx->m_translate.x) * (float)(v60 - p_tx->m_translate.x))
                                  + (float)((float)((float)v61 - p_tx->m_translate.y)
                                          * (float)((float)v61 - p_tx->m_translate.y)));
                            if ( v66 < 15.0 )
                            {
                              v67 = 1.0;
                              if ( v66 >= 7.5 )
                                v67 = (float)((float)(v66 + -7.5) / -7.5) + 1.0;
                              vecStart.y = (float)v61;
                              vecStart.x = (float)v55;
                              vecStart.z = v57;
                              if ( CSprite::CalcScreenCoors(&vecStart, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
                              {
                                v68 = (float)(v58 * (float)(1.0 - (float)((float)(v64 / v16) * (float)(v64 / v16))))
                                    * v67;
                                v69 = (double)((2300 * (_WORD)v63 + (_WORD)CTimer::m_snTimeInMilliseconds) & 0x7FFF)
                                    * 0.000191650391;
                                CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(
                                  pResult.x,
                                  pResult.y,
                                  pResult.z,
                                  FogSizes[v63] * pScaleX,
                                  (float)(FogSizes[v63] * pScaleY) * 0.7,
                                  (unsigned int)(float)(v68 * *v73),
                                  (unsigned int)(float)(v68 * *v75),
                                  (unsigned int)(float)(v68 * *v77),
                                  (int)v68,
                                  1.0 / pResult.z,
                                  v69,
                                  0xFFu);
                              }
                              v54 = &v83->Coors.x;
                            }
                          }
                        }
                        v61 += 2;
                      }
                      while ( v61 <= v59 );
                    }
                    v55 += 2;
                  }
                  while ( v55 <= v79 );
                }
              }
              v10 = v49;
            }
          }
        }
        v11 = v80 + 1;
      }
      while ( v80 + 1 < CPointLights::NumLights );
    }
    CSprite::FlushSpriteBuffer();
  }
}
// 5B19EA: variable 'v2' is possibly undefined
// 5B19EA: variable 'v3' is possibly undefined
// 5B19EA: variable 'v4' is possibly undefined
// 5B19EA: variable 'v5' is possibly undefined
// 5B19EA: variable 'v6' is possibly undefined
// 5B19EA: variable 'v7' is possibly undefined
// 5B19EA: variable 'v8' is possibly undefined
// 5B19EA: variable 'v9' is possibly undefined
// 5B1B70: variable 'v0' is possibly undefined
// 5B1B70: variable 'v1' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005B2198) --------------------------------------------------------
int __fastcall CPointLights::ProcessVerticalLineUsingCache(CVector Coors, float *pResult)
{
  float y; // s2
  float z; // s0
  float x; // s4
  int v6; // r5
  __int64 v7; // d16
  Int32 v8; // r3
  CVector *v9; // r2
  RwReal v10; // r2
  CEntity *refEntityPtr; // [sp+20h] [bp-50h] BYREF
  CColPoint colPoint; // [sp+24h] [bp-4Ch] BYREF
  CVector vecStart; // [sp+50h] [bp-20h] BYREF

  vecStart = Coors;
  y = Coors.y;
  z = Coors.z;
  x = Coors.x;
  Coors.z = 0.0;
  LODWORD(Coors.x) = &CPointLights::aCachedMapReads[0].y;
  do
  {
    Coors.y = Coors.z;
    if ( *(float *)(LODWORD(Coors.x) - 4) == x && *(float *)LODWORD(Coors.x) == y )
    {
      *pResult = CPointLights::aCachedMapReadResults[LODWORD(Coors.z)];
      return 1;
    }
    LODWORD(Coors.x) += 12;
    ++LODWORD(Coors.z);
  }
  while ( SLODWORD(Coors.y) < 31 );
  v6 = 0;
  if ( !CWorld::ProcessVerticalLine(&vecStart, z + -20.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    return v6;
  v7 = *(_QWORD *)&vecStart.x;
  v8 = CPointLights::NextCachedValue;
  v9 = &CPointLights::aCachedMapReads[CPointLights::NextCachedValue];
  v9->z = vecStart.z;
  *(_QWORD *)&v9->x = v7;
  v10 = colPoint.m_vecPosition.z;
  CPointLights::aCachedMapReadResults[v8] = colPoint.m_vecPosition.z;
  CPointLights::NextCachedValue = (v8 + 1) % 32;
  *pResult = v10;
  return 1;
}

//----- (005B2290) --------------------------------------------------------
RwRaster_0 *__fastcall CPostEffects::RasterCreatePostEffects(int a1, int a2, RwInt32 a3, RwInt32 a4)
{
  return sub_18B654(a3, a4, Scene.camera->frameBuffer->depth, 5);
}

//----- (005B22B0) --------------------------------------------------------
void CPostEffects::SetupBackBufferVertex()
{
  RwInt32 width; // r1
  bool v1; // zf
  float nearPlane; // s0
  float v3; // s0
  float v4; // s0
  float v5; // s0

  if ( !CPostEffects::pRasterFrontBuffer )
  {
LABEL_6:
    CPostEffects::pRasterFrontBuffer = RwRasterCreate(64, 64, Scene.camera->frameBuffer->depth, 5);
    if ( !CPostEffects::pRasterFrontBuffer )
    {
      RwRasterDestroy(0);
      CPostEffects::pRasterFrontBuffer = 0;
    }
    goto LABEL_8;
  }
  width = CPostEffects::pRasterFrontBuffer->width;
  v1 = width == 64;
  if ( width == 64 )
    v1 = CPostEffects::pRasterFrontBuffer->height == 64;
  if ( !v1 )
  {
    RwRasterDestroy(CPostEffects::pRasterFrontBuffer);
    CPostEffects::pRasterFrontBuffer = 0;
    goto LABEL_6;
  }
LABEL_8:
  pe_vertex[0].x = 0.0;
  pe_vertex[0].y = 0.0;
  pe_vertex[0].z = RwIm2DGetNearScreenZ();
  nearPlane = Scene.camera->nearPlane;
  *(_QWORD *)&pe_vertex[0].s = 0x3C0000003C000000LL;
  *(_QWORD *)&pe_vertex[1].x = 0x4280000000000000LL;
  pe_vertex[0].rhw = 1.0 / nearPlane;
  pe_vertex[1].z = RwIm2DGetNearScreenZ();
  v3 = 1.0 / Scene.camera->nearPlane;
  *(_QWORD *)&pe_vertex[1].s = 0x3F8100003C000000LL;
  *(_QWORD *)&pe_vertex[2].x = 0x4280000042800000LL;
  pe_vertex[1].rhw = v3;
  pe_vertex[2].z = RwIm2DGetNearScreenZ();
  v4 = 1.0 / Scene.camera->nearPlane;
  *(_QWORD *)&pe_vertex[2].s = 0x3F8100003F810000LL;
  *(_QWORD *)&pe_vertex[3].x = 1115684864LL;
  pe_vertex[2].rhw = v4;
  pe_vertex[3].z = RwIm2DGetNearScreenZ();
  v5 = 1.0 / Scene.camera->nearPlane;
  pe_vertex[3].s = 1.0078;
  pe_vertex[3].t = 0.0078125;
  pe_vertex[3].rhw = v5;
  if ( CPostEffects::pRasterFrontBuffer )
  {
    CPostEffects::ImmediateModeFilterStuffInitialize();
    CPostEffects::HeatHazeFXInit();
  }
}

//----- (005B2420) --------------------------------------------------------
void CPostEffects::ImmediateModeFilterStuffInitialize()
{
  RwReal v0; // s0
  RwRaster_0 *frameBuffer; // r0
  int height; // s2
  float v3; // s18
  unsigned int v4; // s16
  float v5; // s18
  float v6; // r0

  CPostEffects::ms_imf.screenZ = RwIm2DGetNearScreenZ();
  v0 = 1.0 / Scene.camera->nearPlane;
  *(_QWORD *)&CPostEffects::ms_imf.uMinTri = 0x4000000000000000LL;
  *(_QWORD *)&CPostEffects::ms_imf.vMinTri = 0x4000000000000000LL;
  CPostEffects::ms_imf.pRasterDrawBuffer = CPostEffects::pRasterFrontBuffer;
  CPostEffects::ms_imf.recipCameraZ = v0;
  CPostEffects::ms_imf.sizeDrawBufferX = CPostEffects::pRasterFrontBuffer->width;
  CPostEffects::ms_imf.sizeDrawBufferY = CPostEffects::pRasterFrontBuffer->height;
  CPostEffects::ms_imf.triangle[0].x = 0.0;
  CPostEffects::ms_imf.triangle[0].y = 0.0;
  CPostEffects::ms_imf.triangle[0].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.triangle[0].s = 0.0;
  CPostEffects::ms_imf.triangle[0].t = 0.0;
  CPostEffects::ms_imf.triangle[0].rhw = v0;
  CPostEffects::ms_imf.triangle[1].y = 0.0;
  CPostEffects::ms_imf.triangle[1].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.triangle[1].s = 2.0;
  CPostEffects::ms_imf.triangle[1].t = 0.0;
  CPostEffects::ms_imf.triangle[2].x = 0.0;
  CPostEffects::ms_imf.triangle[1].rhw = v0;
  CPostEffects::ms_imf.triangle[2].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.triangle[2].s = 0.0;
  CPostEffects::ms_imf.triangle[2].t = 2.0;
  CPostEffects::ms_imf.triangle[2].rhw = v0;
  CPostEffects::ms_imf.triangle[1].x = (float)CPostEffects::ms_imf.sizeDrawBufferX
                                     + (float)CPostEffects::ms_imf.sizeDrawBufferX;
  CPostEffects::ms_imf.triangle[2].y = (float)CPostEffects::ms_imf.sizeDrawBufferY
                                     + (float)CPostEffects::ms_imf.sizeDrawBufferY;
  CPostEffects::ms_imf.quad[0].x = 0.0;
  CPostEffects::ms_imf.quad[0].y = 0.0;
  CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[0].rhw = v0;
  CPostEffects::ms_imf.quad[1].rhw = v0;
  CPostEffects::ms_imf.quad[2].rhw = v0;
  CPostEffects::ms_imf.quad[3].rhw = v0;
  *(_DWORD *)&CPostEffects::ms_imf.quad[0].r = -16726016;
  CPostEffects::ms_imf.quad[0].s = 0.0;
  CPostEffects::ms_imf.quad[0].t = 0.0;
  CPostEffects::ms_imf.quad[1].x = 0.0;
  CPostEffects::ms_imf.quad[1].y = 0.0;
  CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
  *(_DWORD *)&CPostEffects::ms_imf.quad[1].r = -16726016;
  CPostEffects::ms_imf.quad[1].s = 1.0;
  CPostEffects::ms_imf.quad[1].t = 0.0;
  CPostEffects::ms_imf.quad[2].x = 0.0;
  CPostEffects::ms_imf.quad[2].y = 0.0;
  CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
  *(_DWORD *)&CPostEffects::ms_imf.quad[2].r = -16726016;
  CPostEffects::ms_imf.quad[2].s = 0.0;
  CPostEffects::ms_imf.quad[2].t = 1.0;
  CPostEffects::ms_imf.quad[3].x = 0.0;
  CPostEffects::ms_imf.quad[3].y = 0.0;
  CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
  *(_DWORD *)&CPostEffects::ms_imf.quad[3].r = -16726016;
  CPostEffects::ms_imf.quad[3].s = 1.0;
  CPostEffects::ms_imf.quad[3].t = 1.0;
  frameBuffer = Scene.camera->frameBuffer;
  height = frameBuffer->height;
  v3 = logf((float)frameBuffer->width);
  v4 = (unsigned int)(float)(logf((float)height) / 0.69315);
  v5 = ldexpf(1.0, (unsigned int)(float)(v3 / 0.69315) + 1);
  v6 = ldexpf(1.0, v4 + 1);
  CPostEffects::ms_imf.fFrontBufferU1 = 0.0;
  CPostEffects::ms_imf.fFrontBufferV1 = 0.0;
  CPostEffects::ms_imf.fFrontBufferU2 = (float)RsGlobal.screenWidth / (float)(int)(unsigned int)v5;
  CPostEffects::ms_imf.fFrontBufferV2 = (float)RsGlobal.screenHeight / (float)(int)(unsigned int)v6;
}

//----- (005B25E4) --------------------------------------------------------
void CPostEffects::HeatHazeFXInit()
{
  int v0; // r12
  float v1; // s0
  float v2; // s2
  float v3; // s4
  int v4; // r5
  float v5; // s8
  float v6; // s10
  int v7; // s6
  int v8; // r4
  RwInt32 width; // r9
  Int32 v10; // r10
  RwInt32 height; // r5
  Int32 v12; // r6
  int v13; // s0
  Int32 v14; // r6
  Int32 v15; // r5

  if ( CPostEffects::m_HeatHazeFXType != CPostEffects::m_HeatHazeFXTypeLast )
  {
    if ( (unsigned int)CPostEffects::m_HeatHazeFXType <= 4 )
    {
      v0 = dword_5B280C[CPostEffects::m_HeatHazeFXType];
      v1 = *(float *)&dword_5B2834[CPostEffects::m_HeatHazeFXType];
      CPostEffects::m_HeatHazeFXRandomShift = dword_5B2820[CPostEffects::m_HeatHazeFXType];
      v2 = *(float *)&dword_5B2848[CPostEffects::m_HeatHazeFXType];
      v3 = *(float *)&dword_5B27F8[CPostEffects::m_HeatHazeFXType];
      CPostEffects::m_HeatHazeFXIntensity = (Int32)off_61F970[CPostEffects::m_HeatHazeFXType];
      v4 = dword_5B2878[CPostEffects::m_HeatHazeFXType];
      v5 = (float)RsGlobal.screenWidth / 640.0;
      v6 = (float)RsGlobal.screenHeight / 448.0;
      v7 = (int)(float)(*(float *)&dword_5B2860[CPostEffects::m_HeatHazeFXType] * v5);
      CPostEffects::m_HeatHazeFXSpeedMin = v0;
      CPostEffects::m_HeatHazeFXSpeedMax = v4;
      CPostEffects::m_HeatHazeFXScanSizeX = v7;
      CPostEffects::m_HeatHazeFXScanSizeY = (int)(float)(v3 * v6);
      CPostEffects::m_HeatHazeFXRenderSizeX = (int)(float)(v2 * v5);
      CPostEffects::m_HeatHazeFXRenderSizeY = (int)(float)(v1 * v6);
    }
    v8 = 0;
    CPostEffects::m_HeatHazeFXTypeLast = CPostEffects::m_HeatHazeFXType;
    do
    {
      width = CPostEffects::pRasterFrontBuffer->width;
      v10 = CPostEffects::m_HeatHazeFXScanSizeX;
      hpX[v8] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(width - v10));
      height = CPostEffects::pRasterFrontBuffer->height;
      v12 = CPostEffects::m_HeatHazeFXScanSizeY;
      v13 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(height - v12));
      v14 = CPostEffects::m_HeatHazeFXSpeedMin;
      hpY[v8] = v13;
      v15 = CPostEffects::m_HeatHazeFXSpeedMax;
      hpS[v8++] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(v15 - v14)) + v14;
    }
    while ( v8 != 180 );
  }
}
// 5B27F8: using guessed type int dword_5B27F8[5];
// 5B280C: using guessed type int dword_5B280C[5];
// 5B2820: using guessed type int dword_5B2820[4];
// 5B2834: using guessed type int dword_5B2834[5];
// 5B2848: using guessed type int dword_5B2848[5];
// 5B2860: using guessed type int dword_5B2860[5];
// 5B2878: using guessed type int dword_5B2878[5];
// 61F970: using guessed type int *off_61F970[3];

//----- (005B28D8) --------------------------------------------------------
void CPostEffects::Update()
{
  CPostEffects::m_bRainEnable = CWeather::Rain > 0.0;
  if ( !CPostEffects::pRasterFrontBuffer )
    CPostEffects::SetupBackBufferVertex();
}

//----- (005B2914) --------------------------------------------------------
void CPostEffects::DoScreenModeDependentInitializations()
{
  CPostEffects::ImmediateModeFilterStuffInitialize();
  CPostEffects::HeatHazeFXInit();
}

//----- (005B2924) --------------------------------------------------------
void CPostEffects::DrawQuadSetDefaultUVs()
{
  CPostEffects::ms_imf.quad[0].s = 0.0;
  CPostEffects::ms_imf.quad[0].t = 0.0;
  CPostEffects::ms_imf.quad[2].s = 0.0;
  CPostEffects::ms_imf.quad[2].t = 1.0;
  CPostEffects::ms_imf.quad[1].s = 1.0;
  CPostEffects::ms_imf.quad[1].t = 0.0;
  CPostEffects::ms_imf.quad[3].s = 1.0;
  CPostEffects::ms_imf.quad[3].t = 1.0;
}

//----- (005B2948) --------------------------------------------------------
void CPostEffects::ImmediateModeRenderStatesStore()
{
  RwRenderStateGet(rwRENDERSTATESRCBLEND, &CPostEffects::ms_imf.blendSrc);
  RwRenderStateGet(rwRENDERSTATEDESTBLEND, &CPostEffects::ms_imf.blendDst);
  RwRenderStateGet(rwRENDERSTATEFOGENABLE, &CPostEffects::ms_imf.bFog);
  RwRenderStateGet(rwRENDERSTATECULLMODE, &CPostEffects::ms_imf.cullMode);
  RwRenderStateGet(rwRENDERSTATEZTESTENABLE, &CPostEffects::ms_imf.bZTest);
  RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, &CPostEffects::ms_imf.bZWrite);
  RwRenderStateGet(rwRENDERSTATESHADEMODE, &CPostEffects::ms_imf.shadeMode);
  RwRenderStateGet(rwRENDERSTATEVERTEXALPHAENABLE, &CPostEffects::ms_imf.bVertexAlpha);
  RwRenderStateGet(rwRENDERSTATETEXTUREADDRESS, &CPostEffects::ms_imf.textureAddress);
  sub_1A0070(rwRENDERSTATETEXTUREFILTER, &CPostEffects::ms_imf.textureFilter);
}

//----- (005B29C0) --------------------------------------------------------
void CPostEffects::ImmediateModeRenderStatesSet()
{
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  sub_192840(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B2A18) --------------------------------------------------------
void CPostEffects::ImmediateModeRenderStatesReStore()
{
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (void *)CPostEffects::ms_imf.blendSrc);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (void *)CPostEffects::ms_imf.blendDst);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (void *)CPostEffects::ms_imf.bFog);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (void *)CPostEffects::ms_imf.cullMode);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (void *)CPostEffects::ms_imf.bZTest);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (void *)CPostEffects::ms_imf.bZWrite);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (void *)CPostEffects::ms_imf.shadeMode);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void *)CPostEffects::ms_imf.bVertexAlpha);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (void *)CPostEffects::ms_imf.textureAddress);
  sub_192840(rwRENDERSTATETEXTUREFILTER, (void *)CPostEffects::ms_imf.textureFilter);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005B2A90) --------------------------------------------------------
void __fastcall CPostEffects::DrawQuad(
        RwReal xPos,
        RwReal yPos,
        RwReal xSize,
        RwReal ySize,
        RwUInt8 r,
        RwUInt8 g,
        RwUInt8 b,
        RwUInt8 a,
        RwRaster_0 *pRaster)
{
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, pRaster);
  CPostEffects::ms_imf.quad[0].y = yPos;
  CPostEffects::ms_imf.quad[1].y = yPos;
  CPostEffects::ms_imf.quad[0].r = r;
  CPostEffects::ms_imf.quad[0].g = g;
  CPostEffects::ms_imf.quad[0].b = b;
  CPostEffects::ms_imf.quad[0].a = a;
  CPostEffects::ms_imf.quad[1].r = r;
  CPostEffects::ms_imf.quad[1].g = g;
  CPostEffects::ms_imf.quad[1].b = b;
  CPostEffects::ms_imf.quad[1].a = a;
  CPostEffects::ms_imf.quad[2].x = xPos;
  CPostEffects::ms_imf.quad[2].r = r;
  CPostEffects::ms_imf.quad[2].g = g;
  CPostEffects::ms_imf.quad[2].b = b;
  CPostEffects::ms_imf.quad[2].a = a;
  CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].x = xPos + xSize;
  CPostEffects::ms_imf.quad[2].y = yPos + ySize;
  CPostEffects::ms_imf.quad[0].x = xPos;
  CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[3].r = r;
  CPostEffects::ms_imf.quad[3].g = g;
  CPostEffects::ms_imf.quad[3].b = b;
  CPostEffects::ms_imf.quad[3].a = a;
  CPostEffects::ms_imf.quad[3].x = xPos + xSize;
  CPostEffects::ms_imf.quad[3].y = yPos + ySize;
  sub_18B9D0(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
}

//----- (005B2B58) --------------------------------------------------------
void __fastcall CPostEffects::DrawQuadSetUVs(__int64 u1, __int64 u2, RwReal u3, RwReal v3, RwReal u4, RwReal v4)
{
  *(_QWORD *)&CPostEffects::ms_imf.quad[0].s = u1;
  CPostEffects::ms_imf.quad[2].s = u4;
  CPostEffects::ms_imf.quad[2].t = v4;
  *(_QWORD *)&CPostEffects::ms_imf.quad[1].s = u2;
  CPostEffects::ms_imf.quad[3].s = u3;
  CPostEffects::ms_imf.quad[3].t = v3;
}

//----- (005B2B90) --------------------------------------------------------
void __fastcall CPostEffects::DrawQuadSetPixelUVs(
        RwReal u1,
        RwReal v1,
        RwReal u2,
        RwReal v2,
        RwReal u3,
        RwReal v3,
        RwReal u4,
        RwReal v4)
{
  float v8; // s2
  float v9; // s0

  v8 = 1.0 / (float)CPostEffects::ms_imf.sizeDrawBufferY;
  v9 = 1.0 / (float)CPostEffects::ms_imf.sizeDrawBufferX;
  CPostEffects::ms_imf.quad[0].s = v9 * u1;
  CPostEffects::ms_imf.quad[0].t = v8 * v1;
  CPostEffects::ms_imf.quad[1].s = v9 * u2;
  CPostEffects::ms_imf.quad[1].t = v8 * v2;
  CPostEffects::ms_imf.quad[2].s = v9 * u4;
  CPostEffects::ms_imf.quad[2].t = v8 * v4;
  CPostEffects::ms_imf.quad[3].s = v9 * u3;
  CPostEffects::ms_imf.quad[3].t = v8 * v3;
}

//----- (005B2C1C) --------------------------------------------------------
void CPostEffects::Close()
{
  if ( CPostEffects::pRasterFrontBuffer )
  {
    RwRasterDestroy(CPostEffects::pRasterFrontBuffer);
    CPostEffects::pRasterFrontBuffer = 0;
  }
}

//----- (005B2C4C) --------------------------------------------------------
void CPostEffects::ScriptResetForEffects()
{
  CPostEffects::m_bInfraredVision = 0;
  CPostEffects::m_bNightVision = 0;
  CPostEffects::m_bHeatHazeFX = 0;
  CPostEffects::m_bDarknessFilter = 0;
  CPostEffects::m_bCCTV = 0;
  CWaterLevel::m_bWaterFogScript = 1;
}

//----- (005B2CB0) --------------------------------------------------------
void __fastcall CPostEffects::ScriptNightVisionSwitch(bool n)
{
  bool *v1; // r0

  if ( n )
  {
    v1 = &CPostEffects::m_bInfraredVision;
    CPostEffects::m_bNightVision = 1;
  }
  else
  {
    v1 = &CPostEffects::m_bNightVision;
  }
  *v1 = 0;
}

//----- (005B2CE0) --------------------------------------------------------
void __fastcall CPostEffects::ScriptInfraredVisionSwitch(bool n)
{
  bool *v1; // r0

  if ( n )
  {
    v1 = &CPostEffects::m_bNightVision;
    CPostEffects::m_bInfraredVision = 1;
  }
  else
  {
    v1 = &CPostEffects::m_bInfraredVision;
  }
  *v1 = 0;
}

//----- (005B2D10) --------------------------------------------------------
void __fastcall CPostEffects::ScriptHeatHazeFXSwitch(bool n)
{
  CPostEffects::m_bHeatHazeFX = n;
}

//----- (005B2D20) --------------------------------------------------------
void __fastcall CPostEffects::ScriptDarknessFilterSwitch(bool n, Int32 alpha)
{
  CPostEffects::m_bDarknessFilter = n;
  if ( alpha == -1 )
  {
    alpha = CPostEffects::m_DarknessFilterAlphaDefault;
  }
  else
  {
    if ( alpha <= 0 )
      alpha = 0;
    if ( alpha >= 255 )
      alpha = 255;
  }
  CPostEffects::m_DarknessFilterAlpha = alpha;
}

//----- (005B2D58) --------------------------------------------------------
void __fastcall CPostEffects::ScriptCCTVSwitch(bool n)
{
  CPostEffects::m_bCCTV = n;
}

//----- (005B2D68) --------------------------------------------------------
void CPostEffects::Render()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  __int64 v3; // d8
  __int64 v4; // d9
  char v5; // r0
  unsigned int blue; // r0
  unsigned int red; // r2
  unsigned int green; // r1
  float v9; // s16
  float v10; // s18
  CPlayerPed *PlayerPed; // r0
  float v12; // s16
  float v13; // s18
  CPlayerPed *v14; // r0
  float LightingFromCol; // s0
  float v16; // s2
  float v17; // s4
  float v18; // s6
  float v19; // s0
  float v20; // s8
  float v21; // s10
  float v22; // s8
  unsigned int v23; // r0
  float v24; // s10
  float v25; // s6
  float v26; // s8
  float v27; // s4
  unsigned int v28; // r2
  float v29; // s6
  float v30; // s8
  float v31; // s6
  unsigned int v32; // r3
  float v33; // s8
  float v34; // s4
  unsigned __int8 v35; // r4
  float screenHeight; // s16
  float screenWidth; // s18
  CVehicle *PlayerVehicle; // r0
  int32 m_vehicleType; // r1
  float v40; // r0
  _BOOL4 v41; // r0
  int v42; // r1
  RwRGBA_0 v43; // r0
  int32 m_nHighLightMinIntensity; // r0
  int v45; // r0
  bool v46; // zf
  __int64 v47; // r0
  bool v48; // r1
  int v49; // r0
  float v50; // s0
  float v51; // s2
  int v52; // r2
  int v53; // r3
  int v54; // r1
  int v55; // s6
  bool v56; // zf
  CLink<CPed *> *i; // r0
  FILE *v58; // r5
  int v59; // r4
  bool v60; // zf
  const CVector *PlayerSpeed; // r0
  CRGBA v62; // [sp+Ch] [bp-3Ch] BYREF
  CRGBA v63; // [sp+10h] [bp-38h] BYREF
  CRGBA v64; // [sp+14h] [bp-34h] BYREF
  __int64 v65; // [sp+18h] [bp-30h]
  __int64 v66; // [sp+20h] [bp-28h]

  if ( CPostEffects::m_bDisableAllPostEffect )
    return;
  v65 = v3;
  v66 = v4;
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  RwCameraEndUpdate(Scene.camera);
  RwRasterPushContext(CPostEffects::pRasterFrontBuffer);
  RwRasterRenderFast(Scene.camera->frameBuffer, 0, 0);
  RwRasterPopContext();
  RsCameraBeginUpdate(Scene.camera);
  v5 = `guard variable for'CPostEffects::Render(void)::extraMultiplierLocal;
  __dmb(0xBu);
  if ( (v5 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CPostEffects::Render(void)::extraMultiplierLocal) )
  {
    CPostEffects::Render(void)::extraMultiplierLocal = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
    _cxa_guard_release((__guard *)&`guard variable for'CPostEffects::Render(void)::extraMultiplierLocal);
  }
  if ( CPostEffects::m_bFog )
    CPostEffects::Fog();
  CRGBA::CRGBA(
    &v64,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Red,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Green,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Blue,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Alpha);
  CRGBA::CRGBA(
    &v63,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Red,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Green,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Blue,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Alpha);
  CRGBA::CRGBA(&v62, 0x7Fu, 0x7Fu, 0x7Fu, 0);
  if ( CPostEffects::m_bNightVision )
  {
    qmemcpy(&v64, "@@@", 3);
    qmemcpy(&v63, "@@@", 3);
  }
  if ( CPostEffects::m_bInfraredVision )
  {
    blue = 64;
    red = 64;
    qmemcpy(&v64, "@@@", 3);
    qmemcpy(&v63, "@@@", 3);
    green = 64;
  }
  else
  {
    red = v64._anon_0._anon_0.red;
    green = v64._anon_0._anon_0.green;
    blue = v64._anon_0._anon_0.blue;
  }
  v64._anon_0._anon_0.red = (unsigned int)(float)(gfLaRiotsLightMult * (float)red);
  v64._anon_0._anon_0.green = (unsigned int)(float)(gfLaRiotsLightMult * (float)green);
  v64._anon_0._anon_0.blue = (unsigned int)(float)(gfLaRiotsLightMult * (float)blue);
  if ( FindPlayerPed(-1) )
  {
    v9 = CTimer::ms_fTimeStep;
    v10 = CPostEffects::SCREEN_EXTRA_MULT_CHANGE_RATE;
    PlayerPed = FindPlayerPed(-1);
    v12 = v10 * v9;
    v13 = fabsf(CPhysical::GetLightingFromCol(PlayerPed, 0) - CPostEffects::Render(void)::extraMultiplierLocal);
    v14 = FindPlayerPed(-1);
    LightingFromCol = CPhysical::GetLightingFromCol(v14, 0);
    if ( v13 >= v12 )
    {
      v16 = -v12;
      if ( LightingFromCol > CPostEffects::Render(void)::extraMultiplierLocal )
        v16 = v12;
      LightingFromCol = CPostEffects::Render(void)::extraMultiplierLocal + v16;
    }
    CPostEffects::Render(void)::extraMultiplierLocal = LightingFromCol;
    if ( LightingFromCol > CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP )
    {
      LightingFromCol = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
      CPostEffects::Render(void)::extraMultiplierLocal = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
    }
    v17 = (float)(CPostEffects::SCREEN_EXTRA_MULT_BASE_MULT
                * (float)(1.0 - (float)(LightingFromCol / CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP)))
        + 1.0;
  }
  else
  {
    v17 = 1.0;
  }
  v18 = v17 * CPostEffects::m_colour1Multiplier;
  v19 = 0.0;
  v20 = (float)(v17 * CPostEffects::m_colour1Multiplier) * (float)v64._anon_0._anon_0.red;
  if ( v20 >= 255.0 || (v21 = 0.0, v20 > 0.0) )
  {
    v21 = 255.0;
    if ( v20 < 255.0 )
      v21 = (float)(v17 * CPostEffects::m_colour1Multiplier) * (float)v64._anon_0._anon_0.red;
  }
  v22 = v18 * (float)v64._anon_0._anon_0.green;
  v23 = (unsigned int)v21;
  v64._anon_0._anon_0.red = (unsigned int)v21;
  if ( v22 >= 255.0 || (v24 = 0.0, v22 > 0.0) )
  {
    v24 = 255.0;
    if ( v22 < 255.0 )
      v24 = v18 * (float)v64._anon_0._anon_0.green;
  }
  v25 = v18 * (float)v64._anon_0._anon_0.blue;
  v64._anon_0._anon_0.green = (unsigned int)v24;
  if ( v25 >= 255.0 || (v26 = 0.0, v25 > 0.0) )
  {
    v26 = 255.0;
    if ( v25 < 255.0 )
      v26 = v25;
  }
  v27 = v17 * CPostEffects::m_colour2Multiplier;
  v28 = (unsigned int)v26;
  v29 = v27 * (float)v63._anon_0._anon_0.red;
  v64._anon_0._anon_0.blue = (unsigned int)v26;
  if ( v29 >= 255.0 || (v30 = 0.0, v29 > 0.0) )
  {
    v30 = 255.0;
    if ( v29 < 255.0 )
      v30 = v27 * (float)v63._anon_0._anon_0.red;
  }
  v31 = v27 * (float)v63._anon_0._anon_0.green;
  v32 = (unsigned int)v30;
  v63._anon_0._anon_0.red = (unsigned int)v30;
  if ( v31 >= 255.0 || (v33 = 0.0, v31 > 0.0) )
  {
    v33 = 255.0;
    if ( v31 < 255.0 )
      v33 = v27 * (float)v63._anon_0._anon_0.green;
  }
  v34 = v27 * (float)v63._anon_0._anon_0.blue;
  v63._anon_0._anon_0.green = (unsigned int)v33;
  if ( v34 >= 255.0 || v34 > 0.0 )
  {
    v19 = 255.0;
    if ( v34 < 255.0 )
      v19 = v34;
  }
  v64._anon_0._anon_0.green = (unsigned int)v24;
  v64._anon_0._anon_0.red = v23;
  v64._anon_0._anon_0.blue = v28;
  v63._anon_0._anon_0.green = (unsigned int)v33;
  v63._anon_0._anon_0.red = v32;
  v63._anon_0._anon_0.blue = (unsigned int)v19;
  if ( CPostEffects::m_bColorEnable )
    CPostEffects::ColourFilter(v64.RwRGBA_0, v63.RwRGBA_0);
  if ( CPostEffects::m_bDarknessFilter && !((CPostEffects::m_bNightVision || CPostEffects::m_bInfraredVision) << 24) )
  {
    v35 = CPostEffects::m_DarknessFilterAlpha;
    CPostEffects::ImmediateModeRenderStatesStore();
    CPostEffects::ImmediateModeRenderStatesSet();
    screenHeight = (float)RsGlobal.screenHeight;
    screenWidth = (float)RsGlobal.screenWidth;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    CPostEffects::ms_imf.quad[0].y = 0.0;
    CPostEffects::ms_imf.quad[1].y = 0.0;
    *(_WORD *)&CPostEffects::ms_imf.quad[0].r = 0;
    CPostEffects::ms_imf.quad[0].b = 0;
    CPostEffects::ms_imf.quad[0].a = v35;
    *(_WORD *)&CPostEffects::ms_imf.quad[1].r = 0;
    CPostEffects::ms_imf.quad[1].b = 0;
    CPostEffects::ms_imf.quad[1].a = v35;
    CPostEffects::ms_imf.quad[2].x = 0.0;
    *(_WORD *)&CPostEffects::ms_imf.quad[2].r = 0;
    CPostEffects::ms_imf.quad[2].b = 0;
    CPostEffects::ms_imf.quad[2].a = v35;
    CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[1].x = screenWidth;
    CPostEffects::ms_imf.quad[2].y = screenHeight;
    CPostEffects::ms_imf.quad[0].x = 0.0;
    CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
    *(_WORD *)&CPostEffects::ms_imf.quad[3].r = 0;
    CPostEffects::ms_imf.quad[3].b = 0;
    CPostEffects::ms_imf.quad[3].a = v35;
    CPostEffects::ms_imf.quad[3].x = screenWidth;
    CPostEffects::ms_imf.quad[3].y = screenHeight;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
    CPostEffects::ImmediateModeRenderStatesReStore();
    CPostEffects::Radiosity(CPostEffects::m_DarknessFilterRadiosityIntensityLimit, 0, 2, 255);
  }
  if ( CPostEffects::m_bSpeedFXTestMode )
    CPostEffects::m_fSpeedFXManualSpeedCurrentFrame = 1.0;
  if ( !CPostEffects::m_bSpeedFX || !CPostEffects::m_bSpeedFXUserFlag || !CPostEffects::m_bSpeedFXUserFlagCurrentFrame )
    goto LABEL_66;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  v0.n64_f32[0] = CPostEffects::m_fSpeedFXManualSpeedCurrentFrame;
  if ( CPostEffects::m_fSpeedFXManualSpeedCurrentFrame != 0.0 )
    goto LABEL_64;
  if ( !PlayerVehicle )
    goto LABEL_66;
  m_vehicleType = PlayerVehicle->m_vehicleType;
  if ( (unsigned int)(m_vehicleType - 3) < 4 )
    goto LABEL_66;
  if ( !m_vehicleType
    && (PlayerVehicle->hFlagsLocal & 0x80000) != 0
    && *(float *)&PlayerVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_FramePositionLastUpdated < 0.0 )
  {
    v0.n64_f32[0] = (float)((float)(PlayerVehicle->m_vecMoveSpeed.x * PlayerVehicle->m_pMat->xy)
                          + (float)(PlayerVehicle->m_vecMoveSpeed.y * PlayerVehicle->m_pMat->yy))
                  + (float)(PlayerVehicle->m_vecMoveSpeed.z * PlayerVehicle->m_pMat->zy);
    if ( v0.n64_f32[0] > 0.2 )
    {
      v1.n64_u32[0] = 1.0;
      v0.n64_f32[0] = (float)(v0.n64_f32[0] + v0.n64_f32[0]) * (float)(PlayerVehicle->m_fGasPedal + 1.0);
      v2.n64_u32[0] = 0;
      v0.n64_u64[0] = vmax_f32(vmin_f32(v0, v1), v2).n64_u64[0];
      CPostEffects::m_fSpeedFXManualSpeedCurrentFrame = v0.n64_f32[0];
LABEL_64:
      v40 = v0.n64_f32[0];
LABEL_65:
      CPostEffects::SpeedFX(v40);
LABEL_66:
      v41 = CCutsceneMgr::ms_running;
      goto LABEL_67;
    }
  }
  v41 = CCutsceneMgr::ms_running;
  if ( !CCutsceneMgr::ms_running )
  {
    PlayerSpeed = FindPlayerSpeed(-1);
    v40 = sqrtf(
            (float)((float)(PlayerSpeed->x * PlayerSpeed->x) + (float)(PlayerSpeed->y * PlayerSpeed->y))
          + (float)(PlayerSpeed->z * PlayerSpeed->z));
    goto LABEL_65;
  }
LABEL_67:
  CPostEffects::m_bSpeedFXUserFlagCurrentFrame = 1;
  v42 = CCutsceneMgr::ms_cutsceneProcessing || v41;
  CPostEffects::m_fSpeedFXManualSpeedCurrentFrame = 0.0;
  v43 = (RwRGBA_0)(unsigned __int8)v42;
  if ( (_BYTE)v42 )
    v43 = (RwRGBA_0)1;
  CPostEffects::m_bInCutscene = v43._anon_0._anon_0.red;
  if ( CPostEffects::m_bNightVision )
  {
    if ( !(v42 << 24) )
    {
      CPostEffects::NightVision(v43);
      v43 = (RwRGBA_0)CPostEffects::m_bInCutscene;
    }
  }
  else
  {
    CPostEffects::m_fNightVisionSwitchOnFXCount = CPostEffects::m_fNightVisionSwitchOnFXTime;
  }
  if ( CPostEffects::m_bInfraredVision && !*(_DWORD *)&v43 )
    CPostEffects::InfraredVision(
      CPostEffects::m_InfraredVisionCol.RwRGBA_0,
      CPostEffects::m_InfraredVisionMainCol.RwRGBA_0);
  if ( CPostEffects::m_bRadiosity && !CPostEffects::m_bDarknessFilter )
  {
    if ( CPostEffects::m_bRadiosityBypassTimeCycleIntensityLimit )
      m_nHighLightMinIntensity = CPostEffects::m_RadiosityIntensityLimit;
    else
      m_nHighLightMinIntensity = CTimeCycle::m_CurrentColours.m_nHighLightMinIntensity;
    CPostEffects::Radiosity(
      m_nHighLightMinIntensity,
      CPostEffects::m_RadiosityFilterPasses,
      CPostEffects::m_RadiosityRenderPasses,
      CPostEffects::m_RadiosityIntensity);
  }
  v45 = CPostEffects::Render(void)::currentStrength;
  v46 = !CPostEffects::m_bRainEnable;
  if ( !CPostEffects::m_bRainEnable )
    v46 = CPostEffects::Render(void)::currentStrength == 0;
  if ( !v46 )
  {
    if ( (float)(CWeather::Rain * 128.0) > (float)CPostEffects::Render(void)::currentStrength )
      v45 = ++CPostEffects::Render(void)::currentStrength;
    if ( (float)(CWeather::Rain * 128.0) < (float)v45 )
      CPostEffects::Render(void)::currentStrength = --v45;
    if ( v45 <= 0 )
      v45 = 0;
    CPostEffects::Render(void)::currentStrength = v45;
    if ( !CCullZones::CamNoRain() )
      CCullZones::PlayerNoRain();
  }
  HIDWORD(v47) = CPostEffects::m_bHeatHazeFX;
  LODWORD(v47) = g_fxMan.m_foundHeatHazeInfo;
  if ( CWeather::HeatHaze <= 0.0 && !v47 && CWeather::UnderWaterness < CPostEffects::m_fWaterFXStartUnderWaterness )
    goto LABEL_102;
  if ( CPostEffects::m_bHeatHazeFX || CWeather::UnderWaterness >= CPostEffects::m_fWaterFXStartUnderWaterness )
  {
    v49 = 1065353216;
    v48 = 0;
    goto LABEL_101;
  }
  if ( CWeather::HeatHaze > 0.0 )
  {
    v48 = 0;
    v49 = LODWORD(CWeather::HeatHazeFXControl);
LABEL_101:
    CPostEffects::HeatHazeFX(*(float *)&v49, v48);
    goto LABEL_102;
  }
  if ( g_fxMan.m_foundHeatHazeInfo )
  {
    v49 = 1065353216;
    v48 = 1;
    goto LABEL_101;
  }
LABEL_102:
  if ( CPostEffects::m_waterEnable || CWeather::UnderWaterness >= CPostEffects::m_fWaterFXStartUnderWaterness )
  {
    if ( CPostEffects::m_bWaterDepthDarkness )
    {
      v0.n64_f32[0] = CPostEffects::m_fWaterFullDarknessDepth;
      v1.n64_f32[0] = CWeather::WaterDepth;
      v1.n64_u64[0] = vmin_f32(v1, v0).n64_u64[0];
      v50 = 1.0 - (float)(v1.n64_f32[0] / CPostEffects::m_fWaterFullDarknessDepth);
    }
    else
    {
      v50 = 1.0;
    }
    v2.n64_u32[0] = 24.0;
    v1.n64_f32[0] = CPostEffects::Render(void)::gfWaterGreen + CTimer::ms_fTimeStep;
    LODWORD(v51) = vmin_f32(v1, v2).n64_u32[0];
    v52 = CPostEffects::m_waterCol._anon_0._anon_0.red + 184;
    v53 = 255;
    if ( (unsigned int)v52 >= 0xFF )
      v52 = 255;
    v54 = CPostEffects::m_waterCol._anon_0._anon_0.blue + 184;
    v55 = (int)(float)(CPostEffects::Render(void)::gfWaterGreen + 184.0);
    if ( (unsigned int)v54 >= 0xFF )
      v54 = 255;
    if ( CPostEffects::m_waterCol._anon_0._anon_0.green + v55 < 255 )
      v53 = CPostEffects::m_waterCol._anon_0._anon_0.green + v55;
    CPostEffects::Render(void)::gfWaterGreen = v51;
    CPostEffects::UnderWaterRipple(
      (RwRGBA_0)((unsigned int)(float)(v50 * (float)v52) | ((unsigned int)(float)(v50 * (float)v54) << 16) | ((unsigned int)(float)(v50 * (float)v53) << 8)),
      (float)(CPostEffects::m_xoffset * (float)(v51 / 24.0)) * (float)((float)RsGlobal.screenWidth / 640.0),
      CPostEffects::m_yoffset * (float)((float)RsGlobal.screenHeight / 448.0),
      (unsigned int)(float)(v50 * (float)v53),
      CPostEffects::m_waterSpeed,
      CPostEffects::m_waterFreq);
  }
  else
  {
    CPostEffects::Render(void)::gfWaterGreen = 0.0;
  }
  if ( CPostEffects::m_bCCTV )
    CPostEffects::CCTV();
  if ( CWeapon::ms_bTakePhoto )
  {
    v56 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v56 = gMobileMenu.pendingScreen == 0;
    if ( v56 )
    {
      if ( CPostEffects::Render(void)::done_wait_one_frame )
      {
        CPostEffects::Render(void)::done_wait_one_frame = 0;
        CTimer::Suspend();
        if ( CPostEffects::Render(void)::m_SavePhotoInGallery == 1 )
        {
          CVisibilityPlugins::RenderWeaponPedsForPC();
          for ( i = CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext;
                CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext != &CVisibilityPlugins::ms_weaponPedsForPC.m_lastLink;
                i = CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext )
          {
            i->m_pNext->m_pPrev = i->m_pPrev;
            i->m_pPrev->m_pNext = i->m_pNext;
            i->m_pNext = CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext;
            CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext->m_pPrev = i;
            i->m_pPrev = &CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink;
            CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext = i;
          }
          CFileMgr::SetDirMyDocuments();
          sprintf(gString, "Gallery\\gallery%d.jpg", 1);
          v58 = fopen((const char *)gString, "r");
          if ( v58 )
          {
            v59 = 2;
            do
            {
              sprintf(gString, "Gallery\\gallery%d.jpg", v59);
              fclose(v58);
              ++v59;
              v58 = fopen((const char *)gString, "r");
            }
            while ( v58 );
          }
          JPegCompressScreenToFile(TheCamera.m_pRwCamera, gString);
          CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
        }
        CTimer::Resume();
        v60 = gMobileMenu.screenStack.numEntries == 0;
        if ( !gMobileMenu.screenStack.numEntries )
          v60 = gMobileMenu.pendingScreen == 0;
        if ( v60 )
        {
          CSpecialFX::SnapShotFrames = 0;
          CSpecialFX::bSnapShotActive = 1;
        }
        CPostEffects::Render(void)::m_SavePhotoInGallery = 0;
        CWeapon::ms_bTakePhoto = 0;
        CPostEffects::m_bSavePhotoFromScript = 0;
      }
      else
      {
        if ( FrontEndMenuManager.m_PrefsSavePhotosToGallery )
          CPostEffects::Render(void)::m_SavePhotoInGallery = 1;
        CPostEffects::Render(void)::done_wait_one_frame = 1;
      }
    }
    else
    {
      CPostEffects::m_bSavePhotoFromScript = 0;
      CWeapon::ms_bTakePhoto = 0;
    }
  }
}
// 5B2D80: variable 'v3' is possibly undefined
// 5B2D80: variable 'v4' is possibly undefined
// 5B3416: variable 'v0' is possibly undefined
// 5B3416: variable 'v1' is possibly undefined
// 5B341A: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 61CADE: using guessed type char byte_61CADE;
// 676668: using guessed type char *CPostEffects::m_bNightVision[2];
// 678FE0: using guessed type char *CPostEffects::m_bInfraredVision;
// A478D0: using guessed type char `guard variable for'CPostEffects::Render(void)::extraMultiplierLocal;
// A478DC: using guessed type char CPostEffects::Render(void)::done_wait_one_frame;
// A478DD: using guessed type char CPostEffects::Render(void)::m_SavePhotoInGallery;

//----- (005B3BB0) --------------------------------------------------------
void CPostEffects::Fog()
{
  RwRaster_0 *raster; // r5
  float screenWidth; // s22
  float screenHeight; // s20
  const CVector *PlayerSpeed; // r0
  float v4; // s16
  float v5; // s18
  float v6; // s2
  float v7; // s4
  float v8; // s20
  float v9; // s22
  float v10; // s23
  int v11; // r1
  float v12; // s24
  float v13; // s26
  int v14; // r8
  unsigned __int8 m_nSkyBottomBlue; // r9
  unsigned __int8 m_nSkyBottomGreen; // r11
  unsigned __int8 m_nSkyBottomRed; // r6
  float v18; // s25
  float v19; // s0
  float v20; // s27
  float v21; // r0
  int i; // r4
  float v23; // s23
  float v24; // s25
  float v25; // s0
  float v26; // s27
  float v27; // r0

  raster = CClouds::ms_vc.pTexture[0]->raster;
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  screenWidth = (float)RsGlobal.screenWidth;
  screenHeight = (float)RsGlobal.screenHeight;
  PlayerSpeed = FindPlayerSpeed(-1);
  v4 = screenHeight / 1.5;
  v5 = screenWidth / 1.5;
  v6 = CTimer::ms_fTimeStep * 0.25;
  v7 = gfFogRadius;
  v8 = screenHeight * 0.5;
  v9 = screenWidth * 0.5;
  if ( sqrtf(
         (float)((float)(PlayerSpeed->x * PlayerSpeed->x) + (float)(PlayerSpeed->y * PlayerSpeed->y))
       + (float)(PlayerSpeed->z * PlayerSpeed->z)) <= 0.06 )
  {
    v10 = gfFogRadius - v6;
    gfFogRadius = gfFogRadius - v6;
    if ( (float)(v7 - v6) < 0.0 )
    {
      v11 = 0;
      v10 = 0.0;
      goto LABEL_6;
    }
  }
  else
  {
    v10 = gfFogRadius + v6;
    gfFogRadius = v10;
    if ( v10 > 160.0 )
    {
      v11 = 1126170624;
      v10 = 160.0;
LABEL_6:
      LODWORD(gfFogRadius) = v11;
    }
  }
  v12 = v4 * 0.5;
  v13 = v5 * 0.5;
  v14 = 0;
  m_nSkyBottomBlue = CTimeCycle::m_CurrentColours.m_nSkyBottomBlue;
  m_nSkyBottomGreen = CTimeCycle::m_CurrentColours.m_nSkyBottomGreen;
  m_nSkyBottomRed = CTimeCycle::m_CurrentColours.m_nSkyBottomRed;
  while ( 1 )
  {
    v18 = gfFogAngle;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
    v19 = (float)((float)((float)((float)v14 * 36.0) + v18) * 3.1416) / 180.0;
    v20 = cosf(v19);
    v21 = sinf(v19);
    CPostEffects::ms_imf.quad[0].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[0].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[0].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[0].a = 11;
    CPostEffects::ms_imf.quad[1].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[1].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[1].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[1].a = 11;
    CPostEffects::ms_imf.quad[2].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[2].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[2].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[2].a = 11;
    CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[0].x = (float)(v9 + (float)((float)((float)(v9 * 0.5) + v10) * v20)) - v13;
    CPostEffects::ms_imf.quad[0].y = (float)(v8 + (float)((float)((float)(v8 * 0.5) + v10) * v21)) - v12;
    CPostEffects::ms_imf.quad[1].x = v5 + CPostEffects::ms_imf.quad[0].x;
    CPostEffects::ms_imf.quad[1].y = CPostEffects::ms_imf.quad[0].y;
    CPostEffects::ms_imf.quad[2].x = CPostEffects::ms_imf.quad[0].x;
    CPostEffects::ms_imf.quad[2].y = v4 + CPostEffects::ms_imf.quad[0].y;
    CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[3].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[3].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[3].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[3].a = 11;
    CPostEffects::ms_imf.quad[3].x = v5 + CPostEffects::ms_imf.quad[0].x;
    CPostEffects::ms_imf.quad[3].y = v4 + CPostEffects::ms_imf.quad[0].y;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
    if ( v14 == 9 )
      break;
    ++v14;
    v10 = gfFogRadius;
  }
  for ( i = 0; i != 10; ++i )
  {
    v23 = gfFogRadius;
    v24 = gfFogAngle;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
    v25 = (float)((float)((float)((float)i * 36.0) + v24) * -3.1416) / 180.0;
    v26 = cosf(v25);
    v27 = sinf(v25);
    CPostEffects::ms_imf.quad[0].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[0].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[0].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[0].a = 11;
    CPostEffects::ms_imf.quad[1].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[1].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[1].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[1].a = 11;
    CPostEffects::ms_imf.quad[2].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[2].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[2].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[2].a = 11;
    CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[0].x = (float)(v9 + (float)((float)((float)(v9 * 0.7) + v23) * v26)) - v13;
    CPostEffects::ms_imf.quad[0].y = (float)(v8 + (float)((float)((float)(v8 * 0.7) + v23) * v27)) - v12;
    CPostEffects::ms_imf.quad[1].x = v5 + CPostEffects::ms_imf.quad[0].x;
    CPostEffects::ms_imf.quad[1].y = CPostEffects::ms_imf.quad[0].y;
    CPostEffects::ms_imf.quad[2].x = CPostEffects::ms_imf.quad[0].x;
    CPostEffects::ms_imf.quad[2].y = v4 + CPostEffects::ms_imf.quad[0].y;
    CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[3].r = m_nSkyBottomRed;
    CPostEffects::ms_imf.quad[3].g = m_nSkyBottomGreen;
    CPostEffects::ms_imf.quad[3].b = m_nSkyBottomBlue;
    CPostEffects::ms_imf.quad[3].a = 11;
    CPostEffects::ms_imf.quad[3].x = v5 + CPostEffects::ms_imf.quad[0].x;
    CPostEffects::ms_imf.quad[3].y = v4 + CPostEffects::ms_imf.quad[0].y;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
  }
  gfFogAngle = gfFogAngle + (float)(CTimer::ms_fTimeStep / 6.0);
  CPostEffects::ImmediateModeRenderStatesReStore();
}
// 0: using guessed type int dword_0;
// 98: using guessed type int dword_98;
// B4: using guessed type int dword_B4;
// D0: using guessed type int dword_D0;
// EC: using guessed type int;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005B3F98) --------------------------------------------------------
void __fastcall CPostEffects::ColourFilter(RwRGBA_0 col1, RwRGBA_0 col2)
{
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  *(RwRGBA_0 *)&pe_vertex[0].r = col1;
  *(RwRGBA_0 *)&pe_vertex[1].r = col1;
  *(RwRGBA_0 *)&pe_vertex[2].r = col1;
  *(RwRGBA_0 *)&pe_vertex[3].r = col1;
  RwIm2DRenderIndexedPrimitive(rwPRIMTYPETRILIST, pe_vertex, 4, pe_index, 6);
  *(RwRGBA_0 *)&pe_vertex[0].r = col2;
  *(RwRGBA_0 *)&pe_vertex[1].r = col2;
  *(RwRGBA_0 *)&pe_vertex[2].r = col2;
  *(RwRGBA_0 *)&pe_vertex[3].r = col2;
  RwIm2DRenderIndexedPrimitive(rwPRIMTYPETRILIST, pe_vertex, 4, pe_index, 6);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 10: using guessed type __int16 word_10;
// 12: using guessed type __int16 word_12;
// 2C: using guessed type __int16 word_2C;
// 2E: using guessed type __int16 word_2E;
// 48: using guessed type int dword_48;
// 64: using guessed type int dword_64;

//----- (005B40DC) --------------------------------------------------------
void __fastcall CPostEffects::DarknessFilter(Int32 alpha)
{
  unsigned __int8 v1; // r4
  float screenHeight; // s16
  float screenWidth; // s18

  v1 = alpha;
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  screenHeight = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  CPostEffects::ms_imf.quad[0].y = 0.0;
  CPostEffects::ms_imf.quad[1].y = 0.0;
  *(_WORD *)&CPostEffects::ms_imf.quad[0].r = 0;
  CPostEffects::ms_imf.quad[0].b = 0;
  CPostEffects::ms_imf.quad[0].a = v1;
  *(_WORD *)&CPostEffects::ms_imf.quad[1].r = 0;
  CPostEffects::ms_imf.quad[1].b = 0;
  CPostEffects::ms_imf.quad[1].a = v1;
  CPostEffects::ms_imf.quad[2].x = 0.0;
  *(_WORD *)&CPostEffects::ms_imf.quad[2].r = 0;
  CPostEffects::ms_imf.quad[2].b = 0;
  CPostEffects::ms_imf.quad[2].a = v1;
  CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].x = screenWidth;
  CPostEffects::ms_imf.quad[2].y = screenHeight;
  CPostEffects::ms_imf.quad[0].x = 0.0;
  CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
  *(_WORD *)&CPostEffects::ms_imf.quad[3].r = 0;
  CPostEffects::ms_imf.quad[3].b = 0;
  CPostEffects::ms_imf.quad[3].a = v1;
  CPostEffects::ms_imf.quad[3].x = screenWidth;
  CPostEffects::ms_imf.quad[3].y = screenHeight;
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
  CPostEffects::ImmediateModeRenderStatesReStore();
}

//----- (005B4194) --------------------------------------------------------
void __fastcall CPostEffects::Radiosity(Int32 intensityLimit, Int32 filterPasses, Int32 renderPasses, Int32 intensity)
{
  char v5; // r10
  int v7; // r5
  int v8; // r8
  float v9; // s0
  RwInt32 screenHeight; // r1
  float v11; // s0
  Int32 v12; // lr
  RwCamera_0 *camera; // r1
  RwRaster_0 *v14; // r2
  float v15; // s0
  float v16; // s2
  RwIm2DVertex *v17; // r3
  int v18; // s10
  int v19; // s8
  int v20; // kr00_4
  int v21; // kr08_4
  float height; // s6
  float width; // s4
  float v24; // s6
  float v25; // s4
  float nearPlane; // s4
  int v27; // r0
  char *v28; // r2
  RwCamera_0 *v29; // r3
  float v30; // s0
  float v31; // s0
  RwInt32 v32; // r2
  char *v33; // r1
  _BOOL4 v34; // r4
  char v35; // r1
  char v36; // r11
  Int32 v37; // lr
  RwCamera_0 *v38; // r6
  RwRaster_0 *v39; // r2
  float v40; // s4
  float screenWidth; // s6
  Int32 v42; // r10
  RwIm2DVertex *v43; // r0
  float v44; // s10
  float v45; // s8
  float v46; // s8
  Int32 v47; // r0
  RwRaster_0 *v48; // r1
  RwCamera_0 *v49; // r2
  float v50; // s4
  float v51; // s6
  float *v52; // r6
  int v53; // r3
  float v54; // s10
  float v55; // s8
  float v56; // s8
  int v57; // [sp+4h] [bp-34h]
  char v58; // [sp+8h] [bp-30h]

  v5 = intensityLimit;
  v58 = intensity;
  v7 = CPostEffects::m_RadiosityPixelsX;
  v8 = CPostEffects::m_RadiosityPixelsY;
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  TempVertexBuffer.m_2d[0].t = 0.0;
  TempVertexBuffer.m_2d[0].s = 0.0;
  TempVertexBuffer.m_2d[0].y = 0.0;
  TempVertexBuffer.m_2d[0].x = 0.0;
  TempBufferVerticesStored = 0;
  TempVertexBuffer.m_2d[0].z = 0.0;
  v9 = 1.0 / Scene.camera->nearPlane;
  TempVertexBuffer.m_2d[1].s = 1.0;
  TempVertexBuffer.m_2d[1].t = 1.0;
  TempVertexBuffer.m_2d[0].rhw = v9;
  if ( CPostEffects::m_bRadiosityStripCopyMode )
  {
    screenHeight = RsGlobal.screenHeight;
    TempVertexBuffer.m_2d[1].x = (float)RsGlobal.screenWidth;
  }
  else
  {
    TempVertexBuffer.m_2d[1].x = (float)v7;
    screenHeight = v8;
  }
  TempVertexBuffer.m_2d[1].z = 0.0;
  TempVertexBuffer.m_2d[1].y = (float)screenHeight;
  v11 = 1.0 / Scene.camera->nearPlane;
  TempBufferVerticesStored = 0;
  TempVertexBuffer.m_2d[1].rhw = v11;
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  if ( filterPasses >= 1 )
  {
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    v12 = TempBufferVerticesStored;
    camera = Scene.camera;
    v14 = CPostEffects::pRasterFrontBuffer;
    v15 = (float)CPostEffects::m_RadiosityFilterVCorrection;
    v16 = (float)CPostEffects::m_RadiosityFilterUCorrection;
    v17 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
    v57 = 2 * filterPasses;
    do
    {
      v18 = v7;
      v19 = v8;
      v20 = v7;
      v21 = v8;
      height = (float)v14->height;
      --filterPasses;
      width = (float)v14->width;
      v17->x = 0.0;
      v17->y = 0.0;
      v17->z = 0.0;
      v8 /= 2;
      v7 /= 2;
      v17->s = v16 / width;
      v17->t = v15 / height;
      v17->rhw = 1.0 / camera->nearPlane;
      v24 = (float)v19 / (float)v14->height;
      v25 = (float)v18 / (float)v14->width;
      v17[1].x = (float)(v20 / 2 + 1);
      v17[1].y = (float)(v21 / 2 + 1);
      v17[1].z = 0.0;
      v17[1].s = v25;
      v17[1].t = v24;
      nearPlane = camera->nearPlane;
      *(_DWORD *)&v17->r = -1;
      *(_DWORD *)&v17[1].r = -1;
      v17[1].rhw = 1.0 / nearPlane;
      v17 += 2;
    }
    while ( filterPasses );
    TempBufferVerticesStored = v57 + v12;
  }
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  v27 = TempBufferVerticesStored;
  v28 = (char *)&TempVertexBuffer + 28 * TempBufferVerticesStored;
  *(int *)((char *)&elf_hash_chain[1959] + (_DWORD)v28) = 0;
  *((_DWORD *)v28 + 18432) = 0;
  *(int *)((char *)&elf_hash_chain[1960] + (_DWORD)v28) = 0;
  v29 = Scene.camera;
  v30 = 1.0 / Scene.camera->nearPlane;
  *(int *)((char *)&elf_hash_chain[1967] + (_DWORD)v28) = 0;
  *(float *)((char *)&elf_hash_chain[1966] + (_DWORD)v28) = (float)(v8 + 1);
  *((float *)v28 + 18439) = (float)(v7 + 1);
  *(float *)((char *)&elf_hash_chain[1961] + (_DWORD)v28) = v30;
  v31 = 1.0 / v29->nearPlane;
  v28[73773] = v5;
  *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v28) = v5;
  v28[73774] = v5;
  v28[73775] = 0x80;
  v28[73745] = v5;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v28) = v5;
  v28[73746] = v5;
  v28[73747] = 0x80;
  *(float *)((char *)&elf_hash_chain[1968] + (_DWORD)v28) = v31;
  v32 = v27 + 2;
  TempBufferVerticesStored = v27 + 2;
  if ( renderPasses >= 1 )
  {
    if ( v27 >= 1 )
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, TempVertexBuffer.m_2d, v32);
    TempBufferVerticesStored = 0;
    if ( CPostEffects::m_bRadiosityLinearFilter )
      v33 = (char *)&dword_0 + 2;
    else
      v33 = (_BYTE *)(&dword_0 + 3);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, v33);
    v34 = CPostEffects::m_bRadiosityStripCopyMode;
    if ( !CPostEffects::m_bRadiosityStripCopyMode )
    {
      v35 = CPostEffects::m_bRadiosityDebug;
      v36 = v58;
      if ( CPostEffects::m_bRadiosityDebug )
        v36 = -1;
      v37 = TempBufferVerticesStored;
      v38 = Scene.camera;
      v39 = CPostEffects::pRasterFrontBuffer;
      v40 = (float)RsGlobal.screenHeight;
      screenWidth = (float)RsGlobal.screenWidth;
      if ( CPostEffects::m_bRadiosityDebug )
        v35 = -1;
      v42 = renderPasses;
      v43 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      do
      {
        v43->s = 0.0;
        v43->t = 0.0;
        --v42;
        v43->x = 0.0;
        v43->y = 0.0;
        v43->z = 0.0;
        v43->rhw = 1.0 / v38->nearPlane;
        v44 = (float)v39->height;
        v45 = (float)v39->width;
        v43[1].x = screenWidth;
        v43[1].y = v40;
        v43[1].z = 0.0;
        v43[1].s = (float)v7 / v45;
        v43[1].t = (float)v8 / v44;
        v46 = v38->nearPlane;
        v43->r = v35;
        v43->g = v35;
        v43->b = v35;
        v43->a = v36;
        v43[1].r = v35;
        v43[1].g = v35;
        v43[1].b = v35;
        v43[1].a = v36;
        v43[1].rhw = 1.0 / v46;
        v43 += 2;
      }
      while ( v42 );
      TempBufferVerticesStored = v37 + 2 * renderPasses;
      if ( !v34 )
      {
        v32 = TempBufferVerticesStored;
        if ( TempBufferVerticesStored < 3 )
          goto LABEL_27;
        goto LABEL_26;
      }
    }
    v47 = TempBufferVerticesStored;
    v48 = CPostEffects::pRasterFrontBuffer;
    v49 = Scene.camera;
    v50 = (float)RsGlobal.screenHeight;
    v51 = (float)RsGlobal.screenWidth;
    v52 = (float *)((char *)&elf_hash_chain[1971] + (_DWORD)&TempVertexBuffer + 28 * TempBufferVerticesStored);
    v53 = 2 * renderPasses;
    do
    {
      *(v52 - 8) = 0.0;
      *(v52 - 7) = 0.0;
      --renderPasses;
      *(v52 - 13) = 0.0;
      *(v52 - 12) = 0.0;
      *(v52 - 11) = 0.0;
      *(v52 - 10) = 1.0 / v49->nearPlane;
      v54 = (float)v48->height;
      v55 = (float)v48->width;
      *(v52 - 6) = v51;
      *(v52 - 5) = v50;
      *(v52 - 4) = 0.0;
      *(v52 - 1) = (float)v7 / v55;
      *v52 = (float)v8 / v54;
      v56 = v49->nearPlane;
      *((_WORD *)v52 - 18) = 0;
      *((_BYTE *)v52 - 34) = 0;
      *((_BYTE *)v52 - 33) = v58;
      *((_BYTE *)v52 - 8) = 0;
      *((_BYTE *)v52 - 7) = 0;
      *((_BYTE *)v52 - 6) = 0;
      *((_BYTE *)v52 - 5) = v58;
      *(v52 - 3) = 1.0 / v56;
      v52 += 14;
    }
    while ( renderPasses );
    v32 = v47 + v53;
    TempBufferVerticesStored = v47 + v53;
  }
  if ( v32 >= 3 )
LABEL_26:
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, TempVertexBuffer.m_2d, v32);
LABEL_27:
  TempBufferVerticesStored = 0;
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005B48C8) --------------------------------------------------------
void __fastcall CPostEffects::SpeedFX(float speed)
{
  int DirectionWasLooking; // r8
  int v2; // r0
  unsigned int v3; // r5
  fxSpeedSettings *v4; // r0
  int nShift; // r6
  int nLoops; // r9
  int nShake; // r4
  float32x2_t v8; // d9
  int32x2_t v9; // d10
  unsigned __int64 v10; // d8
  float v11; // s27
  float v12; // s4
  float v13; // s29
  float v14; // s31
  int v15; // r6
  float fFrontBufferV2; // s0
  float fFrontBufferU2; // s2
  float v18; // s6
  float v19; // s4
  float v20; // s22
  float v21; // s24
  float v22; // s28
  float v23; // s19
  float v24; // s23
  float v25; // s25
  float v26; // s30
  float v27; // s21
  float v28; // s6
  float v29; // s2
  RwInt32 screenWidth; // s2
  RwInt32 screenHeight; // s1
  unsigned __int8 v32; // r10
  float v33; // [sp+8h] [bp-70h]

  DirectionWasLooking = TheCamera.Cams[TheCamera.ActiveCam].DirectionWasLooking;
  if ( FX_SPEED_VARS[6].fSpeedThreshHold <= speed )
  {
    v2 = 6;
  }
  else if ( FX_SPEED_VARS[5].fSpeedThreshHold <= speed )
  {
    v2 = 5;
  }
  else if ( FX_SPEED_VARS[4].fSpeedThreshHold <= speed )
  {
    v2 = 4;
  }
  else if ( FX_SPEED_VARS[3].fSpeedThreshHold <= speed )
  {
    v2 = 3;
  }
  else if ( FX_SPEED_VARS[2].fSpeedThreshHold <= speed )
  {
    v2 = 2;
  }
  else if ( FX_SPEED_VARS[1].fSpeedThreshHold <= speed )
  {
    v2 = 1;
  }
  else
  {
    if ( FX_SPEED_VARS[0].fSpeedThreshHold > speed )
      return;
    v2 = 0;
  }
  v3 = DirectionWasLooking - 1;
  v4 = &FX_SPEED_VARS[v2];
  nShift = v4->nShift;
  nLoops = v4->nLoops;
  nShake = v4->nShake;
  if ( (unsigned int)(DirectionWasLooking - 1) < 2 )
  {
    nShift /= 2;
    nShake = 0;
  }
  if ( nLoops >= 1 )
  {
    CPostEffects::ImmediateModeRenderStatesStore();
    CPostEffects::ImmediateModeRenderStatesSet();
    if ( nShake < 1 )
    {
      v10 = 0LL;
    }
    else
    {
      v8.n64_u64[0] = *(unsigned __int64 *)&CPostEffects::ms_imf.fFrontBufferU2;
      v9.n64_u32[0] = rand();
      v9.n64_u32[1] = rand();
      v10 = vadd_f32(
              vmul_f32(
                vmul_n_f32(v8, (float)nShake / 250.0),
                vmul_f32(vcvt_f32_s32(v9), (float32x2_t)0x3000000030000000LL)),
              0LL).n64_u64[0];
    }
    v11 = *(float *)&v10;
    v12 = (float)nShift;
    v13 = *((float *)&v10 + 1);
    v14 = *(float *)&v10;
    v15 = nLoops - 1;
    fFrontBufferV2 = CPostEffects::ms_imf.fFrontBufferV2;
    fFrontBufferU2 = CPostEffects::ms_imf.fFrontBufferU2;
    v18 = (float)(CPostEffects::ms_imf.fFrontBufferV2 * v12) / 400.0;
    v19 = (float)(CPostEffects::ms_imf.fFrontBufferU2 * v12) / 400.0;
    v20 = -v18;
    v33 = v18;
    v21 = -v19;
    v22 = v19;
    v23 = v18;
    v24 = v18;
    v25 = v19;
    v26 = -v18;
    v27 = -v19;
    while ( 1 )
    {
      if ( v3 < 2 )
        v20 = 0.0;
      if ( DirectionWasLooking == 1 )
        v21 = 0.0;
      if ( v3 < 2 )
      {
        v26 = 0.0;
        v23 = 0.0;
      }
      if ( DirectionWasLooking == 2 )
        v22 = 0.0;
      if ( DirectionWasLooking == 1 )
        v27 = 0.0;
      v28 = v21 + fFrontBufferU2;
      v29 = v27 + fFrontBufferU2;
      if ( DirectionWasLooking == 2 )
        v25 = 0.0;
      if ( v3 < 2 )
      {
        v24 = 0.0;
        v11 = 0.0;
        HIDWORD(v10) = 0;
      }
      if ( v3 < 2 )
      {
        v13 = 0.0;
        v14 = 0.0;
      }
      CPostEffects::ms_imf.quad[1].s = v29 - v11;
      screenWidth = RsGlobal.screenWidth;
      screenHeight = RsGlobal.screenHeight;
      v32 = CPostEffects::m_SpeedFXAlpha;
      CPostEffects::ms_imf.quad[3].s = v28 - v11;
      CPostEffects::ms_imf.quad[3].t = (float)(v26 + fFrontBufferV2) - *((float *)&v10 + 1);
      CPostEffects::ms_imf.quad[0].s = v14 + (float)(v25 + CPostEffects::ms_imf.fFrontBufferU1);
      CPostEffects::ms_imf.quad[0].t = v13 + (float)(v24 + CPostEffects::ms_imf.fFrontBufferV1);
      CPostEffects::ms_imf.quad[1].t = v13 + (float)(v23 + CPostEffects::ms_imf.fFrontBufferV1);
      CPostEffects::ms_imf.quad[2].s = v14 + (float)(v22 + CPostEffects::ms_imf.fFrontBufferU1);
      CPostEffects::ms_imf.quad[2].t = (float)(v20 + fFrontBufferV2) - v11;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
      CPostEffects::ms_imf.quad[0].y = 0.0;
      *(_WORD *)&CPostEffects::ms_imf.quad[0].r = -1;
      CPostEffects::ms_imf.quad[0].b = -1;
      CPostEffects::ms_imf.quad[1].y = 0.0;
      CPostEffects::ms_imf.quad[0].a = v32;
      CPostEffects::ms_imf.quad[1].x = (float)screenWidth;
      *(_WORD *)&CPostEffects::ms_imf.quad[1].r = -1;
      CPostEffects::ms_imf.quad[1].b = -1;
      CPostEffects::ms_imf.quad[1].a = v32;
      CPostEffects::ms_imf.quad[2].x = 0.0;
      CPostEffects::ms_imf.quad[2].y = (float)screenHeight;
      *(_WORD *)&CPostEffects::ms_imf.quad[2].r = -1;
      CPostEffects::ms_imf.quad[2].b = -1;
      CPostEffects::ms_imf.quad[2].a = v32;
      CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[0].x = 0.0;
      CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
      *(_WORD *)&CPostEffects::ms_imf.quad[3].r = -1;
      CPostEffects::ms_imf.quad[3].b = -1;
      CPostEffects::ms_imf.quad[3].a = v32;
      CPostEffects::ms_imf.quad[3].x = (float)screenWidth;
      CPostEffects::ms_imf.quad[3].y = (float)screenHeight;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
      if ( !v15 )
        break;
      --v15;
      v25 = v19 + v25;
      v24 = v33 + v24;
      v27 = v27 - v19;
      v23 = v33 + v23;
      v21 = v21 - v19;
      v22 = v19 + v22;
      fFrontBufferU2 = CPostEffects::ms_imf.fFrontBufferU2;
      v26 = v26 - v33;
      v20 = v20 - v33;
      fFrontBufferV2 = CPostEffects::ms_imf.fFrontBufferV2;
    }
    CPostEffects::ms_imf.quad[0].s = 0.0;
    CPostEffects::ms_imf.quad[0].t = 0.0;
    CPostEffects::ms_imf.quad[2].s = 0.0;
    CPostEffects::ms_imf.quad[2].t = 1.0;
    CPostEffects::ms_imf.quad[1].s = 1.0;
    CPostEffects::ms_imf.quad[1].t = 0.0;
    CPostEffects::ms_imf.quad[3].s = 1.0;
    CPostEffects::ms_imf.quad[3].t = 1.0;
    CPostEffects::ImmediateModeRenderStatesReStore();
  }
}
// 98: using guessed type int dword_98;
// B4: using guessed type int dword_B4;
// D0: using guessed type int dword_D0;
// EC: using guessed type int;

//----- (005B4CC8) --------------------------------------------------------
void __fastcall CPostEffects::NightVision(RwRGBA_0 colour)
{
  RwRaster_0 *pRasterDrawBuffer; // r8
  float v2; // s0
  int v3; // r5
  Int32 sizeDrawBufferX; // s0
  Int32 sizeDrawBufferY; // s2
  float screenHeight; // s16
  float screenWidth; // s18

  if ( CPostEffects::m_fNightVisionSwitchOnFXCount > 0.0 )
  {
    pRasterDrawBuffer = CPostEffects::ms_imf.pRasterDrawBuffer;
    v2 = CPostEffects::m_fNightVisionSwitchOnFXCount - CTimer::ms_fTimeStep;
    if ( (float)(CPostEffects::m_fNightVisionSwitchOnFXCount - CTimer::ms_fTimeStep) <= 0.0 )
      v2 = 0.0;
    CPostEffects::m_fNightVisionSwitchOnFXCount = v2;
    CPostEffects::ImmediateModeRenderStatesStore();
    CPostEffects::ImmediateModeRenderStatesSet();
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    v3 = (int)CPostEffects::m_fNightVisionSwitchOnFXCount;
    if ( (int)CPostEffects::m_fNightVisionSwitchOnFXCount >= 1 )
    {
      do
      {
        sizeDrawBufferX = CPostEffects::ms_imf.sizeDrawBufferX;
        sizeDrawBufferY = CPostEffects::ms_imf.sizeDrawBufferY;
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, pRasterDrawBuffer);
        *(_DWORD *)&CPostEffects::ms_imf.quad[0].r = -16250872;
        *(_DWORD *)&CPostEffects::ms_imf.quad[1].r = -16250872;
        CPostEffects::ms_imf.quad[2].x = 0.0;
        *(_DWORD *)&CPostEffects::ms_imf.quad[2].r = -16250872;
        CPostEffects::ms_imf.quad[0].y = 0.0;
        CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
        CPostEffects::ms_imf.quad[1].y = 0.0;
        CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
        CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
        CPostEffects::ms_imf.quad[1].x = (float)sizeDrawBufferX;
        CPostEffects::ms_imf.quad[2].y = (float)sizeDrawBufferY;
        CPostEffects::ms_imf.quad[0].x = 0.0;
        CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
        *(_DWORD *)&CPostEffects::ms_imf.quad[3].r = -16250872;
        CPostEffects::ms_imf.quad[3].x = (float)sizeDrawBufferX;
        CPostEffects::ms_imf.quad[3].y = (float)sizeDrawBufferY;
        RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
        --v3;
      }
      while ( v3 );
    }
    CPostEffects::ImmediateModeRenderStatesReStore();
  }
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 3);
  screenHeight = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  *(_DWORD *)&CPostEffects::ms_imf.quad[0].r = -14614752;
  *(_DWORD *)&CPostEffects::ms_imf.quad[1].r = -14614752;
  CPostEffects::ms_imf.quad[2].x = 0.0;
  *(_DWORD *)&CPostEffects::ms_imf.quad[2].r = -14614752;
  CPostEffects::ms_imf.quad[0].y = 0.0;
  CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].y = 0.0;
  CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].x = screenWidth;
  CPostEffects::ms_imf.quad[2].y = screenHeight;
  CPostEffects::ms_imf.quad[0].x = 0.0;
  CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
  *(_DWORD *)&CPostEffects::ms_imf.quad[3].r = -14614752;
  CPostEffects::ms_imf.quad[3].x = screenWidth;
  CPostEffects::ms_imf.quad[3].y = screenHeight;
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
  CPostEffects::ImmediateModeRenderStatesReStore();
}
// 0: using guessed type int dword_0;

//----- (005B4E74) --------------------------------------------------------
void __fastcall CPostEffects::InfraredVision(RwRGBA_0 colour, RwRGBA_0 colourMain)
{
  float v3; // s16
  int v4; // r8
  float v5; // s16
  float screenHeight; // s18
  float screenWidth; // s20
  float v8; // s2
  float v9; // s16
  float v10; // s18
  RwRaster_0 *v11; // r0

  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  v3 = CPostEffects::m_fInfraredVisionFilterRadius;
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  v4 = 1;
  v5 = v3 * 100.0;
  do
  {
    CPostEffects::ms_imf.quad[0].s = CPostEffects::ms_imf.fFrontBufferU1;
    CPostEffects::ms_imf.quad[0].t = CPostEffects::ms_imf.fFrontBufferV1;
    CPostEffects::ms_imf.quad[1].s = CPostEffects::ms_imf.fFrontBufferU2;
    CPostEffects::ms_imf.quad[1].t = CPostEffects::ms_imf.fFrontBufferV1;
    CPostEffects::ms_imf.quad[2].s = CPostEffects::ms_imf.fFrontBufferU1;
    CPostEffects::ms_imf.quad[2].t = CPostEffects::ms_imf.fFrontBufferV2;
    CPostEffects::ms_imf.quad[3].t = CPostEffects::ms_imf.fFrontBufferV2;
    screenHeight = (float)RsGlobal.screenHeight;
    screenWidth = (float)RsGlobal.screenWidth;
    CPostEffects::ms_imf.quad[3].s = CPostEffects::ms_imf.fFrontBufferU2;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::ms_imf.pRasterDrawBuffer);
    *(_WORD *)&CPostEffects::ms_imf.quad[0].r = *(_WORD *)&colour._anon_0._anon_0.red;
    CPostEffects::ms_imf.quad[0].b = colour._anon_0._anon_0.blue;
    CPostEffects::ms_imf.quad[0].a = -1;
    *(_WORD *)&CPostEffects::ms_imf.quad[1].r = *(_WORD *)&colour._anon_0._anon_0.red;
    CPostEffects::ms_imf.quad[1].b = colour._anon_0._anon_0.blue;
    v8 = v5 * (float)v4;
    CPostEffects::ms_imf.quad[1].a = -1;
    *(_WORD *)&CPostEffects::ms_imf.quad[2].r = *(_WORD *)&colour._anon_0._anon_0.red;
    CPostEffects::ms_imf.quad[2].b = colour._anon_0._anon_0.blue;
    CPostEffects::ms_imf.quad[2].a = -1;
    CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
    CPostEffects::ms_imf.quad[0].x = -v8;
    CPostEffects::ms_imf.quad[0].y = -v8;
    CPostEffects::ms_imf.quad[1].x = (float)((float)(v8 + v8) + screenWidth) - v8;
    CPostEffects::ms_imf.quad[1].y = -v8;
    CPostEffects::ms_imf.quad[2].x = -v8;
    CPostEffects::ms_imf.quad[2].y = (float)((float)(v8 + v8) + screenHeight) - v8;
    CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
    *(_WORD *)&CPostEffects::ms_imf.quad[3].r = *(_WORD *)&colour._anon_0._anon_0.red;
    CPostEffects::ms_imf.quad[3].b = colour._anon_0._anon_0.blue;
    CPostEffects::ms_imf.quad[3].a = -1;
    CPostEffects::ms_imf.quad[3].x = (float)((float)(v8 + v8) + screenWidth) - v8;
    CPostEffects::ms_imf.quad[3].y = (float)((float)(v8 + v8) + screenHeight) - v8;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
    ++v4;
  }
  while ( v4 != 5 );
  CPostEffects::ms_imf.quad[0].s = 0.0;
  CPostEffects::ms_imf.quad[0].t = 0.0;
  CPostEffects::ms_imf.quad[2].s = 0.0;
  CPostEffects::ms_imf.quad[2].t = 1.0;
  CPostEffects::ms_imf.quad[1].s = 1.0;
  CPostEffects::ms_imf.quad[1].t = 0.0;
  CPostEffects::ms_imf.quad[3].s = 1.0;
  CPostEffects::ms_imf.quad[3].t = 1.0;
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 3);
  v9 = (float)RsGlobal.screenHeight;
  v10 = (float)RsGlobal.screenWidth;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  *(_DWORD *)&CPostEffects::ms_imf.quad[0].r = -48897;
  *(_DWORD *)&CPostEffects::ms_imf.quad[1].r = -48897;
  *(_DWORD *)&CPostEffects::ms_imf.quad[2].r = -48897;
  CPostEffects::ms_imf.quad[0].y = 0.0;
  CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].y = 0.0;
  CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[1].x = v10;
  CPostEffects::ms_imf.quad[2].y = v9;
  CPostEffects::ms_imf.quad[2].x = 0.0;
  CPostEffects::ms_imf.quad[0].x = 0.0;
  CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
  CPostEffects::ms_imf.quad[3].x = v10;
  CPostEffects::ms_imf.quad[3].y = v9;
  *(_DWORD *)&CPostEffects::ms_imf.quad[3].r = -48897;
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
  CPostEffects::ImmediateModeRenderStatesReStore();
  CPostEffects::SetFilterMainColour(v11, colourMain);
}
// 5B5056: variable 'v11' is possibly undefined
// 0: using guessed type int dword_0;
// 98: using guessed type int dword_98;
// B4: using guessed type int dword_B4;
// D0: using guessed type int dword_D0;
// EC: using guessed type int;

//----- (005B5074) --------------------------------------------------------
void __fastcall CPostEffects::HeatHazeFX(float fIntensity, bool bAlphaMaskMode)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d8
  float32x2_t v4; // d9
  RwInt32 depth; // r8
  float v6; // s16
  float v7; // s20
  float screenHeight; // s16
  float screenWidth; // s20
  int v10; // r6
  Int32 v11; // r0
  float v12; // r0
  RwIm2DVertex *v13; // r1
  RwRaster_0 *v14; // r0
  float width; // s0
  float v16; // r0
  RwIm2DVertex *v17; // r1
  RwRaster_0 *v18; // r0
  float v19; // s0
  float v20; // r0
  RwIm2DVertex *v21; // r1
  RwRaster_0 *v22; // r0
  float v23; // r0
  Int32 v24; // r1
  RwIm2DVertex *v25; // r2
  float v26; // s0
  Int32 v27; // r2
  RwImVertexIndex *v28; // r0
  int v29; // r4
  int v30; // r5
  int v31; // r9
  Int32 v32; // r8
  int v33; // r10
  int v34; // s0
  Int32 v35; // r11
  __int64 v36; // r0
  int v37; // s0
  int v38; // s22
  float v39; // s26
  RwIm2DVertex *v40; // r5
  float v41; // r0
  RwIm2DVertex *v42; // r1
  RwRaster_0 *v43; // r0
  float v44; // s22
  float v45; // s2
  float v46; // s0
  float v47; // r0
  RwCamera_0 *camera; // r2
  RwIm2DVertex *v49; // r1
  float v50; // s0
  RwRaster_0 *v51; // r2
  float v52; // s30
  float v53; // s2
  float v54; // s0
  float v55; // s26
  float v56; // r0
  RwIm2DVertex *v57; // r1
  RwRaster_0 *v58; // r0
  float height; // s2
  float v60; // s0
  float v61; // r0
  Int32 v62; // r1
  RwIm2DVertex *v63; // r2
  float v64; // s0
  Int32 v65; // r0
  RwImVertexIndex *v66; // r2
  float v67; // s0
  int v68; // r0
  RwInt32 v69; // r4
  Int32 v70; // r4
  Int32 v71; // r5
  RwInt32 v72; // [sp+8h] [bp-C0h]
  int v73; // [sp+38h] [bp-90h]
  int v74; // [sp+3Ch] [bp-8Ch]
  Int32 v75; // [sp+40h] [bp-88h]
  int v76; // [sp+44h] [bp-84h]
  Int32 v77; // [sp+48h] [bp-80h]
  Int32 v78; // [sp+4Ch] [bp-7Ch]
  int v79; // [sp+50h] [bp-78h]
  int v80; // [sp+58h] [bp-70h]
  int v81; // [sp+5Ch] [bp-6Ch]
  Int32 v82; // [sp+60h] [bp-68h]
  CRGBA v83; // [sp+64h] [bp-64h] BYREF

  v4.n64_f32[0] = fIntensity;
  depth = Scene.camera->frameBuffer->depth;
  if ( bAlphaMaskMode )
  {
    CRGBA::CRGBA(&v83, 0, 0, 0, 0);
    RwCameraClear(Scene.camera, &v83, 2);
    CPostEffects::ImmediateModeRenderStatesStore();
    CPostEffects::ImmediateModeRenderStatesSet();
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    if ( depth == 16 )
    {
      screenHeight = (float)RsGlobal.screenHeight;
      screenWidth = (float)RsGlobal.screenWidth;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      *(_DWORD *)&CPostEffects::ms_imf.quad[0].r = -16777216;
      *(_DWORD *)&CPostEffects::ms_imf.quad[1].r = -16777216;
      CPostEffects::ms_imf.quad[2].x = 0.0;
      *(_DWORD *)&CPostEffects::ms_imf.quad[2].r = -16777216;
      CPostEffects::ms_imf.quad[0].y = 0.0;
      CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[1].y = 0.0;
      CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[1].x = screenWidth;
      CPostEffects::ms_imf.quad[2].y = screenHeight;
      CPostEffects::ms_imf.quad[0].x = 0.0;
      CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
      *(_DWORD *)&CPostEffects::ms_imf.quad[3].r = -16777216;
      CPostEffects::ms_imf.quad[3].x = screenWidth;
      CPostEffects::ms_imf.quad[3].y = screenHeight;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
    }
    else
    {
      RwRenderStateSet(rwRENDERSTATESTENCILENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATESTENCILFAIL, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATESTENCILZFAIL, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATESTENCILPASS, (char *)&dword_0 + 3);
      RwRenderStateSet(rwRENDERSTATESTENCILFUNCTIONREF, 0);
      RwRenderStateSet(rwRENDERSTATESTENCILFUNCTION, byte_8);
      v6 = (float)RsGlobal.screenHeight;
      v7 = (float)RsGlobal.screenWidth;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      *(_DWORD *)&CPostEffects::ms_imf.quad[0].r = -16777216;
      *(_DWORD *)&CPostEffects::ms_imf.quad[1].r = -16777216;
      CPostEffects::ms_imf.quad[2].x = 0.0;
      *(_DWORD *)&CPostEffects::ms_imf.quad[2].r = -16777216;
      CPostEffects::ms_imf.quad[0].y = 0.0;
      CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[1].y = 0.0;
      CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[1].x = v7;
      CPostEffects::ms_imf.quad[2].y = v6;
      CPostEffects::ms_imf.quad[0].x = 0.0;
      CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
      *(_DWORD *)&CPostEffects::ms_imf.quad[3].r = -16777216;
      CPostEffects::ms_imf.quad[3].x = v7;
      CPostEffects::ms_imf.quad[3].y = v6;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
      RwRenderStateSet(rwRENDERSTATESTENCILFUNCTIONREF, (char *)&dword_0 + 1);
    }
    Fx_c::Render(&g_fx, TheCamera.m_pRwCamera, 1u);
    CPostEffects::ImmediateModeRenderStatesReStore();
  }
  else
  {
    CPostEffects::m_bHeatHazeMaskModeTest = 0;
  }
  CPostEffects::HeatHazeFXInit();
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  RwCameraEndUpdate(Scene.camera);
  RwRasterPushContext(CPostEffects::pRasterFrontBuffer);
  RwRasterRenderFast(Scene.camera->frameBuffer, 0, 0);
  RwRasterPopContext();
  RsCameraBeginUpdate(Scene.camera);
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  v3.n64_u32[0] = 1.0;
  v2.n64_u32[0] = 0;
  TempBufferVerticesStored = 0;
  v76 = (int)(float)(vmin_f32(vmax_f32(v4, v2), v3).n64_f32[0] * (float)CPostEffects::m_HeatHazeFXIntensity);
  if ( depth != 16 )
  {
    RwRenderStateSet(rwRENDERSTATESTENCILPASS, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESTENCILFUNCTIONREF, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESTENCILFUNCTION, (char *)&dword_0 + 3);
  }
  v10 = 0;
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  v72 = depth;
  if ( CPostEffects::m_bHeatHazeMaskModeTest )
  {
    v11 = TempBufferVerticesStored;
    TempVertexBuffer.m_2d[TempBufferVerticesStored].x = 0.0;
    TempVertexBuffer.m_2d[v11].y = 0.0;
    v12 = RwIm2DGetNearScreenZ();
    v13 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
    v13->z = v12;
    v14 = CPostEffects::pRasterFrontBuffer;
    v13->rhw = 1.0 / Scene.camera->nearPlane;
    width = (float)v14->width;
    v13[1].y = 0.0;
    v13[1].x = width;
    v16 = RwIm2DGetNearScreenZ();
    v17 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
    v17[1].z = v16;
    v18 = CPostEffects::pRasterFrontBuffer;
    v19 = 1.0 / Scene.camera->nearPlane;
    v17[2].x = 0.0;
    v17[1].rhw = v19;
    v17[2].y = (float)v18->height;
    v20 = RwIm2DGetNearScreenZ();
    v21 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
    v21[2].z = v20;
    v22 = CPostEffects::pRasterFrontBuffer;
    v21->rhw = 1.0 / Scene.camera->nearPlane;
    v21[3].x = (float)v22->width;
    v21[3].y = (float)v22->height;
    v23 = RwIm2DGetNearScreenZ();
    v24 = TempBufferVerticesStored;
    v25 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
    v25[3].z = v23;
    v26 = 1.0 / Scene.camera->nearPlane;
    v25[3].b = 0;
    *(_WORD *)&v25[3].r = 255;
    v25[3].a = v76;
    v25->a = v76;
    v25->b = 0;
    *(_WORD *)&v25->r = 255;
    v25[1].a = v76;
    v25[1].b = 0;
    *(_WORD *)&v25[1].r = 255;
    v25[2].a = v76;
    v25[2].b = 0;
    *(_WORD *)&v25[2].r = 255;
    v25[1].rhw = v26;
    v27 = TempBufferIndicesStored;
    TempBufferRenderIndexList[TempBufferIndicesStored] = v24;
    v28 = &TempBufferRenderIndexList[v27];
    v28[1] = v24 + 2;
    v28[2] = v24 + 1;
    v28[3] = v24 + 1;
    v28[4] = v24 + 2;
    v28[5] = v24 + 3;
    TempBufferIndicesStored = v27 + 6;
    TempBufferVerticesStored = v24 + 4;
  }
  else
  {
    v82 = CPostEffects::m_HeatHazeFXRenderSizeY;
    v77 = CPostEffects::m_HeatHazeFXScanSizeX;
    v81 = (CPostEffects::m_HeatHazeFXRenderSizeY - CPostEffects::m_HeatHazeFXScanSizeY) / 2;
    v75 = CPostEffects::m_HeatHazeFXRenderSizeX;
    v80 = (CPostEffects::m_HeatHazeFXRenderSizeX - CPostEffects::m_HeatHazeFXScanSizeX) / 2;
    v73 = (CPostEffects::m_HeatHazeFXRenderSizeX - CPostEffects::m_HeatHazeFXScanSizeX) / -2;
    v78 = CPostEffects::m_HeatHazeFXScanSizeY;
    v74 = (CPostEffects::m_HeatHazeFXRenderSizeY - CPostEffects::m_HeatHazeFXScanSizeY) / -2;
    do
    {
      v79 = v10;
      v29 = hpY[v10];
      v30 = hpX[v10];
      v31 = v29 - v81;
      v32 = CPostEffects::m_HeatHazeFXRandomShift;
      v33 = v30 - v80;
      if ( CPostEffects::m_HeatHazeFXRandomShift >= 1 )
      {
        v34 = (unsigned __int16)rand();
        v35 = CPostEffects::m_HeatHazeFXRandomShift;
        v33 = v33 - v32 + (int)(float)((float)((float)v34 * 0.000015259) * (float)(2 * v32));
        v31 = v31 - v35 + (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(2 * v35));
      }
      if ( v33 < 0 )
        v30 += v80;
      v36 = *(_QWORD *)&CPostEffects::pRasterFrontBuffer->width;
      if ( v33 < 0 )
        v33 = 0;
      if ( v33 > (int)v36 - v75 )
        v30 += v73;
      v37 = v30;
      v38 = v77 + v30;
      if ( v31 < 0 )
      {
        v29 += v81;
        v31 = 0;
      }
      if ( v31 > HIDWORD(v36) - v82 )
        v29 += v74;
      if ( v33 > (int)v36 - v75 )
        v33 = v36 - v75;
      if ( v31 > HIDWORD(v36) - v82 )
        v31 = HIDWORD(v36) - v82;
      v39 = (float)v30;
      v40 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v40->x = (float)v33;
      v40->y = (float)v31;
      v40->s = (float)v37 / (float)(int)v36;
      v40->t = (float)v29 / (float)SHIDWORD(v36);
      v41 = RwIm2DGetNearScreenZ();
      v42 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v42->z = v41;
      v43 = CPostEffects::pRasterFrontBuffer;
      v42->rhw = 1.0 / Scene.camera->nearPlane;
      v44 = (float)v38;
      v45 = (float)v29 / (float)v43->height;
      v46 = v44 / (float)v43->width;
      v42[1].x = (float)(v33 + v75);
      v42[1].y = (float)v31;
      v42[1].s = v46;
      v42[1].t = v45;
      v47 = RwIm2DGetNearScreenZ();
      camera = Scene.camera;
      v49 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v49[1].z = v47;
      v50 = 1.0 / camera->nearPlane;
      v51 = CPostEffects::pRasterFrontBuffer;
      v49[1].rhw = v50;
      v52 = (float)(v78 + v29);
      v53 = v52 / (float)v51->height;
      v54 = v39 / (float)v51->width;
      v55 = (float)(v82 + v31);
      v49[2].x = (float)v33;
      v49[2].y = v55;
      v49[2].s = v54;
      v49[2].t = v53;
      v56 = RwIm2DGetNearScreenZ();
      v57 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v57[2].z = v56;
      v58 = CPostEffects::pRasterFrontBuffer;
      v57[2].rhw = 1.0 / Scene.camera->nearPlane;
      height = (float)v58->height;
      v60 = (float)v58->width;
      v57[3].x = (float)(v33 + v75);
      v57[3].y = v55;
      v57[3].s = v44 / v60;
      v57[3].t = v52 / height;
      v61 = RwIm2DGetNearScreenZ();
      v62 = TempBufferVerticesStored;
      v63 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v63[3].z = v61;
      v64 = 1.0 / Scene.camera->nearPlane;
      v63[3].a = v76;
      v63[3].b = -1;
      v63->a = v76;
      v63[1].a = v76;
      v63[2].a = v76;
      *(_WORD *)&v63[3].r = -1;
      v63->b = -1;
      *(_WORD *)&v63->r = -1;
      v63[1].b = -1;
      *(_WORD *)&v63[1].r = -1;
      v63[2].b = -1;
      *(_WORD *)&v63[2].r = -1;
      v65 = TempBufferIndicesStored;
      v63[3].rhw = v64;
      TempBufferRenderIndexList[v65] = v62;
      v66 = &TempBufferRenderIndexList[v65];
      TempBufferIndicesStored = v65 + 6;
      TempBufferVerticesStored = v62 + 4;
      v66[2] = v62 + 1;
      v67 = CTimer::ms_fTimeStep;
      v66[3] = v62 + 1;
      v66[1] = v62 + 2;
      v66[4] = v62 + 2;
      v66[5] = v62 + 3;
      v68 = hpY[v10] - (int)(float)((float)(v67 * 0.5) * (float)hpS[v10]);
      hpY[v10] = v68;
      if ( v68 <= -1 )
      {
        v69 = CPostEffects::pRasterFrontBuffer->width;
        hpX[v10] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(v69 - v77));
        hpY[v10] = CPostEffects::pRasterFrontBuffer->height - v78;
        v70 = CPostEffects::m_HeatHazeFXSpeedMax;
        v71 = CPostEffects::m_HeatHazeFXSpeedMin;
        hpS[v10] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(v70 - v71)) + v71;
      }
      ++v10;
    }
    while ( v79 != 179 );
  }
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  if ( TempBufferVerticesStored )
    RwIm2DRenderIndexedPrimitive_BUGFIX(
      rwPRIMTYPETRILIST,
      TempVertexBuffer.m_2d,
      TempBufferVerticesStored,
      TempBufferRenderIndexList,
      TempBufferIndicesStored);
  TempBufferVerticesStored = 0;
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  if ( v72 != 16 )
    RwRenderStateSet(rwRENDERSTATESTENCILENABLE, 0);
}
// 5B529A: variable 'v4' is possibly undefined
// 5B529A: variable 'v2' is possibly undefined
// 5B52A4: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B5A54) --------------------------------------------------------
void __fastcall CPostEffects::UnderWaterRipple(
        RwRGBA_0 col,
        float xoffset,
        float yoffset,
        int32 strength,
        float speed,
        float freq)
{
  float v9; // s16
  float v10; // r0
  RwRaster_0 *v11; // r2
  Int32 v12; // r1
  float v13; // s28
  RwInt32 height; // r3
  int v15; // r5
  float v16; // s28
  float width; // s2
  RwIm2DVertex *v18; // r0
  float v19; // s30
  float v20; // r0
  RwIm2DVertex *v21; // r1
  RwRaster_0 *v22; // r0
  float v23; // r0
  Int32 v24; // r11
  RwIm2DVertex *v25; // r1
  float v26; // s0
  int v27; // r8
  float v28; // r0
  float v29; // s2
  RwIm2DVertex *v30; // r0
  float v31; // s20
  float v32; // r0
  RwIm2DVertex *v33; // r1
  RwRaster_0 *v34; // r0
  float v35; // r0
  Int32 v36; // r1
  bool v37; // cc
  RwIm2DVertex *v38; // r2
  float nearPlane; // s0
  unsigned int v40; // [sp+Ch] [bp-6Ch]
  RwUInt8 red; // [sp+10h] [bp-68h]
  unsigned int v42; // [sp+14h] [bp-64h]

  RwCameraEndUpdate(Scene.camera);
  RsCameraBeginUpdate(Scene.camera);
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  v9 = 0.0;
  v10 = sinf((float)(freq * 0.0) + (float)((float)CTimer::m_snTimeInMilliseconds * speed));
  v11 = CPostEffects::pRasterFrontBuffer;
  v12 = TempBufferVerticesStored;
  v13 = v10;
  height = CPostEffects::pRasterFrontBuffer->height;
  v42 = HIWORD(*(unsigned int *)&col);
  v40 = *(unsigned int *)&col >> 8;
  red = col._anon_0._anon_0.red;
  v15 = (int)(float)(xoffset + xoffset);
  if ( height >= 1 )
  {
    v9 = 0.0;
    do
    {
      v16 = v13 * xoffset;
      width = (float)v11->width;
      TempVertexBuffer.m_2d[v12].x = 0.0;
      v18 = &TempVertexBuffer.m_2d[v12];
      v18->y = v9;
      v19 = v9 / (float)height;
      v18->s = (float)(v16 + xoffset) / width;
      v18->t = v19;
      v20 = RwIm2DGetNearScreenZ();
      v21 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v21->z = v20;
      v22 = CPostEffects::pRasterFrontBuffer;
      v21->rhw = 1.0 / Scene.camera->nearPlane;
      v21[1].s = (float)((float)(v16 + (float)v22->width) - xoffset) / (float)v22->width;
      v21[1].t = v19;
      v21[1].x = (float)(v22->width + v15);
      v21[1].y = v9;
      v23 = RwIm2DGetNearScreenZ();
      v24 = TempBufferVerticesStored;
      v25 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
      v25[1].z = v23;
      v26 = 1.0 / Scene.camera->nearPlane;
      v25->g = v40;
      v25->r = red;
      v25->b = v42;
      v25[1].g = v40;
      v25->a = -1;
      v25[1].r = red;
      v25[1].b = v42;
      v25[1].a = -1;
      v25[1].rhw = v26;
      v27 = (int)(float)(v9 + yoffset);
      v9 = (float)v27;
      v28 = sinf((float)((float)v27 * freq) + (float)((float)CTimer::m_snTimeInMilliseconds * speed));
      v11 = CPostEffects::pRasterFrontBuffer;
      v12 = v24 + 2;
      TempBufferVerticesStored = v24 + 2;
      v13 = v28;
      height = CPostEffects::pRasterFrontBuffer->height;
    }
    while ( height > v27 );
  }
  v29 = (float)v11->width;
  v30 = &TempVertexBuffer.m_2d[v12];
  v31 = v9 / (float)height;
  v30->x = 0.0;
  v30->y = v9;
  v30->s = (float)(v13 + xoffset) / v29;
  v30->t = v31;
  v32 = RwIm2DGetNearScreenZ();
  v33 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
  v33->z = v32;
  v34 = CPostEffects::pRasterFrontBuffer;
  v33->rhw = 1.0 / Scene.camera->nearPlane;
  v33[1].s = (float)((float)(v13 + (float)v34->width) - xoffset) / (float)v34->width;
  v33[1].t = v31;
  v33[1].x = (float)(v34->width + v15);
  v33[1].y = v9;
  v35 = RwIm2DGetNearScreenZ();
  v36 = TempBufferVerticesStored;
  v37 = TempBufferVerticesStored < 1;
  v38 = &TempVertexBuffer.m_2d[TempBufferVerticesStored];
  v38[1].z = v35;
  nearPlane = Scene.camera->nearPlane;
  v38[1].g = v40;
  v38[1].r = red;
  v38[1].b = v42;
  v38[1].a = -1;
  v38->g = v40;
  v38->r = red;
  v38->b = v42;
  v38->a = -1;
  v38[1].rhw = 1.0 / nearPlane;
  TempBufferVerticesStored = v36 + 2;
  if ( !v37 )
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, TempVertexBuffer.m_2d, v36 + 2);
  CPostEffects::ImmediateModeRenderStatesReStore();
}

//----- (005B5DA8) --------------------------------------------------------
void CPostEffects::CCTV()
{
  RwInt32 screenHeight; // r5
  float v1; // s0
  int v2; // r5
  float v3; // s16
  int v4; // r9
  __int16 v5; // kr00_2
  unsigned __int8 blue; // r8
  float screenWidth; // s18

  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  RwCameraEndUpdate(Scene.camera);
  RwRasterPushContext(CPostEffects::pRasterFrontBuffer);
  RwRasterRenderFast(Scene.camera->frameBuffer, 0, 0);
  RwRasterPopContext();
  RsCameraBeginUpdate(Scene.camera);
  screenHeight = RsGlobal.screenHeight;
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  v1 = (float)((float)screenHeight / 448.0) + (float)((float)screenHeight / 448.0);
  v2 = screenHeight / (2 * (int)v1);
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  if ( v2 >= 1 )
  {
    v3 = (float)(int)v1;
    v4 = 0;
    do
    {
      v5 = *(_WORD *)&CPostEffects::m_CCTVcol._anon_0._anon_0.red;
      blue = CPostEffects::m_CCTVcol._anon_0._anon_0.blue;
      screenWidth = (float)RsGlobal.screenWidth;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
      CPostEffects::ms_imf.quad[0].y = (float)v4;
      *(_WORD *)&CPostEffects::ms_imf.quad[0].r = v5;
      CPostEffects::ms_imf.quad[0].b = blue;
      CPostEffects::ms_imf.quad[2].x = 0.0;
      CPostEffects::ms_imf.quad[0].x = 0.0;
      CPostEffects::ms_imf.quad[0].a = -1;
      CPostEffects::ms_imf.quad[1].y = (float)v4;
      *(_WORD *)&CPostEffects::ms_imf.quad[1].r = v5;
      CPostEffects::ms_imf.quad[1].b = blue;
      CPostEffects::ms_imf.quad[1].a = -1;
      *(_WORD *)&CPostEffects::ms_imf.quad[2].r = v5;
      CPostEffects::ms_imf.quad[2].b = blue;
      CPostEffects::ms_imf.quad[2].a = -1;
      CPostEffects::ms_imf.quad[0].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[1].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[2].z = CPostEffects::ms_imf.screenZ;
      CPostEffects::ms_imf.quad[2].y = v3 + (float)v4;
      CPostEffects::ms_imf.quad[1].x = screenWidth;
      CPostEffects::ms_imf.quad[3].z = CPostEffects::ms_imf.screenZ;
      *(_WORD *)&CPostEffects::ms_imf.quad[3].r = v5;
      CPostEffects::ms_imf.quad[3].b = blue;
      CPostEffects::ms_imf.quad[3].a = -1;
      CPostEffects::ms_imf.quad[3].x = screenWidth;
      CPostEffects::ms_imf.quad[3].y = v3 + (float)v4;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CPostEffects::ms_imf.quad, 4);
      v4 += 2 * (int)v1;
      --v2;
    }
    while ( v2 );
  }
  CPostEffects::ImmediateModeRenderStatesReStore();
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 98: using guessed type int dword_98;
// B4: using guessed type int dword_B4;
// D0: using guessed type int dword_D0;
// EC: using guessed type int;

//----- (005B5F78) --------------------------------------------------------
void CPostEffects::MobileRender()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  float32x2_t v2; // d3
  float32x2_t v3; // d8
  char v4; // r0
  unsigned int blue; // r0
  unsigned int red; // r2
  unsigned int green; // r1
  float v8; // s16
  float v9; // s18
  CPlayerPed *PlayerPed; // r0
  float v11; // s16
  float v12; // s18
  CPlayerPed *v13; // r0
  float LightingFromCol; // s0
  float v15; // s2
  float v16; // s2
  float v17; // s4
  float v18; // s0
  float v19; // s6
  float v20; // s10
  float v21; // s6
  unsigned int v22; // r12
  float v23; // s10
  float v24; // s4
  float v25; // s6
  float v26; // s2
  unsigned int v27; // r2
  float v28; // s4
  float v29; // s6
  float v30; // s4
  unsigned int v31; // r3
  float v32; // s6
  float v33; // s2
  float v34; // s2
  float v35; // s4
  unsigned int v36; // r5
  float v37; // s0
  float v38; // s6
  float v39; // s10
  float v40; // s2
  float v41; // s8
  float v42; // s10
  float v43; // s8
  float v44; // s10
  float v45; // s10
  float v46; // s0
  float v47; // s0
  float v48; // s0
  float v49; // s4
  float v50; // s6
  float32x4_t v51; // q0
  float v52; // s8
  float32x4_t v53; // q8
  float32x4_t v54; // q1
  RQVector v55; // q8
  __int64 v56; // r0
  CRGBA v57; // [sp+8h] [bp-60h] BYREF
  CRGBA v58; // [sp+Ch] [bp-5Ch] BYREF
  RQVector bGrade; // [sp+10h] [bp-58h] BYREF
  RQVector gGrade; // [sp+20h] [bp-48h] BYREF
  RQVector rGrade; // [sp+30h] [bp-38h] BYREF

  rGrade = CTimeCycle::m_CurrentColours.m_vRedGrade;
  gGrade = CTimeCycle::m_CurrentColours.m_vGreenGrade;
  bGrade = CTimeCycle::m_CurrentColours.m_vBlueGrade;
  v4 = `guard variable for'CPostEffects::MobileRender(void)::extraMultiplierLocal;
  __dmb(0xBu);
  if ( (v4 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CPostEffects::MobileRender(void)::extraMultiplierLocal) )
  {
    CPostEffects::MobileRender(void)::extraMultiplierLocal = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
    _cxa_guard_release((__guard *)&`guard variable for'CPostEffects::MobileRender(void)::extraMultiplierLocal);
  }
  CRGBA::CRGBA(
    &v58,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Red,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Green,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Blue,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx1Alpha);
  CRGBA::CRGBA(
    &v57,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Red,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Green,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Blue,
    (unsigned int)CTimeCycle::m_CurrentColours.m_fPostFx2Alpha);
  if ( CPostEffects::m_bNightVision )
  {
    qmemcpy(&v58, "@@@", 3);
    qmemcpy(&v57, "@@@", 3);
  }
  if ( CPostEffects::m_bInfraredVision )
  {
    blue = 64;
    red = 64;
    qmemcpy(&v58, "@@@", 3);
    qmemcpy(&v57, "@@@", 3);
    green = 64;
  }
  else
  {
    red = v58._anon_0._anon_0.red;
    green = v58._anon_0._anon_0.green;
    blue = v58._anon_0._anon_0.blue;
  }
  v58._anon_0._anon_0.red = (unsigned int)(float)(gfLaRiotsLightMult * (float)red);
  v58._anon_0._anon_0.green = (unsigned int)(float)(gfLaRiotsLightMult * (float)green);
  v58._anon_0._anon_0.blue = (unsigned int)(float)(gfLaRiotsLightMult * (float)blue);
  if ( FindPlayerPed(-1) )
  {
    v8 = CTimer::ms_fTimeStep;
    v9 = CPostEffects::SCREEN_EXTRA_MULT_CHANGE_RATE;
    PlayerPed = FindPlayerPed(-1);
    v11 = v9 * v8;
    v12 = fabsf(CPhysical::GetLightingFromCol(PlayerPed, 0) - CPostEffects::MobileRender(void)::extraMultiplierLocal);
    v13 = FindPlayerPed(-1);
    LightingFromCol = CPhysical::GetLightingFromCol(v13, 0);
    if ( v12 >= v11 )
    {
      v15 = -v11;
      if ( LightingFromCol > CPostEffects::MobileRender(void)::extraMultiplierLocal )
        v15 = v11;
      LightingFromCol = CPostEffects::MobileRender(void)::extraMultiplierLocal + v15;
    }
    CPostEffects::MobileRender(void)::extraMultiplierLocal = LightingFromCol;
    if ( LightingFromCol > CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP )
    {
      LightingFromCol = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
      CPostEffects::MobileRender(void)::extraMultiplierLocal = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
    }
    v16 = (float)(CPostEffects::SCREEN_EXTRA_MULT_BASE_MULT
                * (float)(1.0 - (float)(LightingFromCol / CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP)))
        + 1.0;
  }
  else
  {
    v16 = 1.0;
  }
  v17 = v16 * CPostEffects::m_colour1Multiplier;
  v18 = 0.0;
  v19 = (float)(v16 * CPostEffects::m_colour1Multiplier) * (float)v58._anon_0._anon_0.red;
  if ( v19 >= 255.0 || (v20 = 0.0, v19 > 0.0) )
  {
    v20 = 255.0;
    if ( v19 < 255.0 )
      v20 = (float)(v16 * CPostEffects::m_colour1Multiplier) * (float)v58._anon_0._anon_0.red;
  }
  v21 = v17 * (float)v58._anon_0._anon_0.green;
  v22 = (unsigned int)v20;
  v58._anon_0._anon_0.red = (unsigned int)v20;
  if ( v21 >= 255.0 || (v23 = 0.0, v21 > 0.0) )
  {
    v23 = 255.0;
    if ( v21 < 255.0 )
      v23 = v17 * (float)v58._anon_0._anon_0.green;
  }
  v24 = v17 * (float)v58._anon_0._anon_0.blue;
  v58._anon_0._anon_0.green = (unsigned int)v23;
  if ( v24 >= 255.0 || (v25 = 0.0, v24 > 0.0) )
  {
    v25 = 255.0;
    if ( v24 < 255.0 )
      v25 = v24;
  }
  v26 = v16 * CPostEffects::m_colour2Multiplier;
  v27 = (unsigned int)v25;
  v28 = v26 * (float)v57._anon_0._anon_0.red;
  v58._anon_0._anon_0.blue = (unsigned int)v25;
  if ( v28 >= 255.0 || (v29 = 0.0, v28 > 0.0) )
  {
    v29 = 255.0;
    if ( v28 < 255.0 )
      v29 = v26 * (float)v57._anon_0._anon_0.red;
  }
  v30 = v26 * (float)v57._anon_0._anon_0.green;
  v31 = (unsigned int)v29;
  v57._anon_0._anon_0.red = (unsigned int)v29;
  if ( v30 >= 255.0 || (v32 = 0.0, v30 > 0.0) )
  {
    v32 = 255.0;
    if ( v30 < 255.0 )
      v32 = v26 * (float)v57._anon_0._anon_0.green;
  }
  v33 = v26 * (float)v57._anon_0._anon_0.blue;
  v57._anon_0._anon_0.green = (unsigned int)v32;
  if ( v33 >= 255.0 || v33 > 0.0 )
  {
    v18 = 255.0;
    if ( v33 < 255.0 )
      v18 = v33;
  }
  v3.n64_u32[0] = 1.0;
  v34 = (float)((__int16)(unsigned int)v23 * v58._anon_0._anon_0.alpha
              + (__int16)(unsigned int)v32 * v57._anon_0._anon_0.alpha);
  v35 = (float)(v58._anon_0._anon_0.alpha * (__int16)v22 + v57._anon_0._anon_0.alpha * (__int16)v31);
  v36 = (unsigned int)v18;
  v37 = (float)(v57._anon_0._anon_0.alpha * (__int16)(unsigned int)v18 + (__int16)v27 * v58._anon_0._anon_0.alpha);
  v58._anon_0._anon_0.green = (unsigned int)v23;
  v58._anon_0._anon_0.red = v22;
  v58._anon_0._anon_0.blue = v27;
  v57._anon_0._anon_0.green = (unsigned int)v32;
  v57._anon_0._anon_0.red = v31;
  v57._anon_0._anon_0.blue = v36;
  v38 = 1.0 / sqrtf((float)((float)(v35 * v35) + (float)(v34 * v34)) + (float)(v37 * v37));
  v39 = (float)((float)((float)(v38 * v34) * 1.732) + 1.5) * 0.4;
  v40 = rGrade._anon_0.arr[0] * (float)((float)((float)((float)(v38 * v35) * 1.732) + 1.5) * 0.4);
  v1.n64_f32[0] = gGrade._anon_0.arr[1] * v39;
  v2.n64_f32[0] = bGrade._anon_0.arr[2] * (float)((float)((float)((float)(v38 * v37) * 1.732) + 1.5) * 0.4);
  rGrade._anon_0.arr[0] = v40;
  gGrade._anon_0.arr[1] = gGrade._anon_0.arr[1] * v39;
  LODWORD(bGrade._anon_0.arr[2]) = v2.n64_u32[0];
  if ( CPostEffects::m_bDarknessFilter && !CPostEffects::m_bInfraredVision && !CPostEffects::m_bNightVision )
  {
    v41 = (float)(255.0 - (float)CPostEffects::m_DarknessFilterAlpha) / 255.0;
    v40 = v40 * v41;
    v1.n64_f32[0] = v41 * v1.n64_f32[0];
    v2.n64_f32[0] = v41 * v2.n64_f32[0];
    rGrade._anon_0.arr[0] = v40;
    rGrade._anon_0.arr[1] = rGrade._anon_0.arr[1] * v41;
    rGrade._anon_0.arr[2] = v41 * rGrade._anon_0.arr[2];
    rGrade._anon_0.arr[3] = v41 * rGrade._anon_0.arr[3];
    LODWORD(gGrade._anon_0.arr[1]) = v1.n64_u32[0];
    v0.n64_u32[1] = LODWORD(bGrade._anon_0.arr[0]);
    gGrade._anon_0.arr[0] = v41 * gGrade._anon_0.arr[0];
    gGrade._anon_0.arr[2] = v41 * gGrade._anon_0.arr[2];
    gGrade._anon_0.arr[3] = v41 * gGrade._anon_0.arr[3];
    bGrade._anon_0.arr[0] = v41 * bGrade._anon_0.arr[0];
    LODWORD(bGrade._anon_0.arr[2]) = v2.n64_u32[0];
    bGrade._anon_0.arr[1] = v41 * bGrade._anon_0.arr[1];
    bGrade._anon_0.arr[3] = v41 * bGrade._anon_0.arr[3];
  }
  CPostEffects::m_bInCutscene = 0;
  if ( (CCutsceneMgr::ms_running || CCutsceneMgr::ms_cutsceneProcessing) << 24 )
  {
    CPostEffects::m_bInCutscene = 1;
  }
  else
  {
    v42 = CPostEffects::m_fNightVisionSwitchOnFXCount;
    if ( CPostEffects::m_bNightVision )
    {
      if ( CPostEffects::m_fNightVisionSwitchOnFXCount > 0.0 )
      {
        v42 = CPostEffects::m_fNightVisionSwitchOnFXCount - CTimer::ms_fTimeStep;
        CPostEffects::m_fNightVisionSwitchOnFXCount = CPostEffects::m_fNightVisionSwitchOnFXCount - CTimer::ms_fTimeStep;
      }
      if ( v42 < 0.0 )
      {
        v42 = 0.0;
        CPostEffects::m_fNightVisionSwitchOnFXCount = 0.0;
      }
      v1.n64_u32[1] = LODWORD(bGrade._anon_0.arr[0]);
      v40 = v40 * 0.125;
      v2.n64_f32[0] = v2.n64_f32[0] * 0.125;
      rGrade._anon_0.arr[0] = v40;
      rGrade._anon_0.arr[1] = rGrade._anon_0.arr[1] * 0.125;
      rGrade._anon_0.arr[2] = rGrade._anon_0.arr[2] * 0.125;
      rGrade._anon_0.arr[3] = rGrade._anon_0.arr[3] * 0.125;
      v0.n64_f32[1] = (float)(v42 * 0.02) + 1.0;
      bGrade._anon_0.arr[0] = bGrade._anon_0.arr[0] * 0.125;
      LODWORD(bGrade._anon_0.arr[2]) = v2.n64_u32[0];
      bGrade._anon_0.arr[1] = bGrade._anon_0.arr[1] * 0.125;
      bGrade._anon_0.arr[3] = bGrade._anon_0.arr[3] * 0.125;
      v1.n64_f32[0] = v0.n64_f32[1] * v1.n64_f32[0];
      LODWORD(gGrade._anon_0.arr[1]) = v1.n64_u32[0];
      gGrade._anon_0.arr[0] = gGrade._anon_0.arr[0] * v0.n64_f32[1];
      v43 = 0.0;
      gGrade._anon_0.arr[2] = v0.n64_f32[1] * gGrade._anon_0.arr[2];
      gGrade._anon_0.arr[3] = (float)(v0.n64_f32[1] * gGrade._anon_0.arr[3]) + (float)(v42 * 0.007);
    }
    else
    {
      v43 = 0.0;
      if ( CPostEffects::m_fNightVisionSwitchOnFXCount != CPostEffects::m_fNightVisionSwitchOnFXTime )
      {
        if ( CPostEffects::m_fNightVisionSwitchOnFXCount < CPostEffects::m_fNightVisionSwitchOnFXTime )
        {
          v0.n64_f32[1] = CTimer::ms_fTimeStep;
          v42 = CPostEffects::m_fNightVisionSwitchOnFXCount + (float)(CTimer::ms_fTimeStep * 0.5);
          CPostEffects::m_fNightVisionSwitchOnFXCount = v42;
        }
        if ( v42 > CPostEffects::m_fNightVisionSwitchOnFXTime )
        {
          v42 = CPostEffects::m_fNightVisionSwitchOnFXTime;
          CPostEffects::m_fNightVisionSwitchOnFXCount = CPostEffects::m_fNightVisionSwitchOnFXTime;
        }
        if ( !CPostEffects::m_bDarknessFilter )
          v43 = (float)(50.0 - v42) / 100.0;
      }
    }
    v44 = CPostEffects::m_fInfraredVisionSwitchOnFXCount;
    if ( CPostEffects::m_bInfraredVision )
    {
      if ( CPostEffects::m_fInfraredVisionSwitchOnFXCount > 0.0 )
      {
        v44 = CPostEffects::m_fInfraredVisionSwitchOnFXCount - CTimer::ms_fTimeStep;
        CPostEffects::m_fInfraredVisionSwitchOnFXCount = CPostEffects::m_fInfraredVisionSwitchOnFXCount
                                                       - CTimer::ms_fTimeStep;
      }
      if ( v44 < 0.0 )
      {
        v44 = 0.0;
        CPostEffects::m_fInfraredVisionSwitchOnFXCount = 0.0;
      }
      v1.n64_u32[1] = 6.0;
      v1.n64_f32[0] = v1.n64_f32[0] * 0.125;
      v40 = v40 * 6.0;
      v45 = v44 * 0.017;
      v2.n64_f32[0] = v2.n64_f32[0] * 6.0;
      LODWORD(gGrade._anon_0.arr[1]) = v1.n64_u32[0];
      gGrade._anon_0.arr[0] = gGrade._anon_0.arr[0] * 0.125;
      v2.n64_f32[1] = bGrade._anon_0.arr[0] * 6.0;
      gGrade._anon_0.arr[2] = gGrade._anon_0.arr[2] * 0.125;
      gGrade._anon_0.arr[3] = gGrade._anon_0.arr[3] * 0.125;
      v0.n64_f32[1] = rGrade._anon_0.arr[3] * 6.0;
      rGrade._anon_0.arr[0] = v40;
      rGrade._anon_0.arr[1] = rGrade._anon_0.arr[1] * 6.0;
      rGrade._anon_0.arr[2] = rGrade._anon_0.arr[2] * 6.0;
      bGrade._anon_0.arr[3] = (float)(bGrade._anon_0.arr[3] * 6.0) + v45;
      LODWORD(bGrade._anon_0.arr[2]) = v2.n64_u32[0];
      bGrade._anon_0.arr[0] = bGrade._anon_0.arr[0] * 6.0;
      bGrade._anon_0.arr[1] = bGrade._anon_0.arr[1] * 6.0;
      rGrade._anon_0.arr[3] = v45 + (float)(rGrade._anon_0.arr[3] * 6.0);
    }
    else if ( CPostEffects::m_fInfraredVisionSwitchOnFXCount != CPostEffects::m_fNightVisionSwitchOnFXTime )
    {
      if ( CPostEffects::m_fInfraredVisionSwitchOnFXCount < CPostEffects::m_fNightVisionSwitchOnFXTime )
      {
        v0.n64_f32[1] = CTimer::ms_fTimeStep;
        v44 = CPostEffects::m_fInfraredVisionSwitchOnFXCount + (float)(CTimer::ms_fTimeStep * 0.5);
        CPostEffects::m_fInfraredVisionSwitchOnFXCount = v44;
      }
      if ( v44 > CPostEffects::m_fNightVisionSwitchOnFXTime )
      {
        v44 = CPostEffects::m_fNightVisionSwitchOnFXTime;
        CPostEffects::m_fInfraredVisionSwitchOnFXCount = CPostEffects::m_fNightVisionSwitchOnFXTime;
      }
      if ( !CPostEffects::m_bDarknessFilter )
        v43 = (float)(50.0 - v44) / 180.0;
    }
    if ( v43 != 0.0 )
    {
      gGrade._anon_0.arr[1] = (float)(v43 * 2.6) + v1.n64_f32[0];
      rGrade._anon_0.arr[0] = (float)(v43 * 2.6) + v40;
      bGrade._anon_0.arr[2] = (float)(v43 * 2.6) + v2.n64_f32[0];
      rGrade._anon_0.arr[3] = (float)(v43 * 0.4) + rGrade._anon_0.arr[3];
      gGrade._anon_0.arr[3] = (float)(v43 * 0.4) + gGrade._anon_0.arr[3];
      bGrade._anon_0.arr[3] = (float)(v43 * 0.4) + bGrade._anon_0.arr[3];
    }
  }
  if ( CPostEffects::m_bCCTV )
    CPostEffects::CCTV();
  if ( MobileSettings::settings[16].value != 60 )
  {
    v46 = (float)MobileSettings::settings[16].value + -60.0;
    if ( v46 >= 0.0 )
    {
      v48 = v46 / 320.0;
      rGrade._anon_0.arr[3] = v48 + rGrade._anon_0.arr[3];
      gGrade._anon_0.arr[3] = v48 + gGrade._anon_0.arr[3];
      bGrade._anon_0.arr[3] = v48 + bGrade._anon_0.arr[3];
    }
    else
    {
      v47 = (float)(v46 / 240.0) + 1.0;
      rGrade = (RQVector)vmulq_n_f32((float32x4_t)rGrade, v47);
      gGrade = (RQVector)vmulq_n_f32((float32x4_t)gGrade, v47);
      bGrade = (RQVector)vmulq_n_f32((float32x4_t)bGrade, v47);
    }
  }
  if ( CWeapon::ms_bTakePhoto )
  {
    v0.n64_u32[0] = 3.0;
    CPostEffects::MobileRender(void)::camFlash = 3.0;
LABEL_70:
    v1.n64_u32[0] = 0;
    v0.n64_f32[0] = (float)(v0.n64_f32[0] / 1.9) + -0.06;
    v0.n64_u64[0] = vmax_f32(v0, v1).n64_u64[0];
    v49 = vmin_f32(v0, v3).n64_f32[0];
    CPostEffects::MobileRender(void)::camFlash = v0.n64_f32[0];
    gGrade._anon_0.arr[3] = gGrade._anon_0.arr[3] + v49;
    rGrade._anon_0.arr[3] = rGrade._anon_0.arr[3] + v49;
    bGrade._anon_0.arr[3] = bGrade._anon_0.arr[3] + v49;
    goto LABEL_71;
  }
  v0.n64_f32[0] = CPostEffects::MobileRender(void)::camFlash;
  if ( CPostEffects::MobileRender(void)::camFlash != 0.0 )
    goto LABEL_70;
LABEL_71:
  if ( !((CTimer::m_UserPause || CTimer::m_CodePause) << 24) || MobileSettings::settings[22].value )
  {
    CPostEffects::MobileRender(void)::pauseAmt = 0.0;
  }
  else
  {
    v2.n64_u32[0] = 1061997773;
    v0.n64_f32[0] = CPostEffects::MobileRender(void)::pauseAmt + 0.032;
    v50 = vmin_f32(v0, v2).n64_f32[0];
    v51.n128_f32[3] = v50 * 0.0;
    CPostEffects::MobileRender(void)::pauseAmt = v50;
    v52 = 1.0 - v50;
    v51.n128_f32[0] = v50 * 0.54;
    v53 = vmulq_n_f32((float32x4_t)rGrade, 1.0 - v50);
    v54.n128_f32[1] = v50 * 0.54;
    v54.n128_f32[2] = v50 * 0.33;
    v51.n128_f32[1] = v54.n128_f32[2];
    v51.n128_f32[2] = v54.n128_f32[2];
    v54.n128_f32[0] = v54.n128_f32[2];
    v54.n128_u32[3] = v51.n128_u32[3];
    rGrade = (RQVector)vaddq_f32(v51, v53);
    v55 = (RQVector)vaddq_f32(v54, vmulq_n_f32((float32x4_t)gGrade, v52));
    v54.n128_u32[1] = v54.n128_u32[2];
    v54.n128_u64[1] = __PAIR64__(v51.n128_u32[3], v51.n128_u32[0]);
    gGrade = v55;
    bGrade = (RQVector)vaddq_f32(v54, vmulq_n_f32((float32x4_t)bGrade, v52));
  }
  if ( MobileSettings::settings[0].value > 2 )
  {
    emu_SetAltRTGrading(&rGrade, &gGrade, &bGrade);
    emu_SetAltBlurAmt((float)(CPostEffects::MobileRender(void)::pauseAmt * 3.4) + 0.0);
  }
  else
  {
    *(float *)&v56 = (float)(rGrade._anon_0.arr[0] + rGrade._anon_0.arr[1]) + rGrade._anon_0.arr[2];
    *((float *)&v56 + 1) = (float)(gGrade._anon_0.arr[0] + gGrade._anon_0.arr[1]) + gGrade._anon_0.arr[2];
    emu_SetAltRTContrast(
      v56,
      (float)(bGrade._anon_0.arr[0] + bGrade._anon_0.arr[1]) + bGrade._anon_0.arr[2],
      rGrade._anon_0.arr[3],
      gGrade._anon_0.arr[3],
      bGrade._anon_0.arr[3]);
  }
}
// 5B68D2: variable 'v0' is possibly undefined
// 5B68D2: variable 'v1' is possibly undefined
// 5B68D6: variable 'v3' is possibly undefined
// 5B6946: variable 'v2' is possibly undefined
// A478E4: using guessed type char `guard variable for'CPostEffects::MobileRender(void)::extraMultiplierLocal;

//----- (005B6C54) --------------------------------------------------------
void CPostEffects::NightVisionSetLights()
{
  if ( CPostEffects::m_bNightVision && !CPostEffects::m_bInCutscene )
    sub_1916BC();
}

//----- (005B6C7C) --------------------------------------------------------
void __fastcall CPostEffects::SetFilterMainColour(RwRaster_0 *pRaster, RwRGBA_0 colour)
{
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CPostEffects::pRasterFrontBuffer);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  *(RwRGBA_0 *)&pe_vertex[0].r = colour;
  *(RwRGBA_0 *)&pe_vertex[1].r = colour;
  *(RwRGBA_0 *)&pe_vertex[2].r = colour;
  *(RwRGBA_0 *)&pe_vertex[3].r = colour;
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_7);
  RwIm2DRenderIndexedPrimitive(rwPRIMTYPETRILIST, pe_vertex, 4, pe_index, 6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 7: using guessed type char byte_7;

//----- (005B6D70) --------------------------------------------------------
void CPostEffects::InfraredVisionSetLightsForHeatObjects()
{
  if ( CPostEffects::m_bInfraredVision && !CPostEffects::m_bInCutscene )
    sub_1A0A78();
}

//----- (005B6D98) --------------------------------------------------------
void __fastcall CPostEffects::InfraredVisionStoreAndSetLightsForHeatObjects(CPed *pPed)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d3
  float32x2_t v4; // d4
  signed int v5; // r0
  RwRGBAReal_0 v6; // [sp+0h] [bp-20h]

  if ( CPostEffects::m_bInfraredVision && !CPostEffects::m_bInCutscene )
  {
    v6 = CPostEffects::m_fInfraredVisionHeatObjectCol;
    if ( pPed->m_nPedState == PED_DEAD )
    {
      v3.n64_u32[0] = 1.0;
      v4.n64_u32[0] = 0;
      v5 = CTimer::m_snTimeInMilliseconds - pPed->m_nTimeOfDeath;
      if ( v5 < 0 )
        v5 = -v5;
      v1.n64_f32[0] = (float)v5 / 10000.0;
      v2.n64_f32[0] = CPostEffects::m_fInfraredVisionHeatObjectCol.red - v1.n64_f32[0];
      v1.n64_f32[0] = CPostEffects::m_fInfraredVisionHeatObjectCol.blue + v1.n64_f32[0];
      *(_QWORD *)&CPostEffects::m_fInfraredVisionHeatObjectCol.red = vmax_f32(v2, v4).n64_u32[0];
      LODWORD(CPostEffects::m_fInfraredVisionHeatObjectCol.blue) = vmin_f32(v1, v3).n64_u32[0];
    }
    StoreAndSetLightsForInfraredVisionHeatObjects();
    CPostEffects::m_fInfraredVisionHeatObjectCol = v6;
  }
}
// 5B6E16: variable 'v2' is possibly undefined
// 5B6E16: variable 'v4' is possibly undefined
// 5B6E1A: variable 'v1' is possibly undefined
// 5B6E1A: variable 'v3' is possibly undefined

//----- (005B6E60) --------------------------------------------------------
void CPostEffects::InfraredVisionRestoreLightsForHeatObjects()
{
  if ( CPostEffects::m_bInfraredVision && !CPostEffects::m_bInCutscene )
    sub_18E718();
}

//----- (005B6E88) --------------------------------------------------------
void CPostEffects::InfraredVisionSetLightsForDefaultObjects()
{
  if ( CPostEffects::m_bInfraredVision && !CPostEffects::m_bInCutscene )
    sub_19EA28();
}

//----- (005B6EB0) --------------------------------------------------------
void CPostEffects::FilterFX_StoreAndSetDayNightBalance()
{
  if ( !CPostEffects::m_bInCutscene )
  {
    fDayNightBalanceParamOld = CCustomBuildingDNPipeline::m_fDNBalanceParam;
    CCustomBuildingDNPipeline::m_fDNBalanceParam = CPostEffects::m_VisionFXDayNightBalance;
  }
}

//----- (005B6EE8) --------------------------------------------------------
void CPostEffects::FilterFX_RestoreDayNightBalance()
{
  if ( !CPostEffects::m_bInCutscene )
    CCustomBuildingDNPipeline::m_fDNBalanceParam = fDayNightBalanceParamOld;
}

//----- (005B6F14) --------------------------------------------------------
bool CPostEffects::IsVisionFXActive()
{
  _BOOL4 result; // r0

  if ( CPostEffects::m_bInCutscene )
    return 0;
  result = CPostEffects::m_bNightVision || CPostEffects::m_bInfraredVision;
  if ( CPostEffects::m_bNightVision || CPostEffects::m_bInfraredVision )
    return 1;
  return result;
}

//----- (005B6F50) --------------------------------------------------------
void __fastcall CShadowCamera::CShadowCamera(CShadowCamera *this)
{
  this->m_pShadowCamera = 0;
  this->m_pShadowTexture = 0;
}

//----- (005B6F58) --------------------------------------------------------
void __fastcall CShadowCamera::~CShadowCamera(CShadowCamera *this)
{
  CShadowCamera::Destroy(this);
}

//----- (005B6F66) --------------------------------------------------------
void __fastcall CShadowCamera::Destroy(CShadowCamera *this)
{
  RwCamera_0 *m_pShadowCamera; // r0
  RwFrame_0 *parent; // r5
  RwRaster_0 *frameBuffer; // r1
  RwTexture_0 *m_pShadowTexture; // r0

  m_pShadowCamera = this->m_pShadowCamera;
  if ( m_pShadowCamera )
  {
    parent = (RwFrame_0 *)m_pShadowCamera->object.object.parent;
    if ( parent )
    {
      _rwObjectHasFrameSetFrame(m_pShadowCamera, 0);
      RwFrameDestroy(parent);
      m_pShadowCamera = this->m_pShadowCamera;
    }
    frameBuffer = m_pShadowCamera->frameBuffer;
    if ( frameBuffer )
    {
      m_pShadowCamera->frameBuffer = 0;
      RwRasterDestroy(frameBuffer);
    }
    m_pShadowTexture = this->m_pShadowTexture;
    if ( m_pShadowTexture )
    {
      RwTextureSetRaster(m_pShadowTexture, 0);
      RwTextureDestroy(this->m_pShadowTexture);
      this->m_pShadowTexture = 0;
    }
    RwCameraDestroy(this->m_pShadowCamera);
    this->m_pShadowCamera = 0;
  }
}

//----- (005B6FB4) --------------------------------------------------------
RwCamera_0 *__fastcall CShadowCamera::Create(CShadowCamera *this, RwInt32 res)
{
  char v2; // r5
  RwCamera_0 *v4; // r6
  RwFrame_0 *v5; // r0
  RwRaster_0 *v6; // r0
  RwTexture_0 *v7; // r0

  v2 = res;
  v4 = RwCameraCreate();
  this->m_pShadowCamera = v4;
  if ( v4
    && (v5 = RwFrameCreate(), _rwObjectHasFrameSetFrame(v4, v5), this->m_pShadowCamera->object.object.parent)
    && (v6 = RwRasterCreate(1 << v2, 1 << v2, 0, 5)) != 0
    && (this->m_pShadowCamera->frameBuffer = v6, v7 = RwTextureCreate(v6), (this->m_pShadowTexture = v7) != 0) )
  {
    BYTE1(v7->filterAddressing) = 51;
    LOBYTE(this->m_pShadowTexture->filterAddressing) = 2;
    RwCameraSetProjection(this->m_pShadowCamera, rwPARALLEL);
    return this->m_pShadowCamera;
  }
  else
  {
    CShadowCamera::Destroy(this);
    return 0;
  }
}

//----- (005B7028) --------------------------------------------------------
void __fastcall CShadowCamera::ReInitRasters(CShadowCamera *this)
{
  RwCamera_0 *m_pShadowCamera; // r1
  RwRaster_0 *frameBuffer; // r0
  RwInt32 width; // r5
  RwRaster_0 *v5; // r1

  m_pShadowCamera = this->m_pShadowCamera;
  frameBuffer = this->m_pShadowCamera->frameBuffer;
  width = frameBuffer->width;
  m_pShadowCamera->frameBuffer = 0;
  RwRasterDestroy(frameBuffer);
  v5 = RwRasterCreate(width, width, 0, 5);
  this->m_pShadowCamera->frameBuffer = v5;
  sub_19D9F4(this->m_pShadowTexture, v5);
}

//----- (005B7058) --------------------------------------------------------
RwCamera_0 *__fastcall CShadowCamera::SetFrustum(CShadowCamera *this, RwReal objectRadius)
{
  RwV2d_0 v6; // [sp+0h] [bp-18h] BYREF

  RwCameraSetFarClipPlane(this->m_pShadowCamera, objectRadius + objectRadius);
  RwCameraSetNearClipPlane(this->m_pShadowCamera, objectRadius * 0.001);
  v6.y = -objectRadius;
  v6.x = objectRadius;
  RwCameraSetViewWindow(this->m_pShadowCamera, &v6);
  return this->m_pShadowCamera;
}

//----- (005B70AC) --------------------------------------------------------
RwCamera_0 *__fastcall CShadowCamera::SetLight(CShadowCamera *this, RpLight_0 *light)
{
  RwReal *parent; // r1
  __int64 v4; // d16
  RwFrame_0 *v5; // r5
  __int64 v6; // d16
  __int64 v7; // d16

  parent = (RwReal *)light->object.object.parent;
  v4 = *((_QWORD *)parent + 2);
  v5 = (RwFrame_0 *)this->m_pShadowCamera->object.object.parent;
  v5->modelling.right.z = parent[6];
  *(_QWORD *)&v5->modelling.right.x = v4;
  v6 = *((_QWORD *)parent + 4);
  v5->modelling.up.z = parent[10];
  *(_QWORD *)&v5->modelling.up.x = v6;
  v7 = *((_QWORD *)parent + 6);
  v5->modelling.at.z = parent[14];
  *(_QWORD *)&v5->modelling.at.x = v7;
  RwMatrixUpdate(&v5->modelling);
  RwFrameUpdateObjects(v5);
  return this->m_pShadowCamera;
}

//----- (005B70EE) --------------------------------------------------------
RwCamera_0 *__fastcall CShadowCamera::SetCenter(CShadowCamera *this, RwV3d_0 *center)
{
  __int64 v3; // d16
  RwFrame_0 *parent; // r5
  float y; // s6
  float z; // s8
  float v7; // s10

  v3 = *(_QWORD *)&center->x;
  parent = (RwFrame_0 *)this->m_pShadowCamera->object.object.parent;
  parent->modelling.pos.z = center->z;
  *(_QWORD *)&parent->modelling.pos.x = v3;
  y = parent->modelling.at.y;
  z = parent->modelling.at.z;
  v7 = parent->modelling.pos.y;
  parent->modelling.pos.x = parent->modelling.pos.x
                          + (float)(parent->modelling.at.x * (float)(this->m_pShadowCamera->farPlane * -0.5));
  parent->modelling.pos.y = v7 + (float)(y * (float)(this->m_pShadowCamera->farPlane * -0.5));
  parent->modelling.pos.z = parent->modelling.pos.z + (float)(z * (float)(this->m_pShadowCamera->farPlane * -0.5));
  RwMatrixUpdate(&parent->modelling);
  RwFrameUpdateObjects(parent);
  RwFrameOrthoNormalize(parent);
  return this->m_pShadowCamera;
}

//----- (005B717C) --------------------------------------------------------
RwCamera_0 *__fastcall CShadowCamera::Update(CShadowCamera *this, RpClump_0 *pClump, bool isVehicle, CPed *playerPed)
{
  _BOOL4 v6; // r9
  RpGeometry_0 *geometry; // r8
  RwUInt32 flags; // r6
  RpAtomic_0 *(*v10)(RpAtomic_0 *, void *); // r1
  RpClump_0 *m_pWeaponClump; // r5
  RwInt32 v12; // r5
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwMatrix *MatrixArray; // r10
  __int64 *v15; // r2
  char *parent; // r5
  __int64 *v17; // r1
  _QWORD *v18; // r0
  __int64 v19; // d16
  __int64 v20; // d17
  __int64 v21; // d23
  __int64 v22; // d18
  __int64 v23; // d19
  __int64 v24; // d20
  __int64 v25; // d21
  CTaskSimpleJetPack *TaskJetPack; // r0
  RpClump_0 *v28; // [sp+Ch] [bp-2Ch]
  RwUInt32 v29; // [sp+10h] [bp-28h]
  CRGBA v30; // [sp+14h] [bp-24h] BYREF
  CRGBA v31; // [sp+18h] [bp-20h] BYREF

  v6 = isVehicle;
  CRGBA::CRGBA(&v31, 0xFFu, 0xFFu, 0xFFu, 0);
  RwCameraClear(this->m_pShadowCamera, &v31, 3);
  if ( RwCameraBeginUpdate(this->m_pShadowCamera) )
  {
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
    if ( v6 )
    {
      RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
      CVisibilityPlugins::SetupVehicleVariables(pClump);
      carLodLerp = 1.0;
    }
    geometry = GetFirstAtomic(pClump)->geometry;
    flags = geometry->flags;
    geometry->flags = flags & 0xFFFFFF13;
    if ( v6 )
      v10 = ShCamStdClumpRenderVehicleCB;
    else
      v10 = ShCamStdClumpRenderCB;
    RpClumpForAllAtomics(pClump, v10, 0);
    if ( playerPed )
    {
      m_pWeaponClump = playerPed->m_pWeaponClump;
      if ( m_pWeaponClump )
      {
        v28 = playerPed->m_pWeaponClump;
        v29 = flags;
        v12 = 24;
        if ( playerPed->m_WeaponSlots[playerPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_PARACHUTE )
          v12 = 3;
        AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)playerPed->m_pRwObject);
        MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
        v15 = (__int64 *)&MatrixArray[RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, v12)];
        parent = (char *)playerPed->m_pWeaponClump->object.parent;
        v17 = v15 + 4;
        v18 = v15 + 6;
        v19 = *v15;
        v20 = v15[1];
        v15 += 2;
        v21 = v18[1];
        v22 = *v17;
        v23 = v17[1];
        v24 = *v15;
        v25 = v15[1];
        *((_QWORD *)parent + 8) = *v18;
        *((_QWORD *)parent + 9) = v21;
        *((_QWORD *)parent + 6) = v22;
        *((_QWORD *)parent + 7) = v23;
        *((_QWORD *)parent + 4) = v24;
        *((_QWORD *)parent + 5) = v25;
        *((_QWORD *)parent + 2) = v19;
        *((_QWORD *)parent + 3) = v20;
        if ( playerPed->m_WeaponSlots[playerPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_PARACHUTE )
        {
          RwMatrixTranslate(
            (RwMatrix *)(parent + 16),
            &CShadowCamera::Update(RpClump *,bool,CPed *)::parachuteOffset,
            rwCOMBINEPRECONCAT);
          RwMatrixRotate((RwMatrix *)(parent + 16), &CPedIK::YaxisIK, 90.0, rwCOMBINEPRECONCAT);
        }
        RwFrameUpdateObjects((RwFrame_0 *)parent);
        m_pWeaponClump = v28;
        flags = v29;
      }
      if ( CPedIntelligence::GetTaskJetPack(playerPed->m_pPedIntelligence) )
      {
        TaskJetPack = CPedIntelligence::GetTaskJetPack(playerPed->m_pPedIntelligence);
        CTaskSimpleJetPack::RenderJetPack(TaskJetPack, playerPed);
      }
      if ( m_pWeaponClump )
        RpClumpForAllAtomics(m_pWeaponClump, ShCamStdClumpRenderCB, 0);
    }
    CShadowCamera::InvertRaster(this);
    CRGBA::CRGBA(&v30, 0, 0, 0, 0xFFu);
    CShadowCamera::DrawOutlineBorder(this, &v30);
    if ( v6 )
      RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
    geometry->flags = flags;
    RwCameraEndUpdate(this->m_pShadowCamera);
  }
  return this->m_pShadowCamera;
}
// 0: using guessed type int dword_0;

//----- (005B7350) --------------------------------------------------------
RpAtomic_0 *__fastcall ShCamStdClumpRenderVehicleCB(RpAtomic_0 *pAtomic, void *pData)
{
  if ( (pAtomic->object.object.flags & 4) != 0
    && pAtomic->renderCallBack != CVisibilityPlugins::RenderVehicleReallyLowDetailCB )
  {
    AtomicDefaultRenderCallBack(pAtomic);
  }
  return pAtomic;
}
// 678820: using guessed type void *CVisibilityPlugins::RenderVehicleReallyLowDetailCB;

//----- (005B7378) --------------------------------------------------------
RpAtomic_0 *__fastcall ShCamStdClumpRenderCB(RpAtomic_0 *pAtomic, void *pData)
{
  RpAtomic_0 *(*renderCallBack)(RpAtomic_0 *); // r5
  RpAtomic_0 *result; // r0

  renderCallBack = pAtomic->renderCallBack;
  pAtomic->renderCallBack = AtomicDefaultRenderCallBack;
  AtomicDefaultRenderCallBack(pAtomic);
  result = pAtomic;
  if ( !renderCallBack )
    renderCallBack = AtomicDefaultRenderCallBack;
  pAtomic->renderCallBack = renderCallBack;
  return result;
}

//----- (005B73A8) --------------------------------------------------------
void __fastcall CShadowCamera::InvertRaster(CShadowCamera *this)
{
  RwCamera_0 *m_pShadowCamera; // r0
  float nearPlane; // s2
  RwRaster_0 *frameBuffer; // r0
  float v4; // s16
  float height; // s2
  float width; // s20
  RwIm2DVertex v7; // [sp+0h] [bp-98h] BYREF
  int v8; // [sp+1Ch] [bp-7Ch]
  float v9; // [sp+20h] [bp-78h]
  RwReal v10; // [sp+24h] [bp-74h]
  float v11; // [sp+28h] [bp-70h]
  int v12; // [sp+2Ch] [bp-6Ch]
  float v13; // [sp+38h] [bp-60h]
  int v14; // [sp+3Ch] [bp-5Ch]
  RwReal v15; // [sp+40h] [bp-58h]
  float v16; // [sp+44h] [bp-54h]
  int v17; // [sp+48h] [bp-50h]
  float v18; // [sp+54h] [bp-44h]
  float v19; // [sp+58h] [bp-40h]
  RwReal v20; // [sp+5Ch] [bp-3Ch]
  float v21; // [sp+60h] [bp-38h]
  int v22; // [sp+64h] [bp-34h]

  m_pShadowCamera = this->m_pShadowCamera;
  nearPlane = m_pShadowCamera->nearPlane;
  frameBuffer = m_pShadowCamera->frameBuffer;
  v4 = 1.0 / nearPlane;
  height = (float)frameBuffer->height;
  width = (float)frameBuffer->width;
  v7.x = -10.0;
  v7.y = -10.0;
  v7.z = RwIm2DGetNearScreenZ();
  *(_DWORD *)&v7.r = -1;
  v8 = -1054867456;
  v9 = height + 10.0;
  v7.rhw = v4;
  v12 = -1;
  v11 = v4;
  v10 = RwIm2DGetNearScreenZ();
  v13 = width + 10.0;
  v14 = -1054867456;
  v15 = RwIm2DGetNearScreenZ();
  v16 = v4;
  v17 = -1;
  v18 = width + 10.0;
  v19 = height + 10.0;
  v20 = RwIm2DGetNearScreenZ();
  v21 = v4;
  v22 = -1;
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_9[1]);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, &v7, 4);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B7484) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::DrawOutlineBorder(CShadowCamera *this, const RwRGBA_0 *color)
{
  RwRaster_0 *frameBuffer; // r8
  float width; // s16
  int v6; // r0
  float nearPlane; // s2
  float v8; // s18
  int v9; // s16
  RwImVertexIndex indices[4]; // [sp+8h] [bp-A8h] BYREF
  int v12; // [sp+10h] [bp-A0h]
  RwIm2DVertex vertices; // [sp+18h] [bp-98h] BYREF
  float v14; // [sp+34h] [bp-7Ch]
  int v15; // [sp+38h] [bp-78h]
  int v16; // [sp+3Ch] [bp-74h]
  float v17; // [sp+40h] [bp-70h]
  int v18; // [sp+44h] [bp-6Ch]
  float v19; // [sp+50h] [bp-60h]
  float v20; // [sp+54h] [bp-5Ch]
  int v21; // [sp+58h] [bp-58h]
  float v22; // [sp+5Ch] [bp-54h]
  int v23; // [sp+60h] [bp-50h]
  int v24; // [sp+6Ch] [bp-44h]
  float v25; // [sp+70h] [bp-40h]
  int v26; // [sp+74h] [bp-3Ch]
  float v27; // [sp+78h] [bp-38h]
  int v28; // [sp+7Ch] [bp-34h]

  frameBuffer = this->m_pShadowCamera->frameBuffer;
  width = (float)frameBuffer->width;
  *(float *)&v6 = RwIm2DGetNearScreenZ();
  nearPlane = this->m_pShadowCamera->nearPlane;
  LODWORD(vertices.z) = v6;
  *(RwRGBA_0 *)&vertices.r = *color;
  v16 = v6;
  v18 = *(_DWORD *)&vertices.r;
  v23 = *(_DWORD *)&vertices.r;
  v21 = v6;
  v28 = *(_DWORD *)&vertices.r;
  v26 = v6;
  v12 = 196610;
  vertices.rhw = 1.0 / nearPlane;
  v17 = 1.0 / nearPlane;
  v22 = 1.0 / nearPlane;
  v27 = 1.0 / nearPlane;
  *(_QWORD *)indices = 0x200010000LL;
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  v8 = width + 1.5;
  v14 = width + 1.5;
  vertices.x = -1.5;
  vertices.y = -1.5;
  v15 = -1077936128;
  v19 = width + 1.5;
  v20 = 1.5;
  v24 = -1077936128;
  v25 = 1.5;
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, &vertices, 4, indices, 6);
  v19 = 1.5;
  vertices.x = -1.5;
  vertices.y = -1.5;
  v14 = 1.5;
  v15 = -1077936128;
  v20 = width + 1.5;
  v24 = -1077936128;
  v25 = width + 1.5;
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, &vertices, 4, indices, 6);
  *(float *)&v9 = width + -1.5;
  LODWORD(vertices.x) = v9;
  vertices.y = -1.5;
  v14 = v8;
  v15 = -1077936128;
  v19 = v8;
  v20 = v8;
  v24 = v9;
  v25 = v8;
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, &vertices, 4, indices, 6);
  vertices.x = -1.5;
  v24 = -1077936128;
  LODWORD(vertices.y) = v9;
  v14 = v8;
  v15 = v9;
  v19 = v8;
  v20 = v8;
  v25 = v8;
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, &vertices, 4, indices, 6);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  return frameBuffer;
}
// 0: using guessed type int dword_0;

//----- (005B7624) --------------------------------------------------------
RwCamera_0 *__fastcall CShadowCamera::Update(CShadowCamera *this, RpAtomic_0 *pAtomic)
{
  RpGeometry_0 *geometry; // r6
  RwUInt32 flags; // r8
  RpAtomic_0 *(*renderCallBack)(RpAtomic_0 *); // r5
  CRGBA v8; // [sp+4h] [bp-1Ch] BYREF

  CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, 0);
  RwCameraClear(this->m_pShadowCamera, &v8, 3);
  if ( RwCameraBeginUpdate(this->m_pShadowCamera) )
  {
    geometry = pAtomic->geometry;
    flags = geometry->flags;
    geometry->flags = flags & 0xFFFFFF03;
    renderCallBack = pAtomic->renderCallBack;
    pAtomic->renderCallBack = AtomicDefaultRenderCallBack;
    AtomicDefaultRenderCallBack(pAtomic);
    if ( !renderCallBack )
      renderCallBack = AtomicDefaultRenderCallBack;
    pAtomic->renderCallBack = renderCallBack;
    geometry->flags = flags;
    CShadowCamera::InvertRaster(this);
    RwCameraEndUpdate(this->m_pShadowCamera);
  }
  return this->m_pShadowCamera;
}

//----- (005B76A4) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::MakeGradientRaster(CShadowCamera *this)
{
  RwCamera_0 *m_pShadowCamera; // r0
  float nearPlane; // s16
  float v4; // r8
  RwRaster_0 *frameBuffer; // r5
  int height; // r4
  int width; // r10
  float v8; // s16
  int v9; // s0
  float v10; // s24
  int v11; // r4
  int v12; // r9
  RwIm2DVertex vertices; // [sp+8h] [bp-80h] BYREF
  float v15; // [sp+24h] [bp-64h]
  float v16; // [sp+28h] [bp-60h]
  float v17; // [sp+2Ch] [bp-5Ch]
  float v18; // [sp+30h] [bp-58h]
  int v19; // [sp+34h] [bp-54h]

  m_pShadowCamera = this->m_pShadowCamera;
  if ( !m_pShadowCamera )
    return 0;
  nearPlane = m_pShadowCamera->nearPlane;
  v4 = RwIm2DGetNearScreenZ();
  frameBuffer = this->m_pShadowCamera->frameBuffer;
  height = frameBuffer->height;
  if ( height < 1 )
    return 0;
  width = frameBuffer->width;
  if ( RwCameraBeginUpdate(this->m_pShadowCamera) )
  {
    v8 = 1.0 / nearPlane;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_9[1]);
    RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
    v9 = height;
    v10 = 128.0;
    v11 = height + 1;
    v12 = 0;
    do
    {
      vertices.x = 0.0;
      vertices.z = v4;
      vertices.rhw = v8;
      vertices.y = (float)v12;
      *(_DWORD *)&vertices.r = 16843009 * (unsigned __int8)(int)v10;
      v16 = (float)v12;
      v15 = (float)width;
      v17 = v4;
      v18 = v8;
      v19 = *(_DWORD *)&vertices.r;
      RwIm2DRenderLine_BUGFIX(&vertices, 2, 0, 1);
      v10 = v10 - (float)(64.0 / (float)v9);
      ++v12;
    }
    while ( v11 != v12 );
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 2);
    RwCameraEndUpdate(this->m_pShadowCamera);
  }
  return frameBuffer;
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B77F0) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::GetRwRenderRaster(CShadowCamera *this)
{
  return this->m_pShadowCamera->frameBuffer;
}

//----- (005B77F6) --------------------------------------------------------
void __fastcall CShadowCamera::ApplyAlphaMapToRaster(CShadowCamera *this)
{
  RwRaster_0 *frameBuffer; // r4
  RwImage_0 *v3; // r0
  RwImage_0 *v4; // r5

  frameBuffer = this->m_pShadowCamera->frameBuffer;
  if ( frameBuffer )
  {
    v3 = RwImageCreate(frameBuffer->width, frameBuffer->height, 32);
    v4 = v3;
    if ( v3 )
    {
      RwImageAllocatePixels(v3);
      CShadowCamera::InvertRaster(this);
      RwImageSetFromRaster(v4, frameBuffer);
      RwImageMakeMask(v4);
      RwRasterSetFromImage(frameBuffer, v4);
      sub_19ECC0(v4);
    }
  }
}

//----- (005B784C) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::ShadowRasterRender(CShadowCamera *this, RwV2d_0 *_vx)
{
  float x; // s20
  float y; // s22
  float v5; // s18
  float v6; // s16
  RwRaster_0 *v7; // r4
  float width; // s24
  float v9; // s26
  float height; // s28
  RwIm2DVertex v12; // [sp+0h] [bp-B0h] BYREF
  float v13; // [sp+1Ch] [bp-94h]
  float v14; // [sp+20h] [bp-90h]
  float z; // [sp+24h] [bp-8Ch]
  float v16; // [sp+28h] [bp-88h]
  int v17; // [sp+2Ch] [bp-84h]
  int v18; // [sp+30h] [bp-80h]
  int v19; // [sp+34h] [bp-7Ch]
  float v20; // [sp+38h] [bp-78h]
  float v21; // [sp+3Ch] [bp-74h]
  float v22; // [sp+40h] [bp-70h]
  float v23; // [sp+44h] [bp-6Ch]
  int v24; // [sp+48h] [bp-68h]
  int v25; // [sp+4Ch] [bp-64h]
  int v26; // [sp+50h] [bp-60h]
  float v27; // [sp+54h] [bp-5Ch]
  float v28; // [sp+58h] [bp-58h]
  float v29; // [sp+5Ch] [bp-54h]
  float v30; // [sp+60h] [bp-50h]
  int v31; // [sp+64h] [bp-4Ch]
  int v32; // [sp+68h] [bp-48h]
  int v33; // [sp+6Ch] [bp-44h]

  if ( _vx )
  {
    x = _vx->x;
    y = _vx->y;
    v5 = _vx[1].x;
    v6 = _vx[1].y;
  }
  else
  {
    v6 = 0.17;
    v5 = 0.98;
    y = 0.02;
    x = 0.83;
  }
  v7 = *(RwRaster_0 **)(*(_DWORD *)RwEngineInstance + 96);
  width = (float)v7->width;
  v9 = *(float *)(*(_DWORD *)RwEngineInstance + 128);
  height = (float)v7->height;
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, this->m_pShadowCamera->frameBuffer);
  v12.y = y * height;
  v12.x = x * width;
  v12.z = RwIm2DGetNearScreenZ();
  *(_DWORD *)&v12.r = -1;
  v12.s = 0.0;
  v12.t = 0.0;
  v13 = x * width;
  z = v12.z;
  v14 = v6 * height;
  v17 = -1;
  v18 = 0;
  v19 = 1065353216;
  v22 = v12.z;
  v21 = y * height;
  v24 = -1;
  v25 = 1065353216;
  v26 = 0;
  v20 = v5 * width;
  v12.rhw = 1.0 / v9;
  v16 = 1.0 / v9;
  v23 = 1.0 / v9;
  v29 = v12.z;
  v28 = v6 * height;
  v31 = -1;
  v30 = 1.0 / v9;
  v32 = 1065353216;
  v33 = 1065353216;
  v27 = v5 * width;
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, &v12, 4);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  return v7;
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B796C) --------------------------------------------------------
RwBool __fastcall Im2DRenderQuad(
        RwReal x1,
        RwReal y1,
        RwReal x2,
        RwReal y2,
        RwReal z,
        RwReal recipCamZ,
        RwReal uvOffset)
{
  RwIm2DVertex v8; // [sp+0h] [bp-78h] BYREF
  RwReal v9; // [sp+1Ch] [bp-5Ch]
  RwReal v10; // [sp+20h] [bp-58h]
  RwReal v11; // [sp+24h] [bp-54h]
  RwReal v12; // [sp+28h] [bp-50h]
  int v13; // [sp+2Ch] [bp-4Ch]
  RwReal v14; // [sp+30h] [bp-48h]
  float v15; // [sp+34h] [bp-44h]
  RwReal v16; // [sp+38h] [bp-40h]
  RwReal v17; // [sp+3Ch] [bp-3Ch]
  RwReal v18; // [sp+40h] [bp-38h]
  RwReal v19; // [sp+44h] [bp-34h]
  int v20; // [sp+48h] [bp-30h]
  float v21; // [sp+4Ch] [bp-2Ch]
  RwReal v22; // [sp+50h] [bp-28h]
  RwReal v23; // [sp+54h] [bp-24h]
  RwReal v24; // [sp+58h] [bp-20h]
  RwReal v25; // [sp+5Ch] [bp-1Ch]
  RwReal v26; // [sp+60h] [bp-18h]
  int v27; // [sp+64h] [bp-14h]
  float v28; // [sp+68h] [bp-10h]
  float v29; // [sp+6Ch] [bp-Ch]

  v8.x = x1;
  v8.y = y1;
  *(_DWORD *)&v8.r = -1;
  v9 = x1;
  v10 = y2;
  v16 = x2;
  v17 = y1;
  v13 = -1;
  v8.z = z;
  v8.rhw = recipCamZ;
  v8.s = uvOffset;
  v8.t = uvOffset;
  v11 = z;
  v12 = recipCamZ;
  v14 = uvOffset;
  v15 = uvOffset + 1.0;
  v20 = -1;
  v18 = z;
  v19 = recipCamZ;
  v22 = uvOffset;
  v21 = uvOffset + 1.0;
  v23 = x2;
  v24 = y2;
  v25 = z;
  v27 = -1;
  v26 = recipCamZ;
  v28 = uvOffset + 1.0;
  v29 = uvOffset + 1.0;
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, &v8, 4);
  return 1;
}

//----- (005B79FA) --------------------------------------------------------
RwTexture_0 *__fastcall CShadowCamera::GetRwRenderTexture(CShadowCamera *this)
{
  return this->m_pShadowTexture;
}

//----- (005B7A00) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::RasterResample(CShadowCamera *this, RwRaster_0 *pSourceRaster)
{
  RwCamera_0 *m_pShadowCamera; // r0
  RwRaster_0 *frameBuffer; // r4
  float width; // s16
  float nearPlane; // s18
  RwIm2DVertex v9; // [sp+0h] [bp-A0h] BYREF
  int v10; // [sp+1Ch] [bp-84h]
  float v11; // [sp+20h] [bp-80h]
  float z; // [sp+24h] [bp-7Ch]
  float v13; // [sp+28h] [bp-78h]
  int v14; // [sp+2Ch] [bp-74h]
  float v15; // [sp+30h] [bp-70h]
  float v16; // [sp+34h] [bp-6Ch]
  float v17; // [sp+38h] [bp-68h]
  int v18; // [sp+3Ch] [bp-64h]
  float v19; // [sp+40h] [bp-60h]
  float v20; // [sp+44h] [bp-5Ch]
  int v21; // [sp+48h] [bp-58h]
  float v22; // [sp+4Ch] [bp-54h]
  float v23; // [sp+50h] [bp-50h]
  float v24; // [sp+54h] [bp-4Ch]
  float v25; // [sp+58h] [bp-48h]
  float v26; // [sp+5Ch] [bp-44h]
  float v27; // [sp+60h] [bp-40h]
  int v28; // [sp+64h] [bp-3Ch]
  float v29; // [sp+68h] [bp-38h]
  float v30; // [sp+6Ch] [bp-34h]

  m_pShadowCamera = this->m_pShadowCamera;
  if ( !m_pShadowCamera )
    return 0;
  frameBuffer = m_pShadowCamera->frameBuffer;
  width = (float)frameBuffer->width;
  nearPlane = m_pShadowCamera->nearPlane;
  if ( RwCameraBeginUpdate(m_pShadowCamera) )
  {
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, pSourceRaster);
    v9.x = 0.0;
    v9.y = 0.0;
    v9.z = RwIm2DGetNearScreenZ();
    *(_DWORD *)&v9.r = -1;
    v10 = 0;
    z = v9.z;
    v11 = width;
    v14 = -1;
    v18 = 0;
    v17 = width;
    v9.s = 0.0 / width;
    v9.t = 0.0 / width;
    v15 = 0.0 / width;
    v9.rhw = 1.0 / nearPlane;
    v13 = 1.0 / nearPlane;
    v16 = (float)(0.0 / width) + 1.0;
    v19 = v9.z;
    v21 = -1;
    v23 = 0.0 / width;
    v20 = 1.0 / nearPlane;
    v22 = v16;
    v24 = width;
    v26 = v9.z;
    v25 = width;
    v28 = -1;
    v27 = 1.0 / nearPlane;
    v29 = v16;
    v30 = v16;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, &v9, 4);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwCameraEndUpdate(this->m_pShadowCamera);
  }
  return frameBuffer;
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B7B10) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::RasterBlur(CShadowCamera *this, RwRaster_0 *pSourceRaster, int numPass)
{
  RwRaster_0 *result; // r0

  result = (RwRaster_0 *)this->m_pShadowCamera;
  if ( result )
    return pSourceRaster;
  return result;
}

//----- (005B7B1A) --------------------------------------------------------
RwRaster_0 *__fastcall CShadowCamera::RasterGradient(CShadowCamera *this, RwRaster_0 *pSourceRaster)
{
  RwCamera_0 *m_pShadowCamera; // r0
  RwRaster_0 *frameBuffer; // r8
  float width; // s16
  float nearPlane; // s18
  RwIm2DVertex v9; // [sp+0h] [bp-90h] BYREF
  int v10; // [sp+1Ch] [bp-74h]
  float v11; // [sp+20h] [bp-70h]
  float z; // [sp+24h] [bp-6Ch]
  float v13; // [sp+28h] [bp-68h]
  int v14; // [sp+2Ch] [bp-64h]
  int v15; // [sp+30h] [bp-60h]
  int v16; // [sp+34h] [bp-5Ch]
  float v17; // [sp+38h] [bp-58h]
  int v18; // [sp+3Ch] [bp-54h]
  float v19; // [sp+40h] [bp-50h]
  float v20; // [sp+44h] [bp-4Ch]
  int v21; // [sp+48h] [bp-48h]
  int v22; // [sp+4Ch] [bp-44h]
  int v23; // [sp+50h] [bp-40h]
  float v24; // [sp+54h] [bp-3Ch]
  float v25; // [sp+58h] [bp-38h]
  float v26; // [sp+5Ch] [bp-34h]
  float v27; // [sp+60h] [bp-30h]
  int v28; // [sp+64h] [bp-2Ch]
  int v29; // [sp+68h] [bp-28h]
  int v30; // [sp+6Ch] [bp-24h]

  m_pShadowCamera = this->m_pShadowCamera;
  frameBuffer = m_pShadowCamera->frameBuffer;
  width = (float)pSourceRaster->width;
  nearPlane = m_pShadowCamera->nearPlane;
  m_pShadowCamera->frameBuffer = pSourceRaster;
  if ( RwCameraBeginUpdate(this->m_pShadowCamera) )
  {
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 3);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, frameBuffer);
    v9.x = 0.0;
    v9.y = 0.0;
    v9.z = RwIm2DGetNearScreenZ();
    *(_DWORD *)&v9.r = -1;
    v9.s = 0.0;
    v9.t = 0.0;
    v10 = 0;
    z = v9.z;
    v11 = width;
    v14 = -1;
    v15 = 0;
    v16 = 1065353216;
    v18 = 0;
    v17 = width;
    v9.rhw = 1.0 / nearPlane;
    v13 = 1.0 / nearPlane;
    v19 = v9.z;
    v21 = -1;
    v22 = 1065353216;
    v23 = 0;
    v20 = 1.0 / nearPlane;
    v24 = width;
    v26 = v9.z;
    v25 = width;
    v28 = -1;
    v27 = 1.0 / nearPlane;
    v29 = 1065353216;
    v30 = 1065353216;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, &v9, 4);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwCameraEndUpdate(this->m_pShadowCamera);
  }
  this->m_pShadowCamera->frameBuffer = frameBuffer;
  return pSourceRaster;
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005B7C0A) --------------------------------------------------------
void __fastcall CRealTimeShadow::CRealTimeShadow(CRealTimeShadow *this)
{
  this->m_pPhysical = 0;
  this->m_rpObjectType = -1;
  this->m_pDirectionalLight = 0;
  this->m_nNumBlurPass = 0;
  this->m_bAAResample = 0;
  this->m_bGradientDistDisappear = 0;
  *(_WORD *)&this->m_usedThisFrame = 0;
  this->m_ShadowCamera = 0;
}

//----- (005B7C22) --------------------------------------------------------
void __fastcall CRealTimeShadow::~CRealTimeShadow(CRealTimeShadow *this)
{
  CShadowCamera *m_ShadowCamera; // r5
  RpLight_0 *m_pDirectionalLight; // r0
  RwFrame_0 *parent; // r5

  m_ShadowCamera = this->m_ShadowCamera;
  if ( m_ShadowCamera )
  {
    CShadowCamera::Destroy(this->m_ShadowCamera);
    operator delete(m_ShadowCamera);
    this->m_ShadowCamera = 0;
  }
  this->m_rpObjectType = -1;
  m_pDirectionalLight = this->m_pDirectionalLight;
  this->m_pPhysical = 0;
  if ( m_pDirectionalLight )
  {
    parent = (RwFrame_0 *)m_pDirectionalLight->object.object.parent;
    _rwObjectHasFrameSetFrame(m_pDirectionalLight, 0);
    RwFrameDestroy(parent);
    RpLightDestroy(this->m_pDirectionalLight);
    this->m_pDirectionalLight = 0;
  }
}

//----- (005B7C6C) --------------------------------------------------------
void __fastcall CRealTimeShadow::Destroy(CRealTimeShadow *this)
{
  CShadowCamera *m_ShadowCamera; // r5
  RpLight_0 *m_pDirectionalLight; // r0
  RwFrame_0 *parent; // r5

  m_ShadowCamera = this->m_ShadowCamera;
  if ( m_ShadowCamera )
  {
    CShadowCamera::Destroy(this->m_ShadowCamera);
    operator delete(m_ShadowCamera);
    this->m_ShadowCamera = 0;
  }
  this->m_rpObjectType = -1;
  m_pDirectionalLight = this->m_pDirectionalLight;
  this->m_pPhysical = 0;
  if ( m_pDirectionalLight )
  {
    parent = (RwFrame_0 *)m_pDirectionalLight->object.object.parent;
    _rwObjectHasFrameSetFrame(m_pDirectionalLight, 0);
    RwFrameDestroy(parent);
    RpLightDestroy(this->m_pDirectionalLight);
    this->m_pDirectionalLight = 0;
  }
}

//----- (005B7CC0) --------------------------------------------------------
int __fastcall CRealTimeShadow::Create(
        CRealTimeShadow *this,
        int type,
        bool bResampleRaster,
        int NumBlurPass,
        bool bGradientDistDisappear)
{
  RpLight_0 *v9; // r0
  int v10; // r5
  RwFrame_0 *v11; // r0
  CShadowCamera *v12; // r0
  RwInt32 v13; // r1
  RwCamera_0 *v14; // r0
  CShadowCamera *m_ShadowCamera; // r5
  RwReal *parent; // r0
  RwFrame_0 *v17; // r5
  __int64 v18; // d16
  __int64 v19; // d16
  __int64 v20; // d16
  RpLight_0 *m_pDirectionalLight; // r0
  RwFrame_0 *v22; // r6
  RwRGBAReal_0 v24; // [sp+0h] [bp-28h] BYREF

  v9 = RpLightCreate(1);
  v10 = 0;
  this->m_pDirectionalLight = v9;
  if ( v9 )
  {
    *(_QWORD *)&v24.red = 0x3F4CCCCD3F4CCCCDLL;
    *(_QWORD *)&v24.blue = 1061997773LL;
    RpLightSetColor(v9, &v24);
    v11 = RwFrameCreate();
    _rwObjectHasFrameSetFrame(this->m_pDirectionalLight, v11);
    v12 = (CShadowCamera *)operator new(8u);
    v13 = 4;
    v12->m_pShadowCamera = 0;
    v12->m_pShadowTexture = 0;
    this->m_ShadowCamera = v12;
    if ( type == 1 )
      v13 = 8;
    if ( !type )
      v13 = 9;
    v14 = CShadowCamera::Create(v12, v13);
    m_ShadowCamera = this->m_ShadowCamera;
    if ( v14 )
    {
      parent = (RwReal *)this->m_pDirectionalLight->object.object.parent;
      v17 = (RwFrame_0 *)m_ShadowCamera->m_pShadowCamera->object.object.parent;
      v18 = *((_QWORD *)parent + 2);
      v17->modelling.right.z = parent[6];
      *(_QWORD *)&v17->modelling.right.x = v18;
      v19 = *((_QWORD *)parent + 4);
      v17->modelling.up.z = parent[10];
      *(_QWORD *)&v17->modelling.up.x = v19;
      v20 = *((_QWORD *)parent + 6);
      v17->modelling.at.z = parent[14];
      *(_QWORD *)&v17->modelling.at.x = v20;
      RwMatrixUpdate(&v17->modelling);
      RwFrameUpdateObjects(v17);
      v10 = 1;
      this->m_nNumBlurPass = NumBlurPass;
      this->m_bAAResample = bResampleRaster;
      this->m_bGradientDistDisappear = bGradientDistDisappear;
    }
    else
    {
      if ( m_ShadowCamera )
      {
        CShadowCamera::Destroy(this->m_ShadowCamera);
        operator delete(m_ShadowCamera);
        this->m_ShadowCamera = 0;
      }
      v10 = 0;
      this->m_rpObjectType = -1;
      m_pDirectionalLight = this->m_pDirectionalLight;
      this->m_pPhysical = 0;
      if ( m_pDirectionalLight )
      {
        v22 = (RwFrame_0 *)m_pDirectionalLight->object.object.parent;
        _rwObjectHasFrameSetFrame(m_pDirectionalLight, 0);
        RwFrameDestroy(v22);
        RpLightDestroy(this->m_pDirectionalLight);
        this->m_pDirectionalLight = 0;
      }
    }
  }
  return v10;
}

//----- (005B7DD0) --------------------------------------------------------
bool __fastcall CRealTimeShadow::SetShadowedObject(CRealTimeShadow *this, CPhysical *pPhysical)
{
  RwObject_0 *m_pRwObject; // r5
  RwUInt32 type; // r0
  RwReal radius; // r0
  RwSphere_0 *p_m_ClumpBoundingSphere; // r1
  bool v7; // r5
  CShadowCamera *v8; // r5
  RpLight_0 *m_pDirectionalLight; // r0
  RwFrame_0 *v10; // r6
  __int64 v11; // d17
  char *parent; // r0
  RwSphere_0 *p_m_ClumpWorldBoundingSphere; // r5
  CShadowCamera *m_ShadowCamera; // r6
  RwReal v15; // s20
  CShadowCamera *v16; // r0
  __int64 v17; // d16
  RwFrame_0 *v18; // r4
  float y; // s6
  float z; // s8
  float v21; // s10
  RwV2d_0 v23; // [sp+0h] [bp-30h] BYREF

  this->m_pPhysical = pPhysical;
  m_pRwObject = pPhysical->m_pRwObject;
  if ( !m_pRwObject )
    return 0;
  type = m_pRwObject->type;
  this->m_rpObjectType = type;
  if ( type - 1 < 2 )
  {
    if ( type == 1 )
    {
      if ( ((int)m_pRwObject[9].parent & 2) != 0 )
        _rpAtomicResyncInterpolatedSphere((RpAtomic_0 *)m_pRwObject);
      p_m_ClumpBoundingSphere = &this->m_ClumpBoundingSphere;
      v11 = *(_QWORD *)&m_pRwObject[4].parent;
      *(RwObject_0 *)&this->m_ClumpBoundingSphere.center.x = *(RwObject_0 *)((char *)m_pRwObject + 28);
      *(_QWORD *)&this->m_ClumpBoundingSphere.center.z = v11;
      radius = this->m_ClumpBoundingSphere.radius;
    }
    else
    {
      if ( type != 2 )
      {
        p_m_ClumpWorldBoundingSphere = &this->m_ClumpWorldBoundingSphere;
        goto LABEL_16;
      }
      RpClumpGetBoundingSphere((RpClump_0 *)m_pRwObject, &this->m_ClumpBoundingSphere, 1);
      radius = this->m_ClumpBoundingSphere.radius;
      p_m_ClumpBoundingSphere = &this->m_ClumpBoundingSphere;
    }
    this->m_ClumpWorldBoundingSphere.radius = radius;
    parent = (char *)m_pRwObject->parent;
    p_m_ClumpWorldBoundingSphere = &this->m_ClumpWorldBoundingSphere;
    RwV3dTransformPoints(
      &this->m_ClumpWorldBoundingSphere.center,
      &p_m_ClumpBoundingSphere->center,
      1,
      (const RwMatrix *)(parent + 16));
LABEL_16:
    m_ShadowCamera = this->m_ShadowCamera;
    v15 = this->m_ClumpBoundingSphere.radius * 1.1;
    RwCameraSetFarClipPlane(m_ShadowCamera->m_pShadowCamera, v15 + v15);
    RwCameraSetNearClipPlane(m_ShadowCamera->m_pShadowCamera, v15 * 0.001);
    v23.y = -v15;
    v23.x = v15;
    RwCameraSetViewWindow(m_ShadowCamera->m_pShadowCamera, &v23);
    v16 = this->m_ShadowCamera;
    v17 = *(_QWORD *)&p_m_ClumpWorldBoundingSphere->center.x;
    v18 = (RwFrame_0 *)v16->m_pShadowCamera->object.object.parent;
    v18->modelling.pos.z = p_m_ClumpWorldBoundingSphere->center.z;
    *(_QWORD *)&v18->modelling.pos.x = v17;
    y = v18->modelling.at.y;
    z = v18->modelling.at.z;
    v21 = v18->modelling.pos.y;
    v18->modelling.pos.x = v18->modelling.pos.x
                         + (float)(v18->modelling.at.x * (float)(v16->m_pShadowCamera->farPlane * -0.5));
    v18->modelling.pos.y = v21 + (float)(y * (float)(v16->m_pShadowCamera->farPlane * -0.5));
    v18->modelling.pos.z = v18->modelling.pos.z + (float)(z * (float)(v16->m_pShadowCamera->farPlane * -0.5));
    RwMatrixUpdate(&v18->modelling);
    RwFrameUpdateObjects(v18);
    RwFrameOrthoNormalize(v18);
    return 1;
  }
  v8 = this->m_ShadowCamera;
  if ( v8 )
  {
    CShadowCamera::Destroy(this->m_ShadowCamera);
    operator delete(v8);
    this->m_ShadowCamera = 0;
  }
  v7 = 0;
  this->m_rpObjectType = -1;
  m_pDirectionalLight = this->m_pDirectionalLight;
  this->m_pPhysical = 0;
  if ( m_pDirectionalLight )
  {
    v10 = (RwFrame_0 *)m_pDirectionalLight->object.object.parent;
    _rwObjectHasFrameSetFrame(m_pDirectionalLight, 0);
    RwFrameDestroy(v10);
    RpLightDestroy(this->m_pDirectionalLight);
    this->m_pDirectionalLight = 0;
  }
  return v7;
}

//----- (005B7F68) --------------------------------------------------------
RwFrame_0 *__fastcall CRealTimeShadow::SetLightProperties(
        CRealTimeShadow *this,
        float Azimuth,
        float Elevation,
        bool bUpdateCamera)
{
  _BOOL4 v5; // r8
  RwFrame_0 *parent; // r4
  RwReal *v8; // r1
  RwFrame_0 *v9; // r5
  __int64 v10; // d16
  __int64 v11; // d16
  __int64 v12; // d16
  RwV3d_0 vectorOut; // [sp+4h] [bp-24h] BYREF

  v5 = bUpdateCamera;
  parent = (RwFrame_0 *)this->m_pDirectionalLight->object.object.parent;
  if ( !parent )
    return 0;
  RwFrameRotate(
    (RwFrame_0 *)this->m_pDirectionalLight->object.object.parent,
    &CRealTimeShadow::SetLightProperties(float,float,bool)::Yaxis,
    COERCE_RWREAL(LODWORD(Azimuth) ^ 0x80000000),
    rwCOMBINEREPLACE);
  RwV3dTransformVector(&vectorOut, &CRealTimeShadow::SetLightProperties(float,float,bool)::Xaxis, &parent->modelling);
  RwFrameRotate(parent, &vectorOut, Elevation, rwCOMBINEPOSTCONCAT);
  if ( v5 )
  {
    v8 = (RwReal *)this->m_pDirectionalLight->object.object.parent;
    v9 = (RwFrame_0 *)this->m_ShadowCamera->m_pShadowCamera->object.object.parent;
    v10 = *((_QWORD *)v8 + 2);
    v9->modelling.right.z = v8[6];
    *(_QWORD *)&v9->modelling.right.x = v10;
    v11 = *((_QWORD *)v8 + 4);
    v9->modelling.up.z = v8[10];
    *(_QWORD *)&v9->modelling.up.x = v11;
    v12 = *((_QWORD *)v8 + 6);
    v9->modelling.at.z = v8[14];
    *(_QWORD *)&v9->modelling.at.x = v12;
    RwMatrixUpdate(&v9->modelling);
    RwFrameUpdateObjects(v9);
  }
  return parent;
}

//----- (005B8008) --------------------------------------------------------
CShadowCamera *__fastcall CRealTimeShadow::GetShadowCamera(CRealTimeShadow *this)
{
  return this->m_ShadowCamera;
}

//----- (005B800C) --------------------------------------------------------
RwTexture_0 *__fastcall CRealTimeShadow::Update(CRealTimeShadow *this)
{
  RwUInt32 m_rpObjectType; // r0
  bool v3; // zf
  CPed *m_pPhysical; // r5
  CShadowCamera *m_ShadowCamera; // r6
  RwReal v6; // s20
  CShadowCamera *v7; // r0
  __int64 v8; // d16
  RwFrame_0 *parent; // r6
  float y; // s6
  float z; // s8
  float v12; // s10
  RwUInt32 v13; // r0
  CShadowCamera *v14; // r0
  RwRaster_0 *frameBuffer; // r1
  bool v16; // zf
  RwV2d_0 v18; // [sp+0h] [bp-30h] BYREF

  m_rpObjectType = this->m_rpObjectType;
  v3 = m_rpObjectType == 1;
  if ( m_rpObjectType != 1 )
    v3 = m_rpObjectType == 2;
  if ( v3 )
    RwV3dTransformPoints(
      &this->m_ClumpWorldBoundingSphere.center,
      &this->m_ClumpBoundingSphere.center,
      1,
      (const RwMatrix *)((char *)this->m_pPhysical->m_pRwObject->parent + 16));
  if ( MobileSettings::settings[5].value == 2 && (*(_BYTE *)&this->m_pPhysical->m_info & 7) == 3 )
  {
    if ( CPed::IsPlayer((const CPed *)this->m_pPhysical) )
      m_pPhysical = (CPed *)this->m_pPhysical;
    else
      m_pPhysical = 0;
  }
  else
  {
    m_pPhysical = 0;
  }
  m_ShadowCamera = this->m_ShadowCamera;
  v6 = this->m_ClumpBoundingSphere.radius * 1.1;
  RwCameraSetFarClipPlane(m_ShadowCamera->m_pShadowCamera, v6 + v6);
  RwCameraSetNearClipPlane(m_ShadowCamera->m_pShadowCamera, v6 * 0.001);
  v18.y = -v6;
  v18.x = v6;
  RwCameraSetViewWindow(m_ShadowCamera->m_pShadowCamera, &v18);
  v7 = this->m_ShadowCamera;
  v8 = *(_QWORD *)&this->m_ClumpWorldBoundingSphere.center.x;
  parent = (RwFrame_0 *)v7->m_pShadowCamera->object.object.parent;
  parent->modelling.pos.z = this->m_ClumpWorldBoundingSphere.center.z;
  *(_QWORD *)&parent->modelling.pos.x = v8;
  y = parent->modelling.at.y;
  z = parent->modelling.at.z;
  v12 = parent->modelling.pos.y;
  parent->modelling.pos.x = parent->modelling.pos.x
                          + (float)(parent->modelling.at.x * (float)(v7->m_pShadowCamera->farPlane * -0.5));
  parent->modelling.pos.y = v12 + (float)(y * (float)(v7->m_pShadowCamera->farPlane * -0.5));
  parent->modelling.pos.z = parent->modelling.pos.z + (float)(z * (float)(v7->m_pShadowCamera->farPlane * -0.5));
  RwMatrixUpdate(&parent->modelling);
  RwFrameUpdateObjects(parent);
  RwFrameOrthoNormalize(parent);
  v13 = this->m_rpObjectType;
  if ( v13 == 1 )
  {
    CShadowCamera::Update(this->m_ShadowCamera, (RpAtomic_0 *)this->m_pPhysical->m_pRwObject);
  }
  else if ( v13 == 2 )
  {
    CShadowCamera::Update(
      this->m_ShadowCamera,
      (RpClump_0 *)this->m_pPhysical->m_pRwObject,
      (*(_BYTE *)&this->m_pPhysical->m_info & 7) == 2,
      m_pPhysical);
  }
  v14 = this->m_ShadowCamera;
  frameBuffer = v14->m_pShadowCamera->frameBuffer;
  if ( this->m_nNumBlurPass && !g_realTimeShadowMan.m_IPCameraMB.m_pShadowCamera )
    frameBuffer = (RwRaster_0 *)g_realTimeShadowMan.m_IPCameraMB.m_pShadowCamera;
  v16 = MobileSettings::settings[5].value == 2;
  if ( MobileSettings::settings[5].value != 2 )
    v16 = !this->m_bGradientDistDisappear;
  if ( !v16 )
  {
    CShadowCamera::RasterGradient(&g_realTimeShadowMan.m_IPCameraGradient, frameBuffer);
    v14 = this->m_ShadowCamera;
  }
  return v14->m_pShadowTexture;
}

//----- (005B81C8) --------------------------------------------------------
RwTexture_0 *__fastcall CRealTimeShadow::GetShadowRwTexture(CRealTimeShadow *this)
{
  return this->m_ShadowCamera->m_pShadowTexture;
}

//----- (005B81CE) --------------------------------------------------------
void __fastcall CRealTimeShadow::DrawBorderAroundTexture(CRealTimeShadow *this, const RwRGBA_0 *borderColor)
{
  CShadowCamera::DrawOutlineBorder(this->m_ShadowCamera, borderColor);
}

//----- (005B81E0) --------------------------------------------------------
void __fastcall CRealTimeShadow::Render(CRealTimeShadow *this, int32 shadowNum, float ShadowStrength)
{
  float32x4_t v3; // q8
  float32x4_t v4; // q2
  float32x4_t v5; // q8
  RwV2d_0 v6[2]; // [sp+0h] [bp-18h] BYREF

  v3.n128_u64[0] = 0x3CA3D70A3CA3D70ALL;
  v3.n128_u64[1] = 0x3E6147AE3E6147AELL;
  v4.n128_f32[1] = (float)(shadowNum / 4) * 0.2;
  v4.n128_f32[0] = (float)(shadowNum % 4) * 0.2;
  v4.n128_f32[2] = v4.n128_f32[0];
  v4.n128_f32[3] = v4.n128_f32[1];
  v5 = vaddq_f32(v4, v3);
  v6[0] = (RwV2d_0)v5.n128_u64[0];
  v6[1] = *(RwV2d_0 *)&v5.n128_i8[8];
  CShadowCamera::ShadowRasterRender(this->m_ShadowCamera, v6);
}

//----- (005B8254) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::CRealTimeShadowManager(CRealTimeShadowManager *this)
{
  this->m_initialised = 0;
  memset(this->m_pRealTimeShadows, 0, 0xA1u);
  this->m_IPCameraMB = 0LL;
  this->m_IPCameraGradient = 0LL;
}

//----- (005B8276) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::~CRealTimeShadowManager(CRealTimeShadowManager *this)
{
  CShadowCamera::Destroy(&this->m_IPCameraGradient);
  CShadowCamera::Destroy(&this->m_IPCameraMB);
}

//----- (005B8290) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::Init(CRealTimeShadowManager *this)
{
  int i; // r4
  int v3; // r0
  int v4; // r1

  if ( !this->m_initialised )
  {
    for ( i = 0; i != 40; ++i )
    {
      v3 = operator new(0x40u);
      v4 = 2;
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 24) = -1;
      *(_DWORD *)(v3 + 28) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_BYTE *)(v3 + 12) = 0;
      *(_BYTE *)(v3 + 20) = 0;
      *(_WORD *)(v3 + 4) = 0;
      *(_DWORD *)(v3 + 8) = 0;
      this->m_pRealTimeShadows[i] = (CRealTimeShadow *)v3;
      if ( i < 12 )
        v4 = 1;
      if ( i < 4 )
        v4 = 0;
      CRealTimeShadow::Create((CRealTimeShadow *)v3, v4, 0, 4, 1);
    }
    CShadowCamera::Create(&this->m_IPCameraMB, 7);
    CShadowCamera::Create(&this->m_IPCameraGradient, 7);
    CShadowCamera::MakeGradientRaster(&this->m_IPCameraGradient);
    this->m_initialised = 1;
  }
}

//----- (005B831C) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::Exit(CRealTimeShadowManager *this)
{
  int i; // r4
  void *v3; // r5
  void *v4; // r6
  _DWORD *v5; // r0
  RwFrame_0 *v6; // r6

  if ( this->m_initialised )
  {
    for ( i = 1; i != 41; ++i )
    {
      v3 = (void *)*((_DWORD *)&this->m_initialised + i);
      if ( v3 )
      {
        v4 = (void *)*((_DWORD *)v3 + 2);
        if ( v4 )
        {
          CShadowCamera::Destroy(*((CShadowCamera **)v3 + 2));
          operator delete(v4);
          *((_DWORD *)v3 + 2) = 0;
        }
        *((_DWORD *)v3 + 6) = -1;
        v5 = (_DWORD *)*((_DWORD *)v3 + 7);
        *(_DWORD *)v3 = 0;
        if ( v5 )
        {
          v6 = (RwFrame_0 *)v5[1];
          _rwObjectHasFrameSetFrame(v5, 0);
          RwFrameDestroy(v6);
          RpLightDestroy(*((RpLight_0 **)v3 + 7));
        }
        operator delete(v3);
      }
      *((_DWORD *)&this->m_initialised + i) = 0;
    }
    CShadowCamera::Destroy(&this->m_IPCameraMB);
    CShadowCamera::Destroy(&this->m_IPCameraGradient);
    this->m_initialised = 0;
  }
}

//----- (005B839C) --------------------------------------------------------
int __fastcall CRealTimeShadowManager::CamDistComp(const void *a, const void *b)
{
  int *v2; // r2
  int v3; // r0
  int v4; // r1
  int result; // r0
  int v6; // r3
  int v7; // r12
  float *v8; // r2
  float v9; // s0
  float *v10; // r0
  float v11; // s2
  float v12; // s4
  CSimpleTransform *p_tx; // r2
  float x; // s6
  float y; // s8
  float v16; // s0
  float v17; // s14
  float v18; // s6
  float v19; // s1

  v2 = *(int **)a;
  v3 = **(_DWORD **)b;
  v4 = *v2;
  if ( !*v2 )
    return v3 != 0;
  if ( !v3 )
    return -1;
  v6 = *(_DWORD *)(v3 + 20);
  v7 = *(_DWORD *)(v4 + 20);
  v8 = (float *)(v6 + 48);
  if ( !v6 )
    v8 = (float *)(v3 + 4);
  v9 = *v8;
  v10 = (float *)(v7 + 48);
  v11 = v8[1];
  v12 = v8[2];
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  x = p_tx->m_translate.x;
  if ( !v7 )
    v10 = (float *)(v4 + 4);
  v16 = x - v9;
  v17 = v10[1];
  v18 = x - *v10;
  v19 = v10[2];
  result = 1;
  y = p_tx->m_translate.y;
  if ( (float)((float)((float)(v18 * v18) + (float)((float)(y - v17) * (float)(y - v17)))
             + (float)((float)(p_tx->m_translate.z - v19) * (float)(p_tx->m_translate.z - v19))) < (float)((float)((float)(v16 * v16) + (float)((float)(y - v11) * (float)(y - v11))) + (float)((float)(p_tx->m_translate.z - v12) * (float)(p_tx->m_translate.z - v12))) )
    return -1;
  return result;
}

//----- (005B846C) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::Update(CRealTimeShadowManager *this)
{
  int v2; // r5
  int v3; // r4
  int v4; // r12
  int i; // r0
  int v6; // r6
  int v7; // r1
  int v8; // r1
  int v9; // r3
  int v10; // r2
  int v11; // r0
  int j; // r1
  _DWORD *v13; // r2
  int v14; // r3
  int k; // r1
  int v16; // r2
  CRealTimeShadow **m_pRealTimeShadows; // r10
  int m; // r11
  CRealTimeShadow *v19; // r0
  int m_fadeVal; // r1
  char v21; // r2
  CRealTimeShadow *v22; // r0
  int v23; // r1
  int v24; // r2
  _DWORD v25[47]; // [sp+2Ch] [bp-BCh]

  if ( MobileSettings::settings[5].value )
  {
    v2 = 4;
    v3 = 12;
    v4 = 0;
    for ( i = 1; i != 41; ++i )
    {
      v6 = *(_DWORD *)(*((_DWORD *)&this->m_initialised + i) + 8);
      if ( v6 )
      {
        v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v6 + 96) + 12);
        if ( v7 == 16 )
        {
          v8 = v3 + 1;
          v9 = v2;
          v10 = v4;
        }
        else if ( v7 <= 256 )
        {
          v9 = v2 + 1;
          v8 = v3;
          v10 = v4;
          v3 = v2;
        }
        else
        {
          v8 = v3;
          v10 = v4 + 1;
          v9 = v2;
          v3 = v4;
        }
        v25[v3] = v6;
        v4 = v10;
        v3 = v8;
        v2 = v9;
      }
    }
    qsort(&this->m_pRealTimeShadows[1], 0x27u, 4u, CRealTimeShadowManager::CamDistComp);
    v11 = 0;
    for ( j = 1; j != 41; ++j )
    {
      v13 = (_DWORD *)*((_DWORD *)&this->m_initialised + j);
      v14 = 0;
      if ( *v13 && v11 <= 3 && (*(_BYTE *)(*v13 + 58) & 7) == 2 )
        v14 = v25[v11++];
      v13[2] = v14;
    }
    for ( k = 1; k != 41; ++k )
    {
      v16 = *((_DWORD *)&this->m_initialised + k);
      if ( !*(_DWORD *)(v16 + 8) )
        *(_DWORD *)(v16 + 8) = v25[v11++];
    }
    this->m_updatingShadows = 1;
    m_pRealTimeShadows = this->m_pRealTimeShadows;
    for ( m = 0; m != 40; ++m )
    {
      v19 = m_pRealTimeShadows[m];
      if ( v19->m_pPhysical )
      {
        m_fadeVal = v19->m_fadeVal;
        if ( m <= 11 && v19->m_usedThisFrame )
        {
          v21 = 100;
          if ( m_fadeVal < 90 )
            v21 = m_fadeVal + 10;
        }
        else
        {
          v21 = m_fadeVal - 10;
          if ( m_fadeVal <= 10 )
            v21 = 0;
        }
        v19->m_fadeVal = v21;
        v22 = m_pRealTimeShadows[m];
        if ( v22->m_fadeVal )
        {
          if ( v22->m_ShadowCamera
            && CShadows::StoreRealTimeShadow(
                 v22->m_pPhysical,
                 CTimeCycle::m_fShadowDisplacementX[CTimeCycle::m_CurrentStoredValue],
                 CTimeCycle::m_fShadowDisplacementY[CTimeCycle::m_CurrentStoredValue],
                 CTimeCycle::m_fShadowFrontX[CTimeCycle::m_CurrentStoredValue],
                 CTimeCycle::m_fShadowFrontY[CTimeCycle::m_CurrentStoredValue],
                 CTimeCycle::m_fShadowSideX[CTimeCycle::m_CurrentStoredValue],
                 CTimeCycle::m_fShadowSideY[CTimeCycle::m_CurrentStoredValue]) == 1 )
          {
            CRealTimeShadow::Update(m_pRealTimeShadows[m]);
          }
        }
        else if ( this->m_initialised )
        {
          v22->m_pPhysical->m_pRealTimeShadow = 0;
          v22->m_pPhysical = 0;
        }
      }
    }
    v23 = 1;
    this->m_updatingShadows = 0;
    do
    {
      v24 = *((_DWORD *)&this->m_initialised + v23++);
      *(_BYTE *)(v24 + 4) = 0;
    }
    while ( v23 != 41 );
  }
}
// 5B846C: using guessed type _DWORD var_BC[47];

//----- (005B8668) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::ReturnRealTimeShadow(
        CRealTimeShadowManager *this,
        CRealTimeShadow *pRealTimeShadow)
{
  if ( this->m_initialised )
  {
    pRealTimeShadow->m_pPhysical->m_pRealTimeShadow = 0;
    pRealTimeShadow->m_pPhysical = 0;
  }
}

//----- (005B867A) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::ReInit(CRealTimeShadowManager *this)
{
  int i; // r6
  RwTexture_0 **v3; // r4
  RwRaster_0 *next; // r0
  RwInt32 width; // r5
  RwRaster_0 *v6; // r0
  RwCamera_0 *m_pShadowCamera; // r1
  RwRaster_0 *frameBuffer; // r0
  RwInt32 v9; // r5
  RwRaster_0 *v10; // r0
  CShadowCamera *p_m_IPCameraGradient; // r9
  RwCamera_0 *v12; // t1
  RwRaster_0 *v13; // r0
  RwInt32 v14; // r5
  RwRaster_0 *v15; // r0

  for ( i = 1; i != 41; ++i )
  {
    v3 = *(RwTexture_0 ***)(*((_DWORD *)&this->m_initialised + i) + 8);
    if ( v3 )
    {
      next = (RwRaster_0 *)(*v3)[1].lInDictionary.next;
      width = next->width;
      (*v3)[1].lInDictionary.next = 0;
      RwRasterDestroy(next);
      v6 = RwRasterCreate(width, width, 0, 5);
      (*v3)[1].lInDictionary.next = (RwLLLink *)v6;
      RwTextureSetRaster(v3[1], v6);
    }
  }
  m_pShadowCamera = this->m_IPCameraMB.m_pShadowCamera;
  frameBuffer = m_pShadowCamera->frameBuffer;
  v9 = frameBuffer->width;
  m_pShadowCamera->frameBuffer = 0;
  RwRasterDestroy(frameBuffer);
  v10 = RwRasterCreate(v9, v9, 0, 5);
  this->m_IPCameraMB.m_pShadowCamera->frameBuffer = v10;
  RwTextureSetRaster(this->m_IPCameraMB.m_pShadowTexture, v10);
  v12 = this->m_IPCameraGradient.m_pShadowCamera;
  p_m_IPCameraGradient = &this->m_IPCameraGradient;
  v13 = v12->frameBuffer;
  v14 = v13->width;
  v12->frameBuffer = 0;
  RwRasterDestroy(v13);
  v15 = RwRasterCreate(v14, v14, 0, 5);
  p_m_IPCameraGradient->m_pShadowCamera->frameBuffer = v15;
  RwTextureSetRaster(p_m_IPCameraGradient->m_pShadowTexture, v15);
  CShadowCamera::MakeGradientRaster(p_m_IPCameraGradient);
}

//----- (005B8724) --------------------------------------------------------
void __fastcall CRealTimeShadowManager::DoShadowThisFrame(CRealTimeShadowManager *this, CPhysical *pPhysical)
{
  int v3; // r2
  int v4; // r1
  CRealTimeShadow *m_pRealTimeShadow; // r2
  int v6; // r2
  CRealTimeShadow *v7; // r5
  int i; // r1
  CRealTimeShadow *v9; // r2

  v3 = 0;
  v4 = *(_BYTE *)&pPhysical->m_info & 7;
  if ( v4 == 3 && !LODWORD(pPhysical[4].m_vecCOM.y) )
    v3 = 1;
  if ( v3 || MobileSettings::settings[5].value == 2 )
  {
    m_pRealTimeShadow = pPhysical->m_pRealTimeShadow;
    if ( m_pRealTimeShadow )
    {
      m_pRealTimeShadow->m_usedThisFrame = 1;
    }
    else
    {
      v6 = 0;
      if ( v4 == 3 && !LODWORD(pPhysical[4].m_vecCOM.y) )
        v6 = 1;
      if ( this->m_initialised )
      {
        if ( v6 )
        {
          v7 = this->m_pRealTimeShadows[0];
        }
        else
        {
          v7 = 0;
          for ( i = 2; i != 41; ++i )
          {
            v9 = (CRealTimeShadow *)*((_DWORD *)&this->m_initialised + i);
            if ( !v9->m_pPhysical )
              v7 = v9;
          }
        }
        if ( v7 )
        {
          CRealTimeShadow::SetShadowedObject(v7, pPhysical);
          pPhysical->m_pRealTimeShadow = v7;
          *(_WORD *)&v7->m_usedThisFrame = 1;
        }
      }
    }
  }
}

//----- (005B87AC) --------------------------------------------------------
CRealTimeShadow *__fastcall CRealTimeShadowManager::GetRealTimeShadow(
        CRealTimeShadowManager *this,
        CPhysical *pPhysical)
{
  int v3; // r2
  int v4; // r1
  CRealTimeShadow *v5; // r5
  int i; // r1
  CRealTimeShadow *v7; // r2

  v3 = *(_BYTE *)&pPhysical->m_info & 7;
  v4 = 0;
  if ( v3 == 3 && !LODWORD(pPhysical[4].m_vecCOM.y) )
    v4 = 1;
  if ( !this->m_initialised )
    return 0;
  if ( !v4 )
  {
    v5 = 0;
    for ( i = 2; i != 41; ++i )
    {
      v7 = (CRealTimeShadow *)*((_DWORD *)&this->m_initialised + i);
      if ( !v7->m_pPhysical )
        v5 = v7;
    }
    if ( !v5 )
      return 0;
LABEL_13:
    CRealTimeShadow::SetShadowedObject(v5, pPhysical);
    pPhysical->m_pRealTimeShadow = v5;
    *(_WORD *)&v5->m_usedThisFrame = 1;
    return v5;
  }
  v5 = this->m_pRealTimeShadows[0];
  if ( v5 )
    goto LABEL_13;
  return 0;
}

//----- (005B8810) --------------------------------------------------------
void CShadows::Init()
{
  int32 TxdSlot; // r0
  int v1; // r1
  CStaticShadow *v2; // r2
  CPolyBunch **p_pNext; // r0
  int v4; // r1

  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  gpShadowCarTex = RwTextureRead((const RwChar *)"shad_car", 0);
  gpShadowPedTex = RwTextureRead((const RwChar *)"shad_ped", 0);
  gpShadowHeliTex = RwTextureRead((const RwChar *)"shad_heli", 0);
  gpShadowBikeTex = RwTextureRead((const RwChar *)"shad_bike", 0);
  gpShadowBaronTex = RwTextureRead((const RwChar *)"shad_rcbaron", 0);
  gpShadowExplosionTex = RwTextureRead((const RwChar *)"shad_exp", 0);
  gpShadowHeadLightsTex = RwTextureRead((const RwChar *)"headlight", 0);
  gpShadowHeadLightsTex2 = RwTextureRead((const RwChar *)"headlight1", 0);
  gpBloodPoolTex = RwTextureRead((const RwChar *)"bloodpool_64", 0);
  gpHandManTex = RwTextureRead((const RwChar *)"handman", 0);
  gpCrackedGlassTex = RwTextureRead((const RwChar *)"wincrack_32", 0);
  gpPostShadowTex = RwTextureRead((const RwChar *)"lamp_shad_64", 0);
  CTxdStore::PopCurrentTxd();
  *(_QWORD *)&ShadowIndexList[16] = 0x8000000060007LL;
  *(_QWORD *)&ShadowIndexList[20] = 0x8000900000007LL;
  v1 = 0;
  *(_QWORD *)ShadowIndexList = 0x100020000LL;
  *(_QWORD *)&ShadowIndexList[4] = 0x4000000020003LL;
  *(_QWORD *)&ShadowIndexList[8] = 0x4000500000003LL;
  *(_QWORD *)&ShadowIndexList[12] = 0x500060000LL;
  do
  {
    CShadows::aStaticShadows[v1].ID = 0;
    v2 = &CShadows::aStaticShadows[v1++];
    v2->pFirstBunch = 0;
  }
  while ( v1 != 48 );
  CShadows::pEmptyBunchList = CShadows::aPolyBunches;
  p_pNext = &CShadows::aPolyBunches[0].pNext;
  v4 = 359;
  do
  {
    *p_pNext = (CPolyBunch *)(p_pNext + 5);
    p_pNext += 26;
    --v4;
  }
  while ( v4 );
  CShadows::aPolyBunches[359].pNext = 0;
  CShadows::aPermanentShadows[1].Type = 0;
  CShadows::aPermanentShadows[0].Type = 0;
  CShadows::aPermanentShadows[2].Type = 0;
  CShadows::aPermanentShadows[3].Type = 0;
  CShadows::aPermanentShadows[4].Type = 0;
  CShadows::aPermanentShadows[5].Type = 0;
  CShadows::aPermanentShadows[6].Type = 0;
  CShadows::aPermanentShadows[7].Type = 0;
  CShadows::aPermanentShadows[8].Type = 0;
  CShadows::aPermanentShadows[9].Type = 0;
  CShadows::aPermanentShadows[10].Type = 0;
  CShadows::aPermanentShadows[11].Type = 0;
  CShadows::aPermanentShadows[12].Type = 0;
  CShadows::aPermanentShadows[13].Type = 0;
  CShadows::aPermanentShadows[14].Type = 0;
  CShadows::aPermanentShadows[15].Type = 0;
  CShadows::aPermanentShadows[16].Type = 0;
  CShadows::aPermanentShadows[18].Type = 0;
  CShadows::aPermanentShadows[17].Type = 0;
  CShadows::aPermanentShadows[19].Type = 0;
  CShadows::aPermanentShadows[20].Type = 0;
  CShadows::aPermanentShadows[21].Type = 0;
  CShadows::aPermanentShadows[22].Type = 0;
  CShadows::aPermanentShadows[23].Type = 0;
  CShadows::aPermanentShadows[24].Type = 0;
  CShadows::aPermanentShadows[25].Type = 0;
  CShadows::aPermanentShadows[26].Type = 0;
  CShadows::aPermanentShadows[27].Type = 0;
  CShadows::aPermanentShadows[28].Type = 0;
  CShadows::aPermanentShadows[29].Type = 0;
  CShadows::aPermanentShadows[30].Type = 0;
  CShadows::aPermanentShadows[31].Type = 0;
  CShadows::aPermanentShadows[32].Type = 0;
  CShadows::aPermanentShadows[33].Type = 0;
  CShadows::aPermanentShadows[34].Type = 0;
  CShadows::aPermanentShadows[35].Type = 0;
  CShadows::aPermanentShadows[37].Type = 0;
  CShadows::aPermanentShadows[36].Type = 0;
  CShadows::aPermanentShadows[38].Type = 0;
  CShadows::aPermanentShadows[39].Type = 0;
  CShadows::aPermanentShadows[40].Type = 0;
  CShadows::aPermanentShadows[41].Type = 0;
  CShadows::aPermanentShadows[42].Type = 0;
  CShadows::aPermanentShadows[43].Type = 0;
  CShadows::aPermanentShadows[44].Type = 0;
  CShadows::aPermanentShadows[45].Type = 0;
  CShadows::aPermanentShadows[46].Type = 0;
  CShadows::aPermanentShadows[47].Type = 0;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005B8B1C) --------------------------------------------------------
void CShadows::Shutdown()
{
  RwTextureDestroy(gpShadowCarTex);
  RwTextureDestroy(gpShadowPedTex);
  RwTextureDestroy(gpShadowHeliTex);
  RwTextureDestroy(gpShadowBikeTex);
  RwTextureDestroy(gpShadowBaronTex);
  RwTextureDestroy(gpShadowExplosionTex);
  RwTextureDestroy(gpShadowHeadLightsTex);
  RwTextureDestroy(gpShadowHeadLightsTex2);
  RwTextureDestroy(gpBloodPoolTex);
  RwTextureDestroy(gpHandManTex);
  RwTextureDestroy(gpCrackedGlassTex);
  sub_199074(gpPostShadowTex);
}
// 6784F0: using guessed type int *gpShadowCarTex_ptr;
// 679020: using guessed type int *gpShadowBikeTex_ptr[2];

//----- (005B8BE4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CShadows::AddPermanentShadow(
        UInt8 Type,
        RwTexture_0 *pTexture,
        CVector *pCoors,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        Int16 Brightness,
        UInt8 Red,
        UInt8 Green,
        UInt8 Blue,
        float ShadowDepth,
        UInt32 Duration,
        float TextureScale)
{
  UInt8 v15; // r4
  UInt8 v16; // lr
  int v17; // r3
  UInt32 v18; // r12
  UInt8 *p_Type; // r6
  int v20; // r8
  UInt32 StartTime; // r4
  int v23; // r5
  int v24; // lr
  CPermanentShadow *v25; // r3
  __int64 v26; // d16
  uint32 v27; // r0

  v16 = Blue;
  v15 = Green;
  v17 = 0;
  v18 = Duration;
  p_Type = &CShadows::aPermanentShadows[0].Type;
  do
  {
    if ( !*p_Type )
    {
      v20 = v17;
LABEL_13:
      v25 = &CShadows::aPermanentShadows[v20];
      v25->pTex = pTexture;
      v25->Type = Type;
      v26 = *(_QWORD *)&pCoors->x;
      v25->Coors.z = pCoors->z;
      v27 = CTimer::m_snTimeInMilliseconds;
      v25->Brightness = Brightness;
      v25->Red = Red;
      v25->Green = v15;
      v25->Blue = v16;
      v25->Duration = v18;
      v25->ForwardX = ForwardX;
      v25->ForwardY = ForwardY;
      v25->SideX = SideX;
      v25->SideY = SideY;
      v25->ShadowDepth = ShadowDepth;
      v25->TextureScale = TextureScale;
      *(_QWORD *)&v25->Coors.x = v26;
      v25->StartTime = v27;
      return;
    }
    v20 = v17 + 1;
    p_Type += 56;
  }
  while ( v17++ < 47 );
  StartTime = -1;
  v23 = 0;
  v24 = 0;
  do
  {
    if ( (float)((float)(CShadows::aPermanentShadows[v23].ForwardX * CShadows::aPermanentShadows[v23].ForwardX)
               + (float)(CShadows::aPermanentShadows[v23].ForwardY * CShadows::aPermanentShadows[v23].ForwardY)) < 0.25
      && (float)((float)(CShadows::aPermanentShadows[v23].SideX * CShadows::aPermanentShadows[v23].SideX)
               + (float)(CShadows::aPermanentShadows[v23].SideY * CShadows::aPermanentShadows[v23].SideY)) < 0.25
      && CShadows::aPermanentShadows[v23].StartTime < StartTime )
    {
      v20 = v24;
      StartTime = CShadows::aPermanentShadows[v23].StartTime;
    }
    ++v23;
    ++v24;
  }
  while ( v23 != 48 );
  v18 = Duration;
  v16 = Blue;
  v15 = Green;
  if ( v20 <= 47 )
    goto LABEL_13;
}
// 5B8BE4: variables would overlap: ^3C.1 and ^3C.8

//----- (005B8D38) --------------------------------------------------------
bool __fastcall CShadows::StoreStaticShadow(
        u_native ID,
        UInt8 Type,
        RwTexture_0 *pTexture,
        CVector *pCoors,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        __int64 Brightness,
        __int64 Green,
        float ShadowDepth,
        float TextureScale,
        float MaxDist,
        bool bFromTree,
        float Margin)
{
  float x; // s14
  float y; // s12
  CSimpleTransform *p_tx; // r4
  float v18; // s2
  unsigned int v19; // r9
  unsigned int v20; // r12
  unsigned int v21; // r10
  int v22; // r11
  float v23; // s2
  float v24; // s0
  int v25; // lr
  bool *p_bFromTree; // r5
  int v27; // r8
  float v29; // s14
  _BOOL4 result; // r0
  uint32 v31; // r1
  CPolyBunch *v32; // r12
  int v33; // r6
  CStaticShadow *v34; // r5
  __int64 v35; // d16
  RwReal z; // r0
  uint32 v37; // r0
  UInt8 v38; // [sp+0h] [bp-20h]

  x = pCoors->x;
  y = pCoors->y;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v18 = (float)((float)(x - p_tx->m_translate.x) * (float)(x - p_tx->m_translate.x))
      + (float)((float)(y - p_tx->m_translate.y) * (float)(y - p_tx->m_translate.y));
  if ( MaxDist != 0.0 && v18 >= (float)(MaxDist * MaxDist) )
    return 1;
  LOBYTE(v20) = BYTE4(Green);
  LOBYTE(v19) = Green;
  LOBYTE(v21) = BYTE4(Brightness);
  LOWORD(v22) = Brightness;
  if ( MaxDist != 0.0 )
  {
    v23 = sqrtf(v18);
    if ( v23 >= (float)(MaxDist * 0.75) )
    {
      v24 = (float)((float)(-4.0 / MaxDist) * (float)(v23 - (float)(MaxDist * 0.75))) + 1.0;
      v20 = (unsigned int)(float)(v24 * (float)HIDWORD(Green));
      v19 = (unsigned int)(float)(v24 * (float)(unsigned int)Green);
      v21 = (unsigned int)(float)(v24 * (float)HIDWORD(Brightness));
      v22 = (int)(float)(v24 * (float)(int)Brightness);
    }
  }
  v25 = 0;
  p_bFromTree = &CShadows::aStaticShadows[0].bFromTree;
  v38 = v20;
  while ( 1 )
  {
    if ( *((_DWORD *)p_bFromTree - 15) == ID )
    {
      v27 = *((_DWORD *)p_bFromTree - 14);
      if ( v27 )
        break;
    }
    p_bFromTree += 64;
    if ( v25++ >= 47 )
    {
      LOWORD(v25) = 0;
      while ( CShadows::aStaticShadows[(__int16)v25].pFirstBunch )
      {
        v25 = (__int16)(v25 + 1);
        if ( v25 >= 48 )
        {
          if ( v25 != 48 )
            goto LABEL_28;
          return 1;
        }
      }
      goto LABEL_28;
    }
  }
  v29 = fabsf(x - *((float *)p_bFromTree - 12));
  if ( v29 < Margin && fabsf(y - *((float *)p_bFromTree - 11)) < Margin
    || v29 < 0.05
    && fabsf(y - *((float *)p_bFromTree - 11)) < 0.05
    && fabsf(pCoors->z - *((float *)p_bFromTree - 10)) < 2.0
    && *((float *)p_bFromTree - 9) == ForwardX
    && *((float *)p_bFromTree - 7) == SideX )
  {
    result = 1;
    *(p_bFromTree - 6) = Type;
    *(p_bFromTree - 2) = 1;
    *((_DWORD *)p_bFromTree - 3) = pTexture;
    *((_WORD *)p_bFromTree - 4) = v22;
    v31 = CTimer::m_snTimeInMilliseconds;
    *(p_bFromTree - 5) = v21;
    *(p_bFromTree - 4) = v19;
    *(p_bFromTree - 3) = v20;
    *((float *)p_bFromTree - 5) = ShadowDepth;
    *((float *)p_bFromTree - 4) = TextureScale;
    *p_bFromTree = bFromTree;
    *((_DWORD *)p_bFromTree - 13) = v31;
    return result;
  }
  v32 = CShadows::pEmptyBunchList;
  CShadows::pEmptyBunchList = (CPolyBunch *)*((_DWORD *)p_bFromTree - 14);
  do
  {
    v33 = v27;
    v27 = *(_DWORD *)(v27 + 84);
  }
  while ( v27 );
  *(_DWORD *)(v33 + 84) = v32;
  *((_DWORD *)p_bFromTree - 15) = 0;
  *((_DWORD *)p_bFromTree - 14) = 0;
LABEL_28:
  CShadows::aStaticShadows[(__int16)v25].ID = ID;
  v34 = &CShadows::aStaticShadows[(__int16)v25];
  v34->Type = Type;
  v34->pTex = pTexture;
  v34->Brightness = v22;
  v34->Red = v21;
  v34->Green = v19;
  v34->Blue = v38;
  v34->ShadowDepth = ShadowDepth;
  v34->TextureScale = TextureScale;
  v35 = *(_QWORD *)&pCoors->x;
  z = pCoors->z;
  v34->UpdatedThisFrame = 1;
  v34->bFromTree = bFromTree;
  v34->ForwardX = ForwardX;
  v34->ForwardY = ForwardY;
  v34->SideX = SideX;
  v34->SideY = SideY;
  v34->Coors.z = z;
  v37 = CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)&v34->Coors.x = v35;
  v34->TimeAdded = v37;
  CShadows::GeneratePolysForStaticShadow(v25);
  return v34->pFirstBunch != 0;
}

//----- (005B9044) --------------------------------------------------------
void __fastcall CStaticShadow::Free(CStaticShadow *this)
{
  CPolyBunch *pFirstBunch; // r1
  CPolyBunch *v2; // r2
  CPolyBunch *v3; // r3

  pFirstBunch = this->pFirstBunch;
  if ( pFirstBunch )
  {
    v2 = CShadows::pEmptyBunchList;
    CShadows::pEmptyBunchList = this->pFirstBunch;
    do
    {
      v3 = pFirstBunch;
      pFirstBunch = pFirstBunch->pNext;
    }
    while ( pFirstBunch );
    v3->pNext = v2;
  }
  this->ID = 0;
  this->pFirstBunch = 0;
}

//----- (005B9068) --------------------------------------------------------
void __fastcall CShadows::GeneratePolysForStaticShadow(Int16 ShadowNum)
{
  int v1; // r8
  CStaticShadow *v2; // r4
  float v3; // s0
  float v4; // s4
  float ForwardY; // s2
  float v6; // s0
  float v7; // s2
  float v8; // s18
  float v9; // s22
  float v10; // s20
  float v11; // s16
  float v12; // r5
  float v13; // s24
  float v14; // s26
  float v15; // r0
  int v16; // r10
  int v17; // r1
  int v18; // r0
  int v19; // r0
  uint16 v20; // r0
  float *p_SideY; // r5
  float *p_ForwardY; // r6
  float *p_SideX; // r12
  float *p_ForwardX; // lr
  CStaticShadow *v25; // r0
  CPolyBunch **ppBunch; // r11
  UInt8 *p_lightingMult; // r9
  float *p_TextureScale; // r2
  float *p_ShadowDepth; // r4
  int v30; // r0
  int v31; // r8
  float v32; // s8
  int v33; // r4
  float *v34; // r10
  int v35; // r0
  bool v36; // cc
  int v37; // r0
  int v38; // [sp+3Ch] [bp-94h]
  int v39; // [sp+40h] [bp-90h]
  int v40; // [sp+44h] [bp-8Ch]
  float *v41; // [sp+58h] [bp-78h]
  float *v42; // [sp+5Ch] [bp-74h]
  CPolyBunch **p_pFirstBunch; // [sp+60h] [bp-70h]
  int v44; // [sp+64h] [bp-6Ch]
  CVector pShadowPos; // [sp+68h] [bp-68h] BYREF

  v1 = ShadowNum;
  v2 = &CShadows::aStaticShadows[ShadowNum];
  v3 = fabsf(v2->ForwardX);
  v4 = fabsf(v2->SideX);
  ForwardY = v2->ForwardY;
  *(_QWORD *)&pShadowPos.x = *(_QWORD *)&v2->Coors.x;
  v6 = v3 + v4;
  v7 = fabsf(ForwardY) + fabsf(v2->SideY);
  v8 = pShadowPos.x - v6;
  v9 = v6 + pShadowPos.x;
  v10 = pShadowPos.y - v7;
  v11 = v7 + pShadowPos.y;
  v12 = floorf((float)((float)(pShadowPos.x - v6) / 50.0) + 60.0);
  v13 = floorf((float)((float)(pShadowPos.y - v7) / 50.0) + 60.0);
  v14 = floorf((float)((float)(v6 + pShadowPos.x) / 50.0) + 60.0);
  v15 = floorf((float)((float)(v7 + pShadowPos.y) / 50.0) + 60.0);
  pShadowPos.z = v2->Coors.z;
  v16 = 119;
  v17 = 0;
  v18 = (int)v15;
  if ( v18 >= 119 )
    v18 = 119;
  v38 = v18;
  if ( (int)v14 < 119 )
    v16 = (int)v14;
  v19 = (int)v13;
  if ( (int)v13 <= 0 )
    v19 = 0;
  v40 = v19;
  if ( (int)v12 > 0 )
    v17 = (int)v12;
  v39 = v17;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v20 = 1;
  }
  else
  {
    v20 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v20;
  if ( v40 <= v38 )
  {
    p_SideY = &v2->SideY;
    p_ForwardY = &v2->ForwardY;
    p_SideX = &v2->SideX;
    p_ForwardX = &v2->ForwardX;
    v25 = &CShadows::aStaticShadows[v1];
    ppBunch = &v25->pFirstBunch;
    p_lightingMult = &v25->lightingMult;
    p_TextureScale = &v25->TextureScale;
    p_ShadowDepth = &v25->ShadowDepth;
    p_pFirstBunch = &v25->pFirstBunch;
    v41 = &v25->ShadowDepth;
    v42 = &v25->TextureScale;
    do
    {
      if ( v39 <= v16 )
      {
        v30 = 119;
        if ( v40 < 119 )
          v30 = v40;
        v31 = v39;
        v44 = 120 * v30;
        do
        {
          v32 = *p_ShadowDepth;
          v33 = v16;
          v34 = p_SideX;
          v35 = 119;
          if ( v31 < 119 )
            v35 = v31;
          CShadows::CastShadowSectorList(
            &CWorld::ms_aSectors[v35 + v44].m_buildingPtrListArray,
            v8,
            v10,
            v9,
            v11,
            &pShadowPos,
            *p_ForwardX,
            *p_ForwardY,
            *p_SideX,
            *p_SideY,
            0,
            0,
            0,
            0,
            v32,
            *p_TextureScale,
            ppBunch,
            p_lightingMult,
            0);
          p_SideX = v34;
          v16 = v33;
          p_ShadowDepth = v41;
          p_TextureScale = v42;
          v36 = v31 < v16;
          ppBunch = p_pFirstBunch;
          ++v31;
        }
        while ( v36 );
      }
      v37 = v40++;
    }
    while ( v37 < v38 );
  }
}

//----- (005B92D0) --------------------------------------------------------
void __fastcall CShadows::StoreShadowToBeRendered(
        int Type,
        CVector *pCoors,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        Int16 Brightness,
        UInt8 Red,
        UInt8 Green,
        UInt8 Blue)
{
  UInt16 v12; // r2
  CStoredShadow *v13; // r3
  RwTexture_0 **v14; // r5
  RwTexture_0 **v15; // r5
  char v16; // r5
  RwReal z; // r5
  __int64 v18; // d16
  char v19; // r1

  switch ( Type )
  {
    case 1:
      v12 = CShadows::ShadowsStoredToBeRendered;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v13 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v14 = &gpShadowCarTex;
        goto LABEL_15;
      }
      break;
    case 2:
      v12 = CShadows::ShadowsStoredToBeRendered;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v13 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v14 = &gpShadowPedTex;
        goto LABEL_15;
      }
      break;
    case 3:
      v12 = CShadows::ShadowsStoredToBeRendered;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v13 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v15 = &gpShadowExplosionTex;
        goto LABEL_12;
      }
      break;
    case 4:
      v12 = CShadows::ShadowsStoredToBeRendered;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v13 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v14 = &gpShadowHeliTex;
        goto LABEL_15;
      }
      break;
    case 5:
      v12 = CShadows::ShadowsStoredToBeRendered;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v13 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v15 = &gpShadowHeadLightsTex;
LABEL_12:
        v13->pTex = *v15;
        v16 = 2;
        goto LABEL_16;
      }
      break;
    case 6:
      v12 = CShadows::ShadowsStoredToBeRendered;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v13 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v14 = &gpBloodPoolTex;
LABEL_15:
        v13->pTex = *v14;
        v16 = 1;
LABEL_16:
        v13->Type = v16;
        z = pCoors->z;
        v18 = *(_QWORD *)&pCoors->x;
        v19 = *((_BYTE *)v13 + 50);
        v13->Coors.z = z;
        v13->ForwardX = ForwardX;
        v13->ForwardY = ForwardY;
        v13->SideX = SideX;
        v13->SideY = SideY;
        v13->Brightness = Brightness;
        v13->Red = Red;
        v13->Green = Green;
        v13->Blue = Blue;
        v13->ShadowDepth = 15.0;
        *((_BYTE *)v13 + 50) = v19 & 0xFA;
        v13->TextureScale = 1.0;
        v13->pRealTimeShadow = 0;
        *(_QWORD *)&v13->Coors.x = v18;
        CShadows::ShadowsStoredToBeRendered = v12 + 1;
      }
      break;
    default:
      return;
  }
}

//----- (005B94A0) --------------------------------------------------------
void __fastcall CShadows::StoreShadowToBeRendered(
        UInt8 Type,
        RwTexture_0 *pTexture,
        CVector *pCoors,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        Int16 Brightness,
        UInt8 Red,
        UInt8 Green,
        UInt8 Blue,
        float ShadowDepth,
        bool OnWater,
        float TextureScale,
        CRealTimeShadow *pRealTimeShadow,
        bool bIsPlayer)
{
  UInt16 v16; // r12
  CStoredShadow *v17; // r4
  char v18; // r1
  __int64 v19; // d16

  v16 = CShadows::ShadowsStoredToBeRendered;
  if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
  {
    v17 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
    v17->pTex = pTexture;
    v17->Type = Type;
    v18 = *((_BYTE *)v17 + 50);
    v19 = *(_QWORD *)&pCoors->x;
    v17->Coors.z = pCoors->z;
    v17->Brightness = Brightness;
    v17->Red = Red;
    v17->Green = Green;
    v17->Blue = Blue;
    v17->ForwardX = ForwardX;
    v17->ForwardY = ForwardY;
    v17->SideX = SideX;
    v17->SideY = SideY;
    v17->ShadowDepth = ShadowDepth;
    v17->TextureScale = TextureScale;
    v17->pRealTimeShadow = pRealTimeShadow;
    *(_QWORD *)&v17->Coors.x = v19;
    *((_BYTE *)v17 + 50) = v18 & 0xFA | OnWater | (4 * bIsPlayer);
    CShadows::ShadowsStoredToBeRendered = v16 + 1;
  }
}

//----- (005B955C) --------------------------------------------------------
bool __fastcall UseAdvancedShadows(int32 type)
{
  _BOOL4 v1; // r0

  if ( MobileSettings::settings[5].value == 2 && (unsigned int)type <= 0xB )
    return (0xE03u >> type) & 1;
  else
    LOBYTE(v1) = 0;
  return v1;
}

//----- (005B958C) --------------------------------------------------------
void __fastcall CShadows::StoreShadowForVehicle(CVehicle *pVehicle, VEH_SHD_TYPE VehicleShadowType)
{
  int v4; // r9
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  RwTexture_0 *v7; // r8
  __int64 v8; // d16
  CSimpleTransform *p_m_transform; // r1
  float v10; // s0
  int *v11; // r1
  float v12; // s2
  float v13; // s0
  int m_nModelIndex; // r4
  CColModel *ColModel; // r0
  float v16; // s2
  float y; // s0
  float v18; // s18
  float v19; // s16
  float v20; // s6
  unsigned int m_vehicleType; // r0
  CMatrix *v22; // r0
  float v23; // s0
  RwReal v24; // s2
  RwReal v25; // s0
  int v26; // s20
  RwTexture_0 *v27; // r0
  int **v28; // r0
  float v29; // s0
  float v30; // s2
  RwTexture_0 **v31; // r0
  CMatrix *v32; // r1
  float xz; // r4
  float xy; // t1
  float yx; // r10
  float x; // r8
  float v37; // s24
  float v38; // s2
  CMatrix *v39; // r0
  float zz; // s0
  float yz; // r11
  int v42; // r6
  CVehicle *PlayerVehicle; // r0
  float v44; // s8
  float v45; // s6
  int v46; // r6
  float v47; // s0
  float v48; // s6
  float v49; // s8
  UInt16 v50; // r0
  float v51; // s2
  float v52; // s4
  __int64 v53; // d16
  CStoredShadow *v54; // r1
  char v55; // r5
  __int64 Brightness; // [sp+10h] [bp-98h]
  __int64 Green; // [sp+18h] [bp-90h]
  RwTexture_0 *pTexture; // [sp+34h] [bp-74h]
  CVector v59; // [sp+38h] [bp-70h] BYREF
  CVector v2; // [sp+44h] [bp-64h] BYREF
  CVector pCoors; // [sp+50h] [bp-58h] BYREF

  LOWORD(v4) = CTimeCycle::m_CurrentColours.m_nShadowStrength;
  if ( !CTimeCycle::m_CurrentColours.m_nShadowStrength )
    return;
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  v7 = gpShadowCarTex;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  v8 = *(_QWORD *)&p_tx->m_translate.x;
  pCoors.z = p_tx->m_translate.z;
  *(_QWORD *)&pCoors.x = v8;
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  v10 = (float)((float)(*(float *)&v8 - p_m_transform->m_translate.x)
              * (float)(*(float *)&v8 - p_m_transform->m_translate.x))
      + (float)((float)(*((float *)&v8 + 1) - p_m_transform->m_translate.y)
              * (float)(*((float *)&v8 + 1) - p_m_transform->m_translate.y));
  if ( CCutsceneMgr::ms_running )
    v10 = v10 / (float)((float)(TheCamera.LODDistMultiplier * TheCamera.LODDistMultiplier) * 4.0);
  if ( (unsigned int)(VehicleShadowType - 3) < 2 || VehicleShadowType == VEHICLE_SHADOW_HELI )
  {
    v11 = dword_5B9CD4;
LABEL_13:
    if ( MobileSettings::settings[5].value == 2 )
      ++v11;
    v12 = *(float *)v11;
    if ( v10 < (float)(v12 * v12) )
    {
LABEL_16:
      v13 = sqrtf(v10);
      if ( v13 >= (float)(v12 * 0.75) )
        v4 = (int)(float)((float)((float)((float)(v13 - (float)(v12 * 0.75)) / (float)(v12 * -0.25)) + 1.0)
                        * (float)CTimeCycle::m_CurrentColours.m_nShadowStrength);
      m_nModelIndex = pVehicle->m_nModelIndex;
      ColModel = CEntity::GetColModel(pVehicle);
      v16 = 1.0;
      y = ColModel->m_boxBound.m_vecMax.y;
      v18 = ColModel->m_boxBound.m_vecMax.x - ColModel->m_boxBound.m_vecMin.x;
      v19 = y - ColModel->m_boxBound.m_vecMin.y;
      switch ( m_nModelIndex )
      {
        case 417:
        case 425:
        case 447:
        case 469:
        case 487:
        case 497:
          v16 = 0.5;
          v19 = v19 * 1.4;
          v18 = v18 * 3.0;
          goto LABEL_30;
        case 448:
        case 461:
        case 462:
        case 481:
        case 509:
        case 510:
        case 521:
        case 522:
          v19 = v19 * 1.2;
          v16 = 0.05;
          goto LABEL_30;
        case 463:
        case 468:
        case 523:
          v19 = v19 * 1.5;
          v16 = 0.03;
          goto LABEL_30;
        case 465:
        case 501:
          v18 = v18 + v18;
          v19 = v19 * 1.5;
          v16 = 0.2;
          goto LABEL_30;
        case 539:
          return;
        default:
LABEL_30:
          v22 = pVehicle->m_pMat;
          v23 = v16 * (float)((float)(v19 * 0.5) - y);
          v24 = *(float *)&v8 - (float)(v22->xy * v23);
          v25 = *((float *)&v8 + 1) - (float)(v23 * v22->yy);
          v26 = 4.5;
          pCoors.x = v24;
          pCoors.y = v25;
          switch ( VehicleShadowType )
          {
            case VEHICLE_SHADOW_CAR:
              v28 = &gpShadowCarTex_ptr;
              goto LABEL_38;
            case VEHICLE_SHADOW_BIKE:
              v29 = (float)(fabsf(pVehicle[1].m_vecCOM.x) * 5.093) + 1.0;
              if ( (*(_BYTE *)&pVehicle->m_info & 0xF8) == 32 )
              {
                v30 = fabsf(v22->zx);
                if ( v30 > 0.6 )
                  v29 = v29 + (float)(v30 * 4.0);
              }
              v18 = v18 * v29;
              v28 = gpShadowBikeTex_ptr;
LABEL_38:
              v31 = (RwTexture_0 **)*v28;
              goto LABEL_44;
            case VEHICLE_SHADOW_HELI:
              v27 = gpShadowHeliTex;
              goto LABEL_40;
            case VEHICLE_SHADOW_PLANE:
            case VEHICLE_SHADOW_HUGEPLANE:
              LOWORD(v4) = CTimeCycle::m_CurrentColours.m_nShadowStrength;
              v27 = gpShadowBaronTex;
LABEL_40:
              pTexture = v27;
              v26 = 4.5;
              if ( FindPlayerVehicle(-1, 0) == pVehicle )
                v26 = 1112014848;
              break;
            case VEHICLE_SHADOW_RCBARON:
              v18 = v18 * 2.2;
              v31 = &gpShadowBaronTex;
              v19 = v19 * 1.5;
LABEL_44:
              pTexture = *v31;
              break;
            default:
              pTexture = v7;
              break;
          }
          v32 = pVehicle->m_pMat;
          xy = v32->xy;
          v32 = (CMatrix *)((char *)v32 + 16);
          xz = xy;
          yx = v32->yx;
          v2.x = 0.0;
          v2.y = 0.0;
          v2.z = 1.0;
          CrossProduct(&v59, (const CVector *)v32, &v2);
          x = v59.x;
          v37 = v59.y;
          v38 = sqrtf((float)(v59.x * v59.x) + (float)(v37 * v37));
          if ( v38 < 0.5 )
          {
            v37 = (float)(v59.y / v38) * 0.5;
            x = (float)(v59.x / v38) * 0.5;
          }
          v39 = pVehicle->m_pMat;
          zz = v39->zz;
          if ( zz < 0.0 )
          {
            v37 = -v37;
            LODWORD(x) ^= 0x80000000;
          }
          yz = v37;
          if ( VehicleShadowType == VEHICLE_SHADOW_HELI )
          {
            if ( fabsf(v39->zx) > 0.57 )
            {
              yz = v39->yz;
              x = v39->xz;
              v37 = yz;
            }
            if ( fabsf(v39->zy) > 0.57 )
            {
              yx = v39->yz;
              xz = v39->xz;
            }
          }
          else if ( VehicleShadowType == VEHICLE_SHADOW_BIKE && fabsf(v39->zx) > 0.6 )
          {
            yz = v39->yz;
            x = v39->xz;
            v37 = yz;
          }
          v42 = 0;
          if ( *((unsigned __int8 *)&pVehicle->m_nVehicleFlags + 4) >> 7 )
          {
            LOBYTE(v42) = 1;
          }
          else
          {
            PlayerVehicle = FindPlayerVehicle(-1, 0);
            zz = pVehicle->m_pMat->zz;
            if ( PlayerVehicle == pVehicle )
              v42 = 1;
            if ( !v42
              && (float)(CTimer::ms_fTimeStep
                       * sqrtf(
                           (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                                 + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                         + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z))) <= 0.1 )
            {
              v44 = v18 * 0.5;
              v45 = (float)(v18 * 0.5) * x;
              if ( zz <= 0.0 )
              {
                v47 = -(float)(v44 * v37);
                v45 = -v45;
                v46 = (unsigned __int8)v4;
              }
              else
              {
                v46 = (unsigned __int8)v4;
                v47 = v44 * yz;
              }
              LODWORD(Brightness) = (__int16)v4;
              HIDWORD(Brightness) = v46;
              LODWORD(Green) = v46;
              HIDWORD(Green) = v46;
              CShadows::StoreStaticShadow(
                (u_native)&pVehicle->_vptr$CPlaceable + 1,
                1u,
                pTexture,
                &pCoors,
                (float)(v19 * 0.5) * xz,
                (float)(v19 * 0.5) * yx,
                v45,
                v47,
                Brightness,
                Green,
                4.5,
                1.0,
                0.0,
                0,
                0.1);
              return;
            }
          }
          v48 = v18 * 0.5;
          v49 = (float)(v18 * 0.5) * x;
          v50 = CShadows::ShadowsStoredToBeRendered;
          v51 = (float)(v19 * 0.5) * yx;
          v52 = (float)(v19 * 0.5) * xz;
          if ( zz <= 0.0 )
          {
            if ( CShadows::ShadowsStoredToBeRendered > 0x2Fu )
              return;
            v53 = *(_QWORD *)&pCoors.x;
            v54 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
            v54->pTex = pTexture;
            v54->Type = 1;
            v55 = *((_BYTE *)v54 + 50);
            v54->Coors.z = pCoors.z;
            v54->Brightness = v4;
            v54->Red = v4;
            v54->Green = v4;
            v54->Blue = v4;
            v54->ForwardX = v52;
            v54->ForwardY = v51;
            v54->SideX = -v49;
            v54->SideY = -(float)(v48 * yz);
          }
          else
          {
            if ( CShadows::ShadowsStoredToBeRendered > 0x2Fu )
              return;
            v53 = *(_QWORD *)&pCoors.x;
            v54 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
            v54->pTex = pTexture;
            v54->Type = 1;
            v55 = *((_BYTE *)v54 + 50);
            v54->Coors.z = pCoors.z;
            v54->Brightness = v4;
            v54->Red = v4;
            v54->Green = v4;
            v54->Blue = v4;
            v54->ForwardX = v52;
            v54->ForwardY = v51;
            v54->SideX = v49;
            v54->SideY = v48 * yz;
          }
          LODWORD(v54->ShadowDepth) = v26;
          v54->TextureScale = 1.0;
          v54->pRealTimeShadow = 0;
          *(_QWORD *)&v54->Coors.x = v53;
          *((_BYTE *)v54 + 50) = v55 & 0xFA | v42 | (4 * v42);
          CShadows::ShadowsStoredToBeRendered = v50 + 1;
          break;
      }
      return;
    }
    return;
  }
  if ( VehicleShadowType == VEHICLE_SHADOW_HUGEPLANE )
  {
    v11 = dword_5B9CE0;
    goto LABEL_13;
  }
  v12 = 18.0;
  v20 = 18.0;
  if ( MobileSettings::settings[5].value == 2 )
    v20 = 32.0;
  if ( v10 < (float)(v20 * v20) )
  {
    if ( MobileSettings::settings[5].value == 2 )
    {
      m_vehicleType = pVehicle->m_vehicleType;
      if ( m_vehicleType > 0xB )
      {
        v12 = 32.0;
      }
      else
      {
        v12 = 32.0;
        if ( ((1 << m_vehicleType) & 0xE03) != 0 )
        {
          CRealTimeShadowManager::DoShadowThisFrame(&g_realTimeShadowMan, pVehicle);
          return;
        }
      }
    }
    goto LABEL_16;
  }
}
// 5B9CD4: using guessed type int dword_5B9CD4[2];
// 5B9CE0: using guessed type int dword_5B9CE0[2];
// 6784F0: using guessed type int *gpShadowCarTex_ptr;
// 679020: using guessed type int *gpShadowBikeTex_ptr[2];

//----- (005B9D38) --------------------------------------------------------
void __fastcall CShadows::StoreCarLightShadow(
        CVehicle *pCar,
        Int32 ID,
        RwTexture_0 *pTexture,
        CVector *pShadowPos,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        __int64 Red,
        int Blue,
        float Radius)
{
  int Mode; // r0
  bool v16; // zf
  bool v17; // zf
  CSimpleTransform *p_tx; // r2
  unsigned __int64 v19; // d1
  __int128 v20; // [sp+10h] [bp-40h]

  Mode = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
  v16 = Mode == 1;
  if ( Mode != 1 )
    v16 = Mode == 37;
  if ( v16 )
    goto LABEL_7;
  v17 = !CCutsceneMgr::ms_running;
  if ( !CCutsceneMgr::ms_running )
    v17 = pCar->m_baseVehicleType == 9;
  if ( !v17
    || FindPlayerVehicle(-1, 0) == pCar
    && FindPlayerPed(-1)
    && pCar[1].m_VehicleAudioEntity.ScratchSound.m_fDistanceFromCameraLastFrame != 0.0 )
  {
LABEL_7:
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v19 = vmul_f32(
            vsub_f32(*(float32x2_t *)&pShadowPos->x, *(float32x2_t *)&p_tx->m_translate.x),
            *(float32x2_t *)&TheCamera.CamFrontXNorm).n64_u64[0];
    if ( (float)(*(float *)&v19 + *((float *)&v19 + 1)) > (float)-Radius )
    {
      LODWORD(v20) = 128;
      *(_QWORD *)((char *)&v20 + 4) = Red;
      HIDWORD(v20) = Blue;
      CShadows::StoreStaticShadow(
        (u_native)pCar + ID,
        2u,
        pTexture,
        pShadowPos,
        ForwardX,
        ForwardY,
        SideX,
        SideY,
        v20,
        *((__int64 *)&v20 + 1),
        6.0,
        1.0,
        0.0,
        0,
        0.05);
    }
  }
}

//----- (005B9E68) --------------------------------------------------------
void __fastcall CShadows::StoreShadowForPedObject(
        CEntity *pPed,
        float ShadowDisplacementX,
        float ShadowDisplacementY,
        float ShadowFrontX,
        float ShadowFrontY,
        float ShadowSideX,
        float ShadowSideY)
{
  CSimpleTransform *p_tx; // r2
  float32x2_t v12; // d16
  unsigned __int64 v13; // d0
  CPlayerPed *PlayerPed; // r8
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r1
  float v17; // s0
  int v18; // r0
  float v19; // s6
  float v20; // s0
  float v21; // s10
  float v22; // s2
  float v23; // s4
  float v24; // s12
  UInt16 v25; // r1
  __int64 v26; // d16
  CStoredShadow *v27; // r2
  char v28; // r5
  char v29; // r0
  RwV3d_0 v30; // [sp+0h] [bp-30h] BYREF

  CPed::GetBonePosition((CPed *)pPed, &v30, 0, 0);
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&v30.x, *(float32x2_t *)&p_tx->m_translate.x).n64_u64[0];
  v13 = vmul_f32(v12, v12).n64_u64[0];
  if ( (float)(*(float *)&v13 + *((float *)&v13 + 1)) < MAX_DISTANCE_PED_SHADOWS_SQR )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed == pPed )
      goto LABEL_8;
    m_pMat = pPed->m_pMat;
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_m_transform = &pPed->m_transform;
    if ( CCamera::IsSphereVisible(&TheCamera, &p_m_transform->m_translate, 2.0) )
    {
LABEL_8:
      v17 = sqrtf(*(float *)&v13 + *((float *)&v13 + 1));
      LOWORD(v18) = CTimeCycle::m_CurrentColours.m_nShadowStrength;
      if ( v17 >= (float)(MAX_DISTANCE_PED_SHADOWS * 0.5) )
        v18 = (int)(float)((float)(1.0
                                 - (float)((float)(v17 - (float)(MAX_DISTANCE_PED_SHADOWS * 0.5))
                                         / (float)(MAX_DISTANCE_PED_SHADOWS * 0.5)))
                         * (float)CTimeCycle::m_CurrentColours.m_nShadowStrength);
      v19 = ShadowFrontX;
      v20 = ShadowSideY;
      v21 = ShadowDisplacementY;
      v22 = ShadowSideX;
      v23 = ShadowFrontY;
      v24 = ShadowDisplacementX;
      if ( CGame::currArea )
      {
        v21 = ShadowDisplacementY * 0.5;
        v24 = ShadowDisplacementX * 0.5;
        v20 = ShadowSideY * 0.75;
        v22 = ShadowSideX * 0.75;
        v23 = ShadowFrontY * 0.75;
        v19 = ShadowFrontX * 0.75;
        v18 = (int)(float)((float)(__int16)v18 * 0.65);
      }
      v25 = CShadows::ShadowsStoredToBeRendered;
      v30.x = v24 + v30.x;
      v30.y = v21 + v30.y;
      if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
      {
        v26 = *(_QWORD *)&v30.x;
        v27 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
        v27->pTex = gpShadowPedTex;
        v27->Type = 1;
        v28 = *((_BYTE *)v27 + 50);
        v27->Coors.z = v30.z;
        v27->ForwardX = v19;
        v27->ForwardY = v23;
        v27->SideX = v22;
        v27->SideY = v20;
        v27->Brightness = v18;
        v27->Red = v18;
        v27->Green = v18;
        v27->Blue = v18;
        v27->ShadowDepth = 4.0;
        v27->TextureScale = 1.0;
        v29 = 0;
        v27->pRealTimeShadow = 0;
        *(_QWORD *)&v27->Coors.x = v26;
        if ( PlayerPed == pPed )
          v29 = 1;
        *((_BYTE *)v27 + 50) = v28 & 0xFA | (4 * v29);
        CShadows::ShadowsStoredToBeRendered = v25 + 1;
      }
    }
  }
}

//----- (005BA070) --------------------------------------------------------
int __fastcall CShadows::StoreRealTimeShadow(
        CPhysical *pPhysical,
        float ShadowDisplacementX,
        float ShadowDisplacementY,
        float ShadowFrontX,
        float ShadowFrontY,
        float ShadowSideX,
        float ShadowSideY)
{
  CRealTimeShadow *m_pRealTimeShadow; // r9
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v11; // d16
  float z; // s16
  float v13; // s0
  float x; // s16
  float y; // s18
  CSimpleTransform *p_m_transform; // r2
  float v17; // s20
  float v18; // s22
  float v19; // s0
  int v20; // r0
  float v21; // s0
  float v22; // s18
  float v23; // s20
  RwTexture_0 *ShadowRwTexture; // r8
  CVector *v25; // r0
  float v26; // s6
  float v27; // s8
  float v28; // s2
  float v29; // s0
  int v30; // s18
  float v31; // s20
  float v32; // s4
  float v34; // r4
  float v35; // r0
  RwFrame_0 *v36; // r0
  __int64 v37; // d16
  float v38; // s4
  float v39; // s0
  float v40; // s8
  float v41; // s6
  CStoredShadow *v42; // r2
  __int64 v43; // d16
  UInt16 v44; // r0
  char v45; // r6
  float v46; // s8
  float v47; // s10
  CVector v48; // [sp+0h] [bp-58h] BYREF
  RwV3d_0 posn; // [sp+10h] [bp-48h] BYREF

  m_pRealTimeShadow = pPhysical->m_pRealTimeShadow;
  if ( !m_pRealTimeShadow )
    return 0;
  m_pMat = pPhysical->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPhysical->m_transform;
  v11 = *(_QWORD *)&p_tx->m_translate.x;
  posn.z = p_tx->m_translate.z;
  *(_QWORD *)&posn.x = v11;
  if ( (*(_BYTE *)&pPhysical->m_info & 7) == 3 )
  {
    z = posn.z;
    CPed::GetBonePosition((CPed *)pPhysical, &posn, 0, 0);
    v13 = posn.z;
    if ( z > posn.z )
    {
      posn.z = z;
      v13 = z;
    }
    posn.z = v13 + -0.85;
  }
  x = posn.x;
  y = posn.y;
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  v17 = p_m_transform->m_translate.x;
  v18 = p_m_transform->m_translate.y;
  if ( FindPlayerPed(-1) != pPhysical )
  {
    v19 = 2.0;
    if ( MobileSettings::settings[5].value == 2 )
      v19 = 6.0;
    if ( !CCamera::IsSphereVisible(&TheCamera, (const CVector *)&posn, v19) )
      return 0;
  }
  LOWORD(v20) = CTimeCycle::m_CurrentColours.m_nShadowStrength;
  v21 = sqrtf((float)((float)(x - v17) * (float)(x - v17)) + (float)((float)(y - v18) * (float)(y - v18)));
  if ( v21 >= (float)(MAX_DISTANCE_PED_SHADOWS * 0.5) )
    v20 = (int)(float)((float)(1.0
                             - (float)((float)(v21 - (float)(MAX_DISTANCE_PED_SHADOWS * 0.5))
                                     / (float)(MAX_DISTANCE_PED_SHADOWS * 0.5)))
                     * (float)CTimeCycle::m_CurrentColours.m_nShadowStrength);
  v22 = (float)m_pRealTimeShadow->m_fadeVal / 100.0;
  v23 = (float)(__int16)v20;
  ShadowRwTexture = CRealTimeShadow::GetShadowRwTexture(m_pRealTimeShadow);
  v25 = &CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue];
  v26 = v25->y;
  v27 = v25->z;
  v28 = -v25->x;
  v29 = -v26;
  v30 = (int)(float)(v22 * v23);
  if ( v27 >= 0.75 )
  {
    v31 = -v27;
  }
  else
  {
    v31 = -0.75;
    v32 = sqrtf((float)((float)(v25->x * v25->x) + (float)(v26 * v26)) + 0.5625);
    v29 = v29 / v32;
    v28 = v28 / v32;
  }
  v34 = atan2f(v28, v29);
  v35 = atan2f(v29, v31);
  v36 = CRealTimeShadow::SetLightProperties(
          m_pRealTimeShadow,
          (float)(v34 * 180.0) / 3.1416,
          -(float)((float)(v35 * 180.0) / 3.1416),
          1);
  v37 = *(_QWORD *)&v36->modelling.at.x;
  v48.z = v36->modelling.at.z;
  *(_QWORD *)&v48.x = v37;
  CVector::Normalise(&v48);
  v38 = v48.x;
  v39 = 2.25;
  posn.x = posn.x - (float)((float)(v48.x * -0.5) * 2.5);
  posn.y = posn.y - (float)((float)(v48.y * -0.5) * 2.5);
  if ( (*(_BYTE *)&pPhysical->m_info & 7) == 3 )
    v39 = 1.5;
  if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
  {
    v40 = v48.y * v48.y;
    v41 = -v48.y;
    v42 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
    v43 = *(_QWORD *)&posn.x;
    v44 = CShadows::ShadowsStoredToBeRendered + 1;
    v42->pTex = ShadowRwTexture;
    v45 = *((_BYTE *)v42 + 50);
    v42->Type = 3;
    v46 = sqrtf((float)(v38 * v38) + v40);
    v42->Coors.z = posn.z;
    CShadows::ShadowsStoredToBeRendered = v44;
    v42->Brightness = v30;
    v42->Red = v30;
    v42->Green = v30;
    v42->Blue = v30;
    v42->ShadowDepth = 4.0;
    *((_BYTE *)v42 + 50) = v45 & 0xFA;
    v42->TextureScale = 1.0;
    v42->pRealTimeShadow = m_pRealTimeShadow;
    *(_QWORD *)&v42->Coors.x = v43;
    v47 = (float)(v46 + 1.0) / v46;
    v42->ForwardX = (float)((float)(v38 * v47) * -0.5) * v39;
    v42->ForwardY = (float)((float)(v47 * v41) * 0.5) * v39;
    v42->SideX = (float)((float)(v41 / v46) * 0.5) * v39;
    v42->SideY = (float)((float)(v38 / v46) * 0.5) * v39;
  }
  return 1;
}

//----- (005BA3F4) --------------------------------------------------------
float *__fastcall CShadows::CalcPedShadowValues(
        float a1,
        float a2,
        int a3,
        float *a4,
        float *a5,
        float *a6,
        float *pShadowFrontY,
        float *pShadowSideX,
        float *pShadowSideY)
{
  float *result; // r0
  float v11; // s2
  float v12; // s10

  result = a5;
  *a4 = -a1;
  *a5 = -a2;
  v11 = sqrtf((float)(a2 * a2) + (float)(*a4 * *a4));
  v12 = (float)(v11 + 1.0) / v11;
  *a4 = *a4 * v12;
  *a5 = *a5 * v12;
  *a6 = (float)-a2 / v11;
  *pShadowFrontY = a1 / v11;
  *pShadowSideX = -a1;
  *pShadowSideY = -a2;
  *a4 = *a4 * 0.5;
  *a5 = *a5 * 0.5;
  *a6 = *a6 * 0.5;
  *pShadowFrontY = *pShadowFrontY * 0.5;
  *pShadowSideX = *pShadowSideX * 0.5;
  *pShadowSideY = *pShadowSideY * 0.5;
  return result;
}

//----- (005BA4BC) --------------------------------------------------------
void __fastcall CShadows::StoreShadowForPole(
        CEntity *pPole,
        float OffsetX,
        float OffsetY,
        float ShiftUp,
        float Length,
        float Width,
        UInt32 Number)
{
  Int16 m_nPoleShadowStrength; // r4
  CMatrix *m_pMat; // r0
  float zz; // s0
  float v14; // s16
  CSimpleTransform *p_m_transform; // r1
  __int64 v16; // d16
  float v17; // s28
  float v18; // s22
  float v19; // s20
  int v20; // r6
  float v21; // s4
  CVector *v22; // r0
  float v23; // s10
  float v24; // s12
  RwReal v25; // s0
  float v26; // s4
  CVector pCoors; // [sp+38h] [bp-60h] BYREF

  m_nPoleShadowStrength = CTimeCycle::m_CurrentColours.m_nPoleShadowStrength;
  if ( CTimeCycle::m_CurrentColours.m_nPoleShadowStrength )
  {
    m_pMat = pPole->m_pMat;
    if ( m_pMat )
    {
      zz = m_pMat->zz;
      if ( zz < 0.5 )
        return;
    }
    else
    {
      CPlaceable::AllocateMatrix(pPole);
      CSimpleTransform::UpdateMatrix(&pPole->m_transform, pPole->m_pMat);
      m_pMat = pPole->m_pMat;
      zz = m_pMat->zz;
    }
    v14 = OffsetX;
    p_m_transform = &pPole->m_transform;
    if ( m_pMat )
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    v16 = *(_QWORD *)&p_m_transform->m_translate.x;
    pCoors.z = p_m_transform->m_translate.z;
    *(_QWORD *)&pCoors.x = v16;
    if ( m_pMat )
    {
      v17 = m_pMat->xy * OffsetY;
    }
    else
    {
      CPlaceable::AllocateMatrix(pPole);
      CSimpleTransform::UpdateMatrix(&pPole->m_transform, pPole->m_pMat);
      m_pMat = pPole->m_pMat;
      v17 = m_pMat->xy * OffsetY;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(pPole);
        CSimpleTransform::UpdateMatrix(&pPole->m_transform, pPole->m_pMat);
        m_pMat = pPole->m_pMat;
      }
    }
    v18 = pCoors.x + (float)(v17 + (float)(m_pMat->xx * OffsetX));
    pCoors.x = v18;
    if ( m_pMat )
    {
      v19 = m_pMat->yy * OffsetY;
    }
    else
    {
      CPlaceable::AllocateMatrix(pPole);
      CSimpleTransform::UpdateMatrix(&pPole->m_transform, pPole->m_pMat);
      m_pMat = pPole->m_pMat;
      v19 = m_pMat->yy * OffsetY;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(pPole);
        CSimpleTransform::UpdateMatrix(&pPole->m_transform, pPole->m_pMat);
        m_pMat = pPole->m_pMat;
      }
    }
    v20 = 2
        * (int)(float)((float)((float)(zz + -0.5) * (float)m_nPoleShadowStrength)
                     + (float)((float)(zz + -0.5) * (float)m_nPoleShadowStrength));
    v21 = m_pMat->yx * v14;
    pCoors.z = pCoors.z + ShiftUp;
    v22 = &CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue];
    v23 = (float)(Length * 0.5) * v22->x;
    v24 = (float)(Length * 0.5) * v22->y;
    v25 = (float)(pCoors.y + (float)(v19 + v21)) - v24;
    pCoors.x = v18 - v23;
    v26 = CTimeCycle::m_fShadowSideX[CTimeCycle::m_CurrentStoredValue];
    pCoors.y = v25;
    CShadows::StoreStaticShadow(
      (u_native)(&pPole->m_areaCode + Number),
      1u,
      gpPostShadowTex,
      &pCoors,
      -v23,
      -v24,
      v26 * Width,
      CTimeCycle::m_fShadowSideY[CTimeCycle::m_CurrentStoredValue] * Width,
      (unsigned int)((__int16)v20 / 3),
      0LL,
      9.0,
      1.0,
      40.0,
      0,
      0.0);
  }
}

//----- (005BA714) --------------------------------------------------------
void __fastcall CShadows::SetRenderModeForShadowType(UInt8 ShadowType)
{
  if ( ShadowType <= 8u )
  {
    if ( ((1 << ShadowType) & 0x172) != 0 )
    {
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
    }
    else if ( ShadowType == 2 )
    {
      RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
      sub_192840(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    }
    else if ( ShadowType == 3 )
    {
      RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
      sub_192840(rwRENDERSTATEDESTBLEND, byte_4);
    }
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005BA770) --------------------------------------------------------
void __fastcall CShadows::RenderStoredShadows(bool renderAdditive)
{
  int v1; // r4
  int v2; // r0
  int v3; // r2
  _BYTE *v4; // r1
  int v5; // r6
  CStoredShadow *v6; // r10
  _BOOL4 v7; // r4
  RwTexture_0 *v8; // r1
  RwTexture_0 **p_pTex; // r10
  RwTexture_0 *pTex; // t1
  int v11; // r0
  bool v12; // zf
  bool v13; // zf
  UInt16 v14; // r0
  int v15; // r3
  CStoredShadow *v16; // r4
  CStoredShadow *v17; // r1
  CRealTimeShadow *pRealTimeShadow; // r0
  float v19; // s0
  float v20; // s26
  float radius; // s2
  __int64 v22; // kr00_8
  float v23; // s20
  float v24; // s22
  float v25; // s24
  float v26; // r5
  float v27; // s26
  float v28; // s28
  float v29; // s30
  float v30; // r5
  float v31; // r0
  int v32; // r2
  int v33; // r2
  int v34; // r2
  int v35; // r2
  uint16 v36; // r0
  unsigned __int16 v37; // r0
  CStoredShadow *v38; // r1
  int v39; // r0
  float *v40; // r5
  CStoredShadow *v41; // r0
  float *p_TextureScale; // r9
  float *p_ShadowDepth; // r10
  int v44; // r0
  int v45; // r8
  int v46; // r0
  int v47; // r11
  bool v48; // cc
  int v49; // r0
  CSector *v50; // r0
  float v51; // s8
  Int32 v52; // r6
  float v53; // s10
  float v54; // s4
  float v55; // s0
  float v56; // s6
  float v57; // s2
  int v58; // r2
  _BOOL4 v59; // [sp+44h] [bp-10Ch]
  int v60; // [sp+7Ch] [bp-D4h]
  int v61; // [sp+90h] [bp-C0h]
  RwTexture_0 **v62; // [sp+94h] [bp-BCh]
  int v63; // [sp+98h] [bp-B8h]
  int v64; // [sp+9Ch] [bp-B4h]
  int v65; // [sp+A0h] [bp-B0h]
  int v66; // [sp+A4h] [bp-ACh]
  int v67; // [sp+A8h] [bp-A8h]
  _BYTE *v68; // [sp+ACh] [bp-A4h]
  unsigned __int8 *v69; // [sp+B0h] [bp-A0h]
  float *v70; // [sp+B8h] [bp-98h]
  float *v71; // [sp+BCh] [bp-94h]
  float *v72; // [sp+C0h] [bp-90h]
  int Red; // [sp+C4h] [bp-8Ch]
  int Blue; // [sp+C8h] [bp-88h]
  int Green; // [sp+CCh] [bp-84h]
  int Brightness; // [sp+D0h] [bp-80h]
  CRealTimeShadow **p_pRealTimeShadow; // [sp+D4h] [bp-7Ch]
  int v78; // [sp+D8h] [bp-78h]
  UInt8 lightingMult; // [sp+DFh] [bp-71h] BYREF
  CVector pShadowPos; // [sp+E0h] [bp-70h] BYREF

  v1 = 0;
  v59 = renderAdditive;
  TempBufferIndicesStored = 0;
  TempBufferVerticesStored = 0;
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  v2 = CShadows::ShadowsStoredToBeRendered;
  if ( CShadows::ShadowsStoredToBeRendered )
  {
    v3 = 0;
    v4 = (char *)CShadows::asShadowsStored + 50;
    do
    {
      ++v3;
      *v4 &= ~2u;
      v4 += 52;
    }
    while ( v3 < v2 );
  }
  if ( !(MobileSettings::settings[5].value ^ 2 | CGame::currArea) )
    v1 = 1;
  if ( v2 )
  {
    v5 = 0;
    v60 = !v59 & v1;
    do
    {
      if ( (*((_BYTE *)&CShadows::asShadowsStored[v5] + 50) & 2) == 0 )
      {
        v6 = &CShadows::asShadowsStored[v5];
        v7 = 1;
        pTex = v6->pTex;
        p_pTex = &v6->pTex;
        v8 = pTex;
        v11 = *((unsigned __int8 *)p_pTex + 10);
        v69 = (unsigned __int8 *)p_pTex + 10;
        v12 = v11 == 2;
        if ( v11 != 2 )
          v12 = v8 == gpBloodPoolTex;
        if ( !v12 )
        {
          v13 = v8 == gpShadowHeadLightsTex;
          if ( v8 != gpShadowHeadLightsTex )
            v13 = v8 == gpShadowHeadLightsTex2;
          if ( !v13 )
            v7 = v8 == gpShadowExplosionTex;
        }
        CShadows::SetRenderModeForShadowType(v11);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, (*p_pTex)->raster);
        RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
        v14 = CShadows::ShadowsStoredToBeRendered;
        if ( v5 < CShadows::ShadowsStoredToBeRendered )
        {
          v15 = v5;
          v61 = v59 ^ v7;
          v62 = p_pTex;
          v63 = v5;
          do
          {
            v16 = &CShadows::asShadowsStored[v15];
            if ( *v69 == v16->Type && *p_pTex == CShadows::asShadowsStored[v15].pTex )
            {
              v64 = v15;
              if ( !v61 )
              {
                v17 = &CShadows::asShadowsStored[v15];
                pRealTimeShadow = v17->pRealTimeShadow;
                p_pRealTimeShadow = &v17->pRealTimeShadow;
                v19 = fabsf(v17->ForwardX) + fabsf(v17->SideX);
                v20 = fabsf(v17->ForwardY) + fabsf(v17->SideY);
                if ( pRealTimeShadow )
                {
                  radius = pRealTimeShadow->m_ClumpWorldBoundingSphere.radius;
                  v20 = v20 + radius;
                  v19 = v19 + radius;
                }
                *(_QWORD *)&pShadowPos.x = *(_QWORD *)&v16->Coors.x;
                v22 = *(_QWORD *)&pShadowPos.x;
                v23 = pShadowPos.x - v19;
                v24 = pShadowPos.y - v20;
                v25 = v19 + pShadowPos.x;
                v26 = floorf((float)((float)(pShadowPos.x - v19) / 50.0) + 60.0);
                v27 = v20 + *((float *)&v22 + 1);
                v28 = floorf((float)(v24 / 50.0) + 60.0);
                v29 = v26;
                v30 = floorf((float)(v25 / 50.0) + 60.0);
                v31 = floorf((float)(v27 / 50.0) + 60.0);
                pShadowPos.z = v16->Coors.z;
                v32 = (int)v31;
                if ( (int)v31 >= 119 )
                  v32 = 119;
                v65 = v32;
                v33 = (int)v30;
                if ( (int)v30 >= 119 )
                  v33 = 119;
                v78 = v33;
                v34 = (int)v28;
                if ( (int)v28 <= 0 )
                  v34 = 0;
                v67 = v34;
                v35 = (int)v29;
                if ( (int)v29 <= 0 )
                  v35 = 0;
                v66 = v35;
                if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
                {
                  CWorld::ClearScanCodes();
                  v36 = 1;
                }
                else
                {
                  v36 = CWorld::ms_nCurrentScanCode + 1;
                }
                CWorld::ms_nCurrentScanCode = v36;
                if ( v60 )
                {
                  Green = 255;
                  Red = 255;
                  LOWORD(Brightness) = 255;
                  v37 = 255;
                  Blue = 255;
                }
                else
                {
                  v38 = &CShadows::asShadowsStored[v64];
                  v37 = v38->Brightness;
                  Blue = v38->Blue;
                  Red = v38->Red;
                  Green = v38->Green;
                  LOWORD(Brightness) = v37;
                }
                if ( *p_pRealTimeShadow && MobileSettings::settings[5].value == 2 )
                {
                  v39 = (unsigned __int64)(1374389535LL * v37 * (*p_pRealTimeShadow)->m_fadeVal) >> 32;
                  Brightness = (v39 >> 5) + ((unsigned int)v39 >> 31);
                }
                if ( v67 <= v65 )
                {
                  v72 = (float *)(p_pRealTimeShadow - 4);
                  v71 = (float *)(p_pRealTimeShadow - 6);
                  v70 = (float *)(p_pRealTimeShadow - 5);
                  v40 = (float *)(p_pRealTimeShadow - 7);
                  v41 = &CShadows::asShadowsStored[v64];
                  p_TextureScale = &v41->TextureScale;
                  p_ShadowDepth = &v41->ShadowDepth;
                  v68 = (char *)v41 + 50;
                  do
                  {
                    if ( v66 <= v78 )
                    {
                      v44 = 119;
                      if ( v67 < 119 )
                        v44 = v67;
                      v45 = 120 * v44;
                      v46 = v66;
                      do
                      {
                        v47 = v46;
                        v48 = v46 < 119;
                        v49 = 119;
                        if ( v48 )
                          v49 = v47;
                        v50 = &CWorld::ms_aSectors[v49 + v45];
                        if ( *p_pRealTimeShadow )
                        {
                          CShadows::CastRealTimeShadowSectorList(
                            &v50->m_buildingPtrListArray,
                            v23,
                            v24,
                            v25,
                            v27,
                            &pShadowPos,
                            *v40,
                            *v71,
                            *v70,
                            *v72,
                            Brightness,
                            Red,
                            Green,
                            Blue,
                            *p_ShadowDepth,
                            *p_TextureScale,
                            0,
                            *p_pRealTimeShadow,
                            &lightingMult);
                        }
                        else
                        {
                          v51 = *p_TextureScale;
                          v52 = *v69;
                          v53 = *p_ShadowDepth;
                          v54 = *v71;
                          v55 = *v72;
                          v56 = *v40;
                          v57 = *v70;
                          if ( (*v68 & 4) != 0 )
                            CShadows::CastPlayerShadowSectorList(
                              &v50->m_buildingPtrListArray,
                              v23,
                              v24,
                              v25,
                              v27,
                              &pShadowPos,
                              v56,
                              v54,
                              v57,
                              v55,
                              (__int16)Brightness,
                              Red,
                              Green,
                              Blue,
                              v53,
                              v51,
                              0,
                              &lightingMult,
                              v52);
                          else
                            CShadows::CastShadowSectorList(
                              &v50->m_buildingPtrListArray,
                              v23,
                              v24,
                              v25,
                              v27,
                              &pShadowPos,
                              v56,
                              v54,
                              v57,
                              v55,
                              (__int16)Brightness,
                              Red,
                              Green,
                              Blue,
                              v53,
                              v51,
                              0,
                              &lightingMult,
                              v52);
                        }
                        v46 = v47 + 1;
                      }
                      while ( v47 < v78 );
                    }
                    v58 = v67++;
                  }
                  while ( v58 < v65 );
                }
              }
              v15 = v64;
              *((_BYTE *)&CShadows::asShadowsStored[v64] + 50) |= 2u;
              v14 = CShadows::ShadowsStoredToBeRendered;
              p_pTex = v62;
              v5 = v63;
            }
            ++v15;
          }
          while ( v15 < v14 );
        }
        RenderBuffer::RenderStuffInBuffer();
        LOWORD(v2) = CShadows::ShadowsStoredToBeRendered;
      }
      ++v5;
    }
    while ( v5 < (unsigned __int16)v2 );
  }
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
  if ( v59 )
    CShadows::ShadowsStoredToBeRendered = 0;
}
// 0: using guessed type int dword_0;

//----- (005BADE4) --------------------------------------------------------
void RenderBuffer::ClearRenderBuffer()
{
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
}

//----- (005BAE00) --------------------------------------------------------
void __fastcall CShadows::CastRealTimeShadowSectorList(
        CPtrList *list,
        float XMin,
        float YMin,
        float XMax,
        float YMax,
        CVector *pShadowPos,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        Int16 Brightness,
        UInt8 Red,
        UInt8 Green,
        UInt8 Blue,
        float ShadowDepth,
        float TextureScale,
        CPolyBunch **ppBunch,
        CRealTimeShadow *pRealTimeShadow,
        UInt8 *lightingMult)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v23; // kr00_8
  int v24; // r1
  int v25; // r0
  bool v26; // zf
  int v27; // r1
  float z; // s0
  float *v29; // r2
  CColModel *m_pColModel; // r0
  float v31; // s2
  float v32[28]; // [sp+30h] [bp-70h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v23 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v23.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      v24 = *((_DWORD *)v23.m_pVoid + 7);
      *((_WORD *)v23.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      if ( (v24 & 0x10001) == 1 )
      {
        v25 = *((unsigned __int8 *)v23.m_pVoid + 51);
        v26 = v25 == 13;
        if ( v25 != 13 )
          v26 = CGame::currArea == v25;
        if ( v26 )
        {
          (*(void (__fastcall **)(float *, void *))(*(_DWORD *)v23.m_pVoid + 40))(v32, v23.m_pVoid);
          if ( v32[2] > XMin && v32[0] < XMax && v32[1] > YMin && v32[3] < YMax )
          {
            v27 = *((_DWORD *)v23.m_pVoid + 5);
            z = pShadowPos->z;
            v29 = (float *)(v27 + 48);
            m_pColModel = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v23.m_pVoid + 19)]->m_pColModel;
            if ( !v27 )
              v29 = (float *)((char *)v23.m_pVoid + 4);
            v31 = v29[2];
            if ( (float)(z - ShadowDepth) < (float)(v31 + m_pColModel->m_boxBound.m_vecMax.z)
              && z > (float)(v31 + m_pColModel->m_boxBound.m_vecMin.z) )
            {
              CShadows::CastShadowEntityXYZ(
                (CEntity *)v23.m_pVoid,
                pShadowPos,
                ForwardX,
                ForwardY,
                SideX,
                SideY,
                Brightness,
                Red,
                Green,
                Blue,
                ShadowDepth,
                TextureScale,
                ppBunch,
                pRealTimeShadow,
                lightingMult);
            }
          }
        }
      }
    }
  }
}

//----- (005BAF70) --------------------------------------------------------
void __fastcall CShadows::CastPlayerShadowSectorList(
        CPtrList *list,
        float XMin,
        float YMin,
        float XMax,
        float YMax,
        CVector *pShadowPos,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        int Brightness,
        unsigned int Red,
        unsigned int Green,
        unsigned int Blue,
        float ShadowDepth,
        float TextureScale,
        CPolyBunch **ppBunch,
        UInt8 *lightingMult,
        Int32 ShadowType)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v23; // kr00_8
  int v24; // r1
  bool v25; // zf
  int v26; // r1
  int v27; // r0
  bool v28; // zf
  int v29; // r0
  float v30; // r3
  float v31; // r1
  float z; // s0
  float v33; // r2
  CColModel *m_pColModel; // r0
  float v35; // s2
  float v36; // [sp+0h] [bp-B0h]
  float v37[28]; // [sp+40h] [bp-70h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    while ( 1 )
    {
      v23 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v24 = *((unsigned __int16 *)v23.m_pVoid + 24);
      v25 = v24 == CWorld::ms_nCurrentScanCode;
      if ( v24 != CWorld::ms_nCurrentScanCode )
      {
        v26 = *((unsigned __int8 *)v23.m_pVoid + 28);
        *((_WORD *)v23.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        v25 = v26 << 31 == 0;
      }
      if ( !v25 )
      {
        v27 = *((unsigned __int8 *)v23.m_pVoid + 51);
        v28 = v27 == 13;
        if ( v27 != 13 )
          v28 = CGame::currArea == v27;
        if ( v28 )
        {
          v29 = *((_DWORD *)v23.m_pVoid + 5);
          if ( !v29 )
          {
            CPlaceable::AllocateMatrix((CPlaceable *)v23.m_pVoid);
            CSimpleTransform::UpdateMatrix(
              (const CSimpleTransform *)((char *)v23.m_pVoid + 4),
              *((CMatrix **)v23.m_pVoid + 5));
            v29 = *((_DWORD *)v23.m_pVoid + 5);
          }
          if ( *(float *)(v29 + 40) > 0.97 )
          {
            (*(void (__fastcall **)(float *, void *))(*(_DWORD *)v23.m_pVoid + 40))(v37, v23.m_pVoid);
            if ( v37[2] > XMin && v37[0] < XMax && v37[1] > YMin && v37[3] < YMax )
            {
              v31 = *((float *)v23.m_pVoid + 5);
              z = pShadowPos->z;
              LODWORD(v33) = LODWORD(v31) + 48;
              m_pColModel = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v23.m_pVoid + 19)]->m_pColModel;
              if ( v31 == 0.0 )
                LODWORD(v33) = (char *)v23.m_pVoid + 4;
              v35 = *(float *)(LODWORD(v33) + 8);
              if ( (float)(z - ShadowDepth) < (float)(v35 + m_pColModel->m_boxBound.m_vecMax.z)
                && z > (float)(v35 + m_pColModel->m_boxBound.m_vecMin.z) )
              {
                break;
              }
            }
          }
        }
      }
      if ( !m_pHead )
        return;
    }
    CShadows::CastShadowEntityXY(
      (CEntity *)v23.m_pVoid,
      v31,
      v33,
      v30,
      v36,
      pShadowPos,
      ForwardX,
      ForwardY,
      SideX,
      SideY,
      Brightness,
      Red,
      Green,
      Blue,
      ShadowDepth,
      TextureScale,
      ppBunch,
      lightingMult,
      ShadowType);
  }
}
// 5BB0E4: variable 'v30' is possibly undefined
// 5BB0E4: variable 'v36' is possibly undefined

//----- (005BB10C) --------------------------------------------------------
void __fastcall CShadows::CastShadowSectorList(
        CPtrList *list,
        float XMin,
        float YMin,
        float XMax,
        float YMax,
        CVector *pShadowPos,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        int Brightness,
        unsigned int Red,
        unsigned int Green,
        unsigned int Blue,
        float ShadowDepth,
        float TextureScale,
        CPolyBunch **ppBunch,
        UInt8 *lightingMult,
        Int32 ShadowType)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v23; // kr00_8
  int v24; // r1
  int v25; // r0
  bool v26; // zf
  int v27; // r0
  float v28; // r3
  float v29; // r1
  float z; // s0
  float v31; // r2
  CColModel *m_pColModel; // r0
  float v33; // s2
  float v34; // [sp+0h] [bp-B0h]
  float v35[28]; // [sp+40h] [bp-70h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v23 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v23.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      v24 = *((_DWORD *)v23.m_pVoid + 7);
      *((_WORD *)v23.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      if ( (v24 & 0x10001) == 1 )
      {
        v25 = *((unsigned __int8 *)v23.m_pVoid + 51);
        v26 = v25 == 13;
        if ( v25 != 13 )
          v26 = CGame::currArea == v25;
        if ( v26 )
        {
          v27 = *((_DWORD *)v23.m_pVoid + 5);
          if ( !v27 )
          {
            CPlaceable::AllocateMatrix((CPlaceable *)v23.m_pVoid);
            CSimpleTransform::UpdateMatrix(
              (const CSimpleTransform *)((char *)v23.m_pVoid + 4),
              *((CMatrix **)v23.m_pVoid + 5));
            v27 = *((_DWORD *)v23.m_pVoid + 5);
          }
          if ( *(float *)(v27 + 40) > 0.97 )
          {
            (*(void (__fastcall **)(float *, void *))(*(_DWORD *)v23.m_pVoid + 40))(v35, v23.m_pVoid);
            if ( v35[2] > XMin && v35[0] < XMax && v35[1] > YMin && v35[3] < YMax )
            {
              v29 = *((float *)v23.m_pVoid + 5);
              z = pShadowPos->z;
              LODWORD(v31) = LODWORD(v29) + 48;
              m_pColModel = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v23.m_pVoid + 19)]->m_pColModel;
              if ( v29 == 0.0 )
                LODWORD(v31) = (char *)v23.m_pVoid + 4;
              v33 = *(float *)(LODWORD(v31) + 8);
              if ( (float)(z - ShadowDepth) < (float)(v33 + m_pColModel->m_boxBound.m_vecMax.z)
                && z > (float)(v33 + m_pColModel->m_boxBound.m_vecMin.z) )
              {
                CShadows::CastShadowEntityXY(
                  (CEntity *)v23.m_pVoid,
                  v29,
                  v31,
                  v28,
                  v34,
                  pShadowPos,
                  ForwardX,
                  ForwardY,
                  SideX,
                  SideY,
                  Brightness,
                  Red,
                  Green,
                  Blue,
                  ShadowDepth,
                  TextureScale,
                  ppBunch,
                  lightingMult,
                  ShadowType);
              }
            }
          }
        }
      }
    }
  }
}
// 5BB280: variable 'v28' is possibly undefined
// 5BB280: variable 'v34' is possibly undefined

//----- (005BB2A8) --------------------------------------------------------
void RenderBuffer::RenderStuffInBuffer()
{
  RwImVertexIndex *v0; // r1
  RwInt32 v1; // r2
  int v2; // [sp+0h] [bp-10h] BYREF
  __int16 v3; // [sp+4h] [bp-Ch]

  if ( TempBufferVerticesStored )
  {
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      v0 = TempBufferRenderIndexList;
      v1 = TempBufferIndicesStored;
LABEL_6:
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, v0, v1);
      RwIm3DEnd();
    }
  }
  else if ( RwIm3DTransform(TempVertexBuffer.m_3d, 1u, 0, 1u) )
  {
    v0 = (RwImVertexIndex *)&v2;
    v1 = 3;
    v3 = 0;
    v2 = 0;
    goto LABEL_6;
  }
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
}

//----- (005BB334) --------------------------------------------------------
void __fastcall CShadows::RenderStaticShadows(bool renderAdditive)
{
  float32x2_t v1; // d1
  int v2; // r4
  int v3; // r3
  CPolyBunch *pFirstBunch; // r10
  CStaticShadow *v5; // r4
  int v6; // r0
  UInt8 *v7; // r4
  int Type; // t1
  int v9; // r1
  RwTexture_0 *pTex; // r2
  CStaticShadow *v11; // r1
  __int64 v12; // d0
  int32 NumPoints; // r5
  float v14; // s2
  int v15; // r11
  float v16; // s4
  float v17; // s0
  unsigned int v18; // r0
  Int32 v19; // lr
  int v20; // r1
  UInt8 *v21; // r12
  int v22; // r5
  int v23; // r6
  unsigned int v24; // r2
  RwIm3DVertex *v25; // r3
  char *v26; // r1
  RwReal y; // r1
  RwReal v28; // s0
  RwReal x; // r4
  int v30; // r3
  Int32 v31; // r2
  int v32; // r1
  int v33; // r6
  Int32 v34; // r3
  unsigned int v35; // r12
  uint32x4_t v36; // q8
  int32 v37; // r11
  uint16x4_t *v38; // r1
  unsigned int v39; // r5
  unsigned __int64 v40; // d21
  int v41; // [sp+10h] [bp-E8h]
  int v42; // [sp+1Ch] [bp-DCh]
  void ***p_pTex; // [sp+38h] [bp-C0h]
  UInt8 *p_Type; // [sp+44h] [bp-B4h]
  UInt8 *p_lightingMult; // [sp+50h] [bp-A8h]
  int v46; // [sp+58h] [bp-A0h]
  Int16 *p_Brightness; // [sp+68h] [bp-90h]
  UInt8 *p_Red; // [sp+88h] [bp-70h]
  UInt8 *p_Green; // [sp+8Ch] [bp-6Ch]
  UInt8 *p_Blue; // [sp+90h] [bp-68h]
  int32 v51; // [sp+94h] [bp-64h]

  v2 = 0;
  v42 = renderAdditive;
  TempBufferIndicesStored = 0;
  TempBufferVerticesStored = 0;
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  CShadows::aStaticShadows[1].bRendered = 0;
  CShadows::aStaticShadows[0].bRendered = 0;
  CShadows::aStaticShadows[2].bRendered = 0;
  CShadows::aStaticShadows[3].bRendered = 0;
  CShadows::aStaticShadows[4].bRendered = 0;
  CShadows::aStaticShadows[5].bRendered = 0;
  CShadows::aStaticShadows[6].bRendered = 0;
  CShadows::aStaticShadows[7].bRendered = 0;
  CShadows::aStaticShadows[8].bRendered = 0;
  CShadows::aStaticShadows[9].bRendered = 0;
  CShadows::aStaticShadows[10].bRendered = 0;
  CShadows::aStaticShadows[11].bRendered = 0;
  CShadows::aStaticShadows[12].bRendered = 0;
  CShadows::aStaticShadows[13].bRendered = 0;
  CShadows::aStaticShadows[14].bRendered = 0;
  CShadows::aStaticShadows[15].bRendered = 0;
  CShadows::aStaticShadows[16].bRendered = 0;
  CShadows::aStaticShadows[17].bRendered = 0;
  CShadows::aStaticShadows[18].bRendered = 0;
  CShadows::aStaticShadows[19].bRendered = 0;
  CShadows::aStaticShadows[20].bRendered = 0;
  CShadows::aStaticShadows[21].bRendered = 0;
  CShadows::aStaticShadows[22].bRendered = 0;
  CShadows::aStaticShadows[23].bRendered = 0;
  CShadows::aStaticShadows[24].bRendered = 0;
  CShadows::aStaticShadows[25].bRendered = 0;
  CShadows::aStaticShadows[26].bRendered = 0;
  CShadows::aStaticShadows[27].bRendered = 0;
  CShadows::aStaticShadows[28].bRendered = 0;
  CShadows::aStaticShadows[29].bRendered = 0;
  CShadows::aStaticShadows[30].bRendered = 0;
  CShadows::aStaticShadows[31].bRendered = 0;
  CShadows::aStaticShadows[32].bRendered = 0;
  CShadows::aStaticShadows[33].bRendered = 0;
  CShadows::aStaticShadows[34].bRendered = 0;
  CShadows::aStaticShadows[35].bRendered = 0;
  CShadows::aStaticShadows[36].bRendered = 0;
  CShadows::aStaticShadows[37].bRendered = 0;
  CShadows::aStaticShadows[38].bRendered = 0;
  CShadows::aStaticShadows[39].bRendered = 0;
  CShadows::aStaticShadows[40].bRendered = 0;
  CShadows::aStaticShadows[41].bRendered = 0;
  CShadows::aStaticShadows[42].bRendered = 0;
  CShadows::aStaticShadows[43].bRendered = 0;
  CShadows::aStaticShadows[44].bRendered = 0;
  CShadows::aStaticShadows[45].bRendered = 0;
  CShadows::aStaticShadows[46].bRendered = 0;
  CShadows::aStaticShadows[47].bRendered = 0;
  do
  {
    if ( CShadows::aStaticShadows[v2].pFirstBunch && !CShadows::aStaticShadows[v2].bRendered )
    {
      p_Type = &CShadows::aStaticShadows[v2].Type;
      CShadows::SetRenderModeForShadowType(*p_Type);
      p_pTex = (void ***)&CShadows::aStaticShadows[v2].pTex;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, **p_pTex);
      v3 = v2;
      v41 = v2;
      while ( 1 )
      {
        pFirstBunch = CShadows::aStaticShadows[v3].pFirstBunch;
        if ( pFirstBunch )
        {
          v5 = &CShadows::aStaticShadows[v3];
          Type = v5->Type;
          v7 = &v5->Type;
          v6 = Type;
          if ( Type == 2 )
          {
            v9 = 1;
          }
          else
          {
            pTex = CShadows::aStaticShadows[v3].pTex;
            v9 = 1;
            if ( pTex != gpBloodPoolTex && pTex != gpShadowHeadLightsTex && pTex != gpShadowHeadLightsTex2 )
              v9 = pTex == gpShadowExplosionTex;
          }
          if ( *p_Type == v6 )
          {
            v46 = v3;
            if ( *p_pTex == (void **)CShadows::aStaticShadows[v3].pTex )
            {
              if ( v9 == v42 )
              {
                v11 = &CShadows::aStaticShadows[v3];
                p_lightingMult = &v11->lightingMult;
                p_Brightness = &v11->Brightness;
                p_Blue = &v11->Blue;
                p_Green = &v11->Green;
                p_Red = &v11->Red;
                while ( 1 )
                {
                  v12 = COERCE_UNSIGNED_INT(1.0) | 0x3ECCCCCD00000000LL;
                  if ( (unsigned __int8)v6 != 2 )
                  {
                    v1.n64_f32[0] = (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam) * 0.6) + 0.4;
                    *(float *)&v12 = (float)((float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                           * (float)((float)((float)(*p_lightingMult >> 4) * 0.5) / 15.0))
                                                   + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                           * (float)((float)((float)(*p_lightingMult & 0xF) * 0.5) / 15.0)))
                                           * 0.7)
                                   + 0.3;
                    LODWORD(v12) = vmin_f32(v1, (float32x2_t)v12).n64_u32[0];
                  }
                  NumPoints = pFirstBunch->NumPoints;
                  v14 = *(float *)&v12 * (float)*p_Blue;
                  v15 = 3 * NumPoints - 6;
                  v16 = *(float *)&v12 * (float)*p_Green;
                  v17 = *(float *)&v12 * (float)*p_Red;
                  if ( v15 + TempBufferIndicesStored >= 4096 )
                    RenderBuffer::RenderStuffInBuffer();
                  v18 = TempBufferVerticesStored;
                  if ( TempBufferVerticesStored + NumPoints >= 2048 )
                  {
                    RenderBuffer::RenderStuffInBuffer();
                    v18 = TempBufferVerticesStored;
                  }
                  RenderBuffer::IndicesToBeStored = 3 * NumPoints - 6;
                  RenderBuffer::VerticesToBeStored = NumPoints;
                  v19 = TempBufferIndicesStored;
                  v20 = pFirstBunch->NumPoints;
                  if ( v20 >= 1 )
                  {
                    v51 = NumPoints;
                    v21 = v7;
                    v22 = 0;
                    v23 = 0;
                    v24 = (unsigned int)v17 | ((unsigned int)v14 << 16) | ((unsigned int)v16 << 8) | ((int)(float)((float)((float)(CWeather::Foggyness * -0.5) + 1.0) * (float)*p_Brightness) << 24);
                    v25 = &TempVertexBuffer.m_3d[v18];
                    do
                    {
                      v26 = (char *)pFirstBunch + v22;
                      v25->color = (RwRGBA_0)v24;
                      ++v22;
                      v25->texCoords.u = (float)(unsigned __int8)v26[90] * 0.005;
                      v25->texCoords.v = (float)(unsigned __int8)v26[97] * 0.005;
                      y = pFirstBunch->Coors[v23].y;
                      v28 = pFirstBunch->Coors[v23].z + 0.06;
                      x = pFirstBunch->Coors[v23++].x;
                      v25->position.x = x;
                      v25->position.y = y;
                      v25->position.z = v28;
                      ++v25;
                      v20 = pFirstBunch->NumPoints;
                    }
                    while ( v22 < v20 );
                    NumPoints = v51;
                    v7 = v21;
                  }
                  if ( 3 * (__int16)v20 - 6 >= 1 )
                  {
                    v30 = 0;
                    do
                    {
                      TempBufferRenderIndexList[v19 + v30] = ShadowIndexList[v30];
                      ++v30;
                    }
                    while ( v30 < 3 * pFirstBunch->NumPoints - 6 );
                  }
                  v31 = v15 + v19;
                  if ( v15 >= 1 )
                  {
                    v32 = v19 + 1;
                    if ( v31 > v19 + 1 )
                      v32 = v15 + v19;
                    v33 = v32 - v19;
                    if ( (unsigned int)(v32 - v19) < 8 )
                    {
                      v34 = v19;
                      goto LABEL_41;
                    }
                    v35 = v33 & 0xFFFFFFF8;
                    if ( (v33 & 0xFFFFFFF8) == 0 )
                    {
                      v34 = v19;
                      do
LABEL_41:
                        TempBufferRenderIndexList[v34++] += v18;
                      while ( v34 < v31 );
                      goto LABEL_42;
                    }
                    v34 = v19 + v35;
                    v36 = vdupq_n_s32(v18);
                    v37 = NumPoints;
                    v38 = (uint16x4_t *)&TempBufferRenderIndexList[v19];
                    v39 = v33 & 0xFFFFFFF8;
                    do
                    {
                      v39 -= 8;
                      v40 = vmovn_s32(vaddw_u16(v36, v38[1])).n64_u64[0];
                      v38->n64_u64[0] = vmovn_s32(vaddw_u16(v36, (uint16x4_t)v38->n64_u64[0])).n64_u64[0];
                      v38[1].n64_u64[0] = v40;
                      v38 += 2;
                    }
                    while ( v39 );
                    NumPoints = v37;
                    if ( v33 != v35 )
                      goto LABEL_41;
                  }
LABEL_42:
                  TempBufferVerticesStored = v18 + NumPoints;
                  TempBufferIndicesStored = v31;
                  pFirstBunch = pFirstBunch->pNext;
                  if ( !pFirstBunch )
                    break;
                  LOBYTE(v6) = *v7;
                }
              }
              v3 = v46;
              CShadows::aStaticShadows[v46].bRendered = 1;
            }
          }
        }
        if ( ++v3 == 48 )
        {
          RenderBuffer::RenderStuffInBuffer();
          v2 = v41;
          break;
        }
      }
    }
    ++v2;
  }
  while ( v2 != 48 );
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  sub_192840(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
}
// 5BB6E0: variable 'v1' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005BB99C) --------------------------------------------------------
void __fastcall CShadows::AffectColourWithLighting(
        int shadowType,
        unsigned int lightingMult,
        unsigned int origR,
        unsigned int origG,
        unsigned int a5,
        _BYTE *a6,
        _BYTE *a7,
        _BYTE *a8)
{
  float32x2_t v8; // d0
  float32x2_t v9; // d1
  float v10; // s0

  if ( shadowType == 2 )
  {
    v10 = 1.0;
  }
  else
  {
    v9.n64_f32[0] = (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam) * 0.6) + 0.4;
    v8.n64_f32[0] = (float)((float)((float)((float)((float)((float)(lightingMult >> 4) * 0.5) / 15.0)
                                          * CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                  + (float)((float)((float)((float)(lightingMult & 0xF) * 0.5) / 15.0)
                                          * (float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)))
                          * 0.7)
                  + 0.3;
    LODWORD(v10) = vmin_f32(v9, v8).n64_u32[0];
  }
  *a6 = (unsigned int)(float)(v10 * (float)origR);
  *a7 = (unsigned int)(float)(v10 * (float)origG);
  *a8 = (unsigned int)(float)(v10 * (float)a5);
}
// 5BBA1E: variable 'v9' is possibly undefined
// 5BBA1E: variable 'v8' is possibly undefined

//----- (005BBA80) --------------------------------------------------------
void __fastcall RenderBuffer::StartStoring(
        int32 IndicesWeNeed,
        int32 VerticesWeNeed,
        RwImVertexIndex **ppIndex,
        RwIm3DVertex **ppVertex)
{
  if ( TempBufferIndicesStored + IndicesWeNeed >= 4096 )
    RenderBuffer::RenderStuffInBuffer();
  if ( TempBufferVerticesStored + VerticesWeNeed >= 2048 )
    RenderBuffer::RenderStuffInBuffer();
  *ppIndex = &TempBufferRenderIndexList[TempBufferIndicesStored];
  *ppVertex = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
  RenderBuffer::VerticesToBeStored = VerticesWeNeed;
  RenderBuffer::IndicesToBeStored = IndicesWeNeed;
}

//----- (005BBB24) --------------------------------------------------------
void RenderBuffer::StopStoring()
{
  Int32 v0; // r0
  int v1; // r1
  int v2; // r2
  int v3; // lr
  unsigned int v4; // r12
  Int32 v5; // r2
  uint32x4_t v6; // q8
  uint16x4_t *v7; // r3
  unsigned int v8; // r4
  unsigned __int64 v9; // d21

  v0 = TempBufferVerticesStored;
  v1 = RenderBuffer::IndicesToBeStored + TempBufferIndicesStored;
  if ( RenderBuffer::IndicesToBeStored >= 1 )
  {
    v2 = TempBufferIndicesStored + 1;
    if ( v1 > TempBufferIndicesStored + 1 )
      v2 = RenderBuffer::IndicesToBeStored + TempBufferIndicesStored;
    v3 = v2 - TempBufferIndicesStored;
    if ( (unsigned int)(v2 - TempBufferIndicesStored) > 7 && (v4 = v3 & 0xFFFFFFF8, (v3 & 0xFFFFFFF8) != 0) )
    {
      v5 = TempBufferIndicesStored + v4;
      v6 = vdupq_n_s32(TempBufferVerticesStored);
      v7 = (uint16x4_t *)&TempBufferRenderIndexList[TempBufferIndicesStored];
      v8 = v3 & 0xFFFFFFF8;
      do
      {
        v8 -= 8;
        v9 = vmovn_s32(vaddw_u16(v6, v7[1])).n64_u64[0];
        v7->n64_u64[0] = vmovn_s32(vaddw_u16(v6, (uint16x4_t)v7->n64_u64[0])).n64_u64[0];
        v7[1].n64_u64[0] = v9;
        v7 += 2;
      }
      while ( v8 );
      if ( v3 == v4 )
        goto LABEL_12;
    }
    else
    {
      v5 = TempBufferIndicesStored;
    }
    do
      TempBufferRenderIndexList[v5++] += v0;
    while ( v5 < v1 );
  }
LABEL_12:
  TempBufferIndicesStored = v1;
  TempBufferVerticesStored = v0 + RenderBuffer::VerticesToBeStored;
}

//----- (005BBBEC) --------------------------------------------------------
void __fastcall CShadows::CastShadowEntityXY(
        CEntity *pEntity,
        float XMin,
        float YMin,
        float XMax,
        float YMax,
        CVector *pShadowPos,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        int Brightness,
        unsigned int Red,
        unsigned int Green,
        unsigned int Blue,
        float ShadowDepth,
        float TextureScale,
        CPolyBunch **ppBunch,
        UInt8 *lightingMult,
        Int32 ShadowType)
{
  float32x2_t v19; // d0
  float32x2_t v20; // d1
  float32x2_t v21; // d2
  float32x2_t v22; // d3
  float32x2_t v23; // d5
  float32x2_t v24; // d6
  float32x2_t v25; // d7
  char v27; // r0
  int v28; // r0
  char v29; // r0
  int v30; // r0
  char v31; // r0
  int v32; // r0
  CColModel *m_pColModel; // r0
  CCollisionData *m_pColData; // r11
  bool v35; // zf
  CPlaceable *v36; // r0
  float *p_xx; // r2
  float v38; // s16
  const CSimpleTransform *p_m_transform; // r6
  float v40; // s16
  float v41; // s24
  float v42; // s18
  float v43; // s24
  float v44; // s24
  float v45; // s28
  const CSimpleTransform *v46; // r4
  float *p_x; // r1
  float v48; // s26
  float v49; // s22
  float v50; // s20
  float v51; // s28
  float v52; // s28
  float v53; // s26
  float v54; // s0
  float v55; // s8
  float32x2_t v56; // d4
  const CSimpleTransform *p_tx; // r1
  CMatrix *m_pMat; // r0
  char v59; // r0
  float z; // s20
  int v61; // r1
  float v62; // s18
  float v63; // s28
  float v64; // s16
  int v65; // r4
  float v66; // s20
  float v67; // s22
  float v68; // s24
  float v69; // s26
  int v70; // r6
  int v71; // r0
  int v72; // r8
  int m_nNoOfTriangles; // r4
  CColTriangle *m_pTriangleArray; // r4
  CColTriangle *v75; // r4
  int32 m_nIndex3; // r2
  float x; // s0
  float v78; // s14
  float v79; // s4
  float y; // s2
  float v81; // s1
  float v82; // s8
  float v83; // s6
  float v84; // s10
  float v85; // s12
  float v86; // s5
  float v87; // s3
  int v88; // r0
  int v89; // r3
  int v90; // lr
  int v91; // r2
  float *v92; // r1
  float *v93; // r6
  float v94; // s5
  int v95; // r1
  int v96; // r5
  float v97; // s7
  float *v98; // r4
  float v99; // s9
  float v100; // s5
  float v101; // s13
  float *v102; // r1
  float v103; // s11
  float v104; // s3
  float *v105; // r4
  float *v106; // r5
  float v107; // s7
  float v108; // s9
  float v109; // s5
  float v110; // s13
  float v111; // s11
  float v112; // s7
  RwReal *p_y; // r6
  int v114; // r1
  float v115; // s3
  int v116; // r3
  unsigned int v117; // r1
  char *v118; // r1
  float v119; // s5
  int v120; // r0
  float *v121; // r1
  float *v122; // r0
  float v123; // s9
  float v124; // s5
  float v125; // s3
  float v126; // s3
  int v127; // r2
  int v128; // r3
  int v129; // r1
  int v130; // r6
  int v131; // r5
  float *v132; // r4
  float v133; // s3
  float v134; // s5
  RwReal v135; // r12
  int v136; // lr
  float *v137; // r0
  float v138; // s7
  float v139; // s9
  float v140; // s5
  float *v141; // r0
  int v142; // lr
  int v143; // r1
  float v144; // s7
  float *v145; // r12
  float *v146; // r1
  float v147; // s9
  float v148; // s5
  float v149; // s3
  RwReal *v150; // r0
  int v151; // r5
  int v152; // r1
  int v153; // lr
  float v154; // s3
  float v155; // s5
  int v156; // r4
  int v157; // r0
  float *v158; // r1
  float v159; // s7
  float v160; // s1
  float *v161; // r0
  float *v162; // r3
  float v163; // s14
  float v164; // s14
  float v165; // s5
  float *v166; // r0
  float v167; // s9
  float v168; // s1
  int v169; // r3
  RwReal *v170; // r1
  float *v171; // r2
  int v172; // r12
  int v173; // r4
  int v174; // r6
  float v175; // s14
  float v176; // s1
  float v177; // lr
  int v178; // r6
  RwReal v179; // r0
  float v180; // s3
  int v181; // r0
  float *v182; // r6
  float v183; // s5
  float v184; // s1
  float *v185; // r0
  float v186; // s3
  int v187; // r9
  float *v188; // r6
  float *v189; // r0
  int v190; // r5
  float v191; // s5
  float v192; // s1
  float v193; // s7
  float v194; // s7
  RwReal *v195; // r0
  unsigned int v196; // r5
  float *v197; // r0
  float32x2_t v198; // d1
  float32x2_t v199; // d0
  int v200; // r1
  float *v201; // r0
  float v202; // s5
  float *v203; // r1
  int v204; // r2
  float *v205; // r3
  float v206; // s4
  float v207; // s4
  float v208; // s14
  float v209; // s10
  float *v210; // r1
  float v211; // s28
  int v212; // r1
  float *v213; // r0
  float v214; // s4
  float v215; // s8
  float v216; // s0
  float v217; // s10
  RwReal *p_z; // r0
  float v219; // s0
  CPlaceable *v220; // r0
  int v221; // r6
  int v222; // r11
  RwReal *v223; // r4
  float *v224; // r2
  float v225; // s19
  RwReal *v226; // r10
  float v227; // s16
  float v228; // s30
  float *v229; // r1
  CMatrix *v230; // r2
  float v231; // s30
  float v232; // s16
  CSimpleTransform *v233; // r1
  float v234; // s2
  CSimpleTransform *v235; // r1
  CMatrix *v236; // r2
  CPolyBunch *v237; // r0
  int v238; // r1
  int v239; // r2
  char *v240; // r6
  __int64 v241; // d16
  char *v242; // r6
  float *v243; // r3
  int v244; // r4
  Int32 v245; // r1
  float v246; // s0
  unsigned int v247; // r3
  int v248; // r5
  unsigned int v249; // r12
  VertexBuffer *v250; // r6
  RwIm3DVertex *v251; // r4
  float v252; // s0
  __int64 v253; // kr00_8
  RwReal v254; // s0
  int v255; // r1
  Int32 v256; // lr
  int v257; // r1
  int v258; // r2
  Int32 v259; // r1
  int v260; // r12
  unsigned int v261; // r0
  unsigned int v262; // r10
  uint32x4_t v263; // q8
  uint16x4_t *v264; // r6
  unsigned int v265; // r3
  unsigned __int64 v266; // d21
  int v267; // [sp+4h] [bp-104h]
  Int32 v268; // [sp+8h] [bp-100h]
  int v269; // [sp+Ch] [bp-FCh]
  unsigned int v270; // [sp+10h] [bp-F8h]
  CCollisionData *v271; // [sp+68h] [bp-A0h]
  int v272; // [sp+6Ch] [bp-9Ch]
  int v273; // [sp+70h] [bp-98h]
  int v274; // [sp+70h] [bp-98h]
  int v275; // [sp+70h] [bp-98h]
  CSimpleTransform *v276; // [sp+74h] [bp-94h]
  CEntity *v277; // [sp+78h] [bp-90h]
  int v278; // [sp+7Ch] [bp-8Ch]
  int v279; // [sp+80h] [bp-88h]
  CVector v280; // [sp+84h] [bp-84h] BYREF
  CVector v281; // [sp+90h] [bp-78h] BYREF
  CVector pt; // [sp+9Ch] [bp-6Ch] BYREF

  v27 = `guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List;
  __dmb(0xBu);
  v277 = pEntity;
  if ( (v27 & 1) == 0 )
  {
    v28 = _cxa_guard_acquire((__guard *)&`guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List);
    pEntity = v277;
    if ( v28 )
    {
      _cxa_guard_release((__guard *)&`guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List);
      pEntity = v277;
    }
  }
  v29 = `guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture;
  __dmb(0xBu);
  if ( (v29 & 1) == 0 )
  {
    v30 = _cxa_guard_acquire((__guard *)&`guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture);
    pEntity = v277;
    if ( v30 )
    {
      _cxa_guard_release((__guard *)&`guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture);
      pEntity = v277;
    }
  }
  v31 = `guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points;
  __dmb(0xBu);
  if ( (v31 & 1) == 0 )
  {
    v32 = _cxa_guard_acquire((__guard *)&`guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points);
    pEntity = v277;
    if ( v32 )
    {
      _cxa_guard_release((__guard *)&`guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points);
      pEntity = v277;
    }
  }
  m_pColModel = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
  m_pColData = m_pColModel->m_pColData;
  v35 = m_pColData == 0;
  if ( m_pColData )
    v35 = m_pColData->m_nNoOfTriangles == 0;
  if ( v35 )
    return;
  CCollision::CalculateTrianglePlanes(m_pColModel);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  if ( p_xx )
  {
    v38 = *p_xx * ForwardX;
LABEL_16:
    v40 = v38 + (float)(p_xx[1] * ForwardY);
LABEL_17:
    v41 = p_xx[4] * ForwardX;
LABEL_18:
    v42 = v41 + (float)(p_xx[5] * ForwardY);
LABEL_19:
    v43 = *p_xx * SideX;
LABEL_20:
    v44 = v43 + (float)(p_xx[1] * SideY);
LABEL_21:
    v45 = p_xx[4] * SideX;
    goto LABEL_22;
  }
  CPlaceable::AllocateMatrix(v277);
  p_m_transform = &v277->m_transform;
  CSimpleTransform::UpdateMatrix(&v277->m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v38 = *p_xx * ForwardX;
  if ( p_xx )
    goto LABEL_16;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v40 = v38 + (float)(p_xx[1] * ForwardY);
  if ( p_xx )
    goto LABEL_17;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v41 = p_xx[4] * ForwardX;
  if ( p_xx )
    goto LABEL_18;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v42 = v41 + (float)(p_xx[5] * ForwardY);
  if ( p_xx )
    goto LABEL_19;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v43 = *p_xx * SideX;
  if ( p_xx )
    goto LABEL_20;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v44 = v43 + (float)(p_xx[1] * SideY);
  if ( p_xx )
    goto LABEL_21;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v45 = p_xx[4] * SideX;
  if ( !p_xx )
  {
    CPlaceable::AllocateMatrix(v277);
    CSimpleTransform::UpdateMatrix(p_m_transform, v277->m_pMat);
    v36 = v277;
    p_xx = &v277->m_pMat->xx;
  }
LABEL_22:
  v46 = &v36->m_transform;
  p_x = &v36->m_transform.m_translate.x;
  if ( p_xx )
    p_x = p_xx + 12;
  v48 = pShadowPos->x - *p_x;
  v49 = pShadowPos->y - p_x[1];
  v50 = v45 + (float)(p_xx[5] * SideY);
  if ( p_xx )
  {
    v51 = v48 * *p_xx;
LABEL_27:
    v52 = v51 + (float)(v49 * p_xx[1]);
    goto LABEL_28;
  }
  CPlaceable::AllocateMatrix(v36);
  CSimpleTransform::UpdateMatrix(v46, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v51 = v48 * *p_xx;
  if ( p_xx )
    goto LABEL_27;
  CPlaceable::AllocateMatrix(v277);
  CSimpleTransform::UpdateMatrix(v46, v277->m_pMat);
  v36 = v277;
  p_xx = &v277->m_pMat->xx;
  v52 = v51 + (float)(v49 * p_xx[1]);
  if ( !p_xx )
  {
    CPlaceable::AllocateMatrix(v277);
    CSimpleTransform::UpdateMatrix(v46, v277->m_pMat);
    v36 = v277;
    p_xx = &v277->m_pMat->xx;
    v53 = v48 * p_xx[4];
    if ( !p_xx )
    {
      CPlaceable::AllocateMatrix(v277);
      CSimpleTransform::UpdateMatrix(v46, v277->m_pMat);
      v36 = v277;
      p_xx = &v277->m_pMat->xx;
    }
    goto LABEL_29;
  }
LABEL_28:
  v53 = v48 * p_xx[4];
LABEL_29:
  v22.n64_f32[0] = (float)(v40 + v52) - v44;
  v23.n64_f32[0] = v44 + (float)(v40 + v52);
  v54 = v53 + (float)(v49 * p_xx[5]);
  v24.n64_f32[0] = v44 + (float)(v52 - v40);
  v25.n64_f32[0] = (float)(v52 - v40) - v44;
  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[0].x = v22.n64_f32[0];
  v55 = v42 + v54;
  v56.n64_f32[1] = v54 - v42;
  v19.n64_f32[0] = (float)(v42 + v54) - v50;
  v20.n64_f32[0] = v50 + v55;
  v21.n64_f32[0] = v50 + v56.n64_f32[1];
  v56.n64_f32[0] = v56.n64_f32[1] - v50;
  LODWORD(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[0].y) = v19.n64_u32[0];
  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[1].x = v23.n64_f32[0];
  LODWORD(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[1].y) = v20.n64_u32[0];
  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[2].x = v24.n64_f32[0];
  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[2].y = v50 + v56.n64_f32[1];
  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[3].x = v25.n64_f32[0];
  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[3].y = v56.n64_f32[1] - v50;
  p_tx = v46;
  m_pMat = v36->m_pMat;
  if ( m_pMat )
    p_tx = (const CSimpleTransform *)&m_pMat->tx;
  v59 = *((_BYTE *)m_pColData + 7);
  z = p_tx->m_translate.z;
  if ( (v59 & 2) == 0 )
  {
    v61 = 1;
    goto LABEL_34;
  }
  v61 = *m_pColData->m_modelSec;
  if ( v61 >= 1 )
  {
LABEL_34:
    v272 = v61;
    v276 = (CSimpleTransform *)v46;
    v62 = pShadowPos->z - z;
    v63 = v62 - ShadowDepth;
    v64 = 0.06;
    v65 = 0;
    LODWORD(v66) = vmax_f32(vmax_f32(v22, v23), vmax_f32(v24, v25)).n64_u32[0];
    LODWORD(v67) = vmin_f32(vmin_f32(v22, v23), vmin_f32(v24, v25)).n64_u32[0];
    LODWORD(v68) = vmax_f32(vmax_f32(v19, v20), vmax_f32(v21, v56)).n64_u32[0];
    LODWORD(v69) = vmin_f32(vmin_f32(v19, v20), vmin_f32(v21, v56)).n64_u32[0];
    v271 = m_pColData;
    v70 = v61;
    while ( 1 )
    {
      v278 = v65;
      if ( (v59 & 2) != 0 )
        break;
      m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
      v72 = 0;
      if ( m_nNoOfTriangles > 0 )
        goto LABEL_44;
LABEL_40:
      v65 = v278 + 1;
      if ( v278 + 1 == v70 )
        return;
      v59 = *((_BYTE *)m_pColData + 7);
    }
    v71 = (int)&m_pColData->m_modelSec[8 * ~v65 + 1 + v65];
    if ( v66 <= *(float *)v71 )
      goto LABEL_40;
    if ( v67 >= *(float *)(v71 + 12) )
      goto LABEL_40;
    if ( v68 <= *(float *)(v71 + 4) )
      goto LABEL_40;
    if ( v69 >= *(float *)(v71 + 16) )
      goto LABEL_40;
    v72 = *(__int16 *)(v71 + 24);
    m_nNoOfTriangles = *(__int16 *)(v71 + 26) + 1;
    if ( v72 >= m_nNoOfTriangles )
      goto LABEL_40;
LABEL_44:
    v279 = m_nNoOfTriangles;
    while ( 1 )
    {
      if ( fabsf(m_pColData->m_pTrianglePlaneArray[v72].m_compressedNormal.z) > 0.1 )
      {
        m_pTriangleArray = m_pColData->m_pTriangleArray;
        CCollisionData::GetTrianglePoint(m_pColData, &pt, m_pTriangleArray[v72].m_nIndex1);
        v75 = &m_pTriangleArray[v72];
        CCollisionData::GetTrianglePoint(m_pColData, &v281, v75->m_nIndex2);
        m_nIndex3 = v75->m_nIndex3;
        m_nNoOfTriangles = v279;
        CCollisionData::GetTrianglePoint(m_pColData, &v280, m_nIndex3);
        x = pt.x;
        v78 = v281.x;
        v79 = v280.x;
        if ( (pt.x > v67 || v280.x > v67) && (pt.x < v66 || v280.x < v66) )
        {
          y = pt.y;
          v81 = v281.y;
          v82 = v280.y;
          if ( (pt.y > v69 || v280.y > v69) && (pt.y < v68 || v280.y < v68) )
          {
            v83 = pt.z;
            if ( (pt.z < v62 || v280.z < v62) && (pt.z > v63 || v280.z > v63) )
            {
              v84 = v281.y - pt.y;
              v85 = v281.x - pt.x;
              v86 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[0].y;
              v87 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[0].x;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][3].x = *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[3].x;
              v88 = 0;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][2].x = *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[2].x;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x = *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[0].x;
              LOWORD(v89) = 0;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][1].x = *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points[1].x;
              v90 = 0;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].x = 0LL;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][1].x = 1065353216LL;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][2].x = 0x3F8000003F800000LL;
              *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][3].x = 0x3F80000000000000LL;
              v91 = 0;
              while ( 1 )
              {
                v93 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88].x;
                v94 = (float)(v84 * (float)(v87 - x)) - (float)(v85 * (float)(v86 - y));
                if ( v94 <= 0.0 )
                  break;
                if ( (unsigned __int16)v89 == 2 )
                {
                  v105 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v90].x;
                  v106 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v90].x;
                  v107 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88 - 1].x;
                  v108 = fabsf(
                           (float)(v84 * (float)(v107 - x))
                         - (float)(v85
                                 * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88 - 1].y
                                         - y)));
                  v109 = v108 / (float)(fabsf(v94) + v108);
                  v105[30] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].x
                                   * v109)
                           + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88 - 1].x
                                   * (float)(1.0 - v109));
                  v110 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88 - 1].y;
                  v111 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].y
                       * v109;
                  v106[30] = (float)(v109 * v87) + (float)((float)(1.0 - v109) * v107);
                  v112 = v93[1];
                  p_y = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].y;
                  v114 = v90 + 1;
                  v115 = (float)(v109 * v112)
                       + (float)((float)(1.0 - v109)
                               * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88 - 1].y);
                  v105[31] = v111 + (float)(v110 * (float)(1.0 - v109));
                  v105[33] = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].x;
                  v116 = 2;
                  v106[31] = v115;
                  goto LABEL_72;
                }
                if ( (__int16)v89 == 1 )
                {
                  v95 = v90;
LABEL_71:
                  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v95].x = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].x;
                  v116 = 1;
                  p_y = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v91].y;
                  v114 = v90;
LABEL_72:
                  v117 = 3 * v114;
                  v90 += v116;
                  v89 = 1;
                  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v117 / 3].y = *p_y;
                  v118 = (char *)CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List
                       + 4 * v117;
                  *((_DWORD *)v118 + 30) = LODWORD(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88].x);
                  *((_DWORD *)v118 + 31) = LODWORD(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88].y);
                  if ( v88 == 3 )
                    goto LABEL_75;
                  goto LABEL_59;
                }
                if ( !(_WORD)v89 )
                {
                  v95 = v90;
                  goto LABEL_71;
                }
                v89 = 1;
                if ( v88 == 3 )
                  goto LABEL_75;
LABEL_59:
                ++v91;
                v92 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88++].x;
                v87 = v92[3];
                v86 = v92[4];
              }
              if ( (unsigned __int16)v89 == 1 )
              {
                v96 = v90++;
                v97 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88 - 1].x;
                v98 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v96].x;
                v99 = fabsf(
                        (float)(v84 * (float)(v97 - x))
                      - (float)(v85
                              * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88 - 1].y
                                      - y)));
                v100 = v99 / (float)(fabsf(v94) + v99);
                v98[30] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].x
                                * v100)
                        + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88 - 1].x
                                * (float)(1.0 - v100));
                v101 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88 - 1].y;
                v102 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v96].x;
                v103 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v88].y
                     * v100;
                v102[30] = (float)(v100 * v87) + (float)((float)(1.0 - v100) * v97);
                v104 = (float)(v100 * v93[1])
                     + (float)((float)(1.0 - v100)
                             * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v88 - 1].y);
                v98[31] = v103 + (float)(v101 * (float)(1.0 - v100));
                v102[31] = v104;
              }
              v89 = 2;
              if ( v88 != 3 )
                goto LABEL_59;
LABEL_75:
              v119 = (float)(v84
                           * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x
                                   - x))
                   - (float)(v85
                           * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].y
                                   - y));
              if ( v89 == 2 && v119 > 0.0 || v89 == 1 && v119 <= 0.0 )
              {
                v120 = v90++;
                v121 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v120].x;
                v122 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v120].x;
                v123 = fabsf(
                         (float)(v84
                               * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][3].x
                                       - x))
                       - (float)(v85
                               * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][3].y
                                       - y)));
                v124 = v123 / (float)(fabsf(v119) + v123);
                v125 = (float)(v124
                             * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x)
                     + (float)((float)(1.0 - v124)
                             * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][3].x);
                v121[30] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].x
                                 * v124)
                         + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][3].x
                                 * (float)(1.0 - v124));
                v122[30] = v125;
                v126 = (float)(v124
                             * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].y)
                     + (float)((float)(1.0 - v124)
                             * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][3].y);
                v121[31] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].y
                                 * v124)
                         + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][3].y
                                 * (float)(1.0 - v124));
                v122[31] = v126;
              }
              if ( v90 >= 1 )
              {
                v84 = v82 - v81;
                v127 = 0;
                v85 = v79 - v78;
                v128 = v90;
                v129 = 0;
                v130 = 0;
                LOWORD(v131) = 0;
                v273 = v90;
                while ( 1 )
                {
                  v132 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127].x;
                  v133 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v127].x;
                  v134 = (float)(v84 * (float)(v133 - v78))
                       - (float)(v85
                               * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v127].y
                                       - v81));
                  if ( v134 <= 0.0 )
                  {
                    if ( (unsigned __int16)v131 == 1 )
                    {
                      v136 = v129;
                      v137 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v129].x;
                      v138 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127 + 9].x;
                      v139 = fabsf(
                               (float)(v84 * (float)(v138 - v78))
                             - (float)(v85
                                     * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127 + 9].y
                                             - v81)));
                      v140 = v139 / (float)(fabsf(v134) + v139);
                      *v137 = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].x
                                    * v140)
                            + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v127 + 9].x
                                    * (float)(1.0 - v140));
                      ++v129;
                      v137[1] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].y
                                      * v140)
                              + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v127 + 9].y
                                      * (float)(1.0 - v140));
                      v141 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v136].x;
                      *v141 = (float)(v140 * v133) + (float)((float)(1.0 - v140) * v138);
                      v90 = v273;
                      v141[1] = (float)(v140 * v132[31])
                              + (float)((float)(1.0 - v140)
                                      * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127 + 9].y);
                    }
                    v131 = 2;
                    goto LABEL_94;
                  }
                  if ( (unsigned __int16)v131 == 2 )
                  {
                    v142 = v129;
                    v143 = v129;
                    v144 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127 + 9].x;
                    v145 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v143].x;
                    v146 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v143].x;
                    v147 = fabsf(
                             (float)(v84 * (float)(v144 - v78))
                           - (float)(v85
                                   * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127 + 9].y
                                           - v81)));
                    v148 = v147 / (float)(fabsf(v134) + v147);
                    *v145 = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].x
                                  * v148)
                          + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v127 + 9].x
                                  * (float)(1.0 - v148));
                    *v146 = (float)(v148 * v133) + (float)((float)(1.0 - v148) * v144);
                    v149 = (float)(v148 * v132[31])
                         + (float)((float)(1.0 - v148)
                                 * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v127 + 9].y);
                    v145[1] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].y
                                    * v148)
                            + (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v127 + 9].y
                                    * (float)(1.0 - v148));
                    v146[1] = v149;
                    v150 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].y;
                    v145[3] = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].x;
                    v129 = v142 + 1;
                    v135 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v127].x;
                    v151 = 2;
                  }
                  else
                  {
                    v135 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v127].x;
                    if ( (__int16)v131 != 1 && (_WORD)v131 )
                    {
                      v131 = 1;
                      goto LABEL_94;
                    }
                    v142 = v129;
                    v151 = 1;
                    CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v129].x = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v127].x;
                    v150 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v130].y;
                  }
                  v152 = v129;
                  v153 = v142 + v151;
                  v131 = 1;
                  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v152].y = *v150;
                  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v152].x = v135;
                  CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v152].y = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v127].y;
                  v129 = v153;
                  v90 = v273;
LABEL_94:
                  ++v127;
                  --v128;
                  ++v130;
                  if ( !v128 )
                    goto LABEL_97;
                }
              }
              v131 = 0;
              v129 = 0;
LABEL_97:
              v154 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].x;
              v155 = (float)(v84
                           * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].x
                                   - v78))
                   - (float)(v85
                           * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].y
                                   - v81));
              if ( v131 == 2 && v155 > 0.0 || v131 == 1 && v155 <= 0.0 )
              {
                v156 = v129;
                v157 = 12 * v90 - 12;
                v158 = (float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x
                               + v157);
                v159 = *(float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].x
                                + v157);
                v160 = *(float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].y
                                + v157)
                     - v81;
                v161 = (float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][0].x
                               + v157);
                v162 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v156].x;
                v163 = fabsf((float)(v84 * (float)(v159 - v78)) - (float)(v85 * v160));
                v164 = v163 / (float)(fabsf(v155) + v163);
                *v162 = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][0].x
                              * v164)
                      + (float)(*v161 * (float)(1.0 - v164));
                v165 = v161[1];
                v166 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v156].x;
                v167 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][0].y;
                *v166 = (float)(v164 * v154) + (float)((float)(1.0 - v164) * v159);
                v168 = (float)(1.0 - v164) * v158[31];
                v129 = v156 + 1;
                v162[1] = (float)(v167 * v164) + (float)(v165 * (float)(1.0 - v164));
                v166[1] = (float)(v164
                                * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].y)
                        + v168;
              }
              if ( v129 >= 1 )
              {
                v84 = y - v82;
                v85 = x - v79;
                v169 = v129;
                v170 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].y;
                v171 = (float *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0];
                v172 = 0;
                v173 = 0;
                LOWORD(v174) = 0;
                v274 = v169;
                while ( 1 )
                {
                  v175 = *v171;
                  v176 = (float)(v84 * (float)(*v171 - v79)) - (float)(v85 * (float)(v171[1] - v82));
                  if ( v176 <= 0.0 )
                  {
                    if ( (unsigned __int16)v174 == 1 )
                    {
                      v180 = *(v171 - 3);
                      v181 = v172++;
                      v182 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v181].x;
                      v183 = fabsf((float)(v84 * (float)(v180 - v79)) - (float)(v85 * (float)(*(v171 - 2) - v82)));
                      v184 = v183 / (float)(fabsf(v176) + v183);
                      v182[30] = (float)(*(v170 - 1) * v184) + (float)(*(v170 - 4) * (float)(1.0 - v184));
                      v182[31] = (float)(*v170 * v184) + (float)(*(v170 - 3) * (float)(1.0 - v184));
                      v185 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v181].x;
                      v185[30] = (float)(v184 * v175) + (float)((float)(1.0 - v184) * v180);
                      v185[31] = (float)(v184 * v171[1]) + (float)((float)(1.0 - v184) * *(v171 - 2));
                    }
                    v174 = 2;
                    goto LABEL_117;
                  }
                  if ( (unsigned __int16)v174 == 2 )
                    break;
                  v177 = *v171;
                  if ( (__int16)v174 == 1 )
                  {
                    v178 = v172;
                    v179 = *(v170 - 1);
LABEL_114:
                    v187 = 1;
                    CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v178].x = v179;
                    v190 = v172;
                    v195 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v173].y;
LABEL_115:
                    v196 = v190;
                    v172 += v187;
                    CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v196].y = *v195;
                    v197 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v196].x;
                    v197[30] = v177;
                    v197[31] = v171[1];
                    goto LABEL_116;
                  }
                  if ( !(_WORD)v174 )
                  {
                    v178 = v172;
                    v179 = *(v170 - 1);
                    goto LABEL_114;
                  }
LABEL_116:
                  v174 = 1;
LABEL_117:
                  v170 += 3;
                  v171 += 3;
                  --v169;
                  ++v173;
                  if ( !v169 )
                  {
                    v129 = v274;
                    goto LABEL_120;
                  }
                }
                v186 = *(v171 - 3);
                v187 = 2;
                v188 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v172].x;
                v189 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v172].x;
                v190 = v172 + 1;
                v191 = fabsf((float)(v84 * (float)(v186 - v79)) - (float)(v85 * (float)(*(v171 - 2) - v82)));
                v192 = v191 / (float)(fabsf(v176) + v191);
                v193 = (float)(*(v170 - 1) * v192) + (float)(*(v170 - 4) * (float)(1.0 - v192));
                v189[30] = (float)(v192 * v175) + (float)((float)(1.0 - v192) * v186);
                v188[30] = v193;
                v194 = (float)(*v170 * v192) + (float)(*(v170 - 3) * (float)(1.0 - v192));
                v189[31] = (float)(v192 * v171[1]) + (float)((float)(1.0 - v192) * *(v171 - 2));
                v177 = *v171;
                v188[31] = v194;
                v188[33] = *(v170 - 1);
                v195 = v170;
                goto LABEL_115;
              }
              v174 = 0;
              v172 = 0;
LABEL_120:
              v198.n64_f32[1] = v84
                              * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x
                                      - v79);
              v199.n64_f32[1] = v198.n64_f32[1]
                              - (float)(v85
                                      * (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].y
                                              - v82));
              if ( v174 == 2 && v199.n64_f32[1] > 0.0 || v174 == 1 && v199.n64_f32[1] <= 0.0 )
              {
                v200 = 12 * v129 - 12;
                v201 = (float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x
                               + v200);
                v198.n64_u32[1] = *(_DWORD *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x
                                            + v200);
                v202 = *(float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].y
                                + v200);
                v203 = (float *)((char *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].x
                               + v200);
                v204 = v172++;
                v205 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v204].x;
                v206 = fabsf((float)(v84 * (float)(v198.n64_f32[1] - v79)) - (float)(v85 * (float)(v202 - v82)));
                v207 = v206 / (float)(fabsf(v199.n64_f32[1]) + v206);
                v208 = v207
                     * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].x;
                v199.n64_f32[1] = (float)(1.0 - v207) * v198.n64_f32[1];
                v205[30] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].x
                                 * v207)
                         + (float)(*v203 * (float)(1.0 - v207));
                v209 = v203[1];
                v210 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][v204].x;
                v205[31] = (float)(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][0].y
                                 * v207)
                         + (float)(v209 * (float)(1.0 - v207));
                v210[30] = v208 + v199.n64_f32[1];
                v210[31] = (float)(v207
                                 * CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[0][0].y)
                         + (float)((float)(1.0 - v207) * v201[1]);
              }
              v70 = v272;
              m_nNoOfTriangles = v279;
              if ( v172 >= 3 )
                break;
            }
          }
        }
      }
LABEL_173:
      if ( ++v72 == m_nNoOfTriangles )
        goto LABEL_40;
    }
    v211 = v64;
    v212 = v172;
    v213 = &m_pColData->m_pTrianglePlaneArray[v72].m_compressedNormal.x;
    v214 = *v213;
    v215 = v213[1];
    v216 = *v213 * x;
    v217 = v213[2];
    p_z = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].z;
    v219 = (float)(v216 + (float)(v215 * y)) + (float)(v217 * v83);
    do
    {
      --v212;
      *p_z = (float)-(float)((float)((float)(v214 * *(p_z - 2)) + (float)(v215 * *(p_z - 1))) - v219) / v217;
      p_z += 3;
    }
    while ( v212 );
    v220 = v277;
    v275 = v172;
    v221 = 0;
    v222 = v172;
    v223 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][0].z;
    do
    {
      v224 = &v220->m_pMat->xx;
      v225 = *(v223 - 2);
      if ( v224 )
      {
        v226 = v223 - 1;
        v227 = *(v223 - 1);
        v228 = v225 * *v224;
      }
      else
      {
        CPlaceable::AllocateMatrix(v220);
        CSimpleTransform::UpdateMatrix(v276, v277->m_pMat);
        v220 = v277;
        v227 = *(v223 - 1);
        v224 = &v277->m_pMat->xx;
        v226 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v221].y;
        v228 = v225 * *v224;
        if ( !v224 )
        {
          CPlaceable::AllocateMatrix(v277);
          CSimpleTransform::UpdateMatrix(v276, v277->m_pMat);
          v220 = v277;
          v224 = &v277->m_pMat->xx;
        }
        v172 = v275;
      }
      v229 = &v276->m_translate.x;
      if ( v224 )
        v229 = v224 + 12;
      *(v223 - 2) = (float)(v228 + (float)(v227 * v224[4])) + *v229;
      v230 = v220->m_pMat;
      if ( v230 )
      {
        v231 = *v226;
        v232 = v225 * v230->yx;
      }
      else
      {
        CPlaceable::AllocateMatrix(v220);
        CSimpleTransform::UpdateMatrix(v276, v277->m_pMat);
        v220 = v277;
        v231 = *v226;
        v230 = v277->m_pMat;
        v232 = v225 * v230->yx;
        if ( !v230 )
        {
          CPlaceable::AllocateMatrix(v277);
          CSimpleTransform::UpdateMatrix(v276, v277->m_pMat);
          v220 = v277;
          v230 = v277->m_pMat;
        }
        v172 = v275;
      }
      ++v221;
      v233 = v276;
      if ( v230 )
        v233 = (CSimpleTransform *)&v230->tx;
      v234 = v233->m_translate.y;
      v235 = v276;
      *v226 = (float)(v232 + (float)(v231 * v230->yy)) + v234;
      v236 = v220->m_pMat;
      if ( v236 )
        v235 = (CSimpleTransform *)&v236->tx;
      --v222;
      *v223 = v235->m_translate.z + *v223;
      v223 += 3;
    }
    while ( v222 );
    m_pColData = v271;
    *lightingMult = v271->m_pTriangleArray[v72].m_nLighting;
    if ( ppBunch )
    {
      v64 = v211;
      v70 = v272;
      m_nNoOfTriangles = v279;
      v237 = CShadows::pEmptyBunchList;
      v63 = v62 - ShadowDepth;
      if ( CShadows::pEmptyBunchList )
      {
        CShadows::pEmptyBunchList = CShadows::pEmptyBunchList->pNext;
        v237->pNext = *ppBunch;
        *ppBunch = v237;
        v237->NumPoints = v172;
        v238 = 0;
        v239 = 0;
        do
        {
          v240 = (char *)v237 + v238 * 12;
          v241 = *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v238].x;
          *((_DWORD *)v240 + 2) = LODWORD(CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v238].z);
          *(_QWORD *)v240 = v241;
          v242 = (char *)v237 + v239++;
          v243 = &CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[0][v238++].x;
          v242[90] = (unsigned int)(float)(v243[30] * 200.0);
          v242[97] = (unsigned int)(float)(v243[31] * 200.0);
          v70 = v272;
        }
        while ( v172 != v239 );
      }
      goto LABEL_173;
    }
    v64 = v211;
    v244 = 3 * v172 - 6;
    v267 = 3 * v172;
    if ( TempBufferIndicesStored + v244 >= 4096 )
    {
      RenderBuffer::RenderStuffInBuffer();
      v172 = v275;
    }
    v63 = v62 - ShadowDepth;
    v245 = TempBufferVerticesStored;
    if ( TempBufferVerticesStored + v172 >= 2048 )
    {
      RenderBuffer::RenderStuffInBuffer();
      v172 = v275;
      v245 = TempBufferVerticesStored;
    }
    v246 = 1.0;
    v270 = v245;
    v269 = v244;
    v268 = TempBufferIndicesStored;
    RenderBuffer::IndicesToBeStored = v244;
    RenderBuffer::VerticesToBeStored = v172;
    if ( (unsigned __int8)ShadowType != 2 )
    {
      v198.n64_f32[0] = (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam) * 0.6) + 0.4;
      v199.n64_f32[0] = (float)((float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                              * (float)((float)((float)(*lightingMult >> 4) * 0.5) / 15.0))
                                      + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                              * (float)((float)((float)(*lightingMult & 0xF) * 0.5) / 15.0)))
                              * 0.7)
                      + 0.3;
      LODWORD(v246) = vmin_f32(v198, v199).n64_u32[0];
    }
    v247 = 0;
    v248 = v275;
    v249 = (unsigned int)(float)(v246 * (float)Red) | (Brightness << 24) | ((unsigned int)(float)(v246 * (float)Blue) << 16) | ((unsigned int)(float)(v246 * (float)Green) << 8);
    v250 = &TempVertexBuffer;
    do
    {
      v251 = &v250->m_3d[v270];
      --v248;
      v252 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v247 / 0xC].x;
      v251->color = (RwRGBA_0)v249;
      v251->texCoords.u = v252 * TextureScale;
      v251->texCoords.v = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture[1][v247 / 0xC].y
                        * TextureScale;
      v253 = *(_QWORD *)&CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v247 / 0xC].x;
      v254 = CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List[1][v247 / 0xC].z
           + v64;
      LODWORD(v251->position.x) = v253;
      v255 = 3 * v247;
      v250 = (VertexBuffer *)((char *)v250 + 36);
      v247 += 12;
      *(float *)((char *)&TempVertexBuffer.m_2d[-2633].x + 36 * v270 + v255) = *((float *)&v253 + 1);
      v251->position.z = v254;
    }
    while ( v248 );
    if ( v269 <= 0 )
    {
      v70 = v272;
      v256 = v269 + v268;
      v260 = v275;
      v261 = v270;
    }
    else
    {
      qmemcpy(&TempBufferRenderIndexList[v268], ShadowIndexList, 2 * v267 - 12);
      v256 = v269 + v268;
      v257 = v268 + 1;
      if ( v269 + v268 > v268 + 1 )
        v257 = v269 + v268;
      v70 = v272;
      v258 = v257 - v268;
      if ( (unsigned int)(v257 - v268) >= 8 )
      {
        v262 = v258 & 0xFFFFFFF8;
        v261 = v270;
        if ( (v258 & 0xFFFFFFF8) != 0 )
        {
          v259 = v268 + v262;
          v260 = v275;
          v263 = vdupq_n_s32(v270);
          v264 = (uint16x4_t *)&TempBufferRenderIndexList[v268];
          v265 = v258 & 0xFFFFFFF8;
          do
          {
            v265 -= 8;
            v266 = vmovn_s32(vaddw_u16(v263, v264[1])).n64_u64[0];
            v264->n64_u64[0] = vmovn_s32(vaddw_u16(v263, (uint16x4_t)v264->n64_u64[0])).n64_u64[0];
            v264[1].n64_u64[0] = v266;
            v264 += 2;
          }
          while ( v265 );
          v70 = v272;
          if ( v258 == v262 )
            goto LABEL_172;
        }
        else
        {
          v259 = v268;
          v260 = v275;
        }
      }
      else
      {
        v259 = v268;
        v260 = v275;
        v261 = v270;
      }
      do
        TempBufferRenderIndexList[v259++] += v261;
      while ( v259 < v256 );
    }
LABEL_172:
    m_nNoOfTriangles = v279;
    TempBufferVerticesStored = v260 + v261;
    TempBufferIndicesStored = v256;
    goto LABEL_173;
  }
}
// 5BCC3A: conditional instruction was optimized away because r12.4>=3
// 5BCDC6: conditional instruction was optimized away because r12.4>=3
// 5BCEFA: conditional instruction was optimized away because r12.4>=3
// 5BBE7C: variable 'v22' is possibly undefined
// 5BBE7C: variable 'v23' is possibly undefined
// 5BBE74: variable 'v24' is possibly undefined
// 5BBE74: variable 'v25' is possibly undefined
// 5BBE3C: variable 'v19' is possibly undefined
// 5BBE3C: variable 'v20' is possibly undefined
// 5BBE68: variable 'v21' is possibly undefined
// A53628: using guessed type char `guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::List;
// A5371C: using guessed type char `guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Texture;
// A53750: using guessed type char `guard variable for'CShadows::CastShadowEntityXY(CEntity *,float,float,float,float,CVector *,float,float,float,float,short,unsigned char,unsigned char,unsigned char,float,float,CPolyBunch **,unsigned char *,int)::Points;
// 5BBBEC: using guessed type int Brightness_0;
// 5BBBEC: using guessed type unsigned int Red_0;
// 5BBBEC: using guessed type unsigned int Green_0;

//----- (005BD27C) --------------------------------------------------------
void CShadows::UpdateStaticShadows()
{
  float v0; // s0
  int v1; // r6
  UInt32 v2; // r12
  CStaticShadow *v3; // r4
  CPolyBunch **p_pFirstBunch; // r4
  CPolyBunch *v5; // r8
  CPolyBunch *pFirstBunch; // t1
  _BYTE *v7; // r5
  CPolyBunch *v8; // r0
  CPolyBunch *v9; // r3

  v0 = 15.0;
  v1 = 0;
  if ( MobileSettings::settings[5].value == 2 )
    v0 = 32.0;
  MAX_DISTANCE_PED_SHADOWS = v0;
  v2 = CTimer::m_snTimeInMilliseconds;
  MAX_DISTANCE_PED_SHADOWS_SQR = v0 * v0;
  do
  {
    v3 = &CShadows::aStaticShadows[v1];
    pFirstBunch = v3->pFirstBunch;
    p_pFirstBunch = &v3->pFirstBunch;
    v5 = pFirstBunch;
    v7 = (char *)p_pFirstBunch + 54;
    if ( pFirstBunch
      && !*v7
      && (!CShadows::aStaticShadows[v1].bFromTree || v2 > CShadows::aStaticShadows[v1].TimeAdded + 5000) )
    {
      v8 = CShadows::pEmptyBunchList;
      CShadows::pEmptyBunchList = v5;
      do
      {
        v9 = v5;
        v5 = v5->pNext;
      }
      while ( v5 );
      v9->pNext = v8;
      *p_pFirstBunch = 0;
      CShadows::aStaticShadows[v1].ID = 0;
    }
    ++v1;
    *v7 = 0;
  }
  while ( v1 != 48 );
}

//----- (005BD370) --------------------------------------------------------
void CShadows::UpdatePermanentShadows()
{
  float32x2_t v0; // d1
  unsigned __int64 v1; // d8
  int32 value; // r4
  int32 TxdSlot; // r0
  const char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  int i; // r10
  CPermanentShadow *v11; // r4
  __int64 v12; // kr00_8
  unsigned int v13; // r2
  float v14; // s0
  int j; // r11
  CPermanentShadow *v16; // r1
  UInt8 *p_Type; // r1
  int Type; // t1
  float32x2_t v19; // d0
  int v20; // r1
  CPermanentShadow *v21; // r2
  CPermanentShadow *v22; // r8
  float32x2_t *p_y; // r6
  int v24; // r0
  int v25; // r3
  bool v26; // zf
  float32x2_t v27; // d16
  unsigned __int64 v28; // d2
  bool v29; // nf
  CPermanentShadow *v30; // r4
  int v31; // r9
  CPermanentShadow *v32; // r5
  float x; // r1
  __int64 v34; // r2
  float v35; // s8
  float v36; // s2
  int v37; // r0
  float v38; // s0
  int v39; // r2
  bool v40; // zf
  float y; // s14
  float v42; // s12
  int v43; // r0
  float v44; // r1
  CPermanentShadow *v45; // r0
  __int64 v46; // r2
  int k; // r0
  __int64 v48; // [sp+10h] [bp-68h]
  __int64 v49; // [sp+18h] [bp-60h]

  value = MobileSettings::settings[5].value;
  if ( MobileSettings::settings[5].value
    && MobileSettings::settings[5].value != CShadows::UpdatePermanentShadows(void)::lastSetting )
  {
    CTxdStore::PushCurrentTxd();
    TxdSlot = CTxdStore::FindTxdSlot("particle");
    CTxdStore::SetCurrentTxd(TxdSlot, 0);
    v4 = "shad_car_dark";
    if ( value != 2 )
      v4 = "shad_car";
    gpShadowCarTex = RwTextureRead((const RwChar *)v4, 0);
    v5 = "shad_ped_dark";
    if ( value != 2 )
      v5 = "shad_ped";
    gpShadowPedTex = RwTextureRead((const RwChar *)v5, 0);
    v6 = "shad_heli_dark";
    if ( value != 2 )
      v6 = "shad_heli";
    gpShadowHeliTex = RwTextureRead((const RwChar *)v6, 0);
    v7 = "shad_bike_dark";
    if ( value != 2 )
      v7 = "shad_bike";
    gpShadowBikeTex = RwTextureRead((const RwChar *)v7, 0);
    v8 = "shad_rcbaron_dark";
    if ( value != 2 )
      v8 = "shad_rcbaron";
    gpShadowBaronTex = RwTextureRead((const RwChar *)v8, 0);
    v9 = "lamp_shad_64_dark";
    if ( value != 2 )
      v9 = "lamp_shad_64";
    gpPostShadowTex = RwTextureRead((const RwChar *)v9, 0);
    CTxdStore::PopCurrentTxd();
    CShadows::UpdatePermanentShadows(void)::lastSetting = value;
  }
  for ( i = 0; i != 48; ++i )
  {
    v11 = &CShadows::aPermanentShadows[i];
    if ( CShadows::aPermanentShadows[i].Type )
    {
      v12 = *(_QWORD *)&CShadows::aPermanentShadows[i].StartTime;
      v13 = CTimer::m_snTimeInMilliseconds - v12;
      if ( CTimer::m_snTimeInMilliseconds - (unsigned int)v12 >= HIDWORD(v12) )
      {
        v11->Type = 0;
      }
      else
      {
        if ( v13 >= (unsigned int)(3 * HIDWORD(v12)) >> 2 )
        {
          v14 = 1.0 - (float)((float)(v13 - ((unsigned int)(3 * HIDWORD(v12)) >> 2)) / (float)(HIDWORD(v12) >> 2));
          v0.n64_f32[1] = (float)CShadows::aPermanentShadows[i].Green;
          LODWORD(v48) = (int)(float)(v14 * (float)CShadows::aPermanentShadows[i].Brightness);
          HIDWORD(v48) = (unsigned int)(float)(v14 * (float)CShadows::aPermanentShadows[i].Red);
          LODWORD(v49) = (unsigned int)(float)(v14 * v0.n64_f32[1]);
          HIDWORD(v49) = (unsigned int)(float)(v14 * (float)CShadows::aPermanentShadows[i].Blue);
        }
        else
        {
          LODWORD(v48) = CShadows::aPermanentShadows[i].Brightness;
          HIDWORD(v48) = CShadows::aPermanentShadows[i].Red;
          LODWORD(v49) = CShadows::aPermanentShadows[i].Green;
          HIDWORD(v49) = CShadows::aPermanentShadows[i].Blue;
        }
        if ( !CShadows::StoreStaticShadow(
                (u_native)&CShadows::aPermanentShadows[i],
                CShadows::aPermanentShadows[i].Type,
                CShadows::aPermanentShadows[i].pTex,
                &CShadows::aPermanentShadows[i].Coors,
                CShadows::aPermanentShadows[i].ForwardX,
                CShadows::aPermanentShadows[i].ForwardY,
                CShadows::aPermanentShadows[i].SideX,
                CShadows::aPermanentShadows[i].SideY,
                v48,
                v49,
                CShadows::aPermanentShadows[i].ShadowDepth,
                1.0,
                40.0,
                0,
                0.0)
          && v11->Type != 8 )
        {
          v11->Type = 0;
        }
      }
    }
  }
  if ( !((unsigned __int8)CTimer::m_FrameCounter << 30) )
  {
    LODWORD(v1) = 3.0;
    for ( j = 0; j != 48; ++j )
    {
      v16 = &CShadows::aPermanentShadows[j];
      Type = v16->Type;
      p_Type = &v16->Type;
      if ( Type == 5 )
      {
        v19.n64_u64[0] = v1;
        *p_Type = 6;
        v20 = 0;
        v21 = CShadows::aPermanentShadows;
        v22 = &CShadows::aPermanentShadows[j];
        p_y = (float32x2_t *)&v22->Coors.y;
        v22->StartTime = CTimer::m_snTimeInMilliseconds;
        v22->Duration = 2000;
        v24 = -1;
        do
        {
          v25 = v21->Type;
          v26 = v25 == 8;
          if ( v25 != 8 )
            v26 = v25 == 4;
          if ( v26 )
          {
            v27.n64_u64[0] = vsub_f32((float32x2_t)p_y->n64_u64[0], *(float32x2_t *)&v21->Coors.y).n64_u64[0];
            v28 = vmul_f32(v27, v27).n64_u64[0];
            v0.n64_f32[0] = sqrtf(
                              (float)((float)((float)(v22->Coors.x - v21->Coors.x) * (float)(v22->Coors.x - v21->Coors.x))
                                    + *(float *)&v28)
                            + *((float *)&v28 + 1));
            v29 = v0.n64_f32[0] < v19.n64_f32[0];
            v19.n64_u64[0] = vmin_f32(v0, v19).n64_u64[0];
            if ( v29 )
              v24 = v20;
          }
          ++v20;
          ++v21;
        }
        while ( v20 != 48 );
        if ( v24 > -1 )
        {
          v30 = CShadows::aPermanentShadows;
          v31 = 0;
          v32 = &CShadows::aPermanentShadows[v24];
          x = v32->Coors.x;
          v34 = *(_QWORD *)&v32->Coors.y;
          v32->Type = 7;
          CFireManager::StartFire(&gFireManager, x, *(float *)&v34, *((float *)&v34 + 1), 1.8, 0, 0, 0x7D0u, 0);
          v35 = 3.0;
          v36 = v22->Coors.x;
          v37 = -1;
          v38 = p_y->n64_f32[0];
          do
          {
            v39 = v30->Type;
            v40 = v39 == 8;
            if ( v39 != 8 )
              v40 = v39 == 4;
            if ( v40 )
            {
              y = v30->Coors.y;
              v0.n64_f32[1] = (float)(v36 - v30->Coors.x) * (float)(v36 - v30->Coors.x);
              v42 = sqrtf(
                      (float)(v0.n64_f32[1] + (float)((float)(v38 - y) * (float)(v38 - y)))
                    + (float)((float)(v22->Coors.z - v30->Coors.z) * (float)(v22->Coors.z - v30->Coors.z)));
              if ( v42 < v35
                && (float)((float)((float)(v32->Coors.x - v22->Coors.x) * (float)(v30->Coors.x - v36))
                         + (float)((float)(v32->Coors.y - p_y->n64_f32[0]) * (float)(y - v38))) < 0.0 )
              {
                v37 = v31;
                v35 = v42;
              }
            }
            ++v31;
            ++v30;
          }
          while ( v31 != 48 );
          if ( v37 > -1 )
          {
            v43 = v37;
            v44 = CShadows::aPermanentShadows[v43].Coors.x;
            v45 = &CShadows::aPermanentShadows[v43];
            v46 = *(_QWORD *)&v45->Coors.y;
            v45->Type = 7;
            CFireManager::StartFire(&gFireManager, v44, *(float *)&v46, *((float *)&v46 + 1), 1.8, 0, 0, 0x7D0u, 0);
          }
        }
      }
    }
    for ( k = 0; k != 48; ++k )
    {
      if ( CShadows::aPermanentShadows[k].Type == 7 )
        CShadows::aPermanentShadows[k].Type = 5;
    }
  }
}
// 5BD6AE: variable 'v1' is possibly undefined
// 5BD710: variable 'v0' is possibly undefined

//----- (005BD96C) --------------------------------------------------------
void __fastcall CShadows::RemoveOilInArea(float MinX, float MaxX, float MinY, float MaxY)
{
  int i; // r0
  int Type; // r4
  bool v7; // zf
  float x; // s8
  float y; // s8

  for ( i = 0; i != 48; ++i )
  {
    Type = CShadows::aPermanentShadows[i].Type;
    v7 = Type == 8;
    if ( Type != 8 )
      v7 = Type == 4;
    if ( v7 )
    {
      x = CShadows::aPermanentShadows[i].Coors.x;
      if ( x > MinX && x < MaxX )
      {
        y = CShadows::aPermanentShadows[i].Coors.y;
        if ( y > MinY && y < MaxY )
          CShadows::aPermanentShadows[i].Type = 0;
      }
    }
  }
}

//----- (005BD9FC) --------------------------------------------------------
void __fastcall CShadows::GunShotSetsOilOnFire(const CVector *pShotStart, const CVector *pShotEnd)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d9
  __int64 v4; // d16
  int v5; // r6
  int v6; // r4
  __int64 v7; // d16
  CPermanentShadow *v8; // r5
  int Type; // r0
  bool v10; // zf
  bool v11; // nf
  CPermanentShadow *v12; // r5
  float x; // r1
  __int64 v14; // r2
  CVector pPoint; // [sp+18h] [bp-58h] BYREF
  CVector pVecEnd; // [sp+28h] [bp-48h] BYREF
  CVector pVecStart; // [sp+38h] [bp-38h] BYREF

  v4 = *(_QWORD *)&pShotStart->x;
  v3.n64_u32[0] = 1.0;
  pVecStart.z = pShotStart->z;
  *(_QWORD *)&pVecStart.x = v4;
  v5 = 0;
  v6 = -1;
  pVecEnd.z = pShotEnd->z;
  v7 = *(_QWORD *)&pShotEnd->x;
  v8 = CShadows::aPermanentShadows;
  pVecStart.z = pVecStart.z * 0.27;
  *(_QWORD *)&pVecEnd.x = v7;
  pVecEnd.z = pVecEnd.z * 0.27;
  do
  {
    Type = v8->Type;
    v10 = Type == 8;
    if ( Type != 8 )
      v10 = Type == 4;
    if ( v10 )
    {
      pPoint = v8->Coors;
      pPoint.z = pPoint.z * 0.27;
      v2.n64_u32[0] = CCollision::DistToLine(&pVecStart, &pVecEnd, &pPoint);
      v11 = v2.n64_f32[0] < v3.n64_f32[0];
      v3.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
      if ( v11 )
        v6 = v5;
    }
    ++v5;
    ++v8;
  }
  while ( v5 != 48 );
  if ( v6 > -1 )
  {
    v12 = &CShadows::aPermanentShadows[v6];
    x = v12->Coors.x;
    v14 = *(_QWORD *)&v12->Coors.y;
    v12->Type = 5;
    CFireManager::StartFire(&gFireManager, x, *(float *)&v14, *((float *)&v14 + 1), 1.8, 0, 0, 0x7D0u, 0);
  }
}
// 5BDA8C: variable 'v2' is possibly undefined
// 5BDA8C: variable 'v3' is possibly undefined

//----- (005BDB14) --------------------------------------------------------
void CShadows::RenderExtraPlayerShadows()
{
  CVehicle *PlayerVehicle; // r0
  CEntity *v1; // r4
  bool v2; // zf
  unsigned int v3; // r0
  Int32 v4; // r8
  bool *p_bCastsShadowFromPlayerCarAndPed; // r6
  float v6; // s24
  float v7; // s22
  float v8; // s26
  float v9; // s0
  int v10; // r10
  CVehicle *v11; // r0
  CMatrix *m_pMat; // r1
  float v13; // s26
  CSimpleTransform *p_tx; // r2
  RwReal z; // r11
  float x; // s28
  float y; // s30
  float v18; // s17
  float v19; // s0
  float v20; // s17
  float v21; // s19
  float v22; // s21
  CColModel *ColModel; // r0
  float *p_xx; // r2
  float v25; // s0
  float v26; // s12
  float v27; // s14
  float v28; // s4
  RwTexture_0 *v29; // r1
  float v30; // s3
  float v31; // s7
  float v32; // s0
  float v33; // s2
  float v34; // s6
  float v35; // s8
  float v36; // s10
  CStoredShadow *v37; // r3
  float v38; // s4
  UInt16 v39; // r0
  char v40; // r2
  float v41; // s4
  CStoredShadow *v42; // r3
  char v43; // r2
  CVector v44; // [sp+24h] [bp-6Ch] BYREF

  if ( CTimeCycle::m_CurrentColours.m_nLightShadowStrength )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    v1 = PlayerVehicle;
    v2 = PlayerVehicle == 0;
    if ( PlayerVehicle )
      v2 = PlayerVehicle->m_nModelIndex == 441;
    if ( !v2 && CVehicle::GetVehicleAppearance(PlayerVehicle) != APR_BIKE )
    {
      v3 = (unsigned int)v1[24]._vptr$CPlaceable;
      if ( (v3 > 9 || ((1 << v3) & 0x320) == 0) && CPointLights::NumLights >= 1 )
      {
        v4 = 0;
        p_bCastsShadowFromPlayerCarAndPed = &CPointLights::aLights[0].bCastsShadowFromPlayerCarAndPed;
        do
        {
          if ( *(p_bCastsShadowFromPlayerCarAndPed - 2)
            || !*p_bCastsShadowFromPlayerCarAndPed
            || *(float *)(p_bCastsShadowFromPlayerCarAndPed - 18) == 0.0
            && *(float *)(p_bCastsShadowFromPlayerCarAndPed - 14) == 0.0
            && *(float *)(p_bCastsShadowFromPlayerCarAndPed - 10) == 0.0 )
          {
            goto LABEL_28;
          }
          FindPlayerCoors(&v44, -1);
          v6 = *(float *)(p_bCastsShadowFromPlayerCarAndPed - 42) - v44.y;
          v7 = *(float *)(p_bCastsShadowFromPlayerCarAndPed - 46) - v44.x;
          v8 = sqrtf(
                 (float)((float)(v7 * v7) + (float)(v6 * v6))
               + (float)((float)(*(float *)(p_bCastsShadowFromPlayerCarAndPed - 38) - v44.z)
                       * (float)(*(float *)(p_bCastsShadowFromPlayerCarAndPed - 38) - v44.z)));
          v9 = *(float *)(p_bCastsShadowFromPlayerCarAndPed - 22);
          if ( v8 >= v9 )
            goto LABEL_28;
          if ( v8 >= (float)(v9 * 0.5) )
            v10 = (int)(float)((float)(1.0 - (float)((float)((float)(v8 + v8) - v9) / v9))
                             * (float)(5 * CTimeCycle::m_CurrentColours.m_nLightShadowStrength / 8));
          else
            v10 = 5 * CTimeCycle::m_CurrentColours.m_nLightShadowStrength / 8;
          v11 = FindPlayerVehicle(-1, 0);
          m_pMat = v11->m_pMat;
          v13 = 1.0 / v8;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &v11->m_transform;
          z = p_tx->m_translate.z;
          x = p_tx->m_translate.x;
          y = p_tx->m_translate.y;
          v18 = CEntity::GetColModel(v1)->m_boxBound.m_vecMax.y;
          v19 = v18 - CEntity::GetColModel(v1)->m_boxBound.m_vecMin.y;
          v20 = CEntity::GetColModel(v1)->m_boxBound.m_vecMax.x;
          v21 = v19 * 0.5;
          v22 = CEntity::GetColModel(v1)->m_boxBound.m_vecMin.x;
          ColModel = CEntity::GetColModel(v1);
          p_xx = &v1->m_pMat->xx;
          v25 = (float)(v19 * 0.5) - ColModel->m_boxBound.m_vecMax.y;
          v26 = p_xx[4];
          v27 = p_xx[5];
          v28 = (float)(v20 - v22) * 0.5;
          v29 = gpShadowCarTex;
          v30 = v25 * v27;
          v31 = v25 * v26;
          v32 = v21 * v27;
          v33 = v21 * v26;
          v34 = v28 * *p_xx;
          v35 = (float)(y - (float)((float)(v6 * v13) * 1.2)) - v30;
          v36 = (float)(x - (float)((float)(v7 * v13) * 1.2)) - v31;
          if ( p_xx[10] <= 0.0 )
          {
            if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
            {
              v41 = -(float)(v28 * p_xx[1]);
              v42 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
              v39 = CShadows::ShadowsStoredToBeRendered + 1;
              v42->Coors.x = v36;
              v42->Coors.y = v35;
              v42->Coors.z = z;
              v42->ForwardX = v33;
              v42->ForwardY = v32;
              v42->SideX = -v34;
              v42->SideY = v41;
              v42->Brightness = v10;
              *(_DWORD *)&v42->Type = 1;
              v43 = *((_BYTE *)v42 + 50);
              v42->ShadowDepth = 4.5;
              v42->TextureScale = 1.0;
              v42->pTex = v29;
              v42->pRealTimeShadow = 0;
              *((_BYTE *)v42 + 50) = v43 & 0xFA;
              goto LABEL_26;
            }
          }
          else if ( CShadows::ShadowsStoredToBeRendered <= 0x2Fu )
          {
            v37 = &CShadows::asShadowsStored[CShadows::ShadowsStoredToBeRendered];
            v38 = v28 * p_xx[1];
            v39 = CShadows::ShadowsStoredToBeRendered + 1;
            v37->Coors.x = v36;
            v37->Coors.y = v35;
            v37->Coors.z = z;
            v37->ForwardX = v33;
            v37->ForwardY = v32;
            v37->SideX = v34;
            v37->SideY = v38;
            v37->Brightness = v10;
            *(_DWORD *)&v37->Type = 1;
            v40 = *((_BYTE *)v37 + 50);
            v37->ShadowDepth = 4.5;
            v37->TextureScale = 1.0;
            v37->pTex = v29;
            v37->pRealTimeShadow = 0;
            *((_BYTE *)v37 + 50) = v40 & 0xFA;
LABEL_26:
            CShadows::ShadowsStoredToBeRendered = v39;
          }
LABEL_28:
          ++v4;
          p_bCastsShadowFromPlayerCarAndPed += 48;
        }
        while ( v4 < CPointLights::NumLights );
      }
    }
  }
}

//----- (005BDEC0) --------------------------------------------------------
void CShadows::TidyUpShadows()
{
  CShadows::aPermanentShadows[1].Type = 0;
  CShadows::aPermanentShadows[0].Type = 0;
  CShadows::aPermanentShadows[2].Type = 0;
  CShadows::aPermanentShadows[3].Type = 0;
  CShadows::aPermanentShadows[4].Type = 0;
  CShadows::aPermanentShadows[5].Type = 0;
  CShadows::aPermanentShadows[6].Type = 0;
  CShadows::aPermanentShadows[7].Type = 0;
  CShadows::aPermanentShadows[8].Type = 0;
  CShadows::aPermanentShadows[9].Type = 0;
  CShadows::aPermanentShadows[10].Type = 0;
  CShadows::aPermanentShadows[11].Type = 0;
  CShadows::aPermanentShadows[12].Type = 0;
  CShadows::aPermanentShadows[13].Type = 0;
  CShadows::aPermanentShadows[14].Type = 0;
  CShadows::aPermanentShadows[15].Type = 0;
  CShadows::aPermanentShadows[16].Type = 0;
  CShadows::aPermanentShadows[17].Type = 0;
  CShadows::aPermanentShadows[19].Type = 0;
  CShadows::aPermanentShadows[18].Type = 0;
  CShadows::aPermanentShadows[20].Type = 0;
  CShadows::aPermanentShadows[21].Type = 0;
  CShadows::aPermanentShadows[22].Type = 0;
  CShadows::aPermanentShadows[23].Type = 0;
  CShadows::aPermanentShadows[24].Type = 0;
  CShadows::aPermanentShadows[25].Type = 0;
  CShadows::aPermanentShadows[26].Type = 0;
  CShadows::aPermanentShadows[27].Type = 0;
  CShadows::aPermanentShadows[28].Type = 0;
  CShadows::aPermanentShadows[29].Type = 0;
  CShadows::aPermanentShadows[30].Type = 0;
  CShadows::aPermanentShadows[31].Type = 0;
  CShadows::aPermanentShadows[32].Type = 0;
  CShadows::aPermanentShadows[33].Type = 0;
  CShadows::aPermanentShadows[34].Type = 0;
  CShadows::aPermanentShadows[35].Type = 0;
  CShadows::aPermanentShadows[36].Type = 0;
  CShadows::aPermanentShadows[38].Type = 0;
  CShadows::aPermanentShadows[37].Type = 0;
  CShadows::aPermanentShadows[39].Type = 0;
  CShadows::aPermanentShadows[40].Type = 0;
  CShadows::aPermanentShadows[41].Type = 0;
  CShadows::aPermanentShadows[42].Type = 0;
  CShadows::aPermanentShadows[43].Type = 0;
  CShadows::aPermanentShadows[44].Type = 0;
  CShadows::aPermanentShadows[45].Type = 0;
  CShadows::aPermanentShadows[46].Type = 0;
  CShadows::aPermanentShadows[47].Type = 0;
}

//----- (005BDF90) --------------------------------------------------------
void __fastcall CShadows::RenderIndicatorShadow(
        u_native ID,
        UInt8 Type,
        RwTexture_0 *pTexture,
        CVector *pCoors,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        Int16 Brightness)
{
  float32x2_t v9; // d0
  float32x2_t v10; // d2
  __int64 v12; // d16
  float v13; // s16
  CVector vecPosition; // [sp+20h] [bp-38h] BYREF

  v10.n64_f32[0] = ForwardX;
  v9.n64_f32[0] = -SideY;
  v12 = *(_QWORD *)&pCoors->x;
  vecPosition.z = pCoors->z;
  v13 = vmax_f32(v9, v10).n64_f32[0];
  *(_QWORD *)&vecPosition.x = v12;
  C3dMarkers::PlaceMarkerSet(
    ID,
    1u,
    &vecPosition,
    v13 * 0.8,
    COLMISSIONMARKER._anon_0._anon_0.red,
    COLMISSIONMARKER._anon_0._anon_0.green,
    COLMISSIONMARKER._anon_0._anon_0.blue,
    0xFFu,
    0x800u,
    0.2,
    0);
  C3dMarkers::PlaceMarkerSet(
    ID,
    1u,
    &vecPosition,
    v13 * 0.9,
    COLMISSIONMARKER._anon_0._anon_0.red,
    COLMISSIONMARKER._anon_0._anon_0.green,
    COLMISSIONMARKER._anon_0._anon_0.blue,
    0xFFu,
    0x800u,
    0.2,
    0);
  C3dMarkers::PlaceMarkerSet(
    ID,
    1u,
    &vecPosition,
    v13,
    COLMISSIONMARKER._anon_0._anon_0.red,
    COLMISSIONMARKER._anon_0._anon_0.green,
    COLMISSIONMARKER._anon_0._anon_0.blue,
    0xFFu,
    0x800u,
    0.2,
    0);
}
// 5BDFD2: variable 'v9' is possibly undefined
// 5BDFD2: variable 'v10' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005BE060) --------------------------------------------------------
void __fastcall CShadows::CastShadowEntityXYZ(
        CEntity *pEntity,
        CVector *pShadowPos,
        float ForwardX,
        float ForwardY,
        float SideX,
        float SideY,
        Int16 Brightness,
        UInt8 Red,
        UInt8 Green,
        UInt8 Blue,
        float ShadowDepth,
        float TextureScale,
        CPolyBunch **ppBunch,
        CRealTimeShadow *pRealTimeShadow,
        UInt8 *lightingMult)
{
  CShadowCamera *ShadowCamera; // r9
  CColModel *m_pColModel; // r0
  const CCollisionData *m_pColData; // r4
  _QWORD *parent; // r0
  __int64 v23; // d16
  __int64 v24; // d17
  __int64 v25; // d18
  __int64 v26; // d19
  double *v27; // r1
  __int64 v28; // d23
  double v29; // d20
  __int64 v30; // d21
  CMatrix *m_pMat; // r0
  float x; // s0
  CMatrix *v33; // r0
  float v34; // s20
  __int64 v35; // d16
  float radius; // s18
  float v37; // s0
  int v38; // r8
  int v39; // r5
  int v40; // r9
  CColTriangle *m_pTriangleArray; // r0
  int32 m_nIndex1_low; // r2
  CColTriangle *v43; // r0
  int32 m_nIndex3_low; // r10
  int32 m_nIndex2_low; // r11
  float *p_x; // r0
  float v47; // s26
  float v48; // s24
  float32x4_t v49; // q0
  float v50; // s22
  float32x4_t v51; // q1
  float32x4_t v52; // q8
  float32x4_t v53; // q8
  float32x4_t v54; // q0
  float32x4_t v55; // q1
  Int32 v56; // r3
  unsigned int v57; // r0
  unsigned int v58; // lr
  unsigned __int64 v59; // kr10_8
  RwIm3DVertex *v60; // r2
  unsigned __int32 v61; // r12
  unsigned __int64 v62; // kr00_8
  unsigned __int64 v63; // kr08_8
  RwReal y; // r0
  float v65; // r1
  float v66; // r0
  float v67; // s0
  unsigned int v68; // r1
  Int32 v69; // lr
  int v70; // r0
  float v71; // s0
  float v72; // s0
  unsigned int v73; // r1
  float v74; // s0
  float v75; // s0
  unsigned int v76; // r1
  RwImVertexIndex *v77; // r0
  float v78; // [sp+8h] [bp-2E8h]
  float v79; // [sp+Ch] [bp-2E4h]
  Int32 v80; // [sp+18h] [bp-2D8h]
  float32x4_t pt; // [sp+70h] [bp-280h] BYREF
  unsigned __int64 v82; // [sp+80h] [bp-270h]
  CVector v83; // [sp+88h] [bp-268h] BYREF
  CColSphere sphere; // [sp+94h] [bp-25Ch] BYREF
  RwV3d_0 pointsOut; // [sp+A8h] [bp-248h] BYREF
  float v86; // [sp+B4h] [bp-23Ch]
  RwMatrix dst; // [sp+B8h] [bp-238h] BYREF
  RwMatrix pMatrix; // [sp+F8h] [bp-1F8h] BYREF
  RwV3d_0 translation; // [sp+138h] [bp-1B8h] BYREF
  RwV3d_0 scale; // [sp+144h] [bp-1ACh] BYREF
  double v91; // [sp+150h] [bp-1A0h]
  float v92; // [sp+158h] [bp-198h]
  RwMatrix v93; // [sp+15Ch] [bp-194h] BYREF
  unsigned __int8 v94; // [sp+19Ch] [bp-154h]
  int v95; // [sp+1A0h] [bp-150h]
  RwMatrix v96; // [sp+1A8h] [bp-148h] BYREF
  RwMatrix v97; // [sp+1E8h] [bp-108h] BYREF
  __int128 v98[2]; // [sp+22Ch] [bp-C4h] BYREF
  float v99; // [sp+24Ch] [bp-A4h]
  RwV3d_0 pointsIn; // [sp+250h] [bp-A0h] BYREF
  float v101; // [sp+25Ch] [bp-94h]
  float v102; // [sp+260h] [bp-90h]
  float v103; // [sp+264h] [bp-8Ch]
  float v104; // [sp+268h] [bp-88h]
  RwReal v105; // [sp+26Ch] [bp-84h]
  float v106; // [sp+270h] [bp-80h]
  float32x4_t vecCentre; // [sp+278h] [bp-78h] BYREF
  float32x4_t v108; // [sp+288h] [bp-68h]
  float v109; // [sp+298h] [bp-58h]

  if ( pRealTimeShadow )
  {
    ShadowCamera = CRealTimeShadow::GetShadowCamera(pRealTimeShadow);
    m_pColModel = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
    m_pColData = m_pColModel->m_pColData;
    if ( m_pColData )
    {
      CCollision::CalculateTrianglePlanes(m_pColModel);
      parent = ShadowCamera->m_pShadowCamera->object.object.parent;
      v23 = parent[2];
      v24 = parent[3];
      v25 = parent[4];
      v26 = parent[5];
      v27 = (double *)(parent + 6);
      parent += 8;
      v28 = parent[1];
      v29 = *v27;
      v30 = *((_QWORD *)v27 + 1);
      *(_QWORD *)&v97.pos.x = *parent;
      *(_QWORD *)&v97.pos.z = v28;
      *(double *)&v97.at.x = v29;
      *(_QWORD *)&v97.at.z = v30;
      *(_QWORD *)&v97.right.x = v23;
      *(_QWORD *)&v97.right.z = v24;
      *(_QWORD *)&v97.up.x = v25;
      *(_QWORD *)&v97.up.z = v26;
      v92 = *(float *)&v30;
      v91 = v29;
      m_pMat = pEntity->m_pMat;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        m_pMat = pEntity->m_pMat;
      }
      CMatrix::CopyToRwMatrix(m_pMat, &v96);
      v93 = v97;
      RwMatrixInvert(&v93, &v97);
      x = ShadowCamera->m_pShadowCamera->viewWindow.x;
      scale.x = -0.5 / x;
      scale.y = -0.5 / x;
      scale.z = 1.0 / x;
      RwMatrixScale(&v93, &scale, rwCOMBINEPOSTCONCAT);
      translation.x = 0.5;
      translation.y = 0.5;
      translation.z = 0.0;
      RwMatrixTranslate(&v93, &translation, rwCOMBINEPOSTCONCAT);
      v95 = 0;
      v94 = Brightness;
      v33 = pEntity->m_pMat;
      if ( !v33 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v33 = pEntity->m_pMat;
      }
      CMatrix::CopyToRwMatrix(v33, &pMatrix);
      RwMatrixInvert(&dst, &pMatrix);
      vecCentre.n128_u32[2] = 0;
      vecCentre.n128_f32[1] = -ForwardY;
      vecCentre.n128_f32[0] = -ForwardX;
      v34 = CVector::NormaliseAndMag((CVector *)&vecCentre);
      v35 = *(_QWORD *)&pShadowPos->x;
      pointsIn.z = pShadowPos->z;
      *(_QWORD *)&pointsIn.x = v35;
      radius = pRealTimeShadow->m_ClumpWorldBoundingSphere.radius;
      v37 = v34 + (float)(radius * -0.5);
      pointsIn.y = (float)(vecCentre.n128_f32[1] * v37) + *((float *)&v35 + 1);
      pointsIn.z = (float)(v37 * vecCentre.n128_f32[2]) + pointsIn.z;
      pointsIn.x = (float)(vecCentre.n128_f32[0] * v37) + *(float *)&v35;
      RwV3dTransformPoints(&pointsOut, &pointsIn, 1, &dst);
      v86 = (float)(v34 + radius) * 1.15;
      vecCentre.n128_u32[2] = LODWORD(pointsOut.z);
      vecCentre.n128_u64[0] = *(_QWORD *)&pointsOut.x;
      CColSphere::Set(&sphere, v86, (const CVector *)&vecCentre, 0, 0, 0xFFu);
      if ( m_pColData->m_nNoOfTriangles >= 1 )
      {
        v38 = 0;
        v39 = 0;
        v40 = 0;
        do
        {
          m_pTriangleArray = m_pColData->m_pTriangleArray;
          m_nIndex1_low = LOWORD(m_pTriangleArray[v39].m_nIndex1);
          v43 = &m_pTriangleArray[v39];
          m_nIndex3_low = LOWORD(v43->m_nIndex3);
          m_nIndex2_low = LOWORD(v43->m_nIndex2);
          CCollisionData::GetTrianglePoint(m_pColData, (CVector *)&pt, m_nIndex1_low);
          CCollisionData::GetTrianglePoint(m_pColData, (CVector *)((char *)&pt.n128_f64[1] + 4), m_nIndex2_low);
          CCollisionData::GetTrianglePoint(m_pColData, &v83, m_nIndex3_low);
          if ( CCollision::TestSphereTriangle(
                 &sphere,
                 m_pColData->m_pTriCompressedVectorArray,
                 &m_pColData->m_pTriangleArray[v39],
                 &m_pColData->m_pTrianglePlaneArray[v38]) )
          {
            p_x = &m_pColData->m_pTrianglePlaneArray[v38].m_compressedNormal.x;
            v47 = p_x[2];
            v48 = p_x[1];
            v49.n128_f32[2] = v47 * 0.028;
            v50 = *p_x;
            v49.n128_f32[1] = v48 * 0.028;
            v49.n128_f32[0] = *p_x * 0.028;
            v49.n128_f32[3] = v49.n128_f32[0];
            v51.n128_f32[0] = v48 * 0.028;
            v51.n128_f32[1] = v47 * 0.028;
            v51.n128_f32[2] = v49.n128_f32[0];
            v51.n128_f32[3] = v48 * 0.028;
            pt = vaddq_f32(v49, pt);
            v52.n128_u64[0] = v82;
            v52.n128_u64[1] = *(_QWORD *)&v83.x;
            v53 = vaddq_f32(v51, v52);
            v82 = v53.n128_u64[0];
            *(_QWORD *)&v83.x = v53.n128_u64[1];
            v83.z = (float)(v47 * 0.028) + v83.z;
            RwV3dTransformPoints((RwV3d_0 *)&vecCentre, (const RwV3d_0 *)&pt, 3, &v96);
            if ( (float)((float)((float)(v50 * *(float *)&v91) + (float)(v48 * *((float *)&v91 + 1)))
                       + (float)(v47 * v92)) <= 0.0 )
            {
              v54.n128_f32[2] = v47 * -0.028;
              v54.n128_f32[1] = v48 * -0.028;
              v54.n128_f32[0] = v50 * -0.028;
              v54.n128_f32[3] = v50 * -0.028;
              v55.n128_f32[0] = v48 * -0.028;
              v55.n128_f32[1] = v47 * -0.028;
              v55.n128_f32[2] = v50 * -0.028;
              v55.n128_f32[3] = v48 * -0.028;
              v98[0] = (__int128)vaddq_f32(v54, vecCentre);
              v98[1] = (__int128)vaddq_f32(v55, v108);
              v99 = (float)(v47 * -0.028) + v109;
              RwV3dTransformPoints(&pointsIn, (const RwV3d_0 *)v98, 3, &v93);
              if ( (pointsIn.z >= 0.0 || v106 >= 0.0)
                && (pointsIn.x >= 0.0 || v104 >= 0.0)
                && (pointsIn.x <= 1.0 || v104 <= 1.0)
                && (pointsIn.y >= 0.0 || v105 >= 0.0)
                && (pointsIn.y <= 1.0 || v105 <= 1.0) )
              {
                if ( TempBufferIndicesStored >= 4093 )
                  RenderBuffer::RenderStuffInBuffer();
                v56 = TempBufferVerticesStored;
                if ( TempBufferVerticesStored >= 2045 )
                {
                  RenderBuffer::RenderStuffInBuffer();
                  v56 = TempBufferVerticesStored;
                }
                v59 = *(unsigned __int64 *)((char *)vecCentre.n128_u64 + 4);
                v58 = HIDWORD(v59);
                v57 = v59;
                RenderBuffer::IndicesToBeStored = 3;
                RenderBuffer::VerticesToBeStored = 3;
                v80 = TempBufferIndicesStored;
                LODWORD(TempVertexBuffer.m_3d[v56].position.x) = vecCentre.n128_u32[0];
                v60 = &TempVertexBuffer.m_3d[v56];
                *(_QWORD *)&v60->position.y = __PAIR64__(v58, v57);
                v61 = vecCentre.n128_u32[3];
                v62 = v108.n128_u64[0];
                v63 = v108.n128_u64[1];
                v79 = v109;
                v78 = v104;
                y = pointsIn.y;
                v65 = v101;
                v60->texCoords.u = pointsIn.x;
                v60->texCoords.v = y;
                LODWORD(v60[1].position.x) = v61;
                LODWORD(v60[1].position.y) = v62;
                v66 = v102;
                v60[1].position.z = *((RwReal *)&v62 + 1);
                v60[1].texCoords.u = v65;
                v60[1].texCoords.v = v66;
                *(_QWORD *)&v60[2].position.x = v63;
                v60[2].position.z = v79;
                v60[2].texCoords.u = v78;
                v60[2].texCoords.v = v105;
                if ( v95 )
                {
                  v67 = 1.0 - (float)(pointsIn.z * pointsIn.z);
                  if ( v67 >= 0.0 )
                    v68 = (unsigned int)(float)(v67 * (float)v94);
                  else
                    v68 = 0;
                  v71 = v103 * v103;
                  v69 = v56;
                  TempVertexBuffer.m_3d[v56].color = (RwRGBA_0)(v68 | (v68 << 16) | (v68 << 24) | (v68 << 8));
                  v72 = 1.0 - v71;
                  if ( v72 >= 0.0 )
                    v73 = (unsigned int)(float)(v72 * (float)v94);
                  else
                    v73 = 0;
                  v74 = v106 * v106;
                  v60[1].color = (RwRGBA_0)(v73 | (v73 << 16) | (v73 << 24) | (v73 << 8));
                  v75 = 1.0 - v74;
                  if ( v75 >= 0.0 )
                    v76 = (unsigned int)(float)(v75 * (float)v94);
                  else
                    v76 = 0;
                  v60[2].color = (RwRGBA_0)(v76 | (v76 << 16) | (v76 << 24) | (v76 << 8));
                }
                else
                {
                  v69 = v56;
                  v70 = v94 | (v94 << 16) | (v94 << 24) | (v94 << 8);
                  TempVertexBuffer.m_3d[v56].color = (RwRGBA_0)v70;
                  v60[2].color = (RwRGBA_0)v70;
                  v60[1].color = (RwRGBA_0)v70;
                }
                *(_DWORD *)&TempBufferRenderIndexList[v80 + 1] = (char *)&elf_hash_chain[16294] + 1;
                TempBufferRenderIndexList[v80] = v69;
                v77 = &TempBufferRenderIndexList[v80];
                v77[1] = v69 + 1;
                v77[2] = v69 + 2;
                TempBufferVerticesStored = v69 + 3;
                TempBufferIndicesStored = v80 + 3;
              }
            }
          }
          ++v40;
          ++v38;
          ++v39;
        }
        while ( v40 < m_pColData->m_nNoOfTriangles );
      }
    }
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005BE768) --------------------------------------------------------
void CSkidmarks::Init()
{
  int32 TxdSlot; // r0
  int i; // r1
  CActiveSkidmark *v2; // r2
  int v3; // r0
  int v4; // r1
  RwImVertexIndex *v5; // r3

  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  gpSkidTex = RwTextureRead((const RwChar *)"particleskid", 0);
  CTxdStore::PopCurrentTxd();
  for ( i = 0; i != 32; ++i )
  {
    v2 = &CSkidmarks::aSkidmarks[i];
    *(_WORD *)&v2->Status = 0;
  }
  v3 = 0;
  v4 = 3;
  do
  {
    SkidmarkIndexList[v3] = v4 - 3;
    v5 = &SkidmarkIndexList[v3];
    v3 += 6;
    v5[1] = v4 - 1;
    v5[2] = v4 - 2;
    v5[3] = v4 - 2;
    v5[4] = v4 - 1;
    v5[5] = v4;
    v4 += 2;
  }
  while ( v3 != 96 );
}

//----- (005BE800) --------------------------------------------------------
void CSkidmarks::Shutdown()
{
  RwTextureDestroy(gpSkidTex);
  gpSkidTex = 0;
}

//----- (005BE818) --------------------------------------------------------
void CSkidmarks::Clear()
{
  int i; // r2
  CActiveSkidmark *v1; // r3

  for ( i = 0; i != 32; ++i )
  {
    v1 = &CSkidmarks::aSkidmarks[i];
    *(_WORD *)&v1->Status = 0;
  }
}

//----- (005BE838) --------------------------------------------------------
void CSkidmarks::Update()
{
  int v0; // r6
  UInt32 v1; // r0
  uint32 v2; // r12
  CActiveSkidmark *v3; // r5
  int Status; // r4
  int NumPoints; // r4
  __int64 v6; // r4
  bool v7; // cc
  CActiveSkidmark *v8; // r4

  v0 = 0;
  v1 = CTimer::m_snTimeInMilliseconds;
  v2 = CTimer::m_snTimeInMilliseconds + 2500;
  do
  {
    v3 = &CSkidmarks::aSkidmarks[v0];
    Status = CSkidmarks::aSkidmarks[v0].Status;
    if ( Status == 2 )
    {
      if ( v1 > CSkidmarks::aSkidmarks[v0].RemoveTime )
        v3->Status = 0;
    }
    else if ( Status == 1 && !CSkidmarks::aSkidmarks[v0].bUpdatedThisFrame )
    {
      v3->Status = 2;
      NumPoints = CSkidmarks::aSkidmarks[v0].NumPoints;
      if ( NumPoints >= 4 )
      {
        v7 = NumPoints < 9;
        v6 = 85899345930000LL;
        if ( v7 )
          v6 = 0x271000001388LL;
        LODWORD(v6) = v6 + v1;
      }
      else
      {
        v6 = v2 | 0x138800000000LL;
      }
      HIDWORD(v6) += v1;
      *(_QWORD *)&CSkidmarks::aSkidmarks[v0].FadeOutTime = v6;
    }
    v8 = &CSkidmarks::aSkidmarks[v0++];
    v8->bUpdatedThisFrame = 0;
  }
  while ( v0 != 32 );
}

//----- (005BE914) --------------------------------------------------------
void CSkidmarks::Render()
{
  int v0; // r5
  int i; // r4
  CActiveSkidmark *v2; // r0
  CActiveSkidmark *v3; // r1
  UInt8 *p_Status; // r8
  eSkidmarkType Type; // r2
  unsigned __int8 *v6; // r1
  unsigned int red; // r0
  RwUInt8 *v8; // r3
  unsigned int green; // r1
  RwUInt8 *v10; // r6
  unsigned int blue; // r2
  float v12; // s0
  unsigned int v13; // s2
  unsigned int v14; // s4
  unsigned int v15; // s0
  int v16; // r1
  UInt32 FadeOutTime; // r1
  UInt32 v18; // r0
  unsigned int v19; // r12
  __int16 v20; // r9
  VertexBuffer *v21; // r2
  unsigned int v22; // r11
  int v23; // r6
  int v24; // r1
  int v25; // r4
  __int16 v26; // r8
  int v27; // s0
  float *v28; // r5
  float *v29; // r0
  RwReal v30; // s0
  unsigned int v31; // r3
  float v32; // s6
  float v33; // s2
  float v34; // s4
  RwReal v35; // s6
  float v36; // s8
  float v37; // s10
  int v38; // [sp+28h] [bp-68h]
  int v39; // [sp+2Ch] [bp-64h]
  Int16 *p_NumPoints; // [sp+30h] [bp-60h]
  int v41; // [sp+34h] [bp-5Ch]
  char v42; // [sp+38h] [bp-58h]
  unsigned int v43; // [sp+40h] [bp-50h]
  CRGBA v44; // [sp+44h] [bp-4Ch] BYREF

  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpSkidTex->raster);
  v0 = 0;
  for ( i = 0; i != 32; ++i )
  {
    v2 = &CSkidmarks::aSkidmarks[i];
    if ( v2->Status )
    {
      v3 = &CSkidmarks::aSkidmarks[i];
      if ( v3->NumPoints >= 1 )
      {
        p_Status = &v2->Status;
        p_NumPoints = &v3->NumPoints;
        CRGBA::CRGBA(&v44, 0, 0, 0, 0xFFu);
        Type = CSkidmarks::aSkidmarks[i].Type;
        if ( (unsigned int)Type >= 4 )
        {
          red = v44._anon_0._anon_0.red;
          green = v44._anon_0._anon_0.green;
          blue = v44._anon_0._anon_0.blue;
        }
        else
        {
          v6 = (unsigned __int8 *)*(&off_66E32C + Type);
          red = off_66E31C[Type]->_anon_0._anon_0.red;
          v44._anon_0._anon_0.red = off_66E31C[Type]->_anon_0._anon_0.red;
          v8 = (RwUInt8 *)*(&off_66E33C + Type);
          green = *v6;
          v10 = (RwUInt8 *)*(&off_66E34C + Type);
          v44._anon_0._anon_0.green = green;
          blue = *v8;
          v44._anon_0._anon_0.blue = *v8;
          v44._anon_0._anon_0.alpha = *v10;
        }
        v12 = (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam) * 0.6) + 0.4;
        v13 = (unsigned int)(float)(v12 * (float)blue);
        v14 = (unsigned int)(float)(v12 * (float)red);
        v15 = (unsigned int)(float)(v12 * (float)green);
        v16 = *p_Status;
        v44._anon_0._anon_0.red = v14;
        v43 = v14;
        v44._anon_0._anon_0.green = v15;
        v44._anon_0._anon_0.blue = v13;
        v42 = v16;
        v38 = i;
        v39 = v0;
        if ( v16 == 1
          || (FadeOutTime = CSkidmarks::aSkidmarks[i].FadeOutTime, CTimer::m_snTimeInMilliseconds < FadeOutTime) )
        {
          LOWORD(v18) = 255;
        }
        else
        {
          v18 = 255
              * (CSkidmarks::aSkidmarks[i].RemoveTime - CTimer::m_snTimeInMilliseconds)
              / (CSkidmarks::aSkidmarks[i].RemoveTime - FadeOutTime);
        }
        v41 = *p_NumPoints;
        if ( v41 >= 0 )
        {
          v19 = v15 << 8;
          v20 = v18;
          v21 = &TempVertexBuffer;
          v22 = v13 << 16;
          v23 = 0;
          v24 = v0;
          v25 = v0;
          do
          {
            if ( v23 )
            {
              v26 = 128;
              if ( v41 != v23 || v42 != 2 )
                goto LABEL_18;
              v42 = 2;
            }
            v26 = 0;
LABEL_18:
            v27 = v23++;
            v28 = (float *)((char *)CSkidmarks::aSkidmarks + v24);
            v29 = (float *)((char *)CSkidmarks::aSkidmarks + v25);
            v30 = (float)v27 * 5.01;
            v31 = ((v26 * v20) << 16) & 0xFF000000 | v43 | v19 | v22;
            v32 = *(float *)((char *)&CSkidmarks::aSkidmarks[0].aPoints[0].z + v25);
            v24 += 4;
            v33 = *(float *)((char *)&CSkidmarks::aSkidmarks[0].aPoints[0].x + v25);
            v25 += 12;
            v34 = v29[1];
            v35 = v32 + 0.1;
            v36 = v28[48];
            v37 = v28[64];
            v21->m_3d[0].color = (RwRGBA_0)v31;
            v21->m_3d[0].texCoords.u = 0.0;
            v21->m_3d[1].color = (RwRGBA_0)v31;
            v21->m_3d[1].texCoords.u = 1.0;
            v21->m_3d[1].texCoords.v = v30;
            v21->m_3d[0].position.x = v33 + v36;
            v21->m_3d[0].position.y = v34 + v37;
            v21->m_3d[0].position.z = v35;
            v21->m_3d[0].texCoords.v = v30;
            v21->m_3d[1].position.x = v33 - v36;
            v21->m_3d[1].position.y = v34 - v37;
            v21->m_3d[1].position.z = v35;
            v21 = (VertexBuffer *)((char *)v21 + 72);
          }
          while ( v41 + 1 != v23 );
        }
        LittleTest();
        if ( RwIm3DTransform(TempVertexBuffer.m_3d, 2 * *p_NumPoints + 2, 0, 1u) )
        {
          RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, SkidmarkIndexList, 6 * *p_NumPoints);
          RwIm3DEnd();
        }
        i = v38;
        v0 = v39;
      }
    }
    v0 += 344;
  }
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 66E31C: using guessed type CRGBA *off_66E31C[4];
// 66E32C: using guessed type void *off_66E32C;
// 66E33C: using guessed type void *off_66E33C;
// 66E34C: using guessed type void *off_66E34C;

//----- (005BEC90) --------------------------------------------------------
void __fastcall CSkidmarks::RegisterOne(
        UInt32 ID,
        const CVector *Coors,
        float CarFrontX,
        float CarFrontY,
        bool *pMuddy,
        bool *pBloody,
        float Width)
{
  int v7; // lr

  if ( *pBloody )
    v7 = 3;
  else
    v7 = *pMuddy;
  CSkidmarks::RegisterOne(ID, Coors, CarFrontX, CarFrontY, __SPAIR64__((unsigned int)pBloody, v7), Width);
}

//----- (005BECC4) --------------------------------------------------------
void __fastcall CSkidmarks::RegisterOne(
        UInt32 ID,
        const CVector *Coors,
        float CarFrontX,
        float CarFrontY,
        __int64 Type,
        float Width)
{
  int v7; // r6
  _BYTE *v8; // r12
  float v9; // s2
  float *SidesX; // r4
  int v12; // r1
  int v13; // r2
  bool v14; // zf
  UInt8 *p_Status; // r3
  int v16; // r1
  int v17; // r4
  UInt32 LastPointStoredTime; // r5
  int v20; // r9
  int v21; // r11
  float x; // s0
  float y; // s2
  float z; // s4
  float *v25; // r0
  float v26; // s6
  float v27; // s10
  CActiveSkidmark *v28; // r4
  __int64 v29; // d16
  uint32 v30; // r1
  int v31; // r2
  uint32 v32; // r1
  int v33; // r2
  __int64 v34; // d16
  float *v35; // r1
  int v36; // r1
  float *v37; // r2
  float v38; // s6
  float v39; // s10
  float v40; // s12
  float v41; // s10
  uint32 v42; // r2
  __int64 v43; // d16
  float *v44; // r0
  float v45; // s12
  float v46; // s4
  float v47; // s2
  int v48; // r1
  int v49; // r2
  UInt32 v50; // [sp+0h] [bp-48h]
  int v51; // [sp+8h] [bp-40h]
  CVector posn; // [sp+14h] [bp-34h] BYREF

  v8 = (_BYTE *)HIDWORD(Type);
  v7 = Type;
  v9 = CarFrontY;
  SidesX = CSkidmarks::aSkidmarks[0].SidesX;
  v12 = -1;
  while ( 1 )
  {
    v13 = *((unsigned __int8 *)SidesX + 150);
    v14 = v13 == 1;
    if ( v13 == 1 )
      v14 = *((_DWORD *)SidesX + 32) == ID;
    if ( v14 )
      break;
    ++v12;
    SidesX += 86;
    if ( v12 >= 31 )
    {
      p_Status = &CSkidmarks::aSkidmarks[0].Status;
      v16 = 0;
      while ( *p_Status )
      {
        v17 = v16 + 1;
        p_Status += 344;
        if ( v16++ >= 31 )
        {
          v50 = ID;
          LastPointStoredTime = -1;
          v20 = 0;
          v21 = 0;
          v51 = -1;
          do
          {
            if ( !CSkidmarks::aSkidmarks[v20].bUpdatedThisFrame
              && CSkidmarks::aSkidmarks[v20].LastPointStoredTime < LastPointStoredTime )
            {
              x = CSkidmarks::aSkidmarks[v20].aPoints[0].x;
              y = CSkidmarks::aSkidmarks[v20].aPoints[0].y;
              z = CSkidmarks::aSkidmarks[v20].aPoints[0].z;
              v25 = (float *)((char *)&CSkidmarks::aSkidmarks[0].aPoints[CSkidmarks::aSkidmarks[v20].NumPoints].x
                            + v20 * 344);
              v26 = x + *v25;
              v27 = v25[2];
              posn.y = (float)(y + v25[1]) * 0.5;
              posn.x = v26 * 0.5;
              posn.z = (float)(z + v27) * 0.5;
              if ( !CCamera::IsSphereVisible(
                      &TheCamera,
                      &posn,
                      sqrtf(
                        (float)((float)((float)(x - posn.x) * (float)(x - posn.x))
                              + (float)((float)(y - posn.y) * (float)(y - posn.y)))
                      + (float)((float)(z - posn.z) * (float)(z - posn.z)))) )
              {
                LastPointStoredTime = CSkidmarks::aSkidmarks[v20].LastPointStoredTime;
                v51 = v21;
              }
            }
            ++v20;
            ++v21;
          }
          while ( v20 != 32 );
          if ( v51 > -1 )
            v17 = v51;
          v8 = (_BYTE *)HIDWORD(Type);
          v7 = Type;
          ID = v50;
          if ( v17 > 31 )
          {
LABEL_18:
            *v8 = 0;
            return;
          }
LABEL_20:
          v28 = &CSkidmarks::aSkidmarks[v17];
          v28->ID = ID;
          v28->Status = 1;
          v29 = *(_QWORD *)&Coors->x;
          v30 = CTimer::m_snTimeInMilliseconds - 1000;
          v28->aPoints[0].z = Coors->z;
          v28->SidesX[0] = 0.0;
          v28->SidesY[0] = 0.0;
          v28->bUpdatedThisFrame = 1;
          v28->NumPoints = 0;
          *(_QWORD *)&v28->aPoints[0].x = v29;
          v28->LastPointStoredTime = v30;
          if ( *v8 )
            v7 = 3;
          v28->Type = v7;
          return;
        }
      }
      v17 = v16;
      goto LABEL_20;
    }
  }
  if ( (*((_DWORD *)SidesX + 36) == 3) == *(_BYTE *)HIDWORD(Type) )
  {
    v31 = *((_DWORD *)SidesX + 33);
    *((_BYTE *)SidesX + 151) = 1;
    v32 = CTimer::m_snTimeInMilliseconds;
    if ( CTimer::m_snTimeInMilliseconds - v31 < 0x65 )
    {
      v43 = *(_QWORD *)&Coors->x;
      v44 = &SidesX[3 * *((__int16 *)SidesX + 74)];
      *(v44 - 46) = Coors->z;
      *((_QWORD *)v44 - 24) = v43;
    }
    else
    {
      v33 = *((__int16 *)SidesX + 74);
      *((_DWORD *)SidesX + 33) = CTimer::m_snTimeInMilliseconds;
      if ( v33 > 14 )
      {
        *((_BYTE *)SidesX + 150) = 2;
        *((_DWORD *)SidesX + 33) = v32;
        *((_DWORD *)SidesX + 34) = v32 + 10000;
        *((_DWORD *)SidesX + 35) = v32 + 20000;
        goto LABEL_18;
      }
      *((_WORD *)SidesX + 74) = v33 + 1;
      v34 = *(_QWORD *)&Coors->x;
      v35 = &SidesX[3 * (__int16)(v33 + 1)];
      *(v35 - 46) = Coors->z;
      *((_QWORD *)v35 - 24) = v34;
      v36 = *((__int16 *)SidesX + 74);
      v37 = &SidesX[3 * v36];
      v38 = *(v37 - 51) - *(v37 - 48);
      v39 = *(v37 - 47) - *(v37 - 50);
      v40 = sqrtf((float)(v39 * v39) + (float)(v38 * v38));
      if ( v40 <= 0.0 )
      {
        v41 = 1.0;
      }
      else
      {
        v38 = v38 / v40;
        v41 = v39 / v40;
      }
      v45 = sqrtf((float)(CarFrontX * CarFrontX) + (float)(CarFrontY * CarFrontY));
      if ( v45 <= 0.0 )
      {
        v46 = 1.0;
      }
      else
      {
        v9 = CarFrontY / v45;
        v46 = CarFrontX / v45;
      }
      v47 = fabsf((float)(v38 * v9) + (float)(v41 * v46)) + 1.0;
      SidesX[v36] = (float)((float)(v41 * v47) * Width) * 0.5;
      SidesX[*((__int16 *)SidesX + 74) + 16] = (float)((float)(v38 * v47) * Width) * 0.5;
      v48 = *((__int16 *)SidesX + 74);
      if ( v48 == 1 )
      {
        v49 = *((_DWORD *)SidesX + 17);
        *SidesX = SidesX[1];
        *((_DWORD *)SidesX + 16) = v49;
      }
      else if ( v48 >= 9 )
      {
        goto LABEL_18;
      }
    }
  }
  else
  {
    *((_BYTE *)SidesX + 150) = 2;
    v42 = CTimer::m_snTimeInMilliseconds + 20000;
    *((_DWORD *)SidesX + 34) = CTimer::m_snTimeInMilliseconds + 10000;
    *((_DWORD *)SidesX + 35) = v42;
  }
}

//----- (005BF060) --------------------------------------------------------
Int32 C3dMarkers::User3dMarkerFindFirstFreeSlot()
{
  Int32 result; // r0

  if ( !C3dMarkers::ms_user3dMarkers[0].bActive )
    return 0;
  if ( !C3dMarkers::ms_user3dMarkers[1].bActive )
    return 1;
  if ( !C3dMarkers::ms_user3dMarkers[2].bActive )
    return 2;
  if ( !C3dMarkers::ms_user3dMarkers[3].bActive )
    return 3;
  result = -1;
  if ( !C3dMarkers::ms_user3dMarkers[4].bActive )
    return 4;
  return result;
}

//----- (005BF0CC) --------------------------------------------------------
Int32 __fastcall C3dMarkers::User3dMarkerSet(float x, float y, float z, Int32 colID)
{
  Int32 v4; // r8
  uint8 v5; // r6
  C3dMarkers::user3dMarkers *v6; // r4
  CRGBA v8; // [sp+4h] [bp-24h] BYREF
  CRGBA v9; // [sp+8h] [bp-20h] BYREF
  CRGBA v10; // [sp+Ch] [bp-1Ch] BYREF

  if ( !C3dMarkers::ms_user3dMarkers[0].bActive )
  {
    v4 = 0;
LABEL_12:
    v5 = colID;
    v6 = &C3dMarkers::ms_user3dMarkers[v4];
    v6->pos.x = x;
    v6->pos.y = y;
    v6->pos.z = z;
    CHudColours::GetRGBA(&v10, &HudColour, colID);
    v6->r = v10._anon_0._anon_0.red;
    CHudColours::GetRGBA(&v9, &HudColour, v5);
    v6->g = v9._anon_0._anon_0.green;
    CHudColours::GetRGBA(&v8, &HudColour, v5);
    v6->b = v8._anon_0._anon_0.blue;
    v6->bActive = 1;
    return v4;
  }
  if ( !C3dMarkers::ms_user3dMarkers[1].bActive )
  {
    v4 = 1;
    goto LABEL_12;
  }
  if ( !C3dMarkers::ms_user3dMarkers[2].bActive )
  {
    v4 = 2;
    goto LABEL_12;
  }
  if ( !C3dMarkers::ms_user3dMarkers[3].bActive )
  {
    v4 = 3;
    goto LABEL_12;
  }
  if ( !C3dMarkers::ms_user3dMarkers[4].bActive )
  {
    v4 = 4;
    goto LABEL_12;
  }
  return -1;
}

//----- (005BF1BC) --------------------------------------------------------
void __fastcall C3dMarkers::User3dMarkerDelete(Int32 n)
{
  if ( (unsigned int)n <= 4 )
    C3dMarkers::ms_user3dMarkers[n].bActive = 0;
}

//----- (005BF1D8) --------------------------------------------------------
void C3dMarkers::User3dMarkerDeleteAll()
{
  C3dMarkers::ms_user3dMarkers[1].bActive = 0;
  C3dMarkers::ms_user3dMarkers[0].bActive = 0;
  C3dMarkers::ms_user3dMarkers[2].bActive = 0;
  C3dMarkers::ms_user3dMarkers[3].bActive = 0;
  C3dMarkers::ms_user3dMarkers[4].bActive = 0;
}

//----- (005BF1F8) --------------------------------------------------------
void C3dMarkers::User3dMarkersDraw()
{
  int v0; // r5
  int v1; // r0
  RpClump_0 *v2; // r6
  float v3; // r0
  RwFrame_0 *parent; // r4
  Int32 g; // r1
  Int32 b; // r2
  RwV3d_0 translation; // [sp+10h] [bp-48h] BYREF

  v0 = 0;
  v1 = 0;
  do
  {
    if ( C3dMarkers::ms_user3dMarkers[v0].bActive )
    {
      if ( !(v1 << 31) )
      {
        RwRenderStateGet(rwRENDERSTATECULLMODE, &CPostEffects::ms_imf.cullMode);
        RwRenderStateGet(rwRENDERSTATEZTESTENABLE, &CPostEffects::ms_imf.bZTest);
        RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, &CPostEffects::ms_imf.bZWrite);
        RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
      }
      v2 = C3dMarkers::m_pRpClumpArray[5];
      v3 = sinf((float)(C3dMarkers::m_angleDiamond * 3.1416) / 180.0);
      translation = (RwV3d_0)C3dMarkers::ms_user3dMarkers[v0].pos;
      parent = (RwFrame_0 *)v2->object.parent;
      translation.z = translation.z + (float)(v3 * 0.25);
      RwFrameSetIdentity(parent);
      RwFrameTranslate(parent, &translation, rwCOMBINEREPLACE);
      g = C3dMarkers::ms_user3dMarkers[v0].g;
      b = C3dMarkers::ms_user3dMarkers[v0].b;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.red = C3dMarkers::ms_user3dMarkers[v0].r;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.green = g;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.alpha = -1;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.blue = b;
      RpClumpForAllAtomics(v2, C3dMarkers::User3dMarkerAtomicCB, 0);
      RpClumpRender(v2);
      v1 = 1;
    }
    ++v0;
  }
  while ( v0 != 5 );
  if ( v1 << 31 )
  {
    RwRenderStateSet(rwRENDERSTATECULLMODE, (void *)CPostEffects::ms_imf.cullMode);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (void *)CPostEffects::ms_imf.bZTest);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (void *)CPostEffects::ms_imf.bZWrite);
  }
}
// 0: using guessed type int dword_0;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005BF374) --------------------------------------------------------
RpAtomic_0 *__fastcall C3dMarkers::User3dMarkerAtomicCB(RpAtomic_0 *pAtomic, void *pData)
{
  (*pAtomic->geometry->matList.materials)->color = C3dMarkers::m_user3dMarkerColor;
  return 0;
}

//----- (005BF38C) --------------------------------------------------------
void C3dMarkers::DirectionArrowsInit()
{
  C3dMarkers::ms_directionArrows[1].bActive = 0;
  C3dMarkers::ms_directionArrows[0].bActive = 0;
  C3dMarkers::ms_directionArrows[2].bActive = 0;
  C3dMarkers::ms_directionArrows[3].bActive = 0;
  C3dMarkers::ms_directionArrows[4].bActive = 0;
}

//----- (005BF3AC) --------------------------------------------------------
Int32 C3dMarkers::DirectionArrowFindFirstFreeSlot()
{
  Int32 result; // r0

  if ( !C3dMarkers::ms_directionArrows[0].bActive )
    return 0;
  if ( !C3dMarkers::ms_directionArrows[1].bActive )
    return 1;
  if ( !C3dMarkers::ms_directionArrows[2].bActive )
    return 2;
  if ( !C3dMarkers::ms_directionArrows[3].bActive )
    return 3;
  result = -1;
  if ( !C3dMarkers::ms_directionArrows[4].bActive )
    return 4;
  return result;
}

//----- (005BF41C) --------------------------------------------------------
void __fastcall C3dMarkers::DirectionArrowSet(
        CVector pos,
        float fSize,
        __int64 r,
        __int64 b,
        float normalX,
        float normalY,
        float normalZ)
{
  int v7; // r12
  float v8; // s8

  if ( C3dMarkers::ms_directionArrows[0].bActive )
  {
    if ( C3dMarkers::ms_directionArrows[1].bActive )
    {
      if ( C3dMarkers::ms_directionArrows[2].bActive )
      {
        if ( C3dMarkers::ms_directionArrows[3].bActive )
        {
          if ( C3dMarkers::ms_directionArrows[4].bActive )
            return;
          v7 = 4;
        }
        else
        {
          v7 = 3;
        }
      }
      else
      {
        v7 = 2;
      }
    }
    else
    {
      v7 = 1;
    }
  }
  else
  {
    v7 = 0;
  }
  v8 = pos.z + 3.0;
  C3dMarkers::ms_directionArrows[v7].bActive = 1;
  LODWORD(pos.z) = &C3dMarkers::ms_directionArrows[v7];
  *(_QWORD *)(LODWORD(pos.z) + 4) = *(_QWORD *)&pos.x;
  *(_QWORD *)(LODWORD(pos.z) + 32) = r;
  *(_QWORD *)(LODWORD(pos.z) + 40) = b;
  *(float *)(LODWORD(pos.z) + 12) = v8;
  *(float *)(LODWORD(pos.z) + 16) = fSize;
  *(float *)(LODWORD(pos.z) + 20) = normalX;
  *(float *)(LODWORD(pos.z) + 24) = normalY;
  *(float *)(LODWORD(pos.z) + 28) = normalZ;
}
// 5BF41C: using guessed type _QWORD anonymous_0;

//----- (005BF520) --------------------------------------------------------
void C3dMarkers::DirectionArrowsDraw()
{
  int v0; // r9
  int r0_1; // r0
  RpClump_0 *r11_5; // r11
  __int64 v3; // d16
  RwFrame_0 *parent; // r8
  RwReal y; // r1
  RwReal z; // r2
  const CMatrix *v7; // r0
  float fSize; // s8
  Int32 g; // r1
  Int32 b; // r2
  Int32 a; // r3
  CVector v12; // [sp+20h] [bp-190h] BYREF
  CVector v1; // [sp+2Ch] [bp-184h] BYREF
  CVector v14; // [sp+38h] [bp-178h] BYREF
  CMatrix m2; // [sp+44h] [bp-16Ch] BYREF
  CMatrix m1; // [sp+8Ch] [bp-124h] BYREF
  CMatrix v17; // [sp+D4h] [bp-DCh] BYREF
  CVector v2; // [sp+11Ch] [bp-94h] BYREF
  RwV3d_0 translation; // [sp+128h] [bp-88h] BYREF
  CMatrix v20; // [sp+138h] [bp-78h] BYREF

  v0 = 0;
  r0_1 = 0;
  do
  {
    if ( C3dMarkers::ms_directionArrows[v0].bActive )
    {
      if ( !(r0_1 << 31) )
      {
        RwRenderStateGet(rwRENDERSTATECULLMODE, &CPostEffects::ms_imf.cullMode);
        RwRenderStateGet(rwRENDERSTATEZTESTENABLE, &CPostEffects::ms_imf.bZTest);
        RwRenderStateGet(rwRENDERSTATEZWRITEENABLE, &CPostEffects::ms_imf.bZWrite);
        RwRenderStateGet(rwRENDERSTATEVERTEXALPHAENABLE, &CPostEffects::ms_imf.bVertexAlpha);
        RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
        RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
      }
      r11_5 = C3dMarkers::m_pRpClumpArray[5];
      v3 = *(_QWORD *)&C3dMarkers::ms_directionArrows[v0].pos.x;
      translation.z = C3dMarkers::ms_directionArrows[v0].pos.z;
      *(_QWORD *)&translation.x = v3;
      parent = (RwFrame_0 *)C3dMarkers::m_pRpClumpArray[5]->object.parent;
      RwFrameSetIdentity(parent);
      RwFrameTranslate(parent, &translation, rwCOMBINEREPLACE);
      y = C3dMarkers::ms_directionArrows[v0].normal.y;
      z = C3dMarkers::ms_directionArrows[v0].normal.z;
      v2.x = C3dMarkers::ms_directionArrows[v0].normal.x;
      v2.y = y;
      v2.z = z;
      CMatrix::CMatrix(&v17, &parent->modelling, 0);
      CMatrix::UpdateRW(v7);
      m1.m_pRwMat = 0;
      m1.m_owner = 0;
      CMatrix::Attach(&m1, v17.m_pRwMat, 0);
      m2.m_pRwMat = 0;
      m2.m_owner = 0;
      CMatrix::SetUnity(&m2);
      if ( v2.x != 0.0 || v2.z != 1.0 )
      {
        v1.x = 0.0;
        v1.y = 0.0;
        v1.z = 1.0;
        CrossProduct(&v14, &v1, &v2);
        v20.zx = v14.z;
        *(_QWORD *)&v20.xx = *(_QWORD *)&v14.x;
        CVector::Normalise((CVector *)&v20);
        CrossProduct(&v12, &v2, (const CVector *)&v20);
        v14 = v12;
        CVector::Normalise(&v14);
        *(_QWORD *)&m2.xx = *(_QWORD *)&v20.xx;
        m2.zx = v20.zx;
        *(CVector *)&m2.xz = v2;
        *(CVector *)&m2.xy = v14;
      }
      operator*(&v20, &m1, &m2);
      CMatrix::operator=(&m1, &v20);
      CMatrix::~CMatrix(&v20);
      fSize = C3dMarkers::ms_directionArrows[v0].fSize;
      m1.xx = fSize * m1.xx;
      m1.yx = fSize * m1.yx;
      m1.zx = fSize * m1.zx;
      m1.xy = fSize * m1.xy;
      m1.yy = fSize * m1.yy;
      m1.zy = fSize * m1.zy;
      m1.xz = fSize * m1.xz;
      m1.yz = fSize * m1.yz;
      m1.zz = fSize * m1.zz;
      CMatrix::UpdateRW(&m1);
      RwFrameUpdateObjects(parent);
      C3dMarkers::m_user3dMarkerColor = (RwRGBA_0)-16777216;
      RpClumpForAllAtomics(r11_5, C3dMarkers::User3dMarkerAtomicCB, 0);
      RpClumpRender(r11_5);
      m1.xx = m1.xx * 0.8;
      m1.yx = m1.yx * 0.8;
      m1.zx = m1.zx * 0.8;
      m1.xy = m1.xy * 0.8;
      m1.yy = m1.yy * 0.8;
      m1.zy = m1.zy * 0.8;
      m1.xz = m1.xz * 0.8;
      m1.yz = m1.yz * 0.8;
      m1.zz = m1.zz * 0.8;
      CMatrix::UpdateRW(&m1);
      RwFrameUpdateObjects(parent);
      g = C3dMarkers::ms_directionArrows[v0].g;
      b = C3dMarkers::ms_directionArrows[v0].b;
      a = C3dMarkers::ms_directionArrows[v0].a;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.red = C3dMarkers::ms_directionArrows[v0].r;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.green = g;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.blue = b;
      C3dMarkers::m_user3dMarkerColor._anon_0._anon_0.alpha = a;
      RpClumpForAllAtomics(r11_5, C3dMarkers::User3dMarkerAtomicCB, 0);
      RpClumpRender(r11_5);
      C3dMarkers::ms_directionArrows[v0].bActive = 0;
      CMatrix::~CMatrix(&m2);
      CMatrix::~CMatrix(&m1);
      CMatrix::~CMatrix(&v17);
      r0_1 = 1;
    }
    ++v0;
  }
  while ( v0 != 5 );
  if ( r0_1 << 31 )
  {
    RwRenderStateSet(rwRENDERSTATECULLMODE, (void *)CPostEffects::ms_imf.cullMode);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (void *)CPostEffects::ms_imf.bZTest);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (void *)CPostEffects::ms_imf.bZWrite);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void *)CPostEffects::ms_imf.bVertexAlpha);
  }
}
// 5BF618: variable 'v7' is possibly undefined
// 0: using guessed type int dword_0;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005BF8B0) --------------------------------------------------------
void CSpecialFX::Init()
{
  int v0; // r6
  CCheckpoint *v1; // r1
  _QWORD *p_m_fPulseFraction; // r2
  int32 TxdSlot; // r0

  *(_DWORD *)&StreakIndexList[9] = (char *)&elf_hash_chain[16294] + 1;
  CBulletTraces::aTraces[1].bIsUsed = 0;
  CBulletTraces::aTraces[0].bIsUsed = 0;
  CBulletTraces::aTraces[2].bIsUsed = 0;
  CBulletTraces::aTraces[3].bIsUsed = 0;
  CBulletTraces::aTraces[4].bIsUsed = 0;
  CBulletTraces::aTraces[5].bIsUsed = 0;
  CBulletTraces::aTraces[6].bIsUsed = 0;
  CBulletTraces::aTraces[7].bIsUsed = 0;
  CBulletTraces::aTraces[8].bIsUsed = 0;
  CBulletTraces::aTraces[9].bIsUsed = 0;
  CBulletTraces::aTraces[10].bIsUsed = 0;
  CBulletTraces::aTraces[11].bIsUsed = 0;
  CBulletTraces::aTraces[12].bIsUsed = 0;
  CBulletTraces::aTraces[13].bIsUsed = 0;
  CBulletTraces::aTraces[14].bIsUsed = 0;
  CBulletTraces::aTraces[15].bIsUsed = 0;
  StreakIndexList[11] = 3;
  C3dMarkers::ms_user3dMarkers[1].bActive = 0;
  C3dMarkers::ms_user3dMarkers[0].bActive = 0;
  C3dMarkers::ms_user3dMarkers[2].bActive = 0;
  C3dMarkers::ms_user3dMarkers[3].bActive = 0;
  C3dMarkers::ms_user3dMarkers[4].bActive = 0;
  C3dMarkers::ms_directionArrows[0].bActive = 0;
  C3dMarkers::ms_directionArrows[1].bActive = 0;
  C3dMarkers::ms_directionArrows[2].bActive = 0;
  C3dMarkers::ms_directionArrows[3].bActive = 0;
  C3dMarkers::ms_directionArrows[4].bActive = 0;
  StreakVertices[0].texCoords.u = 0.0;
  StreakVertices[0].texCoords.v = 0.0;
  *(_QWORD *)StreakIndexList = 0x1000200010000LL;
  *(_QWORD *)&StreakIndexList[4] = 0x2000000020003LL;
  StreakIndexList[8] = 1;
  StreakVertices[1].texCoords.u = 1.0;
  StreakVertices[1].texCoords.v = 0.0;
  StreakVertices[2].texCoords.u = 0.0;
  StreakVertices[2].texCoords.v = 0.0;
  StreakVertices[3].texCoords.u = 1.0;
  StreakVertices[3].texCoords.v = 0.0;
  CMotionBlurStreaks::aStreaks[1].ID = 0;
  CMotionBlurStreaks::aStreaks[0].ID = 0;
  CMotionBlurStreaks::aStreaks[2].ID = 0;
  CMotionBlurStreaks::aStreaks[3].ID = 0;
  CBrightLights::NumBrightLights = 0;
  CShinyTexts::NumShinyTexts = 0;
  C3dMarkers::Init();
  v0 = 0;
  do
  {
    v1 = &CCheckpoints::m_aCheckPtArray[v0];
    CCheckpoints::m_aCheckPtArray[v0++].m_nType = 257;
    v1->m_bIsUsed = 0;
    p_m_fPulseFraction = (_QWORD *)&v1->m_fPulseFraction;
    v1->m_nIdentifier = 0;
    v1->rwColour = (RwRGBA_0)-1;
    v1->m_nPulsePeriod = 1024;
    v1->m_nRotateRate = 5;
    v1->m_pointDir.y = 0.0;
    v1->m_pointDir.z = 0.0;
    v1->m_rotFlag = 1;
    v1 = (CCheckpoint *)((char *)v1 + 16);
    *p_m_fPulseFraction = 0x3F8000003E800000LL;
    p_m_fPulseFraction[1] = 0LL;
    *(_QWORD *)&v1->m_nType = 0LL;
    *(_QWORD *)&v1->rwColour._anon_0._anon_0.red = 0LL;
  }
  while ( v0 != 32 );
  CSpecialFX::bVideoCam = 0;
  CCheckpoints::NumActiveCPts = 0;
  CSpecialFX::bLiftCam = 0;
  CSpecialFX::SnapShotFrames = 0;
  CSpecialFX::bSnapShotActive = 0;
  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  if ( !gpFinishFlagTex )
    gpFinishFlagTex = RwTextureRead((const RwChar *)"finishFlag", 0);
  CTxdStore::PopCurrentTxd();
  CMirrors::MirrorFlags = 0;
  CMirrors::TypeOfMirror = 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005BFAD8) --------------------------------------------------------
void CBulletTraces::Init()
{
  CBulletTraces::aTraces[1].bIsUsed = 0;
  CBulletTraces::aTraces[0].bIsUsed = 0;
  CBulletTraces::aTraces[2].bIsUsed = 0;
  CBulletTraces::aTraces[3].bIsUsed = 0;
  CBulletTraces::aTraces[4].bIsUsed = 0;
  CBulletTraces::aTraces[5].bIsUsed = 0;
  CBulletTraces::aTraces[6].bIsUsed = 0;
  CBulletTraces::aTraces[7].bIsUsed = 0;
  CBulletTraces::aTraces[8].bIsUsed = 0;
  CBulletTraces::aTraces[9].bIsUsed = 0;
  CBulletTraces::aTraces[10].bIsUsed = 0;
  CBulletTraces::aTraces[11].bIsUsed = 0;
  CBulletTraces::aTraces[12].bIsUsed = 0;
  CBulletTraces::aTraces[13].bIsUsed = 0;
  CBulletTraces::aTraces[14].bIsUsed = 0;
  CBulletTraces::aTraces[15].bIsUsed = 0;
}

//----- (005BFB24) --------------------------------------------------------
void CMotionBlurStreaks::Init()
{
  CMotionBlurStreaks::aStreaks[1].ID = 0;
  CMotionBlurStreaks::aStreaks[0].ID = 0;
  CMotionBlurStreaks::aStreaks[2].ID = 0;
  CMotionBlurStreaks::aStreaks[3].ID = 0;
}

//----- (005BFB40) --------------------------------------------------------
void CBrightLights::Init()
{
  CBrightLights::NumBrightLights = 0;
}

//----- (005BFB50) --------------------------------------------------------
void CShinyTexts::Init()
{
  CShinyTexts::NumShinyTexts = 0;
}

//----- (005BFB60) --------------------------------------------------------
void C3dMarkers::Init()
{
  int v0; // r2
  C3dMarker *v1; // r3
  _QWORD *p_m_fPulseFraction; // r6
  int32 TxdSlot; // r4
  CBaseModelInfo *ModelInfo; // r4
  RpAtomic_0 *v5; // r5
  RpClump_0 *v6; // r0
  RwFrame_0 *parent; // r6
  RpClump_0 *v8; // r4
  CBaseModelInfo *v9; // r4
  RpAtomic_0 *v10; // r5
  RpClump_0 *v11; // r0
  RwFrame_0 *v12; // r6
  RpClump_0 *v13; // r4
  CBaseModelInfo *v14; // r4
  RpAtomic_0 *v15; // r5
  RpClump_0 *v16; // r0
  RwFrame_0 *v17; // r6
  RpClump_0 *v18; // r4
  int32 v19; // [sp+4h] [bp-24h] BYREF
  int32 pIndex; // [sp+8h] [bp-20h] BYREF
  int32 index[7]; // [sp+Ch] [bp-1Ch] BYREF

  v0 = 0;
  do
  {
    v1 = &C3dMarkers::m_aMarkerArray[v0++];
    p_m_fPulseFraction = (_QWORD *)&v1->m_fPulseFraction;
    v1->m_pRwObject = 0;
    *(_DWORD *)&v1->m_nType = 257;
    v1->m_nIdentifier = 0;
    v1->rwColour = (RwRGBA_0)-1;
    *(_DWORD *)&v1->m_nPulsePeriod = &stru_503FC.st_value;
    v1->m_nStartTime = 0;
    v1->m_fCameraRange = 0.0;
    v1->m_normal.x = 0.0;
    v1->m_normal.y = 0.0;
    v1->m_normal.z = 1.0;
    v1->m_LastMapReadX = 30000;
    v1 = (C3dMarker *)((char *)v1 + 140);
    *p_m_fPulseFraction = 0x3F8000003E800000LL;
    p_m_fPulseFraction[1] = 0x3F8000003F800000LL;
    *(_QWORD *)&v1->m_mat.xx = unk_5BFCF0;
    *(_QWORD *)&v1->m_mat.zx = 0LL;
  }
  while ( v0 != 32 );
  C3dMarkers::NumActiveMarkers = 0;
  *(_QWORD *)&C3dMarkers::m_pRpClumpArray[3] = 0LL;
  *(_QWORD *)&C3dMarkers::m_pRpClumpArray[5] = 0LL;
  C3dMarkers::m_angleDiamond = 0.0;
  *(_QWORD *)C3dMarkers::m_pRpClumpArray = 0LL;
  *(_QWORD *)&C3dMarkers::m_pRpClumpArray[2] = 0LL;
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  CFileMgr::ChangeDir((const unsigned __int8 *)&off_5BFD24);
  ModelInfo = CModelInfo::GetModelInfo("cylinder", &pIndex);
  CStreaming::RequestModel(pIndex, 2);
  CStreaming::LoadAllRequestedModels(0);
  v5 = (RpAtomic_0 *)(*((int (__fastcall **)(CBaseModelInfo *))ModelInfo->_vptr$CBaseModelInfo + 11))(ModelInfo);
  CBaseModelInfo::AddRef(ModelInfo);
  v6 = RpClumpCreate();
  parent = (RwFrame_0 *)v5->object.object.parent;
  v8 = v6;
  RwFrameSetIdentity(parent);
  RpClumpAddAtomic(v8, v5);
  v8->object.parent = parent;
  C3dMarkers::m_pRpClumpArray[1] = v8;
  v9 = CModelInfo::GetModelInfo("hoop", index);
  CStreaming::RequestModel(index[0], 2);
  CStreaming::LoadAllRequestedModels(0);
  v10 = (RpAtomic_0 *)(*((int (__fastcall **)(CBaseModelInfo *))v9->_vptr$CBaseModelInfo + 11))(v9);
  CBaseModelInfo::AddRef(v9);
  v11 = RpClumpCreate();
  v12 = (RwFrame_0 *)v10->object.object.parent;
  v13 = v11;
  RwFrameSetIdentity(v12);
  RpClumpAddAtomic(v13, v10);
  v13->object.parent = v12;
  C3dMarkers::m_pRpClumpArray[4] = v13;
  v14 = CModelInfo::GetModelInfo("diamond_3", &v19);
  CStreaming::RequestModel(v19, 2);
  CStreaming::LoadAllRequestedModels(0);
  v15 = (RpAtomic_0 *)(*((int (__fastcall **)(CBaseModelInfo *))v14->_vptr$CBaseModelInfo + 11))(v14);
  CBaseModelInfo::AddRef(v14);
  v16 = RpClumpCreate();
  v17 = (RwFrame_0 *)v15->object.object.parent;
  v18 = v16;
  RwFrameSetIdentity(v17);
  RpClumpAddAtomic(v18, v15);
  v18->object.parent = v17;
  C3dMarkers::m_pRpClumpArray[0] = v18;
  C3dMarkers::m_pRpClumpArray[5] = v18;
  C3dMarkers::m_pRpClumpArray[6] = v18;
  CTxdStore::PopCurrentTxd();
}
// 503FC: using guessed type Elf32_Sym stru_503FC;
// 5BFD24: using guessed type int *off_5BFD24;
// 5BFB60: using guessed type int32 index[7];

//----- (005BFD50) --------------------------------------------------------
void CCheckpoints::Init()
{
  int v0; // r5
  CCheckpoint *v1; // r6
  float *p_m_fPulseFraction; // r2

  v0 = 0;
  do
  {
    v1 = &CCheckpoints::m_aCheckPtArray[v0];
    CCheckpoints::m_aCheckPtArray[v0].m_nType = 257;
    p_m_fPulseFraction = &CCheckpoints::m_aCheckPtArray[v0].m_fPulseFraction;
    v1->m_bIsUsed = 0;
    ++v0;
    v1->m_nIdentifier = 0;
    v1->rwColour = (RwRGBA_0)-1;
    v1->m_nPulsePeriod = 1024;
    v1->m_nRotateRate = 5;
    v1->m_pointDir.y = 0.0;
    v1->m_pointDir.z = 0.0;
    v1->m_rotFlag = 1;
    *(_QWORD *)p_m_fPulseFraction = 0x3F8000003E800000LL;
    *((_QWORD *)p_m_fPulseFraction + 1) = 0LL;
    *(_QWORD *)&v1->m_pos.x = 0LL;
    *(_QWORD *)&v1->m_pos.z = 0LL;
  }
  while ( v0 != 32 );
  CCheckpoints::NumActiveCPts = 0;
}

//----- (005BFDD8) --------------------------------------------------------
void CMirrors::Init()
{
  CMirrors::MirrorFlags = 0;
  CMirrors::TypeOfMirror = 0;
}

//----- (005BFDF4) --------------------------------------------------------
void CSpecialFX::Shutdown()
{
  C3dMarkers::Shutdown();
  if ( gpFinishFlagTex )
  {
    RwTextureDestroy(gpFinishFlagTex);
    gpFinishFlagTex = 0;
  }
  if ( CMirrors::pBuffer )
  {
    RwRasterDestroy(CMirrors::pBuffer);
    CMirrors::pBuffer = 0;
  }
  if ( CMirrors::pZBuffer )
  {
    RwRasterDestroy(CMirrors::pZBuffer);
    CMirrors::pZBuffer = 0;
  }
}

//----- (005BFE64) --------------------------------------------------------
void C3dMarkers::Shutdown()
{
  int i; // r5
  RpAtomic_0 *m_pRwObject; // r0
  C3dMarker *v2; // r1
  RwFrame_0 *parent; // r4
  int j; // r5
  RpClump_0 *v5; // r0

  for ( i = 0; i != 32; ++i )
  {
    m_pRwObject = (RpAtomic_0 *)C3dMarkers::m_aMarkerArray[i].m_pRwObject;
    if ( m_pRwObject )
    {
      v2 = &C3dMarkers::m_aMarkerArray[i];
      v2->m_nStartTime = 0;
      *(_DWORD *)&v2->m_nType = 257;
      v2->m_nIdentifier = 0;
      parent = (RwFrame_0 *)m_pRwObject->object.object.parent;
      RpAtomicDestroy(m_pRwObject);
      RwFrameDestroy(parent);
      C3dMarkers::m_aMarkerArray[i].m_pRwObject = 0;
    }
  }
  for ( j = 0; j != 7; ++j )
  {
    v5 = C3dMarkers::m_pRpClumpArray[j];
    if ( v5 )
    {
      RpClumpForAllAtomics(v5, RemoveRefsCB, 0);
      RpClumpDestroy(C3dMarkers::m_pRpClumpArray[j]);
      if ( j * 4 )
      {
        if ( C3dMarkers::m_pRpClumpArray[0] == C3dMarkers::m_pRpClumpArray[j] )
          C3dMarkers::m_pRpClumpArray[0] = 0;
        if ( j == 1 )
          goto LABEL_16;
      }
      if ( C3dMarkers::m_pRpClumpArray[1] == C3dMarkers::m_pRpClumpArray[j] )
        C3dMarkers::m_pRpClumpArray[1] = 0;
      if ( j != 2 )
      {
LABEL_16:
        if ( C3dMarkers::m_pRpClumpArray[2] == C3dMarkers::m_pRpClumpArray[j] )
          C3dMarkers::m_pRpClumpArray[2] = 0;
        if ( j == 3 )
          goto LABEL_22;
      }
      if ( C3dMarkers::m_pRpClumpArray[3] == C3dMarkers::m_pRpClumpArray[j] )
        C3dMarkers::m_pRpClumpArray[3] = 0;
      if ( j != 4 )
      {
LABEL_22:
        if ( C3dMarkers::m_pRpClumpArray[4] == C3dMarkers::m_pRpClumpArray[j] )
          C3dMarkers::m_pRpClumpArray[4] = 0;
        if ( j == 5 )
          goto LABEL_26;
      }
      if ( C3dMarkers::m_pRpClumpArray[5] == C3dMarkers::m_pRpClumpArray[j] )
        C3dMarkers::m_pRpClumpArray[5] = 0;
      if ( j != 6 )
      {
LABEL_26:
        if ( C3dMarkers::m_pRpClumpArray[6] == C3dMarkers::m_pRpClumpArray[j] )
          C3dMarkers::m_pRpClumpArray[6] = 0;
      }
      C3dMarkers::m_pRpClumpArray[j] = 0;
    }
  }
}

//----- (005C0040) --------------------------------------------------------
void CMirrors::ShutDown()
{
  if ( CMirrors::pBuffer )
  {
    RwRasterDestroy(CMirrors::pBuffer);
    CMirrors::pBuffer = 0;
  }
  if ( CMirrors::pZBuffer )
  {
    RwRasterDestroy(CMirrors::pZBuffer);
    CMirrors::pZBuffer = 0;
  }
}

//----- (005C008C) --------------------------------------------------------
void __fastcall CSpecialFX::AddWeaponStreak(int32 nWeaponType)
{
  char v2; // r0
  RpClump_0 *m_pWeaponClump; // r8
  RwMatrix *v4; // r0
  int v5; // r0
  RwMatrix *LTM; // r0
  int v7; // r0
  RwMatrix *v8; // r0
  CVector v9; // [sp+20h] [bp-70h] BYREF
  CVector v; // [sp+2Ch] [bp-64h] BYREF
  CMatrix v11; // [sp+38h] [bp-58h] BYREF

  v2 = `guard variable for'CSpecialFX::AddWeaponStreak(int)::MatLTM;
  __dmb(0xBu);
  if ( (v2 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'CSpecialFX::AddWeaponStreak(int)::MatLTM) )
  {
    CSpecialFX::AddWeaponStreak(int)::MatLTM.m_pRwMat = 0;
    CSpecialFX::AddWeaponStreak(int)::MatLTM.m_owner = 0;
    _cxa_atexit((void (__fastcall *)(void *))CMatrix::~CMatrix, &CSpecialFX::AddWeaponStreak(int)::MatLTM, &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CSpecialFX::AddWeaponStreak(int)::MatLTM);
  }
  if ( FindPlayerPed(-1) && FindPlayerPed(-1)->m_pWeaponClump )
  {
    m_pWeaponClump = FindPlayerPed(-1)->m_pWeaponClump;
    switch ( nWeaponType )
    {
      case 2:
        LTM = RwFrameGetLTM((RwFrame_0 *)m_pWeaponClump->object.parent);
        CMatrix::CMatrix(&v11, LTM, 0);
        CMatrix::operator=(&CSpecialFX::AddWeaponStreak(int)::MatLTM, &v11);
        CMatrix::~CMatrix(&v11);
        v.y = 0.05;
        v.x = 0.02;
        v.z = 0.07;
        operator*((CVector *)&v11, &CSpecialFX::AddWeaponStreak(int)::MatLTM, &v);
        v9.y = 0.0325;
        v5 = -1117966565;
        break;
      case 8:
        v8 = RwFrameGetLTM((RwFrame_0 *)m_pWeaponClump->object.parent);
        CMatrix::CMatrix(&v11, v8, 0);
        CMatrix::operator=(&CSpecialFX::AddWeaponStreak(int)::MatLTM, &v11);
        CMatrix::~CMatrix(&v11);
        v.y = 0.05;
        v.x = 0.02;
        v.z = 0.07;
        operator*((CVector *)&v11, &CSpecialFX::AddWeaponStreak(int)::MatLTM, &v);
        v9.y = -0.0175;
        v9.x = 0.096;
        v7 = 1066158522;
        goto LABEL_13;
      case 5:
        v4 = RwFrameGetLTM((RwFrame_0 *)m_pWeaponClump->object.parent);
        CMatrix::CMatrix(&v11, v4, 0);
        CMatrix::operator=(&CSpecialFX::AddWeaponStreak(int)::MatLTM, &v11);
        CMatrix::~CMatrix(&v11);
        v.y = 0.05;
        v.x = 0.02;
        v.z = 0.07;
        operator*((CVector *)&v11, &CSpecialFX::AddWeaponStreak(int)::MatLTM, &v);
        v9.y = 0.0325;
        v5 = 1048307565;
        break;
      default:
        return;
    }
    LODWORD(v9.x) = v5;
    v7 = 1061930664;
LABEL_13:
    LODWORD(v9.z) = v7;
    operator*(&v, &CSpecialFX::AddWeaponStreak(int)::MatLTM, &v9);
    CMotionBlurStreaks::RegisterStreak(
      (u_native)m_pWeaponClump,
      0x64u,
      0x64u,
      0x64u,
      0xFFu,
      (_DWORD *)LODWORD(v11.xx),
      v11.yx,
      v11.zx,
      v.x,
      v.y);
  }
}
// A5A110: using guessed type char `guard variable for'CSpecialFX::AddWeaponStreak(int)::MatLTM;

//----- (005C02A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CMotionBlurStreaks::RegisterStreak(
        u_native ID,
        UInt8 R,
        UInt8 G,
        UInt8 B,
        UInt8 a5,
        _DWORD a6[2],
        RwReal a7,
        RwReal a8,
        RwReal a9,
        RwReal a10)
{
  RwReal v10; // r12
  RwReal v11; // lr
  RwReal v12; // r5
  __int16 v13; // r0
  CRegisteredMotionBlurStreak *v14; // r0
  __int16 v15; // r4
  CRegisteredMotionBlurStreak *v16; // r12
  CRegisteredMotionBlurStreak *v17; // r6

  v11 = a10;
  v10 = a9;
  v12 = a8;
  if ( CMotionBlurStreaks::aStreaks[0].ID == ID )
  {
    v13 = 0;
LABEL_10:
    v14 = &CMotionBlurStreaks::aStreaks[v13];
    v14->G = G;
    v14->R = R;
    v14->B = B;
    v14->A = a5;
    *(_QWORD *)&v14->FirstPoints[0].x = *(_QWORD *)a6;
    v14->FirstPoints[0].z = a7;
    v14->SecondPoints[0].x = v12;
    v14->SecondPoints[0].y = v10;
    v14->SecondPoints[0].z = v11;
    v14->bThisOneUsed[0] = 1;
    return;
  }
  if ( CMotionBlurStreaks::aStreaks[1].ID == ID )
  {
    v13 = 1;
    goto LABEL_10;
  }
  if ( CMotionBlurStreaks::aStreaks[2].ID == ID )
  {
    v13 = 2;
LABEL_9:
    v10 = a9;
    v12 = a8;
    goto LABEL_10;
  }
  if ( CMotionBlurStreaks::aStreaks[3].ID == ID )
  {
    v13 = 3;
    v11 = a10;
    goto LABEL_9;
  }
  if ( CMotionBlurStreaks::aStreaks[0].ID )
  {
    if ( CMotionBlurStreaks::aStreaks[1].ID )
    {
      if ( CMotionBlurStreaks::aStreaks[2].ID )
      {
        if ( CMotionBlurStreaks::aStreaks[3].ID )
          return;
        v15 = 3;
        v16 = &CMotionBlurStreaks::aStreaks[3];
      }
      else
      {
        v15 = 2;
        v16 = &CMotionBlurStreaks::aStreaks[2];
      }
    }
    else
    {
      v15 = 1;
      v16 = &CMotionBlurStreaks::aStreaks[1];
    }
  }
  else
  {
    v15 = 0;
    v16 = CMotionBlurStreaks::aStreaks;
  }
  v16->ID = ID;
  v17 = &CMotionBlurStreaks::aStreaks[v15];
  v17->G = G;
  v17->R = R;
  v17->B = B;
  v17->A = a5;
  *(_QWORD *)&v17->FirstPoints[0].x = *(_QWORD *)a6;
  v17->FirstPoints[0].z = a7;
  v17->SecondPoints[0].x = a8;
  v17->SecondPoints[0].y = a9;
  v17->SecondPoints[0].z = a10;
  *(_WORD *)&v17->bThisOneUsed[1] = 0;
  v17->bThisOneUsed[0] = 1;
}
// 5C02A0: array has been used for an input argument

//----- (005C03E4) --------------------------------------------------------
void CSpecialFX::Update()
{
  int v0; // r6
  uint32 v1; // r0
  int v2; // r5

  CMotionBlurStreaks::Update();
  v0 = 0;
  v1 = CTimer::m_snTimeInMilliseconds;
  do
  {
    if ( CBulletTraces::aTraces[v0].bIsUsed
      && v1 - CBulletTraces::aTraces[v0].TimeCreated >= CBulletTraces::aTraces[v0].LifeTime )
    {
      CBulletTraces::aTraces[v0].bIsUsed = 0;
    }
    ++v0;
  }
  while ( v0 != 16 );
  CCheckpoints::Update();
  v2 = 0;
  C3dMarkers::m_angleDiamond = C3dMarkers::m_angleDiamond + (float)(CTimer::ms_fTimeStep * 5.0);
  do
  {
    if ( C3dMarkers::m_aMarkerArray[v2].m_bIsUsed )
    {
      CMatrix::UpdateRW(&C3dMarkers::m_aMarkerArray[v2].m_mat);
      RwFrameUpdateObjects((RwFrame_0 *)C3dMarkers::m_aMarkerArray[v2].m_pRwObject->parent);
      C3dMarkers::m_aMarkerArray[v2].m_bIsActive = 1;
    }
    ++v2;
  }
  while ( v2 != 32 );
}

//----- (005C04AC) --------------------------------------------------------
void CMotionBlurStreaks::Update()
{
  _BOOL4 v0; // r3
  _BOOL4 v1; // r2
  _BOOL4 v2; // r3
  _BOOL4 v3; // r2
  _BOOL4 v4; // r3
  _BOOL4 v5; // r2
  _BOOL4 v6; // r3
  _BOOL4 v7; // r2

  if ( CMotionBlurStreaks::aStreaks[0].ID )
  {
    v0 = CMotionBlurStreaks::aStreaks[0].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[0].FirstPoints[2] = CMotionBlurStreaks::aStreaks[0].FirstPoints[1];
    CMotionBlurStreaks::aStreaks[0].SecondPoints[2] = CMotionBlurStreaks::aStreaks[0].SecondPoints[1];
    CMotionBlurStreaks::aStreaks[0].bThisOneUsed[2] = CMotionBlurStreaks::aStreaks[0].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[0].FirstPoints[1] = CMotionBlurStreaks::aStreaks[0].FirstPoints[0];
    CMotionBlurStreaks::aStreaks[0].SecondPoints[1] = CMotionBlurStreaks::aStreaks[0].SecondPoints[0];
    v1 = CMotionBlurStreaks::aStreaks[0].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[0].bThisOneUsed[1] = CMotionBlurStreaks::aStreaks[0].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[0].bThisOneUsed[0] = 0;
    if ( !((v1 || v0) << 24) )
      CMotionBlurStreaks::aStreaks[0].ID = 0;
  }
  if ( CMotionBlurStreaks::aStreaks[1].ID )
  {
    v2 = CMotionBlurStreaks::aStreaks[1].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[1].FirstPoints[2] = CMotionBlurStreaks::aStreaks[1].FirstPoints[1];
    CMotionBlurStreaks::aStreaks[1].SecondPoints[2] = CMotionBlurStreaks::aStreaks[1].SecondPoints[1];
    CMotionBlurStreaks::aStreaks[1].bThisOneUsed[2] = CMotionBlurStreaks::aStreaks[1].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[1].FirstPoints[1] = CMotionBlurStreaks::aStreaks[1].FirstPoints[0];
    v3 = CMotionBlurStreaks::aStreaks[1].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[1].SecondPoints[1] = CMotionBlurStreaks::aStreaks[1].SecondPoints[0];
    CMotionBlurStreaks::aStreaks[1].bThisOneUsed[1] = CMotionBlurStreaks::aStreaks[1].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[1].bThisOneUsed[0] = 0;
    if ( !((v3 || v2) << 24) )
      CMotionBlurStreaks::aStreaks[1].ID = 0;
  }
  if ( CMotionBlurStreaks::aStreaks[2].ID )
  {
    v4 = CMotionBlurStreaks::aStreaks[2].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[2].FirstPoints[2] = CMotionBlurStreaks::aStreaks[2].FirstPoints[1];
    CMotionBlurStreaks::aStreaks[2].SecondPoints[2] = CMotionBlurStreaks::aStreaks[2].SecondPoints[1];
    CMotionBlurStreaks::aStreaks[2].bThisOneUsed[2] = CMotionBlurStreaks::aStreaks[2].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[2].FirstPoints[1] = CMotionBlurStreaks::aStreaks[2].FirstPoints[0];
    v5 = CMotionBlurStreaks::aStreaks[2].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[2].SecondPoints[1] = CMotionBlurStreaks::aStreaks[2].SecondPoints[0];
    CMotionBlurStreaks::aStreaks[2].bThisOneUsed[1] = CMotionBlurStreaks::aStreaks[2].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[2].bThisOneUsed[0] = 0;
    if ( !((v5 || v4) << 24) )
      CMotionBlurStreaks::aStreaks[2].ID = 0;
  }
  if ( CMotionBlurStreaks::aStreaks[3].ID )
  {
    v6 = CMotionBlurStreaks::aStreaks[3].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[3].FirstPoints[2] = CMotionBlurStreaks::aStreaks[3].FirstPoints[1];
    CMotionBlurStreaks::aStreaks[3].SecondPoints[2] = CMotionBlurStreaks::aStreaks[3].SecondPoints[1];
    CMotionBlurStreaks::aStreaks[3].bThisOneUsed[2] = CMotionBlurStreaks::aStreaks[3].bThisOneUsed[1];
    CMotionBlurStreaks::aStreaks[3].FirstPoints[1] = CMotionBlurStreaks::aStreaks[3].FirstPoints[0];
    v7 = CMotionBlurStreaks::aStreaks[3].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[3].SecondPoints[1] = CMotionBlurStreaks::aStreaks[3].SecondPoints[0];
    CMotionBlurStreaks::aStreaks[3].bThisOneUsed[1] = CMotionBlurStreaks::aStreaks[3].bThisOneUsed[0];
    CMotionBlurStreaks::aStreaks[3].bThisOneUsed[0] = 0;
    if ( !((v7 || v6) << 24) )
      CMotionBlurStreaks::aStreaks[3].ID = 0;
  }
}

//----- (005C06B0) --------------------------------------------------------
void CBulletTraces::Update()
{
  int v0; // r1
  uint32 v1; // lr

  v0 = 0;
  v1 = CTimer::m_snTimeInMilliseconds;
  do
  {
    if ( CBulletTraces::aTraces[v0].bIsUsed
      && v1 - CBulletTraces::aTraces[v0].TimeCreated >= CBulletTraces::aTraces[v0].LifeTime )
    {
      CBulletTraces::aTraces[v0].bIsUsed = 0;
    }
    ++v0;
  }
  while ( v0 != 16 );
}

//----- (005C0704) --------------------------------------------------------
void CCheckpoints::Update()
{
  int i; // r8
  int m_nType; // r0
  float m_multiSize; // s0
  _BOOL4 m_rotFlag; // r2
  bool v4; // zf
  float *v5; // r1
  float v6; // s0
  CCheckpoint *v7; // r0
  RwReal v8; // s2
  RwReal v9; // s4
  RwReal v10; // s0
  float v11; // s0
  _BOOL4 v12; // r2
  int *v13; // r1
  float v14; // s0
  float x; // s0
  float y; // s2
  float v17; // s6
  float v18; // s8
  float m_fSize; // s4
  float v20; // s12
  float v21; // s10
  float v22; // s0
  _BOOL4 v23; // r2
  int *v24; // r1
  float v25; // s0
  CCheckpoint *v26; // r0
  float v27; // s0
  float v28; // s2
  float v29; // s0
  CCheckpoint *v30; // r0
  float z; // s0
  CVector v32; // [sp+34h] [bp-5Ch] BYREF

  FindPlayerCoors(&v32, -1);
  for ( i = 0; i != 32; ++i )
  {
    m_nType = CCheckpoints::m_aCheckPtArray[i].m_nType;
    if ( m_nType == 5 )
    {
      m_multiSize = CCheckpoints::m_aCheckPtArray[i].m_multiSize;
      if ( m_multiSize > 0.5 && CCheckpoints::m_aCheckPtArray[i].m_rotFlag )
        CCheckpoints::m_aCheckPtArray[i].m_rotFlag = 0;
      m_rotFlag = CCheckpoints::m_aCheckPtArray[i].m_rotFlag;
      if ( m_multiSize < -0.5 )
      {
        v4 = !m_rotFlag;
        m_rotFlag = 1;
        if ( v4 )
        {
          CCheckpoints::m_aCheckPtArray[i].m_rotFlag = 1;
          m_rotFlag = 1;
        }
      }
      v5 = (float *)sub_5C0A40;
      if ( m_rotFlag )
        v5 = (float *)&dword_5C0A44;
      v6 = *v5;
      CCheckpoints::m_aCheckPtArray[i].m_multiSize = *v5;
      v7 = &CCheckpoints::m_aCheckPtArray[i];
      v8 = CCheckpoints::m_aCheckPtArray[i].m_pointDir.x + v6;
      v9 = v6 + CCheckpoints::m_aCheckPtArray[i].m_pointDir.y;
      v10 = v6 + CCheckpoints::m_aCheckPtArray[i].m_pointDir.z;
      v7->m_pointDir.x = v8;
      v7->m_pointDir.y = v9;
      v7->m_pointDir.z = v10;
      CVector::Normalise(&CCheckpoints::m_aCheckPtArray[i].m_pointDir);
      m_nType = CCheckpoints::m_aCheckPtArray[i].m_nType;
    }
    if ( m_nType == 8 )
    {
      x = v32.x;
      y = v32.y;
      v17 = CCheckpoints::m_aCheckPtArray[i].m_pos.x;
      v18 = CCheckpoints::m_aCheckPtArray[i].m_pos.y;
      m_fSize = CCheckpoints::m_aCheckPtArray[i].m_fSize;
    }
    else
    {
      if ( m_nType != 7 )
      {
        if ( m_nType == 6 )
        {
          v11 = CCheckpoints::m_aCheckPtArray[i].m_multiSize;
          if ( v11 > 0.75 && CCheckpoints::m_aCheckPtArray[i].m_rotFlag )
            CCheckpoints::m_aCheckPtArray[i].m_rotFlag = 0;
          v12 = CCheckpoints::m_aCheckPtArray[i].m_rotFlag;
          if ( v11 < 0.0 )
          {
            v4 = !v12;
            v12 = 1;
            if ( v4 )
            {
              CCheckpoints::m_aCheckPtArray[i].m_rotFlag = 1;
              v12 = 1;
            }
          }
          v13 = dword_5C0A8C;
          if ( v12 )
            v13 = &dword_5C0A8C[1];
          v14 = v11 + *(float *)v13;
          CCheckpoints::m_aCheckPtArray[i].m_multiSize = v14;
          if ( v14 < 0.0 )
            CCheckpoints::m_aCheckPtArray[i].m_nType = 257;
        }
        continue;
      }
      x = v32.x;
      y = v32.y;
      v17 = CCheckpoints::m_aCheckPtArray[i].m_pos.x;
      v18 = CCheckpoints::m_aCheckPtArray[i].m_pos.y;
      m_fSize = CCheckpoints::m_aCheckPtArray[i].m_fSize;
      v20 = fabsf(v32.x - v17);
      v21 = fabsf(v32.y - v18);
      if ( (float)((float)(v20 * v20) + (float)(v21 * v21)) > (float)(m_fSize * m_fSize) )
      {
        v22 = CCheckpoints::m_aCheckPtArray[i].m_multiSize;
        if ( v22 > 0.2 && CCheckpoints::m_aCheckPtArray[i].m_rotFlag )
          CCheckpoints::m_aCheckPtArray[i].m_rotFlag = 0;
        v23 = CCheckpoints::m_aCheckPtArray[i].m_rotFlag;
        if ( v22 < -0.2 )
        {
          v4 = !v23;
          v23 = 1;
          if ( v4 )
          {
            CCheckpoints::m_aCheckPtArray[i].m_rotFlag = 1;
            v23 = 1;
          }
        }
        v24 = dword_5C0A74;
        if ( v23 )
          v24 = &dword_5C0A74[1];
        v25 = v22 + *(float *)v24;
        CCheckpoints::m_aCheckPtArray[i].m_multiSize = v25;
        v26 = &CCheckpoints::m_aCheckPtArray[i];
        v27 = CCheckpoints::m_aCheckPtArray[i].m_pos.z + v25;
        goto LABEL_41;
      }
      CCheckpoints::m_aCheckPtArray[i].m_nType = 8;
      CCheckpoints::m_aCheckPtArray[i].m_multiSize = -0.1;
    }
    v28 = fabsf(y - v18);
    v29 = fabsf(x - v17);
    if ( (float)((float)(v29 * v29) + (float)(v28 * v28)) > (float)(m_fSize * m_fSize) )
    {
      CCheckpoints::m_aCheckPtArray[i].m_nType = 7;
      v30 = &CCheckpoints::m_aCheckPtArray[i];
      v30->m_rotFlag = 1;
      v30->m_multiSize = 0.02;
    }
    v26 = &CCheckpoints::m_aCheckPtArray[i];
    z = CCheckpoints::m_aCheckPtArray[i].m_pos.z;
    if ( z > (float)(v32.z + -0.75) )
    {
      v27 = z + CCheckpoints::m_aCheckPtArray[i].m_multiSize;
LABEL_41:
      v26->m_pos.z = v27;
      continue;
    }
  }
}
// 5C0A40: using guessed type int sub_5C0A40();
// 5C0A44: using guessed type int;
// 5C0A74: using guessed type int dword_5C0A74[2];
// 5C0A8C: using guessed type int dword_5C0A8C[2];

//----- (005C0A98) --------------------------------------------------------
void C3dMarkers::Update()
{
  int v0; // r5

  v0 = 0;
  C3dMarkers::m_angleDiamond = C3dMarkers::m_angleDiamond + (float)(CTimer::ms_fTimeStep * 5.0);
  do
  {
    if ( C3dMarkers::m_aMarkerArray[v0].m_bIsUsed )
    {
      CMatrix::UpdateRW(&C3dMarkers::m_aMarkerArray[v0].m_mat);
      RwFrameUpdateObjects((RwFrame_0 *)C3dMarkers::m_aMarkerArray[v0].m_pRwObject->parent);
      C3dMarkers::m_aMarkerArray[v0].m_bIsActive = 1;
    }
    ++v0;
  }
  while ( v0 != 32 );
}

//----- (005C0B14) --------------------------------------------------------
void CSpecialFX::Render()
{
  int i; // r4

  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  CMotionBlurStreaks::Render();
  if ( MobileSettings::settings[0].value == 3 )
    CBulletTraces::Render();
  CShinyTexts::Render();
  C3dMarkers::Render();
  for ( i = 0; i != 32; ++i )
  {
    if ( CCheckpoints::m_aCheckPtArray[i].m_bIsUsed )
      CCheckpoint::Render(&CCheckpoints::m_aCheckPtArray[i]);
  }
  sub_192840(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C0BA8) --------------------------------------------------------
void CMotionBlurStreaks::Render()
{
  int v0; // r5
  int v1; // r0

  v0 = 0;
  v1 = 0;
  do
  {
    if ( CMotionBlurStreaks::aStreaks[v0].ID )
    {
      if ( !(v1 << 31) )
      {
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
        RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(
          rwRENDERSTATEFOGCOLOR,
          (void *)((CTimeCycle::m_CurrentColours.m_nSkyBottomRed << 16) | (CTimeCycle::m_CurrentColours.m_nSkyBottomGreen << 8) | CTimeCycle::m_CurrentColours.m_nSkyBottomBlue | 0xFF000000));
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      }
      CRegisteredMotionBlurStreak::Render(&CMotionBlurStreaks::aStreaks[v0]);
      v1 = 1;
    }
    ++v0;
  }
  while ( v0 != 4 );
  if ( v1 << 31 )
  {
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    sub_192840(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C0C54) --------------------------------------------------------
void CBulletTraces::Render()
{
  int v0; // r5
  CBulletTrace *v1; // r9
  CSimpleTransform *p_tx; // r1
  RwReal v3; // s2
  RwReal v4; // s4
  RwReal v5; // s20
  RwReal y; // s18
  RwReal v7; // s22
  float v8; // s2
  float Opaqueness; // s4
  float v10; // s0
  float v11; // s10
  float z; // s12
  float v13; // s14
  unsigned int v14; // r0
  float x; // s4
  RwReal v16; // s6
  RwReal v17; // s8
  RwReal v18; // s0
  float v19; // s1
  float v20; // s2
  float v21; // s14
  CVector v22; // [sp+Ch] [bp-154h] BYREF
  CVector v23; // [sp+18h] [bp-148h] BYREF
  CVector v24; // [sp+24h] [bp-13Ch] BYREF
  RwIm3DVertex pVerts; // [sp+30h] [bp-130h] BYREF
  float v26; // [sp+54h] [bp-10Ch]
  float v27; // [sp+58h] [bp-108h]
  float v28; // [sp+5Ch] [bp-104h]
  UInt8 *v29; // [sp+6Ch] [bp-F4h]
  float v30; // [sp+78h] [bp-E8h]
  float v31; // [sp+7Ch] [bp-E4h]
  float v32; // [sp+80h] [bp-E0h]
  UInt8 *v33; // [sp+90h] [bp-D0h]
  float v34; // [sp+9Ch] [bp-C4h]
  float v35; // [sp+A0h] [bp-C0h]
  float v36; // [sp+A4h] [bp-BCh]
  unsigned int v37; // [sp+B4h] [bp-ACh]
  float v38; // [sp+C0h] [bp-A0h]
  float v39; // [sp+C4h] [bp-9Ch]
  float v40; // [sp+C8h] [bp-98h]
  UInt8 *v41; // [sp+D8h] [bp-88h]
  float v42; // [sp+E4h] [bp-7Ch]
  float v43; // [sp+E8h] [bp-78h]
  float v44; // [sp+ECh] [bp-74h]
  UInt8 *v45; // [sp+FCh] [bp-64h]
  __int64 indices[11]; // [sp+108h] [bp-58h] BYREF

  v0 = 0;
  indices[0] = 0x1000300010004LL;
  indices[1] = unk_61FA00;
  indices[2] = unk_61FA08;
  do
  {
    if ( CBulletTraces::aTraces[v0].bIsUsed )
    {
      v1 = &CBulletTraces::aTraces[v0];
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      v3 = CBulletTraces::aTraces[v0].Start.y - p_tx->m_translate.y;
      v4 = CBulletTraces::aTraces[v0].Start.z - p_tx->m_translate.z;
      v24.x = CBulletTraces::aTraces[v0].Start.x - p_tx->m_translate.x;
      v24.y = v3;
      v24.z = v4;
      CVector::Normalise(&v24);
      v5 = v1->End.x - v1->Start.x;
      v7 = v1->End.z - v1->Start.z;
      v23.y = v1->End.y - v1->Start.y;
      y = v23.y;
      v23.x = v5;
      v23.z = v7;
      CVector::Normalise(&v23);
      CrossProduct(&v22, &v24, &v23);
      CVector::Normalise(&v22);
      v8 = 1.0 - (float)((float)(CTimer::m_snTimeInMilliseconds - v1->TimeCreated) / (float)v1->LifeTime);
      Opaqueness = (float)v1->Opaqueness;
      pVerts.color = (RwRGBA_0)&CTheScripts::ScriptSpace[338027];
      v10 = sqrtf((float)((float)(v5 * v5) + (float)(y * y)) + (float)(v7 * v7));
      v29 = &CTheScripts::ScriptSpace[338027];
      v33 = &CTheScripts::ScriptSpace[338027];
      v41 = &CTheScripts::ScriptSpace[338027];
      v11 = v1->End.y;
      z = v1->End.z;
      v13 = v8 * v1->Size;
      v45 = &CTheScripts::ScriptSpace[338027];
      v14 = (unsigned int)(float)(v8 * Opaqueness);
      x = v1->End.x;
      v16 = x - (float)(v8 * (float)(v10 * v23.x));
      v17 = v11 - (float)(v8 * (float)(v10 * v23.y));
      v18 = z - (float)(v8 * (float)(v10 * v23.z));
      v19 = v13 * v22.y;
      v20 = v22.x * v13;
      v21 = v13 * v22.z;
      v37 = (unsigned int)&CTheScripts::ScriptSpace[338027] | (v14 << 24);
      pVerts.position.z = v18;
      pVerts.position.y = v17;
      pVerts.position.x = v16;
      v26 = v20 + v16;
      v27 = v19 + v17;
      v28 = v21 + v18;
      v30 = v16 - v20;
      v31 = v17 - v19;
      v32 = v18 - v21;
      v34 = x;
      v35 = v11;
      v36 = z;
      v38 = v20 + x;
      v39 = v19 + v11;
      v40 = v21 + z;
      v42 = x - v20;
      v43 = v11 - v19;
      v44 = z - v21;
      if ( RwIm3DTransform(&pVerts, 6u, 0, 0x10u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, (RwImVertexIndex *)indices, 12);
        RwIm3DEnd();
      }
    }
    ++v0;
  }
  while ( v0 != 16 );
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C0EF8) --------------------------------------------------------
void CShinyTexts::Render()
{
  Int32 v0; // r9
  CShinyText *v1; // r4
  int v2; // r1
  Int32 v3; // r0
  int Red; // r10
  int Green; // r11
  int Blue; // r5
  RwTexture_0 *v7; // r2
  Int32 v8; // r2
  RwReal *p_x; // r1
  unsigned int v10; // r0
  RwReal y; // r5
  RwReal z; // r6
  float Tex1V; // r2
  RwReal v14; // r3
  RwReal v15; // r6
  float Tex2V; // r2
  RwReal v17; // r3
  RwReal v18; // r6
  Int32 v19; // r1
  float *v20; // r3
  float Tex3V; // r2
  RwReal v22; // r2
  RwReal v23; // r6
  Int32 v24; // r2
  RwImVertexIndex *v25; // r0
  RwTexture_0 *v26; // [sp+50h] [bp-28h]

  if ( CShinyTexts::NumShinyTexts )
  {
    RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
    if ( CShinyTexts::NumShinyTexts >= 1 )
    {
      v0 = 0;
      v1 = CShinyTexts::aShinyTexts;
      v2 = 0;
      v3 = 0;
      v26 = 0;
      do
      {
        if ( v2 && (v3 > 1984 || v2 > 4032) )
        {
          LittleTest();
          if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
          {
            RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
            RwIm3DEnd();
          }
          v2 = 0;
          TempBufferIndicesStored = 0;
          TempBufferVerticesStored = 0;
          v3 = 0;
        }
        if ( v1->Type == 1 )
        {
          Red = v1->Red;
          Green = v1->Green;
          Blue = v1->Blue;
          v7 = gpHandManTex;
          if ( v26 != gpHandManTex )
          {
            if ( v2 )
            {
              LittleTest();
              if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
              {
                RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
                RwIm3DEnd();
              }
              v7 = gpHandManTex;
              TempBufferIndicesStored = 0;
              TempBufferVerticesStored = 0;
            }
            RwRenderStateSet(rwRENDERSTATETEXTURERASTER, v7->raster);
            v3 = TempBufferVerticesStored;
            v26 = gpHandManTex;
          }
          v8 = v3;
          p_x = &TempVertexBuffer.m_3d[v3].position.x;
          v10 = Red | (Green << 8) | (Blue << 16) | 0xFF000000;
          *((_DWORD *)p_x + 6) = v10;
          y = v1->Coors1.y;
          z = v1->Coors1.z;
          TempVertexBuffer.m_3d[v8].position.x = v1->Coors1.x;
          p_x[1] = y;
          p_x[2] = z;
          p_x[7] = v1->Tex1U;
          Tex1V = v1->Tex1V;
          *((_DWORD *)p_x + 15) = v10;
          p_x[8] = Tex1V;
          v14 = v1->Coors2.y;
          v15 = v1->Coors2.z;
          p_x[9] = v1->Coors2.x;
          p_x[10] = v14;
          p_x[11] = v15;
          p_x[16] = v1->Tex2U;
          Tex2V = v1->Tex2V;
          *((_DWORD *)p_x + 24) = v10;
          p_x[17] = Tex2V;
          p_x += 18;
          v17 = v1->Coors3.y;
          v18 = v1->Coors3.z;
          *p_x = v1->Coors3.x;
          p_x[1] = v17;
          p_x[2] = v18;
          v19 = TempBufferVerticesStored;
          v20 = &TempVertexBuffer.m_3d[TempBufferVerticesStored].position.x;
          v20[25] = v1->Tex3U;
          Tex3V = v1->Tex3V;
          *((_DWORD *)v20 + 33) = v10;
          v20[26] = Tex3V;
          v22 = v1->Coors4.y;
          v23 = v1->Coors4.z;
          v20[27] = v1->Coors4.x;
          v20[28] = v22;
          v20[29] = v23;
          v20[34] = v1->Tex4U;
          v20[35] = v1->Tex4V;
          v24 = TempBufferIndicesStored;
          TempBufferRenderIndexList[TempBufferIndicesStored] = v19;
          v25 = &TempBufferRenderIndexList[v24];
          v25[1] = v19 + 1;
          v25[2] = v19 + 2;
          v25[3] = v19 + 2;
          v25[4] = v19 + 1;
          v25[5] = v19 + 3;
          v3 = v19 + 4;
          v2 = v24 + 6;
          TempBufferVerticesStored = v3;
          TempBufferIndicesStored = v24 + 6;
        }
        ++v0;
        ++v1;
      }
      while ( v0 < CShinyTexts::NumShinyTexts );
      if ( v2 )
      {
        LittleTest();
        if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
        {
          RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
          RwIm3DEnd();
        }
        TempBufferIndicesStored = 0;
        TempBufferVerticesStored = 0;
      }
    }
    CShinyTexts::NumShinyTexts = 0;
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C1280) --------------------------------------------------------
void C3dMarkers::Render()
{
  int i; // r8
  C3dMarker *v1; // r6
  float tz; // r0
  int32 v3; // r0
  RpAtomic_0 *m_pRwObject; // r0
  C3dMarker *v5; // r1
  RwFrame_0 *parent; // r6
  RwV3d_0 pointsIn; // [sp+34h] [bp-44h] BYREF

  C3dMarkers::NumActiveMarkers = 0;
  ActivateDirectional();
  SetAmbientColours(&C3dMarkers::Render(void)::AmbientL);
  SetDirectionalColours(&C3dMarkers::Render(void)::DirectL);
  C3dMarkers::User3dMarkersDraw();
  for ( i = 0; i != 32; ++i )
  {
    v1 = &C3dMarkers::m_aMarkerArray[i];
    if ( C3dMarkers::m_aMarkerArray[i].m_bIsActive )
    {
      if ( C3dMarkers::m_aMarkerArray[i].m_fCameraRange < 150.0
        || C3dMarkers::IgnoreRenderLimit
        || C3dMarkers::m_aMarkerArray[i].m_nType == 4 )
      {
        tz = C3dMarkers::m_aMarkerArray[i].m_mat.tz;
        *(_QWORD *)&pointsIn.x = *(_QWORD *)&C3dMarkers::m_aMarkerArray[i].m_mat.tx;
        pointsIn.z = tz;
        RwV3dTransformPoints(&pointsIn, &pointsIn, 1, (const RwMatrix *)&TheCamera.m_matInverse);
        if ( (float)(pointsIn.y + 2.0) >= CDraw::ms_fNearClipZ
          && (float)(pointsIn.y + -2.0) <= CDraw::ms_fFarClipZ
          && (float)((float)(pointsIn.x * TheCamera.m_vecFrustumNormals[0].x)
                   + (float)(pointsIn.y * TheCamera.m_vecFrustumNormals[0].y)) <= 2.0
          && (float)((float)(pointsIn.x * TheCamera.m_vecFrustumNormals[1].x)
                   + (float)(pointsIn.y * TheCamera.m_vecFrustumNormals[1].y)) <= 2.0
          && (float)((float)(pointsIn.y * TheCamera.m_vecFrustumNormals[2].y)
                   + (float)(pointsIn.z * TheCamera.m_vecFrustumNormals[2].z)) <= 2.0
          && (float)((float)(pointsIn.y * TheCamera.m_vecFrustumNormals[3].y)
                   + (float)(pointsIn.z * TheCamera.m_vecFrustumNormals[3].z)) <= 2.0 )
        {
          C3dMarker::Render(&C3dMarkers::m_aMarkerArray[i]);
        }
      }
      C3dMarkers::m_aMarkerArray[i].m_bIsUsed = 0;
      v3 = C3dMarkers::NumActiveMarkers;
      v1->m_bIsActive = 0;
      C3dMarkers::NumActiveMarkers = v3 + 1;
    }
    else
    {
      m_pRwObject = (RpAtomic_0 *)C3dMarkers::m_aMarkerArray[i].m_pRwObject;
      if ( m_pRwObject )
      {
        v5 = &C3dMarkers::m_aMarkerArray[i];
        v5->m_bIsUsed = 0;
        v5->m_nStartTime = 0;
        v5->m_nIdentifier = 0;
        v1->m_bIsActive = 0;
        v5->m_nType = 257;
        parent = (RwFrame_0 *)m_pRwObject->object.object.parent;
        RpAtomicDestroy(m_pRwObject);
        RwFrameDestroy(parent);
        C3dMarkers::m_aMarkerArray[i].m_pRwObject = 0;
      }
    }
  }
  C3dMarkers::DirectionArrowsDraw();
}

//----- (005C1528) --------------------------------------------------------
void CCheckpoints::Render()
{
  int i; // r4

  for ( i = 0; i != 32; ++i )
  {
    if ( CCheckpoints::m_aCheckPtArray[i].m_bIsUsed )
      CCheckpoint::Render(&CCheckpoints::m_aCheckPtArray[i]);
  }
  sub_192840(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;

//----- (005C156C) --------------------------------------------------------
void CSpecialFX::Render2DFXs()
{
  CRGBA v0; // r0
  RwInt32 screenHeight; // r4
  RwInt32 v2; // r6
  RwInt32 screenWidth; // s0
  float v4; // s16
  RwInt32 v5; // s0
  float v6; // s16
  __int16 v7; // r5
  float v8; // s16
  float v9; // r1
  const CRGBA *v10; // r0
  CRGBA v11; // r0
  RwInt32 v12; // r4
  RwInt32 v13; // r5
  RwInt32 v14; // s0
  float v15; // s16
  RwInt32 v16; // s0
  float v17; // s16
  __int16 v18; // r5
  float v19; // s16
  float v20; // r1
  int v21; // r4
  int v22; // r6
  int v23; // r1
  char *v24; // r2
  UInt32 v25; // r4
  float v26; // s16
  float v27; // s18
  const CRGBA *v28; // r0
  UInt8 alpha; // [sp+0h] [bp-60h]
  CRGBA v30; // [sp+14h] [bp-4Ch] BYREF
  CRect rgba; // [sp+18h] [bp-48h] BYREF
  CRGBA v32; // [sp+28h] [bp-38h] BYREF
  CRGBA v33; // [sp+2Ch] [bp-34h] BYREF

  if ( CSpecialFX::bVideoCam )
  {
    CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.5);
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    CFont::SetOrientation(1u);
    CRGBA::CRGBA(&v33, 0, 0xFFu, 0, 0xC8u);
    CFont::SetColor(v0);
    CFont::SetFontStyle(1u);
    sprintf(gString, (const unsigned __int8 *)&dword_5C1B5C, CTimer::m_FrameCounter & 0x3F);
    AsciiToGxtChar(gString, gGxtString);
    CFont::PrintString((float)(8 * RsGlobal.screenWidth / 10), (float)(8 * RsGlobal.screenHeight / 10), gGxtString);
    screenHeight = RsGlobal.screenHeight;
    if ( RsGlobal.screenHeight >= 1 )
    {
      v2 = 0;
      do
      {
        RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        screenWidth = RsGlobal.screenWidth;
        v4 = (float)RsGlobal.screenWidth;
        CRGBA::CRGBA((CRGBA *)&rgba, 0, 0x64u, 0, 0x64u);
        CSprite2d::Draw2DPolygon(
          0.0,
          (float)v2,
          (float)screenWidth,
          (float)v2,
          0.0,
          (float)(v2 + 1),
          v4,
          (float)(v2 + 1),
          (const CRGBA *)&rgba);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
        v5 = RsGlobal.screenWidth;
        v6 = (float)RsGlobal.screenWidth;
        CRGBA::CRGBA((CRGBA *)&rgba, 0, 0, 0, 0x96u);
        CSprite2d::Draw2DPolygon(
          0.0,
          (float)(v2 + 2),
          (float)v5,
          (float)(v2 + 2),
          0.0,
          (float)(v2 + 3),
          v6,
          (float)(v2 + 3),
          (const CRGBA *)&rgba);
        screenHeight = RsGlobal.screenHeight;
        v2 += 4;
      }
      while ( v2 < RsGlobal.screenHeight );
    }
    v7 = CTimer::m_snTimeInMilliseconds;
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    v8 = (float)RsGlobal.screenWidth;
    CRGBA::CRGBA((CRGBA *)&rgba, 0, 0x64u, 0, 0x3Cu);
    v9 = (float)(int)(float)((float)(int)(float)((float)((float)((float)screenHeight + 70.0) * 0.00048828)
                                               * (float)(v7 & 0x7FF))
                           + -70.0);
    CSprite2d::Draw2DPolygon(0.0, v9, v8, v9, 0.0, v9 + 70.0, v8, v9 + 70.0, v10);
  }
  if ( CSpecialFX::bLiftCam )
  {
    CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.5);
    CFont::SetBackground(0, 0);
    CFont::SetOrientation(1u);
    CFont::SetProportional(1u);
    CRGBA::CRGBA(&v32, 0x64u, 0x64u, 0x64u, 0xC8u);
    CFont::SetColor(v11);
    CFont::SetFontStyle(1u);
    v12 = RsGlobal.screenHeight;
    if ( RsGlobal.screenHeight >= 1 )
    {
      v13 = 0;
      do
      {
        RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        v14 = RsGlobal.screenWidth;
        v15 = (float)RsGlobal.screenWidth;
        CRGBA::CRGBA((CRGBA *)&rgba, 0x64u, 0x64u, 0x64u, 0x64u);
        CSprite2d::Draw2DPolygon(
          0.0,
          (float)v13,
          (float)v14,
          (float)v13,
          0.0,
          (float)(v13 + 1),
          v15,
          (float)(v13 + 1),
          (const CRGBA *)&rgba);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
        v16 = RsGlobal.screenWidth;
        v17 = (float)RsGlobal.screenWidth;
        CRGBA::CRGBA((CRGBA *)&rgba, 0, 0, 0, 0x96u);
        CSprite2d::Draw2DPolygon(
          0.0,
          (float)(v13 + 2),
          (float)v16,
          (float)(v13 + 2),
          0.0,
          (float)(v13 + 3),
          v17,
          (float)(v13 + 3),
          (const CRGBA *)&rgba);
        v12 = RsGlobal.screenHeight;
        v13 += 4;
      }
      while ( v13 < RsGlobal.screenHeight );
    }
    v18 = CTimer::m_snTimeInMilliseconds;
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    v19 = (float)RsGlobal.screenWidth;
    CRGBA::CRGBA((CRGBA *)&rgba, 0x64u, 0x64u, 0x64u, 0x3Cu);
    v20 = (float)(int)(float)((float)(int)(float)((float)((float)((float)v12 + 70.0) * 0.00048828) * (float)(v18 & 0x7FF))
                            + -70.0);
    CSprite2d::Draw2DPolygon(0.0, v20, v19, v20, 0.0, v20 + 70.0, v19, v20 + 70.0, (const CRGBA *)&rgba);
    v21 = 200;
    do
    {
      v22 = rand() % RsGlobal.screenWidth;
      v23 = rand() % RsGlobal.screenHeight;
      rgba.left = (float)v22;
      rgba.right = (float)(v22 + 20);
      rgba.bottom = (float)v23;
      rgba.top = (float)(v23 + 2);
      CRGBA::CRGBA(&v30, 0xFFu, 0xFFu, 0xFFu, 0x40u);
      CSprite2d::DrawRect(&rgba, &v30);
      --v21;
    }
    while ( v21 );
  }
  if ( CSpecialFX::bSnapShotActive )
  {
    v24 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
    *((_DWORD *)v24 + 130) = 0;
    *((_DWORD *)v24 + 126) = 0;
    v25 = ++CSpecialFX::SnapShotFrames;
    if ( CSpecialFX::SnapShotFrames < 0x15 )
    {
      CTimer::ms_fTimeScale = 0.0;
      if ( CSpecialFX::SnapShotFrames <= 9 )
      {
        RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        v26 = (float)RsGlobal.screenWidth;
        v27 = (float)RsGlobal.screenHeight;
        alpha = (unsigned int)(float)((float)(255 - 255 * v25 / 0xA) * 0.65);
        CRGBA::CRGBA((CRGBA *)&rgba, alpha, alpha, alpha, alpha);
        CSprite2d::Draw2DPolygon(0.0, 0.0, v26, 0.0, 0.0, v27, v26, v27, v28);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      }
    }
    else
    {
      CTimer::ms_fTimeScale = 1.0;
      CSpecialFX::bSnapShotActive = 0;
    }
  }
}
// 5C15DE: variable 'v0' is possibly undefined
// 5C17E0: variable 'v10' is possibly undefined
// 5C1846: variable 'v11' is possibly undefined
// 5C1B1E: variable 'v28' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 5C1B5C: using guessed type int dword_5C1B5C;

//----- (005C1BB4) --------------------------------------------------------
void __fastcall CBulletTraces::AddTrace(CVector *pStart, CVector *pEnd, Int32 WeaponType, CEntity *pFiredByEntity)
{
  float *PlayerVehicle; // r0
  RwReal v8; // s18
  RwReal y; // s16
  RwReal v10; // s20
  float v11; // s28
  float v12; // s30
  float v13; // s18
  float v14; // s20
  float v15; // s22
  float v16; // s0
  CVector v17; // [sp+4h] [bp-74h] BYREF
  CVector v18; // [sp+10h] [bp-68h] BYREF
  CVector v19; // [sp+1Ch] [bp-5Ch] BYREF

  if ( FindPlayerPed(-1) == pFiredByEntity || FindPlayerVehicle(-1, 0) && FindPlayerVehicle(-1, 0) == pFiredByEntity )
  {
    switch ( TheCamera.Cams[TheCamera.ActiveCam].Mode )
    {
      case 7:
      case 8:
      case 0x22:
      case 0x27:
      case 0x28:
      case 0x2A:
      case 0x2D:
      case 0x2E:
      case 0x33:
      case 0x34:
        if ( FindPlayerVehicle(-1, 0) )
          PlayerVehicle = (float *)FindPlayerVehicle(-1, 0);
        else
          PlayerVehicle = (float *)FindPlayerPed(-1);
        if ( sqrtf(
               (float)((float)(PlayerVehicle[19] * PlayerVehicle[19]) + (float)(PlayerVehicle[18] * PlayerVehicle[18]))
             + (float)(PlayerVehicle[20] * PlayerVehicle[20])) >= 0.05 )
          goto LABEL_9;
        break;
      default:
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    v8 = pEnd->x - pStart->x;
    v10 = pEnd->z - pStart->z;
    v19.y = pEnd->y - pStart->y;
    y = v19.y;
    v19.x = v8;
    v19.z = v10;
    CVector::Normalise(&v19);
    v11 = sqrtf((float)((float)(v8 * v8) + (float)(y * y)) + (float)(v10 * v10));
    v12 = (float)(v11 * (float)((float)rand() * 4.6566e-10)) + 0.0;
    v13 = pStart->x + (float)(v19.x * v12);
    v14 = (float)(v19.y * v12) + pStart->y;
    v15 = (float)(v19.z * v12) + pStart->z;
    v18.x = v13;
    v18.y = v14;
    v18.z = v15;
    v16 = v11 - v12;
    if ( (float)((float)((float)((float)rand() * 4.6566e-10) * 3.0) + 2.0) < (float)(v11 - v12) )
      v16 = (float)((float)((float)rand() * 4.6566e-10) * 3.0) + 2.0;
    v17.x = (float)(v16 * v19.x) + v13;
    v17.y = (float)(v16 * v19.y) + v14;
    v17.z = (float)(v16 * v19.z) + v15;
    CBulletTraces::AddTrace(&v18, &v17, 0.01, 0x12Cu, 0x46u);
  }
}

//----- (005C1DF8) --------------------------------------------------------
void __fastcall CBulletTraces::AddTrace(CVector *pStart, CVector *pEnd, float SizeArg, UInt32 LifeTimeArg, UInt8 a5)
{
  int v5; // r10
  float v6; // s0
  UInt32 v7; // r10
  CVector *v8; // r5
  CVector *v9; // r6
  UInt8 v10; // r12
  __int16 v11; // r4
  bool *p_bIsUsed; // lr
  __int64 v13; // d16
  CBulletTrace *v14; // r0
  __int64 v15; // d16
  uint32 v16; // r1
  CSimpleTransform *p_tx; // r2
  float y; // s2
  float v19; // s6
  float z; // s12
  float v21; // s0
  float v22; // s2
  float v23; // s10
  float v24; // s4
  float v25; // s8
  float v26; // s12
  float v27; // s16
  float v28; // s1
  float v29; // s6
  float v30; // s10
  float v31; // s6
  float v32; // s8
  float v33; // s12
  float v34; // s14
  float v35; // s0
  float v36; // s2
  float v37; // s0
  float v38; // s4
  float v39; // s2
  float v40; // s0
  float v41; // s0
  float v42; // s0
  float v43; // s0
  float v44; // r2
  tAudioEvent v45; // r1

  v5 = CBulletTraces::aTraces[7].bIsUsed
     + (unsigned __int8)(CBulletTraces::aTraces[0].bIsUsed
                       + CBulletTraces::aTraces[1].bIsUsed
                       + CBulletTraces::aTraces[2].bIsUsed
                       + CBulletTraces::aTraces[3].bIsUsed
                       + CBulletTraces::aTraces[4].bIsUsed
                       + CBulletTraces::aTraces[5].bIsUsed
                       + CBulletTraces::aTraces[6].bIsUsed)
     + CBulletTraces::aTraces[8].bIsUsed
     + CBulletTraces::aTraces[9].bIsUsed
     + CBulletTraces::aTraces[10].bIsUsed
     + CBulletTraces::aTraces[11].bIsUsed
     + CBulletTraces::aTraces[12].bIsUsed
     + CBulletTraces::aTraces[13].bIsUsed
     + CBulletTraces::aTraces[14].bIsUsed
     + CBulletTraces::aTraces[15].bIsUsed;
  if ( v5 >= 10 )
  {
    v6 = 0.25;
    goto LABEL_5;
  }
  if ( v5 >= 5 )
  {
    v6 = 0.5;
LABEL_5:
    v7 = (unsigned int)(float)((float)LifeTimeArg * v6);
    if ( CBulletTraces::aTraces[0].bIsUsed )
      goto LABEL_6;
LABEL_23:
    v10 = a5;
    v11 = 0;
    p_bIsUsed = &CBulletTraces::aTraces[0].bIsUsed;
LABEL_32:
    v8 = pStart;
    v9 = pEnd;
    goto LABEL_33;
  }
  v7 = LifeTimeArg;
  if ( !CBulletTraces::aTraces[0].bIsUsed )
    goto LABEL_23;
LABEL_6:
  if ( !CBulletTraces::aTraces[1].bIsUsed )
  {
    v10 = a5;
    v11 = 1;
    p_bIsUsed = &CBulletTraces::aTraces[1].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[2].bIsUsed )
  {
    v10 = a5;
    v11 = 2;
    p_bIsUsed = &CBulletTraces::aTraces[2].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[3].bIsUsed )
  {
    v10 = a5;
    v11 = 3;
    p_bIsUsed = &CBulletTraces::aTraces[3].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[4].bIsUsed )
  {
    v10 = a5;
    v11 = 4;
    p_bIsUsed = &CBulletTraces::aTraces[4].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[5].bIsUsed )
  {
    v10 = a5;
    v11 = 5;
    p_bIsUsed = &CBulletTraces::aTraces[5].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[6].bIsUsed )
  {
    v10 = a5;
    v11 = 6;
    p_bIsUsed = &CBulletTraces::aTraces[6].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[7].bIsUsed )
  {
    v10 = a5;
    v11 = 7;
    p_bIsUsed = &CBulletTraces::aTraces[7].bIsUsed;
    goto LABEL_32;
  }
  if ( !CBulletTraces::aTraces[8].bIsUsed )
  {
    v10 = a5;
    v11 = 8;
    p_bIsUsed = &CBulletTraces::aTraces[8].bIsUsed;
    goto LABEL_32;
  }
  v8 = pStart;
  v9 = pEnd;
  if ( CBulletTraces::aTraces[9].bIsUsed )
  {
    if ( CBulletTraces::aTraces[10].bIsUsed )
    {
      if ( CBulletTraces::aTraces[11].bIsUsed )
      {
        if ( CBulletTraces::aTraces[12].bIsUsed )
        {
          if ( CBulletTraces::aTraces[13].bIsUsed )
          {
            if ( CBulletTraces::aTraces[14].bIsUsed )
            {
              if ( CBulletTraces::aTraces[15].bIsUsed )
                goto LABEL_34;
              v10 = a5;
              v11 = 15;
              p_bIsUsed = &CBulletTraces::aTraces[15].bIsUsed;
            }
            else
            {
              v10 = a5;
              v11 = 14;
              p_bIsUsed = &CBulletTraces::aTraces[14].bIsUsed;
            }
          }
          else
          {
            v10 = a5;
            v11 = 13;
            p_bIsUsed = &CBulletTraces::aTraces[13].bIsUsed;
          }
        }
        else
        {
          v10 = a5;
          v11 = 12;
          p_bIsUsed = &CBulletTraces::aTraces[12].bIsUsed;
        }
      }
      else
      {
        v10 = a5;
        v11 = 11;
        p_bIsUsed = &CBulletTraces::aTraces[11].bIsUsed;
      }
    }
    else
    {
      v10 = a5;
      v11 = 10;
      p_bIsUsed = &CBulletTraces::aTraces[10].bIsUsed;
    }
  }
  else
  {
    v10 = a5;
    v11 = 9;
    p_bIsUsed = &CBulletTraces::aTraces[9].bIsUsed;
  }
LABEL_33:
  v13 = *(_QWORD *)&v8->x;
  v14 = &CBulletTraces::aTraces[v11];
  v14->Start.z = v8->z;
  *(_QWORD *)&v14->Start.x = v13;
  v15 = *(_QWORD *)&v9->x;
  v16 = CTimer::m_snTimeInMilliseconds;
  v14->End.z = v9->z;
  *(_QWORD *)&v14->End.x = v15;
  *p_bIsUsed = 1;
  v14->Opaqueness = v10;
  v14->Size = SizeArg;
  v14->TimeCreated = v16;
  v14->LifeTime = v7;
LABEL_34:
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  v19 = v8->y - y;
  z = p_tx->m_translate.z;
  v21 = v9->y - y;
  v22 = v9->x - p_tx->m_translate.x;
  v23 = v8->x - p_tx->m_translate.x;
  v24 = v9->z - z;
  v25 = v8->z - z;
  v26 = (float)((float)(TheCamera.m_cameraMatrix.xy * v22) + (float)(TheCamera.m_cameraMatrix.yy * v21))
      + (float)(TheCamera.m_cameraMatrix.zy * v24);
  v27 = (float)((float)(v23 * TheCamera.m_cameraMatrix.xy) + (float)(v19 * TheCamera.m_cameraMatrix.yy))
      + (float)(v25 * TheCamera.m_cameraMatrix.zy);
  if ( (float)(v27 * v26) < 0.0 )
  {
    v28 = v19 * TheCamera.m_cameraMatrix.yz;
    v29 = (float)(v23 * TheCamera.m_cameraMatrix.xx) + (float)(v19 * TheCamera.m_cameraMatrix.yx);
    v30 = (float)((float)(v23 * TheCamera.m_cameraMatrix.xz) + v28) + (float)(v25 * TheCamera.m_cameraMatrix.zz);
    v31 = v29 + (float)(v25 * TheCamera.m_cameraMatrix.zx);
    v32 = fabsf(v26);
    v33 = fabsf(v27);
    v34 = (float)(TheCamera.m_cameraMatrix.xz * v22) + (float)(TheCamera.m_cameraMatrix.yz * v21);
    v35 = (float)(TheCamera.m_cameraMatrix.xx * v22) + (float)(TheCamera.m_cameraMatrix.yx * v21);
    v36 = v33 / (float)(v33 + v32);
    v37 = (float)(v35 + (float)(TheCamera.m_cameraMatrix.zx * v24)) - v31;
    v38 = (float)((float)(v34 + (float)(TheCamera.m_cameraMatrix.zz * v24)) - v30) * v36;
    v39 = v31 + (float)(v37 * v36);
    v40 = sqrtf((float)(v39 * v39) + (float)((float)(v30 + v38) * (float)(v30 + v38)));
    if ( v40 < 2.0 )
    {
      v41 = (float)(v40 * -0.5) + 1.0;
      if ( v39 >= 0.0 )
      {
        if ( v41 == 0.0 )
          v43 = -100.0;
        else
          v43 = log10f(v41) * 20.0;
        v44 = v43;
        if ( v27 <= 0.0 )
          v45 = 27;
        else
          v45 = 28;
      }
      else
      {
        if ( v41 == 0.0 )
          v42 = -100.0;
        else
          v42 = log10f(v41) * 20.0;
        v44 = v42;
        if ( v27 <= 0.0 )
          v45 = 29;
        else
          v45 = 30;
      }
      sub_18FDC4(&AudioEngine, v45, v44, 1.0);
    }
  }
}

//----- (005C22FC) --------------------------------------------------------
void __fastcall CBulletTrace::Update(CBulletTrace *this)
{
  if ( CTimer::m_snTimeInMilliseconds - this->TimeCreated >= this->LifeTime )
    this->bIsUsed = 0;
}

//----- (005C2318) --------------------------------------------------------
void __fastcall CRegisteredMotionBlurStreak::Update(CRegisteredMotionBlurStreak *this)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d18
  RwReal z; // r2
  _BOOL4 v5; // r3
  RwReal v6; // r1
  __int64 v7; // d16
  _BOOL4 v8; // r2

  v1 = *(_QWORD *)&this->FirstPoints[0].x;
  v2 = *(_QWORD *)&this->FirstPoints[1].x;
  v3 = *(_QWORD *)&this->SecondPoints[1].x;
  z = this->SecondPoints[1].z;
  v5 = this->bThisOneUsed[1];
  v6 = this->FirstPoints[0].z;
  this->FirstPoints[2].z = this->FirstPoints[1].z;
  this->SecondPoints[2].z = z;
  this->bThisOneUsed[2] = v5;
  this->FirstPoints[1].z = v6;
  *(_QWORD *)&this->FirstPoints[2].x = v2;
  *(_QWORD *)&this->SecondPoints[2].x = v3;
  *(_QWORD *)&this->FirstPoints[1].x = v1;
  v7 = *(_QWORD *)&this->SecondPoints[0].x;
  this->SecondPoints[1].z = this->SecondPoints[0].z;
  *(_QWORD *)&this->SecondPoints[1].x = v7;
  v8 = this->bThisOneUsed[0];
  this->bThisOneUsed[1] = v8;
  this->bThisOneUsed[0] = 0;
  if ( !((v8 || v5) << 24) )
    this->ID = 0;
}

//----- (005C236C) --------------------------------------------------------
void __fastcall CRegisteredMotionBlurStreak::Render(CRegisteredMotionBlurStreak *this)
{
  int v2; // r6
  unsigned int v3; // r5
  int v4; // r11
  char *v5; // r0
  bool v6; // zf
  int A; // r0
  int v8; // r1
  int v9; // s0
  RwReal y; // r2
  RwReal z; // r3
  RwReal v12; // r2
  RwReal v13; // r3
  RwReal v14; // r2
  RwReal v15; // r3
  RwReal v16; // r0

  v2 = 0;
  v3 = 255;
  v4 = 0;
  do
  {
    v5 = (char *)this + v4++;
    v6 = v5[80] == 0;
    if ( v5[80] )
      v6 = v5[81] == 0;
    if ( !v6 )
    {
      A = this->A;
      v8 = (int)(float)((float)(int)(v3 / 3 * A) / 255.0);
      StreakVertices[0].color = (RwRGBA_0)(this->R | (this->G << 8) | (this->B << 16) | (v8 << 24));
      StreakVertices[1].color = (RwRGBA_0)(this->R | (v8 << 24) | (this->G << 8) | (this->B << 16));
      v9 = (int)(float)((float)(int)(A * ((v3 - 85) / 3)) / 255.0);
      StreakVertices[2].color = (RwRGBA_0)(this->R | (v9 << 24) | (this->G << 8) | (this->B << 16));
      StreakVertices[3].color = (RwRGBA_0)(this->R | (v9 << 24) | (this->G << 8) | (this->B << 16));
      y = this->FirstPoints[v2].y;
      z = this->FirstPoints[v2].z;
      StreakVertices[0].position.x = this->FirstPoints[v2].x;
      StreakVertices[0].position.y = y;
      StreakVertices[0].position.z = z;
      v12 = this->SecondPoints[v2].y;
      v13 = this->SecondPoints[v2].z;
      StreakVertices[1].position.x = this->SecondPoints[v2].x;
      StreakVertices[1].position.y = v12;
      StreakVertices[1].position.z = v13;
      v14 = this->FirstPoints[v2 + 1].y;
      v15 = this->FirstPoints[v2 + 1].z;
      StreakVertices[2].position.x = this->FirstPoints[v2 + 1].x;
      StreakVertices[2].position.y = v14;
      StreakVertices[2].position.z = v15;
      v16 = this->SecondPoints[v2 + 1].z;
      *(_QWORD *)&StreakVertices[3].position.x = *(_QWORD *)&this->SecondPoints[v2 + 1].x;
      StreakVertices[3].position.z = v16;
      LittleTest();
      if ( RwIm3DTransform(StreakVertices, 4u, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, StreakIndexList, 12);
        RwIm3DEnd();
      }
    }
    ++v2;
    v3 -= 85;
  }
  while ( v2 != 2 );
}

//----- (005C24C4) --------------------------------------------------------
void CBrightLights::Render()
{
  unsigned int v0; // r11
  unsigned int v1; // r4
  int v2; // r5
  Int32 v3; // r1
  Int32 v4; // r0
  bool v5; // r1
  float v6; // s0
  CBrightLight *v7; // r1
  unsigned int Type; // r2
  float v9; // s0
  int v10; // r3
  float DistToCam; // s0
  unsigned int v12; // r3
  float v13; // s19
  int v14; // r1
  int v15; // r10
  int v16; // r4
  Int32 v17; // r11
  CBrightLight *v18; // r0
  float v19; // s21
  float v20; // s23
  float v21; // s25
  float v22; // s27
  float v23; // s29
  float v24; // s31
  float v25; // s20
  float v26; // s26
  int v27; // r9
  RwIm3DVertex *v28; // r8
  float v29; // r5
  float v30; // s0
  char *v31; // r0
  float v32; // s0
  int v33; // r3
  int v34; // r6
  Int32 v35; // r0
  RwImVertexIndex *v36; // r1
  RwImVertexIndex v37; // r1
  int v38; // r2
  CBrightLight *v39; // r0
  float x; // s0
  float y; // s4
  int v42; // r1
  float z; // s2
  float v44; // s8
  float v45; // s12
  float v46; // s6
  float v47; // s10
  float v48; // s14
  float v49; // s1
  uint32x4_t v50; // q9
  unsigned int v51; // r1
  RwIm3DVertex *v52; // r0
  float v53; // s9
  float v54; // s3
  float v55; // s11
  RwReal v56; // s5
  RwReal v57; // s7
  RwReal v58; // s3
  float v59; // s9
  float v60; // s3
  RwReal v61; // s5
  RwReal v62; // s7
  RwReal v63; // s3
  float v64; // s9
  float v65; // s3
  RwReal v66; // s5
  RwReal v67; // s7
  RwReal v68; // s3
  float v69; // s9
  float v70; // s3
  RwReal v71; // s5
  RwReal v72; // s7
  RwReal v73; // s3
  float v74; // s9
  float v75; // s3
  int32x4_t v76; // q8
  float v77; // s3
  float v78; // s5
  int16x4_t *v79; // r2
  unsigned int v80; // [sp+70h] [bp-78h]
  unsigned int v81; // [sp+74h] [bp-74h]
  int v82; // [sp+78h] [bp-70h]
  void *v83; // [sp+7Ch] [bp-6Ch]

  if ( !CBrightLights::NumBrightLights )
    return;
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  v1 = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  TempBufferIndicesStored = 0;
  TempBufferVerticesStored = 0;
  if ( CBrightLights::NumBrightLights < 1 )
    goto LABEL_35;
  v2 = 0;
  v83 = &TempVertexBuffer_ptr;
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    v5 = v3 <= 2008;
    if ( v4 && (v4 >= 4057 || !v5) )
    {
      LittleTest();
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
      TempBufferIndicesStored = 0;
      TempBufferVerticesStored = 0;
    }
    v6 = (float)(unsigned __int8)rand();
    v7 = &CBrightLights::aBrightLights[v2];
    Type = v7->Type;
    if ( Type <= 0xF )
    {
      v9 = v6 * 0.2;
      v10 = 1 << Type;
      if ( ((1 << Type) & 0x2002) != 0 )
      {
        v0 = 255;
        v1 = (unsigned int)v9;
        v83 = (void *)v9;
      }
      else if ( (v10 & 0x4004) != 0 )
      {
        v0 = 128;
        LOBYTE(v83) = -1;
        v1 = (unsigned int)v9;
      }
      else if ( (v10 & 0x8008) != 0 )
      {
        v1 = (unsigned int)v9;
        LOBYTE(v83) = -1;
        v0 = (unsigned int)v9;
      }
    }
    DistToCam = CBrightLights::aBrightLights[v2].DistToCam;
    if ( DistToCam >= 45.0 )
      v12 = (unsigned int)(float)((float)((float)((float)(DistToCam + -45.0) * -0.066667) + 1.0) * 255.0);
    else
      v12 = 255;
    if ( Type - 1 < 3 )
    {
      v82 = v2;
      v39 = &CBrightLights::aBrightLights[v2];
      x = v7->Coors.x;
      v81 = v1;
      v80 = v0;
      y = v39->Coors.y;
      v42 = ((unsigned __int8)v0 << 8) | ((unsigned __int8)v1 << 16) | (unsigned __int8)v83;
      z = v39->Coors.z;
      v44 = v39->Up.x;
      v45 = v39->Up.y;
      v46 = v39->Side.z;
      v47 = v39->Side.x;
      v48 = v39->Side.y;
      v49 = v39->Up.z;
      v17 = TempBufferVerticesStored;
      v50 = vdupq_n_s32(TempBufferVerticesStored);
      v51 = v42 | ((unsigned int)(float)((float)v12 * 0.5) << 24);
      v52 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
      v53 = TrafficLightsSide[0];
      v54 = TrafficLightsUp[0];
      v55 = TrafficLightsSide[0] * v48;
      v52->color = (RwRGBA_0)v51;
      v52[1].color = (RwRGBA_0)v51;
      v56 = (float)(y + (float)(v54 * v45)) + v55;
      v57 = (float)(x + (float)(v54 * v44)) + (float)(v53 * v47);
      v58 = (float)(z + (float)(v54 * v49)) + (float)(v53 * v46);
      v59 = TrafficLightsSide[1];
      v52->position.x = v57;
      v52->position.y = v56;
      v52->position.z = v58;
      v60 = TrafficLightsUp[1];
      v52[2].color = (RwRGBA_0)v51;
      v61 = (float)(y + (float)(v60 * v45)) + (float)(v59 * v48);
      v62 = (float)(x + (float)(v60 * v44)) + (float)(v59 * v47);
      v63 = (float)(z + (float)(v60 * v49)) + (float)(v59 * v46);
      v64 = TrafficLightsSide[2];
      v52[1].position.x = v62;
      v52[1].position.y = v61;
      v52[1].position.z = v63;
      v65 = TrafficLightsUp[2];
      v52[3].color = (RwRGBA_0)v51;
      v66 = (float)(y + (float)(v65 * v45)) + (float)(v64 * v48);
      v67 = (float)(x + (float)(v65 * v44)) + (float)(v64 * v47);
      v68 = (float)(z + (float)(v65 * v49)) + (float)(v64 * v46);
      v69 = TrafficLightsSide[3];
      v52[2].position.x = v67;
      v52[2].position.y = v66;
      v52[2].position.z = v68;
      v70 = TrafficLightsUp[3];
      v52[4].color = (RwRGBA_0)v51;
      v71 = (float)(y + (float)(v70 * v45)) + (float)(v69 * v48);
      v72 = (float)(x + (float)(v70 * v44)) + (float)(v69 * v47);
      v73 = (float)(z + (float)(v70 * v49)) + (float)(v69 * v46);
      v74 = TrafficLightsSide[4];
      v52[3].position.x = v72;
      v52[3].position.y = v71;
      v52[3].position.z = v73;
      v75 = TrafficLightsUp[4];
      v52[5].color = (RwRGBA_0)v51;
      v76 = vaddw_u16(v50, *(uint16x4_t *)TrafficLightIndices);
      LOWORD(v51) = TrafficLightIndices[8] + v17;
      *(int16x4_t *)&v50.n128_i8[8] = vmovn_s32(vaddw_u16(v50, *(uint16x4_t *)&TrafficLightIndices[4]));
      v52[4].position.x = (float)(x + (float)(v75 * v44)) + (float)(v74 * v47);
      v52[4].position.y = (float)(y + (float)(v75 * v45)) + (float)(v74 * v48);
      v52[4].position.z = (float)(z + (float)(v75 * v49)) + (float)(v74 * v46);
      v77 = TrafficLightsUp[5];
      v78 = TrafficLightsSide[5];
      v52[5].position.x = (float)(x + (float)(TrafficLightsUp[5] * v44)) + (float)(TrafficLightsSide[5] * v47);
      v52[5].position.y = (float)(y + (float)(v77 * v45)) + (float)(v78 * v48);
      v52[5].position.z = (float)(z + (float)(v77 * v49)) + (float)(v78 * v46);
      v35 = TempBufferIndicesStored;
      v79 = (int16x4_t *)&TempBufferRenderIndexList[TempBufferIndicesStored];
      v79->n64_u64[0] = vmovn_s32(v76).n64_u64[0];
      v79[1].n64_u64[0] = *(unsigned __int64 *)&v50.n128_i8[8];
      v79[2].n64_u16[0] = v51;
      v33 = 6;
      v79[2].n64_u16[1] = TrafficLightIndices[9] + v17;
      v79[2].n64_u16[2] = TrafficLightIndices[10] + v17;
      v38 = v35 + 11;
      v34 = 12;
      v37 = TrafficLightIndices[11] + v17;
LABEL_27:
      TempBufferRenderIndexList[v38] = v37;
      v4 = v35 + v34;
      v2 = v82;
      TempBufferVerticesStored = v17 + v33;
      TempBufferIndicesStored = v4;
      v0 = v80;
      v1 = v81;
      goto LABEL_28;
    }
    if ( Type - 13 < 3 )
    {
      v13 = v7->Coors.x;
      v14 = ((unsigned __int8)v0 << 8) | ((unsigned __int8)v1 << 16);
      v80 = v0;
      v15 = 0;
      v81 = v1;
      v16 = 0;
      v17 = TempBufferVerticesStored;
      v82 = v2;
      v18 = &CBrightLights::aBrightLights[v2];
      v19 = v18->Coors.y;
      v20 = v18->Coors.z;
      v21 = v18->Up.x;
      v22 = v18->Up.y;
      v23 = v18->Up.z;
      v24 = v18->Side.x;
      v25 = v18->Side.y;
      v26 = v18->Side.z;
      v27 = (unsigned __int8)v83 | v14 | (v12 << 24);
      v28 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
      do
      {
        v29 = sinf((float)v15 * 0.7854);
        v30 = cosf((float)v15 * 0.7854);
        v31 = (char *)&v28[v16++];
        v32 = v30 * 0.1;
        ++v15;
        *((_DWORD *)v31 + 6) = v27;
        *(float *)v31 = (float)(v13 + (float)(v32 * v21)) + (float)((float)(v29 * 0.1) * v24);
        *((float *)v31 + 1) = (float)(v19 + (float)(v32 * v22)) + (float)((float)(v29 * 0.1) * v25);
        *((float *)v31 + 2) = (float)(v20 + (float)(v32 * v23)) + (float)((float)(v29 * 0.1) * v26);
      }
      while ( v16 != 8 );
      v33 = 8;
      v34 = 18;
      v35 = TempBufferIndicesStored;
      TempBufferRenderIndexList[TempBufferIndicesStored] = v17;
      v36 = &TempBufferRenderIndexList[v35];
      v36[1] = v17 + 1;
      v36[2] = v17 + 2;
      v36[3] = v17;
      v36[4] = v17 + 2;
      v36[5] = v17 + 3;
      v36[6] = v17;
      v36[7] = v17 + 3;
      v36[8] = v17 + 4;
      v36[9] = v17;
      v36[10] = v17 + 4;
      v36[11] = v17 + 5;
      v36[12] = v17;
      v36[13] = v17 + 5;
      v36[14] = v17 + 6;
      v36[15] = v17;
      v36[16] = v17 + 6;
      v37 = v17 + 7;
      v38 = v35 + 17;
      goto LABEL_27;
    }
    v4 = TempBufferIndicesStored;
LABEL_28:
    if ( ++v2 >= CBrightLights::NumBrightLights )
      break;
    v3 = TempBufferVerticesStored;
  }
  if ( v4 )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
  }
LABEL_35:
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  CBrightLights::NumBrightLights = 0;
}
// 5C277C: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C2C78) --------------------------------------------------------
void CBrightLights::RenderOutGeometryBuffer()
{
  if ( TempBufferIndicesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
  }
}

//----- (005C2CF4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBrightLights::RegisterOne(
        CVector Coors,
        CVector Up,
        CVector Side,
        CVector Front,
        int Type,
        UInt8 Red,
        UInt8 Green,
        UInt8 Blue)
{
  Int32 v8; // lr
  CSimpleTransform *p_tx; // r6
  float v10; // s0

  if ( Type )
  {
    v8 = CBrightLights::NumBrightLights;
    if ( CBrightLights::NumBrightLights <= 31 )
    {
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      v10 = sqrtf(
              (float)((float)((float)(Coors.x - p_tx->m_translate.x) * (float)(Coors.x - p_tx->m_translate.x))
                    + (float)((float)(Coors.y - p_tx->m_translate.y) * (float)(Coors.y - p_tx->m_translate.y)))
            + (float)((float)(Coors.z - p_tx->m_translate.z) * (float)(Coors.z - p_tx->m_translate.z)))
          / TheCamera.LODDistMultiplier;
      CBrightLights::aBrightLights[CBrightLights::NumBrightLights].DistToCam = v10;
      if ( v10 <= 60.0 )
      {
        CBrightLights::aBrightLights[v8].Coors.x = Coors.x;
        LODWORD(Coors.x) = &CBrightLights::aBrightLights[v8];
        *(RwReal *)(LODWORD(Coors.x) + 4) = Coors.y;
        *(RwReal *)(LODWORD(Coors.x) + 8) = Coors.z;
        *(CVector *)(LODWORD(Coors.x) + 12) = Up;
        *(CVector *)(LODWORD(Coors.x) + 24) = Side;
        *(CVector *)(LODWORD(Coors.x) + 36) = Front;
        *(_BYTE *)(LODWORD(Coors.x) + 53) = Red;
        *(_BYTE *)(LODWORD(Coors.x) + 52) = Type;
        *(_BYTE *)(LODWORD(Coors.x) + 54) = Green;
        *(_BYTE *)(LODWORD(Coors.x) + 55) = Blue;
        CBrightLights::NumBrightLights = v8 + 1;
      }
    }
  }
}
// 5C2CF4: fragmented variable at 0:r3.4,4:^28.8 may be wrong
// 5C2CF4: variables would overlap: 0:r3.4,4:^28.8 and ^28.4
// 5C2CF4: variables would overlap: 0:r3.4,4:^28.8 and ^2C.4

//----- (005C2E00) --------------------------------------------------------
void CShinyTexts::RenderOutGeometryBuffer()
{
  if ( TempBufferIndicesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
  }
}

//----- (005C2E7C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CShinyTexts::RegisterOne(
        CVector Coors1,
        CVector Coors2,
        CVector Coors3,
        CVector Coors4,
        float Tex1U,
        float Tex1V,
        float Tex2U,
        float Tex2V,
        float Tex3U,
        float Tex3V,
        float Tex4U,
        float Tex4V,
        UInt8 Type,
        unsigned int Red,
        unsigned int Green,
        unsigned int Blue,
        float Range)
{
  Int32 v17; // r12
  CSimpleTransform *p_tx; // r4
  float v19; // s0
  CShinyText *v20; // r6
  UInt8 *p_Red; // r6
  float v22; // s0

  v17 = CShinyTexts::NumShinyTexts;
  if ( CShinyTexts::NumShinyTexts <= 31 )
  {
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v19 = sqrtf(
            (float)((float)((float)(Coors1.x - p_tx->m_translate.x) * (float)(Coors1.x - p_tx->m_translate.x))
                  + (float)((float)(Coors1.y - p_tx->m_translate.y) * (float)(Coors1.y - p_tx->m_translate.y)))
          + (float)((float)(Coors1.z - p_tx->m_translate.z) * (float)(Coors1.z - p_tx->m_translate.z)));
    CShinyTexts::aShinyTexts[CShinyTexts::NumShinyTexts].DistToCam = v19;
    if ( v19 <= Range )
    {
      v20 = &CShinyTexts::aShinyTexts[v17];
      v20->Coors1 = Coors1;
      v20->Coors2 = Coors2;
      v20->Coors3 = Coors3;
      v20->Coors4 = Coors4;
      v20->Red = Red;
      p_Red = &v20->Red;
      *(p_Red - 1) = Type;
      *(float *)(p_Red - 33) = Tex1V;
      *(float *)(p_Red - 37) = Tex1U;
      *(float *)(p_Red - 29) = Tex2U;
      *(float *)(p_Red - 25) = Tex2V;
      *(float *)(p_Red - 21) = Tex3U;
      *(float *)(p_Red - 17) = Tex3V;
      *(float *)(p_Red - 13) = Tex4U;
      *(float *)(p_Red - 9) = Tex4V;
      p_Red[2] = Blue;
      p_Red[1] = Green;
      if ( v19 > (float)(Range * 0.5) )
      {
        v22 = 1.0 - (float)((float)(v19 - (float)(Range * 0.5)) / (float)(Range * 0.5));
        *p_Red = (unsigned int)(float)(v22 * (float)Red);
        p_Red[1] = (unsigned int)(float)(v22 * (float)Green);
        p_Red[2] = (unsigned int)(float)(v22 * (float)Blue);
      }
      CShinyTexts::NumShinyTexts = v17 + 1;
    }
  }
}
// 5C2E7C: fragmented variable at 0:r3.4,4:^28.8 may be wrong
// 5C2E7C: variables would overlap: 0:r3.4,4:^28.8 and ^28.8
// 5C2E7C: using guessed type unsigned int Green_0;

//----- (005C3048) --------------------------------------------------------
RpAtomic_0 *__fastcall MarkerAtomicCB(RpAtomic_0 *pAtomic, void *pData)
{
  *(_DWORD *)pData = pAtomic;
  return pAtomic;
}

//----- (005C304C) --------------------------------------------------------
bool __fastcall C3dMarker::AddMarker(
        C3dMarker *this,
        u_native nIdentifier,
        int nType,
        float fSize,
        uint8 setr,
        uint8 setg,
        uint8 setb,
        uint8 seta,
        uint16 nPeriod,
        float fPulseFrac,
        int16 nRotRate)
{
  float v14; // s18
  RpClump_0 *v15; // r0
  RpAtomic_0 *v16; // r6
  RwFrame_0 *v17; // r0
  RpGeometry_0 *geometry; // r11
  RwObject_0 *m_pRwObject; // r0
  RpMaterial_0 *v20; // r1
  uint32 v21; // r1
  RpAtomic_0 *pData; // [sp+4h] [bp-34h] BYREF

  this->m_nIdentifier = nIdentifier;
  CMatrix::SetUnity(&this->m_mat);
  v14 = fSize;
  pData = 0;
  if ( nType == 3 )
  {
    v15 = C3dMarkers::m_pRpClumpArray[0];
  }
  else if ( nType == 2 )
  {
    v15 = C3dMarkers::m_pRpClumpArray[1];
  }
  else
  {
    v15 = C3dMarkers::m_pRpClumpArray[nType];
  }
  RpClumpForAllAtomics(v15, MarkerAtomicCB, &pData);
  v16 = RpAtomicClone(pData);
  v17 = RwFrameCreate();
  RpAtomicSetFrame(v16, v17);
  CVisibilityPlugins::SetAtomicRenderCallback(v16, 0);
  geometry = v16->geometry;
  geometry->flags |= 0x40u;
  this->m_pRwObject = &v16->object.object;
  CMatrix::Attach(&this->m_mat, (RwMatrix *)((char *)v16->object.object.parent + 16), 0);
  m_pRwObject = this->m_pRwObject;
  v20 = *geometry->matList.materials;
  this->m_nPulsePeriod = nPeriod;
  this->m_nRotateRate = nRotRate;
  this->rwColour._anon_0._anon_0.blue = setb;
  this->rwColour._anon_0._anon_0.alpha = seta;
  this->m_pMaterial = v20;
  this->m_fPulseFraction = fPulseFrac;
  this->m_fStdSize = v14;
  this->m_fSize = v14;
  this->rwColour._anon_0._anon_0.red = setr;
  this->rwColour._anon_0._anon_0.green = setg;
  v21 = CTimer::m_snTimeInMilliseconds;
  this->m_nType = nType;
  this->m_nStartTime = v21;
  this->m_roofHeight = 65535.0;
  this->m_lastPosition.x = 0.0;
  this->m_lastPosition.y = 0.0;
  this->m_lastPosition.z = 0.0;
  this->m_OnScreenTestTime = v21;
  return m_pRwObject != 0;
}

//----- (005C3184) --------------------------------------------------------
void __fastcall C3dMarker::DeleteMarkerObject(C3dMarker *this)
{
  RpAtomic_0 *m_pRwObject; // r0
  RwFrame_0 *parent; // r5

  this->m_nStartTime = 0;
  m_pRwObject = (RpAtomic_0 *)this->m_pRwObject;
  *(_DWORD *)&this->m_nType = 257;
  this->m_nIdentifier = 0;
  parent = (RwFrame_0 *)m_pRwObject->object.object.parent;
  RpAtomicDestroy(m_pRwObject);
  RwFrameDestroy(parent);
  this->m_pRwObject = 0;
}

//----- (005C31B0) --------------------------------------------------------
void __fastcall C3dMarker::Render(C3dMarker *this)
{
  char *v2; // r1
  int m_nType; // r0
  float y; // r3
  float z; // r6
  float m_fSize; // s8
  float v7; // s0
  float v8; // s2
  float v9; // s4
  unsigned int v10; // r0
  float alpha; // s0
  CVector v12; // [sp+0h] [bp-110h] BYREF
  CVector v1; // [sp+Ch] [bp-104h] BYREF
  CVector v14; // [sp+18h] [bp-F8h] BYREF
  CMatrix m2; // [sp+28h] [bp-E8h] BYREF
  CMatrix m1; // [sp+70h] [bp-A0h] BYREF
  CMatrix v17; // [sp+B8h] [bp-58h] BYREF

  if ( this->m_pRwObject )
  {
    if ( this->m_nType == 1 )
      v2 = (char *)&dword_0 + 1;
    else
      v2 = (_BYTE *)(&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATECULLMODE, v2);
    CMatrix::UpdateRW(&this->m_mat);
    m1.m_pRwMat = 0;
    m1.m_owner = 0;
    CMatrix::Attach(&m1, this->m_mat.m_pRwMat, 0);
    m_nType = this->m_nType;
    if ( (unsigned __int16)(m_nType - 3) <= 1u )
    {
      m2.m_pRwMat = 0;
      m2.m_owner = 0;
      CMatrix::SetUnity(&m2);
      if ( this->m_normal.x != 0.0 || this->m_normal.z != 1.0 )
      {
        v1.x = 0.0;
        v1.y = 0.0;
        v1.z = 1.0;
        CrossProduct(&v14, &v1, &this->m_normal);
        v17.zx = v14.z;
        *(_QWORD *)&v17.xx = *(_QWORD *)&v14.x;
        CVector::Normalise((CVector *)&v17);
        CrossProduct(&v12, &this->m_normal, (const CVector *)&v17);
        v14 = v12;
        CVector::Normalise(&v14);
        *(_QWORD *)&m2.xx = *(_QWORD *)&v17.xx;
        *(_QWORD *)&m2.xy = *(_QWORD *)&v14.x;
        y = this->m_normal.y;
        z = this->m_normal.z;
        m2.xz = this->m_normal.x;
        m2.yz = y;
        m2.zx = v17.zx;
        m2.zy = v14.z;
        m2.zz = z;
      }
      operator*(&v17, &m1, &m2);
      CMatrix::operator=(&m1, &v17);
      CMatrix::~CMatrix(&v17);
      CMatrix::~CMatrix(&m2);
      m_nType = this->m_nType;
    }
    m_fSize = this->m_fSize;
    v7 = m_fSize * m1.zy;
    v8 = m_fSize * m1.zx;
    v9 = m_fSize * m1.zz;
    m1.xx = m_fSize * m1.xx;
    m1.yx = m_fSize * m1.yx;
    m1.zx = m_fSize * m1.zx;
    m1.xy = m_fSize * m1.xy;
    m1.yy = m_fSize * m1.yy;
    m1.zy = m_fSize * m1.zy;
    m1.xz = m_fSize * m1.xz;
    m1.yz = m_fSize * m1.yz;
    m1.zz = m_fSize * m1.zz;
    if ( m_nType == 2 )
    {
      m1.zy = v7 * 20.0;
      m1.zx = v8 * 20.0;
      m1.zz = v9 * 20.0;
    }
    CMatrix::UpdateRW(&m1);
    RwFrameUpdateObjects((RwFrame_0 *)this->m_pRwObject->parent);
    v10 = this->m_nType;
    if ( v10 <= 6 && ((1 << v10) & 0x61) != 0 )
    {
      alpha = 255.0;
      this->rwColour._anon_0._anon_0.alpha = -1;
    }
    else
    {
      alpha = (float)this->rwColour._anon_0._anon_0.alpha;
    }
    emu_EnableAlphaModulate(alpha / 255.0);
    this->m_pMaterial->color = this->rwColour;
    SetBrightMarkerColours(this->m_fBrightness);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    if ( this->m_nType == 3 )
      RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
    (*(void (**)(void))&this->m_pRwObject[9].type)();
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    emu_DisableAlphaModulate();
    ReSetAmbientAndDirectionalColours();
    CMatrix::~CMatrix(&m1);
  }
}
// 0: using guessed type int dword_0;

//----- (005C33F0) --------------------------------------------------------
void __fastcall C3dMarker::UpdateZCoordinate(C3dMarker *this, CVector vecTempPlayerPos, float fSize)
{
  float tx; // s0
  float ty; // s2
  float GroundZFor3DCoord; // r0
  int v7; // s2
  bool pBool; // [sp+7h] [bp-9h] BYREF

  tx = this->m_mat.tx;
  if ( (unsigned __int16)this->m_LastMapReadX == (unsigned __int16)(int)tx )
  {
    ty = this->m_mat.ty;
    if ( (unsigned __int16)this->m_LastMapReadY == (unsigned __int16)(int)ty )
      return;
  }
  else
  {
    ty = this->m_mat.ty;
  }
  if ( (float)((float)((float)(vecTempPlayerPos.x - tx) * (float)(vecTempPlayerPos.x - tx))
             + (float)((float)(vecTempPlayerPos.y - ty) * (float)(vecTempPlayerPos.y - ty))) < 10000.0
    && CColStore::HasCollisionLoaded((const CVector *)&this->m_mat.tx, 0) )
  {
    GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(this->m_mat.tx, this->m_mat.ty, this->m_mat.tz + 1.0, &pBool, 0);
    if ( pBool )
      this->m_mat.tz = GroundZFor3DCoord + (float)(fSize * -0.05);
    v7 = (int)this->m_mat.ty;
    this->m_LastMapReadX = (int)this->m_mat.tx;
    this->m_LastMapReadY = v7;
  }
}

//----- (005C34D0) --------------------------------------------------------
bool __fastcall C3dMarker::IsZCoordinateUpToDate(C3dMarker *this)
{
  return (unsigned __int16)this->m_LastMapReadX == (unsigned __int16)(int)this->m_mat.tx
      && (unsigned __int16)this->m_LastMapReadY == (unsigned __int16)(int)this->m_mat.ty;
}

//----- (005C3504) --------------------------------------------------------
void __fastcall C3dMarker::SetZCoordinateIfNotUpToDate(C3dMarker *this, float NewZ)
{
  if ( (unsigned __int16)this->m_LastMapReadX != (unsigned __int16)(int)this->m_mat.tx
    || (unsigned __int16)this->m_LastMapReadY != (unsigned __int16)(int)this->m_mat.ty )
  {
    this->m_mat.tz = NewZ;
  }
}

//----- (005C353C) --------------------------------------------------------
RpClump_0 *__fastcall C3dMarkers::LoadMarker(const unsigned __int8 *name)
{
  CBaseModelInfo *ModelInfo; // r4
  RpAtomic_0 *v2; // r5
  RpClump_0 *v3; // r0
  RwFrame_0 *parent; // r6
  RpClump_0 *v5; // r4
  int32 pIndex[5]; // [sp+4h] [bp-14h] BYREF

  ModelInfo = CModelInfo::GetModelInfo(name, pIndex);
  CStreaming::RequestModel(pIndex[0], 2);
  CStreaming::LoadAllRequestedModels(0);
  v2 = (RpAtomic_0 *)(*((int (__fastcall **)(CBaseModelInfo *))ModelInfo->_vptr$CBaseModelInfo + 11))(ModelInfo);
  CBaseModelInfo::AddRef(ModelInfo);
  v3 = RpClumpCreate();
  parent = (RwFrame_0 *)v2->object.object.parent;
  v5 = v3;
  RwFrameSetIdentity(parent);
  RpClumpAddAtomic(v5, v2);
  v5->object.parent = parent;
  return v5;
}
// 5C353C: using guessed type int32 pIndex[5];

//----- (005C358E) --------------------------------------------------------
RpAtomic_0 *__fastcall RemoveRefsCB(RpAtomic_0 *pAtomic, void *data)
{
  CBaseModelInfo *ModelInfo; // r0

  ModelInfo = CVisibilityPlugins::GetModelInfo(pAtomic);
  CBaseModelInfo::RemoveRef(ModelInfo);
  return pAtomic;
}

//----- (005C35A0) --------------------------------------------------------
void __fastcall RemoveRefsForAtomic(RpClump_0 *pClump)
{
  sub_18E410(pClump, RemoveRefsCB, 0);
}

//----- (005C35B0) --------------------------------------------------------
void __fastcall C3dMarkers::ForceRender(bool8 value)
{
  C3dMarkers::IgnoreRenderLimit = value;
}

//----- (005C35C0) --------------------------------------------------------
void __fastcall C3dMarkers::PlaceMarkerCone(
        u_native nIdentifier,
        CVector *vecPosition,
        float fSize,
        uint8 r,
        uint8 g,
        uint8 b,
        uint8 a,
        uint16 nPeriod,
        float fPulseFrac,
        int16 nRotRate,
        int useCollision)
{
  CSimpleTransform *p_tx; // r4
  float32x2_t v14; // d16
  unsigned __int64 v15; // d1
  uint16 v16; // r1

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v14.n64_u64[0] = vsub_f32(*(float32x2_t *)&vecPosition->y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v15 = vmul_f32(v14, v14).n64_u64[0];
  if ( sqrtf(
         (float)((float)((float)(vecPosition->x - p_tx->m_translate.x) * (float)(vecPosition->x - p_tx->m_translate.x))
               + *(float *)&v15)
       + *((float *)&v15 + 1)) >= 1.6 )
  {
    if ( useCollision )
      v16 = 5;
    else
      v16 = 6;
    C3dMarkers::PlaceMarker(
      nIdentifier,
      v16,
      vecPosition,
      fSize,
      r,
      g,
      b,
      C3dMarkers::m_colDiamond._anon_0._anon_0.alpha,
      nPeriod,
      fPulseFrac,
      0,
      0.0,
      0.0,
      0.0,
      0);
  }
}

//----- (005C3670) --------------------------------------------------------
C3dMarker *__fastcall C3dMarkers::PlaceMarker(
        u_native nIdentifier,
        unsigned int nType,
        CVector *vecPosition,
        float fSize,
        uint8 r,
        uint8 g,
        uint8 b,
        unsigned int a,
        uint16 nPeriod,
        float fPulseFrac,
        int16 nRotRate,
        float normalX,
        float normalY,
        float normalZ,
        int zCheck)
{
  C3dMarker *v19; // r4
  const CVector *PlayerCentreOfWorld; // r0
  __int64 v21; // kr00_8
  float v22; // s24
  float v23; // s22
  uint16 v24; // lr
  int v25; // r0
  bool v26; // zf
  int v27; // r0
  int v28; // r0
  float m_fCameraRange; // s0
  unsigned int m_nType; // r6
  u_native m_nIdentifier; // r0
  bool v32; // zf
  RpAtomic_0 *m_pRwObject; // r0
  RwFrame_0 *parent; // r8
  float v35; // s0
  bool v36; // zf
  float x; // s6
  float v38; // s0
  float v39; // s28
  RwReal v40; // s4
  __int64 v41; // d16
  RwReal v42; // s0
  __int64 v43; // d16
  int z_low; // s0
  float m_roofHeight; // s0
  int *v46; // r1
  float v47; // s28
  float m_fStdSize; // s0
  float v49; // s0
  unsigned int v50; // r6
  float v51; // s2
  float v52; // s2
  float v53; // s0
  float v54; // s0
  unsigned int v55; // r0
  float v56; // s0
  float v57; // s0
  int m_nRotateRate; // r0
  __int64 v60; // kr08_8
  float tz; // r9
  int m_LastMapReadX; // r0
  float v63; // r0
  float y; // r1
  int v65; // r3
  RwReal v66; // r2
  bool v67; // zf
  float v68; // r1
  bool v69; // zf
  float v70; // r0
  RwReal z; // [sp+24h] [bp-ACh]
  CEntity *refEntityPtr; // [sp+30h] [bp-A0h] BYREF
  CColPoint colPoint; // [sp+34h] [bp-9Ch] BYREF
  CVector vecEnd; // [sp+60h] [bp-70h] BYREF
  CVector vecStart; // [sp+6Ch] [bp-64h] BYREF
  CVector v76; // 0:r1.12
  CVector v77; // 0:r1.12

  v19 = 0;
  PlayerCentreOfWorld = FindPlayerCentreOfWorld(0);
  v21 = *(_QWORD *)&PlayerCentreOfWorld->x;
  v22 = sqrtf(
          (float)((float)(vecPosition->x - PlayerCentreOfWorld->x) * (float)(vecPosition->x - PlayerCentreOfWorld->x))
        + (float)((float)(vecPosition->y - PlayerCentreOfWorld->y) * (float)(vecPosition->y - PlayerCentreOfWorld->y)));
  if ( nType == 2 )
    v22 = v22 * 0.25;
  if ( nType <= 6 )
  {
    v23 = fSize;
    z = PlayerCentreOfWorld->z;
    v24 = nPeriod;
    v19 = C3dMarkers::m_aMarkerArray;
    v25 = -1;
    while ( 1 )
    {
      v26 = !v19->m_bIsUsed;
      if ( !v19->m_bIsUsed )
        v26 = v19->m_nIdentifier == nIdentifier;
      if ( v26 )
        break;
      ++v25;
      ++v19;
      if ( v25 >= 31 )
      {
        v19 = C3dMarkers::m_aMarkerArray;
        v27 = -1;
        while ( v19->m_nType != 257 )
        {
          ++v27;
          ++v19;
          if ( v27 >= 31 )
            goto LABEL_14;
        }
        if ( v19 )
          break;
LABEL_14:
        if ( !(0x69u >> nType << 31) )
          return 0;
        v28 = 0;
        v19 = 0;
        do
        {
          m_fCameraRange = C3dMarkers::m_aMarkerArray[v28].m_fCameraRange;
          if ( v22 < m_fCameraRange )
          {
            m_nType = C3dMarkers::m_aMarkerArray[v28].m_nType;
            if ( m_nType <= 6 && ((1 << m_nType) & 0x69) != 0 )
            {
              if ( v19 )
              {
                if ( m_fCameraRange > v19->m_fCameraRange )
                  v19 = &C3dMarkers::m_aMarkerArray[v28];
              }
              else
              {
                v19 = &C3dMarkers::m_aMarkerArray[v28];
              }
            }
          }
          ++v28;
        }
        while ( v28 != 32 );
        if ( !v19 )
          return 0;
        v19->m_nType = 257;
        break;
      }
    }
    m_nIdentifier = v19->m_nIdentifier;
    v19->m_fCameraRange = v22;
    v32 = m_nIdentifier == nIdentifier;
    if ( m_nIdentifier == nIdentifier )
      v32 = v19->m_nType == nType;
    if ( !v32 )
    {
      if ( m_nIdentifier )
      {
        v19->m_nStartTime = 0;
        m_pRwObject = (RpAtomic_0 *)v19->m_pRwObject;
        *(_DWORD *)&v19->m_nType = 257;
        v19->m_nIdentifier = 0;
        parent = (RwFrame_0 *)m_pRwObject->object.object.parent;
        RpAtomicDestroy(m_pRwObject);
        RwFrameDestroy(parent);
        v24 = nPeriod;
        v19->m_pRwObject = 0;
      }
      v19->m_LastMapReadX = 30000;
      if ( (unsigned __int16)(nType - 5) >= 2u )
      {
        v35 = vecPosition->z;
      }
      else
      {
        v35 = vecPosition->z + (float)(sinf((float)(C3dMarkers::m_angleDiamond * 3.1416) / 180.0) * 0.3);
        vecPosition->z = v35;
      }
      LOBYTE(v50) = a;
      CMatrix::SetTranslate(&v19->m_mat, vecPosition->x, vecPosition->y, v35);
      C3dMarker::AddMarker(v19, nIdentifier, nType, fSize, r, g, b, a, v24, fPulseFrac, nRotRate);
      if ( nType == 1 )
      {
        if ( CWaterLevel::GetWaterLevelNoWaves(
               v19->m_mat.tx,
               v19->m_mat.ty,
               v19->m_mat.tz,
               &colPoint.m_vecPosition.x,
               0,
               0)
          && colPoint.m_vecPosition.x >= v19->m_mat.tz )
        {
          v19->m_mat.tz = colPoint.m_vecPosition.x;
        }
        else
        {
          *(_QWORD *)&v76.y = __PAIR64__(LODWORD(z), HIDWORD(v21));
          LODWORD(v76.x) = v21;
          C3dMarker::UpdateZCoordinate(v19, v76, fSize);
        }
        CMatrix::UpdateRW(&v19->m_mat);
      }
      else
      {
        CMatrix::UpdateRW(&v19->m_mat);
        if ( ((1 << nType) & 0x69) != 0 )
        {
          v51 = fSize;
          if ( v22 < 25.0 )
          {
            v52 = fSize * 0.3;
            if ( v22 <= 5.0 )
              v51 = fSize - v52;
            else
              v51 = fSize + (float)((float)(v52 * (float)(25.0 - v22)) / -20.0);
          }
          v19->m_fStdSize = v51;
          if ( nType == 3 )
            goto LABEL_81;
        }
      }
      if ( v22 < (float)(fSize + 12.0) )
      {
        v56 = (float)a;
        if ( v22 <= (float)(fSize + 1.0) )
          v57 = v56 * 0.65;
        else
          v57 = (float)((float)((float)((float)((float)(fSize + 12.0) - v22) * -0.35) / 11.0) + 1.0) * v56;
        v50 = (unsigned int)v57;
      }
      v19->rwColour._anon_0._anon_0.alpha = v50;
LABEL_81:
      v19->m_normal.x = normalX;
      v19->m_normal.y = normalY;
      v19->m_normal.z = normalZ;
      v19->m_bIsUsed = 1;
      return v19;
    }
    v36 = nType == 5;
    if ( nType != 5 )
      v36 = nType == 0;
    if ( v36 )
    {
      x = v19->m_lastPosition.x;
      v38 = v19->m_lastPosition.z;
      v39 = *(float *)&v19->m_pRwObject[5].type;
      if ( (float)((float)((float)(x * x) + (float)(v19->m_lastPosition.y * v19->m_lastPosition.y)) + (float)(v38 * v38)) < 0.0001
        || CTimer::m_snTimeInMilliseconds - v19->m_OnScreenTestTime >= 0x7D0 )
      {
        v19->m_OnScreenTestTime = CTimer::m_snTimeInMilliseconds;
        v40 = vecPosition->x;
        if ( x != vecPosition->x || v38 != vecPosition->z )
        {
          v41 = *(_QWORD *)&vecPosition->x;
          v19->m_lastPosition.z = vecPosition->z;
          *(_QWORD *)&v19->m_lastPosition.x = v41;
          v42 = vecPosition->z + -1.5;
          vecStart.y = vecPosition->y;
          vecStart.x = v40;
          vecStart.z = v42;
          v43 = *(_QWORD *)&vecPosition->x;
          vecEnd.z = vecPosition->z;
          *(_QWORD *)&vecEnd.x = v43;
          z_low = 1199570688;
          if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 0) )
            z_low = LODWORD(colPoint.m_vecPosition.z);
          LODWORD(v19->m_roofHeight) = z_low;
        }
      }
      m_roofHeight = v19->m_roofHeight;
      if ( m_roofHeight < 65535.0 )
      {
        v23 = fSize * 0.5;
        vecPosition->z = m_roofHeight + (float)(v39 * -0.1);
      }
    }
    if ( (unsigned __int16)(nType - 5) <= 1u )
    {
      v46 = dword_5C3DC4;
      if ( v19->m_roofHeight < 65535.0 )
        v46 = &dword_5C3DC4[1];
      v47 = *(float *)v46;
      vecPosition->z = vecPosition->z + (float)(sinf((float)(C3dMarkers::m_angleDiamond * 3.1416) / 180.0) * v47);
    }
    if ( ((1 << nType) & 0x69) == 0 )
      goto LABEL_69;
    m_fStdSize = v23;
    if ( v22 < 25.0 )
    {
      v49 = v23 * 0.3;
      if ( v22 <= 5.0 )
        m_fStdSize = v23 - v49;
      else
        m_fStdSize = v23 + (float)((float)((float)(25.0 - v22) * v49) / -20.0);
    }
    v19->m_fStdSize = m_fStdSize;
    if ( nType != 3 )
    {
LABEL_69:
      if ( v22 >= (float)(v23 + 12.0) )
      {
        LOBYTE(v55) = a;
      }
      else
      {
        v53 = (float)a;
        if ( v22 <= (float)(v23 + 1.0) )
          v54 = v53 * 0.65;
        else
          v54 = (float)((float)((float)((float)((float)(v23 + 12.0) - v22) * -0.35) / 11.0) + 1.0) * v53;
        v55 = (unsigned int)v54;
      }
      m_fStdSize = v19->m_fStdSize;
      v19->rwColour._anon_0._anon_0.alpha = v55;
    }
    m_nRotateRate = (unsigned __int16)v19->m_nRotateRate;
    v19->m_fSize = m_fStdSize + (float)((float)(m_fStdSize * fPulseFrac) * -0.0);
    if ( m_nRotateRate )
    {
      v60 = *(_QWORD *)&v19->m_mat.tx;
      tz = v19->m_mat.tz;
      CMatrix::RotateZ(
        &v19->m_mat,
        (float)((float)(CTimer::ms_fTimeStep * (float)(__int16)m_nRotateRate) * 3.1416) / 180.0);
      m_LastMapReadX = (unsigned __int16)v19->m_LastMapReadX;
      *(_QWORD *)&v19->m_mat.tx = v60;
      if ( m_LastMapReadX == (unsigned __int16)(int)*(float *)&v60 )
      {
        if ( (unsigned __int16)v19->m_LastMapReadY != (unsigned __int16)(int)*((float *)&v60 + 1) )
          v19->m_mat.tz = tz;
      }
      else
      {
        v19->m_mat.tz = tz;
      }
    }
    if ( ((1 << nType) & 0x63) != 0 )
    {
      v63 = vecPosition->x;
      v19->m_mat.tx = vecPosition->x;
      y = vecPosition->y;
      v65 = (unsigned __int16)v19->m_LastMapReadX;
      v19->m_mat.ty = y;
      v66 = vecPosition->z;
      if ( v65 == (unsigned __int16)(int)v63 )
      {
        if ( (unsigned __int16)v19->m_LastMapReadY != (unsigned __int16)(int)y )
          v19->m_mat.tz = v66;
        if ( nType == 1 )
          goto LABEL_97;
      }
      else
      {
        v19->m_mat.tz = v66;
        if ( nType == 1 )
        {
LABEL_97:
          if ( CWaterLevel::GetWaterLevelNoWaves(v63, y, v19->m_mat.tz, &colPoint.m_vecPosition.x, 0, 0)
            && colPoint.m_vecPosition.x >= v19->m_mat.tz )
          {
            v19->m_mat.tz = colPoint.m_vecPosition.x;
          }
          else
          {
            *(_QWORD *)&v77.y = __PAIR64__(LODWORD(z), HIDWORD(v21));
            LODWORD(v77.x) = v21;
            C3dMarker::UpdateZCoordinate(v19, v77, v23);
          }
          goto LABEL_81;
        }
      }
      v67 = nType == 4;
      if ( nType != 4 )
        v67 = nType == 2;
      if ( !v67 )
        goto LABEL_81;
    }
    else if ( ((1 << nType) & 0x14) == 0 )
    {
      goto LABEL_81;
    }
    v68 = vecPosition->x;
    v69 = nType == 2;
    v19->m_mat.tx = vecPosition->x;
    v70 = vecPosition->y;
    v19->m_mat.ty = v70;
    if ( nType == 2 )
      v69 = zCheck == 1;
    if ( v69 )
    {
      if ( (unsigned __int16)v19->m_LastMapReadX != (unsigned __int16)(int)v68
        || (unsigned __int16)v19->m_LastMapReadY != (unsigned __int16)(int)v70 )
      {
        v19->m_mat.tz = vecPosition->z;
      }
      C3dMarker::UpdateZCoordinate(v19, *vecPosition, 10.0);
    }
    else
    {
      v19->m_mat.tz = vecPosition->z;
    }
    goto LABEL_81;
  }
  return v19;
}
// 5C373E: conditional instruction was optimized away because r5.4<7u
// 5C39B6: conditional instruction was optimized away because r5.4<7u
// 5C3A84: conditional instruction was optimized away because r5.4 is in (==0|2..6)
// 5C3C82: conditional instruction was optimized away because r5.4<7u
// 5C3C8C: conditional instruction was optimized away because r5.4<7u
// 5C3DC4: using guessed type int dword_5C3DC4[2];

//----- (005C3DD4) --------------------------------------------------------
C3dMarker *__fastcall C3dMarkers::PlaceMarkerSet(
        u_native nIdentifier,
        uint16 nType,
        CVector *vecPosition,
        float fSize,
        uint8 r,
        uint8 g,
        uint8 b,
        unsigned int a,
        uint16 nPeriod,
        float fPulseFrac,
        int16 nRotRate)
{
  return C3dMarkers::PlaceMarker(
           nIdentifier,
           nType,
           vecPosition,
           fSize,
           r,
           g,
           b,
           (unsigned int)(float)((float)a / 3.0),
           nPeriod,
           fPulseFrac,
           1,
           0.0,
           0.0,
           0.0,
           0);
}

//----- (005C3E40) --------------------------------------------------------
void __fastcall CCheckpoint::Render(CCheckpoint *this)
{
  CVector *p_m_pos; // r9
  int zCheck; // r12
  RwUInt8 r; // lr
  RwUInt8 green; // r4
  int v6; // r8
  RwUInt8 b; // r5
  unsigned int a; // r11
  bool v9; // zf
  float m_fSize; // s2
  float z; // s0
  float x; // s4
  float y; // s6
  __int64 v14; // r0
  int v15; // r2
  float32x2_t v16; // d16
  unsigned __int64 v17; // d1
  float v18; // s0
  int v19; // r6
  char v20; // r5
  float v21; // s2
  float v22; // s10
  float v23; // s12
  float m_multiSize; // s3
  float v25; // s8
  RwReal v26; // s4
  RwReal v27; // s8
  C3dMarkers::directionArrows *v28; // r2
  int v29; // [sp+38h] [bp-50h]
  float pScaleY; // [sp+3Ch] [bp-4Ch] BYREF
  float pScaleX; // [sp+40h] [bp-48h] BYREF
  RwV3d_0 pResult; // [sp+44h] [bp-44h] BYREF
  RwV3d_0 In; // [sp+50h] [bp-38h] BYREF
  float pWaterZ[11]; // [sp+5Ch] [bp-2Ch] BYREF

  switch ( this->m_nType )
  {
    case 0u:
    case 1u:
    case 2u:
      p_m_pos = &this->m_pos;
      if ( CWaterLevel::GetWaterLevelNoWaves(this->m_pos.x, this->m_pos.y, this->m_pos.z, pWaterZ, 0, 0) )
      {
        if ( pWaterZ[0] < this->m_pos.z )
        {
          zCheck = 1;
        }
        else
        {
          this->m_pos.z = pWaterZ[0];
          zCheck = 0;
        }
      }
      else
      {
        zCheck = 1;
      }
      r = this->rwColour._anon_0._anon_0.red;
      green = this->rwColour._anon_0._anon_0.green;
      v6 = 1;
      b = this->rwColour._anon_0._anon_0.blue;
      a = this->rwColour._anon_0._anon_0.alpha;
      In.z = this->m_pos.z;
      *(_QWORD *)&In.x = *(_QWORD *)&p_m_pos->x;
      In.z = In.z + 3.0;
      if ( this->m_nType == 1 )
      {
        v29 = zCheck;
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpFinishFlagTex->raster);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
        RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
        if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) == 1 )
          CSprite::RenderOneXLUSprite(
            pResult.x,
            pResult.y,
            pResult.z,
            (float)(this->m_fSize * pScaleX) * 0.5,
            (float)(this->m_fSize * pScaleY) * 0.5,
            this->rwColour._anon_0._anon_0.red,
            this->rwColour._anon_0._anon_0.green,
            this->rwColour._anon_0._anon_0.blue,
            255,
            1.0 / pResult.z,
            this->rwColour._anon_0._anon_0.alpha,
            0,
            0,
            0.0,
            0.0);
        v6 = 0;
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
        zCheck = v29;
      }
      C3dMarkers::PlaceMarker(
        this->m_nIdentifier,
        2u,
        &this->m_pos,
        this->m_fSize * 1.5,
        r,
        green,
        b,
        a,
        this->m_nPulsePeriod,
        this->m_fPulseFraction,
        1,
        0.0,
        0.0,
        0.0,
        zCheck);
      v9 = v6 == 1;
      if ( v6 == 1 )
        v9 = this->m_nType == 0;
      if ( !v9 )
        return;
      m_fSize = this->m_fSize;
      z = this->m_pos.z;
      x = this->m_pointDir.x;
      y = this->m_pointDir.y;
      v14 = *(_QWORD *)&this->m_pos.x;
      if ( C3dMarkers::ms_directionArrows[0].bActive )
      {
        if ( C3dMarkers::ms_directionArrows[1].bActive )
        {
          if ( C3dMarkers::ms_directionArrows[2].bActive )
          {
            if ( C3dMarkers::ms_directionArrows[3].bActive )
            {
              if ( C3dMarkers::ms_directionArrows[4].bActive )
                return;
              v15 = 4;
            }
            else
            {
              v15 = 3;
            }
          }
          else
          {
            v15 = 2;
          }
        }
        else
        {
          v15 = 1;
        }
      }
      else
      {
        v15 = 0;
      }
      v27 = -this->m_pointDir.z;
      v28 = &C3dMarkers::ms_directionArrows[v15];
      v28->bActive = 1;
      *(_QWORD *)&v28->pos.x = v14;
      *(_QWORD *)&v28->r = 0x40000000FFLL;
      *(_QWORD *)&v28->b = 0xFF00000040LL;
      v28->pos.z = z + 3.0;
      v28->fSize = m_fSize / 1.6;
      v28->normal.x = -x;
      v28->normal.y = -y;
      v28->normal.z = v27;
      return;
    case 3u:
      FindPlayerCoors((CVector *)&In, -1);
      v16.n64_u64[0] = vsub_f32(*(float32x2_t *)&In.y, *(float32x2_t *)&this->m_pos.y).n64_u64[0];
      v17 = vmul_f32(v16, v16).n64_u64[0];
      v18 = this->m_fSize;
      if ( sqrtf(
             (float)((float)((float)(In.x - this->m_pos.x) * (float)(In.x - this->m_pos.x)) + *(float *)&v17)
           + *((float *)&v17 + 1)) >= (float)(v18 + v18) )
        C3dMarkers::PlaceMarker(
          this->m_nIdentifier,
          4u,
          &this->m_pos,
          v18,
          this->rwColour._anon_0._anon_0.red,
          this->rwColour._anon_0._anon_0.green,
          this->rwColour._anon_0._anon_0.blue,
          this->rwColour._anon_0._anon_0.alpha,
          this->m_nPulsePeriod,
          this->m_fPulseFraction,
          this->m_nRotateRate,
          this->m_pointDir.x,
          this->m_pointDir.y,
          this->m_pointDir.z,
          0);
      return;
    case 4u:
    case 5u:
    case 7u:
    case 8u:
      goto LABEL_2;
    case 6u:
      v19 = 1;
      v20 = -16;
      do
      {
        v21 = this->m_pointDir.y;
        v22 = this->m_pointDir.x;
        v23 = this->m_pointDir.z;
        m_multiSize = this->m_multiSize;
        v25 = this->m_pos.z;
        v26 = this->m_pos.x + (float)((float)(v22 * (float)v19) * m_multiSize);
        In.y = (float)((float)(v21 * (float)v19) * m_multiSize) + this->m_pos.y;
        In.x = v26;
        In.z = (float)((float)(v23 * (float)v19) * m_multiSize) + v25;
        C3dMarkers::PlaceMarker(
          this->m_nIdentifier,
          4u,
          (CVector *)&In,
          this->m_fSize,
          this->rwColour._anon_0._anon_0.red,
          this->rwColour._anon_0._anon_0.green,
          this->rwColour._anon_0._anon_0.blue,
          (unsigned __int8)(v20 + this->rwColour._anon_0._anon_0.alpha),
          this->m_nPulsePeriod,
          this->m_fPulseFraction,
          this->m_nRotateRate,
          v22,
          v21,
          v23,
          0);
        ++v19;
        v20 -= 16;
      }
      while ( v19 != 4 );
LABEL_2:
      C3dMarkers::PlaceMarker(
        this->m_nIdentifier,
        4u,
        &this->m_pos,
        this->m_fSize,
        this->rwColour._anon_0._anon_0.red,
        this->rwColour._anon_0._anon_0.green,
        this->rwColour._anon_0._anon_0.blue,
        this->rwColour._anon_0._anon_0.alpha,
        this->m_nPulsePeriod,
        this->m_fPulseFraction,
        this->m_nRotateRate,
        this->m_pointDir.x,
        this->m_pointDir.y,
        this->m_pointDir.z,
        0);
      return;
    default:
      return;
  }
}
// 0: using guessed type int dword_0;
// 5C3E40: using guessed type float pWaterZ[11];

//----- (005C4304) --------------------------------------------------------
void __fastcall CCheckpoints::UpdatePos(uint32 nIdentifier, CVector *newPos)
{
  int v2; // r3
  float *i; // r12
  int v4; // r0
  float z; // s0

  v2 = -1;
  for ( i = &CCheckpoints::m_aCheckPtArray[0].m_multiSize; *((_DWORD *)i - 12) != nIdentifier; i += 14 )
  {
    if ( ++v2 >= 31 )
      return;
  }
  v4 = *((unsigned __int16 *)i - 26);
  *(i - 9) = newPos->x;
  *(i - 8) = newPos->y;
  if ( v4 != 8 )
  {
    if ( v4 == 7 )
      z = newPos->z + *i;
    else
      z = newPos->z;
    *(i - 7) = z;
  }
}

//----- (005C435C) --------------------------------------------------------
void __fastcall CCheckpoints::SetHeading(uint32 nIdentifier, float fHeading)
{
  int v3; // r1
  CVector *i; // r4
  float v5; // s0

  v3 = -1;
  for ( i = &CCheckpoints::m_aCheckPtArray[0].m_pointDir; LODWORD(i[-2].x) != nIdentifier; i = (CVector *)((char *)i + 56) )
  {
    if ( ++v3 >= 31 )
      return;
  }
  v5 = (float)(fHeading * 3.1416) / 180.0;
  i->y = sinf(v5);
  i->x = cosf(v5);
  j_CVector::Normalise(i);
}

//----- (005C43C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CCheckpoint *__fastcall CCheckpoints::PlaceMarker(
        uint32 nIdentifier,
        unsigned int nType,
        CVector *vecPosition,
        CVector *pointDir,
        float fSize,
        uint8 r,
        uint8 g,
        RwUInt8 b,
        uint8 a,
        uint16 nPeriod,
        float fPulseFrac,
        int16 nRotRate)
{
  const CVector *PlayerCentreOfWorld; // r0
  float x; // s0
  float y; // s2
  int v19; // r0
  float v20; // s22
  __int16 v21; // r11
  int16 v22; // r10
  uint16 v23; // r12
  uint8 v24; // r2
  RwUInt8 v25; // r3
  uint8 v26; // lr
  CCheckpoint *v27; // r5
  float v28; // s18
  int v29; // r0
  float v30; // s24
  float v31; // s26
  float v32; // s28
  float v33; // s30
  float v34; // s17
  float v35; // s19
  uint8 v36; // r0
  int v37; // r0
  float m_fCameraRange; // s0
  __int64 v39; // d16
  __int64 v40; // d16
  float v41; // s0
  float v42; // s2
  float v43; // s4
  float v44; // s6
  float z; // s0
  CVector v47; // [sp+0h] [bp-90h] BYREF
  CVector v48; // [sp+Ch] [bp-84h] BYREF
  CVector v49; // [sp+18h] [bp-78h] BYREF
  CVector v50; // [sp+24h] [bp-6Ch] BYREF

  PlayerCentreOfWorld = FindPlayerCentreOfWorld(0);
  x = PlayerCentreOfWorld->x;
  y = PlayerCentreOfWorld->y;
  v19 = -1;
  v20 = vecPosition->x;
  v21 = nType;
  v22 = nRotRate;
  v23 = nPeriod;
  v24 = g;
  v25 = b;
  v26 = a;
  v27 = CCheckpoints::m_aCheckPtArray;
  v28 = sqrtf(
          (float)((float)(vecPosition->x - x) * (float)(vecPosition->x - x))
        + (float)((float)(vecPosition->y - y) * (float)(vecPosition->y - y)));
  do
  {
    if ( v27->m_bIsUsed && v27->m_nIdentifier == nIdentifier )
    {
      if ( nType <= 7 && ((1 << nType) & 0xA8) != 0 )
      {
        FindPlayerCoors(&v50, -1);
        v30 = vecPosition->x;
        v31 = v50.x;
        FindPlayerCoors(&v49, -1);
        v32 = vecPosition->y;
        v33 = v49.x;
        FindPlayerCoors(&v48, -1);
        v34 = vecPosition->y;
        v35 = v48.y;
        FindPlayerCoors(&v47, -1);
        v26 = a;
        v25 = b;
        v24 = g;
        v22 = nRotRate;
        v23 = nPeriod;
        v36 = r;
        if ( sqrtf((float)((float)(v20 - v31) * (float)(v30 - v33)) + (float)((float)(v32 - v35) * (float)(v34 - v47.y))) < 2.0 )
        {
          v21 = 6;
          if ( nType == 7 )
            v21 = 8;
        }
      }
      else
      {
LABEL_27:
        v36 = r;
      }
      v27->m_nRotateRate = v22;
      v27->rwColour._anon_0._anon_0.red = v36;
      v27->m_fSize = fSize;
      v27->m_fCameraRange = v28;
      v27->rwColour._anon_0._anon_0.green = v24;
      v27->rwColour._anon_0._anon_0.alpha = v26;
      v27->rwColour._anon_0._anon_0.blue = v25;
      v39 = *(_QWORD *)&vecPosition->x;
      v27->m_pos.z = vecPosition->z;
      *(_QWORD *)&v27->m_pos.x = v39;
      v40 = *(_QWORD *)&pointDir->x;
      v27->m_pointDir.z = pointDir->z;
      v41 = v27->m_pos.x;
      v42 = v27->m_pos.y;
      *(_QWORD *)&v27->m_pointDir.x = v40;
      v43 = v27->m_pointDir.x;
      v44 = v27->m_pointDir.y;
      v27->m_bIsUsed = 1;
      v27->m_nIdentifier = nIdentifier;
      v27->m_nType = v21;
      v27->m_nPulsePeriod = v23;
      v27->m_fPulseFraction = fPulseFrac;
      v27->m_pointDir.x = v43 - v41;
      z = v27->m_pointDir.z;
      v27->m_pointDir.y = v44 - v42;
      v27->m_pointDir.z = z - v27->m_pos.z;
      CVector::Normalise(&v27->m_pointDir);
      return v27;
    }
    ++v19;
    ++v27;
  }
  while ( v19 < 31 );
  v27 = CCheckpoints::m_aCheckPtArray;
  v29 = -1;
  while ( v27->m_nType != 257 )
  {
    ++v29;
    ++v27;
    if ( v29 > 30 )
      goto LABEL_17;
  }
  if ( v27 )
  {
    v24 = g;
    goto LABEL_27;
  }
LABEL_17:
  v37 = 0;
  v27 = 0;
  do
  {
    m_fCameraRange = CCheckpoints::m_aCheckPtArray[v37].m_fCameraRange;
    if ( v28 < m_fCameraRange )
    {
      if ( v27 )
      {
        if ( m_fCameraRange > v27->m_fCameraRange )
          v27 = &CCheckpoints::m_aCheckPtArray[v37];
      }
      else
      {
        v27 = &CCheckpoints::m_aCheckPtArray[v37];
      }
    }
    ++v37;
  }
  while ( v37 != 32 );
  v24 = g;
  if ( v27 )
  {
    v27->m_nType = 257;
    goto LABEL_27;
  }
  return 0;
}
// 5C43C0: variables would overlap: ^A4.1 and ^A4.8

//----- (005C45E8) --------------------------------------------------------
void __fastcall CCheckpoints::DeleteCP(uint32 nIdentifier, uint16 nType)
{
  int i; // r6

  for ( i = 0; i != 32; ++i )
  {
    if ( CCheckpoints::m_aCheckPtArray[i].m_bIsUsed
      && CCheckpoints::m_aCheckPtArray[i].m_nIdentifier == nIdentifier
      && CCheckpoints::m_aCheckPtArray[i].m_nType == nType )
    {
      CCheckpoints::m_aCheckPtArray[i].m_bIsUsed = 0;
      CCheckpoints::m_aCheckPtArray[i].m_nType = 257;
      CCheckpoints::m_aCheckPtArray[i].m_nIdentifier = 0;
    }
  }
}

//----- (005C465C) --------------------------------------------------------
void CMirrors::BeforeConstructRenderList()
{
  CVehicle *PlayerVehicle; // r0
  CSimpleTransform *p_tx; // r2
  CMirrorAttributeZone *MirrorAttributesForCoors; // r0
  CMirrorAttributeZone *v3; // r4
  Int8 Flags; // r0
  _BOOL4 IsSphereVisible; // r9
  bool v6; // r4
  float MirrorNormalZ; // s0
  int MirrorNormalY; // r1
  int MirrorNormalX; // r2
  Int32 v10; // r0
  CMatrix posn; // [sp+10h] [bp-68h] BYREF

  if ( CMirrors::d3dRestored )
  {
    CMirrors::TypeOfMirror = 0;
    CMirrors::d3dRestored = 0;
    CMirrors::MirrorFlags = 0;
  }
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( PlayerVehicle && (unsigned int)(PlayerVehicle->m_vehicleType - 3) < 2 )
    goto LABEL_11;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  MirrorAttributesForCoors = CCullZones::FindMirrorAttributesForCoors(p_tx->m_translate);
  v3 = MirrorAttributesForCoors;
  if ( !MirrorAttributesForCoors )
    goto LABEL_11;
  Flags = MirrorAttributesForCoors->Flags;
  if ( (Flags & 2) == 0 )
  {
LABEL_13:
    CMirrors::MirrorV = v3->MirrorV;
    MirrorNormalZ = (float)v3->MirrorNormalZ;
    MirrorNormalY = v3->MirrorNormalY;
    MirrorNormalX = v3->MirrorNormalX;
    v6 = 1;
    CMirrors::MirrorFlags = Flags;
    v10 = 1;
    CMirrors::MirrorNormal.x = (float)MirrorNormalX / 100.0;
    CMirrors::MirrorNormal.y = (float)MirrorNormalY / 100.0;
    CMirrors::MirrorNormal.z = MirrorNormalZ / 100.0;
    if ( fabsf(MirrorNormalZ / 100.0) > 0.7 )
      v10 = 2;
    CMirrors::TypeOfMirror = v10;
    CMirrors::CreateBuffer();
    if ( (CMirrors::MirrorFlags & 2) != 0 )
      goto LABEL_18;
    goto LABEL_16;
  }
  TheCamera.m_bMirrorActive = 0;
  posn.xx = (float)((float)((float)(Screens8Track[0].x1 + Screens8Track[0].x2) + Screens8Track[0].x3)
                  + Screens8Track[0].x4)
          * 0.25;
  posn.yx = (float)((float)((float)(Screens8Track[0].y1 + Screens8Track[0].y2) + Screens8Track[0].y3)
                  + Screens8Track[0].y4)
          * 0.25;
  posn.zx = (float)((float)((float)(Screens8Track[0].z1 + Screens8Track[0].z2) + Screens8Track[0].z3)
                  + Screens8Track[0].z4)
          * 0.25;
  IsSphereVisible = CCamera::IsSphereVisible(&TheCamera, (const CVector *)&posn, 8.0);
  TheCamera.m_bMirrorActive = 0;
  posn.xx = (float)((float)((float)(Screens8Track[1].x1 + Screens8Track[1].x2) + Screens8Track[1].x3)
                  + Screens8Track[1].x4)
          * 0.25;
  posn.yx = (float)((float)((float)(Screens8Track[1].y1 + Screens8Track[1].y2) + Screens8Track[1].y3)
                  + Screens8Track[1].y4)
          * 0.25;
  posn.zx = (float)((float)((float)(Screens8Track[1].z1 + Screens8Track[1].z2) + Screens8Track[1].z3)
                  + Screens8Track[1].z4)
          * 0.25;
  if ( CCamera::IsSphereVisible(&TheCamera, (const CVector *)&posn, 8.0) || IsSphereVisible )
  {
    Flags = v3->Flags;
    goto LABEL_13;
  }
LABEL_11:
  v6 = 0;
  CMirrors::MirrorFlags = 0;
  CMirrors::TypeOfMirror = 0;
LABEL_16:
  if ( !bFudgeNow )
  {
    CCamera::DealWithMirrorBeforeConstructRenderList(&TheCamera, v6, CMirrors::MirrorNormal, CMirrors::MirrorV, 0);
    return;
  }
LABEL_18:
  posn.m_pRwMat = 0;
  posn.m_owner = 0;
  CMirrors::BuildCameraMatrixForScreens(&posn);
  CCamera::DealWithMirrorBeforeConstructRenderList(&TheCamera, v6, CMirrors::MirrorNormal, CMirrors::MirrorV, &posn);
  CMatrix::~CMatrix(&posn);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005C4974) --------------------------------------------------------
void CMirrors::CreateBuffer()
{
  RwInt32 depth; // r4
  RwInt32 v1; // r4
  RwInt32 v2; // r5
  RwRaster_0 *v3; // r0

  if ( !CMirrors::pBuffer )
  {
    depth = Scene.camera->frameBuffer->depth;
    if ( Fx_c::GetFxQuality(&g_fx) >= FX_QUALITY_MEDIUM )
    {
      CMirrors::pBuffer = RwRasterCreate(1024, 512, depth, 5);
      if ( CMirrors::pBuffer )
      {
        CMirrors::pZBuffer = RwRasterCreate(1024, 512, depth, 1);
        if ( CMirrors::pZBuffer )
          goto LABEL_7;
        RwRasterDestroy(CMirrors::pBuffer);
        CMirrors::pBuffer = 0;
      }
    }
    CMirrors::pBuffer = RwRasterCreate(512, 256, depth, 5);
    CMirrors::pZBuffer = RwRasterCreate(512, 256, depth, 1);
  }
LABEL_7:
  v1 = 0;
  if ( MobileSettings::settings[7].value == 2 )
    v1 = 256;
  if ( MobileSettings::settings[7].value == 3 )
    v1 = 512;
  if ( v1 )
  {
    if ( CMirrors::reflBuffer[0] )
    {
      if ( CMirrors::reflBuffer[0]->height == v1 )
        return;
      v2 = Scene.camera->frameBuffer->depth;
      RwRasterDestroy(CMirrors::reflBuffer[0]);
      RwRasterDestroy(CMirrors::reflBuffer[1]);
    }
    else
    {
      v2 = Scene.camera->frameBuffer->depth;
    }
    CMirrors::reflBuffer[0] = RwRasterCreate(v1, v1, v2, 5);
    v3 = RwRasterCreate(v1, v1, v2, 1);
  }
  else
  {
    if ( !CMirrors::reflBuffer[0] )
      return;
    RwRasterDestroy(CMirrors::reflBuffer[0]);
    RwRasterDestroy(CMirrors::reflBuffer[1]);
    v3 = 0;
    CMirrors::reflBuffer[0] = 0;
  }
  CMirrors::reflBuffer[1] = v3;
}

//----- (005C4AF4) --------------------------------------------------------
void __fastcall CMirrors::BuildCameraMatrixForScreens(CMatrix *pCamMatrix)
{
  uint32 v2; // r5
  signed int v3; // r6
  int v4; // r0
  float v5; // s16
  CVector *p_xy; // r5
  __int64 v7; // d16
  __int64 v8; // d16
  CVector v9[3]; // [sp+0h] [bp-28h] BYREF

  v2 = (CTimer::m_snTimeInMilliseconds / 0x3E8) & 0x1F;
  if ( v2 <= 0x19 )
  {
    v3 = CTimer::m_snTimeInMilliseconds % 0x3E8;
    if ( 1 << v2 << 28 )
    {
      v5 = (float)((float)((float)((float)v3 / 1000.0) + (float)(int)v2) * 6.0) + -1249.3;
      CMatrix::SetTranslateOnly(pCamMatrix, v5, -224.5, 1064.2);
      p_xy = (CVector *)&pCamMatrix->xy;
      pCamMatrix->xy = -1265.4 - v5;
      *(_QWORD *)&pCamMatrix->yy = 0xC130000041880000LL;
LABEL_9:
      CVector::Normalise(p_xy);
      pCamMatrix->yz = 0.0;
      pCamMatrix->zz = 1.0;
      pCamMatrix->xz = 0.0;
      CrossProduct(v9, (const CVector *)&pCamMatrix->xz, p_xy);
      v7 = *(_QWORD *)&v9[0].x;
      pCamMatrix->zx = v9[0].z;
      *(_QWORD *)&pCamMatrix->xx = v7;
      CVector::Normalise((CVector *)pCamMatrix);
      CrossProduct(v9, p_xy, (const CVector *)pCamMatrix);
      v8 = *(_QWORD *)&v9[0].x;
      pCamMatrix->zz = v9[0].z;
      *(_QWORD *)&pCamMatrix->xz = v8;
      return;
    }
    if ( ((1 << v2) & 0x3C00) != 0 )
    {
      CMatrix::SetTranslateOnly(pCamMatrix, -1406.4, -135.3, 1045.7);
      *(_QWORD *)&pCamMatrix->yy = 0xC0233400C1380000LL;
      v4 = 1081711104;
      goto LABEL_8;
    }
    if ( ((1 << v2) & 0x3C00000) != 0 )
    {
      CMatrix::SetTranslateOnly(pCamMatrix, -1479.0, -290.5, 1099.5);
      pCamMatrix->yy = 33.8;
      v4 = 1112276992;
      pCamMatrix->zy = (float)((float)((float)((float)((float)v3 / 1000.0) + (float)(int)(v2 - 22)) * 3.0) + 1057.3)
                     + -1099.5;
LABEL_8:
      LODWORD(pCamMatrix->xy) = v4;
      p_xy = (CVector *)&pCamMatrix->xy;
      goto LABEL_9;
    }
  }
  CMatrix::SetRotateZOnly(pCamMatrix, (float)(CTimer::m_snTimeInMilliseconds & 0x3FFF) * 0.0003835);
  sub_19A684(pCamMatrix, -1397.0, -219.0, 1054.0);
}

//----- (005C4D10) --------------------------------------------------------
void CMirrors::BeforeMainRender()
{
  RwCamera_0 *camera; // r2
  __int64 v1; // kr00_8
  RwCamera_0 *v2; // r0
  CLink<CPed *> *i; // r0
  CRGBA v4; // [sp+4h] [bp-1Ch] BYREF

  if ( CMirrors::TypeOfMirror )
  {
    camera = Scene.camera;
    v1 = *(_QWORD *)&Scene.camera->frameBuffer;
    Scene.camera->frameBuffer = CMirrors::pBuffer;
    camera->zBuffer = CMirrors::pZBuffer;
    CCamera::SetCameraUpForMirror(&TheCamera);
    CRGBA::CRGBA(&v4, 0, 0, 0, 0xFFu);
    RwCameraClear(Scene.camera, &v4, 3);
    v2 = Scene.camera;
    Scene.camera->viewWindow.y = -Scene.camera->viewWindow.y;
    if ( RsCameraBeginUpdate(v2) )
    {
      CMirrors::bRenderingReflection = 1;
      DefinedState();
      RenderScene(1);
      CVisibilityPlugins::RenderWeaponPedsForPC();
      for ( i = CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext;
            CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext != &CVisibilityPlugins::ms_weaponPedsForPC.m_lastLink;
            i = CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext )
      {
        i->m_pNext->m_pPrev = i->m_pPrev;
        i->m_pPrev->m_pNext = i->m_pNext;
        i->m_pNext = CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext;
        CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext->m_pPrev = i;
        i->m_pPrev = &CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink;
        CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext = i;
      }
      CMirrors::bRenderingReflection = 0;
      RwCameraEndUpdate(Scene.camera);
      *(_QWORD *)&Scene.camera->frameBuffer = v1;
      CCamera::RestoreCameraAfterMirror(&TheCamera);
    }
  }
}

//----- (005C4E30) --------------------------------------------------------
void CMirrors::RenderReflections()
{
  char v0; // r0
  int *v1; // r2
  Int32 v2; // r10
  __int64 v3; // kr00_8
  UInt8 m_nSkyTopBlue; // r4
  UInt8 m_nSkyTopGreen; // r2
  UInt8 m_nSkyTopRed; // r0
  RwReal v7; // s0
  RwCamera_0 *camera; // r0
  __int64 v9; // kr08_8
  CSimpleTransform *p_tx; // r2
  __int64 v11; // d16
  CPlayerPed *PlayerPed; // r0
  RwV3d_0 posn; // [sp+8h] [bp-30h] BYREF
  CRGBA v14; // [sp+18h] [bp-20h] BYREF

  if ( MobileSettings::settings[7].value >= 2 )
  {
    CMirrors::CreateBuffer();
    if ( MobileSettings::settings[7].value >= 2 && FindPlayerPed(-1) && CMirrors::reflBuffer[0] )
    {
      v0 = `guard variable for'CMirrors::RenderReflections(void)::radius;
      __dmb(0xBu);
      if ( (v0 & 1) == 0
        && _cxa_guard_acquire((__guard *)&`guard variable for'CMirrors::RenderReflections(void)::radius) )
      {
        v1 = dword_5C504C;
        if ( MobileSettings::settings[7].value == 2 )
          v1 = &dword_5C504C[1];
        LODWORD(CMirrors::RenderReflections(void)::radius) = *v1;
        _cxa_guard_release((__guard *)&`guard variable for'CMirrors::RenderReflections(void)::radius);
      }
      CCamera::SetToSphereMap(&TheCamera, CMirrors::RenderReflections(void)::radius);
      v2 = CMirrors::TypeOfMirror;
      CMirrors::TypeOfMirror = 3;
      v3 = *(_QWORD *)&Scene.camera->frameBuffer;
      *(_QWORD *)&Scene.camera->frameBuffer = *(_QWORD *)CMirrors::reflBuffer;
      emu_SetRenderingSphere(0, 1u);
      m_nSkyTopBlue = 64;
      m_nSkyTopGreen = CTimeCycle::m_CurrentColours.m_nSkyTopGreen;
      m_nSkyTopRed = CTimeCycle::m_CurrentColours.m_nSkyTopRed;
      if ( CTimeCycle::m_CurrentColours.m_nSkyTopRed <= 0x40u )
        m_nSkyTopRed = 64;
      if ( CTimeCycle::m_CurrentColours.m_nSkyTopGreen <= 0x40u )
        m_nSkyTopGreen = 64;
      if ( CTimeCycle::m_CurrentColours.m_nSkyTopBlue > 0x40u )
        m_nSkyTopBlue = CTimeCycle::m_CurrentColours.m_nSkyTopBlue;
      CRGBA::CRGBA(&v14, m_nSkyTopRed, m_nSkyTopGreen, m_nSkyTopBlue, 0xFFu);
      RwCameraClear(Scene.camera, &v14, 3);
      if ( RsCameraBeginUpdate(Scene.camera) )
      {
        v7 = CMirrors::RenderReflections(void)::radius * 0.75;
        camera = Scene.camera;
        v9 = *(_QWORD *)&Scene.camera->farPlane;
        Scene.camera->farPlane = CMirrors::RenderReflections(void)::radius;
        camera->fogPlane = v7;
        CMirrors::bRenderingReflection = 1;
        if ( CCutsceneMgr::ms_running )
        {
          p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            p_tx = &TheCamera.m_transform;
          v11 = *(_QWORD *)&p_tx->m_translate.x;
          posn.z = *(RwReal *)&byte_8[(_DWORD)p_tx];
          *(_QWORD *)&posn.x = v11;
        }
        else
        {
          PlayerPed = FindPlayerPed(-1);
          CPed::GetBonePosition(PlayerPed, &posn, 4u, 0);
          posn.z = posn.z + -2.0;
        }
        emu_SetCameraPosition(&posn.x);
        DefinedState();
        CRenderer::ConstructReflectionList();
        RenderScene(0);
        CBirds::Render();
        CMirrors::bRenderingReflection = 0;
        RwCameraEndUpdate(Scene.camera);
        emu_SetRenderingSphere(0, 0);
        *(_QWORD *)&Scene.camera->frameBuffer = v3;
        CMirrors::TypeOfMirror = v2;
        CCamera::SetToSphereMap(&TheCamera, 0.0);
        *(_QWORD *)&Scene.camera->farPlane = v9;
      }
      else
      {
        emu_SetRenderingSphere(0, 0);
        CCamera::SetToSphereMap(&TheCamera, 0.0);
      }
    }
  }
}
// 5C504C: using guessed type int dword_5C504C[2];
// A5A164: using guessed type char `guard variable for'CMirrors::RenderReflections(void)::radius;

//----- (005C5098) --------------------------------------------------------
void __fastcall CMirrors::RenderReflBuffer(bool hidden)
{
  _BOOL4 v1; // r4
  int v2; // r1
  float v3; // s16
  float v4; // s20
  float v5; // s18
  float v6; // s20
  float z; // r0

  v1 = hidden;
  if ( CMirrors::reflBuffer[0] && MobileSettings::settings[7].value >= 2 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)RwEngineInstance + 96);
    v3 = (float)*(int *)(v2 + 12);
    v4 = *(float *)(*(_DWORD *)RwEngineInstance + 128);
    v5 = (float)*(int *)(v2 + 16);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CMirrors::reflBuffer[0]);
    v6 = 1.0 / v4;
    z = RwIm2DGetNearScreenZ();
    if ( v1 )
      Im2DRenderQuad(v3 * 0.68, v5 * 0.02, v3 * 0.68, v5 * 0.02, z, v6, 0.0);
    else
      Im2DRenderQuad(v3 * 0.68, v5 * 0.02, v3 * 0.98, v5 * 0.32, z, v6, 0.0);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    sub_192840(rwRENDERSTATESRCBLEND, &byte_5);
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C51C8) --------------------------------------------------------
void __fastcall CMirrors::RenderMirrorBuffer(bool withZ)
{
  _BOOL4 v1; // r4
  RwRaster_0 *frameBuffer; // r0
  int height; // s2
  float width; // s16
  float nearPlane; // s0
  float v6; // s0
  float v7; // s0
  float v8; // s0
  CSimpleTransform *p_tx; // r2
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1

  v1 = withZ;
  if ( CMirrors::TypeOfMirror )
  {
    frameBuffer = Scene.camera->frameBuffer;
    height = frameBuffer->height;
    width = (float)frameBuffer->width;
    DefinedState();
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CMirrors::pBuffer);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
    if ( (CMirrors::MirrorFlags & 2) != 0 || bFudgeNow )
    {
      if ( !v1 )
        return;
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
      TempVertexBuffer.m_3d[1].position.z = Screens8Track[0].z2;
      *(_QWORD *)&TempVertexBuffer.m_3d[0].position.x = *(_QWORD *)&Screens8Track[0].x1;
      TempVertexBuffer.m_3d[0].position.z = Screens8Track[0].z1;
      *(_QWORD *)&TempVertexBuffer.m_3d[1].position.x = *(_QWORD *)&Screens8Track[0].x2;
      TempVertexBuffer.m_3d[2].position.x = Screens8Track[0].x3;
      TempVertexBuffer.m_3d[2].position.y = Screens8Track[0].y3;
      TempVertexBuffer.m_3d[2].position.z = Screens8Track[0].z3;
      TempVertexBuffer.m_3d[3].position.x = Screens8Track[0].x4;
      TempVertexBuffer.m_3d[3].position.z = Screens8Track[0].z4;
      TempVertexBuffer.m_3d[3].position.y = Screens8Track[0].y4;
      TempVertexBuffer.m_3d[1].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[2].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[3].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[0].texCoords.v = 0.0;
      TempVertexBuffer.m_3d[0].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[0].texCoords.u = 0.0;
      TempVertexBuffer.m_3d[1].texCoords.v = 0.0;
      TempVertexBuffer.m_3d[1].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[2].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[2].texCoords.v = 1.0;
      TempBufferIndicesStored = 6;
      TempBufferVerticesStored = 4;
      *(_DWORD *)TempBufferRenderIndexList = *(_DWORD *)MirrorIndex;
      *(_DWORD *)&TempBufferRenderIndexList[2] = unk_6B23A8;
      *(_DWORD *)&TempBufferRenderIndexList[4] = unk_6B23AC;
      TempVertexBuffer.m_3d[3].texCoords.v = 1.0;
      TempVertexBuffer.m_3d[3].texCoords.u = 0.0;
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, 4u, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
      TempVertexBuffer.m_3d[0].position.x = Screens8Track[1].x1;
      TempVertexBuffer.m_3d[0].position.y = Screens8Track[1].y1;
      TempVertexBuffer.m_3d[0].position.z = Screens8Track[1].z1;
      TempVertexBuffer.m_3d[1].position.z = Screens8Track[1].z2;
      TempVertexBuffer.m_3d[1].position.x = Screens8Track[1].x2;
      TempVertexBuffer.m_3d[1].position.y = Screens8Track[1].y2;
      TempVertexBuffer.m_3d[2].position.z = Screens8Track[1].z3;
      TempVertexBuffer.m_3d[2].position.x = Screens8Track[1].x3;
      TempVertexBuffer.m_3d[2].position.y = Screens8Track[1].y3;
      TempVertexBuffer.m_3d[0].texCoords.v = 0.0;
      TempVertexBuffer.m_3d[0].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[0].texCoords.u = 0.0;
      TempVertexBuffer.m_3d[1].texCoords.v = 0.0;
      TempVertexBuffer.m_3d[1].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[1].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[2].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[2].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[2].texCoords.v = 1.0;
      TempVertexBuffer.m_3d[3].position.x = Screens8Track[1].x4;
      TempVertexBuffer.m_3d[3].position.y = Screens8Track[1].y4;
      TempVertexBuffer.m_3d[3].position.z = Screens8Track[1].z4;
      TempVertexBuffer.m_3d[3].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[3].texCoords.u = 0.0;
      *(_DWORD *)TempBufferRenderIndexList = *(_DWORD *)MirrorIndex;
      *(_DWORD *)&TempBufferRenderIndexList[2] = unk_6B23A8;
      TempBufferIndicesStored = 6;
      *(_DWORD *)&TempBufferRenderIndexList[4] = unk_6B23AC;
      TempVertexBuffer.m_3d[3].texCoords.v = 1.0;
      TempBufferVerticesStored = 4;
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, 4u, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
    }
    else
    {
      if ( v1 )
        return;
      MirrorVertex[0].x = 0.0;
      MirrorVertex[0].y = 0.0;
      MirrorVertex[0].z = RwIm2DGetNearScreenZ();
      nearPlane = Scene.camera->nearPlane;
      *(_QWORD *)&MirrorVertex[0].r = 0x3F800000FFFFDCDCLL;
      MirrorVertex[0].t = 0.0;
      MirrorVertex[1].x = 0.0;
      MirrorVertex[1].y = (float)height;
      MirrorVertex[0].rhw = 1.0 / nearPlane;
      MirrorVertex[1].z = RwIm2DGetNearScreenZ();
      v6 = Scene.camera->nearPlane;
      *(_QWORD *)&MirrorVertex[1].r = 0x3F800000FFFFDCDCLL;
      MirrorVertex[1].t = 1.0;
      MirrorVertex[2].x = width;
      MirrorVertex[2].y = (float)height;
      MirrorVertex[1].rhw = 1.0 / v6;
      MirrorVertex[2].z = RwIm2DGetNearScreenZ();
      v7 = Scene.camera->nearPlane;
      *(_DWORD *)&MirrorVertex[2].r = -8996;
      MirrorVertex[2].s = 0.0;
      MirrorVertex[2].t = 1.0;
      MirrorVertex[3].y = 0.0;
      MirrorVertex[3].x = width;
      MirrorVertex[2].rhw = 1.0 / v7;
      MirrorVertex[3].z = RwIm2DGetNearScreenZ();
      v8 = Scene.camera->nearPlane;
      *(_DWORD *)&MirrorVertex[3].r = -8996;
      MirrorVertex[3].s = 0.0;
      MirrorVertex[3].t = 0.0;
      MirrorVertex[3].rhw = 1.0 / v8;
      RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, MirrorVertex, 4, MirrorIndex, 6);
    }
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v10.n64_u64[0] = vadd_f32(*(float32x2_t *)&p_tx->m_translate.y, (float32x2_t)0xC47AC00042280000LL).n64_u64[0];
    v11 = vmul_f32(v10, v10).n64_u64[0];
    if ( sqrtf(
           (float)((float)((float)(p_tx->m_translate.x + -216.0) * (float)(p_tx->m_translate.x + -216.0))
                 + *(float *)&v11)
         + *((float *)&v11 + 1)) < 50.0 )
    {
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
      TempVertexBuffer.m_3d[0].position.y = -45.0;
      TempVertexBuffer.m_3d[0].position.x = 216.0;
      TempVertexBuffer.m_3d[0].position.z = 1000.0;
      TempVertexBuffer.m_3d[0].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[0].texCoords.u = 0.0;
      TempVertexBuffer.m_3d[0].texCoords.v = 0.0;
      TempVertexBuffer.m_3d[1].position.x = 216.0;
      TempVertexBuffer.m_3d[1].position.y = -45.0;
      TempVertexBuffer.m_3d[1].position.z = 1006.0;
      TempVertexBuffer.m_3d[1].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[1].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[1].texCoords.v = 0.0;
      TempVertexBuffer.m_3d[2].position.x = 216.0;
      TempVertexBuffer.m_3d[2].position.y = -39.0;
      TempVertexBuffer.m_3d[2].position.z = 1006.0;
      TempVertexBuffer.m_3d[2].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[2].texCoords.u = 1.0;
      TempVertexBuffer.m_3d[2].texCoords.v = 1.0;
      TempVertexBuffer.m_3d[3].position.x = 216.0;
      TempVertexBuffer.m_3d[3].position.y = -39.0;
      TempVertexBuffer.m_3d[3].position.z = 1000.0;
      TempVertexBuffer.m_3d[3].color = (RwRGBA_0)-1;
      TempVertexBuffer.m_3d[3].texCoords.u = 0.0;
      TempBufferIndicesStored = 6;
      TempBufferVerticesStored = 4;
      *(_DWORD *)TempBufferRenderIndexList = *(_DWORD *)MirrorIndex;
      *(_DWORD *)&TempBufferRenderIndexList[2] = unk_6B23A8;
      *(_DWORD *)&TempBufferRenderIndexList[4] = unk_6B23AC;
      TempVertexBuffer.m_3d[3].texCoords.v = 1.0;
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, 4u, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
    }
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005C56D8) --------------------------------------------------------
void __fastcall CMirrors::BuildCamMatrix(CMatrix *pCamMatrix, CVector Source, CVector Dest)
{
  float z; // r5
  float y; // r8
  float x; // r6
  __int64 v7; // d16
  __int64 v8; // d16
  CVector v9[2]; // [sp+0h] [bp-20h] BYREF

  z = Source.z;
  y = Source.y;
  x = Source.x;
  CMatrix::SetTranslateOnly(pCamMatrix, Source.x, Source.y, Source.z);
  pCamMatrix->xy = Dest.x - x;
  pCamMatrix->yy = Dest.y - y;
  pCamMatrix->zy = Dest.z - z;
  CVector::Normalise((CVector *)&pCamMatrix->xy);
  *(_QWORD *)&pCamMatrix->yz = 0x3F80000000000000LL;
  pCamMatrix->xz = 0.0;
  CrossProduct(v9, (const CVector *)&pCamMatrix->xz, (const CVector *)&pCamMatrix->xy);
  v7 = *(_QWORD *)&v9[0].x;
  pCamMatrix->zx = v9[0].z;
  *(_QWORD *)&pCamMatrix->xx = v7;
  CVector::Normalise((CVector *)pCamMatrix);
  CrossProduct(v9, (const CVector *)&pCamMatrix->xy, (const CVector *)pCamMatrix);
  v8 = *(_QWORD *)&v9[0].x;
  pCamMatrix->zz = v9[0].z;
  *(_QWORD *)&pCamMatrix->xz = v8;
}

//----- (005C5780) --------------------------------------------------------
float __fastcall GetZVal(float ScreenZ)
{
  return (float)((float)((float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ) * CDraw::ms_fNearClipZ)
                       / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))
               - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                       * (float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ)
                               / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))))
       / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
}

//----- (005C57E8) --------------------------------------------------------
int __fastcall CSprite::CalcScreenCoors(
        const RwV3d_0 *In,
        RwV3d_0 *pResult,
        float *pScaleX,
        float *pScaleY,
        int ClipFarPlane,
        int ClipNearPlane)
{
  float v9; // s16
  float v10; // s18
  __int64 v11; // d16
  float z; // s2
  float v14; // s16
  float y; // s4
  float v16; // s0
  float Width; // s18
  float v18; // s0
  CVector v19; // [sp+0h] [bp-30h] BYREF

  v9 = CDraw::ms_fFarClipZ;
  v10 = CDraw::ms_fNearClipZ;
  operator*(&v19, &TheCamera.m_viewMatrix, (const CVector *)In);
  v11 = *(_QWORD *)&v19.x;
  pResult->z = v19.z;
  *(_QWORD *)&pResult->x = v11;
  z = pResult->z;
  if ( z <= (float)(v10 + 1.0) && ClipNearPlane || z >= v9 && ClipFarPlane )
    return 0;
  v14 = 1.0 / z;
  y = pResult->y;
  pResult->x = pResult->x * (float)((float)(1.0 / z) * (float)RsGlobal.screenWidth);
  pResult->y = y * (float)((float)(1.0 / z) * (float)RsGlobal.screenHeight);
  if ( pScaleX )
  {
    v16 = v14 * (float)RsGlobal.screenWidth;
    *pScaleX = v16;
    *pScaleX = v16 * (float)(50.0 / CDraw::ms_fFOV);
    Width = (float)(unsigned int)OS_ScreenGetWidth();
    *pScaleX = *pScaleX * (float)(1.4286 / (float)(Width / (float)(unsigned int)OS_ScreenGetHeight()));
  }
  if ( pScaleY )
  {
    v18 = v14 * (float)RsGlobal.screenHeight;
    *pScaleY = v18;
    *pScaleY = v18 * (float)(70.0 / CDraw::ms_fFOV);
  }
  return 1;
}

//----- (005C5964) --------------------------------------------------------
float CSprite::CalcHorizonCoors()
{
  CSimpleTransform *p_tx; // r2
  float x; // s4
  float y; // s6
  CVector v4; // [sp+0h] [bp-20h] BYREF
  CVector v; // [sp+Ch] [bp-14h] BYREF

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  v.z = 0.0;
  v.x = (float)(TheCamera.CamFrontXNorm * 3000.0) + x;
  v.y = (float)(TheCamera.CamFrontYNorm * 3000.0) + y;
  operator*(&v4, &TheCamera.m_viewMatrix, &v);
  return v4.y * (float)((float)(1.0 / v4.z) * (float)RsGlobal.screenHeight);
}

//----- (005C59F4) --------------------------------------------------------
void CSprite::FlushSpriteBuffer()
{
  if ( nSpriteBufferIndex >= 1 )
  {
    if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
    {
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * nSpriteBufferIndex,
        TempBufferRenderIndexList,
        6 * nSpriteBufferIndex);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    }
    else
    {
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * nSpriteBufferIndex,
        TempBufferRenderIndexList,
        6 * nSpriteBufferIndex);
    }
    nSpriteBufferIndex = 0;
  }
}
// 0: using guessed type int dword_0;

//----- (005C5A9C) --------------------------------------------------------
void CSprite::InitSpriteBuffer()
{
  CSprite::m_f2DNearScreenZ = RwIm2DGetNearScreenZ();
  CSprite::m_f2DFarScreenZ = RwIm2DGetFarScreenZ();
}

//----- (005C5AC4) --------------------------------------------------------
void CSprite::InitSpriteBuffer2D()
{
  CSprite::m_fRecipNearClipPlane = 1.0 / Scene.camera->nearPlane;
  CSprite::m_f2DNearScreenZ = RwIm2DGetNearScreenZ();
  CSprite::m_f2DFarScreenZ = RwIm2DGetFarScreenZ();
}

//----- (005C5B10) --------------------------------------------------------
void __fastcall CSprite::RenderBufferedOneXLUSprite(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        __int16 R,
        __int16 G,
        __int16 B,
        Int16 Intensity16,
        float RecipZ,
        UInt8 Alpha)
{
  float v11; // s3
  int v13; // r5
  float screenHeight; // s8
  float screenWidth; // s10
  float *v16; // r6
  float *v17; // r0
  float v18; // s3
  float v19; // s6
  float v20; // s8
  float v21; // s10
  float *v22; // r1
  float v23; // s4
  unsigned int v24; // r2
  unsigned int v25; // r6
  unsigned int v26; // r3
  float v27; // s2
  int32 v28; // r2
  bool v29; // cc
  int v30; // r3
  RwImVertexIndex v31; // r5
  RwImVertexIndex *v32; // r1
  __int64 v33; // [sp+10h] [bp-68h]
  __int64 v34; // [sp+18h] [bp-60h]
  __int64 v35; // [sp+20h] [bp-58h]
  __int64 v36; // [sp+28h] [bp-50h]
  float v37; // [sp+3Ch] [bp-3Ch] BYREF
  float v38; // [sp+40h] [bp-38h]
  float v39; // [sp+44h] [bp-34h]
  float v40; // [sp+48h] [bp-30h]
  float v41; // [sp+4Ch] [bp-2Ch] BYREF
  float v42; // [sp+50h] [bp-28h]
  float v43; // [sp+54h] [bp-24h]
  float v44; // [sp+58h] [bp-20h]

  v11 = ScreenX - SizeX;
  v42 = ScreenX - SizeX;
  v38 = ScreenY + SizeY;
  v40 = ScreenY - SizeY;
  v44 = ScreenX + SizeX;
  v13 = 0;
  v43 = ScreenX + SizeX;
  CSprite::m_bFlushSpriteBufferSwitchZTest = 0;
  v41 = ScreenX - SizeX;
  v39 = ScreenY + SizeY;
  screenHeight = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  v37 = ScreenY - SizeY;
  v35 = 0LL;
  v36 = 0x3F8000003F800000LL;
  v33 = 0x3F80000000000000LL;
  v34 = 1065353216LL;
  while ( 1 )
  {
    v16 = (float *)((char *)&v41 + v13);
    if ( v11 < 0.0 )
    {
      *v16 = 0.0;
      *(float *)((char *)&v35 + v13) = (float)(v11 / SizeX) * -0.5;
      v11 = 0.0;
    }
    if ( v11 > screenWidth )
    {
      *v16 = screenWidth;
      *(float *)((char *)&v35 + v13) = (float)((float)((float)(v11 - screenWidth) * -0.5) / SizeX) + 1.0;
    }
    v17 = (float *)((char *)&v37 + v13);
    v18 = *(float *)((char *)&v37 + v13);
    if ( v18 < 0.0 )
    {
      *v17 = 0.0;
      *(float *)((char *)&v33 + v13) = (float)(v18 / SizeY) * -0.5;
      v18 = 0.0;
    }
    if ( v18 > screenHeight )
    {
      *v17 = screenHeight;
      *(float *)((char *)&v33 + v13) = (float)((float)((float)(v18 - screenHeight) * -0.5) / SizeY) + 1.0;
    }
    if ( v13 == 12 )
      break;
    v11 = v16[1];
    v13 += 4;
  }
  v19 = CDraw::ms_fNearClipZ;
  v20 = CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ;
  v21 = CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ;
  v22 = (float *)&TempVertexBuffer + 28 * nSpriteBufferIndex;
  v23 = CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ;
  v22[18432] = v41;
  v24 = (unsigned int)(Intensity16 * R) >> 8;
  *(float *)((char *)&elf_hash_chain[1965] + (_DWORD)v22) = v42;
  *(float *)((char *)&elf_hash_chain[1972] + (_DWORD)v22) = v43;
  *(float *)((char *)&elf_hash_chain[1979] + (_DWORD)v22) = v44;
  *(float *)((char *)&elf_hash_chain[1959] + (_DWORD)v22) = v37;
  *(float *)((char *)&elf_hash_chain[1966] + (_DWORD)v22) = v38;
  v25 = (unsigned int)(Intensity16 * B) >> 8;
  *(float *)((char *)&elf_hash_chain[1973] + (_DWORD)v22) = v39;
  *(float *)((char *)&elf_hash_chain[1980] + (_DWORD)v22) = v40;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v22) = v24;
  v26 = (unsigned int)(Intensity16 * G) >> 8;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v22 + 1) = v26;
  *((_BYTE *)v22 + 73746) = v25;
  *((_BYTE *)v22 + 73747) = Alpha;
  *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v22) = v24;
  *((_BYTE *)v22 + 73773) = v26;
  *((_BYTE *)v22 + 73774) = v25;
  *((_BYTE *)v22 + 73775) = Alpha;
  *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v22) = v24;
  *((_BYTE *)v22 + 73801) = v26;
  *((_BYTE *)v22 + 73802) = v25;
  *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v22 + 3) = Alpha;
  v22[18435] = RecipZ;
  v22[18442] = RecipZ;
  v22[18449] = RecipZ;
  v27 = (float)((float)((float)(v20 * v19) / v21) - (float)((float)((float)(ScreenZ * 0.95) + -1.0) * (float)(v23 / v21)))
      / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
  v22[18434] = v27;
  v22[18441] = v27;
  v22[18448] = v27;
  *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v22) = v24;
  *((_BYTE *)v22 + 73829) = v26;
  *((_BYTE *)v22 + 73830) = v25;
  *((_BYTE *)v22 + 73831) = Alpha;
  v22[18456] = RecipZ;
  v22[18455] = v27;
  *(int *)((char *)&elf_hash_chain[1963] + (_DWORD)v22) = v35;
  *(int *)((char *)&elf_hash_chain[1964] + (_DWORD)v22) = v33;
  *(int *)((char *)&elf_hash_chain[1970] + (_DWORD)v22) = HIDWORD(v35);
  *(int *)((char *)&elf_hash_chain[1971] + (_DWORD)v22) = HIDWORD(v33);
  *(int *)((char *)&elf_hash_chain[1977] + (_DWORD)v22) = v36;
  *(int *)((char *)&elf_hash_chain[1978] + (_DWORD)v22) = v34;
  *(int *)((char *)&elf_hash_chain[1984] + (_DWORD)v22) = HIDWORD(v36);
  *(int *)((char *)&elf_hash_chain[1985] + (_DWORD)v22) = HIDWORD(v34);
  v28 = nSpriteBufferIndex;
  v29 = nSpriteBufferIndex <= 510;
  v30 = 3 * nSpriteBufferIndex;
  LOWORD(v25) = 4 * nSpriteBufferIndex;
  v31 = (4 * nSpriteBufferIndex) | 3;
  TempBufferRenderIndexList[6 * nSpriteBufferIndex] = 4 * nSpriteBufferIndex;
  v32 = &TempBufferRenderIndexList[2 * v30];
  v32[1] = (4 * v28) | 1;
  LOWORD(v30) = (4 * v28) | 2;
  v32[2] = v30;
  v32[3] = v31;
  v32[4] = v25;
  v32[5] = v30;
  nSpriteBufferIndex = v28 + 1;
  if ( !v29 )
  {
    if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
    {
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * nSpriteBufferIndex,
        TempBufferRenderIndexList,
        6 * nSpriteBufferIndex);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    }
    else
    {
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * (v28 + 1),
        TempBufferRenderIndexList,
        6 * (v28 + 1));
    }
    nSpriteBufferIndex = 0;
  }
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005C5FC0) --------------------------------------------------------
void __fastcall CSprite::RenderOneXLUSprite(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        __int16 R,
        __int16 G,
        __int16 B,
        Int16 Intensity16,
        float RecipZ,
        UInt8 Alpha,
        int FlipU,
        int FlipV,
        float uvPad1,
        float uvPad2)
{
  float v15; // s3
  float v16; // s5
  float v17; // s11
  float v18; // s13
  float screenHeight; // s10
  float screenWidth; // s12
  float v22; // s7
  int v23; // r0
  float *v24; // r2
  float *v25; // r1
  float v26; // s3
  float v27; // [sp+4h] [bp-5Ch]
  float v28; // [sp+8h] [bp-58h]
  float v29; // [sp+Ch] [bp-54h]
  float v30; // [sp+10h] [bp-50h]
  float v31; // [sp+14h] [bp-4Ch]
  float v32; // [sp+18h] [bp-48h]
  float v33; // [sp+1Ch] [bp-44h]
  float v34; // [sp+20h] [bp-40h]
  float v35; // [sp+24h] [bp-3Ch] BYREF
  float v36; // [sp+28h] [bp-38h]
  float v37; // [sp+2Ch] [bp-34h]
  float v38; // [sp+30h] [bp-30h]
  float v39; // [sp+34h] [bp-2Ch] BYREF
  float v40; // [sp+38h] [bp-28h]
  float v41; // [sp+3Ch] [bp-24h]
  float v42; // [sp+40h] [bp-20h]

  v15 = ScreenX - SizeX;
  v16 = 1.0 - uvPad2;
  v17 = uvPad1;
  v18 = uvPad1;
  if ( !FlipV )
    v17 = 1.0 - uvPad2;
  if ( !FlipU )
    v18 = 1.0 - uvPad2;
  screenHeight = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  v41 = ScreenX + SizeX;
  v42 = ScreenX + SizeX;
  v22 = 1.0 - uvPad2;
  v39 = ScreenX - SizeX;
  if ( !FlipU )
    v22 = uvPad1;
  v37 = ScreenY + SizeY;
  v40 = ScreenX - SizeX;
  v38 = ScreenY - SizeY;
  if ( !FlipV )
    v16 = uvPad1;
  v35 = ScreenY - SizeY;
  v23 = 0;
  v33 = v18;
  v34 = v18;
  v31 = v22;
  v29 = v17;
  v30 = v16;
  v27 = v16;
  v36 = ScreenY + SizeY;
  v32 = v22;
  v28 = v17;
  while ( 1 )
  {
    v24 = (float *)((char *)&v39 + v23);
    if ( v15 < 0.0 )
    {
      *v24 = 0.0;
      *(float *)((char *)&v31 + v23) = (float)(v15 / SizeX) * -0.5;
      v15 = 0.0;
    }
    if ( v15 > screenWidth )
    {
      *v24 = screenWidth;
      *(float *)((char *)&v31 + v23) = (float)((float)((float)(v15 - screenWidth) * -0.5) / SizeX) + 1.0;
    }
    v25 = (float *)((char *)&v35 + v23);
    v26 = *(float *)((char *)&v35 + v23);
    if ( v26 < 0.0 )
    {
      *v25 = 0.0;
      *(float *)((char *)&v27 + v23) = (float)(v26 / SizeY) * -0.5;
      v26 = 0.0;
    }
    if ( v26 > screenHeight )
    {
      *v25 = screenHeight;
      *(float *)((char *)&v27 + v23) = (float)((float)((float)(v26 - screenHeight) * -0.5) / SizeY) + 1.0;
    }
    if ( v23 == 12 )
      break;
    v15 = v24[1];
    v23 += 4;
  }
  verts[3].y = v37;
  verts[2].y = v38;
  verts[0].x = v39;
  verts[2].x = v42;
  verts[3].x = v41;
  verts[0].y = v35;
  verts[1].x = v40;
  verts[1].y = v36;
  verts[0].z = (float)((float)((float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ) * CDraw::ms_fNearClipZ)
                             / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))
                     - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                             * (float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ)
                                     / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))))
             / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
  verts[0].rhw = RecipZ;
  verts[1].z = verts[0].z;
  verts[1].rhw = RecipZ;
  verts[2].z = verts[0].z;
  verts[2].rhw = RecipZ;
  verts[3].z = verts[0].z;
  verts[3].rhw = RecipZ;
  verts[0].g = (unsigned __int16)(Intensity16 * G) >> 8;
  verts[0].r = (unsigned __int16)(Intensity16 * R) >> 8;
  verts[0].b = (unsigned __int16)(Intensity16 * B) >> 8;
  verts[0].a = Alpha;
  verts[1].g = (unsigned __int16)(Intensity16 * G) >> 8;
  verts[1].r = (unsigned __int16)(Intensity16 * R) >> 8;
  verts[1].b = (unsigned __int16)(Intensity16 * B) >> 8;
  verts[1].a = Alpha;
  verts[2].g = (unsigned __int16)(Intensity16 * G) >> 8;
  verts[2].r = (unsigned __int16)(Intensity16 * R) >> 8;
  verts[2].b = (unsigned __int16)(Intensity16 * B) >> 8;
  verts[2].a = Alpha;
  verts[3].g = (unsigned __int16)(Intensity16 * G) >> 8;
  verts[3].r = (unsigned __int16)(Intensity16 * R) >> 8;
  verts[3].b = (unsigned __int16)(Intensity16 * B) >> 8;
  verts[3].a = Alpha;
  verts[0].s = v31;
  verts[0].t = v27;
  verts[1].s = v32;
  verts[1].t = v28;
  verts[2].s = v34;
  verts[2].t = v30;
  verts[3].s = v33;
  verts[3].t = v29;
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, verts, 4);
}
// 5C5FC0: using guessed type _DWORD FlipU;

//----- (005C6274) --------------------------------------------------------
void __fastcall CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        __int16 R,
        __int16 G,
        __int16 B,
        Int16 Intensity16,
        float RecipZ,
        float Rotation,
        UInt8 Alpha)
{
  float v16; // r4
  float v17; // s0
  float v18; // s8
  float v19; // s10
  float v20; // s12
  float v21; // s14
  float v22; // s0
  float v23; // s6
  float v24; // s2
  float v25; // s4
  float v26; // s7
  float v27; // s3
  float v28; // s14
  float v29; // s12
  float v30; // s10
  float screenWidth; // s8
  float screenHeight; // s8
  float *v33; // r1
  unsigned int v34; // r6
  float v35; // s2
  float v36; // s0
  unsigned int v37; // r3
  unsigned int v38; // r5
  float v39; // s0
  int32 v40; // r0
  bool v41; // cc
  int v42; // r2
  RwImVertexIndex *v43; // r1

  v16 = sinf(Rotation);
  v17 = cosf(Rotation);
  v18 = v17 - v16;
  v19 = v16 - v17;
  v20 = v16 + v17;
  CSprite::m_bFlushSpriteBufferSwitchZTest = 0;
  v21 = (float)-v17 - v16;
  v22 = (float)((float)(v17 - v16) * SizeX) + ScreenX;
  v23 = (float)(v19 * SizeX) + ScreenX;
  v24 = (float)(v20 * SizeX) + ScreenX;
  v25 = (float)(v21 * SizeX) + ScreenX;
  if ( v22 >= 0.0 || v24 >= 0.0 || v23 >= 0.0 )
  {
    v26 = v21 * SizeY;
    v27 = v19 * SizeY;
    v28 = (float)(v20 * SizeY) + ScreenY;
    v29 = v26 + ScreenY;
    v30 = (float)(v18 * SizeY) + ScreenY;
    if ( (float)(v26 + ScreenY) >= 0.0 || v30 >= 0.0 || v28 >= 0.0 )
    {
      screenWidth = (float)RsGlobal.screenWidth;
      if ( v22 <= (float)RsGlobal.screenWidth || v24 <= screenWidth || v23 <= screenWidth )
      {
        screenHeight = (float)RsGlobal.screenHeight;
        if ( v29 <= (float)RsGlobal.screenHeight || v30 <= screenHeight || v28 <= screenHeight )
        {
          v33 = (float *)&TempVertexBuffer + 28 * nSpriteBufferIndex;
          v33[18439] = v23;
          v34 = (unsigned int)(Intensity16 * G) >> 8;
          v33[18432] = v25;
          v33[18446] = v24;
          v35 = CDraw::ms_fNearClipZ;
          v33[18453] = v22;
          v36 = CDraw::ms_fFarClipZ;
          v33[18433] = v27 + ScreenY;
          v33[18440] = v28;
          v33[18447] = v30;
          v33[18454] = v29;
          v37 = (unsigned int)(Intensity16 * R) >> 8;
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73745) = v34;
          v38 = (unsigned int)(Intensity16 * B) >> 8;
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v33 + 2) = v38;
          *((_BYTE *)v33 + 73747) = Alpha;
          *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73773) = v34;
          *((_BYTE *)v33 + 73774) = v38;
          *((_BYTE *)v33 + 73775) = Alpha;
          *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73801) = v34;
          *((_BYTE *)v33 + 73802) = v38;
          *((_BYTE *)v33 + 73803) = Alpha;
          v33[18435] = RecipZ;
          v33[18442] = RecipZ;
          v33[18449] = RecipZ;
          v39 = (float)((float)((float)((float)(v36 + v36) * v35) / (float)(v36 - v35))
                      - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                              * (float)((float)(v36 + v35) / (float)(v36 - v35))))
              / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
          v33[18434] = v39;
          v33[18441] = v39;
          v33[18448] = v39;
          *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73829) = v34;
          *((_BYTE *)v33 + 73830) = v38;
          *((_BYTE *)v33 + 73831) = Alpha;
          v33[18456] = RecipZ;
          v33[18455] = v39;
          *(int *)((char *)&elf_hash_chain[1971] + (_DWORD)v33) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1964] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1963] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1970] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1978] + (_DWORD)v33) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1977] + (_DWORD)v33) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1985] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1984] + (_DWORD)v33) = 1065353216;
          v40 = nSpriteBufferIndex;
          v41 = nSpriteBufferIndex <= 510;
          v42 = 3 * nSpriteBufferIndex;
          LOWORD(v37) = 4 * nSpriteBufferIndex;
          LOWORD(v34) = (4 * nSpriteBufferIndex) | 3;
          TempBufferRenderIndexList[6 * nSpriteBufferIndex] = 4 * nSpriteBufferIndex;
          v43 = &TempBufferRenderIndexList[2 * v42];
          v43[1] = (4 * v40) | 1;
          LOWORD(v42) = (4 * v40) | 2;
          v43[2] = v42;
          v43[3] = v34;
          v43[4] = v37;
          v43[5] = v42;
          nSpriteBufferIndex = v40 + 1;
          if ( !v41 )
          {
            if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
            {
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
              RwIm2DRenderIndexedPrimitive_BUGFIX(
                rwPRIMTYPETRILIST,
                TempVertexBuffer.m_2d,
                4 * nSpriteBufferIndex,
                TempBufferRenderIndexList,
                6 * nSpriteBufferIndex);
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
            }
            else
            {
              RwIm2DRenderIndexedPrimitive_BUGFIX(
                rwPRIMTYPETRILIST,
                TempVertexBuffer.m_2d,
                4 * (v40 + 1),
                TempBufferRenderIndexList,
                6 * (v40 + 1));
            }
            nSpriteBufferIndex = 0;
          }
        }
      }
    }
  }
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005C66EC) --------------------------------------------------------
void __fastcall CSprite::RenderOneXLUSprite_Triangle(
        float ScreenX1,
        float ScreenY1,
        float ScreenX2,
        float ScreenY2,
        float ScreenX3,
        float ScreenY3,
        float ScreenZ,
        int R,
        int G,
        int B,
        int Intensity16,
        float RecipZ,
        UInt8 Alpha)
{
  unsigned int v13; // r5
  unsigned int v14; // r6
  unsigned int v15; // r8
  unsigned int v16; // lr
  int v17; // r4

  LOBYTE(v13) = R;
  LOBYTE(v14) = G;
  LOBYTE(v15) = B;
  LOWORD(v16) = Intensity16;
  if ( ScreenZ < 2.3 )
  {
    if ( ScreenZ < 1.3 )
      return;
    v17 = (int)(float)((float)(ScreenZ + -1.3) * 255.0);
    v16 = (unsigned int)(Intensity16 * v17) >> 8;
    v15 = (unsigned int)(B * v17) >> 8;
    v14 = (unsigned int)(G * v17) >> 8;
    v13 = (unsigned int)(v17 * R) >> 8;
  }
  verts[1].x = ScreenX2;
  verts[0].x = ScreenX1;
  verts[2].x = ScreenX3;
  verts[0].y = ScreenY1;
  verts[1].y = ScreenY2;
  verts[2].y = ScreenY3;
  verts[0].rhw = RecipZ;
  verts[1].rhw = RecipZ;
  verts[2].rhw = RecipZ;
  verts[0].g = (unsigned __int16)((unsigned __int8)v14 * (_WORD)v16) >> 8;
  verts[0].r = (unsigned __int16)((unsigned __int8)v13 * (_WORD)v16) >> 8;
  verts[0].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v16) >> 8;
  verts[0].a = Alpha;
  verts[1].g = (unsigned __int16)((unsigned __int8)v14 * (_WORD)v16) >> 8;
  verts[1].r = (unsigned __int16)((unsigned __int8)v13 * (_WORD)v16) >> 8;
  verts[1].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v16) >> 8;
  verts[1].a = Alpha;
  verts[0].z = (float)((float)((float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ) * CDraw::ms_fNearClipZ)
                             / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))
                     - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                             * (float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ)
                                     / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))))
             / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
  verts[1].z = verts[0].z;
  verts[2].z = verts[0].z;
  verts[2].g = (unsigned __int16)((unsigned __int8)v14 * (_WORD)v16) >> 8;
  verts[2].r = (unsigned __int16)((unsigned __int8)v13 * (_WORD)v16) >> 8;
  verts[2].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v16) >> 8;
  verts[2].a = Alpha;
  sub_18B9D0(rwPRIMTYPETRILIST, verts, 3);
}
// 5C66EC: using guessed type _DWORD R_0;
// 5C66EC: using guessed type _DWORD G_0;
// 5C66EC: using guessed type _DWORD B_0;
// 5C66EC: using guessed type _DWORD Intensity16_0;

//----- (005C686C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CSprite::RenderOneXLUSprite_Rotate_Aspect(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        int R,
        int G,
        int B,
        int Intensity16,
        float RecipZ,
        float Rotation,
        UInt8 Alpha)
{
  unsigned int v14; // r9
  unsigned int v15; // r10
  unsigned int v16; // r8
  unsigned int v17; // r11
  int v18; // r1
  float v21; // r6
  float v22; // r0
  float v23; // s12
  float v24; // s0
  float v25; // s2
  float v26; // s6
  float v27; // s4
  float v28; // s5
  float v29; // s8
  float v30; // s12
  float screenWidth; // s1

  LOWORD(v14) = Intensity16;
  LOBYTE(v15) = B;
  LOBYTE(v16) = G;
  LOBYTE(v17) = R;
  if ( ScreenZ < 2.3 )
  {
    if ( ScreenZ < 1.3 )
      return;
    v18 = (int)(float)((float)(ScreenZ + -1.3) * 255.0);
    v14 = (unsigned int)(Intensity16 * v18) >> 8;
    v15 = (unsigned int)(B * v18) >> 8;
    v16 = (unsigned int)(G * v18) >> 8;
    v17 = (unsigned int)(R * v18) >> 8;
  }
  v21 = sinf(Rotation);
  v22 = cosf(Rotation);
  v23 = (float)-v22 - v21;
  v24 = (float)((float)(v21 + v22) * SizeX) + ScreenX;
  v25 = (float)((float)(v22 - v21) * SizeX) + ScreenX;
  v26 = (float)((float)(v21 - v22) * SizeX) + ScreenX;
  v27 = (float)(v23 * SizeX) + ScreenX;
  if ( v24 >= 0.0 || v25 >= 0.0 || v26 >= 0.0 )
  {
    v28 = (float)(v21 - v22) * SizeY;
    v29 = (float)((float)(v22 - v21) * SizeY) + ScreenY;
    v30 = (float)(v23 * SizeY) + ScreenY;
    if ( v29 >= 0.0 || v30 >= 0.0 || (float)((float)((float)(v21 + v22) * SizeY) + ScreenY) >= 0.0 )
    {
      screenWidth = (float)RsGlobal.screenWidth;
      if ( (v24 <= (float)RsGlobal.screenWidth || v25 <= screenWidth || v26 <= screenWidth)
        && (v29 <= (float)RsGlobal.screenHeight || (float)(v28 + ScreenY) <= (float)RsGlobal.screenHeight) )
      {
        verts[1].x = (float)((float)(v21 - v22) * SizeX) + ScreenX;
        verts[0].x = v27;
        verts[2].x = (float)((float)(v22 - v21) * SizeX) + ScreenX;
        verts[3].x = (float)((float)(v21 + v22) * SizeX) + ScreenX;
        verts[0].y = v28 + ScreenY;
        verts[1].y = (float)((float)(v21 + v22) * SizeY) + ScreenY;
        verts[2].y = v30;
        verts[3].y = (float)((float)(v22 - v21) * SizeY) + ScreenY;
        verts[0].rhw = 1.0;
        verts[1].rhw = 1.0;
        verts[2].rhw = 1.0;
        verts[3].rhw = 1.0;
        verts[0].g = (unsigned __int16)((unsigned __int8)v16 * (_WORD)v14) >> 8;
        verts[0].r = (unsigned __int16)((unsigned __int8)v17 * (_WORD)v14) >> 8;
        verts[0].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v14) >> 8;
        verts[0].a = Alpha;
        verts[1].g = (unsigned __int16)((unsigned __int8)v16 * (_WORD)v14) >> 8;
        verts[1].r = (unsigned __int16)((unsigned __int8)v17 * (_WORD)v14) >> 8;
        verts[1].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v14) >> 8;
        verts[1].a = Alpha;
        verts[0].z = (float)((float)((float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ) * CDraw::ms_fNearClipZ)
                                   / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))
                           - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                                   * (float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ)
                                           / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))))
                   / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
        verts[1].z = verts[0].z;
        verts[2].z = verts[0].z;
        verts[3].z = verts[0].z;
        verts[2].g = (unsigned __int16)((unsigned __int8)v16 * (_WORD)v14) >> 8;
        verts[2].r = (unsigned __int16)((unsigned __int8)v17 * (_WORD)v14) >> 8;
        verts[2].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v14) >> 8;
        verts[2].a = Alpha;
        verts[3].g = (unsigned __int16)((unsigned __int8)v16 * (_WORD)v14) >> 8;
        verts[3].r = (unsigned __int16)((unsigned __int8)v17 * (_WORD)v14) >> 8;
        verts[3].b = (unsigned __int16)((unsigned __int8)v15 * (_WORD)v14) >> 8;
        verts[3].a = Alpha;
        verts[0].s = 0.0;
        verts[0].t = 0.0;
        verts[1].s = 0.0;
        verts[1].t = 1.0;
        verts[2].s = 1.0;
        verts[2].t = 0.0;
        verts[3].s = 1.0;
        verts[3].t = 1.0;
        sub_18B9D0(rwPRIMTYPETRISTRIP, verts, 4);
      }
    }
  }
}
// 5C686C: variables would overlap: ^54.4 and ^54.8
// 5C686C: variables would overlap: ^5C.4 and ^5C.8

//----- (005C6B6C) --------------------------------------------------------
void __fastcall CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        __int16 R,
        __int16 G,
        __int16 B,
        Int16 Intensity16,
        float RecipZ,
        float Rotation,
        UInt8 Alpha)
{
  float v16; // s18
  float v17; // s8
  float v18; // s6
  float v19; // s10
  float v20; // s0
  float v21; // s2
  float v22; // s6
  float v23; // s4
  float v24; // s8
  float v25; // s1
  float v26; // s14
  float v27; // s10
  float v28; // s12
  float v29; // s14
  float v30; // s1
  float screenWidth; // s8
  float screenHeight; // s8
  float *v33; // r1
  unsigned int v34; // r6
  float v35; // s2
  float v36; // s0
  unsigned int v37; // r3
  unsigned int v38; // r5
  float v39; // s0
  int32 v40; // r0
  bool v41; // cc
  int v42; // r2
  RwImVertexIndex *v43; // r1

  v16 = cosf(Rotation);
  v17 = sinf(Rotation);
  v18 = (float)(v16 * SizeX) + ScreenX;
  v19 = ScreenX - (float)(v16 * SizeX);
  CSprite::m_bFlushSpriteBufferSwitchZTest = 0;
  v20 = v18 - (float)(v17 * SizeY);
  v21 = (float)(v17 * SizeY) + v18;
  v22 = (float)(v17 * SizeY) + v19;
  v23 = v19 - (float)(v17 * SizeY);
  if ( v20 >= 0.0 || v21 >= 0.0 || v22 >= 0.0 )
  {
    v24 = v17 * SizeX;
    v25 = ScreenY - (float)(v16 * SizeY);
    v26 = (float)(v16 * SizeY) + ScreenY;
    v27 = v25 - v24;
    v28 = v26 - v24;
    v29 = v24 + v26;
    v30 = v24 + v25;
    if ( v27 >= 0.0 || v28 >= 0.0 || v29 >= 0.0 )
    {
      screenWidth = (float)RsGlobal.screenWidth;
      if ( v20 <= (float)RsGlobal.screenWidth || v21 <= screenWidth || v22 <= screenWidth )
      {
        screenHeight = (float)RsGlobal.screenHeight;
        if ( v27 <= (float)RsGlobal.screenHeight || v28 <= screenHeight || v29 <= screenHeight )
        {
          v33 = (float *)&TempVertexBuffer + 28 * nSpriteBufferIndex;
          v33[18439] = v22;
          v34 = (unsigned int)(Intensity16 * G) >> 8;
          v33[18432] = v23;
          v33[18446] = v21;
          v35 = CDraw::ms_fNearClipZ;
          v33[18453] = v20;
          v36 = CDraw::ms_fFarClipZ;
          v33[18433] = v30;
          v33[18440] = v29;
          v33[18447] = v28;
          v33[18454] = v27;
          v37 = (unsigned int)(Intensity16 * R) >> 8;
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73745) = v34;
          v38 = (unsigned int)(Intensity16 * B) >> 8;
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v33 + 2) = v38;
          *((_BYTE *)v33 + 73747) = Alpha;
          *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73773) = v34;
          *((_BYTE *)v33 + 73774) = v38;
          *((_BYTE *)v33 + 73775) = Alpha;
          *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73801) = v34;
          *((_BYTE *)v33 + 73802) = v38;
          *((_BYTE *)v33 + 73803) = Alpha;
          v33[18435] = RecipZ;
          v33[18442] = RecipZ;
          v33[18449] = RecipZ;
          v39 = (float)((float)((float)((float)(v36 + v36) * v35) / (float)(v36 - v35))
                      - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                              * (float)((float)(v36 + v35) / (float)(v36 - v35))))
              / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
          v33[18434] = v39;
          v33[18441] = v39;
          v33[18448] = v39;
          *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v33) = v37;
          *((_BYTE *)v33 + 73829) = v34;
          *((_BYTE *)v33 + 73830) = v38;
          *((_BYTE *)v33 + 73831) = Alpha;
          v33[18456] = RecipZ;
          v33[18455] = v39;
          *(int *)((char *)&elf_hash_chain[1971] + (_DWORD)v33) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1964] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1963] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1970] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1978] + (_DWORD)v33) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1977] + (_DWORD)v33) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1985] + (_DWORD)v33) = 0;
          *(int *)((char *)&elf_hash_chain[1984] + (_DWORD)v33) = 1065353216;
          v40 = nSpriteBufferIndex;
          v41 = nSpriteBufferIndex <= 510;
          v42 = 3 * nSpriteBufferIndex;
          LOWORD(v37) = 4 * nSpriteBufferIndex;
          LOWORD(v34) = (4 * nSpriteBufferIndex) | 3;
          TempBufferRenderIndexList[6 * nSpriteBufferIndex] = 4 * nSpriteBufferIndex;
          v43 = &TempBufferRenderIndexList[2 * v42];
          v43[1] = (4 * v40) | 1;
          LOWORD(v42) = (4 * v40) | 2;
          v43[2] = v42;
          v43[3] = v34;
          v43[4] = v37;
          v43[5] = v42;
          nSpriteBufferIndex = v40 + 1;
          if ( !v41 )
          {
            if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
            {
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
              RwIm2DRenderIndexedPrimitive_BUGFIX(
                rwPRIMTYPETRILIST,
                TempVertexBuffer.m_2d,
                4 * nSpriteBufferIndex,
                TempBufferRenderIndexList,
                6 * nSpriteBufferIndex);
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
            }
            else
            {
              RwIm2DRenderIndexedPrimitive_BUGFIX(
                rwPRIMTYPETRILIST,
                TempVertexBuffer.m_2d,
                4 * (v40 + 1),
                TempBufferRenderIndexList,
                6 * (v40 + 1));
            }
            nSpriteBufferIndex = 0;
          }
        }
      }
    }
  }
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005C6FD4) --------------------------------------------------------
void __fastcall CSprite::RenderOneXLUSprite_Rotate_Dimension(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        __int16 R,
        __int16 G,
        __int16 B,
        Int16 Intensity16,
        float RecipZ,
        float Rotation,
        UInt8 Alpha)
{
  float v16; // s18
  float v17; // s10
  float v18; // s6
  float v19; // s12
  float v20; // s4
  float v21; // s2
  float v22; // s6
  float v23; // s8
  float v24; // s1
  float v25; // s3
  float v26; // s14
  float v27; // s12
  float v28; // s10
  float v29; // s14
  float v30; // s1
  float screenWidth; // s3

  v16 = cosf(Rotation);
  v17 = sinf(Rotation);
  v18 = (float)(v16 * SizeX) + ScreenX;
  v19 = ScreenX - (float)(v16 * SizeX);
  v20 = v18 - (float)(v17 * SizeY);
  v21 = (float)(v17 * SizeY) + v18;
  v22 = (float)(v17 * SizeY) + v19;
  v23 = v19 - (float)(v17 * SizeY);
  if ( v20 >= 0.0 || v21 >= 0.0 || v22 >= 0.0 )
  {
    v24 = v17 * SizeX;
    v25 = ScreenY - (float)(v16 * SizeY);
    v26 = (float)(v16 * SizeY) + ScreenY;
    v27 = v25 - (float)(v17 * SizeX);
    v28 = v26 - (float)(v17 * SizeX);
    v29 = v24 + v26;
    v30 = v24 + v25;
    if ( v27 >= 0.0 || v28 >= 0.0 || v29 >= 0.0 )
    {
      screenWidth = (float)RsGlobal.screenWidth;
      if ( (v20 <= (float)RsGlobal.screenWidth || v21 <= screenWidth || v22 <= screenWidth)
        && (v27 <= (float)RsGlobal.screenHeight || v30 <= (float)RsGlobal.screenHeight) )
      {
        verts[0].x = v23;
        verts[0].y = v30;
        verts[0].z = (float)((float)((float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ) * CDraw::ms_fNearClipZ)
                                   / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))
                           - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                                   * (float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ)
                                           / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))))
                   / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
        verts[0].rhw = RecipZ;
        verts[1].x = v22;
        verts[1].y = v29;
        verts[1].z = verts[0].z;
        verts[1].rhw = RecipZ;
        verts[2].x = v20;
        verts[2].y = v27;
        verts[2].z = verts[0].z;
        verts[2].rhw = RecipZ;
        verts[3].x = v21;
        verts[3].y = v28;
        verts[3].z = verts[0].z;
        verts[3].rhw = RecipZ;
        verts[0].g = (unsigned __int16)(Intensity16 * G) >> 8;
        verts[0].r = (unsigned __int16)(Intensity16 * R) >> 8;
        verts[0].b = (unsigned __int16)(Intensity16 * B) >> 8;
        verts[0].a = Alpha;
        verts[1].g = (unsigned __int16)(Intensity16 * G) >> 8;
        verts[1].r = (unsigned __int16)(Intensity16 * R) >> 8;
        verts[1].b = (unsigned __int16)(Intensity16 * B) >> 8;
        verts[1].a = Alpha;
        verts[2].g = (unsigned __int16)(Intensity16 * G) >> 8;
        verts[2].r = (unsigned __int16)(Intensity16 * R) >> 8;
        verts[2].b = (unsigned __int16)(Intensity16 * B) >> 8;
        verts[2].a = Alpha;
        verts[3].g = (unsigned __int16)(Intensity16 * G) >> 8;
        verts[3].r = (unsigned __int16)(Intensity16 * R) >> 8;
        verts[3].b = (unsigned __int16)(Intensity16 * B) >> 8;
        verts[3].a = Alpha;
        verts[0].s = 0.0;
        verts[0].t = 0.0;
        verts[1].s = 0.0;
        verts[1].t = 1.0;
        verts[2].s = 1.0;
        verts[2].t = 0.0;
        verts[3].s = 1.0;
        verts[3].t = 1.0;
        sub_18B9D0(rwPRIMTYPETRISTRIP, verts, 4);
      }
    }
  }
}

//----- (005C7244) --------------------------------------------------------
void __fastcall CSprite::RenderBufferedOneXLUSprite_Rotate_2Colours(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        unsigned int R1,
        unsigned int G1,
        unsigned int B1,
        unsigned int R2,
        unsigned int G2,
        unsigned int B2,
        float ToColour1X,
        float ToColour1Y,
        float RecipZ,
        float Rotation,
        UInt8 Alpha)
{
  float32x2_t v16; // d8
  float32x2_t v17; // d10
  float32x2_t v18; // d12
  float32x2_t v19; // d14
  float v24; // r4
  float v25; // s2
  float v26; // s0
  float v27; // s8
  float v28; // s4
  float v29; // s2
  float v30; // s10
  float v31; // s5
  float v32; // s12
  float v33; // s11
  float v34; // s15
  float v35; // s13
  float screenWidth; // s6
  float screenHeight; // s6
  float32x2_t v38; // d0
  float *v39; // r2
  float v40; // s3
  float32x2_t v41; // d12
  float v42; // s30
  float v43; // s11
  float v44; // s26
  float v45; // s19
  float v46; // s12
  float v47; // s3
  float v48; // s11
  float v49; // s8
  float v50; // s28
  float v51; // s4
  float v52; // s30
  float v53; // s19
  float v54; // s28
  int32 v55; // r1
  bool v56; // cc
  int v57; // r2
  RwImVertexIndex v58; // r3
  RwImVertexIndex v59; // r6
  RwImVertexIndex *v60; // r0

  v24 = sinf(Rotation);
  v25 = cosf(Rotation);
  v26 = v25 - v24;
  v27 = v24 - v25;
  v28 = v24 + v25;
  CSprite::m_bFlushSpriteBufferSwitchZTest = 0;
  v29 = (float)-v25 - v24;
  v30 = (float)(v26 * SizeX) + ScreenX;
  v31 = (float)(v27 * SizeX) + ScreenX;
  v32 = (float)(v28 * SizeX) + ScreenX;
  if ( v30 >= 0.0 || v32 >= 0.0 || v31 >= 0.0 )
  {
    v33 = (float)(v26 * SizeY) + ScreenY;
    v34 = (float)(v28 * SizeY) + ScreenY;
    v35 = (float)(v29 * SizeY) + ScreenY;
    if ( v35 >= 0.0 || v33 >= 0.0 || v34 >= 0.0 )
    {
      screenWidth = (float)RsGlobal.screenWidth;
      if ( v30 <= (float)RsGlobal.screenWidth || v32 <= screenWidth || v31 <= screenWidth )
      {
        screenHeight = (float)RsGlobal.screenHeight;
        if ( v35 <= (float)RsGlobal.screenHeight || v33 <= screenHeight || v34 <= screenHeight )
        {
          v38.n64_f32[1] = ToColour1Y;
          v39 = (float *)&TempVertexBuffer + 28 * nSpriteBufferIndex;
          v39[18439] = v31;
          v39[18432] = (float)(v29 * SizeX) + ScreenX;
          v40 = CDraw::ms_fFarClipZ;
          v39[18446] = v32;
          v39[18453] = v30;
          v17.n64_u32[0] = 0;
          v39[18433] = (float)(v27 * SizeY) + ScreenY;
          v16.n64_u32[0] = 1.0;
          v39[18440] = v34;
          v18.n64_f32[0] = (float)((float)((float)(v29 * ToColour1X) + (float)(v27 * ToColour1Y)) * 0.5) + 0.5;
          v39[18447] = v33;
          v39[18454] = v35;
          v41.n64_u64[0] = vmin_f32(vmax_f32(v18, v17), v16).n64_u64[0];
          v42 = (float)(v40 + CDraw::ms_fNearClipZ) / (float)(v40 - CDraw::ms_fNearClipZ);
          v43 = v41.n64_f32[0] * (float)R1;
          v44 = v41.n64_f32[0] * (float)G1;
          v19.n64_f32[0] = v41.n64_f32[0] * (float)B1;
          v41.n64_f32[0] = 1.0 - v41.n64_f32[0];
          v45 = (float)((float)(v40 + v40) * CDraw::ms_fNearClipZ) / (float)(v40 - CDraw::ms_fNearClipZ);
          v46 = v43 + (float)(v41.n64_f32[0] * (float)R2);
          v47 = v44 + (float)(v41.n64_f32[0] * (float)G2);
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v39 + 3) = Alpha;
          *((_BYTE *)v39 + 73775) = Alpha;
          v48 = v19.n64_f32[0] + (float)(v41.n64_f32[0] * (float)B2);
          v41.n64_f32[0] = (float)((float)((float)(v27 * ToColour1X) + (float)(v28 * ToColour1Y)) * 0.5) + 0.5;
          v49 = (float)(v45 - (float)((float)((float)(ScreenZ * 0.95) + -1.0) * v42))
              / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
          v41.n64_f32[0] = vmin_f32(vmax_f32(v41, v17), v16).n64_f32[0];
          v19.n64_f32[0] = (float)((float)((float)(v28 * ToColour1X) + (float)(v26 * ToColour1Y)) * 0.5) + 0.5;
          v38.n64_f32[0] = (float)((float)((float)(v26 * ToColour1X) + (float)(v29 * ToColour1Y)) * 0.5) + 0.5;
          v50 = vmin_f32(vmax_f32(v19, v17), v16).n64_f32[0];
          v38.n64_f32[0] = vmin_f32(vmax_f32(v38, v17), v16).n64_f32[0];
          v51 = v50 * (float)B1;
          v52 = v50 * (float)R1;
          v53 = v50 * (float)G1;
          v54 = 1.0 - v50;
          v39[18435] = RecipZ;
          v39[18449] = RecipZ;
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v39 + 1) = (int)v47;
          *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v39) = (int)v46;
          *((_BYTE *)v39 + 73746) = (int)v48;
          *((_BYTE *)v39 + 73773) = (int)(float)((float)(v41.n64_f32[0] * (float)G1)
                                               + (float)((float)(1.0 - v41.n64_f32[0]) * (float)G2));
          *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v39) = (int)(float)((float)(v41.n64_f32[0] * (float)R1)
                                                                       + (float)((float)(1.0 - v41.n64_f32[0])
                                                                               * (float)R2));
          *((_BYTE *)v39 + 73774) = (int)(float)((float)(v41.n64_f32[0] * (float)B1)
                                               + (float)((float)(1.0 - v41.n64_f32[0]) * (float)B2));
          v39[18442] = RecipZ;
          v39[18456] = RecipZ;
          v39[18434] = v49;
          v39[18441] = v49;
          v39[18448] = v49;
          v39[18455] = v49;
          *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v39 + 1) = (int)(float)(v53 + (float)(v54 * (float)G2));
          *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v39) = (int)(float)(v52 + (float)(v54 * (float)R2));
          *((_BYTE *)v39 + 73802) = (int)(float)(v51 + (float)(v54 * (float)B2));
          *((_BYTE *)v39 + 73803) = Alpha;
          *((_BYTE *)v39 + 73829) = (int)(float)((float)(v38.n64_f32[0] * (float)G1)
                                               + (float)((float)(1.0 - v38.n64_f32[0]) * (float)G2));
          *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v39) = (int)(float)((float)(v38.n64_f32[0] * (float)R1)
                                                                       + (float)((float)(1.0 - v38.n64_f32[0])
                                                                               * (float)R2));
          *((_BYTE *)v39 + 73830) = (int)(float)((float)(v38.n64_f32[0] * (float)B1)
                                               + (float)((float)(1.0 - v38.n64_f32[0]) * (float)B2));
          *((_BYTE *)v39 + 73831) = Alpha;
          *(int *)((char *)&elf_hash_chain[1971] + (_DWORD)v39) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1964] + (_DWORD)v39) = 0;
          *(int *)((char *)&elf_hash_chain[1963] + (_DWORD)v39) = 0;
          *(int *)((char *)&elf_hash_chain[1970] + (_DWORD)v39) = 0;
          *(int *)((char *)&elf_hash_chain[1978] + (_DWORD)v39) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1977] + (_DWORD)v39) = 1065353216;
          *(int *)((char *)&elf_hash_chain[1985] + (_DWORD)v39) = 0;
          *(int *)((char *)&elf_hash_chain[1984] + (_DWORD)v39) = 1065353216;
          v55 = nSpriteBufferIndex;
          v56 = nSpriteBufferIndex <= 510;
          v57 = 3 * nSpriteBufferIndex;
          v58 = 4 * nSpriteBufferIndex;
          v59 = (4 * nSpriteBufferIndex) | 3;
          TempBufferRenderIndexList[6 * nSpriteBufferIndex] = 4 * nSpriteBufferIndex;
          v60 = &TempBufferRenderIndexList[2 * v57];
          v60[1] = (4 * v55) | 1;
          LOWORD(v57) = (4 * v55) | 2;
          v60[2] = v57;
          v60[3] = v59;
          v60[4] = v58;
          v60[5] = v57;
          nSpriteBufferIndex = v55 + 1;
          if ( !v56 )
          {
            if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
            {
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
              RwIm2DRenderIndexedPrimitive_BUGFIX(
                rwPRIMTYPETRILIST,
                TempVertexBuffer.m_2d,
                4 * nSpriteBufferIndex,
                TempBufferRenderIndexList,
                6 * nSpriteBufferIndex);
              RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
            }
            else
            {
              RwIm2DRenderIndexedPrimitive_BUGFIX(
                rwPRIMTYPETRILIST,
                TempVertexBuffer.m_2d,
                4 * (v55 + 1),
                TempBufferRenderIndexList,
                6 * (v55 + 1));
            }
            nSpriteBufferIndex = 0;
          }
        }
      }
    }
  }
}
// 5C74A2: variable 'v18' is possibly undefined
// 5C74A2: variable 'v17' is possibly undefined
// 5C74BA: variable 'v16' is possibly undefined
// 5C7588: variable 'v19' is possibly undefined
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];
// 5C7244: using guessed type unsigned int B1_0;
// 5C7244: using guessed type unsigned int R2_0;
// 5C7244: using guessed type unsigned int G2_0;

//----- (005C788C) --------------------------------------------------------
void __fastcall CSprite::RenderOneXLUSprite_Rotate_2Colours(
        float ScreenX,
        float ScreenY,
        float ScreenZ,
        float SizeX,
        float SizeY,
        unsigned int R1,
        unsigned int G1,
        unsigned int B1,
        unsigned int R2,
        unsigned int G2,
        unsigned int B2,
        float ToColour1X,
        float ToColour1Y,
        float RecipZ,
        float Rotation,
        UInt8 Alpha)
{
  float32x2_t v16; // d8
  float32x2_t v17; // d9
  float32x2_t v18; // d10
  float32x2_t v19; // d12
  float32x2_t v20; // d13
  float32x2_t v21; // d14
  float v26; // s16
  float v27; // r0
  float v28; // s5
  float v29; // s3
  float v30; // s7
  float v31; // s9
  float v32; // s4
  float v33; // s8
  float v34; // s2
  float v35; // s14
  float screenWidth; // s15
  float v37; // s18
  float32x2_t v38; // d18
  float v39; // s26
  float v40; // s20
  float v41; // s22
  float v42; // s30
  float v43; // s25
  float v44; // s20
  float v45; // [sp+4h] [bp-6Ch]

  v26 = sinf(Rotation);
  v27 = cosf(Rotation);
  v28 = v27 - v26;
  v29 = v26 + v27;
  v30 = v26 - v27;
  v31 = (float)-v27 - v26;
  v32 = (float)((float)(v27 - v26) * SizeX) + ScreenX;
  v33 = (float)((float)(v26 - v27) * SizeX) + ScreenX;
  v34 = (float)((float)(v26 + v27) * SizeX) + ScreenX;
  if ( v32 >= 0.0 || v34 >= 0.0 || v33 >= 0.0 )
  {
    v35 = (float)(v31 * SizeY) + ScreenY;
    if ( v35 >= 0.0 || (float)((float)(v28 * SizeY) + ScreenY) >= 0.0 || (float)((float)(v29 * SizeY) + ScreenY) >= 0.0 )
    {
      screenWidth = (float)RsGlobal.screenWidth;
      if ( (v32 <= (float)RsGlobal.screenWidth || v34 <= screenWidth || v33 <= screenWidth)
        && (v35 <= (float)RsGlobal.screenHeight
         || (float)((float)(v30 * SizeY) + ScreenY) <= (float)RsGlobal.screenHeight) )
      {
        v21.n64_u32[0] = 0;
        v16.n64_u32[0] = 1.0;
        v17.n64_f32[0] = (float)((float)((float)(v28 * ToColour1X) + (float)(v31 * ToColour1Y)) * 0.5) + 0.5;
        v19.n64_f32[0] = (float)((float)((float)(v29 * ToColour1X) + (float)(v28 * ToColour1Y)) * 0.5) + 0.5;
        v18.n64_f32[0] = (float)((float)((float)(v31 * ToColour1X) + (float)(v30 * ToColour1Y)) * 0.5) + 0.5;
        v37 = vmin_f32(vmax_f32(v17, v21), v16).n64_f32[0];
        v20.n64_f32[0] = (float)((float)((float)(v30 * ToColour1X) + (float)(v29 * ToColour1Y)) * 0.5) + 0.5;
        v38.n64_u64[0] = vmax_f32(v20, v21).n64_u64[0];
        v39 = vmin_f32(vmax_f32(v19, v21), v16).n64_f32[0];
        v40 = vmin_f32(vmax_f32(v18, v21), v16).n64_f32[0];
        v41 = vmin_f32(v38, v16).n64_f32[0];
        v45 = v40 * (float)B1;
        v42 = v40 * (float)G1;
        v43 = v40 * (float)R1;
        v44 = 1.0 - v40;
        verts[1].x = v33;
        verts[0].x = (float)(v31 * SizeX) + ScreenX;
        verts[2].x = v32;
        verts[3].x = v34;
        verts[0].y = (float)(v30 * SizeY) + ScreenY;
        verts[1].y = (float)(v29 * SizeY) + ScreenY;
        verts[2].y = (float)(v31 * SizeY) + ScreenY;
        verts[3].y = (float)(v28 * SizeY) + ScreenY;
        verts[0].rhw = RecipZ;
        verts[1].rhw = RecipZ;
        verts[2].rhw = RecipZ;
        verts[3].rhw = RecipZ;
        verts[0].z = (float)((float)((float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fFarClipZ) * CDraw::ms_fNearClipZ)
                                   / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))
                           - (float)((float)((float)(ScreenZ * 0.95) + -1.0)
                                   * (float)((float)(CDraw::ms_fFarClipZ + CDraw::ms_fNearClipZ)
                                           / (float)(CDraw::ms_fFarClipZ - CDraw::ms_fNearClipZ))))
                   / (float)-(float)((float)(ScreenZ * 0.95) + -1.0);
        verts[1].z = verts[0].z;
        verts[2].z = verts[0].z;
        verts[3].z = verts[0].z;
        verts[0].g = (unsigned int)(float)(v42 + (float)(v44 * (float)G2));
        verts[0].r = (unsigned int)(float)(v43 + (float)(v44 * (float)R2));
        verts[0].b = (unsigned int)(float)(v45 + (float)(v44 * (float)B2));
        verts[0].a = Alpha;
        verts[1].g = (unsigned int)(float)((float)(v41 * (float)G1) + (float)((float)(1.0 - v41) * (float)G2));
        verts[1].r = (unsigned int)(float)((float)(v41 * (float)R1) + (float)((float)(1.0 - v41) * (float)R2));
        verts[1].b = (unsigned int)(float)((float)(v41 * (float)B1) + (float)((float)(1.0 - v41) * (float)B2));
        verts[1].a = Alpha;
        verts[3].g = (unsigned int)(float)((float)(v39 * (float)G1) + (float)((float)(1.0 - v39) * (float)G2));
        verts[3].r = (unsigned int)(float)((float)(v39 * (float)R1) + (float)((float)(1.0 - v39) * (float)R2));
        verts[3].b = (unsigned int)(float)((float)(v39 * (float)B1) + (float)((float)(1.0 - v39) * (float)B2));
        verts[3].a = Alpha;
        verts[2].g = (unsigned int)(float)((float)(v37 * (float)G1) + (float)((float)(1.0 - v37) * (float)G2));
        verts[2].r = (unsigned int)(float)((float)(v37 * (float)R1) + (float)((float)(1.0 - v37) * (float)R2));
        verts[2].b = (unsigned int)(float)((float)(v37 * (float)B1) + (float)((float)(1.0 - v37) * (float)B2));
        verts[2].a = Alpha;
        verts[0].s = 0.0;
        verts[0].t = 0.0;
        verts[1].s = 0.0;
        verts[1].t = 1.0;
        verts[2].s = 1.0;
        verts[2].t = 0.0;
        verts[3].s = 1.0;
        verts[3].t = 1.0;
        sub_18B9D0(rwPRIMTYPETRISTRIP, verts, 4);
      }
    }
  }
}
// 5C7AA0: variable 'v17' is possibly undefined
// 5C7AA0: variable 'v21' is possibly undefined
// 5C7AB0: variable 'v16' is possibly undefined
// 5C7AE0: variable 'v20' is possibly undefined
// 5C7AC0: variable 'v19' is possibly undefined
// 5C7ABC: variable 'v18' is possibly undefined

//----- (005C7D08) --------------------------------------------------------
void __fastcall CSprite::RenderBufferedOneXLUSprite2D(
        float ScreenX,
        float ScreenY,
        float SizeX,
        float SizeY,
        const RwRGBA_0 *rgbaColor,
        int16 Intensity16,
        uint8 Alpha)
{
  int32 v7; // lr
  __int16 red; // r2
  __int16 green; // r1
  __int16 blue; // r6
  float *v11; // r5
  int v12; // r12
  int v13; // r4
  unsigned int v14; // r2
  unsigned int v15; // r1
  unsigned int v16; // r0
  RwImVertexIndex *v17; // r0
  int v18; // r0

  v7 = nSpriteBufferIndex;
  CSprite::m_bFlushSpriteBufferSwitchZTest = 1;
  red = rgbaColor->_anon_0._anon_0.red;
  green = rgbaColor->_anon_0._anon_0.green;
  blue = rgbaColor->_anon_0._anon_0.blue;
  v11 = (float *)&TempVertexBuffer + 28 * nSpriteBufferIndex;
  v12 = LODWORD(CSprite::m_fRecipNearClipPlane);
  v13 = LODWORD(CSprite::m_f2DNearScreenZ);
  *(float *)((char *)&elf_hash_chain[1960] + (_DWORD)v11) = CSprite::m_f2DNearScreenZ;
  *(int *)((char *)&elf_hash_chain[1961] + (_DWORD)v11) = v12;
  *(int *)((char *)&elf_hash_chain[1963] + (_DWORD)v11) = 0;
  *(int *)((char *)&elf_hash_chain[1964] + (_DWORD)v11) = 0;
  *((_BYTE *)v11 + 73747) = Alpha;
  *(int *)((char *)&elf_hash_chain[1967] + (_DWORD)v11) = v13;
  *(int *)((char *)&elf_hash_chain[1968] + (_DWORD)v11) = v12;
  *(int *)((char *)&elf_hash_chain[1970] + (_DWORD)v11) = 1065353216;
  *(int *)((char *)&elf_hash_chain[1971] + (_DWORD)v11) = 0;
  v14 = (unsigned int)(red * Intensity16) >> 8;
  v15 = (unsigned int)(green * Intensity16) >> 8;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v11) = v14;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v11 + 1) = v15;
  v16 = (unsigned int)(blue * Intensity16) >> 8;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v11 + 2) = v16;
  *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v11) = v14;
  *((_BYTE *)v11 + 73773) = v15;
  *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v11 + 2) = v16;
  *((_BYTE *)v11 + 73775) = Alpha;
  v11[18433] = ScreenY - SizeY;
  v11[18439] = ScreenX + SizeX;
  v11[18432] = ScreenX - SizeX;
  v11[18440] = ScreenY - SizeY;
  *(int *)((char *)&elf_hash_chain[1974] + (_DWORD)v11) = v13;
  *(int *)((char *)&elf_hash_chain[1975] + (_DWORD)v11) = v12;
  *(int *)((char *)&elf_hash_chain[1977] + (_DWORD)v11) = 1065353216;
  *(int *)((char *)&elf_hash_chain[1978] + (_DWORD)v11) = 1065353216;
  *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v11) = v14;
  *((_BYTE *)v11 + 73801) = v15;
  *((_BYTE *)v11 + 73802) = v16;
  *((_BYTE *)v11 + 73803) = Alpha;
  v11[18446] = ScreenX + SizeX;
  v11[18447] = ScreenY + SizeY;
  *((_BYTE *)v11 + 73831) = Alpha;
  *(int *)((char *)&elf_hash_chain[1981] + (_DWORD)v11) = v13;
  *(int *)((char *)&elf_hash_chain[1982] + (_DWORD)v11) = v12;
  *(int *)((char *)&elf_hash_chain[1984] + (_DWORD)v11) = 0;
  *(int *)((char *)&elf_hash_chain[1985] + (_DWORD)v11) = 1065353216;
  *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v11) = v14;
  *((_BYTE *)v11 + 73829) = v15;
  *((_BYTE *)v11 + 73830) = v16;
  v11[18454] = ScreenY + SizeY;
  LOWORD(v14) = (4 * v7) | 2;
  v11[18453] = ScreenX - SizeX;
  TempBufferRenderIndexList[6 * v7] = 4 * v7;
  v17 = &TempBufferRenderIndexList[6 * v7];
  v17[2] = v14;
  v17[4] = 4 * v7;
  v17[5] = v14;
  v17[1] = (4 * v7) | 1;
  v17[3] = (4 * v7) | 3;
  v18 = nSpriteBufferIndex + 1;
  if ( nSpriteBufferIndex++ > 510 )
  {
    if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
    {
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * nSpriteBufferIndex,
        TempBufferRenderIndexList,
        6 * nSpriteBufferIndex);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    }
    else
    {
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * v18,
        TempBufferRenderIndexList,
        6 * v18);
    }
    nSpriteBufferIndex = 0;
  }
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005C8038) --------------------------------------------------------
void __fastcall CSprite::Set4Vertices2D(
        RwIm2DVertex *maVertices,
        const CRect *Rectangle,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba)
{
  float v6; // lr
  float v7; // r12

  v6 = CSprite::m_f2DNearScreenZ;
  v7 = CSprite::m_fRecipNearClipPlane;
  maVertices->x = Rectangle->left;
  maVertices->y = Rectangle->bottom;
  maVertices->z = v6;
  maVertices->rhw = v7;
  maVertices->s = 0.0;
  maVertices->t = 0.0;
  *(CRGBA *)&maVertices->r = *BottomLeftrgba;
  maVertices[1].x = Rectangle->right;
  maVertices[1].y = Rectangle->bottom;
  maVertices[1].z = v6;
  maVertices[1].rhw = v7;
  maVertices[1].s = 1.0;
  maVertices[1].t = 0.0;
  *(CRGBA *)&maVertices[1].r = *BottomRightrgba;
  maVertices[2].x = Rectangle->right;
  maVertices[2].y = Rectangle->top;
  maVertices[2].z = v6;
  maVertices[2].rhw = v7;
  maVertices[2].s = 1.0;
  maVertices[2].t = 1.0;
  *(CRGBA *)&maVertices[2].r = *TopRightrgba;
  maVertices[3].x = Rectangle->left;
  maVertices[3].y = Rectangle->top;
  maVertices[3].z = v6;
  maVertices[3].rhw = v7;
  maVertices[3].s = 0.0;
  maVertices[3].t = 1.0;
  *(CRGBA *)&maVertices[3].r = *TopLeftrgba;
}

//----- (005C8110) --------------------------------------------------------
void __fastcall CSprite::RenderOneXLUSprite2D(
        float ScreenX,
        float ScreenY,
        float SizeX,
        float SizeY,
        const RwRGBA_0 *rgbaColor,
        int16 Intensity16,
        uint8 Alpha)
{
  float v7; // s10
  float v8; // s0
  unsigned int v9; // r2
  unsigned int v10; // lr
  unsigned int v11; // r0
  RwImVertexIndex indices[4]; // [sp+8h] [bp-28h] BYREF
  int v13; // [sp+10h] [bp-20h]

  v7 = ScreenX + SizeX;
  v8 = ScreenX - SizeX;
  v9 = ((unsigned int)rgbaColor->_anon_0._anon_0.green * Intensity16) >> 8;
  v10 = ((unsigned int)rgbaColor->_anon_0._anon_0.blue * Intensity16) >> 8;
  v11 = ((unsigned int)rgbaColor->_anon_0._anon_0.red * Intensity16) >> 8;
  verts[0].s = 0.0;
  verts[0].t = 0.0;
  verts[0].a = Alpha;
  verts[1].s = 1.0;
  verts[1].t = 0.0;
  verts[1].a = Alpha;
  verts[0].z = CSprite::m_f2DNearScreenZ;
  verts[0].rhw = CSprite::m_fRecipNearClipPlane;
  verts[1].z = CSprite::m_f2DNearScreenZ;
  verts[1].rhw = CSprite::m_fRecipNearClipPlane;
  verts[0].x = v8;
  verts[0].y = ScreenY - SizeY;
  verts[1].x = v7;
  verts[1].y = ScreenY - SizeY;
  verts[0].r = v11;
  verts[0].g = v9;
  verts[0].b = v10;
  verts[1].r = v11;
  verts[1].g = v9;
  verts[1].b = v10;
  verts[2].z = CSprite::m_f2DNearScreenZ;
  verts[2].rhw = CSprite::m_fRecipNearClipPlane;
  verts[2].s = 1.0;
  verts[2].t = 1.0;
  verts[2].r = v11;
  verts[2].g = v9;
  verts[2].b = v10;
  verts[2].a = Alpha;
  verts[2].x = v7;
  verts[2].y = ScreenY + SizeY;
  verts[3].z = CSprite::m_f2DNearScreenZ;
  verts[3].rhw = CSprite::m_fRecipNearClipPlane;
  verts[3].s = 0.0;
  verts[3].t = 1.0;
  verts[3].r = v11;
  verts[3].g = v9;
  verts[3].b = v10;
  verts[3].a = Alpha;
  verts[3].x = v8;
  verts[3].y = ScreenY + SizeY;
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  v13 = 196610;
  *(_QWORD *)indices = 0x200010000LL;
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, verts, 4, indices, 6);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
}
// 0: using guessed type int dword_0;

//----- (005C8244) --------------------------------------------------------
void __fastcall CSprite::RenderBufferedOneXLUSprite2D_Rotate_Dimension(
        float ScreenX,
        float ScreenY,
        float SizeX,
        float SizeY,
        const RwRGBA_0 *rgbaColor,
        int16 Intensity16,
        float Rotation,
        uint8 Alpha)
{
  int32 v9; // r4
  __int16 red; // r8
  __int16 green; // lr
  __int16 blue; // r12
  float *v13; // r5
  int v14; // r0
  int v15; // r6
  unsigned int v16; // r9
  unsigned int v17; // r11
  unsigned int v18; // r10
  float v20; // s20
  float v21; // r0
  float v22; // s6
  float v23; // s2
  float v24; // s12
  float v25; // s0
  RwImVertexIndex *v26; // r0
  RwImVertexIndex v27; // r1
  int v28; // r0
  int v30; // [sp+8h] [bp-50h]

  v9 = nSpriteBufferIndex;
  CSprite::m_bFlushSpriteBufferSwitchZTest = 1;
  red = rgbaColor->_anon_0._anon_0.red;
  green = rgbaColor->_anon_0._anon_0.green;
  blue = rgbaColor->_anon_0._anon_0.blue;
  v13 = (float *)&TempVertexBuffer + 28 * nSpriteBufferIndex;
  v14 = LODWORD(CSprite::m_fRecipNearClipPlane);
  v15 = LODWORD(CSprite::m_f2DNearScreenZ);
  *(float *)((char *)&elf_hash_chain[1960] + (_DWORD)v13) = CSprite::m_f2DNearScreenZ;
  *(int *)((char *)&elf_hash_chain[1961] + (_DWORD)v13) = v14;
  v30 = v14;
  *(int *)((char *)&elf_hash_chain[1963] + (_DWORD)v13) = 0;
  *(int *)((char *)&elf_hash_chain[1964] + (_DWORD)v13) = 0;
  *((_BYTE *)v13 + 73747) = Alpha;
  *(int *)((char *)&elf_hash_chain[1967] + (_DWORD)v13) = v15;
  *(int *)((char *)&elf_hash_chain[1968] + (_DWORD)v13) = v14;
  *(int *)((char *)&elf_hash_chain[1970] + (_DWORD)v13) = 1065353216;
  *(int *)((char *)&elf_hash_chain[1971] + (_DWORD)v13) = 0;
  v16 = (unsigned int)(red * Intensity16) >> 8;
  v17 = (unsigned int)(green * Intensity16) >> 8;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v13) = v16;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v13 + 1) = v17;
  v18 = (unsigned int)(blue * Intensity16) >> 8;
  *((_BYTE *)v13 + 73746) = v18;
  *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v13) = v16;
  *((_BYTE *)v13 + 73773) = v17;
  *((_BYTE *)v13 + 73774) = v18;
  *((_BYTE *)v13 + 73775) = Alpha;
  v20 = sinf(Rotation);
  v21 = cosf(Rotation);
  v22 = ScreenY - (float)(v21 * SizeY);
  v23 = (float)(v21 * SizeY) + ScreenY;
  v13[18433] = (float)(v20 * SizeX) + v22;
  v24 = ScreenX - (float)(v21 * SizeX);
  v25 = (float)(v21 * SizeX) + ScreenX;
  v13[18439] = (float)(v20 * SizeY) + v24;
  v13[18432] = v24 - (float)(v20 * SizeY);
  v13[18440] = (float)(v20 * SizeX) + v23;
  *(int *)((char *)&elf_hash_chain[1974] + (_DWORD)v13) = v15;
  *(int *)((char *)&elf_hash_chain[1975] + (_DWORD)v13) = v30;
  *(int *)((char *)&elf_hash_chain[1977] + (_DWORD)v13) = 1065353216;
  *(int *)((char *)&elf_hash_chain[1978] + (_DWORD)v13) = 1065353216;
  *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v13) = v16;
  *((_BYTE *)v13 + 73801) = v17;
  *((_BYTE *)v13 + 73802) = v18;
  *((_BYTE *)v13 + 73803) = Alpha;
  v13[18446] = (float)(v20 * SizeY) + v25;
  v13[18447] = v23 - (float)(v20 * SizeX);
  *((_BYTE *)v13 + 73831) = Alpha;
  *(int *)((char *)&elf_hash_chain[1981] + (_DWORD)v13) = v15;
  *(int *)((char *)&elf_hash_chain[1982] + (_DWORD)v13) = v30;
  *(int *)((char *)&elf_hash_chain[1984] + (_DWORD)v13) = 0;
  *(int *)((char *)&elf_hash_chain[1985] + (_DWORD)v13) = 1065353216;
  *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v13) = v16;
  *((_BYTE *)v13 + 73829) = v17;
  *((_BYTE *)v13 + 73830) = v18;
  v13[18454] = v22 - (float)(v20 * SizeX);
  v13[18453] = v25 - (float)(v20 * SizeY);
  TempBufferRenderIndexList[6 * v9] = 4 * v9;
  v26 = &TempBufferRenderIndexList[6 * v9];
  v27 = (4 * v9) | 2;
  v26[2] = v27;
  v26[4] = 4 * v9;
  v26[5] = v27;
  v26[1] = (4 * v9) | 1;
  v26[3] = (4 * v9) | 3;
  v28 = nSpriteBufferIndex + 1;
  if ( nSpriteBufferIndex++ > 510 )
  {
    if ( CSprite::m_bFlushSpriteBufferSwitchZTest )
    {
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * nSpriteBufferIndex,
        TempBufferRenderIndexList,
        6 * nSpriteBufferIndex);
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    }
    else
    {
      RwIm2DRenderIndexedPrimitive_BUGFIX(
        rwPRIMTYPETRILIST,
        TempVertexBuffer.m_2d,
        4 * v28,
        TempBufferRenderIndexList,
        6 * v28);
    }
    nSpriteBufferIndex = 0;
  }
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005C85E0) --------------------------------------------------------
void __fastcall CSprite::Set4Vertices2D(
        RwIm2DVertex *maVertices,
        float x1,
        float y1,
        float x2,
        float y2,
        float x3,
        float y3,
        float x4,
        float y4,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba)
{
  float v13; // r12
  float v14; // lr
  unsigned __int8 alpha; // r6
  unsigned __int8 v16; // r4
  unsigned __int8 v17; // r3

  v13 = CSprite::m_fRecipNearClipPlane;
  v14 = CSprite::m_f2DNearScreenZ;
  maVertices->x = x3;
  maVertices->y = y3;
  maVertices->z = v14;
  maVertices->rhw = v13;
  maVertices->s = 0.0;
  maVertices->t = 0.0;
  maVertices->r = BottomLeftrgba->_anon_0._anon_0.red;
  maVertices->g = BottomLeftrgba->_anon_0._anon_0.green;
  maVertices->b = BottomLeftrgba->_anon_0._anon_0.blue;
  alpha = BottomLeftrgba->_anon_0._anon_0.alpha;
  maVertices[1].z = v14;
  maVertices[1].rhw = v13;
  maVertices[1].s = 1.0;
  maVertices[1].t = 0.0;
  maVertices[1].x = x4;
  maVertices[1].y = y4;
  maVertices->a = alpha;
  maVertices[1].r = BottomRightrgba->_anon_0._anon_0.red;
  maVertices[1].g = BottomRightrgba->_anon_0._anon_0.green;
  maVertices[1].b = BottomRightrgba->_anon_0._anon_0.blue;
  v16 = BottomRightrgba->_anon_0._anon_0.alpha;
  maVertices[2].y = y2;
  maVertices[2].z = v14;
  maVertices[2].rhw = v13;
  maVertices[2].s = 1.0;
  maVertices[2].t = 1.0;
  maVertices[2].x = x2;
  maVertices[1].a = v16;
  maVertices[2].r = TopRightrgba->_anon_0._anon_0.red;
  maVertices[2].g = TopRightrgba->_anon_0._anon_0.green;
  maVertices[2].b = TopRightrgba->_anon_0._anon_0.blue;
  v17 = TopRightrgba->_anon_0._anon_0.alpha;
  maVertices[3].rhw = v13;
  maVertices[3].x = x1;
  maVertices[3].y = y1;
  maVertices[3].z = v14;
  maVertices[2].a = v17;
  maVertices[3].s = 0.0;
  maVertices[3].t = 1.0;
  *(CRGBA *)&maVertices[3].r = *TopLeftrgba;
}

//----- (005C86C4) --------------------------------------------------------
void __fastcall CSprite::RenderOneXLUSprite2D_Rotate_Dimension(
        float ScreenX,
        float ScreenY,
        float SizeX,
        float SizeY,
        const RwRGBA_0 *rgbaColor,
        int16 Intensity16,
        float Rotation,
        uint8 Alpha)
{
  __int16 red; // r4
  __int16 green; // r6
  float v14; // r5
  float v15; // r0
  float v16; // s8
  float v17; // s10
  float v18; // s0
  float v19; // s4
  __int16 v20; // [sp+4h] [bp-54h]
  RwImVertexIndex indices[4]; // [sp+8h] [bp-50h] BYREF
  int v22; // [sp+10h] [bp-48h]

  red = rgbaColor->_anon_0._anon_0.red;
  green = rgbaColor->_anon_0._anon_0.green;
  v20 = rgbaColor->_anon_0._anon_0.blue * Intensity16;
  v14 = cosf(Rotation);
  v15 = sinf(Rotation);
  verts[0].s = 0.0;
  verts[0].t = 0.0;
  v16 = ScreenX - (float)(v14 * SizeX);
  verts[0].a = Alpha;
  v17 = ScreenY - (float)(v14 * SizeY);
  verts[1].s = 1.0;
  verts[1].t = 0.0;
  v18 = (float)(v14 * SizeY) + ScreenY;
  verts[1].a = Alpha;
  v19 = (float)(v14 * SizeX) + ScreenX;
  verts[0].z = CSprite::m_f2DNearScreenZ;
  verts[0].rhw = CSprite::m_fRecipNearClipPlane;
  verts[1].z = CSprite::m_f2DNearScreenZ;
  verts[1].rhw = CSprite::m_fRecipNearClipPlane;
  verts[0].r = (unsigned __int16)(red * Intensity16) >> 8;
  verts[0].g = (unsigned __int16)(green * Intensity16) >> 8;
  verts[0].b = HIBYTE(v20);
  verts[1].r = (unsigned __int16)(red * Intensity16) >> 8;
  verts[1].g = (unsigned __int16)(green * Intensity16) >> 8;
  verts[1].b = HIBYTE(v20);
  verts[0].x = v16 - (float)(v15 * SizeY);
  verts[0].y = (float)(v15 * SizeX) + v17;
  verts[1].x = (float)(v15 * SizeY) + v16;
  verts[1].y = (float)(v15 * SizeX) + v18;
  verts[2].z = CSprite::m_f2DNearScreenZ;
  verts[2].rhw = CSprite::m_fRecipNearClipPlane;
  verts[2].s = 1.0;
  verts[2].t = 1.0;
  verts[2].r = (unsigned __int16)(red * Intensity16) >> 8;
  verts[2].g = (unsigned __int16)(green * Intensity16) >> 8;
  verts[2].b = HIBYTE(v20);
  verts[2].a = Alpha;
  verts[2].x = (float)(v15 * SizeY) + v19;
  verts[2].y = v18 - (float)(v15 * SizeX);
  verts[3].z = CSprite::m_f2DNearScreenZ;
  verts[3].rhw = CSprite::m_fRecipNearClipPlane;
  verts[3].s = 0.0;
  verts[3].t = 1.0;
  verts[3].r = (unsigned __int16)(red * Intensity16) >> 8;
  verts[3].g = (unsigned __int16)(green * Intensity16) >> 8;
  verts[3].b = HIBYTE(v20);
  verts[3].a = Alpha;
  verts[3].x = v19 - (float)(v15 * SizeY);
  verts[3].y = v17 - (float)(v15 * SizeX);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  v22 = 196610;
  *(_QWORD *)indices = 0x200010000LL;
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, verts, 4, indices, 6);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
}
// 0: using guessed type int dword_0;

//----- (005C8850) --------------------------------------------------------
void __fastcall CSprite2d::CSprite2d(CSprite2d *this)
{
  this->mpTexture = 0;
}

//----- (005C8856) --------------------------------------------------------
void __fastcall CSprite2d::~CSprite2d(CSprite2d *this)
{
  RwTexture_0 *mpTexture; // r0

  mpTexture = this->mpTexture;
  if ( mpTexture )
  {
    RwTextureDestroy(mpTexture);
    this->mpTexture = 0;
  }
}

//----- (005C886C) --------------------------------------------------------
void __fastcall CSprite2d::Delete(CSprite2d *this)
{
  RwTexture_0 *mpTexture; // r0

  mpTexture = this->mpTexture;
  if ( mpTexture )
  {
    RwTextureDestroy(mpTexture);
    this->mpTexture = 0;
  }
}

//----- (005C8888) --------------------------------------------------------
void __fastcall CSprite2d::SetTexture(CSprite2d *this, unsigned __int8 *pFilename)
{
  RwTexture_0 *mpTexture; // r0
  signed int v5; // r0
  RwChar *v6; // r6
  RwImage_0 *v7; // r8
  RwRaster_0 *v8; // r6
  RwTexture_0 *v9; // r6
  char *v10; // r0
  const char *v11; // r5
  size_t v12; // r0
  RwInt32 v13; // [sp+Ch] [bp-4Ch] BYREF
  RwInt32 npDepth; // [sp+10h] [bp-48h] BYREF
  RwInt32 npHeight; // [sp+14h] [bp-44h] BYREF
  RwInt32 npWidth; // [sp+18h] [bp-40h] BYREF
  RwChar v17[32]; // [sp+1Ch] [bp-3Ch] BYREF

  mpTexture = this->mpTexture;
  if ( mpTexture )
  {
    RwTextureDestroy(mpTexture);
    this->mpTexture = 0;
  }
  if ( pFilename )
  {
    v5 = strlen((const char *)pFilename);
    if ( v5 >= 4 && !strcmp((const char *)&pFilename[v5 - 3], (const char *)&off_5C897C) )
    {
      v6 = RsPathnameCreate(pFilename);
      v7 = RtPNGImageRead(v6);
      RsPathnameDestroy(v6);
      RwImageFindRasterFormat(v7, 4, &npWidth, &npHeight, &npDepth, &v13);
      v8 = RwRasterCreate(npWidth, npHeight, npDepth, v13);
      RwRasterSetFromImage(v8, v7);
      v9 = RwTextureCreate(v8);
      v10 = strrchr((const char *)pFilename, 47);
      if ( v10 )
      {
        v11 = v10 + 1;
        v12 = strlen(v10 + 1);
        strncpy((char *)v17, v11, v12 - 4);
        v17[strlen(v11) - 4] = 0;
        RwTextureSetName(v9, v17);
      }
      RwImageDestroy(v7);
      this->mpTexture = v9;
      if ( v9 )
        ++v9->refCount;
    }
    else
    {
      this->mpTexture = RwTextureRead(pFilename, 0);
    }
  }
}
// 5C897C: using guessed type void **off_5C897C;
// 5C8888: using guessed type RwChar var_3C[32];

//----- (005C8984) --------------------------------------------------------
void __fastcall CSprite2d::SetTexture(CSprite2d *this, unsigned __int8 *pFilename, unsigned __int8 *pMaskFilename)
{
  RwTexture_0 *mpTexture; // r0
  bool v7; // zf

  mpTexture = this->mpTexture;
  if ( mpTexture )
  {
    RwTextureDestroy(mpTexture);
    this->mpTexture = 0;
  }
  v7 = pFilename == 0;
  if ( pFilename )
    v7 = pMaskFilename == 0;
  if ( !v7 )
    this->mpTexture = RwTextureRead(pFilename, pMaskFilename);
}

//----- (005C89B6) --------------------------------------------------------
RwTexture_0 *__fastcall CSprite2d::SetAddressingUV(
        CSprite2d *this,
        RwTextureAddressMode_0 addressU,
        RwTextureAddressMode_0 addressV)
{
  RwTexture_0 *result; // r0

  if ( !this->mpTexture )
    return 0;
  this->mpTexture->filterAddressing = this->mpTexture->filterAddressing & 0xFFFFF0FF | ((addressU & 0xF) << 8);
  result = this->mpTexture;
  result->filterAddressing = result->filterAddressing & 0xFFFF0FFF | ((addressV & 0xF) << 12);
  return result;
}

//----- (005C89DC) --------------------------------------------------------
RwTexture_0 *__fastcall CSprite2d::SetAddressing(CSprite2d *this, RwTextureAddressMode_0 address)
{
  if ( !this->mpTexture )
    return 0;
  BYTE1(this->mpTexture->filterAddressing) = (unsigned __int16)(((_WORD)address << 12) | ((address & 0xF) << 8)) >> 8;
  return this->mpTexture;
}

//----- (005C89F8) --------------------------------------------------------
void CSprite2d::InitPerFrame()
{
  CSprite2d::nextBufferIndex = 0;
  CSprite2d::nextBufferVertex = 0;
  CSprite2d::RecipNearClip = 1.0 / Scene.camera->nearPlane;
  CSprite2d::NearScreenZ = RwIm2DGetNearScreenZ();
}

//----- (005C8A50) --------------------------------------------------------
void __fastcall CSprite2d::AddToBuffer(
        const CRect *Rectangle,
        const CRGBA *rgba,
        float tu1,
        float tv1,
        float tu2,
        float tv2,
        float tu3,
        float tv3,
        float tu4,
        float tv4)
{
  int v10; // r4
  char *v11; // lr
  float bottom; // r6
  int v13; // r5
  float v14; // r2
  float top; // r2
  float v16; // r0
  int32 v17; // r1
  int v18; // r6
  RwImVertexIndex *v19; // r0
  int32 v20; // r0
  bool v21; // cc
  int v22; // r1

  v10 = LODWORD(CSprite2d::NearScreenZ);
  v11 = (char *)&TempVertexBuffer + 28 * CSprite2d::nextBufferVertex;
  *((_DWORD *)v11 + 18432) = LODWORD(Rectangle->left);
  bottom = Rectangle->bottom;
  *(int *)((char *)&elf_hash_chain[1960] + (_DWORD)v11) = v10;
  *(float *)((char *)&elf_hash_chain[1959] + (_DWORD)v11) = bottom;
  *(float *)((char *)&elf_hash_chain[1963] + (_DWORD)v11) = tu1;
  v13 = LODWORD(CSprite2d::RecipNearClip);
  *(float *)((char *)&elf_hash_chain[1961] + (_DWORD)v11) = CSprite2d::RecipNearClip;
  *(float *)((char *)&elf_hash_chain[1964] + (_DWORD)v11) = tv1;
  *((_BYTE *)&elf_hash_chain[1962] + (_DWORD)v11) = rgba->_anon_0._anon_0.red;
  v11[73745] = rgba->_anon_0._anon_0.green;
  v11[73746] = rgba->_anon_0._anon_0.blue;
  v11[73747] = rgba->_anon_0._anon_0.alpha;
  *(int *)((char *)&elf_hash_chain[1965] + (_DWORD)v11) = LODWORD(Rectangle->right);
  v14 = Rectangle->bottom;
  *(int *)((char *)&elf_hash_chain[1967] + (_DWORD)v11) = v10;
  *(float *)((char *)&elf_hash_chain[1966] + (_DWORD)v11) = v14;
  *(int *)((char *)&elf_hash_chain[1968] + (_DWORD)v11) = v13;
  *((float *)v11 + 18444) = tu2;
  *((float *)v11 + 18445) = tv2;
  *((_BYTE *)&elf_hash_chain[1969] + (_DWORD)v11) = rgba->_anon_0._anon_0.red;
  v11[73773] = rgba->_anon_0._anon_0.green;
  v11[73774] = rgba->_anon_0._anon_0.blue;
  v11[73775] = rgba->_anon_0._anon_0.alpha;
  *(int *)((char *)&elf_hash_chain[1972] + (_DWORD)v11) = LODWORD(Rectangle->right);
  top = Rectangle->top;
  *(int *)((char *)&elf_hash_chain[1974] + (_DWORD)v11) = v10;
  *(float *)((char *)&elf_hash_chain[1973] + (_DWORD)v11) = top;
  *(int *)((char *)&elf_hash_chain[1975] + (_DWORD)v11) = v13;
  *((float *)v11 + 18451) = tu4;
  *((float *)v11 + 18452) = tv4;
  *((_BYTE *)&elf_hash_chain[1976] + (_DWORD)v11) = rgba->_anon_0._anon_0.red;
  v11[73801] = rgba->_anon_0._anon_0.green;
  v11[73802] = rgba->_anon_0._anon_0.blue;
  v11[73803] = rgba->_anon_0._anon_0.alpha;
  *(int *)((char *)&elf_hash_chain[1979] + (_DWORD)v11) = LODWORD(Rectangle->left);
  v16 = Rectangle->top;
  *(int *)((char *)&elf_hash_chain[1981] + (_DWORD)v11) = v10;
  *(float *)((char *)&elf_hash_chain[1980] + (_DWORD)v11) = v16;
  *(int *)((char *)&elf_hash_chain[1982] + (_DWORD)v11) = v13;
  *((float *)v11 + 18458) = tu3;
  *((float *)v11 + 18459) = tv3;
  *((_BYTE *)&elf_hash_chain[1983] + (_DWORD)v11) = rgba->_anon_0._anon_0.red;
  v11[73829] = rgba->_anon_0._anon_0.green;
  v11[73830] = rgba->_anon_0._anon_0.blue;
  v11[73831] = rgba->_anon_0._anon_0.alpha;
  v17 = CSprite2d::nextBufferIndex;
  v18 = CSprite2d::nextBufferVertex;
  v19 = &TempBufferRenderIndexList[CSprite2d::nextBufferIndex];
  *v19 = CSprite2d::nextBufferVertex;
  v19[1] = v18 + 1;
  v19[2] = v18 + 2;
  v19[3] = v18 + 3;
  v19[4] = v18;
  v19[5] = v18 + 2;
  CSprite2d::nextBufferVertex = v18 + 4;
  v20 = v17 + 6;
  v21 = v17 <= 4084;
  v22 = 0;
  CSprite2d::nextBufferIndex = v20;
  if ( !v21 )
    v22 = 1;
  if ( v18 >= -3 && ((v18 > 2040) | v22) == 1 )
  {
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwIm2DRenderIndexedPrimitive_BUGFIX(
      rwPRIMTYPETRILIST,
      TempVertexBuffer.m_2d,
      CSprite2d::nextBufferVertex,
      TempBufferRenderIndexList,
      CSprite2d::nextBufferIndex);
    CSprite2d::nextBufferVertex = 0;
    CSprite2d::nextBufferIndex = 0;
  }
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005C8D68) --------------------------------------------------------
void __fastcall CSprite2d::SetVertices(
        RwIm2DVertex *pVerts,
        const CRect *Rectangle,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba,
        float tu1,
        float tv1,
        float tu2,
        float tv2,
        float tu3,
        float tv3,
        float tu4,
        float tv4)
{
  float v14; // lr
  float v15; // r4

  v14 = CSprite2d::NearScreenZ;
  pVerts->x = Rectangle->left;
  pVerts->y = Rectangle->bottom;
  pVerts->z = v14;
  v15 = CSprite2d::RecipNearClip;
  pVerts->rhw = CSprite2d::RecipNearClip;
  pVerts->s = tu1;
  pVerts->t = tv1;
  *(CRGBA *)&pVerts->r = *BottomLeftrgba;
  pVerts[1].x = Rectangle->right;
  pVerts[1].y = Rectangle->bottom;
  pVerts[1].z = v14;
  pVerts[1].rhw = v15;
  pVerts[1].s = tu2;
  pVerts[1].t = tv2;
  *(CRGBA *)&pVerts[1].r = *BottomRightrgba;
  pVerts[2].x = Rectangle->right;
  pVerts[2].y = Rectangle->top;
  pVerts[2].z = v14;
  pVerts[2].rhw = v15;
  pVerts[2].s = tu4;
  pVerts[2].t = tv4;
  *(CRGBA *)&pVerts[2].r = *TopRightrgba;
  pVerts[3].x = Rectangle->left;
  pVerts[3].y = Rectangle->top;
  pVerts[3].z = v14;
  pVerts[3].rhw = CSprite2d::RecipNearClip;
  pVerts[3].s = tu3;
  pVerts[3].t = tv3;
  *(CRGBA *)&pVerts[3].r = *TopLeftrgba;
}

//----- (005C8E68) --------------------------------------------------------
bool CSprite2d::IsVertexBufferFull()
{
  return CSprite2d::nextBufferIndex > 4090 || CSprite2d::nextBufferVertex > 2044;
}

//----- (005C8EA0) --------------------------------------------------------
void CSprite2d::RenderVertexBuffer()
{
  if ( CSprite2d::nextBufferVertex >= 1 )
  {
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwIm2DRenderIndexedPrimitive_BUGFIX(
      rwPRIMTYPETRILIST,
      TempVertexBuffer.m_2d,
      CSprite2d::nextBufferVertex,
      TempBufferRenderIndexList,
      CSprite2d::nextBufferIndex);
    CSprite2d::nextBufferVertex = 0;
    CSprite2d::nextBufferIndex = 0;
  }
}
// 0: using guessed type int dword_0;

//----- (005C8F08) --------------------------------------------------------
bool CSprite2d::IsVertexBufferEmpty()
{
  return CSprite2d::nextBufferVertex == 0;
}

//----- (005C8F20) --------------------------------------------------------
void __fastcall CSprite2d::Draw(CSprite2d *this, float x, float y, float Width, float Height, const CRGBA *rgba)
{
  unsigned __int8 alpha; // r6
  unsigned __int8 v7; // r6
  unsigned __int8 v8; // r1
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *raster; // r1

  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  CSprite2d::maVertices[0].x = x;
  CSprite2d::maVertices[0].y = y;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[0].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[0].b = rgba->_anon_0._anon_0.blue;
  alpha = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[1].x = x + Width;
  CSprite2d::maVertices[0].a = alpha;
  CSprite2d::maVertices[1].y = y;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  CSprite2d::maVertices[1].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[1].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[1].b = rgba->_anon_0._anon_0.blue;
  v7 = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[2].y = y + Height;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  CSprite2d::maVertices[2].x = x;
  CSprite2d::maVertices[1].a = v7;
  CSprite2d::maVertices[2].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[2].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[2].b = rgba->_anon_0._anon_0.blue;
  v8 = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  CSprite2d::maVertices[3].x = CSprite2d::maVertices[1].x;
  CSprite2d::maVertices[3].y = y + Height;
  CSprite2d::maVertices[2].a = v8;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    raster = mpTexture->raster;
  else
    raster = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
  sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9064) --------------------------------------------------------
void __fastcall CSprite2d::SetVertices(
        const CRect *Rectangle,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba)
{
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *BottomLeftrgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *BottomRightrgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *TopLeftrgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *TopRightrgba;
}

//----- (005C915C) --------------------------------------------------------
void __fastcall CSprite2d::SetRenderState(CSprite2d *this)
{
  RwTexture_0 *mpTexture; // r0

  mpTexture = this->mpTexture;
  if ( mpTexture )
    sub_192840(rwRENDERSTATETEXTURERASTER, mpTexture->raster);
  else
    sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9170) --------------------------------------------------------
void __fastcall CSprite2d::Draw(CSprite2d *this, const CRect *Rectangle, const CRGBA *rgba)
{
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *raster; // r1

  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *rgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  *(_QWORD *)&CSprite2d::maVertices[2].s = 0x3F8020003A800000LL;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *rgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    raster = mpTexture->raster;
  else
    raster = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
  sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9280) --------------------------------------------------------
void __fastcall CSprite2d::DrawTriangle(CSprite2d *this, float *pFloats, float *pTc, const CRGBA *rgba)
{
  float v4; // r4
  float v5; // r1
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *raster; // r1

  CSprite2d::maVertices[0].x = *pFloats;
  CSprite2d::maVertices[0].y = pFloats[1];
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ + 1.0;
  CSprite2d::maVertices[0].s = *pTc;
  CSprite2d::maVertices[0].t = pTc[1];
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  CSprite2d::maVertices[1].x = pFloats[2];
  v4 = pFloats[3];
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ + 1.0;
  CSprite2d::maVertices[1].y = v4;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = pTc[2];
  CSprite2d::maVertices[1].t = pTc[3];
  *(CRGBA *)&CSprite2d::maVertices[1].r = *rgba;
  CSprite2d::maVertices[2].x = pFloats[4];
  v5 = pFloats[5];
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ + 1.0;
  CSprite2d::maVertices[2].y = v5;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = pTc[4];
  CSprite2d::maVertices[2].t = pTc[5];
  *(CRGBA *)&CSprite2d::maVertices[2].r = *rgba;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    raster = mpTexture->raster;
  else
    raster = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 3);
  sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9394) --------------------------------------------------------
void __fastcall CSprite2d::SetVertices(int32 number, float *pVert, float *pTc, const CRGBA *rgba)
{
  float *v4; // r1
  float *v5; // r12
  RwIm2DVertex *v6; // r2
  float v7; // s0
  float v8; // lr
  float v9; // r4
  float v10; // r4

  if ( number >= 1 )
  {
    v4 = pVert + 1;
    v5 = pTc + 1;
    v6 = CSprite2d::maVertices;
    v7 = CSprite2d::NearScreenZ + 1.0;
    v8 = CSprite2d::RecipNearClip;
    do
    {
      --number;
      v6->x = *(v4 - 1);
      v9 = *v4;
      v4 += 2;
      v6->z = v7;
      v6->y = v9;
      v6->rhw = v8;
      v6->s = *(v5 - 1);
      v10 = *v5;
      v5 += 2;
      v6->t = v10;
      *(CRGBA *)&v6->r = *rgba;
      ++v6;
    }
    while ( number );
  }
}

//----- (005C941C) --------------------------------------------------------
void __fastcall CSprite2d::DrawWithBilinearOffset(CSprite2d *this, const CRect *Rectangle, const CRGBA *rgba)
{
  RwRaster_0 *raster; // r12
  float v4; // s2
  float v5; // s0
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *v7; // r1

  raster = this->mpTexture->raster;
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *rgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *rgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  v4 = 1.0 / (float)((float)raster->height + (float)raster->height);
  v5 = 1.0 / (float)((float)raster->width + (float)raster->width);
  CSprite2d::maVertices[0].s = v5 + 0.00097656;
  CSprite2d::maVertices[0].t = v4 + 0.00097656;
  CSprite2d::maVertices[1].s = v5 + 1.001;
  CSprite2d::maVertices[1].t = v4 + 0.00097656;
  CSprite2d::maVertices[2].s = v5 + 0.00097656;
  CSprite2d::maVertices[2].t = v4 + 1.001;
  CSprite2d::maVertices[3].s = v5 + 1.001;
  CSprite2d::maVertices[3].t = v4 + 1.001;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    v7 = mpTexture->raster;
  else
    v7 = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, v7);
  sub_18B9D0(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
}

//----- (005C9588) --------------------------------------------------------
void __fastcall CSprite2d::OffsetTexCoordForBilinearFiltering(float xsize, float ysize)
{
  float v2; // s0
  float v3; // s2

  v2 = 1.0 / (float)(xsize + xsize);
  v3 = 1.0 / (float)(ysize + ysize);
  CSprite2d::maVertices[0].s = v2 + CSprite2d::maVertices[0].s;
  CSprite2d::maVertices[0].t = v3 + CSprite2d::maVertices[0].t;
  CSprite2d::maVertices[1].s = v2 + CSprite2d::maVertices[1].s;
  CSprite2d::maVertices[1].t = v3 + CSprite2d::maVertices[1].t;
  CSprite2d::maVertices[2].s = v2 + CSprite2d::maVertices[2].s;
  CSprite2d::maVertices[2].t = v3 + CSprite2d::maVertices[2].t;
  CSprite2d::maVertices[3].s = v2 + CSprite2d::maVertices[3].s;
  CSprite2d::maVertices[3].t = v3 + CSprite2d::maVertices[3].t;
}

//----- (005C9610) --------------------------------------------------------
void __fastcall CSprite2d::Draw(
        CSprite2d *this,
        const CRect *Rectangle,
        const CRGBA *rgba,
        float tu1,
        float tv1,
        float tu2,
        float tv2,
        float tu3,
        float tv3,
        float tu4,
        float tv4)
{
  float bottom; // r6
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *raster; // r1

  CSprite2d::maVertices[0].x = Rectangle->left;
  bottom = Rectangle->bottom;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].y = bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].s = tu1;
  CSprite2d::maVertices[0].t = tv1;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = tu2;
  CSprite2d::maVertices[1].t = tv2;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *rgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = tu3;
  CSprite2d::maVertices[2].t = tv3;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *rgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = tu4;
  CSprite2d::maVertices[3].t = tv4;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    raster = mpTexture->raster;
  else
    raster = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
  sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9754) --------------------------------------------------------
void __fastcall CSprite2d::SetVertices(
        const CRect *Rectangle,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba,
        float tu1,
        float tv1,
        float tu2,
        float tv2,
        float tu3,
        float tv3,
        float tu4,
        float tv4)
{
  float bottom; // r6

  CSprite2d::maVertices[0].x = Rectangle->left;
  bottom = Rectangle->bottom;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].y = bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].s = tu1;
  CSprite2d::maVertices[0].t = tv1;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *BottomLeftrgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = tu2;
  CSprite2d::maVertices[1].t = tv2;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *BottomRightrgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = tu3;
  CSprite2d::maVertices[2].t = tv3;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *TopLeftrgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = tu4;
  CSprite2d::maVertices[3].t = tv4;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *TopRightrgba;
}

//----- (005C9870) --------------------------------------------------------
void __fastcall CSprite2d::Draw(
        CSprite2d *this,
        const CRect *Rectangle,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba)
{
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *raster; // r1

  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *BottomLeftrgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *BottomRightrgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  *(_QWORD *)&CSprite2d::maVertices[2].s = 0x3F8020003A800000LL;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *TopLeftrgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *TopRightrgba;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    raster = mpTexture->raster;
  else
    raster = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
  sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9994) --------------------------------------------------------
CVector2D *__fastcall RotatePoint(CVector2D *retstr, float fX, float fY, float fRadians)
{
  float v8; // s20
  CVector2D *result; // r0

  v8 = sinf(fRadians);
  *(float *)&result = cosf(fRadians);
  retstr->x = (float)(*(float *)&result * fX) - (float)(v8 * fY);
  retstr->y = (float)(*(float *)&result * fY) + (float)(v8 * fX);
  return result;
}

//----- (005C99E2) --------------------------------------------------------
void __fastcall CSprite2d::DrawRotated(CSprite2d *this, CRect *rect, float fRadians, const CRGBA *rgba)
{
  float right; // s4
  float top; // s2
  float bottom; // s6
  float v9; // s0
  float v10; // s8
  float v12; // s2
  float v13; // s4
  float v14; // s20
  float v15; // s6
  float v16; // s16
  float v17; // s24
  float v18; // s26
  float v19; // s22
  float v20; // r4
  float v21; // r0
  float v22; // s4

  right = rect->right;
  top = rect->top;
  bottom = rect->bottom;
  v9 = rect->left + right;
  v10 = top - bottom;
  v12 = top + bottom;
  v13 = fabsf(right - rect->left);
  v14 = v9 * 0.5;
  v15 = fabsf(v10);
  v16 = v12 * 0.5;
  v17 = (float)(v14 - (float)(v13 * 0.5)) - v14;
  v18 = (float)(v14 + (float)(v13 * 0.5)) - v14;
  v19 = (float)((float)(v12 * 0.5) - (float)(v15 * 0.5)) - (float)(v12 * 0.5);
  v20 = cosf(fRadians);
  v21 = sinf(fRadians);
  v22 = (float)(v16 + (float)(v15 * 0.5)) - v16;
  CSprite2d::Draw(
    this,
    v14 + (float)((float)(v20 * v17) - (float)(v21 * v19)),
    v16 + (float)((float)(v21 * v17) + (float)(v20 * v19)),
    v14 + (float)((float)(v20 * v18) - (float)(v21 * v19)),
    v16 + (float)((float)(v21 * v18) + (float)(v20 * v19)),
    v14 + (float)((float)(v20 * v17) - (float)(v21 * v22)),
    v16 + (float)((float)(v21 * v17) + (float)(v20 * v22)),
    v14 + (float)((float)(v20 * v18) - (float)(v21 * v22)),
    v16 + (float)((float)(v21 * v18) + (float)(v20 * v22)),
    rgba);
}

//----- (005C9AFC) --------------------------------------------------------
void __fastcall CSprite2d::DrawRotated(
        CSprite2d *this,
        const CVector2D *vecCenter,
        float fX1,
        float fY1,
        float fX2,
        float fY2,
        float fX3,
        float fY3,
        float fX4,
        float fY4,
        float fRadians,
        const CRGBA *rgba)
{
  float x; // s16
  float y; // s18
  float v15; // s20
  float v16; // s22
  float v17; // s24
  float v18; // r0

  x = vecCenter->x;
  y = vecCenter->y;
  v15 = fX1 - vecCenter->x;
  v16 = fY1 - y;
  v17 = sinf(fRadians);
  v18 = cosf(fRadians);
  CSprite2d::Draw(
    this,
    x + (float)((float)(v15 * v18) - (float)(v16 * v17)),
    y + (float)((float)(v18 * v16) + (float)(v15 * v17)),
    x + (float)((float)((float)(fX2 - x) * v18) - (float)((float)(fY2 - y) * v17)),
    y + (float)((float)(v18 * (float)(fY2 - y)) + (float)((float)(fX2 - x) * v17)),
    x + (float)((float)((float)(fX3 - x) * v18) - (float)((float)(fY3 - y) * v17)),
    y + (float)((float)(v18 * (float)(fY3 - y)) + (float)((float)(fX3 - x) * v17)),
    x + (float)((float)((float)(fX4 - x) * v18) - (float)((float)(fY4 - y) * v17)),
    y + (float)((float)(v18 * (float)(fY4 - y)) + (float)((float)(fX4 - x) * v17)),
    rgba);
}

//----- (005C9C18) --------------------------------------------------------
void __fastcall CSprite2d::Draw(
        CSprite2d *this,
        float x1,
        float y1,
        float x2,
        float y2,
        float x3,
        float y3,
        float x4,
        float y4,
        const CRGBA *rgba)
{
  unsigned __int8 alpha; // r6
  unsigned __int8 v11; // r6
  unsigned __int8 v12; // r1
  RwTexture_0 *mpTexture; // r0
  RwRaster_0 *raster; // r1

  CSprite2d::maVertices[0].x = x3;
  CSprite2d::maVertices[0].y = y3;
  CSprite2d::maVertices[0].s = 0.0;
  CSprite2d::maVertices[0].t = 0.0;
  *(_QWORD *)&CSprite2d::maVertices[0].z = __PAIR64__(
                                             LODWORD(CSprite2d::RecipNearClip),
                                             LODWORD(CSprite2d::NearScreenZ));
  CSprite2d::maVertices[0].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[0].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[0].b = rgba->_anon_0._anon_0.blue;
  alpha = rgba->_anon_0._anon_0.alpha;
  *(_QWORD *)&CSprite2d::maVertices[1].z = __PAIR64__(
                                             LODWORD(CSprite2d::RecipNearClip),
                                             LODWORD(CSprite2d::NearScreenZ));
  *(_QWORD *)&CSprite2d::maVertices[1].s = 1065353216LL;
  CSprite2d::maVertices[1].x = x4;
  CSprite2d::maVertices[1].y = y4;
  CSprite2d::maVertices[0].a = alpha;
  CSprite2d::maVertices[1].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[1].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[1].b = rgba->_anon_0._anon_0.blue;
  v11 = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[2].s = 0.0;
  CSprite2d::maVertices[2].t = 1.0;
  CSprite2d::maVertices[2].x = x1;
  CSprite2d::maVertices[2].y = y1;
  *(_QWORD *)&CSprite2d::maVertices[2].z = __PAIR64__(
                                             LODWORD(CSprite2d::RecipNearClip),
                                             LODWORD(CSprite2d::NearScreenZ));
  CSprite2d::maVertices[1].a = v11;
  CSprite2d::maVertices[2].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[2].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[2].b = rgba->_anon_0._anon_0.blue;
  v12 = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[3].y = y2;
  *(_QWORD *)&CSprite2d::maVertices[3].z = __PAIR64__(
                                             LODWORD(CSprite2d::RecipNearClip),
                                             LODWORD(CSprite2d::NearScreenZ));
  CSprite2d::maVertices[3].s = 1.0;
  CSprite2d::maVertices[3].t = 1.0;
  CSprite2d::maVertices[3].x = x2;
  CSprite2d::maVertices[2].a = v12;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  mpTexture = this->mpTexture;
  if ( mpTexture )
    raster = mpTexture->raster;
  else
    raster = 0;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, raster);
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
  sub_192840(rwRENDERSTATETEXTURERASTER, 0);
}

//----- (005C9D54) --------------------------------------------------------
void __fastcall CSprite2d::SetVertices(
        float x1,
        float y1,
        float x2,
        float y2,
        float x3,
        float y3,
        float x4,
        float y4,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba)
{
  unsigned __int8 alpha; // r5
  unsigned __int8 v13; // r5
  unsigned __int8 v14; // r0

  CSprite2d::maVertices[0].x = x3;
  CSprite2d::maVertices[0].y = y3;
  CSprite2d::maVertices[0].s = 0.0;
  CSprite2d::maVertices[0].t = 0.0;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].r = BottomLeftrgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[0].g = BottomLeftrgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[0].b = BottomLeftrgba->_anon_0._anon_0.blue;
  alpha = BottomLeftrgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.0;
  CSprite2d::maVertices[1].t = 0.0;
  CSprite2d::maVertices[1].x = x4;
  CSprite2d::maVertices[1].y = y4;
  CSprite2d::maVertices[0].a = alpha;
  CSprite2d::maVertices[1].r = BottomRightrgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[1].g = BottomRightrgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[1].b = BottomRightrgba->_anon_0._anon_0.blue;
  v13 = BottomRightrgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  *(_QWORD *)&CSprite2d::maVertices[2].s = 0x3F80000000000000LL;
  CSprite2d::maVertices[2].x = x1;
  CSprite2d::maVertices[2].y = y1;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].a = v13;
  CSprite2d::maVertices[2].r = TopLeftrgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[2].g = TopLeftrgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[2].b = TopLeftrgba->_anon_0._anon_0.blue;
  v14 = TopLeftrgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.0;
  CSprite2d::maVertices[3].t = 1.0;
  CSprite2d::maVertices[3].x = x2;
  CSprite2d::maVertices[3].y = y2;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].a = v14;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *TopRightrgba;
}

//----- (005C9E48) --------------------------------------------------------
void __fastcall CSprite2d::Draw2DPolygon(
        float x1,
        float y1,
        float x2,
        float y2,
        float x3,
        float y3,
        float x4,
        float y4,
        const CRGBA *rgba)
{
  unsigned __int8 alpha; // r6
  unsigned __int8 v10; // r6
  unsigned __int8 v11; // r0

  CSprite2d::maVertices[0].x = x3;
  CSprite2d::maVertices[0].y = y3;
  CSprite2d::maVertices[0].s = 0.0;
  CSprite2d::maVertices[0].t = 0.0;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[0].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[0].b = rgba->_anon_0._anon_0.blue;
  alpha = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.0;
  CSprite2d::maVertices[1].t = 0.0;
  CSprite2d::maVertices[1].x = x4;
  CSprite2d::maVertices[1].y = y4;
  CSprite2d::maVertices[0].a = alpha;
  CSprite2d::maVertices[1].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[1].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[1].b = rgba->_anon_0._anon_0.blue;
  v10 = rgba->_anon_0._anon_0.alpha;
  *(_QWORD *)&CSprite2d::maVertices[2].s = 0x3F80000000000000LL;
  CSprite2d::maVertices[2].x = x1;
  CSprite2d::maVertices[2].y = y1;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].a = v10;
  CSprite2d::maVertices[2].r = rgba->_anon_0._anon_0.red;
  CSprite2d::maVertices[2].g = rgba->_anon_0._anon_0.green;
  CSprite2d::maVertices[2].b = rgba->_anon_0._anon_0.blue;
  v11 = rgba->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[3].s = 1.0;
  CSprite2d::maVertices[3].t = 1.0;
  CSprite2d::maVertices[3].x = x2;
  CSprite2d::maVertices[3].y = y2;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].a = v11;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void *)(rgba->_anon_0._anon_0.alpha != 255));
  sub_18B9D0(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
}
// 0: using guessed type int dword_0;

//----- (005C9F60) --------------------------------------------------------
void __fastcall CSprite2d::DrawBarChart(
        float x,
        float y,
        unsigned int w,
        unsigned int h,
        float value,
        int increase,
        int legend,
        int border,
        CRGBA c,
        CRGBA c2)
{
  float32x2_t v10; // d0
  float32x2_t v11; // d1
  float32x2_t v12; // d2
  float32x2_t v13; // d11
  float32x2_t v14; // d12
  float v19; // s26
  float v20; // s28
  float v21; // s30
  float v22; // s30
  CRGBA v23; // r0
  unsigned int v24; // r4
  CRGBA v25; // [sp+8h] [bp-80h] BYREF
  CRect Rectangle; // [sp+Ch] [bp-7Ch] BYREF
  CRGBA v27; // [sp+20h] [bp-68h] BYREF

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
  v11.n64_u32[0] = 0;
  v12.n64_f32[0] = value;
  v19 = vmax_f32(v12, v11).n64_f32[0];
  Rectangle.bottom = y;
  Rectangle.left = x;
  v14.n64_f32[0] = (float)w + x;
  v20 = (float)h + y;
  v13.n64_f32[0] = (float)((float)(v19 / 100.0) * (float)w) + x;
  Rectangle.top = v20;
  LODWORD(v21) = vmin_f32(v13, v14).n64_u32[0];
  Rectangle.right = v21;
  CSprite2d::DrawRect(&Rectangle, *(const CRGBA **)&c);
  Rectangle.bottom = y;
  Rectangle.left = v21;
  Rectangle.right = v14.n64_f32[0];
  Rectangle.top = v20;
  CRGBA::CRGBA(
    &v27,
    *(_BYTE *)c._anon_0._anon_0.red >> 1,
    *(_BYTE *)(*(_DWORD *)&c + 1) >> 1,
    *(_BYTE *)(*(_DWORD *)&c + 2) >> 1,
    *(_BYTE *)(*(_DWORD *)&c + 3));
  CSprite2d::DrawRect(&Rectangle, &v27);
  if ( increase )
  {
    Rectangle.bottom = y;
    Rectangle.right = v21;
    v10.n64_f32[0] = x + -1.0;
    v11.n64_f32[0] = v21 - (float)increase;
    v10.n64_u64[0] = vmax_f32(v11, v10).n64_u64[0];
    *(_QWORD *)&Rectangle.left = __PAIR64__(LODWORD(v20), v10.n64_u32[0]);
    CRGBA::CRGBA(
      &v27,
      *(_BYTE *)c2._anon_0._anon_0.red,
      *(_BYTE *)(*(_DWORD *)&c2 + 1),
      *(_BYTE *)(*(_DWORD *)&c2 + 2),
      *(_BYTE *)(*(_DWORD *)&c + 3));
    CSprite2d::DrawRect(&Rectangle, &v27);
  }
  if ( border )
  {
    Rectangle.bottom = y;
    Rectangle.left = x;
    Rectangle.right = (float)w + x;
    v10.n64_f32[0] = (float)RsGlobal.screenHeight / 448.0;
    v11.n64_u32[0] = 1.0;
    v22 = vmax_f32(v10, v11).n64_f32[0];
    Rectangle.top = v22 + y;
    CRGBA::CRGBA(&v27, 0, 0, 0, *(_BYTE *)(*(_DWORD *)&c + 3));
    CSprite2d::DrawRect(&Rectangle, &v27);
    Rectangle.bottom = (float)h + y;
    Rectangle.left = x;
    Rectangle.right = (float)w + x;
    Rectangle.top = v20 - v22;
    CRGBA::CRGBA(&v27, 0, 0, 0, *(_BYTE *)(*(_DWORD *)&c + 3));
    CSprite2d::DrawRect(&Rectangle, &v27);
    Rectangle.bottom = y;
    Rectangle.left = x;
    Rectangle.right = v22 + x;
    Rectangle.top = (float)h + y;
    CRGBA::CRGBA(&v27, 0, 0, 0, *(_BYTE *)(*(_DWORD *)&c + 3));
    CSprite2d::DrawRect(&Rectangle, &v27);
    Rectangle.bottom = y;
    Rectangle.left = (float)w + x;
    Rectangle.right = v14.n64_f32[0] - v22;
    Rectangle.top = (float)h + y;
    CRGBA::CRGBA(&v27, 0, 0, 0, *(_BYTE *)(*(_DWORD *)&c + 3));
    CSprite2d::DrawRect(&Rectangle, &v27);
  }
  if ( legend )
  {
    sprintf((unsigned __int8 *)&v27, "%d%%", (int)v19);
    AsciiToGxtChar((const Char *)&v27, (GxtChar *)&Rectangle);
    CFont::SetWrapx(x);
    CFont::SetRightJustifyWrap(v14.n64_f32[0]);
    CRGBA::CRGBA(&v25, 0, 0, 0, *(_BYTE *)(*(_DWORD *)&c + 3));
    CFont::SetColor(v23);
    CFont::SetEdge(0);
    CFont::SetFontStyle(1u);
    CFont::SetScale((float)h * 0.04);
    v24 = (unsigned int)v13.n64_f32[0];
    if ( (float)(x + 50.0) <= (float)(unsigned int)v13.n64_f32[0] )
    {
      CFont::SetOrientation(2u);
    }
    else
    {
      CFont::SetOrientation(1u);
      LOWORD(v24) = v24 + 5;
    }
    CFont::PrintString((float)(unsigned __int16)v24, y + 2.0, (GxtChar *)&Rectangle);
  }
}
// 5C9FA6: variable 'v12' is possibly undefined
// 5C9FA6: variable 'v11' is possibly undefined
// 5C9FDC: variable 'v13' is possibly undefined
// 5C9FDC: variable 'v14' is possibly undefined
// 5CA040: variable 'v10' is possibly undefined
// 5CA17E: variable 'v23' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005CA234) --------------------------------------------------------
void __fastcall CSprite2d::DrawRect(const CRect *Rectangle, const CRGBA *rgba)
{
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *rgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *rgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void *)(rgba->_anon_0._anon_0.alpha != 255));
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
  sub_192840(rwRENDERSTATEVERTEXALPHAENABLE, 0);
}

//----- (005CA33C) --------------------------------------------------------
void __fastcall CSprite2d::SetVertices(int32 number, float *pVert, CRGBA *pRGBA)
{
  float *v3; // r1
  RwUInt8 *p_green; // r2
  float v5; // r12
  RwIm2DVertex *v6; // r3
  float v7; // lr
  float v8; // r5

  if ( number >= 1 )
  {
    v3 = pVert + 1;
    p_green = &pRGBA->_anon_0._anon_0.green;
    v5 = CSprite2d::NearScreenZ;
    v6 = CSprite2d::maVertices;
    v7 = CSprite2d::RecipNearClip;
    do
    {
      --number;
      v6->x = *(v3 - 1);
      v8 = *v3;
      v3 += 2;
      v6->z = v5;
      v6->y = v8;
      v6->rhw = v7;
      v6->s = 1.0;
      v6->t = 1.0;
      v6->r = *(p_green - 1);
      v6->g = *p_green;
      v6->b = p_green[1];
      LOBYTE(v8) = p_green[2];
      p_green += 4;
      v6->a = LOBYTE(v8);
      ++v6;
    }
    while ( number );
  }
}

//----- (005CA3B4) --------------------------------------------------------
void __fastcall CSprite2d::SetMaskVertices(int32 number, float *pVert, float z)
{
  float *v4; // r1
  float v5; // lr
  float *p_z; // r3
  int v7; // r2

  if ( number >= 1 )
  {
    v4 = pVert + 1;
    v5 = CSprite2d::RecipNearClip;
    p_z = &CSprite2d::maVertices[0].z;
    do
    {
      --number;
      *(p_z - 2) = *(v4 - 1);
      v7 = *(_DWORD *)v4;
      v4 += 2;
      *p_z = z;
      *((_DWORD *)p_z - 1) = v7;
      p_z[1] = v5;
      p_z[2] = 0.0;
      p_z += 7;
    }
    while ( number );
  }
}

//----- (005CA408) --------------------------------------------------------
void __fastcall CSprite2d::DrawTxRect(const CRect *Rectangle, const CRGBA *rgba)
{
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *rgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *rgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *rgba;
  sub_18B9D0(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
}

//----- (005CA4E8) --------------------------------------------------------
void __fastcall CSprite2d::DrawRect(
        const CRect *Rectangle,
        const CRGBA *topleftrgba,
        const CRGBA *toprightrgba,
        const CRGBA *bottomleftrgba,
        const CRGBA *bottomrightrgba)
{
  int v9; // r0
  bool v10; // zf
  char *v11; // r1

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *bottomleftrgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *bottomrightrgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *topleftrgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *toprightrgba;
  v9 = (unsigned __int8)(topleftrgba->_anon_0._anon_0.alpha & toprightrgba->_anon_0._anon_0.alpha);
  v10 = v9 == 255;
  if ( v9 == 255 )
    v10 = (unsigned __int8)(bottomleftrgba->_anon_0._anon_0.alpha & bottomrightrgba->_anon_0._anon_0.alpha) == 255;
  if ( v10 )
    v11 = 0;
  else
    v11 = (char *)&dword_0 + 1;
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, v11);
  sub_18B9D0(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
}
// 0: using guessed type int dword_0;

//----- (005CA620) --------------------------------------------------------
void __fastcall CSprite2d::DrawRectXLU(
        const CRect *Rectangle,
        const CRGBA *topleftrgba,
        const CRGBA *toprightrgba,
        const CRGBA *bottomleftrgba,
        const CRGBA *bottomrightrgba)
{
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = Rectangle->bottom;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.00097656;
  CSprite2d::maVertices[0].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *bottomleftrgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  CSprite2d::maVertices[1].y = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.001;
  CSprite2d::maVertices[1].t = 0.00097656;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *bottomrightrgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  CSprite2d::maVertices[2].y = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.00097656;
  CSprite2d::maVertices[2].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *topleftrgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  CSprite2d::maVertices[3].y = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.001;
  CSprite2d::maVertices[3].t = 1.001;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *toprightrgba;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  sub_18B9D0(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005CA734) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CSprite2d::DrawAnyRect(
        float X1,
        float Y1,
        float X2,
        float Y2,
        float X3,
        float Y3,
        float X4,
        float Y4,
        const CRGBA *RGBA1,
        const CRGBA *RGBA2,
        const CRGBA *RGBA3,
        const CRGBA *RGBA4)
{
  unsigned __int8 alpha; // r10
  unsigned __int8 v13; // r5
  unsigned __int8 v14; // r1
  int v15; // r0
  bool v16; // zf
  char *v17; // r1

  CSprite2d::maVertices[0].x = X3;
  CSprite2d::maVertices[0].y = Y3;
  CSprite2d::maVertices[0].s = 0.0;
  CSprite2d::maVertices[0].t = 0.0;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].r = RGBA3->_anon_0._anon_0.red;
  CSprite2d::maVertices[0].g = RGBA3->_anon_0._anon_0.green;
  CSprite2d::maVertices[0].b = RGBA3->_anon_0._anon_0.blue;
  alpha = RGBA3->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  *(_QWORD *)&CSprite2d::maVertices[1].s = 1065353216LL;
  CSprite2d::maVertices[1].x = X4;
  CSprite2d::maVertices[1].y = Y4;
  CSprite2d::maVertices[0].a = alpha;
  CSprite2d::maVertices[1].r = RGBA4->_anon_0._anon_0.red;
  CSprite2d::maVertices[1].g = RGBA4->_anon_0._anon_0.green;
  CSprite2d::maVertices[1].b = RGBA4->_anon_0._anon_0.blue;
  v13 = RGBA4->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[2].s = 0.0;
  *(_QWORD *)&CSprite2d::maVertices[2].x = *(_QWORD *)&X1;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].t = 1.0;
  CSprite2d::maVertices[1].a = v13;
  CSprite2d::maVertices[2].r = RGBA1->_anon_0._anon_0.red;
  CSprite2d::maVertices[2].g = RGBA1->_anon_0._anon_0.green;
  CSprite2d::maVertices[2].b = RGBA1->_anon_0._anon_0.blue;
  v14 = RGBA1->_anon_0._anon_0.alpha;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.0;
  CSprite2d::maVertices[3].t = 1.0;
  *(_QWORD *)&CSprite2d::maVertices[3].x = *(_QWORD *)&X2;
  CSprite2d::maVertices[2].a = v14;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *RGBA2;
  v15 = (unsigned __int8)(RGBA1->_anon_0._anon_0.alpha & RGBA2->_anon_0._anon_0.alpha);
  v16 = v15 == 255;
  if ( v15 == 255 )
    v16 = (unsigned __int8)(RGBA3->_anon_0._anon_0.alpha & RGBA4->_anon_0._anon_0.alpha) == 255;
  if ( v16 )
    v17 = 0;
  else
    v17 = (char *)&dword_0 + 1;
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, v17);
  sub_18B9D0(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
}
// 5CA734: variables would overlap: r0.4 and r0.8
// 5CA734: variables would overlap: r2.4 and r2.8
// 0: using guessed type int dword_0;

//----- (005CA874) --------------------------------------------------------
void __fastcall CSprite2d::DrawCircleAtNearClip(
        const CVector2D *CenterOfCircle,
        float Radius,
        const CRGBA *rgba,
        int NumOfSectionsToCircle)
{
  float v8; // s16
  float v9; // s18
  int v10; // r8
  float v11; // s0
  float v12; // s2
  float v13; // s0
  float v14; // s4
  float y; // s8
  float v16; // s2
  unsigned int v17; // s6
  float v18; // s0
  float v19; // s2
  float v20; // s6

  CSprite2d::maVertices[0].x = CenterOfCircle->x;
  CSprite2d::maVertices[0].y = CenterOfCircle->y;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ;
  CSprite2d::maVertices[0].s = 0.5;
  CSprite2d::maVertices[0].t = 0.5;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *rgba;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  v8 = (float)(360 / NumOfSectionsToCircle);
  if ( NumOfSectionsToCircle >= 1 )
  {
    v9 = Radius;
    v10 = 0;
    do
    {
      v11 = (float)((float)(v8 * (float)v10) * 3.1416) / 180.0;
      v12 = (float)(v11 * 256.0) / 6.2832;
      v13 = (float)((float)((float)((float)(v8 * 3.1416) / 180.0) + v11) * 256.0) / 6.2832;
      v14 = CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)(v12 + 64.0)];
      CSprite2d::maVertices[1].x = CenterOfCircle->x + (float)(v14 * v9);
      y = CenterOfCircle->y;
      v16 = CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v12];
      CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ;
      CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
      CSprite2d::maVertices[1].y = y + (float)(v16 * v9);
      CSprite2d::maVertices[1].r = rgba->_anon_0._anon_0.red;
      CSprite2d::maVertices[1].g = rgba->_anon_0._anon_0.green;
      v17 = (unsigned int)v13;
      CSprite2d::maVertices[1].b = rgba->_anon_0._anon_0.blue;
      CSprite2d::maVertices[1].a = rgba->_anon_0._anon_0.alpha;
      CSprite2d::maVertices[1].s = (float)(v14 + 1.0) * 0.5;
      CSprite2d::maVertices[1].t = (float)(v16 + 1.0) * 0.5;
      v18 = CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)(v13 + 64.0)];
      CSprite2d::maVertices[2].x = CenterOfCircle->x + (float)(v18 * v9);
      v19 = CMaths::ms_SinTable[(unsigned __int8)v17];
      v20 = CenterOfCircle->y;
      CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ;
      CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
      CSprite2d::maVertices[2].y = v20 + (float)(v19 * v9);
      CSprite2d::maVertices[2].r = rgba->_anon_0._anon_0.red;
      CSprite2d::maVertices[2].g = rgba->_anon_0._anon_0.green;
      CSprite2d::maVertices[2].b = rgba->_anon_0._anon_0.blue;
      CSprite2d::maVertices[2].a = rgba->_anon_0._anon_0.alpha;
      CSprite2d::maVertices[2].s = (float)(v18 + 1.0) * 0.5;
      CSprite2d::maVertices[2].t = (float)(v19 + 1.0) * 0.5;
      RwIm2DRenderTriangle(CSprite2d::maVertices, 3, 2, 1, 0);
      ++v10;
    }
    while ( NumOfSectionsToCircle != v10 );
  }
}
// 0: using guessed type int dword_0;
// 2C: using guessed type __int16 word_2C;
// 2E: using guessed type __int16 word_2E;
// 48: using guessed type int dword_48;

//----- (005CAABC) --------------------------------------------------------
void __fastcall CSprite2d::SetVerticesForSniper(
        const CRect *Rectangle,
        const CRGBA *TopLeftrgba,
        const CRGBA *TopRightrgba,
        const CRGBA *BottomLeftrgba,
        const CRGBA *BottomRightrgba)
{
  float bottom; // r6
  float v6; // r3
  float top; // r5
  float v8; // r0

  bottom = Rectangle->bottom;
  CSprite2d::maVertices[0].x = Rectangle->left;
  CSprite2d::maVertices[0].y = bottom;
  CSprite2d::maVertices[0].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[0].s = 0.0;
  CSprite2d::maVertices[0].t = 0.0;
  CSprite2d::maVertices[0].z = CSprite2d::NearScreenZ + 0.000001;
  *(CRGBA *)&CSprite2d::maVertices[0].r = *BottomLeftrgba;
  CSprite2d::maVertices[1].x = Rectangle->right;
  v6 = Rectangle->bottom;
  CSprite2d::maVertices[1].z = CSprite2d::NearScreenZ + 0.000001;
  CSprite2d::maVertices[1].y = v6;
  CSprite2d::maVertices[1].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[1].s = 1.0;
  CSprite2d::maVertices[1].t = 0.0;
  *(CRGBA *)&CSprite2d::maVertices[1].r = *BottomRightrgba;
  CSprite2d::maVertices[2].x = Rectangle->left;
  top = Rectangle->top;
  CSprite2d::maVertices[2].z = CSprite2d::NearScreenZ + 0.000001;
  CSprite2d::maVertices[2].y = top;
  CSprite2d::maVertices[2].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[2].s = 0.0;
  CSprite2d::maVertices[2].t = 1.0;
  *(CRGBA *)&CSprite2d::maVertices[2].r = *TopLeftrgba;
  CSprite2d::maVertices[3].x = Rectangle->right;
  v8 = Rectangle->top;
  CSprite2d::maVertices[3].z = CSprite2d::NearScreenZ + 0.000001;
  CSprite2d::maVertices[3].y = v8;
  CSprite2d::maVertices[3].rhw = CSprite2d::RecipNearClip;
  CSprite2d::maVertices[3].s = 1.0;
  CSprite2d::maVertices[3].t = 1.0;
  *(CRGBA *)&CSprite2d::maVertices[3].r = *TopRightrgba;
}

//----- (005CABD0) --------------------------------------------------------
void __fastcall CWaterCannon::Init(CWaterCannon *this)
{
  UInt32 v2; // r0

  this->PointClosestToOrigin = 0;
  this->ID = 0;
  v2 = CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)&this->aPointsUsed[16] = 0LL;
  *(_QWORD *)&this->aPointsUsed[24] = 0LL;
  *(_QWORD *)this->aPointsUsed = 0LL;
  *(_QWORD *)&this->aPointsUsed[8] = 0LL;
  this->LastTimeElementStored = v2;
  *(_DWORD *)&WaterCannonIndexList[16] = 655371;
  *(_QWORD *)WaterCannonIndexList = 0x1000200010000LL;
  *(_QWORD *)&WaterCannonIndexList[4] = 0x5000400020003LL;
  *(_QWORD *)&WaterCannonIndexList[8] = 0x6000700050006LL;
  *(_QWORD *)&WaterCannonIndexList[12] = 0x9000A00090008LL;
  j_CAEWaterCannonAudioEntity::Initialise(&this->m_AEWaterCannonAudioEntity, this);
}

//----- (005CAC48) --------------------------------------------------------
void __fastcall CWaterCannon::Update_OncePerFrame(CWaterCannon *this, Int16 StreamNumber)
{
  int v3; // r8
  int v4; // r0
  int v5; // r1
  float v6; // s0
  int v7; // r0
  float v8; // s2
  float *v9; // r2
  float v10; // s8
  float v11; // s4
  float x; // s10
  float v13; // s6
  float y; // s12
  float z; // s14
  int v16; // r5
  int v17; // r6
  int v18; // r0

  v3 = StreamNumber;
  if ( CTimer::m_snTimeInMilliseconds > this->LastTimeElementStored + 150 )
  {
    v4 = (this->PointClosestToOrigin + 1) % 32;
    this->PointClosestToOrigin = v4;
    this->aPointsUsed[v4] = 0;
  }
  v5 = 780;
  v6 = CTimer::ms_fTimeStep;
  v7 = 0;
  v8 = CTimer::ms_fTimeStep * 0.004;
  do
  {
    if ( *((_BYTE *)&this->ID + v5) )
    {
      v9 = (float *)((char *)&this->ID + v7 * 12);
      v10 = this->aSpeed[v7].z - v8;
      v11 = v6 * this->aSpeed[v7].x;
      x = this->aPoints[v7].x;
      v13 = v6 * this->aSpeed[v7].y;
      y = this->aPoints[v7].y;
      z = this->aPoints[v7].z;
      v9[101] = v10;
      v9[3] = v11 + x;
      v9[4] = v13 + y;
      v9[5] = (float)(v6 * v10) + z;
    }
    ++v7;
    ++v5;
  }
  while ( v7 != 32 );
  v16 = 0;
  v17 = 780;
  do
  {
    if ( *((_BYTE *)&this->ID + v17) )
      CFireManager::ExtinguishPointWithWater(&gFireManager, this->aPoints[v16], 2.0, 0.5);
    ++v16;
    ++v17;
  }
  while ( v16 != 32 );
  if ( !((CTimer::m_FrameCounter + v3) << 30) )
    CWaterCannon::PushPeds(this);
  LOWORD(v18) = 0;
  while ( !this->aPointsUsed[(__int16)v18] )
  {
    v18 = (__int16)(v18 + 1);
    if ( v18 > 31 )
    {
      this->ID = 0;
      return;
    }
  }
}

//----- (005CAD6C) --------------------------------------------------------
void __fastcall CWaterCannon::PushPeds(CWaterCannon *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d8
  float32x2_t v5; // d9
  int v7; // r0
  float32x2_t v8; // d11
  int v9; // r1
  float32x2_t v10; // d10
  float32x2_t v11; // d12
  float32x2_t v12; // d13
  CPedPool *v13; // r9
  int32 m_nSize; // r10
  CEventHitByWaterCannon *v15; // r0
  int v16; // r5
  bool v17; // zf
  int v18; // r1
  _DWORD *v19; // r11
  float *v20; // r2
  float v21; // s0
  float v22; // s0
  int v23; // r6
  int v24; // r1
  char *v25; // r8
  int v26; // r3
  float32x2_t v27; // d16
  unsigned __int64 v28; // d1
  float v30; // s4
  float v31; // s2
  float v32; // s4
  float v33; // s2
  int v34; // r1
  __int64 v35; // d16
  RwReal v36; // s2
  RwReal v37; // s4
  float v38; // s2
  float v39; // s4
  float *v40; // [sp+20h] [bp-D8h]
  float *v41; // [sp+24h] [bp-D4h]
  float *v42; // [sp+28h] [bp-D0h]
  FxPrtMult_c v43; // [sp+34h] [bp-C4h] BYREF
  RwV3d_0 v44; // [sp+50h] [bp-A8h] BYREF
  RwV3d_0 vel; // [sp+5Ch] [bp-9Ch] BYREF
  RwV3d_0 pos; // [sp+68h] [bp-90h] BYREF
  CEventHitByWaterCannon v47; // [sp+74h] [bp-84h] BYREF
  CVector v48; // 0:r1.12

  v4.n64_u32[0] = -971227136;
  v5.n64_u32[0] = 1176256512;
  v7 = 780;
  v8.n64_u64[0] = v4.n64_u64[0];
  v9 = 0;
  v10.n64_u64[0] = v5.n64_u64[0];
  v11.n64_u64[0] = v5.n64_u64[0];
  v12.n64_u64[0] = v4.n64_u64[0];
  do
  {
    if ( *((_BYTE *)&this->ID + v7) )
    {
      v1.n64_u32[0] = LODWORD(this->aPoints[v9].x);
      v2.n64_u32[0] = LODWORD(this->aPoints[v9].y);
      v3.n64_u32[0] = LODWORD(this->aPoints[v9].z);
      v4.n64_u64[0] = vmax_f32(v4, v1).n64_u64[0];
      v12.n64_u64[0] = vmax_f32(v12, v2).n64_u64[0];
      v8.n64_u64[0] = vmax_f32(v8, v3).n64_u64[0];
      v11.n64_u64[0] = vmin_f32(v11, v3).n64_u64[0];
      v10.n64_u64[0] = vmin_f32(v10, v2).n64_u64[0];
      v5.n64_u64[0] = vmin_f32(v5, v1).n64_u64[0];
    }
    ++v7;
    ++v9;
  }
  while ( v7 != 812 );
  v13 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v15 = &v47;
    do
    {
      while ( 1 )
      {
        if ( (v13->m_aFlags[--m_nSize] & 0x80u) == 0 )
        {
          v16 = (int)v13->m_aStorage[m_nSize];
          v17 = v16 == 0;
          if ( v16 )
            v17 = *(unsigned __int8 *)(v16 + 28) << 31 == 0;
          if ( !v17 )
          {
            v19 = (_DWORD *)(v16 + 20);
            v18 = *(_DWORD *)(v16 + 20);
            v20 = (float *)(v16 + 4);
            if ( v18 )
              v20 = (float *)(v18 + 48);
            if ( *v20 > v5.n64_f32[0] && *v20 < v4.n64_f32[0] )
            {
              v21 = v20[1];
              if ( v21 > v10.n64_f32[0] && v21 < v12.n64_f32[0] )
              {
                v22 = v20[2];
                if ( v22 > v11.n64_f32[0] && v22 < v8.n64_f32[0] )
                  break;
              }
            }
          }
        }
LABEL_12:
        if ( !m_nSize )
          return;
      }
      v42 = (float *)(v16 + 80);
      v40 = (float *)(v16 + 76);
      v41 = (float *)(v16 + 72);
      v23 = 0;
      v24 = 0;
      while ( 1 )
      {
        if ( this->aPointsUsed[v24] )
        {
          v25 = (char *)this + v23 * 12;
          v26 = v16 + 4;
          if ( *v19 )
            v26 = *v19 + 48;
          v27.n64_u64[0] = vsub_f32(*((float32x2_t *)v25 + 2), *(float32x2_t *)(v26 + 4)).n64_u64[0];
          v28 = vmul_f32(v27, v27).n64_u64[0];
          if ( (float)((float)((float)((float)(this->aPoints[v23].x - *(float *)v26)
                                     * (float)(this->aPoints[v23].x - *(float *)v26))
                             + *(float *)&v28)
                     + *((float *)&v28 + 1)) < 5.0 )
            break;
        }
        ++v23;
        if ( v24++ >= 31 )
          goto LABEL_12;
      }
      CEventHitByWaterCannon::CEventHitByWaterCannon(v15, (const CVector *)v25 + 1, (const CVector *)v25 + 33);
      CEventGroup::Add((CEventGroup *)(*(_DWORD *)(v16 + 1088) + 104), &v47, 0);
      v48.y = 0.0;
      *(_DWORD *)(v16 + 1156) &= 0xFFFFFFFC;
      v48.z = CTimer::ms_fTimeStep;
      v48.x = 0.0;
      CPhysical::ApplyMoveForce((CPhysical *)v16, v48);
      v30 = *((float *)v25 + 99);
      v31 = (float)((float)(v30 * 0.1) - *v41) * 0.1;
      if ( (float)(v30 * v31) > 0.0 )
        *v41 = *v41 + v31;
      v32 = *((float *)v25 + 100);
      v33 = (float)((float)(v32 * 0.1) - *v40) * 0.1;
      if ( (float)(v32 * v33) > 0.0 )
        *v40 = *v40 + v33;
      v34 = v16 + 4;
      if ( *v19 )
        v34 = *v19 + 48;
      v35 = *(_QWORD *)v34;
      pos.z = *(RwReal *)(v34 + 8);
      *(_QWORD *)&pos.x = v35;
      v36 = *v41 * 0.3;
      v37 = *v42 * 0.3;
      vel.y = *v40 * 0.3;
      vel.x = v36;
      vel.z = v37;
      v38 = *v41;
      v39 = *v42 * 0.3;
      v44.y = 0.0 - (float)(*v40 * 0.3);
      v44.x = 0.0 - (float)(v38 * 0.3);
      v44.z = 0.5 - v39;
      FxPrtMult_c::FxPrtMult_c(&v43, 1.0, 1.0, 1.0, 0.6, 0.75, 0.0, 0.2);
      FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, &pos, &vel, 0.0, &v43, -1.0, 1.2, 0.6, 0);
      FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, &pos, &v44, 0.0, &v43, -1.0, 1.2, 0.6, 0);
      CEvent::~CEvent(&v47);
    }
    while ( m_nSize );
  }
}
// 5CAD8A: variable 'v4' is possibly undefined
// 5CAD90: variable 'v5' is possibly undefined
// 5CADAE: variable 'v1' is possibly undefined
// 5CADB2: variable 'v2' is possibly undefined
// 5CADB6: variable 'v3' is possibly undefined
// 5CAF18: variable 'v15' is possibly undefined

//----- (005CB0E8) --------------------------------------------------------
void __fastcall CWaterCannon::Update_NewInput(CWaterCannon *this, CVector *pCoors, CVector *pSpeed)
{
  __int64 v3; // d16
  char *v4; // r3
  __int64 v5; // d16
  char *v6; // r1

  v3 = *(_QWORD *)&pCoors->x;
  v4 = (char *)this + 12 * this->PointClosestToOrigin;
  *((_DWORD *)v4 + 5) = LODWORD(pCoors->z);
  *(_QWORD *)(v4 + 12) = v3;
  v5 = *(_QWORD *)&pSpeed->x;
  v6 = (char *)this + 12 * this->PointClosestToOrigin;
  *((_DWORD *)v6 + 101) = LODWORD(pSpeed->z);
  *(_QWORD *)(v6 + 396) = v5;
  this->aPointsUsed[this->PointClosestToOrigin] = 1;
}

//----- (005CB128) --------------------------------------------------------
void __fastcall CWaterCannon::Render(CWaterCannon *this)
{
  int PointClosestToOrigin; // r4
  int v3; // r1
  int v4; // r10
  int v5; // r3
  int v6; // r0
  CVector *v7; // r8
  CVector *v8; // r9
  float v9; // s0
  float v10; // s4
  float *p_z; // r5
  float *v12; // r4
  float *p_y; // r6
  float *v14; // r11
  float v15; // s6
  float v16; // s0
  int v17; // r0
  float *v18; // r1
  RwIm3DVertex *v19; // r2
  float v20; // s2
  float v21; // s4
  float v22; // s6
  RwReal v23; // s8
  RwReal v24; // s12
  RwReal v25; // s8
  RwReal v26; // s12
  RwReal v27; // s8
  RwReal v28; // s12
  RwReal v29; // s4
  RwReal v30; // s6
  int v31; // r4
  float v32; // s0
  float v33; // s6
  float v34; // s0
  __int16 v35; // r2
  bool v36; // cc
  CAEWaterCannonAudioEntity *p_m_AEWaterCannonAudioEntity; // [sp+34h] [bp-10Ch]
  CWaterCannon *v38; // [sp+40h] [bp-100h]
  int v39; // [sp+44h] [bp-FCh]
  RwV3d_0 v40; // [sp+48h] [bp-F8h] BYREF
  RwV3d_0 vel; // [sp+54h] [bp-ECh] BYREF
  FxPrtMult_c v42; // [sp+60h] [bp-E0h] BYREF
  CEntity *refEntityPtr; // [sp+7Ch] [bp-C4h] BYREF
  CColPoint v44; // [sp+80h] [bp-C0h] BYREF
  CVector v1; // [sp+ACh] [bp-94h] BYREF
  float v46; // [sp+B8h] [bp-88h]
  float v47[2]; // [sp+BCh] [bp-84h] BYREF
  CVector v48; // [sp+C4h] [bp-7Ch] BYREF
  CVector v49; // [sp+D0h] [bp-70h] BYREF

  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
  rand();
  PointClosestToOrigin = this->PointClosestToOrigin;
  p_m_AEWaterCannonAudioEntity = &this->m_AEWaterCannonAudioEntity;
  CAEWaterCannonAudioEntity::ClearSplashInfo(&this->m_AEWaterCannonAudioEntity);
  v3 = PointClosestToOrigin % 32;
  v4 = PointClosestToOrigin % 32 + 0xFFFF;
  if ( (((unsigned __int16)(PointClosestToOrigin % 32) - 1) & 0x8000) != 0 )
    LOWORD(v4) = PointClosestToOrigin % 32 + 31;
  v5 = 0;
  v6 = 0;
  v38 = this;
  do
  {
    if ( this->aPointsUsed[(__int16)v3]
      && this->aPointsUsed[(__int16)v4]
      && (v7 = &this->aPoints[(__int16)v3],
          v8 = &this->aPoints[(__int16)v4],
          v9 = v8->x - v7->x,
          v10 = v8->z - v7->z,
          v1.y = v8->y - v7->y,
          v1.x = v9,
          v1.z = v10,
          (float)((float)((float)(v9 * v9) + (float)(v1.y * v1.y)) + (float)(v10 * v10)) < 25.0) )
    {
      p_z = &v7->z;
      v12 = &v8->z;
      p_y = &v7->y;
      v14 = &v8->y;
      v39 = v5;
      if ( !(v6 << 31) )
      {
        v1.x = v9;
        v1.z = v10;
        CrossProduct(&v44.m_vecPosition, &v1, (const CVector *)&TheCamera.m_cameraMatrix.xy);
        v15 = 0.05
            / sqrtf(
                (float)((float)(v44.m_vecPosition.x * v44.m_vecPosition.x)
                      + (float)(v44.m_vecPosition.y * v44.m_vecPosition.y))
              + (float)(v44.m_vecPosition.z * v44.m_vecPosition.z));
        v46 = v44.m_vecPosition.x * v15;
        v47[0] = v44.m_vecPosition.y * v15;
        v47[1] = v44.m_vecPosition.z * v15;
        v48.x = (float)((float)rand() * 4.6566e-10) + 0.0;
        v48.y = (float)((float)rand() * 4.6566e-10) + 0.0;
        v48.z = (float)((float)rand() * 4.6566e-10) + 0.0;
        CVector::Normalise(&v48);
        v48.x = v48.x * 0.05;
        v48.y = v48.y * 0.05;
        v48.z = v48.z * 0.05;
        v49.x = (float)((float)rand() * 4.6566e-10) + 0.0;
        v49.y = (float)((float)rand() * 4.6566e-10) + 0.0;
        v49.z = (float)((float)rand() * 4.6566e-10) + 0.0;
        CVector::Normalise(&v49);
        v5 = v39;
        v49.x = v49.x * 0.05;
        v49.y = v49.y * 0.05;
        v49.z = v49.z * 0.05;
      }
      v16 = (float)((float)(v5 * v5) * 0.03125) + 3.0;
      WaterCannonVertices[1].color = (RwRGBA_0)(((int)(float)(64.0
                                                            - (float)((float)((float)(__int16)v5 * 0.03125) * 64.0)) << 24) | 0xFFC8C8);
      WaterCannonVertices[0].color = WaterCannonVertices[1].color;
      WaterCannonVertices[2].color = WaterCannonVertices[1].color;
      WaterCannonVertices[3].color = WaterCannonVertices[1].color;
      WaterCannonVertices[4].color = WaterCannonVertices[1].color;
      WaterCannonVertices[5].color = WaterCannonVertices[1].color;
      WaterCannonVertices[6].color = WaterCannonVertices[1].color;
      WaterCannonVertices[7].color = WaterCannonVertices[1].color;
      WaterCannonVertices[8].color = WaterCannonVertices[1].color;
      WaterCannonVertices[9].color = WaterCannonVertices[1].color;
      WaterCannonVertices[10].color = WaterCannonVertices[1].color;
      WaterCannonVertices[11].color = WaterCannonVertices[1].color;
      v17 = 0;
      v18 = v47;
      do
      {
        v19 = &WaterCannonVertices[v17];
        v17 += 4;
        v20 = v16 * *(v18 - 1);
        v21 = v16 * *v18;
        v22 = v16 * v18[1];
        v18 += 3;
        v23 = *p_y - v21;
        v24 = *p_z - v22;
        v19->position.x = v7->x - v20;
        v19->position.y = v23;
        v19->position.z = v24;
        v25 = *p_y + v21;
        v26 = *p_z + v22;
        v19[1].position.x = v7->x + v20;
        v19[1].position.y = v25;
        v19[1].position.z = v26;
        v27 = *v14 - v21;
        v28 = *v12 - v22;
        v19[2].position.x = v8->x - v20;
        v19[2].position.y = v27;
        v19[2].position.z = v28;
        v29 = *v14 + v21;
        v30 = *v12 + v22;
        v19[3].position.x = v8->x + v20;
        v19[3].position.y = v29;
        v19[3].position.z = v30;
      }
      while ( v17 != 12 );
      v31 = 0;
      if ( CWorld::ProcessLineOfSight(v8, v7, &v44, &refEntityPtr, 1, 1, 0, 0, 0, 0, 0, 0) )
      {
        FxPrtMult_c::FxPrtMult_c(&v42, 1.0, 1.0, 1.0, 0.15, 0.75, 1.0, 0.2);
        vel.x = v44.m_vecNormal.x * 3.0;
        vel.y = v44.m_vecNormal.y * 3.0;
        vel.z = v44.m_vecNormal.z * 3.0;
        vel.x = vel.x * (float)((float)((float)((float)rand() * 4.6566e-10) * 1.6) + 0.2);
        vel.y = vel.y * (float)((float)((float)((float)rand() * 4.6566e-10) * 1.6) + 0.2);
        v32 = (float)rand();
        v33 = CTimer::ms_fTimeStep;
        vel.z = vel.z * (float)((float)((float)(v32 * 4.6566e-10) * 1.6) + 0.2);
        v40.z = vel.z * 0.6;
        v40.x = vel.x * 0.6;
        v40.y = vel.y * 0.6;
        FxSystem_c::AddParticle(
          g_fx.m_fxSysWaterSplash,
          &v44.m_vecPosition,
          &vel,
          0.0 / (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0),
          &v42,
          -1.0,
          1.2,
          0.6,
          0);
        FxSystem_c::AddParticle(
          g_fx.m_fxSysSmoke2,
          &v44.m_vecPosition,
          &v40,
          0.0 / (float)(unsigned int)(float)((float)(v33 / 50.0) * 1000.0),
          &v42,
          -1.0,
          1.2,
          0.6,
          0);
        v34 = CTimer::ms_fTimeStep / 50.0;
        FxSystem_c::AddParticle(
          g_fx.m_fxSysWaterSplash,
          &v44.m_vecPosition,
          &vel,
          1.0 / (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0),
          &v42,
          -1.0,
          1.2,
          0.6,
          0);
        FxSystem_c::AddParticle(
          g_fx.m_fxSysSmoke2,
          &v44.m_vecPosition,
          &v40,
          1.0 / (float)(unsigned int)(float)(v34 * 1000.0),
          &v42,
          -1.0,
          1.2,
          0.6,
          0);
        CAEWaterCannonAudioEntity::SetSplashInfo(
          p_m_AEWaterCannonAudioEntity,
          v44.m_vecPosition,
          sqrtf((float)((float)(vel.x * vel.x) + (float)(vel.y * vel.y)) + (float)(vel.z * vel.z)));
        v31 = 1;
      }
      if ( RwIm3DTransform(WaterCannonVertices, 0xCu, 0, 0x10u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, WaterCannonIndexList, 18);
        RwIm3DEnd();
      }
      this = v38;
      v6 = 1;
      v5 = v39;
    }
    else
    {
      v31 = 0;
    }
    v35 = v4 - 1;
    if ( (((_WORD)v4 - 1) & 0x8000) != 0 )
      v35 = v4 + 31;
    if ( v31 )
      break;
    v36 = v5++ < 30;
    LOWORD(v3) = v4;
    LOWORD(v4) = v35;
  }
  while ( v36 );
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005CB810) --------------------------------------------------------
void CWaterCannons::Init()
{
  CWaterCannons::aCannons[0].PointClosestToOrigin = 0;
  *(_QWORD *)&CWaterCannons::aCannons[0].aPointsUsed[16] = 0LL;
  *(_QWORD *)&CWaterCannons::aCannons[0].aPointsUsed[24] = 0LL;
  *(_DWORD *)&WaterCannonIndexList[16] = 655371;
  CWaterCannons::aCannons[0].ID = 0;
  CWaterCannons::aCannons[0].LastTimeElementStored = CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)WaterCannonIndexList = 0x1000200010000LL;
  *(_QWORD *)&WaterCannonIndexList[4] = 0x5000400020003LL;
  *(_QWORD *)CWaterCannons::aCannons[0].aPointsUsed = 0LL;
  *(_QWORD *)&CWaterCannons::aCannons[0].aPointsUsed[8] = 0LL;
  *(_QWORD *)&WaterCannonIndexList[8] = 0x6000700050006LL;
  *(_QWORD *)&WaterCannonIndexList[12] = 0x9000A00090008LL;
  CAEWaterCannonAudioEntity::Initialise(&CWaterCannons::aCannons[0].m_AEWaterCannonAudioEntity, CWaterCannons::aCannons);
  *(_QWORD *)&CWaterCannons::aCannons[1].aPointsUsed[16] = 0LL;
  *(_QWORD *)&CWaterCannons::aCannons[1].aPointsUsed[24] = 0LL;
  *(_QWORD *)CWaterCannons::aCannons[1].aPointsUsed = 0LL;
  *(_QWORD *)&CWaterCannons::aCannons[1].aPointsUsed[8] = 0LL;
  CWaterCannons::aCannons[1].PointClosestToOrigin = 0;
  CWaterCannons::aCannons[1].ID = 0;
  CWaterCannons::aCannons[1].LastTimeElementStored = CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)WaterCannonIndexList = 0x1000200010000LL;
  *(_QWORD *)&WaterCannonIndexList[4] = 0x5000400020003LL;
  *(_DWORD *)&WaterCannonIndexList[10] = (char *)&stru_5FFFC.st_size + 3;
  *(_DWORD *)&WaterCannonIndexList[12] = 589832;
  *(_DWORD *)&WaterCannonIndexList[14] = "_scan";
  *(_DWORD *)&WaterCannonIndexList[16] = 655371;
  *(_DWORD *)&WaterCannonIndexList[8] = (char *)&stru_4FFFC.st_size + 2;
  CAEWaterCannonAudioEntity::Initialise(
    &CWaterCannons::aCannons[1].m_AEWaterCannonAudioEntity,
    &CWaterCannons::aCannons[1]);
  *(_QWORD *)WaterCannonIndexList = 0x1000200010000LL;
  *(_QWORD *)&WaterCannonIndexList[4] = 0x5000400020003LL;
  *(_QWORD *)&CWaterCannons::aCannons[2].aPointsUsed[16] = 0LL;
  *(_QWORD *)&CWaterCannons::aCannons[2].aPointsUsed[24] = 0LL;
  *(_QWORD *)CWaterCannons::aCannons[2].aPointsUsed = 0LL;
  *(_QWORD *)&CWaterCannons::aCannons[2].aPointsUsed[8] = 0LL;
  CWaterCannons::aCannons[2].PointClosestToOrigin = 0;
  CWaterCannons::aCannons[2].ID = 0;
  CWaterCannons::aCannons[2].LastTimeElementStored = CTimer::m_snTimeInMilliseconds;
  *(_DWORD *)&WaterCannonIndexList[10] = 393223;
  *(_DWORD *)&WaterCannonIndexList[12] = 589832;
  *(_DWORD *)&WaterCannonIndexList[14] = "_scan";
  *(_DWORD *)&WaterCannonIndexList[16] = 655371;
  *(_DWORD *)&WaterCannonIndexList[8] = (char *)&stru_4FFFC.st_size + 2;
  j_CAEWaterCannonAudioEntity::Initialise(
    &CWaterCannons::aCannons[2].m_AEWaterCannonAudioEntity,
    &CWaterCannons::aCannons[2]);
}
// FC: using guessed type int elf_hash_bucket[16411];
// 4FFFC: using guessed type Elf32_Sym stru_4FFFC;
// 5FFFC: using guessed type Elf32_Sym stru_5FFFC;

//----- (005CB970) --------------------------------------------------------
void __fastcall CWaterCannons::UpdateOne(UInt32 ID, CVector *pCoors, CVector *pSpeed)
{
  __int16 v6; // r4
  __int64 v7; // d16
  CWaterCannon *v8; // r0
  Int16 *p_PointClosestToOrigin; // r5
  char *v10; // r1
  RwReal z; // r2
  char *v12; // r0
  CWaterCannon *v13; // r8
  uint32 v14; // r0
  int v15; // r0
  UInt32 *v16; // r0
  __int64 v17; // d16
  __int64 v18; // d16
  char *v19; // r0

  if ( CWaterCannons::aCannons[0].ID == ID )
  {
    v6 = 0;
LABEL_7:
    v7 = *(_QWORD *)&pCoors->x;
    v8 = &CWaterCannons::aCannons[v6];
    p_PointClosestToOrigin = &v8->PointClosestToOrigin;
    v10 = (char *)v8 + 12 * v8->PointClosestToOrigin;
    *((_DWORD *)v10 + 5) = LODWORD(pCoors->z);
    *(_QWORD *)(v10 + 12) = v7;
    z = pSpeed->z;
    v12 = (char *)v8 + 12 * v8->PointClosestToOrigin;
    *(_QWORD *)(v12 + 396) = *(_QWORD *)&pSpeed->x;
    *((RwReal *)v12 + 101) = z;
LABEL_8:
    CWaterCannons::aCannons[v6].aPointsUsed[*p_PointClosestToOrigin] = 1;
    return;
  }
  if ( CWaterCannons::aCannons[1].ID == ID )
  {
    v6 = 1;
    goto LABEL_7;
  }
  if ( CWaterCannons::aCannons[2].ID == ID )
  {
    v6 = 2;
    goto LABEL_7;
  }
  if ( !CWaterCannons::aCannons[0].ID )
  {
    v6 = 0;
    goto LABEL_16;
  }
  if ( !CWaterCannons::aCannons[1].ID )
  {
    v6 = 1;
    goto LABEL_16;
  }
  if ( !CWaterCannons::aCannons[2].ID )
  {
    v6 = 2;
LABEL_16:
    v13 = &CWaterCannons::aCannons[v6];
    v13->ID = 0;
    v14 = CTimer::m_snTimeInMilliseconds;
    v13->PointClosestToOrigin = 0;
    p_PointClosestToOrigin = &v13->PointClosestToOrigin;
    *(_QWORD *)&v13->aPointsUsed[16] = 0LL;
    *(_QWORD *)&v13->aPointsUsed[24] = 0LL;
    *(_QWORD *)v13->aPointsUsed = 0LL;
    *(_QWORD *)&v13->aPointsUsed[8] = 0LL;
    v13->LastTimeElementStored = v14;
    *(_DWORD *)&WaterCannonIndexList[16] = 655371;
    *(_QWORD *)WaterCannonIndexList = 0x1000200010000LL;
    *(_QWORD *)&WaterCannonIndexList[4] = 0x5000400020003LL;
    *(_QWORD *)&WaterCannonIndexList[8] = 0x6000700050006LL;
    *(_QWORD *)&WaterCannonIndexList[12] = 0x9000A00090008LL;
    CAEWaterCannonAudioEntity::Initialise(&v13->m_AEWaterCannonAudioEntity, v13);
    v15 = 3 * v13->PointClosestToOrigin;
    v13->ID = ID;
    v16 = &v13->ID + v15;
    v17 = *(_QWORD *)&pCoors->x;
    v16[5] = LODWORD(pCoors->z);
    *(_QWORD *)(v16 + 3) = v17;
    v18 = *(_QWORD *)&pSpeed->x;
    v19 = (char *)v13 + 12 * v13->PointClosestToOrigin;
    *((_DWORD *)v19 + 101) = LODWORD(pSpeed->z);
    *(_QWORD *)(v19 + 396) = v18;
    goto LABEL_8;
  }
}

//----- (005CBB20) --------------------------------------------------------
void CWaterCannons::Update()
{
  CAEWaterCannonAudioEntity::Service(&CWaterCannons::aCannons[0].m_AEWaterCannonAudioEntity);
  if ( CWaterCannons::aCannons[0].ID )
    CWaterCannon::Update_OncePerFrame(CWaterCannons::aCannons, 0);
  CAEWaterCannonAudioEntity::Service(&CWaterCannons::aCannons[1].m_AEWaterCannonAudioEntity);
  if ( CWaterCannons::aCannons[1].ID )
    CWaterCannon::Update_OncePerFrame(&CWaterCannons::aCannons[1], 1);
  CAEWaterCannonAudioEntity::Service(&CWaterCannons::aCannons[2].m_AEWaterCannonAudioEntity);
  if ( CWaterCannons::aCannons[2].ID )
    CWaterCannon::Update_OncePerFrame(&CWaterCannons::aCannons[2], 2);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005CBBAC) --------------------------------------------------------
void CWaterCannons::Render()
{
  if ( CWaterCannons::aCannons[0].ID )
    CWaterCannon::Render(CWaterCannons::aCannons);
  if ( CWaterCannons::aCannons[1].ID )
    CWaterCannon::Render(&CWaterCannons::aCannons[1]);
  if ( CWaterCannons::aCannons[2].ID )
    CWaterCannon::Render(&CWaterCannons::aCannons[2]);
}

//----- (005CBC18) --------------------------------------------------------
void __fastcall CAutomobile::FireTruckControl(CAutomobile *this, CFire *pFire)
{
  CSimpleTransform *p_m_transform; // r10
  CMatrix *m_pMat; // r4
  CSimpleTransform *p_tx; // r0
  float v7; // s16
  float m_heading; // s2
  char *v9; // r0
  __int64 v10; // d16
  __int64 v11; // kr00_8
  float v12; // r5
  float v13; // r0
  float *p_GunOrientation; // r1
  float v15; // s4
  int *v16; // r2
  float v17; // s0
  float v18; // s8
  float v19; // s0
  float v20; // s2
  float GunOrientation; // s0
  float v22; // s4
  float v23; // s4
  float v24; // s2
  float v25; // s2
  float v26; // s6
  float v27; // s8
  float v28; // s4
  float v29; // s8
  float v30; // s2
  int m_nModelIndex; // r3
  int *v32; // r2
  float *p_GunElevation; // r0
  int *v34; // r1
  float v35; // s2
  float v36; // s0
  CPad *Pad; // r0
  RwFrame_0 *v38; // r0
  RwMatrix *LTM; // r0
  __int64 v40; // d16
  RwReal z; // r0
  float v42; // r5
  float GunElevation; // r6
  float v44; // r9
  float v45; // r4
  float v46; // s0
  float v47; // s0
  float x; // s16
  float y; // s18
  float v50; // s4
  CMatrix *v51; // r0
  float v52; // s20
  float v53; // s22
  float v54; // s24
  float v55; // s26
  RwReal v56; // s4
  RwReal v57; // s0
  float v58; // s2
  float v59; // s0
  RwReal v60; // s6
  RwReal v61; // s0
  CVector v62; // [sp+8h] [bp-88h] BYREF
  CVector pSpeed; // [sp+18h] [bp-78h] BYREF
  CVector pCoors; // [sp+28h] [bp-68h] BYREF
  CVector v; // [sp+38h] [bp-58h] BYREF
  CVector v66; // 0:r2.8,8:^0.4

  p_m_transform = &this->m_transform;
  if ( this != FindPlayerVehicle(-1, 0) )
  {
    if ( !pFire || (*(_BYTE *)&this->m_info & 0xF8) != 24 )
      return;
    m_pMat = this->m_pMat;
    p_tx = &this->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v7 = atan2f(-(float)(pFire->m_vLocation.x - p_tx->m_translate.x), pFire->m_vLocation.y - p_tx->m_translate.y);
    if ( m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      m_heading = this->m_transform.m_heading;
    if ( v7 <= (float)(m_heading + 3.1416) )
    {
      if ( v7 >= (float)(m_heading + -3.1416) )
        goto LABEL_20;
      v19 = 6.2832;
    }
    else
    {
      v19 = -6.2832;
    }
    v7 = v7 + v19;
LABEL_20:
    v20 = v7 - m_heading;
    GunOrientation = this->GunOrientation;
    if ( v20 <= (float)(GunOrientation + 3.1416) )
    {
      if ( v20 >= (float)(GunOrientation + -3.1416) )
      {
LABEL_25:
        v23 = v20 - GunOrientation;
        if ( fabsf(v20 - GunOrientation) >= (float)(CTimer::ms_fTimeStep * 0.01) )
        {
          v24 = -(float)(CTimer::ms_fTimeStep * 0.01);
          if ( v23 > 0.0 )
            v24 = CTimer::ms_fTimeStep * 0.01;
          v20 = GunOrientation + v24;
        }
        this->GunOrientation = v20;
        this->GunElevation = (float)(sinf((float)((float)(CTimer::m_snTimeInMilliseconds & 0xFFF) * 6.28) * 0.00024414)
                                   * 0.15)
                           + 0.0;
LABEL_56:
        v38 = this->m_aCarNodes[20];
        if ( v38 )
        {
          LTM = RwFrameGetLTM(v38);
          v40 = *(_QWORD *)&LTM->pos.x;
          z = LTM->pos.z;
        }
        else
        {
          v.z = 1.8;
          v.y = 1.5;
          v.x = 0.0;
          operator*(&pSpeed, this->m_pMat, &v);
          z = pSpeed.z;
          v40 = *(_QWORD *)&pSpeed.x;
        }
        pCoors.z = z;
        *(_QWORD *)&pCoors.x = v40;
        v42 = this->GunOrientation;
        GunElevation = this->GunElevation;
        v44 = sinf(v42);
        v45 = cosf(GunElevation);
        v46 = cosf(v42);
        v.z = sinf(GunElevation);
        v.y = v45 * v46;
        v.x = -(float)(v44 * v45);
        Multiply3x3(&v62, this->m_pMat, &v);
        pSpeed = v62;
        if ( this->m_aCarNodes[20] )
        {
          v47 = 1.2;
          if ( this->m_nModelIndex == 601 )
            v47 = 2.0;
          x = pSpeed.x;
          y = pSpeed.y;
          v50 = pSpeed.y * v47;
          v51 = this->m_pMat;
          v52 = pSpeed.z;
          if ( v51 )
            p_m_transform = (CSimpleTransform *)&v51->tx;
          v53 = (float)(pSpeed.x * v47) + pCoors.x;
          v54 = v50 + pCoors.y;
          v55 = (float)(v47 * pSpeed.z) + pCoors.z;
          v56 = (float)(v50 + pCoors.y) - p_m_transform->m_translate.y;
          v57 = v55 - p_m_transform->m_translate.z;
          v.x = v53 - p_m_transform->m_translate.x;
          v66.x = v.x;
          v66.y = v56;
          v.y = v56;
          v.z = v57;
          v66.z = v57;
          CPhysical::GetSpeed(&v62, this, v66);
          v = v62;
          pCoors.x = (float)(CTimer::ms_fTimeStep * v62.x) + v53;
          pCoors.y = (float)(CTimer::ms_fTimeStep * v62.y) + v54;
          pCoors.z = (float)(CTimer::ms_fTimeStep * v62.z) + v55;
        }
        else
        {
          x = pSpeed.x;
          y = pSpeed.y;
          v52 = pSpeed.z;
        }
        v58 = 0.5;
        v59 = (float)(rand() & 0xF) * 0.001;
        if ( this->m_nModelIndex == 601 )
          v58 = 0.4;
        v60 = this->m_vecMoveSpeed.x + (float)(x * v58);
        v61 = (float)(this->m_vecMoveSpeed.z * 0.3) + (float)(v58 * (float)(v52 + v59));
        pSpeed.y = this->m_vecMoveSpeed.y + (float)(v58 * y);
        pSpeed.x = v60;
        pSpeed.z = v61;
        CWaterCannons::UpdateOne((UInt32)this, &pCoors, &pSpeed);
        return;
      }
      v22 = 6.2832;
    }
    else
    {
      v22 = -6.2832;
    }
    v20 = v20 + v22;
    goto LABEL_25;
  }
  if ( TheCamera.Cams[TheCamera.ActiveCam].Mode != 18 )
  {
    p_GunOrientation = &this->GunOrientation;
    v17 = this->GunOrientation;
    goto LABEL_42;
  }
  v9 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
  v10 = *((_QWORD *)v9 + 91);
  v.z = *((RwReal *)v9 + 184);
  *(_QWORD *)&v.x = v10;
  Multiply3x3(&pCoors, &v, this->m_pMat);
  v = pCoors;
  v11 = *(_QWORD *)&pCoors.x;
  v12 = atan2f(COERCE_FLOAT(LODWORD(pCoors.x) ^ 0x80000000), pCoors.y);
  v13 = atan2f(
          v.z,
          sqrtf((float)(*(float *)&v11 * *(float *)&v11) + (float)(*((float *)&v11 + 1) * *((float *)&v11 + 1))));
  p_GunOrientation = &this->GunOrientation;
  v15 = this->GunOrientation;
  v16 = dword_5CC1D4;
  if ( this->m_nModelIndex == 601 )
    v16 = &dword_5CC1D4[1];
  v17 = v12;
  if ( v12 > (float)(v15 + 3.1416) )
  {
    v18 = -6.2832;
LABEL_32:
    v17 = v12 + v18;
    goto LABEL_33;
  }
  if ( v12 < (float)(v15 + -3.1416) )
  {
    v18 = 6.2832;
    goto LABEL_32;
  }
LABEL_33:
  v25 = v13 + *(float *)v16;
  v26 = CTimer::ms_fTimeStep;
  v27 = CTimer::ms_fTimeStep * 0.05;
  if ( (float)(v17 - v15) <= (float)(CTimer::ms_fTimeStep * 0.05) )
  {
    if ( (float)(v17 - v15) < (float)(CTimer::ms_fTimeStep * -0.05) )
      v17 = v15 - v27;
  }
  else
  {
    v17 = v15 + v27;
  }
  *p_GunOrientation = v17;
  v28 = this->GunElevation;
  v29 = v26 * 0.02;
  if ( (float)(v25 - v28) <= (float)(v26 * 0.02) )
  {
    if ( (float)(v25 - v28) < (float)(v26 * -0.02) )
      v25 = v28 - v29;
  }
  else
  {
    v25 = v28 + v29;
  }
  this->GunElevation = v25;
LABEL_42:
  if ( v17 >= -3.1416 )
  {
    if ( v17 <= 3.1416 )
      goto LABEL_47;
    v30 = -6.2832;
  }
  else
  {
    v30 = 6.2832;
  }
  *p_GunOrientation = v17 + v30;
LABEL_47:
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  v32 = dword_5CC1F0;
  p_GunElevation = &this->GunElevation;
  v34 = dword_5CC1F8;
  if ( m_nModelIndex == 601 )
    v32 = &dword_5CC1F0[1];
  v35 = *p_GunElevation;
  v36 = *(float *)v32;
  if ( m_nModelIndex == 601 )
    v34 = &dword_5CC1F8[1];
  if ( v35 >= v36 )
  {
    if ( v35 > *(float *)v34 )
      *(_DWORD *)p_GunElevation = *v34;
  }
  else
  {
    *p_GunElevation = v36;
  }
  Pad = CPad::GetPad(0);
  if ( CPad::GetCarGunFired(Pad, 1, 0) )
    goto LABEL_56;
}
// 5CC1D4: using guessed type int dword_5CC1D4[2];
// 5CC1F0: using guessed type int dword_5CC1F0[2];
// 5CC1F8: using guessed type int dword_5CC1F8[2];

//----- (005CC214) --------------------------------------------------------
void CWeather::Init()
{
  CWeather::OldWeatherType = 0;
  CWeather::NewWeatherType = 0;
  CWeather::InTunnelness = 0.0;
  CWeather::Sandstorm = 0.0;
  CWeather::CurrentRainParticleStrength = 0;
  CWeather::WeatherRegion = 0;
  CWeather::LightningStartX = 0;
  CWeather::LightningStartY = 0;
  CWeather::StreamAfterRainTimer = 0;
  CWeather::InterpolationValue = 0.0;
  CWeather::WeatherTypeInList = 0;
  CWeather::ForcedWeatherType = -1;
  CWeather::WhenToPlayLightningSound = 0;
  CWeather::bScriptsForceRain = 0;
  CWeather::Rain = 0.0;
}

//----- (005CC2E8) --------------------------------------------------------
void CWeather::Update()
{
  float32x2_t v0; // d3
  float32x2_t v1; // d4
  float32x2_t v2; // d9
  float32x2_t v3; // d11
  CSimpleTransform *p_tx; // r2
  float x; // s2
  float y; // s0
  Int16 v7; // r0
  CSimpleTransform *p_m_transform; // r0
  float v9; // s4
  float v10; // s2
  Int16 v11; // r1
  Int16 v12; // r2
  bool v13; // zf
  bool v14; // zf
  int v15; // r0
  _BOOL4 v16; // r4
  __int16 v17; // r0
  uint32 v18; // r0
  UInt32 v19; // r2
  uint32 v20; // r1
  bool v21; // cc
  CPad *Pad; // r0
  float v23; // s4
  float v24; // s6
  int v25; // r0
  float v26; // s2
  bool v27; // zf
  int v28; // r0
  float v29; // s10
  unsigned int v30; // r0
  float v31; // s8
  bool v32; // zf
  float v33; // s8
  float v34; // s10
  float v35; // s6
  float v36; // s14
  float v37; // s10
  float v38; // s12
  float v39; // s8
  float v40; // s14
  float32x2_t v41; // d0
  float v42; // s8
  float v43; // s6
  bool v44; // zf
  bool v45; // zf
  float v46; // s4
  float v47; // s6
  float v48; // s4
  float v49; // s6
  float32x2_t v50; // d0
  int v51; // s0
  float v52; // s0
  Int32 v53; // r11
  int v54; // r5
  Int32 v55; // r10
  float v56; // s22
  Int32 v57; // r8
  int v58; // r4
  Int32 v59; // r9
  float v60; // s0
  float v61; // s2
  uint32 v62; // r4
  float v63; // s30
  float v64; // s28
  float *v65; // r11
  float v66; // s0
  float32x2_t v67; // d2
  float32x2_t v68; // d1
  float v69; // s10
  float v70; // s8
  float v71; // s28
  float v72; // s30
  float32x2_t v73; // d0
  float v74; // s20
  float v75; // s17
  float v76; // s4
  float v77; // r0
  RwReal v78; // s6
  RwReal v79; // s4
  RwReal v80; // s10
  float32x2_t v81; // d0
  float32x2_t v82; // d1
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v84; // r0
  CTask *SimplestActiveTask; // r0
  __int64 v86; // r0
  char (*v87)[64]; // r1
  char v88; // r2
  char v89; // r3
  __int16 v90; // r1
  __int16 v91; // r2
  int v92; // r5
  int v93; // r0
  char v94; // r1
  char v95; // r2
  __int16 v96; // r0
  __int16 v97; // r1

  if ( !((unsigned __int8)CTimer::m_FrameCounter << 28) )
  {
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    if ( p_tx->m_translate.x <= 1000.0 )
    {
      if ( x <= -850.0 || x >= 1000.0 || y <= 1280.0 )
      {
        if ( y >= 1430.0 || y <= -580.0 )
        {
          v94 = 0;
          v95 = 0;
          v96 = 0;
          if ( x < 3000.0 )
            v94 = 1;
          if ( x > 250.0 )
            v95 = 1;
          v97 = (unsigned __int8)(v94 & v95) & (y > -3000.0);
          if ( y < -850.0 )
            v96 = 1;
          v7 = v96 & v97;
        }
        else
        {
          v7 = 2;
        }
      }
      else
      {
        v7 = 4;
      }
    }
    else
    {
      v7 = 3;
    }
    CWeather::WeatherRegion = v7;
  }
  if ( (float)((float)((float)((float)(unsigned __int8)CClock::ms_nGameClockSeconds / 60.0)
                     + (float)CClock::ms_nGameClockMinutes)
             / 60.0) >= CWeather::InterpolationValue )
  {
    v12 = CWeather::NewWeatherType;
  }
  else
  {
    p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_m_transform = &TheCamera.m_transform;
    v9 = p_m_transform->m_translate.x;
    v10 = p_m_transform->m_translate.y;
    if ( p_m_transform->m_translate.x <= 1000.0 )
    {
      if ( v9 <= -850.0 || v9 >= 1000.0 || v10 <= 1280.0 )
      {
        if ( v10 >= 1430.0 || v10 <= -580.0 )
        {
          v88 = 0;
          v89 = 0;
          v90 = 0;
          if ( v9 < 3000.0 )
            v88 = 1;
          if ( v9 > 250.0 )
            v89 = 1;
          v91 = (unsigned __int8)(v88 & v89) & (v10 > -3000.0);
          if ( v10 < -850.0 )
            v90 = 1;
          v11 = v90 & v91;
        }
        else
        {
          v11 = 2;
        }
      }
      else
      {
        v11 = 4;
      }
    }
    else
    {
      v11 = 3;
    }
    v12 = CWeather::NewWeatherType;
    CWeather::WeatherRegion = v11;
    CWeather::OldWeatherType = CWeather::NewWeatherType;
    if ( CWeather::ForcedWeatherType <= -1 )
    {
      if ( p_m_transform->m_translate.z < 950.0 )
      {
        v87 = off_66E360[(unsigned __int16)v11 ^ 4];
        CWeather::WeatherTypeInList = (CWeather::WeatherTypeInList + 1) % 64;
        v12 = (*v87)[CWeather::WeatherTypeInList];
        CWeather::NewWeatherType = v12;
      }
    }
    else
    {
      v12 = CWeather::ForcedWeatherType;
      CWeather::NewWeatherType = CWeather::ForcedWeatherType;
    }
  }
  CWeather::InterpolationValue = (float)((float)((float)(unsigned __int8)CClock::ms_nGameClockSeconds / 60.0)
                                       + (float)CClock::ms_nGameClockMinutes)
                               / 60.0;
  v13 = v12 == 16;
  if ( v12 != 16 )
    v13 = v12 == 8;
  if ( !v13 )
    goto LABEL_34;
  v14 = CWeather::OldWeatherType == 16;
  if ( CWeather::OldWeatherType != 16 )
    v14 = CWeather::OldWeatherType == 8;
  if ( !v14
    || CCullZones::CamNoRain()
    || (v15 = CCullZones::PlayerNoRain(), CWeather::UnderWaterness > 0.0)
    || v15
    || CGame::currArea )
  {
LABEL_34:
    CWeather::LightningBurst = 0;
    CWeather::LightningFlash = 0;
LABEL_35:
    v18 = CTimer::m_snTimeInMilliseconds;
    v20 = CWeather::WhenToPlayLightningSound;
    goto LABEL_36;
  }
  v16 = CWeather::LightningBurst;
  v17 = rand();
  if ( !v16 )
  {
    if ( (v17 & 0xFFF8u) > 0xC7 )
    {
      CWeather::LightningFlash = 0;
    }
    else
    {
      CWeather::LightningBurst = 1;
      CWeather::LightningFlash = 1;
      CWeather::LightningStart = CTimer::m_FrameCounter;
      CWeather::LightningFlashLastChange = CTimer::m_snTimeInMilliseconds;
    }
    goto LABEL_35;
  }
  if ( (v17 & 0xF8u) > 0x17 )
  {
    if ( CTimer::m_snTimeInMilliseconds - CWeather::LightningFlashLastChange >= 0x33 )
    {
      v92 = CWeather::LightningFlash;
      v93 = rand() & 1;
      CWeather::LightningFlash = v93;
      if ( v93 != v92 )
        CWeather::LightningFlashLastChange = CTimer::m_snTimeInMilliseconds;
    }
    goto LABEL_35;
  }
  v18 = CTimer::m_snTimeInMilliseconds;
  v19 = CTimer::m_FrameCounter - CWeather::LightningStart;
  if ( CTimer::m_FrameCounter - CWeather::LightningStart >= 0x14 )
    v19 = 20;
  v20 = CTimer::m_snTimeInMilliseconds + 150 * (20 - v19);
  CWeather::LightningBurst = 0;
  CWeather::LightningFlash = 0;
  CWeather::LightningDuration = v19;
  CWeather::WhenToPlayLightningSound = v20;
LABEL_36:
  v21 = v20 != 0;
  if ( v20 )
    v21 = v18 > v20;
  if ( v21 )
  {
    CAEWeatherAudioEntity::AddAudioEvent(&CWeather::m_WeatherAudioEntity, 141);
    Pad = CPad::GetPad(0);
    CPad::StartShake(Pad, 40 * CWeather::LightningDuration + 100, 2 * CWeather::LightningDuration + 80, 0);
    CWeather::WhenToPlayLightningSound = 0;
  }
  v2.n64_u32[0] = 1.0;
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0;
  v26 = 1.0 - CWeather::InterpolationValue;
  if ( CWeather::NewWeatherType == 16 )
    v25 = 1;
  v28 = v25 | (CWeather::NewWeatherType == 8);
  v27 = v28 == 0;
  if ( v28 )
    v24 = CWeather::InterpolationValue;
  v29 = v24;
  v30 = (unsigned __int16)CWeather::OldWeatherType;
  v31 = 1.0 - CWeather::InterpolationValue;
  if ( !v27 )
    v31 = 1.0;
  if ( CWeather::OldWeatherType == 8 )
    v29 = v31;
  if ( CWeather::OldWeatherType == 16 )
    v29 = v31;
  v32 = CWeather::OldWeatherType == 16;
  CWeather::WetRoads = v29;
  if ( CWeather::OldWeatherType != 16 )
    v32 = CWeather::OldWeatherType == 8;
  if ( v32 )
    v24 = v26 + v24;
  v33 = (float)((float)((CTimer::m_snTimeInMilliseconds >> 13) & 3) * 0.1) + 0.7;
  v34 = v24 * v33;
  v35 = CTimer::ms_fTimeStep * 0.005;
  v36 = v34 - CWeather::Rain;
  if ( fabsf(v34 - CWeather::Rain) >= (float)(CTimer::ms_fTimeStep * 0.005) )
  {
    v37 = -v35;
    if ( v36 > 0.0 )
      v37 = CTimer::ms_fTimeStep * 0.005;
    v34 = CWeather::Rain + v37;
  }
  v38 = 0.0;
  if ( CWeather::NewWeatherType == 19 )
    v38 = CWeather::InterpolationValue;
  if ( CWeather::OldWeatherType == 19 )
    v38 = v38 + v26;
  v39 = v38 * v33;
  v40 = v39 - CWeather::Sandstorm;
  CWeather::Rain = v34;
  v41.n64_f32[1] = fabsf(v39 - CWeather::Sandstorm);
  if ( v41.n64_f32[1] >= v35 )
  {
    v42 = -v35;
    if ( v40 > 0.0 )
      v42 = CTimer::ms_fTimeStep * 0.005;
    v39 = CWeather::Sandstorm + v42;
  }
  v43 = 1.0 - CWeather::InterpolationValue;
  CWeather::Sandstorm = v39;
  if ( (unsigned __int16)CWeather::OldWeatherType <= 0x12u )
  {
    v43 = 1.0 - CWeather::InterpolationValue;
    if ( ((unsigned int)&stru_66C6C.st_name + 3) >> CWeather::OldWeatherType << 31 )
      v43 = 0.0;
  }
  CWeather::CloudCoverage = v43;
  if ( (unsigned __int16)CWeather::NewWeatherType > 0x12u
    || ((1 << CWeather::NewWeatherType) & ((unsigned int)&stru_66C6C.st_name + 3)) == 0 )
  {
    CWeather::CloudCoverage = CWeather::InterpolationValue + v43;
  }
  v44 = CWeather::OldWeatherType == 19;
  if ( CWeather::OldWeatherType != 19 )
    v44 = CWeather::OldWeatherType == 9;
  if ( v44 )
    v23 = 1.0 - CWeather::InterpolationValue;
  v45 = CWeather::NewWeatherType == 19;
  CWeather::Foggyness = v23;
  if ( CWeather::NewWeatherType != 19 )
    v45 = CWeather::NewWeatherType == 9;
  if ( v45 )
    CWeather::Foggyness = CWeather::InterpolationValue + v23;
  v46 = 0.0;
  v47 = 0.0;
  if ( CWeather::OldWeatherType == 9 )
    v47 = 1.0 - CWeather::InterpolationValue;
  if ( CWeather::NewWeatherType == 9 )
    v47 = v47 + CWeather::InterpolationValue;
  CWeather::Foggyness_SF = v47;
  if ( (unsigned __int16)CWeather::OldWeatherType <= 0x11u
    && ((1 << CWeather::OldWeatherType) & ((unsigned int)&elf_hash_chain[18871] + 1)) != 0 )
  {
    v46 = 1.0 - CWeather::InterpolationValue;
  }
  CWeather::ExtraSunnyness = v46;
  if ( (unsigned __int16)CWeather::NewWeatherType <= 0x11u
    && ((1 << CWeather::NewWeatherType) & ((unsigned int)&elf_hash_chain[18871] + 1)) != 0 )
  {
    CWeather::ExtraSunnyness = CWeather::InterpolationValue + v46;
  }
  v48 = 0.0;
  v49 = 0.0;
  if ( (unsigned __int16)CWeather::OldWeatherType <= 0xFu )
  {
    v49 = 0.0;
    if ( ((1 << CWeather::OldWeatherType) & 0x9090) != 0 )
    {
      v49 = 0.0;
      if ( (unsigned __int16)CWeather::NewWeatherType <= 0x12u )
      {
        v49 = 0.0;
        if ( ((1 << CWeather::NewWeatherType) & (unsigned int)&stru_4441C.st_shndx) != 0 )
        {
          v49 = 0.0;
          if ( CWeather::InterpolationValue < 0.5 )
          {
            v49 = 0.0;
            if ( (unsigned __int8)(CClock::ms_nGameClockHours - 7) <= 0xDu )
              v49 = (float)(fabsf(CWeather::InterpolationValue + -0.25) * -4.0) + 1.0;
          }
        }
      }
    }
  }
  CWeather::Rainbow = v49;
  if ( (unsigned __int16)CWeather::OldWeatherType <= 0x12u
    && ((1 << CWeather::OldWeatherType) & ((unsigned int)&stru_66C6C.st_name + 3)) != 0 )
  {
    v48 = 1.0 - CWeather::InterpolationValue;
  }
  CWeather::SunGlare = v48;
  if ( (unsigned __int16)CWeather::NewWeatherType <= 0x12u && ((1 << CWeather::NewWeatherType) & 0x66C6F) != 0 )
  {
    v48 = CWeather::InterpolationValue + v48;
    CWeather::SunGlare = v48;
  }
  if ( v48 > 0.0 )
  {
    v3.n64_u32[0] = 1.0;
    v0.n64_u32[0] = 0;
    v41.n64_f32[0] = CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue].z * 7.0;
    v50.n64_u64[0] = vmin_f32(v41, v3).n64_u64[0];
    v50.n64_f32[0] = v48 * v50.n64_f32[0];
    v41.n64_u64[0] = vmin_f32(vmax_f32(v50, v0), v3).n64_u64[0];
    CWeather::SunGlare = v41.n64_f32[0];
    if ( !CSpecialFX::bSnapShotActive )
    {
      v51 = rand() & 0x1F;
      v30 = (unsigned __int16)CWeather::OldWeatherType;
      CWeather::SunGlare = CWeather::SunGlare * (float)((float)((float)v51 * -0.007) + 1.0);
    }
  }
  v52 = 0.0;
  if ( v30 <= 0x12 && ((1 << v30) & 0x60801) != 0 )
    v52 = 1.0 - CWeather::InterpolationValue;
  CWeather::HeatHaze = v52;
  if ( (unsigned __int16)CWeather::NewWeatherType <= 0x12u && ((1 << CWeather::NewWeatherType) & 0x60801) != 0 )
  {
    v52 = CWeather::InterpolationValue + v52;
    CWeather::HeatHaze = v52;
  }
  if ( v52 > 0.0 )
  {
    v53 = CClock::ms_nGameClockHours;
    v54 = 0;
    v55 = CPostEffects::m_HeatHazeFXHourOfDayEnd;
    v56 = CPostEffects::m_fHeatHazeFXFadeSpeed;
    v57 = CClock::ms_nGameClockMinutes;
    CWeather::HeatHazeFXControl = 0.0;
    v58 = 0;
    v59 = CWeather::Update(void)::mLast;
    if ( CPostEffects::m_HeatHazeFXHourOfDayEnd > CClock::ms_nGameClockHours )
      v58 = 1;
    if ( CPostEffects::m_HeatHazeFXHourOfDayStart <= CClock::ms_nGameClockHours )
      v54 = 1;
    if ( CGame::currArea || FindPlayerPed(-1)->m_areaCode || CCullZones::CamNoRain() || CCullZones::PlayerNoRain() == 1 )
    {
      v56 = CPostEffects::m_fHeatHazeFXInsideBuildingFadeSpeed;
    }
    else
    {
      if ( (v54 & v58) == 1 )
      {
        v60 = CWeather::Update(void)::fHeatHaze;
        if ( v59 != v57 )
        {
          v60 = v56 + CWeather::Update(void)::fHeatHaze;
          CWeather::Update(void)::fHeatHaze = v56 + CWeather::Update(void)::fHeatHaze;
        }
        if ( v60 > 1.0 )
        {
          v60 = 1.0;
          CWeather::Update(void)::fHeatHaze = 1.0;
        }
        goto LABEL_129;
      }
      if ( v55 > v53 )
      {
        v60 = CWeather::HeatHazeFXControl;
        goto LABEL_130;
      }
    }
    v60 = CWeather::Update(void)::fHeatHaze;
    if ( v59 != v57 )
    {
      v60 = CWeather::Update(void)::fHeatHaze - v56;
      CWeather::Update(void)::fHeatHaze = CWeather::Update(void)::fHeatHaze - v56;
    }
    if ( v60 < 0.0 )
    {
      v60 = 0.0;
      CWeather::Update(void)::fHeatHaze = 0.0;
    }
LABEL_129:
    CWeather::HeatHazeFXControl = v60;
LABEL_130:
    CWeather::Update(void)::mLast = v57;
    CWeather::HeatHazeFXControl = CWeather::HeatHaze * v60;
  }
  v61 = (float)CTimeCycle::m_CurrentColours.m_nWaterFogAlpha / 100.0;
  if ( CTimeCycle::m_CurrentColours.m_nWaterFogAlpha )
  {
    if ( CTimeCycle::m_CurrentColours.m_nWaterFogAlpha >= 0x5Fu )
    {
      v41.n64_f32[0] = CWeather::Update(void)::fWaterFogProcessed;
      CWeather::Update(void)::bMaximumWaterFogIntensityReached = 1;
LABEL_136:
      if ( v61 < v41.n64_f32[0] )
      {
        v41.n64_f32[0] = (float)CTimeCycle::m_CurrentColours.m_nWaterFogAlpha / 100.0;
        CWeather::Update(void)::fWaterFogProcessed = v41.n64_f32[0];
      }
      if ( v41.n64_f32[0] <= 0.0 )
        CWeather::Update(void)::bMaximumWaterFogIntensityReached = 0;
      goto LABEL_142;
    }
  }
  else
  {
    CWeather::Update(void)::fWaterFogProcessed = 0.0;
  }
  v41.n64_f32[0] = CWeather::Update(void)::fWaterFogProcessed;
  if ( CWeather::Update(void)::bMaximumWaterFogIntensityReached )
    goto LABEL_136;
  if ( v61 > CWeather::Update(void)::fWaterFogProcessed )
  {
    v41.n64_f32[0] = (float)CTimeCycle::m_CurrentColours.m_nWaterFogAlpha / 100.0;
    CWeather::Update(void)::fWaterFogProcessed = v41.n64_f32[0];
  }
LABEL_142:
  v3.n64_u32[0] = 0;
  v62 = CTimer::m_snTimeInMilliseconds;
  v63 = Windyness[CWeather::NewWeatherType];
  v64 = Windyness[CWeather::OldWeatherType];
  v41.n64_f32[0] = v41.n64_f32[0] * 1.4;
  LODWORD(CWeather::WaterFogFXControl) = vmin_f32(vmax_f32(v41, v3), v2).n64_u32[0];
  v65 = &CWeather::Update(void)::WindVariation[((unsigned __int8)(CTimer::m_snTimeInMilliseconds >> 10) + 6) & 0xF];
  v66 = 0.5 - (float)(cosf((float)((float)(CTimer::m_snTimeInMilliseconds & 0x3FF) * 0.00097656) * 3.1416) * 0.5);
  v68.n64_f32[1] = *v65;
  v67.n64_u32[1] = 1045220557;
  v73.n64_u32[1] = 1053609165;
  v68.n64_f32[0] = (float)(v63 * CWeather::InterpolationValue)
                 + (float)(v64 * (float)(1.0 - CWeather::InterpolationValue));
  v69 = (float)(CWeather::Update(void)::WindVariation[(v62 >> 10) & 0xF] * (float)(1.0 - v66))
      + (float)(v66 * CWeather::Update(void)::WindVariation[((unsigned __int8)(v62 >> 10) + 1) & 0xF]);
  v70 = (float)((float)(1.0 - v66) * CWeather::Update(void)::WindVariation[((unsigned __int8)(v62 >> 10) + 3) & 0xF])
      + (float)(v66 * CWeather::Update(void)::WindVariation[((v62 >> 10) + 4) & 0xF]);
  v71 = vmin_f32(v68, v2).n64_f32[0];
  v73.n64_f32[0] = (float)((float)(1.0 - v66) * *v65)
                 + (float)(v66 * CWeather::Update(void)::WindVariation[((unsigned __int8)(v62 >> 10) + 7) & 0xF]);
  CWeather::Wind = v68.n64_f32[0];
  CWeather::WindClipped = v71;
  v72 = (float)((float)(v71 * 0.2) * v73.n64_f32[0]) + 0.0;
  v73.n64_f32[0] = (float)(v71 + -0.5) * 0.4;
  v74 = (float)(v71 * 0.7) + (float)((float)(v71 * 0.4) * v69);
  v75 = (float)(v71 * 0.7) + (float)((float)(v71 * 0.4) * v70);
  CWeather::WindDir.x = v74;
  CWeather::WindDir.y = v75;
  CWeather::WindDir.z = v72;
  if ( v73.n64_f32[0] > 0.0 )
  {
    v76 = (float)(unsigned __int8)v62 * 0.0039062;
    v73.n64_f32[1] = CWeather::Update(void)::WindVariation[(BYTE1(v62) + 6) & 0xF];
    v75 = v75
        + (float)(v73.n64_f32[0]
                * (float)((float)((float)(1.0 - v76) * CWeather::Update(void)::WindVariation[(BYTE1(v62) + 3) & 0xF])
                        + (float)(v76 * CWeather::Update(void)::WindVariation[(BYTE1(v62) + 4) & 0xF])));
    v74 = v74
        + (float)(v73.n64_f32[0]
                * (float)((float)(CWeather::Update(void)::WindVariation[(BYTE1(v62) + 1) & 0xF] * v76)
                        + (float)(CWeather::Update(void)::WindVariation[(v62 >> 8) & 0xF] * (float)(1.0 - v76))));
    v72 = v72
        + (float)(v73.n64_f32[0]
                * (float)((float)((float)(1.0 - v76) * v73.n64_f32[1])
                        + (float)(v76 * CWeather::Update(void)::WindVariation[(BYTE1(v62) + 7) & 0xF])));
    CWeather::WindDir.x = v74;
    CWeather::WindDir.y = v75;
    CWeather::WindDir.z = v72;
  }
  v77 = cosf((float)((float)(v62 & 0x7FF) * 0.00048828) * 3.1416);
  v1.n64_f32[0] = 1.0 - CWeather::UnderWaterness;
  v73.n64_f32[0] = (float)(CWeather::Update(void)::DyingDown[((unsigned __int8)(v62 >> 11) + 1) & 0xF]
                         * (float)(0.5 - (float)(v77 * 0.5)))
                 + (float)(CWeather::Update(void)::DyingDown[(v62 >> 11) & 0xF]
                         * (float)(1.0 - (float)(0.5 - (float)(v77 * 0.5))));
  v68.n64_f32[0] = v71 + 0.3;
  v78 = v74 * v73.n64_f32[0];
  v79 = v75 * v73.n64_f32[0];
  v80 = v73.n64_f32[0] * v72;
  v73.n64_f32[0] = CWeather::Rain;
  v81.n64_u64[0] = vmin_f32(v73, v1).n64_u64[0];
  LODWORD(CWeather::Wavyness) = vmin_f32(v68, v2).n64_u32[0];
  v82.n64_u64[0] = v2.n64_u64[0];
  CWeather::WindDir.x = v78;
  CWeather::WindDir.y = v79;
  CWeather::WindDir.z = v80;
  CWeather::Rain = v81.n64_f32[0];
  if ( CClock::ms_nGameClockHours <= 0x14u )
  {
    if ( CClock::ms_nGameClockHours == 20 )
    {
      v82.n64_f32[0] = (float)CClock::ms_nGameClockMinutes / 60.0;
    }
    else
    {
      v82.n64_u64[0] = v3.n64_u64[0];
      if ( CClock::ms_nGameClockHours <= 6u )
      {
        v82.n64_u64[0] = v2.n64_u64[0];
        if ( CClock::ms_nGameClockHours == 6 )
          v82.n64_f32[0] = (float)((float)CClock::ms_nGameClockMinutes / -60.0) + 1.0;
      }
    }
  }
  v0.n64_f32[0] = CWeather::WetRoads;
  v67.n64_f32[0] = CWeather::Foggyness;
  LODWORD(CWeather::HeadLightsSpectrum) = vmin_f32(vmax_f32(v67, v81), v2).n64_u32[0];
  LODWORD(CWeather::TrafficLightsBrightness) = vmax_f32(vmax_f32(vmax_f32(v82, v0), v67), v81).n64_u32[0];
  CWeather::AddRain();
  PlayerPed = FindPlayerPed(-1);
  if ( CTaskManager::GetSimplestActiveTask(&PlayerPed->m_pPedIntelligence->m_taskManager) )
  {
    v84 = FindPlayerPed(-1);
    SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&v84->m_pPedIntelligence->m_taskManager);
    HIDWORD(v86) = (*((int (__fastcall **)(CTask *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask) != 254;
  }
  else
  {
    HIDWORD(v86) = 1;
  }
  if ( (unsigned __int16)CWeather::NewWeatherType <= 0x12u )
  {
    if ( ((1 << CWeather::NewWeatherType) & 0x22845) != 0 )
    {
      if ( CGame::currArea )
        goto LABEL_164;
    }
    else if ( ((1 << CWeather::NewWeatherType) & 0x4442A) == 0 || CGame::currArea )
    {
      goto LABEL_164;
    }
    if ( !CCutsceneMgr::ms_running )
    {
      LODWORD(v86) = CTimer::m_FrameCounter & 7;
      if ( (CTimer::m_FrameCounter & 7) != 0 )
        LODWORD(v86) = 1;
      if ( !v86 )
        FindPlayerPed(-1);
    }
  }
LABEL_164:
  CWeather::UpdateInTunnelness();
  sub_18EB2C(&CWeather::m_WeatherAudioEntity);
}
// 5CC8E2: variable 'v3' is possibly undefined
// 5CC8EA: variable 'v0' is possibly undefined
// 5CCBF0: variable 'v2' is possibly undefined
// 5CCEAC: variable 'v1' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 4441C: using guessed type Elf32_Sym stru_4441C;
// 66C6C: using guessed type Elf32_Sym stru_66C6C;
// 66E360: using guessed type char (*off_66E360[12])[64];
// A7D1F8: using guessed type char CWeather::Update(void)::bMaximumWaterFogIntensityReached;

//----- (005CD598) --------------------------------------------------------
void __fastcall CWeather::UpdateWeatherRegion(CVector *pCoors)
{
  CSimpleTransform *p_tx; // r3
  float x; // s2
  float y; // s0
  Int16 v4; // r0
  char v5; // r1
  char v6; // r2
  __int16 v7; // r0
  __int16 v8; // r1

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  if ( pCoors )
    p_tx = (CSimpleTransform *)pCoors;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  if ( p_tx->m_translate.x <= 1000.0 )
  {
    if ( x <= -850.0 || x >= 1000.0 || y <= 1280.0 )
    {
      if ( y >= 1430.0 || y <= -580.0 )
      {
        v5 = 0;
        v6 = 0;
        v7 = 0;
        if ( x < 3000.0 )
          v5 = 1;
        if ( x > 250.0 )
          v6 = 1;
        v8 = (unsigned __int8)(v5 & v6) & (y > -3000.0);
        if ( y < -850.0 )
          v7 = 1;
        v4 = v7 & v8;
      }
      else
      {
        v4 = 2;
      }
    }
    else
    {
      v4 = 4;
    }
  }
  else
  {
    v4 = 3;
  }
  CWeather::WeatherRegion = v4;
}

//----- (005CD6BC) --------------------------------------------------------
Int8 *CWeather::FindWeatherTypesList()
{
  unsigned int v0; // r0

  v0 = CWeather::WeatherRegion - 1;
  if ( v0 > 3 )
    return WeatherTypesListDefault;
  else
    return (Int8 *)off_66E380[v0];
}
// 66E380: using guessed type char (*off_66E380[4])[64];

//----- (005CD6EC) --------------------------------------------------------
void CWeather::AddRain()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  CSimpleTransform *p_tx; // r2
  CVehicle *PlayerVehicle; // r0
  char v5; // r2
  int v6; // r0
  float v7; // s0
  int v8; // r4
  float v9; // s20
  float v10; // s19
  unsigned __int8 v11; // r0
  float v12; // s0
  float v13; // r8
  float v14; // s0
  CSimpleTransform *p_m_transform; // r6
  RwReal v16; // s21
  float v17; // s0
  float y; // s2
  int v19; // r6
  float v20; // s2
  float xy; // s24
  CSimpleTransform *v22; // r1
  float yy; // s20
  float x; // s26
  float v25; // s22
  float z; // s18
  int v27; // [sp+24h] [bp-FCh]
  int v28; // [sp+34h] [bp-ECh]
  int v29; // [sp+38h] [bp-E8h]
  CVector vecStart; // [sp+3Ch] [bp-E4h] BYREF
  RwV3d_0 vel; // [sp+48h] [bp-D8h] BYREF
  FxPrtMult_c v32; // [sp+54h] [bp-CCh] BYREF
  CEntity *refEntityPtr; // [sp+70h] [bp-B0h] BYREF
  CColPoint colPoint; // [sp+74h] [bp-ACh] BYREF
  RwV3d_0 v35; // [sp+A0h] [bp-80h] BYREF
  RwV3d_0 pos; // [sp+B0h] [bp-70h] BYREF
  CRGBA v37; // [sp+BCh] [bp-64h] BYREF

  if ( !CCullZones::CamNoRain()
    && !CCullZones::PlayerNoRain()
    && CWeather::UnderWaterness <= 0.0
    && CGame::currArea == AREA_MAIN_MAP
    && (!FindPlayerPed(-1) || !FindPlayerPed(-1)->m_areaCode) )
  {
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    if ( p_tx->m_translate.z <= 900.0
      && (!CCamera::GetLookingLRBFirstPerson(&TheCamera)
       || (PlayerVehicle = FindPlayerVehicle(-1, 0)) == 0
       || !CVehicle::CarHasRoof(PlayerVehicle)) )
    {
      if ( CWeather::Rain > 0.0 )
      {
        v5 = 1;
LABEL_15:
        pPrevRain = v5;
        CWeather::StreamAfterRainTimer = 800;
        goto LABEL_19;
      }
      if ( pPrevRain == 1 )
      {
        if ( CWeather::StreamAfterRainTimer < 1 )
        {
          v5 = 0;
          goto LABEL_15;
        }
        --CWeather::StreamAfterRainTimer;
      }
LABEL_19:
      if ( CWeather::Wind > 1.01 && !CCullZones::CamNoRain() )
      {
        v6 = CCullZones::PlayerNoRain();
        if ( CWeather::UnderWaterness <= 0.0 && !v6 )
          CWeather::AddSandStormParticles();
      }
      if ( CWeather::Rain > 0.1 || CWeather::AddRain(void)::rainAlpha != 0.0 )
      {
        CRGBA::CRGBA(&v37, 0, 0, 0, 0);
        v7 = CWeather::Rain;
        v28 = (int)(float)(CWeather::Rain * 5.0);
        if ( v28 >= 1 )
        {
          v2.n64_u32[0] = 1109393408;
          v0.n64_f32[0] = CWeather::Rain * 10.0;
          v8 = 0;
          v0.n64_u64[0] = vmax_f32(v0, v2).n64_u64[0];
          v9 = v0.n64_f32[0] * 0.5;
          v27 = (int)(float)(CWeather::Rain + CWeather::Rain);
          do
          {
            FxPrtMult_c::FxPrtMult_c(&v32, 1.0, 1.0, 1.0, 0.25, 0.02, 0.0, 0.03);
            memset(&vel, 0, sizeof(vel));
            v10 = (float)(v9 * (float)((float)rand() * 4.6566e-10)) + 0.0;
            v11 = rand();
            v29 = v8;
            if ( (v11 & 1) != 0 )
              v12 = (float)(unsigned __int8)rand() * 0.024531;
            else
              v12 = (float)((float)(v11 - 128) * 0.00625) + TheCamera.Orientation;
            v13 = v12;
            v14 = v10 * sinf(v12);
            p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              p_m_transform = &TheCamera.m_transform;
            v16 = p_m_transform->m_translate.x + v14;
            v17 = cosf(v13);
            pos.x = v16;
            y = p_m_transform->m_translate.y;
            pos.z = 0.0;
            pos.y = y + (float)(v10 * v17);
            vecStart.x = v16 + 0.0;
            vecStart.z = 40.0;
            vecStart.y = pos.y + 0.0;
            if ( CWorld::ProcessVerticalLine(&vecStart, -40.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
            {
              pos.z = colPoint.m_vecPosition.z + 0.1;
              if ( v27 >= -14 )
              {
                v19 = -1;
                do
                {
                  v35 = pos;
                  v35.x = v35.x + (float)((float)((float)((float)rand() * 4.6566e-10) * 30.0) + -15.0);
                  v35.y = v35.y + (float)((float)((float)((float)rand() * 4.6566e-10) * 30.0) + -15.0);
                  rand();
                  FxSystem_c::AddParticle(g_fx.m_fxSysSplash, &v35, &vel, 0.0, &v32, -1.0, 1.2, 0.6, 0);
                  ++v19;
                }
                while ( v19 < v27 + 14 );
              }
            }
            ++v8;
          }
          while ( v29 + 1 != v28 );
          v7 = CWeather::Rain;
        }
        v20 = v7 * 0.2;
        v0.n64_f32[0] = CWeather::AddRain(void)::rainAlpha;
        if ( CWeather::AddRain(void)::rainAlpha < v20 )
        {
          v0.n64_f32[0] = CWeather::AddRain(void)::rainAlpha + 0.0025;
          CWeather::AddRain(void)::rainAlpha = CWeather::AddRain(void)::rainAlpha + 0.0025;
        }
        if ( v0.n64_f32[0] > v20 )
        {
          v0.n64_f32[0] = v0.n64_f32[0] + -0.0025;
          CWeather::AddRain(void)::rainAlpha = v0.n64_f32[0];
        }
        v1.n64_u32[0] = 0;
        v2.n64_u32[0] = 1.0;
        LODWORD(CWeather::AddRain(void)::rainAlpha) = vmin_f32(vmax_f32(v0, v1), v2).n64_u32[0];
        FxPrtMult_c::FxPrtMult_c(&v32, 0.9, 0.9, 1.0, CWeather::AddRain(void)::rainAlpha, 1.0, 0.0, 0.2);
        xy = TheCamera.m_cameraMatrix.xy;
        v22 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        yy = TheCamera.m_cameraMatrix.yy;
        if ( !TheCamera.m_pMat )
          v22 = &TheCamera.m_transform;
        x = v22->m_translate.x;
        v25 = v22->m_translate.y;
        z = v22->m_translate.z;
        if ( !(rand() % 3) )
        {
          pos.x = (float)(x + (float)(xy * 10.0)) + (float)((float)((float)((float)rand() * 4.6566e-10) * 40.0) + -20.0);
          pos.y = (float)(v25 + (float)(yy * 10.0))
                + (float)((float)((float)((float)rand() * 4.6566e-10) * 40.0) + -20.0);
          pos.z = (float)((float)((float)((float)rand() * 4.6566e-10) * 7.0) + -2.0) + z;
          vel.x = CWeather::WindDir.x * 15.0;
          vel.y = CWeather::WindDir.y * 15.0;
          vel.z = CWeather::WindDir.z * 15.0;
          FxSystem_c::AddParticle(g_fx.m_fxSysSand2, &pos, &vel, 0.0, &v32, -1.0, 1.2, 0.6, 0);
        }
      }
    }
  }
}
// 5CD8DE: variable 'v0' is possibly undefined
// 5CD8DE: variable 'v2' is possibly undefined
// 5CDB5E: variable 'v1' is possibly undefined
// A7D200: using guessed type char pPrevRain;

//----- (005CDD6C) --------------------------------------------------------
void CWeather::UpdateInTunnelness()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d8
  __int64 v3; // d9
  float v4; // s0
  CSimpleTransform *p_tx; // r2
  __int64 v6; // d16
  float m_heading; // r4
  char v8; // r0
  char v9; // r0
  float32x2_t v10; // d9
  float32x2_t v11; // d0
  float v12; // s6
  CVector v13; // [sp+0h] [bp-40h] BYREF
  CVector pVecStart; // [sp+10h] [bp-30h] BYREF
  unsigned __int64 v15; // [sp+20h] [bp-20h]
  __int64 v16; // [sp+28h] [bp-18h]

  if ( (CCullZones::CurrentFlags_Camera & 0x2000) != 0 )
  {
    v15 = v2.n64_u64[0];
    v16 = v3;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    *(_QWORD *)&pVecStart.x = *(_QWORD *)&p_tx->m_translate.x;
    pVecStart.z = 0.0;
    if ( TheCamera.m_pMat )
    {
      v6 = *(_QWORD *)&TheCamera.m_pMat->xy;
      v13.z = TheCamera.m_pMat->zy;
      *(_QWORD *)&v13.x = v6;
    }
    else
    {
      v13.z = 0.0;
      m_heading = TheCamera.m_transform.m_heading;
      v13.y = cosf(TheCamera.m_transform.m_heading);
      LODWORD(v13.x) = COERCE_UNSIGNED_INT(sinf(m_heading)) ^ 0x80000000;
    }
    v13.z = 0.0;
    CVector::Normalise(&v13);
    v2.n64_u32[0] = 1120403456;
    v13.x = pVecStart.x + (float)(v13.x * 100.0);
    v13.y = pVecStart.y + (float)(v13.y * 100.0);
    v13.z = (float)(v13.z * 100.0) + 0.0;
    v8 = `guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd1;
    __dmb(0xBu);
    if ( (v8 & 1) == 0
      && _cxa_guard_acquire((__guard *)&`guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd1) )
    {
      CWeather::UpdateInTunnelness(void)::TunnelEnd1.x = 85.0;
      CWeather::UpdateInTunnelness(void)::TunnelEnd1.y = -1020.0;
      CWeather::UpdateInTunnelness(void)::TunnelEnd1.z = 0.0;
      _cxa_guard_release((__guard *)&`guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd1);
    }
    v9 = `guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd2;
    __dmb(0xBu);
    if ( (v9 & 1) == 0
      && _cxa_guard_acquire((__guard *)&`guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd2) )
    {
      CWeather::UpdateInTunnelness(void)::TunnelEnd2.x = 1683.0;
      CWeather::UpdateInTunnelness(void)::TunnelEnd2.y = -1956.0;
      CWeather::UpdateInTunnelness(void)::TunnelEnd2.z = 0.0;
      _cxa_guard_release((__guard *)&`guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd2);
    }
    v0.n64_u32[0] = CCollision::DistToLine(&pVecStart, &v13, &CWeather::UpdateInTunnelness(void)::TunnelEnd1);
    v10.n64_u64[0] = vmin_f32(v0, v2).n64_u64[0];
    v0.n64_u32[0] = CCollision::DistToLine(&pVecStart, &v13, &CWeather::UpdateInTunnelness(void)::TunnelEnd2);
    v11.n64_u64[0] = vmin_f32(v10, v0).n64_u64[0];
    v1.n64_u32[0] = 1.0;
    v11.n64_f32[0] = v11.n64_f32[0] / 100.0;
    LODWORD(v4) = vmin_f32(v11, v1).n64_u32[0];
  }
  else
  {
    v4 = 0.0;
  }
  v12 = CTimer::ms_fTimeStep * 0.01;
  if ( fabsf(v4 - CWeather::InTunnelness) >= (float)(CTimer::ms_fTimeStep * 0.01) )
  {
    if ( (float)(v4 - CWeather::InTunnelness) < 0.0 )
      v12 = -v12;
    v4 = CWeather::InTunnelness + v12;
  }
  CWeather::InTunnelness = v4;
}
// 5CDD82: variable 'v2' is possibly undefined
// 5CDD82: variable 'v3' is possibly undefined
// 5CDEB6: variable 'v0' is possibly undefined
// 5CDECE: variable 'v1' is possibly undefined
// A7D218: using guessed type char `guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd1;
// A7D228: using guessed type char `guard variable for'CWeather::UpdateInTunnelness(void)::TunnelEnd2;

//----- (005CDF78) --------------------------------------------------------
void __fastcall CWeather::ForceWeather(Int16 Type)
{
  CWeather::ForcedWeatherType = Type;
}

//----- (005CDF88) --------------------------------------------------------
void __fastcall CWeather::ForceWeatherNow(Int16 Type)
{
  CWeather::OldWeatherType = Type;
  CWeather::ForcedWeatherType = Type;
  CWeather::NewWeatherType = Type;
}

//----- (005CDFB0) --------------------------------------------------------
void CWeather::SetWeatherToAppropriateTypeNow()
{
  Int16 v0; // r6
  char v1; // r1
  char v2; // r2
  __int16 v3; // r0
  __int16 v4; // r1
  char (*v5)[64]; // r2
  CVector v6; // [sp+4h] [bp-1Ch] BYREF

  FindPlayerCoors(&v6, -1);
  if ( v6.x <= 1000.0 )
  {
    if ( v6.x <= -850.0 || v6.x >= 1000.0 || v6.y <= 1280.0 )
    {
      if ( v6.y >= 1430.0 || v6.y <= -580.0 )
      {
        v1 = 0;
        v2 = 0;
        v3 = 0;
        if ( v6.x < 3000.0 )
          v1 = 1;
        if ( v6.x > 250.0 )
          v2 = 1;
        v4 = (unsigned __int8)(v1 & v2) & (v6.y > -3000.0);
        if ( v6.y < -850.0 )
          v3 = 1;
        v0 = v3 & v4;
      }
      else
      {
        v0 = 2;
      }
    }
    else
    {
      v0 = 4;
    }
  }
  else
  {
    v0 = 3;
  }
  v5 = off_66E360[(unsigned __int16)v0 ^ 4];
  CWeather::ForcedWeatherType = -1;
  CWeather::WeatherRegion = v0;
  CWeather::NewWeatherType = *(_BYTE *)v5;
  CWeather::OldWeatherType = CWeather::NewWeatherType;
}
// 66E360: using guessed type char (*off_66E360[12])[64];

//----- (005CE11C) --------------------------------------------------------
void CWeather::ReleaseWeather()
{
  CWeather::ForcedWeatherType = -1;
}

//----- (005CE134) --------------------------------------------------------
void CWeather::AddSandStormParticles()
{
  float yy; // s18
  CSimpleTransform *p_tx; // r3
  float xy; // s20
  float x; // s22
  float y; // s24
  float z; // s16
  RwV3d_0 vel; // [sp+14h] [bp-6Ch] BYREF
  RwV3d_0 pos; // [sp+20h] [bp-60h] BYREF
  FxPrtMult_c v8; // [sp+2Ch] [bp-54h] BYREF

  FxPrtMult_c::FxPrtMult_c(&v8, 0.67, 0.65, 0.55, 0.25, 1.0, 0.0, 0.2);
  yy = TheCamera.m_cameraMatrix.yy;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  xy = TheCamera.m_cameraMatrix.xy;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  if ( (MobileSettings::settings[0].value || (rand() & 1) != 0) && !(rand() % 3) )
  {
    pos.x = (float)(x + (float)(xy * 10.0)) + (float)((float)((float)((float)rand() * 4.6566e-10) * 40.0) + -20.0);
    pos.y = (float)(y + (float)(yy * 10.0)) + (float)((float)((float)((float)rand() * 4.6566e-10) * 40.0) + -20.0);
    pos.z = (float)((float)((float)((float)rand() * 4.6566e-10) * 7.0) + -2.0) + z;
    vel.x = CWeather::WindDir.x * 25.0;
    vel.y = CWeather::WindDir.y * 25.0;
    vel.z = CWeather::WindDir.z * 25.0;
    FxSystem_c::AddParticle(g_fx.m_fxSysSand2, &pos, &vel, 0.0, &v8, -1.0, 1.2, 0.6, 0);
  }
}

//----- (005CE2E4) --------------------------------------------------------
void CWeather::RenderRainStreaks()
{
  int v0; // r0
  int v1; // r1
  Int32 v2; // r2
  CMatrix *m_pMat; // r4
  CSimpleTransform *p_tx; // r1
  int v5; // r11
  int v6; // r10
  int v7; // r0
  CSimpleTransform *p_m_transform; // r1
  float x; // s24
  float xy; // s26
  CSimpleTransform *v11; // r4
  int v12; // s0
  float yy; // s24
  CSimpleTransform *v14; // r1
  float y; // s26
  float zy; // s24
  float z; // s26
  float v18; // s31
  float v19; // s24
  float v20; // s26
  int *v21; // r4
  float v22; // s19
  float v23; // s21
  float v24; // s23
  float v25; // s29
  Int32 v26; // r0
  __int16 v27; // r1
  int v28; // r6
  int v29; // r0
  Int32 v30; // r12
  int v31; // s2
  RwIm3DVertex *v32; // r2
  int v33; // r3
  int *v34; // r4
  float v35; // s4
  float v36; // s0
  float v37; // s12
  float v38; // s10
  float v39; // s8
  float v40; // s0
  int v41; // r0
  int v42; // s0
  bool v43; // cc
  unsigned __int8 v44; // r0
  int v45; // [sp+38h] [bp-68h]
  int v46; // [sp+3Ch] [bp-64h]

  if ( !CTimer::m_CodePause )
  {
    v0 = CWeather::CurrentRainParticleStrength;
    v1 = (int)(float)((float)((float)(64.0 - (float)CTimeCycle::m_FogReduction) * 0.015625)
                    * (float)(int)(float)(CWeather::Rain * 110.0));
    if ( CWeather::CurrentRainParticleStrength < v1 )
      v0 = ++CWeather::CurrentRainParticleStrength;
    if ( v0 > v1 )
      CWeather::CurrentRainParticleStrength = --v0;
    v2 = v0;
    if ( v0 <= 0 )
      v2 = 0;
    CWeather::CurrentRainParticleStrength = v2;
    if ( v0 >= 1
      && !CCullZones::CamNoRain()
      && !CCullZones::PlayerNoRain()
      && CWeather::UnderWaterness <= 0.0
      && CGame::currArea == AREA_MAIN_MAP )
    {
      m_pMat = TheCamera.m_pMat;
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      if ( p_tx->m_translate.z <= 900.0 )
      {
        TempBufferVerticesStored = 0;
        TempBufferIndicesStored = 0;
        if ( !CWeather::RenderRainStreaks(void)::xCoor )
        {
          CWeather::RenderRainStreaks(void)::xCoor = 1;
          memset(CWeather::RenderRainStreaks(void)::yCoor, 0, sizeof(CWeather::RenderRainStreaks(void)::yCoor));
          memset(CWeather::RenderRainStreaks(void)::xCoor, 0, sizeof(CWeather::RenderRainStreaks(void)::xCoor));
          memset(CWeather::RenderRainStreaks(void)::zCoor, 0, sizeof(CWeather::RenderRainStreaks(void)::zCoor));
          memset(
            CWeather::RenderRainStreaks(void)::rainAlpha,
            (unsigned int)(float)((float)CWeather::CurrentRainParticleStrength * 0.6),
            sizeof(CWeather::RenderRainStreaks(void)::rainAlpha));
        }
        v5 = 0;
        while ( 1 )
        {
          v6 = CWeather::RenderRainStreaks(void)::zCoor[v5];
          v7 = CWeather::RenderRainStreaks(void)::xCoor[v5];
          p_m_transform = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_m_transform = &TheCamera.m_transform;
          x = p_m_transform->m_translate.x;
          if ( v6 < 1
            || !CWeather::RenderRainStreaks(void)::rainAlpha[v5]
            || sqrtf(
                 (float)((float)((float)((float)CWeather::RenderRainStreaks(void)::xCoor[v5] - x)
                               * (float)((float)CWeather::RenderRainStreaks(void)::xCoor[v5] - x))
                       + (float)((float)((float)CWeather::RenderRainStreaks(void)::yCoor[v5]
                                       - p_m_transform->m_translate.y)
                               * (float)((float)CWeather::RenderRainStreaks(void)::yCoor[v5]
                                       - p_m_transform->m_translate.y)))
               + (float)((float)((float)CWeather::RenderRainStreaks(void)::zCoor[v5] - p_m_transform->m_translate.z)
                       * (float)((float)CWeather::RenderRainStreaks(void)::zCoor[v5] - p_m_transform->m_translate.z))) > 8.0 )
          {
            xy = TheCamera.m_cameraMatrix.xy;
            v11 = &TheCamera.m_transform;
            v12 = (int)(float)((float)(x + (float)(xy * 6.0))
                             + (float)((float)((float)((float)rand() * 4.6566e-10) * 5.0) + -2.5));
            yy = TheCamera.m_cameraMatrix.yy;
            v14 = &TheCamera.m_transform;
            CWeather::RenderRainStreaks(void)::xCoor[v5] = v12;
            if ( TheCamera.m_pMat )
              v14 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            y = v14->m_translate.y;
            CWeather::RenderRainStreaks(void)::yCoor[v5] = (int)(float)((float)(y + (float)(yy * 6.0))
                                                                      + (float)((float)((float)((float)rand()
                                                                                              * 4.6566e-10)
                                                                                      * 5.0)
                                                                              + -2.5));
            if ( TheCamera.m_pMat )
              v11 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            z = v11->m_translate.z;
            zy = TheCamera.m_cameraMatrix.zy;
            v6 = (int)(float)((float)(z + (float)(zy * 6.0))
                            + (float)((float)((float)((float)rand() * 4.6566e-10) * 5.0) + -2.5));
            CWeather::RenderRainStreaks(void)::zCoor[v5] = v6;
            CWeather::RenderRainStreaks(void)::rainAlpha[v5] = (unsigned int)(float)((float)CWeather::CurrentRainParticleStrength
                                                                                   * 0.6);
            v7 = CWeather::RenderRainStreaks(void)::xCoor[v5];
          }
          v18 = (float)v7;
          if ( v5 << 31 )
          {
            v20 = 0.1;
            v19 = CWeather::Wind;
          }
          else
          {
            v19 = CWeather::Rain * 0.1;
            v20 = CWeather::Wind;
          }
          v21 = &CWeather::RenderRainStreaks(void)::yCoor[v5];
          v22 = CWeather::WindDir.x;
          v23 = CWeather::WindDir.y;
          v24 = CWeather::WindDir.z;
          v25 = (float)*v21;
          v46 = rand();
          v26 = TempBufferIndicesStored;
          v27 = TempBufferVerticesStored;
          TempBufferRenderIndexList[TempBufferIndicesStored] = TempBufferVerticesStored;
          TempBufferRenderIndexList[v26 + 1] = v27 + 1;
          v45 = rand();
          v28 = rand();
          v29 = rand();
          v30 = TempBufferVerticesStored;
          v31 = *v21;
          v32 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
          v33 = CWeather::RenderRainStreaks(void)::rainAlpha[v5];
          v32->color = (RwRGBA_0)((v33 << 24) | 0xE6D2D2);
          v34 = &CWeather::RenderRainStreaks(void)::zCoor[v5];
          v35 = (float)*v34;
          v36 = (float)CWeather::RenderRainStreaks(void)::xCoor[v5];
          v32[1].color = (RwRGBA_0)((v33 << 23) & 0x7F000000 | 0xE6D2D2);
          TempBufferVerticesStored = v30 + 2;
          TempBufferIndicesStored += 2;
          v37 = (float)((float)((float)v45 * 4.6566e-10) * 0.4) + -0.2;
          v38 = (float)((float)((float)v28 * 4.6566e-10) * 0.4) + -0.2;
          v39 = (float)((float)((float)v29 * 4.6566e-10) * 0.2) + -0.1;
          v32->position.x = v37 + v36;
          v32->position.y = v38 + (float)v31;
          v32->position.z = v39 + v35;
          v32[1].position.x = (float)(v18 - (float)((float)(v20 * v19) * v22)) + v37;
          v32[1].position.y = (float)(v25 - (float)((float)(v20 * v19) * v23)) + v38;
          v32[1].position.z = (float)((float)((float)v6 - (float)((float)(v20 * v19) * v24))
                                    + (float)((float)((float)((float)v46 * 4.6566e-10) * 0.4) + 0.1))
                            + v39;
          *v34 = (int)(float)((float)*v34 - (float)((float)((float)((float)rand() * 4.6566e-10) * 0.09) + 0.01));
          v40 = (float)(unsigned __int16)rand();
          v41 = CWeather::RenderRainStreaks(void)::rainAlpha[v5];
          v42 = (int)(float)((float)(v40 * 0.000015259) * 3.0);
          v43 = v41 <= v42 + 2;
          v44 = v41 - (v42 + 2);
          if ( v43 )
            v44 = 0;
          CWeather::RenderRainStreaks(void)::rainAlpha[v5] = v44;
          if ( !MobileSettings::settings[0].value )
            ++v5;
          if ( ++v5 > 127 )
            break;
          m_pMat = TheCamera.m_pMat;
        }
        if ( TempBufferIndicesStored )
        {
          RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
          RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
          RwRenderStateSet(rwRENDERSTATEFOGTYPE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
          RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
          RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
          if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 8u) )
          {
            RwIm3DRenderIndexedPrimitive(rwPRIMTYPELINELIST, TempBufferRenderIndexList, TempBufferIndicesStored);
            RwIm3DEnd();
          }
          RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
          RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
          RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
          RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
        }
        TempBufferVerticesStored = 0;
        TempBufferIndicesStored = 0;
      }
    }
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 6B2560: using guessed type int CWeather::RenderRainStreaks(void)::yCoor[128];
// 6B2760: using guessed type int CWeather::RenderRainStreaks(void)::xCoor[128];
// 6B2960: using guessed type int CWeather::RenderRainStreaks(void)::zCoor[128];
// 6B2B60: using guessed type unsigned __int8 CWeather::RenderRainStreaks(void)::rainAlpha[128];
// A7D208: using guessed type char CWeather::RenderRainStreaks(void)::xCoor;

//----- (005CEAA8) --------------------------------------------------------
bool __fastcall CWeather::ForecastWeather(Int32 WeatherType, Int32 HoursAhead)
{
  unsigned int v2; // r3
  int v3; // r2
  Int8 *v4; // r6

  if ( HoursAhead < 0 )
    return 0;
  v2 = CWeather::WeatherRegion - 1;
  v3 = -1;
  while ( 1 )
  {
    v4 = WeatherTypesListDefault;
    if ( v2 <= 3 )
      v4 = (Int8 *)off_66E380[v2];
    if ( v4[(CWeather::WeatherTypeInList + v3 + 1) % 64] == WeatherType )
      break;
    if ( ++v3 >= HoursAhead )
      return 0;
  }
  return 1;
}
// 66E380: using guessed type char (*off_66E380[4])[64];

//----- (005CEB28) --------------------------------------------------------
void __fastcall CAEAudioEntity::~CAEAudioEntity(CAEAudioEntity *this)
{
  this->_vptr$CAEAudioEntity = (int (**)(void))&off_667798;
  CAESound::~CAESound(&this->ScratchSound);
}
// 667798: using guessed type void *off_667798;

//----- (005CEB4C) --------------------------------------------------------
void __fastcall CWindModifiers::RegisterOne(CVector Coors, Int32 Type, float Multiplier)
{
  Int32 v3; // r12
  CSimpleTransform *p_tx; // r5

  v3 = CWindModifiers::Number;
  if ( CWindModifiers::Number <= 15 )
  {
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    if ( sqrtf(
           (float)((float)((float)(Coors.x - p_tx->m_translate.x) * (float)(Coors.x - p_tx->m_translate.x))
                 + (float)((float)(Coors.y - p_tx->m_translate.y) * (float)(Coors.y - p_tx->m_translate.y)))
         + (float)((float)(Coors.z - p_tx->m_translate.z) * (float)(Coors.z - p_tx->m_translate.z))) < 200.0 )
    {
      CWindModifiers::Array[CWindModifiers::Number].Coors.x = Coors.x;
      LODWORD(Coors.x) = &CWindModifiers::Array[v3];
      *(RwReal *)(LODWORD(Coors.x) + 4) = Coors.y;
      *(RwReal *)(LODWORD(Coors.x) + 8) = Coors.z;
      *(_DWORD *)(LODWORD(Coors.x) + 12) = Type;
      *(float *)(LODWORD(Coors.x) + 16) = Multiplier;
      CWindModifiers::Number = v3 + 1;
    }
  }
}

//----- (005CEC10) --------------------------------------------------------
int __fastcall CWindModifiers::FindWindModifier(CVector Coors, float *pX, float *pY)
{
  float v4; // s16
  float z; // s0
  float v6; // s18
  float v7; // s2
  float x; // s4
  float y; // s6
  int v10; // r2
  RwReal *p_z; // r0
  Int32 v12; // r1
  float v13; // s15
  float v14; // s9
  float v15; // s11
  float v16; // s13
  float v17; // s15
  float v18; // s16
  float v19; // s15
  int v20; // s0
  int result; // r0
  float v22; // s0

  if ( CWindModifiers::Number < 1 )
    return 0;
  v4 = 0.0;
  z = Coors.z;
  v6 = 0.0;
  v7 = Coors.z + 15.0;
  x = Coors.x;
  y = Coors.y;
  v10 = 0;
  p_z = &CWindModifiers::Array[0].Coors.z;
  v12 = 0;
  do
  {
    if ( *((_DWORD *)p_z + 1) == 1 )
    {
      v13 = fabsf(v7 - *p_z);
      if ( v13 < 40.0 )
      {
        v14 = x - *(p_z - 2);
        v15 = y - *(p_z - 1);
        v16 = sqrtf((float)((float)(v14 * v14) + (float)(v15 * v15)) + (float)((float)(z - *p_z) * (float)(z - *p_z)));
        if ( v16 < 50.0 )
        {
          v17 = (float)(v13 / -40.0) + 1.0;
          v18 = 1.0;
          if ( v16 >= 20.0 )
            v18 = (float)((float)(v16 + -20.0) / -30.0) + 1.0;
          v10 = 1;
          v19 = (float)(v17 * 0.2) * (float)(v18 * p_z[2]);
          v4 = (float)(v15 * v19) / v16;
          v6 = (float)(v14 * v19) / v16;
        }
      }
    }
    ++v12;
    p_z += 5;
  }
  while ( v12 < CWindModifiers::Number );
  if ( !(v10 << 31) )
    return 0;
  v20 = (rand() & 0x1F) - 16;
  result = 1;
  v22 = (float)((float)v20 * 0.0005) + 1.0;
  *pX = *pX + (float)(v6 * v22);
  *pY = *pY + (float)(v4 * v22);
  return result;
}

//----- (005CED90) --------------------------------------------------------
float __fastcall CalcNewDeltaVal(RwV2d_0 *pStartPoint, RwV2d_0 *pEndPoint)
{
  float v2; // s6

  v2 = 0.0;
  if ( fabsf((float)(pEndPoint->x - pStartPoint->x) / (float)(pEndPoint->y - pStartPoint->y)) != INFINITY )
    return (float)(pEndPoint->x - pStartPoint->x) / (float)(pEndPoint->y - pStartPoint->y);
  return v2;
}

//----- (005CEDD4) --------------------------------------------------------
void __fastcall CWorldScan::ScanWorld(RwV2d_0 *Points, Int32 NumPoints, void (*HitFunc)(Int32, Int32))
{
  RwV2d_0 *v3; // r4
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  unsigned __int64 v6; // d9
  Int32 v7; // r5
  int v8; // r6
  Int32 v10; // lr
  Int32 v11; // r0
  RwV2d_0 *v12; // r10
  Int32 v13; // r6
  int v14; // r1
  Int32 v15; // r0
  unsigned int v16; // r9
  unsigned int v17; // r3
  RwV2d_0 v18; // d17
  RwV2d_0 v19; // d18
  RwV2d_0 v20; // d19
  RwV2d_0 *v21; // r2
  RwV2d_0 *v22; // r4
  RwV2d_0 *v23; // r1
  int v24; // r0
  unsigned __int32 *p_y; // r0
  int v26; // r1
  bool v27; // nf
  float v28; // s16
  float32x2_t v29; // d12
  RwV2d_0 *i; // r8
  int v31; // r11
  float v32; // s16
  float *v33; // r0
  int v34; // r2
  int v35; // r9
  float v36; // s0
  int v37; // r1
  float v38; // r4
  float v39; // s22
  Int32 v40; // r10
  float v41; // s18
  int v42; // r6
  int v43; // r5
  float *v44; // r4
  int v45; // r5
  float v46; // s24
  float v47; // s20
  float *v48; // r8
  float v49; // r4
  float v50; // s16
  int v51; // s0
  int v52; // r6
  int v53; // r0
  float *v54; // r4
  int v55; // r5
  float v56; // s26
  float v57; // s22
  float v58; // r11
  float *v59; // r9
  float v60; // s18
  int v61; // s0
  int v62; // s2
  float v63; // s28
  float v64; // s30
  float v65; // s17
  float v66; // r4
  float v67; // s0
  float v68; // s20
  float v69; // s2
  float v70; // s22
  float v71; // s24
  int v72; // r6
  float v73; // s26
  int v74; // r0
  int v75; // r11
  int v76; // r0
  Int32 v77; // r8
  Int32 v78; // r0
  int v79; // r2
  Int32 v80; // r1
  bool v81; // zf
  int v82; // r3
  int v83; // r1
  unsigned int v84; // r12
  Int32 *v85; // r6
  Int32 *v86; // r2
  unsigned int v87; // r4
  __int64 v88; // d17
  __int64 v89; // d17
  Int32 *v90; // r3
  Int32 *v91; // r2
  int *v93; // r4
  int v94; // r11
  float v95; // s28
  float v96; // s30
  float v97; // r4
  float v98; // r0
  float v99; // r0
  float v100; // s0
  int v101; // r6
  float *v102; // r4
  float v103; // s24
  float v104; // r0
  float *v105; // r11
  float v106; // s20
  int v107; // s28
  int v108; // s0
  float v109; // s28
  float v110; // s30
  float v111; // r0
  int v112; // r0
  float v113; // s0
  float v114; // s0
  int v115; // r6
  float *v116; // r5
  float v117; // s26
  float v118; // r0
  float *v119; // r4
  float v120; // s22
  int v121; // s28
  int v122; // s0
  float v123; // s28
  float v124; // s30
  float v125; // r0
  int v126; // r0
  int v127; // r6
  float v128; // r0
  Int32 v129; // r4
  float *v130; // [sp+4h] [bp-CCh]
  int v131; // [sp+Ch] [bp-C4h]
  int v132; // [sp+10h] [bp-C0h]
  int v133; // [sp+14h] [bp-BCh]
  int v134; // [sp+18h] [bp-B8h]
  int v135; // [sp+18h] [bp-B8h]
  int v136; // [sp+18h] [bp-B8h]
  int v138; // [sp+34h] [bp-9Ch]
  int v139; // [sp+3Ch] [bp-94h]
  int v140; // [sp+3Ch] [bp-94h]
  RwReal x; // [sp+40h] [bp-90h] BYREF
  RwReal y; // [sp+44h] [bp-8Ch]
  int v143; // [sp+4Ch] [bp-84h] BYREF
  int v144; // [sp+68h] [bp-68h]
  char v145; // [sp+6Ch] [bp-64h]

  v7 = NumPoints;
  v8 = 0;
  v145 = 0;
  v144 = 0;
  if ( NumPoints >= 2 )
  {
    v10 = 0;
    do
    {
      v11 = v10++;
      if ( v10 < v7 )
      {
        v12 = &Points[v11];
        v13 = v10;
        do
        {
          v3 = &Points[v13];
          if ( v12->x == v3->x && v12->y == v3->y )
          {
            if ( v13 < --v7 )
            {
              v14 = v7 - v13;
              v15 = v13;
              if ( (unsigned int)(v7 - v13) < 4 )
                goto LABEL_13;
              v16 = v14 & 0xFFFFFFFC;
              v15 = v13;
              if ( (v14 & 0xFFFFFFFC) == 0 )
                goto LABEL_13;
              v15 = v13 + v16;
              v17 = v14 & 0xFFFFFFFC;
              do
              {
                v17 -= 4;
                v18 = v3[2];
                v19 = v3[3];
                v20 = v3[4];
                v21 = v3 + 4;
                *v3 = v3[1];
                v3[1] = v18;
                v22 = v3 + 2;
                *v22 = v19;
                v22[1] = v20;
                v3 = v21;
              }
              while ( v17 );
              if ( v14 != v16 )
              {
LABEL_13:
                v23 = &Points[v15 + 1];
                v24 = v7 - v15;
                do
                {
                  --v24;
                  v23[-1] = *v23;
                  ++v23;
                }
                while ( v24 );
              }
            }
            --v13;
          }
          ++v13;
        }
        while ( v13 < v7 );
      }
    }
    while ( v10 < v7 - 1 );
    if ( v7 < 2 )
    {
      v8 = 0;
    }
    else
    {
      p_y = (unsigned __int32 *)&Points[1].y;
      v4.n64_u32[0] = LODWORD(Points->y);
      v26 = 1;
      v8 = 0;
      do
      {
        v5.n64_u32[0] = *p_y;
        p_y += 2;
        v27 = v5.n64_f32[0] < v4.n64_f32[0];
        v4.n64_u64[0] = vmin_f32(v5, v4).n64_u64[0];
        if ( v27 )
          v8 = v26;
        ++v26;
      }
      while ( v7 != v26 );
    }
  }
  v28 = 0.0;
  x = Points[v8].x;
  LODWORD(v6) = 1203982323;
  y = Points[v8].y;
  *((_BYTE *)&v144 + v8) = 1;
  v139 = 0;
  v138 = 1;
  if ( v7 >= 1 )
    goto LABEL_28;
LABEL_40:
  v29.n64_u32[0] = 1203982323;
  while ( !*((_BYTE *)&v144 + (_DWORD)v3) )
  {
    v28 = v28 + v29.n64_f32[0];
    v8 = (int)v3;
    *(&x + 2 * v138) = Points[(_DWORD)v3].x;
    *(&x + 2 * v138 + 1) = Points[(_DWORD)v3].y;
    *((_BYTE *)&v144 + (_DWORD)v3) = 1;
    ++v138;
    ++v139;
    if ( v7 < 1 )
      goto LABEL_40;
LABEL_28:
    v29.n64_u64[0] = v6;
    for ( i = 0; i != (RwV2d_0 *)v7; i = (RwV2d_0 *)((char *)i + 1) )
    {
      if ( i != (RwV2d_0 *)v8 )
      {
        for ( v4.n64_f32[0] = CGeneral::GetATanOfXY(
                                Points[(_DWORD)i].x - Points[v8].x,
                                Points[(_DWORD)i].y - Points[v8].y)
                            - v28; v4.n64_f32[0] < 0.0; v4.n64_f32[0] = v4.n64_f32[0] + 6.2832 )
          ;
        while ( v4.n64_f32[0] >= 6.2832 )
          v4.n64_f32[0] = v4.n64_f32[0] + -6.2832;
        v27 = v4.n64_f32[0] < v29.n64_f32[0];
        v29.n64_u64[0] = vmin_f32(v4, v29).n64_u64[0];
        if ( v27 )
          v3 = i;
      }
    }
  }
  v31 = v138;
  if ( v138 < 3 )
    return;
  v32 = y;
  v33 = (float *)&v143;
  v34 = v139;
  v35 = 0;
  v36 = y;
  v37 = 1;
  do
  {
    if ( *v33 >= v36 )
    {
      if ( *v33 > v32 )
        v32 = *v33;
    }
    else
    {
      v35 = v37;
      v36 = *v33;
    }
    v33 += 2;
    --v34;
    ++v37;
  }
  while ( v34 );
  v38 = floorf(v36);
  v39 = floorf(v32);
  v40 = 9999;
  v41 = v38;
  v42 = 1;
  v133 = v35;
  do
  {
    v43 = v133;
    v44 = &x + 2 * v133;
    if ( v133 < 1 )
      v43 = v138;
    v45 = v43 - 1;
    v46 = *v44;
    if ( *v44 < (float)v40 )
      v40 = (int)floorf(*v44);
    v47 = v44[1];
    v48 = &x + 2 * v45;
    v49 = floorf(v47);
    v133 = v45;
    v50 = v48[1];
    v51 = (int)floorf(v50);
    if ( v42 >= v138 )
      break;
    ++v42;
  }
  while ( (int)v49 == v51 );
  v132 = v35;
  v52 = 1;
  v131 = (int)v39;
  v134 = (int)v41;
  v140 = -9999;
  do
  {
    v53 = v140;
    v54 = &x + 2 * v132;
    v55 = v132 + 1;
    v56 = *v54;
    if ( v132 + 1 == v31 )
      v55 = 0;
    if ( v56 > (float)v140 )
      v53 = (int)floorf(*v54);
    v57 = v54[1];
    v140 = v53;
    v58 = floorf(v57);
    v59 = &x + 2 * v55;
    v132 = v55;
    v60 = v59[1];
    v61 = (int)floorf(v60);
    v62 = (int)v58;
    v31 = v138;
    if ( v52 >= v138 )
      break;
    ++v52;
  }
  while ( v62 == v61 );
  v63 = (float)(*v59 - v56) / (float)(v60 - v57);
  v64 = (float)(*v48 - v46) / (float)(v50 - v47);
  v65 = fabsf(v63);
  v66 = ceilf(v57);
  v67 = ceilf(v47) - v47;
  v68 = 0.0;
  v69 = v66 - v57;
  v70 = 0.0;
  if ( fabsf(v64) != INFINITY )
    v68 = v64;
  v71 = v46 + (float)(v67 * v68);
  if ( v65 != INFINITY )
    v70 = v63;
  v72 = v134;
  v73 = v56 + (float)(v69 * v70);
  if ( v134 == v131 )
    goto LABEL_72;
  if ( v68 < 0.0 )
  {
    v74 = (int)floorf(v71);
    if ( v40 > v74 )
      v40 = v74;
  }
  if ( v70 < 0.0 )
  {
LABEL_72:
    v75 = v140;
  }
  else
  {
    v75 = v140;
    v76 = (int)floorf(v73);
    if ( v140 < v76 )
      v75 = v76;
  }
  if ( v134 > v131 )
    goto LABEL_154;
LABEL_76:
  while ( 2 )
  {
    v130 = &x + 2 * v132;
    while ( 1 )
    {
      v77 = v72;
      if ( v40 <= v75 )
      {
        while ( 1 )
        {
          HitFunc(v40, v77);
          v78 = NumExtraBlocks;
          if ( NumExtraBlocks >= 1 )
            break;
LABEL_97:
          if ( v40++ >= v75 )
            goto LABEL_98;
        }
        v79 = 0;
        while ( 1 )
        {
          v80 = ExtraBlocksX[v79];
          v81 = v40 == v80;
          if ( v40 == v80 )
            v81 = v77 == ExtraBlocksY[v79];
          if ( !v81 )
            goto LABEL_96;
          if ( v79 < --v78 )
          {
            v82 = v78 - v79;
            if ( (unsigned int)(v78 - v79) > 3 )
            {
              v84 = v82 & 0xFFFFFFFC;
              if ( (v82 & 0xFFFFFFFC) != 0 )
              {
                v83 = v79 + v84;
                v85 = &ExtraBlocksX[v79];
                v86 = &ExtraBlocksY[v79];
                v87 = v82 & 0xFFFFFFFC;
                do
                {
                  v87 -= 4;
                  v88 = *(_QWORD *)(v85 + 3);
                  *(_QWORD *)v85 = *(_QWORD *)(v85 + 1);
                  *((_QWORD *)v85 + 1) = v88;
                  v85 += 4;
                  v89 = *(_QWORD *)(v86 + 3);
                  *(_QWORD *)v86 = *(_QWORD *)(v86 + 1);
                  *((_QWORD *)v86 + 1) = v89;
                  v86 += 4;
                }
                while ( v87 );
                if ( v82 == v84 )
                  goto LABEL_95;
              }
              else
              {
                v83 = v79;
              }
            }
            else
            {
              v83 = v79;
            }
            v90 = &ExtraBlocksY[v83 + 1];
            v91 = &ExtraBlocksX[v83 + 1];
            do
            {
              ++v83;
              *(v91 - 1) = *v91;
              ++v91;
              *(v90 - 1) = *v90;
              ++v90;
            }
            while ( v83 < v78 );
          }
LABEL_95:
          v79 = 4;
          NumExtraBlocks = v78;
LABEL_96:
          if ( ++v79 >= v78 )
            goto LABEL_97;
        }
      }
LABEL_98:
      v93 = (int *)(&x + 2 * v133);
      v72 = v77 + 1;
      v71 = v68 + v71;
      if ( v77 + 1 != (int)floorf(*((float *)v93 + 1)) )
      {
        if ( v68 >= 0.0 )
LABEL_108:
          v99 = v71 - v68;
        else
          v99 = v71;
        v40 = (int)floorf(v99);
        goto LABEL_125;
      }
      if ( v72 == v131 )
      {
        if ( v68 >= 0.0 )
          goto LABEL_108;
        v135 = v77 + 1;
        v94 = v133;
        v95 = *(float *)v93;
        do
        {
          if ( v94 < 1 )
            v94 = v138;
          --v94;
          v96 = *(&x + 2 * v94);
          v97 = floorf(v96);
          v98 = floorf(v95);
          v95 = v96;
          v40 = (int)v98;
        }
        while ( (int)v98 > (int)v97 );
        v133 = v94;
      }
      else
      {
        v100 = v68 < 0.0 ? *(float *)v93 : v71 - v68;
        v135 = v77 + 1;
        v101 = v133;
        v40 = (int)floorf(v100);
        do
        {
          v102 = &x + 2 * v101;
          v103 = *v102;
          if ( v101 < 1 )
            v101 = v138;
          --v101;
          v104 = floorf(*v102);
          v105 = &x + 2 * v101;
          v106 = v105[1];
          v107 = (int)v104;
          v108 = (int)floorf(v106);
          if ( v40 > v107 )
            v40 = v107;
        }
        while ( v135 == v108 );
        v109 = v102[1];
        v133 = v101;
        v110 = (float)(*v105 - v103) / (float)(v106 - v109);
        v111 = ceilf(v109);
        v68 = 0.0;
        if ( fabsf(v110) != INFINITY )
          v68 = v110;
        v71 = v103 + (float)((float)(v111 - v109) * v68);
        if ( v68 < 0.0 )
        {
          v112 = (int)floorf(v71);
          if ( v40 > v112 )
            v40 = v112;
        }
      }
      v72 = v135;
LABEL_125:
      v73 = v70 + v73;
      if ( v72 != (int)floorf(v130[1]) )
      {
        v113 = v73;
        if ( v70 < 0.0 )
          v113 = v73 - v70;
        goto LABEL_132;
      }
      if ( v72 != v131 )
        break;
      if ( v70 >= 0.0 )
      {
        v127 = v132;
        do
        {
          v128 = floorf(*(&x + 2 * v127++));
          if ( v127 == v138 )
            v127 = 0;
          v75 = (int)v128;
        }
        while ( (int)v128 < (int)floorf(*(&x + 2 * v127)) );
        v132 = v127;
        v72 = v131;
        if ( v77 >= v131 )
          goto LABEL_154;
        goto LABEL_76;
      }
      v113 = v73 - v70;
LABEL_132:
      v75 = (int)floorf(v113);
      if ( v77 >= v131 )
        goto LABEL_154;
    }
    if ( v70 >= 0.0 )
      v114 = *v130;
    else
      v114 = v73 - v70;
    v136 = v72;
    v115 = v132;
    v75 = (int)floorf(v114);
    do
    {
      v116 = &x + 2 * v115++;
      v117 = *v116;
      if ( v115 == v138 )
        v115 = 0;
      v118 = floorf(*v116);
      v119 = &x + 2 * v115;
      v120 = v119[1];
      v121 = (int)v118;
      v122 = (int)floorf(v120);
      if ( v75 < v121 )
        v75 = v121;
    }
    while ( v136 == v122 );
    v123 = v116[1];
    v132 = v115;
    v124 = (float)(*v119 - v117) / (float)(v120 - v123);
    v125 = ceilf(v123);
    v70 = 0.0;
    if ( fabsf(v124) != INFINITY )
      v70 = v124;
    v73 = v117 + (float)((float)(v125 - v123) * v70);
    if ( v70 >= 0.0 )
    {
      v126 = (int)floorf(v73);
      if ( v75 < v126 )
        v75 = v126;
    }
    v72 = v136;
    if ( v77 < v131 )
      continue;
    break;
  }
LABEL_154:
  if ( NumExtraBlocks >= 1 )
  {
    v129 = 0;
    do
    {
      HitFunc(ExtraBlocksX[v129], ExtraBlocksY[v129]);
      ++v129;
    }
    while ( v129 < NumExtraBlocks );
  }
  NumExtraBlocks = 0;
}
// 5CEEC2: variable 'v5' is possibly undefined
// 5CEEC2: variable 'v4' is possibly undefined
// 5CEF16: variable 'v3' is possibly undefined
// 5CEF3E: variable 'v6' is possibly undefined

//----- (005CF740) --------------------------------------------------------
void __fastcall CWorldScan::SetExtraRectangleToScan(float MinX, float MaxX, float MinY, float MaxY)
{
  float v7; // s16
  int v8; // r8
  unsigned int v9; // r4
  float v10; // s16
  int32x4_t v11; // q8
  int v12; // r1
  unsigned int v13; // r2
  unsigned int v14; // r9
  int32x4_t v15; // q8
  int32x4_t v16; // q9
  Int32 *v17; // lr
  Int32 v18; // r10
  unsigned int v19; // r0
  Int32 v20; // r12
  int32x4_t v21; // q11
  Int32 *v22; // r5
  int32x4_t v23; // q10
  Int32 *v24; // lr
  Int32 *v25; // r0
  unsigned int v26; // r3
  Int32 *v27; // r5
  Int32 *v28; // r3

  v7 = floorf(MinX);
  v8 = (int)ceilf(MaxX);
  v9 = (int)v7;
  if ( (int)v7 < v8 )
  {
    v10 = floorf(MinY);
    v11.n128_u64[0] = 0x100000000LL;
    v11.n128_u64[1] = 0x300000002LL;
    v12 = (int)ceilf(MaxY);
    v13 = v12 - (int)v10;
    v14 = v13 & 0xFFFFFFFC;
    v15 = vaddq_s32(vdupq_n_s32((int)v10), v11);
    v16.n128_u64[0] = 0x400000004LL;
    v16.n128_u64[1] = 0x400000004LL;
    v17 = ExtraBlocksY;
    do
    {
      if ( v12 > (int)v10 )
      {
        v18 = NumExtraBlocks;
        v19 = (int)v10;
        v20 = NumExtraBlocks;
        if ( v13 < 4 )
          goto LABEL_9;
        v20 = NumExtraBlocks;
        v19 = (int)v10;
        if ( !v14 )
          goto LABEL_9;
        v21 = v15;
        v22 = v17;
        v20 = NumExtraBlocks + v14;
        v23 = vdupq_n_s32(v9);
        v24 = &ExtraBlocksY[NumExtraBlocks];
        v25 = &ExtraBlocksX[NumExtraBlocks];
        v26 = v13 & 0xFFFFFFFC;
        do
        {
          *(int32x4_t *)v24 = v21;
          v24 += 4;
          v26 -= 4;
          v21 = vaddq_s32(v21, v16);
          *(int32x4_t *)v25 = v23;
          v25 += 4;
        }
        while ( v26 );
        v19 = (v13 & 0xFFFFFFFC) + (int)v10;
        v17 = v22;
        if ( v13 != v14 )
        {
LABEL_9:
          v27 = &v17[v20];
          v28 = &ExtraBlocksX[v20];
          do
          {
            *v27++ = v19++;
            *v28++ = v9;
          }
          while ( v12 != v19 );
        }
        NumExtraBlocks = v13 + v18;
      }
      ++v9;
    }
    while ( v9 != v8 );
  }
}

//----- (005CF8A8) --------------------------------------------------------
void CCullZones::Init()
{
  CCullZones::CurrentFlags_Player = 0;
  CCullZones::NumAttributeZones = 0;
  CCullZones::CurrentFlags_Camera = 0;
}

//----- (005CF8D0) --------------------------------------------------------
void CCullZones::Update()
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v1; // r0
  CVector v2; // [sp+4h] [bp-14h] BYREF
  CVector v3; // 0:r0.12

  if ( (CTimer::m_FrameCounter & 7) == 6 )
  {
    FindPlayerCoors(&v2, -1);
    CCullZones::CurrentFlags_Player = CCullZones::FindAttributesForCoors(v2);
    if ( (CCullZones::CurrentFlags_Player & 0x1000) != 0 && !CCullZones::bMilitaryZonesDisabled )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPed::IsAlive(PlayerPed) )
      {
        v1 = FindPlayerPed(-1);
        CPlayerPed::SetWantedLevelNoDrop(v1, 5);
      }
    }
  }
  else if ( (CTimer::m_FrameCounter & 7) == 2 )
  {
    v3 = *CCamera::GetGameCamPosition(&TheCamera);
    CCullZones::CurrentFlags_Camera = CCullZones::FindAttributesForCoors(v3);
  }
}

//----- (005CF96C) --------------------------------------------------------
Int32 __fastcall CCullZones::FindAttributesForCoors(CVector TestCoors)
{
  float x; // s0
  float z; // s4
  Int32 v3; // r2
  float y; // s2
  Int16 *p_Flags; // r1
  Int32 result; // r0
  float v7; // s6
  float v8; // s8
  float v9; // s10
  float v10; // s6

  if ( CCullZones::NumAttributeZones < 1 )
    return 0;
  x = TestCoors.x;
  z = TestCoors.z;
  TestCoors.z = 0.0;
  y = TestCoors.y;
  p_Flags = &CCullZones::aAttributeZones[0].Flags;
  result = 0;
  do
  {
    if ( z > (float)*(p_Flags - 2) && z < (float)*(p_Flags - 1) )
    {
      v7 = y - (float)*(p_Flags - 7);
      v8 = x - (float)*(p_Flags - 8);
      v9 = (float)(v8 * (float)*(p_Flags - 6)) + (float)(v7 * (float)*(p_Flags - 5));
      if ( v9 >= 0.0 && v9 <= (float)(*(p_Flags - 6) * *(p_Flags - 6) + *(p_Flags - 5) * *(p_Flags - 5)) )
      {
        v10 = (float)(v8 * (float)*(p_Flags - 4)) + (float)(v7 * (float)*(p_Flags - 3));
        if ( v10 >= 0.0 && v10 <= (float)(*(p_Flags - 4) * *(p_Flags - 4) + *(p_Flags - 3) * *(p_Flags - 3)) )
          result |= *p_Flags;
      }
    }
    ++v3;
    p_Flags += 9;
  }
  while ( v3 < CCullZones::NumAttributeZones );
  return result;
}

//----- (005CFA94) --------------------------------------------------------
CVector *__fastcall CZoneDef::FindCenter(CVector *retstr, CZoneDef *this)
{
  RwReal v2; // s2
  RwReal v3; // s0

  v2 = (float)((float)((float)this->Vec1Y * 0.5) + (float)this->CornerY) + (float)((float)this->Vec2Y * 0.5);
  v3 = (float)(this->MaxZ + this->MinZ) * 0.5;
  retstr->x = (float)((float)((float)this->Vec1X * 0.5) + (float)this->CornerX) + (float)((float)this->Vec2X * 0.5);
  retstr->y = v2;
  retstr->z = v3;
  return retstr;
}

//----- (005CFB28) --------------------------------------------------------
void __fastcall CZoneDef::FindBoundingBox(CZoneDef *this, CVector *pMin, CVector *pMax)
{
  unsigned __int16 Vec1Y; // lr
  int Vec2X; // r4
  int Vec1X; // r3
  int Vec2Y; // r3

  Vec1Y = 0;
  pMin->x = (float)(this->CornerX
                  + (__int16)(this->Vec1X & ((unsigned int)this->Vec1X >> 15))
                  + (__int16)(this->Vec2X & ((unsigned int)this->Vec2X >> 15)));
  Vec2X = this->Vec2X;
  Vec1X = this->Vec1X;
  if ( Vec2X <= 0 )
    LOWORD(Vec2X) = 0;
  if ( Vec1X <= 0 )
    LOWORD(Vec1X) = 0;
  pMax->x = (float)(this->CornerX + (unsigned __int16)Vec1X + (unsigned __int16)Vec2X);
  pMin->y = (float)(this->CornerY
                  + (__int16)(this->Vec1Y & ((unsigned int)this->Vec1Y >> 15))
                  + (__int16)(this->Vec2Y & ((unsigned int)this->Vec2Y >> 15)));
  Vec2Y = this->Vec2Y;
  if ( Vec2Y <= 0 )
    LOWORD(Vec2Y) = 0;
  if ( this->Vec1Y > 0 )
    Vec1Y = this->Vec1Y;
  pMax->y = (float)(this->CornerY + Vec1Y + (unsigned __int16)Vec2Y);
  pMin->z = (float)this->MinZ;
  pMax->z = (float)this->MaxZ;
}

//----- (005CFBFA) --------------------------------------------------------
bool __fastcall CZoneDef::IsPointWithin(CZoneDef *this, CVector TestCoors)
{
  float v2; // s0
  float v3; // s2
  float v4; // s4
  int Vec2X; // r1
  int Vec2Y; // r0
  float v7; // s0
  bool result; // r0

  result = 0;
  if ( TestCoors.z > (float)this->MinZ && TestCoors.z < (float)this->MaxZ )
  {
    v2 = TestCoors.y - (float)this->CornerY;
    v3 = TestCoors.x - (float)this->CornerX;
    v4 = (float)(v3 * (float)this->Vec1X) + (float)(v2 * (float)this->Vec1Y);
    if ( v4 >= 0.0 && v4 <= (float)(this->Vec1X * this->Vec1X + this->Vec1Y * this->Vec1Y) )
    {
      Vec2X = this->Vec2X;
      Vec2Y = this->Vec2Y;
      v7 = (float)(v3 * (float)Vec2X) + (float)(v2 * (float)Vec2Y);
      if ( v7 >= 0.0 && v7 <= (float)((__int16)Vec2X * (__int16)Vec2X + (__int16)Vec2Y * (__int16)Vec2Y) )
        return 1;
    }
  }
  return result;
}

//----- (005CFCF0) --------------------------------------------------------
Int32 __fastcall CCullZones::FindTunnelAttributesForCoors(CVector TestCoors)
{
  float x; // s0
  float z; // s4
  Int32 v3; // r2
  float y; // s2
  Int16 *p_Flags; // r1
  Int32 result; // r0
  float v7; // s6
  float v8; // s8
  float v9; // s10
  float v10; // s6

  if ( CCullZones::NumTunnelAttributeZones < 1 )
    return 0;
  x = TestCoors.x;
  z = TestCoors.z;
  TestCoors.z = 0.0;
  y = TestCoors.y;
  p_Flags = &CCullZones::aTunnelAttributeZones[0].Flags;
  result = 0;
  do
  {
    if ( z > (float)*(p_Flags - 2) && z < (float)*(p_Flags - 1) )
    {
      v7 = y - (float)*(p_Flags - 7);
      v8 = x - (float)*(p_Flags - 8);
      v9 = (float)(v8 * (float)*(p_Flags - 6)) + (float)(v7 * (float)*(p_Flags - 5));
      if ( v9 >= 0.0 && v9 <= (float)(*(p_Flags - 6) * *(p_Flags - 6) + *(p_Flags - 5) * *(p_Flags - 5)) )
      {
        v10 = (float)(v8 * (float)*(p_Flags - 4)) + (float)(v7 * (float)*(p_Flags - 3));
        if ( v10 >= 0.0 && v10 <= (float)(*(p_Flags - 4) * *(p_Flags - 4) + *(p_Flags - 3) * *(p_Flags - 3)) )
          result |= *p_Flags;
      }
    }
    ++v3;
    p_Flags += 9;
  }
  while ( v3 < CCullZones::NumTunnelAttributeZones );
  return result;
}

//----- (005CFE18) --------------------------------------------------------
CMirrorAttributeZone *__fastcall CCullZones::FindMirrorAttributesForCoors(CVector TestCoors)
{
  float x; // s0
  float y; // s2
  float v3; // s6
  float v4; // s8
  float v5; // s10
  float v6; // s6

  if ( CCullZones::NumMirrorAttributeZones < 1 )
  {
LABEL_10:
    TestCoors.x = 0.0;
  }
  else
  {
    x = TestCoors.x;
    y = TestCoors.y;
    TestCoors.y = 0.0;
    LODWORD(TestCoors.x) = CCullZones::aMirrorAttributeZones;
    while ( 1 )
    {
      if ( TestCoors.z > (float)*(__int16 *)(LODWORD(TestCoors.x) + 12)
        && TestCoors.z < (float)*(__int16 *)(LODWORD(TestCoors.x) + 14) )
      {
        v3 = y - (float)*(__int16 *)(LODWORD(TestCoors.x) + 2);
        v4 = x - (float)(__int16)*(_WORD *)LODWORD(TestCoors.x);
        v5 = (float)(v4 * (float)*(__int16 *)(LODWORD(TestCoors.x) + 4))
           + (float)(v3 * (float)*(__int16 *)(LODWORD(TestCoors.x) + 6));
        if ( v5 >= 0.0
          && v5 <= (float)(*(__int16 *)(LODWORD(TestCoors.x) + 4) * *(__int16 *)(LODWORD(TestCoors.x) + 4)
                         + *(__int16 *)(LODWORD(TestCoors.x) + 6) * *(__int16 *)(LODWORD(TestCoors.x) + 6)) )
        {
          v6 = (float)(v4 * (float)*(__int16 *)(LODWORD(TestCoors.x) + 8))
             + (float)(v3 * (float)*(__int16 *)(LODWORD(TestCoors.x) + 10));
          if ( v6 >= 0.0
            && v6 <= (float)(*(__int16 *)(LODWORD(TestCoors.x) + 8) * *(__int16 *)(LODWORD(TestCoors.x) + 8)
                           + *(__int16 *)(LODWORD(TestCoors.x) + 10) * *(__int16 *)(LODWORD(TestCoors.x) + 10)) )
          {
            break;
          }
        }
      }
      ++LODWORD(TestCoors.y);
      LODWORD(TestCoors.x) += 24;
      if ( SLODWORD(TestCoors.y) >= CCullZones::NumMirrorAttributeZones )
        goto LABEL_10;
    }
  }
  return (CMirrorAttributeZone *)LODWORD(TestCoors.x);
}

//----- (005CFF30) --------------------------------------------------------
CAttributeZone *CCullZones::FindZoneWithStairsAttributeForPlayer()
{
  int v0; // r2
  CAttributeZone *result; // r0
  float v2; // s6
  float v3; // s8
  float v4; // s10
  float v5; // s6
  CVector v6; // [sp+4h] [bp-14h] BYREF

  FindPlayerCoors(&v6, -1);
  if ( CCullZones::NumAttributeZones < 1 )
    return 0;
  v0 = 0;
  for ( result = CCullZones::aAttributeZones; ; ++result )
  {
    if ( (result->Flags & 2) != 0 && v6.z > (float)result->ZoneDef.MinZ && v6.z < (float)result->ZoneDef.MaxZ )
    {
      v2 = v6.y - (float)result->ZoneDef.CornerY;
      v3 = v6.x - (float)result->ZoneDef.CornerX;
      v4 = (float)(v3 * (float)result->ZoneDef.Vec1X) + (float)(v2 * (float)result->ZoneDef.Vec1Y);
      if ( v4 >= 0.0
        && v4 <= (float)(result->ZoneDef.Vec1X * result->ZoneDef.Vec1X + result->ZoneDef.Vec1Y * result->ZoneDef.Vec1Y) )
      {
        v5 = (float)(v3 * (float)result->ZoneDef.Vec2X) + (float)(v2 * (float)result->ZoneDef.Vec2Y);
        if ( v5 >= 0.0
          && v5 <= (float)(result->ZoneDef.Vec2X * result->ZoneDef.Vec2X + result->ZoneDef.Vec2Y * result->ZoneDef.Vec2Y) )
        {
          break;
        }
      }
    }
    if ( ++v0 >= CCullZones::NumAttributeZones )
      return 0;
  }
  return result;
}

//----- (005D0058) --------------------------------------------------------
void __fastcall CCullZones::AddCullZone(
        const CVector *posn,
        float ArgVec1X,
        float ArgVec1Y,
        float ArgMinZ,
        float ArgVec2X,
        float ArgVec2Y,
        float ArgMaxZ,
        unsigned int ArgFlags,
        Int16 ArgWantedLevelDrop)
{
  unsigned int v9; // r12
  Int32 v12; // r2
  Int32 v13; // r4
  CAttributeZone *v14; // r1
  float v15; // s12
  Int32 v16; // r2
  Int32 v17; // r1
  float y; // s12
  CAttributeZone *v19; // r0

  v9 = ArgFlags;
  if ( (ArgFlags & 0x880) != 0 )
  {
    v12 = CCullZones::NumTunnelAttributeZones;
    v13 = CCullZones::NumTunnelAttributeZones;
    CCullZones::aTunnelAttributeZones[CCullZones::NumTunnelAttributeZones].ZoneDef.CornerX = (int)(float)((float)(posn->x - ArgVec1X) - ArgVec2X);
    v14 = &CCullZones::aTunnelAttributeZones[v13];
    v15 = (float)(posn->y - ArgVec1Y) - ArgVec2Y;
    v14->ZoneDef.Vec1X = (int)(float)(ArgVec1X + ArgVec1X);
    v14->ZoneDef.Vec1Y = (int)(float)(ArgVec1Y + ArgVec1Y);
    v14->ZoneDef.MinZ = (int)ArgMinZ;
    v14->ZoneDef.Vec2X = (int)(float)(ArgVec2X + ArgVec2X);
    v14->ZoneDef.Vec2Y = (int)(float)(ArgVec2Y + ArgVec2Y);
    v14->ZoneDef.MaxZ = (int)ArgMaxZ;
    v14->Flags = ArgFlags;
    v9 = ArgFlags & 0xFFFFF77F;
    v14->ZoneDef.CornerY = (int)v15;
    CCullZones::NumTunnelAttributeZones = v12 + 1;
  }
  if ( v9 )
  {
    v16 = CCullZones::NumAttributeZones;
    v17 = CCullZones::NumAttributeZones;
    CCullZones::aAttributeZones[CCullZones::NumAttributeZones].ZoneDef.CornerX = (int)(float)((float)(posn->x - ArgVec1X)
                                                                                            - ArgVec2X);
    y = posn->y;
    v19 = &CCullZones::aAttributeZones[v17];
    v19->ZoneDef.Vec1X = (int)(float)(ArgVec1X + ArgVec1X);
    v19->ZoneDef.Vec1Y = (int)(float)(ArgVec1Y + ArgVec1Y);
    v19->ZoneDef.MinZ = (int)ArgMinZ;
    v19->ZoneDef.Vec2X = (int)(float)(ArgVec2X + ArgVec2X);
    v19->ZoneDef.Vec2Y = (int)(float)(ArgVec2Y + ArgVec2Y);
    v19->ZoneDef.MaxZ = (int)ArgMaxZ;
    v19->Flags = v9;
    v19->ZoneDef.CornerY = (int)(float)((float)(y - ArgVec1Y) - ArgVec2Y);
    CCullZones::NumAttributeZones = v16 + 1;
  }
}

//----- (005D01D8) --------------------------------------------------------
void __fastcall CCullZones::AddTunnelAttributeZone(
        const CVector *posn,
        float ArgVec1X,
        float ArgVec1Y,
        float ArgMinZ,
        float ArgVec2X,
        float ArgVec2Y,
        float ArgMaxZ,
        UInt16 ArgFlags)
{
  Int32 v9; // r5
  Int32 v10; // r4
  CAttributeZone *v11; // r1
  float y; // s2

  v9 = CCullZones::NumTunnelAttributeZones;
  v10 = CCullZones::NumTunnelAttributeZones;
  CCullZones::aTunnelAttributeZones[CCullZones::NumTunnelAttributeZones].ZoneDef.CornerX = (int)(float)((float)(posn->x - ArgVec1X) - ArgVec2X);
  v11 = &CCullZones::aTunnelAttributeZones[v10];
  y = posn->y;
  v11->ZoneDef.Vec1X = (int)(float)(ArgVec1X + ArgVec1X);
  v11->ZoneDef.Vec1Y = (int)(float)(ArgVec1Y + ArgVec1Y);
  v11->ZoneDef.MinZ = (int)ArgMinZ;
  v11->ZoneDef.Vec2X = (int)(float)(ArgVec2X + ArgVec2X);
  v11->ZoneDef.Vec2Y = (int)(float)(ArgVec2Y + ArgVec2Y);
  v11->ZoneDef.MaxZ = (int)ArgMaxZ;
  v11->Flags = ArgFlags;
  v11->ZoneDef.CornerY = (int)(float)((float)(y - ArgVec1Y) - ArgVec2Y);
  CCullZones::NumTunnelAttributeZones = v9 + 1;
}

//----- (005D02A0) --------------------------------------------------------
void __fastcall CCullZones::AddMirrorAttributeZone(
        const CVector *posn,
        float ArgVec1X,
        float ArgVec1Y,
        float ArgMinZ,
        float ArgVec2X,
        float ArgVec2Y,
        float ArgMaxZ,
        UInt16 ArgFlags,
        float ArgMirrorV,
        float ArgMirrorNormalX,
        float ArgMirrorNormalY,
        float ArgMirrorNormalZ)
{
  Int32 v13; // lr
  float v14; // s4
  Int32 v15; // r2
  CMirrorAttributeZone *v16; // r1
  float y; // s6

  v13 = CCullZones::NumMirrorAttributeZones;
  v14 = ArgVec1X + ArgVec1X;
  v15 = CCullZones::NumMirrorAttributeZones;
  CCullZones::aMirrorAttributeZones[CCullZones::NumMirrorAttributeZones].ZoneDef.CornerX = (int)(float)((float)(posn->x - ArgVec1X) - ArgVec2X);
  v16 = &CCullZones::aMirrorAttributeZones[v15];
  y = posn->y;
  v16->ZoneDef.Vec1X = (int)v14;
  v16->ZoneDef.Vec1Y = (int)(float)(ArgVec1Y + ArgVec1Y);
  v16->ZoneDef.MinZ = (int)ArgMinZ;
  v16->ZoneDef.Vec2X = (int)(float)(ArgVec2X + ArgVec2X);
  v16->ZoneDef.Vec2Y = (int)(float)(ArgVec2Y + ArgVec2Y);
  v16->ZoneDef.MaxZ = (int)ArgMaxZ;
  v16->Flags = ArgFlags;
  v16->MirrorV = ArgMirrorV;
  v16->MirrorNormalX = (int)(float)(ArgMirrorNormalX * 100.0);
  v16->MirrorNormalY = (int)(float)(ArgMirrorNormalY * 100.0);
  v16->MirrorNormalZ = (int)(float)(ArgMirrorNormalZ * 100.0);
  v16->ZoneDef.CornerY = (int)(float)((float)(y - ArgVec1Y) - ArgVec2Y);
  CCullZones::NumMirrorAttributeZones = v13 + 1;
}

//----- (005D03AC) --------------------------------------------------------
int CCullZones::CamCloseInForPlayer()
{
  return CCullZones::CurrentFlags_Player & 1;
}

//----- (005D03C0) --------------------------------------------------------
int CCullZones::CamStairsForPlayer()
{
  return ((unsigned __int8)CCullZones::CurrentFlags_Player >> 1) & 1;
}

//----- (005D03D4) --------------------------------------------------------
int CCullZones::Cam1stPersonForPlayer()
{
  return ((unsigned __int8)CCullZones::CurrentFlags_Player >> 2) & 1;
}

//----- (005D03E8) --------------------------------------------------------
int CCullZones::NoPolice()
{
  return ((unsigned __int8)CCullZones::CurrentFlags_Player >> 4) & 1;
}

//----- (005D03FC) --------------------------------------------------------
int CCullZones::PoliceAbandonCars()
{
  return BYTE1(CCullZones::CurrentFlags_Player) & 1;
}

//----- (005D0410) --------------------------------------------------------
int CCullZones::InRoomForAudio()
{
  return (BYTE1(CCullZones::CurrentFlags_Camera) >> 1) & 1;
}

//----- (005D0424) --------------------------------------------------------
int CCullZones::FewerCars()
{
  return BYTE1(CCullZones::CurrentFlags_Player) >> 7;
}

//----- (005D0434) --------------------------------------------------------
int CCullZones::FewerPeds()
{
  return (BYTE1(CCullZones::CurrentFlags_Player) >> 2) & 1;
}

//----- (005D0448) --------------------------------------------------------
int CCullZones::DoINeedToLoadCollision()
{
  return ((unsigned __int8)CCullZones::CurrentFlags_Player >> 6) & 1;
}

//----- (005D045C) --------------------------------------------------------
int CCullZones::CamNoRain()
{
  return ((unsigned __int8)CCullZones::CurrentFlags_Camera >> 3) & 1;
}

//----- (005D0470) --------------------------------------------------------
int CCullZones::PlayerNoRain()
{
  return ((unsigned __int8)CCullZones::CurrentFlags_Player >> 3) & 1;
}

//----- (005D0484) --------------------------------------------------------
int CCullZones::DoExtraAirResistanceForPlayer()
{
  return (BYTE1(CCullZones::CurrentFlags_Player) >> 6) & 1;
}

//----- (005D0498) --------------------------------------------------------
int __fastcall IsPointWithinArbitraryArea(
        float TestPointX,
        float TestPointY,
        float Point1X,
        float Point1Y,
        float Point2X,
        float Point2Y,
        float Point3X,
        float Point3Y,
        float Point4X,
        float Point4Y)
{
  int result; // r0

  if ( (float)((float)((float)(TestPointX - Point1X) * (float)(Point2Y - Point1Y))
             - (float)((float)(TestPointY - Point1Y) * (float)(Point2X - Point1X))) < 0.0
    || (float)((float)((float)(TestPointX - Point2X) * (float)(Point3Y - Point2Y))
             - (float)((float)(TestPointY - Point2Y) * (float)(Point3X - Point2X))) < 0.0 )
  {
    return 0;
  }
  result = 0;
  if ( (float)((float)((float)(TestPointX - Point3X) * (float)(Point4Y - Point3Y))
             - (float)((float)(TestPointY - Point3Y) * (float)(Point4X - Point3X))) >= 0.0
    && (float)((float)((float)(TestPointX - Point4X) * (float)(Point1Y - Point4Y))
             - (float)((float)(Point1X - Point4X) * (float)(TestPointY - Point4Y))) >= 0.0 )
  {
    return 1;
  }
  return result;
}

//----- (005D0564) --------------------------------------------------------
bool __fastcall RpClumpStreamReadAtomics(RwStream_0 *pStream, LoadAtomicCallback atomCB)
{
  return 1;
}

//----- (005D0568) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpGtaStreamRead(RwStream_0 *pStream)
{
  RpClump_0 *v2; // r11
  RpClump_0 *v3; // r6
  RwInt32 v4; // r4
  rpGeometryList_0 *v5; // r6
  RpGeometry_0 *v6; // r0
  int v7; // r6
  RpAtomic_0 *v8; // r1
  RwInt32 numGeoms; // r2
  RpGeometry_0 **geometries; // r0
  RwInt32 v11; // r4
  RwInt32 v12; // r2
  RpGeometry_0 **v13; // r0
  RwInt32 v14; // r4
  RwInt32 v15; // r2
  RwInt32 v16; // r4
  RwUInt32 v18; // [sp+0h] [bp-50h] BYREF
  rpGeometryList_0 v19; // [sp+4h] [bp-4Ch] BYREF
  rwFrameList_0 frameList; // [sp+Ch] [bp-44h] BYREF
  int buffer[3]; // [sp+14h] [bp-3Ch] BYREF
  RwUInt32 versionOut; // [sp+20h] [bp-30h] BYREF
  RwUInt32 lengthOut; // [sp+24h] [bp-2Ch] BYREF
  RwUInt32 v24; // [sp+28h] [bp-28h] BYREF
  RwUInt32 v25; // [sp+2Ch] [bp-24h] BYREF
  RwInt32 v26[8]; // [sp+30h] [bp-20h] BYREF

  if ( !RwStreamFindChunk(pStream, 1u, &lengthOut, &versionOut) || RwStreamRead(pStream, buffer, 0xCu) != 12 )
    return 0;
  v2 = RpClumpCreate();
  v3 = 0;
  if ( !v2 || !RwStreamFindChunk(pStream, 0xEu, 0, &v18) )
    return v3;
  if ( !_rwFrameListStreamRead(pStream, &frameList) )
  {
LABEL_49:
    RpClumpDestroy(v2);
    return 0;
  }
  if ( !RwStreamFindChunk(pStream, 0x1Au, 0, &v18) )
    goto LABEL_48;
  if ( !RwStreamFindChunk(pStream, 1u, &v25, &v24) || RwStreamRead(pStream, v26, 4u) != 4 )
    goto LABEL_17;
  v19.numGeoms = v26[0];
  if ( v26[0] < 1 )
  {
    v19.geometries = 0;
    if ( &v18 == (RwUInt32 *)-4 )
      goto LABEL_48;
    goto LABEL_19;
  }
  v19.geometries = (RpGeometry_0 **)CMemoryMgr::Malloc(4 * v26[0]);
  if ( !v19.geometries )
  {
LABEL_17:
    v5 = 0;
    goto LABEL_18;
  }
  if ( v26[0] >= 1 )
  {
    v4 = 0;
    do
    {
      v5 = 0;
      if ( !RwStreamFindChunk(pStream, 0xFu, 0, &v24) )
        break;
      v6 = RpGeometryStreamRead(pStream);
      v19.geometries[v4] = v6;
      if ( !v6 )
        goto LABEL_17;
      ++v4;
      v5 = &v19;
    }
    while ( v4 < v26[0] );
LABEL_18:
    if ( v5 )
      goto LABEL_19;
    goto LABEL_48;
  }
  if ( &v18 == (RwUInt32 *)-4 )
  {
LABEL_48:
    _rwFrameListDeinitialize(&frameList);
    goto LABEL_49;
  }
LABEL_19:
  v2->object.parent = *frameList.frames;
  if ( buffer[0] < 1 )
  {
LABEL_24:
    numGeoms = v19.numGeoms;
    if ( v19.numGeoms )
    {
      geometries = v19.geometries;
      if ( v19.numGeoms >= 1 )
      {
        v11 = 0;
        do
        {
          if ( geometries[v11] )
          {
            RpGeometryDestroy(geometries[v11]);
            geometries = v19.geometries;
            numGeoms = v19.numGeoms;
          }
          ++v11;
        }
        while ( v11 < numGeoms );
      }
      CMemoryMgr::Free(geometries);
    }
    v19.numGeoms = 0;
    _rwFrameListDeinitialize(&frameList);
    return v2;
  }
  else
  {
    v7 = 0;
    while ( 1 )
    {
      if ( !RwStreamFindChunk(pStream, 0x14u, 0, &versionOut) )
      {
        v12 = v19.numGeoms;
        if ( !v19.numGeoms )
          goto LABEL_46;
        v13 = v19.geometries;
        if ( v19.numGeoms >= 1 )
        {
          v14 = 0;
          do
          {
            if ( v13[v14] )
            {
              RpGeometryDestroy(v13[v14]);
              v13 = v19.geometries;
              v12 = v19.numGeoms;
            }
            ++v14;
          }
          while ( v14 < v12 );
        }
        goto LABEL_45;
      }
      v8 = ClumpAtomicGtaStreamRead(pStream, &frameList, &v19);
      if ( !v8 )
        break;
      RpClumpAddAtomic(v2, v8);
      if ( ++v7 >= buffer[0] )
        goto LABEL_24;
    }
    v15 = v19.numGeoms;
    if ( !v19.numGeoms )
      goto LABEL_46;
    v13 = v19.geometries;
    if ( v19.numGeoms >= 1 )
    {
      v16 = 0;
      do
      {
        if ( v13[v16] )
        {
          RpGeometryDestroy(v13[v16]);
          v13 = v19.geometries;
          v15 = v19.numGeoms;
        }
        ++v16;
      }
      while ( v16 < v15 );
    }
LABEL_45:
    CMemoryMgr::Free(v13);
LABEL_46:
    v3 = 0;
    v19.numGeoms = 0;
    _rwFrameListDeinitialize(&frameList);
    RpClumpDestroy(v2);
  }
  return v3;
}
// 5D0568: using guessed type int buffer[3];
// 5D0568: using guessed type RwInt32 var_20[8];

//----- (005D074C) --------------------------------------------------------
RpAtomic_0 *__fastcall ClumpAtomicGtaStreamRead(RwStream_0 *pStream, rwFrameList_0 *fl, rpGeometryList_0 *gl)
{
  RwUInt32 v6; // r4
  RpAtomic_0 *v7; // r0
  RpAtomic_0 *v8; // r4
  RpGeometry_0 *v9; // r5
  int v11[2]; // [sp+0h] [bp-28h] BYREF
  int v12; // [sp+8h] [bp-20h]
  RwUInt32 versionOut; // [sp+10h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+14h] [bp-14h] BYREF

  if ( !RwStreamFindChunk(pStream, 1u, lengthOut, &versionOut) )
    return 0;
  v6 = lengthOut[0];
  if ( v6 != RwStreamRead(pStream, v11, lengthOut[0]) )
    return 0;
  v7 = RpAtomicCreate();
  v8 = v7;
  if ( !v7 )
    return 0;
  v7->object.object.flags = v12;
  if ( fl->numFrames )
    RpAtomicSetFrame(v7, fl->frames[v11[0]]);
  if ( !gl->numGeoms )
  {
    if ( RwStreamFindChunk(pStream, 0xFu, 0, &versionOut) )
    {
      v9 = RpGeometryStreamRead(pStream);
      if ( v9 )
      {
        RpAtomicSetGeometry(v8, v9, 0);
        RpGeometryDestroy(v9);
        return v8;
      }
    }
    RpAtomicDestroy(v8);
    return 0;
  }
  RpAtomicSetGeometry(v8, gl->geometries[v11[1]], 0);
  return v8;
}
// 5D074C: using guessed type RwUInt32 lengthOut[5];

//----- (005D07EC) --------------------------------------------------------
bool __fastcall RpClumpGtaStreamRead1(RwStream_0 *pStream)
{
  bool v2; // r5
  RpGeometry_0 **v3; // r0
  int v4; // r6
  RpGeometry_0 *v5; // r0
  RwUInt32 v7; // [sp+0h] [bp-30h] BYREF
  RwUInt32 versionOut; // [sp+4h] [bp-2Ch] BYREF
  RwUInt32 lengthOut; // [sp+8h] [bp-28h] BYREF
  RwUInt32 v10; // [sp+Ch] [bp-24h] BYREF
  RwUInt32 v11; // [sp+10h] [bp-20h] BYREF
  RwInt32 buffer[7]; // [sp+14h] [bp-1Ch] BYREF

  if ( !RwStreamFindChunk(pStream, 1u, &lengthOut, &versionOut) )
    return 0;
  v2 = 0;
  if ( RwStreamRead(pStream, &gClumpInfo, 0xCu) == 12 )
  {
    if ( RwStreamFindChunk(pStream, 0xEu, 0, &v7) )
    {
      v2 = 0;
      if ( _rwFrameListStreamRead(pStream, &gFrameList) )
      {
        if ( RwStreamFindChunk(pStream, 0x1Au, 0, &v7) )
        {
          numberGeometrys = 0;
          if ( RwStreamFindChunk(pStream, 1u, &v11, &v10) )
          {
            if ( RwStreamRead(pStream, buffer, 4u) == 4 )
            {
              gGeomList.numGeoms = buffer[0];
              numberGeometrys = buffer[0] / 2;
              if ( buffer[0] < 1 )
              {
                gGeomList.geometries = 0;
                if ( buffer[0] / 2 < 1 )
                {
LABEL_18:
                  v2 = 1;
                  streamPosition = pStream->Type.memory.position;
                  return v2;
                }
                goto LABEL_14;
              }
              v3 = (RpGeometry_0 **)CMemoryMgr::Malloc(4 * buffer[0]);
              gGeomList.geometries = v3;
              if ( v3 )
              {
                memset(v3, 0, 4 * buffer[0]);
                if ( numberGeometrys < 1 )
                  goto LABEL_18;
LABEL_14:
                v4 = 0;
                while ( RwStreamFindChunk(pStream, 0xFu, 0, &v10) )
                {
                  v5 = RpGeometryStreamRead(pStream);
                  gGeomList.geometries[v4] = v5;
                  if ( !v5 )
                    break;
                  if ( ++v4 >= numberGeometrys )
                    goto LABEL_18;
                }
              }
            }
          }
        }
        _rwFrameListDeinitialize(&gFrameList);
        return 0;
      }
    }
  }
  return v2;
}
// 5D07EC: using guessed type RwInt32 buffer[7];

//----- (005D094C) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpGtaStreamRead2(RwStream_0 *pStream)
{
  RpClump_0 *v2; // r8
  int v3; // r6
  RpGeometry_0 *v4; // r0
  int v5; // r6
  RpAtomic_0 *v6; // r1
  RwInt32 v7; // r2
  RpGeometry_0 **v8; // r0
  RwInt32 v9; // r4
  RpClump_0 *v10; // r5
  RwInt32 numGeoms; // r2
  RpGeometry_0 **geometries; // r0
  RwInt32 v13; // r4
  RwInt32 v14; // r2
  RpGeometry_0 **v15; // r0
  RwInt32 v16; // r4
  RwInt32 v17; // r2
  RpGeometry_0 **v18; // r0
  RwInt32 v19; // r4
  RwUInt32 v21; // [sp+4h] [bp-24h] BYREF
  RwUInt32 versionOut[8]; // [sp+8h] [bp-20h] BYREF

  v2 = RpClumpCreate();
  if ( !v2 )
    return 0;
  RwStreamSkip(pStream, streamPosition - pStream->Type.memory.position);
  v3 = numberGeometrys;
  if ( numberGeometrys < gGeomList.numGeoms )
  {
    while ( RwStreamFindChunk(pStream, 0xFu, 0, versionOut) )
    {
      v4 = RpGeometryStreamRead(pStream);
      gGeomList.geometries[v3] = v4;
      if ( !v4 )
        break;
      if ( ++v3 >= gGeomList.numGeoms )
        goto LABEL_6;
    }
    numGeoms = gGeomList.numGeoms;
    if ( gGeomList.numGeoms )
    {
      geometries = gGeomList.geometries;
      if ( gGeomList.numGeoms >= 1 )
      {
        v13 = 0;
        do
        {
          if ( geometries[v13] )
          {
            RpGeometryDestroy(geometries[v13]);
            numGeoms = gGeomList.numGeoms;
            geometries = gGeomList.geometries;
          }
          ++v13;
        }
        while ( v13 < numGeoms );
      }
      CMemoryMgr::Free(geometries);
    }
    goto LABEL_43;
  }
LABEL_6:
  v2->object.parent = *gFrameList.frames;
  if ( gClumpInfo.numAtomics >= 1 )
  {
    v5 = 0;
    while ( RwStreamFindChunk(pStream, 0x14u, 0, &v21) )
    {
      v6 = ClumpAtomicGtaStreamRead(pStream, &gFrameList, &gGeomList);
      if ( !v6 )
      {
        v17 = gGeomList.numGeoms;
        if ( gGeomList.numGeoms )
        {
          v18 = gGeomList.geometries;
          if ( gGeomList.numGeoms >= 1 )
          {
            v19 = 0;
            do
            {
              if ( v18[v19] )
              {
                RpGeometryDestroy(v18[v19]);
                v17 = gGeomList.numGeoms;
                v18 = gGeomList.geometries;
              }
              ++v19;
            }
            while ( v19 < v17 );
          }
          CMemoryMgr::Free(v18);
        }
        goto LABEL_43;
      }
      RpClumpAddAtomic(v2, v6);
      if ( ++v5 >= gClumpInfo.numAtomics )
        goto LABEL_11;
    }
    v14 = gGeomList.numGeoms;
    if ( gGeomList.numGeoms )
    {
      v15 = gGeomList.geometries;
      if ( gGeomList.numGeoms >= 1 )
      {
        v16 = 0;
        do
        {
          if ( v15[v16] )
          {
            RpGeometryDestroy(v15[v16]);
            v14 = gGeomList.numGeoms;
            v15 = gGeomList.geometries;
          }
          ++v16;
        }
        while ( v16 < v14 );
      }
      CMemoryMgr::Free(v15);
    }
LABEL_43:
    v10 = 0;
    gGeomList.numGeoms = 0;
    _rwFrameListDeinitialize(&gFrameList);
    RpClumpDestroy(v2);
    return v10;
  }
LABEL_11:
  v7 = gGeomList.numGeoms;
  if ( gGeomList.numGeoms )
  {
    v8 = gGeomList.geometries;
    if ( gGeomList.numGeoms >= 1 )
    {
      v9 = 0;
      do
      {
        if ( v8[v9] )
        {
          RpGeometryDestroy(v8[v9]);
          v7 = gGeomList.numGeoms;
          v8 = gGeomList.geometries;
        }
        ++v9;
      }
      while ( v9 < v7 );
    }
    CMemoryMgr::Free(v8);
  }
  gGeomList.numGeoms = 0;
  _rwFrameListDeinitialize(&gFrameList);
  return v2;
}
// 5D094C: using guessed type RwUInt32 versionOut[8];

//----- (005D0BA8) --------------------------------------------------------
void RpClumpGtaCancelStream()
{
  RwInt32 numGeoms; // r2
  RpGeometry_0 **geometries; // r0
  RwInt32 v2; // r4

  numGeoms = gGeomList.numGeoms;
  if ( gGeomList.numGeoms )
  {
    geometries = gGeomList.geometries;
    if ( gGeomList.numGeoms >= 1 )
    {
      v2 = 0;
      do
      {
        if ( geometries[v2] )
        {
          RpGeometryDestroy(geometries[v2]);
          numGeoms = gGeomList.numGeoms;
          geometries = gGeomList.geometries;
        }
        ++v2;
      }
      while ( v2 < numGeoms );
    }
    CMemoryMgr::Free(geometries);
  }
  gGeomList.numGeoms = 0;
  _rwFrameListDeinitialize(&gFrameList);
  gFrameList.numFrames = 0;
}

//----- (005D0C10) --------------------------------------------------------
void DefinedState()
{
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREPERSPECTIVE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEBORDERCOLOR, (void *)0xFF000000);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(
    rwRENDERSTATEFOGCOLOR,
    (void *)(CTimeCycle::m_CurrentColours.m_nSkyBottomBlue | (CTimeCycle::m_CurrentColours.m_nSkyBottomRed << 16) | (CTimeCycle::m_CurrentColours.m_nSkyBottomGreen << 8) | 0xFF000000));
  RwRenderStateSet(rwRENDERSTATEFOGTYPE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
  sub_192840(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005D0CB4) --------------------------------------------------------
void DefinedState2d()
{
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREPERSPECTIVE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEBORDERCOLOR, (void *)0xFF000000);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
  sub_192840(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005D0D2E) --------------------------------------------------------
RpAtomic_0 *__fastcall GetFirstAtomicCallback(RpAtomic_0 *pAtomic, void *pData)
{
  *(_DWORD *)pData = pAtomic;
  return 0;
}

//----- (005D0D34) --------------------------------------------------------
RpAtomic_0 *__fastcall GetFirstAtomic(RpClump_0 *pClump)
{
  RpAtomic_0 *pData; // [sp+4h] [bp-Ch] BYREF

  pData = 0;
  RpClumpForAllAtomics(pClump, GetFirstAtomicCallback, &pData);
  return pData;
}

//----- (005D0D54) --------------------------------------------------------
RpAtomic_0 *__fastcall Get2DEffectAtomicCallback(RpAtomic_0 *pAtomic, void *pData)
{
  _DWORD *v2; // r2

  v2 = *(_DWORD **)(&pAtomic->geometry->object.type + g2dEffectPluginOffset);
  if ( v2 )
  {
    if ( *v2 )
    {
      *(_DWORD *)pData = pAtomic;
      return 0;
    }
  }
  return pAtomic;
}

//----- (005D0D78) --------------------------------------------------------
RpAtomic_0 *__fastcall Get2DEffectAtomic(RpClump_0 *pClump)
{
  RpAtomic_0 *pData; // [sp+4h] [bp-Ch] BYREF

  pData = 0;
  RpClumpForAllAtomics(pClump, Get2DEffectAtomicCallback, &pData);
  return pData;
}

//----- (005D0D98) --------------------------------------------------------
RwObject_0 *__fastcall GetFirstObjectCallback(RwObject_0 *pObject, void *pData)
{
  *(_DWORD *)pData = pObject;
  return 0;
}

//----- (005D0DA0) --------------------------------------------------------
RwObject_0 *__fastcall GetFirstObject(RwFrame_0 *pFrame)
{
  RwObject_0 *data; // [sp+4h] [bp-Ch] BYREF

  data = 0;
  RwFrameForAllObjects(pFrame, GetFirstObjectCallback, &data);
  return data;
}

//----- (005D0DC0) --------------------------------------------------------
RwObject_0 *__fastcall GetSecondObjectCallback(RwObject_0 *pObject, void *pData)
{
  int v2; // r2

  v2 = *(_DWORD *)pData;
  *(_DWORD *)pData = pObject;
  if ( v2 )
    return 0;
  return pObject;
}

//----- (005D0DCC) --------------------------------------------------------
RwObject_0 *__fastcall GetSecondObject(RwFrame_0 *pFrame)
{
  RwObject_0 *data; // [sp+4h] [bp-Ch] BYREF

  data = 0;
  RwFrameForAllObjects(pFrame, GetSecondObjectCallback, &data);
  return data;
}

//----- (005D0DEC) --------------------------------------------------------
RwFrame_0 *__fastcall GetFirstFrameCallback(RwFrame_0 *pFrame, void *pData)
{
  *(_DWORD *)pData = pFrame;
  return 0;
}

//----- (005D0DF4) --------------------------------------------------------
RwFrame_0 *__fastcall GetFirstChild(RwFrame_0 *pFrame)
{
  RwFrame_0 *data; // [sp+4h] [bp-Ch] BYREF

  data = 0;
  RwFrameForAllChildren(pFrame, GetFirstFrameCallback, &data);
  return data;
}

//----- (005D0E14) --------------------------------------------------------
RwTexture_0 *__fastcall GetFirstTextureCallback(RwTexture_0 *pTexture, void *pData)
{
  *(_DWORD *)pData = pTexture;
  return 0;
}

//----- (005D0E1C) --------------------------------------------------------
RwTexture_0 *__fastcall GetFirstTexture(RwTexDictionary_0 *pTxd)
{
  RwTexture_0 *pData; // [sp+4h] [bp-Ch] BYREF

  pData = 0;
  RwTexDictionaryForAllTextures(pTxd, GetFirstTextureCallback, &pData);
  return pData;
}

//----- (005D0E3C) --------------------------------------------------------
RpClump_0 *__fastcall RpClumpGetBoundingSphere(RpClump_0 *pClump, RwSphere_0 *pSphere, bool bUseLTM)
{
  bool v4; // zf
  RpClump_0 *v6; // r6
  RwInt32 NumAtomics; // r5
  float v8; // s0
  RwFrame_0 *parent; // r0
  RwMatrix *LTM; // r1
  RwReal v11; // r0
  __int64 v12; // d16
  RwMatrix v14; // [sp+0h] [bp-70h] BYREF
  RwV3d_0 pointsIn; // [sp+40h] [bp-30h] BYREF
  float v16; // [sp+4Ch] [bp-24h]
  RwV3d_0 pData[2]; // [sp+50h] [bp-20h] BYREF

  v4 = pClump == 0;
  v6 = 0;
  b_cbsUseLTM = bUseLTM;
  if ( pClump )
    v4 = pSphere == 0;
  if ( !v4 )
  {
    *(_QWORD *)&pSphere->center.x = 0LL;
    *(_QWORD *)&pSphere->center.z = 0LL;
    NumAtomics = RpClumpGetNumAtomics(pClump);
    v6 = 0;
    if ( NumAtomics >= 1 )
    {
      memset(pData, 0, 12);
      RpClumpForAllAtomics(pClump, cbsCalcMeanBSphereCenterCB, pData);
      v8 = 1.0 / (float)NumAtomics;
      *(_QWORD *)&pData[0].x = __PAIR64__(v8 * pData[0].y, v8 * pData[0].x);
      pData[0].z = v8 * pData[0].z;
      pointsIn = pData[0];
      v16 = 0.0;
      RpClumpForAllAtomics(pClump, cbsCalcMeanBSphereRadiusCB, &pointsIn);
      parent = (RwFrame_0 *)pClump->object.parent;
      if ( b_cbsUseLTM )
        LTM = RwFrameGetLTM(parent);
      else
        LTM = &parent->modelling;
      RwMatrixInvert(&v14, LTM);
      RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &v14);
      v11 = v16;
      v6 = pClump;
      v12 = *(_QWORD *)&pointsIn.x;
      pSphere->center.z = pointsIn.z;
      pSphere->radius = v11;
      *(_QWORD *)&pSphere->center.x = v12;
    }
  }
  return v6;
}

//----- (005D0F28) --------------------------------------------------------
RpAtomic_0 *__fastcall cbsCalcMeanBSphereCenterCB(RpAtomic_0 *pAtomic, void *data)
{
  RpClump_0 *clump; // r6
  int v5; // r0
  RwMatrix *LTM; // r3
  RwSphere_0 *p_boundingSphere; // r1
  RpAtomic_0 *result; // r0
  float v9; // s2
  float v10; // s4
  RwV3d_0 pointsOut; // [sp+4h] [bp-1Ch] BYREF

  clump = pAtomic->clump;
  v5 = pAtomic->interpolator.flags & 2;
  if ( b_cbsUseLTM )
  {
    if ( v5 )
      _rpAtomicResyncInterpolatedSphere(pAtomic);
    LTM = RwFrameGetLTM((RwFrame_0 *)clump->object.parent);
    p_boundingSphere = &pAtomic->boundingSphere;
  }
  else
  {
    if ( v5 )
      _rpAtomicResyncInterpolatedSphere(pAtomic);
    p_boundingSphere = &pAtomic->boundingSphere;
    LTM = (RwMatrix *)((char *)clump->object.parent + 16);
  }
  RwV3dTransformPoints(&pointsOut, &p_boundingSphere->center, 1, LTM);
  result = pAtomic;
  v9 = pointsOut.y + *((float *)data + 1);
  v10 = pointsOut.z + *((float *)data + 2);
  *(float *)data = pointsOut.x + *(float *)data;
  *((float *)data + 1) = v9;
  *((float *)data + 2) = v10;
  return result;
}

//----- (005D0FB8) --------------------------------------------------------
RpAtomic_0 *__fastcall cbsCalcMeanBSphereRadiusCB(RpAtomic_0 *pAtomic, void *data)
{
  RwInt32 flags; // r0
  RpClump_0 *clump; // r8
  int v6; // r0
  RwMatrix *LTM; // r3
  RpAtomic_0 *result; // r0
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1
  float v11; // s0
  RwV3d_0 pointsOut; // [sp+4h] [bp-1Ch] BYREF

  flags = pAtomic->interpolator.flags;
  clump = pAtomic->clump;
  if ( (flags & 2) != 0 )
  {
    _rpAtomicResyncInterpolatedSphere(pAtomic);
    flags = pAtomic->interpolator.flags;
  }
  v6 = flags & 2;
  if ( b_cbsUseLTM )
  {
    if ( v6 )
      _rpAtomicResyncInterpolatedSphere(pAtomic);
    LTM = RwFrameGetLTM((RwFrame_0 *)clump->object.parent);
  }
  else
  {
    if ( v6 )
      _rpAtomicResyncInterpolatedSphere(pAtomic);
    LTM = (RwMatrix *)((char *)clump->object.parent + 16);
  }
  RwV3dTransformPoints(&pointsOut, &pAtomic->boundingSphere.center, 1, LTM);
  result = pAtomic;
  v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&pointsOut.y, *(float32x2_t *)((char *)data + 4)).n64_u64[0];
  v10 = vmul_f32(v9, v9).n64_u64[0];
  v11 = pAtomic->boundingSphere.radius
      + sqrtf(
          (float)((float)((float)(pointsOut.x - *(float *)data) * (float)(pointsOut.x - *(float *)data)) + *(float *)&v10)
        + *((float *)&v10 + 1));
  if ( *((float *)data + 3) < v11 )
    *((float *)data + 3) = v11;
  return result;
}

//----- (005D1070) --------------------------------------------------------
RpHAnimHierarchy_0 *__fastcall GetAnimHierarchyFromSkinClump(RpClump_0 *pClump)
{
  RpHAnimHierarchy_0 *pData; // [sp+4h] [bp-Ch] BYREF

  pData = 0;
  RpClumpForAllAtomics(pClump, GetSkinHierarchy, &pData);
  return pData;
}

//----- (005D1090) --------------------------------------------------------
RpAtomic_0 *__fastcall GetSkinHierarchy(RpAtomic_0 *pAtomic, void *data)
{
  *(_DWORD *)data = j_RpSkinAtomicGetHAnimHierarchy(pAtomic);
  return 0;
}

//----- (005D10A0) --------------------------------------------------------
RpHAnimHierarchy_0 *__fastcall GetAnimHierarchyFromFrame(RwFrame_0 *pFrame)
{
  RpHAnimHierarchy_0 *result; // r0
  int data[3]; // [sp+4h] [bp-Ch] BYREF

  data[0] = 0;
  result = RpHAnimFrameGetHierarchy(pFrame);
  if ( result )
  {
    data[0] = (int)result;
  }
  else
  {
    RwFrameForAllChildren(pFrame, GetChildFrameHierarchy, data);
    result = (RpHAnimHierarchy_0 *)data[0];
    if ( !data[0] )
    {
      RwFrameForAllChildren(pFrame, GetChildFrameHierarchy, data);
      return (RpHAnimHierarchy_0 *)data[0];
    }
  }
  return result;
}

//----- (005D10EC) --------------------------------------------------------
RwFrame_0 *__fastcall GetChildFrameHierarchy(RwFrame_0 *pFrame, void *data)
{
  RpHAnimHierarchy_0 *Hierarchy; // r0

  Hierarchy = RpHAnimFrameGetHierarchy(pFrame);
  if ( Hierarchy )
  {
    *(_DWORD *)data = Hierarchy;
    return 0;
  }
  else
  {
    RwFrameForAllChildren(pFrame, GetChildFrameHierarchy, data);
    return pFrame;
  }
}

//----- (005D1118) --------------------------------------------------------
RpHAnimHierarchy_0 *__fastcall GetAnimHierarchyFromClump(RpClump_0 *pClump)
{
  RwFrame_0 *parent; // r4
  RpHAnimHierarchy_0 *result; // r0
  int data[3]; // [sp+4h] [bp-Ch] BYREF

  parent = (RwFrame_0 *)pClump->object.parent;
  data[0] = 0;
  result = RpHAnimFrameGetHierarchy(parent);
  if ( result )
  {
    data[0] = (int)result;
  }
  else
  {
    RwFrameForAllChildren(parent, GetChildFrameHierarchy, data);
    result = (RpHAnimHierarchy_0 *)data[0];
    if ( !data[0] )
    {
      RwFrameForAllChildren(parent, GetChildFrameHierarchy, data);
      return (RpHAnimHierarchy_0 *)data[0];
    }
  }
  return result;
}

//----- (005D1164) --------------------------------------------------------
void __fastcall SkinGetBonePositions(RpClump_0 *pClump)
{
  RpSkin_0 *v2; // r4
  int v3; // r8
  int v4; // r9
  int v5; // r4
  int v6; // r2
  const RwMatrix *v7; // r0
  __int64 v8; // d16
  __int64 v9; // d17
  __int64 v10; // d18
  __int64 v11; // d19
  __int64 *p_at; // r1
  __int64 v13; // d20
  __int64 v14; // d21
  __int64 v15; // d23
  const RwMatrix *v16; // r0
  __int64 v17; // d16
  __int64 v18; // d17
  __int64 v19; // d18
  __int64 v20; // d19
  __int64 *v21; // r1
  __int64 v22; // d20
  __int64 v23; // d21
  __int64 v24; // d23
  int v25; // r0
  int v26; // r0
  signed int NumBones; // [sp+8h] [bp-138h]
  int v28; // [sp+Ch] [bp-134h]
  RpSkin_0 *skin; // [sp+10h] [bp-130h]
  int v30; // [sp+18h] [bp-128h]
  RwUInt32 v31; // [sp+1Ch] [bp-124h]
  RwMatrix dst; // [sp+20h] [bp-120h] BYREF
  int pData[32]; // [sp+60h] [bp-E0h] BYREF
  RwMatrix src; // [sp+E0h] [bp-60h] BYREF

  if ( !SkinGetBonePositions(RpClump *)::bBoneTranslationsExtracted )
  {
    pData[0] = 0;
    SkinGetBonePositions(RpClump *)::bBoneTranslationsExtracted = 1;
    RpClumpForAllAtomics(pClump, GetFirstAtomicCallback, pData);
    v2 = j_RpSkinGeometryGetSkin(*(RpGeometry_0 **)(pData[0] + 24));
    pData[0] = 0;
    RpClumpForAllAtomics(pClump, GetSkinHierarchy, pData);
    v28 = pData[0];
    BoneTranslations[0].parent = -1;
    BoneTranslations[0].offset.x = 0.0;
    BoneTranslations[0].offset.y = 0.0;
    BoneTranslations[0].offset.z = 0.0;
    skin = v2;
    NumBones = j_RpSkinGetNumBones(v2);
    if ( NumBones >= 2 )
    {
      v3 = 1;
      v4 = 0;
      v5 = 1;
      v6 = 0;
      v31 = 0;
      do
      {
        v30 = v6;
        v7 = &j_RpSkinGetSkinToBoneMatrices(skin)[v5];
        v8 = *(_QWORD *)&v7->right.x;
        v9 = *(_QWORD *)&v7->right.z;
        v10 = *(_QWORD *)&v7->up.x;
        v11 = *(_QWORD *)&v7->up.z;
        p_at = (__int64 *)&v7->at;
        v7 = (const RwMatrix *)((char *)v7 + 48);
        v13 = *p_at;
        v14 = p_at[1];
        v15 = *(_QWORD *)&v7->right.z;
        *(_QWORD *)&src.pos.x = *(_QWORD *)&v7->right.x;
        *(_QWORD *)&src.pos.z = v15;
        *(_QWORD *)&src.at.x = v13;
        *(_QWORD *)&src.at.z = v14;
        *(_QWORD *)&src.right.x = v8;
        *(_QWORD *)&src.right.z = v9;
        *(_QWORD *)&src.up.x = v10;
        *(_QWORD *)&src.up.z = v11;
        RwMatrixInvert(&dst, &src);
        v16 = &j_RpSkinGetSkinToBoneMatrices(skin)[v31];
        v17 = *(_QWORD *)&v16->right.x;
        v18 = *(_QWORD *)&v16->right.z;
        v19 = *(_QWORD *)&v16->up.x;
        v20 = *(_QWORD *)&v16->up.z;
        v21 = (__int64 *)&v16->at;
        v16 = (const RwMatrix *)((char *)v16 + 48);
        v22 = *v21;
        v23 = v21[1];
        v24 = *(_QWORD *)&v16->right.z;
        *(_QWORD *)&src.pos.x = *(_QWORD *)&v16->right.x;
        *(_QWORD *)&src.pos.z = v24;
        *(_QWORD *)&src.at.x = v22;
        *(_QWORD *)&src.at.z = v23;
        *(_QWORD *)&src.right.x = v17;
        *(_QWORD *)&src.right.z = v18;
        *(_QWORD *)&src.up.x = v19;
        *(_QWORD *)&src.up.z = v20;
        RwV3dTransformPoints(&BoneTranslations[v4 + 1].offset, &dst.pos, 1, &src);
        BoneTranslations[v4 + 1].parent = v31;
        v25 = *(_DWORD *)(*(_DWORD *)(v28 + 16) + v4 * 16 + 24);
        if ( (v25 & 2) != 0 )
        {
          v6 = v30 + 1;
          pData[v30 + 1] = v31;
        }
        else
        {
          v6 = v30;
        }
        if ( v25 << 31 )
        {
          v26 = pData[v6--];
          v31 = v26;
        }
        else
        {
          v31 = v3;
        }
        ++v3;
        ++v5;
        ++v4;
      }
      while ( NumBones != v3 );
    }
  }
}
// A838C4: using guessed type char SkinGetBonePositions(RpClump *)::bBoneTranslationsExtracted;
// 5D1164: using guessed type int pData[32];

//----- (005D12E4) --------------------------------------------------------
void __fastcall SkinSetBonePositions(RpClump_0 *pClump)
{
  RpSkin_0 *Skin; // r5
  RwMatrix *MatrixArray; // r8
  signed int NumBones; // r0
  int v5; // r6
  RwV3d_0 *p_pos; // r5
  _boneTranslation *v7; // r0
  _boneTranslation *v8; // r4
  RwUInt32 parent; // t1
  int v10; // [sp+0h] [bp-18h] BYREF
  RpHAnimHierarchy_0 *pData; // [sp+4h] [bp-14h] BYREF

  v10 = 0;
  RpClumpForAllAtomics(pClump, GetFirstAtomicCallback, &v10);
  Skin = j_RpSkinGeometryGetSkin(*(RpGeometry_0 **)(v10 + 24));
  pData = 0;
  RpClumpForAllAtomics(pClump, GetSkinHierarchy, &pData);
  MatrixArray = RpHAnimHierarchyGetMatrixArray(pData);
  NumBones = j_RpSkinGetNumBones(Skin);
  if ( NumBones >= 2 )
  {
    v5 = NumBones - 1;
    p_pos = &MatrixArray[1].pos;
    v7 = &BoneTranslations[1];
    v8 = &BoneTranslations[1];
    do
    {
      parent = v8->parent;
      ++v8;
      RwV3dTransformPoints(p_pos, &v7->offset, 1, &MatrixArray[parent]);
      p_pos = (RwV3d_0 *)((char *)p_pos + 64);
      --v5;
      v7 = v8;
    }
    while ( v5 );
  }
}

//----- (005D136C) --------------------------------------------------------
void __fastcall SkinGetBonePositionsToTable(RpClump_0 *pClump, RwV3d_0 *TransTable)
{
  RpSkin_0 *v4; // r4
  RwV3d_0 *v5; // r4
  int v6; // r9
  int v7; // r2
  int v8; // r10
  int v9; // r11
  const RwMatrix *v10; // r0
  __int64 v11; // d16
  __int64 v12; // d17
  __int64 v13; // d18
  __int64 v14; // d19
  __int64 *p_at; // r1
  __int64 v16; // d20
  __int64 v17; // d21
  __int64 v18; // d23
  const RwMatrix *v19; // r0
  __int64 v20; // d16
  __int64 v21; // d17
  __int64 v22; // d18
  __int64 v23; // d19
  __int64 *v24; // r1
  __int64 v25; // d20
  __int64 v26; // d21
  __int64 v27; // d23
  int v28; // r0
  int v29; // r0
  signed int NumBones; // [sp+8h] [bp-138h]
  int v31; // [sp+Ch] [bp-134h]
  RpSkin_0 *skin; // [sp+10h] [bp-130h]
  int v33; // [sp+14h] [bp-12Ch]
  int v34; // [sp+1Ch] [bp-124h]
  RwMatrix dst; // [sp+20h] [bp-120h] BYREF
  int pData[32]; // [sp+60h] [bp-E0h] BYREF
  RwMatrix src; // [sp+E0h] [bp-60h] BYREF

  if ( TransTable )
  {
    pData[0] = 0;
    RpClumpForAllAtomics(pClump, GetFirstAtomicCallback, pData);
    v4 = j_RpSkinGeometryGetSkin(*(RpGeometry_0 **)(pData[0] + 24));
    pData[0] = 0;
    RpClumpForAllAtomics(pClump, GetSkinHierarchy, pData);
    v31 = pData[0];
    TransTable->x = 0.0;
    TransTable->y = 0.0;
    TransTable->z = 0.0;
    skin = v4;
    NumBones = j_RpSkinGetNumBones(v4);
    if ( NumBones >= 2 )
    {
      v5 = TransTable + 1;
      v6 = 1;
      v7 = 0;
      v8 = 24;
      v9 = 1;
      v34 = 0;
      do
      {
        v33 = v7;
        v10 = &j_RpSkinGetSkinToBoneMatrices(skin)[v9];
        v11 = *(_QWORD *)&v10->right.x;
        v12 = *(_QWORD *)&v10->right.z;
        v13 = *(_QWORD *)&v10->up.x;
        v14 = *(_QWORD *)&v10->up.z;
        p_at = (__int64 *)&v10->at;
        v10 = (const RwMatrix *)((char *)v10 + 48);
        v16 = *p_at;
        v17 = p_at[1];
        v18 = *(_QWORD *)&v10->right.z;
        *(_QWORD *)&src.pos.x = *(_QWORD *)&v10->right.x;
        *(_QWORD *)&src.pos.z = v18;
        *(_QWORD *)&src.at.x = v16;
        *(_QWORD *)&src.at.z = v17;
        *(_QWORD *)&src.right.x = v11;
        *(_QWORD *)&src.right.z = v12;
        *(_QWORD *)&src.up.x = v13;
        *(_QWORD *)&src.up.z = v14;
        RwMatrixInvert(&dst, &src);
        v19 = &j_RpSkinGetSkinToBoneMatrices(skin)[v34];
        v20 = *(_QWORD *)&v19->right.x;
        v21 = *(_QWORD *)&v19->right.z;
        v22 = *(_QWORD *)&v19->up.x;
        v23 = *(_QWORD *)&v19->up.z;
        v24 = (__int64 *)&v19->at;
        v19 = (const RwMatrix *)((char *)v19 + 48);
        v25 = *v24;
        v26 = v24[1];
        v27 = *(_QWORD *)&v19->right.z;
        *(_QWORD *)&src.pos.x = *(_QWORD *)&v19->right.x;
        *(_QWORD *)&src.pos.z = v27;
        *(_QWORD *)&src.at.x = v25;
        *(_QWORD *)&src.at.z = v26;
        *(_QWORD *)&src.right.x = v20;
        *(_QWORD *)&src.right.z = v21;
        *(_QWORD *)&src.up.x = v22;
        *(_QWORD *)&src.up.z = v23;
        RwV3dTransformPoints(v5, &dst.pos, 1, &src);
        v28 = *(_DWORD *)(*(_DWORD *)(v31 + 16) + v8);
        if ( (v28 & 2) != 0 )
        {
          v7 = v33 + 1;
          pData[v33 + 1] = v34;
          if ( !(v28 << 31) )
          {
LABEL_8:
            v34 = v6;
            goto LABEL_9;
          }
        }
        else
        {
          v7 = v33;
          if ( !(v28 << 31) )
            goto LABEL_8;
        }
        v29 = pData[v7--];
        v34 = v29;
LABEL_9:
        ++v6;
        ++v9;
        v8 += 16;
        ++v5;
      }
      while ( NumBones != v6 );
    }
  }
}
// 5D136C: using guessed type int pData[32];

//----- (005D14CC) --------------------------------------------------------
RpAtomic_0 *__fastcall AtomicRemoveAnimFromSkinCB(RpAtomic_0 *pAtomic, void *data)
{
  RpHAnimHierarchy_0 *HAnimHierarchy; // r0
  RpHAnimHierarchy_0 *v4; // r5
  RtAnimAnimation_0 **p_pCurrentAnim; // r1

  if ( j_RpSkinGeometryGetSkin(pAtomic->geometry) )
  {
    HAnimHierarchy = j_RpSkinAtomicGetHAnimHierarchy(pAtomic);
    v4 = HAnimHierarchy;
    if ( HAnimHierarchy )
    {
      p_pCurrentAnim = &HAnimHierarchy->currentAnim->pCurrentAnim;
      if ( *p_pCurrentAnim )
      {
        RtAnimAnimationDestroy(*p_pCurrentAnim);
        p_pCurrentAnim = &v4->currentAnim->pCurrentAnim;
      }
      *p_pCurrentAnim = 0;
    }
  }
  return pAtomic;
}

//----- (005D14F8) --------------------------------------------------------
bool8 __fastcall RpAtomicConvertGeometryToTL(RpAtomic_0 *pAtomic)
{
  RpGeometry_0 *geometry; // r0
  RwUInt32 flags; // r4
  RpGeometry_0 *v4; // r0

  geometry = pAtomic->geometry;
  flags = geometry->flags;
  if ( (flags & 0x1000001) != 1 )
    return 0;
  v4 = RpGeometryLock(geometry, 4095);
  v4->flags = flags & 0xFFFFFFFE;
  RpGeometryUnlock(v4);
  return 1;
}

//----- (005D1526) --------------------------------------------------------
bool8 __fastcall RpAtomicConvertGeometryToTS(RpAtomic_0 *pAtomic)
{
  RpGeometry_0 *geometry; // r0
  RwUInt32 flags; // r4
  RpGeometry_0 *v4; // r0

  geometry = pAtomic->geometry;
  flags = geometry->flags;
  if ( (flags & 0x1000001) != 0 )
    return 0;
  v4 = RpGeometryLock(geometry, 4095);
  v4->flags = flags | 1;
  RpGeometryUnlock(v4);
  return 1;
}

//----- (005D1554) --------------------------------------------------------
bool8 __fastcall RpClumpConvertGeometryToTL(RpClump_0 *pClump)
{
  bool8 v2; // [sp+7h] [bp-9h] BYREF

  v2 = 1;
  RpClumpForAllAtomics(pClump, atomicConvertToTLcb, &v2);
  return v2;
}

//----- (005D1578) --------------------------------------------------------
RpAtomic_0 *__fastcall atomicConvertToTLcb(RpAtomic_0 *atomic, void *pData)
{
  RpGeometry_0 *geometry; // r0
  RwUInt32 flags; // r5
  RpGeometry_0 *v5; // r0

  geometry = atomic->geometry;
  flags = geometry->flags;
  if ( (flags & 0x1000001) == 1 )
  {
    v5 = RpGeometryLock(geometry, 4095);
    v5->flags = flags & 0xFFFFFFFE;
    RpGeometryUnlock(v5);
  }
  else
  {
    *(_BYTE *)pData = 0;
  }
  return atomic;
}

//----- (005D15AC) --------------------------------------------------------
bool8 __fastcall RpClumpConvertGeometryToTS(RpClump_0 *pClump)
{
  bool8 v2; // [sp+7h] [bp-9h] BYREF

  v2 = 1;
  RpClumpForAllAtomics(pClump, atomicConvertToTScb, &v2);
  return v2;
}

//----- (005D15D0) --------------------------------------------------------
RpAtomic_0 *__fastcall atomicConvertToTScb(RpAtomic_0 *atomic, void *pData)
{
  RpGeometry_0 *geometry; // r0
  RwUInt32 flags; // r5
  RpGeometry_0 *v6; // r0

  geometry = atomic->geometry;
  flags = geometry->flags;
  if ( (flags & 0x1000001) != 0 )
  {
    *(_BYTE *)pData = 0;
  }
  else
  {
    v6 = RpGeometryLock(geometry, 4095);
    v6->flags = flags | 1;
    RpGeometryUnlock(v6);
  }
  return atomic;
}

//----- (005D1602) --------------------------------------------------------
RpMaterial_0 *__fastcall forceLinearFilteringMatTexturesCB(RpMaterial_0 *pMaterial, void *data)
{
  if ( pMaterial->texture )
    LOBYTE(pMaterial->texture->filterAddressing) = (_BYTE)data;
  return pMaterial;
}

//----- (005D1610) --------------------------------------------------------
bool8 __fastcall SetFilterModeOnAtomicsTextures(RpAtomic_0 *pAtomic, RwTextureFilterMode_0 filterMode)
{
  RpGeometryForAllMaterials(pAtomic->geometry, forceLinearFilteringMatTexturesCB, (void *)filterMode);
  return 1;
}

//----- (005D162C) --------------------------------------------------------
RpAtomic_0 *__fastcall forceLinearFilteringAtomicsCB(RpAtomic_0 *pAtomic, void *data)
{
  RpGeometryForAllMaterials(pAtomic->geometry, forceLinearFilteringMatTexturesCB, data);
  return pAtomic;
}

//----- (005D1648) --------------------------------------------------------
bool8 __fastcall SetFilterModeOnClumpsTextures(RpClump_0 *pClump, RwTextureFilterMode_0 filterMode)
{
  RpClumpForAllAtomics(pClump, forceLinearFilteringAtomicsCB, (void *)filterMode);
  return 1;
}

//----- (005D1660) --------------------------------------------------------
bool8 __fastcall RpGeometryReplaceOldMaterialWithNewMaterial(
        RpGeometry_0 *pGeometry,
        RpMaterial_0 *pOldMaterial,
        RpMaterial_0 *pNewMaterial)
{
  RpMeshHeader_0 *mesh; // r1
  int numMeshes; // r5
  RpMaterialList_0 *p_matList; // r8
  RpMaterial_0 **p_totalIndicesInMesh; // r4
  bool8 result; // r0
  RwInt32 MaterialIndex; // r6

  mesh = pGeometry->mesh;
  numMeshes = mesh->numMeshes;
  if ( !mesh->numMeshes )
    return 0;
  p_matList = &pGeometry->matList;
  p_totalIndicesInMesh = (RpMaterial_0 **)&mesh[1].totalIndicesInMesh;
  result = 0;
  do
  {
    if ( *p_totalIndicesInMesh == pOldMaterial )
    {
      MaterialIndex = _rpMaterialListFindMaterialIndex(p_matList, pOldMaterial);
      RpMaterialDestroy(*p_totalIndicesInMesh);
      p_matList->materials[MaterialIndex] = pNewMaterial;
      *p_totalIndicesInMesh = pNewMaterial;
      ++pNewMaterial->refCount;
      result = 1;
    }
    --numMeshes;
    p_totalIndicesInMesh += 4;
  }
  while ( numMeshes );
  return result;
}

//----- (005D16BE) --------------------------------------------------------
RwTexture_0 *__fastcall RwTexDictionaryFindHashNamedTexture(RwTexDictionary_0 *pTxd, uint32 hashKey)
{
  RwLinkList_0 *p_texturesInDict; // r5
  RwLinkList_0 *next; // r6

  p_texturesInDict = &pTxd->texturesInDict;
  next = &pTxd->texturesInDict;
  while ( 1 )
  {
    next = (RwLinkList_0 *)next->link.next;
    if ( next == p_texturesInDict )
      break;
    if ( CKeyGen::GetUppercaseKey((const unsigned __int8 *)&next[1]) == hashKey )
      return (RwTexture_0 *)&next[-1];
  }
  return 0;
}

//----- (005D1704) --------------------------------------------------------
void __fastcall SetLightsWithTimeOfDayColour(RpWorld_0 *world)
{
  RpLight_0 *r0_1; // r0
  CVector v2; // [sp+0h] [bp-80h] BYREF
  CVector right; // [sp+10h] [bp-70h] BYREF
  CVector v1; // [sp+20h] [bp-60h] BYREF
  RwMatrix v5; // [sp+30h] [bp-50h] BYREF

  r0_1 = pDirect;
  pDirect->isMainLight = 1;
  if ( pAmbient )
  {
    AmbientLightColourForFrame.red = CTimeCycle::GetAmbientRed() * CCoronas::LightsMult;
    AmbientLightColourForFrame.green = CTimeCycle::GetAmbientGreen() * CCoronas::LightsMult;
    AmbientLightColourForFrame.blue = CTimeCycle::GetAmbientBlue() * CCoronas::LightsMult;
    AmbientLightColourForFrame_PedsCarsAndObjects.red = (float)(CTimeCycle::GetAmbientRed_Obj() * CCoronas::LightsMult)
                                                      * 1.5;
    AmbientLightColourForFrame_PedsCarsAndObjects.green = (float)(CTimeCycle::GetAmbientGreen_Obj()
                                                                * CCoronas::LightsMult)
                                                        * 1.5;
    AmbientLightColourForFrame_PedsCarsAndObjects.blue = (float)(CTimeCycle::GetAmbientBlue_Obj() * CCoronas::LightsMult)
                                                       * 1.5;
    if ( CWeather::LightningFlash )
    {
      AmbientLightColourForFrame.red = 1.0;
      AmbientLightColourForFrame.green = 1.0;
      AmbientLightColourForFrame.blue = 1.0;
      AmbientLightColourForFrame_PedsCarsAndObjects.red = 1.0;
      AmbientLightColourForFrame_PedsCarsAndObjects.green = 1.0;
      AmbientLightColourForFrame_PedsCarsAndObjects.blue = 1.0;
    }
    RpLightSetColor(pAmbient, &AmbientLightColourForFrame);
    r0_1 = pDirect;
  }
  if ( r0_1 )
  {
    DirectionalLightColourForFrame.red = (float)(CCoronas::LightsMult
                                               * (float)((float)(CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier
                                                               * 255.0)
                                                       * 0.0039062))
                                       * 1.5;
    DirectionalLightColourForFrame.green = DirectionalLightColourForFrame.red;
    DirectionalLightColourFromDay.red = (float)((float)CTimeCycle::m_CurrentColours.m_nSkyTopRed / 255.0)
                                      + (float)((float)(0.33
                                                      - (float)((float)CTimeCycle::m_CurrentColours.m_nSkyTopRed / 255.0))
                                              * 0.65);
    DirectionalLightColourFromDay.green = (float)((float)CTimeCycle::m_CurrentColours.m_nSkyTopGreen / 255.0)
                                        + (float)((float)(0.23
                                                        - (float)((float)CTimeCycle::m_CurrentColours.m_nSkyTopGreen
                                                                / 255.0))
                                                * 0.75);
    DirectionalLightColourForFrame.blue = DirectionalLightColourForFrame.red;
    DirectionalLightColourFromDay.blue = (float)((float)CTimeCycle::m_CurrentColours.m_nSkyTopBlue / 255.0)
                                       + (float)((float)(0.23
                                                       - (float)((float)CTimeCycle::m_CurrentColours.m_nSkyTopBlue
                                                               / 255.0))
                                               * 0.75);
    RpLightSetColor(r0_1, &DirectionalLightColourForFrame);
    v2 = CTimeCycle::m_vecDirnLightToSun;
    v1.z = 1.0;
    v1.x = 0.0;
    v1.y = 0.0;
    CrossProduct((CVector *)&v5, &v1, &v2);
    right = (CVector)v5.right;
    CVector::Normalise(&right);
    CrossProduct((CVector *)&v5, &right, &v2);
    v1 = (CVector)v5.right;
    v5.at.z = -v2.z;
    v5.at.x = -v2.x;
    v5.at.y = -v2.y;
    v5.up = right.RwV3d_0;
    RwFrameTransform((RwFrame_0 *)pDirect->object.object.parent, &v5, rwCOMBINEREPLACE);
  }
}

//----- (005D19C8) --------------------------------------------------------
RpWorld_0 *__fastcall LightsDestroy(RpWorld_0 *world)
{
  if ( world )
  {
    if ( pAmbient )
    {
      RpWorldRemoveLight(world, pAmbient);
      RpLightDestroy(pAmbient);
      pAmbient = 0;
    }
    if ( pDirect )
    {
      RpWorldRemoveLight(world, pDirect);
      RwFrameDestroy((RwFrame_0 *)pDirect->object.object.parent);
      RpLightDestroy(pDirect);
      pDirect = 0;
    }
    if ( pExtraDirectionals[0] )
    {
      RpWorldRemoveLight(world, pExtraDirectionals[0]);
      RwFrameDestroy((RwFrame_0 *)pExtraDirectionals[0]->object.object.parent);
      RpLightDestroy(pExtraDirectionals[0]);
      pExtraDirectionals[0] = 0;
    }
    if ( pExtraDirectionals[1] )
    {
      RpWorldRemoveLight(world, pExtraDirectionals[1]);
      RwFrameDestroy((RwFrame_0 *)pExtraDirectionals[1]->object.object.parent);
      RpLightDestroy(pExtraDirectionals[1]);
      pExtraDirectionals[1] = 0;
    }
    if ( pExtraDirectionals[2] )
    {
      RpWorldRemoveLight(world, pExtraDirectionals[2]);
      RwFrameDestroy((RwFrame_0 *)pExtraDirectionals[2]->object.object.parent);
      RpLightDestroy(pExtraDirectionals[2]);
      pExtraDirectionals[2] = 0;
    }
  }
  return world;
}

//----- (005D1AC0) --------------------------------------------------------
void __fastcall WorldReplaceNormalLightsWithScorched(RpWorld_0 *world, float Darkness)
{
  RwRGBAReal_0 v2; // [sp+0h] [bp-18h] BYREF

  v2.red = Darkness;
  v2.green = Darkness;
  v2.blue = Darkness;
  RpLightSetColor(pAmbient, &v2);
  pDirect->object.object.flags = 0;
}

//----- (005D1AF4) --------------------------------------------------------
void __fastcall WorldReplaceScorchedLightsWithNormal(RpWorld_0 *world)
{
  RpLightSetColor(pAmbient, &AmbientLightColourForFrame);
  pDirect->object.object.flags = 1;
}

//----- (005D1B24) --------------------------------------------------------
void __fastcall AddAnExtraDirectionalLight(
        RpWorld_0 *world,
        float DirX,
        float DirY,
        float DirZ,
        float R,
        float G,
        float B)
{
  float32x2_t v7; // d0
  float32x2_t v8; // d1
  float32x2_t v9; // d2
  float32x2_t v10; // d4
  int32 v11; // r5
  unsigned __int64 v12; // d8
  int v13; // r6
  float32x2_t v14; // d3
  int v15; // r4
  float *v16; // r0
  bool v17; // nf
  RwFrame_0 *parent; // r4
  RwRGBAReal_0 v22; // [sp+0h] [bp-40h] BYREF

  v11 = 2;
  v7.n64_f32[0] = G;
  v8.n64_f32[0] = R;
  v9.n64_f32[0] = B;
  v12 = vmax_f32(vmax_f32(v8, v7), v9).n64_u64[0];
  v13 = NumExtraDirLightsInWorld;
  if ( CGame::currArea )
    v11 = 3;
  if ( NumExtraDirLightsInWorld >= v11 )
  {
    v14.n64_u64[0] = v12;
    v13 = -1;
    v15 = 0;
    v16 = LightStrengths;
    do
    {
      v10.n64_f32[0] = *v16++;
      v17 = v10.n64_f32[0] < v14.n64_f32[0];
      v14.n64_u64[0] = vmin_f32(v10, v14).n64_u64[0];
      if ( v17 )
        v13 = v15;
      ++v15;
    }
    while ( v15 < v11 );
  }
  if ( v13 >= 0 )
  {
    v22.green = G;
    v22.red = R;
    v22.blue = B;
    RpLightSetColor(pExtraDirectionals[v13], &v22);
    parent = (RwFrame_0 *)pExtraDirectionals[v13]->object.object.parent;
    parent->modelling.at.x = -DirX;
    parent->modelling.at.y = -DirY;
    parent->modelling.at.z = -DirZ;
    RwMatrixUpdate(&parent->modelling);
    RwFrameUpdateObjects(parent);
    pExtraDirectionals[v13]->object.object.flags = 1;
    LODWORD(LightStrengths[v13]) = v12;
    if ( NumExtraDirLightsInWorld + 1 < v11 )
      v11 = NumExtraDirLightsInWorld + 1;
    NumExtraDirLightsInWorld = v11;
  }
}
// 5D1B42: variable 'v8' is possibly undefined
// 5D1B42: variable 'v7' is possibly undefined
// 5D1B52: variable 'v9' is possibly undefined
// 5D1B80: variable 'v10' is possibly undefined

//----- (005D1C34) --------------------------------------------------------
void __fastcall RemoveExtraDirectionalLights(RpWorld_0 *world)
{
  pExtraDirectionals[0]->object.object.flags = 0;
  pExtraDirectionals[1]->object.object.flags = 0;
  pExtraDirectionals[2]->object.object.flags = 0;
  NumExtraDirLightsInWorld = 0;
}

//----- (005D1C5C) --------------------------------------------------------
void __fastcall SetAmbientAndDirectionalColours(float Mult)
{
  AmbientLightColour.red = AmbientLightColourForFrame.red * Mult;
  AmbientLightColour.green = AmbientLightColourForFrame.green * Mult;
  DirectionalLightColour.red = DirectionalLightColourForFrame.red * Mult;
  DirectionalLightColour.green = DirectionalLightColourForFrame.green * Mult;
  AmbientLightColour.blue = AmbientLightColourForFrame.blue * Mult;
  DirectionalLightColour.blue = DirectionalLightColourForFrame.blue * Mult;
  RpLightSetColor(pAmbient, &AmbientLightColour);
  sub_19321C(pDirect, &DirectionalLightColour);
}

//----- (005D1CF8) --------------------------------------------------------
void __fastcall SetFlashyColours(float Mult)
{
  if ( BYTE1(CTimer::m_snTimeInMilliseconds) << 31 )
  {
    AmbientLightColour.red = 1.0;
    AmbientLightColour.green = 1.0;
    AmbientLightColour.blue = 1.0;
    DirectionalLightColour.red = DirectionalLightColourForFrame.red;
    DirectionalLightColour.green = DirectionalLightColourForFrame.green;
    DirectionalLightColour.blue = DirectionalLightColourForFrame.blue;
  }
  else
  {
    DirectionalLightColour.red = (float)(Mult * 0.75) * DirectionalLightColourForFrame.red;
    AmbientLightColour.red = (float)(Mult * 0.75) * AmbientLightColourForFrame.red;
    AmbientLightColour.green = (float)(Mult * 0.75) * AmbientLightColourForFrame.green;
    AmbientLightColour.blue = (float)(Mult * 0.75) * AmbientLightColourForFrame.blue;
    DirectionalLightColour.green = (float)(Mult * 0.75) * DirectionalLightColourForFrame.green;
    DirectionalLightColour.blue = (float)(Mult * 0.75) * DirectionalLightColourForFrame.blue;
  }
  RpLightSetColor(pAmbient, &AmbientLightColour);
  sub_19321C(pDirect, &DirectionalLightColour);
}

//----- (005D1DFC) --------------------------------------------------------
void __fastcall SetFlashyColours_Mild(float Mult)
{
  if ( BYTE1(CTimer::m_snTimeInMilliseconds) << 31 )
  {
    qmemcpy(&AmbientLightColour, "ff&?ff&?ff&?", 12);
    DirectionalLightColour.red = DirectionalLightColourForFrame.red;
    DirectionalLightColour.green = DirectionalLightColourForFrame.green;
    DirectionalLightColour.blue = DirectionalLightColourForFrame.blue;
  }
  else
  {
    AmbientLightColour.red = (float)(Mult * 0.9) * AmbientLightColourForFrame.red;
    AmbientLightColour.green = (float)(Mult * 0.9) * AmbientLightColourForFrame.green;
    DirectionalLightColour.red = (float)(Mult * 0.9) * DirectionalLightColourForFrame.red;
    DirectionalLightColour.green = (float)(Mult * 0.9) * DirectionalLightColourForFrame.green;
    AmbientLightColour.blue = (float)(Mult * 0.9) * AmbientLightColourForFrame.blue;
    DirectionalLightColour.blue = (float)(Mult * 0.9) * DirectionalLightColourForFrame.blue;
  }
  RpLightSetColor(pAmbient, &AmbientLightColour);
  sub_19321C(pDirect, &DirectionalLightColour);
}

//----- (005D1F08) --------------------------------------------------------
void __fastcall SetBrightMarkerColours(float Mult)
{
  AmbientLightColour.red = 0.6;
  AmbientLightColour.green = 0.6;
  AmbientLightColour.blue = 0.6;
  DirectionalLightColour.red = 1.0;
  DirectionalLightColour.green = 1.0;
  DirectionalLightColour.blue = 1.0;
  RpLightSetColor(pAmbient, &AmbientLightColour);
  sub_19321C(pDirect, &DirectionalLightColour);
}

//----- (005D1F5C) --------------------------------------------------------
void ReSetAmbientAndDirectionalColours()
{
  RpLightSetColor(pAmbient, &AmbientLightColourForFrame);
  sub_19321C(pDirect, &DirectionalLightColourForFrame);
}

//----- (005D1F98) --------------------------------------------------------
void DeActivateDirectional()
{
  pDirect->object.object.flags = 0;
}

//----- (005D1FAC) --------------------------------------------------------
void ActivateDirectional()
{
  pDirect->object.object.flags = 1;
}

//----- (005D1FC0) --------------------------------------------------------
void __fastcall SetAmbientColoursToIndicateRoadGroup(Int32 Number)
{
  int v1; // r0
  unsigned int v2; // r2
  unsigned int v3; // r0

  v1 = Number % 7;
  v2 = IndicateG[v1];
  AmbientLightColour.red = (float)IndicateR[v1] / 255.0;
  v3 = IndicateB[v1];
  AmbientLightColour.green = (float)v2 / 255.0;
  AmbientLightColour.blue = (float)v3 / 255.0;
  sub_19321C(pAmbient, &AmbientLightColour);
}

//----- (005D204C) --------------------------------------------------------
void SetFullAmbient()
{
  sub_19321C(pAmbient, &FullLight);
}

//----- (005D2068) --------------------------------------------------------
void SetAmbientColours()
{
  sub_19321C(pAmbient, &AmbientLightColourForFrame);
}

//----- (005D2084) --------------------------------------------------------
void __fastcall SetAmbientColours(RwRGBAReal_0 *pRgba)
{
  sub_19321C(pAmbient, pRgba);
}

//----- (005D2098) --------------------------------------------------------
void __fastcall SetDirectionalColours(RwRGBAReal_0 *pRgba)
{
  sub_19321C(pDirect, pRgba);
}

//----- (005D20AC) --------------------------------------------------------
void __fastcall SetLightColoursForPedsCarsAndObjects(float Mult)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float32x2_t v4; // d0

  v4.n64_f32[1] = CTimeCycle::m_BrightnessAddedToAmbientGreen;
  DirectionalLightColour.red = DirectionalLightColourForFrame.red * Mult;
  DirectionalLightColour.green = DirectionalLightColourForFrame.green * Mult;
  AmbientLightColour.red = CTimeCycle::m_BrightnessAddedToAmbientRed
                         + (float)(AmbientLightColourForFrame_PedsCarsAndObjects.red * Mult);
  AmbientLightColour.green = CTimeCycle::m_BrightnessAddedToAmbientGreen
                           + (float)(AmbientLightColourForFrame_PedsCarsAndObjects.green * Mult);
  DirectionalLightColour.blue = DirectionalLightColourForFrame.blue * Mult;
  AmbientLightColour.blue = CTimeCycle::m_BrightnessAddedToAmbientBlue
                          + (float)(AmbientLightColourForFrame_PedsCarsAndObjects.blue * Mult);
  if ( CGame::currArea )
  {
    v3.n64_u32[0] = 1045220557;
    v1.n64_f32[0] = CTimeCycle::m_BrightnessAddedToAmbientRed
                  + (float)(AmbientLightColourForFrame_PedsCarsAndObjects.red * Mult);
    LODWORD(AmbientLightColour.red) = vmax_f32(v1, v3).n64_u32[0];
    v4.n64_f32[0] = CTimeCycle::m_BrightnessAddedToAmbientGreen
                  + (float)(AmbientLightColourForFrame_PedsCarsAndObjects.green * Mult);
    LODWORD(AmbientLightColour.green) = vmax_f32(v4, v3).n64_u32[0];
    v2.n64_f32[0] = CTimeCycle::m_BrightnessAddedToAmbientBlue
                  + (float)(AmbientLightColourForFrame_PedsCarsAndObjects.blue * Mult);
    LODWORD(AmbientLightColour.blue) = vmax_f32(v2, v3).n64_u32[0];
  }
  RpLightSetColor(pAmbient, &AmbientLightColour);
  sub_19321C(pDirect, &DirectionalLightColour);
}
// 5D2158: variable 'v1' is possibly undefined
// 5D2158: variable 'v3' is possibly undefined
// 5D2154: variable 'v2' is possibly undefined

//----- (005D21CC) --------------------------------------------------------
void SetLightsForInfraredVisionHeatObjects()
{
  RpLightSetColor(pAmbient, &CPostEffects::m_fInfraredVisionHeatObjectCol);
  sub_19321C(pDirect, &CPostEffects::m_fInfraredVisionHeatObjectCol);
}

//----- (005D2204) --------------------------------------------------------
void StoreAndSetLightsForInfraredVisionHeatObjects()
{
  originalAmbientColour = AmbientLightColour;
  originalDirectionalColour = DirectionalLightColour;
  RpLightSetColor(pAmbient, &CPostEffects::m_fInfraredVisionHeatObjectCol);
  sub_19321C(pDirect, &CPostEffects::m_fInfraredVisionHeatObjectCol);
}

//----- (005D226C) --------------------------------------------------------
void RestoreLightsForInfraredVisionHeatObjects()
{
  RpLightSetColor(pAmbient, &originalAmbientColour);
  sub_19321C(pDirect, &originalDirectionalColour);
}

//----- (005D22A4) --------------------------------------------------------
void SetLightsForInfraredVisionDefaultObjects()
{
  RwRGBAReal_0 v0; // [sp+0h] [bp-18h] BYREF

  v0 = (RwRGBAReal_0)xmmword_60ED98;
  RpLightSetColor(pAmbient, &v0);
  RpLightSetColor(pDirect, &v0);
}
// 60ED98: using guessed type __int128 xmmword_60ED98;
// 5D22A4: using guessed type RwRGBAReal_0 var_18;

//----- (005D22E4) --------------------------------------------------------
void SetLightsForNightVision()
{
  RwRGBAReal_0 v0; // [sp+0h] [bp-18h] BYREF

  v0 = (RwRGBAReal_0)xmmword_61FA20;
  RpLightSetColor(pAmbient, &v0);
  RpLightSetColor(pDirect, &v0);
}
// 61FA20: using guessed type __int128 xmmword_61FA20;
// 5D22E4: using guessed type RwRGBAReal_0 var_18;

//----- (005D2324) --------------------------------------------------------
void __fastcall CommonSize::Init(CommonSize *this, int32 size)
{
  this->m_startBlock.m_pNextFreeBlock = &this->m_endBlock;
  this->m_endBlock.m_pPrevFreeBlock = &this->m_startBlock;
  this->m_size = size;
  this->m_count = 0;
  this->m_free = 0;
}

//----- (005D2336) --------------------------------------------------------
HeapBlockDesc *__fastcall CommonSize::Malloc(CommonSize *this)
{
  HeapFreeBlockDesc *p_m_endBlock; // r2
  HeapBlockDesc *result; // r0

  p_m_endBlock = &this->m_endBlock;
  result = &this->m_startBlock.m_pNextFreeBlock->hb;
  if ( result == (HeapBlockDesc *)p_m_endBlock )
  {
    ++this->m_count;
    return 0;
  }
  else
  {
    --this->m_free;
    *(_DWORD *)(result[1].blockSize + 20) = *(_DWORD *)&result[1].isAllocated;
    *(_DWORD *)(*(_DWORD *)&result[1].isAllocated + 16) = result[1].blockSize;
  }
  return result;
}

//----- (005D2360) --------------------------------------------------------
void __fastcall HeapFreeBlockDesc::RemoveHeapFreeBlock(HeapFreeBlockDesc *this)
{
  this->m_pNextFreeBlock->m_pPrevFreeBlock = this->m_pPrevFreeBlock;
  this->m_pPrevFreeBlock->m_pNextFreeBlock = this->m_pNextFreeBlock;
}

//----- (005D236E) --------------------------------------------------------
void __fastcall CommonSize::Free(CommonSize *this, HeapFreeBlockDesc *pData)
{
  int32 m_free; // r2

  pData->m_pNextFreeBlock = this->m_startBlock.m_pNextFreeBlock;
  this->m_startBlock.m_pNextFreeBlock->m_pPrevFreeBlock = pData;
  pData->m_pPrevFreeBlock = &this->m_startBlock;
  m_free = this->m_free;
  this->m_startBlock.m_pNextFreeBlock = pData;
  this->m_free = m_free + 1;
}

//----- (005D2382) --------------------------------------------------------
void __fastcall HeapFreeBlockDesc::InsertHeapFreeBlock(HeapFreeBlockDesc *this, HeapFreeBlockDesc *pBlock)
{
  pBlock->m_pNextFreeBlock = this->m_pNextFreeBlock;
  this->m_pNextFreeBlock->m_pPrevFreeBlock = pBlock;
  pBlock->m_pPrevFreeBlock = this;
  this->m_pNextFreeBlock = pBlock;
}

//----- (005D2392) --------------------------------------------------------
HeapFreeBlockDesc *__fastcall HeapFreeBlockDesc::FindSmallestFreeBlock(HeapFreeBlockDesc *this, int32 size)
{
  do
    this = this->m_pNextFreeBlock;
  while ( this->hb.blockSize < size );
  return this;
}

//----- (005D239C) --------------------------------------------------------
void __fastcall HeapFreeBlockDesc::InsertOrderedHeapFreeBlock(HeapFreeBlockDesc *this, HeapFreeBlockDesc *pBlock)
{
  HeapFreeBlockDesc *m_pPrevFreeBlock; // r0

  do
    this = this->m_pNextFreeBlock;
  while ( this->hb.blockSize < pBlock->hb.blockSize );
  m_pPrevFreeBlock = this->m_pPrevFreeBlock;
  pBlock->m_pNextFreeBlock = m_pPrevFreeBlock->m_pNextFreeBlock;
  m_pPrevFreeBlock->m_pNextFreeBlock->m_pPrevFreeBlock = pBlock;
  pBlock->m_pPrevFreeBlock = m_pPrevFreeBlock;
  m_pPrevFreeBlock->m_pNextFreeBlock = pBlock;
}

//----- (005D23B6) --------------------------------------------------------
void __fastcall HeapFreeBlockDesc::ReplaceHeapFreeBlock(HeapFreeBlockDesc *this, HeapFreeBlockDesc *pBlock)
{
  pBlock->m_pNextFreeBlock = this->m_pNextFreeBlock;
  this->m_pNextFreeBlock->m_pPrevFreeBlock = pBlock;
  pBlock->m_pPrevFreeBlock = this->m_pPrevFreeBlock;
  this->m_pPrevFreeBlock->m_pNextFreeBlock = pBlock;
}

//----- (005D23C8) --------------------------------------------------------
void __fastcall CMemoryHeap::CMemoryHeap(CMemoryHeap *this)
{
  this->m_pHeap = 0;
}

//----- (005D23CE) --------------------------------------------------------
void __fastcall CMemoryHeap::Init(CMemoryHeap *this, void *pBuffer, size_t size, bool bIncludeCommonSizes)
{
  HeapFreeBlockDesc *m_pHeap; // r1
  CommonSize *v6; // r0
  int v7; // r1
  int v8; // r0
  CommonSize *m_pCommonSizes; // r2
  char *v10; // r2

  this->m_memUsed = 0;
  this->m_id = -1;
  this->m_restrictMemoryMove = 1;
  this->m_pHeap = (uint8 *)pBuffer;
  this->m_pHeapEnd = (HeapBlockDesc *)((char *)pBuffer + size - 16);
  *((char *)pBuffer + size - 12) = 1;
  this->m_pHeapEnd->refId = -1;
  this->m_pHeapEnd->blockSize = 0;
  this->m_pHeapEnd->m_pPrevBlock = (HeapBlockDesc *)this->m_pHeap;
  *(_DWORD *)this->m_pHeap = size - 32;
  this->m_pHeap[4] = 0;
  *((_DWORD *)this->m_pHeap + 3) = 0;
  this->m_endFreeBlock.m_pPrevFreeBlock = &this->m_startFreeBlock;
  m_pHeap = (HeapFreeBlockDesc *)this->m_pHeap;
  this->m_endFreeBlock.hb.blockSize = 0x7FFFFFFF;
  this->m_startFreeBlock.m_pNextFreeBlock = &this->m_endFreeBlock;
  m_pHeap->m_pNextFreeBlock = &this->m_endFreeBlock;
  this->m_startFreeBlock.m_pNextFreeBlock->m_pPrevFreeBlock = m_pHeap;
  m_pHeap->m_pPrevFreeBlock = &this->m_startFreeBlock;
  this->m_startFreeBlock.m_pNextFreeBlock = m_pHeap;
  if ( bIncludeCommonSizes )
  {
    this->m_pCommonSizes = 0;
    v6 = (CommonSize *)CMemoryHeap::Malloc(this, 0xF00u);
    this->m_pCommonSizes = v6;
    v6->m_startBlock.m_pNextFreeBlock = &v6->m_endBlock;
    v6->m_endBlock.m_pPrevFreeBlock = &v6->m_startBlock;
    v6->m_size = 16;
    v6->m_count = 0;
    v7 = 32;
    v6->m_free = 0;
    v8 = 116;
    do
    {
      m_pCommonSizes = this->m_pCommonSizes;
      *(size_t *)((char *)&m_pCommonSizes->m_startBlock.hb.blockSize + v8) = 0;
      v10 = (char *)m_pCommonSizes + v8;
      *((_DWORD *)v10 - 10) = v10 - 32;
      *((_DWORD *)v10 - 3) = v10 - 56;
      *((_DWORD *)v10 - 2) = v7;
      v7 += 16;
      v8 += 60;
      *((_DWORD *)v10 - 1) = 0;
    }
    while ( v7 != 1040 );
  }
}

//----- (005D2488) --------------------------------------------------------
void *__fastcall CMemoryHeap::Malloc(CMemoryHeap *this, size_t size)
{
  size_t v2; // r12
  size_t v3; // r1
  CommonSize *m_pCommonSizes; // r4
  int v5; // lr
  int i; // r2
  CommonSize *v7; // r3
  CMemoryHeap *m_pNextFreeBlock; // r1
  uint32 *p_m_debugInfo; // r4
  size_t blockSize; // r2

  v2 = size;
  v3 = size + 16;
  if ( (v2 & 0xF) != 0 )
    v2 = v3 & 0xFFFFFFF0;
  if ( v2 <= 0x400 )
  {
    m_pCommonSizes = this->m_pCommonSizes;
    if ( m_pCommonSizes )
    {
      v5 = (v2 >> 4) - 1;
      for ( i = 60 * (v2 >> 4) - 8; ; i += 60 )
      {
        v7 = *(CommonSize **)((char *)m_pCommonSizes + i - 36);
        if ( (CommonSize *)((char *)m_pCommonSizes + i - 28) == v7 )
        {
          ++*(size_t *)((char *)&m_pCommonSizes->m_startBlock.hb.blockSize + i);
          if ( v5 > 62 )
            break;
        }
        else
        {
          --*(_DWORD *)(&m_pCommonSizes->m_startBlock.hb.isAllocated + i);
          v7->m_startBlock.m_pNextFreeBlock->m_pPrevFreeBlock = v7->m_startBlock.m_pPrevFreeBlock;
          v7->m_startBlock.m_pPrevFreeBlock->m_pNextFreeBlock = v7->m_startBlock.m_pNextFreeBlock;
          if ( v7 )
          {
            v7->m_startBlock.hb.isAllocated = 1;
            blockSize = v7->m_startBlock.hb.blockSize;
            v7->m_startBlock.hb.refId = this->m_id;
            this->m_memUsed += blockSize + 16;
            return &v7->m_startBlock.m_pNextFreeBlock;
          }
          if ( v5 > 62 )
            break;
        }
        m_pCommonSizes = this->m_pCommonSizes;
        ++v5;
      }
    }
  }
  m_pNextFreeBlock = (CMemoryHeap *)this->m_startFreeBlock.m_pNextFreeBlock;
  if ( m_pNextFreeBlock == (CMemoryHeap *)&this->m_endFreeBlock )
    return 0;
  while ( m_pNextFreeBlock->m_pHeap < (uint8 *)v2 )
  {
    m_pNextFreeBlock = (CMemoryHeap *)m_pNextFreeBlock->m_startFreeBlock.hb.m_debugInfo;
    if ( m_pNextFreeBlock == (CMemoryHeap *)&this->m_endFreeBlock )
      return 0;
  }
  p_m_debugInfo = &m_pNextFreeBlock->m_startFreeBlock.hb.m_debugInfo;
  *(_DWORD *)(m_pNextFreeBlock->m_startFreeBlock.hb.m_debugInfo + 20) = m_pNextFreeBlock->m_startFreeBlock.hb.m_pPrevBlock;
  m_pNextFreeBlock->m_startFreeBlock.hb.m_pPrevBlock[1].blockSize = m_pNextFreeBlock->m_startFreeBlock.hb.m_debugInfo;
  CMemoryHeap::FillInBlockData(
    this,
    (HeapBlockDesc *)m_pNextFreeBlock,
    (HeapBlockDesc *)&m_pNextFreeBlock->m_pHeap[(unsigned int)m_pNextFreeBlock + 16],
    v2);
  return p_m_debugInfo;
}

//----- (005D255C) --------------------------------------------------------
void __fastcall CMemoryHeap::Shutdown(CMemoryHeap *this)
{
  free(this->m_pHeap);
  this->m_pHeap = 0;
}

//----- (005D2570) --------------------------------------------------------
void __fastcall CMemoryHeap::RegisterMalloc(CMemoryHeap *this, HeapBlockDesc *pBlock)
{
  size_t blockSize; // r3

  pBlock->isAllocated = 1;
  blockSize = pBlock->blockSize;
  pBlock->refId = this->m_id;
  this->m_memUsed += blockSize + 16;
}

//----- (005D2584) --------------------------------------------------------
void __fastcall CMemoryHeap::Free(CMemoryHeap *this, void *pMem)
{
  HeapFreeBlockDesc *v2; // r1
  int v3; // t1
  HeapFreeBlockDesc *m_pPrevBlock; // r12
  char *v5; // r2
  int v6; // r3
  _DWORD *v7; // r2
  CommonSize *m_pCommonSizes; // r3
  unsigned int blockSize; // r2
  CommonSize *v10; // r0
  int32 m_free; // r2
  HeapFreeBlockDesc *p_m_startFreeBlock; // r0
  HeapFreeBlockDesc *m_pPrevFreeBlock; // r0

  if ( !pMem )
    return;
  v3 = *((_DWORD *)pMem - 4);
  v2 = (HeapFreeBlockDesc *)((char *)pMem - 16);
  this->m_memUsed += -16 - v3;
  m_pPrevBlock = (HeapFreeBlockDesc *)v2->hb.m_pPrevBlock;
  v5 = (char *)v2 + v2->hb.blockSize;
  v2->hb.isAllocated = 0;
  v6 = (unsigned __int8)v5[20];
  v7 = v5 + 16;
  if ( v6 )
  {
    if ( !m_pPrevBlock )
      goto LABEL_8;
LABEL_6:
    if ( !m_pPrevBlock->hb.isAllocated )
    {
      m_pPrevBlock->m_pNextFreeBlock->m_pPrevFreeBlock = m_pPrevBlock->m_pPrevFreeBlock;
      m_pPrevBlock->m_pPrevFreeBlock->m_pNextFreeBlock = m_pPrevBlock->m_pNextFreeBlock;
      v2 = m_pPrevBlock;
    }
    goto LABEL_8;
  }
  *(_DWORD *)(v7[4] + 20) = v7[5];
  *(_DWORD *)(v7[5] + 16) = v7[4];
  v7 = (_DWORD *)((char *)v7 + *v7 + 16);
  if ( m_pPrevBlock )
    goto LABEL_6;
LABEL_8:
  v2->hb.blockSize = (char *)(v7 - 4) - (char *)v2;
  v7[3] = v2;
  m_pCommonSizes = this->m_pCommonSizes;
  blockSize = v2->hb.blockSize;
  if ( m_pCommonSizes && blockSize <= 0x400 )
  {
    v10 = &m_pCommonSizes[blockSize >> 4];
    v2->m_pNextFreeBlock = v10[-1].m_startBlock.m_pNextFreeBlock;
    v10[-1].m_startBlock.m_pNextFreeBlock->m_pPrevFreeBlock = v2;
    v2->m_pPrevFreeBlock = &v10[-1].m_startBlock;
    m_free = v10[-1].m_free;
    v10[-1].m_startBlock.m_pNextFreeBlock = v2;
    v10[-1].m_free = m_free + 1;
  }
  else
  {
    p_m_startFreeBlock = &this->m_startFreeBlock;
    do
      p_m_startFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
    while ( p_m_startFreeBlock->hb.blockSize < blockSize );
    m_pPrevFreeBlock = p_m_startFreeBlock->m_pPrevFreeBlock;
    v2->m_pNextFreeBlock = m_pPrevFreeBlock->m_pNextFreeBlock;
    m_pPrevFreeBlock->m_pNextFreeBlock->m_pPrevFreeBlock = v2;
    v2->m_pPrevFreeBlock = m_pPrevFreeBlock;
    m_pPrevFreeBlock->m_pNextFreeBlock = v2;
  }
}

//----- (005D264C) --------------------------------------------------------
void __fastcall CMemoryHeap::RegisterFree(CMemoryHeap *this, HeapFreeBlockDesc *pBlock)
{
  this->m_memUsed += -16 - pBlock->hb.blockSize;
}

//----- (005D265C) --------------------------------------------------------
void *__fastcall CMemoryHeap::Realloc(CMemoryHeap *this, void *pMem, size_t size)
{
  _DWORD *v3; // r4
  unsigned int v4; // r3
  unsigned int v6; // r0
  HeapBlockDesc *v7; // r1
  int *v8; // r2
  int v9; // r6
  void *v10; // r0
  void *v11; // r6
  HeapBlockDesc *v13; // r0

  v3 = pMem;
  v4 = size;
  if ( !pMem )
    return CMemoryHeap::Malloc(this, size);
  v7 = (HeapBlockDesc *)((char *)pMem - 16);
  v6 = *(v3 - 4);
  if ( (size & 0xF) != 0 )
    v4 = (size + 16) & 0xFFFFFFF0;
  if ( v4 <= v6 )
  {
    this->m_memUsed += -16 - v6;
    v13 = (HeapBlockDesc *)((char *)v7 + v7->blockSize);
  }
  else
  {
    if ( *(&v7[1].isAllocated + v6) || (v8 = (int *)((char *)&v7[1] + v6), v9 = *v8, v6 + *v8 + 16 < v4) )
    {
      v10 = CMemoryHeap::Malloc(this, v4);
      v11 = v10;
      if ( !v10 )
        return 0;
      qmemcpy(v10, v3, *(v3 - 4));
      CMemoryHeap::Free(this, v3);
      return v11;
    }
    *(_DWORD *)(*(size_t *)((char *)&v7[2].blockSize + v6) + 20) = *(_DWORD *)(&v7[2].isAllocated + v6);
    *(_DWORD *)(*(_DWORD *)(&v7[2].isAllocated + v6) + 16) = *(size_t *)((char *)&v7[2].blockSize + v6);
    this->m_memUsed += -16 - v7->blockSize;
    v13 = (HeapBlockDesc *)((char *)v8 + v9);
  }
  CMemoryHeap::FillInBlockData(this, v7, v13 + 1, v4);
  return v3;
}

//----- (005D2716) --------------------------------------------------------
void __fastcall CMemoryHeap::IntegrityCheck(const CMemoryHeap *this)
{
  const CMemoryHeap *i; // r1
  CommonSize *m_pCommonSizes; // r12
  int j; // r2
  CommonSize *v4; // r1
  HeapFreeBlockDesc *m_pNextFreeBlock; // r3
  HeapFreeBlockDesc *k; // r1
  uint8 *m_pHeap; // r1
  uint8 *m_pHeapEnd; // lr
  int v9; // r3
  int v10; // r2
  _DWORD v11[22]; // [sp-58h] [bp-58h] BYREF

  for ( i = (const CMemoryHeap *)this->m_startFreeBlock.m_pNextFreeBlock;
        i != (const CMemoryHeap *)&this->m_endFreeBlock;
        i = (const CMemoryHeap *)i->m_startFreeBlock.hb.m_debugInfo )
  {
    ;
  }
  m_pCommonSizes = this->m_pCommonSizes;
  if ( m_pCommonSizes )
  {
    for ( j = 0; j != 64; ++j )
    {
      v4 = &m_pCommonSizes[j];
      m_pNextFreeBlock = v4->m_startBlock.m_pNextFreeBlock;
      for ( k = &v4->m_endBlock; m_pNextFreeBlock != k; m_pNextFreeBlock = m_pNextFreeBlock->m_pNextFreeBlock )
        ;
    }
  }
  memset(v11, 0, 80);
  m_pHeapEnd = (uint8 *)this->m_pHeapEnd;
  m_pHeap = this->m_pHeap;
  if ( this->m_pHeap != m_pHeapEnd )
  {
    do
    {
      v9 = *(_DWORD *)m_pHeap;
      if ( m_pHeap[4] )
      {
        v10 = *((__int16 *)m_pHeap + 3);
        if ( v10 != -1 )
        {
          v11[v10] += v9 + 16;
          v9 = *(_DWORD *)m_pHeap;
        }
      }
      m_pHeap += v9 + 16;
    }
    while ( m_pHeapEnd != m_pHeap );
    m_pHeap = m_pHeapEnd;
  }
  do
    m_pHeap = (uint8 *)*((_DWORD *)m_pHeap + 3);
  while ( m_pHeap );
}

//----- (005D27C4) --------------------------------------------------------
int32 __fastcall CMemoryHeap::GetSizeOfHoles(const CMemoryHeap *this)
{
  HeapFreeBlockDesc *v1; // r2
  HeapFreeBlockDesc *p_m_endFreeBlock; // lr
  HeapFreeBlockDesc *m_pNextFreeBlock; // r3
  int32 result; // r0
  bool v6; // zf
  HeapFreeBlockDesc *v7; // r1
  CommonSize *m_pCommonSizes; // r12
  int i; // lr
  CommonSize *v10; // r1
  HeapFreeBlockDesc *v11; // r3
  HeapFreeBlockDesc *j; // r1
  size_t blockSize; // r2

  p_m_endFreeBlock = &this->m_endFreeBlock;
  m_pNextFreeBlock = this->m_startFreeBlock.m_pNextFreeBlock;
  result = 0;
  v6 = m_pNextFreeBlock == p_m_endFreeBlock;
  if ( m_pNextFreeBlock != p_m_endFreeBlock )
  {
    v1 = m_pNextFreeBlock->m_pNextFreeBlock;
    v6 = v1 == p_m_endFreeBlock;
  }
  if ( !v6 )
  {
    result = 0;
    do
    {
      v7 = v1;
      result += m_pNextFreeBlock->hb.blockSize;
      if ( v1 == p_m_endFreeBlock )
        break;
      v1 = v1->m_pNextFreeBlock;
      m_pNextFreeBlock = v7;
    }
    while ( v1 != p_m_endFreeBlock );
  }
  m_pCommonSizes = this->m_pCommonSizes;
  if ( m_pCommonSizes )
  {
    for ( i = 0; i != 64; ++i )
    {
      v10 = &m_pCommonSizes[i];
      v11 = v10->m_startBlock.m_pNextFreeBlock;
      for ( j = &v10->m_endBlock; v11 != j; result += blockSize )
      {
        blockSize = v11->hb.blockSize;
        v11 = v11->m_pNextFreeBlock;
      }
    }
  }
  return result;
}
// 5D27E0: variable 'v1' is possibly undefined

//----- (005D2828) --------------------------------------------------------
void __fastcall CMemoryHeap::ParseHeap(const CMemoryHeap *this)
{
  u_native v2; // r5
  HeapBlockDesc *m_pHeap; // r11
  int v4; // r8
  __int16 v5; // r2
  size_t v6; // r9
  int v7; // r10
  int v8; // r9
  size_t v9; // [sp+8h] [bp-38h]
  unsigned __int8 v10; // [sp+Fh] [bp-31h] BYREF
  unsigned __int8 s[16]; // [sp+10h] [bp-30h] BYREF

  v2 = CFileMgr::OpenFileForWriting("heap.txt");
  CTimer::Stop();
  m_pHeap = (HeapBlockDesc *)this->m_pHeap;
  if ( this->m_pHeap < (uint8 *)this->m_pHeapEnd )
  {
    v4 = 0;
    do
    {
      v5 = m_pHeap->refId + 64;
      if ( !(unsigned __int8)m_pHeap->refId )
        LOBYTE(v5) = 42;
      v6 = m_pHeap->blockSize >> 4;
      v10 = v5;
      if ( !(v4 << 26) )
      {
        sprintf(s, "\n%5dK:", v4 / 64);
        CFileMgr::Write(v2, s, 8);
      }
      CFileMgr::Write(v2, "#", 1);
      ++v4;
      if ( v6 )
      {
        v7 = -v6;
        v9 = v6;
        v8 = v4;
        do
        {
          if ( !(v8 << 26) )
          {
            sprintf(s, "\n%5dK:", v8 / 64);
            CFileMgr::Write(v2, s, 8);
          }
          CFileMgr::Write(v2, &v10, 1);
          ++v7;
          ++v8;
        }
        while ( v7 );
        v4 += v9;
      }
      m_pHeap = (HeapBlockDesc *)((char *)m_pHeap + m_pHeap->blockSize + 16);
    }
    while ( this->m_pHeapEnd > m_pHeap );
  }
  CTimer::Update();
  CFileMgr::CloseFile(v2);
}

//----- (005D294C) --------------------------------------------------------
void __fastcall CMemoryHeap::SetDebugInfo(void *pMem, uint32 info)
{
  *((_DWORD *)pMem - 2) = info;
}

//----- (005D2952) --------------------------------------------------------
uint32 __fastcall CMemoryHeap::GetDebugInfo(void *pMem)
{
  return *((_DWORD *)pMem - 2);
}

//----- (005D295C) --------------------------------------------------------
unsigned __int8 *__fastcall CMemoryHeap::MoveHeapBlock(
        CMemoryHeap *this,
        HeapFreeBlockDesc *pNewBlock,
        HeapBlockDesc *pOldBlock)
{
  int32 m_id; // r8
  HeapFreeBlockDesc **p_m_pNextFreeBlock; // r5

  m_id = this->m_id;
  this->m_id = pOldBlock->refId;
  p_m_pNextFreeBlock = &pNewBlock->m_pNextFreeBlock;
  pNewBlock->m_pNextFreeBlock->m_pPrevFreeBlock = pNewBlock->m_pPrevFreeBlock;
  pNewBlock->m_pPrevFreeBlock->m_pNextFreeBlock = pNewBlock->m_pNextFreeBlock;
  CMemoryHeap::FillInBlockData(
    this,
    &pNewBlock->hb,
    (HeapBlockDesc *)((char *)&pNewBlock->m_pNextFreeBlock + pNewBlock->hb.blockSize),
    pOldBlock->blockSize);
  this->m_id = m_id;
  qmemcpy(p_m_pNextFreeBlock, &pOldBlock[1], pOldBlock->blockSize);
  memMoved += pOldBlock->blockSize;
  CMemoryHeap::Free(this, &pOldBlock[1]);
  return (unsigned __int8 *)p_m_pNextFreeBlock;
}

//----- (005D29C8) --------------------------------------------------------
HeapFreeBlockDesc *__fastcall CMemoryHeap::WhereShouldMemoryMove(CMemoryHeap *this, void *pMem)
{
  unsigned int v2; // r4
  int v3; // r12
  int v4; // r1
  HeapFreeBlockDesc *p_m_startFreeBlock; // r1
  unsigned int blockSize; // r3

  v2 = *((_DWORD *)pMem - 4);
  v3 = v2;
  if ( !*((char *)pMem + v2 + 4) )
    v3 = *(_DWORD *)((char *)pMem + v2) + v2 + 16;
  v4 = *((_DWORD *)pMem - 1);
  if ( !*(_BYTE *)(v4 + 4) )
    v3 += *(_DWORD *)v4 + 16;
  if ( v3 == v2 )
    return 0;
  p_m_startFreeBlock = &this->m_startFreeBlock;
  do
  {
    p_m_startFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
    blockSize = p_m_startFreeBlock->hb.blockSize;
  }
  while ( p_m_startFreeBlock->hb.blockSize < v2 );
  if ( blockSize >= v3 - 16 )
    return 0;
  if ( this->m_restrictMemoryMove && (float)((float)((float)v2 * 1.25) + 16.0) <= (float)blockSize )
    return 0;
  return p_m_startFreeBlock;
}

//----- (005D2A50) --------------------------------------------------------
void *__fastcall CMemoryHeap::MoveMemory(CMemoryHeap *this, void *pMem)
{
  unsigned int v4; // r0
  char *v5; // r1
  int v6; // r2
  int v7; // r1
  HeapFreeBlockDesc *p_m_startFreeBlock; // r1
  unsigned int blockSize; // r3
  int32 m_id; // r8
  HeapFreeBlockDesc **p_m_pNextFreeBlock; // r6

  v4 = *((_DWORD *)pMem - 4);
  v5 = (char *)pMem + v4 - 16;
  v6 = v4;
  if ( !v5[20] )
    v6 = *((_DWORD *)v5 + 4) + v4 + 16;
  v7 = *((_DWORD *)pMem - 1);
  if ( !*(_BYTE *)(v7 + 4) )
    v6 += *(_DWORD *)v7 + 16;
  if ( v6 == v4 )
    return pMem;
  p_m_startFreeBlock = &this->m_startFreeBlock;
  do
  {
    p_m_startFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
    blockSize = p_m_startFreeBlock->hb.blockSize;
  }
  while ( p_m_startFreeBlock->hb.blockSize < v4 );
  if ( blockSize >= v6 - 16 )
    return pMem;
  if ( this->m_restrictMemoryMove )
  {
    if ( p_m_startFreeBlock && (float)((float)((float)v4 * 1.25) + 16.0) > (float)blockSize )
      goto LABEL_12;
    return pMem;
  }
  if ( !p_m_startFreeBlock )
    return pMem;
LABEL_12:
  m_id = this->m_id;
  this->m_id = *((__int16 *)pMem - 5);
  p_m_pNextFreeBlock = &p_m_startFreeBlock->m_pNextFreeBlock;
  p_m_startFreeBlock->m_pNextFreeBlock->m_pPrevFreeBlock = p_m_startFreeBlock->m_pPrevFreeBlock;
  p_m_startFreeBlock->m_pPrevFreeBlock->m_pNextFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
  CMemoryHeap::FillInBlockData(
    this,
    &p_m_startFreeBlock->hb,
    (HeapBlockDesc *)((char *)&p_m_startFreeBlock->m_pNextFreeBlock + p_m_startFreeBlock->hb.blockSize),
    *((_DWORD *)pMem - 4));
  this->m_id = m_id;
  qmemcpy(p_m_pNextFreeBlock, pMem, *((_DWORD *)pMem - 4));
  memMoved += *((_DWORD *)pMem - 4);
  CMemoryHeap::Free(this, pMem);
  return p_m_pNextFreeBlock;
}

//----- (005D2B38) --------------------------------------------------------
void *__fastcall CMemoryHeap::MoveMemory(CMemoryHeap *this, void *pMem, void **ppMemAlign, int32 align)
{
  unsigned int v7; // r5
  _BYTE *v9; // r11
  char *v10; // r1
  int v11; // r0
  int v12; // r1
  HeapFreeBlockDesc *p_m_startFreeBlock; // r1
  unsigned int blockSize; // r2
  HeapFreeBlockDesc **p_m_pNextFreeBlock; // r6
  unsigned int v16; // r2
  void *v17; // r8
  int32 m_id; // [sp+0h] [bp-20h]

  v7 = *((_DWORD *)pMem - 4);
  v9 = *ppMemAlign;
  v10 = (char *)pMem + v7 - 16;
  v11 = v7;
  if ( !v10[20] )
    v11 = *((_DWORD *)v10 + 4) + v7 + 16;
  v12 = *((_DWORD *)pMem - 1);
  if ( !*(_BYTE *)(v12 + 4) )
    v11 += *(_DWORD *)v12 + 16;
  if ( v11 == v7 )
    return pMem;
  p_m_startFreeBlock = &this->m_startFreeBlock;
  do
  {
    p_m_startFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
    blockSize = p_m_startFreeBlock->hb.blockSize;
  }
  while ( p_m_startFreeBlock->hb.blockSize < v7 );
  if ( blockSize >= v11 - 16 )
    return pMem;
  if ( this->m_restrictMemoryMove )
  {
    if ( p_m_startFreeBlock && (float)((float)((float)v7 * 1.25) + 16.0) > (float)blockSize )
      goto LABEL_12;
    return pMem;
  }
  if ( !p_m_startFreeBlock )
    return pMem;
LABEL_12:
  m_id = this->m_id;
  this->m_id = *((__int16 *)pMem - 5);
  p_m_pNextFreeBlock = &p_m_startFreeBlock->m_pNextFreeBlock;
  p_m_startFreeBlock->m_pNextFreeBlock->m_pPrevFreeBlock = p_m_startFreeBlock->m_pPrevFreeBlock;
  p_m_startFreeBlock->m_pPrevFreeBlock->m_pNextFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
  CMemoryHeap::FillInBlockData(
    this,
    &p_m_startFreeBlock->hb,
    (HeapBlockDesc *)((char *)&p_m_startFreeBlock->m_pNextFreeBlock + p_m_startFreeBlock->hb.blockSize),
    *((_DWORD *)pMem - 4));
  this->m_id = m_id;
  qmemcpy(p_m_pNextFreeBlock, pMem, v9 - (_BYTE *)pMem);
  v16 = ((_BYTE *)pMem - v9 + v7) & -align;
  v17 = (void *)(((unsigned int)p_m_pNextFreeBlock + *((_DWORD *)pMem - 4) - v16) & -align);
  qmemcpy(v17, *ppMemAlign, v16);
  *ppMemAlign = v17;
  memMoved += *((_DWORD *)pMem - 4);
  CMemoryHeap::Free(this, pMem);
  return p_m_pNextFreeBlock;
}

//----- (005D2C58) --------------------------------------------------------
void __fastcall CMemoryHeap::FillInBlockData(
        CMemoryHeap *this,
        HeapBlockDesc *pBlock,
        HeapBlockDesc *pNextBlock,
        const size_t size)
{
  HeapBlockDesc *v4; // r12
  HeapBlockDesc *v5; // r2
  char *v6; // r1
  int v7; // r3
  _DWORD *v8; // r1
  CommonSize *m_pCommonSizes; // r2
  unsigned int v10; // r1
  CommonSize *v11; // r0
  int32 m_free; // r1
  size_t blockSize; // r3
  HeapFreeBlockDesc *p_m_startFreeBlock; // r0
  HeapFreeBlockDesc *m_pPrevFreeBlock; // r0

  v4 = (HeapBlockDesc *)((char *)pBlock + size + 16);
  pBlock->blockSize = size;
  if ( &pNextBlock[-1] <= v4 )
  {
    if ( v4 < pNextBlock )
      pBlock->blockSize = (size_t)pNextBlock - 16 - (_DWORD)pBlock;
    pNextBlock->m_pPrevBlock = pBlock;
    pBlock->isAllocated = 1;
    blockSize = pBlock->blockSize;
    pBlock->refId = this->m_id;
    this->m_memUsed += blockSize + 16;
  }
  else
  {
    pBlock->isAllocated = 1;
    pBlock->refId = this->m_id;
    this->m_memUsed += size + 16;
    *(&pBlock[1].isAllocated + size) = 0;
    v4->blockSize = (char *)&pNextBlock[-1] - (char *)v4;
    *(HeapBlockDesc **)((char *)&pBlock[1].m_pPrevBlock + size) = pBlock;
    pNextBlock->m_pPrevBlock = v4;
    v5 = *(HeapBlockDesc **)((char *)&pBlock[1].m_pPrevBlock + size);
    v6 = (char *)v4 + v4->blockSize;
    v7 = (unsigned __int8)v6[20];
    v8 = v6 + 16;
    if ( !v7 )
    {
      *(_DWORD *)(v8[4] + 20) = v8[5];
      *(_DWORD *)(v8[5] + 16) = v8[4];
      v8 = (_DWORD *)((char *)v8 + *v8 + 16);
    }
    if ( v5 && !v5->isAllocated )
    {
      v4 = v5;
      *(_DWORD *)(v5[1].blockSize + 20) = *(_DWORD *)&v5[1].isAllocated;
      *(_DWORD *)(*(_DWORD *)&v5[1].isAllocated + 16) = v5[1].blockSize;
    }
    v4->blockSize = (char *)(v8 - 4) - (char *)v4;
    v8[3] = v4;
    m_pCommonSizes = this->m_pCommonSizes;
    v10 = v4->blockSize;
    if ( m_pCommonSizes && v10 <= 0x400 )
    {
      v11 = &m_pCommonSizes[v10 >> 4];
      v4[1].blockSize = (size_t)v11[-1].m_startBlock.m_pNextFreeBlock;
      v11[-1].m_startBlock.m_pNextFreeBlock->m_pPrevFreeBlock = (HeapFreeBlockDesc *)v4;
      *(_DWORD *)&v4[1].isAllocated = v11 - 1;
      m_free = v11[-1].m_free;
      v11[-1].m_startBlock.m_pNextFreeBlock = (HeapFreeBlockDesc *)v4;
      v11[-1].m_free = m_free + 1;
    }
    else
    {
      p_m_startFreeBlock = &this->m_startFreeBlock;
      do
        p_m_startFreeBlock = p_m_startFreeBlock->m_pNextFreeBlock;
      while ( p_m_startFreeBlock->hb.blockSize < v10 );
      m_pPrevFreeBlock = p_m_startFreeBlock->m_pPrevFreeBlock;
      v4[1].blockSize = (size_t)m_pPrevFreeBlock->m_pNextFreeBlock;
      m_pPrevFreeBlock->m_pNextFreeBlock->m_pPrevFreeBlock = (HeapFreeBlockDesc *)v4;
      *(_DWORD *)&v4[1].isAllocated = m_pPrevFreeBlock;
      m_pPrevFreeBlock->m_pNextFreeBlock = (HeapFreeBlockDesc *)v4;
    }
  }
}

//----- (005D2D68) --------------------------------------------------------
void *__fastcall CMemoryMgr::InternalMalloc(size_t size)
{
  void *result; // r0

  if ( size > 0x800 )
    return sub_18DC1C(&gMainHeap, size);
  result = CMemoryHeap::Malloc(&gSmallHeap, size);
  if ( !result )
    return sub_18DC1C(&gMainHeap, size);
  return result;
}

//----- (005D2D9C) --------------------------------------------------------
void *__fastcall CMemoryMgr::InternalRealloc(void *pMem, size_t size)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  unsigned int v5; // r5
  CMemoryHeap *v6; // r0
  void *v8; // r6

  v5 = size;
  if ( gScratchPadHeap.m_pHeap <= pMem && gScratchPadHeap.m_pHeapEnd > pMem )
  {
    v6 = &gScratchPadHeap;
    return sub_19DB84(v6, pMem, size);
  }
  if ( gSmallHeap.m_pHeap > pMem || gSmallHeap.m_pHeapEnd <= pMem )
  {
    if ( size > 0x800 )
    {
      v6 = &gMainHeap;
      return sub_19DB84(v6, pMem, size);
    }
    v8 = CMemoryHeap::Malloc(&gSmallHeap, size);
    if ( v8 )
      goto LABEL_15;
    size = v5;
  }
  else if ( size <= 0x800 )
  {
    v6 = &gSmallHeap;
    return sub_19DB84(v6, pMem, size);
  }
  v8 = CMemoryHeap::Malloc(&gMainHeap, size);
  if ( !v8 )
    return 0;
LABEL_15:
  v2.n64_f32[0] = (float)v5;
  v3.n64_f32[0] = (float)*((int *)pMem - 4);
  qmemcpy(v8, pMem, (unsigned int)vmin_f32(v2, v3).n64_f32[0]);
  free(pMem);
  return v8;
}
// 5D2E30: variable 'v2' is possibly undefined
// 5D2E30: variable 'v3' is possibly undefined

//----- (005D2E84) --------------------------------------------------------
void CMemoryMgr::InitScratchPad()
{
  sub_1968E4(&gScratchPadHeap, PC_Scratch, 0x4000u, 0);
}

//----- (005D2EA0) --------------------------------------------------------
void *__fastcall CMemoryMgr::MallocFromScratchPad(size_t size)
{
  void *result; // r0
  int v2; // r12
  int v3; // r1

  result = CMemoryHeap::Malloc(&gScratchPadHeap, size);
  v2 = *((_DWORD *)result - 4) + 16;
  v3 = *((__int16 *)result - 5);
  CMemoryMgr::m_memUsed += v2;
  ++CMemoryMgr::m_blocksUsed;
  if ( v3 != -1 )
  {
    CMemoryMgr::m_pMemUsedArray[v3] += v2;
    ++CMemoryMgr::m_pBlockArray[v3];
  }
  return result;
}

//----- (005D2F18) --------------------------------------------------------
void __fastcall CMemoryMgr::RegisterMalloc(void *pMem)
{
  int v1; // lr
  int v2; // r0

  v1 = *((_DWORD *)pMem - 4) + 16;
  v2 = *((__int16 *)pMem - 5);
  CMemoryMgr::m_memUsed += v1;
  ++CMemoryMgr::m_blocksUsed;
  if ( v2 != -1 )
  {
    CMemoryMgr::m_pMemUsedArray[v2] += v1;
    ++CMemoryMgr::m_pBlockArray[v2];
  }
}

//----- (005D2F80) --------------------------------------------------------
void *__fastcall CMemoryMgr::MallocAlignFromScratchPad(size_t size, size_t align)
{
  __int16 *v3; // r0
  int v4; // r2
  int v5; // r1

  v3 = (__int16 *)CMemoryHeap::Malloc(&gScratchPadHeap, align + size);
  v4 = *((_DWORD *)v3 - 4) + 16;
  v5 = *(v3 - 5);
  CMemoryMgr::m_memUsed += v4;
  ++CMemoryMgr::m_blocksUsed;
  if ( v5 != -1 )
  {
    CMemoryMgr::m_pMemUsedArray[v5] += v4;
    ++CMemoryMgr::m_pBlockArray[v5];
  }
  *(_DWORD *)((((unsigned int)v3 + align) & -align) - 4) = v3;
  return (void *)(((unsigned int)v3 + align) & -align);
}

//----- (005D3010) --------------------------------------------------------
void *__fastcall CMemoryMgr::MallocAlign(size_t size, size_t align)
{
  void *v3; // r0

  v3 = malloc(size + align);
  *(_DWORD *)((((unsigned int)v3 + align) & -align) - 4) = v3;
  return (void *)(((unsigned int)v3 + align) & -align);
}

//----- (005D302A) --------------------------------------------------------
void __fastcall CMemoryMgr::FreeAlign(void *pMem)
{
  j_free(*((void **)pMem - 1));
}

//----- (005D3038) --------------------------------------------------------
void __fastcall CMemoryMgr::SetRestrictMemoryMove(bool bRestrict)
{
  gSmallHeap.m_restrictMemoryMove = bRestrict;
  gMainHeap.m_restrictMemoryMove = bRestrict;
}

//----- (005D3054) --------------------------------------------------------
uint32 CMemoryMgr::GetLargestFreeBlock()
{
  return gMainHeap.m_endFreeBlock.m_pPrevFreeBlock->hb.blockSize;
}

//----- (005D3064) --------------------------------------------------------
int CMemoryMgr::GetSizeOfHoles()
{
  int32 SizeOfHoles; // r4

  SizeOfHoles = CMemoryHeap::GetSizeOfHoles(&gMainHeap);
  return CMemoryHeap::GetSizeOfHoles(&gSmallHeap) + SizeOfHoles;
}

//----- (005D308C) --------------------------------------------------------
void __fastcall CMemoryMgr::InitMemoryTracking(int32 numIds)
{
  size_t v2; // r6
  int32 m_posn; // r11
  int32 *v4; // r10
  int32 *v5; // r0
  int v6; // r0

  v2 = 4 * numIds;
  CMemoryMgr::m_memUsed = 0;
  CMemoryMgr::m_idStack.m_array[CMemoryMgr::m_idStack.m_posn++] = CMemoryMgr::m_id;
  CMemoryMgr::m_idStack.m_array[CMemoryMgr::m_idStack.m_posn] = 1;
  m_posn = CMemoryMgr::m_idStack.m_posn;
  v4 = (int32 *)malloc(4 * numIds);
  CMemoryMgr::m_pMemUsedArray = v4;
  v5 = (int32 *)malloc(v2);
  CMemoryMgr::m_idStack.m_posn = m_posn;
  CMemoryMgr::m_pBlockArray = v5;
  gMainHeap.m_id = CMemoryMgr::m_idStack.m_array[m_posn];
  CMemoryMgr::m_id = gMainHeap.m_id;
  gSmallHeap.m_id = gMainHeap.m_id;
  if ( numIds >= 1 )
  {
    *v4 = 0;
    *CMemoryMgr::m_pBlockArray = 0;
    if ( numIds != 1 )
    {
      v6 = 1;
      do
      {
        CMemoryMgr::m_pMemUsedArray[v6] = 0;
        CMemoryMgr::m_pBlockArray[v6++] = 0;
      }
      while ( numIds != v6 );
    }
  }
}

//----- (005D3174) --------------------------------------------------------
void __fastcall CMemoryMgr::PushMemId(int32 id)
{
  int v1; // r3

  gMainHeap.m_id = id;
  v1 = CMemoryMgr::m_id;
  CMemoryMgr::m_id = id;
  CMemoryMgr::m_idStack.m_array[CMemoryMgr::m_idStack.m_posn] = v1;
  gSmallHeap.m_id = id;
  ++CMemoryMgr::m_idStack.m_posn;
}

//----- (005D31B8) --------------------------------------------------------
void CMemoryMgr::PopMemId()
{
  gMainHeap.m_id = CMemoryMgr::m_idStack.m_array[--CMemoryMgr::m_idStack.m_posn];
  CMemoryMgr::m_id = gMainHeap.m_id;
  gSmallHeap.m_id = gMainHeap.m_id;
}

//----- (005D31F4) --------------------------------------------------------
void __fastcall CMemoryMgr::RegisterFree(void *pMem)
{
  int v1; // lr
  int v2; // r0

  if ( pMem )
  {
    v1 = *((_DWORD *)pMem - 4) + 16;
    v2 = *((__int16 *)pMem - 5);
    CMemoryMgr::m_memUsed -= v1;
    --CMemoryMgr::m_blocksUsed;
    if ( v2 != -1 )
    {
      CMemoryMgr::m_pMemUsedArray[v2] -= v1;
      --CMemoryMgr::m_pBlockArray[v2];
    }
  }
}

//----- (005D3260) --------------------------------------------------------
int32 __fastcall CMemoryMgr::GetMemoryUsed(int32 id)
{
  return CMemoryMgr::m_pMemUsedArray[id];
}

//----- (005D3274) --------------------------------------------------------
int32 __fastcall CMemoryMgr::GetBlocksUsed(int32 id)
{
  return CMemoryMgr::m_pBlockArray[id];
}

//----- (005D3288) --------------------------------------------------------
void *__fastcall mallocAlignPC(int32 size, int32 align)
{
  void *v3; // r0

  v3 = malloc(size + align);
  *(_DWORD *)((((unsigned int)v3 + align) & -align) - 4) = v3;
  return (void *)(((unsigned int)v3 + align) & -align);
}

//----- (005D32A2) --------------------------------------------------------
void __fastcall freeAlignPC(void *pMem)
{
  j_free(*((void **)pMem - 1));
}

//----- (005D32AC) --------------------------------------------------------
void __fastcall CameraSize(RwCamera_0 *camera, RwRect_0 *rect, RwReal viewWindow, RwReal aspectRatio)
{
  RwInt32 CurrentVideoMode; // r0
  RwRaster_0 *frameBuffer; // r0
  __int64 v10; // kr00_8
  RwInt32 w; // r2
  RwInt32 height; // r5
  bool v13; // zf
  RwRaster_0 *zBuffer; // r1
  RwInt32 h; // r2
  RwInt32 v16; // r0
  RwInt32 *p_h; // r6
  RwInt32 v18; // r1
  float v19; // s2
  RwInt32 v20; // r2
  _DWORD v21[4]; // [sp+0h] [bp-40h] BYREF
  RwVideoMode_0 modeinfo; // [sp+10h] [bp-30h] BYREF
  RwV2d_0 v23; // [sp+20h] [bp-20h] BYREF

  if ( camera )
  {
    CurrentVideoMode = RwEngineGetCurrentVideoMode();
    RwEngineGetVideoModeInfo(&modeinfo, CurrentVideoMode);
    frameBuffer = camera->frameBuffer;
    v10 = *(_QWORD *)&frameBuffer->width;
    if ( rect )
    {
      w = rect->w;
    }
    else
    {
      w = modeinfo.width;
      height = modeinfo.height;
      v21[0] = 0;
      v21[1] = 0;
      if ( (modeinfo.flags & 1) == 0 )
        w = v10;
      v21[2] = w;
      if ( (modeinfo.flags & 1) == 0 )
        height = HIDWORD(v10);
      v21[3] = height;
      rect = (RwRect_0 *)v21;
    }
    v13 = (_DWORD)v10 == w;
    if ( (_DWORD)v10 == w )
      v13 = HIDWORD(v10) == rect->h;
    if ( !v13 )
    {
      zBuffer = camera->zBuffer;
      zBuffer->width = w;
      frameBuffer->width = w;
      h = rect->h;
      zBuffer->height = h;
      frameBuffer->height = h;
    }
    if ( LOBYTE(modeinfo.flags) << 31 )
    {
      v23.x = viewWindow;
      p_h = &rect->h;
      v19 = viewWindow / aspectRatio;
    }
    else
    {
      p_h = &rect->h;
      v16 = rect->h;
      v18 = rect->w;
      if ( v18 <= v16 )
      {
        v23.x = (float)((float)v18 * viewWindow) / (float)v16;
        v19 = viewWindow;
      }
      else
      {
        v23.x = viewWindow;
        v19 = (float)((float)v16 * viewWindow) / (float)v18;
      }
    }
    v23.y = v19;
    RwCameraSetViewWindow(camera, &v23);
    v20 = *p_h;
    RsGlobal.screenWidth = rect->w;
    RsGlobal.screenHeight = v20;
  }
}

//----- (005D33A4) --------------------------------------------------------
void __fastcall CameraDestroy(RwCamera_0 *camera)
{
  RwFrame_0 *parent; // r5
  RwRaster_0 *frameBuffer; // r5
  RwRaster_0 *v4; // r6
  RwRaster_0 *zBuffer; // r5
  RwRaster_0 *v6; // r6

  if ( camera )
  {
    parent = (RwFrame_0 *)camera->object.object.parent;
    if ( parent )
    {
      _rwObjectHasFrameSetFrame(camera, 0);
      RwFrameDestroy(parent);
    }
    frameBuffer = camera->frameBuffer;
    if ( frameBuffer )
    {
      v4 = frameBuffer->parent;
      RwRasterDestroy(camera->frameBuffer);
      if ( v4 )
      {
        if ( v4 != frameBuffer )
          RwRasterDestroy(v4);
      }
    }
    zBuffer = camera->zBuffer;
    if ( zBuffer )
    {
      v6 = zBuffer->parent;
      RwRasterDestroy(camera->zBuffer);
      if ( v6 )
      {
        if ( v6 != zBuffer )
          RwRasterDestroy(v6);
      }
    }
    sub_19C70C(camera);
  }
}

//----- (005D3410) --------------------------------------------------------
RwTexture_0 *__fastcall destroyTexture(RwTexture_0 *pTexture, void *data)
{
  RwTextureDestroy(pTexture);
  return 0;
}

//----- (005D341C) --------------------------------------------------------
RwTexture_0 *__fastcall RwTextureGtaStreamRead(RwStream_0 *stream)
{
  unsigned int CurrentTimeInCycles; // r8
  unsigned int CyclesPerMillisecond; // r6
  float v4; // s18
  unsigned int v5; // r0
  float v6; // s2
  float v7; // s4
  RwTexture_0 *result; // r0
  RwUInt32 filterAddressing; // r1
  int v10; // r2
  RwTexture_0 *v11; // [sp+4h] [bp-2Ch] BYREF
  RwUInt32 versionOut; // [sp+8h] [bp-28h] BYREF
  RwUInt32 lengthOut[9]; // [sp+Ch] [bp-24h] BYREF

  if ( !RwStreamFindChunk(stream, 0x15u, lengthOut, &versionOut) )
    return 0;
  CurrentTimeInCycles = CTimer::GetCurrentTimeInCycles();
  CyclesPerMillisecond = CTimer::GetCyclesPerMillisecond();
  if ( !(*((int (__fastcall **)(RwStream_0 *, RwTexture_0 **, RwUInt32))RwEngineInstance + 44))(
          stream,
          &v11,
          lengthOut[0]) )
    return 0;
  if ( gGameState == 8 )
  {
    v4 = (float)CTimer::GetCurrentTimeInCycles();
    v5 = CTimer::GetCyclesPerMillisecond();
    v6 = texLoadTime * (float)texNumLoaded;
    v7 = (float)++texNumLoaded;
    texLoadTime = (float)((float)((float)(v4 / (float)v5)
                                - (float)((float)CurrentTimeInCycles / (float)CyclesPerMillisecond))
                        + v6)
                / v7;
  }
  result = v11;
  if ( !v11 )
    return 0;
  filterAddressing = v11->filterAddressing;
  if ( (unsigned __int8)filterAddressing == 3 )
  {
    v10 = 4;
    goto LABEL_12;
  }
  if ( (unsigned __int8)filterAddressing == 1 )
  {
    v10 = 2;
LABEL_12:
    v11->filterAddressing = filterAddressing & 0xFFFFFF00 | v10;
  }
  return result;
}
// 5D341C: using guessed type RwUInt32 lengthOut[9];

//----- (005D3514) --------------------------------------------------------
RwTexDictionary_0 *__fastcall RwTexDictionaryGtaStreamRead(RwStream_0 *pStream)
{
  RwUInt32 v2; // r0
  RwTexDictionary_0 *v3; // r5
  RwTexDictionary_0 *v4; // r4
  RwTexture_0 *v7; // r1
  __int16 buffer; // [sp+4h] [bp-14h] BYREF
  RwUInt32 versionOut; // [sp+8h] [bp-10h] BYREF
  RwUInt32 lengthOut[3]; // [sp+Ch] [bp-Ch] BYREF

  if ( !RwStreamFindChunk(pStream, 1u, lengthOut, &versionOut) )
    return 0;
  v2 = RwStreamRead(pStream, &buffer, lengthOut[0]);
  if ( v2 != lengthOut[0] )
    return 0;
  v3 = RwTexDictionaryCreate();
  if ( !v3 )
    return 0;
  while ( buffer-- != 0 )
  {
    v7 = RwTextureGtaStreamRead(pStream);
    if ( !v7 )
    {
      v4 = 0;
      RwTexDictionaryForAllTextures(v3, destroyTexture, 0);
      RwTexDictionaryDestroy(v3);
      return v4;
    }
    RwTexDictionaryAddTexture(v3, v7);
  }
  return v3;
}
// 5D3514: using guessed type RwUInt32 lengthOut[3];

//----- (005D358C) --------------------------------------------------------
RwTexDictionary_0 *__fastcall RwTexDictionaryGtaStreamRead1(RwStream_0 *pStream)
{
  RwTexDictionary_0 *v2; // r4
  RwUInt32 v3; // r0
  int32 v4; // r0
  RwTexture_0 *v5; // r1
  unsigned __int16 buffer; // [sp+4h] [bp-1Ch] BYREF
  RwUInt32 versionOut; // [sp+8h] [bp-18h] BYREF
  RwUInt32 lengthOut[5]; // [sp+Ch] [bp-14h] BYREF

  v2 = 0;
  numberTextures = 0;
  if ( RwStreamFindChunk(pStream, 1u, lengthOut, &versionOut) )
  {
    v3 = RwStreamRead(pStream, &buffer, lengthOut[0]);
    if ( v3 != lengthOut[0] )
      return 0;
    v2 = RwTexDictionaryCreate();
    if ( !v2 )
      return 0;
    v4 = buffer;
    numberTextures = buffer >> 1;
    if ( buffer >> 1 < (unsigned int)buffer )
    {
      while ( 1 )
      {
        v5 = RwTextureGtaStreamRead(pStream);
        if ( !v5 )
          break;
        RwTexDictionaryAddTexture(v2, v5);
        v4 = --buffer;
        if ( numberTextures >= buffer )
          goto LABEL_7;
      }
      RwTexDictionaryForAllTextures(v2, destroyTexture, 0);
      RwTexDictionaryDestroy(v2);
      return 0;
    }
LABEL_7:
    numberTextures = v4;
    streamPosition = pStream->Type.memory.position;
  }
  return v2;
}
// 5D358C: using guessed type RwUInt32 lengthOut[5];

//----- (005D3644) --------------------------------------------------------
RwTexDictionary_0 *__fastcall RwTexDictionaryGtaStreamRead2(RwStream_0 *pStream, RwTexDictionary_0 *texDict)
{
  bool v4; // zf
  RwTexture_0 *v5; // r1
  RwTexDictionary_0 *v6; // r5

  RwStreamSkip(pStream, streamPosition - pStream->Type.memory.position);
  v4 = numberTextures-- == 0;
  if ( v4 )
    return texDict;
  while ( 1 )
  {
    v5 = RwTextureGtaStreamRead(pStream);
    if ( !v5 )
      break;
    RwTexDictionaryAddTexture(texDict, v5);
    v4 = numberTextures-- == 0;
    if ( v4 )
      return texDict;
  }
  v6 = 0;
  RwTexDictionaryForAllTextures(texDict, destroyTexture, 0);
  RwTexDictionaryDestroy(texDict);
  return v6;
}

//----- (005D36C4) --------------------------------------------------------
void __fastcall ReadVideoCardCapsFile(
        uint32 *regRasterType32,
        uint32 *regRasterType24,
        uint32 *regRasterType16,
        uint32 *regRasterType8)
{
  void *v8; // r0
  void *v9; // r6

  *regRasterType32 = -1;
  *regRasterType24 = -1;
  *regRasterType16 = -1;
  *regRasterType8 = -1;
  v8 = (void *)CFileMgr::OpenFile("DATA\\CAPS.DAT", "rb");
  v9 = v8;
  if ( v8 )
  {
    OS_FileRead(v8, regRasterType32, 4);
    OS_FileRead(v9, regRasterType24, 4);
    OS_FileRead(v9, regRasterType16, 4);
    OS_FileRead(v9, regRasterType8, 4);
    sub_19B258((u_native)v9);
  }
}

//----- (005D3740) --------------------------------------------------------
int CanVideoCardDoDXT()
{
  return 1;
}

//----- (005D3744) --------------------------------------------------------
int CheckVideoCardCaps()
{
  return 1;
}

//----- (005D3750) --------------------------------------------------------
void __fastcall ConvertingTexturesScreen(uint32 num, uint32 total, const unsigned __int8 *pMsg)
{
  float32x4_t v6; // q8
  float32x4_t v7; // q1
  float v8; // s0
  CRGBA v9; // r0
  float v10; // s0
  float v11; // s18
  GxtChar *v12; // r0
  CRGBA v13; // [sp+18h] [bp-50h] BYREF
  CRGBA v14; // [sp+1Ch] [bp-4Ch] BYREF
  CRect Rectangle; // [sp+20h] [bp-48h] BYREF

  if ( DoRWStuffStartOfFrame(0, 0, 0, 0, 0, 0, 255) == 1 )
  {
    CFont::InitPerFrame();
    DefinedState2d();
    CLoadingScreen::RenderSplash();
    v6.n128_u64[0] = 0x4378000043480000LL;
    v6.n128_u64[1] = 0x4370000043DC0000LL;
    v7.n128_f32[1] = (float)RsGlobal.screenHeight / 448.0;
    v7.n128_f32[0] = (float)RsGlobal.screenWidth / 640.0;
    v7.n128_f32[2] = v7.n128_f32[0];
    v7.n128_f32[3] = v7.n128_f32[1];
    Rectangle = (CRect)vmulq_f32(v7, v6);
    CRGBA::CRGBA(&v14, 0x40u, 0x40u, 0x40u, 0xFFu);
    CSprite2d::DrawRect(&Rectangle, &v14);
    Rectangle.left = (float)((float)RsGlobal.screenWidth / 640.0) * 200.0;
    Rectangle.bottom = (float)((float)RsGlobal.screenHeight / 448.0) * 240.0;
    Rectangle.right = (float)((float)((float)((float)num / (float)total) * 240.0) + 200.0)
                    * (float)((float)RsGlobal.screenWidth / 640.0);
    Rectangle.top = (float)((float)RsGlobal.screenHeight / 448.0) * 248.0;
    CRGBA::CRGBA(&v14, 0xFFu, 0xD9u, 0x6Au, 0xFFu);
    CSprite2d::DrawRect(&Rectangle, &v14);
    Rectangle.left = (float)((float)RsGlobal.screenWidth / 640.0) * 120.0;
    Rectangle.bottom = (float)((float)RsGlobal.screenHeight / 448.0) * 150.0;
    Rectangle.right = (float)RsGlobal.screenWidth - Rectangle.left;
    Rectangle.top = (float)RsGlobal.screenHeight + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -220.0);
    CRGBA::CRGBA(&v14, 0x32u, 0x32u, 0x32u, 0xD2u);
    CSprite2d::DrawRect(&Rectangle, &v14);
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    v8 = (float)((float)RsGlobal.screenHeight / 448.0) * 0.7;
    CFont::SetScale(v8);
    CFont::SetWrapx((float)RsGlobal.screenWidth - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 170.0));
    CFont::SetOrientation(1u);
    CRGBA::CRGBA(&v13, 0xFFu, 0xD9u, 0x6Au, 0xFFu);
    CFont::SetColor(v9);
    CFont::SetFontStyle(1u);
    v10 = (float)RsGlobal.screenWidth / 640.0;
    v11 = (float)((float)RsGlobal.screenHeight / 448.0) * 160.0;
    v12 = CText::Get(&TheText, pMsg);
    CFont::PrintString(v10 * 170.0, v11, v12);
    CFont::RenderFontBuffer();
    DoRWStuffEndOfFrame(0);
  }
}
// 5D393A: variable 'v9' is possibly undefined

//----- (005D39E8) --------------------------------------------------------
void __fastcall DealWithTxdWriteError(uint32 num, uint32 total, const unsigned __int8 *pError)
{
  CPad *Pad; // r0
  _BOOL4 EscapeJustDown; // r0
  bool v8; // zf

  if ( !RsGlobal.quit )
  {
    do
    {
      ConvertingTexturesScreen(num, total, pError);
      CPad::UpdatePads();
      Pad = CPad::GetPad(0);
      EscapeJustDown = CPad::GetEscapeJustDown(Pad);
      v8 = RsGlobal.quit == 0;
      if ( !RsGlobal.quit )
        v8 = !EscapeJustDown;
    }
    while ( v8 );
  }
  RsGlobal.quit = 0;
  LoadingScreen(0, 0, 0);
  RsGlobal.quit = 1;
}

//----- (005D3A54) --------------------------------------------------------
int CreateTxdImageForVideoCard()
{
  CDirectory *v0; // r0

  v0 = (CDirectory *)operator new(0x10u);
  CDirectory::CDirectory(v0, 5000);
  return 1;
}

//----- (005D3A6C) --------------------------------------------------------
void *__fastcall TxdParentConstructor(void *pTxd, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pTxd + ms_txdPluginOffset) = 0;
  return pTxd;
}

//----- (005D3A80) --------------------------------------------------------
void *__fastcall TxdParentCopyConstructor(void *pDestTxd, const void *pSrcTxd, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pDestTxd + ms_txdPluginOffset) = *(_DWORD *)((char *)pSrcTxd + ms_txdPluginOffset);
  return pDestTxd;
}

//----- (005D3A90) --------------------------------------------------------
void CTxdStore::Initialise()
{
  CPool<TxdDef,TxdDef> *v0; // r4
  uint8 *v1; // r0
  uint8 v2; // r1
  int i; // r0

  if ( !CTxdStore::ms_pTxdPool )
  {
    v0 = (CPool<TxdDef,TxdDef> *)operator new(0x14u);
    v0->m_aStorage = (CPool<TxdDef,TxdDef>::StorageType *)operator new[]((unsigned int)&stru_445BC.st_value);
    v1 = (uint8 *)operator new[](0x1388u);
    v0->m_bOwnsArrays = 1;
    v0->m_aFlags = v1;
    v0->m_nSize = 5000;
    v0->m_nFreeIndex = -1;
    v2 = v1[1];
    *v1 = 0x80;
    v1[1] = v2 | 0x80;
    v0->m_aFlags[1] &= 0x80u;
    for ( i = 2; i != 5000; ++i )
    {
      v0->m_aFlags[i] |= 0x80u;
      v0->m_aFlags[i] &= 0x80u;
    }
    CTxdStore::ms_pTxdPool = v0;
  }
  gSpecialSlots[0] = CTxdStore::AddTxdSlot((const unsigned __int8 *)off_5D3B6C, "player", 0);
  gSpecialSlots[1] = CTxdStore::AddTxdSlot((const unsigned __int8 *)off_5D3B6C, "player", 0);
  gSpecialSlots[2] = CTxdStore::AddTxdSlot((const unsigned __int8 *)off_5D3B6C, "player", 0);
  gSpecialSlots[3] = CTxdStore::AddTxdSlot((const unsigned __int8 *)off_5D3B6C, "player", 0);
  RwTextureSetFindCallBack(CTxdStore::TxdStoreFindCB);
  sub_19AED0(TxdStoreLoadCB);
}
// 0: using guessed type int dword_0;
// 445BC: using guessed type Elf32_Sym stru_445BC;
// 5D3B6C: using guessed type __int16 *off_5D3B6C[2];

//----- (005D3B84) --------------------------------------------------------
int32 __fastcall CTxdStore::AddTxdSlot(const unsigned __int8 *pName, const unsigned __int8 *dbName, bool keepCPU)
{
  int v5; // r3
  CPool<TxdDef,TxdDef> *v6; // r0
  int32 m_nSize; // r1
  int32 m_nFreeIndex; // r6
  uint8 *m_aFlags; // r4
  int v10; // r5

  v5 = 0;
  v6 = CTxdStore::ms_pTxdPool;
  m_nFreeIndex = CTxdStore::ms_pTxdPool->m_nFreeIndex;
  m_nSize = CTxdStore::ms_pTxdPool->m_nSize;
  do
  {
    v6->m_nFreeIndex = ++m_nFreeIndex;
    if ( m_nFreeIndex == m_nSize )
    {
      m_nFreeIndex = 0;
      v6->m_nFreeIndex = 0;
      if ( v5 << 31 )
        goto LABEL_7;
      v5 = 1;
    }
    m_aFlags = v6->m_aFlags;
    v10 = (char)m_aFlags[m_nFreeIndex];
  }
  while ( v10 > -1 );
  m_aFlags[m_nFreeIndex] = v10 & 0x7F;
  v6->m_aFlags[v6->m_nFreeIndex] = (v6->m_aFlags[v6->m_nFreeIndex] + 1) & 0x7F | v6->m_aFlags[v6->m_nFreeIndex] & 0x80;
  m_nFreeIndex = (int32)v6->m_aStorage[v6->m_nFreeIndex];
LABEL_7:
  *(_QWORD *)m_nFreeIndex = 0xFFFF000000000000LL;
  *(_BYTE *)(m_nFreeIndex + 52) = keepCPU;
  *(_DWORD *)(m_nFreeIndex + 8) = CKeyGen::GetUppercaseKey(pName);
  strcpy((char *)(m_nFreeIndex + 12), (const char *)pName);
  strcpy((char *)(m_nFreeIndex + 32), (const char *)dbName);
  return -1227133513 * ((signed int)(m_nFreeIndex - (unsigned int)CTxdStore::ms_pTxdPool->m_aStorage) >> 3);
}

//----- (005D3C34) --------------------------------------------------------
RwTexture_0 *__fastcall CTxdStore::TxdStoreFindCB(const unsigned __int8 *pTexname)
{
  TextureDatabaseRuntime *Database; // r6
  TextureDatabaseRuntime *v3; // r5
  unsigned int numEntries; // r0
  int v5; // r2
  RwTexture_0 *Texture; // r4
  int v7; // r2
  RwTexDictionary_0 *Current; // r5

  Database = TextureDatabaseRuntime::GetDatabase("gta_int");
  v3 = TextureDatabaseRuntime::GetDatabase("gta3");
  numEntries = TextureDatabaseRuntime::registered.numEntries;
  if ( TextureDatabaseRuntime::registered.numEntries )
  {
    v5 = 0;
    while ( TextureDatabaseRuntime::registered.dataPtr[v5] != Database )
    {
      if ( ++v5 >= TextureDatabaseRuntime::registered.numEntries )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    TextureDatabaseRuntime::Register(Database);
    Texture = TextureDatabaseRuntime::GetTexture(pTexname);
    TextureDatabaseRuntime::Unregister(Database);
    if ( Texture )
      return Texture;
    numEntries = TextureDatabaseRuntime::registered.numEntries;
    if ( !TextureDatabaseRuntime::registered.numEntries )
    {
LABEL_10:
      TextureDatabaseRuntime::Register(v3);
      Texture = TextureDatabaseRuntime::GetTexture(pTexname);
      TextureDatabaseRuntime::Unregister(v3);
      if ( Texture )
        return Texture;
      goto LABEL_11;
    }
  }
  v7 = 0;
  while ( TextureDatabaseRuntime::registered.dataPtr[v7] != v3 )
  {
    if ( ++v7 >= numEntries )
      goto LABEL_10;
  }
LABEL_11:
  Current = RwTexDictionaryGetCurrent();
  if ( !Current )
    return 0;
  while ( 1 )
  {
    Texture = RwTexDictionaryFindNamedTexture(Current, pTexname);
    if ( Texture )
      break;
    Current = *(RwTexDictionary_0 **)(&Current->object.type + ms_txdPluginOffset);
    if ( !Current )
      return 0;
  }
  return Texture;
}

//----- (005D3D0C) --------------------------------------------------------
RwTexture_0 *__fastcall TxdStoreLoadCB(const unsigned __int8 *pTexname, const unsigned __int8 *pMaskName)
{
  return 0;
}

//----- (005D3D10) --------------------------------------------------------
bool CTxdStore::PluginAttach()
{
  ms_txdPluginOffset = RwTexDictionaryRegisterPlugin(
                         4,
                         0x253F2F5u,
                         TxdParentConstructor,
                         TxdParentDestructor,
                         TxdParentCopyConstructor);
  return ms_txdPluginOffset != -1;
}

//----- (005D3D60) --------------------------------------------------------
void CTxdStore::Shutdown()
{
  CPool<TxdDef,TxdDef> *v0; // r4
  uint8 *m_aFlags; // r0
  uint8 **p_m_aFlags; // r5

  v0 = CTxdStore::ms_pTxdPool;
  if ( CTxdStore::ms_pTxdPool )
  {
    if ( CTxdStore::ms_pTxdPool->m_nSize >= 1 )
    {
      if ( CTxdStore::ms_pTxdPool->m_bOwnsArrays )
      {
        if ( CTxdStore::ms_pTxdPool->m_aStorage )
          operator delete[](CTxdStore::ms_pTxdPool->m_aStorage);
        p_m_aFlags = &v0->m_aFlags;
        m_aFlags = v0->m_aFlags;
        if ( m_aFlags )
          operator delete[](m_aFlags);
      }
      else
      {
        p_m_aFlags = &CTxdStore::ms_pTxdPool->m_aFlags;
      }
      v0->m_aStorage = 0;
      *p_m_aFlags = 0;
    }
    sub_191374(v0);
  }
}

//----- (005D3DAC) --------------------------------------------------------
void CTxdStore::GameShutdown()
{
  int v0; // r4
  int i; // r6
  CPool<TxdDef,TxdDef> *v2; // r1
  uint8 *m_aFlags; // r2
  RwTexDictionary_0 *v4; // r0
  CPool<TxdDef,TxdDef>::StorageType *m_aStorage; // r0
  int v6; // r3
  int v7; // r0

  v0 = 0;
  for ( i = 0; i != 5000; ++i )
  {
    v2 = CTxdStore::ms_pTxdPool;
    m_aFlags = CTxdStore::ms_pTxdPool->m_aFlags;
    if ( (m_aFlags[i] & 0x80u) == 0
      && CTxdStore::ms_pTxdPool->m_aStorage[v0]
      && !*(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[v0][4] )
    {
      v4 = *(RwTexDictionary_0 **)&CTxdStore::ms_pTxdPool->m_aStorage[v0][0];
      if ( v4
        && (RwTexDictionaryDestroy(v4),
            v2 = CTxdStore::ms_pTxdPool,
            m_aFlags = CTxdStore::ms_pTxdPool->m_aFlags,
            (char)m_aFlags[i] <= -1) )
      {
        m_aStorage = CTxdStore::ms_pTxdPool->m_aStorage;
        v6 = 0;
      }
      else
      {
        m_aStorage = v2->m_aStorage;
        v6 = (int)v2->m_aStorage[v0];
      }
      v7 = -1227133513 * ((v6 - (int)m_aStorage) >> 3);
      m_aFlags[v7] |= 0x80u;
      if ( v7 < v2->m_nFreeIndex )
        v2->m_nFreeIndex = v7;
    }
    ++v0;
  }
}

//----- (005D3E34) --------------------------------------------------------
int32 __fastcall CTxdStore::GetNumRefs(int32 index)
{
  return *(__int16 *)&CTxdStore::ms_pTxdPool->m_aStorage[index][4];
}

//----- (005D3E50) --------------------------------------------------------
void __fastcall CTxdStore::RemoveTxdSlot(int32 index)
{
  int v2; // r5
  CPool<TxdDef,TxdDef> *v3; // r1
  RwTexDictionary_0 *v4; // r0
  uint8 *m_aFlags; // r0
  CPool<TxdDef,TxdDef>::StorageType *m_aStorage; // r2
  uint8 *v7; // r3
  int v8; // r2

  v2 = index;
  v3 = CTxdStore::ms_pTxdPool;
  v4 = *(RwTexDictionary_0 **)&CTxdStore::ms_pTxdPool->m_aStorage[index][0];
  if ( v4 )
  {
    RwTexDictionaryDestroy(v4);
    v3 = CTxdStore::ms_pTxdPool;
  }
  m_aFlags = v3->m_aFlags;
  m_aStorage = v3->m_aStorage;
  if ( (char)m_aFlags[index] <= -1 )
    v7 = 0;
  else
    v7 = m_aStorage[v2];
  v8 = -1227133513 * ((v7 - (uint8 *)m_aStorage) >> 3);
  m_aFlags[v8] |= 0x80u;
  if ( v8 < v3->m_nFreeIndex )
    v3->m_nFreeIndex = v8;
}

//----- (005D3EB0) --------------------------------------------------------
int32 __fastcall CTxdStore::FindTxdSlot(const unsigned __int8 *pName)
{
  uint32 UppercaseKey; // r0
  int32 v2; // r4
  int v3; // r2
  int32 v4; // r1
  int32 m_nSize; // r6
  int i; // r3

  UppercaseKey = CKeyGen::GetUppercaseKey(pName);
  if ( CTxdStore::ms_lastSlotFound >= 0 )
  {
    v2 = CTxdStore::ms_lastSlotFound;
    v3 = 56 * CTxdStore::ms_lastSlotFound + 8;
    do
    {
      v4 = v2;
      if ( (CTxdStore::ms_pTxdPool->m_aFlags[v2] & 0x80u) == 0
        && &(*CTxdStore::ms_pTxdPool->m_aStorage)[v3] != (uint8 *)byte_8
        && *(_DWORD *)&(*CTxdStore::ms_pTxdPool->m_aStorage)[v3] == UppercaseKey )
      {
        goto LABEL_14;
      }
      v3 -= 56;
      --v2;
    }
    while ( v4 > 0 );
  }
  m_nSize = CTxdStore::ms_pTxdPool->m_nSize;
  v4 = CTxdStore::ms_lastSlotFound + 1;
  if ( CTxdStore::ms_lastSlotFound + 1 < m_nSize )
  {
    for ( i = 56 * CTxdStore::ms_lastSlotFound + 64;
          (CTxdStore::ms_pTxdPool->m_aFlags[v4] & 0x80u) != 0
       || &(*CTxdStore::ms_pTxdPool->m_aStorage)[i] == (uint8 *)byte_8
       || *(_DWORD *)&(*CTxdStore::ms_pTxdPool->m_aStorage)[i] != UppercaseKey;
          i += 56 )
    {
      if ( ++v4 >= m_nSize )
        return -1;
    }
LABEL_14:
    CTxdStore::ms_lastSlotFound = v4;
    return v4;
  }
  return -1;
}

//----- (005D3F6C) --------------------------------------------------------
int32 __fastcall CTxdStore::FindTxdSlotFromHashKey(const int32 hashKey)
{
  int32 m_nSize; // r3
  int32 result; // r0
  int i; // r2

  m_nSize = CTxdStore::ms_pTxdPool->m_nSize;
  if ( m_nSize < 1 )
    return -1;
  result = 0;
  for ( i = 8;
        (CTxdStore::ms_pTxdPool->m_aFlags[result] & 0x80u) != 0
     || &(*CTxdStore::ms_pTxdPool->m_aStorage)[i] == (uint8 *)byte_8
     || *(_DWORD *)&(*CTxdStore::ms_pTxdPool->m_aStorage)[i] != hashKey;
        i += 56 )
  {
    if ( ++result >= m_nSize )
      return -1;
  }
  return result;
}

//----- (005D3FB4) --------------------------------------------------------
bool __fastcall CTxdStore::LoadTxd(int32 index, const unsigned __int8 *pFilename)
{
  return 1;
}

//----- (005D3FB8) --------------------------------------------------------
void __fastcall CTxdStore::SetupTxdParent(int32 index)
{
  uint8 *v1; // r0
  int v2; // r2
  uint8 *v3; // r0

  if ( (CTxdStore::ms_pTxdPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CTxdStore::ms_pTxdPool->m_aStorage[index];
  v2 = *((__int16 *)v1 + 3);
  if ( v2 != -1 )
  {
    *(_DWORD *)(*(_DWORD *)v1 + ms_txdPluginOffset) = *(_DWORD *)&CTxdStore::ms_pTxdPool->m_aStorage[v2][0];
    v3 = CTxdStore::ms_pTxdPool->m_aStorage[*((__int16 *)v1 + 3)];
    ++*((_WORD *)v3 + 2);
  }
}

//----- (005D4030) --------------------------------------------------------
void __fastcall CTxdStore::SetTxdParent(RwTexDictionary_0 *pTxd, RwTexDictionary_0 *pParent)
{
  *(_DWORD *)(&pTxd->object.type + ms_txdPluginOffset) = pParent;
}

//----- (005D4040) --------------------------------------------------------
void __fastcall CTxdStore::AddRef(int32 index)
{
  ++*(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[index][4];
}

//----- (005D4060) --------------------------------------------------------
bool __fastcall CTxdStore::LoadTxd(int32 index, RwStream_0 *pStream)
{
  return 1;
}

//----- (005D4064) --------------------------------------------------------
bool __fastcall CTxdStore::StartLoadTxd(int32 index, RwStream_0 *pStream)
{
  return 1;
}

//----- (005D4068) --------------------------------------------------------
bool __fastcall CTxdStore::FinishLoadTxd(int32 index, RwStream_0 *pStream)
{
  return 1;
}

//----- (005D406C) --------------------------------------------------------
void __fastcall CTxdStore::Create(int32 index)
{
  uint8 *v1; // r4

  if ( (CTxdStore::ms_pTxdPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CTxdStore::ms_pTxdPool->m_aStorage[index];
  *(_DWORD *)v1 = RwTexDictionaryCreate();
}

//----- (005D409C) --------------------------------------------------------
RwTexture_0 *__fastcall RemoveIfRefCountIsGreaterThanOne(RwTexture_0 *pTexture, void *pData)
{
  if ( pTexture->refCount >= 2 )
  {
    RwTextureDestroy(pTexture);
    RwTexDictionaryRemoveTexture(pTexture);
  }
  return pTexture;
}

//----- (005D40B8) --------------------------------------------------------
void __fastcall CTxdStore::RemoveTxd(int32 index)
{
  uint8 *v1; // r4
  int v2; // r0

  if ( (CTxdStore::ms_pTxdPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CTxdStore::ms_pTxdPool->m_aStorage[index];
  if ( *(_DWORD *)v1 )
  {
    RwTexDictionaryForAllTextures(*(const RwTexDictionary_0 **)v1, RemoveIfRefCountIsGreaterThanOne, 0);
    RwTexDictionaryDestroy(*(RwTexDictionary_0 **)v1);
  }
  v2 = *((__int16 *)v1 + 3);
  if ( v2 != -1 )
    --*(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[v2][4];
  *(_DWORD *)v1 = 0;
}

//----- (005D4124) --------------------------------------------------------
void __fastcall CTxdStore::RemoveRef(int32 index)
{
  --*(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[index][4];
}

//----- (005D4144) --------------------------------------------------------
void __fastcall CTxdStore::SetCurrentTxd(int32 index, const unsigned __int8 *dbOverride)
{
  uint8 *v2; // r5
  TextureDatabaseRuntime *Database; // r4

  if ( (CTxdStore::ms_pTxdPool->m_aFlags[index] & 0x80u) != 0 )
    v2 = 0;
  else
    v2 = CTxdStore::ms_pTxdPool->m_aStorage[index];
  if ( !dbOverride )
    dbOverride = v2 + 32;
  Database = TextureDatabaseRuntime::GetDatabase((const char *)dbOverride);
  if ( CTxdStore::ms_curDB != Database )
  {
    if ( CTxdStore::ms_curDB && *CTxdStore::ms_curDB->name != 116 )
      TextureDatabaseRuntime::Unregister(CTxdStore::ms_curDB);
    TextureDatabaseRuntime::Register(Database);
    CTxdStore::ms_curDB = Database;
  }
  strcpy((char *)TextureDatabaseRuntime::curParentName, (const char *)v2 + 12);
  sub_19B9DC((char *)CTxdStore::ms_curName, (const char *)v2 + 12);
}

//----- (005D41D4) --------------------------------------------------------
void CTxdStore::PushCurrentTxd()
{
  CTxdStore::ms_storedDB = CTxdStore::ms_curDB;
  sub_19B9DC((char *)CTxdStore::ms_storedName, (const char *)CTxdStore::ms_curName);
}

//----- (005D4214) --------------------------------------------------------
void CTxdStore::PopCurrentTxd()
{
  TextureDatabaseRuntime *v0; // r0
  bool v1; // zf

  v0 = CTxdStore::ms_storedDB;
  if ( CTxdStore::ms_storedDB != CTxdStore::ms_curDB )
  {
    v1 = CTxdStore::ms_curDB == 0;
    if ( CTxdStore::ms_curDB )
      v1 = *CTxdStore::ms_curDB->name == 116;
    if ( !v1 )
    {
      TextureDatabaseRuntime::Unregister(CTxdStore::ms_curDB);
      v0 = CTxdStore::ms_storedDB;
    }
    if ( v0 )
    {
      TextureDatabaseRuntime::Register(v0);
      v0 = CTxdStore::ms_storedDB;
    }
    CTxdStore::ms_curDB = v0;
  }
  CTxdStore::ms_storedDB = 0;
  strcpy((char *)TextureDatabaseRuntime::curParentName, (const char *)CTxdStore::ms_storedName);
  sub_19B9DC((char *)CTxdStore::ms_curName, (const char *)CTxdStore::ms_storedName);
}

//----- (005D42AC) --------------------------------------------------------
void __fastcall CTxdStore::RemoveRefWithoutDelete(int32 index)
{
  --*(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[index][4];
}

//----- (005D42CC) --------------------------------------------------------
int32 __fastcall CTxdStore::GetSpecialTxdSlot(int32 index)
{
  return gSpecialSlots[index];
}

//----- (005D42DC) --------------------------------------------------------
RwTexDictionary_0 *__fastcall CTxdStore::GetTxdParent(RwTexDictionary_0 *pTxd)
{
  return *(RwTexDictionary_0 **)(&pTxd->object.type + ms_txdPluginOffset);
}

//----- (005D42EC) --------------------------------------------------------
void *__fastcall CVisibilityPlugins::AtomicConstructor(void *atom, RwInt32 offset, RwInt32 size)
{
  *(_WORD *)((char *)atom + CVisibilityPlugins::ms_atomicPluginOffset) = -1;
  *(_WORD *)((char *)atom + CVisibilityPlugins::ms_atomicPluginOffset + 2) = 0;
  return atom;
}

//----- (005D4308) --------------------------------------------------------
void *__fastcall CVisibilityPlugins::AtomicCopyConstructor(
        void *pDestAtom,
        const void *pSrcAtom,
        RwInt32 offset,
        RwInt32 size)
{
  *(_WORD *)((char *)pDestAtom + CVisibilityPlugins::ms_atomicPluginOffset) = *(_WORD *)((char *)pSrcAtom
                                                                                       + CVisibilityPlugins::ms_atomicPluginOffset);
  *(_WORD *)((char *)pDestAtom + CVisibilityPlugins::ms_atomicPluginOffset + 2) = *(_WORD *)((char *)pSrcAtom
                                                                                           + CVisibilityPlugins::ms_atomicPluginOffset
                                                                                           + 2);
  return pDestAtom;
}

//----- (005D4330) --------------------------------------------------------
void *__fastcall CVisibilityPlugins::FrameConstructor(void *pFrame, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pFrame + CVisibilityPlugins::ms_framePluginOffset) = 0;
  return pFrame;
}

//----- (005D4344) --------------------------------------------------------
void *__fastcall CVisibilityPlugins::FrameCopyConstructor(
        void *pDestFrame,
        const void *pSrcFrame,
        RwInt32 offset,
        RwInt32 size)
{
  *(_DWORD *)((char *)pDestFrame + CVisibilityPlugins::ms_framePluginOffset) = *(_DWORD *)((char *)pSrcFrame
                                                                                         + CVisibilityPlugins::ms_framePluginOffset);
  return pDestFrame;
}

//----- (005D435C) --------------------------------------------------------
void *__fastcall CVisibilityPlugins::ClumpConstructor(void *pClump, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pClump + CVisibilityPlugins::ms_clumpPluginOffset) = CVisibilityPlugins::DefaultVisibilityCB;
  *(_DWORD *)((char *)pClump + CVisibilityPlugins::ms_clumpPluginOffset + 4) = 255;
  return pClump;
}

//----- (005D4380) --------------------------------------------------------
RwBool __fastcall CVisibilityPlugins::DefaultVisibilityCB(RpClump_0 *pClump)
{
  return 1;
}

//----- (005D4384) --------------------------------------------------------
void *__fastcall CVisibilityPlugins::ClumpCopyConstructor(
        void *pDestClump,
        const void *pSrcClump,
        RwInt32 offset,
        RwInt32 size)
{
  *(_DWORD *)((char *)pDestClump + CVisibilityPlugins::ms_clumpPluginOffset) = *(_DWORD *)((char *)pSrcClump
                                                                                         + CVisibilityPlugins::ms_clumpPluginOffset);
  return pDestClump;
}

//----- (005D439C) --------------------------------------------------------
RwBool CVisibilityPlugins::PluginAttach()
{
  RwInt32 v0; // r0
  char v1; // r2

  CVisibilityPlugins::ms_atomicPluginOffset = RpAtomicRegisterPlugin(
                                                4,
                                                0x253F200u,
                                                CVisibilityPlugins::AtomicConstructor,
                                                CVisibilityPlugins::AtomicDestructor,
                                                CVisibilityPlugins::AtomicCopyConstructor);
  CVisibilityPlugins::ms_framePluginOffset = RwFrameRegisterPlugin(
                                               4,
                                               0x253F202u,
                                               CVisibilityPlugins::FrameConstructor,
                                               CVisibilityPlugins::FrameDestructor,
                                               CVisibilityPlugins::FrameCopyConstructor);
  v0 = RpClumpRegisterPlugin(
         8,
         0x253F201u,
         CVisibilityPlugins::ClumpConstructor,
         CVisibilityPlugins::ClumpDestructor,
         CVisibilityPlugins::ClumpCopyConstructor);
  v1 = 0;
  CVisibilityPlugins::ms_clumpPluginOffset = v0;
  if ( v0 != -1 )
    v1 = 1;
  return (CVisibilityPlugins::ms_atomicPluginOffset != -1) & (unsigned __int8)v1;
}

//----- (005D446C) --------------------------------------------------------
void CVisibilityPlugins::Initialise()
{
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v0; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v1; // r12
  int v2; // r0
  unsigned int v3; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pStore; // r4
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v5; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v6; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v7; // r2
  int v8; // r0
  unsigned int v9; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v10; // r4
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v11; // r5
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v12; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v13; // r2
  int v14; // r0
  unsigned int v15; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v16; // r5
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v17; // r4
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v18; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v19; // r2
  int v20; // r0
  unsigned int v21; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v22; // r5
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v23; // r4
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v24; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v25; // r2
  int v26; // r0
  unsigned int v27; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v28; // r5
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v29; // r4
  CLink<CPed *> *v30; // r0
  CLink<CPed *> *v31; // r2
  int v32; // r0
  unsigned int v33; // r1
  CLink<CPed *> *v34; // r6
  CLink<CPed *> *v35; // r5

  v0 = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)operator new[](0x190u);
  v1 = v0 + 18;
  CVisibilityPlugins::m_alphaList.m_pStore = v0;
  CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext = &CVisibilityPlugins::m_alphaList.m_lastLink;
  CVisibilityPlugins::m_alphaList.m_lastLink.m_pPrev = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList;
  CVisibilityPlugins::m_alphaList.m_lastFreeLink.m_pPrev = v0 + 19;
  v0[19].m_pPrev = &CVisibilityPlugins::m_alphaList.m_firstFreeLink;
  v0[19].m_pNext = &CVisibilityPlugins::m_alphaList.m_lastFreeLink;
  CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext = v0 + 19;
  v0[18].m_pNext = v0 + 19;
  CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->m_pPrev = v0 + 18;
  v0[18].m_pPrev = &CVisibilityPlugins::m_alphaList.m_firstFreeLink;
  v2 = 18;
  CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext = v1;
  v3 = 340;
  do
  {
    m_pStore = CVisibilityPlugins::m_alphaList.m_pStore;
    --v2;
    v5 = &CVisibilityPlugins::m_alphaList.m_pStore[v3 / 0x14];
    v3 -= 20;
    v5->m_pNext = v1;
    CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->m_pPrev = v5;
    v5->m_pPrev = &CVisibilityPlugins::m_alphaList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext = v5;
    v1 = &m_pStore[v2];
  }
  while ( v3 != -20 );
  CVisibilityPlugins::m_alphaList.m_lastLink.item.dist = 100000000.0;
  CVisibilityPlugins::m_alphaList.m_firstLink.item.dist = 0.0;
  v6 = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)operator new[](0x190u);
  CVisibilityPlugins::m_alphaBoatAtomicList.m_pStore = v6;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext = &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink.m_pPrev = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaBoatAtomicList;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_lastFreeLink.m_pPrev = v6 + 19;
  v6[19].m_pPrev = &CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink;
  v6[19].m_pNext = &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastFreeLink;
  v7 = v6 + 18;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext = v6 + 19;
  v6[18].m_pNext = v6 + 19;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->m_pPrev = v6 + 18;
  v6[18].m_pPrev = &CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink;
  v8 = 18;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext = v7;
  v9 = 340;
  do
  {
    v10 = CVisibilityPlugins::m_alphaBoatAtomicList.m_pStore;
    --v8;
    v11 = &CVisibilityPlugins::m_alphaBoatAtomicList.m_pStore[v9 / 0x14];
    v9 -= 20;
    v11->m_pNext = v7;
    CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->m_pPrev = v11;
    v11->m_pPrev = &CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext = v11;
    v7 = &v10[v8];
  }
  while ( v9 != -20 );
  CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink.item.dist = 100000000.0;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.item.dist = 0.0;
  v12 = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)operator new[](0xFA0u);
  CVisibilityPlugins::m_alphaEntityList.m_pStore = v12;
  CVisibilityPlugins::m_alphaEntityList.m_firstLink.m_pNext = &CVisibilityPlugins::m_alphaEntityList.m_lastLink;
  CVisibilityPlugins::m_alphaEntityList.m_lastLink.m_pPrev = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaEntityList;
  CVisibilityPlugins::m_alphaEntityList.m_lastFreeLink.m_pPrev = v12 + 199;
  CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext = v12 + 199;
  v12[199].m_pPrev = &CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink;
  v12[199].m_pNext = &CVisibilityPlugins::m_alphaEntityList.m_lastFreeLink;
  v13 = v12 + 198;
  v12[198].m_pNext = v12 + 199;
  CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext->m_pPrev = v12 + 198;
  v12[198].m_pPrev = &CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink;
  v14 = 198;
  CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext = v13;
  v15 = 3940;
  do
  {
    v16 = CVisibilityPlugins::m_alphaEntityList.m_pStore;
    --v14;
    v17 = &CVisibilityPlugins::m_alphaEntityList.m_pStore[v15 / 0x14];
    v15 -= 20;
    v17->m_pNext = v13;
    CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext->m_pPrev = v17;
    v17->m_pPrev = &CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext = v17;
    v13 = &v16[v14];
  }
  while ( v15 != -20 );
  CVisibilityPlugins::m_alphaEntityList.m_lastLink.item.dist = 100000000.0;
  CVisibilityPlugins::m_alphaEntityList.m_firstLink.item.dist = 0.0;
  v18 = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)operator new[](0x7D0u);
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_pStore = v18;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.m_pNext = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink.m_pPrev = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaUnderwaterEntityList;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastFreeLink.m_pPrev = v18 + 99;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext = v18 + 99;
  v18[99].m_pPrev = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink;
  v18[99].m_pNext = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastFreeLink;
  v19 = v18 + 98;
  v18[98].m_pNext = v18 + 99;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext->m_pPrev = v18 + 98;
  v18[98].m_pPrev = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink;
  v20 = 98;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext = v19;
  v21 = 1940;
  do
  {
    v22 = CVisibilityPlugins::m_alphaUnderwaterEntityList.m_pStore;
    --v20;
    v23 = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_pStore[v21 / 0x14];
    v21 -= 20;
    v23->m_pNext = v19;
    CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext->m_pPrev = v23;
    v23->m_pPrev = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext = v23;
    v19 = &v22[v20];
  }
  while ( v21 != -20 );
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink.item.dist = 100000000.0;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.item.dist = 0.0;
  v24 = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)operator new[](0x3E8u);
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_pStore = v24;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink.m_pPrev = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaReallyDrawLastList;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastFreeLink.m_pPrev = v24 + 49;
  v24[49].m_pPrev = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink;
  v24[49].m_pNext = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastFreeLink;
  v25 = v24 + 48;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext = v24 + 49;
  v24[48].m_pNext = v24 + 49;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->m_pPrev = v24 + 48;
  v24[48].m_pPrev = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink;
  v26 = 48;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext = v25;
  v27 = 940;
  do
  {
    v28 = CVisibilityPlugins::m_alphaReallyDrawLastList.m_pStore;
    --v26;
    v29 = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_pStore[v27 / 0x14];
    v27 -= 20;
    v29->m_pNext = v25;
    CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->m_pPrev = v29;
    v29->m_pPrev = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext = v29;
    v25 = &v28[v26];
  }
  while ( v27 != -20 );
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink.item.dist = 100000000.0;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.item.dist = 0.0;
  v30 = (CLink<CPed *> *)operator new[](0x4B0u);
  CVisibilityPlugins::ms_weaponPedsForPC.m_pStore = v30;
  CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext = &CVisibilityPlugins::ms_weaponPedsForPC.m_lastLink;
  CVisibilityPlugins::ms_weaponPedsForPC.m_lastLink.m_pPrev = (CLink<CPed *> *)&CVisibilityPlugins::ms_weaponPedsForPC;
  CVisibilityPlugins::ms_weaponPedsForPC.m_lastFreeLink.m_pPrev = v30 + 99;
  CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext = v30 + 99;
  v30[99].m_pPrev = &CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink;
  v30[99].m_pNext = &CVisibilityPlugins::ms_weaponPedsForPC.m_lastFreeLink;
  v31 = v30 + 98;
  v30[98].m_pNext = v30 + 99;
  CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext->m_pPrev = v30 + 98;
  v30[98].m_pPrev = &CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink;
  v32 = 98;
  CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext = v31;
  v33 = 1164;
  do
  {
    v34 = CVisibilityPlugins::ms_weaponPedsForPC.m_pStore;
    --v32;
    v35 = &CVisibilityPlugins::ms_weaponPedsForPC.m_pStore[v33 / 0xC];
    v33 -= 12;
    v35->m_pNext = v31;
    CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext->m_pPrev = v35;
    v35->m_pPrev = &CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink;
    CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext = v35;
    v31 = &v34[v32];
  }
  while ( v33 != -12 );
}

//----- (005D47B0) --------------------------------------------------------
void CVisibilityPlugins::Shutdown()
{
  if ( CVisibilityPlugins::m_alphaList.m_pStore )
    operator delete[](CVisibilityPlugins::m_alphaList.m_pStore);
  CVisibilityPlugins::m_alphaList.m_pStore = 0;
  if ( CVisibilityPlugins::m_alphaBoatAtomicList.m_pStore )
    operator delete[](CVisibilityPlugins::m_alphaBoatAtomicList.m_pStore);
  CVisibilityPlugins::m_alphaBoatAtomicList.m_pStore = 0;
  if ( CVisibilityPlugins::m_alphaEntityList.m_pStore )
    operator delete[](CVisibilityPlugins::m_alphaEntityList.m_pStore);
  CVisibilityPlugins::m_alphaEntityList.m_pStore = 0;
  if ( CVisibilityPlugins::m_alphaUnderwaterEntityList.m_pStore )
    operator delete[](CVisibilityPlugins::m_alphaUnderwaterEntityList.m_pStore);
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_pStore = 0;
  if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_pStore )
    operator delete[](CVisibilityPlugins::m_alphaReallyDrawLastList.m_pStore);
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_pStore = 0;
  if ( CVisibilityPlugins::ms_weaponPedsForPC.m_pStore )
    operator delete[](CVisibilityPlugins::ms_weaponPedsForPC.m_pStore);
  CVisibilityPlugins::ms_weaponPedsForPC.m_pStore = 0;
}

//----- (005D487C) --------------------------------------------------------
void CVisibilityPlugins::RenderWeaponPedsForPC()
{
  CLinkList<CPed *> *m_pPrev; // r11
  CPed *item; // r6
  bool v2; // zf
  RwInt32 v3; // r4
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r5
  RwMatrix *MatrixArray; // r8
  __int64 *v6; // r2
  char *parent; // r8
  __int64 *v8; // r1
  _QWORD *v9; // r0
  __int64 v10; // d16
  __int64 v11; // d17
  __int64 v12; // d23
  __int64 v13; // d18
  __int64 v14; // d19
  __int64 v15; // d20
  __int64 v16; // d21
  eWeaponType m_eWeaponType; // r4
  int8 WeaponSkill; // r0
  RwMatrix *v19; // r4
  __int64 *v20; // r0
  __int64 *v21; // r2
  __int64 *v22; // r1
  __int64 v23; // d23
  __int64 v24; // d16
  __int64 v25; // d17
  __int64 v26; // d18
  __int64 v27; // d19
  __int64 v28; // d20
  __int64 v29; // d21

  m_pPrev = (CLinkList<CPed *> *)CVisibilityPlugins::ms_weaponPedsForPC.m_lastLink.m_pPrev;
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, &dword_14);
  for ( ; m_pPrev != &CVisibilityPlugins::ms_weaponPedsForPC; m_pPrev = (CLinkList<CPed *> *)m_pPrev->m_firstLink.m_pPrev )
  {
    item = m_pPrev->m_firstLink.item;
    v2 = m_pPrev->m_firstLink.item == 0;
    if ( m_pPrev->m_firstLink.item )
      v2 = item->m_pWeaponClump == 0;
    if ( !v2 )
    {
      (*((void (__fastcall **)(CPed *))item->_vptr$CPlaceable + 20))(m_pPrev->m_firstLink.item);
      v3 = 24;
      if ( item->m_WeaponSlots[item->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_PARACHUTE )
        v3 = 3;
      AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)item->m_pRwObject);
      MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
      v6 = (__int64 *)&MatrixArray[RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, v3)];
      parent = (char *)item->m_pWeaponClump->object.parent;
      v8 = v6 + 4;
      v9 = v6 + 6;
      v10 = *v6;
      v11 = v6[1];
      v6 += 2;
      v12 = v9[1];
      v13 = *v8;
      v14 = v8[1];
      v15 = *v6;
      v16 = v6[1];
      *((_QWORD *)parent + 8) = *v9;
      *((_QWORD *)parent + 9) = v12;
      *((_QWORD *)parent + 6) = v13;
      *((_QWORD *)parent + 7) = v14;
      *((_QWORD *)parent + 4) = v15;
      *((_QWORD *)parent + 5) = v16;
      *((_QWORD *)parent + 2) = v10;
      *((_QWORD *)parent + 3) = v11;
      if ( item->m_WeaponSlots[item->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_PARACHUTE )
      {
        RwMatrixTranslate(
          (RwMatrix *)(parent + 16),
          &CVisibilityPlugins::RenderWeaponPedsForPC(void)::parachuteOffset,
          rwCOMBINEPRECONCAT);
        RwMatrixRotate((RwMatrix *)(parent + 16), &CPedIK::YaxisIK, 90.0, rwCOMBINEPRECONCAT);
      }
      CPed::SetGunFlashAlpha(item, 0);
      RwFrameUpdateObjects((RwFrame_0 *)parent);
      RpClumpRender(item->m_pWeaponClump);
      m_eWeaponType = item->m_WeaponSlots[item->m_nCurrentWeapon].m_eWeaponType;
      WeaponSkill = CPed::GetWeaponSkill(item);
      if ( (CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill)->m_nFlags & 0x800) != 0 )
      {
        v19 = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
        v20 = (__int64 *)&v19[RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 34)];
        v21 = v20 + 4;
        v22 = v20;
        v20 += 6;
        v23 = v20[1];
        v24 = *v22;
        v25 = v22[1];
        v22 += 2;
        v26 = *v21;
        v27 = v21[1];
        v28 = *v22;
        v29 = v22[1];
        *((_QWORD *)parent + 8) = *v20;
        *((_QWORD *)parent + 9) = v23;
        *((_QWORD *)parent + 6) = v26;
        *((_QWORD *)parent + 7) = v27;
        *((_QWORD *)parent + 2) = v24;
        *((_QWORD *)parent + 3) = v25;
        *((_QWORD *)parent + 4) = v28;
        *((_QWORD *)parent + 5) = v29;
        RwMatrixRotate(
          (RwMatrix *)(parent + 16),
          &CVisibilityPlugins::RenderWeaponPedsForPC(void)::axis,
          180.0,
          rwCOMBINEPRECONCAT);
        RwMatrixTranslate(
          (RwMatrix *)(parent + 16),
          &CVisibilityPlugins::RenderWeaponPedsForPC(void)::trans,
          rwCOMBINEPRECONCAT);
        CPed::SetGunFlashAlpha(item, 1);
        RwFrameUpdateObjects((RwFrame_0 *)parent);
        RpClumpRender(item->m_pWeaponClump);
      }
      CPed::ResetGunFlashAlpha(item);
    }
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 14: using guessed type int dword_14;

//----- (005D4A78) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetModelInfoIndex(RpAtomic_0 *pAtomic, int32 index)
{
  *(_WORD *)(&pAtomic->object.object.type + CVisibilityPlugins::ms_atomicPluginOffset) = index;
}

//----- (005D4A88) --------------------------------------------------------
int32 __fastcall CVisibilityPlugins::GetModelInfoIndex(RpAtomic_0 *pAtomic)
{
  return *(__int16 *)(&pAtomic->object.object.type + CVisibilityPlugins::ms_atomicPluginOffset);
}

//----- (005D4A98) --------------------------------------------------------
CBaseModelInfo *__fastcall CVisibilityPlugins::GetModelInfo(RpAtomic_0 *pAtomic)
{
  int v1; // r0

  v1 = *(__int16 *)(&pAtomic->object.object.type + CVisibilityPlugins::ms_atomicPluginOffset);
  if ( v1 == -1 )
    return 0;
  else
    return CModelInfo::ms_modelInfoPtrs[v1];
}

//----- (005D4AC0) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetAtomicId(RpAtomic_0 *pAtomic, int32 id)
{
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = id;
}

//----- (005D4AD4) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetAtomicFlag(RpAtomic_0 *pAtomic, uint16 flag)
{
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) |= flag;
}

//----- (005D4AEC) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetClumpForAllAtomicsFlag(RpClump_0 *pClump, int32 id)
{
  sub_18E410(pClump, setClumpForAllAtomicsFlagCB, (void *)id);
}

//----- (005D4AFC) --------------------------------------------------------
RpAtomic_0 *__fastcall setClumpForAllAtomicsFlagCB(RpAtomic_0 *pAtomic, void *data)
{
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) |= (unsigned __int16)data;
  return pAtomic;
}

//----- (005D4B14) --------------------------------------------------------
void __fastcall CVisibilityPlugins::ClearAtomicFlag(RpAtomic_0 *pAtomic, uint16 flag)
{
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) &= ~flag;
}

//----- (005D4B2C) --------------------------------------------------------
void __fastcall CVisibilityPlugins::ClearClumpForAllAtomicsFlag(RpClump_0 *pClump, int32 id)
{
  sub_18E410(pClump, clearClumpForAllAtomicsFlagCB, (void *)id);
}

//----- (005D4B3C) --------------------------------------------------------
RpAtomic_0 *__fastcall clearClumpForAllAtomicsFlagCB(RpAtomic_0 *pAtomic, void *data)
{
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) &= ~(_WORD)data;
  return pAtomic;
}

//----- (005D4B54) --------------------------------------------------------
int32 __fastcall CVisibilityPlugins::GetAtomicId(RpAtomic_0 *pAtomic)
{
  return *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
}

//----- (005D4B68) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetUserValue(RpAtomic_0 *pAtomic, uint16 value)
{
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = value;
}

//----- (005D4B7C) --------------------------------------------------------
uint16 __fastcall CVisibilityPlugins::GetUserValue(RpAtomic_0 *pAtomic)
{
  return *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
}

//----- (005D4B90) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetupVehicleVariables(RpClump_0 *pClump)
{
  RwFrame_0 *parent; // r4
  RwMatrix *LTM; // r0
  float y; // s8
  float z; // s10

  if ( pClump->object.type == 2 )
  {
    parent = (RwFrame_0 *)pClump->object.parent;
    LTM = RwFrameGetLTM(parent);
    y = CVisibilityPlugins::ms_pCameraPosn->y;
    z = CVisibilityPlugins::ms_pCameraPosn->z;
    gVehicleDistanceFromCamera = (float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x)
                                               * (float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x))
                                       + (float)((float)(LTM->pos.y - y) * (float)(LTM->pos.y - y)))
                               + (float)((float)(LTM->pos.z - z) * (float)(LTM->pos.z - z));
    gAngleWithHorizontal = atan2f(
                             z - parent->modelling.pos.z,
                             sqrtf(
                               (float)((float)(CVisibilityPlugins::ms_pCameraPosn->x - parent->modelling.pos.x)
                                     * (float)(CVisibilityPlugins::ms_pCameraPosn->x - parent->modelling.pos.x))
                             + (float)((float)(y - parent->modelling.pos.y) * (float)(y - parent->modelling.pos.y))));
  }
}

//----- (005D4C40) --------------------------------------------------------
float __fastcall CVisibilityPlugins::GetDistanceSquaredFromCamera(RwFrame_0 *pFrame)
{
  RwMatrix *LTM; // r0
  float32x2_t v2; // d16
  unsigned __int64 v3; // d1

  LTM = RwFrameGetLTM(pFrame);
  v2.n64_u64[0] = vsub_f32(*(float32x2_t *)&LTM->pos.y, *(float32x2_t *)&CVisibilityPlugins::ms_pCameraPosn->y).n64_u64[0];
  v3 = vmul_f32(v2, v2).n64_u64[0];
  return (float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x)
                       * (float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x))
               + *(float *)&v3)
       + *((float *)&v3 + 1);
}

//----- (005D4C84) --------------------------------------------------------
RpMaterial_0 *__fastcall SetAlphaCB(RpMaterial_0 *pMaterial, void *pData)
{
  pMaterial->color._anon_0._anon_0.alpha = (unsigned __int8)pData;
  return pMaterial;
}

//----- (005D4C88) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderWheelAtomicCB(RpAtomic_0 *pAtomic)
{
  AtomicDefaultRenderCallBack(pAtomic);
  return pAtomic;
}

//----- (005D4C98) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderObjNormalAtomic(RpAtomic_0 *pAtomic)
{
  RwMatrix *LTM; // r5
  float y; // s2
  float z; // s4
  float v5; // r0
  RwV3d_0 in; // [sp+4h] [bp-14h] BYREF

  LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent);
  y = LTM->pos.y;
  z = LTM->pos.z;
  in.x = LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x;
  in.y = y - CVisibilityPlugins::ms_pCameraPosn->y;
  in.z = z - CVisibilityPlugins::ms_pCameraPosn->z;
  v5 = RwV3dLength(&in);
  if ( v5 <= 8.0
    || (float)((float)((float)(in.x * LTM->up.x) + (float)(in.y * LTM->up.y)) + (float)(in.z * LTM->up.z)) >= (float)(v5 * -0.3) )
  {
    AtomicDefaultRenderCallBack(pAtomic);
  }
  return pAtomic;
}

//----- (005D4D4C) --------------------------------------------------------
void __fastcall CVisibilityPlugins::RenderAtomicWithAlpha(RpAtomic_0 *pAtomic, int32 alpha)
{
  emu_EnableAlphaModulate((float)alpha / 255.0);
  AtomicDefaultRenderCallBack(pAtomic);
  sub_18F834();
}

//----- (005D4D7C) --------------------------------------------------------
int32 __fastcall CVisibilityPlugins::CalculateFadingAtomicAlpha(
        CBaseModelInfo *pModelInfo,
        CEntity *pEntity,
        float dist)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  float32x2_t v6; // d4
  float32x2_t v7; // d2
  float v8; // s8

  v5.n64_u32[0] = LODWORD(pModelInfo->m_lodDistance);
  v4.n64_f32[0] = CRenderer::ms_fFarClipPlane + pModelInfo->m_pColModel->m_sphereBound.m_fRadius;
  v6.n64_f32[0] = v5.n64_f32[0] * TheCamera.LODDistMultiplier;
  v7.n64_u64[0] = vmin_f32(v6, v4).n64_u64[0];
  if ( pEntity->m_pLod )
  {
    v5.n64_f32[0] = FadeDistMult * 22.0;
  }
  else
  {
    v8 = vmin_f32(v5, v7).n64_f32[0];
    v5.n64_f32[0] = FadeDistMult * 22.0;
    if ( v8 > 150.0 )
      v5.n64_f32[0] = (float)(v8 / 15.0) + 10.0;
    if ( *((unsigned __int8 *)&pEntity->m_nFlags + 1) << 31 )
      v7.n64_f32[0] = v7.n64_f32[0] * CRenderer::ms_lowLodDistScale;
  }
  v3.n64_f32[0] = (float)((float)(v7.n64_f32[0] + (float)(FadeDistMult * 22.0)) - dist) / v5.n64_f32[0];
  v5.n64_u32[0] = 1.0;
  v3.n64_f32[0] = v3.n64_f32[0] * 0.8;
  return (int)(float)(vmin_f32(v3, v5).n64_f32[0] * (float)pModelInfo->m_alpha);
}
// 5D4DC6: variable 'v6' is possibly undefined
// 5D4DC6: variable 'v4' is possibly undefined
// 5D4DD2: variable 'v5' is possibly undefined
// 5D4E30: variable 'v3' is possibly undefined

//----- (005D4E5C) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetupRenderFadingAtomic(CBaseModelInfo *pModelInfo, int32 alpha)
{
  if ( (pModelInfo->m_flags & 4) != 0 )
    sub_192840(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;

//----- (005D4E6E) --------------------------------------------------------
void __fastcall CVisibilityPlugins::ResetRenderFadingAtomic(CBaseModelInfo *pModelInfo)
{
  if ( (pModelInfo->m_flags & 4) != 0 )
    sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 6: using guessed type char byte_6;

//----- (005D4E80) --------------------------------------------------------
void __fastcall CVisibilityPlugins::RenderFadingAtomic(CBaseModelInfo *pModelInfo, RpAtomic_0 *pAtomic, int32 alpha)
{
  if ( (pModelInfo->m_flags & 4) != 0 )
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  emu_EnableAlphaModulate((float)alpha / 255.0);
  AtomicDefaultRenderCallBack(pAtomic);
  emu_DisableAlphaModulate();
  if ( (pModelInfo->m_flags & 4) != 0 )
    sub_192840(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;

//----- (005D4EE4) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderAtomicWithAlphaCB(RpAtomic_0 *pAtomic, void *pAlpha)
{
  if ( (pAtomic->object.object.flags & 4) != 0 )
  {
    emu_EnableAlphaModulate((float)*(int *)pAlpha / 255.0);
    AtomicDefaultRenderCallBack(pAtomic);
    emu_DisableAlphaModulate();
  }
  return pAtomic;
}

//----- (005D4F1C) --------------------------------------------------------
void __fastcall CVisibilityPlugins::RenderFadingClump(CBaseModelInfo *pModelInfo, RpClump_0 *pClump, int32 alpha)
{
  int32 pData[3]; // [sp+4h] [bp-Ch] BYREF

  pData[0] = alpha;
  if ( (pModelInfo->m_flags & 4) != 0 )
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  RpClumpForAllAtomics(pClump, CVisibilityPlugins::RenderAtomicWithAlphaCB, pData);
  if ( (pModelInfo->m_flags & 4) != 0 )
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
}
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// 5D4F1C: using guessed type int32 pData[3];

//----- (005D4F60) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleReallyLowDetailCB(RpAtomic_0 *pAtomic)
{
  int v2; // r0

  if ( gVehicleDistanceFromCamera >= CVisibilityPlugins::ms_vehicleLod0Dist )
  {
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) |= 0x2000u;
    v2 = *(int *)((char *)&pAtomic->clump->object.parent + CVisibilityPlugins::ms_clumpPluginOffset);
    if ( v2 == 255 )
    {
      AtomicDefaultRenderCallBack(pAtomic);
      return pAtomic;
    }
    emu_EnableAlphaModulate((float)v2 / 255.0);
    AtomicDefaultRenderCallBack(pAtomic);
    emu_DisableAlphaModulate();
  }
  return pAtomic;
}

//----- (005D4FEC) --------------------------------------------------------
int32 __fastcall CVisibilityPlugins::GetClumpAlpha(RpClump_0 *pClump)
{
  return *(int32 *)((char *)&pClump->object.parent + CVisibilityPlugins::ms_clumpPluginOffset);
}

//----- (005D5000) --------------------------------------------------------
float __fastcall CVisibilityPlugins::GetDotProductWithCameraVector(
        RwMatrix *pMatrix,
        RwMatrix *pCarMatrix,
        uint32 atomicId)
{
  float v3; // s2
  float v4; // s4
  float v5; // s0
  float x; // s6
  RwReal *p_z; // r0
  float y; // s8
  float v9; // s8
  float v10; // s6
  float v11; // s8
  float v12; // s2
  float v13; // s2

  v3 = pMatrix->pos.x - CVisibilityPlugins::ms_pCameraPosn->x;
  v4 = pMatrix->pos.y - CVisibilityPlugins::ms_pCameraPosn->y;
  v5 = pMatrix->pos.z - CVisibilityPlugins::ms_pCameraPosn->z;
  if ( (atomicId & 0x30) != 0 )
  {
    x = pCarMatrix->up.x;
    p_z = &pCarMatrix->up.z;
    y = pCarMatrix->up.y;
LABEL_5:
    v9 = (float)((float)(v3 * x) + (float)(v4 * y)) + (float)(v5 * *p_z);
    goto LABEL_6;
  }
  if ( (atomicId & 0xC) != 0 )
  {
    x = pCarMatrix->right.x;
    p_z = &pCarMatrix->right.z;
    y = pCarMatrix->right.y;
    goto LABEL_5;
  }
  v9 = 0.0;
LABEL_6:
  v10 = -v9;
  if ( (atomicId & 0x24) == 0 )
    v10 = v9;
  if ( (atomicId & 0x8000) == 0 )
  {
    if ( (atomicId & 0x300) == 0 )
      return v10;
    if ( (atomicId & 0x100) == 0 )
      goto LABEL_11;
    goto LABEL_15;
  }
  v11 = (float)((float)(v3 * pCarMatrix->at.x) + (float)(v4 * pCarMatrix->at.y)) + (float)(v5 * pCarMatrix->at.z);
  if ( (atomicId & 0x300) != 0 )
  {
    v9 = v11 * 0.25;
    v10 = v10 + v9;
    if ( (atomicId & 0x100) == 0 )
    {
LABEL_11:
      if ( (atomicId & 0x200) != 0 )
        v9 = (float)((float)(v3 * pCarMatrix->up.x) + (float)(v4 * pCarMatrix->up.y)) + (float)(v5 * pCarMatrix->up.z);
      goto LABEL_16;
    }
LABEL_15:
    v9 = -(float)((float)((float)(v3 * pCarMatrix->up.x) + (float)(v4 * pCarMatrix->up.y))
                + (float)(v5 * pCarMatrix->up.z));
LABEL_16:
    v12 = v10;
    if ( v9 < 0.0 )
      v12 = v10 + v9;
    if ( v10 < 0.0 )
      v10 = v12;
    v13 = v10;
    if ( v10 > 0.0 )
      v13 = v9 + v10;
    if ( v9 > 0.0 )
      return v13;
    return v10;
  }
  return v10 + (float)(v11 * 2.5);
}

//----- (005D5178) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleHiDetailCB(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r5
  __int16 v3; // r1
  uint32 v4; // r5
  RwFrame_0 *parent; // r8
  RwMatrix *LTM; // r6
  RwMatrix *v7; // r0
  float DotProductWithCameraVector; // s0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_vehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    if ( gVehicleDistanceFromCamera <= CVisibilityPlugins::ms_cullCompsDist
      || (v4 = *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset),
          (v4 & 0x400) != 0)
      || gAngleWithHorizontal >= 0.2
      || (parent = (RwFrame_0 *)pAtomic->clump->object.parent,
          LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent),
          v7 = RwFrameGetLTM(parent),
          DotProductWithCameraVector = CVisibilityPlugins::GetDotProductWithCameraVector(LTM, v7, v4),
          DotProductWithCameraVector <= 0.0)
      || (v4 & 0x80) == 0
      && (float)(DotProductWithCameraVector * DotProductWithCameraVector) <= (float)(gVehicleDistanceFromCamera * 0.1) )
    {
      AtomicDefaultRenderCallBack(pAtomic);
    }
  }
  return pAtomic;
}

//----- (005D5290) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleHiDetailAlphaCB(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r2
  __int16 v3; // r0
  RwFrame_0 *parent; // r6
  RwMatrix *LTM; // r4
  uint32 v6; // r5
  RwMatrix *v7; // r0
  float DotProductWithCameraVector; // s2
  float v9; // s0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *v10; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v13; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v14; // r6
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r3
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v16; // r0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_vehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    parent = (RwFrame_0 *)pAtomic->clump->object.parent;
    LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent);
    v6 = *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v7 = RwFrameGetLTM(parent);
    DotProductWithCameraVector = CVisibilityPlugins::GetDotProductWithCameraVector(LTM, v7, v6);
    if ( gVehicleDistanceFromCamera <= CVisibilityPlugins::ms_cullCompsDist
      || (v6 & 0x400) != 0
      || gAngleWithHorizontal >= 0.2
      || (v6 & 0x80) == 0
      && (float)(DotProductWithCameraVector * DotProductWithCameraVector) <= (float)(gVehicleDistanceFromCamera * 0.1) )
    {
      if ( (v6 & 0x40) != 0 )
      {
        v9 = gVehicleDistanceFromCamera + -0.0001;
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
        {
          while ( m_pNext->m_firstLink.item.dist < v9 )
          {
            m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
            p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
            if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
              goto LABEL_23;
          }
          p_m_lastLink = &m_pNext->m_firstLink;
        }
LABEL_23:
        v13 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
        if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
          goto LABEL_25;
      }
      else
      {
        v9 = DotProductWithCameraVector + gVehicleDistanceFromCamera;
        v10 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
        {
          while ( v10->m_firstLink.item.dist < v9 )
          {
            v10 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)v10->m_firstLink.m_pNext;
            p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
            if ( v10 == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
              goto LABEL_20;
          }
          p_m_lastLink = &v10->m_firstLink;
        }
LABEL_20:
        v13 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
        if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
          goto LABEL_25;
      }
      v14 = v13->m_pNext;
      m_pPrev = v13->m_pPrev;
      v13->item.dist = v9;
      v13->item.pObj = pAtomic;
      v13->item.RenderFn = CVisibilityPlugins::RenderAtomic;
      v14->m_pPrev = m_pPrev;
      v13->m_pPrev->m_pNext = v13->m_pNext;
      v16 = p_m_lastLink->m_pPrev;
      v13->m_pNext = v16->m_pNext;
      v16->m_pNext->m_pPrev = v13;
      v13->m_pPrev = v16;
      v16->m_pNext = v13;
      if ( v13 )
        return pAtomic;
LABEL_25:
      AtomicDefaultRenderCallBack(pAtomic);
    }
  }
  return pAtomic;
}

//----- (005D5484) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertAtomicIntoSortedList(RpAtomic_0 *pAtomic, float dist)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v5; // r1
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
  p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
  if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
  {
    while ( m_pNext->m_firstLink.item.dist < dist )
    {
      m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
      p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
      if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
        goto LABEL_6;
    }
    p_m_lastLink = &m_pNext->m_firstLink;
  }
LABEL_6:
  v5 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
  if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
    return 0;
  v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->m_pPrev;
  CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->item.dist = dist;
  v5->item.pObj = pAtomic;
  v5->item.RenderFn = CVisibilityPlugins::RenderAtomic;
  *(_DWORD *)(HIDWORD(v7) + 12) = v7;
  v5->m_pPrev->m_pNext = v5->m_pNext;
  m_pPrev = p_m_lastLink->m_pPrev;
  v5->m_pNext = m_pPrev->m_pNext;
  m_pPrev->m_pNext->m_pPrev = v5;
  v5->m_pPrev = m_pPrev;
  m_pPrev->m_pNext = v5;
  return v5 != 0;
}

//----- (005D5520) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderHeliRotorAlphaCB(RpAtomic_0 *pAtomic)
{
  RwFrame_0 *parent; // r5
  RwMatrix *LTM; // r6
  RwMatrix *v4; // r0
  float x; // s6
  float y; // s8
  float v7; // s4
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r0
  float v10; // s0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v11; // r1
  __int64 v12; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_bigVehicleLod0Dist )
  {
    parent = (RwFrame_0 *)pAtomic->clump->object.parent;
    LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent);
    v4 = RwFrameGetLTM(parent);
    x = v4->at.x;
    y = v4->at.y;
    v7 = (float)(LTM->pos.z - CVisibilityPlugins::ms_pCameraPosn->z) * v4->at.z;
    m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
    p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
    v10 = gVehicleDistanceFromCamera
        + (float)((float)((float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x) * x)
                                + (float)((float)(LTM->pos.y - CVisibilityPlugins::ms_pCameraPosn->y) * y))
                        + v7)
                * 20.0);
    if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
    {
      while ( m_pNext->m_firstLink.item.dist < v10 )
      {
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
          goto LABEL_7;
      }
      p_m_lastLink = &m_pNext->m_firstLink;
    }
LABEL_7:
    v11 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
    if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
      goto LABEL_9;
    v12 = *(_QWORD *)&CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->m_pPrev;
    CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->item.dist = v10;
    v11->item.pObj = pAtomic;
    v11->item.RenderFn = CVisibilityPlugins::RenderAtomic;
    *(_DWORD *)(HIDWORD(v12) + 12) = v12;
    v11->m_pPrev->m_pNext = v11->m_pNext;
    m_pPrev = p_m_lastLink->m_pPrev;
    v11->m_pNext = m_pPrev->m_pNext;
    m_pPrev->m_pNext->m_pPrev = v11;
    v11->m_pPrev = m_pPrev;
    m_pPrev->m_pNext = v11;
    if ( !v11 )
LABEL_9:
      AtomicDefaultRenderCallBack(pAtomic);
  }
  return pAtomic;
}

//----- (005D5654) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderHeliTailRotorAlphaCB(RpAtomic_0 *pAtomic)
{
  RwFrame_0 *parent; // r5
  RwMatrix *LTM; // r6
  RwMatrix *v4; // r0
  float v5; // s2
  float v6; // s4
  float v7; // s0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r0
  float v10; // s0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v11; // r1
  __int64 v12; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_vehicleLod0Dist )
  {
    parent = (RwFrame_0 *)pAtomic->clump->object.parent;
    LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent);
    v4 = RwFrameGetLTM(parent);
    v5 = LTM->pos.y - CVisibilityPlugins::ms_pCameraPosn->y;
    v6 = LTM->pos.z - CVisibilityPlugins::ms_pCameraPosn->z;
    v7 = (float)-(float)((float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x) * v4->right.x)
                               + (float)(v5 * v4->right.y))
                       + (float)(v6 * v4->right.z))
       - (float)((float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x) * v4->up.x)
                       + (float)(v5 * v4->up.y))
               + (float)(v6 * v4->up.z));
    m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
    p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
    v10 = gVehicleDistanceFromCamera + v7;
    if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
    {
      while ( m_pNext->m_firstLink.item.dist < v10 )
      {
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
          goto LABEL_7;
      }
      p_m_lastLink = &m_pNext->m_firstLink;
    }
LABEL_7:
    v11 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
    if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
      goto LABEL_9;
    v12 = *(_QWORD *)&CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->m_pPrev;
    CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->item.dist = v10;
    v11->item.pObj = pAtomic;
    v11->item.RenderFn = CVisibilityPlugins::RenderAtomic;
    *(_DWORD *)(HIDWORD(v12) + 12) = v12;
    v11->m_pPrev->m_pNext = v11->m_pNext;
    m_pPrev = p_m_lastLink->m_pPrev;
    v11->m_pNext = m_pPrev->m_pNext;
    m_pPrev->m_pNext->m_pPrev = v11;
    v11->m_pPrev = m_pPrev;
    m_pPrev->m_pNext = v11;
    if ( !v11 )
LABEL_9:
      AtomicDefaultRenderCallBack(pAtomic);
  }
  return pAtomic;
}

//----- (005D57AC) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderTrainHiDetailCB(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r5
  __int16 v3; // r1
  uint32 v4; // r5
  RwFrame_0 *parent; // r8
  RwMatrix *LTM; // r6
  RwMatrix *v7; // r0
  float DotProductWithCameraVector; // s0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_bigVehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    if ( gVehicleDistanceFromCamera <= CVisibilityPlugins::ms_cullCompsDist
      || (v4 = *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset),
          (v4 & 0x400) != 0)
      || gAngleWithHorizontal >= 0.2
      || (parent = (RwFrame_0 *)pAtomic->clump->object.parent,
          LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent),
          v7 = RwFrameGetLTM(parent),
          DotProductWithCameraVector = CVisibilityPlugins::GetDotProductWithCameraVector(LTM, v7, v4),
          DotProductWithCameraVector <= 0.0)
      || (v4 & 0x80) == 0
      && (float)(DotProductWithCameraVector * DotProductWithCameraVector) <= (float)(gVehicleDistanceFromCamera * 0.1) )
    {
      AtomicDefaultRenderCallBack(pAtomic);
    }
  }
  return pAtomic;
}

//----- (005D58C4) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderTrainHiDetailAlphaCB(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r2
  __int16 v3; // r0
  RwFrame_0 *parent; // r6
  RwMatrix *LTM; // r4
  uint32 v6; // r5
  RwMatrix *v7; // r0
  float DotProductWithCameraVector; // s2
  float v9; // s0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *v10; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v13; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v14; // r6
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r3
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v16; // r0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_bigVehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    parent = (RwFrame_0 *)pAtomic->clump->object.parent;
    LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent);
    v6 = *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v7 = RwFrameGetLTM(parent);
    DotProductWithCameraVector = CVisibilityPlugins::GetDotProductWithCameraVector(LTM, v7, v6);
    v9 = gVehicleDistanceFromCamera;
    if ( gVehicleDistanceFromCamera <= CVisibilityPlugins::ms_cullCompsDist
      || (v6 & 0x400) != 0
      || gAngleWithHorizontal >= 0.2
      || (v6 & 0x80) == 0
      && (float)(DotProductWithCameraVector * DotProductWithCameraVector) <= (float)(gVehicleDistanceFromCamera * 0.1) )
    {
      if ( (v6 & 0x40) != 0 )
      {
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
        {
          while ( m_pNext->m_firstLink.item.dist < gVehicleDistanceFromCamera )
          {
            m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
            p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
            if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
              goto LABEL_23;
          }
          p_m_lastLink = &m_pNext->m_firstLink;
        }
LABEL_23:
        v13 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
        if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
          goto LABEL_25;
      }
      else
      {
        v9 = DotProductWithCameraVector + gVehicleDistanceFromCamera;
        v10 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
        {
          while ( v10->m_firstLink.item.dist < v9 )
          {
            v10 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)v10->m_firstLink.m_pNext;
            p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
            if ( v10 == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
              goto LABEL_20;
          }
          p_m_lastLink = &v10->m_firstLink;
        }
LABEL_20:
        v13 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
        if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
          goto LABEL_25;
      }
      v14 = v13->m_pNext;
      m_pPrev = v13->m_pPrev;
      v13->item.dist = v9;
      v13->item.pObj = pAtomic;
      v13->item.RenderFn = CVisibilityPlugins::RenderAtomic;
      v14->m_pPrev = m_pPrev;
      v13->m_pPrev->m_pNext = v13->m_pNext;
      v16 = p_m_lastLink->m_pPrev;
      v13->m_pNext = v16->m_pNext;
      v16->m_pNext->m_pPrev = v13;
      v13->m_pPrev = v16;
      v16->m_pNext = v13;
      if ( v13 )
        return pAtomic;
LABEL_25:
      AtomicDefaultRenderCallBack(pAtomic);
    }
  }
  return pAtomic;
}

//----- (005D5AAC) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleReallyLowDetailCB_BigVehicle(RpAtomic_0 *pAtomic)
{
  if ( gVehicleDistanceFromCamera >= CVisibilityPlugins::ms_bigVehicleLod0Dist )
    AtomicDefaultRenderCallBack(pAtomic);
  return pAtomic;
}

//----- (005D5AE4) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleHiDetailCB_BigVehicle(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r6
  __int16 v3; // r1
  RwFrame_0 *parent; // r5
  RwMatrix *LTM; // r6
  RwMatrix *v6; // r0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_bigVehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    if ( gVehicleDistanceFromCamera <= CVisibilityPlugins::ms_cullBigCompsDist
      || (*(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) & 0x400) != 0
      || gAngleWithHorizontal >= 0.2
      || (parent = (RwFrame_0 *)pAtomic->clump->object.parent,
          LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent),
          v6 = RwFrameGetLTM(parent),
          CVisibilityPlugins::GetDotProductWithCameraVector(
            LTM,
            v6,
            *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset)) <= 0.0) )
    {
      AtomicDefaultRenderCallBack(pAtomic);
    }
  }
  return pAtomic;
}

//----- (005D5BE4) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_BigVehicle(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r2
  __int16 v3; // r0
  RwFrame_0 *parent; // r6
  RwMatrix *LTM; // r4
  uint32 v6; // r5
  RwMatrix *v7; // r0
  float DotProductWithCameraVector; // s2
  float v9; // s0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *v10; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r0
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v13; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v14; // r6
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r3
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v16; // r0

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_bigVehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    parent = (RwFrame_0 *)pAtomic->clump->object.parent;
    LTM = RwFrameGetLTM((RwFrame_0 *)pAtomic->object.object.parent);
    v6 = *(unsigned __int16 *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v7 = RwFrameGetLTM(parent);
    DotProductWithCameraVector = CVisibilityPlugins::GetDotProductWithCameraVector(LTM, v7, v6);
    if ( gVehicleDistanceFromCamera <= CVisibilityPlugins::ms_cullBigCompsDist
      || (v6 & 0x400) != 0
      || gAngleWithHorizontal >= 0.2
      || (v6 & 0x80) == 0
      && (float)(DotProductWithCameraVector * DotProductWithCameraVector) <= (float)(gVehicleDistanceFromCamera * 0.1) )
    {
      if ( (v6 & 0x40) != 0 )
      {
        v9 = gVehicleDistanceFromCamera + -0.0001;
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
        {
          while ( m_pNext->m_firstLink.item.dist < v9 )
          {
            m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
            p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
            if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
              goto LABEL_23;
          }
          p_m_lastLink = &m_pNext->m_firstLink;
        }
LABEL_23:
        v13 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
        if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
          goto LABEL_25;
      }
      else
      {
        v9 = DotProductWithCameraVector + gVehicleDistanceFromCamera;
        v10 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
        if ( CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink )
        {
          while ( v10->m_firstLink.item.dist < v9 )
          {
            v10 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)v10->m_firstLink.m_pNext;
            p_m_lastLink = &CVisibilityPlugins::m_alphaList.m_lastLink;
            if ( v10 == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaList.m_lastLink )
              goto LABEL_20;
          }
          p_m_lastLink = &v10->m_firstLink;
        }
LABEL_20:
        v13 = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
        if ( CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaList.m_lastFreeLink )
          goto LABEL_25;
      }
      v14 = v13->m_pNext;
      m_pPrev = v13->m_pPrev;
      v13->item.dist = v9;
      v13->item.pObj = pAtomic;
      v13->item.RenderFn = CVisibilityPlugins::RenderAtomic;
      v14->m_pPrev = m_pPrev;
      v13->m_pPrev->m_pNext = v13->m_pNext;
      v16 = p_m_lastLink->m_pPrev;
      v13->m_pNext = v16->m_pNext;
      v16->m_pNext->m_pPrev = v13;
      v13->m_pPrev = v16;
      v16->m_pNext = v13;
      if ( v13 )
        return pAtomic;
LABEL_25:
      AtomicDefaultRenderCallBack(pAtomic);
    }
  }
  return pAtomic;
}

//----- (005D5DD8) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleLoDetailCB_Boat(RpAtomic_0 *pAtomic)
{
  int v2; // r0

  if ( gVehicleDistanceFromCamera >= CVisibilityPlugins::ms_vehicleLod0Dist )
  {
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) |= 0x2000u;
    v2 = *(int *)((char *)&pAtomic->clump->object.parent + CVisibilityPlugins::ms_clumpPluginOffset);
    if ( v2 == 255 )
    {
      AtomicDefaultRenderCallBack(pAtomic);
      return pAtomic;
    }
    emu_EnableAlphaModulate((float)v2 / 255.0);
    AtomicDefaultRenderCallBack(pAtomic);
    emu_DisableAlphaModulate();
  }
  return pAtomic;
}

//----- (005D5E64) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleHiDetailCB_Boat(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r2
  __int16 v3; // r1

  if ( gVehicleDistanceFromCamera < CVisibilityPlugins::ms_vehicleLod0Dist )
  {
    v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
    v3 = v2 | 0x2000;
    if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
      v3 = v2 & 0xDFFF;
    *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
    AtomicDefaultRenderCallBack(pAtomic);
  }
  return pAtomic;
}

//----- (005D5ECC) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderVehicleHiDetailAlphaCB_Boat(RpAtomic_0 *pAtomic)
{
  __int16 v2; // r3
  __int16 v3; // r1
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v6; // r1
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  if ( gVehicleDistanceFromCamera >= CVisibilityPlugins::ms_vehicleLod0Dist )
    return pAtomic;
  v2 = *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset);
  v3 = v2 | 0x2000;
  if ( CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist > gVehicleDistanceFromCamera )
    v3 = v2 & 0xDFFF;
  *(_WORD *)(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) = v3;
  if ( (*(&pAtomic->object.object.flags + CVisibilityPlugins::ms_atomicPluginOffset) & 0x40) != 0 )
  {
    m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext;
    p_m_lastLink = &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink;
    if ( CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink )
    {
      while ( m_pNext->m_firstLink.item.dist < gVehicleDistanceFromCamera )
      {
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink;
        if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink )
          goto LABEL_10;
      }
      p_m_lastLink = &m_pNext->m_firstLink;
    }
LABEL_10:
    v6 = CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext;
    if ( CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext != &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastFreeLink )
    {
      v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->m_pPrev;
      CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->item.dist = gVehicleDistanceFromCamera;
      v6->item.pObj = pAtomic;
      v6->item.RenderFn = CVisibilityPlugins::RenderAtomic;
      *(_DWORD *)(HIDWORD(v7) + 12) = v7;
      v6->m_pPrev->m_pNext = v6->m_pNext;
      m_pPrev = p_m_lastLink->m_pPrev;
      v6->m_pNext = m_pPrev->m_pNext;
      m_pPrev->m_pNext->m_pPrev = v6;
      v6->m_pPrev = m_pPrev;
      m_pPrev->m_pNext = v6;
      if ( v6 )
        return pAtomic;
    }
  }
  AtomicDefaultRenderCallBack(pAtomic);
  return pAtomic;
}

//----- (005D5FD0) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertAtomicIntoBoatSortedList(RpAtomic_0 *pAtomic, float dist)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v5; // r1
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext;
  p_m_lastLink = &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink;
  if ( CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink )
  {
    while ( m_pNext->m_firstLink.item.dist < dist )
    {
      m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
      p_m_lastLink = &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink;
      if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink )
        goto LABEL_6;
    }
    p_m_lastLink = &m_pNext->m_firstLink;
  }
LABEL_6:
  v5 = CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext;
  if ( CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastFreeLink )
    return 0;
  v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->m_pPrev;
  CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->item.dist = dist;
  v5->item.pObj = pAtomic;
  v5->item.RenderFn = CVisibilityPlugins::RenderAtomic;
  *(_DWORD *)(HIDWORD(v7) + 12) = v7;
  v5->m_pPrev->m_pNext = v5->m_pNext;
  m_pPrev = p_m_lastLink->m_pPrev;
  v5->m_pNext = m_pPrev->m_pNext;
  m_pPrev->m_pNext->m_pPrev = v5;
  v5->m_pPrev = m_pPrev;
  m_pPrev->m_pNext = v5;
  return v5 != 0;
}

//----- (005D606C) --------------------------------------------------------
RpMaterial_0 *__fastcall SetTextureCB(RpMaterial_0 *pMaterial, void *pData)
{
  RpMaterialSetTexture(pMaterial, (RwTexture_0 *)pData);
  return pMaterial;
}

//----- (005D607C) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderPlayerCB(RpAtomic_0 *pAtomic)
{
  if ( CWorld::Players[0].m_pSkinTexture )
    RpGeometryForAllMaterials(pAtomic->geometry, SetTextureCB, CWorld::Players[0].m_pSkinTexture);
  AtomicDefaultRenderCallBack(pAtomic);
  return pAtomic;
}

//----- (005D60AC) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderPedCB(RpAtomic_0 *pAtomic)
{
  RpClump_0 *clump; // r5
  RwMatrix *LTM; // r0
  float32x2_t v4; // d16
  unsigned __int64 v5; // d1
  int v6; // r0

  clump = pAtomic->clump;
  LTM = RwFrameGetLTM((RwFrame_0 *)clump->object.parent);
  v4.n64_u64[0] = vsub_f32(*(float32x2_t *)&LTM->pos.y, *(float32x2_t *)&CVisibilityPlugins::ms_pCameraPosn->y).n64_u64[0];
  v5 = vmul_f32(v4, v4).n64_u64[0];
  if ( (float)((float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x)
                             * (float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x))
                     + *(float *)&v5)
             + *((float *)&v5 + 1)) < CVisibilityPlugins::ms_pedLodDist )
  {
    v6 = *(int *)((char *)&clump->object.parent + CVisibilityPlugins::ms_clumpPluginOffset);
    if ( v6 == 255 )
    {
      AtomicDefaultRenderCallBack(pAtomic);
      return pAtomic;
    }
    emu_EnableAlphaModulate((float)v6 / 255.0);
    AtomicDefaultRenderCallBack(pAtomic);
    emu_DisableAlphaModulate();
  }
  return pAtomic;
}

//----- (005D6150) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderFadingClumpCB(RpAtomic_0 *pAtomic)
{
  int v2; // r0

  v2 = *(int *)((char *)&pAtomic->clump->object.parent + CVisibilityPlugins::ms_clumpPluginOffset);
  if ( v2 == 255 )
  {
    AtomicDefaultRenderCallBack(pAtomic);
  }
  else
  {
    emu_EnableAlphaModulate((float)v2 / 255.0);
    AtomicDefaultRenderCallBack(pAtomic);
    emu_DisableAlphaModulate();
  }
  return pAtomic;
}

//----- (005D61A0) --------------------------------------------------------
RpAtomic_0 *__fastcall CVisibilityPlugins::RenderWeaponCB(RpAtomic_0 *pAtomic)
{
  RwFrame_0 *parent; // r0
  int v3; // r5
  RwMatrix *LTM; // r0
  float32x2_t v5; // d16
  unsigned __int64 v6; // d2

  parent = (RwFrame_0 *)pAtomic->clump->object.parent;
  v3 = *(_DWORD *)(&parent->object.type + CVisibilityPlugins::ms_framePluginOffset);
  LTM = RwFrameGetLTM(parent);
  v5.n64_u64[0] = vsub_f32(*(float32x2_t *)&LTM->pos.y, *(float32x2_t *)&CVisibilityPlugins::ms_pCameraPosn->y).n64_u64[0];
  v6 = vmul_f32(v5, v5).n64_u64[0];
  if ( (float)((float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x)
                             * (float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x))
                     + *(float *)&v6)
             + *((float *)&v6 + 1)) < (float)((float)(*(float *)(v3 + 48) * TheCamera.LODDistMultiplier)
                                            * (float)(*(float *)(v3 + 48) * TheCamera.LODDistMultiplier)) )
    AtomicDefaultRenderCallBack(pAtomic);
  return pAtomic;
}

//----- (005D6220) --------------------------------------------------------
CClumpModelInfo *__fastcall CVisibilityPlugins::GetClumpModelInfo(RpClump_0 *pClump)
{
  return *(CClumpModelInfo **)((char *)pClump->object.parent + CVisibilityPlugins::ms_framePluginOffset);
}

//----- (005D6234) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetAtomicRenderCallback(RpAtomic_0 *pAtomic, RpAtomicCallBackRender renderCB)
{
  if ( !renderCB )
    renderCB = AtomicDefaultRenderCallBack;
  pAtomic->renderCallBack = renderCB;
}

//----- (005D6248) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetRenderWareCamera(RwCamera_0 *pCamera)
{
  int *v1; // r5
  float v2; // s0
  int *v3; // r5
  float v4; // s2

  v1 = dword_5D6368;
  if ( !MobileSettings::settings[0].value )
    v1 = &dword_5D6368[1];
  v2 = *(float *)v1;
  v3 = dword_5D6374;
  if ( !MobileSettings::settings[0].value )
    v3 = &dword_5D6374[1];
  v4 = *(float *)v3;
  CVisibilityPlugins::ms_pCamera = pCamera;
  CVisibilityPlugins::ms_pCameraPosn = (RwV3d_0 *)((char *)pCamera->object.object.parent + 64);
  CVisibilityPlugins::ms_cullCompsDist = (float)(TheCamera.LODDistMultiplier * 20.0)
                                       * (float)(TheCamera.LODDistMultiplier * 20.0);
  CVisibilityPlugins::ms_cullBigCompsDist = (float)(TheCamera.LODDistMultiplier * 50.0)
                                          * (float)(TheCamera.LODDistMultiplier * 50.0);
  CVisibilityPlugins::ms_pedLodDist = (float)((float)(TheCamera.LODDistMultiplier * v4)
                                            * (float)(TheCamera.LODDistMultiplier * v4))
                                    + (float)((float)(TheCamera.LODDistMultiplier * v4)
                                            * (float)(TheCamera.LODDistMultiplier * v4));
  CVisibilityPlugins::ms_vehicleLod0RenderMultiPassDist = (float)((float)(TheCamera.GenerationDistMultiplier * 45.0)
                                                                * (float)(TheCamera.GenerationDistMultiplier * 45.0))
                                                        + (float)((float)(TheCamera.GenerationDistMultiplier * 45.0)
                                                                * (float)(TheCamera.GenerationDistMultiplier * 45.0));
  CVisibilityPlugins::ms_vehicleLod0Dist = (float)((float)(TheCamera.GenerationDistMultiplier * 70.0)
                                                 * (float)(TheCamera.GenerationDistMultiplier * 70.0))
                                         + (float)((float)(TheCamera.GenerationDistMultiplier * 70.0)
                                                 * (float)(TheCamera.GenerationDistMultiplier * 70.0));
  CVisibilityPlugins::ms_vehicleLod1Dist = (float)((float)(TheCamera.GenerationDistMultiplier * 150.0)
                                                 * (float)(TheCamera.GenerationDistMultiplier * 150.0))
                                         + (float)((float)(TheCamera.GenerationDistMultiplier * 150.0)
                                                 * (float)(TheCamera.GenerationDistMultiplier * 150.0));
  CVisibilityPlugins::ms_bigVehicleLod0Dist = CVisibilityPlugins::ms_vehicleLod1Dist;
  CVisibilityPlugins::ms_pedFadeDist = (float)((float)(TheCamera.LODDistMultiplier * v2)
                                             * (float)(TheCamera.LODDistMultiplier * v2))
                                     + (float)((float)(TheCamera.LODDistMultiplier * v2)
                                             * (float)(TheCamera.LODDistMultiplier * v2));
}
// 5D6368: using guessed type int dword_5D6368[2];
// 5D6374: using guessed type int dword_5D6374[2];

//----- (005D63A0) --------------------------------------------------------
RwBool __fastcall CVisibilityPlugins::IsAtomicVisible(RpAtomic_0 *pAtomic)
{
  __int64 v2; // d17
  RwSphere_0 v4; // [sp+0h] [bp-18h] BYREF

  if ( (pAtomic->interpolator.flags & 2) != 0 )
    _rpAtomicResyncInterpolatedSphere(pAtomic);
  v2 = *(_QWORD *)&pAtomic->boundingSphere.center.z;
  *(_QWORD *)&v4.center.x = *(_QWORD *)&pAtomic->boundingSphere.center.x;
  *(_QWORD *)&v4.center.z = v2;
  RwV3dTransformPoints(&v4.center, &v4.center, 1, (const RwMatrix *)((char *)pAtomic->object.object.parent + 16));
  return RwCameraFrustumTestSphere(CVisibilityPlugins::ms_pCamera, &v4) != rwSPHEREOUTSIDE;
}
// 5D63A0: using guessed type RwSphere_0 var_18;

//----- (005D63F0) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetFrameHierarchyId(RwFrame_0 *pFrame, u_native value)
{
  *(_DWORD *)(&pFrame->object.type + CVisibilityPlugins::ms_framePluginOffset) = value;
}

//----- (005D6400) --------------------------------------------------------
u_native __fastcall CVisibilityPlugins::GetFrameHierarchyId(RwFrame_0 *pFrame)
{
  return *(_DWORD *)(&pFrame->object.type + CVisibilityPlugins::ms_framePluginOffset);
}

//----- (005D6410) --------------------------------------------------------
RwBool __fastcall CVisibilityPlugins::FrustumSphereCB(RpClump_0 *pClump)
{
  RwFrame_0 *parent; // r0
  __int64 v2; // d17
  RwMatrix *LTM; // r0
  RwSphere_0 v5; // [sp+0h] [bp-18h] BYREF

  parent = (RwFrame_0 *)pClump->object.parent;
  v2 = *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(&parent->object.type + CVisibilityPlugins::ms_framePluginOffset) + 44) + 32);
  *(_QWORD *)&v5.center.x = *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(&parent->object.type
                                                              + CVisibilityPlugins::ms_framePluginOffset)
                                                  + 44)
                                      + 24);
  *(_QWORD *)&v5.center.z = v2;
  LTM = RwFrameGetLTM(parent);
  RwV3dTransformPoints(&v5.center, &v5.center, 1, LTM);
  return RwCameraFrustumTestSphere(CVisibilityPlugins::ms_pCamera, &v5) != rwSPHEREOUTSIDE;
}

//----- (005D646C) --------------------------------------------------------
RwBool __fastcall CVisibilityPlugins::VehicleVisibilityCB(RpClump_0 *pClump)
{
  RwMatrix *LTM; // r0
  float32x2_t v3; // d16
  unsigned __int64 v4; // d1
  RwFrame_0 *parent; // r0
  __int64 v7; // d17
  RwMatrix *v8; // r0
  RwSphere_0 v9; // [sp+0h] [bp-18h] BYREF

  LTM = RwFrameGetLTM((RwFrame_0 *)pClump->object.parent);
  v3.n64_u64[0] = vsub_f32(*(float32x2_t *)&LTM->pos.y, *(float32x2_t *)&CVisibilityPlugins::ms_pCameraPosn->y).n64_u64[0];
  v4 = vmul_f32(v3, v3).n64_u64[0];
  if ( (float)((float)((float)((float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x)
                             * (float)(LTM->pos.x - CVisibilityPlugins::ms_pCameraPosn->x))
                     + *(float *)&v4)
             + *((float *)&v4 + 1)) > CVisibilityPlugins::ms_vehicleLod1Dist )
    return 0;
  parent = (RwFrame_0 *)pClump->object.parent;
  v7 = *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(&parent->object.type + CVisibilityPlugins::ms_framePluginOffset) + 44) + 32);
  *(_QWORD *)&v9.center.x = *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(&parent->object.type
                                                              + CVisibilityPlugins::ms_framePluginOffset)
                                                  + 44)
                                      + 24);
  *(_QWORD *)&v9.center.z = v7;
  v8 = RwFrameGetLTM(parent);
  RwV3dTransformPoints(&v9.center, &v9.center, 1, v8);
  return RwCameraFrustumTestSphere(CVisibilityPlugins::ms_pCamera, &v9) != rwSPHEREOUTSIDE;
}

//----- (005D6520) --------------------------------------------------------
RwBool __fastcall CVisibilityPlugins::VehicleVisibilityCB_BigVehicle(RpClump_0 *pClump)
{
  RwFrame_0 *parent; // r0
  __int64 v2; // d17
  RwMatrix *LTM; // r0
  RwSphere_0 v5; // [sp+0h] [bp-18h] BYREF

  parent = (RwFrame_0 *)pClump->object.parent;
  v2 = *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(&parent->object.type + CVisibilityPlugins::ms_framePluginOffset) + 44) + 32);
  *(_QWORD *)&v5.center.x = *(_QWORD *)(*(_DWORD *)(*(_DWORD *)(&parent->object.type
                                                              + CVisibilityPlugins::ms_framePluginOffset)
                                                  + 44)
                                      + 24);
  *(_QWORD *)&v5.center.z = v2;
  LTM = RwFrameGetLTM(parent);
  RwV3dTransformPoints(&v5.center, &v5.center, 1, LTM);
  return RwCameraFrustumTestSphere(CVisibilityPlugins::ms_pCamera, &v5) != rwSPHEREOUTSIDE;
}

//----- (005D657C) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetClumpModelInfo(RpClump_0 *pClump, CClumpModelInfo *pModelInfo)
{
  int v4; // r3
  RwBool (__fastcall *v5)(RpClump_0 *); // r2

  *(_DWORD *)((char *)pClump->object.parent + CVisibilityPlugins::ms_framePluginOffset) = pModelInfo;
  if ( (*((int (__fastcall **)(CClumpModelInfo *))pModelInfo->_vptr$CBaseModelInfo + 5))(pModelInfo) == 6 )
  {
    v4 = *(_DWORD *)&pModelInfo[1].m_modelName[16];
    v5 = CVisibilityPlugins::VehicleVisibilityCB_BigVehicle;
    if ( v4 != 8 )
      v5 = CVisibilityPlugins::VehicleVisibilityCB;
    if ( v4 == 6 )
      v5 = CVisibilityPlugins::VehicleVisibilityCB_BigVehicle;
    *(_DWORD *)(&pClump->object.type + CVisibilityPlugins::ms_clumpPluginOffset) = v5;
  }
}

//----- (005D65D4) --------------------------------------------------------
RwBool __fastcall CVisibilityPlugins::IsClumpVisible(RpClump_0 *pClump)
{
  return (*(int (**)(void))(&pClump->object.type + CVisibilityPlugins::ms_clumpPluginOffset))();
}

//----- (005D65E4) --------------------------------------------------------
void __fastcall CVisibilityPlugins::SetClumpAlpha(RpClump_0 *pClump, int32 alpha)
{
  *(void **)((char *)&pClump->object.parent + CVisibilityPlugins::ms_clumpPluginOffset) = (void *)alpha;
}

//----- (005D65F8) --------------------------------------------------------
void CVisibilityPlugins::InitAlphaAtomicList()
{
  CLink<CVisibilityPlugins::AlphaObjectInfo> *i; // r0

  for ( i = CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext;
        CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaList.m_lastLink;
        i = CVisibilityPlugins::m_alphaList.m_firstLink.m_pNext )
  {
    i->m_pNext->m_pPrev = i->m_pPrev;
    i->m_pPrev->m_pNext = i->m_pNext;
    i->m_pNext = CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext;
    CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext->m_pPrev = i;
    i->m_pPrev = &CVisibilityPlugins::m_alphaList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaList.m_firstFreeLink.m_pNext = i;
  }
}

//----- (005D6640) --------------------------------------------------------
void CVisibilityPlugins::InitAlphaEntityList()
{
  CLink<CVisibilityPlugins::AlphaObjectInfo> *i; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *j; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *k; // r0
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m; // r0

  for ( i = CVisibilityPlugins::m_alphaEntityList.m_firstLink.m_pNext;
        CVisibilityPlugins::m_alphaEntityList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaEntityList.m_lastLink;
        i = CVisibilityPlugins::m_alphaEntityList.m_firstLink.m_pNext )
  {
    i->m_pNext->m_pPrev = i->m_pPrev;
    i->m_pPrev->m_pNext = i->m_pNext;
    i->m_pNext = CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext;
    CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext->m_pPrev = i;
    i->m_pPrev = &CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext = i;
  }
  for ( j = CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext;
        CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink;
        j = CVisibilityPlugins::m_alphaBoatAtomicList.m_firstLink.m_pNext )
  {
    j->m_pNext->m_pPrev = j->m_pPrev;
    j->m_pPrev->m_pNext = j->m_pNext;
    j->m_pNext = CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext;
    CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext->m_pPrev = j;
    j->m_pPrev = &CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaBoatAtomicList.m_firstFreeLink.m_pNext = j;
  }
  for ( k = CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.m_pNext;
        CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink;
        k = CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.m_pNext )
  {
    k->m_pNext->m_pPrev = k->m_pPrev;
    k->m_pPrev->m_pNext = k->m_pNext;
    k->m_pNext = CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext;
    CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext->m_pPrev = k;
    k->m_pPrev = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext = k;
  }
  for ( m = CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext;
        CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
        m = CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext )
  {
    m->m_pNext->m_pPrev = m->m_pPrev;
    m->m_pPrev->m_pNext = m->m_pNext;
    m->m_pNext = CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext;
    CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->m_pPrev = m;
    m->m_pPrev = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink;
    CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext = m;
  }
}

//----- (005D6758) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertEntityIntoSortedList(CEntity *pEntity, float dist)
{
  int m_nModelIndex; // r2
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v6; // r2
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r1
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *v10; // r3
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *v11; // r2
  int v12; // r1
  __int64 v13; // kr08_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v14; // r0

  m_nModelIndex = pEntity->m_nModelIndex;
  if ( m_nModelIndex == MI_GRASSHOUSE || m_nModelIndex == MI_GASSTATION )
  {
    m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext;
    p_m_lastLink = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
    if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink )
    {
      while ( m_pNext->m_firstLink.item.dist < dist )
      {
        m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
        p_m_lastLink = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
        if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink )
          goto LABEL_8;
      }
      p_m_lastLink = &m_pNext->m_firstLink;
    }
LABEL_8:
    v6 = CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext;
    if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext != &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastFreeLink )
    {
      v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->m_pPrev;
      CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->item.dist = dist;
      v6->item.pObj = pEntity;
      v6->item.RenderFn = CVisibilityPlugins::RenderEntity;
      *(_DWORD *)(HIDWORD(v7) + 12) = v7;
      v6->m_pPrev->m_pNext = v6->m_pNext;
      m_pPrev = p_m_lastLink->m_pPrev;
      v6->m_pNext = m_pPrev->m_pNext;
      m_pPrev->m_pNext->m_pPrev = v6;
      v6->m_pPrev = m_pPrev;
      m_pPrev->m_pNext = v6;
      if ( v6 )
        return 1;
    }
  }
  v10 = &CVisibilityPlugins::m_alphaUnderwaterEntityList;
  if ( (*((_BYTE *)&pEntity->m_nFlags + 2) & 0x10) == 0 )
    v10 = &CVisibilityPlugins::m_alphaEntityList;
  v11 = *(CLinkList<CVisibilityPlugins::AlphaObjectInfo> **)((char *)&word_10 + (_DWORD)v10);
  if ( v11 != (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&v10->m_lastLink )
  {
    while ( v11->m_firstLink.item.dist < dist )
    {
      v11 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)v11->m_firstLink.m_pNext;
      if ( v11 == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&v10->m_lastLink )
      {
        v11 = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&v10->m_lastLink;
        break;
      }
    }
  }
  v12 = *(int *)((char *)&dword_38 + (_DWORD)v10);
  if ( (CLink<CVisibilityPlugins::AlphaObjectInfo> *)v12 == &v10->m_lastFreeLink )
    return 0;
  v13 = *(_QWORD *)(v12 + 12);
  *(float *)(v12 + 8) = dist;
  *(_DWORD *)v12 = pEntity;
  *(_DWORD *)(v12 + 4) = CVisibilityPlugins::RenderEntity;
  *(_DWORD *)(HIDWORD(v13) + 12) = v13;
  *(_DWORD *)(*(_DWORD *)(v12 + 12) + 16) = *(_DWORD *)(v12 + 16);
  v14 = v11->m_firstLink.m_pPrev;
  *(_DWORD *)(v12 + 16) = v14->m_pNext;
  v14->m_pNext->m_pPrev = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)v12;
  *(_DWORD *)(v12 + 12) = v14;
  v14->m_pNext = (CLink<CVisibilityPlugins::AlphaObjectInfo> *)v12;
  return v12 != 0;
}
// 10: using guessed type __int16 word_10;
// 38: using guessed type int dword_38;

//----- (005D6890) --------------------------------------------------------
void __fastcall CVisibilityPlugins::RenderEntity(void *pObj, float dist)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  CBaseModelInfo *v8; // r8
  void *v9; // r1
  __int64 *v10; // r10
  float32x2_t v11; // d1
  __int64 v12; // r0
  float v13; // s4
  float m_alpha; // s2
  float v15; // s0
  int v16; // r0
  RpAtomic_0 *v17; // r6
  int v18; // r9
  bool v19; // zf
  int pData[9]; // [sp+4h] [bp-24h] BYREF

  if ( *((_DWORD *)pObj + 6) )
  {
    v8 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)pObj + 19)];
    if ( (v8->m_flags & 8) != 0 )
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    if ( (*((_BYTE *)pObj + 29) & 0x80) != 0 )
    {
      v10 = (__int64 *)((char *)pObj + 28);
      RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
      v4.n64_u32[0] = LODWORD(v8->m_lodDistance);
      v3.n64_f32[0] = CRenderer::ms_fFarClipPlane + v8->m_pColModel->m_sphereBound.m_fRadius;
      v5.n64_f32[0] = v4.n64_f32[0] * TheCamera.LODDistMultiplier;
      v11.n64_u64[0] = vmin_f32(v5, v3).n64_u64[0];
      if ( *((_DWORD *)pObj + 13) )
      {
        v12 = *v10;
        v13 = FadeDistMult * 22.0;
      }
      else
      {
        v5.n64_u64[0] = vmin_f32(v4, v11).n64_u64[0];
        v13 = FadeDistMult * 22.0;
        if ( v5.n64_f32[0] > 150.0 )
          v13 = (float)(v5.n64_f32[0] / 15.0) + 10.0;
        v12 = *v10;
        if ( (*(_DWORD *)v10 & 0x100) != 0 )
          v11.n64_f32[0] = v11.n64_f32[0] * CRenderer::ms_lowLodDistScale;
      }
      v2.n64_f32[0] = (float)(FadeDistMult * 22.0) + v11.n64_f32[0];
      v5.n64_u32[0] = 1.0;
      m_alpha = (float)v8->m_alpha;
      *((_DWORD *)pObj + 8) = HIDWORD(v12);
      v2.n64_f32[0] = (float)((float)(v2.n64_f32[0] - dist) / v13) * 0.8;
      v15 = vmin_f32(v2, v5).n64_f32[0];
      *(_DWORD *)v10 = v12 | 0x2000;
      if ( (v12 & 0x8000000) == 0 )
        RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
      v16 = (*(int (__fastcall **)(void *))(*(_DWORD *)pObj + 80))(pObj);
      v17 = (RpAtomic_0 *)*((_DWORD *)pObj + 6);
      v18 = v16;
      if ( v17->object.object.type == 1 )
      {
        if ( (v8->m_flags & 4) != 0 )
          RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        emu_EnableAlphaModulate((float)(int)(float)(v15 * m_alpha) / 255.0);
        AtomicDefaultRenderCallBack(v17);
        emu_DisableAlphaModulate();
      }
      else
      {
        pData[0] = (int)(float)(v15 * m_alpha);
        if ( (v8->m_flags & 4) != 0 )
          RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        RpClumpForAllAtomics((RpClump_0 *)v17, CVisibilityPlugins::RenderAtomicWithAlphaCB, pData);
      }
      if ( (v8->m_flags & 4) != 0 )
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      (*(void (__fastcall **)(void *, int))(*(_DWORD *)pObj + 84))(pObj, v18);
      v19 = (*(_DWORD *)v10 & 0x8000000) == 0;
      *(_DWORD *)v10 &= ~0x2000u;
      if ( v19 )
        RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
    }
    else
    {
      if ( CGame::currArea || (v8->m_flags & 8) != 0 )
        v9 = 0;
      else
        v9 = &dword_64;
      RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, v9);
      CRenderer::RenderOneNonRoad((CEntity *)pObj);
    }
    if ( (v8->m_flags & 8) != 0 )
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  }
}
// 5D6934: variable 'v5' is possibly undefined
// 5D6934: variable 'v3' is possibly undefined
// 5D6954: variable 'v4' is possibly undefined
// 5D69C2: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// 64: using guessed type int dword_64;
// 5D6890: using guessed type int pData[9];

//----- (005D6ABC) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertEntityIntoReallyDrawLastList(CEntity *pEntity, float dist)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v5; // r1
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext;
  p_m_lastLink = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
  if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink )
  {
    while ( m_pNext->m_firstLink.item.dist < dist )
    {
      m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
      p_m_lastLink = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
      if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink )
        goto LABEL_6;
    }
    p_m_lastLink = &m_pNext->m_firstLink;
  }
LABEL_6:
  v5 = CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext;
  if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastFreeLink )
    return 0;
  v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->m_pPrev;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->item.dist = dist;
  v5->item.pObj = pEntity;
  v5->item.RenderFn = CVisibilityPlugins::RenderEntity;
  *(_DWORD *)(HIDWORD(v7) + 12) = v7;
  v5->m_pPrev->m_pNext = v5->m_pNext;
  m_pPrev = p_m_lastLink->m_pPrev;
  v5->m_pNext = m_pPrev->m_pNext;
  m_pPrev->m_pNext->m_pPrev = v5;
  v5->m_pPrev = m_pPrev;
  m_pPrev->m_pNext = v5;
  return v5 != 0;
}

//----- (005D6B58) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertEntityIntoUnderwaterList(CEntity *pEntity, float dist)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v5; // r1
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.m_pNext;
  p_m_lastLink = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink;
  if ( CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink )
  {
    while ( m_pNext->m_firstLink.item.dist < dist )
    {
      m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
      p_m_lastLink = &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink;
      if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink )
        goto LABEL_6;
    }
    p_m_lastLink = &m_pNext->m_firstLink;
  }
LABEL_6:
  v5 = CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext;
  if ( CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastFreeLink )
    return 0;
  v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext->m_pPrev;
  CVisibilityPlugins::m_alphaUnderwaterEntityList.m_firstFreeLink.m_pNext->item.dist = dist;
  v5->item.pObj = pEntity;
  v5->item.RenderFn = CVisibilityPlugins::RenderEntity;
  *(_DWORD *)(HIDWORD(v7) + 12) = v7;
  v5->m_pPrev->m_pNext = v5->m_pNext;
  m_pPrev = p_m_lastLink->m_pPrev;
  v5->m_pNext = m_pPrev->m_pNext;
  m_pPrev->m_pNext->m_pPrev = v5;
  v5->m_pPrev = m_pPrev;
  m_pPrev->m_pNext = v5;
  return v5 != 0;
}

//----- (005D6BF4) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertObjectIntoSortedList(
        void *pObj,
        float dist,
        CVisibilityPlugins::RenderFunction fn)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r3
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v6; // r1
  __int64 v8; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaEntityList.m_firstLink.m_pNext;
  p_m_lastLink = &CVisibilityPlugins::m_alphaEntityList.m_lastLink;
  if ( CVisibilityPlugins::m_alphaEntityList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaEntityList.m_lastLink )
  {
    while ( m_pNext->m_firstLink.item.dist < dist )
    {
      m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
      p_m_lastLink = &CVisibilityPlugins::m_alphaEntityList.m_lastLink;
      if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaEntityList.m_lastLink )
        goto LABEL_6;
    }
    p_m_lastLink = &m_pNext->m_firstLink;
  }
LABEL_6:
  v6 = CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext;
  if ( CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaEntityList.m_lastFreeLink )
    return 0;
  v8 = *(_QWORD *)&CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext->m_pPrev;
  CVisibilityPlugins::m_alphaEntityList.m_firstFreeLink.m_pNext->item.pObj = pObj;
  v6->item.RenderFn = fn;
  v6->item.dist = dist;
  *(_DWORD *)(HIDWORD(v8) + 12) = v8;
  v6->m_pPrev->m_pNext = v6->m_pNext;
  m_pPrev = p_m_lastLink->m_pPrev;
  v6->m_pNext = m_pPrev->m_pNext;
  m_pPrev->m_pNext->m_pPrev = v6;
  v6->m_pPrev = m_pPrev;
  m_pPrev->m_pNext = v6;
  return v6 != 0;
}

//----- (005D6C84) --------------------------------------------------------
bool __fastcall CVisibilityPlugins::InsertAtomicIntoReallyDrawLastList(RpAtomic_0 *pAtomic, float dist)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m_pNext; // r1
  CLink<CVisibilityPlugins::AlphaObjectInfo> *p_m_lastLink; // r2
  CLink<CVisibilityPlugins::AlphaObjectInfo> *v5; // r1
  __int64 v7; // kr00_8
  CLink<CVisibilityPlugins::AlphaObjectInfo> *m_pPrev; // r0

  m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext;
  p_m_lastLink = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
  if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstLink.m_pNext != &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink )
  {
    while ( m_pNext->m_firstLink.item.dist < dist )
    {
      m_pNext = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m_pNext->m_firstLink.m_pNext;
      p_m_lastLink = &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink;
      if ( m_pNext == (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)&CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink )
        goto LABEL_6;
    }
    p_m_lastLink = &m_pNext->m_firstLink;
  }
LABEL_6:
  v5 = CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext;
  if ( CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext == &CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastFreeLink )
    return 0;
  v7 = *(_QWORD *)&CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->m_pPrev;
  CVisibilityPlugins::m_alphaReallyDrawLastList.m_firstFreeLink.m_pNext->item.dist = dist;
  v5->item.pObj = pAtomic;
  v5->item.RenderFn = CVisibilityPlugins::RenderAtomic;
  *(_DWORD *)(HIDWORD(v7) + 12) = v7;
  v5->m_pPrev->m_pNext = v5->m_pNext;
  m_pPrev = p_m_lastLink->m_pPrev;
  v5->m_pNext = m_pPrev->m_pNext;
  m_pPrev->m_pNext->m_pPrev = v5;
  v5->m_pPrev = m_pPrev;
  m_pPrev->m_pNext = v5;
  return v5 != 0;
}

//----- (005D6D20) --------------------------------------------------------
void CVisibilityPlugins::RenderAlphaAtomics()
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *i; // r4

  for ( i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaList.m_lastLink.m_pPrev;
        i != &CVisibilityPlugins::m_alphaList;
        i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)i->m_firstLink.m_pPrev )
  {
    ((void (__fastcall *)(void *, _DWORD))i->m_firstLink.item.RenderFn)(
      i->m_firstLink.item.pObj,
      LODWORD(i->m_firstLink.item.dist));
  }
}

//----- (005D6D50) --------------------------------------------------------
void __fastcall CVisibilityPlugins::RenderOrderedList(CLinkList<CVisibilityPlugins::AlphaObjectInfo> *list)
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *i; // r5

  for ( i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)list->m_lastLink.m_pPrev;
        i != list;
        i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)i->m_firstLink.m_pPrev )
  {
    ((void (__fastcall *)(void *, _DWORD))i->m_firstLink.item.RenderFn)(
      i->m_firstLink.item.pObj,
      LODWORD(i->m_firstLink.item.dist));
  }
}

//----- (005D6D6C) --------------------------------------------------------
void CVisibilityPlugins::RenderBoatAlphaAtomics()
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *i; // r4

  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  for ( i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink.m_pPrev;
        i != &CVisibilityPlugins::m_alphaBoatAtomicList;
        i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)i->m_firstLink.m_pPrev )
  {
    ((void (__fastcall *)(void *, _DWORD))i->m_firstLink.item.RenderFn)(
      i->m_firstLink.item.pObj,
      LODWORD(i->m_firstLink.item.dist));
  }
  sub_192840(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;

//----- (005D6DAC) --------------------------------------------------------
void CVisibilityPlugins::RenderFadingEntities()
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *i; // r4
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *j; // r4
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *k; // r4
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *m; // r4

  if ( MobileSettings::settings[0].value == 3 )
  {
    _rpSkipBlendRender(1);
    _rpSkipNonblendRender(0);
    for ( i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaEntityList.m_lastLink.m_pPrev;
          i != &CVisibilityPlugins::m_alphaEntityList;
          i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)i->m_firstLink.m_pPrev )
    {
      ((void (__fastcall *)(void *, _DWORD))i->m_firstLink.item.RenderFn)(
        i->m_firstLink.item.pObj,
        LODWORD(i->m_firstLink.item.dist));
    }
    _rpSkipBlendRender(0);
    _rpSkipNonblendRender(1);
    for ( j = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaEntityList.m_lastLink.m_pPrev;
          j != &CVisibilityPlugins::m_alphaEntityList;
          j = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)j->m_firstLink.m_pPrev )
    {
      ((void (__fastcall *)(void *, _DWORD))j->m_firstLink.item.RenderFn)(
        j->m_firstLink.item.pObj,
        LODWORD(j->m_firstLink.item.dist));
    }
    _rpSkipNonblendRender(0);
  }
  else
  {
    for ( k = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaEntityList.m_lastLink.m_pPrev;
          k != &CVisibilityPlugins::m_alphaEntityList;
          k = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)k->m_firstLink.m_pPrev )
    {
      ((void (__fastcall *)(void *, _DWORD))k->m_firstLink.item.RenderFn)(
        k->m_firstLink.item.pObj,
        LODWORD(k->m_firstLink.item.dist));
    }
  }
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  for ( m = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaBoatAtomicList.m_lastLink.m_pPrev;
        m != &CVisibilityPlugins::m_alphaBoatAtomicList;
        m = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)m->m_firstLink.m_pPrev )
  {
    ((void (__fastcall *)(void *, _DWORD))m->m_firstLink.item.RenderFn)(
      m->m_firstLink.item.pObj,
      LODWORD(m->m_firstLink.item.dist));
  }
  sub_192840(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;

//----- (005D6E94) --------------------------------------------------------
void CVisibilityPlugins::RenderFadingUnderwaterEntities()
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *i; // r4

  for ( i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaUnderwaterEntityList.m_lastLink.m_pPrev;
        i != &CVisibilityPlugins::m_alphaUnderwaterEntityList;
        i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)i->m_firstLink.m_pPrev )
  {
    ((void (__fastcall *)(void *, _DWORD))i->m_firstLink.item.RenderFn)(
      i->m_firstLink.item.pObj,
      LODWORD(i->m_firstLink.item.dist));
  }
}

//----- (005D6EC4) --------------------------------------------------------
void CVisibilityPlugins::RenderReallyDrawLastObjects()
{
  CLinkList<CVisibilityPlugins::AlphaObjectInfo> *i; // r4

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  SetAmbientColours();
  DeActivateDirectional();
  for ( i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)CVisibilityPlugins::m_alphaReallyDrawLastList.m_lastLink.m_pPrev;
        i != &CVisibilityPlugins::m_alphaReallyDrawLastList;
        i = (CLinkList<CVisibilityPlugins::AlphaObjectInfo> *)i->m_firstLink.m_pPrev )
  {
    ((void (__fastcall *)(void *, _DWORD))i->m_firstLink.item.RenderFn)(
      i->m_firstLink.item.pObj,
      LODWORD(i->m_firstLink.item.dist));
  }
  sub_192840(rwRENDERSTATEFOGENABLE, 0);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005D6F44) --------------------------------------------------------
float __fastcall CVisibilityPlugins::GetDistanceSquaredFromCamera(RwV3d_0 *pVec)
{
  float32x2_t v1; // d16
  unsigned __int64 v2; // d1

  v1.n64_u64[0] = vsub_f32(*(float32x2_t *)&pVec->y, *(float32x2_t *)&CVisibilityPlugins::ms_pCameraPosn->y).n64_u64[0];
  v2 = vmul_f32(v1, v1).n64_u64[0];
  return (float)((float)((float)(pVec->x - CVisibilityPlugins::ms_pCameraPosn->x)
                       * (float)(pVec->x - CVisibilityPlugins::ms_pCameraPosn->x))
               + *(float *)&v2)
       + *((float *)&v2 + 1);
}

//----- (005D6F80) --------------------------------------------------------
void CBulletInfo::Initialise()
{
  gaBulletInfo[0].m_bBulletActive = 0;
  gaBulletInfo[0].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[0].m_pEntBulletOwner = 0;
  gaBulletInfo[0].m_fTimeExpires = 0.0;
  gaBulletInfo[1].m_bBulletActive = 0;
  gaBulletInfo[1].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[1].m_pEntBulletOwner = 0;
  gaBulletInfo[1].m_fTimeExpires = 0.0;
  gaBulletInfo[2].m_bBulletActive = 0;
  gaBulletInfo[2].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[2].m_pEntBulletOwner = 0;
  gaBulletInfo[2].m_fTimeExpires = 0.0;
  gaBulletInfo[3].m_bBulletActive = 0;
  gaBulletInfo[3].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[3].m_pEntBulletOwner = 0;
  gaBulletInfo[3].m_fTimeExpires = 0.0;
  gaBulletInfo[4].m_bBulletActive = 0;
  gaBulletInfo[4].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[4].m_pEntBulletOwner = 0;
  gaBulletInfo[4].m_fTimeExpires = 0.0;
  gaBulletInfo[5].m_bBulletActive = 0;
  gaBulletInfo[5].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[5].m_pEntBulletOwner = 0;
  gaBulletInfo[5].m_fTimeExpires = 0.0;
  gaBulletInfo[6].m_bBulletActive = 0;
  gaBulletInfo[6].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[6].m_pEntBulletOwner = 0;
  gaBulletInfo[6].m_fTimeExpires = 0.0;
  gaBulletInfo[7].m_bBulletActive = 0;
  gaBulletInfo[7].m_eBulletType = WEAPONTYPE_PISTOL;
  gaBulletInfo[7].m_pEntBulletOwner = 0;
  gaBulletInfo[7].m_fTimeExpires = 0.0;
}

//----- (005D6FEC) --------------------------------------------------------
int __fastcall CBulletInfo::AddBullet(int a1, eWeaponType a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v10; // r2
  int v11; // r4
  int v12; // r6
  int v14; // r6
  char *v15; // r4
  char *v16; // r9
  char *v17; // r0

  v10 = 0;
  v11 = 0;
  do
  {
    v12 = v10 * 44 + 44;
    if ( v11 > 7 )
      break;
    ++v11;
  }
  while ( gaBulletInfo[v10++].m_bBulletActive );
  if ( v12 == 396 )
    return 0;
  v15 = (char *)gaBulletInfo + v12;
  v16 = (char *)gaBulletInfo + v12;
  v14 = 1;
  *((_DWORD *)v16 - 11) = a2;
  *((_DWORD *)v16 - 10) = a1;
  *((_WORD *)v16 - 2) = CWeaponInfo::GetWeaponInfo(a2, 1)->m_nDamage;
  v17 = v16 - 28;
  *(_DWORD *)v17 = a3;
  *((_DWORD *)v17 + 1) = a4;
  *((_DWORD *)v17 + 2) = a5;
  *((_DWORD *)v16 - 4) = a6;
  *((_DWORD *)v16 - 3) = a7;
  *((_DWORD *)v16 - 2) = a8;
  *((float *)v16 - 9) = (float)(int)(CTimer::m_snTimeInMilliseconds + 1000);
  *(v15 - 32) = 1;
  return v14;
}

//----- (005D7094) --------------------------------------------------------
void CBulletInfo::Update()
{
  int v0; // r4
  CBulletInfo *v1; // r5
  CEntity *m_pEntBulletOwner; // r0
  CBulletInfo *v3; // r11
  float v4; // s8
  float x; // s2
  float v6; // s10
  float y; // s4
  float v8; // s12
  __int64 v9; // d16
  float v10; // s2
  float v11; // s0
  CEntity *v12; // r8
  int v13; // r0
  unsigned int v14; // r0
  bool v15; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v18; // s6
  unsigned __int8 LocalDirection; // r0
  eCrimeType v20; // r0
  CAnimBlendAssociation *FirstAssociation; // r0
  AnimationId v22; // r2
  CAnimBlendAssociation *v23; // r0
  CAnimBlendAssociation *v24; // r5
  CEntity *v25; // r1
  int v26; // r0
  bool v27; // zf
  int v28; // r0
  CEntity *v29; // r8
  int v30; // r1
  int v31; // r1
  int v32; // r2
  int v33; // r0
  int v34; // r1
  int m_nFlags; // r0
  eWeaponType m_eBulletType; // r1
  float v37; // r0
  __int64 v38; // d16
  CVector *p_m_vecPosition; // [sp+78h] [bp-C8h]
  CVector dir; // [sp+84h] [bp-BCh] BYREF
  CVector vecEnd; // [sp+90h] [bp-B0h] BYREF
  CVector vecStart; // [sp+A0h] [bp-A0h] BYREF
  CEntity *refEntityPtr; // [sp+ACh] [bp-94h] BYREF
  CColPoint colPoint; // [sp+B0h] [bp-90h] BYREF
  CVector v45; // 0:r1.12

  v0 = 0;
  refEntityPtr = 0;
  do
  {
    v1 = &gaBulletInfo[v0];
    m_pEntBulletOwner = gaBulletInfo[v0].m_pEntBulletOwner;
    if ( m_pEntBulletOwner
      && (*(_BYTE *)&m_pEntBulletOwner->m_info & 7) == 3
      && !CPed::IsPointerValid((CPed *)m_pEntBulletOwner) )
    {
      v1->m_pEntBulletOwner = 0;
    }
    v3 = &gaBulletInfo[v0];
    if ( gaBulletInfo[v0].m_bBulletActive )
    {
      if ( gaBulletInfo[v0].m_fTimeExpires < (float)CTimer::m_snTimeInMilliseconds )
        v3->m_bBulletActive = 0;
      v4 = gaBulletInfo[v0].m_vecVelocity.x * (float)(CTimer::ms_fTimeStep * 0.5);
      x = gaBulletInfo[v0].m_vecPosition.x;
      v6 = (float)(CTimer::ms_fTimeStep * 0.5) * gaBulletInfo[v0].m_vecVelocity.y;
      y = gaBulletInfo[v0].m_vecPosition.y;
      v8 = (float)(CTimer::ms_fTimeStep * 0.5) * gaBulletInfo[v0].m_vecVelocity.z;
      v9 = *(_QWORD *)&gaBulletInfo[v0].m_vecPosition.x;
      vecStart.z = gaBulletInfo[v0].m_vecPosition.z;
      *(_QWORD *)&vecStart.x = v9;
      v10 = v4 + x;
      v11 = v6 + y;
      vecEnd.x = v10;
      vecEnd.y = v6 + y;
      vecEnd.z = v8 + vecStart.z;
      if ( v10 <= -3000.0 || v10 >= 3000.0 || v11 <= -3000.0 || v11 >= 3000.0 )
      {
        v3->m_bBulletActive = 0;
      }
      else
      {
        p_m_vecPosition = &gaBulletInfo[v0].m_vecPosition;
        CWorld::bIncludeCarTyres = 1;
        CWorld::bIncludeDeadPeds = 1;
        CWorld::bIncludeBikers = 1;
        CWorld::pIgnoreEntity = gaBulletInfo[v0].m_pEntBulletOwner;
        if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 1, 1, 1, 1, 0, 0, 1) == 1 )
        {
          CWeapon::CheckForShootingVehicleOccupant(
            &refEntityPtr,
            &colPoint,
            gaBulletInfo[v0].m_eBulletType,
            &vecStart,
            &vecEnd);
          v12 = refEntityPtr;
          v13 = *(_BYTE *)&refEntityPtr->m_info & 7;
          if ( v13 == 2 )
          {
            v25 = v1->m_pEntBulletOwner;
            if ( !v25 )
              goto LABEL_37;
            v26 = *(_BYTE *)&v25->m_info & 7;
            v27 = v26 == 3;
            if ( v26 == 3 )
              v27 = LODWORD(v25[4].m_transform.m_heading) == (_DWORD)refEntityPtr;
            if ( !v27 )
            {
LABEL_37:
              if ( (unsigned __int8)(colPoint.m_dataB.m_nPieceType - 13) > 3u )
              {
                CVehicle::InflictDamage(
                  (CVehicle *)refEntityPtr,
                  v25,
                  gaBulletInfo[v0].m_eBulletType,
                  (float)gaBulletInfo[v0].m_nBulletDamage,
                  colPoint.m_vecPosition);
                if ( gaBulletInfo[v0].m_eBulletType == WEAPONTYPE_FLAMETHROWER )
                {
                  CFireManager::StartFire(&gFireManager, refEntityPtr, v1->m_pEntBulletOwner, 0.8, 1u, 7000, 100);
                }
                else if ( CCamera::IsSphereVisible(&TheCamera, &colPoint.m_vecPosition, 1.0) )
                {
                  Fx_c::AddBulletImpact(
                    &g_fx,
                    &colPoint.m_vecPosition,
                    &colPoint.m_vecNormal,
                    colPoint.m_dataB.m_nSurfaceType,
                    8,
                    (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                          * (float)((float)((float)(colPoint.m_dataB.m_lighting >> 4) * 0.5) / 15.0))
                  + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                          * (float)((float)((float)(colPoint.m_dataB.m_lighting & 0xF) * 0.5) / 15.0)));
                }
              }
              else
              {
                (*((void (__fastcall **)(CEntity *, _DWORD, int))refEntityPtr->_vptr$CPlaceable + 45))(
                  refEntityPtr,
                  colPoint.m_dataB.m_nPieceType,
                  1);
                Fx_c::AddTyreBurst(&g_fx, &colPoint.m_vecPosition, &colPoint.m_vecNormal);
              }
            }
          }
          else if ( v13 == 3 )
          {
            v14 = (int)refEntityPtr[18].m_pMat & 0xFFFFFFFE;
            v15 = v14 == 54;
            if ( v14 != 54 )
              v15 = refEntityPtr == v1->m_pEntBulletOwner;
            if ( !v15 )
            {
              m_pMat = refEntityPtr->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &refEntityPtr->m_transform;
              v18 = p_tx->m_translate.y;
              dir.x = p_tx->m_translate.x - colPoint.m_vecPosition.x;
              dir.y = v18 - colPoint.m_vecPosition.y;
              LocalDirection = CPed::GetLocalDirection((CPed *)refEntityPtr, (const CVector2D *)&dir);
              CWeapon::GenerateDamageEvent(
                (CPed *)v12,
                v1->m_pEntBulletOwner,
                gaBulletInfo[v0].m_eBulletType,
                gaBulletInfo[v0].m_nBulletDamage,
                (ePedPieceTypes)colPoint.m_dataB.m_nPieceType,
                LocalDirection);
              if ( *(_DWORD *)&v12[23].numLodChildren == 6 )
                v20 = CRIME_SHOOT_COP;
              else
                v20 = CRIME_SHOOT_PED;
              CCrime::ReportCrime(v20, refEntityPtr, (CPed *)gaBulletInfo[v0].m_pEntBulletOwner);
              vecEnd = colPoint.m_vecPosition;
            }
            if ( CLocalisation::Blood() )
            {
              Fx_c::AddBlood(&g_fx, &colPoint.m_vecPosition, &colPoint.m_vecNormal, 8, v12[5].m_transform.m_translate.x);
              if ( v12[18].m_pMat == (CMatrix *)((char *)&dword_34 + 3) )
              {
                FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)v12->m_pRwObject, 0x800u);
                v22 = ANIM_STD_HIT_FLOOR_FRONT;
                if ( !FirstAssociation )
                  v22 = ANIM_STD_HIT_FLOOR;
                v23 = CAnimManager::BlendAnimation((RpClump_0 *)v12->m_pRwObject, ANIM_STD_PED, v22, 8.0);
                v24 = v23;
                if ( v23 )
                {
                  CAnimBlendAssociation::SetCurrentTime(v23, 0.0);
                  v24->m_bitsFlag = v24->m_bitsFlag & 0xFFF6 | 1;
                }
              }
              vecEnd = colPoint.m_vecPosition;
            }
          }
          else
          {
            if ( CCamera::IsSphereVisible(&TheCamera, &colPoint.m_vecPosition, 1.0) )
              Fx_c::AddBulletImpact(
                &g_fx,
                &colPoint.m_vecPosition,
                &colPoint.m_vecNormal,
                colPoint.m_dataB.m_nSurfaceType,
                8,
                (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                      * (float)((float)((float)(colPoint.m_dataB.m_lighting >> 4) * 0.5) / 15.0))
              + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                      * (float)((float)((float)(colPoint.m_dataB.m_lighting & 0xF) * 0.5) / 15.0)));
            v28 = (int)v1->m_pEntBulletOwner;
            if ( !v28 || (*(_BYTE *)(v28 + 58) & 7) != 3 || *(CEntity **)(v28 + 256) != refEntityPtr )
            {
              v29 = refEntityPtr;
              v30 = *(_BYTE *)&refEntityPtr->m_info & 7;
              if ( v30 == 1 )
              {
                if ( v28 )
                {
                  if ( (*(_BYTE *)(v28 + 58) & 7) == 3 )
                  {
                    v33 = *(_DWORD *)(v28 + 1092);
                    if ( v33 )
                      *(_DWORD *)(v33 + 156) = refEntityPtr->m_nModelIndex;
                  }
                }
              }
              else if ( v30 == 4 )
              {
                if ( *(_BYTE *)&refEntityPtr[5].m_nFlags < 0xC8u )
                {
                  if ( (LOBYTE(refEntityPtr[1].m_transform.m_translate.y) & 4) == 0 )
                  {
                    v34 = *(_DWORD *)&refEntityPtr[5].numLodChildren;
                    if ( *(float *)(v34 + 24) < 99.9 )
                    {
                      m_nFlags = (int)refEntityPtr->m_nFlags;
                      if ( (m_nFlags & 0x40004) != 0 && *(float *)(v34 + 20) <= 0.0 )
                      {
                        (*((void (__fastcall **)(CEntity *, _DWORD))refEntityPtr->_vptr$CPlaceable + 5))(
                          refEntityPtr,
                          0);
                        CPhysical::AddToMovingList((CPhysical *)v29);
                        m_nFlags = (int)v29->m_nFlags;
                      }
                      if ( (m_nFlags & 0x40004) == 0 )
                      {
                        v45.x = colPoint.m_vecNormal.x * -7.5;
                        v45.y = colPoint.m_vecNormal.y * -7.5;
                        v45.z = colPoint.m_vecNormal.z * -7.5;
                        CPhysical::ApplyMoveForce((CPhysical *)v29, v45);
                      }
                      v28 = (int)v1->m_pEntBulletOwner;
                    }
                  }
                  m_eBulletType = gaBulletInfo[v0].m_eBulletType;
                }
                else
                {
                  v31 = *(_DWORD *)&refEntityPtr[5].numLodChildren;
                  v32 = *(_DWORD *)(v31 + 72);
                  if ( v32 == 2 )
                  {
                    CObject::ObjectDamage(
                      (CObject *)refEntityPtr,
                      *(float *)(v31 + 52) * 151.0,
                      &colPoint.m_vecPosition,
                      &colPoint.m_vecNormal,
                      (int)v1->m_pEntBulletOwner,
                      gaBulletInfo[v0].m_eBulletType);
                  }
                  else if ( v32 == 1 )
                  {
                    CObject::ObjectDamage(
                      (CObject *)refEntityPtr,
                      151.0,
                      &colPoint.m_vecPosition,
                      &colPoint.m_vecNormal,
                      (int)v1->m_pEntBulletOwner,
                      gaBulletInfo[v0].m_eBulletType);
                  }
                  v28 = (int)v1->m_pEntBulletOwner;
                  m_eBulletType = gaBulletInfo[v0].m_eBulletType;
                }
                CObject::ObjectDamage(
                  (CObject *)v29,
                  50.0,
                  &colPoint.m_vecPosition,
                  &colPoint.m_vecNormal,
                  v28,
                  m_eBulletType);
              }
            }
          }
          if ( gaBulletInfo[v0].m_eBulletType == WEAPONTYPE_SNIPERRIFLE )
          {
            dir.x = vecEnd.x - vecStart.x;
            dir.y = vecEnd.y - vecStart.y;
            dir.z = vecEnd.z - vecStart.z;
            CVector::Normalise(&dir);
            if ( (float)((float)((float)(dir.x * colPoint.m_vecNormal.x) + (float)(dir.y * colPoint.m_vecNormal.y))
                       + (float)(dir.z * colPoint.m_vecNormal.z)) < 0.0 )
            {
              v37 = asinf(-(float)((float)((float)(dir.x * colPoint.m_vecNormal.x)
                                         + (float)(dir.y * colPoint.m_vecNormal.y))
                                 + (float)(dir.z * colPoint.m_vecNormal.z)));
              CAudioEngine::ReportBulletHit(
                &AudioEngine,
                refEntityPtr,
                colPoint.m_dataB.m_nSurfaceType,
                &colPoint.m_vecPosition,
                (float)(v37 * 180.0) / 3.1416);
            }
          }
          CGlass::WasGlassHitByBullet(refEntityPtr, colPoint.m_vecPosition);
        }
        CWorld::bIncludeCarTyres = 0;
        CWorld::bIncludeDeadPeds = 0;
        CWorld::bIncludeBikers = 0;
        CWorld::pIgnoreEntity = 0;
        if ( gaBulletInfo[v0].m_eBulletType == WEAPONTYPE_SNIPERRIFLE )
        {
          v38 = *(_QWORD *)&p_m_vecPosition->x;
          PlayerSniperBulletStart.z = gaBulletInfo[v0].m_vecPosition.z;
          PlayerSniperBulletEnd = vecEnd;
          *(_QWORD *)&PlayerSniperBulletStart.x = v38;
          CHeli::TestSniperCollision(&PlayerSniperBulletStart, &PlayerSniperBulletEnd);
        }
        gaBulletInfo[v0].m_vecPosition.z = vecEnd.z;
        v15 = refEntityPtr == 0;
        *(_QWORD *)&p_m_vecPosition->x = *(_QWORD *)&vecEnd.x;
        if ( !v15 )
          v3->m_bBulletActive = 0;
      }
    }
    ++v0;
  }
  while ( v0 != 8 );
}
// 34: using guessed type int dword_34;

//----- (005D78C0) --------------------------------------------------------
void CExplosion::Initialise()
{
  int v0; // r2
  CExplosion *v1; // r3

  v0 = 0;
  do
  {
    v1 = &gaExplosion[v0++];
    v1->m_cExplosionActive = 0;
    v1->m_ParticleTimer = 0.0;
    v1->m_bMakeSound = 1;
    v1->m_fExplosionForce = 0.0;
    v1->m_fGroundZ = 0.0;
    v1->m_fuelTime = 0;
    *(_QWORD *)&v1->m_fExplosionPropagationRate = 0LL;
    *(_QWORD *)&v1->m_pExplodingEntity = 0LL;
    *(_QWORD *)&v1->m_eExplosionType = 0LL;
    *(_QWORD *)&v1->m_vecExplosionPosition.y = 0LL;
    v1->m_fExplosionRadius = 1.0;
    gaExplosion[0].m_fuelDir[0].x = 0.0;
    gaExplosion[0].m_fuelDir[0].y = 0.0;
    gaExplosion[0].m_fuelDir[0].z = 0.0;
    gaExplosion[0].m_fuelSpeed[0] = 0.0;
    gaExplosion[0].m_fuelOffsetDist[0] = 0.0;
    gaExplosion[1].m_fuelDir[1].x = 0.0;
    gaExplosion[1].m_fuelDir[1].y = 0.0;
    gaExplosion[1].m_fuelDir[1].z = 0.0;
    gaExplosion[1].m_fuelOffsetDist[1] = 0.0;
    gaExplosion[1].m_fuelSpeed[1] = 0.0;
    gaExplosion[2].m_fuelOffsetDist[2] = 0.0;
    gaExplosion[2].m_fuelSpeed[2] = 0.0;
    gaExplosion[2].m_fuelDir[2].x = 0.0;
    gaExplosion[2].m_fuelDir[2].y = 0.0;
    gaExplosion[2].m_fuelDir[2].z = 0.0;
  }
  while ( v0 != 16 );
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005D7934) --------------------------------------------------------
void CExplosion::ClearAllExplosions()
{
  int v0; // r2
  CExplosion *v1; // r3

  v0 = 0;
  do
  {
    v1 = &gaExplosion[v0++];
    v1->m_cExplosionActive = 0;
    v1->m_ParticleTimer = 0.0;
    v1->m_bMakeSound = 1;
    v1->m_fExplosionForce = 0.0;
    v1->m_fGroundZ = 0.0;
    v1->m_fuelTime = 0;
    *(_QWORD *)&v1->m_fExplosionPropagationRate = 0LL;
    *(_QWORD *)&v1->m_pExplodingEntity = 0LL;
    *(_QWORD *)&v1->m_eExplosionType = 0LL;
    *(_QWORD *)&v1->m_vecExplosionPosition.y = 0LL;
    v1->m_fExplosionRadius = 1.0;
    gaExplosion[0].m_fuelDir[0].x = 0.0;
    gaExplosion[0].m_fuelDir[0].y = 0.0;
    gaExplosion[0].m_fuelDir[0].z = 0.0;
    gaExplosion[0].m_fuelSpeed[0] = 0.0;
    gaExplosion[0].m_fuelOffsetDist[0] = 0.0;
    gaExplosion[1].m_fuelDir[1].x = 0.0;
    gaExplosion[1].m_fuelDir[1].y = 0.0;
    gaExplosion[1].m_fuelDir[1].z = 0.0;
    gaExplosion[1].m_fuelOffsetDist[1] = 0.0;
    gaExplosion[1].m_fuelSpeed[1] = 0.0;
    gaExplosion[2].m_fuelOffsetDist[2] = 0.0;
    gaExplosion[2].m_fuelSpeed[2] = 0.0;
    gaExplosion[2].m_fuelDir[2].x = 0.0;
    gaExplosion[2].m_fuelDir[2].y = 0.0;
    gaExplosion[2].m_fuelDir[2].z = 0.0;
  }
  while ( v0 != 16 );
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005D79AC) --------------------------------------------------------
UInt8 __fastcall CExplosion::GetExplosionActiveCounter(UInt8 i)
{
  return gaExplosion[i].m_nTriggerExplosionSfx;
}

//----- (005D79C4) --------------------------------------------------------
void __fastcall CExplosion::ResetExplosionActiveCounter(UInt8 i)
{
  gaExplosion[i].m_nTriggerExplosionSfx = 0;
}

//----- (005D79DC) --------------------------------------------------------
Bool8 __fastcall CExplosion::DoesExplosionMakeSound(UInt8 i)
{
  return gaExplosion[i].m_bMakeSound;
}

//----- (005D79F4) --------------------------------------------------------
eExplosionType __fastcall CExplosion::GetExplosionType(UInt8 i)
{
  return gaExplosion[i].m_eExplosionType;
}

//----- (005D7A08) --------------------------------------------------------
CVector *__fastcall CExplosion::GetExplosionPosition(UInt8 i)
{
  return &gaExplosion[i].m_vecExplosionPosition;
}

//----- (005D7A1C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall CExplosion::AddExplosion(
        CEntity *pExplodingEntity,
        CEntity *pEntExplosionOwner,
        eExplosionType ExplosionType,
        CVector vecExplosionPosition,
        uint32 ActivationDelay,
        bool8 bMakeSound,
        float fCamShake,
        int noDamage)
{
  CPlayerPed *PlayerPed; // r0
  CEntity *v12; // r3
  CPlayerInfo *v13; // r0
  float v14; // s0
  int v15; // r2
  uint32 v16; // r6
  int v17; // s16
  CEntity **p_m_pGameEntity; // r0
  CEntity **v19; // r10
  int v20; // r1
  bool v21; // zf
  int v22; // r4
  CEntity *v23; // r0
  __int64 v24; // d16
  CEntity *v25; // r0
  int v26; // r0
  int v27; // r0
  float v28; // s0
  float *v29; // r0
  int v30; // r0
  int v31; // r0
  int v32; // s0
  float v33; // s0
  float *v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // s0
  int v38; // r2
  uint32 v39; // r0
  float v40; // s0
  int *v41; // r1
  int v42; // s4
  RwObject_0 *v43; // r0
  char *v44; // r1
  CMatrix *v45; // r0
  CSimpleTransform *v46; // r2
  RwReal v47; // s2
  RwReal v48; // s4
  FxSystem_c *v49; // r0
  unsigned int v50; // r0
  float v51; // s2
  CEntity *v52; // r1
  int *v53; // r6
  int v54; // s6
  int v55; // r4
  CEntity *v56; // r0
  uint32 m_hashKey; // r0
  __int64 v58; // d16
  RwObject_0 *v59; // r0
  FxSystem_c *v60; // r4
  unsigned int v61; // r0
  float v62; // s2
  int *v63; // r1
  int v64; // s6
  RwObject_0 *v65; // r0
  char *v66; // r1
  CMatrix *v67; // r0
  CSimpleTransform *v68; // r2
  RwReal v69; // s2
  RwReal v70; // s4
  FxSystem_c *v71; // r0
  unsigned int v72; // r0
  float v73; // s0
  int *v74; // r1
  int v75; // s4
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  RwReal v80; // s2
  RwReal v81; // s4
  FxSystem_c *v82; // r0
  unsigned int v83; // r0
  float v84; // s2
  float GroundZFor3DCoord; // r0
  float z; // s0
  unsigned int v87; // r0
  float v88; // s2
  int *v89; // r1
  int v90; // s6
  float v91; // s0
  unsigned int v92; // r0
  float v93; // s0
  int v94; // r2
  int *v95; // r1
  int v96; // s4
  float v97; // s0
  int *v98; // r1
  int v99; // s4
  RwObject_0 *v100; // r0
  char *v101; // r1
  CMatrix *v102; // r0
  CSimpleTransform *v103; // r2
  RwReal v104; // s2
  RwReal v105; // s4
  FxSystem_c *v106; // r0
  unsigned int v107; // r0
  float v108; // s0
  int *v109; // r1
  int v110; // s4
  RwObject_0 *v111; // r0
  char *v112; // r1
  CMatrix *v113; // r0
  CSimpleTransform *v114; // r2
  RwReal v115; // s2
  RwReal v116; // s4
  FxSystem_c *v117; // r0
  unsigned int v118; // r0
  float v119; // s0
  int *v120; // r1
  int v121; // s4
  RwObject_0 *v122; // r0
  char *v123; // r1
  CMatrix *v124; // r0
  CSimpleTransform *v125; // r2
  RwReal v126; // s2
  RwReal v127; // s4
  FxSystem_c *v128; // r0
  RwObject_0 *v129; // r0
  char *v130; // r1
  CMatrix *v131; // r0
  CSimpleTransform *p_m_transform; // r2
  RwReal v133; // s2
  RwReal v134; // s4
  FxSystem_c *v135; // r0
  CVector *v136; // r2
  int v137; // r3
  __int32 v138; // r0
  int v139; // r4
  int v140; // r0
  int v141; // r11
  int v142; // r8
  float v143; // s23
  float v144; // r5
  float v145; // r6
  float v146; // r9
  CEntity *bReportFire; // r4
  unsigned int v148; // s0
  bool8 v149; // r0
  int v150; // r0
  CPad *Pad; // r0
  CPad *v152; // r0
  TouchSense *v153; // r0
  eExplosionType v155; // [sp+28h] [bp-A0h]
  CEntity *pExplosionOwner; // [sp+30h] [bp-98h]
  CEntity *v157; // [sp+34h] [bp-94h]
  RwV3d_0 offsetPos; // [sp+38h] [bp-90h] BYREF
  CRGBA v159; // [sp+48h] [bp-80h] BYREF
  CRGBA v160; // [sp+4Ch] [bp-7Ch] BYREF
  float pWaterZ; // [sp+50h] [bp-78h] BYREF
  bool pBool; // [sp+57h] [bp-71h] BYREF
  RwV3d_0 v163; // [sp+58h] [bp-70h] BYREF

  v163 = vecExplosionPosition.RwV3d_0;
  CRGBA::CRGBA(&v160, 0, 0, 0, 0);
  CRGBA::CRGBA(&v159, 0xA0u, 0xA0u, 0xA0u, 0xFFu);
  PlayerPed = FindPlayerPed(-1);
  v12 = pEntExplosionOwner;
  if ( PlayerPed == pEntExplosionOwner )
  {
    v13 = &CWorld::Players[CWorld::PlayerInFocus];
    v14 = v13->CurrentChaseValue + 7.0;
    v13->HavocCaused += 5;
    v13->CurrentChaseValue = v14;
  }
  v15 = 0;
  v16 = ActivationDelay;
  v17 = LODWORD(fCamShake);
  p_m_pGameEntity = &CExplosion::m_ExplosionAudioEntity.m_pGameEntity;
  do
  {
    v19 = p_m_pGameEntity + 31;
    v20 = v15 + 1;
    if ( v15 > 15 )
      break;
    ++v15;
    v21 = *((_BYTE *)p_m_pGameEntity + 164) == 0;
    p_m_pGameEntity += 31;
  }
  while ( !v21 );
  v22 = 0;
  if ( v20 != 17 )
  {
    v157 = pExplodingEntity;
    *v19 = (CEntity *)ExplosionType;
    v23 = v19[6];
    v24 = *(_QWORD *)&v163.x;
    v19[3] = (CEntity *)LODWORD(v163.z);
    v19[4] = (CEntity *)1065353216;
    v19[13] = 0;
    v19[14] = 0;
    v19[9] = (CEntity *)1065353216;
    *(_QWORD *)(v19 + 1) = v24;
    pExplosionOwner = v12;
    if ( v23 )
    {
      CEntity::CleanUpOldReference(v23, v19 + 6);
      v12 = pExplosionOwner;
    }
    v19[6] = v12;
    if ( v12 )
      CEntity::RegisterReference(v12, v19 + 6);
    v25 = v19[7];
    if ( v25 )
      CEntity::CleanUpOldReference(v25, v19 + 7);
    v19[7] = pExplodingEntity;
    if ( pExplodingEntity )
      CEntity::RegisterReference(pExplodingEntity, v19 + 7);
    *((_BYTE *)v19 + 42) = bMakeSound;
    *((_WORD *)v19 + 20) = 257;
    v19[15] = 0;
    v26 = rand();
    *((float *)v19 + 16) = (float)((float)((float)v26 * 4.6566e-10) + (float)((float)v26 * 4.6566e-10)) + -1.0;
    v27 = rand();
    *((float *)v19 + 17) = (float)((float)((float)v27 * 4.6566e-10) + (float)((float)v27 * 4.6566e-10)) + -1.0;
    *((float *)v19 + 18) = (float)((float)((float)rand() * 4.6566e-10) * 0.8) + 0.2;
    *((float *)v19 + 25) = (float)((float)((float)rand() * 4.6566e-10) * 1.5) + 0.5;
    *((float *)v19 + 28) = (float)((float)((float)rand() * 4.6566e-10) * 10.0) + 20.0;
    if ( (rand() & 1) != 0 )
    {
      v30 = rand();
      *((float *)v19 + 19) = (float)((float)((float)v30 * 4.6566e-10) + (float)((float)v30 * 4.6566e-10)) + -1.0;
      v31 = rand();
      *((float *)v19 + 20) = (float)((float)((float)v31 * 4.6566e-10) + (float)((float)v31 * 4.6566e-10)) + -1.0;
      *((float *)v19 + 21) = (float)((float)((float)rand() * 4.6566e-10) * 0.8) + 0.2;
      *((float *)v19 + 26) = (float)((float)((float)rand() * 4.6566e-10) * 1.5) + 0.5;
      v32 = rand();
      v29 = (float *)(v19 + 29);
      v28 = (float)((float)((float)v32 * 4.6566e-10) * 10.0) + 20.0;
    }
    else
    {
      v28 = 0.0;
      v29 = (float *)(v19 + 26);
    }
    *v29 = v28;
    if ( (rand() & 1) != 0 )
    {
      v35 = rand();
      *((float *)v19 + 22) = (float)((float)((float)v35 * 4.6566e-10) + (float)((float)v35 * 4.6566e-10)) + -1.0;
      v36 = rand();
      *((float *)v19 + 23) = (float)((float)((float)v36 * 4.6566e-10) + (float)((float)v36 * 4.6566e-10)) + -1.0;
      *((float *)v19 + 24) = (float)((float)((float)rand() * 4.6566e-10) * 0.8) + 0.2;
      *((float *)v19 + 27) = (float)((float)((float)rand() * 4.6566e-10) * 1.5) + 0.5;
      v37 = rand();
      v34 = (float *)(v19 + 30);
      v33 = (float)((float)((float)v37 * 4.6566e-10) * 10.0) + 20.0;
    }
    else
    {
      v33 = 0.0;
      v34 = (float *)(v19 + 27);
    }
    *v34 = v33;
    v38 = CTimer::m_snTimeInMilliseconds;
    v39 = CTimer::m_snTimeInMilliseconds + ActivationDelay;
    if ( ActivationDelay )
      v16 = CTimer::m_snTimeInMilliseconds + ActivationDelay;
    v19[12] = (CEntity *)v16;
    switch ( ExplosionType )
    {
      case EXP_TYPE_GRENADE:
        v72 = v39 + 750;
        v73 = 0.0;
        v74 = &dword_5D893C;
        if ( !noDamage )
          v73 = 9.0;
        if ( !noDamage )
          v74 = &dword_5D8940;
        v75 = *v74;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v75;
        *((float *)v19 + 4) = v73;
        *((float *)v19 + 8) = (float)v72;
        if ( pExplodingEntity )
        {
          m_pRwObject = pExplodingEntity->m_pRwObject;
          if ( !m_pRwObject )
            goto LABEL_126;
          parent = (char *)m_pRwObject->parent;
          m_pMat = pExplodingEntity->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pExplodingEntity->m_transform;
          v80 = v163.y - p_tx->m_translate.y;
          v81 = v163.z - p_tx->m_translate.z;
          offsetPos.x = v163.x - p_tx->m_translate.x;
          offsetPos.y = v80;
          offsetPos.z = v81;
          v82 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_small", &offsetPos, (RwMatrix *)(parent + 16), 0);
        }
        else
        {
          v82 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_small", &v163, 0, 0);
        }
        v60 = v82;
        if ( !v82 )
          goto LABEL_145;
        if ( !*((_BYTE *)v19 + 42) )
          goto LABEL_144;
        goto LABEL_142;
      case EXP_TYPE_MOLOTOV:
        v83 = v39 + 3000;
        v84 = 0.0;
        if ( !noDamage )
          v84 = 6.0;
        v19[13] = 0;
        v19[5] = (CEntity *)1056964608;
        *((float *)v19 + 4) = v84;
        *((float *)v19 + 8) = (float)v83;
        GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(v163.x, v163.y, v163.z + 3.0, &pBool, 0);
        if ( pBool )
        {
          z = GroundZFor3DCoord;
          v163.z = GroundZFor3DCoord;
        }
        else
        {
          z = v163.z;
        }
        if ( CWaterLevel::GetWaterLevelNoWaves(v163.x, v163.y, z, &pWaterZ, 0, 0) && v163.z < pWaterZ )
        {
          v55 = 1;
          if ( pExplodingEntity )
            goto LABEL_147;
          goto LABEL_148;
        }
        if ( pExplodingEntity )
        {
          v129 = pExplodingEntity->m_pRwObject;
          if ( !v129 )
            goto LABEL_126;
          v130 = (char *)v129->parent;
          v131 = pExplodingEntity->m_pMat;
          p_m_transform = (CSimpleTransform *)&v131->tx;
          if ( !v131 )
            p_m_transform = &pExplodingEntity->m_transform;
          v133 = v163.y - p_m_transform->m_translate.y;
          v134 = v163.z - p_m_transform->m_translate.z;
          offsetPos.x = v163.x - p_m_transform->m_translate.x;
          offsetPos.y = v133;
          offsetPos.z = v134;
          v135 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_molotov", &offsetPos, (RwMatrix *)(v130 + 16), 0);
        }
        else
        {
          v135 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_molotov", &v163, 0, 0);
        }
        v60 = v135;
        if ( !v135 )
          goto LABEL_145;
        if ( !*((_BYTE *)v19 + 42) )
          goto LABEL_144;
        v137 = -1039138816;
        v136 = (CVector *)(v19 + 1);
        goto LABEL_143;
      case EXP_TYPE_ROCKET:
      case EXP_TYPE_ROCKET_WEAK:
        v40 = 0.0;
        v41 = &dword_5D893C;
        if ( !noDamage )
          v40 = 10.0;
        if ( !noDamage )
          v41 = &dword_5D8940;
        v42 = *v41;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v42;
        *((float *)v19 + 4) = v40;
        *((float *)v19 + 8) = (float)(v39 + 750);
        if ( ExplosionType == EXP_TYPE_ROCKET_WEAK )
        {
          v19[9] = (CEntity *)1045220557;
          v19[13] = (CEntity *)1128792064;
        }
        if ( pExplodingEntity )
        {
          v43 = pExplodingEntity->m_pRwObject;
          if ( !v43 )
            goto LABEL_126;
          v44 = (char *)v43->parent;
          v45 = pExplodingEntity->m_pMat;
          v46 = (CSimpleTransform *)&v45->tx;
          if ( !v45 )
            v46 = &pExplodingEntity->m_transform;
          v47 = v163.y - v46->m_translate.y;
          v48 = v163.z - v46->m_translate.z;
          offsetPos.x = v163.x - v46->m_translate.x;
          offsetPos.y = v47;
          offsetPos.z = v48;
          v49 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_small", &offsetPos, (RwMatrix *)(v44 + 16), 0);
        }
        else
        {
          v49 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_small", &v163, 0, 0);
        }
        v60 = v49;
        if ( !v49 )
          goto LABEL_145;
        if ( *((_BYTE *)v19 + 42) )
          goto LABEL_142;
        goto LABEL_144;
      case EXP_TYPE_CAR:
      case EXP_TYPE_CAR_QUICK:
        v50 = v39 + 4250;
        v51 = 0.0;
        v52 = v19[7];
        v53 = &dword_5D893C;
        if ( !noDamage )
          v51 = 9.0;
        if ( !noDamage )
          v53 = &dword_5D8940;
        v54 = *v53;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v54;
        *((float *)v19 + 11) = (float)v38;
        *((float *)v19 + 4) = v51;
        *((float *)v19 + 8) = (float)v50;
        if ( !v52 )
          goto LABEL_145;
        v55 = 0;
        CCrime::ReportCrime(CRIME_CAUSE_EXPLOSION, v52, 0);
        v56 = v19[7];
        if ( !v56 )
          goto LABEL_146;
        m_hashKey = CModelInfo::ms_modelInfoPtrs[v56->m_nModelIndex][2].m_hashKey;
        v58 = *(_QWORD *)(m_hashKey + 84);
        offsetPos.z = *(RwReal *)(m_hashKey + 92);
        *(_QWORD *)&offsetPos.x = v58;
        v59 = pExplodingEntity->m_pRwObject;
        if ( !v59 )
          goto LABEL_145;
        v60 = FxManager_c::CreateFxSystem(
                &g_fxMan,
                "explosion_medium",
                &offsetPos,
                (RwMatrix *)((char *)v59->parent + 16),
                0);
        if ( !v60 )
          goto LABEL_145;
        if ( *((_BYTE *)v19 + 42) )
          goto LABEL_142;
        goto LABEL_144;
      case EXP_TYPE_BOAT:
      case EXP_TYPE_HELI:
        v61 = v39 + 3000;
        v62 = 0.0;
        v63 = &dword_5D8928;
        if ( !noDamage )
          v62 = 25.0;
        if ( !noDamage )
          v63 = &dword_5D892C;
        v64 = *v63;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v64;
        *((float *)v19 + 11) = (float)v38;
        *((float *)v19 + 4) = v62;
        *((float *)v19 + 8) = (float)v61;
        if ( pExplodingEntity )
        {
          v65 = pExplodingEntity->m_pRwObject;
          if ( !v65 )
            goto LABEL_126;
          v66 = (char *)v65->parent;
          v67 = pExplodingEntity->m_pMat;
          v68 = (CSimpleTransform *)&v67->tx;
          if ( !v67 )
            v68 = &pExplodingEntity->m_transform;
          v69 = v163.y - v68->m_translate.y;
          v70 = v163.z - v68->m_translate.z;
          offsetPos.x = v163.x - v68->m_translate.x;
          offsetPos.y = v69;
          offsetPos.z = v70;
          v71 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_large", &offsetPos, (RwMatrix *)(v66 + 16), 0);
        }
        else
        {
          v71 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_large", &v163, 0, 0);
        }
        v60 = v71;
        if ( !v71 )
          goto LABEL_145;
        if ( *((_BYTE *)v19 + 42) )
          goto LABEL_142;
        goto LABEL_144;
      case EXP_TYPE_MINE:
        v87 = v39 + 750;
        v88 = 0.0;
        if ( !noDamage )
          v88 = 10.0;
        v89 = &dword_5D88FC;
        if ( !noDamage )
          v89 = &dword_5D8900;
        v90 = *v89;
        v19[5] = (CEntity *)1056964608;
        v55 = 0;
        v19[13] = (CEntity *)v90;
        *((float *)v19 + 4) = v88;
        v91 = v163.z + 4.0;
        *((float *)v19 + 8) = (float)v87;
        CWorld::FindGroundZFor3DCoord(v163.x, v163.y, v91, 0, 0);
        if ( *((_BYTE *)v19 + 42) )
          goto LABEL_84;
        goto LABEL_146;
      case EXP_TYPE_OBJECT:
        v92 = v39 + 750;
        v93 = 0.0;
        v94 = *((unsigned __int8 *)v19 + 42);
        if ( !noDamage )
          v93 = 10.0;
        v95 = &dword_5D88FC;
        if ( !noDamage )
          v95 = &dword_5D8900;
        v96 = *v95;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v96;
        *((float *)v19 + 4) = v93;
        *((float *)v19 + 8) = (float)v92;
        if ( !v94 )
          goto LABEL_145;
LABEL_84:
        v55 = 0;
        CAEExplosionAudioEntity::AddAudioEvent(&CExplosion::m_ExplosionAudioEntity, 129, (CVector *)(v19 + 1), 0.0);
        if ( !pExplodingEntity )
          goto LABEL_148;
        goto LABEL_147;
      case EXP_TYPE_TANK_GRENADE:
        v97 = 0.0;
        v98 = &dword_5D88FC;
        if ( !noDamage )
          v97 = 10.0;
        if ( !noDamage )
          v98 = &dword_5D8900;
        v99 = *v98;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v99;
        *((float *)v19 + 4) = v97;
        *((float *)v19 + 8) = (float)(v39 + 750);
        if ( pExplodingEntity )
        {
          v100 = pExplodingEntity->m_pRwObject;
          if ( !v100 )
            goto LABEL_126;
          v101 = (char *)v100->parent;
          v102 = pExplodingEntity->m_pMat;
          v103 = (CSimpleTransform *)&v102->tx;
          if ( !v102 )
            v103 = &pExplodingEntity->m_transform;
          v104 = v163.y - v103->m_translate.y;
          v105 = v163.z - v103->m_translate.z;
          offsetPos.x = v163.x - v103->m_translate.x;
          offsetPos.y = v104;
          offsetPos.z = v105;
          v106 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_large", &offsetPos, (RwMatrix *)(v101 + 16), 0);
        }
        else
        {
          v106 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_large", &v163, 0, 0);
        }
        v60 = v106;
        if ( !v106 )
          goto LABEL_145;
        if ( *((_BYTE *)v19 + 42) )
          goto LABEL_142;
        goto LABEL_144;
      case EXP_TYPE_SMALL:
        v107 = v39 + 750;
        v108 = 0.0;
        v109 = &dword_5D88BC;
        if ( !noDamage )
          v108 = 3.0;
        if ( !noDamage )
          v109 = &dword_5D88C0;
        v110 = *v109;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v110;
        *((float *)v19 + 4) = v108;
        *((float *)v19 + 8) = (float)v107;
        if ( pExplodingEntity )
        {
          v111 = pExplodingEntity->m_pRwObject;
          if ( !v111 )
            goto LABEL_126;
          v112 = (char *)v111->parent;
          v113 = pExplodingEntity->m_pMat;
          v114 = (CSimpleTransform *)&v113->tx;
          if ( !v113 )
            v114 = &pExplodingEntity->m_transform;
          v115 = v163.y - v114->m_translate.y;
          v116 = v163.z - v114->m_translate.z;
          offsetPos.x = v163.x - v114->m_translate.x;
          offsetPos.y = v115;
          offsetPos.z = v116;
          v117 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_small", &offsetPos, (RwMatrix *)(v112 + 16), 0);
        }
        else
        {
          v117 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_small", &v163, 0, 0);
        }
        v60 = v117;
        if ( !v117 )
          goto LABEL_145;
        if ( *((_BYTE *)v19 + 42) )
          goto LABEL_142;
        goto LABEL_144;
      case EXP_TYPE_TINY:
        v118 = v39 + 750;
        v119 = 0.0;
        v120 = &dword_5D88BC;
        if ( !noDamage )
          v119 = 3.0;
        if ( !noDamage )
          v120 = &dword_5D88C0;
        v121 = *v120;
        v19[5] = (CEntity *)1056964608;
        v19[13] = (CEntity *)v121;
        *((float *)v19 + 4) = v119;
        *((float *)v19 + 8) = (float)v118;
        if ( pExplodingEntity )
        {
          v122 = pExplodingEntity->m_pRwObject;
          if ( !v122 )
          {
LABEL_126:
            CInterestingEvents::Add(&g_InterestingEvents, EExplosion, pExplodingEntity);
            goto LABEL_150;
          }
          v123 = (char *)v122->parent;
          v124 = pExplodingEntity->m_pMat;
          v125 = (CSimpleTransform *)&v124->tx;
          if ( !v124 )
            v125 = &pExplodingEntity->m_transform;
          v126 = v163.y - v125->m_translate.y;
          v127 = v163.z - v125->m_translate.z;
          offsetPos.x = v163.x - v125->m_translate.x;
          offsetPos.y = v126;
          offsetPos.z = v127;
          v128 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_tiny", &offsetPos, (RwMatrix *)(v123 + 16), 0);
        }
        else
        {
          v128 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_tiny", &v163, 0, 0);
        }
        v60 = v128;
        if ( v128 )
        {
          if ( *((_BYTE *)v19 + 42) )
          {
LABEL_142:
            v136 = (CVector *)(v19 + 1);
            v137 = 0;
LABEL_143:
            CAEExplosionAudioEntity::AddAudioEvent(&CExplosion::m_ExplosionAudioEntity, 129, v136, *(float *)&v137);
          }
LABEL_144:
          FxSystem_c::PlayAndKill(v60);
        }
LABEL_145:
        v55 = 0;
LABEL_146:
        if ( pExplodingEntity )
LABEL_147:
          CInterestingEvents::Add(&g_InterestingEvents, EExplosion, pExplodingEntity);
LABEL_148:
        if ( v55 )
        {
          v22 = 0;
          *((_BYTE *)v19 + 40) = 0;
          return v22;
        }
LABEL_150:
        v138 = ExplosionType - 1;
        if ( (unsigned int)(ExplosionType - 1) <= 8 )
        {
          if ( 0x107u >> v138 << 31 )
          {
            v139 = dword_5D89A4[v138];
            v140 = ((unsigned __int8)rand() + (_BYTE)v139) & 3;
            if ( v140 )
            {
              v155 = ExplosionType;
              v141 = -v140;
              v142 = 0;
              do
              {
                v143 = *((float *)v19 + 3);
                v144 = *((float *)v19 + 2);
                v145 = *((float *)v19 + 1);
                if ( v142 )
                {
                  v145 = (float)((float)((float)((float)rand() * 4.6566e-10) * 8.0) + -4.0) + v145;
                  v144 = (float)((float)((float)((float)rand() * 4.6566e-10) * 8.0) + -4.0) + v144;
                }
                v146 = CWorld::FindGroundZFor3DCoord(v145, v144, v143 + 3.0, &pBool, 0);
                if ( pBool && fabsf(v146 - *((float *)v19 + 3)) < 10.0 )
                {
                  bReportFire = v19[6];
                  v148 = (unsigned int)(float)((float)((float)((float)((float)rand() * 4.6566e-10) * 0.4) + 0.8) * 7000.0);
                  v149 = v142;
                  if ( v142 )
                    v149 = 1;
                  CFireManager::StartFire(&gFireManager, v145, v144, v146, 0.8, v149, bReportFire, v148, 3);
                }
                --v142;
              }
              while ( v141 != v142 );
              ExplosionType = v155;
              pExplodingEntity = v157;
              if ( pExplosionOwner
                && (*(_BYTE *)&pExplosionOwner->m_info & 7) == 3
                && !*(_DWORD *)&pExplosionOwner[23].numLodChildren )
              {
                CStats::IncrementStat(0xD8u, 1.0);
              }
            }
          }
        }
        *(_QWORD *)&offsetPos.x = *(_QWORD *)&v163.x;
        offsetPos.z = v163.z + 5.0;
        CShadows::AddPermanentShadow(
          1u,
          gpShadowHeliTex,
          (CVector *)&offsetPos,
          8.0,
          0.0,
          0.0,
          -8.0,
          200,
          0,
          0,
          0,
          10.0,
          0x7530u,
          1.0);
        if ( *((float *)v19 + 13) == 0.0 || v19[12] )
        {
          if ( ExplosionType == EXP_TYPE_MOLOTOV )
            goto LABEL_169;
        }
        else
        {
          if ( (unsigned int)(ExplosionType - 2) > 8 )
            v150 = 0;
          else
            v150 = (0x1C9u >> (ExplosionType - 2)) & 1;
          CWorld::TriggerExplosion(
            (const CVector *)&v163,
            *((float *)v19 + 4),
            *((float *)v19 + 13),
            pExplodingEntity,
            pExplosionOwner,
            v150,
            *((float *)v19 + 9));
          if ( ExplosionType == EXP_TYPE_MOLOTOV )
          {
LABEL_169:
            if ( fCamShake == -1.0 )
              v17 = 1045220557;
            CCamera::CamShake(&TheCamera, *(float *)&v17, v163.x, v163.y, v163.z);
            goto LABEL_180;
          }
        }
        if ( fCamShake == -1.0 )
          v17 = 1058642330;
        CCamera::CamShake(&TheCamera, *(float *)&v17, v163.x, v163.y, v163.z);
        Pad = CPad::GetPad(0);
        CPad::StartShake_Distance(Pad, 300, 0x80u, v163.x, v163.y, v163.z);
        if ( CGameLogic::IsCoopGameGoingOn() == 1 )
        {
          v152 = CPad::GetPad(1);
          CPad::StartShake_Distance(v152, 300, 0x80u, v163.x, v163.y, v163.z);
        }
LABEL_180:
        TouchSense::instance();
        v22 = 1;
        TouchSense::playBuiltinEffect(v153, 1, 81, 115, 20);
        break;
      default:
        goto LABEL_145;
    }
  }
  return v22;
}
// 5D7A1C: fragmented variable at 0:r3.4,4:^D0.8 may be wrong
// 5D7A1C: variables would overlap: 0:r3.4,4:^D0.8 and ^D0.8
// 5D88BC: using guessed type int dword_5D88BC;
// 5D88C0: using guessed type int;
// 5D88FC: using guessed type int dword_5D88FC;
// 5D8900: using guessed type int;
// 5D8928: using guessed type int dword_5D8928;
// 5D892C: using guessed type int;
// 5D893C: using guessed type int dword_5D893C;
// 5D8940: using guessed type int;
// 5D89A4: using guessed type int dword_5D89A4[9];

//----- (005D89DC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void CExplosion::Update()
{
  int i; // r6
  CExplosion *v1; // r4
  uint32 m_ActivationTime; // r1
  unsigned __int32 v3; // r1
  int v4; // r4
  CExplosion *v5; // r5
  float m_TimeExpires; // s4
  eExplosionType m_eExplosionType; // r0
  float *p_z; // r9
  float x; // r8
  __int64 v10; // r10
  CEntity *m_pExplodingEntity; // r0
  CMatrix *m_pMat; // r3
  __int64 *p_tx; // r2
  __int64 v14; // kr10_8 OVERLAPPED
  float v15; // s21
  int v16; // r0
  int v17; // s0
  CEntity *v18; // r0
  float v19; // s0
  float v20; // s4
  float v21; // s6
  float v22; // s0
  CMatrix *v23; // r1
  float *p_x; // r2
  UInt8 v25; // r0
  CExplosion *v26; // r4
  uint32 v27; // r0
  CVector *p_m_vecExplosionPosition; // r5
  float v29; // s0
  __int64 v30; // d16
  float v31; // s4
  float z; // s6
  float v33; // s0
  float v34; // s4
  FxSystem_c *FxSystem; // r0
  float v36; // s0
  float m_fuelTime; // s2
  __int64 v38; // d16
  float v39; // s0
  float v40; // s4
  float v41; // s2
  float v42; // s0
  FxSystem_c *v43; // r0
  float v44; // s0
  float v45; // s2
  __int64 v46; // d16
  float v47; // s0
  float v48; // s4
  float v49; // s2
  float v50; // s0
  FxSystem_c *v51; // r0
  CVector alpha; // [sp+0h] [bp-F8h] BYREF
  int v53; // [sp+54h] [bp-A4h]
  CVector vecStart; // [sp+58h] [bp-A0h] BYREF
  CEntity *refEntityPtr; // [sp+64h] [bp-94h] BYREF
  CColPoint v56; // [sp+68h] [bp-90h] BYREF
  CRGBA v57; // [sp+94h] [bp-64h] BYREF
  CVector v58; // 0:r0.12
  CVector v59; // 0:r1.12
  CVector v60; // 0:r1.12

  CRGBA::CRGBA(&v57, 0, 0, 0, 0);
  for ( i = 0; i != 16; ++i )
  {
    v1 = &gaExplosion[i];
    if ( gaExplosion[i].m_cExplosionActive )
    {
      m_ActivationTime = gaExplosion[i].m_ActivationTime;
      if ( m_ActivationTime )
      {
        if ( CTimer::m_snTimeInMilliseconds > m_ActivationTime )
        {
          gaExplosion[i].m_ActivationTime = 0;
          if ( gaExplosion[i].m_fExplosionForce != 0.0 )
          {
            v3 = gaExplosion[i].m_eExplosionType - 2;
            if ( v3 > 8 )
              v4 = 0;
            else
              v4 = (0x1C9u >> v3) & 1;
            CWorld::TriggerExplosion(
              &gaExplosion[i].m_vecExplosionPosition,
              gaExplosion[i].m_fExplosionRadius,
              gaExplosion[i].m_fExplosionForce,
              gaExplosion[i].m_pExplodingEntity,
              gaExplosion[i].m_pEntExplosionOwner,
              v4,
              gaExplosion[i].m_DamagePercentage);
          }
        }
      }
      else
      {
        v5 = &gaExplosion[i];
        m_TimeExpires = gaExplosion[i].m_TimeExpires;
        gaExplosion[i].m_fExplosionRadius = gaExplosion[i].m_fExplosionRadius
                                          + (float)(gaExplosion[i].m_fExplosionPropagationRate * CTimer::ms_fTimeStep);
        m_eExplosionType = gaExplosion[i].m_eExplosionType;
        v53 = (int)(float)(m_TimeExpires - (float)CTimer::m_snTimeInMilliseconds);
        if ( (unsigned int)m_eExplosionType <= EXP_TYPE_OBJECT )
        {
          p_z = &v5->m_vecExplosionPosition.z;
          v10 = *(_QWORD *)&v5->m_vecExplosionPosition.y;
          x = v5->m_vecExplosionPosition.x;
          if ( ((1 << m_eExplosionType) & 0x38D) != 0 )
          {
            if ( (unsigned __int8)CTimer::m_FrameCounter << 31 )
            {
              memset(&alpha, 0, sizeof(alpha));
              LODWORD(v59.y) = v10;
              v59.z = v5->m_vecExplosionPosition.z;
              v59.x = x;
              CPointLights::AddLight(0, v59, alpha, 20.0, 1.0, 1.0, 0.5, 0, 1, 0);
              m_eExplosionType = v5->m_eExplosionType;
            }
            if ( m_eExplosionType == EXP_TYPE_HELI
              && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 4 )
            {
              m_pExplodingEntity = gaExplosion[i].m_pExplodingEntity;
              if ( m_pExplodingEntity )
              {
                m_pMat = m_pExplodingEntity->m_pMat;
                p_tx = (__int64 *)&m_pMat->tx;
                if ( !m_pMat )
                  p_tx = (__int64 *)&m_pExplodingEntity->m_transform;
                v14 = *p_tx;
                *(_QWORD *)&alpha.x = *(__int64 *)((char *)p_tx + 4);
                CExplosion::AddExplosion(
                  m_pExplodingEntity,
                  gaExplosion[i].m_pEntExplosionOwner,
                  EXP_TYPE_ROCKET,
                  *(CVector *)&v14,
                  0,
                  1u,
                  -1.0,
                  0);
              }
            }
          }
          else if ( ((1 << m_eExplosionType) & 0x70) != 0 )
          {
            if ( gaExplosion[i].m_pExplodingEntity && (rand() & 0x1F) == 0 )
            {
              v15 = (float)rand();
              v16 = rand();
              v56.m_vecPosition.z = 0.0;
              v56.m_vecPosition.x = (float)(v15 * 4.6566e-10) + -0.5;
              v56.m_vecPosition.y = (float)((float)v16 * 4.6566e-10) + -0.5;
              CVector::Normalise(&v56.m_vecPosition);
              v17 = rand();
              v18 = gaExplosion[i].m_pExplodingEntity;
              v19 = (float)((float)v17 * 4.6566e-10) + 1.0;
              v20 = v56.m_vecPosition.y * v19;
              v21 = v19 * v56.m_vecPosition.z;
              v22 = v56.m_vecPosition.x * v19;
              v56.m_vecPosition.y = v20;
              v56.m_vecPosition.z = v21;
              v23 = v18->m_pMat;
              p_x = &v23->tx;
              if ( !v23 )
                p_x = &v18->m_transform.m_translate.x;
              v56.m_vecPosition.x = *p_x + v22;
              v58.x = v56.m_vecPosition.x;
              v56.m_vecPosition.y = p_x[1] + v20;
              v58.y = v56.m_vecPosition.y;
              v58.z = (float)(p_x[2] + v21) + 2.0;
              v56.m_vecPosition.z = v58.z;
              CCreepingFire::TryToStartFireAtCoors(v58, 0, 1, 0, 10.0);
            }
            if ( (unsigned __int8)CTimer::m_FrameCounter << 31 )
            {
              memset(&alpha, 0, sizeof(alpha));
              *(_QWORD *)&v60.y = v10;
              v60.x = x;
              CPointLights::AddLight(0, v60, alpha, 15.0, 1.0, 0.7, 0.5, 0, 1, 0);
            }
          }
          else
          {
            CWorld::SetPedsOnFire(
              x,
              *(float *)&v10,
              v5->m_vecExplosionPosition.z,
              6.0,
              (int)gaExplosion[i].m_pEntExplosionOwner);
            CWorld::SetCarsOnFire(x, *(float *)&v10, *((float *)&v10 + 1), 6.0, gaExplosion[i].m_pEntExplosionOwner);
            CWorld::SetWorldOnFire(x, *(float *)&v10, *((float *)&v10 + 1), 0.1, gaExplosion[i].m_pEntExplosionOwner);
            if ( v1->m_cExplosionActive == 1 )
            {
              vecStart = gaExplosion[i].m_vecExplosionPosition;
              vecStart.z = vecStart.z + 5.0;
              if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &v56, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
                p_z = &v56.m_vecPosition.z;
              gaExplosion[i].m_fGroundZ = *p_z;
            }
          }
        }
        if ( v53 < 1 )
          v25 = 0;
        else
          v25 = v1->m_cExplosionActive + 1;
        v1->m_cExplosionActive = v25;
        v26 = &gaExplosion[i];
        v27 = gaExplosion[i].m_fuelTime + (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        gaExplosion[i].m_fuelTime = v27;
        if ( (v5->m_eExplosionType & 0xFFFFFFFC) == 4 && v27 <= 0xC8 )
        {
          p_m_vecExplosionPosition = &gaExplosion[i].m_vecExplosionPosition;
          v29 = gaExplosion[i].m_fuelOffsetDist[0];
          if ( v29 > 0.0 )
          {
            v30 = *(_QWORD *)&p_m_vecExplosionPosition->x;
            v31 = gaExplosion[i].m_fuelSpeed[0];
            z = gaExplosion[i].m_fuelDir[0].z;
            v56.m_vecPosition.z = gaExplosion[i].m_vecExplosionPosition.z;
            *(_QWORD *)&v56.m_vecPosition.x = v30;
            v33 = v29 + (float)(v31 * (float)((float)v27 * 0.001));
            v34 = gaExplosion[i].m_fuelDir[0].y * v33;
            v56.m_vecPosition.x = (float)(gaExplosion[i].m_fuelDir[0].x * v33) + *(float *)&v30;
            v56.m_vecPosition.y = v34 + *((float *)&v30 + 1);
            v56.m_vecPosition.z = (float)(v33 * z) + v56.m_vecPosition.z;
            FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_fuel_car", &v56.m_vecPosition, 0, 0);
            if ( FxSystem )
              FxSystem_c::PlayAndKill(FxSystem);
          }
          v36 = gaExplosion[i].m_fuelOffsetDist[1];
          if ( v36 > 0.0 )
          {
            m_fuelTime = (float)v26->m_fuelTime;
            v38 = *(_QWORD *)&p_m_vecExplosionPosition->x;
            v56.m_vecPosition.z = gaExplosion[i].m_vecExplosionPosition.z;
            *(_QWORD *)&v56.m_vecPosition.x = v38;
            v39 = v36 + (float)(gaExplosion[i].m_fuelSpeed[1] * (float)(m_fuelTime * 0.001));
            v40 = gaExplosion[i].m_fuelDir[1].y * v39;
            v41 = gaExplosion[i].m_fuelDir[1].x * v39;
            v42 = v39 * gaExplosion[i].m_fuelDir[1].z;
            v56.m_vecPosition.x = v41 + *(float *)&v38;
            v56.m_vecPosition.y = v40 + *((float *)&v38 + 1);
            v56.m_vecPosition.z = v42 + v56.m_vecPosition.z;
            v43 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_fuel_car", &v56.m_vecPosition, 0, 0);
            if ( v43 )
              FxSystem_c::PlayAndKill(v43);
          }
          v44 = gaExplosion[i].m_fuelOffsetDist[2];
          if ( v44 > 0.0 )
          {
            v45 = (float)v26->m_fuelTime;
            v46 = *(_QWORD *)&p_m_vecExplosionPosition->x;
            v56.m_vecPosition.z = gaExplosion[i].m_vecExplosionPosition.z;
            *(_QWORD *)&v56.m_vecPosition.x = v46;
            v47 = v44 + (float)(gaExplosion[i].m_fuelSpeed[2] * (float)(v45 * 0.001));
            v48 = gaExplosion[i].m_fuelDir[2].y * v47;
            v49 = gaExplosion[i].m_fuelDir[2].x * v47;
            v50 = v47 * gaExplosion[i].m_fuelDir[2].z;
            v56.m_vecPosition.x = v49 + *(float *)&v46;
            v56.m_vecPosition.y = v48 + *((float *)&v46 + 1);
            v56.m_vecPosition.z = v50 + v56.m_vecPosition.z;
            v51 = FxManager_c::CreateFxSystem(&g_fxMan, "explosion_fuel_car", &v56.m_vecPosition, 0, 0);
            if ( v51 )
              FxSystem_c::PlayAndKill(v51);
          }
        }
      }
    }
  }
}
// 5D89DC: variables would overlap: ^0.12 and 0:r3.4,4:^0.8
// 5D8BDF: failed to expand linear variable kr10_8.8

//----- (005D90E4) --------------------------------------------------------
int __fastcall CExplosion::TestForExplosionInArea(
        Int32 TestExplosionType,
        float MinX,
        float MaxX,
        float MinY,
        float MaxY,
        float MinZ,
        float MaxZ)
{
  UInt8 *p_m_cExplosionActive; // r1
  int v10; // r2
  bool v12; // zf
  float v13; // s12
  float v14; // s12
  float v15; // s12

  p_m_cExplosionActive = &gaExplosion[0].m_cExplosionActive;
  v10 = -1;
  while ( 1 )
  {
    if ( *p_m_cExplosionActive )
    {
      v12 = TestExplosionType == -1;
      if ( TestExplosionType != -1 )
        v12 = *((_DWORD *)p_m_cExplosionActive - 10) == TestExplosionType;
      if ( v12 )
      {
        v13 = *((float *)p_m_cExplosionActive - 9);
        if ( v13 >= MinX && v13 <= MaxX )
        {
          v14 = *((float *)p_m_cExplosionActive - 8);
          if ( v14 >= MinY && v14 <= MaxY )
          {
            v15 = *((float *)p_m_cExplosionActive - 7);
            if ( v15 >= MinZ && v15 <= MaxZ )
              break;
          }
        }
      }
    }
    ++v10;
    p_m_cExplosionActive += 124;
    if ( v10 >= 15 )
      return 0;
  }
  return 1;
}

//----- (005D917C) --------------------------------------------------------
void __fastcall CExplosion::RemoveAllExplosionsInArea(CVector Centre, float Radius)
{
  float v2; // s0
  int i; // r3

  v2 = Radius * Radius;
  for ( i = 0; i != 16; ++i )
  {
    if ( gaExplosion[i].m_cExplosionActive )
    {
      if ( (float)((float)((float)((float)(Centre.x - gaExplosion[i].m_vecExplosionPosition.x)
                                 * (float)(Centre.x - gaExplosion[i].m_vecExplosionPosition.x))
                         + (float)((float)(Centre.y - gaExplosion[i].m_vecExplosionPosition.y)
                                 * (float)(Centre.y - gaExplosion[i].m_vecExplosionPosition.y)))
                 + (float)((float)(Centre.z - gaExplosion[i].m_vecExplosionPosition.z)
                         * (float)(Centre.z - gaExplosion[i].m_vecExplosionPosition.z))) < v2 )
        gaExplosion[i].m_cExplosionActive = 0;
    }
  }
}

//----- (005D9204) --------------------------------------------------------
void CProjectileInfo::Initialise()
{
  int v0; // r3
  CProjectileInfo *v1; // r2

  v0 = 0;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[28] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[30] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[24] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[26] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[20] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[22] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[16] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[18] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[12] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[14] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[8] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[10] = 0LL;
  *(_QWORD *)CProjectileInfo::ms_apProjectile = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[2] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[4] = 0LL;
  *(_QWORD *)&CProjectileInfo::ms_apProjectile[6] = 0LL;
  do
  {
    gaProjectileInfo[v0].m_eProjectileType = WEAPONTYPE_GRENADE;
    v1 = &gaProjectileInfo[v0++];
    v1->m_pEntProjectileOwner = 0;
    v1->m_fTimeExpires = 0;
    v1->m_bProjectileActive = 0;
    v1->m_fxSystem = 0;
  }
  while ( v0 != 32 );
}

//----- (005D9274) --------------------------------------------------------
void __fastcall CProjectileInfo::RemoveFXSystem(CProjectileInfo *this, bool8 instantly)
{
  int v3; // r2
  FxSystem_c *m_fxSystem; // r1

  v3 = instantly;
  m_fxSystem = this->m_fxSystem;
  if ( m_fxSystem )
  {
    if ( v3 )
      FxManager_c::DestroyFxSystem(&g_fxMan, m_fxSystem);
    else
      FxSystem_c::Kill(this->m_fxSystem);
    this->m_fxSystem = 0;
  }
}

//----- (005D92A4) --------------------------------------------------------
void CProjectileInfo::Shutdown()
{
  int i; // r5
  FxSystem_c *v1; // r1

  for ( i = 32; i != 1184; i += 36 )
  {
    v1 = *(FxSystem_c **)((char *)&gaProjectileInfo[0].m_eProjectileType + i);
    if ( v1 )
    {
      FxManager_c::DestroyFxSystem(&g_fxMan, v1);
      *(eWeaponType *)((char *)&gaProjectileInfo[0].m_eProjectileType + i) = WEAPONTYPE_UNARMED;
    }
  }
}

//----- (005D92F0) --------------------------------------------------------
CProjectileInfo *__fastcall CProjectileInfo::GetProjectileInfo(int32 i)
{
  return &gaProjectileInfo[i];
}

//----- (005D9304) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall CProjectileInfo::AddProjectile(
        CEntity *pEntProjOwner,
        eWeaponType ProjType,
        CVector vecInitialPosition,
        float ThrowForce,
        CVector *pFireDirn,
        CEntity *pTargetEntity)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d9
  float v8; // s20
  float v9; // s22
  float v10; // s16
  eWeaponType v11; // r5
  __int32 v12; // r9
  int v13; // r8
  RwReal y; // r6
  RwReal x; // r4
  int v17; // r1
  eWeaponType v18; // r1
  float v19; // r11
  float v20; // r5
  float v21; // s22
  uint32 v22; // r4
  CMatrix *m_pMat; // r0
  float m_heading; // s18
  int *v25; // r1
  CEntity::CEntityInfo m_info; // r2
  int v27; // r3
  float v28; // s18
  CMatrix *v29; // r1
  float v30; // s22
  CMatrix *v31; // r0
  float v32; // s16
  float v33; // r11
  float v34; // r5
  CMatrix *v35; // r0
  float v36; // s22
  float v37; // s20
  void *v38; // r1
  CEntity::CEntityInfo v39; // r2
  uint32 v40; // r11
  CMatrix *v41; // r1
  uint32 v42; // r3
  float v43; // r6
  float v44; // r0
  float v45; // s24
  float v46; // s28
  float v47; // s26
  float v48; // s20
  float v49; // r0
  float z; // s2
  uint32 v51; // r3
  float v52; // r8
  char *v53; // r0
  float v54; // r12
  __int64 v55; // kr00_8
  float v56; // r4
  __int64 v57; // d16
  CMatrix *v58; // r0
  __int64 v59; // d16
  float v60; // s24
  float v61; // s26
  float v62; // s28
  float v63; // r6
  float v64; // r0
  float v65; // s26
  float v66; // s24
  float v67; // s28
  float v68; // r4
  float v69; // r0
  uint32 v70; // r3
  CMatrix *v71; // r1
  uint32 v72; // r3
  CPlaceable **p_m_fxSystem; // r4
  float *v74; // r0
  int v75; // r1
  float *v76; // r11
  int v77; // r2
  eWeaponType v78; // r10
  int v79; // r3
  eWeaponType v80; // r9
  CProjectile *v81; // r6
  CWeaponInfo *WeaponInfo; // r0
  int m_nModelIndex; // r1
  CColModel *m_pColModel; // r6
  CCollisionData *m_pColData; // r5
  bool v86; // zf
  CColSphere *v87; // r0
  CWeaponInfo *v88; // r0
  CWeaponInfo *v89; // r0
  CPlaceable *v90; // r0
  CPlaceable *v91; // r0
  CMatrix *v92; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v94; // d16
  int (**v95)(void); // r0
  FxSystem_c *v96; // r0
  CMatrix *v97; // r1
  int v98; // r0
  bool v99; // zf
  unsigned int v100; // r6
  int32 v101; // r0
  UInt32 v102; // r1
  int v103; // r4
  CEntity *v105; // [sp+10h] [bp-C8h]
  eWeaponType v106; // [sp+14h] [bp-C4h]
  eWeaponType v107; // [sp+14h] [bp-C4h]
  int v108; // [sp+14h] [bp-C4h]
  uint32 v109; // [sp+18h] [bp-C0h]
  uint32 v110; // [sp+18h] [bp-C0h]
  int v111; // [sp+18h] [bp-C0h]
  CVector v; // [sp+1Ch] [bp-BCh] BYREF
  CVector v113; // [sp+28h] [bp-B0h] BYREF
  CMatrix m; // [sp+38h] [bp-A0h] BYREF

  v10 = 0.75;
  v11 = ProjType;
  v12 = ProjType - 16;
  v13 = 0;
  y = vecInitialPosition.y;
  x = vecInitialPosition.x;
  v17 = 2;
  m.m_pRwMat = 0;
  m.m_owner = 0;
  switch ( v12 )
  {
    case 0:
    case 23:
      v10 = 0.5;
      v18 = v11;
      v19 = vecInitialPosition.x;
      v20 = vecInitialPosition.y;
      v21 = (float)(ThrowForce * 0.22) + 0.15;
      if ( ThrowForce == 0.0 )
        v21 = 0.0;
      v106 = v18;
      if ( v18 == WEAPONTYPE_REMOTE_SATCHEL_CHARGE )
        v21 = v21 * 0.5;
      v22 = CTimer::m_snTimeInMilliseconds;
      m_pMat = pEntProjOwner->m_pMat;
      if ( m_pMat )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        m_heading = pEntProjOwner->m_transform.m_heading;
      if ( (*(_BYTE *)&pEntProjOwner->m_info & 7) == 2 )
        m_heading = CGeneral::LimitRadianAngle(m_heading + 3.1416);
      CMatrix::SetTranslate(&m, 0.0, 0.0, 0.0);
      v43 = m_heading;
      CMatrix::RotateZ(&m, m_heading);
      v44 = m_heading;
      v45 = m.tx + v19;
      v46 = m.tz + vecInitialPosition.z;
      v47 = m.ty + v20;
      v7.n64_f32[0] = (float)((float)(ThrowForce * 0.4) + 0.4) * v21;
      v48 = cosf(v44);
      v49 = sinf(v43);
      m.tx = v45;
      v8 = v21 * v48;
      m.ty = v47;
      m.tz = v46;
      if ( pEntProjOwner->m_nModelIndex == 405 )
      {
        v8 = v8 + pEntProjOwner[1].m_transform.m_heading;
        z = pEntProjOwner[1].m_transform.m_translate.z;
        v7.n64_f32[0] = v7.n64_f32[0] + *(float *)&pEntProjOwner[1].m_pMat;
      }
      else
      {
        z = -0.0;
      }
      v11 = v106;
      v51 = v22 + 2000;
      v9 = z - (float)(v21 * v49);
      v17 = 2;
      if ( v106 == WEAPONTYPE_REMOTE_SATCHEL_CHARGE )
        v10 = 0.03;
      v13 = 5;
      goto LABEL_56;
    case 1:
      v30 = (float)(ThrowForce * 0.22) + 0.15;
      if ( ThrowForce == 0.0 )
        v30 = 0.0;
      v31 = pEntProjOwner->m_pMat;
      v109 = CTimer::m_snTimeInMilliseconds + 20000;
      if ( v31 )
        v32 = atan2f(COERCE_FLOAT(LODWORD(v31->xy) ^ 0x80000000), v31->yy);
      else
        v32 = pEntProjOwner->m_transform.m_heading;
      CMatrix::SetTranslate(&m, 0.0, 0.0, 0.0);
      CMatrix::RotateZ(&m, v32);
      v60 = m.tz + vecInitialPosition.z;
      v61 = m.ty + y;
      v62 = m.tx + x;
      v63 = sinf(v32);
      v64 = cosf(v32);
      m.tx = v62;
      m.ty = v61;
      v10 = 0.5;
      m.tz = v60;
      v7.n64_f32[0] = (float)((float)(ThrowForce * 0.4) + 0.4) * v30;
      v17 = 2;
      v8 = v30 * v64;
      v13 = 5;
      v9 = -(float)(v30 * v63);
      goto LABEL_55;
    case 2:
      v33 = vecInitialPosition.x;
      v7.n64_u32[0] = 1045220557;
      v107 = v11;
      v34 = vecInitialPosition.y;
      v6.n64_f32[0] = (float)(ThrowForce * 0.22) + 0.15;
      v35 = pEntProjOwner->m_pMat;
      v110 = CTimer::m_snTimeInMilliseconds + 2000;
      LODWORD(v36) = vmax_f32(v6, v7).n64_u32[0];
      if ( v35 )
        v37 = atan2f(COERCE_FLOAT(LODWORD(v35->xy) ^ 0x80000000), v35->yy);
      else
        v37 = pEntProjOwner->m_transform.m_heading;
      v13 = 0;
      CMatrix::SetTranslate(&m, 0.0, 0.0, 0.0);
      CMatrix::RotateZ(&m, v37);
      v65 = m.ty + v34;
      v66 = m.tz + vecInitialPosition.z;
      v67 = m.tx + v33;
      v68 = sinf(v37);
      v69 = cosf(v37);
      m.tx = v67;
      m.ty = v65;
      m.tz = v66;
      v7.n64_f32[0] = (float)((float)(ThrowForce * 0.2) + 0.4) * v36;
      v8 = v36 * v69;
      v17 = 2;
      v9 = -(float)(v36 * v68);
      v11 = v107;
      v70 = v110;
      goto LABEL_56;
    case 3:
    case 4:
      v25 = dword_5D9C08;
      m_info = pEntProjOwner->m_info;
      if ( v11 == WEAPONTYPE_ROCKET )
        v25 = &dword_5D9C08[1];
      v27 = 10000;
      v28 = *(float *)v25;
      if ( v11 == WEAPONTYPE_ROCKET )
        v27 = 3000;
      v109 = CTimer::m_snTimeInMilliseconds + v27;
      if ( (*(_BYTE *)&m_info & 7) == 3 )
      {
        if ( CPed::IsPlayer((const CPed *)pEntProjOwner) )
        {
          v52 = x;
          v53 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
          v54 = *((float *)v53 + 184);
          *(_QWORD *)&m.xy = *((_QWORD *)v53 + 91);
          v55 = *(_QWORD *)(v53 + 764);
          v56 = *((float *)v53 + 193);
          m.zy = v54;
          *(_QWORD *)&m.xz = v55;
          m.zz = v56;
          CrossProduct(&v113, (const CVector *)(v53 + 764), (const CVector *)(v53 + 728));
          m.xx = v113.x;
          m.yx = v113.y;
          m.zx = v113.z;
LABEL_46:
          m.tx = v52;
          m.ty = y;
          m.tz = vecInitialPosition.z;
          goto LABEL_54;
        }
      }
      else if ( (*(_BYTE *)&m_info & 7) == 2 )
      {
        v29 = pEntProjOwner->m_pMat;
        if ( !v29 )
        {
          CPlaceable::AllocateMatrix(pEntProjOwner);
          CSimpleTransform::UpdateMatrix(&pEntProjOwner->m_transform, pEntProjOwner->m_pMat);
          v29 = pEntProjOwner->m_pMat;
        }
        CMatrix::operator=(&m, v29);
        m.tx = x;
        m.ty = y;
        m.tz = vecInitialPosition.z;
        v28 = v28
            + sqrtf(
                (float)((float)(pEntProjOwner[1].m_transform.m_translate.z * pEntProjOwner[1].m_transform.m_translate.z)
                      + (float)(pEntProjOwner[1].m_transform.m_heading * pEntProjOwner[1].m_transform.m_heading))
              + (float)(*(float *)&pEntProjOwner[1].m_pMat * *(float *)&pEntProjOwner[1].m_pMat));
        goto LABEL_54;
      }
      if ( pFireDirn )
      {
        v57 = *(_QWORD *)&pFireDirn->x;
        v52 = x;
        m.zy = pFireDirn->z;
        *(_QWORD *)&m.xy = v57;
        v58 = pEntProjOwner->m_pMat;
        if ( !v58 )
        {
          CPlaceable::AllocateMatrix(pEntProjOwner);
          CSimpleTransform::UpdateMatrix(&pEntProjOwner->m_transform, pEntProjOwner->m_pMat);
          v58 = pEntProjOwner->m_pMat;
        }
        v59 = *(_QWORD *)&v58->xx;
        m.zx = v58->zx;
        *(_QWORD *)&m.xx = v59;
        CrossProduct(&v113, (const CVector *)&m, (const CVector *)&m.xy);
        *(CVector *)&m.xz = v113;
        goto LABEL_46;
      }
      v71 = pEntProjOwner->m_pMat;
      if ( !v71 )
      {
        CPlaceable::AllocateMatrix(pEntProjOwner);
        CSimpleTransform::UpdateMatrix(&pEntProjOwner->m_transform, pEntProjOwner->m_pMat);
        v71 = pEntProjOwner->m_pMat;
      }
      CMatrix::operator=(&m, v71);
LABEL_54:
      v13 = 0;
      v.y = v28;
      v.x = 0.0;
      v.z = 0.0;
      Multiply3x3(&v113, &m, &v);
      v9 = v113.x;
      v17 = 0;
      v8 = v113.y;
      v7.n64_u32[0] = LODWORD(v113.z);
LABEL_55:
      v72 = v109;
LABEL_56:
      v108 = v17;
      p_m_fxSystem = (CPlaceable **)&gaProjectileInfo[31].m_fxSystem;
      v74 = &gaExplosion[15].m_fuelOffsetDist[1];
      v75 = 0;
      do
      {
        v76 = v74 + 9;
        ++p_m_fxSystem;
        v77 = v75 + 1;
        if ( v75 > 31 )
          break;
        ++v75;
        v86 = *((_BYTE *)v74 + 52) == 0;
        v74 += 9;
      }
      while ( !v86 );
      if ( v77 == 33 )
      {
LABEL_99:
        v103 = 0;
      }
      else
      {
        v105 = pEntProjOwner;
        v78 = v11;
        v111 = v79;
        switch ( v12 )
        {
          case 0:
          case 1:
          case 2:
          case 23:
            v80 = v11;
            v81 = (CProjectile *)CObject::operator new(0x184u);
            WeaponInfo = CWeaponInfo::GetWeaponInfo(v11, 1);
            CProjectile::CProjectile(v81, WeaponInfo->m_modelId);
            *p_m_fxSystem = v81;
            if ( v81 )
            {
              m_nModelIndex = v81->m_nModelIndex;
              m_pColModel = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel;
              m_pColData = m_pColModel->m_pColData;
              if ( m_pColData )
              {
                v86 = m_pColData->m_nNoOfSpheres == 0;
                if ( !m_pColData->m_nNoOfSpheres )
                  v86 = m_pColData->m_pSphereArray == 0;
                if ( v86 )
                {
                  m_pColData->m_nNoOfSpheres = 1;
                  v87 = (CColSphere *)CMemoryMgr::Malloc(0x14u);
                  m_pColData->m_pSphereArray = v87;
                  CColSphere::Set(
                    v87,
                    m_pColModel->m_sphereBound.m_fRadius * 0.75,
                    &m_pColModel->m_sphereBound.m_vecCentre,
                    0x38u,
                    0,
                    0xFFu);
                }
              }
              else
              {
                CColModel::AllocateData(CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel, 1, 0, 0, 0, 0, 0);
                CColSphere::Set(
                  m_pColModel->m_pColData->m_pSphereArray,
                  m_pColModel->m_sphereBound.m_fRadius * 0.75,
                  &m_pColModel->m_sphereBound.m_vecCentre,
                  0x38u,
                  0,
                  0xFFu);
              }
              goto LABEL_74;
            }
            goto LABEL_76;
          case 3:
          case 4:
            v80 = v11;
            v81 = (CProjectile *)CObject::operator new(0x184u);
            v88 = CWeaponInfo::GetWeaponInfo(v11, 1);
            CProjectile::CProjectile(v81, v88->m_modelId);
            *p_m_fxSystem = v81;
            goto LABEL_76;
          case 5:
            v81 = (CProjectile *)CObject::operator new(0x184u);
            v89 = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_FREEFALL_BOMB, 1);
            CProjectile::CProjectile(v81, v89->m_modelId);
            *p_m_fxSystem = v81;
            goto LABEL_75;
          case 42:
            v81 = (CProjectile *)CObject::operator new(0x184u);
            CProjectile::CProjectile(v81, MI_FLARE);
            *p_m_fxSystem = v81;
            if ( !v81 )
              goto LABEL_75;
            v81->m_fAirResistance = 0.9;
LABEL_74:
            v81 = (CProjectile *)*p_m_fxSystem;
LABEL_75:
            v80 = v78;
LABEL_76:
            if ( !v81 )
              goto LABEL_99;
            *(_DWORD *)v76 = v80;
            *((_DWORD *)v76 + 1) = v105;
            CEntity::RegisterReference(v105, (CEntity **)v76 + 1);
            CPlaceable::SetMatrix(*p_m_fxSystem, &m);
            v90 = *p_m_fxSystem;
            *(float *)&v90[3]._vptr$CPlaceable = v9;
            v90[3].m_transform.m_translate.x = v8;
            LODWORD(v90[3].m_transform.m_translate.y) = v7.n64_u32[0];
            (*p_m_fxSystem)[2].m_pMat = (CMatrix *)((int)(*p_m_fxSystem)[2].m_pMat & 0xFFFFFFFD | v108);
            *((_DWORD *)v76 + 3) = v111;
            (*p_m_fxSystem)[6].m_transform.m_heading = v10;
            if ( v13 == 5 )
              (*p_m_fxSystem)[14].m_pMat = (CMatrix *)&CObjectData::ms_aObjectInfo[4];
            *((_DWORD *)v76 + 2) = pTargetEntity;
            if ( pTargetEntity )
              CEntity::RegisterReference(pTargetEntity, (CEntity **)v76 + 2);
            *((_BYTE *)v76 + 16) = 1;
            CWorld::Add((CEntity *)*p_m_fxSystem);
            CEntity::RegisterReference((CEntity *)*p_m_fxSystem, (CEntity **)p_m_fxSystem);
            v91 = *p_m_fxSystem;
            v92 = (*p_m_fxSystem)->m_pMat;
            p_tx = (CSimpleTransform *)&v92->tx;
            if ( !v92 )
              p_tx = &v91->m_transform;
            v94 = *(_QWORD *)&p_tx->m_translate.x;
            v76[7] = p_tx->m_translate.z;
            *(_QWORD *)(v76 + 5) = v94;
            if ( v80 == WEAPONTYPE_TEARGAS )
            {
              memset(&v113, 0, sizeof(v113));
              v95 = v91[1]._vptr$CPlaceable;
              if ( v95 )
              {
                v96 = FxManager_c::CreateFxSystem(&g_fxMan, "teargasAD", &v113, (RwMatrix *)((char *)v95[1] + 16), 0);
                *((_DWORD *)v76 + 8) = v96;
                if ( v96 )
                  FxSystem_c::Play(v96);
              }
              v91 = *p_m_fxSystem;
            }
            v97 = v91[2].m_pMat;
            LODWORD(v91[12].m_transform.m_translate.z) = v105;
            v91[2].m_pMat = (CMatrix *)((unsigned int)v97 | 0x10000000);
            if ( v105 )
            {
              v98 = *(_BYTE *)&v105->m_info & 7;
              v99 = v98 == 2;
              if ( v98 != 2 )
                v99 = v98 == 3;
              if ( (v99 || v98 == 4) && !v105[5]._vptr$CPlaceable )
                v105[5]._vptr$CPlaceable = (int (**)(void))v105;
            }
            if ( v80 == WEAPONTYPE_ROCKET_HS )
            {
              v100 = CRadar::SetEntityBlip(
                       BLIPTYPE_OBJECT,
                       CPools::ms_pObjectPool->m_aFlags[-654471207
                                                      * (((char *)*p_m_fxSystem
                                                        - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)] | (-40904448 * (((char *)*p_m_fxSystem - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)),
                       0xFF0000FF,
                       BLIPDISPLAY_BLIPONLY,
                       (Char *)"CODEPRJ");
              CRadar::ChangeBlipScale(v100, 1);
              if ( FindPlayerPed(-1) == v105 || FindPlayerVehicle(-1, 0) == v105 )
              {
                v101 = v100;
                v102 = -1;
              }
              else
              {
                v101 = v100;
                v102 = -16776961;
              }
              CRadar::ChangeBlipColour(v101, v102);
            }
            CAudioEngine::ReportWeaponEvent(&AudioEngine, 148, v80, (CPhysical *)*p_m_fxSystem);
            v103 = 1;
            break;
          default:
            goto LABEL_74;
        }
      }
      CMatrix::~CMatrix(&m);
      return v103;
    case 5:
      v38 = &loc_1E8480;
      v39 = pEntProjOwner->m_info;
      goto LABEL_25;
    case 42:
      CStreaming::RequestModel(MI_FLARE, 0);
      v38 = elf_hash_bucket + 9748;
      v39 = pEntProjOwner->m_info;
LABEL_25:
      if ( (unsigned __int8)((*(_BYTE *)&v39 & 7) - 2) > 2u )
      {
        v9 = 0.0;
        v8 = 0.0;
        v7.n64_u32[0] = 0;
      }
      else
      {
        v9 = pEntProjOwner[1].m_transform.m_translate.z;
        v8 = pEntProjOwner[1].m_transform.m_heading;
        v7.n64_u32[0] = (unsigned __int32)pEntProjOwner[1].m_pMat;
      }
      v40 = (uint32)v38 + CTimer::m_snTimeInMilliseconds;
      v41 = pEntProjOwner->m_pMat;
      if ( !v41 )
      {
        CPlaceable::AllocateMatrix(pEntProjOwner);
        CSimpleTransform::UpdateMatrix(&pEntProjOwner->m_transform, pEntProjOwner->m_pMat);
        v41 = pEntProjOwner->m_pMat;
      }
      CMatrix::operator=(&m, v41);
      m.tx = x;
      v17 = 2;
      m.ty = y;
      v42 = v40;
      m.tz = vecInitialPosition.z;
      v13 = 0;
      goto LABEL_56;
    default:
      goto LABEL_56;
  }
}
// 5D9304: fragmented variable at 0:r2.8,8:^E0.4 may be wrong
// 5D9304: variables would overlap: 0:r2.8,8:^E0.4 and ^E0.4
// FC: using guessed type int elf_hash_bucket[16411];
// 5D9C08: using guessed type int dword_5D9C08[2];

//----- (005D9C54) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void CProjectileInfo::RemoveDetonatorProjectiles()
{
  unsigned int i; // r10
  int v1; // r0
  CProjectileInfo *v2; // r8
  CProjectile *v3; // r11
  CMatrix *m_pMat; // r1
  __int64 *p_tx; // r2
  __int64 v6; // kr00_8 OVERLAPPED
  char *v7; // r9
  FxSystem_c *v8; // r0
  __int64 v9; // [sp+0h] [bp-40h]

  for ( i = 0; i != 128; i += 4 )
  {
    v1 = 9 * i;
    v2 = &gaProjectileInfo[i / 4];
    if ( v2->m_bProjectileActive && gaProjectileInfo[i / 4].m_eProjectileType == WEAPONTYPE_REMOTE_SATCHEL_CHARGE )
    {
      v3 = CProjectileInfo::ms_apProjectile[i / 4];
      m_pMat = v3->m_pMat;
      p_tx = (__int64 *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = (__int64 *)&v3->m_transform;
      v6 = *p_tx;
      v7 = (char *)gaProjectileInfo + v1;
      v9 = *(__int64 *)((char *)p_tx + 4);
      CExplosion::AddExplosion(
        0,
        *(CEntity **)((char *)&gaProjectileInfo[0].m_pEntProjectileOwner + v1),
        EXP_TYPE_GRENADE,
        *(CVector *)&v6,
        0,
        1u,
        -1.0,
        0);
      v2->m_bProjectileActive = 0;
      v8 = (FxSystem_c *)*((_DWORD *)v7 + 8);
      if ( v8 )
      {
        FxSystem_c::Kill(v8);
        *((_DWORD *)v7 + 8) = 0;
      }
      *(_DWORD *)&v3->m_nFlags |= 0x800u;
    }
  }
}
// 5D9CA9: failed to expand linear variable kr00_8.8

//----- (005D9D18) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CProjectileInfo::RemoveProjectile(CProjectileInfo *pProjInfo, CProjectile *pProj)
{
  CMatrix *m_pMat; // r0
  float fCamShake; // r12
  CSimpleTransform *p_tx; // r2
  CMatrix *v7; // r0
  float v8; // r12
  CSimpleTransform *p_m_transform; // r2
  __int64 v10; // kr00_8 OVERLAPPED
  CEntity *m_pEntProjectileOwner; // r1
  CMatrix *v12; // r0
  CEntity *v13; // r8
  CPlayerPed *PlayerPed; // r0
  CMatrix *v15; // r2
  CSimpleTransform *v16; // r6
  RwReal x; // r3
  CSimpleTransform *v18; // r2
  FxSystem_c *m_fxSystem; // r0
  __int64 v20; // [sp+0h] [bp-28h]
  RwReal v21; // [sp+0h] [bp-28h]
  RwReal y; // [sp+0h] [bp-28h]
  RwReal v23; // [sp+4h] [bp-24h]
  RwReal z; // [sp+4h] [bp-24h]

  switch ( pProjInfo->m_eProjectileType )
  {
    case WEAPONTYPE_GRENADE:
    case WEAPONTYPE_FREEFALL_BOMB:
      m_pMat = pProj->m_pMat;
      LOWORD(fCamShake) = 0;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pProj->m_transform;
      HIWORD(fCamShake) = -16512;
      CExplosion::AddExplosion(
        0,
        pProjInfo->m_pEntProjectileOwner,
        EXP_TYPE_GRENADE,
        p_tx->m_translate,
        0,
        1u,
        fCamShake,
        0);
      break;
    case WEAPONTYPE_MOLOTOV:
      v7 = pProj->m_pMat;
      LOWORD(v8) = 0;
      p_m_transform = (CSimpleTransform *)&v7->tx;
      if ( !v7 )
        p_m_transform = &pProj->m_transform;
      v10 = *(_QWORD *)&p_m_transform->m_translate.x;
      HIWORD(v8) = -16512;
      v20 = *(_QWORD *)&p_m_transform->m_translate.y;
      CExplosion::AddExplosion(0, pProjInfo->m_pEntProjectileOwner, EXP_TYPE_MOLOTOV, *(CVector *)&v10, 0, 1u, v8, 0);
      if ( pProj )
        CAudioEngine::ReportObjectDestruction(&AudioEngine, pProj);
      break;
    case WEAPONTYPE_ROCKET:
      m_pEntProjectileOwner = pProjInfo->m_pEntProjectileOwner;
      if ( m_pEntProjectileOwner && (*(_BYTE *)&m_pEntProjectileOwner->m_info & 7) == 2 )
      {
        v12 = pProj->m_pMat;
        m_pEntProjectileOwner = (CEntity *)m_pEntProjectileOwner[18].m_pLastRenderedLink;
      }
      else
      {
        v12 = pProj->m_pMat;
      }
      v18 = (CSimpleTransform *)&v12->tx;
      if ( !v12 )
        v18 = &pProj->m_transform;
      x = v18->m_translate.x;
      y = v18->m_translate.y;
      z = v18->m_translate.z;
      goto LABEL_21;
    case WEAPONTYPE_ROCKET_HS:
      v13 = pProjInfo->m_pEntProjectileOwner;
      PlayerPed = FindPlayerPed(-1);
      v15 = pProj->m_pMat;
      m_pEntProjectileOwner = pProjInfo->m_pEntProjectileOwner;
      v16 = (CSimpleTransform *)&v15->tx;
      if ( !v15 )
        v16 = &pProj->m_transform;
      x = v16->m_translate.x;
      if ( v13 == PlayerPed )
      {
        y = v16->m_translate.y;
        z = v16->m_translate.z;
LABEL_21:
        CExplosion::AddExplosion(0, m_pEntProjectileOwner, EXP_TYPE_ROCKET, *(CVector *)&x, 0, 1u, -1.0, 0);
      }
      else
      {
        v21 = v16->m_translate.y;
        v23 = v16->m_translate.z;
        CExplosion::AddExplosion(0, m_pEntProjectileOwner, EXP_TYPE_ROCKET_WEAK, *(CVector *)&x, 0, 1u, -1.0, 0);
      }
      break;
    default:
      break;
  }
  m_fxSystem = pProjInfo->m_fxSystem;
  pProjInfo->m_bProjectileActive = 0;
  if ( m_fxSystem )
  {
    FxSystem_c::Kill(m_fxSystem);
    pProjInfo->m_fxSystem = 0;
  }
  CRadar::ClearBlipForEntity(
    BLIPTYPE_OBJECT,
    CPools::ms_pObjectPool->m_aFlags[-654471207 * (((char *)pProj - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)] | (-40904448 * (((char *)pProj - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)));
  CWorld::Remove(pProj);
  if ( pProj )
    (*((void (__fastcall **)(CProjectile *))pProj->_vptr$CPlaceable + 1))(pProj);
}
// 5D9D18: fragmented variable at r3.4 may be wrong
// 5D9D18: fragmented variable at ^0.4 may be wrong
// 5D9D18: fragmented variable at ^4.4 may be wrong
// 5D9D83: failed to expand linear variable kr00_8.8

//----- (005D9EB4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CProjectileInfo::RemoveNotAdd(CEntity *pProjOwner, eWeaponType ProjType, CVector vecPosn)
{
  RwReal x; // r12
  int v4; // r3
  CEntity *v5; // r1
  eExplosionType v6; // r2
  int v7; // r3
  int v8; // r3
  RwReal v9; // r3
  int v10; // [sp+0h] [bp-20h]
  RwReal z; // [sp+4h] [bp-1Ch]

  x = vecPosn.x;
  switch ( ProjType )
  {
    case WEAPONTYPE_REMOTE_SATCHEL_CHARGE:
      goto LABEL_4;
    case WEAPONTYPE_MOLOTOV:
      v10 = v7;
      z = vecPosn.z;
      v5 = pProjOwner;
      v6 = EXP_TYPE_MOLOTOV;
      break;
    case WEAPONTYPE_GRENADE:
LABEL_4:
      v10 = v4;
      z = vecPosn.z;
      v5 = pProjOwner;
      v6 = EXP_TYPE_GRENADE;
      break;
    default:
      if ( (unsigned int)(ProjType - 19) > 1 )
        return;
      v10 = v8;
      z = vecPosn.z;
      v5 = pProjOwner;
      v6 = EXP_TYPE_ROCKET;
      break;
  }
  v9 = x;
  CExplosion::AddExplosion(0, v5, v6, *(CVector *)(&v10 - 1), 0, 1u, -1.0, 0);
}
// 5D9EB4: fragmented variable at 0:r2.8,8:^28.4 may be wrong
// 5D9EB4: variables would overlap: 0:r2.8,8:^28.4 and ^28.4
// 5D9EB4: fragmented variable at ^0.4 may be wrong
// 5D9EB4: fragmented variable at ^4.4 may be wrong

//----- (005D9F38) --------------------------------------------------------
void CProjectileInfo::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d6
  float32x2_t v2; // d8
  int v3; // r8
  float v4; // s19
  int v5; // r10
  CProjectileInfo *v6; // r11
  CProjectile *v7; // r9
  CProjectileInfo *v8; // r4
  FxSystem_c *v9; // r0
  FxSystem_c **p_m_fxSystem; // r4
  FxSystem_c *m_fxSystem; // t1
  CProjectileInfo *v12; // r1
  CEntity *m_pEntProjectileOwner; // r0
  eWeaponType m_eProjectileType; // r0
  unsigned int v15; // r1
  CSimpleTransform *p_m_transform; // r5
  CMatrix *m_pMat; // r0
  float *p_x; // r2
  eWeaponType v19; // r0
  float v20; // s27
  float v21; // s23
  float v22; // s21
  int v23; // r10
  int i; // r4
  int v25; // r0
  float *p_tx; // r1
  float v27; // s2
  float v28; // s4
  float v29; // s0
  float v30; // s2
  CMatrix *v31; // r0
  RwReal v32; // s2
  RwReal v33; // s0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  __int64 v37; // d16
  CProjectileInfo *v38; // r4
  uint32 v39; // r1
  UInt32 *p_m_fTimeExpires; // r4
  uint32 m_fTimeExpires; // t1
  CPed *v42; // r6
  CMatrix *v43; // r0
  CSimpleTransform *v44; // r1
  __int64 v45; // d16
  CEntity *v46; // r0
  CEntity *v47; // r0
  CMatrix *v48; // r1
  CSimpleTransform *v49; // r2
  float32x2_t *v50; // r0
  float32x2_t v51; // d16
  unsigned __int64 v52; // d1
  float *p_xx; // r0
  float v54; // s4
  float v55; // s0
  float v56; // s2
  float v57; // s6
  float v58; // s6
  const CVector *p_m_translate; // r1
  CProjectileInfo *v60; // r0
  CVehicle *m_pTargetEntity; // r4
  float v62; // s23
  CMatrix *v63; // r0
  int v64; // r4
  __int64 v65; // d16
  CSimpleTransform *v66; // r1
  __int64 v67; // d16
  CEntity *v68; // r0
  float v69; // s21
  CProjectile *v70; // r5
  float32x2_t v71; // d9
  CProjectile *v72; // r6
  bool v73; // nf
  CVector *p_m_vecMoveSpeed; // r3
  CMatrix *v75; // r0
  CMatrix *v76; // r1
  CSimpleTransform *v77; // r2
  float *v78; // r0
  float32x2_t v79; // d16
  unsigned __int64 v80; // d1
  CEntity *v81; // r4
  CPlayerPed *PlayerPed; // r0
  _BOOL4 v83; // r6
  CEntity *v84; // r4
  CVehicle *PlayerVehicle; // r0
  CEntity *m_pDamageEntity; // r1
  CMatrix *v87; // r0
  const CVector *v88; // r1
  _BOOL4 v89; // r0
  CMatrix *v90; // r3
  RwReal x; // r2
  __int64 v92; // kr00_8
  CMatrix *v93; // r0
  CMatrix *v94; // r1
  float *v95; // r2
  float *v96; // r0
  float v97; // s11
  float v98; // s2
  float v99; // s4
  float v100; // s8
  float v101; // s10
  float v102; // s3
  float32x2_t v103; // d0
  float v104; // s14
  unsigned __int32 v105; // s18
  float v106; // s1
  float v107; // s5
  float v108; // s7
  float v109; // s12
  __int64 v110; // d16
  float v111; // s12
  CPlayerPed *v112; // r4
  CVehicle *v113; // r4
  float v114; // s0
  float v115; // s18
  float v116; // s2
  float v117; // s0
  float v118; // s12
  float v119; // s8
  float v120; // s0
  float v121; // s4
  float v122; // s2
  float v123; // s6
  float v124; // s6
  CMatrix *v125; // r0
  _BOOL4 IsLineOfSightClear; // r0
  CEntity *m_nNoOfCollisionRecords; // r0
  bool v128; // zf
  bool v129; // zf
  CMatrix *v130; // r0
  __int64 v131; // d16
  CProjectileInfo *v132; // r1
  CEntity **p_m_pTargetEntity; // [sp+7Ch] [bp-F4h]
  float *v134; // [sp+7Ch] [bp-F4h]
  CEntity **p_m_pEntProjectileOwner; // [sp+9Ch] [bp-D4h]
  float *v136; // [sp+A4h] [bp-CCh]
  CVector v137; // [sp+A8h] [bp-C8h] BYREF
  RwV3d_0 v138; // [sp+B8h] [bp-B8h] BYREF
  CVector v139; // [sp+C8h] [bp-A8h] BYREF
  CVector v140; // [sp+D4h] [bp-9Ch] BYREF
  RwV3d_0 pos; // [sp+E0h] [bp-90h] BYREF
  FxPrtMult_c fxMults; // [sp+F0h] [bp-80h] BYREF

  v2.n64_u32[0] = 1.5;
  v3 = 0;
  v4 = 0.000015259;
  do
  {
    v5 = v3;
    v6 = &gaProjectileInfo[v3];
    if ( v6->m_bProjectileActive )
    {
      v7 = CProjectileInfo::ms_apProjectile[v3];
      if ( *((unsigned __int8 *)&v7->m_nPhysicalFlags + 1) << 31 )
      {
        v8 = &gaProjectileInfo[v3];
        m_fxSystem = v8->m_fxSystem;
        p_m_fxSystem = &v8->m_fxSystem;
        v9 = m_fxSystem;
        if ( m_fxSystem )
        {
          FxSystem_c::Kill(v9);
          *p_m_fxSystem = 0;
        }
      }
      v12 = &gaProjectileInfo[v3];
      m_pEntProjectileOwner = v12->m_pEntProjectileOwner;
      p_m_pEntProjectileOwner = &v12->m_pEntProjectileOwner;
      if ( m_pEntProjectileOwner
        && (*(_BYTE *)&m_pEntProjectileOwner->m_info & 7) == 3
        && !CPed::IsPointerValid((CPed *)m_pEntProjectileOwner) )
      {
        *p_m_pEntProjectileOwner = 0;
      }
      m_eProjectileType = v6->m_eProjectileType;
      v15 = v6->m_eProjectileType - 16;
      if ( v15 <= 0x17
        && ((1 << v15) & 0x800003) != 0
        && v7->m_fElasticity > 0.1
        && fabsf(v7->m_vecMoveSpeed.x) < 0.05
        && fabsf(v7->m_vecMoveSpeed.y) < 0.05
        && fabsf(v7->m_vecMoveSpeed.z) < 0.05 )
      {
        v7->m_fElasticity = 0.03;
        m_eProjectileType = v6->m_eProjectileType;
      }
      p_m_transform = &v7->m_transform;
      if ( m_eProjectileType == WEAPONTYPE_TEARGAS
        && CTimer::m_snTimeInMilliseconds > gaProjectileInfo[v3].m_fTimeExpires - 17500
        && (int)(float)((float)((float)(unsigned __int16)rand() * v4) * 100.0) <= 9 )
      {
        m_pMat = v7->m_pMat;
        p_x = &v7->m_transform.m_translate.x;
        if ( m_pMat )
          p_x = &m_pMat->tx;
        CWorld::SetPedsChoking(*p_x, p_x[1], p_x[2], 6.0, *p_m_pEntProjectileOwner);
      }
      v19 = v6->m_eProjectileType;
      if ( (unsigned int)(v6->m_eProjectileType - 19) <= 1 )
      {
        FxPrtMult_c::FxPrtMult_c(&fxMults, 0.3, 0.3, 0.3, 0.3, 0.5, 1.0, 0.08);
        v20 = CTimer::ms_fTimeStep * v7->m_vecMoveSpeed.y;
        v21 = CTimer::ms_fTimeStep * v7->m_vecMoveSpeed.x;
        v22 = CTimer::ms_fTimeStep * v7->m_vecMoveSpeed.z;
        v23 = (int)sqrtf((float)((float)(v21 * v21) + (float)(v20 * v20)) + (float)(v22 * v22));
        if ( v23 <= 1 )
          v23 = 1;
        for ( i = 0; i < v23; ++i )
        {
          fxMults.m_blue = (float)((float)((float)rand() * 4.6566e-10) * 0.25) + 0.25;
          fxMults.m_green = fxMults.m_blue;
          fxMults.m_red = fxMults.m_blue;
          v25 = rand();
          p_tx = &v7->m_transform.m_translate.x;
          v27 = 1.0 - (float)((float)i / (float)v23);
          v28 = v20 * v27;
          fxMults.m_life = (float)((float)((float)v25 * 4.6566e-10) * 0.04) + 0.08;
          v29 = v22 * v27;
          v30 = v21 * v27;
          v31 = v7->m_pMat;
          if ( v31 )
            p_tx = &v31->tx;
          v32 = *p_tx - v30;
          v33 = p_tx[2] - v29;
          pos.y = p_tx[1] - v28;
          pos.x = v32;
          pos.z = v33;
          v34 = rand();
          v140.x = (float)((float)((float)v34 * 4.6566e-10) + (float)((float)v34 * 4.6566e-10)) + -1.0;
          v35 = rand();
          v140.y = (float)((float)((float)v35 * 4.6566e-10) + (float)((float)v35 * 4.6566e-10)) + -1.0;
          v36 = rand();
          v140.z = (float)((float)((float)v36 * 4.6566e-10) + (float)((float)v36 * 4.6566e-10)) + -1.0;
          CVector::Normalise(&v140);
          v37 = *(_QWORD *)&v7->m_vecMoveSpeed.x;
          v139.z = v7->m_vecMoveSpeed.z;
          *(_QWORD *)&v139.x = v37;
          CVector::Normalise(&v139);
          CrossProduct(&v137, &v139, &v140);
          v138.x = v137.x * 1.5;
          v138.y = v137.y * 1.5;
          v138.z = v137.z * 1.5;
          FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &pos, &v138, 0.0, &fxMults, -1.0, 1.2, 0.6, 0);
        }
        v6 = &gaProjectileInfo[v3];
        v19 = v6->m_eProjectileType;
        v5 = v3;
        p_m_transform = &v7->m_transform;
      }
      v38 = &gaProjectileInfo[v5];
      m_fTimeExpires = v38->m_fTimeExpires;
      p_m_fTimeExpires = &v38->m_fTimeExpires;
      v39 = m_fTimeExpires;
      if ( CTimer::m_snTimeInMilliseconds <= m_fTimeExpires || !v39 )
      {
        switch ( v19 )
        {
          case WEAPONTYPE_MOLOTOV:
          case WEAPONTYPE_FREEFALL_BOMB:
            v43 = v7->m_pMat;
            v44 = p_m_transform;
            if ( v43 )
              v44 = (CSimpleTransform *)&v43->tx;
            v45 = *(_QWORD *)&v44->m_translate.x;
            fxMults.m_blue = v44->m_translate.z;
            v46 = *p_m_pEntProjectileOwner;
            *(_QWORD *)&fxMults.m_red = v45;
            CWorld::pIgnoreEntity = v46;
            *(_DWORD *)&v7->m_nFlags &= ~1u;
            v47 = *p_m_pEntProjectileOwner;
            if ( !*p_m_pEntProjectileOwner )
              goto LABEL_132;
            v48 = v47->m_pMat;
            v49 = (CSimpleTransform *)&v48->tx;
            if ( !v48 )
              v49 = &v47->m_transform;
            v50 = (float32x2_t *)&gaProjectileInfo[v5];
            v51.n64_u64[0] = vsub_f32(v50[3], *(float32x2_t *)&v49->m_translate.y).n64_u64[0];
            v52 = vmul_f32(v51, v51).n64_u64[0];
            if ( (float)((float)((float)((float)(v50[2].n64_f32[1] - v49->m_translate.x)
                                       * (float)(v50[2].n64_f32[1] - v49->m_translate.x))
                               + *(float *)&v52)
                       + *((float *)&v52 + 1)) >= 2.0 )
            {
LABEL_132:
              if ( (*((_BYTE *)&v7->m_nPhysicalFlags + 1) & 2) != 0
                || !CWorld::GetIsLineOfSightClear(
                      &gaProjectileInfo[v5].OldCoors,
                      (const CVector *)&fxMults,
                      1,
                      1,
                      1,
                      1,
                      0,
                      0,
                      0) )
              {
                CProjectileInfo::RemoveProjectile(v6, v7);
              }
            }
            CWorld::pIgnoreEntity = 0;
            *(_DWORD *)&v7->m_nFlags |= 1u;
            goto LABEL_126;
          case WEAPONTYPE_ROCKET:
            p_xx = &v7->m_pMat->xx;
            v54 = (float)((float)(CTimer::ms_fTimeStep * 0.008) * p_xx[5]) + v7->m_vecMoveSpeed.y;
            v55 = (float)((float)(CTimer::ms_fTimeStep * 0.008) * p_xx[4]) + v7->m_vecMoveSpeed.x;
            v56 = (float)((float)(CTimer::ms_fTimeStep * 0.008) * p_xx[6]) + v7->m_vecMoveSpeed.z;
            v7->m_vecMoveSpeed.x = v55;
            v7->m_vecMoveSpeed.y = v54;
            v7->m_vecMoveSpeed.z = v56;
            v57 = sqrtf((float)(v56 * v56) + (float)((float)(v54 * v54) + (float)(v55 * v55)));
            if ( v57 > 9.9 )
            {
              v58 = 9.9 / v57;
              v7->m_vecMoveSpeed.x = v55 * v58;
              v7->m_vecMoveSpeed.y = v58 * v54;
              v7->m_vecMoveSpeed.z = v58 * v56;
            }
            if ( (*((_BYTE *)&v7->m_nPhysicalFlags + 1) & 2) != 0 )
              goto LABEL_119;
            CWorld::pIgnoreEntity = *p_m_pEntProjectileOwner;
            *(_DWORD *)&v7->m_nFlags &= ~1u;
            p_m_translate = &p_m_transform->m_translate;
            if ( p_xx )
              p_m_translate = (const CVector *)(p_xx + 12);
            goto LABEL_118;
          case WEAPONTYPE_ROCKET_HS:
            v60 = &gaProjectileInfo[v5];
            m_pTargetEntity = (CVehicle *)v60->m_pTargetEntity;
            p_m_pTargetEntity = &v60->m_pTargetEntity;
            if ( m_pTargetEntity )
            {
              v62 = v4;
              if ( m_pTargetEntity == FindPlayerVehicle(-1, 0) )
                CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 101, 0.0, 1.0);
              v63 = v7->m_pMat;
              v64 = 0;
              v65 = *(_QWORD *)&v63->xy;
              fxMults.m_blue = v63->zy;
              v66 = p_m_transform;
              *(_QWORD *)&fxMults.m_red = v65;
              v136 = &p_m_transform->m_translate.x;
              if ( v63 )
                v66 = (CSimpleTransform *)&v63->tx;
              v67 = *(_QWORD *)&v66->m_translate.x;
              pos.z = v66->m_translate.z;
              *(_QWORD *)&pos.x = v67;
              v68 = *p_m_pTargetEntity;
              pos.z = fxMults.m_blue + pos.z;
              pos.y = fxMults.m_green + *((float *)&v67 + 1);
              pos.x = fxMults.m_red + *(float *)&v67;
              v0.n64_u32[0] = 0;
              v69 = CWeapon::EvaluateTargetForHeatSeekingMissile(v68, (CVector *)&pos, (CVector *)&fxMults, 1.2, 1, 0);
              v70 = 0;
              v71.n64_u64[0] = v0.n64_u64[0];
              do
              {
                if ( gaProjectileInfo[v64].m_eProjectileType == WEAPONTYPE_FLARE
                  && gaProjectileInfo[v64].m_bProjectileActive )
                {
                  v72 = CProjectileInfo::ms_apProjectile[v64];
                  v0.n64_u32[0] = CWeapon::EvaluateTargetForHeatSeekingMissile(
                                    v72,
                                    (CVector *)&pos,
                                    (CVector *)&fxMults,
                                    1.2,
                                    1,
                                    0);
                  v73 = v0.n64_f32[0] < v71.n64_f32[0];
                  v71.n64_u64[0] = vmax_f32(v0, v71).n64_u64[0];
                  if ( !v73 )
                    v70 = v72;
                }
                ++v64;
              }
              while ( v64 != 32 );
              if ( !v70 || v71.n64_f32[0] <= v69 )
                v70 = (CProjectile *)*p_m_pTargetEntity;
              p_m_vecMoveSpeed = &v7->m_vecMoveSpeed;
              v134 = (float *)v70;
              if ( (*(_BYTE *)&v70->m_info & 7) == 2 )
              {
                if ( FindPlayerVehicle(-1, 0) == (CVehicle *)v70 )
                {
                  v75 = v70->m_pMat;
                  v76 = v7->m_pMat;
                  v77 = (CSimpleTransform *)&v75->tx;
                  if ( !v75 )
                    v77 = &v70->m_transform;
                  v78 = v136;
                  if ( v76 )
                    v78 = &v76->tx;
                  v79.n64_u64[0] = vsub_f32(*(float32x2_t *)(v78 + 1), *(float32x2_t *)&v77->m_translate.y).n64_u64[0];
                  v80 = vmul_f32(v79, v79).n64_u64[0];
                  if ( sqrtf(
                         (float)((float)((float)(*v78 - v77->m_translate.x) * (float)(*v78 - v77->m_translate.x))
                               + *(float *)&v80)
                       + *((float *)&v80 + 1)) < 42.0 )
                    LOBYTE(v70[3].m_vecMoveSpeed.y) = 1;
                }
                v81 = *p_m_pEntProjectileOwner;
                PlayerPed = FindPlayerPed(-1);
                p_m_vecMoveSpeed = &v7->m_vecMoveSpeed;
                if ( v81 == PlayerPed
                  || (v83 = 0,
                      v84 = *p_m_pEntProjectileOwner,
                      PlayerVehicle = FindPlayerVehicle(-1, 0),
                      p_m_vecMoveSpeed = &v7->m_vecMoveSpeed,
                      v84 == PlayerVehicle) )
                {
                  v83 = LODWORD(v70[3].m_vecAttachTiltOffset.z) == 4;
                }
              }
              else
              {
                v83 = 0;
              }
              v93 = v70->m_pMat;
              v94 = v7->m_pMat;
              v95 = &v93->tx;
              if ( !v93 )
                v95 = &v70->m_transform.m_translate.x;
              v96 = v136;
              v97 = *v95;
              v98 = v95[1];
              v99 = v95[2];
              if ( v94 )
                v96 = &v94->tx;
              v100 = v96[1];
              v101 = v96[2];
              v102 = (float)(v7->m_vecMoveSpeed.z * 100.0) + v101;
              v103.n64_u32[1] = LODWORD(v7->m_vecMoveSpeed.y);
              v103.n64_u32[0] = 1112014848;
              v104 = (float)(v7->m_vecMoveSpeed.x * 100.0) + *v96;
              v1.n64_f32[0] = sqrtf(
                                (float)((float)((float)(*v96 - v97) * (float)(*v96 - v97))
                                      + (float)((float)(v100 - v98) * (float)(v100 - v98)))
                              + (float)((float)(v101 - v99) * (float)(v101 - v99)));
              v105 = vmin_f32(v1, v2).n64_u32[0];
              v1.n64_u64[0] = vmin_f32(v1, v103).n64_u64[0];
              if ( v83 )
                v1.n64_u32[0] = v105;
              v106 = (float)(v103.n64_f32[1] * 100.0) + v100;
              v107 = v70->m_vecMoveSpeed.x * v1.n64_f32[0];
              v108 = v70->m_vecMoveSpeed.y * v1.n64_f32[0];
              v109 = v70->m_vecMoveSpeed.z * v1.n64_f32[0];
              if ( v83 )
              {
                v106 = v96[1];
                v104 = *v96;
                v102 = v96[2];
              }
              v140.y = (float)(v98 + v108) - v106;
              v140.x = (float)(v97 + v107) - v104;
              v140.z = (float)(v99 + v109) - v102;
              v110 = *(_QWORD *)&p_m_vecMoveSpeed->x;
              v139.z = p_m_vecMoveSpeed->z;
              *(_QWORD *)&v139.x = v110;
              CVector::Normalise(&v139);
              v0.n64_f32[1] = v139.z * v140.z;
              v111 = (float)((float)(v139.x * v140.x) + (float)(v139.y * v140.y)) + (float)(v139.z * v140.z);
              if ( v111 < 0.0 )
              {
                v140.y = v140.y - (float)(v139.y * v111);
                v140.x = v140.x - (float)(v139.x * v111);
                v140.z = v140.z - (float)(v139.z * v111);
              }
              CVector::Normalise(&v140);
              v112 = (CPlayerPed *)*p_m_pEntProjectileOwner;
              v4 = v62;
              if ( v112 == FindPlayerPed(-1) )
              {
                v114 = 0.0117;
              }
              else
              {
                v113 = (CVehicle *)*p_m_pEntProjectileOwner;
                v114 = 0.009;
                if ( v113 == FindPlayerVehicle(-1, 0) )
                  v114 = 0.0117;
              }
              p_m_transform = (CSimpleTransform *)v136;
              if ( v83 )
              {
                v115 = CTimer::ms_fTimeStep;
                v116 = powf(0.95, CTimer::ms_fTimeStep);
                v114 = 0.15;
              }
              else
              {
                v116 = 1.0;
                if ( sqrtf(
                       (float)((float)(v134[18] * v134[18]) + (float)(v134[19] * v134[19]))
                     + (float)(v134[20] * v134[20])) > 0.8 )
                  v114 = v114 * 1.2;
                v115 = CTimer::ms_fTimeStep;
              }
              v117 = v114 * v115;
              v118 = v117 * v140.y;
              v119 = v117 * v140.z;
              v120 = (float)(v140.x * v117) + (float)(v116 * v7->m_vecMoveSpeed.x);
              v121 = v118 + (float)(v116 * v7->m_vecMoveSpeed.y);
              v122 = v119 + (float)(v116 * v7->m_vecMoveSpeed.z);
              v7->m_vecMoveSpeed.x = v120;
              v7->m_vecMoveSpeed.y = v121;
              v7->m_vecMoveSpeed.z = v122;
              v123 = sqrtf((float)(v122 * v122) + (float)((float)(v121 * v121) + (float)(v120 * v120)));
              if ( v123 > 9.9 )
              {
                v124 = 9.9 / v123;
                v7->m_vecMoveSpeed.x = v120 * v124;
                v7->m_vecMoveSpeed.y = v124 * v121;
                v7->m_vecMoveSpeed.z = v124 * v122;
              }
              *(CVector *)&v7->m_pMat->xy = v139;
            }
            if ( (*((_BYTE *)&v7->m_nPhysicalFlags + 1) & 2) == 0 )
            {
              CWorld::pIgnoreEntity = *p_m_pEntProjectileOwner;
              v125 = v7->m_pMat;
              *(_DWORD *)&v7->m_nFlags &= ~1u;
              p_m_translate = &p_m_transform->m_translate;
              if ( v125 )
                p_m_translate = (const CVector *)&v125->tx;
LABEL_118:
              IsLineOfSightClear = CWorld::GetIsLineOfSightClear(
                                     &gaProjectileInfo[v5].OldCoors,
                                     p_m_translate,
                                     1,
                                     1,
                                     1,
                                     1,
                                     0,
                                     0,
                                     0);
              CWorld::pIgnoreEntity = 0;
              *(_DWORD *)&v7->m_nFlags |= 1u;
              v7->m_pNOCollisionVehicle = *p_m_pEntProjectileOwner;
              if ( IsLineOfSightClear )
                goto LABEL_126;
            }
LABEL_119:
            m_nNoOfCollisionRecords = (CEntity *)v7->m_nNoOfCollisionRecords;
            v128 = m_nNoOfCollisionRecords == 0;
            if ( v7->m_nNoOfCollisionRecords )
            {
              m_nNoOfCollisionRecords = v7->m_aCollisionRecordPtrs[0];
              v128 = m_nNoOfCollisionRecords == 0;
            }
            if ( v128 )
              goto LABEL_125;
            v129 = m_nNoOfCollisionRecords == *p_m_pEntProjectileOwner;
            if ( m_nNoOfCollisionRecords != *p_m_pEntProjectileOwner )
              v129 = m_nNoOfCollisionRecords->m_nModelIndex == 345;
            if ( !v129 )
              goto LABEL_125;
            goto LABEL_126;
          case WEAPONTYPE_REMOTE_SATCHEL_CHARGE:
            if ( v7->m_fDamageImpulseMagnitude > 0.0 )
            {
              m_pDamageEntity = v7->m_pDamageEntity;
              if ( m_pDamageEntity )
              {
                if ( !v7->m_pAttachToEntity )
                {
                  CPhysical::AttachEntityToEntity(v7, m_pDamageEntity, 0, 0);
                  *(_DWORD *)&v7->m_nFlags &= ~1u;
                }
              }
            }
            goto LABEL_126;
          case WEAPONTYPE_FLARE:
            *(_DWORD *)&v7->m_nFlags &= ~1u;
            CWorld::pIgnoreEntity = *p_m_pEntProjectileOwner;
            v87 = v7->m_pMat;
            v88 = &p_m_transform->m_translate;
            if ( v87 )
              v88 = (const CVector *)&v87->tx;
            v89 = CWorld::GetIsLineOfSightClear(&gaProjectileInfo[v5].OldCoors, v88, 1, 1, 1, 1, 0, 0, 0);
            *(_DWORD *)&v7->m_nFlags |= 1u;
            CWorld::pIgnoreEntity = 0;
            if ( !v89 )
            {
              v7->m_vecMoveSpeed.x = 0.0;
              v7->m_vecMoveSpeed.y = 0.0;
              v7->m_vecMoveSpeed.z = 0.0;
              v90 = v7->m_pMat;
              x = gaProjectileInfo[v5].OldCoors.x;
              v92 = *(_QWORD *)&gaProjectileInfo[v5].OldCoors.y;
              if ( v90 )
              {
                v90->tx = x;
                *(_QWORD *)&v7->m_pMat->ty = v92;
              }
              else
              {
                v7->m_transform.m_translate.x = x;
                *(_QWORD *)&v7->m_transform.m_translate.y = v92;
              }
            }
            goto LABEL_126;
          default:
            goto LABEL_126;
        }
      }
      if ( v19 == WEAPONTYPE_REMOTE_SATCHEL_CHARGE )
      {
        if ( (*(_BYTE *)&(*p_m_pEntProjectileOwner)->m_info & 7) == 3
          && CPed::IsPlayer((const CPed *)*p_m_pEntProjectileOwner) )
        {
          v42 = (CPed *)*p_m_pEntProjectileOwner;
          if ( v42->m_WeaponSlots[CPed::GetWeaponSlot((CPed *)*p_m_pEntProjectileOwner, WEAPONTYPE_DETONATOR)].m_eWeaponType != WEAPONTYPE_DETONATOR
            || !v42->m_WeaponSlots[CPed::GetWeaponSlot(v42, WEAPONTYPE_DETONATOR)].m_nAmmoTotal )
          {
            *p_m_fTimeExpires = 0;
          }
        }
      }
      else
      {
LABEL_125:
        CProjectileInfo::RemoveProjectile(v6, v7);
      }
LABEL_126:
      v130 = v7->m_pMat;
      if ( v130 )
        p_m_transform = (CSimpleTransform *)&v130->tx;
      v131 = *(_QWORD *)&p_m_transform->m_translate.x;
      v132 = &gaProjectileInfo[v5];
      v132->OldCoors.z = p_m_transform->m_translate.z;
      *(_QWORD *)&v132->OldCoors.x = v131;
    }
    ++v3;
  }
  while ( v3 != 32 );
}
// 5DA2A4: conditional instruction was optimized away because r10.4>=1
// 5DA744: variable 'v0' is possibly undefined
// 5DA9C6: variable 'v1' is possibly undefined
// 5DA9C6: variable 'v2' is possibly undefined

//----- (005DAD48) --------------------------------------------------------
int __fastcall CProjectileInfo::IsProjectileInRange(
        float MinX,
        float MaxX,
        float MinY,
        float MaxY,
        float MinZ,
        float MaxZ,
        int bRemoveThem)
{
  unsigned int v11; // r11
  char v12; // r12
  int v13; // r1
  CProjectileInfo *v14; // r2
  CProjectile *v15; // r4
  CMatrix *m_pMat; // r0
  float *p_tx; // r3
  float v18; // s0
  float v19; // s0
  char v20; // r3
  int v21; // r0
  char *v22; // r8
  FxSystem_c *v23; // r0

  v11 = 0;
  v12 = 0;
  do
  {
    v13 = 9 * v11;
    v14 = &gaProjectileInfo[v11 / 4];
    if ( v14->m_bProjectileActive && (unsigned int)(gaProjectileInfo[v11 / 4].m_eProjectileType - 16) <= 4 )
    {
      v15 = CProjectileInfo::ms_apProjectile[v11 / 4];
      m_pMat = v15->m_pMat;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v15->m_transform.m_translate.x;
      if ( *p_tx >= MinX && *p_tx <= MaxX )
      {
        v18 = p_tx[1];
        if ( v18 >= MinY && v18 <= MaxY )
        {
          v19 = p_tx[2];
          if ( v19 >= MinZ )
          {
            v20 = 0;
            v21 = 0;
            if ( v19 > MaxZ )
              v21 = 1;
            else
              v20 = 1;
            if ( v21 | bRemoveThem ^ 1 )
            {
              v12 |= v20;
            }
            else
            {
              v14->m_bProjectileActive = 0;
              v22 = (char *)gaProjectileInfo + v13;
              v23 = *(FxSystem_c **)((char *)&gaProjectileInfo[0].m_fxSystem + v13);
              if ( v23 )
              {
                FxSystem_c::Kill(v23);
                *((_DWORD *)v22 + 8) = 0;
              }
              CRadar::ClearBlipForEntity(
                BLIPTYPE_OBJECT,
                CPools::ms_pObjectPool->m_aFlags[-654471207
                                               * (((char *)v15 - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)] | (-40904448 * (((char *)v15 - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)));
              CWorld::Remove(v15);
              (*((void (__fastcall **)(CProjectile *))v15->_vptr$CPlaceable + 1))(v15);
              v12 = 1;
            }
          }
        }
      }
    }
    v11 += 4;
  }
  while ( v11 != 128 );
  return v12 & 1;
}

//----- (005DAEAC) --------------------------------------------------------
void CProjectileInfo::RemoveAllProjectiles()
{
  unsigned int i; // r8
  int v1; // r0
  CProjectileInfo *v2; // r1
  char *v3; // r9
  FxSystem_c *v4; // r1
  CProjectile *v5; // r5

  for ( i = 0; i != 128; i += 4 )
  {
    v1 = 9 * i;
    v2 = &gaProjectileInfo[i / 4];
    if ( v2->m_bProjectileActive )
    {
      v3 = (char *)gaProjectileInfo + v1;
      v2->m_bProjectileActive = 0;
      v4 = *(FxSystem_c **)((char *)&gaProjectileInfo[0].m_fxSystem + v1);
      v5 = CProjectileInfo::ms_apProjectile[i / 4];
      if ( v4 )
      {
        FxManager_c::DestroyFxSystem(&g_fxMan, v4);
        *((_DWORD *)v3 + 8) = 0;
      }
      CRadar::ClearBlipForEntity(
        BLIPTYPE_OBJECT,
        CPools::ms_pObjectPool->m_aFlags[-654471207 * (((char *)v5 - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)] | (-40904448 * (((char *)v5 - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)));
      CWorld::Remove(v5);
      if ( v5 )
        (*((void (__fastcall **)(CProjectile *))v5->_vptr$CPlaceable + 1))(v5);
    }
  }
}

//----- (005DAF68) --------------------------------------------------------
bool __fastcall CProjectileInfo::RemoveIfThisIsAProjectile(CObject *pObject)
{
  int v1; // r4
  bool *i; // r5
  CProjectile *v3; // r1
  FxSystem_c *v6; // r0
  CProjectile *v7; // r0

  v1 = 0;
  for ( i = &gaProjectileInfo[0].m_bProjectileActive; ; i += 36 )
  {
    v3 = CProjectileInfo::ms_apProjectile[v1];
    if ( v3 == pObject && *i )
      break;
    if ( v1++ >= 31 )
      return 0;
  }
  *i = 0;
  v6 = (FxSystem_c *)*((_DWORD *)i + 4);
  if ( v6 )
  {
    FxSystem_c::Kill(v6);
    *((_DWORD *)i + 4) = 0;
    v3 = CProjectileInfo::ms_apProjectile[v1];
  }
  CRadar::ClearBlipForEntity(
    BLIPTYPE_OBJECT,
    CPools::ms_pObjectPool->m_aFlags[-654471207 * (((char *)v3 - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)] | (-40904448 * (((char *)v3 - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)));
  CWorld::Remove(CProjectileInfo::ms_apProjectile[v1]);
  v7 = CProjectileInfo::ms_apProjectile[v1];
  if ( v7 )
    (*((void (__fastcall **)(CProjectile *))v7->_vptr$CPlaceable + 1))(v7);
  CProjectileInfo::ms_apProjectile[v1] = 0;
  return 1;
}

//----- (005DB030) --------------------------------------------------------
void CShotInfo::Initialise()
{
  int v0; // r1
  bool *p_m_bSprayPaintDone; // r0
  bool *v2; // r2

  v0 = 100;
  p_m_bSprayPaintDone = &gaShotInfo[0].m_bSprayPaintDone;
  do
  {
    *(_DWORD *)(p_m_bSprayPaintDone - 41) = 22;
    v2 = p_m_bSprayPaintDone - 37;
    *(_WORD *)(p_m_bSprayPaintDone - 1) = 0;
    --v0;
    *(_DWORD *)(p_m_bSprayPaintDone - 21) = 0;
    *(_DWORD *)(p_m_bSprayPaintDone - 17) = 0;
    *(_DWORD *)(p_m_bSprayPaintDone - 13) = 1065353216;
    *(_DWORD *)(p_m_bSprayPaintDone - 9) = 0;
    *(_DWORD *)(p_m_bSprayPaintDone - 5) = 0;
    p_m_bSprayPaintDone += 44;
    *(_QWORD *)v2 = 0LL;
    *((_QWORD *)v2 + 1) = 0LL;
  }
  while ( v0 );
  *(_QWORD *)CShotInfo::ms_afRandTable = loc_5DB0C0;
  *(_QWORD *)&CShotInfo::ms_afRandTable[2] = 0xBD0F5C2ABD23D70BLL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[4] = 0xBCCCCCD0BCF5C292LL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[6] = 0xBC75C297BCA3D70ELL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[8] = 0xBBA3D71ABC23D712LL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[10] = 0x3BA3D6FAB2000000LL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[12] = 0x3C75C2873C23D702LL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[14] = 0x3CCCCCC83CA3D706LL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[16] = 0x3D0F5C263CF5C28ALL;
  *(_QWORD *)&CShotInfo::ms_afRandTable[18] = 0x3D3851E83D23D707LL;
}

//----- (005DB11C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall CShotInfo::AddShot(
        CEntity *pEntShotOwner,
        eWeaponType eShotType,
        CVector vecInitialPosition,
        CVector vecTargetPosition)
{
  float y; // r10
  float x; // r11
  CWeaponInfo *WeaponInfo; // r9
  CProjectile **v9; // r6
  int v10; // r1
  CProjectile **v11; // r4
  int v12; // r2
  int v13; // r1
  bool v14; // zf
  int result; // r0
  float m_fSpeed; // s0
  float v17; // s6
  float v18; // s2
  float v19; // s4

  y = vecInitialPosition.y;
  x = vecInitialPosition.x;
  WeaponInfo = CWeaponInfo::GetWeaponInfo(eShotType, 1);
  v9 = &CProjectileInfo::ms_apProjectile[21];
  v10 = 0;
  do
  {
    v11 = v9 + 11;
    v12 = v10 + 1;
    if ( v10 > 99 )
      break;
    v13 = *((unsigned __int8 *)v9 + 84);
    v9 += 11;
    v14 = v13 == 0;
    v10 = v12;
  }
  while ( !v14 );
  if ( v12 == 101 )
    return 0;
  *((_WORD *)v11 + 20) = 1;
  *v11 = (CProjectile *)eShotType;
  *((float *)v11 + 1) = x;
  *((float *)v11 + 2) = y;
  v11[3] = (CProjectile *)LODWORD(vecInitialPosition.z);
  *((float *)v11 + 4) = vecTargetPosition.x - x;
  *((float *)v11 + 5) = vecTargetPosition.y - y;
  *((float *)v11 + 6) = vecTargetPosition.z - vecInitialPosition.z;
  v11[7] = (CProjectile *)LODWORD(WeaponInfo->m_fRadius);
  if ( WeaponInfo->m_fSpread != 0.0 )
  {
    *((float *)v11 + 4) = *((float *)v11 + 4) + (float)(CShotInfo::ms_afRandTable[rand() % 20] * WeaponInfo->m_fSpread);
    *((float *)v11 + 5) = *((float *)v11 + 5) + (float)(CShotInfo::ms_afRandTable[rand() % 20] * WeaponInfo->m_fSpread);
    *((float *)v11 + 6) = CShotInfo::ms_afRandTable[rand() % 20] + *((float *)v11 + 6);
  }
  CVector::Normalise((CVector *)(v11 + 4));
  if ( (WeaponInfo->m_nFlags & 0x20000) != 0 )
    m_fSpeed = WeaponInfo->m_fSpeed + CShotInfo::ms_afRandTable[rand() % 20];
  else
    m_fSpeed = WeaponInfo->m_fSpeed;
  v17 = *((float *)v11 + 6);
  v18 = m_fSpeed * *((float *)v11 + 4);
  v19 = m_fSpeed * *((float *)v11 + 5);
  v11[8] = (CProjectile *)pEntShotOwner;
  *((float *)v11 + 4) = v18;
  *((float *)v11 + 5) = v19;
  *((float *)v11 + 6) = m_fSpeed * v17;
  result = 1;
  *((float *)v11 + 9) = (float)(int)(float)(WeaponInfo->m_fLifeSpan + (float)CTimer::m_snTimeInMilliseconds);
  return result;
}
// 5DB11C: fragmented variable at 0:r2.8,8:^28.4 may be wrong
// 5DB11C: variables would overlap: 0:r2.8,8:^28.4 and ^28.4

//----- (005DB308) --------------------------------------------------------
void CShotInfo::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d9
  int i; // r11
  CShotInfo *v3; // r6
  CEntity *v4; // r0
  CEntity **p_m_pEntShotOwner; // r6
  CEntity *m_pEntShotOwner; // t1
  CShotInfo *v7; // r5
  bool *p_m_bShotActive; // r5
  _BOOL4 m_bShotActive; // t1
  int32 m_nFlags; // r4
  CShotInfo *v11; // r5
  float x; // s22
  float y; // s24
  float z; // s26
  float v15; // r0
  float v16; // s0
  CShotInfo *v17; // r8
  float v18; // s12
  float v19; // s10
  float v20; // s4
  float v21; // s6
  CEntity *v22; // r0
  CShotInfo *v23; // r6
  RwReal v24; // r4
  CShotInfo *v25; // r1
  int v26; // r0
  float v27; // s22
  int v28; // r9
  int v29; // r10
  int v30; // r1
  float *v31; // r5
  int v32; // r0
  float v33; // s26
  float32x2_t v34; // d15
  float v35; // s24
  float32x2_t v36; // d14
  float32x2_t v37; // d16
  unsigned __int64 v38; // d1
  int v39; // r1
  CMatrix *m_pMat; // r2
  float v41; // s0
  float *p_tx; // r1
  float v43; // s4
  int32 LocalDirection; // r0
  CShotInfo *v45; // r4
  bool *v46; // r4
  _BOOL4 v47; // t1
  int v48; // r0
  float v49; // s8
  float v50; // s6
  float v51; // s14
  float v52; // s10
  RwReal v53; // s2
  RwReal v54; // s4
  CPlayerPed *v55; // r4
  CShotInfo *v56; // r4
  bool *v57; // r4
  _BOOL4 m_bSprayPaintDone; // t1
  bool *p_m_bSprayPaintDone; // [sp+20h] [bp-90h]
  CWeaponInfo *WeaponInfo; // [sp+2Ch] [bp-84h]
  RwReal *p_z; // [sp+30h] [bp-80h]
  CEntity **v62; // [sp+34h] [bp-7Ch]
  RwReal *p_y; // [sp+3Ch] [bp-74h]
  CVector *vecPos; // [sp+40h] [bp-70h]
  CVector v65[9]; // [sp+44h] [bp-6Ch] BYREF
  CVector v66; // 0:r1.12

  v1.n64_u32[0] = 1.0;
  for ( i = 0; i != 100; ++i )
  {
    v3 = &gaShotInfo[i];
    m_pEntShotOwner = v3->m_pEntShotOwner;
    p_m_pEntShotOwner = &v3->m_pEntShotOwner;
    v4 = m_pEntShotOwner;
    if ( m_pEntShotOwner && (*(_BYTE *)&v4->m_info & 7) == 3 && !CPed::IsPointerValid((CPed *)v4) )
      *p_m_pEntShotOwner = 0;
    v7 = &gaShotInfo[i];
    m_bShotActive = v7->m_bShotActive;
    p_m_bShotActive = &v7->m_bShotActive;
    if ( m_bShotActive )
    {
      WeaponInfo = CWeaponInfo::GetWeaponInfo(gaShotInfo[i].m_eShotType, 1);
      m_nFlags = WeaponInfo->m_nFlags;
      if ( gaShotInfo[i].m_fTimeExpires < (float)CTimer::m_snTimeInMilliseconds )
        *p_m_bShotActive = 0;
      if ( (m_nFlags & 0x10000) != 0 )
      {
        v11 = &gaShotInfo[i];
        x = v11->m_vecShotVelocity.x;
        y = v11->m_vecShotVelocity.y;
        z = v11->m_vecShotVelocity.z;
        v15 = powf(0.96, CTimer::ms_fTimeStep);
        v11->m_vecShotVelocity.x = v15 * x;
        v11->m_vecShotVelocity.y = v15 * y;
        v11->m_vecShotVelocity.z = v15 * z;
      }
      v16 = CTimer::ms_fTimeStep;
      if ( (m_nFlags & 0x80000) != 0 )
        gaShotInfo[i].m_fShotRadius = gaShotInfo[i].m_fShotRadius + (float)(CTimer::ms_fTimeStep * 0.075);
      v62 = p_m_pEntShotOwner;
      v17 = &gaShotInfo[i];
      p_z = &v17->m_vecShotPosition.z;
      v18 = v17->m_vecShotVelocity.z;
      v19 = v16 * v17->m_vecShotVelocity.y;
      v20 = v17->m_vecShotPosition.y;
      v21 = v17->m_vecShotPosition.z;
      p_y = &v17->m_vecShotPosition.y;
      vecPos = &v17->m_vecShotPosition;
      v17->m_vecShotPosition.x = (float)(v16 * v17->m_vecShotVelocity.x) + v17->m_vecShotPosition.x;
      v17->m_vecShotPosition.y = v19 + v20;
      v17->m_vecShotPosition.z = (float)(v16 * v18) + v21;
      v22 = *p_m_pEntShotOwner;
      v23 = v17;
      if ( v22 )
      {
        v24 = v22[18].m_transform.m_translate.y;
        v25 = &gaShotInfo[i];
        p_m_bSprayPaintDone = &v25->m_bSprayPaintDone;
        v0.n64_u32[0] = LODWORD(v25->m_fShotRadius);
        v26 = 92;
        LODWORD(v27) = vmax_f32(v0, v1).n64_u32[0];
        do
        {
          v28 = v26;
          v29 = *(_DWORD *)(LODWORD(v24) + 4 * v26);
          if ( v29
            && CPed::IsPointerValid(*(CPed **)(LODWORD(v24) + 4 * v26))
            && !(*(unsigned __int8 *)(v29 + 1157) << 31) )
          {
            v30 = *(_DWORD *)(v29 + 20);
            v31 = (float *)(v29 + 4);
            v32 = v29 + 4;
            if ( v30 )
              v32 = v30 + 48;
            if ( (*(_BYTE *)(v29 + 70) & 8) == 0 )
            {
              v33 = *(float *)v32;
              v34.n64_u64[0] = *(unsigned __int64 *)(v32 + 4);
              v35 = vecPos->x;
              v36.n64_u64[0] = *(unsigned __int64 *)p_y;
              if ( CPed::IsPedInControl((CPed *)v29) )
              {
                v37.n64_u64[0] = vsub_f32(v34, v36).n64_u64[0];
                v38 = vmul_f32(v37, v37).n64_u64[0];
                if ( (float)((float)((float)((float)(v33 - v35) * (float)(v33 - v35)) + *(float *)&v38)
                           + *((float *)&v38 + 1)) < v27 )
                {
                  if ( (unsigned int)(v23->m_eShotType - 41) > 1 )
                  {
                    CFireManager::StartFire(&gFireManager, (CEntity *)v29, *v62, 0.8, 1u, 7000, 100);
                  }
                  else if ( !*p_m_bSprayPaintDone )
                  {
                    v39 = *(_DWORD *)(v29 + 20);
                    m_pMat = (*v62)->m_pMat;
                    if ( v39 )
                      v31 = (float *)(v39 + 48);
                    v41 = *v31;
                    p_tx = &m_pMat->tx;
                    if ( !m_pMat )
                      p_tx = &(*v62)->m_transform.m_translate.x;
                    v43 = *p_tx;
                    v65[0].y = p_tx[1] - v31[1];
                    v65[0].x = v43 - v41;
                    LocalDirection = CPed::GetLocalDirection((CPed *)v29, (const CVector2D *)v65);
                    v23 = &gaShotInfo[i];
                    CWeapon::GenerateDamageEvent(
                      (CPed *)v29,
                      *v62,
                      v23->m_eShotType,
                      WeaponInfo->m_nDamage,
                      PED_SPHERE_CHEST,
                      LocalDirection);
                    *p_m_bSprayPaintDone = 1;
                  }
                }
              }
            }
          }
          v26 = v28 - 1;
        }
        while ( v28 - 76 > 1 );
      }
      if ( v23->m_eShotType == WEAPONTYPE_EXTINGUISHER )
      {
        v56 = &gaShotInfo[i];
        m_bSprayPaintDone = v56->m_bSprayPaintDone;
        v57 = &v56->m_bSprayPaintDone;
        if ( !m_bSprayPaintDone )
        {
          v66.z = *p_z;
          v66.y = *p_y;
          v66.x = vecPos->x;
          if ( CFireManager::ExtinguishPointWithWater(&gFireManager, v66, gaShotInfo[i].m_fShotRadius, 2.0) )
            *v57 = 1;
        }
      }
      else if ( v23->m_eShotType == WEAPONTYPE_SPRAYCAN )
      {
        v45 = &gaShotInfo[i];
        v47 = v45->m_bSprayPaintDone;
        v46 = &v45->m_bSprayPaintDone;
        if ( !v47 )
        {
          v48 = CWorld::SprayPaintWorld(vecPos, v65, gaShotInfo[i].m_fShotRadius * 1.5, 1);
          if ( v48 )
          {
            *v46 = 1;
            v49 = v17->m_vecShotVelocity.x;
            v50 = v17->m_vecShotVelocity.y;
            v51 = v17->m_vecShotVelocity.z;
            v0.n64_f32[1] = v51 * v65[0].z;
            v52 = (float)((float)(v49 * v65[0].x) + (float)(v50 * v65[0].y)) + (float)(v51 * v65[0].z);
            v53 = (float)(v50 - (float)(v65[0].y * v52)) + (float)(v50 - (float)(v65[0].y * v52));
            v54 = (float)(v51 - (float)(v65[0].z * v52)) + (float)(v51 - (float)(v65[0].z * v52));
            v17->m_vecShotVelocity.x = (float)(v49 - (float)(v65[0].x * v52)) + (float)(v49 - (float)(v65[0].x * v52));
            v17->m_vecShotVelocity.y = v53;
            v17->m_vecShotVelocity.z = v54;
            if ( v48 == 2 )
            {
              v55 = (CPlayerPed *)*v62;
              if ( v55 == FindPlayerPed(-1) )
                CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 43, 0.0, 1.0);
            }
          }
        }
      }
      else
      {
        if ( !((CTimer::m_FrameCounter + i) << 30) )
          CWorld::SetCarsOnFire(vecPos->x, *p_y, *p_z, 4.0, *v62);
        CWorld::SetWorldOnFire(vecPos->x, *p_y, *p_z, 0.1, *v62);
      }
    }
  }
}
// 5DB4CA: variable 'v0' is possibly undefined
// 5DB4CA: variable 'v1' is possibly undefined

//----- (005DB7AC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
Bool8 __fastcall CShotInfo::GetPositionOfPossibleFlame(UInt8 ShotIndex, CVector *vecFlamePosition)
{
  Bool8 v2; // r2
  CShotInfo *v4; // r0
  __int64 v5; // d16

  v2 = 0;
  vecFlamePosition->x = 0.0;
  vecFlamePosition->y = 0.0;
  vecFlamePosition->z = 0.0;
  if ( gaShotInfo[ShotIndex].m_bShotActive )
  {
    if ( gaShotInfo[ShotIndex].m_eShotType != WEAPONTYPE_FLAMETHROWER )
      return 0;
    v4 = &gaShotInfo[ShotIndex];
    v2 = 1;
    v5 = *(_QWORD *)&v4->m_vecShotPosition.x;
    vecFlamePosition->z = v4->m_vecShotPosition.z;
    *(_QWORD *)&vecFlamePosition->x = v5;
  }
  return v2;
}
// 5DB7AC: variables would overlap: r0.1 and r0.2

//----- (005DB810) --------------------------------------------------------
void __fastcall CWeapon::CWeapon(CWeapon *this, eWeaponType WeaponType, int32 nAmmoTotal)
{
  int32 v4; // r0
  unsigned int m_nAmmo; // r0

  v4 = 99999;
  if ( nAmmoTotal < 99999 )
    v4 = nAmmoTotal;
  this->m_eWeaponType = WeaponType;
  this->m_eState = WEAPONSTATE_READY;
  this->m_nAmmoInClip = 0;
  this->m_nAmmoTotal = v4;
  if ( v4 )
  {
    m_nAmmo = CWeaponInfo::GetWeaponInfo(WeaponType, 1)->m_nAmmo;
    if ( this->m_nAmmoTotal < m_nAmmo )
      m_nAmmo = this->m_nAmmoTotal;
    this->m_nAmmoInClip = m_nAmmo;
  }
  this->m_nTimer = 0;
  this->m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_bFirstPersonWeaponModeSelected = 0;
}

//----- (005DB852) --------------------------------------------------------
void __fastcall CWeapon::Reload(CWeapon *this, CPed *pOwnerPed)
{
  eWeaponType m_eWeaponType; // r5
  int8 WeaponSkill; // r1
  unsigned int m_nAmmo; // r0

  if ( this->m_nAmmoTotal )
  {
    m_eWeaponType = this->m_eWeaponType;
    if ( pOwnerPed )
      WeaponSkill = CPed::GetWeaponSkill(pOwnerPed, this->m_eWeaponType);
    else
      WeaponSkill = 1;
    m_nAmmo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill)->m_nAmmo;
    if ( this->m_nAmmoTotal < m_nAmmo )
      m_nAmmo = this->m_nAmmoTotal;
    this->m_nAmmoInClip = m_nAmmo;
  }
}

//----- (005DB888) --------------------------------------------------------
void CWeapon::InitialiseWeapons()
{
  CWeaponInfo::Initialise();
  CShotInfo::Initialise();
  CExplosion::Initialise();
  CProjectileInfo::Initialise();
  CBulletInfo::Initialise();
  CWeapon::ms_bTakePhoto = 0;
  CWeapon::ms_bPhotographHasBeenTaken = 0;
}

//----- (005DB8BC) --------------------------------------------------------
void CWeapon::ShutdownWeapons()
{
  CWeaponInfo::Shutdown();
  CShotInfo::Shutdown();
  CExplosion::Shutdown();
  CProjectileInfo::Shutdown();
  CBulletInfo::Shutdown();
  sub_195058(&CWeapon::ms_PelletTestCol);
}

//----- (005DB8E8) --------------------------------------------------------
void CWeapon::UpdateWeapons()
{
  CShotInfo::Update();
  CExplosion::Update();
  CProjectileInfo::Update();
  sub_19ACA8();
}

//----- (005DB900) --------------------------------------------------------
void __fastcall CWeapon::Initialise(CWeapon *this, eWeaponType WeaponType, int32 nAmmoTotal, CPed *pOwnerPed)
{
  int32 v5; // r0
  eWeaponType m_eWeaponType; // r5
  int8 WeaponSkill; // r1
  unsigned int m_nAmmo; // r0
  int32 m_modelId; // r6
  int32 m_modelId2; // r5

  v5 = 99999;
  if ( nAmmoTotal < 99999 )
    v5 = nAmmoTotal;
  m_eWeaponType = WeaponType;
  this->m_eWeaponType = WeaponType;
  this->m_eState = WEAPONSTATE_READY;
  this->m_nAmmoInClip = 0;
  this->m_nAmmoTotal = v5;
  if ( v5 )
  {
    if ( pOwnerPed )
      WeaponSkill = CPed::GetWeaponSkill(pOwnerPed, WeaponType);
    else
      WeaponSkill = 1;
    m_nAmmo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill)->m_nAmmo;
    m_eWeaponType = this->m_eWeaponType;
    if ( this->m_nAmmoTotal < m_nAmmo )
      m_nAmmo = this->m_nAmmoTotal;
    this->m_nAmmoInClip = m_nAmmo;
  }
  this->m_nTimer = 0;
  m_modelId = CWeaponInfo::GetWeaponInfo(m_eWeaponType, 1)->m_modelId;
  m_modelId2 = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1)->m_modelId2;
  if ( m_modelId != -1 )
    CBaseModelInfo::AddRef(CModelInfo::ms_modelInfoPtrs[m_modelId]);
  if ( m_modelId2 != -1 )
    CBaseModelInfo::AddRef(CModelInfo::ms_modelInfoPtrs[m_modelId2]);
  this->m_bDontPlaceInHand = 0;
  this->m_pWeaponFxSys = 0;
}

//----- (005DB99C) --------------------------------------------------------
void __fastcall CWeapon::Shutdown(CWeapon *this)
{
  int32 m_modelId; // r0
  int32 m_modelId2; // r0

  m_modelId = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1)->m_modelId;
  if ( m_modelId != -1 )
    CBaseModelInfo::RemoveRef(CModelInfo::ms_modelInfoPtrs[m_modelId]);
  m_modelId2 = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1)->m_modelId2;
  if ( m_modelId2 != -1 )
    CBaseModelInfo::RemoveRef(CModelInfo::ms_modelInfoPtrs[m_modelId2]);
  *(_QWORD *)&this->m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_nAmmoInClip = 0LL;
  this->m_nTimer = 0;
}

//----- (005DB9F0) --------------------------------------------------------
int __fastcall CWeapon::Fire(
        CWeapon *this,
        CEntity *pEntity,
        CVector *pStartPosn,
        CVector *pBarrelPosn,
        CEntity *pTargetEnt,
        CVector *pTargetPosn,
        CVector *pAltPosn)
{
  float32x2_t v7; // d0
  float32x2_t v8; // d2
  float32x2_t v9; // d3
  CEntity *v11; // r11
  CEntity *v15; // r2
  CWeaponInfo *WeaponInfo; // r4
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v20; // r0
  float m_heading; // s0
  float v22; // s0
  float v23; // s18
  RwReal v24; // s0
  unsigned int m_nAmmo; // r0
  CEntity *v26; // r3
  CVector *v27; // r6
  CTask *ActiveTask; // r0
  int v29; // r0
  int v30; // r4
  CMatrix *v31; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v33; // d16
  unsigned __int64 v34; // d1
  bool v35; // zf
  bool v36; // zf
  CSimpleTransform *p_m_transform; // r0
  CMatrix *v38; // r1
  CMatrix *v39; // r1
  CSimpleTransform *v40; // r2
  float32x2_t v41; // d16
  unsigned __int64 v42; // d1
  _BOOL4 IsPlayer; // r0
  int v44; // r5
  int v45; // r0
  CWeaponInfo *v46; // r4
  int v47; // r5
  TouchSense *v48; // r0
  int v49; // r2
  int v50; // r6
  unsigned __int32 v51; // r0
  UInt16 v52; // r0
  int32 m_nAmmoInClip; // r0
  int32 m_nAmmoTotal; // r1
  int32 v55; // r0
  int v56; // r1
  uint32 v57; // r5
  uint32 v58; // r5
  int32 WeaponReloadTime; // r0
  uint32 v60; // r0
  CPad *Pad; // r0
  TouchSense *v63; // r0
  int v64; // r2
  CVector *v65; // [sp+14h] [bp-54h]
  CVector v66; // [sp+18h] [bp-50h] BYREF
  CVector v; // [sp+28h] [bp-40h] BYREF

  v11 = 0;
  v.x = 0.0;
  v.y = 0.0;
  v.z = 0.6;
  WeaponInfo = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
  if ( !pEntity )
  {
LABEL_4:
    if ( !pStartPosn )
      goto LABEL_7;
    goto LABEL_10;
  }
  if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
  {
    m_eWeaponType = this->m_eWeaponType;
    WeaponSkill = CPed::GetWeaponSkill((CPed *)pEntity, this->m_eWeaponType);
    WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
    v11 = pEntity;
    goto LABEL_4;
  }
  v11 = 0;
  if ( !pStartPosn )
  {
LABEL_7:
    m_pMat = pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    pBarrelPosn = &v;
    operator*(&v66, m_pMat, &v);
    pStartPosn = &v;
    v = v66;
  }
LABEL_10:
  if ( this->m_bFirstPersonWeaponModeSelected )
  {
    v20 = pEntity->m_pMat;
    if ( v20 )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(v20->xy) ^ 0x80000000), v20->yy);
    else
      m_heading = pEntity->m_transform.m_heading;
    v22 = (float)((float)(m_heading * 180.0) / 3.1416) * 0.017453;
    v23 = sinf(v22);
    v24 = pStartPosn->y + (float)(cosf(v22) * 0.15);
    pStartPosn->x = pStartPosn->x - (float)(v23 * 0.15);
    pStartPosn->y = v24;
  }
  if ( this->m_eState > (unsigned int)WEAPONSTATE_FIRING )
    return 0;
  if ( this->m_nAmmoInClip > 0 )
    goto LABEL_21;
  if ( this->m_nAmmoTotal < 1 )
    return 0;
  m_nAmmo = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1)->m_nAmmo;
  if ( this->m_nAmmoTotal < m_nAmmo )
    m_nAmmo = this->m_nAmmoTotal;
  this->m_nAmmoInClip = m_nAmmo;
LABEL_21:
  v26 = pTargetEnt;
  v65 = (CVector *)(&dword_0 + 1);
  v27 = (CVector *)WeaponInfo;
  switch ( this->m_eWeaponType )
  {
    case WEAPONTYPE_GRENADE:
    case WEAPONTYPE_TEARGAS:
    case WEAPONTYPE_MOLOTOV:
    case WEAPONTYPE_REMOTE_SATCHEL_CHARGE:
      if ( !pTargetPosn )
      {
        v44 = 0;
        if ( FindPlayerPed(-1) == pEntity )
          v45 = CWeapon::FireProjectile(
                  this,
                  pEntity,
                  pBarrelPosn,
                  pTargetEnt,
                  0,
                  *(float *)(LODWORD(pEntity[18].m_transform.m_translate.z) + 44) / 26.667);
        else
          v45 = CWeapon::FireProjectile(this, pEntity, pBarrelPosn, pTargetEnt, 0, 0.3);
        goto LABEL_68;
      }
      v31 = pEntity->m_pMat;
      v8.n64_u32[0] = 1.0;
      p_tx = (CSimpleTransform *)&v31->tx;
      if ( !v31 )
        p_tx = &pEntity->m_transform;
      v9.n64_u32[0] = 1045220557;
      v33.n64_u64[0] = vsub_f32(*(float32x2_t *)&pTargetPosn->y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
      v34 = vmul_f32(v33, v33).n64_u64[0];
      v7.n64_f32[0] = (float)(sqrtf(
                                (float)((float)((float)(pTargetPosn->x - p_tx->m_translate.x)
                                              * (float)(pTargetPosn->x - p_tx->m_translate.x))
                                      + *(float *)&v34)
                              + *((float *)&v34 + 1))
                            + -10.0)
                    * 0.1;
      if ( !CWeapon::FireProjectile(
              this,
              pEntity,
              pBarrelPosn,
              pTargetEnt,
              pTargetPosn,
              vmin_f32(vmax_f32(v7, v9), v8).n64_f32[0]) )
        goto LABEL_65;
      goto LABEL_69;
    case WEAPONTYPE_ROCKET:
    case WEAPONTYPE_ROCKET_HS:
    case WEAPONTYPE_FREEFALL_BOMB:
      goto LABEL_71;
    case WEAPONTYPE_PISTOL:
    case WEAPONTYPE_PISTOL_SILENCED:
    case WEAPONTYPE_DESERT_EAGLE:
    case WEAPONTYPE_MICRO_UZI:
    case WEAPONTYPE_MP5:
    case WEAPONTYPE_AK47:
    case WEAPONTYPE_M4:
    case WEAPONTYPE_TEC9:
    case WEAPONTYPE_COUNTRYRIFLE:
    case WEAPONTYPE_MINIGUN:
      if ( !v11 )
        goto LABEL_29;
      if ( *(_DWORD *)&v11[23].numLodChildren )
        goto LABEL_24;
      v35 = TheCamera.PlayerWeaponMode.Mode == 45;
      if ( TheCamera.PlayerWeaponMode.Mode != 45 )
        v35 = TheCamera.PlayerWeaponMode.Mode == 34;
      if ( v35 )
      {
        if ( !CWeapon::FireM16_1stPerson(this, (CPed *)pEntity) )
          goto LABEL_65;
      }
      else
      {
LABEL_24:
        CWeapon::FireInstantHit(this, pEntity, pStartPosn, pBarrelPosn, pTargetEnt, pTargetPosn, pAltPosn, 0, 1);
        if ( !(BYTE1(v11[19].m_transform.m_heading) << 31)
          || CTaskManager::GetActiveTask((const CTaskManager *)(LODWORD(v11[18].m_transform.m_translate.y) + 4))
          && (ActiveTask = CTaskManager::GetActiveTask((const CTaskManager *)(LODWORD(v11[18].m_transform.m_translate.y)
                                                                            + 4)),
              (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) == 1022) )
        {
          v29 = 0;
          goto LABEL_70;
        }
      }
      goto LABEL_69;
    case WEAPONTYPE_SHOTGUN:
    case WEAPONTYPE_SAWNOFF_SHOTGUN:
    case WEAPONTYPE_SPAS12_SHOTGUN:
LABEL_29:
      v65 = (CVector *)(&dword_0 + 1);
      CWeapon::FireInstantHit(this, pEntity, pStartPosn, pBarrelPosn, pTargetEnt, pTargetPosn, pAltPosn, 0, 1);
      goto LABEL_71;
    case WEAPONTYPE_SNIPERRIFLE:
      if ( !v11 || *(_DWORD *)&v11[23].numLodChildren || TheCamera.PlayerWeaponMode.Mode != 7 )
      {
        v65 = (CVector *)(&dword_0 + 1);
        CWeapon::FireInstantHit(this, pEntity, pStartPosn, pBarrelPosn, pTargetEnt, pTargetPosn, 0, 0, 1);
        goto LABEL_71;
      }
      if ( CWeapon::FireSniper(this, (CPed *)pEntity, v15, (CVector *)pTargetEnt) )
        goto LABEL_69;
      goto LABEL_65;
    case WEAPONTYPE_ROCKETLAUNCHER:
    case WEAPONTYPE_ROCKETLAUNCHER_HS:
      if ( (*(_BYTE *)&pEntity->m_info & 7) != 3 )
        goto LABEL_57;
      v36 = pTargetEnt == 0;
      if ( !pTargetEnt )
        v36 = pTargetPosn == 0;
      if ( v36 )
      {
LABEL_57:
        v44 = 0;
        v45 = CWeapon::FireProjectile(this, pEntity, pBarrelPosn, pTargetEnt, pTargetPosn, 0.0);
LABEL_68:
        if ( !v45 )
          goto LABEL_126;
      }
      else
      {
        p_m_transform = (CSimpleTransform *)pTargetPosn;
        if ( pTargetEnt )
        {
          v38 = pTargetEnt->m_pMat;
          p_m_transform = (CSimpleTransform *)&v38->tx;
          if ( !v38 )
            p_m_transform = &pTargetEnt->m_transform;
        }
        v39 = pEntity->m_pMat;
        v40 = (CSimpleTransform *)&v39->tx;
        if ( !v39 )
          v40 = &pEntity->m_transform;
        v41.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&v40->m_translate.y).n64_u64[0];
        v42 = vmul_f32(v41, v41).n64_u64[0];
        if ( sqrtf(
               (float)((float)((float)(p_m_transform->m_translate.x - v40->m_translate.x)
                             * (float)(p_m_transform->m_translate.x - v40->m_translate.x))
                     + *(float *)&v42)
             + *((float *)&v42 + 1)) <= 8.0 )
        {
          IsPlayer = CPed::IsPlayer((const CPed *)pEntity);
          v26 = pTargetEnt;
          if ( !IsPlayer )
          {
LABEL_65:
            v44 = 0;
LABEL_126:
            v30 = 1;
            if ( this->m_eWeaponType && this->m_eWeaponType != WEAPONTYPE_BASEBALLBAT )
              return v44;
            return v30;
          }
        }
        v44 = 0;
        if ( CWeapon::FireProjectile(this, pEntity, pBarrelPosn, v26, pTargetPosn, 0.0) != 1 )
          goto LABEL_126;
      }
LABEL_69:
      v29 = 1;
LABEL_70:
      v65 = (CVector *)v29;
LABEL_71:
      if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
      {
        v46 = (CWeaponInfo *)v27;
        if ( this->m_eWeaponType == WEAPONTYPE_CAMERA
          || (LODWORD(pEntity[19].m_transform.m_heading) |= 0x10000u, !CPed::IsPlayer((const CPed *)pEntity)) )
        {
          v47 = 0;
        }
        else
        {
          v47 = 1;
          switch ( this->m_eWeaponType )
          {
            case WEAPONTYPE_PISTOL:
            case WEAPONTYPE_PISTOL_SILENCED:
            case WEAPONTYPE_DESERT_EAGLE:
              TouchSense::instance();
              v49 = 86;
              goto LABEL_85;
            case WEAPONTYPE_SHOTGUN:
            case WEAPONTYPE_SAWNOFF_SHOTGUN:
            case WEAPONTYPE_SPAS12_SHOTGUN:
              TouchSense::instance();
              v49 = 77;
              goto LABEL_85;
            case WEAPONTYPE_MICRO_UZI:
            case WEAPONTYPE_TEC9:
              TouchSense::instance();
              v49 = 4;
              goto LABEL_85;
            case WEAPONTYPE_MP5:
              TouchSense::instance();
              v49 = 87;
              goto LABEL_85;
            case WEAPONTYPE_AK47:
            case WEAPONTYPE_M4:
              TouchSense::instance();
              v49 = 22;
              goto LABEL_85;
            case WEAPONTYPE_COUNTRYRIFLE:
            case WEAPONTYPE_SNIPERRIFLE:
              TouchSense::instance();
              v49 = 88;
              goto LABEL_85;
            case WEAPONTYPE_ROCKETLAUNCHER:
              TouchSense::instance();
              v49 = 43;
LABEL_85:
              TouchSense::playBuiltinEffect(v48, 2, v49, 115, 20);
              goto LABEL_86;
            case WEAPONTYPE_FLAMETHROWER:
              TouchSense::instance();
              v64 = 111;
              goto LABEL_136;
            case WEAPONTYPE_MINIGUN:
              TouchSense::instance();
              v64 = 121;
LABEL_136:
              TouchSense::startContinuousBuiltinEffect(v63, 2, v64, 115, 20);
LABEL_86:
              v47 = 1;
              break;
            default:
              break;
          }
        }
        CAEPedWeaponAudioEntity::AddAudioEvent((CAEPedWeaponAudioEntity *)&pEntity[15].m_pMat, 145);
        if ( pTargetEnt && v47 == 1 )
        {
          if ( (*(_BYTE *)&pTargetEnt->m_info & 7) == 3 )
          {
            if ( this->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED )
            {
LABEL_100:
              v52 = 126;
              goto LABEL_104;
            }
            CPed::Say((CPed *)pEntity, 0xB6u, 0xC8u, 1.0, 0, 0, 0);
          }
          v47 = 1;
        }
      }
      else
      {
        v47 = 0;
        v46 = (CWeaponInfo *)v27;
      }
      if ( this->m_eWeaponType == WEAPONTYPE_REMOTE_SATCHEL_CHARGE
        && (CPed::GiveWeapon((CPed *)pEntity, WEAPONTYPE_DETONATOR, 1u, 1),
            *((int *)&pEntity[24].m_transform.m_heading
            + 7 * CPed::GetWeaponSlot((CPed *)pEntity, WEAPONTYPE_REMOTE_SATCHEL_CHARGE)) <= 1) )
      {
        v50 = 0;
        *((_DWORD *)&pEntity[24].m_transform.m_translate.y
        + 7 * CPed::GetWeaponSlot((CPed *)pEntity, WEAPONTYPE_DETONATOR)) = 0;
        CPed::SetCurrentWeapon((CPed *)pEntity, WEAPONTYPE_DETONATOR);
        if ( !v47 )
          goto LABEL_105;
      }
      else if ( v47 != 1 )
      {
        v50 = 0;
        goto LABEL_105;
      }
      v50 = 1;
      v51 = this->m_eWeaponType - 16;
      if ( v51 > 0x18 )
        goto LABEL_105;
      if ( ((1 << v51) & (unsigned int)&loc_47FFC0) != 0 )
        goto LABEL_100;
      if ( ((1 << v51) & 0x198000D) == 0 )
        goto LABEL_105;
      v52 = 127;
LABEL_104:
      CStats::IncrementStat(v52, 1.0);
      v50 = 1;
LABEL_105:
      if ( !CCheat::m_aCheatsActive[80] )
      {
        m_nAmmoInClip = this->m_nAmmoInClip;
        if ( m_nAmmoInClip >= 1 )
          this->m_nAmmoInClip = m_nAmmoInClip - 1;
        m_nAmmoTotal = this->m_nAmmoTotal;
        if ( m_nAmmoTotal >= 1
          && ((m_nAmmoTotal < 25000) | v50) == 1
          && (v50 != 1 || CStats::GetPercentageProgress() < 100.0 || this->m_eWeaponType == WEAPONTYPE_DETONATOR) )
        {
          --this->m_nAmmoTotal;
        }
      }
      v55 = this->m_nAmmoInClip;
      this->m_eState = WEAPONSTATE_FIRING;
      if ( v55 )
      {
        if ( v65 == (CVector *)((char *)&dword_0 + 1) )
        {
          if ( this->m_eWeaponType == WEAPONTYPE_CAMERA )
            v56 = 1100;
          else
            v56 = (int)(float)((float)(v46->m_animLoopEnd - v46->m_animLoopStart) * 900.0);
          v60 = CTimer::m_snTimeInMilliseconds + v56;
        }
        else
        {
          v60 = CTimer::m_snTimeInMilliseconds;
        }
        v44 = 1;
        this->m_nTimer = v60;
        goto LABEL_126;
      }
      if ( this->m_nAmmoTotal )
      {
        this->m_eState = WEAPONSTATE_RELOADING;
        v57 = CTimer::m_snTimeInMilliseconds;
        this->m_nTimer = CWeaponInfo::GetWeaponReloadTime(v46) + v57;
        if ( FindPlayerPed(-1) == pEntity && CWorld::Players[CWorld::PlayerInFocus].FastReload )
        {
          v58 = CTimer::m_snTimeInMilliseconds;
          WeaponReloadTime = CWeaponInfo::GetWeaponReloadTime(v46);
          v30 = 1;
          this->m_nTimer = v58 + WeaponReloadTime / 4;
          return v30;
        }
      }
      else if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 46 )
      {
        Pad = CPad::GetPad(0);
        v30 = 1;
        CPad::Clear(Pad, 0, 1);
        return v30;
      }
      v30 = 1;
      break;
    case WEAPONTYPE_FLAMETHROWER:
    case WEAPONTYPE_SPRAYCAN:
    case WEAPONTYPE_EXTINGUISHER:
      CWeapon::FireAreaEffect(this, pEntity, pBarrelPosn, pTargetEnt, (CSimpleTransform *)pTargetPosn);
      v29 = 0;
      goto LABEL_70;
    case WEAPONTYPE_DETONATOR:
      CWorld::UseDetonator(pEntity);
      this->m_nAmmoInClip = 1;
      v65 = (CVector *)(&dword_0 + 1);
      this->m_nAmmoTotal = 1;
      goto LABEL_71;
    case WEAPONTYPE_CAMERA:
      if ( !CWeapon::TakePhotograph((CWeapon *)pAltPosn, (CEntity *)(this->m_eWeaponType - 16), pBarrelPosn) )
        goto LABEL_65;
      goto LABEL_69;
    default:
      v65 = pAltPosn;
      v27 = pTargetPosn;
      goto LABEL_71;
  }
  return v30;
}
// 5DBC7A: variable 'v7' is possibly undefined
// 5DBC7A: variable 'v9' is possibly undefined
// 5DBC7E: variable 'v8' is possibly undefined
// 5DBDB8: variable 'v15' is possibly undefined
// 5DBEDE: variable 'v48' is possibly undefined
// 5DC13C: variable 'v63' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005DC178) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall CWeapon::FireInstantHit(
        CWeapon *this,
        CEntity *pEntity,
        CVector *pStartPosn,
        CVector *pBarrelPosn,
        CEntity *pTargetEnt,
        CVector *pTargetPosn,
        CVector *pAltPosn,
        int bCrossHairGun,
        int bCreateGunFx)
{
  float32x2_t v9; // d0
  float32x2_t v10; // d2
  float32x2_t v11; // d3
  float32x2_t v12; // d4
  CEntity *v13; // r5
  eWeaponType m_eWeaponType; // r8
  int8 WeaponSkill; // r1
  eWeaponType v18; // r0
  __int64 v19; // d16
  __int64 v20; // d16
  __int64 v21; // d16
  float v22; // s16
  CTaskSimpleUseGun *TaskUseGun; // r0
  CEntity *v24; // r8
  CEntity *v25; // r11
  bool v26; // zf
  CEntity *v27; // r2
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v29; // r8
  RwMatrix *MatrixArray; // r0
  bool v31; // zf
  int m_pLastRenderedLink; // r0
  bool v33; // zf
  unsigned __int16 v34; // r0
  unsigned int v35; // r0
  __int64 v36; // d16
  unsigned int m_info; // r1
  CMatrix *v38; // r0
  __int64 v39; // d16
  __int64 v40; // d16
  float v41; // s6
  CVehicle *v42; // r4
  unsigned int v43; // r5
  CPlayerPed *PlayerPed; // r0
  float v45; // s6
  float v46; // s2
  float v47; // s4
  __int64 v48; // d16
  CEntity *v49; // r0
  bool v50; // zf
  CEntity *v51; // r1
  __int64 v52; // d16
  RwReal z; // r0
  float v54; // s16
  float *p_m_fWeaponRange; // r6
  int m_nModelIndex; // r0
  bool v57; // zf
  float *v58; // r1
  float v59; // s18
  float v60; // s20
  int v61; // r0
  float v62; // s6
  char v63; // r2
  RwReal v64; // r3
  char v65; // r0
  RwReal v66; // r2
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventGlobalGroup *v68; // r0
  CEntity *v69; // r8
  __int64 v70; // d16
  int v71; // s16
  float v72; // s18
  int v73; // r4
  CVector2D *v74; // r0
  CEntity *v75; // r3
  CVector2D v76; // d8
  __int64 v77; // d9
  CWeaponInfo *v78; // r10
  CEntity *v79; // r9
  int *v80; // r0
  int v81; // r8
  CEntity *v82; // r5
  CColModel *ColModel; // r0
  CEntity *v84; // r11
  CColModel *v85; // r9
  CMatrix *v86; // r2
  int v87; // r11
  CVector2D *v88; // r0
  int v89; // r6
  int i; // r1
  float v91; // s0
  CColPoint *v92; // r10
  CVector2D *v93; // r5
  int v94; // r4
  float v96; // s16
  bool v97; // zf
  RwReal v98; // r0
  CVector2D v99; // d16
  int v100; // r0
  RwReal v101; // r0
  __int64 v102; // d16
  CVector *p_dirGunshell; // r0
  int (**v104)(void); // s20
  float v105; // s28
  int m_iAccumulatedTime; // s22
  float v107; // s24
  float v108; // s26
  float v109; // r6
  float v110; // s18
  float v111; // s30
  float v112; // r0
  bool v113; // zf
  int v114; // r0
  eWeaponType v115; // r2
  float v116; // r0
  float v117; // s18
  float v118; // s16
  int v119; // r1
  CLink<CEntity *> *v120; // r1
  bool v121; // zf
  int Mode; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v125; // s18
  bool v126; // zf
  float32x2_t v127; // d3
  int z_low; // r0
  float m_fWeaponRange; // s20
  int v130; // r0
  bool v131; // zf
  float m_heading; // r0
  bool v133; // zf
  float v134; // s18
  float v135; // s4
  float v136; // s16
  CVector *p_posGunshell; // r0
  float v138; // s18
  float v139; // s20
  int v140; // r0
  float x; // s20
  float v142; // s28
  float y; // s22
  float v144; // s24
  float v145; // s26
  float v146; // r6
  float v147; // s18
  float v148; // s30
  float v149; // r0
  bool v150; // zf
  int m_heading_low; // r1
  CVector bCheckBuildings; // [sp+0h] [bp-218h] BYREF
  CWeaponInfo *WeaponInfo; // [sp+4Ch] [bp-1CCh]
  CEntity *pFiringEntity; // [sp+50h] [bp-1C8h]
  CWeapon *v155; // [sp+54h] [bp-1C4h]
  CVector2D dirGunshell; // [sp+58h] [bp-1C0h] BYREF
  __int64 v157; // [sp+60h] [bp-1B8h]
  CVector2D v158; // [sp+68h] [bp-1B0h]
  __int64 v159; // [sp+70h] [bp-1A8h]
  CVector2D v160; // [sp+78h] [bp-1A0h]
  __int64 v161; // [sp+80h] [bp-198h]
  int v162; // [sp+88h] [bp-190h]
  int v163; // [sp+8Ch] [bp-18Ch]
  int v164; // [sp+90h] [bp-188h]
  CMatrix posGunshell; // [sp+98h] [bp-180h] BYREF
  CEventGunShotWhizzedBy v166; // [sp+E0h] [bp-138h] BYREF
  CEventGunShot v167; // [sp+110h] [bp-108h] BYREF
  CEntity *refEntityPtr; // [sp+144h] [bp-D4h] BYREF
  CColPoint colPoint; // [sp+148h] [bp-D0h] BYREF
  CVector dir; // [sp+178h] [bp-A0h] BYREF
  CVector pos; // [sp+188h] [bp-90h] BYREF
  CVector pShotStart; // [sp+198h] [bp-80h] BYREF
  RwV3d_0 pointsIn; // [sp+1A8h] [bp-70h] BYREF

  v13 = pEntity;
  v155 = this;
  if ( pEntity && (*(_BYTE *)&pEntity->m_info & 7) == 3 )
  {
    m_eWeaponType = this->m_eWeaponType;
    WeaponSkill = CPed::GetWeaponSkill((CPed *)pEntity, this->m_eWeaponType);
    v18 = m_eWeaponType;
  }
  else
  {
    WeaponSkill = 1;
    v18 = this->m_eWeaponType;
  }
  WeaponInfo = CWeaponInfo::GetWeaponInfo(v18, WeaponSkill);
  memset(&pointsIn, 0, sizeof(pointsIn));
  v19 = *(_QWORD *)&pBarrelPosn->x;
  pos.z = pBarrelPosn->z;
  *(_QWORD *)&pos.x = v19;
  *(float *)&refEntityPtr = 0.0;
  v20 = *(_QWORD *)&pStartPosn->x;
  pShotStart.z = pStartPosn->z;
  *(_QWORD *)&pShotStart.x = v20;
  if ( pAltPosn )
  {
    v21 = *(_QWORD *)&pAltPosn->x;
    pShotStart.z = pAltPosn->z;
    *(_QWORD *)&pShotStart.x = v21;
  }
  if ( (*(_BYTE *)&v13->m_info & 7) == 3 )
  {
    if ( LODWORD(v13[18].m_transform.m_translate.z) )
    {
      v22 = (float)((float)(100.0 - (float)BYTE2(v13[30].m_pMat)) / WeaponInfo->m_fAccuracy) * 0.5;
      if ( (HIBYTE(v13[19].m_transform.m_heading) & 4) == 0 )
        v22 = (float)(100.0 - (float)BYTE2(v13[30].m_pMat)) / WeaponInfo->m_fAccuracy;
    }
    else
    {
      v22 = (float)(100.0 - (float)BYTE2(v13[30].m_pMat)) / WeaponInfo->m_fAccuracy;
    }
    TaskUseGun = CPedIntelligence::GetTaskUseGun((const CPedIntelligence *)LODWORD(v13[18].m_transform.m_translate.y));
    v24 = v13;
    v25 = v13;
  }
  else
  {
    v22 = 0.0;
    TaskUseGun = 0;
    v24 = 0;
    v25 = 0;
  }
  if ( (unsigned int)(v155->m_eWeaponType - 25) <= 2 )
  {
    v22 = 0.0;
    CWorld::fWeaponSpreadRate = SHOTGUN_SPREAD_RATE / WeaponInfo->m_fAccuracy;
  }
  pFiringEntity = v13;
  v26 = TaskUseGun == 0;
  v27 = pTargetEnt;
  if ( TaskUseGun )
    v26 = TaskUseGun->m_bSkipAim == 0;
  if ( !v26 )
  {
    pointsIn.x = WeaponInfo->m_fWeaponRange;
    pointsIn.y = 0.0;
    pointsIn.z = 0.0;
    AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)v13->m_pRwObject);
    v29 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, *(_DWORD *)(*(_DWORD *)&v13[19].numLodChildren + 20));
    MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
    RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &MatrixArray[v29]);
    dir.z = pointsIn.z - pShotStart.z;
    dir.y = pointsIn.y - pShotStart.y;
    dir.x = pointsIn.x - pShotStart.x;
    CVector::Normalise(&dir);
    m_pLastRenderedLink = BYTE1(v25[19].m_transform.m_heading) << 31;
    v31 = m_pLastRenderedLink == 0;
    if ( m_pLastRenderedLink )
    {
      m_pLastRenderedLink = (int)v25[23].m_pLastRenderedLink;
      v31 = m_pLastRenderedLink == 0;
    }
    if ( !v31
      || (m_pLastRenderedLink = LODWORD(v25[4].m_transform.m_heading)) != 0
      && (*(_BYTE *)(m_pLastRenderedLink + 58) & 7) == 2 )
    {
      CWorld::pIgnoreEntity = (CEntity *)m_pLastRenderedLink;
    }
LABEL_45:
    CWorld::bIncludeBikers = 1;
    CBirds::HandleGunShot(&pShotStart, (const CVector *)&pointsIn);
    CShadows::GunShotSetsOilOnFire(&pShotStart, (const CVector *)&pointsIn);
    CWorld::ProcessLineOfSight(
      &pShotStart,
      (const CVector *)&pointsIn,
      &colPoint,
      &refEntityPtr,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1);
    goto LABEL_76;
  }
  if ( !v25 )
    goto LABEL_38;
  v33 = pTargetEnt == 0;
  if ( !pTargetEnt )
    v33 = pTargetPosn == 0;
  if ( !v33 && (LODWORD(v25[22].m_transform.m_translate.z) << 31 || bCrossHairGun == 1) )
  {
    if ( pTargetPosn )
    {
      v52 = *(_QWORD *)&pTargetPosn->x;
      z = pTargetPosn->z;
LABEL_197:
      pointsIn.z = z;
      *(_QWORD *)&pointsIn.x = v52;
      goto LABEL_198;
    }
    v100 = *(_BYTE *)&pTargetEnt->m_info & 7;
    if ( v100 == 2 )
    {
      if ( CVehicle::m_pTappedGasTankVehicle == pTargetEnt )
      {
        CVehicle::GetGasTankPosition((CVector *)&posGunshell, (CVehicle *)pTargetEnt);
        v27 = pTargetEnt;
        v52 = *(_QWORD *)&posGunshell.xx;
        z = posGunshell.zx;
        goto LABEL_197;
      }
    }
    else if ( v100 == 3 )
    {
      v101 = v25[18].m_transform.m_translate.z;
      if ( v101 == 0.0 )
      {
        CPed::GetBonePosition((CPed *)pTargetEnt, &pointsIn, 3u, 0);
      }
      else
      {
        v102 = *(_QWORD *)(LODWORD(v101) + 116);
        pointsIn.z = *(RwReal *)(LODWORD(v101) + 124);
        *(_QWORD *)&pointsIn.x = v102;
        CPed::GetTransformedBonePosition((CPed *)pTargetEnt, &pointsIn, *(_DWORD *)(LODWORD(v101) + 112), 0);
      }
      v27 = pTargetEnt;
LABEL_198:
      v125 = 1.0;
      v126 = v27 == 0;
      v12.n64_u32[0] = 1008981770;
      v11.n64_f32[0] = sqrtf(
                         (float)((float)(pointsIn.z - pShotStart.z) * (float)(pointsIn.z - pShotStart.z))
                       + (float)((float)((float)(pointsIn.x - pShotStart.x) * (float)(pointsIn.x - pShotStart.x))
                               + (float)((float)(pointsIn.y - pShotStart.y) * (float)(pointsIn.y - pShotStart.y))));
      v127.n64_u64[0] = vmax_f32(v11, v12).n64_u64[0];
      v127.n64_f32[0] = 1.0 / v127.n64_f32[0];
      pointsIn.x = (float)(pointsIn.x - pShotStart.x) * v127.n64_f32[0];
      pointsIn.y = (float)(pointsIn.y - pShotStart.y) * v127.n64_f32[0];
      pointsIn.z = (float)(pointsIn.z - pShotStart.z) * v127.n64_f32[0];
      dir = (CVector)pointsIn;
      z_low = (int)WeaponInfo;
      m_fWeaponRange = WeaponInfo->m_fWeaponRange;
      if ( v27 )
        v126 = v24 == 0;
      if ( v126 )
        goto LABEL_220;
      v130 = *(_BYTE *)&v27->m_info & 7;
      if ( v130 == 3 )
      {
        z_low = (int)v27[23].m_pLastRenderedLink;
        v131 = z_low == 0;
        if ( z_low )
        {
          z_low = *(_DWORD *)(z_low + 1440);
          v131 = z_low == 9;
        }
        if ( !v131 )
          goto LABEL_219;
        m_heading = v27[4].m_transform.m_heading;
        if ( m_heading != 0.0 && (*(_BYTE *)(LODWORD(m_heading) + 58) & 7) == 2 )
        {
          z_low = *(_DWORD *)(LODWORD(m_heading) + 1440);
          if ( z_low != 9 )
            goto LABEL_219;
        }
      }
      else if ( v130 == 2 )
      {
        z_low = (int)v27[24]._vptr$CPlaceable;
        if ( z_low != 9 )
        {
LABEL_219:
          v125 = 3.0;
LABEL_220:
          v133 = v22 == 0.0;
          pointsIn.x = pShotStart.x + (float)(pointsIn.x * (float)(m_fWeaponRange * v125));
          pointsIn.y = pShotStart.y + (float)((float)(m_fWeaponRange * v125) * pointsIn.y);
          pointsIn.z = pShotStart.z + (float)((float)(m_fWeaponRange * v125) * pointsIn.z);
          if ( v22 != 0.0 )
          {
            z_low = LODWORD(v25[18].m_transform.m_translate.z);
            v133 = z_low == 0;
          }
          if ( v133 )
          {
            if ( v22 > 0.0 )
            {
              if ( pTargetEnt && (*(_BYTE *)&pTargetEnt->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)pTargetEnt) )
              {
                v10.n64_u32[0] = 1051260355;
                v9.n64_f32[0] = sqrtf(
                                  (float)((float)(pTargetEnt[1].m_transform.m_translate.z
                                                * pTargetEnt[1].m_transform.m_translate.z)
                                        + (float)(pTargetEnt[1].m_transform.m_heading
                                                * pTargetEnt[1].m_transform.m_heading))
                                + (float)(*(float *)&pTargetEnt[1].m_pMat * *(float *)&pTargetEnt[1].m_pMat));
                v22 = v22 * (float)((float)((float)(vmin_f32(v9, v10).n64_f32[0] * 0.3) / 0.33) + 0.8);
              }
              v138 = (float)rand();
              v139 = (float)rand();
              v140 = rand();
              pointsIn.x = pointsIn.x + (float)(v22 * (float)((float)((float)(v138 * 4.6566e-10) * 0.4) + -0.2));
              pointsIn.y = pointsIn.y + (float)(v22 * (float)((float)((float)(v139 * 4.6566e-10) * 0.4) + -0.2));
              pointsIn.z = (float)(v22 * (float)((float)((float)((float)v140 * 4.6566e-10) * 0.2) + -0.1)) + pointsIn.z;
            }
          }
          else
          {
            v10.n64_u32[0] = 1.0;
            v9.n64_f32[0] = fPlayerAimScaleDist / WeaponInfo->m_fWeaponRange;
            v134 = (float)(v22 * vmin_f32(v9, v10).n64_f32[0]) * (float)(fPlayerAimScale * *(float *)(z_low + 44));
            v127.n64_f32[0] = v134 * 0.5;
            v10.n64_u32[0] = 1045220557;
            v135 = vmin_f32(v127, v10).n64_f32[0];
            v136 = v135 + (float)((float)((float)rand() * 4.6566e-10) * (float)(v134 - v135));
            if ( ((unsigned __int16)TheCamera.Cams[0].Mode | 2) == 55 )
            {
              *(RwReal *)&v157 = TheCamera.Cams[0].Up.z;
              dirGunshell = *(CVector2D *)&TheCamera.Cams[0].Up.x;
              CrossProduct((CVector *)&v167, &TheCamera.Cams[0].Front, (const CVector *)&dirGunshell);
              posGunshell.zx = *(float *)&v167.m_bIsPersistent;
              p_posGunshell = (CVector *)&posGunshell;
              *(_QWORD *)&posGunshell.xx = *(_QWORD *)&v167._vptr$CEvent;
            }
            else
            {
              *(_QWORD *)&v167._vptr$CEvent = 0LL;
              *(_DWORD *)&v167.m_bIsPersistent = 1065353216;
              CrossProduct((CVector *)&dirGunshell, (const CVector *)&pointsIn, (const CVector *)&v167);
              LODWORD(posGunshell.zx) = v157;
              *(CVector2D *)&posGunshell.xx = dirGunshell;
              CVector::Normalise((CVector *)&posGunshell);
              CrossProduct((CVector *)&v167, (const CVector *)&posGunshell, (const CVector *)&pointsIn);
              LODWORD(v157) = *(_DWORD *)&v167.m_bIsPersistent;
              p_posGunshell = (CVector *)&dirGunshell;
              dirGunshell = *(CVector2D *)&v167._vptr$CEvent;
            }
            CVector::Normalise(p_posGunshell);
            x = dirGunshell.x;
            v142 = v136 * posGunshell.zx;
            y = dirGunshell.y;
            v144 = *(float *)&v157;
            v145 = v136 * posGunshell.yx;
            v146 = fPlayerAimRotRate * (float)CTimer::m_snTimeInMilliseconds;
            v147 = v136 * posGunshell.xx;
            v148 = sinf(v146);
            v149 = cosf(v146);
            pointsIn.x = (float)((float)(v136 * x) * v149) + (float)((float)(v147 * v148) + pointsIn.x);
            pointsIn.y = (float)((float)(v136 * y) * v149) + (float)((float)(v145 * v148) + pointsIn.y);
            pointsIn.z = (float)((float)(v136 * v144) * v149) + (float)((float)(v142 * v148) + pointsIn.z);
            *(float *)(LODWORD(v25[18].m_transform.m_translate.z) + 44) = *(float *)(LODWORD(v25[18].m_transform.m_translate.z)
                                                                                   + 44)
                                                                        + (float)((float)WeaponInfo->m_nDamage / 25.0);
          }
          m_heading_low = BYTE1(v25[19].m_transform.m_heading) << 31;
          v150 = m_heading_low == 0;
          if ( m_heading_low )
          {
            m_heading_low = (int)v25[23].m_pLastRenderedLink;
            v150 = m_heading_low == 0;
          }
          if ( !v150 && (*(_BYTE *)(m_heading_low + 1073) & 4) == 0
            || (m_heading_low = LODWORD(v25[4].m_transform.m_heading)) != 0
            && (*(_BYTE *)(m_heading_low + 58) & 7) == 2
            && (*(_BYTE *)(m_heading_low + 1073) & 4) == 0 )
          {
            CWorld::pIgnoreEntity = (CEntity *)m_heading_low;
          }
          if ( CPed::IsPlayer((const CPed *)v25) )
            CWorld::bIncludeDeadPeds = 1;
          goto LABEL_45;
        }
      }
      z_low = *(_BYTE *)&v24->m_info & 7;
      if ( z_low == 3 )
      {
        z_low = CPed::IsPlayer((const CPed *)v24);
        if ( z_low == 1 )
        {
          v125 = 1.0;
          z_low = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
          if ( z_low == 45 )
            v125 = 3.0;
          if ( z_low == 49 )
            v125 = 2.0;
        }
      }
      goto LABEL_220;
    }
    m_pMat = pTargetEnt->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pTargetEnt->m_transform;
    z = p_tx->m_translate.z;
    v52 = *(_QWORD *)&p_tx->m_translate.x;
    goto LABEL_197;
  }
  if ( !CPed::IsPlayer((const CPed *)v25)
    || (v34 = TheCamera.Cams[TheCamera.ActiveCam].Mode - 49, v35 = (unsigned __int16)((v34 >> 1) | (v34 << 15)), v35 > 8)
    || ((1 << v35) & 0x10D) == 0 )
  {
LABEL_38:
    m_info = (unsigned __int8)v13->m_info;
    v38 = v13->m_pMat;
    if ( (m_info & 7) == 2 )
    {
      if ( !v38 )
      {
        CPlaceable::AllocateMatrix(v13);
        CSimpleTransform::UpdateMatrix(&v13->m_transform, v13->m_pMat);
        m_info = (unsigned __int8)v13->m_info;
        v38 = v13->m_pMat;
      }
      v39 = *(_QWORD *)&v38->xy;
      pointsIn.z = v38->zy;
      *(_QWORD *)&pointsIn.x = v39;
      v40 = *(_QWORD *)&v38->xy;
      dir.z = v38->zy;
      *(_QWORD *)&dir.x = v40;
      if ( ((m_info >> 3) | 8) == 8 )
      {
        v41 = WeaponInfo->m_fWeaponRange;
        v42 = (CVehicle *)v13;
        pointsIn.x = pShotStart.x + (float)(v41 * pointsIn.x);
        pointsIn.y = pShotStart.y + (float)(v41 * pointsIn.y);
        pointsIn.z = pShotStart.z + (float)(v41 * pointsIn.z);
        v43 = LODWORD(v13[24].m_transform.m_translate.x) - 3;
        if ( (m_info & 0xF8) == 64 )
          PlayerPed = FindPlayerPed(-1);
        else
          PlayerPed = (CPlayerPed *)v42->pDriver;
        CWeapon::DoDriveByAutoAiming(PlayerPed, v42, &pShotStart, (CVector *)&pointsIn, v43 < 2);
        pointsIn.x = pointsIn.x - pShotStart.x;
        pointsIn.y = pointsIn.y - pShotStart.y;
        pointsIn.z = pointsIn.z - pShotStart.z;
        CVector::Normalise((CVector *)&pointsIn);
        m_nModelIndex = v42->m_nModelIndex;
        v54 = 0.1;
        v13 = v42;
        v57 = m_nModelIndex == 447;
        if ( m_nModelIndex != 447 )
          v57 = m_nModelIndex == 469;
        if ( !v57 )
        {
          v58 = (float *)&loc_5DC4EC;
          if ( (unsigned __int16)m_nModelIndex == 564 )
            v58 = (float *)&loc_5DC4F0;
          v54 = *v58;
        }
        p_m_fWeaponRange = &WeaponInfo->m_fWeaponRange;
      }
      else
      {
        v54 = 0.6;
        p_m_fWeaponRange = &WeaponInfo->m_fWeaponRange;
      }
      v59 = (float)rand();
      v60 = (float)rand();
      v61 = rand();
      pointsIn.x = pointsIn.x + (float)(v54 * (float)((float)((float)(v59 * 4.6566e-10) * 0.4) + -0.2));
      pointsIn.y = pointsIn.y + (float)(v54 * (float)((float)((float)(v60 * 4.6566e-10) * 0.4) + -0.2));
      pointsIn.z = (float)(v54 * (float)((float)((float)((float)v61 * 4.6566e-10) * 0.2) + -0.1)) + pointsIn.z;
      CVector::Normalise((CVector *)&pointsIn);
      v62 = *p_m_fWeaponRange;
      CWorld::pIgnoreEntity = v13;
      pointsIn.x = pShotStart.x + (float)(v62 * pointsIn.x);
      pointsIn.y = pShotStart.y + (float)(v62 * pointsIn.y);
      pointsIn.z = pShotStart.z + (float)(v62 * pointsIn.z);
      CBirds::HandleGunShot(&pShotStart, (const CVector *)&pointsIn);
      CShadows::GunShotSetsOilOnFire(&pShotStart, (const CVector *)&pointsIn);
      CWorld::ProcessLineOfSight(
        &pShotStart,
        (const CVector *)&pointsIn,
        &colPoint,
        &refEntityPtr,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        1);
    }
    else
    {
      if ( !v38 )
      {
        CPlaceable::AllocateMatrix(v13);
        CSimpleTransform::UpdateMatrix(&v13->m_transform, v13->m_pMat);
        v38 = v13->m_pMat;
      }
      v45 = WeaponInfo->m_fWeaponRange;
      v46 = v45 * v38->yy;
      v47 = v45 * v38->zy;
      pointsIn.x = (float)(v45 * v38->xy) + pos.x;
      pointsIn.y = v46 + pos.y;
      pointsIn.z = v47 + pos.z;
      if ( !v38 )
      {
        CPlaceable::AllocateMatrix(v13);
        CSimpleTransform::UpdateMatrix(&v13->m_transform, v13->m_pMat);
        v38 = v13->m_pMat;
      }
      v48 = *(_QWORD *)&v38->xy;
      dir.z = v38->zy;
      v49 = v13;
      *(_QWORD *)&dir.x = v48;
      if ( v25 )
      {
        if ( (HIBYTE(v25[19].m_pMat) & 2) != 0
          && (!CPed::IsPlayer((const CPed *)v25) || !(LOBYTE(WeaponInfo->m_nFlags) << 31)) )
        {
          CWeapon::DoDoomAiming(v13, &pShotStart, (CVector *)&pointsIn);
        }
        v49 = (CEntity *)(BYTE1(v25[19].m_transform.m_heading) << 31);
        v50 = v49 == 0;
        if ( v49 )
        {
          v49 = (CEntity *)v25[23].m_pLastRenderedLink;
          v50 = v49 == 0;
        }
        if ( v50 )
        {
          v51 = (CEntity *)LODWORD(v25[4].m_transform.m_heading);
          v49 = v13;
          if ( v51 )
          {
            if ( (*(_BYTE *)&v51->m_info & 7) != 2 )
              v51 = v13;
            v49 = v51;
          }
        }
      }
      CWorld::bIncludeBikers = 1;
      CWorld::pIgnoreEntity = v49;
      CBirds::HandleGunShot(&pShotStart, (const CVector *)&pointsIn);
      CShadows::GunShotSetsOilOnFire(&pShotStart, (const CVector *)&pointsIn);
      CWorld::ProcessLineOfSight(
        &pShotStart,
        (const CVector *)&pointsIn,
        &colPoint,
        &refEntityPtr,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        1);
    }
    goto LABEL_76;
  }
  if ( pTargetPosn )
  {
    v36 = *(_QWORD *)&pTargetPosn->x;
    pointsIn.z = pTargetPosn->z;
    *(_QWORD *)&pointsIn.x = v36;
  }
  else
  {
    CCamera::Find3rdPersonCamTargetVector(
      &TheCamera,
      WeaponInfo->m_fWeaponRange * 3.0,
      pShotStart,
      (CVector *)&posGunshell,
      (CVector *)&pointsIn);
  }
  dir.x = pointsIn.x - pShotStart.x;
  dir.y = pointsIn.y - pShotStart.y;
  dir.z = pointsIn.z - pShotStart.z;
  CVector::Normalise(&dir);
  if ( v22 != 0.0 )
  {
    v10.n64_u32[0] = 1.0;
    v9.n64_f32[0] = (float)(fPlayerAimScaleDist * 3.0) / WeaponInfo->m_fWeaponRange;
    v96 = (float)(v22 * vmin_f32(v9, v10).n64_f32[0])
        * (float)(fPlayerAimScale * *(float *)(LODWORD(v25[18].m_transform.m_translate.z) + 44));
    if ( TheCamera.Cams[0].Mode == 49 )
    {
      CCam::Get_TwoPlayer_AimVector(TheCamera.Cams, (CVector *)&v166);
      *(RwReal *)&v167.m_bIsPersistent = TheCamera.Cams[0].Up.z;
      *(_QWORD *)&v167._vptr$CEvent = *(_QWORD *)&TheCamera.Cams[0].Up.x;
      CrossProduct(&colPoint.m_vecPosition, &TheCamera.Cams[0].Front, (const CVector *)&v167);
      v99 = *(CVector2D *)&colPoint.m_vecPosition.x;
      v98 = colPoint.m_vecPosition.z;
    }
    else
    {
      v97 = TheCamera.Cams[0].Mode == 55;
      if ( TheCamera.Cams[0].Mode != 55 )
        v97 = TheCamera.Cams[0].Mode == 53;
      if ( !v97 )
      {
        *(_QWORD *)&v166._vptr$CEvent = 0LL;
        *(_DWORD *)&v166.m_bIsPersistent = 1065353216;
        CrossProduct((CVector *)&v167, (const CVector *)&pointsIn, (const CVector *)&v166);
        LODWORD(v157) = *(_DWORD *)&v167.m_bIsPersistent;
        dirGunshell = *(CVector2D *)&v167._vptr$CEvent;
        CVector::Normalise((CVector *)&dirGunshell);
        CrossProduct((CVector *)&v166, (const CVector *)&dirGunshell, (const CVector *)&pointsIn);
        *(_DWORD *)&v167.m_bIsPersistent = *(_DWORD *)&v166.m_bIsPersistent;
        p_dirGunshell = (CVector *)&v167;
        *(_QWORD *)&v167._vptr$CEvent = *(_QWORD *)&v166._vptr$CEvent;
LABEL_158:
        CVector::Normalise(p_dirGunshell);
        v104 = v167._vptr$CEvent;
        v105 = v96 * *(float *)&v157;
        m_iAccumulatedTime = v167.m_iAccumulatedTime;
        v107 = *(float *)&v167.m_bIsPersistent;
        v108 = v96 * dirGunshell.y;
        v109 = fPlayerAimRotRate * (float)CTimer::m_snTimeInMilliseconds;
        v110 = v96 * dirGunshell.x;
        v111 = sinf(v109);
        v112 = cosf(v109);
        pointsIn.x = (float)((float)(v96 * *(float *)&v104) * v112) + (float)((float)(v110 * v111) + pointsIn.x);
        pointsIn.y = (float)((float)(v96 * *(float *)&m_iAccumulatedTime) * v112)
                   + (float)((float)(v108 * v111) + pointsIn.y);
        pointsIn.z = (float)((float)(v96 * v107) * v112) + (float)((float)(v105 * v111) + pointsIn.z);
        *(float *)(LODWORD(v25[18].m_transform.m_translate.z) + 44) = *(float *)(LODWORD(v25[18].m_transform.m_translate.z)
                                                                               + 44)
                                                                    + (float)((float)WeaponInfo->m_nDamage / 25.0);
        goto LABEL_159;
      }
      *(RwReal *)&v167.m_bIsPersistent = TheCamera.Cams[0].Up.z;
      *(_QWORD *)&v167._vptr$CEvent = *(_QWORD *)&TheCamera.Cams[0].Up.x;
      CrossProduct((CVector *)&v166, &TheCamera.Cams[0].Front, (const CVector *)&v167);
      v98 = *(float *)&v166.m_bIsPersistent;
      v99 = *(CVector2D *)&v166._vptr$CEvent;
    }
    *(RwReal *)&v157 = v98;
    p_dirGunshell = (CVector *)&dirGunshell;
    dirGunshell = v99;
    goto LABEL_158;
  }
LABEL_159:
  v114 = BYTE1(v25[19].m_transform.m_heading) << 31;
  v113 = v114 == 0;
  if ( v114 )
  {
    v114 = (int)v25[23].m_pLastRenderedLink;
    v113 = v114 == 0;
  }
  if ( v113 || (*(_BYTE *)(v114 + 1073) & 4) != 0 )
  {
    v114 = LODWORD(v25[4].m_transform.m_heading);
    if ( v114 && (*(_BYTE *)(v114 + 58) & 7) == 2 )
    {
      if ( (*(_BYTE *)(v114 + 1073) & 4) != 0 )
        v114 = (int)v13;
    }
    else
    {
      v114 = (int)v13;
    }
  }
  CWorld::bIncludeCarTyres = 1;
  CWorld::bIncludeDeadPeds = 1;
  CWorld::pIgnoreEntity = (CEntity *)v114;
  CWorld::bIncludeBikers = 1;
  CBirds::HandleGunShot((const CVector *)&posGunshell, (const CVector *)&pointsIn);
  CShadows::GunShotSetsOilOnFire((const CVector *)&posGunshell, (const CVector *)&pointsIn);
  CWorld::ProcessLineOfSight(
    (const CVector *)&posGunshell,
    (const CVector *)&pointsIn,
    &colPoint,
    &refEntityPtr,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1);
  v116 = *(float *)&refEntityPtr;
  if ( *(float *)&refEntityPtr != 0.0 )
  {
    v117 = 1.0;
    v118 = sqrtf(
             (float)((float)(colPoint.m_vecPosition.x - posGunshell.xx)
                   * (float)(colPoint.m_vecPosition.x - posGunshell.xx))
           + (float)((float)(colPoint.m_vecPosition.y - posGunshell.yx)
                   * (float)(colPoint.m_vecPosition.y - posGunshell.yx)));
    if ( !v24 )
      goto LABEL_189;
    v119 = *(_BYTE *)&refEntityPtr->m_info & 7;
    if ( v119 == 3 )
    {
      v120 = refEntityPtr[23].m_pLastRenderedLink;
      v121 = v120 == 0;
      if ( v120 )
        v121 = v120[120].item == (CEntity *)byte_9;
      if ( !v121 )
        goto LABEL_188;
      v116 = refEntityPtr[4].m_transform.m_heading;
      if ( v116 == 0.0 || (*(_BYTE *)(LODWORD(v116) + 58) & 7) != 2 )
      {
LABEL_181:
        if ( (*(_BYTE *)&v24->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v24) )
        {
          v117 = 1.0;
          Mode = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
          if ( Mode == 45 )
            v117 = 3.0;
          if ( Mode == 49 )
            v117 = 2.0;
        }
        goto LABEL_189;
      }
    }
    else if ( v119 != 2 )
    {
      goto LABEL_181;
    }
    if ( *(_DWORD *)(LODWORD(v116) + 1440) != 9 )
    {
LABEL_188:
      v117 = 3.0;
LABEL_189:
      if ( v118 <= (float)(v117 * WeaponInfo->m_fWeaponRange) )
      {
        if ( *(float *)&refEntityPtr != 0.0 )
          CWeapon::CheckForShootingVehicleOccupant(
            &refEntityPtr,
            &colPoint,
            v115,
            (const CVector *)&posGunshell,
            (const CVector *)&pointsIn);
      }
      else
      {
        *(float *)&refEntityPtr = 0.0;
      }
      goto LABEL_76;
    }
    goto LABEL_181;
  }
LABEL_76:
  v63 = 0;
  v64 = pShotStart.y;
  if ( v155->m_eWeaponType == WEAPONTYPE_TEARGAS )
    v63 = 1;
  v65 = (v155->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED) | v63;
  v66 = pShotStart.x;
  bCheckBuildings.x = pShotStart.z;
  CEventGunShot::CEventGunShot(&v167, pFiringEntity, *(CVector *)(&v64 - 1), (CVector)pointsIn, v65);
  EventGlobalGroup = GetEventGlobalGroup();
  CEventGroup::Add(EventGlobalGroup, (CEvent *)&v167, 0);
  CEventGunShotWhizzedBy::CEventGunShotWhizzedBy(
    &v166,
    pFiringEntity,
    &pShotStart,
    (const CVector *)&pointsIn,
    v155->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED);
  v68 = GetEventGlobalGroup();
  CEventGroup::Add(v68, (CEvent *)&v166, 0);
  v69 = pFiringEntity;
  CInterestingEvents::Add(&g_InterestingEvents, EGunshotFired, pFiringEntity);
  v70 = *(_QWORD *)&pStartPosn->x;
  pShotStart.z = pStartPosn->z;
  *(_QWORD *)&pShotStart.x = v70;
  if ( bCreateGunFx == 1 )
  {
    v71 = 1050253722;
    v72 = 0.2;
    switch ( v155->m_eWeaponType )
    {
      case WEAPONTYPE_PISTOL:
      case WEAPONTYPE_PISTOL_SILENCED:
      case WEAPONTYPE_DESERT_EAGLE:
      case WEAPONTYPE_SNIPERRIFLE:
        v71 = 0.25;
        goto LABEL_84;
      case WEAPONTYPE_SHOTGUN:
      case WEAPONTYPE_SAWNOFF_SHOTGUN:
      case WEAPONTYPE_SPAS12_SHOTGUN:
        v71 = 1055286886;
        v72 = 0.3;
        goto LABEL_84;
      case WEAPONTYPE_MICRO_UZI:
      case WEAPONTYPE_MP5:
      case WEAPONTYPE_TEC9:
        goto LABEL_84;
      case WEAPONTYPE_AK47:
      case WEAPONTYPE_M4:
      case WEAPONTYPE_MINIGUN:
        v71 = 0.25;
        v72 = 0.65;
        if ( (int)(float)((float)(WeaponInfo->m_animLoopEnd - WeaponInfo->m_animLoopStart) * 900.0) > 49
          || (++CWeapon::FireInstantHit(CEntity *,CVector *,CVector *,CEntity *,CVector *,CVector *,bool,bool)::counter,
              (CWeapon::FireInstantHit(CEntity *,CVector *,CVector *,CEntity *,CVector *,CVector *,bool,bool)::counter & 1) == 0) )
        {
LABEL_84:
          v73 = 0;
          memset(&bCheckBuildings, 0, sizeof(bCheckBuildings));
          CPointLights::AddLight(0, pos, bCheckBuildings, 3.0, 0.25, 0.22, 0.0, 0, 0, 0);
          if ( (*(_BYTE *)&pFiringEntity->m_info & 7) == 3 )
          {
            if ( !pFiringEntity[21].m_pRwObject )
              v73 = 1;
          }
          else
          {
            v73 = 1;
          }
          Fx_c::TriggerGunshot(&g_fx, pFiringEntity, &pos, &dir, v73);
          posGunshell.xx = pos.x - (float)(v72 * dir.x);
          posGunshell.yx = pos.y - (float)(v72 * dir.y);
          posGunshell.zx = pos.z - (float)(v72 * dir.z);
          v74 = (CVector2D *)pFiringEntity->m_pMat;
          if ( !v74 )
          {
            CPlaceable::AllocateMatrix(pFiringEntity);
            CSimpleTransform::UpdateMatrix(&pFiringEntity->m_transform, pFiringEntity->m_pMat);
            v74 = (CVector2D *)pFiringEntity->m_pMat;
          }
          dirGunshell = *v74;
          v69 = pFiringEntity;
          CWeapon::AddGunshell(v155, pFiringEntity, (const CVector *)&posGunshell, &dirGunshell, *(float *)&v71);
        }
        break;
      default:
        break;
    }
  }
  if ( pTargetEnt )
  {
    if ( (unsigned __int8)((*(_BYTE *)&pTargetEnt->m_info & 7) - 2) > 2u
      || !(BYTE1(pTargetEnt[1].m_transform.m_translate.y) << 31) )
    {
      goto LABEL_107;
    }
    goto LABEL_101;
  }
  if ( v25 && CPed::IsPlayer((const CPed *)v25) && pointsIn.z < pShotStart.z
    || ((*(_BYTE *)&v69->m_info >> 3) | 8) == 8 && pointsIn.z < pShotStart.z )
  {
LABEL_101:
    if ( *(float *)&refEntityPtr == 0.0 )
      goto LABEL_104;
    if ( CWaterLevel::TestLineAgainstWater(pShotStart, colPoint.m_vecPosition, (CVector *)&posGunshell) )
    {
LABEL_105:
      Fx_c::TriggerBulletSplash(&g_fx, (CVector *)&posGunshell);
      CAudioEngine::ReportBulletHit(&AudioEngine, 0, 0x27u, (CVector *)&posGunshell, 0.0);
      goto LABEL_106;
    }
    if ( *(float *)&refEntityPtr == 0.0 )
    {
LABEL_104:
      if ( ((int (__fastcall *)(CVector, CVector, CVector *))CWaterLevel::TestLineAgainstWater)(
             pShotStart,
             (CVector)pointsIn,
             (CVector *)&posGunshell) == 1 )
        goto LABEL_105;
    }
LABEL_106:
    v69 = pFiringEntity;
  }
LABEL_107:
  v75 = refEntityPtr;
  if ( CWorld::fWeaponSpreadRate > 0.0
    && *(float *)&refEntityPtr != 0.0
    && ((*(_BYTE *)&refEntityPtr->m_info & 7) != 2 || (unsigned __int8)(colPoint.m_dataB.m_nPieceType - 13) >= 4u) )
  {
    v76.x = 1.0;
    v76.y = 1.0;
    *(float *)&v77 = 1.0;
    *((float *)&v77 + 1) = 1.0;
    v78 = 0;
    v79 = v69;
    while ( 1 )
    {
      WeaponInfo = v78;
      v80 = &SHOTGUN_NUM_PELLETS;
      if ( v155->m_eWeaponType == WEAPONTYPE_SPAS12_SHOTGUN )
        v80 = &SPAS_NUM_PELLETS;
      v81 = *v80;
      posGunshell.m_pRwMat = 0;
      posGunshell.m_owner = 0;
      CWeapon::SetUpPelletCol(
        (CWeapon *)&colPoint,
        v81,
        v79,
        v75,
        &pShotStart.x,
        &colPoint.m_vecPosition.x,
        (int)&posGunshell);
      dirGunshell = v76;
      v157 = v77;
      v82 = v79;
      v158 = v76;
      v159 = v77;
      v160 = v76;
      v161 = v77;
      v162 = 1065353216;
      v163 = 1065353216;
      v164 = 1065353216;
      if ( (*(_BYTE *)&refEntityPtr->m_info & 7) == 3 )
        ColModel = CPedModelInfo::AnimatePedColModelSkinned(
                     (CPedModelInfo *)CModelInfo::ms_modelInfoPtrs[refEntityPtr->m_nModelIndex],
                     (RpClump_0 *)refEntityPtr->m_pRwObject);
      else
        ColModel = CEntity::GetColModel(refEntityPtr);
      v84 = refEntityPtr;
      v85 = ColModel;
      v86 = refEntityPtr->m_pMat;
      if ( !v86 )
      {
        CPlaceable::AllocateMatrix(refEntityPtr);
        CSimpleTransform::UpdateMatrix(&v84->m_transform, v84->m_pMat);
        v86 = v84->m_pMat;
      }
      v87 = 0;
      CCollision::ProcessColModels(
        &posGunshell,
        &CWeapon::ms_PelletTestCol,
        v86,
        v85,
        CWorld::m_aTempColPts,
        CWorld::m_aTempColPts,
        &dirGunshell.x,
        0);
      if ( v81 < 1 )
      {
        v79 = v82;
      }
      else
      {
        v88 = &dirGunshell;
        v89 = 0;
        v87 = 0;
        for ( i = 0; i != v81; ++i )
        {
          v91 = v88->x;
          v88 = (CVector2D *)((char *)v88 + 4);
          if ( v91 < 1.0 )
          {
            v89 = i;
            ++v87;
          }
        }
        v92 = CWorld::m_aTempColPts;
        v93 = &dirGunshell;
        v94 = v81;
        do
        {
          if ( v93->x < 1.0 )
          {
            if ( v89 )
              CWeapon::DoBulletImpact(v155, pFiringEntity, refEntityPtr, &pos, &v92->m_vecPosition, v92, 1);
            else
              CWeapon::DoBulletImpact(v155, pFiringEntity, refEntityPtr, &pos, &v92->m_vecPosition, v92, -v87);
          }
          --v94;
          ++v92;
          --v89;
          v93 = (CVector2D *)((char *)v93 + 4);
        }
        while ( v94 );
        v79 = pFiringEntity;
      }
      v78 = (CWeaponInfo *)((char *)&WeaponInfo->m_eFireType + 1);
      if ( (*(_BYTE *)&refEntityPtr->m_info & 6) == 2 )
      {
        if ( dirGunshell.x == 1.0 )
        {
          if ( (int)WeaponInfo <= 0 )
            goto LABEL_140;
        }
        else if ( (int)WeaponInfo <= 0 && (float)((float)v87 / (float)v81) < 0.5 )
        {
LABEL_140:
          pShotStart = colPoint.m_vecPosition;
          CWorld::pIgnoreEntity = refEntityPtr;
          *(float *)&refEntityPtr = 0.0;
          CBirds::HandleGunShot(&pShotStart, (const CVector *)&pointsIn);
          CShadows::GunShotSetsOilOnFire(&pShotStart, (const CVector *)&pointsIn);
          CWorld::ProcessLineOfSight(
            &pShotStart,
            (const CVector *)&pointsIn,
            &colPoint,
            &refEntityPtr,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1);
          goto LABEL_141;
        }
        *(float *)&refEntityPtr = 0.0;
      }
      else
      {
        CWeapon::DoBulletImpact(v155, v79, refEntityPtr, &pos, (CVector *)&pointsIn, &colPoint, 0);
        *(float *)&refEntityPtr = 0.0;
      }
LABEL_141:
      CMatrix::~CMatrix(&posGunshell);
      v75 = refEntityPtr;
      if ( *(float *)&refEntityPtr == 0.0 )
        goto LABEL_142;
    }
  }
  CWeapon::DoBulletImpact(v155, v69, refEntityPtr, &pos, (CVector *)&pointsIn, &colPoint, 0);
LABEL_142:
  CWorld::ResetLineTestOptions();
  CEventGunShotWhizzedBy::~CEventGunShotWhizzedBy(&v166);
  CEventGunShotWhizzedBy::~CEventGunShotWhizzedBy(&v167);
  return 1;
}
// 5DCC4C: conditional instruction was optimized away because r8.4>=1
// 5DC178: fragmented variable at r3.4 may be wrong
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005DD740) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __fastcall CWeapon::FireSniper(CWeapon *this, CPed *pEntity, CEntity *pTargetEnt, CVector *pTargetPosn)
{
  bool result; // r0
  char *v7; // r0
  float v8; // s2
  float v9; // s0
  __int64 v10; // d16
  float v11; // s4
  __int64 v12; // d16
  unsigned int m_nPedType; // r0
  CPad *Pad; // r8
  CPlayerPed *PlayerPed; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  float v18; // r6
  CPlayerPed *v19; // r0
  CMatrix *v20; // r1
  CSimpleTransform *p_m_transform; // r2
  float v22; // s16
  CPlayerPed *v23; // r0
  CMatrix *v24; // r1
  CSimpleTransform *v25; // r2
  int v26; // r0
  CPed *v27; // r1
  RwReal v28; // r2
  char v29; // r6
  RwReal x; // r2
  RwReal v31; // r3
  float v32; // s22
  float v33; // s18
  float z; // s20
  CEventGlobalGroup *EventGlobalGroup; // r0
  char v36; // r1
  CEventGlobalGroup *v37; // r0
  RwReal Y; // [sp+0h] [bp-D0h]
  CVector v39; // [sp+4h] [bp-CCh]
  CVector vShotTarget; // [sp+14h] [bp-BCh] BYREF
  CEventGunShotWhizzedBy v41; // [sp+20h] [bp-B0h] BYREF
  CEventGunShot v42; // [sp+50h] [bp-80h] BYREF
  CVector vShotOrigin; // [sp+80h] [bp-50h] BYREF
  CVector v44; // [sp+90h] [bp-40h] BYREF

  if ( FindPlayerPed(-1) != pEntity )
  {
LABEL_3:
    CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
    v7 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
    v8 = *((float *)v7 + 182) * 0.0;
    v9 = *((float *)v7 + 183) * -0.9894;
    v10 = *(_QWORD *)(v7 + 740);
    v11 = *((float *)v7 + 184) * 0.145;
    vShotOrigin.z = *((RwReal *)v7 + 187);
    *(_QWORD *)&vShotOrigin.x = v10;
    v12 = *((_QWORD *)v7 + 91);
    v44.z = *((RwReal *)v7 + 184);
    *(_QWORD *)&v44.x = v12;
    if ( (float)((float)(v8 + v9) + v11) > 0.997 )
      CCoronas::MoonSize = (CCoronas::MoonSize + 1) & 7;
    CVector::Normalise(&v44);
    v44.x = v44.x * 16.0;
    v44.y = v44.y * 16.0;
    v44.z = v44.z * 16.0;
    CBulletInfo::AddBullet(
      (int)pEntity,
      this->m_eWeaponType,
      SLODWORD(vShotOrigin.x),
      SLODWORD(vShotOrigin.y),
      SLODWORD(vShotOrigin.z),
      SLODWORD(v44.x),
      SLODWORD(v44.y),
      SLODWORD(v44.z));
    m_nPedType = pEntity->m_nPedType;
    if ( m_nPedType <= 1 )
    {
      Pad = CPad::GetPad(m_nPedType);
      PlayerPed = FindPlayerPed(-1);
      m_pMat = PlayerPed->m_pMat;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &PlayerPed->m_transform.m_translate.x;
      v18 = *p_tx;
      v19 = FindPlayerPed(-1);
      v20 = v19->m_pMat;
      p_m_transform = (CSimpleTransform *)&v20->tx;
      if ( !v20 )
        p_m_transform = &v19->m_transform;
      v22 = p_m_transform->m_translate.y;
      v23 = FindPlayerPed(-1);
      v24 = v23->m_pMat;
      v25 = (CSimpleTransform *)&v24->tx;
      if ( !v24 )
        v25 = &v23->m_transform;
      CPad::StartShake_Distance(Pad, 240, 0x80u, v18, v22, v25->m_translate.z);
      CamShakeNoPos(&TheCamera, 0.2);
    }
    v26 = *(_BYTE *)&pEntity->m_info & 7;
    if ( v26 == 2 )
    {
      v28 = pEntity->m_storedCollPoly.V2.y;
      if ( v28 != 0.0 )
      {
        v27 = pEntity;
        goto LABEL_18;
      }
    }
    else if ( v26 == 3 )
    {
      v27 = pEntity;
      v28 = *(float *)&pEntity;
LABEL_18:
      CCrime::ReportCrime(CRIME_POSSESSION_GUN, v27, (CPed *)LODWORD(v28));
    }
    v29 = 0;
    x = vShotOrigin.x;
    v31 = vShotOrigin.y;
    v32 = vShotOrigin.y;
    v33 = vShotOrigin.x;
    z = vShotOrigin.z;
    if ( this->m_eWeaponType == WEAPONTYPE_TEARGAS )
      v29 = 1;
    Y = vShotOrigin.z;
    v39.x = (float)(v44.x * 40.0) + vShotOrigin.x;
    v39.y = (float)(v44.y * 40.0) + vShotOrigin.y;
    v39.z = (float)(v44.z * 40.0) + vShotOrigin.z;
    CEventGunShot::CEventGunShot(
      &v42,
      pEntity,
      *(CVector *)&x,
      v39,
      (this->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED) | v29);
    EventGlobalGroup = GetEventGlobalGroup();
    CEventGroup::Add(EventGlobalGroup, (CEvent *)&v42, 0);
    CVector::Normalise(&v44);
    v36 = 0;
    vShotTarget.x = (float)(v44.x * 40.0) + v33;
    vShotTarget.y = (float)(v44.y * 40.0) + v32;
    vShotTarget.z = (float)(v44.z * 40.0) + z;
    if ( this->m_eWeaponType == WEAPONTYPE_TEARGAS )
      v36 = 1;
    CEventGunShotWhizzedBy::CEventGunShotWhizzedBy(
      &v41,
      pEntity,
      &vShotOrigin,
      &vShotTarget,
      (this->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED) | v36);
    v37 = GetEventGlobalGroup();
    CEventGroup::Add(v37, (CEvent *)&v41, 0);
    CInterestingEvents::Add(&g_InterestingEvents, EGunshotFired, pEntity);
    CEventGunShotWhizzedBy::~CEventGunShotWhizzedBy(&v41);
    CEventGunShotWhizzedBy::~CEventGunShotWhizzedBy(&v42);
    return 1;
  }
  result = 0;
  switch ( TheCamera.Cams[TheCamera.ActiveCam].Mode )
  {
    case 7:
    case 8:
    case 0x22:
    case 0x27:
    case 0x28:
    case 0x2A:
    case 0x2E:
    case 0x33:
    case 0x34:
      goto LABEL_3;
    default:
      return result;
  }
  return result;
}
// 5DD740: fragmented variable at r2.4 may be wrong
// 5DD740: fragmented variable at r3.4 may be wrong

//----- (005DDA78) --------------------------------------------------------
bool __fastcall CWeapon::FireM16_1stPerson(CWeapon *this, CPed *pEntity)
{
  bool result; // r0
  CWeaponInfo *WeaponInfo; // r8
  float v6; // s16
  char *v7; // r0
  float v8; // s0
  float v9; // s2
  __int64 v10; // d16
  float v11; // s4
  float m_fWeaponRange; // s6
  CEntity *v13; // r6
  eWeaponType v14; // r2
  float m_heading; // r0
  float v16; // s18
  int v17; // r1
  CLink<CEntity *> *m_pLastRenderedLink; // r1
  bool v19; // zf
  int Mode; // r0
  int *v21; // r1
  float v22; // s16
  double v23; // d17
  unsigned int v24; // r5
  unsigned int v25; // r4
  CPad *Pad; // r0
  CEntity *refEntityPtr; // [sp+20h] [bp-80h] BYREF
  CColPoint colPoint; // [sp+24h] [bp-7Ch] BYREF
  CVector pShotStart; // [sp+50h] [bp-50h] BYREF
  CVector pShotEnd; // [sp+5Ch] [bp-44h] BYREF

  result = 0;
  switch ( TheCamera.Cams[TheCamera.ActiveCam].Mode )
  {
    case 7:
    case 8:
    case 0x22:
    case 0x27:
    case 0x28:
    case 0x2A:
    case 0x2D:
    case 0x2E:
    case 0x33:
    case 0x34:
      WeaponInfo = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
      v6 = 3.0;
      v7 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
      v8 = *((float *)v7 + 182) * 3.0;
      v9 = *((float *)v7 + 183) * 3.0;
      v10 = *(_QWORD *)(v7 + 740);
      v11 = *((float *)v7 + 184) * 3.0;
      pShotStart.z = *((RwReal *)v7 + 187);
      *(_QWORD *)&pShotStart.x = v10;
      m_fWeaponRange = WeaponInfo->m_fWeaponRange;
      CWorld::bIncludeCarTyres = 1;
      CWorld::pIgnoreEntity = pEntity;
      CWorld::bIncludeBikers = 1;
      CWorld::bIncludeDeadPeds = 1;
      pShotEnd.z = (float)(v11 * m_fWeaponRange) + pShotStart.z;
      pShotEnd.y = (float)(v9 * m_fWeaponRange) + *((float *)&v10 + 1);
      pShotEnd.x = *(float *)&v10 + (float)(v8 * m_fWeaponRange);
      CBirds::HandleGunShot(&pShotStart, &pShotEnd);
      CShadows::GunShotSetsOilOnFire(&pShotStart, &pShotEnd);
      v13 = 0;
      if ( CWorld::ProcessLineOfSight(&pShotStart, &pShotEnd, &colPoint, &refEntityPtr, 1, 1, 1, 1, 1, 0, 0, 1) == 1 )
        CWeapon::CheckForShootingVehicleOccupant(&refEntityPtr, &colPoint, v14, &pShotStart, &pShotEnd);
      m_heading = *(float *)&refEntityPtr;
      CWorld::bIncludeCarTyres = 0;
      CWorld::bIncludeDeadPeds = 0;
      CWorld::bIncludeBikers = 0;
      CWorld::pIgnoreEntity = 0;
      if ( !refEntityPtr )
        goto LABEL_27;
      v16 = sqrtf(
              (float)((float)(colPoint.m_vecPosition.x - pShotStart.x) * (float)(colPoint.m_vecPosition.x - pShotStart.x))
            + (float)((float)(colPoint.m_vecPosition.y - pShotStart.y) * (float)(colPoint.m_vecPosition.y - pShotStart.y)));
      if ( !pEntity )
        goto LABEL_23;
      v17 = *(_BYTE *)&refEntityPtr->m_info & 7;
      if ( v17 != 3 )
      {
        if ( v17 != 2 )
          goto LABEL_16;
        goto LABEL_8;
      }
      m_pLastRenderedLink = refEntityPtr[23].m_pLastRenderedLink;
      v19 = m_pLastRenderedLink == 0;
      if ( m_pLastRenderedLink )
        v19 = m_pLastRenderedLink[120].item == (CEntity *)byte_9;
      if ( !v19 )
        goto LABEL_24;
      m_heading = refEntityPtr[4].m_transform.m_heading;
      if ( m_heading != 0.0 && (*(_BYTE *)(LODWORD(m_heading) + 58) & 7) == 2 )
      {
LABEL_8:
        if ( *(_DWORD *)(LODWORD(m_heading) + 1440) != 9 )
          goto LABEL_24;
      }
LABEL_16:
      if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
      {
        v6 = 1.0;
        if ( CPed::IsPlayer(pEntity) )
        {
          v6 = 1.0;
          Mode = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
          if ( Mode == 45 )
            v6 = 3.0;
          if ( Mode == 49 )
            v6 = 2.0;
        }
      }
      else
      {
LABEL_23:
        v6 = 1.0;
      }
LABEL_24:
      if ( v16 <= (float)(v6 * WeaponInfo->m_fWeaponRange) )
      {
        v13 = refEntityPtr;
      }
      else
      {
        v13 = 0;
        refEntityPtr = 0;
      }
LABEL_27:
      CWeapon::DoBulletImpact(this, pEntity, v13, &pShotStart, &pShotEnd, &colPoint, 0);
      if ( pEntity->m_nPedType <= 1u )
      {
        v21 = dword_5DDEB0;
        if ( this->m_eWeaponType == WEAPONTYPE_M4 )
          v21 = &dword_5DDEB0[1];
        v22 = *(float *)v21;
        if ( this->m_eWeaponType == WEAPONTYPE_AK47 )
          v22 = 0.00015;
        if ( (*((_BYTE *)&FindPlayerPed(-1)->m_nPedFlags + 3) & 4) != 0 || FindPlayerPed(-1)->m_pAttachToEntity )
          v22 = v22 * 0.3;
        TheCamera.Cams[TheCamera.ActiveCam].Beta = TheCamera.Cams[TheCamera.ActiveCam].Beta
                                                 + (float)(v22 * (float)((rand() & 0x7F) - 64));
        TheCamera.Cams[TheCamera.ActiveCam].Alpha = TheCamera.Cams[TheCamera.ActiveCam].Alpha
                                                  + (float)(v22 * (float)((rand() & 0x7F) - 64));
        v23 = (20.0 - (double)(int)(float)((float)(WeaponInfo->m_animLoopEnd - WeaponInfo->m_animLoopStart) * 900.0))
            / 80.0;
        if ( v23 < 0.0 || v23 <= 1.0 )
        {
          if ( v23 >= 0.0 )
            v24 = (unsigned int)(v23 * 80.0 + 130.0);
          else
            v24 = 130;
        }
        else
        {
          v24 = 210;
        }
        v25 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep * 20000.0) / (float)v24);
        Pad = CPad::GetPad(pEntity->m_nPedType);
        CPad::StartShake(Pad, v25, v24, 0);
      }
      return 1;
    default:
      return result;
  }
}
// 5DDBF2: variable 'v14' is possibly undefined
// 54: using guessed type int dword_54;
// 5DDEB0: using guessed type int dword_5DDEB0[2];

//----- (005DDECC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall CWeapon::FireProjectile(
        CWeapon *this,
        CEntity *pEntity,
        CVector *pPosn,
        CEntity *pTargetEnt,
        CVector *pTargetPosn,
        float fThrowForce)
{
  CWeapon *v6; // r8
  CVector *p_m_translate; // r4
  eWeaponType m_eWeaponType; // r10
  __int64 v11; // d16
  int v13; // r8
  int v14; // r6
  CVector *p_xy; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  float v18; // s18
  float v19; // s20
  float v20; // s16
  float xy; // s0
  float yy; // s2
  float zy; // s4
  float v24; // s6
  float v25; // s16
  CMatrix *v26; // r0
  RwReal v27; // s6
  RwReal v28; // s2
  float z; // s0
  CMatrix *v30; // r0
  float y; // s2
  float v32; // s4
  RwReal v33; // r6
  int IsLockedOn; // r0
  bool v35; // zf
  CMatrix *v36; // r0
  CSimpleTransform *v37; // r1
  RwReal x; // r5
  CEntity *v39; // r0
  __int64 v40; // d16
  CSimpleTransform *p_tx; // r1
  RwReal v42; // s6
  RwReal v43; // s2
  CSimpleTransform *v44; // r1
  float v45; // s16
  float v46; // s18
  float v47; // s20
  float v48; // s0
  float v49; // s4
  float v50; // s2
  float v51; // s16
  CMatrix *v52; // r0
  RwReal v53; // s0
  RwReal v54; // s2
  bool v55; // zf
  __int64 v56; // d16
  CEntity *v57; // r5
  bool v58; // zf
  CSimpleTransform *v59; // r0
  CMatrix *v60; // r1
  int v61; // s2
  float v62; // s4
  __int64 v63; // r2
  eWeaponType v64; // r1
  RwReal v65; // r0
  bool v66; // zf
  CMatrix *v67; // r0
  CSimpleTransform *v68; // r6
  float v69; // s4
  RwReal v70; // s2
  int v71; // r0
  CEntity *v72; // r2
  CLink<CEntity *> *m_pLastRenderedLink; // r2
  CMatrix *v74; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  CSimpleTransform *v77; // r0
  CMatrix *v78; // r1
  int v79; // s2
  float v80; // s4
  _BOOL4 IsLineOfSightClear; // r0
  RwReal bCheckPeds; // [sp+0h] [bp-B0h]
  CVector *Tolerance; // [sp+8h] [bp-A8h]
  CEntity *v84; // [sp+Ch] [bp-A4h]
  RwReal v85; // [sp+20h] [bp-90h]
  CEntity *y_low; // [sp+24h] [bp-8Ch]
  CEventGunShot v88; // [sp+28h] [bp-88h] BYREF
  CVector vecEnd; // [sp+58h] [bp-58h] BYREF
  CVector vecStart; // [sp+68h] [bp-48h] BYREF
  CVector v91; // 0:r0.12
  CVector v92; // 0:r0.12
  CVector v93; // 0:r3.4,4:^0.8

  v6 = this;
  p_m_translate = pTargetPosn;
  m_eWeaponType = this->m_eWeaponType;
  if ( (unsigned int)(this->m_eWeaponType - 35) > 1 )
  {
    m_pMat = pEntity->m_pMat;
    p_m_transform = &pEntity->m_transform;
    if ( m_pMat )
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    v18 = pPosn->x - p_m_transform->m_translate.x;
    v19 = pPosn->y - p_m_transform->m_translate.y;
    v20 = pPosn->z - p_m_transform->m_translate.z;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
    v24 = (float)((float)(v18 * xy) + (float)(v19 * yy)) + (float)(v20 * zy);
    if ( v24 >= 0.3 )
    {
      z = pPosn->z;
    }
    else
    {
      v25 = 0.3 - v24;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v26 = pEntity->m_pMat;
        xy = v26->xy;
        yy = v26->yy;
        zy = v26->zy;
      }
      v27 = (float)(v25 * xy) + pPosn->x;
      v28 = (float)(v25 * yy) + pPosn->y;
      z = (float)(v25 * zy) + pPosn->z;
      pPosn->x = v27;
      pPosn->y = v28;
      pPosn->z = z;
      m_pMat = pEntity->m_pMat;
    }
    v40 = *(_QWORD *)&pPosn->x;
    vecEnd.z = pPosn->z;
    p_tx = &pEntity->m_transform;
    *(_QWORD *)&vecEnd.x = v40;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( (float)(z - p_tx->m_translate.z) > 0.0 )
    {
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        m_pMat = pEntity->m_pMat;
        z = pPosn->z;
      }
      v42 = (float)(m_pMat->yy * 0.6) + vecEnd.y;
      v43 = (float)(m_pMat->zy * 0.6) + vecEnd.z;
      vecEnd.x = (float)(m_pMat->xy * 0.6) + vecEnd.x;
      vecEnd.y = v42;
      vecEnd.z = v43;
    }
    v44 = &pEntity->m_transform;
    if ( m_pMat )
      v44 = (CSimpleTransform *)&m_pMat->tx;
    v45 = pPosn->x - v44->m_translate.x;
    v46 = pPosn->y - v44->m_translate.y;
    v47 = z - v44->m_translate.z;
    vecStart.y = v46;
    vecStart.x = v45;
    vecStart.z = v47;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    v48 = m_pMat->xy;
    v49 = m_pMat->yy;
    v50 = m_pMat->zy;
    v51 = (float)((float)(v45 * v48) + (float)(v46 * v49)) + (float)(v47 * v50);
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v52 = pEntity->m_pMat;
      v48 = v52->xy;
      v49 = v52->yy;
      v50 = v52->zy;
    }
    v53 = pPosn->x - (float)(v51 * v48);
    v54 = pPosn->z - (float)(v51 * v50);
    vecStart.y = pPosn->y - (float)(v51 * v49);
    vecStart.x = v53;
    vecStart.z = v54;
LABEL_56:
    CWorld::pIgnoreEntity = pEntity;
    if ( CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 1, 0, 1, 0, 0, 0) )
    {
      v57 = pTargetEnt;
      if ( m_eWeaponType != WEAPONTYPE_ROCKET )
        goto LABEL_76;
      v58 = p_m_translate == 0;
      if ( !p_m_translate )
        v58 = pTargetEnt == 0;
      if ( v58 )
      {
LABEL_76:
        v63 = *(_QWORD *)&pPosn->x;
        v65 = pPosn->z;
        Tolerance = 0;
        v84 = pTargetEnt;
        v64 = m_eWeaponType;
      }
      else
      {
        v59 = (CSimpleTransform *)p_m_translate;
        if ( pTargetEnt )
        {
          v60 = pTargetEnt->m_pMat;
          v59 = (CSimpleTransform *)&v60->tx;
          if ( !v60 )
            v59 = &pTargetEnt->m_transform;
        }
        *(float *)&v61 = v59->m_translate.y - vecStart.y;
        v62 = v59->m_translate.z - vecStart.z;
        *(float *)&v88._vptr$CEvent = v59->m_translate.x - vecStart.x;
        v88.m_iAccumulatedTime = v61;
        *(float *)&v88.m_bIsPersistent = v62;
        CVector::Normalise((CVector *)&v88);
        v63 = *(_QWORD *)&pPosn->x;
        v64 = WEAPONTYPE_ROCKET;
        v65 = pPosn->z;
        Tolerance = (CVector *)&v88;
        v84 = pTargetEnt;
      }
      bCheckPeds = v65;
      CProjectileInfo::AddProjectile(pEntity, v64, *(CVector *)&v63, fThrowForce, Tolerance, v84);
    }
    else
    {
      v66 = m_eWeaponType == WEAPONTYPE_GRENADE;
      if ( m_eWeaponType != WEAPONTYPE_GRENADE )
        v66 = m_eWeaponType == WEAPONTYPE_REMOTE_SATCHEL_CHARGE;
      if ( v66 )
      {
        v57 = pTargetEnt;
        if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
        {
          v67 = pEntity->m_pMat;
          v68 = &pEntity->m_transform;
          if ( v67 )
          {
            v68 = (CSimpleTransform *)&v67->tx;
          }
          else
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            v67 = pEntity->m_pMat;
          }
          v69 = v68->m_translate.z - v67->zy;
          v70 = v68->m_translate.y - v67->yy;
          v92.x = v68->m_translate.x - v67->xy;
          v92.y = v70;
          vecStart.y = v70;
          vecStart.x = v92.x;
          v92.z = v69 + -0.4;
          vecStart.z = v69 + -0.4;
          if ( CWorld::TestSphereAgainstWorld(v92, 0.3, 0, 0, 0, 1, 0, 0, 0) )
          {
            CProjectileInfo::RemoveNotAdd(pEntity, m_eWeaponType, *pPosn);
            v57 = pTargetEnt;
          }
          else
          {
            v57 = pTargetEnt;
            CProjectileInfo::AddProjectile(pEntity, m_eWeaponType, vecStart, 0.0, 0, pTargetEnt);
          }
          p_m_translate = pTargetPosn;
        }
      }
      else
      {
        CProjectileInfo::RemoveNotAdd(pEntity, m_eWeaponType, *pPosn);
        v57 = pTargetEnt;
      }
    }
    CWorld::pIgnoreEntity = 0;
    v71 = *(_BYTE *)&pEntity->m_info & 7;
    if ( v71 == 2 )
    {
      m_pLastRenderedLink = pEntity[18].m_pLastRenderedLink;
      if ( m_pLastRenderedLink )
      {
        CCrime::ReportCrime(CRIME_POSSESSION_GUN, pEntity, (CPed *)m_pLastRenderedLink);
        v72 = (CEntity *)pEntity[18].m_pLastRenderedLink;
        goto LABEL_83;
      }
    }
    else if ( v71 == 3 )
    {
      CCrime::ReportCrime(CRIME_CAUSE_EXPLOSION, pEntity, (CPed *)pEntity);
      v72 = pEntity;
LABEL_83:
      CInterestingEvents::Add(&g_InterestingEvents, EGunshotFired, v72);
    }
    if ( v57 )
    {
      v74 = v57->m_pMat;
      p_m_translate = (CVector *)&v74->tx;
      if ( !v74 )
        p_m_translate = &v57->m_transform.m_translate;
    }
    else if ( !p_m_translate )
    {
      p_m_translate = pPosn;
    }
    CEventGunShot::CEventGunShot(
      &v88,
      pEntity,
      *pPosn,
      *p_m_translate,
      v6->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED || v6->m_eWeaponType == WEAPONTYPE_TEARGAS);
    EventGlobalGroup = GetEventGlobalGroup();
    CEventGroup::Add(EventGlobalGroup, (CEvent *)&v88, 0);
    CEventGunShotWhizzedBy::~CEventGunShotWhizzedBy(&v88);
    return 1;
  }
  v11 = *(_QWORD *)&pPosn->x;
  v13 = 19;
  vecStart.z = pPosn->z;
  *(_QWORD *)&vecStart.x = v11;
  if ( m_eWeaponType == WEAPONTYPE_ROCKETLAUNCHER_HS )
    v13 = 20;
  if ( (*(_BYTE *)&pEntity->m_info & 7) != 3 || !CPed::IsPlayer((const CPed *)pEntity) )
  {
    v30 = pEntity->m_pMat;
    if ( !v30 )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v30 = pEntity->m_pMat;
    }
    p_xy = (CVector *)&v30->xy;
LABEL_19:
    y = pPosn->y;
    v32 = pPosn->z;
    pPosn->x = p_xy->x + pPosn->x;
    pPosn->y = p_xy->y + y;
    pPosn->z = p_xy->z + v32;
    if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    {
      if ( CPed::IsPlayer((const CPed *)pEntity) )
      {
        if ( this->m_eWeaponType == WEAPONTYPE_ROCKETLAUNCHER_HS )
        {
          v33 = pEntity[18].m_transform.m_translate.z;
          IsLockedOn = CWeaponEffects::IsLockedOn(0);
          v35 = IsLockedOn == 0;
          if ( IsLockedOn )
            v35 = *(_DWORD *)(LODWORD(v33) + 148) == 0;
          if ( !v35 )
          {
            v36 = pEntity->m_pMat;
            v37 = &pEntity->m_transform;
            if ( v36 )
              v37 = (CSimpleTransform *)&v36->tx;
            x = v37->m_translate.x;
            y_low = (CEntity *)LODWORD(v37->m_translate.y);
            v85 = v37->m_translate.z;
            if ( !v36 )
            {
              CPlaceable::AllocateMatrix(pEntity);
              CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
              v36 = pEntity->m_pMat;
            }
            v93 = *(CVector *)&v36->xy;
            *(_QWORD *)&v91.x = __PAIR64__((unsigned int)y_low, LODWORD(x));
            v91.z = v85;
            v39 = CWeapon::PickTargetForHeatSeekingMissile(v91, v93, 1.2, pEntity, 0, *(CEntity **)(LODWORD(v33) + 152));
            if ( v39 )
            {
              m_eWeaponType = WEAPONTYPE_ROCKET;
              pTargetEnt = 0;
              if ( v39 == *(CEntity **)(LODWORD(v33) + 152)
                && CTimer::m_snTimeInMilliseconds - *(_DWORD *)(LODWORD(v33) + 148) >= 0x5DD )
              {
                m_eWeaponType = v13;
                pTargetEnt = v39;
                gCrossHair[0].m_blue = 0;
                *(_WORD *)&gCrossHair[0].m_red = 255;
                gCrossHair[0].m_bLockedOn = 1.0;
                gCrossHair[0].clearTargetTimer = 0;
              }
              goto LABEL_55;
            }
          }
        }
        m_eWeaponType = WEAPONTYPE_ROCKET;
      }
      else
      {
        v55 = pTargetEnt == 0;
        if ( !pTargetEnt )
          v55 = pTargetPosn == 0;
        if ( !v55 )
        {
          v77 = (CSimpleTransform *)pTargetPosn;
          if ( pTargetEnt )
          {
            v78 = pTargetEnt->m_pMat;
            v77 = (CSimpleTransform *)&v78->tx;
            if ( !v78 )
              v77 = &pTargetEnt->m_transform;
          }
          *(float *)&v79 = v77->m_translate.y - vecStart.y;
          v80 = v77->m_translate.z - vecStart.z;
          *(float *)&v88._vptr$CEvent = v77->m_translate.x - vecStart.x;
          v88.m_iAccumulatedTime = v79;
          *(float *)&v88.m_bIsPersistent = v80;
          CVector::Normalise((CVector *)&v88);
          v14 = 0;
          CWorld::pIgnoreEntity = pEntity;
          *(float *)&v88._vptr$CEvent = vecStart.x + (float)(*(float *)&v88._vptr$CEvent * 8.0);
          *(float *)&v88.m_iAccumulatedTime = vecStart.y + (float)(*(float *)&v88.m_iAccumulatedTime * 8.0);
          *(float *)&v88.m_bIsPersistent = vecStart.z + (float)(*(float *)&v88.m_bIsPersistent * 8.0);
          IsLineOfSightClear = CWorld::GetIsLineOfSightClear(&vecStart, (const CVector *)&v88, 1, 0, 0, 0, 0, 0, 0);
          CWorld::pIgnoreEntity = 0;
          m_eWeaponType = v13;
          if ( !IsLineOfSightClear )
            return v14;
          goto LABEL_55;
        }
        m_eWeaponType = v13;
      }
      pTargetEnt = 0;
    }
    else
    {
      m_eWeaponType = v13;
    }
LABEL_55:
    v56 = *(_QWORD *)&pPosn->x;
    v6 = this;
    vecEnd.z = pPosn->z;
    *(_QWORD *)&vecEnd.x = v56;
    p_m_translate = pTargetPosn;
    goto LABEL_56;
  }
  v14 = 0;
  switch ( TheCamera.Cams[TheCamera.ActiveCam].Mode )
  {
    case 7:
    case 8:
    case 0x22:
    case 0x27:
    case 0x28:
    case 0x2A:
    case 0x33:
    case 0x34:
      p_xy = &TheCamera.Cams[TheCamera.ActiveCam].Front;
      goto LABEL_19;
    default:
      return v14;
  }
  return v14;
}
// 5DDECC: fragmented variable at r2.8 may be wrong

//----- (005DE6A8) --------------------------------------------------------
int __fastcall CWeapon::FireAreaEffect(
        CWeapon *this,
        CEntity *pEntity,
        CVector *pPosn,
        CEntity *pTargetEnt,
        CSimpleTransform *a5)
{
  CWeaponInfo *WeaponInfo; // r2
  float y; // r8
  float x; // r11
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v14; // d16
  RwReal v15; // r0
  CMatrix *v16; // r0
  CSimpleTransform *p_m_transform; // r1
  CPed *v18; // r10
  float v19; // r6
  float v20; // r2
  float v21; // r3
  float v22; // r0
  float v23; // s0
  CWeaponInfo *v25; // r4
  CMatrix *v26; // r0
  float m_heading; // s16
  float m_fWeaponRange; // s14
  float v29; // s0
  float v30; // s16
  float v31; // s0
  float v32; // r0
  float v33; // s0
  float v34; // s2
  RwReal v35; // r0
  CVector shotVector_4; // [sp+4h] [bp-5Ch]
  float z; // [sp+10h] [bp-50h]
  CVector v38; // [sp+14h] [bp-4Ch] BYREF
  RwV3d_0 posn; // [sp+20h] [bp-40h] BYREF
  CVector shotVector; // [sp+2Ch] [bp-34h] BYREF
  CVector v41; // 0:r0.12
  CVector v42; // 0:r1.12
  CVector cvector; // 0:r2.8,8:^0.4
  CVector cvectorc; // 0:r2.8,8:^0.4

  WeaponInfo = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
  y = pPosn->y;
  x = pPosn->x;
  z = pPosn->z;
  if ( pTargetEnt )
  {
    m_pMat = pTargetEnt->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pTargetEnt->m_transform;
LABEL_6:
    CGeneral::GetAngleBetweenPoints(p_tx->m_translate.x, p_tx->m_translate.y, x, y);
    memset(&posn, 0, sizeof(posn));
    if ( a5 )
    {
      v14 = *(_QWORD *)&a5->m_translate.x;
      v15 = a5->m_translate.z;
    }
    else
    {
      if ( (*(_BYTE *)&pTargetEnt->m_info & 7) == 3 )
      {
        CPed::GetBonePosition((CPed *)pTargetEnt, &posn, 3u, 0);
LABEL_14:
        v18 = (CPed *)pEntity;
        v19 = z;
        shotVector.x = posn.x - x;
        shotVector.y = posn.y - y;
        shotVector.z = posn.z - z;
        CVector::Normalise(&shotVector);
        v21 = posn.x;
        v20 = posn.y;
        v22 = posn.z;
        goto LABEL_15;
      }
      v16 = pTargetEnt->m_pMat;
      p_m_transform = (CSimpleTransform *)&v16->tx;
      if ( !v16 )
        p_m_transform = &pTargetEnt->m_transform;
      v15 = p_m_transform->m_translate.z;
      v14 = *(_QWORD *)&p_m_transform->m_translate.x;
    }
    posn.z = v15;
    *(_QWORD *)&posn.x = v14;
    goto LABEL_14;
  }
  p_tx = a5;
  if ( a5 )
    goto LABEL_6;
  v18 = (CPed *)pEntity;
  v25 = WeaponInfo;
  v26 = pEntity->m_pMat;
  if ( v26 )
    m_heading = atan2f(COERCE_FLOAT(LODWORD(v26->xy) ^ 0x80000000), v26->yy);
  else
    m_heading = pEntity->m_transform.m_heading;
  if ( FindPlayerPed(-1) == pEntity && CCam::Using3rdPersonMouseCam(TheCamera.Cams) )
  {
    v19 = z;
    cvectorc.z = z;
    *(_QWORD *)&cvectorc.x = __PAIR64__(LODWORD(y), LODWORD(x));
    CCamera::Find3rdPersonCamTargetVector(&TheCamera, v25->m_fWeaponRange, cvectorc, &v38, (CVector *)&posn);
    v22 = posn.z;
    v21 = posn.x;
    v20 = posn.y;
    shotVector.z = posn.z - v38.z;
    m_fWeaponRange = v25->m_fWeaponRange;
    shotVector.y = (float)(1.0 / m_fWeaponRange) * (float)(posn.y - v38.y);
    shotVector.x = (float)(1.0 / m_fWeaponRange) * (float)(posn.x - v38.x);
    shotVector.z = (float)(posn.z - v38.z) * (float)(1.0 / m_fWeaponRange);
  }
  else
  {
    v29 = m_heading * 180.0;
    shotVector.z = 0.0;
    v30 = 0.0;
    v31 = (float)(v29 / 3.1416) * 0.017453;
    shotVector.y = cosf(v31);
    v32 = sinf(v31);
    v33 = shotVector.y;
    LODWORD(shotVector.x) = LODWORD(v32) ^ 0x80000000;
    v18 = (CPed *)pEntity;
    LODWORD(v34) = LODWORD(v32) ^ 0x80000000;
    if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    {
      v35 = pEntity[18].m_transform.m_translate.z;
      v19 = z;
      if ( v35 != 0.0 )
      {
        LODWORD(shotVector.z) = COERCE_UNSIGNED_INT(tanf(*(float *)(LODWORD(v35) + 84))) ^ 0x80000000;
        CVector::Normalise(&shotVector);
        v34 = shotVector.x;
        v33 = shotVector.y;
        v30 = shotVector.z;
      }
    }
    else
    {
      v19 = z;
    }
    v20 = v33 + y;
    posn.y = v33 + y;
    v22 = v30 + v19;
    v21 = v34 + x;
    posn.x = v34 + x;
    posn.z = v30 + v19;
  }
LABEL_15:
  cvector.z = v19;
  shotVector_4.x = v21;
  *(_QWORD *)&shotVector_4.y = __PAIR64__(LODWORD(v22), LODWORD(v20));
  *(_QWORD *)&cvector.x = __PAIR64__(LODWORD(y), LODWORD(x));
  CShotInfo::AddShot(v18, this->m_eWeaponType, cvector, shotVector_4);
  v42.x = x;
  *(_QWORD *)&v42.y = __PAIR64__(LODWORD(v19), LODWORD(y));
  CWeapon::DoWeaponEffect(this, v42, shotVector);
  if ( this->m_eWeaponType == WEAPONTYPE_FLAMETHROWER && (rand() & 3) == 2 )
  {
    v23 = (float)((float)((float)rand() * 4.6566e-10) * 2.5) + 3.5;
    v41.x = (float)((float)(shotVector.x * v23) + x) + 0.0;
    v41.y = (float)((float)(shotVector.y * v23) + y) + 0.0;
    v41.z = (float)((float)(shotVector.z * v23) + v19) + 0.5;
    if ( CCreepingFire::TryToStartFireAtCoors(v41, 0, 1, 0, 2.3) == 1 )
      CStats::IncrementStat(0xD8u, 1.0);
  }
  CCrime::ReportCrime(CRIME_POSSESSION_GUN, 0, v18);
  return 1;
}

//----- (005DEA18) --------------------------------------------------------
bool __fastcall CWeapon::TakePhotograph(CWeapon *this, CEntity *pEntity, CVector *cameraPos)
{
  FxSystem_c *FxSystem; // r0
  CPedPool *v4; // r8
  int32 m_nSize; // r0
  int v6; // r5
  int v7; // r6
  uint8 *v8; // r10
  int v9; // r0
  uint8 *v10; // r2
  CSimpleTransform *p_tx; // r0
  float32x2_t v12; // d16
  unsigned __int64 v13; // d1
  CSimpleTransform *p_m_transform; // r1
  RwReal v15; // s2
  RwReal v16; // s4
  CSimpleTransform *v17; // r1
  float z; // s10
  RwReal v19; // s0
  RwReal v20; // s4
  CObjectPool *v21; // r11
  int32 v22; // r0
  int v23; // r8
  int v24; // r9
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r10
  uint8 *v26; // r5
  int v27; // r0
  uint8 *v28; // r1
  __int64 v29; // d16
  CSimpleTransform *v30; // r0
  float v31; // s0
  float32x2_t v32; // d16
  unsigned __int64 v33; // d1
  CSimpleTransform *v34; // r0
  float y; // s8
  RwReal v36; // s0
  RwReal v37; // s4
  CVector vecEnd; // [sp+30h] [bp-B8h] BYREF
  CVector vecStart; // [sp+3Ch] [bp-ACh] BYREF
  CEntity *refEntityPtr; // [sp+48h] [bp-A0h] BYREF
  CColPoint colPoint; // [sp+4Ch] [bp-9Ch] BYREF
  CVector v43; // [sp+78h] [bp-70h] BYREF
  RwV3d_0 posn; // [sp+88h] [bp-60h] BYREF
  RwV3d_0 pResult; // [sp+94h] [bp-54h] BYREF
  float pScaleY; // [sp+A0h] [bp-48h] BYREF
  float pScaleX[17]; // [sp+A4h] [bp-44h] BYREF

  if ( cameraPos )
  {
    FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, "camflash", cameraPos, 0, 0);
    if ( FxSystem )
      FxSystem_c::PlayAndKill(FxSystem);
  }
  if ( TheCamera.Cams[TheCamera.ActiveCam].Mode != 46 )
    return 0;
  CPickups::PictureTaken();
  CWeapon::ms_bTakePhoto = 1;
  CWeapon::ms_bPhotographHasBeenTaken = 1;
  CWeapon::m_nTakePhotoFrames = 2;
  CStats::IncrementStat(0xA6u, 1.0);
  v4 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v6 = m_nSize - 1;
    v7 = 1996 * m_nSize - 840;
    do
    {
      if ( (v4->m_aFlags[v6] & 0x80u) == 0 )
      {
        v8 = &(*v4->m_aStorage)[v7];
        if ( v8 != (uint8 *)&elf_hash_bucket[226] )
        {
          v9 = *((_DWORD *)v8 - 284);
          v10 = (uint8 *)(v9 + 48);
          if ( !v9 )
            v10 = v8 - 1152;
          p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            p_tx = &TheCamera.m_transform;
          v12.n64_u64[0] = vsub_f32(*(float32x2_t *)(v10 + 4), *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
          v13 = vmul_f32(v12, v12).n64_u64[0];
          if ( sqrtf(
                 (float)((float)((float)(*(float *)v10 - p_tx->m_translate.x)
                               * (float)(*(float *)v10 - p_tx->m_translate.x))
                       + *(float *)&v13)
               + *((float *)&v13 + 1)) < 125.0 )
          {
            CPed::GetBonePosition((CPed *)(v8 - 1156), &posn, 5u, 0);
            if ( CSprite::CalcScreenCoors(&posn, &pResult, pScaleX, &pScaleY, 0, 1) == 1
              && pResult.x > (float)((float)RsGlobal.screenWidth * 0.1)
              && pResult.x < (float)((float)RsGlobal.screenWidth * 0.9)
              && pResult.y > (float)((float)RsGlobal.screenHeight * 0.1)
              && pResult.y < (float)((float)RsGlobal.screenHeight * 0.9) )
            {
              p_m_transform = &TheCamera.m_transform;
              if ( TheCamera.m_pMat )
                p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              v15 = p_m_transform->m_translate.y - posn.y;
              v16 = p_m_transform->m_translate.z - posn.z;
              v43.x = p_m_transform->m_translate.x - posn.x;
              v43.y = v15;
              v43.z = v16;
              CVector::Normalise(&v43);
              v43.x = v43.x * 1.5;
              v43.y = v43.y * 1.5;
              v43.z = v43.z * 1.5;
              posn.x = v43.x + posn.x;
              posn.y = v43.y + posn.y;
              posn.z = v43.z + posn.z;
              v17 = &TheCamera.m_transform;
              if ( TheCamera.m_pMat )
                v17 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              z = v17->m_translate.z;
              v19 = (float)(TheCamera.m_cameraMatrix.yy + TheCamera.m_cameraMatrix.yy) + v17->m_translate.y;
              v20 = (float)(TheCamera.m_cameraMatrix.xy + TheCamera.m_cameraMatrix.xy) + v17->m_translate.x;
              vecEnd = (CVector)posn;
              vecStart.x = v20;
              vecStart.y = v19;
              vecStart.z = (float)(TheCamera.m_cameraMatrix.zy + TheCamera.m_cameraMatrix.zy) + z;
              if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 1, 1, 1, 1, 1, 0, 0) != 1
                || v8 - 1156 == (uint8 *)refEntityPtr )
              {
                *((_DWORD *)v8 + 1) |= 0x40000u;
              }
            }
          }
        }
      }
      --v6;
      v7 -= 1996;
    }
    while ( v6 != -1 );
  }
  v21 = CPools::ms_pObjectPool;
  v22 = CPools::ms_pObjectPool->m_nSize;
  if ( v22 )
  {
    v23 = v22 - 1;
    v24 = 420 * v22 - 96;
    do
    {
      if ( (v21->m_aFlags[v23] & 0x80u) == 0 )
      {
        m_aStorage = v21->m_aStorage;
        v26 = &(*v21->m_aStorage)[v24];
        if ( v26 != (uint8 *)&elf_hash_bucket[18] )
        {
          v27 = *((_DWORD *)v26 - 76);
          v28 = (uint8 *)(v27 + 48);
          if ( !v27 )
            v28 = v26 - 320;
          v29 = *(_QWORD *)v28;
          v43.z = *((RwReal *)v28 + 2);
          v30 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          *(_QWORD *)&v43.x = v29;
          v31 = *(float *)&v29;
          if ( !TheCamera.m_pMat )
            v30 = &TheCamera.m_transform;
          v32.n64_u64[0] = vsub_f32(*(float32x2_t *)&v43.y, *(float32x2_t *)&v30->m_translate.y).n64_u64[0];
          v33 = vmul_f32(v32, v32).n64_u64[0];
          if ( sqrtf(
                 (float)((float)((float)(v31 - v30->m_translate.x) * (float)(v31 - v30->m_translate.x)) + *(float *)&v33)
               + *((float *)&v33 + 1)) < 125.0
            && CSprite::CalcScreenCoors(&v43, &pResult, pScaleX, &pScaleY, 0, 1) == 1
            && pResult.x > (float)((float)RsGlobal.screenWidth * 0.1)
            && pResult.x < (float)((float)RsGlobal.screenWidth * 0.9)
            && pResult.y > (float)((float)RsGlobal.screenHeight * 0.1)
            && pResult.y < (float)((float)RsGlobal.screenHeight * 0.9) )
          {
            v34 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              v34 = &TheCamera.m_transform;
            y = v34->m_translate.y;
            v36 = (float)(TheCamera.m_cameraMatrix.xy + TheCamera.m_cameraMatrix.xy) + v34->m_translate.x;
            v37 = (float)(TheCamera.m_cameraMatrix.zy + TheCamera.m_cameraMatrix.zy) + v34->m_translate.z;
            vecEnd = v43;
            vecStart.x = v36;
            vecStart.y = (float)(TheCamera.m_cameraMatrix.yy + TheCamera.m_cameraMatrix.yy) + y;
            vecStart.z = v37;
            if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 1, 1, 1, 1, 1, 0, 0) != 1
              || v26 - 324 == (uint8 *)refEntityPtr )
            {
              *(_DWORD *)&(*m_aStorage)[v24] |= 0x1000u;
            }
          }
        }
      }
      --v23;
      v24 -= 420;
    }
    while ( v23 != -1 );
  }
  return 1;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005DEFA0) --------------------------------------------------------
bool __fastcall CWeapon::FireFromCar(
        CWeapon *this,
        CVehicle *pVehicle,
        bool LeftIsTrue_FalseIsRight,
        bool RightIsTrue_ForceForBikes)
{
  CPed *pDriver; // r0
  TouchSense *v7; // r0
  int32 m_nAmmoInClip; // r0
  int32 m_nAmmoTotal; // r0
  int32 v10; // r0
  bool v11; // r5
  eWeaponType m_eWeaponType; // r0
  uint32 v14; // r6
  CWeaponInfo *WeaponInfo; // r0

  if ( this->m_eState > (unsigned int)WEAPONSTATE_FIRING || this->m_nAmmoInClip < 1 )
    return 0;
  CWeapon::FireInstantHitFromCar(this, pVehicle, LeftIsTrue_FalseIsRight, RightIsTrue_ForceForBikes);
  pDriver = pVehicle->pDriver;
  if ( pDriver )
    CAEPedWeaponAudioEntity::AddAudioEvent(&pDriver->m_PedWeaponAudioEntity, 145);
  if ( FindPlayerVehicle(-1, 0) == pVehicle )
  {
    TouchSense::instance();
    TouchSense::playBuiltinEffect(v7, 2, 3, 115, 20);
  }
  if ( !CCheat::m_aCheatsActive[80] )
  {
    m_nAmmoInClip = this->m_nAmmoInClip;
    if ( m_nAmmoInClip >= 1 )
      this->m_nAmmoInClip = m_nAmmoInClip - 1;
    m_nAmmoTotal = this->m_nAmmoTotal;
    if ( (unsigned int)(m_nAmmoTotal - 1) <= 0x61A6 )
    {
      if ( *(_BYTE *)&pVehicle->m_info > 7u )
      {
LABEL_14:
        this->m_nAmmoTotal = m_nAmmoTotal - 1;
        goto LABEL_15;
      }
      if ( CStats::GetPercentageProgress() < 100.0 )
      {
        m_nAmmoTotal = this->m_nAmmoTotal;
        goto LABEL_14;
      }
    }
  }
LABEL_15:
  v10 = this->m_nAmmoInClip;
  this->m_eState = WEAPONSTATE_FIRING;
  if ( v10 )
  {
    this->m_nTimer = CTimer::m_snTimeInMilliseconds + 1000;
  }
  else if ( this->m_nAmmoTotal )
  {
    v11 = 1;
    m_eWeaponType = this->m_eWeaponType;
    this->m_eState = WEAPONSTATE_RELOADING;
    v14 = CTimer::m_snTimeInMilliseconds;
    WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, 1);
    this->m_nTimer = CWeaponInfo::GetWeaponReloadTime(WeaponInfo) + v14;
    return v11;
  }
  return 1;
}
// 5DEFF0: variable 'v7' is possibly undefined

//----- (005DF098) --------------------------------------------------------
bool __fastcall CWeapon::FireInstantHitFromCar(
        CWeapon *this,
        CVehicle *pVehicle,
        bool LeftIsTrue_FalseIsRight,
        bool RightIsTrue_ForceForBikes)
{
  _BOOL4 v5; // r10
  _BOOL4 v6; // r11
  CWeaponInfo *WeaponInfo; // r9
  CPed *pDriver; // r0
  __int64 v9; // d16
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r4
  RwInt32 v11; // r6
  RwMatrix *MatrixArray; // r0
  float v13; // s4
  float v14; // s2
  float v15; // s0
  CMatrix *m_pMat; // r0
  float m_fWeaponRange; // s6
  float v18; // s2
  float v19; // s4
  float v20; // s0
  RwReal v21; // s0
  RwReal v22; // s2
  __int64 v23; // d16
  RpHAnimHierarchy_0 *v24; // r4
  RwInt32 v25; // r6
  RwMatrix *v26; // r0
  CEntity **p_pDriver; // r5
  float v28; // s2
  float v29; // s4
  float v30; // s0
  CMatrix *v31; // r0
  float v32; // s6
  float v33; // s2
  float v34; // s4
  float v35; // s0
  float xy; // s8
  float yy; // s10
  float zy; // s12
  CBaseModelInfo *v39; // r6
  CMatrix *v40; // r4
  CColModel *ColModel; // r0
  uint32 m_hashKey; // r2
  float x; // s16
  float v44; // s18
  float v45; // s0
  uint32 v46; // r1
  float v47; // s2
  RwReal v48; // s2
  RwReal v49; // s4
  float v50; // s2
  uint32 v51; // r2
  CMatrix *v52; // r1
  float v53; // s4
  float v54; // s0
  float xx; // s8
  float yx; // s10
  float zx; // s12
  CWeapon *v58; // r9
  CMatrix *v59; // r4
  CColModel *v60; // r0
  uint32 v61; // r2
  float v62; // s16
  float v63; // s18
  float v64; // s0
  uint32 v65; // r1
  float v66; // s2
  RwReal v67; // s2
  RwReal v68; // s4
  uint32 v69; // r2
  RwReal v70; // r0
  CMatrix *v71; // r4
  int v72; // s0
  uint32 v73; // r2
  float v74; // s18
  float v75; // s2
  uint32 v76; // r2
  RwReal v77; // s4
  RwReal v78; // s2
  RwReal v79; // s4
  uint32 v80; // r2
  float v81; // s2
  float v82; // s16
  float v83; // s18
  unsigned __int8 v84; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v88; // [sp+24h] [bp-6Ch] BYREF
  CVector v; // [sp+30h] [bp-60h] BYREF
  RwV3d_0 pointsIn; // [sp+40h] [bp-50h] BYREF
  CVector pShotTarget; // [sp+50h] [bp-40h] BYREF

  v5 = RightIsTrue_ForceForBikes;
  v6 = LeftIsTrue_FalseIsRight;
  WeaponInfo = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
  if ( pVehicle->m_baseVehicleType == 9 )
  {
    pDriver = pVehicle->pDriver;
    if ( pDriver )
    {
      v9 = *(_QWORD *)&WeaponInfo->m_vecFireOffset.x;
      pointsIn.z = WeaponInfo->m_vecFireOffset.z;
      *(_QWORD *)&pointsIn.x = v9;
      AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pDriver->m_pRwObject);
      v11 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, pVehicle->pDriver->m_aPedFrames[6]->boneTag);
      MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
      RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &MatrixArray[v11]);
      v13 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.y) + pointsIn.y;
      v14 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.x) + pointsIn.x;
      v15 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.z) + pointsIn.z;
      pointsIn.x = v14;
      pointsIn.y = v13;
      pointsIn.z = v15;
      m_pMat = pVehicle->m_pMat;
      m_fWeaponRange = WeaponInfo->m_fWeaponRange;
      if ( v6 )
      {
        v18 = v14 - (float)(m_fWeaponRange * m_pMat->xx);
        v19 = v13 - (float)(m_fWeaponRange * m_pMat->yx);
        v20 = v15 - (float)(m_fWeaponRange * m_pMat->zx);
      }
      else
      {
        if ( v5 )
        {
          xx = m_pMat->xx;
          yx = m_pMat->yx;
          zx = m_pMat->zx;
        }
        else
        {
          xx = m_pMat->xy;
          yx = m_pMat->yy;
          zx = m_pMat->zy;
        }
        v19 = (float)(m_fWeaponRange * yx) + v13;
        v18 = (float)(m_fWeaponRange * xx) + v14;
        v20 = v15 + (float)(m_fWeaponRange * zx);
      }
      pShotTarget.y = v19;
      pShotTarget.x = v18;
      pShotTarget.z = v20;
    }
    else
    {
      v39 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex];
      if ( v6 )
      {
        v40 = pVehicle->m_pMat;
        ColModel = CEntity::GetColModel(pVehicle);
        m_hashKey = v39[2].m_hashKey;
        x = ColModel->m_boxBound.m_vecMax.x;
        if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
          m_hashKey += 48;
        v44 = *(float *)(m_hashKey + 4);
        v45 = (float)(unsigned __int8)rand();
        v46 = v39[2].m_hashKey;
        if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
          v46 += 48;
        v47 = *(float *)(v46 + 8);
        v.x = -0.25 - x;
        v.z = v47 + 0.63;
        v.y = (float)(v44 + -0.05) + (float)(v45 * 0.001);
        operator*(&pShotTarget, v40, &v);
        pointsIn = pShotTarget.RwV3d_0;
        v48 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.y) + pShotTarget.y;
        v49 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.z) + pShotTarget.z;
        pointsIn.x = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.x) + pShotTarget.x;
        pointsIn.y = v48;
        pointsIn.z = v49;
        v50 = -WeaponInfo->m_fWeaponRange;
        v51 = v39[2].m_hashKey;
        v52 = pVehicle->m_pMat;
        if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
          v51 += 48;
        v53 = *(float *)(v51 + 8);
        v88.y = *(RwReal *)(v51 + 4);
        v54 = v53 + 0.6;
        v88.x = v50;
      }
      else
      {
        if ( v5 )
        {
          v59 = pVehicle->m_pMat;
          v60 = CEntity::GetColModel(pVehicle);
          v61 = v39[2].m_hashKey;
          v62 = v60->m_boxBound.m_vecMax.x;
          if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
            v61 += 48;
          v63 = *(float *)(v61 + 4);
          v64 = (float)(unsigned __int8)rand();
          v65 = v39[2].m_hashKey;
          if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
            v65 += 48;
          v66 = *(float *)(v65 + 8);
          v.x = v62 + 0.25;
          v.z = v66 + 0.52;
          v.y = (float)(v63 + -0.18) + (float)(v64 * 0.001);
          operator*(&pShotTarget, v59, &v);
          pointsIn = pShotTarget.RwV3d_0;
          v67 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.y) + pShotTarget.y;
          v68 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.z) + pShotTarget.z;
          pointsIn.x = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.x) + pShotTarget.x;
          pointsIn.y = v67;
          pointsIn.z = v68;
          v69 = v39[2].m_hashKey;
          v52 = pVehicle->m_pMat;
          if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
            v69 += 48;
          v70 = WeaponInfo->m_fWeaponRange;
          v54 = *(float *)(v69 + 8) + 0.5;
          v88.y = *(RwReal *)(v69 + 4);
        }
        else
        {
          v71 = pVehicle->m_pMat;
          v72 = (unsigned __int8)rand();
          v73 = v39[2].m_hashKey;
          if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
            v73 += 48;
          v74 = *(float *)(v73 + 4);
          v75 = v74 + CEntity::GetColModel(pVehicle)->m_boxBound.m_vecMax.y;
          v76 = v39[2].m_hashKey;
          if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
            v76 += 48;
          v77 = *(float *)(v76 + 8) + 0.55;
          v.x = (float)((float)v72 * 0.001) + -0.4;
          v.z = v77;
          v.y = v75 + 0.2;
          operator*(&pShotTarget, v71, &v);
          pointsIn = pShotTarget.RwV3d_0;
          v78 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.y) + pShotTarget.y;
          v79 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.z) + pShotTarget.z;
          pointsIn.x = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.x) + pShotTarget.x;
          pointsIn.y = v78;
          pointsIn.z = v79;
          v80 = v39[2].m_hashKey;
          v52 = pVehicle->m_pMat;
          if ( *(_DWORD *)&v39[1].m_modelName[20] != 5 )
            v80 += 48;
          v81 = *(float *)(v80 + 8);
          v88.y = WeaponInfo->m_fWeaponRange;
          v70 = 0.0;
          v54 = v81 + 0.5;
        }
        v88.x = v70;
      }
      v88.z = v54;
      operator*(&v, v52, &v88);
      pShotTarget = v;
    }
    p_pDriver = &pVehicle->pDriver;
    v58 = this;
  }
  else
  {
    if ( v5 )
    {
      v21 = WeaponInfo->m_vecFireOffset.x * 1.8;
      v22 = (float)(WeaponInfo->m_vecFireOffset.z * 1.8) + -0.1;
      pointsIn.y = WeaponInfo->m_vecFireOffset.y * 1.8;
      pointsIn.x = v21;
      pointsIn.z = v22;
    }
    else
    {
      v23 = *(_QWORD *)&WeaponInfo->m_vecFireOffset.x;
      pointsIn.z = WeaponInfo->m_vecFireOffset.z;
      *(_QWORD *)&pointsIn.x = v23;
    }
    v24 = GetAnimHierarchyFromSkinClump((RpClump_0 *)pVehicle->pDriver->m_pRwObject);
    v25 = RpHAnimIDGetIndex(v24, pVehicle->pDriver->m_aPedFrames[6]->boneTag);
    v26 = RpHAnimHierarchyGetMatrixArray(v24);
    RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &v26[v25]);
    p_pDriver = &pVehicle->pDriver;
    v28 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.y) + pointsIn.y;
    v29 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.z) + pointsIn.z;
    v30 = (float)(CTimer::ms_fTimeStep * pVehicle->m_vecMoveSpeed.x) + pointsIn.x;
    pointsIn.x = v30;
    pointsIn.y = v28;
    pointsIn.z = v29;
    v31 = pVehicle->m_pMat;
    v32 = WeaponInfo->m_fWeaponRange;
    if ( v6 )
    {
      v33 = v28 - (float)(v32 * v31->yx);
      v34 = v29 - (float)(v32 * v31->zx);
      v35 = v30 - (float)(v32 * v31->xx);
    }
    else
    {
      if ( v5 )
      {
        xy = v31->xx;
        yy = v31->yx;
        zy = v31->zx;
      }
      else
      {
        xy = v31->xy;
        yy = v31->yy;
        zy = v31->zy;
      }
      v34 = v29 + (float)(v32 * zy);
      v33 = (float)(v32 * yy) + v28;
      v35 = (float)(v32 * xy) + v30;
    }
    v58 = this;
    pShotTarget.y = v33;
    pShotTarget.x = v35;
    pShotTarget.z = v34;
  }
  v82 = (float)(unsigned __int8)rand();
  v83 = (float)(unsigned __int8)rand();
  v84 = rand();
  pShotTarget.x = pShotTarget.x + (float)((float)(v82 * 0.01) + -1.28);
  pShotTarget.y = (float)((float)(v83 * 0.01) + -1.28) + pShotTarget.y;
  pShotTarget.z = (float)((float)((float)v84 * 0.01) + -1.28) + pShotTarget.z;
  PlayerPed = FindPlayerPed(-1);
  CWeapon::DoDriveByAutoAiming(PlayerPed, pVehicle, (CVector *)&pointsIn, &pShotTarget, 0);
  CWeapon::FireInstantHitFromCar2(v58, (CVector)pointsIn, pShotTarget, pVehicle, *p_pDriver);
  return 1;
}

//----- (005DF748) --------------------------------------------------------
int __fastcall CWeapon::ProcessLineOfSight(
        const CVector *vecShotOrigin,
        const CVector *vecShotVector,
        CColPoint *colPoint,
        CEntity **pHitEntity,
        eWeaponType WeaponType,
        CEntity *pOwner,
        int bCheckBuildings,
        CEntity *bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        bool bSeeThroughStuff,
        int bIgnoreSomeObjectsForCamera)
{
  CBirds::HandleGunShot(vecShotOrigin, vecShotVector);
  CShadows::GunShotSetsOilOnFire(vecShotOrigin, vecShotVector);
  return CWorld::ProcessLineOfSight(
           vecShotOrigin,
           vecShotVector,
           colPoint,
           pHitEntity,
           bCheckBuildings,
           (int)bCheckVehicles,
           bCheckPeds,
           bCheckObjects,
           bCheckDummies,
           0,
           bIgnoreSomeObjectsForCamera,
           1);
}
// 5DF748: using guessed type int bCheckPeds;
// 5DF748: using guessed type int bCheckDummies;

//----- (005DF798) --------------------------------------------------------
float __fastcall CWeapon::TargetWeaponRangeMultiplier(CEntity *pTarget, CEntity *pOwner)
{
  float v2; // s16
  bool v3; // zf
  int v4; // r2
  CLink<CEntity *> *m_pLastRenderedLink; // r2
  bool v6; // zf
  int Mode; // r0

  v2 = 1.0;
  v3 = pTarget == 0;
  if ( pTarget )
    v3 = pOwner == 0;
  if ( !v3 )
  {
    v4 = *(_BYTE *)&pTarget->m_info & 7;
    if ( v4 == 3 )
    {
      m_pLastRenderedLink = pTarget[23].m_pLastRenderedLink;
      v6 = m_pLastRenderedLink == 0;
      if ( m_pLastRenderedLink )
        v6 = m_pLastRenderedLink[120].item == (CEntity *)byte_9;
      if ( !v6 )
        return 3.0;
      pTarget = (CEntity *)LODWORD(pTarget[4].m_transform.m_heading);
      if ( !pTarget || (*(_BYTE *)&pTarget->m_info & 7) != 2 )
        goto LABEL_14;
    }
    else if ( v4 != 2 )
    {
LABEL_14:
      if ( (*(_BYTE *)&pOwner->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)pOwner) )
      {
        v2 = 1.0;
        Mode = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
        if ( Mode == 45 )
          v2 = 3.0;
        if ( Mode == 49 )
          return 2.0;
      }
      return v2;
    }
    if ( pTarget[24]._vptr$CPlaceable != (int (**)(void))byte_9 )
      return 3.0;
    goto LABEL_14;
  }
  return v2;
}

//----- (005DF844) --------------------------------------------------------
void __fastcall CWeapon::CheckForShootingVehicleOccupant(
        CEntity **ppHitEntity,
        CColPoint *pColPoint,
        eWeaponType nWeaponType,
        const CVector *vecShotStart,
        const CVector *a5)
{
  CEntity *v6; // r6
  CColPoint *v7; // r5
  __int64 *v8; // r0
  __int64 v9; // d16
  __int64 v10; // d17
  __int64 v11; // d18
  __int64 v12; // d19
  CLink<CEntity *> *m_pLastRenderedLink; // r0
  int v14; // r4
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r9
  RwInt32 v16; // r8
  RwMatrix *MatrixArray; // r0
  int v18; // r11
  int v19; // r0
  RpHAnimHierarchy_0 *v20; // r4
  RwInt32 v21; // r9
  RwMatrix *v22; // r0
  float v23; // s0
  float v24; // s2
  float *p_xx; // r0
  float v26; // s4
  CColModel *ColModel; // r9
  CCollisionData *m_pColData; // r4
  CColPoint *v29; // r10
  CMatrix *v30; // r0
  int v31; // r5
  const CVector *v32; // [sp+Ch] [bp-F4h]
  int v33; // [sp+10h] [bp-F0h]
  CMatrix v35; // [sp+18h] [bp-E8h] BYREF
  CVector vecCentre; // [sp+60h] [bp-A0h] BYREF
  float fCollisionRatio; // [sp+70h] [bp-90h] BYREF
  CColSphere v38; // [sp+74h] [bp-8Ch] BYREF
  CColLine line; // [sp+88h] [bp-78h] BYREF
  CColPoint p; // [sp+ACh] [bp-54h] BYREF

  v6 = *ppHitEntity;
  v7 = pColPoint;
  if ( (*(_BYTE *)&(*ppHitEntity)->m_info & 7) == 2 )
  {
    CColPoint::operator=(&p, pColPoint);
    fCollisionRatio = 1.0;
    v32 = vecShotStart;
    CColLine::CColLine((CColLine *)&v35, vecShotStart, a5);
    v9 = *v8;
    v10 = v8[1];
    v8 += 2;
    v11 = *v8;
    v12 = v8[1];
    *(_QWORD *)&line.m_vecStart.x = v9;
    *(_QWORD *)&line.m_vecStart.z = v10;
    *(_QWORD *)&line.m_vecEnd.x = v11;
    *(_QWORD *)&line.m_vecEnd.z = v12;
    m_pLastRenderedLink = v6[18].m_pLastRenderedLink;
    if ( m_pLastRenderedLink )
    {
      v14 = 0;
      if ( (HIBYTE(m_pLastRenderedLink[96].m_pNext) & 4) != 0 )
      {
        memset(&v35, 0, 12);
        AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)m_pLastRenderedLink[2].item);
        v16 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, (RwInt32)v6[18].m_pLastRenderedLink[98].m_pPrev[1].m_pNext);
        MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
        RwV3dTransformPoints((RwV3d_0 *)&v35, (const RwV3d_0 *)&v35, 1, &MatrixArray[v16]);
        vecCentre.x = v35.xx;
        vecCentre.y = v35.yx;
        vecCentre.z = v35.zx + 0.1;
        CColSphere::Set(&v38, 0.2, &vecCentre, 0, 9u, 0xFFu);
        if ( CCollision::ProcessLineSphere(&line, &v38, v7, &fCollisionRatio) )
        {
          *ppHitEntity = (CEntity *)v6[18].m_pLastRenderedLink;
          v14 = 1;
        }
      }
    }
    else
    {
      v14 = 0;
    }
    v18 = 282;
    v33 = v14;
    do
    {
      v19 = *((_DWORD *)&v6->_vptr$CPlaceable + v18);
      if ( v19 )
      {
        if ( (*(_BYTE *)(v19 + 1163) & 4) != 0 )
        {
          memset(&v35, 0, 12);
          v20 = GetAnimHierarchyFromSkinClump(*(RpClump_0 **)(v19 + 24));
          v21 = RpHAnimIDGetIndex(v20, *(_DWORD *)(*(_DWORD *)(*((_DWORD *)&v6->_vptr$CPlaceable + v18) + 1180) + 20));
          v22 = RpHAnimHierarchyGetMatrixArray(v20);
          RwV3dTransformPoints((RwV3d_0 *)&v35, (const RwV3d_0 *)&v35, 1, &v22[v21]);
          vecCentre.x = v35.xx;
          vecCentre.y = v35.yx;
          vecCentre.z = v35.zx + 0.1;
          CColSphere::Set(&v38, 0.2, &vecCentre, 0, 9u, 0xFFu);
          if ( CCollision::ProcessLineSphere(&line, &v38, v7, &fCollisionRatio) )
          {
            *ppHitEntity = (CEntity *)*((_DWORD *)&v6->_vptr$CPlaceable + v18);
            v33 = 1;
          }
        }
      }
      ++v18;
    }
    while ( v18 != 290 );
    if ( !v6[24]._vptr$CPlaceable )
    {
      v23 = a5->x - v32->x;
      v24 = a5->y - v32->y;
      p_xx = &v6->m_pMat->xx;
      v26 = a5->z - v32->z;
      if ( (float)((float)((float)(v23 * p_xx[4]) + (float)(v24 * p_xx[5])) + (float)(v26 * p_xx[6])) < 0.0
        && ((float)((float)((float)(v23 * p_xx[8]) + (float)(v24 * p_xx[9])) + (float)(v26 * p_xx[10])) <= 0.0
         || (v6[17].m_nScanCode & 0x400) != 0) )
      {
        ColModel = CEntity::GetColModel(v6);
        m_pColData = ColModel->m_pColData;
        if ( m_pColData->m_nNoOfTriangles >= 1 )
        {
          v29 = v7;
          v30 = Invert(v6->m_pMat, &v35);
          CMatrix::CMatrix(&v35, v30);
          operator*(&vecCentre, &v35, &line.m_vecStart);
          line.m_vecStart = vecCentre;
          operator*(&vecCentre, &v35, &line.m_vecEnd);
          line.m_vecEnd = vecCentre;
          CCollision::CalculateTrianglePlanes(ColModel);
          if ( m_pColData->m_nNoOfTriangles >= 1 )
          {
            v31 = 0;
            while ( !SurfaceInfos_c::IsGlass(&g_surfaceInfos, m_pColData->m_pTriangleArray[v31].m_nSurfaceType)
                 || !CCollision::TestLineTriangle(
                       &line,
                       m_pColData->m_pTriCompressedVectorArray,
                       &m_pColData->m_pTriangleArray[v31],
                       &m_pColData->m_pTrianglePlaneArray[v31]) )
            {
              v31 = (__int16)(v31 + 1);
              if ( v31 >= m_pColData->m_nNoOfTriangles )
                goto LABEL_29;
            }
            if ( CDamageManager::ProgressPanelDamage((CDamageManager *)&v6[24].m_pMat, 4u) )
            {
              if ( CDamageManager::GetPanelStatus((const CDamageManager *)&v6[24].m_pMat, 4) == 2 )
                CDamageManager::ProgressPanelDamage((CDamageManager *)&v6[24].m_pMat, 4u);
              CAutomobile::SetPanelDamage((CAutomobile *)v6, WINDSCREEN_PANEL, 1);
            }
          }
LABEL_29:
          CMatrix::~CMatrix(&v35);
          v7 = v29;
        }
      }
    }
    if ( !(v33 << 31) )
    {
      *ppHitEntity = v6;
      CColPoint::operator=(v7, &p);
    }
  }
}
// 5DF888: variable 'v8' is possibly undefined

//----- (005DFB80) --------------------------------------------------------
void __fastcall CWeapon::DoDriveByAutoAiming(
        CEntity *pEntity,
        CVehicle *pVehicle,
        CVector *pShotOrigin,
        CVector *pShotTarget,
        int a5)
{
  int v5; // r4
  float v8; // s2
  float v9; // s0
  int v10; // r0
  int v11; // r8
  float v12; // s16
  int v13; // r9
  CVector *v14; // r1
  CVehicle *v15; // r6
  int v16; // r10
  CEntity *v17; // r0
  unsigned int v18; // r3
  bool v19; // zf
  CMatrix *m_pMat; // r3
  const CVector *p_tx; // r2
  float v22; // r0
  CEntity *v23; // r1
  float v24; // s6
  CMatrix *v25; // r2
  float *p_x; // r0
  CMatrix *v27; // r1
  float v28; // s0
  float v29; // s4
  float v30; // s2
  CSimpleTransform *v31; // r0
  float v32; // s8
  float v33; // s6
  CMatrix *v34; // r1
  CSimpleTransform *p_m_transform; // r0
  int v36; // r0
  int v37; // r3
  bool v38; // zf
  int v39; // r0
  int v40; // r0
  float PlaneGunsAutoAimAngle; // r0
  float v42; // s0
  float x; // s6
  CEntity *v44; // r0
  float y; // s8
  CMatrix *v46; // r1
  float z; // s10
  float *v48; // r2
  float v49; // s14
  float v50; // s1
  float v51; // s0
  int v54; // [sp+28h] [bp-C0h]
  Int16 v55; // [sp+2Ch] [bp-BCh] BYREF
  Int16 pNum; // [sp+2Eh] [bp-BAh] BYREF
  CEntity *v57[46]; // [sp+30h] [bp-B8h] BYREF

  v5 = 0;
  pNum = 0;
  v55 = 0;
  if ( pEntity )
  {
    v8 = pShotTarget->y - pShotOrigin->y;
    v9 = sqrtf(
           (float)((float)((float)(pShotTarget->x - pShotOrigin->x) * (float)(pShotTarget->x - pShotOrigin->x))
                 + (float)(v8 * v8))
         + (float)((float)(pShotTarget->z - pShotOrigin->z) * (float)(pShotTarget->z - pShotOrigin->z)));
    CWorld::FindObjectsInRange(pShotOrigin, v9, 1, &pNum, 16, v57, 0, 0, 1, 0, 0);
    if ( a5 == 1 )
    {
      CWorld::FindObjectsInRange(pShotOrigin, v9, 1, &v55, 16, &v57[pNum], 0, 1, 0, 0, 0);
      v5 = (unsigned __int16)v55;
    }
    v10 = (unsigned __int16)pNum + v5;
    if ( v10 << 16 < 1 )
    {
      v12 = 10000.0;
      LOWORD(v54) = pNum + v5;
      v15 = pVehicle;
    }
    else
    {
      v11 = (__int16)v10;
      v12 = 10000.0;
      v54 = (unsigned __int16)pNum + v5;
      v13 = 0;
      v15 = pVehicle;
      v14 = pShotTarget;
      v16 = 0;
      do
      {
        v17 = v57[v13];
        if ( v17 != pEntity )
        {
          if ( (*(_BYTE *)&v17->m_info & 7) != 3 )
            goto LABEL_11;
          v18 = (int)v17[18].m_pMat & 0xFFFFFFFE;
          v19 = v18 == 54;
          if ( v18 != 54 )
            v19 = LODWORD(v17[4].m_transform.m_heading) == (_DWORD)v15;
          if ( !v19 )
          {
LABEL_11:
            m_pMat = v17->m_pMat;
            p_tx = (const CVector *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &v17->m_transform.m_translate;
            v22 = CCollision::DistToLine(pShotOrigin, v14, p_tx);
            v23 = v57[v13];
            v24 = v22;
            v15 = pVehicle;
            v25 = v23->m_pMat;
            p_x = &v25->tx;
            if ( !v25 )
              p_x = &v23->m_transform.m_translate.x;
            if ( (unsigned int)(pVehicle->m_vehicleType - 3) > 1 )
            {
              v34 = pEntity->m_pMat;
              v28 = *p_x;
              v29 = p_x[1];
              v30 = p_x[2];
              p_m_transform = (CSimpleTransform *)&v34->tx;
              if ( !v34 )
                p_m_transform = &pEntity->m_transform;
              v33 = v24
                  + (float)(sqrtf(
                              (float)((float)((float)(v28 - p_m_transform->m_translate.x)
                                            * (float)(v28 - p_m_transform->m_translate.x))
                                    + (float)((float)(v29 - p_m_transform->m_translate.y)
                                            * (float)(v29 - p_m_transform->m_translate.y)))
                            + (float)((float)(v30 - p_m_transform->m_translate.z)
                                    * (float)(v30 - p_m_transform->m_translate.z)))
                          * 0.15);
            }
            else
            {
              v27 = pVehicle->m_pMat;
              v28 = *p_x;
              v29 = p_x[1];
              v30 = p_x[2];
              v31 = (CSimpleTransform *)&v27->tx;
              if ( !v27 )
                v31 = &pVehicle->m_transform;
              v32 = sqrtf(
                      (float)((float)((float)(v28 - v31->m_translate.x) * (float)(v28 - v31->m_translate.x))
                            + (float)((float)(v29 - v31->m_translate.y) * (float)(v29 - v31->m_translate.y)))
                    + (float)((float)(v30 - v31->m_translate.z) * (float)(v30 - v31->m_translate.z)));
              if ( v32 >= 5.0 )
                v33 = v24 / v32;
              else
                v33 = v24 / 5.0;
            }
            v14 = pShotTarget;
            v36 = 0;
            v37 = 0;
            if ( (float)((float)((float)((float)(pShotTarget->x - pShotOrigin->x) * (float)(v28 - pShotOrigin->x))
                               + (float)((float)(pShotTarget->y - pShotOrigin->y) * (float)(v29 - pShotOrigin->y)))
                       + (float)((float)(pShotTarget->z - pShotOrigin->z) * (float)(v30 - pShotOrigin->z))) > 0.0 )
              v36 = 1;
            if ( v33 < v12 )
              v37 = 1;
            v39 = v36 & v37;
            v38 = v39 == 0;
            if ( v39 )
              v12 = v33;
            v40 = v54;
            if ( !v38 )
              v40 = v16;
            v54 = v40;
          }
        }
        v13 = (__int16)++v16;
      }
      while ( v11 > (__int16)v16 );
    }
    PlaneGunsAutoAimAngle = CVehicle::GetPlaneGunsAutoAimAngle(v15);
    if ( PlaneGunsAutoAimAngle <= 0.5 )
      v42 = 2.5;
    else
      v42 = tanf((float)(PlaneGunsAutoAimAngle * 3.1416) / 180.0);
    if ( v12 < v42 )
    {
      x = pShotOrigin->x;
      v44 = v57[(__int16)v54];
      y = pShotOrigin->y;
      v46 = v44->m_pMat;
      z = pShotOrigin->z;
      v48 = &v46->tx;
      if ( !v46 )
        v48 = &v44->m_transform.m_translate.x;
      v49 = v48[1];
      v50 = v48[2];
      v51 = sqrtf(
              (float)((float)((float)(pShotOrigin->x - pShotTarget->x) * (float)(pShotOrigin->x - pShotTarget->x))
                    + (float)((float)(y - pShotTarget->y) * (float)(y - pShotTarget->y)))
            + (float)((float)(z - pShotTarget->z) * (float)(z - pShotTarget->z)))
          / sqrtf(
              (float)((float)((float)(x - *v48) * (float)(x - *v48)) + (float)((float)(y - v49) * (float)(y - v49)))
            + (float)((float)(z - v50) * (float)(z - v50)));
      pShotTarget->x = x + (float)((float)(*v48 - x) * v51);
      pShotTarget->y = y + (float)((float)(v49 - y) * v51);
      pShotTarget->z = z + (float)((float)(v50 - z) * v51);
    }
  }
}

//----- (005DFF24) --------------------------------------------------------
void __fastcall CWeapon::DoDoomAiming(CEntity *pEntity, CVector *pShotOrigin, CVector *pShotTarget)
{
  float v5; // s2
  float v6; // s16
  int v7; // r8
  CEntity *v8; // r1
  CPlaceable **v9; // r9
  CPlaceable *v10; // r5
  CMatrix *m_pMat; // r0
  CMatrix *v12; // r1
  float tx; // s20
  float v14; // s22
  CPlaceable *v15; // r5
  float v16; // s24
  CMatrix *v17; // r1
  float v18; // s26
  CPlaceable *v19; // r5
  float ty; // s28
  CMatrix *v21; // r1
  float v22; // s30
  CPlaceable *v23; // r5
  float v24; // s17
  CMatrix *v25; // r1
  float v26; // s20
  float v27; // s22
  float v28; // s26
  float v29; // s22
  CPlaceable *v30; // r5
  float tz; // s20
  CMatrix *v32; // r1
  float v33; // s22
  float v34; // s24
  float v35; // s22
  CPlaceable *v36; // r5
  float v37; // s20
  float v38; // s24
  CMatrix *v39; // r0
  float v40; // s0
  float v41; // s0
  CEntity *v42; // r0
  CMatrix *v43; // r2
  const CVector *p_tx; // r1
  CEntity *v45; // r0
  CMatrix *v46; // r1
  float *p_x; // r2
  float y; // s2
  float v49; // s0
  float v50; // s2
  float v51; // s6
  CVector *vecStart; // [sp+24h] [bp-DCh]
  Int16 v54; // [sp+28h] [bp-D8h]
  CEntity *refEntityPtr; // [sp+2Ch] [bp-D4h] BYREF
  CColPoint colPoint; // [sp+30h] [bp-D0h] BYREF
  Int16 pNum; // [sp+5Eh] [bp-A2h] BYREF
  CEntity *v58[40]; // [sp+60h] [bp-A0h] BYREF

  v5 = pShotTarget->y - pShotOrigin->y;
  CWorld::FindObjectsInRange(
    pShotOrigin,
    sqrtf(
      (float)((float)((float)(pShotTarget->x - pShotOrigin->x) * (float)(pShotTarget->x - pShotOrigin->x))
            + (float)(v5 * v5))
    + (float)((float)(pShotTarget->z - pShotOrigin->z) * (float)(pShotTarget->z - pShotOrigin->z))),
    1,
    &pNum,
    15,
    v58,
    0,
    1,
    1,
    0,
    0);
  if ( pNum >= 1 )
  {
    v6 = 10000.0;
    LOWORD(v7) = 0;
    vecStart = pShotOrigin;
    v54 = pNum;
    do
    {
      v8 = v58[(__int16)v7];
      if ( v8 != pEntity && CPed::CanSeeEntity((CPed *)pEntity, v8, 0.3927) )
      {
        v9 = &v58[(__int16)v7];
        v10 = *v9;
        if ( (BYTE2((*v9)[2].m_transform.m_translate.y) >> 3) - 5 >= 3u )
        {
          m_pMat = pEntity->m_pMat;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            v10 = *v9;
            m_pMat = pEntity->m_pMat;
          }
          v12 = v10->m_pMat;
          tx = m_pMat->tx;
          if ( !v12 )
          {
            CPlaceable::AllocateMatrix(v10);
            CSimpleTransform::UpdateMatrix(&v10->m_transform, v10->m_pMat);
            m_pMat = pEntity->m_pMat;
            v12 = v10->m_pMat;
          }
          v14 = v12->tx;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          v15 = *v9;
          v16 = m_pMat->tx;
          v17 = (*v9)->m_pMat;
          if ( !v17 )
          {
            CPlaceable::AllocateMatrix(*v9);
            CSimpleTransform::UpdateMatrix(&v15->m_transform, v15->m_pMat);
            m_pMat = pEntity->m_pMat;
            v17 = v15->m_pMat;
          }
          v18 = v17->tx;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          v19 = *v9;
          ty = m_pMat->ty;
          v21 = (*v9)->m_pMat;
          if ( !v21 )
          {
            CPlaceable::AllocateMatrix(*v9);
            CSimpleTransform::UpdateMatrix(&v19->m_transform, v19->m_pMat);
            m_pMat = pEntity->m_pMat;
            v21 = v19->m_pMat;
          }
          v22 = v21->ty;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          v23 = *v9;
          v24 = m_pMat->ty;
          v25 = (*v9)->m_pMat;
          if ( !v25 )
          {
            CPlaceable::AllocateMatrix(*v9);
            CSimpleTransform::UpdateMatrix(&v23->m_transform, v23->m_pMat);
            m_pMat = pEntity->m_pMat;
            v25 = v23->m_pMat;
          }
          v26 = tx - v14;
          v27 = v16 - v18;
          v28 = v24 - v25->ty;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          v29 = v26 * v27;
          v30 = *v9;
          tz = m_pMat->tz;
          v32 = (*v9)->m_pMat;
          if ( !v32 )
          {
            CPlaceable::AllocateMatrix(*v9);
            CSimpleTransform::UpdateMatrix(&v30->m_transform, v30->m_pMat);
            m_pMat = pEntity->m_pMat;
            v32 = v30->m_pMat;
          }
          v33 = v29 + (float)((float)(ty - v22) * v28);
          v34 = v32->tz;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          v35 = sqrtf(v33);
          v36 = *v9;
          v37 = tz - v34;
          v38 = m_pMat->tz;
          v39 = (*v9)->m_pMat;
          if ( !v39 )
          {
            CPlaceable::AllocateMatrix(*v9);
            CSimpleTransform::UpdateMatrix(&v36->m_transform, v36->m_pMat);
            v39 = v36->m_pMat;
          }
          v40 = v38 - v39->tz;
          if ( v37 < 0.0 )
            v40 = -v40;
          if ( (float)(v40 * 1.5) < v35 )
          {
            v41 = sqrtf((float)(v35 * v35) + (float)(v40 * v40));
            if ( v41 < v6 )
            {
              v6 = v41;
              v54 = v7;
            }
          }
        }
      }
      v7 = (__int16)(v7 + 1);
    }
    while ( v7 < pNum );
    if ( v6 < 9000.0 )
    {
      v42 = v58[v54];
      v43 = v42->m_pMat;
      p_tx = (const CVector *)&v43->tx;
      if ( !v43 )
        p_tx = &v42->m_transform.m_translate;
      if ( !CWorld::ProcessLineOfSight(vecStart, p_tx, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 1) )
      {
        v45 = v58[v54];
        v46 = v45->m_pMat;
        p_x = &v46->tx;
        y = vecStart->y;
        if ( !v46 )
          p_x = &v45->m_transform.m_translate.x;
        v49 = sqrtf(
                (float)((float)(pShotTarget->x - vecStart->x) * (float)(pShotTarget->x - vecStart->x))
              + (float)((float)(pShotTarget->y - y) * (float)(pShotTarget->y - y)));
        v50 = sqrtf(
                (float)((float)(*p_x - vecStart->x) * (float)(*p_x - vecStart->x))
              + (float)((float)(p_x[1] - y) * (float)(p_x[1] - y)));
        if ( (*(_BYTE *)&v45->m_info & 7) == 3 )
        {
          v51 = (float)(p_x[2] + 0.3) + -0.8;
          if ( (HIBYTE(v45[19].m_transform.m_heading) & 4) == 0 )
            v51 = p_x[2] + 0.3;
        }
        else
        {
          v51 = p_x[2] + 0.3;
        }
        pShotTarget->z = vecStart->z + (float)((float)(v49 / v50) * (float)(v51 - vecStart->z));
      }
    }
  }
}

//----- (005E02B8) --------------------------------------------------------
void __fastcall CWeapon::AddGunshell(
        CWeapon *this,
        CEntity *pEntity,
        const CVector *posGunshell,
        const CVector2D *dirGunshell,
        float fGunshellSize)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v12; // d16
  unsigned __int64 v13; // d1
  float y; // s2
  FxPrtMult_c *v15; // r0
  FxPrtMult_c v16; // [sp+18h] [bp-48h] BYREF
  RwV3d_0 vel; // [sp+34h] [bp-2Ch] BYREF

  if ( pEntity && CEntity::GetIsOnScreen(pEntity) )
  {
    m_pMat = pEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pEntity->m_transform;
    p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_m_transform = &TheCamera.m_transform;
    v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v13 = vmul_f32(v12, v12).n64_u64[0];
    if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                               * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                       + *(float *)&v13)
               + *((float *)&v13 + 1)) <= 100.0 )
    {
      y = dirGunshell->y;
      vel.x = (float)(dirGunshell->x * 20.0) * 0.05;
      vel.y = (float)(y * 20.0) * 0.05;
      vel.z = (float)((float)((float)((float)rand() * 4.6566e-10) * 0.06) + 0.02) * 20.0;
      rand();
      FxPrtMult_c::FxPrtMult_c(&v16, 0.5, 0.5, 0.5, 1.0, fGunshellSize, 1.0, 1.0);
      if ( (this->m_eWeaponType | 2) == 27 )
      {
        v16.m_green = 0.1;
        v16.m_red = 0.6;
        v16.m_blue = 0.1;
      }
      FxSystem_c::AddParticle(g_fx.m_fxSysGunshell, &posGunshell->RwV3d_0, &vel, 0.0, v15, -1.0, 1.2, 0.6, 0);
    }
  }
}
// 5E0400: variable 'v15' is possibly undefined

//----- (005E0430) --------------------------------------------------------
void __fastcall CWeapon::SetUpPelletCol(
        CWeapon *this,
        int nNumPellets,
        CEntity *pEntity,
        CEntity *pHitEntity,
        float *a5,
        float *a6,
        int a7)
{
  CCollisionData *m_pColData; // r6
  RwReal v11; // s0
  RwReal y; // s2
  RwReal v13; // s4
  CColLine *m_pLineArray; // r0
  float v15; // s8
  float v16; // s6
  float v17; // s16
  float v18; // s18
  CColLine *v19; // r0
  float v20; // s20
  int v21; // r8
  int v22; // r9
  float v23; // s22
  float v24; // r5
  float v25; // s19
  float v26; // r4
  float v27; // s0
  float *p_x; // r0
  float *v29; // r0
  const CVector *v30; // r6
  CVector *p_xy; // r1
  float v32; // s2
  float v33; // s4
  __int64 v34; // d16
  CMatrix *m_pMat; // r0
  CVector *v36; // r2
  int v37; // r0
  __int64 v38; // d16
  __int64 v39; // d16
  __int64 v40; // d16
  float v41; // s0
  float v42; // s2
  float v43; // s8
  float v44; // s0
  float v45; // s2
  CEntity *v46; // [sp+Ch] [bp-94h]
  CEntity *v47; // [sp+10h] [bp-90h]
  CVector v2; // [sp+14h] [bp-8Ch] BYREF
  CVector v49; // [sp+20h] [bp-80h] BYREF
  CVector v1; // [sp+30h] [bp-70h] BYREF

  m_pColData = CWeapon::ms_PelletTestCol.m_pColData;
  if ( !CWeapon::ms_PelletTestCol.m_pColData )
  {
    CColModel::AllocateData(&CWeapon::ms_PelletTestCol, 0, 0, 15, 0, 0, 0);
    CWeapon::ms_PelletTestCol.m_level = 0;
    m_pColData = CWeapon::ms_PelletTestCol.m_pColData;
    *(_QWORD *)&CWeapon::ms_PelletTestCol.m_sphereBound.m_vecCentre.x = 0LL;
    *(_QWORD *)&CWeapon::ms_PelletTestCol.m_sphereBound.m_vecCentre.z = 0x3F80000000000000LL;
  }
  v11 = *a6 - *a5;
  v13 = a6[2] - a5[2];
  v1.y = a6[1] - a5[1];
  y = v1.y;
  v1.x = v11;
  v1.z = v13;
  m_pLineArray = m_pColData->_anon_1.m_pLineArray;
  v15 = PELLET_COL_SCALE_RATIO_MULT * CWorld::fWeaponSpreadRate;
  m_pLineArray->m_vecStart.z = 0.0;
  m_pLineArray->m_vecStart.x = 0.0;
  v16 = sqrtf((float)(v13 * v13) + (float)((float)(v11 * v11) + (float)(y * y)));
  v17 = -(float)(v15 * v16);
  v18 = v15 * v16;
  m_pLineArray->m_vecStart.y = v17;
  v19 = m_pColData->_anon_1.m_pLineArray;
  v19->m_vecEnd.z = 0.0;
  v19->m_vecEnd.y = v15 * v16;
  v19->m_vecEnd.x = 0.0;
  if ( nNumPellets <= 1 )
  {
    v20 = v18 + v18;
    v23 = v18 * -2.0;
  }
  else
  {
    v20 = v18 + v18;
    v46 = pEntity;
    v47 = pHitEntity;
    v21 = nNumPellets - 1;
    v22 = 1;
    v23 = v18 * -2.0;
    do
    {
      v24 = (float)((float)((float)rand() * 4.6566e-10) * 6.2832) + -3.1416;
      v25 = (float)(v18 * 0.2) + (float)((float)(v18 - (float)(v18 * 0.2)) * (float)((float)rand() * 4.6566e-10));
      v26 = cosf(v24);
      --v21;
      v27 = sinf(v24) * v25;
      p_x = &m_pColData->_anon_1.m_pLineArray[v22].m_vecStart.x;
      *p_x = v26 * v25;
      p_x[1] = v23;
      p_x[2] = v27;
      v29 = &m_pColData->_anon_1.m_pLineArray[v22++].m_vecStart.x;
      v29[4] = v26 * v25;
      v29[5] = v20;
      v29[6] = v27;
    }
    while ( v21 );
    pEntity = v46;
    pHitEntity = v47;
  }
  m_pColData->_anon_0.m_nNoOfLines = nNumPellets;
  CWeapon::ms_PelletTestCol.m_boxBound.m_vecMin.x = -(float)(v15 * v16);
  CWeapon::ms_PelletTestCol.m_boxBound.m_vecMin.y = v23;
  CWeapon::ms_PelletTestCol.m_boxBound.m_vecMin.z = -(float)(v15 * v16);
  CWeapon::ms_PelletTestCol.m_boxBound.m_vecMax.x = v15 * v16;
  CWeapon::ms_PelletTestCol.m_boxBound.m_vecMax.y = v20;
  CWeapon::ms_PelletTestCol.m_boxBound.m_vecMax.z = v15 * v16;
  CWeapon::ms_PelletTestCol.m_sphereBound.m_fRadius = v18 * 2.5;
  if ( (*(_BYTE *)&pHitEntity->m_info & 7) == 1 )
  {
    v30 = (const CVector *)(a7 + 16);
    p_xy = (CVector *)(a6 + 4);
    v32 = -a6[5];
    v33 = -a6[6];
    *(float *)(a7 + 16) = -a6[4];
    *(float *)(a7 + 20) = v32;
    *(float *)(a7 + 24) = v33;
    if ( fabsf(a6[4]) >= 0.9 )
    {
      v2.y = 1.0;
      v2.x = 0.0;
    }
    else
    {
      v2.y = 0.0;
      v2.x = 1.0;
    }
    v2.z = 0.0;
    goto LABEL_21;
  }
  CVector::Normalise(&v1);
  v34 = *(_QWORD *)&v1.x;
  v30 = (const CVector *)(a7 + 16);
  *(RwReal *)(a7 + 24) = v1.z;
  *(_QWORD *)(a7 + 16) = v34;
  if ( fabsf(v1.z) <= 0.9 )
  {
    v2.x = 0.0;
    v2.y = 0.0;
    v37 = 1065353216;
LABEL_20:
    LODWORD(v2.z) = v37;
    p_xy = &v1;
LABEL_21:
    v36 = &v2;
    goto LABEL_22;
  }
  if ( (*(_BYTE *)&pEntity->m_info & 7) != 3 )
  {
    v37 = 0;
    v2.y = 0.0;
    v2.x = 1.0;
    goto LABEL_20;
  }
  m_pMat = pEntity->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(pEntity);
    CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
    m_pMat = pEntity->m_pMat;
  }
  p_xy = (CVector *)&m_pMat->xy;
  v36 = &v1;
LABEL_22:
  CrossProduct(&v49, p_xy, v36);
  v38 = *(_QWORD *)&v49.x;
  *(RwReal *)(a7 + 8) = v49.z;
  *(_QWORD *)a7 = v38;
  CVector::Normalise((CVector *)a7);
  CrossProduct(&v49, (const CVector *)a7, v30);
  v39 = *(_QWORD *)&v49.x;
  *(RwReal *)(a7 + 40) = v49.z;
  *(_QWORD *)(a7 + 32) = v39;
  v40 = *(_QWORD *)a6;
  *(float *)(a7 + 56) = a6[2];
  *(_QWORD *)(a7 + 48) = v40;
  if ( (*(_BYTE *)&pHitEntity->m_info & 7) != 1 )
  {
    v41 = *(float *)(a7 + 20);
    v42 = *(float *)(a7 + 24);
    v43 = (float)((float)(v30->x * a6[4]) + (float)(v41 * a6[5])) + (float)(v42 * a6[6]);
    v44 = (float)((float)(v41 * v17) * v43) + *(float *)(a7 + 52);
    v45 = (float)((float)(v42 * v17) * v43) + *(float *)(a7 + 56);
    *(float *)(a7 + 48) = *(float *)(a7 + 48) + (float)((float)(v30->x * v17) * v43);
    *(float *)(a7 + 52) = v44;
    *(float *)(a7 + 56) = v45;
  }
}

//----- (005E07D8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWeapon::DoBulletImpact(
        CWeapon *this,
        CEntity *pEntity,
        CEntity *pHitEntity,
        CVector *pShotOrigin,
        CVector *pShotTarget,
        CColPoint *pColPoint,
        int nIncrementalHit)
{
  float32x2_t v7; // d1
  float32x2_t v8; // d2
  CWeaponInfo *WeaponInfo; // r4
  CEntity::CEntityInfo m_info; // r0
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r0
  CEntity *v17; // r6
  CColPoint *v18; // r4
  int v19; // r10
  RwReal v20; // s0
  RwReal v21; // s4
  __int64 v22; // d16
  bool v23; // zf
  CEntity::CEntityInfo *p_m_info; // r5
  float StatValue; // s16
  const CPed *m_pRwObject; // r10
  CEntity::CEntityInfo v27; // r2
  int v28; // r0
  int v29; // r4
  int v30; // r1
  int v31; // r3
  int v32; // r1
  int v33; // r0
  _BOOL4 v34; // r0
  const CPed *v35; // r6
  int v36; // r0
  _BOOL4 IsPlayer; // r0
  int DamageEvent; // r6
  CEntity::CEntityInfo v39; // r0
  unsigned __int8 v40; // r5
  int v41; // r0
  unsigned __int8 v42; // r0
  uint16 *p_m_nScanCode; // r5
  int v44; // r6
  RwReal z; // r0
  int v46; // r0
  int v47; // r1
  eWeaponType v48; // r0
  int v49; // r1
  CVector *p_m_vecNormal; // r3
  float v51; // s0
  float v52; // s4
  float v53; // r0
  CMatrix *v54; // r0
  CSimpleTransform *v55; // r6
  CSimpleTransform *v56; // r1
  float v57; // s0
  int32 LocalDirection; // r3
  int v59; // r1
  Int32 v60; // r5
  CMatrix *v61; // r1
  float32x2_t v62; // d16
  unsigned __int64 v63; // d1
  int v64; // r1
  float m_nDamage; // s0
  float v66; // s0
  int v67; // r1
  int m_nFlags; // r0
  int v69; // r6
  int v70; // r0
  bool v71; // zf
  int32 v72; // r3
  float v73; // s0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r6
  float v76; // s0
  CMatrix *v77; // r0
  CSimpleTransform *p_m_transform; // r6
  float v79; // s8
  float v80; // s10
  float v81; // s0
  float v82; // s0
  float v83; // s4
  float v84; // r0
  unsigned int v85; // r0
  CPad *Pad; // r4
  CPlayerPed *PlayerPed; // r0
  CMatrix *v88; // r1
  float *p_x; // r2
  float v90; // r5
  CPlayerPed *v91; // r0
  CMatrix *v92; // r1
  CSimpleTransform *v93; // r2
  float y; // s16
  CPlayerPed *v95; // r0
  CMatrix *v96; // r1
  CSimpleTransform *v97; // r2
  CVector num; // [sp+0h] [bp-78h]
  CVector numa; // [sp+0h] [bp-78h]
  CWeaponInfo *v100; // [sp+14h] [bp-64h]
  int32 v101; // [sp+14h] [bp-64h]
  CVector *v102; // [sp+18h] [bp-60h]
  CEventVehicleDamage v103; // [sp+1Ch] [bp-5Ch] BYREF
  CVector2D v104; // [sp+38h] [bp-40h] BYREF
  CVector pStart; // [sp+40h] [bp-38h] BYREF
  CVector v106; // 0:r1.12
  CVector v107; // 0:r1.12

  WeaponInfo = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
  if ( !pEntity )
    goto LABEL_7;
  m_info = pEntity->m_info;
  if ( (*(_BYTE *)&m_info & 7) == 3 )
  {
    m_eWeaponType = this->m_eWeaponType;
    WeaponSkill = CPed::GetWeaponSkill((CPed *)pEntity);
    WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
    m_info = pEntity->m_info;
  }
  if ( (*(_BYTE *)&m_info & 7) == 3 && CPed::IsPlayer((const CPed *)pEntity) )
  {
    CCrime::ReportCrime(CRIME_POSSESSION_GUN, pHitEntity, (CPed *)pEntity);
    v17 = pEntity;
  }
  else
  {
LABEL_7:
    v17 = 0;
  }
  if ( !pHitEntity )
  {
    CBulletTraces::AddTrace(pShotOrigin, pShotTarget, this->m_eWeaponType, pEntity);
    if ( !pEntity )
      return;
    goto LABEL_161;
  }
  v100 = WeaponInfo;
  v19 = nIncrementalHit;
  v18 = pColPoint;
  if ( nIncrementalHit )
  {
    v20 = (float)((float)(pColPoint->m_vecPosition.x - pShotOrigin->x) * 0.4) + pShotOrigin->x;
    v21 = (float)((float)(pColPoint->m_vecPosition.z - pShotOrigin->z) * 0.4) + pShotOrigin->z;
    pStart.y = (float)((float)(pColPoint->m_vecPosition.y - pShotOrigin->y) * 0.4) + pShotOrigin->y;
    pStart.x = v20;
    pStart.z = v21;
  }
  else
  {
    v22 = *(_QWORD *)&pShotOrigin->x;
    pStart.z = pShotOrigin->z;
    *(_QWORD *)&pStart.x = v22;
  }
  CBulletTraces::AddTrace(&pStart, &pColPoint->m_vecPosition, this->m_eWeaponType, pEntity);
  v23 = pHitEntity == pEntity;
  v102 = pShotOrigin;
  if ( pHitEntity != pEntity )
    v23 = v17 == 0;
  if ( v23 && *(_BYTE *)&pEntity->m_info >= 8u )
  {
    p_m_info = &pHitEntity->m_info;
    goto LABEL_53;
  }
  p_m_info = &pHitEntity->m_info;
  if ( (unsigned __int8)((*(_BYTE *)&pHitEntity->m_info & 7) - 2) <= 2u )
  {
    StatValue = CStats::GetStatValue(0x80u);
    if ( StatValue <= CStats::GetStatValue(0x7Eu) )
      CStats::IncrementStat(0x80u, 1.0);
  }
  if ( (unsigned int)(this->m_eWeaponType - 22) > 0xA || (*(_BYTE *)&pEntity->m_info & 7) != 3 )
    goto LABEL_53;
  m_pRwObject = (const CPed *)pEntity[30].m_pRwObject;
  if ( !m_pRwObject )
    m_pRwObject = (const CPed *)pHitEntity;
  v27 = m_pRwObject->m_info;
  v28 = *(_BYTE *)&v27 & 7;
  switch ( v28 )
  {
    case 2:
      v29 = 0;
      if ( (m_pRwObject->m_PedWeaponAudioEntity.m_nLastChainsawEventTimeMs & 0x200000) != 0 )
      {
        v30 = 0;
        v31 = 0;
        if ( (*(_BYTE *)&v27 & 0xF8) != 40 )
          v30 = 1;
        if ( *(float *)&m_pRwObject->m_aPedFrames[14] > 0.0 )
          v31 = 1;
        v32 = v30 & v31;
        if ( (*((_BYTE *)&m_pRwObject->m_nPhysicalFlags + 2) & 4) == 0 )
          v29 = 1;
        v29 &= v32;
      }
      if ( (unsigned __int8)(pColPoint->m_dataB.m_nPieceType - 13) <= 3u )
      {
        v33 = (*((int (__fastcall **)(const CPed *))m_pRwObject->_vptr$CPlaceable + 45))(m_pRwObject);
        v27 = m_pRwObject->m_info;
        if ( !v33 )
          v29 = 0;
      }
      break;
    case 4:
      if ( m_pRwObject->m_PedAudioEntity.ScratchSound.m_EmittedVolume > 0.0
        && LOBYTE(m_pRwObject->m_PedAudioEntity.ScratchSound.m_pAudioEntity) )
      {
        v29 = *(float *)(LODWORD(m_pRwObject->m_PedAudioEntity.ScratchSound.m_FrequencyVariance) + 24) >= 0.5;
        break;
      }
      break;
    case 3:
      v29 = m_pRwObject->m_nHealth > 0.0;
      break;
    default:
      v29 = 0;
      break;
  }
  if ( (*(_BYTE *)&v27 & 7) != 3 )
  {
    v23 = v29 == 0;
    v19 = nIncrementalHit;
    v18 = pColPoint;
    if ( v23 )
      goto LABEL_53;
    goto LABEL_52;
  }
  v34 = CPedGroups::AreInSameGroup(m_pRwObject, (const CPed *)pEntity);
  if ( !v29 )
  {
    v19 = nIncrementalHit;
    v18 = pColPoint;
    goto LABEL_53;
  }
  v19 = nIncrementalHit;
  v18 = pColPoint;
  if ( !v34 )
LABEL_52:
    CStats::UpdateStatsWhenWeaponHit(this->m_eWeaponType);
LABEL_53:
  if ( (*(_BYTE *)p_m_info & 7) != 3 )
  {
    CGlass::WasGlassHitByBullet(pHitEntity, v18->m_vecPosition);
    v39 = *p_m_info;
    v40 = 8;
    v41 = *(_BYTE *)&v39 & 7;
    if ( v19 )
      v40 = 2;
    if ( v41 == 1 )
    {
      if ( CCamera::IsSphereVisible(&TheCamera, &v18->m_vecPosition, 1.0) )
        Fx_c::AddBulletImpact(
          &g_fx,
          &v18->m_vecPosition,
          &v18->m_vecNormal,
          v18->m_dataB.m_nSurfaceType,
          v40,
          (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                * (float)((float)((float)(v18->m_dataB.m_lighting >> 4) * 0.5) / 15.0))
        + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                * (float)((float)((float)(v18->m_dataB.m_lighting & 0xF) * 0.5) / 15.0)));
      if ( v17 )
      {
        z = v17[18].m_transform.m_translate.z;
        if ( z != 0.0 )
          *(_DWORD *)(LODWORD(z) + 156) = pHitEntity->m_nModelIndex;
      }
      goto LABEL_157;
    }
    if ( v41 != 4 )
    {
      if ( v41 == 2 )
      {
        if ( (unsigned __int8)(pColPoint->m_dataB.m_nPieceType - 13) > 3u )
        {
          m_nDamage = (float)v100->m_nDamage;
          if ( v17 && TheCamera.Cams[TheCamera.ActiveCam].Mode == 49 )
            m_nDamage = m_nDamage + m_nDamage;
          CVehicle::InflictDamage(
            (CVehicle *)pHitEntity,
            pEntity,
            this->m_eWeaponType,
            m_nDamage,
            pColPoint->m_vecPosition);
          if ( CCamera::IsSphereVisible(&TheCamera, &pColPoint->m_vecPosition, 1.0) )
            Fx_c::AddBulletImpact(
              &g_fx,
              &pColPoint->m_vecPosition,
              &pColPoint->m_vecNormal,
              pColPoint->m_dataB.m_nSurfaceType,
              v40,
              (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                    * (float)((float)((float)(pColPoint->m_dataB.m_lighting >> 4) * 0.5) / 15.0))
            + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                    * (float)((float)((float)(pColPoint->m_dataB.m_lighting & 0xF) * 0.5) / 15.0)));
          v66 = -10.0;
          switch ( this->m_eWeaponType )
          {
            case WEAPONTYPE_DESERT_EAGLE:
            case WEAPONTYPE_MINIGUN:
              v66 = -20.0;
              break;
            case WEAPONTYPE_SHOTGUN:
            case WEAPONTYPE_SPAS12_SHOTGUN:
              v66 = -4.0;
              break;
            default:
              break;
          }
          if ( g_LoadMonitor.m_eProcLevel <= eProcLevelMed )
          {
            v7.n64_f32[0] = *(float *)&pHitEntity[2].m_pRwObject / 1000.0;
            v8.n64_u32[0] = 1.0;
            v73 = v66 * vmin_f32(v7, v8).n64_f32[0];
            m_pMat = pHitEntity->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &pHitEntity->m_transform;
            v106.x = pColPoint->m_vecNormal.x * v73;
            v106.y = pColPoint->m_vecNormal.y * v73;
            v106.z = pColPoint->m_vecNormal.z * v73;
            num.x = pColPoint->m_vecPosition.x - p_tx->m_translate.x;
            num.y = pColPoint->m_vecPosition.y - p_tx->m_translate.y;
            num.z = pColPoint->m_vecPosition.z - p_tx->m_translate.z;
            CPhysical::ApplyForce((CPhysical *)pHitEntity, v106, num, 1);
          }
        }
        else
        {
          (*((void (__fastcall **)(CEntity *))pHitEntity->_vptr$CPlaceable + 45))(pHitEntity);
          Fx_c::AddTyreBurst(&g_fx, &pColPoint->m_vecPosition, &pColPoint->m_vecNormal);
          if ( pEntity && (*(_BYTE *)&pEntity->m_info & 7) == 3 )
          {
            if ( pHitEntity[18].m_pLastRenderedLink )
            {
              CEventVehicleDamage::CEventVehicleDamage(
                &v103,
                (CVehicle *)pHitEntity,
                pEntity,
                (const eWeaponType)this->m_eWeaponType);
              v103._vptr$CEvent = (int (**)(void))&off_669BAC;
              CEventGroup::Add(
                (CEventGroup *)&pHitEntity[18].m_pLastRenderedLink[90].m_pNext[8].m_pNext,
                (CEvent *)&v103,
                0);
              CEventVehicleDamage::~CEventVehicleDamage(&v103);
            }
            v42 = (unsigned __int8)pHitEntity[19].m_pRwObject;
            if ( v42 )
            {
              p_m_nScanCode = &pHitEntity[18].m_nScanCode;
              v44 = 0;
              do
              {
                if ( *(_DWORD *)&p_m_nScanCode[2 * v44] )
                {
                  CEventVehicleDamage::CEventVehicleDamage(
                    &v103,
                    (CVehicle *)pHitEntity,
                    pEntity,
                    (const eWeaponType)this->m_eWeaponType);
                  v103._vptr$CEvent = (int (**)(void))&off_669BAC;
                  CEventGroup::Add(
                    (CEventGroup *)(*(_DWORD *)(*(_DWORD *)&p_m_nScanCode[2 * v44] + 1088) + 104),
                    (CEvent *)&v103,
                    0);
                  CEventVehicleDamage::~CEventVehicleDamage(&v103);
                  v42 = (unsigned __int8)pHitEntity[19].m_pRwObject;
                }
                ++v44;
              }
              while ( v44 < v42 );
            }
          }
        }
      }
      goto LABEL_157;
    }
    if ( CCamera::IsSphereVisible(&TheCamera, &v18->m_vecPosition, 1.0) )
      Fx_c::AddBulletImpact(
        &g_fx,
        &v18->m_vecPosition,
        &v18->m_vecNormal,
        v18->m_dataB.m_nSurfaceType,
        v40,
        (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
              * (float)((float)((float)(v18->m_dataB.m_lighting >> 4) * 0.5) / 15.0))
      + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
              * (float)((float)((float)(v18->m_dataB.m_lighting & 0xF) * 0.5) / 15.0)));
    if ( *(_BYTE *)&pHitEntity[5].m_nFlags >= 0xC8u )
    {
      v46 = *(_DWORD *)&pHitEntity[5].numLodChildren;
      v47 = *(_DWORD *)(v46 + 72);
      if ( v47 == 2 )
      {
        CObject::ObjectDamage(
          (CObject *)pHitEntity,
          *(float *)(v46 + 52) * 151.0,
          &v18->m_vecPosition,
          &v18->m_vecNormal,
          (int)pEntity,
          this->m_eWeaponType);
LABEL_157:
        if ( nIncrementalHit <= 0 )
        {
          v82 = pShotTarget->x - v102->x;
          v83 = pShotTarget->z - v102->z;
          *(float *)&v103.m_iAccumulatedTime = pShotTarget->y - v102->y;
          *(float *)&v103._vptr$CEvent = v82;
          *(float *)&v103.m_bIsPersistent = v83;
          CVector::Normalise((CVector *)&v103);
          if ( (float)((float)((float)(*(float *)&v103._vptr$CEvent * pColPoint->m_vecNormal.x)
                             + (float)(*(float *)&v103.m_iAccumulatedTime * pColPoint->m_vecNormal.y))
                     + (float)(*(float *)&v103.m_bIsPersistent * pColPoint->m_vecNormal.z)) < 0.0 )
          {
            v84 = asinf(-(float)((float)((float)(*(float *)&v103._vptr$CEvent * pColPoint->m_vecNormal.x)
                                       + (float)(*(float *)&v103.m_iAccumulatedTime * pColPoint->m_vecNormal.y))
                               + (float)(*(float *)&v103.m_bIsPersistent * pColPoint->m_vecNormal.z)));
            CAudioEngine::ReportBulletHit(
              &AudioEngine,
              pHitEntity,
              pColPoint->m_dataB.m_nSurfaceType,
              &pColPoint->m_vecPosition,
              (float)(v84 * 180.0) / 3.1416);
          }
        }
LABEL_160:
        if ( !pEntity )
          return;
        goto LABEL_161;
      }
      if ( v47 == 1 )
      {
        v48 = this->m_eWeaponType;
        v49 = 1125580800;
        p_m_vecNormal = &v18->m_vecNormal;
LABEL_156:
        CObject::ObjectDamage(
          (CObject *)pHitEntity,
          *(float *)&v49,
          &v18->m_vecPosition,
          p_m_vecNormal,
          (int)pEntity,
          v48);
        goto LABEL_157;
      }
LABEL_155:
      v48 = this->m_eWeaponType;
      v49 = 1112014848;
      p_m_vecNormal = &v18->m_vecNormal;
      goto LABEL_156;
    }
    if ( (LOBYTE(pHitEntity[1].m_transform.m_translate.y) & 4) != 0 )
      goto LABEL_155;
    v67 = *(_DWORD *)&pHitEntity[5].numLodChildren;
    if ( *(float *)(v67 + 24) >= 99.9 )
      goto LABEL_155;
    m_nFlags = (int)pHitEntity->m_nFlags;
    if ( (m_nFlags & 0x40004) != 0 )
    {
      v69 = nIncrementalHit;
      if ( *(float *)(v67 + 20) <= 0.0 )
      {
        (*((void (__fastcall **)(CEntity *, _DWORD))pHitEntity->_vptr$CPlaceable + 5))(pHitEntity, 0);
        CPhysical::AddToMovingList((CPhysical *)pHitEntity);
        if ( (*(_DWORD *)&pHitEntity->m_nFlags & 0x40004) != 0 )
          goto LABEL_155;
LABEL_148:
        v76 = -0.2;
        v77 = pHitEntity->m_pMat;
        if ( (LODWORD(pHitEntity[1].m_transform.m_translate.y) & 0xA0) == 0 )
          v76 = -2.0;
        v23 = v69 == 0;
        p_m_transform = (CSimpleTransform *)&v77->tx;
        if ( !v23 )
          v76 = v76 * 0.2;
        v79 = v18->m_vecNormal.x * v76;
        v80 = v18->m_vecNormal.y * v76;
        v81 = v18->m_vecNormal.z * v76;
        if ( !v77 )
          p_m_transform = &pHitEntity->m_transform;
        v107.x = v79;
        *(_QWORD *)&v107.y = __PAIR64__(LODWORD(v81), LODWORD(v80));
        numa.x = v18->m_vecPosition.x - p_m_transform->m_translate.x;
        numa.y = v18->m_vecPosition.y - p_m_transform->m_translate.y;
        numa.z = v18->m_vecPosition.z - p_m_transform->m_translate.z;
        CPhysical::ApplyForce((CPhysical *)pHitEntity, v107, numa, 1);
        goto LABEL_155;
      }
    }
    else
    {
      v69 = nIncrementalHit;
    }
    if ( (m_nFlags & 0x40004) != 0 )
      goto LABEL_155;
    goto LABEL_148;
  }
  v35 = (const CPed *)pEntity;
  if ( (*(_BYTE *)&pEntity->m_info & 7) != 3 )
    v35 = 0;
  if ( v35
    && (v36 = *(int *)((char *)&elf_hash_bucket[296] + (_DWORD)v35), v36 == *(_DWORD *)&pHitEntity[23].numLodChildren)
    && (v36 & 0xFFFFFFFE) != 4 )
  {
    IsPlayer = CPed::IsPlayer(v35);
    if ( v35 == pHitEntity || !IsPlayer )
      return;
  }
  else if ( v35 == pHitEntity )
  {
    return;
  }
  if ( v19 <= 0 )
  {
    v51 = pShotTarget->x - v102->x;
    v52 = pShotTarget->z - v102->z;
    *(float *)&v103.m_iAccumulatedTime = pShotTarget->y - v102->y;
    *(float *)&v103._vptr$CEvent = v51;
    *(float *)&v103.m_bIsPersistent = v52;
    CVector::Normalise((CVector *)&v103);
    if ( (float)((float)((float)(*(float *)&v103._vptr$CEvent * v18->m_vecNormal.x)
                       + (float)(*(float *)&v103.m_iAccumulatedTime * v18->m_vecNormal.y))
               + (float)(*(float *)&v103.m_bIsPersistent * v18->m_vecNormal.z)) < 0.0 )
    {
      v53 = asinf(-(float)((float)((float)(*(float *)&v103._vptr$CEvent * v18->m_vecNormal.x)
                                 + (float)(*(float *)&v103.m_iAccumulatedTime * v18->m_vecNormal.y))
                         + (float)(*(float *)&v103.m_bIsPersistent * v18->m_vecNormal.z)));
      CAudioEngine::ReportBulletHit(
        &AudioEngine,
        pHitEntity,
        v18->m_dataB.m_nSurfaceType,
        &v18->m_vecPosition,
        (float)(v53 * 180.0) / 3.1416);
    }
    v54 = pHitEntity->m_pMat;
    v55 = &pHitEntity->m_transform;
    v56 = &pHitEntity->m_transform;
    if ( v54 )
      v56 = (CSimpleTransform *)&v54->tx;
    v57 = v102->x - v56->m_translate.x;
    v104.y = v102->y - v56->m_translate.y;
    v104.x = v57;
    LocalDirection = CPed::GetLocalDirection((CPed *)pHitEntity, &v104);
    v59 = 1;
    if ( nIncrementalHit < 0 )
      v59 = -nIncrementalHit;
    v60 = v59 * v100->m_nDamage;
    if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    {
      v101 = LocalDirection;
      if ( !CPed::IsPlayer((const CPed *)pEntity) )
        goto LABEL_123;
      v61 = pHitEntity->m_pMat;
      if ( v61 )
        v55 = (CSimpleTransform *)&v61->tx;
      v62.n64_u64[0] = vsub_f32(*(float32x2_t *)&v55->m_translate.y, *(float32x2_t *)&v102->y).n64_u64[0];
      v63 = vmul_f32(v62, v62).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(v55->m_translate.x - v102->x) * (float)(v55->m_translate.x - v102->x))
                   + *(float *)&v63)
           + *((float *)&v63 + 1)) < 1.0 )
      {
        LocalDirection = v101;
        if ( (BYTE1(pHitEntity[19].m_pMat) & 0x10) == 0 )
        {
          v64 = v60;
          if ( this->m_eWeaponType != WEAPONTYPE_SHOTGUN )
            v64 = 150;
          if ( this->m_eWeaponType != WEAPONTYPE_SPAS12_SHOTGUN )
            v60 = v64;
        }
      }
      else
      {
LABEL_123:
        LocalDirection = v101;
      }
    }
    v19 = nIncrementalHit;
    DamageEvent = CWeapon::GenerateDamageEvent(
                    (CPed *)pHitEntity,
                    pEntity,
                    this->m_eWeaponType,
                    v60,
                    (ePedPieceTypes)v18->m_dataB.m_nPieceType,
                    LocalDirection);
  }
  else
  {
    DamageEvent = 1;
  }
  if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)pEntity) )
    CCrime::ReportCrime(CRIME_SHOOT_PED, pHitEntity, (CPed *)pEntity);
  v70 = CLocalisation::Blood();
  v71 = DamageEvent == 0;
  if ( DamageEvent )
    v71 = v70 == 0;
  if ( v71 )
    goto LABEL_160;
  v72 = 8;
  if ( v19 )
    v72 = 4;
  if ( v18->m_dataB.m_nPieceType == 9 )
  {
    if ( *(float *)&pHitEntity[22].m_nFlags >= 0.0 )
      v72 = 16;
    else
      v72 = 32;
  }
  Fx_c::AddBlood(&g_fx, &v18->m_vecPosition, &v18->m_vecNormal, v72, pHitEntity[5].m_transform.m_translate.x);
  if ( pEntity )
  {
LABEL_161:
    if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    {
      v85 = *(_DWORD *)&pEntity[23].numLodChildren;
      if ( v85 <= 1 )
      {
        Pad = CPad::GetPad(v85);
        PlayerPed = FindPlayerPed(-1);
        v88 = PlayerPed->m_pMat;
        p_x = &v88->tx;
        if ( !v88 )
          p_x = &PlayerPed->m_transform.m_translate.x;
        v90 = *p_x;
        v91 = FindPlayerPed(-1);
        v92 = v91->m_pMat;
        v93 = (CSimpleTransform *)&v92->tx;
        if ( !v92 )
          v93 = &v91->m_transform;
        y = v93->m_translate.y;
        v95 = FindPlayerPed(-1);
        v96 = v95->m_pMat;
        v97 = (CSimpleTransform *)&v96->tx;
        if ( !v96 )
          v97 = &v95->m_transform;
        CPad::StartShake_Distance(Pad, 240, 0x80u, v90, y, v97->m_translate.z);
      }
    }
  }
}
// 5E07D8: variables would overlap: ^84.4 and ^84.8
// FC: using guessed type int elf_hash_bucket[16411];
// 669BAC: using guessed type void *off_669BAC;

//----- (005E1394) --------------------------------------------------------
bool8 __fastcall CWeapon::GenerateDamageEvent(
        CPed *pHitPed,
        CEntity *pEntity,
        eWeaponType WeaponType,
        Int32 WeaponDamage,
        ePedPieceTypes PieceType,
        Int32 dir)
{
  float *p_m_nHealth; // r9
  CTask *SimplestActiveTask; // r0
  CAnimBlendAssociation *FirstAssociation; // r0
  AnimationId v12; // r2
  CAnimBlendAssociation *v13; // r0
  CAnimBlendAssociation *v14; // r4
  bool v15; // r5
  CEntity::CEntityInfo m_info; // r0
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v18; // r0
  CTask *ActiveTask; // r0
  char v20; // r0
  CTask *v21; // r0
  CEventDamage v23; // [sp+10h] [bp-70h] BYREF
  CPedDamageResponseCalculator v24; // [sp+50h] [bp-30h] BYREF

  CPedDamageResponseCalculator::CPedDamageResponseCalculator(
    &v24,
    pEntity,
    (float)WeaponDamage,
    WeaponType,
    PieceType,
    0);
  CEventDamage::CEventDamage(
    &v23,
    pEntity,
    CTimer::m_snTimeInMilliseconds,
    WeaponType,
    PieceType,
    dir,
    0,
    *(_DWORD *)&pHitPed->m_nPedFlags & 0x100);
  p_m_nHealth = &pHitPed->m_nHealth;
  if ( pHitPed->m_nHealth <= 0.0 )
  {
    if ( CLocalisation::Blood() )
    {
      if ( CLocalisation::KickingWhenDown() )
      {
        if ( CTaskManager::GetSimplestActiveTask(&pHitPed->m_pPedIntelligence->m_taskManager) )
        {
          SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&pHitPed->m_pPedIntelligence->m_taskManager);
          if ( (*((int (__fastcall **)(CTask *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask) == 218 )
          {
            FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pHitPed->m_pRwObject, 0x800u);
            v12 = ANIM_STD_HIT_FLOOR_FRONT;
            if ( !FirstAssociation )
              v12 = ANIM_STD_HIT_FLOOR;
            v13 = CAnimManager::BlendAnimation((RpClump_0 *)pHitPed->m_pRwObject, ANIM_STD_PED, v12, 8.0);
            v14 = v13;
            if ( v13 )
            {
              CAnimBlendAssociation::SetCurrentTime(v13, 0.0);
              v15 = 1;
              v14->m_bitsFlag = v14->m_bitsFlag & 0xFFF6 | 1;
              goto LABEL_50;
            }
LABEL_21:
            v15 = 1;
            goto LABEL_50;
          }
        }
      }
    }
  }
  if ( !CPed::IsAlive(pHitPed) )
    goto LABEL_21;
  if ( !CEventDamage::AffectsPed(&v23, pHitPed) )
  {
    v15 = 0;
    goto LABEL_50;
  }
  if ( FindPlayerPed(-1) == pEntity )
    CCrime::ReportCrime(CRIME_HIT_PED, pHitPed, (CPed *)pEntity);
  CPedDamageResponseCalculator::ComputeDamageResponse(&v24, pHitPed, &v23.m_pedDamageResponse, 1);
  if ( CWeaponInfo::GetWeaponInfo(WeaponType, 1)->m_eFireType )
  {
    v15 = 1;
    if ( !pEntity || WeaponType != WEAPONTYPE_FALL )
    {
LABEL_24:
      if ( !pEntity )
        goto LABEL_43;
      goto LABEL_38;
    }
    m_info = pEntity->m_info;
    if ( (*(_BYTE *)&m_info & 7) != 4 )
    {
      v15 = 1;
      goto LABEL_39;
    }
  }
  if ( *((unsigned __int8 *)&pHitPed->m_nPedFlags + 1) << 31 )
  {
    v15 = 1;
    goto LABEL_24;
  }
  if ( *p_m_nHealth <= 0.0 )
    CEventDamage::ComputeDeathAnim(&v23, pHitPed, 1);
  else
    CEventDamage::ComputeDamageAnim(&v23, pHitPed, 1);
  if ( v23.m_nAnimId < ANIM_STD_HITBYGUN_FRONT )
    goto LABEL_36;
  if ( v23.m_nAnimId <= ANIM_STD_HITBYGUN_RIGHT )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pHitPed->m_pRwObject, v23.m_nAnimId);
    if ( !Association )
      Association = CAnimManager::AddAnimation((RpClump_0 *)pHitPed->m_pRwObject, v23.m_nAnimGroup, v23.m_nAnimId);
    Association->m_fBlendAmount = 0.0;
    Association->m_fBlendDelta = v23.m_fAnimBlendSpeed;
    Association->m_fSpeed = v23.m_fAnimPlaySpeed;
    CAnimBlendAssociation::SetCurrentTime(Association, 0.0);
LABEL_37:
    v15 = 1;
    *((_BYTE *)&v23 + 33) |= 4u;
    if ( !pEntity )
    {
LABEL_43:
      v20 = 0;
      goto LABEL_45;
    }
    goto LABEL_38;
  }
  if ( (unsigned int)(v23.m_nAnimId - 191) >= 2 )
  {
LABEL_36:
    v18 = CAnimManager::BlendAnimation(
            (RpClump_0 *)pHitPed->m_pRwObject,
            v23.m_nAnimGroup,
            v23.m_nAnimId,
            v23.m_fAnimBlendSpeed);
    v18->m_fSpeed = v23.m_fAnimPlaySpeed;
    goto LABEL_37;
  }
  v15 = v23.m_nAnimId != ANIM_DOOR_OPENLEFT;
  if ( !pEntity )
    goto LABEL_43;
LABEL_38:
  m_info = pEntity->m_info;
LABEL_39:
  if ( (*(_BYTE *)&m_info & 7) != 3 )
    goto LABEL_43;
  ActiveTask = CTaskManager::GetActiveTask((const CTaskManager *)(LODWORD(pEntity[18].m_transform.m_translate.y) + 4));
  if ( ActiveTask && (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) == 1027 )
    v20 = 16;
  else
    v20 = 16 * (WeaponType == WEAPONTYPE_PISTOL_SILENCED);
LABEL_45:
  *((_BYTE *)&v23 + 33) = v20 | *((_BYTE *)&v23 + 33) & 0xEF;
  if ( !(*((unsigned __int8 *)&pHitPed->m_nPedFlags + 1) << 31)
    || *p_m_nHealth <= 0.0
    || !CTaskManager::GetActiveTask(&pHitPed->m_pPedIntelligence->m_taskManager)
    || (v21 = CTaskManager::GetActiveTask(&pHitPed->m_pPedIntelligence->m_taskManager),
        (*((int (__fastcall **)(CTask *))v21->_vptr$CTask + 5))(v21) != 1022) )
  {
    CEventGroup::Add(&pHitPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v23, 0);
  }
LABEL_50:
  CEventDamage::~CEventDamage(&v23);
  CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v24);
  return v15;
}
// 5E1394: using guessed type Int32 arg_4;

//----- (005E161C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CEntity *__fastcall CWeapon::PickTargetForHeatSeekingMissile(
        CVector Origin,
        CVector AimingVector,
        float Tolerance,
        CEntity *pException,
        int bPlanesPriority,
        CEntity *pPreferredExistingTarget)
{
  uint8 *v6; // r10
  CVehiclePool *v7; // r6
  int32 m_nSize; // r5
  CEntity *v9; // r12
  float v10; // s18
  int i; // r0
  uint8 *v12; // r2
  bool v13; // zf
  float v14; // s0
  int v15; // r0
  int v16; // r2
  int v17; // r0
  uint8 *v19; // [sp+Ch] [bp-4Ch]
  CVector vAimingVector; // [sp+10h] [bp-48h] BYREF
  CVector vOrigin; // [sp+1Ch] [bp-3Ch] BYREF

  v6 = 0;
  v7 = CPools::ms_pVehiclePool;
  vAimingVector = AimingVector;
  vOrigin.y = (float)(AimingVector.y * 5.0) + Origin.y;
  vOrigin.z = (float)(AimingVector.z * 5.0) + Origin.z;
  vOrigin.x = (float)(AimingVector.x * 5.0) + Origin.x;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v9 = pPreferredExistingTarget;
    v10 = 100000.0;
    do
    {
      for ( i = m_nSize--; ; --i )
      {
        if ( (v7->m_aFlags[m_nSize] & 0x80u) == 0 )
        {
          v12 = v7->m_aStorage[i];
          v13 = v12 == (uint8 *)&elf_hash_bucket[588];
          if ( v12 != (uint8 *)&elf_hash_bucket[588] )
            v13 = (_BYTE (*)[2604])((char *)v7->m_aStorage - (char *)pException + i * 2604) == (_BYTE (*)[2604])&elf_hash_bucket[588];
          if ( !v13 && (*(v12 - 1531) & 0x40) != 0 && *((float *)v12 - 344) > 0.0 )
            break;
        }
        if ( --m_nSize == -1 )
          return (CEntity *)v6;
      }
      v19 = v12 - 2604;
      v14 = CWeapon::EvaluateTargetForHeatSeekingMissile(
              (CEntity *)(v12 - 2604),
              &vOrigin,
              &vAimingVector,
              Tolerance,
              bPlanesPriority,
              v9);
      v15 = 0;
      v16 = 0;
      v9 = pPreferredExistingTarget;
      if ( v14 < v10 )
        v15 = 1;
      if ( v14 >= 0.0 )
        v16 = 1;
      v17 = v15 & v16;
      if ( v17 )
        v10 = v14;
      if ( v17 )
        v6 = v19;
    }
    while ( m_nSize );
  }
  return (CEntity *)v6;
}
// 5E161C: fragmented variable at 0:r3.4,4:^60.8 may be wrong
// 5E161C: variables would overlap: 0:r3.4,4:^60.8 and ^60.4
// 5E161C: variables would overlap: 0:r3.4,4:^60.8 and ^64.4
// FC: using guessed type int elf_hash_bucket[16411];
// 5E161C: using guessed type int bPlanesPriority_0;

//----- (005E1754) --------------------------------------------------------
void __fastcall CWeapon::DoWeaponEffect(CWeapon *this, CVector shotOrigin, CVector shotVector)
{
  FxSystem_c *m_eWeaponType; // r0
  const char *v5; // r0
  __int64 v6; // d16
  FxSystem_c *m_pWeaponFxSys; // r6
  RwMatrix *v8; // r5
  FxSystem_c *v9; // r0
  bool v10; // zf
  RwV3d_0 offsetPos; // [sp+4h] [bp-5Ch] BYREF
  CVector dir; // [sp+10h] [bp-50h] BYREF
  CVector pos; // [sp+1Ch] [bp-44h] BYREF
  unsigned __int8 bpName[8]; // [sp+28h] [bp-38h] BYREF
  char v15; // [sp+30h] [bp-30h]

  pos = shotOrigin;
  dir = shotVector;
  m_eWeaponType = (FxSystem_c *)this->m_eWeaponType;
  if ( m_eWeaponType == (FxSystem_c *)&word_2A )
  {
    v5 = "extinguisher";
    goto LABEL_6;
  }
  if ( m_eWeaponType == (FxSystem_c *)((char *)&word_28 + 1) )
  {
    v6 = *(_QWORD *)"spraycan";
    v15 = 0;
LABEL_8:
    *(_QWORD *)bpName = v6;
    m_pWeaponFxSys = this->m_pWeaponFxSys;
    v8 = RwMatrixCreate();
    Fx_c::CreateMatFromVec(&g_fx, v8, &pos, &dir);
    if ( m_pWeaponFxSys )
    {
      FxSystem_c::SetMatrix(this->m_pWeaponFxSys, v8);
    }
    else
    {
      memset(&offsetPos, 0, sizeof(offsetPos));
      v9 = FxManager_c::CreateFxSystem(&g_fxMan, bpName, &offsetPos, v8, 0);
      this->m_pWeaponFxSys = v9;
      if ( !v9 )
      {
LABEL_13:
        RwMatrixDestroy(v8);
        return;
      }
      FxSystem_c::CopyParentMatrix(v9);
      FxSystem_c::Play(this->m_pWeaponFxSys);
      FxSystem_c::SetMustCreatePrts(this->m_pWeaponFxSys, 1u);
    }
    FxSystem_c::SetConstTime(this->m_pWeaponFxSys, 1u, 1.0);
    goto LABEL_13;
  }
  if ( m_eWeaponType == (FxSystem_c *)((char *)&dword_24 + 1) )
  {
    v5 = "flamethrower";
LABEL_6:
    v6 = *(_QWORD *)v5;
    *(_QWORD *)((unsigned int)bpName | 5) = *(_QWORD *)(v5 + 5);
    goto LABEL_8;
  }
  v10 = m_eWeaponType == (FxSystem_c *)&word_12;
  if ( m_eWeaponType != (FxSystem_c *)&word_12 )
  {
    m_eWeaponType = this->m_pWeaponFxSys;
    v10 = m_eWeaponType == 0;
  }
  if ( !v10 )
  {
    FxSystem_c::Kill(m_eWeaponType);
    this->m_pWeaponFxSys = 0;
  }
}
// 12: using guessed type __int16 word_12;
// 24: using guessed type int dword_24;
// 28: using guessed type __int16 word_28;
// 2A: using guessed type __int16 word_2A;

//----- (005E1870) --------------------------------------------------------
bool __fastcall CWeapon::LaserScopeDot(CWeapon *this, CVector *ScreenCoords, float *fScale)
{
  bool v3; // r6
  float m_fWeaponRange; // s22
  float *v8; // r1
  float v9; // s4
  float v10; // s6
  float v11; // s10
  float v12; // s0
  float v13; // s8
  float v14; // s12
  __int64 v15; // d16
  RwReal y; // r1
  RwReal z; // r2
  float pScaleY; // [sp+48h] [bp-A0h] BYREF
  float pScaleX; // [sp+4Ch] [bp-9Ch] BYREF
  RwV3d_0 pResult; // [sp+50h] [bp-98h] BYREF
  CEntity *refEntityPtr; // [sp+5Ch] [bp-8Ch] BYREF
  CColPoint colPoint; // [sp+60h] [bp-88h] BYREF
  CVector vecStart; // [sp+8Ch] [bp-5Ch] BYREF
  CVector v25; // [sp+98h] [bp-50h] BYREF

  v3 = 0;
  refEntityPtr = 0;
  m_fWeaponRange = CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1)->m_fWeaponRange;
  v8 = (float *)((char *)&TheCamera + 528 * TheCamera.ActiveCam);
  v9 = v8[183] * 0.5;
  v10 = v8[184] * 0.5;
  v11 = v8[186];
  v12 = v8[182] * 0.5;
  v13 = v8[185];
  v14 = v8[187];
  v15 = *((_QWORD *)v8 + 91);
  v25.z = v8[184];
  *(_QWORD *)&v25.x = v15;
  vecStart.z = v10 + v14;
  vecStart.y = v9 + v11;
  vecStart.x = v12 + v13;
  CVector::Normalise(&v25);
  v25.x = (float)(v12 + v13) + (float)(m_fWeaponRange * v25.x);
  v25.y = (float)(v9 + v11) + (float)(m_fWeaponRange * v25.y);
  v25.z = (float)(v10 + v14) + (float)(m_fWeaponRange * v25.z);
  if ( CWorld::ProcessLineOfSight(&vecStart, &v25, &colPoint, &refEntityPtr, 1, 1, 1, 1, 0, 0, 0, 0) == 1 )
  {
    pResult = (RwV3d_0)colPoint.m_vecPosition;
    if ( CSprite::CalcScreenCoors(&colPoint.m_vecPosition, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
    {
      v3 = 1;
      y = pResult.y;
      z = pResult.z;
      ScreenCoords->x = pResult.x;
      ScreenCoords->y = y;
      ScreenCoords->z = z;
      *fScale = pScaleX / 20.0;
      CCoronas::RegisterCorona(
        (u_native)&this->m_eState + 3,
        0,
        0x80u,
        0,
        0,
        0xFFu,
        &colPoint.m_vecPosition,
        1.2,
        50.0,
        0,
        0,
        1u,
        0,
        1u,
        0.0,
        0,
        1.5,
        0,
        15.0,
        0,
        0);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

//----- (005E19F4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWeapon::FireInstantHitFromCar2(
        CWeapon *this,
        CVector vecShotOrigin,
        CVector vecShotTarget,
        CVehicle *pVehicle,
        CEntity *pShotOwner)
{
  RwReal x; // r4
  __int64 v6; // r10
  CPlayerPed *PlayerPed; // r5
  CPlayerPed *v9; // r0
  char v10; // r1
  RwReal v11; // r2
  char v12; // r0
  int v13; // r3
  CVehicle *v14; // r1
  CEventGlobalGroup *EventGlobalGroup; // r0
  __int128 Dir; // [sp+0h] [bp-C0h] BYREF
  bool bSilent[4]; // [sp+10h] [bp-B0h]
  CWeapon *v18; // [sp+28h] [bp-98h]
  CEventGunShot v19; // [sp+2Ch] [bp-94h] BYREF
  CColPoint colPoint; // [sp+5Ch] [bp-64h] BYREF
  CEntity *refEntityPtr; // [sp+88h] [bp-38h] BYREF
  CVector pShotEnd; // [sp+8Ch] [bp-34h] BYREF
  CVector pShotStart; // [sp+98h] [bp-28h] BYREF
  CVector v24; // 0:r1.12

  x = vecShotOrigin.x;
  v6 = *(_QWORD *)&vecShotOrigin.y;
  pShotEnd = vecShotTarget;
  pShotStart = vecShotOrigin;
  v18 = this;
  CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1);
  refEntityPtr = 0;
  PlayerPed = FindPlayerPed(-1);
  v9 = FindPlayerPed(-1);
  CCrime::ReportCrime(CRIME_POSSESSION_GUN, PlayerPed, v9);
  v10 = 0;
  v11 = x;
  if ( this->m_eWeaponType == WEAPONTYPE_TEARGAS )
    v10 = 1;
  v12 = 0;
  v13 = v6;
  if ( this->m_eWeaponType == WEAPONTYPE_PISTOL_SILENCED )
    v12 = 1;
  bSilent[0] = v12 | v10;
  v14 = pVehicle;
  *(CVector *)((char *)&Dir + 4) = vecShotTarget;
  LODWORD(Dir) = HIDWORD(v6);
  if ( pShotOwner )
    v14 = (CVehicle *)pShotOwner;
  CEventGunShot::CEventGunShot(&v19, v14, *(CVector *)&v11, *(CVector *)((char *)&Dir + 4), bSilent[0]);
  EventGlobalGroup = GetEventGlobalGroup();
  CEventGroup::Add(EventGlobalGroup, (CEvent *)&v19, 0);
  CInterestingEvents::Add(&g_InterestingEvents, EGunshotFired, pShotOwner);
  v24.x = x;
  *(_QWORD *)&v24.y = v6;
  memset(&Dir, 0, 12);
  CPointLights::AddLight(0, v24, (CVector)Dir, 3.0, 0.25, 0.22, 0.0, 0, 0, 0);
  CWorld::pIgnoreEntity = pVehicle;
  CWorld::bIncludeBikers = 1;
  CBirds::HandleGunShot(&pShotStart, &pShotEnd);
  CShadows::GunShotSetsOilOnFire(&pShotStart, &pShotEnd);
  CWorld::ProcessLineOfSight(
    &pShotStart,
    &pShotEnd,
    &colPoint,
    &refEntityPtr,
    (int)&dword_0 + 1,
    (int)&dword_0 + 1,
    (int)&dword_0 + 1,
    (int)&dword_0 + 1,
    (int)&dword_0 + 1,
    0,
    0,
    1);
  CWorld::ResetLineTestOptions();
  CWeapon::DoBulletImpact(v18, pShotOwner, refEntityPtr, &pShotStart, &pShotEnd, &colPoint, 0);
  CEventGunShotWhizzedBy::~CEventGunShotWhizzedBy(&v19);
}
// 5E19F4: fragmented variable at r2.4 may be wrong
// 5E19F4: fragmented variable at r3.4 may be wrong
// 5E19F4: fragmented variable at ^0.4 may be wrong
// 0: using guessed type int dword_0;

//----- (005E1B4C) --------------------------------------------------------
void __fastcall CWeapon::DoTankDoomAiming(
        CEntity *pTankEntity,
        CEntity *pDriverEntity,
        CVector *pShotOrigin,
        CVector *pShotTarget)
{
  CVector *v7; // r9
  float v8; // s2
  float v9; // s16
  CEntity::CEntityInfo m_info; // r1
  float z; // s2
  float v12; // s18
  float v13; // s16
  CEntity *v14; // r11
  bool v15; // zf
  CPlaceable **v16; // r10
  CMatrix *m_pMat; // r0
  CMatrix *v18; // r1
  float tx; // s22
  float v20; // s24
  CPlaceable *v21; // r5
  float v22; // s26
  CMatrix *v23; // r1
  float v24; // s30
  CPlaceable *v25; // r5
  float ty; // s28
  CMatrix *v27; // r1
  float v28; // s22
  float v29; // s24
  float v30; // s26
  float v31; // s22
  CPlaceable *v32; // r5
  float v33; // s24
  float v34; // s26
  CMatrix *v35; // r1
  float v36; // s22
  float v37; // s22
  CPlaceable *v38; // r5
  CMatrix *v39; // r1
  float tz; // s24
  float v41; // s28
  float v42; // s28
  CPlaceable *v43; // r5
  float v44; // s24
  CMatrix *v45; // r0
  float v46; // s24
  CMatrix *v47; // r1
  _QWORD *p_tx; // r2
  float v49; // s0
  float y; // s2
  CEntity *v51; // r0
  CMatrix *v52; // r1
  float *v53; // r2
  float *p_x; // [sp+24h] [bp-DCh]
  CBaseModelInfo **v55; // [sp+28h] [bp-D8h]
  CVector pPoint; // [sp+30h] [bp-D0h] BYREF
  CVector pVecEnd; // [sp+40h] [bp-C0h] BYREF
  CVector pVecStart; // [sp+50h] [bp-B0h] BYREF
  Int16 pNum; // [sp+5Eh] [bp-A2h] BYREF
  CEntity *v60[40]; // [sp+60h] [bp-A0h] BYREF

  v7 = pShotTarget;
  *(_QWORD *)&pVecStart.x = *(_QWORD *)&pShotOrigin->x;
  pVecStart.z = 0.0;
  *(_QWORD *)&pVecEnd.x = *(_QWORD *)&pShotTarget->x;
  pVecEnd.z = 0.0;
  v8 = pShotTarget->y - pShotOrigin->y;
  v9 = sqrtf(
         (float)((float)((float)(pShotTarget->x - pShotOrigin->x) * (float)(pShotTarget->x - pShotOrigin->x))
               + (float)(v8 * v8))
       + (float)((float)(pShotTarget->z - pShotOrigin->z) * (float)(pShotTarget->z - pShotOrigin->z)));
  CWorld::FindObjectsInRange(pShotOrigin, v9, 1, &pNum, 15, v60, 0, 1, 0, 0, 0);
  if ( pNum >= 1 )
  {
    p_x = &v7->x;
    z = v7->z;
    LOWORD(v7) = 0;
    v12 = 10000.0;
    v55 = CModelInfo::ms_modelInfoPtrs;
    v13 = (float)(z - pShotOrigin->z) / v9;
    do
    {
      v14 = v60[(__int16)v7];
      if ( v14 != pTankEntity )
      {
        v15 = v14 == pDriverEntity;
        if ( v14 != pDriverEntity )
        {
          m_info = v14->m_info;
          v15 = (*(_BYTE *)&m_info & 0xF0) == 48;
        }
        if ( !v15 && ((*(_BYTE *)&m_info & 7) != 2 || (HIBYTE(v14[1].m_transform.m_translate.y) & 0x20) == 0) )
        {
          v16 = &v60[(__int16)v7];
          m_pMat = pTankEntity->m_pMat;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pTankEntity);
            CSimpleTransform::UpdateMatrix(&pTankEntity->m_transform, pTankEntity->m_pMat);
            v14 = (CEntity *)*v16;
            m_pMat = pTankEntity->m_pMat;
          }
          v18 = v14->m_pMat;
          tx = m_pMat->tx;
          if ( !v18 )
          {
            CPlaceable::AllocateMatrix(v14);
            CSimpleTransform::UpdateMatrix(&v14->m_transform, v14->m_pMat);
            m_pMat = pTankEntity->m_pMat;
            v18 = v14->m_pMat;
          }
          v20 = v18->tx;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pTankEntity);
            CSimpleTransform::UpdateMatrix(&pTankEntity->m_transform, pTankEntity->m_pMat);
            m_pMat = pTankEntity->m_pMat;
          }
          v21 = *v16;
          v22 = m_pMat->tx;
          v23 = (*v16)->m_pMat;
          if ( !v23 )
          {
            CPlaceable::AllocateMatrix(*v16);
            CSimpleTransform::UpdateMatrix(&v21->m_transform, v21->m_pMat);
            m_pMat = pTankEntity->m_pMat;
            v23 = v21->m_pMat;
          }
          v24 = v23->tx;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pTankEntity);
            CSimpleTransform::UpdateMatrix(&pTankEntity->m_transform, pTankEntity->m_pMat);
            m_pMat = pTankEntity->m_pMat;
          }
          v25 = *v16;
          ty = m_pMat->ty;
          v27 = (*v16)->m_pMat;
          if ( !v27 )
          {
            CPlaceable::AllocateMatrix(*v16);
            CSimpleTransform::UpdateMatrix(&v25->m_transform, v25->m_pMat);
            m_pMat = pTankEntity->m_pMat;
            v27 = v25->m_pMat;
          }
          v28 = tx - v20;
          v29 = v22 - v24;
          v30 = v27->ty;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pTankEntity);
            CSimpleTransform::UpdateMatrix(&pTankEntity->m_transform, pTankEntity->m_pMat);
            m_pMat = pTankEntity->m_pMat;
          }
          v31 = v28 * v29;
          v32 = *v16;
          v33 = ty - v30;
          v34 = m_pMat->ty;
          v35 = (*v16)->m_pMat;
          if ( !v35 )
          {
            CPlaceable::AllocateMatrix(*v16);
            CSimpleTransform::UpdateMatrix(&v32->m_transform, v32->m_pMat);
            m_pMat = pTankEntity->m_pMat;
            v35 = v32->m_pMat;
          }
          v36 = v31 + (float)(v33 * (float)(v34 - v35->ty));
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pTankEntity);
            CSimpleTransform::UpdateMatrix(&pTankEntity->m_transform, pTankEntity->m_pMat);
            m_pMat = pTankEntity->m_pMat;
          }
          v37 = sqrtf(v36);
          v38 = *v16;
          v39 = (*v16)->m_pMat;
          tz = m_pMat->tz;
          if ( !v39 )
          {
            CPlaceable::AllocateMatrix(*v16);
            CSimpleTransform::UpdateMatrix(&v38->m_transform, v38->m_pMat);
            m_pMat = pTankEntity->m_pMat;
            v39 = v38->m_pMat;
          }
          v41 = (float)(v13 * v37) + v39->tz;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(pTankEntity);
            CSimpleTransform::UpdateMatrix(&pTankEntity->m_transform, pTankEntity->m_pMat);
            m_pMat = pTankEntity->m_pMat;
          }
          v42 = tz - v41;
          v43 = *v16;
          v44 = m_pMat->tz;
          v45 = (*v16)->m_pMat;
          if ( !v45 )
          {
            CPlaceable::AllocateMatrix(*v16);
            CSimpleTransform::UpdateMatrix(&v43->m_transform, v43->m_pMat);
            v45 = v43->m_pMat;
          }
          v46 = v44 - (float)((float)(v13 * v37) + v45->tz);
          if ( v42 < 0.0 )
            v46 = -v46;
          if ( (float)(v46 * 3.0) < v37 )
          {
            v47 = (*v16)->m_pMat;
            p_tx = (_QWORD *)&v47->tx;
            if ( !v47 )
              p_tx = (_QWORD *)&(*v16)->m_transform.m_translate.x;
            *(_QWORD *)&pPoint.x = *p_tx;
            pPoint.z = 0.0;
            if ( CCollision::DistToLine(&pVecStart, &pVecEnd, &pPoint) < (float)(CModelInfo::ms_modelInfoPtrs[SHIWORD((*v16)[1].m_transform.m_translate.z)]->m_pColModel->m_sphereBound.m_fRadius
                                                                               * 3.0) )
            {
              v49 = sqrtf((float)(v37 * v37) + (float)(v46 * v46));
              if ( v49 < v12 )
              {
                v12 = v49;
                LOWORD(v55) = (_WORD)v7;
              }
            }
          }
        }
      }
      m_info = (CEntity::CEntityInfo)((_BYTE)v7 + 1);
      v7 = (CVector *)(__int16)((_WORD)v7 + 1);
    }
    while ( (int)v7 < pNum );
    if ( v12 < 9000.0 )
    {
      v51 = v60[(__int16)v55];
      v52 = v51->m_pMat;
      v53 = &v52->tx;
      if ( !v52 )
        v53 = &v51->m_transform.m_translate.x;
      y = pShotOrigin->y;
      p_x[2] = pShotOrigin->z
             + (float)((float)((float)(v53[2] + 0.3) - pShotOrigin->z)
                     * (float)(sqrtf(
                                 (float)((float)(*p_x - pShotOrigin->x) * (float)(*p_x - pShotOrigin->x))
                               + (float)((float)(p_x[1] - y) * (float)(p_x[1] - y)))
                             / sqrtf(
                                 (float)((float)(*v53 - pShotOrigin->x) * (float)(*v53 - pShotOrigin->x))
                               + (float)((float)(v53[1] - y) * (float)(v53[1] - y)))));
    }
  }
}
// 5E1C2E: variable 'm_info' is possibly undefined

//----- (005E1F18) --------------------------------------------------------
void __fastcall CWeapon::Update(CWeapon *this, CPed *pOwnerPed)
{
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r1
  CWeaponInfo *WeaponInfo; // r6
  int16 m_nAimOffsetIndex; // r12
  tAnimAimOffsets *v8; // r2
  int m_nPedFlags; // r0
  uint16 *p_nReloadSampleA; // r3
  uint32 v11; // r2
  tAnimAimOffsets *v12; // r1
  uint16 *p_nReloadSampleB; // r2
  uint32 v14; // r0
  eWeaponState v15; // r0
  int32 m_nFlags; // r1
  int v17; // r1
  CAnimBlendAssociation *Association; // r8
  int v19; // r1
  FxSystem_c *m_pWeaponFxSys; // r0
  CTaskSimpleUseGun *TaskUseGun; // r0
  int v22; // r1
  tAnimAimOffsets *v23; // r2
  int v24; // r0
  uint16 *p_nReloadSampleCrouchedA; // r3
  float v26; // s2
  float m_fCurrentTime; // s0
  tAnimAimOffsets *v28; // r1
  uint16 *p_nReloadSampleCrouchedB; // r2
  float v30; // s2
  uint32 m_nTimer; // r8
  uint32 v32; // r8
  int16 v33; // r12
  tAnimAimOffsets *v34; // r3
  int v35; // r2
  uint16 *v36; // r1
  int v37; // r3
  tAnimAimOffsets *v38; // r0
  uint16 *v39; // r1
  uint32 v40; // r0
  eWeaponType v41; // r6
  int8 v42; // r1
  unsigned int m_nAmmo; // r0
  bool v44; // zf

  m_eWeaponType = this->m_eWeaponType;
  if ( pOwnerPed )
    WeaponSkill = CPed::GetWeaponSkill(pOwnerPed, m_eWeaponType);
  else
    WeaponSkill = 1;
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  switch ( this->m_eState )
  {
    case WEAPONSTATE_FIRING:
      if ( pOwnerPed && (this->m_eWeaponType | 2) == 27 )
      {
        m_nAimOffsetIndex = WeaponInfo->m_nAimOffsetIndex;
        v8 = &CWeaponInfo::ms_aWeaponAimOffsets[m_nAimOffsetIndex];
        m_nPedFlags = (int)pOwnerPed->m_nPedFlags;
        p_nReloadSampleA = &v8->nReloadSampleA;
        if ( (m_nPedFlags & 0x4000000) != 0 )
          p_nReloadSampleA = &v8->nReloadSampleCrouchedA;
        if ( *p_nReloadSampleA )
        {
          v11 = *p_nReloadSampleA + this->m_nTimer;
          if ( CTimer::m_snPreviousTimeInMilliseconds < v11 && CTimer::m_snTimeInMilliseconds >= v11 )
          {
            CAEPedWeaponAudioEntity::AddAudioEvent(&pOwnerPed->m_PedWeaponAudioEntity, 146);
            m_nPedFlags = (int)pOwnerPed->m_nPedFlags;
            m_nAimOffsetIndex = WeaponInfo->m_nAimOffsetIndex;
          }
        }
        v12 = &CWeaponInfo::ms_aWeaponAimOffsets[m_nAimOffsetIndex];
        p_nReloadSampleB = &v12->nReloadSampleB;
        if ( (m_nPedFlags & 0x4000000) != 0 )
          p_nReloadSampleB = &v12->nReloadSampleCrouchedB;
        if ( *p_nReloadSampleB )
        {
          v14 = *p_nReloadSampleB + this->m_nTimer;
          if ( CTimer::m_snPreviousTimeInMilliseconds < v14 && CTimer::m_snTimeInMilliseconds >= v14 )
            CAEPedWeaponAudioEntity::AddAudioEvent(&pOwnerPed->m_PedWeaponAudioEntity, 147);
        }
      }
      if ( CTimer::m_snTimeInMilliseconds > this->m_nTimer )
      {
        v15 = WEAPONSTATE_READY;
        if ( WeaponInfo->m_eFireType )
        {
          if ( !this->m_nAmmoTotal )
            v15 = WEAPONSTATE_OUT_OF_AMMO;
        }
        this->m_eState = v15;
      }
      return;
    case WEAPONSTATE_RELOADING:
      if ( !pOwnerPed || this->m_eWeaponType > WEAPONTYPE_PARACHUTE )
        goto LABEL_70;
      m_nFlags = WeaponInfo->m_nFlags;
      if ( (m_nFlags & 0x1000) == 0 )
        goto LABEL_58;
      if ( !CWorld::Players[CWorld::PlayerInFocus].FastReload )
        goto LABEL_30;
      if ( CPed::IsPlayer(pOwnerPed) )
        goto LABEL_58;
      m_nFlags = WeaponInfo->m_nFlags;
LABEL_30:
      v17 = m_nFlags & 0x1000;
      if ( v17 )
        v17 = 226;
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pOwnerPed->m_pRwObject, v17);
      if ( !Association )
      {
        if ( (WeaponInfo->m_nFlags & 0x2000) != 0 )
        {
          v19 = WeaponInfo->m_nFlags & 0x1000;
          if ( v19 )
            v19 = 227;
        }
        else
        {
          v19 = 0;
        }
        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pOwnerPed->m_pRwObject, v19);
      }
      TaskUseGun = CPedIntelligence::GetTaskUseGun(pOwnerPed->m_pPedIntelligence);
      if ( Association )
      {
        v22 = WeaponInfo->m_nAimOffsetIndex;
        v23 = &CWeaponInfo::ms_aWeaponAimOffsets[v22];
        v24 = (int)pOwnerPed->m_nPedFlags;
        p_nReloadSampleCrouchedA = &v23->nReloadSampleA;
        if ( (v24 & 0x4000000) != 0 )
          p_nReloadSampleCrouchedA = &v23->nReloadSampleCrouchedA;
        v26 = (float)*p_nReloadSampleCrouchedA * 0.001;
        m_fCurrentTime = Association->m_fCurrentTime;
        if ( m_fCurrentTime >= v26 && (float)(m_fCurrentTime - Association->m_fTimeStep) < v26 )
        {
          CAEPedWeaponAudioEntity::AddAudioEvent(&pOwnerPed->m_PedWeaponAudioEntity, 146);
          v24 = (int)pOwnerPed->m_nPedFlags;
          LOWORD(v22) = WeaponInfo->m_nAimOffsetIndex;
          m_fCurrentTime = Association->m_fCurrentTime;
        }
        v28 = &CWeaponInfo::ms_aWeaponAimOffsets[(__int16)v22];
        p_nReloadSampleCrouchedB = &v28->nReloadSampleB;
        if ( (v24 & 0x4000000) != 0 )
          p_nReloadSampleCrouchedB = &v28->nReloadSampleCrouchedB;
        v30 = (float)*p_nReloadSampleCrouchedB * 0.001;
        if ( m_fCurrentTime >= v30 && (float)(m_fCurrentTime - Association->m_fTimeStep) < v30 )
          CAEPedWeaponAudioEntity::AddAudioEvent(&pOwnerPed->m_PedWeaponAudioEntity, 147);
        if ( CTimer::m_snTimeInMilliseconds > this->m_nTimer
          && (float)(Association->m_fCurrentTime / Association->m_pAnimBlendHierarchy->m_fTotalTime) < 0.9 )
        {
          this->m_nTimer = CTimer::m_snTimeInMilliseconds;
        }
      }
      else if ( TaskUseGun )
      {
        if ( CTimer::m_snTimeInMilliseconds > this->m_nTimer )
          this->m_nTimer = CTimer::m_snTimeInMilliseconds;
      }
      else
      {
LABEL_58:
        m_nTimer = this->m_nTimer;
        v32 = m_nTimer - CWeaponInfo::GetWeaponReloadTime(WeaponInfo);
        v33 = WeaponInfo->m_nAimOffsetIndex;
        v34 = &CWeaponInfo::ms_aWeaponAimOffsets[v33];
        v35 = (int)pOwnerPed->m_nPedFlags;
        v36 = &v34->nReloadSampleA;
        if ( (v35 & 0x4000000) != 0 )
          v36 = &v34->nReloadSampleCrouchedA;
        v37 = *v36;
        if ( *v36 && CTimer::m_snPreviousTimeInMilliseconds < v32 + v37 && CTimer::m_snTimeInMilliseconds >= v32 + v37 )
        {
          CAEPedWeaponAudioEntity::AddAudioEvent(&pOwnerPed->m_PedWeaponAudioEntity, 146);
          v35 = (int)pOwnerPed->m_nPedFlags;
          v33 = WeaponInfo->m_nAimOffsetIndex;
        }
        v38 = &CWeaponInfo::ms_aWeaponAimOffsets[v33];
        v39 = &v38->nReloadSampleB;
        if ( (v35 & 0x4000000) != 0 )
          v39 = &v38->nReloadSampleCrouchedB;
        if ( *v39 )
        {
          v40 = *v39 + v32;
          if ( CTimer::m_snPreviousTimeInMilliseconds < v40 && CTimer::m_snTimeInMilliseconds >= v40 )
            CAEPedWeaponAudioEntity::AddAudioEvent(&pOwnerPed->m_PedWeaponAudioEntity, 147);
        }
      }
LABEL_70:
      if ( CTimer::m_snTimeInMilliseconds > this->m_nTimer )
      {
        if ( this->m_nAmmoTotal )
        {
          v41 = this->m_eWeaponType;
          if ( pOwnerPed )
            v42 = CPed::GetWeaponSkill(pOwnerPed, this->m_eWeaponType);
          else
            v42 = 1;
          m_nAmmo = CWeaponInfo::GetWeaponInfo(v41, v42)->m_nAmmo;
          if ( this->m_nAmmoTotal < m_nAmmo )
            m_nAmmo = this->m_nAmmoTotal;
          this->m_nAmmoInClip = m_nAmmo;
        }
        this->m_eState = WEAPONSTATE_READY;
      }
      goto LABEL_79;
    case WEAPONSTATE_MELEE_MADECONTACT:
      m_pWeaponFxSys = this->m_pWeaponFxSys;
      this->m_eState = WEAPONSTATE_READY;
      goto LABEL_80;
    default:
LABEL_79:
      m_pWeaponFxSys = this->m_pWeaponFxSys;
LABEL_80:
      v44 = m_pWeaponFxSys == 0;
      if ( m_pWeaponFxSys )
        v44 = this->m_eWeaponType == WEAPONTYPE_MOLOTOV;
      if ( !v44 )
      {
        FxSystem_c::Kill(m_pWeaponFxSys);
        this->m_pWeaponFxSys = 0;
      }
      return;
  }
}

//----- (005E2324) --------------------------------------------------------
void __fastcall CWeapon::StopWeaponEffect(CWeapon *this)
{
  FxSystem_c *m_pWeaponFxSys; // r0
  bool v3; // zf

  m_pWeaponFxSys = this->m_pWeaponFxSys;
  v3 = m_pWeaponFxSys == 0;
  if ( m_pWeaponFxSys )
    v3 = this->m_eWeaponType == WEAPONTYPE_MOLOTOV;
  if ( !v3 )
  {
    FxSystem_c::Kill(m_pWeaponFxSys);
    this->m_pWeaponFxSys = 0;
  }
}

//----- (005E2344) --------------------------------------------------------
void CWeapon::StaticUpdate()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1

  if ( CWeapon::ms_bTakePhoto || CWeapon::m_nTakePhotoFrames >= 1 )
  {
    v0.n64_u32[0] = 0;
    v1.n64_f32[0] = (float)(CWeapon::m_nTakePhotoFrames - 1);
    CWeapon::m_nTakePhotoFrames = (int)vmax_f32(v1, v0).n64_f32[0];
    if ( !CWeapon::m_nTakePhotoFrames )
      CWeapon::ms_bTakePhoto = 0;
  }
}
// 5E2370: variable 'v1' is possibly undefined
// 5E2370: variable 'v0' is possibly undefined

//----- (005E23AC) --------------------------------------------------------
void __fastcall FireOneInstantHitRound(CVector *pStartCoors, CVector *pEndCoors, Int32 Damage)
{
  CEntity *v6; // r6
  int v7; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v10; // s0
  int32 LocalDirection; // r9
  CAnimBlendAssociation *v12; // r0
  RwReal v13; // s0
  RwReal v14; // s4
  float v15; // r0
  CVector Pos; // [sp+0h] [bp-88h] BYREF
  float pWaterZ; // [sp+2Ch] [bp-5Ch] BYREF
  CVector v18; // [sp+30h] [bp-58h] BYREF
  CEntity *refEntityPtr; // [sp+40h] [bp-48h] BYREF
  CColPoint colPoint; // [sp+44h] [bp-44h] BYREF
  CVector v21; // 0:r1.12

  refEntityPtr = 0;
  v21 = *pStartCoors;
  memset(&Pos, 0, sizeof(Pos));
  CPointLights::AddLight(0, v21, Pos, 3.0, 0.25, 0.22, 0.0, 0, 0, 0);
  CWorld::ProcessLineOfSight(pStartCoors, pEndCoors, &colPoint, &refEntityPtr, 1, 1, 1, 1, 1, 1, 0, 0);
  if ( refEntityPtr )
    CBulletTraces::AddTrace(pStartCoors, &colPoint.m_vecPosition, 0.02, 0x2EEu, 0x96u);
  else
    CBulletTraces::AddTrace(pStartCoors, pEndCoors, 0.02, 0x2EEu, 0x96u);
  v6 = refEntityPtr;
  if ( refEntityPtr )
  {
    v7 = *(_BYTE *)&refEntityPtr->m_info & 7;
    if ( v7 == 2 )
    {
      memset(&Pos, 0, sizeof(Pos));
      CVehicle::InflictDamage((CVehicle *)refEntityPtr, 0, WEAPONTYPE_MICRO_UZI, (float)Damage, Pos);
    }
    else if ( v7 == 3 && ((int)refEntityPtr[18].m_pMat | 1) != 55 )
    {
      m_pMat = refEntityPtr->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &refEntityPtr->m_transform;
      v10 = pStartCoors->x - p_tx->m_translate.x;
      v18.y = pStartCoors->y - p_tx->m_translate.y;
      v18.x = v10;
      LocalDirection = CPed::GetLocalDirection((CPed *)refEntityPtr, (const CVector2D *)&v18);
      v12 = CAnimManager::AddAnimation((RpClump_0 *)v6->m_pRwObject, ANIM_STD_PED, (AnimationId)(LocalDirection + 28));
      v12->m_fBlendAmount = 0.0;
      v12->m_fBlendDelta = 8.0;
      CWeapon::GenerateDamageEvent(
        (CPed *)v6,
        0,
        WEAPONTYPE_UZI_DRIVEBY,
        Damage,
        (ePedPieceTypes)colPoint.m_dataB.m_nPieceType,
        LocalDirection);
    }
    v13 = pEndCoors->x - pStartCoors->x;
    v14 = pEndCoors->z - pStartCoors->z;
    v18.y = pEndCoors->y - pStartCoors->y;
    v18.x = v13;
    v18.z = v14;
    CVector::Normalise(&v18);
    if ( (float)((float)((float)(v18.x * colPoint.m_vecNormal.x) + (float)(v18.y * colPoint.m_vecNormal.y))
               + (float)(v18.z * colPoint.m_vecNormal.z)) < 0.0 )
    {
      v15 = asinf(-(float)((float)((float)(v18.x * colPoint.m_vecNormal.x) + (float)(v18.y * colPoint.m_vecNormal.y))
                         + (float)(v18.z * colPoint.m_vecNormal.z)));
      CAudioEngine::ReportBulletHit(
        &AudioEngine,
        refEntityPtr,
        colPoint.m_dataB.m_nSurfaceType,
        &colPoint.m_vecPosition,
        (float)(v15 * 180.0) / 3.1416);
    }
  }
  else if ( CWaterLevel::GetWaterLevel(pEndCoors->x, pEndCoors->y, pEndCoors->z + 10.0, &pWaterZ, 1, 0) == 1 )
  {
    *(_QWORD *)&v18.x = *(_QWORD *)&pEndCoors->x;
    v18.z = pWaterZ;
    CAudioEngine::ReportBulletHit(&AudioEngine, 0, 0x27u, &v18, 0.0);
  }
}

//----- (005E25D8) --------------------------------------------------------
bool __fastcall CWeapon::IsTypeMelee(const CWeapon *this)
{
  return CWeaponInfo::GetWeaponInfo(this->m_eWeaponType, 1)->m_eFireType == FIRETYPE_MELEE;
}

//----- (005E25F0) --------------------------------------------------------
bool __fastcall CWeapon::IsType2Handed(CWeapon *this)
{
  unsigned __int32 v1; // r0
  _BOOL4 v2; // r0

  v1 = this->m_eWeaponType - 25;
  if ( v1 <= 0xC )
    return (0x1365u >> v1) & 1;
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (005E260E) --------------------------------------------------------
bool __fastcall CWeapon::IsTypeProjectile(CWeapon *this)
{
  unsigned __int32 v1; // r0
  _BOOL4 v2; // r0

  v1 = this->m_eWeaponType - 16;
  if ( v1 <= 0x17 )
    return ((unsigned int)&CTheScripts::ScriptSpace[272531] >> v1) & 1;
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (005E2630) --------------------------------------------------------
bool __fastcall CWeapon::CanBeUsedFor2Player(CWeapon *this)
{
  __int32 v1; // r1
  bool result; // r0

  v1 = this->m_eWeaponType - 9;
  result = 0;
  switch ( v1 )
  {
    case 0:
    case 10:
    case 11:
    case 24:
    case 25:
    case 26:
    case 27:
    case 37:
      return result;
    default:
      result = 1;
      break;
  }
  return result;
}

//----- (005E266C) --------------------------------------------------------
bool __fastcall CWeapon::CanBeUsedFor2Player(eWeaponType WeaponType)
{
  __int32 v1; // r1
  bool result; // r0

  v1 = WeaponType - 9;
  result = 0;
  switch ( v1 )
  {
    case 0:
    case 10:
    case 11:
    case 24:
    case 25:
    case 26:
    case 27:
    case 37:
      return result;
    default:
      result = 1;
      break;
  }
  return result;
}

//----- (005E26A8) --------------------------------------------------------
void __fastcall CVehicle::DoDriveByShootings(CVehicle *this)
{
  CPed *pDriver; // r4
  CPlayerInfo *PlayerInfoForThisPlayerPed; // r0
  bool v4; // zf
  CPad *PadFromPlayer; // r6
  char *v6; // r10
  _BOOL4 v7; // r11
  int v8; // r0
  int32 m_vehicleType; // r8
  int CarGunFired; // r9
  _BOOL4 v11; // r1
  _BOOL4 v12; // r9
  int Mode; // r1
  bool v14; // zf
  int v15; // r1
  int v16; // r2
  CPed *v17; // r6
  signed int v18; // r11
  unsigned int m_nAmmo; // r0
  CAnimBlendAssociation *v20; // r0
  CAnimBlendAssociation *v21; // r0
  RpClump_0 **p_m_pRwObject; // r6
  RpClump_0 *m_pRwObject; // t1
  CAnimBlendAssociation *Association; // r0
  char *v25; // r0
  int v26; // r8
  _BOOL4 LookRight; // r0
  _BOOL4 LookLeft; // r8
  bool RightIsTrue_ForceForBikes; // [sp+4h] [bp-34h]
  AssocGroupId groupId; // [sp+8h] [bp-30h]
  uint32 v31; // [sp+Ch] [bp-2Ch]
  int v32; // [sp+10h] [bp-28h]
  int id; // [sp+14h] [bp-24h]
  CWeapon *v34; // [sp+18h] [bp-20h]

  pDriver = this->pDriver;
  if ( pDriver )
  {
    PlayerInfoForThisPlayerPed = CPlayerPed::GetPlayerInfoForThisPlayerPed((CPlayerPed *)this->pDriver);
    v4 = PlayerInfoForThisPlayerPed == 0;
    if ( PlayerInfoForThisPlayerPed )
      v4 = !PlayerInfoForThisPlayerPed->bCanDoDriveBy;
    if ( !v4 )
    {
      PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pDriver);
      if ( PadFromPlayer )
      {
        v6 = (char *)pDriver + 28 * pDriver->m_nCurrentWeapon;
        if ( CWeaponInfo::GetWeaponInfo(*((eWeaponType *)v6 + 361), 1)->m_nWeaponSlot == 4 )
        {
          v34 = (CWeapon *)(v6 + 1444);
          if ( (*((int (__fastcall **)(CVehicle *))this->_vptr$CPlaceable + 48))(this) )
          {
            v7 = 1;
            v31 = 204;
            v32 = 203;
            groupId = *(_DWORD *)(*((int (__fastcall **)(CVehicle *))this->_vptr$CPlaceable + 48))(this);
            id = 202;
          }
          else
          {
            v7 = 0;
            v8 = (*(_DWORD *)&this->m_nVehicleFlags >> 11) & 1;
            v32 = 2 * v8 + 75;
            id = 2 * v8 + 74;
            v31 = 191;
            groupId = ANIM_STD_PED;
          }
          m_vehicleType = this->m_vehicleType;
          CarGunFired = CPad::GetCarGunFired(PadFromPlayer, v7, 0);
          CWeapon::Update(v34, 0);
          v11 = CarGunFired;
          if ( CarGunFired != 1 )
            v11 = 0;
          v12 = CarGunFired != 0;
          if ( m_vehicleType == 10 )
            v12 = v11;
          if ( TheCamera.m_bObbeCinematicCarCamOn )
            goto LABEL_19;
          Mode = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
          v14 = Mode == 49;
          if ( Mode != 49 )
            v14 = Mode == 1;
          if ( v14 )
          {
LABEL_19:
            LookLeft = CPad::GetLookLeft(PadFromPlayer, 1);
            LookRight = CPad::GetLookRight(PadFromPlayer, 1);
          }
          else
          {
            v25 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
            v26 = (unsigned __int8)v25[376];
            LookRight = v25[377] != 0;
            LookLeft = v26 != 0;
          }
          v15 = v12;
          if ( !v7 )
            v15 = LookLeft || LookRight;
          v16 = *((_DWORD *)v6 + 364);
          if ( v15 == 1 && v16 >= 1 )
          {
            RightIsTrue_ForceForBikes = LookRight;
            if ( LookLeft )
            {
              v17 = pDriver;
              v18 = id;
            }
            else
            {
              if ( !LookRight )
              {
                if ( !v7 )
                  goto LABEL_51;
                v18 = v31;
                p_m_pRwObject = (RpClump_0 **)&pDriver->m_pRwObject;
                Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pDriver->m_pRwObject, v31);
                if ( Association )
                {
                  if ( Association->m_fBlendDelta >= 0.0 )
                    goto LABEL_44;
                  v18 = v31;
                }
LABEL_43:
                Association = CAnimManager::BlendAnimation(*p_m_pRwObject, groupId, (AnimationId)v18, 16.0);
                if ( Association )
                  goto LABEL_44;
LABEL_51:
                if ( !v12 )
                  return;
                goto LABEL_52;
              }
              v17 = pDriver;
              v18 = v32;
            }
            m_pRwObject = (RpClump_0 *)v17->m_pRwObject;
            p_m_pRwObject = (RpClump_0 **)&v17->m_pRwObject;
            Association = RpAnimBlendClumpGetAssociation(m_pRwObject, v18);
            if ( Association && Association->m_fBlendDelta >= 0.0 )
            {
LABEL_44:
              if ( LOBYTE(Association->m_bitsFlag) << 31 || Association->m_fBlendAmount <= 0.99 || !v12 )
                return;
LABEL_52:
              if ( CTimer::m_snTimeInMilliseconds > *((_DWORD *)v6 + 365) )
              {
                CWeapon::FireFromCar(v34, this, LookLeft, RightIsTrue_ForceForBikes);
                *((_DWORD *)v6 + 365) = CTimer::m_snTimeInMilliseconds + 70;
                CPed::DoGunFlash(pDriver, 250, 0);
              }
              return;
            }
            goto LABEL_43;
          }
          if ( v16 )
          {
            m_nAmmo = CWeaponInfo::GetWeaponInfo(v34->m_eWeaponType, 1)->m_nAmmo;
            if ( *((_DWORD *)v6 + 364) < m_nAmmo )
              m_nAmmo = *((_DWORD *)v6 + 364);
            *((_DWORD *)v6 + 363) = m_nAmmo;
          }
          v20 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pDriver->m_pRwObject, id);
          if ( v20 )
            v20->m_fBlendDelta = -8.0;
          v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pDriver->m_pRwObject, v32);
          if ( v21 )
            v21->m_fBlendDelta = -8.0;
          if ( v7 )
            v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pDriver->m_pRwObject, v31);
          if ( v21 )
            v21->m_fBlendDelta = -8.0;
        }
      }
    }
  }
}
// 2C: using guessed type __int16 word_2C;
// 54: using guessed type int dword_54;

//----- (005E2954) --------------------------------------------------------
void __fastcall CVehicle::DoFixedMachineGuns(CVehicle *this)
{
  CPad *Pad; // r0
  CPed *pDriver; // r1

  if ( TheCamera.Cams[TheCamera.ActiveCam].DirectionWasLooking == 3 )
  {
    Pad = CPad::GetPad(0);
    pDriver = this->pDriver;
    if ( pDriver && pDriver->m_nPedType == 1 )
      Pad = CPad::GetPad(1);
    if ( !CPad::GetCarGunFired(Pad, 0, 0) || *((unsigned __int8 *)&this->m_nVehicleFlags + 2) >> 7 )
    {
      if ( CTimer::m_snTimeInMilliseconds > this->TimeOfLastShotFired + 1400 )
        this->AmmoInClip = 20;
    }
    else
    {
      CVehicle::FireFixedMachineGuns(this);
    }
  }
}

//----- (005E29D4) --------------------------------------------------------
void __fastcall CVehicle::FireFixedMachineGuns(CVehicle *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  CMatrix *m_pMat; // r1
  float xy; // s16
  float yy; // s18
  __int64 v7; // kr00_8
  float z; // s24
  unsigned __int8 v9; // r5
  unsigned __int8 v10; // r6
  float v11; // s0
  float v12; // s30
  float v13; // s20
  float v14; // s22
  unsigned __int8 v15; // r0
  TouchSense *v16; // r0
  UInt8 v17; // r0
  CVector v18; // [sp+8h] [bp-98h] BYREF
  CVector pShotTarget; // [sp+18h] [bp-88h] BYREF
  CVector pShotOrigin; // [sp+28h] [bp-78h] BYREF
  CVector v; // [sp+34h] [bp-6Ch] BYREF

  if ( CTimer::m_snTimeInMilliseconds > this->TimeOfLastShotFired + 150 )
  {
    m_pMat = this->m_pMat;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    this->TimeOfLastShotFired = CTimer::m_snTimeInMilliseconds;
    v.y = 2.5;
    v.x = 2.0;
    v.z = 1.0;
    operator*(&pShotTarget, m_pMat, &v);
    pShotOrigin = pShotTarget;
    v7 = *(_QWORD *)&pShotTarget.x;
    z = pShotTarget.z;
    v9 = rand();
    v10 = rand();
    v2.n64_u32[0] = 1036831949;
    v1.n64_f32[0] = sqrtf((float)(xy * xy) + (float)(yy * yy));
    v11 = vmax_f32(v1, v2).n64_f32[0];
    v12 = (float)(yy / v11) * 60.0;
    pShotTarget.z = (float)((float)((unsigned __int8)rand() - 128) * 0.02) + (float)(z + 0.0);
    pShotTarget.x = (float)((float)((float)(xy / v11) * 60.0) + *(float *)&v7) + (float)((float)(v9 - 128) * 0.015);
    pShotTarget.y = (float)((float)(v10 - 128) * 0.015) + (float)(v12 + *((float *)&v7 + 1));
    CWeapon::DoTankDoomAiming(this, this->pDriver, &pShotOrigin, &pShotTarget);
    FireOneInstantHitRound(&pShotOrigin, &pShotTarget, 15);
    v.y = 2.5;
    v.x = -2.0;
    v.z = 1.0;
    operator*(&v18, this->m_pMat, &v);
    pShotOrigin = v18;
    pShotTarget.x = (float)((float)(xy / v11) * 60.0) + v18.x;
    pShotTarget.y = v12 + v18.y;
    pShotTarget.z = v18.z + 0.0;
    v13 = (float)((unsigned __int8)rand() - 128);
    v14 = (float)((unsigned __int8)rand() - 128);
    v15 = rand();
    pShotTarget.x = pShotTarget.x + (float)(v13 * 0.015);
    pShotTarget.y = (float)(v14 * 0.015) + pShotTarget.y;
    pShotTarget.z = (float)((float)(v15 - 128) * 0.02) + pShotTarget.z;
    CWeapon::DoTankDoomAiming(this, this->pDriver, &pShotOrigin, &pShotTarget);
    FireOneInstantHitRound(&pShotOrigin, &pShotTarget, 15);
    CAudioEngine::ReportWeaponEvent(&AudioEngine, 149, WEAPONTYPE_M4, this);
    if ( FindPlayerVehicle(-1, 0) == this )
    {
      TouchSense::instance();
      TouchSense::playBuiltinEffect(v16, 1, 666, 115, 20);
    }
    v17 = this->AmmoInClip - 1;
    this->AmmoInClip = v17;
    if ( !v17 )
    {
      this->AmmoInClip = 20;
      this->TimeOfLastShotFired = CTimer::m_snTimeInMilliseconds + 1400;
    }
  }
}
// 5E2A9A: variable 'v1' is possibly undefined
// 5E2A9A: variable 'v2' is possibly undefined
// 5E2BF0: variable 'v16' is possibly undefined

//----- (005E2C48) --------------------------------------------------------
bool __fastcall CWeapon::HasWeaponAmmoToBeUsed(CWeapon *this)
{
  bool result; // r0
  eWeaponType m_eWeaponType; // r2

  result = 1;
  m_eWeaponType = this->m_eWeaponType;
  if ( (this->m_eWeaponType > (unsigned int)WEAPONTYPE_FLOWERS || ((1 << m_eWeaponType) & 0x7F3F) == 0)
    && m_eWeaponType != WEAPONTYPE_PARACHUTE )
  {
    return this->m_nAmmoTotal != 0;
  }
  return result;
}

//----- (005E2C74) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
const CVehicle *__fastcall CWeapon::FindNearestTargetEntityWithScreenCoors(
        float ScreenX,
        float ScreenY,
        float fRange,
        CVector vecSource,
        float *pTargetScreenX,
        float *pTargetScreenY)
{
  RwReal x; // r5
  float screenWidth; // s20
  float v9; // s2
  float screenHeight; // s24
  CPedPool *v11; // r8
  float v12; // s26
  int32 m_nSize; // r6
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r0
  char *v18; // r0
  _BOOL4 v19; // r0
  float v20; // s22
  float v21; // s18
  float v22; // s20
  int v23; // r0
  float v24; // s30
  int v25; // r6
  int v26; // r5
  uint8 *v27; // r9
  bool v28; // zf
  float *v29; // r10
  const RwV3d_0 *v30; // r1
  const RwV3d_0 *v31; // r0
  float y; // s2
  float v33; // s0
  int v34; // r0
  CVehiclePool *v35; // r11
  int32 v36; // r0
  float v37; // s24
  int v38; // r8
  int v39; // r6
  const CVehicle *v40; // r5
  CMatrix *m_pMat; // r1
  float *p_x; // r4
  const RwV3d_0 *p_m_translate; // r0
  float v44; // s2
  float v45; // s0
  CMatrix *v46; // r0
  float v48; // [sp+10h] [bp-80h]
  const CVehicle *v49; // [sp+14h] [bp-7Ch]
  _BOOL4 v50; // [sp+18h] [bp-78h]
  float pScaleY; // [sp+1Ch] [bp-74h] BYREF
  float pScaleX; // [sp+20h] [bp-70h] BYREF
  RwV3d_0 pResult; // [sp+24h] [bp-6Ch] BYREF

  x = vecSource.x;
  screenWidth = (float)RsGlobal.screenWidth;
  v9 = ScreenX + 1.0;
  screenHeight = (float)RsGlobal.screenHeight;
  v11 = CPools::ms_pPedPool;
  v12 = (float)(ScreenY + 1.0) * 0.5;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  v14 = CTheScripts::CurrentMissionName();
  v19 = 1;
  if ( strcmp(v14, "run_co") )
  {
    v15 = CTheScripts::CurrentMissionName();
    if ( strcmp(v15, "run_de") )
    {
      v16 = CTheScripts::CurrentMissionName();
      if ( strcmp(v16, "run_ls") )
      {
        v17 = CTheScripts::CurrentMissionName();
        if ( strcmp(v17, "run_lv") )
        {
          v18 = CTheScripts::CurrentMissionName();
          if ( strcmp(v18, "run_sf") )
            v19 = 0;
        }
      }
    }
  }
  v20 = screenWidth / 15.0;
  v50 = v19;
  v48 = x;
  v21 = v12 * screenHeight;
  v22 = (float)(v9 * 0.5) * screenWidth;
  if ( m_nSize )
  {
    v23 = 1996 * m_nSize;
    v24 = x;
    v25 = m_nSize - 1;
    v26 = v23 - 896;
    v49 = 0;
    do
    {
      if ( (v11->m_aFlags[v25] & 0x80u) == 0 )
      {
        v27 = &(*v11->m_aStorage)[v26];
        v28 = v27 == (uint8 *)&elf_hash_bucket[212];
        if ( v27 != (uint8 *)&elf_hash_bucket[212] )
          v28 = *(_DWORD *)&(*v11->m_aStorage)[v26] == 55;
        if ( !v28 && !(v27[57] << 31) && (CDarkel::ThisPedShouldBeKilledForFrenzy((const CPed *)(v27 - 1100)) || v50) )
        {
          v29 = (float *)(v27 - 1096);
          v30 = (const RwV3d_0 *)*((_DWORD *)v27 - 270);
          v31 = (const RwV3d_0 *)(v27 - 1096);
          if ( v30 )
            v31 = v30 + 4;
          if ( CSprite::CalcScreenCoors(v31, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
          {
            y = pResult.y;
            v33 = sqrtf(
                    (float)((float)(pResult.x - v22) * (float)(pResult.x - v22))
                  + (float)((float)(pResult.y - v21) * (float)(pResult.y - v21)));
            if ( v33 < v20 )
            {
              v34 = *((_DWORD *)v27 - 270);
              if ( v34 )
                v29 = (float *)(v34 + 48);
              if ( (float)((float)((float)((float)(*v29 - v24) * (float)(*v29 - v24))
                                 + (float)((float)(v29[1] - vecSource.y) * (float)(v29[1] - vecSource.y)))
                         + (float)((float)(v29[2] - vecSource.z) * (float)(v29[2] - vecSource.z))) < (float)(fRange * fRange) )
              {
                if ( pTargetScreenX )
                {
                  *pTargetScreenX = (float)(pResult.x / (float)((float)RsGlobal.screenWidth * 0.5)) + -1.0;
                  *pTargetScreenY = (float)(y / (float)((float)RsGlobal.screenHeight * 0.5)) + -1.0;
                }
                v20 = v33;
                v49 = (const CVehicle *)(v27 - 1100);
              }
            }
          }
        }
      }
      --v25;
      v26 -= 1996;
    }
    while ( v25 != -1 );
  }
  else
  {
    v49 = 0;
  }
  v35 = CPools::ms_pVehiclePool;
  v36 = CPools::ms_pVehiclePool->m_nSize;
  if ( v36 )
  {
    v37 = fRange * fRange;
    v38 = v36 - 1;
    v39 = 2604 * v36 - 2604;
    do
    {
      if ( (v35->m_aFlags[v38] & 0x80u) == 0 )
      {
        v40 = (const CVehicle *)&(*v35->m_aStorage)[v39];
        if ( v40 )
        {
          if ( v40 != FindPlayerVehicle(-1, 0) && (CDarkel::ThisVehicleShouldBeKilledForFrenzy(v40) || v50) )
          {
            m_pMat = v40->m_pMat;
            p_x = &v40->m_transform.m_translate.x;
            p_m_translate = &v40->m_transform.m_translate;
            if ( m_pMat )
              p_m_translate = (const RwV3d_0 *)&m_pMat->tx;
            if ( CSprite::CalcScreenCoors(p_m_translate, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
            {
              v44 = pResult.y;
              v45 = sqrtf(
                      (float)((float)(pResult.x - v22) * (float)(pResult.x - v22))
                    + (float)((float)(pResult.y - v21) * (float)(pResult.y - v21)));
              if ( v45 < v20 )
              {
                v46 = v40->m_pMat;
                if ( v46 )
                  p_x = &v46->tx;
                if ( (float)((float)((float)((float)(*p_x - v48) * (float)(*p_x - v48))
                                   + (float)((float)(p_x[1] - vecSource.y) * (float)(p_x[1] - vecSource.y)))
                           + (float)((float)(p_x[2] - vecSource.z) * (float)(p_x[2] - vecSource.z))) < v37 )
                {
                  if ( pTargetScreenX )
                  {
                    *pTargetScreenX = (float)(pResult.x / (float)((float)RsGlobal.screenWidth * 0.5)) + -1.0;
                    *pTargetScreenY = (float)(v44 / (float)((float)RsGlobal.screenHeight * 0.5)) + -1.0;
                  }
                  v20 = v45;
                  v49 = v40;
                }
              }
            }
          }
        }
      }
      --v38;
      v39 -= 2604;
    }
    while ( v38 != -1 );
  }
  return v49;
}
// 5E2C74: fragmented variable at 0:r3.4,4:^98.8 may be wrong
// 5E2C74: variables would overlap: 0:r3.4,4:^98.8 and ^98.4
// 5E2C74: variables would overlap: 0:r3.4,4:^98.8 and ^9C.4
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005E3028) --------------------------------------------------------
float __fastcall CWeapon::EvaluateTargetForHeatSeekingMissile(
        CEntity *pPotentialTarget,
        CVector *vOrigin,
        CVector *vAimingVector,
        float fTolerance,
        int bPlanesPriority,
        CEntity *pPreferredExistingTarget)
{
  CMatrix *m_pMat; // r3
  float x; // s0
  CSimpleTransform *p_tx; // r0
  float y; // s2
  float z; // s4
  float v13; // s10
  float v14; // s8
  float v15; // s16
  __int64 v16; // d16
  float v17; // s0
  float v18; // s0
  float v19; // s4
  CVector v21; // [sp+0h] [bp-28h] BYREF
  CVector pVecEnd; // [sp+Ch] [bp-1Ch] BYREF

  m_pMat = pPotentialTarget->m_pMat;
  x = vOrigin->x;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  y = vOrigin->y;
  z = vOrigin->z;
  if ( !m_pMat )
    p_tx = &pPotentialTarget->m_transform;
  v13 = vAimingVector->x * 250.0;
  v14 = vAimingVector->z * 250.0;
  v15 = sqrtf(
          (float)((float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
                + (float)((float)(p_tx->m_translate.y - y) * (float)(p_tx->m_translate.y - y)))
        + (float)((float)(p_tx->m_translate.z - z) * (float)(p_tx->m_translate.z - z)));
  pVecEnd.y = (float)(vAimingVector->y * 250.0) + y;
  pVecEnd.x = v13 + x;
  pVecEnd.z = v14 + z;
  v16 = *(_QWORD *)&p_tx->m_translate.x;
  v21.z = p_tx->m_translate.z;
  *(_QWORD *)&v21.x = v16;
  v17 = CCollision::DistToLine(vOrigin, &pVecEnd, &v21);
  if ( (float)(v17 * fTolerance) >= v15 )
    return -1.0;
  v18 = (float)(sqrtf(v15) * 0.1) + (float)(v17 / v15);
  if ( bPlanesPriority == 1
    && (*(_BYTE *)&pPotentialTarget->m_info & 7) == 2
    && (unsigned int)(LODWORD(pPotentialTarget[24].m_transform.m_translate.x) - 3) < 2 )
  {
    v18 = v18 * 0.25;
  }
  v19 = v18;
  if ( pPreferredExistingTarget == pPotentialTarget )
    v19 = v18 * 0.25;
  if ( pPreferredExistingTarget )
    return v19;
  return v18;
}

//----- (005E3158) --------------------------------------------------------
void CWeaponEffects::Init()
{
  int32 TxdSlot; // r0

  gCrossHair[0].m_bRender = 0;
  gCrossHair[0].clearTargetTimer = 0;
  gCrossHair[0].m_vecTargetPos.x = 0.0;
  gCrossHair[0].m_vecTargetPos.y = 0.0;
  gCrossHair[0].m_vecTargetPos.z = 0.0;
  *(_DWORD *)&gCrossHair[0].m_red = 2130706687;
  gCrossHair[0].m_fScale = 1.0;
  gCrossHair[0].m_fRotate = 0.0;
  gCrossHair[0].m_type = 0;
  gCrossHair[0].m_bLockedOn = 0.0;
  gCrossHair[1].m_bRender = 0;
  gCrossHair[1].clearTargetTimer = 0;
  gCrossHair[1].m_vecTargetPos.x = 0.0;
  gCrossHair[1].m_vecTargetPos.y = 0.0;
  gCrossHair[1].m_vecTargetPos.z = 0.0;
  *(_DWORD *)&gCrossHair[1].m_red = 2130706687;
  gCrossHair[1].m_fScale = 1.0;
  gCrossHair[1].m_fRotate = 0.0;
  gCrossHair[1].m_type = 0;
  gCrossHair[1].m_bLockedOn = 0.0;
  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  gpCrossHairTex = RwTextureRead((const RwChar *)"target256", (const RwChar *)"target256m");
  gpCrossHairTexFlight[0] = RwTextureRead((const RwChar *)"lockon", (const RwChar *)"lockonA");
  gpCrossHairTexFlight[1] = RwTextureRead((const RwChar *)"lockonFire", (const RwChar *)"lockonFireA");
  sub_1979B0();
}

//----- (005E3238) --------------------------------------------------------
void CWeaponEffects::Shutdown()
{
  RwTextureDestroy(gpCrossHairTexFlight[1]);
  gpCrossHairTexFlight[1] = 0;
  RwTextureDestroy(gpCrossHairTexFlight[0]);
  gpCrossHairTexFlight[0] = 0;
  RwTextureDestroy(gpCrossHairTex);
  gpCrossHairTex = 0;
}

//----- (005E3274) --------------------------------------------------------
bool8 __fastcall CWeaponEffects::IsLockedOn(Int32 Index)
{
  return (unsigned int)gCrossHair[Index].m_bLockedOn;
}

//----- (005E3294) --------------------------------------------------------
void __fastcall CWeaponEffects::MarkTarget(
        Int32 Index,
        CVector vecTargetPos,
        uint8 red,
        uint8 green,
        uint8 blue,
        uint8 alpha,
        float fScale,
        uint8 type)
{
  CWeaponEffects *v8; // r0

  v8 = &gCrossHair[Index];
  v8->m_bRender = 1;
  v8->m_green = green;
  v8->m_blue = blue;
  v8->m_alpha = alpha;
  v8->m_fScale = fScale;
  v8->clearTargetTimer = -1;
  v8->m_vecTargetPos = vecTargetPos;
  v8->m_red = red;
  v8->m_type = type;
}

//----- (005E32F8) --------------------------------------------------------
void __fastcall CWeaponEffects::ClearCrossHair(Int32 Index)
{
  gCrossHair[Index].clearTargetTimer = CTimer::m_snTimeInMilliseconds + 400;
}

//----- (005E331C) --------------------------------------------------------
void CWeaponEffects::ClearCrossHairs()
{
  gCrossHair[1].m_bRender = 0;
  gCrossHair[0].m_bRender = 0;
}

//----- (005E3330) --------------------------------------------------------
void __fastcall CWeaponEffects::ClearCrossHairImmediately(Int32 Index)
{
  CWeaponEffects *v1; // lr

  v1 = &gCrossHair[Index];
  v1->m_bRender = 0;
  v1->clearTargetTimer = CTimer::m_snTimeInMilliseconds - 100;
}

//----- (005E3368) --------------------------------------------------------
void CWeaponEffects::ClearAllCrosshairs()
{
  gCrossHair[0].m_bRender = 0;
  gCrossHair[1].m_bRender = 0;
  gCrossHair[0].clearTargetTimer = CTimer::m_snTimeInMilliseconds - 100;
  gCrossHair[1].clearTargetTimer = CTimer::m_snTimeInMilliseconds - 100;
}

//----- (005E3390) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void CWeaponEffects::Render()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float32x2_t v4; // d8
  __int64 v5; // d9
  __int64 v6; // d10
  __int64 v7; // d11
  __int64 v8; // d12
  __int64 v9; // d13
  float32x2_t v10; // d14
  __int64 v11; // d15
  float v12; // s31
  int i; // r4
  float v14; // s0
  float v15; // s2
  float v16; // s0
  CWeaponEffects *v17; // r0
  uint32 clearTargetTimer; // r1
  CWeaponEffects *v19; // r0
  __int64 v20; // d16
  float v21; // s2
  float32x2_t v22; // d0
  float v23; // r3
  float32x2_t v24; // d0
  float32x2_t v25; // d0
  float v26; // r3
  float32x2_t v27; // d0
  CWeaponEffects *v28; // r9
  float32x2_t v29; // d13
  float v30; // s30
  float32x2_t v31; // d1
  float v32; // s28
  float32x2_t v33; // d0
  float32x2_t v34; // d0
  float v35; // s20
  float v36; // s19
  CPlayerInfo *v37; // r9
  int IsCoopGameGoingOn; // r5
  int v39; // r0
  int v40; // r1
  CVector *p_m_vecTargetPos; // r5
  float v42; // s20
  float *p_m_fScale; // r5
  float32x2_t v44; // d16
  float v45; // s28
  bool v46; // nf
  float WeaponRadiusOnScreen; // r0
  float v48; // s30
  float v49; // s19
  CWeaponEffects *v50; // r10
  float x; // s20
  float y; // s28
  float z; // s30
  float yz; // s19
  float yx; // s29
  float xx; // s21
  float zz; // s26
  float zx; // s27
  float v59; // r5
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  float v62; // r6
  float v63; // r4
  float v64; // r6
  float v65; // s6
  float v66; // s30
  float v67; // s19
  unsigned __int64 v68; // d13
  float v69; // s6
  int v70; // r11
  CWeaponEffects *v71; // r0
  float *p_m_fRotate; // r8
  float *v73; // r2
  float v74; // s20
  float v75; // r4
  float v76; // s0
  float v77; // s2
  float v78; // s20
  float v79; // s0
  float v80; // s2
  float v81; // s26
  float v82; // s28
  float v83; // s17
  float v84; // s21
  float v85; // s27
  float v86; // s21
  float v87; // s4
  float v88; // s0
  float v89; // s2
  float v90; // s20
  float v91; // s28
  float v92; // s21
  unsigned __int64 v93; // d13
  float v94; // s2
  uint32 v95; // r0
  float v96; // s0
  float v97; // s2
  CPlayerPed *pPed; // r4
  CVehicle *m_pMyVehicle; // r1
  const CVehicle *NearestTargetEntityWithScreenCoors; // r5
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r0
  float v104; // s0
  CMatrix *v105; // r1
  __int64 *p_m_transform; // r6
  __int64 v107; // kr00_8 OVERLAPPED
  __int64 v108; // r0
  bool v109; // zf
  CMatrix *v110; // r1
  const RwV3d_0 *p_m_translate; // r0
  float v112; // s0
  float v113; // s2
  int v114; // r5
  float v115; // s2
  __int64 ClipFarPlane; // [sp+0h] [bp-110h]
  uint32 *p_clearTargetTimer; // [sp+5Ch] [bp-B4h]
  int v118; // [sp+6Ch] [bp-A4h]
  float *v119; // [sp+74h] [bp-9Ch]
  UInt8 *p_m_alpha; // [sp+78h] [bp-98h]
  uint8 *p_m_red; // [sp+7Ch] [bp-94h]
  uint8 *p_m_green; // [sp+80h] [bp-90h]
  uint8 *p_m_blue; // [sp+84h] [bp-8Ch]
  RwV3d_0 In; // [sp+88h] [bp-88h] BYREF
  float pScaleY; // [sp+94h] [bp-7Ch] BYREF
  float pScaleX; // [sp+98h] [bp-78h] BYREF
  RwV3d_0 pResult; // [sp+9Ch] [bp-74h] BYREF
  unsigned __int64 v128; // [sp+A8h] [bp-68h]
  __int64 v129; // [sp+B0h] [bp-60h]
  __int64 v130; // [sp+B8h] [bp-58h]
  __int64 v131; // [sp+C0h] [bp-50h]
  __int64 v132; // [sp+C8h] [bp-48h]
  __int64 v133; // [sp+D0h] [bp-40h]
  unsigned __int64 v134; // [sp+D8h] [bp-38h]
  __int64 v135; // [sp+E0h] [bp-30h]

  if ( TheCamera.m_WideScreenOn )
    return;
  v128 = v4.n64_u64[0];
  v129 = v5;
  v130 = v6;
  v131 = v7;
  v132 = v8;
  v133 = v9;
  v134 = v10.n64_u64[0];
  v135 = v11;
  v10.n64_u32[0] = 20.0;
  v4.n64_u32[0] = 15.0;
  v12 = -15.0;
  for ( i = 0; i != 2; ++i )
  {
    v17 = &gCrossHair[i];
    clearTargetTimer = v17->clearTargetTimer;
    if ( !clearTargetTimer )
      goto LABEL_11;
    if ( clearTargetTimer < CTimer::m_snTimeInMilliseconds )
    {
      v17->m_bRender = 0;
      v17->clearTargetTimer = 0;
      CWeaponEffects::Render(void)::increment[i] = 0.0;
LABEL_11:
      CWeaponEffects::Render(void)::increment[i] = 0.0;
      goto LABEL_14;
    }
    if ( clearTargetTimer != -1 )
      CWeaponEffects::Render(void)::increment[i] = 0.0;
LABEL_14:
    if ( CWorld::Players[i].pPed )
    {
      if ( v17->m_bRender )
      {
        if ( gCrossHair[i].m_type == 1 )
        {
          v19 = &gCrossHair[i];
          v20 = *(_QWORD *)&v19->m_vecTargetPos.x;
          In.z = v19->m_vecTargetPos.z;
          *(_QWORD *)&In.x = v20;
          if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
          {
            v21 = v10.n64_f32[0] / pScaleY;
            if ( (float)(v10.n64_f32[0] / pScaleY) > 1.0 )
            {
              pScaleY = v21 * pScaleY;
              pScaleX = v21 * pScaleX;
            }
            RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
            RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
            RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
            RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
            RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
            RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCrossHairTexFlight[0]->raster);
            v4.n64_u32[0] = 28.0;
            v0.n64_f32[0] = pScaleX;
            v22.n64_u64[0] = vmin_f32(v0, v4).n64_u64[0];
            v23 = (float)(v22.n64_f32[0] * 1.8) * 0.95;
            v22.n64_f32[0] = pScaleY;
            v24.n64_u64[0] = vmin_f32(v22, v10).n64_u64[0];
            CSprite::RenderOneXLUSprite_Rotate_Aspect(
              pResult.x,
              pResult.y,
              pResult.z,
              v23,
              (float)(v24.n64_f32[0] * 1.8) * 0.95,
              0,
              0,
              0,
              255,
              0.01,
              0.0,
              0xFFu);
            v24.n64_f32[0] = pScaleX;
            v25.n64_u64[0] = vmin_f32(v24, v4).n64_u64[0];
            v26 = (float)(v25.n64_f32[0] * 1.8) * 1.05;
            v25.n64_f32[0] = pScaleY;
            v27.n64_u64[0] = vmin_f32(v25, v10).n64_u64[0];
            CSprite::RenderOneXLUSprite_Rotate_Aspect(
              pResult.x,
              pResult.y,
              pResult.z,
              v26,
              (float)(v27.n64_f32[0] * 1.8) * 1.05,
              0,
              0,
              0,
              255,
              0.01,
              0.0,
              0xFFu);
            v28 = &gCrossHair[i];
            v27.n64_f32[0] = pScaleX;
            v33.n64_u64[0] = vmin_f32(v27, v4).n64_u64[0];
            v1.n64_f32[0] = pScaleY;
            v31.n64_u64[0] = vmin_f32(v1, v10).n64_u64[0];
            CSprite::RenderOneXLUSprite_Rotate_Aspect(
              pResult.x,
              pResult.y,
              pResult.z,
              v33.n64_f32[0] * 1.8,
              v31.n64_f32[0] * 1.8,
              v28->m_red,
              v28->m_green,
              v28->m_blue,
              255,
              0.01,
              0.0,
              v28->m_alpha);
            RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCrossHairTexFlight[1]->raster);
            v29.n64_u64[0] = v10.n64_u64[0];
            v30 = (float)(CTimer::m_snTimeInMilliseconds & 0x3FF) * 0.0061359;
            v33.n64_f32[0] = v28->m_fRadius - (float)(v30 * v10.n64_f32[0]);
            v31.n64_u32[0] = 0;
            v32 = vmax_f32(v33, v31).n64_f32[0];
            v33.n64_u32[0] = 0;
            if ( v32 == 0.0 )
              v33.n64_u32[0] = 1.0;
            v28->m_fRadius = v32;
            LODWORD(v28->m_bLockedOn) = v33.n64_u32[0];
            v33.n64_f32[0] = pScaleY;
            v31.n64_f32[0] = pScaleX;
            v34.n64_u64[0] = vmin_f32(v33, v29).n64_u64[0];
            v35 = vmin_f32(v31, v4).n64_f32[0];
            v36 = v34.n64_f32[0] * 0.8;
            v4.n64_u32[1] = cosf(v30);
            v2.n64_f32[0] = v4.n64_f32[1] * v32;
            v34.n64_f32[0] = sinf(v30) * v32;
            v10.n64_u64[0] = v29.n64_u64[0];
            CWeaponEffects::Render(void)::newy = v2.n64_f32[0];
            CWeaponEffects::Render(void)::newx = v34.n64_f32[0];
            CSprite::RenderOneXLUSprite_Rotate_Aspect(
              pResult.x - v34.n64_f32[0],
              pResult.y - v2.n64_f32[0],
              pResult.z,
              (float)(v35 * 0.8) * 0.95,
              v36 * 0.95,
              0,
              0,
              0,
              255,
              0.01,
              v30,
              0xFFu);
            v4.n64_u32[0] = 28.0;
            v31.n64_f32[0] = pScaleX;
            v34.n64_f32[0] = pScaleY;
            v1.n64_u64[0] = vmin_f32(v31, v4).n64_u64[0];
            CSprite::RenderOneXLUSprite_Rotate_Aspect(
              pResult.x - CWeaponEffects::Render(void)::newx,
              pResult.y - CWeaponEffects::Render(void)::newy,
              pResult.z,
              (float)(v1.n64_f32[0] * 0.8) * 1.05,
              (float)(vmin_f32(v34, v29).n64_f32[0] * 0.8) * 1.05,
              0,
              0,
              0,
              255,
              0.01,
              v30,
              0xFFu);
            v2.n64_f32[0] = pScaleX;
            v2.n64_u64[0] = vmin_f32(v2, v4).n64_u64[0];
            v3.n64_f32[0] = pScaleY;
            v0.n64_u64[0] = vmin_f32(v3, v29).n64_u64[0];
            CSprite::RenderOneXLUSprite_Rotate_Aspect(
              pResult.x - CWeaponEffects::Render(void)::newx,
              pResult.y - CWeaponEffects::Render(void)::newy,
              pResult.z,
              v2.n64_f32[0] * 0.8,
              v0.n64_f32[0] * 0.8,
              v28->m_red,
              v28->m_green,
              v28->m_blue,
              v28->m_alpha,
              0.01,
              v30,
              0xFFu);
            v4.n64_u32[0] = 15.0;
            v12 = -15.0;
          }
          RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
        }
        else
        {
          p_clearTargetTimer = &v17->clearTargetTimer;
          v37 = &CWorld::Players[i];
          RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
          RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
          RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
          IsCoopGameGoingOn = CGameLogic::IsCoopGameGoingOn();
          v39 = CGameLogic::IsCoopGameGoingOn();
          v40 = IsCoopGameGoingOn ^ 1;
          p_m_vecTargetPos = &gCrossHair[i].m_vecTargetPos;
          CSprite::CalcScreenCoors(p_m_vecTargetPos, &pResult, &pScaleX, &pScaleY, v40, v39 ^ 1);
          v118 = i;
          if ( pResult.x < 0.0
            || pResult.x > (float)RsGlobal.screenWidth
            || pResult.y < 0.0
            || pResult.y > (float)RsGlobal.screenHeight )
          {
            if ( CGameLogic::IsCoopGameGoingOn() == 1 )
            {
              v50 = &gCrossHair[i];
              x = p_m_vecTargetPos->x;
              y = v50->m_vecTargetPos.y;
              z = v50->m_vecTargetPos.z;
              yz = TheCamera.m_cameraMatrix.yz;
              v4.n64_u32[1] = LODWORD(TheCamera.m_cameraMatrix.xz);
              yx = TheCamera.m_cameraMatrix.yx;
              xx = TheCamera.m_cameraMatrix.xx;
              zz = TheCamera.m_cameraMatrix.zz;
              zx = TheCamera.m_cameraMatrix.zx;
              v59 = atan2f(
                      (float)((float)((float)(p_m_vecTargetPos->x - TheCamera.m_cameraMatrix.tx)
                                    * TheCamera.m_cameraMatrix.xz)
                            + (float)((float)(y - TheCamera.m_cameraMatrix.ty) * TheCamera.m_cameraMatrix.yz))
                    + (float)((float)(z - TheCamera.m_cameraMatrix.tz) * TheCamera.m_cameraMatrix.zz),
                      (float)((float)((float)(p_m_vecTargetPos->x - TheCamera.m_cameraMatrix.tx)
                                    * TheCamera.m_cameraMatrix.xx)
                            + (float)((float)(y - TheCamera.m_cameraMatrix.ty) * TheCamera.m_cameraMatrix.yx))
                    + (float)((float)(z - TheCamera.m_cameraMatrix.tz) * TheCamera.m_cameraMatrix.zx));
              m_pMat = v37->pPed->m_pMat;
              p_tx = &m_pMat->tx;
              if ( !m_pMat )
                p_tx = &v37->pPed->m_transform.m_translate.x;
              v62 = atan2f(
                      (float)((float)(v4.n64_f32[1] * (float)(x - *p_tx)) + (float)(yz * (float)(y - p_tx[1])))
                    + (float)(zz * (float)(z - p_tx[2])),
                      (float)((float)(xx * (float)(x - *p_tx)) + (float)(yx * (float)(y - p_tx[1])))
                    + (float)(zx * (float)(z - p_tx[2])));
              v63 = sinf(v62);
              v64 = cosf(v62);
              v65 = sinf(v59);
              v4.n64_f32[1] = v63 * v4.n64_f32[0];
              v66 = (float)(1.0 - cosf(v59)) * (float)((float)RsGlobal.screenWidth * 0.5);
              v67 = (float)(1.0 - v65) * (float)((float)RsGlobal.screenHeight * 0.5);
              *((float *)&v68 + 1) = v64 * 7.5;
              CSprite::RenderOneXLUSprite_Triangle(
                v66,
                v67,
                (float)(v63 * 7.5) + (float)((float)(v64 * v4.n64_f32[0]) + v66),
                (float)(v4.n64_f32[1] + v67) - (float)(v64 * 7.5),
                (float)((float)(v64 * v4.n64_f32[0]) + v66) - (float)(v63 * 7.5),
                (float)(v64 * 7.5) + (float)(v4.n64_f32[1] + v67),
                2.5,
                0,
                0,
                0,
                255,
                1.0,
                0xFFu);
              v69 = v64 * 1.5 + v66;
              LODWORD(v68) = 20.0;
              v10.n64_u64[0] = v68;
              CSprite::RenderOneXLUSprite_Triangle(
                v69,
                (float)(v63 * 1.5) + v67,
                (float)((float)((float)(v63 * 7.5) + (float)(v64 * v4.n64_f32[0])) * 0.8) + v69,
                (float)((float)(v4.n64_f32[1] - *((float *)&v68 + 1)) * 0.8) + (float)((float)(v63 * 1.5) + v67),
                (float)((float)((float)(v64 * v4.n64_f32[0]) - (float)(v63 * 7.5)) * 0.8) + v69,
                (float)((float)(v4.n64_f32[1] + *((float *)&v68 + 1)) * 0.8) + (float)((float)(v63 * 1.5) + v67),
                2.5,
                v50->m_red,
                v50->m_green,
                v50->m_blue,
                255,
                1.0,
                0xFFu);
            }
          }
          else
          {
            v42 = v10.n64_f32[0];
            v1.n64_u32[0] = 1067030938;
            p_m_fScale = &gCrossHair[i].m_fScale;
            v0.n64_f32[0] = *p_m_fScale;
            v44.n64_u64[0] = vmin_f32(v0, v1).n64_u64[0];
            v0.n64_u32[0] = 1050253722;
            LODWORD(v45) = vmax_f32(v44, v0).n64_u32[0];
            v46 = pResult.z < 2.5;
            *p_m_fScale = v45;
            if ( v46 )
              pResult.z = 2.5;
            WeaponRadiusOnScreen = CPlayerPed::GetWeaponRadiusOnScreen(v37->pPed);
            if ( WeaponRadiusOnScreen <= 0.0 )
            {
              v49 = v45 * 25.0;
              v48 = v45 * 5.0;
            }
            else
            {
              v48 = WeaponRadiusOnScreen * 30.0;
              v49 = (float)(WeaponRadiusOnScreen * 30.0) + (float)(*p_m_fScale * v42);
            }
            RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
            RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
            v70 = 0;
            v71 = &gCrossHair[i];
            p_m_blue = &v71->m_blue;
            p_m_green = &v71->m_green;
            p_m_red = &v71->m_red;
            p_m_fRotate = &v71->m_fRotate;
            p_m_alpha = &v71->m_alpha;
            v73 = &CWeaponEffects::Render(void)::increment[i];
            v119 = v73;
            do
            {
              v4.n64_f32[1] = v48 + *v73;
              v74 = (float)v70 * 120.0;
              v75 = (float)((float)(v74 * 3.1416) / 180.0) + *p_m_fRotate;
              v76 = v74 + v4.n64_f32[0];
              v77 = v74 + v12;
              v78 = v49 + *v73;
              v79 = (float)((float)(v76 * 3.1416) / 180.0) + *p_m_fRotate;
              v80 = (float)((float)(v77 * 3.1416) / 180.0) + *p_m_fRotate;
              v81 = v4.n64_f32[1] * sinf(v75);
              v82 = v4.n64_f32[1] * cosf(v75);
              v83 = sinf(v79);
              v84 = sinf(v80);
              v85 = cosf(v80);
              v86 = v78 * v84;
              v87 = v78 * v83;
              v88 = v78 * cosf(v79);
              v89 = v78 * v85;
              v90 = pResult.y - v82;
              v91 = pResult.x - v86;
              *(float *)&v93 = pResult.x - v81;
              v92 = pResult.x - v87;
              *((float *)&v93 + 1) = pResult.y - v88;
              v4.n64_f32[1] = pResult.y - v89;
              CSprite::RenderOneXLUSprite_Triangle(
                *(float *)&v93,
                v90,
                pResult.x - v87,
                pResult.y - v88,
                v91,
                pResult.y - v89,
                pResult.z,
                0,
                0,
                0,
                255,
                1.0,
                *p_m_alpha);
              RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
              RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
              RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
              v0.n64_f32[0] = (float)((float)(*(float *)&v93 + v92) + v91) / 3.0;
              v94 = (float)((float)(v90 + *((float *)&v93 + 1)) + v4.n64_f32[1]) / 3.0;
              v0.n64_f32[1] = v91 - v0.n64_f32[0];
              CSprite::RenderOneXLUSprite_Triangle(
                v0.n64_f32[0] + (float)((float)(*(float *)&v93 - v0.n64_f32[0]) * 0.75),
                v94 + (float)((float)(v90 - v94) * 0.75),
                v0.n64_f32[0] + (float)((float)(v92 - v0.n64_f32[0]) * 0.75),
                v94 + (float)((float)(*((float *)&v93 + 1) - v94) * 0.75),
                v0.n64_f32[0] + (float)((float)(v91 - v0.n64_f32[0]) * 0.75),
                v94 + (float)((float)(v4.n64_f32[1] - v94) * 0.75),
                pResult.z,
                *p_m_red,
                *p_m_green,
                *p_m_blue,
                255,
                1.0,
                *p_m_alpha);
              v73 = v119;
              ++v70;
            }
            while ( v70 != 3 );
            v95 = *p_clearTargetTimer;
            if ( *p_clearTargetTimer + 1 >= 2 )
            {
              v96 = *p_m_fRotate + 0.75;
              v97 = *v119 + 2.0;
              *p_m_fRotate = v96;
              *v119 = v97;
              *p_m_fScale = *p_m_fScale * 0.9;
            }
            else
            {
              v96 = *p_m_fRotate + 0.05;
              *p_m_fRotate = v96;
            }
            LODWORD(v93) = 20.0;
            v10.n64_u64[0] = v93;
            if ( v96 > 6.2832 )
              *p_m_fRotate = 0.0;
            if ( !v95 )
            {
              if ( CWeaponEffects::Render(void)::increFlag[v118] )
              {
                v14 = *p_m_fScale * 20.0;
                v15 = *v119 + (float)(*p_m_fScale + *p_m_fScale);
                *v119 = v15;
                if ( v15 > v14 )
                  CWeaponEffects::Render(void)::increFlag[v118] = 0;
              }
              else
              {
                v16 = *v119 + -2.0;
                *v119 = v16;
                if ( v16 < 0.0 )
                  CWeaponEffects::Render(void)::increFlag[v118] = 1;
              }
            }
          }
          RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
          RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
          RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
          i = v118;
        }
      }
    }
    else
    {
      v17->m_bRender = 0;
    }
  }
  if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 49 )
  {
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCrossHairTex->raster);
    pPed = CWorld::Players[1].pPed;
    m_pMyVehicle = CWorld::Players[0].pPed->m_pMyVehicle;
    if ( m_pMyVehicle && m_pMyVehicle->pDriver != CWorld::Players[0].pPed )
      pPed = CWorld::Players[0].pPed;
    if ( pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_nAmmoTotal )
      CSprite::RenderOneXLUSprite_Rotate_Aspect(
        (float)((float)(TheCamera.Cams[TheCamera.ActiveCam].X_Targetting + 1.0) * (float)RsGlobal.screenWidth) * 0.5,
        (float)((float)(TheCamera.Cams[TheCamera.ActiveCam].Y_Targetting + 1.0) * (float)RsGlobal.screenHeight) * 0.5,
        100.0,
        20.0,
        20.0,
        255,
        128,
        0,
        128,
        0.01,
        (float)(CTimer::m_snTimeInMilliseconds & 0x3FF) * 0.0061359,
        0xFFu);
    NearestTargetEntityWithScreenCoors = 0;
    if ( pPed )
    {
      m_eWeaponType = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
      WeaponSkill = CPed::GetWeaponSkill(pPed);
      WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
      v104 = WeaponInfo->m_fWeaponRange + WeaponInfo->m_fWeaponRange;
      v105 = pPed->m_pMat;
      p_m_transform = (__int64 *)&v105->tx;
      if ( !v105 )
        p_m_transform = (__int64 *)&pPed->m_transform;
      v107 = *p_m_transform;
      v108 = *(_QWORD *)&TheCamera.Cams[TheCamera.ActiveCam].X_Targetting;
      ClipFarPlane = *(__int64 *)((char *)p_m_transform + 4);
      NearestTargetEntityWithScreenCoors = CWeapon::FindNearestTargetEntityWithScreenCoors(
                                             *(float *)&v108,
                                             *((float *)&v108 + 1),
                                             v104,
                                             *(CVector *)&v107,
                                             0,
                                             0);
    }
    if ( NearestTargetEntityWithScreenCoors != CWeaponEffects::Render(void)::pEntityTargetted )
    {
      CWeaponEffects::Render(void)::pEntityTargetted = &NearestTargetEntityWithScreenCoors->CPhysical;
      CWeaponEffects::Render(void)::TimeEntityFound = CTimer::m_snTimeInMilliseconds;
    }
    v109 = NearestTargetEntityWithScreenCoors == 0;
    if ( NearestTargetEntityWithScreenCoors )
      v109 = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_nAmmoTotal == 0;
    if ( !v109 )
    {
      v110 = NearestTargetEntityWithScreenCoors->m_pMat;
      p_m_translate = (const RwV3d_0 *)&v110->tx;
      if ( !v110 )
        p_m_translate = &NearestTargetEntityWithScreenCoors->m_transform.m_translate;
      if ( CSprite::CalcScreenCoors(p_m_translate, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
      {
        v112 = pScaleY;
        v113 = v10.n64_f32[0] / pScaleY;
        if ( (float)(v10.n64_f32[0] / pScaleY) > 1.0 )
        {
          v112 = v113 * pScaleY;
          pScaleY = v113 * pScaleY;
          pScaleX = v113 * pScaleX;
        }
        LOWORD(v114) = 255;
        if ( (int)(CTimer::m_snTimeInMilliseconds - CWeaponEffects::Render(void)::TimeEntityFound) < 744 )
          v114 = (int)(CTimer::m_snTimeInMilliseconds - CWeaponEffects::Render(void)::TimeEntityFound) / 4 + 70;
        v2.n64_u32[0] = 1.0;
        v1.n64_f32[0] = (float)((float)(int)(CTimer::m_snTimeInMilliseconds
                                           - CWeaponEffects::Render(void)::TimeEntityFound)
                              * -0.0019531)
                      + 3.0;
        v115 = vmax_f32(v1, v2).n64_f32[0];
        CSprite::RenderOneXLUSprite_Rotate_Aspect(
          pResult.x,
          pResult.y,
          pResult.z,
          v115 * pScaleX,
          v115 * v112,
          (unsigned __int8)v114,
          0,
          0,
          (__int16)v114,
          0.01,
          (float)(CTimer::m_snTimeInMilliseconds & 0x3FF) * 0.0061359,
          0xFFu);
      }
    }
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  }
  CPlayerCrossHair::Render(&CWorld::Players[0].CrossHair, 0);
  CPlayerCrossHair::Render(&CWorld::Players[1].CrossHair, 1);
}
// 5E40BF: failed to expand linear variable kr00_8.8
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005E42E8) --------------------------------------------------------
CWeaponInfo *__fastcall CWeaponInfo::GetWeaponInfo(eWeaponType WeaponType, int8 nSkillLevel)
{
  switch ( nSkillLevel )
  {
    case 0:
      LOWORD(WeaponType) = WeaponType + 25;
      break;
    case 1:
      return &aWeaponInfo[(__int16)WeaponType];
    case 2:
      LOWORD(WeaponType) = WeaponType + 36;
      break;
    case 3:
      LOWORD(WeaponType) = WeaponType + 47;
      break;
    default:
      LOWORD(WeaponType) = 47;
      break;
  }
  return &aWeaponInfo[(__int16)WeaponType];
}

//----- (005E4318) --------------------------------------------------------
int32 __fastcall CWeaponInfo::GetSkillStatIndex(eWeaponType WeaponType)
{
  int32 v2; // r1

  if ( (unsigned int)(WeaponType - 22) > 0xA )
    return -1;
  v2 = WeaponType + 47;
  if ( WeaponType > WEAPONTYPE_M4 )
    return 75;
  return v2;
}

//----- (005E4334) --------------------------------------------------------
eWeaponType __fastcall CWeaponInfo::FindWeaponType(const unsigned __int8 *pString)
{
  eWeaponType v2; // r4

  v2 = WEAPONTYPE_UNARMED;
  while ( strcasecmp((const char *)pString, (const char *)CWeaponInfo::ms_aWeaponNames[v2]) )
  {
    if ( v2++ >= WEAPONTYPE_ARMOUR )
      return 0;
  }
  return v2;
}

//----- (005E4368) --------------------------------------------------------
float __fastcall CWeaponInfo::GetTargetHeadRange(CWeaponInfo *this)
{
  return (float)(this->m_fWeaponRange * 0.04) * (float)(this->m_SkillLevel + 2);
}

//----- (005E4390) --------------------------------------------------------
int32 __fastcall CWeaponInfo::GetWeaponReloadTime(CWeaponInfo *this)
{
  int32 m_nFlags; // r1
  int32 result; // r0
  int m_nAimOffsetIndex; // r1

  m_nFlags = this->m_nFlags;
  if ( (m_nFlags & 0x1000) != 0 )
  {
    result = 1000;
    if ( (m_nFlags & 0x800) != 0 )
      return 2000;
  }
  else if ( (m_nFlags & 0x8000) != 0 )
  {
    return 1000;
  }
  else
  {
    m_nAimOffsetIndex = this->m_nAimOffsetIndex;
    result = CWeaponInfo::ms_aWeaponAimOffsets[this->m_nAimOffsetIndex].nReloadSampleA + 100;
    if ( (unsigned int)result <= 0x190 )
    {
      result = CWeaponInfo::ms_aWeaponAimOffsets[m_nAimOffsetIndex].nReloadSampleCrouchedA + 100;
      if ( (unsigned int)result <= 0x190 )
      {
        result = CWeaponInfo::ms_aWeaponAimOffsets[m_nAimOffsetIndex].nReloadSampleB + 100;
        if ( (unsigned int)result <= 0x190 )
        {
          result = CWeaponInfo::ms_aWeaponAimOffsets[m_nAimOffsetIndex].nReloadSampleCrouchedB + 100;
          if ( (unsigned int)result <= 0x190 )
            return 400;
        }
      }
    }
  }
  return result;
}

//----- (005E4420) --------------------------------------------------------
RwBool AttachInputDevices()
{
  RsInputDeviceAttach(rsPAD, PadHandler);
  return 1;
}

//----- (005E4438) --------------------------------------------------------
RsEventStatus_0 __fastcall PadHandler(RsEvent_0 event, void *param)
{
  int v2; // r4
  RwInt32 v3; // r1
  RwInt32 v4; // r1
  RwInt32 v5; // r1
  RwInt32 v6; // r1
  RwInt32 v7; // r1
  RwInt32 v8; // r1
  RwInt32 v9; // r1
  RwInt32 v10; // r1
  RwInt32 v11; // r1
  RwInt32 v12; // r1
  RwInt32 v13; // r1
  RwInt32 v14; // r1
  RwInt32 v15; // r1
  RwInt32 v16; // r1
  RwInt32 v17; // r1
  int v18; // r4
  RwInt32 v19; // r1
  RwInt32 v20; // r8
  RwInt32 v21; // r1
  RwInt32 v22; // r1
  RwInt32 v23; // r1
  RwInt32 v24; // r1
  RwInt32 v25; // r1
  RwInt32 v26; // r1
  RwInt32 v27; // r1
  RwInt32 v28; // r1
  RwInt32 v29; // r1
  RwInt32 v30; // r1
  RwInt32 v31; // r1
  RwInt32 v32; // r1
  RwInt32 v33; // r1

  if ( event == rsPADBUTTONUP )
  {
    v18 = *(_DWORD *)param;
    CPad::GetPad(*(_DWORD *)param);
    if ( CPad::m_bMapPadOneToPadTwo )
      v18 = 1;
    CControllerConfigManager::UpdateJoyButtonState(&ControlsManager, v18);
    v19 = 0;
    v20 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][1] )
      v19 = 2;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v19, v18);
    v21 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][2] )
      v21 = 3;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v21, v18);
    v22 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][3] )
      v22 = 4;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v22, v18);
    v23 = 0;
    if ( !*((_BYTE *)&ControlsManager.ConfigurationForAction[-1][0].m_uiActionInitiator + 17 * v18) )
      v23 = 5;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v23, v18);
    v24 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][5] )
      v24 = 6;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v24, v18);
    v25 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][6] )
      v25 = 7;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v25, v18);
    v26 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][7] )
      v26 = 8;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v26, v18);
    v27 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][8] )
      v27 = 9;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v27, v18);
    v28 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][9] )
      v28 = 10;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v28, v18);
    v29 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][10] )
      v29 = 11;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v29, v18);
    v30 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][11] )
      v30 = 12;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v30, v18);
    v31 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][12] )
      v31 = 13;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v31, v18);
    v32 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][13] )
      v32 = 14;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v32, v18);
    v33 = 0;
    if ( !ControlsManager.m_arrJoyButtonState[v18][14] )
      v33 = 15;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v33, v18);
    if ( !ControlsManager.m_arrJoyButtonState[v18][15] )
      v20 = 16;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonUp(&ControlsManager, v20, v18);
    return 1;
  }
  if ( event == rsPADBUTTONDOWN )
  {
    v2 = *(_DWORD *)param;
    CPad::GetPad(*(_DWORD *)param);
    if ( CPad::m_bMapPadOneToPadTwo )
      v2 = 1;
    CControllerConfigManager::UpdateJoyButtonState(&ControlsManager, v2);
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(
      &ControlsManager,
      ControlsManager.m_arrJoyButtonState[v2][0],
      v2);
    v3 = ControlsManager.m_arrJoyButtonState[v2][1];
    if ( ControlsManager.m_arrJoyButtonState[v2][1] )
      v3 = 2;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v3, v2);
    v4 = ControlsManager.m_arrJoyButtonState[v2][2];
    if ( ControlsManager.m_arrJoyButtonState[v2][2] )
      v4 = 3;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v4, v2);
    v5 = ControlsManager.m_arrJoyButtonState[v2][3];
    if ( ControlsManager.m_arrJoyButtonState[v2][3] )
      v5 = 4;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v5, v2);
    v6 = *((unsigned __int8 *)&ControlsManager.ConfigurationForAction[-1][0].m_uiActionInitiator + 17 * v2);
    if ( *((_BYTE *)&ControlsManager.ConfigurationForAction[-1][0].m_uiActionInitiator + 17 * v2) )
      v6 = 5;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v6, v2);
    v7 = ControlsManager.m_arrJoyButtonState[v2][5];
    if ( ControlsManager.m_arrJoyButtonState[v2][5] )
      v7 = 6;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v7, v2);
    v8 = ControlsManager.m_arrJoyButtonState[v2][6];
    if ( ControlsManager.m_arrJoyButtonState[v2][6] )
      v8 = 7;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v8, v2);
    v9 = ControlsManager.m_arrJoyButtonState[v2][7];
    if ( ControlsManager.m_arrJoyButtonState[v2][7] )
      v9 = 8;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v9, v2);
    v10 = ControlsManager.m_arrJoyButtonState[v2][8];
    if ( ControlsManager.m_arrJoyButtonState[v2][8] )
      v10 = 9;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v10, v2);
    v11 = ControlsManager.m_arrJoyButtonState[v2][9];
    if ( ControlsManager.m_arrJoyButtonState[v2][9] )
      v11 = 10;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v11, v2);
    v12 = ControlsManager.m_arrJoyButtonState[v2][10];
    if ( ControlsManager.m_arrJoyButtonState[v2][10] )
      v12 = 11;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v12, v2);
    v13 = ControlsManager.m_arrJoyButtonState[v2][11];
    if ( ControlsManager.m_arrJoyButtonState[v2][11] )
      v13 = 12;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v13, v2);
    v14 = ControlsManager.m_arrJoyButtonState[v2][12];
    if ( ControlsManager.m_arrJoyButtonState[v2][12] )
      v14 = 13;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v14, v2);
    v15 = ControlsManager.m_arrJoyButtonState[v2][13];
    if ( ControlsManager.m_arrJoyButtonState[v2][13] )
      v15 = 14;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v15, v2);
    v16 = ControlsManager.m_arrJoyButtonState[v2][14];
    if ( ControlsManager.m_arrJoyButtonState[v2][14] )
      v16 = 15;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v16, v2);
    v17 = ControlsManager.m_arrJoyButtonState[v2][15];
    if ( ControlsManager.m_arrJoyButtonState[v2][15] )
      v17 = 16;
    CControllerConfigManager::UpdateJoyInConfigMenus_ButtonDown(&ControlsManager, v17, v2);
    return 1;
  }
  return 2;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005E474C) --------------------------------------------------------
bool IsPlayingGame()
{
  return gGameState == 9;
}

//----- (005E4764) --------------------------------------------------------
void DoGameState()
{
  uint32 v0; // r1
  CPad *Pad; // r0
  OSKeyboardKey v2; // r0
  CPad *v3; // r0
  OSKeyboardKey v4; // r0
  int v5; // r0
  RwInt32 v6; // r0
  bool v7; // zf
  unsigned int CurrentTimeInCycles; // r4
  unsigned int CyclesPerMillisecond; // r0

  switch ( gGameState )
  {
    case 0u:
      MobileMenu::Initialize(&gMobileMenu);
      v0 = 5;
      goto LABEL_17;
    case 1u:
      v0 = 2;
      goto LABEL_17;
    case 2u:
      CPad::UpdatePads();
      if ( startupDeactivate )
        goto LABEL_29;
      if ( CControllerConfigManager::GetJoyButtonJustDown(&ControlsManager) )
        goto LABEL_29;
      Pad = CPad::GetPad(0);
      if ( CControllerState::CheckForInput(&Pad->NewState) )
        goto LABEL_29;
      CPad::GetPad(0);
      if ( CPad::NewMouseControllerState.m_bLeftButton )
      {
        if ( !CPad::OldMouseControllerState.m_bLeftButton )
          goto LABEL_29;
      }
      CPad::GetPad(0);
      if ( LIB_KeyboardPressed(KK_ENTER) )
        goto LABEL_29;
      CPad::GetPad(0);
      v2 = RsKeyToOSWKey((RsKeyCodes_0)32);
      if ( v2 != KK_MAX )
      {
        if ( LIB_KeyboardPressed(v2) )
          goto LABEL_29;
      }
      CPad::GetPad(0);
      if ( LIB_KeyboardPressed(KK_LEFTALT) )
        goto LABEL_29;
      if ( LIB_KeyboardPressed(KK_RIGHTALT) )
        goto LABEL_29;
      CPad::GetPad(0);
      if ( LIB_KeyboardPressed(KK_TAB) )
        goto LABEL_29;
      break;
    case 3u:
      v0 = 4;
LABEL_17:
      gGameState = v0;
      break;
    case 4u:
      CPad::UpdatePads();
      if ( startupDeactivate
        || CControllerConfigManager::GetJoyButtonJustDown(&ControlsManager)
        || (v3 = CPad::GetPad(0), CControllerState::CheckForInput(&v3->NewState))
        || (CPad::GetPad(0), CPad::NewMouseControllerState.m_bLeftButton)
        && !CPad::OldMouseControllerState.m_bLeftButton
        || (CPad::GetPad(0), LIB_KeyboardPressed(KK_ENTER))
        || (CPad::GetPad(0), v4 = RsKeyToOSWKey((RsKeyCodes_0)32), v4 != KK_MAX) && LIB_KeyboardPressed(v4)
        || (CPad::GetPad(0), LIB_KeyboardPressed(KK_LEFTALT))
        || LIB_KeyboardPressed(KK_RIGHTALT)
        || (CPad::GetPad(0), LIB_KeyboardPressed(KK_TAB)) )
      {
LABEL_29:
        ++gGameState;
      }
      break;
    case 5u:
      if ( !CGame::InitialiseEssentialsAfterRW() )
        RsGlobal.quit = 1;
      CGame::InitialiseCoreDataAfterRW();
      gGameState = 6;
      CheckAniso();
      break;
    case 6u:
      v5 = NeedsAmazonDownload();
      DoGameState(void)::needsDownload = v5;
      if ( v5 )
        MobileMenu::InitForDownload(&gMobileMenu);
      else
        MobileMenu::InitForTitle(&gMobileMenu);
      gGameState = 7;
      SkipBankLoader = 0;
      SendLanguageToSC();
      break;
    case 7u:
      RsGlobal.maxFPS = 30;
      RsEventHandler(rsFRONTENDIDLE, 0);
      if ( DoGameState(void)::needsDownload )
        DoGameState(void)::needsDownload = ProcessDataDownload();
      if ( gMobileMenu.WantsToLoad )
        goto LABEL_38;
      break;
    case 8u:
LABEL_38:
      CAudioEngine::StartLoadingTune(&AudioEngine);
      CLoadingScreen::DoPCScreenChange(0, 1u);
      if ( gMobileMenu.WantsToLoad )
        CLoadingScreen::SetChunksToLoad(30, 1);
      InitialiseGame();
      FrontEndMenuManager.m_MainMenu = 0;
      gGameState = 9;
      CAudioEngine::InitialisePostLoading(&AudioEngine);
      if ( !gMobileMenu.WantsToLoad )
        CLoadingScreen::Shutdown(0);
      break;
    case 9u:
      v6 = 30;
      v7 = gMobileMenu.screenStack.numEntries == 0;
      if ( !gMobileMenu.screenStack.numEntries )
        v7 = gMobileMenu.pendingScreen == 0;
      if ( v7 )
      {
        v6 = 30;
        if ( MobileSettings::settings[30].value )
          v6 = 20;
      }
      RsGlobal.maxFPS = v6;
      CurrentTimeInCycles = CTimer::GetCurrentTimeInCycles();
      CyclesPerMillisecond = CTimer::GetCyclesPerMillisecond();
      if ( RwInitialized
        && (float)((float)CurrentTimeInCycles / (float)((float)CyclesPerMillisecond * 0.001)) > (float)(1000000.0 / (float)RsGlobal.maxFPS) )
      {
        UpdateInput();
        RsEventHandler(rsIDLE, (char *)&dword_0 + 1);
      }
      else
      {
        OS_ThreadSleep(100);
      }
      break;
    default:
      break;
  }
  if ( !WasForegroundApp )
    WasForegroundApp = 1;
}
// 0: using guessed type int dword_0;

//----- (005E4B38) --------------------------------------------------------
int DoGameRestart()
{
  RwInitialized = 0;
  CMenuManager::UnloadTextures(&FrontEndMenuManager);
  if ( gMobileMenu.m_WantsToRestartGame )
  {
    CCheat::ResetCheats();
    CPad::StopPadsShaking();
    CTimer::Stop();
    if ( gMobileMenu.WantsToLoad )
    {
      CGame::ShutDownForRestart();
      CGame::InitialiseWhenRestarting();
      gMobileMenu.WantsToLoad = 0;
    }
    else if ( bFirstTime )
    {
      CTimer::Stop();
      gGameState = 8;
    }
    else
    {
      CCheat::ResetCheats();
      CGame::ShutDownForRestart();
      CTimer::Stop();
      CGame::InitialiseWhenRestarting();
      gMobileMenu.m_WantsToRestartGame = 0;
    }
    gMobileMenu.m_WantsToRestartGame = 0;
    bFirstTime = 0;
    CLoadingScreen::Shutdown(0);
    return 1;
  }
  else
  {
    if ( gGameState == 9 )
      CGame::Shutdown();
    if ( !NeedsAmazonDownload() )
      CAudioEngine::Shutdown(&AudioEngine);
    return 0;
  }
}

//----- (005E4C38) --------------------------------------------------------
bool __fastcall SaveGameForPause(eSaveTypes state, unsigned __int8 *Scriptname)
{
  int v4; // r8
  __int32 v5; // r12
  int v6; // r9
  int v7; // r6
  int v8; // r1
  int v9; // r0
  int v10; // r3
  bool v11; // zf
  int v12; // lr
  int v13; // r6
  _BOOL4 v14; // r5
  bool v15; // zf
  int v16; // r5
  int v17; // r6
  GxtChar *v18; // r0
  int8 v19; // r1

  CTimer::Suspend();
  if ( state == eStartmissionSave )
    OS_ServiceAppCommand("Analytic", Scriptname);
  v4 = 0;
  v5 = state | 4;
  v6 = 0;
  v7 = 0;
  SaveGameStateType = state;
  if ( state != eStartmissionSave )
    v4 = 1;
  if ( v5 != 4 )
    v6 = 1;
  v8 = 0;
  v9 = 0;
  v10 = CTheScripts::bAlreadyRunningAMissionScript;
  if ( CTheScripts::bAlreadyRunningAMissionScript )
    v10 = 1;
  if ( state != eTeminateSave )
    v8 = 1;
  if ( state != eExitSave )
    v9 = 1;
  if ( state != eAutoSave )
    v7 = 1;
  if ( gGameState != 9 )
    goto LABEL_32;
  v11 = state == eCheckpointSave;
  v12 = v8 | v10;
  v13 = v7 | v10;
  if ( state )
    v11 = state == eStartmissionSave;
  if ( v11 )
    goto LABEL_23;
  v14 = CTheScripts::bAlreadyRunningAMissionScript != 0;
  v15 = state == eExitSave && !v14;
  if ( state != eExitSave || v14 )
    v15 = ((state != eOddjobSave || v14) & v13 & v12) == 0;
  if ( v15 )
  {
LABEL_23:
    v16 = v13 & v12;
    v17 = v9 & v4 & v6 & v10;
    if ( v5 == 4 )
    {
      v18 = CText::Get(&TheText, "CKP_SAV");
      CHud::SetHelpMessage("CKP_SAV", v18, 0, 0, 0, 0);
    }
    v19 = 9;
    if ( v17 )
      v19 = 8;
    if ( !v16 )
      v19 = 8;
    C_PcSave::SaveSlot(&PcSaveHelper, v19, 1);
    if ( CGenericGameStorage::ms_bFailed )
    {
      CGenericGameStorage::ms_bFailed = 0;
      MobileMenu::SaveFailed(&gMobileMenu);
    }
    C_PcSave::PopulateSlotInfo(&PcSaveHelper);
    CTimer::Resume();
    return 1;
  }
  else
  {
LABEL_32:
    CTimer::Resume();
    return 0;
  }
}

//----- (005E4DB0) --------------------------------------------------------
bool IsSaveGameForPause()
{
  return sub_195CD0(9, 0);
}

//----- (005E4DB8) --------------------------------------------------------
int PlayerDrivingCar()
{
  return 0;
}

//----- (005E4DBC) --------------------------------------------------------
int IsCarTurret()
{
  return 0;
}

//----- (005E4DC0) --------------------------------------------------------
void __fastcall CJoySticks::CJoySticks(CJoySticks *this)
{
  this->JoyStickNum[0].bZRotPresent = 0;
  *(_WORD *)&this->JoyStickNum[0].bJoyAttachedToPort = 0;
  this->JoyStickNum[0].wDeviceID = 0;
  this->JoyStickNum[1].bZRotPresent = 0;
  *(_WORD *)&this->JoyStickNum[1].bJoyAttachedToPort = 0;
  this->JoyStickNum[1].wDeviceID = 0;
}

//----- (005E4DD0) --------------------------------------------------------
void __fastcall CJoySticks::ClearJoyInfo(CJoySticks *this, int JoyNumber)
{
  JoyStruct *v2; // r0

  this->JoyStickNum[JoyNumber].wDeviceID = 0;
  v2 = &this->JoyStickNum[JoyNumber];
  v2->bZRotPresent = 0;
  *(_WORD *)&v2->bJoyAttachedToPort = 0;
}

//----- (005E4DE4) --------------------------------------------------------
RwBool __fastcall psCameraBeginUpdate(RwCamera_0 *pCamera)
{
  if ( RwCameraBeginUpdate(Scene.camera) )
    return 1;
  RsEventHandler(rsACTIVATE, 0);
  return 0;
}

//----- (005E4E10) --------------------------------------------------------
void __fastcall psCameraShowRaster(RwCamera_0 *camera)
{
  sub_18CE04(camera, 0, 0);
}

//----- (005E4E1C) --------------------------------------------------------
RwImage_0 *__fastcall psGrabScreen(RwCamera_0 *camera)
{
  return 0;
}

//----- (005E4E24) --------------------------------------------------------
RwChar *__fastcall psPathnameCreate(const RwChar *srcBuffer)
{
  int v2; // r0
  RwChar *v3; // r0
  RwChar *v4; // r4
  _BYTE *i; // r0

  v2 = (*((int (__fastcall **)(const RwChar *))RwEngineInstance + 70))(srcBuffer);
  v3 = (RwChar *)CMemoryMgr::Malloc(v2 + 1);
  v4 = v3;
  if ( v3 )
  {
    (*((void (__fastcall **)(RwChar *, const RwChar *))RwEngineInstance + 62))(v3, srcBuffer);
    for ( i = (_BYTE *)(*((int (__fastcall **)(RwChar *, int))RwEngineInstance + 67))(v4, 47);
          i;
          i = (_BYTE *)(*((int (__fastcall **)(RwChar *, int))RwEngineInstance + 67))(v4, 47) )
    {
      *i = 92;
    }
  }
  return v4;
}

//----- (005E4E98) --------------------------------------------------------
void __fastcall psPathnameDestroy(RwChar *buffer)
{
  if ( buffer )
    (*((void (**)(void))RwEngineInstance + 76))();
}

//----- (005E4EB0) --------------------------------------------------------
int psPathGetSeparator()
{
  return 92;
}

//----- (005E4EB4) --------------------------------------------------------
RwMemoryFunctions_0 *psGetMemoryFunctions()
{
  return &psGetMemoryFunctions(void)::memFuncs;
}

//----- (005E4EC0) --------------------------------------------------------
RwBool psInstallFileSystem()
{
  return 1;
}

//----- (005E4EC4) --------------------------------------------------------
RwBool psNativeTextureSupport()
{
  return 1;
}

//----- (005E4ECC) --------------------------------------------------------
RwBool psInitialize()
{
  __int64 v0; // r0

  RsGlobal.ps = &PsGlobal;
  PsGlobal.fullScreen = 0;
  PsGlobal.lastMousePos.x = 0.0;
  PsGlobal.lastMousePos.y = 0.0;
  LODWORD(v0) = OS_LanguageUserSelected();
  if ( ForceGermanBuild )
    LODWORD(v0) = 8;
  HIDWORD(v0) = 4;
  switch ( (int)v0 )
  {
    case 4:
    case 5:
      break;
    case 6:
    case 7:
      HIDWORD(v0) = 1;
      break;
    case 8:
      HIDWORD(v0) = 2;
      break;
    case 10:
      HIDWORD(v0) = 3;
      break;
    case 11:
      HIDWORD(v0) = 5;
      break;
    case 14:
      HIDWORD(v0) = 6;
      break;
    default:
      HIDWORD(v0) = 0;
      break;
  }
  FrontEndMenuManager.m_PrefsLanguage = BYTE4(v0);
  *(_QWORD *)&FrontEndMenuManager.OS_Language = v0;
  MobileSettings::settings[17].value = BYTE4(v0);
  CText::Unload(&TheText, 0);
  CText::Load(&TheText, 0);
  gGameState = 0;
  Menu_LoadSettings();
  LoadTelemetry();
  InitProfileData();
  EnterGameFromSCFunc = EnterGameFromSC;
  CText::Unload(&TheText, 0);
  return 1;
}

//----- (005E4FB0) --------------------------------------------------------
void InitialiseLanguage()
{
  __int64 v0; // r0

  LODWORD(v0) = OS_LanguageUserSelected();
  if ( ForceGermanBuild )
    LODWORD(v0) = 8;
  HIDWORD(v0) = 4;
  switch ( (int)v0 )
  {
    case 4:
    case 5:
      break;
    case 6:
    case 7:
      HIDWORD(v0) = 1;
      break;
    case 8:
      HIDWORD(v0) = 2;
      break;
    case 10:
      HIDWORD(v0) = 3;
      break;
    case 11:
      HIDWORD(v0) = 5;
      break;
    case 14:
      HIDWORD(v0) = 6;
      break;
    default:
      HIDWORD(v0) = 0;
      break;
  }
  FrontEndMenuManager.m_PrefsLanguage = BYTE4(v0);
  *(_QWORD *)&FrontEndMenuManager.OS_Language = v0;
  MobileSettings::settings[17].value = BYTE4(v0);
  CText::Unload(&TheText, 0);
  sub_19FAC4(&TheText, 0);
}

//----- (005E503E) --------------------------------------------------------
RwBool __fastcall psAlwaysOnTop(RwBool alwaysOnTop)
{
  return 0;
}

//----- (005E5042) --------------------------------------------------------
int IsForegroundApp()
{
  return 1;
}

//----- (005E5048) --------------------------------------------------------
RwBool WasForegroundAppLastFrame()
{
  RwBool result; // r0

  result = WasForegroundApp;
  if ( WasForegroundApp )
    return 1;
  return result;
}

//----- (005E505C) --------------------------------------------------------
bool HasAppJustRegainedForeground()
{
  return WasForegroundApp == 0;
}

//----- (005E5074) --------------------------------------------------------
int32 __fastcall GetBestRefreshRate(uint32 width, uint32 height, uint32 depth)
{
  return 60;
}

//----- (005E5078) --------------------------------------------------------
RwSubSystemInfo_0 *GetVideoCardName()
{
  return &GsubSysInfo[GcurSel];
}

//----- (005E5098) --------------------------------------------------------
RwBool psSelectDevice()
{
  return 1;
}

//----- (005E509C) --------------------------------------------------------
void CheckAniso()
{
  AnisoAvailable = 0;
}

//----- (005E50AC) --------------------------------------------------------
void UpdateInput()
{
  sub_18E63C(1);
}

//----- (005E50B8) --------------------------------------------------------
unsigned int __fastcall MainGameFunc(void *unused)
{
  unsigned int v2; // r0
  unsigned int v3; // r5
  RwV2d_0 param[2]; // [sp+Ch] [bp-3Ch] BYREF
  int v6[11]; // [sp+1Ch] [bp-2Ch] BYREF

  v6[0] = (int)unused;
  v2 = (unsigned int)(OS_TimeAccurate() * 1234234230.0);
  if ( unused )
    v2 += (unsigned int)v6;
  srand(v2);
  param[0].x = 0.0;
  param[0].y = 0.0;
  param[1] = *(RwV2d_0 *)&RsGlobal.screenWidth;
  RsEventHandler(rsCAMERASIZE, param);
  do
  {
    RwInitialized = 1;
    param[0].x = (float)RsGlobal.screenWidth * 0.5;
    param[0].y = (float)RsGlobal.screenHeight * 0.5;
    RsMouseSetPos(param);
    while ( !RsGlobal.quit && !gMobileMenu.m_WantsToRestartGame )
    {
      MainGameFunc(void *)::lastTime = OS_TimeAccurate();
      if ( OS_SystemCheckPause(10) )
      {
        updateUsage(0);
        OS_SystemCheckPause(-1);
        updateUsage(1);
      }
      else
      {
        v3 = OS_TimeMS();
        if ( v3 - MainGameFunc(void *)::lastUsageTime >= 0x7531 )
        {
          updateUsage(0);
          MainGameFunc(void *)::lastUsageTime = v3;
        }
      }
      if ( gGameState != 9 )
        LIB_InputUpdate(1);
      LIB_PointerGetCoordinates(0, &FrontEndMenuManager.WinMousePosX, &FrontEndMenuManager.WinMousePosY, 0);
      DoGameState();
      SCCloudSaveStateUpdate();
    }
  }
  while ( DoGameRestart() );
  RsEventHandler(rsRWTERMINATE, 0);
  RsEventHandler(rsTERMINATE, 0);
  RenderQueue::Flush(renderQueue);
  RenderQueue::Kill();
  CMemoryMgr::Shutdown();
  return 0;
}

//----- (005E5280) --------------------------------------------------------
Int32 GetMobileEffectSetting()
{
  return FrontEndMenuManager.m_PrefsMobileEffects;
}

//----- (005E5290) --------------------------------------------------------
bool __fastcall OS_ApplicationInitialize(int argc, const unsigned __int8 **argv)
{
  if ( argc >= 2 )
    OS_ScreenSetResolution(0x500u, 0x2D0u);
  ForceGermanBuild = OS_ServiceAppCommand("ForceGermanBuild", (const unsigned __int8 *)&byte_61CADE);
  return 1;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (005E52D8) --------------------------------------------------------
bool __fastcall OS_ApplicationStartup(int width, int height, int argc, const unsigned __int8 **argv)
{
  bool v4; // r4
  RenderQueue *v5; // r2
  unsigned __int8 *mainWorkPointer; // r1
  RenderQueue *v7; // r4
  __int64 v8; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v10; // r2
  CMouseControllerState v12; // [sp+4h] [bp-24h] BYREF

  j_mpg123_init();
  v4 = 0;
  if ( RsEventHandler(rsINITIALIZE, 0) )
  {
    CControllerConfigManager::MakeControllerActionsBlank(&ControlsManager);
    CControllerConfigManager::InitDefaultControlConfiguration(&ControlsManager);
    CMousePointerStateHelper::GetMouseSetUp(&v12, &MousePointerStateHelper);
    if ( !FrontEndMenuManager.m_ControlMethod )
      v4 = 1;
    CControllerConfigManager::InitDefaultControlConfigMouse(&ControlsManager, &v12, v4);
    CControllerConfigManager::InitDefaultControlConfigJoyPad(&ControlsManager, 0x20u);
    OS_ThreadMakeCurrent();
    RenderQueue::Initialize();
    v5 = renderQueue;
    WaitForApplicationInit = 1;
    mainWorkPointer = renderQueue->mainWorkPointer;
    renderQueue->curQueueingCommand = rqInit;
    *(_DWORD *)mainWorkPointer = 44;
    v5->mainWorkPointer += 4;
    v7 = renderQueue;
    if ( renderQueue->useMutex )
      OS_MutexObtain(renderQueue->commandMutex);
    v8 = *(_QWORD *)&v7->mainPointer;
    p_mainPointer = (unsigned int *)&v7->mainPointer;
    __dmb(0xBu);
    do
      v10 = __ldrex(p_mainPointer);
    while ( __strex(v10 + HIDWORD(v8) - v8, p_mainPointer) );
    __dmb(0xBu);
    if ( v7->useMutex )
      OS_MutexRelease(v7->commandMutex);
    if ( !v7->multiThread )
      RenderQueue::Process(v7);
    if ( v7->mainPointer + 1024 > v7->queueEnd )
      RenderQueue::Flush(v7);
    RenderQueue::Flush(renderQueue);
    MobileSettings::SetRendererDefaults();
    if ( RsEventHandler(rsRWINITIALIZE, 0) )
    {
      return 1;
    }
    else
    {
      v4 = 0;
      RsEventHandler(rsTERMINATE, 0);
    }
  }
  return v4;
}

//----- (005E5418) --------------------------------------------------------
bool __fastcall OS_ApplicationTick(float delta)
{
  bool v1; // r4

  if ( mainThread )
  {
    if ( !OS_ThreadIsRunning(mainThread) )
    {
      OS_ThreadClose(mainThread);
      j_mpg123_exit();
      return 0;
    }
    OS_ThreadSleep(5000);
    return 1;
  }
  OS_ThreadUnmakeCurrent();
  v1 = 1;
  mainThread = OS_ThreadLaunch(MainGameFunc, 0, 1u, "MainThread", 1, 2);
  if ( !OS_ThreadIsRunning(mainThread) )
  {
    do
      OS_ThreadSleep(1000);
    while ( !OS_ThreadIsRunning(mainThread) );
    return 1;
  }
  return v1;
}

//----- (005E54B8) --------------------------------------------------------
void __fastcall OS_ApplicationEvent(OSEventType type, void *data)
{
  bool v2; // zf

  switch ( type )
  {
    case OSET_RequestExit:
      RsGlobal.quit = 1;
      sub_196804(mainThread);
      break;
    case OSET_KeyboardDown:
    case OSET_KeyboardUp:
    case OSET_PointerMove:
    case OSET_PointerButton:
    case OSET_GamepadConnection:
    case OSET_GamepadButtonDown:
    case OSET_GamepadButtonUp:
    case OSET_KeyboardSoft:
    case OSET_BillingChange:
    case OSET_GameServiceChange:
    case OSET_GameServiceSignInFailed:
    case OSET_GameServiceAchievementsReady:
    case OSET_GameServiceCloudLoadReady:
    case OSET_GameServiceCloudSaveReady:
    case OSET_GameServiceSnapshotCountLoaded:
    case OSET_GameServiceSnapshotLoading:
    case OSET_GameServiceSnapshotSelected:
      return;
    case OSET_Pause:
      SaveGameForPause(eExitSave, 0);
      CTimer::StartUserPause();
      if ( !CPad::GetPad(0)->DisablePlayerControls && !gMobileMenu.screenStack.numEntries )
      {
        v2 = (CCutsceneMgr::ms_running || CCutsceneMgr::IntroTextIsActiveHack) << 24 == 0;
        if ( !((CCutsceneMgr::ms_running || CCutsceneMgr::IntroTextIsActiveHack) << 24) )
          v2 = gMobileMenu.pendingScreen == 0;
        if ( v2 && !CTouchInterface::AnyWidgetsUsingAltBack() )
        {
          if ( FindPlayerPed(-1) )
            bPendingPause = 1;
        }
      }
      sub_19DCD0(&AEAudioHardware, 1);
      break;
    case OSET_Resume:
      OS_ThreadUnmakeCurrent();
      CTimer::Update();
      if ( !gMobileMenu.screenStack.numEntries && !gMobileMenu.pendingScreen )
        CTimer::EndUserPause();
      sub_19DCD0(&AEAudioHardware, 0);
      break;
    case OSET_LowMemory:
      DoLowMemoryCleanup = 1;
      break;
  }
}

//----- (005E55C8) --------------------------------------------------------
bool __fastcall DoesPadHaveInput(int padID)
{
  bool v2; // r5

  v2 = 0;
  if ( OS_GamepadIsConnected(padID, 0) )
  {
    if ( OS_GamepadButton(padID, 0) )
      return 1;
    v2 = 1;
    if ( !OS_GamepadButton(padID, 1u) )
      return OS_GamepadButton(padID, 2u)
          || OS_GamepadButton(padID, 3u)
          || OS_GamepadButton(padID, 4u)
          || OS_GamepadButton(padID, 5u)
          || OS_GamepadButton(padID, 6u)
          || OS_GamepadButton(padID, 7u)
          || OS_GamepadButton(padID, 8u)
          || OS_GamepadButton(padID, 9u)
          || OS_GamepadButton(padID, 0xAu)
          || OS_GamepadButton(padID, 0xBu)
          || OS_GamepadButton(padID, 0xCu)
          || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(padID, 0x40u)) & 0x7FFFFFFF) > 0.4
          || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(padID, 0x41u)) & 0x7FFFFFFF) > 0.4
          || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(padID, 0x42u)) & 0x7FFFFFFF) > 0.4
          || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(padID, 0x43u)) & 0x7FFFFFFF) > 0.4
          || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(padID, 0x44u)) & 0x7FFFFFFF) > 0.4
          || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(padID, 0x45u)) & 0x7FFFFFFF) > 0.4;
  }
  return v2;
}

//----- (005E573C) --------------------------------------------------------
int __fastcall CapturePad(unsigned int padID)
{
  float v1; // r0
  unsigned int v2; // r1
  float v3; // r0
  unsigned int v4; // r1
  float v5; // r0
  unsigned int v6; // r1
  float v7; // r1
  unsigned int v8; // r0
  bool v9; // zf
  int m_NewJoyState; // r2
  _BOOL4 v11; // r0
  int v12; // r2
  _BOOL4 v13; // r0
  int v14; // r2
  _BOOL4 v15; // r0
  int v16; // r2
  _BOOL4 v17; // r0
  int v18; // r1
  int v19; // r2
  _BOOL4 v20; // r0
  int v21; // r2
  _BOOL4 v22; // r0
  int v23; // r2
  _BOOL4 v24; // r0
  int v25; // r2
  _BOOL4 v26; // r4
  _BOOL4 v27; // r0
  int v28; // r2
  float v29; // r4
  float v30; // r0
  int v31; // r1
  _BOOL4 v32; // r0
  int v33; // r2
  _BOOL4 v34; // r0
  int v35; // r2
  _BOOL4 v36; // r0
  int v37; // r2
  _BOOL4 v38; // r0
  int v39; // r2
  _BOOL4 v40; // r0
  int v41; // r2
  _BOOL4 v42; // r0
  int v43; // r2
  int32 v44; // r0
  CPad *Pad; // r0
  int *v46; // r3
  unsigned int v47; // r1
  float x; // s2
  float v49; // s4
  float v50; // s0
  float y; // s2
  float v52; // s2
  float v53; // s2
  OSGamepadType v55; // [sp+0h] [bp-10h] BYREF
  unsigned int param[3]; // [sp+4h] [bp-Ch] BYREF

  param[0] = padID;
  v55 = OSGT_Generic;
  if ( ControlsManager.m_bJoyJustInitialised )
  {
    ControlsManager.m_OldJoyState = 0;
    ControlsManager.m_NewJoyState = 0;
    ControlsManager.m_bJoyJustInitialised = 0;
  }
  else
  {
    ControlsManager.m_OldJoyState = ControlsManager.m_NewJoyState;
  }
  if ( OS_GamepadIsConnected(padID, &v55) )
  {
    if ( MarketingControllerEnabled )
      goto LABEL_48;
    v1 = OS_GamepadAxis(param[0], 0x40u);
    v2 = param[0];
    leftStickPos[param[0]].x = v1;
    v3 = OS_GamepadAxis(v2, 0x41u);
    v4 = param[0];
    leftStickPos[param[0]].y = v3;
    v5 = OS_GamepadAxis(v4, 0x42u);
    v6 = param[0];
    rightStickPos[param[0]].x = v5;
    v7 = OS_GamepadAxis(v6, 0x43u);
    v8 = param[0];
    v9 = param[0] == 1;
    rightStickPos[param[0]].y = v7;
    ControlsManager.m_NewJoyState = 0;
    GamepadType = v55;
    if ( v9 )
    {
      v9 = !OS_GamepadButton(1u, 0);
      m_NewJoyState = ControlsManager.m_NewJoyState;
      if ( !v9 )
        m_NewJoyState = ControlsManager.m_NewJoyState | 2;
      ControlsManager.m_NewJoyState = m_NewJoyState;
      v11 = OS_GamepadButton(param[0], 2u);
      v12 = ControlsManager.m_NewJoyState;
      if ( v11 )
        v12 = ControlsManager.m_NewJoyState | 4;
      ControlsManager.m_NewJoyState = v12;
      v13 = OS_GamepadButton(param[0], 3u);
      v14 = ControlsManager.m_NewJoyState;
      if ( v13 )
        v14 = ControlsManager.m_NewJoyState | 8;
      ControlsManager.m_NewJoyState = v14;
      ControlsManager.m_NewJoyState = OS_GamepadButton(param[0], 1u) | v14;
      v15 = OS_GamepadButton(param[0], 7u);
      v16 = ControlsManager.m_NewJoyState;
      if ( v15 )
        v16 = ControlsManager.m_NewJoyState | 0x20;
      ControlsManager.m_NewJoyState = v16;
      v17 = OS_GamepadButton(param[0], 6u);
      v18 = 16;
    }
    else
    {
      ControlsManager.m_NewJoyState |= OS_GamepadButton(v8, 1u);
      v20 = OS_GamepadButton(param[0], 0);
      v21 = ControlsManager.m_NewJoyState;
      if ( v20 )
        v21 = ControlsManager.m_NewJoyState | 2;
      ControlsManager.m_NewJoyState = v21;
      v22 = OS_GamepadButton(param[0], 2u);
      v23 = ControlsManager.m_NewJoyState;
      if ( v22 )
        v23 = ControlsManager.m_NewJoyState | 4;
      ControlsManager.m_NewJoyState = v23;
      v24 = OS_GamepadButton(param[0], 3u);
      v25 = ControlsManager.m_NewJoyState;
      if ( v24 )
        v25 = ControlsManager.m_NewJoyState | 8;
      ControlsManager.m_NewJoyState = v25;
      v26 = OS_GamepadButton(param[0], 6u);
      v27 = OS_GamepadButton(param[0], 7u);
      v28 = ControlsManager.m_NewJoyState;
      if ( v26 )
        v28 = ControlsManager.m_NewJoyState | 0x10;
      if ( v27 )
        v28 |= 0x20u;
      ControlsManager.m_NewJoyState = v28;
      v29 = OS_GamepadAxis(param[0], 0x44u);
      v30 = OS_GamepadAxis(param[0], 0x45u);
      v31 = ControlsManager.m_NewJoyState;
      if ( v29 > 0.75 )
        v31 = ControlsManager.m_NewJoyState | 0x40;
      if ( v30 > 0.75 )
        v31 |= 0x80u;
      ControlsManager.m_NewJoyState = v31;
      v32 = OS_GamepadButton(param[0], 5u);
      v33 = ControlsManager.m_NewJoyState;
      if ( v32 )
        v33 = ControlsManager.m_NewJoyState | 0x100;
      ControlsManager.m_NewJoyState = v33;
      v34 = OS_GamepadButton(param[0], 0xCu);
      v35 = ControlsManager.m_NewJoyState;
      if ( v34 )
        v35 = ControlsManager.m_NewJoyState | 0x200;
      ControlsManager.m_NewJoyState = v35;
      v36 = OS_GamepadButton(param[0], 0xDu);
      v37 = ControlsManager.m_NewJoyState;
      if ( v36 )
        v37 = ControlsManager.m_NewJoyState | 0x400;
      ControlsManager.m_NewJoyState = v37;
      v38 = OS_GamepadButton(param[0], 8u);
      v39 = ControlsManager.m_NewJoyState;
      if ( v38 )
        v39 = ControlsManager.m_NewJoyState | 0x1000;
      ControlsManager.m_NewJoyState = v39;
      v40 = OS_GamepadButton(param[0], 0xBu);
      v41 = ControlsManager.m_NewJoyState;
      if ( v40 )
        v41 = ControlsManager.m_NewJoyState | 0x2000;
      ControlsManager.m_NewJoyState = v41;
      v42 = OS_GamepadButton(param[0], 9u);
      v43 = ControlsManager.m_NewJoyState;
      if ( v42 )
        v43 = ControlsManager.m_NewJoyState | 0x4000;
      ControlsManager.m_NewJoyState = v43;
      v17 = OS_GamepadButton(param[0], 0xAu);
      v18 = 0x8000;
    }
    v19 = ControlsManager.m_NewJoyState;
    if ( v17 )
      v19 = ControlsManager.m_NewJoyState | v18;
  }
  else
  {
    v19 = 0;
    GamepadType = -1;
  }
  ControlsManager.m_NewJoyState = v19;
LABEL_48:
  if ( hackNextTick )
  {
    hackNextTick = 0;
    ControlsManager.m_NewJoyState |= 1u;
  }
  RsPadEventHandler(rsPADBUTTONUP, param);
  if ( CPad::m_bMapPadOneToPadTwo )
    param[0] = 1;
  RsPadEventHandler(rsPADBUTTONUP, param);
  RsPadEventHandler(rsPADBUTTONDOWN, param);
  if ( CPad::m_bMapPadOneToPadTwo )
  {
    v44 = 1;
    param[0] = 1;
  }
  else
  {
    v44 = param[0];
  }
  Pad = CPad::GetPad(v44);
  v46 = dword_5E5B60;
  v47 = param[0];
  x = leftStickPos[param[0]].x;
  v49 = fabsf(x);
  if ( v55 == OSGT_Xbox360 )
    v46 = &dword_5E5B60[1];
  v50 = *(float *)v46;
  if ( v49 > *(float *)v46 )
    Pad->PCTempJoyState.LeftStickX = (int)(float)(x * 128.0);
  y = leftStickPos[v47].y;
  if ( fabsf(y) > v50 )
    Pad->PCTempJoyState.LeftStickY = (int)(float)(y * 128.0);
  v52 = rightStickPos[v47].x;
  if ( fabsf(v52) > v50 )
    Pad->PCTempJoyState.RightStickX = (int)(float)(v52 * 128.0);
  v53 = rightStickPos[v47].y;
  if ( fabsf(v53) > v50 )
    Pad->PCTempJoyState.RightStickY = (int)(float)(v53 * -128.0);
  return 1;
}
// 5E5B60: using guessed type int dword_5E5B60[2];

//----- (005E5B7C) --------------------------------------------------------
OSKeyboardKey __fastcall RsKeyToOSWKey(RsKeyCodes_0 code)
{
  __int32 v1; // r1
  OSKeyboardKey result; // r0

  v1 = code - 34;
  result = KK_A;
  switch ( v1 )
  {
    case 0:
    case 5:
      result = KK_APOSTROPHE;
      break;
    case 9:
    case 27:
      result = KK_EQUALS;
      break;
    case 10:
    case 26:
      result = KK_COMMA;
      break;
    case 11:
    case 61:
      result = KK_MINUS;
      break;
    case 12:
    case 28:
      result = KK_PERIOD;
      break;
    case 13:
    case 29:
      result = KK_BACKSLASH;
      break;
    case 14:
      result = KK_0;
      break;
    case 15:
      result = KK_1;
      break;
    case 16:
      result = KK_2;
      break;
    case 17:
      result = KK_3;
      break;
    case 18:
      result = KK_4;
      break;
    case 19:
      result = KK_5;
      break;
    case 20:
      result = KK_6;
      break;
    case 21:
      result = KK_7;
      break;
    case 22:
      result = KK_8;
      break;
    case 23:
      result = KK_9;
      break;
    case 24:
    case 25:
      result = KK_SEMICOLON;
      break;
    case 31:
    case 63:
      return result;
    case 32:
    case 64:
      result = KK_B;
      break;
    case 33:
    case 65:
      result = KK_C;
      break;
    case 34:
    case 66:
      result = KK_D;
      break;
    case 35:
    case 67:
      result = KK_E;
      break;
    case 36:
    case 68:
      result = KK_F;
      break;
    case 37:
    case 69:
      result = KK_G;
      break;
    case 38:
    case 70:
      result = KK_H;
      break;
    case 39:
    case 71:
      result = KK_I;
      break;
    case 40:
    case 72:
      result = KK_J;
      break;
    case 41:
    case 73:
      result = KK_K;
      break;
    case 42:
    case 74:
      result = KK_L;
      break;
    case 43:
    case 75:
      result = KK_M;
      break;
    case 44:
    case 76:
      result = KK_N;
      break;
    case 45:
    case 77:
      result = KK_O;
      break;
    case 46:
    case 78:
      result = KK_P;
      break;
    case 47:
    case 79:
      result = KK_Q;
      break;
    case 48:
    case 80:
      result = KK_R;
      break;
    case 49:
    case 81:
      result = KK_S;
      break;
    case 50:
    case 82:
      result = KK_T;
      break;
    case 51:
    case 83:
      result = KK_U;
      break;
    case 52:
    case 84:
      result = KK_V;
      break;
    case 53:
    case 85:
      result = KK_W;
      break;
    case 54:
    case 86:
      result = KK_X;
      break;
    case 55:
    case 87:
      result = KK_Y;
      break;
    case 56:
    case 88:
      result = KK_Z;
      break;
    case 57:
    case 89:
      result = KK_LEFTBRACKET;
      break;
    case 58:
    case 90:
      result = KK_FORWARDSLASH;
      break;
    case 59:
    case 91:
      result = KK_RIGHTBRACKET;
      break;
    case 62:
    case 92:
      result = KK_TILDE;
      break;
    case 966:
      result = KK_ESCAPE;
      break;
    case 979:
      result = KK_INSERT;
      break;
    case 980:
      result = KK_DELETE;
      break;
    case 981:
      result = KK_HOME;
      break;
    case 982:
      result = KK_END;
      break;
    case 983:
      result = KK_PAGEUP;
      break;
    case 984:
      result = KK_PAGEDOWN;
      break;
    case 985:
      result = KK_ARROWUP;
      break;
    case 986:
      result = KK_ARROWDOWN;
      break;
    case 987:
      result = KK_ARROWLEFT;
      break;
    case 988:
      result = KK_ARROWRIGHT;
      break;
    case 989:
    case 999:
    case 1006:
    case 1007:
      result = KK_NPDIVIDE;
      break;
    case 990:
      result = KK_NPMULTIPLY;
      break;
    case 991:
      result = KK_PLUS;
      break;
    case 992:
      result = KK_NPMINUS;
      break;
    case 993:
      result = KK_NPPERIOD;
      break;
    case 994:
      result = KK_NP1;
      break;
    case 995:
      result = KK_NP2;
      break;
    case 996:
      result = KK_NP3;
      break;
    case 997:
      result = KK_NP4;
      break;
    case 998:
      result = KK_NP5;
      break;
    case 1000:
      result = KK_NP6;
      break;
    case 1001:
      result = KK_NP7;
      break;
    case 1002:
      result = KK_NP8;
      break;
    case 1003:
      result = KK_NP9;
      break;
    case 1004:
      result = KK_NP0;
      break;
    case 1005:
      result = KK_ENTER;
      break;
    case 1008:
      result = KK_BACKSPACE;
      break;
    case 1009:
      result = KK_TAB;
      break;
    case 1010:
      result = KK_CAPSLOCK;
      break;
    case 1011:
      result = KK_ENTER;
      break;
    case 1012:
    case 1014:
      result = KK_LEFTSHIFT;
      break;
    case 1013:
      result = KK_RIGHTSHIFT;
      break;
    case 1015:
      result = KK_LEFTCONTROL;
      break;
    case 1016:
      result = KK_RIGHTCONTROL;
      break;
    case 1017:
      result = KK_LEFTALT;
      break;
    case 1018:
      result = KK_RIGHTALT;
      break;
    default:
      result = KK_MAX;
      break;
  }
  return result;
}

//----- (005E64D8) --------------------------------------------------------
void test()
{
  void (__fastcall **v0)(double *, const char *); // r2
  double v1[2]; // [sp+0h] [bp-20h] BYREF

  v0 = (void (__fastcall **)(double *, const char *))RwEngineInstance;
  strcpy((char *)((unsigned int)v1 | 7), " a test");
  v1[0] = *(double *)"This is a test";
  v0[68](v1, "This is a test");
}

//----- (005E653C) --------------------------------------------------------
void SecuromDisplayInit()
{
  *(int32x4_t *)triggerDisplay = vdupq_n_s32(0x3E8u);
  *(_OWORD *)&triggerDisplay[4] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)trapDisplay = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[4] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&triggerDisplay[8] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[8] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&triggerDisplay[12] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[12] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&triggerDisplay[16] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[16] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&triggerDisplay[20] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[20] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&triggerDisplay[24] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&triggerDisplay[28] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[24] = *(_OWORD *)triggerDisplay;
  *(_OWORD *)&trapDisplay[28] = *(_OWORD *)triggerDisplay;
}

//----- (005E65CC) --------------------------------------------------------
void SecuromStateDisplay()
{
  CRGBA v0; // r0
  int v1; // r4
  CRGBA v2; // r0
  unsigned int v3; // r5
  UInt32 *v4; // r9
  int v5; // r4
  unsigned int v6; // r5
  UInt32 *v7; // r9
  GxtChar v8[256]; // [sp+8h] [bp-328h] BYREF
  CRGBA v9; // [sp+208h] [bp-128h] BYREF
  CRGBA v10; // [sp+20Ch] [bp-124h] BYREF
  unsigned __int8 s[256]; // [sp+210h] [bp-120h] BYREF

  CRGBA::CRGBA(&v10, 0xC8u, 0xC8u, 0xC8u, 0xFFu);
  CFont::SetColor(v0);
  CFont::SetFontStyle(1u);
  CFont::SetScale(0.8);
  CFont::SetEdge(2);
  v1 = 0;
  CRGBA::CRGBA(&v9, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v2);
  CFont::SetProportional(1u);
  CFont::SetWrapx(640.0);
  CFont::SetRightJustifyWrap(0.0);
  CFont::SetOrientation(1u);
  v3 = 140;
  do
  {
    if ( triggerDisplay[v1] )
    {
      sprintf(s, "Trigger: %d", v1);
      AsciiToGxtChar(s, v8);
      CFont::PrintString(30.0, (float)v3, v8);
      --triggerDisplay[v1];
    }
    v4 = &triggerDisplay[v1];
    if ( v4[16] )
    {
      sprintf(s, "Trigger: %d", v1 + 16);
      AsciiToGxtChar(s, v8);
      CFont::PrintString(160.0, (float)v3, v8);
      --v4[16];
    }
    ++v1;
    v3 += 12;
  }
  while ( v1 != 16 );
  v5 = 0;
  v6 = 140;
  do
  {
    if ( trapDisplay[v5] )
    {
      sprintf(s, "Trap: %d", v5);
      AsciiToGxtChar(s, v8);
      CFont::PrintString(350.0, (float)v6, v8);
      --trapDisplay[v5];
    }
    v7 = &trapDisplay[v5];
    if ( v7[16] )
    {
      sprintf(s, "Trap: %d", v5 + 16);
      AsciiToGxtChar(s, v8);
      CFont::PrintString(450.0, (float)v6, v8);
      --v7[16];
    }
    ++v5;
    v6 += 12;
  }
  while ( v5 != 16 );
}
// 5E65F2: variable 'v0' is possibly undefined
// 5E661E: variable 'v2' is possibly undefined
// 5E65CC: using guessed type GxtChar var_328[256];

//----- (005E67E0) --------------------------------------------------------
double __fastcall frexp(double x, int *e)
{
  double v3; // d0
  int v4; // r2
  int v5; // r0

  v3 = x;
  v4 = (HIDWORD(x) >> 20) & 0x7FF;
  if ( v4 != 2047 )
  {
    if ( v4 )
    {
      *e = ((HIDWORD(x) >> 20) & 0x7FF) - 1022;
      LODWORD(v3) = LODWORD(x);
      HIDWORD(v3) = HIDWORD(x) & 0x800FFFFF | 0x3FE00000;
    }
    else
    {
      if ( x == 0.0 )
      {
        v5 = 0;
      }
      else
      {
        v3 = frexp(x * 1.84467441e19, e);
        v5 = *e - 64;
      }
      *e = v5;
    }
  }
  return v3;
}

//----- (005E6850) --------------------------------------------------------
int printf(const unsigned __int8 *fmt, ...)
{
  va_list va; // [sp+14h] [bp-Ch] BYREF

  va_start(va, fmt);
  return vfprintf((FILE *)&_sF + 1, fmt, va);
}

//----- (005E68AC) --------------------------------------------------------
size_t snprintf(unsigned __int8 *s, size_t n, const unsigned __int8 *fmt, ...)
{
  va_list va; // [sp+14h] [bp-4h] BYREF

  va_start(va, fmt);
  return vsnprintf(s, n, fmt, va);
}

//----- (005E68F8) --------------------------------------------------------
size_t sprintf(unsigned __int8 *s, const unsigned __int8 *fmt, ...)
{
  va_list va; // [sp+10h] [bp-8h] BYREF

  va_start(va, fmt);
  return vsprintf(s, fmt, va);
}

//----- (005E6944) --------------------------------------------------------
size_t __fastcall vsprintf(unsigned __int8 *s, const unsigned __int8 *fmt, va_list_0 ap)
{
  return vsnprintf(s, 0x7FFFFFFFu, fmt, ap);
}

//----- (005E6950) --------------------------------------------------------
int __fastcall vfprintf(FILE *f, const unsigned __int8 *fmt, va_list_0 ap)
{
  va_list_0 apa; // [sp+8h] [bp-A8h] BYREF
  void *v7; // [sp+Ch] [bp-A4h]
  FakeFILE file; // [sp+10h] [bp-A0h] BYREF
  arg nl_arg; // [sp+20h] [bp-90h] BYREF
  int nl_type[11]; // [sp+70h] [bp-40h] BYREF

  v7 = ap.__ap;
  memset(nl_type, 0, 0x28u);
  fake_file_init_file(&file, f);
  apa.__ap = v7;
  if ( printf_core(0, fmt, &apa, &nl_arg, nl_type) < 0 )
    return -1;
  apa.__ap = v7;
  return printf_core(&file, fmt, &apa, &nl_arg, nl_type);
}
// 5E6950: using guessed type int var_40[11];

//----- (005E69D0) --------------------------------------------------------
int __fastcall printf_core(FakeFILE *f, const unsigned __int8 *fmt, va_list_0 *ap, arg *nl_arg, int *nl_type)
{
  int v6; // r10
  signed int v7; // r5
  unsigned int v8; // r1
  const unsigned __int8 *v9; // r2
  size_t v10; // r0
  int v11; // t1
  int v12; // r0
  size_t *v13; // r2
  int v14; // r4
  int v15; // r1
  int v16; // r9
  uintmax_t v17; // r0
  int v18; // r3
  char *v19; // r0
  wchar_t *v20; // r6
  double v21; // d15
  char *v22; // r11
  double v23; // r0
  double v24; // d15
  char v25; // r5
  double v26; // d0
  size_t v27; // r0
  size_t v28; // r11
  FakeFILE *v29; // r6
  int v30; // r4
  const unsigned __int8 *v31; // r1
  size_t v32; // r0
  int v33; // r5
  int v34; // r0
  size_t v35; // r3
  unsigned __int8 *v36; // r1
  const unsigned __int8 *v37; // r11
  unsigned __int8 *v38; // r0
  int v39; // r5
  int *v40; // r0
  arg v41; // r0
  char *v42; // r2
  int v43; // r3
  unsigned __int64 v44; // r4
  int v45; // r12
  size_t v46; // r0
  unsigned int v47; // r0
  unsigned int v48; // r1
  char v49; // r3
  char *v50; // r2
  int v51; // r6
  int v52; // r5
  size_t v53; // r4
  char *v54; // r1
  unsigned int *v55; // r11
  unsigned int v56; // r0
  unsigned __int8 *v57; // r3
  unsigned __int64 v58; // r0
  size_t v59; // r11
  int *v60; // r6
  int v61; // r1
  size_t v62; // r4
  unsigned int v63; // r3
  unsigned __int64 v64; // r0
  unsigned __int64 v65; // r2
  size_t v66; // r2
  size_t v67; // r4
  int v68; // r12
  int v69; // r2
  unsigned __int8 *v70; // r1
  unsigned int v71; // r6
  unsigned int v72; // r0
  size_t v73; // r0
  unsigned __int8 *v74; // r4
  int v75; // r11
  int v76; // r1
  int v77; // r2
  size_t v78; // r0
  signed int v79; // r0
  int v80; // r0
  size_t v81; // r1
  int v82; // r0
  int v83; // r0
  unsigned int v84; // r5
  unsigned __int8 *v85; // r0
  int p; // lr
  int v87; // r6
  int v88; // r0
  unsigned __int8 *v89; // r4
  unsigned __int8 *v90; // lr
  size_t v91; // lr
  int v92; // r2
  unsigned __int8 *v93; // r0
  unsigned __int8 *v94; // r4
  int v95; // r3
  size_t v96; // r5
  _BOOL4 v97; // r0
  size_t v98; // r0
  size_t v99; // r6
  FakeFILE *v100; // r11
  size_t v101; // r6
  unsigned __int8 *v102; // r0
  FakeFILE *v103; // r0
  bool v104; // zf
  unsigned __int8 *v105; // r6
  size_t v106; // r1
  bool v107; // cc
  int v108; // r0
  int v109; // r0
  signed int v110; // r0
  unsigned __int8 *v111; // r1
  size_t v112; // r6
  int v113; // r2
  unsigned int v114; // r2
  int v115; // r5
  int v116; // r0
  int v117; // r5
  int v118; // r2
  int v119; // r0
  unsigned __int8 *v120; // r0
  unsigned __int8 *v121; // r3
  unsigned __int8 *v122; // r0
  int v123; // r1
  unsigned __int8 *v124; // r3
  unsigned int v125; // r0
  size_t v126; // r4
  FakeFILE *v127; // r6
  size_t v128; // r0
  int v129; // r11
  unsigned __int8 *v130; // r0
  unsigned __int8 *v131; // r4
  unsigned __int8 *v132; // r11
  unsigned __int8 *v133; // r6
  size_t v134; // r0
  const unsigned __int8 *v135; // r6
  signed int v136; // r4
  size_t v137; // r2
  unsigned __int8 *v138; // r1
  unsigned __int8 *v139; // r6
  unsigned __int8 *v140; // r4
  unsigned __int8 *v141; // r11
  size_t v142; // r6
  signed int v143; // r4
  size_t v144; // r2
  signed int v145; // r0
  double v146; // d0
  int *v147; // r0
  double v148; // d1
  FakeFILE *v149; // r6
  char *v150; // r3
  signed int v151; // r0
  int v152; // r6
  FakeFILE *v153; // r4
  size_t v154; // r5
  wchar_t *v155; // r0
  signed int v156; // r6
  wchar_t *v157; // r11
  int v158; // r2
  int v159; // r4
  unsigned int v160; // r0
  unsigned int v161; // r0
  unsigned int *v162; // r0
  unsigned int v163; // r1
  int v164; // r1
  int v165; // r2
  unsigned int v166; // r6
  FakeFILE *v167; // r6
  int v168; // r0
  unsigned __int8 v169; // r0
  unsigned __int8 v170; // t1
  const unsigned __int8 *v171; // r0
  int v172; // t1
  const unsigned __int8 *v173; // r1
  int v174; // r2
  int v175; // r12
  int v176; // r2
  bool v177; // zf
  int v178; // r0
  char v179; // r3
  char v180; // r3
  int v181; // t1
  unsigned int v182; // r2
  int v183; // r0
  unsigned int v184; // r2
  int v185; // t1
  int *v186; // r1
  int v187; // r1
  unsigned int v188; // r2
  int v189; // r1
  int v190; // r1
  int v191; // r6
  unsigned int v192; // r1
  int v193; // r5
  va_list_0 *v194; // r6
  arg *v195; // r4
  int v196; // r1
  int v197; // r0
  int v199; // [sp+0h] [bp-320h] BYREF
  unsigned int v200; // [sp+8h] [bp-318h]
  size_t v201; // [sp+Ch] [bp-314h]
  unsigned __int8 *v202; // [sp+10h] [bp-310h]
  unsigned int v203; // [sp+14h] [bp-30Ch]
  unsigned __int8 *text; // [sp+18h] [bp-308h]
  int v205; // [sp+1Ch] [bp-304h]
  int v206; // [sp+20h] [bp-300h]
  size_t length; // [sp+24h] [bp-2FCh]
  int v208; // [sp+28h] [bp-2F8h]
  unsigned __int8 *v209; // [sp+2Ch] [bp-2F4h]
  unsigned __int8 *v210; // [sp+30h] [bp-2F0h]
  size_t v211; // [sp+34h] [bp-2ECh]
  size_t v212; // [sp+38h] [bp-2E8h]
  char *v213; // [sp+3Ch] [bp-2E4h]
  int v214; // [sp+40h] [bp-2E0h]
  char *v215; // [sp+44h] [bp-2DCh]
  int v216; // [sp+48h] [bp-2D8h]
  unsigned __int8 *v217; // [sp+4Ch] [bp-2D4h]
  unsigned __int8 *v218; // [sp+50h] [bp-2D0h]
  unsigned __int8 *v219; // [sp+54h] [bp-2CCh]
  size_t v220; // [sp+58h] [bp-2C8h]
  unsigned __int8 *v221; // [sp+5Ch] [bp-2C4h]
  arg *v222; // [sp+60h] [bp-2C0h]
  va_list_0 *v223; // [sp+64h] [bp-2BCh]
  int v224; // [sp+68h] [bp-2B8h]
  FakeFILE *file; // [sp+6Ch] [bp-2B4h]
  arg arg; // [sp+70h] [bp-2B0h] BYREF
  int e; // [sp+7Ch] [bp-2A4h] BYREF
  unsigned __int8 v228[4]; // [sp+80h] [bp-2A0h] BYREF
  int v229[2]; // [sp+84h] [bp-29Ch] BYREF
  char f_low; // [sp+B3h] [bp-26Dh] BYREF
  char v231; // [sp+B4h] [bp-26Ch] BYREF
  char v232; // [sp+BFh] [bp-261h] BYREF
  unsigned __int8 v233[8]; // [sp+C0h] [bp-260h] BYREF
  char v234; // [sp+C8h] [bp-258h] BYREF
  _BYTE v235[3]; // [sp+C9h] [bp-257h] BYREF
  char v236; // [sp+DCh] [bp-244h] BYREF
  int v237; // [sp+1E4h] [bp-13Ch] BYREF

  v222 = nl_arg;
  v223 = ap;
  file = f;
  v6 = 0;
  v7 = 0;
  v214 = -194 - (_DWORD)&v199;
  v219 = (unsigned __int8 *)&v234;
  v221 = v235;
  v217 = v233;
  v216 = -(int)v233;
  v218 = (unsigned __int8 *)&v231;
  v213 = &v232;
  v215 = &f_low;
  v224 = 0;
LABEL_334:
  v167 = file;
  while ( 1 )
  {
    v37 = fmt;
    if ( v6 >= 0 )
    {
      v168 = 0x7FFFFFFF - v6;
      if ( v7 <= 0x7FFFFFFF - v6 )
      {
        v6 += v7;
      }
      else
      {
        v6 = -1;
        *(_DWORD *)_errno(v168) = 75;
      }
    }
    v169 = *fmt;
    if ( !*fmt )
      break;
    while ( 1 )
    {
      if ( !v169 )
      {
        v171 = fmt;
        goto LABEL_349;
      }
      if ( v169 == 37 )
        break;
      v170 = *++fmt;
      v169 = v170;
    }
    v171 = fmt;
    do
    {
      if ( fmt[1] != 37 )
        break;
      v172 = fmt[2];
      fmt += 2;
      ++v171;
    }
    while ( v172 == 37 );
LABEL_349:
    v7 = v171 - v37;
    if ( v167 )
      fake_file_out(v167, v37, v7);
    if ( !v7 )
    {
      v173 = fmt + 1;
      v174 = fmt[1];
      v175 = v174 - 48;
      if ( (unsigned int)(v174 - 48) > 9 )
      {
        v175 = -1;
      }
      else
      {
        v176 = fmt[2];
        v177 = v176 == 36;
        if ( v176 == 36 )
          v173 = fmt + 3;
        else
          v175 = -1;
        v178 = v224;
        v174 = *v173;
        if ( v177 )
          v178 = 1;
        v224 = v178;
      }
      v179 = v174 - 32;
      v16 = 0;
      if ( (unsigned int)(v174 - 32) <= 0x1F )
      {
        do
        {
          if ( ((1 << v179) & ((unsigned int)&elf_hash_chain[2504] + 1)) == 0 )
            break;
          v180 = v174 - 32;
          v181 = *++v173;
          LOBYTE(v174) = v181;
          v16 |= 1 << v180;
          v179 = v181 - 32;
        }
        while ( (unsigned int)(v181 - 32) < 0x20 );
      }
      if ( (unsigned __int8)v174 != 42 )
      {
        v184 = (unsigned __int8)v174 - 48;
        p = 0;
        fmt = v173;
        if ( v184 > 9 )
          goto LABEL_378;
        do
        {
          v185 = *++fmt;
          p = v184 + 10 * p;
          v184 = v185 - 48;
        }
        while ( (unsigned int)(v185 - 48) < 0xA );
        if ( p >= 0 )
          goto LABEL_378;
        return -1;
      }
      fmt = v173 + 1;
      v182 = v173[1] - 48;
      if ( v182 <= 9 && v173[2] == 36 )
      {
        fmt = v173 + 3;
        nl_type[v182] = 10;
        p = (int)v222[v173[1] - 48].p;
        v183 = 1;
LABEL_374:
        v224 = v183;
        if ( p <= -1 )
        {
          p = -p;
          v16 |= 0x2000u;
        }
        goto LABEL_378;
      }
      if ( v224 )
        return -1;
      if ( v167 )
      {
        v183 = 0;
        v186 = (int *)v223->__ap;
        v223->__ap = (char *)v223->__ap + 4;
        p = *v186;
        goto LABEL_374;
      }
      p = 0;
      v224 = 0;
LABEL_378:
      if ( *fmt != 46 )
      {
        v10 = -1;
        goto LABEL_384;
      }
      v187 = fmt[1];
      if ( v187 != 42 )
      {
        v8 = v187 - 48;
        if ( v8 > 9 )
        {
          v10 = 0;
          ++fmt;
        }
        else
        {
          v9 = fmt + 2;
          v10 = 0;
          do
          {
            v11 = *v9++;
            v10 = v8 + 10 * v10;
            v8 = v11 - 48;
          }
          while ( (unsigned int)(v11 - 48) < 0xA );
          fmt = v9 - 1;
        }
        goto LABEL_384;
      }
      v188 = fmt[2] - 48;
      if ( v188 > 9 || fmt[3] != 36 )
      {
        if ( !v224 )
        {
          if ( v167 )
          {
            fmt += 2;
            v13 = (size_t *)v223->__ap;
            v223->__ap = (char *)v223->__ap + 4;
            v10 = *v13;
          }
          else
          {
            v10 = 0;
            fmt += 2;
          }
          goto LABEL_384;
        }
        return -1;
      }
      nl_type[v188] = 10;
      v189 = fmt[2];
      fmt += 4;
      v10 = (size_t)v222[v189 - 48].p;
LABEL_384:
      v190 = 0;
      do
      {
        v191 = v190;
        v192 = *fmt - 65;
        if ( v192 > 0x39 )
          return -1;
        ++fmt;
        v190 = states[v191][v192];
      }
      while ( (unsigned int)(v190 - 1) < 8 );
      if ( !v190 )
        return -1;
      v220 = v10;
      if ( v190 != 19 )
      {
        if ( v175 > -1 )
        {
          nl_type[v175] = v190;
          v12 = *((_DWORD *)&v222[v175].p + 1);
          arg.p = v222[v175].p;
          *((_DWORD *)&arg.p + 1) = v12;
          goto LABEL_11;
        }
        if ( file )
        {
          pop_arg(&arg, v190, v223);
          goto LABEL_19;
        }
        return 0;
      }
      if ( v175 > -1 )
        return -1;
LABEL_11:
      v7 = 0;
      if ( file )
      {
LABEL_19:
        v14 = v16 & 0xFFFEFFFF;
        v15 = *(fmt - 1);
        if ( (*(fmt - 1) & 0xF) == 3 )
          v15 &= 0xDFu;
        if ( !v191 )
          v15 = *(fmt - 1);
        if ( (v16 & 0x2000) != 0 )
          v16 &= ~0x10000u;
        v209 = (unsigned __int8 *)v15;
        if ( v15 > 82 )
        {
          v7 = 0;
          switch ( v15 )
          {
            case 'S':
              if ( v220 )
              {
                v20 = (wchar_t *)arg.p;
                goto LABEL_65;
              }
              v149 = file;
              v7 = 0;
              v208 = p;
              pad(file, 32, p, 0, v16);
              goto LABEL_315;
            case 'X':
            case 'x':
              goto LABEL_80;
            case 'a':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_37;
            case 'c':
              v35 = 0;
              f_low = LOBYTE(arg.f);
              v210 = "-+   0X0x";
              v36 = (_BYTE *)(&dword_0 + 1);
              v37 = (const unsigned __int8 *)v215;
              v16 = v14;
              v38 = v218;
              goto LABEL_302;
            case 'd':
            case 'i':
              HIDWORD(v17) = *((_DWORD *)&arg.p + 1);
              v18 = (int)arg.p;
              v208 = p;
              if ( *((int *)&arg.p + 1) <= -1 )
              {
                v18 = -(int)arg.p;
                HIDWORD(v17) = -arg.i >> 32;
                arg.i = -arg.i;
                LODWORD(v17) = 1;
LABEL_157:
                v212 = v17;
                v19 = "-+   0X0x";
                goto LABEL_158;
              }
              if ( (v16 & 0x800) == 0 )
              {
                v212 = v16 & 1;
                v19 = "-+   0X0x";
                if ( (v16 & 1) != 0 )
                  v19 = "   0X0x";
LABEL_158:
                v210 = (unsigned __int8 *)v19;
                goto LABEL_161;
              }
              v210 = (unsigned __int8 *)"+   0X0x";
              v212 = 1;
LABEL_161:
              LODWORD(v17) = v18;
              v44 = __PAIR64__(HIDWORD(v17), v18);
              v85 = fmt_u(v17, v218);
              p = v208;
              v45 = HIDWORD(v44);
              v35 = v212;
              v37 = v85;
LABEL_294:
              if ( (int)v220 > -1 )
                v16 &= ~0x10000u;
              if ( v220 || (unsigned int)v44 | v45 )
              {
                v36 = (unsigned __int8 *)v220;
                if ( (int)v220 <= v218 - v37 + (((unsigned int)v44 | v45) == 0) )
                  v36 = (unsigned __int8 *)(v218 - v37 + (((unsigned int)v44 | v45) == 0));
                v38 = v218;
              }
              else
              {
                v38 = v218;
                v36 = 0;
                v37 = v218;
              }
              break;
            case 'm':
              v39 = v14;
              v208 = p;
              v40 = (int *)_errno(v15 - 83);
              v37 = (const unsigned __int8 *)strerror(*v40);
              goto LABEL_89;
            case 'n':
              goto LABEL_334;
            case 'o':
              v41.i = arg.i;
              if ( arg.i )
              {
                v42 = v215;
                do
                {
                  *v42-- = LOBYTE(v41.f) & 7 | 0x30;
                  v41.p = (void *)((__int64)v41.i >> 3);
                  v43 = (int)v41.p | (*((_DWORD *)&v41.p + 1) >> 3);
                  *((_DWORD *)&v41.p + 1) >>= 3;
                }
                while ( v43 );
                v45 = *((_DWORD *)&arg.p + 1);
                LODWORD(v44) = arg.p;
                v37 = (const unsigned __int8 *)(v42 + 1);
              }
              else
              {
                LODWORD(v44) = 0;
                v45 = 0;
                v37 = v218;
              }
              v150 = "-+   0X0x";
              if ( (unsigned int)v44 | v45 )
                v150 = "0X0x";
              if ( (v16 & 8) == 0 )
                v150 = "-+   0X0x";
              v210 = (unsigned __int8 *)v150;
              v35 = (((unsigned int)v44 | v45) != 0) & ((unsigned __int8)(v16 & 8) >> 3);
              goto LABEL_294;
            case 'p':
              v46 = v220;
              v16 |= 8u;
              if ( v220 <= 8 )
                v46 = 8;
              v220 = v46;
              v209 = (unsigned __int8 *)&dword_78;
LABEL_80:
              v47 = *((_DWORD *)&arg.p + 1);
              v48 = (unsigned int)arg.p;
              if ( arg.i )
              {
                v49 = (unsigned __int8)v209 & 0x20;
                v50 = v215;
                do
                {
                  v51 = v48 & 0xF;
                  v48 = (v48 >> 4) | (v47 << 28);
                  v52 = v48 | (v47 >> 4);
                  v47 >>= 4;
                  *v50-- = xdigits[v51] | v49;
                }
                while ( v52 );
                v45 = *((_DWORD *)&arg.p + 1);
                LODWORD(v44) = arg.p;
                v37 = (const unsigned __int8 *)(v50 + 1);
                v35 = 0;
                if ( (v16 & 8) != 0 && arg.i )
                {
                  v35 = 2;
                  v210 = (unsigned __int8 *)&a0x0x_0[(unsigned int)v209 >> 4];
                }
                else
                {
                  v210 = "-+   0X0x";
                }
              }
              else
              {
                LODWORD(v44) = 0;
                v210 = "-+   0X0x";
                v45 = 0;
                v37 = v218;
                v35 = 0;
              }
              goto LABEL_294;
            case 's':
              v37 = (const unsigned __int8 *)arg.p;
              v39 = v14;
              v208 = p;
              if ( !arg.p )
                v37 = "(null)";
LABEL_89:
              if ( (v220 & 0x80000000) != 0 )
              {
                v36 = (unsigned __int8 *)strlen((const char *)v37);
              }
              else
              {
                v53 = v220;
                v38 = (unsigned __int8 *)memchr(v37, 0, v220);
                if ( v38 )
                {
                  v36 = (unsigned __int8 *)(v38 - v37);
                  goto LABEL_206;
                }
                v36 = (unsigned __int8 *)v53;
              }
              v38 = &v36[(_DWORD)v37];
LABEL_206:
              v35 = 0;
              v210 = "-+   0X0x";
              v16 = v39;
              p = v208;
              goto LABEL_302;
            case 'u':
              v208 = p;
              LODWORD(v17) = 0;
              HIDWORD(v17) = *((_DWORD *)&arg.p + 1);
              v18 = (int)arg.p;
              goto LABEL_157;
            default:
              goto LABEL_93;
          }
          goto LABEL_302;
        }
        if ( (unsigned int)(v15 - 69) < 3 || v209 == (_BYTE *)&dword_40 + 1 )
        {
LABEL_37:
          v21 = arg.f;
          v208 = p;
          e = 0;
          if ( _signbit(arg.p, *((_DWORD *)&arg.p + 1)) )
          {
            v21 = -v21;
            v205 = 1;
            v22 = "-0X+0X 0X-0x+0x 0x";
          }
          else if ( (v16 & 0x800) != 0 )
          {
            v22 = "+0X 0X-0x+0x 0x";
            v205 = 1;
          }
          else
          {
            v22 = " 0X-0x+0x 0x";
            v205 = v16 & 1;
            if ( (v16 & 1) == 0 )
              v22 = "0X+0X 0X-0x+0x 0x";
          }
          if ( _isfinite(LODWORD(v21), HIDWORD(v21)) )
          {
            v23 = frexpl(v21, &e);
            v24 = v23 + v23;
            if ( v23 + v23 != 0.0 )
              --e;
            length = (unsigned int)v209 | 0x20;
            if ( ((unsigned int)v209 | 0x20) == 97 )
            {
              v25 = (unsigned __int8)v209 & 0x20;
              if ( ((unsigned __int8)v209 & 0x20) != 0 )
                v22 += 9;
              text = (unsigned __int8 *)v22;
              if ( v220 <= 0xB && 12 != v220 )
              {
                v26 = 8.0;
                v27 = v220 - 12;
                do
                {
                  v26 = v26 * 16.0;
                  ++v27;
                }
                while ( v27 );
                if ( *v22 == 45 )
                  v24 = -(v26 + -v24 - v26);
                else
                  v24 = v24 + v26 - v26;
              }
              v87 = e;
              v88 = e;
              if ( e < 0 )
                v88 = -e;
              v89 = v217;
              v212 = v205 | 2;
              v90 = fmt_u(v88, v217);
              if ( v90 == v89 )
              {
                v232 = 48;
                v90 = (unsigned __int8 *)v213;
              }
              *(v90 - 2) = (_BYTE)v209 + 15;
              v91 = (size_t)(v90 - 2);
              *(_BYTE *)(v91 + 1) = 2 * (v87 < 0) + 43;
              v92 = v208;
              v93 = v233;
              do
              {
                v94 = v93;
                v95 = (int)v24;
                v24 = (v24 - (double)(int)v24) * 16.0;
                *v93++ = xdigits[v95] | v25;
                if ( v93 - v233 == 1 && ((v16 & 8) != 0 || (int)v220 > 0 || v24 != 0.0) )
                {
                  v93 = v94 + 2;
                  v94[1] = 46;
                }
              }
              while ( v24 != 0.0 );
              v30 = v92;
              v199 = v16;
              v96 = v93 - v233;
              v211 = (size_t)&v217[-v91];
              length = v93 - v233;
              v210 = (unsigned __int8 *)(v220 + 2);
              v97 = (int)&v93[v214] < (int)v220 && v220 != 0;
              v104 = !v97;
              v209 = (unsigned __int8 *)v97;
              v98 = v96;
              if ( !v104 )
                v98 = v220 + 2;
              v99 = v212;
              v100 = file;
              v220 = v91;
              v7 = (signed int)&v217[v212 - v91 + v98];
              pad(file, 32, v92, v7, v199);
              fake_file_out(v100, text, v99);
              pad(v100, 48, v30, v7, v16 ^ 0x10000);
              v101 = length;
              fake_file_out(v100, v233, length);
              v199 = 0;
              v102 = v209;
              if ( v209 )
                v102 = &v210[-v101];
              pad(v100, 48, (int)v102, 0, v199);
              fake_file_out(v100, (const unsigned __int8 *)v220, v211);
              v199 = v16 ^ 0x2000;
              v103 = v100;
              goto LABEL_276;
            }
            v32 = v220;
            if ( (v220 & 0x80000000) != 0 )
              v32 = 6;
            v220 = v32;
            text = (unsigned __int8 *)v22;
            if ( v24 == 0.0 )
            {
              v33 = e;
            }
            else
            {
              v24 = v24 * 268435456.0;
              v33 = e - 28;
              e -= 28;
            }
            v54 = &v236;
            if ( v33 >= 0 )
              v54 = (char *)&v237;
            v55 = (unsigned int *)v54;
            do
            {
              v56 = (unsigned int)v24;
              v24 = (v24 - (double)(unsigned int)v24) * 1000000000.0;
              *v55++ = v56;
            }
            while ( v24 != 0.0 );
            v57 = (unsigned __int8 *)v54;
            v211 = (size_t)v54;
            if ( v33 >= 1 )
            {
              v206 = v16;
              do
              {
                HIDWORD(v58) = v55;
                v59 = (size_t)(v55 - 1);
                if ( v33 >= 29 )
                  v33 = 29;
                if ( v59 >= (unsigned int)v57 )
                {
                  LODWORD(v58) = 0;
                  v60 = (int *)v59;
                  v212 = HIDWORD(v58);
                  do
                  {
                    v61 = *v60;
                    v62 = (size_t)v57;
                    v63 = (unsigned int)*v60 >> (32 - v33);
                    if ( v33 - 32 >= 0 )
                      v63 = v61 << (v33 - 32);
                    HIDWORD(v58) = v61 << v33;
                    if ( v33 - 32 >= 0 )
                      HIDWORD(v58) = 0;
                    v64 = __PAIR64__(v63, v58) + HIDWORD(v58);
                    v65 = v64 % 0x3B9ACA00;
                    v58 = v64 / 0x3B9ACA00;
                    *v60-- = v65;
                    v57 = (unsigned __int8 *)v62;
                  }
                  while ( (unsigned int)v60 >= v62 );
                  v66 = v212;
                  if ( *(_DWORD *)(v212 - 4) )
                    v59 = v212;
                  if ( v212 > v62 )
                    v66 = v59;
                  v55 = (unsigned int *)v66;
                  if ( (_DWORD)v58 )
                  {
                    *(_DWORD *)(v62 - 4) = v58;
                    v57 = (unsigned __int8 *)(v62 - 4);
                  }
                  v16 = v206;
                }
                else
                {
                  if ( *(_DWORD *)(HIDWORD(v58) - 4) )
                    v59 = HIDWORD(v58);
                  if ( HIDWORD(v58) > (unsigned int)v57 )
                    HIDWORD(v58) = v59;
                  v55 = (unsigned int *)HIDWORD(v58);
                }
                v33 = e - v33;
                e = v33;
              }
              while ( v33 > 0 );
            }
            if ( v33 <= -1 )
            {
              v67 = (int)v220 / 9;
              v68 = (int)v220 / 9 + 2;
              v212 = (int)v220 / 9;
              do
              {
                v69 = -v33;
                if ( -v33 >= 9 )
                  v69 = 9;
                if ( v57 >= (unsigned __int8 *)v55 )
                {
                  if ( !*(_DWORD *)v57 )
                    v57 += 4;
                }
                else
                {
                  v70 = v57;
                  v71 = 0;
                  do
                  {
                    v72 = (*(_DWORD *)v70 & ((1 << v69) - 1)) * (0x3B9ACA00u >> v69);
                    *(_DWORD *)v70 = (*(_DWORD *)v70 >> v69) + v71;
                    v70 += 4;
                    v71 = v72;
                  }
                  while ( v70 < (unsigned __int8 *)v55 );
                  if ( !*(_DWORD *)v57 )
                    v57 += 4;
                  if ( v72 )
                    *v55++ = v72;
                  v67 = v212;
                }
                v33 = e + v69;
                e += v69;
                v73 = (size_t)v57;
                if ( length == 102 )
                  v73 = v211;
                if ( (int)((int)v55 - v73) >> 2 > v68 )
                  v55 = (unsigned int *)(v73 + 4 * v67 + 8);
              }
              while ( v33 < 0 );
            }
            v212 = (size_t)v55;
            if ( v57 >= (unsigned __int8 *)v55 )
            {
              v75 = 0;
              v74 = v217;
            }
            else
            {
              v74 = v217;
              v75 = 9 * ((int)(v211 - (_DWORD)v57) >> 2);
              if ( *(_DWORD *)v57 >= 0xAu )
              {
                v76 = 10;
                do
                {
                  v77 = 5 * v76;
                  ++v75;
                  v76 *= 10;
                }
                while ( *(_DWORD *)v57 >= (unsigned int)(2 * v77) );
              }
            }
            v78 = v220;
            if ( length != 102 )
              v78 = v220 - v75;
            v79 = v78 - (length == 103 && v220 != 0);
            if ( v79 < (int)(((int)(v212 - v211) >> 2) + 2 * (v212 - v211) - 9) )
            {
              v80 = v79 + 9216;
              v210 = v57;
              v81 = v211 + 4 * (v80 / 9);
              v82 = v80 % 9;
              v201 = v81;
              if ( v82 > 7 )
              {
                v84 = 10;
              }
              else
              {
                v83 = v82 - 1;
                v84 = 10;
                do
                {
                  ++v83;
                  v84 *= 10;
                }
                while ( v83 < 7 );
              }
              v202 = (unsigned __int8 *)(v81 - 4092);
              v203 = *(_DWORD *)(v81 - 4092);
              v104 = v81 - 4088 == v212;
              if ( v81 - 4088 == v212 )
                v104 = v203 % v84 == 0;
              if ( v104 )
              {
                v57 = v210;
                v105 = v202;
              }
              else
              {
                v200 = v203 % v84;
                v146 = 0.5;
                v147 = dword_5E7AF0;
                if ( !((v203 / v84) << 31) )
                  v147 = &dword_5E7AF0[2];
                if ( v200 >= (int)v84 / 2 )
                {
                  v146 = 1.5;
                  if ( !(((int)v84 / 2) ^ v200 | v212 ^ (v81 - 4088)) )
                    v146 = 1.0;
                }
                v148 = *(double *)v147;
                if ( v205 )
                {
                  v105 = v202;
                  if ( *text == 45 )
                  {
                    v146 = -v146;
                    v148 = -v148;
                  }
                }
                else
                {
                  v105 = v202;
                }
                v160 = v203 - v200;
                *(_DWORD *)v105 = v203 - v200;
                if ( v148 + v146 == v148 )
                {
                  v57 = v210;
                }
                else
                {
                  v161 = v160 + v84;
                  *(_DWORD *)v105 = v161;
                  if ( v161 > 0x3B9AC9FF )
                  {
                    v162 = (unsigned int *)(v201 - 4096);
                    do
                    {
                      v163 = *v162 + 1;
                      *v162 = v163;
                      v162[1] = 0;
                      --v162;
                    }
                    while ( v163 > 0x3B9AC9FF );
                    v105 = (unsigned __int8 *)(v162 + 1);
                  }
                  v57 = v210;
                  if ( v105 < v210 )
                    v57 = v105;
                  v75 = 9 * ((int)(v211 - (_DWORD)v57) >> 2);
                  if ( *(_DWORD *)v57 >= 0xAu )
                  {
                    v164 = 10;
                    do
                    {
                      v165 = 5 * v164;
                      ++v75;
                      v164 *= 10;
                    }
                    while ( *(_DWORD *)v57 >= (unsigned int)(2 * v165) );
                  }
                }
              }
              v106 = v212;
              if ( v212 > (unsigned int)(v105 + 4) )
                v106 = (size_t)(v105 + 4);
              v212 = v106;
              do
              {
                v107 = v212 > (unsigned int)v57;
                v108 = *(_DWORD *)(v212 - 4);
                v212 -= 4;
              }
              while ( v107 && !v108 );
              v212 += 4;
            }
            v210 = v57;
            v109 = v220;
            if ( length == 103 )
            {
              v110 = (v220 == 0) + v220;
              if ( v110 <= v75 || v75 < -4 )
              {
                v112 = v110 - 1;
                v111 = v209 - 2;
              }
              else
              {
                v111 = v209 - 1;
                v112 = v110 - 1 - v75;
              }
              v113 = v16 & 8;
              v209 = v111;
              if ( (v16 & 8) != 0 )
              {
                v109 = v112;
              }
              else
              {
                v220 = v112;
                if ( v212 > (unsigned int)v57 && (v114 = *(_DWORD *)(v212 - 4)) != 0 )
                {
                  if ( v114 % 0xA )
                  {
                    v115 = 0;
                  }
                  else
                  {
                    v166 = 10;
                    v115 = 0;
                    do
                    {
                      v166 *= 10;
                      ++v115;
                    }
                    while ( !(v114 % v166) );
                  }
                }
                else
                {
                  v115 = 9;
                }
                v113 = 0;
                v116 = 9 * ((int)(v212 - v211) >> 2) - 9;
                if ( ((unsigned int)v209 | 0x20) != 102 )
                  v116 += v75;
                v109 = v116 - v115;
                if ( v109 <= 0 )
                  v109 = 0;
                if ( (int)v220 < v109 )
                  v109 = v220;
                v74 = v217;
              }
            }
            else
            {
              v113 = v16 & 8;
            }
            v117 = v109 | v113;
            v220 = v109;
            length = v113;
            v202 = (unsigned __int8 *)(v109 | v113);
            if ( v109 | v113 )
              v117 = 1;
            v203 = (unsigned int)v209 | 0x20;
            if ( ((unsigned int)v209 | 0x20) == 102 )
            {
              if ( v75 <= 0 )
                v75 = 0;
              v118 = v208;
              v209 = 0;
            }
            else
            {
              v119 = v75;
              if ( v75 < 0 )
                v119 = -v75;
              v120 = fmt_u(v119, v74);
              v118 = v208;
              v121 = v120;
              if ( v74 - v120 <= 1 )
              {
                v122 = v120 - 1;
                do
                {
                  v123 = v74 - v122;
                  *v122-- = 48;
                }
                while ( v123 < 2 );
                v121 = v122 + 1;
              }
              *(v121 - 2) = (unsigned __int8)v209;
              v124 = v121 - 2;
              v125 = (unsigned int)v75 >> 31;
              v75 = v74 - v124;
              v124[1] = 2 * v125 + 43;
              v209 = v124;
            }
            v126 = v205;
            v127 = file;
            v128 = v220 + v205 + v117 + v75;
            v129 = v118;
            v7 = v128 + 1;
            pad(file, 32, v118, v128 + 1, v16);
            fake_file_out(v127, text, v126);
            pad(v127, 48, v129, v7, v16 ^ 0x10000);
            if ( v203 == 102 )
            {
              v130 = v210;
              if ( (unsigned int)v210 > v211 )
                v130 = (unsigned __int8 *)v211;
              v131 = v221;
              v132 = v130;
              v210 = v130;
              do
              {
                v133 = fmt_u(*(unsigned int *)v132, v131);
                if ( v132 == v210 )
                {
                  if ( v133 == v131 )
                  {
                    v234 = 48;
                    v133 = v219;
                  }
                }
                else if ( v133 <= v233 )
                {
                  v131 = v221;
                }
                else
                {
                  memset(v233, 48, v133 - v233);
                  v131 = v221;
                  do
                    --v133;
                  while ( v133 > v233 );
                }
                fake_file_out(file, v133, v131 - v133);
                v132 += 4;
              }
              while ( (unsigned int)v132 <= v211 );
              if ( v202 )
                fake_file_out(file, (const unsigned __int8 *)off_5E7B00, 1u);
              v134 = v220;
              if ( (int)v220 >= 1 && (unsigned int)v132 < v212 )
              {
                do
                {
                  v135 = fmt_u(*(unsigned int *)v132, v221);
                  if ( v135 > v233 )
                  {
                    memset(v233, 48, v135 - v233);
                    do
                      --v135;
                    while ( v135 > v233 );
                  }
                  v136 = v220;
                  v137 = 9;
                  if ( (int)v220 < 9 )
                    v137 = v220;
                  fake_file_out(file, v135, v137);
                  v134 = v136 - 9;
                  if ( v136 < 10 )
                    break;
                  v132 += 4;
                  v220 = v136 - 9;
                }
                while ( (unsigned int)v132 < v212 );
              }
              v29 = file;
              pad(file, 48, v134 + 9, 9, 0);
            }
            else
            {
              v138 = (unsigned __int8 *)v212;
              if ( v212 <= (unsigned int)v210 )
                v138 = v210 + 4;
              if ( (v220 & 0x80000000) == 0 )
              {
                v139 = v210;
                v212 = (size_t)v138;
                do
                {
                  v140 = v221;
                  v141 = fmt_u(*(unsigned int *)v139, v221);
                  if ( v141 == v140 )
                  {
                    v234 = 48;
                    v141 = v219;
                  }
                  v211 = (size_t)v139;
                  if ( v139 == v210 )
                  {
                    fake_file_out(file, v141++, 1u);
                    if ( length || (int)v220 >= 1 )
                      fake_file_out(file, (const unsigned __int8 *)off_5E7B00, 1u);
                    v140 = v221;
                  }
                  else if ( v141 > v233 )
                  {
                    memset(v233, 48, (size_t)&v141[v216]);
                    v140 = v221;
                    do
                      --v141;
                    while ( v141 > v233 );
                  }
                  v142 = v220;
                  v143 = v140 - v141;
                  v144 = v220;
                  if ( (int)v220 > v143 )
                    v144 = v143;
                  fake_file_out(file, v141, v144);
                  v145 = v142 - v143;
                  v139 = (unsigned __int8 *)(v211 + 4);
                  v220 = v145;
                }
                while ( v211 + 4 < v212 && v145 > -1 );
              }
              v29 = file;
              pad(file, 48, v220 + 18, 18, 0);
              fake_file_out(v29, v209, v217 - v209);
            }
            v30 = v208;
          }
          else
          {
            text = (unsigned __int8 *)v22;
            v28 = v205;
            v199 = v14;
            v29 = file;
            v30 = v208;
            v7 = v205 + 3;
            pad(file, 32, v208, v205 + 3, v199);
            fake_file_out(v29, text, v28);
            v31 = (const unsigned __int8 *)&dword_5E7B1C;
            if ( ((unsigned __int8)v209 & 0x20) != 0 )
              v31 = (const unsigned __int8 *)&off_5E7B20;
            fake_file_out(v29, v31, 3u);
          }
          v199 = v16 ^ 0x2000;
          v103 = v29;
LABEL_276:
          pad(v103, 32, v30, v7, v199);
          if ( v7 < v30 )
            v7 = v30;
          goto LABEL_334;
        }
        if ( v209 != (_BYTE *)&dword_40 + 3 )
        {
LABEL_93:
          v210 = "-+   0X0x";
          v35 = 0;
          v38 = v218;
          v36 = (unsigned __int8 *)v220;
LABEL_302:
          v151 = v38 - v37;
          v212 = v35;
          v199 = v16;
          v211 = v151;
          if ( (int)v36 < v151 )
            v36 = (unsigned __int8 *)v151;
          v152 = (int)&v36[v35];
          v220 = (size_t)v36;
          if ( p < (int)&v36[v35] )
            p = (int)&v36[v35];
          v153 = file;
          v208 = p;
          pad(file, 32, p, v152, v199);
          fake_file_out(v153, v210, v212);
          pad(v153, 48, p, v152, v16 ^ 0x10000);
          v154 = v211;
          pad(v153, 48, v220, v211, 0);
          fake_file_out(v153, v37, v154);
          v7 = v208;
          pad(v153, 32, v208, v152, v16 ^ 0x2000);
          goto LABEL_334;
        }
        v20 = (wchar_t *)v229;
        v229[0] = (int)arg.p;
        v229[1] = 0;
        arg.p = v229;
        v220 = -1;
LABEL_65:
        v7 = 0;
        v34 = 0;
        v212 = (size_t)v20;
        do
        {
          if ( !*v20 )
            break;
          v34 = wctomb(v228, *v20);
          if ( v34 < 0 )
            break;
          if ( v34 > v220 - v7 )
            break;
          v7 += v34;
          ++v20;
        }
        while ( v220 > v7 );
        if ( v34 < 0 )
          return -1;
        v149 = file;
        v208 = p;
        pad(file, 32, p, v7, v16);
        if ( v7 )
        {
          v155 = (wchar_t *)v212;
          v156 = 0;
          do
          {
            v157 = v155;
            if ( !*v155 )
              break;
            v158 = wctomb(v228, *v155);
            v156 += v158;
            if ( v156 > v7 )
              break;
            fake_file_out(file, v228, v158);
            v155 = v157 + 1;
          }
          while ( v156 < (unsigned int)v7 );
          v149 = file;
        }
        else
        {
          v7 = 0;
        }
LABEL_315:
        v159 = v208;
        pad(v149, 32, v208, v7, v16 ^ 0x2000);
        if ( v159 > v7 )
          v7 = v159;
      }
      goto LABEL_334;
    }
  }
  if ( !v167 )
  {
    if ( !v224 )
      return 0;
    v193 = 1;
    v194 = v223;
    v195 = v222 + 1;
    while ( 1 )
    {
      v196 = nl_type[v193];
      if ( !v196 )
        break;
      pop_arg(v195, v196, v194);
      v197 = v193 + 1;
      ++v195;
      v107 = v193++ < 9;
      if ( !v107 )
        goto LABEL_397;
    }
    v197 = v193;
LABEL_397:
    if ( v197 <= 9 )
    {
      while ( !nl_type[v197] )
      {
        v107 = v197++ <= 8;
        if ( !v107 )
          return 1;
      }
      return -1;
    }
    return 1;
  }
  return v6;
}
// 0: using guessed type int dword_0;
// 40: using guessed type int dword_40;
// 78: using guessed type int;
// 10168: using guessed type int elf_hash_chain[22025];
// 18CF00: using guessed type int __fastcall _isfinite(_DWORD, _DWORD);
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);
// 19DAF0: using guessed type int __fastcall _signbit(_DWORD, _DWORD);
// 5E7AF0: using guessed type int dword_5E7AF0[3];
// 5E7B00: using guessed type __int16 *off_5E7B00[4];
// 5E7B1C: using guessed type int dword_5E7B1C;
// 5E7B20: using guessed type void *off_5E7B20;
// 5E69D0: using guessed type unsigned __int8 var_2A0[4];

//----- (005E7B48) --------------------------------------------------------
size_t __fastcall vsnprintf(unsigned __int8 *s, size_t n, const unsigned __int8 *fmt, va_list_0 ap)
{
  size_t result; // r0
  size_t v8; // r1
  char v9; // [sp+7h] [bp-B1h] BYREF
  va_list_0 apa; // [sp+8h] [bp-B0h] BYREF
  void *v11; // [sp+Ch] [bp-ACh]
  FakeFILE file; // [sp+10h] [bp-A8h] BYREF
  arg nl_arg; // [sp+20h] [bp-98h] BYREF
  int nl_type[11]; // [sp+70h] [bp-48h] BYREF

  v11 = ap.__ap;
  memset(nl_type, 0, 0x28u);
  if ( n - 1 >= 0x7FFFFFFF )
  {
    if ( n )
    {
      *(_DWORD *)_errno(n - 1) = 75;
      return -1;
    }
    s = (unsigned __int8 *)&v9;
    n = 1;
  }
  if ( n > -2 - (int)s )
    n = -2 - (_DWORD)s;
  fake_file_init_buffer(&file, s, n);
  apa.__ap = v11;
  result = printf_core(&file, fmt, &apa, &nl_arg, nl_type);
  v8 = result;
  if ( result >= n )
    v8 = n - 1;
  s[v8] = 0;
  return result;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);
// 5E7B48: using guessed type int var_48[11];

//----- (005E7BEC) --------------------------------------------------------
void __fastcall pop_arg(arg *arg, int type, va_list_0 *ap)
{
  bool v3; // cc
  uintmax_t *v4; // r1
  void **v5; // r1
  int *v6; // r1
  int v7; // r1
  unsigned int *v8; // r1
  uintmax_t *v9; // r1
  __int16 *v10; // r1
  unsigned __int16 *v11; // r1
  char *v12; // r1
  unsigned __int8 *v13; // r1

  v3 = (unsigned int)type > 0x14;
  if ( (unsigned int)type <= 0x14 )
  {
    type -= 9;
    v3 = (unsigned int)type > 9;
  }
  if ( !v3 )
  {
    switch ( type )
    {
      case 0:
        v5 = (void **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        arg->p = *v5;
        return;
      case 1:
        v6 = (int *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v7 = *v6;
        goto LABEL_15;
      case 2:
        v8 = (unsigned int *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        arg->i = *v8;
        return;
      case 3:
        v9 = (uintmax_t *)(((int)ap->__ap + 7) & 0xFFFFFFF8);
        ap->__ap = v9 + 1;
        arg->i = *v9;
        return;
      case 4:
        v10 = (__int16 *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v7 = *v10;
        goto LABEL_15;
      case 5:
        v11 = (unsigned __int16 *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        arg->i = *v11;
        return;
      case 6:
        v12 = (char *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v7 = *v12;
LABEL_15:
        arg->i = v7;
        break;
      case 7:
        v13 = (unsigned __int8 *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        arg->i = *v13;
        break;
      case 8:
      case 9:
        v4 = (uintmax_t *)(((int)ap->__ap + 7) & 0xFFFFFFF8);
        ap->__ap = v4 + 1;
        arg->i = *v4;
        break;
    }
  }
}

//----- (005E7C9C) --------------------------------------------------------
unsigned __int8 *__fastcall fmt_u(uintmax_t x, unsigned __int8 *s)
{
  unsigned int v2; // r5
  uintmax_t v4; // r2
  bool v5; // cc
  unsigned int v6; // r3

  v2 = HIDWORD(x);
  if ( HIDWORD(x) )
  {
    do
    {
      HIDWORD(x) = v2;
      v4 = x % 0xA;
      x /= 0xAuLL;
      *--s = v4 | 0x30;
      v5 = v2 > 9;
      v2 = HIDWORD(x);
    }
    while ( v5 );
  }
  if ( (_DWORD)x )
  {
    do
    {
      v5 = (unsigned int)x > 9;
      v6 = (unsigned int)x % 0xA;
      LODWORD(x) = (unsigned int)x / 0xA;
      *--s = v6 | 0x30;
    }
    while ( v5 );
  }
  return s;
}

//----- (005E7CEC) --------------------------------------------------------
void __fastcall pad(FakeFILE *f, int c, int w, int l, int fl)
{
  size_t v6; // r8
  bool v7; // cf
  size_t v9; // r1
  unsigned int i; // r5
  unsigned __int8 v11[260]; // [sp+0h] [bp-118h] BYREF

  if ( w > l && (fl & 0x12000) == 0 )
  {
    v6 = w - l;
    v7 = (unsigned int)(w - l) >= 0x100;
    v9 = v6;
    if ( v7 )
      v9 = 256;
    memset(v11, c, v9);
    if ( v6 >= 0x100 )
    {
      for ( i = v6; i > 0xFF; i -= 256 )
        fake_file_out(f, v11, 0x100u);
      v6 = (unsigned __int8)v6;
    }
    fake_file_out(f, v11, v6);
  }
}

//----- (005E7D7C) --------------------------------------------------------
int __fastcall wctomb(unsigned __int8 *s, wchar_t wc)
{
  if ( s )
    return wcrtomb(s, wc, 0);
  else
    return 0;
}

//----- (005E7D88) --------------------------------------------------------
void __fastcall fake_file_init_file(FakeFILE *file, FILE *f)
{
  file->file = f;
  file->buffer = 0;
  file->buffer_size = 0;
  file->buffer_pos = 0;
}

//----- (005E7D94) --------------------------------------------------------
void __fastcall fake_file_init_buffer(FakeFILE *file, unsigned __int8 *buffer, size_t buffer_size)
{
  file->file = 0;
  file->buffer = buffer;
  *(_QWORD *)&file->buffer_size = buffer_size;
}

//----- (005E7DA0) --------------------------------------------------------
void __fastcall fake_file_init_wbuffer(FakeFILE *file, wchar_t *buffer, size_t buffer_size)
{
  file->file = 0;
  file->buffer = (unsigned __int8 *)buffer;
  *(_QWORD *)&file->buffer_size = 4 * buffer_size;
}

//----- (005E7DAE) --------------------------------------------------------
void __fastcall fake_file_out(FakeFILE *file, const unsigned __int8 *text, size_t length)
{
  size_t v3; // r4
  size_t buffer_pos; // r3
  size_t v6; // r2
  unsigned __int8 *v7; // r0

  v3 = length;
  if ( length )
  {
    if ( file->file )
    {
      sub_19B810(text, 1u, length, file->file);
    }
    else
    {
      buffer_pos = file->buffer_pos;
      v6 = file->buffer_size - buffer_pos;
      v7 = &file->buffer[buffer_pos];
      if ( v6 < v3 )
        v3 = file->buffer_size - buffer_pos;
      qmemcpy(v7, text, v3);
      file->buffer_pos += v3;
    }
  }
}

//----- (005E7DE6) --------------------------------------------------------
void __fastcall fake_file_outw(FakeFILE *file, const wchar_t *text, size_t length)
{
  size_t v3; // r5
  size_t v6; // r8
  unsigned __int8 *v7; // r6
  size_t buffer_pos; // r3
  size_t v9; // r1

  v3 = length;
  if ( length )
  {
    if ( file->file )
    {
      v6 = wcstombs(0, text, length);
      v7 = (unsigned __int8 *)malloc(v6);
      wcstombs(v7, text, v3);
      fwrite(v7, 1u, v6, file->file);
      j_free(v7);
    }
    else
    {
      buffer_pos = file->buffer_pos;
      v9 = file->buffer_size - buffer_pos;
      if ( v9 >> 2 < length )
        v3 = v9 >> 2;
      qmemcpy(&file->buffer[buffer_pos], text, 4 * v3);
      file->buffer_pos += 4 * v3;
    }
  }
}

//----- (005E7E54) --------------------------------------------------------
int __fastcall fake_feof(FakeFILE *file)
{
  if ( file->file )
    return (LOBYTE(file->file->_flags) >> 5) & 1;
  else
    return file->buffer_pos >= file->buffer_size;
}

//----- (005E7E6E) --------------------------------------------------------
int __fastcall fake_ferror(FakeFILE *file)
{
  FILE *v1; // r0

  v1 = file->file;
  if ( v1 )
    return (*(unsigned __int16 *)&byte_9[(_DWORD)v1 + 3] >> 6) & 1;
  else
    return 0;
}

//----- (005E7E80) --------------------------------------------------------
size_t fake_fprintf(FakeFILE *file, const unsigned __int8 *format, ...)
{
  FILE *v4; // r0
  size_t v5; // r5
  size_t v6; // r8
  unsigned __int8 *v7; // r6
  wchar_t *v8; // r4
  va_list va; // [sp+28h] [bp+8h] BYREF

  va_start(va, format);
  v4 = file->file;
  if ( v4 )
    return vfprintf(v4, format, va);
  v6 = vsnprintf(0, 0, format, va);
  v7 = (unsigned __int8 *)malloc(v6 + 1);
  vsnprintf(v7, v6 + 1, format, va);
  v5 = mbstowcs(0, v7, v6);
  v8 = (wchar_t *)malloc(4 * v5 + 4);
  mbstowcs(v8, v7, v6);
  fake_file_outw(file, v8, v5);
  free(v8);
  free(v7);
  return v5;
}

//----- (005E7F3C) --------------------------------------------------------
void __fastcall fake_fputc(unsigned __int8 ch, FakeFILE *file)
{
  __int64 v2; // kr00_8
  unsigned __int8 *buffer; // r12

  if ( file->file )
  {
    sub_18F47C(ch, file->file);
  }
  else
  {
    v2 = *(_QWORD *)&file->buffer_size;
    if ( HIDWORD(v2) < (unsigned int)v2 )
    {
      buffer = file->buffer;
      file->buffer_pos = HIDWORD(v2) + 1;
      buffer[HIDWORD(v2)] = ch;
    }
  }
}

//----- (005E7F5E) --------------------------------------------------------
void __fastcall fake_fputwc(wchar_t wc, FakeFILE *file)
{
  __int64 v2; // kr00_8

  if ( file->file )
  {
    sub_191AE4(wc, (__FILE *)file->file);
  }
  else
  {
    v2 = *(_QWORD *)&file->buffer_size;
    if ( HIDWORD(v2) + 3 < (unsigned int)v2 )
    {
      *(_DWORD *)&file->buffer[HIDWORD(v2)] = wc;
      file->buffer_pos += 4;
    }
  }
}

//----- (005E7F80) --------------------------------------------------------
size_t __fastcall mbstowcs(wchar_t *ws, const unsigned __int8 *s, size_t wn)
{
  const unsigned __int8 *v4; // [sp+0h] [bp-10h] BYREF

  v4 = s;
  return mbsrtowcs(ws, &v4, wn, 0);
}

//----- (005E7FB8) --------------------------------------------------------
size_t __fastcall wcrtomb(unsigned __int8 *s, wchar_t wc, mbstate_t *st)
{
  size_t v3; // r2
  _DWORD *v5; // r0

  if ( !s )
    return 1;
  if ( wc <= 0x7F )
  {
    *s = wc;
    return 1;
  }
  if ( wc >> 11 )
  {
    if ( wc < 0xD800 || (wc & 0xFFFFE000) == 57344 )
    {
      s[1] = (wc >> 6) & 0x3F | 0x80;
      *s = (wc >> 12) | 0xE0;
      s[2] = wc & 0x3F | 0x80;
      return 3;
    }
    else if ( (wc - 0x10000) >> 20 )
    {
      v5 = (_DWORD *)_errno();
      v3 = -1;
      *v5 = 84;
    }
    else
    {
      s[1] = (wc >> 12) & 0x3F | 0x80;
      *s = (wc >> 18) | 0xF0;
      s[2] = (wc >> 6) & 0x3F | 0x80;
      s[3] = wc & 0x3F | 0x80;
      return 4;
    }
  }
  else
  {
    v3 = 2;
    s[1] = wc & 0x3F | 0x80;
    *s = (wc >> 6) | 0xC0;
  }
  return v3;
}
// 19CEE8: using guessed type int _errno(void);

//----- (005E8058) --------------------------------------------------------
size_t __fastcall wcstombs(unsigned __int8 *s, const wchar_t *ws, size_t n)
{
  const wchar_t *v4; // [sp+0h] [bp-10h] BYREF

  v4 = ws;
  return wcsrtombs(s, &v4, n, 0);
}

//----- (005E8090) --------------------------------------------------------
size_t __fastcall mbsrtowcs(wchar_t *ws, const unsigned __int8 **src, size_t wn, mbstate_t *st)
{
  wchar_t *v5; // r5
  const unsigned __int8 *v6; // r6
  signed int opaque1; // r12
  size_t v8; // r0
  int v9; // r3
  int i; // r4
  int v11; // t1
  unsigned int v12; // r1
  const unsigned __int8 *v13; // r3
  int v14; // r3
  wchar_t v15; // r3
  unsigned int v16; // r3
  unsigned int v17; // r1
  const unsigned __int8 *v18; // r3
  int v19; // r1
  unsigned int v21; // r3
  unsigned int v22; // r3

  v5 = ws;
  v6 = *src;
  if ( !st || (opaque1 = st->__opaque1) == 0 )
  {
    v8 = wn;
    if ( v5 )
      goto LABEL_25;
    goto LABEL_9;
  }
  if ( ws )
  {
    st->__opaque1 = 0;
    v8 = wn;
    while ( 1 )
    {
      v16 = *v6;
      if ( (((v16 >> 3) + (opaque1 >> 26)) | ((v16 >> 3) - 16)) > 7 )
        break;
      v17 = v16 - 128;
      v18 = v6 + 1;
      v19 = v17 | (opaque1 << 6);
      if ( v19 > -1 )
        goto LABEL_44;
      v21 = *v18 - 128;
      if ( v21 >= 0x40 )
        goto LABEL_51;
      v19 = v21 | (v19 << 6);
      v18 = v6 + 2;
      if ( v19 > -1 )
      {
LABEL_44:
        v6 = v18;
      }
      else
      {
        v22 = *v18 - 128;
        if ( v22 >= 0x40 )
        {
LABEL_51:
          --v6;
          goto LABEL_40;
        }
        v19 = v22 | (v19 << 6);
        v6 += 3;
      }
      *v5++ = v19;
      --v8;
LABEL_25:
      if ( !v8 )
      {
LABEL_34:
        *src = v6;
        return wn;
      }
      while ( 1 )
      {
        v14 = *v6;
        if ( (unsigned int)(v14 - 1) <= 0x7E && v8 >= 5 && ((unsigned __int8)v6 & 3) == 0 )
        {
          while ( 1 )
          {
            v14 = *(_DWORD *)v6;
            if ( (((*(_DWORD *)v6 - 16843009) | *(_DWORD *)v6) & 0x80808080) != 0 )
              break;
            v8 -= 4;
            *v5 = (unsigned __int8)v14;
            v5[1] = v6[1];
            v5[2] = v6[2];
            v15 = v6[3];
            v6 += 4;
            v5[3] = v15;
            v5 += 4;
            if ( v8 <= 4 )
            {
              LOBYTE(v14) = *v6;
              break;
            }
          }
        }
        if ( (unsigned int)(unsigned __int8)v14 - 1 > 0x7E )
          break;
        *v5++ = (unsigned __int8)v14;
        --v8;
        ++v6;
        if ( !v8 )
          goto LABEL_34;
      }
      if ( (unsigned int)(unsigned __int8)v14 - 194 > 0x32 )
        goto LABEL_39;
      ++v6;
      opaque1 = _fsmu8[(unsigned __int8)v14 - 194];
    }
  }
  else
  {
    v8 = wn;
    while ( (((*v6 >> 3) - 16) | ((*v6 >> 3) + (opaque1 >> 26))) <= 7u )
    {
      v13 = v6 + 1;
      if ( (opaque1 & 0x2000000) == 0 )
        goto LABEL_19;
      if ( (*v13 & 0xC0) != 128 )
        break;
      v13 = v6 + 2;
      if ( (opaque1 & 0x80000) != 0 )
      {
        if ( (*v13 & 0xC0) != 128 )
          break;
        v6 += 3;
      }
      else
      {
LABEL_19:
        v6 = v13;
      }
      --v8;
      while ( 1 )
      {
LABEL_9:
        v9 = *v6;
        if ( (unsigned int)(v9 - 1) <= 0x7E && !((_DWORD)v6 << 30) )
        {
          v9 = *(_DWORD *)v6;
          for ( i = (*(_DWORD *)v6 - 16843009) | *(_DWORD *)v6; (i & 0x80808080) == 0; i = (v11 - 16843009) | v11 )
          {
            v11 = *((_DWORD *)v6 + 1);
            v6 += 4;
            LOBYTE(v9) = v11;
            v8 -= 4;
          }
        }
        if ( (unsigned int)(unsigned __int8)v9 - 1 > 0x7E )
          break;
        --v8;
        ++v6;
      }
      v12 = (unsigned __int8)v9 - 194;
      if ( v12 > 0x32 )
        goto LABEL_39;
      ++v6;
      opaque1 = _fsmu8[v12];
    }
  }
  --v6;
  if ( opaque1 )
    goto LABEL_40;
LABEL_39:
  if ( *v6 )
  {
LABEL_40:
    *(_DWORD *)_errno(v8) = 84;
    if ( v5 )
      *src = v6;
    return -1;
  }
  if ( v5 )
  {
    *v5 = 0;
    *src = 0;
  }
  wn -= v8;
  return wn;
}
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (005E825C) --------------------------------------------------------
size_t __fastcall wcsrtombs(unsigned __int8 *s, const wchar_t **ws, size_t n, mbstate_t *st)
{
  unsigned __int8 *v4; // r11
  size_t v5; // r10
  const wchar_t *v7; // r5
  size_t v8; // r4
  wchar_t v9; // r1
  size_t v10; // r0
  const wchar_t *v11; // r0
  wchar_t v12; // r1
  wchar_t *v13; // r4
  size_t v14; // r0
  wchar_t v15; // t1
  const wchar_t *v16; // r6
  wchar_t v17; // r1
  size_t v18; // r5
  unsigned __int8 v20[4]; // [sp+4h] [bp-24h] BYREF

  v4 = s;
  v5 = n;
  if ( !s )
  {
    v11 = *ws;
    v12 = **ws;
    if ( !v12 )
      return 0;
    v13 = (wchar_t *)(v11 + 1);
    v5 = 0;
    while ( 1 )
    {
      if ( v12 < 0x80 )
      {
        v14 = 1;
      }
      else
      {
        v14 = wcrtomb(v20, v12, 0);
        if ( v14 == -1 )
          return -1;
      }
      v15 = *v13++;
      v12 = v15;
      v5 += v14;
      if ( !v15 )
        return v5;
    }
  }
  if ( n >= 4 )
  {
    v7 = *ws;
    v8 = n;
    while ( 1 )
    {
      v9 = *v7;
      if ( *v7 - 1 < 0x7F )
      {
        v7 = *ws;
        --v8;
        *v4++ = v9;
      }
      else
      {
        if ( !v9 )
        {
LABEL_32:
          *v4 = 0;
          *ws = 0;
LABEL_33:
          v5 -= v8;
          return v5;
        }
        v10 = wcrtomb(v4, v9, 0);
        if ( v10 == -1 )
          return -1;
        v8 -= v10;
        v4 += v10;
      }
      *ws = ++v7;
      if ( v8 <= 3 )
        goto LABEL_20;
    }
  }
  v8 = n;
LABEL_20:
  if ( v8 )
  {
    v16 = *ws;
    do
    {
      v17 = *v16;
      if ( *v16 - 1 < 0x7F )
      {
        v16 = *ws;
        --v8;
        *v4++ = v17;
      }
      else
      {
        if ( !v17 )
          goto LABEL_32;
        v18 = wcrtomb(v20, v17, 0);
        if ( v18 == -1 )
          return -1;
        if ( v8 < v18 )
          goto LABEL_33;
        wcrtomb(v4, *v16, 0);
        v8 -= v18;
        v4 += v18;
      }
      *ws = ++v16;
    }
    while ( v8 );
  }
  return v5;
}
// 5E825C: using guessed type unsigned __int8 var_24[4];

// nfuncs=26157 queued=23910 decompiled=23910 lumina nreq=0 worse=0 better=0
// ALL OK, 23910 function(s) have been successfully decomp