m_nModelIndex == 571 )
        v27 = v27 * 3.0;
      CMatrix::SetScale(&v72, v20 * v27, v20, v20);
      if ( this->m_vehicleType == 3 )
      {
        v33 = m_fSteerAngle;
        v34 = 0.0;
      }
      else
      {
        WheelStatus = CDamageManager::GetWheelStatus(&this->Damage, v11);
        v36 = v9 * v16[527];
        if ( WheelStatus == 1 )
        {
          v37 = sinf(v9 * v16[527]);
          v34 = v36;
          v15 = v66;
          v33 = m_fSteerAngle + (float)(v37 * 0.3);
        }
        else
        {
          v34 = v9 * v16[527];
          v33 = m_fSteerAngle;
        }
      }
      CMatrix::Rotate(&v72, v34, 0.0, v33);
      if ( *(_BYTE *)&this->m_nAutomobileFlags < 0 || (this->hFlagsLocal & 0x20000) != 0 )
        goto LABEL_100;
      mFlags = this->pHandling->mFlags;
      v39 = v65 ^ 1;
      v40 = (mFlags & 0x20000) == 0;
      if ( (mFlags & 0x20000) != 0 )
        v40 = v39 == 1;
      if ( !v40 || (v41 = v10 ^ 1, (mFlags & 0x200000) != 0) && !v41 )
      {
LABEL_100:
        v42 = 2;
        if ( v11 > 1 )
          v42 = -2;
        v43 = fabsf(ty);
        v44 = atan2f(-(float)(v9 * (float)(v16[531] - this->m_aWheelSuspensionHeights[v42 + v11])), v43 + v43);
        goto LABEL_103;
      }
      if ( (CCheat::m_aCheatsActive[41] || (v15 = v66, this->m_nModelIndex == 539))
        && v16[510] < 1.0
        && (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) == 0 )
      {
        if ( (v64 & 4) == 0 )
          CMatrix::RotateY(&v72, v9 * -1.5708);
        if ( (v64 & 8) == 0 )
        {
          FxPrtMult_c::FxPrtMult_c(&v70, 1.0, 1.0, 1.0, 0.2, 0.5, 0.0, 0.05);
          v46 = (char *)this + 44 * (__int16)v11;
          v47 = *((_QWORD *)v46 + 231);
          pos.z = *((RwReal *)v46 + 464);
          *(_QWORD *)&pos.x = v47;
          m_pMat = this->m_pMat;
          v49 = (float)(this->m_vecMoveSpeed.x * 0.5) + (float)(v9 * m_pMat->xx);
          v50 = (float)(this->m_vecMoveSpeed.y * 0.5) + (float)(v9 * m_pMat->yx);
          v51 = (float)(this->m_vecMoveSpeed.z * 0.5) + (float)(v9 * m_pMat->zx);
          vel.y = v50;
          vel.x = v49;
          vel.z = v51;
          if ( SurfaceInfos_c::IsWater(&g_surfaceInfos, (unsigned __int8)v46[1883]) )
          {
            if ( (unsigned __int8)CTimer::m_FrameCounter << 31 )
            {
              m_fxSysSmokeHuge = g_fx.m_fxSysSmokeHuge;
            }
            else
            {
              m_fxSysSmokeHuge = g_fx.m_fxSysWaterSplash;
              vel.z = v51 + 2.0;
            }
            FxSystem_c::AddParticle(m_fxSysSmokeHuge, &pos, &vel, 0.0, &v70, -1.0, 1.2, 0.6, 0);
          }
          else if ( SurfaceInfos_c::IsSand(&g_surfaceInfos, (unsigned __int8)v46[1883]) )
          {
            FxPrtMult_c::FxPrtMult_c(&v67, 0.81, 0.67, 0.57, 0.35, 0.5, 0.0, 0.05);
            FxSystem_c::AddParticle(g_fx.m_fxSysSand, &pos, &vel, 0.0, v59, -1.0, 1.2, 0.6, 0);
          }
        }
      }
      else if ( !(v64 << 31) && ((mFlags & 0x10000) == 0 || v39 == 1) && ((mFlags & 0x100000) == 0 || v41 == 1) )
      {
        p_m_n2dEffects = (float *)&v15[1].m_n2dEffects;
        if ( v65 )
          p_m_n2dEffects = (float *)&v15[1].m_txdIndex;
        v54 = (float)(this->m_fHeightAboveRoad + v25) + (float)(*p_m_n2dEffects * -0.5);
        if ( (mFlags & 0x80000) != 0 && v39 != 1 || (mFlags & 0x800000) != 0 && !v41 )
        {
          v55 = v9 * v54;
          v56 = -(float)(v9 * v54);
          v57 = 1.0;
          v58 = -1.0;
          if ( v55 > 1.0 )
            v57 = -1.0;
          if ( v55 < -1.0 )
            v58 = v57;
          if ( v55 > 1.0 )
            v56 = v58;
          if ( v55 < -1.0 )
            v56 = v58;
          LODWORD(v45) = COERCE_UNSIGNED_INT(asinf(v56)) ^ 0x80000000;
          goto LABEL_104;
        }
        v60 = v9 * v54;
        v61 = -(float)(v9 * v54);
        v62 = 1.0;
        v63 = -1.0;
        if ( v60 > 1.0 )
          v62 = -1.0;
        if ( v60 < -1.0 )
          v63 = v62;
        if ( v60 > 1.0 )
          v61 = v63;
        if ( v60 < -1.0 )
          v61 = v63;
        v44 = asinf(v61);
LABEL_103:
        v45 = v44;
LABEL_104:
        CMatrix::RotateY(&v72, v45);
      }
      v72.tx = tx + v72.tx;
      v72.ty = ty + v72.ty;
      v72.tz = v72.tz + v25;
      CMatrix::UpdateRW(&v72);
LABEL_106:
      CMatrix::~CMatrix(&v72);
      return;
    default:
      goto LABEL_106;
  }
}
// 559C8E: variable 'v59' is possibly undefined

//----- (00559D44) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CAutomobile::PreRender(CAutomobile *this)
{
  float v1; // s22
  CAutomobile *v2; // r8
  CColModel *ColModel; // r0
  int v4; // r1
  int m_pColData; // r5
  bool v6; // zf
  float v7; // s2
  float v8; // s6
  float v9; // s4
  float v10; // s8
  float v11; // s2
  float *m_aWheelSuspensionHeights; // r0
  float v13; // s8
  float v14; // s4
  float v15; // s4
  float v16; // s6
  float v17; // s8
  float v18; // s2
  float *v19; // r0
  float v20; // s4
  float v21; // s4
  float v22; // s4
  float v23; // s6
  float v24; // s8
  float v25; // s2
  float *v26; // r0
  float v27; // s4
  float v28; // s4
  float v29; // s4
  float v30; // s6
  float v31; // s8
  float v32; // s2
  float *v33; // r0
  float v34; // s4
  float v35; // s4
  float *p_xx; // r0
  float x; // s0
  float y; // s2
  float v39; // s6
  float v40; // s10
  float v41; // s8
  float z; // s4
  int m_nModelIndex; // r0
  float v44; // s16
  bool v45; // zf
  unsigned int m_info; // r0
  __int64 v47; // d16
  RwReal v48; // r0
  RwMatrix *p_modelling; // r1
  __int64 v50; // d16
  RwReal v51; // r0
  RwMatrix *v52; // r1
  __int64 v53; // d16
  RwReal v54; // r0
  RwMatrix *v55; // r1
  __int64 v56; // d16
  RwReal v57; // r0
  tWheelState v58; // r0
  bool v59; // zf
  int v60; // r2
  CColPoint *m_aWheelColPoints; // r11
  int v62; // r5
  int v63; // r4
  unsigned int nWheelIndex; // r6
  char *v65; // r10
  uint32 v66; // r8
  uint32 WheelStatus; // r2
  float fOutsideVec; // s0
  float v69; // s18
  float v70; // s20
  float *v71; // r1
  uint32 v72; // r4
  float v73; // s0
  float v74; // s4
  tWheelState v75; // r10
  uint32 v76; // r0
  float *v77; // r0
  uint32 v78; // r5
  float v79; // s2
  float v80; // s4
  tWheelState v81; // r6
  uint32 v82; // r0
  float v83; // s16
  CVehicle *v84; // r0
  CVehicle *v85; // r4
  int v86; // r0
  CMatrix *v87; // r6
  float xy; // s2
  float yy; // s4
  float zy; // s0
  unsigned int v91; // r8
  unsigned int v92; // r10
  unsigned int v93; // r6
  float v94; // s0
  unsigned int v95; // r2
  unsigned int v96; // r1
  unsigned int v97; // r0
  uint32 v98; // r3
  unsigned int v99; // r0
  float v100; // s0
  CMatrix *m_pMat; // r3
  unsigned int v102; // s8
  CSimpleTransform *p_tx; // r1
  float v104; // s0
  float v105; // s8
  float v106; // s14
  RwReal v107; // s4
  unsigned int v108; // s4
  char *v109; // r11
  int v110; // r10
  unsigned int v111; // s2
  int v112; // r8
  float v113; // s8
  float v114; // s0
  uint32 v115; // r0
  int v116; // r0
  bool v117; // zf
  int v118; // r2
  bool v119; // zf
  uint32 v120; // r2
  CVehicle *PlayerVehicle; // r0
  CVehicle *v122; // r2
  _BOOL4 LookingForwardFirstPerson; // r0
  CVehicle *v124; // r0
  VEH_SHD_TYPE v125; // r1
  int v126; // r1
  float m_fSteerAngle; // r6
  const CMatrix *v128; // r5
  uint32 mFlags; // r8
  CAutomobile *v130; // r1
  CMatrix *v131; // r5
  __int64 v132; // d16
  uint32 hFlagsLocal; // r0
  float m_f2ndSteerAngle; // s0
  float v135; // r0
  __int64 v136; // d16
  float v137; // r6
  tWheelState v138; // r2
  CVector *p_v; // r6
  int v140; // r9
  int v141; // r8
  int v142; // r10
  float *v143; // r4
  __int16 v144; // r11
  bool v145; // zf
  CMatrix *v146; // r0
  float *p_x; // r3
  float v148; // s6
  CVehicle *v149; // r5
  __int64 v150; // d16
  float *p_m_wheelScaleRear; // r0
  CVector *p_vecForward; // r2
  float v153; // s0
  int32 v154; // r5
  CVehicle *v155; // r4
  float *p_m_ListenerVolume; // r9
  float *p_m_nPlayTime; // r8
  float *p_m_FrameDelay; // r10
  float *p_m_Doppler; // r11
  int z_low; // r1
  int m_pNOCollisionVehicle_low; // r1
  int m_pPhysicalEntity_low; // r1
  int v163; // r1
  int v164; // r0
  float v165; // s0
  float v166; // s4
  float v167; // s2
  float v168; // s14
  float v169; // s1
  float v170; // s6
  float v171; // s10
  float v172; // s7
  float v173; // s8
  int v174; // r1
  int v175; // r0
  float v176; // s0
  float v177; // s16
  CVehicle *v178; // r2
  int v179; // r0
  CEntity *v180; // r0
  float v181; // r3
  RwFrame_0 *v182; // r1
  CVehicle *v183; // r0
  CVehicle *v184; // r0
  RwReal v185; // r2
  CEntity *m_pAttachToEntity; // r1
  int v187; // r1
  RwReal v188; // r1
  float v189; // s0
  unsigned int m_pAudioEntity_low; // r0
  float v191; // s2
  float v192; // s0
  RwFrame_0 *v193; // r1
  float v194; // r3
  float v195; // s4
  float v196; // s0
  CVehicle *m_pVehicleBeingTowed; // r0
  float v198; // r0
  int v199; // r6
  float v200; // r3
  RwReal v201; // r1
  RwFrame_0 *FrameFromId; // r0
  __int64 v203; // kr00_8
  float v204; // s16
  unsigned int v205; // r4
  float *p_InvertDirVeryOldLink; // r0
  float v207; // s18
  float v208; // s6
  float v209; // s0
  float v210; // s4
  float v211; // r3
  float v212; // s20
  float v213; // s22
  float v214; // r0
  float v215; // s0
  float v216; // s16
  float v217; // r5
  CMatrix *v218; // r0
  bool v219; // zf
  float v220; // r0
  float m_heading; // r5
  float v222; // r8
  float v223; // r0
  _BYTE B[20]; // [sp+0h] [bp-190h] OVERLAPPED BYREF
  uint32 ReflType; // [sp+1Ch] [bp-174h]
  int v226; // [sp+44h] [bp-14Ch]
  CVehicleModelInfo *v227; // [sp+4Ch] [bp-144h]
  unsigned int v228; // [sp+50h] [bp-140h]
  UInt8 G[4]; // [sp+54h] [bp-13Ch]
  UInt8 v230[4]; // [sp+58h] [bp-138h]
  tWheelState nWheelState; // [sp+5Ch] [bp-134h]
  CVehicle *pVehicle; // [sp+60h] [bp-130h]
  CVector v233; // [sp+64h] [bp-12Ch] BYREF
  CVector v234; // [sp+70h] [bp-120h] BYREF
  CVector vecForward; // [sp+80h] [bp-110h] BYREF
  CVector v236; // [sp+90h] [bp-100h] BYREF
  CVector v; // [sp+A0h] [bp-F0h] BYREF
  CVector posn; // [sp+D0h] [bp-C0h] BYREF
  CMatrix Coors; // [sp+E0h] [bp-B0h] BYREF
  CVector v240; // [sp+128h] [bp-68h] BYREF
  CVector v241; // 0:r1.12
  CVector v242; // 0:r3.4,4:^0.8
  CVector v243; // 0:r3.4,4:^0.8
  CVector v244; // 0:r3.4,4:^0.8
  CVector v245; // 0:r2.8,8:^0.4

  v2 = this;
  CVehicle::PreRender(this);
  if ( CCheat::m_aCheatsActive[41] )
    (*((void (__fastcall **)(CAutomobile *))v2->_vptr$CPlaceable + 70))(v2);
  ColModel = CEntity::GetColModel(v2);
  v4 = *((unsigned __int8 *)&v2->m_nVehicleFlags + 3);
  m_pColData = (int)ColModel->m_pColData;
  pVehicle = v2;
  v6 = v4 << 31 == 0;
  if ( v4 << 31 )
    v6 = v2->m_vehicleType == 1;
  if ( !v6 )
  {
    (*((void (__fastcall **)(CAutomobile *))v2->_vptr$CPlaceable + 53))(v2);
    v7 = v2->m_fSuspensionLength[0];
    v8 = v2->m_aWheelRatios[0];
    v9 = (float)(v8 - (float)(1.0 - (float)(v7 / v2->m_fLineLength[0])))
       / (float)(1.0 - (float)(1.0 - (float)(v7 / v2->m_fLineLength[0])));
    v10 = v7 * v9;
    v11 = *(float *)(*(_DWORD *)(m_pColData + 16) + 8);
    m_aWheelSuspensionHeights = v2->m_aWheelSuspensionHeights;
    v13 = v11 - v10;
    if ( v9 > 0.0 )
      v11 = v13;
    v14 = *m_aWheelSuspensionHeights;
    if ( v8 >= 1.0 || v11 <= v14 )
      v11 = v14 + (float)((float)(v11 - v14) * 0.75);
    *m_aWheelSuspensionHeights = v11;
    v15 = v2->m_fSuspensionLength[1];
    v16 = v2->m_aWheelRatios[1];
    v17 = (float)(v16 - (float)(1.0 - (float)(v15 / v2->m_fLineLength[1])))
        / (float)(1.0 - (float)(1.0 - (float)(v15 / v2->m_fLineLength[1])));
    v18 = *(float *)(*(_DWORD *)(m_pColData + 16) + 40);
    v19 = &v2->m_aWheelSuspensionHeights[1];
    v20 = v18 - (float)(v15 * v17);
    if ( v17 > 0.0 )
      v18 = v20;
    v21 = *v19;
    if ( v16 >= 1.0 || v18 <= v21 )
      v18 = v21 + (float)((float)(v18 - v21) * 0.75);
    *v19 = v18;
    v22 = v2->m_fSuspensionLength[2];
    v23 = v2->m_aWheelRatios[2];
    v24 = (float)(v23 - (float)(1.0 - (float)(v22 / v2->m_fLineLength[2])))
        / (float)(1.0 - (float)(1.0 - (float)(v22 / v2->m_fLineLength[2])));
    v25 = *(float *)(*(_DWORD *)(m_pColData + 16) + 72);
    v26 = &v2->m_aWheelSuspensionHeights[2];
    v27 = v25 - (float)(v22 * v24);
    if ( v24 > 0.0 )
      v25 = v27;
    v28 = *v26;
    if ( v23 >= 1.0 || v25 <= v28 )
      v25 = v28 + (float)((float)(v25 - v28) * 0.75);
    *v26 = v25;
    v29 = v2->m_fSuspensionLength[3];
    v30 = v2->m_aWheelRatios[3];
    v31 = (float)(v30 - (float)(1.0 - (float)(v29 / v2->m_fLineLength[3])))
        / (float)(1.0 - (float)(1.0 - (float)(v29 / v2->m_fLineLength[3])));
    v32 = *(float *)(*(_DWORD *)(m_pColData + 16) + 104);
    v33 = &v2->m_aWheelSuspensionHeights[3];
    v34 = v32 - (float)(v29 * v31);
    if ( v31 > 0.0 )
      v32 = v34;
    v35 = *v33;
    if ( v30 >= 1.0 || v32 <= v35 )
      *v33 = v35 + (float)((float)(v32 - v35) * 0.75);
    else
      *v33 = v32;
  }
  v226 = m_pColData;
  p_xx = &v2->m_pMat->xx;
  x = v2->m_vecMoveSpeed.x;
  y = v2->m_vecMoveSpeed.y;
  v39 = x * p_xx[4];
  v40 = p_xx[6];
  v41 = y * p_xx[5];
  z = v2->m_vecMoveSpeed.z;
  m_nModelIndex = v2->m_nModelIndex;
  v44 = sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z));
  if ( m_nModelIndex != -2 )
  {
    v45 = m_nModelIndex == 441;
    if ( m_nModelIndex != 441 )
      v45 = m_nModelIndex == 539;
    if ( !v45 )
    {
      m_info = (unsigned __int8)v2->m_info;
      if ( (m_info & 0xF8) == 16 )
      {
        Coors.m_pRwMat = 0;
        Coors.m_owner = 0;
        CMatrix::Attach(&Coors, &v2->m_aCarNodes[4]->modelling, 0);
        v1 = 1.5;
        v.x = Coors.tx;
        v.y = Coors.ty;
        v.z = v2->m_aWheelSuspensionHeights[3] * 1.5;
        operator*(&posn, v2->m_pMat, &v);
        v240 = posn;
        v47 = *(_QWORD *)&posn.x;
        v48 = posn.z;
        p_modelling = &v2->m_aCarNodes[7]->modelling;
        v2->m_aWheelColPoints[3].m_dataB.m_nSurfaceType = 0;
        v2->m_aWheelColPoints[3].m_vecPosition.z = v48;
        *(_QWORD *)&v2->m_aWheelColPoints[3].m_vecPosition.x = v47;
        CMatrix::Attach(&Coors, p_modelling, 0);
        v.x = Coors.tx;
        v.y = Coors.ty;
        v.z = v2->m_aWheelSuspensionHeights[1] * 1.5;
        operator*(&posn, v2->m_pMat, &v);
        v240 = posn;
        v50 = *(_QWORD *)&posn.x;
        v51 = posn.z;
        v52 = &v2->m_aCarNodes[2]->modelling;
        v2->m_aWheelColPoints[1].m_dataB.m_nSurfaceType = 0;
        v2->m_aWheelColPoints[1].m_vecPosition.z = v51;
        *(_QWORD *)&v2->m_aWheelColPoints[1].m_vecPosition.x = v50;
        CMatrix::Attach(&Coors, v52, 0);
        v.x = Coors.tx;
        v.y = Coors.ty;
        v.z = v2->m_aWheelSuspensionHeights[2] * 1.5;
        operator*(&posn, v2->m_pMat, &v);
        v240 = posn;
        v53 = *(_QWORD *)&posn.x;
        v54 = posn.z;
        v55 = &v2->m_aCarNodes[5]->modelling;
        v2->m_aWheelColPoints[2].m_dataB.m_nSurfaceType = 0;
        v2->m_aWheelColPoints[2].m_vecPosition.z = v54;
        *(_QWORD *)&v2->m_aWheelColPoints[2].m_vecPosition.x = v53;
        CMatrix::Attach(&Coors, v55, 0);
        v.x = Coors.tx;
        v.y = Coors.ty;
        v.z = v2->m_aWheelSuspensionHeights[0] * 1.5;
        operator*(&posn, v2->m_pMat, &v);
        v240 = posn;
        v56 = *(_QWORD *)&posn.x;
        v57 = posn.z;
        v2->m_aWheelColPoints[0].m_dataB.m_nSurfaceType = 0;
        v2->m_aWheelColPoints[0].m_vecPosition.z = v57;
        *(_QWORD *)&v2->m_aWheelColPoints[0].m_vecPosition.x = v56;
        CMatrix::~CMatrix(&Coors);
        m_info = (unsigned __int8)v2->m_info;
      }
      if ( m_info <= 0x1F )
      {
        v58 = v2->m_aWheelState[1];
        v59 = v58 == WS_SKIDDING;
        if ( v58 != WS_SKIDDING )
          v59 = v2->m_aWheelState[3] == WS_SKIDDING;
        v60 = !v59;
        v1 = 1.0;
        m_aWheelColPoints = v2->m_aWheelColPoints;
        v62 = 0;
        v63 = 0;
        nWheelIndex = 0;
        *(_DWORD *)G = &v2->Damage;
        *(_DWORD *)v230 = v60;
        do
        {
          v65 = (char *)(&m_aWheelColPoints->m_vecPosition.x + nWheelIndex);
          v66 = *(&m_aWheelColPoints[5].m_dataA.m_nSurfaceType + nWheelIndex);
          if ( (nWheelIndex | 2) == 2 )
            v66 |= 4u;
          nWheelState = *((_DWORD *)v65 + 145);
          if ( !v60 )
            v66 = *(&m_aWheelColPoints[5].m_dataA.m_nSurfaceType + nWheelIndex);
          if ( *(&m_aWheelColPoints[5].m_dataB.m_nPieceType + nWheelIndex) )
            v66 |= 2u;
          WheelStatus = CDamageManager::GetWheelStatus(*(const CDamageManager **)G, nWheelIndex);
          fOutsideVec = 1.0;
          if ( nWheelIndex < 2 )
            fOutsideVec = -1.0;
          ReflType = v66;
          v2 = (CAutomobile *)pVehicle;
          CVehicle::AddSingleWheelParticles(
            pVehicle,
            nWheelState,
            WheelStatus,
            *(float *)((char *)&m_aWheelColPoints[4].m_vecNormal.x + v63),
            v44,
            &m_aWheelColPoints[v62],
            &m_aWheelColPoints[v62].m_vecPosition,
            fOutsideVec,
            nWheelIndex,
            *((_DWORD *)v65 + 59),
            (bool *)&m_aWheelColPoints[5].m_dataA.m_nSurfaceType + nWheelIndex,
            ReflType);
          v60 = *(_DWORD *)v230;
          ++nWheelIndex;
          ++v62;
          v63 += 4;
        }
        while ( nWheelIndex != 4 );
      }
    }
  }
  v69 = (float)(v39 + v41) + (float)(z * v40);
  nWheelState = (tWheelState)&v2->m_nVehicleFlags;
  v70 = 0.0055556;
  if ( v2->m_aCarNodes[3] )
  {
    v71 = &v2->m_pMat->xx;
    v6 = !v2->bMoreSkidMarks[1];
    v72 = v2->bWheelBloody[1];
    v73 = (float)(v71[4] + v71[4]) + v2->m_aWheelColPoints[1].m_vecPosition.x;
    v74 = (float)(v71[6] + v71[6]) + v2->m_aWheelColPoints[1].m_vecPosition.z;
    Coors.yx = (float)(v71[5] + v71[5]) + v2->m_aWheelColPoints[1].m_vecPosition.y;
    Coors.xx = v73;
    Coors.zx = v74;
    v75 = v2->m_aWheelState[1];
    if ( !v6 )
      v72 |= 2u;
    v76 = CDamageManager::GetWheelStatus(&v2->Damage, 1);
    CVehicle::AddSingleWheelParticles(
      v2,
      v75,
      v76,
      v2->m_aRatioHistory[1],
      v44,
      &v2->m_aWheelColPoints[1],
      (CVector *)&Coors,
      1.0,
      5,
      v2->aWheelSkidmarkType[1],
      &v2->bWheelBloody[1],
      v72);
    v77 = &v2->m_pMat->xx;
    v78 = v2->bWheelBloody[3];
    v6 = !v2->bMoreSkidMarks[3];
    v79 = (float)(v77[5] + v77[5]) + v2->m_aWheelColPoints[3].m_vecPosition.y;
    v80 = (float)(v77[6] + v77[6]) + v2->m_aWheelColPoints[3].m_vecPosition.z;
    Coors.xx = (float)(v77[4] + v77[4]) + v2->m_aWheelColPoints[3].m_vecPosition.x;
    Coors.yx = v79;
    Coors.zx = v80;
    v81 = v2->m_aWheelState[3];
    if ( !v6 )
      v78 |= 2u;
    v82 = CDamageManager::GetWheelStatus(&v2->Damage, 3);
    CVehicle::AddSingleWheelParticles(
      v2,
      v81,
      v82,
      v2->m_aRatioHistory[3],
      v44,
      &v2->m_aWheelColPoints[3],
      (CVector *)&Coors,
      1.0,
      6,
      v2->aWheelSkidmarkType[3],
      &v2->bWheelBloody[3],
      v78);
  }
  v83 = v69 / 0.0055556;
  if ( !CCullZones::CamNoRain()
    && !CCullZones::PlayerNoRain()
    && fabsf(v83) < 20.0
    && CWeather::Rain > 0.02
    && CGame::currArea == AREA_MAIN_MAP )
  {
    CVehicle::AddWaterSplashParticles(pVehicle);
  }
  v84 = pVehicle;
  if ( (*(_DWORD *)nWheelState & 0x10) != 0
    && !(*((_DWORD *)&v2->m_nVehicleFlags + 1) & 0x800000 | *(_DWORD *)nWheelState & 0x40000000)
    && v83 < 130.0
    && (pVehicle->pHandling->mFlags & 0x1000) == 0 )
  {
    CVehicle::AddExhaustParticles(pVehicle);
    v84 = pVehicle;
  }
  CVehicle::AddDamagedVehicleParticles(v84);
  v85 = pVehicle;
  v86 = pVehicle->m_nModelIndex;
  switch ( pVehicle->m_nModelIndex )
  {
    case 0x197:
    case 0x1A0:
    case 0x1AB:
      goto LABEL_74;
    case 0x198:
    case 0x199:
    case 0x19A:
    case 0x19B:
    case 0x19C:
    case 0x19D:
    case 0x19E:
    case 0x19F:
    case 0x1A1:
    case 0x1A2:
    case 0x1A3:
    case 0x1A5:
    case 0x1A6:
    case 0x1A7:
    case 0x1A8:
    case 0x1A9:
    case 0x1AA:
    case 0x1AC:
    case 0x1AD:
    case 0x1AE:
    case 0x1AF:
    case 0x1B0:
    case 0x1B1:
    case 0x1B2:
    case 0x1B3:
    case 0x1B4:
    case 0x1B5:
      goto LABEL_109;
    case 0x1A4:
      if ( !(LOBYTE(pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_BankSlotID) << 31)
        || MobileSettings::settings[0].value < 2 )
      {
        goto LABEL_109;
      }
      Coors.yx = -0.4;
      Coors.xx = 0.0;
      Coors.zx = 0.95;
      operator*(&v, pVehicle->m_pMat, (const CVector *)&Coors);
      v94 = CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0;
      goto LABEL_87;
    case 0x1B6:
      if ( !(LOBYTE(pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_BankSlotID) << 31) )
        goto LABEL_109;
      Coors.xx = 0.0;
      Coors.yx = 0.0;
      Coors.zx = 0.85;
      operator*(&v, pVehicle->m_pMat, (const CVector *)&Coors);
      v94 = CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0;
LABEL_87:
      CCoronas::RegisterCorona(
        (u_native)&pVehicle->m_transform.m_heading + 1,
        pVehicle,
        (unsigned int)(float)(v94 * 100.0),
        (unsigned int)(float)(v94 * 100.0),
        0,
        0xFFu,
        (const CVector *)&Coors,
        0.8,
        TheCamera.LODDistMultiplier * 150.0,
        1,
        0,
        1u,
        0,
        0,
        0.0,
        0,
        1.5,
        0,
        15.0,
        0,
        1);
      memset(B, 0, 12);
      CPointLights::AddLight(0, v, *(CVector *)B, 10.0, 0.1, 0.1, 0.05, 0, 1, 0);
      goto LABEL_88;
    default:
      if ( (unsigned int)(v86 - 596) < 4 )
      {
LABEL_74:
        if ( (*((_BYTE *)&v2->m_nVehicleFlags + 5) & 0x80) == 0 )
          goto LABEL_109;
        v91 = 0;
        if ( v86 < 596 )
        {
          if ( v86 == 407 )
          {
            v83 = 0.9;
            v92 = 255;
            v69 = 1.3;
            v91 = 0;
            v70 = 3.2;
            v1 = -0.9;
          }
          else if ( v86 == 416 )
          {
            v83 = 0.6;
            v91 = 255;
            v69 = 1.2;
            v92 = 255;
            v70 = 0.9;
            v1 = -0.6;
          }
          else
          {
            v92 = 0;
            v93 = 0;
            if ( v86 != 427 )
              goto LABEL_93;
            v83 = 0.55;
            v92 = 0;
            v69 = 1.4;
            v91 = 255;
            v70 = 1.1;
            v1 = -0.55;
          }
        }
        else
        {
          if ( (unsigned int)(v86 - 596) >= 3 )
          {
            v92 = 0;
            v93 = 0;
            if ( v86 != 599 )
              goto LABEL_93;
            v83 = 0.7;
            v92 = 0;
            v69 = 1.2;
            v70 = -0.1;
          }
          else
          {
            v69 = 1.0;
            v83 = 0.7;
            v70 = -0.4;
            v92 = 0;
          }
          v1 = -0.7;
          v91 = 255;
        }
        v93 = 255;
LABEL_93:
        if ( (CTimer::m_snTimeInMilliseconds & 0x200) >= 0x200 )
        {
          v97 = v92;
          v95 = v91 / 6;
          v96 = v92 / 6;
        }
        else
        {
          LOBYTE(v95) = 0;
          LOBYTE(v96) = 0;
          v97 = v93;
        }
        v98 = CTimer::m_snTimeInMilliseconds & 0x1FF;
        v99 = v97 / 6;
        if ( v98 > 0x63 )
        {
          if ( v98 <= 0x19C )
          {
LABEL_100:
            m_pMat = pVehicle->m_pMat;
            v102 = (unsigned __int8)v96;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            v104 = (float)(unsigned __int8)v95;
            v105 = (float)v102;
            if ( !m_pMat )
              p_tx = &pVehicle->m_transform;
            v106 = p_tx->m_translate.z;
            v107 = p_tx->m_translate.y + (float)(m_pMat->yz + m_pMat->yz);
            memset(B, 0, 12);
            v241.x = p_tx->m_translate.x + (float)(m_pMat->xz + m_pMat->xz);
            v241.y = v107;
            v241.z = v106 + (float)(m_pMat->zz + m_pMat->zz);
            CPointLights::AddLight(
              0,
              v241,
              *(CVector *)B,
              10.0,
              (float)(unsigned __int8)v99 / 200.0,
              v105 / 200.0,
              v104 / 200.0,
              0,
              1,
              0);
            v85 = pVehicle;
            v108 = v92;
            v109 = (char *)&pVehicle->m_pMat + 1;
            v110 = 0;
            v111 = v91;
            v112 = 0;
            v113 = (float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0) * 0.0;
            *(_DWORD *)v230 = (unsigned int)(float)((float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0)
                                                  * (float)v111);
            *(_DWORD *)G = (unsigned int)(float)((float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0)
                                               * (float)v108);
            v228 = (unsigned int)(float)((float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0) * (float)v93);
            while ( 1 )
            {
              v114 = (float)(unsigned __int8)v110;
              v240.x = (float)((float)(v83 * v114) + (float)(v1 * (float)(3.0 - v114))) * 0.33333;
              v240.y = (float)((float)(v70 * v114) + (float)(v70 * (float)(3.0 - v114))) * 0.33333;
              v240.z = (float)((float)(v69 * v114) + (float)(v69 * (float)(3.0 - v114))) * 0.33333;
              v115 = ((CTimer::m_snTimeInMilliseconds + v112) >> 8) & 3;
              if ( v115 == 2 )
                break;
              if ( !v115 )
              {
                CCoronas::RegisterCorona(
                  (u_native)&v109[v110],
                  v85,
                  v228,
                  (unsigned int)v113,
                  (unsigned int)v113,
                  0xFFu,
                  &v240,
                  0.4,
                  TheCamera.LODDistMultiplier * 150.0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0.0,
                  0,
                  1.5,
                  0,
                  15.0,
                  0,
                  1);
LABEL_107:
                v85 = pVehicle;
              }
              ++v110;
              v112 += 64;
              if ( v110 == 4 )
                goto LABEL_109;
            }
            CCoronas::RegisterCorona(
              (u_native)&v109[v110],
              v85,
              G[0],
              G[0],
              v230[0],
              0xFFu,
              &v240,
              0.4,
              TheCamera.LODDistMultiplier * 150.0,
              0,
              0,
              0,
              0,
              0,
              0.0,
              0,
              1.5,
              0,
              15.0,
              0,
              1);
            goto LABEL_107;
          }
          v98 = 512 - v98;
        }
        v100 = (float)v98 / 100.0;
        v95 = (unsigned int)(float)(v100 * (float)(unsigned __int8)v95);
        v96 = (unsigned int)(float)(v100 * (float)(unsigned __int8)v96);
        v99 = (unsigned int)(float)(v100 * (float)(unsigned __int8)v99);
        goto LABEL_100;
      }
      if ( v86 == 490 && (*((_BYTE *)&v2->m_nVehicleFlags + 5) & 0x80) != 0 )
      {
        Coors.yx = 1.2;
        Coors.xx = 0.0;
        Coors.zx = 0.5;
        if ( BYTE1(CTimer::m_snTimeInMilliseconds) << 31 )
        {
          v87 = pVehicle->m_pMat;
          if ( TheCamera.m_pMat )
          {
            xy = TheCamera.m_pMat->xy;
            yy = TheCamera.m_pMat->yy;
            zy = TheCamera.m_pMat->zy;
          }
          else
          {
            m_heading = TheCamera.m_transform.m_heading;
            v222 = sinf(TheCamera.m_transform.m_heading);
            yy = cosf(m_heading);
            v85 = pVehicle;
            zy = 0.0;
            LODWORD(xy) = LODWORD(v222) ^ 0x80000000;
          }
          if ( (float)((float)((float)(xy * v87->xy) + (float)(yy * v87->yy)) + (float)(zy * v87->zy)) < 0.0 )
          {
            CCoronas::RegisterCorona(
              (u_native)&v85->m_pMat + 1,
              v85,
              0,
              0,
              0xFFu,
              0xFFu,
              (const CVector *)&Coors,
              0.4,
              TheCamera.LODDistMultiplier * 150.0,
              0,
              0,
              0,
              0,
              0,
              0.0,
              0,
              1.5,
              0,
              15.0,
              0,
              1);
LABEL_88:
            v85 = pVehicle;
          }
        }
      }
LABEL_109:
      v116 = v85->m_nModelIndex;
      if ( v116 != -2 )
      {
        v117 = v116 == 432;
        if ( v116 != 432 )
          v117 = v116 == 441;
        if ( !v117
          && !(*(unsigned __int8 *)(nWheelState + 4) >> 7)
          && CVehicle::GetVehicleAppearance(pVehicle) != APR_HELI )
        {
          v118 = pVehicle->m_nModelIndex;
          v119 = v118 == 532;
          if ( v118 != 532 )
            v119 = v118 == 471;
          if ( v119 )
            v120 = 0;
          else
            v120 = 3;
          CVehicle::DoVehicleLights(pVehicle, pVehicle->m_pMat, v120);
        }
      }
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      v122 = pVehicle;
      if ( pVehicle != PlayerVehicle
        || (LookingForwardFirstPerson = CCamera::GetLookingForwardFirstPerson(&TheCamera),
            v122 = pVehicle,
            !LookingForwardFirstPerson) )
      {
        if ( (*(_BYTE *)(nWheelState + 4) & 0x80) != 0 && v122->m_vehicleType )
        {
          v124 = v122;
          v125 = VEHICLE_SHADOW_RCBARON;
        }
        else
        {
          v124 = v122;
          v125 = VEHICLE_SHADOW_CAR;
        }
        CShadows::StoreShadowForVehicle(v124, v125);
        v122 = pVehicle;
      }
      Coors.m_pRwMat = 0;
      Coors.m_owner = 0;
      v126 = v122->m_nModelIndex;
      v227 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[v126];
      if ( v126 == 432 )
      {
        CVehicle::SetComponentRotation(
          v122,
          (RwFrame_0 *)LODWORD(v122[1].m_vecDamageNormal.y),
          2,
          *(float *)&v122[1].AutoPilot.VeryOldLink.Address,
          1);
        v122 = pVehicle;
      }
      m_fSteerAngle = v122->m_fSteerAngle;
      v128 = v122->m_pMat;
      mFlags = v122->pHandling->mFlags;
      v.z = 0.0;
      v.y = cosf(m_fSteerAngle);
      LODWORD(v.x) = COERCE_UNSIGNED_INT(sinf(m_fSteerAngle)) ^ 0x80000000;
      Multiply3x3(&v236, v128, &v);
      v130 = (CAutomobile *)pVehicle;
      v131 = pVehicle->m_pMat;
      v132 = *(_QWORD *)&v131->xy;
      vecForward.z = v131->zy;
      *(_QWORD *)&vecForward.x = v132;
      hFlagsLocal = pVehicle->hFlagsLocal;
      if ( (hFlagsLocal & 0x20) != 0 )
      {
        v136 = *(_QWORD *)&v131->xy;
        v236.z = v131->zy;
        *(_QWORD *)&v236.x = v136;
        v137 = pVehicle->m_fSteerAngle;
        posn.z = 0.0;
        posn.y = cosf(v137);
        v135 = sinf(v137);
      }
      else
      {
        if ( (hFlagsLocal & 0x40) == 0 )
          goto LABEL_138;
        m_f2ndSteerAngle = pVehicle->m_f2ndSteerAngle;
        if ( m_f2ndSteerAngle == 0.0 )
          goto LABEL_138;
        posn.z = 0.0;
        posn.y = cosf(m_f2ndSteerAngle);
        LODWORD(v135) = COERCE_UNSIGNED_INT(sinf(m_f2ndSteerAngle)) ^ 0x80000000;
      }
      posn.x = v135;
      Multiply3x3(&v, v131, &posn);
      v130 = (CAutomobile *)pVehicle;
      vecForward = v;
LABEL_138:
      *(_DWORD *)v230 = v130->m_aWheelState;
      v138 = mFlags & 0x2000000;
      p_v = &v;
      v140 = 0;
      v141 = 2056;
      v142 = 0;
      nWheelState = v138;
      do
      {
        v143 = (float *)((char *)v130 + v141);
        if ( *(float *)((char *)&v130->_vptr$CPlaceable + v141) > 0.0 )
        {
          v144 = v142 | 2;
          v145 = v138 == WS_ROLLING;
          if ( v138 )
            v145 = v144 == 2;
          if ( v145 )
          {
            v146 = v130->m_pMat;
            p_x = &v146->tx;
            if ( !v146 )
              p_x = &v130->m_transform.m_translate.x;
            v148 = p_x[2];
            v149 = v130;
            v245.x = v130->m_aWheelColPoints[v140].m_vecPosition.x - *p_x;
            v245.y = v130->m_aWheelColPoints[v140].m_vecPosition.y - p_x[1];
            *(float *)B = v130->m_aWheelColPoints[v140].m_vecPosition.z - v148;
            CPhysical::GetSpeed(&posn, v130, v245);
            v150 = *(_QWORD *)&posn.x;
            p_v->z = posn.z;
            *(_QWORD *)&p_v->x = v150;
            if ( v144 == 2 )
            {
              p_m_wheelScaleRear = &v227->m_wheelScaleRear;
              p_vecForward = &v236;
              if ( v144 == 2 )
                p_m_wheelScaleRear = &v227->m_wheelScale;
            }
            else
            {
              p_m_wheelScaleRear = &v227->m_wheelScaleRear;
              p_vecForward = &vecForward;
            }
            v153 = CVehicle::ProcessWheelRotation(
                     v149,
                     *(tWheelState *)(*(_DWORD *)v230 + 4 * v142),
                     p_vecForward,
                     p_v,
                     *p_m_wheelScaleRear * 0.5);
            v143[21] = v153;
            v143[13] = v143[13] + (float)(v153 * CTimer::ms_fTimeStep);
            v138 = nWheelState;
            v130 = (CAutomobile *)pVehicle;
          }
        }
        ++v142;
        ++p_v;
        v141 += 4;
        ++v140;
      }
      while ( v142 != 4 );
      v154 = 0;
      if ( v130->m_nModelIndex == 432 )
        v154 = 7;
      CAutomobile::UpdateWheelMatrix(v130, 2, v154);
      CAutomobile::UpdateWheelMatrix((CAutomobile *)pVehicle, 5, v154);
      CAutomobile::UpdateWheelMatrix((CAutomobile *)pVehicle, 4, v154);
      CAutomobile::UpdateWheelMatrix((CAutomobile *)pVehicle, 7, v154);
      v155 = pVehicle;
      if ( pVehicle[1].m_listEntryInfo.m_pHead )
      {
        CAutomobile::UpdateWheelMatrix((CAutomobile *)pVehicle, 3, v154);
        v155 = pVehicle;
      }
      if ( v155[1].m_aCollisionRecordPtrs[0] )
      {
        CAutomobile::UpdateWheelMatrix((CAutomobile *)v155, 6, v154);
        v155 = pVehicle;
      }
      if ( v155->m_nModelIndex == 432 )
      {
        p_m_ListenerVolume = &v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_ListenerVolume;
        p_m_nPlayTime = (float *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_nPlayTime;
        p_m_FrameDelay = (float *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_FrameDelay;
        p_m_Doppler = &v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_Doppler;
      }
      else
      {
        CAutomobile::ProcessSwingingDoor((CAutomobile *)v155, 10, FRONT_LEFT_DOOR_0);
        CAutomobile::ProcessSwingingDoor((CAutomobile *)pVehicle, 8, FRONT_RIGHT_DOOR_0);
        CAutomobile::ProcessSwingingDoor((CAutomobile *)pVehicle, 11, REAR_LEFT_DOOR_0);
        CAutomobile::ProcessSwingingDoor((CAutomobile *)pVehicle, 9, REAR_RIGHT_DOOR_0);
        CAutomobile::ProcessSwingingDoor((CAutomobile *)pVehicle, 16, BONNET_0);
        CAutomobile::ProcessSwingingDoor((CAutomobile *)pVehicle, 17, BOOT_0);
        v155 = pVehicle;
        z_low = SLOWORD(pVehicle[1].m_vecAttachPosnOffset.z);
        if ( z_low >= 0 )
        {
          v242 = *(CVector *)&pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_fDistanceFromCameraLastFrame;
          *(_DWORD *)&B[8] = *(_DWORD *)&pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_bCurrentlyInUse;
          *(_QWORD *)&B[12] = *(_QWORD *)&pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_nPlayTime;
          CBouncingPanel::ProcessPanel(
            (CBouncingPanel *)&pVehicle[1].m_vecAttachPosnOffset.z,
            pVehicle,
            *((RwFrame_0 **)&pVehicle[1].m_vecCOM.x + z_low),
            v242,
            *(CVector *)&B[8],
            -1.0,
            -1.0);
          v155 = pVehicle;
        }
        m_pNOCollisionVehicle_low = SLOWORD(v155[1].m_pNOCollisionVehicle);
        if ( m_pNOCollisionVehicle_low > -1 )
        {
          v243 = *(CVector *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_fDistanceFromCameraLastFrame;
          *(_DWORD *)&B[8] = *(_DWORD *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_bCurrentlyInUse;
          *(_QWORD *)&B[12] = *(_QWORD *)&pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_nPlayTime;
          CBouncingPanel::ProcessPanel(
            (CBouncingPanel *)&v155[1].m_pNOCollisionVehicle,
            pVehicle,
            *((RwFrame_0 **)&pVehicle[1].m_vecCOM.x + m_pNOCollisionVehicle_low),
            v243,
            *(CVector *)&B[8],
            -1.0,
            -1.0);
          v155 = pVehicle;
        }
        m_pPhysicalEntity_low = SLOWORD(v155[1].m_VehicleAudioEntity.ScratchSound.m_pPhysicalEntity);
        p_m_ListenerVolume = &v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_ListenerVolume;
        p_m_nPlayTime = (float *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_nPlayTime;
        p_m_FrameDelay = (float *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_FrameDelay;
        p_m_Doppler = &v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_Doppler;
        if ( m_pPhysicalEntity_low > -1 )
        {
          v244 = *(CVector *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_fDistanceFromCameraLastFrame;
          *(_DWORD *)&B[8] = *(_DWORD *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_bCurrentlyInUse;
          *(_QWORD *)&B[12] = *(_QWORD *)&pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_nPlayTime;
          CBouncingPanel::ProcessPanel(
            (CBouncingPanel *)&v155[1].m_VehicleAudioEntity.ScratchSound.m_pPhysicalEntity,
            pVehicle,
            *((RwFrame_0 **)&pVehicle[1].m_vecCOM.x + m_pPhysicalEntity_low),
            v244,
            *(CVector *)&B[8],
            -1.0,
            -1.0);
          v155 = pVehicle;
        }
        if ( HIBYTE(v155[1].m_VehicleAudioEntity.ScratchSound.m_PositionLastFrame.x) == 1 )
        {
          v163 = 4;
          if ( v155->m_nModelIndex == 544 )
            v163 = 84;
          v164 = *(_DWORD *)((char *)&v155[1].m_vecCOM.x + v163);
          if ( v164 )
          {
            CMatrix::Attach(&Coors, (RwMatrix *)(v164 + 16), 0);
            posn = *(CVector *)&Coors.tx;
            memset(&v234, 0, sizeof(v234));
            Multiply3x3(&v233, v155->m_pMat, &posn);
            CDoor::Process(
              (CDoor *)&v155[1].m_VehicleAudioEntity.ScratchSound.m_Position.y,
              v155,
              (CVector *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_fDistanceFromCameraLastFrame,
              (CVector *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_bCurrentlyInUse,
              &v233);
            *((_DWORD *)&v234.x + BYTE2(v155[1].m_VehicleAudioEntity.ScratchSound.m_PositionLastFrame.x)) = LODWORD(v155[1].m_VehicleAudioEntity.ScratchSound.m_PositionLastFrame.y);
            CMatrix::SetRotate(&Coors, v234.x, v234.y, v234.z);
            if ( v155->m_nModelIndex == 544 )
              CMatrix::RotateX(
                &Coors,
                (float)LOWORD(pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity) * -0.0001);
            Coors.tx = posn.x + Coors.tx;
            Coors.ty = posn.y + Coors.ty;
            Coors.tz = posn.z + Coors.tz;
            CMatrix::UpdateRW(&Coors);
            v155 = pVehicle;
          }
        }
      }
      v165 = v155->m_vecMoveSpeed.x;
      v166 = v155->m_vecMoveSpeed.y;
      v167 = v155->m_vecMoveSpeed.z;
      v168 = v166 + v155->m_vecMoveFriction.y;
      v169 = v167 + v155->m_vecMoveFriction.z;
      v170 = v155->m_vecTurnSpeed.x + v155->m_vecTurnFriction.x;
      v171 = v155->m_vecTurnSpeed.z;
      v172 = v155->m_vecTurnFriction.z;
      v173 = v155->m_vecTurnSpeed.y + v155->m_vecTurnFriction.y;
      v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_fDistanceFromCameraLastFrame = v165
                                                                                           + v155->m_vecMoveFriction.x;
      *p_m_Doppler = v168;
      *p_m_FrameDelay = v169;
      *(float *)&v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_bCurrentlyInUse = v170;
      *p_m_nPlayTime = v173;
      *p_m_ListenerVolume = v171 + v172;
      v174 = v155->m_nModelIndex;
      v175 = (unsigned __int16)v174;
      if ( v174 >= 568 )
      {
        if ( v174 == 568 )
        {
LABEL_186:
          CEntity::GetColModel(v155);
          v184 = pVehicle;
          v185 = pVehicle[1].m_vecDamagePos.z;
          if ( v185 != 0.0 )
          {
            CMatrix::Attach(&Coors, (RwMatrix *)(LODWORD(v185) + 16), 0);
            posn = *(CVector *)&Coors.tx;
            Coors.zx = (float)(*(float *)&pVehicle[1].m_VehicleAudioEntity.m_RoadNoiseSoundID
                             - (float)(*(float *)(*(_DWORD *)(v226 + 16) + 8)
                                     - pVehicle->pHandling->fSuspensionUpperLimit))
                     / (float)(**(float **)(v226 + 16) - Coors.tx);
            CMatrix::UpdateRW(&Coors);
            v184 = pVehicle;
          }
          m_pAttachToEntity = v184[1].m_pAttachToEntity;
          if ( m_pAttachToEntity )
          {
            CMatrix::Attach(&Coors, (RwMatrix *)&m_pAttachToEntity->m_transform.m_heading, 0);
            posn = *(CVector *)&Coors.tx;
            Coors.zx = (float)(*(float *)&pVehicle[1].m_VehicleAudioEntity.m_RoadNoiseSoundPtr
                             - (float)(*(float *)(*(_DWORD *)(v226 + 16) + 40)
                                     - pVehicle->pHandling->fSuspensionUpperLimit))
                     / (float)(*(float *)(*(_DWORD *)(v226 + 16) + 32) - Coors.tx);
            CMatrix::UpdateRW(&Coors);
            v184 = pVehicle;
          }
          v187 = *(_DWORD *)&v184[1].m_nDamagedPieceType;
          if ( v187 )
          {
            CMatrix::Attach(&Coors, (RwMatrix *)(v187 + 16), 0);
            posn = *(CVector *)&Coors.tx;
            Coors.zx = (float)(*(float *)&pVehicle[1].m_VehicleAudioEntity.m_FlatTyreSoundID
                             - (float)(*(float *)(*(_DWORD *)(v226 + 16) + 72)
                                     - pVehicle->pHandling->fSuspensionUpperLimit))
                     / (float)(*(float *)(*(_DWORD *)(v226 + 16) + 64) - Coors.tx);
            CMatrix::UpdateRW(&Coors);
            v184 = pVehicle;
          }
          v188 = v184[1].m_vecAttachPosnOffset.x;
          if ( v188 != 0.0 )
          {
            CMatrix::Attach(&Coors, (RwMatrix *)(LODWORD(v188) + 16), 0);
            posn = *(CVector *)&Coors.tx;
            Coors.zx = (float)(*(float *)&pVehicle[1].m_VehicleAudioEntity.m_FlatTyreSoundPtr
                             - (float)(*(float *)(*(_DWORD *)(v226 + 16) + 104)
                                     - pVehicle->pHandling->fSuspensionUpperLimit))
                     / (float)(*(float *)(*(_DWORD *)(v226 + 16) + 96) - Coors.tx);
            CMatrix::UpdateRW(&Coors);
            v184 = pVehicle;
          }
          v189 = 0.3;
          if ( v184->m_fGasPedal != 0.0 )
            v189 = 0.5;
          CVehicle::SetComponentRotation(
            v184,
            (RwFrame_0 *)LODWORD(v184[1].m_vecAttachPosnOffset.y),
            1,
            CTimer::ms_fTimeStep * v189,
            0);
        }
        else
        {
          if ( v174 != 601 )
            goto LABEL_217;
LABEL_185:
          CVehicle::SetComponentRotation(
            v155,
            (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z),
            2,
            *(float *)&v155[1].AutoPilot.VeryOldLink.Address,
            1);
          v181 = *(float *)&pVehicle[1].AutoPilot.LastTimeNotStuck;
          v182 = *(RwFrame_0 **)&pVehicle[1].m_nDamagedPieceType;
          v183 = pVehicle;
LABEL_214:
          CVehicle::SetComponentRotation(v183, v182, 0, v181, 1);
        }
      }
      else
      {
        switch ( v155->m_nModelIndex )
        {
          case 0x1A8:
            v176 = 0.3;
            if ( v155->m_fGasPedal != 0.0 )
              v176 = 0.5;
            v177 = CTimer::ms_fTimeStep * v176;
            CVehicle::SetComponentRotation(
              v155,
              (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z),
              1,
              CTimer::ms_fTimeStep * v176,
              0);
            CVehicle::SetComponentRotation(
              pVehicle,
              (RwFrame_0 *)LODWORD(pVehicle[1].m_vecAttachPosnOffset.y),
              1,
              v177 * 1.5,
              0);
            CEntity::GetColModel(pVehicle);
            v178 = pVehicle;
            v179 = *(_DWORD *)&pVehicle[1].m_nDamagedPieceType;
            if ( v179 )
            {
              CMatrix::Attach(&Coors, (RwMatrix *)(v179 + 16), 0);
              posn = *(CVector *)&Coors.tx;
              Coors.zy = (float)(*(float *)&pVehicle[1].m_VehicleAudioEntity.m_RoadNoiseSoundID
                               - (float)(*(float *)(*(_DWORD *)(v226 + 16) + 8)
                                       - pVehicle->pHandling->fSuspensionUpperLimit))
                       / (float)(*(float *)(*(_DWORD *)(v226 + 16) + 4) - Coors.ty);
              CMatrix::UpdateRW(&Coors);
              v178 = pVehicle;
            }
            v180 = v178[1].m_pAttachToEntity;
            v155 = v178;
            if ( v180 )
            {
              CMatrix::Attach(&Coors, (RwMatrix *)&v180->m_transform.m_heading, 0);
              posn = *(CVector *)&Coors.tx;
              Coors.zy = (float)(*(float *)&v155[1].m_VehicleAudioEntity.m_FlatTyreSoundID
                               - (float)(*(float *)(*(_DWORD *)(v226 + 16) + 72) - v155->pHandling->fSuspensionUpperLimit))
                       / (float)(*(float *)(*(_DWORD *)(v226 + 16) + 68) - Coors.ty);
              CMatrix::UpdateRW(&Coors);
            }
            CVehicleModelInfo::GetWheelPosn(v227, 1, &posn, 0);
            CVehicle::SetTransmissionRotation(
              v155,
              (RwFrame_0 *)LODWORD(v155[1].m_vecAttachPosnOffset.x),
              *(float *)&v155[1].m_VehicleAudioEntity.m_RoadNoiseSoundPtr,
              *(float *)&v155[1].m_VehicleAudioEntity.m_FlatTyreSoundPtr,
              SLODWORD(posn.x),
              posn.y,
              posn.z,
              0);
            goto LABEL_216;
          case 0x1A9:
          case 0x1AA:
          case 0x1AB:
          case 0x1AC:
          case 0x1AD:
          case 0x1AE:
          case 0x1AF:
          case 0x1B1:
          case 0x1B3:
          case 0x1B4:
          case 0x1B5:
          case 0x1B6:
          case 0x1B7:
          case 0x1B8:
          case 0x1B9:
          case 0x1BA:
          case 0x1BC:
          case 0x1BD:
          case 0x1BE:
          case 0x1BF:
          case 0x1C0:
          case 0x1C1:
          case 0x1C2:
          case 0x1C3:
          case 0x1C4:
          case 0x1C5:
          case 0x1C6:
          case 0x1C7:
          case 0x1C8:
          case 0x1C9:
          case 0x1CA:
          case 0x1CB:
          case 0x1CC:
          case 0x1CD:
          case 0x1CE:
          case 0x1CF:
          case 0x1D0:
          case 0x1D1:
          case 0x1D2:
          case 0x1D3:
          case 0x1D4:
          case 0x1D5:
          case 0x1D6:
          case 0x1D7:
          case 0x1D8:
          case 0x1D9:
          case 0x1DA:
          case 0x1DB:
          case 0x1DC:
          case 0x1DE:
          case 0x1DF:
          case 0x1E0:
          case 0x1E1:
          case 0x1E2:
          case 0x1E3:
          case 0x1E4:
          case 0x1E5:
          case 0x1E7:
          case 0x1E8:
          case 0x1E9:
          case 0x1EA:
          case 0x1EB:
          case 0x1EC:
          case 0x1ED:
          case 0x1EE:
          case 0x1EF:
          case 0x1F0:
          case 0x1F1:
          case 0x1F2:
          case 0x1F3:
          case 0x1F4:
          case 0x1F5:
          case 0x1F6:
          case 0x1F7:
          case 0x1F8:
          case 0x1F9:
          case 0x1FA:
          case 0x1FB:
          case 0x1FC:
          case 0x1FD:
          case 0x1FE:
          case 0x1FF:
          case 0x200:
          case 0x201:
          case 0x202:
          case 0x203:
          case 0x204:
          case 0x205:
          case 0x206:
          case 0x207:
          case 0x208:
          case 0x209:
          case 0x20A:
          case 0x20B:
          case 0x20E:
          case 0x20F:
          case 0x210:
          case 0x211:
            goto LABEL_217;
          case 0x1B0:
            goto LABEL_185;
          case 0x1B2:
            goto LABEL_186;
          case 0x1BB:
            m_pAudioEntity_low = LOWORD(v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity);
            v191 = -0.0001;
            goto LABEL_202;
          case 0x1DD:
            v181 = *(float *)&v155[1].AutoPilot.InvertDirVeryOldLink;
            goto LABEL_213;
          case 0x1E6:
            m_pAudioEntity_low = LOWORD(v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity);
            v191 = 0.0002;
LABEL_202:
            v192 = (float)m_pAudioEntity_low * v191;
            goto LABEL_212;
          case 0x20C:
            if ( (*(_BYTE *)&v155->m_info & 0xF8) == 40 )
              goto LABEL_216;
            CVehicle::SetComponentRotation(v155, (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z), 0, -0.17453, 1);
            v193 = *(RwFrame_0 **)&pVehicle[1].m_nDamagedPieceType;
            v194 = *(float *)&pVehicle[1].AutoPilot.InvertDirVeryOldLink
                 + (float)(CTimer::ms_fTimeStep
                         * (float)((float)((float)((float)LOWORD(pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity)
                                                 / (float)DEFAULT_COLLISION_EXTENDLIMIT)
                                         + 0.5)
                                 * 0.02));
            *(float *)&pVehicle[1].AutoPilot.InvertDirVeryOldLink = v194;
            CVehicle::SetComponentRotation(pVehicle, v193, 1, v194, 1);
            CVehicle::SetComponentRotation(pVehicle, *(RwFrame_0 **)&pVehicle[1].m_nDamagedPieceType, 0, -0.17453, 0);
            break;
          case 0x20D:
            v195 = (float)TOWTRUCK_HOIST_DOWN_LIMIT;
            v196 = TOWTRUCK_ROT_ANGLE
                 * (float)LOWORD(v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity);
            CVehicle::SetComponentRotation(v155, (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z), 0, v196 / v195, 1);
            v155 = pVehicle;
            m_pVehicleBeingTowed = pVehicle->m_pVehicleBeingTowed;
            if ( m_pVehicleBeingTowed )
            {
              if ( (*((int (__fastcall **)(CVehicle *, CVector *, int, CVehicle *))m_pVehicleBeingTowed->_vptr$CPlaceable
                    + 60))(
                     m_pVehicleBeingTowed,
                     &v234,
                     1,
                     pVehicle) == 1
                && (*((int (__fastcall **)(CVehicle *, CVector *, int, CVehicle *))pVehicle->_vptr$CPlaceable + 61))(
                     pVehicle,
                     &v233,
                     1,
                     pVehicle->m_pVehicleBeingTowed) == 1 )
              {
                v234.x = v234.x - v233.x;
                v234.y = v234.y - v233.y;
                v234.z = v234.z - v233.z;
                v198 = asinf(
                         (float)((float)((float)(v234.x * pVehicle->m_pMat->xy) + (float)(v234.y * pVehicle->m_pMat->yy))
                               + (float)(v234.z * pVehicle->m_pMat->zy))
                       / TOWTRUCK_WIRE_LENGTH);
                v199 = 0;
                CVehicle::SetComponentRotation(
                  pVehicle,
                  *(RwFrame_0 **)&pVehicle[1].m_nDamagedPieceType,
                  0,
                  v198 - (float)(v196 / v195),
                  1);
                v200 = asinf(
                         (float)-(float)((float)((float)(v234.x * pVehicle->m_pMat->xx)
                                               + (float)(v234.y * pVehicle->m_pMat->yx))
                                       + (float)(v234.z * pVehicle->m_pMat->zx))
                       / TOWTRUCK_WIRE_LENGTH);
                v201 = *(float *)&pVehicle[1].m_nDamagedPieceType;
LABEL_233:
                CVehicle::SetComponentRotation(v155, (RwFrame_0 *)LODWORD(v201), 1, v200, v199);
              }
              goto LABEL_216;
            }
            CVehicle::SetComponentRotation(
              pVehicle,
              *(RwFrame_0 **)&pVehicle[1].m_nDamagedPieceType,
              0,
              -(float)(v196 / v195),
              1);
            v155 = pVehicle;
            if ( LOWORD(pVehicle[1].m_vecAttachPosnOffset.z) != 21 )
              goto LABEL_216;
            CMatrix::Attach(&Coors, (RwMatrix *)(*(_DWORD *)&pVehicle[1].m_nDamagedPieceType + 16), 0);
            Coors.yz = pVehicle[1].m_vecAttachTiltOffset.y + Coors.yz;
            Coors.xz = pVehicle[1].m_vecAttachTiltOffset.z + Coors.xz;
LABEL_236:
            CMatrix::UpdateRW(&Coors);
            break;
          case 0x212:
            if ( !LODWORD(v155[1].m_vecDamagePos.z) )
              goto LABEL_216;
            FrameFromId = CClumpModelInfo::GetFrameFromId(
                            (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[530]->m_pRwObject,
                            20);
            v203 = *(_QWORD *)&FrameFromId->modelling.pos.x;
            v204 = FrameFromId->modelling.pos.z;
            v205 = LOWORD(pVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity);
            CMatrix::Attach(&Coors, (RwMatrix *)(LODWORD(pVehicle[1].m_vecDamagePos.z) + 16), 0);
            CMatrix::SetTranslateOnly(
              &Coors,
              *(float *)&v203,
              *((float *)&v203 + 1),
              v204 + (float)((float)v205 * 0.0006));
            goto LABEL_236;
          case 0x213:
            v192 = (float)(TOWTRUCK_ROT_ANGLE
                         * (float)LOWORD(v155[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity))
                 / (float)TOWTRUCK_HOIST_DOWN_LIMIT;
LABEL_212:
            v181 = v192;
LABEL_213:
            v182 = (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z);
            v183 = v155;
            goto LABEL_214;
          case 0x214:
            p_InvertDirVeryOldLink = (float *)&v155[1].AutoPilot.InvertDirVeryOldLink;
            v207 = 0.0;
            v208 = *(float *)&v155[1].AutoPilot.InvertDirVeryOldLink;
            if ( v208 > 6.2832 )
            {
              v208 = v208 + -6.2832;
              *p_InvertDirVeryOldLink = v208;
            }
            v209 = (float)((float)(v165 * v155->m_pMat->xy) + (float)(v166 * v155->m_pMat->yy))
                 + (float)(v167 * v155->m_pMat->zy);
            if ( v209 > 0.1 || (v210 = 0.0, v209 >= 0.0) )
            {
              v210 = 0.1;
              if ( v209 <= 0.1 )
                v210 = v209;
            }
            v199 = 1;
            v211 = v208 - (float)(v210 * CTimer::ms_fTimeStep);
            *p_InvertDirVeryOldLink = v211;
            CVehicle::SetComponentRotation(v155, *(RwFrame_0 **)&v155[1].m_nDamagedPieceType, 0, v211, 1);
            CVehicleModelInfo::GetWheelPosn(v227, 0, &v234, 0);
            CMatrix::Attach(&Coors, (RwMatrix *)(LODWORD(pVehicle[1].m_vecDamagePos.z) + 16), 0);
            posn = *(CVector *)&Coors.tx;
            v212 = *(float *)&pVehicle[1].m_VehicleAudioEntity.m_FlatTyreSoundID;
            v213 = *(float *)&pVehicle[1].m_VehicleAudioEntity.m_RoadNoiseSoundID;
            v214 = atan2f((float)((float)(v213 + v212) * 0.5) - v234.z, Coors.ty - v234.y);
            v215 = fabsf(v234.x);
            v216 = 3.1416 - v214;
            v217 = atan2f(v213 - v212, v215 + v215);
            CVehicle::SetComponentRotation(pVehicle, (RwFrame_0 *)LODWORD(pVehicle[1].m_vecDamagePos.z), 0, v216, 1);
            CVehicle::SetComponentRotation(pVehicle, (RwFrame_0 *)LODWORD(pVehicle[1].m_vecDamagePos.z), 1, v217, 0);
            v218 = pVehicle->m_pMat;
            if ( v218->zz > 0.0 )
            {
              v219 = pVehicle->m_nGettingInFlags == 0;
              if ( !pVehicle->m_nGettingInFlags )
                v219 = pVehicle->m_nGettingOutFlags == 0;
              if ( v219 )
              {
                v223 = asinf(v218->zx);
                v207 = 0.5236;
                if ( v223 <= 0.5236 )
                {
                  v207 = v223;
                  if ( v223 < -0.5236 )
                    v207 = -0.5236;
                }
              }
            }
            v220 = powf(0.95, CTimer::ms_fTimeStep);
            v155 = pVehicle;
            v201 = pVehicle[1].m_vecCOM.y;
            v200 = (float)(v220 * *(float *)&pVehicle[1].AutoPilot.VeryOldLink.Address)
                 + (float)(v207 * (float)(1.0 - v220));
            *(float *)&pVehicle[1].AutoPilot.VeryOldLink.Address = v200;
            goto LABEL_233;
          default:
            if ( v174 != 407 )
              goto LABEL_217;
            CVehicle::SetComponentRotation(
              v155,
              (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z),
              0,
              *(float *)&v155[1].AutoPilot.LastTimeNotStuck,
              1);
            CVehicle::SetComponentRotation(
              pVehicle,
              (RwFrame_0 *)LODWORD(pVehicle[1].m_vecDamagePos.z),
              2,
              *(float *)&pVehicle[1].AutoPilot.VeryOldLink.Address,
              0);
            break;
        }
      }
      v155 = pVehicle;
LABEL_216:
      v175 = (unsigned __int16)v155->m_nModelIndex;
LABEL_217:
      if ( v175 == 495 || (v155->hFlagsLocal & 0x30000) == 196608 && v155->m_vehicleType != 1 )
      {
        CVehicleModelInfo::GetWheelPosn(v227, 0, &posn, 0);
        CVehicle::SetTransmissionRotation(
          v155,
          (RwFrame_0 *)LODWORD(v155[1].m_vecDamagePos.z),
          *(float *)&v155[1].m_VehicleAudioEntity.m_RoadNoiseSoundID,
          *(float *)&v155[1].m_VehicleAudioEntity.m_FlatTyreSoundID,
          SLODWORD(posn.x),
          posn.y,
          posn.z,
          1);
        CVehicleModelInfo::GetWheelPosn(v227, 1, &posn, 0);
        CVehicle::SetTransmissionRotation(
          v155,
          *(RwFrame_0 **)&v155[1].m_nDamagedPieceType,
          *(float *)&v155[1].m_VehicleAudioEntity.m_RoadNoiseSoundPtr,
          *(float *)&v155[1].m_VehicleAudioEntity.m_FlatTyreSoundPtr,
          SLODWORD(posn.x),
          posn.y,
          posn.z,
          0);
      }
      CMatrix::~CMatrix(&Coors);
      return;
  }
}
// 559D44: variables would overlap: ^0.20 and 0:r2.8,8:^0.4

//----- (0055BB8C) --------------------------------------------------------
void __fastcall CAutomobile::Render(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d9
  void (__fastcall *v4)(RwObject_0 *); // r5
  RwObject_0 *FirstObject; // r0
  void (__fastcall *v6)(RwObject_0 *); // r5
  RwObject_0 *v7; // r0
  void (__fastcall *v8)(RwObject_0 *); // r5
  RwObject_0 *v9; // r0
  void (__fastcall *v10)(RwObject_0 *); // r5
  RwObject_0 *v11; // r0
  RwFrame_0 *v12; // r0
  void (__fastcall *v13)(RwObject_0 *); // r5
  RwObject_0 *v14; // r0
  RwFrame_0 *v15; // r0
  void (__fastcall *v16)(RwObject_0 *); // r5
  RwObject_0 *v17; // r0
  int v18; // r11
  float m_fClosedAngle; // r1
  int v20; // r8
  float m_fPrevAngle; // r2
  unsigned __int32 *v22; // r10
  float v23; // r2
  float v24; // r2
  float *p_x; // r0
  float v26; // s3
  float v27; // s10
  float v28; // s4
  float v29; // s2
  RwFrame_0 *v30; // r0
  float v31; // s10
  RwReal v32; // s2
  void (__fastcall *v33)(RwObject_0 *); // r9
  RwObject_0 *v34; // r0
  RwFrame_0 *v35; // r0
  RwFrame_0 *v36; // r0
  float z; // s10
  RwReal v38; // s2
  void (__fastcall *v39)(RwObject_0 *); // r4
  RwObject_0 *v40; // r0
  int m_nModelIndex; // r0
  bool v42; // zf
  char v43; // r0
  CCollisionData *m_pColData; // [sp+8h] [bp-78h]
  RwV3d_0 translation; // [sp+10h] [bp-70h] BYREF
  float m_fOpenAngle; // [sp+2Ch] [bp-54h]
  _DWORD v47[7]; // [sp+30h] [bp-50h] BYREF
  void *value; // [sp+4Ch] [bp-34h] BYREF

  this->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds + 3000;
  value = &dword_0 + 1;
  RwRenderStateGet(rwRENDERSTATEALPHATESTFUNCTIONREF, &value);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 1);
  if ( CCheat::m_aCheatsActive[34] )
  {
    v4 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aCarNodes[4])[9].type;
    FirstObject = GetFirstObject(this->m_aCarNodes[4]);
    v4(FirstObject);
    v6 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aCarNodes[7])[9].type;
    v7 = GetFirstObject(this->m_aCarNodes[7]);
    v6(v7);
    v8 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aCarNodes[2])[9].type;
    v9 = GetFirstObject(this->m_aCarNodes[2]);
    v8(v9);
    v10 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aCarNodes[5])[9].type;
    v11 = GetFirstObject(this->m_aCarNodes[5]);
    v10(v11);
    v12 = this->m_aCarNodes[3];
    if ( v12 )
    {
      v13 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(v12)[9].type;
      v14 = GetFirstObject(this->m_aCarNodes[3]);
      v13(v14);
    }
    v15 = this->m_aCarNodes[6];
    if ( v15 )
    {
      v16 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(v15)[9].type;
      v17 = GetFirstObject(this->m_aCarNodes[6]);
      v16(v17);
    }
  }
  else
  {
    CVehicle::Render(this);
  }
  if ( this->m_nModelIndex == 432 )
  {
    m_pColData = CEntity::GetColModel(this)->m_pColData;
    v18 = 4;
    m_fClosedAngle = this->Door[4].m_fClosedAngle;
    v20 = 4;
    v2.n64_u32[0] = 0;
    m_fOpenAngle = this->Door[4].m_fOpenAngle;
    *(float *)v47 = m_fClosedAngle;
    m_fPrevAngle = this->Door[4].m_fPrevAngle;
    v1.n64_f32[0] = m_fOpenAngle;
    v22 = v47;
    v47[1] = LODWORD(this->Door[4].m_fAngle);
    *(float *)&v47[2] = m_fPrevAngle;
    v23 = this->Door[5].m_fClosedAngle;
    v47[3] = LODWORD(this->Door[5].m_fOpenAngle);
    *(float *)&v47[4] = v23;
    v24 = this->Door[5].m_fPrevAngle;
    v47[5] = LODWORD(this->Door[5].m_fAngle);
    *(float *)&v47[6] = v24;
    while ( 1 )
    {
      p_x = &m_pColData->_anon_1.m_pLineArray[v20].m_vecStart.x;
      v1.n64_f32[0] = v1.n64_f32[0]
                    - (float)((float)(this->m_fLineLength[0] - this->m_fSuspensionLength[0]) / this->m_fLineLength[0]);
      v1.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
      v26 = p_x[4] * v1.n64_f32[0];
      v27 = *p_x * (float)(1.0 - v1.n64_f32[0]);
      v28 = (float)(p_x[5] * v1.n64_f32[0]) + (float)((float)(1.0 - v1.n64_f32[0]) * p_x[1]);
      v1.n64_f32[0] = (float)(p_x[6] * v1.n64_f32[0]) + (float)((float)(1.0 - v1.n64_f32[0]) * p_x[2]);
      v29 = v26 + v27;
      translation.y = v28;
      translation.x = v26 + v27;
      LODWORD(translation.z) = v1.n64_u32[0];
      if ( v18 > 7 )
      {
        v36 = this->m_aCarNodes[4];
        z = v36->modelling.pos.z;
        v38 = v29 - v36->modelling.pos.x;
        translation.y = v28 - v36->modelling.pos.y;
        translation.x = v38;
        translation.z = v1.n64_f32[0] - z;
        RwMatrixTranslate(&v36->modelling, &translation, rwCOMBINEPOSTCONCAT);
        RwFrameUpdateObjects(this->m_aCarNodes[4]);
        v39 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aCarNodes[4])[9].type;
        v40 = GetFirstObject(this->m_aCarNodes[4]);
        v39(v40);
        translation.x = -translation.x;
        translation.y = -translation.y;
        translation.z = -translation.z;
        v35 = this->m_aCarNodes[4];
      }
      else
      {
        v30 = this->m_aCarNodes[7];
        v31 = v30->modelling.pos.z;
        v32 = v29 - v30->modelling.pos.x;
        translation.y = v28 - v30->modelling.pos.y;
        translation.x = v32;
        translation.z = v1.n64_f32[0] - v31;
        RwMatrixTranslate(&v30->modelling, &translation, rwCOMBINEPOSTCONCAT);
        RwFrameUpdateObjects(this->m_aCarNodes[7]);
        v33 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aCarNodes[7])[9].type;
        v34 = GetFirstObject(this->m_aCarNodes[7]);
        v33(v34);
        translation.x = -translation.x;
        translation.y = -translation.y;
        translation.z = -translation.z;
        v35 = this->m_aCarNodes[7];
      }
      RwMatrixTranslate(&v35->modelling, &translation, rwCOMBINEPOSTCONCAT);
      if ( v18 == 11 )
        break;
      ++v18;
      ++v20;
      v1.n64_u32[0] = *v22++;
    }
  }
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, value);
  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex != -2 )
  {
    v42 = m_nModelIndex == 432;
    if ( m_nModelIndex != 432 )
      v42 = m_nModelIndex == 441;
    if ( !v42
      && !(*((unsigned __int8 *)&this->m_nVehicleFlags + 4) >> 7)
      && CVehicle::GetVehicleAppearance(this) != APR_HELI )
    {
      v43 = *((_BYTE *)&this->CVehicle + 1428);
      if ( (v43 & 1) != 0 )
      {
        CVehicle::DoHeadLightBeam(this, 0, this->m_pMat, 1u);
        v43 = *((_BYTE *)&this->CVehicle + 1428);
      }
      if ( (v43 & 2) != 0 )
        CVehicle::DoHeadLightBeam(this, 0, this->m_pMat, 0);
    }
  }
}
// 55BD04: variable 'v1' is possibly undefined
// 55BD04: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;

//----- (0055BEC0) --------------------------------------------------------
void __fastcall CAutomobile::CustomCarPlate_BeforeRenderingStart(CAutomobile *this, CVehicleModelInfo *pModelInfo)
{
  RpMaterial_0 *pCustomPlateMaterial; // r0

  pCustomPlateMaterial = pModelInfo->pCustomPlateMaterial;
  if ( pCustomPlateMaterial )
  {
    pOldMatTexture = pCustomPlateMaterial->texture;
    ++pOldMatTexture->refCount;
    sub_189DF8(pCustomPlateMaterial, this->pCustomPlateTexture);
  }
}

//----- (0055BEE4) --------------------------------------------------------
void __fastcall CAutomobile::CustomCarPlate_AfterRenderingStop(CAutomobile *this, CVehicleModelInfo *pModelInfo)
{
  RpMaterial_0 *pCustomPlateMaterial; // r0

  pCustomPlateMaterial = pModelInfo->pCustomPlateMaterial;
  if ( pCustomPlateMaterial )
  {
    RpMaterialSetTexture(pCustomPlateMaterial, pOldMatTexture);
    RwTextureDestroy(pOldMatTexture);
    pOldMatTexture = 0;
  }
}

//----- (0055BF10) --------------------------------------------------------
int32 __fastcall CAutomobile::ProcessEntityCollision(CAutomobile *this, CEntity *pEntity, CColPoint *aColPoints)
{
  float32x2_t v3; // d1
  float32x2_t v4; // d3
  float32x2_t v5; // d10
  float32x2_t v6; // d11
  CCollisionData *m_pColData; // r11
  __int64 v9; // d17
  int8 m_nNoOfLines; // r9
  __int64 v11; // d17
  int m_nModelIndex; // r3
  float m_fClosedAngle; // r2
  float m_fPrevAngle; // r2
  float v15; // r2
  float v16; // r2
  int v17; // r1
  bool v18; // zf
  CVehicle *m_pTowingVehicle; // r1
  bool v20; // zf
  int m_nNoOfTriangles; // r4
  int v22; // r5
  int32 v23; // r0
  CEntity *v24; // r0
  CMatrix *m_pMat; // r8
  CMatrix *v26; // r6
  CColModel *ColModel; // r0
  CEntity *v28; // r3
  int v29; // r8
  unsigned int v30; // r9
  int v31; // r11
  int v32; // r4
  float v33; // s0
  float *v34; // r0
  float *v35; // r6
  int v36; // r0
  bool v37; // zf
  CMatrix *v38; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v40; // s2
  float *v41; // r0
  float v42; // s4
  CEntity::CFlags v43; // kr00_8
  unsigned int v44; // r1
  int v45; // r0
  int v46; // r2
  float32x4_t v47; // q9
  float32x4_t v48; // q8
  int v49; // r4
  CEntity::CEntityInfo *p_m_info; // r9
  bool v51; // zf
  _BOOL4 v52; // r5
  _BOOL4 v53; // r6
  bool v54; // cc
  CEntity *v55; // r0
  int v56; // r1
  CColPoint *m_aWheelColPoints; // r4
  int v58; // r5
  unsigned int v59; // r6
  float *v60; // r11
  float *v61; // r9
  float v62; // s24
  int32 AdhesionGroup; // r0
  bool v64; // zf
  CColPoint *v65; // r8
  CMatrix *v66; // r0
  float32x2_t v67; // d1
  float32x2_t v68; // d1
  float v69; // s0
  unsigned int v70; // r0
  int v71; // r0
  int v73; // r5
  const CColPoint *v74; // r6
  int v75; // r4
  int v76; // r11
  CEntity::CFlags *v78; // [sp+18h] [bp-C8h]
  CEntity::CFlags *p_m_nFlags; // [sp+1Ch] [bp-C4h]
  RwReal *p_z; // [sp+20h] [bp-C0h]
  int32 v81; // [sp+24h] [bp-BCh]
  CColModel *colModelA; // [sp+30h] [bp-B0h]
  CColModel *colModelAa; // [sp+30h] [bp-B0h]
  __int64 v85[2]; // [sp+38h] [bp-A8h]
  float32x4_t v86; // [sp+48h] [bp-98h]
  float32x4_t v87; // [sp+58h] [bp-88h]
  float aLineRatios[2]; // [sp+68h] [bp-78h] BYREF
  __int64 v89; // [sp+70h] [bp-70h]
  float32x4_t v90; // [sp+78h] [bp-68h]
  float32x4_t v91; // [sp+88h] [bp-58h]

  if ( (*(_BYTE *)&this->m_info & 0xF8) != 16 )
    *(_DWORD *)&this->m_nVehicleFlags |= 0x1000000u;
  colModelA = CEntity::GetColModel(this);
  m_pColData = colModelA->m_pColData;
  v9 = *(_QWORD *)&this->m_aWheelRatios[2];
  m_nNoOfLines = m_pColData->_anon_0.m_nNoOfLines;
  *(_QWORD *)aLineRatios = *(_QWORD *)this->m_aWheelRatios;
  v89 = v9;
  v11 = *(_QWORD *)&this->m_aWheelRatios[2];
  v85[0] = *(_QWORD *)this->m_aWheelRatios;
  v85[1] = v11;
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( m_nModelIndex == 432 )
  {
    m_fClosedAngle = this->Door[4].m_fClosedAngle;
    v90.n128_u32[0] = LODWORD(this->Door[4].m_fOpenAngle);
    v90.n128_f32[1] = m_fClosedAngle;
    m_fPrevAngle = this->Door[4].m_fPrevAngle;
    v90.n128_u32[2] = LODWORD(this->Door[4].m_fAngle);
    v90.n128_f32[3] = m_fPrevAngle;
    v15 = this->Door[5].m_fClosedAngle;
    v91.n128_u32[0] = LODWORD(this->Door[5].m_fOpenAngle);
    v91.n128_f32[1] = v15;
    v16 = this->Door[5].m_fPrevAngle;
    v91.n128_u32[2] = LODWORD(this->Door[5].m_fAngle);
    v91.n128_f32[3] = v16;
    v86 = v90;
    v87 = v91;
  }
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 1) & 0x90) != 0 )
    goto LABEL_11;
  v17 = *(_BYTE *)&pEntity->m_info & 7;
  if ( v17 == 3 )
    goto LABEL_11;
  v18 = v17 == 2;
  if ( v17 == 2 )
    v18 = m_nModelIndex == 65534;
  if ( v18 )
LABEL_11:
    m_pColData->_anon_0.m_nNoOfLines = 0;
  m_pTowingVehicle = this->m_pTowingVehicle;
  v20 = m_pTowingVehicle == pEntity;
  if ( m_pTowingVehicle != pEntity )
    v20 = this->m_pVehicleBeingTowed == pEntity;
  if ( v20 )
  {
    m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
    m_pColData->m_nNoOfTriangles = 0;
    v22 = CEntity::GetColModel(pEntity)->m_pColData->m_nNoOfTriangles;
    CEntity::GetColModel(pEntity)->m_pColData->m_nNoOfTriangles = 0;
  }
  else
  {
    m_nNoOfTriangles = -1;
    v22 = -1;
  }
  if ( (*(_BYTE *)&this->m_info & 0xF8) == 96 )
  {
    v23 = 0;
  }
  else
  {
    v24 = pEntity;
    m_pMat = this->m_pMat;
    v26 = pEntity->m_pMat;
    if ( !v26 )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v24 = pEntity;
      v26 = pEntity->m_pMat;
    }
    ColModel = CEntity::GetColModel(v24);
    v23 = CCollision::ProcessColModels(
            m_pMat,
            colModelA,
            v26,
            ColModel,
            aColPoints,
            aAutomobileColPoints,
            aLineRatios,
            0);
  }
  v81 = v23;
  if ( v22 >= 0 )
    CEntity::GetColModel(pEntity)->m_pColData->m_nNoOfTriangles = v22;
  v28 = pEntity;
  if ( m_nNoOfTriangles >= 0 )
    m_pColData->m_nNoOfTriangles = m_nNoOfTriangles;
  if ( !m_pColData->_anon_0.m_nNoOfLines )
  {
    m_pColData->_anon_0.m_nNoOfLines = m_nNoOfLines;
    v49 = 0;
    v45 = (unsigned __int16)this->m_nModelIndex;
    v46 = v81;
    if ( v81 < 1 )
      goto LABEL_53;
LABEL_47:
    if ( v45 != 530 )
      goto LABEL_53;
    p_m_info = &v28->m_info;
    if ( (*(_BYTE *)&v28->m_info & 7) != 4 )
      goto LABEL_52;
    v51 = this->m_nSuspensionHydraulics == 0;
    if ( !this->m_nSuspensionHydraulics )
      v51 = this->m_nOldSuspensionHydraulics == 0;
    if ( !v51 )
    {
LABEL_52:
      v52 = v49 > 0;
      v53 = 1;
      goto LABEL_57;
    }
    v73 = 0;
    v46 = v81;
    colModelAa = (CColModel *)v49;
    do
    {
      if ( aColPoints[v73].m_dataA.m_nSurfaceType == 65 && v73 < --v46 )
      {
        v74 = &aColPoints[v73 + 1];
        v75 = v46 - v73;
        v76 = v46;
        do
        {
          CColPoint::operator=((CColPoint *)&v74[-1], v74);
          ++v74;
          --v75;
        }
        while ( v75 );
        v28 = pEntity;
        --v73;
        v46 = v76;
      }
      ++v73;
    }
    while ( v73 < v46 );
    goto LABEL_43;
  }
  p_z = &this->m_aGroundOffsets[0].z;
  p_m_nFlags = &this->m_nFlags;
  v78 = &pEntity->m_nFlags;
  v29 = 1412;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  colModelAa = 0;
  do
  {
    v33 = aLineRatios[v31];
    if ( v33 < 1.0 )
    {
      v34 = &this->m_aWheelRatios[v31];
      if ( v33 < *v34 )
      {
        *v34 = v33;
        v35 = (float *)((char *)this + v32 * 44);
        CColPoint::operator=(&this->m_aWheelColPoints[v32], &aAutomobileColPoints[v32]);
        v28 = pEntity;
        *((_BYTE *)&this->_vptr$CPlaceable + v29) = this->m_aWheelColPoints[v32].m_dataB.m_lighting;
        v36 = *(_BYTE *)&pEntity->m_info & 7;
        v37 = v36 == 4;
        colModelAa = (CColModel *)((char *)colModelAa + 1);
        if ( v36 != 4 )
          v37 = v36 == 2;
        if ( v37 )
        {
          this->m_aGroundPhysicalPtrs[v31] = (CPhysical *)pEntity;
          CEntity::RegisterReference(pEntity, (CEntity **)&p_z[v31 - 6]);
          v28 = pEntity;
          v38 = pEntity->m_pMat;
          p_tx = (CSimpleTransform *)&v38->tx;
          if ( !v38 )
            p_tx = &pEntity->m_transform;
          v40 = v35[463] - p_tx->m_translate.y;
          v41 = &p_z[v30 / 4];
          v42 = v35[464] - p_tx->m_translate.z;
          *(v41 - 2) = this->m_aWheelColPoints[v32].m_vecPosition.x - p_tx->m_translate.x;
          this->m_aGroundOffsets[v30 / 0xC].y = v40;
          *v41 = v42;
          if ( (*(_BYTE *)&pEntity->m_info & 7) == 2 )
            *((_BYTE *)&this->_vptr$CPlaceable + v29) = *((_BYTE *)&pEntity->_vptr$CPlaceable + v29);
        }
        this->m_LastMaterialToHaveBeenStandingOn = *((_BYTE *)v35 + 1883);
        if ( (*(_BYTE *)&v28->m_info & 7) == 1 )
        {
          this->pEntityWeAreOnForVisibilityCheck = v28;
          v43 = *p_m_nFlags;
          v44 = *(_DWORD *)p_m_nFlags & 0xBFFFFFFF | (((*(_DWORD *)v78 >> 30) & 1) << 30);
          *(_DWORD *)p_m_nFlags = v44;
          this->m_nFlags.bdummy = v43.bdummy;
          *(_DWORD *)p_m_nFlags = v44 & 0x7FFFFFFF | ((*(_DWORD *)v78 < 0) << 31);
          this->m_nFlags.bdummy = v43.bdummy;
        }
      }
    }
    ++v32;
    v30 += 12;
    ++v29;
    ++v31;
  }
  while ( v32 != 4 );
  v45 = (unsigned __int16)this->m_nModelIndex;
  v46 = v81;
  if ( v45 != 432 )
  {
    v49 = (int)colModelAa;
    if ( v81 < 1 )
      goto LABEL_53;
    goto LABEL_47;
  }
  v47 = vminq_f32(v90, v86);
  v48 = vminq_f32(v91, v87);
  v90 = v47;
  v91 = v48;
  LODWORD(this->Door[4].m_fAngle) = v47.n128_u32[2];
  LODWORD(this->Door[4].m_fClosedAngle) = v47.n128_u32[1];
  LODWORD(this->Door[4].m_fPrevAngle) = v47.n128_u32[3];
  LODWORD(this->Door[4].m_fOpenAngle) = v47.n128_u32[0];
  LODWORD(this->Door[5].m_fAngle) = v48.n128_u32[2];
  LODWORD(this->Door[5].m_fClosedAngle) = v48.n128_u32[1];
  LODWORD(this->Door[5].m_fPrevAngle) = v48.n128_u32[3];
  LODWORD(this->Door[5].m_fOpenAngle) = v48.n128_u32[0];
LABEL_43:
  v49 = (int)colModelAa;
LABEL_53:
  v52 = v49 > 0;
  v53 = v46 > 0;
  v54 = v49 < 0;
  v81 = v46;
  if ( v49 <= 0 )
    v54 = v46 < 1;
  if ( v54 )
    return v81;
  p_m_info = &v28->m_info;
LABEL_57:
  CPhysical::AddCollisionRecord(this, v28);
  v55 = pEntity;
  if ( (*(_BYTE *)&pEntity->m_info & 7) != 1 )
  {
    CPhysical::AddCollisionRecord((CPhysical *)pEntity, this);
    v55 = pEntity;
  }
  if ( v53
    && ((v56 = *(_BYTE *)p_m_info & 7, v56 == 1) || v56 == 4 && (LOBYTE(v55[1].m_transform.m_translate.y) & 4) != 0) )
  {
    *(_DWORD *)&this->m_nFlags |= 0x1000u;
    if ( !v52 )
      return v81;
  }
  else
  {
    if ( !v52 )
      return v81;
    p_m_info = &v55->m_info;
  }
  if ( (*(_BYTE *)p_m_info & 7) == 1 && this->pHandling->fSuspensionHighSpdComDamp > 0.0 )
  {
    m_aWheelColPoints = this->m_aWheelColPoints;
    v58 = 0;
    v59 = 0;
    v5.n64_u32[0] = 1050253722;
    v6.n64_u32[0] = 1045220557;
    do
    {
      v60 = &this->m_fLineLength[v58];
      v61 = &this->m_aWheelRatios[v58];
      v3.n64_f32[0] = 1.0 - (float)(this->m_fSuspensionLength[v58] / *v60);
      v4.n64_u32[0] = *(_DWORD *)((char *)v85 + v58 * 4);
      v3.n64_f32[0] = v3.n64_f32[0] + (float)(this->m_aRatioHistory[v58] * (float)(1.0 - v3.n64_f32[0]));
      v62 = vmin_f32(v4, v3).n64_f32[0];
      if ( (float)(*v60 * (float)(v62 - *v61)) > 0.1 && !CDamageManager::GetWheelStatus(&this->Damage, v59) )
      {
        AdhesionGroup = SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, m_aWheelColPoints->m_dataB.m_nSurfaceType);
        v64 = AdhesionGroup == 4;
        if ( AdhesionGroup != 4 )
          v64 = m_aWheelColPoints->m_dataB.m_nSurfaceType == 178;
        if ( !v64 )
        {
          v65 = &aColPoints[v81];
          CColPoint::operator=(v65, m_aWheelColPoints);
          v66 = this->m_pMat;
          v67.n64_u32[1] = LODWORD(this->m_vecMoveSpeed.z);
          v67.n64_f32[0] = fabsf(
                             (float)((float)(this->m_vecMoveSpeed.x * v66->xy)
                                   + (float)(this->m_vecMoveSpeed.y * v66->yy))
                           + (float)(v67.n64_f32[1] * v66->zy));
          v68.n64_u64[0] = vmin_f32(v67, v5).n64_u64[0];
          v69 = fabsf(
                  (float)((float)(v65->m_vecNormal.x * v66->xz) + (float)(v65->m_vecNormal.y * v66->yz))
                + (float)(v65->m_vecNormal.z * v66->zz))
              * v68.n64_f32[0];
          v68.n64_f32[0] = (float)(v62 - *v61) * *v60;
          v3.n64_u64[0] = vmin_f32(v68, v6).n64_u64[0];
          v65->m_fDepth = this->pHandling->fSuspensionHighSpdComDamp * (float)(v3.n64_f32[0] * (float)(v69 / 0.3));
          if ( v59 > 2 )
            LOBYTE(v70) = 16;
          else
            v70 = (unsigned int)"ager27AddMusicTrackIndexToHistoryEaa" >> (8 * v59);
          v65->m_dataB.m_nSurfaceType = 60;
          v65->m_dataA.m_nSurfaceType = 60;
          v65->m_dataA.m_nPieceType = v70;
          v71 = v81;
          if ( v81 < 31 )
            v71 = v81 + 1;
          v81 = v71;
        }
      }
      ++v58;
      ++m_aWheelColPoints;
      ++v59;
    }
    while ( v58 != 4 );
  }
  return v81;
}
// 55C3DE: variable 'v4' is possibly undefined
// 55C3DE: variable 'v3' is possibly undefined
// 55C498: variable 'v5' is possibly undefined
// 55C4B0: variable 'v6' is possibly undefined
// 55BF10: using guessed type _QWORD var_A8[2];

//----- (0055C580) --------------------------------------------------------
void __fastcall CAutomobile::ProcessControlInputs(CAutomobile *this, uint8 CtrlNum)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  int32 v5; // r5
  CMatrix *m_pMat; // r0
  float x; // s16
  float y; // s20
  float xy; // s22
  float yy; // s26
  float zy; // s24
  CPed *pDriver; // r0
  float z; // s18
  CPad *Pad; // r0
  int v15; // r9
  int v16; // r0
  CPed *v17; // r0
  CPad *v18; // r0
  int v19; // r3
  CPad *v20; // r0
  float *p_fSteer; // r8
  unsigned __int32 v22; // s2
  CPad *v23; // r0
  int Accelerate; // r6
  CPad *v25; // r0
  int v26; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  float v28; // s17
  CPed *v29; // r0
  CTask *SimplestActiveTask; // r0
  int RightShoulder2; // r10
  float v32; // s2
  float m_fGasPedal; // s30
  float *p_m_fGasPedal; // r9
  float v35; // s0
  CPad *v36; // r0
  CPad *v37; // r0
  CPad *v38; // r0
  CPad *v39; // r0
  int Brake; // r0
  CPlayerPed *v41; // r0
  CPlayerPed *v42; // r0
  tHandlingData *pHandling; // r0
  float v44; // s0
  char hFlags; // r1
  int v46; // r0
  float v47; // s2
  float v48; // s0
  UInt8 v49; // r0
  CPlayerPed *PlayerPed; // r0
  float v51; // s0
  float v52; // s4
  float v53; // s2
  float v54; // s6
  float v55; // s6
  int v56; // r0
  int v57; // r1
  int v58; // r0
  int ComedyControlsState; // r1
  int v60; // r0
  float v61; // s0
  CVector v62; // 0:r1.12

  v5 = CtrlNum;
  m_pMat = this->m_pMat;
  x = this->m_vecMoveSpeed.x;
  y = this->m_vecMoveSpeed.y;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  zy = m_pMat->zy;
  pDriver = this->pDriver;
  z = this->m_vecMoveSpeed.z;
  if ( pDriver
    && !CTaskManager::FindActiveTaskByType(&pDriver->m_pPedIntelligence->m_taskManager, 814)
    && ((v17 = this->pDriver, v17->m_nPedState == PED_ARRESTED)
     || CTaskManager::FindActiveTaskByType(&v17->m_pPedIntelligence->m_taskManager, 823)
     || CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 825)
     || CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 809)
     || (v18 = CPad::GetPad(v5), CPad::GetExitVehicle(v18))) )
  {
    v16 = 32;
    v15 = 1;
  }
  else
  {
    Pad = CPad::GetPad(v5);
    v15 = 0;
    v16 = 32 * (CPad::GetHandBrake(Pad) != 0);
  }
  v19 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  *(_DWORD *)&this->m_nVehicleFlags = v16 | *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFFFDF;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v19;
  v20 = CPad::GetPad(v5);
  p_fSteer = &this->fSteer;
  this->fSteer = this->fSteer
               + (float)(CTimer::ms_fTimeStep
                       * (float)((float)((float)((float)-CPad::GetSteeringLeftRight(v20) * 0.0078125) - this->fSteer)
                               * 0.2));
  v2.n64_f32[0] = CVehicle::GetNewSteeringAmt(this) + this->fSteer;
  v3.n64_u32[0] = 1.0;
  v22 = vmin_f32(v2, v3).n64_u32[0];
  if ( v2.n64_f32[0] < -1.0 )
    v22 = -1.0;
  *(_DWORD *)p_fSteer = v22;
  v23 = CPad::GetPad(v5);
  Accelerate = CPad::GetAccelerate(v23);
  v25 = CPad::GetPad(v5);
  v26 = Accelerate - CPad::GetBrake(v25);
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  v28 = (float)v26 / 255.0;
  if ( v28 == 0.0 )
  {
    v29 = this->pDriver;
    if ( v29 )
    {
      if ( CTaskManager::GetSimplestActiveTask(&v29->m_pPedIntelligence->m_taskManager) )
      {
        SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&this->pDriver->m_pPedIntelligence->m_taskManager);
        if ( (*((int (__fastcall **)(CTask *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask) == 1022
          && TheCamera.Cams[0].Mode == 55 )
        {
          RightShoulder2 = CPad::GetPad(v5)->NewState.RightShoulder2;
          v28 = (float)(RightShoulder2 - CPad::GetPad(v5)->NewState.LeftShoulder2) / 255.0;
        }
      }
    }
  }
  v32 = v28;
  m_fGasPedal = 0.0;
  if ( (unsigned __int16)this->m_nModelIndex == 65534 )
    v32 = v28 * 0.3;
  if ( v28 < 0.0 )
    v28 = v32;
  if ( (*(_DWORD *)p_m_nVehicleFlags & 0x40000010) != 0x40000000 )
    m_fGasPedal = v28;
  if ( v15 == 1 )
  {
    this->m_fGasPedal = 0.0;
    p_m_fGasPedal = &this->m_fGasPedal;
    this->m_fBrakePedal = 1.0;
    goto LABEL_48;
  }
  v35 = (float)((float)(x * xy) + (float)(y * yy)) + (float)(z * zy);
  if ( fabsf(v35) >= 0.01 )
  {
    p_m_fGasPedal = &this->m_fGasPedal;
    if ( v35 >= 0.0 )
    {
      if ( m_fGasPedal < 0.0 )
      {
        *p_m_fGasPedal = 0.0;
        this->m_fBrakePedal = -m_fGasPedal;
        goto LABEL_48;
      }
    }
    else if ( m_fGasPedal >= 0.0 && v35 <= -0.15 )
    {
      *p_m_fGasPedal = 0.0;
      this->m_fBrakePedal = m_fGasPedal;
      goto LABEL_48;
    }
    *p_m_fGasPedal = m_fGasPedal;
    this->m_fBrakePedal = 0.0;
  }
  else
  {
    v36 = CPad::GetPad(v5);
    if ( CPad::GetAccelerate(v36) < 151 || (v37 = CPad::GetPad(v5), CPad::GetBrake(v37) < 151) )
    {
      p_m_fGasPedal = &this->m_fGasPedal;
      this->m_fBrakePedal = 0.0;
      this->m_fGasPedal = m_fGasPedal;
    }
    else
    {
      v38 = CPad::GetPad(v5);
      p_m_fGasPedal = &this->m_fGasPedal;
      this->m_fGasPedal = (float)CPad::GetAccelerate(v38) / 255.0;
      v39 = CPad::GetPad(v5);
      Brake = CPad::GetBrake(v39);
      this->nBrakesOn = 1;
      m_fGasPedal = this->m_fGasPedal;
      this->m_fBrakePedal = (float)Brake / 255.0;
    }
  }
  if ( m_fGasPedal > 0.0 )
  {
    v41 = (CPlayerPed *)this->pDriver;
    if ( v41 )
    {
      if ( !CGameLogic::IsPlayerAllowedToGoInThisDirection(v41, *(CVector *)&this->m_pMat->xy, 0.0) )
      {
        *p_m_fGasPedal = 0.0;
        goto LABEL_48;
      }
      m_fGasPedal = *p_m_fGasPedal;
    }
  }
  if ( m_fGasPedal < 0.0 )
  {
    v42 = (CPlayerPed *)this->pDriver;
    if ( v42 )
    {
      LODWORD(v62.x) = LODWORD(this->m_pMat->xy) ^ 0x80000000;
      *(_QWORD *)&v62.y = *(_QWORD *)&this->m_pMat->yy ^ 0x8000000080000000LL;
      if ( !CGameLogic::IsPlayerAllowedToGoInThisDirection(v42, v62, 0.0) )
        *p_m_fGasPedal = 0.0;
    }
  }
LABEL_48:
  pHandling = this->pHandling;
  v44 = *p_fSteer * (float)((float)(pHandling->fSteeringLock * 3.1416) / 180.0);
  this->m_fSteerAngle = v44;
  hFlags = pHandling->hFlags;
  v46 = *(_DWORD *)p_m_nVehicleFlags;
  if ( (hFlags & 0x40) != 0 )
  {
    v47 = this->m_f2ndSteerAngle * 0.9;
    v48 = v47 + (float)(v44 * -0.1);
    if ( (v46 & 0x20) != 0 )
      v47 = v48;
    this->m_f2ndSteerAngle = v47;
  }
  if ( (v46 & 0x1000) == 0 )
    goto LABEL_53;
  v58 = rand();
  ComedyControlsState = this->ComedyControlsState;
  v60 = v58 % 10;
  if ( ComedyControlsState == 2 )
  {
    v61 = -0.05;
  }
  else
  {
    if ( ComedyControlsState != 1 )
    {
      if ( !this->ComedyControlsState )
      {
        if ( (unsigned __int16)v60 <= 1u )
        {
          v49 = 1;
          goto LABEL_54;
        }
        if ( (unsigned __int16)v60 <= 3u )
        {
          v49 = 2;
          goto LABEL_54;
        }
      }
      goto LABEL_55;
    }
    v61 = 0.05;
  }
  this->m_fSteerAngle = this->m_fSteerAngle + v61;
  if ( (v60 & 0xFFFEu) <= 1 )
  {
LABEL_53:
    v49 = 0;
LABEL_54:
    this->ComedyControlsState = v49;
  }
LABEL_55:
  if ( CPad::GetPad(0)->DisablePlayerControls && CGameLogic::SkipState != 2 || CPad::GetPad(0)->bApplyBrakes )
  {
    this->m_fBrakePedal = 1.0;
    *(_DWORD *)p_m_nVehicleFlags |= 0x20u;
    *p_m_fGasPedal = 0.0;
    PlayerPed = FindPlayerPed(-1);
    CPlayerPed::KeepAreaAroundPlayerClear(PlayerPed);
    v51 = this->m_vecMoveSpeed.x;
    v52 = this->m_vecMoveSpeed.y;
    v53 = this->m_vecMoveSpeed.z;
    v54 = sqrtf((float)((float)(v51 * v51) + (float)(v52 * v52)) + (float)(v53 * v53));
    if ( v54 > 0.28 )
    {
      v55 = 0.28 / v54;
      this->m_vecMoveSpeed.x = v51 * v55;
      this->m_vecMoveSpeed.y = v52 * v55;
      this->m_vecMoveSpeed.z = v53 * v55;
    }
  }
  v56 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  if ( (v56 & 0x200) != 0 )
  {
    v57 = *(_DWORD *)p_m_nVehicleFlags;
    this->m_fBrakePedal = 0.05;
    *(_DWORD *)p_m_nVehicleFlags = v57 & 0xFFFFFFDF;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v56;
    *p_m_fGasPedal = 0.0;
  }
}
// 55C6BC: variable 'v2' is possibly undefined
// 55C6BC: variable 'v3' is possibly undefined

//----- (0055CB00) --------------------------------------------------------
Bool8 __fastcall CAutomobile::GetAllWheelsOffGround(const CAutomobile *this)
{
  return this->m_nDriveWheelsOnGround == 0;
}

//----- (0055CB10) --------------------------------------------------------
void __fastcall CAutomobile::DebugCode(CAutomobile *this)
{
  CBaseModelInfo *v2; // r5
  CVehicle *PlayerVehicle; // r0
  CAutomobile *pRemoteVehicle; // r1
  bool v5; // zf
  unsigned int v6; // r0
  float *v7; // r0
  float v8; // s0

  v2 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  pRemoteVehicle = (CAutomobile *)CWorld::Players[CWorld::PlayerInFocus].pRemoteVehicle;
  v6 = (unsigned int)PlayerVehicle ^ (unsigned int)this | (unsigned int)pRemoteVehicle;
  v5 = v6 == 0;
  if ( v6 )
    v5 = pRemoteVehicle == this;
  if ( v5 )
  {
    v7 = &mod_HandlingManager.m_fCoefficientOfRestitution + 56 * *((unsigned __int8 *)&v2[1].m_flags + 2);
    this->m_fMass = v7[6];
    this->m_fTurnMass = v7[8];
    this->m_fBuoyancyConstant = v7[14];
    v8 = v7[9];
    if ( v8 > 0.01 )
      v8 = (float)(v8 * 0.5) / 1000.0;
    this->m_fAirResistance = v8;
  }
}

//----- (0055CBB8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CAutomobile::BlowUpCar(CAutomobile *this, CEntity *pCulprit, Bool8 bInACutscene)
{
  int v4; // r8
  CPlayerInfo *v6; // r0
  float v7; // s0
  int v8; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  RwReal v10; // s0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  RpClump_0 *m_pRwObject; // r0
  int m_nModelIndex; // r0
  bool v14; // zf
  char v15; // r1
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r4
  CSimpleTransform *p_tx; // r1
  int v19; // r1
  int v20; // r2
  unsigned int v21; // r0
  unsigned int v22; // r1
  CMatrix *v23; // r0
  float x; // s16
  float y; // s18
  float z; // s20
  float v27; // s22
  int v28; // s0
  CColModel *ColModel; // r0
  CMatrix *v30; // r1
  float v31; // s28
  float xx; // s30
  float yx; // s17
  float zx; // s19
  float v35; // s24
  float v36; // s0
  CColModel *v37; // r0
  CMatrix *v38; // r1
  float v39; // s21
  float v40; // s24
  float v41; // s23
  float xy; // s25
  float yy; // s27
  float zy; // s29
  float v45; // s8
  float v46; // s0
  float v47; // s22
  float v48; // s4
  float v49; // s24
  float v50; // s20
  float v51; // s18
  CColModel *v52; // r0
  int v53; // r2
  bool v54; // zf
  float v55; // r3
  float bExtinguishEnabled; // [sp+0h] [bp-78h]
  float v57; // [sp+4h] [bp-74h]
  int data[23]; // [sp+1Ch] [bp-5Ch] BYREF

  v4 = bInACutscene;
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    if ( FindPlayerPed(-1) == pCulprit || FindPlayerVehicle(-1, 0) == pCulprit )
    {
      v6 = &CWorld::Players[CWorld::PlayerInFocus];
      v7 = v6->CurrentChaseValue + 10.0;
      v6->HavocCaused += 20;
      v6->CurrentChaseValue = v7;
      v8 = rand();
      CStats::IncrementStat(0x7Du, (float)(v8 % 6000 + 4000));
    }
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    if ( this->m_nModelIndex == 488 )
      CWanted::bUseNewsHeliInAdditionToPolice = 0;
    v10 = this->m_vecMoveSpeed.z + 0.13;
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x28);
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x20000000);
    this->m_vecMoveSpeed.z = v10;
    m_pRwObject = (RpClump_0 *)this->m_pRwObject;
    this->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
    CVisibilityPlugins::SetClumpForAllAtomicsFlag(m_pRwObject, 0x4000);
    CDamageManager::FuckCarCompletely(&this->Damage, 0);
    m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
    v14 = m_nModelIndex == 441;
    if ( m_nModelIndex != 441 )
      v14 = m_nModelIndex == 564;
    if ( !v14 )
    {
      CAutomobile::SetBumperDamage(this, FRONT_BUMPER, 0);
      CAutomobile::SetBumperDamage(this, REAR_BUMPER, 0);
      CAutomobile::SetDoorDamage(this, BONNET_0, 0);
      CAutomobile::SetDoorDamage(this, BOOT_0, 0);
      CAutomobile::SetDoorDamage(this, FRONT_LEFT_DOOR_0, 0);
      CAutomobile::SetDoorDamage(this, FRONT_RIGHT_DOOR_0, 0);
      CAutomobile::SetDoorDamage(this, REAR_LEFT_DOOR_0, 0);
      CAutomobile::SetDoorDamage(this, REAR_RIGHT_DOOR_0, 0);
      CAutomobile::SpawnFlyingComponent(this, 5, 1u);
      data[0] = 0;
      RwFrameForAllObjects(this->m_aCarNodes[5], GetCurrentAtomicObjectCB, data);
      if ( data[0] )
        *(_BYTE *)(data[0] + 2) = 0;
    }
    v15 = *((_BYTE *)&this->CVehicle + 1202);
    this->DelayedExplosion = 0;
    m_pMat = this->m_pMat;
    this->m_nHealth = 0.0;
    p_m_transform = &this->m_transform;
    *((_BYTE *)&this->CVehicle + 1202) = v15 & 0xF8;
    p_tx = &this->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    CCamera::CamShake(&TheCamera, 0.4, p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z);
    CVehicle::KillPedsInVehicle(this);
    CVehicle::KillPedsGettingInVehicle(this);
    v19 = *((_DWORD *)&this->m_nVehicleFlags + 1);
    v20 = *(_DWORD *)p_m_nVehicleFlags;
    *((_BYTE *)&this->CVehicle + 1202) &= 0xE7u;
    v21 = v19 & 0xFFFF7FFF;
    v22 = v20 & 0xFFFFFFAF;
    *(_DWORD *)p_m_nVehicleFlags = v20 & 0xFFFFFFAF;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v21;
    *(_BYTE *)&this->m_nAutomobileFlags &= ~1u;
    if ( (v20 & 2) != 0 )
    {
      v22 = v20 & 0xFFFFFFAD;
      *(_DWORD *)p_m_nVehicleFlags = v20 & 0xFFFFFFAD;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v21;
      --CCarCtrl::NumAmbulancesOnDuty;
    }
    if ( (v22 & 4) != 0 )
    {
      *(_DWORD *)p_m_nVehicleFlags = v22 & 0xFFFFFFAB;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v21 & 0xFFFF7FFF;
      --CCarCtrl::NumFireTrucksOnDuty;
    }
    CVehicle::ChangeLawEnforcerState(this, 0);
    CFireManager::StartFire(&gFireManager, this, pCulprit, 0.8, 1u, 7000, 0);
    CDarkel::RegisterCarBlownUpByPlayer(this, 0);
    v23 = this->m_pMat;
    if ( v23 )
      p_m_transform = (CSimpleTransform *)&v23->tx;
    x = p_m_transform->m_translate.x;
    y = p_m_transform->m_translate.y;
    z = p_m_transform->m_translate.z;
    if ( (this->m_vehicleType | 2) == 2 )
      v27 = 0.75;
    else
      v27 = 0.1;
    v28 = rand();
    ColModel = CEntity::GetColModel(this);
    v30 = this->m_pMat;
    v31 = ColModel->m_boxBound.m_vecMax.x;
    xx = v30->xx;
    yx = v30->yx;
    zx = v30->zx;
    v35 = (float)(v27 + v27) * (float)((float)v28 * 4.6566e-10);
    v36 = (float)rand();
    v37 = CEntity::GetColModel(this);
    v38 = this->m_pMat;
    v39 = (float)(v27 + v27) * (float)(v36 * 4.6566e-10);
    v40 = v35 - v27;
    v41 = v37->m_boxBound.m_vecMax.y;
    xy = v38->xy;
    yy = v38->yy;
    zy = v38->zy;
    v45 = (float)(v31 * v40) * zx;
    v46 = (float)rand() * 4.6566e-10;
    v47 = v41 * (float)(v39 - v27);
    v48 = yx * (float)(v31 * v40);
    v49 = xx * (float)(v31 * v40);
    v50 = z + v45;
    v51 = y + v48;
    v52 = CEntity::GetColModel(this);
    v53 = (unsigned __int16)this->m_nModelIndex;
    v54 = v53 == 564;
    if ( v53 != 564 )
      v54 = v53 == 441;
    v55 = (float)(x + v49) + (float)(xy * v47);
    bExtinguishEnabled = v51 + (float)(yy * v47);
    v57 = (float)(v50 + (float)(v47 * zy)) - (float)(v52->m_boxBound.m_vecMax.z * (float)(v46 + 0.5));
    if ( v54 )
      CExplosion::AddExplosion(this, pCulprit, EXP_TYPE_CAR_QUICK, *(CVector *)&v55, 0, 1u, -1.0, v4);
    else
      CExplosion::AddExplosion(this, pCulprit, EXP_TYPE_CAR, *(CVector *)&v55, 0, 1u, -1.0, v4);
  }
}
// 55CBB8: fragmented variable at r3.4 may be wrong
// 55CBB8: fragmented variable at ^0.4 may be wrong
// 55CBB8: fragmented variable at ^4.4 may be wrong
// 676438: using guessed type CFireManager *gFireManager_ptr;
// 55CBB8: using guessed type int data[23];

//----- (0055CFA0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CAutomobile::BlowUpCarCutSceneNoExtras(
        CAutomobile *this,
        int bDontShakeCam,
        _BOOL4 bDontSpawnStuff,
        int bNoExplosion,
        bool bMakeSound)
{
  int v9; // r1
  RpClump_0 *m_pRwObject; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r5
  char v12; // r0
  CSimpleTransform *p_m_transform; // r10
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r6
  int v16; // r1
  int v17; // r2
  unsigned int v18; // r0
  unsigned int v19; // r1
  CMatrix *v20; // r0
  __int64 v21; // kr08_8 OVERLAPPED
  __int64 bExtinguishEnabled; // [sp+0h] [bp-38h]
  int data[7]; // [sp+1Ch] [bp-1Ch] BYREF

  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    if ( this->m_vehicleType == 4 && *(_BYTE *)&this->m_info >= 8u )
    {
      switch ( this->AutoPilot.Mission )
      {
        case 0x16:
        case 0x23:
        case 0x24:
        case 0x25:
        case 0x3B:
        case 0x3E:
        case 0x3F:
          this->AutoPilot.Mission = 57;
          break;
        default:
          goto LABEL_4;
      }
    }
    else
    {
LABEL_4:
      if ( this->m_nModelIndex == 488 )
        CWanted::bUseNewsHeliInAdditionToPolice = 0;
      if ( !bNoExplosion )
        this->m_vecMoveSpeed.z = this->m_vecMoveSpeed.z + 0.13;
      v9 = *(_DWORD *)&this->m_nPhysicalFlags | 0x20000000;
      this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x28);
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)v9;
      m_pRwObject = (RpClump_0 *)this->m_pRwObject;
      this->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
      CVisibilityPlugins::SetClumpForAllAtomicsFlag(m_pRwObject, 0x4000);
      CDamageManager::FuckCarCompletely(&this->Damage, bNoExplosion == 1);
      p_m_nVehicleFlags = &this->m_nVehicleFlags;
      if ( this->m_nModelIndex != 441 )
      {
        CAutomobile::SetBumperDamage(this, FRONT_BUMPER, bDontSpawnStuff);
        CAutomobile::SetBumperDamage(this, REAR_BUMPER, bDontSpawnStuff);
        CAutomobile::SetDoorDamage(this, BONNET_0, bDontSpawnStuff);
        CAutomobile::SetDoorDamage(this, BOOT_0, bDontSpawnStuff);
        CAutomobile::SetDoorDamage(this, FRONT_LEFT_DOOR_0, bDontSpawnStuff);
        CAutomobile::SetDoorDamage(this, FRONT_RIGHT_DOOR_0, bDontSpawnStuff);
        CAutomobile::SetDoorDamage(this, REAR_LEFT_DOOR_0, bDontSpawnStuff);
        CAutomobile::SetDoorDamage(this, REAR_RIGHT_DOOR_0, bDontSpawnStuff);
        if ( !bDontSpawnStuff )
          CAutomobile::SpawnFlyingComponent(this, 5, 1u);
        data[0] = 0;
        if ( !bNoExplosion )
        {
          RwFrameForAllObjects(this->m_aCarNodes[5], GetCurrentAtomicObjectCB, data);
          if ( data[0] )
            *(_BYTE *)(data[0] + 2) = 0;
        }
      }
      v12 = *((_BYTE *)&this->CVehicle + 1202);
      this->DelayedExplosion = 0;
      this->m_nHealth = 0.0;
      *((_BYTE *)&this->CVehicle + 1202) = v12 & 0xF8;
      if ( bDontShakeCam )
      {
        p_m_transform = &this->m_transform;
      }
      else
      {
        p_m_transform = &this->m_transform;
        m_pMat = this->m_pMat;
        p_tx = &this->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        CCamera::CamShake(&TheCamera, 0.4, p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z);
      }
      CVehicle::KillPedsInVehicle(this);
      v16 = *((_DWORD *)&this->m_nVehicleFlags + 1);
      v17 = *(_DWORD *)p_m_nVehicleFlags;
      *((_BYTE *)&this->CVehicle + 1202) &= 0xE7u;
      v18 = v16 & 0xFFFF7FFF;
      v19 = v17 & 0xFFFFFFAF;
      *(_DWORD *)p_m_nVehicleFlags = v17 & 0xFFFFFFAF;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v18;
      *(_BYTE *)&this->m_nAutomobileFlags &= ~1u;
      if ( (v17 & 2) != 0 )
      {
        v19 = v17 & 0xFFFFFFAD;
        *(_DWORD *)p_m_nVehicleFlags = v17 & 0xFFFFFFAD;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v18;
        --CCarCtrl::NumAmbulancesOnDuty;
      }
      if ( (v19 & 4) != 0 )
      {
        *(_DWORD *)p_m_nVehicleFlags = v19 & 0xFFFFFFAB;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v18 & 0xFFFF7FFF;
        --CCarCtrl::NumFireTrucksOnDuty;
      }
      CVehicle::ChangeLawEnforcerState(this, 0);
      if ( !bNoExplosion )
      {
        CDarkel::RegisterCarBlownUpByPlayer(this, 0);
        CFireManager::StartFire(&gFireManager, this, 0, 0.8, 1u, 7000, 0);
        v20 = this->m_pMat;
        if ( v20 )
          p_m_transform = (CSimpleTransform *)&v20->tx;
        v21 = *(_QWORD *)&p_m_transform->m_translate.x;
        bExtinguishEnabled = *(_QWORD *)&p_m_transform->m_translate.y;
        CExplosion::AddExplosion(this, 0, EXP_TYPE_MOLOTOV, *(CVector *)&v21, 0, bMakeSound, -1.0, 0);
      }
    }
  }
}
// 55D1CB: failed to expand linear variable kr08_8.8
// 676438: using guessed type CFireManager *gFireManager_ptr;
// 55CFA0: using guessed type int data[7];

//----- (0055D250) --------------------------------------------------------
void __fastcall CAutomobile::RemoveRefsToVehicle(CAutomobile *this, CEntity *pEntity)
{
  if ( this->m_aGroundPhysicalPtrs[0] == pEntity )
    this->m_aGroundPhysicalPtrs[0] = 0;
  if ( this->m_aGroundPhysicalPtrs[1] == pEntity )
    this->m_aGroundPhysicalPtrs[1] = 0;
  if ( this->m_aGroundPhysicalPtrs[2] == pEntity )
    this->m_aGroundPhysicalPtrs[2] = 0;
  if ( this->m_aGroundPhysicalPtrs[3] == pEntity )
    this->m_aGroundPhysicalPtrs[3] = 0;
}

//----- (0055D28C) --------------------------------------------------------
bool __fastcall CAutomobile::SetUpWheelColModel(CAutomobile *this, CColModel *pColModel)
{
  CBaseModelInfo *v4; // r6
  CColModel *ColModel; // r0
  int m_nModelIndex; // r2
  bool v7; // r1
  CCollisionData *m_pColData; // r9
  __int64 v9; // d17
  __int64 v10; // d17
  __int64 v11; // d18
  RwFrame_0 *v12; // r0
  __int16 v13; // r0
  CMatrix v15; // [sp+8h] [bp-68h] BYREF

  v4 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  ColModel = CEntity::GetColModel(this);
  m_nModelIndex = this->m_nModelIndex;
  v7 = 0;
  if ( (unsigned int)(m_nModelIndex - 531) >= 2 && m_nModelIndex != 571 )
  {
    m_pColData = pColModel->m_pColData;
    v9 = *(_QWORD *)&ColModel->m_sphereBound.m_vecCentre.z;
    *(_QWORD *)&pColModel->m_sphereBound.m_vecCentre.x = *(_QWORD *)&ColModel->m_sphereBound.m_vecCentre.x;
    *(_QWORD *)&pColModel->m_sphereBound.m_vecCentre.z = v9;
    v10 = *(_QWORD *)&ColModel->m_boxBound.m_vecMin.z;
    v11 = *(_QWORD *)&ColModel->m_boxBound.m_vecMax.y;
    *(_QWORD *)&pColModel->m_boxBound.m_vecMin.x = *(_QWORD *)&ColModel->m_boxBound.m_vecMin.x;
    *(_QWORD *)&pColModel->m_boxBound.m_vecMin.z = v10;
    *(_QWORD *)&pColModel->m_boxBound.m_vecMax.y = v11;
    v15.m_pRwMat = 0;
    v15.m_owner = 0;
    CMatrix::Attach(&v15, &this->m_aCarNodes[5]->modelling, 0);
    CColSphere::Set(
      m_pColData->m_pSphereArray,
      *(float *)&v4[1].m_txdIndex * 0.5,
      (const CVector *)&v15.tx,
      0x43u,
      0xDu,
      0xFFu);
    CMatrix::Attach(&v15, &this->m_aCarNodes[7]->modelling, 0);
    CColSphere::Set(
      m_pColData->m_pSphereArray + 1,
      *(float *)&v4[1].m_n2dEffects * 0.5,
      (const CVector *)&v15.tx,
      0x43u,
      0xFu,
      0xFFu);
    CMatrix::Attach(&v15, &this->m_aCarNodes[2]->modelling, 0);
    CColSphere::Set(
      m_pColData->m_pSphereArray + 2,
      *(float *)&v4[1].m_txdIndex * 0.5,
      (const CVector *)&v15.tx,
      0x43u,
      0xEu,
      0xFFu);
    CMatrix::Attach(&v15, &this->m_aCarNodes[4]->modelling, 0);
    CColSphere::Set(
      m_pColData->m_pSphereArray + 3,
      *(float *)&v4[1].m_n2dEffects * 0.5,
      (const CVector *)&v15.tx,
      0x43u,
      0x10u,
      0xFFu);
    v12 = this->m_aCarNodes[6];
    if ( v12 && this->m_aCarNodes[3] )
    {
      CMatrix::Attach(&v15, &v12->modelling, 0);
      CColSphere::Set(
        m_pColData->m_pSphereArray + 4,
        *(float *)&v4[1].m_n2dEffects * 0.5,
        (const CVector *)&v15.tx,
        0x43u,
        0xFu,
        0xFFu);
      CMatrix::Attach(&v15, &this->m_aCarNodes[3]->modelling, 0);
      CColSphere::Set(
        m_pColData->m_pSphereArray + 5,
        *(float *)&v4[1].m_n2dEffects * 0.5,
        (const CVector *)&v15.tx,
        0x43u,
        0x10u,
        0xFFu);
      v13 = 6;
    }
    else
    {
      v13 = 4;
    }
    m_pColData->m_nNoOfSpheres = v13;
    CMatrix::~CMatrix(&v15);
    return 1;
  }
  return v7;
}

//----- (0055D458) --------------------------------------------------------
bool __fastcall CAutomobile::BurstTyre(CAutomobile *this, uint8 nWheelPieceType, bool bApplyForce)
{
  _BOOL4 v4; // r5
  unsigned int v5; // r0
  int32 v6; // r8
  float v8; // s16
  float v9; // s0
  CMatrix *m_pMat; // r0
  float v11; // s0
  float v12; // s16
  float v13; // s0
  CMatrix *v14; // r0
  float v15; // s0
  CVector v16; // 0:r1.12
  CVector v17; // 0:r1.12

  v4 = bApplyForce;
  if ( this->m_nModelIndex == 432
    || *(_DWORD *)&this->m_nVehicleFlags < 0
    || (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) != 0 )
  {
    return 0;
  }
  v5 = (unsigned __int8)(nWheelPieceType - 13);
  if ( v5 <= 3 )
    *(_DWORD *)&nWheelPieceType = 0x3010200u >> (8 * v5);
  v6 = nWheelPieceType;
  if ( CDamageManager::GetWheelStatus(&this->Damage, nWheelPieceType) )
    return 0;
  CDamageManager::SetWheelStatus(&this->Damage, v6, 1u);
  CStats::IncrementStat(0x81u, 1.0);
  CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 90, 0.0);
  if ( (*(_BYTE *)&this->m_info & 0xF8) == 16 )
    CCarCtrl::SwitchVehicleToRealPhysics(this);
  if ( v4 )
  {
    v8 = fBurstForceMult;
    v9 = (float)rand();
    m_pMat = this->m_pMat;
    v11 = this->m_fMass * (float)((float)((float)(v8 + v8) * (float)(v9 * 4.6566e-10)) - v8);
    v16.x = m_pMat->xx * v11;
    v16.y = m_pMat->yx * v11;
    v16.z = m_pMat->zx * v11;
    CPhysical::ApplyMoveForce(this, v16);
    v12 = fBurstForceMult;
    v13 = (float)rand();
    v14 = this->m_pMat;
    v15 = this->m_fTurnMass * (float)((float)((float)(v12 + v12) * (float)(v13 * 4.6566e-10)) - v12);
    v17.x = v14->xx * v15;
    v17.y = v14->yx * v15;
    v17.z = v14->zx * v15;
    CPhysical::ApplyTurnForce(this, v17, *(CVector *)&v14->xy);
    this->m_nNoOfStaticFrames = 0;
  }
  return 1;
}

//----- (0055D5C0) --------------------------------------------------------
void __fastcall CAutomobile::Fix(CAutomobile *this)
{
  CDamageManager *p_Damage; // r8
  RpClump_0 *m_pRwObject; // r0
  int i; // r4
  RwFrame_0 *v5; // r0
  CMatrix *v6; // r0
  CMatrix v7; // [sp+0h] [bp-60h] BYREF

  p_Damage = &this->Damage;
  CDamageManager::ResetDamageStatus(&this->Damage);
  if ( BYTE1(this->pHandling->mFlags) << 31 )
  {
    CDamageManager::SetDoorStatus(p_Damage, FRONT_LEFT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(p_Damage, FRONT_RIGHT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(p_Damage, REAR_LEFT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(p_Damage, REAR_RIGHT_DOOR_0, 4u);
  }
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x10000u;
  RpClumpForAllAtomics(m_pRwObject, CVehicleModelInfo::HideAllComponentsAtomicCB, (char *)&dword_0 + 2);
  for ( i = 0; i != 17; ++i )
  {
    v5 = this->m_aCarNodes[i + 8];
    if ( v5 )
    {
      CMatrix::CMatrix(&v7, &v5->modelling, 0);
      CMatrix::SetTranslate(v6, v7.tx, v7.ty, v7.tz);
      CMatrix::UpdateRW(&v7);
      CMatrix::~CMatrix(&v7);
    }
  }
  CDamageManager::SetWheelStatus(p_Damage, 0, 0);
  CDamageManager::SetWheelStatus(p_Damage, 1, 0);
  CDamageManager::SetWheelStatus(p_Damage, 2, 0);
  CDamageManager::SetWheelStatus(p_Damage, 3, 0);
  this->BouncingPanels[2].m_nComponentIndex = -1;
  this->BouncingPanels[1].m_nComponentIndex = -1;
  this->BouncingPanels[0].m_nComponentIndex = -1;
}
// 55D644: variable 'v6' is possibly undefined
// 0: using guessed type int dword_0;

//----- (0055D6A0) --------------------------------------------------------
void __fastcall CAutomobile::FixTyre(CAutomobile *this, eWheels tyre)
{
  sub_18A19C(&this->Damage, tyre, 0);
}

//----- (0055D6AA) --------------------------------------------------------
void __fastcall CAutomobile::FixDoor(CAutomobile *this, int32 index, eDoors iDoor)
{
  int (***v6)(void); // r0
  RwFrame_0 *v7; // r1
  char *v8; // r5
  CMatrix *v9; // r0
  CMatrix v10; // [sp+0h] [bp-58h] BYREF

  if ( !(BYTE1(this->pHandling->mFlags) << 31) )
  {
    CDoor::Open(&this->Door[iDoor], 0.0);
    CDamageManager::SetDoorStatus(&this->Damage, iDoor, 0);
    v6 = &this->_vptr$CPlaceable + index;
    v7 = (RwFrame_0 *)v6[407];
    if ( v7 )
    {
      v8 = (char *)(v6 + 407);
      CVehicle::SetComponentVisibility(this, v7, 1u);
      CMatrix::CMatrix(&v10, (RwMatrix *)(*(_DWORD *)v8 + 16), 0);
      CMatrix::SetTranslate(v9, v10.tx, v10.ty, v10.tz);
      CMatrix::UpdateRW(&v10);
      CMatrix::~CMatrix(&v10);
    }
  }
}
// 55D70E: variable 'v9' is possibly undefined

//----- (0055D726) --------------------------------------------------------
void __fastcall CAutomobile::PopDoor(CAutomobile *this, int32 index, eDoors iDoor, bool bSpawnStuff)
{
  CDamageManager *p_Damage; // r5
  _BOOL4 v8; // r6
  int32 v9; // r1
  uint32 v10; // r2
  CPhysical *v11; // r0

  p_Damage = &this->Damage;
  v8 = bSpawnStuff;
  if ( (unsigned __int8)CDamageManager::GetDoorStatus(&this->Damage, iDoor) != 4 )
  {
    if ( v8 )
    {
      if ( index )
      {
        if ( index == 1 )
        {
          v9 = 1;
          v10 = 4;
        }
        else
        {
          v9 = index;
          v10 = 2;
        }
        CAutomobile::SpawnFlyingComponent(this, v9, v10);
      }
      else
      {
        v11 = CAutomobile::SpawnFlyingComponent(this, 0, 3u);
        CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 93, v11);
      }
    }
    CDamageManager::SetDoorStatus(p_Damage, iDoor, 4u);
    sub_18B798(this, this->m_aCarNodes[index], 0);
  }
}

//----- (0055D7A6) --------------------------------------------------------
void __fastcall CAutomobile::FixPanel(CAutomobile *this, int32 index, ePanels iPanel)
{
  int (***v5)(void); // r0
  RwFrame_0 *v6; // r1
  char *v7; // r5
  CMatrix *v8; // r0
  CMatrix v9; // [sp+0h] [bp-50h] BYREF

  CDamageManager::SetPanelStatus(&this->Damage, iPanel, 0);
  if ( this->BouncingPanels[0].m_nComponentIndex == index )
    this->BouncingPanels[0].m_nComponentIndex = -1;
  if ( this->BouncingPanels[1].m_nComponentIndex == index )
    this->BouncingPanels[1].m_nComponentIndex = -1;
  if ( this->BouncingPanels[2].m_nComponentIndex == index )
    this->BouncingPanels[2].m_nComponentIndex = -1;
  v5 = &this->_vptr$CPlaceable + index;
  v6 = (RwFrame_0 *)v5[407];
  if ( v6 )
  {
    v7 = (char *)(v5 + 407);
    CVehicle::SetComponentVisibility(this, v6, 1u);
    CMatrix::CMatrix(&v9, (RwMatrix *)(*(_DWORD *)v7 + 16), 0);
    CMatrix::SetTranslate(v8, v9.tx, v9.ty, v9.tz);
    CMatrix::UpdateRW(&v9);
    CMatrix::~CMatrix(&v9);
  }
}
// 55D80E: variable 'v8' is possibly undefined

//----- (0055D822) --------------------------------------------------------
void __fastcall CAutomobile::PopPanel(CAutomobile *this, int32 index, ePanels iPanel, bool bSpawnStuff)
{
  CDamageManager *p_Damage; // r5
  _BOOL4 v8; // r9
  uint32 v9; // r2

  p_Damage = &this->Damage;
  v8 = bSpawnStuff;
  if ( (unsigned __int8)CDamageManager::GetPanelStatus(&this->Damage, iPanel) != 3 )
  {
    if ( v8 )
    {
      if ( (unsigned int)(index - 5) <= 1 )
        v9 = 0;
      else
        v9 = 5;
      CAutomobile::SpawnFlyingComponent(this, index, v9);
    }
    CDamageManager::SetPanelStatus(p_Damage, iPanel, 3u);
    sub_18B798(this, this->m_aCarNodes[index], 0);
  }
}

//----- (0055D886) --------------------------------------------------------
void __fastcall CAutomobile::SetupDamageAfterLoad(CAutomobile *this)
{
  if ( this->m_aCarNodes[12] )
    CAutomobile::SetBumperDamage(this, FRONT_BUMPER, 0);
  if ( this->m_aCarNodes[16] )
    CAutomobile::SetDoorDamage(this, BONNET_0, 0);
  if ( this->m_aCarNodes[13] )
    CAutomobile::SetBumperDamage(this, REAR_BUMPER, 0);
  if ( this->m_aCarNodes[17] )
    CAutomobile::SetDoorDamage(this, BOOT_0, 0);
  if ( this->m_aCarNodes[10] )
    CAutomobile::SetDoorDamage(this, FRONT_LEFT_DOOR_0, 0);
  if ( this->m_aCarNodes[8] )
    CAutomobile::SetDoorDamage(this, FRONT_RIGHT_DOOR_0, 0);
  if ( this->m_aCarNodes[11] )
    CAutomobile::SetDoorDamage(this, REAR_LEFT_DOOR_0, 0);
  if ( this->m_aCarNodes[9] )
    CAutomobile::SetDoorDamage(this, REAR_RIGHT_DOOR_0, 0);
  if ( this->m_aCarNodes[15] )
    CAutomobile::SetPanelDamage(this, FRONT_LEFT_PANEL, 0);
  if ( this->m_aCarNodes[14] )
    CAutomobile::SetPanelDamage(this, FRONT_RIGHT_PANEL, 0);
}

//----- (0055D934) --------------------------------------------------------
void __fastcall CAutomobile::SetAllTaxiLights(bool State)
{
  CAutomobile::m_sAllTaxiLights = State;
}

//----- (0055D944) --------------------------------------------------------
void __fastcall CAutomobile::PlayCarHorn(CAutomobile *this)
{
  int CarAlarmState; // r0
  bool v3; // zf
  UInt8 v4; // r0
  unsigned int v5; // r1
  CPed *pDriver; // r0
  bool v7; // zf

  CarAlarmState = this->CarAlarmState;
  v3 = CarAlarmState == 0;
  if ( CarAlarmState )
    v3 = CarAlarmState == 0xFFFF;
  if ( (v3 || (*(_BYTE *)&this->m_info & 0xF8) == 40) && !this->m_cHorn )
  {
    if ( this->m_NoHornCount )
    {
      --this->m_NoHornCount;
      return;
    }
    v4 = (rand() & 0x7F) - 106;
    this->m_NoHornCount = v4;
    v5 = v4 & 7;
    if ( v5 > 1 )
    {
      pDriver = this->pDriver;
      if ( v5 > 3 )
      {
        if ( pDriver )
          CPed::Say(pDriver, 0x16u, 0, 1.0, 0, 0, 0);
        return;
      }
      v7 = pDriver == 0;
      if ( pDriver )
        v7 = *((unsigned __int8 *)&this->AutoPilot + 75) << 31 == 0;
      if ( !v7 )
        CPed::Say(pDriver, 0x16u, 0, 1.0, 0, 0, 0);
    }
    this->m_cHorn = 45;
  }
}

//----- (0055D9EA) --------------------------------------------------------
bool __fastcall CAutomobile::IsRoomForPedToLeaveCar(CAutomobile *this, uint32 nDoor, CVector *pvecCarJackOffset)
{
  return 1;
}

//----- (0055D9F0) --------------------------------------------------------
bool16 __fastcall CAutomobile::RcbanditCheck1CarWheels(const CAutomobile *this, CPtrList *list)
{
  CPtrNode *m_pHead; // r8
  char v4; // r0
  CPtrNode v5; // kr00_8
  int v6; // r0
  int v7; // r2
  CMatrix *m_pMat; // r3
  float *v9; // r1
  CSimpleTransform *p_tx; // r2
  float *v11; // r6
  int32 v12; // r1
  CMatrix *v13; // r0
  _BOOL4 v14; // r0
  CVehicleModelInfo *v16; // [sp+8h] [bp-80h]
  CColModel *box; // [sp+Ch] [bp-7Ch]
  int32 num; // [sp+10h] [bp-78h]
  CVector v19; // [sp+14h] [bp-74h] BYREF
  CVector v20; // [sp+20h] [bp-68h] BYREF
  CSphere sphere; // [sp+30h] [bp-58h] BYREF
  CVector posn; // [sp+44h] [bp-44h] BYREF

  m_pHead = list->m_pHead;
  box = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
  v4 = `guard variable for'CAutomobile::RcbanditCheck1CarWheels(CPtrList &)::matW2B;
  __dmb(0xBu);
  if ( (v4 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CAutomobile::RcbanditCheck1CarWheels(CPtrList &)::matW2B) )
  {
    CAutomobile::RcbanditCheck1CarWheels(CPtrList &)const::matW2B.m_pRwMat = 0;
    CAutomobile::RcbanditCheck1CarWheels(CPtrList &)const::matW2B.m_owner = 0;
    _cxa_atexit(
      (void (__fastcall *)(void *))CMatrix::~CMatrix,
      &CAutomobile::RcbanditCheck1CarWheels(CPtrList &)const::matW2B,
      &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CAutomobile::RcbanditCheck1CarWheels(CPtrList &)::matW2B);
  }
  if ( !m_pHead )
    return 0;
  while ( 1 )
  {
    v5 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( v5.m_pVoid != this && !*((_DWORD *)v5.m_pVoid + 360) )
    {
      v6 = *((__int16 *)v5.m_pVoid + 19);
      if ( v6 != 441 && *((unsigned __int16 *)v5.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        v7 = *((_DWORD *)v5.m_pVoid + 5);
        *((_WORD *)v5.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        m_pMat = this->m_pMat;
        v9 = (float *)(v7 + 48);
        if ( !v7 )
          v9 = (float *)((char *)v5.m_pVoid + 4);
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        if ( fabsf(p_tx->m_translate.x - *v9) < 10.0 && fabsf(p_tx->m_translate.y - v9[1]) < 10.0 )
          break;
      }
    }
LABEL_20:
    if ( !m_pHead )
      return 0;
  }
  v11 = (float *)((char *)v5.m_pVoid + 2040);
  v12 = -1;
  v16 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[v6];
  while ( 1 )
  {
    ++v12;
    if ( *v11 < 1.0 || (*((_BYTE *)v5.m_pVoid + 58) & 0xF8) == 16 )
    {
      num = v12;
      CVehicleModelInfo::GetWheelPosn(v16, v12, &posn, 0);
      v13 = Invert(this->m_pMat, &CAutomobile::RcbanditCheck1CarWheels(CPtrList &)const::matW2B);
      CMatrix::operator=(&CAutomobile::RcbanditCheck1CarWheels(CPtrList &)const::matW2B, v13);
      operator*(&v19, *((const CMatrix **)v5.m_pVoid + 5), &posn);
      operator*(&v20, &CAutomobile::RcbanditCheck1CarWheels(CPtrList &)const::matW2B, &v19);
      sphere.m_vecCentre = v20;
      sphere.m_fRadius = v16->m_wheelScale * 0.25;
      v14 = CCollision::TestSphereBox(&sphere, &box->m_boxBound);
      v12 = num;
      if ( v14 )
        return 1;
    }
    ++v11;
    if ( v12 >= 3 )
      goto LABEL_20;
  }
}
// A01F54: using guessed type char `guard variable for'CAutomobile::RcbanditCheck1CarWheels(CPtrList &)::matW2B;

//----- (0055DBD8) --------------------------------------------------------
void __fastcall CPed::DeadPedMakesTyresBloody(CPed *this)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s4
  float v5; // s20
  float v6; // s24
  float v7; // r5
  float v8; // s16
  int v9; // r9
  float v10; // s2
  int v11; // r5
  int v12; // r1
  int v13; // r11
  uint16 v14; // r0
  int v15; // r8
  int v17; // [sp+4h] [bp-4Ch]

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  y = p_tx->m_translate.y;
  v5 = p_tx->m_translate.x + 2.0;
  v6 = floorf((float)((float)(p_tx->m_translate.x + -2.0) / 50.0) + 60.0);
  v7 = floorf((float)((float)(y + -2.0) / 50.0) + 60.0);
  v8 = floorf((float)(v5 / 50.0) + 60.0);
  v9 = 0;
  v10 = v7;
  v11 = 119;
  v12 = (int)floorf((float)((float)(y + 2.0) / 50.0) + 60.0);
  v13 = (int)v10;
  if ( v12 >= 119 )
    v12 = 119;
  v17 = v12;
  if ( (int)v8 < 119 )
    v11 = (int)v8;
  if ( v13 <= 0 )
    v13 = 0;
  if ( (int)v6 > 0 )
    v9 = (int)v6;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v14 = 1;
  }
  else
  {
    v14 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v14;
  if ( v13 <= v17 )
  {
    do
    {
      if ( v9 <= v11 )
      {
        v15 = v9 - 1;
        do
          CPed::MakeTyresMuddySectorList(
            this,
            (CPtrList *)&CWorld::ms_aRepeatSectors[++v15 & 0xF | (unsigned __int8)(16 * v13)]);
        while ( v15 < v11 );
      }
    }
    while ( v13++ < v17 );
  }
}

//----- (0055DD48) --------------------------------------------------------
void __fastcall CPed::MakeTyresMuddySectorList(CPed *this, CPtrList *list)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d10
  CPtrNode *m_pHead; // r11
  uint16 *v6; // r12
  CVehicle *v7; // r6
  CBaseModelInfo **v8; // r10
  int v9; // r1
  CPtrNode v10; // kr00_8
  int v11; // r3
  CMatrix *m_pMat; // r5
  float *v13; // r2
  CSimpleTransform *p_m_transform; // r3
  int v15; // r1
  CPhysical *m_pVoid; // r2
  __int16 *v17; // r2
  __int16 *v18; // r2
  __int16 *v19; // r2
  bool v20; // zf
  __int16 *v21; // r1
  __int16 *v22; // r1
  __int16 *v23; // r1
  int v24; // r9
  int v25; // r10
  CColModel *m_pColModel; // r0
  float x; // s0
  CColModel *p_m_vecMax; // r0
  float v29; // s0
  CColModel *v30; // r0
  CMatrix *v31; // r1
  CSimpleTransform *p_tx; // r0
  float z; // s23
  float v34; // s25
  float y; // s27
  float32x2_t v36; // d0
  CMatrix *v37; // r0
  unsigned int v38; // s2
  unsigned int v39; // s4
  CPad *Pad; // r0
  int v41; // r6
  int v42; // r5
  CPhysical *v43; // r2
  char *v44; // r10
  CColModel *v45; // r0
  float v46; // s0
  CMatrix *v47; // r1
  CSimpleTransform *v48; // r0
  float v49; // s23
  float v50; // s25
  float v51; // s27
  CMatrix *v52; // r0
  float v53; // s4
  unsigned int v54; // s0
  unsigned int v55; // s2
  CVehicle *PlayerVehicle; // r0
  CPad *v57; // r0
  CVector v58; // [sp+0h] [bp-C0h]
  CVector v59; // [sp+0h] [bp-C0h]
  uint16 *v60; // [sp+10h] [bp-B0h]
  uint16 *v61; // [sp+10h] [bp-B0h]
  CBaseModelInfo **v62; // [sp+14h] [bp-ACh]
  CBaseModelInfo **v63; // [sp+14h] [bp-ACh]
  __int16 *v64; // [sp+2Ch] [bp-94h]
  __int16 *v65; // [sp+30h] [bp-90h]
  __int16 *v66; // [sp+34h] [bp-8Ch]
  __int16 *v67; // [sp+38h] [bp-88h]
  __int16 *v68; // [sp+3Ch] [bp-84h]
  __int16 *v69; // [sp+40h] [bp-80h]
  CPhysical *v70; // [sp+44h] [bp-7Ch]
  CVector v71; // [sp+48h] [bp-78h] BYREF
  CVector v; // [sp+54h] [bp-6Ch] BYREF
  CVector v73; // 0:r1.12
  CVector v74; // 0:r1.12
  CVector v75; // 0:r1.12
  CVector v76; // 0:r1.12

  m_pHead = list->m_pHead;
  if ( list->m_pHead )
  {
    v3.n64_u32[0] = 1.0;
    v6 = &CWorld::ms_nCurrentScanCode;
    v7 = 0;
    v8 = CModelInfo::ms_modelInfoPtrs;
    v70 = 0;
    v64 = 0;
    v65 = 0;
    v69 = 0;
    v68 = 0;
    v67 = 0;
    v66 = 0;
    do
    {
      while ( 1 )
      {
LABEL_3:
        v9 = *v6;
        while ( 1 )
        {
          v10 = *m_pHead;
          m_pHead = m_pHead->m_pNext;
          if ( *((unsigned __int16 *)v10.m_pVoid + 24) != v9 )
          {
            v11 = *((_DWORD *)v10.m_pVoid + 5);
            *((_WORD *)v10.m_pVoid + 24) = v9;
            m_pMat = this->m_pMat;
            v13 = (float *)(v11 + 48);
            v20 = v11 == 0;
            p_m_transform = &this->m_transform;
            if ( v20 )
              v13 = (float *)((char *)v10.m_pVoid + 4);
            if ( m_pMat )
              p_m_transform = (CSimpleTransform *)&m_pMat->tx;
            if ( fabsf(p_m_transform->m_translate.x - *v13) < 10.0
              && fabsf(p_m_transform->m_translate.y - v13[1]) < 10.0 )
            {
              break;
            }
          }
          if ( !m_pHead )
            return;
        }
        v15 = *((_DWORD *)v10.m_pVoid + 360);
        if ( v15 )
        {
          m_pVoid = v70;
          if ( v15 == 9 )
            m_pVoid = (CPhysical *)v10.m_pVoid;
          v70 = m_pVoid;
          v17 = v64;
          if ( v15 == 9 )
            v17 = (__int16 *)v10.m_pVoid;
          v64 = v17;
          v18 = v65;
          if ( v15 == 9 )
            v18 = (__int16 *)v10.m_pVoid;
          v65 = v18;
          if ( v15 == 9 )
            v7 = 0;
          v19 = v69;
          if ( v15 == 9 )
            v19 = 0;
          v20 = v15 == 9;
          v21 = v68;
          v69 = v19;
          if ( v20 )
            v21 = 0;
          v68 = v21;
          v22 = v67;
          if ( v20 )
            v22 = 0;
          v67 = v22;
          v23 = v66;
          if ( v20 )
            v23 = 0;
          v66 = v23;
        }
        else
        {
          v7 = (CVehicle *)v10.m_pVoid;
          v65 = 0;
          v66 = (__int16 *)v10.m_pVoid;
          v67 = (__int16 *)v10.m_pVoid;
          v68 = (__int16 *)v10.m_pVoid;
          v64 = 0;
          v69 = (__int16 *)v10.m_pVoid;
          v70 = 0;
        }
        if ( (float)((float)(*((float *)v10.m_pVoid + 18) * *((float *)v10.m_pVoid + 18))
                   + (float)(*((float *)v10.m_pVoid + 19) * *((float *)v10.m_pVoid + 19))) <= 0.05 )
          goto LABEL_56;
        if ( !v7 )
          break;
        v24 = 2024;
        v60 = v6;
        v62 = v8;
        v25 = 0;
        do
        {
          if ( !*((_BYTE *)&v7[1].m_VehicleAudioEntity.m_EngineSounds[12].EngineSoundType + v25)
            && *(float *)((char *)&v7->_vptr$CPlaceable + v24) < 1.0 )
          {
            switch ( v25 )
            {
              case 0:
                m_pColModel = CModelInfo::ms_modelInfoPtrs[v69[19]]->m_pColModel;
                x = m_pColModel->m_boxBound.m_vecMax.x;
                p_m_vecMax = (CColModel *)&m_pColModel->m_boxBound.m_vecMax;
                v29 = -x;
                goto LABEL_42;
              case 1:
                p_m_vecMax = CModelInfo::ms_modelInfoPtrs[v68[19]]->m_pColModel;
                v29 = -p_m_vecMax->m_boxBound.m_vecMax.x;
                goto LABEL_42;
              case 2:
                v30 = CModelInfo::ms_modelInfoPtrs[v67[19]]->m_pColModel;
                v29 = v30->m_boxBound.m_vecMax.x;
                p_m_vecMax = (CColModel *)&v30->m_boxBound.m_vecMax;
                goto LABEL_42;
              case 3:
                p_m_vecMax = CModelInfo::ms_modelInfoPtrs[v66[19]]->m_pColModel;
                v29 = p_m_vecMax->m_boxBound.m_vecMax.x;
LABEL_42:
                v.y = p_m_vecMax->m_boxBound.m_vecMin.y;
                v.x = v29;
                v.z = 0.0;
                break;
              default:
                break;
            }
            operator*(&v71, v7->m_pMat, &v);
            v31 = this->m_pMat;
            p_tx = &this->m_transform;
            z = v71.z;
            if ( v31 )
              p_tx = (CSimpleTransform *)&v31->tx;
            if ( fabsf(v71.z - p_tx->m_translate.z) < 2.0 )
            {
              v34 = v71.x;
              y = v71.y;
              if ( (float)((float)((float)(v71.x - p_tx->m_translate.x) * (float)(v71.x - p_tx->m_translate.x))
                         + (float)((float)(v71.y - p_tx->m_translate.y) * (float)(v71.y - p_tx->m_translate.y))) < 1.0 )
              {
                if ( CLocalisation::Blood() )
                {
                  *((_BYTE *)&v7[1].m_VehicleAudioEntity.m_EngineSounds[12].EngineSoundType + v25) = 1;
                  CAEVehicleAudioEntity::AddAudioEvent(&v7->m_VehicleAudioEntity, 120, 0.0);
                }
                if ( v7->m_fMass > 500.0 )
                {
                  v73.x = 0.0;
                  v73.y = 0.0;
                  v2.n64_f32[0] = this->m_fMass / 1000.0;
                  v36.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
                  v73.z = v36.n64_f32[0] * 50.0;
                  CPhysical::ApplyMoveForce(v7, v73);
                  v74.y = 0.0;
                  v37 = v7->m_pMat;
                  LODWORD(v74.x) = &v37->tx;
                  if ( !v37 )
                    LODWORD(v74.x) = &v7->m_transform;
                  v36.n64_f32[0] = this->m_fTurnMass / 2000.0;
                  v2.n64_u64[0] = vmin_f32(v36, v3).n64_u64[0];
                  *(float *)&v38 = y - *(float *)(LODWORD(v74.x) + 4);
                  *(float *)&v39 = z - *(float *)(LODWORD(v74.x) + 8);
                  v74.z = v2.n64_f32[0] * 50.0;
                  v2.n64_u32[0] = *(_DWORD *)LODWORD(v74.x);
                  v74.x = 0.0;
                  v58.x = v34 - v2.n64_f32[0];
                  *(_QWORD *)&v58.y = __PAIR64__(v39, v38);
                  CPhysical::ApplyTurnForce(v7, v74, v58);
                  if ( v7 == FindPlayerVehicle(-1, 0) )
                  {
                    Pad = CPad::GetPad(0);
                    CPad::StartShake(Pad, 300, 0x46u, 0);
                  }
                }
              }
            }
          }
          v24 += 4;
          ++v25;
        }
        while ( v24 != 2040 );
        v6 = v60;
        v8 = v62;
LABEL_56:
        if ( !m_pHead )
          return;
      }
      if ( !v70 )
      {
        v7 = 0;
        v70 = 0;
        if ( !m_pHead )
          return;
        goto LABEL_3;
      }
      v41 = 0;
      v42 = 1828;
      v43 = v70;
      v61 = v6;
      v63 = v8;
      do
      {
        v44 = (char *)v43 + v41;
        if ( *((_BYTE *)&v43[5].m_lightingFromPointLights + v41)
          || *(float *)((char *)&v43->_vptr$CPlaceable + v42) >= 1.0 )
        {
          goto LABEL_78;
        }
        if ( v41 == 1 )
        {
          v45 = CModelInfo::ms_modelInfoPtrs[v65[19]]->m_pColModel;
          goto LABEL_66;
        }
        if ( !v41 )
        {
          v45 = (CColModel *)&v63[v64[19]]->m_pColModel->m_boxBound.m_vecMax;
LABEL_66:
          v46 = v45->m_boxBound.m_vecMin.y;
          v.x = 0.0;
          v.z = 0.0;
          v.y = v46 * 0.8;
        }
        operator*(&v71, v43->m_pMat, &v);
        v47 = this->m_pMat;
        v48 = &this->m_transform;
        v43 = v70;
        v49 = v71.z;
        if ( v47 )
          v48 = (CSimpleTransform *)&v47->tx;
        if ( fabsf(v71.z - v48->m_translate.z) < 2.0 )
        {
          v50 = v71.x;
          v51 = v71.y;
          if ( (float)((float)((float)(v71.x - v48->m_translate.x) * (float)(v71.x - v48->m_translate.x))
                     + (float)((float)(v71.y - v48->m_translate.y) * (float)(v71.y - v48->m_translate.y))) < 1.0 )
          {
            if ( CLocalisation::Blood() )
            {
              v44[1888] = 1;
              CAEVehicleAudioEntity::AddAudioEvent((CAEVehicleAudioEntity *)&v70[1], 120, 0.0);
            }
            v43 = v70;
            if ( v70->m_fMass > 100.0 )
            {
              v75.x = 0.0;
              *(_QWORD *)&v75.y = 0x4120000000000000LL;
              CPhysical::ApplyMoveForce(v70, v75);
              v76.y = 0.0;
              v76.z = 10.0;
              v52 = v70->m_pMat;
              LODWORD(v76.x) = &v52->tx;
              if ( !v52 )
                LODWORD(v76.x) = &v70->m_transform;
              v53 = *(float *)(LODWORD(v76.x) + 8);
              *(float *)&v54 = v50 - *(float *)LODWORD(v76.x);
              *(float *)&v55 = v51 - *(float *)(LODWORD(v76.x) + 4);
              v76.x = 0.0;
              *(_QWORD *)&v59.x = __PAIR64__(v55, v54);
              v59.z = v49 - v53;
              CPhysical::ApplyTurnForce(v70, v76, v59);
              PlayerVehicle = FindPlayerVehicle(-1, 0);
              v43 = v70;
              if ( v70 == PlayerVehicle )
              {
                v57 = CPad::GetPad(0);
                CPad::StartShake(v57, 300, 0x46u, 0);
                v43 = v70;
              }
            }
          }
        }
LABEL_78:
        ++v41;
        v42 += 8;
      }
      while ( v41 != 2 );
      v7 = 0;
      v6 = v61;
      v8 = v63;
    }
    while ( m_pHead );
  }
}
// 55E01E: variable 'v2' is possibly undefined
// 55E01E: variable 'v3' is possibly undefined

//----- (0055E2AC) --------------------------------------------------------
void __fastcall CAutomobile::SetBusDoorTimer(CAutomobile *this, uint32 nTime, uint8 nStatus)
{
  UInt32 v3; // r3

  v3 = CTimer::m_snTimeInMilliseconds;
  if ( nStatus )
    v3 = CTimer::m_snTimeInMilliseconds - 500;
  if ( nTime <= 0x3E8 )
    nTime = 1000;
  this->m_nBusDoorTimer = nTime + v3;
  this->m_nBusDoorStart = v3;
}

//----- (0055E2D8) --------------------------------------------------------
void __fastcall CAutomobile::BlowUpCarsInPath(CAutomobile *this)
{
  uint8 m_nNoOfCollisionRecords; // r0
  CEntity **m_aCollisionRecordPtrs; // r6
  int v4; // r5
  CEntity *v5; // r1
  CEntity *v6; // r8
  CPlayerPed *PlayerPed; // r0

  if ( sqrtf(
         (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
               + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
       + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.1
    && (*(_BYTE *)&this->m_nAutomobileFlags & 0x20) != 0 )
  {
    m_nNoOfCollisionRecords = this->m_nNoOfCollisionRecords;
    if ( this->m_nNoOfCollisionRecords )
    {
      m_aCollisionRecordPtrs = this->m_aCollisionRecordPtrs;
      v4 = 0;
      do
      {
        v5 = m_aCollisionRecordPtrs[v4];
        if ( v5
          && (*(_BYTE *)&v5->m_info & 7) == 2
          && v5->m_nModelIndex != 432
          && (HIBYTE(v5[1].m_transform.m_translate.y) & 0x20) == 0 )
        {
          if ( this == FindPlayerVehicle(-1, 0) )
          {
            v6 = m_aCollisionRecordPtrs[v4];
            PlayerPed = FindPlayerPed(-1);
            CCrime::ReportCrime(CRIME_CAUSE_EXPLOSION, v6, PlayerPed);
          }
          (*((void (__fastcall **)(CEntity *, CAutomobile *, _DWORD))m_aCollisionRecordPtrs[v4]->_vptr$CPlaceable + 42))(
            m_aCollisionRecordPtrs[v4],
            this,
            0);
          m_nNoOfCollisionRecords = this->m_nNoOfCollisionRecords;
        }
        ++v4;
      }
      while ( v4 < m_nNoOfCollisionRecords );
    }
  }
}

//----- (0055E394) --------------------------------------------------------
void __fastcall CAutomobile::DoNitroEffect(CAutomobile *this, float keyframeTime)
{
  _BOOL4 v4; // r5
  uint32 m_hashKey; // r0
  __int64 v6; // d16
  _BOOL4 v7; // r9
  RwObject_0 *m_pRwObject; // r0
  RwMatrix *v9; // r6
  FxSystem_c *m_pFxSysNitro1; // r0
  int32 PlayStatus; // r1
  FxSystem_c *v12; // r0
  FxSystem_c *v13; // r0
  int32 v14; // r0
  bool v15; // zf
  FxSystem_c *m_pFxSysNitro2; // r0
  int32 v17; // r1
  FxSystem_c *v18; // r0
  FxSystem_c *v19; // r0
  int32 v20; // r0
  bool v21; // zf
  float v22; // [sp+8h] [bp-48h] BYREF
  CVector pWaterZ; // [sp+Ch] [bp-44h] BYREF
  CVector v24; // [sp+18h] [bp-38h] BYREF
  CVector v; // [sp+28h] [bp-28h] BYREF

  v4 = 0;
  m_hashKey = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey;
  v6 = *(_QWORD *)(m_hashKey + 72);
  v.z = *(RwReal *)(m_hashKey + 80);
  *(_QWORD *)&v.x = v6;
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 8) != 0 )
  {
    operator*(&v24, this->m_pMat, &v);
    if ( CWaterLevel::GetWaterLevel(v24.x, v24.y, v24.z, &pWaterZ.x, 1, 0) == 1 )
      v4 = pWaterZ.x >= v24.z;
  }
  if ( CVehicle::GetHasDualExhausts(this) )
  {
    v7 = 0;
    v24.y = v.y;
    v24.z = v.z;
    v24.x = -v.x;
    if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 8) != 0 )
    {
      operator*(&pWaterZ, this->m_pMat, &v24);
      if ( CWaterLevel::GetWaterLevel(pWaterZ.x, pWaterZ.y, pWaterZ.z, &v22, 1, 0) == 1 )
        v7 = v22 >= pWaterZ.z;
    }
  }
  else
  {
    v7 = 0;
  }
  m_pRwObject = this->m_pRwObject;
  if ( m_pRwObject )
    v9 = (RwMatrix *)((char *)m_pRwObject->parent + 16);
  else
    v9 = 0;
  m_pFxSysNitro1 = this->m_pFxSysNitro1;
  if ( !m_pFxSysNitro1 )
  {
    if ( v4 )
      goto LABEL_25;
    if ( !v9 )
      goto LABEL_25;
    v13 = FxManager_c::CreateFxSystem(&g_fxMan, "nitro", &v, v9, 1);
    this->m_pFxSysNitro1 = v13;
    if ( !v13 )
      goto LABEL_25;
    FxSystem_c::SetLocalParticles(v13, 1u);
LABEL_24:
    FxSystem_c::Play(this->m_pFxSysNitro1);
    goto LABEL_25;
  }
  FxSystem_c::SetConstTime(m_pFxSysNitro1, 1u, COERCE_FLOAT(LODWORD(keyframeTime) & 0x7FFFFFFF));
  PlayStatus = FxSystem_c::GetPlayStatus(this->m_pFxSysNitro1);
  v12 = this->m_pFxSysNitro1;
  if ( v4 && !PlayStatus )
  {
    FxSystem_c::Stop(v12);
    goto LABEL_25;
  }
  v14 = FxSystem_c::GetPlayStatus(v12);
  v15 = !v4;
  if ( !v4 )
    v15 = v14 == 1;
  if ( v15 )
    goto LABEL_24;
LABEL_25:
  if ( !CVehicle::GetHasDualExhausts(this) )
    return;
  m_pFxSysNitro2 = this->m_pFxSysNitro2;
  if ( !m_pFxSysNitro2 )
  {
    if ( v4 )
      return;
    if ( !v9 )
      return;
    v19 = FxManager_c::CreateFxSystem(&g_fxMan, "nitro", &v24, v9, 1);
    this->m_pFxSysNitro2 = v19;
    if ( !v19 )
      return;
    FxSystem_c::SetLocalParticles(v19, 1u);
LABEL_38:
    FxSystem_c::Play(this->m_pFxSysNitro2);
    return;
  }
  FxSystem_c::SetConstTime(m_pFxSysNitro2, 1u, COERCE_FLOAT(LODWORD(keyframeTime) & 0x7FFFFFFF));
  v17 = FxSystem_c::GetPlayStatus(this->m_pFxSysNitro2);
  v18 = this->m_pFxSysNitro2;
  if ( v7 && !v17 )
  {
    FxSystem_c::Stop(v18);
    return;
  }
  v20 = FxSystem_c::GetPlayStatus(v18);
  v21 = !v7;
  if ( !v7 )
    v21 = v20 == 1;
  if ( v21 )
    goto LABEL_38;
}

//----- (0055E56C) --------------------------------------------------------
bool __fastcall CAutomobile::GetTowHitchPos(CAutomobile *this, CVector *vecResult, bool bGenericPosOk, CVehicle *pVeh)
{
  bool v5; // r1
  __int64 v6; // d16
  CVector v8; // [sp+0h] [bp-18h] BYREF

  v5 = 0;
  if ( bGenericPosOk )
  {
    vecResult->x = 0.0;
    vecResult->y = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y + -0.5;
    vecResult->z = 0.5 - this->m_fHeightAboveRoad;
    operator*(&v8, this->m_pMat, vecResult);
    v6 = *(_QWORD *)&v8.x;
    v5 = 1;
    vecResult->z = v8.z;
    *(_QWORD *)&vecResult->x = v6;
  }
  return v5;
}

//----- (0055E5D4) --------------------------------------------------------
bool __fastcall CAutomobile::GetTowBarPos(CAutomobile *this, CVector *vecResult, bool bGenericPosOk, CVehicle *pVeh)
{
  int m_nModelIndex; // r1
  float v6; // s0
  bool v7; // zf
  bool v8; // zf
  bool v9; // r1
  float v10; // s0
  RwMatrix *LTM; // r0
  __int64 v12; // d16
  RwReal z; // r0
  CVector v15; // [sp+0h] [bp-18h] BYREF

  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex <= 524 )
  {
    if ( (unsigned int)(m_nModelIndex - 514) < 2 || m_nModelIndex == 403 )
      goto LABEL_31;
    goto LABEL_13;
  }
  switch ( m_nModelIndex )
  {
    case 525:
      goto LABEL_8;
    case 591:
      goto LABEL_31;
    case 531:
LABEL_8:
      if ( (unsigned __int16)m_nModelIndex == 531 )
      {
        v6 = -0.6;
        if ( pVeh && pVeh->m_vehicleType == 11 && pVeh->m_nModelIndex != 610 )
          return 0;
      }
      else
      {
        v6 = -1.05;
        if ( pVeh && pVeh->m_vehicleType == 11 )
          return 0;
      }
      vecResult->x = 0.0;
      vecResult->y = v6 + CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.y;
      v10 = (float)((float)((float)(1.0
                                  - (float)((float)this->m_nSuspensionHydraulics / (float)TOWTRUCK_HOIST_DOWN_LIMIT))
                          * 0.5)
                  + 0.5)
          - this->m_fHeightAboveRoad;
LABEL_35:
      vecResult->z = v10;
      operator*(&v15, this->m_pMat, vecResult);
      v12 = *(_QWORD *)&v15.x;
      z = v15.z;
      goto LABEL_36;
  }
LABEL_13:
  if ( !pVeh )
    goto LABEL_20;
  v7 = (unsigned __int16)m_nModelIndex == 552;
  if ( (unsigned __int16)m_nModelIndex == 552 )
    v7 = pVeh->m_nModelIndex == 611;
  if ( !v7 )
  {
LABEL_20:
    if ( m_nModelIndex == 485 )
      goto LABEL_22;
    v8 = m_nModelIndex == 583;
    if ( m_nModelIndex != 583 )
      v8 = m_nModelIndex == 606;
    if ( v8 )
    {
LABEL_22:
      if ( !pVeh )
        goto LABEL_33;
    }
    else if ( !pVeh || (unsigned __int16)m_nModelIndex != 607 )
    {
      goto LABEL_33;
    }
    if ( (unsigned int)(pVeh->m_nModelIndex - 606) > 2 )
      goto LABEL_33;
  }
LABEL_31:
  if ( this->m_aCarNodes[20] )
  {
    LTM = RwFrameGetLTM(this->m_aCarNodes[20]);
    v12 = *(_QWORD *)&LTM->pos.x;
    z = LTM->pos.z;
LABEL_36:
    v9 = 1;
    vecResult->z = z;
    *(_QWORD *)&vecResult->x = v12;
    return v9;
  }
LABEL_33:
  v9 = 0;
  if ( bGenericPosOk )
  {
    vecResult->x = 0.0;
    vecResult->y = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.y + -0.5;
    v10 = 0.5 - this->m_fHeightAboveRoad;
    goto LABEL_35;
  }
  return v9;
}

//----- (0055E778) --------------------------------------------------------
bool __fastcall CAutomobile::SetTowLink(CAutomobile *this, CVehicle *pTractor, bool bWarpPosition)
{
  _BOOL4 v4; // r9
  bool v6; // r6
  unsigned int m_info; // r0
  int m_nModelIndex; // r0
  bool v10; // zf
  CMatrix *m_pMat; // r0
  float m_heading; // s0
  CMatrix *v13; // r0
  CMatrix *v14; // r1
  CSimpleTransform *p_tx; // r2
  float v16; // s2
  float v17; // s6
  float v18; // s4
  float v19; // s2
  float v20; // s0
  float *p_tz; // r0
  float v22; // [sp+0h] [bp-30h] BYREF
  float v23; // [sp+4h] [bp-2Ch]
  float v24; // [sp+8h] [bp-28h]
  float v25; // [sp+Ch] [bp-24h] BYREF
  float v26; // [sp+10h] [bp-20h]
  float v27; // [sp+14h] [bp-1Ch]

  v4 = bWarpPosition;
  if ( !pTractor || this->m_pTowingVehicle )
    return 0;
  m_info = (unsigned __int8)this->m_info;
  v6 = 0;
  if ( m_info >> 3 <= 0xA && ((1 << (m_info >> 3)) & 0x41C) != 0 )
  {
    if ( (m_info & 0xF8) == 16 )
    {
      CCarCtrl::SwitchVehicleToRealPhysics(this);
      LOBYTE(m_info) = this->m_info;
    }
    this->m_pTowingVehicle = pTractor;
    this->m_info = (CEntity::CEntityInfo)(m_info & 7 | 0x50);
    CEntity::RegisterReference(pTractor, &this->m_pTowingVehicle);
    pTractor->m_pVehicleBeingTowed = this;
    CEntity::RegisterReference(this, &pTractor->m_pVehicleBeingTowed);
    CPhysical::RemoveFromMovingList(this);
    CPhysical::RemoveFromMovingList(this->m_pTowingVehicle);
    CPhysical::AddToMovingList(this);
    CPhysical::AddToMovingList(this->m_pTowingVehicle);
    if ( !v4 )
    {
      v6 = 1;
      CVehicle::UpdateTrailerLink(this, 1, 0);
      return v6;
    }
    v26 = 0.0;
    v27 = 0.0;
    v22 = 0.0;
    v23 = 0.0;
    v24 = 0.0;
    v25 = 0.0;
    m_nModelIndex = pTractor->m_nModelIndex;
    v10 = m_nModelIndex == 531;
    if ( m_nModelIndex != 531 )
      v10 = m_nModelIndex == 525;
    if ( v10 )
      LOWORD(this->m_pTowingVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity) = TOWTRUCK_HOIST_UP_LIMIT;
    m_pMat = pTractor->m_pMat;
    if ( m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      m_heading = pTractor->m_transform.m_heading;
    v13 = this->m_pMat;
    if ( v13 )
      CMatrix::SetRotateZOnly(v13, m_heading);
    else
      this->m_transform.m_heading = m_heading;
    if ( (*((int (__fastcall **)(CAutomobile *, float *, int, CAutomobile *))this->_vptr$CPlaceable + 60))(
           this,
           &v22,
           1,
           this) != 1
      || (*((int (__fastcall **)(CVehicle *, float *, int, CAutomobile *))pTractor->_vptr$CPlaceable + 61))(
           pTractor,
           &v25,
           1,
           this) != 1 )
    {
      return 0;
    }
    v14 = this->m_pMat;
    p_tx = (CSimpleTransform *)&v14->tx;
    if ( !v14 )
      p_tx = &this->m_transform;
    v16 = v23 - p_tx->m_translate.y;
    v17 = v24 - p_tx->m_translate.z;
    v22 = v22 - p_tx->m_translate.x;
    v18 = v25 - v22;
    v23 = v16;
    v19 = v26 - v16;
    v20 = v27 - v17;
    v24 = v17;
    if ( v14 )
    {
      v14->tx = v18;
      this->m_pMat->ty = v19;
      p_tz = &this->m_pMat->tz;
    }
    else
    {
      p_tz = &this->m_transform.m_translate.z;
      this->m_transform.m_translate.x = v18;
      this->m_transform.m_translate.y = v19;
    }
    *p_tz = v20;
    CAutomobile::PlaceOnRoadProperly(this);
    return 1;
  }
  return v6;
}

//----- (0055E934) --------------------------------------------------------
void __fastcall CAutomobile::PlaceOnRoadProperly(CAutomobile *this)
{
  float z; // s20
  CColModel *ColModel; // r0
  CSimpleTransform *p_m_transform; // r9
  CMatrix *m_pMat; // r1
  CColLine *m_pLineArray; // r0
  float xy; // s0
  float yy; // s2
  float y; // s18
  float v10; // s16
  CSimpleTransform *p_tx; // r0
  float v12; // s4
  RwReal v13; // s0
  float v14; // s4
  float v15; // s2
  CEntity *v16; // r0
  int v17; // r5
  CEntity::CFlags m_nFlags; // r2
  RwReal v19; // s0
  CEntity *v20; // r0
  CEntity::CFlags v21; // r2
  CMatrix *v22; // r0
  float v23; // s2
  int v24; // r6
  CEntity *v25; // r0
  CEntity::CFlags v26; // r2
  float v27; // s22
  RwReal v28; // s0
  CEntity *v29; // r0
  CEntity::CFlags v30; // r2
  float v31; // r0
  float v32; // s18
  RwReal v33; // s0
  float v34; // r1
  float v35; // r2
  CMatrix *v36; // r0
  float v37; // s2
  float v38; // s0
  float v39; // s4
  float *p_tz; // r0
  CVector v41; // [sp+20h] [bp-A0h] BYREF
  CVector v42; // [sp+2Ch] [bp-94h] BYREF
  CEntity *refEntityPtr; // [sp+38h] [bp-88h] BYREF
  CColPoint colPoint; // [sp+3Ch] [bp-84h] BYREF
  CVector v45; // [sp+68h] [bp-58h] BYREF
  CVector vecStart; // [sp+74h] [bp-4Ch] BYREF

  ColModel = CEntity::GetColModel(this);
  p_m_transform = &this->m_transform;
  m_pMat = this->m_pMat;
  m_pLineArray = ColModel->m_pColData->_anon_1.m_pLineArray;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  y = m_pLineArray[3].m_vecStart.y;
  v10 = m_pLineArray->m_vecStart.y;
  p_tx = &this->m_transform;
  v12 = xy * y;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v13 = (float)(v10 * xy) + p_tx->m_translate.x;
  v45.x = p_tx->m_translate.x + v12;
  v14 = p_tx->m_translate.y;
  vecStart.x = v13;
  v45.y = v14 + (float)(yy * y);
  vecStart.y = (float)(v10 * yy) + v14;
  v15 = p_tx->m_translate.z + 5.0;
  vecStart.z = p_tx->m_translate.z;
  if ( CWorld::ProcessVerticalLine(&vecStart, v15, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    v16 = refEntityPtr;
    v17 = 1;
    z = colPoint.m_vecPosition.z;
    this->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
    m_nFlags = this->m_nFlags;
    *(_DWORD *)&m_nFlags = *(_DWORD *)&m_nFlags & 0xBFFFFFFF | (((*(_DWORD *)&v16->m_nFlags >> 30) & 1) << 30);
    this->m_nFlags = m_nFlags;
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&v16->m_nFlags & 0x80000000 | *(_DWORD *)&m_nFlags & 0x7FFFFFFF;
    this->m_nFlags.bdummy = m_nFlags.bdummy;
  }
  else
  {
    v17 = 0;
  }
  if ( CWorld::ProcessVerticalLine(&vecStart, vecStart.z + -5.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    if ( v17 )
    {
      v19 = colPoint.m_vecPosition.z;
      if ( fabsf(vecStart.z - z) <= fabsf(vecStart.z - colPoint.m_vecPosition.z) )
        goto LABEL_14;
    }
    else
    {
      v19 = colPoint.m_vecPosition.z;
    }
    v20 = refEntityPtr;
    z = v19;
    this->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
    v21 = this->m_nFlags;
    *(_DWORD *)&v21 = *(_DWORD *)&v21 & 0xBFFFFFFF | (((*(_DWORD *)&v20->m_nFlags >> 30) & 1) << 30);
    this->m_nFlags = v21;
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&v20->m_nFlags & 0x80000000 | *(_DWORD *)&v21 & 0x7FFFFFFF;
    this->m_nFlags.bdummy = v21.bdummy;
LABEL_14:
    vecStart.z = z;
    this->StoredCollPolys[0].lighting = colPoint.m_dataB.m_lighting;
    goto LABEL_15;
  }
  if ( v17 == 1 )
    goto LABEL_14;
LABEL_15:
  v22 = this->m_pMat;
  if ( v22 )
    p_m_transform = (CSimpleTransform *)&v22->tx;
  v23 = p_m_transform->m_translate.z + 5.0;
  v45.z = p_m_transform->m_translate.z;
  v24 = 0;
  if ( CWorld::ProcessVerticalLine(&v45, v23, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    v25 = refEntityPtr;
    v24 = 1;
    z = colPoint.m_vecPosition.z;
    this->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
    v26 = this->m_nFlags;
    *(_DWORD *)&v26 = *(_DWORD *)&v26 & 0xBFFFFFFF | (((*(_DWORD *)&v25->m_nFlags >> 30) & 1) << 30);
    this->m_nFlags = v26;
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&v25->m_nFlags & 0x80000000 | *(_DWORD *)&v26 & 0x7FFFFFFF;
    this->m_nFlags.bdummy = v26.bdummy;
  }
  v27 = -y;
  if ( CWorld::ProcessVerticalLine(&v45, v45.z + -5.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    if ( v24 )
    {
      v28 = colPoint.m_vecPosition.z;
      if ( fabsf(v45.z - z) <= fabsf(v45.z - colPoint.m_vecPosition.z) )
        goto LABEL_27;
    }
    else
    {
      v28 = colPoint.m_vecPosition.z;
    }
    v29 = refEntityPtr;
    z = v28;
    this->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
    v30 = this->m_nFlags;
    *(_DWORD *)&v30 = *(_DWORD *)&v30 & 0xBFFFFFFF | (((*(_DWORD *)&v29->m_nFlags >> 30) & 1) << 30);
    this->m_nFlags = v30;
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&v29->m_nFlags & 0x80000000 | *(_DWORD *)&v30 & 0x7FFFFFFF;
    this->m_nFlags.bdummy = v30.bdummy;
LABEL_27:
    v45.z = z;
    this->StoredCollPolys[1].lighting = colPoint.m_dataB.m_lighting;
    goto LABEL_28;
  }
  if ( v24 == 1 )
    goto LABEL_27;
LABEL_28:
  v31 = (*((float (__fastcall **)(CAutomobile *))this->_vptr$CPlaceable + 54))(this);
  v32 = v10 - y;
  vecStart.z = v31 + vecStart.z;
  v45.z = this->m_fRearHeightAboveRoad + v45.z;
  this->m_pMat->xx = (float)(vecStart.y - v45.y) / v32;
  v33 = vecStart.x - v45.x;
  this->m_pMat->yx = (float)-(float)(vecStart.x - v45.x) / v32;
  this->m_pMat->zx = 0.0;
  v42.x = v33;
  v42.y = vecStart.y - v45.y;
  v42.z = vecStart.z - v45.z;
  CVector::Normalise(&v42);
  *(CVector *)&this->m_pMat->xy = v42;
  CrossProduct(&v41, (const CVector *)this->m_pMat, (const CVector *)&this->m_pMat->xy);
  v34 = v41.y;
  v35 = v41.z;
  this->m_pMat->xz = v41.x;
  this->m_pMat->yz = v34;
  this->m_pMat->zz = v35;
  v36 = this->m_pMat;
  v37 = (float)(1.0 / v32) * (float)((float)(vecStart.y * v27) + (float)(v10 * v45.y));
  v38 = (float)(1.0 / v32) * (float)((float)(vecStart.z * v27) + (float)(v10 * v45.z));
  v39 = (float)(1.0 / v32) * (float)((float)(vecStart.x * v27) + (float)(v10 * v45.x));
  if ( v36 )
  {
    v36->tx = v39;
    this->m_pMat->ty = v37;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = v39;
    this->m_transform.m_translate.y = v37;
  }
  *p_tz = v38;
  if ( this->m_vehicleType == 4 )
    *(float *)&this[1].m_nFlags = CGeneral::GetATanOfXY(this->m_pMat->xy, this->m_pMat->yy);
}
// 55EA40: variable 'z' is possibly undefined

//----- (0055ECDC) --------------------------------------------------------
bool __fastcall CAutomobile::BreakTowLink(CAutomobile *this)
{
  CVehicle *m_pTowingVehicle; // r0
  CVehicle **p_m_pTowingVehicle; // r5
  CEntity::CEntityInfo m_info; // r1
  bool result; // r0
  CPed *pDriver; // r0
  _BOOL4 IsPlayer; // r0
  CEntity::CEntityInfo v8; // r1
  char v9; // r0

  m_pTowingVehicle = this->m_pTowingVehicle;
  if ( m_pTowingVehicle )
  {
    p_m_pTowingVehicle = &this->m_pTowingVehicle;
    if ( m_pTowingVehicle->m_pVehicleBeingTowed )
    {
      CEntity::CleanUpOldReference(m_pTowingVehicle->m_pVehicleBeingTowed, &m_pTowingVehicle->m_pVehicleBeingTowed);
      (*p_m_pTowingVehicle)->m_pVehicleBeingTowed = 0;
      m_pTowingVehicle = *p_m_pTowingVehicle;
    }
    CEntity::CleanUpOldReference(m_pTowingVehicle, &this->m_pTowingVehicle);
    *p_m_pTowingVehicle = 0;
  }
  m_info = this->m_info;
  if ( (*(_BYTE *)&m_info & 0xF0) != 80 )
    return 0;
  pDriver = this->pDriver;
  if ( pDriver )
  {
    IsPlayer = CPed::IsPlayer(pDriver);
    v8 = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7);
    if ( !IsPlayer )
      v8 = (CEntity::CEntityInfo)(*(_BYTE *)&v8 | 0x18);
  }
  else
  {
    v9 = *(_BYTE *)&m_info & 7;
    if ( this->m_nHealth < 1.0 )
      v8 = (CEntity::CEntityInfo)(v9 | 0x28);
    else
      v8 = (CEntity::CEntityInfo)(v9 | 0x20);
  }
  result = 1;
  this->m_info = v8;
  return result;
}

//----- (0055ED66) --------------------------------------------------------
CPed *__fastcall CAutomobile::KnockPedOutCar(CAutomobile *this, eWeaponType nHitType, uint16 nDoor, CPed *pPed)
{
  return pPed;
}

//----- (0055ED6A) --------------------------------------------------------
void __fastcall CAutomobile::PopBoot(CAutomobile *this)
{
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float v5; // [sp+0h] [bp-80h]
  float v6; // [sp+4h] [bp-7Ch]
  float v7; // [sp+8h] [bp-78h]
  CMatrix v8; // [sp+10h] [bp-70h] BYREF

  if ( (CDamageManager::GetDoorStatus(&this->Damage, BOOT_0) | 2) == 2 )
  {
    this->Door[1].m_fAngle = this->Door[1].m_fOpenAngle;
    CMatrix::CMatrix(&v8, &this->m_aCarNodes[17]->modelling, 0);
    tx = v8.tx;
    ty = v8.ty;
    tz = v8.tz;
    v5 = 0.0;
    v6 = 0.0;
    v7 = 0.0;
    *(&v5 + this->Door[1].m_nAxis) = this->Door[1].m_fAngle;
    CMatrix::SetRotate(&v8, v5, v6, v7);
    v8.tx = tx + v8.tx;
    v8.ty = ty + v8.ty;
    v8.tz = tz + v8.tz;
    CMatrix::UpdateRW(&v8);
    CMatrix::~CMatrix(&v8);
  }
}

//----- (0055EE0E) --------------------------------------------------------
void __fastcall CAutomobile::PopBootUsingPhysics(CAutomobile *this)
{
  CDamageManager *p_Damage; // r5
  uint32 DoorStatus; // r0

  p_Damage = &this->Damage;
  DoorStatus = CDamageManager::GetDoorStatus(&this->Damage, BOOT_0);
  if ( DoorStatus == 2 )
    goto LABEL_4;
  if ( !DoorStatus )
  {
    CDamageManager::SetDoorStatus(p_Damage, BOOT_0, 1u);
LABEL_4:
    CDamageManager::SetDoorStatus(p_Damage, BOOT_0, 3u);
  }
  this->Door[1].m_fAngVel = -2.0;
}

//----- (0055EE44) --------------------------------------------------------
void __fastcall CAutomobile::CloseBoot(CAutomobile *this)
{
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float v5; // [sp+0h] [bp-80h]
  float v6; // [sp+4h] [bp-7Ch]
  float v7; // [sp+8h] [bp-78h]
  CMatrix v8; // [sp+10h] [bp-70h] BYREF

  this->Door[1].m_fAngle = this->Door[1].m_fClosedAngle;
  CMatrix::CMatrix(&v8, &this->m_aCarNodes[17]->modelling, 0);
  tx = v8.tx;
  ty = v8.ty;
  tz = v8.tz;
  v5 = 0.0;
  v6 = 0.0;
  v7 = 0.0;
  *(&v5 + this->Door[1].m_nAxis) = this->Door[1].m_fAngle;
  CMatrix::SetRotate(&v8, v5, v6, v7);
  v8.tx = tx + v8.tx;
  v8.ty = ty + v8.ty;
  v8.tz = tz + v8.tz;
  CMatrix::UpdateRW(&v8);
  CMatrix::~CMatrix(&v8);
}

//----- (0055EED8) --------------------------------------------------------
void __fastcall CAutomobile::CloseAllDoors(CAutomobile *this)
{
  CBaseModelInfo *v2; // r5

  v2 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  if ( !(*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 2) )
    (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, _DWORD, int))this->_vptr$CPlaceable + 28))(
      this,
      0,
      10,
      2,
      0,
      1);
  if ( SLOBYTE(v2[1].m_pColModel) >= 2 )
  {
    if ( !(*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 3) )
      (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, _DWORD, int))this->_vptr$CPlaceable + 28))(
        this,
        0,
        8,
        3,
        0,
        1);
    if ( SLOBYTE(v2[1].m_pColModel) >= 3 )
    {
      if ( !(*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 4) )
        (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, _DWORD, int))this->_vptr$CPlaceable + 28))(
          this,
          0,
          11,
          4,
          0,
          1);
      if ( !(*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 5) )
        (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, _DWORD, int))this->_vptr$CPlaceable + 28))(
          this,
          0,
          9,
          5,
          0,
          1);
    }
  }
}

//----- (0055EF9C) --------------------------------------------------------
void __fastcall CAutomobile::DoHoverSuspensionRatios(CAutomobile *this)
{
  CCollisionData *m_pColData; // r10
  int v3; // r5
  int v4; // r11
  int i; // r8
  float x; // s26
  float y; // s28
  float z; // s30
  float v9; // s19
  float v10; // s21
  float v11; // s23
  float v12; // s17
  float v13; // s0
  float v14; // s2
  char *v15; // r0
  CVector v16; // [sp+8h] [bp-70h] BYREF
  float pWaterZ[25]; // [sp+14h] [bp-64h] BYREF

  if ( this->m_pMat->zz >= 0.3 && (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) == 0 )
  {
    m_pColData = CEntity::GetColModel(this)->m_pColData;
    v3 = 2024;
    v4 = 0;
    for ( i = 0; i != 4; ++i )
    {
      operator*(&v16, this->m_pMat, &m_pColData->_anon_1.m_pLineArray[v4].m_vecStart);
      x = v16.x;
      y = v16.y;
      z = v16.z;
      operator*(&v16, this->m_pMat, &m_pColData->_anon_1.m_pLineArray[v4].m_vecEnd);
      v9 = v16.y;
      v10 = v16.z;
      v11 = -100.0;
      v12 = v16.x;
      if ( *(float *)((char *)&this->_vptr$CPlaceable + v3) < 1.0 )
        v11 = this->m_aWheelColPoints[i].m_vecPosition.z;
      if ( CWaterLevel::GetWaterLevel(v16.x, v16.y, v16.z, pWaterZ, 0, 0) == 1 )
      {
        v13 = pWaterZ[0];
        if ( pWaterZ[0] > v11 )
        {
          v14 = 0.99999;
          if ( pWaterZ[0] > v10 )
          {
            v14 = 0.0;
            if ( pWaterZ[0] <= z )
              v14 = (float)(z - pWaterZ[0]) / (float)(z - v10);
          }
          *(float *)((char *)&this->_vptr$CPlaceable + v3) = v14;
          v15 = (char *)this + i * 44;
          *((_DWORD *)v15 + 466) = 0;
          *((_DWORD *)v15 + 467) = 0;
          *((_DWORD *)v15 + 468) = 1065353216;
          v15[1883] = 39;
          this->m_aWheelColPoints[i].m_vecPosition.z = v13;
          this->m_aWheelColPoints[i].m_vecPosition.y = y + (float)((float)(v9 - y) * v14);
          this->m_aWheelColPoints[i].m_vecPosition.x = x + (float)((float)(v12 - x) * v14);
        }
      }
      v3 += 4;
      ++v4;
    }
  }
}
// 55EF9C: using guessed type float pWaterZ[25];

//----- (0055F138) --------------------------------------------------------
void __fastcall CAutomobile::DoBurstAndSoftGroundRatios(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d5
  float32x2_t v4; // d12
  ColData *p_m_dataB; // r11
  float *m_aWheelRatios; // r10
  CDamageManager *p_Damage; // r5
  int32 v9; // r6
  float v10; // s16
  float v11; // s0
  float v12; // s29
  float *p_m_txdIndex; // r0
  float v14; // s19
  float v15; // s27
  float v16; // s31
  float v17; // s18
  float v18; // r4
  float v19; // s19
  float v20; // s2
  float v21; // s0
  uint32 hFlagsLocal; // r0
  bool v23; // nf
  int *v24; // r0
  float *p_m_n2dEffects; // [sp+8h] [bp-68h]
  CBaseModelInfo *v26; // [sp+Ch] [bp-64h]

  v4.n64_u32[0] = 1.0;
  p_m_dataB = &this->m_aWheelColPoints[0].m_dataB;
  m_aWheelRatios = this->m_aWheelRatios;
  p_Damage = &this->Damage;
  v9 = 0;
  v10 = fabsf(
          (float)((float)(this->m_vecMoveSpeed.x * this->m_pMat->xy) + (float)(this->m_vecMoveSpeed.y * this->m_pMat->yy))
        + (float)(this->m_vecMoveSpeed.z * this->m_pMat->zy));
  p_m_n2dEffects = (float *)&CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][1].m_n2dEffects;
  v26 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  do
  {
    if ( CDamageManager::GetWheelStatus(p_Damage, v9) == 2 )
    {
      *m_aWheelRatios = 1.0;
      goto LABEL_30;
    }
    if ( CDamageManager::GetWheelStatus(p_Damage, v9) == 1 )
    {
      if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259)
                      * (float)(int)((unsigned int)(float)(v10 * 40.0) + 98)) <= 99 )
      {
        v11 = *m_aWheelRatios
            + (float)((float)((float)(m_aWheelRatios[45] - m_aWheelRatios[41]) * 0.25) / m_aWheelRatios[45]);
        *m_aWheelRatios = v11;
        if ( v11 > 1.0 )
          *m_aWheelRatios = 1.0;
      }
    }
    else
    {
      v12 = *m_aWheelRatios;
      if ( *m_aWheelRatios < 1.0 )
      {
        if ( SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, p_m_dataB->m_nSurfaceType) == 4
          && this->m_nModelIndex != 432 )
        {
          hFlagsLocal = this->hFlagsLocal;
          v1.n64_u32[0] = 1041865114;
          if ( (hFlagsLocal & 0x200000) == 0 )
          {
            v23 = (hFlagsLocal & 0x100000) != 0;
            v24 = dword_55F408;
            if ( !v23 )
              v24 = &dword_55F408[1];
            v1.n64_u32[0] = *v24;
          }
          v3.n64_u32[0] = 1053609165;
          v2.n64_f32[0] = (float)((float)((float)(v10 * -0.7) / 0.3) + 1.0) + (float)(CWeather::WetRoads * -0.7);
          v2.n64_u64[0] = vmax_f32(v2, v3).n64_u64[0];
          v1.n64_f32[0] = *m_aWheelRatios
                        + (float)((float)((float)(m_aWheelRatios[45] - m_aWheelRatios[41])
                                        * (float)(v1.n64_f32[0] * v2.n64_f32[0]))
                                / m_aWheelRatios[45]);
          v1.n64_u64[0] = vmin_f32(v1, v4).n64_u64[0];
          goto LABEL_29;
        }
        v12 = *m_aWheelRatios;
      }
      if ( v12 < 1.0 && p_m_dataB->m_nSurfaceType == 178 )
      {
        p_m_txdIndex = p_m_n2dEffects;
        if ( (v9 | 2) == 2 )
          p_m_txdIndex = (float *)&v26[1].m_txdIndex;
        v14 = 1.5 / (float)(*p_m_txdIndex * 0.5);
        if ( v10 > 0.3 )
          v14 = (float)(v10 / 0.3) * v14;
        if ( (v15 = m_aWheelRatios[21],
              v16 = m_aWheelRatios[29],
              v17 = v15 / v14,
              v18 = floorf(v15 / v14),
              v19 = (float)(v15 + (float)(v16 * CTimer::ms_fTimeStep)) / v14,
              v20 = v17 - v18,
              v21 = v19 - floorf(v19),
              v16 > 0.0)
          && v21 < v20
          || v16 < 0.0 && v21 > v20 )
        {
          v1.n64_f32[0] = v12
                        + (float)((float)((float)(m_aWheelRatios[45] - m_aWheelRatios[41]) * -0.3) / m_aWheelRatios[45]);
          v2.n64_u32[0] = 1045220557;
          v1.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
LABEL_29:
          *m_aWheelRatios = v1.n64_f32[0];
        }
      }
    }
LABEL_30:
    ++v9;
    p_m_dataB = (ColData *)((char *)p_m_dataB + 44);
    ++m_aWheelRatios;
  }
  while ( v9 != 4 );
}
// 55F370: variable 'v1' is possibly undefined
// 55F370: variable 'v2' is possibly undefined
// 55F3B6: variable 'v3' is possibly undefined
// 55F3CA: variable 'v4' is possibly undefined
// 55F408: using guessed type int dword_55F408[2];

//----- (0055F430) --------------------------------------------------------
void __fastcall CAutomobile::ProcessSuspension(CAutomobile *this)
{
  int r9_1; // r9
  __int64 v3; // d16
  __int64 v4; // d17
  CMatrix *m_pMat; // r0
  float v6; // s8
  float v7; // s18
  uint32 v8; // r0
  float fSuspensionDamping; // s0
  int v10; // s2
  float v11; // s4
  float v12; // s2
  int v13; // s2
  float v14; // s4
  float v15; // s2
  int v16; // s2
  float v17; // s4
  float v18; // s2
  int v19; // s2
  float v20; // s4
  CCollisionData *m_pColData; // r8
  float m_fClosedAngle; // r1
  int v23; // r0
  float m_fAngle; // r0
  CVector *v25; // r6
  float v26; // s21
  int j; // r4
  float *v28; // r0
  RwReal v29; // s4
  RwReal v30; // s0
  __int64 v31; // d16
  float *v32; // r1
  float v33; // s0
  bool v34; // fnf
  float v35; // s0
  float v36; // s4
  float v37; // s2
  float v38; // s8
  float v39; // s10
  float v40; // s6
  float *p_x; // r1
  float v42; // s10
  float v43; // s8
  float v44; // s6
  float v45; // s25
  float *p_tx; // r1
  float v47; // s4
  float v48; // s8
  float v49; // s6
  float v50; // s23
  float *v51; // r1
  float xz; // s4
  float v53; // s0
  float v54; // s2
  float v55; // s21
  float v56; // s4
  int v57; // r6
  CVector *p_vecDirection; // r8
  float v59; // s0
  CVector *p_v; // r9
  float *fImpulseMagnitude; // r11
  CVector *v62; // r5
  float *i; // r10
  tHandlingData *pHandling; // r1
  uint32 hFlagsLocal; // r0
  float fSuspensionBias; // s2
  float fSuspensionForce; // s4
  float v68; // s6
  int v69; // r5
  unsigned int v70; // r6
  int v71; // r8
  __int64 v72; // d16
  float *v73; // r4
  CPhysical *v74; // r1
  float v75; // s2
  float v76; // s4
  float *v77; // r0
  float z; // s0
  float *v79; // r1
  float v80; // s4
  float *v81; // r0
  float v82; // s2
  unsigned int m_info; // r0
  float v84; // s20
  int *v85; // r1
  float v86; // s2
  float v87; // s0
  float v88; // s2
  float v89; // s18
  const CVector *p_xy; // r1
  float *p_xx; // r0
  float v92; // s2
  float v93; // s4
  float v94; // s16
  float v95; // s6
  float x; // s6
  float m_fMass; // s18
  CVector vecSpeed; // [sp+0h] [bp-218h]
  float *v99; // [sp+20h] [bp-1F8h]
  float *v100; // [sp+24h] [bp-1F4h]
  float *m_aWheelRatios; // [sp+28h] [bp-1F0h]
  float *v102; // [sp+2Ch] [bp-1ECh]
  CColPoint *m_aWheelColPoints; // [sp+74h] [bp-1A4h]
  RwReal *v104; // [sp+78h] [bp-1A0h]
  RwReal *v105; // [sp+7Ch] [bp-19Ch]
  CColPoint *v106; // [sp+80h] [bp-198h]
  RwReal *v107; // [sp+84h] [bp-194h]
  RwReal *v108; // [sp+88h] [bp-190h]
  CColPoint *v109; // [sp+8Ch] [bp-18Ch]
  RwReal *v110; // [sp+90h] [bp-188h]
  RwReal *v111; // [sp+94h] [bp-184h]
  CColPoint *v112; // [sp+98h] [bp-180h]
  RwReal *p_y; // [sp+9Ch] [bp-17Ch]
  RwReal *p_z; // [sp+A0h] [bp-178h]
  CVector *vecColNormal; // [sp+A4h] [bp-174h]
  CSimpleTransform *p_m_transform; // [sp+A8h] [bp-170h]
  CVector *vecOffset; // [sp+ACh] [bp-16Ch]
  float v118; // [sp+B0h] [bp-168h]
  float *v119; // [sp+C0h] [bp-158h]
  float *m_fSuspensionLength; // [sp+C4h] [bp-154h]
  CAutomobile *v121; // [sp+D0h] [bp-148h]
  CVector v1; // [sp+D4h] [bp-144h] BYREF
  CVector v2; // [sp+E0h] [bp-138h] BYREF
  __int64 v124; // [sp+F0h] [bp-128h] BYREF
  __int64 v125; // [sp+F8h] [bp-120h]
  CVector v; // [sp+100h] [bp-118h] BYREF
  CVector v127; // [sp+10Ch] [bp-10Ch] BYREF
  CVector v128; // [sp+118h] [bp-100h] BYREF
  CVector v129; // [sp+124h] [bp-F4h] BYREF
  CVector vecDirection; // [sp+130h] [bp-E8h] BYREF
  CVector v131; // [sp+13Ch] [bp-DCh] BYREF
  CVector v132; // [sp+148h] [bp-D0h] BYREF
  CVector v133; // [sp+154h] [bp-C4h] BYREF
  float v134[3]; // [sp+160h] [bp-B8h] BYREF
  float v135; // [sp+16Ch] [bp-ACh] BYREF
  float v136; // [sp+178h] [bp-A0h] BYREF
  float v137; // [sp+184h] [bp-94h] BYREF
  __int64 v138; // [sp+190h] [bp-88h] BYREF
  __int64 v139; // [sp+198h] [bp-80h]
  __int64 fSpringForce; // [sp+1A8h] [bp-70h] BYREF
  __int64 v141; // [sp+1B0h] [bp-68h]
  CVector v142; // 0:r1.12
  CVector v143; // 0:r1.12

  r9_1 = 1;
  fSpringForce = 0LL;
  v141 = 0LL;
  m_aWheelRatios = this->m_aWheelRatios;
  v3 = *(_QWORD *)this->m_aWheelRatios;
  v4 = *(_QWORD *)&this->m_aWheelRatios[2];
  v138 = v3;
  v139 = v4;
  if ( this->m_nModelIndex == 432 )
    r9_1 = 3;
  m_fSuspensionLength = this->m_fSuspensionLength;
  vecColNormal = &this->m_aWheelColPoints[0].m_vecNormal;
  p_z = &this->m_aWheelColPoints[3].m_vecPosition.z;
  p_y = &this->m_aWheelColPoints[3].m_vecPosition.y;
  v112 = &this->m_aWheelColPoints[3];
  v111 = &this->m_aWheelColPoints[2].m_vecPosition.z;
  v110 = &this->m_aWheelColPoints[2].m_vecPosition.y;
  v109 = &this->m_aWheelColPoints[2];
  v108 = &this->m_aWheelColPoints[1].m_vecPosition.z;
  v107 = &this->m_aWheelColPoints[1].m_vecPosition.y;
  v106 = &this->m_aWheelColPoints[1];
  v105 = &this->m_aWheelColPoints[0].m_vecPosition.z;
  v104 = &this->m_aWheelColPoints[0].m_vecPosition.y;
  m_aWheelColPoints = this->m_aWheelColPoints;
  v119 = &this[1].m_transform.m_translate.z;
  p_m_transform = &this->m_transform;
  v99 = &this->m_aWheelRatios[3];
  v102 = &this->m_aWheelRatios[2];
  v100 = &this->m_aWheelRatios[1];
  m_pMat = this->m_pMat;
  v6 = *(float *)&v3;
  v121 = this;
  v7 = fabsf(
         (float)((float)(this->m_vecMoveSpeed.x * m_pMat->xy) + (float)(this->m_vecMoveSpeed.y * m_pMat->yy))
       + (float)(this->m_vecMoveSpeed.z * m_pMat->zy));
  while ( 2 )
  {
    v34 = v6 < 1.0;
    v35 = -m_pMat->yz;
    v118 = v6;
    v36 = -m_pMat->xz;
    v37 = -m_pMat->zz;
    v38 = 0.0;
    v39 = 0.0;
    v40 = 0.0;
    vecDirection.y = v35;
    vecDirection.x = v36;
    vecDirection.z = v37;
    if ( v34 )
    {
      p_x = &p_m_transform->m_translate.x;
      if ( m_pMat )
        p_x = &m_pMat->tx;
      v40 = *v105 - p_x[2];
      v39 = *v104 - p_x[1];
      v38 = m_aWheelColPoints->m_vecPosition.x - *p_x;
    }
    v.y = v39;
    v42 = 0.0;
    v.x = v38;
    v43 = 0.0;
    v.z = v40;
    v44 = 0.0;
    v45 = *((float *)&v138 + 1);
    v131.x = v36;
    v131.y = v35;
    v131.z = v37;
    if ( *((float *)&v138 + 1) < 1.0 )
    {
      p_tx = &p_m_transform->m_translate.x;
      if ( m_pMat )
        p_tx = &m_pMat->tx;
      v44 = *v108 - p_tx[2];
      v42 = *v107 - p_tx[1];
      v43 = v106->m_vecPosition.x - *p_tx;
    }
    v132.x = v36;
    v47 = 0.0;
    v127.y = v42;
    v127.x = v43;
    v48 = 0.0;
    v127.z = v44;
    v49 = 0.0;
    v50 = *(float *)&v139;
    v132.y = v35;
    v132.z = v37;
    if ( *(float *)&v139 < 1.0 )
    {
      v51 = &p_m_transform->m_translate.x;
      if ( m_pMat )
        v51 = &m_pMat->tx;
      v48 = *v111 - v51[2];
      v49 = *v110 - v51[1];
      v47 = v109->m_vecPosition.x - *v51;
    }
    v128.z = v48;
    v128.y = v49;
    vecOffset = (CVector *)r9_1;
    v128.x = v47;
    xz = m_pMat->xz;
    v133.y = v35;
    v53 = 0.0;
    v133.z = v37;
    v54 = 0.0;
    v55 = *((float *)&v139 + 1);
    v133.x = -xz;
    v56 = 0.0;
    if ( *((float *)&v139 + 1) < 1.0 )
    {
      v53 = *p_z - m_pMat->tz;
      v56 = *p_y - m_pMat->ty;
      v54 = v112->m_vecPosition.x - m_pMat->tx;
    }
    v129.y = v56;
    v129.x = v54;
    v57 = 0;
    v129.z = v53;
    p_vecDirection = &vecDirection;
    v59 = v118;
    p_v = &v;
    fImpulseMagnitude = (float *)&fSpringForce;
    v62 = vecColNormal;
    for ( i = (float *)&v138 + 1; ; ++i )
    {
      if ( v59 >= 1.0 )
        goto LABEL_85;
      pHandling = v121->pHandling;
      hFlagsLocal = v121->hFlagsLocal;
      fSuspensionBias = pHandling->fSuspensionBias;
      if ( (v57 | 2) == 3 )
        fSuspensionBias = 1.0 - fSuspensionBias;
      if ( (unsigned __int8 *)(hFlagsLocal & (unsigned int)&stru_2FFFC.st_info) == &stru_2FFFC.st_info
        && (*(_BYTE *)&v121->m_info & 0xF8) == 24 )
      {
        fSuspensionBias = 0.5;
      }
      fSuspensionForce = pHandling->fSuspensionForce;
      if ( v7 < 0.15 && (hFlagsLocal & 0x20000) != 0 )
      {
        v68 = fSuspensionForce * 1.5;
        if ( (hFlagsLocal & 0x10000) == 0 )
          v68 = pHandling->fSuspensionForce;
      }
      else
      {
        v68 = v121->m_nModelIndex == 539 ? fSuspensionForce * (float)((float)(fabsf(*v119) * 0.25) + 1.0) : pHandling->fSuspensionForce;
      }
      if ( !CCheat::m_aCheatsActive[41] && v121->m_nModelIndex != 539 )
        break;
      CPhysical::ApplySpringCollision(v121, v68, p_vecDirection, p_v, v59, fSuspensionBias, fImpulseMagnitude);
LABEL_85:
      if ( v57 == 3 )
        goto LABEL_88;
LABEL_67:
      ++v57;
      v62 = (CVector *)((char *)v62 + 44);
      ++fImpulseMagnitude;
      ++p_v;
      ++p_vecDirection;
      v59 = *i;
    }
    CPhysical::ApplySpringCollisionAlt(v121, v68, p_vecDirection, p_v, v59, fSuspensionBias, v62, fImpulseMagnitude);
    if ( v57 != 3 )
      goto LABEL_67;
LABEL_88:
    v69 = 0;
    v70 = 0;
    v71 = 0;
    do
    {
      CPhysical::GetSpeed((CVector *)&v124, v121, *(CVector *)((char *)&v + v70));
      v72 = v124;
      v73 = &v134[v70 / 4];
      *((_DWORD *)v73 + 2) = v125;
      *(_QWORD *)v73 = v72;
      v74 = v121->m_aGroundPhysicalPtrs[v69];
      if ( v74 )
      {
        CPhysical::GetSpeed((CVector *)&v124, v74, v121->m_aGroundOffsets[v70 / 0xC]);
        v75 = v73[1] - *((float *)&v124 + 1);
        v76 = v73[2] - *(float *)&v125;
        *v73 = *v73 - *(float *)&v124;
        v73[1] = v75;
        v73[2] = v76;
      }
      if ( v121->m_aWheelRatios[v69] < 1.0 )
      {
        v77 = (float *)((char *)v121 + v71 * 44);
        z = v121->m_aWheelColPoints[v71].m_vecNormal.z;
        if ( z > 0.35 )
        {
          v79 = v77 + 467;
          v80 = v77[466];
          v81 = (float *)((char *)&vecDirection.x + v70);
          v82 = -*v79;
          *v81 = -v80;
          v81[1] = v82;
          v81[2] = -z;
        }
      }
      v70 += 12;
      ++v69;
      ++v71;
    }
    while ( v70 != 48 );
    v8 = v121->hFlagsLocal;
    fSuspensionDamping = v121->pHandling->fSuspensionDamping;
    v10 = LODWORD(fSuspensionDamping);
    if ( (v8 & 0x20000) != 0 )
      v10 = 1036831949;
    v11 = v121->pHandling->fSuspensionDamping;
    if ( fSuspensionDamping > 0.1 )
      v11 = *(float *)&v10;
    v12 = v121->pHandling->fSuspensionDamping;
    if ( v7 < 0.15 )
      v12 = v11;
    if ( v118 < 0.99999 && *(_BYTE *)&v121->m_nAutomobileFlags >= 0 )
    {
      CPhysical::ApplySpringDampening(v121, v12, *(float *)&fSpringForce, &vecDirection, &v, v134);
      v8 = v121->hFlagsLocal;
      fSuspensionDamping = v121->pHandling->fSuspensionDamping;
    }
    v13 = LODWORD(fSuspensionDamping);
    if ( (v8 & 0x20000) != 0 )
      v13 = 1036831949;
    v14 = fSuspensionDamping;
    if ( fSuspensionDamping > 0.1 )
      v14 = *(float *)&v13;
    v15 = fSuspensionDamping;
    if ( v7 < 0.15 )
      v15 = v14;
    if ( v45 < 0.99999 && *(_BYTE *)&v121->m_nAutomobileFlags >= 0 )
    {
      CPhysical::ApplySpringDampening(v121, v15, *((float *)&fSpringForce + 1), &v131, &v127, &v135);
      v8 = v121->hFlagsLocal;
      fSuspensionDamping = v121->pHandling->fSuspensionDamping;
    }
    v16 = LODWORD(fSuspensionDamping);
    if ( (v8 & 0x20000) != 0 )
      v16 = 1036831949;
    v17 = fSuspensionDamping;
    if ( fSuspensionDamping > 0.1 )
      v17 = *(float *)&v16;
    v18 = fSuspensionDamping;
    if ( v7 < 0.15 )
      v18 = v17;
    if ( v50 < 0.99999 && *(_BYTE *)&v121->m_nAutomobileFlags >= 0 )
    {
      CPhysical::ApplySpringDampening(v121, v18, *(float *)&v141, &v132, &v128, &v136);
      v8 = v121->hFlagsLocal;
      fSuspensionDamping = v121->pHandling->fSuspensionDamping;
    }
    *(float *)&v19 = fSuspensionDamping;
    if ( (v8 & 0x20000) != 0 )
      *(float *)&v19 = 0.1;
    v20 = fSuspensionDamping;
    if ( fSuspensionDamping > 0.1 )
      v20 = *(float *)&v19;
    if ( v7 < 0.15 )
      fSuspensionDamping = v20;
    if ( v55 < 0.99999 && *(_BYTE *)&v121->m_nAutomobileFlags >= 0 )
      CPhysical::ApplySpringDampening(v121, fSuspensionDamping, *((float *)&v141 + 1), &v133, &v129, &v137);
    if ( (int)vecOffset >= 2 && v121->m_nModelIndex == 432 )
    {
      m_pColData = CEntity::GetColModel(v121)->m_pColData;
      v124 = unk_61E9F0;
      v125 = unk_61E9F8;
      if ( vecOffset == (CVector *)((char *)&dword_0 + 2) )
      {
        m_fClosedAngle = v121->Door[4].m_fClosedAngle;
        *(float *)&v138 = m_fClosedAngle;
        HIDWORD(v138) = LODWORD(v121->Door[4].m_fAngle);
        *(float *)&v139 = v121->Door[5].m_fClosedAngle;
        m_fAngle = v121->Door[5].m_fAngle;
        v124 = 0x600000005LL;
        v125 = 0xA00000009LL;
        *((float *)&v139 + 1) = m_fAngle;
        v23 = 5;
        goto LABEL_46;
      }
      if ( vecOffset == (CVector *)((char *)&dword_0 + 3) )
      {
        m_fClosedAngle = v121->Door[4].m_fOpenAngle;
        *(float *)&v138 = m_fClosedAngle;
        HIDWORD(v138) = LODWORD(v121->Door[4].m_fPrevAngle);
        *(float *)&v139 = v121->Door[5].m_fOpenAngle;
        HIDWORD(v139) = LODWORD(v121->Door[5].m_fPrevAngle);
        v23 = 4;
LABEL_46:
        v25 = &v;
        v26 = m_fClosedAngle;
        for ( j = 0; ; ++j )
        {
          v28 = &m_pColData->_anon_1.m_pLineArray[v23].m_vecStart.x;
          v29 = v28[1] + 0.0;
          v30 = v28[2] - (float)(v26 * m_fSuspensionLength[j + 4]);
          v25->x = *v28 + 0.0;
          v25->y = v29;
          v25->z = v30;
          Multiply3x3(&v2, v121->m_pMat, v25);
          v31 = *(_QWORD *)&v2.x;
          v25->z = v2.z;
          *(_QWORD *)&v25->x = v31;
          v32 = (float *)((char *)&v138 + j * 4 + 4);
          v33 = 1.0 - (float)(m_fSuspensionLength[j] / m_fSuspensionLength[j + 4]);
          *(float *)((char *)&v138 + j * 4) = (float)(v26 - v33) / (float)(1.0 - v33);
          if ( j == 3 )
            break;
          v23 = *(_DWORD *)((char *)&v124 + j * 4 + 4);
          v26 = *v32;
          ++v25;
        }
      }
    }
    if ( (int)vecOffset >= 2 )
    {
      r9_1 = (int)&vecOffset[-1].z + 3;
      v6 = *(float *)&v138;
      m_pMat = v121->m_pMat;
      continue;
    }
    break;
  }
  m_info = (unsigned __int8)v121->m_info;
  v84 = ROLL_ONTO_WHEELS_FORCE;
  if ( m_info >> 3 )
  {
    v85 = dword_55FE3C;
    v86 = ROLL_ONTO_WHEELS_FORCE + ROLL_ONTO_WHEELS_FORCE;
    if ( m_info >> 3 == 8 )
    {
      v86 = ROLL_ONTO_WHEELS_FORCE;
      v85 = &dword_55FE3C[1];
    }
    v84 = v86;
    v87 = *(float *)v85;
  }
  else
  {
    v87 = 0.02;
  }
  if ( v7 < v87 )
  {
    if ( *m_aWheelRatios == 1.0 && *v100 == 1.0 )
    {
      v88 = *v102;
      if ( *v102 < 1.0 )
      {
        v89 = 1.0;
        goto LABEL_113;
      }
      v89 = 1.0;
      if ( *v99 < 1.0 )
        goto LABEL_113;
    }
    else
    {
      v88 = *v102;
    }
    if ( v88 == 1.0 && *v99 == 1.0 )
    {
      v89 = -1.0;
      if ( *m_aWheelRatios < 1.0 || *v100 < 1.0 )
      {
LABEL_113:
        p_xy = (const CVector *)&v121->m_pMat->xy;
        v2.x = 0.0;
        v2.y = 0.0;
        v2.z = 1.0;
        CrossProduct((CVector *)&v124, p_xy, &v2);
        p_xx = &v121->m_pMat->xx;
        v92 = p_xx[1];
        v93 = p_xx[2];
        if ( fabsf(
               (float)((float)(*p_xx * *(float *)&v124) + (float)(v92 * *((float *)&v124 + 1)))
             + (float)(v93 * *(float *)&v125)) < 0.6 )
        {
          v94 = v84 * v89;
          v95 = (float)(v84 * v89) * v121->m_fTurnMass;
          v142.x = p_xx[8] * v95;
          v142.y = v95 * p_xx[9];
          v142.z = v95 * p_xx[10];
          x = CModelInfo::ms_modelInfoPtrs[v121->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.x;
          vecSpeed.x = *p_xx * x;
          vecSpeed.y = v92 * x;
          vecSpeed.z = v93 * x;
          CPhysical::ApplyTurnForce(v121, v142, vecSpeed);
          m_fMass = v121->m_fMass;
          v1.x = 0.0;
          v1.y = 0.0;
          v1.z = 1.0;
          CrossProduct(&v2, &v1, (const CVector *)&v121->m_pMat->xy);
          v143.x = (float)(v94 * m_fMass) * v2.x;
          v143.y = (float)(v94 * m_fMass) * v2.y;
          v143.z = (float)(v94 * m_fMass) * v2.z;
          CPhysical::ApplyMoveForce(v121, v143);
        }
      }
    }
  }
}
// 0: using guessed type int dword_0;
// 2FFFC: using guessed type Elf32_Sym stru_2FFFC;
// 55FE3C: using guessed type int dword_55FE3C[2];
// 55F430: using guessed type float var_B8[3];

//----- (0055FE50) --------------------------------------------------------
float __fastcall CAutomobile::GetCarRoll(CAutomobile *this)
{
  CMatrix *m_pMat; // r0
  float v2; // s0

  m_pMat = this->m_pMat;
  v2 = sqrtf((float)(m_pMat->xx * m_pMat->xx) + (float)(m_pMat->yx * m_pMat->yx));
  if ( m_pMat->zz < 0.0 )
    v2 = -v2;
  return (float)(atan2f(m_pMat->zx, v2) * 180.0) / 3.1416;
}

//----- (0055FEB0) --------------------------------------------------------
float __fastcall CAutomobile::GetCarPitch(CAutomobile *this)
{
  CMatrix *m_pMat; // r0
  float v2; // s0

  m_pMat = this->m_pMat;
  v2 = sqrtf((float)(m_pMat->xy * m_pMat->xy) + (float)(m_pMat->yy * m_pMat->yy));
  if ( m_pMat->zz < 0.0 )
    v2 = -v2;
  return sub_18D4E8(m_pMat->zy, v2);
}

//----- (0055FEEC) --------------------------------------------------------
float __fastcall CAutomobile::FindWheelWidth(CAutomobile *this, bool bRear)
{
  int m_nModelIndex; // r12
  CBaseModelInfo *v3; // r2
  float *p_m_txdIndex; // r3
  uint32 hFlagsLocal; // r2
  float v6; // s0
  float v7; // s2
  bool v8; // nf
  float v9; // s2
  float v10; // s2

  m_nModelIndex = this->m_nModelIndex;
  v3 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex];
  p_m_txdIndex = (float *)&v3[1].m_txdIndex;
  if ( bRear )
    p_m_txdIndex = (float *)&v3[1].m_n2dEffects;
  hFlagsLocal = this->hFlagsLocal;
  v6 = (float)(*p_m_txdIndex / 0.7) * 0.25;
  if ( bRear )
  {
    if ( (hFlagsLocal & 0xF000) != 0 )
    {
      if ( (hFlagsLocal & 0x1000) == 0 )
      {
        if ( (hFlagsLocal & 0x2000) == 0 )
        {
          if ( (hFlagsLocal & 0x4000) == 0 )
          {
            v7 = 1.25;
            v8 = (this->hFlagsLocal & 0x8000) != 0;
            goto LABEL_14;
          }
          goto LABEL_20;
        }
        goto LABEL_19;
      }
LABEL_18:
      v10 = 0.65;
LABEL_21:
      v9 = v6 * v10;
      goto LABEL_22;
    }
LABEL_17:
    v9 = (float)(*p_m_txdIndex / 0.7) * 0.25;
    goto LABEL_22;
  }
  if ( (hFlagsLocal & 0xF00) == 0 )
    goto LABEL_17;
  if ( (hFlagsLocal & 0x100) != 0 )
    goto LABEL_18;
  if ( (hFlagsLocal & 0x200) != 0 )
  {
LABEL_19:
    v10 = 0.8;
    goto LABEL_21;
  }
  if ( (hFlagsLocal & 0x400) != 0 )
  {
LABEL_20:
    v10 = 1.1;
    goto LABEL_21;
  }
  v7 = 1.25;
  v8 = (this->hFlagsLocal & 0x800) != 0;
LABEL_14:
  v9 = v6 * v7;
  if ( !v8 )
    v9 = (float)(*p_m_txdIndex / 0.7) * 0.25;
LABEL_22:
  if ( (unsigned __int16)m_nModelIndex == 571 )
    return v9 * 1.5;
  return v9;
}

//----- (0055FFAC) --------------------------------------------------------
void __fastcall CAutomobile::DoHeliDustEffect(CAutomobile *this, float power, float radiusMult)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  int32 m_vehicleType; // r0
  CSimpleTransform *p_m_transform; // r11
  int v10; // r6
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r0
  float z; // s16
  int IsSand; // r8
  CMatrix *v15; // r0
  CSimpleTransform *v16; // r2
  int m_nModelIndex; // r0
  bool v18; // zf
  float v19; // s0
  CSimpleTransform *v20; // r5
  CMatrix *v21; // r2
  float *p_z; // r5
  float32x2_t v23; // d16
  CSimpleTransform *v24; // r2
  float v25; // s2
  float32x2_t v26; // d16
  unsigned __int64 v27; // d3
  float v28; // s18
  float v29; // s0
  float v30; // s2
  CEventGlobalGroup *EventGlobalGroup; // r0
  FxSystem_c *m_fxSysHeliDust; // r0
  CMatrix *v33; // r1
  CSimpleTransform *v34; // r2
  float v35; // s0
  FxSystem_c *v36; // r0
  CMatrix *v37; // r0
  FxSystem_c *FxSystem; // r0
  FxSystem_c *v39; // r0
  FxSystem_c *v40; // r0
  bool8 v41; // r2
  CEventDanger v42; // [sp+20h] [bp-80h] BYREF
  CEntity *refEntityPtr; // [sp+3Ch] [bp-64h] BYREF
  CColPoint colPoint; // [sp+40h] [bp-60h] BYREF
  float pWaterZ[13]; // [sp+6Ch] [bp-34h] BYREF

  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 4 || m_vehicleType == 3 && this->m_aWheelAngularVelocity[1] > 0.1125 )
  {
    p_m_transform = &this->m_transform;
    v10 = 0;
    pWaterZ[0] = -1000.0;
    m_pMat = this->m_pMat;
    p_tx = &this->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    CWorld::ProcessVerticalLine(&p_tx->m_translate, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0);
    z = colPoint.m_vecPosition.z;
    IsSand = SurfaceInfos_c::IsSand(&g_surfaceInfos, colPoint.m_dataB.m_nSurfaceType);
    v15 = this->m_pMat;
    v16 = &this->m_transform;
    if ( v15 )
      v16 = (CSimpleTransform *)&v15->tx;
    if ( CWaterLevel::GetWaterLevel(v16->m_translate.x, v16->m_translate.y, v16->m_translate.z, pWaterZ, 0, 0) == 1 )
    {
      if ( pWaterZ[0] <= z )
      {
        v10 = 0;
      }
      else
      {
        v10 = 1;
        z = pWaterZ[0];
      }
    }
    m_nModelIndex = this->m_nModelIndex;
    v18 = m_nModelIndex == 501;
    if ( m_nModelIndex != 501 )
      v18 = m_nModelIndex == 465;
    if ( v18 )
      v19 = 3.0;
    else
      v19 = 30.0;
    v20 = &this->m_transform;
    v21 = this->m_pMat;
    if ( v21 )
      v20 = (CSimpleTransform *)&v21->tx;
    v23.n64_u64[0] = *(unsigned __int64 *)&v20->m_translate.x;
    p_z = &v20->m_translate.z;
    v24 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      v24 = &TheCamera.m_transform;
    v25 = *p_z;
    v26.n64_u64[0] = vsub_f32(v23, *(float32x2_t *)&v24->m_translate.x).n64_u64[0];
    v27 = vmul_f32(v26, v26).n64_u64[0];
    if ( (float)((float)(*(float *)&v27 + *((float *)&v27 + 1))
               + (float)((float)(*p_z - v24->m_translate.z) * (float)(*p_z - v24->m_translate.z))) < 2500.0 )
    {
      v28 = v19 * radiusMult;
      v29 = v25 - z;
      if ( (float)(v25 - z) < v28 )
      {
        if ( !(CTimer::m_FrameCounter % 0x14) )
        {
          v30 = 20.0;
          if ( (unsigned __int16)m_nModelIndex == 520 )
            v30 = 30.0;
          if ( v29 < v30 )
          {
            CEventDanger::CEventDanger(&v42, this, v30);
            EventGlobalGroup = GetEventGlobalGroup();
            CEventGroup::Add(EventGlobalGroup, (CEvent *)&v42, 0);
            CEventDanger::~CEventDanger(&v42);
          }
        }
        m_fxSysHeliDust = this->m_fxSysHeliDust;
        if ( !m_fxSysHeliDust )
        {
          memset(&v42, 0, 12);
          FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, "heli_dust", (RwV3d_0 *)&v42, 0, 1);
          this->m_fxSysHeliDust = FxSystem;
          if ( !FxSystem )
            return;
          FxSystem_c::SetLocalParticles(FxSystem, 1u);
          FxSystem_c::Play(this->m_fxSysHeliDust);
          m_fxSysHeliDust = this->m_fxSysHeliDust;
          if ( !m_fxSysHeliDust )
            return;
        }
        v33 = this->m_pMat;
        v34 = &this->m_transform;
        if ( v33 )
          v34 = (CSimpleTransform *)&v33->tx;
        v35 = (float)((float)(v28 - (float)(v34->m_translate.z - z)) / v28) * power;
        v4.n64_f32[0] = v35 * v35;
        v3.n64_u32[0] = LODWORD(this->m_heliDustRatio);
        if ( v4.n64_f32[0] <= v3.n64_f32[0] )
        {
          if ( v4.n64_f32[0] >= v3.n64_f32[0] )
          {
LABEL_39:
            FxSystem_c::SetConstTime(m_fxSysHeliDust, 1u, v3.n64_f32[0]);
            v37 = this->m_pMat;
            if ( v37 )
              p_m_transform = (CSimpleTransform *)&v37->tx;
            *(_QWORD *)&v42._vptr$CEvent = *(_QWORD *)&p_m_transform->m_translate.x;
            *(float *)&v42.m_bIsPersistent = z;
            FxSystem_c::SetOffsetPos(this->m_fxSysHeliDust, (RwV3d_0 *)&v42);
            if ( v10 )
            {
              FxSystem_c::EnablePrim(this->m_fxSysHeliDust, 0, 0);
              FxSystem_c::EnablePrim(this->m_fxSysHeliDust, 1, 0);
              FxSystem_c::EnablePrim(this->m_fxSysHeliDust, 2, 1u);
            }
            else
            {
              v39 = this->m_fxSysHeliDust;
              if ( IsSand )
              {
                FxSystem_c::EnablePrim(v39, 0, 0);
                v40 = this->m_fxSysHeliDust;
                v41 = 1;
              }
              else
              {
                FxSystem_c::EnablePrim(v39, 0, 1u);
                v40 = this->m_fxSysHeliDust;
                v41 = 0;
              }
              FxSystem_c::EnablePrim(v40, 1, v41);
              FxSystem_c::EnablePrim(this->m_fxSysHeliDust, 2, 0);
            }
            return;
          }
          v3.n64_f32[0] = v3.n64_f32[0] + -0.04;
          v3.n64_u32[0] = vmax_f32(v3, v4).n64_u32[0];
        }
        else
        {
          v3.n64_f32[0] = v3.n64_f32[0] + 0.04;
          v3.n64_u32[0] = vmin_f32(v3, v4).n64_u32[0];
        }
        LODWORD(this->m_heliDustRatio) = v3.n64_u32[0];
        goto LABEL_39;
      }
    }
  }
  v36 = this->m_fxSysHeliDust;
  if ( v36 )
  {
    FxSystem_c::Kill(v36);
    this->m_heliDustRatio = 0.0;
    this->m_fxSysHeliDust = 0;
  }
}
// 560192: variable 'v3' is possibly undefined
// 560192: variable 'v4' is possibly undefined
// 55FFAC: using guessed type float pWaterZ[13];

//----- (005602C8) --------------------------------------------------------
float __fastcall CAutomobile::GetDooorAngleOpenRatio(const CAutomobile *this, uint32 iDoorIndex)
{
  uint32 v2; // r1
  float result; // r0

  v2 = iDoorIndex - 8;
  switch ( v2 )
  {
    case 0u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 30))(this, 3));
      break;
    case 1u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 30))(this, 5));
      break;
    case 2u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 30))(this, 2));
      break;
    case 3u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 30))(this, 4));
      break;
    default:
      result = 0.0;
      break;
  }
  return result;
}

//----- (005602FC) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorReady(const CAutomobile *this, uint32 iDoorIndex)
{
  uint32 v2; // r2
  bool v3; // r1
  bool result; // r0

  v2 = iDoorIndex - 8;
  v3 = 0;
  switch ( v2 )
  {
    case 0u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 31))(this, 3);
      break;
    case 1u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 31))(this, 5);
      break;
    case 2u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 31))(this, 2);
      break;
    case 3u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 31))(this, 4);
      break;
    case 0xAu:
      v3 = 1;
      goto LABEL_7;
    default:
LABEL_7:
      result = v3;
      break;
  }
  return result;
}

//----- (0056033C) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorFullyOpen(const CAutomobile *this, uint32 iDoorIndex)
{
  uint32 v2; // r1
  bool result; // r0

  v2 = iDoorIndex - 8;
  switch ( v2 )
  {
    case 0u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 32))(this, 3);
      break;
    case 1u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 32))(this, 5);
      break;
    case 2u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 32))(this, 2);
      break;
    case 3u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 32))(this, 4);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00560378) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorClosed(const CAutomobile *this, uint32 iDoorIndex)
{
  uint32 v2; // r1
  bool result; // r0

  v2 = iDoorIndex - 8;
  switch ( v2 )
  {
    case 0u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 33))(this, 3);
      break;
    case 1u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 33))(this, 5);
      break;
    case 2u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 33))(this, 2);
      break;
    case 3u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 33))(this, 4);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (005603B4) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorMissing(const CAutomobile *this, uint32 iDoorIndex)
{
  uint32 v2; // r2
  bool v3; // r1
  bool result; // r0

  v2 = iDoorIndex - 8;
  v3 = 0;
  switch ( v2 )
  {
    case 0u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 3);
      break;
    case 1u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 5);
      break;
    case 2u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 2);
      break;
    case 3u:
      result = (*((int (__fastcall **)(const CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 4);
      break;
    case 0xAu:
      v3 = 1;
      goto LABEL_7;
    default:
LABEL_7:
      result = v3;
      break;
  }
  return result;
}

//----- (005603FC) --------------------------------------------------------
CRideAnimData *__fastcall CVehicle::GetRideAnimData(CVehicle *this)
{
  return 0;
}

//----- (00560400) --------------------------------------------------------
float __fastcall CAutomobile::GetHeightAboveRoad(const CAutomobile *this)
{
  return this->m_fHeightAboveRoad;
}

//----- (00560406) --------------------------------------------------------
int __fastcall CAutomobile::GetNumContactWheels(CAutomobile *this)
{
  return this->nNoOfContactWheels;
}

//----- (0056040C) --------------------------------------------------------
void __fastcall CEventVehicleDamageCollision::~CEventVehicleDamageCollision(CEventVehicleDamageCollision *this)
{
  void *v1; // r0

  CEventVehicleDamage::~CEventVehicleDamage(this);
  sub_1978E4(v1);
}
// 560418: variable 'v1' is possibly undefined

//----- (0056041C) --------------------------------------------------------
int __fastcall CEventVehicleDamageCollision::GetEventType(const CEventVehicleDamageCollision *this)
{
  return 73;
}

//----- (00560420) --------------------------------------------------------
CEvent *__fastcall CEventVehicleDamageCollision::CloneEditable(const CEventVehicleDamageCollision *this)
{
  CEventVehicleDamage *v2; // r0
  CEvent *result; // r0

  v2 = (CEventVehicleDamage *)CEvent::operator new(0x1Cu);
  CEventVehicleDamage::CEventVehicleDamage(
    v2,
    this->m_pVehicle,
    this->m_pInflictor,
    (const eWeaponType)this->m_eWeaponUsed);
  result->_vptr$CEvent = (int (**)(void))&off_66D7A0;
  return result;
}
// 56043E: variable 'result' is possibly undefined
// 66D7A0: using guessed type void *off_66D7A0;

//----- (00560448) --------------------------------------------------------
RwObject_0 *__fastcall GetBikeAtomicObjectCB(RwObject_0 *pObject, void *data)
{
  if ( (pObject->flags & 4) != 0 )
    *(_DWORD *)data = pObject;
  return pObject;
}

//----- (00560454) --------------------------------------------------------
void __fastcall CBike::CBike(CBike *this, int nModelIndex, UInt8 CreatedBy)
{
  CVehicleModelInfo *v5; // r9
  int m_handlingId_low; // r6
  AssocGroupId m_firstAssocGroup; // r0
  int (**v8)(void); // r0
  char *v9; // r1
  float v10; // r0
  tHandlingData *pHandling; // r1
  float fDragCoeff; // s0
  float fBuoyancyConstant; // r0
  CCollisionData *m_pColData; // r6
  CColLine *m_pLineArray; // r0
  CColLine *v16; // r0
  CEntity::CEntityInfo m_info; // r2
  CMatrix *m_pMat; // r1
  int m_nVehicleFlags; // r3
  __int16 v20; // r6

  CVehicle::CVehicle(this, CreatedBy);
  this->m_LeanMatrix.m_pRwMat = 0;
  this->m_LeanMatrix.m_owner = 0;
  this->_vptr$CPlaceable = (int (**)(void))&off_66D7F0;
  CRideAnimData::CRideAnimData(&this->RideAnimData);
  v5 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[nModelIndex];
  m_handlingId_low = LOBYTE(v5->m_handlingId);
  if ( v5->m_vehicleType == VEHICLE_TYPE_BIKE )
  {
    m_firstAssocGroup = CAnimManager::ms_aAnimBlocks[(*((int (__fastcall **)(CBaseModelInfo *))v5->_vptr$CBaseModelInfo
                                                      + 15))(CModelInfo::ms_modelInfoPtrs[nModelIndex])].m_firstAssocGroup;
    if ( (unsigned int)(m_firstAssocGroup - 2) > 4 )
      m_firstAssocGroup = ANIM_BIKE_PED;
    this->RideAnimData.m_animGroup = m_firstAssocGroup;
  }
  this->m_baseVehicleType = 9;
  this->m_vehicleType = 9;
  v8 = this->_vptr$CPlaceable;
  this->m_BlowUpTimer = 0.0;
  this->nBrakesOn = 0;
  this->m_nBikeFlags = 0;
  ((void (__fastcall *)(CBike *, int))v8[6])(this, nModelIndex);
  this->pBikeHandling = (tBikeHandlingData *)(&mod_HandlingManager.m_aHandlingData[163].fSteeringLock
                                            + 16 * m_handlingId_low);
  v9 = (char *)&mod_HandlingManager + 224 * m_handlingId_low;
  this->pHandling = (tHandlingData *)(v9 + 20);
  this->hFlagsLocal = *((_DWORD *)v9 + 57);
  this->pFlyingHandling = cHandlingDataMgr::GetFlyingPointer(&mod_HandlingManager, m_handlingId_low);
  this->fBrakeCount = 20.0;
  CVehicleModelInfo::ChooseVehicleColour(v5, &this->m_colour1, &this->m_colour2, &this->m_colour3, &this->m_colour4, 1);
  this->m_fSwingArmLength = 0.0;
  this->m_fForkYOffset = 0.0;
  this->m_fForkZOffset = 0.0;
  v10 = tanf((float)(v5->m_steerAngle * 3.1416) / 180.0);
  pHandling = this->pHandling;
  this->m_fSteerAngleTan = v10;
  *(_WORD *)&this->m_nFixLeftHand = 0;
  this->m_fMass = pHandling->fMass;
  this->m_fTurnMass = pHandling->fTurnMass;
  *(_QWORD *)&this->m_vecCOM.x = *(_QWORD *)&pHandling->CentreOfMass.x;
  this->m_vecCOM.z = 0.1;
  fDragCoeff = pHandling->fDragCoeff;
  if ( fDragCoeff > 0.01 )
    fDragCoeff = (float)(fDragCoeff * 0.5) / 1000.0;
  this->m_fElasticity = 0.05;
  this->m_fAirResistance = fDragCoeff;
  fBuoyancyConstant = pHandling->fBuoyancyConstant;
  *(_QWORD *)this->m_aWheelPitchAngles = 0LL;
  *(_QWORD *)this->m_aWheelAngularVelocity = 0LL;
  this->m_fSteerAngle = 0.0;
  this->m_fBuoyancyConstant = fBuoyancyConstant;
  this->m_fGasPedal = 0.0;
  this->m_fBrakePedal = 0.0;
  this->pEntityThatSetUsOnFire = 0;
  this->pBombOwner = 0;
  this->m_fTyreTemp = 1.0;
  this->m_fBrakingSlide = 0.0;
  this->fPrevSpeed = 0.0;
  this->m_fGasPedalAudioRevs = 0.0;
  this->m_aWheelState[0] = WS_ROLLING;
  this->m_aWheelState[1] = WS_ROLLING;
  *(_WORD *)this->m_nWheelStatus = 0;
  *(_QWORD *)this->aWheelSkidmarkType = 0LL;
  *(_QWORD *)this->bWheelBloody = 0LL;
  *(_QWORD *)&this->m_aGroundOffsets[1].x = 0LL;
  *(_QWORD *)&this->m_aGroundOffsets[1].z = 0LL;
  *(_QWORD *)&this->m_aGroundOffsets[2].y = 0LL;
  *(_QWORD *)&this->m_aGroundOffsets[3].x = 0LL;
  this->m_aGroundPhysicalPtrs[0] = 0;
  this->m_aGroundPhysicalPtrs[1] = 0;
  this->m_aGroundPhysicalPtrs[2] = 0;
  this->m_aGroundPhysicalPtrs[3] = 0;
  this->m_aGroundOffsets[0].x = 0.0;
  this->m_aGroundOffsets[0].y = 0.0;
  this->m_aGroundOffsets[0].z = 0.0;
  this->m_aGroundOffsets[3].z = 0.0;
  this->m_aWheelRatios[0] = 1.0;
  this->m_aWheelRatios[1] = 1.0;
  this->m_aWheelRatios[2] = 1.0;
  this->m_aWheelRatios[3] = 1.0;
  this->m_aRatioHistory[0] = 1.0;
  this->m_aRatioHistory[1] = 1.0;
  this->m_aRatioHistory[2] = 1.0;
  this->m_aRatioHistory[3] = 1.0;
  this->m_aWheelCounts[0] = 0.0;
  this->m_aWheelCounts[1] = 0.0;
  this->m_aWheelCounts[2] = 0.0;
  this->m_aWheelCounts[3] = 0.0;
  this->m_nDriveWheelsOnGroundLastFrame = 0;
  *(_WORD *)&this->nNoOfContactWheels = 0;
  this->m_fHeightAboveRoad = 0.0;
  this->m_fExtraTractionMult = 1.0;
  m_pColData = v5->m_pColModel->m_pColData;
  m_pLineArray = m_pColData->_anon_1.m_pLineArray;
  if ( !m_pLineArray )
  {
    m_pColData->_anon_0.m_nNoOfLines = 4;
    v16 = (CColLine *)CMemoryMgr::Malloc(0x80u);
    m_pColData->_anon_1.m_pLineArray = v16;
    v16[1].m_vecStart.z = 100000.0;
    m_pLineArray = m_pColData->_anon_1.m_pLineArray;
  }
  m_pLineArray->m_vecStart.z = 100000.0;
  (*((void (__fastcall **)(CBike *))this->_vptr$CPlaceable + 49))(this);
  m_info = this->m_info;
  m_pMat = this->m_pMat;
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  v20 = *(_WORD *)((char *)&this->AutoPilot + 75);
  *(_WORD *)&this->AutoPilot.Mission = 0;
  this->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
  *(_WORD *)((char *)&this->AutoPilot + 75) = v20 & 0xFFFB;
  *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFF0FF;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x10);
  this->m_nNumPassengers = 0;
  this->m_bLeanMatrix = 0;
  CMatrix::operator=(&this->m_LeanMatrix, m_pMat);
  this->m_vecOldSpeedForPlayback.x = 0.0;
  this->m_vecOldSpeedForPlayback.y = 0.0;
  this->m_vecOldSpeedForPlayback.z = 0.0;
  CAEVehicleAudioEntity::Initialise(&this->m_VehicleAudioEntity, this);
}
// 66D7F0: using guessed type void *;

//----- (00560744) --------------------------------------------------------
void __fastcall CBike::~CBike(CBike *this)
{
  this->_vptr$CPlaceable = (int (**)(void))&off_66D7F0;
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CRideAnimData::~CRideAnimData(&this->RideAnimData);
  CMatrix::~CMatrix(&this->m_LeanMatrix);
  sub_195C74(this);
}
// 66D7F0: using guessed type void *off_66D7F0;

//----- (0056077C) --------------------------------------------------------
void __fastcall CBike::~CBike(CBike *this)
{
  void *v2; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_66D7F0;
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CRideAnimData::~CRideAnimData(&this->RideAnimData);
  CMatrix::~CMatrix(&this->m_LeanMatrix);
  CVehicle::~CVehicle(this);
  sub_199F98(v2);
}
// 5607AE: variable 'v2' is possibly undefined
// 66D7F0: using guessed type void *off_66D7F0;

//----- (005607B8) --------------------------------------------------------
void __fastcall CBike::SetModelIndex(CBike *this, uint32 index)
{
  RpClump_0 *m_pRwObject; // r0

  CVehicle::SetModelIndex(this, index);
  this->m_aBikeNodes[8] = 0;
  this->m_aBikeNodes[9] = 0;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aBikeNodes[4] = 0LL;
  *(_QWORD *)&this->m_aBikeNodes[6] = 0LL;
  *(_QWORD *)this->m_aBikeNodes = 0LL;
  *(_QWORD *)&this->m_aBikeNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aBikeNodes);
}

//----- (005607EA) --------------------------------------------------------
void __fastcall CBike::SetupModelNodes(CBike *this)
{
  RpClump_0 *m_pRwObject; // r2

  this->m_aBikeNodes[8] = 0;
  this->m_aBikeNodes[9] = 0;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aBikeNodes[4] = 0LL;
  *(_QWORD *)&this->m_aBikeNodes[6] = 0LL;
  *(_QWORD *)this->m_aBikeNodes = 0LL;
  *(_QWORD *)&this->m_aBikeNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aBikeNodes);
}

//----- (00560810) --------------------------------------------------------
void __fastcall CBike::SetupSuspensionLines(CBike *this)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float v4; // s30
  int v5; // r8
  CBaseModelInfo *v6; // r0
  float *p_m_txdIndex; // r3
  float *p_m_n2dEffects; // r6
  CCollisionData *m_pColData; // r9
  CColLine *m_pLineArray; // r0
  float z; // s20
  float v12; // s16
  CColLine *v13; // r0
  RwReal *p_x; // r2
  RwReal x; // s17
  float v16; // s0
  float v17; // r11
  float v18; // s2
  RwFrame_0 **v19; // r0
  float v20; // s0
  float *v21; // r1
  RwFrame_0 *v22; // r0
  __int64 v23; // d17
  __int64 v24; // d18
  __int64 v25; // d19
  __int64 v26; // d20
  __int64 v27; // d21
  __int64 v28; // d22
  __int64 v29; // d23
  char *parent; // r10
  char *v31; // r6
  float y; // s19
  float v33; // s0
  RwFrame_0 *v34; // r0
  __int64 v35; // d16
  __int64 v36; // d17
  __int64 v37; // d18
  __int64 v38; // d19
  __int64 v39; // d20
  __int64 v40; // d21
  __int64 v41; // d23
  char *v42; // r6
  RwReal *v43; // r0
  float fSuspensionUpperLimit; // s4
  float *v45; // r1
  float v46; // s2
  float v47; // s4
  float v48; // s6
  int v49; // r0
  tHandlingData *pHandling; // r0
  float v51; // s0
  float fSuspensionLowerLimit; // s2
  float *v53; // r0
  int v54; // r1
  RwFrame_0 *v55; // r10
  __int64 v56; // d16
  __int64 v57; // d17
  __int64 v58; // d18
  __int64 v59; // d19
  __int64 v60; // d20
  __int64 v61; // d21
  __int64 v62; // d23
  RwFrame_0 *v63; // r5
  float v64; // r1
  float v65; // s0
  float v66; // s2
  float v67; // s0
  float *v68; // r1
  float v69; // s0
  int m_nNoOfSpheres; // r2
  int v71; // r0
  int v72; // r1
  float v73; // s0
  CColSphere *m_pSphereArray; // r3
  float v75; // s6
  CColModel *m_pColModel; // [sp+0h] [bp-C0h]
  float *v77; // [sp+10h] [bp-B0h]
  CCollisionData *v78; // [sp+14h] [bp-ACh]
  float *v79; // [sp+18h] [bp-A8h]
  RwMatrix matrix; // [sp+20h] [bp-A0h] BYREF

  v4 = 0.0;
  v5 = 0;
  v6 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  p_m_txdIndex = (float *)&v6[1].m_txdIndex;
  p_m_n2dEffects = (float *)&v6[1].m_n2dEffects;
  m_pColModel = v6->m_pColModel;
  m_pColData = m_pColModel->m_pColData;
  m_pLineArray = m_pColData->_anon_1.m_pLineArray;
  z = m_pLineArray->m_vecStart.z;
  v12 = m_pLineArray[1].m_vecStart.z;
  v77 = p_m_n2dEffects;
  v78 = m_pColData;
  v79 = p_m_txdIndex;
  do
  {
    if ( z == 100000.0 )
    {
      v18 = -0.25;
      v19 = &this->m_aBikeNodes[5];
      v20 = 0.25;
      v21 = p_m_n2dEffects;
      switch ( v5 )
      {
        case 0:
          v18 = 0.25;
          goto LABEL_6;
        case 1:
LABEL_6:
          v20 = v18;
          v19 = &this->m_aBikeNodes[4];
          v21 = p_m_txdIndex;
          goto LABEL_9;
        case 2:
          goto LABEL_9;
        case 3:
          v19 = &this->m_aBikeNodes[5];
          v20 = -0.25;
          v21 = p_m_n2dEffects;
LABEL_9:
          v22 = *v19;
          v4 = v20 * *v21;
          break;
        default:
          v22 = 0;
          break;
      }
      v23 = *(_QWORD *)&v22->modelling.pos.z;
      v24 = *(_QWORD *)&v22->modelling.at.x;
      v25 = *(_QWORD *)&v22->modelling.at.z;
      v26 = *(_QWORD *)&v22->modelling.right.x;
      v27 = *(_QWORD *)&v22->modelling.right.z;
      v28 = *(_QWORD *)&v22->modelling.up.x;
      v29 = *(_QWORD *)&v22->modelling.up.z;
      parent = (char *)this->m_pRwObject->parent;
      *(_QWORD *)&matrix.pos.x = *(_QWORD *)&v22->modelling.pos.x;
      *(_QWORD *)&matrix.pos.z = v23;
      *(_QWORD *)&matrix.at.x = v24;
      *(_QWORD *)&matrix.at.z = v25;
      *(_QWORD *)&matrix.right.x = v26;
      *(_QWORD *)&matrix.right.z = v27;
      *(_QWORD *)&matrix.up.x = v28;
      *(_QWORD *)&matrix.up.z = v29;
      v31 = (char *)v22->object.parent;
      while ( v31 )
      {
        RwMatrixTransform(&matrix, (const RwMatrix *)(v31 + 16), rwCOMBINEPOSTCONCAT);
        v31 = (char *)*((_DWORD *)v31 + 1);
        if ( v31 == parent )
          v31 = 0;
      }
      v17 = matrix.pos.z;
      x = matrix.pos.x;
      y = matrix.pos.y;
      if ( (unsigned __int16)v5 == 2 )
      {
        v33 = 0.0;
        v34 = this->m_aBikeNodes[3];
        this->m_aWheelOrigHeights[1] = matrix.pos.z;
        if ( v34 )
        {
          v35 = *(_QWORD *)&v34->modelling.right.x;
          v36 = *(_QWORD *)&v34->modelling.right.z;
          v37 = *(_QWORD *)&v34->modelling.up.x;
          v38 = *(_QWORD *)&v34->modelling.up.z;
          v39 = *(_QWORD *)&v34->modelling.at.x;
          v40 = *(_QWORD *)&v34->modelling.at.z;
          v41 = *(_QWORD *)&v34->modelling.pos.z;
          *(_QWORD *)&matrix.pos.x = *(_QWORD *)&v34->modelling.pos.x;
          *(_QWORD *)&matrix.pos.z = v41;
          *(_QWORD *)&matrix.at.x = v39;
          *(_QWORD *)&matrix.at.z = v40;
          *(_QWORD *)&matrix.right.x = v35;
          *(_QWORD *)&matrix.right.z = v36;
          *(_QWORD *)&matrix.up.x = v37;
          *(_QWORD *)&matrix.up.z = v38;
          v42 = (char *)v34->object.parent;
          while ( v42 )
          {
            RwMatrixTransform(&matrix, (const RwMatrix *)(v42 + 16), rwCOMBINEPOSTCONCAT);
            v42 = (char *)*((_DWORD *)v42 + 1);
            if ( v42 == parent )
              v42 = 0;
          }
          v33 = sqrtf(
                  (float)((float)(y - matrix.pos.y) * (float)(y - matrix.pos.y))
                + (float)((float)(v17 - matrix.pos.z) * (float)(v17 - matrix.pos.z)));
        }
        this->m_fSwingArmLength = v33;
      }
      else if ( !(_WORD)v5 )
      {
        this->m_aWheelOrigHeights[0] = matrix.pos.z;
      }
      v16 = v4 + y;
      m_pColData = v78;
      p_m_n2dEffects = v77;
      p_m_txdIndex = v79;
      v13 = v78->_anon_1.m_pLineArray;
    }
    else
    {
      v13 = m_pColData->_anon_1.m_pLineArray;
      p_x = &v13[v5].m_vecStart.x;
      x = *p_x;
      v16 = p_x[1];
      v17 = this->m_aWheelOrigHeights[v5 > 1];
    }
    v43 = &v13[v5].m_vecStart.x;
    fSuspensionUpperLimit = this->pHandling->fSuspensionUpperLimit;
    v45 = p_m_n2dEffects;
    *v43 = x;
    v46 = fSuspensionUpperLimit + v17;
    v43[1] = v16;
    v43[2] = fSuspensionUpperLimit + v17;
    if ( (unsigned int)v5 < 2 )
      v45 = p_m_txdIndex;
    v47 = *v45 * -0.5;
    v48 = this->pHandling->fSuspensionLowerLimit - this->pHandling->fSuspensionUpperLimit;
    v49 = (int)&m_pColData->_anon_1.m_pLineArray[v5];
    *(RwReal *)(v49 + 16) = x;
    *(float *)(v49 + 20) = v16;
    *(float *)(v49 + 24) = v46 + (float)(v48 + v47);
    pHandling = this->pHandling;
    v51 = pHandling->fSuspensionUpperLimit;
    fSuspensionLowerLimit = pHandling->fSuspensionLowerLimit;
    v53 = (float *)(&this->_vptr$CPlaceable + v5);
    v53[481] = v51 - fSuspensionLowerLimit;
    v54 = (int)&m_pColData->_anon_1.m_pLineArray[v5++];
    v53[485] = *(float *)(v54 + 8) - *(float *)(v54 + 24);
  }
  while ( v5 != 4 );
  if ( z == 100000.0 )
  {
    v55 = this->m_aBikeNodes[2];
    v56 = *(_QWORD *)&v55->modelling.right.x;
    v57 = *(_QWORD *)&v55->modelling.right.z;
    v58 = *(_QWORD *)&v55->modelling.up.x;
    v59 = *(_QWORD *)&v55->modelling.up.z;
    v60 = *(_QWORD *)&v55->modelling.at.x;
    v61 = *(_QWORD *)&v55->modelling.at.z;
    v62 = *(_QWORD *)&v55->modelling.pos.z;
    *(_QWORD *)&matrix.pos.x = *(_QWORD *)&v55->modelling.pos.x;
    *(_QWORD *)&matrix.pos.z = v62;
    *(_QWORD *)&matrix.at.x = v60;
    *(_QWORD *)&matrix.at.z = v61;
    *(_QWORD *)&matrix.right.x = v56;
    *(_QWORD *)&matrix.right.z = v57;
    *(_QWORD *)&matrix.up.x = v58;
    *(_QWORD *)&matrix.up.z = v59;
    v63 = (RwFrame_0 *)v55->object.parent;
    while ( v63 )
    {
      RwMatrixTransform(&matrix, &v63->modelling, rwCOMBINEPOSTCONCAT);
      v63 = (RwFrame_0 *)v63->object.parent;
      if ( v63 == v55 )
        v63 = 0;
    }
    v64 = matrix.pos.z;
    this->m_fForkYOffset = matrix.pos.y;
    this->m_fForkZOffset = v64;
    p_m_txdIndex = v79;
  }
  v65 = (float)(*p_m_txdIndex * 0.5)
      + (float)((float)(this->m_fSuspensionLength[0]
                      * (float)((float)(1.0 / (float)(this->pHandling->fSuspensionForce * -4.0)) + 1.0))
              - m_pColData->_anon_1.m_pLineArray->m_vecStart.z);
  this->m_fHeightAboveRoad = v65;
  this->m_aWheelSuspensionHeights[0] = (float)(*p_m_txdIndex * 0.5) - v65;
  this->m_aWheelSuspensionHeights[1] = (float)(*p_m_n2dEffects * 0.5) - v65;
  v66 = m_pColData->_anon_1.m_pLineArray->m_vecEnd.z;
  v67 = m_pColModel->m_boxBound.m_vecMin.z;
  v68 = &m_pColModel->m_boxBound.m_vecMin.x;
  if ( v66 < v67 )
  {
    m_pColModel->m_boxBound.m_vecMin.z = v66;
    v67 = v66;
  }
  if ( sqrtf(
         (float)((float)(m_pColModel->m_boxBound.m_vecMin.x * m_pColModel->m_boxBound.m_vecMin.x)
               + (float)(m_pColModel->m_boxBound.m_vecMin.y * m_pColModel->m_boxBound.m_vecMin.y))
       + (float)(v67 * v67)) <= sqrtf(
                                  (float)((float)(m_pColModel->m_boxBound.m_vecMax.x * m_pColModel->m_boxBound.m_vecMax.x)
                                        + (float)(m_pColModel->m_boxBound.m_vecMax.y * m_pColModel->m_boxBound.m_vecMax.y))
                                + (float)(m_pColModel->m_boxBound.m_vecMax.z * m_pColModel->m_boxBound.m_vecMax.z)) )
    v68 = &m_pColModel->m_boxBound.m_vecMax.x;
  v69 = sqrtf((float)((float)(*v68 * *v68) + (float)(v68[1] * v68[1])) + (float)(v68[2] * v68[2]));
  if ( m_pColModel->m_sphereBound.m_fRadius < v69 )
    m_pColModel->m_sphereBound.m_fRadius = v69;
  if ( v12 == 100000.0 && (this->pHandling->mFlags & 0x40000000) != 0 )
  {
    m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
    if ( m_nNoOfSpheres >= 1 )
    {
      v71 = 0;
      v72 = 12;
      v73 = 0.25 - this->m_fHeightAboveRoad;
      v1.n64_u32[0] = 1053609165;
      do
      {
        m_pSphereArray = m_pColData->m_pSphereArray;
        v75 = *(float *)((char *)m_pSphereArray + v72 - 4);
        v2.n64_u32[0] = *(_DWORD *)((char *)&m_pSphereArray->m_vecCentre.x + v72);
        if ( (float)(v75 - v2.n64_f32[0]) < v73 )
        {
          if ( v2.n64_f32[0] > 0.4 )
          {
            v2.n64_f32[0] = v75 - v73;
            v2.n64_u64[0] = vmax_f32(v2, v1).n64_u64[0];
            *(_DWORD *)((char *)&m_pSphereArray->m_vecCentre.x + v72) = v2.n64_u32[0];
            m_pSphereArray = m_pColData->m_pSphereArray;
            v2.n64_u32[0] = *(_DWORD *)((char *)&m_pSphereArray->m_vecCentre.x + v72);
          }
          *(float *)((char *)m_pSphereArray + v72 - 4) = v73 + v2.n64_f32[0];
          LOWORD(m_nNoOfSpheres) = m_pColData->m_nNoOfSpheres;
        }
        v72 += 20;
        ++v71;
      }
      while ( v71 < (__int16)m_nNoOfSpheres );
    }
  }
}
// 560CA2: variable 'v2' is possibly undefined
// 560CA2: variable 'v1' is possibly undefined

//----- (00560CE4) --------------------------------------------------------
void __fastcall CBike::GetComponentWorldPosition(CBike *this, int32 component, CVector *posn)
{
  RwFrame_0 *v4; // r0
  RwMatrix *LTM; // r0
  __int64 v6; // d16

  v4 = this->m_aBikeNodes[component];
  if ( v4 )
  {
    LTM = RwFrameGetLTM(v4);
    v6 = *(_QWORD *)&LTM->pos.x;
    posn->z = LTM->pos.z;
    *(_QWORD *)&posn->x = v6;
  }
}

//----- (00560D0A) --------------------------------------------------------
bool __fastcall CBike::IsComponentPresent(const CBike *this, int32 component)
{
  return this->m_aBikeNodes[component] != 0;
}

//----- (00560D1C) --------------------------------------------------------
int __fastcall CBike::DamageKnockOffRider(
        CVehicle *pVehicle,
        float fImpulse,
        uint16 nPieceType,
        CEntity *pDamageEntity,
        CVector *vecDamagePos,
        const CVector *a6)
{
  float32x2_t v6; // d2
  float32x2_t v7; // d3
  float32x2_t v8; // d10
  float v11; // s18
  CPed *pDriver; // r0
  float v13; // s20
  CPed **p_pDriver; // r5
  CPed *v15; // r1
  int result; // r0
  CTask *ActiveTask; // r0
  CMatrix *m_pMat; // r1
  float x; // s22
  float y; // s26
  float yy; // s19
  float z; // s24
  float zy; // s17
  float v24; // s0
  float v25; // s6
  float v26; // s28
  float zz; // s27
  float v28; // s2
  int32 m_vehicleType; // r0
  float v30; // s6
  int *v31; // r2
  CPed *v32; // r0
  float BikeRidingSkill; // r0
  float v34; // s0
  float xx; // s23
  float yx; // s30
  float zx; // s25
  float xz; // s29
  float yz; // s31
  CPed *v40; // r2
  CPed *v41; // r0
  float v42; // s0
  int32 LocalDirection; // r6
  CPlayerPed *v44; // r6
  int8 v45; // r0
  float v46; // [sp+28h] [bp-E8h]
  float xy; // [sp+2Ch] [bp-E4h]
  CEventKnockOffBike v48; // [sp+30h] [bp-E0h] BYREF
  CEventKnockOffBike v49; // [sp+6Ch] [bp-A4h] BYREF
  CVector2D dir; // [sp+A8h] [bp-68h] BYREF

  v11 = (float)(fImpulse * 800.0) / pVehicle->m_fMass;
  if ( *(_BYTE *)&pVehicle->m_info <= 7u )
  {
    pDriver = pVehicle->pDriver;
    if ( !pDriver )
      return 0;
    v13 = 0.5;
    p_pDriver = &pVehicle->pDriver;
    v11 = v11 * 0.42;
    goto LABEL_7;
  }
  pDriver = pVehicle->pDriver;
  if ( !pDriver )
    return 0;
  p_pDriver = &pVehicle->pDriver;
  if ( (*((_DWORD *)&pDriver->m_nPedFlags + 2) & 0x18000000) != 0x10000000 )
  {
    v13 = 0.6;
LABEL_7:
    v11 = v11 * (float)(1.0 - (float)(CPed::GetBikeRidingSkill(pDriver) * v13));
  }
  v15 = *p_pDriver;
  if ( !*p_pDriver )
    return 0;
  result = 0;
  if ( v11 <= 10.0 || v15->m_nPedState != PED_DRIVING )
    return result;
  if ( CTaskManager::GetActiveTask(&v15->m_pPedIntelligence->m_taskManager) )
  {
    ActiveTask = CTaskManager::GetActiveTask(&(*p_pDriver)->m_pPedIntelligence->m_taskManager);
    if ( (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) == 1022
      && (*p_pDriver)->m_nPedType != 6 )
    {
      return 0;
    }
  }
  m_pMat = pVehicle->m_pMat;
  x = a6->x;
  y = a6->y;
  yy = m_pMat->yy;
  z = a6->z;
  zy = m_pMat->zy;
  xy = m_pMat->xy;
  v24 = (float)((float)(a6->x * xy) + (float)(y * yy)) + (float)(z * zy);
  if ( fabsf(v24) <= 0.85 )
  {
    v26 = 0.6;
  }
  else
  {
    v6.n64_u32[0] = 0;
    v7.n64_f32[0] = (float)((float)(x * 0.0) + (float)(y * 0.0)) + z;
    v25 = vmax_f32(v7, v6).n64_f32[0];
    if ( v25 < 0.85 )
      v25 = 0.0;
    v26 = (float)(v25 * (float)(v25 * 7.0)) + 0.6;
  }
  zz = m_pMat->zz;
  if ( zz < 0.0 )
    v26 = 5.0;
  if ( pVehicle->m_nModelIndex == 468 )
  {
    v26 = v26 * 0.65;
    v28 = 0.0375;
    v46 = 1.5;
  }
  else
  {
    m_vehicleType = pVehicle->m_vehicleType;
    v30 = 1.5;
    v31 = dword_56119C;
    if ( m_vehicleType == 2 )
    {
      v26 = v26 * 0.65;
      v30 = 3.0;
    }
    v46 = v30;
    if ( m_vehicleType == 2 )
      v31 = &dword_56119C[1];
    v28 = *(float *)v31;
  }
  v32 = *p_pDriver;
  if ( *p_pDriver )
  {
    if ( v24 > 0.0 )
    {
      BikeRidingSkill = CPed::GetBikeRidingSkill(v32);
      m_pMat = pVehicle->m_pMat;
      v34 = BikeRidingSkill * -0.6;
      x = a6->x;
      y = a6->y;
      z = a6->z;
      v32 = *p_pDriver;
      v26 = v26 * (float)(v34 + 1.0);
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      zy = m_pMat->zy;
      zz = m_pMat->zz;
    }
  }
  else
  {
    v32 = 0;
  }
  xx = m_pMat->xx;
  yx = m_pMat->yx;
  zx = m_pMat->zx;
  xz = m_pMat->xz;
  yz = m_pMat->yz;
  v8.n64_u32[0] = 0;
  if ( !CPed::IsPlayer(v32)
    || CCullZones::CamStairsForPlayer() != 1
    || !CCullZones::FindZoneWithStairsAttributeForPlayer() )
  {
    v6.n64_f32[0] = (float)((float)(x * xz) + (float)(y * yz)) + (float)(z * zz);
    v8.n64_f32[0] = v11
                  * (float)((float)((float)((float)(v26
                                                  * fabsf((float)((float)(x * xy) + (float)(y * yy)) + (float)(z * zy)))
                                          + (float)(fabsf((float)((float)(x * xx) + (float)(y * yx)) + (float)(z * zx))
                                                  * 0.45))
                                  + (float)(v28 * vmax_f32(v6, v8).n64_f32[0]))
                          - (float)(v46 * vmin_f32(v6, v8).n64_f32[0]));
    if ( v8.n64_f32[0] > 75.0 )
    {
      v40 = *p_pDriver;
LABEL_39:
      if ( v40 && (*((_DWORD *)&v40->m_nPedFlags + 2) & 0x18000000) == 0x8000000 )
        return 0;
      v41 = pVehicle->pPassengers[0];
      if ( v41 )
      {
        if ( (*((_DWORD *)&v41->m_nPedFlags + 2) & 0x18000000) == 0x8000000 )
          return 0;
      }
      v42 = -a6->x;
      dir.y = -a6->y;
      dir.x = v42;
      if ( v40 )
      {
        LocalDirection = CPed::GetLocalDirection(v40, &dir);
        CEventKnockOffBike::CEventKnockOffBike(
          &v49,
          pVehicle,
          &pVehicle->m_vecMoveSpeed,
          a6,
          fImpulse,
          v8.n64_f32[0] * 0.05,
          WEAPONTYPE_RAMMEDBYCAR,
          LocalDirection,
          0,
          0,
          1,
          0);
        CEventGroup::Add(&(*p_pDriver)->m_pPedIntelligence->m_eventGroup, &v49, 0);
        CEventKnockOffBike::~CEventKnockOffBike(&v49);
        v41 = pVehicle->pPassengers[0];
        if ( !v41 )
          return 1;
      }
      else
      {
        LocalDirection = -10;
        if ( !v41 )
          return 1;
      }
      if ( LocalDirection == -10 )
        LOBYTE(LocalDirection) = CPed::GetLocalDirection(v41, &dir);
      CEventKnockOffBike::CEventKnockOffBike(
        &v49,
        pVehicle,
        &pVehicle->m_vecMoveSpeed,
        a6,
        fImpulse,
        v8.n64_f32[0] * 0.05,
        WEAPONTYPE_RAMMEDBYCAR,
        LocalDirection,
        0,
        0,
        0,
        0);
      CEventGroup::Add(&pVehicle->pPassengers[0]->m_pPedIntelligence->m_eventGroup, &v49, 0);
      v44 = (CPlayerPed *)*p_pDriver;
      if ( v44 == FindPlayerPed(-1) )
      {
        v45 = CPed::GetLocalDirection(*p_pDriver, &dir);
        CEventKnockOffBike::CEventKnockOffBike(
          &v48,
          pVehicle,
          &pVehicle->m_vecMoveSpeed,
          a6,
          fImpulse,
          v8.n64_f32[0] * 0.05,
          WEAPONTYPE_RAMMEDBYCAR,
          v45,
          0,
          0,
          1,
          0);
        CEventGroup::Add(&(*p_pDriver)->m_pPedIntelligence->m_eventGroup, &v48, 0);
        CEventKnockOffBike::~CEventKnockOffBike(&v48);
      }
      CEventKnockOffBike::~CEventKnockOffBike(&v49);
      return 1;
    }
  }
  result = 0;
  if ( v8.n64_f32[0] > 20.0 )
  {
    v40 = *p_pDriver;
    if ( (*((_DWORD *)&(*p_pDriver)->m_nPedFlags + 2) & 0x18000000) == 0x18000000 )
      goto LABEL_39;
  }
  return result;
}
// 560E56: variable 'v7' is possibly undefined
// 560E56: variable 'v6' is possibly undefined
// 560FBE: variable 'v8' is possibly undefined
// 56119C: using guessed type int dword_56119C[2];

//----- (005611B8) --------------------------------------------------------
void __fastcall CBike::VehicleDamage(
        CBike *this,
        float fImpulse,
        uint16 nPieceType,
        CEntity *pDamageEntity,
        CVector *pVecDamagePos,
        CVector *pVecDamageNormal,
        eWeaponType weaponType)
{
  CEntity *v7; // r6
  CEntity *v9; // r3
  CEntity *m_pDamageEntity; // r0
  CEntity *v11; // r0
  float x; // s18
  float y; // s20
  float z; // s22
  CVehicle *PlayerVehicle; // r0
  CVehicle *v16; // r0
  CPlayerPed *PlayerPed; // r0
  CPed *pDriver; // r0
  bool v19; // zf
  CBike *v20; // r0
  bool v21; // zf
  float *p_m_nHealth; // r6
  float m_nHealth; // s18
  CBike *v24; // r0
  int v25; // r1
  float v26; // s0
  float v27; // s0
  CVehicle *v28; // r5
  float v29; // s0
  float v30; // s2
  CBike::CBikeFlags m_nBikeFlags; // r0
  CEntity *v32; // r0
  CVector *bOverideSilence; // [sp+0h] [bp-40h]
  float fDamage[13]; // [sp+Ch] [bp-34h] BYREF

  fDamage[0] = fImpulse;
  if ( fImpulse <= 0.0 && this->m_fDamageImpulseMagnitude >= 1.0 && (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    fDamage[0] = this->m_fDamageImpulseMagnitude;
    CVehicle::ReduceVehicleDamage(this, fDamage);
    if ( (*(_BYTE *)&this->m_nBikeFlags & 0x10) != 0 && fDamage[0] > 20.0 )
      *(_BYTE *)&this->m_nBikeFlags &= ~0x10u;
    CBike::DamageKnockOffRider(this, this->m_fDamageImpulseMagnitude, 0, v9, bOverideSilence, &this->m_vecDamageNormal);
    m_pDamageEntity = this->m_pDamageEntity;
    if ( m_pDamageEntity && (*(_BYTE *)&m_pDamageEntity->m_info & 7) == 2 )
    {
      this->pLastDamageEntity = m_pDamageEntity;
      this->LastDamagedWeaponType = 49;
      CEntity::RegisterReference(m_pDamageEntity, &this->pLastDamageEntity);
    }
    if ( (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x10) == 0 )
    {
      v11 = this->m_pDamageEntity;
      if ( !v11
        || (*(_BYTE *)&v11->m_info & 7) != 1
        || (float)((float)((float)(this->m_vecDamageNormal.x * this->m_pMat->xz)
                         + (float)(this->m_vecDamageNormal.y * this->m_pMat->yz))
                 + (float)(this->m_vecDamageNormal.z * this->m_pMat->zz)) <= 0.6 )
      {
        if ( fDamage[0] <= 25.0 || (*(_BYTE *)&this->m_info & 0xF8) == 40 )
          goto LABEL_48;
        if ( *(_BYTE *)&this->m_nVehicleFlags << 31 )
        {
          if ( FindPlayerVehicle(-1, 0) )
          {
            v7 = this->m_pDamageEntity;
            if ( v7 == FindPlayerVehicle(-1, 0) && (*(_BYTE *)&this->m_info & 0xF8) != 32 )
            {
              x = this->m_vecMoveSpeed.x;
              y = this->m_vecMoveSpeed.y;
              z = this->m_vecMoveSpeed.z;
              PlayerVehicle = FindPlayerVehicle(-1, 0);
              if ( sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z)) <= sqrtf(
                                                                                         (float)((float)(PlayerVehicle->m_vecMoveSpeed.x * PlayerVehicle->m_vecMoveSpeed.x)
                                                                                               + (float)(PlayerVehicle->m_vecMoveSpeed.y * PlayerVehicle->m_vecMoveSpeed.y))
                                                                                       + (float)(PlayerVehicle->m_vecMoveSpeed.z
                                                                                               * PlayerVehicle->m_vecMoveSpeed.z)) )
              {
                v16 = FindPlayerVehicle(-1, 0);
                if ( sqrtf(
                       (float)((float)(v16->m_vecMoveSpeed.x * v16->m_vecMoveSpeed.x)
                             + (float)(v16->m_vecMoveSpeed.y * v16->m_vecMoveSpeed.y))
                     + (float)(v16->m_vecMoveSpeed.z * v16->m_vecMoveSpeed.z)) > 0.1 )
                {
                  PlayerPed = FindPlayerPed(-1);
                  CPlayerPed::SetWantedLevelNoDrop(PlayerPed, 1);
                }
              }
            }
          }
        }
        fDamage[0] = (float)(fDamage[0] + -25.0) * this->pHandling->fCollisionDamageMultiplier;
        if ( fDamage[0] <= 0.0 )
          goto LABEL_48;
        if ( fDamage[0] > 5.0 )
        {
          pDriver = this->pDriver;
          v19 = pDriver == 0;
          if ( pDriver )
          {
            v7 = this->m_pDamageEntity;
            v19 = v7 == 0;
          }
          if ( !v19 && (*(_BYTE *)&v7->m_info & 7) == 2 )
          {
            v20 = (CBike *)FindPlayerVehicle(-1, 0);
            v21 = v20 == this;
            if ( v20 == this )
              v21 = LOBYTE(v7[19].m_pLod) == 2;
            if ( !v21 && v7[18].m_pLastRenderedLink )
              CPed::Say(this->pDriver, 0x42u, 0, 1.0, 0, 0, 0);
          }
        }
        p_m_nHealth = &this->m_nHealth;
        m_nHealth = this->m_nHealth;
        v24 = (CBike *)FindPlayerVehicle(-1, 0);
        v25 = *(_DWORD *)&this->m_nVehicleFlags & 0x8000;
        if ( this == v24 )
        {
          v26 = 2.0;
          if ( v25 )
            v26 = 6.0;
        }
        else if ( v25 )
        {
          v26 = 12.0;
        }
        else
        {
          v28 = (CVehicle *)this->m_pDamageEntity;
          if ( !v28 || v28 != FindPlayerVehicle(-1, 0) )
          {
            v27 = fDamage[0] * 0.25;
            goto LABEL_43;
          }
          v26 = 1.5;
        }
        v27 = fDamage[0] / v26;
LABEL_43:
        v29 = *p_m_nHealth - v27;
        v30 = v29;
        if ( v29 <= 1.0 )
          v30 = 1.0;
        if ( m_nHealth > 1.0 )
          v29 = v30;
        *p_m_nHealth = v29;
LABEL_48:
        if ( this->m_nHealth < 250.0 )
        {
          m_nBikeFlags = this->m_nBikeFlags;
          if ( (*(_BYTE *)&m_nBikeFlags & 0x40) == 0 )
          {
            this->m_BlowUpTimer = 0.0;
            this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags | 0x40);
            v32 = this->m_pDamageEntity;
            this->pEntityThatSetUsOnFire = v32;
            if ( v32 )
              CEntity::RegisterReference(v32, &this->pEntityThatSetUsOnFire);
          }
        }
      }
    }
  }
}
// 561236: variable 'v9' is possibly undefined
// 561236: variable 'bOverideSilence' is possibly undefined
// 5613FA: variable 'v7' is possibly undefined
// 5611B8: using guessed type float fDamage[13];

//----- (00561524) --------------------------------------------------------
CPed *__fastcall CBike::KnockOffRider(
        CBike *this,
        eWeaponType nHitType,
        uint8 nLocalDirn,
        CPed *pPed,
        bool bBeingJacked)
{
  return pPed;
}

//----- (00561528) --------------------------------------------------------
void __fastcall CBike::SetRemoveAnimFlags(CBike *this, CPed *pPed)
{
  CAnimBlendAssociation *i; // r0

  if ( (*(_BYTE *)&pPed->m_info & 7) == 3 )
  {
    for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPed->m_pRwObject, 0x1000u);
          i;
          i = RpAnimBlendGetNextAssociation(i, 0x1000u) )
    {
      i->m_bitsFlag |= 4u;
    }
  }
}

//----- (0056155C) --------------------------------------------------------
void __fastcall CBike::ReduceHornCounter(CBike *this)
{
  UInt32 m_cHorn; // r1

  m_cHorn = this->m_cHorn;
  if ( m_cHorn )
    this->m_cHorn = m_cHorn - 1;
}

//----- (0056156C) --------------------------------------------------------
void __fastcall CBike::ProcessBuoyancy(CBike *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  int v5; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  float v7; // s6
  float m_fBuoyancyConstant; // s4
  float32x2_t v9; // d1
  CPhysical::CPhysicalFlags v10; // r5
  float v11; // s18
  float v12; // r0
  RwReal v13; // s6
  float32x4_t v14; // q0
  RwReal v15; // s4
  int v16; // r1
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  int v18; // r0
  int v19; // r1
  CPed *pDriver; // r2
  const CEventDamage *v21; // r0
  int m_nVehicleFlags; // r2
  unsigned int v23; // r0
  int v24; // r0
  float *m_aWheelRatios; // r6
  CPed **pPassengers; // r5
  int v27; // r9
  CPed *v28; // r0
  const CEventDamage *v29; // r0
  const CVector *vecSpeed; // [sp+28h] [bp-B8h]
  CEventDamage v31; // [sp+44h] [bp-9Ch] BYREF
  CPedDamageResponseCalculator v32; // [sp+84h] [bp-5Ch] BYREF
  CVector v33; // [sp+98h] [bp-48h] BYREF
  CVector pCentreOfBuoyancy; // [sp+A4h] [bp-3Ch] BYREF

  v5 = cBuoyancy::ProcessBuoyancy(&mod_Buoyancy, this, this->m_fBuoyancyConstant, &pCentreOfBuoyancy, &v33);
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  if ( v5 != 1 )
  {
    m_nVehicleFlags = (int)this->m_nVehicleFlags;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xF7FFFEFF);
    v23 = m_nVehicleFlags & 0xBFFFFFFF;
LABEL_29:
    *(_DWORD *)&this->m_nVehicleFlags = v23;
    return;
  }
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x8000000);
  CPhysical::ApplyMoveForce(this, v33);
  CPhysical::ApplyTurnForce(this, v33, pCentreOfBuoyancy);
  v7 = this->m_fMass * 0.008;
  v2.n64_u32[0] = 1008981770;
  m_fBuoyancyConstant = this->m_fBuoyancyConstant;
  v1.n64_f32[0] = CTimer::ms_fTimeStep;
  v9.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
  v9.n64_f32[0] = v33.z / (float)(v7 * v9.n64_f32[0]);
  if ( m_fBuoyancyConstant < v7 )
    v9.n64_f32[0] = v9.n64_f32[0] * (float)((float)(v7 * 1.05) / m_fBuoyancyConstant);
  v10 = this->m_nPhysicalFlags;
  v11 = v9.n64_f32[0] * 1.5;
  if ( (*(_BYTE *)&v10 & 1) == 0 )
    v11 = v9.n64_f32[0];
  v3.n64_u32[0] = 0.5;
  v9.n64_f32[0] = (float)(v11 * -0.05) + 1.0;
  v12 = powf(vmax_f32(v9, v3).n64_f32[0], CTimer::ms_fTimeStep);
  v13 = v12 * this->m_vecTurnSpeed.y;
  v14 = vmulq_n_f32(*(float32x4_t *)&this->m_vecMoveSpeed.x, v12);
  vecSpeed = &this->m_vecMoveSpeed;
  v15 = v12 * this->m_vecTurnSpeed.z;
  *(float32x4_t *)&this->m_vecMoveSpeed.x = v14;
  this->m_vecTurnSpeed.y = v13;
  this->m_vecTurnSpeed.z = v15;
  if ( v11 <= 0.8
    && (v11 <= 0.4
     || this->m_aWheelRatios[0] != 1.0
     && this->m_aWheelRatios[1] != 1.0
     && this->m_aWheelRatios[2] != 1.0
     && this->m_aWheelRatios[3] != 1.0) )
  {
    v24 = (int)this->m_nVehicleFlags;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v10 & 0xFFFFFEFF);
    v23 = v24 & 0xBFFFFFFF;
    goto LABEL_29;
  }
  v16 = (int)this->m_nVehicleFlags;
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  v18 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v10 | 0x100);
  v19 = v16 | 0x40000000;
  *(_DWORD *)&this->m_nVehicleFlags = v19;
  if ( v14.n128_f32[2] < -0.1 )
    this->m_vecMoveSpeed.z = -0.1;
  pDriver = this->pDriver;
  if ( pDriver )
  {
    *(_DWORD *)&pDriver->m_nPhysicalFlags |= 0x8000000u;
    if ( CPed::IsPlayer(this->pDriver) || (*(_BYTE *)&this->m_nBikeFlags & 4) == 0 )
    {
      if ( CPed::IsPlayer(this->pDriver) )
        CPlayerPed::HandlePlayerBreath((CPlayerPed *)this->pDriver, 1, 1.0);
      if ( this->m_aWheelRatios[0] >= 1.0
        && this->m_aWheelRatios[1] >= 1.0
        && this->m_aWheelRatios[2] >= 1.0
        && this->m_aWheelRatios[3] >= 1.0 )
      {
        CEventKnockOffBike::CEventKnockOffBike(
          (CEventKnockOffBike *)&v31,
          this,
          vecSpeed,
          &this->m_vecDamageNormal,
          this->m_fDamageImpulseMagnitude,
          0.0,
          WEAPONTYPE_DROWNING,
          0,
          0,
          0,
          1,
          0);
        CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v31, 0);
        *(_DWORD *)p_m_nVehicleFlags &= ~0x10u;
        CEventKnockOffBike::~CEventKnockOffBike((CEventKnockOffBike *)&v31);
      }
      else if ( !CPed::IsPlayer(this->pDriver) )
      {
        CPedDamageResponseCalculator::CPedDamageResponseCalculator(
          &v32,
          this,
          CTimer::ms_fTimeStep,
          WEAPONTYPE_DROWNING,
          PED_SPHERE_CHEST,
          0);
        CEventDamage::CEventDamage(
          &v31,
          this,
          CTimer::m_snTimeInMilliseconds,
          WEAPONTYPE_DROWNING,
          PED_SPHERE_CHEST,
          0,
          0,
          1);
        if ( CEventDamage::AffectsPed(v21, this->pDriver) )
          CPedDamageResponseCalculator::ComputeDamageResponse(&v32, this->pDriver, &v31.m_pedDamageResponse, 1);
        else
          v31.m_pedDamageResponse.m_bDamageCalculated = 1;
        CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v31, 0);
        CEventDamage::~CEventDamage(&v31);
        CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v32);
      }
    }
  }
  else
  {
    *(_DWORD *)p_m_nVehicleFlags = v19 & 0xFFFFFFEF;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v18;
  }
  if ( this->m_nMaxPassengers )
  {
    m_aWheelRatios = this->m_aWheelRatios;
    pPassengers = this->pPassengers;
    v27 = 0;
    do
    {
      v28 = pPassengers[v27];
      if ( v28 )
      {
        *(_DWORD *)&v28->m_nPhysicalFlags |= 0x8000000u;
        if ( CPed::IsPlayer(pPassengers[v27]) )
          CPlayerPed::HandlePlayerBreath((CPlayerPed *)pPassengers[v27], 1, 1.0);
        if ( CPed::IsPlayer(pPassengers[v27]) || (*(_BYTE *)&this->m_nBikeFlags & 4) == 0 )
        {
          if ( *m_aWheelRatios >= 1.0
            && this->m_aWheelRatios[1] >= 1.0
            && this->m_aWheelRatios[2] >= 1.0
            && this->m_aWheelRatios[3] >= 1.0 )
          {
            CEventKnockOffBike::CEventKnockOffBike(
              (CEventKnockOffBike *)&v31,
              this,
              vecSpeed,
              &this->m_vecDamageNormal,
              this->m_fDamageImpulseMagnitude,
              0.0,
              WEAPONTYPE_DROWNING,
              0,
              0,
              0,
              0,
              0);
            CEventGroup::Add(&pPassengers[v27]->m_pPedIntelligence->m_eventGroup, (CEvent *)&v31, 0);
            CEventKnockOffBike::~CEventKnockOffBike((CEventKnockOffBike *)&v31);
          }
          else if ( !CPed::IsPlayer(pPassengers[v27]) )
          {
            CPedDamageResponseCalculator::CPedDamageResponseCalculator(
              &v32,
              this,
              CTimer::ms_fTimeStep,
              WEAPONTYPE_DROWNING,
              PED_SPHERE_CHEST,
              0);
            CEventDamage::CEventDamage(
              &v31,
              this,
              CTimer::m_snTimeInMilliseconds,
              WEAPONTYPE_DROWNING,
              PED_SPHERE_CHEST,
              0,
              0,
              1);
            if ( CEventDamage::AffectsPed(v29, pPassengers[v27]) )
              CPedDamageResponseCalculator::ComputeDamageResponse(&v32, pPassengers[v27], &v31.m_pedDamageResponse, 1);
            else
              v31.m_pedDamageResponse.m_bDamageCalculated = 1;
            CEventGroup::Add(&pPassengers[v27]->m_pPedIntelligence->m_eventGroup, (CEvent *)&v31, 0);
            CEventDamage::~CEventDamage(&v31);
            CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v32);
            m_aWheelRatios = this->m_aWheelRatios;
          }
        }
      }
      ++v27;
    }
    while ( v27 < this->m_nMaxPassengers );
  }
}
// 5615EC: variable 'v1' is possibly undefined
// 5615EC: variable 'v2' is possibly undefined
// 561640: variable 'v3' is possibly undefined
// 5617EA: variable 'v21' is possibly undefined
// 5619CA: variable 'v29' is possibly undefined

//----- (00561A90) --------------------------------------------------------
void __fastcall CBike::ProcessControl(CBike *this)
{
  float32x4_t v1; // q0
  float32x4_t v2; // q1
  float32x2_t v3; // d8
  float32x2_t v4; // d10
  unsigned __int64 v5; // d11
  float32x2_t v6; // d12
  float32x2_t v7; // d13
  CBike *v8; // r11
  CColModel *ColModel; // r0
  int m_nModelIndex; // r2
  CBaseModelInfo *v11; // r10
  int m_nVehicleFlags; // r0
  int v13; // r1
  CBike::CBikeFlags m_nBikeFlags; // r2
  const CPed *pDriver; // r0
  const CPed *v16; // r0
  unsigned int m_info; // r0
  CBike::CBikeFlags v18; // r1
  CMatrix *m_pMat; // r2
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r4
  tHandlingData *pHandling; // r1
  tBikeHandlingData *pBikeHandling; // r3
  float y; // s20
  float x; // r6
  float v25; // s18
  float v26; // r5
  float v27; // r0
  float v28; // r9
  float FatAndMuscleModifier; // r0
  CMatrix *v30; // r5
  int (**v31)(void); // s22
  int m_iAccumulatedTime; // s24
  float m_fTurnMass; // s26
  float v34; // r6
  float xz; // s28
  float yz; // s30
  float v37; // s0
  const CMatrix *v38; // r5
  float v39; // s20
  float v40; // s24
  float v41; // s26
  float zz; // s28
  float v43; // s0
  tHandlingData *v44; // r1
  __int64 v45; // d16
  int v46; // r9
  bool v47; // zf
  _BOOL4 v48; // r8
  float32x4_t v49; // q9
  int v50; // r0
  float *v51; // r3
  float32x4_t v52; // q8
  float v53; // s14
  float *v54; // r1
  float *v55; // r2
  uint8 *p_m_nNoOfStaticFrames; // r6
  CMatrix *v57; // r0
  float *v58; // r1
  int v59; // r0
  uint8 v60; // r0
  CPhysical *v61; // r1
  int v62; // r0
  CPhysical *v63; // r1
  CPhysical *v64; // r1
  CPhysical *v65; // r2
  int v66; // r1
  int v67; // r6
  float m_fBarSteerAngle; // s0
  float v69; // r0
  CMatrix *v70; // r1
  float zx; // s0
  bool v72; // nf
  float v73; // s2
  float m_fSteerAngle; // s0
  float v75; // s2
  float m_fDesiredLeanAngle; // s20
  float v77; // s0
  float m_fAirResistance; // r4
  CPed *v79; // r0
  CAnimBlendAssociation *Association; // r0
  float m_fCurrentTime; // s0
  float v82; // s0
  bool v83; // cc
  float *v84; // r0
  float v85; // s0
  float v86; // s2
  float v87; // s4
  float v88; // s6
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r5
  const CPed *v90; // r0
  CPed **pPassengers; // r4
  int v92; // r5
  const CPed *v93; // r0
  float *v94; // r1
  RwReal *p_y; // r10
  float *v96; // r0
  float *p_z; // r11
  CVector *p_vecDirection; // r5
  int v99; // r6
  float v100; // s0
  float v101; // s6
  float v102; // s2
  float v103; // s4
  float v104; // s8
  float v105; // s4
  float v106; // s14
  unsigned __int32 *v107; // r4
  const CMatrix *v108; // r1
  float v109; // s4
  float *p_tx; // r0
  float v111; // s10
  RwReal v112; // s2
  float *v113; // r0
  RwReal v114; // s0
  float v115; // s4
  float v116; // s10
  __int64 v117; // d16
  CVector *v118; // r6
  CVector *p_vecOffset; // r5
  int v120; // r8
  int v121; // r9
  int v122; // r10
  int v123; // r11
  float v124; // s0
  float *v125; // r2
  RwReal v126; // r0
  float v127; // s2
  float v128; // r1
  __int64 v129; // d16
  _BOOL4 v130; // r4
  eSkidmarkType SkidmarkType; // r0
  int v132; // r4
  unsigned int i; // r6
  __int64 v134; // d16
  CVector *v135; // r5
  CPhysical *v136; // r1
  RwReal v137; // s2
  RwReal v138; // s4
  float v139; // s0
  float v140; // s2
  __int16 v141; // r2
  __int16 v142; // r0
  float *v143; // r2
  float v144; // s2
  int v145; // s6
  float v146; // s8
  float v147; // s4
  float *v148; // r0
  float v149; // s8
  float v150; // s6
  __int16 v151; // r1
  float *v152; // r1
  float v153; // s6
  RwReal v154; // s8
  RwReal v155; // s10
  __int16 v156; // r1
  float v157; // s4
  float *v158; // r0
  float v159; // s8
  RwReal v160; // s6
  int v161; // r4
  unsigned int j; // r6
  __int64 v163; // d16
  CVector *v164; // r5
  CPhysical *v165; // r1
  RwReal v166; // s2
  RwReal v167; // s4
  float v168; // s2
  RwReal v169; // r0
  float v170; // s6
  float v171; // s0
  float v172; // s10
  float v173; // s18
  float v174; // s30
  float v175; // s19
  char v176; // r0
  float *v177; // r4
  char *v178; // r2
  float *v179; // r3
  CVector *v180; // r8
  int v181; // r0
  __int16 v182; // r1
  float v183; // s4
  int z_low; // r5
  __int64 v185; // d16
  float v186; // s4
  float v187; // s2
  float v188; // s0
  float v189; // s4
  const CMatrix *v190; // r1
  float *v191; // r10
  float v192; // s2
  float v193; // s0
  CColLine *m_pLineArray; // r0
  float v195; // s0
  float v196; // s2
  int v197; // r0
  int v198; // r9
  RwReal v199; // r5
  unsigned int v200; // r0
  float v201; // s28
  _BOOL2 v202; // r10
  char *v203; // r4
  float v204; // s24
  float v205; // r0
  float32x2_t v206; // d0
  float v207; // s2
  int v208; // r0
  __int16 v209; // r5
  float v210; // s22
  float v211; // s24
  float v212; // s26
  const CMatrix *v213; // r4
  char *v214; // r6
  float v215; // s6
  float v216; // s8
  float v217; // s14
  float v218; // s10
  float AdhesiveLimit; // s23
  float v220; // s23
  CPhysical::CPhysicalFlags v221; // r4
  CPhysical *v222; // r1
  RwReal v223; // s0
  CRealTimeShadow *v224; // s2
  CMatrix *v225; // r0
  const CVector *v226; // r4
  __int64 v227; // d16
  __int64 v228; // d16
  float v229; // s4
  float v230; // s6
  float v231; // s14
  float v232; // s8
  int v233; // r6
  CColPoint *v234; // r5
  float *v235; // r0
  float v236; // s0
  float v237; // s23
  char *v238; // r4
  float v239; // s0
  unsigned __int32 v240; // s19
  float v241; // s19
  float v242; // s23
  int v243; // r5
  int v244; // r4
  CPhysical *v245; // r1
  float *v246; // r0
  float v247; // s0
  float v248; // s2
  float v249; // s25
  float *v250; // r0
  float v251; // s0
  RwReal v252; // s0
  float v253; // s0
  float v254; // r5
  float v255; // r0
  const CMatrix *v256; // r6
  char *v257; // r4
  float v258; // s6
  float v259; // s8
  float v260; // s14
  float v261; // s10
  float v262; // s30
  float v263; // s28
  CPhysical::CPhysicalFlags v264; // r4
  CPhysical *v265; // r1
  RwReal v266; // s0
  float v267; // s16
  RwReal v268; // r0
  CAnimBlendAssociation *v269; // r0
  __int64 v270; // d16
  float *p_m_pLod; // r4
  float v272; // s0
  __int64 v273; // d16
  float v274; // s4
  float v275; // r5
  float v276; // s18
  float v277; // s2
  float v278; // s4
  int v279; // r0
  float v280; // s2
  float v281; // s4
  float v282; // s18
  float v283; // s4
  float v284; // r5
  float v285; // r0
  float v286; // s18
  tWheelState v287; // r0
  unsigned int v288; // r2
  tWheelState v289; // r1
  CEntity *m_pLod; // r0
  FxSystem_c *m_fxSysEngFire; // r0
  RwObject_0 *m_vehicleType; // r0
  bool v293; // zf
  uint32 m_hashKey; // r1
  RwMatrix *v295; // r3
  __int64 v296; // d16
  FxSystem_c *FxSystem; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  float v299; // s0
  float v300; // s22
  float v301; // s28
  float *m_aWheelRatios; // r4
  float *m_aRatioHistory; // r6
  int v304; // r5
  int v305; // r9
  float v306; // s20
  float *v307; // r8
  float v308; // s0
  float v309; // s2
  bool v310; // fzf
  bool v311; // fnf
  unsigned int v312; // r0
  float v313; // r0
  float v314; // s0
  float v315; // s0
  CPad *Pad; // r0
  CPlayerPed *m_pDamageEntity; // r4
  const CMatrix *v318; // r1
  float v319; // s0
  float *p_xx; // r0
  float v321; // s0
  float v322; // s0
  float z; // s0
  int v324; // r0
  int v325; // r0
  float v326; // s18
  float v327; // s2
  float *v328; // r0
  float v329; // s0
  float *v330; // r0
  float v331; // s0
  float v332; // s0
  float *v333; // r0
  float v334; // s2
  float v335; // s18
  float v336; // s2
  float *v337; // r0
  float v338; // s0
  const CVector *v339; // r2
  float v340; // s16
  float v341; // s18
  float v342; // s20
  float v343; // s22
  float v344; // s24
  float v345; // s26
  float v346; // s28
  float v347; // s30
  float *v348; // r0
  float v349; // s0
  CVector vecSpeed; // [sp+0h] [bp-200h]
  CVector vecSpeeda; // [sp+0h] [bp-200h]
  CVector vecSpeedb; // [sp+0h] [bp-200h]
  CVector vecSpeedc; // [sp+0h] [bp-200h]
  CVector vecSpeedd; // [sp+0h] [bp-200h]
  CVector vecSpeede; // [sp+0h] [bp-200h]
  CVector vecSpeedf; // [sp+0h] [bp-200h]
  CVector vecSpeedg; // [sp+0h] [bp-200h]
  CVector vecSpeedh; // [sp+0h] [bp-200h]
  CVector vecSpeedi; // [sp+0h] [bp-200h]
  float *v360; // [sp+34h] [bp-1CCh]
  int v361; // [sp+38h] [bp-1C8h]
  float *v362; // [sp+3Ch] [bp-1C4h]
  CBaseModelInfo *v363; // [sp+40h] [bp-1C0h]
  float *v364; // [sp+44h] [bp-1BCh]
  int v365; // [sp+48h] [bp-1B8h]
  float *v366; // [sp+4Ch] [bp-1B4h]
  CPhysical **m_aGroundPhysicalPtrs; // [sp+50h] [bp-1B0h]
  float *v368; // [sp+54h] [bp-1ACh]
  CVector *v369; // [sp+58h] [bp-1A8h]
  int v370; // [sp+5Ch] [bp-1A4h]
  CVehicle::CVehicleFlags *v371; // [sp+60h] [bp-1A0h]
  SurfaceInfos_c *v372; // [sp+64h] [bp-19Ch]
  CCollisionData *m_pColData; // [sp+68h] [bp-198h]
  int v374; // [sp+68h] [bp-198h]
  float *v375; // [sp+6Ch] [bp-194h]
  _BOOL4 v376; // [sp+6Ch] [bp-194h]
  int v377; // [sp+70h] [bp-190h]
  float *v378; // [sp+70h] [bp-190h]
  float *p_x; // [sp+70h] [bp-190h]
  CPhysical *v380; // [sp+74h] [bp-18Ch]
  CVector v381; // [sp+78h] [bp-188h] BYREF
  CVector vecRight; // [sp+88h] [bp-178h] BYREF
  CVector vecForward; // [sp+98h] [bp-168h] BYREF
  CColPoint v; // [sp+A8h] [bp-158h] BYREF
  CVector m_vecPosition; // [sp+D8h] [bp-128h] BYREF
  CVector v386; // [sp+E4h] [bp-11Ch] BYREF
  float v387; // [sp+F4h] [bp-10Ch] BYREF
  CVector vecOffset; // [sp+F8h] [bp-108h] BYREF
  CVector v389; // [sp+104h] [bp-FCh] BYREF
  CVector v390; // [sp+110h] [bp-F0h] BYREF
  CVector v391; // [sp+11Ch] [bp-E4h] BYREF
  CVector v392[4]; // [sp+128h] [bp-D8h] BYREF
  float v393; // [sp+134h] [bp-CCh] BYREF
  float v394; // [sp+140h] [bp-C0h] BYREF
  float v395; // [sp+14Ch] [bp-B4h] BYREF
  CEventVehicleOnFire vecDirection; // [sp+15Ch] [bp-A4h] BYREF
  float v397; // [sp+170h] [bp-90h]
  CVector v398; // [sp+174h] [bp-8Ch] BYREF
  CVector v399; // [sp+180h] [bp-80h] BYREF
  float fSpringForce[4]; // [sp+18Ch] [bp-74h] BYREF
  int v401[25]; // [sp+19Ch] [bp-64h] BYREF
  CVector v402; // 0:r1.12
  CVector v403; // 0:r1.12
  CVector v404; // 0:r1.12
  CVector v405; // 0:r1.12
  CVector v406; // 0:r1.12
  CVector v407; // 0:r1.12
  CVector v408; // 0:r1.12
  CVector v409; // 0:r1.12
  CVector v410; // 0:r1.12
  CVector v411; // 0:r1.12

  v8 = this;
  ColModel = CEntity::GetColModel(this);
  m_nModelIndex = v8->m_nModelIndex;
  m_pColData = ColModel->m_pColData;
  v401[0] = 0;
  v11 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex];
  CAEVehicleAudioEntity::Service(&v8->m_VehicleAudioEntity);
  m_nVehicleFlags = (int)v8->m_nVehicleFlags;
  v13 = *((_DWORD *)&v8->m_nVehicleFlags + 1);
  v8->m_bLeanMatrix = 0;
  v8->nBrakesOn = 0;
  m_nBikeFlags = v8->m_nBikeFlags;
  *(_DWORD *)&v8->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFDFFF;
  *((_DWORD *)&v8->m_nVehicleFlags + 1) = v13 & 0xFFFFFFFD;
  v8->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags & 0xDF);
  CVehicle::ProcessCarAlarm(v8);
  CVehicle::ActivateBombWhenEntered(v8);
  CVehicle::UpdateClumpAlpha(v8);
  pDriver = v8->pDriver;
  if ( pDriver && (CPed::IsPlayer(pDriver) || (v16 = v8->pPassengers[0]) != 0 && CPed::IsPlayer(v16)) )
  {
    if ( v8->m_nTestPedCollision )
    {
      if ( v8->m_nTestPedCollision == 1 )
        v8->m_nTestPedCollision = 2;
    }
    else
    {
      v8->m_nTestPedCollision = 1;
    }
  }
  else
  {
    v8->m_nTestPedCollision = 0;
  }
  (*((void (__fastcall **)(CBike *, int *))v8->_vptr$CPlaceable + 67))(v8, v401);
  LOBYTE(m_info) = v8->m_info;
  if ( (m_info & 0xF8) != 16 )
  {
    v18 = v8->m_nBikeFlags;
    if ( (*(_BYTE *)&v18 & 0x10) != 0 )
    {
      m_pMat = v8->m_pMat;
      if ( fabsf(m_pMat->zx) > 0.35 || fabsf(m_pMat->zy) > 0.5 )
      {
        v18 = (CBike::CBikeFlags)(*(_BYTE *)&v18 & 0xEF);
        v8->m_nBikeFlags = v18;
      }
    }
    p_m_nVehicleFlags = &v8->m_nVehicleFlags;
    if ( (v401[0] & 2) == 0 && (*(_BYTE *)&v18 & 0x18) == 0 )
    {
      pHandling = v8->pHandling;
      pBikeHandling = v8->pBikeHandling;
      v8->m_vecCOM.x = pHandling->CentreOfMass.x;
      v8->m_vecCOM.y = pHandling->CentreOfMass.y;
      v8->m_vecCOM.z = pBikeHandling->fNoRiderCOMz;
      goto LABEL_36;
    }
    y = vecTestResistance.y;
    x = vecTestResistance.x;
    Multiply3x3((CVector *)&vecDirection, &v8->m_vecTurnSpeed, v8->m_pMat);
    if ( *(_BYTE *)&v8->m_info > 7u )
    {
      v28 = x;
      v25 = 1.0;
      goto LABEL_34;
    }
    v25 = 1.0;
    if ( v8->m_aWheelRatios[0] >= 1.0 && v8->m_aWheelRatios[1] >= 1.0 )
    {
      FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_BALANCE_DAMPING);
      v28 = 0.88;
      if ( v8->m_aWheelRatios[2] >= 1.0 && v8->m_aWheelRatios[3] >= 1.0 )
      {
        v25 = 88.0;
LABEL_34:
        v30 = v8->m_pMat;
        v31 = vecDirection._vptr$CEvent;
        m_iAccumulatedTime = vecDirection.m_iAccumulatedTime;
        m_fTurnMass = v8->m_fTurnMass;
        v34 = CTimer::ms_fTimeStep;
        xz = v30->xz;
        yz = v30->yz;
        v3.n64_u32[1] = LODWORD(v30->zz);
        Multiply3x3(v392, v30, &v8->m_vecCOM);
        v37 = (float)(*(float *)&m_iAccumulatedTime
                    * powf(
                        y
                      * (float)(1.0
                              / (float)((float)(*(float *)&m_iAccumulatedTime
                                              * (float)(*(float *)&m_iAccumulatedTime * 1000.0))
                                      + 1.0)),
                        v34))
            - *(float *)&m_iAccumulatedTime;
        vecSpeed.x = v30->xx + v392[0].x;
        vecSpeed.y = v30->yx + v392[0].y;
        vecSpeed.z = v30->zx + v392[0].z;
        v402.x = -(float)((float)(xz * v37) * m_fTurnMass);
        v402.y = -(float)((float)(v37 * yz) * m_fTurnMass);
        v402.z = -(float)((float)(v37 * v3.n64_f32[1]) * m_fTurnMass);
        CPhysical::ApplyTurnForce(v8, v402, vecSpeed);
        v38 = v8->m_pMat;
        v39 = v8->m_fTurnMass;
        v40 = v38->xz;
        v41 = v38->yz;
        zz = v38->zz;
        Multiply3x3(v392, v38, &v8->m_vecCOM);
        v43 = (float)(*(float *)&v31
                    * powf(
                        (float)(1.0 / (float)((float)(*(float *)&v31 * (float)(v25 * *(float *)&v31)) + 1.0)) * v28,
                        v34))
            - *(float *)&v31;
        v403.x = (float)(v43 * v40) * v39;
        v403.y = (float)(v43 * v41) * v39;
        v403.z = (float)(v43 * zz) * v39;
        vecSpeeda.x = v38->xy + v392[0].x;
        vecSpeeda.y = v38->yy + v392[0].y;
        vecSpeeda.z = v38->zy + v392[0].z;
        CPhysical::ApplyTurnForce(v8, v403, vecSpeeda);
        m_info = (unsigned __int8)v8->m_info;
        if ( m_info >= 8 )
        {
          v44 = v8->pHandling;
          v45 = *(_QWORD *)&v44->CentreOfMass.x;
          v8->m_vecCOM.z = v44->CentreOfMass.z;
          *(_QWORD *)&v8->m_vecCOM.x = v45;
        }
LABEL_36:
        v46 = 0;
        v47 = (*(_DWORD *)&v8->m_nFlags & 0x10) == 0;
        if ( (*(_DWORD *)&v8->m_nFlags & 0x10) == 0 )
          v47 = (m_info & 0xF0) == 32;
        if ( !v47 )
        {
LABEL_71:
          v61 = v8->m_aGroundPhysicalPtrs[0];
          v62 = CWorld::bForceProcessControl;
          if ( v61 )
          {
            *((_DWORD *)&v8->m_nVehicleFlags + 1) |= 2u;
            if ( v62 )
            {
              if ( (*(_BYTE *)&v61->m_nFlags & 0x20) != 0 )
                goto LABEL_89;
            }
          }
          v63 = v8->m_aGroundPhysicalPtrs[1];
          if ( v63 )
          {
            *((_DWORD *)&v8->m_nVehicleFlags + 1) |= 2u;
            if ( v62 )
            {
              if ( (*(_BYTE *)&v63->m_nFlags & 0x20) != 0 )
                goto LABEL_89;
            }
          }
          if ( (v64 = v8->m_aGroundPhysicalPtrs[2]) != 0
            && (*((_DWORD *)&v8->m_nVehicleFlags + 1) |= 2u, v62)
            && (*(_BYTE *)&v64->m_nFlags & 0x20) != 0
            || (v65 = v8->m_aGroundPhysicalPtrs[3], v66 = *((_DWORD *)&v8->m_nVehicleFlags + 1), v65)
            && (v66 |= 2u,
                *(_DWORD *)p_m_nVehicleFlags = *(_DWORD *)p_m_nVehicleFlags,
                *((_DWORD *)&v8->m_nVehicleFlags + 1) = v66,
                v62)
            && (*(_BYTE *)&v65->m_nFlags & 0x20) != 0 )
          {
LABEL_89:
            *(_DWORD *)&v8->m_nFlags |= 0x40u;
            return;
          }
          if ( (v66 & 2) != 0 )
          {
            v46 = 0;
            v8->m_nNoOfStaticFrames = 0;
          }
          (*((void (__fastcall **)(CBike *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int))v8->_vptr$CPlaceable + 57))(
            v8,
            0,
            0,
            0,
            0,
            0,
            49);
          if ( v8->m_fDamageImpulseMagnitude <= 0.0
            || fabsf(
                 (float)((float)(v8->m_vecDamageNormal.x * v8->m_pMat->xx)
                       + (float)(v8->m_vecDamageNormal.y * v8->m_pMat->yx))
               + (float)(v8->m_vecDamageNormal.z * v8->m_pMat->zx)) <= 0.5
            || (float)((float)((float)(v8->m_vecMoveSpeed.x * v8->m_vecMoveSpeed.x)
                             + (float)(v8->m_vecMoveSpeed.y * v8->m_vecMoveSpeed.y))
                     + (float)(v8->m_vecMoveSpeed.z * v8->m_vecMoveSpeed.z)) >= 0.1 )
          {
            v67 = (*(_BYTE *)&v8->m_nBikeFlags >> 3) & 1;
          }
          else
          {
            v67 = 1;
          }
          v380 = v8;
          v370 = v46;
          v371 = &v8->m_nVehicleFlags;
          if ( v46 == 1 )
          {
            CPhysical::SkipPhysics(v8);
            *(_DWORD *)p_m_nVehicleFlags &= 0xDEFFFFFF;
            if ( (*(_BYTE *)&v8->m_nBikeFlags & 0x10) != 0 )
            {
              m_fBarSteerAngle = v8->RideAnimData.m_fBarSteerAngle;
              if ( m_fBarSteerAngle < 0.34907 )
                v8->RideAnimData.m_fBarSteerAngle = m_fBarSteerAngle + (float)(CTimer::ms_fTimeStep * 0.017453);
              v69 = powf(0.97, CTimer::ms_fTimeStep);
              v70 = v8->m_pMat;
              zx = v70->zx;
              v72 = zx < 1.0;
              if ( zx <= 1.0 )
                v72 = zx < -1.0;
              if ( v72 )
              {
                v73 = -1.0;
              }
              else
              {
                v73 = 1.0;
                if ( zx <= 1.0 )
                  v73 = v70->zx;
              }
              m_fDesiredLeanAngle = v8->RideAnimData.m_fDesiredLeanAngle;
              v77 = (float)(v69 * m_fDesiredLeanAngle) - (float)((float)(1.0 - v69) * (float)(asinf(v73) + 0.2618));
              v8->RideAnimData.m_fDesiredLeanAngle = v77;
              v8->RideAnimData.m_fLeanAngle = v77;
            }
LABEL_357:
            v6.n64_u32[0] = 1132068864;
            if ( v8->m_nHealth >= 250.0 || (*(_BYTE *)&v8->m_info & 0xF8) == 40 )
            {
              m_fxSysEngFire = v8->m_fxSysEngFire;
              v8->m_BlowUpTimer = 0.0;
              if ( m_fxSysEngFire )
              {
                FxSystem_c::Kill(m_fxSysEngFire);
                v8->m_fxSysEngFire = 0;
              }
            }
            else
            {
              m_vehicleType = (RwObject_0 *)v8->m_vehicleType;
              v293 = m_vehicleType == (RwObject_0 *)&byte_9[1];
              if ( m_vehicleType != (RwObject_0 *)&byte_9[1] )
              {
                m_vehicleType = v8->m_pRwObject;
                v293 = m_vehicleType == 0;
              }
              if ( !v293 && !v8->m_fxSysEngFire )
              {
                m_hashKey = CModelInfo::ms_modelInfoPtrs[v8->m_nModelIndex][2].m_hashKey;
                v295 = (RwMatrix *)((char *)m_vehicleType->parent + 16);
                v296 = *(_QWORD *)(m_hashKey + 84);
                v392[0].z = *(RwReal *)(m_hashKey + 92);
                *(_QWORD *)&v392[0].x = v296;
                FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, "fire_bike", v392, v295, 0);
                v8->m_fxSysEngFire = FxSystem;
                if ( FxSystem )
                {
                  FxSystem_c::Play(FxSystem);
                  CEventVehicleOnFire::CEventVehicleOnFire(&vecDirection, v8);
                  EventGlobalGroup = GetEventGlobalGroup();
                  CEventGroup::Add(EventGlobalGroup, (CEvent *)&vecDirection, 0);
                  CEventVehicleOnFire::~CEventVehicleOnFire(&vecDirection);
                }
              }
              v299 = v8->m_BlowUpTimer + (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
              v8->m_BlowUpTimer = v299;
              if ( v299 > 5000.0 )
                (*((void (__fastcall **)(CBike *, CEntity *, _DWORD))v8->_vptr$CPlaceable + 42))(
                  v8,
                  v8->pEntityThatSetUsOnFire,
                  0);
            }
            CVehicle::ProcessDelayedExplosion(v8);
            v300 = 1.0;
            v7.n64_u32[0] = 0;
            p_x = &v8->m_vecMoveSpeed.x;
            v301 = 0.0;
            m_aWheelRatios = v8->m_aWheelRatios;
            m_aRatioHistory = v8->m_aRatioHistory;
            v304 = -44;
            v3.n64_u32[0] = 1036831949;
            v305 = 0;
            v306 = (float)((float)(v8->m_vecMoveSpeed.x * v8->m_vecMoveSpeed.x)
                         + (float)(v8->m_vecMoveSpeed.y * v8->m_vecMoveSpeed.y))
                 + (float)(v8->m_vecMoveSpeed.z * v8->m_vecMoveSpeed.z);
            do
            {
              v307 = &m_aWheelRatios[v305];
              v308 = m_aWheelRatios[v305];
              if ( v306 > 0.04 && !(v305 * 4) )
              {
                v309 = *m_aRatioHistory - v308;
                if ( v309 > 0.3 )
                {
                  v310 = v309 == v301;
                  v311 = v309 < v301;
                  v312 = (unsigned __int8)v380->m_info;
                  if ( v312 >> 3 )
                  {
                    if ( !v311 && !v310 && v312 >> 3 == 3 )
                      v301 = *m_aRatioHistory - v308;
                  }
                  else if ( !v311 && !v310 )
                  {
                    v301 = *m_aRatioHistory - v308;
                  }
                }
              }
              v313 = m_aWheelRatios[v305];
              if ( v308 < 1.0 && *(_BYTE *)&v380->m_info <= 7u )
              {
                v1.n128_f32[0] = (float)SurfaceInfos_c::GetRoughness(&g_surfaceInfos, HIBYTE(m_aRatioHistory[v304 + 4]));
                v313 = m_aWheelRatios[v305];
                v1.n128_f32[0] = v1.n128_f32[0] * 0.1;
                v7.n64_u64[0] = vmax_f32(v7, (float32x2_t)v1.n128_u64[0]).n64_u64[0];
              }
              m_aRatioHistory[v305++] = v313;
              v304 += 11;
              *v307 = 1.0;
            }
            while ( v305 != 4 );
            v4.n64_u32[0] = 0;
            v314 = 0.0;
            if ( v7.n64_f32[0] < 0.29 )
              v314 = v301;
            if ( (CTimer::m_snTimeInMilliseconds & 0x7FF) > 0x320 )
            {
              v301 = v314;
              v7.n64_u32[0] = 0;
            }
            if ( v301 > 0.0 && *(_BYTE *)&v380->m_info <= 7u )
            {
              v315 = (float)((float)(v380->m_vecMoveSpeed.x * v380->m_vecMoveSpeed.x)
                           + (float)(v380->m_vecMoveSpeed.y * v380->m_vecMoveSpeed.y))
                   + (float)(v380->m_vecMoveSpeed.z * v380->m_vecMoveSpeed.z);
              if ( v315 > 0.01 )
              {
                v1.n128_f32[0] = sqrtf(v315);
                if ( v301 <= 0.0 )
                {
                  v2.n128_u32[0] = 1125515264;
                  v1.n128_f32[0] = (float)((float)((float)((float)(v7.n64_f32[0] * 200.0) * v1.n128_f32[0]) * 2000.0)
                                         / v380->m_fMass)
                                 + 40.0;
                  v1.n128_f32[2] = CTimer::ms_fTimeStep * 5000.0;
                  v1.n128_u64[0] = vmin_f32((float32x2_t)v1.n128_u64[0], (float32x2_t)v2.n128_u64[0]).n64_u64[0];
                }
                else
                {
                  v1.n128_f32[0] = (float)((float)((float)((float)(v301 * 200.0) * v1.n128_f32[0]) * 2000.0)
                                         / v380->m_fMass)
                                 + 100.0;
                  v1.n128_f32[2] = CTimer::ms_fTimeStep * 20000.0;
                  v1.n128_u64[0] = vmin_f32((float32x2_t)v1.n128_u64[0], v6).n64_u64[0];
                }
                Pad = CPad::GetPad(0);
                CPad::StartShake(
                  Pad,
                  (unsigned int)(float)(v1.n128_f32[2] / (float)(unsigned int)v1.n128_f32[0]),
                  (unsigned int)v1.n128_f32[0],
                  0);
              }
            }
            v47 = (*(_DWORD *)v371 & 0x2000) == 0;
            *(_DWORD *)v371 &= 0xDEFFFFFF;
            if ( v47 )
              CCarCtrl::ScanForPedDanger((CVehicle *)v380);
            if ( (*(_DWORD *)&v380->m_nPhysicalFlags & 0xC) == 12 )
            {
              *(_QWORD *)&v8->m_vecMoveFriction.z = 0LL;
              *(_QWORD *)&v8->m_vecTurnFriction.y = 0LL;
              *(_QWORD *)p_x = 0LL;
              *(_QWORD *)&v8->m_vecMoveSpeed.z = 0LL;
              *(_QWORD *)&v8->m_vecTurnSpeed.y = 0LL;
              *(_QWORD *)&v8->m_vecMoveFriction.x = 0LL;
            }
            else if ( !v370
                   && (v380[3].m_vecDamageNormal.z == 0.0 || (*(_BYTE *)&v380->m_info & 0xF8) == 40)
                   && fabsf(*p_x) < 0.005
                   && fabsf(v380->m_vecMoveSpeed.y) < 0.005
                   && fabsf(v380->m_vecMoveSpeed.z) < 0.005 )
            {
              if ( v380->m_fDamageImpulseMagnitude <= 0.0
                || (m_pDamageEntity = (CPlayerPed *)v380->m_pDamageEntity, m_pDamageEntity != FindPlayerPed(-1)) )
              {
                v380->m_vecMoveSpeed.x = 0.0;
                v380->m_vecMoveSpeed.y = 0.0;
                v380->m_vecMoveSpeed.z = 0.0;
                v380->m_vecTurnSpeed.z = 0.0;
              }
            }
            if ( (v401[0] & 2) != 0 || ((int)v380[4].m_pRealTimeShadow & 0x18) != 0 )
            {
              v318 = v380->m_pMat;
              v319 = (float)((float)(v318->xx * *(float *)&v380[5]._vptr$CPlaceable)
                           + (float)(v318->yx * v380[5].m_transform.m_translate.x))
                   + (float)(v318->zx * v380[5].m_transform.m_translate.y);
              if ( v319 <= 1.0 )
              {
                v300 = (float)((float)(v318->xx * *(float *)&v380[5]._vptr$CPlaceable)
                             + (float)(v318->yx * v380[5].m_transform.m_translate.x))
                     + (float)(v318->zx * v380[5].m_transform.m_translate.y);
                if ( v319 < -1.0 )
                  v300 = -1.0;
              }
              Multiply3x3((CVector *)&vecDirection, v318, &v380->m_vecCOM);
              p_xx = &v380->m_pMat->xx;
              if ( (v401[0] & 2) != 0 )
              {
                v322 = (float)(v300 * -0.07) * v380->m_fTurnMass;
                v406.x = (float)(v322 * p_xx[8]) * CTimer::ms_fTimeStep;
                v406.y = (float)(v322 * p_xx[9]) * CTimer::ms_fTimeStep;
                v406.z = (float)(v322 * p_xx[10]) * CTimer::ms_fTimeStep;
                vecSpeede.x = *(float *)&vecDirection._vptr$CEvent + *p_xx;
                vecSpeede.y = *(float *)&vecDirection.m_iAccumulatedTime + p_xx[1];
                vecSpeede.z = *(float *)&vecDirection.m_bIsPersistent + p_xx[2];
                CPhysical::ApplyTurnForce(v380, v406, vecSpeede);
                LOBYTE(v380[4].m_pRealTimeShadow) &= ~0x10u;
              }
              else
              {
                v321 = (float)(v300 * -0.1) * v380->m_fTurnMass;
                v405.x = (float)(v321 * p_xx[8]) * CTimer::ms_fTimeStep;
                v405.y = (float)(v321 * p_xx[9]) * CTimer::ms_fTimeStep;
                v405.z = (float)(v321 * p_xx[10]) * CTimer::ms_fTimeStep;
                vecSpeedd.x = *(float *)&vecDirection._vptr$CEvent + *p_xx;
                vecSpeedd.y = *(float *)&vecDirection.m_iAccumulatedTime + p_xx[1];
                vecSpeedd.z = *(float *)&vecDirection.m_bIsPersistent + p_xx[2];
                CPhysical::ApplyTurnForce(v380, v405, vecSpeedd);
              }
              if ( *(_BYTE *)&v380->m_info <= 7u )
              {
                z = v380[5].m_vecAttachTiltOffset.z;
                if ( z > 0.0
                  || v380[5].m_AttachQuat.imag.x > 0.0
                  || (v1.n128_u32[2] = LODWORD(v380->m_pMat->zy), v1.n128_f32[2] <= 0.0)
                  || v380[5].m_AttachQuat.imag.y <= 0.0 && v380[5].m_AttachQuat.imag.z <= 0.0 )
                {
                  if ( v380[5].m_AttachQuat.imag.y <= 0.0 && v380[5].m_AttachQuat.imag.z <= 0.0 )
                  {
                    v1.n128_u32[2] = LODWORD(v380->m_pMat->zy);
                    if ( v1.n128_f32[2] < 0.0 && (z > 0.0 || v380[5].m_AttachQuat.imag.x > 0.0) )
                    {
                      v325 = *(_DWORD *)&v380[5].RandomSeed;
                      v1.n128_f32[0] = *(float *)(v325 + 48) - v1.n128_f32[2];
                      if ( v1.n128_f32[0] <= 0.15 )
                      {
                        if ( v1.n128_f32[0] < -0.15 )
                        {
                          v1.n128_f32[0] = -0.3 - v1.n128_f32[0];
                          v1.n128_u32[0] = vmin_f32((float32x2_t)v1.n128_u64[0], v4).n64_u32[0];
                        }
                      }
                      else
                      {
                        v1.n128_f32[0] = 0.3 - v1.n128_f32[0];
                        v1.n128_u32[0] = vmax_f32((float32x2_t)v1.n128_u64[0], v4).n64_u32[0];
                      }
                      v1.n128_f32[2] = sqrtf(
                                         (float)((float)(v380->m_vecMoveSpeed.x * v380->m_vecMoveSpeed.x)
                                               + (float)(v380->m_vecMoveSpeed.y * v380->m_vecMoveSpeed.y))
                                       + (float)(v380->m_vecMoveSpeed.z * v380->m_vecMoveSpeed.z));
                      v335 = v1.n128_f32[0]
                           * (float)(*(float *)(v325 + 60) * vmin_f32(*(float32x2_t *)&v1.n128_i8[8], v3).n64_f32[0]);
                      v336 = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_BALANCE_FORCE);
                      v337 = &v380->m_pMat->xx;
                      v338 = v380->m_fTurnMass * (float)((float)(CTimer::ms_fTimeStep * 0.5) * (float)(v336 * v335));
                      v410.x = v337[8] * v338;
                      v410.y = v337[9] * v338;
                      v410.z = v337[10] * v338;
                      vecSpeedh.x = *(float *)&vecDirection._vptr$CEvent + v337[4];
                      vecSpeedh.y = *(float *)&vecDirection.m_iAccumulatedTime + v337[5];
                      vecSpeedh.z = *(float *)&vecDirection.m_bIsPersistent + v337[6];
                      CPhysical::ApplyTurnForce(v380, v410, vecSpeedh);
                      v339 = (const CVector *)v380->m_pMat;
                      v340 = v380->m_vecMoveSpeed.x;
                      v341 = v380->m_vecMoveSpeed.y;
                      v342 = v380->m_vecMoveSpeed.z;
                      v343 = CTimer::ms_fTimeStep;
                      v344 = v380->m_fTurnMass;
                      v345 = v339->x;
                      v346 = v339->y;
                      v347 = v339->z;
                      vecOffset.x = 0.0;
                      vecOffset.y = 0.0;
                      vecOffset.z = 1.0;
                      CrossProduct(v392, &vecOffset, v339);
                      CVector::Normalise(v392);
                      v348 = &v380->m_pMat->xx;
                      v349 = (float)((float)((float)(v340 * v345) + (float)(v341 * v346)) + (float)(v342 * v347))
                           * (float)((float)(v344 * -0.05) * v343);
                      v411.x = *v348 * v349;
                      v411.y = v348[1] * v349;
                      v411.z = v348[2] * v349;
                      vecSpeedi.x = -v392[0].x;
                      vecSpeedi.y = -v392[0].y;
                      vecSpeedi.z = -v392[0].z;
                      CPhysical::ApplyTurnForce(v380, v411, vecSpeedi);
                    }
                  }
                }
                else
                {
                  v324 = *(_DWORD *)&v380[5].RandomSeed;
                  v1.n128_f32[0] = *(float *)(v324 + 44) - v1.n128_f32[2];
                  if ( v1.n128_f32[0] <= 0.15 )
                  {
                    if ( v1.n128_f32[0] < -0.08 )
                    {
                      v1.n128_f32[0] = -0.14 - v1.n128_f32[0];
                      v1.n128_u32[0] = vmin_f32((float32x2_t)v1.n128_u64[0], v4).n64_u32[0];
                    }
                  }
                  else
                  {
                    v1.n128_f32[0] = 0.3 - v1.n128_f32[0];
                    v1.n128_u32[0] = vmax_f32((float32x2_t)v1.n128_u64[0], v4).n64_u32[0];
                  }
                  v1.n128_f32[2] = sqrtf(
                                     (float)((float)(v380->m_vecMoveSpeed.x * v380->m_vecMoveSpeed.x)
                                           + (float)(v380->m_vecMoveSpeed.y * v380->m_vecMoveSpeed.y))
                                   + (float)(v380->m_vecMoveSpeed.z * v380->m_vecMoveSpeed.z));
                  v326 = v1.n128_f32[0]
                       * (float)(*(float *)(v324 + 56) * vmin_f32(*(float32x2_t *)&v1.n128_i8[8], v3).n64_f32[0]);
                  v327 = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_BALANCE_FORCE);
                  v328 = &v380->m_pMat->xx;
                  v329 = v380->m_fTurnMass * (float)((float)(CTimer::ms_fTimeStep * 0.5) * (float)(v327 * v326));
                  v407.x = v328[8] * v329;
                  v407.y = v328[9] * v329;
                  v407.z = v328[10] * v329;
                  vecSpeedf.x = *(float *)&vecDirection._vptr$CEvent + v328[4];
                  vecSpeedf.y = *(float *)&vecDirection.m_iAccumulatedTime + v328[5];
                  vecSpeedf.z = *(float *)&vecDirection.m_bIsPersistent + v328[6];
                  CPhysical::ApplyTurnForce(v380, v407, vecSpeedf);
                  v330 = &v380->m_pMat->xx;
                  v331 = (float)((float)((float)(CTimer::ms_fTimeStep * 0.5) * *(float *)&v380[5].m_pLastRenderedLink)
                               * *(float *)(*(_DWORD *)&v380[5].RandomSeed + 52))
                       * v380->m_fTurnMass;
                  v408.x = v331 * *v330;
                  v408.y = v331 * v330[1];
                  v408.z = v331 * v330[2];
                  vecSpeedg.x = *(float *)&vecDirection._vptr$CEvent + v330[4];
                  vecSpeedg.y = *(float *)&vecDirection.m_iAccumulatedTime + v330[5];
                  vecSpeedg.z = *(float *)&vecDirection.m_bIsPersistent + v330[6];
                  CPhysical::ApplyTurnForce(v380, v408, vecSpeedg);
                  v332 = sqrtf(
                           (float)((float)(v380->m_vecMoveSpeed.x * v380->m_vecMoveSpeed.x)
                                 + (float)(v380->m_vecMoveSpeed.y * v380->m_vecMoveSpeed.y))
                         + (float)(v380->m_vecMoveSpeed.z * v380->m_vecMoveSpeed.z));
                  v333 = &v380->m_pMat->xx;
                  v334 = v380->m_fMass
                       * (float)(*(float *)(*(_DWORD *)&v380[5].RandomSeed + 52)
                               * (float)(*(float *)&v380[5].m_pLastRenderedLink
                                       * (float)(CTimer::ms_fTimeStep * (float)(v332 * 0.01))));
                  v409.x = v332 * (float)(*v333 * v334);
                  v409.y = v332 * (float)(v333[1] * v334);
                  v409.z = v332 * (float)(v334 * v333[2]);
                  CPhysical::ApplyMoveForce(v380, v409);
                  *(float *)&v380[5].m_nScanCode = *(float *)&v380[5].m_nScanCode
                                                 + (float)((float)(CTimer::ms_fTimeStep * -0.1)
                                                         * *(float *)&v380[5].m_pLastRenderedLink);
                }
              }
            }
            return;
          }
          if ( !(*((unsigned __int8 *)&v8->m_nVehicleFlags + 3) << 31) )
            (*((void (__fastcall **)(CBike *, int))v8->_vptr$CPlaceable + 24))(v8, 1);
          if ( (v401[0] & 2) == 0 && (*(_BYTE *)&v8->m_nBikeFlags & 0x18) == 0 )
          {
            m_fSteerAngle = v8->m_fSteerAngle;
            if ( v8->m_pMat->zx >= 0.0 )
            {
              if ( m_fSteerAngle < 0.43633 )
              {
                v75 = 0.0087266;
                goto LABEL_112;
              }
            }
            else if ( m_fSteerAngle > -0.43633 )
            {
              v75 = -0.0087266;
LABEL_112:
              v8->m_fSteerAngle = m_fSteerAngle + (float)(CTimer::ms_fTimeStep * v75);
            }
          }
          m_fAirResistance = v8->m_fAirResistance;
          if ( *(_BYTE *)&v8->m_info <= 7u )
          {
            v79 = v8->pDriver;
            if ( v79 )
            {
              Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)v79->m_pRwObject, 0xC7u);
              if ( Association )
              {
                if ( Association->m_fBlendAmount > 0.5 )
                {
                  m_fCurrentTime = Association->m_fCurrentTime;
                  if ( m_fCurrentTime > 0.06 && m_fCurrentTime < 0.14 )
                  {
                    v82 = 0.6;
                    if ( CCullZones::DoExtraAirResistanceForPlayer() )
                      v82 = 0.85;
                    v83 = v8->m_fGasPedal <= 0.5;
                    v8->m_fAirResistance = v8->m_fAirResistance * v82;
                    if ( !v83 )
                    {
                      v84 = &v8->m_pMat->xx;
                      v85 = v84[4];
                      v86 = v84[5];
                      v87 = v84[6];
                      if ( (float)((float)((float)(v8->m_vecMoveSpeed.x * v85) + (float)(v8->m_vecMoveSpeed.y * v86))
                                 + (float)(v8->m_vecMoveSpeed.z * v87)) > 0.25 )
                      {
                        v88 = CTimer::ms_fTimeStep * (float)((float)(v8->m_fMass * 0.2) * 0.008);
                        v404.x = v85 * v88;
                        v404.y = v86 * v88;
                        v404.z = v87 * v88;
                        CPhysical::ApplyMoveForce(v8, v404);
                        *(_BYTE *)&v8->m_nBikeFlags |= 0x20u;
                      }
                    }
                  }
                }
              }
            }
          }
          m_aGroundPhysicalPtrs = v8->m_aGroundPhysicalPtrs;
          m_nPhysicalFlags = v8->m_nPhysicalFlags;
          CPhysical::ProcessControl(v8);
          v8->m_fAirResistance = m_fAirResistance;
          CBike::ProcessBuoyancy(v8);
          if ( (*(_WORD *)&m_nPhysicalFlags & 0x100) == 0 && *((unsigned __int8 *)&v8->m_nPhysicalFlags + 1) << 31 )
          {
            v90 = v8->pDriver;
            if ( v90 && CPed::IsPlayer(v90) )
            {
              CPlayerPed::ResetPlayerBreath((CPlayerPed *)v8->pDriver);
            }
            else if ( v8->m_nMaxPassengers )
            {
              pPassengers = v8->pPassengers;
              v92 = 0;
              do
              {
                v93 = pPassengers[v92];
                if ( v93 && CPed::IsPlayer(v93) )
                  CPlayerPed::ResetPlayerBreath((CPlayerPed *)pPassengers[v92]);
                ++v92;
              }
              while ( v92 < v8->m_nMaxPassengers );
            }
          }
          v94 = (float *)v8;
          v363 = v11;
          p_y = &vecOffset.y;
          v96 = &v8->m_fLineLength[3];
          v365 = v67;
          p_z = &v8->m_aWheelColPoints[0].m_vecPosition.z;
          p_vecDirection = (CVector *)&vecDirection;
          v99 = 24;
          v100 = 1.0 - (float)(v94[484] / *v96);
          v360 = v94 + 481;
          v101 = 1.0 - (float)(v94[482] / v94[486]);
          v362 = v94 + 483;
          v102 = 1.0 - (float)(v94[481] / v94[485]);
          v103 = 1.0 - (float)(v94[483] / v94[487]);
          v375 = v94 + 457;
          v104 = v94[460] - v100;
          v1.n128_f32[1] = 1.0 - v103;
          v105 = v94[459] - v103;
          v106 = 1.0 - v100;
          v1.n128_f32[0] = (float)(v94[457] - v102) / (float)(1.0 - v102);
          v1.n128_f32[2] = (float)(v94[458] - v101) / (float)(1.0 - v101);
          v94[457] = v1.n128_f32[0];
          v107 = (unsigned __int32 *)(v94 + 458);
          v94[458] = v1.n128_f32[2];
          v369 = (CVector *)(v94 + 459);
          v94[459] = v105 / v1.n128_f32[1];
          v366 = v94 + 460;
          v94[460] = v104 / v106;
          v368 = v94 + 458;
          while ( 1 )
          {
            if ( v1.n128_f32[0] < 1.0 )
            {
              v108 = v380->m_pMat;
              v109 = *p_z;
              p_tx = &v108->tx;
              if ( !v108 )
                p_tx = &v380->m_transform.m_translate.x;
              v111 = p_tx[2];
              v112 = *(p_z - 1) - p_tx[1];
              *(p_y - 1) = *(p_z - 2) - *p_tx;
              *p_y = v112;
              p_y[1] = v109 - v111;
              v113 = (float *)((char *)&m_pColData->_anon_1.m_pLineArray->m_vecStart.x + v99);
              v114 = *(v113 - 2) - *(v113 - 6);
              v115 = *v113;
              v116 = *(v113 - 4);
              v.m_vecPosition.y = *(v113 - 1) - *(v113 - 5);
              v.m_vecPosition.x = v114;
              v.m_vecPosition.z = v115 - v116;
              Multiply3x3(v392, v108, &v.m_vecPosition);
              v117 = *(_QWORD *)&v392[0].x;
              p_vecDirection->z = v392[0].z;
              *(_QWORD *)&p_vecDirection->x = v117;
              CVector::Normalise(p_vecDirection);
            }
            if ( v99 == 120 )
              break;
            v1.n128_u32[0] = *v107;
            p_y += 3;
            p_z += 11;
            v99 += 32;
            ++p_vecDirection;
            ++v107;
          }
          v118 = (CVector *)&vecDirection;
          p_vecOffset = &vecOffset;
          v380[5].m_pNOCollisionVehicle = 0;
          v120 = 16;
          v380[5].m_lightingFromCollision = 0.0;
          v121 = -44;
          HIBYTE(v380[5].m_lightingFromPointLights) = 0;
          v122 = 0;
          v377 = 0;
          v123 = 0;
          BYTE2(v380[5].m_lightingFromPointLights) = 0;
          do
          {
            v124 = v375[v122];
            if ( v124 >= 1.0 )
            {
              Multiply3x3(
                v392,
                v380->m_pMat,
                (const CVector *)((char *)&m_pColData->_anon_1.m_pLineArray->m_vecStart + v120));
              v129 = *(_QWORD *)&v392[0].x;
              p_vecOffset->z = v392[0].z;
              *(_QWORD *)&p_vecOffset->x = v129;
            }
            else
            {
              v125 = &v375[v121];
              v126 = v380[2].m_vecAttachTiltOffset.x;
              v127 = *(float *)(LODWORD(v126) + 192);
              v128 = *(float *)(LODWORD(v126) + 172);
              if ( (v123 | 1) == 3 )
                v127 = 1.0 - v127;
              if ( v125[6] <= 0.35 )
                CPhysical::ApplySpringCollision(v380, v128, v118, p_vecOffset, v124, v127, &fSpringForce[v122]);
              else
                CPhysical::ApplySpringCollisionAlt(
                  v380,
                  v128,
                  v118,
                  p_vecOffset,
                  v124,
                  v127,
                  (CVector *)(v125 + 4),
                  &fSpringForce[v122]);
              v130 = v123 > 1;
              SkidmarkType = SurfaceInfos_c::GetSkidmarkType(
                               &g_surfaceInfos,
                               *((unsigned __int8 *)&v375[v377 - 35] - 1));
              *((_DWORD *)&v380[5].m_pNOCollisionVehicle + v130) = SkidmarkType;
              if ( SkidmarkType == SKIDMARKTYPE_SANDY )
                *((_BYTE *)&v380[5].m_lightingFromPointLights + v130 + 2) = 1;
            }
            v120 += 32;
            v121 += 11;
            ++v122;
            ++p_vecOffset;
            ++v118;
            ++v123;
            v377 += 11;
          }
          while ( v120 != 144 );
          v132 = 0;
          for ( i = 0; i != 12; i += 3 )
          {
            CPhysical::GetSpeed(&v.m_vecPosition, v380, *(CVector *)((char *)&vecOffset + i * 4));
            v134 = *(_QWORD *)&v.m_vecPosition.x;
            v135 = &v392[i / 3];
            v135->z = v.m_vecPosition.z;
            *(_QWORD *)&v135->x = v134;
            v136 = m_aGroundPhysicalPtrs[v132];
            if ( v136 )
            {
              CPhysical::GetSpeed(&v.m_vecPosition, v136, *(CVector *)&m_aGroundPhysicalPtrs[i + 4]);
              v137 = v135->y - v.m_vecPosition.y;
              v138 = v135->z - v.m_vecPosition.z;
              v135->x = v135->x - v.m_vecPosition.x;
              v135->y = v137;
              v135->z = v138;
            }
            ++v132;
          }
          v139 = *v375;
          if ( *v375 < 1.0 || (v140 = *v368, *v368 < 1.0) )
          {
            v141 = 0;
            v142 = 0;
            if ( v139 >= 1.0 )
              v141 = 1;
            v143 = (float *)((char *)v380 + 44 * v141);
            v144 = v143[419];
            if ( v144 > 0.35 )
            {
              *(float *)&v145 = -v143[418];
              v146 = -v143[417];
              *(float *)&vecDirection.m_bIsPersistent = -v144;
              vecDirection.m_iAccumulatedTime = v145;
              *(float *)&vecDirection._vptr$CEvent = v146;
            }
            v140 = *v368;
            if ( *v368 < 1.0 )
              v142 = 1;
            v147 = *(&v380[5].m_vecMoveFriction.x + 11 * v142);
            if ( v147 > 0.35 )
            {
              v148 = (float *)((char *)v380 + 44 * v142);
              v149 = v148[417];
              v150 = -v148[418];
              v397 = -v147;
              *(float *)&vecDirection.m_pVehicleOnFire = v150;
              *(float *)&vecDirection.m_iFacialTaskType = -v149;
            }
          }
          if ( v369->x < 1.0 || *v366 < 1.0 )
          {
            v151 = 3;
            if ( v369->x < 1.0 )
              v151 = 2;
            v152 = (float *)((char *)v380 + 44 * v151);
            v153 = v152[419];
            if ( v153 > 0.35 )
            {
              v154 = -v152[418];
              v155 = -v152[417];
              v398.z = -v153;
              v398.y = v154;
              v398.x = v155;
            }
            v156 = 2;
            if ( *v366 < 1.0 )
              v156 = 3;
            v157 = *(&v380[5].m_vecMoveFriction.x + 11 * v156);
            if ( v157 > 0.35 )
            {
              v158 = (float *)((char *)v380 + 44 * v156);
              v159 = v158[417];
              v160 = -v158[418];
              v399.z = -v157;
              v399.y = v160;
              v399.x = -v159;
            }
          }
          if ( v139 < 1.0 )
          {
            CPhysical::ApplySpringDampening(
              v380,
              *(float *)(LODWORD(v380[2].m_vecAttachTiltOffset.x) + 176),
              fSpringForce[0],
              (CVector *)&vecDirection,
              &vecOffset,
              &v392[0].x);
            v140 = *v368;
          }
          if ( v140 < 1.0 )
            CPhysical::ApplySpringDampening(
              v380,
              *(float *)(LODWORD(v380[2].m_vecAttachTiltOffset.x) + 176),
              fSpringForce[1],
              (CVector *)&vecDirection.m_iFacialTaskType,
              &v389,
              &v393);
          if ( v369->x < 1.0 )
            CPhysical::ApplySpringDampening(
              v380,
              *(float *)(LODWORD(v380[2].m_vecAttachTiltOffset.x) + 176),
              fSpringForce[2],
              &v398,
              &v390,
              &v394);
          if ( *v366 < 1.0 )
            CPhysical::ApplySpringDampening(
              v380,
              *(float *)(LODWORD(v380[2].m_vecAttachTiltOffset.x) + 176),
              fSpringForce[3],
              &v399,
              &v391,
              &v395);
          v161 = 0;
          for ( j = 0; j != 12; j += 3 )
          {
            CPhysical::GetSpeed(&v.m_vecPosition, v380, *(CVector *)((char *)&vecOffset + j * 4));
            v163 = *(_QWORD *)&v.m_vecPosition.x;
            v164 = &v392[j / 3];
            v164->z = v.m_vecPosition.z;
            *(_QWORD *)&v164->x = v163;
            v165 = m_aGroundPhysicalPtrs[v161];
            if ( v165 )
            {
              CPhysical::GetSpeed(&v.m_vecPosition, v165, *(CVector *)&m_aGroundPhysicalPtrs[j + 4]);
              v166 = v164->y - v.m_vecPosition.y;
              v167 = v164->z - v.m_vecPosition.z;
              v164->x = v164->x - v.m_vecPosition.x;
              v164->y = v166;
              v164->z = v167;
            }
            ++v161;
          }
          v387 = (float)((float)(v380->m_vecMoveSpeed.x * v380->m_pMat->xy)
                       + (float)(v380->m_vecMoveSpeed.y * v380->m_pMat->yy))
               + (float)(v380->m_vecMoveSpeed.z * v380->m_pMat->zy);
          v364 = &v380[3].m_vecDamageNormal.z;
          v168 = cTransmission::CalculateDriveAcceleration(
                   (cTransmission *)(LODWORD(v380[2].m_vecAttachTiltOffset.x) + 44),
                   &v380[3].m_vecDamageNormal.z,
                   (uint8 *)&v380[3].m_vecAttachPosnOffset.z,
                   &v380[3].m_vecAttachTiltOffset.x,
                   &v387,
                   0,
                   0,
                   BYTE1(v380[6].m_vecCOM.z),
                   CCheat::m_aCheatsActive[35]);
          v169 = v380[2].m_vecAttachTiltOffset.x;
          v170 = v380[3].m_vecDamagePos.x * *(float *)(LODWORD(v169) + 148);
          v171 = CTimer::ms_fTimeStep;
          if ( ((*(_BYTE *)&v380->m_info >> 3) | 8) != 8 && (*(_BYTE *)(LODWORD(v169) + 208) & 8) != 0 )
          {
            v174 = 1.0;
            v361 = 1;
            v173 = 1.0;
            v3.n64_u32[0] = 1.0;
          }
          else
          {
            v172 = *(float *)(LODWORD(v169) + 152);
            v173 = v172 + v172;
            v361 = 0;
            v3.n64_f32[0] = *(float *)(LODWORD(v169) + 168) + *(float *)(LODWORD(v169) + 168);
            v174 = (float)(1.0 - v172) + (float)(1.0 - v172);
          }
          v175 = v168 / v380->m_fMassMultiplier;
          v176 = BYTE1(v380[6].m_vecCOM.z);
          v177 = &v380[5].m_vecAttachTiltOffset.z;
          LOBYTE(v380[6].m_vecCOM.z) = 0;
          v178 = (char *)&v380[5].m_vecTurnSpeed.y;
          BYTE1(v380[6].m_vecCOM.z) = 0;
          BYTE2(v380[6].m_vecCOM.z) = v176;
          v179 = &v380[5].m_transform.m_translate.x;
          v180 = (CVector *)&v380[5];
          v378 = &v380[5].m_transform.m_translate.y;
          v181 = 0;
          v182 = 0;
          v372 = (SurfaceInfos_c *)&v380[5].m_vecAttachTiltOffset.z;
          v4.n64_f32[0] = v170 * v171;
          v3.n64_f32[1] = 2.0 - v3.n64_f32[0];
          do
          {
            v183 = 4.0;
            if ( *(v177 - 8) >= 1.0 && (v183 = *v177 - v171, v183 <= 0.0) )
            {
              *v177 = 0.0;
            }
            else
            {
              *v177 = v183;
              z_low = LOBYTE(v380[6].m_vecCOM.z);
              LOBYTE(v380[6].m_vecCOM.z) = z_low + 1;
              if ( (v182 & 0xFFFE) == 2 )
                BYTE1(v380[6].m_vecCOM.z) = 1;
              if ( z_low )
              {
                v180->x = *(float *)&v178[v181] + v180->x;
                *v179 = *(float *)((char *)&v380[5].m_vecTurnSpeed.z + v181) + *v179;
                *v378 = *(float *)&v178[v181 + 8] + *v378;
              }
              else
              {
                v185 = *(_QWORD *)&v178[v181];
                v380[5].m_transform.m_translate.y = *(RwReal *)&v178[v181 + 8];
                *(_QWORD *)&v180->x = v185;
              }
            }
            v181 += 44;
            ++v177;
            ++v182;
          }
          while ( v181 != 176 );
          v4.n64_u32[1] = 1.0;
          if ( v361 )
            v3.n64_u32[1] = 1.0;
          v8 = (CBike *)v380;
          if ( LOBYTE(v380[6].m_vecCOM.z) )
          {
            v186 = 1.0 / (float)LOBYTE(v380[6].m_vecCOM.z);
            v187 = v186 * *v179;
            v188 = v186 * v180->x;
            v189 = v186 * *v378;
            v180->x = v188;
            *v179 = v187;
            *v378 = v189;
            v190 = v380->m_pMat;
            if ( (float)((float)((float)(v188 * v190->xz) + (float)(v187 * v190->yz)) + (float)(v189 * v190->zz)) < -0.5 )
            {
              v180->x = -v188;
              *v179 = -v187;
              *v378 = -v189;
            }
          }
          else
          {
            v380[5]._vptr$CPlaceable = 0;
            *v179 = 0.0;
            *v378 = 1.0;
            v190 = v380->m_pMat;
          }
          v191 = v375;
          v192 = *v375;
          v193 = *v368;
          m_vecPosition.x = 0.0;
          m_pLineArray = m_pColData->_anon_1.m_pLineArray;
          m_vecPosition.y = m_pLineArray->m_vecStart.y;
          v376 = v192 >= v193;
          m_vecPosition.z = (float)(m_pLineArray->m_vecStart.z - (float)(v191[v376] * *v360))
                          - (float)(*(float *)&v363[1].m_txdIndex * 0.5);
          Multiply3x3(&v.m_vecPosition, v190, &m_vecPosition);
          m_vecPosition = v.m_vecPosition;
          v195 = *v366;
          v196 = v369->x;
          v386.x = 0.0;
          v386.y = m_pColData->_anon_1.m_pLineArray[3].m_vecStart.y;
          v197 = 3;
          if ( v196 < v195 )
            v197 = 2;
          v198 = v197;
          v386.z = (float)(m_pColData->_anon_1.m_pLineArray[2].m_vecStart.z - (float)(v191[v197] * *v362))
                 - (float)(*(float *)&v363[1].m_n2dEffects * 0.5);
          Multiply3x3(&v.m_vecPosition, v380->m_pMat, &v386);
          v386 = v.m_vecPosition;
          v199 = v380[2].m_vecAttachTiltOffset.x;
          v200 = (unsigned __int8)v380->m_info;
          v201 = (float)((float)(*(float *)&v380[6].m_LastCollisionTime * 0.004) * *(float *)(LODWORD(v199) + 40))
               * 0.25;
          if ( v200 >= 8 && ((int)v380[4].m_pRealTimeShadow & 0x18) == 16 )
          {
            v1.n128_u32[0] = (unsigned __int32)v380[5].m_pLastRenderedLink;
            if ( v1.n128_f32[0] < 0.34907 )
            {
              v1.n128_f32[0] = v1.n128_f32[0] + (float)(CTimer::ms_fTimeStep * 0.02618);
              v380[5].m_pLastRenderedLink = (CLink<CEntity *> *)v1.n128_u32[0];
            }
            v202 = v376;
          }
          else if ( fabsf(v380->m_vecMoveSpeed.x) < 0.01
                 && fabsf(v380->m_vecMoveSpeed.y) < 0.01
                 && v380[3].m_vecDamageNormal.x == 0.0 )
          {
            v1.n128_f32[0] = powf(0.96, CTimer::ms_fTimeStep) * *(float *)&v380[5].m_pLastRenderedLink;
            v380[5].m_pLastRenderedLink = (CLink<CEntity *> *)v1.n128_u32[0];
            v202 = v376;
          }
          else
          {
            LODWORD(v5) = 1.0;
            if ( v387 <= 0.01 || v372->m_adhesiveLimitTable[0] <= 0.0 && v380[5].m_AttachQuat.imag.x <= 0.0 )
            {
              v1.n128_u64[0] = v5;
              v202 = v376;
            }
            else
            {
              v1.n128_u64[0] = v5;
              v202 = v376;
              if ( v200 <= 7 )
              {
                v.m_dataB.m_nSurfaceType = 1;
                v.m_dataA.m_nSurfaceType = 60;
                v203 = (char *)v380 + 44 * (__int16)v198;
                v204 = v201 * (float)(*(float *)(*(_DWORD *)&v380[5].RandomSeed + 32) * 4.0);
                v6.n64_f32[0] = SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, &v) * v204;
                if ( SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, (unsigned __int8)v203[1687]) == 3
                  || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, (unsigned __int8)v203[1687]) == 4 )
                {
                  v6.n64_f32[0] = v6.n64_f32[0] * *(float *)(*(_DWORD *)&v380[5].RandomSeed + 36);
                }
                v1.n128_f32[0] = v6.n64_f32[0] / (float)(v387 * v387);
                v6.n64_u32[0] = 1.0;
                v206.n64_u64[0] = vmin_f32((float32x2_t)v1.n128_u64[0], v6).n64_u64[0];
                v205 = asinf(v206.n64_f32[0]);
                v199 = v380[2].m_vecAttachTiltOffset.x;
                v206.n64_f32[0] = v205 / (float)((float)(*(float *)(LODWORD(v199) + 160) * 3.1416) / 180.0);
                v207 = v380[3].m_vecDamageNormal.x;
                if ( v207 >= 0.0 || *(float *)&v380[5].m_nScanCode >= 0.0 )
                {
                  if ( v207 > 0.0 && *(float *)&v380[5].m_nScanCode > 0.0 )
                    v206.n64_f32[0] = v206.n64_f32[0] + v206.n64_f32[0];
                }
                else
                {
                  v206.n64_f32[0] = v206.n64_f32[0] + v206.n64_f32[0];
                }
                v1.n128_u64[0] = vmin_f32(v206, v6).n64_u64[0];
                v200 = (unsigned __int8)v380->m_info;
              }
            }
            if ( v200 < 8 )
              LODWORD(v5) = v1.n128_u32[0];
            v1.n128_f32[0] = v380[3].m_vecDamageNormal.x * *(float *)&v5;
            v380[5].m_pLastRenderedLink = (CLink<CEntity *> *)v1.n128_u32[0];
          }
          v208 = *(_DWORD *)(LODWORD(v199) + 208);
          v209 = v198;
          v210 = v380->m_vecMoveSpeed.x;
          v211 = v380->m_vecMoveSpeed.y;
          v212 = v380->m_vecMoveSpeed.z;
          v374 = v208 & 0x800000;
          if ( (v208 & 0x800000) == 0 )
          {
            if ( v372->m_adhesiveLimitTable[0] <= 0.0 && v380[5].m_AttachQuat.imag.x <= 0.0 )
            {
              v223 = v380[6].m_transform.m_translate.x * 0.95;
              *(float *)&v224 = v223 + *(float *)&v380[5].m_pRealTimeShadow;
              v380[6].m_transform.m_translate.x = v223;
              v380[5].m_pRealTimeShadow = v224;
            }
            else
            {
              v213 = v380->m_pMat;
              vecRight.z = 0.0;
              vecRight.y = cosf(v1.n128_f32[0]);
              LODWORD(vecRight.x) = COERCE_UNSIGNED_INT(sinf(v1.n128_f32[0])) ^ 0x80000000;
              Multiply3x3(&v.m_vecPosition, v213, &vecRight);
              v214 = (char *)v380 + 44 * v202;
              vecForward = v.m_vecPosition;
              v215 = *((float *)v214 + 418);
              v216 = *((float *)v214 + 417);
              v217 = *((float *)v214 + 419);
              v1.n128_f32[1] = v.m_vecPosition.z * v217;
              v218 = (float)((float)(v.m_vecPosition.x * v216) + (float)(v.m_vecPosition.y * v215))
                   + (float)(v.m_vecPosition.z * v217);
              vecForward.x = v.m_vecPosition.x - (float)(v216 * v218);
              vecForward.y = v.m_vecPosition.y - (float)(v215 * v218);
              vecForward.z = v.m_vecPosition.z - (float)(v217 * v218);
              CVector::Normalise(&vecForward);
              CrossProduct(&v.m_vecPosition, &vecForward, (const CVector *)v214 + 139);
              vecRight = v.m_vecPosition;
              CVector::Normalise(&vecRight);
              if ( v365 == 1 )
                vecRight.z = 0.0;
              CBike::ProcessControl(void)::fThrust = 0.0;
              v214[1684] = 60;
              AdhesiveLimit = SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, (CColPoint *)(v214 + 1652));
              v202 = v376;
              if ( v380[6].m_vecTurnSpeed.z > 0.0 )
              {
                v4.n64_u32[1] = 1.0;
                if ( (unsigned int)(SurfaceInfos_c::GetAdhesionGroup(
                                      &g_surfaceInfos,
                                      *((unsigned __int8 *)&v380[5].m_vecMoveFriction.z + 44 * v376 + 3))
                                  - 1) < 3 )
                  v4.n64_u32[1] = 1060320051;
              }
              v220 = v201 * AdhesiveLimit;
              v209 = v198;
              if ( *(_BYTE *)&v380->m_info <= 7u )
                v220 = v220
                     * SurfaceInfos_c::GetWetMultiplier(
                         &g_surfaceInfos,
                         *((unsigned __int8 *)&v380[5].m_vecMoveFriction.z + 44 * v376 + 3));
              v221 = v380[5].m_nPhysicalFlags;
              CBike::ProcessControl(void)::WheelState[0] = (tWheelState)v380[6].m_pMovingListNode;
              CPhysical::GetSpeed(&v381, v380, m_vecPosition);
              if ( v221 == 1 )
                v220 = v220 * 0.4;
              v.m_vecPosition = v381;
              v222 = (CPhysical *)*((_DWORD *)&v380[6].m_vecTurnFriction.x + v376);
              if ( v222 )
              {
                CPhysical::GetSpeed(&v381, v222, *(CVector *)(&v380[6].m_vecAverageMoveSpeed.y + 3 * v376));
                v.m_vecPosition.x = v.m_vecPosition.x - v381.x;
                v.m_vecPosition.y = v.m_vecPosition.y - v381.y;
                v.m_vecPosition.z = v.m_vecPosition.z - v381.z;
              }
              CVehicle::ProcessBikeWheel(
                (CVehicle *)v380,
                &vecForward,
                &vecRight,
                &v.m_vecPosition,
                &m_vecPosition,
                2,
                CBike::ProcessControl(void)::fThrust,
                v4.n64_f32[0] * v173,
                v3.n64_f32[0] * v220,
                v4.n64_f32[1],
                0,
                &v380[6].m_transform.m_translate.x,
                CBike::ProcessControl(void)::WheelState,
                BIKE_WHEEL_F_STD,
                *(_BYTE *)&v380[5].m_nPhysicalFlags);
              if ( (v401[0] & 4) != 0 && (unsigned int)(CBike::ProcessControl(void)::WheelState[0] - 1) <= 1 )
                CBike::ProcessControl(void)::WheelState[0] = WS_ROLLING;
            }
          }
          if ( v380[5].m_AttachQuat.imag.y > 0.0 || v380[5].m_AttachQuat.imag.z > 0.0 )
          {
            v225 = v380->m_pMat;
            v226 = (const CVector *)((char *)v380 + 44 * v209);
            v227 = *(_QWORD *)&v225->xy;
            vecForward.z = v225->zy;
            *(_QWORD *)&vecForward.x = v227;
            v228 = *(_QWORD *)&v225->xx;
            vecRight.z = v225->zx;
            *(_QWORD *)&vecRight.x = v228;
            v229 = v226[139].y;
            v230 = v226[139].x;
            v231 = v226[139].z;
            v1.n128_f32[1] = vecForward.z * v231;
            v232 = (float)((float)(vecForward.x * v230) + (float)(vecForward.y * v229)) + (float)(vecForward.z * v231);
            vecForward.z = vecForward.z - (float)(v231 * v232);
            vecForward.y = vecForward.y - (float)(v229 * v232);
            vecForward.x = vecForward.x - (float)(v230 * v232);
            CVector::Normalise(&vecForward);
            CrossProduct(&v381, &vecForward, v226 + 139);
            vecRight = v381;
            CVector::Normalise(&vecRight);
            v233 = v365;
            v234 = (CColPoint *)&v226[137].z;
            if ( v365 == 1 )
              vecRight.z = 0.0;
            if ( (*(_BYTE *)v371 & 0x20) != 0 )
            {
              v4.n64_u32[1] = 1184645120;
              v380[6].m_vecTurnSpeed.y = 1.0;
              v237 = v201;
            }
            else if ( LOWORD(v380[6].m_vecTurnSpeed.x) )
            {
              v235 = &v380->m_pMat->xx;
              v236 = (float)(v380[3].m_vecDamageNormal.x * v380->m_fTurnMass) * -0.0007;
              vecSpeedb.x = (float)(*v235 * v236) * CTimer::ms_fTimeStep;
              vecSpeedb.y = (float)(v236 * v235[1]) * CTimer::ms_fTimeStep;
              vecSpeedb.z = (float)(v236 * v235[2]) * CTimer::ms_fTimeStep;
              CPhysical::ApplyTurnForce(v380, v390, vecSpeedb);
              v4.n64_u32[1] = 0;
              v237 = 0.0;
            }
            else
            {
              v4.n64_u32[1] = v4.n64_u32[0];
              v237 = v201;
              v249 = v380[6].m_vecTurnSpeed.y;
              if ( v249 < 1.0 )
              {
                v4.n64_u32[1] = v4.n64_u32[0];
                v237 = v201;
                if ( *v364 > 0.75 )
                {
                  v250 = &v380->m_pMat->xx;
                  v251 = (float)((float)((float)(1.0 - v249) * v380[3].m_vecDamageNormal.x) * v380->m_fTurnMass)
                       * -0.0007;
                  vecSpeedc.x = (float)(*v250 * v251) * CTimer::ms_fTimeStep;
                  vecSpeedc.y = (float)(v251 * v250[1]) * CTimer::ms_fTimeStep;
                  vecSpeedc.z = (float)(v251 * v250[2]) * CTimer::ms_fTimeStep;
                  CPhysical::ApplyTurnForce(v380, v390, vecSpeedc);
                  v237 = v201 * v249;
                  v4.n64_u32[1] = v4.n64_u32[0];
                }
              }
            }
            v238 = (char *)v380 + 44 * (__int16)v198;
            v239 = CBike::ProcessControl(void)::fThrust;
            CBike::ProcessControl(void)::fThrust = v175;
            v240 = v4.n64_u32[0];
            if ( v239 > 0.0 )
              v240 = 0;
            v238[1684] = 60;
            v6.n64_u32[1] = SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, v234);
            if ( v4.n64_f32[0] > 0.0 )
              v4.n64_u32[0] = v240;
            if ( v380[6].m_vecTurnSpeed.z <= 0.0 )
            {
              v241 = 1.0;
            }
            else
            {
              v241 = 1.0;
              if ( (unsigned int)(SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, (unsigned __int8)v238[1687]) - 1) < 3 )
                v241 = 0.7;
            }
            v242 = v237 * v6.n64_f32[1];
            v243 = v374;
            if ( *(_BYTE *)&v380->m_info <= 7u )
              v242 = v242
                   * SurfaceInfos_c::GetWetMultiplier(
                       &g_surfaceInfos,
                       *((unsigned __int8 *)&v380[5].m_vecMoveFriction.z + 44 * (__int16)v198 + 3));
            v244 = *((unsigned __int8 *)&v380[5].m_nPhysicalFlags + 1);
            CBike::ProcessControl(void)::WheelState[1] = *(tWheelState *)&v380[6].m_nNoOfStaticFrames;
            CPhysical::GetSpeed(&v381, v380, v386);
            if ( v244 == 1 )
              v242 = v242 * 0.4;
            v.m_vecPosition = v381;
            v245 = (CPhysical *)*((_DWORD *)&v380[6].m_vecTurnFriction.x + v198);
            if ( v245 )
            {
              CPhysical::GetSpeed(&v381, v245, *(CVector *)(&v380[6].m_vecAverageMoveSpeed.y + 3 * v198));
              v.m_vecPosition.x = v.m_vecPosition.x - v381.x;
              v.m_vecPosition.y = v.m_vecPosition.y - v381.y;
              v.m_vecPosition.z = v.m_vecPosition.z - v381.z;
            }
            CVehicle::ProcessBikeWheel(
              (CVehicle *)v380,
              &vecForward,
              &vecRight,
              &v.m_vecPosition,
              &v386,
              2,
              CBike::ProcessControl(void)::fThrust,
              v174 * v4.n64_f32[1],
              v3.n64_f32[1] * v242,
              v241,
              1,
              &v380[6].m_transform.m_translate.y,
              &CBike::ProcessControl(void)::WheelState[1],
              BIKE_WHEEL_R_STD,
              *((unsigned __int8 *)&v380[5].m_nPhysicalFlags + 1));
            if ( (v401[0] & 4) != 0 && (unsigned int)(CBike::ProcessControl(void)::WheelState[1] - 1) <= 1 )
              CBike::ProcessControl(void)::WheelState[1] = WS_ROLLING;
LABEL_295:
            if ( LOWORD(v380[6].m_vecTurnSpeed.x) && *(_DWORD *)&v380[6].m_nNoOfStaticFrames == 1 )
            {
              v252 = v380[6].m_vecTurnSpeed.y + (float)(CTimer::ms_fTimeStep * -0.002);
              v380[6].m_vecTurnSpeed.y = v252;
              if ( v252 < 0.0 )
                v380[6].m_vecTurnSpeed.y = 0.0;
              if ( !v243 )
                goto LABEL_321;
            }
            else
            {
              v253 = v380[6].m_vecTurnSpeed.y;
              if ( v253 < 1.0 )
                v380[6].m_vecTurnSpeed.y = v253 + (float)(CTimer::ms_fTimeStep * 0.005);
              if ( !v243 )
              {
LABEL_321:
                v267 = 0.0;
                *(_QWORD *)m_aGroundPhysicalPtrs = 0LL;
                *((_QWORD *)m_aGroundPhysicalPtrs + 1) = 0LL;
                v268 = v380[3].m_vecCOM.z;
                if ( v268 != 0.0 )
                {
                  v269 = RpAnimBlendClumpGetAssociation(*(RpClump_0 **)(LODWORD(v268) + 24), 0xC3u);
                  if ( v269 )
                    v267 = v269->m_fBlendAmount * 0.17453;
                }
                if ( v233 == 1 )
                {
                  v380[5]._vptr$CPlaceable = 0;
                  v380[5].m_transform.m_translate.x = 0.0;
                  *v378 = 1.0;
                  CrossProduct(&vecForward, (const CVector *)&v380->m_pMat->xy, v180);
                  CVector::Normalise(&vecForward);
                  CrossProduct(&vecRight, &vecForward, (const CVector *)&v380->m_pMat->xy);
                  v270 = *(_QWORD *)&vecRight.x;
                  v380[5].m_transform.m_translate.y = vecRight.z;
                  *(_QWORD *)&v180->x = v270;
                  CVector::Normalise(v180);
                }
                if ( (v401[0] & 2) == 0 && ((int)v380[4].m_pRealTimeShadow & 8) == 0 )
                {
                  if ( ((int)v380[4].m_pRealTimeShadow & 0x10) != 0 )
                  {
                    v275 = powf(0.97, CTimer::ms_fTimeStep);
                    p_m_pLod = (float *)&v380[5].m_pLod;
                    v276 = *(float *)&v380[5].m_pLod;
                    v272 = (float)(v275 * v276)
                         - (float)((float)(1.0 - v275) * (float)(v267 + (float)(asinf(v380->m_pMat->zx) + 0.2618)));
                  }
                  else
                  {
                    p_m_pLod = (float *)&v380[5].m_pLod;
                    v272 = powf(0.95, CTimer::ms_fTimeStep) * *(float *)&v380[5].m_pLod;
                  }
                  goto LABEL_349;
                }
                CrossProduct(&vecForward, (const CVector *)&v380->m_pMat->xy, v180);
                v273 = *(_QWORD *)&vecForward.x;
                v380[5].m_pMat = (CMatrix *)LODWORD(vecForward.z);
                *(_QWORD *)&v380[5].m_transform.m_translate.z = v273;
                CVector::Normalise((CVector *)&v380[5].m_transform.m_translate.z);
                if ( v380->m_pAttachToEntity )
                {
                  v1.n128_u32[2] = 0;
                }
                else
                {
                  if ( !LOBYTE(v380[6].m_vecCOM.z) )
                  {
                    v1.n128_f32[0] = CTimer::ms_fTimeStep;
                    v1.n128_f32[2] = CTimer::ms_fTimeStep
                                   * (float)((float)((float)(v380[3].m_vecDamageNormal.x
                                                           / (float)((float)(*(float *)(LODWORD(v380[2].m_vecAttachTiltOffset.x)
                                                                                      + 160)
                                                                           * 3.1416)
                                                                   / 180.0))
                                                   * -0.5)
                                           * 0.008);
                    goto LABEL_340;
                  }
                  if ( (*(_BYTE *)&v380->m_nPhysicalFlags & 4) != 0 )
                  {
                    v277 = *(float *)&v380[5].m_nFlags;
                    v278 = *(float *)&v380[5].m_pRwObject;
                    v1.n128_f32[0] = v212 - *(float *)&v380[5].m_nFlags.bdummy;
                    *(float *)&v380[5].m_nFlags.bdummy = v212;
                    v1.n128_f32[2] = v211 - v277;
                    *(float *)&v380[5].m_pRwObject = v210;
                    v274 = v210 - v278;
                    *(float *)&v380[5].m_nFlags = v211;
                  }
                  else
                  {
                    v274 = v380->m_vecMoveSpeed.x - v210;
                    v1.n128_f32[2] = v380->m_vecMoveSpeed.y - v211;
                    v1.n128_f32[0] = v380->m_vecMoveSpeed.z - v212;
                  }
                  v1.n128_f32[2] = (float)((float)(v274 * v380[5].m_transform.m_translate.z)
                                         + (float)(v1.n128_f32[2] * v380[5].m_transform.m_heading))
                                 + (float)(v1.n128_f32[0] * *(float *)&v380[5].m_pMat);
                }
                v1.n128_f32[0] = CTimer::ms_fTimeStep;
LABEL_340:
                v2.n128_u32[2] = 1008981770;
                v279 = *(_DWORD *)&v380[5].RandomSeed;
                v280 = v1.n128_f32[2]
                     / (float)(vmax_f32((float32x2_t)v1.n128_u64[0], *(float32x2_t *)&v2.n128_i8[8]).n64_f32[0] * 0.008);
                v281 = *(float *)(v279 + 20);
                if ( v380[5].m_nPhysicalFlags == 1 )
                {
                  v282 = v281 * 0.4;
                  if ( v280 <= (float)(v281 * 0.4) )
                  {
                    v283 = v281 * -0.4;
                    goto LABEL_346;
                  }
                }
                else
                {
                  if ( v280 <= v281 )
                  {
                    v283 = -v281;
LABEL_346:
                    v282 = v280;
                    if ( v280 < v283 )
                      v282 = v283;
                    goto LABEL_348;
                  }
                  v282 = *(float *)(v279 + 20);
                }
LABEL_348:
                v284 = powf(*(float *)(v279 + 28), v1.n128_f32[0]);
                v285 = v282;
                p_m_pLod = (float *)&v380[5].m_pLod;
                v286 = *(float *)&v380[5].m_pLod;
                v272 = (float)(v284 * v286) + (float)((float)(1.0 - v284) * (float)(asinf(v285) - v267));
LABEL_349:
                *p_m_pLod = v272;
                *(float *)&v380[5].m_nScanCode = v272;
                v287 = CBike::ProcessControl(void)::WheelState[1];
                v47 = CBike::ProcessControl(void)::WheelState[1] == WS_SPINNING;
                v288 = (unsigned __int8)v380->m_info;
                *(_QWORD *)&v380[6].m_pMovingListNode = *(_QWORD *)CBike::ProcessControl(void)::WheelState;
                v289 = v287;
                if ( v47 )
                  v289 = WS_ROLLING;
                if ( *v364 >= 0.0 )
                  v289 = v287;
                *(_DWORD *)&v380[6].m_nNoOfStaticFrames = v289;
                if ( v288 > 7 )
                {
                  m_pLod = v380[4].m_pLod;
                  if ( m_pLod )
                    v380[4].m_pLod = (CEntity *)((char *)m_pLod - 1);
                }
                else
                {
                  CVehicle::ProcessSirenAndHorn((CVehicle *)v380, 1);
                }
                goto LABEL_357;
              }
            }
            if ( v372->m_adhesiveLimitTable[0] <= 0.0 && v380[5].m_AttachQuat.imag.x <= 0.0 )
            {
              v266 = v380[6].m_transform.m_translate.x * 0.95;
              v380[6].m_transform.m_translate.x = v266;
              *(float *)&v380[5].m_pRealTimeShadow = *(float *)&v380[5].m_pRealTimeShadow
                                                   + (float)(v266 * CTimer::ms_fTimeStep);
            }
            else
            {
              v254 = *(float *)&v380[5].m_pLastRenderedLink;
              v255 = cosf(v254);
              v256 = v380->m_pMat;
              v381.y = v255;
              LODWORD(v381.x) = COERCE_UNSIGNED_INT(sinf(v254)) ^ 0x80000000;
              v381.z = 0.0;
              Multiply3x3(&vecRight, v256, &v381);
              v257 = (char *)v380 + 44 * v202;
              vecForward = vecRight;
              v258 = *((float *)v257 + 418);
              v259 = *((float *)v257 + 417);
              v260 = *((float *)v257 + 419);
              v1.n128_f32[1] = vecRight.z * v260;
              v261 = (float)((float)(vecRight.x * v259) + (float)(vecRight.y * v258)) + (float)(vecRight.z * v260);
              vecForward.x = vecRight.x - (float)(v259 * v261);
              vecForward.y = vecRight.y - (float)(v258 * v261);
              vecForward.z = vecRight.z - (float)(v260 * v261);
              CVector::Normalise(&vecForward);
              CrossProduct(&v381, &vecForward, (const CVector *)v257 + 139);
              vecRight = v381;
              CVector::Normalise(&vecRight);
              CBike::ProcessControl(void)::fThrust = 0.0;
              v257[1684] = 60;
              v3.n64_u32[1] = SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, (CColPoint *)(v257 + 1652));
              if ( v380[6].m_vecTurnSpeed.z <= 0.0 )
              {
                v262 = 1.0;
              }
              else
              {
                v262 = 1.0;
                if ( (unsigned int)(SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, (unsigned __int8)v257[1687]) - 1) < 3 )
                  v262 = 0.7;
              }
              v263 = v201 * v3.n64_f32[1];
              v233 = v365;
              if ( *(_BYTE *)&v380->m_info <= 7u )
                v263 = v263
                     * SurfaceInfos_c::GetWetMultiplier(
                         &g_surfaceInfos,
                         *((unsigned __int8 *)&v380[5].m_vecMoveFriction.z + 44 * v376 + 3));
              v264 = v380[5].m_nPhysicalFlags;
              CBike::ProcessControl(void)::WheelState[0] = (tWheelState)v380[6].m_pMovingListNode;
              CPhysical::GetSpeed(&v381, v380, m_vecPosition);
              if ( v264 == 1 )
                v263 = v263 * 0.4;
              v.m_vecPosition = v381;
              v265 = (CPhysical *)*((_DWORD *)&v380[6].m_vecTurnFriction.x + v376);
              if ( v265 )
              {
                CPhysical::GetSpeed(&v381, v265, *(CVector *)(&v380[6].m_vecAverageMoveSpeed.y + 3 * v376));
                v.m_vecPosition.x = v.m_vecPosition.x - v381.x;
                v.m_vecPosition.y = v.m_vecPosition.y - v381.y;
                v.m_vecPosition.z = v.m_vecPosition.z - v381.z;
              }
              CVehicle::ProcessBikeWheel(
                (CVehicle *)v380,
                &vecForward,
                &vecRight,
                &v.m_vecPosition,
                &m_vecPosition,
                2,
                CBike::ProcessControl(void)::fThrust,
                v173 * v4.n64_f32[0],
                v3.n64_f32[0] * v263,
                v262,
                0,
                &v380[6].m_transform.m_translate.x,
                CBike::ProcessControl(void)::WheelState,
                BIKE_WHEEL_F_STD,
                *(_BYTE *)&v380[5].m_nPhysicalFlags);
              if ( (v401[0] & 4) != 0 && (unsigned int)(CBike::ProcessControl(void)::WheelState[0] - 1) <= 1 )
                CBike::ProcessControl(void)::WheelState[0] = WS_ROLLING;
            }
            goto LABEL_321;
          }
          if ( (*(_BYTE *)v371 & 0x20) != 0 )
          {
            v247 = 0.0;
            v380[6].m_transform.m_translate.y = 0.0;
          }
          else
          {
            v246 = &v380[6].m_transform.m_translate.y;
            if ( v175 != 0.0 )
            {
              v243 = v374;
              v247 = *v246;
              if ( v175 <= 0.0 )
              {
                v233 = v365;
                if ( v247 > -1.0 )
                {
                  v248 = 0.05;
                  goto LABEL_433;
                }
              }
              else
              {
                v233 = v365;
                if ( v247 < 1.0 )
                {
                  v248 = -0.1;
LABEL_433:
                  v247 = v247 + v248;
                  *v246 = v247;
                }
              }
LABEL_294:
              *(float *)&v380[6]._vptr$CPlaceable = *(float *)&v380[6]._vptr$CPlaceable
                                                  + (float)(v247 * CTimer::ms_fTimeStep);
              goto LABEL_295;
            }
            v247 = *v246;
          }
          v233 = v365;
          v243 = v374;
          goto LABEL_294;
        }
        if ( (*(_BYTE *)&v8->m_nBikeFlags & 8) != 0 )
        {
LABEL_60:
          v46 = 0;
          goto LABEL_71;
        }
        v48 = 0;
        v1.n128_u32[0] = LODWORD(v8->m_vecMoveSpeed.x);
        if ( (*(_DWORD *)p_m_nVehicleFlags & 0x1000000) == 0 && v1.n128_f32[0] == 0.0 )
          v48 = v8->m_vecMoveSpeed.y == 0.0 && v8->m_vecMoveSpeed.z == 0.0 && v8->m_aRatioHistory[3] != 1.0;
        v49.n128_u64[0] = 0x3F0000003F000000LL;
        v49.n128_u64[1] = 0x3F0000003F000000LL;
        v1.n128_u32[1] = LODWORD(v8->m_vecMoveSpeed.y);
        v1.n128_u64[1] = *(_QWORD *)&v8->m_vecMoveSpeed.z;
        v50 = m_info & 0xF8;
        v51 = (float *)&loc_562778;
        v52 = vaddq_f32(*(float32x4_t *)&v8->m_vecAverageMoveSpeed.x, v1);
        if ( v50 == 40 )
          v51 = (float *)&loc_56277C;
        v53 = *v51;
        v2 = vmulq_f32(v52, v49);
        v1.n128_f32[2] = (float)(v8->m_vecAverageTurnSpeed.y + v8->m_vecTurnSpeed.y) * 0.5;
        v1.n128_f32[0] = (float)(v8->m_vecAverageTurnSpeed.z + v8->m_vecTurnSpeed.z) * 0.5;
        *(float32x4_t *)&v8->m_vecAverageMoveSpeed.x = v2;
        v54 = (float *)&loc_562780;
        v1.n128_f32[1] = v2.n128_f32[2] * v2.n128_f32[2];
        LODWORD(v8->m_vecAverageTurnSpeed.y) = v1.n128_u32[2];
        v8->m_vecAverageTurnSpeed.z = v1.n128_f32[0];
        if ( v50 == 40 )
          v54 = (float *)&loc_562784;
        if ( (float)((float)((float)(v2.n128_f32[0] * v2.n128_f32[0]) + (float)(v2.n128_f32[1] * v2.n128_f32[1]))
                   + v1.n128_f32[1]) > (float)((float)(v53 * CTimer::ms_fTimeStep) * (float)(v53 * CTimer::ms_fTimeStep)) )
          goto LABEL_55;
        v1.n128_f32[2] = v1.n128_f32[2] * v1.n128_f32[2];
        v55 = (float *)&loc_562788;
        if ( v50 == 40 )
          v55 = (float *)&loc_56278C;
        if ( (float)((float)((float)(v2.n128_f32[3] * v2.n128_f32[3]) + v1.n128_f32[2])
                   + (float)(v1.n128_f32[0] * v1.n128_f32[0])) <= (float)((float)(*v55 * CTimer::ms_fTimeStep)
                                                                        * (float)(*v55 * CTimer::ms_fTimeStep)) )
        {
          v59 = 0;
          v46 = 0;
          if ( v8->m_fTrueDistanceTravelled < *v54 )
            v59 = 1;
          if ( v59 | v48 )
          {
            p_m_nNoOfStaticFrames = &v8->m_nNoOfStaticFrames;
            v60 = v8->m_nNoOfStaticFrames + 1;
            v8->m_nNoOfStaticFrames = v60;
            if ( v60 <= 0xAu && !v48 )
              goto LABEL_71;
LABEL_57:
            v57 = v8->m_pMat;
            v58 = &v57->tx;
            if ( !v57 )
              v58 = &v8->m_transform.m_translate.x;
            if ( !CCarCtrl::MapCouldMoveInThisArea(*v58, v58[1]) )
            {
              if ( !v48 || *p_m_nNoOfStaticFrames >= 0xBu )
                *p_m_nNoOfStaticFrames = 10;
              v8->m_vecMoveSpeed.x = 0.0;
              v46 = 1;
              *(_QWORD *)&v8->m_vecMoveSpeed.y = 0LL;
              *(_QWORD *)&v8->m_vecTurnSpeed.x = 0LL;
              v8->m_vecTurnSpeed.z = 0.0;
              goto LABEL_71;
            }
            goto LABEL_60;
          }
        }
        else
        {
LABEL_55:
          if ( v48 )
          {
            p_m_nNoOfStaticFrames = &v8->m_nNoOfStaticFrames;
            ++v8->m_nNoOfStaticFrames;
            goto LABEL_57;
          }
        }
        v46 = 0;
        v8->m_nNoOfStaticFrames = 0;
        goto LABEL_71;
      }
      v25 = 88.0;
      v1.n128_u32[0] = LODWORD(v8->m_pMat->zy);
      if ( v1.n128_f32[0] <= 0.0 )
        goto LABEL_34;
      v2.n128_u32[2] = 1028443341;
      v1.n128_f32[0] = (float)(FatAndMuscleModifier * 0.2)
                     * fabsf(v8->pBikeHandling->fWheelieBalancePoint - v1.n128_f32[0]);
      v1.n128_u64[0] = vmin_f32((float32x2_t)v1.n128_u64[0], *(float32x2_t *)&v2.n128_i8[8]).n64_u64[0];
      v1.n128_f32[0] = x - v1.n128_f32[0];
    }
    else
    {
      if ( v8->m_aWheelCounts[2] > 0.0
        || v8->m_aWheelCounts[3] > 0.0
        || (v26 = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_BALANCE_DAMPING),
            v27 = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_BALANCE_DAMPING),
            v25 = 88.0,
            v1.n128_u32[0] = LODWORD(v8->m_pMat->zy),
            v1.n128_f32[0] >= 0.0) )
      {
        v28 = x;
        goto LABEL_34;
      }
      v1.n128_f32[2] = v26 * 0.075;
      v1.n128_f32[0] = (float)(v27 * 0.25) * fabsf(v8->pBikeHandling->fStoppieBalancePoint - v1.n128_f32[0]);
      v1.n128_u64[0] = vmin_f32(*(float32x2_t *)&v1.n128_i8[8], (float32x2_t)v1.n128_u64[0]).n64_u64[0];
      v1.n128_f32[0] = (float)(v1.n128_f32[0] + 0.9) * x;
    }
    v28 = v1.n128_f32[0];
    goto LABEL_34;
  }
}
// 561C8A: variable 'v1' is possibly undefined
// 561D20: variable 'v2' is possibly undefined
// 562FD8: variable 'v5' is possibly undefined
// 563060: variable 'v6' is possibly undefined
// 56415E: variable 'v7' is possibly undefined
// 564582: variable 'v4' is possibly undefined
// 564684: variable 'v3' is possibly undefined
// 561A90: using guessed type int var_64[25];
// 561A90: using guessed type CVector var_D8[4];

//----- (00564A64) --------------------------------------------------------
bool __fastcall CBike::ProcessAI(CBike *this, uint32 *nProcContFlags)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d5
  __int16 v8; // r2
  CBaseModelInfo *v9; // r6
  int RecordingNumber; // r0
  bool result; // r0
  CBike::CBikeFlags m_nBikeFlags; // r2
  int v13; // r1
  int v14; // r0
  CBike::CBikeFlags v15; // r0
  tHandlingData *pHandling; // r0
  float v17; // s0
  UInt8 m_nDriveWheelsOnGround; // r2
  float v19; // s18
  float v20; // s16
  float v21; // r0
  int v22; // r1
  UInt32 m_cHorn; // r0
  int m_nVehicleFlags; // r1
  float v25; // s0
  float z; // s4
  float v27; // s2
  int v28; // r0
  int v29; // r1
  int v30; // r1
  CBike::CBikeFlags v31; // r0
  float *p_m_fBrakePedal; // r0
  unsigned int v33; // r0
  CPed *pDriver; // r0
  unsigned int m_nPedType; // r0
  tBikeHandlingData *pBikeHandling; // r0
  float m_fLeanFwd; // s0
  float y; // s2
  float m_fBrakePedal; // s4
  float v40; // s2
  float v41; // s16
  float FatAndMuscleModifier; // r0
  CBike::CBikeFlags *p_m_nBikeFlags; // r2
  CPed *v44; // r2
  bool v45; // zf
  RwReal v46; // s4
  float v47; // s4
  float v48; // s0
  CMatrix *m_pMat; // r0
  float v50; // s0
  CPad *Pad; // r0
  CVector v52; // [sp+0h] [bp-30h]
  CVector v53; // 0:r1.12

  v8 = *(_WORD *)((char *)&this->AutoPilot + 75);
  v9 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  RecordingNumber = this->AutoPilot.RecordingNumber;
  *(_WORD *)((char *)&this->AutoPilot + 75) = v8 & 0xFFFC;
  if ( RecordingNumber < 0 || CVehicleRecording::bUseCarAI[RecordingNumber] )
  {
    result = 1;
    switch ( *(_BYTE *)&this->m_info >> 3 )
    {
      case 0:
        *nProcContFlags += 2;
        *(_BYTE *)&this->m_nBikeFlags &= ~8u;
        if ( FindPlayerPed(-1)->m_nPedState == PED_EXIT_CAR || FindPlayerPed(-1)->m_nPedState == PED_DRAGGED_FROM_CAR )
          goto LABEL_55;
        pDriver = this->pDriver;
        if ( pDriver )
        {
          m_nPedType = pDriver->m_nPedType;
          if ( m_nPedType <= 1 )
            (*((void (__fastcall **)(CBike *, _DWORD))this->_vptr$CPlaceable + 25))(this, (unsigned __int8)m_nPedType);
        }
        pBikeHandling = this->pBikeHandling;
        m_fLeanFwd = this->RideAnimData.m_fLeanFwd;
        y = this->pHandling->CentreOfMass.y;
        if ( m_fLeanFwd >= 0.0 )
        {
          v46 = y + (float)(m_fLeanFwd * pBikeHandling->fLeanFwdCOMMult);
          v2.n64_u32[0] = LODWORD(this->m_fBrakePedal);
          this->m_vecCOM.y = v46;
          if ( v2.n64_f32[0] >= 0.0 && this->nNoOfContactWheels )
            goto LABEL_52;
          v4.n64_u32[0] = 1036831949;
          v3.n64_f32[0] = sqrtf(
                            (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                  + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                          + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
          v47 = vmin_f32(v3, v4).n64_f32[0];
          v4.n64_f32[0] = v47 / 0.1;
          v41 = (float)((float)((float)(m_fLeanFwd * this->m_fTurnMass) * pBikeHandling->fLeanFwdForceMult) * v47)
              * (float)((float)(v2.n64_f32[0] * 0.5) + (float)(vmax_f32(v4, v2).n64_f32[0] * 0.5));
          FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_WHEELIE_MULT);
        }
        else
        {
          m_fBrakePedal = this->m_fBrakePedal;
          this->m_vecCOM.y = y + (float)(m_fLeanFwd * pBikeHandling->fLeanBakCOMMult);
          if ( (m_fBrakePedal != 0.0 || (*(_BYTE *)&this->m_nVehicleFlags & 0x20) != 0) && this->nNoOfContactWheels )
            goto LABEL_52;
          v5.n64_u32[0] = LODWORD(this->m_fGasPedal);
          v3.n64_u32[0] = 1036831949;
          v2.n64_f32[0] = sqrtf(
                            (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                  + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                          + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
          v40 = vmin_f32(v2, v3).n64_f32[0];
          v3.n64_f32[0] = v40 / 0.1;
          v41 = (float)((float)((float)(m_fLeanFwd * this->m_fTurnMass) * pBikeHandling->fLeanBakForceMult) * v40)
              * (float)((float)(v5.n64_f32[0] * 0.5) + (float)(vmax_f32(v3, v5).n64_f32[0] * 0.5));
          FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BIKE_WHEELIE_MULT);
        }
        v48 = FatAndMuscleModifier;
        m_pMat = this->m_pMat;
        v50 = CTimer::ms_fTimeStep * (float)(v48 * v41);
        v53.x = -(float)(v50 * m_pMat->xz);
        v53.y = -(float)(v50 * m_pMat->yz);
        v53.z = -(float)(v50 * m_pMat->zz);
        v52.x = this->m_vecCOM.x + m_pMat->xy;
        v52.y = this->m_vecCOM.y + m_pMat->yy;
        v52.z = this->m_vecCOM.z + m_pMat->zy;
        CPhysical::ApplyTurnForce(this, v53, v52);
LABEL_52:
        CEntity::PruneReferences(this);
        if ( *(_BYTE *)&this->m_info <= 7u )
          CVehicle::DoDriveByShootings(this);
        CBike::DoSoftGroundResistance(this, nProcContFlags);
LABEL_55:
        if ( (unsigned __int8)((*((_BYTE *)&this->CVehicle + 1202) & 7) - 1) <= 1u )
        {
          Pad = CPad::GetPad(0);
          if ( CPad::UseBomb(Pad) )
            CVehicle::ActivateBomb(this);
        }
        return 1;
      case 1:
        *nProcContFlags += 2;
        return 1;
      case 2:
        CCarAI::UpdateCarAI(this);
        CPhysical::ProcessControl(this);
        CCarCtrl::UpdateCarOnRails(this);
        pHandling = this->pHandling;
        v17 = this->AutoPilot.ActualSpeed / 50.0;
        m_nDriveWheelsOnGround = this->m_nDriveWheelsOnGround;
        this->nNoOfContactWheels = 2;
        this->m_nDriveWheelsOnGround = 2;
        this->m_nDriveWheelsOnGroundLastFrame = m_nDriveWheelsOnGround;
        cTransmission::CalculateGearForSimpleCar(&pHandling->Transmission, v17, &this->m_nCurrentGear);
        v19 = CTimer::ms_fTimeStep;
        this->m_aWheelPitchAngles[0] = this->m_aWheelPitchAngles[0]
                                     + (float)(v19
                                             * CVehicle::ProcessWheelRotation(
                                                 this,
                                                 WS_ROLLING,
                                                 (const CVector *)&this->m_pMat->xy,
                                                 &this->m_vecMoveSpeed,
                                                 *(float *)&v9[1].m_txdIndex * 0.5));
        v20 = CTimer::ms_fTimeStep;
        v21 = CVehicle::ProcessWheelRotation(
                this,
                WS_ROLLING,
                (const CVector *)&this->m_pMat->xy,
                &this->m_vecMoveSpeed,
                *(float *)&v9[1].m_n2dEffects * 0.5);
        v22 = *((unsigned __int8 *)&this->AutoPilot + 75);
        this->m_aWheelPitchAngles[1] = this->m_aWheelPitchAngles[1] + (float)(v20 * v21);
        if ( v22 << 30 )
          (*((void (__fastcall **)(CBike *))this->_vptr$CPlaceable + 55))(this);
        m_cHorn = this->m_cHorn;
        if ( m_cHorn )
          this->m_cHorn = m_cHorn - 1;
        m_nVehicleFlags = (int)this->m_nVehicleFlags;
        *(_BYTE *)&this->m_nBikeFlags &= ~0x80u;
        *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags & 0xDEFFFFFF;
        return 1;
      case 3:
      case 0xC:
        CCarAI::UpdateCarAI(this);
        CCarCtrl::SteerAICarWithPhysics(this);
        if ( *((unsigned __int8 *)&this->AutoPilot + 75) << 30 )
          (*((void (__fastcall **)(CBike *))this->_vptr$CPlaceable + 55))(this);
        *nProcContFlags += 2;
        m_nBikeFlags = this->m_nBikeFlags;
        v13 = (int)this->m_nVehicleFlags;
        v14 = *((_DWORD *)&this->m_nVehicleFlags + 1);
        this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags & 0x7F);
        if ( (v13 & 0x80000) != 0 )
        {
          this->m_fGasPedal = 0.0;
          this->m_fBrakePedal = 1.0;
          *(_DWORD *)&this->m_nVehicleFlags = v13 | 0x20;
          *((_DWORD *)&this->m_nVehicleFlags + 1) = v14;
        }
        else
        {
          v15 = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags & 0x77);
LABEL_39:
          this->m_nBikeFlags = v15;
        }
        return 1;
      case 4:
        v25 = this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x;
        z = this->m_vecMoveSpeed.z;
        v27 = this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y;
        this->m_fBrakePedal = 0.0;
        if ( (float)((float)(v25 + v27) + (float)(z * z)) < 0.01 || (*(_BYTE *)&this->m_nBikeFlags & 0x10) != 0 )
        {
          v28 = *((_DWORD *)&this->m_nVehicleFlags + 1);
          v29 = *(_DWORD *)&this->m_nVehicleFlags | 0x20;
        }
        else
        {
          v28 = *((_DWORD *)&this->m_nVehicleFlags + 1);
          v29 = *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFFFDF;
        }
        *(_DWORD *)&this->m_nVehicleFlags = v29;
        this->m_cHorn = 0;
        this->m_fGasPedal = 0.0;
        if ( this->pDriver )
          goto LABEL_34;
        v44 = this->pPassengers[0];
        v45 = v44 == 0;
        if ( !v44 )
          v45 = (v29 & 0x80000) == 0;
        if ( v45 )
        {
          p_m_nBikeFlags = &this->m_nBikeFlags;
        }
        else
        {
LABEL_34:
          p_m_nBikeFlags = &this->m_nBikeFlags;
          if ( (*(_BYTE *)&this->m_nBikeFlags & 0x10) == 0 )
          {
            *nProcContFlags += 2;
            v29 = (int)this->m_nVehicleFlags;
            v28 = *((_DWORD *)&this->m_nVehicleFlags + 1);
          }
        }
        this->RideAnimData.m_fAnimLeanLeft = 0.0;
        this->RideAnimData.m_fAnimLeanFwd = 0.0;
        *(_BYTE *)p_m_nBikeFlags &= ~0x80u;
        if ( (v29 & 0x80000) != 0 )
        {
          this->m_fGasPedal = 0.0;
          this->m_fBrakePedal = 1.0;
          *(_DWORD *)&this->m_nVehicleFlags = v29 | 0x20;
          *((_DWORD *)&this->m_nVehicleFlags + 1) = v28;
        }
        return 1;
      case 5:
        v30 = (int)this->m_nVehicleFlags;
        this->m_fSteerAngle = 0.0;
        this->m_fGasPedal = 0.0;
        this->m_fBrakePedal = 0.05;
        this->m_cHorn = 0;
        v31 = this->m_nBikeFlags;
        this->RideAnimData.m_fAnimLeanLeft = 0.0;
        this->RideAnimData.m_fAnimLeanFwd = 0.0;
        *(_DWORD *)&this->m_nVehicleFlags = v30 | 0x20;
        goto LABEL_38;
      case 9:
        p_m_fBrakePedal = &this->m_fBrakePedal;
        if ( (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                           + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                   + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) >= 0.01 )
        {
          *p_m_fBrakePedal = 0.0;
          v33 = *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFFFDF;
        }
        else
        {
          *p_m_fBrakePedal = 1.0;
          v33 = *(_DWORD *)&this->m_nVehicleFlags | 0x20;
        }
        *(_DWORD *)&this->m_nVehicleFlags = v33;
        this->m_fGasPedal = 0.0;
        this->m_fSteerAngle = 0.0;
        this->m_cHorn = 0;
        *nProcContFlags += 2;
        v31 = this->m_nBikeFlags;
LABEL_38:
        v15 = (CBike::CBikeFlags)(*(_BYTE *)&v31 & 0x7F);
        goto LABEL_39;
      default:
        return result;
    }
  }
  *nProcContFlags += 2;
  return 0;
}
// 564DD6: variable 'v2' is possibly undefined
// 564DD6: variable 'v3' is possibly undefined
// 564DE2: variable 'v5' is possibly undefined
// 564F4C: variable 'v4' is possibly undefined

//----- (00565044) --------------------------------------------------------
void __fastcall CBike::DoSoftGroundResistance(CBike *this, uint32 *nProcContFlags)
{
  float *m_aWheelRatios; // r6
  CMatrix *m_pMat; // r0
  float x; // s4
  float y; // s2
  float xz; // s6
  float yz; // s8
  float z; // s0
  float zz; // s10
  float v12; // s12
  float v13; // s0
  float v14; // s2
  float v15; // s4
  float xy; // s6
  float yy; // s8
  float zy; // s10
  float v19; // s12
  float v20; // s6
  CMatrix *v21; // r0
  float v22; // s0
  float v23; // s2
  float v24; // s6
  float v25; // s8
  float v26; // s10
  float v27; // s4
  float v28; // s12
  float v29; // s6
  float v30; // s8
  float v31; // s10
  float v32; // s12
  CVector v33; // 0:r1.12

  m_aWheelRatios = this->m_aWheelRatios;
  if ( this->m_aWheelRatios[0] < 1.0
    && SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[0].m_dataB.m_nSurfaceType) == 4
    || this->m_aWheelRatios[1] < 1.0
    && SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[1].m_dataB.m_nSurfaceType) == 4
    || this->m_aWheelRatios[2] < 1.0
    && SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[2].m_dataB.m_nSurfaceType) == 4
    || this->m_aWheelRatios[3] < 1.0
    && SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[3].m_dataB.m_nSurfaceType) == 4 )
  {
    m_pMat = this->m_pMat;
    x = this->m_vecMoveSpeed.x;
    y = this->m_vecMoveSpeed.y;
    xz = m_pMat->xz;
    yz = m_pMat->yz;
    z = this->m_vecMoveSpeed.z;
    zz = m_pMat->zz;
    v12 = (float)((float)(x * xz) + (float)(y * yz)) + (float)(z * zz);
    v13 = z - (float)(zz * v12);
    v14 = y - (float)(yz * v12);
    v15 = x - (float)(xz * v12);
    if ( this->m_fGasPedal > 0.3 )
    {
      if ( (float)((float)(v13 * v13) + (float)((float)(v15 * v15) + (float)(v14 * v14))) < 0.09 )
      {
        *nProcContFlags += 4;
        m_pMat = this->m_pMat;
      }
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      zy = m_pMat->zy;
      v19 = (float)((float)(v15 * xy) + (float)(v14 * yy)) + (float)(v13 * zy);
      v13 = v13 - (float)(zy * v19);
      v14 = v14 - (float)(yy * v19);
      v15 = v15 - (float)(xy * v19);
    }
    v20 = (float)(this->m_fMass * -0.02) * CTimer::ms_fTimeStep;
    v33.x = v15 * v20;
    v33.y = v14 * v20;
    v33.z = v13 * v20;
    goto LABEL_23;
  }
  if ( *m_aWheelRatios < 1.0 && this->m_aWheelColPoints[0].m_dataB.m_nSurfaceType == 178
    || this->m_aWheelRatios[1] < 1.0 && this->m_aWheelColPoints[1].m_dataB.m_nSurfaceType == 178
    || this->m_aWheelRatios[2] < 1.0 && this->m_aWheelColPoints[2].m_dataB.m_nSurfaceType == 178
    || this->m_aWheelRatios[3] < 1.0 && this->m_aWheelColPoints[3].m_dataB.m_nSurfaceType == 178 )
  {
    v21 = this->m_pMat;
    v22 = this->m_vecMoveSpeed.x;
    v23 = this->m_vecMoveSpeed.y;
    v24 = v21->xz;
    v25 = v21->yz;
    v26 = v21->zz;
    v27 = this->m_vecMoveSpeed.z;
    v28 = (float)((float)(v22 * v24) + (float)(v23 * v25)) + (float)(v27 * v26);
    v29 = v24 * v28;
    v30 = v25 * v28;
    v31 = v26 * v28;
    v32 = (float)(CVehicle::ms_fRailTrackResistance * this->m_fMass) * CTimer::ms_fTimeStep;
    v33.x = -(float)(v32 * (float)(v22 - v29));
    v33.y = -(float)(v32 * (float)(v23 - v30));
    v33.z = -(float)(v32 * (float)(v27 - v31));
LABEL_23:
    sub_1932F0(this, v33);
  }
}

//----- (005652FC) --------------------------------------------------------
void __fastcall CBike::PlayHornIfNecessary(CBike *this)
{
  if ( *((unsigned __int8 *)&this->AutoPilot + 75) << 30 )
    (*((void (__fastcall **)(CBike *))this->_vptr$CPlaceable + 55))(this);
}

//----- (0056530E) --------------------------------------------------------
void __fastcall CBike::ProcessControlCollisionCheck(CBike *this, bool bDoMovement)
{
  _BOOL4 v3; // r5
  CEntity::CFlags *p_m_nFlags; // r8
  __int64 v5; // d16
  __int64 v6; // d17
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  int v8; // r6
  int v9; // r5
  CMatrix v10; // [sp+0h] [bp-58h] BYREF

  v3 = bDoMovement;
  CMatrix::CMatrix(&v10, this->m_pMat);
  p_m_nFlags = &this->m_nFlags;
  *(_DWORD *)&this->m_nFlags &= ~0x10u;
  CPhysical::SkipPhysics(this);
  *(float *)&v5 = 1.0;
  *((float *)&v5 + 1) = 1.0;
  *(float *)&v6 = 1.0;
  *((float *)&v6 + 1) = 1.0;
  *(_QWORD *)this->m_aWheelRatios = v5;
  *(_QWORD *)&this->m_aWheelRatios[2] = v6;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  this->m_fTrueDistanceTravelled = 0.0;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xFFFF6FFF);
  if ( v3 )
  {
    CPhysical::ApplyMoveSpeed(this);
    CPhysical::ApplyTurnSpeed(this);
    if ( CPhysical::CheckCollision(this) )
    {
      v8 = 0;
      do
      {
        CMatrix::operator=(this->m_pMat, &v10);
        CPhysical::ApplyMoveSpeed(this);
        CPhysical::ApplyTurnSpeed(this);
        if ( !CPhysical::CheckCollision(this) )
          break;
        ++v8;
      }
      while ( (unsigned __int16)v8 < 5u );
    }
  }
  else
  {
    v9 = *(_DWORD *)p_m_nFlags;
    *(_DWORD *)p_m_nFlags &= ~1u;
    CPhysical::CheckCollision(this);
    *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFFE | v9 & 1;
  }
  *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFCF | 0x20;
  CMatrix::~CMatrix(&v10);
}

//----- (005653D4) --------------------------------------------------------
void __fastcall CBike::Teleport(CBike *this, CVector NewCoors, int bClearOrientation)
{
  RwReal z; // r8
  float y; // r6
  RwReal x; // r5
  CMatrix *m_pMat; // r1
  float *p_tz; // r1
  CMatrix *v9; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v13; // r0
  float v14; // s2
  float v15; // s4
  __int64 v16; // d16
  __int64 v17; // d17

  z = NewCoors.z;
  y = NewCoors.y;
  x = NewCoors.x;
  CWorld::Remove(this);
  m_pMat = this->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = x;
    this->m_pMat->ty = y;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = x;
    this->m_transform.m_translate.y = y;
  }
  *p_tz = z;
  if ( bClearOrientation )
  {
    v9 = this->m_pMat;
    if ( v9 )
    {
      tx = v9->tx;
      ty = v9->ty;
      tz = v9->tz;
      CMatrix::SetRotate(v9, 0.0, 0.0, 0.0);
      v13 = this->m_pMat;
      v14 = ty + v13->ty;
      v15 = tz + v13->tz;
      v13->tx = tx + v13->tx;
      v13->ty = v14;
      v13->tz = v15;
    }
    else
    {
      this->m_transform.m_heading = 0.0;
    }
  }
  this->m_aWheelPitchAngles[0] = 0.0;
  *(float *)&v16 = 1.0;
  *((float *)&v16 + 1) = 1.0;
  *(float *)&v17 = 1.0;
  *((float *)&v17 + 1) = 1.0;
  this->m_aWheelPitchAngles[1] = 0.0;
  this->m_aWheelState[0] = WS_ROLLING;
  this->m_aWheelState[1] = WS_ROLLING;
  this->m_vecTurnSpeed.y = 0.0;
  this->m_vecTurnSpeed.z = 0.0;
  *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
  *(_QWORD *)this->m_aWheelRatios = v16;
  *(_QWORD *)&this->m_aWheelRatios[2] = v17;
  *(_QWORD *)this->m_aWheelCounts = 0LL;
  *(_QWORD *)&this->m_aWheelCounts[2] = 0LL;
  sub_19B3E4(this);
}

//----- (0056549C) --------------------------------------------------------
void __fastcall CBike::ResetSuspension(CBike *this)
{
  __int64 v1; // d16
  __int64 v2; // d17
  float *m_aWheelCounts; // r1
  float *m_aWheelRatios; // r0

  *(float *)&v1 = 1.0;
  *((float *)&v1 + 1) = 1.0;
  *(float *)&v2 = 1.0;
  *((float *)&v2 + 1) = 1.0;
  this->m_aWheelPitchAngles[0] = 0.0;
  this->m_aWheelPitchAngles[1] = 0.0;
  this->m_aWheelState[0] = WS_ROLLING;
  this->m_aWheelState[1] = WS_ROLLING;
  m_aWheelCounts = this->m_aWheelCounts;
  m_aWheelRatios = this->m_aWheelRatios;
  *(_QWORD *)m_aWheelCounts = 0LL;
  *((_QWORD *)m_aWheelCounts + 1) = 0LL;
  *(_QWORD *)m_aWheelRatios = v1;
  *((_QWORD *)m_aWheelRatios + 1) = v2;
}

//----- (005654C8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBike::PreRender(CBike *this)
{
  float32x2_t v1; // d3
  float32x2_t v2; // d4
  float32x2_t v3; // d5
  float32x2_t v4; // d6
  CBike *v5; // r9
  unsigned __int64 v6; // r0
  float v7; // s2
  float v8; // s6
  float v9; // s8
  float v10; // s0
  float v11; // s6
  float v12; // s4
  float v13; // s10
  float v14; // s6
  float v15; // s2
  float v16; // s4
  float v17; // s0
  int v18; // r1
  int32 nWheelIndex; // r8
  float v20; // s16
  int v21; // r10
  CColModel *v22; // r0
  float v23; // s24
  char *v24; // r9
  float v25; // s26
  float v26; // r11
  float v27; // s0
  CColPoint *pColPoint; // r0
  __int64 v29; // d16
  float v30; // s0
  CMatrix *m_pMat; // r1
  float zx; // s6
  float v33; // s2
  float v34; // s4
  int (***v35)(void); // r1
  float v36; // s0
  uint32 nOptionFlags; // r4
  uint32 nSkidmarkType; // r5
  tWheelState v39; // r1
  uint32 v40; // r5
  uint32 v41; // r6
  int v42; // r0
  float *p_xx; // r1
  float *p_x; // r2
  int v45; // r0
  float v46; // s4
  float v47; // s10
  RwReal v48; // s0
  float m_fSteerAngle; // r5
  float *v50; // r11
  float v51; // r0
  const CMatrix *v52; // r6
  CMatrix *v53; // r0
  __int64 v54; // d16
  float *v55; // r0
  float v56; // r0
  int v57; // r2
  float *v58; // r0
  int v59; // r1
  float v60; // r3
  float v61; // r0
  RwFrame_0 *v62; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float v66; // s2
  float v67; // s0
  int m_nFlags; // r0
  float v69; // r5
  float v70; // r6
  float v71; // r9
  RwFrame_0 *v72; // r5
  float v73; // r6
  float v74; // s16
  float v75; // s18
  float v76; // s20
  float v77; // r6
  float v78; // s6
  float v79; // s16
  float v80; // s18
  float v81; // s0
  float v82; // r0
  float v83; // s16
  float v84; // s18
  float v85; // s0
  float v86; // s20
  float v87; // r0
  RwFrame_0 *v88; // r0
  float v89; // s18
  float m_fLeanAngle; // s16
  float v91; // s20
  float z; // s22
  float v93; // r0
  CVector B; // [sp+0h] [bp-218h] OVERLAPPED BYREF
  CColModel *ColModel; // [sp+44h] [bp-1D4h]
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // [sp+48h] [bp-1D0h]
  float *v97; // [sp+4Ch] [bp-1CCh]
  unsigned int m_pColData; // [sp+50h] [bp-1C8h]
  float *v99; // [sp+54h] [bp-1C4h]
  float *m_aRatioHistory; // [sp+58h] [bp-1C0h]
  float *v101; // [sp+5Ch] [bp-1BCh]
  float *p_m_fLeanAngle; // [sp+60h] [bp-1B8h]
  int v103; // [sp+64h] [bp-1B4h]
  CVehicle *v104; // [sp+68h] [bp-1B0h]
  CVector v105; // [sp+6Ch] [bp-1ACh] BYREF
  CQuaternion v106; // [sp+78h] [bp-1A0h] BYREF
  char v107; // [sp+88h] [bp-190h] BYREF
  CMatrix m2; // [sp+C8h] [bp-150h] BYREF
  CVector v109; // [sp+110h] [bp-108h] BYREF
  CVector vecForward; // [sp+11Ch] [bp-FCh] BYREF
  CVector WheelSpeed; // [sp+128h] [bp-F0h] BYREF
  CMatrix Coors; // [sp+138h] [bp-E0h] BYREF
  CMatrix v[2]; // [sp+180h] [bp-98h] BYREF
  CVector v114; // 0:r1.12
  CVector v115; // 0:r2.8,8:^0.4

  v5 = this;
  CVehicle::PreRender(this);
  ColModel = CEntity::GetColModel(v5);
  m_pColData = (unsigned int)ColModel->m_pColData;
  p_m_nVehicleFlags = &v5->m_nVehicleFlags;
  if ( *((unsigned __int8 *)&v5->m_nVehicleFlags + 3) << 31 )
  {
    v6 = __PAIR64__(m_pColData, (*((int (__fastcall **)(CBike *))v5->_vptr$CPlaceable + 53))(v5));
    v1.n64_u32[0] = LODWORD(v5->m_aWheelRatios[0]);
    v7 = v5->m_fSuspensionLength[0];
    v2.n64_u32[0] = LODWORD(v5->m_aWheelRatios[1]);
    v8 = vmin_f32(v2, v1).n64_f32[0];
    v9 = v5->m_fSuspensionLength[2];
    v4.n64_u32[0] = LODWORD(v5->m_aWheelRatios[3]);
    v10 = (float)(v8 - (float)(1.0 - (float)(v7 / v5->m_fLineLength[0])))
        / (float)(1.0 - (float)(1.0 - (float)(v7 / v5->m_fLineLength[0])));
    v11 = 1.0 - (float)(v9 / v5->m_fLineLength[2]);
    v3.n64_u32[0] = LODWORD(v5->m_aWheelRatios[2]);
    v12 = 1.0 - v11;
    v13 = vmin_f32(v4, v3).n64_f32[0] - v11;
    v14 = *(float *)(*(_DWORD *)(m_pColData + 16) + 8);
    v15 = v14 - (float)(v7 * v10);
    v16 = v13 / v12;
    if ( v10 > 0.0 )
      v14 = v15;
    v5->m_aWheelSuspensionHeights[0] = v5->m_aWheelSuspensionHeights[0]
                                     + (float)((float)(v14 - v5->m_aWheelSuspensionHeights[0]) * 0.75);
    v17 = *(float *)(*(_DWORD *)(HIDWORD(v6) + 16) + 72);
    if ( v16 > 0.0 )
      v17 = v17 - (float)(v9 * v16);
    v5->m_aWheelSuspensionHeights[1] = v5->m_aWheelSuspensionHeights[1]
                                     + (float)((float)(v17 - v5->m_aWheelSuspensionHeights[1]) * 0.75);
  }
  v104 = v5;
  if ( *(_BYTE *)&v5->m_info < 0x20u )
  {
    v18 = 4;
    if ( v5->m_aWheelState[1] == WS_SKIDDING )
      v18 = 0;
    v99 = &v5->m_aRatioHistory[2];
    v101 = &v5->m_aRatioHistory[3];
    p_m_fLeanAngle = &v5->RideAnimData.m_fLeanAngle;
    nWheelIndex = 0;
    v97 = &v5->m_aRatioHistory[1];
    v103 = v18;
    m_aRatioHistory = v5->m_aRatioHistory;
    v20 = sqrtf(
            (float)((float)(v5->m_vecMoveSpeed.x * v5->m_vecMoveSpeed.x)
                  + (float)(v5->m_vecMoveSpeed.y * v5->m_vecMoveSpeed.y))
          + (float)(v5->m_vecMoveSpeed.z * v5->m_vecMoveSpeed.z));
    do
    {
      if ( nWheelIndex )
      {
        if ( *v101 < 1.0 || *v99 >= 1.0 )
          v21 = 3;
        else
          v21 = 2;
      }
      else
      {
        v21 = *m_aRatioHistory >= 1.0 && *v97 < 1.0;
      }
      v22 = CEntity::GetColModel(v5);
      v23 = *p_m_fLeanAngle;
      v24 = (char *)v104 + 44 * (__int16)v21;
      v25 = v22->m_boxBound.m_vecMin.z * 0.8;
      v26 = *((float *)v24 + 415);
      v27 = sinf(*p_m_fLeanAngle);
      pColPoint = (CColPoint *)(v24 + 1652);
      v5 = (CBike *)v104;
      v29 = *(_QWORD *)&pColPoint->m_vecPosition.x;
      v30 = v25 * v27;
      v[0].zx = v26;
      *(_QWORD *)&v[0].xx = v29;
      m_pMat = v104->m_pMat;
      zx = m_pMat->zx;
      v33 = v30 * m_pMat->xx;
      v34 = v30 * m_pMat->yx;
      v35 = &v104->_vptr$CPlaceable + nWheelIndex;
      v[0].xx = v33 + *(float *)&v29;
      v[0].yx = v34 + *((float *)&v29 + 1);
      v[0].zx = (float)(v30 * zx) + v26;
      v36 = 1.0;
      nOptionFlags = *((unsigned __int8 *)&v104[1].m_VehicleAudioEntity.ScratchSound.m_bRequestedStopped + nWheelIndex);
      nSkidmarkType = (uint32)v35[470];
      v39 = (tWheelState)v35[520];
      if ( !nWheelIndex )
        nOptionFlags |= v103;
      if ( v23 > 0.0 )
        v36 = -1.0;
      if ( *((_BYTE *)&v104[1].m_VehicleAudioEntity.ScratchSound.m_bRequestedStopped + nWheelIndex + 2) )
        nOptionFlags |= 2u;
      CVehicle::AddSingleWheelParticles(
        v104,
        v39,
        *(&v104[1].m_nNoOfStaticFrames + nWheelIndex),
        *((float *)&v104[1].m_VehicleAudioEntity.ScratchSound.m_FramePositionLastUpdated + v21),
        v20,
        pColPoint,
        (CVector *)v,
        v36,
        nWheelIndex,
        nSkidmarkType,
        (bool *)&v104[1].m_VehicleAudioEntity.ScratchSound.m_bRequestedStopped + nWheelIndex,
        nOptionFlags);
      ++nWheelIndex;
    }
    while ( nWheelIndex != 2 );
  }
  v5->m_bLeanMatrix = 0;
  CBike::CalculateLeanMatrix(v5);
  if ( (*(_DWORD *)p_m_nVehicleFlags & 0x10) != 0
    && (*(_DWORD *)p_m_nVehicleFlags & 0x40000000) == 0
    && (v5->pHandling->mFlags & 0x1000) == 0
    && (float)((float)((float)((float)(v5->m_vecMoveSpeed.x * v5->m_pMat->xy)
                             + (float)(v5->m_vecMoveSpeed.y * v5->m_pMat->yy))
                     + (float)(v5->m_vecMoveSpeed.z * v5->m_pMat->zy))
             / 0.0055556) < 130.0 )
  {
    CVehicle::AddExhaustParticles(v5);
  }
  CVehicle::AddDamagedVehicleParticles(v5);
  if ( v5->m_nModelIndex == 523
    && !(~*(_DWORD *)p_m_nVehicleFlags & 0x10 | ~*((_DWORD *)p_m_nVehicleFlags + 1) & 0x8000)
    && (*((_BYTE *)&v5->m_nPhysicalFlags + 3) & 0x20) == 0 )
  {
    v[0].yx = 0.6;
    v[0].xx = 0.28;
    Coors.yx = 0.6;
    v40 = CTimer::m_snTimeInMilliseconds;
    v[0].zx = 0.3;
    Coors.xx = -0.28;
    Coors.zx = 0.3;
    v41 = CTimer::m_snTimeInMilliseconds & 0x1FF;
    if ( v41 > 0xFF )
    {
      CCoronas::RegisterCorona(
        (u_native)&v5->m_pMat + 2,
        v5,
        0,
        0,
        (unsigned int)(float)((float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0) * 255.0),
        0xFFu,
        (const CVector *)v,
        0.4,
        40.0,
        0,
        0,
        0,
        0,
        0,
        0.0,
        0,
        1.5,
        0,
        30.0,
        0,
        1);
      v42 = -v40;
      v41 = -v40;
    }
    else
    {
      CCoronas::RegisterCorona(
        (u_native)&v5->m_pMat + 1,
        v5,
        (unsigned int)(float)((float)(CTimeCycle::m_CurrentColours.m_fSpriteBrightness / 10.0) * 255.0),
        0,
        0,
        0xFFu,
        (const CVector *)&Coors,
        0.4,
        40.0,
        0,
        0,
        0,
        0,
        0,
        0.0,
        0,
        1.5,
        0,
        30.0,
        0,
        1);
      LOBYTE(v42) = v40;
    }
    p_xx = &v5->m_pMat->xx;
    p_x = p_xx + 12;
    v45 = (unsigned __int8)~(_BYTE)v42;
    v46 = p_xx[5];
    if ( !p_xx )
      p_x = &v5->m_transform.m_translate.x;
    v47 = p_xx[9] * 0.5;
    v48 = (float)(p_x[2] + p_xx[6]) + (float)(p_xx[10] * 0.5);
    v114.x = (float)(*p_x + p_xx[4]) + (float)(p_xx[8] * 0.5);
    v114.y = (float)(p_x[1] + v46) + v47;
    v114.z = v48;
    memset(&B, 0, sizeof(B));
    CPointLights::AddLight(
      0,
      v114,
      B,
      10.0,
      (float)(unsigned __int8)v41 * 0.00097656,
      0.0,
      (float)v45 * 0.00097656,
      0,
      1,
      0);
  }
  CVehicle::DoVehicleLights(v5, &v5->m_LeanMatrix, 4u);
  CShadows::StoreShadowForVehicle(v5, VEHICLE_SHADOW_BIKE);
  Coors.m_pRwMat = 0;
  Coors.m_owner = 0;
  m_fSteerAngle = v5->m_fSteerAngle;
  v50 = (float *)CModelInfo::ms_modelInfoPtrs[v5->m_nModelIndex];
  v51 = cosf(m_fSteerAngle);
  v52 = v5->m_pMat;
  v[0].yx = v51;
  LODWORD(v[0].xx) = COERCE_UNSIGNED_INT(sinf(m_fSteerAngle)) ^ 0x80000000;
  v[0].zx = 0.0;
  Multiply3x3(&vecForward, v52, (const CVector *)v);
  v53 = v5->m_pMat;
  v54 = *(_QWORD *)&v53->xy;
  v109.z = v53->zy;
  *(_QWORD *)&v109.x = v54;
  if ( v5->m_aWheelCounts[0] > 0.0 || v5->m_aWheelCounts[1] > 0.0 )
  {
    v115.x = 0.0;
    v55 = *(float **)(m_pColData + 16);
    B.x = (float)(v55[2]
                - (float)(v5->m_aRatioHistory[v5->m_aRatioHistory[0] >= v5->m_aRatioHistory[1]]
                        * v5->m_fSuspensionLength[0]))
        - (float)(v50[22] * 0.5);
    v115.y = (float)(v55[1] + v55[9]) * 0.5;
    CPhysical::GetSpeed((CVector *)v, v5, v115);
    WheelSpeed.z = v[0].zx;
    *(_QWORD *)&WheelSpeed.x = *(_QWORD *)&v[0].xx;
    v56 = CVehicle::ProcessWheelRotation(v5, WS_ROLLING, &vecForward, &WheelSpeed, v50[22] * 0.5);
    v5->m_aWheelAngularVelocity[0] = v56;
    v5->m_aWheelPitchAngles[0] = v5->m_aWheelPitchAngles[0] + (float)(v56 * CTimer::ms_fTimeStep);
  }
  if ( v5->m_aWheelCounts[2] > 0.0 || v5->m_aWheelCounts[3] > 0.0 )
  {
    v57 = 0;
    v58 = *(float **)(m_pColData + 16);
    v59 = 3;
    if ( v5->m_aRatioHistory[2] < v5->m_aRatioHistory[3] )
      v59 = 2;
    B.x = (float)(v58[18] - (float)(v5->m_aRatioHistory[v59] * v5->m_fSuspensionLength[2])) - (float)(v50[22] * 0.5);
    v60 = (float)(v58[17] + v58[25]) * 0.5;
    CPhysical::GetSpeed((CVector *)v, v5, *(CVector *)&v57);
    WheelSpeed.z = v[0].zx;
    *(_QWORD *)&WheelSpeed.x = *(_QWORD *)&v[0].xx;
    v61 = CVehicle::ProcessWheelRotation(v5, v5->m_aWheelState[1], &v109, &WheelSpeed, v50[23] * 0.5);
    v5->m_aWheelAngularVelocity[1] = v61;
    v5->m_aWheelPitchAngles[1] = v5->m_aWheelPitchAngles[1] + (float)(v61 * CTimer::ms_fTimeStep);
  }
  v62 = v5->m_aBikeNodes[2];
  if ( v62 )
  {
    CMatrix::Attach(&Coors, &v62->modelling, 0);
    m2.m_owner = 0;
    m2.m_pRwMat = (RwMatrix *)&v107;
    tx = Coors.tx;
    ty = Coors.ty;
    tz = Coors.tz;
    CMatrix::SetUnity(&m2);
    CMatrix::UpdateRW(&m2);
    v66 = v50[28];
    v105.x = 0.0;
    v67 = (float)(v66 * 3.1416) / 180.0;
    v105.y = sinf(v67);
    LODWORD(v105.z) = COERCE_UNSIGNED_INT(cosf(v67)) ^ 0x80000000;
    CVector::Normalise(&v105);
    CQuaternion::Set(&v106, &v105, COERCE_FLOAT(LODWORD(v104[1].m_fBuoyancyConstant) ^ 0x80000000));
    CQuaternion::Get(&v106, m2.m_pRwMat);
    CMatrix::Update(&m2);
    CMatrix::SetUnity(&Coors);
    operator*(v, &Coors, &m2);
    CMatrix::operator=(&Coors, v);
    CMatrix::~CMatrix(v);
    v5 = (CBike *)v104;
    Coors.tx = tx + Coors.tx;
    Coors.ty = ty + Coors.ty;
    Coors.tz = tz + Coors.tz;
    CMatrix::UpdateRW(&Coors);
    m_nFlags = (int)v104[1].m_nFlags;
    if ( m_nFlags )
    {
      CMatrix::Attach(&Coors, (RwMatrix *)(m_nFlags + 16), 0);
      v70 = Coors.tx;
      v69 = Coors.ty;
      v71 = Coors.tz;
      if ( (*(_BYTE *)&v104->m_info & 0xF0) == 32 )
      {
        CMatrix::SetUnity(&Coors);
        operator*(v, &Coors, &m2);
        CMatrix::operator=(&Coors, v);
        CMatrix::~CMatrix(v);
        Coors.tx = Coors.tx + v70;
        Coors.ty = Coors.ty + v69;
        Coors.tz = Coors.tz + v71;
      }
      else
      {
        CMatrix::SetTranslate(&Coors, Coors.tx, Coors.ty, Coors.tz);
      }
      CMatrix::UpdateRW(&Coors);
      v5 = (CBike *)v104;
    }
    CMatrix::~CMatrix(&m2);
  }
  v72 = v5->m_aBikeNodes[3];
  if ( v72 )
  {
    v73 = asinf((float)(v5->m_aWheelSuspensionHeights[1] - v5->m_aWheelOrigHeights[1]) / v5->m_fSwingArmLength);
    CMatrix::Attach(&Coors, &v72->modelling, 0);
    v74 = Coors.tx;
    v75 = Coors.ty;
    v76 = Coors.tz;
    CMatrix::SetRotate(&Coors, COERCE_FLOAT(LODWORD(v73) ^ 0x80000000), 0.0, 0.0);
    Coors.tx = v74 + Coors.tx;
    Coors.ty = v75 + Coors.ty;
    Coors.tz = v76 + Coors.tz;
    CMatrix::UpdateRW(&Coors);
  }
  CMatrix::Attach(&Coors, &v5->m_aBikeNodes[4]->modelling, 0);
  v77 = Coors.tx;
  v78 = v5->m_aWheelSuspensionHeights[0];
  v79 = v78 - v5->m_fForkZOffset;
  v80 = (float)((float)((float)(*(float *)(*(_DWORD *)(m_pColData + 16) + 4)
                              + *(float *)(*(_DWORD *)(m_pColData + 16) + 36))
                      * 0.5)
              - v5->m_fForkYOffset)
      - (float)((float)(v78 - v5->m_aWheelOrigHeights[0]) * v5->m_fSteerAngleTan);
  v81 = v5->m_aWheelPitchAngles[0];
  if ( v5->m_nWheelStatus[0] == 1 )
  {
    v82 = sinf(v5->m_aWheelPitchAngles[0]);
    CMatrix::SetRotate(&Coors, v81, 0.0, v82 * 0.05);
  }
  else
  {
    CMatrix::SetRotateX(&Coors, v5->m_aWheelPitchAngles[0]);
  }
  Coors.ty = v80 + Coors.ty;
  Coors.tz = v79 + Coors.tz;
  Coors.tx = Coors.tx + v77;
  CMatrix::UpdateRW(&Coors);
  CMatrix::Attach(&Coors, &v5->m_aBikeNodes[6]->modelling, 0);
  Coors.tx = v77;
  Coors.tz = v79;
  Coors.ty = v80;
  CMatrix::UpdateRW(&Coors);
  CMatrix::Attach(&Coors, &v5->m_aBikeNodes[5]->modelling, 0);
  v83 = Coors.tx;
  v84 = Coors.ty;
  v85 = v5->m_aWheelPitchAngles[1];
  v86 = Coors.tz;
  if ( v5->m_nWheelStatus[1] == 1 )
  {
    v87 = sinf(v5->m_aWheelPitchAngles[1]);
    CMatrix::SetRotate(&Coors, v85, 0.0, v87 * 0.07);
  }
  else
  {
    CMatrix::SetRotateX(&Coors, v5->m_aWheelPitchAngles[1]);
  }
  Coors.tx = v83 + Coors.tx;
  Coors.ty = v84 + Coors.ty;
  Coors.tz = v86 + Coors.tz;
  CMatrix::UpdateRW(&Coors);
  v88 = v5->m_aBikeNodes[1];
  if ( v88 )
  {
    CMatrix::Attach(&Coors, &v88->modelling, 0);
    v89 = Coors.tx;
    m_fLeanAngle = v5->RideAnimData.m_fLeanAngle;
    v91 = Coors.ty;
    z = ColModel->m_boxBound.m_vecMin.z;
    CMatrix::SetRotateX(&Coors, fabsf(m_fLeanAngle) * -0.05);
    CMatrix::RotateY(&Coors, v5->RideAnimData.m_fLeanAngle);
    v93 = cosf(m_fLeanAngle);
    Coors.tx = v89 + Coors.tx;
    Coors.ty = v91 + Coors.ty;
    Coors.tz = (float)((float)(z * 0.9) * (float)(1.0 - v93)) + Coors.tz;
    CMatrix::UpdateRW(&Coors);
  }
  CMatrix::~CMatrix(&Coors);
}
// 5654C8: fragmented variable at r2.4 may be wrong
// 5654C8: variables would overlap: ^0.12 and 0:r2.8,8:^0.4

//----- (005660E4) --------------------------------------------------------
void __fastcall CBike::CalculateLeanMatrix(CBike *this)
{
  CMatrix *m_pMat; // r5
  float z; // s24
  float xz; // s18
  float yz; // s20
  float zz; // s22
  float v7; // r0
  float ty; // s8
  float tz; // s10
  float tx; // s6
  CMatrix v11; // [sp+0h] [bp-C8h] BYREF
  CMatrix v12; // [sp+48h] [bp-80h] BYREF

  if ( !this->m_bLeanMatrix )
  {
    v11.m_pRwMat = 0;
    v11.m_owner = 0;
    CMatrix::SetRotateX(&v11, fabsf(this->RideAnimData.m_fLeanAngle) * -0.05);
    CMatrix::RotateY(&v11, this->RideAnimData.m_fLeanAngle);
    CMatrix::operator=(&this->m_LeanMatrix, this->m_pMat);
    operator*(&v12, &this->m_LeanMatrix, &v11);
    CMatrix::operator=(&this->m_LeanMatrix, &v12);
    CMatrix::~CMatrix(&v12);
    m_pMat = this->m_pMat;
    z = CEntity::GetColModel(this)->m_boxBound.m_vecMin.z;
    xz = m_pMat->xz;
    yz = m_pMat->yz;
    zz = m_pMat->zz;
    v7 = cosf(this->RideAnimData.m_fLeanAngle);
    ty = this->m_LeanMatrix.ty;
    tz = this->m_LeanMatrix.tz;
    tx = this->m_LeanMatrix.tx;
    this->m_bLeanMatrix = 1;
    this->m_LeanMatrix.tx = tx + (float)((float)(z * xz) * (float)(1.0 - v7));
    this->m_LeanMatrix.ty = (float)((float)(z * yz) * (float)(1.0 - v7)) + ty;
    this->m_LeanMatrix.tz = (float)((float)(z * zz) * (float)(1.0 - v7)) + tz;
    CMatrix::~CMatrix(&v11);
  }
}

//----- (005661E4) --------------------------------------------------------
void __fastcall CBike::Render(CBike *this)
{
  void *value; // [sp+4h] [bp-Ch] BYREF

  value = 0;
  RwRenderStateGet(rwRENDERSTATEALPHATESTFUNCTIONREF, &value);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 1);
  this->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds + 3000;
  CVehicle::Render(this);
  if ( *((unsigned __int8 *)&this->CVehicle + 1428) << 31 )
  {
    CBike::CalculateLeanMatrix(this);
    CVehicle::DoHeadLightBeam(this, 0, &this->m_LeanMatrix, 1u);
  }
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, value);
}
// 0: using guessed type int dword_0;

//----- (00566244) --------------------------------------------------------
int32 __fastcall CBike::ProcessEntityCollision(CBike *this, CEntity *pEntity, CColPoint *aColPoints)
{
  CColModel *ColModel; // r10
  CCollisionData *m_pColData; // r11
  __int64 v6; // d17
  CEntity *v7; // r0
  CMatrix *m_pMat; // r6
  CMatrix *v9; // r9
  CColModel *v10; // r0
  int32 v11; // r10
  CPed *pDriver; // r0
  CBike *v13; // lr
  bool v14; // zf
  CColModel *v15; // r6
  char v16; // r0
  CEntity *v17; // r4
  CBaseModelInfo *v18; // r0
  int v19; // r1
  uint32 m_hashKey; // r0
  __int64 v21; // d16
  CColModel *v22; // r0
  CEntity *v23; // r1
  CColModel *v24; // r9
  CMatrix *v25; // r6
  CColModel *v26; // r0
  int32 v27; // r9
  int v28; // r5
  CColPoint *v29; // r6
  uint8 *m_storedCollisionLighting; // r3
  int v31; // r10
  int v32; // r9
  unsigned int v33; // r8
  int v34; // r11
  int v35; // r6
  float v36; // s0
  float *v37; // r5
  int v38; // r1
  bool v39; // zf
  CMatrix *v40; // r0
  CSimpleTransform *p_tx; // r2
  uint8 *v42; // r0
  RwReal v43; // s2
  float v44; // s4
  CEntity::CFlags v45; // kr00_8
  unsigned int v46; // r1
  bool v47; // cc
  CEntity *v48; // r0
  int v49; // r2
  int32 v51; // [sp+10h] [bp-B8h]
  CEntity::CFlags *v52; // [sp+14h] [bp-B4h]
  CEntity::CFlags *p_m_nFlags; // [sp+18h] [bp-B0h]
  uint8 *v54; // [sp+1Ch] [bp-ACh]
  CVector v57; // [sp+28h] [bp-A0h] BYREF
  CVector v; // [sp+38h] [bp-90h] BYREF
  CMatrix matA; // [sp+48h] [bp-80h] BYREF
  _QWORD v60[2]; // [sp+90h] [bp-38h]

  if ( (*(_BYTE *)&this->m_info & 0xF8) != 16 )
    *(_DWORD *)&this->m_nVehicleFlags |= 0x1000000u;
  ColModel = CEntity::GetColModel(this);
  m_pColData = ColModel->m_pColData;
  v6 = *(_QWORD *)&this->m_aWheelRatios[2];
  v60[0] = *(_QWORD *)this->m_aWheelRatios;
  v60[1] = v6;
  v7 = pEntity;
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 1) & 0x90) != 0 || (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    m_pColData->_anon_0.m_nNoOfLines = 0;
  m_pMat = pEntity->m_pMat;
  v9 = this->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(pEntity);
    CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
    v7 = pEntity;
    m_pMat = pEntity->m_pMat;
  }
  v10 = CEntity::GetColModel(v7);
  v11 = CCollision::ProcessColModels(
          v9,
          ColModel,
          m_pMat,
          v10,
          aColPoints,
          this->m_aWheelColPoints,
          this->m_aWheelRatios,
          0);
  pDriver = this->pDriver;
  v13 = this;
  v14 = pDriver == 0;
  if ( pDriver )
    v14 = this->m_nTestPedCollision == 0;
  if ( v14 )
    goto LABEL_29;
  v15 = CEntity::GetColModel(pDriver);
  v16 = `guard variable for'CBike::ProcessEntityCollision(CEntity *,CColPoint *)::aPedColPoints;
  __dmb(0xBu);
  if ( (v16 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CBike::ProcessEntityCollision(CEntity *,CColPoint *)::aPedColPoints) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CBike::ProcessEntityCollision(CEntity *,CColPoint *)::aPedColPoints);
  }
  v13 = this;
  v17 = pEntity;
  if ( !v15->m_pColData->_anon_0.m_nNoOfLines )
  {
    CMatrix::CMatrix(&matA, this->m_pMat);
    v18 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
    v19 = *(_DWORD *)&v18[1].m_modelName[20];
    m_hashKey = v18[2].m_hashKey;
    if ( v19 != 5 )
      m_hashKey += 48;
    v21 = *(_QWORD *)m_hashKey;
    v.z = *(RwReal *)(m_hashKey + 8);
    *(_QWORD *)&v.x = v21;
    Multiply3x3(&v57, this->m_pMat, &v);
    v = v57;
    matA.tx = v57.x + matA.tx;
    matA.ty = v57.y + matA.ty;
    matA.tz = v57.z + matA.tz;
    v22 = CEntity::GetColModel(this->pDriver);
    v23 = pEntity;
    v24 = v22;
    v25 = pEntity->m_pMat;
    if ( !v25 )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v23 = pEntity;
      v25 = pEntity->m_pMat;
    }
    v26 = CEntity::GetColModel(v23);
    v27 = CCollision::ProcessColModels(
            &matA,
            v24,
            v25,
            v26,
            CBike::ProcessEntityCollision(CEntity *,CColPoint *)::aPedColPoints,
            0,
            0,
            0);
    if ( v27 >= 1 )
    {
      if ( this->m_nTestPedCollision == 1 )
      {
        this->m_nTestPedCollision = 0;
      }
      else if ( v11 <= 30 )
      {
        v28 = 1;
        v29 = CBike::ProcessEntityCollision(CEntity *,CColPoint *)::aPedColPoints;
        do
        {
          if ( v29->m_dataA.m_nPieceType )
            CColPoint::operator=(&aColPoints[v11++], v29);
          if ( v11 > 30 )
            break;
          ++v29;
          v47 = v28++ < v27;
        }
        while ( v47 );
      }
    }
    CMatrix::~CMatrix(&matA);
    v13 = this;
LABEL_29:
    v17 = pEntity;
  }
  v51 = v11;
  if ( m_pColData->_anon_0.m_nNoOfLines )
  {
    m_storedCollisionLighting = v13->m_storedCollisionLighting;
    v31 = 1412;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    p_m_nFlags = &v13->m_nFlags;
    v52 = &v17->m_nFlags;
    v54 = v13->m_storedCollisionLighting;
    do
    {
      v36 = *(float *)&m_storedCollisionLighting[v34 * 4 + 416];
      if ( v36 < 1.0 && v36 < *(float *)((char *)v60 + v34 * 4) )
      {
        v37 = (float *)((char *)v13 + v33);
        ++v35;
        *((_BYTE *)&v13->_vptr$CPlaceable + v31) = v13->m_aWheelColPoints[v33 / 0x2C].m_dataB.m_lighting;
        v38 = *(_BYTE *)&v17->m_info & 7;
        v39 = v38 == 4;
        if ( v38 != 4 )
          v39 = v38 == 2;
        if ( v39 )
        {
          v13->m_aGroundPhysicalPtrs[v34] = (CPhysical *)v17;
          CEntity::RegisterReference(v17, (CEntity **)&m_storedCollisionLighting[v34 * 4 + 592]);
          v17 = pEntity;
          m_storedCollisionLighting = v54;
          v13 = this;
          v40 = pEntity->m_pMat;
          p_tx = (CSimpleTransform *)&v40->tx;
          if ( !v40 )
            p_tx = &pEntity->m_transform;
          v42 = &v54[v32 * 12];
          v43 = v37[414] - p_tx->m_translate.y;
          v44 = *(float *)&v54[v33 + 248] - p_tx->m_translate.z;
          *((float *)v42 + 152) = *(float *)&v54[v33 + 240] - p_tx->m_translate.x;
          this->m_aGroundOffsets[v32].y = v43;
          *((float *)v42 + 154) = v44;
          if ( (*(_BYTE *)&pEntity->m_info & 7) == 2 )
            *((_BYTE *)&this->_vptr$CPlaceable + v31) = *((_BYTE *)&pEntity->_vptr$CPlaceable + v31);
        }
        v13->m_LastMaterialToHaveBeenStandingOn = *((_BYTE *)v37 + 1687);
        if ( (*(_BYTE *)&v17->m_info & 7) == 1 )
        {
          v13->pEntityWeAreOnForVisibilityCheck = v17;
          v45 = *p_m_nFlags;
          v46 = *(_DWORD *)p_m_nFlags & 0xBFFFFFFF | (((*(_DWORD *)v52 >> 30) & 1) << 30);
          *(_DWORD *)p_m_nFlags = v46;
          p_m_nFlags->bdummy = v45.bdummy;
          *(_DWORD *)p_m_nFlags = v46 & 0x7FFFFFFF | ((*(_DWORD *)v52 < 0) << 31);
          p_m_nFlags->bdummy = v45.bdummy;
          m_storedCollisionLighting = v54;
        }
      }
      ++v34;
      ++v32;
      v33 += 44;
      ++v31;
    }
    while ( v34 != 4 );
  }
  else
  {
    v35 = 0;
    m_pColData->_anon_0.m_nNoOfLines = 4;
  }
  v47 = v51 < 0;
  if ( v51 <= 0 )
    v47 = v35 < 1;
  if ( !v47 )
  {
    CPhysical::AddCollisionRecord(v13, v17);
    v48 = pEntity;
    if ( (*(_BYTE *)&pEntity->m_info & 7) != 1 )
    {
      CPhysical::AddCollisionRecord((CPhysical *)pEntity, this);
      v48 = pEntity;
    }
    if ( v51 >= 1 )
    {
      v49 = *(_BYTE *)&v48->m_info & 7;
      if ( v49 == 1 || v49 == 4 && (LOBYTE(v48[1].m_transform.m_translate.y) & 4) != 0 )
        *(_DWORD *)&this->m_nFlags |= 0x1000u;
    }
  }
  return v51;
}
// A02538: using guessed type char `guard variable for'CBike::ProcessEntityCollision(CEntity *,CColPoint *)::aPedColPoints;
// 566244: using guessed type _QWORD var_38[2];

//----- (00566620) --------------------------------------------------------
void __fastcall CBike::ProcessControlInputs(CBike *this, uint8 CtrlNum)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  int32 v7; // r8
  RwReal v8; // s0
  RwReal v9; // s4
  CPed *pDriver; // r0
  CPed *v11; // r0
  float v12; // s16
  CPad *Pad; // r0
  int v14; // r0
  CPad *v15; // r0
  int v16; // r3
  CPad *v17; // r0
  CPad *v18; // r0
  float NewSteeringAmt; // r0
  CPad *v20; // r0
  int Accelerate; // r6
  CPad *v22; // r0
  int v23; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  float v25; // s20
  CPad *v26; // r0
  CPad *v27; // r0
  float *p_m_fGasPedal; // r0
  float v29; // s0
  CPad *v30; // r0
  CPad *v31; // r0
  int Brake; // r0
  int RecordingNumber; // r0
  CVehicle::CVehicleFlags v34; // r0
  uint32 v35; // r2
  int *v36; // r1
  CPlayerPed *PlayerPed; // r0
  float x; // s0
  float y; // s4
  float z; // s2
  float v41; // s6
  float v42; // s6
  CVector v43; // [sp+20h] [bp-78h] BYREF
  CEventKnockOffBike v44; // [sp+2Ch] [bp-6Ch] BYREF

  v7 = CtrlNum;
  if ( (float)(this->pBikeHandling->fStoppieBalancePoint - this->m_pMat->zy) <= 0.36 )
  {
    if ( (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) == 0 )
      goto LABEL_14;
    v8 = -this->m_vecMoveSpeed.x;
    v9 = -this->m_vecMoveSpeed.z;
    v43.y = -this->m_vecMoveSpeed.y;
    v43.x = v8;
    v43.z = v9;
    CVector::Normalise(&v43);
    CEventKnockOffBike::CEventKnockOffBike(
      &v44,
      this,
      &this->m_vecMoveSpeed,
      &v43,
      this->m_fMass
    * sqrtf(
        (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
              + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
      + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)),
      0.0,
      WEAPONTYPE_DROWNING,
      0,
      0,
      0,
      0,
      0);
  }
  else
  {
    if ( this->m_aWheelCounts[0] == 0.0
      && this->m_aWheelCounts[1] == 0.0
      && this->m_aWheelCounts[2] == 0.0
      && this->m_aWheelCounts[3] == 0.0 )
    {
      goto LABEL_14;
    }
    v43.x = 0.0;
    v43.y = 0.0;
    v43.z = 1.0;
    CEventKnockOffBike::CEventKnockOffBike(
      &v44,
      this,
      &this->m_vecMoveSpeed,
      &v43,
      0.0,
      0.0,
      WEAPONTYPE_FALL,
      1,
      0,
      0,
      1,
      0);
  }
  pDriver = this->pDriver;
  if ( pDriver )
    CEventGroup::Add(&pDriver->m_pPedIntelligence->m_eventGroup, &v44, 0);
  v11 = this->pPassengers[0];
  if ( v11 )
    CEventGroup::Add(&v11->m_pPedIntelligence->m_eventGroup, &v44, 0);
  CEventKnockOffBike::~CEventKnockOffBike(&v44);
LABEL_14:
  v12 = (float)((float)(this->m_vecMoveSpeed.x * this->m_pMat->xy) + (float)(this->m_vecMoveSpeed.y * this->m_pMat->yy))
      + (float)(this->m_vecMoveSpeed.z * this->m_pMat->zy);
  Pad = CPad::GetPad(v7);
  if ( CPad::GetExitVehicle(Pad) )
  {
    v14 = 32;
  }
  else
  {
    v15 = CPad::GetPad(v7);
    v14 = 32 * (CPad::GetHandBrake(v15) != 0);
  }
  v16 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  *(_DWORD *)&this->m_nVehicleFlags = v14 | *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFFFDF;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v16;
  v17 = CPad::GetPad(v7);
  this->fSteer = this->fSteer
               + (float)(CTimer::ms_fTimeStep
                       * (float)((float)((float)((float)-CPad::GetSteeringLeftRight(v17) * 0.0078125) - this->fSteer)
                               * 0.2));
  v18 = CPad::GetPad(v7);
  this->RideAnimData.m_fLeanFwd = this->RideAnimData.m_fLeanFwd
                                + (float)(CTimer::ms_fTimeStep
                                        * (float)((float)((float)((float)-CPad::GetSteeringUpDown(v18) * 0.0078125)
                                                        - this->RideAnimData.m_fLeanFwd)
                                                * 0.2));
  NewSteeringAmt = CVehicle::GetNewSteeringAmt(this);
  v2.n64_u32[0] = -1.0;
  v4.n64_u32[0] = LODWORD(this->RideAnimData.m_fLeanFwd);
  v5.n64_u32[0] = 1.0;
  v3.n64_f32[0] = NewSteeringAmt + this->fSteer;
  LODWORD(this->RideAnimData.m_fLeanFwd) = vmin_f32(vmax_f32(v4, v2), v5).n64_u32[0];
  LODWORD(this->fSteer) = vmin_f32(vmax_f32(v3, v2), v5).n64_u32[0];
  v20 = CPad::GetPad(v7);
  Accelerate = CPad::GetAccelerate(v20);
  v22 = CPad::GetPad(v7);
  v23 = Accelerate - CPad::GetBrake(v22);
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  v25 = (float)v23 / 255.0;
  if ( fabsf(v12) >= 0.01 )
  {
    p_m_fGasPedal = &this->m_fGasPedal;
    if ( v12 >= 0.0 )
    {
      if ( v25 < 0.0 )
      {
        v29 = -v25;
        *p_m_fGasPedal = 0.0;
LABEL_29:
        this->m_fBrakePedal = v29;
        goto LABEL_30;
      }
    }
    else if ( v25 >= 0.0 )
    {
      *p_m_fGasPedal = 0.0;
      this->m_fBrakePedal = v25;
      goto LABEL_30;
    }
    *p_m_fGasPedal = v25;
    this->m_fBrakePedal = 0.0;
    goto LABEL_30;
  }
  v26 = CPad::GetPad(v7);
  if ( CPad::GetAccelerate(v26) >= 151 )
  {
    v27 = CPad::GetPad(v7);
    if ( CPad::GetBrake(v27) >= 151 && this->m_vehicleType != 10 )
    {
      v30 = CPad::GetPad(v7);
      this->m_fGasPedal = (float)CPad::GetAccelerate(v30) / 255.0;
      v31 = CPad::GetPad(v7);
      Brake = CPad::GetBrake(v31);
      this->nBrakesOn = 1;
      v29 = (float)Brake / 255.0;
      goto LABEL_29;
    }
  }
  this->m_fBrakePedal = 0.0;
  this->m_fGasPedal = v25;
LABEL_30:
  RecordingNumber = this->AutoPilot.RecordingNumber;
  if ( RecordingNumber < 0 || CVehicleRecording::bUseCarAI[RecordingNumber] )
    this->m_fSteerAngle = this->fSteer * (float)((float)(this->pHandling->fSteeringLock * 3.1416) / 180.0);
  if ( (*(_DWORD *)p_m_nVehicleFlags & 0x1000) != 0 )
  {
    *(_DWORD *)&v34 = *(_DWORD *)p_m_nVehicleFlags & 0xFFFFFFDF;
    *((_DWORD *)&v34 + 1) = *((_DWORD *)&this->m_nVehicleFlags + 1);
    v35 = CTimer::m_snTimeInMilliseconds;
    if ( ((CTimer::m_snTimeInMilliseconds >> 12) & 3) != 3 )
      this->m_fGasPedal = 1.0;
    if ( (((unsigned __int8)(v35 >> 10) + 6) & 0xCu) <= 0xB )
      this->m_fBrakePedal = 0.0;
    *p_m_nVehicleFlags = v34;
    v36 = dword_566AE8;
    if ( (v35 & 0x800) != 0 )
      v36 = &dword_566AE8[1];
    this->m_fSteerAngle = this->m_fSteerAngle + *(float *)v36;
  }
  if ( CPad::GetPad(0)->DisablePlayerControls && CGameLogic::SkipState != 2 )
  {
    *(_DWORD *)p_m_nVehicleFlags |= 0x20u;
    this->m_fGasPedal = 0.0;
    this->m_fBrakePedal = 1.0;
    PlayerPed = FindPlayerPed(-1);
    CPlayerPed::KeepAreaAroundPlayerClear(PlayerPed);
    x = this->m_vecMoveSpeed.x;
    y = this->m_vecMoveSpeed.y;
    z = this->m_vecMoveSpeed.z;
    v41 = sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z));
    if ( v41 > 0.28 )
    {
      v42 = 0.28 / v41;
      this->m_vecMoveSpeed.x = x * v42;
      this->m_vecMoveSpeed.y = y * v42;
      this->m_vecMoveSpeed.z = z * v42;
    }
  }
}
// 566884: variable 'v4' is possibly undefined
// 566884: variable 'v2' is possibly undefined
// 566888: variable 'v5' is possibly undefined
// 56688C: variable 'v3' is possibly undefined
// 566AE8: using guessed type int dword_566AE8[2];

//----- (00566AF8) --------------------------------------------------------
Bool8 __fastcall CBike::GetAllWheelsOffGround(CBike *this)
{
  return this->m_nDriveWheelsOnGround == 0;
}

//----- (00566B08) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBike::BlowUpCar(CBike *this, CEntity *pCulprit, Bool8 bInACutscene)
{
  int noDamage; // r10
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r11
  RwReal v7; // s0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  RpClump_0 *m_pRwObject; // r0
  CSimpleTransform *p_m_transform; // r5
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r6
  CVehicle::CVehicleFlags v13; // kr00_8
  CMatrix *v14; // r0
  __int64 v15; // kr08_8 OVERLAPPED
  __int64 v16; // [sp+0h] [bp-38h]

  noDamage = bInACutscene;
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    v7 = this->m_vecMoveSpeed.z + 0.13;
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    m_pRwObject = (RpClump_0 *)this->m_pRwObject;
    this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x28);
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x20000000);
    this->m_vecMoveSpeed.z = v7;
    CVisibilityPlugins::SetClumpForAllAtomicsFlag(m_pRwObject, 0x4000);
    p_m_transform = &this->m_transform;
    m_pMat = this->m_pMat;
    p_tx = &this->m_transform;
    this->DelayedExplosion = 0;
    this->m_nHealth = 0.0;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    CCamera::CamShake(&TheCamera, 0.4, p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z);
    CVehicle::KillPedsInVehicle(this);
    v13 = *p_m_nVehicleFlags;
    *((_BYTE *)&this->CVehicle + 1202) &= 0xE7u;
    *(_DWORD *)p_m_nVehicleFlags = *(_DWORD *)&v13 & 0xFFFFFFAF;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = *((_DWORD *)&v13 + 1);
    CVehicle::ChangeLawEnforcerState(this, 0);
    v14 = this->m_pMat;
    if ( v14 )
      p_m_transform = (CSimpleTransform *)&v14->tx;
    v15 = *(_QWORD *)&p_m_transform->m_translate.x;
    v16 = *(_QWORD *)&p_m_transform->m_translate.y;
    CExplosion::AddExplosion(this, pCulprit, EXP_TYPE_CAR, *(CVector *)&v15, 0, 1u, -1.0, noDamage);
    sub_18CBF8(this, 0);
  }
}
// 566BCD: failed to expand linear variable kr08_8.8

//----- (00566C04) --------------------------------------------------------
void __fastcall CBike::RemoveRefsToVehicle(CBike *this, CEntity *pEntity)
{
  if ( this->m_aGroundPhysicalPtrs[0] == pEntity )
    this->m_aGroundPhysicalPtrs[0] = 0;
  if ( this->m_aGroundPhysicalPtrs[1] == pEntity )
    this->m_aGroundPhysicalPtrs[1] = 0;
  if ( this->m_aGroundPhysicalPtrs[2] == pEntity )
    this->m_aGroundPhysicalPtrs[2] = 0;
  if ( this->m_aGroundPhysicalPtrs[3] == pEntity )
    this->m_aGroundPhysicalPtrs[3] = 0;
}

//----- (00566C40) --------------------------------------------------------
bool __fastcall CBike::SetUpWheelColModel(CBike *this, CColModel *pColModel)
{
  RwFrame_0 *v4; // r6
  CColModel *ColModel; // r0
  __int64 v6; // d17
  __int64 v7; // d17
  __int64 v8; // d18
  RwFrame_0 *v9; // r0
  __int64 v10; // d16
  __int64 v11; // d17
  __int64 v12; // d18
  __int64 v13; // d19
  __int64 v14; // d20
  __int64 v15; // d21
  __int64 v16; // d23
  RwFrame_0 *parent; // r8
  float v18; // s0
  CColSphere *m_pSphereArray; // r0
  RwFrame_0 *v20; // r0
  __int64 v21; // d16
  __int64 v22; // d17
  __int64 v23; // d18
  __int64 v24; // d19
  __int64 v25; // d20
  __int64 v26; // d21
  __int64 v27; // d23
  RwFrame_0 *v28; // r5
  CColSphere *v29; // r0
  float v30; // s0
  CCollisionData *m_pColData; // [sp+8h] [bp-80h]
  CBaseModelInfo *v33; // [sp+Ch] [bp-7Ch]
  CVector vecCentre; // [sp+10h] [bp-78h] BYREF
  RwMatrix matrix; // [sp+20h] [bp-68h] BYREF

  v4 = this->m_aBikeNodes[1];
  m_pColData = pColModel->m_pColData;
  v33 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  ColModel = CEntity::GetColModel(this);
  v6 = *(_QWORD *)&ColModel->m_sphereBound.m_vecCentre.z;
  *(_QWORD *)&pColModel->m_sphereBound.m_vecCentre.x = *(_QWORD *)&ColModel->m_sphereBound.m_vecCentre.x;
  *(_QWORD *)&pColModel->m_sphereBound.m_vecCentre.z = v6;
  v7 = *(_QWORD *)&ColModel->m_boxBound.m_vecMin.z;
  v8 = *(_QWORD *)&ColModel->m_boxBound.m_vecMax.y;
  *(_QWORD *)&pColModel->m_boxBound.m_vecMin.x = *(_QWORD *)&ColModel->m_boxBound.m_vecMin.x;
  *(_QWORD *)&pColModel->m_boxBound.m_vecMin.z = v7;
  *(_QWORD *)&pColModel->m_boxBound.m_vecMax.y = v8;
  v9 = this->m_aBikeNodes[4];
  v10 = *(_QWORD *)&v9->modelling.right.x;
  v11 = *(_QWORD *)&v9->modelling.right.z;
  v12 = *(_QWORD *)&v9->modelling.up.x;
  v13 = *(_QWORD *)&v9->modelling.up.z;
  v14 = *(_QWORD *)&v9->modelling.at.x;
  v15 = *(_QWORD *)&v9->modelling.at.z;
  v16 = *(_QWORD *)&v9->modelling.pos.z;
  *(_QWORD *)&matrix.pos.x = *(_QWORD *)&v9->modelling.pos.x;
  *(_QWORD *)&matrix.pos.z = v16;
  *(_QWORD *)&matrix.at.x = v14;
  *(_QWORD *)&matrix.at.z = v15;
  *(_QWORD *)&matrix.right.x = v10;
  *(_QWORD *)&matrix.right.z = v11;
  *(_QWORD *)&matrix.up.x = v12;
  *(_QWORD *)&matrix.up.z = v13;
  parent = (RwFrame_0 *)v9->object.parent;
  while ( parent )
  {
    RwMatrixTransform(&matrix, &parent->modelling, rwCOMBINEPOSTCONCAT);
    parent = (RwFrame_0 *)parent->object.parent;
    if ( parent == v4 )
      parent = 0;
  }
  v18 = *(float *)&v33[1].m_txdIndex;
  m_pSphereArray = m_pColData->m_pSphereArray;
  vecCentre = (CVector)matrix.pos;
  CColSphere::Set(m_pSphereArray, v18 * 0.5, &vecCentre, 0x43u, 0xDu, 0xFFu);
  v20 = this->m_aBikeNodes[5];
  v21 = *(_QWORD *)&v20->modelling.right.x;
  v22 = *(_QWORD *)&v20->modelling.right.z;
  v23 = *(_QWORD *)&v20->modelling.up.x;
  v24 = *(_QWORD *)&v20->modelling.up.z;
  v25 = *(_QWORD *)&v20->modelling.at.x;
  v26 = *(_QWORD *)&v20->modelling.at.z;
  v27 = *(_QWORD *)&v20->modelling.pos.z;
  *(_QWORD *)&matrix.pos.x = *(_QWORD *)&v20->modelling.pos.x;
  *(_QWORD *)&matrix.pos.z = v27;
  *(_QWORD *)&matrix.at.x = v25;
  *(_QWORD *)&matrix.at.z = v26;
  *(_QWORD *)&matrix.right.x = v21;
  *(_QWORD *)&matrix.right.z = v22;
  *(_QWORD *)&matrix.up.x = v23;
  *(_QWORD *)&matrix.up.z = v24;
  v28 = (RwFrame_0 *)v20->object.parent;
  while ( v28 )
  {
    RwMatrixTransform(&matrix, &v28->modelling, rwCOMBINEPOSTCONCAT);
    v28 = (RwFrame_0 *)v28->object.parent;
    if ( v28 == v4 )
      v28 = 0;
  }
  v29 = m_pColData->m_pSphereArray;
  v30 = *(float *)&v33[1].m_n2dEffects * 0.5;
  vecCentre = (CVector)matrix.pos;
  CColSphere::Set(v29 + 1, v30, &vecCentre, 0x43u, 0xFu, 0xFFu);
  m_pColData->m_nNoOfSpheres = 2;
  return 1;
}

//----- (00566DD0) --------------------------------------------------------
bool __fastcall CBike::BurstTyre(CBike *this, uint8 nWheelPieceType, bool bApplyForce)
{
  _BOOL4 v4; // r5
  int v5; // r6
  bool v6; // r5
  float v8; // s16
  float v9; // s0
  CMatrix *m_pMat; // r0
  float v11; // s0
  float v12; // s16
  float v13; // s0
  CMatrix *v14; // r0
  float v15; // s0
  float v16; // s0
  float *v17; // r0
  float v18; // s0
  CMatrix *v19; // r0
  float v20; // s0
  CEventKnockOffBike v21; // [sp+20h] [bp-A8h] BYREF
  CEventKnockOffBike v22; // [sp+5Ch] [bp-6Ch] BYREF
  CVector v23; // 0:r1.12
  CVector v24; // 0:r1.12
  CVector v25; // 0:r1.12

  v4 = bApplyForce;
  v5 = nWheelPieceType;
  if ( *(_DWORD *)&this->m_nVehicleFlags < 0 || (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) != 0 )
    return 0;
  if ( nWheelPieceType == 15 )
  {
    v5 = 1;
  }
  else if ( nWheelPieceType == 13 )
  {
    v5 = 0;
  }
  if ( this->m_nWheelStatus[v5] )
  {
    v6 = 0;
  }
  else
  {
    this->m_nWheelStatus[v5] = 1;
    CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 90, 0.0);
    if ( (*(_BYTE *)&this->m_info & 0xF8) == 16 )
      CCarCtrl::SwitchVehicleToRealPhysics(this);
    if ( v4 )
    {
      v8 = fBikeBurstForceMult;
      v9 = (float)rand();
      m_pMat = this->m_pMat;
      v11 = this->m_fMass * (float)((float)((float)(v8 + v8) * (float)(v9 * 4.6566e-10)) - v8);
      v23.x = m_pMat->xx * v11;
      v23.y = m_pMat->yx * v11;
      v23.z = m_pMat->zx * v11;
      CPhysical::ApplyMoveForce(this, v23);
      v12 = fBikeBurstForceMult;
      v13 = (float)rand();
      v14 = this->m_pMat;
      v15 = this->m_fTurnMass * (float)((float)((float)(v12 + v12) * (float)(v13 * 4.6566e-10)) - v12);
      v24.x = v14->xx * v15;
      v24.y = v14->yx * v15;
      v24.z = v14->zx * v15;
      CPhysical::ApplyTurnForce(this, v24, *(CVector *)&v14->xy);
    }
    v6 = 1;
  }
  if ( this->pDriver )
  {
    if ( v5 == 13 )
    {
      v16 = 1.0;
      if ( this->m_aRatioHistory[0] < 1.0 )
      {
LABEL_25:
        v18 = sqrtf(
                (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                      + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
              + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
        if ( v18 > fBikeBurstFallSpeed && (*(_BYTE *)&this->m_info > 7u || v18 > fBikeBurstFallSpeedPlayer) )
        {
          if ( v5 == 13 )
          {
            CEventKnockOffBike::CEventKnockOffBike(
              &v22,
              this,
              &this->m_vecMoveSpeed,
              &this->m_vecDamageNormal,
              0.0,
              0.0,
              WEAPONTYPE_RAMMEDBYCAR,
              0,
              0,
              0,
              1,
              0);
            CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, &v22, 0);
            if ( this->pPassengers[0] )
            {
              CEventKnockOffBike::CEventKnockOffBike(
                &v21,
                this,
                &this->m_vecMoveSpeed,
                &this->m_vecDamageNormal,
                0.0,
                0.0,
                WEAPONTYPE_RAMMEDBYCAR,
                0,
                0,
                0,
                0,
                0);
              CEventGroup::Add(&this->pPassengers[0]->m_pPedIntelligence->m_eventGroup, &v21, 0);
              CEventKnockOffBike::~CEventKnockOffBike(&v21);
            }
            CEventKnockOffBike::~CEventKnockOffBike(&v22);
          }
          else
          {
            v19 = this->m_pMat;
            v20 = (float)(fBikeBurstForceMult + fBikeBurstForceMult) * this->m_fTurnMass;
            v25.x = v20 * v19->xx;
            v25.y = v20 * v19->yx;
            v25.z = v20 * v19->zx;
            CPhysical::ApplyTurnForce(this, v25, *(CVector *)&v19->xy);
          }
        }
        return v6;
      }
      v17 = &this->m_aRatioHistory[1];
    }
    else
    {
      if ( v5 != 14 )
        return v6;
      v16 = 1.0;
      if ( this->m_aRatioHistory[2] < 1.0 )
        goto LABEL_25;
      v17 = &this->m_aRatioHistory[3];
    }
    if ( *v17 >= v16 )
      return v6;
    goto LABEL_25;
  }
  return v6;
}

//----- (005670B0) --------------------------------------------------------
void __fastcall CBike::DoBurstAndSoftGroundRatios(CBike *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d8
  float32x2_t v4; // d14
  CBike *v5; // r5
  uint8 *m_nWheelStatus; // r2
  int v7; // r6
  int v8; // r8
  int v9; // r9
  int v10; // r10
  float v11; // s18
  int v12; // r0
  int (***v13)(void); // r0
  float *v14; // r1
  float *v15; // r0
  float *v16; // r4
  float v17; // s21
  float *p_m_txdIndex; // r0
  float v19; // s0
  uint8 *v20; // r0
  float v21; // s25
  float v22; // s27
  float v23; // s23
  float v24; // s31
  float v25; // r5
  float v26; // s25
  float v27; // s2
  float v28; // s2
  float v29; // s0
  float *m_aWheelRatios; // r6
  ColData *p_m_dataB; // r5
  int v32; // r4
  float v33; // s18
  uint32 hFlagsLocal; // r0
  float *p_m_n2dEffects; // [sp+4h] [bp-74h]
  CBaseModelInfo *v36; // [sp+8h] [bp-70h]
  uint8 *v38; // [sp+10h] [bp-68h]
  int v39[25]; // [sp+14h] [bp-64h]

  v5 = this;
  v39[0] = 16843009;
  v3.n64_u32[0] = 1.0;
  m_nWheelStatus = this->m_nWheelStatus;
  v7 = 1;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v4.n64_u32[0] = 1045220557;
  v11 = fabsf(
          (float)((float)(v5->m_vecMoveSpeed.x * this->m_pMat->xy) + (float)(v5->m_vecMoveSpeed.y * this->m_pMat->yy))
        + (float)(v5->m_vecMoveSpeed.z * this->m_pMat->zy));
  p_m_n2dEffects = (float *)&CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][1].m_n2dEffects;
  v36 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v38 = this->m_nWheelStatus;
  do
  {
    v12 = m_nWheelStatus[v10];
    if ( v10 == 1 )
    {
      v9 = 2;
      v7 = 3;
    }
    if ( v12 == 1 )
    {
      if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259)
                      * (float)(int)((unsigned int)(float)(v11 * 40.0) + 98)) <= 99 )
      {
        v13 = &v5->_vptr$CPlaceable + v9;
        v2.n64_u32[0] = (unsigned __int32)v13[485];
        v1.n64_u32[0] = (unsigned __int32)v13[481];
        v14 = &v5->m_aWheelRatios[v9];
        v15 = &v5->m_aWheelRatios[v7];
        v1.n64_f32[0] = (float)((float)(v2.n64_f32[0] - v1.n64_f32[0]) * 0.2) / v2.n64_f32[0];
        v2.n64_f32[0] = *v14 + v1.n64_f32[0];
        v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
        *v14 = v2.n64_f32[0];
        v1.n64_f32[0] = *v15 + v1.n64_f32[0];
        v1.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
        goto LABEL_22;
      }
LABEL_23:
      m_nWheelStatus = v38;
LABEL_24:
      *((_BYTE *)v39 + v9) = 0;
      *((_BYTE *)v39 + v7) = 0;
      goto LABEL_25;
    }
    if ( v12 == 2 )
    {
      v5->m_aWheelRatios[v9] = 1.0;
      v5->m_aWheelRatios[v7] = 1.0;
      goto LABEL_24;
    }
    v16 = (float *)(&v5->_vptr$CPlaceable + v9);
    v17 = v16[457];
    if ( v17 < 1.0 && v5->m_aWheelColPoints[v9].m_dataB.m_nSurfaceType == 178
      || v5->m_aWheelRatios[v7] < 1.0 && v5->m_aWheelColPoints[v7].m_dataB.m_nSurfaceType == 178 )
    {
      p_m_txdIndex = p_m_n2dEffects;
      if ( !v10 )
        p_m_txdIndex = (float *)&v36[1].m_txdIndex;
      v19 = *p_m_txdIndex;
      v20 = &m_nWheelStatus[v8];
      v21 = 1.5 / (float)(v19 * 0.5);
      if ( v11 > 0.3 )
        v21 = (float)(v11 / 0.3) * v21;
      v22 = *((float *)v20 + 61);
      v23 = *((float *)v20 + 63);
      v24 = v22 / v21;
      v25 = floorf(v22 / v21);
      v26 = (float)(v22 + (float)(v23 * CTimer::ms_fTimeStep)) / v21;
      v27 = v25;
      v5 = this;
      v28 = v24 - v27;
      v29 = v26 - floorf(v26);
      if ( v23 > 0.0 && v29 < v28 || v23 < 0.0 && v29 > v28 )
      {
        v15 = &this->m_aWheelRatios[v7];
        v1.n64_f32[0] = (float)((float)(v16[485] - v16[481]) * 0.3) / v16[485];
        v2.n64_f32[0] = v17 - v1.n64_f32[0];
        v2.n64_u64[0] = vmax_f32(v2, v4).n64_u64[0];
        v16[457] = v2.n64_f32[0];
        v1.n64_f32[0] = *v15 - v1.n64_f32[0];
        v1.n64_u64[0] = vmax_f32(v1, v4).n64_u64[0];
LABEL_22:
        *v15 = v1.n64_f32[0];
      }
      goto LABEL_23;
    }
LABEL_25:
    ++v10;
    v8 += 4;
  }
  while ( v10 != 2 );
  m_aWheelRatios = v5->m_aWheelRatios;
  p_m_dataB = &v5->m_aWheelColPoints[0].m_dataB;
  v4.n64_u32[0] = 1053609165;
  v32 = 0;
  v33 = (float)((float)(v11 * -0.7) / 0.3) + 1.0;
  do
  {
    if ( *((_BYTE *)v39 + v32)
      && *m_aWheelRatios < 1.0
      && SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, p_m_dataB->m_nSurfaceType) == 4
      && this->m_nModelIndex != 432 )
    {
      v1.n64_u32[0] = 1036831949;
      hFlagsLocal = this->hFlagsLocal;
      if ( (hFlagsLocal & 0x200000) == 0 )
      {
        v1.n64_u32[0] = 1041865114;
        if ( (hFlagsLocal & 0x100000) == 0 )
          v1.n64_u32[0] = 0.25;
      }
      v2.n64_f32[0] = v33 + (float)(CWeather::WetRoads * -0.7);
      v2.n64_u64[0] = vmax_f32(v2, v4).n64_u64[0];
      v1.n64_f32[0] = *m_aWheelRatios
                    + (float)((float)((float)(m_aWheelRatios[28] - m_aWheelRatios[24])
                                    * (float)(v1.n64_f32[0] * v2.n64_f32[0]))
                            / m_aWheelRatios[28]);
      v1.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
      *m_aWheelRatios = v1.n64_f32[0];
    }
    ++v32;
    ++m_aWheelRatios;
    p_m_dataB = (ColData *)((char *)p_m_dataB + 44);
  }
  while ( v32 != 4 );
}
// 5671E8: variable 'v2' is possibly undefined
// 5671E8: variable 'v3' is possibly undefined
// 5671F8: variable 'v1' is possibly undefined
// 567308: variable 'v4' is possibly undefined

//----- (0056743C) --------------------------------------------------------
void __fastcall CBike::Fix(CBike *this)
{
  CBike::CBikeFlags m_nBikeFlags; // r1
  int m_nVehicleFlags; // r2

  m_nBikeFlags = this->m_nBikeFlags;
  *(_WORD *)this->m_nWheelStatus = 0;
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags & 0xBF);
  *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags & 0xFFFEFFFF;
}

//----- (0056745E) --------------------------------------------------------
void __fastcall CBike::PlayCarHorn(CBike *this)
{
  int CarAlarmState; // r0
  bool v3; // zf
  UInt8 v4; // r0
  unsigned int v5; // r1
  CPed *pDriver; // r0
  bool v7; // zf

  CarAlarmState = this->CarAlarmState;
  v3 = CarAlarmState == 0;
  if ( CarAlarmState )
    v3 = CarAlarmState == 0xFFFF;
  if ( (v3 || (*(_BYTE *)&this->m_info & 0xF8) == 40) && !this->m_cHorn )
  {
    if ( this->m_NoHornCount )
    {
      --this->m_NoHornCount;
      return;
    }
    v4 = (rand() & 0x7F) - 106;
    this->m_NoHornCount = v4;
    v5 = v4 & 7;
    if ( v5 > 1 )
    {
      pDriver = this->pDriver;
      if ( v5 > 3 )
      {
        if ( pDriver )
          CPed::Say(pDriver, 0x16u, 0, 1.0, 0, 0, 0);
        return;
      }
      v7 = pDriver == 0;
      if ( pDriver )
        v7 = *((unsigned __int8 *)&this->AutoPilot + 75) << 31 == 0;
      if ( !v7 )
        CPed::Say(pDriver, 0x16u, 0, 1.0, 0, 0, 0);
    }
    this->m_cHorn = 45;
  }
}

//----- (00567504) --------------------------------------------------------
void __fastcall CBike::PlaceOnRoadProperly(CBike *this)
{
  float y; // s24
  CColModel *ColModel; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r2
  float xy; // s0
  float yy; // s2
  float z; // s10
  float x; // s6
  float v11; // s8
  float v12; // s28
  float v13; // s16
  float v14; // s18
  float v15; // s22
  float v16; // s20
  float v17; // s26
  CEntity *v18; // r1
  CMatrix *v19; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  unsigned int v21; // r3
  CSimpleTransform *v22; // r1
  CSimpleTransform *v23; // r1
  float v24; // s0
  float v25; // s30
  CEntity *v26; // r0
  CMatrix *v27; // r6
  CEntity::CFlags v28; // r2
  float v29; // s24
  float v30; // r5
  float v31; // r0
  float v32; // r1
  float v33; // r2
  float v34; // s0
  CMatrix *v35; // r0
  float v36; // s2
  float v37; // s4
  float v38; // s0
  float *p_tz; // r0
  CVector v40; // [sp+20h] [bp-98h] BYREF
  CVector vecStart; // [sp+2Ch] [bp-8Ch] BYREF
  CEntity *refEntityPtr; // [sp+38h] [bp-80h] BYREF
  CColPoint colPoint; // [sp+3Ch] [bp-7Ch] BYREF

  y = CEntity::GetColModel(this)->m_boxBound.m_vecMax.y;
  ColModel = CEntity::GetColModel(this);
  m_pMat = this->m_pMat;
  p_m_transform = &this->m_transform;
  p_tx = &this->m_transform;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  z = p_tx->m_translate.z;
  x = p_tx->m_translate.x;
  v11 = p_tx->m_translate.y;
  v12 = ColModel->m_boxBound.m_vecMin.y;
  v13 = (float)(y * xy) + p_tx->m_translate.x;
  v14 = (float)(y * yy) + v11;
  vecStart.z = z + 5.0;
  v15 = v11 + (float)(yy * v12);
  v16 = x + (float)(xy * v12);
  vecStart.y = v14;
  vecStart.x = (float)(y * xy) + x;
  if ( CWorld::ProcessVerticalLine(&vecStart, z + -5.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    v17 = colPoint.m_vecPosition.z;
    this->StoredCollPolys[0].lighting = colPoint.m_dataB.m_lighting;
    v18 = refEntityPtr;
    this->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
    v19 = this->m_pMat;
    m_nFlags = this->m_nFlags;
    v21 = *(_DWORD *)&m_nFlags & 0xBFFFFFFF | (((*(_DWORD *)&v18->m_nFlags >> 30) & 1) << 30);
    *(_DWORD *)&this->m_nFlags = v21;
    this->m_nFlags.bdummy = m_nFlags.bdummy;
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&v18->m_nFlags & 0x80000000 | v21 & 0x7FFFFFFF;
    this->m_nFlags.bdummy = m_nFlags.bdummy;
  }
  else
  {
    v19 = this->m_pMat;
    v22 = &this->m_transform;
    if ( v19 )
      v22 = (CSimpleTransform *)&v19->tx;
    v17 = v22->m_translate.z;
  }
  v23 = &this->m_transform;
  if ( v19 )
    v23 = (CSimpleTransform *)&v19->tx;
  v24 = v23->m_translate.z;
  vecStart.y = v11 + (float)(yy * v12);
  vecStart.x = v16;
  vecStart.z = v24 + 5.0;
  if ( CWorld::ProcessVerticalLine(&vecStart, v24 + -5.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    v25 = colPoint.m_vecPosition.z;
    this->StoredCollPolys[1].lighting = colPoint.m_dataB.m_lighting;
    v26 = refEntityPtr;
    this->pEntityWeAreOnForVisibilityCheck = refEntityPtr;
    v27 = this->m_pMat;
    v28 = this->m_nFlags;
    *(_DWORD *)&v28 = *(_DWORD *)&v28 & 0xBFFFFFFF | (((*(_DWORD *)&v26->m_nFlags >> 30) & 1) << 30);
    this->m_nFlags = v28;
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&v26->m_nFlags & 0x80000000 | *(_DWORD *)&v28 & 0x7FFFFFFF;
    this->m_nFlags.bdummy = v28.bdummy;
  }
  else
  {
    v27 = this->m_pMat;
    if ( v27 )
      p_m_transform = (CSimpleTransform *)&v27->tx;
    v25 = p_m_transform->m_translate.z;
  }
  v29 = y - v12;
  v30 = atanf((float)(v17 - v25) / v29);
  v27->xx = (float)(v14 - v15) / v29;
  this->m_pMat->yx = (float)-(float)(v13 - v16) / v29;
  this->m_pMat->zx = 0.0;
  v31 = cosf(v30);
  this->m_pMat->xy = -(float)(v31 * this->m_pMat->yx);
  this->m_pMat->yy = v31 * this->m_pMat->xx;
  this->m_pMat->zy = sinf(v30);
  CrossProduct(&v40, (const CVector *)this->m_pMat, (const CVector *)&this->m_pMat->xy);
  v32 = v40.y;
  v33 = v40.z;
  this->m_pMat->xz = v40.x;
  this->m_pMat->yz = v32;
  this->m_pMat->zz = v33;
  v34 = COERCE_FLOAT((*((int (__fastcall **)(CBike *))this->_vptr$CPlaceable + 54))(this));
  v35 = this->m_pMat;
  v36 = (float)(v14 + v15) * 0.5;
  v37 = (float)(v13 + v16) * 0.5;
  v38 = (float)((float)(v17 + v25) * 0.5) + v34;
  if ( v35 )
  {
    v35->tx = v37;
    this->m_pMat->ty = v36;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = v37;
    this->m_transform.m_translate.y = v36;
  }
  *p_tz = v38;
}

//----- (00567752) --------------------------------------------------------
bool __fastcall CBike::IsRoomForPedToLeaveCar(CBike *this, uint32 nDoor, CVector *pvecCarJackOffset)
{
  return 1;
}

//----- (00567758) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBike::GetCorrectedWorldDoorPosition(
        CBike *this,
        CVector *vecPosToRunTo,
        CVector vecAnimOffset,
        CVector vecSeatPos)
{
  CMatrix *m_pMat; // r0
  float x; // r9
  float y; // r8
  CMatrix *v9; // r0
  float v10; // s16
  float v11; // s18
  CColModel *ColModel; // r0
  float v13; // s0
  float z; // s2
  bool v15; // cc
  float v16; // s6
  float v17; // s0
  CMatrix *v18; // r0
  float v19; // s0
  float v20; // s1
  float v21; // s10
  float v22; // s2
  float v23; // s0
  CMatrix *v24; // r0
  CSimpleTransform *p_tx; // r1
  CVector v26; // [sp+0h] [bp-40h] BYREF
  CVector v27; // [sp+Ch] [bp-34h] BYREF

  m_pMat = this->m_pMat;
  v26.x = 0.0;
  v26.y = 0.0;
  x = vecAnimOffset.x;
  v26.z = 1.0;
  y = vecAnimOffset.y;
  CrossProduct(&v27, (const CVector *)&m_pMat->xy, &v26);
  CrossProduct(&v26, &v27, (const CVector *)&this->m_pMat->xy);
  v9 = this->m_pMat;
  v10 = v9->zz * v27.z;
  v11 = (float)(v9->xz * v27.x) + (float)(v9->yz * v27.y);
  ColModel = CEntity::GetColModel(this);
  v13 = ColModel->m_boxBound.m_vecMax.x;
  z = ColModel->m_boxBound.m_vecMax.z;
  v15 = z <= v13;
  v16 = z - v13;
  v17 = 0.0;
  if ( !v15 )
    v17 = v16;
  vecPosToRunTo->x = 0.0;
  vecPosToRunTo->y = 0.0;
  vecPosToRunTo->z = 0.0;
  v18 = this->m_pMat;
  v19 = (float)(vecSeatPos.x - x) + (float)((float)(v11 + v10) * v17);
  v20 = (float)(vecSeatPos.z - vecAnimOffset.z) * v26.y;
  v21 = (float)(v19 * v27.y) + (float)((float)((float)(vecSeatPos.y - y) * v18->yy) + 0.0);
  v22 = (float)((float)(vecSeatPos.z - vecAnimOffset.z) * v26.x)
      + (float)((float)(v19 * v27.x) + (float)((float)((float)(vecSeatPos.y - y) * v18->xy) + 0.0));
  v23 = (float)((float)(vecSeatPos.z - vecAnimOffset.z) * v26.z)
      + (float)((float)(v19 * v27.z) + (float)((float)((float)(vecSeatPos.y - y) * v18->zy) + 0.0));
  vecPosToRunTo->x = v22;
  vecPosToRunTo->y = v20 + v21;
  vecPosToRunTo->z = v23;
  v24 = this->m_pMat;
  p_tx = (CSimpleTransform *)&v24->tx;
  if ( !v24 )
    p_tx = &this->m_transform;
  vecPosToRunTo->x = p_tx->m_translate.x + v22;
  vecPosToRunTo->y = p_tx->m_translate.y + (float)(v20 + v21);
  vecPosToRunTo->z = p_tx->m_translate.z + v23;
}
// 567758: fragmented variable at 0:r2.8,8:^48.4 may be wrong
// 567758: variables would overlap: 0:r2.8,8:^48.4 and ^48.4

//----- (005678E0) --------------------------------------------------------
void __fastcall CBike::ProcessDrivingAnims(CBike *this, CPed *pPed, bool8 playRadioAnim)
{
  if ( (*((_BYTE *)&this->m_nFlags + 2) & 2) == 0 || *(_BYTE *)&this->m_info <= 7u )
    CBike::ProcessRiderAnims(pPed, this, &this->RideAnimData, this->pBikeHandling, 0);
}

//----- (00567914) --------------------------------------------------------
void __fastcall CBike::ProcessRiderAnims(
        CPed *pPed,
        CVehicle *pVehicle,
        CRideAnimData *pRideData,
        tBikeHandlingData *pBikeHandData,
        int16 nFlags)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d2
  float32x2_t v7; // d10
  float32x2_t v8; // d11
  unsigned __int64 v9; // d13
  _BOOL4 IsPlayer; // r4
  int32 m_baseVehicleType; // r0
  unsigned __int8 *p_TempActionFinish; // r0
  CAnimBlendAssociation *Association; // r5
  CAnimBlendAssociation *v18; // r5
  CAnimBlendAssociation *v19; // r0
  CAnimBlendAssociation *v20; // r6
  CAnimBlendAssociation *v21; // r9
  CMatrix *m_pMat; // r0
  float v23; // s0
  float v24; // s2
  float v25; // s16
  float BikeRidingSkill; // r0
  CPed *v27; // r0
  bool v28; // zf
  CAnimBlendAssociation *v29; // r0
  float v30; // s2
  float m_fMaxReverseVelocity; // s0
  CPed *v32; // r0
  bool v33; // zf
  CAnimBlendAssociation *v34; // r9
  float v35; // s28
  float32x2_t v36; // d12
  float v37; // s2
  float v38; // r6
  float v39; // r0
  bool v40; // zf
  float v41; // r0
  float v42; // s0
  float m_fAnimLeanLeft; // s2
  float v44; // s20
  float *p_m_fAnimLeanFwd; // r10
  CAnimBlendAssociation *v46; // r5
  CAnimBlendAssociation *v47; // r6
  float v48; // s24
  CAnimBlendAssociation *v49; // r4
  float v50; // s0
  CAnimBlendHierarchy *v51; // r0
  CAnimBlendAssociation *v52; // r0
  float v53; // s4
  float v54; // s0
  CAnimBlendHierarchy *v55; // r0
  CAnimBlendAssociation *v56; // r0
  CAnimBlendHierarchy *v57; // r0
  RwFrame_0 *pFrame; // r5
  float v59; // s18
  int v60; // r0
  float v61; // s16
  int v62; // r0
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r0
  char z_low; // r0
  float m_fDistanceFromCameraLastFrame; // s0
  float v66; // s2
  float fWheelieBalancePoint; // s6
  float v68; // s0
  float zy; // s2
  float v70; // s0
  CVehicle *v71; // [sp+20h] [bp-108h]
  int v72; // [sp+24h] [bp-104h]
  CAnimBlendAssociation *v73; // [sp+28h] [bp-100h]
  const CVector *vecSpeed; // [sp+2Ch] [bp-FCh]
  CAnimBlendAssociation *v75; // [sp+30h] [bp-F8h]
  CVehicle *v76; // [sp+34h] [bp-F4h]
  CAnimBlendAssociation *v77; // [sp+38h] [bp-F0h]
  CAnimBlendAssociation *v78; // [sp+3Ch] [bp-ECh]
  tBikeHandlingData *v79; // [sp+40h] [bp-E8h]
  CAnimBlendAssociation *v80; // [sp+44h] [bp-E4h]
  CVector v81; // [sp+4Ch] [bp-DCh] BYREF
  CEventKnockOffBike vecNorm; // [sp+58h] [bp-D0h] BYREF
  CEventKnockOffBike v83; // [sp+94h] [bp-94h] BYREF

  IsPlayer = CPed::IsPlayer(pPed);
  m_baseVehicleType = pVehicle->m_baseVehicleType;
  v79 = pBikeHandData;
  if ( !m_baseVehicleType )
  {
    p_TempActionFinish = (unsigned __int8 *)&pVehicle[1].AutoPilot.TempActionFinish;
    v76 = 0;
    v71 = pVehicle;
    goto LABEL_5;
  }
  if ( m_baseVehicleType == 9 )
  {
    p_TempActionFinish = (unsigned __int8 *)&pVehicle[1].m_VehicleAudioEntity.m_EngineSounds[8].SoundPtr;
    v71 = 0;
    v76 = pVehicle;
LABEL_5:
    v72 = *p_TempActionFinish;
    goto LABEL_7;
  }
  v72 = 0;
  v71 = 0;
  v76 = 0;
LABEL_7:
  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC4u);
  v80 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC5u);
  v78 = Association;
  v75 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC3u);
  if ( IsPlayer )
  {
    v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC7u);
    v19 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC6u);
  }
  else
  {
    v18 = 0;
    v19 = 0;
  }
  v77 = v19;
  v20 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC8u);
  v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCAu);
  if ( !v21 )
  {
    v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCBu);
    if ( !v21 )
      v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCCu);
  }
  m_pMat = pVehicle->m_pMat;
  v23 = pVehicle->m_vecMoveSpeed.z * m_pMat->zy;
  vecSpeed = &pVehicle->m_vecMoveSpeed;
  v24 = (float)(pVehicle->m_vecMoveSpeed.x * m_pMat->xy) + (float)(pVehicle->m_vecMoveSpeed.y * m_pMat->yy);
  if ( pVehicle->m_vehicleType == 10 && (unsigned int)v20 | (unsigned int)v21 )
    BYTE1(pVehicle[1].m_VehicleAudioEntity.m_fEventVolume) = 0;
  v25 = v24 + v23;
  BikeRidingSkill = CPed::GetBikeRidingSkill(pPed);
  v7.n64_u32[0] = 1.0;
  if ( (float)((float)((float)(pVehicle->m_vecTurnSpeed.x * pVehicle->m_vecTurnSpeed.x)
                     + (float)(pVehicle->m_vecTurnSpeed.y * pVehicle->m_vecTurnSpeed.y))
             + (float)(pVehicle->m_vecTurnSpeed.z * pVehicle->m_vecTurnSpeed.z)) > (float)((float)((float)(BikeRidingSkill + 1.0)
                                                                                                 * 0.3)
                                                                                         * (float)((float)(BikeRidingSkill + 1.0)
                                                                                                 * 0.3)) )
  {
    vecNorm._vptr$CEvent = 0;
    vecNorm.m_iAccumulatedTime = 0;
    *(_DWORD *)&vecNorm.m_bIsPersistent = 1065353216;
    CEventKnockOffBike::CEventKnockOffBike(
      &v83,
      pVehicle,
      vecSpeed,
      (const CVector *)&vecNorm,
      0.0,
      0.0,
      WEAPONTYPE_FALL,
      2,
      0,
      0,
      1,
      0);
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v83, 0);
    v27 = pVehicle->pPassengers[0];
    v28 = v27 == 0;
    if ( v27 )
      v28 = v27 == pPed;
    if ( !v28 )
    {
      v81.x = 0.0;
      v81.y = 0.0;
      v81.z = 1.0;
      CEventKnockOffBike::CEventKnockOffBike(
        &vecNorm,
        pVehicle,
        vecSpeed,
        &v81,
        0.0,
        0.0,
        WEAPONTYPE_FALL,
        2,
        0,
        0,
        0,
        0);
      CEventGroup::Add(&pVehicle->pPassengers[0]->m_pPedIntelligence->m_eventGroup, &vecNorm, 0);
      CEventKnockOffBike::~CEventKnockOffBike(&vecNorm);
    }
    CEventKnockOffBike::~CEventKnockOffBike(&v83);
  }
  if ( fabsf(v25) >= 0.02 || v21 )
  {
    if ( v25 >= 0.0 )
    {
      v29 = v75;
      if ( v75 && v75->m_fBlendDelta >= 0.0 )
        v75->m_fBlendDelta = -4.0;
      LODWORD(v9) = 0;
      if ( !v20 )
      {
LABEL_128:
        v20 = 0;
        if ( v29 )
          goto LABEL_28;
        goto LABEL_49;
      }
LABEL_46:
      if ( v20->m_fBlendDelta >= 0.0 )
        v20->m_fBlendDelta = -4.0;
      if ( v29 )
        goto LABEL_28;
      goto LABEL_49;
    }
    v30 = (float)(CPed::GetBikeRidingSkill(pPed) + 1.0) * 3.5;
    if ( pVehicle->m_vehicleType == 2 )
      v30 = v30 + v30;
    m_fMaxReverseVelocity = pVehicle->pHandling->Transmission.m_fMaxReverseVelocity;
    if ( v25 < (float)(m_fMaxReverseVelocity * v30)
      && (v72 || pVehicle->m_pMat->zz < -0.5 && CTimer::m_snTimeInMilliseconds - pVehicle->m_LastCollisionTime <= 0x63) )
    {
      vecNorm._vptr$CEvent = 0;
      vecNorm.m_iAccumulatedTime = 0;
      *(_DWORD *)&vecNorm.m_bIsPersistent = 1065353216;
      CEventKnockOffBike::CEventKnockOffBike(
        &v83,
        pVehicle,
        vecSpeed,
        (const CVector *)&vecNorm,
        0.0,
        0.0,
        WEAPONTYPE_FALL,
        2,
        0,
        0,
        1,
        0);
      CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v83, 0);
      v32 = pVehicle->pPassengers[0];
      v33 = v32 == 0;
      if ( v32 )
        v33 = v32 == pPed;
      if ( !v33 )
      {
        v81.x = 0.0;
        v81.y = 0.0;
        v81.z = 1.0;
        CEventKnockOffBike::CEventKnockOffBike(
          &vecNorm,
          pVehicle,
          vecSpeed,
          &v81,
          0.0,
          0.0,
          WEAPONTYPE_FALL,
          2,
          0,
          0,
          0,
          0);
        CEventGroup::Add(&pVehicle->pPassengers[0]->m_pPedIntelligence->m_eventGroup, &vecNorm, 0);
        CEventKnockOffBike::~CEventKnockOffBike(&vecNorm);
      }
      CEventKnockOffBike::~CEventKnockOffBike(&v83);
      LODWORD(v9) = 0;
LABEL_40:
      v29 = v75;
      if ( v75 )
        goto LABEL_28;
      goto LABEL_49;
    }
    if ( pVehicle->m_fGasPedal < 0.0 && m_fMaxReverseVelocity * 1.5 < v25 )
    {
      if ( !v20 || (LODWORD(v9) = 0, v20->m_fBlendAmount < 1.0) && v20->m_fBlendDelta <= 0.0 )
      {
        v20 = CAnimManager::BlendAnimation(
                (RpClump_0 *)pPed->m_pRwObject,
                pRideData->m_animGroup,
                ANIM_BIKE_WALKBACK,
                4.0);
        LODWORD(v9) = 0;
      }
      goto LABEL_40;
    }
    LODWORD(v9) = 0;
    if ( IsPlayer )
    {
      v29 = v75;
      if ( m_fMaxReverseVelocity * 1.5 > v25 )
        LODWORD(v9) = -1.0;
      if ( !v75 )
      {
LABEL_127:
        if ( !v20 )
          goto LABEL_128;
        goto LABEL_46;
      }
    }
    else
    {
      v29 = v75;
      if ( !v75 )
        goto LABEL_127;
    }
    if ( v29->m_fBlendDelta >= 0.0 )
      v29->m_fBlendDelta = -4.0;
    goto LABEL_127;
  }
  v29 = v75;
  if ( v75 )
  {
    v5.n64_u32[0] = LODWORD(v75->m_fBlendAmount);
    LODWORD(v9) = 0;
    if ( v5.n64_f32[0] >= 1.0 || v75->m_fBlendDelta > 0.0 )
      goto LABEL_29;
  }
  v29 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pRideData->m_animGroup, ANIM_BIKE_READY, 2.0);
  LODWORD(v9) = 0;
  if ( v29 )
  {
LABEL_28:
    v5.n64_u32[0] = LODWORD(v29->m_fBlendAmount);
LABEL_29:
    v5.n64_f32[0] = v5.n64_f32[0] + (float)(v29->m_fBlendDelta * (float)(CTimer::ms_fTimeStepNonClipped / 50.0));
    v5.n64_u64[0] = vmin_f32(v5, v7).n64_u64[0];
    v8.n64_f32[0] = 1.0 - v5.n64_f32[0];
    goto LABEL_50;
  }
LABEL_49:
  v8.n64_u32[0] = 1.0;
LABEL_50:
  v73 = v18;
  if ( v21 )
  {
    v5.n64_f32[0] = v21->m_fBlendAmount + (float)(v21->m_fBlendDelta * (float)(CTimer::ms_fTimeStepNonClipped / 50.0));
    v5.n64_u64[0] = vmin_f32(v8, v5).n64_u64[0];
    v8.n64_f32[0] = v8.n64_f32[0] - v5.n64_f32[0];
  }
  v34 = v78;
  if ( v20 )
  {
    v5.n64_f32[0] = v20->m_fBlendAmount + (float)(v20->m_fBlendDelta * (float)(CTimer::ms_fTimeStepNonClipped / 50.0));
    v5.n64_u64[0] = vmin_f32(v8, v5).n64_u64[0];
    v8.n64_f32[0] = v8.n64_f32[0] - v5.n64_f32[0];
  }
  v35 = 1.0;
  v36.n64_u32[0] = 0;
  v37 = pRideData->m_fLeanAngle / v79->fFullAnimAngle;
  if ( *(float *)&v9 == -1.0 )
    v37 = 0.0;
  if ( v37 <= 1.0 )
  {
    v35 = v37;
    if ( v37 < -1.0 )
      v35 = -1.0;
  }
  v38 = CTimer::ms_fTimeStep;
  v39 = powf(0.86, CTimer::ms_fTimeStep);
  v40 = IsPlayer;
  pRideData->m_fAnimLeanLeft = (float)(v35 * (float)(1.0 - v39)) + (float)(v39 * pRideData->m_fAnimLeanLeft);
  if ( IsPlayer )
    v40 = pVehicle->pPassengers[0] == 0;
  if ( v40 )
  {
    v36.n64_u64[0] = v9;
    if ( *(float *)&v9 <= -1.0 )
      goto LABEL_65;
    v36.n64_u32[0] = LODWORD(pRideData->m_fLeanFwd);
    if ( v76 )
    {
      z_low = LOBYTE(v76[1].m_vecTurnFriction.z);
      m_fDistanceFromCameraLastFrame = v76[1].m_VehicleAudioEntity.ScratchSound.m_fDistanceFromCameraLastFrame;
      LOBYTE(v76[1].m_vecTurnFriction.z) = z_low & 0x7F;
      if ( m_fDistanceFromCameraLastFrame > 0.0
        || v76[1].m_VehicleAudioEntity.ScratchSound.m_Doppler > 0.0
        || (v66 = v76->m_pMat->zy, v66 <= 0.0)
        || *(float *)&v76[1].m_VehicleAudioEntity.ScratchSound.m_FrameDelay <= 0.0
        && *(float *)&v76[1].m_VehicleAudioEntity.ScratchSound.m_bCurrentlyInUse <= 0.0 )
      {
        if ( *(float *)&v76[1].m_VehicleAudioEntity.ScratchSound.m_FrameDelay <= 0.0
          && *(float *)&v76[1].m_VehicleAudioEntity.ScratchSound.m_bCurrentlyInUse <= 0.0 )
        {
          zy = v76->m_pMat->zy;
          if ( zy < 0.0
            && (m_fDistanceFromCameraLastFrame > 0.0 || v76[1].m_VehicleAudioEntity.ScratchSound.m_Doppler > 0.0)
            && (float)(v79->fStoppieBalancePoint - zy) > (float)(v79->fStoppieBalancePoint * 0.6) )
          {
            LOBYTE(v76[1].m_vecTurnFriction.z) = z_low | 0x80;
          }
        }
        goto LABEL_139;
      }
      fWheelieBalancePoint = v79->fWheelieBalancePoint;
      v68 = fWheelieBalancePoint - v66;
      if ( (float)(fWheelieBalancePoint - v66) < (float)(fWheelieBalancePoint * 0.5) )
        LOBYTE(v76[1].m_vecTurnFriction.z) = z_low | 0x80;
    }
    else
    {
      if ( !v71 )
        goto LABEL_139;
      if ( *(float *)&v71[1].m_VehicleAudioEntity.m_EngineSounds[6].SoundPtr > 0.0 )
        goto LABEL_139;
      if ( *(float *)&v71[1].m_VehicleAudioEntity.m_EngineSounds[7].EngineSoundType > 0.0 )
        goto LABEL_139;
      v70 = v71->m_pMat->zy;
      if ( v70 <= 0.0
        || *(float *)&v71[1].m_VehicleAudioEntity.m_EngineSounds[7].SoundPtr <= 0.0
        && *(float *)&v71[1].m_VehicleAudioEntity.m_EngineSounds[8].EngineSoundType <= 0.0 )
      {
        goto LABEL_139;
      }
      v68 = v79->fWheelieBalancePoint - v70;
    }
    if ( v68 < 0.15 )
    {
      v5.n64_u32[0] = 0.25;
      v36.n64_u32[0] = vmax_f32(v36, v5).n64_u32[0];
LABEL_145:
      v5.n64_f32[0] = fabsf(v35);
      if ( v5.n64_f32[0] > 0.3 )
      {
        v6.n64_u32[0] = 0;
        v5.n64_f32[0] = (float)((float)(v5.n64_f32[0] + -0.3) / -0.26) + 1.0;
        v36.n64_f32[0] = vmax_f32(v5, v6).n64_f32[0] * v36.n64_f32[0];
      }
      goto LABEL_65;
    }
LABEL_139:
    if ( v25 <= 0.01 )
    {
      if ( v36.n64_f32[0] <= 0.0
        && pVehicle->m_fGasPedal > 0.5
        && v25 < (float)(pVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 0.3) )
      {
        v5.n64_u32[0] = -1097229926;
        v36.n64_u32[0] = vmin_f32(v36, v5).n64_u32[0];
      }
    }
    else
    {
      v5.n64_u32[0] = 1036831949;
      v36.n64_u32[0] = vmax_f32(v36, v5).n64_u32[0];
    }
    goto LABEL_145;
  }
  if ( v76 )
    LOBYTE(v76[1].m_vecTurnFriction.z) &= ~0x80u;
  if ( !IsPlayer )
  {
    v42 = 0.0;
    goto LABEL_67;
  }
LABEL_65:
  v41 = powf(0.89, v38);
  v42 = (float)(v36.n64_f32[0] * (float)(1.0 - v41)) + (float)(v41 * pRideData->m_fAnimLeanFwd);
LABEL_67:
  m_fAnimLeanLeft = pRideData->m_fAnimLeanLeft;
  v44 = 1.0;
  p_m_fAnimLeanFwd = &pRideData->m_fAnimLeanFwd;
  v46 = v77;
  v47 = v80;
  v48 = 0.0;
  pRideData->m_fAnimLeanFwd = v42;
  if ( fabsf(m_fAnimLeanLeft) > 0.56 || !IsPlayer )
  {
LABEL_71:
    if ( IsPlayer )
      goto LABEL_72;
LABEL_79:
    if ( !v78 )
      goto LABEL_89;
    goto LABEL_80;
  }
  v48 = fabsf(v42);
  if ( v48 > 0.56 )
  {
    v48 = 1.0;
    v44 = 0.0;
    goto LABEL_71;
  }
  v53 = sqrtf((float)(v42 * v42) + (float)(m_fAnimLeanLeft * m_fAnimLeanLeft));
  if ( v53 > 0.01 )
  {
    m_fAnimLeanLeft = m_fAnimLeanLeft / v53;
    v48 = fabsf(v42 / v53);
  }
  v44 = fabsf(m_fAnimLeanLeft);
  if ( !IsPlayer )
    goto LABEL_79;
LABEL_72:
  v49 = v73;
  if ( v73 )
  {
    if ( v77 )
      goto LABEL_74;
  }
  else
  {
    v49 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pRideData->m_animGroup, ANIM_BIKE_LEANF);
    if ( v77 )
      goto LABEL_74;
  }
  v46 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pRideData->m_animGroup, ANIM_BIKE_LEANB);
LABEL_74:
  v50 = v8.n64_f32[0] * v48;
  if ( *p_m_fAnimLeanFwd >= 0.0 )
  {
    m_pAnimBlendHierarchy = v49->m_pAnimBlendHierarchy;
    v49->m_fBlendAmount = v50;
    CAnimBlendAssociation::SetCurrentTime(v49, m_pAnimBlendHierarchy->m_fTotalTime * *p_m_fAnimLeanFwd);
    v52 = v49;
  }
  else
  {
    v51 = v46->m_pAnimBlendHierarchy;
    v46->m_fBlendAmount = v50;
    CAnimBlendAssociation::SetCurrentTime(v46, -(float)(v51->m_fTotalTime * *p_m_fAnimLeanFwd));
    v52 = v46;
    v46 = v49;
  }
  v52->m_bitsFlag &= ~1u;
  v46->m_fBlendAmount = 0.0;
  if ( !v78 )
  {
LABEL_89:
    v34 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pRideData->m_animGroup, ANIM_BIKE_LEFT);
    if ( v80 )
      goto LABEL_81;
    goto LABEL_90;
  }
LABEL_80:
  if ( v80 )
    goto LABEL_81;
LABEL_90:
  v47 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pRideData->m_animGroup, ANIM_BIKE_RIGHT);
LABEL_81:
  v54 = v8.n64_f32[0] * v44;
  if ( pRideData->m_fAnimLeanLeft >= 0.0 )
  {
    v57 = v47->m_pAnimBlendHierarchy;
    v47->m_fBlendAmount = v54;
    CAnimBlendAssociation::SetCurrentTime(v47, v57->m_fTotalTime * pRideData->m_fAnimLeanLeft);
    v56 = v47;
  }
  else
  {
    v55 = v34->m_pAnimBlendHierarchy;
    v34->m_fBlendAmount = v54;
    CAnimBlendAssociation::SetCurrentTime(v34, -(float)(v55->m_fTotalTime * pRideData->m_fAnimLeanLeft));
    v56 = v34;
    v34 = v47;
  }
  v56->m_bitsFlag &= ~1u;
  v34->m_fBlendAmount = 0.0;
  if ( v25 > 0.3 )
  {
    pFrame = pPed->m_aPedFrames[2]->_anon_1.pFrame;
    v59 = v25 * -6.0;
    v60 = rand();
    v61 = (float)(v25 * 6.0) - (float)(v25 * -6.0);
    RtQuatRotate(
      (RtQuat_0 *)pFrame,
      &CPedIK::XaxisIK,
      v59 + (float)(v61 * (float)((float)v60 * 4.6566e-10)),
      rwCOMBINEPOSTCONCAT);
    v62 = rand();
    RtQuatRotate(
      (RtQuat_0 *)pFrame,
      &CPedIK::YaxisIK,
      v59 + (float)(v61 * (float)((float)v62 * 4.6566e-10)),
      rwCOMBINEPOSTCONCAT);
    *((_DWORD *)&pPed->m_nPedFlags + 1) |= 0x4000u;
  }
}
// 567B9E: variable 'v5' is possibly undefined
// 567B9E: variable 'v7' is possibly undefined
// 567D10: variable 'v8' is possibly undefined
// 56806C: variable 'v9' is possibly undefined
// 5683B6: variable 'v6' is possibly undefined

//----- (005683F8) --------------------------------------------------------
void __fastcall CBike::FixHandsToBars(CBike *this, CPed *pPed)
{
  int m_nFixRightHand; // r0
  bool v5; // zf
  char v6; // r5
  RwFrame_0 *v7; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  int m_nModelIndex; // r0
  uint32 m_hashKey; // r1
  __int64 v11; // d16
  RwReal v12; // r1
  CVector **v13; // r0
  RwInt32 v14; // r4
  RwMatrix *v15; // r4
  CVector *v16; // r0
  __int64 v17; // d16
  float xx; // s16
  float yx; // s20
  float zx; // s18
  RwInt32 v21; // r4
  RwMatrix *v22; // r4
  float x; // s0
  float y; // s2
  float z; // s4
  float v26; // s16
  float v27; // s20
  float v28; // s18
  RwInt32 v29; // r4
  RwMatrix *v30; // r4
  RwReal v31; // s2
  RwReal v32; // s4
  RwInt32 v33; // r4
  RwMatrix *v34; // r4
  RwReal v35; // s2
  RwReal v36; // s4
  RwInt32 v37; // r4
  RwMatrix *v38; // r4
  RwReal v39; // s4
  RwReal v40; // s0
  RwInt32 v41; // r4
  RwMatrix *v42; // r4
  float v43; // s16
  RwReal v44; // s4
  RwReal v45; // s2
  RwInt32 v46; // r4
  RwMatrix *v47; // r4
  RwReal v48; // s2
  RwReal v49; // s4
  float v50; // s16
  float v51; // s20
  float v52; // s18
  RwInt32 v53; // r4
  RwMatrix *v54; // r4
  float v55; // s0
  float v56; // s2
  float v57; // s4
  float v58; // s16
  float v59; // s20
  float v60; // s18
  RwInt32 v61; // r4
  RwMatrix *v62; // r4
  RwReal v63; // s2
  RwReal v64; // s4
  RwInt32 v65; // r4
  RwMatrix *v66; // r4
  RwReal v67; // s2
  RwReal v68; // s4
  RwInt32 v69; // r4
  RwMatrix *v70; // r4
  RwReal v71; // s4
  RwReal v72; // s0
  RwInt32 v73; // r4
  RwMatrix *v74; // r4
  float v75; // s16
  RwReal v76; // s4
  RwReal v77; // s2
  RwInt32 v78; // r4
  RwMatrix *v79; // r4
  RwReal v80; // s2
  RwReal v81; // s4
  CVector v82; // [sp+0h] [bp-140h] BYREF
  CVector v; // [sp+10h] [bp-130h] BYREF
  CVector v84; // [sp+20h] [bp-120h] BYREF
  CMatrix v85; // [sp+30h] [bp-110h] BYREF
  CMatrix m; // [sp+78h] [bp-C8h] BYREF
  CMatrix v87; // [sp+C0h] [bp-80h] BYREF

  m_nFixRightHand = this->m_nFixRightHand;
  v5 = m_nFixRightHand == 0;
  if ( !m_nFixRightHand )
    v5 = this->m_nFixLeftHand == 0;
  if ( !v5 )
  {
    v6 = 0;
    m.m_pRwMat = 0;
    m.m_owner = 0;
    v85.m_pRwMat = 0;
    v85.m_owner = 0;
    v7 = this->m_aBikeNodes[1];
    if ( v7 )
    {
      CMatrix::Attach(&v85, &v7->modelling, 0);
      CMatrix::operator=(&m, this->m_pMat);
      operator*(&v87, &m, &v85);
      CMatrix::operator=(&m, &v87);
      CMatrix::~CMatrix(&v87);
      AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
      m_nModelIndex = this->m_nModelIndex;
      m_hashKey = CModelInfo::ms_modelInfoPtrs[m_nModelIndex][2].m_hashKey;
      v11 = *(_QWORD *)(m_hashKey + 120);
      v12 = *(float *)(m_hashKey + 128);
      *(_QWORD *)&v84.x = v11;
      v84.z = v12;
      if ( *(float *)&v11 == 0.0 )
        v6 = 1;
      if ( ((unsigned __int8)v6 & (*((float *)&v11 + 1) == 0.0)) != 0 && v84.z == 0.0 )
      {
        if ( m_nModelIndex == 509 )
        {
          v13 = &vecChopperHandleBarPos_ptr;
        }
        else if ( m_nModelIndex == 510 )
        {
          v13 = &vecMtbHandleBarPos_ptr;
        }
        else
        {
          v13 = &vecBmxHandleBarPos_ptr;
        }
        v16 = *v13;
        v17 = *(_QWORD *)&v16->x;
        v84.z = v16->z;
        *(_QWORD *)&v84.x = v17;
      }
      else
      {
        v14 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 24);
        v15 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v14];
        TestMatrix(v15);
        v = vecTweakHandleBarPos2;
        CMatrix::CMatrix(&v87, v15, 0);
        Multiply3x3(&v82, &v87, &v);
        v = v82;
        Multiply3x3(&v82, &v, &m);
        v = v82;
        v84.x = v82.x + v84.x;
        v84.y = v82.y + v84.y;
        v84.z = v82.z + v84.z;
        CMatrix::~CMatrix(&v87);
      }
      if ( this->m_nFixRightHand )
      {
        operator*((CVector *)&v87, &m, &v84);
        xx = v87.xx;
        yx = v87.yx;
        zx = v87.zx;
        v21 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 24);
        v22 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v21];
        TestMatrix(v22);
        x = v22->pos.x;
        y = v22->pos.y;
        z = v22->pos.z;
        v26 = xx - x;
        v27 = yx - y;
        v28 = zx - z;
        v22->pos.x = x + v26;
        v22->pos.y = y + v27;
        v22->pos.z = z + v28;
        v29 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 25);
        v30 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v29];
        TestMatrix(v30);
        v31 = v27 + v30->pos.y;
        v32 = v28 + v30->pos.z;
        v30->pos.x = v26 + v30->pos.x;
        v30->pos.y = v31;
        v30->pos.z = v32;
        v33 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 26);
        v34 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v33];
        TestMatrix(v34);
        v35 = v27 + v34->pos.y;
        v36 = v28 + v34->pos.z;
        v34->pos.x = v26 + v34->pos.x;
        v34->pos.y = v35;
        v34->pos.z = v36;
        v37 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 23);
        v38 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v37];
        TestMatrix(v38);
        v39 = (float)(v28 * 0.667) + v38->pos.z;
        v40 = (float)(v27 * 0.667) + v38->pos.y;
        v38->pos.x = (float)(v26 * 0.667) + v38->pos.x;
        v38->pos.y = v40;
        v38->pos.z = v39;
        v41 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 22);
        v42 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v41];
        TestMatrix(v42);
        v43 = v26 * 0.333;
        v44 = (float)(v28 * 0.333) + v42->pos.z;
        v45 = (float)(v27 * 0.333) + v42->pos.y;
        v42->pos.x = v43 + v42->pos.x;
        v42->pos.y = v45;
        v42->pos.z = v44;
        if ( CPed::IsPlayer(pPed) )
        {
          v46 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 301);
          v47 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v46];
          TestMatrix(v47);
          v48 = (float)(v27 * 0.333) + v47->pos.y;
          v49 = (float)(v28 * 0.333) + v47->pos.z;
          v47->pos.x = v43 + v47->pos.x;
          v47->pos.y = v48;
          v47->pos.z = v49;
        }
      }
      if ( this->m_nFixLeftHand )
      {
        v84.x = -v84.x;
        operator*((CVector *)&v87, &m, &v84);
        v50 = v87.xx;
        v51 = v87.yx;
        v52 = v87.zx;
        v53 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 34);
        v54 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v53];
        TestMatrix(v54);
        v55 = v54->pos.x;
        v56 = v54->pos.y;
        v57 = v54->pos.z;
        v58 = v50 - v55;
        v59 = v51 - v56;
        v60 = v52 - v57;
        v54->pos.x = v55 + v58;
        v54->pos.y = v56 + v59;
        v54->pos.z = v57 + v60;
        v61 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 35);
        v62 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v61];
        TestMatrix(v62);
        v63 = v59 + v62->pos.y;
        v64 = v60 + v62->pos.z;
        v62->pos.x = v58 + v62->pos.x;
        v62->pos.y = v63;
        v62->pos.z = v64;
        v65 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 36);
        v66 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v65];
        TestMatrix(v66);
        v67 = v59 + v66->pos.y;
        v68 = v60 + v66->pos.z;
        v66->pos.x = v58 + v66->pos.x;
        v66->pos.y = v67;
        v66->pos.z = v68;
        v69 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 33);
        v70 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v69];
        TestMatrix(v70);
        v71 = (float)(v60 * 0.75) + v70->pos.z;
        v72 = (float)(v59 * 0.75) + v70->pos.y;
        v70->pos.x = (float)(v58 * 0.75) + v70->pos.x;
        v70->pos.y = v72;
        v70->pos.z = v71;
        v73 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 32);
        v74 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v73];
        TestMatrix(v74);
        v75 = v58 * 0.4;
        v76 = (float)(v60 * 0.4) + v74->pos.z;
        v77 = (float)(v59 * 0.4) + v74->pos.y;
        v74->pos.x = v75 + v74->pos.x;
        v74->pos.y = v77;
        v74->pos.z = v76;
        if ( CPed::IsPlayer(pPed) )
        {
          v78 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 302);
          v79 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v78];
          TestMatrix(v79);
          v80 = (float)(v59 * 0.4) + v79->pos.y;
          v81 = (float)(v60 * 0.4) + v79->pos.z;
          v79->pos.x = v75 + v79->pos.x;
          v79->pos.y = v80;
          v79->pos.z = v81;
        }
      }
      *(_WORD *)&this->m_nFixLeftHand = 0;
    }
    CMatrix::~CMatrix(&v85);
    CMatrix::~CMatrix(&m);
  }
}
// 675F08: using guessed type CVector *vecBmxHandleBarPos_ptr;
// 676714: using guessed type CVector *vecMtbHandleBarPos_ptr;
// 6788AC: using guessed type CVector *vecChopperHandleBarPos_ptr;

//----- (00568978) --------------------------------------------------------
float __fastcall CBike::FindWheelWidth(CBike *this, bool bRear)
{
  return 0.15;
}

//----- (00568986) --------------------------------------------------------
bool __fastcall CBike::IsDoorReady(const CBike *this, eDoors DoorID)
{
  return 1;
}

//----- (0056898A) --------------------------------------------------------
bool __fastcall CBike::IsDoorFullyOpen(const CBike *this, eDoors DoorID)
{
  return 0;
}

//----- (0056898E) --------------------------------------------------------
bool __fastcall CBike::IsDoorClosed(const CBike *this, eDoors DoorID)
{
  return 0;
}

//----- (00568992) --------------------------------------------------------
bool __fastcall CBike::IsDoorMissing(const CBike *this, eDoors DoorID)
{
  return 1;
}

//----- (00568996) --------------------------------------------------------
float __fastcall CVehicle::GetDooorAngleOpenRatio(const CVehicle *this, uint32 iDoorID)
{
  return 0.0;
}

//----- (0056899A) --------------------------------------------------------
bool __fastcall CBike::IsDoorReady(const CBike *this, uint32 iDoorID)
{
  return 1;
}

//----- (0056899E) --------------------------------------------------------
bool __fastcall CBike::IsDoorFullyOpen(const CBike *this, uint32 iDoorID)
{
  return 0;
}

//----- (005689A2) --------------------------------------------------------
bool __fastcall CBike::IsDoorClosed(const CBike *this, uint32 DoorID)
{
  return 0;
}

//----- (005689A6) --------------------------------------------------------
bool __fastcall CBike::IsDoorMissing(const CBike *this, uint32 iDoorID)
{
  return 1;
}

//----- (005689AA) --------------------------------------------------------
bool __fastcall CVehicle::IsOpenTopCar(const CVehicle *this)
{
  return 0;
}

//----- (005689B0) --------------------------------------------------------
CRideAnimData *__fastcall CBike::GetRideAnimData(CBike *this)
{
  return &this->RideAnimData;
}

//----- (005689B6) --------------------------------------------------------
CVector *__fastcall CVehicle::AddMovingCollisionSpeed(CVector *retstr, CVehicle *this, CVector *vecOffset)
{
  retstr->x = 0.0;
  retstr->y = 0.0;
  retstr->z = 0.0;
  return retstr;
}

//----- (005689C0) --------------------------------------------------------
float __fastcall CBike::GetHeightAboveRoad(const CBike *this)
{
  return this->m_fHeightAboveRoad;
}

//----- (005689C6) --------------------------------------------------------
int __fastcall CBike::GetNumContactWheels(CBike *this)
{
  return this->nNoOfContactWheels;
}

//----- (005689CC) --------------------------------------------------------
bool __fastcall CVehicle::SetTowLink(CVehicle *this, CVehicle *pTractor, bool bWarpPosition)
{
  return 0;
}

//----- (005689D0) --------------------------------------------------------
bool __fastcall CVehicle::BreakTowLink(CVehicle *this)
{
  return 0;
}

//----- (005689D4) --------------------------------------------------------
void __fastcall CBmx::CBmx(CBmx *this, int nModelIndex, UInt8 CreatedBy)
{
  CBaseModelInfo *v5; // r0
  AssocGroupId m_firstAssocGroup; // r0
  RwFrame_0 *v7; // r6
  __int64 v8; // d16
  __int64 v9; // d17
  __int64 v10; // d18
  __int64 v11; // d19
  __int64 v12; // d20
  __int64 v13; // d21
  __int64 v14; // d23
  RwFrame_0 *parent; // r4
  RwFrame_0 *v16; // r6
  float y; // s16
  __int64 v18; // d16
  __int64 v19; // d17
  __int64 v20; // d18
  __int64 v21; // d19
  __int64 v22; // d20
  __int64 v23; // d21
  __int64 v24; // d23
  RwFrame_0 *v25; // r4
  float v26; // s2
  RwMatrix v27; // [sp+0h] [bp-68h] BYREF

  CBike::CBike(this, nModelIndex, CreatedBy);
  this->_vptr$CPlaceable = (int (**)(void))&off_66D908;
  v5 = CModelInfo::ms_modelInfoPtrs[nModelIndex];
  this->m_vehicleType = 10;
  m_firstAssocGroup = CAnimManager::ms_aAnimBlocks[(*((int (__fastcall **)(CBaseModelInfo *))v5->_vptr$CBaseModelInfo
                                                    + 15))(v5)].m_firstAssocGroup;
  *(_QWORD *)&this->m_fControlJump = 0LL;
  *(_QWORD *)&this->m_fSprintLeanAngle = 0LL;
  *(_WORD *)&this->m_nFixLeftHand = 0;
  this->m_bIsFreewheeling = 0;
  this->m_fPedalAngleL = 0.0;
  this->m_fPedalAngleR = 0.0;
  if ( (unsigned int)(m_firstAssocGroup - 7) > 2 )
    m_firstAssocGroup = ANIM_BMX_PED;
  this->RideAnimData.m_animGroup = m_firstAssocGroup;
  v7 = this->m_aBikeNodes[4];
  v8 = *(_QWORD *)&v7->modelling.right.x;
  v9 = *(_QWORD *)&v7->modelling.right.z;
  v10 = *(_QWORD *)&v7->modelling.up.x;
  v11 = *(_QWORD *)&v7->modelling.up.z;
  v12 = *(_QWORD *)&v7->modelling.at.x;
  v13 = *(_QWORD *)&v7->modelling.at.z;
  v14 = *(_QWORD *)&v7->modelling.pos.z;
  *(_QWORD *)&v27.pos.x = *(_QWORD *)&v7->modelling.pos.x;
  *(_QWORD *)&v27.pos.z = v14;
  *(_QWORD *)&v27.at.x = v12;
  *(_QWORD *)&v27.at.z = v13;
  *(_QWORD *)&v27.right.x = v8;
  *(_QWORD *)&v27.right.z = v9;
  *(_QWORD *)&v27.up.x = v10;
  *(_QWORD *)&v27.up.z = v11;
  parent = (RwFrame_0 *)v7->object.parent;
  while ( parent )
  {
    RwMatrixTransform(&v27, &parent->modelling, rwCOMBINEPOSTCONCAT);
    parent = (RwFrame_0 *)parent->object.parent;
    if ( parent == v7 )
      parent = 0;
  }
  v16 = this->m_aBikeNodes[5];
  y = v27.pos.y;
  v18 = *(_QWORD *)&v16->modelling.right.x;
  v19 = *(_QWORD *)&v16->modelling.right.z;
  v20 = *(_QWORD *)&v16->modelling.up.x;
  v21 = *(_QWORD *)&v16->modelling.up.z;
  v22 = *(_QWORD *)&v16->modelling.pos.x;
  v23 = *(_QWORD *)&v16->modelling.pos.z;
  v24 = *(_QWORD *)&v16->modelling.at.z;
  *(_QWORD *)&v27.at.x = *(_QWORD *)&v16->modelling.at.x;
  *(_QWORD *)&v27.at.z = v24;
  *(_QWORD *)&v27.pos.x = v22;
  *(_QWORD *)&v27.pos.z = v23;
  *(_QWORD *)&v27.right.x = v18;
  *(_QWORD *)&v27.right.z = v19;
  *(_QWORD *)&v27.up.x = v20;
  *(_QWORD *)&v27.up.z = v21;
  v25 = (RwFrame_0 *)v16->object.parent;
  while ( v25 )
  {
    RwMatrixTransform(&v27, &v25->modelling, rwCOMBINEPOSTCONCAT);
    v25 = (RwFrame_0 *)v25->object.parent;
    if ( v25 == v16 )
      v25 = 0;
  }
  v26 = y / (float)(y - v27.pos.y);
  this->m_fMidWheelDistY = y - v27.pos.y;
  this->m_fMidWheelFracY = v26;
}
// 66D908: using guessed type void *;

//----- (00568B30) --------------------------------------------------------
void __fastcall CBmx::~CBmx(CBmx *this)
{
  this->_vptr$CPlaceable = (int (**)(void))&off_66D908;
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  sub_19BF38(this);
}
// 66D908: using guessed type void *off_66D908;

//----- (00568B58) --------------------------------------------------------
void __fastcall CBmx::~CBmx(CBmx *this)
{
  void *v2; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_66D908;
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CBike::~CBike(this);
  sub_199F98(v2);
}
// 568B7A: variable 'v2' is possibly undefined
// 66D908: using guessed type void *off_66D908;

//----- (00568B84) --------------------------------------------------------
void __fastcall CBmx::ProcessControl(CBmx *this)
{
  float v2; // s4
  float v3; // s6
  float v4; // s0
  float v5; // s2
  CPed *pDriver; // r0
  CAnimBlendAssociation *Association; // r0
  float v8; // s0
  float *v9; // r1
  float v10; // s16
  float v11; // s0
  float *p_m_fSprintLeanAngle; // r0
  float v13; // s0
  float *v14; // r3
  float v15; // s16
  CAnimBlendAssociation *v16; // r0
  float m_fBlendAmount; // s0

  CBike::ProcessControl(this);
  if ( (*(_BYTE *)&this->m_nFlags & 0x40) == 0 )
  {
    v2 = 0.5;
    v3 = 0.5;
    v4 = fHackedBunnyHopTimer + (float)(CTimer::ms_fTimeStep / -50.0);
    if ( v4 < 0.0 )
      v3 = 0.0;
    if ( v4 < 0.5 )
      v2 = v3;
    v5 = v2;
    if ( v4 < 0.5 )
      v5 = fHackedBunnyHopTimer + (float)(CTimer::ms_fTimeStep / -50.0);
    if ( v4 < 0.0 )
      v5 = v2;
    fHackedBunnyHopTimer = v5;
    if ( *(_BYTE *)&this->m_info <= 7u )
    {
      pDriver = this->pDriver;
      if ( pDriver )
      {
        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pDriver->m_pRwObject, 0xD0u);
        if ( Association && (v8 = Association->m_fBlendAmount, v8 > 0.01) )
        {
          v9 = &BMX_SPRINT_LEANMULT;
          if ( this->m_nModelIndex == 510 )
            v9 = &MTB_SPRINT_LEANMULT;
          v10 = v8 * *v9;
          v11 = sinf(
                  BMX_SPRINT_LEANSTART
                + (float)((float)(Association->m_fCurrentTime * 6.2832)
                        / Association->m_pAnimBlendHierarchy->m_fTotalTime));
          p_m_fSprintLeanAngle = &this->m_fSprintLeanAngle;
          v13 = v10 * v11;
        }
        else
        {
          v14 = &BMX_PEDAL_LEANMULT;
          if ( this->m_nModelIndex == 510 )
            v14 = &MTB_PEDAL_LEANMULT;
          v15 = *v14;
          v16 = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->pDriver->m_pRwObject, 0xCFu);
          if ( v16 )
          {
            m_fBlendAmount = v16->m_fBlendAmount;
            if ( m_fBlendAmount > 0.01 )
              this->RideAnimData.m_fLeanAngle = this->RideAnimData.m_fLeanAngle
                                              + (float)((float)(v15 * m_fBlendAmount)
                                                      * sinf(
                                                          BMX_PEDAL_LEANSTART
                                                        + (float)((float)(v16->m_fCurrentTime * 6.2832)
                                                                / v16->m_pAnimBlendHierarchy->m_fTotalTime)));
          }
          p_m_fSprintLeanAngle = &this->m_fSprintLeanAngle;
          v13 = this->m_fSprintLeanAngle * 0.95;
        }
        *p_m_fSprintLeanAngle = v13;
      }
    }
  }
}

//----- (00568D54) --------------------------------------------------------
bool __fastcall CBmx::ProcessAI(CBmx *this, uint32 *nProcContFlags)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  unsigned int m_info; // r3
  CBaseModelInfo *v9; // r6
  CPed *pDriver; // r0
  CPad *PadFromPlayer; // r8
  CPlayerPed *v12; // r9
  float m_fLeanFwd; // s2
  tBikeHandlingData *pBikeHandling; // r0
  float y; // s0
  float v16; // s0
  float v17; // s4
  float m_fGasPedal; // s4
  float v19; // s4
  float v20; // s6
  tHandlingData *pHandling; // r0
  float v22; // s0
  UInt8 m_nDriveWheelsOnGround; // r2
  int v24; // r0
  CBike::CBikeFlags v25; // r1
  CBike::CBikeFlags v26; // r2
  CVehicle::CVehicleFlags v27; // r0
  float v28; // s0
  float z; // s4
  float v30; // s2
  int v31; // r0
  int v32; // r1
  int v33; // r1
  CBike::CBikeFlags v34; // r0
  CBike::CBikeFlags v35; // r0
  float *p_m_fBrakePedal; // r0
  unsigned int v37; // r0
  CBike::CBikeFlags *p_m_nBikeFlags; // r3
  float *v39; // r0
  float m_fControlPedaling; // s0
  float v41; // s2
  CPed *v42; // r0
  CPed **p_pDriver; // r6
  CAnimBlendAssociation *v44; // r0
  CAnimBlendAssociation *v45; // r5
  CAnimBlendAssociation *v46; // r0
  float m_fBlendAmount; // s0
  char m_nVehicleFlags; // r0
  CMatrix *v49; // r0
  float v50; // s16
  float xy; // s0
  float yy; // s2
  float zy; // s4
  float v54; // s6
  float FatAndMuscleModifier; // s0
  CMatrix *v56; // r0
  float v57; // s6
  float v58; // s6
  CPed *v60; // r2
  bool v61; // zf
  int *v62; // r3
  float v63; // s0
  float m_fBrakePedal; // s4
  float v65; // s2
  CMatrix *m_pMat; // r0
  float v67; // s2
  float v68; // s18
  int SteeringLeftRight; // s0
  CMatrix *v70; // r0
  float v71; // s0
  float *p_m_fSteerAngle; // r5
  CPad *v73; // r0
  _BOOL4 v74; // r6
  CAnimBlendAssociation *Association; // r5
  float m_fSprintControlCounter; // r0
  float ButtonSprintResults; // r0
  CBike::CBikeFlags m_nBikeFlags; // r0
  float32x2_t v79; // d0
  float v80; // s0
  _BOOL4 AccelerateJustDown; // r0
  float *p_m_fControlPedaling; // r1
  CPad *Pad; // r0
  CVector vecOffset; // [sp+0h] [bp-38h]
  CVector v85; // 0:r1.12
  CVector v86; // 0:r1.12
  CVector v87; // 0:r1.12

  m_info = (unsigned __int8)this->m_info;
  v9 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  *(_WORD *)((char *)&this->AutoPilot + 75) &= 0xFFFCu;
  this->m_bIsFreewheeling = 0;
  switch ( m_info >> 3 )
  {
    case 0u:
      *nProcContFlags += 2;
      pDriver = this->pDriver;
      *(_BYTE *)&this->m_nBikeFlags &= ~8u;
      if ( !pDriver || !CPed::IsPlayer(pDriver) )
        goto LABEL_32;
      (*((void (__fastcall **)(CBmx *, _DWORD))this->_vptr$CPlaceable + 25))(this, LOBYTE(this->pDriver->m_nPedType));
      PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
      v12 = (CPlayerPed *)this->pDriver;
      m_fLeanFwd = this->RideAnimData.m_fLeanFwd;
      pBikeHandling = this->pBikeHandling;
      y = this->pHandling->CentreOfMass.y;
      if ( m_fLeanFwd >= 0.0 )
      {
        v16 = y + (float)(m_fLeanFwd * pBikeHandling->fLeanFwdCOMMult);
        m_fBrakePedal = this->m_fBrakePedal;
        this->m_vecCOM.y = v16;
        if ( m_fBrakePedal < 0.0 || !this->nNoOfContactWheels )
        {
          v4.n64_f32[0] = (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                        + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z);
          v65 = (float)(m_fLeanFwd * this->m_fTurnMass) * pBikeHandling->fLeanFwdForceMult;
LABEL_82:
          v4.n64_f32[0] = sqrtf(v4.n64_f32[0]);
          v5.n64_u32[0] = 1036831949;
          v4.n64_u64[0] = vmin_f32(v4, v5).n64_u64[0];
          m_pMat = this->m_pMat;
          v67 = CTimer::ms_fTimeStep * (float)(v65 * v4.n64_f32[0]);
          v86.x = -(float)(v67 * m_pMat->xz);
          v86.y = -(float)(v67 * m_pMat->yz);
          v86.z = -(float)(v67 * m_pMat->zz);
          vecOffset.x = this->m_vecCOM.x + m_pMat->xy;
          vecOffset.y = v16 + m_pMat->yy;
          vecOffset.z = this->m_vecCOM.z + m_pMat->zy;
          CPhysical::ApplyTurnForce(this, v86, vecOffset);
        }
      }
      else
      {
        v16 = y + (float)(m_fLeanFwd * pBikeHandling->fLeanBakCOMMult);
        v17 = this->m_fBrakePedal;
        this->m_vecCOM.y = v16;
        if ( v17 == 0.0 && (*(_BYTE *)&this->m_nVehicleFlags & 0x20) == 0 || !this->nNoOfContactWheels )
        {
          m_fGasPedal = this->m_fGasPedal;
          if ( this->m_nModelIndex == 468 )
          {
            v19 = m_fGasPedal * 0.7;
            v20 = 0.3;
          }
          else
          {
            v20 = 0.5;
            v19 = m_fGasPedal * 0.5;
          }
          v65 = (float)((float)((float)(v19 + v20) * m_fLeanFwd) * this->m_fTurnMass) * pBikeHandling->fLeanBakForceMult;
          v4.n64_f32[0] = (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)
                        + (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y));
          goto LABEL_82;
        }
      }
      CEntity::PruneReferences(this);
      if ( *(_BYTE *)&this->m_info <= 7u )
        CVehicle::DoDriveByShootings(this);
      CBike::DoSoftGroundResistance(this, nProcContFlags);
      if ( this->m_aWheelRatios[0] == 1.0
        && this->m_aWheelRatios[1] == 1.0
        && this->m_aWheelRatios[2] == 1.0
        && this->m_aWheelRatios[3] == 1.0 )
      {
        if ( (v68 = (float)((float)(this->m_vecTurnSpeed.x * this->m_pMat->xz)
                          + (float)(this->m_vecTurnSpeed.y * this->m_pMat->yz))
                  + (float)(this->m_vecTurnSpeed.z * this->m_pMat->zz),
              v68 < 0.04)
          && CPad::GetSteeringLeftRight(PadFromPlayer) < 0
          || v68 > -0.04 && CPad::GetSteeringLeftRight(PadFromPlayer) >= 1 )
        {
          SteeringLeftRight = CPad::GetSteeringLeftRight(PadFromPlayer);
          v70 = this->m_pMat;
          v71 = this->m_fTurnMass
              * (float)((float)(CTimer::ms_fTimeStep * (float)((float)SteeringLeftRight * 0.0078125)) * 0.002);
          v87.x = v70->xx * v71;
          v87.y = v70->yx * v71;
          v87.z = v71 * v70->zx;
          CPhysical::ApplyTurnForce(this, v87, *(CVector *)&v70->xy);
        }
      }
      if ( fHackedBunnyHopTimer == 0.0 )
        CBmx::ProcessBunnyHop(this);
      p_m_fSteerAngle = &this->m_fSteerAngle;
      if ( fabsf(this->m_fSteerAngle) < 0.0001 )
        *p_m_fSteerAngle = 0.0;
      v73 = CPlayerPed::GetPadFromPlayer(v12);
      if ( CPad::GetAccelerate(v73) )
        v74 = *p_m_fSteerAngle == 0.0;
      else
        v74 = 0;
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->pDriver->m_pRwObject, 0xD0u);
      if ( CPlayerPed::ControlButtonSprint(v12, SPRINT_ON_BMX) > 1.2
        || (ButtonSprintResults = CPlayerPed::GetButtonSprintResults(v12, SPRINT_ON_BMX), Association)
        && ButtonSprintResults > 1.0
        && Association->m_fBlendAmount > 0.5 )
      {
        *(_BYTE *)&this->m_nBikeFlags |= 0x20u;
        m_fSprintControlCounter = v12->m_pPlayerData->m_fSprintControlCounter;
LABEL_103:
        this->m_fControlPedaling = m_fSprintControlCounter;
        goto LABEL_119;
      }
      if ( v74 )
      {
        m_nBikeFlags = this->m_nBikeFlags;
        this->m_fControlPedaling = 5.0001;
        this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags | 0x20);
        goto LABEL_119;
      }
      v3.n64_u32[0] = 0.5;
      v2.n64_f32[0] = (float)((float)((float)CPad::GetAccelerate(PadFromPlayer) / -255.0) * 0.5) + 1.0;
      v79.n64_u64[0] = vmax_f32(v2, v3).n64_u64[0];
      CPlayerPed::HandleSprintEnergy(v12, 0, v79.n64_f32[0]);
      if ( CPlayerPed::GetButtonSprintResults(v12, SPRINT_ON_BMX) > 0.0 )
      {
        v80 = this->m_fGasPedal;
        this->m_fControlPedaling = 4.9;
        if ( v80 == 0.0 && this->m_fBrakePedal == 0.0 )
          this->m_fGasPedal = 1.0;
        goto LABEL_119;
      }
      if ( v12->m_pPlayerData->m_fSprintEnergy >= 0.0 )
      {
        m_fSprintControlCounter = 0.0;
        goto LABEL_103;
      }
      AccelerateJustDown = CPad::GetAccelerateJustDown(PadFromPlayer);
      p_m_fControlPedaling = &this->m_fControlPedaling;
      if ( AccelerateJustDown )
      {
        *p_m_fControlPedaling = 4.9;
      }
      else
      {
        v4.n64_u32[0] = 0;
        v79.n64_f32[0] = *p_m_fControlPedaling + -0.4;
        *(_DWORD *)p_m_fControlPedaling = vmax_f32(v79, v4).n64_u32[0];
      }
LABEL_119:
      CStats::UpdateStatsWhenCycling((*(_BYTE *)&this->m_nBikeFlags & 0x20) != 0, this);
      if ( (unsigned __int8)((*((_BYTE *)&this->CVehicle + 1202) & 7) - 1) <= 1u )
      {
        Pad = CPad::GetPad(0);
        if ( CPad::UseBomb(Pad) )
          CVehicle::ActivateBomb(this);
      }
LABEL_32:
      v42 = this->pDriver;
      if ( !v42 )
        goto LABEL_52;
      p_pDriver = &this->pDriver;
      v44 = RpAnimBlendClumpGetAssociation((RpClump_0 *)v42->m_pRwObject, 0xC7u);
      v45 = v44;
      if ( !v44 || v44->m_fBlendAmount < 0.5 )
        v45 = RpAnimBlendClumpGetAssociation((RpClump_0 *)(*p_pDriver)->m_pRwObject, 0xC6u);
      v46 = RpAnimBlendClumpGetAssociation((RpClump_0 *)(*p_pDriver)->m_pRwObject, 0xCAu);
      if ( v46 )
      {
        m_fBlendAmount = v46->m_fBlendAmount;
        if ( m_fBlendAmount >= 0.5 )
        {
LABEL_40:
          if ( m_fBlendAmount >= 0.5 )
            goto LABEL_42;
          goto LABEL_41;
        }
      }
      v46 = RpAnimBlendClumpGetAssociation((RpClump_0 *)(*p_pDriver)->m_pRwObject, 0xCBu);
      if ( v46 )
      {
        m_fBlendAmount = v46->m_fBlendAmount;
        goto LABEL_40;
      }
LABEL_41:
      v46 = RpAnimBlendClumpGetAssociation((RpClump_0 *)(*p_pDriver)->m_pRwObject, 0xCCu);
LABEL_42:
      if ( v45 && v45->m_fBlendAmount > 0.5 || v46 && v46->m_fBlendAmount > 0.5 )
      {
        m_nVehicleFlags = (char)this->m_nVehicleFlags;
        this->m_fGasPedal = 0.0;
        if ( (m_nVehicleFlags & 0x20) == 0
          && (this->m_aWheelRatios[0] < 1.0
           || this->m_aWheelRatios[1] < 1.0
           || this->m_aWheelRatios[2] < 1.0
           || this->m_aWheelRatios[3] < 1.0) )
        {
          this->m_bIsFreewheeling = 1;
        }
        return 1;
      }
LABEL_52:
      if ( this->m_fControlPedaling > 5.0 && (this->m_aWheelRatios[2] < 1.0 || this->m_aWheelRatios[3] < 1.0) )
      {
        v49 = this->m_pMat;
        v50 = 2.0;
        xy = v49->xy;
        yy = v49->yy;
        zy = v49->zy;
        v54 = (float)((float)((float)((float)((float)(this->m_vecMoveSpeed.x * xy) + (float)(this->m_vecMoveSpeed.y * yy))
                                    + (float)(this->m_vecMoveSpeed.z * zy))
                            / this->pHandling->Transmission.m_fMaxFlatVelocity)
                    * -1.5)
            + 2.4;
        if ( v54 <= 2.0 )
        {
          v50 = (float)((float)((float)((float)((float)(this->m_vecMoveSpeed.x * xy)
                                              + (float)(this->m_vecMoveSpeed.y * yy))
                                      + (float)(this->m_vecMoveSpeed.z * zy))
                              / this->pHandling->Transmission.m_fMaxFlatVelocity)
                      * -1.5)
              + 2.4;
          if ( v54 < 0.0 )
            v50 = 0.0;
        }
        if ( *(_BYTE *)&this->m_info > 7u )
        {
          v57 = v50 * 1.25;
          if ( (*((_BYTE *)&this->m_nVehicleFlags + 7) & 2) == 0 )
            v57 = v50;
        }
        else
        {
          FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BMX_SPRINT_SPEED);
          v56 = this->m_pMat;
          v57 = v50 * FatAndMuscleModifier;
          xy = v56->xy;
          yy = v56->yy;
          zy = v56->zy;
        }
        v58 = CTimer::ms_fTimeStep * (float)((float)((float)(v57 * 0.25) * this->m_fMass) * 0.008);
        v85.x = xy * v58;
        v85.y = v58 * yy;
        v85.z = v58 * zy;
        CPhysical::ApplyMoveForce(this, v85);
      }
      return 1;
    case 1u:
      *nProcContFlags += 2;
      goto LABEL_32;
    case 2u:
      CCarAI::UpdateCarAI(this);
      CPhysical::ProcessControl(this);
      CCarCtrl::UpdateCarOnRails(this);
      pHandling = this->pHandling;
      v22 = this->AutoPilot.ActualSpeed / 50.0;
      m_nDriveWheelsOnGround = this->m_nDriveWheelsOnGround;
      this->nNoOfContactWheels = 2;
      this->m_nDriveWheelsOnGround = 2;
      this->m_nDriveWheelsOnGroundLastFrame = m_nDriveWheelsOnGround;
      cTransmission::CalculateGearForSimpleCar(&pHandling->Transmission, v22, &this->m_nCurrentGear);
      this->m_aWheelPitchAngles[0] = CVehicle::ProcessWheelRotation(
                                       this,
                                       WS_ROLLING,
                                       (const CVector *)&this->m_pMat->xy,
                                       &this->m_vecMoveSpeed,
                                       *(float *)&v9[1].m_txdIndex * 0.5)
                                   + this->m_aWheelPitchAngles[0];
      this->m_aWheelPitchAngles[1] = CVehicle::ProcessWheelRotation(
                                       this,
                                       WS_ROLLING,
                                       (const CVector *)&this->m_pMat->xy,
                                       &this->m_vecMoveSpeed,
                                       *(float *)&v9[1].m_n2dEffects * 0.5)
                                   + this->m_aWheelPitchAngles[1];
      CBike::PlayHornIfNecessary(this);
      CBike::ReduceHornCounter(this);
      v24 = (int)this->m_nVehicleFlags;
      this->m_fControlPedaling = 0.0;
      v25 = this->m_nBikeFlags;
      *(_DWORD *)&this->m_nVehicleFlags = v24 & 0xDEFFFFFF;
      goto LABEL_30;
    case 3u:
      CCarAI::UpdateCarAI(this);
      CCarCtrl::SteerAICarWithPhysics(this);
      CBike::PlayHornIfNecessary(this);
      *nProcContFlags += 2;
      v26 = this->m_nBikeFlags;
      v27 = this->m_nVehicleFlags;
      this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&v26 & 0x7F);
      if ( (*(_DWORD *)&v27 & 0x80000) != 0 )
      {
        this->m_fGasPedal = 0.0;
        this->m_fBrakePedal = 1.0;
        *(_DWORD *)&v27 |= 0x20u;
        this->m_nVehicleFlags = v27;
      }
      else
      {
        this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&v26 & 0x77);
      }
      v39 = &this->m_fControlPedaling;
      m_fControlPedaling = this->m_fControlPedaling;
      if ( m_fControlPedaling > 0.0 )
      {
        if ( m_fControlPedaling <= 5.0 )
        {
          v62 = dword_569820;
          if ( (*((_DWORD *)&v27 + 1) & 0x2000000) != 0 )
            v62 = &dword_569820[1];
          v41 = *(float *)v62;
        }
        else
        {
          v41 = 0.02;
        }
        v63 = m_fControlPedaling - (float)(CTimer::ms_fTimeStep * v41);
        *v39 = v63;
        if ( v63 < 0.0 )
          *v39 = 0.0;
      }
      goto LABEL_32;
    case 4u:
      v28 = this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x;
      z = this->m_vecMoveSpeed.z;
      v30 = this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y;
      this->m_fBrakePedal = 0.0;
      if ( (float)((float)(v28 + v30) + (float)(z * z)) < 0.01 || (*(_BYTE *)&this->m_nBikeFlags & 0x10) != 0 )
      {
        v31 = *((_DWORD *)&this->m_nVehicleFlags + 1);
        v32 = *(_DWORD *)&this->m_nVehicleFlags | 0x20;
      }
      else
      {
        v31 = *((_DWORD *)&this->m_nVehicleFlags + 1);
        v32 = *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFFFDF;
      }
      *(_DWORD *)&this->m_nVehicleFlags = v32;
      this->m_cHorn = 0;
      this->m_fGasPedal = 0.0;
      if ( this->pDriver )
        goto LABEL_22;
      v60 = this->pPassengers[0];
      v61 = v60 == 0;
      if ( !v60 )
        v61 = (v32 & 0x80000) == 0;
      if ( v61 )
      {
        p_m_nBikeFlags = &this->m_nBikeFlags;
      }
      else
      {
LABEL_22:
        p_m_nBikeFlags = &this->m_nBikeFlags;
        if ( (*(_BYTE *)&this->m_nBikeFlags & 0x10) == 0 )
        {
          *nProcContFlags += 2;
          v32 = (int)this->m_nVehicleFlags;
          v31 = *((_DWORD *)&this->m_nVehicleFlags + 1);
        }
      }
      this->RideAnimData.m_fAnimLeanLeft = 0.0;
      this->RideAnimData.m_fAnimLeanFwd = 0.0;
      *(_BYTE *)p_m_nBikeFlags &= ~0x80u;
      this->m_fControlPedaling = 0.0;
      if ( (v32 & 0x80000) != 0 )
      {
        this->m_fGasPedal = 0.0;
        this->m_fBrakePedal = 1.0;
        *(_DWORD *)&this->m_nVehicleFlags = v32 | 0x20;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v31;
      }
      goto LABEL_32;
    case 5u:
      v33 = (int)this->m_nVehicleFlags;
      this->m_fSteerAngle = 0.0;
      this->m_fGasPedal = 0.0;
      this->m_fBrakePedal = 0.05;
      this->m_cHorn = 0;
      this->m_fControlPedaling = 0.0;
      this->RideAnimData.m_fAnimLeanLeft = 0.0;
      this->RideAnimData.m_fAnimLeanFwd = 0.0;
      v34 = this->m_nBikeFlags;
      *(_DWORD *)&this->m_nVehicleFlags = v33 | 0x20;
      v35 = (CBike::CBikeFlags)(*(_BYTE *)&v34 & 0x7F);
      goto LABEL_31;
    case 9u:
      p_m_fBrakePedal = &this->m_fBrakePedal;
      if ( (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                 + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) >= 0.01 )
      {
        *p_m_fBrakePedal = 0.0;
        v37 = *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFFFDF;
      }
      else
      {
        *p_m_fBrakePedal = 1.0;
        v37 = *(_DWORD *)&this->m_nVehicleFlags | 0x20;
      }
      *(_DWORD *)&this->m_nVehicleFlags = v37;
      this->m_fGasPedal = 0.0;
      this->m_fSteerAngle = 0.0;
      this->m_cHorn = 0;
      *nProcContFlags += 2;
      v25 = this->m_nBikeFlags;
      this->m_fControlPedaling = 0.0;
LABEL_30:
      v35 = (CBike::CBikeFlags)(*(_BYTE *)&v25 & 0x7F);
LABEL_31:
      this->m_nBikeFlags = v35;
      goto LABEL_32;
    default:
      goto LABEL_32;
  }
}
// 56949C: variable 'v4' is possibly undefined
// 56949C: variable 'v5' is possibly undefined
// 56973C: variable 'v2' is possibly undefined
// 56973C: variable 'v3' is possibly undefined
// 569820: using guessed type int dword_569820[2];

//----- (00569868) --------------------------------------------------------
void __fastcall CBmx::ProcessBunnyHop(CBmx *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  CPed *pDriver; // r0
  CAnimBlendAssociation *Association; // r5
  CPed *v6; // r0
  CPad *PadFromPlayer; // r0
  float *p_m_fControlJump; // r9
  CPad *v9; // r8
  _BOOL4 BunnyHop; // r6
  uint16 v11; // r0
  uint16 v12; // r0
  _BOOL4 BunnyHopDown; // r0
  int m_bitsFlag; // r1
  bool v15; // zf
  float v16; // s0
  float m_fCurrentTime; // s2

  pDriver = this->pDriver;
  if ( pDriver )
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pDriver->m_pRwObject, 0xCEu);
  else
    Association = 0;
  if ( *(_BYTE *)&this->m_info <= 7u )
  {
    v6 = this->pDriver;
    if ( v6 )
    {
      if ( CPed::IsPlayer(v6) )
      {
        PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
        p_m_fControlJump = &this->m_fControlJump;
        v9 = PadFromPlayer;
        if ( this->m_fControlJump == 0.0 && CPad::GetBunnyHopDown(PadFromPlayer) )
        {
          *p_m_fControlJump = CTimer::ms_fTimeStep + *p_m_fControlJump;
          Association = CAnimManager::BlendAnimation(
                          (RpClump_0 *)this->pDriver->m_pRwObject,
                          this->RideAnimData.m_animGroup,
                          ANIM_BIKE_BUNNYHOP,
                          8.0);
          CAnimBlendAssociation::SetCurrentTime(Association, 0.0);
          Association->m_bitsFlag &= ~1u;
        }
        BunnyHop = CPad::GetBunnyHop(v9);
        if ( BunnyHop || *p_m_fControlJump > 0.0 )
        {
          CWidgetHelpText::ConditionSatisfied(0x20u);
          if ( !v9->DisablePlayerControls )
          {
            if ( BunnyHop )
            {
              Association = CAnimManager::BlendAnimation(
                              (RpClump_0 *)this->pDriver->m_pRwObject,
                              this->RideAnimData.m_animGroup,
                              ANIM_BIKE_BUNNYHOP,
                              8.0);
              CAnimBlendAssociation::SetCurrentTime(Association, 0.0);
              Association->m_bitsFlag &= ~1u;
              *p_m_fControlJump = 25.0;
              CAnimBlendAssociation::SetCurrentTime(Association, 0.2);
              if ( !Association )
                return;
            }
            else
            {
              if ( !Association )
              {
                *p_m_fControlJump = 0.0;
                return;
              }
              BunnyHopDown = CPad::GetBunnyHopDown(v9);
              m_bitsFlag = Association->m_bitsFlag;
              v15 = BunnyHopDown;
              if ( BunnyHopDown )
                v15 = (m_bitsFlag & 1) == 0;
              if ( v15 )
              {
                v2.n64_u32[0] = 25.0;
                v1.n64_f32[0] = CTimer::ms_fTimeStep + *p_m_fControlJump;
                v16 = vmin_f32(v1, v2).n64_f32[0];
                *p_m_fControlJump = v16;
                CAnimBlendAssociation::SetCurrentTime(Association, (float)(v16 * 0.2) / 25.0);
              }
              else if ( !(m_bitsFlag << 31) )
              {
                m_fCurrentTime = Association->m_fCurrentTime;
                if ( m_fCurrentTime < 0.2 )
                {
                  CAnimBlendAssociation::SetCurrentTime(
                    Association,
                    (float)((float)((float)(0.2 - m_fCurrentTime) / 0.2)
                          * (float)(Association->m_pAnimBlendHierarchy->m_fTotalTime + -0.2))
                  + 0.2);
                  LOWORD(m_bitsFlag) = Association->m_bitsFlag;
                }
                Association->m_bitsFlag = m_bitsFlag | 1;
                Association->m_fSpeed = 1.5;
                CAnimBlendAssociation::SetFinishCallback(Association, CBmx::LaunchBunnyHopCB, this);
              }
            }
            goto LABEL_20;
          }
          *p_m_fControlJump = 0.0;
          if ( !Association )
            return;
        }
        else if ( !Association )
        {
          return;
        }
        v12 = Association->m_bitsFlag;
        Association->m_fBlendDelta = -8.0;
        Association->m_bitsFlag = v12 | 5;
LABEL_20:
        if ( Association->m_fBlendAmount > 0.5 )
        {
          this->m_fGasPedal = 0.0;
          FindPlayerPed(-1)->m_pPlayerData->m_fSprintControlCounter = 0.0;
          if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x20) == 0
            && (this->m_aWheelRatios[0] < 1.0
             || this->m_aWheelRatios[1] < 1.0
             || this->m_aWheelRatios[2] < 1.0
             || this->m_aWheelRatios[3] < 1.0) )
          {
            this->m_bIsFreewheeling = 1;
          }
        }
        return;
      }
    }
  }
  if ( Association )
  {
    v11 = Association->m_bitsFlag;
    Association->m_fBlendDelta = -8.0;
    Association->m_bitsFlag = v11 | 5;
  }
}
// 569A54: variable 'v1' is possibly undefined
// 569A54: variable 'v2' is possibly undefined

//----- (00569AEC) --------------------------------------------------------
void __fastcall CBmx::ProcessDrivingAnims(CBmx *this, CPed *pPed, bool8 playRadioAnim)
{
  CAnimBlendAssociation *Association; // r0
  float m_fCrankAngle; // s0
  CMatrix *m_pMat; // r1
  float x; // s16
  float xy; // s22
  float yy; // s26
  float zy; // s24
  float y; // s20
  float z; // s18
  CAnimBlendAssociation *v14; // r11
  CAnimBlendAssociation *v15; // r6
  CAnimBlendAssociation *v16; // r10
  CAnimBlendAssociation *v17; // r9
  CAnimBlendAssociation *v18; // r8
  CRideAnimData *p_RideAnimData; // r2
  float v20; // s4
  float m_fControlPedaling; // s0
  int *v22; // r0
  float v23; // s4
  float v24; // s6
  float v25; // s16
  uint16 v26; // r0
  uint16 v27; // r0
  uint16 v28; // r0
  float v29; // s0
  float v30; // s16
  float *p_m_fCrankAngle; // r6
  float v32; // s0
  float v33; // s2
  float v34; // s0
  float v35; // s2
  float v36; // s0
  float v37; // s2
  float m_fBlendAmount; // s0
  float v39; // s0
  CBike::CBikeFlags m_nBikeFlags; // r0
  float v41; // s0
  float v42; // s2
  float v43; // s2
  float v44; // s0
  int v45; // r0
  int v46; // r0
  uint16 m_bitsFlag; // r1
  uint16 v48; // r1
  float v49; // s0
  float v50; // s16
  float m_fAnimLeanLeft; // s0
  float m_fAnimLeanFwd; // s2
  CAnimBlendAssociation *v53; // [sp+4h] [bp-54h]

  if ( (*((_BYTE *)&this->m_nFlags + 2) & 2) == 0 || pPed && CPed::IsPlayer(pPed) )
  {
    *(_WORD *)&this->m_nFixLeftHand = 257;
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCEu);
    if ( Association )
    {
      m_fCrankAngle = (float)(Association->m_fBlendAmount * 1.5708)
                    + (float)((float)(1.0 - Association->m_fBlendAmount) * this->m_fCrankAngle);
      this->m_fCrankAngle = m_fCrankAngle;
LABEL_67:
      v44 = -m_fCrankAngle;
      this->m_fPedalAngleR = v44;
      this->m_fPedalAngleL = v44;
      return;
    }
    if ( pPed->m_pPlayerData )
      CPed::SetMoveState(pPed, PEDMOVE_NONE);
    m_pMat = this->m_pMat;
    x = this->m_vecMoveSpeed.x;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
    y = this->m_vecMoveSpeed.y;
    z = this->m_vecMoveSpeed.z;
    v14 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCFu);
    v15 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xD0u);
    v16 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC4u);
    v17 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC5u);
    v53 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xC7u);
    v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCAu);
    if ( !v18 )
    {
      v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCBu);
      if ( !v18 )
        v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCCu);
    }
    p_RideAnimData = &this->RideAnimData;
    v20 = fabsf(this->RideAnimData.m_fLeanAngle);
    m_fControlPedaling = this->m_fControlPedaling;
    v22 = dword_56A284;
    if ( m_fControlPedaling > 5.0 )
      v22 = &dword_56A284[1];
    if ( v20 < *(float *)v22 && !v18 )
    {
      v23 = (float)((float)(x * xy) + (float)(y * yy)) + (float)(z * zy);
      if ( v23 > 0.01 && this->RideAnimData.m_fLeanFwd < *(float *)v22 )
      {
        if ( this->m_nModelIndex == 510 )
        {
          v24 = 2.0;
          if ( this->m_nCurrentGear )
            v25 = (float)(v23 * 5.0)
                / (float)((float)(this->pHandling->Transmission.m_fMaxFlatVelocity * (float)this->m_nCurrentGear) + -0.25);
          else
            v25 = 0.0;
        }
        else
        {
          v24 = 2.5;
          v25 = v23 * 3.0;
        }
        if ( v25 < v24 && m_fControlPedaling > 5.0 )
        {
          if ( v15 && (v15->m_fBlendAmount >= 1.0 || v15->m_fBlendDelta > 0.0) )
          {
            v45 = 0;
          }
          else
          {
            v15 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPed->m_pRwObject,
                    p_RideAnimData->m_animGroup,
                    ANIM_BIKE_SPRINT,
                    4.0);
            v45 = 1;
          }
          v15->m_bitsFlag |= 1u;
          if ( v14 )
          {
            m_bitsFlag = v14->m_bitsFlag;
            v15 = v14;
            v14->m_fSpeed = v25;
            v14->m_bitsFlag = m_bitsFlag | 1;
            if ( !v45 )
              goto LABEL_106;
          }
          else
          {
            v15->m_fSpeed = v25;
            if ( !v45 )
            {
LABEL_106:
              v50 = (float)((float)(v15->m_fCurrentTime * -6.2832) / v15->m_pAnimBlendHierarchy->m_fTotalTime) + 0.0;
LABEL_107:
              this->m_fCrankAngle = v50;
              goto LABEL_108;
            }
          }
LABEL_94:
          if ( v16 && v16->m_fBlendAmount > 0.5 )
          {
            v49 = 3.1416;
          }
          else if ( v17 && v17->m_fBlendAmount > 0.5 )
          {
            v49 = 0.0;
          }
          else
          {
            if ( !v53 || v53->m_fBlendAmount <= 0.5 )
              goto LABEL_106;
            v49 = 1.5708;
          }
          v50 = (float)(0.0 - v49) / 6.2832;
          if ( v50 < 0.0 )
            v50 = v50 + 1.0;
          CAnimBlendAssociation::SetCurrentTime(v15, v15->m_pAnimBlendHierarchy->m_fTotalTime * v50);
          goto LABEL_107;
        }
        if ( m_fControlPedaling <= 0.0 && this->m_fGasPedal == 0.0 && (*(_BYTE *)&this->m_info & 0xF8) != 16 )
        {
          if ( v14 && (v14->m_fBlendAmount >= 1.0 || v14->m_fBlendDelta > 0.0) )
          {
            v46 = 0;
            v15 = v14;
          }
          else
          {
            v15 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPed->m_pRwObject,
                    p_RideAnimData->m_animGroup,
                    ANIM_BIKE_PEDAL,
                    4.0);
            v46 = 1;
          }
          v15->m_bitsFlag &= ~1u;
          if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x20) == 0
            && (this->m_aRatioHistory[0] < 1.0
             || this->m_aRatioHistory[1] < 1.0
             || this->m_aRatioHistory[2] < 1.0
             || this->m_aRatioHistory[3] < 1.0) )
          {
            this->m_bIsFreewheeling = 1;
            if ( v15 )
            {
LABEL_91:
              if ( v46 != 1 )
                goto LABEL_106;
              goto LABEL_94;
            }
LABEL_121:
            this->m_fCrankAngle = powf(0.97, CTimer::ms_fTimeStep) * this->m_fCrankAngle;
LABEL_108:
            m_fAnimLeanLeft = this->RideAnimData.m_fAnimLeanLeft;
            m_fAnimLeanFwd = this->RideAnimData.m_fAnimLeanFwd;
            if ( fabsf(m_fAnimLeanLeft) > 0.05 )
            {
              this->RideAnimData.m_fAnimLeanLeft = m_fAnimLeanLeft * 0.95;
              this->RideAnimData.m_fAnimLeanFwd = m_fAnimLeanFwd * 0.95;
            }
            goto LABEL_51;
          }
        }
        else
        {
          if ( v14 && (v14->m_fBlendAmount >= 1.0 || v14->m_fBlendDelta > 0.0) )
          {
            v46 = 0;
            v15 = v14;
          }
          else
          {
            v15 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPed->m_pRwObject,
                    p_RideAnimData->m_animGroup,
                    ANIM_BIKE_PEDAL,
                    4.0);
            v46 = 1;
          }
          v48 = v15->m_bitsFlag;
          v15->m_fSpeed = v25;
          v15->m_bitsFlag = v48 | 1;
        }
        if ( v15 )
          goto LABEL_91;
        goto LABEL_121;
      }
    }
    if ( v14 && v14->m_fBlendDelta >= 0.0 && v14->m_fBlendAmount > 0.0 )
    {
      v26 = v14->m_bitsFlag;
      v14->m_fBlendDelta = -8.0;
      v14->m_bitsFlag = v26 & 0xFFFE;
      if ( !v15 )
      {
LABEL_31:
        v29 = this->RideAnimData.m_fAnimLeanFwd * 0.95;
        this->RideAnimData.m_fAnimLeanLeft = this->RideAnimData.m_fAnimLeanLeft * 0.95;
        this->RideAnimData.m_fAnimLeanFwd = v29;
        if ( !((unsigned int)v14 | (unsigned int)v15) )
        {
LABEL_32:
          v30 = 0.0;
          goto LABEL_37;
        }
LABEL_34:
        if ( v14 )
          v15 = v14;
        v30 = (float)((float)(v15->m_fCurrentTime * -6.2832) / v15->m_pAnimBlendHierarchy->m_fTotalTime) + 0.0;
LABEL_37:
        p_m_fCrankAngle = &this->m_fCrankAngle;
        this->m_fCrankAngle = v30;
        if ( v16 && (v32 = v16->m_fBlendAmount, v32 > 0.1) )
        {
          v33 = 1.0 - v32;
          v34 = v32 * 3.1416;
          v35 = v30 * v33;
        }
        else
        {
          if ( !v17 || (v36 = v17->m_fBlendAmount, v36 <= 0.1) )
          {
            if ( v53 && (m_fBlendAmount = v53->m_fBlendAmount, m_fBlendAmount > 0.1) )
              v39 = (float)(m_fBlendAmount * 1.5708) + (float)((float)(1.0 - m_fBlendAmount) * v30);
            else
              v39 = powf(0.97, CTimer::ms_fTimeStep) * v30;
            *p_m_fCrankAngle = v39;
LABEL_49:
            if ( v18 )
            {
              this->m_bIsFreewheeling = 1;
              this->m_nFixRightHand = 0;
            }
LABEL_51:
            if ( CPed::IsPlayer(pPed) )
            {
              m_nBikeFlags = this->m_nBikeFlags;
              v41 = this->m_aWheelCounts[0];
              this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags & 0x7F);
              if ( v41 > 0.0
                || this->m_aWheelCounts[1] > 0.0
                || (v42 = this->m_pMat->zy, v42 <= 0.0)
                || this->m_aWheelCounts[2] <= 0.0 && this->m_aWheelCounts[3] <= 0.0 )
              {
                if ( this->m_aWheelCounts[2] > 0.0 )
                  goto LABEL_66;
                if ( this->m_aWheelCounts[3] > 0.0 )
                  goto LABEL_66;
                v43 = this->m_pMat->zy;
                if ( v43 >= 0.0 || v41 <= 0.0 && this->m_aWheelCounts[1] <= 0.0 )
                  goto LABEL_66;
                if ( (float)(this->pBikeHandling->fStoppieBalancePoint - v43) <= (float)(this->pBikeHandling->fStoppieBalancePoint
                                                                                       * 0.6) )
                  goto LABEL_66;
              }
              else if ( (float)(this->pBikeHandling->fWheelieBalancePoint - v42) >= (float)(this->pBikeHandling->fWheelieBalancePoint
                                                                                          * 0.5) )
              {
                goto LABEL_66;
              }
              this->m_nBikeFlags = (CBike::CBikeFlags)(*(_BYTE *)&m_nBikeFlags | 0x80);
            }
LABEL_66:
            m_fCrankAngle = this->m_fCrankAngle;
            goto LABEL_67;
          }
          v37 = 1.0 - v36;
          v34 = v36 * 0.0;
          v35 = v37 * v30;
        }
        *p_m_fCrankAngle = v34 + v35;
        this->m_bIsFreewheeling = 1;
        goto LABEL_49;
      }
    }
    else
    {
      if ( !v15 || v15->m_fBlendDelta < 0.0 || v15->m_fBlendAmount <= 0.0 )
      {
        CBike::ProcessRiderAnims(pPed, this, p_RideAnimData, this->pBikeHandling, 0);
        if ( !((unsigned int)v14 | (unsigned int)v15) )
          goto LABEL_32;
        goto LABEL_34;
      }
      if ( v14 )
      {
        v27 = v14->m_bitsFlag;
        v14->m_fBlendDelta = -8.0;
        v14->m_bitsFlag = v27 & 0xFFFE;
      }
    }
    v28 = v15->m_bitsFlag;
    v15->m_fBlendDelta = -8.0;
    v15->m_bitsFlag = v28 & 0xFFFE;
    goto LABEL_31;
  }
}
// 56A284: using guessed type int dword_56A284[2];

//----- (0056A2B0) --------------------------------------------------------
void __fastcall CBmx::LaunchBunnyHopCB(CAnimBlendAssociation *pAnim, void *pData)
{
  float v3; // s0
  float v4; // s16
  float v5; // s18
  float *v6; // r0
  float v7; // s0
  int v8; // r0
  float v9; // s0
  CVector v10; // 0:r1.12
  CVector v11; // 0:r1.12

  if ( (*((float *)pData + 465) > 0.0 || *((float *)pData + 466) > 0.0)
    && (*((float *)pData + 467) > 0.0 || *((float *)pData + 468) > 0.0) )
  {
    v3 = *((float *)pData + 522) / 25.0;
    v4 = v3 + 1.0;
    if ( v3 > 1.0 )
      v4 = 2.0;
    if ( *((unsigned __int8 *)pData + 58) <= 7u )
      v4 = v4 * CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BMX_BUNNYHOP);
    v5 = v4 * 5.0;
    if ( !CCheat::m_aCheatsActive[57] )
      v5 = v4;
    v6 = (float *)*((_DWORD *)pData + 5);
    v7 = *((float *)pData + 36) * (float)(v5 * 0.06);
    v10.x = v6[8] * v7;
    v10.y = v6[9] * v7;
    v10.z = v7 * v6[10];
    CPhysical::ApplyMoveForce((CPhysical *)pData, v10);
    v8 = *((_DWORD *)pData + 5);
    v9 = (float)(v5 * 0.01) * *((float *)pData + 37);
    v11.x = v9 * *(float *)(v8 + 32);
    v11.y = v9 * *(float *)(v8 + 36);
    v11.z = v9 * *(float *)(v8 + 40);
    CPhysical::ApplyTurnForce((CPhysical *)pData, v11, *(CVector *)(v8 + 16));
    fHackedBunnyHopTimer = 0.5;
  }
}

//----- (0056A408) --------------------------------------------------------
void __fastcall CBmx::GetFrameOffset(CBmx *this, float *fZOffset, float *fAngleOffset)
{
  float v3; // s0
  float v4; // s2

  v3 = this->m_aWheelSuspensionHeights[0] - this->m_aWheelOrigHeights[0];
  v4 = this->m_aWheelSuspensionHeights[1] - this->m_aWheelOrigHeights[1];
  *fZOffset = (float)(this->m_fMidWheelFracY * v4) + (float)(v3 * (float)(1.0 - this->m_fMidWheelFracY));
  *fAngleOffset = atan2f(v3 - v4, this->m_fMidWheelDistY);
}

//----- (0056A46C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBmx::PreRender(CBmx *this)
{
  float32x2_t v1; // d3
  float32x2_t v2; // d4
  float32x2_t v3; // d5
  float32x2_t v4; // d6
  CBmx *v5; // r10
  CCollisionData *m_pColData; // r4
  float v7; // s2
  float v8; // s6
  float v9; // s8
  float v10; // s0
  float v11; // s6
  float v12; // s4
  float v13; // s10
  float z; // s6
  float v15; // s2
  float v16; // s4
  float v17; // s0
  int32 nWheelIndex; // r9
  float v19; // s16
  int v20; // r8
  int v21; // r11
  CColModel *v22; // r0
  CBmx *v23; // r4
  char *v24; // r10
  float v25; // s24
  float v26; // s26
  float v27; // r6
  float v28; // s0
  CColPoint *v29; // r0
  __int64 v30; // d16
  float v31; // s0
  float *p_xx; // r1
  bool *v33; // r5
  float v34; // s6
  float v35; // s2
  float v36; // s4
  int (***v37)(void); // r1
  float v38; // s0
  float v39; // r3
  uint32 v40; // r2
  _BOOL4 v41; // r4
  uint32 nSkidmarkType; // r6
  tWheelState v43; // r1
  int nOptionFlags; // r0
  float m_fSteerAngle; // r5
  float *v46; // r11
  float v47; // r0
  const CMatrix *m_pMat; // r6
  CMatrix *v49; // r0
  __int64 v50; // d16
  float *p_x; // r0
  float v52; // r0
  float *v53; // r0
  int v54; // r2
  int v55; // r1
  float v56; // r3
  float v57; // r0
  RwFrame_0 *v58; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float v62; // s2
  float v63; // s0
  RwFrame_0 *v64; // r0
  float v65; // s20
  float v66; // s18
  float v67; // s16
  RwFrame_0 *v68; // r6
  float v69; // r5
  float v70; // s16
  float v71; // s18
  float v72; // s20
  float v73; // s16
  float v74; // s18
  float v75; // s0
  float v76; // s20
  float v77; // r0
  float v78; // s16
  float v79; // s18
  float v80; // s0
  float v81; // s20
  float v82; // r0
  RwFrame_0 *v83; // r5
  float v84; // s16
  float v85; // s18
  float m_fMidWheelFracY; // s20
  float v87; // r6
  float m_fLeanAngle; // s22
  float v89; // s24
  float v90; // s28
  float v91; // s26
  float v92; // r0
  RwFrame_0 *v93; // r0
  float v94; // s16
  float v95; // s18
  float v96; // s20
  RwFrame_0 *v97; // r0
  float v98; // s16
  float v99; // s18
  float v100; // s20
  RwFrame_0 *v101; // r0
  float v102; // s16
  float v103; // s18
  float v104; // s20
  float v105; // [sp+0h] [bp-1F8h]
  CColPoint *pColPoint; // [sp+4h] [bp-1F4h]
  CColModel *ColModel; // [sp+20h] [bp-1D8h]
  CCollisionData *v108; // [sp+24h] [bp-1D4h]
  float *v109; // [sp+28h] [bp-1D0h]
  float *v110; // [sp+2Ch] [bp-1CCh]
  float *m_aRatioHistory; // [sp+30h] [bp-1C8h]
  float *v112; // [sp+34h] [bp-1C4h]
  float *p_m_fLeanAngle; // [sp+38h] [bp-1C0h]
  CVector v114; // [sp+3Ch] [bp-1BCh] BYREF
  CQuaternion v115; // [sp+48h] [bp-1B0h] BYREF
  char v116; // [sp+58h] [bp-1A0h] BYREF
  CMatrix m2; // [sp+98h] [bp-160h] BYREF
  CVector v118; // [sp+E0h] [bp-118h] BYREF
  CVector vecForward; // [sp+ECh] [bp-10Ch] BYREF
  CVector WheelSpeed; // [sp+F8h] [bp-100h] BYREF
  CMatrix v121; // [sp+108h] [bp-F0h] BYREF
  CMatrix v[2]; // [sp+150h] [bp-A8h] BYREF
  CVector v123; // 0:r2.8,8:^0.4

  v5 = this;
  CVehicle::PreRender(this);
  ColModel = CEntity::GetColModel(v5);
  m_pColData = ColModel->m_pColData;
  if ( *((unsigned __int8 *)&v5->m_nVehicleFlags + 3) << 31 )
  {
    (*((void (__fastcall **)(CBmx *))v5->_vptr$CPlaceable + 53))(v5);
    v1.n64_u32[0] = LODWORD(v5->m_aWheelRatios[0]);
    v7 = v5->m_fSuspensionLength[0];
    v2.n64_u32[0] = LODWORD(v5->m_aWheelRatios[1]);
    v8 = vmin_f32(v2, v1).n64_f32[0];
    v9 = v5->m_fSuspensionLength[2];
    v4.n64_u32[0] = LODWORD(v5->m_aWheelRatios[3]);
    v10 = (float)(v8 - (float)(1.0 - (float)(v7 / v5->m_fLineLength[0])))
        / (float)(1.0 - (float)(1.0 - (float)(v7 / v5->m_fLineLength[0])));
    v11 = 1.0 - (float)(v9 / v5->m_fLineLength[2]);
    v3.n64_u32[0] = LODWORD(v5->m_aWheelRatios[2]);
    v12 = 1.0 - v11;
    v13 = vmin_f32(v4, v3).n64_f32[0] - v11;
    z = m_pColData->_anon_1.m_pLineArray->m_vecStart.z;
    v15 = z - (float)(v7 * v10);
    v16 = v13 / v12;
    if ( v10 > 0.0 )
      z = v15;
    v5->m_aWheelSuspensionHeights[0] = v5->m_aWheelSuspensionHeights[0]
                                     + (float)((float)(z - v5->m_aWheelSuspensionHeights[0]) * 0.75);
    v17 = m_pColData->_anon_1.m_pLineArray[2].m_vecStart.z;
    if ( v16 > 0.0 )
      v17 = v17 - (float)(v9 * v16);
    v5->m_aWheelSuspensionHeights[1] = v5->m_aWheelSuspensionHeights[1]
                                     + (float)((float)(v17 - v5->m_aWheelSuspensionHeights[1]) * 0.75);
  }
  v108 = m_pColData;
  if ( *(_BYTE *)&v5->m_info < 0x20u )
  {
    v110 = &v5->m_aRatioHistory[2];
    v112 = &v5->m_aRatioHistory[3];
    p_m_fLeanAngle = &v5->RideAnimData.m_fLeanAngle;
    nWheelIndex = 0;
    v109 = &v5->m_aRatioHistory[1];
    m_aRatioHistory = v5->m_aRatioHistory;
    v19 = sqrtf(
            (float)((float)(v5->m_vecMoveSpeed.x * v5->m_vecMoveSpeed.x)
                  + (float)(v5->m_vecMoveSpeed.y * v5->m_vecMoveSpeed.y))
          + (float)(v5->m_vecMoveSpeed.z * v5->m_vecMoveSpeed.z));
    while ( nWheelIndex )
    {
      if ( *v112 < 1.0 || *v110 >= 1.0 )
        v20 = 3;
      else
        v20 = 2;
      if ( v5->m_aWheelState[1] == WS_LOCKED )
        goto LABEL_20;
      v21 = 0;
LABEL_21:
      v22 = CEntity::GetColModel(v5);
      v23 = v5;
      v24 = (char *)v5 + 44 * (__int16)v20;
      v25 = *p_m_fLeanAngle;
      v26 = v22->m_boxBound.m_vecMin.z * 0.8;
      v27 = *((float *)v24 + 415);
      v28 = sinf(*p_m_fLeanAngle);
      v29 = (CColPoint *)(v24 + 1652);
      v5 = v23;
      v30 = *(_QWORD *)&v29->m_vecPosition.x;
      v31 = v26 * v28;
      v[0].zx = v27;
      *(_QWORD *)&v[0].xx = v30;
      p_xx = &v23->m_pMat->xx;
      v33 = (bool *)v23 + nWheelIndex;
      v34 = p_xx[2];
      v35 = v31 * *p_xx;
      v36 = v31 * p_xx[1];
      v37 = &v23->_vptr$CPlaceable + nWheelIndex;
      v[0].xx = v35 + *(float *)&v30;
      v[0].yx = v36 + *((float *)&v30 + 1);
      v[0].zx = (float)(v31 * v34) + v27;
      v38 = 1.0;
      v39 = v23->m_aRatioHistory[v20];
      v40 = v23->m_nWheelStatus[nWheelIndex];
      v41 = v23->bWheelBloody[nWheelIndex];
      nSkidmarkType = (uint32)v37[470];
      v43 = (tWheelState)v37[520];
      pColPoint = v29;
      if ( v25 > 0.0 )
        v38 = -1.0;
      nOptionFlags = v21 | v41;
      if ( v33[1890] )
        nOptionFlags |= 2u;
      CVehicle::AddSingleWheelParticles(
        v5,
        v43,
        v40,
        v39,
        v19,
        pColPoint,
        (CVector *)v,
        v38,
        nWheelIndex++,
        nSkidmarkType,
        v33 + 1888,
        nOptionFlags);
      if ( nWheelIndex == 2 )
        goto LABEL_26;
    }
    v20 = *m_aRatioHistory >= 1.0 && *v109 < 1.0;
LABEL_20:
    v21 = 4;
    goto LABEL_21;
  }
LABEL_26:
  v5->m_bLeanMatrix = 0;
  CBike::CalculateLeanMatrix(v5);
  CShadows::StoreShadowForVehicle(v5, VEHICLE_SHADOW_BIKE);
  v121.m_pRwMat = 0;
  v121.m_owner = 0;
  m_fSteerAngle = v5->m_fSteerAngle;
  v46 = (float *)CModelInfo::ms_modelInfoPtrs[v5->m_nModelIndex];
  v47 = cosf(m_fSteerAngle);
  m_pMat = v5->m_pMat;
  v[0].yx = v47;
  LODWORD(v[0].xx) = COERCE_UNSIGNED_INT(sinf(m_fSteerAngle)) ^ 0x80000000;
  v[0].zx = 0.0;
  Multiply3x3(&vecForward, m_pMat, (const CVector *)v);
  v49 = v5->m_pMat;
  v50 = *(_QWORD *)&v49->xy;
  v118.z = v49->zy;
  *(_QWORD *)&v118.x = v50;
  if ( v5->m_aWheelCounts[0] > 0.0 || v5->m_aWheelCounts[1] > 0.0 )
  {
    p_x = &v108->_anon_1.m_pLineArray->m_vecStart.x;
    v123.x = 0.0;
    v123.z = (float)(p_x[2]
                   - (float)(v5->m_aRatioHistory[v5->m_aRatioHistory[0] >= v5->m_aRatioHistory[1]]
                           * v5->m_fSuspensionLength[0]))
           - (float)(v46[22] * 0.5);
    v123.y = (float)(p_x[1] + p_x[9]) * 0.5;
    CPhysical::GetSpeed((CVector *)v, v5, v123);
    WheelSpeed.z = v[0].zx;
    *(_QWORD *)&WheelSpeed.x = *(_QWORD *)&v[0].xx;
    v52 = CVehicle::ProcessWheelRotation(v5, WS_ROLLING, &vecForward, &WheelSpeed, v46[22] * 0.5);
    v5->m_aWheelAngularVelocity[0] = v52;
    v5->m_aWheelPitchAngles[0] = v5->m_aWheelPitchAngles[0] + (float)(v52 * CTimer::ms_fTimeStep);
  }
  if ( v5->m_aWheelCounts[2] > 0.0 || v5->m_aWheelCounts[3] > 0.0 )
  {
    v53 = &v108->_anon_1.m_pLineArray->m_vecStart.x;
    v54 = 0;
    v55 = 3;
    if ( v5->m_aRatioHistory[2] < v5->m_aRatioHistory[3] )
      v55 = 2;
    v105 = (float)(v53[18] - (float)(v5->m_aRatioHistory[v55] * v5->m_fSuspensionLength[2])) - (float)(v46[22] * 0.5);
    v56 = (float)(v53[17] + v53[25]) * 0.5;
    CPhysical::GetSpeed((CVector *)v, v5, *(CVector *)&v54);
    WheelSpeed.z = v[0].zx;
    *(_QWORD *)&WheelSpeed.x = *(_QWORD *)&v[0].xx;
    v57 = CVehicle::ProcessWheelRotation(v5, v5->m_aWheelState[1], &v118, &WheelSpeed, v46[23] * 0.5);
    v5->m_aWheelAngularVelocity[1] = v57;
    v5->m_aWheelPitchAngles[1] = v5->m_aWheelPitchAngles[1] + (float)(v57 * CTimer::ms_fTimeStep);
  }
  v58 = v5->m_aBikeNodes[2];
  if ( v58 )
  {
    CMatrix::Attach(&v121, &v58->modelling, 0);
    m2.m_owner = 0;
    m2.m_pRwMat = (RwMatrix *)&v116;
    tx = v121.tx;
    ty = v121.ty;
    tz = v121.tz;
    CMatrix::SetUnity(&m2);
    CMatrix::UpdateRW(&m2);
    v62 = v46[28];
    v114.x = 0.0;
    v63 = (float)(v62 * 3.1416) / 180.0;
    v114.y = sinf(v63);
    LODWORD(v114.z) = COERCE_UNSIGNED_INT(cosf(v63)) ^ 0x80000000;
    CVector::Normalise(&v114);
    CQuaternion::Set(&v115, &v114, COERCE_FLOAT(LODWORD(v5->RideAnimData.m_fBarSteerAngle) ^ 0x80000000));
    CQuaternion::Get(&v115, m2.m_pRwMat);
    CMatrix::Update(&m2);
    CMatrix::SetUnity(&v121);
    operator*(v, &v121, &m2);
    CMatrix::operator=(&v121, v);
    CMatrix::~CMatrix(v);
    v121.tx = tx + v121.tx;
    v121.ty = ty + v121.ty;
    v121.tz = tz + v121.tz;
    CMatrix::UpdateRW(&v121);
    v64 = v5->m_aBikeNodes[6];
    if ( v64 )
    {
      CMatrix::Attach(&v121, &v64->modelling, 0);
      v65 = v121.tx;
      v66 = v121.ty;
      v67 = v121.tz;
      if ( (*(_BYTE *)&v5->m_info & 0xF0) == 32 )
      {
        CMatrix::SetUnity(&v121);
        operator*(v, &v121, &m2);
        CMatrix::operator=(&v121, v);
        CMatrix::~CMatrix(v);
        v121.tx = v65 + v121.tx;
        v121.ty = v66 + v121.ty;
        v121.tz = v67 + v121.tz;
      }
      else
      {
        CMatrix::SetTranslate(&v121, v121.tx, v121.ty, v121.tz);
      }
      CMatrix::UpdateRW(&v121);
    }
    CMatrix::~CMatrix(&m2);
  }
  v68 = v5->m_aBikeNodes[3];
  if ( v68 )
  {
    v69 = asinf((float)(v5->m_aWheelSuspensionHeights[1] - v5->m_aWheelOrigHeights[1]) / v5->m_fSwingArmLength);
    CMatrix::Attach(&v121, &v68->modelling, 0);
    v70 = v121.tx;
    v71 = v121.ty;
    v72 = v121.tz;
    CMatrix::SetRotate(&v121, COERCE_FLOAT(LODWORD(v69) ^ 0x80000000), 0.0, 0.0);
    v121.tx = v70 + v121.tx;
    v121.ty = v71 + v121.ty;
    v121.tz = v72 + v121.tz;
    CMatrix::UpdateRW(&v121);
  }
  CMatrix::Attach(&v121, &v5->m_aBikeNodes[4]->modelling, 0);
  v73 = v121.tx;
  v74 = v121.ty;
  v75 = v5->m_aWheelPitchAngles[0];
  v76 = v121.tz;
  if ( v5->m_nWheelStatus[0] == 1 )
  {
    v77 = sinf(v5->m_aWheelPitchAngles[0]);
    CMatrix::SetRotate(&v121, v75, 0.0, v77 * 0.02);
  }
  else
  {
    CMatrix::SetRotateX(&v121, v5->m_aWheelPitchAngles[0]);
  }
  v121.tx = v73 + v121.tx;
  v121.ty = v74 + v121.ty;
  v121.tz = v76 + v121.tz;
  CMatrix::UpdateRW(&v121);
  CMatrix::Attach(&v121, &v5->m_aBikeNodes[5]->modelling, 0);
  v78 = v121.tx;
  v79 = v121.ty;
  v80 = v5->m_aWheelPitchAngles[1];
  v81 = v121.tz;
  if ( v5->m_nWheelStatus[1] == 1 )
  {
    v82 = sinf(v5->m_aWheelPitchAngles[1]);
    CMatrix::SetRotate(&v121, v80, 0.0, v82 * 0.04);
  }
  else
  {
    CMatrix::SetRotateX(&v121, v5->m_aWheelPitchAngles[1]);
  }
  v121.tx = v78 + v121.tx;
  v121.ty = v79 + v121.ty;
  v121.tz = v81 + v121.tz;
  CMatrix::UpdateRW(&v121);
  v83 = v5->m_aBikeNodes[1];
  if ( v83 )
  {
    v84 = v5->m_aWheelSuspensionHeights[1] - v5->m_aWheelOrigHeights[1];
    v85 = v5->m_aWheelSuspensionHeights[0] - v5->m_aWheelOrigHeights[0];
    m_fMidWheelFracY = v5->m_fMidWheelFracY;
    v87 = atan2f(v85 - v84, v5->m_fMidWheelDistY);
    CMatrix::Attach(&v121, &v83->modelling, 0);
    m_fLeanAngle = v5->RideAnimData.m_fLeanAngle;
    v89 = v121.tx;
    v90 = ColModel->m_boxBound.m_vecMin.z;
    v91 = v121.ty;
    CMatrix::SetRotateX(&v121, v87 + (float)(fabsf(m_fLeanAngle) * -0.05));
    CMatrix::RotateY(&v121, v5->RideAnimData.m_fLeanAngle + v5->m_fSprintLeanAngle);
    v92 = cosf(m_fLeanAngle);
    v121.tx = v89 + v121.tx;
    v121.ty = v91 + v121.ty;
    v121.tz = (float)((float)((float)(m_fMidWheelFracY * v84) + (float)(v85 * (float)(1.0 - m_fMidWheelFracY)))
                    + (float)((float)(v90 * 0.9) * (float)(1.0 - v92)))
            + v121.tz;
    CMatrix::UpdateRW(&v121);
  }
  v93 = v5->m_aBikeNodes[7];
  if ( v93 )
  {
    CMatrix::Attach(&v121, &v93->modelling, 0);
    v94 = v121.tx;
    v95 = v121.ty;
    v96 = v121.tz;
    CMatrix::SetRotate(&v121, v5->m_fCrankAngle, 0.0, 0.0);
    v121.tx = v94 + v121.tx;
    v121.ty = v95 + v121.ty;
    v121.tz = v96 + v121.tz;
    CMatrix::UpdateRW(&v121);
  }
  v97 = v5->m_aBikeNodes[8];
  if ( v97 )
  {
    CMatrix::Attach(&v121, &v97->modelling, 0);
    v98 = v121.tx;
    v99 = v121.ty;
    v100 = v121.tz;
    CMatrix::SetRotate(&v121, v5->m_fPedalAngleL, 0.0, 0.0);
    v121.tx = v98 + v121.tx;
    v121.ty = v99 + v121.ty;
    v121.tz = v100 + v121.tz;
    CMatrix::UpdateRW(&v121);
  }
  v101 = v5->m_aBikeNodes[9];
  if ( v101 )
  {
    CMatrix::Attach(&v121, &v101->modelling, 0);
    v102 = v121.tx;
    v103 = v121.ty;
    v104 = v121.tz;
    CMatrix::SetRotate(&v121, v5->m_fPedalAngleR, 0.0, 0.0);
    v121.tx = v102 + v121.tx;
    v121.ty = v103 + v121.ty;
    v121.tz = v104 + v121.tz;
    CMatrix::UpdateRW(&v121);
  }
  CMatrix::~CMatrix(&v121);
}
// 56A46C: fragmented variable at r2.4 may be wrong

//----- (0056AEBA) --------------------------------------------------------
bool __fastcall CBmx::SetUpWheelColModel(CBmx *this, CColModel *pColModel)
{
  return 0;
}

//----- (0056AEBE) --------------------------------------------------------
bool __fastcall CBmx::BurstTyre(CBmx *this, uint8 nWheelPieceType, bool bApplyForce)
{
  return 0;
}

//----- (0056AEC2) --------------------------------------------------------
float __fastcall CBmx::FindWheelWidth(CBmx *this, bool bRear)
{
  return 0.07;
}

//----- (0056AED0) --------------------------------------------------------
RwObject_0 *__fastcall GetBoatAtomicObjectCB(RwObject_0 *pObject, void *data)
{
  if ( (pObject->flags & 4) != 0 )
    *(_DWORD *)data = pObject;
  return pObject;
}

//----- (0056AEDC) --------------------------------------------------------
void __fastcall CBoat::CBoat(CBoat *this, int nModelIndex, UInt8 CreatedBy)
{
  CBaseModelInfo *v5; // r8
  int v6; // r6
  RpClump_0 *m_pRwObject; // r0
  char *v8; // r0
  tHandlingData *pHandling; // r0
  __int64 v10; // d16
  float fDragCoeff; // s2
  __int16 m_nBoatFlags; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  int *v14; // r2
  int *v15; // r1
  int m_nModelIndex; // r0
  float v17; // s2
  uint16 v18; // r1

  CVehicle::CVehicle(this, CreatedBy);
  this->BoatDoor.m_fAngVel = 0.0;
  *(_QWORD *)&this->BoatDoor.m_fOpenAngle = 0LL;
  *(_QWORD *)&this->BoatDoor.m_nDirn = 0LL;
  this->BoatDoor.m_fPrevAngle = 0.0;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DA20;
  v5 = CModelInfo::ms_modelInfoPtrs[nModelIndex];
  v6 = *((unsigned __int8 *)&v5[1].m_flags + 2);
  *(_QWORD *)&this->m_vecOldMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecOldMoveSpeed.z = 0LL;
  this->m_vecOldTurnSpeed.y = 0.0;
  this->m_vecOldTurnSpeed.z = 0.0;
  this->m_baseVehicleType = 5;
  this->m_vehicleType = 5;
  this->nPadNum = 0;
  this->m_fScan = 0.0;
  this->m_fEngineSpeed = 0.0;
  this->m_fPropellerAngle = 0.0;
  this->m_nNextTalkTimer = CTimer::m_snTimeInMilliseconds;
  CVehicle::SetModelIndex(this, nModelIndex);
  *(_QWORD *)&this->m_aBoatNodes[8] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[10] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[4] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[6] = 0LL;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)this->m_aBoatNodes = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[2] = 0LL;
  CClumpModelInfo::FillFrameArray(m_pRwObject, this->m_aBoatNodes);
  v8 = (char *)&mod_HandlingManager + 224 * v6;
  this->pHandling = (tHandlingData *)(v8 + 20);
  this->hFlagsLocal = *((_DWORD *)v8 + 57);
  this->pFlyingHandling = cHandlingDataMgr::GetFlyingPointer(&mod_HandlingManager, v6);
  this->pBoatHandling = cHandlingDataMgr::GetBoatPointer(&mod_HandlingManager, v6);
  CVehicleModelInfo::ChooseVehicleColour(
    (CVehicleModelInfo *)v5,
    &this->m_colour1,
    &this->m_colour2,
    &this->m_colour3,
    &this->m_colour4,
    1);
  pHandling = this->pHandling;
  this->m_fMass = pHandling->fMass;
  this->m_fTurnMass = pHandling->fTurnMass * 0.5;
  v10 = *(_QWORD *)&pHandling->CentreOfMass.x;
  this->m_vecCOM.z = pHandling->CentreOfMass.z;
  this->m_fElasticity = 0.1;
  *(_QWORD *)&this->m_vecCOM.x = v10;
  this->m_fBuoyancyConstant = pHandling->fBuoyancyConstant;
  fDragCoeff = pHandling->fDragCoeff;
  if ( fDragCoeff > 0.01 )
    fDragCoeff = (float)(fDragCoeff * 0.5) / 1000.0;
  this->m_fSteerAngle = 0.0;
  this->m_fAirResistance = fDragCoeff;
  this->m_fGasPedal = 0.0;
  this->m_fBrakePedal = 0.0;
  this->fSteer = 0.0;
  this->nCurrentField = 0;
  this->fPrevVolume = 7.0;
  this->fLockedHeading = -10000.0;
  this->TimeOfLastParticle = 0;
  this->m_BlowUpTimer = 0.0;
  this->pEntityThatSetUsOnFire = 0;
  this->m_nNumWakeCoords = 0;
  m_nBoatFlags = (unsigned __int8)this->m_nBoatFlags;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  *(_QWORD *)&this->m_fWakePtCounters[28] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[30] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[24] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[26] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[20] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[22] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[16] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[18] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[12] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[14] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[8] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[10] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[4] = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[6] = 0LL;
  *(_QWORD *)this->m_fWakePtCounters = 0LL;
  *(_QWORD *)&this->m_fWakePtCounters[2] = 0LL;
  v14 = dword_56B144;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x8000100);
  v15 = dword_56B13C;
  this->m_nBoatFlags = (CBoat::CBoatFlags)(m_nBoatFlags | 7);
  this->AmmoInClip = 20;
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( m_nModelIndex == 484 )
  {
    v15 = &dword_56B13C[1];
    v14 = &dword_56B144[1];
  }
  v17 = *(float *)v15;
  LODWORD(this->BoatDoor.m_fOpenAngle) = *v14;
  this->BoatDoor.m_nAxis = 2;
  this->BoatDoor.m_fClosedAngle = v17;
  v18 = 3;
  if ( m_nModelIndex == 484 )
    v18 = 4;
  this->BoatDoor.m_nDirn = v18;
  CAEVehicleAudioEntity::Initialise(&this->m_VehicleAudioEntity, this);
  this->m_fxSysProp[0] = 0;
  this->m_fxSysProp[1] = 0;
}
// 56B13C: using guessed type int dword_56B13C[2];
// 56B144: using guessed type int dword_56B144[2];
// 66DA20: using guessed type void *;

//----- (0056B14C) --------------------------------------------------------
void __fastcall CBoat::~CBoat(CBoat *this)
{
  FxSystem_c *m_fxSysEngFire; // r0
  FxSystem_c *v3; // r0
  FxSystem_c *v4; // r0

  m_fxSysEngFire = this->m_fxSysEngFire;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DA20;
  if ( m_fxSysEngFire )
  {
    FxSystem_c::Kill(m_fxSysEngFire);
    this->m_fxSysEngFire = 0;
  }
  v3 = this->m_fxSysProp[0];
  if ( v3 )
  {
    FxSystem_c::Kill(v3);
    this->m_fxSysProp[0] = 0;
  }
  v4 = this->m_fxSysProp[1];
  if ( v4 )
  {
    FxSystem_c::Kill(v4);
    this->m_fxSysProp[1] = 0;
  }
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  sub_195C74(this);
}
// 66DA20: using guessed type void *off_66DA20;

//----- (0056B1A4) --------------------------------------------------------
void __fastcall CBoat::~CBoat(CBoat *this)
{
  FxSystem_c *m_fxSysEngFire; // r0
  FxSystem_c *v3; // r0
  FxSystem_c *v4; // r0
  void *v5; // r0

  m_fxSysEngFire = this->m_fxSysEngFire;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DA20;
  if ( m_fxSysEngFire )
  {
    FxSystem_c::Kill(m_fxSysEngFire);
    this->m_fxSysEngFire = 0;
  }
  v3 = this->m_fxSysProp[0];
  if ( v3 )
  {
    FxSystem_c::Kill(v3);
    this->m_fxSysProp[0] = 0;
  }
  v4 = this->m_fxSysProp[1];
  if ( v4 )
  {
    FxSystem_c::Kill(v4);
    this->m_fxSysProp[1] = 0;
  }
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CVehicle::~CVehicle(this);
  sub_199F98(v5);
}
// 56B1F6: variable 'v5' is possibly undefined
// 66DA20: using guessed type void *off_66DA20;

//----- (0056B200) --------------------------------------------------------
void __fastcall CBoat::SetModelIndex(CBoat *this, uint32 index)
{
  RpClump_0 *m_pRwObject; // r0

  CVehicle::SetModelIndex(this, index);
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aBoatNodes[8] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[10] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[4] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[6] = 0LL;
  *(_QWORD *)this->m_aBoatNodes = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aBoatNodes);
}

//----- (0056B230) --------------------------------------------------------
void __fastcall CBoat::SetupModelNodes(CBoat *this)
{
  RpClump_0 *m_pRwObject; // r2

  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aBoatNodes[8] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[10] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[4] = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[6] = 0LL;
  *(_QWORD *)this->m_aBoatNodes = 0LL;
  *(_QWORD *)&this->m_aBoatNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aBoatNodes);
}

//----- (0056B254) --------------------------------------------------------
void __fastcall CBoat::GetComponentWorldPosition(CBoat *this, int32 component, CVector *posn)
{
  RwMatrix *LTM; // r0
  __int64 v5; // d16

  LTM = RwFrameGetLTM(this->m_aBoatNodes[component]);
  v5 = *(_QWORD *)&LTM->pos.x;
  posn->z = LTM->pos.z;
  *(_QWORD *)&posn->x = v5;
}

//----- (0056B274) --------------------------------------------------------
bool __fastcall CBoat::IsComponentPresent(const CBoat *this, int32 component)
{
  return 1;
}

//----- (0056B278) --------------------------------------------------------
void __fastcall CBoat::PreRender(CBoat *this)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d8
  int32 v4; // r5
  float *p_m_fPropellerAngle; // r4
  float m_fEngineSpeed; // s0
  float v7; // s0
  int32 v8; // r8
  RwFrame_0 *v9; // r1
  RwFrame_0 *v10; // r1
  RwFrame_0 *v11; // r1
  RwFrame_0 *v12; // r1
  int m_nModelIndex; // r0
  RwFrame_0 *v14; // r0
  unsigned int v15; // r0
  RwFrame_0 *v16; // r1
  float *p_m_fScan; // r5
  void (__fastcall *v18)(RwObject_0 *); // r4
  RwObject_0 *FirstObject; // r0
  float z; // s12
  float32x4_t v21; // q0
  unsigned int v22; // r9
  int v23; // r10
  float v24; // s8
  float32x4_t v25; // q8
  float v26; // s4
  float v27; // s8
  float v28; // s4
  float v29; // s16
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r11
  FxSystem_c **v32; // r8
  FxSystem_c *v33; // r0
  char *v34; // r5
  RwFrame_0 *v35; // r0
  RwMatrix *LTM; // r0
  __int64 v37; // kr00_8
  RwReal v38; // r0
  FxSystem_c *v39; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r4
  int32 PlayStatus; // r0
  RwMatrix *v42; // r0
  __int64 v43; // kr08_8
  RwReal v44; // r0
  RwFrame_0 **v45; // [sp+Ch] [bp-A4h]
  FxSystem_c **m_fxSysProp; // [sp+10h] [bp-A0h]
  CVector vecOffset; // [sp+14h] [bp-9Ch] BYREF
  RwV3d_0 offsetPos; // [sp+20h] [bp-90h] BYREF
  RpAtomic_0 *data; // [sp+2Ch] [bp-84h] BYREF
  CVector v; // [sp+30h] [bp-80h] BYREF
  CMatrix v51; // [sp+40h] [bp-70h] BYREF

  CVehicle::PreRender(this);
  v4 = 0;
  this->m_lightingFromCollision = 0.5;
  v51.m_pRwMat = 0;
  v51.m_owner = 0;
  data = 0;
  CVehicle::SetComponentRotation(
    this,
    this->m_aBoatNodes[3],
    2,
    COERCE_FLOAT(LODWORD(this->m_fSteerAngle) ^ 0x80000000),
    1);
  CVehicle::SetComponentRotation(
    this,
    this->m_aBoatNodes[6],
    2,
    COERCE_FLOAT(LODWORD(this->m_fSteerAngle) ^ 0x80000000),
    1);
  CVehicle::SetComponentRotation(
    this,
    this->m_aBoatNodes[7],
    2,
    COERCE_FLOAT(LODWORD(this->m_fSteerAngle) ^ 0x80000000),
    1);
  v2.n64_u32[0] = 1.0;
  p_m_fPropellerAngle = &this->m_fPropellerAngle;
  m_fEngineSpeed = this->m_fEngineSpeed;
  v1.n64_f32[0] = (float)(m_fEngineSpeed + m_fEngineSpeed) / 0.3927;
  v7 = this->m_fPropellerAngle + (float)(m_fEngineSpeed * CTimer::ms_fTimeStep);
  this->m_fPropellerAngle = v7;
  v8 = (int)(float)((float)(1.0 - vmin_f32(v1, v2).n64_f32[0]) * 255.0);
  if ( v7 > 6.2832 )
  {
    do
      v7 = v7 + -6.2832;
    while ( v7 > 6.2832 );
    *p_m_fPropellerAngle = v7;
  }
  v9 = this->m_aBoatNodes[8];
  if ( 150 - v8 > 0 )
    v4 = 150 - v8;
  if ( v9 )
  {
    CVehicle::SetComponentRotation(this, v9, 1, v7 + v7, 1);
    data = 0;
    RwFrameForAllObjects(this->m_aBoatNodes[8], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, v8);
  }
  v10 = this->m_aBoatNodes[9];
  if ( v10 )
  {
    CVehicle::SetComponentRotation(this, v10, 1, COERCE_FLOAT(*(_DWORD *)p_m_fPropellerAngle ^ 0x80000000), 1);
    data = 0;
    RwFrameForAllObjects(this->m_aBoatNodes[9], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, v4);
  }
  v11 = this->m_aBoatNodes[10];
  if ( v11 )
  {
    CVehicle::SetComponentRotation(this, v11, 1, *p_m_fPropellerAngle * -2.0, 1);
    data = 0;
    RwFrameForAllObjects(this->m_aBoatNodes[10], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, v8);
  }
  v12 = this->m_aBoatNodes[11];
  if ( v12 )
  {
    CVehicle::SetComponentRotation(this, v12, 1, *p_m_fPropellerAngle, 1);
    data = 0;
    RwFrameForAllObjects(this->m_aBoatNodes[11], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, v4);
  }
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( m_nModelIndex == 484 )
  {
    v14 = this->m_aBoatNodes[4];
    if ( v14 )
    {
      CMatrix::Attach(&v51, &v14->modelling, 0);
      v = *(CVector *)&v51.tx;
      memset(&offsetPos, 0, sizeof(offsetPos));
      Multiply3x3(&vecOffset, this->m_pMat, &v);
      CDoor::Process(&this->BoatDoor, this, &this->m_vecOldMoveSpeed, &this->m_vecOldTurnSpeed, &vecOffset);
      *((_DWORD *)&offsetPos.x + this->BoatDoor.m_nAxis) = LODWORD(this->BoatDoor.m_fAngle);
      CMatrix::SetRotate(&v51, offsetPos.x, offsetPos.y, offsetPos.z);
      v51.tx = v.x + v51.tx;
      v51.ty = v.y + v51.ty;
      v51.tz = v.z + v51.tz;
      CMatrix::UpdateRW(&v51);
      LOWORD(m_nModelIndex) = this->m_nModelIndex;
    }
    else
    {
      LOWORD(m_nModelIndex) = 484;
    }
  }
  v15 = (__int16)m_nModelIndex - 430;
  if ( v15 <= 0x18 && ((1 << v15) & 0x1800001) != 0 )
  {
    v16 = this->m_aBoatNodes[1];
    p_m_fScan = &this->m_fScan;
    if ( v16 )
    {
      CVehicle::SetComponentRotation(this, v16, 2, *p_m_fScan, 1);
      if ( CCheat::m_aCheatsActive[34] )
      {
        v18 = *(void (__fastcall **)(RwObject_0 *))&GetFirstObject(this->m_aBoatNodes[1])[9].type;
        FirstObject = GetFirstObject(this->m_aBoatNodes[1]);
        v18(FirstObject);
      }
    }
    *p_m_fScan = *p_m_fScan + (float)(CTimer::ms_fTimeStep * 0.02);
  }
  z = this->m_vecTurnFriction.z;
  v21 = *(float32x4_t *)&this->m_vecMoveSpeed.x;
  v22 = 0;
  v23 = 0;
  v24 = v21.n128_f32[2] * v21.n128_f32[2];
  v25 = vaddq_f32(v21, *(float32x4_t *)&this->m_vecMoveFriction.x);
  v21.n128_f32[2] = this->m_vecTurnSpeed.y + this->m_vecTurnFriction.y;
  v26 = (float)((float)(v21.n128_f32[0] * v21.n128_f32[0]) + (float)(v21.n128_f32[1] * v21.n128_f32[1])) + v24;
  v27 = this->m_vecTurnSpeed.z;
  *(float32x4_t *)&this->m_vecOldMoveSpeed.x = v25;
  v28 = sqrtf(v26);
  this->m_vecOldTurnSpeed.z = v27 + z;
  v21.n128_f32[0] = v28 + v28;
  this->m_vecOldTurnSpeed.y = v21.n128_f32[2];
  m_fxSysProp = this->m_fxSysProp;
  v45 = &this->m_aBoatNodes[8];
  LODWORD(v29) = vmin_f32((float32x2_t)v21.n128_u64[0], v2).n64_u32[0];
  do
  {
    m_pRwObject = this->m_pRwObject;
    if ( !m_pRwObject )
    {
      v34 = 0;
      v32 = &this->m_fxSysProp[v23];
      goto LABEL_35;
    }
    parent = (char *)m_pRwObject->parent;
    v32 = &m_fxSysProp[v22 / 2];
    v33 = m_fxSysProp[v22 / 2];
    v34 = parent + 16;
    if ( !v33 )
    {
      v35 = v45[v22];
      if ( v35 )
      {
        memset(&offsetPos, 0, sizeof(offsetPos));
        LTM = RwFrameGetLTM(v35);
        v37 = *(_QWORD *)&LTM->pos.x;
        v38 = LTM->pos.z;
        *((_QWORD *)parent + 8) = v37;
        *((RwReal *)parent + 18) = v38;
        RwMatrixUpdate((RwMatrix *)(parent + 16));
        v39 = FxManager_c::CreateFxSystem(&g_fxMan, "boat_prop", &offsetPos, (RwMatrix *)(parent + 16), 0);
        *v32 = v39;
        if ( v39 )
        {
          FxSystem_c::Play(v39);
          FxSystem_c::SetLocalParticles(*v32, 1u);
          FxSystem_c::CopyParentMatrix(*v32);
        }
      }
LABEL_35:
      v33 = *v32;
      if ( !*v32 )
        goto LABEL_42;
    }
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    PlayStatus = FxSystem_c::GetPlayStatus(v33);
    if ( (*(_WORD *)&m_nPhysicalFlags & 0x100) != 0 )
    {
      if ( PlayStatus == 1 )
        FxSystem_c::Play(*v32);
      v42 = RwFrameGetLTM(v45[v22]);
      v43 = *(_QWORD *)&v42->pos.x;
      v44 = v42->pos.z;
      *((_QWORD *)v34 + 6) = v43;
      *((RwReal *)v34 + 14) = v44;
      RwMatrixUpdate((RwMatrix *)v34);
      FxSystem_c::SetMatrix(*v32, (RwMatrix *)v34);
      FxSystem_c::SetConstTime(*v32, 1u, v29);
    }
    else if ( !PlayStatus )
    {
      FxSystem_c::Stop(*v32);
    }
LABEL_42:
    v22 += 2;
    ++v23;
  }
  while ( v22 != 4 );
  CVehicle::DoBoatSplashes(
    this,
    sqrtf(
      (float)((float)(this->m_fxBuoyancyForce.x * this->m_fxBuoyancyForce.x)
            + (float)(this->m_fxBuoyancyForce.y * this->m_fxBuoyancyForce.y))
    + (float)(this->m_fxBuoyancyForce.z * this->m_fxBuoyancyForce.z)));
  CMatrix::~CMatrix(&v51);
}
// 56B30A: variable 'v1' is possibly undefined
// 56B30A: variable 'v2' is possibly undefined

//----- (0056B760) --------------------------------------------------------
void __fastcall CBoat::Render(CBoat *this)
{
  int v2; // r2
  int v3; // r3
  int v4; // r5
  int v5; // r1
  int v6; // r5
  int v7; // r1
  int v8; // r2
  int v9; // r3
  RwMatrix v10; // [sp+0h] [bp-48h] BYREF

  this->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds + 3000;
  if ( !CCheat::m_aCheatsActive[34] )
    CVehicle::Render(this);
  if ( this->m_nModelIndex != 460 )
  {
    *(_DWORD *)KeepWaterOutIndices = 0x20000;
    *(_DWORD *)&KeepWaterOutIndices[2] = 65537;
    *(_DWORD *)&KeepWaterOutIndices[4] = 196610;
    KeepWaterOutVertices[0].color = (RwRGBA_0)-1;
    KeepWaterOutVertices[1].color = (RwRGBA_0)-1;
    KeepWaterOutVertices[2].color = (RwRGBA_0)-1;
    KeepWaterOutVertices[3].color = (RwRGBA_0)-1;
    switch ( this->m_nModelIndex )
    {
      case 0x1AE:
        v2 = -1078355558;
        v3 = 1064682127;
        v4 = 1069128090;
        KeepWaterOutVertices[0].position.x = -1.45;
        KeepWaterOutVertices[0].position.y = 1.9;
        KeepWaterOutVertices[0].position.z = 0.96;
        KeepWaterOutVertices[1].position.x = 1.45;
        KeepWaterOutVertices[1].position.y = 1.9;
        v5 = -1066401792;
        KeepWaterOutVertices[1].position.z = 0.96;
        goto LABEL_16;
      case 0x1AF:
      case 0x1B0:
      case 0x1B1:
      case 0x1B2:
      case 0x1B3:
      case 0x1B4:
      case 0x1B5:
      case 0x1B6:
      case 0x1B7:
      case 0x1B8:
      case 0x1B9:
      case 0x1BA:
      case 0x1BB:
      case 0x1BC:
      case 0x1BD:
      case 0x1BF:
      case 0x1C0:
      case 0x1C1:
      case 0x1C2:
      case 0x1C3:
      case 0x1C7:
      case 0x1C8:
      case 0x1C9:
      case 0x1CA:
      case 0x1CB:
      case 0x1CC:
      case 0x1CD:
      case 0x1CE:
      case 0x1CF:
      case 0x1D0:
      case 0x1D1:
      case 0x1D2:
      case 0x1D3:
      case 0x1D4:
      case 0x1D5:
      case 0x1D6:
      case 0x1D7:
      case 0x1DA:
      case 0x1DB:
      case 0x1DC:
      case 0x1DD:
      case 0x1DE:
      case 0x1DF:
      case 0x1E0:
      case 0x1E1:
      case 0x1E2:
      case 0x1E3:
        return;
      case 0x1BE:
        v6 = 1062769525;
        KeepWaterOutVertices[0].position.x = -1.222;
        KeepWaterOutVertices[0].position.y = 2.004;
        KeepWaterOutVertices[0].position.z = 1.409;
        KeepWaterOutVertices[1].position.x = 1.222;
        KeepWaterOutVertices[1].position.y = 2.004;
        v7 = -1079051813;
        v8 = -1080117166;
        KeepWaterOutVertices[1].position.z = 1.409;
        v9 = 1067366482;
        goto LABEL_14;
      case 0x1C4:
        v2 = -1080872141;
        v3 = 1065604874;
        v4 = 1066611507;
        KeepWaterOutVertices[0].position.x = -1.15;
        KeepWaterOutVertices[0].position.y = 3.61;
        KeepWaterOutVertices[0].position.z = 1.03;
        KeepWaterOutVertices[1].position.x = 1.15;
        KeepWaterOutVertices[1].position.y = 3.61;
        v5 = 1031127695;
        KeepWaterOutVertices[1].position.z = 1.03;
        goto LABEL_16;
      case 0x1C5:
        KeepWaterOutVertices[2].position.x = -1.9;
        KeepWaterOutVertices[2].position.y = 2.83;
        KeepWaterOutVertices[2].position.z = 1.0;
        KeepWaterOutVertices[3].position.x = 1.9;
        KeepWaterOutVertices[3].position.y = 2.83;
        KeepWaterOutVertices[3].position.z = 1.0;
        KeepWaterOutVertices[0].position.x = -1.66;
        KeepWaterOutVertices[0].position.y = -4.48;
        KeepWaterOutVertices[0].position.z = 0.83;
        KeepWaterOutVertices[1].position.x = 1.66;
        KeepWaterOutVertices[1].position.y = -4.48;
        KeepWaterOutVertices[1].position.z = 0.83;
        goto LABEL_17;
      case 0x1C6:
        v2 = -1074698125;
        v4 = 1072785523;
        KeepWaterOutVertices[0].position.x = -1.886;
        KeepWaterOutVertices[0].position.y = -2.347;
        KeepWaterOutVertices[0].position.z = 0.787;
        KeepWaterOutVertices[1].position.x = 1.886;
        KeepWaterOutVertices[1].position.y = -2.347;
        v5 = -1063948124;
        KeepWaterOutVertices[1].position.z = 0.787;
        v3 = 1062702416;
        goto LABEL_16;
      case 0x1D8:
        v6 = 1052971631;
        KeepWaterOutVertices[0].position.x = -0.663;
        KeepWaterOutVertices[0].position.y = 3.565;
        KeepWaterOutVertices[0].position.z = 0.382;
        KeepWaterOutVertices[1].position.x = 0.663;
        KeepWaterOutVertices[1].position.y = 3.565;
        v7 = 1062517866;
        v8 = -1081400623;
        KeepWaterOutVertices[1].position.z = 0.382;
        v9 = 1066083025;
        goto LABEL_14;
      case 0x1D9:
        v6 = 1057115603;
        KeepWaterOutVertices[0].position.x = -0.797;
        KeepWaterOutVertices[0].position.y = 1.641;
        KeepWaterOutVertices[0].position.z = 0.573;
        KeepWaterOutVertices[1].position.x = 0.797;
        KeepWaterOutVertices[1].position.y = 1.641;
        v7 = -1078405890;
        v8 = -1084395356;
        KeepWaterOutVertices[1].position.z = 0.573;
        v9 = 1063088292;
LABEL_14:
        LODWORD(KeepWaterOutVertices[3].position.x) = v9;
        LODWORD(KeepWaterOutVertices[3].position.y) = v7;
        LODWORD(KeepWaterOutVertices[3].position.z) = v6;
        LODWORD(KeepWaterOutVertices[2].position.x) = v8;
        LODWORD(KeepWaterOutVertices[2].position.y) = v7;
        LODWORD(KeepWaterOutVertices[2].position.z) = v6;
        goto LABEL_17;
      case 0x1E4:
        v3 = 1061779669;
        v4 = 1065546154;
        KeepWaterOutVertices[0].position.x = -1.246;
        KeepWaterOutVertices[0].position.y = -1.373;
        KeepWaterOutVertices[0].position.z = 0.787;
        KeepWaterOutVertices[1].position.x = 1.246;
        KeepWaterOutVertices[1].position.y = -1.373;
        v5 = -1062580781;
        v2 = -1081937494;
        KeepWaterOutVertices[1].position.z = 0.787;
        goto LABEL_16;
      default:
        if ( this->m_nModelIndex != 595 )
          return;
        v2 = -1082130432;
        v3 = 1050253722;
        v4 = 1065353216;
        KeepWaterOutVertices[0].position.x = -1.0;
        KeepWaterOutVertices[0].position.y = 2.5;
        KeepWaterOutVertices[0].position.z = 0.3;
        KeepWaterOutVertices[1].position.x = 1.0;
        KeepWaterOutVertices[1].position.y = 2.5;
        v5 = -1062417203;
        KeepWaterOutVertices[1].position.z = 0.3;
LABEL_16:
        LODWORD(KeepWaterOutVertices[3].position.x) = v4;
        LODWORD(KeepWaterOutVertices[3].position.y) = v5;
        LODWORD(KeepWaterOutVertices[3].position.z) = v3;
        LODWORD(KeepWaterOutVertices[2].position.x) = v2;
        LODWORD(KeepWaterOutVertices[2].position.y) = v5;
        LODWORD(KeepWaterOutVertices[2].position.z) = v3;
LABEL_17:
        KeepWaterOutVertices[0].texCoords.u = 0.0;
        KeepWaterOutVertices[0].texCoords.v = 0.0;
        KeepWaterOutVertices[1].texCoords.u = 1.0;
        KeepWaterOutVertices[1].texCoords.v = 0.0;
        KeepWaterOutVertices[2].texCoords = (RwTexCoords_0)0x3F80000000000000LL;
        KeepWaterOutVertices[3].texCoords.u = 1.0;
        KeepWaterOutVertices[3].texCoords.v = 1.0;
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpWaterTex->raster);
        RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        if ( !CCheat::m_aCheatsActive[34] )
        {
          CMatrix::UpdateRwMatrix(this->m_pMat, &v10);
          if ( RwIm3DTransform(KeepWaterOutVertices, 4u, &v10, 1u) )
          {
            RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, KeepWaterOutIndices, 6);
            RwIm3DEnd();
          }
        }
        if ( this->m_nModelIndex == 472 )
        {
          KeepWaterOutVertices[0].position.x = -1.087;
          KeepWaterOutVertices[0].position.y = 0.831;
          KeepWaterOutVertices[0].position.z = 0.381;
          KeepWaterOutVertices[1].position.z = 0.381;
          KeepWaterOutVertices[2].position.z = 0.381;
          KeepWaterOutVertices[2].texCoords.u = 0.0;
          KeepWaterOutVertices[2].texCoords.v = 1.0;
          KeepWaterOutVertices[3].position.x = 1.097;
          KeepWaterOutVertices[3].position.y = -2.977;
          KeepWaterOutVertices[3].position.z = 0.381;
          KeepWaterOutVertices[3].texCoords.v = 1.0;
          KeepWaterOutVertices[1].texCoords = (RwTexCoords_0)1065353216LL;
          *(_QWORD *)&KeepWaterOutVertices[2].position.x = 0xC03E872BBF8C6A7FLL;
          KeepWaterOutVertices[3].texCoords.u = 1.0;
          KeepWaterOutVertices[0].texCoords = 0LL;
          *(_QWORD *)&KeepWaterOutVertices[1].position.x = 0x3F54BC6A3F8B22D1LL;
          if ( !CCheat::m_aCheatsActive[34] )
          {
            CMatrix::UpdateRwMatrix(this->m_pMat, &v10);
            if ( RwIm3DTransform(KeepWaterOutVertices, 4u, &v10, 1u) )
            {
              RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, KeepWaterOutIndices, 6);
              RwIm3DEnd();
            }
          }
        }
        RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
        break;
    }
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (0056BCB8) --------------------------------------------------------
void __fastcall CBoat::ProcessControlInputs(CBoat *this, uint8 CtrlNum)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  int32 v5; // r5
  uint8 v7; // r0
  CPad *Pad; // r0
  int Brake; // s0
  float *p_m_fBrakePedal; // r0
  float v11; // s0
  bool v12; // cc
  CPad *v13; // r0
  CPad *v14; // r0
  tHandlingData *pHandling; // r0
  float v16; // s0

  v5 = CtrlNum;
  v7 = CtrlNum;
  if ( CtrlNum >= 3u )
    v7 = 3;
  this->nPadNum = v7;
  Pad = CPad::GetPad(CtrlNum);
  Brake = CPad::GetBrake(Pad);
  p_m_fBrakePedal = &this->m_fBrakePedal;
  v11 = this->m_fBrakePedal + (float)((float)((float)((float)Brake / 255.0) - this->m_fBrakePedal) * 0.1);
  this->m_fBrakePedal = v11;
  v12 = v11 <= 1.0;
  if ( v11 >= 1.0 )
    v12 = v11 <= 0.0;
  if ( v12 )
  {
    if ( v11 <= 0.0 )
    {
      *p_m_fBrakePedal = 0.0;
    }
    else
    {
      *p_m_fBrakePedal = v11;
      if ( v11 >= 0.05 )
        goto LABEL_7;
    }
    *p_m_fBrakePedal = 0.0;
    v13 = CPad::GetPad(v5);
    v2.n64_f32[0] = (float)CPad::GetAccelerate(v13) / 255.0;
    goto LABEL_13;
  }
  v11 = 1.0;
  *p_m_fBrakePedal = 1.0;
LABEL_7:
  v2.n64_f32[0] = v11 * -0.3;
LABEL_13:
  LODWORD(this->m_fGasPedal) = v2.n64_u32[0];
  v14 = CPad::GetPad(v5);
  this->fSteer = this->fSteer
               + (float)(CTimer::ms_fTimeStep
                       * (float)((float)((float)((float)-CPad::GetSteeringLeftRight(v14) * 0.0078125) - this->fSteer)
                               * 0.2));
  v3.n64_u32[0] = CVehicle::GetNewSteeringAmt(this);
  v4.n64_u32[0] = 1.0;
  pHandling = this->pHandling;
  v2.n64_f32[0] = v3.n64_f32[0] + this->fSteer;
  v3.n64_u32[0] = -1.0;
  v16 = vmax_f32(vmin_f32(v2, v4), v3).n64_f32[0];
  this->fSteer = v16;
  this->m_fSteerAngle = v16 * (float)((float)(pHandling->fSteeringLock * 3.1416) / 180.0);
}
// 56BDDA: variable 'v2' is possibly undefined
// 56BDDA: variable 'v4' is possibly undefined
// 56BDDE: variable 'v3' is possibly undefined

//----- (0056BE30) --------------------------------------------------------
void __fastcall CBoat::DebugCode(CBoat *this)
{
  CPad *Pad; // r0
  RpClump_0 *m_pRwObject; // r0
  int v4; // r3

  if ( FindPlayerVehicle(-1, 0) == this && !CPad::GetPad(this->nPadNum)->NewState.Start )
  {
    Pad = CPad::GetPad(0);
    if ( Pad->NewState.DPadLeft )
    {
      if ( !Pad->OldState.DPadLeft )
      {
        m_pRwObject = (RpClump_0 *)this->m_pRwObject;
        v4 = *((unsigned __int8 *)&CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][1].m_flags + 2);
        *(_QWORD *)&this->m_aBoatNodes[8] = 0LL;
        *(_QWORD *)&this->m_aBoatNodes[10] = 0LL;
        *(_QWORD *)&this->m_aBoatNodes[4] = 0LL;
        *(_QWORD *)&this->m_aBoatNodes[6] = 0LL;
        *(_QWORD *)this->m_aBoatNodes = 0LL;
        *(_QWORD *)&this->m_aBoatNodes[2] = 0LL;
        this->pHandling = &mod_HandlingManager.m_aHandlingData[v4];
        sub_18AA98(m_pRwObject, this->m_aBoatNodes);
      }
    }
  }
}

//----- (0056BEC0) --------------------------------------------------------
void __fastcall CBoat::ProcessControl(CBoat *this)
{
  float *m_fWakePtCounters; // r0
  float v3; // s0
  unsigned int v4; // r1
  float v5; // s2
  float m_fMass; // s4
  float m_fBuoyancyConstant; // s2
  CVehicle *PlayerVehicle; // r0
  unsigned int Mission; // r0
  uint32 v10; // r5
  CPhysical::CPhysicalFlags v11; // r0
  CMatrix *m_pMat; // r6
  CBoat::CBoatFlags v13; // r1
  CSimpleTransform *p_tx; // r5
  int m_nVehicleFlags; // r2
  const CVector *PlayerCentreOfWorld_NoSniperShift; // r0
  float32x2_t v17; // d16
  unsigned __int64 v18; // d1
  CBoat::CBoatFlags m_nBoatFlags; // r1
  CPed *pDriver; // r0
  CBoat::CBoatFlags v21; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  CBoat::CBoatFlags v23; // r0
  unsigned int m_info; // r0
  float v25; // s0
  float m_fGasPedal; // s2
  float v27; // s4
  float *p_m_fEngineSpeed; // r1
  float v29; // s0
  float *p_m_nHealth; // r5
  float m_nHealth; // s16
  CPed *v32; // r0
  float v33; // s0
  char v34; // r0
  float v35; // s2
  float m_fEngineSpeed; // s0
  float v37; // s0
  float v38; // s0
  FxSystem_c *m_fxSysEngFire; // r0
  CMatrix *v40; // r1
  CSimpleTransform *p_m_transform; // r0
  CSimpleTransform *v42; // r1
  int m_nModelIndex; // r0
  int v44; // s2
  RwReal v45; // s4
  RwReal v46; // s6
  RwObject_0 *m_pRwObject; // r0
  FxSystem_c *v48; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  float v50; // s0
  int v51; // r5
  int v52; // r6
  CBoat *v53; // r0
  eFlightModel v54; // r1
  CMatrix *v55; // r5
  float fLockedHeading; // s16
  float m_heading; // s0
  float v58; // s0
  CSimpleTransform *v59; // r0
  float x; // r6
  float y; // r8
  float z; // r9
  CEventVehicleOnFire v63; // [sp+Ch] [bp-44h] BYREF
  RwV3d_0 offsetPos; // [sp+20h] [bp-30h] BYREF
  float fDamage[9]; // [sp+2Ch] [bp-24h] BYREF

  CAEVehicleAudioEntity::Service(&this->m_VehicleAudioEntity);
  m_fWakePtCounters = this->m_fWakePtCounters;
  v3 = CTimer::ms_fTimeStep;
  v4 = 0;
  while ( 1 )
  {
    v5 = *m_fWakePtCounters;
    if ( *m_fWakePtCounters <= 0.0 )
      break;
    if ( v5 <= v3 )
    {
      *m_fWakePtCounters = 0.0;
      break;
    }
    ++v4;
    *m_fWakePtCounters++ = v5 - v3;
    if ( v4 >= 0x20 )
      goto LABEL_8;
  }
  this->m_nNumWakeCoords = v4;
LABEL_8:
  CVehicle::ProcessDelayedExplosion(this);
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) != 0 )
  {
    m_fMass = this->m_fMass;
    m_fBuoyancyConstant = this->m_fBuoyancyConstant;
    if ( m_fBuoyancyConstant > (float)((float)((float)(m_fMass * 0.008) * 100.0) / 125.0) )
      this->m_fBuoyancyConstant = m_fBuoyancyConstant + (float)((float)(m_fMass * -0.001) * 0.008);
  }
  if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL1 && this->m_nModelIndex == 430 )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    if ( PlayerVehicle )
    {
      if ( CVehicle::GetVehicleAppearance(PlayerVehicle) == APR_BOAT )
      {
        Mission = this->AutoPilot.Mission;
        if ( Mission <= 0x15 && ((1 << Mission) & 0x20003C) != 0 )
        {
          v10 = CTimer::m_snTimeInMilliseconds;
          if ( CTimer::m_snTimeInMilliseconds > this->m_nNextTalkTimer )
            this->m_nNextTalkTimer = (rand() & 0xFFF) + v10 + 4500;
        }
      }
    }
  }
  CVehicle::UpdateClumpAlpha(this);
  CVehicle::ProcessCarAlarm(this);
  switch ( *(_BYTE *)&this->m_info >> 3 )
  {
    case 0:
      m_nBoatFlags = this->m_nBoatFlags;
      this->fLockedHeading = -10000.0;
      pDriver = this->pDriver;
      this->m_nBoatFlags = (CBoat::CBoatFlags)(*(_BYTE *)&m_nBoatFlags & 0xFB);
      if ( pDriver )
        (*((void (__fastcall **)(CBoat *, _DWORD))this->_vptr$CPlaceable + 25))(this, LOBYTE(pDriver->m_nPedType));
      if ( this->m_nModelIndex == 430 )
        CVehicle::DoFixedMachineGuns(this);
      CVehicle::DoDriveByShootings(this);
      goto LABEL_31;
    case 2:
      v21 = (CBoat::CBoatFlags)(*(_BYTE *)&this->m_nBoatFlags & 0xFB);
      this->fLockedHeading = -10000.0;
      this->m_nBoatFlags = v21;
      CCarAI::UpdateCarAI(this);
      CPhysical::ProcessControl(this);
      m_nPhysicalFlags = this->m_nPhysicalFlags;
      *(_BYTE *)&this->m_nBoatFlags |= 3u;
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x100);
      return;
    case 3:
      v23 = (CBoat::CBoatFlags)(*(_BYTE *)&this->m_nBoatFlags & 0xFB);
      this->fLockedHeading = -10000.0;
      this->m_nBoatFlags = v23;
      CCarAI::UpdateCarAI(this);
      CCarCtrl::SteerAICarWithPhysics(this);
      goto LABEL_31;
    case 4:
    case 5:
      v11 = this->m_nPhysicalFlags;
      m_pMat = this->m_pMat;
      this->m_fSteerAngle = 0.0;
      v13 = this->m_nBoatFlags;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      this->m_fGasPedal = 0.0;
      this->m_fBrakePedal = 0.5;
      m_nVehicleFlags = (int)this->m_nVehicleFlags;
      this->m_nBoatFlags = (CBoat::CBoatFlags)(*(_BYTE *)&v13 | 3);
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v11 | 0x100);
      *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFDF;
      PlayerCentreOfWorld_NoSniperShift = FindPlayerCentreOfWorld_NoSniperShift(0);
      if ( !m_pMat )
        p_tx = &this->m_transform;
      v17.n64_u64[0] = vsub_f32(
                         *(float32x2_t *)&p_tx->m_translate.y,
                         *(float32x2_t *)&PlayerCentreOfWorld_NoSniperShift->y).n64_u64[0];
      v18 = vmul_f32(v17, v17).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(p_tx->m_translate.x - PlayerCentreOfWorld_NoSniperShift->x)
                           * (float)(p_tx->m_translate.x - PlayerCentreOfWorld_NoSniperShift->x))
                   + *(float *)&v18)
           + *((float *)&v18 + 1)) <= 150.0 )
        goto LABEL_31;
      this->m_vecTurnSpeed.y = 0.0;
      this->m_vecTurnSpeed.z = 0.0;
      *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
      *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
      return;
    default:
LABEL_31:
      m_info = (unsigned __int8)this->m_info;
      if ( m_info >> 3 <= 8 && ((1 << (*(_BYTE *)&this->m_info >> 3)) & 0x109) != 0 )
      {
        v25 = CPlane::PLANE_ROC_PROP_SPEED;
        if ( this->m_nModelIndex == 460 )
        {
          m_fGasPedal = this->m_fGasPedal;
          v27 = CPlane::PLANE_STD_PROP_SPEED;
        }
        else
        {
          v27 = 0.0;
          m_fGasPedal = this->m_fGasPedal;
          if ( m_fGasPedal != 0.0 )
            v25 = CPlane::PLANE_ROC_PROP_SPEED * 5.0;
        }
        if ( m_fGasPedal <= 0.0 )
        {
          if ( m_fGasPedal < 0.0 )
            v27 = CPlane::PLANE_STD_PROP_SPEED
                + (float)(m_fGasPedal * (float)(CPlane::PLANE_STD_PROP_SPEED - CPlane::PLANE_MIN_PROP_SPEED));
        }
        else
        {
          v27 = CPlane::PLANE_STD_PROP_SPEED
              + (float)(m_fGasPedal * (float)(CPlane::PLANE_MAX_PROP_SPEED - CPlane::PLANE_STD_PROP_SPEED));
        }
        p_m_fEngineSpeed = &this->m_fEngineSpeed;
        v29 = this->m_fEngineSpeed + (float)(CTimer::ms_fTimeStep * (float)(v25 * (float)(v27 - this->m_fEngineSpeed)));
        goto LABEL_42;
      }
      p_m_fEngineSpeed = &this->m_fEngineSpeed;
      m_fEngineSpeed = this->m_fEngineSpeed;
      if ( m_fEngineSpeed > 0.0 )
      {
        v29 = m_fEngineSpeed * 0.95;
LABEL_42:
        *p_m_fEngineSpeed = v29;
      }
      fDamage[0] = this->m_fDamageImpulseMagnitude * this->pHandling->fCollisionDamageMultiplier;
      if ( fDamage[0] > 25.0 && (m_info & 0xF8) != 40 )
      {
        p_m_nHealth = &this->m_nHealth;
        m_nHealth = this->m_nHealth;
        if ( m_nHealth >= 250.0 )
        {
          CVehicle::ReduceVehicleDamage(this, fDamage);
          if ( this == FindPlayerVehicle(-1, 0) )
          {
            v33 = 2.0;
            v34 = *((_BYTE *)&this->m_nVehicleFlags + 1);
            v35 = 6.0;
          }
          else
          {
            if ( fDamage[0] > 60.0 )
            {
              v32 = this->pDriver;
              if ( v32 )
                CPed::Say(v32, 0x44u, 0, 1.0, 0, 0, 0);
            }
            v33 = 4.0;
            v34 = *((_BYTE *)&this->m_nVehicleFlags + 1);
            v35 = 12.0;
          }
          if ( (v34 & 0x80) != 0 )
            v33 = v35;
          v37 = *p_m_nHealth - (float)((float)(fDamage[0] + -25.0) / v33);
          *p_m_nHealth = v37;
          if ( m_nHealth > 0.0 && v37 <= 0.0 )
          {
            *p_m_nHealth = 1.0;
            this->pEntityThatSetUsOnFire = this->m_pDamageEntity;
          }
        }
      }
      v38 = this->m_nHealth;
      if ( v38 > 460.0 || (*(_BYTE *)&this->m_info & 0xF8) == 40 )
      {
        m_fxSysEngFire = this->m_fxSysEngFire;
        this->m_BlowUpTimer = 0.0;
        if ( m_fxSysEngFire )
        {
          FxSystem_c::Kill(m_fxSysEngFire);
          this->m_fxSysEngFire = 0;
        }
      }
      else
      {
        v40 = this->m_pMat;
        p_m_transform = (CSimpleTransform *)&v40->tx;
        if ( !v40 )
          p_m_transform = &this->m_transform;
        v42 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          v42 = &TheCamera.m_transform;
        if ( fabsf(p_m_transform->m_translate.x - v42->m_translate.x) < 200.0
          && fabsf(p_m_transform->m_translate.y - v42->m_translate.y) < 200.0 )
        {
          m_nModelIndex = this->m_nModelIndex;
          if ( m_nModelIndex == 453 )
          {
            v44 = 1.5;
            v45 = -1.0;
            v46 = 2.0;
          }
          else if ( m_nModelIndex == 452 )
          {
            v44 = 1072064102;
            v45 = -2.4;
            v46 = 0.4;
          }
          else
          {
            v45 = -0.5;
            v44 = 1074580685;
            v46 = -1.5;
          }
          offsetPos.y = v45;
          offsetPos.x = v46;
          LODWORD(offsetPos.z) = v44;
          if ( v38 < 250.0 )
          {
            if ( !this->m_fxSysEngFire )
            {
              m_pRwObject = this->m_pRwObject;
              if ( m_pRwObject )
              {
                v48 = FxManager_c::CreateFxSystem(
                        &g_fxMan,
                        "fire_car",
                        &offsetPos,
                        (RwMatrix *)((char *)m_pRwObject->parent + 16),
                        0);
                this->m_fxSysEngFire = v48;
                if ( v48 )
                {
                  FxSystem_c::Play(v48);
                  CEventVehicleOnFire::CEventVehicleOnFire(&v63, this);
                  EventGlobalGroup = GetEventGlobalGroup();
                  CEventGroup::Add(EventGlobalGroup, (CEvent *)&v63, 0);
                  CEventVehicleOnFire::~CEventVehicleOnFire(&v63);
                }
              }
            }
            v50 = this->m_BlowUpTimer + (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
            this->m_BlowUpTimer = v50;
            if ( v50 > 5000.0 )
              (*((void (__fastcall **)(CBoat *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(
                this,
                this->pEntityThatSetUsOnFire,
                0);
          }
        }
      }
      v51 = *(_DWORD *)&this->m_nFlags & 0x1000;
      v52 = this->m_fDamageImpulseMagnitude > 0.0 && this->m_vecDamageNormal.z > 0.1;
      CPhysical::ProcessControl(this);
      CVehicle::ProcessBoatControl(this, this->pBoatHandling, &this->fPrevVolume, v51 != 0, v52);
      if ( this->m_nModelIndex != 460 )
      {
        if ( !CCheat::m_aCheatsActive[42] )
          goto LABEL_91;
        v53 = this;
        v54 = FLIGHTMODEL_PLANE_GLIDER;
        goto LABEL_90;
      }
      if ( this->m_fEngineSpeed > CPlane::PLANE_MIN_PROP_SPEED
        || (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                 + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.05 )
      {
        v53 = this;
        v54 = FLIGHTMODEL_PLANE;
LABEL_90:
        CVehicle::FlyingControl(v53, v54, -10000.0, -10000.0, -10000.0, -10000.0);
      }
LABEL_91:
      if ( (*(_BYTE *)&this->m_nBoatFlags & 4) != 0 )
      {
        v55 = this->m_pMat;
        fLockedHeading = this->fLockedHeading;
        this->m_vecMoveSpeed.x = 0.0;
        this->m_vecMoveSpeed.y = 0.0;
        if ( v55 )
          m_heading = atan2f(COERCE_FLOAT(LODWORD(v55->xy) ^ 0x80000000), v55->yy);
        else
          m_heading = this->m_transform.m_heading;
        if ( fLockedHeading == -10000.0 )
        {
          this->fLockedHeading = m_heading;
        }
        else
        {
          v58 = fLockedHeading - m_heading;
          v59 = (CSimpleTransform *)&v55->tx;
          if ( !v55 )
            v59 = &this->m_transform;
          x = v59->m_translate.x;
          y = v59->m_translate.y;
          z = v59->m_translate.z;
          CMatrix::RotateZ(v55, v58);
          this->m_pMat->tx = x;
          this->m_pMat->ty = y;
          this->m_pMat->tz = z;
        }
      }
      return;
  }
}
// 56BEC0: using guessed type float fDamage[9];

//----- (0056C678) --------------------------------------------------------
void __fastcall CBoat::PruneWakeTrail(CBoat *this)
{
  float *m_fWakePtCounters; // r1
  float v2; // s0
  unsigned int v3; // r2
  float v4; // s2

  m_fWakePtCounters = this->m_fWakePtCounters;
  v2 = CTimer::ms_fTimeStep;
  v3 = 0;
  while ( 1 )
  {
    v4 = *m_fWakePtCounters;
    if ( *m_fWakePtCounters <= 0.0 )
      break;
    if ( v4 <= v2 )
    {
      *m_fWakePtCounters = 0.0;
      break;
    }
    ++v3;
    *m_fWakePtCounters++ = v4 - v2;
    if ( v3 >= 0x20 )
      return;
  }
  this->m_nNumWakeCoords = v3;
}

//----- (0056C6C0) --------------------------------------------------------
void __fastcall CBoat::Teleport(CBoat *this, CVector NewCoors, int bClearOrientation)
{
  RwReal z; // r8
  float y; // r6
  RwReal x; // r5
  CMatrix *m_pMat; // r1
  float *p_tz; // r1
  CMatrix *v9; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v13; // r0
  float v14; // s2
  float v15; // s4

  z = NewCoors.z;
  y = NewCoors.y;
  x = NewCoors.x;
  CWorld::Remove(this);
  m_pMat = this->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = x;
    this->m_pMat->ty = y;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = x;
    this->m_transform.m_translate.y = y;
  }
  *p_tz = z;
  if ( bClearOrientation )
  {
    v9 = this->m_pMat;
    if ( v9 )
    {
      tx = v9->tx;
      ty = v9->ty;
      tz = v9->tz;
      CMatrix::SetRotate(v9, 0.0, 0.0, 0.0);
      v13 = this->m_pMat;
      v14 = ty + v13->ty;
      v15 = tz + v13->tz;
      v13->tx = tx + v13->tx;
      v13->ty = v14;
      v13->tz = v15;
    }
    else
    {
      this->m_transform.m_heading = 0.0;
    }
  }
  this->m_vecTurnSpeed.y = 0.0;
  this->m_vecTurnSpeed.z = 0.0;
  *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
  sub_19B3E4(this);
}

//----- (0056C764) --------------------------------------------------------
void __fastcall CBoat::DisplayHandlingData(CBoat *this)
{
  unsigned __int8 s[64]; // [sp+4h] [bp-4Ch] BYREF

  sprintf(s, "Thrust %3.2f", (float)(this->pHandling->Transmission.m_fEngineAcceleration * this->pHandling->fMass));
  sprintf(s, "Rudder Angle  %3.2f", this->pHandling->fSteeringLock);
}

//----- (0056C7F4) --------------------------------------------------------
void __fastcall CBoat::ModifyHandlingValue(CBoat *this, const bool *bPlus)
{
  float v2; // s0

  if ( this->nCurrentField == 4 )
  {
    v2 = 1.0;
    if ( !*bPlus )
      v2 = -1.0;
    this->pHandling->fSteeringLock = this->pHandling->fSteeringLock + v2;
  }
}

//----- (0056C824) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBoat::BlowUpCar(CBoat *this, CEntity *pCulprit, Bool8 bInACutscene)
{
  int noDamage; // r6
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r5
  RwReal v7; // s0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  RpClump_0 *m_pRwObject; // r0
  CSimpleTransform *p_m_transform; // r9
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  int v13; // r1
  int v14; // r2
  CMatrix *v15; // r0
  CSimpleTransform *v16; // r1
  __int64 v17; // kr08_8 OVERLAPPED
  RwFrame_0 *v18; // r0
  CObject *v19; // r5
  RwMatrix *LTM; // r8
  RwFrame_0 *v21; // r6
  RpAtomic_0 *v22; // r0
  __int64 v23; // d16
  __int64 v24; // d17
  __int64 v25; // d19
  __int64 v26; // d22
  __int64 v27; // d23
  __int64 v28; // d20
  __int64 v29; // d21
  int m_nFlags; // r3
  int (**v31)(void); // r0
  __int64 v32; // d16
  int *v33; // r0
  float z; // s2
  RwReal v35; // s0
  CMatrix *v36; // r0
  CMatrix *v37; // r1
  float *p_x; // r0
  float v39; // s4
  float v40; // s10
  RwReal v41; // s0
  CMatrix *v42; // r0
  float zz; // s2
  float v44; // s2
  float x; // s0
  float y; // s4
  float *p_xx; // r0
  float v48; // s4
  float v49; // s2
  __int64 v50; // [sp+0h] [bp-40h]
  CVector v51; // [sp+18h] [bp-28h] BYREF
  RwObject_0 *data[7]; // [sp+24h] [bp-1Ch] BYREF

  noDamage = bInACutscene;
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    v7 = this->m_vecMoveSpeed.z + 0.13;
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    m_pRwObject = (RpClump_0 *)this->m_pRwObject;
    this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x28);
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x20000000);
    this->m_vecMoveSpeed.z = v7;
    CVisibilityPlugins::SetClumpForAllAtomicsFlag(m_pRwObject, 0x4000);
    p_m_transform = &this->m_transform;
    m_pMat = this->m_pMat;
    p_tx = &this->m_transform;
    this->DelayedExplosion = 0;
    this->m_nHealth = 0.0;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    CCamera::CamShake(&TheCamera, 0.4, p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z);
    CVehicle::KillPedsInVehicle(this);
    v14 = *((_DWORD *)p_m_nVehicleFlags + 1);
    v13 = *(_DWORD *)p_m_nVehicleFlags;
    *((_BYTE *)&this->CVehicle + 1202) &= 0xE7u;
    *(_DWORD *)p_m_nVehicleFlags = v13 & 0xFFFFFFAF;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v14;
    CVehicle::ChangeLawEnforcerState(this, 0);
    v15 = this->m_pMat;
    v16 = &this->m_transform;
    if ( v15 )
      v16 = (CSimpleTransform *)&v15->tx;
    v17 = *(_QWORD *)&v16->m_translate.x;
    v50 = *(_QWORD *)&v16->m_translate.y;
    CExplosion::AddExplosion(this, pCulprit, EXP_TYPE_BOAT, *(CVector *)&v17, 0, 1u, -1.0, noDamage);
    CDarkel::RegisterCarBlownUpByPlayer(this, 0);
    v18 = this->m_aBoatNodes[1];
    if ( v18 )
    {
      data[0] = 0;
      RwFrameForAllObjects(v18, GetBoatAtomicObjectCB, data);
      if ( data[0] )
      {
        v19 = (CObject *)CObject::operator new(0x184u);
        CObject::CObject(v19);
        if ( v19 )
        {
          (*((void (__fastcall **)(CObject *, int))v19->_vptr$CPlaceable + 7))(v19, 379);
          CObject::RefModelInfo(v19, this->m_nModelIndex);
          LTM = RwFrameGetLTM(this->m_aBoatNodes[1]);
          v21 = RwFrameCreate();
          v22 = RpAtomicClone((RpAtomic_0 *)data[0]);
          data[0] = &v22->object.object;
          v23 = *(_QWORD *)&LTM->right.x;
          v24 = *(_QWORD *)&LTM->right.z;
          v25 = *(_QWORD *)&LTM->pos.z;
          v26 = *(_QWORD *)&LTM->up.x;
          v27 = *(_QWORD *)&LTM->up.z;
          v28 = *(_QWORD *)&LTM->at.x;
          v29 = *(_QWORD *)&LTM->at.z;
          *(_QWORD *)&v21->modelling.pos.x = *(_QWORD *)&LTM->pos.x;
          *(_QWORD *)&v21->modelling.pos.z = v25;
          *(_QWORD *)&v21->modelling.at.x = v28;
          *(_QWORD *)&v21->modelling.at.z = v29;
          *(_QWORD *)&v21->modelling.right.x = v23;
          *(_QWORD *)&v21->modelling.right.z = v24;
          *(_QWORD *)&v21->modelling.up.x = v26;
          *(_QWORD *)&v21->modelling.up.z = v27;
          RpAtomicSetFrame(v22, v21);
          CVisibilityPlugins::SetAtomicRenderCallback((RpAtomic_0 *)data[0], 0);
          CEntity::AttachToRwObject(v19, data[0], 1);
          v19->m_fMass = 10.0;
          v19->m_fTurnMass = 25.0;
          m_nFlags = (int)v19->m_nFlags;
          v19->m_fAirResistance = 0.99;
          v19->m_fElasticity = 0.1;
          v19->m_fBuoyancyConstant = 0.10667;
          *(_DWORD *)&v19->m_nFlags = m_nFlags | 0x80000;
          ++CObject::nNoTempObjects;
          v31 = v19->_vptr$CPlaceable;
          v19->ObjectCreatedBy = 3;
          ((void (__fastcall *)(CObject *, _DWORD))v31[5])(v19, 0);
          *(_DWORD *)&v19->m_nObjectFlags &= ~1u;
          v19->m_nEndOfLifeTime = CTimer::m_snTimeInMilliseconds + 20000;
          v32 = *(_QWORD *)&this->m_vecMoveSpeed.x;
          v19->m_vecMoveSpeed.z = this->m_vecMoveSpeed.z;
          *(_QWORD *)&v19->m_vecMoveSpeed.x = v32;
          v33 = &dword_56CB7C;
          if ( this->m_pMat->zz > 0.0 )
            v33 = &dword_56CB80;
          LODWORD(v19->m_vecMoveSpeed.z) = *v33;
          z = this->m_vecTurnSpeed.z;
          v35 = this->m_vecTurnSpeed.y + this->m_vecTurnSpeed.y;
          v19->m_vecTurnSpeed.x = 0.5;
          v19->m_vecTurnSpeed.y = v35;
          v19->m_vecTurnSpeed.z = z + z;
          v36 = this->m_pMat;
          v37 = v19->m_pMat;
          if ( v36 )
            p_m_transform = (CSimpleTransform *)&v36->tx;
          p_x = &v37->tx;
          v39 = p_m_transform->m_translate.z;
          if ( !v37 )
            p_x = &v19->m_transform.m_translate.x;
          v40 = p_x[2];
          v41 = *p_x - p_m_transform->m_translate.x;
          v51.y = p_x[1] - p_m_transform->m_translate.y;
          v51.x = v41;
          v51.z = v40 - v39;
          CVector::Normalise(&v51);
          v42 = this->m_pMat;
          zz = v42->zz;
          if ( zz <= 0.0 )
          {
            x = v51.x;
            y = v51.y;
            v44 = v51.z;
          }
          else
          {
            v44 = zz + v51.z;
            x = v42->xz + v51.x;
            y = v42->yz + v51.y;
            v51.x = x;
            v51.z = v44;
            v51.y = y;
          }
          p_xx = &v19->m_pMat->xx;
          v48 = y + p_xx[13];
          v49 = v44 + p_xx[14];
          p_xx[12] = x + p_xx[12];
          p_xx[13] = v48;
          p_xx[14] = v49;
          CWorld::Add(v19);
          data[0] = 0;
          RwFrameForAllObjects(this->m_aBoatNodes[1], GetBoatAtomicObjectCB, data);
          if ( data[0] )
            data[0]->flags = 0;
        }
      }
    }
  }
}
// 56C8EB: failed to expand linear variable kr08_8.8
// 56CB7C: using guessed type int dword_56CB7C;
// 56CB80: using guessed type int;

//----- (0056CB88) --------------------------------------------------------
void __fastcall CBoat::AddWakePoint(CBoat *this, CVector pos)
{
  unsigned int v2; // r12
  CMatrix *m_pMat; // r5
  CVector2D *m_vecWakeCoords; // r9
  CSimpleTransform *p_tx; // r6
  float32x2_t v6; // d16
  unsigned __int64 v7; // d1
  unsigned int m_nNumWakeCoords; // r8
  unsigned int v9; // r4
  float v10; // r1
  unsigned int v11; // r6
  float v12; // r1

  v2 = (unsigned int)(float)(sqrtf(
                               (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                     + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                             + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z))
                           * 100.0);
  if ( this->m_fWakePtCounters[0] <= 0.0 )
  {
    this->m_vecWakeCoords[0].x = pos.x;
    this->m_vecWakeCoords[0].y = pos.y;
    this->m_fWakeBoatSpeed[0] = v2;
    v10 = CBoat::WAKE_LIFETIME;
    this->m_nNumWakeCoords = 1;
    this->m_fWakePtCounters[0] = v10;
    return;
  }
  m_pMat = this->m_pMat;
  m_vecWakeCoords = this->m_vecWakeCoords;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v6.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)this->m_vecWakeCoords[0]).n64_u64[0];
  v7 = vmul_f32(v6, v6).n64_u64[0];
  if ( (float)(*(float *)&v7 + *((float *)&v7 + 1)) > (float)(CBoat::MIN_WAKE_INTERVAL * CBoat::MIN_WAKE_INTERVAL) )
  {
    if ( *(_BYTE *)&this->m_info > 7u )
    {
      m_nNumWakeCoords = this->m_nNumWakeCoords;
      if ( this->VehicleCreatedBy == 2 )
      {
        if ( m_nNumWakeCoords >= 0x14 )
        {
          v9 = 20;
          goto LABEL_16;
        }
      }
      else if ( m_nNumWakeCoords > 0xE )
      {
        v9 = 15;
        goto LABEL_16;
      }
    }
    else
    {
      m_nNumWakeCoords = this->m_nNumWakeCoords;
      if ( m_nNumWakeCoords >= 0x1F )
      {
        v9 = 31;
        goto LABEL_16;
      }
    }
    v9 = m_nNumWakeCoords;
    if ( !m_nNumWakeCoords )
    {
LABEL_19:
      this->m_vecWakeCoords[0].x = pos.x;
      this->m_vecWakeCoords[0].y = pos.y;
      v12 = CBoat::WAKE_LIFETIME;
      this->m_fWakeBoatSpeed[0] = v2;
      this->m_fWakePtCounters[0] = v12;
      if ( v9 <= 0x1F )
        this->m_nNumWakeCoords = v9 + 1;
      return;
    }
LABEL_16:
    v11 = v9;
    do
    {
      --v9;
      m_vecWakeCoords[v11].x = m_vecWakeCoords[v11 - 1].x;
      m_vecWakeCoords[v11].y = m_vecWakeCoords[v11 - 1].y;
      this->m_fWakePtCounters[v11] = *(&this->m_vecWakeCoords[31].y + v11);
      this->m_fWakeBoatSpeed[v11] = *((_BYTE *)&this->m_fWakePtCounters[31] + v11 + 3);
      v11 = (unsigned __int16)v9;
    }
    while ( (_WORD)v9 );
    v9 = m_nNumWakeCoords;
    goto LABEL_19;
  }
}

//----- (0056CCDC) --------------------------------------------------------
void CBoat::FillBoatList()
{
  float32x2_t v0; // d10
  float32x2_t v1; // d11
  float yy; // s0
  float xy; // s2
  CSimpleTransform *p_tx; // r1
  float y; // s6
  float v6; // s8
  float x; // s4
  CVehiclePool *v8; // r0
  int32 m_nSize; // r2
  int v10; // r1
  CBoat **v11; // r12
  int v12; // r2
  __int16 v13; // lr
  int v14; // r1
  unsigned __int64 v15; // d7
  CBoat **v16; // r3
  uint8 *v17; // r5
  int v18; // r6
  float *v19; // r4
  float v20; // s1
  float v21; // s3
  float v22; // s5
  float v23; // s1
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_m_transform; // r8
  CMatrix *v26; // r4
  CSimpleTransform *v27; // r12
  float v28; // s3
  CMatrix *v29; // r3
  float v30; // s5
  CMatrix *v31; // r8
  CSimpleTransform *v32; // r4
  CSimpleTransform *v33; // r3
  int v34; // r6
  float v35; // s3
  float v36; // s5
  float v37; // s5
  float32x2_t v38; // d9
  float v39; // s3
  float32x2_t v40; // d12
  float v41; // s16
  CBoat **v42; // [sp+0h] [bp-58h]
  CBoat **v43; // [sp+4h] [bp-54h]

  yy = TheCamera.m_cameraMatrix.yy;
  xy = TheCamera.m_cameraMatrix.xy;
  *(_QWORD *)CBoat::apFrameWakeGeneratingBoats = 0LL;
  *(_QWORD *)&CBoat::apFrameWakeGeneratingBoats[2] = 0LL;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  v6 = sqrtf(
         (float)(TheCamera.m_cameraMatrix.xy * TheCamera.m_cameraMatrix.xy)
       + (float)(TheCamera.m_cameraMatrix.yy * TheCamera.m_cameraMatrix.yy));
  x = p_tx->m_translate.x;
  if ( v6 > 0.0 )
  {
    yy = TheCamera.m_cameraMatrix.yy / v6;
    xy = TheCamera.m_cameraMatrix.xy / v6;
  }
  v8 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v10 = 2604 * m_nSize;
    v11 = CBoat::apFrameWakeGeneratingBoats;
    v12 = m_nSize - 1;
    v13 = 0;
    v14 = v10 - 2604;
    LODWORD(v15) = 1232348158;
    v16 = CBoat::apFrameWakeGeneratingBoats;
    do
    {
      if ( (v8->m_aFlags[v12] & 0x80u) == 0 )
      {
        v17 = &(*v8->m_aStorage)[v14];
        if ( v17 )
        {
          if ( *((_DWORD *)v17 + 360) == 5 && *((_WORD *)v17 + 812) )
          {
            v18 = *((_DWORD *)v17 + 5);
            v19 = (float *)(v18 + 48);
            if ( !v18 )
              v19 = (float *)(v17 + 4);
            v20 = *v19 - x;
            v21 = v19[1] - y;
            v22 = (float)(xy * v20) + (float)(yy * v21);
            if ( v22 <= 100.0 && v22 >= -15.0 )
            {
              v23 = (float)(v20 * v20) + (float)(v21 * v21);
              if ( v23 <= 6400.0 )
              {
                if ( v13 >= 4 )
                {
                  v42 = v16;
                  v43 = v11;
                  m_pMat = CBoat::apFrameWakeGeneratingBoats[0]->m_pMat;
                  p_m_transform = (CSimpleTransform *)&m_pMat->tx;
                  if ( !m_pMat )
                    p_m_transform = &CBoat::apFrameWakeGeneratingBoats[0]->m_transform;
                  v26 = CBoat::apFrameWakeGeneratingBoats[2]->m_pMat;
                  v27 = (CSimpleTransform *)&v26->tx;
                  v28 = p_m_transform->m_translate.x - x;
                  v29 = CBoat::apFrameWakeGeneratingBoats[1]->m_pMat;
                  v30 = p_m_transform->m_translate.y - y;
                  v31 = CBoat::apFrameWakeGeneratingBoats[3]->m_pMat;
                  if ( !v26 )
                    v27 = &CBoat::apFrameWakeGeneratingBoats[2]->m_transform;
                  v32 = (CSimpleTransform *)&v29->tx;
                  if ( !v29 )
                    v32 = &CBoat::apFrameWakeGeneratingBoats[1]->m_transform;
                  v33 = (CSimpleTransform *)&v31->tx;
                  v34 = 0;
                  v35 = v28 * v28;
                  v36 = v30 * v30;
                  if ( !v31 )
                    v33 = &CBoat::apFrameWakeGeneratingBoats[3]->m_transform;
                  v37 = v35 + v36;
                  *((float *)&v15 + 1) = (float)(v33->m_translate.x - x) * (float)(v33->m_translate.x - x);
                  v0.n64_f32[0] = (float)((float)(v32->m_translate.x - x) * (float)(v32->m_translate.x - x))
                                + (float)((float)(v32->m_translate.y - y) * (float)(v32->m_translate.y - y));
                  v38.n64_u64[0] = v15;
                  v1.n64_f32[0] = (float)((float)(v27->m_translate.x - x) * (float)(v27->m_translate.x - x))
                                + (float)((float)(v27->m_translate.y - y) * (float)(v27->m_translate.y - y));
                  v39 = *((float *)&v15 + 1)
                      + (float)((float)(v33->m_translate.y - y) * (float)(v33->m_translate.y - y));
                  if ( v37 < 1000000.0 )
                    v38.n64_f32[0] = v37;
                  v40.n64_u64[0] = vmin_f32(v0, v38).n64_u64[0];
                  LODWORD(v41) = vmin_f32(v1, v40).n64_u32[0];
                  if ( v37 >= 1000000.0 )
                    v34 = -1;
                  if ( v0.n64_f32[0] < v38.n64_f32[0] )
                    v34 = 1;
                  if ( v1.n64_f32[0] < v40.n64_f32[0] )
                    v34 = 2;
                  if ( v39 < v41 )
                    v34 = 3;
                  if ( v34 == -1 )
                    goto LABEL_42;
                  if ( v39 < v41 )
                    v41 = *((float *)&v15 + 1)
                        + (float)((float)(v33->m_translate.y - y) * (float)(v33->m_translate.y - y));
                  if ( v23 >= v41 && v17[58] > 7u )
                  {
LABEL_42:
                    v16 = v42;
                    v11 = v43;
                  }
                  else
                  {
                    v16 = v42;
                    v11 = v43;
                    v42[v34] = (CBoat *)v17;
                  }
                }
                else
                {
                  v11[v13++] = (CBoat *)v17;
                }
              }
            }
          }
        }
      }
      --v12;
      v14 -= 2604;
    }
    while ( v12 != -1 );
  }
}
// 56CEF4: variable 'v0' is possibly undefined
// 56CEF8: variable 'v1' is possibly undefined

//----- (0056CF94) --------------------------------------------------------
bool __fastcall CBoat::IsSectorAffectedByWake(CVector2D CentreCoords, float SemiSize, CBoat **apBoatList)
{
  CBoat *v3; // r4
  float y; // s4
  float x; // s2
  int v7; // r0
  int v8; // r10
  int v9; // r1
  __int16 v10; // r2
  float *v11; // r5
  float *v12; // r1
  float v13; // s12

  v3 = CBoat::apFrameWakeGeneratingBoats[0];
  if ( !CBoat::apFrameWakeGeneratingBoats[0] )
    return 0;
  y = CentreCoords.y;
  x = CentreCoords.x;
  v7 = 0;
  LOWORD(v8) = 0;
  do
  {
    if ( v3->m_nNumWakeCoords )
    {
      v9 = 0;
      v10 = 0;
      while ( 1 )
      {
        v11 = (float *)(&v3->_vptr$CPlaceable + v9);
        v12 = (float *)((char *)v3 + 8 * v9);
        v13 = (float)((float)(fShapeLength * (float)v10) + (float)(fShapeTime * (float)(CBoat::WAKE_LIFETIME - v11[471])))
            + SemiSize;
        if ( fabsf(v12[407] - x) < v13 && fabsf(v12[408] - y) < v13 )
          break;
        v9 = ++v10;
        if ( v10 >= (int)v3->m_nNumWakeCoords )
          goto LABEL_10;
      }
      apBoatList[v7++] = v3;
    }
LABEL_10:
    v8 = (__int16)(v8 + 1);
    if ( v8 > 3 )
      break;
    v3 = CBoat::apFrameWakeGeneratingBoats[v8];
  }
  while ( v3 );
  return v7 != 0;
}

//----- (0056D0A4) --------------------------------------------------------
float __fastcall CBoat::IsVertexAffectedByWake(CVector Coords, CBoat *pBoat, int nWakeQuadrant, int bForceCheck)
{
  float v4; // s0
  float x; // s6
  float v6; // s10
  float v7; // s4
  float v8; // s8
  __int16 v9; // r4
  float32x2_t v10; // d0
  float v11; // s5
  float v12; // s3
  float32x2_t v13; // d2
  int v14; // r5
  int v15; // r6
  __int16 v16; // r0
  bool v17; // cc

  if ( bForceCheck == 1 )
  {
    nWakeSkipCounters[nWakeQuadrant] = 0;
    nWakeSkipCounterVertex[nWakeQuadrant] = 8;
  }
  else if ( nWakeSkipCounters[nWakeQuadrant] > 0 )
  {
    return 0.0;
  }
  LODWORD(Coords.z) = pBoat->m_nNumWakeCoords;
  v4 = 0.0;
  if ( pBoat->m_nNumWakeCoords )
  {
    x = Coords.x;
    Coords.x = 0.0;
    v6 = fShapeLength;
    v7 = CBoat::WAKE_LIFETIME;
    v8 = fShapeTime;
    v9 = 0;
    while ( 1 )
    {
      v10.n64_f32[1] = v7 - pBoat->m_fWakePtCounters[LODWORD(Coords.x)];
      v11 = (float)(v6 * (float)v9) + (float)(v8 * v10.n64_f32[1]);
      v12 = (float)((float)(pBoat->m_vecWakeCoords[LODWORD(Coords.x)].x - x)
                  * (float)(pBoat->m_vecWakeCoords[LODWORD(Coords.x)].x - x))
          + (float)((float)(pBoat->m_vecWakeCoords[LODWORD(Coords.x)].y - Coords.y)
                  * (float)(pBoat->m_vecWakeCoords[LODWORD(Coords.x)].y - Coords.y));
      v13.n64_f32[1] = v11 * v11;
      if ( v12 < v13.n64_f32[1] )
      {
        nWakeSkipCounterVertex[nWakeQuadrant] = 0;
        v13.n64_u32[0] = 1.0;
        v10.n64_f32[0] = (float)(sqrtf(v12 / v13.n64_f32[1]) * fRangeMult) + (float)(fTimeMult * v10.n64_f32[1]);
        return 1.0 - vmin_f32(v10, v13).n64_f32[0];
      }
      if ( (float)(v12 - v13.n64_f32[1]) > 20.0 )
        break;
      if ( (float)(v12 - v13.n64_f32[1]) > 10.0 )
      {
        v14 = nWakeSkipCounterVertex[nWakeQuadrant];
        v15 = 0;
        v16 = 2;
        v17 = v14 <= 2;
        goto LABEL_12;
      }
LABEL_17:
      LODWORD(Coords.x) = ++v9;
      if ( v9 >= SLODWORD(Coords.z) )
        return v4;
    }
    v14 = nWakeSkipCounterVertex[nWakeQuadrant];
    v15 = 0;
    v16 = 3;
    v17 = v14 <= 3;
LABEL_12:
    if ( !v17 )
      v15 = 1;
    if ( v15 )
      LOWORD(v14) = v16;
    nWakeSkipCounterVertex[nWakeQuadrant] = v14;
    goto LABEL_17;
  }
  return v4;
}

//----- (0056D24C) --------------------------------------------------------
void CBoat::CheckForSkippingCalculations()
{
  int16 v0; // r0
  int16 v1; // r0
  int16 v2; // r0
  int16 v3; // r0

  v0 = nWakeSkipCounterVertex[0];
  if ( (unsigned __int16)(nWakeSkipCounterVertex[0] - 1) > 6u )
  {
    if ( nWakeSkipCounters[0] < 1 )
      goto LABEL_8;
    v0 = nWakeSkipCounters[0] - 1;
  }
  else if ( nWakeSkipCounters[0] > nWakeSkipCounterVertex[0] )
  {
    v0 = nWakeSkipCounters[0] - 1;
  }
  nWakeSkipCounters[0] = v0;
LABEL_8:
  v1 = nWakeSkipCounterVertex[1];
  nWakeSkipCounterVertex[0] = 8;
  if ( (unsigned __int16)(nWakeSkipCounterVertex[1] - 1) >= 7u )
  {
    if ( nWakeSkipCounters[1] < 1 )
      goto LABEL_15;
    v1 = nWakeSkipCounters[1] - 1;
  }
  else if ( nWakeSkipCounters[1] > nWakeSkipCounterVertex[1] )
  {
    v1 = nWakeSkipCounters[1] - 1;
  }
  nWakeSkipCounters[1] = v1;
LABEL_15:
  v2 = nWakeSkipCounterVertex[2];
  nWakeSkipCounterVertex[1] = 8;
  if ( (unsigned __int16)(nWakeSkipCounterVertex[2] - 1) >= 7u )
  {
    if ( nWakeSkipCounters[2] < 1 )
      goto LABEL_22;
    v2 = nWakeSkipCounters[2] - 1;
  }
  else if ( nWakeSkipCounters[2] > nWakeSkipCounterVertex[2] )
  {
    v2 = nWakeSkipCounters[2] - 1;
  }
  nWakeSkipCounters[2] = v2;
LABEL_22:
  v3 = nWakeSkipCounterVertex[3];
  nWakeSkipCounterVertex[2] = 8;
  if ( (unsigned __int16)(nWakeSkipCounterVertex[3] - 1) < 7u )
  {
    if ( nWakeSkipCounters[3] > nWakeSkipCounterVertex[3] )
      v3 = nWakeSkipCounters[3] - 1;
    goto LABEL_28;
  }
  if ( nWakeSkipCounters[3] >= 1 )
  {
    v3 = nWakeSkipCounters[3] - 1;
LABEL_28:
    nWakeSkipCounters[3] = v3;
  }
  nWakeSkipCounterVertex[3] = 8;
}

//----- (0056D360) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorReady(const CVehicle *this, eDoors DoorID)
{
  return 0;
}

//----- (0056D364) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorFullyOpen(const CVehicle *this, eDoors DoorID)
{
  return 0;
}

//----- (0056D368) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorClosed(const CVehicle *this, eDoors DoorID)
{
  return 0;
}

//----- (0056D36C) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorMissing(const CVehicle *this, eDoors DoorID)
{
  return 0;
}

//----- (0056D370) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorReady(const CVehicle *this, uint32 iDoorID)
{
  return 0;
}

//----- (0056D374) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorFullyOpen(const CVehicle *this, uint32 iDoorID)
{
  return 0;
}

//----- (0056D378) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorClosed(const CVehicle *this, uint32 DoorID)
{
  return 0;
}

//----- (0056D37C) --------------------------------------------------------
bool __fastcall CVehicle::IsDoorMissing(const CVehicle *this, uint32 iDoorID)
{
  return 0;
}

//----- (0056D382) --------------------------------------------------------
bool __fastcall CVehicle::SetUpWheelColModel(CVehicle *this, CColModel *pColModel)
{
  return 0;
}

//----- (0056D386) --------------------------------------------------------
bool __fastcall CVehicle::BurstTyre(CVehicle *this, uint8 nWheelPieceType, bool bApplyForce)
{
  return 0;
}

//----- (0056D38A) --------------------------------------------------------
bool __fastcall CVehicle::IsRoomForPedToLeaveCar(CVehicle *this, uint32 nDoor, CVector *pvecCarJackOffset)
{
  return 0;
}

//----- (0056D398) --------------------------------------------------------
float __fastcall CVehicle::GetHeightAboveRoad(const CVehicle *this)
{
  float result; // r0

  LODWORD(result) = LODWORD(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.z) ^ 0x80000000;
  return result;
}

//----- (0056D3B6) --------------------------------------------------------
int __fastcall CVehicle::GetNumContactWheels(CVehicle *this)
{
  return 4;
}

//----- (0056D3BC) --------------------------------------------------------
void __fastcall CSpecialPlateHandler::Init(CSpecialPlateHandler *this)
{
  this->m_aSpecialPlates[0].nCarIndex = -1;
  this->m_nSpecialPlates = 0;
  this->m_aSpecialPlates[0].szNumPlate[0] = 0;
  this->m_aSpecialPlates[1].nCarIndex = -1;
  this->m_aSpecialPlates[1].szNumPlate[0] = 0;
  this->m_aSpecialPlates[2].szNumPlate[0] = 0;
  this->m_aSpecialPlates[2].nCarIndex = -1;
  this->m_aSpecialPlates[3].nCarIndex = -1;
  this->m_aSpecialPlates[3].szNumPlate[0] = 0;
  this->m_aSpecialPlates[4].nCarIndex = -1;
  this->m_aSpecialPlates[4].szNumPlate[0] = 0;
  this->m_aSpecialPlates[5].nCarIndex = -1;
  this->m_aSpecialPlates[5].szNumPlate[0] = 0;
  this->m_aSpecialPlates[6].nCarIndex = -1;
  this->m_aSpecialPlates[6].szNumPlate[0] = 0;
  this->m_aSpecialPlates[7].szNumPlate[0] = 0;
  this->m_aSpecialPlates[7].nCarIndex = -1;
  this->m_aSpecialPlates[8].szNumPlate[0] = 0;
  this->m_aSpecialPlates[8].nCarIndex = -1;
  this->m_aSpecialPlates[9].szNumPlate[0] = 0;
  this->m_aSpecialPlates[9].nCarIndex = -1;
  this->m_aSpecialPlates[10].szNumPlate[0] = 0;
  this->m_aSpecialPlates[10].nCarIndex = -1;
  this->m_aSpecialPlates[11].szNumPlate[0] = 0;
  this->m_aSpecialPlates[11].nCarIndex = -1;
  this->m_aSpecialPlates[12].szNumPlate[0] = 0;
  this->m_aSpecialPlates[12].nCarIndex = -1;
  this->m_aSpecialPlates[13].szNumPlate[0] = 0;
  this->m_aSpecialPlates[13].nCarIndex = -1;
  this->m_aSpecialPlates[14].szNumPlate[0] = 0;
  this->m_aSpecialPlates[14].nCarIndex = -1;
}

//----- (0056D42C) --------------------------------------------------------
int32 __fastcall CSpecialPlateHandler::Find(CSpecialPlateHandler *this, int32 nIndex, unsigned __int8 *str)
{
  int32 v3; // r4

  *str = 0;
  if ( this->m_nSpecialPlates )
  {
    if ( this->m_aSpecialPlates[0].nCarIndex == nIndex )
    {
      v3 = 0;
LABEL_32:
      strcpy((char *)str, (const char *)this->m_aSpecialPlates[v3].szNumPlate);
      return v3;
    }
    if ( this->m_aSpecialPlates[1].nCarIndex == nIndex )
    {
      v3 = 1;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[2].nCarIndex == nIndex )
    {
      v3 = 2;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[3].nCarIndex == nIndex )
    {
      v3 = 3;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[4].nCarIndex == nIndex )
    {
      v3 = 4;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[5].nCarIndex == nIndex )
    {
      v3 = 5;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[6].nCarIndex == nIndex )
    {
      v3 = 6;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[7].nCarIndex == nIndex )
    {
      v3 = 7;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[8].nCarIndex == nIndex )
    {
      v3 = 8;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[9].nCarIndex == nIndex )
    {
      v3 = 9;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[10].nCarIndex == nIndex )
    {
      v3 = 10;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[11].nCarIndex == nIndex )
    {
      v3 = 11;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[12].nCarIndex == nIndex )
    {
      v3 = 12;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[13].nCarIndex == nIndex )
    {
      v3 = 13;
      goto LABEL_32;
    }
    if ( this->m_aSpecialPlates[14].nCarIndex == nIndex )
    {
      v3 = 14;
      goto LABEL_32;
    }
  }
  return -1;
}

//----- (0056D4F6) --------------------------------------------------------
void __fastcall CSpecialPlateHandler::Add(CSpecialPlateHandler *this, int32 nCarIndex, unsigned __int8 *szNumPlate)
{
  int32 m_nSpecialPlates; // r0

  m_nSpecialPlates = this->m_nSpecialPlates;
  if ( m_nSpecialPlates != 15 )
  {
    this->m_aSpecialPlates[m_nSpecialPlates].nCarIndex = nCarIndex;
    strcpy((char *)this->m_aSpecialPlates[this->m_nSpecialPlates].szNumPlate, (const char *)szNumPlate);
    ++this->m_nSpecialPlates;
  }
}

//----- (0056D526) --------------------------------------------------------
void __fastcall CSpecialPlateHandler::Remove(CSpecialPlateHandler *this, int32 nIndex)
{
  TSpecialPlate *v2; // r12
  int32 m_nSpecialPlates; // r3
  TSpecialPlate *v4; // r1
  __int64 v5; // d17

  if ( nIndex >= 0 && this->m_nSpecialPlates )
  {
    v2 = &this->m_aSpecialPlates[nIndex];
    v2->nCarIndex = -1;
    v2->szNumPlate[0] = 0;
    m_nSpecialPlates = this->m_nSpecialPlates;
    if ( m_nSpecialPlates - 1 > nIndex )
    {
      v4 = &this->m_aSpecialPlates[m_nSpecialPlates - 1];
      v5 = *(_QWORD *)&v4->szNumPlate[4];
      *(_QWORD *)&v2->nCarIndex = *(_QWORD *)&v4->nCarIndex;
      *(_QWORD *)&v2->szNumPlate[4] = v5;
      m_nSpecialPlates = this->m_nSpecialPlates;
    }
    this->m_nSpecialPlates = m_nSpecialPlates - 1;
  }
}

//----- (0056D568) --------------------------------------------------------
void __fastcall CCarGenerator::SwitchOff(CCarGenerator *this)
{
  this->GenerateCount = 0;
}

//----- (0056D570) --------------------------------------------------------
void __fastcall CCarGenerator::SwitchOn(CCarGenerator *this)
{
  this->GenerateCount = -1;
  this->NextGen = CTimer::m_snTimeInMilliseconds + 4;
}

//----- (0056D588) --------------------------------------------------------
UInt32 __fastcall CCarGenerator::CalcNextGen(CCarGenerator *this)
{
  return CTimer::m_snTimeInMilliseconds + 4;
}

//----- (0056D598) --------------------------------------------------------
void __fastcall CCarGenerator::DoInternalProcessing(CCarGenerator *this)
{
  unsigned __int8 v2; // r8
  int32 VisibleModel; // r1
  UInt32 NextGen; // r0
  int32 v5; // r5
  Int32 v6; // r0
  CBaseModelInfo *v7; // r0
  CColModel *m_pColModel; // r0
  bool v9; // zf
  int v10; // r0
  char *v11; // r6
  bool v12; // zf
  Int16 *p_nX; // r10
  float v14; // s4
  Int16 *p_nY; // r11
  float v16; // s2
  float v17; // s0
  float GroundZForCoord; // s16
  CVehicleModelInfo *v19; // r0
  float DistanceFromCentreOfMassToBaseOfModel; // s0
  int v21; // r0
  float v22; // s0
  float v23; // s2
  float v24; // s4
  float *v25; // r0
  CMatrix *v26; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float *v30; // r0
  float v31; // s2
  float v32; // s4
  char v33; // r1
  int v34; // r0
  float v35; // r8
  char *v36; // r3
  CPathFind *v37; // r1
  CNodeAddress *NodeClosestToCoors; // r0
  CNodeAddress *v39; // r8
  CPathNode *v40; // r1
  CNodeAddress v41; // r11
  char v42; // r0
  bool v43; // zf
  float *v44; // r0
  float *v45; // r1
  float v46; // s2
  float v47; // s10
  float v48; // s0
  float v49; // s6
  CPed *v50; // r5
  char v51; // r0
  int car_remap1; // r0
  bool v53; // zf
  int GenerateCount; // r0
  int v55; // r1
  CEntity *refEntityPtr; // [sp+1Ch] [bp-84h] BYREF
  CColPoint v57; // [sp+20h] [bp-80h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-54h] BYREF
  CVector str; // [sp+58h] [bp-48h] BYREF
  CVector v60; // 0:r2.8,8:^0.4

  v2 = CClock::ms_nGameClockHours - 7;
  if ( (*((_BYTE *)this + 13) & 0x10) == 0 )
  {
    if ( v2 < 0xFu )
    {
      if ( CCarCtrl::NumParkedCars > 4 )
        return;
    }
    else if ( CCarCtrl::NumParkedCars > 9 )
    {
      return;
    }
  }
  VisibleModel = this->VisibleModel;
  if ( VisibleModel <= -1 )
  {
    if ( VisibleModel == -1 || (v5 = -VisibleModel, CStreaming::ms_aInfoForModel[-VisibleModel].m_status != 1) )
    {
      FindPlayerCoors(&v57.m_vecPosition, -1);
      CTheZones::GetZoneInfo(&v57.m_vecPosition, 0);
      v6 = CLoadedCarGroup::PickRandomCar(&CPopulation::m_AppropriateLoadedCars, 1, 1);
      v5 = v6;
      if ( v6 < 0 )
        return;
      v7 = CModelInfo::ms_modelInfoPtrs[v6];
      if ( BYTE1(v7[1].m_pColModel) == 5 )
        return;
      m_pColModel = v7->m_pColModel;
      if ( m_pColModel )
      {
        if ( (float)(m_pColModel->m_boxBound.m_vecMax.y - m_pColModel->m_boxBound.m_vecMin.y) > 8.0 )
          return;
      }
      this->VisibleModel = -(__int16)v5;
      *(_WORD *)&this->car_remap1 = -1;
    }
    if ( CCarGenerator::CheckForBlockage(this, v5) )
      goto LABEL_8;
  }
  else
  {
    if ( CCarGenerator::CheckForBlockage(this, VisibleModel) )
    {
LABEL_8:
      NextGen = this->NextGen;
LABEL_9:
      this->NextGen = NextGen + 4;
      return;
    }
    CStreaming::RequestModel(this->VisibleModel, 8);
    v5 = this->VisibleModel;
    if ( v5 == 588 )
      CStreaming::RequestModel(168, 8);
  }
  if ( CStreaming::ms_aInfoForModel[v5].m_status == 1 )
  {
    v9 = v5 == 588;
    if ( v5 == 588 )
      v9 = this->VisibleModel == 588;
    if ( !v9 || CStreaming::ms_aInfoForModel[168].m_status == 1 )
    {
      if ( CModelInfo::IsBoatModel(v5) )
        goto LABEL_27;
      v12 = v5 == 417;
      if ( v5 != 417 )
        v12 = v5 == 460;
      if ( v12 || v5 == 447 )
      {
LABEL_27:
        v10 = *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[v5][1].m_modelName[20];
        switch ( v10 )
        {
          case 5:
            v11 = (char *)CVehicle::operator new(0x7FCu);
            CBoat::CBoat((CBoat *)v11, v5, 3u);
            break;
          case 4:
            v11 = (char *)CVehicle::operator new(0xA18u);
            CPlane::CPlane((CPlane *)v11, v5, 3u);
            break;
          case 3:
            v11 = (char *)CVehicle::operator new(0xA2Cu);
            CHeli::CHeli((CHeli *)v11, v5, 3u);
            break;
          default:
            v11 = 0;
            break;
        }
        p_nX = &this->nX;
        GroundZForCoord = (float)this->nZ * 0.125;
        p_nY = &this->nY;
        if ( GroundZForCoord <= -100.0 )
          GroundZForCoord = CWorld::FindGroundZForCoord((float)this->nX * 0.125, (float)this->nY * 0.125);
        *((_WORD *)v11 + 600) = 255;
LABEL_51:
        (*(void (__fastcall **)(char *, _DWORD))(*(_DWORD *)v11 + 20))(v11, 0);
        *((_DWORD *)v11 + 267) &= ~0x10u;
        DistanceFromCentreOfMassToBaseOfModel = CEntity::GetDistanceFromCentreOfMassToBaseOfModel((CEntity *)v11);
        v21 = *((_DWORD *)v11 + 5);
        v22 = GroundZForCoord + DistanceFromCentreOfMassToBaseOfModel;
        v23 = (float)*p_nY * 0.125;
        v24 = (float)*p_nX * 0.125;
        if ( v21 )
        {
          *(float *)(v21 + 48) = v24;
          *(float *)(*((_DWORD *)v11 + 5) + 52) = v23;
          v25 = (float *)(*((_DWORD *)v11 + 5) + 56);
        }
        else
        {
          v25 = (float *)(v11 + 12);
          *((float *)v11 + 1) = v24;
          *((float *)v11 + 2) = v23;
        }
        *v25 = v22;
        v26 = (CMatrix *)*((_DWORD *)v11 + 5);
        if ( v26 )
        {
          tx = v26->tx;
          ty = v26->ty;
          tz = v26->tz;
          CMatrix::SetRotate(v26, 0.0, 0.0, (float)this->rot * 0.024544);
          v30 = (float *)*((_DWORD *)v11 + 5);
          v31 = ty + v30[13];
          v32 = tz + v30[14];
          v30[12] = tx + v30[12];
          v30[13] = v31;
          v30[14] = v32;
        }
        else
        {
          *((float *)v11 + 4) = (float)this->rot * 0.024544;
        }
        v33 = v11[58];
        *((_DWORD *)v11 + 322) = 1;
        v11[58] = v33 & 7 | 0x20;
        *((_DWORD *)v11 + 267) = *((_DWORD *)v11 + 267) & 0xFFFDFFFF | (((*((unsigned __int8 *)this + 13) >> 3) & 1) << 17);
        if ( v2 > 0xEu || (unsigned int)(*((__int16 *)v11 + 19) - 531) > 1 )
          goto LABEL_65;
        v34 = *((_DWORD *)v11 + 5);
        LOWORD(v35) = 0;
        v36 = (char *)(v34 + 48);
        if ( !v34 )
          v36 = v11 + 4;
        v37 = *(CPathFind **)v36;
        *(_QWORD *)&v60.x = *(_QWORD *)(v36 + 4);
        HIWORD(v35) = 16800;
        v60.z = 0.0;
        NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                               (CNodeAddress *)&ThePaths,
                               v37,
                               v60,
                               v35,
                               0.0,
                               0,
                               0,
                               0,
                               1,
                               (bool)refEntityPtr);
        v39 = NodeClosestToCoors;
        if ( (unsigned __int16)NodeClosestToCoors == 0xFFFF )
          goto LABEL_65;
        v40 = ThePaths.pNodes[(unsigned __int16)NodeClosestToCoors];
        if ( *((unsigned __int16 *)&v40[(unsigned int)NodeClosestToCoors >> 16] + 12) << 28
          && (v41 = ThePaths.pAdjacentNodes[(unsigned __int16)NodeClosestToCoors][v40[(unsigned int)NodeClosestToCoors >> 16].IndexAdjacentNodes],
              ThePaths.pNodes[v41.Region]) )
        {
          CVehicle::SetVehicleCreatedBy((CVehicle *)v11, 1, 0);
          v11[958] = 1;
          v11[980] = 7;
          *((_DWORD *)v11 + 229) = v39;
          v42 = v11[58];
          *((CNodeAddress *)v11 + 230) = v41;
          v11[58] = v42 & 7 | 0x18;
          *((_DWORD *)v11 + 268) |= 0x40u;
          *((_WORD *)v11 + 600) = 255;
          *((_BYTE *)this + 13) |= 1u;
          CWorld::Add((CEntity *)v11);
          CCarCtrl::SetUpDriverAndPassengersForVehicle((CVehicle *)v11, 4, 0, 0, 0, 99);
        }
        else
        {
LABEL_65:
          CWorld::Add((CEntity *)v11);
        }
        v43 = v5 == 588;
        if ( v5 == 588 )
          v43 = this->VisibleModel == 588;
        if ( v43 && CStreaming::ms_aInfoForModel[168].m_status == 1 )
        {
          v44 = (float *)*((_DWORD *)v11 + 5);
          v45 = v44 + 12;
          v46 = *v44;
          if ( !v44 )
            v45 = (float *)(v11 + 4);
          v47 = v45[2];
          v48 = v44[2] * 3.0;
          v49 = *v45;
          str.y = v45[1] - (float)(v44[1] * 3.0);
          str.x = v49 - (float)(v46 * 3.0);
          str.z = v47 - v48;
          v50 = CPopulation::AddPed(PEDTYPE_CIVMALE, 0xA8u, &str, 0);
          if ( v50 )
          {
            v51 = `guard variable for'CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset;
            __dmb(0xBu);
            if ( (v51 & 1) == 0
              && _cxa_guard_acquire((__guard *)&`guard variable for'CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset) )
            {
              CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset.x = 0.0;
              CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset.y = 0.0;
              CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset.z = 0.6;
              _cxa_guard_release((__guard *)&`guard variable for'CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset);
            }
            CPed::AttachPedToEntity(
              v50,
              (CEntity *)v11,
              CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset,
              3u,
              0.0,
              WEAPONTYPE_UNARMED);
            CScriptsForBrains::CheckIfNewEntityNeedsScript(&CTheScripts::ScriptsForBrains, v50, 0, 0);
          }
        }
        if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) < this->ChanceOfCarAlarm )
          *((_WORD *)v11 + 560) = -1;
        if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) < this->ChanceOfCarLocked )
          *((_DWORD *)v11 + 322) = 2;
        car_remap1 = this->car_remap1;
        v53 = car_remap1 == 255;
        if ( car_remap1 != 255 )
          v53 = this->car_remap2 == 255;
        if ( v53 )
        {
          if ( this->VisibleModel < -1 )
          {
            this->car_remap1 = v11[1080];
            this->car_remap2 = v11[1081];
          }
        }
        else
        {
          v11[1080] = car_remap1;
          v11[1081] = this->car_remap2;
        }
        CVisibilityPlugins::SetClumpAlpha(*((RpClump_0 **)v11 + 6), 0);
        GenerateCount = this->GenerateCount;
        this->LatestCarID = CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                                            * ((v11 - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (unsigned __int16)(8960 * ((v11 - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2));
        if ( GenerateCount != 0xFFFF )
          this->GenerateCount = GenerateCount - 1;
        NextGen = CTimer::m_snTimeInMilliseconds;
        goto LABEL_9;
      }
      p_nX = &this->nX;
      v14 = (float)this->nZ * 0.125;
      vecStart.x = (float)this->nX * 0.125;
      p_nY = &this->nY;
      v16 = v14 + 2.0;
      v17 = (float)this->nY * 0.125;
      if ( v14 <= -100.0 )
        v16 = 1000.0;
      vecStart.z = v16;
      vecStart.y = v17;
      if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &v57, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
      {
        GroundZForCoord = v57.m_vecPosition.z;
        CSpecialPlateHandler::Find(
          &CTheCarGenerators::m_SpecialPlateHandler,
          (unsigned int)((char *)this - (char *)CTheCarGenerators::CarGeneratorArray) >> 5,
          (unsigned __int8 *)&str);
        if ( LOBYTE(str.x) )
        {
          v19 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[v5];
          if ( v19->pCustomPlateMaterial )
            CVehicleModelInfo::SetCustomCarPlateText(v19, (unsigned __int8 *)&str);
        }
        switch ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[v5][1].m_modelName[20] )
        {
          case 1:
            v11 = (char *)CVehicle::operator new(0x9B0u);
            CMonsterTruck::CMonsterTruck((CMonsterTruck *)v11, v5, 3u);
            break;
          case 2:
            v11 = (char *)CVehicle::operator new(0x9D0u);
            CQuadBike::CQuadBike((CQuadBike *)v11, v5, 3u);
            break;
          case 3:
            v11 = (char *)CVehicle::operator new(0xA2Cu);
            CHeli::CHeli((CHeli *)v11, v5, 3u);
            break;
          case 4:
            v11 = (char *)CVehicle::operator new(0xA18u);
            CPlane::CPlane((CPlane *)v11, v5, 3u);
            break;
          case 6:
            v11 = (char *)CVehicle::operator new(0x6C0u);
            CTrain::CTrain((CTrain *)v11, v5, 3u);
            break;
          case 9:
            v11 = (char *)CVehicle::operator new(0x828u);
            CBike::CBike((CBike *)v11, v5, 3u);
            goto LABEL_98;
          case 0xA:
            v11 = (char *)CVehicle::operator new(0x84Cu);
            CBmx::CBmx((CBmx *)v11, v5, 3u);
LABEL_98:
            v11[1576] |= 0x10u;
            break;
          case 0xB:
            v11 = (char *)CVehicle::operator new(0xA08u);
            CTrailer::CTrailer((CTrailer *)v11, v5, 3u);
            break;
          default:
            v11 = (char *)CVehicle::operator new(0x99Cu);
            CAutomobile::CAutomobile((CAutomobile *)v11, v5, 3u, 1u);
            break;
        }
        CEntity::GetDistanceFromCentreOfMassToBaseOfModel((CEntity *)v11);
        v55 = *((_DWORD *)v11 + 267);
        v11[1202] &= 0xE7u;
        *((_DWORD *)v11 + 267) = v55 & 0xFFFFFFBF;
        CVehicle::SetCollisionLighting((CVehicle *)v11, v57.m_dataB.m_lighting);
        goto LABEL_51;
      }
    }
  }
}
// 677AB4: using guessed type int CCarCtrl::NumParkedCars[2];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 679BDC: using guessed type CLoadedCarGroup *CPopulation::m_AppropriateLoadedCars;
// A065C8: using guessed type char `guard variable for'CCarGenerator::DoInternalProcessing(void)::vecHotDogPedOffset;

//----- (0056DE00) --------------------------------------------------------
Bool8 __fastcall CCarGenerator::CheckForBlockage(CCarGenerator *this, int32 CarModel)
{
  Bool8 v4; // r6
  CBaseModelInfo *v5; // r9
  CColModel *m_pColModel; // r0
  float m_fRadius; // s0
  float v8; // r1
  RwReal v9; // s4
  RwReal v10; // s0
  int v11; // r2
  CEntity *v12; // r6
  CColModel *v13; // r5
  CMatrix *m_pMat; // r4
  CSimpleTransform *p_tx; // r1
  float nZ; // s8
  float z; // s4
  CColModel *v18; // r6
  float v19; // s4
  float v20; // s6
  CMatrix *v21; // r1
  CSimpleTransform *p_m_transform; // r4
  float v23; // s4
  float v24; // s6
  CVector Coors; // [sp+20h] [bp-58h] BYREF
  Int16 pNum; // [sp+2Eh] [bp-4Ah] BYREF
  CEntity *v28[18]; // [sp+30h] [bp-48h] BYREF

  v4 = 0;
  v5 = CModelInfo::ms_modelInfoPtrs[CarModel];
  m_pColModel = v5->m_pColModel;
  if ( m_pColModel )
    m_fRadius = m_pColModel->m_sphereBound.m_fRadius;
  else
    m_fRadius = 2.0;
  v8 = m_fRadius;
  v9 = (float)this->nX * 0.125;
  v10 = (float)this->nZ * 0.125;
  Coors.y = (float)this->nY * 0.125;
  Coors.x = v9;
  Coors.z = v10;
  CWorld::FindObjectsKindaColliding(&Coors, v8, 1, &pNum, 8, v28, 0, 1, 1, 0, 0);
  if ( pNum >= 1 )
  {
    v11 = 0;
    while ( 1 )
    {
      v12 = v28[v11];
      v13 = CModelInfo::ms_modelInfoPtrs[v12->m_nModelIndex]->m_pColModel;
      if ( v5->m_pColModel )
      {
        m_pMat = v12->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        nZ = (float)this->nZ;
        if ( !m_pMat )
          p_tx = &v12->m_transform;
        z = p_tx->m_translate.z;
        v18 = CModelInfo::ms_modelInfoPtrs[CarModel]->m_pColModel;
        if ( (float)(v18->m_boxBound.m_vecMin.z + (float)(nZ * 0.125)) >= (float)((float)(z + v13->m_boxBound.m_vecMax.z)
                                                                                + 1.0) )
          goto LABEL_16;
        v19 = z + v13->m_boxBound.m_vecMin.z;
        v20 = (float)(nZ * 0.125) + v18->m_boxBound.m_vecMax.z;
      }
      else
      {
        v21 = v12->m_pMat;
        p_m_transform = (CSimpleTransform *)&v21->tx;
        if ( !v21 )
          p_m_transform = &v12->m_transform;
        v23 = p_m_transform->m_translate.z;
        v24 = (float)this->nZ * 0.125;
        if ( (float)(v24 + -1.0) >= (float)((float)(v23 + v13->m_boxBound.m_vecMax.z) + 1.0) )
          goto LABEL_16;
        v20 = v24 + 1.0;
        v19 = v23 + v13->m_boxBound.m_vecMin.z;
      }
      if ( v20 > (float)(v19 + -1.0) )
      {
        v4 = 1;
        *((_BYTE *)this + 13) |= 1u;
        return v4;
      }
LABEL_16:
      if ( ++v11 >= pNum )
        return 0;
    }
  }
  return v4;
}

//----- (0056DFAC) --------------------------------------------------------
void __fastcall CCarGenerator::Process(CCarGenerator *this)
{
  int LatestCarID; // r0
  unsigned int v3; // r1
  uint8 *v4; // r2
  uint8 *v5; // r0
  UInt32 NextGen; // r1
  char v7; // r2

  LatestCarID = (unsigned __int16)this->LatestCarID;
  if ( LatestCarID != 0xFFFF )
    goto LABEL_18;
  if ( (CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter || CTimer::m_snTimeInMilliseconds >= this->NextGen)
    && this->GenerateCount
    && CCarGenerator::CheckIfWithinRangeOfAnyPlayers(this) )
  {
    CCarGenerator::DoInternalProcessing(this);
  }
  LatestCarID = (unsigned __int16)this->LatestCarID;
  if ( LatestCarID != 0xFFFF )
  {
LABEL_18:
    if ( (__int16)LatestCarID > -1
      && (v3 = (unsigned int)(__int16)LatestCarID >> 8,
          CPools::ms_pVehiclePool->m_aFlags[v3] == (unsigned __int8)LatestCarID)
      && (v4 = CPools::ms_pVehiclePool->m_aStorage[v3]) != 0 )
    {
      if ( v4[58] <= 7u )
      {
        v5 = CPools::ms_pVehiclePool->m_aStorage[v3];
        NextGen = this->NextGen;
        this->LatestCarID = -1;
        v7 = *((_BYTE *)this + 13);
        this->NextGen = NextGen + 60000;
        *((_BYTE *)this + 13) = v7 | 1;
        *((_WORD *)v5 + 600) = 0;
        if ( this->VisibleModel <= -1 )
          this->VisibleModel = -1;
      }
    }
    else
    {
      this->LatestCarID = -1;
    }
  }
}

//----- (0056E068) --------------------------------------------------------
Bool8 __fastcall CCarGenerator::CheckIfWithinRangeOfAnyPlayers(CCarGenerator *this)
{
  const CVector *PlayerCentreOfWorld; // r0
  float nX; // s6
  float v4; // s0
  float y; // s10
  float x; // s8
  int VisibleModel; // r0
  float v8; // s18
  float v9; // s16
  float v10; // s22
  float v11; // s0
  Bool8 v12; // r4
  char v14; // r0
  float v15; // s2
  const CVector *PlayerSpeed; // r0
  CVector posn; // [sp+4h] [bp-34h] BYREF

  PlayerCentreOfWorld = FindPlayerCentreOfWorld(CWorld::PlayerInFocus);
  nX = (float)this->nX;
  v4 = (float)this->nZ * 0.125;
  if ( fabsf(PlayerCentreOfWorld->z - v4) > 50.0 )
    return 0;
  y = PlayerCentreOfWorld->y;
  x = PlayerCentreOfWorld->x;
  VisibleModel = this->VisibleModel;
  v8 = y - (float)((float)this->nY * 0.125);
  v9 = x - (float)(nX * 0.125);
  v10 = sqrtf((float)(v9 * v9) + (float)(v8 * v8));
  if ( VisibleModel < 1 )
    goto LABEL_7;
  if ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[VisibleModel][1].m_modelName[20] == 5
    && v10 < (float)(TheCamera.GenerationDistMultiplier * 240.0)
    && (posn.y = (float)this->nY * 0.125,
        posn.x = nX * 0.125,
        posn.z = v4,
        CCamera::IsSphereVisible(&TheCamera, &posn, 0.0))
    && !COcclusion::IsPositionOccluded((float)this->nX * 0.125, (float)this->nY * 0.125, (float)this->nZ * 0.125, 0.0) )
  {
    v11 = TheCamera.GenerationDistMultiplier * 160.0;
  }
  else
  {
LABEL_7:
    v11 = TheCamera.GenerationDistMultiplier * 160.0;
    if ( v10 >= (float)(TheCamera.GenerationDistMultiplier * 160.0) )
    {
      if ( (*((_BYTE *)this + 13) & 1) != 0 )
        *((_BYTE *)this + 13) &= ~1u;
      return 0;
    }
  }
  if ( CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter )
    return 1;
  v14 = *((_BYTE *)this + 13);
  if ( (v14 & 1) != 0 )
    return 0;
  v15 = (float)this->nZ * 0.125;
  if ( CGame::currArea == AREA_MAIN_MAP && v15 >= 950.0 )
    return 0;
  if ( CGame::currArea && v15 < 950.0 )
    return 0;
  v12 = 0;
  if ( v10 >= (float)(v11 + -20.0) || (v14 & 2) != 0 )
  {
    PlayerSpeed = FindPlayerSpeed(-1);
    if ( (float)((float)(v9 * PlayerSpeed->x) + (float)(v8 * PlayerSpeed->y)) <= 0.0 )
      return 1;
  }
  return v12;
}

//----- (0056E290) --------------------------------------------------------
void __fastcall CCarGenerator::Setup(
        CCarGenerator *this,
        const float ix,
        const float iy,
        const float iz,
        const float new_rot,
        const int visible_model,
        const Int16 remap1_for_car,
        const Int16 remap2_for_car,
        const Bool8 high_priority,
        const UInt8 alarm_likelihood,
        const UInt8 locked_likelihood,
        const UInt16 imin_delay,
        const UInt16 imax_delay,
        const uint8 level,
        const Bool8 ignore_population_limit)
{
  float v15; // s0
  float i; // s0
  char v17; // r1
  uint32 v18; // r2

  this->nY = (int)(float)(iy * 8.0);
  v15 = new_rot;
  this->nX = (int)(float)(ix * 8.0);
  for ( this->nZ = (int)(float)(iz * 8.0); v15 < 0.0; v15 = v15 + 360.0 )
    ;
  for ( ; v15 >= 360.0; v15 = v15 + -360.0 )
    ;
  for ( i = v15 * 0.017453; i < 0.0; i = i + 6.2832 )
    ;
  this->ChanceOfCarAlarm = alarm_likelihood;
  this->VisibleModel = visible_model;
  this->car_remap1 = remap1_for_car;
  this->car_remap2 = remap2_for_car;
  this->ChanceOfCarLocked = locked_likelihood;
  this->MinDelay = imin_delay;
  this->MaxDelay = imax_delay;
  v17 = *((_BYTE *)this + 13);
  this->LatestCarID = -1;
  this->rot = (unsigned int)(float)(i * 40.744);
  v18 = CTimer::m_snTimeInMilliseconds;
  this->GenerateCount = 0;
  this->m_level = level;
  this->m_used = 1;
  *((_BYTE *)this + 13) = v17 & 0xE4 | (2 * high_priority) & 2 | (16 * (ignore_population_limit & 1));
  this->NextGen = v18 + 1;
}

//----- (0056E3C0) --------------------------------------------------------
void CTheCarGenerators::Process()
{
  UInt8 v0; // r2
  int v1; // r5
  CCarGenerator *v2; // r4

  if ( !FindPlayerTrain(-1) && !CCutsceneMgr::ms_cutsceneProcessing )
  {
    v0 = CTheCarGenerators::ProcessCounter + 1;
    if ( (unsigned __int8)(CTheCarGenerators::ProcessCounter + 1) == 4 )
      v0 = 0;
    CTheCarGenerators::ProcessCounter = v0;
    v1 = v0 - 4;
    v2 = &CTheCarGenerators::CarGeneratorArray[v0];
    do
    {
      if ( v2->m_used )
        CCarGenerator::Process(v2);
      v1 += 4;
      v2 += 4;
    }
    while ( v1 < 496 );
    if ( CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter )
      --CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter;
  }
}

//----- (0056E444) --------------------------------------------------------
Int32 __fastcall CTheCarGenerators::CreateCarGenerator(
        const float x,
        const float y,
        const float z,
        const float rot,
        const int VisMod,
        const Int16 car_rmap1,
        const Int16 car_rmap2,
        const Bool8 high_priority,
        const UInt8 chance_of_alarm,
        const UInt8 chance_of_locked,
        const UInt16 imin_delay,
        const UInt16 imax_delay,
        const uint8 level,
        const Bool8 ignore_population_limit)
{
  char v14; // cc
  float v16; // s0
  CCarGenerator *v18; // r1
  Int32 result; // r0
  float i; // s0
  char v21; // r2
  uint32 v22; // r6

  v14 = (VisMod != -1) & __CFADD__(VisMod, 1);
  if ( VisMod != -1 )
    v14 = (unsigned int)(VisMod - 400) > 0xE6;
  if ( v14 )
    return -1;
  v16 = rot;
  v18 = CTheCarGenerators::CarGeneratorArray;
  result = 0;
  while ( v18->m_used )
  {
    ++v18;
    v14 = result++ <= 498;
    if ( !v14 )
      return -1;
  }
  v18->nY = (int)(float)(y * 8.0);
  v18->nX = (int)(float)(x * 8.0);
  v18->nZ = (int)(float)(z * 8.0);
  if ( rot < 0.0 )
  {
    do
      v16 = v16 + 360.0;
    while ( v16 < 0.0 );
  }
  for ( ; v16 >= 360.0; v16 = v16 + -360.0 )
    ;
  for ( i = v16 * 0.017453; i < 0.0; i = i + 6.2832 )
    ;
  v18->ChanceOfCarAlarm = chance_of_alarm;
  v18->VisibleModel = VisMod;
  v18->car_remap1 = car_rmap1;
  v18->car_remap2 = car_rmap2;
  v18->ChanceOfCarLocked = chance_of_locked;
  v18->MinDelay = imin_delay;
  v21 = *((_BYTE *)v18 + 13);
  v18->MaxDelay = imax_delay;
  v18->LatestCarID = -1;
  v22 = CTimer::m_snTimeInMilliseconds;
  v18->rot = (unsigned int)(float)(i * 40.744);
  v18->GenerateCount = 0;
  v18->m_level = level;
  v18->m_used = 1;
  *((_BYTE *)v18 + 13) = v21 & 0xE4 | (2 * high_priority) & 2 | (16 * (ignore_population_limit & 1));
  v18->NextGen = v22 + 1;
  ++CTheCarGenerators::NumOfCarGenerators;
  return result;
}

//----- (0056E5B8) --------------------------------------------------------
void __fastcall CTheCarGenerators::RemoveCarGenerators(uint8 level)
{
  int i; // r3

  for ( i = 0; i != 500; ++i )
  {
    if ( CTheCarGenerators::CarGeneratorArray[i].m_level == level )
    {
      CTheCarGenerators::CarGeneratorArray[i].m_used = 0;
      CTheCarGenerators::CarGeneratorArray[i].m_level = 0;
      --CTheCarGenerators::NumOfCarGenerators;
    }
  }
}

//----- (0056E60C) --------------------------------------------------------
void CTheCarGenerators::Init()
{
  int v0; // r2
  CCarGenerator *v1; // r3

  CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_nSpecialPlates = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[0].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[0].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[1].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[1].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[2].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[2].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[3].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[3].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[4].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[4].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[5].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[5].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[6].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[6].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[7].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[7].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[8].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[8].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[9].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[9].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[10].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[10].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[11].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[11].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[12].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[12].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[13].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[13].nCarIndex = -1;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[14].szNumPlate[0] = 0;
  CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[14].nCarIndex = -1;
  v0 = 0;
  CTheCarGenerators::ProcessCounter = 0;
  CTheCarGenerators::NumOfCarGenerators = 0;
  do
  {
    v1 = &CTheCarGenerators::CarGeneratorArray[v0++];
    v1->m_used = 0;
  }
  while ( v0 != 500 );
}

//----- (0056E6D2) --------------------------------------------------------
bool __fastcall CCranes::IsThisCarPickedUp(float CoorX, float CoorY, CVehicle *pVehicle)
{
  return 0;
}

//----- (0056E6D8) --------------------------------------------------------
bool __fastcall CCranes::IsThisCarBeingCarriedByAnyCrane(CVehicle *pVehicle)
{
  return 0;
}

//----- (0056E6DC) --------------------------------------------------------
bool __fastcall CCranes::IsThisCarBeingTargettedByAnyCrane(CVehicle *pVehicle)
{
  return 0;
}

//----- (0056E6E4) --------------------------------------------------------
bool __fastcall CDamageManager::GetComponentGroup(
        CDamageManager *this,
        tComponent Component,
        tComponentGroup *pComponentGroup,
        uint8 *pComponentNumber)
{
  tComponentGroup v4; // r0
  uint8 v5; // r0
  tComponentGroup v6; // r0

  *pComponentNumber = -2;
  if ( Component < CT_PANEL_FRONT_LEFT )
  {
    if ( Component < CT_DOOR_BONNET )
    {
      if ( Component < CT_WHEEL_FRONT_LEFT )
      {
        if ( Component < CT_ENGINE )
          return 0;
        *pComponentGroup = CG_ENGINE;
        v5 = 0;
      }
      else
      {
        *pComponentGroup = CG_WHEEL;
        v5 = Component - 1;
      }
    }
    else
    {
      v6 = CG_DOOR;
      if ( Component == CT_DOOR_BOOT )
        v6 = CG_BOOT;
      if ( Component == CT_DOOR_BONNET )
        v6 = CG_BONNET;
      *pComponentGroup = v6;
      v5 = Component - 5;
    }
  }
  else
  {
    v4 = CG_PANEL;
    if ( Component > CT_PANEL_WINDSCREEN )
      v4 = CG_BUMPER;
    *pComponentGroup = v4;
    v5 = Component - 11;
  }
  *pComponentNumber = v5;
  return 1;
}

//----- (0056E738) --------------------------------------------------------
void __fastcall CDamageManager::ResetDamageStatus(CDamageManager *this)
{
  this->m_Lights = 0;
  this->m_Panels = 0;
  this->m_Door[5] = 0;
  *(_WORD *)&this->m_Door[3] = 0;
  *(_DWORD *)&this->m_Engine = 0;
  *(_DWORD *)&this->m_Wheel[3] = 0;
}

//----- (0056E748) --------------------------------------------------------
void __fastcall CDamageManager::SetLightStatus(CDamageManager *this, eLights LightID, uint32 Status)
{
  this->m_Lights = this->m_Lights & ~(3 << (2 * LightID)) | (Status << (2 * LightID));
}

//----- (0056E762) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetLightStatus(const CDamageManager *this, eLights LightID)
{
  return (this->m_Lights >> (2 * LightID)) & 3;
}

//----- (0056E770) --------------------------------------------------------
void __fastcall CDamageManager::SetPanelStatus(CDamageManager *this, int32 PanelID, uint32 Status)
{
  this->m_Panels = this->m_Panels & ~(15 << (4 * PanelID)) | (Status << (4 * PanelID));
}

//----- (0056E78A) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetPanelStatus(const CDamageManager *this, int32 PanelID)
{
  return (this->m_Panels >> (4 * PanelID)) & 0xF;
}

//----- (0056E798) --------------------------------------------------------
void __fastcall CDamageManager::SetWheelStatus(CDamageManager *this, int32 WheelID, uint32 Status)
{
  this->m_Wheel[WheelID] = Status;
}

//----- (0056E79E) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetWheelStatus(const CDamageManager *this, int32 WheelID)
{
  return this->m_Wheel[WheelID];
}

//----- (0056E7A4) --------------------------------------------------------
void __fastcall CDamageManager::SetDoorStatus(CDamageManager *this, eDoors DoorID, uint32 Status)
{
  if ( (unsigned int)DoorID <= REAR_RIGHT_DOOR_0 )
    this->m_Door[DoorID] = Status;
}

//----- (0056E7B0) --------------------------------------------------------
void __fastcall CDamageManager::SetDoorStatus(CDamageManager *this, int32 iDoorIndex, uint32 Status)
{
  unsigned int v3; // r1

  v3 = iDoorIndex - 8;
  if ( v3 <= 3 )
    this->m_Door[dword_61EA04[v3]] = Status;
}
// 61EA04: using guessed type _DWORD dword_61EA04[4];

//----- (0056E7CC) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetDoorStatus(const CDamageManager *this, eDoors DoorID)
{
  if ( (unsigned int)DoorID <= REAR_RIGHT_DOOR_0 )
    return this->m_Door[DoorID];
  else
    return 4;
}

//----- (0056E7D8) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetDoorStatus(const CDamageManager *this, int32 iDoorIndex)
{
  unsigned int v2; // r1

  v2 = iDoorIndex - 8;
  if ( v2 <= 3 )
    return this->m_Door[dword_61EA04[v2]];
  else
    return 4;
}
// 61EA04: using guessed type _DWORD dword_61EA04[4];

//----- (0056E7F4) --------------------------------------------------------
void __fastcall CDamageManager::SetEngineStatus(CDamageManager *this, uint32 Status)
{
  if ( Status >= 0xFA )
    LOBYTE(Status) = -6;
  this->m_Engine = Status;
}

//----- (0056E7FE) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetEngineStatus(const CDamageManager *this)
{
  return this->m_Engine;
}

//----- (0056E802) --------------------------------------------------------
void __fastcall CDamageManager::SetAeroplaneCompStatus(CDamageManager *this, int32 CompID, uint32 Status)
{
  this->m_Panels = this->m_Panels & ~(3 << (2 * CompID - 24)) | (Status << (2 * CompID - 24));
}

//----- (0056E820) --------------------------------------------------------
uint32 __fastcall CDamageManager::GetAeroplaneCompStatus(const CDamageManager *this, int32 CompID)
{
  return (this->m_Panels >> (2 * CompID - 24)) & 3;
}

//----- (0056E834) --------------------------------------------------------
bool __fastcall CDamageManager::ProgressDoorDamage(CDamageManager *this, uint8 ComponentNumber, CAutomobile *pCar)
{
  char v3; // r3
  uint8 *v4; // r5
  bool result; // r0

  if ( ComponentNumber > 5u )
    return 0;
  v4 = &this->m_Door[ComponentNumber];
  v3 = *v4;
  result = 0;
  switch ( *v4 )
  {
    case 0u:
    case 1u:
      CDoor::Open(&pCar->Door[ComponentNumber], 0.0);
      v3 = 2;
      goto LABEL_8;
    case 2u:
      v3 = 3;
      goto LABEL_8;
    case 3u:
      if ( (rand() & 7) != 0 )
        return 0;
      v3 = 4;
      goto LABEL_8;
    case 4u:
      return result;
    default:
LABEL_8:
      result = 1;
      *v4 = v3;
      break;
  }
  return result;
}

//----- (0056E882) --------------------------------------------------------
bool __fastcall CDamageManager::ProgressEngineDamage(CDamageManager *this, float fDamageMultiplier)
{
  return 0;
}

//----- (0056E886) --------------------------------------------------------
bool __fastcall CDamageManager::ProgressPanelDamage(CDamageManager *this, uint8 ComponentNumber)
{
  int v3; // r5
  char v4; // r6
  uint32 v5; // r4
  int v6; // r0

  v3 = ComponentNumber;
  v4 = 4 * ComponentNumber;
  v5 = (this->m_Panels >> (4 * ComponentNumber)) & 0xF;
  if ( v5 != 3 )
  {
    if ( v5 != 2 )
    {
LABEL_5:
      this->m_Panels = this->m_Panels & ~(15 << v4) | ((v5 + 1) << v4);
      return 1;
    }
    v6 = rand();
    if ( v3 == 4 )
    {
      if ( !(v6 << 31) )
        goto LABEL_5;
    }
    else if ( !(v6 << 29) )
    {
      goto LABEL_5;
    }
  }
  return 0;
}

//----- (0056E8DC) --------------------------------------------------------
bool __fastcall CDamageManager::ProgressWheelDamage(CDamageManager *this, uint8 ComponentNumber)
{
  char *v2; // r0
  _BYTE *v3; // r0
  char v4; // r1
  int v5; // t1

  v2 = (char *)this + ComponentNumber;
  v5 = (unsigned __int8)v2[5];
  v3 = v2 + 5;
  v4 = v5;
  if ( v5 == 2 )
    return 0;
  *v3 = v4 + 1;
  return 1;
}

//----- (0056E8F0) --------------------------------------------------------
bool __fastcall CDamageManager::ProgressAeroplaneDamage(CDamageManager *this, uint8 ComponentNumber)
{
  uint32 m_Panels; // r12
  char v3; // r1
  int v4; // r3

  m_Panels = this->m_Panels;
  v3 = 2 * ComponentNumber - 24;
  v4 = (m_Panels >> v3) & 3;
  if ( v4 == 2 )
    return 0;
  this->m_Panels = ((v4 + 1) << v3) | m_Panels & ~(3 << v3);
  return 1;
}

//----- (0056E924) --------------------------------------------------------
bool __fastcall CDamageManager::ApplyDamage(
        CDamageManager *this,
        CAutomobile *pAutomobile,
        tComponent Component,
        float fImpact,
        float fDamageMultiplier)
{
  int v5; // r6
  unsigned __int8 v8; // r0
  float v9; // s0
  eDoors v10; // r6
  char *v11; // r5
  char v12; // r1
  char *v13; // r5
  int v14; // t1
  bool result; // r0
  ePanels v16; // r8
  char *v17; // r0
  _BYTE *v18; // r0
  char v19; // r1
  int v20; // t1
  uint32 v21; // r10
  int v22; // r11
  int v23; // r0

  if ( (*(_BYTE *)&pAutomobile->m_nAutomobileFlags & 0x10) == 0 )
    return 0;
  if ( Component < CT_PANEL_FRONT_LEFT )
  {
    if ( Component < CT_DOOR_BONNET )
    {
      if ( Component < CT_WHEEL_FRONT_LEFT )
      {
        if ( Component < CT_ENGINE )
        {
          v8 = -2;
        }
        else
        {
          v8 = 0;
          v5 = 6;
        }
      }
      else
      {
        v8 = Component - 1;
        v5 = 1;
      }
    }
    else
    {
      v5 = 2;
      if ( Component == CT_DOOR_BOOT )
        v5 = 4;
      if ( Component == CT_DOOR_BONNET )
        v5 = 3;
      v8 = Component - 5;
    }
  }
  else
  {
    v5 = 5;
    if ( Component > CT_PANEL_WINDSCREEN )
      v5 = 0;
    v8 = Component - 11;
  }
  v9 = G_aComponentDamage[v5] * fImpact;
  if ( Component == CT_PANEL_WINDSCREEN )
    v9 = v9 * 0.6;
  if ( v9 <= 150.0 )
    return 0;
  switch ( v5 )
  {
    case 0:
      v16 = v8;
      goto LABEL_30;
    case 1:
      v17 = (char *)this + v8;
      v20 = (unsigned __int8)v17[5];
      v18 = v17 + 5;
      v19 = v20;
      if ( v20 != 2 )
        *v18 = v19 + 1;
      goto LABEL_43;
    case 2:
    case 3:
    case 4:
      v10 = v8;
      if ( v8 <= 5u )
      {
        v11 = (char *)this + v8;
        v14 = (unsigned __int8)v11[9];
        v13 = v11 + 9;
        v12 = v14;
        result = 1;
        switch ( v14 )
        {
          case 0:
          case 1:
            CDoor::Open(&pAutomobile->Door[v10], 0.0);
            v12 = 2;
            goto LABEL_42;
          case 2:
            v12 = 3;
            goto LABEL_42;
          case 3:
            if ( (rand() & 7) != 0 )
              goto LABEL_43;
            v12 = 4;
            goto LABEL_42;
          case 4:
            return result;
          default:
LABEL_42:
            *v13 = v12;
            CAutomobile::SetDoorDamage(pAutomobile, v10, 0);
            break;
        }
      }
      goto LABEL_43;
    case 5:
      v16 = v8;
      this->m_Lights = (1 << (2 * v8)) | this->m_Lights & ~(3 << (2 * v8));
LABEL_30:
      v21 = (this->m_Panels >> (4 * v16)) & 0xF;
      if ( v21 == 3 )
        goto LABEL_43;
      if ( v21 != 2 )
        goto LABEL_36;
      v22 = v8;
      v23 = rand();
      if ( v22 == 4 )
      {
        if ( v23 << 31 )
          goto LABEL_43;
      }
      else if ( v23 << 29 )
      {
        goto LABEL_43;
      }
LABEL_36:
      this->m_Panels = this->m_Panels & ~(15 << (4 * v16)) | ((v21 + 1) << (4 * v16));
      if ( v5 )
        CAutomobile::SetPanelDamage(pAutomobile, v16, 0);
      else
        CAutomobile::SetBumperDamage(pAutomobile, v16, 0);
LABEL_43:
      result = 1;
      break;
    default:
      goto LABEL_43;
  }
  return result;
}
// 56E988: variable 'v5' is possibly undefined

//----- (0056EAC8) --------------------------------------------------------
void __fastcall CDamageManager::FuckCarCompletely(CDamageManager *this, bool bKeepWheels)
{
  uint32 m_Panels; // r5
  int v4; // r0
  uint32 v5; // r6
  char v6; // r0
  int v7; // r0
  unsigned int v8; // r5
  char v9; // r0
  int v10; // r0
  unsigned int v11; // r6
  char v12; // r0
  int v13; // r0
  unsigned int v14; // r5
  char v15; // r0
  int v16; // r0
  unsigned int v17; // r6
  char v18; // r0
  int v19; // r0
  bool v20; // zf
  uint32 v21; // r0

  if ( !bKeepWheels )
    this->m_Wheel[(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0)] = 2;
  m_Panels = this->m_Panels;
  *(_WORD *)&this->m_Door[4] = 1028;
  *(_DWORD *)this->m_Door = 67372036;
  v4 = (m_Panels >> 20) & 0xF;
  if ( v4 == 2 )
  {
    v6 = rand();
    v5 = this->m_Panels;
    if ( (v6 & 7) != 0 )
      goto LABEL_8;
  }
  else
  {
    v5 = m_Panels;
    if ( v4 == 3 )
    {
      v5 = m_Panels;
      goto LABEL_8;
    }
  }
  v5 = v5 & 0xFF0FFFFF | ((m_Panels & 0xF00000) + 0x100000);
  this->m_Panels = v5;
LABEL_8:
  v7 = HIBYTE(v5) & 0xF;
  if ( v7 == 3 )
  {
    v8 = v5;
  }
  else
  {
    v8 = v5;
    if ( v7 != 2 || (v9 = rand(), v8 = this->m_Panels, (v9 & 7) == 0) )
    {
      v8 = v8 & 0xF0FFFFFF | ((v5 & 0xF000000) + 0x1000000);
      this->m_Panels = v8;
    }
  }
  v10 = (v8 >> 20) & 0xF;
  if ( v10 == 3 )
  {
    v11 = v8;
  }
  else
  {
    v11 = v8;
    if ( v10 != 2 || (v12 = rand(), v11 = this->m_Panels, (v12 & 7) == 0) )
    {
      v11 = v11 & 0xFF0FFFFF | ((v8 & 0xF00000) + 0x100000);
      this->m_Panels = v11;
    }
  }
  v13 = HIBYTE(v11) & 0xF;
  if ( v13 == 3 )
  {
    v14 = v11;
  }
  else
  {
    v14 = v11;
    if ( v13 != 2 || (v15 = rand(), v14 = this->m_Panels, (v15 & 7) == 0) )
    {
      v14 = v14 & 0xF0FFFFFF | ((v11 & 0xF000000) + 0x1000000);
      this->m_Panels = v14;
    }
  }
  v16 = (v14 >> 20) & 0xF;
  if ( v16 == 3 )
  {
    v17 = v14;
  }
  else
  {
    v17 = v14;
    if ( v16 != 2 || (v18 = rand(), v17 = this->m_Panels, (v18 & 7) == 0) )
    {
      v17 = v17 & 0xFF0FFFFF | ((v14 & 0xF00000) + 0x100000);
      this->m_Panels = v17;
    }
  }
  v19 = HIBYTE(v17) & 0xF;
  if ( v19 != 3 )
  {
    v20 = v19 == 2;
    v21 = v17;
    if ( !v20 )
      goto LABEL_33;
    if ( (rand() & 7) == 0 )
    {
      v21 = this->m_Panels;
LABEL_33:
      this->m_Panels = v21 & 0xF0FFFFFF | ((v17 & 0xF000000) + 0x1000000);
    }
  }
  this->m_Lights = 0;
  this->m_Panels = 0;
  this->m_Engine = -6;
}

//----- (0056EC44) --------------------------------------------------------
int32 __fastcall CDamageManager::GetCarNodeIndexFromPanel(ePanels PanelIndex)
{
  if ( (unsigned int)PanelIndex <= REAR_BUMPER )
    return dword_56EC54[PanelIndex];
  else
    return -1;
}
// 56EC54: using guessed type int dword_56EC54[7];

//----- (0056EC70) --------------------------------------------------------
int32 __fastcall CDamageManager::GetCarNodeIndexFromDoor(eDoors DoorIndex)
{
  if ( (unsigned int)DoorIndex <= REAR_RIGHT_DOOR_0 )
    return dword_56EC80[DoorIndex];
  else
    return -1;
}
// 56EC80: using guessed type int dword_56EC80[6];

//----- (0056EC98) --------------------------------------------------------
bool __fastcall CDoor::Process(
        CDoor *this,
        CVehicle *pVehicle,
        CVector *vecOldMoveSpeed,
        CVector *vecOldTurnSpeed,
        CVector *vecOffset)
{
  int *v9; // r2
  float v10; // s4
  RwReal v11; // s2
  float v12; // s4
  float z; // s0
  int v14; // r6
  float v15; // s16
  float v16; // s18
  int v17; // r0
  float v18; // s20
  int v19; // r0
  float m_fAngle; // r4
  float v21; // r5
  float v22; // s2
  uint16 m_nDirn; // r4
  float m_fAngVel; // s2
  float v25; // s0
  float v26; // s2
  float v27; // s0
  int32 m_baseVehicleType; // r0
  bool v29; // zf
  float v30; // s16
  int v31; // s0
  int32 v32; // r0
  bool v33; // zf
  float v34; // s18
  float v35; // s2
  float v36; // s2
  float m_fOpenAngle; // s6
  float m_fClosedAngle; // s4
  uint8 v39; // r0
  bool v40; // r4
  int *v41; // r1
  CVector v43; // [sp+4h] [bp-ACh] BYREF
  CVector v2; // [sp+10h] [bp-A0h] BYREF
  CMatrix v45; // [sp+20h] [bp-90h] BYREF
  CVector v; // [sp+68h] [bp-48h] BYREF
  CVector v47; // [sp+74h] [bp-3Ch] BYREF

  CPhysical::GetSpeed(&v47, pVehicle, *vecOffset);
  CrossProduct((CVector *)&v45, vecOldTurnSpeed, vecOffset);
  v9 = dword_56F090;
  v10 = v45.zx + vecOldMoveSpeed->z;
  v11 = v47.y - (float)(v45.yx + vecOldMoveSpeed->y);
  v.x = v47.x - (float)(v45.xx + vecOldMoveSpeed->x);
  v12 = v47.z - v10;
  v.y = v11;
  if ( (this->m_nDirn & 0x20) != 0 )
    v9 = &dword_56F090[1];
  z = v12 + (float)(CTimer::ms_fTimeStep * *(float *)v9);
  v.z = z;
  CMatrix::CMatrix(&v45, pVehicle->m_pMat);
  Multiply3x3(&v2, &v, &v45);
  v14 = 0;
  v = v2;
  memset(&v2, 0, sizeof(v2));
  v15 = 0.0;
  switch ( this->m_nDirn & 0xF )
  {
    case 0:
      v16 = 1.0;
      v17 = 1065353216;
      goto LABEL_9;
    case 1:
      z = 1.0;
      v19 = 1065353216;
      goto LABEL_11;
    case 2:
      v18 = 1.0;
      v14 = 1065353216;
      goto LABEL_13;
    case 3:
      v17 = -1082130432;
      v16 = -1.0;
LABEL_9:
      LODWORD(v2.x) = v17;
      v14 = 0;
      v18 = 0.0;
      break;
    case 4:
      v19 = -1082130432;
      z = -1.0;
LABEL_11:
      LODWORD(v2.y) = v19;
      v14 = 0;
      v16 = 0.0;
      v18 = 0.0;
      v15 = z;
      break;
    case 5:
      v18 = -1.0;
      v14 = -1082130432;
LABEL_13:
      v16 = 0.0;
      LODWORD(v2.z) = v14;
      break;
    default:
      v16 = 0.0;
      v18 = 0.0;
      break;
  }
  m_fAngle = this->m_fAngle;
  v21 = sinf(m_fAngle);
  v22 = cosf(m_fAngle);
  if ( this->m_nAxis )
  {
    if ( this->m_nAxis == 2 )
    {
      LODWORD(v2.z) = v14;
      v2.y = (float)(v21 * v16) + (float)(v22 * v15);
      v2.x = (float)(v22 * v16) - (float)(v21 * v15);
      CrossProduct(&v43, &v, &v2);
      z = v43.z;
    }
  }
  else
  {
    v2.z = (float)(v21 * v15) + (float)(v22 * v18);
    v2.y = (float)(v22 * v15) - (float)(v21 * v18);
    CrossProduct(&v43, &v, &v2);
    z = v43.x;
  }
  m_nDirn = this->m_nDirn;
  if ( (m_nDirn & 0x40) != 0 )
  {
    if ( TheCamera.m_WideScreenOn )
      goto LABEL_25;
    m_baseVehicleType = pVehicle->m_baseVehicleType;
    v26 = 0.025;
    v29 = m_baseVehicleType == 0;
    if ( !m_baseVehicleType )
      v29 = LOBYTE(pVehicle[1].AutoPilot.TempActionFinish) == 0;
    if ( v29 )
LABEL_25:
      v26 = 0.0;
    v30 = (float)(z * v26) + this->m_fAngVel;
    this->m_fAngVel = v30;
    if ( TheCamera.m_WideScreenOn )
      goto LABEL_32;
    v32 = pVehicle->m_baseVehicleType;
    v31 = 1065017672;
    v33 = v32 == 0;
    if ( !v32 )
      v33 = LOBYTE(pVehicle[1].AutoPilot.TempActionFinish) == 0;
    if ( v33 )
LABEL_32:
      v31 = 1064514355;
    v34 = CTimer::ms_fTimeStep;
    v27 = (float)(powf(*(float *)&v31, CTimer::ms_fTimeStep) * v30) + (float)((float)(this->m_fAngle * -0.06) * v34);
  }
  else
  {
    if ( fabsf(z) > 0.001 || (m_fAngVel = this->m_fAngVel, fabsf(m_fAngVel) > 0.001) )
    {
      m_fAngVel = z + this->m_fAngVel;
      this->m_fAngVel = m_fAngVel;
    }
    if ( pVehicle->m_baseVehicleType == 5 )
    {
      v25 = 0.98;
    }
    else
    {
      if ( pVehicle->m_nModelIndex == 544 )
      {
        v27 = (float)(m_fAngVel * 0.92) + (float)((float)(this->m_fAngle * -0.01) * CTimer::ms_fTimeStep);
        goto LABEL_39;
      }
      v25 = 0.97;
    }
    v27 = m_fAngVel * v25;
  }
LABEL_39:
  this->m_fAngVel = v27;
  if ( (m_nDirn & 0x40) != 0 )
  {
    v35 = 0.02;
  }
  else
  {
    v35 = 0.05;
    if ( (m_nDirn & 0x100) == 0 )
      v35 = CDoor::DOOR_SPEED_MAX_CAPPED;
  }
  if ( v27 > v35 || (v35 = -v35, v27 < v35) )
  {
    v27 = v35;
    this->m_fAngVel = v35;
  }
  v36 = v27 + this->m_fAngle;
  this->m_fAngle = v36;
  if ( (m_nDirn & 0x80) == 0 )
    this->m_nDoorState = 0;
  m_fOpenAngle = this->m_fOpenAngle;
  m_fClosedAngle = this->m_fClosedAngle;
  if ( this->m_fOpenAngle < m_fClosedAngle )
  {
    if ( v36 >= m_fOpenAngle )
    {
      if ( v36 > m_fClosedAngle )
        goto LABEL_57;
LABEL_65:
      v40 = 0;
      goto LABEL_66;
    }
LABEL_54:
    this->m_fAngle = m_fOpenAngle;
    this->m_fAngVel = v27 * -0.8;
    if ( (m_nDirn & 0x80) == 0 )
    {
      v39 = 1;
LABEL_64:
      this->m_nDoorState = v39;
      goto LABEL_65;
    }
    goto LABEL_65;
  }
  if ( v36 > m_fOpenAngle )
    goto LABEL_54;
  if ( v36 >= m_fClosedAngle )
    goto LABEL_65;
LABEL_57:
  this->m_fAngle = m_fClosedAngle;
  if ( (m_nDirn & 0x90) != 16 || fabsf(v27) <= 0.1 )
  {
    v41 = dword_56F0DC;
    if ( (m_nDirn & 0x20) != 0 )
      v41 = &dword_56F0DC[1];
    this->m_fAngVel = v27 * *(float *)v41;
    if ( (m_nDirn & 0x80) != 0 )
      goto LABEL_65;
    v39 = 2;
    goto LABEL_64;
  }
  v40 = 1;
  this->m_nDoorState = 4;
  this->m_fAngVel = 0.0;
LABEL_66:
  CMatrix::~CMatrix(&v45);
  return v40;
}
// 56F090: using guessed type int dword_56F090[2];
// 56F0DC: using guessed type int dword_56F0DC[2];

//----- (0056F0E8) --------------------------------------------------------
bool __fastcall CDoor::ProcessImpact(
        CDoor *this,
        CVehicle *pVehicle,
        CVector *vecOldMoveSpeed,
        CVector *vecOldTurnSpeed,
        CVector *vecOffset)
{
  float z; // s16
  RwReal v10; // s2
  RwReal v11; // s4
  CMatrix *m_pMat; // r0
  __int64 v13; // d16
  RwReal zx; // r0
  CMatrix *v15; // r0
  CMatrix *v16; // r0
  CMatrix *v17; // r0
  float xx; // s0
  float yx; // s2
  float zy; // s4
  CMatrix *v21; // r0
  CMatrix *v22; // r0
  int v23; // r0
  float m_fClosedAngle; // s4
  float v25; // s2
  bool v26; // cc
  char v27; // r4
  char v28; // r1
  float v29; // s2
  char v30; // r0
  CVector v32; // [sp+4h] [bp-9Ch] BYREF
  CVector v2; // [sp+10h] [bp-90h] BYREF
  CMatrix v34; // [sp+20h] [bp-80h] BYREF
  CVector v1; // [sp+68h] [bp-38h] BYREF
  CVector v36; // [sp+74h] [bp-2Ch] BYREF

  CPhysical::GetSpeed(&v36, pVehicle, *vecOffset);
  CrossProduct((CVector *)&v34, vecOldTurnSpeed, vecOffset);
  v10 = v36.y - (float)(v34.yx + vecOldMoveSpeed->y);
  v11 = v36.z - (float)(v34.zx + vecOldMoveSpeed->z);
  v1.x = v36.x - (float)(v34.xx + vecOldMoveSpeed->x);
  v1.y = v10;
  v1.z = v11;
  CMatrix::CMatrix(&v34, pVehicle->m_pMat);
  switch ( this->m_nDirn & 0xF )
  {
    case 0:
      m_pMat = pVehicle->m_pMat;
      v13 = *(_QWORD *)&m_pMat->xx;
      zx = m_pMat->zx;
      goto LABEL_5;
    case 1:
      v15 = pVehicle->m_pMat;
      v13 = *(_QWORD *)&v15->xy;
      zx = v15->zy;
      goto LABEL_5;
    case 2:
      v16 = pVehicle->m_pMat;
      v13 = *(_QWORD *)&v16->xz;
      zx = v16->zz;
LABEL_5:
      v2.z = zx;
      *(_QWORD *)&v2.x = v13;
      break;
    case 3:
      v17 = pVehicle->m_pMat;
      xx = v17->xx;
      yx = v17->yx;
      zy = v17->zx;
      goto LABEL_9;
    case 4:
      v21 = pVehicle->m_pMat;
      xx = v21->xy;
      yx = v21->yy;
      zy = v21->zy;
      goto LABEL_9;
    case 5:
      v22 = pVehicle->m_pMat;
      xx = v22->xz;
      yx = v22->yz;
      zy = v22->zz;
LABEL_9:
      v2.y = -yx;
      v2.x = -xx;
      v2.z = -zy;
      break;
    default:
      break;
  }
  if ( this->m_nAxis )
  {
    if ( this->m_nAxis == 2 )
    {
      CrossProduct(&v32, &v1, &v2);
      z = v32.z;
    }
  }
  else
  {
    CrossProduct(&v32, &v1, &v2);
    z = v32.x;
  }
  v23 = rand();
  m_fClosedAngle = this->m_fClosedAngle;
  v25 = (float)((float)((float)((float)v23 * 4.6566e-10) * 0.75) + 0.75) * 0.1;
  v26 = this->m_fOpenAngle <= m_fClosedAngle;
  if ( this->m_fOpenAngle >= m_fClosedAngle )
    v26 = z <= v25;
  if ( v26 )
  {
    v28 = 0;
    v29 = -v25;
    v30 = 0;
    if ( this->m_fOpenAngle < m_fClosedAngle )
      v28 = 1;
    if ( z < v29 )
      v30 = 1;
    v27 = v30 & v28;
  }
  else
  {
    v27 = 1;
  }
  CMatrix::~CMatrix(&v34);
  return v27;
}
// 56F24E: variable 'z' is possibly undefined

//----- (0056F29C) --------------------------------------------------------
void __fastcall CDoor::Open(CDoor *this, float fAngRatio)
{
  float m_fOpenAngle; // s0
  float v3; // s0
  unsigned int m_nDirn_low; // r1

  m_fOpenAngle = this->m_fOpenAngle;
  this->m_fPrevAngle = this->m_fAngle;
  if ( fAngRatio >= 1.0 )
  {
    m_nDirn_low = LOBYTE(this->m_nDirn);
    this->m_fAngle = m_fOpenAngle;
    if ( !(m_nDirn_low >> 7) )
      this->m_nDoorState = 1;
  }
  else
  {
    v3 = m_fOpenAngle * fAngRatio;
    this->m_fAngle = v3;
    if ( v3 == 0.0 )
      this->m_fAngVel = 0.0;
  }
}

//----- (0056F2E4) --------------------------------------------------------
float __fastcall CDoor::GetAngleOpenRatio(const CDoor *this)
{
  if ( this->m_fOpenAngle == 0.0 )
    return 0.0;
  else
    return this->m_fAngle / this->m_fOpenAngle;
}

//----- (0056F310) --------------------------------------------------------
bool __fastcall CDoor::IsClosed(const CDoor *this)
{
  return this->m_fAngle == this->m_fClosedAngle;
}

//----- (0056F328) --------------------------------------------------------
bool __fastcall CDoor::IsFullyOpen(const CDoor *this)
{
  return fabsf(this->m_fOpenAngle) + -0.5 <= fabsf(this->m_fAngle);
}

//----- (0056F358) --------------------------------------------------------
bool __fastcall CTrainDoor::IsClosed(const CTrainDoor *this)
{
  float fMaxTrans; // s0
  float fMinTrans; // s2
  float v3; // s6
  float m_fTrans; // s4
  bool result; // r0

  fMaxTrans = this->fMaxTrans;
  fMinTrans = this->fMinTrans;
  v3 = fabsf(this->fMaxTrans);
  m_fTrans = this->m_fTrans;
  result = 0;
  if ( fabsf(fMinTrans) > v3 )
    fMinTrans = fMaxTrans;
  if ( m_fTrans == fMinTrans )
    return 1;
  return result;
}

//----- (0056F38A) --------------------------------------------------------
float __fastcall CTrainDoor::RetTranslationWhenClosed(const CTrainDoor *this)
{
  float fMinTrans; // s2

  fMinTrans = this->fMinTrans;
  if ( fabsf(fMinTrans) > fabsf(this->fMaxTrans) )
    return this->fMaxTrans;
  return fMinTrans;
}

//----- (0056F3AE) --------------------------------------------------------
bool __fastcall CTrainDoor::IsFullyOpen(const CTrainDoor *this)
{
  float fMaxTrans; // s0
  float fMinTrans; // s2
  float v3; // s6
  float m_fTrans; // s4
  bool result; // r0

  fMaxTrans = this->fMaxTrans;
  fMinTrans = this->fMinTrans;
  v3 = fabsf(this->fMaxTrans);
  m_fTrans = this->m_fTrans;
  result = 0;
  if ( fabsf(fMinTrans) > v3 )
    fMaxTrans = fMinTrans;
  if ( fabsf(fMaxTrans) + -0.5 <= fabsf(m_fTrans) )
    return 1;
  return result;
}

//----- (0056F3F8) --------------------------------------------------------
float __fastcall CTrainDoor::RetTranslationWhenOpen(const CTrainDoor *this)
{
  float fMaxTrans; // s0

  fMaxTrans = this->fMaxTrans;
  if ( fabsf(this->fMinTrans) > fabsf(this->fMaxTrans) )
    return this->fMinTrans;
  return fMaxTrans;
}

//----- (0056F41C) --------------------------------------------------------
bool __fastcall CTrainDoor::IsInUse(CTrainDoor *this)
{
  float m_fTrans; // s0
  float v2; // s2

  m_fTrans = this->m_fTrans;
  v2 = this->m_fPrevTrans - m_fTrans;
  this->m_fPrevTrans = m_fTrans;
  return fabsf(v2) > 0.002;
}

//----- (0056F448) --------------------------------------------------------
void __fastcall CTrainDoor::Open(CTrainDoor *this, float fRatio)
{
  float fMaxTrans; // s0

  fMaxTrans = this->fMaxTrans;
  if ( fabsf(this->fMinTrans) > fabsf(this->fMaxTrans) )
    fMaxTrans = this->fMinTrans;
  this->m_fPrevTrans = this->m_fTrans;
  if ( fRatio >= 1.0 )
    this->m_nDoorState = 1;
  else
    fMaxTrans = fMaxTrans * fRatio;
  this->m_fTrans = fMaxTrans;
}

//----- (0056F48A) --------------------------------------------------------
void __fastcall CBouncingPanel::ResetPanel(CBouncingPanel *this)
{
  this->m_nComponentIndex = -1;
}

//----- (0056F492) --------------------------------------------------------
void __fastcall CBouncingPanel::SetPanel(CBouncingPanel *this, int16 nIndex, int16 nAxis, float fMult)
{
  CVector *p_m_vecBounceAngle; // r0

  this->m_nBounceAxis = nAxis;
  this->m_nComponentIndex = nIndex;
  this->m_fBounceApplyMult = fMult;
  this->m_vecBounceTurnSpeed.y = 0.0;
  this->m_vecBounceTurnSpeed.z = 0.0;
  p_m_vecBounceAngle = &this->m_vecBounceAngle;
  *(_QWORD *)&p_m_vecBounceAngle->x = 0LL;
  *(_QWORD *)&p_m_vecBounceAngle->z = 0LL;
}

//----- (0056F4AC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBouncingPanel::ProcessPanel(
        CBouncingPanel *this,
        CVehicle *pVehicle,
        RwFrame_0 *pNode,
        CVector vecOldMoveSpeed,
        CVector vecOldTurnSpeed,
        float fReturnMult,
        float fDampMult)
{
  float32x2_t v7; // d1
  float32x2_t v8; // d2
  float32x2_t v9; // d3
  float x; // r9
  RwReal v13; // r2
  int m_nBounceAxis; // r4
  float m_fBounceApplyMult; // s8
  float32x2_t v16; // d2
  RwReal *p_y; // r0
  float y; // s18
  float v20; // s20
  float v21; // s16
  float v22; // s22
  float v23; // s24
  float v24; // s28
  float v25; // s26
  float v26; // s8
  float v27; // s2
  float v28; // s10
  float v29; // s4
  float v30; // s6
  float **v31; // r0
  float *v32; // r0
  CVector *p_m_vecBounceAngle; // r6
  float v34; // r0
  float v35; // s2
  float *p_xz; // r0
  RwReal z; // [sp+0h] [bp-E0h]
  CVector v38; // [sp+8h] [bp-D8h] BYREF
  CVector v; // [sp+18h] [bp-C8h] BYREF
  CVector v40; // [sp+24h] [bp-BCh] BYREF
  CVector v41; // [sp+30h] [bp-B0h] BYREF
  CMatrix v42; // [sp+3Ch] [bp-A4h] BYREF
  CVector v1; // [sp+84h] [bp-5Ch] BYREF

  v1 = vecOldTurnSpeed;
  x = vecOldMoveSpeed.x;
  CMatrix::CMatrix(&v42, &pNode->modelling, 0);
  Multiply3x3(&v41, pVehicle->m_pMat, (const CVector *)&v42.tx);
  v13 = v41.x;
  vecOldMoveSpeed.x = v41.y;
  z = v41.z;
  CPhysical::GetSpeed(&v40, pVehicle, vecOldMoveSpeed);
  CrossProduct(&v, &v1, &v41);
  v.x = v40.x - (float)(v.x + x);
  v.y = v40.y - (float)(v.y + vecOldMoveSpeed.y);
  v.z = v40.z - (float)(v.z + vecOldMoveSpeed.z);
  Multiply3x3(&v38, &v, pVehicle->m_pMat);
  v = v38;
  m_nBounceAxis = (unsigned __int16)this->m_nBounceAxis;
  if ( m_nBounceAxis == 2 )
  {
    v8.n64_u32[0] = LODWORD(v.y);
    m_fBounceApplyMult = this->m_fBounceApplyMult;
    v7.n64_f32[0] = CBouncingPanel::BOUNCE_VEL_CHANGE_LIMIT;
    p_y = &this->m_vecBounceTurnSpeed.y;
    v9.n64_f32[0] = -CBouncingPanel::BOUNCE_VEL_CHANGE_LIMIT;
    v16.n64_u64[0] = vmin_f32(v7, vmax_f32(v8, v9)).n64_u64[0];
    this->m_vecBounceTurnSpeed.x = this->m_vecBounceTurnSpeed.x + (float)(m_fBounceApplyMult * v16.n64_f32[0]);
    v16.n64_u32[0] = LODWORD(v.x);
  }
  else
  {
    if ( m_nBounceAxis == 1 )
    {
      v8.n64_u32[0] = LODWORD(v.z);
      m_fBounceApplyMult = this->m_fBounceApplyMult;
      v7.n64_f32[0] = CBouncingPanel::BOUNCE_VEL_CHANGE_LIMIT;
      v9.n64_f32[0] = -CBouncingPanel::BOUNCE_VEL_CHANGE_LIMIT;
      v16.n64_u64[0] = vmin_f32(v7, vmax_f32(v8, v9)).n64_u64[0];
      this->m_vecBounceTurnSpeed.x = this->m_vecBounceTurnSpeed.x + (float)(m_fBounceApplyMult * v16.n64_f32[0]);
    }
    else
    {
      if ( this->m_nBounceAxis )
        goto LABEL_9;
      v8.n64_u32[0] = LODWORD(v.z);
      m_fBounceApplyMult = this->m_fBounceApplyMult;
      v7.n64_f32[0] = CBouncingPanel::BOUNCE_VEL_CHANGE_LIMIT;
      v9.n64_f32[0] = -CBouncingPanel::BOUNCE_VEL_CHANGE_LIMIT;
      v16.n64_u64[0] = vmin_f32(v7, vmax_f32(v8, v9)).n64_u64[0];
      this->m_vecBounceTurnSpeed.y = this->m_vecBounceTurnSpeed.y + (float)(m_fBounceApplyMult * v16.n64_f32[0]);
    }
    v16.n64_u32[0] = LODWORD(v.y);
    p_y = &this->m_vecBounceTurnSpeed.z;
  }
  *p_y = (float)(m_fBounceApplyMult * vmin_f32(v7, vmax_f32(v16, v9)).n64_f32[0]) + *p_y;
LABEL_9:
  if ( fReturnMult <= -1.0 )
  {
    v21 = this->m_vecBounceAngle.x;
    y = this->m_vecBounceAngle.y;
    v20 = this->m_vecBounceAngle.z;
    if ( m_nBounceAxis == 2 )
    {
      v26 = CBouncingPanel::BOUNCE_HANGING_RETURN_MULT * v21;
      v27 = this->m_vecBounceTurnSpeed.y;
      v28 = CBouncingPanel::BOUNCE_HANGING_RETURN_MULT * y;
      v29 = this->m_vecBounceTurnSpeed.z;
      v22 = CTimer::ms_fTimeStep;
      v30 = CBouncingPanel::BOUNCE_HANGING_RETURN_MULT * v20;
      v31 = &CBouncingPanel::BOUNCE_HANGING_DAMP_MULT;
    }
    else
    {
      v26 = CBouncingPanel::BOUNCE_SPRING_RETURN_MULT * v21;
      v27 = this->m_vecBounceTurnSpeed.y;
      v28 = CBouncingPanel::BOUNCE_SPRING_RETURN_MULT * y;
      v29 = this->m_vecBounceTurnSpeed.z;
      v22 = CTimer::ms_fTimeStep;
      v30 = CBouncingPanel::BOUNCE_SPRING_RETURN_MULT * v20;
      v31 = &CBouncingPanel::BOUNCE_SPRING_DAMP_MULT;
    }
    v25 = this->m_vecBounceTurnSpeed.x - (float)(v26 * v22);
    v23 = v27 - (float)(v28 * v22);
    v24 = v29 - (float)(v30 * v22);
    v32 = *v31;
    this->m_vecBounceTurnSpeed.x = v25;
    this->m_vecBounceTurnSpeed.y = v23;
    this->m_vecBounceTurnSpeed.z = v24;
    fDampMult = *v32;
  }
  else
  {
    y = this->m_vecBounceAngle.y;
    v20 = this->m_vecBounceAngle.z;
    v21 = this->m_vecBounceAngle.x;
    v22 = CTimer::ms_fTimeStep;
    v23 = this->m_vecBounceTurnSpeed.y - (float)((float)(y * fReturnMult) * CTimer::ms_fTimeStep);
    v24 = this->m_vecBounceTurnSpeed.z - (float)((float)(v20 * fReturnMult) * CTimer::ms_fTimeStep);
    v25 = this->m_vecBounceTurnSpeed.x - (float)((float)(v21 * fReturnMult) * CTimer::ms_fTimeStep);
    this->m_vecBounceTurnSpeed.x = v25;
    this->m_vecBounceTurnSpeed.y = v23;
    this->m_vecBounceTurnSpeed.z = v24;
  }
  p_m_vecBounceAngle = (CVector *)&this->m_vecBounceAngle.y;
  v34 = powf(fDampMult, v22);
  v35 = (float)(v22 * (float)(v34 * v25)) + v21;
  this->m_vecBounceAngle.x = v35;
  this->m_vecBounceAngle.y = (float)(v22 * (float)(v34 * v23)) + y;
  this->m_vecBounceAngle.z = (float)(v22 * (float)(v34 * v24)) + v20;
  this->m_vecBounceTurnSpeed.x = v34 * v25;
  this->m_vecBounceTurnSpeed.y = v34 * v23;
  this->m_vecBounceTurnSpeed.z = v34 * v24;
  switch ( m_nBounceAxis )
  {
    case 2:
      p_xz = &v42.xz;
      v42.yz = v35;
      goto LABEL_21;
    case 1:
      p_m_vecBounceAngle = &this->m_vecBounceAngle;
      v42.xy = (float)(v22 * (float)(v34 * v24)) + v20;
      p_xz = &v42.zy;
      goto LABEL_21;
    case 0:
      v42.yx = (float)(v22 * (float)(v34 * v24)) + v20;
      p_xz = &v42.zx;
LABEL_21:
      *p_xz = p_m_vecBounceAngle->x;
      break;
  }
  CMatrix::UpdateRW(&v42);
  CMatrix::~CMatrix(&v42);
}
// 56F4AC: fragmented variable at 0:r3.4,4:^E8.8 may be wrong
// 56F4AC: variables would overlap: 0:r3.4,4:^E8.8 and ^E8.4
// 56F4AC: variables would overlap: 0:r3.4,4:^E8.8 and ^EC.4
// 677894: using guessed type float *CBouncingPanel::BOUNCE_HANGING_DAMP_MULT;
// 678E5C: using guessed type float *CBouncingPanel::BOUNCE_SPRING_DAMP_MULT;

//----- (0056F804) --------------------------------------------------------
int __fastcall cBuoyancy::ProcessBuoyancy(
        cBuoyancy *this,
        CPhysical *pPhysical,
        float fBouyConst,
        CVector *pCentreOfBuoyancy,
        _DWORD *a5)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r11
  CSimpleTransform *p_tx; // r2
  int v14; // r6
  CMatrix *v15; // r0
  CSimpleTransform *v16; // r1
  float z; // s4
  bool *p_bBuoyancyCalcValid; // r6
  float fWaterLevel; // s0
  float v20; // s4
  CMatrix *v21; // r0
  float v22; // r10
  float xy; // s4
  float yy; // s0
  float zy; // s2
  float m_heading; // r11
  _BOOL4 v27; // r0
  int v28; // r6
  __int64 v29; // d16
  float v30; // s2
  _BOOL4 bIsBoat; // r0
  CVector pNormal; // [sp+4h] [bp-4Ch]
  CVector v34; // [sp+10h] [bp-40h]
  float v35; // [sp+24h] [bp-2Ch]
  CVector v36; // [sp+28h] [bp-28h] BYREF
  CVector v37; // 0:r2.8,8:^0.4

  m_pMat = pPhysical->m_pMat;
  p_m_transform = &pPhysical->m_transform;
  p_tx = &pPhysical->m_transform;
  v14 = 0;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( CWaterLevel::GetWaterLevel(
         p_tx->m_translate.x,
         p_tx->m_translate.y,
         p_tx->m_translate.z,
         &this->fWaterLevel,
         (*(_DWORD *)&pPhysical->m_nPhysicalFlags >> 27) & 1,
         0) == 1 )
  {
    CMatrix::operator=(&this->mat, pPhysical->m_pMat);
    cBuoyancy::PreCalcSetup(this, pPhysical, fBouyConst);
    if ( (*(_BYTE *)&pPhysical->m_info & 7) == 3 )
    {
      CEntity::GetColModel(pPhysical);
      v15 = pPhysical->m_pMat;
      v16 = p_m_transform;
      if ( v15 )
        v16 = (CSimpleTransform *)&v15->tx;
      z = v16->m_translate.z;
      this->bBuoyancyCalcValid = 1;
      p_bBuoyancyCalcValid = &this->bBuoyancyCalcValid;
      fWaterLevel = this->fWaterLevel;
      v20 = (float)((float)(fWaterLevel - z) + 1.0) / 1.9;
      this->VolumeUnderWater = v20;
      if ( v20 <= 1.0 )
      {
        if ( v20 < 0.0 )
        {
          v20 = 0.0;
          this->bBuoyancyCalcValid = 0;
          this->VolumeUnderWater = 0.0;
        }
      }
      else
      {
        v20 = 1.0;
        this->VolumeUnderWater = 1.0;
      }
      this->CentreOfBuoyancy.x = 0.0;
      this->CentreOfBuoyancy.y = 0.0;
      this->CentreOfBuoyancy.z = 0.0;
      if ( v20 > 0.0 && v20 < 1.0 )
      {
        v21 = pPhysical->m_pMat;
        if ( v21 )
          p_m_transform = (CSimpleTransform *)&v21->tx;
        v22 = fWaterLevel - p_m_transform->m_translate.z;
        if ( v21 )
        {
          xy = v21->xy;
          yy = v21->yy;
          zy = v21->zy;
        }
        else
        {
          m_heading = pPhysical->m_transform.m_heading;
          v35 = sinf(m_heading);
          yy = cosf(m_heading);
          zy = 0.0;
          LODWORD(xy) = LODWORD(v35) ^ 0x80000000;
        }
        *(_QWORD *)&v37.x = 0LL;
        v37.z = v22;
        *(_QWORD *)&pNormal.x = 0LL;
        pNormal.z = v22;
        v34.x = -xy;
        v34.y = -yy;
        v34.z = -zy;
        cBuoyancy::AddSplashParticles(0, pPhysical, v37, pNormal, v34, 1);
      }
    }
    else
    {
      cBuoyancy::SimpleCalcBuoyancy(this, pPhysical);
      p_bBuoyancyCalcValid = &this->bBuoyancyCalcValid;
    }
    v27 = *p_bBuoyancyCalcValid;
    v28 = 0;
    if ( v27 )
    {
      Multiply3x3(&v36, &this->mat, &this->CentreOfBuoyancy);
      v29 = *(_QWORD *)&v36.x;
      pCentreOfBuoyancy->z = v36.z;
      *(_QWORD *)&pCentreOfBuoyancy->x = v29;
      *a5 = 0;
      a5[1] = 0;
      v28 = 1;
      v5.n64_f32[0] = (float)(this->VolumeUnderWater * this->BuoyancyConstant) * CTimer::ms_fTimeStep;
      a5[2] = v5.n64_u32[0];
      v30 = pPhysical->m_vecMoveSpeed.z * pPhysical->m_fMass;
      if ( v30 > (float)(v5.n64_f32[0] * 4.0) )
      {
        v6.n64_u32[0] = 0;
        v5.n64_f32[0] = v5.n64_f32[0] - v30;
        a5[2] = vmax_f32(v5, v6).n64_u32[0];
      }
    }
    bIsBoat = this->bIsBoat;
    if ( this->bIsBoat )
      bIsBoat = 1;
    return v28 | bIsBoat;
  }
  return v14;
}
// 56F9E4: variable 'v5' is possibly undefined
// 56F9E4: variable 'v6' is possibly undefined

//----- (0056FA10) --------------------------------------------------------
void __fastcall cBuoyancy::PreCalcSetup(cBuoyancy *this, CPhysical *pPhysical, float fBouyConst)
{
  bool v6; // r0
  CColModel *ColModel; // r0
  __int64 v8; // d16
  __int64 v9; // d16
  _BOOL4 bIsBoat; // r3
  int m_nModelIndex; // r2
  float v12; // s0
  float y; // s2
  float v14; // s4
  float v15; // s6
  float v16; // s4
  RwReal v17; // s6
  RwReal v18; // s8
  int v19; // r2
  bool v20; // zf
  float v21; // s2
  RwReal v22; // s0
  float v23; // s0
  float v24; // s2
  float v25; // s4
  float z; // s6
  float v27; // s8
  float v28; // s10
  RwReal v29; // s0
  unsigned __int64 v30; // d1
  float v31; // s4
  float v32; // s6
  float v33; // s4
  float v34; // s2
  float fWaterLevel; // s4
  float fWaveOffset; // s6
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v39; // d16
  RwReal v40; // r1

  v6 = 0;
  if ( (*(_BYTE *)&pPhysical->m_info & 7) == 2 && LODWORD(pPhysical[4].m_vecCOM.z) == 5 )
    v6 = 1;
  this->bIsBoat = v6;
  ColModel = CEntity::GetColModel(pPhysical);
  v8 = *(_QWORD *)&ColModel->m_boxBound.m_vecMin.x;
  this->MinLimits.z = ColModel->m_boxBound.m_vecMin.z;
  *(_QWORD *)&this->MinLimits.x = v8;
  v9 = *(_QWORD *)&ColModel->m_boxBound.m_vecMax.x;
  bIsBoat = this->bIsBoat;
  this->MaxLimits.z = ColModel->m_boxBound.m_vecMax.z;
  *(_QWORD *)&this->MaxLimits.x = v9;
  m_nModelIndex = pPhysical->m_nModelIndex;
  if ( bIsBoat )
  {
    switch ( pPhysical->m_nModelIndex )
    {
      case 0x1BE:
        v29 = this->MinLimits.y * 0.9;
        this->MaxLimits.y = this->MaxLimits.y * 0.9;
        this->MinLimits.y = v29;
        goto LABEL_29;
      case 0x1BF:
      case 0x1C0:
      case 0x1C1:
      case 0x1C2:
      case 0x1C3:
      case 0x1C7:
      case 0x1C8:
      case 0x1C9:
      case 0x1CA:
      case 0x1CB:
      case 0x1CC:
      case 0x1CD:
      case 0x1CE:
      case 0x1CF:
      case 0x1D0:
      case 0x1D1:
      case 0x1D2:
      case 0x1D3:
      case 0x1D4:
      case 0x1D5:
      case 0x1D6:
      case 0x1D7:
      case 0x1DA:
      case 0x1DB:
      case 0x1DC:
      case 0x1DD:
      case 0x1DE:
      case 0x1DF:
      case 0x1E0:
      case 0x1E1:
      case 0x1E2:
      case 0x1E3:
      case 0x1E5:
      case 0x1E6:
      case 0x1E7:
      case 0x1E8:
      case 0x1E9:
      case 0x1EA:
      case 0x1EB:
      case 0x1EC:
        goto LABEL_18;
      case 0x1C4:
        v12 = 1.25;
        y = this->MaxLimits.y;
        v14 = this->MinLimits.y;
        v15 = 0.83;
        goto LABEL_28;
      case 0x1C5:
      case 0x1ED:
        this->MinLimits.y = this->MinLimits.y * 0.9;
        goto LABEL_29;
      case 0x1C6:
        v23 = 1.3;
        v24 = this->MaxLimits.y;
        v25 = this->MinLimits.y;
        z = this->MinLimits.z;
        v27 = 0.82;
        goto LABEL_24;
      case 0x1D8:
        v23 = 1.1;
        v24 = this->MaxLimits.y;
        v25 = this->MinLimits.y;
        z = this->MinLimits.z;
        v27 = 0.9;
        v28 = -0.3;
        goto LABEL_25;
      case 0x1D9:
        v23 = 1.3;
        v24 = this->MaxLimits.y;
        v25 = this->MinLimits.y;
        z = this->MinLimits.z;
        v27 = 0.9;
LABEL_24:
        v28 = -0.2;
        goto LABEL_25;
      case 0x1E4:
        v12 = 1.1;
        goto LABEL_27;
      default:
        if ( m_nModelIndex == 595 )
        {
          v23 = 1.25;
          v24 = this->MaxLimits.y;
          v25 = this->MinLimits.y;
          z = this->MinLimits.z;
          v27 = 0.8;
          v28 = -0.1;
LABEL_25:
          this->MaxLimits.y = v24 * v23;
          this->MinLimits.y = v25 * v27;
          this->MinLimits.z = z + v28;
          goto LABEL_29;
        }
LABEL_18:
        v12 = 1.05;
LABEL_27:
        y = this->MaxLimits.y;
        v14 = this->MinLimits.y;
        v15 = 0.9;
        break;
    }
    goto LABEL_28;
  }
  if ( m_nModelIndex == 460 )
  {
    v16 = this->MaxLimits.y;
    v17 = this->MinLimits.x * 0.3;
    v18 = this->MinLimits.z + -0.1;
    this->MaxLimits.x = this->MaxLimits.x * 0.3;
    this->MaxLimits.y = v16 * 1.4;
    this->MinLimits.x = v17;
    this->MinLimits.y = v16 * -0.6;
    this->MinLimits.z = v18;
    goto LABEL_29;
  }
  if ( m_nModelIndex == 417 )
  {
    v12 = 1.15;
    y = this->MaxLimits.y;
    v14 = this->MinLimits.y;
    v15 = 0.4;
LABEL_28:
    this->MaxLimits.y = y * v12;
    this->MinLimits.y = v14 * v15;
    goto LABEL_29;
  }
  v19 = *(_BYTE *)&pPhysical->m_info & 7;
  v20 = v19 == 2;
  if ( v19 == 2 )
    v20 = pPhysical[4].m_listEntryInfo.m_pHead == (CEntryInfoNode *)((char *)&dword_0 + 3);
  if ( v20 )
  {
    v21 = this->MinLimits.z;
    v22 = -this->MaxLimits.y;
    this->MaxLimits.z = v21 * -1.1;
    this->MinLimits.y = v22;
    this->MinLimits.z = v21 * 0.85;
  }
LABEL_29:
  v30 = vmul_f32(
          vsub_f32(*(float32x2_t *)&this->MaxLimits.x, *(float32x2_t *)&this->MinLimits.x),
          (float32x2_t)0x3F0000003F000000LL).n64_u64[0];
  v31 = (float)(this->MaxLimits.z - this->MinLimits.z) * 0.5;
  *(_QWORD *)&this->xstep = v30;
  this->zstep = v31;
  if ( v31 <= *(float *)&v30 )
  {
    if ( *((float *)&v30 + 1) <= *(float *)&v30 )
    {
      v32 = *((float *)&v30 + 1) / *(float *)&v30;
      this->xsc = 1.0;
    }
    else
    {
      v32 = 1.0;
      this->xsc = *(float *)&v30 / *((float *)&v30 + 1);
      LODWORD(v30) = HIDWORD(v30);
    }
    v34 = v31 / *(float *)&v30;
  }
  else
  {
    v32 = *((float *)&v30 + 1) / v31;
    v33 = *(float *)&v30 / v31;
    v34 = 1.0;
    this->xsc = v33;
  }
  this->ysc = v32;
  fWaterLevel = this->fWaterLevel;
  fWaveOffset = this->fWaveOffset;
  *(_QWORD *)&this->VolumeUnderWater = 0LL;
  *(_QWORD *)&this->CentreOfBuoyancy.y = 0LL;
  this->bBuoyancyCalcValid = 0;
  this->zsc = v34;
  this->count = 1.0;
  m_pMat = pPhysical->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPhysical->m_transform;
  v39 = *(_QWORD *)&p_tx->m_translate.x;
  v40 = p_tx->m_translate.z;
  this->Pos.z = v40;
  this->ShipPos.x = 0.0;
  this->ShipPos.y = 0.0;
  this->ShipPos.z = v40;
  this->BuoyancyConstant = fBouyConst;
  this->fWaterLevel = fWaveOffset + fWaterLevel;
  *(_QWORD *)&this->Pos.x = v39;
}
// 0: using guessed type int dword_0;

//----- (0056FDAC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall cBuoyancy::AddSplashParticles(
        cBuoyancy *this,
        CPhysical *pPhysical,
        CVector pos1,
        CVector pos2,
        CVector normal,
        int isPed)
{
  float x; // s28
  float y; // s17
  float z; // s16
  float v10; // s18
  float v11; // s4
  float v12; // s6
  float v13; // s2
  float v14; // s20
  float v15; // s22
  float v16; // s24
  float v17; // s26
  float v18; // s30
  float v19; // s19
  int v20; // r11
  int v21; // r10
  float v22; // s21
  float v23; // s19
  float v24; // s27
  CMatrix *m_pMat; // r1
  float v26; // s0
  CMatrix *v27; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v29; // s2
  RwReal v30; // s4
  float v31; // s0
  float AngleBetweenPoints; // r0
  float v33; // r9
  CMatrix *v34; // r0
  CSimpleTransform *p_m_transform; // r6
  float m_heading; // r5
  float v37; // r10
  float yy; // s0
  float v39; // s10
  float xy; // s2
  float v41; // s16
  RwReal v42; // s0
  RwReal v43; // s2
  float m_fMass; // r0
  RwV3d_0 pos; // [sp+18h] [bp-C8h] BYREF
  FxPrtMult_c v46; // [sp+24h] [bp-BCh] BYREF
  CVector v; // [sp+40h] [bp-A0h] BYREF
  RwV3d_0 v48; // [sp+4Ch] [bp-94h] BYREF
  FxPrtMult_c fxMults; // [sp+58h] [bp-88h] BYREF
  CVector v50; // [sp+74h] [bp-6Ch] BYREF

  v50 = normal;
  x = pPhysical->m_vecMoveSpeed.x;
  y = pPhysical->m_vecMoveSpeed.y;
  z = pPhysical->m_vecMoveSpeed.z;
  v10 = sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z));
  if ( v10 <= 0.1 )
  {
    if ( v10 <= 0.05 )
      return;
  }
  else
  {
    v11 = z * (float)(1.0 / v10);
    v12 = y * (float)(1.0 / v10);
    v13 = x * (float)(1.0 / v10);
    v10 = 0.1;
    z = v11 * 0.1;
    y = v12 * 0.1;
    x = v13 * 0.1;
  }
  v14 = pos1.y;
  v15 = pos1.x;
  v16 = pos2.y - pos1.y;
  v17 = pos2.x - pos1.x;
  LOWORD(pos1.y) = -13107;
  v18 = pos2.z - pos1.z;
  HIWORD(pos1.y) = 15948;
  v19 = sqrtf((float)(v18 * v18) + (float)((float)(v17 * v17) + (float)(v16 * v16)));
  FxPrtMult_c::FxPrtMult_c(&fxMults, 1.0, 1.0, 1.0, 0.1, 0.5, 1.0, pos1.y);
  if ( isPed )
  {
    fxMults.m_size = fxMults.m_size * 0.5;
    fxMults.m_life = fxMults.m_life * 0.5;
  }
  v20 = (int)(float)(v19 + v19);
  if ( v20 <= 1 )
    v20 = 1;
  v21 = 0;
  v22 = pPhysical->m_vecMoveSpeed.x * 0.0;
  v23 = pPhysical->m_vecMoveSpeed.y * 0.0;
  v24 = (float)(pPhysical->m_vecMoveSpeed.z * 0.0) * 0.0;
  do
  {
    m_pMat = pPhysical->m_pMat;
    v26 = (float)v21 / (float)v20;
    v.y = (float)(v16 * v26) + v14;
    v.x = (float)(v17 * v26) + v15;
    v.z = (float)(v18 * v26) + pos1.z;
    operator*((CVector *)&v46, m_pMat, &v);
    if ( (*(_BYTE *)&pPhysical->m_info & 7) != 3 )
    {
      v27 = pPhysical->m_pMat;
      p_tx = (CSimpleTransform *)&v27->tx;
      if ( !v27 )
        p_tx = &pPhysical->m_transform;
      v29 = v46.m_green - p_tx->m_translate.y;
      v30 = v46.m_blue - p_tx->m_translate.z;
      v50.x = v46.m_red - p_tx->m_translate.x;
      v50.y = v29;
      v50.z = v30;
    }
    v50.z = 0.0;
    CVector::Normalise(&v50);
    v48.x = v22 + (float)((float)((float)(x * 0.0) * 120.0) + (float)((float)(v10 * v50.x) * 60.0));
    v48.y = v23 + (float)((float)((float)(y * 0.0) * 120.0) + (float)((float)(v10 * v50.y) * 60.0));
    v48.z = v24 + (float)((float)((float)(v10 * v50.z) * 60.0) - (float)(z * 120.0));
    v31 = (float)((float)((float)rand() * 4.6566e-10) * 0.5) + 0.0;
    v46.m_blue = (float)(v50.z * v31) + v46.m_blue;
    v46.m_green = (float)(v50.y * v31) + v46.m_green;
    v46.m_red = v46.m_red + (float)(v50.x * v31);
    FxSystem_c::AddParticle(g_fx.m_fxSysWaterSplash, (RwV3d_0 *)&v46, &v48, 0.0, &fxMults, -1.0, 1.2, 0.6, 0);
    ++v21;
  }
  while ( v21 < v20 );
  if ( (*(_BYTE *)&pPhysical->m_info & 7) == 3 )
  {
    AngleBetweenPoints = CGeneral::GetAngleBetweenPoints(pPhysical->m_pMat->xy, pPhysical->m_pMat->yy, 0.0, 0.0);
    v33 = CGeneral::LimitAngle(AngleBetweenPoints);
    FxPrtMult_c::FxPrtMult_c(&v46, 1.0, 1.0, 1.0, 0.2, 0.4, 0.0, 0.5);
    memset(&v, 0, sizeof(v));
    v34 = pPhysical->m_pMat;
    p_m_transform = (CSimpleTransform *)&v34->tx;
    if ( v34 )
    {
      xy = v34->xy;
      yy = v34->yy;
      v39 = v34->zy * 0.4;
    }
    else
    {
      p_m_transform = &pPhysical->m_transform;
      m_heading = pPhysical->m_transform.m_heading;
      v37 = sinf(m_heading);
      yy = cosf(m_heading);
      v39 = 0.0;
      LODWORD(xy) = LODWORD(v37) ^ 0x80000000;
    }
    v41 = v39 + p_m_transform->m_translate.z;
    v42 = (float)(yy * 0.4) + p_m_transform->m_translate.y;
    v43 = p_m_transform->m_translate.x + (float)(xy * 0.4);
    pos.z = v41;
    pos.y = v42;
    pos.x = v43;
    if ( !CPedIntelligence::GetTaskSwim((const CPedIntelligence *)LODWORD(pPhysical[3].m_vecAverageTurnSpeed.z)) )
    {
      m_fMass = pPhysical[3].m_fMass;
      if ( m_fMass == 0.0 )
        pos.z = v41 + 0.5;
      else
        pos.z = *(RwReal *)(LODWORD(m_fMass) + 144);
      FxSystem_c::AddParticle(g_fx.m_fxSysWake, &pos, &v, 0.0, &v46, v33 + 180.0, 1.2, 0.6, 0);
      CAEPedAudioEntity::AddAudioEvent((CAEPedAudioEntity *)&pPhysical[1], 76, 0.0, 1.0, 0, 0, 0, 0);
    }
  }
  CAudioEngine::ReportWaterSplash(&AudioEngine, pPhysical, -100.0, 0);
}
// 56FEDA: conditional instruction was optimized away because r11.4>=1
// 56FDAC: fragmented variable at 0:r2.8,8:^E8.4 may be wrong
// 56FDAC: variables would overlap: 0:r2.8,8:^E8.4 and ^E8.4

//----- (00570248) --------------------------------------------------------
void __fastcall cBuoyancy::SimpleCalcBuoyancy(cBuoyancy *this, CPhysical *pPhysical)
{
  CMatrix *p_mat; // r6
  float x; // s16
  char *v5; // r10
  int v6; // r0
  int v7; // r11
  float y; // s18
  char *v9; // r9
  RwReal v10; // s2
  tWaterLevel v11; // r2
  float v12; // s0
  float z; // s2
  __int64 v14; // d16
  float v15; // s2
  float v16; // s0
  int v17; // r4
  float v18; // s16
  char *v19; // r6
  float v20; // s0
  float v21; // s4
  float v22; // s2
  float v23; // s0
  float v24; // s4
  float v25; // s2
  int i; // r4
  char *v27; // r6
  float v28; // s0
  float v29; // s4
  float v30; // s2
  float v31; // s0
  float v32; // s4
  float v33; // s2
  CVector normal; // [sp+10h] [bp-D8h]
  CVector normala; // [sp+10h] [bp-D8h]
  CVector normalb; // [sp+10h] [bp-D8h]
  CVector normalc; // [sp+10h] [bp-D8h]
  int v39; // [sp+28h] [bp-C0h]
  char v40[108]; // [sp+34h] [bp-B4h] BYREF
  CVector v; // [sp+A0h] [bp-48h] BYREF
  CVector v42; // [sp+ACh] [bp-3Ch] BYREF
  CVector v43; // 0:r2.8,8:^0.4
  CVector v44; // 0:r2.8,8:^0.4
  CVector v45; // 0:r2.8,8:^0.4
  CVector v46; // 0:r2.8,8:^0.4

  p_mat = &this->mat;
  x = this->MinLimits.x;
  v5 = v40;
  v6 = 0;
  do
  {
    v39 = v6;
    v7 = 0;
    y = this->MinLimits.y;
    do
    {
      v9 = &v5[v7];
      *(_DWORD *)&v5[v7] = 0;
      *((_DWORD *)v9 + 1) = 0;
      *((_DWORD *)v9 + 2) = 0;
      v.y = y;
      v.x = x;
      v.z = 0.0;
      Multiply3x3(&v42, p_mat, &v);
      v10 = this->Pos.y + v42.y;
      v42.x = this->Pos.x + v42.x;
      v42.y = v10;
      CWaterLevel::GetWaterLevel(v42.x, v10, this->Pos.z, &v.z, 1, 0);
      v12 = v.z - (float)(v42.z + this->ShipPos.z);
      v.z = v12;
      if ( v12 <= this->MaxLimits.z )
      {
        z = this->MinLimits.z;
        if ( v12 < z )
        {
          v.z = this->MinLimits.z;
          *((float *)v9 + 2) = z;
          fVolMultiplier = 1.0;
          goto LABEL_8;
        }
      }
      else
      {
        v.z = this->MaxLimits.z;
      }
      fVolMultiplier = 1.0;
      cBuoyancy::SimpleSumBuoyancyData(this, &v, v11);
      v14 = *(_QWORD *)&v.x;
      *((_DWORD *)v9 + 2) = LODWORD(v.z);
      *(_QWORD *)v9 = v14;
LABEL_8:
      v7 += 12;
      y = y + this->ystep;
    }
    while ( v7 != 36 );
    v5 += 36;
    x = x + this->xstep;
    v6 = v39 + 1;
  }
  while ( v39 != 2 );
  v15 = this->MinLimits.z;
  v16 = this->MaxLimits.z - v15;
  v17 = 0;
  this->VolumeUnderWater = this->VolumeUnderWater / (float)(v16 * 9.0);
  v18 = v15 + (float)(v16 * 0.5);
  do
  {
    v19 = &v40[v17];
    v20 = *(float *)&v40[v17 + 8];
    if ( v20 > v18 )
    {
      v21 = this->MaxLimits.z;
      if ( v20 < v21 )
      {
        v22 = *((float *)v19 + 11);
        if ( v22 > v18 && v22 < v21 )
        {
          v43.y = *((RwReal *)v19 + 1);
          v43.x = *(RwReal *)&v40[v17];
          normal.x = 0.0;
          *(_QWORD *)&normal.y = 3212836864LL;
          v43.z = *(RwReal *)&v40[v17 + 8];
          cBuoyancy::AddSplashParticles(*((cBuoyancy **)v19 + 10), pPhysical, v43, *((CVector *)v19 + 3), normal, 0);
        }
      }
    }
    v23 = *((float *)v19 + 8);
    if ( v23 > v18 )
    {
      v24 = this->MaxLimits.z;
      if ( v23 < v24 )
      {
        v25 = *((float *)v19 + 17);
        if ( v25 > v18 && v25 < v24 )
        {
          v44 = *(CVector *)(v19 + 2);
          normala.x = 0.0;
          *(_QWORD *)&normala.y = 1065353216LL;
          cBuoyancy::AddSplashParticles((cBuoyancy *)LODWORD(v44.z), pPhysical, v44, *((CVector *)v19 + 5), normala, 0);
        }
      }
    }
    v17 += 36;
  }
  while ( v17 != 72 );
  for ( i = 0; i != 24; i += 12 )
  {
    v27 = &v40[i];
    v28 = *(float *)&v40[i + 8];
    if ( v28 > v18 )
    {
      v29 = this->MaxLimits.z;
      if ( v28 < v29 )
      {
        v30 = *((float *)v27 + 5);
        if ( v30 > v18 && v30 < v29 )
        {
          v45.y = *((RwReal *)v27 + 1);
          v45.x = *(RwReal *)&v40[i];
          normalb.x = -1.0;
          *(_QWORD *)&normalb.y = 0LL;
          v45.z = *(RwReal *)&v40[i + 8];
          cBuoyancy::AddSplashParticles(*((cBuoyancy **)v27 + 4), pPhysical, v45, *((CVector *)v27 + 1), normalb, 0);
        }
      }
    }
    v31 = *((float *)v27 + 20);
    if ( v31 > v18 )
    {
      v32 = this->MaxLimits.z;
      if ( v31 < v32 )
      {
        v33 = *((float *)v27 + 23);
        if ( v33 > v18 && v33 < v32 )
        {
          v46 = *(CVector *)(v27 + 6);
          normalc.x = 1.0;
          *(_QWORD *)&normalc.y = 0LL;
          cBuoyancy::AddSplashParticles((cBuoyancy *)LODWORD(v46.z), pPhysical, v46, *((CVector *)v27 + 7), normalc, 0);
        }
      }
    }
  }
}
// 57033E: variable 'v11' is possibly undefined

//----- (0057054C) --------------------------------------------------------
bool __fastcall cBuoyancy::CalcBuoyancyForce(
        cBuoyancy *this,
        CPhysical *pPhysical,
        CVector *pCentreOfBuoyancy,
        CVector *pBuoyancyForce)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d2
  bool v10; // r6
  __int64 v11; // d16
  float v12; // s2
  CVector v14; // [sp+0h] [bp-28h] BYREF

  v10 = 0;
  if ( this->bBuoyancyCalcValid )
  {
    Multiply3x3(&v14, &this->mat, &this->CentreOfBuoyancy);
    v11 = *(_QWORD *)&v14.x;
    pCentreOfBuoyancy->z = v14.z;
    *(_QWORD *)&pCentreOfBuoyancy->x = v11;
    pBuoyancyForce->x = 0.0;
    pBuoyancyForce->y = 0.0;
    v10 = 1;
    v4.n64_f32[0] = (float)(this->VolumeUnderWater * this->BuoyancyConstant) * CTimer::ms_fTimeStep;
    LODWORD(pBuoyancyForce->z) = v4.n64_u32[0];
    v12 = pPhysical->m_vecMoveSpeed.z * pPhysical->m_fMass;
    if ( v12 > (float)(v4.n64_f32[0] * 4.0) )
    {
      v5.n64_u32[0] = 0;
      v4.n64_f32[0] = v4.n64_f32[0] - v12;
      LODWORD(pBuoyancyForce->z) = vmax_f32(v4, v5).n64_u32[0];
    }
  }
  return v10;
}
// 5705CA: variable 'v4' is possibly undefined
// 5705CA: variable 'v5' is possibly undefined

//----- (005705E4) --------------------------------------------------------
void __fastcall cBuoyancy::FindWaterLevel(
        cBuoyancy *this,
        const CVector *ShipPos,
        CVector *pWaterLevelLocation,
        tWaterLevel *pWaterLevelStatus)
{
  RwReal v8; // s2
  float v9; // s2
  float z; // s0
  tWaterLevel v11; // r0
  CVector v12; // [sp+Ch] [bp-24h] BYREF

  *pWaterLevelStatus = IN_WATER;
  Multiply3x3(&v12, &this->mat, pWaterLevelLocation);
  v8 = this->Pos.y + v12.y;
  v12.x = this->Pos.x + v12.x;
  v12.y = v8;
  CWaterLevel::GetWaterLevel(v12.x, v8, this->Pos.z, &pWaterLevelLocation->z, 1, 0);
  v9 = pWaterLevelLocation->z - (float)(v12.z + ShipPos->z);
  pWaterLevelLocation->z = v9;
  z = this->MaxLimits.z;
  if ( v9 <= z )
  {
    z = this->MinLimits.z;
    if ( v9 >= z )
      return;
    v11 = HIGH_N_DRY;
  }
  else
  {
    v11 = SUBMERGED;
  }
  pWaterLevelLocation->z = z;
  *pWaterLevelStatus = v11;
}

//----- (0057068A) --------------------------------------------------------
void __fastcall cBuoyancy::FindWaterLevelNorm(
        cBuoyancy *this,
        const CVector *ShipPos,
        CVector *pWaterLevelLocation,
        tWaterLevel *pWaterLevelStatus,
        CVector *pVecNormal)
{
  RwReal v9; // s2
  float v10; // s2
  float z; // s0
  tWaterLevel v12; // r0
  CVector v13; // [sp+Ch] [bp-24h] BYREF

  *pWaterLevelStatus = IN_WATER;
  Multiply3x3(&v13, &this->mat, pWaterLevelLocation);
  v9 = this->Pos.y + v13.y;
  v13.x = this->Pos.x + v13.x;
  v13.y = v9;
  CWaterLevel::GetWaterLevel(v13.x, v9, this->Pos.z, &pWaterLevelLocation->z, 1, pVecNormal);
  v10 = pWaterLevelLocation->z - (float)(v13.z + ShipPos->z);
  pWaterLevelLocation->z = v10;
  z = this->MaxLimits.z;
  if ( v10 <= z )
  {
    z = this->MinLimits.z;
    if ( v10 >= z )
      return;
    v12 = HIGH_N_DRY;
  }
  else
  {
    v12 = SUBMERGED;
  }
  pWaterLevelLocation->z = z;
  *pWaterLevelStatus = v12;
}

//----- (00570730) --------------------------------------------------------
float __fastcall cBuoyancy::SimpleSumBuoyancyData(
        cBuoyancy *this,
        CVector *WaterLevelLocation,
        tWaterLevel WaterLevelStatus)
{
  char v5; // r0
  float z; // s4
  float v7; // s0
  float result; // r0
  float zsc; // s6
  float v10; // s4
  float v11; // s6
  float v12; // s8
  float count; // s10
  float v14; // s14
  float v15; // s3
  float y; // s1
  float v17; // s12

  v5 = `guard variable for'cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel;
  __dmb(0xBu);
  if ( (v5 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel);
  }
  z = this->MinLimits.z;
  v7 = fabsf(WaterLevelLocation->z - z) - (float)(1.0 - fVolMultiplier);
  cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::fThisVolume = v7;
  if ( v7 < 0.0 )
    return 0.0;
  if ( this->bIsBoat )
  {
    v7 = (float)(v7 * fVolMultiplier) * (float)(v7 * fVolMultiplier);
    cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::fThisVolume = v7;
  }
  zsc = this->zsc;
  this->VolumeUnderWater = v7 + this->VolumeUnderWater;
  v10 = zsc * (float)((float)(WaterLevelLocation->z + z) * 0.5);
  cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel.z = v10;
  v11 = WaterLevelLocation->x * this->xsc;
  cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel.x = v11;
  v12 = WaterLevelLocation->y * this->ysc;
  cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel.y = v12;
  if ( this->bUpsideDown )
  {
    v12 = -v12;
    v11 = -v11;
    v10 = -v10;
    cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel.x = v11;
    cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel.y = v12;
    cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel.z = v10;
  }
  count = this->count;
  v14 = 1.0 - (float)(1.0 / count);
  cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::fFraction = 1.0 / count;
  cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::fRemainingSlice = v14;
  v15 = this->CentreOfBuoyancy.z;
  y = this->CentreOfBuoyancy.y;
  v17 = v14 * this->CentreOfBuoyancy.x;
  this->count = count + 1.0;
  this->bBuoyancyCalcValid = 1;
  result = v7;
  this->CentreOfBuoyancy.x = v17 + (float)((float)((float)(1.0 / count) * v11) * v7);
  this->CentreOfBuoyancy.y = (float)(v14 * y) + (float)((float)((float)(1.0 / count) * v12) * v7);
  this->CentreOfBuoyancy.z = (float)(v14 * v15) + (float)((float)((float)(1.0 / count) * v10) * v7);
  return result;
}
// A065E4: using guessed type char `guard variable for'cBuoyancy::SimpleSumBuoyancyData(CVector &,tWaterLevel)::AverageOfWaterLevel;

//----- (005708C4) --------------------------------------------------------
bool __fastcall cBuoyancy::ProcessBuoyancyBoat(
        cBuoyancy *this,
        CVehicle *pVehicle,
        float fBouyConst,
        CVector *pCentreOfBuoyancy,
        CVector *pBuoyancyForce,
        int bCollidingWithMap)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d12
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  _BOOL4 bBuoyancyCalcValid; // r11
  CVector *p_v; // r8
  float x; // s16
  float v17; // s18
  int v18; // r0
  int v19; // r10
  float y; // s28
  RwReal v21; // s2
  float v22; // s2
  float z; // s0
  int v24; // r0
  float (*v25)[3]; // r2
  const CVector *v26; // r6
  float v27; // r8
  float BuoyancyConstant; // s21
  float v29; // s23
  float v30; // s6
  float v31; // s30
  float v32; // s17
  float v33; // s19
  float v34; // s21
  __int64 v35; // d16
  int v37; // [sp+14h] [bp-CCh]
  int v38; // [sp+34h] [bp-ACh]
  const CMatrix *m; // [sp+38h] [bp-A8h]
  CVector v40; // [sp+3Ch] [bp-A4h] BYREF
  CVector v41; // [sp+48h] [bp-98h] BYREF
  CVector pNormal; // [sp+58h] [bp-88h] BYREF
  CVector v; // [sp+64h] [bp-7Ch] BYREF
  CVector vecOffset; // [sp+70h] [bp-70h] BYREF
  CVector v45; // 0:r1.12

  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  bBuoyancyCalcValid = 0;
  if ( CWaterLevel::GetWaterLevel(
         p_tx->m_translate.x,
         p_tx->m_translate.y,
         p_tx->m_translate.z,
         &this->fWaterLevel,
         (*(_DWORD *)&pVehicle->m_nPhysicalFlags >> 27) & 1,
         0) == 1 )
  {
    m = &this->mat;
    CMatrix::operator=(&this->mat, pVehicle->m_pMat);
    cBuoyancy::PreCalcSetup(this, pVehicle, fBouyConst);
    p_v = &v;
    x = this->MinLimits.x;
    v7.n64_u32[0] = 0;
    v17 = 1.0 / (float)((float)(this->MaxLimits.z - this->MinLimits.z) * 9.0);
    v38 = 0;
    v18 = 0;
LABEL_5:
    v37 = v18;
    v19 = 0;
    y = this->MinLimits.y;
    while ( 2 )
    {
      v.z = 0.0;
      v.y = y;
      pNormal.z = 1.0;
      v.x = x;
      pNormal.x = 0.0;
      pNormal.y = 0.0;
      Multiply3x3(&vecOffset, m, p_v);
      v21 = this->Pos.y + vecOffset.y;
      vecOffset.x = this->Pos.x + vecOffset.x;
      vecOffset.y = v21;
      CWaterLevel::GetWaterLevel(vecOffset.x, v21, this->Pos.z, &v.z, 1, &pNormal);
      v22 = v.z - (float)(vecOffset.z + this->ShipPos.z);
      v.z = v22;
      z = this->MaxLimits.z;
      if ( v22 <= z )
      {
        z = this->MinLimits.z;
        if ( v22 >= z )
        {
          v24 = 1;
LABEL_12:
          pNormal.x = (float)(pNormal.x + 0.0) * 0.33333;
          pNormal.y = (float)(pNormal.y + 0.0) * 0.33333;
          pNormal.z = (float)(pNormal.z + 2.0) * 0.33333;
          v25 = fBoatVolumeDistributionDinghy;
          switch ( pVehicle->m_nModelIndex )
          {
            case 0x1BE:
            case 0x1C4:
            case 0x1ED:
              goto LABEL_13;
            case 0x1BF:
            case 0x1C0:
            case 0x1C1:
            case 0x1C2:
            case 0x1C3:
            case 0x1C5:
            case 0x1C6:
            case 0x1C7:
            case 0x1C8:
            case 0x1C9:
            case 0x1CA:
            case 0x1CB:
            case 0x1CC:
            case 0x1CD:
            case 0x1CE:
            case 0x1CF:
            case 0x1D0:
            case 0x1D1:
            case 0x1D2:
            case 0x1D3:
            case 0x1D4:
            case 0x1D5:
            case 0x1D6:
            case 0x1D7:
            case 0x1DA:
            case 0x1DB:
            case 0x1DC:
            case 0x1DD:
            case 0x1DE:
            case 0x1DF:
            case 0x1E0:
            case 0x1E1:
            case 0x1E2:
            case 0x1E3:
            case 0x1E5:
            case 0x1E6:
            case 0x1E7:
            case 0x1E8:
            case 0x1E9:
            case 0x1EA:
            case 0x1EB:
            case 0x1EC:
              goto LABEL_15;
            case 0x1D8:
            case 0x1D9:
              goto LABEL_17;
            case 0x1E4:
              v25 = fBoatVolumeDistributionSail;
              goto LABEL_17;
            default:
              if ( fBoatVolumeDistributionDinghy == (float (*)[3])((char *)&elf_hash_bucket[85] + 3) )
LABEL_13:
                v25 = fBoatVolumeDistributionSpeed;
              else
LABEL_15:
                v25 = fBoatVolumeDistribution;
LABEL_17:
              fVolMultiplier = (*v25)[v38 + v19];
              if ( v24 )
              {
                v26 = p_v;
                v27 = cBuoyancy::SimpleSumBuoyancyData(this, p_v, (tWaterLevel)&fVolMultiplier);
                BuoyancyConstant = this->BuoyancyConstant;
                vecOffset.y = y;
                vecOffset.x = x;
                vecOffset.z = 0.0;
                v29 = CTimer::ms_fTimeStep;
                Multiply3x3(&v41, pVehicle->m_pMat, &vecOffset);
                vecOffset = v41;
                CPhysical::GetSpeed(&v41, pVehicle, v41);
                v30 = v27;
                p_v = (CVector *)v26;
                vecOffset = v41;
                v31 = pNormal.x;
                v32 = pNormal.y;
                v33 = pNormal.z;
                v6.n64_f32[0] = 1.0
                              - (float)(pVehicle->pHandling->fSuspensionDamping
                                      * (float)((float)((float)(v41.x * pNormal.x) + (float)(v41.y * pNormal.y))
                                              + (float)(v41.z * pNormal.z)));
                v6.n64_u64[0] = vmax_f32(v6, v7).n64_u64[0];
                v34 = (float)((float)((float)(v17 * v30) * BuoyancyConstant) * v29) * v6.n64_f32[0];
                pBuoyancyForce->z = pBuoyancyForce->z + v34;
                if ( !bCollidingWithMap )
                {
                  Multiply3x3(&v40, m, v26);
                  v45.x = v34 * v31;
                  v45.y = v34 * v32;
                  v45.z = v34 * v33;
                  CPhysical::ApplyTurnForce(pVehicle, v45, v40);
                }
              }
              v19 += 3;
              y = y + this->ystep;
              if ( v19 != 9 )
                continue;
              x = x + this->xstep;
              ++v38;
              v18 = v37 + 1;
              if ( v37 != 2 )
                goto LABEL_5;
              this->VolumeUnderWater = v17 * this->VolumeUnderWater;
              Multiply3x3(&vecOffset, m, &this->CentreOfBuoyancy);
              v35 = *(_QWORD *)&vecOffset.x;
              pCentreOfBuoyancy->z = vecOffset.z;
              *(_QWORD *)&pCentreOfBuoyancy->x = v35;
              if ( this->bIsBoat )
              {
                bBuoyancyCalcValid = 1;
              }
              else
              {
                bBuoyancyCalcValid = this->bBuoyancyCalcValid;
                if ( this->bBuoyancyCalcValid )
                  bBuoyancyCalcValid = 1;
              }
              break;
          }
          return bBuoyancyCalcValid;
        }
        v24 = 0;
      }
      else
      {
        v24 = 2;
      }
      break;
    }
    v.z = z;
    goto LABEL_12;
  }
  return bBuoyancyCalcValid;
}
// 570B74: variable 'v6' is possibly undefined
// 570B74: variable 'v7' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00570C58) --------------------------------------------------------
void __fastcall cBuoyancy::~cBuoyancy(cBuoyancy *this)
{
  CMatrix::~CMatrix(&this->mat);
}

//----- (00570C70) --------------------------------------------------------
int __fastcall cHandlingDataMgr::FindExactWord(
        cHandlingDataMgr *this,
        unsigned __int8 *szLine,
        unsigned __int8 *szArray,
        int nWidth,
        int a5)
{
  int v5; // r9
  int v8; // r4
  int v9; // r8
  size_t v10; // r5
  int v11; // r0
  char v14[20]; // [sp+4h] [bp-34h] BYREF

  v5 = a5;
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = strlen((const char *)szArray);
    strncpy(v14, (const char *)szArray, v10);
    v11 = strncmp((const char *)szLine, v14, v10);
    v8 |= v11 == 0;
    if ( (v8 & 1) == 0 )
      szArray += nWidth;
    v9 += v11 != 0;
  }
  while ( v9 < a5 && !(v8 << 31) );
  if ( v8 << 31 )
    return v9;
  return v5;
}

//----- (00570D04) --------------------------------------------------------
void __fastcall cHandlingDataMgr::cHandlingDataMgr(cHandlingDataMgr *this)
{
  int i; // r5

  for ( i = 64; i != 47104; i += 224 )
    cTransmission::cTransmission((cTransmission *)((char *)this + i));
  memset(this, 0, sizeof(cHandlingDataMgr));
}

//----- (00570D28) --------------------------------------------------------
int32 __fastcall cHandlingDataMgr::GetHandlingId(cHandlingDataMgr *this, const unsigned __int8 *pName)
{
  int v3; // r6
  const char *v4; // r5

  v3 = -1;
  v4 = (const char *)VehicleNames;
  do
  {
    if ( !strncmp((const char *)pName, v4, 0xEu) )
      break;
    ++v3;
    v4 += 14;
  }
  while ( v3 < 209 );
  return v3 + 1;
}

//----- (00570D5C) --------------------------------------------------------
void __fastcall cHandlingDataMgr::ConvertDataToWorldUnits(cHandlingDataMgr *this, tHandlingData *pHand)
{
  float v2; // s10
  float v3; // s4
  float fBrakeDeceleration; // s8
  float v5; // s2

  v2 = 0.5;
  v3 = pHand->Transmission.m_fEngineAcceleration / 0.0004;
  fBrakeDeceleration = pHand->fBrakeDeceleration;
  v5 = pHand->fCollisionDamageMultiplier * pHand->fMass;
  if ( pHand->Transmission.m_nDriveType == 52 )
    v2 = 0.25;
  pHand->Transmission.m_fMaxVelocity = pHand->Transmission.m_fMaxVelocity / 0.0055556;
  pHand->fBrakeDeceleration = fBrakeDeceleration / 0.0004;
  pHand->fCollisionDamageMultiplier = v5 / 2000.0;
  pHand->Transmission.m_fEngineAcceleration = v3 / v2;
}

//----- (00570DC8) --------------------------------------------------------
void __fastcall cHandlingDataMgr::ConvertDataToGameUnits(cHandlingDataMgr *this, tHandlingData *pHand)
{
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float fMass; // s2
  float v5; // s12
  float v6; // s8
  float v7; // s10
  float v8; // s0
  float32x2_t v9; // d1
  float v10; // s6
  float fDragCoeff; // s8
  float v12; // s12
  float v13; // s4
  unsigned __int32 v14; // r2
  float v15; // s2
  float v16; // s2

  fMass = pHand->fMass;
  v9.n64_u32[1] = LODWORD(pHand->fBrakeDeceleration);
  v5 = 1.0 / fMass;
  v6 = (float)(pHand->fCollisionDamageMultiplier * 2000.0) / fMass;
  v7 = (float)((float)(fMass * 0.008) * 100.0) / (float)pHand->nPercentSubmerged;
  v8 = pHand->Transmission.m_fEngineAcceleration * 0.0004;
  v9.n64_f32[0] = pHand->Transmission.m_fMaxVelocity * 0.0055556;
  pHand->Transmission.m_fEngineAcceleration = v8;
  pHand->Transmission.m_fMaxVelocity = v9.n64_f32[0];
  pHand->fBrakeDeceleration = v9.n64_f32[1] * 0.0004;
  v10 = v9.n64_f32[0];
  pHand->fOneOverMass = v5;
  pHand->fCollisionDamageMultiplier = v6;
  pHand->fBuoyancyConstant = v7;
  if ( v9.n64_f32[0] > 0.0 )
  {
    fDragCoeff = pHand->fDragCoeff;
    v10 = v9.n64_f32[0];
    do
    {
      v10 = v10 + -0.01;
      if ( fDragCoeff >= 0.01 )
        v9.n64_f32[1] = (float)(v10 * v10) * (float)((float)(fDragCoeff * 0.5) / 1000.0);
      else
        v9.n64_f32[1] = -(float)((float)((float)(1.0 / (float)((float)((float)(fDragCoeff * v10) * v10) + 1.0)) + -1.0)
                               * v10);
      v12 = v8 * 0.166666667;
    }
    while ( v9.n64_f32[1] > v12 );
  }
  if ( pHand->nVehicleID == VT_RCBANDIT )
  {
    v13 = -v9.n64_f32[0];
    LODWORD(pHand->Transmission.m_fMaxFlatVelocity) = v9.n64_u32[0];
  }
  else if ( HIBYTE(pHand->hFlags) << 31 )
  {
    v3.n64_u32[0] = -1102263091;
    v15 = v9.n64_f32[0] / 1.2;
    pHand->Transmission.m_fMaxFlatVelocity = v15;
    v2.n64_f32[0] = v15 * -0.25;
    LODWORD(v13) = vmin_f32(v2, v3).n64_u32[0];
  }
  else
  {
    v14 = pHand->nVehicleID - 162;
    pHand->Transmission.m_fMaxVelocity = v10 * 1.2;
    pHand->Transmission.m_fMaxFlatVelocity = v10;
    if ( v14 >= 0xD )
    {
      v2.n64_u32[0] = -1102263091;
      v9.n64_f32[0] = v10 * -0.3;
      LODWORD(v13) = vmin_f32(v9, v2).n64_u32[0];
    }
    else
    {
      v13 = -0.05;
    }
  }
  v16 = 0.5;
  if ( pHand->Transmission.m_nDriveType == 52 )
    v16 = 0.25;
  pHand->Transmission.m_fMaxReverseVelocity = v13;
  pHand->Transmission.m_fEngineAcceleration = v8 * v16;
  sub_19F444(&pHand->Transmission);
}
// 570F1A: variable 'v2' is possibly undefined
// 570F1A: variable 'v3' is possibly undefined

//----- (00570F94) --------------------------------------------------------
void __fastcall cHandlingDataMgr::ConvertBikeDataToWorldUnits(cHandlingDataMgr *this, tBikeHandlingData *pBikeHand)
{
  float v3; // s0
  float fWheelieBalancePoint; // r0
  float v5; // s2
  float v6; // s0
  float fStoppieBalancePoint; // r0

  v3 = asinf(pBikeHand->fMaxBankAngle) * 180.0;
  fWheelieBalancePoint = pBikeHand->fWheelieBalancePoint;
  v5 = (float)(pBikeHand->fFullAnimAngle * 180.0) / 3.1416;
  pBikeHand->fMaxBankAngle = v3 / 3.1416;
  pBikeHand->fFullAnimAngle = v5;
  v6 = asinf(fWheelieBalancePoint);
  fStoppieBalancePoint = pBikeHand->fStoppieBalancePoint;
  pBikeHand->fWheelieBalancePoint = (float)(v6 * 180.0) / 3.1416;
  pBikeHand->fStoppieBalancePoint = (float)(asinf(fStoppieBalancePoint) * 180.0) / 3.1416;
}

//----- (00571008) --------------------------------------------------------
void __fastcall cHandlingDataMgr::ConvertBikeDataToGameUnits(cHandlingDataMgr *this, tBikeHandlingData *pBikeHand)
{
  float v3; // s4
  float v4; // s6
  float v5; // r0

  v3 = (float)(pBikeHand->fWheelieBalancePoint * 3.1416) / 180.0;
  v4 = (float)(pBikeHand->fStoppieBalancePoint * 3.1416) / 180.0;
  v5 = (float)(pBikeHand->fMaxBankAngle * 3.1416) / 180.0;
  pBikeHand->fFullAnimAngle = (float)(pBikeHand->fFullAnimAngle * 3.1416) / 180.0;
  pBikeHand->fMaxBankAngle = sinf(v5);
  pBikeHand->fWheelieBalancePoint = sinf(v3);
  pBikeHand->fStoppieBalancePoint = sinf(v4);
}

//----- (00571080) --------------------------------------------------------
tFlyingHandlingData *__fastcall cHandlingDataMgr::GetFlyingPointer(cHandlingDataMgr *this, uint8 plane)
{
  int v2; // r3

  v2 = 0;
  if ( (unsigned __int8)(plane + 70) < 0x18u )
    v2 = plane - 186;
  return &this->m_aFlyingHandlingData[v2];
}

//----- (0057109E) --------------------------------------------------------
tBoatHandlingData *__fastcall cHandlingDataMgr::GetBoatPointer(cHandlingDataMgr *this, uint8 boat)
{
  int v2; // r3

  v2 = 0;
  if ( (unsigned __int8)(boat + 81) < 0xCu )
    v2 = boat - 175;
  return &this->m_aBoatHandlingData[v2];
}

//----- (005710C0) --------------------------------------------------------
void __fastcall CHeli::CHeli(CHeli *this, int nModelIndex, UInt8 CreatedBy)
{
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  CHeli::CHeliFlags m_nHeliFlags; // r3
  int v7; // r1
  UInt32 v8; // r0

  CAutomobile::CAutomobile(this, nModelIndex, CreatedBy, 1u);
  this->m_vehicleType = 3;
  this->m_LightBrightness = 0.0;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  m_nHeliFlags = this->m_nHeliFlags;
  *(_QWORD *)&this->m_LowestFlightHeight = 0x4120000041200000LL;
  *(_QWORD *)&this->m_MinHeightAboveTerrain = 1092616192LL;
  *(_QWORD *)&this->m_fYawControl = 0LL;
  *(_QWORD *)&this->m_fRollControl = 0LL;
  *(_QWORD *)&this->m_fThrottleControl = 0LL;
  *(_QWORD *)&this->m_fMainRotorAngle = 0LL;
  this->m_nHeliFlags = (CHeli::CHeliFlags)(*(_BYTE *)&m_nHeliFlags & 0xFC);
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x1000000);
  this->_vptr$CPlaceable = (int (**)(void))&off_66DB34;
  if ( nModelIndex == 425 )
  {
    CDamageManager::SetDoorStatus(&this->Damage, FRONT_LEFT_DOOR_0, 0);
    this->Door[2].m_fOpenAngle = 0.94248;
    this->Door[2].m_fClosedAngle = 0.0;
    this->Door[2].m_nAxis = 1;
    this->Door[2].m_nDirn = 19;
  }
  *(_DWORD *)this->m_SwatRopeActive = 0;
  this->m_nSwatOnBoard = 4;
  v7 = *((_DWORD *)&this->m_nVehicleFlags + 1) | 0x40;
  v8 = CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)&this->m_OldSearchLightY[2] = 0LL;
  *(_QWORD *)&this->m_OldSearchLightY[4] = 0LL;
  *(_QWORD *)&this->m_OldSearchLightX[4] = 0LL;
  *(_QWORD *)this->m_OldSearchLightY = 0LL;
  *(_QWORD *)this->m_OldSearchLightX = 0LL;
  *(_QWORD *)&this->m_OldSearchLightX[2] = 0LL;
  this->m_LastSearchLightSample = v8;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v7;
  this->AutoPilot.TargetReachedDist = 10;
  this->m_FiringRateMultiplier = 16;
  this->m_LastTimeSearchLightWasTooFarAwayToShoot = 0;
  this->m_nNextTalkTimer = v8;
  this->m_GunflashFxPtrs = 0;
  this->m_bStopFlyingForAWhile = 0;
  this->m_bSearchLightOn = 0;
  this->m_crashAndBurnTurnSpeed = (float)((float)((float)rand() * 4.6566e-10) * 6.0) + 2.0;
}
// 66DB34: using guessed type void *;

//----- (0057120C) --------------------------------------------------------
void __fastcall CHeli::~CHeli(CHeli *this)
{
  FxSystem_c **m_GunflashFxPtrs; // r1
  int PlaneNumGuns; // r1
  FxSystem_c **v4; // r0
  int i; // r6
  FxSystem_c *v6; // r0
  int v7; // r1

  m_GunflashFxPtrs = this->m_GunflashFxPtrs;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DB34;
  if ( m_GunflashFxPtrs )
  {
    PlaneNumGuns = CVehicle::GetPlaneNumGuns(this);
    v4 = this->m_GunflashFxPtrs;
    if ( PlaneNumGuns >= 1 )
    {
      for ( i = 0; i < v7; ++i )
      {
        v6 = v4[i];
        if ( v6 )
        {
          FxSystem_c::Kill(v6);
          FxManager_c::DestroyFxSystem(&g_fxMan, this->m_GunflashFxPtrs[i]);
        }
        v7 = CVehicle::GetPlaneNumGuns(this);
        v4 = this->m_GunflashFxPtrs;
      }
    }
    if ( v4 )
      operator delete[](v4);
    this->m_GunflashFxPtrs = 0;
  }
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  sub_19E450(this);
}
// 66DB34: using guessed type void *off_66DB34;

//----- (00571298) --------------------------------------------------------
void __fastcall CHeli::~CHeli(CHeli *this)
{
  void *v1; // r0

  CHeli::~CHeli(this);
  sub_199F98(v1);
}
// 5712A4: variable 'v1' is possibly undefined

//----- (005712A8) --------------------------------------------------------
void __fastcall CHeli::ProcessControl(CHeli *this)
{
  CHeli *v1; // r11
  FxSystem_c *m_fxSysHeliDust; // r0
  CPed *pDriver; // r0
  int32 m_nPedType; // r0
  CPad *Pad; // r0
  Int8 *p_Mission; // r4
  UInt8 *m_SwatRopeActive; // r8
  RwReal *v8; // r5
  RwReal *v9; // r11
  RwReal *v10; // r10
  RwReal *v11; // r6
  unsigned int v12; // r9
  RwReal v13; // s0
  RwReal v14; // s2
  RwReal v15; // s4
  u_native v16; // r4
  const CMatrix *v17; // r1
  RwReal v18; // s0
  RwReal v19; // s2
  int v20; // s4
  const CMatrix *v21; // r1
  float v22; // s16
  float v23; // s0
  int Mission; // r0
  CEntity *PlayerEntity; // r10
  int m_bSearchLightOn; // r0
  int v27; // r1
  _BOOL4 v28; // r3
  int v29; // r0
  CMatrix *m_pMat; // r0
  float *p_z; // r2
  CSimpleTransform *p_tx; // r1
  __int64 v33; // d16
  RwReal z; // r0
  float *p_m_heading; // r1
  float *p_xx; // r5
  float *p_x; // r6
  float m_heading; // r9
  float v39; // r8
  float v40; // s2
  float v41; // s4
  float v42; // s0
  float v43; // s6
  float v44; // s0
  float v45; // s4
  float v46; // s2
  float v47; // s6
  float v48; // s10
  float v49; // s8
  UInt32 m_LastSearchLightSample; // r3
  uint32 v51; // r8
  int v52; // r5
  CHeli *v53; // r4
  float v54; // s0
  UInt32 v55; // r2
  float v56; // s2
  float *v57; // r1
  float *v58; // r3
  float v59; // r11
  float v60; // r6
  float v61; // r0
  UInt32 v62; // r10
  float v63; // r8
  float v64; // r9
  float v65; // lr
  float v66; // r12
  float v67; // s4
  int v68; // r1
  float v69; // s0
  float v70; // s2
  UInt32 v71; // r4
  float v72; // r3
  float v73; // s4
  float v74; // s6
  float v75; // s10
  float v76; // s12
  float v77; // s8
  CMatrix *v78; // r0
  float v79; // s0
  float v80; // s2
  float v81; // s4
  float v82; // s0
  float v83; // s6
  float v84; // s2
  float v85; // s0
  float *v86; // r1
  float v87; // s4
  unsigned __int32 v88; // r0
  unsigned int v89; // r8
  char v90; // r5
  CPlayerPed *PlayerPed; // r6
  int v92; // r0
  int v93; // r9
  uint32 v94; // r0
  const CMatrix *v95; // r1
  uint32 m_LastTimeSearchLightWasTooFarAwayToShoot; // r0
  uint32 v97; // r1
  _BOOL4 IsLineOfSightClear; // r0
  uint32 v99; // r0
  bool v100; // cc
  unsigned __int8 v101; // r5
  float x; // s16
  unsigned __int8 v103; // r6
  float y; // s18
  int v105; // r0
  int v106; // r1
  float *m_OldSearchLightY; // [sp+18h] [bp-B8h]
  float *v108; // [sp+20h] [bp-B0h]
  float *m_OldSearchLightX; // [sp+24h] [bp-ACh]
  float *v110; // [sp+28h] [bp-A8h]
  CEntity *v111; // [sp+2Ch] [bp-A4h]
  Int8 *v112; // [sp+30h] [bp-A0h]
  int v113; // [sp+3Ch] [bp-94h]
  CVehicle *v114; // [sp+40h] [bp-90h]
  CVector v115; // [sp+44h] [bp-8Ch] BYREF
  CVector pStartCoors; // [sp+50h] [bp-80h] BYREF
  CVector v117; // [sp+5Ch] [bp-74h] BYREF
  CVector pEndCoors; // [sp+68h] [bp-68h] BYREF
  CVector vecStart; // [sp+78h] [bp-58h] BYREF
  CVector v; // [sp+88h] [bp-48h] BYREF
  CVector v121; // 0:r1.12

  v1 = this;
  CAutomobile::ProcessControl(this);
  if ( (*(_BYTE *)&v1->m_nVehicleFlags & 0x10) == 0 )
  {
    m_fxSysHeliDust = v1->m_fxSysHeliDust;
    if ( m_fxSysHeliDust )
    {
      FxSystem_c::Kill(m_fxSysHeliDust);
      v1->m_heliDustRatio = 0.0;
      v1->m_fxSysHeliDust = 0;
    }
  }
  pDriver = v1->pDriver;
  if ( pDriver )
  {
    m_nPedType = pDriver->m_nPedType;
    if ( m_nPedType != 1 )
      m_nPedType = 0;
  }
  else
  {
    m_nPedType = 0;
  }
  Pad = CPad::GetPad(m_nPedType);
  if ( ((*(_BYTE *)&v1->m_info >> 3) | 8) == 8 && CPad::HornJustDown(Pad) )
    v1->m_bSearchLightOn = v1->m_bSearchLightOn == 0;
  v114 = v1;
  if ( (*((_BYTE *)&v1->m_nPhysicalFlags + 3) & 0x20) != 0 || CCullZones::PlayerNoRain() )
  {
    p_Mission = &v1->AutoPilot.Mission;
    v113 = 0;
    v1->m_LightBrightness = 0.0;
    goto LABEL_15;
  }
  Mission = (unsigned __int8)v1->AutoPilot.Mission;
  p_Mission = &v1->AutoPilot.Mission;
  if ( Mission == 40 )
  {
    if ( !FindPlayerVehicle(-1, 0)
      || FindPlayerVehicle(-1, 0)->m_vehicleType != 3 && FindPlayerVehicle(-1, 0)->m_vehicleType != 4 )
    {
      PlayerEntity = FindPlayerEntity(-1);
      v27 = 1;
      m_bSearchLightOn = 1;
      goto LABEL_50;
    }
    Mission = (unsigned __int8)*p_Mission;
  }
  if ( Mission == 39 && (PlayerEntity = v1->AutoPilot.pTargetEntity) != 0 && (*(_BYTE *)&v1->m_nHeliFlags & 2) != 0 )
  {
    m_bSearchLightOn = 1;
  }
  else
  {
    if ( *(_BYTE *)&v1->m_info > 7u || v1->m_nModelIndex != 497 )
    {
      PlayerEntity = 0;
      v27 = 0;
      m_bSearchLightOn = 0;
      goto LABEL_50;
    }
    m_bSearchLightOn = v1->m_bSearchLightOn;
    PlayerEntity = 0;
    if ( v1->m_bSearchLightOn )
      m_bSearchLightOn = 1;
  }
  v27 = 0;
LABEL_50:
  v28 = (*(_DWORD *)&v1->m_nPhysicalFlags & 0x100) == 0;
  v29 = m_bSearchLightOn & v28;
  v1->m_bSearchLightOn = v29;
  v113 = v27 & v28;
  if ( v29 )
  {
    if ( PlayerEntity )
    {
      m_pMat = PlayerEntity->m_pMat;
      p_z = &PlayerEntity[1].m_transform.m_translate.z;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &PlayerEntity->m_transform;
      v33 = *(_QWORD *)&p_tx->m_translate.x;
      z = p_tx->m_translate.z;
      p_m_heading = &PlayerEntity[1].m_transform.m_heading;
      v.z = z;
      *(_QWORD *)&v.x = v33;
    }
    else
    {
      p_xx = &v1->m_pMat->xx;
      p_x = p_xx + 12;
      if ( p_xx )
      {
        v42 = p_xx[4];
        v40 = p_xx[5];
        v41 = p_xx[6];
      }
      else
      {
        p_x = &v1->m_transform.m_translate.x;
        m_heading = v1->m_transform.m_heading;
        v39 = sinf(m_heading);
        v40 = cosf(m_heading);
        v41 = 0.0;
        LODWORD(v42) = LODWORD(v39) ^ 0x80000000;
      }
      v43 = v42 * 10.0;
      v44 = (float)(v41 * 10.0) + p_x[2];
      v45 = (float)(v40 * 10.0) + p_x[1];
      v46 = v43 + *p_x;
      if ( p_xx )
      {
        v47 = p_xx[8];
        v48 = p_xx[9];
        v49 = p_xx[10];
      }
      else
      {
        v47 = 0.0;
        v49 = 1.0;
        v48 = 0.0;
      }
      p_m_heading = &v1->m_vecMoveSpeed.y;
      p_z = &v1->m_vecMoveSpeed.x;
      v.y = v45 - (float)(v48 * 30.0);
      v.x = v46 - (float)(v47 * 30.0);
      v.z = v44 - (float)(v49 * 30.0);
    }
    m_LastSearchLightSample = v1->m_LastSearchLightSample;
    v51 = CTimer::m_snTimeInMilliseconds;
    v52 = CTimer::m_snTimeInMilliseconds - m_LastSearchLightSample;
    if ( (int)(CTimer::m_snTimeInMilliseconds - m_LastSearchLightSample) <= 1000 )
    {
      v75 = v1->m_OldSearchLightY[2];
      v76 = v1->m_OldSearchLightX[2];
      v73 = v1->m_OldSearchLightY[1];
      v74 = v1->m_OldSearchLightX[1];
    }
    else
    {
      v111 = PlayerEntity;
      v112 = &v1->AutoPilot.Mission;
      v53 = v1;
      v54 = *p_z;
      v55 = m_LastSearchLightSample + 1000;
      v56 = *p_m_heading;
      v57 = &v1->m_OldSearchLightX[1];
      v58 = &v1->m_OldSearchLightY[1];
      v59 = v1->m_OldSearchLightX[0];
      v60 = v53->m_OldSearchLightX[1];
      v61 = v53->m_OldSearchLightX[2];
      v62 = LODWORD(v53->m_OldSearchLightX[3]);
      v63 = v53->m_OldSearchLightY[0];
      v64 = v53->m_OldSearchLightY[1];
      v65 = v53->m_OldSearchLightY[2];
      v66 = v53->m_OldSearchLightY[3];
      v67 = (float)(v54 * 50.0) + (float)(v54 * 50.0);
      v108 = v57;
      m_OldSearchLightY = v53->m_OldSearchLightY;
      v68 = v52 - 1000;
      m_OldSearchLightX = v53->m_OldSearchLightX;
      v110 = v58;
      v69 = (float)((float)(v56 * 50.0) + (float)(v56 * 50.0)) + v.y;
      v70 = v67 + v.x;
      if ( v52 <= 2000 )
      {
        v73 = v53->m_OldSearchLightY[0];
        v74 = v59;
        v52 -= 1000;
        v72 = *(float *)&v114[1].m_upgrades[5];
        v71 = *((_DWORD *)&v114[1].m_nVehicleFlags + 1);
      }
      else
      {
        do
        {
          v71 = v62;
          v72 = v66;
          v62 = LODWORD(v61);
          v66 = v65;
          v61 = v60;
          v65 = v64;
          v60 = v59;
          v64 = v63;
          v52 = v68 - 1000;
          v59 = v67 + v.x;
          v63 = v69;
          v55 += 1000;
          v100 = v68 <= 2000;
          v68 -= 1000;
        }
        while ( !v100 );
        v73 = v69;
        v74 = v70;
      }
      v1 = (CHeli *)v114;
      v76 = v60;
      v51 = CTimer::m_snTimeInMilliseconds;
      v75 = v64;
      *(float *)&v114[1].m_upgrades[7] = v72;
      *(float *)&v114[1].m_upgrades[5] = v66;
      *(float *)&v114[1].m_upgrades[3] = v65;
      *(float *)&v114[1].AutoPilot.RecordingNumber = v60;
      *(float *)&v114[1].m_nVehicleFlags = v61;
      *((_DWORD *)&v114[1].m_nVehicleFlags + 1) = v62;
      v114[1].m_TimeOfCreation = v71;
      *(float *)&v114[1].m_upgrades[1] = v64;
      *v108 = v74;
      *v110 = v73;
      *m_OldSearchLightX = v70;
      *m_OldSearchLightY = v69;
      *(_DWORD *)&v114[1].m_upgrades[9] = v55;
      PlayerEntity = v111;
      p_Mission = v112;
    }
    v77 = 1.0;
    v78 = v1->m_pMat;
    v79 = (float)v52 / 1000.0;
    v80 = 1.0 - v79;
    v81 = v79 * v73;
    v82 = v79 * v74;
    v83 = v80 * v76;
    v84 = v81 + (float)(v80 * v75);
    v85 = v82 + v83;
    v1->m_SearchLightY = v84;
    v1->m_SearchLightX = v85;
    v1->m_SearchLightZ = v.z;
    v86 = &v78->tx;
    if ( !v78 )
      v86 = &v1->m_transform.m_translate.x;
    v87 = sqrtf((float)((float)(v85 - *v86) * (float)(v85 - *v86)) + (float)((float)(v84 - v86[1])
                                                                           * (float)(v84 - v86[1])));
    if ( v87 <= 60.0 )
    {
      if ( v87 >= 40.0 )
        v77 = (float)((float)(v87 + -40.0) / -20.0) + 1.0;
    }
    else
    {
      v77 = 0.0;
    }
    v1->m_LightBrightness = v77;
    if ( v77 < 0.9
      || (float)((float)((float)(v.x - v85) * (float)(v.x - v85)) + (float)((float)(v.y - v84) * (float)(v.y - v84))) > 49.0 )
    {
      v1->m_LastTimeGunFired = v51;
      v1->m_LastTimeSearchLightWasTooFarAwayToShoot = v51;
    }
    else if ( v51 > v1->m_nNextTalkTimer )
    {
      v1->m_nNextTalkTimer = (rand() & 0xFFF) + v51 + 4500;
    }
    if ( v113 == 1 )
    {
      v88 = FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel - 3;
      if ( v88 > 3 )
        v89 = 999999;
      else
        v89 = (unsigned int)*(&off_571B78 + v88);
      if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel )
        CAudioEngine::SayPedless(&AudioEngine, 52, 174, v1, 0, 1.0, 0, 0, 0);
      v90 = CCullZones::NoPolice();
      PlayerPed = FindPlayerPed(-1);
      v92 = *((unsigned __int8 *)FindPlayerWanted(-1) + 30);
      v93 = 5000;
      if ( PlayerEntity == PlayerPed )
        v93 = v89 >> v90;
      if ( v92 << 29 )
      {
        v94 = CTimer::m_snTimeInMilliseconds;
        v1->m_LastTimeGunFired = CTimer::m_snTimeInMilliseconds;
        v1->m_LastTimeSearchLightWasTooFarAwayToShoot = v94;
      }
      else
      {
        v95 = v1->m_pMat;
        pEndCoors.y = 3.5;
        pEndCoors.x = 0.0;
        pEndCoors.z = -1.0;
        operator*(&vecStart, v95, &pEndCoors);
        m_LastTimeSearchLightWasTooFarAwayToShoot = v1->m_LastTimeSearchLightWasTooFarAwayToShoot;
        v97 = CTimer::m_snTimeInMilliseconds;
        if ( CTimer::m_snTimeInMilliseconds > m_LastTimeSearchLightWasTooFarAwayToShoot + v93
          && CTimer::m_snPreviousTimeInMilliseconds <= m_LastTimeSearchLightWasTooFarAwayToShoot + v93 )
        {
          IsLineOfSightClear = CWorld::GetIsLineOfSightClear(&vecStart, &v, 1, 0, 0, 0, 0, 0, 0);
          v97 = CTimer::m_snTimeInMilliseconds;
          if ( IsLineOfSightClear )
          {
            m_LastTimeSearchLightWasTooFarAwayToShoot = v1->m_LastTimeSearchLightWasTooFarAwayToShoot;
          }
          else
          {
            m_LastTimeSearchLightWasTooFarAwayToShoot = CTimer::m_snTimeInMilliseconds;
            v1->m_LastTimeGunFired = CTimer::m_snTimeInMilliseconds;
            v1->m_LastTimeSearchLightWasTooFarAwayToShoot = v97;
          }
        }
        v99 = m_LastTimeSearchLightWasTooFarAwayToShoot + v93;
        v100 = v97 > v99;
        if ( v97 > v99 )
          v100 = v97 > v1->m_LastTimeGunFired;
        if ( v100 )
        {
          pEndCoors = v;
          v101 = rand();
          x = pEndCoors.x;
          v103 = rand();
          y = pEndCoors.y;
          v117.x = v.x - vecStart.x;
          v117.y = v.y - vecStart.y;
          v117.z = v.z - vecStart.z;
          CVector::Normalise(&v117);
          pEndCoors.x = (float)(v117.x * 3.0) + (float)(x + (float)((float)(v101 - 128) * 0.02));
          pEndCoors.y = (float)(v117.y * 3.0) + (float)(y + (float)((float)(v103 - 128) * 0.02));
          pEndCoors.z = (float)(v117.z * 3.0) + pEndCoors.z;
          pStartCoors.x = (float)(v117.x * 3.0) + vecStart.x;
          pStartCoors.y = (float)(v117.y * 3.0) + vecStart.y;
          pStartCoors.z = (float)(v117.z * 3.0) + vecStart.z;
          FireOneInstantHitRound(&pStartCoors, &pEndCoors, 20);
          CAudioEngine::ReportWeaponEvent(&AudioEngine, 145, WEAPONTYPE_M4, v1);
          v105 = rand();
          v106 = 150;
          if ( (float)((float)((float)v105 * 4.6566e-10) + 0.0) < 0.15 )
            v106 = 400;
          v1->m_LastTimeGunFired = CTimer::m_snTimeInMilliseconds + v106;
        }
      }
    }
  }
LABEL_15:
  if ( *p_Mission == 40 && v1->m_nSwatOnBoard )
  {
    CHeli::SendDownSwat(v1);
    CInterestingEvents::Add(&g_InterestingEvents, ESwatTeamAbseiling, v1);
  }
  m_SwatRopeActive = v1->m_SwatRopeActive;
  v8 = flt_61EA24;
  v9 = (RwReal *)sub_571BBC;
  v10 = flt_61EA34;
  v11 = (RwReal *)sub_571BCC;
  v12 = 0;
  do
  {
    if ( m_SwatRopeActive[v12] )
    {
      --m_SwatRopeActive[v12];
      v13 = 0.0;
      v14 = 0.0;
      v15 = 0.0;
      v16 = (u_native)v114 + v12;
      v17 = v114->m_pMat;
      if ( v12 <= 3 )
      {
        v14 = *v10;
        v13 = *v8;
        v15 = -0.5;
      }
      v.y = v14;
      v.x = v13;
      v.z = v15;
      operator*(&v115, v17, &v);
      CRopes::RegisterRope(v16, 8u, v115, 0, 0, 0, 0, 20000);
      if ( !m_SwatRopeActive[v12] )
      {
        v18 = 0.0;
        v19 = 0.0;
        v20 = 0;
        v21 = v114->m_pMat;
        if ( v12 <= 3 )
        {
          v19 = *v11;
          v18 = *v9;
          v20 = -1127428915;
        }
        vecStart.y = v19;
        vecStart.x = v18;
        LODWORD(vecStart.z) = v20;
        Multiply3x3(&v, v21, &vecStart);
        v121.x = v.x;
        *(_QWORD *)&v121.y = LODWORD(v.y);
        v.z = 0.0;
        CRopes::SetSpeedOfTopNode(v16, v121);
      }
    }
    ++v12;
    ++v10;
    ++v8;
    ++v11;
    ++v9;
  }
  while ( v12 != 4 );
  CVehicle::UpdateWinch(v114);
  CVehicle::ProcessWeapons(v114);
  if ( *((unsigned __int8 *)&g_InterestingEvents + 300) << 31 )
  {
    v22 = (float)(CTimer::ms_fTimeStep / 50.0) / 10.0;
    v23 = (float)((float)rand() * 4.6566e-10) + 0.0;
    if ( v113 )
      v22 = v22 + v22;
    if ( v23 < v22 )
      CInterestingEvents::Add(&g_InterestingEvents, EHelicopterOverhead, v114);
  }
}
// 571B78: using guessed type void *off_571B78;
// 571BBC: using guessed type int sub_571BBC();
// 571BCC: using guessed type int sub_571BCC();
// 61EA24: using guessed type float flt_61EA24[4];
// 61EA34: using guessed type float flt_61EA34[4];

//----- (00571BE8) --------------------------------------------------------
bool __fastcall CHeli::SendDownSwat(CHeli *this)
{
  CEntity *pTargetEntity; // r1
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r0
  bool v5; // r5
  float32x2_t v6; // d9
  float z; // s16
  CMatrix *v8; // r1
  CSimpleTransform *p_m_transform; // r5
  float32x2_t *v10; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  unsigned __int8 v14; // r0
  RwReal v15; // s0
  RwReal v16; // s4
  RwReal v17; // s2
  CMatrix *v18; // r0
  float v19; // s10
  float v20; // s0
  float v21; // s2
  float v22; // s4
  float GroundZFor3DCoord; // s18
  _BOOL4 WaterLevelNoWaves; // r0
  CPed *v25; // r8
  CTaskComplexSequence *v26; // r9
  CTaskComplexUseSwatRope *v27; // r6
  char *v28; // r6
  unsigned __int16 v29; // r0
  UInt8 v30; // r0
  CVector v; // [sp+1Ch] [bp-A4h] BYREF
  CVector v32; // [sp+28h] [bp-98h] BYREF
  CMatrix m; // [sp+38h] [bp-88h] BYREF
  CVector vecPosition; // [sp+80h] [bp-40h] BYREF
  CVector cvector; // 0:r2.8,8:^0.4

  pTargetEntity = this->AutoPilot.pTargetEntity;
  m_pMat = pTargetEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pTargetEntity->m_transform;
  if ( !this->m_nSwatOnBoard )
    return 0;
  v5 = 0;
  if ( (*(_DWORD *)&this->m_nPhysicalFlags & 0x100) == 0 && CStreaming::ms_aInfoForModel[285].m_status == 1 )
  {
    v6.n64_u64[0] = *(unsigned __int64 *)&p_tx->m_translate.x;
    z = p_tx->m_translate.z;
    if ( (rand() & 0x7F) != 0 )
      return 0;
    v8 = this->m_pMat;
    p_m_transform = &this->m_transform;
    v10 = (float32x2_t *)&this->m_transform;
    if ( v8 )
      v10 = (float32x2_t *)&v8->tx;
    v11.n64_u64[0] = vsub_f32((float32x2_t)v10->n64_u64[0], v6).n64_u64[0];
    v12 = vmul_f32(v11, v11).n64_u64[0];
    if ( sqrtf(
           (float)(*(float *)&v12 + *((float *)&v12 + 1))
         + (float)((float)(v10[1].n64_f32[0] - z) * (float)(v10[1].n64_f32[0] - z))) > 50.0
      || sqrtf(
           (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                 + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
         + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.1 )
    {
      return 0;
    }
    CMatrix::CMatrix(&m, v8);
    v14 = this->m_nSwatOnBoard - 1;
    if ( v14 > 3u )
    {
      v17 = 0.0;
      v16 = 0.0;
      v15 = 0.0;
    }
    else
    {
      v15 = -0.5;
      v16 = flt_61EA34[(char)v14];
      v17 = flt_61EA24[(char)v14];
    }
    v.y = v16;
    v.x = v17;
    v.z = v15;
    Multiply3x3(&v32, &m, &v);
    vecPosition = v32;
    v18 = this->m_pMat;
    if ( v18 )
      p_m_transform = (CSimpleTransform *)&v18->tx;
    v19 = p_m_transform->m_translate.z;
    v20 = p_m_transform->m_translate.x + v32.x;
    v21 = p_m_transform->m_translate.y + v32.y;
    v5 = 0;
    v22 = v19 + v32.z;
    vecPosition.x = v20;
    vecPosition.y = v21;
    vecPosition.z = v19 + v32.z;
    GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(v20, v21, v19 + v32.z, 0, 0);
    if ( fabsf(z - GroundZFor3DCoord) < 2.5 )
    {
      WaterLevelNoWaves = CWaterLevel::GetWaterLevelNoWaves(v20, v21, v22, &v32.x, 0, 0);
      if ( v32.x >= GroundZFor3DCoord && WaterLevelNoWaves
        || (cvector.z = v22,
            *(_QWORD *)&cvector.x = __PAIR64__(LODWORD(v21), LODWORD(v20)),
            CRopes::RegisterRope(
              (u_native)&this[-1].m_crashAndBurnTurnSpeed + this->m_nSwatOnBoard + 3,
              8u,
              cvector,
              0,
              0,
              0,
              0,
              20000) < 0) )
      {
        v5 = 0;
      }
      else
      {
        v5 = 1;
        v25 = CPopulation::AddPed(PEDTYPE_COP, 3u, &vecPosition, 1);
        v26 = (CTaskComplexSequence *)CTask::operator new(0x40u);
        CTaskComplexSequence::CTaskComplexSequence(v26);
        v27 = (CTaskComplexUseSwatRope *)CTask::operator new(0x1Cu);
        CTaskComplexUseSwatRope::CTaskComplexUseSwatRope(
          v27,
          (int)&this[-1].m_crashAndBurnTurnSpeed + this->m_nSwatOnBoard + 3,
          this);
        CTaskComplexSequence::AddTask(v26, v27);
        v28 = (char *)CTask::operator new(0x50u);
        v29 = rand();
        CTaskComplexWander::CTaskComplexWander(
          (CTaskComplexWander *)v28,
          4,
          (int)(float)((float)((float)v29 * 0.000015259) * 8.0),
          1,
          0.5);
        *((_QWORD *)v28 + 7) = 0LL;
        *((_QWORD *)v28 + 8) = 0LL;
        *(_DWORD *)(v28 + 50) = 0;
        *(_DWORD *)(v28 + 46) = 0;
        *(_DWORD *)v28 = &off_66C5D8;
        *((_DWORD *)v28 + 10) = 0;
        *((_DWORD *)v28 + 11) = 0;
        *(_DWORD *)(v28 + 74) = 0;
        *(_DWORD *)(v28 + 70) = 0;
        CTaskComplexSequence::AddTask(v26, (CTask *)v28);
        CTaskManager::SetTask(&v25->m_pPedIntelligence->m_taskManager, v26, 3, 0);
        *(_DWORD *)&v25->m_nFlags &= ~1u;
        v30 = this->m_nSwatOnBoard - 1;
        this->m_nSwatOnBoard = v30;
        this->m_SwatRopeActive[v30] = -86;
        CAnimManager::BlendAnimation((RpClump_0 *)v25->m_pRwObject, ANIM_STD_PED, ANIM_STD_ABSEIL, 4.0);
      }
    }
    CMatrix::~CMatrix(&m);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 61EA24: using guessed type float flt_61EA24[4];
// 61EA34: using guessed type float flt_61EA34[4];
// 66C5D8: using guessed type void *off_66C5D8;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00571F08) --------------------------------------------------------
CVector *__fastcall CHeli::FindSwatPositionRelativeToHeli(CVector *retstr, CHeli *this, Int32 SwatNumber)
{
  RwReal v3; // s0
  RwReal v4; // s2
  RwReal v5; // s4

  if ( (unsigned int)SwatNumber > 3 )
  {
    v5 = 0.0;
    v4 = 0.0;
    v3 = 0.0;
  }
  else
  {
    v3 = -0.5;
    v4 = flt_61EA34[SwatNumber];
    v5 = flt_61EA24[SwatNumber];
  }
  retstr->x = v5;
  retstr->y = v4;
  retstr->z = v3;
  return retstr;
}
// 61EA24: using guessed type float flt_61EA24[4];
// 61EA34: using guessed type float flt_61EA34[4];

//----- (00571F50) --------------------------------------------------------
void __fastcall CHeli::ProcessControlInputs(CHeli *this, uint8 CtrlNum)
{
  float32x2_t d0_0; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d8
  float32x2_t v5; // d9
  CPad *Pad; // r9
  float *p_m_fThrottleControl; // r5
  int Accelerate; // r6
  float *p_m_fRollControl; // r8
  float *p_m_fPitchControl; // r5
  float x; // s20
  _BOOL4 IsPressed; // r6
  _BOOL4 v14; // r0
  float v15; // s2
  int v16; // r0
  const CVector *m_pMat; // r2
  float v18; // s16
  float v19; // s0
  float v20; // s2
  CMatrix *v21; // r0
  float v22; // s0
  bool v23; // nf
  int m_nVehicleFlags; // r1
  CPlayerPed *PlayerPed; // r0
  float v26; // s0
  float y; // s4
  float z; // s2
  float v29; // s6
  float v30; // s6
  float m_fYawControl; // s2
  CVector v2; // [sp+4h] [bp-5Ch] BYREF
  CVector v1; // [sp+10h] [bp-50h] BYREF
  CVector pfValueOut[5]; // [sp+20h] [bp-40h] BYREF

  Pad = CPad::GetPad(CtrlNum);
  if ( CHID::GetInputType() == 2 )
  {
    this->m_fThrottleControl = 0.0;
    p_m_fThrottleControl = &this->m_fThrottleControl;
    if ( CHID::IsPressed(HID_MAPPING_FLIGHT_ASCEND, 0) )
      *p_m_fThrottleControl = 1.0;
    if ( CHID::IsPressed(HID_MAPPING_FLIGHT_DESCEND, 0) )
      *p_m_fThrottleControl = -1.0;
    if ( CHID::IsPressed(HID_MAPPING_FLIGHT_ASCEND, 0) && CHID::IsPressed(HID_MAPPING_FLIGHT_DESCEND, 0) )
      *p_m_fThrottleControl = 0.0;
  }
  else
  {
    Accelerate = CPad::GetAccelerate(Pad);
    this->m_fThrottleControl = (float)(Accelerate - CPad::GetBrake(Pad)) / 255.0;
  }
  p_m_fRollControl = &this->m_fRollControl;
  this->m_fRollControl = (float)-CPad::GetSteeringLeftRight(Pad) * 0.0078125;
  p_m_fPitchControl = &this->m_fPitchControl;
  this->m_fPitchControl = (float)CPad::GetSteeringUpDown(Pad) * 0.0078125;
  if ( CHID::GetInputType() == 2 )
  {
    pfValueOut[0].x = 0.0;
    if ( CHID::IsPressed(HID_MAPPING_ACCELERATE, &pfValueOut[0].x) )
      *p_m_fPitchControl = pfValueOut[0].x;
    if ( CHID::IsPressed(HID_MAPPING_BRAKE, &pfValueOut[0].x) )
      *p_m_fPitchControl = -pfValueOut[0].x;
    if ( CHID::IsPressed(HID_MAPPING_ACCELERATE, 0) && CHID::IsPressed(HID_MAPPING_BRAKE, 0) )
      *p_m_fPitchControl = 0.0;
    CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_X, &this->m_fRollControl);
    d0_0.n64_f32[0] = -*p_m_fPitchControl;
    *p_m_fPitchControl = d0_0.n64_f32[0];
    v3.n64_f32[0] = -*p_m_fRollControl;
    *p_m_fRollControl = v3.n64_f32[0];
  }
  else
  {
    v3.n64_f32[0] = *p_m_fRollControl;
    d0_0.n64_f32[0] = *p_m_fPitchControl;
  }
  v4.n64_u32[0] = 1.0;
  v5.n64_u32[0] = -1.0;
  *(_DWORD *)p_m_fPitchControl = vmax_f32(vmin_f32(d0_0, v4), v5).n64_u32[0];
  *(_DWORD *)p_m_fRollControl = vmax_f32(vmin_f32(v3, v4), v5).n64_u32[0];
  if ( CHID::GetInputType() != 2 )
  {
    this->m_fYawControl = 0.0;
    if ( CPad::GetTurretLeft(Pad) && CPad::GetTurretRight(Pad) )
    {
      v16 = 0;
    }
    else if ( CPad::GetTurretLeft(Pad) )
    {
      v16 = -1082130432;
    }
    else
    {
      if ( !CPad::GetTurretRight(Pad) )
        goto LABEL_35;
      v16 = 1065353216;
    }
    LODWORD(this->m_fYawControl) = v16;
    goto LABEL_35;
  }
  x = CPad::NewMouseControllerState.m_AmountMoved.x;
  IsPressed = CHID::IsPressed(HID_MAPPING_FLIGHT_ALT_LEFT, 0);
  v14 = CHID::IsPressed(HID_MAPPING_FLIGHT_ALT_RIGHT, 0);
  v15 = x * 0.15;
  if ( IsPressed )
    v15 = -1.0;
  if ( v14 )
    v15 = 1.0;
  this->m_fYawControl = v15 * (float)((float)((float)((float)MobileSettings::settings[31].value / 100.0) * 0.5) + 0.5);
LABEL_35:
  if ( CPad::GetHorn(Pad, 1) )
  {
    m_pMat = (const CVector *)this->m_pMat;
    if ( m_pMat[3].y > 0.0 )
    {
      this->m_fYawControl = 0.0;
      v1.x = 0.0;
      v1.y = 0.0;
      v1.z = 1.0;
      CrossProduct(pfValueOut, &v1, m_pMat);
      CVector::Normalise(pfValueOut);
      v18 = -2.0;
      v19 = (float)((float)((float)(this->m_vecMoveSpeed.x * pfValueOut[0].x)
                          + (float)(this->m_vecMoveSpeed.y * pfValueOut[0].y))
                  + (float)(this->m_vecMoveSpeed.z * pfValueOut[0].z))
          * this->pFlyingHandling->fPitchStabilise;
      if ( v19 > 2.0 || (v20 = -2.0, v19 >= -2.0) )
      {
        v20 = 2.0;
        if ( v19 <= 2.0 )
          v20 = (float)((float)((float)(this->m_vecMoveSpeed.x * pfValueOut[0].x)
                              + (float)(this->m_vecMoveSpeed.y * pfValueOut[0].y))
                      + (float)(this->m_vecMoveSpeed.z * pfValueOut[0].z))
              * this->pFlyingHandling->fPitchStabilise;
      }
      *p_m_fPitchControl = v20;
      v21 = this->m_pMat;
      v2.x = 0.0;
      v2.y = 0.0;
      v2.z = 1.0;
      CrossProduct(&v1, (const CVector *)&v21->xy, &v2);
      pfValueOut[0] = v1;
      CVector::Normalise(pfValueOut);
      v22 = (float)((float)((float)(this->m_vecMoveSpeed.x * pfValueOut[0].x)
                          + (float)(this->m_vecMoveSpeed.y * pfValueOut[0].y))
                  + (float)(this->m_vecMoveSpeed.z * pfValueOut[0].z))
          * this->pFlyingHandling->fRollStabilise;
      v23 = v22 < 2.0;
      if ( v22 <= 2.0 )
        v23 = v22 < -2.0;
      if ( !v23 )
      {
        v18 = 2.0;
        if ( v22 <= 2.0 )
          v18 = (float)((float)((float)(this->m_vecMoveSpeed.x * pfValueOut[0].x)
                              + (float)(this->m_vecMoveSpeed.y * pfValueOut[0].y))
                      + (float)(this->m_vecMoveSpeed.z * pfValueOut[0].z))
              * this->pFlyingHandling->fRollStabilise;
      }
      *p_m_fRollControl = v18;
    }
  }
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  this->m_fSteerAngle = 0.0;
  this->m_fGasPedal = 0.0;
  this->m_fBrakePedal = 1.0;
  *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFDF;
  if ( Pad->DisablePlayerControls )
  {
    PlayerPed = FindPlayerPed(-1);
    CPlayerPed::KeepAreaAroundPlayerClear(PlayerPed);
    v26 = this->m_vecMoveSpeed.x;
    y = this->m_vecMoveSpeed.y;
    z = this->m_vecMoveSpeed.z;
    v29 = sqrtf((float)((float)(v26 * v26) + (float)(y * y)) + (float)(z * z));
    if ( v29 > 0.28 )
    {
      v30 = 0.28 / v29;
      this->m_vecMoveSpeed.x = v26 * v30;
      this->m_vecMoveSpeed.y = y * v30;
      this->m_vecMoveSpeed.z = z * v30;
    }
  }
  if ( this->m_nHealth < 250.0 )
  {
    m_fYawControl = this->m_fYawControl;
    this->m_fThrottleControl = -0.1;
    this->m_fYawControl = m_fYawControl + 0.5;
  }
}
// 5720A8: variable 'd0_0' is possibly undefined
// 5720A8: variable 'v4' is possibly undefined
// 5720B0: variable 'v5' is possibly undefined
// 5720AC: variable 'v3' is possibly undefined

//----- (00572394) --------------------------------------------------------
void __fastcall CHeli::ProcessFlyingCarStuff(CHeli *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  unsigned int v5; // r0
  float *v6; // r5
  float v7; // s0
  int v8; // r0
  bool v9; // zf
  float *v10; // r0
  float v11; // s2
  float v12; // s0
  float v13; // s2
  int v14; // r0
  bool v15; // zf
  __int64 v16; // r0
  float *p_m_fThrottleControl; // r2
  RwFrame_0 *v18; // r0
  float xx; // r0
  float v20; // s0
  int v21; // r0
  int v22; // s2
  int m_nModelIndex; // r0
  bool v24; // zf
  unsigned int m_info; // r0
  bool v26; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  CMatrix *v29; // r0
  CSimpleTransform *p_m_transform; // r2
  int v31; // r0
  bool v32; // zf
  RwFrame_0 *v33; // r0
  CMatrix *v34; // r2
  CSimpleTransform *v35; // r3
  CSimpleTransform *v36; // r2
  float v37; // s18
  float v38; // s20
  float v39; // s16
  float v40; // s22
  float v41; // s0
  CVector v42; // [sp+10h] [bp-E0h] BYREF
  CVector v; // [sp+20h] [bp-D0h] BYREF
  CMatrix data; // [sp+30h] [bp-C0h] BYREF
  CMatrix v45; // [sp+78h] [bp-78h] BYREF

  v5 = *(_BYTE *)&this->m_info >> 3;
  if ( v5 > 8 || ((1 << v5) & 0x109) == 0 )
  {
    if ( (this->pHandling->mFlags & 0x2000000) != 0 )
    {
      *(_DWORD *)&this->m_nVehicleFlags &= ~0x10u;
      v10 = &this->m_aWheelAngularVelocity[1];
      v11 = this->m_aWheelAngularVelocity[1];
      if ( v11 <= (float)(CTimer::ms_fTimeStep * 0.00055) )
      {
        v12 = 0.0;
        *v10 = 0.0;
      }
      else
      {
        v12 = v11 - (float)(CTimer::ms_fTimeStep * 0.00055);
        *v10 = v12;
        this->m_nNoOfStaticFrames = 0;
      }
      m_nModelIndex = this->m_nModelIndex;
      v24 = m_nModelIndex == 465;
      if ( m_nModelIndex != 465 )
        v24 = m_nModelIndex == 501;
      if ( !v24 )
        goto LABEL_72;
    }
    return;
  }
  v6 = &this->m_aWheelAngularVelocity[1];
  v7 = this->m_aWheelAngularVelocity[1];
  if ( v7 < 0.22 && !(*((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31) )
  {
    v8 = this->m_nModelIndex;
    v9 = v8 == 501;
    if ( v8 != 501 )
      v9 = v8 == 465;
    if ( v9 )
      v13 = 0.003;
    else
      v13 = 0.001;
    v7 = v13 + v7;
    *v6 = v7;
  }
  if ( v7 > 0.15 )
  {
    if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 8) == 0 )
      goto LABEL_21;
    v14 = this->m_nModelIndex;
    v15 = v14 == 447;
    if ( v14 != 447 )
      v15 = v14 == 417;
    if ( v15 )
      LODWORD(v16) = 1;
    else
LABEL_21:
      LODWORD(v16) = 0;
    if ( (*((_BYTE *)&this->m_nVehicleFlags + 4) & 0x80) != 0 )
    {
      CVehicle::FlyingControl(
        this,
        FLIGHTMODEL_RCHELI,
        this->m_fYawControl,
        this->m_fPitchControl,
        this->m_fRollControl,
        this->m_fThrottleControl);
    }
    else
    {
      HIDWORD(v16) = 0;
      p_m_fThrottleControl = &this->m_fThrottleControl;
      if ( this->nNoOfContactWheels > 3u )
        HIDWORD(v16) = 1;
      if ( *p_m_fThrottleControl > 0.0
        || !v16
        || fabsf(this->m_vecMoveSpeed.x) > 0.02
        || fabsf(this->m_vecMoveSpeed.y) > 0.02
        || fabsf(this->m_vecMoveSpeed.z) > 0.02 )
      {
        CVehicle::FlyingControl(
          this,
          FLIGHTMODEL_HELI,
          this->m_fYawControl,
          this->m_fPitchControl,
          this->m_fRollControl,
          *p_m_fThrottleControl);
      }
    }
  }
  if ( *v6 > 0.015 )
  {
    v18 = this->m_aCarNodes[12];
    if ( v18 )
    {
      v45.m_pRwMat = 0;
      v45.m_owner = 0;
      CMatrix::Attach(&v45, &v18->modelling, 0);
      data.xx = 0.0;
      RwFrameForAllObjects(this->m_aCarNodes[12], GetCurrentAtomicObjectCB, &data);
      xx = data.xx;
      if ( !LODWORD(data.xx) )
        goto LABEL_55;
      if ( (*(_BYTE *)(LODWORD(data.xx) + 76) & 2) != 0 )
      {
        _rpAtomicResyncInterpolatedSphere((RpAtomic_0 *)LODWORD(data.xx));
        xx = data.xx;
      }
      v20 = *(float *)(LODWORD(xx) + 40);
      if ( v20 <= 0.1 )
        goto LABEL_55;
      v21 = this->m_nModelIndex;
      v22 = 1063675494;
      if ( v21 > 468 )
      {
        if ( v21 != 469 )
        {
          if ( v21 != 501 )
            goto LABEL_49;
          goto LABEL_53;
        }
      }
      else if ( v21 != 447 )
      {
        if ( v21 != 465 )
        {
LABEL_49:
          v22 = 1.0;
          if ( (unsigned __int16)v21 == 425 )
            v22 = 0.5;
        }
LABEL_53:
        if ( ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
          CVehicle::DoBladeCollision(this, *(CVector *)&v45.tx, this->m_pMat, -3, v20, *(float *)&v22);
LABEL_55:
        m_info = (unsigned __int8)this->m_info;
        v26 = m_info >> 3 == 3;
        if ( m_info >> 3 != 3 )
          v26 = m_info >> 3 == 0;
        if ( v26 && *v6 > 0.0075 )
        {
          m_pMat = this->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &this->m_transform;
          v2.n64_u32[0] = 1.0;
          v1.n64_f32[0] = *v6 / 0.15;
          v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
          CWindModifiers::RegisterOne(p_tx->m_translate, 1, v1.n64_f32[0]);
        }
        else if ( (m_info & 0xF8) == 16 )
        {
          v29 = this->m_pMat;
          p_m_transform = (CSimpleTransform *)&v29->tx;
          if ( !v29 )
            p_m_transform = &this->m_transform;
          CWindModifiers::RegisterOne(p_m_transform->m_translate, 1, 1.0);
        }
        CMatrix::~CMatrix(&v45);
        goto LABEL_68;
      }
      v22 = 1061997773;
      goto LABEL_53;
    }
  }
LABEL_68:
  v31 = this->m_nModelIndex;
  v32 = v31 == 465;
  if ( v31 != 465 )
    v32 = v31 == 501;
  if ( !v32 )
  {
    v12 = *v6;
LABEL_72:
    if ( v12 < 0.154 && v12 > 0.0044 )
    {
      v33 = this->m_aCarNodes[12];
      if ( v33 )
      {
        v34 = this->m_pMat;
        v35 = (CSimpleTransform *)&v34->tx;
        if ( !v34 )
          v35 = &this->m_transform;
        v36 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          v36 = &TheCamera.m_transform;
        v37 = v36->m_translate.x - v35->m_translate.x;
        v38 = v36->m_translate.y - v35->m_translate.y;
        v39 = v36->m_translate.z - v35->m_translate.z;
        v40 = (float)((float)(v37 * v37) + (float)(v38 * v38)) + (float)(v39 * v39);
        if ( v40 < 400.0 && fabsf(this->PropRotate - this->m_aWheelPitchAngles[1]) > 0.5236 )
        {
          v45.m_pRwMat = 0;
          v45.m_owner = 0;
          data.m_pRwMat = 0;
          data.m_owner = 0;
          CMatrix::Attach(&v45, &v33->modelling, 0);
          v.z = v45.zx;
          *(_QWORD *)&v.x = *(_QWORD *)&v45.xx;
          Multiply3x3(&v42, this->m_pMat, &v);
          v1.n64_f32[0] = sqrtf(v40);
          v = v42;
          v3.n64_u32[0] = 1008981770;
          v41 = vmax_f32(v1, v3).n64_f32[0];
          if ( fabsf(
                 (float)((float)((float)(v37 * (float)(1.0 / v41)) * v42.x)
                       + (float)((float)(v38 * (float)(1.0 / v41)) * v42.y))
               + (float)((float)(v39 * (float)(1.0 / v41)) * v42.z)) > 0.95 )
          {
            CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 94, 0.0);
            this->PropRotate = this->m_aWheelPitchAngles[1];
          }
          CMatrix::~CMatrix(&data);
          CMatrix::~CMatrix(&v45);
        }
      }
    }
  }
}
// 572668: variable 'v1' is possibly undefined
// 572668: variable 'v2' is possibly undefined
// 5727BE: variable 'v3' is possibly undefined

//----- (00572874) --------------------------------------------------------
void __fastcall CHeli::PreRender(CHeli *this)
{
  CVehicleModelInfo *v2; // r9
  float m_SearchLightX; // r11
  float m_SearchLightY; // r10
  float m_SearchLightZ; // lr
  UInt32 v6; // r1
  float m_LightBrightness; // r8
  RwReal y; // r5
  RwReal z; // r0
  HeliSearchLight *v10; // r2
  float *m_aWheelRatios; // r5
  int32 i; // r6
  float v13; // s20
  float v14; // s22
  float v15; // s24
  float v16; // s2
  float v17; // s0
  float v18; // s2
  bool v19; // nf
  int m_nModelIndex; // r1
  bool v21; // zf
  int v22; // r0
  float v23; // s2
  float v24; // s0
  float *p_m_fMainRotorAngle; // r6
  float v26; // s4
  float v27; // s6
  float v28; // s6
  float *p_m_fRearRotorAngle; // r8
  float j; // s2
  RwFrame_0 *v31; // r0
  RwFrame_0 *v32; // r0
  RwFrame_0 *v33; // r0
  RwFrame_0 *v34; // r0
  CVector v35; // [sp+4h] [bp-ACh] BYREF
  CVector v; // [sp+10h] [bp-A0h] BYREF
  CMatrix v37; // [sp+20h] [bp-90h] BYREF

  CVehicle::PreRender(this);
  v2 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v37.m_pRwMat = 0;
  v37.m_owner = 0;
  if ( this->m_bSearchLightOn && this->m_LightBrightness > 0.0 && CClock::GetIsTimeInRange(0x13u, 6u) )
  {
    v.y = 3.5;
    v.x = 0.0;
    v.z = -0.3;
    operator*(&v35, this->m_pMat, &v);
    m_SearchLightX = this->m_SearchLightX;
    m_SearchLightY = this->m_SearchLightY;
    m_SearchLightZ = this->m_SearchLightZ;
    v6 = CHeli::NumberOfSearchLights;
    m_LightBrightness = this->m_LightBrightness;
    y = v35.y;
    z = v35.z;
    CHeli::HeliSearchLights[CHeli::NumberOfSearchLights].vecSourcePosition.x = v35.x;
    v10 = &CHeli::HeliSearchLights[v6];
    *(_WORD *)&v10->ClipIfColliding = 257;
    v10->vecSourcePosition.y = y;
    v10->vecSourcePosition.z = z;
    v10->vecTargetPosition.x = m_SearchLightX;
    v10->vecTargetPosition.y = m_SearchLightY;
    v10->vecTargetPosition.z = m_SearchLightZ;
    v10->radius = 20.0;
    v10->brightness = m_LightBrightness;
    v10->UniqueID = (UInt32)&this->m_transform.m_translate.y + 3;
    CHeli::NumberOfSearchLights = v6 + 1;
  }
  CEntity::GetColModel(this);
  if ( *((unsigned __int8 *)&this->m_nVehicleFlags + 3) << 31 )
  {
    (*((void (__fastcall **)(CHeli *))this->_vptr$CPlaceable + 53))(this);
    m_aWheelRatios = this->m_aWheelRatios;
    for ( i = 0; i != 4; ++i )
    {
      v13 = *m_aWheelRatios;
      v14 = m_aWheelRatios[41];
      v15 = m_aWheelRatios[45];
      CVehicleModelInfo::GetWheelPosn(v2, i, &v, 1);
      v16 = (float)(v13 - (float)(1.0 - (float)(v14 / v15))) / (float)(1.0 - (float)(1.0 - (float)(v14 / v15)));
      v17 = v.z + this->pHandling->fSuspensionUpperLimit;
      if ( v16 > 0.0 )
        v17 = v17 - (float)(v16 * m_aWheelRatios[41]);
      v18 = m_aWheelRatios[25];
      if ( v17 <= v18 )
      {
        v19 = (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 4) != 0;
        if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 4) != 0 )
          v19 = (this->hFlagsLocal & 0x20000) != 0;
        if ( !v19 )
          v17 = v18 + (float)((float)(v17 - v18) * 0.75);
      }
      m_aWheelRatios[25] = v17;
      ++m_aWheelRatios;
    }
  }
  CAutomobile::UpdateWheelMatrix(this, 4, 1);
  CAutomobile::UpdateWheelMatrix(this, 7, 1);
  CAutomobile::UpdateWheelMatrix(this, 2, 1);
  CAutomobile::UpdateWheelMatrix(this, 5, 1);
  m_nModelIndex = this->m_nModelIndex;
  v21 = m_nModelIndex == 465;
  if ( m_nModelIndex != 465 )
    v21 = m_nModelIndex == 501;
  v22 = (unsigned __int16)m_nModelIndex;
  if ( !v21 )
  {
    CAutomobile::DoHeliDustEffect(this, 1.0, 1.0);
    v22 = (unsigned __int16)this->m_nModelIndex;
  }
  if ( (unsigned int)((__int16)v22 - 469) <= 0x1C && ((1 << (v22 + 43)) & 0x100C0001) != 0 || (__int16)v22 == 447 )
  {
    v23 = this->m_aWheelAngularVelocity[1];
    v24 = v23 * 1.66;
  }
  else
  {
    v23 = this->m_aWheelAngularVelocity[1];
    v24 = v23;
  }
  p_m_fMainRotorAngle = &this->m_fMainRotorAngle;
  v26 = CTimer::ms_fTimeStep;
  v27 = this->m_fMainRotorAngle - (float)(v24 * CTimer::ms_fTimeStep);
  this->m_fMainRotorAngle = v27;
  if ( v27 < -6.2832 )
  {
    do
      v27 = v27 + 6.2832;
    while ( v27 < -6.2832 );
    *p_m_fMainRotorAngle = v27;
  }
  v28 = 2.3;
  p_m_fRearRotorAngle = &this->m_fRearRotorAngle;
  if ( v22 == 417 )
    v28 = 2.0;
  for ( j = *p_m_fRearRotorAngle - (float)(v26 * (float)(v23 * v28)); j > 6.2832; j = j + -6.2832 )
    ;
  *p_m_fRearRotorAngle = j;
  v31 = this->m_aCarNodes[12];
  if ( v31 )
  {
    CMatrix::Attach(&v37, &v31->modelling, 0);
    v = *(CVector *)&v37.tx;
    CMatrix::SetRotateZ(&v37, *p_m_fMainRotorAngle);
    v37.tx = v.x + v37.tx;
    v37.ty = v.y + v37.ty;
    v37.tz = v.z + v37.tz;
    CMatrix::UpdateRW(&v37);
  }
  v32 = this->m_aCarNodes[13];
  if ( v32 )
  {
    CMatrix::Attach(&v37, &v32->modelling, 0);
    v = *(CVector *)&v37.tx;
    CMatrix::SetRotateZ(&v37, *p_m_fMainRotorAngle);
    v37.tx = v.x + v37.tx;
    v37.ty = v.y + v37.ty;
    v37.tz = v.z + v37.tz;
    CMatrix::UpdateRW(&v37);
  }
  v33 = this->m_aCarNodes[14];
  if ( v33 )
  {
    CMatrix::Attach(&v37, &v33->modelling, 0);
    v = *(CVector *)&v37.tx;
    CMatrix::SetRotateX(&v37, *p_m_fRearRotorAngle);
    v37.tx = v.x + v37.tx;
    v37.ty = v.y + v37.ty;
    v37.tz = v.z + v37.tz;
    CMatrix::UpdateRW(&v37);
  }
  v34 = this->m_aCarNodes[15];
  if ( v34 )
  {
    CMatrix::Attach(&v37, &v34->modelling, 0);
    v = *(CVector *)&v37.tx;
    CMatrix::SetRotateX(&v37, *p_m_fRearRotorAngle);
    v37.tx = v.x + v37.tx;
    v37.ty = v.y + v37.ty;
    v37.tz = v.z + v37.tz;
    CMatrix::UpdateRW(&v37);
  }
  CShadows::StoreShadowForVehicle(this, VEHICLE_SHADOW_HELI);
  CMatrix::~CMatrix(&v37);
}

//----- (00572CC0) --------------------------------------------------------
void __fastcall CHeli::AddHeliSearchLight(
        const CVector *vecSource,
        const CVector *vecDest,
        const float radius,
        const float brightness,
        UInt32 UniqueID,
        bool8 clipIfColliding,
        bool8 bRenderGroundLight)
{
  UInt32 v7; // lr
  __int64 v8; // kr00_8
  RwReal z; // r0
  HeliSearchLight *v10; // r5
  __int64 v11; // kr08_8

  v7 = CHeli::NumberOfSearchLights;
  v8 = *(_QWORD *)&vecSource->x;
  z = vecSource->z;
  v10 = &CHeli::HeliSearchLights[CHeli::NumberOfSearchLights];
  *(_QWORD *)&v10->vecSourcePosition.x = v8;
  v10->vecSourcePosition.z = z;
  v11 = *(_QWORD *)&vecDest->x;
  v10->vecTargetPosition.z = vecDest->z;
  *(_QWORD *)&v10->vecTargetPosition.x = v11;
  v10->radius = radius;
  v10->brightness = brightness;
  v10->UniqueID = UniqueID;
  v10->ClipIfColliding = clipIfColliding;
  v10->bRenderGroundLight = bRenderGroundLight;
  CHeli::NumberOfSearchLights = v7 + 1;
}

//----- (00572D2C) --------------------------------------------------------
void __fastcall CHeli::Render(CHeli *this)
{
  uint8 m_colour3; // r3
  uint8 m_colour1; // r1
  CVehicleModelInfo *v4; // r0
  uint8 m_colour2; // r2
  uint8 col4; // lr
  RwFrame_0 *v7; // r0
  RwFrame_0 *v8; // r0
  RwFrame_0 *v9; // r0
  RwFrame_0 *v10; // r0
  RpAtomic_0 *data[3]; // [sp+4h] [bp-Ch] BYREF

  gVehicleDistanceFromCamera = gVehicleDistanceFromCamera * 0.6;
  m_colour3 = this->m_colour3;
  m_colour1 = this->m_colour1;
  v4 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  m_colour2 = this->m_colour2;
  col4 = this->m_colour4;
  this->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds + 3000;
  CVehicleModelInfo::SetVehicleColour(v4, m_colour1, m_colour2, m_colour3, col4);
  data[0] = 0;
  v7 = this->m_aCarNodes[12];
  if ( v7 )
  {
    RwFrameForAllObjects(v7, GetCurrentAtomicObjectCB, data);
    if ( data[0] )
      CVehicle::SetComponentAtomicAlpha(data[0], 255);
  }
  data[0] = 0;
  v8 = this->m_aCarNodes[14];
  if ( v8 )
  {
    RwFrameForAllObjects(v8, GetCurrentAtomicObjectCB, data);
    if ( data[0] )
      CVehicle::SetComponentAtomicAlpha(data[0], 255);
  }
  data[0] = 0;
  v9 = this->m_aCarNodes[13];
  if ( v9 )
  {
    RwFrameForAllObjects(v9, GetCurrentAtomicObjectCB, data);
    if ( data[0] )
      CVehicle::SetComponentAtomicAlpha(data[0], 0);
  }
  data[0] = 0;
  v10 = this->m_aCarNodes[15];
  if ( v10 )
  {
    RwFrameForAllObjects(v10, GetCurrentAtomicObjectCB, data);
    if ( data[0] )
      CVehicle::SetComponentAtomicAlpha(data[0], 0);
  }
  CEntity::Render(this);
}

//----- (00572E30) --------------------------------------------------------
void __fastcall CHeli::Fix(CHeli *this)
{
  CDamageManager::ResetDamageStatus(&this->Damage);
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x10000u;
}

//----- (00572E4C) --------------------------------------------------------
void __fastcall CHeli::SetupDamageAfterLoad(CHeli *this)
{
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x10000u;
}

//----- (00572E5C) --------------------------------------------------------
void CHeli::InitHelis()
{
  *(_QWORD *)&CHeli::HeliSearchLights[0].vecSourcePosition.x = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[0].vecSourcePosition.z = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[0].vecTargetPosition.y = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[0].radius = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[1].vecTargetPosition.y = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[1].radius = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[1].vecSourcePosition.x = 0LL;
  *(_QWORD *)&CHeli::HeliSearchLights[1].vecSourcePosition.z = 0LL;
  CHeli::pHelis[0] = 0;
  CHeli::pHelis[1] = 0;
  CHeli::NumberOfSearchLights = 0;
  CHeli::bPoliceHelisAllowed = 1;
}

//----- (00572EBC) --------------------------------------------------------
void CHeli::UpdateHelis()
{
  int v0; // r4
  CWanted *PlayerWanted; // r0
  Int32 v2; // r0
  int v3; // r10
  int v4; // r9
  int v5; // r0
  int v6; // r3
  int v7; // r2
  CHeli *v8; // r1
  int v9; // r2
  int v10; // r0
  int v11; // r0
  _BOOL4 v12; // r2
  bool v13; // r5
  int v14; // r2
  CPlayerPed *PlayerPed; // r0
  CHeli *Heli; // r0
  CEntity **v17; // r1
  bool v18; // nf
  CHeli *v19; // r0
  bool v20; // nf
  CHeli *v21; // r1
  bool v22; // zf
  bool v23; // zf
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float32x2_t v26; // d16
  unsigned __int64 v27; // d1
  CMatrix *v28; // r1
  CSimpleTransform *p_m_transform; // r2
  float32x2_t v30; // d16
  unsigned __int64 v31; // d1
  int v32; // [sp+4h] [bp-2Ch]
  CVector v33; // [sp+8h] [bp-28h] BYREF

  v0 = 0;
  CHeli::NumberOfSearchLights = 0;
  PlayerWanted = FindPlayerWanted(-1);
  v2 = CWanted::NumOfHelisRequired(PlayerWanted);
  if ( CHeli::pHelis[0] )
  {
    if ( CHeli::pHelis[0]->m_nModelIndex == 497 )
    {
      v3 = 0;
      if ( (*((_BYTE *)&CHeli::pHelis[0]->m_nPhysicalFlags + 3) & 0x20) == 0
        && (*((_BYTE *)&CHeli::pHelis[0]->m_nVehicleFlags + 3) & 0x40) == 0 )
      {
        v3 = 1;
      }
    }
    else
    {
      v3 = 0;
    }
    v0 = 1;
  }
  else
  {
    v3 = 0;
  }
  if ( CHeli::pHelis[1] )
  {
    v4 = v2;
    v32 = v0 + 1;
    if ( CHeli::pHelis[1]->m_nModelIndex == 497 && (*((_BYTE *)&CHeli::pHelis[1]->m_nPhysicalFlags + 3) & 0x20) == 0 )
      v3 |= (*((_BYTE *)&CHeli::pHelis[1]->m_nVehicleFlags + 3) & 0x40) == 0;
  }
  else
  {
    v32 = v0;
    v4 = v2;
  }
  v5 = CCullZones::PlayerNoRain();
  v6 = 0;
  v7 = 0;
  v8 = CHeli::pHelis[0];
  if ( CWeather::NewWeatherType == 19 )
    v7 = 1;
  v9 = v7 | (CWeather::OldWeatherType == 19);
  v10 = v5 | (CGame::currArea != AREA_MAIN_MAP) | !CHeli::bPoliceHelisAllowed;
  if ( CHeli::pHelis[0] )
  {
    if ( CHeli::pHelis[0]->m_nModelIndex != 488 )
      v6 = 1;
    v3 &= v6;
  }
  v11 = v10 | v9;
  if ( CHeli::pHelis[1] )
    v3 = (unsigned __int8)v3 & (CHeli::pHelis[1]->m_nModelIndex != 488);
  if ( v11 )
    v4 = 0;
  v12 = CWanted::bUseNewsHeliInAdditionToPolice;
  v13 = v3 & v12;
  if ( (v3 & v12) != 0 )
    v14 = 9776;
  else
    v14 = 9956;
  if ( *((_BYTE *)&CStreaming::ms_aInfoForModel[0].m_nextIndex + v14) == 1
    && CTimer::m_snTimeInMilliseconds > CHeli::TestForNewRandomHelisTimer )
  {
    CHeli::TestForNewRandomHelisTimer = CTimer::m_snTimeInMilliseconds + 15000;
    if ( v32 < v4 )
    {
      PlayerPed = FindPlayerPed(-1);
      Heli = CHeli::GenerateHeli(PlayerPed, v13);
      if ( CHeli::pHelis[0] )
      {
        if ( CHeli::pHelis[1] )
        {
LABEL_36:
          v8 = CHeli::pHelis[0];
          goto LABEL_37;
        }
        CHeli::pHelis[1] = Heli;
        v17 = &CHeli::pHelis[1];
      }
      else
      {
        v17 = CHeli::pHelis;
        CHeli::pHelis[0] = Heli;
      }
      CEntity::RegisterReference(Heli, v17);
      goto LABEL_36;
    }
  }
LABEL_37:
  if ( !v8 )
    goto LABEL_44;
  v18 = (*((_BYTE *)&v8->m_nPhysicalFlags + 3) & 0x20) != 0;
  if ( (*((_BYTE *)&v8->m_nPhysicalFlags + 3) & 0x20) == 0 )
    v18 = (*((_BYTE *)&v8->m_nVehicleFlags + 3) & 0x40) != 0;
  if ( v18 )
  {
    v8->AutoPilot.Mission = 42;
LABEL_43:
    CHeli::pHelis[0] = 0;
    goto LABEL_44;
  }
  if ( v8->AutoPilot.Mission == 42 )
  {
    FindPlayerCoors(&v33, -1);
    m_pMat = CHeli::pHelis[0]->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &CHeli::pHelis[0]->m_transform;
    v26.n64_u64[0] = vsub_f32(*(float32x2_t *)&v33.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v27 = vmul_f32(v26, v26).n64_u64[0];
    if ( fabsf(
           sqrtf(
             (float)((float)((float)(v33.x - p_tx->m_translate.x) * (float)(v33.x - p_tx->m_translate.x))
                   + *(float *)&v27)
           + *((float *)&v27 + 1))) > 170.0 )
    {
      CWorld::Remove(CHeli::pHelis[0]);
      if ( CHeli::pHelis[0] )
        (*((void (__fastcall **)(CHeli *))CHeli::pHelis[0]->_vptr$CPlaceable + 1))(CHeli::pHelis[0]);
      goto LABEL_43;
    }
  }
LABEL_44:
  v19 = CHeli::pHelis[1];
  if ( CHeli::pHelis[1] )
  {
    v20 = (*((_BYTE *)&CHeli::pHelis[1]->m_nPhysicalFlags + 3) & 0x20) != 0;
    if ( (*((_BYTE *)&CHeli::pHelis[1]->m_nPhysicalFlags + 3) & 0x20) == 0 )
      v20 = (*((_BYTE *)&CHeli::pHelis[1]->m_nVehicleFlags + 3) & 0x40) != 0;
    if ( v20 )
    {
      CHeli::pHelis[1]->AutoPilot.Mission = 42;
LABEL_50:
      v19 = 0;
      CHeli::pHelis[1] = 0;
      goto LABEL_52;
    }
    if ( CHeli::pHelis[1]->AutoPilot.Mission == 42 )
    {
      FindPlayerCoors(&v33, -1);
      v19 = CHeli::pHelis[1];
      v28 = CHeli::pHelis[1]->m_pMat;
      p_m_transform = (CSimpleTransform *)&v28->tx;
      if ( !v28 )
        p_m_transform = &CHeli::pHelis[1]->m_transform;
      v30.n64_u64[0] = vsub_f32(*(float32x2_t *)&v33.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
      v31 = vmul_f32(v30, v30).n64_u64[0];
      if ( fabsf(
             sqrtf(
               (float)((float)((float)(v33.x - p_m_transform->m_translate.x)
                             * (float)(v33.x - p_m_transform->m_translate.x))
                     + *(float *)&v31)
             + *((float *)&v31 + 1))) > 170.0 )
      {
        CWorld::Remove(CHeli::pHelis[1]);
        if ( CHeli::pHelis[1] )
          (*((void (__fastcall **)(CHeli *))CHeli::pHelis[1]->_vptr$CPlaceable + 1))(CHeli::pHelis[1]);
        goto LABEL_50;
      }
    }
  }
  else
  {
    v19 = 0;
  }
LABEL_52:
  v21 = CHeli::pHelis[0];
  v22 = CHeli::pHelis[0] == 0;
  if ( CHeli::pHelis[0] )
    v22 = CHeli::pHelis[0]->AutoPilot.Mission == 42;
  if ( !v22 )
  {
    if ( v4 < 1 )
    {
      CHeli::pHelis[0]->m_MinHeightAboveTerrain = 100.0;
      v21->AutoPilot.Mission = 42;
      v21->m_LowestFlightHeight = 100.0;
    }
    else
    {
      --v4;
    }
  }
  v23 = v19 == 0;
  if ( v19 )
    v23 = v19->AutoPilot.Mission == 42;
  if ( !v23 && v4 <= 0 )
  {
    v19->m_MinHeightAboveTerrain = 100.0;
    v19->AutoPilot.Mission = 42;
    v19->m_LowestFlightHeight = 100.0;
  }
}

//----- (005732D0) --------------------------------------------------------
CHeli *__fastcall CHeli::GenerateHeli(CPed *pTargetPed, bool bNewsHeli)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d2
  float32x2_t v4; // d4
  float32x2_t v5; // d9
  _BOOL4 v7; // r8
  CAutomobile *v8; // r0
  CAutomobile *v9; // r4
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  char v11; // r5
  uint32 v12; // r0
  int v13; // r1
  int v14; // r0
  CSimpleTransform *p_m_transform; // r11
  CSimpleTransform *p_tx; // r1
  CMatrix *m_pMat; // r0
  float x; // s22
  float y; // s24
  float z; // s18
  float v21; // s16
  float v22; // r5
  float v23; // s2
  float v24; // r6
  float v25; // s0
  CMatrix *v26; // r0
  CSimpleTransform *v27; // r1
  float v28; // s0
  CMatrix *v29; // r0
  float GroundZForCoord; // r0
  float v31; // r2
  CPed **p_pTargetEntity; // r0
  char v33; // r1
  CMatrix *v34; // r5
  float v35; // r6
  float v36; // r0

  v7 = bNewsHeli;
  v8 = (CAutomobile *)CVehicle::operator new(0xA2Cu);
  v9 = v8;
  if ( v7 )
    CAutomobile::CAutomobile(v8, 488, 4u, 1u);
  else
    CAutomobile::CAutomobile(v8, 497, 4u, 1u);
  v9->m_vehicleType = 3;
  v9[1].m_vecAverageMoveSpeed.x = 0.0;
  *(_DWORD *)&v9[1].m_iplIndex = 0;
  m_nPhysicalFlags = v9->m_nPhysicalFlags;
  *(_QWORD *)&v9[1].m_transform.m_heading = 0LL;
  *(_QWORD *)&v9[1].m_pRwObject = 0LL;
  v11 = (char)v9[1]._vptr$CPlaceable;
  *(_QWORD *)&v9[1].m_transform.m_translate.x = 0LL;
  *(_QWORD *)&v9[1].m_transform.m_translate.z = 0LL;
  *(_QWORD *)&v9[1].m_nFlags.bdummy = 0x4120000041200000LL;
  *(_QWORD *)&v9[1].pReferences = 1092616192LL;
  HIBYTE(v9[1].m_nScanCode) = 4;
  LOBYTE(v9[1]._vptr$CPlaceable) = v11 & 0xFC;
  v9->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x1000000);
  v9->_vptr$CPlaceable = (int (**)(void))&off_66DB34;
  v12 = CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)&v9[1].m_vecTurnSpeed.y = 0LL;
  *(_QWORD *)&v9[1].m_vecMoveFriction.x = 0LL;
  *(_QWORD *)&v9[1].m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&v9[1].m_vecMoveSpeed.z = 0LL;
  *(_QWORD *)&v9[1].numLodChildren = 0LL;
  *(_QWORD *)&v9[1].m_LastCollisionTime = 0LL;
  v9[1].m_vecAverageMoveSpeed.y = 0.0;
  LODWORD(v9[1].m_vecMoveFriction.z) = v12;
  LODWORD(v9[1].m_vecAverageMoveSpeed.z) = v12;
  v9->AutoPilot.TargetReachedDist = 10;
  v9[1].m_vecAverageTurnSpeed.x = 0.0;
  v13 = *((_DWORD *)&v9->m_nVehicleFlags + 1);
  LOBYTE(v9[1].m_vecAverageTurnSpeed.y) = 16;
  LOBYTE(v9[1].m_nScanCode) = 0;
  BYTE1(v9[1].m_vecAverageTurnSpeed.y) = 0;
  *((_DWORD *)&v9->m_nVehicleFlags + 1) = v13 | 0x40;
  v14 = rand();
  p_m_transform = &pTargetPed->m_transform;
  p_tx = &pTargetPed->m_transform;
  v9[1].m_vecAverageTurnSpeed.z = (float)((float)((float)v14 * 4.6566e-10) * 6.0) + 2.0;
  m_pMat = pTargetPed->m_pMat;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  v21 = (float)(unsigned __int8)rand() * 0.024531;
  v22 = cosf(v21);
  v2.n64_f32[0] = y + (float)(sinf(v21) * 250.0);
  if ( v2.n64_f32[0] > 3000.0
    || (v23 = x + (float)(v22 * 250.0), v23 < -3000.0)
    || v23 > 3000.0
    || v2.n64_f32[0] < -3000.0 )
  {
    v21 = v21 + 3.1416;
    v24 = cosf(v21);
    v25 = sinf(v21);
    v26 = pTargetPed->m_pMat;
    v27 = &pTargetPed->m_transform;
    v28 = v25 * 250.0;
    if ( v26 )
      v27 = (CSimpleTransform *)&v26->tx;
    z = v27->m_translate.z;
    v2.n64_f32[0] = v27->m_translate.y + v28;
    v23 = v27->m_translate.x + (float)(v24 * 250.0);
  }
  if ( sqrtf(
         (float)((float)(v23 + 2322.0) * (float)(v23 + 2322.0))
       + (float)((float)(v2.n64_f32[0] + 1653.0) * (float)(v2.n64_f32[0] + 1653.0))) >= 350.0 )
  {
    v5.n64_f32[0] = z + 50.0;
  }
  else
  {
    v29 = pTargetPed->m_pMat;
    v4.n64_u32[0] = 1141637120;
    if ( v29 )
      p_m_transform = (CSimpleTransform *)&v29->tx;
    v23 = p_m_transform->m_translate.x;
    v3.n64_f32[0] = p_m_transform->m_translate.z + 200.0;
    v2.n64_u32[0] = LODWORD(p_m_transform->m_translate.y);
    v5.n64_u64[0] = vmax_f32(v3, v4).n64_u64[0];
  }
  GroundZForCoord = CWorld::FindGroundZForCoord(v23, v2.n64_f32[0]);
  v31 = v2.n64_f32[0];
  v2.n64_f32[0] = GroundZForCoord + 20.0;
  CMatrix::SetTranslate(v9->m_pMat, v23, v31, vmax_f32(v5, v2).n64_f32[0]);
  v9->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v9->m_info & 7 | 0x18);
  *(_DWORD *)&v9->m_nVehicleFlags |= 8u;
  if ( v7 )
  {
    v9->AutoPilot.Mission = 41;
    v9->AutoPilot.pTargetEntity = FindPlayerPed(-1);
    p_pTargetEntity = (CPed **)&v9->AutoPilot.pTargetEntity;
    v33 = 35;
  }
  else
  {
    v33 = 70;
    v9->AutoPilot.Mission = 40;
    p_pTargetEntity = (CPed **)&v9->AutoPilot.pTargetEntity;
  }
  v9[1].m_nFlags.bdummy = 1101004800;
  v9->AutoPilot.CruiseSpeed = v33;
  v9[1].pReferences = (CReference *)1094713344;
  *p_pTargetEntity = pTargetPed;
  if ( v7 )
  {
    v9[1].m_nFlags.bdummy = 1106247680;
    v9[1].pReferences = (CReference *)1104674816;
  }
  v34 = v9->m_pMat;
  v9->m_aWheelAngularVelocity[1] = 0.165;
  v34->zx = 0.0;
  v34->zy = 0.0;
  v34->xz = 0.0;
  v34->yz = 0.0;
  v34->zz = 1.0;
  v35 = cosf(v21 + 3.1416);
  LODWORD(v34->yx) = LODWORD(v35) ^ 0x80000000;
  v36 = sinf(v21 + 3.1416);
  v34->xx = v36;
  v34->xy = v35;
  v34->yy = v36;
  CWorld::Add(v9);
  CVehicle::SetUpDriver(v9, -1, 0, 0);
  return (CHeli *)v9;
}
// 57351E: variable 'v3' is possibly undefined
// 57351E: variable 'v4' is possibly undefined
// 57354E: variable 'v5' is possibly undefined
// 57354E: variable 'v2' is possibly undefined
// 66DB34: using guessed type void *off_66DB34;

//----- (005736A0) --------------------------------------------------------
void CHeli::RenderAllHeliSearchLights()
{
  int v0; // r5
  int v1; // r0
  HeliSearchLight *v2; // r4
  float v3; // [sp+30h] [bp-30h]
  float v4; // [sp+34h] [bp-2Ch]
  float v5; // [sp+38h] [bp-28h]

  if ( CHeli::NumberOfSearchLights )
  {
    v0 = 0;
    v1 = 0;
    do
    {
      v2 = &CHeli::HeliSearchLights[v1];
      CHeli::SearchLightCone(
        v2->UniqueID,
        v2->vecSourcePosition,
        v2->vecTargetPosition,
        v2->radius,
        v2->brightness,
        0,
        v2->bRenderGroundLight,
        &v2->vecEllipseCentre,
        &v2->vecEllipseForward,
        &v2->vecEllipseSide,
        0,
        0.05,
        v3,
        v4,
        v5);
      v1 = (unsigned __int8)++v0;
    }
    while ( CHeli::NumberOfSearchLights > (unsigned __int8)v0 );
  }
}
// 57371C: variable 'v3' is possibly undefined
// 57371C: variable 'v4' is possibly undefined
// 57371C: variable 'v5' is possibly undefined

//----- (00573740) --------------------------------------------------------
void __fastcall CHeli::SearchLightCone(
        Int32 UniqueID,
        CVector position,
        CVector targetPos,
        float radius,
        float brightness,
        bool8 clipIfColliding,
        int doGroundLight,
        CVector *pVecEllipseCentre,
        CVector *pVecEllipseForward,
        CVector *pVecEllipseSide,
        bool bFromScript,
        float topRadius,
        float normalX,
        float normalY,
        float normalZ)
{
  int32x2_t v15; // d1
  float32x2_t v16; // d3
  int32x2_t v17; // d11
  float32x2_t v18; // d13
  float32x2_t v20; // d14
  float x; // s24
  float32x2_t v22; // d8
  float v23; // s18
  CSimpleTransform *p_tx; // r2
  RwReal v25; // s4
  float v26; // s6
  float v27; // s0
  float32x2_t v28; // d15
  int v29; // r10
  float v30; // s21
  float32x2_t v31; // d8
  float32x2_t v32; // d14
  int v33; // r9
  float v34; // r4
  float v35; // r0
  float32x2_t v36; // d16
  float32x2_t v37; // d0
  float32x2_t v38; // d17
  float32x2_t v39; // d5
  float32x2_t v40; // d9
  float v41; // s2
  float v42; // s12
  float v43; // s24
  float v44; // s6
  float32x2_t v45; // d2
  float *v46; // r0
  float32x2_t v47; // d16
  unsigned __int64 v48; // d6
  float32x2_t *v49; // r0
  int v50; // r0
  int v51; // r2
  Int32 v52; // r1
  RwImVertexIndex *v53; // r6
  RwImVertexIndex *v54; // r2
  signed int v55; // r1
  float *v56; // r3
  float *v57; // r6
  signed int v58; // r2
  RwRGBA_0 *p_color; // r0
  float v60; // s2
  float v61; // s4
  __int64 v62; // d16
  float z; // s2
  RwReal v64; // s14
  float v65; // s6
  float v66; // s0
  float v67; // s8
  float v68; // s4
  RwReal v69; // s10
  float v70; // s0
  float v71; // s6
  float v72; // s4
  float v73; // s2
  CSimpleTransform *p_m_transform; // r2
  float32x2_t v75; // d16
  unsigned __int64 v76; // d4
  float v77; // s8
  CVector v78; // [sp+7Ch] [bp-3C4h] BYREF
  CVector v79; // [sp+88h] [bp-3B8h] BYREF
  CVector v80; // [sp+94h] [bp-3ACh] BYREF
  CVector v2; // [sp+A0h] [bp-3A0h] BYREF
  CVector Coors; // [sp+ACh] [bp-394h] BYREF
  CVector v83; // [sp+B8h] [bp-388h] BYREF
  CEntity *refEntityPtr; // [sp+C4h] [bp-37Ch] BYREF
  CColPoint colPoint; // [sp+C8h] [bp-378h] BYREF
  CVector v1; // [sp+F4h] [bp-34Ch] BYREF
  _DWORD v87[82]; // [sp+100h] [bp-340h] BYREF
  float v88[82]; // [sp+248h] [bp-1F8h] BYREF
  _DWORD v89[3]; // [sp+390h] [bp-B0h] BYREF
  int v90; // [sp+39Ch] [bp-A4h] BYREF
  float v91[3]; // [sp+3A8h] [bp-98h] BYREF
  float v92[3]; // [sp+3B4h] [bp-8Ch] BYREF
  CVector vecEnd; // [sp+3C0h] [bp-80h] BYREF
  CVector vecStart; // [sp+3D0h] [bp-70h] BYREF

  vecStart = position;
  v1.y = targetPos.y - position.y;
  v1.x = targetPos.x - position.x;
  v1.z = targetPos.z - position.z;
  CVector::Normalise(&v1);
  vecEnd.x = (float)(v1.x * 3.0) + targetPos.x;
  vecEnd.y = (float)(v1.y * 3.0) + targetPos.y;
  vecEnd.z = (float)(v1.z * 3.0) + targetPos.z;
  if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 0) == 1 )
    vecEnd = colPoint.m_vecPosition;
  v17.n64_f32[0] = topRadius;
  v20.n64_u64[0] = *(unsigned __int64 *)&v1.y;
  x = v1.x;
  v22.n64_u64[0] = *(unsigned __int64 *)&vecStart.y;
  v23 = vecStart.x;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v15.n64_f32[0] = p_tx->m_translate.y - vecStart.y;
  v25 = p_tx->m_translate.z - vecStart.z;
  v83.x = p_tx->m_translate.x - vecStart.x;
  LODWORD(v83.y) = v15.n64_u32[0];
  v83.z = v25;
  CVector::Normalise(&v83);
  v18.n64_u32[0] = 0;
  v16.n64_f32[0] = (float)((float)(v1.x * v83.x) + (float)(v1.y * v83.y)) + (float)(v1.z * v83.z);
  v26 = vmax_f32(v16, v18).n64_f32[0];
  Coors.x = (float)(v83.x * 15.0) + vecStart.x;
  Coors.y = (float)(v83.y * 15.0) + vecStart.y;
  Coors.z = (float)(v83.z * 15.0) + vecStart.z;
  v27 = v26 * (float)(v26 * (float)(v26 * (float)(v26 * (float)(v26 * v26))));
  CCoronas::RegisterCorona(
    UniqueID,
    0,
    0xC8u,
    0xC8u,
    0xFFu,
    (unsigned int)(float)(v27 * 255.0),
    &Coors,
    v27 * 20.0,
    100.0,
    0,
    0,
    1u,
    0,
    0,
    0.0,
    0,
    1.5,
    0,
    15.0,
    0,
    0);
  v28.n64_u64[0] = vdup_lane_s32(v17, 0).n64_u64[0];
  v15.n64_f32[0] = radius;
  v29 = 0;
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
  v30 = (float)(x * 100.0) + v23;
  v31.n64_u64[0] = vadd_f32(vmul_f32(v20, (float32x2_t)0x42C8000042C80000LL), v22).n64_u64[0];
  v32.n64_u64[0] = vdup_lane_s32(v15, 0).n64_u64[0];
  do
  {
    v33 = 0;
    v2.x = 0.0;
    v2.y = 0.0;
    v2.z = 1.0;
    CrossProduct(&v80, &v1, &v2);
    CVector::Normalise(&v80);
    CrossProduct(&v79, &v80, &v1);
    CVector::Normalise(&v79);
    v34 = sinf((float)v29 * 0.15708);
    v35 = cosf((float)v29 * 0.15708);
    v36.n64_u64[0] = vmul_n_f32(*(float32x2_t *)&v80.y, v34).n64_u64[0];
    v37.n64_u64[0] = *(unsigned __int64 *)&vecStart.y;
    v38.n64_u64[0] = vmul_n_f32(*(float32x2_t *)&v79.y, v35).n64_u64[0];
    v39.n64_u64[0] = vadd_f32(vadd_f32(v31, vmul_f32(v32, v36)), vmul_f32(v32, v38)).n64_u64[0];
    v40.n64_u64[0] = vadd_f32(vadd_f32(vmul_f32(v28, v36), *(float32x2_t *)&vecStart.y), vmul_f32(v28, v38)).n64_u64[0];
    v41 = vecStart.x;
    v42 = (float)(v40.n64_f32[1] - vecEnd.z) / (float)(v40.n64_f32[1] - v39.n64_f32[1]);
    v43 = (float)((float)((float)(v34 * v80.x) * topRadius) + vecStart.x) + (float)((float)(v35 * v79.x) * topRadius);
    v44 = v43
        + (float)((float)((float)((float)(v30 + (float)((float)(v34 * v80.x) * radius))
                                + (float)((float)(v35 * v79.x) * radius))
                        - v43)
                * v42);
    v45.n64_u64[0] = vadd_f32(v40, vmul_n_f32(vsub_f32(v39, v40), v42)).n64_u64[0];
    v46 = (float *)v89;
    switch ( v29 )
    {
      case 0:
        goto LABEL_10;
      case 10:
        v33 = 1;
        v46 = (float *)&v90;
        goto LABEL_10;
      case 20:
        v33 = 2;
        v46 = v91;
        goto LABEL_10;
      case 30:
        v46 = v92;
        v33 = 3;
LABEL_10:
        *v46 = v44;
        *(float32x2_t *)&v89[3 * v33 + 1] = v45;
        break;
      default:
        break;
    }
    v47.n64_u64[0] = vsub_f32(v45, v40).n64_u64[0];
    v48 = vmul_f32(v47, v47).n64_u64[0];
    if ( sqrtf(*((float *)&v48 + 1) + (float)((float)((float)(v44 - v43) * (float)(v44 - v43)) + *(float *)&v48)) > 100.0 )
    {
      *(float32x2_t *)&v78.y = v47;
      v78.x = v44 - v43;
      CVector::Normalise(&v78);
      v45.n64_f32[1] = v40.n64_f32[1] + (float)(v78.z * 100.0);
      v44 = v43 + (float)(v78.x * 100.0);
      v37.n64_u64[0] = *(unsigned __int64 *)&vecStart.y;
      v45.n64_f32[0] = v40.n64_f32[0] + (float)(v78.y * 100.0);
      v41 = vecStart.x;
    }
    v37.n64_f32[0] = v40.n64_f32[0] - v37.n64_f32[0];
    v49 = (float32x2_t *)&TempVertexBuffer.m_3d[TempBufferVerticesStored];
    v49[4].n64_f32[1] = v44;
    v49[5].n64_u64[0] = v45.n64_u64[0];
    v49[1].n64_u32[0] = v40.n64_u32[1];
    v49->n64_f32[0] = v43;
    v49->n64_u32[1] = v40.n64_u32[0];
    v40.n64_f32[0] = CCustomBuildingDNPipeline::m_fDNBalanceParam;
    LODWORD(v78.y) = v37.n64_u32[0];
    v78.x = v43 - v41;
    v78.z = v40.n64_f32[1] - v37.n64_f32[1];
    CVector::Normalise(&v78);
    v50 = TempBufferVerticesStored;
    v51 = TempBufferVerticesStored + 1;
    v37.n64_f32[0] = fabsf((float)((float)(v83.x * v78.x) + (float)(v83.y * v78.y)) + (float)(v83.z * v78.z));
    v88[TempBufferVerticesStored] = (float)(v40.n64_f32[0] * 0.15) + 0.1;
    v37.n64_f32[0] = v37.n64_f32[0] * v37.n64_f32[0];
    v18.n64_u64[0] = vmax_f32(v37, v18).n64_u64[0];
    v87[v50] = v37.n64_u32[0];
    v88[v51] = 0.0;
    v87[v51] = v37.n64_u32[0];
    if ( v29 != 40 )
    {
      v52 = TempBufferIndicesStored;
      v53 = &TempBufferRenderIndexList[TempBufferIndicesStored];
      *v53 = v50;
      v53[1] = v50 + 3;
      v53[2] = v51;
      TempBufferIndicesStored = v52 + 3;
      if ( topRadius > 0.0 )
      {
        TempBufferRenderIndexList[v52 + 3] = v50;
        v54 = &TempBufferRenderIndexList[v52];
        v54[5] = v50 + 3;
        v54[4] = v50 + 2;
        TempBufferIndicesStored = v52 + 6;
      }
    }
    v55 = v50 + 2;
    ++v29;
    TempBufferVerticesStored = v50 + 2;
  }
  while ( v29 != 41 );
  if ( v50 >= -1 )
  {
    v56 = v88;
    v57 = (float *)v87;
    v58 = 0;
    p_color = &TempVertexBuffer.m_3d[0].color;
    do
    {
      v60 = *v57;
      ++v58;
      v61 = *v56;
      ++v57;
      ++v56;
      *p_color = (RwRGBA_0)((unsigned int)(float)((float)((float)(v61 * v60) / v18.n64_f32[0]) * 200.0) | ((unsigned int)(float)((float)((float)(v61 * v60) / v18.n64_f32[0]) * 200.0) << 8) | ((unsigned int)(float)((float)((float)(v61 * v60) / v18.n64_f32[0]) * 255.0) << 16));
      p_color += 9;
    }
    while ( v58 < v55 );
  }
  if ( TempBufferIndicesStored > 0 && RwIm3DTransform(TempVertexBuffer.m_3d, v55, 0, 0x18u) )
  {
    RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
    RwIm3DEnd();
  }
  v62 = *(_QWORD *)&vecEnd.x;
  v2 = vecEnd;
  z = vecEnd.z;
  v64 = v91[2] - vecEnd.z;
  v65 = v91[0] - vecEnd.x;
  v66 = v91[1] - vecEnd.y;
  v67 = v92[0] - vecEnd.x;
  v68 = v92[1] - vecEnd.y;
  v69 = v92[2] - vecEnd.z;
  pVecEllipseCentre->z = vecEnd.z;
  *(_QWORD *)&pVecEllipseCentre->x = v62;
  pVecEllipseForward->x = v65;
  pVecEllipseForward->y = v66;
  pVecEllipseForward->z = v64;
  pVecEllipseSide->x = v67;
  pVecEllipseSide->y = v68;
  pVecEllipseSide->z = v69;
  if ( doGroundLight )
  {
    v70 = v66 * 1.2;
    v71 = v65 * 1.2;
    v2.z = z + 5.0;
    if ( sqrtf((float)(v71 * v71) + (float)(v70 * v70)) < 100.0 )
    {
      v72 = v68 * 1.2;
      v73 = v67 * 1.2;
      if ( sqrtf((float)(v73 * v73) + (float)(v72 * v72)) < 100.0 )
      {
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        v75.n64_u64[0] = vsub_f32(*(float32x2_t *)&vecEnd.x, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
        v76 = vmul_f32(v75, v75).n64_u64[0];
        v77 = sqrtf((float)(*(float *)&v76 + *((float *)&v76 + 1)) + 0.0);
        if ( v77 <= 25.0 )
          CShadows::StoreShadowToBeRendered(
            2u,
            gpShadowExplosionTex,
            &v2,
            v71,
            v70,
            v73,
            v72,
            (int)(float)((float)((float)((float)((float)(v77 * -0.04) + 1.0) * brightness) * 0.5) * 128.0),
            (unsigned int)(float)((float)((float)((float)((float)(v77 * -0.04) + 1.0) * brightness) * 0.5) * 200.0),
            (unsigned int)(float)((float)((float)((float)((float)(v77 * -0.04) + 1.0) * brightness) * 0.5) * 200.0),
            (unsigned int)(float)((float)((float)((float)((float)(v77 * -0.04) + 1.0) * brightness) * 0.5) * 255.0),
            15.0,
            1,
            1.0,
            0,
            0);
      }
    }
  }
}
// 5738B8: variable 'v16' is possibly undefined
// 5738B8: variable 'v18' is possibly undefined
// 573932: variable 'v17' is possibly undefined
// 573992: variable 'v15' is possibly undefined
// 573740: using guessed type float var_1F8[82];
// 573740: using guessed type _DWORD var_340[82];

//----- (00573F70) --------------------------------------------------------
bool __fastcall CHeli::TestSniperCollision(CVector *pStartCoors, CVector *pEndCoors)
{
  float32x2_t v4; // d16
  float v5; // s0
  unsigned __int64 v6; // d1
  CMatrix *m_pMat; // r1
  int v8; // r6
  float v9; // s0
  CHeli *v10; // r8
  int (**v11)(void); // r0
  int (*v12)(void); // r10
  CPlayerPed *PlayerPed; // r0
  CMatrix *v15; // r1
  float v16; // s0
  CHeli *v17; // r4
  int (**v18)(void); // r0
  int (*v19)(void); // r6
  CPlayerPed *v20; // r0
  CVector v22; // [sp+0h] [bp-30h] BYREF
  CVector v23; // [sp+Ch] [bp-24h] BYREF

  v4.n64_u64[0] = vsub_f32(*(float32x2_t *)&pEndCoors->x, *(float32x2_t *)&pStartCoors->x).n64_u64[0];
  v5 = pEndCoors->z - pStartCoors->z;
  v6 = vmul_f32(v4, v4).n64_u64[0];
  if ( v5 >= (float)(sqrtf((float)(*(float *)&v6 + *((float *)&v6 + 1)) + (float)(v5 * v5)) * 0.5) )
    return 0;
  if ( !CHeli::pHelis[0] || (*((_BYTE *)&CHeli::pHelis[0]->m_nPhysicalFlags + 2) & 4) != 0 )
  {
    v8 = 0;
  }
  else
  {
    m_pMat = CHeli::pHelis[0]->m_pMat;
    v22.y = 1.49;
    v22.x = -0.43;
    v22.z = 1.5;
    operator*(&v23, m_pMat, &v22);
    v8 = 0;
    if ( CCollision::DistToLine(pStartCoors, pEndCoors, &v23) < 0.8 )
    {
      v9 = 0.0;
      if ( (rand() & 1) != 0 )
        v9 = 1.0;
      v10 = CHeli::pHelis[0];
      v11 = CHeli::pHelis[0]->_vptr$CPlaceable;
      CHeli::pHelis[0]->ZRotSpeed = (float)(v9 * 0.1) + -0.05;
      v12 = v11[42];
      PlayerPed = FindPlayerPed(-1);
      ((void (__fastcall *)(CHeli *, CPlayerPed *, _DWORD))v12)(v10, PlayerPed, 0);
      CHeli::pHelis[0]->m_nSwatOnBoard = 0;
      v8 = 1;
    }
  }
  if ( CHeli::pHelis[1] )
  {
    if ( (*((_BYTE *)&CHeli::pHelis[1]->m_nPhysicalFlags + 2) & 4) == 0 )
    {
      v15 = CHeli::pHelis[1]->m_pMat;
      v22.y = 1.49;
      v22.x = -0.43;
      v22.z = 1.5;
      operator*(&v23, v15, &v22);
      if ( CCollision::DistToLine(pStartCoors, pEndCoors, &v23) < 0.8 )
      {
        v16 = 0.0;
        if ( (rand() & 1) != 0 )
          v16 = 1.0;
        v17 = CHeli::pHelis[1];
        v18 = CHeli::pHelis[1]->_vptr$CPlaceable;
        CHeli::pHelis[1]->ZRotSpeed = (float)(v16 * 0.1) + -0.05;
        v19 = v18[42];
        v20 = FindPlayerPed(-1);
        ((void (__fastcall *)(CHeli *, CPlayerPed *, _DWORD))v19)(v17, v20, 0);
        v8 = 1;
        CHeli::pHelis[1]->m_nSwatOnBoard = 0;
      }
    }
  }
  return v8 != 0;
}

//----- (00574158) --------------------------------------------------------
void CHeli::Pre_SearchLightCone()
{
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_7);
  sub_192840(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
}
// 0: using guessed type int dword_0;
// 7: using guessed type char byte_7;

//----- (005741B0) --------------------------------------------------------
void CHeli::Post_SearchLightCone()
{
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
  sub_192840(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 2);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005741F8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CHeli::BlowUpCar(CHeli *this, CEntity *pCulprit, Bool8 bInACutscene)
{
  int m_nModelIndex; // r0
  bool v6; // zf
  CPlayerInfo *v7; // r0
  float v8; // s0
  int v9; // r0
  unsigned int m_info; // r1
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  int m_nFlags; // r2
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  RpClump_0 *m_pRwObject; // r0
  int v15; // r0
  bool v16; // zf
  char v17; // r1
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  int v21; // r1
  int v22; // r2
  unsigned int v23; // r0
  unsigned int v24; // r1
  int v25; // r0
  bool v26; // zf
  CMatrix *v27; // r0
  __int64 v28; // kr08_8 OVERLAPPED
  CMatrix *v29; // r0
  __int64 v30; // kr10_8 OVERLAPPED
  __int64 bExtinguishEnabled; // [sp+0h] [bp-38h]
  __int64 bExtinguishEnableda; // [sp+0h] [bp-38h]
  int data[7]; // [sp+1Ch] [bp-1Ch] BYREF

  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    if ( *(_BYTE *)&this->m_info < 8u || this->AutoPilot.Mission == 58 )
      goto LABEL_9;
    m_nModelIndex = this->m_nModelIndex;
    v6 = m_nModelIndex == 465;
    if ( m_nModelIndex != 465 )
      v6 = m_nModelIndex == 501;
    if ( v6 )
    {
LABEL_9:
      if ( FindPlayerPed(-1) == pCulprit || FindPlayerVehicle(-1, 0) == pCulprit )
      {
        v7 = &CWorld::Players[CWorld::PlayerInFocus];
        v8 = v7->CurrentChaseValue + 10.0;
        v7->HavocCaused += 20;
        v7->CurrentChaseValue = v8;
        v9 = rand();
        CStats::IncrementStat(0x7Du, (float)(v9 % 6000 + 4000));
      }
      if ( this->m_nModelIndex == 488 )
        CWanted::bUseNewsHeliInAdditionToPolice = 0;
      m_info = (unsigned __int8)this->m_info;
      p_m_nVehicleFlags = &this->m_nVehicleFlags;
      if ( m_info <= 7 )
      {
        this->m_vecTurnSpeed.z = 0.0;
        m_nFlags = (int)this->m_nFlags;
        *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
        *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
        this->m_vecTurnSpeed.y = 0.0;
        *(_DWORD *)&this->m_nFlags = m_nFlags & 0xFFFFFF7E;
      }
      m_nPhysicalFlags = this->m_nPhysicalFlags;
      m_pRwObject = (RpClump_0 *)this->m_pRwObject;
      this->m_info = (CEntity::CEntityInfo)(m_info & 7 | 0x28);
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x20000000);
      this->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
      CVisibilityPlugins::SetClumpForAllAtomicsFlag(m_pRwObject, 0x4000);
      CDamageManager::FuckCarCompletely(&this->Damage, 0);
      v15 = (unsigned __int16)this->m_nModelIndex;
      v16 = v15 == 465;
      if ( v15 != 465 )
        v16 = v15 == 501;
      if ( !v16 )
      {
        CAutomobile::SetBumperDamage(this, FRONT_BUMPER, 0);
        CAutomobile::SetBumperDamage(this, REAR_BUMPER, 0);
        CAutomobile::SetDoorDamage(this, BONNET_0, 0);
        CAutomobile::SetDoorDamage(this, BOOT_0, 0);
        CAutomobile::SetDoorDamage(this, FRONT_LEFT_DOOR_0, 0);
        CAutomobile::SetDoorDamage(this, FRONT_RIGHT_DOOR_0, 0);
        CAutomobile::SetDoorDamage(this, REAR_LEFT_DOOR_0, 0);
        CAutomobile::SetDoorDamage(this, REAR_RIGHT_DOOR_0, 0);
        CAutomobile::SpawnFlyingComponent(this, 5, 1u);
        data[0] = 0;
        RwFrameForAllObjects(this->m_aCarNodes[5], GetCurrentAtomicObjectCB, data);
        if ( data[0] )
          *(_BYTE *)(data[0] + 2) = 0;
      }
      v17 = *((_BYTE *)&this->CVehicle + 1202);
      this->DelayedExplosion = 0;
      m_pMat = this->m_pMat;
      this->m_nHealth = 0.0;
      p_m_transform = &this->m_transform;
      *((_BYTE *)&this->CVehicle + 1202) = v17 & 0xF8;
      p_tx = &this->m_transform;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      CCamera::CamShake(&TheCamera, 0.4, p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z);
      CVehicle::KillPedsInVehicle(this);
      v21 = *((_DWORD *)&this->m_nVehicleFlags + 1);
      v22 = *(_DWORD *)p_m_nVehicleFlags;
      *((_BYTE *)&this->CVehicle + 1202) &= 0xE7u;
      v23 = v21 & 0xFFFF7FFF;
      v24 = v22 & 0xFFFFFFAF;
      *(_DWORD *)p_m_nVehicleFlags = v22 & 0xFFFFFFAF;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v23;
      *(_BYTE *)&this->m_nAutomobileFlags &= ~1u;
      if ( (v22 & 2) != 0 )
      {
        v24 = v22 & 0xFFFFFFAD;
        *(_DWORD *)p_m_nVehicleFlags = v22 & 0xFFFFFFAD;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v23;
        --CCarCtrl::NumAmbulancesOnDuty;
      }
      if ( (v24 & 4) != 0 )
      {
        *(_DWORD *)p_m_nVehicleFlags = v24 & 0xFFFFFFAB;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v23 & 0xFFFF7FFF;
        --CCarCtrl::NumFireTrucksOnDuty;
      }
      CVehicle::ChangeLawEnforcerState(this, 0);
      CFireManager::StartFire(&gFireManager, this, pCulprit, 0.8, 1u, 7000, 0);
      CDarkel::RegisterCarBlownUpByPlayer(this, 0);
      v25 = (unsigned __int16)this->m_nModelIndex;
      v26 = v25 == 501;
      if ( v25 != 501 )
        v26 = v25 == 465;
      if ( v26 )
      {
        v27 = this->m_pMat;
        if ( v27 )
          p_m_transform = (CSimpleTransform *)&v27->tx;
        v28 = *(_QWORD *)&p_m_transform->m_translate.x;
        bExtinguishEnabled = *(_QWORD *)&p_m_transform->m_translate.y;
        CExplosion::AddExplosion(this, pCulprit, EXP_TYPE_TINY, *(CVector *)&v28, 0, 1u, -1.0, 0);
      }
      else
      {
        v29 = this->m_pMat;
        if ( v29 )
          p_m_transform = (CSimpleTransform *)&v29->tx;
        v30 = *(_QWORD *)&p_m_transform->m_translate.x;
        bExtinguishEnableda = *(_QWORD *)&p_m_transform->m_translate.y;
        CExplosion::AddExplosion(this, pCulprit, EXP_TYPE_HELI, *(CVector *)&v30, 0, 1u, -1.0, 0);
      }
    }
    else
    {
      this->m_nHealth = 0.0;
      this->AutoPilot.Mission = 58;
    }
  }
}
// 5744AB: failed to expand linear variable kr08_8.8
// 5744D3: failed to expand linear variable kr10_8.8
// 676438: using guessed type CFireManager *gFireManager_ptr;
// 5741F8: using guessed type int data[7];

//----- (00574524) --------------------------------------------------------
void __fastcall CHeli::SwitchPoliceHelis(bool bSwitch)
{
  CHeli::bPoliceHelisAllowed = bSwitch;
}

//----- (00574534) --------------------------------------------------------
bool __fastcall CHeli::SetUpWheelColModel(CHeli *this, CColModel *pColModel)
{
  return 0;
}

//----- (00574538) --------------------------------------------------------
bool __fastcall CHeli::BurstTyre(CHeli *this, uint8 nWheelPieceType, bool bApplyForce)
{
  return 0;
}

//----- (0057453C) --------------------------------------------------------
void __fastcall CMonsterTruck::CMonsterTruck(CMonsterTruck *this, int nModelIndex, UInt8 CreatedBy)
{
  __int64 v4; // d16
  __int64 v5; // d17
  CAutomobile::CAutomobileFlags m_nAutomobileFlags; // r0

  CAutomobile::CAutomobile(this, nModelIndex, CreatedBy, 0);
  *(float *)&v4 = 1.0;
  *((float *)&v4 + 1) = 1.0;
  *(float *)&v5 = 1.0;
  *((float *)&v5 + 1) = 1.0;
  *(_QWORD *)this->m_aBigTyreCompression = v4;
  *(_QWORD *)&this->m_aBigTyreCompression[2] = v5;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DC5C;
  CMonsterTruck::SetupSuspensionLines(this);
  m_nAutomobileFlags = this->m_nAutomobileFlags;
  this->m_vehicleType = 1;
  this->m_nAutomobileFlags = (CAutomobile::CAutomobileFlags)(*(_BYTE *)&m_nAutomobileFlags | 0x80);
}
// 66DC5C: using guessed type void *;

//----- (00574584) --------------------------------------------------------
void __fastcall CMonsterTruck::~CMonsterTruck(CMonsterTruck *this)
{
  void *v1; // r0

  CAutomobile::~CAutomobile(this);
  sub_199F98(v1);
}
// 574590: variable 'v1' is possibly undefined

//----- (00574594) --------------------------------------------------------
void __fastcall CMonsterTruck::SetupSuspensionLines(CMonsterTruck *this)
{
  CCollisionData *m_pColData; // r10
  CColLine *m_pLineArray; // r0
  int v4; // r1
  float *m_fLineLength; // r11
  unsigned int v6; // r5
  int v7; // r8
  RwReal v8; // s0
  float z; // s0
  bool v10; // zf
  float v11; // s2
  float v12; // s0
  float v13; // s2
  float m_wheelScale; // s4
  float v15; // s4
  float v16; // s4
  float v17; // s4
  float v18; // s0
  float *p_x; // r0
  float v20; // s0
  CColModel *m_pColModel; // [sp+14h] [bp-64h]
  float *p_m_fWheelRadius; // [sp+18h] [bp-60h]
  CVehicleModelInfo *v23; // [sp+1Ch] [bp-5Ch]
  CVector posn; // [sp+20h] [bp-58h] BYREF
  CVector vecThickness; // [sp+2Ch] [bp-4Ch] BYREF

  v23 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  m_pColModel = v23->m_pColModel;
  m_pColData = m_pColModel->m_pColData;
  p_m_fWheelRadius = &this->m_fWheelRadius;
  this->m_fWheelRadius = v23->m_wheelScale * 0.5;
  m_pLineArray = m_pColData->_anon_1.m_pLineArray;
  v4 = *((unsigned __int8 *)m_pColData + 7);
  if ( !m_pLineArray )
    goto LABEL_4;
  if ( !(v4 << 31) )
  {
    CMemoryMgr::Free(m_pLineArray);
    LOBYTE(v4) = *((_BYTE *)m_pColData + 7);
LABEL_4:
    m_pColData->_anon_0.m_nNoOfLines = 4;
    *((_BYTE *)m_pColData + 7) = v4 | 1;
    m_pColData->_anon_1.m_pLineArray = (CColLine *)CMemoryMgr::Malloc(0x90u);
  }
  m_fLineLength = this->m_fLineLength;
  v6 = -1;
  v7 = 17;
  memset(&vecThickness, 0, sizeof(vecThickness));
  do
  {
    CVehicleModelInfo::GetWheelPosn(v23, v6 + 1, &posn, 0);
    v8 = 1.0;
    if ( (int)(v6 + 1) < 2 )
      v8 = -1.0;
    vecThickness.x = v8;
    CColDisk::Set(
      (CColDisk *)((char *)m_pColData->_anon_1.m_pLineArray + v7 - 17),
      *p_m_fWheelRadius,
      &posn,
      &vecThickness,
      *p_m_fWheelRadius * 0.6,
      0x3Cu,
      0xDu,
      0xFFu);
    if ( v6 <= 2 )
      *((_BYTE *)&m_pColData->_anon_1.m_pLineArray->m_vecStart.x + v7) = (unsigned int)"lSubTaskEP4CPed" >> (8 * v6);
    v7 += 36;
    z = posn.z;
    v10 = v6++ == 2;
    *(m_fLineLength - 4) = posn.z + this->pHandling->fSuspensionUpperLimit;
    *m_fLineLength++ = z + this->pHandling->fSuspensionLowerLimit;
  }
  while ( !v10 );
  v11 = *p_m_fWheelRadius;
  v12 = *p_m_fWheelRadius
      + (float)((float)((float)(this->m_fSuspensionLength[0] - this->m_fLineLength[0])
                      * (float)((float)(1.0 / (float)(this->pHandling->fSuspensionForce * -4.0)) + 1.0))
              - this->m_fSuspensionLength[0]);
  this->m_fHeightAboveRoad = v12;
  v13 = v12 - v11;
  this->m_fRearHeightAboveRoad = v12;
  m_wheelScale = v23->m_wheelScale;
  this->m_aWheelRatios[0] = 1.0;
  this->m_aWheelSuspensionHeights[0] = (float)(m_wheelScale * 0.5) - v12;
  v15 = v23->m_wheelScale;
  this->m_aWheelRatios[1] = 1.0;
  this->m_aWheelSuspensionHeights[1] = (float)(v15 * 0.5) - v12;
  v16 = v23->m_wheelScale;
  this->m_aWheelRatios[2] = 1.0;
  this->m_aWheelSuspensionHeights[2] = (float)(v16 * 0.5) - v12;
  v17 = v23->m_wheelScale;
  this->m_aWheelRatios[3] = 1.0;
  this->m_aWheelSuspensionHeights[3] = (float)(v17 * 0.5) - v12;
  v18 = m_pColModel->m_boxBound.m_vecMin.z;
  p_x = &m_pColModel->m_boxBound.m_vecMin.x;
  if ( v13 < v18 )
  {
    m_pColModel->m_boxBound.m_vecMin.z = v13;
    v18 = v13;
  }
  if ( sqrtf(
         (float)((float)(m_pColModel->m_boxBound.m_vecMin.x * m_pColModel->m_boxBound.m_vecMin.x)
               + (float)(m_pColModel->m_boxBound.m_vecMin.y * m_pColModel->m_boxBound.m_vecMin.y))
       + (float)(v18 * v18)) <= sqrtf(
                                  (float)((float)(m_pColModel->m_boxBound.m_vecMax.x * m_pColModel->m_boxBound.m_vecMax.x)
                                        + (float)(m_pColModel->m_boxBound.m_vecMax.y * m_pColModel->m_boxBound.m_vecMax.y))
                                + (float)(m_pColModel->m_boxBound.m_vecMax.z * m_pColModel->m_boxBound.m_vecMax.z)) )
    p_x = &m_pColModel->m_boxBound.m_vecMax.x;
  v20 = sqrtf((float)((float)(*p_x * *p_x) + (float)(p_x[1] * p_x[1])) + (float)(p_x[2] * p_x[2]));
  if ( m_pColModel->m_sphereBound.m_fRadius < v20 )
    m_pColModel->m_sphereBound.m_fRadius = v20;
}

//----- (0057483C) --------------------------------------------------------
void __fastcall CMonsterTruck::ResetSuspension(CMonsterTruck *this)
{
  __int64 v2; // d16
  __int64 v3; // d17
  __int64 v4; // d18
  __int64 v5; // d19

  CAutomobile::ResetSuspension(this);
  *(float *)&v2 = 1.0;
  *((float *)&v2 + 1) = 1.0;
  *(float *)&v3 = 1.0;
  *((float *)&v3 + 1) = 1.0;
  v4 = *(_QWORD *)this->m_fLineLength;
  v5 = *(_QWORD *)&this->m_fLineLength[2];
  *(_QWORD *)this->m_aBigTyreCompression = v2;
  *(_QWORD *)&this->m_aBigTyreCompression[2] = v3;
  *(_QWORD *)this->m_aWheelSuspensionHeights = v4;
  *(_QWORD *)&this->m_aWheelSuspensionHeights[2] = v5;
}

//----- (00574864) --------------------------------------------------------
void __fastcall CMonsterTruck::ProcessControl(CMonsterTruck *this)
{
  float v1; // s2
  float *m_aWheelRatios; // r8
  float v4; // s2
  float v5; // s0
  float v6; // s0
  float *v7; // r9
  float v8; // s2
  float v9; // s0
  float v10; // s2
  float *v11; // r5
  float v12; // s2
  float v13; // s0
  float v14; // s0
  float *v15; // r6
  float v16; // s2
  float v17; // s0
  float *m_aWheelSuspensionHeights; // r0
  float v19; // s0
  float v20; // s4
  float v21; // s2
  float v22; // s2
  float *v23; // r0
  float v24; // s4
  float v25; // s2
  float v26; // s2
  float *v27; // r0
  float v28; // s4
  float v29; // s2
  float v30; // s2
  float *v31; // r0
  float v32; // s2
  float v33; // s0
  float v34; // s0

  v1 = 1.0;
  m_aWheelRatios = this->m_aWheelRatios;
  if ( this->m_aWheelRatios[0] < 1.0 )
  {
    v4 = this->m_fSuspensionLength[0];
    v5 = v4 - this->m_aWheelSuspensionHeights[0];
    *m_aWheelRatios = v5;
    v1 = v5 / (float)(v4 - this->m_fLineLength[0]);
    if ( v1 < 0.0 )
      v1 = 0.0;
  }
  v6 = 1.0;
  v7 = &this->m_aWheelRatios[1];
  *m_aWheelRatios = v1;
  if ( this->m_aWheelRatios[1] < 1.0 )
  {
    v8 = this->m_fSuspensionLength[1];
    v9 = v8 - this->m_aWheelSuspensionHeights[1];
    *v7 = v9;
    v6 = v9 / (float)(v8 - this->m_fLineLength[1]);
    if ( v6 < 0.0 )
      v6 = 0.0;
  }
  v10 = 1.0;
  v11 = &this->m_aWheelRatios[2];
  *v7 = v6;
  if ( this->m_aWheelRatios[2] < 1.0 )
  {
    v12 = this->m_fSuspensionLength[2];
    v13 = v12 - this->m_aWheelSuspensionHeights[2];
    *v11 = v13;
    v10 = v13 / (float)(v12 - this->m_fLineLength[2]);
    if ( v10 < 0.0 )
      v10 = 0.0;
  }
  v14 = 1.0;
  v15 = &this->m_aWheelRatios[3];
  *v11 = v10;
  if ( this->m_aWheelRatios[3] < 1.0 )
  {
    v16 = this->m_fSuspensionLength[3];
    v17 = v16 - this->m_aWheelSuspensionHeights[3];
    *v15 = v17;
    v14 = v17 / (float)(v16 - this->m_fLineLength[3]);
    if ( v14 < 0.0 )
      v14 = 0.0;
  }
  *v15 = v14;
  CAutomobile::ProcessControl(this);
  if ( (*(_BYTE *)&this->m_nFlags & 0x40) == 0
    && (this->m_vecMoveSpeed.x != 0.0
     || this->m_vecMoveSpeed.y != 0.0
     || this->m_vecMoveSpeed.z != 0.0
     || this->m_vecTurnSpeed.x != 0.0
     || this->m_vecTurnSpeed.y != 0.0
     || this->m_vecTurnSpeed.z != 0.0) )
  {
    m_aWheelSuspensionHeights = this->m_aWheelSuspensionHeights;
    v19 = CTimer::ms_fTimeStep * (float)(fWheelExtensionRate * this->m_fWheelRadius);
    v20 = this->m_aWheelSuspensionHeights[0] - v19;
    v21 = this->m_fLineLength[0];
    this->m_aWheelSuspensionHeights[0] = v20;
    if ( v20 >= v21 )
    {
      v22 = this->m_fSuspensionLength[0];
      if ( v20 > v22 )
        *m_aWheelSuspensionHeights = v22;
    }
    else
    {
      *m_aWheelSuspensionHeights = v21;
    }
    *m_aWheelRatios = 1.0;
    v23 = &this->m_aWheelSuspensionHeights[1];
    v24 = this->m_aWheelSuspensionHeights[1] - v19;
    v25 = this->m_fLineLength[1];
    this->m_aWheelSuspensionHeights[1] = v24;
    if ( v24 >= v25 )
    {
      v26 = this->m_fSuspensionLength[1];
      if ( v24 > v26 )
        *v23 = v26;
    }
    else
    {
      *v23 = v25;
    }
    *v7 = 1.0;
    v27 = &this->m_aWheelSuspensionHeights[2];
    v28 = this->m_aWheelSuspensionHeights[2] - v19;
    v29 = this->m_fLineLength[2];
    this->m_aWheelSuspensionHeights[2] = v28;
    if ( v28 >= v29 )
    {
      v30 = this->m_fSuspensionLength[2];
      if ( v28 > v30 )
        *v27 = v30;
    }
    else
    {
      *v27 = v29;
    }
    *v11 = 1.0;
    v31 = &this->m_aWheelSuspensionHeights[3];
    v32 = this->m_aWheelSuspensionHeights[3] - v19;
    v33 = this->m_fLineLength[3];
    this->m_aWheelSuspensionHeights[3] = v32;
    if ( v32 >= v33 )
    {
      v34 = this->m_fSuspensionLength[3];
      if ( v32 > v34 )
        *v31 = v34;
    }
    else
    {
      *v31 = v33;
    }
    *v15 = 1.0;
  }
}

//----- (00574B5C) --------------------------------------------------------
void __fastcall CMonsterTruck::ExtendSuspension(CMonsterTruck *this)
{
  float *m_aWheelSuspensionHeights; // r1
  float v2; // s0
  float v3; // s4
  float v4; // s2
  float v5; // s2
  float *v6; // r1
  float v7; // s4
  float v8; // s2
  float v9; // s2
  float *v10; // r1
  float v11; // s4
  float v12; // s2
  float v13; // s2
  float *v14; // r1
  float v15; // s2
  float v16; // s0
  float v17; // s0

  m_aWheelSuspensionHeights = this->m_aWheelSuspensionHeights;
  v2 = (float)(fWheelExtensionRate * this->m_fWheelRadius) * CTimer::ms_fTimeStep;
  v3 = this->m_aWheelSuspensionHeights[0] - v2;
  v4 = this->m_fLineLength[0];
  this->m_aWheelSuspensionHeights[0] = v3;
  if ( v3 >= v4 )
  {
    v5 = this->m_fSuspensionLength[0];
    if ( v3 > v5 )
      *m_aWheelSuspensionHeights = v5;
  }
  else
  {
    *m_aWheelSuspensionHeights = v4;
  }
  v6 = &this->m_aWheelSuspensionHeights[1];
  v7 = this->m_aWheelSuspensionHeights[1] - v2;
  v8 = this->m_fLineLength[1];
  this->m_aWheelRatios[0] = 1.0;
  this->m_aWheelSuspensionHeights[1] = v7;
  if ( v7 >= v8 )
  {
    v9 = this->m_fSuspensionLength[1];
    if ( v7 > v9 )
      *v6 = v9;
  }
  else
  {
    *v6 = v8;
  }
  v10 = &this->m_aWheelSuspensionHeights[2];
  v11 = this->m_aWheelSuspensionHeights[2] - v2;
  v12 = this->m_fLineLength[2];
  this->m_aWheelRatios[1] = 1.0;
  this->m_aWheelSuspensionHeights[2] = v11;
  if ( v11 >= v12 )
  {
    v13 = this->m_fSuspensionLength[2];
    if ( v11 > v13 )
      *v10 = v13;
  }
  else
  {
    *v10 = v12;
  }
  v14 = &this->m_aWheelSuspensionHeights[3];
  v15 = this->m_aWheelSuspensionHeights[3] - v2;
  v16 = this->m_fLineLength[3];
  this->m_aWheelRatios[2] = 1.0;
  this->m_aWheelSuspensionHeights[3] = v15;
  if ( v15 >= v16 )
  {
    v17 = this->m_fSuspensionLength[3];
    if ( v15 > v17 )
      *v14 = v17;
  }
  else
  {
    *v14 = v16;
  }
  this->m_aWheelRatios[3] = 1.0;
}

//----- (00574CA4) --------------------------------------------------------
void __fastcall CMonsterTruck::ProcessControlCollisionCheck(CMonsterTruck *this, bool bDoMovement)
{
  float *m_aWheelSuspensionHeights; // r2
  float v4; // s0
  float v5; // s4
  float v6; // s2
  float v7; // s2
  float *v8; // r5
  float v9; // s2
  float v10; // s4
  float v11; // s2
  float v12; // s2
  float *v13; // r6
  float *m_aWheelRatios; // r11
  float v15; // s2
  float v16; // s4
  float v17; // s2
  float v18; // s2
  float *v19; // r8
  float *v20; // r9
  float v21; // s2
  float v22; // s2
  float v23; // s0
  float v24; // s0
  float *v25; // r10
  float v26; // s0
  float v27; // s2
  float v28; // s4
  float v29; // s2
  float *v30; // r0
  float v31; // s2
  float v32; // s4
  float v33; // s2
  float v34; // s2
  float v35; // s4
  float v36; // s2
  float v37; // s2
  float v38; // s0
  float *v39; // [sp+Ch] [bp-24h]
  float *m_fLineLength; // [sp+10h] [bp-20h]

  m_aWheelSuspensionHeights = this->m_aWheelSuspensionHeights;
  v4 = CTimer::ms_fTimeStep * (float)(fWheelExtensionRate * this->m_fWheelRadius);
  m_fLineLength = this->m_fLineLength;
  v5 = this->m_aWheelSuspensionHeights[0] - v4;
  v6 = this->m_fLineLength[0];
  this->m_aWheelSuspensionHeights[0] = v5;
  if ( v5 >= v6 )
  {
    v7 = this->m_fSuspensionLength[0];
    if ( v5 > v7 )
      *m_aWheelSuspensionHeights = v7;
  }
  else
  {
    *m_aWheelSuspensionHeights = v6;
  }
  v8 = &this->m_aWheelSuspensionHeights[1];
  v9 = this->m_aWheelSuspensionHeights[1];
  this->m_aWheelRatios[0] = 1.0;
  v10 = v9 - v4;
  v11 = this->m_fLineLength[1];
  this->m_aWheelSuspensionHeights[1] = v10;
  if ( v10 >= v11 )
  {
    v12 = this->m_fSuspensionLength[1];
    if ( v10 > v12 )
      *v8 = v12;
  }
  else
  {
    *v8 = v11;
  }
  v13 = &this->m_aWheelSuspensionHeights[2];
  m_aWheelRatios = this->m_aWheelRatios;
  v15 = this->m_aWheelSuspensionHeights[2];
  this->m_aWheelRatios[1] = 1.0;
  v16 = v15 - v4;
  v17 = this->m_fLineLength[2];
  this->m_aWheelSuspensionHeights[2] = v16;
  if ( v16 >= v17 )
  {
    v18 = this->m_fSuspensionLength[2];
    if ( v16 > v18 )
      *v13 = v18;
  }
  else
  {
    *v13 = v17;
  }
  v19 = &this->m_aWheelSuspensionHeights[3];
  v39 = this->m_aWheelSuspensionHeights;
  v20 = &this->m_aWheelRatios[1];
  v21 = this->m_aWheelSuspensionHeights[3];
  this->m_aWheelRatios[2] = 1.0;
  v22 = v21 - v4;
  v23 = this->m_fLineLength[3];
  this->m_aWheelSuspensionHeights[3] = v22;
  if ( v22 >= v23 )
  {
    v24 = this->m_fSuspensionLength[3];
    if ( v22 > v24 )
      *v19 = v24;
  }
  else
  {
    *v19 = v23;
  }
  v25 = &this->m_aWheelRatios[2];
  this->m_aWheelRatios[3] = 1.0;
  CAutomobile::ProcessControlCollisionCheck(this, bDoMovement);
  v26 = 1.0;
  v27 = 1.0;
  if ( *m_aWheelRatios < 1.0 )
  {
    v28 = this->m_fSuspensionLength[0];
    v29 = v28 - *v39;
    *m_aWheelRatios = v29;
    v27 = v29 / (float)(v28 - *m_fLineLength);
  }
  *m_aWheelRatios = v27;
  v30 = &this->m_aWheelRatios[3];
  v31 = 1.0;
  if ( *v20 < 1.0 )
  {
    v32 = this->m_fSuspensionLength[1];
    v33 = v32 - *v8;
    *v20 = v33;
    v31 = v33 / (float)(v32 - this->m_fLineLength[1]);
  }
  *v20 = v31;
  v34 = 1.0;
  if ( *v25 < 1.0 )
  {
    v35 = this->m_fSuspensionLength[2];
    v36 = v35 - *v13;
    *v25 = v36;
    v34 = v36 / (float)(v35 - this->m_fLineLength[2]);
  }
  *v25 = v34;
  if ( *v30 < 1.0 )
  {
    v37 = this->m_fSuspensionLength[3];
    v38 = v37 - *v19;
    *v30 = v38;
    v26 = v38 / (float)(v37 - this->m_fLineLength[3]);
  }
  *v30 = v26;
}

//----- (00574F00) --------------------------------------------------------
void __fastcall CMonsterTruck::ProcessSuspension(CMonsterTruck *this)
{
  CMatrix *m_pMat; // r0
  float v3; // s10
  float v4; // s6
  float v5; // s2
  float v6; // s8
  float v7; // s4
  float v8; // s12
  float v9; // s14
  float v10; // s0
  CSimpleTransform *p_m_transform; // r1
  CSimpleTransform *p_tx; // r2
  float v13; // s14
  float v14; // s12
  float v15; // s1
  float v16; // s4
  CSimpleTransform *v17; // r2
  float *v18; // r5
  float v19; // s14
  float v20; // s12
  float v21; // s10
  float *v22; // r6
  float xz; // s10
  float v24; // s8
  float v25; // s6
  int v26; // r10
  unsigned int v27; // r4
  int v28; // r8
  __int64 v29; // d16
  float *v30; // r9
  CPhysical *v31; // r1
  float v32; // s2
  float v33; // s4
  float *v34; // r0
  float z; // s0
  float *v36; // r1
  float v37; // s4
  float *v38; // r0
  float v39; // s2
  int v40; // r6
  int i; // r5
  char *v42; // r10
  float *v43; // r8
  float v44; // s0
  _BYTE *v45; // r0
  float *v46; // r12
  float v47; // s0
  float v48; // s6
  CPhysical *v49; // r0
  CMatrix *v50; // r8
  float v51; // s0
  float v52; // s2
  float v53; // s4
  float m_fMass; // s6
  float v55; // s2
  float v56; // s4
  float *p_x; // r9
  CVector vecSpeed; // [sp+0h] [bp-118h]
  CVector v59; // [sp+20h] [bp-F8h] BYREF
  CVector vecOffset; // [sp+30h] [bp-E8h] BYREF
  CVector v61; // [sp+3Ch] [bp-DCh] BYREF
  CVector v62; // [sp+48h] [bp-D0h] BYREF
  CVector v63; // [sp+54h] [bp-C4h] BYREF
  CVector vecDirection; // [sp+60h] [bp-B8h] BYREF
  CVector v65; // [sp+6Ch] [bp-ACh] BYREF
  CVector v66; // [sp+78h] [bp-A0h] BYREF
  CVector v67; // [sp+84h] [bp-94h] BYREF
  float v68[3]; // [sp+90h] [bp-88h] BYREF
  float v69; // [sp+9Ch] [bp-7Ch] BYREF
  float v70; // [sp+A8h] [bp-70h] BYREF
  float v71; // [sp+B4h] [bp-64h] BYREF
  float fSpringForce; // [sp+C0h] [bp-58h] BYREF
  float v73; // [sp+C4h] [bp-54h] BYREF
  float v74; // [sp+C8h] [bp-50h] BYREF
  float v75[19]; // [sp+CCh] [bp-4Ch] BYREF
  CVector v76; // 0:r1.12

  m_pMat = this->m_pMat;
  v3 = -m_pMat->xz;
  v4 = -m_pMat->yz;
  v5 = 0.0;
  v6 = -m_pMat->zz;
  v7 = 0.0;
  v8 = 0.0;
  v9 = 0.0;
  vecDirection.y = v4;
  vecDirection.x = v3;
  vecDirection.z = v6;
  v10 = this->m_aWheelRatios[0];
  p_m_transform = &this->m_transform;
  if ( v10 < 1.0 )
  {
    p_tx = &this->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v9 = this->m_aWheelColPoints[0].m_vecPosition.z - p_tx->m_translate.z;
    v8 = this->m_aWheelColPoints[0].m_vecPosition.y - p_tx->m_translate.y;
    v7 = this->m_aWheelColPoints[0].m_vecPosition.x - p_tx->m_translate.x;
  }
  vecOffset.z = v9;
  v13 = 0.0;
  vecOffset.y = v8;
  v14 = 0.0;
  v15 = 0.0;
  v65.z = v6;
  v65.y = v4;
  vecOffset.x = v7;
  v65.x = v3;
  v16 = this->m_aWheelRatios[1];
  if ( v16 < 1.0 )
  {
    v17 = &this->m_transform;
    if ( m_pMat )
      v17 = (CSimpleTransform *)&m_pMat->tx;
    v15 = this->m_aWheelColPoints[1].m_vecPosition.z - v17->m_translate.z;
    v13 = this->m_aWheelColPoints[1].m_vecPosition.y - v17->m_translate.y;
    v14 = this->m_aWheelColPoints[1].m_vecPosition.x - v17->m_translate.x;
  }
  v18 = &this->m_aWheelRatios[2];
  v61.z = v15;
  v61.y = v13;
  v19 = 0.0;
  v61.x = v14;
  v20 = 0.0;
  v66.z = v6;
  v66.y = v4;
  v66.x = v3;
  v21 = 0.0;
  if ( this->m_aWheelRatios[2] < 1.0 )
  {
    if ( m_pMat )
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    v19 = this->m_aWheelColPoints[2].m_vecPosition.z - p_m_transform->m_translate.z;
    v20 = this->m_aWheelColPoints[2].m_vecPosition.y - p_m_transform->m_translate.y;
    v21 = this->m_aWheelColPoints[2].m_vecPosition.x - p_m_transform->m_translate.x;
  }
  v62.z = v19;
  v22 = &this->m_aWheelRatios[3];
  v62.y = v20;
  v62.x = v21;
  xz = m_pMat->xz;
  v67.z = v6;
  v24 = 0.0;
  v67.y = v4;
  v67.x = -xz;
  v25 = 0.0;
  if ( this->m_aWheelRatios[3] < 1.0 )
  {
    v24 = this->m_aWheelColPoints[3].m_vecPosition.z - m_pMat->tz;
    v5 = this->m_aWheelColPoints[3].m_vecPosition.x - m_pMat->tx;
    v25 = this->m_aWheelColPoints[3].m_vecPosition.y - m_pMat->ty;
  }
  v63.z = v24;
  v63.y = v25;
  v63.x = v5;
  if ( v10 < 1.0 )
  {
    CPhysical::ApplySpringCollisionAlt(
      this,
      this->pHandling->fSuspensionForce,
      &vecDirection,
      &vecOffset,
      v10,
      this->pHandling->fSuspensionBias,
      &this->m_aWheelColPoints[0].m_vecNormal,
      &fSpringForce);
    v16 = this->m_aWheelRatios[1];
  }
  if ( v16 < 1.0 )
    CPhysical::ApplySpringCollisionAlt(
      this,
      this->pHandling->fSuspensionForce,
      &v65,
      &v61,
      v16,
      1.0 - this->pHandling->fSuspensionBias,
      &this->m_aWheelColPoints[1].m_vecNormal,
      &v73);
  if ( *v18 < 1.0 )
    CPhysical::ApplySpringCollisionAlt(
      this,
      this->pHandling->fSuspensionForce,
      &v66,
      &v62,
      *v18,
      this->pHandling->fSuspensionBias,
      &this->m_aWheelColPoints[2].m_vecNormal,
      &v74);
  if ( *v22 < 1.0 )
    CPhysical::ApplySpringCollisionAlt(
      this,
      this->pHandling->fSuspensionForce,
      &v67,
      &v63,
      *v22,
      1.0 - this->pHandling->fSuspensionBias,
      &this->m_aWheelColPoints[3].m_vecNormal,
      v75);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  do
  {
    CPhysical::GetSpeed(&v59, this, *(CVector *)((char *)&vecOffset + v27));
    v29 = *(_QWORD *)&v59.x;
    v30 = &v68[v27 / 4];
    v30[2] = v59.z;
    *(_QWORD *)v30 = v29;
    v31 = this->m_aGroundPhysicalPtrs[v26];
    if ( v31 )
    {
      CPhysical::GetSpeed(&v59, v31, this->m_aGroundOffsets[v27 / 0xC]);
      v32 = v30[1] - v59.y;
      v33 = v30[2] - v59.z;
      *v30 = *v30 - v59.x;
      v30[1] = v32;
      v30[2] = v33;
    }
    if ( this->m_aWheelRatios[v26] < 1.0 )
    {
      v34 = (float *)((char *)this + v28 * 44);
      z = this->m_aWheelColPoints[v28].m_vecNormal.z;
      if ( z > 0.35 )
      {
        v36 = v34 + 467;
        v37 = v34[466];
        v38 = (float *)((char *)&vecDirection.x + v27);
        v39 = -*v36;
        *v38 = -v37;
        v38[1] = v39;
        v38[2] = -z;
      }
    }
    v27 += 12;
    ++v26;
    ++v28;
  }
  while ( v27 != 48 );
  if ( this->m_aWheelRatios[0] < 1.0 )
    CPhysical::ApplySpringDampening(
      this,
      this->pHandling->fSuspensionDamping,
      fSpringForce,
      &vecDirection,
      &vecOffset,
      v68);
  if ( this->m_aWheelRatios[1] < 1.0 )
    CPhysical::ApplySpringDampening(this, this->pHandling->fSuspensionDamping, v73, &v65, &v61, &v69);
  if ( this->m_aWheelRatios[2] < 1.0 )
    CPhysical::ApplySpringDampening(this, this->pHandling->fSuspensionDamping, v74, &v66, &v62, &v70);
  if ( this->m_aWheelRatios[3] < 1.0 )
    CPhysical::ApplySpringDampening(this, this->pHandling->fSuspensionDamping, v75[0], &v67, &v63, &v71);
  v40 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v42 = (char *)this + v40 * 4;
    v43 = &this->m_aWheelRatios[v40];
    v44 = *v43;
    if ( *v43 < 1.0 )
    {
      v45 = (_BYTE *)*((_DWORD *)v42 + 575);
      if ( v45 )
      {
        if ( (v45[58] & 7) == 2 )
        {
          if ( v44 < 0.5 )
            (*(void (__fastcall **)(_BYTE *, _DWORD, _DWORD, CMonsterTruck *, CColPoint *, CVector *, int))(*(_DWORD *)v45 + 228))(
              v45,
              (float)((float)(1.0 - v44) * 0.05) * this->m_fMass,
              this->m_aWheelColPoints[i].m_dataB.m_nPieceType,
              this,
              &this->m_aWheelColPoints[i],
              &this->m_aWheelColPoints[i].m_vecNormal,
              49);
          v46 = (float *)((char *)this + i * 44);
          v47 = this->m_aWheelColPoints[i].m_vecNormal.z;
          if ( v47 > 0.5 )
          {
            v48 = 1.0 - *v43;
            v49 = (CPhysical *)*((_DWORD *)v42 + 575);
            v50 = v49->m_pMat;
            v51 = (float)(v47 * -0.05) * v48;
            v52 = (float)((float)(v46[466] * 0.25) * -0.05) * v48;
            v53 = (float)((float)(v46[467] * 0.25) * -0.05) * v48;
            m_fMass = v49->m_fMass;
            v55 = m_fMass * v52;
            v56 = m_fMass * v53;
            p_x = &v50->tx;
            if ( !v50 )
              p_x = &v49->m_transform.m_translate.x;
            v76.x = v55;
            v76.y = v56;
            vecSpeed.x = v46[462] - *p_x;
            *(_QWORD *)&vecSpeed.y = __PAIR64__(v46[464] - p_x[2], v46[463] - p_x[1]);
            v76.z = m_fMass * v51;
            CPhysical::ApplyForce(v49, v76, vecSpeed, 1);
          }
        }
      }
    }
    ++v40;
    *((_DWORD *)v42 + 575) = 0;
  }
}
// 574F00: using guessed type float var_88[3];
// 574F00: using guessed type float var_4C[19];

//----- (00575520) --------------------------------------------------------
void __fastcall CMonsterTruck::PreRender(CMonsterTruck *this)
{
  float *m_aWheelSuspensionHeights; // r10
  float *v3; // r11
  float v4; // s0
  float *v5; // r0
  float *v6; // r8
  float v7; // s0
  float v8; // s0
  CVehicleModelInfo *v9; // r9
  RwFrame_0 *v10; // r1
  CVector posn; // [sp+18h] [bp-70h] BYREF
  CMatrix v12; // [sp+24h] [bp-64h] BYREF

  m_aWheelSuspensionHeights = this->m_aWheelSuspensionHeights;
  v3 = &this->m_aWheelSuspensionHeights[2];
  v4 = this->m_fSuspensionLength[0];
  v5 = &this->m_fSuspensionLength[1];
  v6 = &this->m_aWheelSuspensionHeights[3];
  if ( this->m_aWheelSuspensionHeights[0] > v4 )
    *m_aWheelSuspensionHeights = v4;
  if ( this->m_aWheelSuspensionHeights[1] > *v5 )
    this->m_aWheelSuspensionHeights[1] = *v5;
  v7 = this->m_fSuspensionLength[2];
  if ( *v3 > v7 )
    *v3 = v7;
  v8 = this->m_fSuspensionLength[3];
  if ( *v6 > v8 )
    *v6 = v8;
  CAutomobile::PreRender(this);
  v9 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v12.m_pRwMat = 0;
  v12.m_owner = 0;
  CVehicleModelInfo::GetWheelPosn(v9, 0, &posn, 0);
  CVehicle::SetTransmissionRotation(
    this,
    this->m_aCarNodes[19],
    *m_aWheelSuspensionHeights,
    *v3,
    SLODWORD(posn.x),
    posn.y,
    posn.z,
    1);
  CVehicleModelInfo::GetWheelPosn(v9, 1, &posn, 0);
  CVehicle::SetTransmissionRotation(
    this,
    this->m_aCarNodes[20],
    this->m_aWheelSuspensionHeights[1],
    *v6,
    SLODWORD(posn.x),
    posn.y,
    posn.z,
    0);
  if ( this->m_nModelIndex == 406 )
  {
    v10 = this->m_aCarNodes[22];
    if ( v10 )
      CVehicle::SetComponentRotation(
        this,
        v10,
        0,
        CMonsterTruck::DUMPER_COL_ANGLEMULT * (float)this->m_nSuspensionHydraulics,
        1);
  }
  CMatrix::~CMatrix(&v12);
}
// 676F9C: using guessed type float *CMonsterTruck::DUMPER_COL_ANGLEMULT;

//----- (00575670) --------------------------------------------------------
int32 __fastcall CMonsterTruck::ProcessEntityCollision(CMonsterTruck *this, CEntity *pEntity, CColPoint *aColPoints)
{
  CColModel *ColModel; // r10
  __int64 v6; // d17
  CCollisionData *m_pColData; // r11
  CEntity *v8; // r0
  CMatrix *m_pMat; // r6
  CMatrix *v10; // r9
  CEntity *v11; // r5
  CColModel *v12; // r0
  int v13; // r12
  int v14; // r8
  unsigned int v15; // r11
  int v16; // r10
  int v17; // r6
  CEntity *v18; // r3
  char *v19; // r0
  float v20; // s0
  float *v21; // r1
  float *v22; // r5
  int v23; // r1
  bool v24; // zf
  CMatrix *v25; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v27; // s2
  float *v28; // r0
  float v29; // s4
  CEntity::CFlags v30; // kr00_8
  unsigned int v31; // r1
  bool v32; // cc
  CEntity *v33; // r0
  int v34; // r1
  int *p_m_nFlags; // [sp+10h] [bp-48h]
  RwReal *p_z; // [sp+14h] [bp-44h]
  int v38; // [sp+18h] [bp-40h]
  CEntity::CFlags *v40; // [sp+20h] [bp-38h]
  int v41; // [sp+24h] [bp-34h]
  float aLineRatios[2]; // [sp+28h] [bp-30h] BYREF
  __int64 v43; // [sp+30h] [bp-28h]

  if ( (*(_BYTE *)&this->m_info & 0xF8) != 16 )
    *(_DWORD *)&this->m_nVehicleFlags |= 0x1000000u;
  ColModel = CEntity::GetColModel(this);
  v6 = *(_QWORD *)&this->m_aWheelSuspensionHeights[2];
  m_pColData = ColModel->m_pColData;
  *(_QWORD *)aLineRatios = *(_QWORD *)this->m_aWheelSuspensionHeights;
  v43 = v6;
  v8 = pEntity;
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 1) & 0x90) != 0 || (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    m_pColData->_anon_0.m_nNoOfLines = 0;
  m_pMat = pEntity->m_pMat;
  v10 = this->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(pEntity);
    CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
    v8 = pEntity;
    m_pMat = pEntity->m_pMat;
  }
  v11 = v8;
  v12 = CEntity::GetColModel(v8);
  v13 = CCollision::ProcessColModels(v10, ColModel, m_pMat, v12, aColPoints, this->m_aWheelColPoints, aLineRatios, 0);
  v38 = v13;
  if ( m_pColData->_anon_0.m_nNoOfLines )
  {
    p_z = &this->m_aGroundOffsets[0].z;
    p_m_nFlags = (int *)&v11->m_nFlags;
    v40 = &this->m_nFlags;
    v14 = 1412;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = v11;
    v41 = 0;
    do
    {
      v19 = (char *)this + v17 * 4;
      v20 = aLineRatios[v17];
      v21 = &this->m_aWheelSuspensionHeights[v17];
      if ( v20 > *v21 && (!v13 || (*(_DWORD *)v40 & 1) != 0) )
      {
        v22 = (float *)((char *)this + v16 * 44);
        *((_DWORD *)v19 + 506) = 0;
        *v21 = v20;
        *((_BYTE *)&this->_vptr$CPlaceable + v14) = this->m_aWheelColPoints[v16].m_dataB.m_lighting;
        v23 = *(_BYTE *)&v18->m_info & 7;
        v24 = v23 == 4;
        ++v41;
        if ( v23 != 4 )
          v24 = v23 == 2;
        if ( v24 )
        {
          *((_DWORD *)v19 + 575) = v18;
          CEntity::RegisterReference(v18, (CEntity **)&p_z[v17 - 6]);
          v13 = v38;
          v18 = pEntity;
          v25 = pEntity->m_pMat;
          p_tx = (CSimpleTransform *)&v25->tx;
          if ( !v25 )
            p_tx = &pEntity->m_transform;
          v27 = v22[463] - p_tx->m_translate.y;
          v28 = &p_z[v15 / 4];
          v29 = v22[464] - p_tx->m_translate.z;
          *(v28 - 2) = v22[462] - p_tx->m_translate.x;
          this->m_aGroundOffsets[v15 / 0xC].y = v27;
          *v28 = v29;
          if ( (*(_BYTE *)&pEntity->m_info & 7) == 2 )
            *((_BYTE *)&this->_vptr$CPlaceable + v14) = *((_BYTE *)&pEntity->_vptr$CPlaceable + v14);
        }
        this->m_LastMaterialToHaveBeenStandingOn = *((_BYTE *)v22 + 1883);
        if ( (*(_BYTE *)&v18->m_info & 7) == 1 )
        {
          this->pEntityWeAreOnForVisibilityCheck = v18;
          v30 = *v40;
          v31 = *(_DWORD *)v40 & 0xBFFFFFFF | ((((unsigned int)*p_m_nFlags >> 30) & 1) << 30);
          *(_DWORD *)v40 = v31;
          this->m_nFlags.bdummy = v30.bdummy;
          *(_DWORD *)v40 = v31 & 0x7FFFFFFF | ((*p_m_nFlags < 0) << 31);
          this->m_nFlags.bdummy = v30.bdummy;
        }
      }
      ++v17;
      v15 += 12;
      ++v14;
      ++v16;
    }
    while ( v17 != 4 );
  }
  else
  {
    v18 = v11;
    m_pColData->_anon_0.m_nNoOfLines = 4;
    v41 = 0;
  }
  v32 = v13 < 0;
  if ( v13 <= 0 )
    v32 = v41 < 1;
  if ( !v32 )
  {
    CPhysical::AddCollisionRecord(this, v18);
    v33 = pEntity;
    if ( (*(_BYTE *)&pEntity->m_info & 7) != 1 )
    {
      CPhysical::AddCollisionRecord((CPhysical *)pEntity, this);
      v33 = pEntity;
    }
    v13 = v38;
    if ( v38 >= 1 )
    {
      v34 = *(_BYTE *)&v33->m_info & 7;
      if ( v34 == 1 || v34 == 4 && (LOBYTE(v33[1].m_transform.m_translate.y) & 4) != 0 )
        *(_DWORD *)&this->m_nFlags |= 0x1000u;
    }
  }
  return v13;
}

//----- (005758EA) --------------------------------------------------------
bool __fastcall CMonsterTruck::SetUpWheelColModel(CMonsterTruck *this, CColModel *pColModel)
{
  return 0;
}

//----- (005758EE) --------------------------------------------------------
bool __fastcall CMonsterTruck::BurstTyre(CMonsterTruck *this, uint8 nWheelPieceType, bool bApplyForce)
{
  return 0;
}

//----- (00575900) --------------------------------------------------------
void __fastcall CPlane::CPlane(CPlane *this, int nModelIndex, UInt8 CreatedBy)
{
  CVehicleModelInfo *v5; // r5
  int m_nModelIndex; // r1
  int v7; // r1
  int v8; // r0
  RwFrame_0 *v9; // r0
  RwFrame_0 *v10; // r0
  uint16 v11; // r0
  int v12; // r0
  CVector v13; // [sp+0h] [bp-30h] BYREF
  CVector posn; // [sp+Ch] [bp-24h] BYREF

  CAutomobile::CAutomobile(this, nModelIndex, CreatedBy, 1u);
  this->_vptr$CPlaceable = (int (**)(void))&off_66DD84;
  v5 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[nModelIndex];
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  *(_QWORD *)&this->m_fYawControl = 0LL;
  *(_QWORD *)&this->m_fRollControl = 0LL;
  *(_QWORD *)&this->m_TakeOffDirection = 0x4170000000000000LL;
  *(_QWORD *)&this->m_DesiredHeight = 0x41A0000041C80000LL;
  this->m_vehicleType = 4;
  this->m_FlightDirection = 0.0;
  this->m_FlightDirectionAvoidingTerrain = 0.0;
  this->m_OldTilt = 0.0;
  this->m_OnGroundTimer = 0;
  this->m_fEngineSpeed = 0.0;
  this->m_fPropellerAngle = 0.0;
  this->m_fLGearAngle = 0.0;
  this->m_fScriptThrottleControl = 1.0;
  this->m_fPreviousRoll = 0.0;
  this->m_nStallCounter = 0;
  if ( m_nModelIndex != 539 )
    *(_DWORD *)&this->m_nPhysicalFlags |= 0x1000000u;
  v7 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  v8 = *(_DWORD *)&this->m_nVehicleFlags | 0x400;
  this->ExtendedRemovalRange = 255;
  *(_DWORD *)&this->m_nVehicleFlags = v8;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v7 | 0x40;
  switch ( nModelIndex )
  {
    case 512:
    case 520:
      goto LABEL_6;
    case 513:
      CDamageManager::SetDoorStatus(&this->Damage, FRONT_LEFT_DOOR_0, 0);
      this->Door[2].m_fOpenAngle = 1.885;
      this->Door[2].m_fClosedAngle = 0.0;
      this->Door[2].m_nAxis = 1;
      v9 = this->m_aCarNodes[7];
      this->Door[2].m_nDirn = 19;
      GetFirstObject(v9)->flags = 0;
      v10 = this->m_aCarNodes[4];
      goto LABEL_8;
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
    case 534:
    case 535:
    case 536:
    case 537:
    case 538:
    case 540:
    case 541:
    case 542:
    case 543:
    case 544:
    case 545:
    case 546:
    case 547:
    case 548:
    case 549:
    case 550:
    case 551:
    case 552:
      goto LABEL_13;
    case 519:
      CDamageManager::SetDoorStatus(&this->Damage, FRONT_LEFT_DOOR_0, 0);
      this->Door[2].m_fOpenAngle = -2.3562;
      this->Door[2].m_fClosedAngle = 0.0;
      this->Door[2].m_nAxis = 1;
      v10 = this->m_aCarNodes[5];
      this->Door[2].m_nDirn = 18;
LABEL_8:
      GetFirstObject(v10)->flags = 0;
      goto LABEL_13;
    case 539:
      if ( (unsigned __int16)this->BouncingPanels[0].m_nComponentIndex == 0xFFFF )
        CBouncingPanel::SetPanel(this->BouncingPanels, 21, 1, -0.25);
      goto LABEL_13;
    case 553:
      CDamageManager::SetDoorStatus(&this->Damage, FRONT_LEFT_DOOR_0, 0);
      this->Door[2].m_fOpenAngle = -1.2566;
      v11 = 20;
      this->Door[2].m_fClosedAngle = 0.0;
      this->Door[2].m_nAxis = 2;
      goto LABEL_12;
    default:
      if ( nModelIndex != 476 )
        goto LABEL_13;
LABEL_6:
      CDamageManager::SetDoorStatus(&this->Damage, FRONT_LEFT_DOOR_0, 0);
      this->Door[2].m_fOpenAngle = 1.885;
      this->Door[2].m_fClosedAngle = 0.0;
      this->Door[2].m_nAxis = 1;
      v11 = 19;
LABEL_12:
      this->Door[2].m_nDirn = v11;
LABEL_13:
      CVehicleModelInfo::GetWheelPosn(v5, 0, &posn, 0);
      CVehicleModelInfo::GetWheelPosn(v5, 0, &v13, 1);
      this->m_aWheelSuspensionHeights[0] = (float)(this->m_aWheelSuspensionHeights[0] - posn.z) + v13.z;
      CVehicleModelInfo::GetWheelPosn(v5, 1, &posn, 0);
      CVehicleModelInfo::GetWheelPosn(v5, 1, &v13, 1);
      this->m_aWheelSuspensionHeights[1] = (float)(this->m_aWheelSuspensionHeights[1] - posn.z) + v13.z;
      CVehicleModelInfo::GetWheelPosn(v5, 2, &posn, 0);
      CVehicleModelInfo::GetWheelPosn(v5, 2, &v13, 1);
      this->m_aWheelSuspensionHeights[2] = (float)(this->m_aWheelSuspensionHeights[2] - posn.z) + v13.z;
      CVehicleModelInfo::GetWheelPosn(v5, 3, &posn, 0);
      CVehicleModelInfo::GetWheelPosn(v5, 3, &v13, 1);
      this->m_aWheelSuspensionHeights[3] = (float)(this->m_aWheelSuspensionHeights[3] - posn.z) + v13.z;
      *(_QWORD *)this->m_fxSysNozzle = 0LL;
      *(_QWORD *)&this->m_fxSysNozzle[2] = 0LL;
      this->m_nDamageControlWaveCounter = 0;
      this->m_GunflashFxPtrs = 0;
      v12 = (unsigned __int16)this->m_nModelIndex;
      this->m_FiringRateMultiplier = 16;
      this->m_FireMissilePressedTime = 0;
      this->m_pLastMissileTarget = 0;
      this->m_fxSysFire = 0;
      if ( v12 == 520 )
        this->m_nSuspensionHydraulics = CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
      this->m_fxActive = 0;
      return;
  }
}
// 66DD84: using guessed type void *;

//----- (00575C0C) --------------------------------------------------------
void __fastcall CPlane::~CPlane(CPlane *this)
{
  FxSystem_c **m_GunflashFxPtrs; // r1
  int PlaneNumGuns; // r1
  FxSystem_c **v4; // r0
  int i; // r6
  FxSystem_c *v6; // r0
  int v7; // r1
  FxSystem_c *v8; // r0
  FxSystem_c *v9; // r0
  FxSystem_c *v10; // r0
  FxSystem_c *v11; // r0
  FxSystem_c *m_fxSysFire; // r0

  m_GunflashFxPtrs = this->m_GunflashFxPtrs;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DD84;
  if ( m_GunflashFxPtrs )
  {
    PlaneNumGuns = CVehicle::GetPlaneNumGuns(this);
    v4 = this->m_GunflashFxPtrs;
    if ( PlaneNumGuns >= 1 )
    {
      for ( i = 0; i < v7; ++i )
      {
        v6 = v4[i];
        if ( v6 )
        {
          FxSystem_c::Kill(v6);
          FxManager_c::DestroyFxSystem(&g_fxMan, this->m_GunflashFxPtrs[i]);
        }
        v7 = CVehicle::GetPlaneNumGuns(this);
        v4 = this->m_GunflashFxPtrs;
      }
    }
    if ( v4 )
      operator delete[](v4);
    this->m_GunflashFxPtrs = 0;
  }
  v8 = this->m_fxSysNozzle[0];
  if ( v8 )
  {
    FxSystem_c::Kill(v8);
    this->m_fxSysNozzle[0] = 0;
  }
  v9 = this->m_fxSysNozzle[1];
  if ( v9 )
  {
    FxSystem_c::Kill(v9);
    this->m_fxSysNozzle[1] = 0;
  }
  v10 = this->m_fxSysNozzle[2];
  if ( v10 )
  {
    FxSystem_c::Kill(v10);
    this->m_fxSysNozzle[2] = 0;
  }
  v11 = this->m_fxSysNozzle[3];
  if ( v11 )
  {
    FxSystem_c::Kill(v11);
    this->m_fxSysNozzle[3] = 0;
  }
  m_fxSysFire = this->m_fxSysFire;
  if ( m_fxSysFire )
  {
    FxSystem_c::Kill(m_fxSysFire);
    this->m_fxSysFire = 0;
  }
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  sub_19E450(this);
}
// 66DD84: using guessed type void *off_66DD84;

//----- (00575CE8) --------------------------------------------------------
void __fastcall CPlane::~CPlane(CPlane *this)
{
  void *v1; // r0

  CPlane::~CPlane(this);
  sub_199F98(v1);
}
// 575CF4: variable 'v1' is possibly undefined

//----- (00575CF8) --------------------------------------------------------
void __fastcall CPlane::ProcessControl(CPlane *this)
{
  CPed *pDriver; // r0
  int32 m_nPedType; // r0
  uint32 m_nStallCounter; // r0
  FxSystem_c *m_fxSysFire; // r0
  RwReal v6; // s2
  RwReal v7; // s0
  FxPrtMult_c v8; // [sp+14h] [bp-84h] BYREF
  RwV3d_0 vel; // [sp+30h] [bp-68h] BYREF
  RwMatrix compMat; // [sp+3Ch] [bp-5Ch] BYREF

  if ( *(_BYTE *)&this->m_info <= 7u && (this->m_nModelIndex & 0xFFFFFFFE) == 512 )
  {
    pDriver = this->pDriver;
    if ( pDriver )
    {
      m_nPedType = pDriver->m_nPedType;
      if ( m_nPedType != 1 )
        m_nPedType = 0;
    }
    else
    {
      m_nPedType = 0;
    }
    CPad::GetPad(m_nPedType);
    if ( CHID::IsReleased(HID_MAPPING_TOGGLE_LANDING_GEAR) )
      this->m_fxActive = this->m_fxActive == 0;
  }
  if ( this->m_fxActive && ((*(_DWORD *)&this->m_nVehicleFlags & 0x40000010) != 0x10 || !this->pDriver) )
    this->m_fxActive = 0;
  if ( this->m_nModelIndex == 460 )
  {
    CDamageManager::SetWheelStatus(&this->Damage, 0, 2u);
    CDamageManager::SetWheelStatus(&this->Damage, 1, 2u);
    CDamageManager::SetWheelStatus(&this->Damage, 2, 2u);
    CDamageManager::SetWheelStatus(&this->Damage, 3, 2u);
  }
  CAutomobile::ProcessControl(this);
  m_nStallCounter = this->m_nStallCounter;
  this->m_VehicleAudioEntity.m_nStallCounter = m_nStallCounter;
  if ( m_nStallCounter )
    this->m_nStallCounter = 0;
  CVehicle::ProcessWeapons(this);
  if ( this->m_nModelIndex == 539 )
  {
    *(_QWORD *)this->m_aWheelState = 0LL;
    *(_QWORD *)&this->m_aWheelState[2] = 0LL;
  }
  m_fxSysFire = this->m_fxSysFire;
  if ( m_fxSysFire )
  {
    this->m_fireTime -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    FxSystem_c::GetCompositeMatrix(m_fxSysFire, &compMat);
    v6 = this->m_vecMoveSpeed.x * -5.0;
    v7 = this->m_vecMoveSpeed.z * -5.0;
    vel.y = this->m_vecMoveSpeed.y * -5.0;
    vel.x = v6;
    vel.z = v7;
    FxPrtMult_c::FxPrtMult_c(&v8, 0.0, 0.0, 0.0, 0.2, 1.0, 1.0, 0.1);
    FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &compMat.pos, &vel, 0.0, &v8, -1.0, 1.2, 0.6, 0);
    FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &compMat.pos, &vel, 0.05, &v8, -1.0, 1.2, 0.6, 0);
    if ( this->m_fireTime < 1 || (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) != 0 )
    {
      FxSystem_c::Kill(this->m_fxSysFire);
      this->m_fxSysFire = 0;
    }
  }
}

//----- (00575F08) --------------------------------------------------------
void __fastcall CPlane::ProcessControlInputs(CPlane *this, uint8 CtrlNum)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d9
  float32x2_t v5; // d10
  float32x2_t v6; // d11
  int32 v8; // r8
  CMatrix *m_pMat; // r0
  float v10; // s18
  float v11; // s20
  float v12; // s16
  CPad *Pad; // r0
  float SteeringLeftRight; // s22
  CPad *v15; // r0
  float v16; // s20
  float SteeringUpDown; // s24
  float x; // s22
  float y; // s24
  _BOOL4 IsPressed; // r5
  _BOOL4 v21; // r9
  _BOOL4 v22; // r6
  _BOOL4 v23; // r0
  float v24; // s6
  float v25; // s4
  float v26; // s8
  float v27; // s2
  float v28; // s0
  float v29; // s6
  float v30; // s16
  float *p_m_fRollControl; // r1
  float *p_m_fPitchControl; // r0
  float v33; // s10
  float v34; // s2
  float v35; // s4
  float v36; // s6
  bool v37; // fnf
  unsigned __int32 v38; // s4
  CPad *v39; // r0
  float v40; // s0
  float *p_m_fYawControl; // r5
  int m_nModelIndex; // r0
  float v43; // s4
  float m_fYawControl; // s0
  CPad *v45; // r0
  int v46; // r0
  float v47; // s2
  float v48; // s4
  float v49; // s0
  float v50; // s2
  float *p_m_fSteerAngle; // r6
  float v52; // s4
  float v53; // s6
  float32x2_t v54; // d1
  CPad *v55; // r0
  float *p_m_fThrottleControl; // r5
  CPad *v57; // r0
  int Accelerate; // r5
  CPad *v59; // r0
  CSimpleTransform *p_m_transform; // r5
  CMatrix *v61; // r0
  CSimpleTransform *p_tx; // r2
  float GroundZFor3DCoord; // r0
  CMatrix *v64; // r1
  CPad *v65; // r0
  float *v66; // r0
  float v67; // s0
  float v68; // s0
  float fDragCoeff; // s2
  float v70; // s0
  float v71; // s0
  __int64 v72; // r0
  float v73; // s0
  float v74; // s2
  CPad *v75; // r0
  int m_nSuspensionHydraulics; // r2
  unsigned int v77; // r1
  CPad *v78; // r0
  unsigned int v79; // r2
  float v80; // s2
  float v81; // s0
  float v82; // s4
  float v83; // s6
  int m_nVehicleFlags; // r0
  CPad *v85; // r0
  CPad *v86; // r0
  float Brake; // s0
  float v88; // s0
  CPad *v89; // r0
  CPad *v90; // r0
  CPlayerPed *PlayerPed; // r0
  float v92; // s0
  float v93; // s4
  float z; // s2
  float v95; // s6
  float v96; // s6
  float *p_m_fLGearAngle; // r0
  float m_fLGearAngle; // s0
  bool pBool; // [sp+Bh] [bp-45h] BYREF
  float pfValueOut[17]; // [sp+Ch] [bp-44h] BYREF

  v8 = CtrlNum;
  m_pMat = this->m_pMat;
  v10 = this->m_vecMoveSpeed.y * m_pMat->yy;
  v11 = this->m_vecMoveSpeed.x * m_pMat->xy;
  v12 = this->m_vecMoveSpeed.z * m_pMat->zy;
  Pad = CPad::GetPad(CtrlNum);
  SteeringLeftRight = (float)CPad::GetSteeringLeftRight(Pad);
  v15 = CPad::GetPad(v8);
  v16 = v11 + v10;
  SteeringUpDown = (float)CPad::GetSteeringUpDown(v15);
  if ( CHID::GetInputType() == 2 )
  {
    CPad::GetPad(v8);
    x = CPad::NewMouseControllerState.m_AmountMoved.x;
    CPad::GetPad(v8);
    y = CPad::NewMouseControllerState.m_AmountMoved.y;
    IsPressed = CHID::IsPressed(HID_MAPPING_FLIGHT_ALT_LEFT, 0);
    v21 = CHID::IsPressed(HID_MAPPING_FLIGHT_ALT_RIGHT, 0);
    v22 = CHID::IsPressed(HID_MAPPING_FLIGHT_ALT_UP, 0);
    v23 = CHID::IsPressed(HID_MAPPING_FLIGHT_ALT_DOWN, 0);
    v24 = x * 0.12;
    v25 = y * 0.08;
    if ( v22 )
      v25 = -1.0;
    if ( IsPressed )
      v24 = -1.0;
    v26 = (float)((float)((float)MobileSettings::settings[31].value / 100.0) * 0.5) + 0.5;
    if ( v23 )
      v25 = 1.0;
    if ( v21 )
      v24 = 1.0;
    v27 = v25 * (float)((float)((float)((float)MobileSettings::settings[32].value / 100.0) * 0.5) + 0.5);
    v28 = v24 * v26;
    v29 = (float)(v24 * v26) * 0.75;
    if ( this->m_nModelIndex == 513 )
    {
      v28 = v29;
      v27 = v27 * 0.75;
    }
  }
  else
  {
    v28 = SteeringLeftRight * 0.0078125;
    v27 = SteeringUpDown * 0.0078125;
  }
  v6.n64_u32[0] = -1.0;
  v30 = v16 + v12;
  v5.n64_u32[0] = 1.0;
  p_m_fRollControl = &this->m_fRollControl;
  p_m_fPitchControl = &this->m_fPitchControl;
  v33 = -1.0;
  v34 = this->m_fPitchControl + (float)((float)(v27 - this->m_fPitchControl) * (float)(CTimer::ms_fTimeStep * 0.069));
  v35 = -1.0;
  if ( v34 > -1.0 )
    v35 = v34;
  v2.n64_f32[0] = *p_m_fRollControl + (float)((float)(v28 - *p_m_fRollControl) * (float)(CTimer::ms_fTimeStep * 0.069));
  if ( v35 >= 1.0 )
    v33 = 1.0;
  v36 = v33;
  v37 = v35 < 1.0;
  v38 = vmin_f32(vmax_f32(v2, v6), v5).n64_u32[0];
  if ( v34 > -1.0 )
    v36 = v34;
  if ( !v37 )
    v36 = v33;
  *p_m_fRollControl = v2.n64_f32[0];
  *p_m_fPitchControl = v34;
  *(_DWORD *)p_m_fRollControl = v38;
  *p_m_fPitchControl = v36;
  v39 = CPad::GetPad(v8);
  v40 = (float)CPad::GetSteeringLeftRight(v39);
  p_m_fYawControl = &this->m_fYawControl;
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  v43 = v40 * 0.0078125;
  m_fYawControl = this->m_fYawControl;
  if ( m_nModelIndex == 539 )
  {
    *p_m_fYawControl = m_fYawControl + (float)((float)(v43 - m_fYawControl) * (float)(CTimer::ms_fTimeStep * 0.02));
    v45 = CPad::GetPad(v8);
    v46 = CPad::GetSteeringLeftRight(v45);
    m_fYawControl = *p_m_fYawControl;
    v47 = (float)((float)((float)v46 * 0.0078125) - *p_m_fYawControl) * 0.2;
    v48 = CTimer::ms_fTimeStep;
    m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  }
  else
  {
    v48 = v43 - m_fYawControl;
    v47 = CTimer::ms_fTimeStep * 0.069;
  }
  v49 = (float)(v48 * v47) + m_fYawControl;
  v4.n64_u32[0] = 1036831949;
  v50 = -1.0;
  p_m_fSteerAngle = &this->m_fSteerAngle;
  v52 = -1.0;
  if ( v49 > -1.0 )
    v50 = v49;
  if ( v50 >= 1.0 )
    v52 = 1.0;
  v53 = v52;
  if ( v49 > -1.0 )
    v53 = v49;
  if ( v50 >= 1.0 )
    v53 = v52;
  *p_m_fYawControl = v53;
  v3.n64_f32[0] = 1.0 - v30;
  v54.n64_u64[0] = vmax_f32(v3, v4).n64_u64[0];
  *p_m_fSteerAngle = v54.n64_f32[0] * (float)(v53 * (float)((float)(this->pHandling->fSteeringLock * -3.1416) / 180.0));
  if ( m_nModelIndex == 539 )
  {
    v55 = CPad::GetPad(v8);
    if ( CPad::GetHandBrake(v55) )
    {
      *p_m_fSteerAngle = *p_m_fSteerAngle * 1.5;
      *p_m_fYawControl = *p_m_fYawControl * 1.5;
    }
  }
  if ( CHID::GetInputType() == 2 )
  {
    this->m_fThrottleControl = 0.0;
    pfValueOut[0] = 0.0;
    p_m_fThrottleControl = &this->m_fThrottleControl;
    if ( CHID::IsPressed(HID_MAPPING_ACCELERATE, pfValueOut) )
      *p_m_fThrottleControl = pfValueOut[0];
    if ( CHID::IsPressed(HID_MAPPING_BRAKE, pfValueOut) )
      *p_m_fThrottleControl = -pfValueOut[0];
    if ( CHID::IsPressed(HID_MAPPING_ACCELERATE, 0) && CHID::IsPressed(HID_MAPPING_BRAKE, 0) )
      *p_m_fThrottleControl = 0.0;
  }
  else
  {
    v57 = CPad::GetPad(v8);
    Accelerate = CPad::GetAccelerate(v57);
    v59 = CPad::GetPad(v8);
    this->m_fThrottleControl = (float)(Accelerate - CPad::GetBrake(v59)) / 255.0;
  }
  p_m_transform = &this->m_transform;
  pBool = 0;
  v61 = this->m_pMat;
  p_tx = &this->m_transform;
  if ( v61 )
    p_tx = (CSimpleTransform *)&v61->tx;
  GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(
                        p_tx->m_translate.x,
                        p_tx->m_translate.y,
                        p_tx->m_translate.z,
                        &pBool,
                        0);
  v64 = this->m_pMat;
  if ( v64 )
    p_m_transform = (CSimpleTransform *)&v64->tx;
  if ( pBool && (float)(p_m_transform->m_translate.z - GroundZFor3DCoord) <= 30.0 )
  {
    v65 = CPad::GetPad(v8);
    if ( CPad::GetAccelerate(v65) || this->m_fLGearAngle != 1.0 )
    {
LABEL_54:
      if ( !CHID::IsReleased(HID_MAPPING_TOGGLE_LANDING_GEAR) )
        goto LABEL_64;
      goto LABEL_58;
    }
  }
  else if ( this->m_fLGearAngle != 0.0 )
  {
    goto LABEL_54;
  }
  CHID::IsReleased(HID_MAPPING_TOGGLE_LANDING_GEAR);
LABEL_58:
  if ( this->m_aWheelRatios[0] == 1.0
    && this->m_aWheelRatios[1] == 1.0
    && this->m_aWheelRatios[2] == 1.0
    && this->m_aWheelRatios[3] == 1.0
    && this->pFlyingHandling->fGearUpResMult < 1.0
    && this->m_nModelIndex != 464 )
  {
    p_m_fLGearAngle = &this->m_fLGearAngle;
    m_fLGearAngle = this->m_fLGearAngle;
    if ( m_fLGearAngle == 0.0 )
    {
      *p_m_fLGearAngle = m_fLGearAngle + (float)(CTimer::ms_fTimeStep * 0.02);
      *(_DWORD *)this->Damage.m_Wheel = 33686018;
    }
    else if ( m_fLGearAngle == 1.0 )
    {
      *p_m_fLGearAngle = (float)(CTimer::ms_fTimeStep * 0.02) + -1.0;
    }
    else
    {
      *p_m_fLGearAngle = -m_fLGearAngle;
    }
    goto LABEL_72;
  }
LABEL_64:
  v66 = &this->m_fLGearAngle;
  v67 = this->m_fLGearAngle;
  if ( v67 < 0.0 )
  {
    v68 = v67 + (float)(CTimer::ms_fTimeStep * 0.02);
    *v66 = v68;
    if ( v68 < 0.0 )
      goto LABEL_72;
    *v66 = 0.0;
    fDragCoeff = this->pHandling->fDragCoeff;
    *(_DWORD *)this->Damage.m_Wheel = 0;
    v70 = (float)(fDragCoeff * 0.5) / 1000.0;
    goto LABEL_71;
  }
  if ( v67 > 0.0 && v67 < 1.0 )
  {
    v71 = v67 + (float)(CTimer::ms_fTimeStep * 0.02);
    *v66 = v71;
    if ( v71 >= 1.0 )
    {
      *v66 = 1.0;
      v72 = *(_QWORD *)&this->pHandling;
      v73 = (float)(*(float *)(v72 + 16) * 0.5) / 1000.0;
      v74 = *(float *)(HIDWORD(v72) + 48);
      *(_DWORD *)this->Damage.m_Wheel = 33686018;
      v70 = v74 * v73;
LABEL_71:
      this->m_fAirResistance = v70;
    }
  }
LABEL_72:
  if ( this->m_nModelIndex == 520 )
  {
    if ( CHID::GetInputType() && CHID::GetInputType() != 1 )
    {
      if ( CHID::GetInputType() == 2 )
      {
        v80 = 0.0;
        v81 = (float)(CTimer::ms_fTimeStep
                    * (float)(HARRIER_NOZZLE_ROTATERATE
                            * (float)CPlane::ProcessControlInputs(unsigned char)::nKeyboardSuspensionDirection))
            + (float)this->m_nSuspensionHydraulics;
        v82 = (float)CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
        v83 = v81;
        if ( v81 < 0.0 )
          v83 = 0.0;
        if ( v83 >= v82 )
          v80 = (float)CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
        if ( v81 < 0.0 )
          v81 = v80;
        if ( v83 >= v82 )
          v81 = v80;
        this->m_nSuspensionHydraulics = (unsigned int)v81;
        if ( CHID::IsReleased(HID_MAPPING_FLIGHT_DESCEND) )
          CPlane::ProcessControlInputs(unsigned char)::nKeyboardSuspensionDirection = (int)(float)-(float)CPlane::ProcessControlInputs(unsigned char)::nKeyboardSuspensionDirection;
      }
    }
    else
    {
      if ( v30 > 0.15 )
      {
        v75 = CPad::GetPad(v8);
        if ( CPad::GetAccelerate(v75) )
        {
          m_nSuspensionHydraulics = this->m_nSuspensionHydraulics;
          this->m_nOldSuspensionHydraulics = m_nSuspensionHydraulics;
          v54.n64_u32[0] = 0;
          v2.n64_f32[0] = (float)(HARRIER_NOZZLE_ROTATERATE * CTimer::ms_fTimeStep) + (float)-m_nSuspensionHydraulics;
          v2.n64_u64[0] = vmax_f32(v2, v54).n64_u64[0];
          v77 = (unsigned int)v2.n64_f32[0];
          if ( (int)(unsigned int)v2.n64_f32[0] > CPlane::HARRIER_NOZZLE_ROTATE_LIMIT )
            LOWORD(v77) = CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
          this->m_nSuspensionHydraulics = v77;
        }
      }
      if ( v30 < 0.88 )
      {
        v78 = CPad::GetPad(v8);
        if ( CPad::GetBrake(v78) )
        {
          v79 = this->m_nSuspensionHydraulics;
          this->m_nOldSuspensionHydraulics = v79;
          v54.n64_u32[0] = 0;
          v2.n64_f32[0] = (float)(HARRIER_NOZZLE_ROTATERATE * CTimer::ms_fTimeStep) + (float)v79;
          this->m_nSuspensionHydraulics = (unsigned int)vmax_f32(v2, v54).n64_f32[0];
        }
      }
    }
    if ( this->m_nSuspensionHydraulics > CPlane::HARRIER_NOZZLE_ROTATE_LIMIT )
      this->m_nSuspensionHydraulics = CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
  }
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  this->m_fGasPedal = 0.0;
  *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFDF;
  if ( v30 > 0.0 && (v85 = CPad::GetPad(v8), CPad::GetBrake(v85)) )
  {
    v86 = CPad::GetPad(v8);
    Brake = (float)CPad::GetBrake(v86);
    if ( v30 > 0.35 )
      Brake = Brake * 0.5;
    v88 = Brake / 255.0;
  }
  else if ( sqrtf(
              (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                    + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
            + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) >= 0.1
         || (v89 = CPad::GetPad(v8), CPad::GetBrake(v89) > 9)
         || (v90 = CPad::GetPad(v8), CPad::GetAccelerate(v90) >= 10) )
  {
    v88 = 0.0;
  }
  else
  {
    v88 = 0.5;
  }
  this->m_fBrakePedal = v88;
  if ( CPad::GetPad(v8)->DisablePlayerControls )
  {
    this->m_fBrakePedal = 1.0;
    *(_DWORD *)&this->m_nVehicleFlags |= 0x20u;
    this->m_fGasPedal = 0.0;
    PlayerPed = FindPlayerPed(-1);
    CPlayerPed::KeepAreaAroundPlayerClear(PlayerPed);
    v92 = this->m_vecMoveSpeed.x;
    v93 = this->m_vecMoveSpeed.y;
    z = this->m_vecMoveSpeed.z;
    v95 = sqrtf((float)((float)(v92 * v92) + (float)(v93 * v93)) + (float)(z * z));
    if ( v95 > 0.28 )
    {
      v96 = 0.28 / v95;
      this->m_vecMoveSpeed.x = v92 * v96;
      this->m_vecMoveSpeed.y = v93 * v96;
      this->m_vecMoveSpeed.z = z * v96;
    }
  }
}
// 5760D8: variable 'v2' is possibly undefined
// 5760D8: variable 'v6' is possibly undefined
// 5760DC: variable 'v5' is possibly undefined
// 576200: variable 'v3' is possibly undefined
// 576200: variable 'v4' is possibly undefined

//----- (00576874) --------------------------------------------------------
void __fastcall CPlane::SetGearDown(CPlane *this)
{
  tHandlingData *pHandling; // r1
  float fDragCoeff; // s2

  pHandling = this->pHandling;
  this->m_fLGearAngle = 0.0;
  fDragCoeff = pHandling->fDragCoeff;
  *(_DWORD *)this->Damage.m_Wheel = 0;
  this->m_fAirResistance = (float)(fDragCoeff * 0.5) / 1000.0;
}

//----- (005768A0) --------------------------------------------------------
void __fastcall CPlane::SetGearUp(CPlane *this)
{
  __int64 v1; // kr00_8
  float v2; // s0
  float v3; // s2

  v1 = *(_QWORD *)&this->pHandling;
  this->m_fLGearAngle = 1.0;
  v2 = (float)(*(float *)(v1 + 16) * 0.5) / 1000.0;
  v3 = *(float *)(HIDWORD(v1) + 48);
  *(_DWORD *)this->Damage.m_Wheel = 33686018;
  this->m_fAirResistance = v3 * v2;
}

//----- (005768E0) --------------------------------------------------------
void __fastcall CPlane::ProcessFlyingCarStuff(CPlane *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d12
  float v6; // s16
  float v7; // s18
  int v8; // r0
  float x; // s22
  float y; // s30
  float v11; // s2
  float z; // s28
  float v13; // s4
  float v14; // s0
  float m_fRollControl; // s16
  float m_fPitchControl; // s18
  float m_fYawControl; // s20
  unsigned int v18; // s0
  float m_nHealth; // s2
  CMatrix *m_pMat; // r0
  float v21; // s0
  float v22; // s0
  CEntity::CEntityInfo *p_m_info; // r9
  RwFrame_0 **v24; // r8
  int v25; // r10
  float v26; // s28
  int v27; // r5
  signed int AeroplaneCompStatus; // r6
  int v29; // r9
  float v30; // s19
  float v31; // s23
  float v32; // s30
  float v33; // s19
  float v34; // s23
  float v35; // s0
  float *v36; // r0
  float v37; // s23
  float v38; // s0
  float *v39; // r0
  float v40; // s2
  float v41; // s0
  float v42; // s23
  float v43; // s0
  float *v44; // r0
  CMatrix *v45; // r1
  CSimpleTransform *p_tx; // r0
  CSimpleTransform *p_m_transform; // r3
  float32x2_t v48; // d16
  RwFrame_0 *v49; // r0
  __int64 v50; // d16
  RwReal v51; // s0
  RwReal v52; // s4
  unsigned int v53; // r0
  float *v54; // r8
  float m_fThrottleControl; // s0
  float v56; // s22
  float v57; // s2
  CMatrix *v58; // r0
  CSimpleTransform *v59; // r6
  eFlightModel v60; // r5
  CSimpleTransform *v61; // r1
  float v62; // r1
  CMatrix *v63; // r0
  CSimpleTransform *v64; // r1
  float v65; // r0
  CMatrix *v66; // r1
  float v67; // s24
  float32x2_t v68; // d1
  int v69; // r2
  int m_nVehicleFlags; // r0
  float v71; // s0
  int m_nModelIndex; // r1
  float v73; // r2
  float v74; // s0
  float v75; // r3
  CPlane *v76; // r0
  eFlightModel v77; // r1
  float *p_m_fEngineSpeed; // r0
  float m_fEngineSpeed; // s2
  float *v80; // r1
  tFlyingHandlingData *pFlyingHandling; // r5
  float *p_m_fYawControl; // [sp+34h] [bp-BCh]
  float *p_m_fPitchControl; // [sp+44h] [bp-ACh]
  float *p_m_fRollControl; // [sp+48h] [bp-A8h]
  float *p_m_fThrottleControl; // [sp+50h] [bp-A0h]
  RwV3d_0 vel; // [sp+54h] [bp-9Ch] BYREF
  FxPrtMult_c v87; // [sp+60h] [bp-90h] BYREF
  CVector v; // [sp+80h] [bp-70h] BYREF

  v6 = CTimer::ms_fTimeStep;
  if ( CTimer::ms_fTimeStep <= 0.0 )
    return;
  v4.n64_u32[0] = 1.0;
  v7 = PLANE_DAMAGE_WAVE_COUNTER_VAR;
  v8 = rand();
  x = this->m_vecMoveSpeed.x;
  y = this->m_vecMoveSpeed.y;
  v11 = 1.0 - v7;
  z = this->m_vecMoveSpeed.z;
  v13 = (float)((float)(v7 + 1.0) - (float)(1.0 - v7)) * (float)((float)v8 * 4.6566e-10);
  v14 = (float)(unsigned int)(float)((float)(v6 / 50.0) * 1000.0);
  p_m_fRollControl = &this->m_fRollControl;
  m_fRollControl = this->m_fRollControl;
  p_m_fPitchControl = &this->m_fPitchControl;
  m_fPitchControl = this->m_fPitchControl;
  p_m_fYawControl = &this->m_fYawControl;
  m_fYawControl = this->m_fYawControl;
  v18 = (unsigned int)(float)((float)(v11 + v13) * v14);
  m_nHealth = this->m_nHealth;
  this->m_nDamageControlWaveCounter += v18;
  if ( m_nHealth < 250.0 && *(_BYTE *)&this->m_info <= 7u )
  {
    CDamageManager::SetAeroplaneCompStatus(&this->Damage, 12, 2u);
    CDamageManager::SetAeroplaneCompStatus(&this->Damage, 13, 2u);
    m_pMat = this->m_pMat;
    if ( m_pMat )
    {
      v21 = sqrtf((float)(m_pMat->xx * m_pMat->xx) + (float)(m_pMat->yx * m_pMat->yx));
      if ( m_pMat->zz < 0.0 )
        v21 = -v21;
      v22 = atan2f(m_pMat->zx, v21);
      if ( fabsf(v22) < 2.3562 )
        m_fRollControl = m_fRollControl + 0.75;
    }
    else
    {
      m_fRollControl = m_fRollControl + 0.75;
      v22 = 0.0;
    }
    m_fYawControl = m_fYawControl + 0.5;
    if ( fabsf(v22) > 1.5708 )
      m_fPitchControl = m_fPitchControl + 0.5;
  }
  if ( this->m_nModelIndex == 464 )
  {
    p_m_info = &this->m_info;
  }
  else
  {
    p_m_fThrottleControl = &this->m_fThrottleControl;
    v24 = &this->m_aCarNodes[12];
    v25 = 0;
    v1.n64_f32[0] = sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z)) * 3.0;
    LODWORD(v26) = vmin_f32(v1, v4).n64_u32[0];
    do
    {
      v27 = v25 + 12;
      AeroplaneCompStatus = CDamageManager::GetAeroplaneCompStatus(&this->Damage, v25 + 12);
      if ( AeroplaneCompStatus >= 1 && v24[v25] )
      {
        if ( v27 == this->BouncingPanels[0].m_nComponentIndex )
        {
          v29 = 0;
        }
        else if ( v27 == this->BouncingPanels[1].m_nComponentIndex )
        {
          v29 = 1;
        }
        else if ( v27 == this->BouncingPanels[2].m_nComponentIndex )
        {
          v29 = 2;
        }
        else
        {
          v29 = -1;
          if ( v27 == SLOWORD(this->ChassisDoor.m_fOpenAngle) )
            v29 = 3;
        }
        switch ( v25 )
        {
          case 0:
          case 1:
          case 2:
          case 3:
            v30 = (float)AeroplaneCompStatus;
            if ( *p_m_fThrottleControl > 0.0 )
            {
              v31 = CTimer::ms_fTimeStep;
              v32 = (float)((float)((float)rand() * 4.6566e-10) * 1.6) + 0.2;
              *p_m_fThrottleControl = *p_m_fThrottleControl
                                    + (float)((float)(sinf(
                                                        (float)((float)this->m_nDamageControlWaveCounter * 6.2832)
                                                      / 2500.0)
                                                    + -1.0)
                                            * (float)((float)((float)((float)(v30 * 0.2) * v30) * v31) * v32));
            }
            v33 = v30 * 0.5;
            goto LABEL_40;
          case 4:
            v33 = (float)AeroplaneCompStatus * 0.2;
            *p_m_fYawControl = (float)(1.0 - v33) * *p_m_fYawControl;
            v42 = v26 * (float)(AeroplaneCompStatus * AeroplaneCompStatus);
            m_fYawControl = *p_m_fYawControl
                          + (float)(CTimer::ms_fTimeStep
                                  * (float)(v42 * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.1) + -0.05)));
            *p_m_fYawControl = m_fYawControl;
            if ( v29 >= 0 )
            {
              v43 = (float)rand();
              v44 = (float *)((char *)this + 32 * v29);
              m_fYawControl = m_fYawControl + (float)(v44[435] * -10.0);
              v44[438] = v44[438]
                       + (float)(CTimer::ms_fTimeStep
                               * (float)(v42 * (float)((float)((float)(v43 * 4.6566e-10) * 0.004) + -0.002)));
            }
            goto LABEL_40;
          case 5:
          case 6:
            *p_m_fPitchControl = (float)((float)((float)AeroplaneCompStatus * -0.2) + 1.0) * *p_m_fPitchControl;
            v34 = v26 * (float)(AeroplaneCompStatus * AeroplaneCompStatus);
            m_fPitchControl = *p_m_fPitchControl
                            + (float)(CTimer::ms_fTimeStep
                                    * (float)(v34 * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.1) + -0.05)));
            *p_m_fPitchControl = m_fPitchControl;
            if ( v29 >= 0 )
            {
              v35 = (float)rand();
              v36 = (float *)((char *)this + 32 * v29);
              m_fPitchControl = m_fPitchControl + (float)(v36[435] * -10.0);
              v36[438] = v36[438]
                       + (float)(CTimer::ms_fTimeStep
                               * (float)(v34 * (float)((float)((float)(v35 * 4.6566e-10) * 0.004) + -0.002)));
            }
            v33 = (float)AeroplaneCompStatus * 0.15;
            goto LABEL_40;
          case 7:
          case 8:
            *p_m_fRollControl = (float)((float)((float)AeroplaneCompStatus * -0.2) + 1.0) * *p_m_fRollControl;
            v37 = v26 * (float)(AeroplaneCompStatus * AeroplaneCompStatus);
            m_fRollControl = *p_m_fRollControl
                           + (float)(CTimer::ms_fTimeStep
                                   * (float)(v37 * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.1) + -0.05)));
            *p_m_fRollControl = m_fRollControl;
            if ( v29 >= 0 )
            {
              v38 = (float)rand();
              v39 = (float *)((char *)this + 32 * v29);
              v40 = v39[438]
                  + (float)(CTimer::ms_fTimeStep
                          * (float)(v37 * (float)((float)((float)(v38 * 4.6566e-10) * 0.004) + -0.002)));
              v41 = v39[435] * 10.0;
              v39[438] = v40;
              if ( v25 == 7 )
                m_fRollControl = m_fRollControl + v41;
              else
                m_fRollControl = m_fRollControl - v41;
            }
            v33 = (float)AeroplaneCompStatus * 0.25;
LABEL_40:
            if ( v33 > 0.0 && (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) == 0 && (v26 > 0.3 || (rand() & 7) == 0) )
            {
              v45 = this->m_pMat;
              p_tx = (CSimpleTransform *)&v45->tx;
              if ( !v45 )
                p_tx = &this->m_transform;
              p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
              if ( !TheCamera.m_pMat )
                p_m_transform = &TheCamera.m_transform;
              v48.n64_u64[0] = vsub_f32(
                                 *(float32x2_t *)&p_tx->m_translate.y,
                                 *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
              v2.n64_u64[0] = vmul_f32(v48, v48).n64_u64[0];
              if ( (float)((float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                                         * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                                 + v2.n64_f32[0])
                         + v2.n64_f32[1]) < 6400.0
                || *(_BYTE *)&this->m_info <= 7u )
              {
                v49 = v24[v25];
                if ( v49 )
                {
                  v50 = *(_QWORD *)&v49->modelling.pos.x;
                  v.z = v49->modelling.pos.z;
                  *(_QWORD *)&v.x = v50;
                  operator*((CVector *)&v87, v45, &v);
                  v.z = v87.m_blue;
                  *(_QWORD *)&v.x = *(_QWORD *)&v87.m_red;
                  FxPrtMult_c::FxPrtMult_c(&v87, 0.0, 0.0, 0.0, 0.2, 1.0, 1.0, v33);
                  v51 = (float)(this->m_vecMoveSpeed.x * 0.25) * 50.0;
                  v52 = (float)(this->m_vecMoveSpeed.z * 0.25) * 50.0;
                  vel.y = (float)(this->m_vecMoveSpeed.y * 0.25) * 50.0;
                  vel.x = v51;
                  vel.z = v52;
                  vel.x = v51 * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + 0.9);
                  vel.y = vel.y * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + 0.9);
                  vel.z = vel.z * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + 0.9);
                  v87.m_life = (float)((float)rand() * 4.6566e-10) + 0.0;
                  v.x = v.x + (float)((float)((float)(v33 + v33) * (float)((float)rand() * 4.6566e-10)) - v33);
                  v.y = v.y + (float)((float)((float)(v33 + v33) * (float)((float)rand() * 4.6566e-10)) - v33);
                  v.z = v.z + (float)((float)((float)(v33 + v33) * (float)((float)rand() * 4.6566e-10)) - v33);
                  FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &v, &vel, 0.0, &v87, -1.0, 1.2, 0.6, 0);
                }
              }
            }
            break;
          default:
            break;
        }
      }
      ++v25;
    }
    while ( v25 != 13 );
    p_m_info = &this->m_info;
  }
  v53 = *(_BYTE *)p_m_info >> 3;
  if ( v53 > 8 || ((1 << v53) & 0x109) == 0 )
  {
    p_m_fEngineSpeed = &this->m_fEngineSpeed;
    m_fEngineSpeed = this->m_fEngineSpeed;
    if ( m_fEngineSpeed <= (float)(CTimer::ms_fTimeStep * 0.001) )
    {
      *p_m_fEngineSpeed = 0.0;
      *(_DWORD *)&this->m_nVehicleFlags &= ~0x10u;
    }
    else
    {
      v80 = (float *)sub_57747C;
      if ( m_fEngineSpeed > CPlane::PLANE_STD_PROP_SPEED )
        v80 = (float *)&loc_577480;
      *p_m_fEngineSpeed = m_fEngineSpeed - (float)(CTimer::ms_fTimeStep * *v80);
      this->m_nNoOfStaticFrames = 0;
    }
    return;
  }
  v54 = &this->m_fThrottleControl;
  m_fThrottleControl = this->m_fThrottleControl;
  v56 = CPlane::PLANE_STD_PROP_SPEED;
  if ( m_fThrottleControl <= 0.0 )
  {
    if ( m_fThrottleControl >= 0.0 )
      goto LABEL_61;
    v57 = CPlane::PLANE_STD_PROP_SPEED - CPlane::PLANE_MIN_PROP_SPEED;
  }
  else
  {
    v57 = CPlane::PLANE_MAX_PROP_SPEED - CPlane::PLANE_STD_PROP_SPEED;
  }
  v56 = CPlane::PLANE_STD_PROP_SPEED + (float)(m_fThrottleControl * v57);
LABEL_61:
  if ( (v53 & 0x17 | 8) == 8 )
  {
    v58 = this->m_pMat;
    v59 = &this->m_transform;
    v60 = FLIGHTMODEL_PLANE;
    v61 = &this->m_transform;
    if ( v58 )
      v61 = (CSimpleTransform *)&v58->tx;
    v62 = v61->m_translate.z;
    if ( this->m_nModelIndex == 464 )
      v60 = FLIGHTMODEL_RCPLANE;
    if ( CVehicle::HeightAboveCeiling(this, v62, v60) > 0.0 )
    {
      v63 = this->m_pMat;
      v64 = &this->m_transform;
      if ( v63 )
        v64 = (CSimpleTransform *)&v63->tx;
      v65 = CVehicle::HeightAboveCeiling(this, v64->m_translate.z, v60);
      v66 = this->m_pMat;
      if ( v66 )
        v59 = (CSimpleTransform *)&v66->tx;
      v3.n64_f32[0] = v65 / 50.0;
      v2.n64_u32[0] = 0;
      v67 = *v54;
      v1.n64_f32[0] = v67 + (float)(CVehicle::HeightAboveCeiling(this, v59->m_translate.z, v60) / -25.0);
      v68.n64_u64[0] = vmax_f32(v3, v2).n64_u64[0];
      v56 = v56 * v68.n64_f32[0];
      v68.n64_u32[0] = -1.0;
      *(_DWORD *)v54 = vmax_f32(v1, v68).n64_u32[0];
    }
  }
  v69 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  v71 = this->m_fEngineSpeed
      + (float)((float)((float)(v56 - this->m_fEngineSpeed) * CPlane::PLANE_ROC_PROP_SPEED) * CTimer::ms_fTimeStep);
  this->m_fEngineSpeed = v71;
  if ( (m_nVehicleFlags & 0x40000000) != 0 )
  {
    v71 = 0.0;
    m_nVehicleFlags &= ~0x10u;
    this->m_fEngineSpeed = 0.0;
    *v54 = 0.0;
    *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v69;
  }
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( m_nModelIndex == 464 )
  {
    if ( (m_nVehicleFlags & 0x40000010) == 0x10 )
    {
      v73 = m_fYawControl;
      v74 = *v54;
      v75 = m_fPitchControl;
      v76 = this;
      v77 = FLIGHTMODEL_RCPLANE;
LABEL_84:
      CVehicle::FlyingControl(v76, v77, v73, v75, m_fRollControl, v74);
    }
  }
  else if ( (m_nVehicleFlags & 0x10) != 0
         && (v71 > CPlane::PLANE_MIN_PROP_SPEED
          || (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                           + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                   + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.05) )
  {
    if ( m_nModelIndex != 520
      || *(_BYTE *)p_m_info > 7u
      || this->m_nSuspensionHydraulics < CPlane::HARRIER_NOZZLE_SWITCH_LIMIT )
    {
      v73 = m_fYawControl;
      v74 = *v54;
      v75 = m_fPitchControl;
      v76 = this;
      v77 = FLIGHTMODEL_PLANE;
      goto LABEL_84;
    }
    pFlyingHandling = this->pFlyingHandling;
    this->pFlyingHandling = cHandlingDataMgr::GetFlyingPointer(
                              &mod_HandlingManager,
                              *((_BYTE *)&CModelInfo::ms_modelInfoPtrs[425][1].m_flags + 2));
    if ( *v54 > 0.0 || this->nNoOfContactWheels <= 3u && (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 8) == 0 )
      CVehicle::FlyingControl(this, FLIGHTMODEL_HELI, m_fYawControl, m_fPitchControl, -m_fRollControl, *v54 * 0.25);
    this->pFlyingHandling = pFlyingHandling;
  }
}
// 576B04: variable 'v1' is possibly undefined
// 576B04: variable 'v4' is possibly undefined
// 577216: variable 'v3' is possibly undefined
// 577216: variable 'v2' is possibly undefined
// 57747C: using guessed type int sub_57747C();

//----- (00577484) --------------------------------------------------------
void __fastcall CPlane::PreRender(CPlane *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d4
  float32x2_t v4; // d8
  float32x2_t v5; // d9
  CVehicleModelInfo *v7; // r9
  CColModel *ColModel; // r8
  float *m_aWheelRatios; // r5
  CVector *p_m_vecNormal; // r4
  int32 i; // r6
  float v12; // s24
  float v13; // s26
  float v14; // s28
  float v15; // s2
  float v16; // s0
  float v17; // s2
  bool v18; // nf
  int32 v19; // r5
  float *p_m_fPropellerAngle; // r6
  float v21; // s0
  RwFrame_0 *v22; // r0
  char v23; // r4
  CVehicleModelInfo::CVehicleStructure *m_pStructure; // r0
  __int64 v25; // d16
  RwReal z; // r0
  RwFrame_0 *v27; // r0
  RwFrame_0 *v28; // r0
  float v29; // s16
  float v30; // s18
  float v31; // s0
  RwFrame_0 *v32; // r1
  bool v33; // zf
  float v34; // s0
  char v35; // r4
  CVehicleModelInfo::CVehicleStructure *v36; // r0
  __int64 v37; // d16
  RwReal v38; // r0
  RwFrame_0 *v39; // r0
  RwFrame_0 *v40; // r0
  char v41; // r4
  CVehicleModelInfo::CVehicleStructure *v42; // r0
  __int64 v43; // d16
  RwReal v44; // r0
  RwFrame_0 *v45; // r0
  float v46; // r2
  RwFrame_0 *v47; // r1
  RwFrame_0 *v48; // r1
  RwFrame_0 *v49; // r1
  RwFrame_0 *v50; // r1
  int m_nModelIndex; // r0
  float v52; // s0
  float v53; // s18
  float v54; // s16
  float v55; // s20
  int32 v56; // r8
  int32 v57; // r6
  float *p_m_fLGearAngle; // r4
  int v59; // r0
  float v60; // s0
  FxSystem_c *v61; // r0
  FxSystem_c *v62; // r0
  FxSystem_c *v63; // r0
  FxSystem_c *v64; // r0
  FxSystem_c *v65; // r0
  CCollisionData *m_pColData; // r5
  CMatrix *m_pMat; // r0
  float x; // s2
  float y; // s6
  float v70; // s4
  float v71; // s0
  float v72; // s10
  int v73; // s0
  int v74; // s12
  float v75; // s2
  bool v76; // cc
  float v77; // s18
  float v78; // s20
  float v79; // s16
  float v80; // s22
  float v81; // s26
  float v82; // r0
  float v83; // s6
  float v84; // s8
  float v85; // s2
  float v86; // s8
  float v87; // s16
  FxSystem_c *m_fxSysHeliDust; // r0
  RwObject_0 *m_pRwObject; // r0
  RwFrame_0 *v90; // r8
  RwFrame_0 *v91; // r5
  char *parent; // r0
  FxSystem_c *FxSystem; // r0
  char *v94; // r0
  FxSystem_c *v95; // r0
  char *v96; // r0
  FxSystem_c *v97; // r0
  char *v98; // r0
  FxSystem_c *v99; // r0
  const CMatrix *p_modelling; // r6
  const CMatrix *v101; // r8
  int m_nComponentIndex; // r1
  int v103; // r1
  int v104; // r1
  RwReal v105; // s0
  RwReal v106; // s2
  int v107; // r0
  CVehicleModelInfo *v108; // r4
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r5
  bool v110; // zf
  VEH_SHD_TYPE v111; // r1
  int v112; // r0
  bool v113; // zf
  CMatrix *v114; // r1
  float v115; // s16
  float fAttackLiftMult; // s28
  RwV3d_0 *v117; // r0
  float v118; // s18
  float v119; // s20
  __int64 v120; // d16
  float xz; // s22
  float yz; // s24
  float zz; // s26
  unsigned int v124; // r4
  int v125; // r0
  RwReal v126; // s0
  FxSystem_c *m_fxSysSmokeHuge; // r0
  RwReal v128; // s2
  RwReal v129; // s2
  RwReal v130; // s0
  CVector v131; // [sp+28h] [bp-150h] BYREF
  CVector SecondPoint; // [sp+38h] [bp-140h] BYREF
  CVector v133; // [sp+48h] [bp-130h] BYREF
  CMatrix v; // [sp+58h] [bp-120h] BYREF
  RwV3d_0 pos; // [sp+A0h] [bp-D8h] BYREF
  RpAtomic_0 *data; // [sp+ACh] [bp-CCh] BYREF
  CVector v137; // [sp+B0h] [bp-C8h] BYREF
  CVector posn; // [sp+BCh] [bp-BCh] BYREF
  CMatrix v139; // [sp+C8h] [bp-B0h] BYREF
  CQuaternion v140; // [sp+110h] [bp-68h] BYREF

  v139.m_pRwMat = 0;
  v139.m_owner = 0;
  data = 0;
  v7 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  ColModel = CEntity::GetColModel(this);
  CVehicle::PreRender(this);
  if ( this->m_nModelIndex == 539 )
    (*((void (__fastcall **)(CPlane *))this->_vptr$CPlaceable + 70))(this);
  if ( *((unsigned __int8 *)&this->m_nVehicleFlags + 3) << 31 )
  {
    (*((void (__fastcall **)(CPlane *))this->_vptr$CPlaceable + 53))(this);
    v4.n64_u32[0] = 1.0;
    m_aWheelRatios = this->m_aWheelRatios;
    v5.n64_u32[0] = -1.0;
    p_m_vecNormal = &this->m_aWheelColPoints[0].m_vecNormal;
    for ( i = 0; i != 4; ++i )
    {
      v12 = *m_aWheelRatios;
      v13 = m_aWheelRatios[41];
      v14 = m_aWheelRatios[45];
      CVehicleModelInfo::GetWheelPosn(v7, i, &posn, 1);
      v15 = (float)(v12 - (float)(1.0 - (float)(v13 / v14))) / (float)(1.0 - (float)(1.0 - (float)(v13 / v14)));
      v16 = posn.z + this->pHandling->fSuspensionUpperLimit;
      if ( v15 > 0.0 )
        v16 = v16 - (float)(v15 * m_aWheelRatios[41]);
      v17 = m_aWheelRatios[25];
      if ( v16 <= v17 )
      {
        v18 = (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 4) != 0;
        if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 4) != 0 )
          v18 = (this->hFlagsLocal & 0x20000) != 0;
        if ( !v18 )
          v16 = v17 + (float)((float)(v16 - v17) * 0.75);
      }
      m_aWheelRatios[25] = v16;
      if ( this->m_nModelIndex == 592 )
      {
        if ( *m_aWheelRatios >= 1.0 )
        {
          m_aWheelRatios[21] = m_aWheelRatios[21] * 0.95;
        }
        else
        {
          v1.n64_f32[0] = (float)((float)(p_m_vecNormal->x * this->m_pMat->xy)
                                + (float)(p_m_vecNormal->y * this->m_pMat->yy))
                        + (float)(p_m_vecNormal->z * this->m_pMat->zy);
          v1.n64_u64[0] = vmin_f32(vmax_f32(v1, v5), v4).n64_u64[0];
          *((_DWORD *)m_aWheelRatios + 21) = COERCE_UNSIGNED_INT(asinf(v1.n64_f32[0])) ^ 0x80000000;
        }
      }
      ++m_aWheelRatios;
      p_m_vecNormal = (CVector *)((char *)p_m_vecNormal + 44);
    }
  }
  v19 = 1;
  CAutomobile::UpdateWheelMatrix(this, 4, 1);
  CAutomobile::UpdateWheelMatrix(this, 7, 1);
  CAutomobile::UpdateWheelMatrix(this, 2, 1);
  if ( this->m_nModelIndex == 520 )
    v19 = 3;
  CAutomobile::UpdateWheelMatrix(this, 5, v19);
  p_m_fPropellerAngle = &this->m_fPropellerAngle;
  v21 = this->m_fPropellerAngle + (float)(this->m_fEngineSpeed * CTimer::ms_fTimeStep);
  this->m_fPropellerAngle = v21;
  if ( v21 > 6.2832 )
  {
    do
      v21 = v21 + -6.2832;
    while ( v21 > 6.2832 );
    *p_m_fPropellerAngle = v21;
  }
  if ( *(_BYTE *)&this->m_info <= 0x1Fu )
  {
    v22 = this->m_aCarNodes[16];
    if ( v22 )
    {
      v23 = 0;
      CMatrix::Attach(&v139, &v22->modelling, 0);
      CMatrix::UpdateRW(&v139);
      m_pStructure = v7->m_pStructure;
      v25 = *(_QWORD *)&m_pStructure->m_positions[11].x;
      z = m_pStructure->m_positions[11].z;
      *(_QWORD *)&v137.x = v25;
      v137.z = z;
      if ( *(float *)&v25 == 0.0 )
        v23 = 1;
      if ( ((unsigned __int8)v23 & (*((float *)&v25 + 1) == 0.0)) != 0 && v137.z == 0.0 )
      {
        v137.z = 1.0;
      }
      else
      {
        v137.x = *(float *)&v25 - v139.tx;
        v137.y = *((float *)&v25 + 1) - v139.ty;
        v137.z = v137.z - v139.tz;
        CVector::Normalise(&v137);
      }
      CQuaternion::Set(&v140, &v137, this->m_fYawControl * 0.69813);
      CQuaternion::Get(&v140, v139.m_pRwMat);
      if ( this->m_nModelIndex == 539 )
      {
        v27 = this->m_aCarNodes[24];
        if ( v27 )
        {
          CMatrix::Attach(&v139, &v27->modelling, 0);
          CMatrix::UpdateRW(&v139);
          CQuaternion::Get(&v140, v139.m_pRwMat);
        }
      }
    }
    v28 = this->m_aCarNodes[20];
    if ( v28 )
    {
      v29 = 1.0;
      v30 = 0.0;
      if ( this->pFlyingHandling->fGearDownLiftMult > 1.0 )
      {
        v29 = 1.0;
        v31 = fabsf(this->m_fLGearAngle);
        if ( v31 < 1.0 )
        {
          v32 = this->m_aCarNodes[21];
          v33 = v32 == 0;
          if ( !v32 )
            v33 = this->m_aCarNodes[22] == 0;
          if ( !v33 )
          {
            v34 = 1.0 - v31;
            v30 = v34 * 0.3;
            v29 = (float)(v34 * 0.5) + 1.0;
          }
        }
      }
      v35 = 0;
      CMatrix::Attach(&v139, &v28->modelling, 0);
      CMatrix::UpdateRW(&v139);
      v36 = v7->m_pStructure;
      v37 = *(_QWORD *)&v36->m_positions[9].x;
      v38 = v36->m_positions[9].z;
      *(_QWORD *)&v137.x = v37;
      v137.z = v38;
      if ( *(float *)&v37 == 0.0 )
        v35 = 1;
      if ( ((unsigned __int8)v35 & (*((float *)&v37 + 1) == 0.0)) != 0 && v137.z == 0.0 )
      {
        v137.x = 1.0;
      }
      else
      {
        v137.x = *(float *)&v37 - v139.tx;
        v137.y = *((float *)&v37 + 1) - v139.ty;
        v137.z = v137.z - v139.tz;
        CVector::Normalise(&v137);
      }
      CQuaternion::Set(&v140, &v137, v30 + (float)(this->m_fRollControl * -0.5236));
      CQuaternion::Get(&v140, v139.m_pRwMat);
      if ( v29 > 1.0 )
      {
        CMatrix::Update(&v139);
        if ( v137.x == 1.0 )
        {
          v139.yy = v29 * v139.yy;
        }
        else if ( CVehicleModelInfo::GetOriginalCompPosition(v7, &posn, 20) )
        {
          posn.y = posn.y + (float)((float)(1.0 - v29) * (float)(ColModel->m_boxBound.m_vecMax.y * 0.03));
          CMatrix::SetTranslateOnly(&v139, posn.x, posn.y, posn.z);
        }
        CMatrix::UpdateRW(&v139);
      }
      v39 = this->m_aCarNodes[19];
      if ( v39 )
      {
        CMatrix::Attach(&v139, &v39->modelling, 0);
        CMatrix::UpdateRW(&v139);
        v137.x = -v137.x;
        CQuaternion::Set(&v140, &v137, (float)(this->m_fRollControl * -0.5236) - v30);
        CQuaternion::Get(&v140, v139.m_pRwMat);
        if ( v29 > 1.0 )
        {
          CMatrix::Update(&v139);
          if ( v137.x == -1.0 )
          {
            v139.yy = v29 * v139.yy;
          }
          else if ( CVehicleModelInfo::GetOriginalCompPosition(v7, &posn, 19) )
          {
            posn.y = posn.y + (float)((float)(1.0 - v29) * (float)(ColModel->m_boxBound.m_vecMax.y * 0.03));
            CMatrix::SetTranslateOnly(&v139, posn.x, posn.y, posn.z);
          }
          CMatrix::UpdateRW(&v139);
        }
      }
    }
    v40 = this->m_aCarNodes[18];
    if ( v40 )
    {
      v41 = 0;
      CMatrix::Attach(&v139, &v40->modelling, 0);
      CMatrix::UpdateRW(&v139);
      v42 = v7->m_pStructure;
      v43 = *(_QWORD *)&v42->m_positions[10].x;
      v44 = v42->m_positions[10].z;
      *(_QWORD *)&v137.x = v43;
      v137.z = v44;
      if ( *(float *)&v43 == 0.0 )
        v41 = 1;
      if ( ((unsigned __int8)v41 & (*((float *)&v43 + 1) == 0.0)) != 0 && v137.z == 0.0 )
      {
        v137.x = 1.0;
      }
      else
      {
        v137.x = *(float *)&v43 - v139.tx;
        v137.y = *((float *)&v43 + 1) - v139.ty;
        v137.z = v137.z - v139.tz;
        CVector::Normalise(&v137);
      }
      CQuaternion::Set(&v140, &v137, this->m_fPitchControl * -0.43633);
      CQuaternion::Get(&v140, v139.m_pRwMat);
      v45 = this->m_aCarNodes[17];
      if ( v45 )
      {
        CMatrix::Attach(&v139, &v45->modelling, 0);
        CMatrix::UpdateRW(&v139);
        v46 = this->m_fPitchControl * 0.43633;
        v137.x = -v137.x;
        CQuaternion::Set(&v140, &v137, v46);
        CQuaternion::Get(&v140, v139.m_pRwMat);
      }
    }
  }
  v47 = this->m_aCarNodes[12];
  if ( v47 )
  {
    CVehicle::SetComponentRotation(this, v47, 1, *p_m_fPropellerAngle + *p_m_fPropellerAngle, 1);
    data = 0;
    RwFrameForAllObjects(this->m_aCarNodes[12], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, 255);
  }
  v48 = this->m_aCarNodes[13];
  if ( v48 )
  {
    CVehicle::SetComponentRotation(this, v48, 1, COERCE_FLOAT(*(_DWORD *)p_m_fPropellerAngle ^ 0x80000000), 1);
    data = 0;
    RwFrameForAllObjects(this->m_aCarNodes[13], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, 0);
  }
  v49 = this->m_aCarNodes[14];
  if ( v49 )
  {
    CVehicle::SetComponentRotation(this, v49, 1, *p_m_fPropellerAngle * -2.0, 1);
    data = 0;
    RwFrameForAllObjects(this->m_aCarNodes[14], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, 255);
  }
  v50 = this->m_aCarNodes[15];
  if ( v50 )
  {
    CVehicle::SetComponentRotation(this, v50, 1, *p_m_fPropellerAngle, 1);
    data = 0;
    RwFrameForAllObjects(this->m_aCarNodes[15], GetCurrentAtomicObjectCB, &data);
    if ( data )
      CVehicle::SetComponentAtomicAlpha(data, 0);
  }
  m_nModelIndex = this->m_nModelIndex;
  v52 = -1.4835;
  v53 = 1.4835;
  v54 = 0.0;
  if ( m_nModelIndex > 552 )
  {
    if ( m_nModelIndex == 553 )
    {
      v53 = 1.309;
      v55 = 0.0;
      v57 = 0;
      v56 = -1;
      v52 = 1.309;
      goto LABEL_93;
    }
    if ( m_nModelIndex != 577 )
    {
      if ( m_nModelIndex != 592 )
        goto LABEL_96;
      v53 = 2.2689;
      v55 = -2.2689;
      goto LABEL_89;
    }
LABEL_90:
    v57 = 1;
    v55 = 2.2689;
    v56 = 0;
    goto LABEL_93;
  }
  if ( m_nModelIndex == 476 )
  {
    v57 = 1;
    v56 = -1;
    v55 = 0.0;
    goto LABEL_93;
  }
  if ( m_nModelIndex == 519 )
    goto LABEL_90;
  if ( m_nModelIndex != 520 )
    goto LABEL_96;
  v53 = -1.5708;
  v55 = -1.3963;
  v54 = 2.2689;
LABEL_89:
  v56 = 0;
  v52 = v53;
  v57 = 0;
LABEL_93:
  p_m_fLGearAngle = &this->m_fLGearAngle;
  CVehicle::SetComponentRotation(this, this->m_aCarNodes[21], v57, v52 * fabsf(this->m_fLGearAngle), 1);
  CVehicle::SetComponentRotation(this, this->m_aCarNodes[22], v57, v53 * fabsf(this->m_fLGearAngle), 1);
  if ( v56 >= 0 )
  {
    CVehicle::SetComponentRotation(this, this->m_aCarNodes[23], v56, v55 * fabsf(*p_m_fLGearAngle), 1);
    if ( v54 > 0.0 )
      CVehicle::SetComponentRotation(this, this->m_aCarNodes[24], v56, v54 * fabsf(*p_m_fLGearAngle), 1);
  }
LABEL_96:
  v59 = this->m_nModelIndex;
  switch ( v59 )
  {
    case 520:
      v60 = (float)((float)this->m_nSuspensionHydraulics * 1.5708) / (float)CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
      CVehicle::SetComponentRotation(this, this->m_aCarNodes[6], 0, v60, 1);
      CVehicle::SetComponentRotation(this, this->m_aCarNodes[3], 0, v60, 1);
      if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x10) != 0 )
      {
        v87 = (float)(this->m_fThrottleControl + 1.0) * 0.5;
        if ( this->m_nSuspensionHydraulics >= CPlane::HARRIER_NOZZLE_SWITCH_LIMIT )
        {
          CAutomobile::DoHeliDustEffect(this, (float)(this->m_fThrottleControl + 1.0) * 0.5, 2.0);
        }
        else
        {
          m_fxSysHeliDust = this->m_fxSysHeliDust;
          if ( m_fxSysHeliDust )
          {
            FxSystem_c::Kill(m_fxSysHeliDust);
            this->m_heliDustRatio = 0.0;
            this->m_fxSysHeliDust = 0;
          }
        }
        m_pRwObject = this->m_pRwObject;
        v90 = this->m_aCarNodes[3];
        v91 = this->m_aCarNodes[6];
        if ( m_pRwObject )
        {
          if ( this->m_fxSysNozzle[0] )
            goto LABEL_189;
          parent = (char *)m_pRwObject->parent;
          memset(&v, 0, 12);
          FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, "jetthrust", (RwV3d_0 *)&v, (RwMatrix *)(parent + 16), 0);
          this->m_fxSysNozzle[0] = FxSystem;
          if ( FxSystem )
          {
            FxSystem_c::Play(FxSystem);
            FxSystem_c::SetLocalParticles(this->m_fxSysNozzle[0], 1u);
            FxSystem_c::CopyParentMatrix(this->m_fxSysNozzle[0]);
          }
          m_pRwObject = this->m_pRwObject;
          if ( m_pRwObject )
          {
LABEL_189:
            if ( this->m_fxSysNozzle[1] )
              goto LABEL_190;
            v94 = (char *)m_pRwObject->parent;
            memset(&v, 0, 12);
            v95 = FxManager_c::CreateFxSystem(&g_fxMan, "jetthrust", (RwV3d_0 *)&v, (RwMatrix *)(v94 + 16), 0);
            this->m_fxSysNozzle[1] = v95;
            if ( v95 )
            {
              FxSystem_c::Play(v95);
              FxSystem_c::SetLocalParticles(this->m_fxSysNozzle[1], 1u);
              FxSystem_c::CopyParentMatrix(this->m_fxSysNozzle[1]);
            }
            m_pRwObject = this->m_pRwObject;
            if ( m_pRwObject )
            {
LABEL_190:
              if ( this->m_fxSysNozzle[2] )
                goto LABEL_191;
              v96 = (char *)m_pRwObject->parent;
              memset(&v, 0, 12);
              v97 = FxManager_c::CreateFxSystem(&g_fxMan, "jetthrust", (RwV3d_0 *)&v, (RwMatrix *)(v96 + 16), 0);
              this->m_fxSysNozzle[2] = v97;
              if ( v97 )
              {
                FxSystem_c::Play(v97);
                FxSystem_c::SetLocalParticles(this->m_fxSysNozzle[2], 1u);
                FxSystem_c::CopyParentMatrix(this->m_fxSysNozzle[2]);
              }
              m_pRwObject = this->m_pRwObject;
              if ( m_pRwObject )
              {
LABEL_191:
                if ( !this->m_fxSysNozzle[3] )
                {
                  v98 = (char *)m_pRwObject->parent;
                  memset(&v, 0, 12);
                  v99 = FxManager_c::CreateFxSystem(&g_fxMan, "jetthrust", (RwV3d_0 *)&v, (RwMatrix *)(v98 + 16), 0);
                  this->m_fxSysNozzle[3] = v99;
                  if ( v99 )
                  {
                    FxSystem_c::Play(v99);
                    FxSystem_c::SetLocalParticles(this->m_fxSysNozzle[3], 1u);
                    FxSystem_c::CopyParentMatrix(this->m_fxSysNozzle[3]);
                  }
                }
              }
            }
          }
        }
        p_modelling = (const CMatrix *)&v91->modelling;
        if ( this->m_fxSysNozzle[0] )
        {
          pos.y = -0.45;
          pos.x = 0.7;
          pos.z = 0.05;
          operator*(&v, this->m_pMat, p_modelling);
          FxSystem_c::SetMatrix(this->m_fxSysNozzle[0], (RwMatrix *)&v);
          FxSystem_c::SetOffsetPos(this->m_fxSysNozzle[0], &pos);
          FxSystem_c::SetConstTime(this->m_fxSysNozzle[0], 1u, v87);
          CMatrix::~CMatrix(&v);
        }
        v101 = (const CMatrix *)&v90->modelling;
        if ( this->m_fxSysNozzle[1] )
        {
          pos.y = -0.45;
          pos.x = -0.82;
          pos.z = 0.05;
          operator*(&v, this->m_pMat, p_modelling);
          FxSystem_c::SetMatrix(this->m_fxSysNozzle[1], (RwMatrix *)&v);
          FxSystem_c::SetOffsetPos(this->m_fxSysNozzle[1], &pos);
          FxSystem_c::SetConstTime(this->m_fxSysNozzle[1], 1u, v87);
          CMatrix::~CMatrix(&v);
        }
        if ( this->m_fxSysNozzle[2] )
        {
          pos.y = -0.45;
          pos.x = 0.63;
          pos.z = 0.07;
          operator*(&v, this->m_pMat, v101);
          FxSystem_c::SetMatrix(this->m_fxSysNozzle[2], (RwMatrix *)&v);
          FxSystem_c::SetOffsetPos(this->m_fxSysNozzle[2], &pos);
          FxSystem_c::SetConstTime(this->m_fxSysNozzle[2], 1u, v87);
          CMatrix::~CMatrix(&v);
        }
        if ( this->m_fxSysNozzle[3] )
        {
          pos.y = -0.45;
          pos.x = -0.75;
          pos.z = 0.07;
          operator*(&v, this->m_pMat, v101);
          FxSystem_c::SetMatrix(this->m_fxSysNozzle[3], (RwMatrix *)&v);
          FxSystem_c::SetOffsetPos(this->m_fxSysNozzle[3], &pos);
          FxSystem_c::SetConstTime(this->m_fxSysNozzle[3], 1u, v87);
          CMatrix::~CMatrix(&v);
        }
      }
      else
      {
        v61 = this->m_fxSysNozzle[0];
        if ( v61 )
        {
          FxSystem_c::Kill(v61);
          this->m_fxSysNozzle[0] = 0;
        }
        v62 = this->m_fxSysNozzle[1];
        if ( v62 )
        {
          FxSystem_c::Kill(v62);
          this->m_fxSysNozzle[1] = 0;
        }
        v63 = this->m_fxSysNozzle[2];
        if ( v63 )
        {
          FxSystem_c::Kill(v63);
          this->m_fxSysNozzle[2] = 0;
        }
        v64 = this->m_fxSysNozzle[3];
        if ( v64 )
        {
          FxSystem_c::Kill(v64);
          this->m_fxSysNozzle[3] = 0;
        }
        v65 = this->m_fxSysHeliDust;
        if ( v65 )
        {
          FxSystem_c::Kill(v65);
          this->m_heliDustRatio = 0.0;
          this->m_fxSysHeliDust = 0;
        }
      }
      break;
    case 539:
      if ( this->m_aCarNodes[23] )
      {
        m_pColData = CEntity::GetColModel(this)->m_pColData;
        CVehicleModelInfo::GetWheelPosn(v7, 0, (CVector *)&v, 0);
        CMatrix::Attach(&v139, &this->m_aCarNodes[23]->modelling, 0);
        m_pMat = this->m_pMat;
        x = this->m_vecMoveSpeed.x;
        y = this->m_vecMoveSpeed.y;
        v70 = this->m_vecMoveSpeed.z;
        v71 = (float)((float)(x * m_pMat->xy) + (float)(y * m_pMat->yy)) + (float)(v70 * m_pMat->zy);
        v72 = v71 + v71;
        v73 = -1097229926;
        if ( v72 > 0.3 || (v74 = -1097229926, v72 >= -0.3) )
        {
          v74 = 1050253722;
          if ( v72 <= 0.3 )
            v74 = LODWORD(v72);
        }
        LODWORD(v139.yz) = v74;
        v75 = (float)((float)((float)(x * m_pMat->xx) + (float)(y * m_pMat->yx)) + (float)(v70 * m_pMat->zx))
            + (float)((float)((float)(x * m_pMat->xx) + (float)(y * m_pMat->yx)) + (float)(v70 * m_pMat->zx));
        v76 = v75 < 0.3;
        if ( v75 <= 0.3 )
          v76 = v75 < -0.3;
        if ( !v76 )
        {
          v73 = 1050253722;
          if ( v75 <= 0.3 )
            v73 = LODWORD(v75);
        }
        LODWORD(v139.xz) = v73;
        v77 = this->m_aWheelSuspensionHeights[1];
        v78 = this->m_aWheelSuspensionHeights[2];
        v79 = this->m_aWheelSuspensionHeights[3];
        v80 = this->m_aWheelSuspensionHeights[0];
        v81 = (float)((float)((float)(v80 - v77) + (float)(v78 - v79)) * 0.5)
            / (float)(m_pColData->_anon_1.m_pLineArray->m_vecStart.y - m_pColData->_anon_1.m_pLineArray[1].m_vecStart.y);
        v82 = powf(0.9, CTimer::ms_fTimeStep);
        v83 = 0.1;
        v84 = 0.1;
        if ( v81 <= 0.1 )
        {
          v84 = v81;
          if ( v81 < -0.1 )
            v84 = -0.1;
        }
        v85 = 1.0 - v82;
        v139.zy = (float)((float)(1.0 - v82) * v84) + (float)(v82 * v139.zy);
        v86 = (float)((float)((float)(v78 - v80) + (float)(v79 - v77)) * 0.5)
            / (float)(m_pColData->_anon_1.m_pLineArray[3].m_vecStart.x - m_pColData->_anon_1.m_pLineArray[1].m_vecStart.x);
        if ( v86 <= 0.1 )
        {
          v83 = (float)((float)((float)(v78 - v80) + (float)(v79 - v77)) * 0.5)
              / (float)(m_pColData->_anon_1.m_pLineArray[3].m_vecStart.x
                      - m_pColData->_anon_1.m_pLineArray[1].m_vecStart.x);
          if ( v86 < -0.1 )
            v83 = -0.1;
        }
        v139.zx = (float)(v85 * v83) + (float)(v82 * v139.zx);
        v2.n64_f32[0] = (float)((float)((float)((float)((float)((float)(v80 + v78) + v77) + v79) * 0.25) - v.zx)
                              / (float)(v7->m_wheelScale * -0.5))
                      + 1.0;
        v3.n64_u32[0] = 1067869798;
        v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
        v139.zz = (float)(v82 * v139.zz) + (float)(v85 * v2.n64_f32[0]);
        CMatrix::UpdateRW(&v139);
      }
      break;
    case 592:
      CVehicle::SetComponentRotation(
        this,
        this->m_aCarNodes[24],
        0,
        CPlane::ANDROM_COL_ANGLE_MULT * (float)this->m_nSuspensionHydraulics,
        1);
      break;
  }
  m_nComponentIndex = this->BouncingPanels[0].m_nComponentIndex;
  if ( m_nComponentIndex >= 0 )
    CBouncingPanel::ProcessPanel(
      this->BouncingPanels,
      this,
      this->m_aCarNodes[m_nComponentIndex],
      this->m_vecOldMoveSpeed,
      this->m_vecOldTurnSpeed,
      0.03,
      0.98);
  v103 = this->BouncingPanels[1].m_nComponentIndex;
  if ( v103 > -1 )
    CBouncingPanel::ProcessPanel(
      &this->BouncingPanels[1],
      this,
      this->m_aCarNodes[v103],
      this->m_vecOldMoveSpeed,
      this->m_vecOldTurnSpeed,
      0.03,
      0.98);
  v104 = this->BouncingPanels[2].m_nComponentIndex;
  if ( v104 > -1 )
    CBouncingPanel::ProcessPanel(
      &this->BouncingPanels[2],
      this,
      this->m_aCarNodes[v104],
      this->m_vecOldMoveSpeed,
      this->m_vecOldTurnSpeed,
      0.03,
      0.98);
  v105 = this->m_vecTurnSpeed.y + this->m_vecTurnFriction.y;
  v106 = this->m_vecTurnSpeed.z + this->m_vecTurnFriction.z;
  *(float32x4_t *)&this->m_vecOldMoveSpeed.x = vaddq_f32(
                                                 *(float32x4_t *)&this->m_vecMoveSpeed.x,
                                                 *(float32x4_t *)&this->m_vecMoveFriction.x);
  this->m_vecOldTurnSpeed.y = v105;
  this->m_vecOldTurnSpeed.z = v106;
  v107 = this->m_nModelIndex;
  if ( v107 == 539 )
  {
    CShadows::StoreShadowForVehicle(this, VEHICLE_SHADOW_CAR);
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    v108 = v7;
  }
  else
  {
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    v108 = v7;
    v110 = v107 == 577;
    if ( v107 != 577 )
      v110 = v107 == 592;
    if ( v110 )
      v111 = VEHICLE_SHADOW_HUGEPLANE;
    else
      v111 = VEHICLE_SHADOW_PLANE;
    CShadows::StoreShadowForVehicle(this, v111);
  }
  if ( (*((_BYTE *)p_m_nVehicleFlags + 3) & 0x40) == 0 )
  {
    v112 = this->m_nModelIndex;
    v113 = v112 == 464;
    if ( v112 != 464 )
      v113 = v112 == 539;
    if ( !v113 )
    {
      v114 = this->m_pMat;
      v115 = this->m_vecMoveSpeed.x;
      fAttackLiftMult = this->pFlyingHandling->fAttackLiftMult;
      v117 = (RwV3d_0 *)v108->m_pStructure;
      v118 = this->m_vecMoveSpeed.y;
      v119 = this->m_vecMoveSpeed.z;
      v120 = *(_QWORD *)&v117[12].x;
      xz = v114->xz;
      yz = v114->yz;
      zz = v114->zz;
      v.zx = v117[12].z;
      *(_QWORD *)&v.xx = v120;
      pos = v117[12];
      pos.x = pos.x + -0.1;
      operator*(&v133, v114, (const CVector *)&v);
      operator*(&SecondPoint, this->m_pMat, (const CVector *)&pos);
      v2.n64_u32[0] = 0;
      v1.n64_f32[0] = fabsf(
                        (float)((float)((float)(v115 * xz) + (float)(v118 * yz)) + (float)(v119 * zz))
                      * (float)(fAttackLiftMult * 6400.0))
                    + -32.0;
      v124 = (unsigned int)vmax_f32(v1, v2).n64_f32[0];
      CMotionBlurStreaks::RegisterStreak(
        (u_native)this,
        0xFFu,
        0xFFu,
        0xFFu,
        v124,
        (_DWORD *)LODWORD(v133.x),
        v133.y,
        v133.z,
        SecondPoint.x,
        SecondPoint.y);
      v.xx = -v.xx;
      pos.x = -pos.x;
      operator*(&v131, this->m_pMat, (const CVector *)&v);
      v133 = v131;
      operator*(&v131, this->m_pMat, (const CVector *)&pos);
      SecondPoint = v131;
      CMotionBlurStreaks::RegisterStreak(
        (u_native)&this->_vptr$CPlaceable + 1,
        0xFFu,
        0xFFu,
        0xFFu,
        v124,
        (_DWORD *)LODWORD(v133.x),
        v133.y,
        v133.z,
        v131.x,
        v131.y);
    }
  }
  if ( this->m_fxActive )
  {
    v125 = this->m_nModelIndex;
    if ( v125 == 513 )
    {
      FxPrtMult_c::FxPrtMult_c((FxPrtMult_c *)&v, 1.0, 0.0, 0.0, 0.4, 1.0, 1.0, 0.3);
      pos.x = 0.0;
      pos.y = -5.0;
      pos.z = 0.0;
      operator*(&v133, this->m_pMat, (const CVector *)&pos);
      m_fxSysSmokeHuge = g_fx.m_fxSysSmokeHuge;
      v129 = this->m_vecMoveSpeed.x * 10.0;
      v130 = this->m_vecMoveSpeed.z * 10.0;
      SecondPoint.y = this->m_vecMoveSpeed.y * 10.0;
      SecondPoint.x = v129;
      SecondPoint.z = v130;
    }
    else
    {
      if ( v125 != 512 )
      {
        if ( (unsigned __int16)v125 != 460 )
          goto LABEL_186;
        goto LABEL_184;
      }
      FxPrtMult_c::FxPrtMult_c((FxPrtMult_c *)&v, 1.0, 1.0, 1.0, 0.4, 1.0, 1.0, 0.2);
      pos.y = -0.5;
      pos.x = 0.0;
      pos.z = -0.5;
      operator*(&v133, this->m_pMat, (const CVector *)&pos);
      v126 = this->m_vecMoveSpeed.x * 10.0;
      m_fxSysSmokeHuge = g_fx.m_fxSysSmokeHuge;
      v128 = (float)(this->m_vecMoveSpeed.z * 10.0) + -3.0;
      SecondPoint.y = this->m_vecMoveSpeed.y * 10.0;
      SecondPoint.x = v126;
      SecondPoint.z = v128;
    }
    FxSystem_c::AddParticle(m_fxSysSmokeHuge, &v133, &SecondPoint, 0.0, (FxPrtMult_c *)&v, -1.0, 1.2, 0.6, 0);
  }
  if ( this->m_nModelIndex != 460 )
    goto LABEL_186;
LABEL_184:
  if ( *((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31 )
    CVehicle::DoBoatSplashes(this, this->GunElevation);
LABEL_186:
  CMatrix::~CMatrix(&v139);
}
// 5775D2: variable 'v1' is possibly undefined
// 5775D2: variable 'v5' is possibly undefined
// 5775D6: variable 'v4' is possibly undefined
// 578062: variable 'v2' is possibly undefined
// 578062: variable 'v3' is possibly undefined
// 679728: using guessed type float *CPlane::ANDROM_COL_ANGLE_MULT;

//----- (00578820) --------------------------------------------------------
void __fastcall CPlane::Render(CPlane *this)
{
  this->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds + 3000;
  sub_18CAF8(this);
}

//----- (00578838) --------------------------------------------------------
void __fastcall CPlane::IsAlreadyFlying(CPlane *this)
{
  this->m_OnGroundTimer = CTimer::m_snTimeInMilliseconds - 20000;
}

//----- (00578850) --------------------------------------------------------
void __fastcall CPlane::Fix(CPlane *this)
{
  CDamageManager *p_Damage; // r5

  p_Damage = &this->Damage;
  CDamageManager::ResetDamageStatus(&this->Damage);
  if ( BYTE1(this->pHandling->mFlags) << 31 )
  {
    CDamageManager::SetDoorStatus(p_Damage, FRONT_LEFT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(p_Damage, FRONT_RIGHT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(p_Damage, REAR_LEFT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(p_Damage, REAR_RIGHT_DOOR_0, 4u);
  }
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x10000u;
}

//----- (005788A2) --------------------------------------------------------
void __fastcall CPlane::SetupDamageAfterLoad(CPlane *this)
{
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x10000u;
}

//----- (005788B0) --------------------------------------------------------
void __fastcall CPlane::VehicleDamage(
        CPlane *this,
        float fImpulse,
        CVector *nPieceType,
        CEntity *pDamageEntity,
        __int64 pVecDamagePos,
        eWeaponType weaponType)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d9
  CVector *p_m_vecDamagePos; // r9
  float v12; // s22
  float v13; // s20
  CPlayerPed *m_pDamageEntity; // r5
  CVehicle *v15; // r5
  float m_fDamageImpulseMagnitude; // s16
  int v17; // r8
  float *p_m_nHealth; // r6
  float m_nHealth; // s24
  float v20; // s26
  CPlane *PlayerVehicle; // r0
  int v22; // r1
  float v23; // s0
  CEntity *v24; // r0
  float v25; // s0
  CVehicle *v26; // r5
  int v27; // r1
  int v28; // r0
  float v29; // s0
  float v30; // s4
  float v31; // s20
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r0
  float z; // s4
  float v35; // s10
  RwReal v36; // s0
  int v37; // r8
  int v38; // r2
  float x; // s0
  RwFrame_0 *v40; // r3
  float32x2_t v41; // d17
  unsigned __int64 v42; // d2
  float v43; // s2
  uint32 AeroplaneCompStatus; // r0
  int m_nComponentIndex; // r0
  CBouncingPanel *BouncingPanels; // r0
  RwFrame_0 *v47; // r0
  __int64 v48; // d16
  FxSystem_c *m_fxSysFire; // r0
  RwObject_0 *m_pRwObject; // r0
  FxSystem_c *v51; // r0
  RwReal v52; // s2
  RwReal v53; // s0
  int v54; // r1
  int v55; // r1
  RwV3d_0 vel; // [sp+4h] [bp-74h] BYREF
  CVector pos; // [sp+10h] [bp-68h] BYREF
  CVector pBeingShotAt[7]; // [sp+20h] [bp-58h] BYREF

  if ( this->m_nModelIndex == 539 )
  {
    sub_18D528(this, fImpulse, nPieceType, pDamageEntity, pVecDamagePos, weaponType);
    return;
  }
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) == 0 )
    return;
  p_m_vecDamagePos = (CVector *)pVecDamagePos;
  v12 = PLANE_DAMAGE_DESTROY_THRESHHOLD;
  v13 = PLANE_DAMAGE_THRESHHOLD;
  if ( *(_BYTE *)&this->m_info >= 8u && (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x40) != 0 )
  {
    m_pDamageEntity = (CPlayerPed *)this->m_pDamageEntity;
    if ( m_pDamageEntity != FindPlayerPed(-1) )
    {
      v15 = (CVehicle *)this->m_pDamageEntity;
      if ( v15 != FindPlayerVehicle(-1, 0) )
        return;
    }
  }
  if ( fImpulse == 0.0 )
  {
    m_fDamageImpulseMagnitude = this->m_fDamageImpulseMagnitude;
    if ( m_fDamageImpulseMagnitude <= 0.0 )
      return;
    if ( (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x10) != 0 )
      return;
    v7.n64_u32[0] = 1.0;
    p_m_vecDamagePos = &this->m_vecDamagePos;
    v24 = this->m_pDamageEntity;
    v6.n64_f32[0] = this->m_fMass / PLANE_DAMAGE_SCALE_MASS;
    v12 = v12 * v6.n64_f32[0];
    v13 = v13 * vmax_f32(v6, v7).n64_f32[0];
    if ( v24 )
    {
      if ( (*(_BYTE *)&v24->m_info & 7) == 3 )
        return;
    }
    v17 = 0;
  }
  else
  {
    LOBYTE(pBeingShotAt[0].x) = 0;
    if ( !CVehicle::CanVehicleBeDamaged(this, pDamageEntity, weaponType, (Bool8 *)pBeingShotAt)
      || (unsigned int)(weaponType - 19) >= 3 && weaponType != WEAPONTYPE_EXPLOSION )
    {
      return;
    }
    m_fDamageImpulseMagnitude = 0.0;
    v17 = 1;
    v7.n64_u32[0] = 1051361018;
  }
  p_m_nHealth = &this->m_nHealth;
  m_nHealth = this->m_nHealth;
  v20 = m_fDamageImpulseMagnitude * this->pHandling->fCollisionDamageMultiplier;
  PlayerVehicle = (CPlane *)FindPlayerVehicle(-1, 0);
  v22 = *(_DWORD *)&this->m_nVehicleFlags & 0x8000;
  if ( this == PlayerVehicle )
  {
    v23 = 2.0;
    if ( v22 )
      v23 = 6.0;
    goto LABEL_24;
  }
  if ( v22 )
  {
    v23 = 12.0;
LABEL_24:
    v25 = v20 / v23;
    goto LABEL_28;
  }
  v26 = (CVehicle *)this->m_pDamageEntity;
  if ( v26 && v26 == FindPlayerVehicle(-1, 0) )
  {
    v23 = 1.5;
    goto LABEL_24;
  }
  v25 = v20 * 0.25;
LABEL_28:
  v27 = 0;
  v28 = 0;
  v29 = *p_m_nHealth - v25;
  v30 = v29;
  if ( v29 <= 0.0 )
    v30 = 1.0;
  if ( m_nHealth > 0.0 )
    v29 = v30;
  *p_m_nHealth = v29;
  if ( v29 <= 1.0 )
    v27 = 1;
  if ( m_nHealth > 0.0 )
    v28 = 1;
  if ( m_fDamageImpulseMagnitude > v12 || (v28 & v27) == 1 )
  {
    (*((void (__fastcall **)(CPlane *, CPlane *, _DWORD))this->_vptr$CPlaceable + 42))(this, this, 0);
    return;
  }
  if ( (m_fDamageImpulseMagnitude > v13) | v17 )
  {
    if ( (*(_BYTE *)&this->m_info & 0xF8) != 40 )
    {
      v31 = 1000.0;
      if ( this->m_fMass > 1000.0 )
      {
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        z = p_m_vecDamagePos->z;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        v35 = p_tx->m_translate.z;
        v36 = p_m_vecDamagePos->x - p_tx->m_translate.x;
        pBeingShotAt[0].y = p_m_vecDamagePos->y - p_tx->m_translate.y;
        pBeingShotAt[0].x = v36;
        pBeingShotAt[0].z = z - v35;
        Multiply3x3(&pos, pBeingShotAt, m_pMat);
        v37 = -1;
        pBeingShotAt[0] = pos;
        v38 = 0;
        x = pos.x;
        do
        {
          v40 = this->m_aCarNodes[v38 + 12];
          if ( v40 )
          {
            pos = (CVector)v40->modelling.pos;
            v41.n64_u64[0] = vsub_f32(*(float32x2_t *)&pos.y, *(float32x2_t *)&pBeingShotAt[0].y).n64_u64[0];
            v42 = vmul_f32(v41, v41).n64_u64[0];
            v43 = (float)((float)((float)(pos.x - x) * (float)(pos.x - x)) + *(float *)&v42) + *((float *)&v42 + 1);
            if ( v43 < (float)(v31 * v31) )
            {
              v31 = sqrtf(v43);
              v37 = v38 + 12;
            }
          }
          ++v38;
        }
        while ( v38 != 13 );
        if ( v37 > -1 )
        {
          if ( v37 == 16 )
          {
            if ( (rand() & 1) != 0 )
            {
              if ( this->m_aCarNodes[17] && (rand() & 1) != 0 )
              {
                v37 = 17;
              }
              else
              {
                v37 = 18;
                if ( !this->m_aCarNodes[18] )
                  v37 = 16;
              }
            }
            else
            {
              v37 = 16;
            }
          }
          if ( !CDamageManager::ProgressAeroplaneDamage(&this->Damage, v37) )
            goto LABEL_69;
          AeroplaneCompStatus = CDamageManager::GetAeroplaneCompStatus(&this->Damage, v37);
          if ( (unsigned int)(v37 - 16) > 6 || AeroplaneCompStatus != 1 )
          {
            if ( CDamageManager::GetAeroplaneCompStatus(&this->Damage, v37) == 2 )
              CVehicle::SetComponentVisibility(this, this->m_aCarNodes[v37], 2u);
            goto LABEL_69;
          }
          m_nComponentIndex = this->BouncingPanels[0].m_nComponentIndex;
          if ( m_nComponentIndex == -1 )
          {
            BouncingPanels = this->BouncingPanels;
          }
          else
          {
            if ( v37 == m_nComponentIndex )
              goto LABEL_69;
            v54 = (unsigned __int16)this->BouncingPanels[1].m_nComponentIndex;
            if ( v54 == 0xFFFF )
            {
              BouncingPanels = &this->BouncingPanels[1];
            }
            else
            {
              if ( v37 == (__int16)v54 )
                goto LABEL_69;
              v55 = (unsigned __int16)this->BouncingPanels[2].m_nComponentIndex;
              if ( v55 == 0xFFFF )
              {
                BouncingPanels = &this->BouncingPanels[2];
              }
              else
              {
                if ( v37 == (__int16)v55 || LOWORD(this->ChassisDoor.m_fOpenAngle) != 0xFFFF )
                  goto LABEL_69;
                BouncingPanels = (CBouncingPanel *)&this->ChassisDoor;
              }
            }
          }
          CBouncingPanel::SetPanel(BouncingPanels, v37, 0, -0.02);
LABEL_69:
          CAutomobile::dmgDrawCarCollidingParticles(
            this,
            p_m_vecDamagePos,
            v7.n64_f32[0] * m_fDamageImpulseMagnitude,
            weaponType);
          v47 = this->m_aCarNodes[v37];
          v48 = *(_QWORD *)&v47->modelling.pos.x;
          pos.z = v47->modelling.pos.z;
          *(_QWORD *)&pos.x = v48;
          m_fxSysFire = this->m_fxSysFire;
          if ( m_fxSysFire )
          {
            FxSystem_c::Kill(m_fxSysFire);
            this->m_fxSysFire = 0;
          }
          m_pRwObject = this->m_pRwObject;
          if ( m_pRwObject )
          {
            v51 = FxManager_c::CreateFxSystem(
                    &g_fxMan,
                    "fire_med",
                    &pos,
                    (RwMatrix *)((char *)m_pRwObject->parent + 16),
                    0);
            this->m_fxSysFire = v51;
            if ( v51 )
            {
              FxSystem_c::Play(v51);
              v52 = this->m_vecMoveSpeed.x * -5.0;
              v53 = this->m_vecMoveSpeed.z * -5.0;
              vel.y = this->m_vecMoveSpeed.y * -5.0;
              vel.x = v52;
              vel.z = v53;
              FxSystem_c::SetVelAdd(this->m_fxSysFire, &vel);
              FxSystem_c::SetLocalParticles(this->m_fxSysFire, 1u);
              this->m_fireTime = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 2000.0) + 2000;
            }
          }
        }
      }
    }
  }
}
// 5789F0: variable 'v6' is possibly undefined
// 5789F0: variable 'v7' is possibly undefined

//----- (00578D98) --------------------------------------------------------
void __fastcall CPlane::OpenDoor(
        CPlane *this,
        CPed *pPed,
        int32 index,
        eDoors DoorID,
        float timeRatio,
        int bPlaySoundSample)
{
  CAutomobile::OpenDoor(this, pPed, index, DoorID, timeRatio, bPlaySoundSample);
}
// 578D98: using guessed type int bPlaySoundSample;

//----- (00578DB8) --------------------------------------------------------
void __fastcall CPlane::FindPlaneCreationCoors(
        CVector *pCoors,
        CVector *pTargetCoors,
        float *pPlaneOrientation,
        float *pFlightHeight,
        int bBigPlane)
{
  float v6; // s16
  float v8; // s18
  int v9; // r11
  int v10; // r10
  __int64 v11; // d16
  float v12; // s26
  float v13; // s24
  float v14; // r0
  float y; // s6
  float z; // s8
  __int64 v17; // d16
  int v18; // r0
  RwReal v19; // s2
  RwReal v20; // s4
  RwReal v21; // s0
  RwReal v22; // s0
  RwReal v23; // s4
  uint16 v24; // r0
  int v27; // [sp+28h] [bp-90h]
  CColSphere pA; // [sp+2Ch] [bp-8Ch] BYREF
  CColBox v29; // [sp+40h] [bp-78h] BYREF
  CVector vecEnd; // [sp+5Ch] [bp-5Ch] BYREF

  v6 = 25.0;
  v8 = 140.0;
  if ( bBigPlane )
  {
    v8 = 340.0;
    v6 = 200.0;
  }
  v9 = 0;
  v27 = 0;
  do
  {
    v10 = rand();
    FindPlayerCoors(&v29.m_vecMin, -1);
    v11 = *(_QWORD *)&v29.m_vecMin.x;
    pCoors->z = v29.m_vecMin.z;
    *(_QWORD *)&pCoors->x = v11;
    v12 = cosf((float)((float)(v10 % 360) * 3.1416) / 180.0);
    v13 = (float)(v6 + (float)(rand() & 0xF)) + (float)v9;
    v14 = sinf((float)((float)(v10 % 360) * 3.1416) / 180.0);
    *pFlightHeight = v13;
    y = pCoors->y;
    z = pCoors->z;
    pCoors->x = pCoors->x + (float)(v8 * v12);
    pCoors->y = y + (float)(v8 * v14);
    pCoors->z = *pFlightHeight + z;
    FindPlayerCoors(&v29.m_vecMin, -1);
    v17 = *(_QWORD *)&v29.m_vecMin.x;
    pTargetCoors->z = v29.m_vecMin.z;
    *(_QWORD *)&pTargetCoors->x = v17;
    v18 = (rand() & 0x1F) + 20;
    v19 = (float)(TheCamera.m_cameraMatrix.xy * (float)v18) + pTargetCoors->x;
    v20 = (float)(TheCamera.m_cameraMatrix.yy * (float)v18) + pTargetCoors->y;
    v21 = (float)(TheCamera.m_cameraMatrix.zy * (float)v18) + pTargetCoors->z;
    pTargetCoors->x = v19;
    pTargetCoors->y = v20;
    pTargetCoors->z = v21;
    pTargetCoors->z = v21 + *pFlightHeight;
    *pPlaneOrientation = CGeneral::GetATanOfXY(v19 - pCoors->x, v20 - pCoors->y);
    v22 = pTargetCoors->x + (float)(pTargetCoors->x - pCoors->x);
    v23 = pTargetCoors->z + (float)(pTargetCoors->z - pCoors->z);
    vecEnd.y = pTargetCoors->y + (float)(pTargetCoors->y - pCoors->y);
    vecEnd.x = v22;
    vecEnd.z = v23;
    if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
    {
      CWorld::ClearScanCodes();
      v24 = 1;
    }
    else
    {
      v24 = CWorld::ms_nCurrentScanCode + 1;
    }
    CWorld::ms_nCurrentScanCode = v24;
    CColSphere::Set(&pA, 15.0, pCoors, 0, 0, (uint8)elf_hash_bucket + 3);
    if ( CWorld::GetIsLineOfSightClear(pCoors, &vecEnd, 1, 0, 0, 0, 0, 0, 0)
      && CCollision::CheckCameraCollisionBuildings((int)pCoors->x, (int)pCoors->y, &v29, &pA, &pA, &pA) != 1 )
    {
      v27 = 1;
    }
    else
    {
      v9 += 10;
      if ( v9 >= 500 )
        break;
    }
  }
  while ( !(v27 << 31) );
  *pFlightHeight = *pFlightHeight + 20.0;
  pTargetCoors->z = pTargetCoors->z + 20.0;
}
// 579034: conditional instruction was optimized away because r11.4<1F4
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0057908C) --------------------------------------------------------
Int32 CPlane::CountPlanesAndHelis()
{
  int32 m_nSize; // r2
  Int32 result; // r0
  int v2; // r1
  int i; // r1

  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  result = 0;
  do
  {
    v2 = 2604 * m_nSize--;
    for ( i = v2 - 2604;
          (CPools::ms_pVehiclePool->m_aFlags[m_nSize] & 0x80u) != 0 || !&(*CPools::ms_pVehiclePool->m_aStorage)[i];
          i -= 2604 )
    {
      if ( --m_nSize == -1 )
        return result;
    }
    if ( (unsigned int)(*(_DWORD *)&(*CPools::ms_pVehiclePool->m_aStorage)[i + 1444] - 3) < 2 )
      ++result;
  }
  while ( m_nSize );
  return result;
}

//----- (005790E8) --------------------------------------------------------
bool CPlane::AreWeInNoPlaneZone()
{
  CSimpleTransform *p_tx; // r2
  float x; // s2
  float y; // s0

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  return sqrtf(
           (float)((float)((float)(p_tx->m_translate.x + 1073.0) * (float)(p_tx->m_translate.x + 1073.0))
                 + (float)((float)(y + 675.0) * (float)(y + 675.0)))
         + (float)((float)(p_tx->m_translate.z + -50.0) * (float)(p_tx->m_translate.z + -50.0))) < 200.0
      || x > -2743.0 && x < -2626.0 && y > 1300.0 && y < 2200.0
      || x > -1668.0 && x < -1122.0 && y > 541.0 && y < 1118.0;
}

//----- (005791F0) --------------------------------------------------------
bool CPlane::AreWeInNoBigPlaneZone()
{
  CSimpleTransform *p_tx; // r2
  float y; // s2

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  return sqrtf(
           (float)((float)(p_tx->m_translate.x + -1522.0) * (float)(p_tx->m_translate.x + -1522.0))
         + (float)((float)(y + 1237.0) * (float)(y + 1237.0))) < 800.0
      || sqrtf(
           (float)((float)(p_tx->m_translate.x + 1836.0) * (float)(p_tx->m_translate.x + 1836.0))
         + (float)((float)(y + -659.0) * (float)(y + -659.0))) < 800.0;
}

//----- (00579284) --------------------------------------------------------
void CPlane::DoPlaneGenerationAndRemoval()
{
  int32 m_nSize; // r1
  int v1; // r4
  int v2; // r6
  int v3; // r6
  CSimpleTransform *p_tx; // r2
  float v5; // s2
  float v6; // s0
  int v7; // r1
  int v8; // r0
  Int32 v9; // r4
  char *v10; // r4
  RwReal y; // r1
  int v12; // r3
  RwReal z; // r0
  RwReal *v14; // r1
  int v15; // r0
  int v16; // r1
  char *v17; // r5
  int m_iAccumulatedTime; // r1
  int v19; // r3
  int v20; // r0
  _DWORD *v21; // r1
  int32 v22; // r1
  int v23; // r2
  int v24; // r6
  int v25; // r5
  Int32 v26; // r0
  float v27; // s16
  int v28; // r6
  float v29; // r5
  float v30; // s18
  float v31; // r5
  char v32; // r1
  float v33; // r0
  int v34; // r2
  int v35; // r1
  unsigned int v36; // r0
  int v37; // r0
  int v38; // r0
  float *v39; // r1
  float v40; // r5
  unsigned int v41; // r6
  RwReal v42; // r8
  CVehicle *UnsuspectingTargetCar; // r0
  __int16 v44; // r1
  float x; // r10
  int v46; // r6
  float v47; // r8
  float v48; // s16
  int v49; // r12
  int v50; // lr
  float v51; // r6
  int32 v52; // r0
  bool v53; // zf
  bool v54; // zf
  int v55; // r0
  float *v56; // r1
  float v57; // r5
  unsigned int v58; // r6
  RwReal v59; // r8
  CPed *UnsuspectingTargetPed; // r0
  const CPed *v61; // r5
  __int16 v62; // r1
  CPedGroup *PedsGroup; // r0
  CPedGroup *v64; // r6
  bool v65; // zf
  int CharCreatedBy; // r0
  bool v67; // zf
  int v68; // r1
  int v69; // r4
  float v70; // s0
  float v71; // s2
  unsigned int v72; // r1
  CVehicle *PlayerVehicle; // r0
  CVehicle *v74; // r0
  CSimpleTransform *p_m_transform; // r2
  float v76; // s2
  CVehicle *v77; // r0
  CVehicle *v78; // r0
  char v79; // r0
  Int32 v80; // r1
  CEventDanger v81; // [sp+8h] [bp-80h] BYREF
  CVector v82; // [sp+20h] [bp-68h] BYREF
  CVector v83; // [sp+2Ch] [bp-5Ch] BYREF
  float pFlightHeight; // [sp+38h] [bp-50h] BYREF
  float pPlaneOrientation; // [sp+3Ch] [bp-4Ch] BYREF
  CVector pTargetCoors; // [sp+40h] [bp-48h] BYREF
  CVector pCoors; // [sp+4Ch] [bp-3Ch] BYREF
  CVector v88; // 0:r0.12
  CVector v89; // 0:r0.12

  if ( (CTimer::m_FrameCounter & 0x1F) == 30 && CPlane::GenPlane_Active )
  {
    m_nSize = CPools::ms_pVehiclePool->m_nSize;
    if ( m_nSize )
    {
      v1 = 0;
      do
      {
        v2 = 2604 * m_nSize--;
        v3 = v2 - 2604;
        while ( (CPools::ms_pVehiclePool->m_aFlags[m_nSize] & 0x80u) != 0
             || !&(*CPools::ms_pVehiclePool->m_aStorage)[v3] )
        {
          --m_nSize;
          v3 -= 2604;
          if ( m_nSize == -1 )
            goto LABEL_15;
        }
        if ( (unsigned int)(*(_DWORD *)&(*CPools::ms_pVehiclePool->m_aStorage)[v3 + 1444] - 3) < 2 )
          ++v1;
      }
      while ( m_nSize );
    }
    else
    {
      v1 = 0;
    }
LABEL_15:
    if ( CPlane::GenPlane_Status == 1 )
    {
      v9 = CPlane::GenPlane_ModelIndex;
      if ( CStreaming::ms_aInfoForModel[CPlane::GenPlane_ModelIndex].m_status == 1 )
      {
        if ( CPlane::GenPlane_ModelIndex == 497 )
        {
          CPlane::FindPlaneCreationCoors(&pCoors, &pTargetCoors, &pPlaneOrientation, &pFlightHeight, 0);
          v10 = (char *)CVehicle::operator new(0xA2Cu);
          CHeli::CHeli((CHeli *)v10, CPlane::GenPlane_ModelIndex, 1u);
          y = pCoors.y;
          v12 = *((_DWORD *)v10 + 5);
          z = pCoors.z;
          if ( v12 )
          {
            *(RwReal *)(v12 + 48) = pCoors.x;
            *(RwReal *)(*((_DWORD *)v10 + 5) + 52) = y;
            v14 = (RwReal *)(*((_DWORD *)v10 + 5) + 56);
          }
          else
          {
            *((_DWORD *)v10 + 1) = LODWORD(pCoors.x);
            *((RwReal *)v10 + 2) = y;
            v14 = (RwReal *)(v10 + 12);
          }
          *v14 = z;
          v27 = pPlaneOrientation;
          v28 = *((_DWORD *)v10 + 5);
          v29 = pPlaneOrientation;
          v30 = cosf(pPlaneOrientation);
          *(_DWORD *)(v28 + 8) = 0;
          *(_DWORD *)(v28 + 24) = 0;
          *(_DWORD *)(v28 + 32) = 0;
          *(_DWORD *)(v28 + 36) = 0;
          *(_DWORD *)(v28 + 40) = 1065353216;
          v31 = sinf(v29);
          *(float *)v28 = v31;
          *(float *)(v28 + 16) = v30;
          *(float *)(v28 + 20) = v31;
          *(float *)(v28 + 4) = -v30;
          CCarCtrl::JoinCarWithRoadSystem((CVehicle *)v10);
          v32 = v10[58];
          *((_DWORD *)v10 + 536) = 1046562734;
          v10[58] = v32 & 7 | 0x18;
          CWorld::Add((CEntity *)v10);
          *((float *)v10 + 626) = v27;
          v10[958] = 38;
          v33 = pFlightHeight;
          v34 = *((_DWORD *)v10 + 268);
          v35 = *((_DWORD *)v10 + 267);
          *((float *)v10 + 625) = pFlightHeight;
          *((float *)v10 + 623) = v33;
          *((float *)v10 + 18) = v30 * 0.66667;
          *((float *)v10 + 19) = v31 * 0.66667;
          *((_DWORD *)v10 + 20) = 0;
          *((_WORD *)v10 + 600) = 255;
          v10[980] = 50;
          v36 = v35 & 0xFFFFFFEF;
          if ( (v34 & 0x200) == 0 )
            v36 = v35 | 0x10;
          *((_DWORD *)v10 + 267) = v36;
          *((_DWORD *)v10 + 268) = v34 | 0x40;
          v37 = rand() % 2;
          if ( v37 == 1 )
          {
            v55 = *((_DWORD *)v10 + 5);
            v56 = (float *)(v55 + 48);
            if ( !v55 )
              v56 = (float *)(v10 + 4);
            v57 = *v56;
            v58 = *((_DWORD *)v56 + 1);
            v59 = v56[2];
            FindPlayerCoors(&v82, -1);
            v89.z = v59;
            *(_QWORD *)&v89.x = __PAIR64__(v58, LODWORD(v57));
            UnsuspectingTargetPed = CWorld::FindUnsuspectingTargetPed(v89, v82);
            v61 = UnsuspectingTargetPed;
            if ( UnsuspectingTargetPed )
            {
              *((_DWORD *)v10 + 264) = UnsuspectingTargetPed;
              v10[958] = 39;
              CEntity::RegisterReference(UnsuspectingTargetPed, (CEntity **)v10 + 264);
              v62 = *(_WORD *)(v10 + 991);
              v10[2460] |= 2u;
              *(_WORD *)(v10 + 991) = v62 | 0xA0;
              PedsGroup = CPedGroups::GetPedsGroup(v61);
              v64 = PedsGroup;
              v65 = PedsGroup == 0;
              if ( PedsGroup )
                v65 = PedsGroup->m_iGroupCreatedBy == 1;
              if ( v65 )
              {
                if ( !CPed::IsPlayer(v61) )
                {
                  CharCreatedBy = v61->CharCreatedBy;
                  v67 = CharCreatedBy == 2;
                  if ( CharCreatedBy != 2 )
                    v67 = v61->m_nPedType == 6;
                  if ( !v67 )
                  {
                    CEventDanger::CEventDanger(&v81, (CEntity *)v10, 200.0);
                    v81.m_iTaskType = 911;
                    CEventGroup::Add(&v61->m_pPedIntelligence->m_eventGroup, (CEvent *)&v81, 0);
                    CEventDanger::~CEventDanger(&v81);
                  }
                }
              }
              else
              {
                CEventDanger::CEventDanger(&v81, (CEntity *)v10, 200.0);
                v81.m_iTaskType = 1505;
                CPedGroupIntelligence::AddEvent(&v64->m_intelligence, (CEvent *)&v81);
                CEventDanger::~CEventDanger(&v81);
              }
            }
          }
          else if ( !v37 )
          {
            v38 = *((_DWORD *)v10 + 5);
            v39 = (float *)(v38 + 48);
            if ( !v38 )
              v39 = (float *)(v10 + 4);
            v40 = *v39;
            v41 = *((_DWORD *)v39 + 1);
            v42 = v39[2];
            FindPlayerCoors(&v83, -1);
            v88.z = v42;
            *(_QWORD *)&v88.x = __PAIR64__(v41, LODWORD(v40));
            UnsuspectingTargetCar = CWorld::FindUnsuspectingTargetCar(v88, v83);
            if ( UnsuspectingTargetCar )
            {
              *((_DWORD *)v10 + 264) = UnsuspectingTargetCar;
              v10[958] = 39;
              CEntity::RegisterReference(UnsuspectingTargetCar, (CEntity **)v10 + 264);
              v44 = *(_WORD *)(v10 + 991);
              v10[2460] |= 2u;
              *(_WORD *)(v10 + 991) = v44 | 0xA0;
            }
          }
        }
        else
        {
          v15 = 0;
          v16 = 0;
          if ( CPlane::GenPlane_ModelIndex == 577 )
            v15 = 1;
          if ( CPlane::GenPlane_ModelIndex == 592 )
            v16 = 1;
          CPlane::FindPlaneCreationCoors((CVector *)&v81, &pCoors, &pTargetCoors.x, &pPlaneOrientation, v15 | v16);
          v17 = (char *)CVehicle::operator new(0xA18u);
          CPlane::CPlane((CPlane *)v17, CPlane::GenPlane_ModelIndex, 1u);
          m_iAccumulatedTime = v81.m_iAccumulatedTime;
          v19 = *((_DWORD *)v17 + 5);
          v20 = *(_DWORD *)&v81.m_bIsPersistent;
          if ( v19 )
          {
            *(_DWORD *)(v19 + 48) = v81._vptr$CEvent;
            *(_DWORD *)(*((_DWORD *)v17 + 5) + 52) = m_iAccumulatedTime;
            v21 = (_DWORD *)(*((_DWORD *)v17 + 5) + 56);
          }
          else
          {
            *((_DWORD *)v17 + 1) = v81._vptr$CEvent;
            *((_DWORD *)v17 + 2) = m_iAccumulatedTime;
            v21 = v17 + 12;
          }
          *v21 = v20;
          x = pTargetCoors.x;
          v46 = *((_DWORD *)v17 + 5);
          *((_DWORD *)v17 + 622) = LODWORD(pTargetCoors.x);
          v47 = sinf(x);
          v48 = cosf(x);
          *(float *)v46 = v47;
          *(_DWORD *)(v46 + 8) = 0;
          *(float *)(v46 + 16) = v48;
          *(float *)(v46 + 20) = v47;
          *(_DWORD *)(v46 + 24) = 0;
          *(_DWORD *)(v46 + 32) = 0;
          *(_DWORD *)(v46 + 36) = 0;
          *(_DWORD *)(v46 + 40) = 1065353216;
          *(float *)(v46 + 4) = -v48;
          CCarCtrl::JoinCarWithRoadSystem((CVehicle *)v17);
          v17[58] = v17[58] & 7 | 0x18;
          CWorld::Add((CEntity *)v17);
          v49 = *((_DWORD *)v17 + 267);
          v50 = *((_DWORD *)v17 + 268);
          v17[958] = 36;
          v51 = pPlaneOrientation;
          *((_DWORD *)v17 + 268) = v50 | 0x40;
          *((float *)v17 + 625) = v51;
          *((float *)v17 + 626) = x;
          *((float *)v17 + 627) = x;
          *((float *)v17 + 623) = v51;
          *((float *)v17 + 18) = v48 * 0.66667;
          *((float *)v17 + 19) = v47 * 0.66667;
          *((_DWORD *)v17 + 20) = 0;
          v52 = CPlane::GenPlane_ModelIndex;
          v53 = CPlane::GenPlane_ModelIndex == 520;
          if ( CPlane::GenPlane_ModelIndex != 520 )
            v53 = v9 == 592;
          if ( v53 || v9 == 577 )
          {
            v54 = v9 == 592;
            *((_WORD *)v17 + 600) = 360;
            if ( v9 != 592 )
              v54 = v9 == 577;
            if ( v54 )
              *((_DWORD *)v17 + 7) &= ~1u;
            if ( v52 == 520 )
            {
              *((_WORD *)v17 + 1088) = 0;
              v17[958] = 59;
            }
          }
          else
          {
            *((_WORD *)v17 + 600) = 150;
          }
          v69 = *((_DWORD *)v17 + 227);
          v68 = *((_DWORD *)v17 + 226);
          *((_DWORD *)v17 + 632) = 1065353216;
          v70 = (float)(*(float *)(v68 + 16) * 0.5) / 1000.0;
          v71 = *(float *)(v69 + 48);
          *(_DWORD *)(v17 + 1465) = 33686018;
          v72 = v49 & 0xFFFFFFEF;
          *((float *)v17 + 39) = v71 * v70;
          if ( (v50 & 0x200) == 0 )
            v72 = v49 | 0x10;
          *((_DWORD *)v17 + 267) = v72;
          *((_DWORD *)v17 + 268) = v50 | 0x40;
          CStreaming::SetModelIsDeletable(v52);
          CStreaming::SetModelTxdIsDeletable(CPlane::GenPlane_ModelIndex);
        }
        CPlane::GenPlane_Status = 0;
        CPlane::GenPlane_LastTimeGenerated = CTimer::m_snTimeInMilliseconds;
      }
      else
      {
        sub_192918(CPlane::GenPlane_ModelIndex, 8);
      }
    }
    else if ( !CPlane::GenPlane_Status )
    {
      if ( v1 > 4 || CGame::currArea )
        goto LABEL_74;
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      v5 = p_tx->m_translate.x;
      v6 = p_tx->m_translate.y;
      if ( sqrtf(
             (float)((float)((float)(p_tx->m_translate.x + 1073.0) * (float)(p_tx->m_translate.x + 1073.0))
                   + (float)((float)(v6 + 675.0) * (float)(v6 + 675.0)))
           + (float)((float)(p_tx->m_translate.z + -50.0) * (float)(p_tx->m_translate.z + -50.0))) < 200.0
        || v5 > -2743.0 && v5 < -2626.0 && v6 > 1300.0 && v6 < 2200.0 )
      {
        goto LABEL_74;
      }
      if ( v5 > -1668.0 && v5 < -1122.0 )
      {
        v7 = 0;
        v8 = 0;
        if ( v6 < 1118.0 )
          v7 = 1;
        if ( v6 > 541.0 )
          v8 = 1;
        if ( (v8 & v7) != 0 )
          goto LABEL_74;
      }
      if ( CCutsceneMgr::ms_cutsceneProcessing )
      {
LABEL_74:
        CPlane::GenPlane_LastTimeGenerated = CTimer::m_snTimeInMilliseconds;
        return;
      }
      if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL4
        && FindPlayerVehicle(-1, 0)
        && (FindPlayerVehicle(-1, 0)->m_vehicleType == 4 || FindPlayerVehicle(-1, 0)->m_vehicleType == 3)
        && FindPlayerVehicle(-1, 0)->m_nModelIndex != 577
        && FindPlayerVehicle(-1, 0)->m_nModelIndex != 592
        && CTimer::m_snTimeInMilliseconds > CPlane::GenPlane_LastTimeGenerated + 60000 )
      {
        v22 = CPools::ms_pVehiclePool->m_nSize;
        if ( !v22 )
          goto LABEL_66;
        v23 = 0;
        do
        {
          v24 = 2604 * v22--;
          v25 = v24 - 2604;
          while ( (CPools::ms_pVehiclePool->m_aFlags[v22] & 0x80u) != 0 || !&(*CPools::ms_pVehiclePool->m_aStorage)[v25] )
          {
            --v22;
            v25 -= 2604;
            if ( v22 == -1 )
              goto LABEL_63;
          }
          if ( (*CPools::ms_pVehiclePool->m_aStorage)[v25 + 958] == 59 )
            ++v23;
        }
        while ( v22 );
LABEL_63:
        if ( v23 < 1 || v23 == 1 && FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel >= WANTED_LEVEL5 )
        {
LABEL_66:
          CPlane::GenPlane_Status = 1;
          CPlane::GenPlane_ModelIndex = 520;
        }
      }
      if ( v1 <= 0 )
      {
        if ( !CPlane::GenPlane_Status
          && ((unsigned __int16)CWeather::WeatherRegion | 4) == 4
          && CWeather::OldWeatherType != 19
          && CWeather::NewWeatherType != 19 )
        {
          if ( !FindPlayerVehicle(-1, 0)
            || (PlayerVehicle = FindPlayerVehicle(-1, 0), CVehicle::GetVehicleAppearance(PlayerVehicle) != APR_HELI)
            && (v74 = FindPlayerVehicle(-1, 0), CVehicle::GetVehicleAppearance(v74) != APR_PLANE) )
          {
            if ( CTimer::m_snTimeInMilliseconds > CPlane::GenPlane_LastTimeGenerated + 120000 )
            {
              CPlane::GenPlane_ModelIndex = (Int32)*(&off_579D14 + (rand() & 7 ^ 4));
              CPlane::GenPlane_Status = 1;
            }
          }
        }
        v26 = CPlane::GenPlane_Status;
        if ( !CPlane::GenPlane_Status && CPopCycle::m_bCurrentZoneIsGangArea )
        {
          if ( !CTheScripts::IsPlayerOnAMission()
            && CTimer::m_snTimeInMilliseconds > CPlane::GenPlane_LastTimeGenerated + 350000 )
          {
            goto LABEL_118;
          }
          v26 = CPlane::GenPlane_Status;
        }
        if ( !v26 )
        {
          if ( CGameLogic::LaRiotsActiveHere() )
          {
LABEL_118:
            CPlane::GenPlane_ModelIndex = 497;
            CPlane::GenPlane_Status = 1;
            return;
          }
          if ( !CPlane::GenPlane_Status
            && ((unsigned __int16)CWeather::WeatherRegion | 4) != 4
            && !CPopCycle::m_bCurrentZoneIsGangArea
            && CWeather::OldWeatherType != 19
            && CWeather::NewWeatherType != 19
            && CTimer::m_snTimeInMilliseconds > CPlane::GenPlane_LastTimeGenerated + 200000 )
          {
            p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
            if ( !TheCamera.m_pMat )
              p_m_transform = &TheCamera.m_transform;
            v76 = p_m_transform->m_translate.y;
            if ( sqrtf(
                   (float)((float)(p_m_transform->m_translate.x + -1522.0)
                         * (float)(p_m_transform->m_translate.x + -1522.0))
                 + (float)((float)(v76 + 1237.0) * (float)(v76 + 1237.0))) >= 800.0
              && sqrtf(
                   (float)((float)(p_m_transform->m_translate.x + 1836.0)
                         * (float)(p_m_transform->m_translate.x + 1836.0))
                 + (float)((float)(v76 + -659.0) * (float)(v76 + -659.0))) >= 800.0 )
            {
              if ( !FindPlayerVehicle(-1, 0)
                || (v77 = FindPlayerVehicle(-1, 0), CVehicle::GetVehicleAppearance(v77) != APR_HELI)
                && (v78 = FindPlayerVehicle(-1, 0), CVehicle::GetVehicleAppearance(v78) != APR_PLANE) )
              {
                v79 = rand();
                v80 = 592;
                if ( (v79 & 1) == 0 )
                  v80 = 577;
                CPlane::GenPlane_ModelIndex = v80;
                CPlane::GenPlane_Status = 1;
              }
            }
          }
        }
      }
    }
  }
}
// 579D14: using guessed type void *off_579D14;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00579D9C) --------------------------------------------------------
void CPlane::InitPlaneGenerationAndRemoval()
{
  CPlane::GenPlane_LastTimeGenerated = 0;
  CPlane::GenPlane_Status = 0;
  CPlane::GenPlane_Active = 1;
}

//----- (00579DC8) --------------------------------------------------------
void __fastcall CPlane::SwitchAmbientPlanes(bool bActive)
{
  CVehiclePool *v2; // r11
  int32 m_nSize; // r0
  int v4; // r5
  int v5; // r4
  uint8 *v6; // r6

  if ( CPlane::GenPlane_Active && !bActive )
  {
    v2 = CPools::ms_pVehiclePool;
    m_nSize = CPools::ms_pVehiclePool->m_nSize;
    if ( m_nSize )
    {
      v4 = m_nSize - 1;
      v5 = 2604 * m_nSize - 1160;
      do
      {
        if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
        {
          v6 = &(*v2->m_aStorage)[v5];
          if ( v6 != (uint8 *)&elf_hash_bucket[298]
            && (unsigned int)(*(_DWORD *)&(*v2->m_aStorage)[v5] - 3) <= 1
            && *(v6 - 252) == 1 )
          {
            CWorld::Remove((CEntity *)(v6 - 1444));
            (*(void (__fastcall **)(uint8 *))(*((_DWORD *)v6 - 361) + 4))(v6 - 1444);
          }
        }
        --v4;
        v5 -= 2604;
      }
      while ( v4 != -1 );
    }
  }
  CPlane::GenPlane_Active = bActive;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00579E70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CPlane::BlowUpCar(CPlane *this, CEntity *pCulprit, Bool8 bInACutscene)
{
  int Mission; // r0
  bool v6; // zf
  CPlayerInfo *v7; // r0
  float v8; // s0
  int v9; // r0
  unsigned int m_info; // r1
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  CPed *pDriver; // r1
  CPed *v13; // r1
  CPed *v14; // r1
  CPed *v15; // r1
  CPed *v16; // r1
  CPed *v17; // r1
  CPed *v18; // r1
  CPed *v19; // r1
  CPed *v20; // r1
  int m_nFlags; // r2
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  RpClump_0 *m_pRwObject; // r0
  RwFrame_0 *v24; // r0
  char v25; // r1
  CSimpleTransform *p_m_transform; // r5
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CVehicle::CVehicleFlags v29; // kr00_8
  char v30; // r1
  unsigned int v31; // r0
  unsigned int v32; // r1
  CMatrix *v33; // r0
  __int64 v34; // kr08_8 OVERLAPPED
  eExplosionType v35; // r2
  RwReal bExtinguishEnabled; // [sp+0h] [bp-38h] OVERLAPPED
  RwReal z; // [sp+4h] [bp-34h]
  int data[7]; // [sp+1Ch] [bp-1Ch] BYREF

  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) != 0 )
  {
    if ( *(_BYTE *)&this->m_info < 8u )
      goto LABEL_8;
    Mission = (unsigned __int8)this->AutoPilot.Mission;
    v6 = Mission == 57;
    if ( Mission != 57 )
      v6 = this->m_nModelIndex == 464;
    if ( v6 )
    {
LABEL_8:
      if ( FindPlayerPed(-1) == pCulprit || FindPlayerVehicle(-1, 0) == pCulprit )
      {
        v7 = &CWorld::Players[CWorld::PlayerInFocus];
        v8 = v7->CurrentChaseValue + 10.0;
        v7->HavocCaused += 20;
        v7->CurrentChaseValue = v8;
        v9 = rand();
        CStats::IncrementStat(0x7Du, (float)(v9 % 6000 + 4000));
      }
      m_info = (unsigned __int8)this->m_info;
      p_m_nVehicleFlags = &this->m_nVehicleFlags;
      if ( m_info <= 7 )
      {
        pDriver = this->pDriver;
        if ( pDriver )
          *((_DWORD *)&pDriver->m_nPedFlags + 2) |= 2u;
        v13 = this->pPassengers[0];
        if ( v13 )
          *((_DWORD *)&v13->m_nPedFlags + 2) |= 2u;
        v14 = this->pPassengers[1];
        if ( v14 )
          *((_DWORD *)&v14->m_nPedFlags + 2) |= 2u;
        v15 = this->pPassengers[2];
        if ( v15 )
          *((_DWORD *)&v15->m_nPedFlags + 2) |= 2u;
        v16 = this->pPassengers[3];
        if ( v16 )
          *((_DWORD *)&v16->m_nPedFlags + 2) |= 2u;
        v17 = this->pPassengers[4];
        if ( v17 )
          *((_DWORD *)&v17->m_nPedFlags + 2) |= 2u;
        v18 = this->pPassengers[5];
        if ( v18 )
          *((_DWORD *)&v18->m_nPedFlags + 2) |= 2u;
        v19 = this->pPassengers[6];
        if ( v19 )
          *((_DWORD *)&v19->m_nPedFlags + 2) |= 2u;
        v20 = this->pPassengers[7];
        if ( v20 )
          *((_DWORD *)&v20->m_nPedFlags + 2) |= 2u;
        this->m_vecTurnSpeed.z = 0.0;
        LOBYTE(m_info) = this->m_info;
        m_nFlags = (int)this->m_nFlags;
        *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
        *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
        this->m_vecTurnSpeed.y = 0.0;
        *(_DWORD *)&this->m_nFlags = m_nFlags & 0xFFFFFF7E;
      }
      m_nPhysicalFlags = this->m_nPhysicalFlags;
      m_pRwObject = (RpClump_0 *)this->m_pRwObject;
      this->m_info = (CEntity::CEntityInfo)(m_info & 7 | 0x28);
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x20000000);
      this->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
      CVisibilityPlugins::SetClumpForAllAtomicsFlag(m_pRwObject, 0x4000);
      CDamageManager::FuckCarCompletely(&this->Damage, 0);
      if ( this->m_nModelIndex != 464 )
      {
        CAutomobile::SetBumperDamage(this, FRONT_BUMPER, 0);
        CAutomobile::SetBumperDamage(this, REAR_BUMPER, 0);
        CAutomobile::SetDoorDamage(this, BONNET_0, 0);
        CAutomobile::SetDoorDamage(this, BOOT_0, 0);
        CAutomobile::SetDoorDamage(this, FRONT_LEFT_DOOR_0, 0);
        CAutomobile::SetDoorDamage(this, FRONT_RIGHT_DOOR_0, 0);
        CAutomobile::SetDoorDamage(this, REAR_LEFT_DOOR_0, 0);
        CAutomobile::SetDoorDamage(this, REAR_RIGHT_DOOR_0, 0);
        CAutomobile::SpawnFlyingComponent(this, 5, 1u);
        v24 = this->m_aCarNodes[5];
        if ( v24 )
        {
          data[0] = 0;
          RwFrameForAllObjects(v24, GetCurrentAtomicObjectCB, data);
          if ( data[0] )
            *(_BYTE *)(data[0] + 2) = 0;
        }
      }
      v25 = *((_BYTE *)&this->CVehicle + 1202);
      p_m_transform = &this->m_transform;
      this->DelayedExplosion = 0;
      m_pMat = this->m_pMat;
      this->m_nHealth = 0.0;
      *((_BYTE *)&this->CVehicle + 1202) = v25 & 0xF8;
      p_tx = &this->m_transform;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      CCamera::CamShake(&TheCamera, 0.4, p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z);
      CVehicle::KillPedsInVehicle(this);
      v29 = *p_m_nVehicleFlags;
      v30 = *((_BYTE *)&this->CVehicle + 1202);
      v31 = *((_DWORD *)&this->m_nVehicleFlags + 1) & 0xFFFF7FFF;
      this->m_fxActive = 0;
      *((_BYTE *)&this->CVehicle + 1202) = v30 & 0xE7;
      v32 = *(_DWORD *)&v29 & 0xFFFFFFAF;
      *(_DWORD *)p_m_nVehicleFlags = *(_DWORD *)&v29 & 0xFFFFFFAF;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v31;
      *(_BYTE *)&this->m_nAutomobileFlags &= ~1u;
      if ( (*(_BYTE *)&v29 & 2) != 0 )
      {
        v32 = *(_DWORD *)&v29 & 0xFFFFFFAD;
        *(_DWORD *)p_m_nVehicleFlags = *(_DWORD *)&v29 & 0xFFFFFFAD;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v31;
        --CCarCtrl::NumAmbulancesOnDuty;
      }
      if ( (v32 & 4) != 0 )
      {
        *(_DWORD *)p_m_nVehicleFlags = v32 & 0xFFFFFFAB;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v31 & 0xFFFF7FFF;
        --CCarCtrl::NumFireTrucksOnDuty;
      }
      CVehicle::ChangeLawEnforcerState(this, 0);
      CFireManager::StartFire(&gFireManager, this, pCulprit, 0.8, 1u, 7000, 0);
      CDarkel::RegisterCarBlownUpByPlayer(this, 0);
      v33 = this->m_pMat;
      if ( v33 )
        p_m_transform = (CSimpleTransform *)&v33->tx;
      if ( this->m_nModelIndex == 464 )
        v35 = EXP_TYPE_TINY;
      else
        v35 = EXP_TYPE_HELI;
      bExtinguishEnabled = p_m_transform->m_translate.y;
      z = p_m_transform->m_translate.z;
      v34 = *(_QWORD *)&p_m_transform->m_translate.x;
      CExplosion::AddExplosion(this, pCulprit, v35, *(CVector *)(&bExtinguishEnabled - 1), 0, 1u, -1.0, 0);
    }
    else
    {
      this->m_nHealth = 0.0;
      this->AutoPilot.Mission = 57;
    }
  }
}
// 579E70: fragmented variable at r3.4 may be wrong
// 579E70: fragmented variable at kr08_8.8 may be wrong
// 57A1A3: failed to expand linear variable ^0.4
// 676438: using guessed type CFireManager *gFireManager_ptr;
// 579E70: using guessed type int data[7];

//----- (0057A1F4) --------------------------------------------------------
bool __fastcall CPlane::SetUpWheelColModel(CPlane *this, CColModel *pColModel)
{
  return 0;
}

//----- (0057A1F8) --------------------------------------------------------
bool __fastcall CPlane::BurstTyre(CPlane *this, uint8 nWheelPieceType, bool bApplyForce)
{
  return 0;
}

//----- (0057A1FC) --------------------------------------------------------
void __fastcall CQuadBike::CQuadBike(CQuadBike *this, int nModelIndex, UInt8 CreatedBy)
{
  int (**v5)(void); // r2
  CBaseModelInfo *v6; // r0
  int v7; // r0
  char v8; // r0

  CAutomobile::CAutomobile(this, nModelIndex, CreatedBy, 0);
  this->_vptr$CPlaceable = (int (**)(void))&off_66DEAC;
  CRideAnimData::CRideAnimData(&this->RideAnimData);
  v5 = this->_vptr$CPlaceable;
  v6 = CModelInfo::ms_modelInfoPtrs[nModelIndex];
  this->RideAnimData.m_animGroup = ANIM_QUAD_PED;
  v7 = *((unsigned __int8 *)&v6[1].m_flags + 2);
  *(_QWORD *)&this->m_fSwingArmLength = 0LL;
  *(_QWORD *)&this->m_fForkZOffset = 0LL;
  this->m_vehicleType = 2;
  this->pBikeHandling = (tBikeHandlingData *)(&mod_HandlingManager.m_aHandlingData[163].fSteeringLock + 16 * v7);
  ((void (__fastcall *)(CQuadBike *))v5[49])(this);
  v8 = *((_BYTE *)this + 2508);
  this->m_fSteerAngle = 0.0;
  *((_BYTE *)this + 2508) = v8 & 0xFE;
}
// 66DEAC: using guessed type void *;

//----- (0057A28C) --------------------------------------------------------
void __fastcall CQuadBike::~CQuadBike(CQuadBike *this)
{
  this->_vptr$CPlaceable = (int (**)(void))&off_66DEAC;
  CRideAnimData::~CRideAnimData(&this->RideAnimData);
  sub_19E450(this);
}
// 66DEAC: using guessed type void *off_66DEAC;

//----- (0057A2B4) --------------------------------------------------------
void __fastcall CQuadBike::~CQuadBike(CQuadBike *this)
{
  void *v2; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_66DEAC;
  CRideAnimData::~CRideAnimData(&this->RideAnimData);
  CAutomobile::~CAutomobile(this);
  sub_199F98(v2);
}
// 57A2D6: variable 'v2' is possibly undefined
// 66DEAC: using guessed type void *off_66DEAC;

//----- (0057A2E0) --------------------------------------------------------
void __fastcall CQuadBike::SetupSuspensionLines(CQuadBike *this)
{
  this->m_fSwingArmLength = 1.0;
  sub_19177C(this);
}

//----- (0057A2F0) --------------------------------------------------------
void __fastcall CQuadBike::ProcessControl(CQuadBike *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d3
  float y; // s20
  float x; // r5
  float v6; // r9
  float v7; // s18
  float v8; // s0
  float zy; // s0
  float v10; // s0
  float v11; // s2
  CMatrix *m_pMat; // r5
  float v13; // s22
  float v14; // s24
  float m_fTurnMass; // s26
  float v16; // r8
  float xz; // s28
  float yz; // s30
  float zz; // s17
  float v20; // s0
  CMatrix *v21; // r5
  float v22; // s20
  float v23; // s24
  float v24; // s26
  float v25; // s28
  float v26; // s0
  CVector v27; // [sp+0h] [bp-80h]
  CVector v28; // [sp+0h] [bp-80h]
  CVector v29; // [sp+10h] [bp-70h] BYREF
  CVector v30; // [sp+1Ch] [bp-64h] BYREF
  CVector v31; // 0:r1.12
  CVector v32; // 0:r1.12

  if ( *(_BYTE *)&this->m_info <= 7u && bDoQuadDamping )
  {
    y = vecQuadResistance.y;
    x = vecQuadResistance.x;
    Multiply3x3(&v30, &this->m_vecTurnSpeed, this->m_pMat);
    if ( this->m_aWheelRatios[0] == 1.0 && this->m_aWheelRatios[2] == 1.0 )
    {
      v6 = 0.995;
      if ( this->m_aWheelRatios[1] >= 1.0 && this->m_aWheelRatios[3] >= 1.0 )
      {
        v7 = 0.995;
        goto LABEL_17;
      }
      v7 = 0.995;
      v1.n64_u32[0] = LODWORD(this->m_pMat->zy);
      if ( v1.n64_f32[0] <= 0.0 )
      {
LABEL_17:
        m_pMat = this->m_pMat;
        v13 = v30.x;
        v14 = v30.y;
        m_fTurnMass = this->m_fTurnMass;
        v16 = CTimer::ms_fTimeStep;
        xz = m_pMat->xz;
        yz = m_pMat->yz;
        zz = m_pMat->zz;
        Multiply3x3(&v29, m_pMat, &this->m_vecCOM);
        v20 = (float)(v14 * powf(y * (float)(1.0 / (float)((float)(v14 * v14) + 1.0)), v16)) - v14;
        v27.x = m_pMat->xx + v29.x;
        v27.y = m_pMat->yx + v29.y;
        v27.z = m_pMat->zx + v29.z;
        v31.x = -(float)((float)(xz * v20) * m_fTurnMass);
        v31.y = -(float)((float)(v20 * yz) * m_fTurnMass);
        v31.z = -(float)((float)(v20 * zz) * m_fTurnMass);
        CPhysical::ApplyTurnForce(this, v31, v27);
        v21 = this->m_pMat;
        v22 = this->m_fTurnMass;
        v23 = v21->xz;
        v24 = v21->yz;
        v25 = v21->zz;
        Multiply3x3(&v29, v21, &this->m_vecCOM);
        v26 = (float)(v13 * powf((float)(1.0 / (float)((float)(v13 * (float)(v7 * v13)) + 1.0)) * v6, v16)) - v13;
        v32.x = (float)(v26 * v23) * v22;
        v32.y = (float)(v26 * v24) * v22;
        v32.z = (float)(v26 * v25) * v22;
        v28.x = v21->xy + v29.x;
        v28.y = v21->yy + v29.y;
        v28.z = v21->zy + v29.z;
        CPhysical::ApplyTurnForce(this, v32, v28);
        goto LABEL_18;
      }
      v2.n64_u32[0] = 1032805417;
      v1.n64_f32[0] = fabsf(this->pBikeHandling->fWheelieBalancePoint - v1.n64_f32[0]) * 0.25;
      v8 = x - vmin_f32(v1, v2).n64_f32[0];
    }
    else
    {
      v7 = 0.5;
      if ( this->m_aWheelCounts[1] != 1.0
        || this->m_aWheelCounts[3] != 1.0
        || (v7 = 0.995, zy = this->m_pMat->zy, zy >= 0.0) )
      {
        v6 = x;
        goto LABEL_17;
      }
      v10 = fabsf(this->pBikeHandling->fStoppieBalancePoint - zy) * 0.3;
      v11 = v10 + 0.9;
      if ( v10 > 0.1 )
        v11 = 1.0;
      v8 = v11 * x;
    }
    v6 = v8;
    goto LABEL_17;
  }
LABEL_18:
  CAutomobile::ProcessControl(this);
}
// 57A3BA: variable 'v1' is possibly undefined
// 57A3BA: variable 'v2' is possibly undefined

//----- (0057A5DC) --------------------------------------------------------
bool __fastcall CQuadBike::ProcessAI(CQuadBike *this, uint32 *nProcContFlags)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  int RecordingNumber; // r0
  tHandlingData *pHandling; // r1
  CPed *pDriver; // r0
  __int64 v9; // d16
  CPed *v10; // r0
  int m_nVehicleFlags; // r1
  CPad *PadFromPlayer; // r5
  CMatrix *m_pMat; // r0
  float v15; // s2
  float m_fLeanFwd; // s0
  tBikeHandlingData *v17; // r1
  tBikeHandlingData *v18; // r1
  float v19; // s0
  float v20; // s0
  float v21; // s18
  CMatrix *v22; // r0
  float x; // s4
  float y; // s6
  float z; // s8
  float yx; // s10
  float zx; // s12
  float v28; // s0
  float xy; // s14
  float yy; // s1
  float zy; // s3
  float v32; // s0
  tBikeHandlingData *pBikeHandling; // r0
  float v34; // s0
  float v35; // s2
  float v36; // r0
  CVector v37; // [sp+0h] [bp-28h]
  CVector v38; // [sp+0h] [bp-28h]
  CVector v39; // 0:r1.12
  CVector v40; // 0:r1.12

  if ( *(_BYTE *)&this->m_info < 8u )
  {
    CEntity::GetColModel(this);
    RecordingNumber = this->AutoPilot.RecordingNumber;
    *(_WORD *)((char *)&this->AutoPilot + 75) &= 0xFFFCu;
    if ( RecordingNumber >= 0 && !CVehicleRecording::bUseCarAI[RecordingNumber] )
      return 0;
    pHandling = this->pHandling;
    pDriver = this->pDriver;
    v9 = *(_QWORD *)&pHandling->CentreOfMass.x;
    this->m_vecCOM.z = pHandling->CentreOfMass.z;
    *(_QWORD *)&this->m_vecCOM.x = v9;
    if ( !pDriver || !CPed::IsPlayer(pDriver) )
      return 0;
    CEntity::PruneReferences(this);
    if ( CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 809)
      || CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 823)
      || CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 825)
      || (v10 = this->pDriver, v10->m_nPedState == PED_ARRESTED) )
    {
      m_nVehicleFlags = (int)this->m_nVehicleFlags;
      this->m_fGasPedal = 0.0;
      this->m_fBrakePedal = 1.0;
      *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags | 0x20;
      return 0;
    }
    if ( v10 && CPed::IsPlayer(v10) )
    {
      (*((void (__fastcall **)(CQuadBike *, _DWORD))this->_vptr$CPlaceable + 25))(
        this,
        LOBYTE(this->pDriver->m_nPedType));
      PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
    }
    else
    {
      PadFromPlayer = 0;
    }
    m_pMat = this->m_pMat;
    v15 = (float)((float)(this->m_vecTurnSpeed.x * m_pMat->xx) + (float)(this->m_vecTurnSpeed.y * m_pMat->yx))
        + (float)(this->m_vecTurnSpeed.z * m_pMat->zx);
    m_fLeanFwd = this->RideAnimData.m_fLeanFwd;
    if ( m_fLeanFwd >= 0.0 || (v17 = this->pBikeHandling, v15 >= v17->fLeanBakCOMMult) )
    {
      if ( m_fLeanFwd <= 0.0 || (v18 = this->pBikeHandling, v15 <= (float)-v18->fLeanFwdCOMMult) )
      {
LABEL_34:
        if ( this->m_aWheelRatios[0] != 1.0
          || this->m_aWheelRatios[1] != 1.0
          || this->m_aWheelRatios[2] != 1.0
          || !PadFromPlayer
          || this->m_aWheelRatios[3] != 1.0 )
        {
          goto LABEL_51;
        }
        v21 = (float)CPad::GetSteeringLeftRight(PadFromPlayer) * 0.0078125;
        if ( CHID::GetInputType() == 2 && fabsf(v21) < 0.05 )
        {
          v4.n64_u32[0] = -1.5;
          v2.n64_f32[0] = CPad::NewMouseControllerState.m_AmountMoved.x * 0.01;
          v3.n64_u32[0] = 1.5;
          LODWORD(v21) = vmin_f32(vmax_f32(v2, v4), v3).n64_u32[0];
        }
        if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x20) != 0 )
        {
          v22 = this->m_pMat;
          if ( v21 >= 0.0 && v21 <= 0.0 )
            goto LABEL_51;
          x = this->m_vecCOM.x;
          y = this->m_vecCOM.y;
          z = this->m_vecCOM.z;
          yx = v22->yx;
          zx = v22->zx;
          v28 = v21 * CTimer::ms_fTimeStep;
          xy = v22->xy;
          yy = v22->yy;
          zy = v22->zy;
        }
        else
        {
          if ( CPad::GetAccelerate(PadFromPlayer) )
            goto LABEL_51;
          v22 = this->m_pMat;
          if ( v21 >= 0.0 && v21 <= 0.0 )
            goto LABEL_51;
          x = this->m_vecCOM.x;
          y = this->m_vecCOM.y;
          z = this->m_vecCOM.z;
          yx = v22->yx;
          zx = v22->zx;
          v28 = v21 * CTimer::ms_fTimeStep;
          xy = v22->xz;
          yy = v22->yz;
          zy = v22->zz;
        }
        v32 = this->m_fTurnMass * (float)(v28 * 0.0015);
        v40.x = v22->xx * v32;
        v40.y = v32 * yx;
        v40.z = v32 * zx;
        v38.x = x + xy;
        v38.y = y + yy;
        v38.z = z + zy;
        CPhysical::ApplyTurnForce(this, v40, v38);
LABEL_51:
        pBikeHandling = this->pBikeHandling;
        v34 = (float)(this->pHandling->fSteeringLock * -3.1416) / 180.0;
        v35 = pBikeHandling->fFullAnimAngle * this->m_fSteerAngle;
        v36 = powf(pBikeHandling->fDesLeanReturnFrac, CTimer::ms_fTimeStep);
        this->RideAnimData.m_fLeanAngle = (float)(v36 * this->RideAnimData.m_fLeanAngle)
                                        + (float)((float)(1.0 - v36) * (float)(v35 / v34));
        CVehicle::DoDriveByShootings(this);
        if ( CCheat::m_aCheatsActive[41] )
          (*((void (__fastcall **)(CQuadBike *))this->_vptr$CPlaceable + 70))(this);
        return 0;
      }
      if ( this->nNoOfContactWheels )
      {
        if ( this->m_fBrakePedal <= 0.0 )
        {
          v19 = 0.0;
        }
        else
        {
          v4.n64_u32[0] = 1036831949;
          v3.n64_f32[0] = sqrtf(
                            (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                  + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                          + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
          v3.n64_u64[0] = vmin_f32(v3, v4).n64_u64[0];
          v19 = (float)((float)(m_fLeanFwd * this->m_fTurnMass) * v18->fLeanFwdForceMult) * v3.n64_f32[0];
        }
      }
      else
      {
        v19 = (float)(m_fLeanFwd * this->m_fTurnMass) * 0.0015;
      }
      v20 = v19 * CTimer::ms_fTimeStep;
    }
    else
    {
      if ( this->nNoOfContactWheels )
      {
        v3.n64_u32[0] = 0;
        if ( this->m_fBrakePedal == 0.0 && (*(_BYTE *)&this->m_nVehicleFlags & 0x20) == 0 )
        {
          v4.n64_u32[0] = 1036831949;
          v3.n64_f32[0] = sqrtf(
                            (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                  + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                          + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
          v3.n64_u64[0] = vmin_f32(v3, v4).n64_u64[0];
          v3.n64_f32[0] = (float)((float)(m_fLeanFwd * this->m_fTurnMass) * v17->fLeanBakForceMult) * v3.n64_f32[0];
        }
      }
      else
      {
        v3.n64_f32[0] = (float)(m_fLeanFwd * this->m_fTurnMass) * 0.0015;
      }
      v20 = v3.n64_f32[0] * CTimer::ms_fTimeStep;
    }
    v39.x = -(float)(v20 * m_pMat->xz);
    v39.y = -(float)(v20 * m_pMat->yz);
    v39.z = -(float)(v20 * m_pMat->zz);
    v37.x = this->m_vecCOM.x + m_pMat->xy;
    v37.y = this->m_vecCOM.y + m_pMat->yy;
    v37.z = this->m_vecCOM.z + m_pMat->zy;
    CPhysical::ApplyTurnForce(this, v39, v37);
    goto LABEL_34;
  }
  return sub_196F40(this, nProcContFlags);
}
// 57A794: variable 'v3' is possibly undefined
// 57A794: variable 'v4' is possibly undefined
// 57A95C: variable 'v2' is possibly undefined

//----- (0057ABB4) --------------------------------------------------------
void __fastcall CQuadBike::ProcessControlInputs(CQuadBike *this, uint8 CtrlNum)
{
  int32 v2; // r4
  CPad *Pad; // r0
  float *p_m_fLeanFwd; // r5
  float v6; // s6
  float v7; // s0
  float v8; // s2
  bool v9; // fzf
  bool v10; // fnf
  float v11; // s2

  v2 = CtrlNum;
  CAutomobile::ProcessControlInputs(this, CtrlNum);
  Pad = CPad::GetPad(v2);
  p_m_fLeanFwd = &this->RideAnimData.m_fLeanFwd;
  v6 = -1.0;
  v7 = *p_m_fLeanFwd
     + (float)(CTimer::ms_fTimeStep
             * (float)((float)((float)((float)-CPad::GetSteeringUpDown(Pad) * 0.0078125) - *p_m_fLeanFwd) * 0.2));
  v8 = -1.0;
  v9 = v7 == -1.0;
  v10 = v7 < -1.0;
  if ( v7 >= 1.0 )
    v8 = 1.0;
  if ( !v10 && !v9 )
    v6 = v8;
  v11 = v6;
  if ( !v10 && !v9 )
    v11 = v7;
  if ( v7 >= 1.0 )
    v11 = v6;
  *p_m_fLeanFwd = v11;
  if ( CPad::GetPad(v2)->DisablePlayerControls )
    *p_m_fLeanFwd = 0.0;
}

//----- (0057AC6C) --------------------------------------------------------
void __fastcall CQuadBike::ProcessDrivingAnims(CQuadBike *this, CPed *pPed, bool8 playRadioAnim)
{
  if ( (*((_BYTE *)&this->m_nFlags + 2) & 2) == 0 )
    CBike::ProcessRiderAnims(pPed, this, &this->RideAnimData, this->pBikeHandling, 0);
}

//----- (0057AC98) --------------------------------------------------------
void __fastcall CQuadBike::PreRender(CQuadBike *this)
{
  CVehicleModelInfo *v2; // r10
  RwFrame_0 *v3; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  float v7; // r0
  RwFrame_0 *v8; // r0
  float v9; // s16
  float v10; // s18
  float v11; // s20
  float v12; // r0
  RwFrame_0 *v13; // r0
  float v14; // s16
  float v15; // s18
  float v16; // s20
  CVector posn; // [sp+14h] [bp-84h] BYREF
  CMatrix v18; // [sp+20h] [bp-78h] BYREF

  CAutomobile::PreRender(this);
  v2 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v18.m_pRwMat = 0;
  v18.m_owner = 0;
  CVehicleModelInfo::GetWheelPosn(v2, 1, &posn, 0);
  CVehicle::SetTransmissionRotation(
    this,
    this->m_aCarNodes[16],
    this->m_aWheelSuspensionHeights[1],
    this->m_aWheelSuspensionHeights[3],
    SLODWORD(posn.x),
    posn.y,
    posn.z,
    0);
  CVehicleModelInfo::GetWheelPosn(v2, 0, &posn, 0);
  v3 = this->m_aCarNodes[15];
  if ( v3 )
  {
    CMatrix::Attach(&v18, &v3->modelling, 0);
    tx = v18.tx;
    ty = v18.ty;
    tz = v18.tz;
    v7 = atan2f(this->m_aWheelSuspensionHeights[0] - posn.z, COERCE_FLOAT(LODWORD(posn.x) & 0x7FFFFFFF));
    CMatrix::SetRotateY(&v18, v7);
    v18.tx = tx + v18.tx;
    v18.ty = ty + v18.ty;
    v18.tz = tz + v18.tz;
    CMatrix::UpdateRW(&v18);
  }
  v8 = this->m_aCarNodes[14];
  if ( v8 )
  {
    CMatrix::Attach(&v18, &v8->modelling, 0);
    v9 = v18.tx;
    v10 = v18.ty;
    v11 = v18.tz;
    v12 = atan2f(this->m_aWheelSuspensionHeights[2] - posn.z, COERCE_FLOAT(LODWORD(posn.x) & 0x7FFFFFFF));
    CMatrix::SetRotateY(&v18, COERCE_FLOAT(LODWORD(v12) ^ 0x80000000));
    v18.tx = v9 + v18.tx;
    v18.ty = v10 + v18.ty;
    v18.tz = v11 + v18.tz;
    CMatrix::UpdateRW(&v18);
  }
  v13 = this->m_aCarNodes[17];
  if ( v13 )
  {
    CMatrix::Attach(&v18, &v13->modelling, 0);
    v14 = v18.tx;
    v15 = v18.ty;
    v16 = v18.tz;
    CMatrix::SetRotateZ(&v18, QUAD_HBSTEER_ANIM_MULT * this->RideAnimData.m_fAnimLeanLeft);
    v18.tx = v14 + v18.tx;
    v18.ty = v15 + v18.ty;
    v18.tz = v16 + v18.tz;
    CMatrix::UpdateRW(&v18);
  }
  CMatrix::~CMatrix(&v18);
}

//----- (0057AE64) --------------------------------------------------------
void __fastcall CQuadBike::Fix(CQuadBike *this)
{
  CDamageManager *p_Damage; // r4
  RpClump_0 *m_pRwObject; // r0

  p_Damage = &this->Damage;
  CDamageManager::ResetDamageStatus(&this->Damage);
  CDamageManager::SetDoorStatus(p_Damage, FRONT_LEFT_DOOR_0, 4u);
  CDamageManager::SetDoorStatus(p_Damage, FRONT_RIGHT_DOOR_0, 4u);
  CDamageManager::SetDoorStatus(p_Damage, REAR_LEFT_DOOR_0, 4u);
  CDamageManager::SetDoorStatus(p_Damage, REAR_RIGHT_DOOR_0, 4u);
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x10000u;
  RpClumpForAllAtomics(m_pRwObject, CVehicleModelInfo::HideAllComponentsAtomicCB, (char *)&dword_0 + 2);
  CDamageManager::SetWheelStatus(p_Damage, 0, 0);
  CDamageManager::SetWheelStatus(p_Damage, 1, 0);
  CDamageManager::SetWheelStatus(p_Damage, 2, 0);
  sub_18A19C(p_Damage, 3, 0);
}
// 0: using guessed type int dword_0;

//----- (0057AEE8) --------------------------------------------------------
void __fastcall CQuadBike::SetupDamageAfterLoad(CQuadBike *this)
{
  if ( this->m_aCarNodes[12] )
    CAutomobile::SetBumperDamage(this, FRONT_BUMPER, 0);
  if ( this->m_aCarNodes[13] )
    sub_190F64(this, BONNET_0, 0);
}

//----- (0057AF16) --------------------------------------------------------
CRideAnimData *__fastcall CQuadBike::GetRideAnimData(CQuadBike *this)
{
  return &this->RideAnimData;
}

//----- (0057AF1C) --------------------------------------------------------
void __fastcall CTrailer::CTrailer(CTrailer *this, int nModelIndex, UInt8 CreatedBy)
{
  unsigned int m_nModelIndex; // r1

  CAutomobile::CAutomobile(this, nModelIndex, CreatedBy, 0);
  this->m_aSupportRatios[0] = 1.0;
  this->m_vehicleType = 11;
  this->m_aSupportRatios[1] = 1.0;
  this->m_fSupportExtension = 1.0;
  this->m_fSupportMinRatio = 1.0;
  m_nModelIndex = this->m_nModelIndex;
  this->_vptr$CPlaceable = (int (**)(void))&off_66DFD4;
  if ( m_nModelIndex >> 1 == 303 )
    this->m_fSupportExtension = -1000.0;
  CTrailer::SetupSuspensionLines(this);
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x20);
}
// 66DFD4: using guessed type void *;

//----- (0057AF88) --------------------------------------------------------
void __fastcall CTrailer::~CTrailer(CTrailer *this)
{
  void *v1; // r0

  CAutomobile::~CAutomobile(this);
  sub_199F98(v1);
}
// 57AF94: variable 'v1' is possibly undefined

//----- (0057AF98) --------------------------------------------------------
void __fastcall CTrailer::SetupSuspensionLines(CTrailer *this)
{
  CVehicleModelInfo *v2; // r10
  CColModel *ColModel; // r6
  CCollisionData *m_pColData; // r5
  float *m_fLineLength; // r11
  int32 v6; // r6
  int i; // r8
  float z; // r0
  __int64 v9; // d16
  int v10; // r0
  CColLine *m_pLineArray; // r0
  __int64 v12; // d16
  float *v13; // r0
  float *v14; // r3
  float v15; // s0
  float v16; // s2
  float v17; // s0
  float *v18; // r0
  __int64 *p_m_vecMax; // r9
  float v20; // s2
  RwFrame_0 *v21; // r11
  __int64 v22; // d16
  __int64 v23; // d17
  __int64 v24; // d18
  __int64 v25; // d19
  __int64 v26; // d20
  __int64 v27; // d21
  __int64 v28; // d23
  RwFrame_0 *parent; // r6
  __int64 v30; // d16
  RwReal v31; // r0
  __int64 v32; // d16
  RwReal v33; // r1
  CColLine *v34; // r2
  __int64 v35; // d16
  RwReal v36; // r0
  CColLine *v37; // r2
  CColLine *v38; // r1
  __int64 v39; // d16
  RwReal v40; // r0
  CColLine *v41; // r1
  float *v42; // r0
  float v43; // s6
  float v44; // s0
  float v45; // s2
  float m_fHeightAboveRoad; // s2
  CColModel *v47; // [sp+0h] [bp-80h]
  float *p_x; // [sp+4h] [bp-7Ch]
  RwMatrix matrix; // [sp+8h] [bp-78h] BYREF
  CVector posn; // [sp+48h] [bp-38h] BYREF

  v2 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  ColModel = CEntity::GetColModel(this);
  if ( this->m_fSupportExtension == -1000.0 )
  {
    sub_19177C(this);
  }
  else
  {
    m_pColData = ColModel->m_pColData;
    if ( !m_pColData->_anon_1.m_pLineArray )
    {
      m_pColData->_anon_0.m_nNoOfLines = 6;
      m_pColData->_anon_1.m_pLineArray = (CColLine *)CMemoryMgr::Malloc(0xC0u);
    }
    m_fLineLength = this->m_fLineLength;
    v47 = ColModel;
    p_x = &ColModel->m_boxBound.m_vecMin.x;
    v6 = 0;
    for ( i = 24; i != 152; i += 32 )
    {
      CVehicleModelInfo::GetWheelPosn(v2, v6, &posn, 0);
      z = posn.z;
      ++v6;
      *(m_fLineLength - 20) = posn.z;
      posn.z = this->pHandling->fSuspensionUpperLimit + z;
      v9 = *(_QWORD *)&posn.x;
      v10 = (int)m_pColData->_anon_1.m_pLineArray + i;
      *(RwReal *)(v10 - 16) = posn.z;
      *(_QWORD *)(v10 - 24) = v9;
      posn.z = posn.z
             + (float)((float)(this->pHandling->fSuspensionLowerLimit - this->pHandling->fSuspensionUpperLimit)
                     + (float)(v2->m_wheelScale * -0.5));
      m_pLineArray = m_pColData->_anon_1.m_pLineArray;
      v12 = *(_QWORD *)&posn.x;
      *(RwReal *)((char *)&m_pLineArray->m_vecStart.x + i) = posn.z;
      *(_QWORD *)((char *)m_pLineArray + i - 8) = v12;
      *(m_fLineLength - 4) = this->pHandling->fSuspensionUpperLimit - this->pHandling->fSuspensionLowerLimit;
      v13 = (float *)((char *)&m_pColData->_anon_1.m_pLineArray->m_vecStart.x + i);
      *m_fLineLength++ = *(v13 - 4) - *v13;
    }
    v14 = p_x;
    v15 = m_pColData->_anon_1.m_pLineArray->m_vecEnd.z;
    v16 = p_x[2];
    if ( v15 < v16 )
    {
      p_x[2] = v15;
      v16 = v15;
    }
    v17 = p_x[5];
    v18 = &v47->m_boxBound.m_vecMin.x;
    p_m_vecMax = (__int64 *)&v47->m_boxBound.m_vecMax;
    if ( sqrtf((float)((float)(*p_x * *p_x) + (float)(p_x[1] * p_x[1])) + (float)(v16 * v16)) <= sqrtf(
                                                                                                   (float)((float)(p_x[3] * p_x[3]) + (float)(p_x[4] * p_x[4]))
                                                                                                 + (float)(v17 * v17)) )
      v18 = &v47->m_boxBound.m_vecMax.x;
    v20 = sqrtf((float)((float)(*v18 * *v18) + (float)(v18[1] * v18[1])) + (float)(v18[2] * v18[2]));
    if ( p_x[9] < v20 )
      p_x[9] = v20;
    v21 = this->m_aCarNodes[20];
    if ( v21 )
    {
      v22 = *(_QWORD *)&v21->modelling.right.x;
      v23 = *(_QWORD *)&v21->modelling.right.z;
      v24 = *(_QWORD *)&v21->modelling.up.x;
      v25 = *(_QWORD *)&v21->modelling.up.z;
      v26 = *(_QWORD *)&v21->modelling.at.x;
      v27 = *(_QWORD *)&v21->modelling.at.z;
      v28 = *(_QWORD *)&v21->modelling.pos.z;
      *(_QWORD *)&matrix.pos.x = *(_QWORD *)&v21->modelling.pos.x;
      *(_QWORD *)&matrix.pos.z = v28;
      *(_QWORD *)&matrix.at.x = v26;
      *(_QWORD *)&matrix.at.z = v27;
      *(_QWORD *)&matrix.right.x = v22;
      *(_QWORD *)&matrix.right.z = v23;
      *(_QWORD *)&matrix.up.x = v24;
      *(_QWORD *)&matrix.up.z = v25;
      parent = (RwFrame_0 *)v21->object.parent;
      while ( parent )
      {
        RwMatrixTransform(&matrix, &parent->modelling, rwCOMBINEPOSTCONCAT);
        parent = (RwFrame_0 *)parent->object.parent;
        if ( parent == v21 )
          parent = 0;
      }
      posn = (CVector)matrix.pos;
      this->m_fSupportStartZ = matrix.pos.z;
      v30 = *p_m_vecMax;
      posn.z = v47->m_boxBound.m_vecMax.z;
      *(_QWORD *)&posn.x = v30;
      v14 = p_x;
      v31 = p_x[5];
    }
    else
    {
      v31 = v17;
      v32 = *p_m_vecMax;
      posn.z = v47->m_boxBound.m_vecMax.z;
      *(_QWORD *)&posn.x = v32;
    }
    v33 = *v14;
    posn.z = v31;
    posn.x = v33;
    v34 = m_pColData->_anon_1.m_pLineArray;
    v35 = *(_QWORD *)&posn.x;
    v34[4].m_vecStart.z = v31;
    *(_QWORD *)&v34[4].m_vecStart.x = v35;
    posn.z = v14[2];
    v36 = posn.z;
    v37 = m_pColData->_anon_1.m_pLineArray;
    *(_QWORD *)&v37[4].m_vecEnd.x = *(_QWORD *)&posn.x;
    v37[4].m_vecEnd.z = v36;
    LODWORD(posn.x) = LODWORD(v33) ^ 0x80000000;
    posn.z = v14[5];
    v38 = m_pColData->_anon_1.m_pLineArray;
    v39 = *(_QWORD *)&posn.x;
    v38[5].m_vecStart.z = posn.z;
    *(_QWORD *)&v38[5].m_vecStart.x = v39;
    posn.z = v14[2];
    v40 = posn.z;
    v41 = m_pColData->_anon_1.m_pLineArray;
    *(_QWORD *)&v41[5].m_vecEnd.x = *(_QWORD *)&posn.x;
    v41[5].m_vecEnd.z = v40;
    v42 = &m_pColData->_anon_1.m_pLineArray->m_vecStart.x;
    v43 = fabsf(v42[33]);
    v44 = v43 / (float)(v43 + (float)(fabsf(v42[1] + v42[9]) * 0.5));
    v45 = (float)(v2->m_wheelScale * 0.5)
        + (float)((float)(this->m_fSuspensionLength[0]
                        * (float)((float)(v44 / (float)(this->pHandling->fSuspensionForce * -4.0)) + 1.0))
                - v42[2]);
    this->m_fHeightAboveRoad = v45;
    this->m_fRearHeightAboveRoad = v45;
    m_pColData->_anon_1.m_pLineArray[4].m_vecEnd.z = m_pColData->_anon_1.m_pLineArray[4].m_vecStart.z
                                                   - (float)((float)(m_pColData->_anon_1.m_pLineArray[4].m_vecStart.z
                                                                   + v45)
                                                           / (float)((float)((float)(1.0 - v44)
                                                                           / (float)(CTrailer::m_fTrailerSuspensionForce
                                                                                   * -2.0))
                                                                   + 1.0));
    m_pColData->_anon_1.m_pLineArray[5].m_vecEnd.z = m_pColData->_anon_1.m_pLineArray[4].m_vecEnd.z;
    m_fHeightAboveRoad = this->m_fHeightAboveRoad;
    this->m_aWheelSuspensionHeights[0] = (float)(v2->m_wheelScale * 0.5) - m_fHeightAboveRoad;
    this->m_aWheelSuspensionHeights[1] = (float)(v2->m_wheelScale * 0.5) - m_fHeightAboveRoad;
    this->m_aWheelSuspensionHeights[2] = (float)(v2->m_wheelScale * 0.5) - m_fHeightAboveRoad;
    this->m_aWheelSuspensionHeights[3] = (float)(v2->m_wheelScale * 0.5) - m_fHeightAboveRoad;
  }
}

//----- (0057B374) --------------------------------------------------------
void __fastcall CTrailer::ProcessControl(CTrailer *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float *p_m_fSupportExtension; // r0
  CVehicle *m_pTowingVehicle; // r1
  float v7; // r0

  CAutomobile::ProcessControl(this);
  if ( (*(_BYTE *)&this->m_nFlags & 0x40) == 0 )
  {
    p_m_fSupportExtension = &this->m_fSupportExtension;
    v1.n64_u32[0] = LODWORD(this->m_fSupportExtension);
    if ( v1.n64_f32[0] != -1000.0 )
    {
      m_pTowingVehicle = this->m_pTowingVehicle;
      if ( v1.n64_f32[0] > 0.0 && m_pTowingVehicle )
      {
        v3.n64_u32[0] = 0;
        v1.n64_f32[0] = v1.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.002);
        v1.n64_u32[0] = vmax_f32(v1, v3).n64_u32[0];
        *p_m_fSupportExtension = v1.n64_f32[0];
      }
      else
      {
        v2.n64_u32[0] = 1.0;
        if ( v1.n64_f32[0] < 1.0 && !m_pTowingVehicle )
        {
          if ( v1.n64_f32[0] <= 0.1 )
          {
            v1.n64_f32[0] = v1.n64_f32[0] + (float)(CTimer::ms_fTimeStep * 0.0005);
          }
          else
          {
            v1.n64_f32[0] = v1.n64_f32[0] + (float)(CTimer::ms_fTimeStep * 0.002);
            v1.n64_u32[0] = vmin_f32(v1, v2).n64_u32[0];
          }
          *p_m_fSupportExtension = v1.n64_f32[0];
          this->m_nNoOfStaticFrames = 0;
        }
      }
      if ( (*(_BYTE *)&this->m_info & 0xF0) == 80 && TRAILER_TOWED_MINRATIO > v1.n64_f32[0] )
        p_m_fSupportExtension = &TRAILER_TOWED_MINRATIO;
      v7 = *p_m_fSupportExtension;
      this->m_fSupportMinRatio = v7;
      this->m_aSupportRatios[0] = v7;
      this->m_aSupportRatios[1] = v7;
    }
  }
}
// 57B3C6: variable 'v1' is possibly undefined
// 57B3C6: variable 'v3' is possibly undefined
// 57B404: variable 'v2' is possibly undefined

//----- (0057B478) --------------------------------------------------------
bool __fastcall CTrailer::ProcessAI(CTrailer *this, uint32 *nProcContFlags)
{
  bool v3; // r4
  int v4; // r0
  float m_fSupportExtension; // s0
  CVehicle *m_pTowingVehicle; // r0
  CMatrix *m_pMat; // r1
  float m_heading; // s16
  CMatrix *v9; // r0
  float v10; // s0
  float v11; // s2

  v3 = CAutomobile::ProcessAI(this, nProcContFlags);
  v4 = *(_BYTE *)&this->m_info & 0xF8;
  if ( v4 == 80 )
  {
    m_pTowingVehicle = this->m_pTowingVehicle;
    if ( !m_pTowingVehicle )
      return v3;
    if ( this->m_fSupportExtension != -1000.0 )
    {
      this->m_fBrakePedal = m_pTowingVehicle->m_fBrakePedal;
      return v3;
    }
    m_pMat = m_pTowingVehicle->m_pMat;
    if ( m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      m_heading = m_pTowingVehicle->m_transform.m_heading;
    v9 = this->m_pMat;
    if ( v9 )
      v10 = atan2f(COERCE_FLOAT(LODWORD(v9->xy) ^ 0x80000000), v9->yy);
    else
      v10 = this->m_transform.m_heading;
    if ( m_heading <= (float)(v10 + 3.1416) )
    {
      if ( m_heading >= (float)(v10 + -3.1416) )
      {
LABEL_20:
        this->m_fSteerAngle = m_heading - v10;
        return v3;
      }
      v11 = 6.2832;
    }
    else
    {
      v11 = -6.2832;
    }
    m_heading = m_heading + v11;
    goto LABEL_20;
  }
  if ( v4 == 32 )
  {
    m_fSupportExtension = this->m_fSupportExtension;
    if ( m_fSupportExtension > 0.5 || m_fSupportExtension == -1000.0 )
      CTrailer::ScanForTowLink(this);
  }
  return v3;
}

//----- (0057B57C) --------------------------------------------------------
void __fastcall CTrailer::ScanForTowLink(CTrailer *this)
{
  int v2; // r5
  CTrailer *v3; // r6
  float32x2_t v4; // d16
  unsigned __int64 v5; // d0
  Int16 pNum; // [sp+26h] [bp-7Ah] BYREF
  CEntity *v7[16]; // [sp+28h] [bp-78h] BYREF
  CVector Coors; // [sp+68h] [bp-38h] BYREF
  float32x2_t v9; // [sp+78h] [bp-28h] BYREF
  float v10; // [sp+80h] [bp-20h]

  if ( !this->m_pTowingVehicle && !CVehicleRecording::IsPlaybackGoingOnForCar(this) && this->m_nModelIndex != 610 )
  {
    v9.n64_u64[0] = 0LL;
    v10 = 0.0;
    memset(&Coors, 0, sizeof(Coors));
    if ( (*((int (__fastcall **)(CTrailer *, CVector *, _DWORD, CTrailer *))this->_vptr$CPlaceable + 60))(
           this,
           &Coors,
           0,
           this) == 1 )
    {
      CWorld::FindObjectsInRange(&Coors, 10.0, 1, &pNum, 16, v7, 0, 1, 0, 0, 0);
      if ( pNum >= 1 )
      {
        LOWORD(v2) = 0;
        while ( 1 )
        {
          v3 = (CTrailer *)v7[(__int16)v2];
          if ( v3 != this
            && (*((int (__fastcall **)(CEntity *, float32x2_t *, _DWORD, CTrailer *))v3->_vptr$CPlaceable + 61))(
                 v7[(__int16)v2],
                 &v9,
                 0,
                 this) == 1 )
          {
            v4.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors.x, v9).n64_u64[0];
            v5 = vmul_f32(v4, v4).n64_u64[0];
            if ( sqrtf(*(float *)&v5 + *((float *)&v5 + 1)) < RELINK_TRAILER_DIFF_LIMIT_XY
              && fabsf(Coors.z - v10) < RELINK_TRAILER_DIFF_LIMIT_Z )
            {
              break;
            }
          }
          v2 = (__int16)(v2 + 1);
          if ( v2 >= pNum )
            return;
        }
        (*((void (__fastcall **)(CTrailer *, CTrailer *, _DWORD))this->_vptr$CPlaceable + 62))(this, v3, 0);
      }
    }
  }
}

//----- (0057B6A4) --------------------------------------------------------
void __fastcall CTrailer::ProcessSuspension(CTrailer *this)
{
  float *m_aSupportRatios; // r11
  float *p_m_fSupportMinRatio; // r6
  CSimpleTransform *p_m_transform; // r5
  float m_fSupportMinRatio; // s0
  float v6; // s2
  CMatrix *m_pMat; // r0
  float v8; // s0
  CSimpleTransform *p_tx; // r2
  RwReal v10; // s4
  RwReal v11; // s8
  RwReal v12; // s2
  RwReal v13; // s6
  float *v14; // r9
  float v15; // s2
  CMatrix *v16; // r0
  float v17; // s0
  RwReal v18; // s4
  RwReal v19; // s8
  RwReal v20; // s2
  RwReal v21; // s4
  CMatrix *v22; // r0
  float zz; // s4
  RwReal v24; // s0
  float z; // s0
  RwReal v26; // s2
  RwReal v27; // s4
  CMatrix *v28; // r0
  float v29; // s4
  RwReal v30; // s0
  float v31; // s0
  RwReal v32; // s2
  RwReal v33; // s4
  unsigned __int8 WheelStatus; // r8
  uint32 v35; // r2
  CDamageManager *p_Damage; // r0
  unsigned __int8 v37; // r11
  uint32 v38; // r2
  CDamageManager *v39; // r0
  CVector vecDirection; // [sp+18h] [bp-68h] BYREF
  CVector vecOffset[2]; // [sp+28h] [bp-58h] BYREF
  CVector aWheelSpeeds[2]; // [sp+40h] [bp-40h] BYREF
  float fSpringForce; // [sp+58h] [bp-28h] BYREF
  float fImpulseMagnitude[9]; // [sp+5Ch] [bp-24h] BYREF

  CAutomobile::ProcessSuspension(this);
  if ( this->m_fSupportExtension != -1000.0 )
  {
    fSpringForce = 0.0;
    fImpulseMagnitude[0] = 0.0;
    memset(aWheelSpeeds, 0, sizeof(aWheelSpeeds));
    m_aSupportRatios = this->m_aSupportRatios;
    p_m_fSupportMinRatio = &this->m_fSupportMinRatio;
    p_m_transform = &this->m_transform;
    memset(vecOffset, 0, sizeof(vecOffset));
    m_fSupportMinRatio = this->m_fSupportMinRatio;
    v6 = this->m_aSupportRatios[0];
    if ( v6 < m_fSupportMinRatio && m_fSupportMinRatio > 0.1 )
    {
      m_pMat = this->m_pMat;
      v8 = v6 / m_fSupportMinRatio;
      p_tx = &this->m_transform;
      v10 = -m_pMat->xz;
      v11 = -m_pMat->zz;
      vecDirection.y = -m_pMat->yz;
      vecDirection.x = v10;
      vecDirection.z = v11;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      v12 = this->m_aSupportColPoints[0].m_vecPosition.x - p_tx->m_translate.x;
      v13 = this->m_aSupportColPoints[0].m_vecPosition.z - p_tx->m_translate.z;
      vecOffset[0].y = this->m_aSupportColPoints[0].m_vecPosition.y - p_tx->m_translate.y;
      vecOffset[0].x = v12;
      vecOffset[0].z = v13;
      CPhysical::ApplySpringCollisionAlt(
        this,
        CTrailer::m_fTrailerSuspensionForce,
        &vecDirection,
        vecOffset,
        v8,
        1.0,
        &this->m_aSupportColPoints[0].m_vecNormal,
        &fSpringForce);
      m_fSupportMinRatio = *p_m_fSupportMinRatio;
    }
    v14 = &this->m_aSupportRatios[1];
    v15 = this->m_aSupportRatios[1];
    if ( v15 < m_fSupportMinRatio && m_fSupportMinRatio > 0.1 )
    {
      v16 = this->m_pMat;
      v17 = v15 / m_fSupportMinRatio;
      v18 = -v16->xz;
      v19 = -v16->zz;
      vecDirection.y = -v16->yz;
      vecDirection.x = v18;
      vecDirection.z = v19;
      if ( v16 )
        p_m_transform = (CSimpleTransform *)&v16->tx;
      v20 = this->m_aSupportColPoints[1].m_vecPosition.x - p_m_transform->m_translate.x;
      v21 = this->m_aSupportColPoints[1].m_vecPosition.y - p_m_transform->m_translate.y;
      vecOffset[1].z = this->m_aSupportColPoints[1].m_vecPosition.z - p_m_transform->m_translate.z;
      vecOffset[1].y = v21;
      vecOffset[1].x = v20;
      CPhysical::ApplySpringCollisionAlt(
        this,
        CTrailer::m_fTrailerSuspensionForce,
        &vecDirection,
        &vecOffset[1],
        v17,
        1.0,
        &this->m_aSupportColPoints[1].m_vecNormal,
        fImpulseMagnitude);
      m_fSupportMinRatio = *p_m_fSupportMinRatio;
    }
    if ( *m_aSupportRatios < m_fSupportMinRatio && m_fSupportMinRatio > 0.1 )
    {
      CPhysical::GetSpeed(&vecDirection, this, vecOffset[0]);
      aWheelSpeeds[0] = vecDirection;
      m_fSupportMinRatio = *p_m_fSupportMinRatio;
    }
    if ( *v14 < m_fSupportMinRatio && m_fSupportMinRatio > 0.1 )
    {
      CPhysical::GetSpeed(&vecDirection, this, vecOffset[1]);
      aWheelSpeeds[1] = vecDirection;
      m_fSupportMinRatio = *p_m_fSupportMinRatio;
    }
    if ( *m_aSupportRatios < m_fSupportMinRatio && m_fSupportMinRatio > 0.1 )
    {
      v22 = this->m_pMat;
      zz = v22->zz;
      v24 = -v22->xz;
      vecDirection.y = -v22->yz;
      vecDirection.x = v24;
      vecDirection.z = -zz;
      z = this->m_aSupportColPoints[0].m_vecNormal.z;
      if ( z > 0.35 )
      {
        v26 = -this->m_aSupportColPoints[0].m_vecNormal.y;
        v27 = -this->m_aSupportColPoints[0].m_vecNormal.x;
        vecDirection.z = -z;
        vecDirection.y = v26;
        vecDirection.x = v27;
      }
      CPhysical::ApplySpringDampening(
        this,
        CTrailer::m_fTrailerDampingForce,
        fSpringForce,
        &vecDirection,
        vecOffset,
        &aWheelSpeeds[0].x);
      m_fSupportMinRatio = *p_m_fSupportMinRatio;
    }
    if ( *v14 < m_fSupportMinRatio && m_fSupportMinRatio > 0.1 )
    {
      v28 = this->m_pMat;
      v29 = v28->zz;
      v30 = -v28->xz;
      vecDirection.y = -v28->yz;
      vecDirection.x = v30;
      vecDirection.z = -v29;
      v31 = this->m_aSupportColPoints[1].m_vecNormal.z;
      if ( v31 > 0.35 )
      {
        v32 = -this->m_aSupportColPoints[1].m_vecNormal.y;
        v33 = -this->m_aSupportColPoints[1].m_vecNormal.x;
        vecDirection.z = -v31;
        vecDirection.y = v32;
        vecDirection.x = v33;
      }
      CPhysical::ApplySpringDampening(
        this,
        CTrailer::m_fTrailerDampingForce,
        fImpulseMagnitude[0],
        &vecDirection,
        &vecOffset[1],
        &aWheelSpeeds[1].x);
    }
    if ( (*(_BYTE *)&this->m_info & 0xF0) != 80 )
    {
      WheelStatus = CDamageManager::GetWheelStatus(&this->Damage, 0);
      if ( *m_aSupportRatios >= *p_m_fSupportMinRatio || *p_m_fSupportMinRatio <= 0.1 )
      {
        p_Damage = &this->Damage;
        v35 = 2;
      }
      else
      {
        CPhysical::GetSpeed(&vecDirection, this, vecOffset[0]);
        v35 = 0;
        aWheelSpeeds[0] = vecDirection;
        p_Damage = &this->Damage;
      }
      CDamageManager::SetWheelStatus(p_Damage, 0, v35);
      v37 = CDamageManager::GetWheelStatus(&this->Damage, 1);
      if ( *v14 >= *p_m_fSupportMinRatio || *p_m_fSupportMinRatio <= 0.1 )
      {
        v39 = &this->Damage;
        v38 = 2;
      }
      else
      {
        CPhysical::GetSpeed(&vecDirection, this, vecOffset[1]);
        v38 = 0;
        aWheelSpeeds[1] = vecDirection;
        v39 = &this->Damage;
      }
      CDamageManager::SetWheelStatus(v39, 1, v38);
      CAutomobile::ProcessCarWheelPair(
        this,
        0,
        1,
        0.0,
        aWheelSpeeds,
        vecOffset,
        (float)(this->pHandling->fTractionMultiplier * 0.004) * 0.25,
        0.0,
        1000.0,
        1);
      CDamageManager::SetWheelStatus(&this->Damage, 0, WheelStatus);
      CDamageManager::SetWheelStatus(&this->Damage, 1, v37);
    }
  }
}
// 57B6A4: using guessed type float var_24[9];

//----- (0057BB6C) --------------------------------------------------------
void __fastcall CTrailer::PreRender(CTrailer *this)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d3
  float32x2_t v3; // d4
  float32x2_t v4; // d5
  int m_nModelIndex; // r2
  CCollisionData *m_pColData; // r6
  int v8; // r0
  RwFrame_0 *v9; // r1
  float *p_x; // r0
  float *p_PropRotate; // r0
  float PropRotate; // s0
  CMatrix *m_pMat; // r1
  float xy; // s8
  float yy; // s10
  float v16; // s6
  float v17; // s4
  float v18; // s2
  bool v19; // nf
  float v20; // r3
  CMatrix v21; // [sp+8h] [bp-58h] BYREF

  CAutomobile::PreRender(this);
  m_nModelIndex = this->m_nModelIndex;
  m_pColData = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel->m_pColData;
  v21.m_pRwMat = 0;
  v21.m_owner = 0;
  v8 = (unsigned __int16)m_nModelIndex;
  v9 = this->m_aCarNodes[20];
  if ( v9
    && m_pColData->_anon_0.m_nNoOfLines >= 5
    && (this->m_vecMoveSpeed.x != 0.0
     || this->m_vecMoveSpeed.y != 0.0
     || this->m_vecMoveSpeed.z != 0.0
     || this->m_vecTurnSpeed.x != 0.0
     || this->m_vecTurnSpeed.y != 0.0
     || this->m_vecTurnSpeed.z != 0.0
     || !this->m_nNoOfStaticFrames) )
  {
    CMatrix::Attach(&v21, &v9->modelling, 0);
    p_x = &m_pColData->_anon_1.m_pLineArray->m_vecStart.x;
    v4.n64_u32[0] = LODWORD(this->m_fSupportExtension);
    v3.n64_f32[0] = (float)(this->m_aSupportRatios[0] + this->m_aSupportRatios[1]) * 0.5;
    v2.n64_u32[0] = LODWORD(this->m_fSupportStartZ);
    v1.n64_f32[0] = (float)((float)(v21.ty / p_x[33])
                          * (float)(p_x[34] + (float)(vmin_f32(v3, v4).n64_f32[0] * (float)(p_x[38] - p_x[34]))))
                  - (float)((float)(1.0 - (float)(v21.ty / p_x[33])) * this->m_fHeightAboveRoad);
    CMatrix::SetTranslate(&v21, v21.tx, v21.ty, vmin_f32(v1, v2).n64_f32[0]);
    CMatrix::UpdateRW(&v21);
    v8 = (unsigned __int16)this->m_nModelIndex;
  }
  if ( v8 == 610 )
  {
    p_PropRotate = &this->PropRotate;
    PropRotate = this->PropRotate;
    if ( PropRotate > 6.2832 )
    {
      PropRotate = PropRotate + -6.2832;
      *p_PropRotate = PropRotate;
    }
    m_pMat = this->m_pMat;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    v16 = this->m_vecMoveSpeed.z * m_pMat->zy;
    v17 = (float)((float)(this->m_vecMoveSpeed.x * xy) + (float)(this->m_vecMoveSpeed.y * yy)) + v16;
    v18 = 0.1;
    v19 = v17 < 0.1;
    if ( v17 <= 0.1 )
      v19 = v17 < 0.0;
    if ( v19 )
    {
      v18 = 0.0;
    }
    else if ( v17 <= 0.1 )
    {
      v18 = (float)((float)(this->m_vecMoveSpeed.x * xy) + (float)(this->m_vecMoveSpeed.y * yy)) + v16;
    }
    v20 = PropRotate - (float)(v18 * CTimer::ms_fTimeStep);
    *p_PropRotate = v20;
    CVehicle::SetComponentRotation(this, this->m_aCarNodes[21], 0, v20, 1);
  }
  CMatrix::~CMatrix(&v21);
}
// 57BC56: variable 'v3' is possibly undefined
// 57BC56: variable 'v4' is possibly undefined
// 57BC84: variable 'v1' is possibly undefined
// 57BC84: variable 'v2' is possibly undefined

//----- (0057BD6C) --------------------------------------------------------
void __fastcall CTrailer::ResetSuspension(CTrailer *this)
{
  float v2; // s0
  float *p_m_fSupportExtension; // r0

  CAutomobile::ResetSuspension(this);
  v2 = 1.0;
  this->m_aSupportRatios[0] = 1.0;
  this->m_aSupportRatios[1] = 1.0;
  p_m_fSupportExtension = &this->m_fSupportExtension;
  if ( this->m_pTowingVehicle && *p_m_fSupportExtension > -1000.0 )
    v2 = 0.0;
  *p_m_fSupportExtension = v2;
}

//----- (0057BDB4) --------------------------------------------------------
bool __fastcall CTrailer::GetTowHitchPos(CTrailer *this, CVector *vecResult, bool bGenericPosOk, CVehicle *pVeh)
{
  CBaseModelInfo *v5; // r12
  uint32 m_hashKey; // r1
  __int64 v7; // d16
  bool v8; // r1
  __int64 v9; // d16
  CVector v11; // [sp+0h] [bp-18h] BYREF

  v5 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  m_hashKey = v5[2].m_hashKey;
  v7 = *(_QWORD *)(m_hashKey + 108);
  vecResult->z = *(RwReal *)(m_hashKey + 116);
  *(_QWORD *)&vecResult->x = v7;
  if ( !pVeh || pVeh->m_nModelIndex != 525 )
  {
    if ( vecResult->x == 0.0 && vecResult->y == 0.0 && vecResult->z == 0.0 )
    {
      v8 = 0;
      if ( !bGenericPosOk )
        return v8;
      vecResult->x = 0.0;
      vecResult->y = v5->m_pColModel->m_boxBound.m_vecMax.y + 1.0;
      vecResult->z = 0.5 - this->m_fHeightAboveRoad;
    }
    operator*(&v11, this->m_pMat, vecResult);
    v9 = *(_QWORD *)&v11.x;
    v8 = 1;
    vecResult->z = v11.z;
    *(_QWORD *)&vecResult->x = v9;
    return v8;
  }
  return 0;
}

//----- (0057BE6C) --------------------------------------------------------
bool __fastcall CTrailer::GetTowBarPos(CTrailer *this, CVector *vecResult, bool bGenericPosOk, CVehicle *pVeh)
{
  __int64 v5; // d16
  bool result; // r0
  CVector v7; // [sp+0h] [bp-18h] BYREF

  if ( !bGenericPosOk && (unsigned int)this->m_nModelIndex >> 1 != 303 )
    return 0;
  vecResult->x = 0.0;
  vecResult->y = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.y + 0.05;
  vecResult->z = 0.5 - this->m_fHeightAboveRoad;
  operator*(&v7, this->m_pMat, vecResult);
  v5 = *(_QWORD *)&v7.x;
  vecResult->z = v7.z;
  result = 1;
  *(_QWORD *)&vecResult->x = v5;
  return result;
}

//----- (0057BEE8) --------------------------------------------------------
bool __fastcall CTrailer::SetTowLink(CTrailer *this, CVehicle *pTractor, bool bWarpPosition)
{
  _BOOL4 v4; // r6
  unsigned int m_info; // r1
  bool result; // r0
  CMatrix *m_pMat; // r0
  float m_heading; // s0
  CMatrix *v10; // r0
  CMatrix *v11; // r1
  CSimpleTransform *p_tx; // r2
  float v13; // s2
  float v14; // s6
  float v15; // s4
  float v16; // s2
  float v17; // s0
  float *p_tz; // r0
  __int64 v19; // d16
  float v20; // [sp+0h] [bp-28h] BYREF
  float v21; // [sp+4h] [bp-24h]
  float v22; // [sp+8h] [bp-20h]
  float v23; // [sp+Ch] [bp-1Ch] BYREF
  float v24; // [sp+10h] [bp-18h]
  float v25; // [sp+14h] [bp-14h]

  v4 = bWarpPosition;
  if ( !pTractor )
    return 0;
  m_info = (unsigned __int8)this->m_info;
  result = 0;
  if ( m_info >> 3 <= 0xA && ((1 << (m_info >> 3)) & 0x418) != 0 )
  {
    this->m_pTowingVehicle = pTractor;
    this->m_info = (CEntity::CEntityInfo)(m_info & 7 | 0x50);
    CEntity::RegisterReference(pTractor, &this->m_pTowingVehicle);
    pTractor->m_pVehicleBeingTowed = this;
    CEntity::RegisterReference(this, &pTractor->m_pVehicleBeingTowed);
    CPhysical::RemoveFromMovingList(this);
    CPhysical::RemoveFromMovingList(pTractor);
    CPhysical::AddToMovingList(this);
    CPhysical::AddToMovingList(pTractor);
    if ( !v4 )
    {
      CVehicle::UpdateTractorLink(pTractor, 1, 0);
LABEL_10:
      CAEVehicleAudioEntity::AddAudioEvent(&pTractor->m_VehicleAudioEntity, 113, 0.0);
      return 1;
    }
    if ( this->m_fSupportExtension > -1000.0 )
      this->m_fSupportExtension = 0.0;
    m_pMat = pTractor->m_pMat;
    if ( m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      m_heading = pTractor->m_transform.m_heading;
    v10 = this->m_pMat;
    if ( v10 )
      CMatrix::SetRotateZOnly(v10, m_heading);
    else
      this->m_transform.m_heading = m_heading;
    v24 = 0.0;
    v25 = 0.0;
    v20 = 0.0;
    v21 = 0.0;
    v22 = 0.0;
    v23 = 0.0;
    if ( (*((int (__fastcall **)(CTrailer *, float *, int, CTrailer *))this->_vptr$CPlaceable + 60))(
           this,
           &v20,
           1,
           this) == 1
      && (*((int (__fastcall **)(CVehicle *, float *, int, CTrailer *))pTractor->_vptr$CPlaceable + 61))(
           pTractor,
           &v23,
           1,
           this) == 1 )
    {
      v11 = this->m_pMat;
      p_tx = (CSimpleTransform *)&v11->tx;
      if ( !v11 )
        p_tx = &this->m_transform;
      v13 = v21 - p_tx->m_translate.y;
      v14 = v22 - p_tx->m_translate.z;
      v20 = v20 - p_tx->m_translate.x;
      v15 = v23 - v20;
      v21 = v13;
      v16 = v24 - v13;
      v17 = v25 - v14;
      v22 = v14;
      if ( v11 )
      {
        v11->tx = v15;
        this->m_pMat->ty = v16;
        p_tz = &this->m_pMat->tz;
      }
      else
      {
        p_tz = &this->m_transform.m_translate.z;
        this->m_transform.m_translate.x = v15;
        this->m_transform.m_translate.y = v16;
      }
      *p_tz = v17;
      v19 = *(_QWORD *)&pTractor->m_vecMoveSpeed.x;
      this->m_vecMoveSpeed.z = pTractor->m_vecMoveSpeed.z;
      *(_QWORD *)&this->m_vecMoveSpeed.x = v19;
      CAutomobile::PlaceOnRoadProperly(this);
      goto LABEL_10;
    }
    return 0;
  }
  return result;
}

//----- (0057C090) --------------------------------------------------------
bool __fastcall CTrailer::BreakTowLink(CTrailer *this)
{
  CVehicle *m_pTowingVehicle; // r0
  CVehicle **p_m_pTowingVehicle; // r5
  CVehicle *v4; // r0
  CEntity::CEntityInfo m_info; // r0

  m_pTowingVehicle = this->m_pTowingVehicle;
  if ( m_pTowingVehicle )
  {
    p_m_pTowingVehicle = &this->m_pTowingVehicle;
    CAEVehicleAudioEntity::AddAudioEvent(&m_pTowingVehicle->m_VehicleAudioEntity, 114, 0.0);
    v4 = this->m_pTowingVehicle;
    if ( v4 )
    {
      if ( v4->m_pVehicleBeingTowed )
      {
        CEntity::CleanUpOldReference(v4->m_pVehicleBeingTowed, &v4->m_pVehicleBeingTowed);
        (*p_m_pTowingVehicle)->m_pVehicleBeingTowed = 0;
        v4 = *p_m_pTowingVehicle;
      }
      CEntity::CleanUpOldReference(v4, &this->m_pTowingVehicle);
      *p_m_pTowingVehicle = 0;
    }
  }
  m_info = this->m_info;
  if ( (*(_BYTE *)&m_info & 0xF0) != 80 )
    return 0;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x20);
  return 1;
}

//----- (0057C0F4) --------------------------------------------------------
int32 __fastcall CTrailer::ProcessEntityCollision(CTrailer *this, CEntity *pEntity, CColPoint *aColPoints)
{
  CColModel *ColModel; // r0
  CTrailer *v6; // r3
  CColModel *v7; // r4
  CCollisionData *m_pColData; // r11
  __int64 v9; // d17
  float v10; // r2
  CEntity *v11; // r1
  CVehicle *m_pTowingVehicle; // r0
  bool v13; // zf
  int m_nNoOfTriangles; // r5
  int v15; // r8
  CColModel *v16; // r0
  CMatrix *m_pMat; // r6
  const CMatrix *v18; // r9
  CColModel *v19; // r0
  int v20; // r4
  CEntity *v21; // r12
  CTrailer *v22; // r3
  int v23; // r11
  int v24; // r10
  unsigned int v25; // r9
  int v26; // r5
  float v27; // s0
  char *v28; // r4
  float *v29; // r0
  float *v30; // r8
  CColPoint *v31; // r6
  int v32; // r0
  bool v33; // zf
  CMatrix *v34; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v36; // s2
  float *v37; // r0
  float v38; // s4
  CEntity::CFlags v39; // kr00_8
  unsigned int v40; // r1
  int v41; // r5
  bool v42; // cc
  CEntity *v43; // r0
  int v44; // r2
  float *v45; // [sp+10h] [bp-168h]
  int v46; // [sp+14h] [bp-164h]
  CEntity::CFlags *v47; // [sp+18h] [bp-160h]
  CEntity::CFlags *p_m_nFlags; // [sp+1Ch] [bp-15Ch]
  RwReal *p_z; // [sp+20h] [bp-158h]
  int v50; // [sp+24h] [bp-154h]
  CColPoint v53[4]; // [sp+30h] [bp-148h] BYREF
  CColPoint v54; // [sp+E0h] [bp-98h] BYREF
  CColPoint v55; // [sp+10Ch] [bp-6Ch] BYREF
  float aLineRatios[2]; // [sp+138h] [bp-40h] BYREF
  __int64 v57; // [sp+140h] [bp-38h]
  float v58; // [sp+148h] [bp-30h]
  float v59; // [sp+14Ch] [bp-2Ch]

  if ( this->m_fSupportExtension == -1000.0 )
    return sub_190558(this, pEntity, aColPoints);
  if ( (*(_BYTE *)&this->m_info & 0xF8) != 16 )
    *(_DWORD *)&this->m_nVehicleFlags |= 0x1000000u;
  ColModel = CEntity::GetColModel(this);
  v6 = this;
  v7 = ColModel;
  m_pColData = ColModel->m_pColData;
  v9 = *(_QWORD *)&this->m_aWheelRatios[2];
  *(_QWORD *)aLineRatios = *(_QWORD *)this->m_aWheelRatios;
  v57 = v9;
  v10 = this->m_aSupportRatios[1];
  v58 = this->m_aSupportRatios[0];
  v59 = v10;
  v11 = pEntity;
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 1) & 0x90) != 0 || (*(_BYTE *)&pEntity->m_info & 6) == 2 )
    m_pColData->_anon_0.m_nNoOfLines = 0;
  m_pTowingVehicle = this->m_pTowingVehicle;
  v13 = m_pTowingVehicle == pEntity;
  if ( m_pTowingVehicle != pEntity )
    v13 = this->m_pVehicleBeingTowed == pEntity;
  if ( v13 )
  {
    m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
    m_pColData->m_nNoOfTriangles = 0;
    v15 = CEntity::GetColModel(pEntity)->m_pColData->m_nNoOfTriangles;
    v16 = CEntity::GetColModel(pEntity);
    v6 = this;
    v11 = pEntity;
    v16->m_pColData->m_nNoOfTriangles = 0;
  }
  else
  {
    m_nNoOfTriangles = -1;
    v15 = -1;
  }
  m_pMat = v11->m_pMat;
  v18 = v6->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(v11);
    CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
    v11 = pEntity;
    m_pMat = pEntity->m_pMat;
  }
  v19 = CEntity::GetColModel(v11);
  v20 = CCollision::ProcessColModels(v18, v7, m_pMat, v19, aColPoints, v53, aLineRatios, 0);
  if ( m_nNoOfTriangles >= 0 )
    m_pColData->m_nNoOfTriangles = m_nNoOfTriangles;
  if ( v15 >= 0 )
    CEntity::GetColModel(pEntity)->m_pColData->m_nNoOfTriangles = v15;
  v21 = pEntity;
  if ( m_pColData->_anon_0.m_nNoOfLines )
  {
    v46 = v20;
    v22 = this;
    v23 = 0;
    v24 = 1412;
    v45 = &this->m_aSupportRatios[1];
    p_z = &this->m_aGroundOffsets[0].z;
    p_m_nFlags = &this->m_nFlags;
    v47 = &pEntity->m_nFlags;
    v25 = 0;
    v26 = 0;
    v50 = 0;
    do
    {
      v27 = aLineRatios[v23];
      if ( v27 < 1.0 )
      {
        v28 = (char *)v22 + v23 * 4;
        v29 = &v22->m_aWheelRatios[v23];
        if ( v27 < *v29 )
        {
          v30 = (float *)((char *)v22 + v26 * 44);
          *v29 = v27;
          v31 = &v22->m_aWheelColPoints[v26];
          CColPoint::operator=(v31, &v53[v26]);
          v22 = this;
          v21 = pEntity;
          *((_BYTE *)&this->_vptr$CPlaceable + v24) = *((_BYTE *)v30 + 1885);
          v32 = *(_BYTE *)&pEntity->m_info & 7;
          v33 = v32 == 4;
          ++v50;
          if ( v32 != 4 )
            v33 = v32 == 2;
          if ( v33 )
          {
            *((_DWORD *)v28 + 575) = pEntity;
            CEntity::RegisterReference(pEntity, (CEntity **)&p_z[v23 - 6]);
            v22 = this;
            v21 = pEntity;
            v34 = pEntity->m_pMat;
            p_tx = (CSimpleTransform *)&v34->tx;
            if ( !v34 )
              p_tx = &pEntity->m_transform;
            v36 = v30[463] - p_tx->m_translate.y;
            v37 = &p_z[v25 / 4];
            v38 = v30[464] - p_tx->m_translate.z;
            *(v37 - 2) = v31->m_vecPosition.x - p_tx->m_translate.x;
            this->m_aGroundOffsets[v25 / 0xC].y = v36;
            *v37 = v38;
          }
          v22->m_LastMaterialToHaveBeenStandingOn = *((_BYTE *)v30 + 1883);
          if ( (*(_BYTE *)&v21->m_info & 7) == 1 )
          {
            v22->pEntityWeAreOnForVisibilityCheck = v21;
            v39 = *p_m_nFlags;
            v40 = *(_DWORD *)p_m_nFlags & 0xBFFFFFFF | (((*(_DWORD *)v47 >> 30) & 1) << 30);
            *(_DWORD *)p_m_nFlags = v40;
            this->m_nFlags.bdummy = v39.bdummy;
            *(_DWORD *)p_m_nFlags = v40 & 0x7FFFFFFF | ((*(_DWORD *)v47 < 0) << 31);
            this->m_nFlags.bdummy = v39.bdummy;
          }
        }
      }
      ++v26;
      ++v24;
      ++v23;
      v25 += 12;
    }
    while ( v26 != 4 );
    if ( v58 >= 1.0 || v58 >= v22->m_aSupportRatios[0] )
    {
      v20 = v46;
      v41 = v50;
    }
    else
    {
      v22->m_aSupportRatios[0] = v58;
      CColPoint::operator=(v22->m_aSupportColPoints, &v54);
      v21 = pEntity;
      v22 = this;
      v20 = v46;
      v41 = v50 + 1;
    }
    if ( v59 < 1.0 && v59 < *v45 )
    {
      *v45 = v59;
      CColPoint::operator=(&v22->m_aSupportColPoints[1], &v55);
      v22 = this;
      v21 = pEntity;
      ++v41;
    }
  }
  else
  {
    v41 = 0;
    m_pColData->_anon_0.m_nNoOfLines = 6;
    v22 = this;
  }
  v42 = v20 < 0;
  if ( v20 <= 0 )
    v42 = v41 < 1;
  if ( !v42 )
  {
    CPhysical::AddCollisionRecord(v22, v21);
    v43 = pEntity;
    if ( (*(_BYTE *)&pEntity->m_info & 7) != 1 )
    {
      CPhysical::AddCollisionRecord((CPhysical *)pEntity, this);
      v43 = pEntity;
    }
    if ( v20 >= 1 )
    {
      v44 = *(_BYTE *)&v43->m_info & 7;
      if ( v44 == 1 || v44 == 4 && (LOBYTE(v43[1].m_transform.m_translate.y) & 4) != 0 )
        *(_DWORD *)&this->m_nFlags |= 0x1000u;
    }
  }
  return v20;
}

//----- (0057C480) --------------------------------------------------------
uint8 __fastcall CTrainNode::GetLightingFromCollision(CTrainNode *this)
{
  uint8 result; // r0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-44h] BYREF
  CColPoint colPoint; // [sp+20h] [bp-40h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-14h] BYREF

  if ( this->bLightingHasBeenCalculated )
    return this->lighting;
  vecStart.x = (float)this->CoorX * 0.125;
  vecStart.y = (float)this->CoorY * 0.125;
  vecStart.z = (float)((float)this->CoorZ * 0.125) + 1.0;
  if ( !CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
    return 72;
  result = colPoint.m_dataB.m_lighting;
  this->bLightingHasBeenCalculated = 1;
  this->lighting = result;
  return result;
}

//----- (0057C510) --------------------------------------------------------
void __fastcall CTrain::CTrain(CTrain *this, int nModelIndex, UInt8 CreatedBy)
{
  CBaseModelInfo *v5; // r9
  char *v6; // r0
  RpClump_0 *m_pRwObject; // r0
  int m_nModelIndex; // r0
  float v9; // s8
  float v10; // s4
  float v11; // s0
  char v12; // r0
  int m_nFlags; // r1
  char v14; // r3
  char v15; // r0
  uint32 bdummy; // r2
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  uint32 v18; // r0
  tHandlingData *pHandling; // r0
  __int64 v20; // d16
  float fDragCoeff; // s0
  CPhysical::CPhysicalFlags v22; // r0

  CVehicle::CVehicle(this, CreatedBy);
  this->_vptr$CPlaceable = (int (**)(void))&off_66E0FC;
  memset(this->Door, 0, sizeof(this->Door));
  v5 = CModelInfo::ms_modelInfoPtrs[nModelIndex];
  this->m_baseVehicleType = 6;
  this->m_vehicleType = 6;
  v6 = (char *)&mod_HandlingManager + 224 * *((unsigned __int8 *)&v5[1].m_flags + 2);
  this->pHandling = (tHandlingData *)(v6 + 20);
  this->hFlagsLocal = *((_DWORD *)v6 + 57);
  CVehicle::SetModelIndex(this, nModelIndex);
  *(_QWORD *)&this->m_aTrainNodes[12] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[14] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[8] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[10] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[4] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[6] = 0LL;
  *(_QWORD *)this->m_aTrainNodes = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[2] = 0LL;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  this->m_aTrainNodes[16] = 0;
  CClumpModelInfo::FillFrameArray(m_pRwObject, this->m_aTrainNodes);
  this->Door[2].m_nAxis = 2;
  this->Door[2].m_nDirn = 20;
  this->Door[3].m_nAxis = 2;
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  this->Door[3].m_nDirn = 20;
  v9 = -1.2566;
  if ( m_nModelIndex == 570 )
    v9 = 1.25;
  this->m_PassengersMode = 0;
  v10 = 0.0;
  if ( m_nModelIndex == 570 )
    v10 = 0.25;
  v11 = 1.2566;
  if ( m_nModelIndex == 570 )
    v11 = 1.25;
  this->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&this->m_nTrainFlags & 0xF858 | 0x281);
  this->Door[2].m_fOpenAngle = v9;
  this->Door[2].m_fClosedAngle = v10;
  this->Door[3].m_fOpenAngle = v11;
  this->Door[3].m_fClosedAngle = v10;
  *((_BYTE *)this + 1503) = rand() & 3 | *((_BYTE *)this + 1503) & 0xF0;
  v12 = rand();
  m_nFlags = (int)this->m_nFlags;
  v14 = *((_BYTE *)this + 1503);
  this->m_nMaxPassengers = 5;
  v15 = (16 * (v12 & 3) + 16) | v14 & 0xF;
  bdummy = this->m_nFlags.bdummy;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  this->m_pRandomPedForTrain = 0;
  *((_BYTE *)this + 1503) = v15;
  v18 = CTimer::m_snTimeInMilliseconds;
  *(_DWORD *)&this->m_nFlags = m_nFlags | 1;
  this->m_nFlags.bdummy = bdummy;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x20000);
  this->DoorState = 0;
  this->m_nDoorTimer = v18;
  this->TrainType = 0;
  this->LinearSpeed = 0.0;
  this->PositionOnTrack = 0.0;
  this->m_StopAtStationTimer = 0;
  CVehicleModelInfo::ChooseVehicleColour(
    (CVehicleModelInfo *)v5,
    &this->m_colour1,
    &this->m_colour2,
    &this->m_colour3,
    &this->m_colour4,
    1);
  pHandling = this->pHandling;
  this->m_fMass = pHandling->fMass;
  this->m_fTurnMass = pHandling->fTurnMass;
  v20 = *(_QWORD *)&pHandling->CentreOfMass.x;
  this->m_vecCOM.z = pHandling->CentreOfMass.z;
  this->m_fElasticity = 0.05;
  *(_QWORD *)&this->m_vecCOM.x = v20;
  this->m_fBuoyancyConstant = pHandling->fBuoyancyConstant;
  fDragCoeff = pHandling->fDragCoeff;
  if ( fDragCoeff > 0.01 )
    fDragCoeff = (float)(fDragCoeff * 0.5) / 1000.0;
  v22 = this->m_nPhysicalFlags;
  this->m_fAirResistance = fDragCoeff;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v22 & 0xFFFFFFF3 | 4);
  *(_DWORD *)&this->m_nFlags |= 0x80000000;
  this->pLinkedToForward = 0;
  this->pLinkedToBackward = 0;
  this->AutoPilot.ActualSpeed = 0.0;
  *(CEntity::CEntityInfo *)&v22 = this->m_info;
  this->AutoPilot.CruiseSpeed = 0;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v22 & 7 | 0x30);
  CAEVehicleAudioEntity::Initialise(&this->m_VehicleAudioEntity, this);
}
// 66E0FC: using guessed type void *;

//----- (0057C774) --------------------------------------------------------
void __fastcall CTrain::~CTrain(CTrain *this)
{
  this->_vptr$CPlaceable = (int (**)(void))&off_66E0FC;
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  sub_195C74(this);
}
// 66E0FC: using guessed type void *off_66E0FC;

//----- (0057C79C) --------------------------------------------------------
void __fastcall CTrain::~CTrain(CTrain *this)
{
  void *v2; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_66E0FC;
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CVehicle::~CVehicle(this);
  sub_199F98(v2);
}
// 57C7BE: variable 'v2' is possibly undefined
// 66E0FC: using guessed type void *off_66E0FC;

//----- (0057C7C8) --------------------------------------------------------
void __fastcall CTrain::SetModelIndex(CTrain *this, uint32 index)
{
  RpClump_0 *m_pRwObject; // r0

  CVehicle::SetModelIndex(this, index);
  this->m_aTrainNodes[16] = 0;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aTrainNodes[12] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[14] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[8] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[10] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[4] = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[6] = 0LL;
  *(_QWORD *)this->m_aTrainNodes = 0LL;
  *(_QWORD *)&this->m_aTrainNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aTrainNodes);
}

//----- (0057C808) --------------------------------------------------------
bool __fastcall CTrain::IsInTunnel(CTrain *this)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r12
  CEntity *refEntityPtr; // [sp+20h] [bp-38h] BYREF
  CColPoint colPoint; // [sp+24h] [bp-34h] BYREF

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  return CWorld::ProcessVerticalLine(
           &p_tx->m_translate,
           p_tx->m_translate.z + 100.0,
           &colPoint,
           &refEntityPtr,
           1,
           0,
           0,
           0,
           0,
           0,
           0);
}

//----- (0057C850) --------------------------------------------------------
void __fastcall CTrain::PreRender(CTrain *this)
{
  CTrain::CTrainFlags m_nTrainFlags; // r0
  CMatrix *m_pMat; // r1
  CTrain *v4; // r0
  uint32 v5; // r2

  CVehicle::PreRender(this);
  m_nTrainFlags = this->m_nTrainFlags;
  if ( (*(_BYTE *)&m_nTrainFlags & 8) != 0 )
  {
    m_pMat = this->m_pMat;
    v4 = this;
    if ( this->m_nModelIndex == 449 )
      v5 = 5;
    else
      v5 = 37;
  }
  else
  {
    if ( (*(_BYTE *)&m_nTrainFlags & 0x10) == 0 )
      return;
    m_pMat = this->m_pMat;
    v4 = this;
    v5 = 21;
  }
  sub_19B3C8(v4, m_pMat, v5);
}

//----- (0057C898) --------------------------------------------------------
void __fastcall CTrain::ReadAndInterpretTrackFile(
        unsigned __int8 *pFileName,
        CTrainNode **ppTrackNodes,
        Int32 *pNumTrackNodes,
        float *pTotalLengthOfTrack,
        Int32 TrackType)
{
  int16x4_t v5; // d16
  int16x4_t v6; // d17
  uint8 *v10; // r4
  int v11; // r1
  int v12; // r5
  int v13; // r2
  int v14; // r2
  int v15; // r1
  Int32 v16; // r6
  __int64 v17; // r0
  CTrainNode *v18; // r0
  bool *p_bLightingHasBeenCalculated; // r1
  int v20; // r2
  Int32 v21; // r10
  int v22; // r11
  int v23; // r0
  unsigned __int8 *v24; // r1
  float v25; // s0
  int v26; // r2
  float v27; // r0
  CVector *v28; // r1
  float v29; // s16
  CTrainNode *v30; // r0
  Int32 v31; // r4
  int v32; // r6
  char *v33; // r2
  unsigned __int64 v34; // d0
  int v36; // [sp+20h] [bp-48h] BYREF
  float v37; // [sp+24h] [bp-44h] BYREF
  float v38; // [sp+28h] [bp-40h] BYREF
  RwReal v39; // [sp+2Ch] [bp-3Ch] BYREF

  if ( !*ppTrackNodes )
  {
    v10 = (uint8 *)operator new[](0xB530u);
    CFileMgr::LoadFile(pFileName, v10, 46384, (const unsigned __int8 *)&dword_57CAFC);
    v11 = *v10;
    if ( v11 == 10 )
    {
      v12 = 1;
      v13 = 0;
    }
    else
    {
      v13 = 0;
      do
      {
        gString[v13] = v11;
        v11 = v10[++v13];
      }
      while ( v11 != 10 );
      v12 = v13 + 1;
    }
    gString[v13] = 0;
    if ( !strcmp("processed", (const char *)gString) )
    {
      v14 = v10[v12];
      if ( v14 == 10 )
      {
        v15 = 0;
      }
      else
      {
        v15 = 0;
        do
        {
          gString[v15] = v14;
          v14 = v10[v12 + 1 + v15++];
        }
        while ( v14 != 10 );
        v12 += v15;
      }
      ++v12;
      gString[v15] = 0;
    }
    sscanf((const char *)gString, (const char *)&dword_57CB20, pNumTrackNodes);
    v16 = *pNumTrackNodes;
    v17 = 10LL * (unsigned int)*pNumTrackNodes;
    if ( !is_mul_ok(0xAu, *pNumTrackNodes) )
      HIDWORD(v17) = 1;
    if ( HIDWORD(v17) )
      LODWORD(v17) = -1;
    v18 = (CTrainNode *)operator new[](v17);
    if ( v16 )
    {
      p_bLightingHasBeenCalculated = &v18->bLightingHasBeenCalculated;
      v20 = 10 * v16;
      do
      {
        *p_bLightingHasBeenCalculated = 0;
        p_bLightingHasBeenCalculated += 10;
        v20 -= 10;
      }
      while ( v20 );
    }
    *ppTrackNodes = v18;
    if ( *pNumTrackNodes >= 1 )
    {
      v21 = 0;
      v22 = 0;
      do
      {
        v23 = v10[v12++];
        if ( v23 != 10 )
        {
          v24 = gString;
          do
          {
            *v24++ = v23;
            v23 = v10[v12++];
          }
          while ( v23 != 10 );
        }
        sscanf((const char *)gString, "%f %f %f %d", &v39, &v38, &v37, &v36);
        (*ppTrackNodes)[v21].CoorX = (int)(float)(v39 * 8.0);
        (*ppTrackNodes)[v21].CoorY = (int)(float)(v38 * 8.0);
        v25 = v37;
        (*ppTrackNodes)[v21].CoorZ = (int)(float)(v37 * 8.0);
        if ( !TrackType && v36 )
        {
          v26 = v22;
          v27 = v38;
          ++v22;
          CTrain::aStationCoors[v26].x = v39;
          v28 = &CTrain::aStationCoors[v26];
          v28->y = v27;
          v28->z = v25;
        }
        ++v21;
      }
      while ( v21 < *pNumTrackNodes );
    }
    operator delete[](v10);
  }
  v29 = 0.0;
  if ( *pNumTrackNodes >= 1 )
  {
    v30 = *ppTrackNodes;
    v31 = 0;
    v32 = 6;
    do
    {
      ++v31;
      *(Int16 *)((char *)&v30->CoorX + v32) = (unsigned int)(float)(v29 * 3.0);
      v30 = *ppTrackNodes;
      v33 = (char *)*ppTrackNodes + v32;
      v32 += 10;
      v5.n64_u32[0] = *(_DWORD *)(v33 - 6);
      v6.n64_u32[0] = *(_DWORD *)&(*ppTrackNodes)[v31 % *pNumTrackNodes].CoorX;
      v6.n64_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v6).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
      v5.n64_u64[0] = vsub_f32(
                        vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v5).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL),
                        v6).n64_u64[0];
      v34 = vmul_f32(v5, v5).n64_u64[0];
      v29 = v29 + sqrtf(*(float *)&v34 + *((float *)&v34 + 1));
    }
    while ( v31 < *pNumTrackNodes );
  }
  *pTotalLengthOfTrack = v29;
}
// 57CAC0: variable 'v6' is possibly undefined
// 57CAB4: variable 'v5' is possibly undefined
// 57CAFC: using guessed type int dword_57CAFC;
// 57CB20: using guessed type int dword_57CB20;

//----- (0057CB40) --------------------------------------------------------
void CTrain::InitTrains()
{
  Int32 v0; // r11
  unsigned __int64 v1; // d0
  float32x2_t v2; // d5
  int16x4_t v3; // d18
  int i; // r10
  float32x2_t v5; // d4
  CVector *v6; // r1
  float32x2_t v7; // d17
  float x; // s6
  Int32 v9; // r6
  Int16 *p_CoorY; // r1
  unsigned __int64 v11; // d6
  bool v12; // nf
  Int16 *v13; // r6
  Int32 v14; // r2
  unsigned __int64 v15; // d6
  Int32 v16; // r2
  Int16 *v17; // r6
  unsigned __int64 v18; // d6
  Int32 v19; // r6
  Int16 *v20; // r2
  unsigned __int64 v21; // d6
  float *v22; // r0
  unsigned __int32 v23; // [sp+2Ch] [bp-2Ch]
  unsigned __int32 v24; // [sp+30h] [bp-28h]
  unsigned __int32 v25; // [sp+34h] [bp-24h]
  unsigned __int32 v26; // [sp+38h] [bp-20h]

  CTrain::GenTrain_Status = 0;
  CTrain::bDisableRandomTrains = 0;
  if ( !pTrackNodes[0] )
    CTrain::ReadAndInterpretTrackFile("data\\paths\\tracks.dat", pTrackNodes, NumTrackNodes, TotalLengthOfTrack, 0);
  if ( !pTrackNodes[1] )
    CTrain::ReadAndInterpretTrackFile(
      "data\\paths\\tracks3.dat",
      &pTrackNodes[1],
      &NumTrackNodes[1],
      &TotalLengthOfTrack[1],
      1);
  if ( !pTrackNodes[2] )
    CTrain::ReadAndInterpretTrackFile(
      "data\\paths\\tracks2.dat",
      &pTrackNodes[2],
      &NumTrackNodes[2],
      &TotalLengthOfTrack[2],
      2);
  if ( !pTrackNodes[3] )
    CTrain::ReadAndInterpretTrackFile(
      "data\\paths\\tracks4.dat",
      &pTrackNodes[3],
      &NumTrackNodes[3],
      &TotalLengthOfTrack[3],
      3);
  LODWORD(v1) = 1203982323;
  for ( i = 0; i != 6; ++i )
  {
    v5.n64_u64[0] = v1;
    v6 = &CTrain::aStationCoors[i];
    v7.n64_u64[0] = *(unsigned __int64 *)&v6->y;
    x = v6->x;
    if ( NumTrackNodes[0] >= 1 )
    {
      v5.n64_u64[0] = v1;
      v9 = 0;
      p_CoorY = &pTrackNodes[0]->CoorY;
      do
      {
        v2.n64_f32[0] = (float)*(p_CoorY - 1);
        v26 = *(_DWORD *)p_CoorY;
        p_CoorY += 5;
        v3.n64_u32[0] = v26;
        v3.n64_u64[0] = vsub_f32(
                          v7,
                          vmul_f32(
                            vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                            (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
        v11 = vmul_f32(v3, v3).n64_u64[0];
        v2.n64_f32[0] = sqrtf(
                          (float)((float)((float)(x + (float)(v2.n64_f32[0] * -0.125))
                                        * (float)(x + (float)(v2.n64_f32[0] * -0.125)))
                                + *(float *)&v11)
                        + *((float *)&v11 + 1));
        v12 = v2.n64_f32[0] < v5.n64_f32[0];
        v5.n64_u64[0] = vmin_f32(v2, v5).n64_u64[0];
        if ( v12 )
          v0 = v9;
        ++v9;
      }
      while ( v9 < NumTrackNodes[0] );
    }
    if ( NumTrackNodes[1] >= 1 )
    {
      v13 = &pTrackNodes[1]->CoorY;
      v14 = 0;
      do
      {
        v2.n64_f32[0] = (float)*(v13 - 1);
        v25 = *(_DWORD *)v13;
        v13 += 5;
        v3.n64_u32[0] = v25;
        v3.n64_u64[0] = vsub_f32(
                          v7,
                          vmul_f32(
                            vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                            (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
        v15 = vmul_f32(v3, v3).n64_u64[0];
        v2.n64_f32[0] = sqrtf(
                          (float)((float)((float)(x + (float)(v2.n64_f32[0] * -0.125))
                                        * (float)(x + (float)(v2.n64_f32[0] * -0.125)))
                                + *(float *)&v15)
                        + *((float *)&v15 + 1));
        v12 = v2.n64_f32[0] < v5.n64_f32[0];
        v5.n64_u64[0] = vmin_f32(v2, v5).n64_u64[0];
        if ( v12 )
          v0 = v14;
        ++v14;
      }
      while ( v14 < NumTrackNodes[1] );
    }
    if ( NumTrackNodes[2] >= 1 )
    {
      v16 = 0;
      v17 = &pTrackNodes[2]->CoorY;
      do
      {
        v2.n64_f32[0] = (float)*(v17 - 1);
        v24 = *(_DWORD *)v17;
        v17 += 5;
        v3.n64_u32[0] = v24;
        v3.n64_u64[0] = vsub_f32(
                          v7,
                          vmul_f32(
                            vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                            (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
        v18 = vmul_f32(v3, v3).n64_u64[0];
        v2.n64_f32[0] = sqrtf(
                          (float)((float)((float)(x + (float)(v2.n64_f32[0] * -0.125))
                                        * (float)(x + (float)(v2.n64_f32[0] * -0.125)))
                                + *(float *)&v18)
                        + *((float *)&v18 + 1));
        v12 = v2.n64_f32[0] < v5.n64_f32[0];
        v5.n64_u64[0] = vmin_f32(v2, v5).n64_u64[0];
        if ( v12 )
          v0 = v16;
        ++v16;
      }
      while ( v16 < NumTrackNodes[2] );
    }
    if ( NumTrackNodes[3] >= 1 )
    {
      v19 = 0;
      v20 = &pTrackNodes[3]->CoorY;
      do
      {
        v2.n64_f32[0] = (float)*(v20 - 1);
        v23 = *(_DWORD *)v20;
        v20 += 5;
        v3.n64_u32[0] = v23;
        v3.n64_u64[0] = vsub_f32(
                          v7,
                          vmul_f32(
                            vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                            (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
        v21 = vmul_f32(v3, v3).n64_u64[0];
        v2.n64_f32[0] = sqrtf(
                          (float)((float)((float)(x + (float)(v2.n64_f32[0] * -0.125))
                                        * (float)(x + (float)(v2.n64_f32[0] * -0.125)))
                                + *(float *)&v21)
                        + *((float *)&v21 + 1));
        v12 = v2.n64_f32[0] < v5.n64_f32[0];
        v5.n64_u64[0] = vmin_f32(v2, v5).n64_u64[0];
        if ( v12 )
          v0 = v19;
        ++v19;
      }
      while ( v19 < NumTrackNodes[3] );
    }
    v22 = &StationDist[i];
    *v22 = (float)pTrackNodes[0][v0].LengthFromStart / 3.0;
  }
}
// 57CC86: variable 'v1' is possibly undefined
// 57CCC4: variable 'v3' is possibly undefined
// 57CCF8: variable 'v2' is possibly undefined
// 57CE46: variable 'v0' is possibly undefined
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];

//----- (0057CF4C) --------------------------------------------------------
int (**__fastcall CTrain::FindClosestTrackNode(CVector Coors, Int32 *pTrackType))[4]
{
  float x; // s4
  float v3; // s6
  float z; // s0
  Int32 v5; // r10
  int (**result)[4]; // r0
  int v7; // r9
  int v8; // r5
  int (**i)[4]; // r6
  int v10; // r4
  float v11; // s10

  x = Coors.x;
  v3 = 100000.0;
  z = Coors.z;
  v5 = 0;
  result = &NumTrackNodes_ptr;
  do
  {
    v7 = NumTrackNodes[v5];
    if ( v7 >= 1 )
    {
      v8 = 0;
      for ( i = 0; (int)i < v7; i = (int (**)[4])((char *)i + 1) )
      {
        LODWORD(Coors.z) = pTrackNodes[v5];
        v10 = *(__int16 *)(LODWORD(Coors.z) + v8);
        LODWORD(Coors.z) += v8;
        v8 += 10;
        v11 = sqrtf(
                (float)((float)((float)(x - (float)((float)v10 * 0.125)) * (float)(x - (float)((float)v10 * 0.125)))
                      + (float)((float)(Coors.y - (float)((float)*(__int16 *)(LODWORD(Coors.z) + 2) * 0.125))
                              * (float)(Coors.y - (float)((float)*(__int16 *)(LODWORD(Coors.z) + 2) * 0.125))))
              + (float)((float)(z - (float)((float)*(__int16 *)(LODWORD(Coors.z) + 4) * 0.125))
                      * (float)(z - (float)((float)*(__int16 *)(LODWORD(Coors.z) + 4) * 0.125))));
        if ( v11 < v3 )
        {
          *pTrackType = v5;
          v7 = NumTrackNodes[v5];
          result = i;
          v3 = v11;
        }
      }
    }
    ++v5;
  }
  while ( v5 != 4 );
  return result;
}
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];

//----- (0057D02C) --------------------------------------------------------
void CTrain::Shutdown()
{
  if ( pTrackNodes[0] )
    operator delete[](pTrackNodes[0]);
  pTrackNodes[0] = 0;
  if ( pTrackNodes[1] )
    operator delete[](pTrackNodes[1]);
  pTrackNodes[1] = 0;
  if ( pTrackNodes[2] )
    operator delete[](pTrackNodes[2]);
  pTrackNodes[2] = 0;
  if ( pTrackNodes[3] )
    operator delete[](pTrackNodes[3]);
  pTrackNodes[3] = 0;
}

//----- (0057D0A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTrain::ProcessControl(CTrain *this)
{
  float32x2_t v1; // d0
  float32x2_t d1_0; // d1
  float32x4_t v3; // q1
  float32x2_t v4; // d7
  float32x2_t v5; // d12
  float32x2_t v6; // d13
  float32x2_t v7; // d14
  CAEVehicleAudioEntity *p_m_VehicleAudioEntity; // r11
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r4
  float x; // s16
  float y; // s20
  float z; // s18
  float m_heading; // s22
  CTrain::CTrainFlags m_nTrainFlags; // r5
  int TrainType; // r3
  CTrainNode *v18; // r10
  CSimpleTransform *Accelerate; // r6
  float v20; // s24
  CTrain *pLinkedToForward; // r0
  float *v22; // r3
  float v23; // s10
  float32x4_t v24; // q9
  unsigned int v25; // r0
  float v26; // s0
  float v27; // s14
  float *v28; // r1
  float *v29; // r2
  CEntity *m_pDamageEntity; // r0
  float v31; // s16
  float v32; // s0
  float v33; // s18
  RwReal v34; // s20
  float v35; // r0
  CPad *Pad; // r5
  CPed *pDriver; // r0
  int v38; // r11
  CTrain *v39; // r0
  CTrain::CTrainFlags v40; // r2
  int v41; // r1
  float LinearSpeed; // s26
  int v43; // r0
  unsigned int v44; // r3
  uint32 v45; // r6
  CTrain *v46; // r1
  CTrain::CTrainFlags v47; // r2
  CTrain *v48; // r3
  float v49; // s26
  float v50; // r0
  float PositionOnTrack; // s4
  float v52; // s0
  int m_PassengersMode; // r0
  char v54; // r0
  int v55; // r0
  int v56; // s0
  float *p_Gas; // r0
  float v58; // s0
  CMatrix *v59; // r0
  CSimpleTransform *v60; // r2
  __int64 v61; // kr00_8 OVERLAPPED
  CMatrix *v62; // r4
  float xy; // s2
  float yy; // s4
  float zy; // s0
  CTrain *pLinkedToBackward; // r1
  CTrain::CTrainFlags v67; // r2
  CTrain *v68; // r3
  uint8 v69; // r0
  float v70; // r5
  float v71; // r6
  int v72; // r1
  int v73; // r2
  float v74; // s0
  float Gas; // s2
  bool v76; // zf
  CSimpleTransform *v77; // r2
  RwReal v78; // r3
  RwReal v79; // r5
  RwReal v80; // r6
  float *p_LinearSpeed; // r4
  float v82; // s26
  float v83; // s2
  float v84; // s28
  float Brake; // s4
  float v86; // s0
  float v87; // s2
  float v88; // s0
  unsigned int m_info; // r1
  CPad *v90; // r0
  CMatrix *v91; // r0
  __int64 v92; // r2
  float v93; // s0
  int v94; // r0
  int v95; // r1
  int v96; // r2
  int v97; // r0
  int v98; // r3
  CTrainNode *v99; // r0
  int v100; // r6
  int v101; // r5
  int v102; // r0
  int v103; // s2
  bool v104; // cc
  int v105; // r2
  CTrainNode *v106; // r3
  RwReal v107; // s4
  RwReal v108; // s6
  int v109; // r1
  CTrainNode *v110; // r2
  int v111; // r1
  int v112; // r6
  int v113; // r2
  int v114; // s8
  float v115; // s12
  CTrain *v116; // r8
  CMatrix *v117; // r1
  const CVector *p_m_translate; // r0
  _BOOL4 v119; // r0
  CTrain *v120; // r5
  int (**v121)(void); // r1
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r2
  CTrain *v123; // r1
  CTrain::CTrainFlags v124; // r2
  CTrain *v125; // r3
  char v126; // r0
  float *p_PositionOnTrack; // r4
  float v128; // s0
  int CurrentNode; // r5
  float v130; // s4
  int v131; // r2
  unsigned __int16 v132; // r1
  int v133; // r3
  unsigned int LengthFromStart; // r0
  int *v135; // r2
  float v136; // s12
  int i; // r2
  int v138; // r0
  int v139; // r2
  CTrainNode *v140; // r3
  int CoorY; // r12
  int CoorZ; // lr
  int v143; // r3
  CColModel *m_pColModel; // r1
  int CoorX; // r8
  CTrainNode *v146; // r3
  float v147; // s2
  float v148; // s6
  float v149; // s10
  float v150; // s1
  float v151; // s3
  unsigned __int16 v152; // r1
  int v153; // r2
  float32x2_t v154; // d1
  float v155; // s23
  float32x2_t v156; // d0
  float v157; // s8
  float v158; // s10
  float v159; // s14
  float v160; // s17
  CSimpleTransform *v161; // r8
  float v162; // s21
  float v163; // s19
  Int16 v164; // r6
  __int16 v165; // r3
  __int16 v166; // r2
  CTrainNode *v167; // r0
  float v168; // s2
  CTrainNode *v169; // r4
  float v170; // s0
  float v171; // s2
  float v172; // s0
  float v173; // s24
  float v174; // s0
  float v175; // s2
  float v176; // s4
  CTrainNode *v177; // r4
  unsigned int lighting; // r0
  CTrainNode *v179; // r0
  float v180; // s0
  CTrainNode *v181; // r4
  float v182; // s19
  unsigned int m_lighting; // r0
  CSimpleTransform *p_tx; // r1
  float v185; // s30
  CMatrix *v186; // r0
  float v187; // s0
  float v188; // s0
  float v189; // s0
  float v190; // s2
  int v191; // r1
  float32x2_t v192; // d16
  float32x2_t v193; // d17
  float32x2_t v194; // d18
  RwReal v195; // s0
  RwReal v196; // s2
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *v199; // r0
  RwMatrix *v200; // r1
  CMatrix *v201; // r0
  char v202; // r1
  float v203; // s6
  RwReal v204; // s2
  RwReal v205; // s4
  RwReal vecOffset; // [sp+0h] [bp-F8h] OVERLAPPED
  RwReal vecOffseta; // [sp+0h] [bp-F8h]
  RwReal vecOffset_4; // [sp+4h] [bp-F4h]
  RwReal vecOffset_4a; // [sp+4h] [bp-F4h]
  Int16 *p_CoorY; // [sp+20h] [bp-D8h]
  CAEVehicleAudioEntity *v211; // [sp+24h] [bp-D4h]
  Int16 *p_CoorZ; // [sp+24h] [bp-D4h]
  __int16 v213; // [sp+28h] [bp-D0h]
  CTrainNode *v214; // [sp+28h] [bp-D0h]
  int v215; // [sp+2Ch] [bp-CCh]
  CVector m_vecPosition; // [sp+30h] [bp-C8h] BYREF
  CVector refEntityPtr; // [sp+3Ch] [bp-BCh] BYREF
  CVector v2; // [sp+48h] [bp-B0h] BYREF
  CEntity *v219; // [sp+58h] [bp-A0h] BYREF
  CVector vecStart; // [sp+5Ch] [bp-9Ch] BYREF
  CColPoint pCentreOfBuoyancy[3]; // [sp+68h] [bp-90h] BYREF
  CVector v222; // 0:r0.12
  CVector v223; // 0:r1.12

  p_m_VehicleAudioEntity = &this->m_VehicleAudioEntity;
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x2000u;
  CAEVehicleAudioEntity::Service(&this->m_VehicleAudioEntity);
  if ( gbModelViewer )
    return;
  m_pMat = this->m_pMat;
  p_m_transform = &this->m_transform;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  x = p_m_transform->m_translate.x;
  y = p_m_transform->m_translate.y;
  z = p_m_transform->m_translate.z;
  if ( m_pMat )
    m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
  else
    m_heading = this->m_transform.m_heading;
  m_nTrainFlags = this->m_nTrainFlags;
  if ( (*(_WORD *)&m_nTrainFlags & 0x100) == 0 )
  {
    TrainType = this->TrainType;
    v18 = pTrackNodes[TrainType];
    Accelerate = (CSimpleTransform *)NumTrackNodes[TrainType];
    v20 = TotalLengthOfTrack[TrainType];
    if ( (*(_BYTE *)&m_nTrainFlags & 8) == 0 )
    {
      pLinkedToForward = this->pLinkedToForward;
      if ( pLinkedToForward )
      {
        this->LinearSpeed = pLinkedToForward->LinearSpeed;
        this->PositionOnTrack = pLinkedToForward->PositionOnTrack + this->OffsetFromLeader;
      }
      else
      {
        v49 = CTimer::ms_fTimeStep;
        v50 = powf(0.99, CTimer::ms_fTimeStep);
        PositionOnTrack = this->PositionOnTrack;
        v52 = v50 * this->LinearSpeed;
        this->LinearSpeed = v52;
        this->PositionOnTrack = PositionOnTrack + (float)(v49 * v52);
      }
      if ( (*(_BYTE *)&m_nTrainFlags & 0xB) != 3 || (*(_BYTE *)&m_nTrainFlags & 0x20) != 0 || this->m_nModelIndex != 570 )
        goto LABEL_146;
      m_PassengersMode = this->m_PassengersMode;
      if ( m_PassengersMode != 1 )
      {
        if ( this->m_PassengersMode )
          goto LABEL_135;
        if ( FindPlayerPed(-1)->m_pMyVehicle == this )
          v54 = *((_BYTE *)this + 1503) & 0xF0;
        else
          v54 = ((rand() & 3) + 1) | *((_BYTE *)this + 1503) & 0xF0;
        *((_BYTE *)this + 1503) = v54;
        this->m_PassengersMode = 1;
      }
      CTrain::RemoveRandomPassenger(this);
      if ( !(*((unsigned __int8 *)this + 1503) << 28) )
      {
        this->m_PassengersMode = 2;
        goto LABEL_139;
      }
      m_PassengersMode = this->m_PassengersMode;
LABEL_135:
      if ( m_PassengersMode == 3 )
        goto LABEL_143;
      if ( m_PassengersMode != 2 )
      {
LABEL_146:
        p_PositionOnTrack = &this->PositionOnTrack;
        v128 = this->PositionOnTrack;
        if ( v128 < 0.0 )
        {
          do
            v128 = v20 + v128;
          while ( v128 < 0.0 );
          *p_PositionOnTrack = v128;
        }
        if ( v128 >= v20 )
        {
          do
            v128 = v128 - v20;
          while ( v128 >= v20 );
          *p_PositionOnTrack = v128;
        }
        CurrentNode = this->CurrentNode;
        v130 = v20;
        v131 = 0;
        v132 = 0;
        v133 = (unsigned __int16)(CurrentNode + 1);
        LengthFromStart = v18[CurrentNode].LengthFromStart;
        if ( (__int16)Accelerate > v133 )
        {
          v132 = CurrentNode + 1;
          v130 = (float)v18[v133].LengthFromStart / 3.0;
        }
        if ( v128 >= (float)((float)v18[CurrentNode].LengthFromStart / 3.0) )
          goto LABEL_179;
        v131 = 1;
        do
        {
          while ( 1 )
          {
            v138 = v131 << 31 ? (unsigned __int16)CurrentNode - 1 : (unsigned __int16)CurrentNode + 1;
            this->CurrentNode = v138 % (__int16)Accelerate;
            CAEVehicleAudioEntity::AddAudioEvent(p_m_VehicleAudioEntity, 100, 0.0);
            CurrentNode = this->CurrentNode;
            v132 = CurrentNode + 1;
            v139 = (unsigned __int16)(CurrentNode + 1);
            LengthFromStart = v18[CurrentNode].LengthFromStart;
            if ( (__int16)Accelerate <= v139 )
            {
              v132 = 0;
              v130 = v20;
            }
            else
            {
              v130 = (float)v18[v139].LengthFromStart / 3.0;
            }
            v128 = *p_PositionOnTrack;
            v131 = 0;
            if ( *p_PositionOnTrack >= (float)((float)v18[CurrentNode].LengthFromStart / 3.0) )
              break;
            v131 = 1;
          }
LABEL_179:
          ;
        }
        while ( v128 > v130 );
        v140 = &v18[CurrentNode];
        CoorY = v140->CoorY;
        CoorZ = v140->CoorZ;
        v143 = v132;
        m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
        CoorX = v18[v143].CoorX;
        v146 = &v18[v143];
        v147 = (float)LengthFromStart / 3.0;
        v148 = (float)((float)v146->LengthFromStart / 3.0) - v147;
        if ( v148 < 0.0 )
          v148 = v20 + v148;
        v149 = (float)(v128 - v147) / v148;
        v150 = m_pColModel->m_boxBound.m_vecMin.y;
        v151 = m_pColModel->m_boxBound.m_vecMax.y;
        v152 = CurrentNode + 1;
        v156.n64_f32[1] = v151 - v150;
        v153 = (unsigned __int16)(CurrentNode + 1);
        v154.n64_f32[1] = 1.0 - v149;
        v155 = v128 + v156.n64_f32[1];
        v3.n128_f32[1] = (float)v18[CurrentNode].CoorX * 0.125;
        v156.n64_f32[0] = v149 * (float)((float)v146->CoorZ * 0.125);
        v3.n128_f32[0] = (float)(1.0 - v149) * (float)((float)CoorZ * 0.125);
        v3.n128_f32[2] = (float)((float)v146->CoorY * 0.125) * v149;
        v157 = (float)((float)CoorY * 0.125) * (float)(1.0 - v149);
        v158 = (float)((float)CoorX * 0.125) * v149;
        if ( v155 > v20 )
          v155 = v155 - v20;
        if ( (__int16)Accelerate <= v153 )
        {
          v152 = 0;
          v159 = v20;
        }
        else
        {
          v159 = (float)v18[v153].LengthFromStart / 3.0;
        }
        v160 = v156.n64_f32[0] + v3.n128_f32[0];
        v161 = &this->m_transform;
        v162 = v3.n128_f32[2] + v157;
        v163 = v158 + (float)(v3.n128_f32[1] * v154.n64_f32[1]);
        if ( v155 > v159 || v155 < v147 )
        {
          do
          {
            LOWORD(CurrentNode) = ((unsigned __int16)CurrentNode + 1) % (__int16)Accelerate;
            v167 = &v18[(unsigned __int16)CurrentNode];
            v152 = CurrentNode + 1;
            if ( (unsigned __int16)(CurrentNode + 1) >= (__int16)Accelerate )
            {
              v152 = 0;
              v168 = v20;
            }
            else
            {
              v168 = (float)v18[v152].LengthFromStart / 3.0;
            }
          }
          while ( v155 > v168 || v155 < (float)((float)v167->LengthFromStart / 3.0) );
          v164 = v18[(unsigned __int16)CurrentNode].CoorX;
          v165 = v167->CoorZ;
          v166 = v167->CoorY;
          LengthFromStart = v167->LengthFromStart;
        }
        else
        {
          v164 = v18[CurrentNode].CoorX;
          v165 = CoorZ;
          v166 = CoorY;
        }
        v215 = v152;
        v169 = &v18[v152];
        v170 = (float)LengthFromStart / 3.0;
        v171 = (float)((float)v169->LengthFromStart / 3.0) - v170;
        v172 = v155 - v170;
        if ( v171 < 0.0 )
          v171 = v20 + v171;
        v173 = v172 / v171;
        p_CoorY = &v169->CoorY;
        v214 = &v18[v152];
        p_CoorZ = &v169->CoorZ;
        v174 = (float)((float)((float)v214->CoorX * 0.125) * v173)
             + (float)((float)((float)v164 * 0.125) * (float)(1.0 - v173));
        v175 = (float)((float)((float)v169->CoorY * 0.125) * v173)
             + (float)((float)((float)v166 * 0.125) * (float)(1.0 - v173));
        v176 = (float)(v173 * (float)((float)v169->CoorZ * 0.125))
             + (float)((float)(1.0 - v173) * (float)((float)v165 * 0.125));
        this->m_pMat->tx = (float)(v163 + v174) * 0.5;
        this->m_pMat->ty = (float)(v162 + v175) * 0.5;
        this->m_pMat->tz = (float)(v160 + v176) * 0.5;
        this->m_pMat->tz = (float)(this->pHandling->fSuspensionLowerLimit
                                 - CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.z)
                         + this->m_pMat->tz;
        refEntityPtr.y = v175 - v162;
        refEntityPtr.x = v174 - v163;
        refEntityPtr.z = v176 - v160;
        CVector::Normalise(&refEntityPtr);
        if ( (*(_BYTE *)&this->m_nTrainFlags & 0x40) == 0 )
        {
          refEntityPtr.x = -refEntityPtr.x;
          refEntityPtr.y = -refEntityPtr.y;
          refEntityPtr.z = -refEntityPtr.z;
        }
        v2.x = 0.0;
        v2.y = 0.0;
        v2.z = 1.0;
        CrossProduct(&pCentreOfBuoyancy[0].m_vecPosition, &refEntityPtr, &v2);
        m_vecPosition = pCentreOfBuoyancy[0].m_vecPosition;
        CVector::Normalise(&m_vecPosition);
        CrossProduct(&pCentreOfBuoyancy[0].m_vecPosition, &m_vecPosition, &refEntityPtr);
        v2 = pCentreOfBuoyancy[0].m_vecPosition;
        *(CVector *)&this->m_pMat->xx = m_vecPosition;
        *(CVector *)&this->m_pMat->xz = v2;
        *(CVector *)&this->m_pMat->xy = refEntityPtr;
        v177 = &v18[(unsigned __int16)CurrentNode];
        if ( v177->bLightingHasBeenCalculated )
        {
          lighting = v177->lighting;
        }
        else
        {
          v179 = &v18[(unsigned __int16)CurrentNode];
          vecStart.x = (float)v179->CoorX * 0.125;
          vecStart.y = (float)v179->CoorY * 0.125;
          vecStart.z = (float)((float)v179->CoorZ * 0.125) + 1.0;
          if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, pCentreOfBuoyancy, &v219, 1, 0, 0, 0, 0, 0, 0) )
          {
            lighting = pCentreOfBuoyancy[0].m_dataB.m_lighting;
            v177->lighting = pCentreOfBuoyancy[0].m_dataB.m_lighting;
            v177->bLightingHasBeenCalculated = 1;
          }
          else
          {
            lighting = 72;
          }
        }
        v180 = CCustomBuildingDNPipeline::m_fDNBalanceParam;
        v181 = &v18[v215];
        v182 = (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                     * (float)((float)((float)(lighting >> 4) * 0.5) / 15.0))
             + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                     * (float)((float)((float)(lighting & 0xF) * 0.5) / 15.0));
        if ( v181->bLightingHasBeenCalculated )
        {
          m_lighting = v181->lighting;
        }
        else
        {
          vecStart.x = (float)v214->CoorX * 0.125;
          vecStart.y = (float)*p_CoorY * 0.125;
          vecStart.z = (float)((float)*p_CoorZ * 0.125) + 1.0;
          if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, pCentreOfBuoyancy, &v219, 1, 0, 0, 0, 0, 0, 0) )
          {
            m_lighting = pCentreOfBuoyancy[0].m_dataB.m_lighting;
            v181->lighting = pCentreOfBuoyancy[0].m_dataB.m_lighting;
            v181->bLightingHasBeenCalculated = 1;
          }
          else
          {
            m_lighting = 72;
          }
          v180 = CCustomBuildingDNPipeline::m_fDNBalanceParam;
        }
        p_tx = &this->m_transform;
        this->m_lightingFromCollision = v182
                                      + (float)(v173
                                              * (float)((float)((float)(v180
                                                                      * (float)((float)((float)(m_lighting >> 4) * 0.5)
                                                                              / 15.0))
                                                              + (float)((float)(1.0 - v180)
                                                                      * (float)((float)((float)(m_lighting & 0xF) * 0.5)
                                                                              / 15.0)))
                                                      - v182));
        v185 = CTimer::ms_fTimeStep;
        v186 = this->m_pMat;
        v187 = 1.0 / CTimer::ms_fTimeStep;
        if ( v186 )
          p_tx = (CSimpleTransform *)&v186->tx;
        v6.n64_f32[0] = (float)(p_tx->m_translate.x - x) * v187;
        v7.n64_f32[0] = (float)(p_tx->m_translate.y - y) * v187;
        v5.n64_f32[0] = (float)(p_tx->m_translate.z - z) * v187;
        this->m_vecMoveSpeed.x = v6.n64_f32[0];
        this->m_vecMoveSpeed.y = v7.n64_f32[0];
        this->m_vecMoveSpeed.z = v5.n64_f32[0];
        if ( v186 )
          v188 = atan2f(COERCE_FLOAT(LODWORD(v186->xy) ^ 0x80000000), v186->yy);
        else
          v188 = this->m_transform.m_heading;
        v189 = v188 - m_heading;
        if ( v189 <= 3.1416 )
        {
          if ( v189 >= -3.1416 )
          {
LABEL_230:
            v156.n64_f32[0] = v189 / v185;
            v191 = *((unsigned __int8 *)&this->m_nTrainFlags + 1);
            this->m_vecTurnSpeed.x = 0.0;
            this->m_vecTurnSpeed.y = 0.0;
            LODWORD(this->m_vecTurnSpeed.z) = v156.n64_u32[0];
            if ( v191 << 31 )
            {
              this->m_vecTurnSpeed.x = -0.0;
              this->m_vecTurnSpeed.y = -0.0;
              this->m_vecMoveSpeed.x = -v6.n64_f32[0];
              this->m_vecMoveSpeed.y = -v7.n64_f32[0];
              this->m_vecMoveSpeed.z = -v5.n64_f32[0];
              this->m_vecTurnSpeed.z = -v156.n64_f32[0];
              CPhysical::ApplyMoveSpeed(this);
              v195 = -this->m_vecTurnSpeed.y;
              v196 = -this->m_vecTurnSpeed.z;
              *(float32x4_t *)&this->m_vecMoveSpeed.x = vnegq_f32(*(float32x4_t *)&this->m_vecMoveSpeed.x);
              this->m_vecTurnSpeed.y = v195;
              this->m_vecTurnSpeed.z = v196;
              CPhysical::ProcessControl(this);
            }
            else
            {
              v154.n64_u32[0] = -2.0;
              v3.n128_u32[2] = -1110651699;
              v3.n128_u32[0] = 2.0;
              this->m_vecTurnSpeed.x = 0.0;
              this->m_vecTurnSpeed.y = 0.0;
              v192.n64_u64[0] = vmax_f32(v7, v154).n64_u64[0];
              v193.n64_u64[0] = vmax_f32(v6, v154).n64_u64[0];
              v194.n64_u64[0] = vmax_f32(v5, v154).n64_u64[0];
              v154.n64_u32[0] = 1036831949;
              LODWORD(this->m_vecMoveSpeed.x) = vmin_f32(v193, (float32x2_t)v3.n128_u64[0]).n64_u32[0];
              LODWORD(this->m_vecMoveSpeed.y) = vmin_f32(v192, (float32x2_t)v3.n128_u64[0]).n64_u32[0];
              LODWORD(this->m_vecMoveSpeed.z) = vmin_f32(v194, (float32x2_t)v3.n128_u64[0]).n64_u32[0];
              LODWORD(this->m_vecTurnSpeed.z) = vmin_f32(vmax_f32(v156, *(float32x2_t *)&v3.n128_i8[8]), v154).n64_u32[0];
            }
            m_pRwObject = this->m_pRwObject;
            if ( m_pRwObject )
            {
              parent = (char *)m_pRwObject->parent;
              v199 = this->m_pMat;
              v200 = (RwMatrix *)(parent + 16);
              if ( v199 )
                CMatrix::UpdateRwMatrix(v199, v200);
              else
                CSimpleTransform::UpdateRwMatrix(v161, v200);
            }
            CEntity::UpdateRwFrame(this);
            CPhysical::RemoveAndAdd(this);
            v201 = this->m_pMat;
            *(_DWORD *)&this->m_nFlags = *(_DWORD *)&this->m_nFlags & 0xFFFFFF8F | 0x20;
            if ( v201 )
              v161 = (CSimpleTransform *)&v201->tx;
            v202 = (char)this->m_nTrainFlags;
            this->m_fTrueDistanceTravelled = sqrtf(
                                               (float)((float)((float)(x - v161->m_translate.x)
                                                             * (float)(x - v161->m_translate.x))
                                                     + (float)((float)(y - v161->m_translate.y)
                                                             * (float)(y - v161->m_translate.y)))
                                             + (float)((float)(z - v161->m_translate.z)
                                                     * (float)(z - v161->m_translate.z)));
            if ( (v202 & 0x18) != 0 )
            {
              v203 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y;
              v204 = (float)((float)(v203 * v201->yy) + v161->m_translate.y)
                   + (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y);
              v205 = (float)((float)(v203 * v201->zy) + v161->m_translate.z)
                   + (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z);
              v222.x = (float)((float)(v203 * v201->xy) + v161->m_translate.x)
                     + (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x);
              v222.y = v204;
              v222.z = v205;
              MarkSurroundingEntitiesForCollisionWithTrain(v222, 3.0, this, 0);
            }
            if ( (*((_BYTE *)&this->m_nVehicleFlags + 1) & 0x20) == 0 )
              CCarCtrl::ScanForPedDanger(this);
            return;
          }
          v190 = 6.2832;
        }
        else
        {
          v190 = -6.2832;
        }
        v189 = v189 + v190;
        goto LABEL_230;
      }
LABEL_139:
      if ( FindPlayerPed(-1)->m_pMyVehicle == this )
        v126 = *((_BYTE *)this + 1503) & 0xF;
      else
        v126 = (16 * (rand() & 3) + 16) | *((_BYTE *)this + 1503) & 0xF;
      *((_BYTE *)this + 1503) = v126;
      this->m_PassengersMode = 3;
LABEL_143:
      if ( (*(_BYTE *)&this->m_nTrainFlags & 4) != 0 )
      {
        CTrain::AddNearbyPedAsRandomPassenger(this);
        if ( (*((_BYTE *)this + 1503) & 0xF) == *((unsigned __int8 *)this + 1503) >> 4 )
          this->m_PassengersMode = 4;
      }
      goto LABEL_146;
    }
    Pad = CPad::GetPad(0);
    pDriver = this->pDriver;
    v211 = p_m_VehicleAudioEntity;
    if ( pDriver && CPed::IsPlayer(pDriver) )
      Pad = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
    v38 = 2;
    v39 = this;
    do
    {
      v39 = v39->pLinkedToBackward;
      ++v38;
    }
    while ( v39 );
    v40 = this->m_nTrainFlags;
    v41 = *(_BYTE *)&v40 & 0x40;
    if ( (*(_BYTE *)&v40 & 0x40) == 0 )
      this->LinearSpeed = -this->LinearSpeed;
    v213 = (__int16)Accelerate;
    if ( *(_BYTE *)&this->m_info <= 7u )
    {
      LinearSpeed = this->LinearSpeed;
      if ( fabsf(LinearSpeed) < 0.001 )
      {
        this->Brake = 0.0;
        Accelerate = (CSimpleTransform *)CPad::GetAccelerate(Pad);
        v43 = (int)Accelerate - CPad::GetBrake(Pad);
        LOWORD(Accelerate) = v213;
LABEL_55:
        v56 = v43;
        p_Gas = &this->Gas;
        v58 = (float)v56;
LABEL_64:
        *p_Gas = v58;
        if ( (*((_BYTE *)&this->m_nTrainFlags + 1) & 2) != 0 )
        {
          v59 = this->m_pMat;
          v60 = &this->m_transform;
          if ( v59 )
            v60 = (CSimpleTransform *)&v59->tx;
          vecOffset = this->m_vecMoveSpeed.y;
          vecOffset_4 = this->m_vecMoveSpeed.z;
          v61 = *(_QWORD *)&this->m_vecMoveSpeed.x;
          if ( CGameLogic::CalcDistanceToForbiddenTrainCrossing(
                 v60->m_translate,
                 *(CVector *)(&vecOffset - 1),
                 1,
                 &pCentreOfBuoyancy[0].m_vecPosition) < 230.0 )
          {
            v62 = this->m_pMat;
            if ( v62 )
            {
              xy = v62->xy;
              yy = v62->yy;
              zy = v62->zy;
            }
            else
            {
              v70 = this->m_transform.m_heading;
              v71 = sinf(v70);
              yy = cosf(v70);
              zy = 0.0;
              LODWORD(xy) = LODWORD(v71) ^ 0x80000000;
            }
            v72 = 0;
            v73 = 0;
            v74 = (float)((float)(xy * pCentreOfBuoyancy[0].m_vecPosition.x)
                        + (float)(yy * pCentreOfBuoyancy[0].m_vecPosition.y))
                + (float)(zy * pCentreOfBuoyancy[0].m_vecPosition.z);
            Gas = this->Gas;
            if ( Gas > 0.0 )
              v72 = 1;
            if ( Gas < 0.0 )
              v73 = 1;
            if ( v74 > 0.0 )
              v73 = v72;
            v76 = v73 == 0;
            v77 = &this->m_transform;
            if ( !v76 )
              Gas = 0.0;
            v78 = this->m_vecMoveSpeed.x;
            v79 = this->m_vecMoveSpeed.y;
            v80 = this->m_vecMoveSpeed.z;
            this->Gas = Gas;
            if ( v62 )
              v77 = (CSimpleTransform *)&v62->tx;
            vecOffseta = v79;
            vecOffset_4a = v80;
            if ( CGameLogic::CalcDistanceToForbiddenTrainCrossing(
                   v77->m_translate,
                   *(CVector *)&v78,
                   0,
                   &pCentreOfBuoyancy[0].m_vecPosition) < 230.0 )
              this->Brake = 512.0;
          }
          LOWORD(Accelerate) = v213;
        }
        p_LinearSpeed = &this->LinearSpeed;
        v82 = CTimer::ms_fTimeStep;
        v83 = (float)v38;
        v84 = this->LinearSpeed
            + (float)((float)((float)((float)(this->Gas * 0.0039062) * CTimer::ms_fTimeStep) * 0.002) / (float)v38);
        Brake = this->Brake;
        this->LinearSpeed = v84;
        if ( Brake == 0.0 )
        {
          p_m_VehicleAudioEntity = v211;
        }
        else
        {
          p_m_VehicleAudioEntity = v211;
          v86 = (float)((float)((float)(Brake * 0.0039062) * v82) * 0.006) / v83;
          if ( fabsf(v84) >= v86 )
          {
            v87 = -v86;
            if ( v84 < 0.0 )
              v87 = v86;
            v84 = v84 + v87;
          }
          else
          {
            v84 = 0.0;
          }
          *p_LinearSpeed = v84;
        }
        v88 = powf(0.99975, v82) * v84;
        *p_LinearSpeed = v88;
        if ( (*(_BYTE *)&this->m_nTrainFlags & 0x40) == 0 )
        {
          v88 = -v88;
          *p_LinearSpeed = v88;
        }
        m_info = (unsigned __int8)this->m_info;
        this->PositionOnTrack = this->PositionOnTrack + (float)(v88 * v82);
        if ( m_info <= 7 )
        {
          if ( fabsf(v88) > 0.95 )
          {
            v90 = CPad::GetPad(0);
            CPad::StartShake(v90, 300, 0x46u, 0);
            Accelerate = &this->m_transform;
            v91 = this->m_pMat;
            if ( v91 )
              Accelerate = (CSimpleTransform *)&v91->tx;
            v92 = *(_QWORD *)&Accelerate->m_translate.x;
            v93 = Accelerate->m_translate.z;
            LOWORD(Accelerate) = v213;
            CCamera::CamShake(&TheCamera, 0.1, *(float *)&v92, *((float *)&v92 + 1), v93);
            v88 = *p_LinearSpeed;
          }
          if ( fabsf(v88) > 1.0 )
          {
            v94 = this->CurrentNode;
            v95 = (__int16)Accelerate;
            v96 = (__int16)Accelerate;
            if ( this->CurrentNode )
              v96 = v94 - 1;
            v97 = v94;
            v98 = v18[v97].CoorX;
            v99 = &v18[v97];
            v100 = v99->CoorY;
            v101 = v99->CoorZ;
            v102 = v96;
            v103 = v98;
            v104 = v96 < 1;
            v105 = v96 - 1;
            v106 = &v18[v102];
            v107 = (float)((float)v100 * 0.125) - (float)((float)v106->CoorY * 0.125);
            v108 = (float)((float)v101 * 0.125) - (float)((float)v106->CoorZ * 0.125);
            vecStart.x = (float)((float)v103 * 0.125) - (float)((float)v106->CoorX * 0.125);
            vecStart.y = v107;
            vecStart.z = v108;
            if ( v104 )
              v105 = v95;
            v109 = v105;
            v110 = &v18[v105];
            v111 = v18[v109].CoorX;
            v112 = v110->CoorY;
            v113 = v110->CoorZ;
            v114 = v18[v102].CoorX;
            v115 = (float)v106->CoorZ;
            v2.y = (float)((float)v106->CoorY * 0.125) - (float)((float)v112 * 0.125);
            v2.x = (float)((float)v114 * 0.125) - (float)((float)v111 * 0.125);
            v2.z = (float)(v115 * 0.125) - (float)((float)v113 * 0.125);
            CVector::Normalise(&vecStart);
            CVector::Normalise(&v2);
            if ( (float)((float)((float)(vecStart.x * v2.x) + (float)(vecStart.y * v2.y)) + (float)(vecStart.z * v2.z)) < 0.996 )
            {
              v116 = this;
              do
              {
                v117 = v116->m_pMat;
                p_m_translate = (const CVector *)&v117->tx;
                if ( !v117 )
                  p_m_translate = &v116->m_transform.m_translate;
                v119 = CWorld::ProcessVerticalLine(
                         p_m_translate,
                         p_m_translate->z + 100.0,
                         pCentreOfBuoyancy,
                         (CEntity **)&refEntityPtr,
                         1,
                         0,
                         0,
                         0,
                         0,
                         0,
                         0);
                if ( v119 )
                  break;
                v116 = v116->pLinkedToBackward;
              }
              while ( v116 );
              p_m_VehicleAudioEntity = v211;
              if ( !v119 )
              {
                v120 = this;
                do
                {
                  v121 = v120->_vptr$CPlaceable;
                  m_nPhysicalFlags = v120->m_nPhysicalFlags;
                  *(_WORD *)&v120->m_nTrainFlags |= 0x100u;
                  v120->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xFFFDFFFB);
                  ((void (__fastcall *)(CTrain *, _DWORD))v121[5])(v120, 0);
                  v120 = v120->pLinkedToBackward;
                }
                while ( v120 );
                CPhysical::ProcessControl(this);
              }
            }
            LOWORD(Accelerate) = v213;
          }
        }
        goto LABEL_146;
      }
      v55 = CPad::GetBrake(Pad);
      if ( LinearSpeed > 0.0 )
      {
        this->Brake = (float)v55;
        v43 = CPad::GetAccelerate(Pad);
        goto LABEL_55;
      }
      this->Gas = (float)-v55;
      v58 = (float)CPad::GetAccelerate(Pad);
LABEL_63:
      p_Gas = &this->Brake;
      goto LABEL_64;
    }
    v1.n64_f32[0] = (float)this->AutoPilot.CruiseSpeed;
    v44 = 10000;
    if ( (*(_WORD *)&v40 & 0x400) != 0 )
      v44 = 20000;
    v45 = CTimer::m_snTimeInMilliseconds - this->m_StopAtStationTimer;
    if ( v45 >= v44 )
    {
      if ( v45 >= v44 + 8000 )
      {
        if ( v45 < v44 + 12000 )
        {
          LOWORD(Accelerate) = v213;
          if ( (*(_BYTE *)&v40 & 2) != 0 )
          {
            this->m_PassengersMode = 4;
            pLinkedToBackward = this->pLinkedToBackward;
            this->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v40 & 0xFFFD);
            if ( pLinkedToBackward )
            {
              do
              {
                v67 = pLinkedToBackward->m_nTrainFlags;
                pLinkedToBackward->m_PassengersMode = 4;
                v68 = pLinkedToBackward->pLinkedToBackward;
                pLinkedToBackward->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v67 & 0xFFFD);
                pLinkedToBackward = v68;
              }
              while ( v68 );
            }
          }
          goto LABEL_59;
        }
        LOWORD(Accelerate) = v213;
        if ( (*(_BYTE *)&v40 & 0x80) != 0 )
        {
          if ( this->TrainType )
          {
            v3.n128_u32[0] = 1112014848;
          }
          else
          {
            d1_0.n64_u32[0] = 1176256512;
            v135 = dword_57E62C;
            if ( !v41 )
              v135 = &dword_57E62C[1];
            v136 = *(float *)v135;
            for ( i = 0; i != 6; ++i )
            {
              for ( v4.n64_f32[0] = v136 + (float)(StationDist[i] - this->PositionOnTrack);
                    v4.n64_f32[0] > (float)(TotalLengthOfTrack[0] * 0.5);
                    v4.n64_f32[0] = v4.n64_f32[0] - TotalLengthOfTrack[0] )
              {
                ;
              }
              while ( v4.n64_f32[0] < (float)(TotalLengthOfTrack[0] * -0.5) )
                v4.n64_f32[0] = TotalLengthOfTrack[0] + v4.n64_f32[0];
              LOWORD(Accelerate) = v213;
              if ( v41 )
              {
                if ( v4.n64_f32[0] > 0.0 )
                  d1_0.n64_u64[0] = vmin_f32(v4, d1_0).n64_u64[0];
              }
              else if ( v4.n64_f32[0] < 0.0 )
              {
                v4.n64_f32[0] = -v4.n64_f32[0];
                d1_0.n64_u64[0] = vmin_f32(d1_0, v4).n64_u64[0];
              }
            }
            if ( d1_0.n64_f32[0] >= 500.0 )
              v3.n128_u32[0] = 1203982336;
            else
              v3.n128_f32[0] = (float)(1.0 - (float)((float)(500.0 - d1_0.n64_f32[0]) / 500.0)) * 50.0;
            if ( d1_0.n64_f32[0] < 5.0 )
            {
              v1.n64_u32[0] = 0;
              this->m_StopAtStationTimer = CTimer::m_snTimeInMilliseconds;
              goto LABEL_59;
            }
          }
          v1.n64_u64[0] = vmin_f32((float32x2_t)v3.n128_u64[0], v1).n64_u64[0];
        }
LABEL_59:
        v1.n64_f32[0] = (float)(v1.n64_f32[0] / 50.0) - this->LinearSpeed;
        if ( v1.n64_f32[0] > 0.0 )
        {
          v3.n128_u32[0] = 1.0;
          this->Brake = 0.0;
          p_Gas = &this->Gas;
          v1.n64_f32[0] = v1.n64_f32[0] * 30.0;
          v58 = vmin_f32(v1, (float32x2_t)v3.n128_u64[0]).n64_f32[0] * 255.0;
          goto LABEL_64;
        }
        v3.n128_u32[0] = 1.0;
        this->Gas = 0.0;
        v1.n64_f32[0] = v1.n64_f32[0] * -30.0;
        v58 = vmin_f32(v1, (float32x2_t)v3.n128_u64[0]).n64_f32[0] * 255.0;
        goto LABEL_63;
      }
      v1.n64_u32[0] = 0;
      if ( (*(_BYTE *)&v40 & 2) != 0 )
      {
        this->m_PassengersMode = 4;
        v123 = this->pLinkedToBackward;
        this->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v40 & 0xFFFB);
        LOWORD(Accelerate) = v213;
        if ( v123 )
        {
          do
          {
            v124 = v123->m_nTrainFlags;
            v123->m_PassengersMode = 4;
            v125 = v123->pLinkedToBackward;
            v123->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v124 & 0xFFFB);
            v123 = v125;
          }
          while ( v125 );
        }
        goto LABEL_59;
      }
    }
    else
    {
      v1.n64_u32[0] = 0;
      if ( (*(_BYTE *)&v40 & 2) == 0 )
      {
        this->m_PassengersMode = 0;
        v46 = this->pLinkedToBackward;
        this->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v40 | 6);
        LOWORD(Accelerate) = v213;
        if ( v46 )
        {
          do
          {
            v47 = v46->m_nTrainFlags;
            v46->m_PassengersMode = 0;
            v48 = v46->pLinkedToBackward;
            v46->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v47 | 6);
            v46 = v48;
          }
          while ( v48 );
        }
        goto LABEL_59;
      }
    }
    LOWORD(Accelerate) = v213;
    goto LABEL_59;
  }
  if ( (*(_BYTE *)&this->m_nFlags & 0x10) != 0 )
    goto LABEL_26;
  v22 = (float *)&loc_57DF8C;
  v23 = this->m_vecAverageTurnSpeed.y + this->m_vecTurnSpeed.y;
  v24.n128_u64[0] = 0x3F0000003F000000LL;
  v24.n128_u64[1] = 0x3F0000003F000000LL;
  v25 = (unsigned __int8)this->m_info;
  v3 = vmulq_f32(
         vaddq_f32(*(float32x4_t *)&this->m_vecAverageMoveSpeed.x, *(float32x4_t *)&this->m_vecMoveSpeed.x),
         v24);
  v26 = (float)(this->m_vecAverageTurnSpeed.z + this->m_vecTurnSpeed.z) * 0.5;
  if ( v25 < 8 )
    v22 = (float *)&loc_57DF90;
  v27 = *v22;
  *(float32x4_t *)&this->m_vecAverageMoveSpeed.x = v3;
  v28 = (float *)&loc_57DF98;
  this->m_vecAverageTurnSpeed.y = v23 * 0.5;
  this->m_vecAverageTurnSpeed.z = v26;
  if ( v25 < 8 )
    v28 = (float *)&loc_57DF9C;
  if ( (float)((float)((float)(v3.n128_f32[0] * v3.n128_f32[0]) + (float)(v3.n128_f32[1] * v3.n128_f32[1]))
             + (float)(v3.n128_f32[2] * v3.n128_f32[2])) > (float)((float)(v27 * CTimer::ms_fTimeStep)
                                                                 * (float)(v27 * CTimer::ms_fTimeStep)) )
    goto LABEL_25;
  v29 = (float *)&loc_57DFA0;
  if ( v25 < 8 )
    v29 = (float *)&loc_57DFA4;
  if ( (float)((float)((float)(v3.n128_f32[3] * v3.n128_f32[3]) + (float)((float)(v23 * 0.5) * (float)(v23 * 0.5)))
             + (float)(v26 * v26)) > (float)((float)(*v29 * CTimer::ms_fTimeStep) * (float)(*v29 * CTimer::ms_fTimeStep))
    || this->m_fTrueDistanceTravelled >= *v28
    || this->m_fDamageImpulseMagnitude > 0.0
    && (m_pDamageEntity = this->m_pDamageEntity) != 0
    && (*(_BYTE *)&m_pDamageEntity->m_info & 7) == 3 )
  {
LABEL_25:
    this->m_nNoOfStaticFrames = 0;
    goto LABEL_26;
  }
  v69 = this->m_nNoOfStaticFrames + 1;
  this->m_nNoOfStaticFrames = v69;
  if ( v69 < 0xBu || CCarCtrl::MapCouldMoveInThisArea(p_m_transform->m_translate.x, p_m_transform->m_translate.y) )
  {
LABEL_26:
    CPhysical::ProcessControl(this);
    if ( cBuoyancy::ProcessBuoyancy(
           &mod_Buoyancy,
           this,
           this->m_fBuoyancyConstant,
           &pCentreOfBuoyancy[0].m_vecPosition,
           &vecStart) == 1 )
    {
      v31 = this->m_vecTurnSpeed.y;
      v32 = this->m_fMass * -0.008;
      v33 = this->m_vecTurnSpeed.z;
      *(_DWORD *)&this->m_nPhysicalFlags |= 0x8000000u;
      v3.n128_f32[0] = CTimer::ms_fTimeStep;
      d1_0.n64_u32[0] = 1008981770;
      v34 = vecStart.z;
      v35 = powf(
              (float)((float)(vecStart.z / (float)(v32 * vmax_f32((float32x2_t)v3.n128_u64[0], d1_0).n64_f32[0])) * 0.05)
            + 1.0,
              CTimer::ms_fTimeStep);
      *(float32x4_t *)&this->m_vecMoveSpeed.x = vmulq_n_f32(*(float32x4_t *)&this->m_vecMoveSpeed.x, v35);
      this->m_vecTurnSpeed.y = v35 * v31;
      this->m_vecTurnSpeed.z = v35 * v33;
      v223.x = vecStart.x;
      *(_QWORD *)&v223.y = __PAIR64__(LODWORD(v34), LODWORD(vecStart.y));
      CPhysical::ApplyMoveForce(this, v223);
      CPhysical::ApplyTurnForce(this, vecStart, pCentreOfBuoyancy[0].m_vecPosition);
    }
    return;
  }
  if ( this->m_nNoOfStaticFrames >= 0xBu )
    this->m_nNoOfStaticFrames = 10;
  this->m_vecTurnSpeed.z = 0.0;
  *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
  this->m_vecTurnSpeed.y = 0.0;
  CPhysical::SkipPhysics(this);
}
// 57D0A0: fragmented variable at r3.4 may be wrong
// 57D0A0: fragmented variable at kr00_8.8 may be wrong
// 57D5FB: failed to expand linear variable ^0.4
// 57E62C: using guessed type int dword_57E62C[2];
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];

//----- (0057E674) --------------------------------------------------------
Int32 __fastcall CTrain::FindNumCarriagesPulled(CTrain *this)
{
  Int32 result; // r0

  result = -1;
  do
  {
    this = this->pLinkedToBackward;
    ++result;
  }
  while ( this );
  return result;
}

//----- (0057E688) --------------------------------------------------------
bool __fastcall CTrain::FindMaximumSpeedToStopAtStations(CTrain *this, float *pMaxSpeed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d6
  bool result; // r0
  int *v5; // r3
  int v6; // r12
  int i; // r2
  float v8; // s2

  *pMaxSpeed = 50.0;
  if ( this->TrainType )
    return 0;
  v5 = dword_57E784;
  v2.n64_u32[0] = 1176256512;
  v6 = *(_WORD *)&this->m_nTrainFlags & 0x40;
  if ( !v6 )
    v5 = &dword_57E784[1];
  for ( i = 0; i != 6; ++i )
  {
    for ( v3.n64_f32[0] = (float)(StationDist[i] - this->PositionOnTrack) + *(float *)v5;
          v3.n64_f32[0] > (float)(TotalLengthOfTrack[0] * 0.5);
          v3.n64_f32[0] = v3.n64_f32[0] - TotalLengthOfTrack[0] )
    {
      ;
    }
    while ( v3.n64_f32[0] < (float)(TotalLengthOfTrack[0] * -0.5) )
      v3.n64_f32[0] = v3.n64_f32[0] + TotalLengthOfTrack[0];
    if ( v6 )
    {
      if ( v3.n64_f32[0] > 0.0 )
        v2.n64_u64[0] = vmin_f32(v3, v2).n64_u64[0];
    }
    else if ( v3.n64_f32[0] < 0.0 )
    {
      v3.n64_f32[0] = -v3.n64_f32[0];
      v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
    }
  }
  if ( v2.n64_f32[0] >= 500.0 )
    v8 = 100000.0;
  else
    v8 = (float)(1.0 - (float)((float)(500.0 - v2.n64_f32[0]) / 500.0)) * 50.0;
  result = 0;
  *pMaxSpeed = v8;
  if ( v2.n64_f32[0] < 5.0 )
    return 1;
  return result;
}
// 57E720: variable 'v2' is possibly undefined
// 57E720: variable 'v3' is possibly undefined
// 57E784: using guessed type int dword_57E784[2];

//----- (0057E79C) --------------------------------------------------------
void __fastcall CTrain::RemoveRandomPassenger(CTrain *this)
{
  CPlayerPed *PlayerPed; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  CTrain **v4; // r5
  CTrain::CTrainFlags m_nTrainFlags; // r5
  CPlayerPed *v6; // r0
  CPed *m_pRandomPedForTrain; // r0
  float v8; // s16
  unsigned int v9; // r0
  bool v10; // r1
  Int32 v11; // r2
  CPed *v12; // r0
  CPed *v13; // r6
  char v14; // r0
  CTaskComplexLeaveCarAndWander *v15; // r5
  CPed *pDriver; // r1

  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed->m_pMyVehicle != this )
  {
    if ( (m_pPedIntelligence = PlayerPed->m_pPedIntelligence,
          (v4 = (CTrain **)m_pPedIntelligence->m_taskManager.m_tasks[3]) == 0)
      || ((int (__fastcall *)(CTask *))(*v4)->m_pMat)(m_pPedIntelligence->m_taskManager.m_tasks[3]) != 701
      && ((int (__fastcall *)(CTrain **))(*v4)->m_pMat)(v4) != 700
      || v4[3] != this )
    {
      m_nTrainFlags = this->m_nTrainFlags;
      v6 = FindPlayerPed(-1);
      if ( *((unsigned __int8 *)&v6->m_nPedFlags + 1) << 31 && v6->m_pMyVehicle == this )
      {
        pDriver = this->pDriver;
        if ( (*(_BYTE *)&m_nTrainFlags & 0x40) != 0 )
        {
          if ( pDriver == v6 )
            return;
        }
        else if ( pDriver != v6 )
        {
          return;
        }
      }
      if ( !(*((unsigned __int8 *)this + 1503) << 28) )
        return;
      m_pRandomPedForTrain = this->m_pRandomPedForTrain;
      if ( m_pRandomPedForTrain )
      {
        if ( *((unsigned __int8 *)&m_pRandomPedForTrain->m_nPedFlags + 1) << 31 )
          return;
        CEntity::CleanUpOldReference(m_pRandomPedForTrain, &this->m_pRandomPedForTrain);
        this->m_pRandomPedForTrain = 0;
      }
      v8 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 12.0;
      v9 = rand() & 0xFFFC;
      v10 = 0;
      v11 = (int)v8;
      if ( (int)v8 == 12 )
        v11 = 11;
      if ( v9 < 0x64 )
        v11 = 25;
      if ( (*(_BYTE *)&m_nTrainFlags & 0x40) == 0 )
        v10 = 1;
      v12 = CPopulation::AddPedInCar(this, v10, v11, 0, 0, 0);
      v13 = v12;
      if ( v12 )
      {
        *((_DWORD *)&v12->m_nPedFlags + 3) |= 0x40000u;
        v14 = *((_BYTE *)this + 1503);
        this->m_pRandomPedForTrain = v13;
        *((_BYTE *)this + 1503) = (v14 + 15) & 0xF | v14 & 0xF0;
        CEntity::RegisterReference(v13, &this->m_pRandomPedForTrain);
        v15 = (CTaskComplexLeaveCarAndWander *)CTask::operator new(0x1Cu);
        CTaskComplexLeaveCarAndWander::CTaskComplexLeaveCarAndWander(v15, this, 0, 0, 1);
        sub_1951C0(&v13->m_pPedIntelligence->m_taskManager, v15, 3, 0);
      }
    }
  }
}

//----- (0057E910) --------------------------------------------------------
void __fastcall CTrain::AddNearbyPedAsRandomPassenger(CTrain *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d9
  CPlayerPed *PlayerPed; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  CTrain **v6; // r5
  CPed *m_pRandomPedForTrain; // r0
  CEntity **p_m_pRandomPedForTrain; // r5
  CTrain::CTrainFlags m_nTrainFlags; // r8
  int v10; // r2
  int v11; // r1
  bool v12; // zf
  CEntity *v13; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r2
  CPedPool *v16; // r11
  int32 m_nSize; // r0
  int v18; // r3
  int v19; // r8
  int v20; // r6
  float v21; // s16
  CMatrix *v22; // r12
  CSimpleTransform *p_tx; // r3
  int v24; // r2
  float *v25; // r1
  float v26; // s2
  float v27; // s4
  int v28; // r0
  float v29; // s6
  int v30; // r1
  float v31; // s2
  CPed *v32; // r0
  bool v33; // nf
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r9
  uint8 *v35; // r10
  CPedGroup *PedsGroup; // r0
  bool v37; // zf
  CMatrix *v38; // r0
  float xx; // s6
  float v40; // s16
  float v41; // s20
  float v42; // s18
  void *v43; // r5
  char v44; // r2
  CTaskComplexSequence *v45; // r6
  CTaskComplexSequence *v46; // r0
  CTaskComplexEnterCarAsPassenger *v47; // r0
  CTask *v48; // r5
  char v49; // r0
  int v50; // [sp+8h] [bp-B0h]
  CPed *ped; // [sp+10h] [bp-A8h]
  CVector v52; // [sp+14h] [bp-A4h] BYREF
  CMatrix output; // [sp+20h] [bp-98h] BYREF
  int iDoor; // [sp+68h] [bp-50h] BYREF
  CVector vDoorPos; // [sp+6Ch] [bp-4Ch] BYREF

  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed->m_pMyVehicle == this )
    return;
  m_pPedIntelligence = PlayerPed->m_pPedIntelligence;
  v6 = (CTrain **)m_pPedIntelligence->m_taskManager.m_tasks[3];
  if ( v6 )
  {
    if ( (((int (__fastcall *)(CTask *))(*v6)->m_pMat)(m_pPedIntelligence->m_taskManager.m_tasks[3]) == 701
       || ((int (__fastcall *)(CTrain **))(*v6)->m_pMat)(v6) == 700)
      && v6[3] == this )
    {
      return;
    }
  }
  if ( (*((_BYTE *)this + 1503) & 0xF) == *((unsigned __int8 *)this + 1503) >> 4 )
    return;
  m_pRandomPedForTrain = this->m_pRandomPedForTrain;
  p_m_pRandomPedForTrain = &this->m_pRandomPedForTrain;
  m_nTrainFlags = this->m_nTrainFlags;
  if ( !m_pRandomPedForTrain )
    goto LABEL_16;
  v10 = *(_DWORD *)&m_pRandomPedForTrain->m_nPedFlags & 0x100;
  v11 = *((_DWORD *)&m_pRandomPedForTrain->m_nPedFlags + 3) & 0x40000;
  v12 = (v11 ^ 0x40000 | v10 ^ 0x100) == 0;
  if ( v11 ^ 0x40000 | v10 ^ 0x100 )
    v12 = (*((_DWORD *)&m_pRandomPedForTrain->m_nPedFlags + 3) & 0x40000 | v10) == 0;
  if ( !v12 && !CPedIntelligence::FindTaskByType(m_pRandomPedForTrain->m_pPedIntelligence, 707) )
  {
    CEntity::CleanUpOldReference(*p_m_pRandomPedForTrain, &this->m_pRandomPedForTrain);
    v13 = *p_m_pRandomPedForTrain;
    if ( !(LODWORD((*p_m_pRandomPedForTrain)[19].m_transform.m_heading) & 0x100 ^ 0x100 | *(_DWORD *)&(*p_m_pRandomPedForTrain)[19].m_nFlags & 0x40000)
      && (CTrain *)v13[23].m_pLastRenderedLink == this )
    {
      CPopulation::RemovePed((CPed *)v13);
    }
    *p_m_pRandomPedForTrain = 0;
LABEL_16:
    m_pMat = this->m_pMat;
    p_m_transform = &this->m_transform;
    if ( m_pMat )
      p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    v16 = CPools::ms_pPedPool;
    m_nSize = CPools::ms_pPedPool->m_nSize;
    if ( m_nSize )
    {
      v18 = *(_BYTE *)&m_nTrainFlags & 0x40;
      v19 = m_nSize - 1;
      v50 = v18;
      v2.n64_u32[0] = 1232348144;
      ped = 0;
      v20 = 1996 * m_nSize - 908;
      v21 = (float)((float)(p_m_transform->m_translate.x * m_pMat->xx)
                  + (float)(p_m_transform->m_translate.y * m_pMat->yx))
          + (float)(p_m_transform->m_translate.z * m_pMat->zx);
      do
      {
        if ( (v16->m_aFlags[v19] & 0x80u) == 0 )
        {
          m_aStorage = v16->m_aStorage;
          v35 = &(*v16->m_aStorage)[v20];
          if ( v35 != (uint8 *)&elf_hash_bucket[209] && v35[8] == 1 )
          {
            PedsGroup = CPedGroups::GetPedsGroup((const CPed *)(v35 - 1088));
            v37 = PedsGroup == 0;
            if ( !PedsGroup )
              v37 = *((_DWORD *)v35 + 1) == 0;
            if ( v37
              && *((_DWORD *)v35 + 87) != 6
              && !(*((_DWORD *)v35 + 17) & 0x100 | *((_DWORD *)v35 + 20) & 0x40000)
              && (unsigned int)(*((_DWORD *)v35 + 3) - 54) >= 3
              && !CPedIntelligence::FindTaskByType(*(const CPedIntelligence **)&(*m_aStorage)[v20], 700) )
            {
              v22 = this->m_pMat;
              p_tx = &this->m_transform;
              v24 = *((_DWORD *)v35 - 267);
              if ( v22 )
                p_tx = (CSimpleTransform *)&v22->tx;
              v25 = (float *)(v24 + 48);
              if ( !v24 )
                v25 = (float *)&(*m_aStorage)[v20 - 1084];
              v26 = *v25;
              v27 = v25[1];
              v1.n64_f32[0] = (float)((float)((float)(*v25 - p_tx->m_translate.x) * (float)(*v25 - p_tx->m_translate.x))
                                    + (float)((float)(v27 - p_tx->m_translate.y) * (float)(v27 - p_tx->m_translate.y)))
                            + 0.0;
              if ( v1.n64_f32[0] <= 625.0 )
              {
                v28 = 0;
                v29 = v25[2];
                v30 = 0;
                v31 = (float)((float)((float)(v26 * v22->xx) + (float)(v27 * v22->yx)) + (float)(v29 * v22->zx)) - v21;
                if ( v31 < 0.0 )
                  v28 = 1;
                if ( v31 > 0.0 )
                  v30 = 1;
                if ( v50 )
                  v30 = v28;
                if ( !v30 )
                {
                  v32 = ped;
                  v33 = v1.n64_f32[0] < v2.n64_f32[0];
                  v2.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
                  if ( v33 )
                    v32 = (CPed *)(v35 - 1088);
                  ped = v32;
                }
              }
            }
          }
        }
        --v19;
        v20 -= 1996;
      }
      while ( v19 != -1 );
      if ( ped )
      {
        iDoor = 0;
        CCarEnterExit::GetNearestCarDoor(ped, this, &vDoorPos, &iDoor);
        output.m_pRwMat = 0;
        output.m_owner = 0;
        Invert(this->m_pMat, &output);
        operator*(&v52, &output, &vDoorPos);
        v38 = this->m_pMat;
        xx = v38->xx;
        if ( v50 )
        {
          v40 = v52.x + xx;
          v41 = v52.y + v38->yx;
          v42 = v52.z + v38->zx;
        }
        else
        {
          v40 = v52.x - xx;
          v41 = v52.y - v38->yx;
          v42 = v52.z - v38->zx;
        }
        v43 = CTask::operator new(0x58u);
        CTaskComplex::CTaskComplex((CTaskComplex *)v43);
        *((_QWORD *)v43 + 3) = 0x400000003F800000LL;
        *((_QWORD *)v43 + 4) = 0x4000000000000000LL;
        *((_QWORD *)v43 + 2) = 0x3E80000C350LL;
        *((_WORD *)v43 + 24) = 0;
        *((_WORD *)v43 + 30) = 0;
        *((_DWORD *)v43 + 10) = 0;
        *((_DWORD *)v43 + 11) = 0;
        *((_DWORD *)v43 + 13) = 0;
        *((_DWORD *)v43 + 14) = 0;
        *((_DWORD *)v43 + 17) = 0;
        *((_DWORD *)v43 + 18) = 0;
        *((_DWORD *)v43 + 19) = 0;
        *((_DWORD *)v43 + 20) = 6;
        v44 = *((_BYTE *)v43 + 84);
        *(_DWORD *)v43 = &off_668968;
        *((_DWORD *)v43 + 16) = &off_66D3CC;
        *((_BYTE *)v43 + 84) = v44 & 0xF0 | 3;
        *((_DWORD *)v43 + 3) = this;
        CEntity::RegisterReference(this, (CEntity **)v43 + 3);
        *((float *)v43 + 17) = v40;
        *((float *)v43 + 18) = v41;
        *((float *)v43 + 19) = v42;
        *((_DWORD *)v43 + 20) = 7;
        v45 = (CTaskComplexSequence *)CTask::operator new(0x40u);
        CTaskComplexSequence::CTaskComplexSequence(v45);
        CTaskComplexSequence::AddTask(v46, (CTask *)v43);
        v47 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
        v48 = v47;
        if ( v50 )
          CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(v47, this, 0, 0);
        else
          CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver((CTaskComplexEnterCarAsDriver *)v47, this);
        CTaskComplexSequence::AddTask(v45, v48);
        CTaskManager::SetTask(&ped->m_pPedIntelligence->m_taskManager, v45, 3, 0);
        v49 = *((_BYTE *)this + 1503);
        this->m_pRandomPedForTrain = ped;
        *((_BYTE *)this + 1503) = (v49 + 1) & 0xF | v49 & 0xF0;
        CEntity::RegisterReference(ped, &this->m_pRandomPedForTrain);
        CMatrix::~CMatrix(&output);
      }
    }
  }
}
// 57EB60: variable 'v1' is possibly undefined
// 57EB60: variable 'v2' is possibly undefined
// 57ECCA: variable 'v46' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (0057ED68) --------------------------------------------------------
void __fastcall MarkSurroundingEntitiesForCollisionWithTrain(
        CVector CenterPoint,
        float Size,
        CEntity *pException,
        int bOnlyVehicles)
{
  float v4; // s24
  float v5; // s20
  float v6; // s22
  float v7; // r4
  float v8; // s16
  float v9; // s18
  float v10; // r0
  int v11; // r2
  int v12; // r1
  int v13; // r1
  int v14; // r2
  uint16 v15; // r0
  int v16; // r0
  int v17; // r11
  int v18; // r9
  CPtrNode *m_pHead; // r8
  CPtrNode v20; // kr00_8
  char v21; // r1
  int v22; // r0
  __int64 v23; // r4
  char v24; // r1
  int v25; // r0
  __int64 v26; // r4
  char v27; // r1
  int v28; // r0
  int v30; // [sp+0h] [bp-88h]
  int v31; // [sp+4h] [bp-84h]
  int v32; // [sp+8h] [bp-80h]
  int v33; // [sp+2Ch] [bp-5Ch]
  int v34; // [sp+30h] [bp-58h]

  v4 = CenterPoint.x + Size;
  v5 = CenterPoint.y - Size;
  v6 = CenterPoint.y + Size;
  v7 = floorf((float)((float)(CenterPoint.x - Size) / 50.0) + 60.0);
  v8 = floorf((float)(v5 / 50.0) + 60.0);
  v9 = floorf((float)(v4 / 50.0) + 60.0);
  v10 = floorf((float)(v6 / 50.0) + 60.0);
  v11 = 119;
  v12 = (int)v10;
  if ( (int)v10 >= 119 )
    v12 = 119;
  v30 = v12;
  if ( (int)v9 < 119 )
    v11 = (int)v9;
  v13 = (int)v8;
  v34 = v11;
  v14 = 0;
  if ( (int)v8 <= 0 )
    v13 = 0;
  v32 = v13;
  if ( (int)v7 > 0 )
    v14 = (int)v7;
  v31 = v14;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v15 = 1;
  }
  else
  {
    v15 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v15;
  if ( v32 <= v30 )
  {
    do
    {
      if ( v31 <= v34 )
      {
        v33 = (unsigned __int8)(16 * v32);
        v16 = v31;
        do
        {
          v17 = v16;
          v18 = v16 & 0xF | v33;
          m_pHead = CWorld::ms_aRepeatSectors[v16 & 0xF | v33].m_ptrListArray[0].m_pHead;
          while ( m_pHead )
          {
            v20 = *m_pHead;
            m_pHead = m_pHead->m_pNext;
            if ( v20.m_pVoid != pException )
            {
              v21 = *((_BYTE *)v20.m_pVoid + 58);
              *((_DWORD *)v20.m_pVoid + 17) |= 0x800u;
              if ( (v21 & 7) == 4 && (*((_DWORD *)v20.m_pVoid + 7) & 0x40004) != 0 )
              {
                v22 = *((__int16 *)v20.m_pVoid + 19);
                if ( v22 == MI_OBJECTFORMAGNOCRANE1 || v22 == MI_OBJECTFORMAGNOCRANE2 || v22 == MI_OBJECTFORMAGNOCRANE3 )
                {
                  (*(void (__fastcall **)(void *, _DWORD))(*(_DWORD *)v20.m_pVoid + 20))(v20.m_pVoid, 0);
                  CPhysical::AddToMovingList((CPhysical *)v20.m_pVoid);
                  *((_BYTE *)v20.m_pVoid + 188) = 0;
                }
              }
            }
          }
          if ( !bOnlyVehicles )
          {
            HIDWORD(v23) = CWorld::ms_aRepeatSectors[v18].m_ptrListArray[1].m_pHead;
            while ( HIDWORD(v23) )
            {
              v23 = *(_QWORD *)HIDWORD(v23);
              if ( (CEntity *)v23 != pException )
              {
                v24 = *(_BYTE *)(v23 + 58);
                *(_DWORD *)(v23 + 68) |= 0x800u;
                if ( (v24 & 7) == 4 && (*(_DWORD *)(v23 + 28) & 0x40004) != 0 )
                {
                  v25 = *(__int16 *)(v23 + 38);
                  if ( v25 == MI_OBJECTFORMAGNOCRANE1
                    || v25 == MI_OBJECTFORMAGNOCRANE2
                    || v25 == MI_OBJECTFORMAGNOCRANE3 )
                  {
                    (*(void (__fastcall **)(_DWORD, _DWORD))(*(_DWORD *)v23 + 20))(v23, 0);
                    CPhysical::AddToMovingList((CPhysical *)v23);
                    *(_BYTE *)(v23 + 188) = 0;
                  }
                }
              }
            }
            HIDWORD(v26) = CWorld::ms_aRepeatSectors[v18].m_ptrListArray[2].m_pHead;
            while ( HIDWORD(v26) )
            {
              v26 = *(_QWORD *)HIDWORD(v26);
              if ( (CEntity *)v26 != pException )
              {
                v27 = *(_BYTE *)(v26 + 58);
                *(_DWORD *)(v26 + 68) |= 0x800u;
                if ( (v27 & 7) == 4 && (*(_DWORD *)(v26 + 28) & 0x40004) != 0 )
                {
                  v28 = *(__int16 *)(v26 + 38);
                  if ( v28 == MI_OBJECTFORMAGNOCRANE1
                    || v28 == MI_OBJECTFORMAGNOCRANE2
                    || v28 == MI_OBJECTFORMAGNOCRANE3 )
                  {
                    (*(void (__fastcall **)(_DWORD, _DWORD))(*(_DWORD *)v26 + 20))(v26, 0);
                    CPhysical::AddToMovingList((CPhysical *)v26);
                    *(_BYTE *)(v26 + 188) = 0;
                  }
                }
              }
            }
          }
          v16 = v17 + 1;
        }
        while ( v17 < v34 );
      }
    }
    while ( v32++ < v30 );
  }
}

//----- (0057F088) --------------------------------------------------------
float __fastcall CTrain::GetDooorAngleOpenRatio(const CTrain *this, uint32 iDoorIndex)
{
  uint32 v2; // r1
  float result; // r0

  v2 = iDoorIndex - 8;
  switch ( v2 )
  {
    case 0u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CTrain *, int))this->_vptr$CPlaceable + 30))(this, 3));
      break;
    case 1u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CTrain *, int))this->_vptr$CPlaceable + 30))(this, 5));
      break;
    case 2u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CTrain *, int))this->_vptr$CPlaceable + 30))(this, 2));
      break;
    case 3u:
      result = COERCE_FLOAT((*((int (__fastcall **)(const CTrain *, int))this->_vptr$CPlaceable + 30))(this, 4));
      break;
    default:
      result = 0.0;
      break;
  }
  return result;
}

//----- (0057F0BA) --------------------------------------------------------
float __fastcall CTrain::GetDooorAngleOpenRatio(const CTrain *this, const eDoors DoorId)
{
  return sub_19BFCC(&this->Door[DoorId]);
}

//----- (0057F0CC) --------------------------------------------------------
void __fastcall CTrain::OpenDoor(
        CTrain *this,
        CPed *pPed,
        int32 index,
        eDoors DoorID,
        float timeRatio,
        bool bPlaySoundSample)
{
  int v9; // r0
  char *v10; // r4
  RwFrame_0 *v11; // r0
  float tx; // s18
  float ty; // s20
  CPlaceable *v14; // r5
  float tz; // s16
  RwFrame_0 **v16; // r4
  int v17; // r0
  CEntity **v18; // r8
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  double v21; // d16
  int v22; // r0
  CMatrix *v23; // r0
  CSimpleTransform *p_m_transform; // r2
  double v25; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventEditableResponse v27; // [sp+0h] [bp-C0h] BYREF
  CEntity *v28; // [sp+10h] [bp-B0h]
  int v29; // [sp+14h] [bp-ACh]
  uint32 v30; // [sp+18h] [bp-A8h]
  double v31; // [sp+1Ch] [bp-A4h]
  RwReal z; // [sp+24h] [bp-9Ch]
  float v33; // [sp+28h] [bp-98h]
  float v34; // [sp+2Ch] [bp-94h]
  float v35; // [sp+30h] [bp-90h]
  CMatrix v36; // [sp+38h] [bp-88h] BYREF

  if ( (DoorID & 0xFFFFFFFE) == 2 )
  {
    v9 = 2;
    if ( DoorID == FRONT_LEFT_DOOR_0 )
      v9 = 1;
    v10 = (char *)this + v9 * 4;
    v11 = this->m_aTrainNodes[v9];
    if ( v11 )
    {
      CMatrix::CMatrix(&v36, &v11->modelling, 0);
      tx = v36.tx;
      ty = v36.ty;
      v14 = (CTrain *)((char *)this + 24 * DoorID);
      tz = v36.tz;
      v33 = 0.0;
      v34 = 0.0;
      v35 = 0.0;
      if ( CDoor::IsClosed((const CDoor *)&v14[63].m_transform) )
      {
        v16 = (RwFrame_0 **)(v10 + 1660);
        RwFrameForAllObjects(*v16, CVehicleModelInfo::ClearAtomicFlagCB, &elf_hash_bucket[193]);
        CDoor::Open((CDoor *)&v14[63].m_transform, timeRatio);
        if ( v14[63].m_transform.m_heading != v14[63].m_transform.m_translate.y )
        {
          RwFrameForAllObjects(*v16, CVehicleModelInfo::SetAtomicFlagCB, &elf_hash_bucket[193]);
          if ( pPed )
          {
            CEventEditableResponse::CEventEditableResponse(&v27);
            v28 = pPed;
            v29 = 1114636288;
            v18 = (CEntity **)(v17 + 16);
            v30 = -1;
            v31 = 0.0;
            z = 0.0;
            v27._vptr$CEvent = (int (**)(void))&off_66714C;
            CEntity::RegisterReference(pPed, (CEntity **)(v17 + 16));
            if ( v30 == -1 )
            {
              v30 = CTimer::m_snTimeInMilliseconds;
              m_pMat = v28->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &v28->m_transform;
              v21 = *(double *)&p_tx->m_translate.x;
              z = p_tx->m_translate.z;
              v31 = v21;
            }
LABEL_19:
            EventGlobalGroup = GetEventGlobalGroup();
            CEventGroup::Add(EventGlobalGroup, (CEvent *)&v27, 0);
            v27._vptr$CEvent = (int (**)(void))&off_66714C;
            if ( v28 )
              CEntity::CleanUpOldReference(v28, v18);
            CEvent::~CEvent((CEvent *)&v27);
          }
        }
      }
      else
      {
        CDoor::Open((CDoor *)&v14[63].m_transform, timeRatio);
        if ( pPed && timeRatio == 0.0 )
        {
          CEventEditableResponse::CEventEditableResponse(&v27);
          v28 = pPed;
          v29 = 1123024896;
          v18 = (CEntity **)(v22 + 16);
          v30 = -1;
          v31 = 0.0;
          z = 0.0;
          v27._vptr$CEvent = (int (**)(void))&off_66714C;
          CEntity::RegisterReference(pPed, (CEntity **)(v22 + 16));
          if ( v30 == -1 )
          {
            v30 = CTimer::m_snTimeInMilliseconds;
            v23 = v28->m_pMat;
            p_m_transform = (CSimpleTransform *)&v23->tx;
            if ( !v23 )
              p_m_transform = &v28->m_transform;
            v25 = *(double *)&p_m_transform->m_translate.x;
            z = p_m_transform->m_translate.z;
            v31 = v25;
          }
          goto LABEL_19;
        }
      }
      if ( this->m_nModelIndex == 570 )
      {
        CMatrix::SetTranslate(
          &v36,
          tx,
          v14[63].m_transform.m_translate.y
        + (float)((float)(v14[63].m_transform.m_translate.x - v14[63].m_transform.m_translate.y) * timeRatio),
          tz);
      }
      else
      {
        *(&v33 + BYTE2(v14[63].m_transform.m_translate.z)) = v14[63].m_transform.m_heading;
        CMatrix::SetRotate(&v36, v33, v34, v35);
        v36.tx = tx + v36.tx;
        v36.ty = ty + v36.ty;
        v36.tz = tz + v36.tz;
      }
      CMatrix::UpdateRW(&v36);
      CMatrix::~CMatrix(&v36);
    }
  }
}
// 57F1A8: variable 'v17' is possibly undefined
// 57F234: variable 'v22' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 66714C: using guessed type void *off_66714C;

//----- (0057F354) --------------------------------------------------------
void __fastcall CTrain::FindCoorsFromPositionOnTrack(float Position, Int32 Track, CVector *pCoors)
{
  int v6; // r5
  int v7; // r4
  Int32 v8; // r6
  CTrainNode *v9; // r2
  int v10; // r1
  unsigned int v11; // r0
  unsigned int v12; // s0
  CTrainNode *v13; // r0
  float v14; // s0
  float v15; // s2
  int CoorX; // r1
  char *v17; // r2
  float v18; // s14
  float v19; // s4
  float v20; // s6
  float v21; // s0

  v6 = 6;
  v7 = 1;
  v8 = NumTrackNodes[Track];
  while ( v7 - 1 < v8 )
  {
    v9 = pTrackNodes[Track];
    v10 = v7 % v8;
    ++v7;
    v11 = *(unsigned __int16 *)((char *)&v9->CoorX + v6);
    v6 += 10;
    v12 = v11;
    v13 = &v9[v10];
    v14 = Position - (float)((float)v12 / 3.0);
    if ( v14 >= 0.0 )
    {
      v15 = (float)((float)v13->LengthFromStart / 3.0) - Position;
      if ( v15 >= 0.0 )
      {
        CoorX = v9[v10].CoorX;
        v17 = (char *)v9 + v6;
        v18 = 1.0 / (float)(v14 + v15);
        v19 = (float)(v15 * (float)((float)*((__int16 *)v17 - 8) * 0.125))
            + (float)(v14 * (float)((float)CoorX * 0.125));
        v20 = (float)(v15 * (float)((float)*((__int16 *)v17 - 7) * 0.125))
            + (float)(v14 * (float)((float)v13->CoorY * 0.125));
        v21 = (float)(v15 * (float)((float)*((__int16 *)v17 - 6) * 0.125))
            + (float)(v14 * (float)((float)v13->CoorZ * 0.125));
        pCoors->x = v18 * v19;
        pCoors->y = v18 * v20;
        pCoors->z = v18 * v21;
        return;
      }
    }
  }
}
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];

//----- (0057F498) --------------------------------------------------------
void __fastcall TrainHitStuff(CPtrList *list, CEntity *pException)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v4; // kr00_8
  char v5; // r1
  int v6; // r0
  bool v7; // zf

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v4 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( v4.m_pVoid != pException )
    {
      v5 = *((_BYTE *)v4.m_pVoid + 58);
      *((_DWORD *)v4.m_pVoid + 17) |= 0x800u;
      if ( (v5 & 7) == 4 && (*((_DWORD *)v4.m_pVoid + 7) & 0x40004) != 0 )
      {
        v6 = *((__int16 *)v4.m_pVoid + 19);
        v7 = v6 == MI_OBJECTFORMAGNOCRANE1;
        if ( v6 != MI_OBJECTFORMAGNOCRANE1 )
          v7 = v6 == MI_OBJECTFORMAGNOCRANE2;
        if ( v7 || v6 == MI_OBJECTFORMAGNOCRANE3 )
        {
          (*(void (__fastcall **)(void *, _DWORD))(*(_DWORD *)v4.m_pVoid + 20))(v4.m_pVoid, 0);
          CPhysical::AddToMovingList((CPhysical *)v4.m_pVoid);
          *((_BYTE *)v4.m_pVoid + 188) = 0;
        }
      }
    }
  }
}

//----- (0057F536) --------------------------------------------------------
bool __fastcall CTrain::FindSideStationIsOn(CTrain *this)
{
  return (*(_BYTE *)&this->m_nTrainFlags >> 6) & 1;
}

//----- (0057F540) --------------------------------------------------------
void __fastcall CTrain::DisableRandomTrains(bool bDisable)
{
  CTrain::bDisableRandomTrains = bDisable;
}

//----- (0057F550) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTrain::CreateMissionTrain(
        CVector StartCoors,
        int bDirection,
        UInt32 TrainConfig,
        CTrain **ppEngine,
        CTrain **ppLastCarriage,
        Int32 Node,
        Int32 TrackType,
        int bIsMissionTrain)
{
  float32x2_t v8; // d0
  float32x2_t v9; // d5
  Int32 v11; // r9
  float y; // s4
  float x; // s6
  Int32 i; // r1
  int v15; // r6
  int v16; // r4
  Int16 *p_CoorY; // r5
  float v18; // s12
  bool v19; // nf
  CTrain *v20; // r6
  int v21; // r11
  Int32 *v22; // r10
  __int16 v23; // r4
  float v24; // s16
  int v25; // r0
  CTrain *v26; // r5
  int m_nVehicleFlags; // r0
  CEntity::CEntityInfo m_info; // r1
  CTrain::CTrainFlags m_nTrainFlags; // r2
  int v30; // r0
  CColModel *m_pColModel; // r0
  float v32; // s0
  CMatrix *m_pMat; // r0
  RwReal *p_tz; // r0
  CColModel *v35; // r0
  float v36; // s0
  CTrain::CTrainFlags v37; // r1
  int v38; // t1
  int v39; // r5
  CEntity *v40; // r4
  CTrain *v41; // r0
  CTrain *v42; // r4
  CPed *pDriver; // r1
  CTrain **p_pLinkedToBackward; // r0
  __int16 v45; // r0
  CTrain *v46; // r1
  CTrain *pLinkedToBackward; // r3
  CVector v48; // [sp+14h] [bp-7Ch]
  _DWORD v50[26]; // [sp+28h] [bp-68h]

  v11 = Node;
  v48 = StartCoors;
  if ( Node <= -1 )
  {
    y = StartCoors.y;
    v8.n64_u32[0] = 1203982323;
    x = StartCoors.x;
    for ( i = 0; i != 4; ++i )
    {
      v15 = NumTrackNodes[i];
      if ( v15 >= 1 )
      {
        v16 = 0;
        p_CoorY = &pTrackNodes[i]->CoorY;
        do
        {
          v9.n64_f32[0] = (float)*p_CoorY;
          v18 = (float)*(p_CoorY - 1);
          LODWORD(StartCoors.x) = p_CoorY[1];
          p_CoorY += 5;
          v9.n64_f32[0] = sqrtf(
                            (float)((float)((float)(x - (float)(v18 * 0.125)) * (float)(x - (float)(v18 * 0.125)))
                                  + (float)((float)(y - (float)(v9.n64_f32[0] * 0.125))
                                          * (float)(y - (float)(v9.n64_f32[0] * 0.125))))
                          + (float)((float)(StartCoors.z - (float)((float)SLODWORD(StartCoors.x) * 0.125))
                                  * (float)(StartCoors.z - (float)((float)SLODWORD(StartCoors.x) * 0.125))));
          v19 = v9.n64_f32[0] < v8.n64_f32[0];
          v8.n64_u64[0] = vmin_f32(v9, v8).n64_u64[0];
          if ( v19 )
          {
            v11 = v16;
            TrackType = i;
          }
          ++v16;
        }
        while ( v16 < v15 );
      }
    }
  }
  v20 = 0;
  v21 = 0;
  v22 = &TrainConfigs[TrainConfig][1];
  v24 = (float)pTrackNodes[TrackType][v11].LengthFromStart / 3.0;
  do
  {
    v26 = (CTrain *)CVehicle::operator new(0x6C0u);
    CTrain::CTrain(v26, *(v22 - 1), 4u);
    CMatrix::SetTranslate(v26->m_pMat, 0.0, 0.0, 0.0);
    v26->CurrentNode = v11;
    v26->PositionOnTrack = v24;
    m_nVehicleFlags = (int)v26->m_nVehicleFlags;
    v26->TrainType = TrackType;
    m_info = v26->m_info;
    m_nTrainFlags = v26->m_nTrainFlags;
    *(_DWORD *)&v26->m_nVehicleFlags = m_nVehicleFlags | 8;
    v26->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x20);
    v23 = (32 * bIsMissionTrain) | ((_WORD)bDirection << 6);
    v26->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&m_nTrainFlags & 0xFF9F | v23);
    if ( !bIsMissionTrain )
      goto LABEL_17;
    v26->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&m_nTrainFlags & 0xFF1F | v23 & 0xFF7F);
    v30 = (int)v20;
    if ( v20 )
      v30 = 1;
    if ( !(v30 | bIsMissionTrain ^ 1) )
    {
      m_pMat = v26->m_pMat;
      if ( m_pMat )
      {
        m_pMat->tx = v48.x;
        v26->m_pMat->ty = v48.y;
        p_tz = &v26->m_pMat->tz;
      }
      else
      {
        v26->m_transform.m_translate.x = v48.x;
        v26->m_transform.m_translate.y = v48.y;
        p_tz = &v26->m_transform.m_translate.z;
      }
      *p_tz = v48.z;
      CTrain::FindPositionOnTrackFromCoors(v26);
    }
    else
    {
LABEL_17:
      if ( v20 )
      {
        if ( bDirection == 1 )
        {
          m_pColModel = CModelInfo::ms_modelInfoPtrs[v26->m_nModelIndex]->m_pColModel;
          v32 = m_pColModel->m_boxBound.m_vecMax.y - m_pColModel->m_boxBound.m_vecMin.y;
          v24 = v24 - v32;
          v26->OffsetFromLeader = -v32;
        }
        else
        {
          v35 = CModelInfo::ms_modelInfoPtrs[v20->m_nModelIndex]->m_pColModel;
          v36 = v35->m_boxBound.m_vecMax.y - v35->m_boxBound.m_vecMin.y;
          v24 = v24 + v36;
          v26->OffsetFromLeader = v36;
        }
        v50[v21++] = v26;
        v25 = 1;
        v37 = v26->m_nTrainFlags;
LABEL_27:
        v26->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v37 & 0xFFF7);
        *(_DWORD *)&v26->m_nVehicleFlags |= 0x20000u;
        *(_WORD *)&v20->m_nTrainFlags &= ~0x10u;
        goto LABEL_28;
      }
    }
    v25 = 0;
    v26->OffsetFromLeader = 0.0;
    v50[v21++] = v26;
    v37 = v26->m_nTrainFlags;
    if ( v20 )
      goto LABEL_27;
    v26->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v37 | 8);
    if ( ppEngine )
      *ppEngine = v26;
    v25 = 0;
LABEL_28:
    *(_WORD *)&v26->m_nTrainFlags |= 0x10u;
    if ( ppLastCarriage )
      *ppLastCarriage = v26;
    v26->pLinkedToForward = v20;
    if ( v25 == 1 )
    {
      CEntity::RegisterReference(v20, &v26->pLinkedToForward);
      v26->pLinkedToBackward = 0;
      v20->pLinkedToBackward = v26;
      CEntity::RegisterReference(v26, &v20->pLinkedToBackward);
    }
    else
    {
      v26->pLinkedToBackward = 0;
    }
    (*((void (__fastcall **)(CTrain *))v26->_vptr$CPlaceable + 11))(v26);
    v38 = *v22++;
    v20 = v26;
  }
  while ( v38 );
  v39 = v21 - 1;
  if ( v21 - 1 >= 0 )
  {
    do
    {
      v40 = (CEntity *)v50[v39];
      CWorld::Remove(v40);
      CWorld::Add(v40);
      --v39;
    }
    while ( v39 > -1 );
  }
  v41 = *ppEngine;
  if ( (*ppEngine)->m_nModelIndex != 449 )
  {
    v42 = 0;
    CPopulation::AddPedInCar(v41, 1, -1, 0, 0, 0);
    if ( !*ppEngine )
      goto LABEL_43;
    pDriver = (*ppEngine)->pDriver;
    p_pLinkedToBackward = ppEngine;
    if ( pDriver )
    {
      CPedIntelligence::SetPedDecisionMakerType(pDriver->m_pPedIntelligence, 6);
      p_pLinkedToBackward = ppEngine;
    }
    goto LABEL_42;
  }
  v42 = *ppEngine;
  if ( v41 )
  {
    while ( v42->m_nModelIndex != 538 )
    {
      p_pLinkedToBackward = &v42->pLinkedToBackward;
LABEL_42:
      v42 = *p_pLinkedToBackward;
LABEL_43:
      if ( !v42 )
        goto LABEL_46;
    }
    v45 = 1024;
  }
  else
  {
LABEL_46:
    v45 = 0;
  }
  v46 = *ppEngine;
  if ( *ppEngine )
  {
    do
    {
      pLinkedToBackward = v46->pLinkedToBackward;
      v46->m_nTrainFlags = (CTrain::CTrainFlags)(*(_WORD *)&v46->m_nTrainFlags & 0xFBFF | v45);
      v46 = pLinkedToBackward;
    }
    while ( pLinkedToBackward );
  }
}
// 57F550: variables would overlap: ^A4.4 and ^A4.8
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];
// 57F550: using guessed type _DWORD var_68[26];

//----- (0057F8E8) --------------------------------------------------------
void __fastcall CTrain::FindPositionOnTrackFromCoors(CTrain *this)
{
  __int128 v1; // q8
  int TrainType; // r9
  int v3; // r1
  int v4; // r11
  int v5; // r6
  int v6; // r5
  int v7; // r1
  CTrainNode *v8; // r0
  int v9; // r8
  CTrain *v10; // r3
  float32x2_t v11; // d17
  CMatrix *m_pMat; // r1
  float32x2_t v13; // d1
  float32x2_t *p_tx; // r2
  unsigned __int64 v15; // d0
  float v16; // s6
  float32x2_t v17; // d0
  unsigned __int64 v18; // d4
  float v19; // s19
  CTrainNode *v20; // r6
  unsigned int lighting; // r0
  float v22; // s2
  float v23; // s4
  float v24; // s0
  CTrainNode *v25; // r0
  CTrainNode *v26; // r6
  float v27; // s23
  unsigned int m_lighting; // r0
  int m_nModelIndex; // r1
  float v30; // s2
  float v31; // s2
  CColModel *m_pColModel; // r1
  float v33; // s2
  float x; // s2
  float y; // s4
  int v36; // r2
  float z; // s6
  unsigned int m_nTrainFlags; // r1
  float v39; // s8
  float v40; // s2
  float v41; // s0
  CEntity *refEntityPtr; // [sp+3Ch] [bp-9Ch] BYREF
  CColPoint colPoint; // [sp+40h] [bp-98h] BYREF
  CVector vecStart; // [sp+6Ch] [bp-6Ch] BYREF

  TrainType = this->TrainType;
  v3 = NumTrackNodes[TrainType];
  if ( v3 < 1 )
    return;
  v4 = 0;
  v5 = this->TrainType;
  v6 = 0;
  while ( 1 )
  {
    v7 = ++v6 % v3;
    v8 = pTrackNodes[v5];
    v9 = v7;
    LODWORD(v1) = *(_DWORD *)&v8[v4].CoorX;
    DWORD2(v1) = *(_DWORD *)&v8[v7].CoorX;
    v10 = this;
    *((float32x2_t *)&v1 + 1) = vcvt_f32_s32((int32x2_t)vmovl_s16(*((int16x4_t *)&v1 + 1)).n128_u64[0]);
    m_pMat = this->m_pMat;
    v13.n64_u64[0] = vmul_f32(
                       vcvt_f32_s32((int32x2_t)vmovl_s16(*(int16x4_t *)&v1).n128_u64[0]),
                       (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
    p_tx = (float32x2_t *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = (float32x2_t *)&this->m_transform;
    *(float32x2_t *)&v1 = vmul_f32(v11, (float32x2_t)0x3E0000003E000000LL);
    *((float32x2_t *)&v1 + 1) = vsub_f32(v13, *(float32x2_t *)&v1);
    v15 = vmul_f32(*((float32x2_t *)&v1 + 1), *((float32x2_t *)&v1 + 1)).n64_u64[0];
    *((float32x2_t *)&v1 + 1) = vsub_f32((float32x2_t)p_tx->n64_u64[0], v13);
    v16 = sqrtf((float)(*(float *)&v15 + *((float *)&v15 + 1)) + 0.0);
    v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&v1, v13).n64_u64[0];
    v18 = vmul_f32(v17, *((float32x2_t *)&v1 + 1)).n64_u64[0];
    v19 = (float)((float)(*(float *)&v18 + *((float *)&v18 + 1)) + 0.0) / (float)(v16 * v16);
    if ( v19 <= 0.001 || v19 >= 1.001 )
      goto LABEL_21;
    v20 = &v8[v4];
    if ( sqrtf(
           (float)((float)((float)(v19 * 0.0) + 0.0) * (float)((float)(v19 * 0.0) + 0.0))
         + (float)((float)((float)((float)(v13.n64_f32[0] + (float)(v17.n64_f32[0] * v19)) - p_tx->n64_f32[0])
                         * (float)((float)(v13.n64_f32[0] + (float)(v17.n64_f32[0] * v19)) - p_tx->n64_f32[0]))
                 + (float)((float)((float)(v13.n64_f32[1] + (float)(v17.n64_f32[1] * v19)) - p_tx->n64_f32[1])
                         * (float)((float)(v13.n64_f32[1] + (float)(v17.n64_f32[1] * v19)) - p_tx->n64_f32[1])))) < 3.0 )
      break;
    if ( v20->bLightingHasBeenCalculated )
    {
      lighting = v20->lighting;
    }
    else
    {
      LODWORD(vecStart.x) = v13.n64_u32[0];
      vecStart.y = (float)v20->CoorY * 0.125;
      vecStart.z = (float)((float)v20->CoorZ * 0.125) + 1.0;
      if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
      {
        lighting = colPoint.m_dataB.m_lighting;
        v20->lighting = colPoint.m_dataB.m_lighting;
        v20->bLightingHasBeenCalculated = 1;
      }
      else
      {
        lighting = 72;
      }
      v10 = this;
      LOBYTE(TrainType) = this->TrainType;
    }
    v22 = (float)(lighting >> 4);
    v23 = (float)((float)(lighting & 0xF) * 0.5) / 15.0;
    v24 = CCustomBuildingDNPipeline::m_fDNBalanceParam;
    v25 = pTrackNodes[(unsigned __int8)TrainType];
    v26 = &v25[v9];
    v27 = (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam * (float)((float)(v22 * 0.5) / 15.0))
        + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam) * v23);
    if ( v26->bLightingHasBeenCalculated )
    {
      m_lighting = v26->lighting;
    }
    else
    {
      vecStart.x = (float)v25[v9].CoorX * 0.125;
      vecStart.y = (float)v26->CoorY * 0.125;
      vecStart.z = (float)((float)v26->CoorZ * 0.125) + 1.0;
      if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
      {
        m_lighting = colPoint.m_dataB.m_lighting;
        v26->lighting = colPoint.m_dataB.m_lighting;
        v26->bLightingHasBeenCalculated = 1;
      }
      else
      {
        m_lighting = 72;
      }
      v10 = this;
      LOBYTE(TrainType) = this->TrainType;
      v24 = CCustomBuildingDNPipeline::m_fDNBalanceParam;
    }
    v10->m_lightingFromCollision = v27
                                 + (float)(v19
                                         * (float)((float)((float)(v24
                                                                 * (float)((float)((float)(m_lighting >> 4) * 0.5) / 15.0))
                                                         + (float)((float)(1.0 - v24)
                                                                 * (float)((float)((float)(m_lighting & 0xF) * 0.5)
                                                                         / 15.0)))
                                                 - v27));
LABEL_21:
    v5 = (unsigned __int8)TrainType;
    ++v4;
    v3 = NumTrackNodes[(unsigned __int8)TrainType];
    if ( v6 >= v3 )
      return;
  }
  m_nModelIndex = this->m_nModelIndex;
  v30 = (float)v20->LengthFromStart / 3.0;
  v31 = v30 + (float)(v19 * (float)((float)((float)v8[v9].LengthFromStart / 3.0) - v30));
  this->PositionOnTrack = v31;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel;
  v33 = v31 + (float)((float)(m_pColModel->m_boxBound.m_vecMax.y - m_pColModel->m_boxBound.m_vecMin.y) * -0.5);
  this->PositionOnTrack = v33;
  if ( v33 < 0.0 )
    this->PositionOnTrack = v33 + TotalLengthOfTrack[(unsigned __int8)TrainType];
  x = this->m_vecMoveSpeed.x;
  y = this->m_vecMoveSpeed.y;
  v36 = 0;
  z = this->m_vecMoveSpeed.z;
  m_nTrainFlags = (unsigned __int16)this->m_nTrainFlags;
  v39 = (float)((float)(x * x) + (float)(y * y)) + (float)(z * z);
  v40 = (float)((float)(v17.n64_f32[0] * x) + (float)(v17.n64_f32[1] * y)) + (float)(z * 0.0);
  v41 = sqrtf(v39);
  this->LinearSpeed = v41;
  if ( v40 > 0.0 )
    v36 = 1;
  if ( ((m_nTrainFlags >> 6) & 1) == v36 )
    this->LinearSpeed = -v41;
}
// 57F99A: variable 'v1' is possibly undefined
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];

//----- (0057FD1C) --------------------------------------------------------
void CTrain::RemoveMissionTrains()
{
  CVehiclePool *v0; // r11
  int32 m_nSize; // r0
  int v2; // r4
  int v3; // r6
  uint8 *v4; // r5

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 2604 * m_nSize - 1164;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        v4 = &(*v0->m_aStorage)[v3];
        if ( v4 != (uint8 *)&elf_hash_bucket[297]
          && *(_DWORD *)&(*v0->m_aStorage)[v3] == 6
          && v4 - 1440 != (uint8 *)FindPlayerVehicle(-1, 0)
          && (v4[44] & 0x20) != 0 )
        {
          CWorld::Remove((CEntity *)v4 - 24);
          (*(void (__fastcall **)(uint8 *))(*((_DWORD *)v4 - 360) + 4))(v4 - 1440);
        }
      }
      --v2;
      v3 -= 2604;
    }
    while ( v2 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (0057FDB0) --------------------------------------------------------
void __fastcall CTrain::RemoveOneMissionTrain(CTrain *pEngine)
{
  CTrain *v1; // r4
  CTrain *pLinkedToBackward; // r5

  v1 = pEngine;
  if ( pEngine )
  {
    do
    {
      pLinkedToBackward = v1->pLinkedToBackward;
      CWorld::Remove(v1);
      (*((void (__fastcall **)(CTrain *))v1->_vptr$CPlaceable + 1))(v1);
      v1 = pLinkedToBackward;
    }
    while ( pLinkedToBackward );
  }
}

//----- (0057FDD8) --------------------------------------------------------
void CTrain::RemoveAllTrains()
{
  CVehiclePool *v0; // r9
  int32 m_nSize; // r6
  CEntity *v2; // r10
  int v3; // r5
  CVehicle *v4; // r4
  _BOOL4 v5; // r0
  CVehicle *m_pLod; // r4
  _BOOL4 v7; // r0

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  while ( m_nSize )
  {
    if ( (v0->m_aFlags[--m_nSize] & 0x80u) == 0 )
    {
      v2 = (CEntity *)v0->m_aStorage[m_nSize];
      if ( v2 )
      {
        if ( v2[24]._vptr$CPlaceable == (int (**)(void))&byte_6 )
        {
          v3 = 0;
          v4 = (CVehicle *)v0->m_aStorage[m_nSize];
          do
          {
            v5 = v4 == FindPlayerVehicle(-1, 0);
            v4 = *(CVehicle **)&v4[1].m_nScanCode;
            v3 |= v5;
          }
          while ( v4 );
          m_pLod = (CVehicle *)v2;
          do
          {
            v7 = m_pLod == FindPlayerVehicle(-1, 0);
            m_pLod = (CVehicle *)m_pLod[1].m_pLod;
            v3 |= v7;
          }
          while ( m_pLod );
          if ( !(v3 << 31) )
          {
            CWorld::Remove(v2);
            (*((void (__fastcall **)(CEntity *))v2->_vptr$CPlaceable + 1))(v2);
          }
        }
      }
    }
  }
}
// 6: using guessed type char byte_6;
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (0057FE7C) --------------------------------------------------------
void CTrain::ReleaseMissionTrains()
{
  CVehiclePool *v0; // r8
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r5
  uint8 *v4; // r4

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 2604 * m_nSize - 1164;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        v4 = &(*v0->m_aStorage)[v3];
        if ( v4 != (uint8 *)&elf_hash_bucket[297]
          && *(_DWORD *)&(*v0->m_aStorage)[v3] == 6
          && v4 - 1440 != (uint8 *)FindPlayerVehicle(-1, 0) )
        {
          *((_WORD *)v4 + 22) &= ~0x20u;
        }
      }
      --v2;
      v3 -= 2604;
    }
    while ( v2 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0057FEEC) --------------------------------------------------------
void __fastcall CTrain::ReleaseOneMissionTrain(CTrain *pEngine)
{
  CTrain *pLinkedToBackward; // r2

  if ( pEngine )
  {
    do
    {
      pLinkedToBackward = pEngine->pLinkedToBackward;
      *(_WORD *)&pEngine->m_nTrainFlags &= ~0x20u;
      pEngine = pLinkedToBackward;
    }
    while ( pLinkedToBackward );
  }
}

//----- (0057FF0C) --------------------------------------------------------
void __fastcall CTrain::SetTrainSpeed(CTrain *pTrain, float NewSpeed)
{
  char m_nTrainFlags; // r1
  float *p_LinearSpeed; // r0

  m_nTrainFlags = (char)pTrain->m_nTrainFlags;
  p_LinearSpeed = &pTrain->LinearSpeed;
  *p_LinearSpeed = NewSpeed / 50.0;
  if ( (m_nTrainFlags & 0x40) == 0 )
    *p_LinearSpeed = -(float)(NewSpeed / 50.0);
}

//----- (0057FF38) --------------------------------------------------------
void __fastcall CTrain::SetTrainCruiseSpeed(CTrain *pTrain, float NewSpeed)
{
  pTrain->AutoPilot.CruiseSpeed = (unsigned int)NewSpeed;
}

//----- (0057FF4A) --------------------------------------------------------
CTrain *__fastcall CTrain::FindCaboose(CTrain *pEngine)
{
  CTrain *v1; // r1

  do
  {
    v1 = pEngine;
    pEngine = pEngine->pLinkedToBackward;
  }
  while ( pEngine );
  return v1;
}

//----- (0057FF58) --------------------------------------------------------
CTrain *__fastcall CTrain::FindEngine(CTrain *pEngine)
{
  CTrain *v1; // r1

  do
  {
    v1 = pEngine;
    pEngine = pEngine->pLinkedToForward;
  }
  while ( pEngine );
  return v1;
}

//----- (0057FF66) --------------------------------------------------------
CTrain *__fastcall CTrain::FindCarriage(CTrain *pEngine, UInt8 CarriageNumber)
{
  int v2; // r2

  if ( CarriageNumber )
  {
    v2 = 0;
    while ( 1 )
    {
      pEngine = pEngine->pLinkedToBackward;
      if ( !pEngine )
        break;
      if ( (unsigned int)(unsigned __int8)++v2 >= CarriageNumber )
        return pEngine;
    }
    return 0;
  }
  return pEngine;
}

//----- (0057FF88) --------------------------------------------------------
void CTrain::DoTrainGenerationAndRemoval()
{
  float32x2_t v0; // d2
  float32x2_t v1; // d6
  int16x4_t v2; // d16
  uint32 v3; // r0
  uint32 v4; // r4
  float32x2_t v5; // d16
  unsigned __int64 v6; // d0
  float32x2_t v7; // d16
  unsigned __int64 v8; // d0
  float32x2_t v9; // d16
  unsigned __int64 v10; // d0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float32x2_t v13; // d16
  unsigned __int64 v14; // d0
  unsigned __int64 v15; // d0
  unsigned int v16; // r5
  float v17; // s16
  CVehiclePool *v18; // r10
  int v19; // r0
  int32 i; // r6
  int v21; // r2
  int v22; // r2
  uint8 *v23; // r5
  int v24; // r11
  CVehicle *m_pLod; // r4
  CMatrix *m_pMat; // r0
  float32x2_t *p_tx; // r1
  CSimpleTransform *p_m_transform; // r0
  unsigned __int64 v29; // d0
  _BOOL4 v30; // r0
  int v31; // r1
  uint8 *v32; // r4
  bool v33; // zf
  CSimpleTransform *v34; // r1
  float32x2_t v35; // d9
  CTrainNode *v36; // r0
  float CoorZ; // s0
  float32x2_t v38; // d11
  int16x4_t v39; // d16
  unsigned __int64 v40; // d1
  float v41; // s20
  bool *v42; // r5
  char v43; // r0
  int v44; // r1
  Int32 v45; // r8
  unsigned __int64 v46; // d0
  int16x4_t v47; // d16
  unsigned __int64 v48; // d0
  float v49; // s22
  char v50; // r0
  int v51; // r1
  Int32 v52; // r10
  unsigned __int64 v53; // d0
  Int32 *v54; // r4
  int v55; // r1
  int32 v56; // r0
  int32 *v57; // r4
  int32 v58; // t1
  int32 v59; // t1
  CSimpleTransform *v60; // r6
  float32x2_t v61; // d16
  int16x4_t v62; // d16
  float32x2_t v63; // d0
  Int32 v64; // r4
  int v65; // r0
  int v66; // r0
  float32x2_t v67; // d16
  RwReal x; // r1
  __int16 v69; // r2
  int *v70; // r6
  float v71; // s10
  int j; // r6
  float v73; // s0
  Int32 *v74; // r4
  int32 v75; // r0
  int32 *v76; // r4
  int32 v77; // t1
  int32 v78; // t1
  CVector v79; // [sp+44h] [bp-64h] BYREF
  CVector v80; // [sp+50h] [bp-58h] BYREF
  CVector v81; // 0:r0.12
  CVector v82; // 0:r0.12

  v3 = CTimer::m_snTimeInMilliseconds;
  v4 = CTimer::m_snPreviousTimeInMilliseconds;
  if ( CTimer::m_snTimeInMilliseconds / 0xBB8 != CTimer::m_snPreviousTimeInMilliseconds / 0xBB8 )
  {
    CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 0;
    FindPlayerCoors(&v80, -1);
    v5.n64_u64[0] = vsub_f32(*(float32x2_t *)&CTrain::aStationCoors[0].x, *(float32x2_t *)&v80.x).n64_u64[0];
    v6 = vmul_f32(v5, v5).n64_u64[0];
    if ( sqrtf(*(float *)&v6 + *((float *)&v6 + 1)) < 60.0 )
      CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 1;
    FindPlayerCoors(&v80, -1);
    v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&CTrain::aStationCoors[1].x, *(float32x2_t *)&v80.x).n64_u64[0];
    v8 = vmul_f32(v7, v7).n64_u64[0];
    if ( sqrtf(*(float *)&v8 + *((float *)&v8 + 1)) < 60.0 )
      CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 1;
    FindPlayerCoors(&v80, -1);
    v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&CTrain::aStationCoors[2].x, *(float32x2_t *)&v80.x).n64_u64[0];
    v10 = vmul_f32(v9, v9).n64_u64[0];
    if ( sqrtf(*(float *)&v10 + *((float *)&v10 + 1)) < 60.0 )
      CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 1;
    FindPlayerCoors(&v80, -1);
    v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&CTrain::aStationCoors[3].x, *(float32x2_t *)&v80.x).n64_u64[0];
    v12 = vmul_f32(v11, v11).n64_u64[0];
    if ( sqrtf(*(float *)&v12 + *((float *)&v12 + 1)) < 60.0 )
      CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 1;
    FindPlayerCoors(&v80, -1);
    v13.n64_u64[0] = vsub_f32(*(float32x2_t *)&CTrain::aStationCoors[4].x, *(float32x2_t *)&v80.x).n64_u64[0];
    v14 = vmul_f32(v13, v13).n64_u64[0];
    if ( sqrtf(*(float *)&v14 + *((float *)&v14 + 1)) < 60.0 )
      CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 1;
    FindPlayerCoors(&v80, -1);
    v2.n64_u64[0] = vsub_f32(*(float32x2_t *)&CTrain::aStationCoors[5].x, *(float32x2_t *)&v80.x).n64_u64[0];
    v15 = vmul_f32(v2, v2).n64_u64[0];
    if ( sqrtf(*(float *)&v15 + *((float *)&v15 + 1)) < 60.0 )
      CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation = 1;
    v4 = CTimer::m_snPreviousTimeInMilliseconds;
    v3 = CTimer::m_snTimeInMilliseconds;
  }
  v16 = 950;
  v17 = 70.0;
  if ( CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation )
  {
    v17 = 100.0;
    v16 = 1;
  }
  if ( v3 / v16 != v4 / v16 )
  {
    v18 = CPools::ms_pVehiclePool;
    v19 = 0;
    for ( i = CPools::ms_pVehiclePool->m_nSize; i; v19 = 1 )
    {
      v21 = 2604 * i--;
      v22 = v21 - 2604;
      while ( 1 )
      {
        if ( (v18->m_aFlags[i] & 0x80u) == 0 )
        {
          v23 = &(*v18->m_aStorage)[v22];
          if ( v23 )
          {
            if ( *((_DWORD *)v23 + 361) == 6 && (*((_WORD *)v23 + 742) & 0x28) == 8 )
              break;
          }
        }
        --i;
        v22 -= 2604;
        if ( i == -1 )
          goto LABEL_37;
      }
      v24 = 1;
      m_pLod = (CVehicle *)&(*v18->m_aStorage)[v22];
      do
      {
        m_pMat = m_pLod->m_pMat;
        p_tx = (float32x2_t *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = (float32x2_t *)&m_pLod->m_transform;
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        v2.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.x, (float32x2_t)p_tx->n64_u64[0]).n64_u64[0];
        v29 = vmul_f32(v2, v2).n64_u64[0];
        v30 = m_pLod != FindPlayerVehicle(-1, 0);
        v31 = 0;
        m_pLod = (CVehicle *)m_pLod[1].m_pLod;
        if ( sqrtf(*(float *)&v29 + *((float *)&v29 + 1)) >= 220.0 )
          v31 = 1;
        v24 &= v30 & v31;
      }
      while ( m_pLod );
      if ( v24 == 1 )
      {
        do
        {
          v32 = (uint8 *)*((_DWORD *)v23 + 378);
          CWorld::Remove((CEntity *)v23);
          (*(void (__fastcall **)(uint8 *))(*(_DWORD *)v23 + 4))(v23);
          v23 = v32;
        }
        while ( v32 );
      }
    }
LABEL_37:
    if ( !CTrain::bDisableRandomTrains )
    {
      if ( CTrain::GenTrain_Status != 1 )
      {
        v33 = CTrain::GenTrain_Status == 0;
        if ( !CTrain::GenTrain_Status )
          v33 = v19 << 31 == 0;
        if ( !v33 )
          return;
        v34 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          v34 = &TheCamera.m_transform;
        v35.n64_u64[0] = *(unsigned __int64 *)&v34->m_translate.x;
        CTrain::GenTrain_Track = 0;
        CTrain::GenTrain_GenerationNode = rand() % NumTrackNodes[0];
        v36 = pTrackNodes[CTrain::GenTrain_Track];
        v2.n64_u32[0] = *(_DWORD *)&v36[CTrain::GenTrain_GenerationNode].CoorX;
        CoorZ = (float)v36[CTrain::GenTrain_GenerationNode].CoorZ;
        v38.n64_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v2).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
        v39.n64_u64[0] = vsub_f32(v38, v35).n64_u64[0];
        v40 = vmul_f32(v39, v39).n64_u64[0];
        v41 = sqrtf(*(float *)&v40 + *((float *)&v40 + 1));
        if ( v41 < v17 )
        {
          FindPlayerCoors(&v80, -1);
          if ( v80.z < (float)((float)(CoorZ * 0.125) + 6.0)
            || (FindPlayerCoors(&v79, -1), (CCullZones::FindTunnelAttributesForCoors(v79) & 0x880) != 0)
            || (v81.z = CoorZ * 0.125,
                *(float32x2_t *)&v81.x = v38,
                (CCullZones::FindTunnelAttributesForCoors(v81) & 0x800) == 0) )
          {
            v42 = &CTrain::GenTrain_Direction;
            v43 = rand();
            CTrain::GenTrain_Direction = v43 & 1;
            if ( v41 < 170.0 )
            {
              v44 = CTrain::GenTrain_GenerationNode;
              while ( 1 )
              {
                v42 = (bool *)v44;
                if ( (v43 & 1) == 0 )
                  break;
                v45 = CTrain::GenTrain_Track;
                --v44;
                CTrain::GenTrain_GenerationNode = (Int32)(v42 - 1);
                if ( (int)v42 <= 0 )
                {
                  v44 += NumTrackNodes[CTrain::GenTrain_Track];
LABEL_55:
                  CTrain::GenTrain_GenerationNode = v44;
                }
                v39.n64_u32[0] = *(_DWORD *)&pTrackNodes[v45][v44].CoorX;
                v39.n64_u64[0] = vsub_f32(
                                   vmul_f32(
                                     vcvt_f32_s32((int32x2_t)vmovl_s16(v39).n128_u64[0]),
                                     (float32x2_t)0x3E0000003E000000LL),
                                   v35).n64_u64[0];
                v46 = vmul_f32(v39, v39).n64_u64[0];
                v41 = sqrtf(*(float *)&v46 + *((float *)&v46 + 1));
                if ( v41 >= 170.0 )
                  goto LABEL_57;
              }
              v45 = CTrain::GenTrain_Track;
              CTrain::GenTrain_GenerationNode = v44 + 1;
              v44 = (v44 + 1) % NumTrackNodes[CTrain::GenTrain_Track];
              goto LABEL_55;
            }
LABEL_57:
            CTrain::GenTrain_Status = 1;
            CTrain::GenTrain_TrainConfig = (CTrain::DoTrainGenerationAndRemoval(void)::DeterministicTrainConfig + 1) % 8;
            CTrain::DoTrainGenerationAndRemoval(void)::DeterministicTrainConfig = (CTrain::DoTrainGenerationAndRemoval(void)::DeterministicTrainConfig
                                                                                 + 1)
                                                                                % 8;
            if ( v41 > 220.0 )
              CTrain::GenTrain_GenerationNode = (Int32)v42;
          }
        }
        if ( CTrain::GenTrain_Status )
          return;
        if ( CWeather::WeatherRegion != 2 )
          return;
        CTrain::GenTrain_Track = 1;
        CTrain::GenTrain_GenerationNode = rand() % NumTrackNodes[1];
        v39.n64_u32[0] = *(_DWORD *)&pTrackNodes[CTrain::GenTrain_Track][CTrain::GenTrain_GenerationNode].CoorX;
        v47.n64_u64[0] = vsub_f32(
                           vmul_f32(
                             vcvt_f32_s32((int32x2_t)vmovl_s16(v39).n128_u64[0]),
                             (float32x2_t)0x3E0000003E000000LL),
                           v35).n64_u64[0];
        v48 = vmul_f32(v47, v47).n64_u64[0];
        v49 = sqrtf(*(float *)&v48 + *((float *)&v48 + 1));
        if ( v49 >= v17 )
          return;
        v50 = rand();
        CTrain::GenTrain_Direction = v50 & 1;
        if ( v49 >= 170.0 )
        {
LABEL_71:
          if ( v49 < 220.0 )
          {
            CTrain::GenTrain_Status = 1;
            CTrain::GenTrain_TrainConfig = rand() % 2 + 8;
          }
          return;
        }
        v51 = CTrain::GenTrain_GenerationNode;
        while ( (v50 & 1) != 0 )
        {
          v52 = CTrain::GenTrain_Track;
          CTrain::GenTrain_GenerationNode = v51 - 1;
          if ( v51 <= 0 )
          {
            v51 = NumTrackNodes[CTrain::GenTrain_Track] + v51 - 1;
            goto LABEL_69;
          }
          --v51;
LABEL_70:
          v47.n64_u32[0] = *(_DWORD *)&pTrackNodes[v52][v51].CoorX;
          v47.n64_u64[0] = vsub_f32(
                             vmul_f32(
                               vcvt_f32_s32((int32x2_t)vmovl_s16(v47).n128_u64[0]),
                               (float32x2_t)0x3E0000003E000000LL),
                             v35).n64_u64[0];
          v53 = vmul_f32(v47, v47).n64_u64[0];
          v49 = sqrtf(*(float *)&v53 + *((float *)&v53 + 1));
          if ( v49 >= 170.0 )
            goto LABEL_71;
        }
        v52 = CTrain::GenTrain_Track;
        CTrain::GenTrain_GenerationNode = v51 + 1;
        v51 = (v51 + 1) % NumTrackNodes[CTrain::GenTrain_Track];
LABEL_69:
        CTrain::GenTrain_GenerationNode = v51;
        goto LABEL_70;
      }
      v54 = TrainConfigs[CTrain::GenTrain_TrainConfig];
      v55 = 1;
      v58 = *v54;
      v57 = v54 + 1;
      v56 = v58;
      do
      {
        if ( CStreaming::ms_aInfoForModel[v56].m_status != 1 )
        {
          CStreaming::RequestModel(v56, 8);
          v55 = 0;
        }
        v59 = *v57++;
        v56 = v59;
      }
      while ( v59 );
      if ( v55 << 31 )
      {
        v2.n64_u32[0] = *(_DWORD *)&pTrackNodes[CTrain::GenTrain_Track][CTrain::GenTrain_GenerationNode].CoorX;
        v60 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        v61.n64_u64[0] = vmul_f32(vcvt_f32_s32((int32x2_t)vmovl_s16(v2).n128_u64[0]), (float32x2_t)0x3E0000003E000000LL).n64_u64[0];
        if ( !TheCamera.m_pMat )
          v60 = &TheCamera.m_transform;
        v62.n64_u64[0] = vsub_f32(v61, *(float32x2_t *)&v60->m_translate.x).n64_u64[0];
        v63.n64_u64[0] = vmul_f32(v62, v62).n64_u64[0];
        if ( sqrtf(v63.n64_f32[0] + v63.n64_f32[1]) > 60.0 )
        {
          v82.z = 0.0;
          *(_QWORD *)&v82.x = 0LL;
          CTrain::CreateMissionTrain(
            v82,
            CTrain::GenTrain_Direction,
            CTrain::GenTrain_TrainConfig,
            (CTrain **)&v80,
            0,
            CTrain::GenTrain_GenerationNode,
            CTrain::GenTrain_Track,
            0);
          v64 = CTrain::GenTrain_Track;
          v65 = rand();
          if ( v64 )
          {
            v66 = v65 % 7 + 7;
          }
          else
          {
            v62.n64_u32[0] = *(_DWORD *)&pTrackNodes[CTrain::GenTrain_Track][CTrain::GenTrain_GenerationNode].CoorX;
            v67.n64_u64[0] = vadd_f32(
                               vmul_f32(
                                 vcvt_f32_s32((int32x2_t)vmovl_s16(v62).n128_u64[0]),
                                 (float32x2_t)0x3E0000003E000000LL),
                               (float32x2_t)0x44DAC000C50AE000LL).n64_u64[0];
            v66 = v65 % 30 + 15;
            v63.n64_u64[0] = vmul_f32(v67, v67).n64_u64[0];
            if ( sqrtf(v63.n64_f32[0] + v63.n64_f32[1]) < 300.0 )
              v66 /= 2;
          }
          x = v80.x;
          if ( *(_BYTE *)(LODWORD(v80.x) + 1492) )
          {
            v63.n64_u32[0] = 1112014848;
            v69 = *(_WORD *)(LODWORD(v80.x) + 1484);
          }
          else
          {
            v69 = *(_WORD *)(LODWORD(v80.x) + 1484);
            v70 = dword_580A1C;
            if ( (v69 & 0x40) == 0 )
              v70 = &dword_580A1C[1];
            v71 = *(float *)v70;
            v63.n64_u32[0] = 1176256512;
            for ( j = 0; j != 6; ++j )
            {
              for ( v1.n64_f32[0] = v71 + (float)(StationDist[j] - *(float *)(LODWORD(v80.x) + 1468));
                    v1.n64_f32[0] > (float)(TotalLengthOfTrack[0] * 0.5);
                    v1.n64_f32[0] = v1.n64_f32[0] - TotalLengthOfTrack[0] )
              {
                ;
              }
              while ( v1.n64_f32[0] < (float)(TotalLengthOfTrack[0] * -0.5) )
                v1.n64_f32[0] = TotalLengthOfTrack[0] + v1.n64_f32[0];
              if ( (v69 & 0x40) != 0 )
              {
                if ( v1.n64_f32[0] > 0.0 )
                  v63.n64_u64[0] = vmin_f32(v1, v63).n64_u64[0];
              }
              else if ( v1.n64_f32[0] < 0.0 )
              {
                v1.n64_f32[0] = -v1.n64_f32[0];
                v63.n64_u64[0] = vmin_f32(v63, v1).n64_u64[0];
              }
            }
            if ( v63.n64_f32[0] >= 500.0 )
              v63.n64_u32[0] = 1203982336;
            else
              v63.n64_f32[0] = (float)(1.0 - (float)((float)(500.0 - v63.n64_f32[0]) / 500.0)) * 50.0;
          }
          v0.n64_f32[0] = (float)v66;
          v73 = vmin_f32(v63, v0).n64_f32[0] / 50.0;
          if ( (v69 & 0x40) == 0 )
            v73 = -v73;
          *(_BYTE *)(LODWORD(v80.x) + 980) = v66;
          *(float *)(LODWORD(x) + 1464) = v73;
        }
        v74 = TrainConfigs[CTrain::GenTrain_TrainConfig];
        v77 = *v74;
        v76 = v74 + 1;
        v75 = v77;
        do
        {
          CStreaming::SetModelIsDeletable(v75);
          CStreaming::SetModelTxdIsDeletable(*(v76 - 1));
          v78 = *v76++;
          v75 = v78;
        }
        while ( v78 );
        CTrain::GenTrain_Status = 0;
      }
    }
  }
}
// 580336: variable 'v2' is possibly undefined
// 5808C0: variable 'v1' is possibly undefined
// 580910: variable 'v0' is possibly undefined
// 580A1C: using guessed type int dword_580A1C[2];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 6789B8: using guessed type int (*NumTrackNodes_ptr)[4];
// A12EB4: using guessed type char CTrain::DoTrainGenerationAndRemoval(void)::bPlayerNearStation;

//----- (00580AD0) --------------------------------------------------------
bool __fastcall CTrain::IsRoomForPedToLeaveCar(CTrain *this, uint32 nDoor, CVector *pvecCarJackOffset)
{
  return 1;
}

//----- (00580AD4) --------------------------------------------------------
CTrain *__fastcall CTrain::FindNearestTrain(CVector Coors, int bOnlyEngine)
{
  int32 m_nSize; // r2
  float x; // s0
  float v4; // s6
  float y; // s2
  CTrain *result; // r0
  CTrain *v7; // r4
  int v8; // r0
  float v9; // s4
  int i; // r5
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r1

  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  x = Coors.x;
  v4 = 10000000.0;
  y = Coors.y;
  result = 0;
  do
  {
    v7 = result;
    v8 = 2604 * m_nSize;
    v9 = v4;
    --m_nSize;
    for ( i = v8 - 2604; ; i -= 2604 )
    {
      if ( (CPools::ms_pVehiclePool->m_aFlags[m_nSize] & 0x80u) == 0 )
      {
        result = (CTrain *)&(*CPools::ms_pVehiclePool->m_aStorage)[i];
        if ( result )
        {
          if ( result->m_baseVehicleType == 6 )
          {
            m_pMat = result->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &result->m_transform;
            v4 = sqrtf(
                   (float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
                 + (float)((float)(p_tx->m_translate.y - y) * (float)(p_tx->m_translate.y - y)));
            if ( v4 < v9 && (bOnlyEngine != 1 || (*(_BYTE *)&result->m_nTrainFlags & 8) != 0) )
              break;
          }
        }
      }
      if ( --m_nSize == -1 )
        return v7;
    }
  }
  while ( m_nSize );
  return result;
}

//----- (00580B9C) --------------------------------------------------------
void __fastcall CTrain::SetNewTrainPosition(CTrain *pEngine, CVector NewCoors)
{
  CMatrix *m_pMat; // r12

  m_pMat = pEngine->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = NewCoors.x;
    pEngine->m_pMat->ty = NewCoors.y;
    pEngine->m_pMat->tz = NewCoors.z;
  }
  else
  {
    pEngine->m_transform.m_translate = NewCoors;
  }
  CTrain::FindPositionOnTrackFromCoors(pEngine);
}

//----- (00580BC6) --------------------------------------------------------
void __fastcall CTrain::Teleport(CTrain *this, CVector NewCoors, int bClearOrientation)
{
  RwReal z; // r8
  float y; // r6
  RwReal x; // r5
  CMatrix *m_pMat; // r1
  float *p_tz; // r1
  CMatrix *v9; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v13; // r0
  float v14; // s2
  float v15; // s4

  z = NewCoors.z;
  y = NewCoors.y;
  x = NewCoors.x;
  CWorld::Remove(this);
  m_pMat = this->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = x;
    this->m_pMat->ty = y;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = x;
    this->m_transform.m_translate.y = y;
  }
  *p_tz = z;
  if ( bClearOrientation )
  {
    v9 = this->m_pMat;
    if ( v9 )
    {
      tx = v9->tx;
      ty = v9->ty;
      tz = v9->tz;
      CMatrix::SetRotate(v9, 0.0, 0.0, 0.0);
      v13 = this->m_pMat;
      v14 = ty + v13->ty;
      v15 = tz + v13->tz;
      v13->tx = tx + v13->tx;
      v13->ty = v14;
      v13->tz = v15;
    }
    else
    {
      this->m_transform.m_heading = 0.0;
    }
  }
  this->m_vecTurnSpeed.y = 0.0;
  this->m_vecTurnSpeed.z = 0.0;
  *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
  sub_19B3E4(this);
}

//----- (00580C6C) --------------------------------------------------------
bool __fastcall CTrain::IsNextStationAllowed(CTrain *pTrain)
{
  CTrain *v1; // r1
  CTrain::CTrainFlags m_nTrainFlags; // r0
  float *p_PositionOnTrack; // r1
  float v4; // s0
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r0
  eLevelName LevelFromPosition; // r4

  do
  {
    v1 = pTrain;
    pTrain = pTrain->pLinkedToForward;
  }
  while ( pTrain );
  m_nTrainFlags = v1->m_nTrainFlags;
  p_PositionOnTrack = &v1->PositionOnTrack;
  v4 = *p_PositionOnTrack;
  v5 = *(_BYTE *)&m_nTrainFlags & 0x40;
  if ( StationDist[0] <= *p_PositionOnTrack )
  {
    if ( StationDist[1] <= v4 )
    {
      if ( StationDist[2] <= v4 )
      {
        if ( StationDist[3] <= v4 )
        {
          if ( StationDist[4] <= v4 )
          {
            if ( StationDist[5] > v4 )
              v6 = 5;
            else
              v6 = 6;
          }
          else
          {
            v6 = 4;
          }
        }
        else
        {
          v6 = 3;
        }
      }
      else
      {
        v6 = 2;
      }
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( (unsigned int)v6 > 5 )
    v6 = 0;
  if ( !v5 )
  {
    v7 = -1;
    if ( !v6 )
      v7 = 5;
    v6 += v7;
  }
  if ( fabsf(v4 - StationDist[v6]) < 100.0 )
  {
    v8 = v6 + ((unsigned __int16)v5 >> 5);
    v6 = v8 - 1;
    if ( v8 - 1 < 0 )
      v6 = v8 + 5;
    if ( v6 > 5 )
      v6 = 0;
  }
  LevelFromPosition = CTheZones::GetLevelFromPosition(&CTrain::aStationCoors[v6]);
  return (float)(CStats::GetStatValue(0xB5u) + 1.0) >= (float)LevelFromPosition;
}

//----- (00580DC8) --------------------------------------------------------
void __fastcall CTrain::FindNextStationPositionInDirection(
        bool bDir,
        float PosOnTrack,
        float *pResultPosOnTrack,
        Int32 *pStation)
{
  Int32 v4; // lr
  int v5; // r12
  int v6; // r1

  if ( StationDist[0] <= PosOnTrack )
  {
    if ( StationDist[1] <= PosOnTrack )
    {
      if ( StationDist[2] <= PosOnTrack )
      {
        if ( StationDist[3] <= PosOnTrack )
        {
          if ( StationDist[4] <= PosOnTrack )
          {
            if ( StationDist[5] > PosOnTrack )
              v4 = 5;
            else
              v4 = 6;
          }
          else
          {
            v4 = 4;
          }
        }
        else
        {
          v4 = 3;
        }
      }
      else
      {
        v4 = 2;
      }
    }
    else
    {
      v4 = 1;
    }
  }
  else
  {
    v4 = 0;
  }
  if ( (unsigned int)v4 > 5 )
    v4 = 0;
  if ( !bDir )
  {
    v5 = -1;
    if ( !v4 )
      v5 = 5;
    v4 += v5;
  }
  if ( fabsf(PosOnTrack - StationDist[v4]) < 100.0 )
  {
    v6 = -1;
    if ( bDir )
      v6 = 1;
    v4 += v6 + (v4 + v6 < 0 ? 6 : 0);
    if ( v4 > 5 )
      v4 = 0;
  }
  *pStation = v4;
  *pResultPosOnTrack = StationDist[v4];
}

//----- (00580F08) --------------------------------------------------------
void __fastcall CTrain::SkipToNextAllowedStation(CTrain *pTrain)
{
  CTrain *v1; // r6
  float PositionOnTrack; // r9
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r0
  int v7; // r10
  const CVector *v8; // r4
  eLevelName LevelFromPosition; // r5
  float v10; // s0
  int (*v11)(); // r1
  float v12; // s0
  float v13; // s2
  CMatrix *m_pMat; // r1
  float *p_tx; // r0

  do
  {
    v1 = pTrain;
    pTrain = pTrain->pLinkedToForward;
  }
  while ( pTrain );
  PositionOnTrack = v1->PositionOnTrack;
  do
  {
    v3 = *(_WORD *)&v1->m_nTrainFlags & 0x40;
    if ( StationDist[0] <= PositionOnTrack )
    {
      if ( StationDist[1] <= PositionOnTrack )
      {
        if ( StationDist[2] <= PositionOnTrack )
        {
          if ( StationDist[3] <= PositionOnTrack )
          {
            if ( StationDist[4] <= PositionOnTrack )
            {
              if ( StationDist[5] > PositionOnTrack )
                v4 = 5;
              else
                v4 = 6;
            }
            else
            {
              v4 = 4;
            }
          }
          else
          {
            v4 = 3;
          }
        }
        else
        {
          v4 = 2;
        }
      }
      else
      {
        v4 = 1;
      }
    }
    else
    {
      v4 = 0;
    }
    if ( (unsigned int)v4 > 5 )
      v4 = 0;
    if ( !v3 )
    {
      v5 = -1;
      if ( !v4 )
        v5 = 5;
      v4 += v5;
    }
    if ( fabsf(PositionOnTrack - StationDist[v4]) < 100.0 )
    {
      v6 = v4 + ((unsigned __int16)v3 >> 5);
      v4 = v6 - 1;
      if ( v6 - 1 < 0 )
        v4 = v6 + 5;
      if ( v4 > 5 )
        v4 = 0;
    }
    v7 = v4;
    PositionOnTrack = StationDist[v4];
    v8 = &CTrain::aStationCoors[v4];
    LevelFromPosition = CTheZones::GetLevelFromPosition(v8);
  }
  while ( (float)(CStats::GetStatValue(0xB5u) + 1.0) < (float)LevelFromPosition );
  v10 = -20.0;
  v11 = sub_58114C;
  if ( (*(_WORD *)&v1->m_nTrainFlags & 0x40) == 0 )
    v10 = 20.0;
  v12 = v10 + PositionOnTrack;
  if ( (*(_WORD *)&v1->m_nTrainFlags & 0x40) == 0 )
    v11 = (int (*)())&loc_581150;
  v13 = *(float *)v11;
  v1->PositionOnTrack = v12;
  v1->LinearSpeed = v13;
  CStreaming::LoadScene(v8);
  CStreaming::LoadAllRequestedModels(0);
  m_pMat = v1->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &v1->m_transform.m_translate.x;
  sub_18D250((unsigned int)(float)((float)(sqrtf(
                                             (float)((float)(v8->x - *p_tx) * (float)(v8->x - *p_tx))
                                           + (float)((float)(CTrain::aStationCoors[v7].y - p_tx[1])
                                                   * (float)(CTrain::aStationCoors[v7].y - p_tx[1])))
                                         / 20.0)
                                 + 23.0));
}
// 58114C: using guessed type int sub_58114C();

//----- (0058115C) --------------------------------------------------------
bool __fastcall CVehicle::IsComponentPresent(const CVehicle *this, int32 component)
{
  return 0;
}

//----- (00581168) --------------------------------------------------------
void __fastcall cTransmission::InitGearRatios(cTransmission *this)
{
  unsigned int m_nNumberOfGears; // r1
  float v2; // s0
  float m_fMaxVelocity; // s4
  int v4; // r3
  unsigned __int8 v5; // r1
  float v6; // s0
  float v7; // s2
  float v8; // s4
  tGearRatio *v9; // lr
  float v10; // s12
  float fMaxVelocity; // s10
  float v12; // s12
  float v13; // s14
  float v14; // s10
  float m_fMaxReverseVelocity; // r1

  m_nNumberOfGears = this->m_nNumberOfGears;
  v2 = (float)m_nNumberOfGears;
  m_fMaxVelocity = this->m_fMaxVelocity;
  this->m_GearRatio[5].fChangeUpVelocity = 0.0;
  this->m_GearRatio[5].fChangeDownVelocity = 0.0;
  *(_QWORD *)&this->m_GearRatio[4].fMaxVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[4].fChangeDownVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[2].fChangeDownVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[3].fChangeUpVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[0].fMaxVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[0].fChangeDownVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[1].fChangeUpVelocity = 0LL;
  *(_QWORD *)&this->m_GearRatio[2].fMaxVelocity = 0LL;
  if ( m_nNumberOfGears )
  {
    v4 = 1;
    v5 = 1;
    v6 = 1.0 / v2;
    v7 = m_fMaxVelocity * (float)(v6 * 0.5);
    v8 = m_fMaxVelocity - v7;
    do
    {
      v9 = &this->m_GearRatio[v4];
      v10 = v7 + (float)(v8 * (float)(v6 * (float)v5));
      fMaxVelocity = v9[-1].fMaxVelocity;
      v9->fMaxVelocity = v10;
      if ( v5 >= (unsigned int)this->m_nNumberOfGears )
      {
        v14 = this->m_fMaxVelocity;
      }
      else
      {
        v12 = v10 - fMaxVelocity;
        v13 = fMaxVelocity + (float)(v12 * 0.42);
        v14 = (float)(v12 * 0.6667) + fMaxVelocity;
        v9[1].fChangeDownVelocity = v13;
      }
      v9->fChangeUpVelocity = v14;
      v4 = ++v5;
    }
    while ( v5 <= (unsigned int)this->m_nNumberOfGears );
    cTransmission::InitGearRatios(void)::pGearRatio0 = v9 - 1;
    cTransmission::InitGearRatios(void)::pGearRatio1 = v9;
  }
  m_fMaxReverseVelocity = this->m_fMaxReverseVelocity;
  this->m_GearRatio[1].fChangeDownVelocity = -0.01;
  this->m_GearRatio[0].fMaxVelocity = m_fMaxReverseVelocity;
  this->m_GearRatio[0].fChangeUpVelocity = -0.01;
  this->m_GearRatio[0].fChangeDownVelocity = m_fMaxReverseVelocity;
}

//----- (00581260) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __fastcall cTransmission::CalculateDriveAcceleration(
        cTransmission *this,
        const float *fThrottleSetting,
        uint8 *nCurrentGear,
        float *fGearChangeCount,
        const float *v,
        float *pEngineRevs,
        float *pEngineForce,
        int nDriveWheelsOnGround,
        uint8 nFasterCheat)
{
  float32x2_t v9; // d1
  float32x2_t v10; // d2
  float32x2_t v11; // d4
  float v12; // s0
  float v13; // s2
  float v18; // s4
  float m_fMaxVelocity; // s6
  unsigned int v20; // r4
  tGearRatio *v21; // r9
  float fChangeUpVelocity; // s8
  char v23; // r5
  unsigned int m_nNumberOfGears; // r8
  float v25; // s0
  uint32 m_nFlags; // r5
  float v27; // s4
  float v28; // s10
  float v29; // s10
  float v30; // s4
  bool v31; // zf
  float v32; // s12
  float v33; // s6
  float v34; // s8
  float v35; // s2
  float v36; // s6
  float fChangeDownVelocity; // s6
  float v38; // s2
  float v39; // s6
  float **v40; // r1
  int v41; // s12
  float v42; // s14
  float v43; // s6
  bool v44; // fnf
  float v45; // s6
  float fMaxVelocity; // s2
  float v47; // s2

  v12 = 0.0;
  cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity = *v;
  v13 = cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity;
  if ( cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity < this->m_fMaxReverseVelocity )
    return v12;
  v18 = cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity;
  while ( 1 )
  {
    m_fMaxVelocity = this->m_fMaxVelocity;
    if ( v13 > m_fMaxVelocity )
      return v12;
    this->m_fVelocity = v13;
    v20 = *nCurrentGear;
    v21 = &this->m_GearRatio[v20];
    fChangeUpVelocity = v21->fChangeUpVelocity;
    if ( v13 <= fChangeUpVelocity )
      break;
    v23 = 1;
    if ( !*nCurrentGear && *fThrottleSetting <= 0.0 )
      goto LABEL_14;
LABEL_12:
    *nCurrentGear = v20 + v23;
    nFasterCheat = 0;
    nDriveWheelsOnGround = 0;
    pEngineForce = 0;
    pEngineRevs = 0;
    v13 = v18;
    if ( v18 < this->m_fMaxReverseVelocity )
      return v12;
  }
  if ( *nCurrentGear )
  {
    if ( v13 < v21->fChangeDownVelocity )
    {
      v23 = -1;
      if ( v20 != 1 || *fThrottleSetting < 0.0 )
        goto LABEL_12;
    }
  }
LABEL_14:
  m_nNumberOfGears = this->m_nNumberOfGears;
  if ( m_nNumberOfGears == 1 )
  {
    v25 = 1.0;
  }
  else if ( *nCurrentGear )
  {
    m_nFlags = this->m_nFlags;
    if ( (m_nFlags & 1) != 0 )
    {
      v28 = 5.0;
    }
    else
    {
      v28 = 4.0;
      if ( (m_nFlags & 2) == 0 )
        v28 = 3.0;
    }
    v27 = 1.0 - (float)((float)((float)v20 + -1.0) / (float)((float)m_nNumberOfGears + -1.0));
    v25 = (float)(v27 * (float)(v27 * v28)) + 1.0;
  }
  else
  {
    v25 = 4.5;
  }
  cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fCheat = 1.0;
  if ( nFasterCheat == 1 )
  {
    v29 = 1.0;
    cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fCheat = TRANSMISSION_AI_CHEAT_MULT;
    v30 = TRANSMISSION_AI_CHEAT_MULT;
  }
  else
  {
    v30 = 1.0;
    v29 = 1.0;
    if ( nFasterCheat == 2 )
      v29 = TRANSMISSION_NITROS_MULT;
  }
  v31 = pEngineRevs == 0;
  v32 = *fThrottleSetting;
  v12 = CTimer::ms_fTimeStep
      * (float)(*fThrottleSetting
              * (float)((float)(v30 * (float)(v25 * (float)(v29 * this->m_fEngineAcceleration))) / 2.5));
  cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fAcceleration = v12;
  if ( pEngineRevs )
    v31 = pEngineForce == 0;
  if ( !v31 )
  {
    if ( nDriveWheelsOnGround << 24 )
    {
      if ( v20 == 1 )
      {
        v36 = (float)(m_fMaxVelocity / (float)m_nNumberOfGears) * 0.3333;
        v34 = fChangeUpVelocity + v36;
        v35 = v13 + v36;
      }
      else if ( v20 )
      {
        fChangeDownVelocity = v21->fChangeDownVelocity;
        v34 = fChangeUpVelocity - fChangeDownVelocity;
        v35 = v13 - fChangeDownVelocity;
      }
      else
      {
        v33 = (float)(m_fMaxVelocity / (float)m_nNumberOfGears) * 0.3333;
        v34 = v33 - v21->fChangeDownVelocity;
        v35 = v33 - v13;
      }
      v38 = v35 / v34;
      v39 = v38 - *pEngineRevs;
      if ( nFasterCheat == 1 )
      {
        v40 = (float **)&TRANSMISSION_AI_CHEAT_INERTIA_MULT_ptr;
        goto LABEL_42;
      }
      if ( nFasterCheat == 2 )
      {
        v40 = &TRANSMISSION_NITROS_INERTIA_MULT_ptr;
LABEL_42:
        v39 = v39 * **v40;
      }
      v41 = 1036831949;
      v42 = 1.0;
      v43 = 1.0 - (float)(v39 * this->m_fEngineInertia);
      if ( v43 > 1.0 )
        v41 = 1.0;
      if ( v43 < 0.1 )
        v42 = *(float *)&v41;
      v44 = v43 < 0.1;
      if ( v43 > 1.0 )
        v43 = v42;
      if ( v44 )
        v43 = v42;
      v45 = (float)(TRANSMISSION_SMOOTHER_FRAC * *pEngineForce)
          + (float)((float)(1.0 - TRANSMISSION_SMOOTHER_FRAC) * v43);
      v12 = v12 * v45;
      cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fAcceleration = v12;
      *pEngineForce = v45;
      *pEngineRevs = v38;
    }
    else
    {
      v11.n64_u32[0] = 1.0;
      v9.n64_f32[0] = *pEngineRevs
                    + (float)((float)(CTimer::ms_fTimeStep * (float)(TRANSMISSION_FREE_ACCELERATION * fabsf(v32)))
                            / this->m_fEngineInertia);
      v9.n64_u64[0] = vmin_f32(v9, v11).n64_u64[0];
      *pEngineRevs = v9.n64_f32[0];
      *pEngineForce = 0.1;
    }
  }
  fMaxVelocity = this->m_GearRatio[*nCurrentGear].fMaxVelocity;
  if ( fMaxVelocity < 0.0
    && cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity < (float)(fMaxVelocity * v30) )
  {
    v9.n64_f32[0] = (float)(fMaxVelocity * v30)
                  - cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity;
LABEL_58:
    v9.n64_f32[0] = v9.n64_f32[0] / 0.05;
    v10.n64_u32[0] = 1.0;
    v12 = (float)(1.0 - vmin_f32(v9, v10).n64_f32[0]) * v12;
    cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fAcceleration = v12;
    return v12;
  }
  if ( fMaxVelocity > 0.0 )
  {
    v47 = fMaxVelocity * v30;
    if ( cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity > v47 )
    {
      v9.n64_f32[0] = cTransmission::CalculateDriveAcceleration(float const&,unsigned char &,float &,float const&,float *,float *,unsigned char,unsigned char)::fVelocity
                    - v47;
      goto LABEL_58;
    }
  }
  return v12;
}
// 581260: variables would overlap: ^24.4 and ^24.8
// 581260: variables would overlap: ^2C.1 and ^2C.8
// 67802C: using guessed type float *TRANSMISSION_NITROS_INERTIA_MULT_ptr;
// 678798: using guessed type float TRANSMISSION_AI_CHEAT_INERTIA_MULT_ptr;

//----- (00581640) --------------------------------------------------------
void __fastcall cTransmission::CalculateGearForSimpleCar(cTransmission *this, float CurrentVel, uint8 *nCurrentGear)
{
  unsigned int v4; // r3
  tGearRatio *v5; // r1
  unsigned int m_nNumberOfGears; // r0

  this->m_fVelocity = CurrentVel;
  v4 = *nCurrentGear;
  v5 = &this->m_GearRatio[v4];
  if ( v5->fChangeUpVelocity >= CurrentVel )
  {
    if ( v5->fChangeDownVelocity > CurrentVel )
    {
      if ( *nCurrentGear )
        LOBYTE(v4) = v4 - 1;
      *nCurrentGear = v4;
    }
  }
  else
  {
    m_nNumberOfGears = this->m_nNumberOfGears;
    if ( v4 < m_nNumberOfGears )
      LOBYTE(m_nNumberOfGears) = v4 + 1;
    *nCurrentGear = m_nNumberOfGears;
  }
}

//----- (00581690) --------------------------------------------------------
void __fastcall CRideAnimData::CRideAnimData(CRideAnimData *this)
{
  *(_QWORD *)&this->m_fDesiredLeanAngle = 0LL;
  *(_QWORD *)&this->m_fAnimLeanLeft = 0LL;
  *(_QWORD *)&this->m_animGroup = 0LL;
  *(_QWORD *)&this->m_fLeanAngle = 0LL;
}

//----- (005816A4) --------------------------------------------------------
void __fastcall CVehicle::CVehicle(CVehicle *this, UInt8 CreatedBy)
{
  __int16 v4; // r2
  UInt32 v5; // r0
  char v6; // r0
  CEntity::CEntityInfo m_info; // r1
  int m_nFlags; // r3
  int v9; // r2
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r1
  int v11; // r0
  int (***v12)(void); // r2
  char v13; // r12
  char v14; // r3
  CVehicle::CVehicleFlags v15; // kr00_8
  unsigned int v16; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  UInt32 v18; // r0

  CPhysical::CPhysical(this);
  this->_vptr$CPlaceable = (int (**)(void))&off_66E210;
  CAEVehicleAudioEntity::CAEVehicleAudioEntity(&this->m_VehicleAudioEntity);
  this->AutoPilot.VeryOldNode.Region = -1;
  this->AutoPilot.NewNode.Region = -1;
  this->AutoPilot.OldLink.Address = -1;
  this->AutoPilot.NewLink.Address = -1;
  this->AutoPilot.VeryOldLink.Address = -1;
  this->AutoPilot.OldNode.Region = -1;
  this->AutoPilot.aPathNodeList[0].Region = -1;
  this->AutoPilot.aPathNodeList[2].Region = -1;
  this->AutoPilot.aPathNodeList[1].Region = -1;
  this->AutoPilot.aPathNodeList[3].Region = -1;
  this->AutoPilot.aPathNodeList[4].Region = -1;
  this->AutoPilot.aPathNodeList[5].Region = -1;
  this->AutoPilot.aPathNodeList[6].Region = -1;
  this->AutoPilot.aPathNodeList[7].Region = -1;
  this->AutoPilot.TimeToLeaveLink = 0;
  this->AutoPilot.TimeToGetToNextLink = 1000;
  this->AutoPilot.TempAction = 0;
  *(_WORD *)&this->AutoPilot.InvertDirOldLink = 257;
  *(_DWORD *)&this->AutoPilot.OldLane = 0;
  this->AutoPilot.CruiseSpeed = 10;
  this->AutoPilot.NumPathNodes = 0;
  v4 = *(_WORD *)((char *)&this->AutoPilot + 75);
  this->AutoPilot.ActualSpeed = 10.0;
  this->AutoPilot.pTargetEntity = 0;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
  this->AutoPilot.LastTimeMoving = v5;
  this->AutoPilot.SpeedFromNodes = 0;
  this->AutoPilot.SpeedMultiplier = 1.0;
  this->AutoPilot.RecordingNumber = -1;
  this->AutoPilot.AISwitchToStraightLineDistance = 20;
  this->AutoPilot.LastTimeWeStartedTempActReverse = 0;
  *(_WORD *)&this->AutoPilot.WhatToTryForReverse = 0;
  this->AutoPilot.SpeedCheat = 0;
  this->AutoPilot.AimAheadOfTarget = 0;
  this->AutoPilot.FollowCarDistance = 10;
  this->AutoPilot.TargetReachedDist = 10;
  this->AutoPilot.Diversion = 0;
  *(_WORD *)((char *)&this->AutoPilot + 75) = v4 & 0xFC04;
  v6 = rand();
  this->AutoPilot.pObstructingEntity = 0;
  this->AutoPilot.MaxSpeedBuffer = 0.0;
  this->m_fGearChangeCount = 0.0;
  this->m_fWheelSpinForAudio = 0.0;
  this->m_fSteerAngle = 0.0;
  this->m_f2ndSteerAngle = 0.0;
  this->VehicleCreatedBy = CreatedBy;
  this->fSteer = 0.0;
  this->m_nCurrentGear = 1;
  this->ForcedRandomSeed = 0;
  m_info = this->m_info;
  *(_DWORD *)&this->m_nVehicleFlags = &loc_2000B0;
  m_nFlags = (int)this->m_nFlags;
  v9 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  this->AutoPilot.LaneChangeCounter = (v6 & 7) + 2;
  *(_DWORD *)&this->m_nFlags = m_nFlags | 0x200000;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v9 & 0xFFFFFFF8;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 0xF8 | 2);
  *((_DWORD *)&this->m_nVehicleFlags + 1) = *((_DWORD *)&this->m_nVehicleFlags + 1) & 0xF8000007 | (8
                                                                                                  * ((float)((float)((float)rand() * 4.6566e-10) + 0.0) < 0.0)) | 0x645000;
  CCarCtrl::UpdateCarCount(this, 0);
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  this->m_nHealth = 1000.0;
  this->ExtendedRemovalRange = 0;
  this->pDriver = 0;
  *(_DWORD *)&this->m_nNumPassengers = 0;
  this->m_nMaxPassengers = 8;
  v11 = 0;
  do
  {
    v12 = &this->_vptr$CPlaceable + v11++;
    v12[282] = 0;
  }
  while ( v11 < this->m_nMaxPassengers );
  v13 = *((_BYTE *)this + 1202);
  v14 = *((_BYTE *)this + 1203) & 0xF0;
  this->nUsedForCover = 0;
  this->m_pFire = 0;
  this->PacMansCollected = 0;
  this->m_cHorn = 0;
  this->m_nHornPattern = 0;
  this->m_NoHornCount = 0;
  this->NumOilSpillsToDo = 0;
  *(_QWORD *)&this->TimeOfLastShotFired = 0LL;
  *(_QWORD *)&this->GetOutOfCarTimer = 0LL;
  this->m_pTowingVehicle = 0;
  this->m_pVehicleBeingTowed = 0;
  *((_BYTE *)this + 1203) = v14;
  v15 = *p_m_nVehicleFlags;
  v16 = *((_DWORD *)&this->m_nVehicleFlags + 1) & 0xFFFFFF9F;
  this->m_bFireAutoFlare = 0;
  this->pBombOwner = 0;
  this->DontUseSmallerRemovalRange = 0;
  *(_DWORD *)p_m_nVehicleFlags = v15;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v16;
  this->CarAlarmState = 0;
  this->LastDamagedWeaponType = -1;
  this->m_nSpecialColModel = -1;
  this->m_nSoundIndex = 0;
  this->ComedyControlsState = 0;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  this->m_eDoorLockState = CARLOCK_UNLOCKED;
  this->m_LastTimePrimaryFired = 0;
  this->m_LastTimeSecondaryFired = 0;
  this->m_LastTimeGunFired = 0;
  this->pLastDamageEntity = 0;
  this->LastFrontHeight = 0.0;
  this->LastRearHeight = 0.0;
  this->pEntityWeAreOnForVisibilityCheck = 0;
  this->StoredCollPolys[1].bValidPolyStored = 0;
  this->StoredCollPolys[0].bValidPolyStored = 0;
  this->m_nRainHitCount = 0;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x10000000);
  *(_WORD *)&m_nPhysicalFlags = *(_WORD *)((char *)&this->AutoPilot + 75);
  this->hFlagsLocal = 0;
  this->pHandling = 0;
  *(_WORD *)&this->AutoPilot.Mission = 0;
  this->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
  *(_WORD *)((char *)&this->AutoPilot + 75) = *(_WORD *)&m_nPhysicalFlags & 0xFFFB;
  this->m_remapTxdName = 0;
  this->m_newRemapTxdName = 0;
  this->m_pRemapTexture = 0;
  this->m_fxSysEngOverheat = 0;
  this->m_fxSysEngFire = 0;
  this->m_fxSysHeliDust = 0;
  this->pCustomPlateTexture = 0;
  this->m_upgrades[14] = -1;
  *(_DWORD *)&this->m_upgrades[12] = -1;
  *(_DWORD *)&this->m_upgrades[10] = -1;
  *(_DWORD *)&this->m_upgrades[8] = -1;
  *(_DWORD *)&this->m_upgrades[6] = -1;
  *(_DWORD *)&this->m_upgrades[4] = -1;
  *(_DWORD *)&this->m_upgrades[2] = -1;
  *(_DWORD *)this->m_upgrades = -1;
  this->m_wheelScale = 1.0;
  *(_WORD *)&this->m_windowsOpenFlags = 0;
  this->m_hassleStatus = 0;
  this->m_SelectedWeapon = 0;
  *((_BYTE *)this + 1202) = v13 & 0x80;
  this->nBodyDirtLevel = (float)(rand() % 15);
  v18 = CTimer::m_snTimeInMilliseconds;
  *(_DWORD *)this->m_storedCollisionLighting = 1212696648;
  this->m_TimeOfCreation = v18;
  this->cachedTotalSteer = 0.0;
}
// 66E210: using guessed type void *;

//----- (005819EC) --------------------------------------------------------
void __fastcall CVehicle::SetCollisionLighting(CVehicle *this, uint8 light)
{
  *(_DWORD *)this->m_storedCollisionLighting = 16843009 * light;
}

//----- (005819F8) --------------------------------------------------------
void __fastcall CVehicle::~CVehicle(CVehicle *this)
{
  bool v2; // zf
  CPed *pDriver; // r0
  uint8 m_nMaxPassengers; // r1
  int v5; // r0
  int v6; // r5
  CPed *v7; // r0
  CFire *m_pFire; // r0
  int m_nVehicleFlags; // r2
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r1
  int v11; // r0
  int m_nSpecialColModel; // r0
  FxSystem_c *m_fxSysEngOverheat; // r1
  FxSystem_c *m_fxSysEngFire; // r1
  FxSystem_c *m_fxSysHeliDust; // r1
  RwTexture_0 *pCustomPlateTexture; // r0
  Int32 Rope; // r0
  int m_bInitialised; // r1

  this->CarAlarmState = 0;
  v2 = this->m_remapTxdName == 0;
  this->_vptr$CPlaceable = (int (**)(void))&off_66E210;
  if ( !v2 )
  {
    this->m_remapTxdName = 0;
    this->m_newRemapTxdName = 0;
    this->m_pRemapTexture = 0;
  }
  RpClumpForAllAtomics((RpClump_0 *)this->m_pRwObject, RemoveAllUpgradesCB, 0);
  this->m_upgrades[14] = -1;
  *(_DWORD *)&this->m_upgrades[12] = -1;
  *(_DWORD *)&this->m_upgrades[10] = -1;
  *(_DWORD *)&this->m_upgrades[8] = -1;
  *(_DWORD *)&this->m_upgrades[6] = -1;
  *(_DWORD *)&this->m_upgrades[4] = -1;
  *(_DWORD *)&this->m_upgrades[2] = -1;
  *(_DWORD *)this->m_upgrades = -1;
  CEntity::DeleteRwObject(this);
  CRadar::ClearBlipForEntity(
    BLIPTYPE_CAR,
    CPools::ms_pVehiclePool->m_aFlags[-1075391197 * (((char *)this - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * (((char *)this - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)));
  pDriver = this->pDriver;
  if ( pDriver )
    (*((void (__fastcall **)(CPed *))pDriver->_vptr$CPlaceable + 22))(pDriver);
  m_nMaxPassengers = this->m_nMaxPassengers;
  if ( m_nMaxPassengers )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = this->pPassengers[v5];
      if ( v7 )
      {
        (*((void (__fastcall **)(CPed *))v7->_vptr$CPlaceable + 22))(v7);
        m_nMaxPassengers = this->m_nMaxPassengers;
      }
      v5 = (unsigned __int16)++v6;
    }
    while ( (unsigned __int16)v6 < (unsigned int)m_nMaxPassengers );
  }
  m_pFire = this->m_pFire;
  if ( m_pFire )
  {
    CFire::Extinguish(m_pFire);
    this->m_pFire = 0;
  }
  CCarCtrl::UpdateCarCount(this, 1u);
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  v11 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  if ( (m_nVehicleFlags & 2) != 0 )
  {
    m_nVehicleFlags &= ~2u;
    --CCarCtrl::NumAmbulancesOnDuty;
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v11;
  }
  if ( (m_nVehicleFlags & 4) != 0 )
  {
    --CCarCtrl::NumFireTrucksOnDuty;
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFFB;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v11;
  }
  m_nSpecialColModel = this->m_nSpecialColModel;
  if ( m_nSpecialColModel >= 0 )
  {
    CVehicle::m_aSpecialColVehicle[m_nSpecialColModel] = 0;
    this->m_nSpecialColModel = -1;
  }
  m_fxSysEngOverheat = this->m_fxSysEngOverheat;
  if ( m_fxSysEngOverheat )
  {
    FxManager_c::DestroyFxSystem(&g_fxMan, m_fxSysEngOverheat);
    this->m_fxSysEngOverheat = 0;
  }
  m_fxSysEngFire = this->m_fxSysEngFire;
  if ( m_fxSysEngFire )
  {
    FxManager_c::DestroyFxSystem(&g_fxMan, m_fxSysEngFire);
    this->m_fxSysEngFire = 0;
  }
  m_fxSysHeliDust = this->m_fxSysHeliDust;
  if ( m_fxSysHeliDust )
  {
    FxManager_c::DestroyFxSystem(&g_fxMan, m_fxSysHeliDust);
    this->m_fxSysHeliDust = 0;
  }
  pCustomPlateTexture = this->pCustomPlateTexture;
  if ( pCustomPlateTexture )
  {
    RwTextureDestroy(pCustomPlateTexture);
    this->pCustomPlateTexture = 0;
  }
  Rope = CRopes::FindRope((u_native)&this->m_nFlags + 1);
  if ( Rope >= 0 )
    CRope::Remove(&CRopes::aRopes[Rope]);
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) == 0 && this->m_nHealth < 250.0 )
    CDarkel::RegisterCarBlownUpByPlayer(this, 0);
  m_bInitialised = this->m_VehicleAudioEntity.m_bInitialised;
  this->m_VehicleAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_6678FC;
  if ( m_bInitialised )
    CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CAETwinLoopSoundEntity::~CAETwinLoopSoundEntity(&this->m_VehicleAudioEntity.m_SkidSound);
  this->m_VehicleAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_667798;
  CAESound::~CAESound(&this->m_VehicleAudioEntity.ScratchSound);
  sub_194468(this);
}
// 667798: using guessed type void *off_667798;
// 6678FC: using guessed type void *off_6678FC;
// 66E210: using guessed type void *off_66E210;
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (00581C3C) --------------------------------------------------------
void __fastcall CVehicle::DeleteRwObject(CVehicle *this)
{
  if ( this->m_remapTxdName )
  {
    this->m_remapTxdName = 0;
    this->m_newRemapTxdName = 0;
    this->m_pRemapTexture = 0;
  }
  RpClumpForAllAtomics((RpClump_0 *)this->m_pRwObject, RemoveAllUpgradesCB, 0);
  this->m_upgrades[14] = -1;
  *(_DWORD *)&this->m_upgrades[12] = -1;
  *(_DWORD *)&this->m_upgrades[10] = -1;
  *(_DWORD *)&this->m_upgrades[8] = -1;
  *(_DWORD *)&this->m_upgrades[6] = -1;
  *(_DWORD *)&this->m_upgrades[4] = -1;
  *(_DWORD *)&this->m_upgrades[2] = -1;
  *(_DWORD *)this->m_upgrades = -1;
  sub_1947EC(this);
}

//----- (00581C9C) --------------------------------------------------------
void __fastcall CVehicle::CustomCarPlate_TextureDestroy(CVehicle *this)
{
  RwTexture_0 *pCustomPlateTexture; // r0

  pCustomPlateTexture = this->pCustomPlateTexture;
  if ( pCustomPlateTexture )
  {
    RwTextureDestroy(pCustomPlateTexture);
    this->pCustomPlateTexture = 0;
  }
}

//----- (00581CB8) --------------------------------------------------------
void __fastcall CVehicle::~CVehicle(CVehicle *this)
{
  CVehiclePool *v1; // r1
  int v2; // r0
  int v3; // r0

  CVehicle::~CVehicle(this);
  v1 = CPools::ms_pVehiclePool;
  v3 = -1075391197 * ((signed int)(v2 - (unsigned int)CPools::ms_pVehiclePool->m_aStorage) >> 2);
  CPools::ms_pVehiclePool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v3;
}
// 581CCC: variable 'v2' is possibly undefined
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (00581CF0) --------------------------------------------------------
void __fastcall CVehicle::operator delete(void *pVoid)
{
  CVehiclePool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pVehiclePool;
  v2 = -1075391197 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pVehiclePool->m_aStorage) >> 2);
  CPools::ms_pVehiclePool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (00581D20) --------------------------------------------------------
void CVehicle::Shutdown()
{
  if ( CVehicle::m_aSpecialColModel[0].m_pColData )
    CColModel::RemoveCollisionVolumes(CVehicle::m_aSpecialColModel);
  if ( CVehicle::m_aSpecialColModel[1].m_pColData )
    CColModel::RemoveCollisionVolumes(&CVehicle::m_aSpecialColModel[1]);
  if ( CVehicle::m_aSpecialColModel[2].m_pColData )
    CColModel::RemoveCollisionVolumes(&CVehicle::m_aSpecialColModel[2]);
  if ( CVehicle::m_aSpecialColModel[3].m_pColData )
    sub_195058(&CVehicle::m_aSpecialColModel[3]);
}

//----- (00581DA8) --------------------------------------------------------
void *__fastcall CVehicle::operator new(size_t nSize)
{
  int v1; // lr
  CVehiclePool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pVehiclePool;
  result = (void *)CPools::ms_pVehiclePool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pVehiclePool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (00581E0C) --------------------------------------------------------
void *__fastcall CVehicle::operator new(size_t nSize, int32 index)
{
  int32 v2; // r4
  CVehiclePool *v3; // r2
  __int64 v4; // kr00_8
  int32 v5; // r0
  uint8 *m_aFlags; // r1
  int v7; // r3

  v2 = index >> 8;
  v3 = CPools::ms_pVehiclePool;
  v4 = *(_QWORD *)&CPools::ms_pVehiclePool->m_aStorage;
  CPools::ms_pVehiclePool->m_aFlags[v2] &= ~0x80u;
  v3->m_aFlags[v2] = v3->m_aFlags[index >> 8] & 0x80 | index & 0x7F;
  v5 = 0;
  m_aFlags = v3->m_aFlags;
  do
  {
    v3->m_nFreeIndex = v5;
    v7 = (char)m_aFlags[v5++];
  }
  while ( v7 > -1 );
  return (void *)(v4 + 2604 * v2);
}

//----- (00581E60) --------------------------------------------------------
void __fastcall CVehicle::operator delete(void *pVoid, int32 index)
{
  CVehiclePool *v2; // r1
  int v3; // r0

  v2 = CPools::ms_pVehiclePool;
  v3 = -1075391197 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pVehiclePool->m_aStorage) >> 2);
  CPools::ms_pVehiclePool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v2->m_nFreeIndex )
    v2->m_nFreeIndex = v3;
}

//----- (00581E90) --------------------------------------------------------
void __fastcall CVehicle::SetRemapTexDictionary(CVehicle *this, const unsigned __int8 *name)
{
  if ( this->m_remapTxdName != name )
  {
    if ( !name )
    {
      this->m_remapTxdName = 0;
      this->m_pRemapTexture = 0;
    }
    this->m_newRemapTxdName = name;
  }
}

//----- (00581EB0) --------------------------------------------------------
void __fastcall CVehicle::RemoveAllUpgrades(CVehicle *this)
{
  RpClumpForAllAtomics((RpClump_0 *)this->m_pRwObject, RemoveAllUpgradesCB, 0);
  this->m_upgrades[14] = -1;
  *(_DWORD *)&this->m_upgrades[12] = -1;
  *(_DWORD *)&this->m_upgrades[10] = -1;
  *(_DWORD *)&this->m_upgrades[8] = -1;
  *(_DWORD *)&this->m_upgrades[6] = -1;
  *(_DWORD *)&this->m_upgrades[4] = -1;
  *(_DWORD *)&this->m_upgrades[2] = -1;
  *(_DWORD *)this->m_upgrades = -1;
}

//----- (00581EF4) --------------------------------------------------------
int32 __fastcall CVehicle::GetRemapIndex(CVehicle *this)
{
  CVehicleModelInfo *v2; // r5
  int v3; // r4
  int32 v4; // r6

  v2 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  if ( CVehicleModelInfo::GetNumRemaps(v2) < 1 )
    return -1;
  v3 = 0;
  v4 = 0;
  while ( *(const unsigned __int8 **)((char *)v2->m_remaps + (v3 >> 14)) != this->m_remapTxdName )
  {
    ++v4;
    v3 += 0x10000;
    if ( v4 >= CVehicleModelInfo::GetNumRemaps(v2) )
      return -1;
  }
  return v4;
}

//----- (00581F4C) --------------------------------------------------------
void __fastcall CVehicle::SetRemap(CVehicle *this, int32 index)
{
  const unsigned __int8 *v2; // r1

  if ( index == -1 )
  {
    if ( this->m_remapTxdName )
    {
      this->m_remapTxdName = 0;
      this->m_newRemapTxdName = 0;
      this->m_pRemapTexture = 0;
    }
  }
  else
  {
    v2 = *(const unsigned __int8 **)&CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][16].m_modelName[(index << 16 >> 14) + 12];
    if ( this->m_remapTxdName != v2 )
    {
      if ( !v2 )
      {
        this->m_remapTxdName = 0;
        this->m_pRemapTexture = 0;
      }
      this->m_newRemapTxdName = v2;
    }
  }
}

//----- (00581FA8) --------------------------------------------------------
void __fastcall CVehicle::UpdateLightingFromStoredPolys(CVehicle *this)
{
  uint8 lighting; // r1
  uint8 v2; // r2

  lighting = this->StoredCollPolys[0].lighting;
  v2 = this->StoredCollPolys[1].lighting;
  this->m_storedCollisionLighting[1] = lighting;
  this->m_storedCollisionLighting[0] = lighting;
  this->m_storedCollisionLighting[3] = v2;
  this->m_storedCollisionLighting[2] = v2;
}

//----- (00581FC4) --------------------------------------------------------
void __fastcall CVehicle::CalculateLightingFromCollision(CVehicle *this)
{
  unsigned int v1; // r3

  v1 = this->m_storedCollisionLighting[2];
  this->m_lightingFromCollision = (float)((float)((float)((float)((float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                                                * (float)((float)((float)(this->m_storedCollisionLighting[0] >> 4)
                                                                                                * 0.5)
                                                                                        / 15.0))
                                                                        + (float)((float)(1.0
                                                                                        - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                                                * (float)((float)((float)(this->m_storedCollisionLighting[0] & 0xF)
                                                                                                * 0.5)
                                                                                        / 15.0)))
                                                                + 0.0)
                                                        + (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                                        * (float)((float)((float)(this->m_storedCollisionLighting[1] >> 4)
                                                                                        * 0.5)
                                                                                / 15.0))
                                                                + (float)((float)(1.0
                                                                                - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                                        * (float)((float)((float)(this->m_storedCollisionLighting[1] & 0xF)
                                                                                        * 0.5)
                                                                                / 15.0))))
                                                + (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                                * (float)((float)((float)(v1 >> 4) * 0.5) / 15.0))
                                                        + (float)((float)(1.0
                                                                        - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                                * (float)((float)((float)(v1 & 0xF) * 0.5) / 15.0))))
                                        + (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                        * (float)((float)((float)(this->m_storedCollisionLighting[3] >> 4)
                                                                        * 0.5)
                                                                / 15.0))
                                                + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                        * (float)((float)((float)(this->m_storedCollisionLighting[3] & 0xF)
                                                                        * 0.5)
                                                                / 15.0))))
                                * 0.25;
}

//----- (005820E8) --------------------------------------------------------
void __fastcall CVehicle::PreRender(CVehicle *this)
{
  unsigned int v2; // r2
  float v3; // s0

  if ( this->m_baseVehicleType != 6 )
  {
    v2 = this->m_storedCollisionLighting[2];
    this->m_lightingFromCollision = (float)((float)((float)((float)((float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                                                  * (float)((float)((float)(this->m_storedCollisionLighting[0] >> 4)
                                                                                                  * 0.5)
                                                                                          / 15.0))
                                                                          + (float)((float)(1.0
                                                                                          - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                                                  * (float)((float)((float)(this->m_storedCollisionLighting[0] & 0xF)
                                                                                                  * 0.5)
                                                                                          / 15.0)))
                                                                  + 0.0)
                                                          + (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                                          * (float)((float)((float)(this->m_storedCollisionLighting[1] >> 4)
                                                                                          * 0.5)
                                                                                  / 15.0))
                                                                  + (float)((float)(1.0
                                                                                  - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                                          * (float)((float)((float)(this->m_storedCollisionLighting[1] & 0xF)
                                                                                          * 0.5)
                                                                                  / 15.0))))
                                                  + (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                                  * (float)((float)((float)(v2 >> 4) * 0.5) / 15.0))
                                                          + (float)((float)(1.0
                                                                          - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                                  * (float)((float)((float)(v2 & 0xF) * 0.5) / 15.0))))
                                          + (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                          * (float)((float)((float)(this->m_storedCollisionLighting[3] >> 4)
                                                                          * 0.5)
                                                                  / 15.0))
                                                  + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                          * (float)((float)((float)(this->m_storedCollisionLighting[3] & 0xF)
                                                                          * 0.5)
                                                                  / 15.0))))
                                  * 0.25;
  }
  CVehicle::PreRenderDriverAndPassengers(this);
  if ( CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_num2dEffects )
    CEntity::ProcessLightsForEntity(this);
  *((_BYTE *)this + 1428) &= 0xF0u;
  v3 = CPhysical::GetLightingFromCol(this, 0) * 0.4;
  sub_198534((CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex], v3);
}

//----- (00582280) --------------------------------------------------------
void __fastcall CVehicle::PreRenderDriverAndPassengers(CVehicle *this)
{
  CPed *pDriver; // r0
  CPed *v3; // r0
  CPed *v4; // r0
  CPed *v5; // r0
  CPed *v6; // r0
  CPed *v7; // r0
  CPed *v8; // r0
  CPed *v9; // r0
  CPed *v10; // r0

  pDriver = this->pDriver;
  if ( pDriver && pDriver->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(pDriver);
  v3 = this->pPassengers[0];
  if ( v3 && v3->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v3);
  v4 = this->pPassengers[1];
  if ( v4 && v4->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v4);
  v5 = this->pPassengers[2];
  if ( v5 && v5->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v5);
  v6 = this->pPassengers[3];
  if ( v6 && v6->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v6);
  v7 = this->pPassengers[4];
  if ( v7 && v7->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v7);
  v8 = this->pPassengers[5];
  if ( v8 && v8->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v8);
  v9 = this->pPassengers[6];
  if ( v9 && v9->m_nPedState == PED_DRIVING )
    CPed::PreRenderAfterTest(v9);
  v10 = this->pPassengers[7];
  if ( v10 )
  {
    if ( v10->m_nPedState == PED_DRIVING )
      sub_195410(v10);
  }
}

//----- (00582334) --------------------------------------------------------
void __fastcall CVehicle::SetupRender(CVehicle *this)
{
  CVehicleModelInfo *v2; // r5
  const unsigned __int8 *m_newRemapTxdName; // r0
  RwTexture_0 **p_m_pRemapTexture; // r6
  RwTexture_0 *v5; // r0
  char v6; // r1

  v2 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  if ( !this->m_baseVehicleType )
    CAutomobile::CustomCarPlate_BeforeRenderingStart((CAutomobile *)this, v2);
  m_newRemapTxdName = this->m_newRemapTxdName;
  if ( m_newRemapTxdName )
  {
    p_m_pRemapTexture = &this->m_pRemapTexture;
    if ( this->m_pRemapTexture )
      *p_m_pRemapTexture = 0;
    this->m_remapTxdName = m_newRemapTxdName;
    this->m_newRemapTxdName = 0;
    v5 = RwTextureRead(m_newRemapTxdName, 0);
    v6 = *((_BYTE *)&this->m_nVehicleFlags + 7);
    this->m_pRemapTexture = v5;
    if ( (v6 & 4) == 0 )
      this->m_colour1 = 1;
  }
  else
  {
    p_m_pRemapTexture = &this->m_pRemapTexture;
    *((_DWORD *)&this->m_nVehicleFlags + 1) &= ~0x4000000u;
  }
  CVehicleModelInfo::SetVehicleColour(v2, this->m_colour1, this->m_colour2, this->m_colour3, this->m_colour4);
  CVehicleModelInfo::SetupLightFlags(this);
  CVehicleModelInfo::ms_pRemapTexture = *p_m_pRemapTexture;
  sub_18A9D0((RpClump_0 *)this->m_pRwObject);
}
// 0: using guessed type int dword_0;

//----- (005823F0) --------------------------------------------------------
void __fastcall CVehicle::ResetAfterRender(CVehicle *this)
{
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
  CVehicleModelInfo::ResetEditableMaterials((RpClump_0 *)this->m_pRwObject);
  if ( !this->m_baseVehicleType )
    sub_197E84((CAutomobile *)this, (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]);
}
// 0: using guessed type int dword_0;

//----- (0058242C) --------------------------------------------------------
void __fastcall CVehicle::Render(CVehicle *this)
{
  CVehicleModelInfo *v2; // r5
  unsigned int v3; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CSimpleTransform *p_m_transform; // r2
  float v7; // s0

  if ( CMirrors::TypeOfMirror != 3 )
  {
    v2 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
    if ( Fx_c::GetFxQuality(&g_fx) >= FX_QUALITY_MEDIUM )
      CCarFXRenderer::RemapDirt(v2, (unsigned int)this->nBodyDirtLevel & 0xF);
    if ( MobileSettings::settings[0].value )
    {
      v3 = MobileSettings::settings[0].value - 1;
      m_pMat = this->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &this->m_transform;
      p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_m_transform = &TheCamera.m_transform;
      if ( v3 > 2 )
        goto LABEL_13;
      v7 = (float)(sqrtf(
                     (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                   * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                           + (float)((float)(p_m_transform->m_translate.y - p_tx->m_translate.y)
                                   * (float)(p_m_transform->m_translate.y - p_tx->m_translate.y)))
                   + (float)((float)(p_m_transform->m_translate.z - p_tx->m_translate.z)
                           * (float)(p_m_transform->m_translate.z - p_tx->m_translate.z)))
                 + *(float *)&dword_582530[v3])
         / *(float *)&dword_58253C[v3];
    }
    else
    {
      v7 = 0.0;
    }
    carLodLerp = v7;
LABEL_13:
    sub_18D660(this);
  }
}
// 582530: using guessed type int dword_582530[3];
// 58253C: using guessed type int dword_58253C[3];

//----- (0058254C) --------------------------------------------------------
void __fastcall CVehicle::SpecialEntityPreCollisionStuff(
        CVehicle *this,
        CPhysical *pPhysical,
        int bDoingShift,
        bool *bSkipTestEntirely,
        _BYTE *a5,
        _BYTE *a6,
        _BYTE *a7)
{
  CPhysical *m_pNOCollisionVehicle; // r0
  bool v12; // zf
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  int v14; // r1
  CEntity::CEntityInfo m_info; // r2
  RwReal y; // r0
  int v17; // r1
  bool v18; // zf
  int v19; // r1
  bool v20; // zf
  CVehicle *m_pTowingVehicle; // r1
  bool v22; // zf
  int m_nModelIndex; // r0
  bool v24; // zf
  CColModel *ColModel; // r0
  RwReal v26; // s0
  float z; // s4
  float v28; // s10
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CMatrix *v31; // r0
  CVector v32; // [sp+0h] [bp-80h] BYREF
  CVector v; // [sp+10h] [bp-70h] BYREF
  CMatrix output; // [sp+20h] [bp-60h] BYREF

  if ( (*(_BYTE *)&pPhysical->m_info & 7) == 3
    && (HIBYTE(pPhysical[3].m_aCollisionRecordPtrs[5]) & 0x80) != 0
    && (CVehicle *)LODWORD(pPhysical[4].m_fElasticity) == this
    || *((unsigned __int8 *)&this->m_nPhysicalFlags + 3) << 31
    && ((*(_BYTE *)&this->m_info >> 3) | 8) != 8
    && CEntity::DoesNotCollideWithFlyers(pPhysical) )
  {
    goto LABEL_23;
  }
  m_pNOCollisionVehicle = (CPhysical *)this->m_pNOCollisionVehicle;
  v12 = m_pNOCollisionVehicle == pPhysical;
  if ( m_pNOCollisionVehicle != pPhysical )
    v12 = pPhysical->m_pNOCollisionVehicle == this;
  if ( v12 )
    goto LABEL_11;
  if ( this->m_pAttachToEntity == pPhysical )
  {
LABEL_22:
    *a5 = 1;
    return;
  }
  if ( pPhysical->m_pAttachToEntity == this )
  {
    *bSkipTestEntirely = 1;
    goto LABEL_12;
  }
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  if ( (*(_BYTE *)&m_nPhysicalFlags & 4) != 0 && (*(_BYTE *)&pPhysical->m_nPhysicalFlags & 4) != 0 )
  {
LABEL_23:
    *bSkipTestEntirely = 1;
    return;
  }
  v14 = *(_DWORD *)&this->m_nFlags & 0x10;
  if ( v14 && (*(_BYTE *)&pPhysical->m_info & 7) == 2 && (*(_DWORD *)&pPhysical->m_nPhysicalFlags & 0xC) == 4 )
  {
LABEL_11:
    *a5 = 1;
LABEL_12:
    *(_DWORD *)&this->m_nPhysicalFlags |= 0x1000u;
    return;
  }
  if ( (*(_BYTE *)&pPhysical->m_nPhysicalFlags & 0xE0) == 0 )
  {
    m_info = pPhysical->m_info;
    if ( (*(_BYTE *)&m_info & 7) == 4 )
    {
      y = pPhysical[1].m_transform.m_translate.y;
      if ( (LOWORD(y) & 0x100) != 0 && pPhysical->m_pMat->zz < 0.66 )
      {
        *bSkipTestEntirely = 1;
        pPhysical->m_pNOCollisionVehicle = this;
      }
      else if ( (unsigned __int16)(pPhysical->m_nModelIndex - 374) > 7u )
      {
        if ( LOBYTE(pPhysical[1].m_transform.m_translate.x) == 3
          || (LOBYTE(y) & 0x40) != 0
          || (*(_DWORD *)&pPhysical->m_nFlags & 0x40004) == 0 )
        {
          m_nModelIndex = this->m_nModelIndex;
          v24 = m_nModelIndex == 406;
          if ( m_nModelIndex != 406 )
            v24 = m_nModelIndex == 530;
          if ( v24 || m_nModelIndex == 486 )
          {
            if ( v14 || (*(_BYTE *)&pPhysical->m_nFlags & 0x10) != 0 )
              *a7 = 1;
          }
          else if ( LOBYTE(pPhysical[1].m_transform.m_translate.z) <= 0x13u && this->m_baseVehicleType != 9 )
          {
            ColModel = CEntity::GetColModel(pPhysical);
            if ( ColModel->m_boxBound.m_vecMax.x < 1.0
              && ColModel->m_boxBound.m_vecMax.y < 1.0
              && ColModel->m_boxBound.m_vecMax.z < 1.0 )
            {
              output.m_pRwMat = 0;
              output.m_owner = 0;
              v26 = ColModel->m_boxBound.m_vecMax.x - ColModel->m_boxBound.m_vecMin.x;
              z = ColModel->m_boxBound.m_vecMin.z;
              v28 = ColModel->m_boxBound.m_vecMax.z;
              v.y = ColModel->m_boxBound.m_vecMax.y - ColModel->m_boxBound.m_vecMin.y;
              v.x = v26;
              v.z = v28 - z;
              operator*(&v32, pPhysical->m_pMat, &v);
              v = v32;
              m_pMat = this->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &this->m_transform;
              if ( p_tx->m_translate.z > v32.z
                || (v31 = Invert(m_pMat, &output),
                    CMatrix::operator=(&output, v31),
                    operator*(&v32, &output, &v),
                    v32.z < 0.0) )
              {
                *a5 = 1;
              }
              CMatrix::~CMatrix(&output);
            }
          }
        }
      }
      else
      {
        *bSkipTestEntirely = 1;
      }
      if ( ((unsigned __int8)*a5 | *bSkipTestEntirely | (unsigned __int8)*a7) << 24 )
        return;
LABEL_72:
      if ( (*(_BYTE *)&pPhysical->m_nFlags & 0x10) != 0 )
        *a6 = 1;
      return;
    }
    v17 = pPhysical->m_nModelIndex;
    if ( v17 != 441 )
    {
      v18 = v17 == 564;
      if ( v17 != 564 )
        v18 = v17 == 594;
      if ( !v18 )
      {
        v19 = this->m_nModelIndex;
        v20 = v19 == 441;
        if ( v19 != 441 )
          v20 = v19 == 594;
        if ( !v20 && v19 != 564 || (*(_BYTE *)&m_info & 6) != 2 )
        {
          m_pTowingVehicle = this->m_pTowingVehicle;
          v22 = m_pTowingVehicle == pPhysical;
          if ( m_pTowingVehicle != pPhysical )
            v22 = this->m_pVehicleBeingTowed == pPhysical;
          if ( v22 )
          {
            this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x1000);
LABEL_47:
            *a7 = 1;
            return;
          }
          goto LABEL_72;
        }
      }
    }
    goto LABEL_11;
  }
  if ( bDoingShift == 1 )
    goto LABEL_22;
  if ( v14 || (*(_BYTE *)&pPhysical->m_nFlags & 0x10) != 0 )
    goto LABEL_47;
}

//----- (0058282C) --------------------------------------------------------
uint8 __fastcall CVehicle::SpecialEntityCalcCollisionSteps(
        CVehicle *this,
        bool *bDoPreCheckAtFullSpeed,
        bool *bDoPreCheckAtHalfSpeed)
{
  float v6; // s0
  unsigned int v7; // r0
  float v8; // s16
  int *v9; // r1
  float v10; // s18
  int *v11; // r0
  CColModel *ColModel; // r0
  CMatrix *m_pMat; // r1
  float x; // s0
  float y; // s2
  float v16; // s6
  float32x2_t v17; // d2
  float z; // s4
  float32x2_t v19; // d0
  float v20; // s12
  float v21; // s0
  float v22; // s2
  float32x2_t v23; // d1
  float v24; // s10
  float v25; // s0
  float v26; // s8
  float v27; // s6
  float v28; // r0
  float v29; // s16

  if ( (*(_BYTE *)&this->m_nPhysicalFlags & 4) != 0
    || (v6 = CTimer::ms_fTimeStep
           * (float)(CTimer::ms_fTimeStep
                   * (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                   + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                           + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z))),
        v6 < 0.16) )
  {
    LOBYTE(v7) = 1;
  }
  else
  {
    v8 = sqrtf(v6);
    if ( *(_BYTE *)&this->m_info > 7u )
    {
      v11 = dword_5829F4;
      if ( v6 > 0.32 )
        v11 = &dword_5829F4[1];
      v10 = *(float *)v11;
    }
    else
    {
      v9 = dword_5829FC;
      if ( this->m_baseVehicleType == 9 )
        v9 = &dword_5829FC[1];
      v10 = *(float *)v9;
    }
    ColModel = CEntity::GetColModel(this);
    m_pMat = this->m_pMat;
    x = this->m_vecMoveSpeed.x;
    y = this->m_vecMoveSpeed.y;
    v16 = x * m_pMat->xx;
    v17.n64_u32[1] = LODWORD(m_pMat->yz);
    z = this->m_vecMoveSpeed.z;
    v19.n64_u32[1] = LODWORD(ColModel->m_boxBound.m_vecMax.z);
    v20 = (float)(x * m_pMat->xy) + (float)(y * m_pMat->yy);
    v21 = (float)(x * m_pMat->xz) + (float)(y * v17.n64_f32[1]);
    v22 = (float)(v16 + (float)(y * m_pMat->yx)) + (float)(z * m_pMat->zx);
    v23.n64_f32[1] = CTimer::ms_fTimeStep;
    v24 = v19.n64_f32[1] - ColModel->m_boxBound.m_vecMin.z;
    v25 = v21 + (float)(z * m_pMat->zz);
    v26 = ColModel->m_boxBound.m_vecMax.y - ColModel->m_boxBound.m_vecMin.y;
    v27 = ColModel->m_boxBound.m_vecMax.x - ColModel->m_boxBound.m_vecMin.x;
    v28 = v8 / v10;
    v17.n64_f32[0] = (float)(CTimer::ms_fTimeStep * fabsf(v20 + (float)(z * m_pMat->zy))) / v26;
    v23.n64_f32[0] = (float)(CTimer::ms_fTimeStep * fabsf(v22)) / v27;
    v19.n64_f32[0] = (float)(CTimer::ms_fTimeStep * fabsf(v25)) / v24;
    LODWORD(v29) = vmax_f32(vmax_f32(v17, v23), v19).n64_u32[0];
    if ( this->m_baseVehicleType == 9 )
      v29 = v29 * 1.5;
    v7 = (unsigned int)ceilf(v28);
    if ( v29 < 1.0 || (bDoPreCheckAtFullSpeed = bDoPreCheckAtHalfSpeed, v29 < 2.0) )
      *bDoPreCheckAtFullSpeed = 1;
  }
  return v7;
}
// 5829F4: using guessed type int dword_5829F4[2];
// 5829FC: using guessed type int dword_5829FC[2];

//----- (00582A08) --------------------------------------------------------
eVehicleAppearance __fastcall CVehicle::GetVehicleAppearance(const CVehicle *this)
{
  int v1; // r1
  eVehicleAppearance result; // r0

  v1 = HIBYTE(this->pHandling->mFlags) & 0xF;
  result = APR_CAR;
  switch ( v1 )
  {
    case 0:
      return result;
    case 1:
      result = APR_BIKE;
      break;
    case 2:
      result = APR_HELI;
      break;
    case 4:
      result = APR_PLANE;
      break;
    case 8:
      result = APR_BOAT;
      break;
    default:
      result = APR_UNKNOWN;
      break;
  }
  return result;
}

//----- (00582A3C) --------------------------------------------------------
void __fastcall CVehicle::SetModelIndex(CVehicle *this, uint32 index)
{
  CVehicleModelInfo *v4; // r6
  unsigned __int8 *CustomCarPlateText; // r0
  RwTexture_0 *texture; // r0
  uint8 MaximumNumberOfPassengersFromNumberOfDoors; // r0
  int m_nModelIndex; // r1
  bool v9; // zf
  bool v10; // zf
  UInt8 v11; // r0
  unsigned int v12; // r0

  CEntity::SetModelIndex(this, index);
  v4 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[index];
  this->pCustomPlateTexture = 0;
  if ( v4->pCustomPlateMaterial )
  {
    CustomCarPlateText = CVehicleModelInfo::GetCustomCarPlateText(v4);
    if ( CustomCarPlateText )
    {
      this->pCustomPlateTexture = CCustomCarPlateMgr::CreatePlateTexture(CustomCarPlateText, v4->nCarplateDesign);
      CVehicleModelInfo::SetCustomCarPlateText(v4, 0);
      v4->nCarplateDesign = -1;
    }
    else
    {
      texture = v4->pCustomPlateMaterial->texture;
      ++texture->refCount;
      this->pCustomPlateTexture = texture;
    }
  }
  this->m_comp1 = CVehicleModelInfo::ms_compsUsed[0];
  this->m_comp2 = CVehicleModelInfo::ms_compsUsed[1];
  MaximumNumberOfPassengersFromNumberOfDoors = CVehicleModelInfo::GetMaximumNumberOfPassengersFromNumberOfDoors(index);
  m_nModelIndex = this->m_nModelIndex;
  this->m_nMaxPassengers = MaximumNumberOfPassengersFromNumberOfDoors;
  if ( (unsigned int)(m_nModelIndex - 441) <= 0x18 && ((1 << (m_nModelIndex + 71)) & 0x1800001) != 0 )
    goto LABEL_11;
  v9 = m_nModelIndex == 564;
  if ( m_nModelIndex != 564 )
    v9 = m_nModelIndex == 501;
  if ( v9 )
LABEL_11:
    v12 = *((_DWORD *)&this->m_nVehicleFlags + 1) | 0x80;
  else
    v12 = *((_DWORD *)&this->m_nVehicleFlags + 1) & 0xFFFFFF7F;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v12;
  if ( m_nModelIndex <= 512 )
  {
    if ( m_nModelIndex != 476 )
    {
      if ( m_nModelIndex != 511 )
        return;
      v11 = 2;
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  v10 = m_nModelIndex == 576;
  if ( m_nModelIndex != 576 )
    v10 = m_nModelIndex == 520;
  if ( v10 )
  {
    v11 = 3;
    goto LABEL_23;
  }
  if ( m_nModelIndex == 513 )
  {
LABEL_21:
    v11 = 1;
LABEL_23:
    this->m_SelectedWeapon = v11;
  }
}

//----- (00582B34) --------------------------------------------------------
bool8 __fastcall CVehicle::CustomCarPlate_TextureCreate(CVehicle *this, CVehicleModelInfo *pModelInfo)
{
  bool8 result; // r0
  unsigned __int8 *CustomCarPlateText; // r0
  RwTexture_0 *texture; // r0

  result = 0;
  this->pCustomPlateTexture = 0;
  if ( pModelInfo->pCustomPlateMaterial )
  {
    CustomCarPlateText = CVehicleModelInfo::GetCustomCarPlateText(pModelInfo);
    if ( CustomCarPlateText )
    {
      this->pCustomPlateTexture = CCustomCarPlateMgr::CreatePlateTexture(
                                    CustomCarPlateText,
                                    pModelInfo->nCarplateDesign);
      CVehicleModelInfo::SetCustomCarPlateText(pModelInfo, 0);
      pModelInfo->nCarplateDesign = -1;
    }
    else
    {
      texture = pModelInfo->pCustomPlateMaterial->texture;
      ++texture->refCount;
      this->pCustomPlateTexture = texture;
    }
    return 1;
  }
  return result;
}

//----- (00582B82) --------------------------------------------------------
Bool8 __fastcall CVehicle::CanBeDeleted(const CVehicle *this)
{
  bool v1; // zf
  CPed *pDriver; // r1
  ePedState m_nPedState; // r1
  bool v5; // zf
  CPed *v6; // r1
  ePedState v7; // r1
  bool v8; // zf
  CPed *v9; // r1
  ePedState v10; // r1
  bool v11; // zf
  CPed *v12; // r1
  ePedState v13; // r1
  bool v14; // zf
  CPed *v15; // r1
  ePedState v16; // r1
  bool v17; // zf
  CPed *v18; // r1
  ePedState v19; // r1
  bool v20; // zf
  CPed *v21; // r1
  ePedState v22; // r1
  bool v23; // zf
  CPed *v24; // r1
  ePedState v25; // r1
  bool v26; // zf
  CPed *v27; // r1
  ePedState v28; // r1
  bool v29; // zf
  int VehicleCreatedBy; // r0
  bool v31; // zf

  v1 = this->m_nNumGettingIn == 0;
  if ( !this->m_nNumGettingIn )
    v1 = this->m_nGettingOutFlags == 0;
  if ( !v1 )
    return 0;
  pDriver = this->pDriver;
  if ( pDriver )
  {
    if ( pDriver->CharCreatedBy == 2 )
      return 0;
    m_nPedState = pDriver->m_nPedState;
    v5 = m_nPedState == PED_DEAD;
    if ( m_nPedState != PED_DEAD )
      v5 = m_nPedState == PED_DRIVING;
    if ( !v5 )
      return 0;
  }
  v6 = this->pPassengers[0];
  if ( v6 )
  {
    if ( v6->CharCreatedBy == 2 )
      return 0;
    v7 = v6->m_nPedState;
    v8 = v7 == PED_DEAD;
    if ( v7 != PED_DEAD )
      v8 = v7 == PED_DRIVING;
    if ( !v8 )
      return 0;
  }
  v9 = this->pPassengers[1];
  if ( v9 )
  {
    if ( v9->CharCreatedBy == 2 )
      return 0;
    v10 = v9->m_nPedState;
    v11 = v10 == PED_DEAD;
    if ( v10 != PED_DEAD )
      v11 = v10 == PED_DRIVING;
    if ( !v11 )
      return 0;
  }
  v12 = this->pPassengers[2];
  if ( v12 )
  {
    if ( v12->CharCreatedBy == 2 )
      return 0;
    v13 = v12->m_nPedState;
    v14 = v13 == PED_DEAD;
    if ( v13 != PED_DEAD )
      v14 = v13 == PED_DRIVING;
    if ( !v14 )
      return 0;
  }
  v15 = this->pPassengers[3];
  if ( v15 )
  {
    if ( v15->CharCreatedBy == 2 )
      return 0;
    v16 = v15->m_nPedState;
    v17 = v16 == PED_DEAD;
    if ( v16 != PED_DEAD )
      v17 = v16 == PED_DRIVING;
    if ( !v17 )
      return 0;
  }
  v18 = this->pPassengers[4];
  if ( v18 )
  {
    if ( v18->CharCreatedBy == 2 )
      return 0;
    v19 = v18->m_nPedState;
    v20 = v19 == PED_DEAD;
    if ( v19 != PED_DEAD )
      v20 = v19 == PED_DRIVING;
    if ( !v20 )
      return 0;
  }
  v21 = this->pPassengers[5];
  if ( v21 )
  {
    if ( v21->CharCreatedBy == 2 )
      return 0;
    v22 = v21->m_nPedState;
    v23 = v22 == PED_DEAD;
    if ( v22 != PED_DEAD )
      v23 = v22 == PED_DRIVING;
    if ( !v23 )
      return 0;
  }
  v24 = this->pPassengers[6];
  if ( v24 )
  {
    if ( v24->CharCreatedBy == 2 )
      return 0;
    v25 = v24->m_nPedState;
    v26 = v25 == PED_DEAD;
    if ( v25 != PED_DEAD )
      v26 = v25 == PED_DRIVING;
    if ( !v26 )
      return 0;
  }
  v27 = this->pPassengers[7];
  if ( v27 )
  {
    if ( v27->CharCreatedBy == 2 )
      return 0;
    v28 = v27->m_nPedState;
    v29 = v28 == PED_DEAD;
    if ( v28 != PED_DEAD )
      v29 = v28 == PED_DRIVING;
    if ( !v29 )
      return 0;
  }
  VehicleCreatedBy = this->VehicleCreatedBy;
  v31 = VehicleCreatedBy == 2;
  if ( VehicleCreatedBy != 2 )
    v31 = VehicleCreatedBy == 4;
  return !v31;
}

//----- (00582C9C) --------------------------------------------------------
float __fastcall CVehicle::ProcessWheelRotation(
        CVehicle *this,
        tWheelState WheelState,
        const CVector *vecForward,
        const CVector *WheelSpeed,
        float fRadius)
{
  if ( WheelState == WS_SPINNING )
    return -1.1;
  if ( WheelState == WS_LOCKED )
    return 0.0;
  return (float)-(float)((float)((float)(WheelSpeed->x * vecForward->x) + (float)(WheelSpeed->y * vecForward->y))
                       + (float)(WheelSpeed->z * vecForward->z))
       / fRadius;
}

//----- (00582D00) --------------------------------------------------------
void __fastcall CVehicle::ProcessWheel(
        CVehicle *this,
        CVector *vecForward,
        CVector *vecRight,
        CVector *vecSpeed,
        CVector *vecOffset,
        int32 nNoOfContactWheels,
        float fDriveAcceleration,
        float fDriveDeceleration,
        float fAdhesiveLimit,
        int WheelNum,
        float *pWheelPitchIncrement,
        tWheelState *pWheelState,
        float *nWheelDamage)
{
  float32x2_t v13; // d10
  float32x2_t v14; // d13
  float v15; // s22
  float v17; // s18
  int v18; // r1
  float v21; // s0
  float v22; // s2
  int v23; // r0
  float v24; // s16
  int v25; // r0
  char v26; // r1
  tWheelState v27; // r2
  float v28; // s0
  float v29; // s24
  float v30; // s28
  int v31; // s0
  float v32; // s0
  float fMass; // s4
  float m_fWheelFriction; // s6
  float v35; // s2
  float v36; // s2
  tWheelState v37; // r1
  float v38; // s4
  float fTractionLoss; // s4
  float v40; // s2
  int v41; // r2
  int v42; // r1
  float y; // s4
  float z; // s6
  float fSuspensionAntiDive; // s8
  float v46; // s20
  float v47; // s16
  float v48; // s0
  int v49; // r0
  float v50; // s2
  float v51; // s6
  float v52; // s4
  float v53; // s22
  float v54; // s18
  float v55; // s24
  float m_fMass; // s26
  float v57; // s0
  float v58; // s22
  float x; // s28
  float v60; // s30
  float v61; // s17
  RwReal v62; // s2
  float m_fTurnMass; // s24
  unsigned int v64; // s4
  float v65; // s20
  unsigned int v66; // s0
  float v67; // s16
  float v68; // s0
  CVector v69; // [sp+10h] [bp-70h] BYREF
  CVector v2; // [sp+1Ch] [bp-64h] BYREF
  CVector v71; // 0:r1.12
  CVector v72; // 0:r1.12

  v15 = fDriveDeceleration;
  v17 = fDriveAcceleration;
  v18 = 0;
  v21 = vecSpeed->z * vecForward->z;
  v22 = (float)(vecSpeed->x * vecForward->x) + (float)(vecSpeed->y * vecForward->y);
  if ( fDriveDeceleration == 0.0 )
    v18 = 1;
  v23 = 0;
  v24 = CTimer::ms_fTimeStep * fAdhesiveLimit;
  if ( fDriveAcceleration != 0.0 )
    v23 = 1;
  v25 = v23 & v18;
  v26 = 0;
  CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bDriving = v25;
  if ( fDriveDeceleration != 0.0 )
    v26 = 1;
  CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bBraking = v26;
  v27 = *pWheelState;
  if ( *pWheelState )
  {
    CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bAlreadySkidding = 1;
    v24 = v24 * this->pHandling->fTractionLoss;
    if ( v27 == WS_SPINNING && ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
      v24 = v24 * (float)(1.0 - (float)(fabsf(this->m_fGasPedal) * WS_ALREADY_SPINNING_LOSS));
  }
  *pWheelState = WS_ROLLING;
  v13.n64_f32[0] = v22 + v21;
  v28 = (float)((float)(vecSpeed->x * vecRight->x) + (float)(vecSpeed->y * vecRight->y))
      + (float)(vecSpeed->z * vecRight->z);
  if ( v28 != 0.0 )
  {
    v29 = (float)-v28 / (float)nNoOfContactWheels;
    if ( nWheelDamage == (float *)((char *)&dword_0 + 1) )
    {
      v14.n64_f32[0] = fBurstSpeedMax;
      v30 = fBurstTyreMod;
      v31 = rand();
      v25 = CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bDriving;
      v29 = v29
          + (float)(vmin_f32(v13, v14).n64_f32[0]
                  * (float)((float)((float)(v30 + v30) * (float)((float)v31 * 4.6566e-10)) - v30));
    }
    if ( v25 )
      goto LABEL_15;
LABEL_20:
    if ( v13.n64_f32[0] == 0.0 )
    {
      v17 = 0.0;
      v32 = v29;
      goto LABEL_40;
    }
    if ( !CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bBraking
      && fabsf(this->m_fGasPedal) < 0.01 )
    {
      if ( this->m_baseVehicleType == 9 )
      {
        fMass = this->pHandling->fMass + 200.0;
        m_fWheelFriction = mod_HandlingManager.m_fWheelFriction * 0.6;
      }
      else
      {
        if ( this->m_vehicleType == 4 )
        {
          v15 = 0.0;
          goto LABEL_36;
        }
        fMass = this->pHandling->fMass;
        if ( fMass >= 500.0 )
        {
          m_fWheelFriction = mod_HandlingManager.m_fWheelFriction;
          if ( this->m_nModelIndex == 441 )
            m_fWheelFriction = mod_HandlingManager.m_fWheelFriction * 0.2;
        }
        else
        {
          m_fWheelFriction = mod_HandlingManager.m_fWheelFriction * 0.1;
        }
      }
      v15 = m_fWheelFriction / fMass;
    }
LABEL_36:
    v35 = (float)-v13.n64_f32[0] / (float)nNoOfContactWheels;
    if ( v15 <= v24 )
    {
      if ( v35 <= 0.0 )
      {
        v17 = -v15;
        if ( v35 < (float)-v15 )
        {
          v32 = v29;
          goto LABEL_40;
        }
      }
      else if ( v35 > v15 )
      {
        v32 = v29;
        v17 = v15;
        goto LABEL_40;
      }
    }
    else if ( fabsf(v13.n64_f32[0]) > 0.005 )
    {
      *pWheelState = WS_LOCKED;
    }
    v32 = v29;
    v17 = (float)-v13.n64_f32[0] / (float)nNoOfContactWheels;
    goto LABEL_40;
  }
  v29 = 0.0;
  if ( !v25 )
    goto LABEL_20;
LABEL_15:
  if ( v29 <= 0.0 )
  {
    v32 = -v24;
    if ( v29 >= (float)-v24 )
      v32 = v29;
  }
  else if ( v29 <= v24 )
  {
    v32 = v29;
  }
  else
  {
    v32 = v24;
  }
LABEL_40:
  v36 = (float)(v32 * v32) + (float)(v17 * v17);
  if ( v36 > (float)(v24 * v24) )
  {
    if ( *pWheelState == WS_LOCKED )
    {
      v37 = WS_LOCKED;
    }
    else
    {
      v38 = WS_TRAC_FRAC_LIMIT;
      if ( v13.n64_f32[0] > 0.15 && (WheelNum | 2) == 2 )
        v38 = WS_TRAC_FRAC_LIMIT + WS_TRAC_FRAC_LIMIT;
      if ( v25 && fabsf(v17) > (float)(v24 * v38) )
        v37 = WS_SPINNING;
      else
        v37 = WS_SKIDDING;
      *pWheelState = v37;
    }
    if ( CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bAlreadySkidding )
    {
      fTractionLoss = 1.0;
    }
    else
    {
      fTractionLoss = this->pHandling->fTractionLoss;
      if ( v37 == WS_SPINNING && ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
        fTractionLoss = fTractionLoss * (float)(1.0 - (float)(fabsf(this->m_fGasPedal) * WS_ALREADY_SPINNING_LOSS));
    }
    v40 = (float)(v24 / sqrtf(v36)) * fTractionLoss;
    v32 = v32 * v40;
    v17 = v17 * v40;
  }
  v41 = 0;
  v42 = 0;
  if ( v17 != 0.0 )
    v41 = 1;
  if ( v32 != 0.0 )
    v42 = 1;
  if ( v42 | v41 )
  {
    y = vecForward->y;
    z = vecForward->z;
    fSuspensionAntiDive = this->pHandling->fSuspensionAntiDive;
    v46 = (float)(v32 * vecRight->y) + (float)(v17 * y);
    v47 = (float)(v32 * vecRight->z) + (float)(v17 * z);
    v48 = (float)(v32 * vecRight->x) + (float)(v17 * vecForward->x);
    if ( fSuspensionAntiDive > 0.0 )
    {
      if ( CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bBraking )
      {
LABEL_66:
        v49 = 1;
        v50 = v47 - (float)(v17 * (float)(z * fSuspensionAntiDive));
        v51 = v46 - (float)(v17 * (float)(y * fSuspensionAntiDive));
        v52 = v48 - (float)(v17 * (float)(vecForward->x * fSuspensionAntiDive));
LABEL_68:
        v2.y = v51;
        v2.x = v52;
        v2.z = v50;
        v53 = sqrtf((float)((float)(v48 * v48) + (float)(v46 * v46)) + (float)(v47 * v47));
        v54 = v53;
        if ( v49 )
          v54 = sqrtf((float)((float)(v52 * v52) + (float)(v51 * v51)) + (float)(v50 * v50));
        if ( v53 <= 0.0 )
        {
          v55 = 1.0;
        }
        else
        {
          v47 = v47 * (float)(1.0 / v53);
          v46 = v46 * (float)(1.0 / v53);
          v55 = v48 * (float)(1.0 / v53);
        }
        if ( v49 )
        {
          if ( v54 <= 0.0 )
          {
            v2.x = 1.0;
          }
          else
          {
            v2.y = (float)(1.0 / v54) * v51;
            v2.x = (float)(1.0 / v54) * v52;
            v2.z = (float)(1.0 / v54) * v50;
          }
        }
        else
        {
          v2.y = v46;
          v2.x = v55;
          v2.z = v47;
        }
        m_fMass = this->m_fMass;
        CrossProduct(&v69, vecOffset, &v2);
        v57 = v53 * m_fMass;
        v58 = v69.z;
        x = v2.x;
        v60 = v2.y;
        v61 = v2.z;
        v62 = v55 * v57;
        m_fTurnMass = this->m_fTurnMass;
        *(float *)&v64 = v46 * v57;
        v65 = v69.y;
        *(float *)&v66 = v47 * v57;
        v67 = v69.x;
        v71.x = v62;
        *(_QWORD *)&v71.y = __PAIR64__(v66, v64);
        CPhysical::ApplyMoveForce(this, v71);
        v68 = v54
            * (float)(1.0
                    / (float)((float)(1.0 / m_fMass)
                            + (float)((float)((float)((float)(v67 * v67) + (float)(v65 * v65)) + (float)(v58 * v58))
                                    / m_fTurnMass)));
        v72.x = x * v68;
        v72.y = v60 * v68;
        v72.z = v61 * v68;
        CPhysical::ApplyTurnForce(this, v72, *vecOffset);
        return;
      }
      if ( v25 )
      {
        fSuspensionAntiDive = fSuspensionAntiDive * 0.5;
        goto LABEL_66;
      }
    }
    v49 = 0;
    v52 = v48;
    v51 = v46;
    v50 = v47;
    goto LABEL_68;
  }
}
// 582E86: variable 'v13' is possibly undefined
// 582E86: variable 'v14' is possibly undefined
// 0: using guessed type int dword_0;
// A1305A: using guessed type char CVehicle::ProcessWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,char,float *,tWheelState *,unsigned short)::bAlreadySkidding;

//----- (00583358) --------------------------------------------------------
void __fastcall CVehicle::ProcessBikeWheel(
        CVehicle *this,
        CVector *vecForward,
        CVector *vecRight,
        CVector *vecSpeed,
        CVector *vecOffset,
        int32 nNoOfContactWheels,
        float fDriveAcceleration,
        float fDriveDeceleration,
        float fAdhesiveLimit,
        float fSideAdhesiveMult,
        int WheelNum,
        float *pWheelPitchIncrement,
        tWheelState *pWheelState,
        eBikeWheelSpecial WheelSp,
        int nWheelDamage)
{
  float32x2_t v15; // d10
  float32x2_t v16; // d13
  float v17; // s24
  float v20; // s6
  char v21; // r2
  float v22; // s4
  float z; // s0
  float v24; // s2
  float v26; // s18
  _BOOL4 v27; // r5
  bool v28; // r2
  float v29; // s0
  float v30; // s16
  int v31; // r2
  float v32; // s22
  float v33; // s0
  float v34; // s28
  int v35; // r0
  float v36; // s0
  float v37; // s26
  CPad *Pad; // r0
  float fMass; // s0
  float m_fWheelFriction; // s2
  float v41; // s2
  float v42; // s4
  tWheelState v43; // r0
  float v44; // s4
  float fTractionLoss; // s6
  float v46; // s4
  __int64 v47; // r0
  float v48; // s4
  float v49; // s6
  RwReal v50; // s18
  RwReal y; // s16
  RwReal v52; // s20
  float m_fMass; // s22
  float v54; // s2
  float x; // s28
  float v56; // s30
  float v57; // s4
  float v58; // s17
  float v59; // s18
  float v60; // s20
  float v61; // s24
  float m_fTurnMass; // s26
  float v63; // s16
  CMatrix *m_pMat; // r0
  float v65; // s8
  float yy; // s6
  float xx; // s12
  float yx; // s1
  float zy; // s10
  float zx; // s14
  float v71; // s4
  float v72; // s7
  float v73; // s0
  float xy; // s2
  float v75; // s3
  float v76; // s5
  float v77; // s7
  float v78; // s16
  float v79; // s18
  float v80; // s6
  float v81; // s12
  float v82; // s2
  float v83; // s10
  CMatrix *v84; // r0
  CVector v85; // [sp+0h] [bp-88h]
  CVector v86; // [sp+0h] [bp-88h]
  CVector v87; // [sp+10h] [bp-78h] BYREF
  CVector v88; // [sp+1Ch] [bp-6Ch] BYREF
  CVector v89; // 0:r1.12
  CVector v90; // 0:r1.12
  CVector v91; // 0:r1.12

  v17 = fDriveDeceleration;
  v20 = vecSpeed->x * vecForward->x;
  v21 = 0;
  v22 = vecSpeed->y * vecForward->y;
  z = vecForward->z;
  v24 = vecSpeed->z;
  v26 = fDriveAcceleration;
  v27 = 0;
  if ( fDriveDeceleration != 0.0 )
    v21 = 1;
  CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bBraking = v21;
  if ( fDriveDeceleration == 0.0 )
  {
    CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bDriving = fDriveAcceleration != 0.0;
    if ( fDriveAcceleration < 0.0 )
      LOBYTE(v27) = 1;
    v28 = v27;
    v27 = fDriveAcceleration != 0.0;
  }
  else
  {
    v28 = 0;
    CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bDriving = 0;
  }
  v29 = v24 * z;
  CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bReversing = v28;
  if ( *pWheelState )
  {
    CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bAlreadySkidding = 1;
    *pWheelState = WS_ROLLING;
    v30 = CTimer::ms_fTimeStep * fAdhesiveLimit;
LABEL_11:
    v30 = v30 * this->pHandling->fTractionLoss;
    goto LABEL_12;
  }
  v31 = (unsigned __int8)CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bAlreadySkidding;
  *pWheelState = WS_ROLLING;
  v30 = CTimer::ms_fTimeStep * fAdhesiveLimit;
  if ( v31 == 1 )
    goto LABEL_11;
LABEL_12:
  v15.n64_f32[0] = (float)(v20 + v22) + v29;
  v32 = 0.0;
  if ( (WheelSp | 1) != 3 )
  {
    v33 = (float)((float)(vecSpeed->x * vecRight->x) + (float)(vecSpeed->y * vecRight->y))
        + (float)(vecSpeed->z * vecRight->z);
    if ( v33 != 0.0 )
    {
      v32 = (float)-v33 / (float)nNoOfContactWheels;
      if ( nWheelDamage == 1 )
      {
        v16.n64_f32[0] = fBurstBikeSpeedMax;
        v34 = fBurstBikeTyreMod;
        v35 = rand();
        v27 = CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bDriving;
        v32 = v32
            + (float)(vmin_f32(v15, v16).n64_f32[0]
                    * (float)((float)((float)(v34 + v34) * (float)((float)v35 * 4.6566e-10)) - v34));
      }
    }
  }
  if ( !v27 )
  {
    if ( v15.n64_f32[0] == 0.0 )
    {
      v26 = 0.0;
      v36 = v32;
      goto LABEL_45;
    }
    v37 = (float)-v15.n64_f32[0] / (float)nNoOfContactWheels;
    if ( !CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bBraking
      && fabsf(this->m_fGasPedal) < 0.01 )
    {
      if ( v37 < 0.05 && v37 > -0.05 && this->m_vehicleType == 10 )
      {
        if ( !this->pDriver || (Pad = CPad::GetPad(0), !CPad::GetAccelerate(Pad)) )
          v17 = (float)(mod_HandlingManager.m_fWheelFriction * 0.5) / (float)(this->pHandling->fMass + 200.0);
      }
      else
      {
        if ( this->m_baseVehicleType == 9 )
        {
          fMass = this->pHandling->fMass + 200.0;
          m_fWheelFriction = mod_HandlingManager.m_fWheelFriction * 0.6;
        }
        else
        {
          fMass = this->pHandling->fMass;
          if ( fMass >= 500.0 )
          {
            m_fWheelFriction = mod_HandlingManager.m_fWheelFriction;
            if ( this->m_nModelIndex == 441 )
              m_fWheelFriction = mod_HandlingManager.m_fWheelFriction * 0.2;
          }
          else
          {
            m_fWheelFriction = mod_HandlingManager.m_fWheelFriction * 0.2;
          }
        }
        v17 = m_fWheelFriction / fMass;
      }
    }
    if ( v17 <= v30 )
    {
      if ( v37 <= 0.0 )
      {
        v26 = -v17;
        if ( v37 < (float)-v17 )
        {
          v36 = v32;
          goto LABEL_45;
        }
      }
      else if ( v37 > v17 )
      {
        v36 = v32;
        v26 = v17;
        goto LABEL_45;
      }
    }
    else if ( fabsf(v15.n64_f32[0]) > 0.005 )
    {
      *pWheelState = WS_LOCKED;
    }
    v36 = v32;
    v26 = (float)-v15.n64_f32[0] / (float)nNoOfContactWheels;
    goto LABEL_45;
  }
  if ( v32 <= 0.0 )
  {
    v36 = -v30;
    if ( v32 >= (float)-v30 )
      v36 = v32;
  }
  else if ( v32 <= v30 )
  {
    v36 = v32;
  }
  else
  {
    v36 = v30;
  }
LABEL_45:
  v41 = fSideAdhesiveMult;
  v42 = (float)(v36 * v36) + (float)(v26 * v26);
  if ( v42 <= (float)(v30 * v30) )
  {
    if ( fSideAdhesiveMult < 1.0 )
    {
      if ( !CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bAlreadySkidding )
        v41 = this->pHandling->fTractionLoss * fSideAdhesiveMult;
      if ( v42 > (float)(v41 * (float)((float)(v30 * v30) * v41)) )
        v36 = v36 * (float)((float)(v30 * v41) / sqrtf(v42));
    }
  }
  else
  {
    if ( *pWheelState != WS_LOCKED )
    {
      v43 = WS_SKIDDING;
      if ( CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bDriving )
        v43 = WS_SPINNING;
      if ( v15.n64_f32[0] >= 0.1 )
        v43 = WS_SKIDDING;
      *pWheelState = v43;
    }
    v44 = v30 / sqrtf(v42);
    fTractionLoss = this->pHandling->fTractionLoss;
    if ( CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bAlreadySkidding )
      fTractionLoss = 1.0;
    v46 = v44 * fTractionLoss;
    v36 = v36 * v46;
    v26 = v26 * v46;
    if ( fSideAdhesiveMult < 1.0 )
      v36 = v36 * fSideAdhesiveMult;
  }
  v47 = 0LL;
  if ( v26 != 0.0 )
    HIDWORD(v47) = 1;
  if ( v36 != 0.0 )
    LODWORD(v47) = 1;
  if ( v47 )
  {
    v48 = v26 * vecForward->y;
    v49 = v26 * vecForward->z;
    v50 = (float)(v36 * vecRight->x) + (float)(v26 * vecForward->x);
    v52 = (float)(v36 * vecRight->z) + v49;
    v88.y = (float)(v36 * vecRight->y) + v48;
    y = v88.y;
    v88.x = v50;
    v88.z = v52;
    CVector::Normalise(&v88);
    m_fMass = this->m_fMass;
    CrossProduct(&v87, vecOffset, &v88);
    v54 = v50 * v50;
    x = v88.x;
    v56 = v88.y;
    v57 = v52 * v52;
    v58 = v88.z;
    v59 = v87.x;
    v60 = v87.y;
    v61 = v87.z;
    m_fTurnMass = this->m_fTurnMass;
    v63 = sqrtf((float)(v54 + (float)(y * y)) + v57);
    v89.x = (float)(v63 * m_fMass) * v88.x;
    v89.y = (float)(v63 * m_fMass) * v88.y;
    v89.z = (float)(v63 * m_fMass) * v88.z;
    CPhysical::ApplyMoveForce(this, v89);
    m_pMat = this->m_pMat;
    v65 = vecOffset->z;
    yy = m_pMat->yy;
    xx = m_pMat->xx;
    yx = m_pMat->yx;
    zy = m_pMat->zy;
    zx = m_pMat->zx;
    v71 = vecOffset->y;
    v72 = v63
        * (float)(1.0
                / (float)((float)(1.0 / m_fMass)
                        + (float)((float)((float)((float)(v59 * v59) + (float)(v60 * v60)) + (float)(v61 * v61))
                                / m_fTurnMass)));
    v73 = vecOffset->x;
    xy = m_pMat->xy;
    v75 = v56 * v72;
    v76 = x * v72;
    v77 = v58 * v72;
    v78 = (float)((float)(vecOffset->x * xy) + (float)(v71 * yy)) + (float)(v65 * zy);
    v79 = (float)((float)(v76 * m_pMat->xx) + (float)(v75 * yx)) + (float)(v77 * zx);
    if ( WheelNum != 1
      || !((CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bBraking
         || CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bReversing) << 24) )
    {
      v80 = xx * v73;
      v81 = m_pMat->zx;
      v82 = (float)(v80 + (float)(yx * v71)) + (float)(zx * v65);
      v83 = m_pMat->yx;
      v90.x = fTweakBikeWheelTurnForce * (float)(v76 - (float)(v79 * m_pMat->xx));
      v90.y = fTweakBikeWheelTurnForce * (float)(v75 - (float)(v79 * v83));
      v90.z = fTweakBikeWheelTurnForce * (float)(v77 - (float)(v79 * v81));
      v85.x = v73 - (float)(v82 * m_pMat->xx);
      v85.y = v71 - (float)(v82 * v83);
      v85.z = v65 - (float)(v82 * v81);
      CPhysical::ApplyTurnForce(this, v90, v85);
      v84 = this->m_pMat;
      xx = v84->xx;
      yx = v84->yx;
      zx = v84->zx;
      xy = v84->xy;
      yy = v84->yy;
      zy = v84->zy;
    }
    v91.x = v79 * xx;
    v91.y = v79 * yx;
    v91.z = v79 * zx;
    v86.x = v78 * xy;
    v86.y = v78 * yy;
    v86.z = v78 * zy;
    CPhysical::ApplyTurnForce(this, v91, v86);
  }
}
// 5834EE: variable 'v15' is possibly undefined
// 5834EE: variable 'v16' is possibly undefined
// A1305D: using guessed type char CVehicle::ProcessBikeWheel(CVector &,CVector &,CVector &,CVector &,int,float,float,float,float,char,float *,tWheelState *,eBikeWheelSpecial,unsigned short)::bAlreadySkidding;

//----- (00583A80) --------------------------------------------------------
UInt32 __fastcall CVehicle::FindTyreNearestPoint(CVehicle *this, float PointX, float PointY)
{
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r2
  float v6; // s2
  float v7; // s0
  float v8; // s4
  UInt32 result; // r0
  float v10; // s0

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v6 = PointY - p_tx->m_translate.y;
  v7 = PointX - p_tx->m_translate.x;
  v8 = (float)((float)(v7 * m_pMat->xy) + (float)(v6 * m_pMat->yy)) + (float)(m_pMat->zy * 0.0);
  if ( this->m_baseVehicleType == 9 )
  {
    result = 2;
    if ( v8 > 0.0 )
      return 0;
  }
  else
  {
    v10 = (float)((float)(v7 * m_pMat->xx) + (float)(v6 * m_pMat->yx)) + (float)(m_pMat->zx * 0.0);
    if ( v8 <= 0.0 )
    {
      result = 2;
      if ( v10 > 0.0 )
        return 3;
    }
    else
    {
      return v10 > 0.0;
    }
  }
  return result;
}

//----- (00583B30) --------------------------------------------------------
void __fastcall CVehicle::ReduceVehicleDamage(CVehicle *this, float *fDamage)
{
  float PercentageProgress; // s2
  bool (__fastcall *v4)(CVehicle *); // r0

  if ( *(_BYTE *)&this->m_info <= 7u )
  {
    if ( CTheScripts::pActiveScripts && !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "strap3") )
      *fDamage = *fDamage * 0.25;
    PercentageProgress = CStats::GetPercentageProgress();
    v4 = sub_583BA0;
    if ( PercentageProgress < 100.0 )
      v4 = (bool (__fastcall *)(CVehicle *))&loc_583BA4;
    *fDamage = *fDamage * *(float *)v4;
  }
}

//----- (00583BA0) --------------------------------------------------------
bool __fastcall sub_583BA0(CVehicle *this)
{
  return CVehicle::CanUseCameraHeightSetting(this);
}

//----- (00583BA8) --------------------------------------------------------
bool __fastcall CVehicle::CanUseCameraHeightSetting(CVehicle *this)
{
  int32 m_vehicleType; // r1
  bool v2; // zf
  int m_nModelIndex; // r0

  m_vehicleType = this->m_vehicleType;
  v2 = m_vehicleType == 0;
  if ( !m_vehicleType )
    v2 = *((unsigned __int8 *)&this->m_nVehicleFlags + 1) << 29 == 0;
  if ( !v2 )
    return 0;
  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex >= 528 )
  {
    if ( ((unsigned int)(m_nModelIndex - 528) > 0x10 || ((1 << (m_nModelIndex - 16)) & 0x10005) == 0)
      && m_nModelIndex != 601 )
    {
      return (unsigned __int16)m_nModelIndex != 583;
    }
    return 0;
  }
  if ( (unsigned int)(m_nModelIndex - 407) <= 0x19 && ((1 << (m_nModelIndex + 105)) & 0x2100201) != 0
    || m_nModelIndex == 490 )
  {
    return 0;
  }
  return (unsigned __int16)m_nModelIndex != 583;
}

//----- (00583C1C) --------------------------------------------------------
Bool8 __fastcall CVehicle::CanVehicleBeDamaged(
        CVehicle *this,
        CEntity *pInflictor,
        eWeaponType WeaponUsed,
        Bool8 *pBeingShotAt)
{
  Bool8 v8; // r6

  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) == 0 )
    return 0;
  if ( *(_BYTE *)&this->m_info < 8u
    || (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x40) == 0
    || FindPlayerPed(-1) == pInflictor
    || (v8 = 0, FindPlayerVehicle(-1, 0) == pInflictor) )
  {
    if ( !FindPlayerPed(-1) || FindPlayerPed(-1) != pInflictor || FindPlayerPed(-1)->m_pAttachToEntity != this )
    {
      v8 = 0;
      *pBeingShotAt = 0;
      if ( !CPhysical::CanPhysicalBeDamaged(this, WeaponUsed, pBeingShotAt) )
        return v8;
      if ( !*pBeingShotAt || *(_BYTE *)&this->m_info > 7u || this->m_nHealth >= 250.0 )
        return 1;
    }
    return 0;
  }
  return v8;
}

//----- (00583CCC) --------------------------------------------------------
void __fastcall CVehicle::InflictDamage(
        CVehicle *this,
        CEntity *pInflictor,
        eWeaponType WeaponUsed,
        float damage,
        CVector Pos)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d1
  float v11; // s16
  float PercentageProgress; // s2
  int *v13; // r0
  CPlayerInfo *v14; // r0
  float v15; // s0
  int v16; // r0
  int32 m_baseVehicleType; // r0
  bool v18; // zf
  int v19; // r4
  _BOOL4 IsPlayer; // r0
  CLink<CEntity *> *m_pLastRenderedLink; // r1
  CPed *pDriver; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float zy; // s8
  float x; // s2
  float y; // s4
  int v28; // r2
  float yy; // s6
  float v30; // s0
  float xy; // s4
  int v32; // r1
  void (__fastcall *v33)(CVehicle *, int, int); // r3
  CVehicle *v34; // r0
  CMatrix *v35; // r1
  CSimpleTransform *p_m_transform; // r2
  float v37; // s10
  float v38; // s2
  float v39; // s4
  float v40; // s2
  float yx; // s6
  float v42; // s0
  float xx; // s4
  float zx; // s8
  float v45; // s12
  float v46; // s14
  int v47; // r1
  int v48; // r0
  float v49; // s4
  float v50; // s0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r6
  bool v52; // zf
  uint32 m_hashKey; // r0
  __int64 v54; // d16
  int v55; // r0
  float *p_m_nHealth; // r4
  float m_nHealth; // s18
  unsigned int v58; // r0
  bool v59; // zf
  uint8 m_nMaxPassengers; // r0
  int v61; // r6
  int (***v62)(void); // r8
  CEntity **p_pHandling; // r1
  __int16 v64; // r0
  int32 m_vehicleType; // r0
  eCrimeType v66; // r0
  CPlayerPed *PlayerPed; // r0
  eWeaponType v68; // [sp+4h] [bp-64h]
  CEventVehicleDamage v; // [sp+8h] [bp-60h] BYREF
  CVector v70; // [sp+28h] [bp-40h] BYREF
  Bool8 pBeingShotAt[49]; // [sp+37h] [bp-31h] BYREF

  pBeingShotAt[0] = 0;
  if ( !CVehicle::CanVehicleBeDamaged(this, pInflictor, WeaponUsed, pBeingShotAt) )
    return;
  v11 = damage;
  if ( *(_BYTE *)&this->m_info <= 7u )
  {
    if ( CTheScripts::pActiveScripts && !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "strap3") )
      v11 = damage * 0.25;
    PercentageProgress = CStats::GetPercentageProgress();
    v13 = dword_5842BC;
    if ( PercentageProgress < 100.0 )
      v13 = &dword_5842BC[1];
    v11 = v11 * *(float *)v13;
  }
  if ( v11 > 10.0
    && (FindPlayerPed(-1) == pInflictor || FindPlayerVehicle(-1, 0) == pInflictor)
    && (*(_BYTE *)&this->m_info & 0xF8) != 40 )
  {
    v14 = &CWorld::Players[CWorld::PlayerInFocus];
    v15 = v14->CurrentChaseValue + 1.0;
    v14->HavocCaused += 2;
    v14->CurrentChaseValue = v15;
    v16 = rand();
    CStats::IncrementStat(0x7Du, (float)(v16 % 20 + 5));
  }
  if ( pInflictor && (*(_BYTE *)&pInflictor->m_info & 7) == 3 )
  {
    m_baseVehicleType = this->m_baseVehicleType;
    v18 = m_baseVehicleType == 9;
    if ( m_baseVehicleType != 9 )
      v18 = m_baseVehicleType == 0;
    if ( v18 )
    {
      v19 = 0;
      switch ( WeaponUsed )
      {
        case WEAPONTYPE_PISTOL:
        case WEAPONTYPE_PISTOL_SILENCED:
        case WEAPONTYPE_SHOTGUN:
        case WEAPONTYPE_MICRO_UZI:
        case WEAPONTYPE_MP5:
        case WEAPONTYPE_TEC9:
        case WEAPONTYPE_UZI_DRIVEBY:
          v19 = 5;
          break;
        case WEAPONTYPE_DESERT_EAGLE:
          v19 = 64;
          break;
        case WEAPONTYPE_AK47:
        case WEAPONTYPE_M4:
          v19 = 10;
          break;
        default:
          break;
      }
      IsPlayer = CPed::IsPlayer((const CPed *)pInflictor);
      m_pLastRenderedLink = pInflictor[23].m_pLastRenderedLink;
      if ( IsPlayer )
        v19 = 0;
      if ( m_pLastRenderedLink && m_pLastRenderedLink[120].m_pPrev == (CLink<CEntity *> *)byte_9 )
      {
        if ( !v19 )
          goto LABEL_53;
        v19 = 1;
      }
      else if ( this->m_nModelIndex == 523 && (pDriver = this->pDriver) != 0 )
      {
        if ( !v19 || pDriver->m_nPedType == 6 )
          goto LABEL_53;
      }
      else if ( !v19 )
      {
        goto LABEL_53;
      }
      if ( *(_DWORD *)&this->m_nVehicleFlags >= 0 && (rand() & 0x7F) < v19 )
      {
        if ( this->m_baseVehicleType == 9 )
        {
          m_pMat = this->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &this->m_transform;
          zy = m_pMat->zy;
          x = p_tx->m_translate.x;
          y = p_tx->m_translate.y;
          v28 = 0;
          yy = m_pMat->yy;
          v30 = Pos.y - y;
          xy = m_pMat->xy;
          v32 = 15;
          v33 = (void (__fastcall *)(CVehicle *, int, int))*((_DWORD *)this->_vptr$CPlaceable + 45);
          v34 = this;
          if ( (float)((float)((float)((float)(Pos.x - x) * xy) + (float)(v30 * yy)) + (float)(zy * 0.0)) > 0.0 )
            v32 = 13;
        }
        else
        {
          if ( HIBYTE(this->pHandling->mFlags) << 28 )
            goto LABEL_53;
          v35 = this->m_pMat;
          p_m_transform = (CSimpleTransform *)&v35->tx;
          if ( !v35 )
            p_m_transform = &this->m_transform;
          v37 = v35->xy;
          v38 = p_m_transform->m_translate.x;
          v39 = p_m_transform->m_translate.y;
          v28 = 1;
          v40 = Pos.x - v38;
          yx = v35->yx;
          v42 = Pos.y - v39;
          xx = v35->xx;
          zx = v35->zx;
          v45 = v35->yy;
          v46 = v35->zy;
          v47 = 0;
          v33 = (void (__fastcall *)(CVehicle *, int, int))*((_DWORD *)this->_vptr$CPlaceable + 45);
          v48 = 2;
          v49 = (float)(v40 * xx) + (float)(v42 * yx);
          v50 = (float)((float)(v40 * v37) + (float)(v42 * v45)) + (float)(v46 * 0.0);
          if ( (float)(v49 + (float)(zx * 0.0)) > 0.0 )
          {
            v47 = 1;
            v48 = 3;
          }
          if ( v50 > 0.0 )
            v48 = v47;
          v32 = v48 + 13;
          v34 = this;
        }
        v33(v34, v32, v28);
      }
    }
  }
LABEL_53:
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 6) & 0x40) != 0 )
  {
    v52 = pInflictor == 0;
    if ( pInflictor )
      v52 = pBeingShotAt[0] == 0;
    if ( !v52 && (*(_BYTE *)&pInflictor->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)pInflictor) )
    {
      m_hashKey = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey;
      v54 = *(_QWORD *)(m_hashKey + 96);
      v55 = *(_DWORD *)(m_hashKey + 104);
      *(_QWORD *)&v._vptr$CEvent = v54;
      *(_DWORD *)&v.m_bIsPersistent = v55;
      if ( *(float *)&v54 != 0.0 || *(float *)&v.m_bIsPersistent != 0.0 )
      {
        operator*(&v70, this->m_pMat, (const CVector *)&v);
        if ( sqrtf(
               (float)((float)((float)(Pos.x - v70.x) * (float)(Pos.x - v70.x))
                     + (float)((float)(Pos.y - v70.y) * (float)(Pos.y - v70.y)))
             + (float)((float)(Pos.z - v70.z) * (float)(Pos.z - v70.z))) < 0.25 )
        {
          v5.n64_u32[0] = 1149861888;
          v6.n64_u32[0] = LODWORD(this->m_nHealth);
          LODWORD(v11) = vmin_f32(v6, v5).n64_u32[0];
        }
      }
    }
  }
  if ( (unsigned int)(this->m_vehicleType - 3) <= 1
    && !(*((unsigned __int8 *)&this->m_nVehicleFlags + 4) >> 7)
    && ((unsigned int)WeaponUsed > WEAPONTYPE_ROCKET_HS || ((1 << WeaponUsed) & 0x190000) == 0)
    && WeaponUsed != WEAPONTYPE_EXPLOSION )
  {
    v11 = v11 * 0.4;
  }
  p_m_nHealth = &this->m_nHealth;
  m_nHealth = this->m_nHealth;
  if ( m_nHealth <= 0.0 )
    goto LABEL_104;
  this->LastDamagedWeaponType = WeaponUsed;
  if ( pInflictor )
  {
    this->pLastDamageEntity = pInflictor;
    CEntity::RegisterReference(pInflictor, &this->pLastDamageEntity);
    m_nHealth = *p_m_nHealth;
  }
  if ( m_nHealth > v11 )
  {
    v68 = WeaponUsed;
    *p_m_nHealth = m_nHealth - v11;
    v58 = *(_BYTE *)&this->m_info >> 3;
    if ( v58 <= 3 )
    {
      v59 = v58 == 1;
      if ( v58 != 1 )
        v59 = pInflictor == 0;
      if ( !v59 && (*(_BYTE *)&pInflictor->m_info & 7) == 3 )
      {
        if ( this->pDriver )
        {
          CEventVehicleDamage::CEventVehicleDamage(&v, this, pInflictor, WeaponUsed);
          v._vptr$CEvent = (int (**)(void))&off_669BAC;
          CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v, 0);
          CEventVehicleDamage::~CEventVehicleDamage(&v);
        }
        m_nMaxPassengers = this->m_nMaxPassengers;
        if ( m_nMaxPassengers )
        {
          v61 = 0;
          do
          {
            v62 = &this->_vptr$CPlaceable + v61;
            if ( v62[282] )
            {
              CEventVehicleDamage::CEventVehicleDamage(&v, this, pInflictor, v68);
              v._vptr$CEvent = (int (**)(void))&off_669BAC;
              CEventGroup::Add((CEventGroup *)((char *)v62[282][272] + 104), (CEvent *)&v, 0);
              CEventVehicleDamage::~CEventVehicleDamage(&v);
              m_nMaxPassengers = this->m_nMaxPassengers;
            }
            ++v61;
          }
          while ( v61 < m_nMaxPassengers );
        }
      }
    }
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    if ( m_nHealth < 250.0 )
      goto LABEL_104;
    if ( *p_m_nHealth >= 250.0 )
      goto LABEL_104;
    if ( this->m_baseVehicleType )
      goto LABEL_104;
    CDamageManager::SetEngineStatus((CDamageManager *)&this[1], 0xE1u);
    this[1].pHandling = (tHandlingData *)pInflictor;
    if ( !pInflictor )
      goto LABEL_104;
    p_pHandling = (CEntity **)&this[1].pHandling;
LABEL_94:
    CEntity::RegisterReference(pInflictor, p_pHandling);
    goto LABEL_104;
  }
  *p_m_nHealth = 0.0;
  if ( FindPlayerPed(-1) == pInflictor )
  {
    m_vehicleType = this->m_vehicleType;
    if ( m_vehicleType == 4 )
    {
      if ( !(*((unsigned __int8 *)&this->m_nVehicleFlags + 4) >> 7) )
      {
        v66 = CRIME_DESTROY_PLANE;
        goto LABEL_102;
      }
    }
    else if ( m_vehicleType == 3 && !(*((unsigned __int8 *)&this->m_nVehicleFlags + 4) >> 7) )
    {
      v66 = CRIME_DESTROY_HELI;
      goto LABEL_102;
    }
    v66 = CRIME_DESTROY_VEHICLE;
LABEL_102:
    CCrime::ReportCrime(v66, this, (CPed *)pInflictor);
    if ( WeaponUsed == WEAPONTYPE_EXPLOSION )
      goto LABEL_92;
    goto LABEL_103;
  }
  if ( WeaponUsed == WEAPONTYPE_EXPLOSION )
  {
LABEL_92:
    v64 = rand();
    this->pDelayedExplosionInflictor = pInflictor;
    this->DelayedExplosion = (v64 & 0x7FF) + 1000;
    if ( !pInflictor )
      goto LABEL_104;
    p_pHandling = &this->pDelayedExplosionInflictor;
    goto LABEL_94;
  }
LABEL_103:
  (*((void (__fastcall **)(CVehicle *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(this, pInflictor, 0);
LABEL_104:
  if ( *(_BYTE *)p_m_nVehicleFlags << 31 )
  {
    if ( FindPlayerPed(-1) == pInflictor )
    {
      PlayerPed = FindPlayerPed(-1);
      CPlayerPed::SetWantedLevelNoDrop(PlayerPed, 1);
    }
  }
}
// 58409C: variable 'v6' is possibly undefined
// 58409C: variable 'v5' is possibly undefined
// 5842BC: using guessed type int dword_5842BC[2];
// 669BAC: using guessed type void *off_669BAC;
// 583CCC: using guessed type Bool8 pBeingShotAt[49];

//----- (005842E8) --------------------------------------------------------
void __fastcall CVehicle::ProcessDelayedExplosion(CVehicle *this)
{
  unsigned int DelayedExplosion; // r1
  unsigned int v2; // r2
  bool v3; // cc
  UInt16 v4; // r1

  DelayedExplosion = this->DelayedExplosion;
  if ( this->DelayedExplosion )
  {
    v2 = (unsigned int)(float)(CTimer::ms_fTimeStep * 16.667);
    v3 = DelayedExplosion > v2;
    v4 = DelayedExplosion - v2;
    if ( !v3 )
      v4 = 0;
    this->DelayedExplosion = v4;
    if ( !v4 )
      (*((void (__fastcall **)(CVehicle *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(
        this,
        this->pDelayedExplosionInflictor,
        0);
  }
}

//----- (00584338) --------------------------------------------------------
bool __fastcall CVehicle::AddPassenger(CVehicle *this, CPed *pPed)
{
  float m_fMass; // s0
  CMatrix *m_pMat; // r0
  float v6; // s0
  CMatrix *v7; // r0
  float v8; // s4
  float v9; // s6
  CPed **pPassengers; // r1
  int v11; // r2
  int v12; // r3
  _BYTE v14[12]; // [sp+0h] [bp-20h]
  CVector v15; // 0:r1.12

  m_fMass = pPed->m_fMass;
  if ( this->m_baseVehicleType == 9 )
  {
    m_pMat = this->m_pMat;
    v6 = m_fMass * -0.02;
    v15.x = v6 * m_pMat->xz;
    v15.y = v6 * m_pMat->yz;
    v15.z = v6 * m_pMat->zz;
    *(float *)v14 = m_pMat->xy * -0.1;
    *(float *)&v14[4] = m_pMat->yy * -0.1;
    *(float *)&v14[8] = m_pMat->zy * -0.1;
  }
  else
  {
    v15.y = 0.0;
    LODWORD(v15.x) = pPed->m_pMat;
    v7 = this->m_pMat;
    v8 = *(float *)(LODWORD(v15.x) + 48);
    v9 = *(float *)(LODWORD(v15.x) + 52);
    v15.x = 0.0;
    v15.z = m_fMass * -0.2;
    *(float *)v14 = v8 - v7->tx;
    *(_QWORD *)&v14[4] = COERCE_UNSIGNED_INT(v9 - v7->ty);
  }
  CPhysical::ApplyTurnForce(this, v15, *(CVector *)v14);
  if ( !this->m_nMaxPassengers )
    return 0;
  pPassengers = this->pPassengers;
  v11 = 0;
  v12 = 0;
  while ( pPassengers[v12] )
  {
    ++v12;
    ++v11;
    if ( v12 >= this->m_nMaxPassengers )
      return 0;
  }
  pPassengers[v12] = pPed;
  CEntity::RegisterReference(pPed, &pPassengers[v11]);
  ++this->m_nNumPassengers;
  return 1;
}

//----- (00584438) --------------------------------------------------------
bool __fastcall CVehicle::AddPassenger(CVehicle *this, CPed *pPed, uint8 nSeat)
{
  unsigned int v4; // r6
  float m_fMass; // s0
  CMatrix *m_pMat; // r0
  float v8; // s0
  CMatrix *v10; // r0
  float v11; // s4
  float v12; // s6
  int (***v13)(void); // r0
  _BYTE v14[12]; // [sp+0h] [bp-20h]
  CVector v15; // 0:r1.12

  v4 = nSeat;
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 1) & 2) != 0 )
    return CVehicle::AddPassenger(this, pPed);
  m_fMass = pPed->m_fMass;
  if ( this->m_baseVehicleType == 9 )
  {
    m_pMat = this->m_pMat;
    v8 = m_fMass * -0.02;
    v15.x = v8 * m_pMat->xz;
    v15.y = v8 * m_pMat->yz;
    v15.z = v8 * m_pMat->zz;
    *(float *)v14 = m_pMat->xy * -0.1;
    *(float *)&v14[4] = m_pMat->yy * -0.1;
    *(float *)&v14[8] = m_pMat->zy * -0.1;
  }
  else
  {
    v15.y = 0.0;
    LODWORD(v15.x) = pPed->m_pMat;
    v10 = this->m_pMat;
    v11 = *(float *)(LODWORD(v15.x) + 48);
    v12 = *(float *)(LODWORD(v15.x) + 52);
    v15.x = 0.0;
    v15.z = m_fMass * -0.2;
    *(float *)v14 = v11 - v10->tx;
    *(_QWORD *)&v14[4] = COERCE_UNSIGNED_INT(v12 - v10->ty);
  }
  CPhysical::ApplyTurnForce(this, v15, *(CVector *)v14);
  if ( this->m_nMaxPassengers <= v4 )
    return 0;
  v13 = &this->_vptr$CPlaceable + v4;
  if ( v13[282] )
    return 0;
  v13[282] = (int (**)(void))pPed;
  CEntity::RegisterReference(pPed, (CEntity **)v13 + 282);
  ++this->m_nNumPassengers;
  return 1;
}

//----- (00584548) --------------------------------------------------------
void __fastcall CVehicle::RemovePassenger(CVehicle *this, CPed *pPed)
{
  CPed **pPassengers; // r5
  int v4; // r2

  if ( pPed )
  {
    if ( this->m_baseVehicleType == 6 )
    {
      if ( this->pPassengers[0] == pPed )
      {
        pPassengers = this->pPassengers;
      }
      else if ( this->pPassengers[1] == pPed )
      {
        pPassengers = &this->pPassengers[1];
      }
      else if ( this->pPassengers[2] == pPed )
      {
        pPassengers = &this->pPassengers[2];
      }
      else if ( this->pPassengers[3] == pPed )
      {
        pPassengers = &this->pPassengers[3];
      }
      else if ( this->pPassengers[4] == pPed )
      {
        pPassengers = &this->pPassengers[4];
      }
      else if ( this->pPassengers[5] == pPed )
      {
        pPassengers = &this->pPassengers[5];
      }
      else if ( this->pPassengers[6] == pPed )
      {
        pPassengers = &this->pPassengers[6];
      }
      else
      {
        if ( this->pPassengers[7] != pPed )
          return;
        pPassengers = &this->pPassengers[7];
      }
      goto LABEL_24;
    }
    if ( this->m_nMaxPassengers )
    {
      pPassengers = this->pPassengers;
      v4 = 0;
      while ( *pPassengers != pPed )
      {
        ++v4;
        ++pPassengers;
        if ( v4 >= this->m_nMaxPassengers )
          return;
      }
LABEL_24:
      CEntity::CleanUpOldReference(pPed, pPassengers);
      *pPassengers = 0;
      --this->m_nNumPassengers;
    }
  }
}

//----- (005845FC) --------------------------------------------------------
void __fastcall CVehicle::SetDriver(CVehicle *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CEntity **p_pDriver; // r6
  CPed *pDriver; // r0
  float v8; // s0
  CMatrix *m_pMat; // r0
  CMatrix *v10; // r0
  CMatrix *v11; // r1
  float tx; // s4
  float ty; // s6
  int m_nModelIndex; // r0
  CVector v15; // [sp+0h] [bp-20h]
  CVector v16; // 0:r1.12
  CVector v17; // 0:r1.12

  p_pDriver = &this->pDriver;
  pDriver = this->pDriver;
  if ( pDriver )
    CEntity::CleanUpOldReference(pDriver, p_pDriver);
  this->pDriver = pPed;
  CEntity::RegisterReference(pPed, p_pDriver);
  if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x80) != 0 && FindPlayerPed(-1) == pPed )
  {
    *(_DWORD *)&this->m_nVehicleFlags &= ~0x80u;
    m_nModelIndex = this->m_nModelIndex;
    switch ( this->m_nModelIndex )
    {
      case 0x1A0:
        CPlayerInfo::AddHealth(CWorld::Players, 20);
        break;
      case 0x1A1:
      case 0x1A2:
      case 0x1A3:
      case 0x1A5:
      case 0x1A6:
      case 0x1A7:
      case 0x1A8:
      case 0x1A9:
      case 0x1AA:
      case 0x1AC:
      case 0x1AD:
      case 0x1AE:
      case 0x1AF:
      case 0x1B0:
      case 0x1B1:
      case 0x1B2:
      case 0x1B3:
      case 0x1B4:
      case 0x1B5:
      case 0x1B7:
      case 0x1B8:
      case 0x1B9:
      case 0x1BA:
      case 0x1BB:
      case 0x1BC:
      case 0x1BD:
      case 0x1BE:
      case 0x1BF:
      case 0x1C0:
      case 0x1C1:
      case 0x1C2:
      case 0x1C3:
      case 0x1C4:
      case 0x1C5:
      case 0x1C6:
      case 0x1C7:
      case 0x1C8:
        break;
      case 0x1A4:
      case 0x1B6:
        CWorld::Players[CWorld::PlayerInFocus].Score += 12;
        break;
      case 0x1AB:
        v2.n64_u32[0] = LODWORD(pPed->m_nArmour);
        v3.n64_f32[0] = (float)CWorld::Players[0].MaxArmour;
        LODWORD(pPed->m_nArmour) = vmax_f32(v2, v3).n64_u32[0];
        break;
      case 0x1C9:
        if ( !CPed::IsPlayer(pPed) || CPlayerPed::DoesPlayerWantNewWeapon((CPlayerPed *)pPed, WEAPONTYPE_GOLFCLUB, 1) )
          CStreaming::RequestModel(333, 2);
        break;
      default:
        if ( (unsigned int)(m_nModelIndex - 596) >= 4 )
        {
          if ( m_nModelIndex == 588 )
            CStats::IncrementStat(0xF5u, 40.0);
        }
        else
        {
          CStreaming::RequestModel(349, 2);
          *(_DWORD *)&this->m_nVehicleFlags |= 0x80u;
        }
        break;
    }
  }
  v8 = pPed->m_fMass * -0.02;
  if ( this->m_baseVehicleType == 9 )
  {
    m_pMat = this->m_pMat;
    v16.x = v8 * m_pMat->xz;
    v16.y = v8 * m_pMat->yz;
    v16.z = v8 * m_pMat->zz;
    sub_1932F0(this, v16);
  }
  else
  {
    v17.z = pPed->m_fMass * -0.02;
    v10 = this->m_pMat;
    v11 = pPed->m_pMat;
    v17.y = 0.0;
    tx = v11->tx;
    ty = v11->ty;
    v17.x = 0.0;
    v15.x = tx - v10->tx;
    *(_QWORD *)&v15.y = COERCE_UNSIGNED_INT(ty - v10->ty);
    CPhysical::ApplyTurnForce(this, v17, v15);
  }
}
// 5847AE: variable 'v2' is possibly undefined
// 5847AE: variable 'v3' is possibly undefined

//----- (005847CC) --------------------------------------------------------
void __fastcall CVehicle::RemoveDriver(CVehicle *this, bool bDontTurnOffEngine)
{
  const CPed **p_pDriver; // r4
  CPlayerPed *v4; // r6
  int m_nModelIndex; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r5
  _BOOL4 DoesPlayerWantNewWeapon; // r1
  CPed *v8; // r0
  int32 v9; // r0

  p_pDriver = (const CPed **)&this->pDriver;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x20);
  if ( !bDontTurnOffEngine && (!*p_pDriver || !CPed::IsPlayer(*p_pDriver)) )
    *(_DWORD *)&this->m_nVehicleFlags &= ~0x10u;
  v4 = (CPlayerPed *)*p_pDriver;
  if ( v4 == FindPlayerPed(-1) )
  {
    m_nModelIndex = this->m_nModelIndex;
    if ( (unsigned int)(m_nModelIndex - 596) < 4 )
    {
      if ( CStreaming::ms_aInfoForModel[349].m_status != 1 )
        goto LABEL_20;
      if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x80) != 0 )
      {
        p_m_nVehicleFlags = &this->m_nVehicleFlags;
        DoesPlayerWantNewWeapon = CPlayerPed::DoesPlayerWantNewWeapon((CPlayerPed *)*p_pDriver, WEAPONTYPE_SHOTGUN, 1);
        v8 = (CPed *)*p_pDriver;
        if ( DoesPlayerWantNewWeapon )
          CPed::GiveWeapon(v8, WEAPONTYPE_SHOTGUN, 5u, 1);
        else
          CPed::GrantAmmo(v8, WEAPONTYPE_SHOTGUN, 5u);
        *(_DWORD *)p_m_nVehicleFlags &= ~0x80u;
      }
      v9 = 349;
      goto LABEL_19;
    }
    if ( m_nModelIndex == 457 && CStreaming::ms_aInfoForModel[333].m_status == 1 )
    {
      if ( CPlayerPed::DoesPlayerWantNewWeapon((CPlayerPed *)*p_pDriver, WEAPONTYPE_GOLFCLUB, 1) )
        CPed::GiveWeapon((CPed *)*p_pDriver, WEAPONTYPE_GOLFCLUB, 1u, 1);
      v9 = 333;
LABEL_19:
      CStreaming::SetModelIsDeletable(v9);
    }
  }
LABEL_20:
  if ( *p_pDriver )
    CEntity::CleanUpOldReference(&(*p_pDriver)->CPhysical, (CEntity **)p_pDriver);
  *p_pDriver = 0;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005848C4) --------------------------------------------------------
CPed *__fastcall CVehicle::SetUpDriver(CVehicle *this, Int32 CarRating, bool bMustBeMale, bool bCriminal)
{
  CPed *result; // r0

  result = this->pDriver;
  if ( !result )
  {
    if ( this->VehicleCreatedBy == 1 )
    {
      CPopulation::AddPedInCar(this, 1, CarRating, 0, bMustBeMale, bCriminal);
      return this->pDriver;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (005848FE) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CPed *__fastcall CVehicle::SetupPassenger(
        CVehicle *this,
        int32 seat_num,
        Int32 CarRating,
        bool bMustBeMale,
        int bCriminal)
{
  int v5; // r1
  int v6; // r10
  CVehicle *v7; // r4
  CPed *v9; // r6
  bool v10; // zf
  int v11; // r1
  int32 v12; // r1
  unsigned int m_nPedType; // r0
  int m_nModelIndex; // r9
  CPed *pDriver; // r0
  int i; // r5
  CPed *v18; // r0
  bool v19; // zf

  v6 = v5;
  v7 = this;
  v9 = this->pPassengers[v5];
  if ( !v9 )
  {
    this = (CVehicle *)(unsigned __int16)this->m_nModelIndex;
    v10 = this == (CVehicle *)((char *)&elf_hash_bucket[46] + 2);
    if ( this != (CVehicle *)((char *)&elf_hash_bucket[46] + 2) )
      v10 = this == (CVehicle *)&elf_hash_bucket[42];
    if ( v10 )
    {
      if ( !v11 )
      {
LABEL_16:
        v9 = 0;
        CVehicle::RemovePassenger(v7, 0);
        return v9;
      }
    }
    else if ( *(_QWORD *)&this == 409LL )
    {
      goto LABEL_16;
    }
    v9 = CPopulation::AddPedInCar(v7, 0, CarRating, v12, bMustBeMale, bCriminal);
    m_nPedType = v9->m_nPedType;
    m_nModelIndex = (unsigned __int16)v9->m_nModelIndex;
    if ( (m_nPedType > 0x13 || ((1 << m_nPedType) & (unsigned int)"eObjectCarriedWithRopeEv") == 0)
      && m_nPedType - 7 >= 0xA
      && ((unsigned int)(CarRating - 14) > 9 || m_nPedType != 20) )
    {
      pDriver = v7->pDriver;
      if ( pDriver && (unsigned __int16)pDriver->m_nModelIndex == m_nModelIndex )
      {
        CVehicle::RemovePassenger(v7, v9);
        CPopulation::RemovePed(v9);
        return 0;
      }
      else if ( v6 >= 1 )
      {
        for ( i = 0; i != v6; ++i )
        {
          v18 = v7->pPassengers[i];
          if ( v18 != v9 )
          {
            v19 = v9 == 0;
            if ( v9 )
              v19 = v18 == 0;
            if ( !v19 && (unsigned __int16)v18->m_nModelIndex == m_nModelIndex )
            {
              CVehicle::RemovePassenger(v7, v9);
              CPopulation::RemovePed(v9);
              v9 = 0;
            }
          }
        }
      }
    }
  }
  return v9;
}
// 5848FE: variables would overlap: r0.4 and r0.8
// FC: using guessed type int elf_hash_bucket[16411];

//----- (005849E8) --------------------------------------------------------
bool __fastcall CVehicle::IsPassenger(const CVehicle *this, const CPed *pPed)
{
  CPed *v3; // r2
  bool v4; // zf
  CPed *v5; // r2
  bool v6; // zf
  CPed *v7; // r2
  bool v8; // zf

  if ( !pPed )
    return 0;
  if ( this->pPassengers[0] == pPed )
    return 1;
  v3 = this->pPassengers[1];
  v4 = v3 == pPed;
  if ( v3 != pPed )
    v4 = this->pPassengers[2] == pPed;
  if ( v4 )
    return 1;
  v5 = this->pPassengers[3];
  v6 = v5 == pPed;
  if ( v5 != pPed )
    v6 = this->pPassengers[4] == pPed;
  if ( v6 )
    return 1;
  v7 = this->pPassengers[5];
  v8 = v7 == pPed;
  if ( v7 != pPed )
    v8 = this->pPassengers[6] == pPed;
  if ( v8 )
    return 1;
  return this->pPassengers[7] == pPed;
}

//----- (00584A3A) --------------------------------------------------------
bool __fastcall CVehicle::IsPassenger(const CVehicle *this, int iModelIndex)
{
  CPed *v2; // r2
  CPed *v3; // r2
  CPed *v4; // r2
  CPed *v5; // r2
  CPed *v6; // r2
  CPed *v7; // r2
  CPed *v8; // r2
  CPed *v9; // r0
  bool result; // r0

  v2 = this->pPassengers[0];
  result = 1;
  if ( !v2 || v2->m_nModelIndex != iModelIndex )
  {
    v3 = this->pPassengers[1];
    if ( !v3 || v3->m_nModelIndex != iModelIndex )
    {
      v4 = this->pPassengers[2];
      if ( !v4 || v4->m_nModelIndex != iModelIndex )
      {
        v5 = this->pPassengers[3];
        if ( !v5 || v5->m_nModelIndex != iModelIndex )
        {
          v6 = this->pPassengers[4];
          if ( !v6 || v6->m_nModelIndex != iModelIndex )
          {
            v7 = this->pPassengers[5];
            if ( !v7 || v7->m_nModelIndex != iModelIndex )
            {
              v8 = this->pPassengers[6];
              if ( !v8 || v8->m_nModelIndex != iModelIndex )
              {
                v9 = this->pPassengers[7];
                if ( !v9 || v9->m_nModelIndex != iModelIndex )
                  return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00584AB2) --------------------------------------------------------
bool __fastcall CVehicle::IsDriver(const CVehicle *this, const CPed *pPed)
{
  bool result; // r0

  result = 0;
  if ( pPed )
  {
    if ( this->pDriver == pPed )
      return 1;
  }
  return result;
}

//----- (00584AC8) --------------------------------------------------------
bool __fastcall CVehicle::IsDriver(const CVehicle *this, int iModelIndex)
{
  CPed *pDriver; // r0

  pDriver = this->pDriver;
  return pDriver && pDriver->m_nModelIndex == iModelIndex;
}

//----- (00584ADE) --------------------------------------------------------
void __fastcall CVehicle::KillPedsInVehicle(CVehicle *this)
{
  uint8 m_nMaxPassengers; // r0
  int v3; // r6
  const CPed **v4; // r5
  CEventVehicleDied v5; // [sp+4h] [bp-24h] BYREF

  if ( this->pDriver )
  {
    if ( !CGameLogic::IsCoopGameGoingOn() )
      CDarkel::RegisterKillByPlayer(this->pDriver, WEAPONTYPE_EXPLOSION, 0, 0);
    CEventVehicleDied::CEventVehicleDied(&v5, this);
    CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, &v5, 0);
    CEventVehicleDied::~CEventVehicleDied(&v5);
  }
  m_nMaxPassengers = this->m_nMaxPassengers;
  if ( m_nMaxPassengers )
  {
    v3 = 0;
    do
    {
      v4 = (const CPed **)(&this->_vptr$CPlaceable + v3);
      if ( v4[282] )
      {
        if ( !CGameLogic::IsCoopGameGoingOn() )
          CDarkel::RegisterKillByPlayer(v4[282], WEAPONTYPE_EXPLOSION, 0, 0);
        CEventVehicleDied::CEventVehicleDied(&v5, this);
        CEventGroup::Add(&v4[282]->m_pPedIntelligence->m_eventGroup, &v5, 0);
        CEventVehicleDied::~CEventVehicleDied(&v5);
        m_nMaxPassengers = this->m_nMaxPassengers;
      }
      ++v3;
    }
    while ( v3 < m_nMaxPassengers );
  }
}

//----- (00584B84) --------------------------------------------------------
void __fastcall CVehicle::KillPedsGettingInVehicle(CVehicle *this)
{
  CPedPool *v1; // r8
  int32 m_nSize; // r0
  int v3; // r10
  int v4; // r9
  CPedDamageResponseCalculator *v5; // r1
  CVehicle *m_pParent; // r0
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r11
  uint8 *v8; // r5
  bool v9; // zf
  CPedDamageResponseCalculator *v10; // r4
  CTask *ActiveTaskByType; // r0
  const CEventDamage *v12; // r0
  CEventDamage v14; // [sp+20h] [bp-70h] BYREF
  CPedDamageResponseCalculator v15; // [sp+60h] [bp-30h] BYREF

  v1 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v3 = m_nSize - 1;
    v4 = 1996 * m_nSize - 908;
    v5 = &v15;
    do
    {
      if ( (v1->m_aFlags[v3] & 0x80u) == 0 )
      {
        m_aStorage = v1->m_aStorage;
        v8 = &(*v1->m_aStorage)[v4];
        if ( v8 != (uint8 *)&elf_hash_bucket[209] )
        {
          v9 = v8[69] << 31 == 0;
          if ( !(v8[69] << 31) )
            v9 = (*m_aStorage)[v4 - 1060] << 31 == 0;
          if ( v9 )
          {
            v10 = v5;
            ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                                 (const CTaskManager *)(*(_DWORD *)&(*m_aStorage)[v4] + 4),
                                 701);
            if ( ActiveTaskByType
              || (ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                                       (const CTaskManager *)(*(_DWORD *)&(*m_aStorage)[v4] + 4),
                                       700)) != 0 )
            {
              m_pParent = (CVehicle *)ActiveTaskByType[1].m_pParent;
            }
            else
            {
              m_pParent = 0;
            }
            v5 = v10;
            if ( m_pParent == this )
            {
              CPedDamageResponseCalculator::CPedDamageResponseCalculator(
                v10,
                (const CEntity *)(v8 - 1088),
                1000.0,
                WEAPONTYPE_EXPLOSION,
                PED_SPHERE_CHEST,
                0);
              CEventDamage::CEventDamage(
                &v14,
                (CEntity *)(v8 - 1088),
                CTimer::m_snTimeInMilliseconds,
                WEAPONTYPE_EXPLOSION,
                PED_SPHERE_CHEST,
                0,
                0,
                *((_DWORD *)v8 + 17) & 0x100);
              if ( CEventDamage::AffectsPed(v12, (CPed *)(v8 - 1088)) )
                CPedDamageResponseCalculator::ComputeDamageResponse(
                  &v15,
                  (CPed *)(v8 - 1088),
                  &v14.m_pedDamageResponse,
                  1);
              else
                v14.m_pedDamageResponse.m_bDamageCalculated = 1;
              CEventGroup::Add((CEventGroup *)(*(_DWORD *)&(*m_aStorage)[v4] + 104), (CEvent *)&v14, 0);
              CEventDamage::~CEventDamage(&v14);
              CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v15);
              v5 = &v15;
            }
          }
        }
      }
      --v3;
      v4 -= 1996;
    }
    while ( v3 != -1 );
  }
}
// 584C7C: variable 'v12' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (00584CEC) --------------------------------------------------------
Bool8 __fastcall CVehicle::UsesSiren(const CVehicle *this)
{
  int m_nModelIndex; // r1
  Bool8 result; // r0
  bool v3; // zf

  m_nModelIndex = this->m_nModelIndex;
  result = 1;
  if ( m_nModelIndex <= 522 )
  {
    if ( (unsigned int)(m_nModelIndex - 407) <= 0x1A )
    {
      if ( ((1 << (m_nModelIndex + 105)) & 0x4910201) != 0 )
        return result;
      if ( m_nModelIndex == 432 )
        return 0;
    }
    if ( m_nModelIndex != 490 )
      return 0;
  }
  else if ( (unsigned int)(m_nModelIndex - 596) > 5 || m_nModelIndex == 600 )
  {
    v3 = m_nModelIndex == 523;
    if ( m_nModelIndex != 523 )
      v3 = m_nModelIndex == 528;
    if ( !v3 )
      return 0;
  }
  return result;
}

//----- (00584D44) --------------------------------------------------------
Bool8 __fastcall CVehicle::IsLawEnforcementVehicle(const CVehicle *this)
{
  int m_nModelIndex; // r1
  Bool8 result; // r0

  m_nModelIndex = this->m_nModelIndex;
  result = 1;
  if ( m_nModelIndex >= 528 )
  {
    if ( ((unsigned int)(m_nModelIndex - 596) > 5 || m_nModelIndex == 600) && m_nModelIndex != 528 )
      return 0;
  }
  else if ( ((unsigned int)(m_nModelIndex - 427) > 6 || ((1 << (m_nModelIndex + 85)) & 0x69) == 0)
         && m_nModelIndex != 490
         && m_nModelIndex != 523 )
  {
    return 0;
  }
  return result;
}

//----- (00584D90) --------------------------------------------------------
Bool8 __fastcall CVehicle::IsUpsideDown(const CVehicle *this)
{
  return this->m_pMat->zz <= -0.9;
}

//----- (00584DB0) --------------------------------------------------------
Bool8 __fastcall CVehicle::IsOnItsSide(const CVehicle *this)
{
  char v1; // r1
  float zx; // s4
  char v3; // r0

  v1 = 0;
  zx = this->m_pMat->zx;
  v3 = 0;
  if ( zx >= 0.8 )
    v1 = 1;
  if ( zx <= -0.8 )
    v3 = 1;
  return v3 | v1;
}

//----- (00584DE8) --------------------------------------------------------
Bool8 __fastcall CVehicle::CanPedOpenLocks(const CVehicle *this, const CPed *pEnteringPed)
{
  eCarLockState m_eDoorLockState; // r0
  _BOOL4 IsPlayer; // r0
  bool v6; // zf

  m_eDoorLockState = this->m_eDoorLockState;
  if ( (unsigned int)m_eDoorLockState <= CARLOCK_LOCKED_BUT_CAN_BE_DAMAGED && ((1 << m_eDoorLockState) & 0xB4) != 0 )
    return 0;
  IsPlayer = CPed::IsPlayer(pEnteringPed);
  v6 = IsPlayer;
  if ( IsPlayer )
    v6 = this->m_eDoorLockState == CARLOCK_LOCKOUT_PLAYER_ONLY;
  return !v6;
}

//----- (00584E1C) --------------------------------------------------------
Bool8 __fastcall CVehicle::CanDoorsBeDamaged(const CVehicle *this)
{
  eCarLockState m_eDoorLockState; // r1

  m_eDoorLockState = this->m_eDoorLockState;
  return (unsigned int)m_eDoorLockState <= CARLOCK_LOCKED_BUT_CAN_BE_DAMAGED && ((1 << m_eDoorLockState) & 0x83) != 0;
}

//----- (00584E38) --------------------------------------------------------
bool __fastcall CVehicle::CanPedEnterCar(const CVehicle *this)
{
  float zz; // s0
  bool v3; // r1

  zz = this->m_pMat->zz;
  if ( zz >= -0.1 && zz <= 0.1 && this->m_baseVehicleType != 9 )
    return 0;
  v3 = 0;
  if ( (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                     + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
             + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) <= 0.04
    && (float)((float)((float)(this->m_vecTurnSpeed.x * this->m_vecTurnSpeed.x)
                     + (float)(this->m_vecTurnSpeed.y * this->m_vecTurnSpeed.y))
             + (float)(this->m_vecTurnSpeed.z * this->m_vecTurnSpeed.z)) <= 0.04 )
  {
    return 1;
  }
  return v3;
}

//----- (00584ED4) --------------------------------------------------------
bool __fastcall CVehicle::CanPedStepOutCar(const CVehicle *this, bool bIgnoreSpeedCheck)
{
  float zz; // s0

  zz = this->m_pMat->zz;
  if ( zz <= 0.1 && zz >= -0.1 )
    return fabsf(this->m_vecMoveSpeed.z) <= 0.05
        && sqrtf(
             (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
           + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) <= 0.01
        && (float)((float)((float)(this->m_vecTurnSpeed.x * this->m_vecTurnSpeed.x)
                         + (float)(this->m_vecTurnSpeed.y * this->m_vecTurnSpeed.y))
                 + (float)(this->m_vecTurnSpeed.z * this->m_vecTurnSpeed.z)) <= 0.0004;
  if ( this->m_baseVehicleType != 5 )
    return (bIgnoreSpeedCheck
         || sqrtf(
              (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
            + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) <= 0.01
         && fabsf(this->m_vecMoveSpeed.z) <= 0.05)
        && (float)((float)((float)(this->m_vecTurnSpeed.x * this->m_vecTurnSpeed.x)
                         + (float)(this->m_vecTurnSpeed.y * this->m_vecTurnSpeed.y))
                 + (float)(this->m_vecTurnSpeed.z * this->m_vecTurnSpeed.z)) <= 0.0004;
  return 1;
}

//----- (00585000) --------------------------------------------------------
bool __fastcall CVehicle::CanPedJumpOutCar(const CVehicle *this, CPed *pPed)
{
  float32x2_t v2; // d3
  float32x2_t v3; // d5
  int32 m_baseVehicleType; // r0
  CPed *v6; // r0
  bool v7; // zf
  float32x4_t v8; // q0
  float v9; // s4
  RwReal v10; // s10
  RwReal v11; // s12
  float x; // s0
  float y; // s4
  float z; // s2
  float v15; // s4
  float v16; // s0
  float v17; // s2
  float32x4_t v19; // q8
  RwReal v20; // s4
  float v21; // s6

  m_baseVehicleType = this->m_baseVehicleType;
  if ( m_baseVehicleType != 9 )
  {
    v8.n128_u64[0] = *(_QWORD *)&this->m_vecMoveSpeed.x;
    v9 = (float)(v8.n128_f32[0] * v8.n128_f32[0]) + (float)(v8.n128_f32[1] * v8.n128_f32[1]);
    if ( (unsigned int)(this->m_vehicleType - 3) >= 2
      && (m_baseVehicleType
       || this->m_pMat->zz >= 0.3
       || this->m_LastCollisionTime <= CTimer::m_snTimeInMilliseconds - 1000) )
    {
      if ( v9 < 0.1 || v9 > 0.5 )
        goto LABEL_19;
    }
    else if ( v9 < 0.1 )
    {
      if ( !(*((int (__fastcall **)(const CVehicle *, _DWORD))this->_vptr$CPlaceable + 58))(this, 0) )
      {
        v10 = this->m_vecTurnSpeed.y * 0.9;
        v11 = this->m_vecTurnSpeed.z * 0.9;
        x = this->m_vecMoveSpeed.x;
        y = this->m_vecMoveSpeed.y;
        z = this->m_vecMoveSpeed.z;
        this->m_vecTurnSpeed.x = this->m_vecTurnSpeed.x * 0.9;
        this->m_vecTurnSpeed.y = v10;
        this->m_vecTurnSpeed.z = v11;
        v3.n64_f32[0] = (float)((float)(x * x) + (float)(y * y)) + (float)(z * z);
        if ( (float)(v3.n64_f32[0] * 0.01) <= (float)(CTimer::ms_fTimeStep
                                                    * (float)((float)(CTimer::ms_fTimeStep * 0.008) * 0.008)) )
        {
          v2.n64_f32[0] = sqrtf(v3.n64_f32[0]);
          v3.n64_u32[0] = 0;
          v2.n64_f32[0] = (float)((float)(CTimer::ms_fTimeStep * -0.016) / v2.n64_f32[0]) + 1.0;
          v21 = vmax_f32(v2, v3).n64_f32[0];
          v15 = v21 * y;
          v16 = x * v21;
          v17 = v21 * z;
        }
        else
        {
          v15 = y * 0.9;
          v16 = x * 0.9;
          v17 = z * 0.9;
        }
        this->m_vecMoveSpeed.x = v16;
        this->m_vecMoveSpeed.y = v15;
        this->m_vecMoveSpeed.z = v17;
      }
      return 0;
    }
    return 1;
  }
  v6 = this->pPassengers[0];
  v7 = v6 == 0;
  if ( v6 )
    v7 = v6 == pPed;
  if ( !v7 )
    return 0;
  v8.n128_u64[0] = *(_QWORD *)&this->m_vecMoveSpeed.x;
  if ( (float)((float)(v8.n128_f32[0] * v8.n128_f32[0]) + (float)(v8.n128_f32[1] * v8.n128_f32[1])) >= 0.07 )
    return 1;
LABEL_19:
  v8.n128_u64[1] = *(_QWORD *)&this->m_vecMoveSpeed.z;
  v19.n128_u64[0] = 0x3F6666663F666666LL;
  v19.n128_u64[1] = 0x3F6666663F666666LL;
  v20 = this->m_vecTurnSpeed.z * 0.9;
  this->m_vecTurnSpeed.y = this->m_vecTurnSpeed.y * 0.9;
  this->m_vecTurnSpeed.z = v20;
  *(float32x4_t *)&this->m_vecMoveSpeed.x = vmulq_f32(v8, v19);
  return 0;
}
// 5851A2: variable 'v2' is possibly undefined
// 5851A2: variable 'v3' is possibly undefined

//----- (00585208) --------------------------------------------------------
void __fastcall CVehicle::ProcessCarAlarm(CVehicle *this)
{
  unsigned int CarAlarmState; // r1
  bool v2; // zf
  unsigned int v3; // r2
  UInt16 v4; // r1

  CarAlarmState = this->CarAlarmState;
  v2 = CarAlarmState == 0;
  if ( this->CarAlarmState )
    v2 = CarAlarmState == 0xFFFF;
  if ( !v2 )
  {
    v3 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    if ( CarAlarmState < v3 )
    {
      v4 = 0;
      this->m_cHorn = 0;
    }
    else
    {
      v4 = CarAlarmState - v3;
    }
    this->CarAlarmState = v4;
  }
}

//----- (0058525C) --------------------------------------------------------
int __fastcall CVehicle::IsSphereTouchingVehicle(
        CVehicle *this,
        float CenterX,
        float CenterY,
        float CenterZ,
        float Radius)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  float z; // s20
  float v11; // s18
  float v12; // s16
  CColModel *ColModel; // r0
  CMatrix *v14; // r1
  float v15; // s2
  float v16; // s4
  float v17; // s4
  int v18; // r1
  float v20; // s4
  float zz; // s8
  float v22; // s6
  float v23; // s2

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  z = p_tx->m_translate.z;
  v11 = CenterX - p_tx->m_translate.x;
  v12 = CenterY - p_tx->m_translate.y;
  ColModel = CEntity::GetColModel(this);
  v14 = this->m_pMat;
  v15 = CenterZ - z;
  v16 = (float)((float)(v11 * v14->xx) + (float)(v12 * v14->yx)) + (float)((float)(CenterZ - z) * v14->zx);
  if ( v16 < (float)(ColModel->m_boxBound.m_vecMin.x - Radius) )
    return 0;
  if ( v16 > (float)(ColModel->m_boxBound.m_vecMax.x + Radius) )
    return 0;
  v17 = (float)((float)(v11 * v14->xy) + (float)(v12 * v14->yy)) + (float)(v15 * v14->zy);
  if ( v17 < (float)(ColModel->m_boxBound.m_vecMin.y - Radius)
    || v17 > (float)(ColModel->m_boxBound.m_vecMax.y + Radius) )
  {
    return 0;
  }
  v20 = v11 * v14->xz;
  zz = v14->zz;
  v22 = v12 * v14->yz;
  v18 = 0;
  v23 = (float)(v20 + v22) + (float)(v15 * zz);
  if ( v23 >= (float)(ColModel->m_boxBound.m_vecMin.z - Radius)
    && v23 <= (float)(ColModel->m_boxBound.m_vecMax.z + Radius) )
  {
    return 1;
  }
  return v18;
}

//----- (00585380) --------------------------------------------------------
void __fastcall DestroyVehicleAndDriverAndPassengers(CVehicle *pVehicle)
{
  uint8 m_nMaxPassengers; // r0
  CPed **pPassengers; // r5
  int v4; // r6

  if ( pVehicle->pDriver )
  {
    if ( !CGameLogic::IsCoopGameGoingOn() )
      CDarkel::RegisterKillByPlayer(pVehicle->pDriver, WEAPONTYPE_UNIDENTIFIED, 0, 0);
    (*((void (__fastcall **)(CPed *))pVehicle->pDriver->_vptr$CPlaceable + 22))(pVehicle->pDriver);
  }
  m_nMaxPassengers = pVehicle->m_nMaxPassengers;
  if ( m_nMaxPassengers )
  {
    pPassengers = pVehicle->pPassengers;
    v4 = 0;
    do
    {
      if ( pPassengers[v4] )
      {
        if ( !CGameLogic::IsCoopGameGoingOn() )
          CDarkel::RegisterKillByPlayer(pPassengers[v4], WEAPONTYPE_UNIDENTIFIED, 0, 0);
        (*((void (__fastcall **)(CPed *))pPassengers[v4]->_vptr$CPlaceable + 22))(pPassengers[v4]);
        m_nMaxPassengers = pVehicle->m_nMaxPassengers;
      }
      ++v4;
    }
    while ( v4 < m_nMaxPassengers );
  }
  CWorld::Remove(pVehicle);
  (*((void (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 1))(pVehicle);
}

//----- (00585400) --------------------------------------------------------
bool __fastcall IsVehiclePointerValid(CVehicle *pVeh)
{
  int v1; // r2
  int32 v2; // r2

  v1 = (char *)pVeh - (char *)CPools::ms_pVehiclePool->m_aStorage;
  if ( v1 < 0 )
    return 0;
  v2 = -1075391197 * (v1 >> 2);
  if ( v2 >= CPools::ms_pVehiclePool->m_nSize || (CPools::ms_pVehiclePool->m_aFlags[v2] & 0x80u) != 0 )
    return 0;
  if ( pVeh->m_baseVehicleType == 8 )
    return 1;
  return pVeh->m_listEntryInfo.m_pHead != 0;
}

//----- (0058544C) --------------------------------------------------------
bool __fastcall IsVehiclePointerValid_NotInWorld(CVehicle *pVeh)
{
  int v1; // r0
  bool result; // r0
  int32 v3; // r2

  v1 = (char *)pVeh - (char *)CPools::ms_pVehiclePool->m_aStorage;
  if ( v1 < 0 )
    return 0;
  v3 = -1075391197 * (v1 >> 2);
  result = 0;
  if ( v3 < CPools::ms_pVehiclePool->m_nSize && (char)CPools::ms_pVehiclePool->m_aFlags[v3] > -1 )
    return 1;
  return result;
}

//----- (00585488) --------------------------------------------------------
bool __fastcall CVehicle::IsVehicleNormal(const CVehicle *this)
{
  return this->pDriver
      && !this->m_nNumPassengers
      && (*(_BYTE *)&this->m_info & 0xF8) != 40
      && BYTE1(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][1].m_pColModel) != 255;
}

//----- (005854C4) --------------------------------------------------------
void __fastcall CVehicle::ChangeLawEnforcerState(CVehicle *this, Bool8 NewState)
{
  int m_nVehicleFlags; // r3
  int v3; // r12
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r0
  int v5; // r0

  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  v3 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  if ( NewState )
  {
    if ( (m_nVehicleFlags & 1) != 0 )
      return;
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags | 1;
    *((_DWORD *)p_m_nVehicleFlags + 1) = v3;
    v5 = CCarCtrl::NumLawEnforcerCars + 1;
  }
  else
  {
    if ( (m_nVehicleFlags & 1) == 0 )
      return;
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFFE;
    *((_DWORD *)p_m_nVehicleFlags + 1) = v3;
    v5 = CCarCtrl::NumLawEnforcerCars - 1;
  }
  CCarCtrl::NumLawEnforcerCars = v5;
}

//----- (00585514) --------------------------------------------------------
bool __fastcall CVehicle::ShufflePassengersToMakeSpace(CVehicle *this)
{
  return 1;
}

//----- (00585518) --------------------------------------------------------
void __fastcall CVehicle::ExtinguishCarFire(CVehicle *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  CFire *m_pFire; // r0

  if ( (*(_BYTE *)&this->m_info & 0xF8) != 40 )
  {
    v1.n64_u32[0] = 1133903872;
    v2.n64_u32[0] = LODWORD(this->m_nHealth);
    LODWORD(this->m_nHealth) = vmax_f32(v2, v1).n64_u32[0];
  }
  m_pFire = this->m_pFire;
  if ( m_pFire )
  {
    *(_BYTE *)m_pFire &= ~2u;
    CFire::Extinguish(this->m_pFire);
    this->m_pFire = 0;
  }
  if ( !this->m_baseVehicleType )
  {
    if ( CDamageManager::GetEngineStatus((const CDamageManager *)&this[1]) >= 0xE1 )
      CDamageManager::SetEngineStatus((CDamageManager *)&this[1], 0xD7u);
    this[1].m_VehicleAudioEntity.m_SkidSound.m_pAudioEntity = 0;
  }
}
// 585536: variable 'v2' is possibly undefined
// 585536: variable 'v1' is possibly undefined

//----- (00585588) --------------------------------------------------------
void __fastcall CVehicle::ActivateBomb(CVehicle *this)
{
  char v2; // r0

  v2 = *((_BYTE *)this + 1202);
  if ( (v2 & 7) == 2 )
  {
    *((_BYTE *)this + 1202) = v2 & 0xF8 | 5;
  }
  else
  {
    if ( (v2 & 7) != 1 )
      return;
    this->DelayedExplosion = 7000;
    *((_BYTE *)this + 1202) = v2 & 0xF8 | 4;
    this->pDelayedExplosionInflictor = FindPlayerPed(-1);
  }
  sub_19BFB0("GA_12", -1, 0xBB8u, -1);
}

//----- (005855EC) --------------------------------------------------------
void __fastcall CVehicle::ActivateBombWhenEntered(CVehicle *this)
{
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r4
  int m_nVehicleFlags; // r1
  int v3; // r3
  CEntity *pBombOwner; // r2

  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  v3 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  if ( this->pDriver )
  {
    if ( (v3 & 0x20) == 0 && (*((_BYTE *)this + 1202) & 7) == 5 )
    {
      this->DelayedExplosion = 1000;
      pBombOwner = this->pBombOwner;
      this->pDelayedExplosionInflictor = pBombOwner;
      if ( pBombOwner )
      {
        CEntity::RegisterReference(pBombOwner, &this->pDelayedExplosionInflictor);
        v3 = *((_DWORD *)p_m_nVehicleFlags + 1);
        m_nVehicleFlags = *(_DWORD *)p_m_nVehicleFlags;
      }
    }
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
    *((_DWORD *)p_m_nVehicleFlags + 1) = v3 | 0x20;
  }
  else
  {
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v3 & 0xFFFFFFDF;
  }
}

//----- (00585646) --------------------------------------------------------
bool8 __fastcall CVehicle::CarHasRoof(const CVehicle *this)
{
  return (this->pHandling->mFlags & 0x800) == 0 || !this->m_comp1 || this->m_comp2 == 0;
}

//----- (0058566C) --------------------------------------------------------
float __fastcall CVehicle::HeightAboveCeiling(CVehicle *this, float Height, eFlightModel nType)
{
  float v3; // s2
  float v4; // s2

  if ( (unsigned int)(nType - 1) > 1 )
  {
    if ( Height < 800.0 )
      return -1.0;
    v4 = -800.0;
    return Height + v4;
  }
  v3 = -1.0;
  if ( Height < 500.0 )
    return v3;
  if ( Height < 950.0 )
  {
    v4 = -500.0;
    return Height + v4;
  }
  if ( Height < 1500.0 )
    return v3;
  return (float)(Height + -1000.0) + 500.0;
}

//----- (00585700) --------------------------------------------------------
void __fastcall CVehicle::FlyingControl(
        CVehicle *this,
        eFlightModel nType,
        float fYawControl,
        float fPitchControl,
        float fRollControl,
        float fThrottleControl)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d1
  float32x2_t v8; // d2
  CPed *pDriver; // r0
  CPad *PadFromPlayer; // r9
  float v15; // s16
  float32x2_t v16; // d9
  float v17; // s20
  float fWindMult; // s0
  float x; // s28
  float y; // s30
  float32x2_t v21; // d15
  float32x2_t v22; // d14
  float v23; // s17
  float v24; // s20
  float LookLeft; // s22
  float32x2_t v26; // d13
  float v27; // s24
  tFlyingHandlingData *pFlyingHandling; // r4
  float v29; // r0
  RwReal v30; // s2
  CMatrix *v31; // r6
  RwReal v32; // s4
  float v33; // s18
  int Accelerate; // r5
  int Brake; // r0
  CMatrix *m_pMat; // r0
  float yx; // s6
  float zx; // s8
  float xy; // s10
  float zy; // s1
  float v41; // s0
  float v42; // s26
  float v43; // s16
  float yy; // s4
  float v45; // s12
  float v46; // s24
  float v47; // s0
  RwReal v48; // s28
  CMatrix *v49; // r0
  float v50; // s0
  RwReal v51; // s2
  unsigned int v52; // s4
  unsigned int v53; // s0
  CMatrix *v54; // r0
  CMatrix *v55; // r0
  float xz; // s0
  float v57; // s16
  float SteeringUpDown; // s0
  float v59; // s2
  float v60; // s19
  float v61; // r5
  float v62; // r4
  float v63; // r0
  float v64; // s0
  float v65; // r0
  float v66; // s0
  float v67; // s2
  float v68; // r0
  float v69; // r5
  float v70; // s18
  float v71; // s0
  float v72; // s23
  int v73; // r5
  int v74; // r6
  float v75; // s19
  float v76; // s2
  float m_fMass; // s2
  double v78; // d16
  float v79; // s0
  CMatrix *v80; // r0
  CSimpleTransform *p_tx; // r1
  float z; // s2
  bool v83; // cc
  CMatrix *v84; // r0
  float v85; // s22
  float v86; // s24
  float v87; // s16
  float yz; // s18
  float zz; // s20
  RwReal v90; // s2
  unsigned int v91; // s4
  unsigned int v92; // s0
  float v93; // s26
  float v94; // s0
  CMatrix *v95; // r0
  float v96; // s6
  CMatrix *v97; // r1
  RwReal v98; // s4
  RwReal v99; // s0
  float v100; // s17
  float v101; // s28
  float v102; // s30
  float v103; // s0
  float v104; // s21
  float v105; // s16
  float v106; // r0
  float v107; // s4
  float v108; // s0
  float fThrust; // s16
  CMatrix *v110; // r0
  CSimpleTransform *p_m_transform; // r1
  float v112; // s0
  float v113; // s2
  float v114; // s4
  float v115; // s4
  float v116; // s4
  float v117; // s4
  CMatrix *v118; // r0
  float v119; // s25
  float v120; // s21
  float v121; // s23
  float v122; // s27
  float v123; // s2
  int v124; // r5
  int m_nModelIndex; // r1
  int v126; // r0
  float v127; // s20
  tFlyingHandlingData *v128; // r2
  float v129; // s0
  float fThrustFallOff; // s2
  float v131; // s2
  float v132; // s2
  float v133; // s23
  float v134; // s21
  float32x2_t v135; // d8
  float v136; // s0
  RwReal v137; // r6
  CMatrix *v138; // r8
  float v139; // r9
  float v140; // s18
  float v141; // s27
  float v142; // r6
  float v143; // r5
  float v144; // r0
  float v145; // r0
  float v146; // s25
  float v147; // s6
  CMatrix *v148; // r0
  float v149; // s2
  float v150; // s4
  float v151; // s6
  float v152; // s0
  float v153; // s2
  float v154; // s4
  float v155; // s6
  CMatrix *v156; // r0
  float xx; // s18
  float v158; // s24
  float v159; // s2
  float v160; // s0
  float v161; // s30
  float v162; // s0
  CMatrix *v163; // r0
  float v164; // s0
  CMatrix *v165; // r0
  float v166; // r2
  float v167; // r3
  CMatrix *v168; // r0
  float v169; // r1
  float v170; // s0
  float v171; // s2
  float v172; // s8
  float32x2_t v173; // d0
  CMatrix *v174; // r0
  float v175; // s18
  float v176; // s22
  float v177; // s0
  float v178; // s0
  CMatrix *v179; // r4
  float32x2_t v180; // d0
  float v181; // s0
  int32 m_vehicleType; // r1
  float v183; // s2
  tFlyingHandlingData *v184; // r0
  float v185; // s4
  float v186; // s4
  float v187; // s0
  float v188; // s6
  CSimpleTransform *v189; // r0
  float v190; // s4
  unsigned int v191; // r0
  float v192; // s8
  float v193; // s8
  float v194; // s6
  float v195; // s0
  float v196; // s4
  float v197; // s6
  float v198; // s2
  float v199; // s0
  float v200; // s4
  float v201; // s8
  float v202; // s8
  float v203; // s6
  float v204; // s2
  float v205; // s4
  CMatrix *v206; // r0
  float v207; // s0
  float v208; // s0
  CMatrix *v209; // r0
  float v210; // s8
  float v211; // s10
  tFlyingHandlingData *v212; // r1
  float v213; // s2
  float v214; // s1
  float v215; // s0
  float v216; // s4
  bool v217; // fnf
  float v218; // s0
  CMatrix *v219; // r0
  float v220; // s6
  float v221; // s8
  float v222; // s10
  tFlyingHandlingData *v223; // r1
  float v224; // s2
  float v225; // s1
  float v226; // s0
  float v227; // s4
  bool v228; // fnf
  float v229; // s0
  RwReal v230; // s12
  RwReal v231; // s2
  float v232; // s0
  float v233; // s12
  tFlyingHandlingData *v234; // r1
  float fFormLiftMult; // s6
  float v236; // s2
  tFlyingHandlingData *v237; // r0
  float v238; // s0
  float fAttackLiftMult; // s2
  CMatrix *v240; // r0
  float v241; // s4
  float v242; // s0
  RwReal v243; // s2
  RwReal v244; // s4
  _BOOL4 LookRight; // r5
  int SteeringLeftRight; // r0
  _BOOL4 v247; // r5
  float CarGunLeftRight; // s0
  float v249; // s2
  float v250; // s0
  tFlyingHandlingData *v251; // r0
  float fPitchMult; // s16
  float v253; // s18
  float v254; // r0
  float v255; // s0
  CMatrix *v256; // r0
  float m_fTurnMass; // s12
  CMatrix *v258; // r0
  float fRollMult; // s12
  float v260; // s6
  float v261; // s8
  float v262; // s10
  float v263; // s12
  CMatrix *v264; // r0
  float v265; // s2
  float v266; // s4
  float v267; // s16
  float v268; // s18
  float v269; // s6
  float v270; // s0
  float v271; // s2
  float v272; // s4
  float v273; // s6
  tFlyingHandlingData *v274; // r0
  float fYawMult; // s0
  float v276; // s2
  CMatrix *v277; // r0
  float v278; // s0
  CMatrix *v279; // r0
  float v280; // s12
  float v281; // s6
  float v282; // s8
  float v283; // s10
  float v284; // s12
  float v285; // r5
  float v286; // r6
  float v287; // r9
  float v288; // r4
  float v289; // r5
  float v290; // r6
  float v291; // r9
  float v292; // s0
  float v293; // s16
  bool v294; // zf
  tFlyingHandlingData *v295; // r4
  float v296; // s2
  float v297; // s18
  float v298; // s18
  float v299; // r0
  float v300; // s2
  float v301; // s20
  float v302; // s22
  float v303; // r0
  float v304; // s2
  float v305; // s20
  float v306; // s20
  float v307; // r0
  float v308; // s0
  __int64 v309; // d16
  float v310; // s18
  CMatrix *v311; // r0
  float v312; // s6
  float v313; // s16
  CMatrix *v314; // r0
  float v315; // s12
  CMatrix *v316; // r0
  float v317; // s8
  float v318; // s0
  float v319; // s4
  float v320; // s2
  float v321; // s6
  float v322; // s6
  float v323; // s0
  float v324; // s4
  float v325; // s2
  float v326; // s6
  float v327; // s6
  CVector bPoop; // [sp+0h] [bp-A0h]
  CVector bPoopa; // [sp+0h] [bp-A0h]
  CVector bPoopb; // [sp+0h] [bp-A0h]
  CVector bPoopc; // [sp+0h] [bp-A0h]
  CVector bPoopd; // [sp+0h] [bp-A0h]
  CVector bPoope; // [sp+0h] [bp-A0h]
  CVector bPoopf; // [sp+0h] [bp-A0h]
  CVector bPoopg; // [sp+0h] [bp-A0h]
  CVector bPooph; // [sp+0h] [bp-A0h]
  CVector bPoopi; // [sp+0h] [bp-A0h]
  CVector bPoopj; // [sp+0h] [bp-A0h]
  CVector bPoopk; // [sp+0h] [bp-A0h]
  CVector bPoopl; // [sp+0h] [bp-A0h]
  CVector bPoopm; // [sp+0h] [bp-A0h]
  CVector bPoopn; // [sp+0h] [bp-A0h]
  CVector bPoopo; // [sp+0h] [bp-A0h]
  CVector bPoopp; // [sp+0h] [bp-A0h]
  CVector bPoopq; // [sp+0h] [bp-A0h]
  eFlightModel v346; // [sp+Ch] [bp-94h]
  float v347; // [sp+14h] [bp-8Ch]
  CVector v2; // [sp+18h] [bp-88h] BYREF
  CVector v; // [sp+28h] [bp-78h] BYREF
  CVector v350; // [sp+34h] [bp-6Ch] BYREF
  CVector v351; // 0:r1.12
  CVector v352; // 0:r1.12
  CVector v353; // 0:r1.12
  CVector v354; // 0:r1.12
  CVector v355; // 0:r1.12
  CVector v356; // 0:r1.12
  CVector v357; // 0:r1.12
  CVector v358; // 0:r1.12
  CVector v359; // 0:r1.12
  CVector v360; // 0:r1.12
  CVector v361; // 0:r1.12
  CVector v362; // 0:r1.12
  CVector v363; // 0:r1.12
  CVector v364; // 0:r1.12
  CVector v365; // 0:r1.12
  CVector v366; // 0:r1.12
  CVector v367; // 0:r1.12
  CVector v368; // 0:r1.12
  CVector v369; // 0:r1.12
  CVector v370; // 0:r1.12
  CVector v371; // 0:r1.12
  CVector v372; // 0:r1.12
  CVector v373; // 0:r1.12
  CVector v374; // 0:r1.12
  CVector v375; // 0:r1.12
  CVector v376; // 0:r1.12
  CVector v377; // 0:r1.12
  CVector v378; // 0:r1.12
  CVector v379; // 0:r2.8,8:^0.4
  CVector v380; // 0:r2.8,8:^0.4

  if ( !this->pFlyingHandling || CTimer::ms_fTimeStep <= 0.0 )
    return;
  if ( *(_BYTE *)&this->m_info <= 7u && (pDriver = this->pDriver) != 0 && CPed::IsPlayer(pDriver) )
    PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
  else
    PadFromPlayer = 0;
  if ( this->VehicleCreatedBy == 2 )
  {
    v15 = 0.0;
    v16.n64_u32[0] = 0;
    v17 = 0.0;
  }
  else
  {
    fWindMult = this->pFlyingHandling->fWindMult;
    v16.n64_f32[0] = 0.0 - (float)(fWindMult * CWeather::WindDir.y);
    v17 = 0.0 - (float)(fWindMult * CWeather::WindDir.z);
    v15 = 0.0 - (float)(fWindMult * CWeather::WindDir.x);
  }
  x = this->m_vecMoveSpeed.x;
  y = this->m_vecMoveSpeed.y;
  v16.n64_u32[1] = LODWORD(this->m_vecMoveSpeed.z);
  Multiply3x3(&v350, this->m_pMat, &this->m_vecCOM);
  if ( (unsigned int)nType <= FLIGHTMODEL_AUTOGYRO )
  {
    v21.n64_f32[1] = v17 + v16.n64_f32[1];
    v22.n64_f32[1] = v16.n64_f32[0] + y;
    v23 = fThrottleControl;
    v24 = v15 + x;
    LookLeft = fRollControl;
    v26.n64_f32[0] = fPitchControl;
    v27 = fYawControl;
    if ( ((1 << nType) & 0x3A) == 0 )
    {
      if ( ((1 << nType) & 0x144) == 0 )
      {
        if ( nType == FLIGHTMODEL_DODO )
        {
          m_pMat = this->m_pMat;
          yx = m_pMat->yx;
          zx = m_pMat->zx;
          xy = m_pMat->xy;
          zy = m_pMat->zy;
          v41 = (float)((float)(v24 * v24) + (float)(v22.n64_f32[1] * v22.n64_f32[1]))
              + (float)(v21.n64_f32[1] * v21.n64_f32[1]);
          v42 = sqrtf(v41);
          v43 = (float)-(float)((float)((float)(v24 * m_pMat->xx) + (float)(v22.n64_f32[1] * yx))
                              + (float)(v21.n64_f32[1] * zx))
              / v42;
          yy = m_pMat->yy;
          v45 = (float)((float)(v24 * xy) + (float)(v22.n64_f32[1] * yy)) + (float)(v21.n64_f32[1] * zy);
          v46 = v45 * (float)(v41 * v45);
          v47 = (v43 * 0.003 + this->m_fSteerAngle * 0.001) * v46 * this->m_fTurnMass * CTimer::ms_fTimeStep;
          v351.x = m_pMat->xx * v47;
          v351.y = yx * v47;
          v351.z = zx * v47;
          v22.n64_f32[0] = yy * -4.0;
          bPoop.x = xy * -4.0;
          bPoop.y = yy * -4.0;
          bPoop.z = zy * -4.0;
          CPhysical::ApplyTurnForce(this, v351, bPoop);
          v49 = this->m_pMat;
          v50 = (float)((float)((float)(v43 * 0.2) * v46) * this->m_fMass) * CTimer::ms_fTimeStep;
          v51 = v49->xx * v50;
          *(float *)&v52 = v49->yx * v50;
          *(float *)&v53 = v49->zx * v50;
          v352.x = v51;
          *(_QWORD *)&v352.y = __PAIR64__(v53, v52);
          CPhysical::ApplyMoveForce(this, v352);
          v54 = this->m_pMat;
          v353.x = v51;
          *(_QWORD *)&v353.y = __PAIR64__(v53, v52);
          bPoopa.x = v54->xz + v54->xz;
          bPoopa.y = v54->yz + v54->yz;
          bPoopa.z = v54->zz + v54->zz;
          CPhysical::ApplyTurnForce(this, v353, bPoopa);
          v55 = this->m_pMat;
          xz = v55->xz;
          v57 = (float)-(float)((float)((float)(v24 * xz) + (float)(v22.n64_f32[1] * v55->yz))
                              + (float)(v21.n64_f32[1] * v55->zz))
              / v42;
          if ( PadFromPlayer )
          {
            SteeringUpDown = (float)CPad::GetSteeringUpDown(PadFromPlayer);
            v55 = this->m_pMat;
            v59 = (float)(SteeringUpDown * -0.0078125) * 0.001;
            xz = v55->xz;
          }
          else
          {
            v59 = 0.0;
          }
          v76 = (float)((float)(v46 * (float)((float)(v57 * 0.002) + v59)) * this->m_fTurnMass) * CTimer::ms_fTimeStep;
          bPoopb.x = xy * -4.0;
          bPoopb.y = v48;
          bPoopb.z = zy * -4.0;
          v354.x = xz * v76;
          v354.y = v55->yz * v76;
          v354.z = v55->zz * v76;
          CPhysical::ApplyTurnForce(this, v354, bPoopb);
          m_fMass = this->m_fMass;
          v78 = m_fMass;
          v79 = (v57 * 3.5 + 0.5) * 0.05 * v46 * m_fMass * CTimer::ms_fTimeStep;
          if ( ((*(_BYTE *)&this->m_info >> 3) | 8) == 8
            && (float)((float)(CTimer::ms_fTimeStep * 0.008) * m_fMass) < v79 )
          {
            v80 = this->m_pMat;
            p_tx = (CSimpleTransform *)&v80->tx;
            if ( !v80 )
              p_tx = &this->m_transform;
            z = p_tx->m_translate.z;
            v83 = z <= 800.0;
            if ( z >= 800.0 )
              v83 = (float)(z + -800.0) <= 0.0;
            if ( !v83 )
              v79 = CTimer::ms_fTimeStep * 0.00720000034 * v78;
          }
          v84 = this->m_pMat;
          v85 = v350.x;
          v86 = v350.y;
          v87 = v84->xz;
          yz = v84->yz;
          zz = v84->zz;
          v90 = v79 * v87;
          *(float *)&v91 = v79 * yz;
          *(float *)&v92 = v79 * zz;
          v93 = v350.z;
          v355.x = v90;
          *(_QWORD *)&v355.y = __PAIR64__(v92, v91);
          CPhysical::ApplyMoveForce(this, v355);
          v356.x = v90;
          *(_QWORD *)&v356.y = __PAIR64__(v92, v91);
          bPoopc.x = (float)(v87 + v87) + v85;
          bPoopc.y = (float)(yz + yz) + v86;
          bPoopc.z = (float)(zz + zz) + v93;
          CPhysical::ApplyTurnForce(this, v356, bPoopc);
          this->m_vecTurnSpeed.y = powf(0.9, CTimer::ms_fTimeStep) * this->m_vecTurnSpeed.y;
        }
        goto LABEL_252;
      }
      pFlyingHandling = this->pFlyingHandling;
      v29 = powf(pFlyingHandling->fMoveRes, CTimer::ms_fTimeStep);
      v30 = v29 * this->m_vecMoveSpeed.y;
      v31 = this->m_pMat;
      v32 = v29 * this->m_vecMoveSpeed.z;
      this->m_vecMoveSpeed.x = v29 * this->m_vecMoveSpeed.x;
      this->m_vecMoveSpeed.y = v30;
      this->m_vecMoveSpeed.z = v32;
      if ( nType == FLIGHTMODEL_AUTOGYRO )
      {
        v33 = (float)((float)(v24 * v31->xy) + (float)(v22.n64_f32[1] * v31->yy)) + (float)(v21.n64_f32[1] * v31->zy);
        if ( fThrottleControl == -10000.0 )
        {
          if ( PadFromPlayer )
          {
            Accelerate = CPad::GetAccelerate(PadFromPlayer);
            Brake = CPad::GetBrake(PadFromPlayer);
            pFlyingHandling = this->pFlyingHandling;
            v23 = (float)(Accelerate - Brake) / 255.0;
          }
          else
          {
            v23 = 0.0;
          }
        }
        v7.n64_u32[0] = LODWORD(pFlyingHandling->fThrustFallOff);
        if ( v33 > 0.0 )
        {
          v7.n64_f32[0] = v23 - (float)(v33 * v7.n64_f32[0]);
        }
        else
        {
          v8.n64_u32[0] = 0;
          v7.n64_f32[0] = v23 + (float)(v33 * (float)(v7.n64_f32[0] * -8.0));
          v7.n64_u64[0] = vmin_f32(v7, v8).n64_u64[0];
        }
        v94 = pFlyingHandling->fThrust * v7.n64_f32[0];
        v95 = this->m_pMat;
        v96 = this->m_fMass;
        v357.x = (float)((float)(v94 * v95->xy) * v96) * CTimer::ms_fTimeStep;
        v357.y = (float)((float)(v94 * v95->yy) * v96) * CTimer::ms_fTimeStep;
        v357.z = (float)((float)(v94 * v95->zy) * v96) * CTimer::ms_fTimeStep;
        CPhysical::ApplyMoveForce(this, v357);
        v97 = this->m_pMat;
        v98 = v97->yz - (float)(AUTOGYRO_ROTORTILT_ANGLE * v97->yy);
        v99 = v97->zz - (float)(AUTOGYRO_ROTORTILT_ANGLE * v97->zy);
        v.x = v97->xz - (float)(AUTOGYRO_ROTORTILT_ANGLE * v97->xy);
        v.y = v98;
        v.z = v99;
        CVector::Normalise(&v);
        v100 = v.x;
        v22.n64_u32[0] = LODWORD(v.y);
        v21.n64_u32[0] = LODWORD(v.z);
        v16.n64_f32[0] = (float)((float)(v24 * v.x) + (float)(v22.n64_f32[1] * v.y)) + (float)(v21.n64_f32[1] * v.z);
        if ( this->m_baseVehicleType )
        {
          v103 = 0.22;
          v104 = CTimer::ms_fTimeStep;
        }
        else
        {
          v7.n64_u32[0] = 0;
          v104 = CTimer::ms_fTimeStep;
          v6.n64_f32[0] = -AUTOGYRO_ROTORSPIN_MULTLIMIT;
          v16.n64_f32[0] = vmin_f32(vmax_f32(v16, v6), v7).n64_f32[0];
          v105 = *(float *)&this[1].m_VehicleAudioEntity.m_ReverseSoundPtr
               - (float)(CTimer::ms_fTimeStep * (float)(AUTOGYRO_ROTORSPIN_MULT * v16.n64_f32[0]));
          v106 = powf(AUTOGYRO_ROTORSPIN_DAMP, CTimer::ms_fTimeStep);
          v103 = 0.4;
          *(float *)&this[1].m_VehicleAudioEntity.m_ReverseSoundPtr = v105 * v106;
          if ( (float)(v105 * v106) <= 0.4 && (v103 = 0.08, (float)(v105 * v106) >= 0.08) )
            v103 = v105 * v106;
          else
            *(float *)&this[1].m_VehicleAudioEntity.m_ReverseSoundPtr = v103;
        }
        v195 = (float)(v103 * AUTOGYRO_ROTORLIFT_MULT) - (float)(v16.n64_f32[0] * AUTOGYRO_ROTORLIFT_FALLOFF);
        v196 = this->m_fMass;
        v197 = (float)((float)(v100 * 0.008) * v195) * v196;
        v198 = (float)(v195 * (float)(v101 * 0.008)) * v196;
        v199 = v104 * (float)(v196 * (float)(v195 * (float)(v102 * 0.008)));
        v366.x = v197 * v104;
        v366.y = v198 * v104;
LABEL_191:
        v366.z = v199;
        CPhysical::ApplyMoveForce(this, v366);
        v206 = this->m_pMat;
        v207 = v206->zz;
        if ( v207 <= 0.0 )
        {
          v233 = v206->zx;
          v234 = this->pFlyingHandling;
          fFormLiftMult = -v234->fFormLiftMult;
          if ( v233 < 0.0 )
            fFormLiftMult = v234->fFormLiftMult;
          v236 = (float)((float)(v234->fAttackLiftMult * fFormLiftMult) * this->m_fTurnMass) * CTimer::ms_fTimeStep;
          v369.x = v206->xz * v236;
          v369.y = v236 * v206->yz;
          v369.z = v207 * v236;
          bPoopi.x = v206->xx + v350.x;
          bPoopi.y = v206->yx + v350.y;
          bPoopi.z = v233 + v350.z;
          CPhysical::ApplyTurnForce(this, v369, bPoopi);
          v237 = this->pFlyingHandling;
          v238 = v237->fFormLiftMult;
          fAttackLiftMult = v237->fAttackLiftMult;
          v240 = this->m_pMat;
          v241 = -v238;
          v222 = v240->zy;
          v220 = v240->xy;
          v221 = v240->yy;
          if ( v222 < 0.0 )
            v241 = v238;
          v242 = (float)((float)(fAttackLiftMult * v241) * this->m_fTurnMass) * CTimer::ms_fTimeStep;
          v243 = v240->xz * v242;
          v244 = v242 * v240->yz;
          v232 = v242 * v240->zz;
          v368.x = v243;
          v368.y = v244;
        }
        else
        {
          v208 = this->pFlyingHandling->fWindMult;
          v.x = (float)(v208 * CWeather::WindDir.x) + 0.0;
          v.y = (float)(v208 * CWeather::WindDir.y) + 0.0;
          v.z = (float)(v208 * CWeather::WindDir.z) + 1.0;
          CVector::Normalise(&v);
          v209 = this->m_pMat;
          v210 = v209->yx;
          v211 = v209->zx;
          v212 = this->pFlyingHandling;
          v213 = v212->fFormLiftMult;
          v214 = -v213;
          v215 = (float)((float)(v209->xx * v.x) + (float)(v210 * v.y)) + (float)(v211 * v.z);
          v216 = v215;
          if ( v215 < (float)-v213 )
            v216 = -v213;
          v217 = v215 < v214;
          if ( v213 < v216 )
            v214 = v212->fFormLiftMult;
          if ( v217 )
            v215 = v214;
          if ( v213 < v216 )
            v215 = v214;
          v218 = (float)((float)(v215 * v212->fAttackLiftMult) * this->m_fTurnMass) * CTimer::ms_fTimeStep;
          v367.x = -(float)(v218 * v209->xz);
          v367.y = -(float)(v218 * v209->yz);
          v367.z = -(float)(v218 * v209->zz);
          bPooph.x = v209->xx + v350.x;
          bPooph.y = v210 + v350.y;
          bPooph.z = v211 + v350.z;
          CPhysical::ApplyTurnForce(this, v367, bPooph);
          v219 = this->m_pMat;
          v220 = v219->xy;
          v221 = v219->yy;
          v222 = v219->zy;
          v223 = this->pFlyingHandling;
          v224 = v223->fFormLiftMult;
          v225 = -v224;
          v226 = (float)((float)(v220 * v.x) + (float)(v221 * v.y)) + (float)(v222 * v.z);
          v227 = v226;
          if ( v226 < (float)-v224 )
            v227 = -v224;
          v228 = v226 < v225;
          if ( v224 < v227 )
            v225 = v223->fFormLiftMult;
          if ( v228 )
            v226 = v225;
          if ( v224 < v227 )
            v226 = v225;
          v229 = (float)((float)(v226 * v223->fAttackLiftMult) * this->m_fTurnMass) * CTimer::ms_fTimeStep;
          v230 = -(float)(v229 * v219->xz);
          v231 = -(float)(v229 * v219->yz);
          v232 = -(float)(v229 * v219->zz);
          v368.x = v230;
          v368.y = v231;
        }
        v368.z = v232;
        bPoopj.x = v220 + v350.x;
        bPoopj.y = v221 + v350.y;
        bPoopj.z = v222 + v350.z;
        CPhysical::ApplyTurnForce(this, v368, bPoopj);
        if ( CHeli::bHeliControlsCheat )
        {
          if ( v26.n64_f32[0] == -10000.0 )
          {
            if ( PadFromPlayer )
              v26.n64_f32[0] = (float)CPad::GetSteeringUpDown(PadFromPlayer) * 0.0078125;
            else
              v26.n64_u32[0] = 0;
          }
          if ( fRollControl == -10000.0 )
          {
            if ( PadFromPlayer )
              LookLeft = (float)CPad::GetLookLeft(PadFromPlayer, 1);
            else
              LookLeft = 0.0;
          }
          if ( v27 != -10000.0 )
            goto LABEL_244;
          if ( PadFromPlayer )
          {
            LookRight = CPad::GetLookRight(PadFromPlayer, 1);
            SteeringLeftRight = CPad::GetSteeringLeftRight(PadFromPlayer);
            if ( LookRight )
              LookLeft = -1.0;
            v27 = (float)SteeringLeftRight * 0.0078125;
            goto LABEL_244;
          }
        }
        else
        {
          if ( v26.n64_f32[0] == -10000.0 )
          {
            if ( PadFromPlayer )
              v26.n64_f32[0] = (float)CPad::GetSteeringUpDown(PadFromPlayer) * 0.0078125;
            else
              v26.n64_u32[0] = 0;
          }
          if ( fRollControl == -10000.0 )
          {
            if ( PadFromPlayer )
              LookLeft = (float)-CPad::GetSteeringLeftRight(PadFromPlayer) * 0.0078125;
            else
              LookLeft = 0.0;
          }
          if ( v27 != -10000.0 )
            goto LABEL_244;
          if ( PadFromPlayer )
          {
            v27 = (float)CPad::GetLookRight(PadFromPlayer, 1);
            v247 = CPad::GetLookLeft(PadFromPlayer, 1);
            CarGunLeftRight = (float)CPad::GetCarGunLeftRight(PadFromPlayer, 0, 0);
            if ( v247 )
              v27 = -1.0;
            v249 = fabsf(CarGunLeftRight);
            v250 = CarGunLeftRight * 0.0078125;
            if ( v249 > 1.0 )
              v27 = v250;
            goto LABEL_244;
          }
        }
        v27 = 0.0;
LABEL_244:
        v251 = this->pFlyingHandling;
        fPitchMult = v251->fPitchMult;
        if ( (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x10) != 0 )
        {
          v253 = v251->fAttackLiftMult;
          v254 = asinf(fPitchMult / v253);
          v255 = (float)(v253 * sinf(v254 * 0.25)) / fPitchMult;
          LookLeft = LookLeft * v255;
          v26.n64_f32[0] = v26.n64_f32[0] * v255;
        }
        v256 = this->m_pMat;
        m_fTurnMass = this->m_fTurnMass;
        v370.x = (float)((float)((float)(v26.n64_f32[0] * v256->xz) * fPitchMult) * m_fTurnMass) * CTimer::ms_fTimeStep;
        v370.y = (float)((float)((float)(v26.n64_f32[0] * v256->yz) * fPitchMult) * m_fTurnMass) * CTimer::ms_fTimeStep;
        v370.z = (float)((float)((float)(v26.n64_f32[0] * v256->zz) * fPitchMult) * m_fTurnMass) * CTimer::ms_fTimeStep;
        bPoopk.x = v256->xy + v350.x;
        bPoopk.y = v256->yy + v350.y;
        bPoopk.z = v256->zy + v350.z;
        CPhysical::ApplyTurnForce(this, v370, bPoopk);
        v258 = this->m_pMat;
        fRollMult = this->pFlyingHandling->fRollMult;
        v260 = (float)(LookLeft * v258->xz) * fRollMult;
        v261 = (float)(LookLeft * v258->yz) * fRollMult;
        v262 = (float)(LookLeft * v258->zz) * fRollMult;
        v263 = this->m_fTurnMass;
        v371.x = (float)(v260 * v263) * CTimer::ms_fTimeStep;
        v371.y = (float)(v261 * v263) * CTimer::ms_fTimeStep;
        v371.z = (float)(v262 * v263) * CTimer::ms_fTimeStep;
        bPoopl.x = v258->xx + v350.x;
        bPoopl.y = v258->yx + v350.y;
        bPoopl.z = v258->zx + v350.z;
        CPhysical::ApplyTurnForce(this, v371, bPoopl);
        v264 = this->m_pMat;
        v265 = v264->yx;
        v266 = v264->zx;
        v267 = (float)((float)(v24 * v264->xx) + (float)(v22.n64_f32[1] * v265)) + (float)(v21.n64_f32[1] * v266);
        v268 = fabsf(v267);
        v269 = v268 * (float)-(float)(v267 * this->pFlyingHandling->fSideSlipMult);
        v270 = v264->xx * v269;
        v271 = v265 * v269;
        v272 = v266 * v269;
        v273 = this->m_fMass;
        v372.x = CTimer::ms_fTimeStep * (float)(v273 * v270);
        v372.y = CTimer::ms_fTimeStep * (float)(v273 * v271);
        v372.z = CTimer::ms_fTimeStep * (float)(v273 * v272);
        CPhysical::ApplyMoveForce(this, v372);
        v274 = this->pFlyingHandling;
        fYawMult = v274->fYawMult;
        v276 = v274->fYawStabilise * v267;
        v277 = this->m_pMat;
        v278 = CTimer::ms_fTimeStep
             * (float)(this->m_fTurnMass * (float)((float)(v27 * fYawMult) - (float)(v268 * v276)));
        v373.x = v277->xx * v278;
        v373.y = v277->yx * v278;
        v373.z = v277->zx * v278;
        bPoopm.x = v350.x - v277->xy;
        bPoopm.y = v350.y - v277->yy;
        bPoopm.z = v350.z - v277->zy;
        CPhysical::ApplyTurnForce(this, v373, bPoopm);
        v279 = this->m_pMat;
        v280 = this->pFlyingHandling->fYawMult;
        v281 = (float)(v27 * v279->xy) * v280;
        v282 = (float)(v27 * v279->yy) * v280;
        v283 = (float)(v27 * v279->zy) * v280;
        v284 = this->m_fTurnMass;
        v374.x = (float)(v281 * v284) * CTimer::ms_fTimeStep;
        v374.y = (float)(v282 * v284) * CTimer::ms_fTimeStep;
        v374.z = (float)(v283 * v284) * CTimer::ms_fTimeStep;
        bPoopn.x = v279->xx + v350.x;
        bPoopn.y = v279->yx + v350.y;
        bPoopn.z = v279->zx + v350.z;
        CPhysical::ApplyTurnForce(this, v374, bPoopn);
        goto LABEL_252;
      }
      v60 = v31->xz;
      v22.n64_u32[0] = LODWORD(v31->yz);
      v21.n64_u32[0] = LODWORD(v31->zz);
      if ( (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x10) != 0 )
      {
        v68 = asinf(v31->xz);
        v69 = sinf(v68 * 4.0);
        v70 = asinf(v22.n64_f32[0]);
        v60 = v69;
        v71 = acosf(v21.n64_f32[0]) * 4.0;
        v22.n64_u32[0] = sinf(v70 * 4.0);
        v21.n64_u32[0] = cosf(v71);
      }
      else if ( this->m_nModelIndex == 520 )
      {
        v61 = (float)((float)LOWORD(this[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity) * 1.5708)
            / (float)CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
        v62 = cosf(v61);
        v63 = sinf(v61);
        v21.n64_f32[0] = (float)(v62 * v31->zy) + (float)(v21.n64_f32[0] * v63);
        v22.n64_f32[0] = (float)(v62 * v31->yy) + (float)(v22.n64_f32[0] * v63);
        v60 = (float)(v62 * v31->xy) + (float)(v60 * v63);
      }
      v72 = (float)((float)(v24 * v60) + (float)(v22.n64_f32[1] * v22.n64_f32[0]))
          + (float)(v21.n64_f32[1] * v21.n64_f32[0]);
      if ( v72 > 0.0 )
        v72 = v72 + v72;
      if ( fThrottleControl == -10000.0 )
      {
        if ( PadFromPlayer )
        {
          v73 = CPad::GetAccelerate(PadFromPlayer);
          v74 = CPad::GetBrake(PadFromPlayer);
          if ( fabsf((float)CPad::GetCarGunUpDown(PadFromPlayer, 0, 0, 2500.0, 0)) <= 1.0 )
            v23 = (float)(v73 - v74) / 255.0;
          else
            v23 = (float)CPad::GetCarGunUpDown(PadFromPlayer, 0, 0, 2500.0, 0) * 0.0078125;
        }
        else
        {
          v23 = 0.0;
        }
      }
      v107 = this->m_fMass;
      v108 = 0.5 - this->m_vecMoveSpeed.z;
      fThrust = this->pFlyingHandling->fThrust;
      v358.z = CTimer::ms_fTimeStep * (float)(v107 * (float)(v108 * 0.008));
      v358.x = CTimer::ms_fTimeStep * (float)(v107 * (float)((float)(v108 * 0.0) * 0.008));
      v358.y = v358.x;
      CPhysical::ApplyMoveForce(this, v358);
      v110 = this->m_pMat;
      p_m_transform = (CSimpleTransform *)&v110->tx;
      if ( !v110 )
        p_m_transform = &this->m_transform;
      v112 = (float)((float)(v23 * fThrust) + 0.45) - (float)(v72 * this->pFlyingHandling->fThrustFallOff);
      v113 = p_m_transform->m_translate.z;
      if ( (unsigned int)(nType - 1) > 1 )
      {
        if ( v113 < 800.0 )
          goto LABEL_190;
        v114 = -800.0;
      }
      else
      {
        if ( v113 < 500.0 )
          goto LABEL_190;
        if ( v113 >= 950.0 )
        {
          if ( v113 < 1500.0 )
            goto LABEL_190;
          v115 = (float)(v113 + -1000.0) + 500.0;
          goto LABEL_82;
        }
        v114 = -500.0;
      }
      v115 = v113 + v114;
LABEL_82:
      if ( v115 > 0.0 )
      {
        if ( (unsigned int)(nType - 1) > 1 )
        {
          if ( v113 >= 800.0 )
          {
            v117 = -800.0;
LABEL_174:
            v116 = v113 + v117;
            goto LABEL_189;
          }
          v116 = -1.0;
        }
        else
        {
          v116 = -1.0;
          if ( v113 >= 500.0 )
          {
            if ( v113 >= 950.0 )
            {
              if ( v113 >= 1500.0 )
                v116 = (float)(v113 + -1000.0) + 500.0;
              goto LABEL_189;
            }
            v117 = -500.0;
            goto LABEL_174;
          }
        }
LABEL_189:
        v112 = v112 * (float)(10.0 / (float)(v116 + 10.0));
      }
LABEL_190:
      v203 = this->m_fMass;
      v204 = (float)((float)(v60 * 0.008) * v112) * v203;
      v205 = (float)((float)(v22.n64_f32[0] * 0.008) * v112) * v203;
      v199 = (float)((float)((float)(v21.n64_f32[0] * 0.008) * v112) * v203) * CTimer::ms_fTimeStep;
      v366.x = v204 * CTimer::ms_fTimeStep;
      v366.y = v205 * CTimer::ms_fTimeStep;
      goto LABEL_191;
    }
    if ( fYawControl == -10000.0 )
    {
      if ( PadFromPlayer )
        v27 = (float)CPad::GetSteeringLeftRight(PadFromPlayer) * 0.0078125;
      else
        v27 = 0.0;
    }
    if ( fPitchControl == -10000.0 )
    {
      if ( PadFromPlayer )
      {
        v64 = (float)CPad::GetSteeringUpDown(PadFromPlayer);
        if ( fabsf((float)CPad::GetCarGunUpDown(PadFromPlayer, 0, 0, 2500.0, 0)) > 1.0 )
          v64 = (float)-CPad::GetCarGunUpDown(PadFromPlayer, 0, 0, 2500.0, 0);
        v26.n64_f32[0] = v64 * 0.0078125;
      }
      else
      {
        v26.n64_u32[0] = 0;
      }
    }
    v65 = atan2f(v26.n64_f32[0], v27);
    v66 = v65;
    if ( v65 <= -0.7854 || v65 > 0.7854 )
    {
      if ( v65 <= 0.7854 || v65 > 2.3562 )
      {
        if ( v65 <= 2.3562 )
        {
          if ( v65 <= -2.3562 )
          {
            v67 = 3.1416;
          }
          else
          {
            v75 = 1.0;
            if ( v65 <= -2.3562 || v65 >= -0.7854 )
            {
LABEL_90:
              v118 = this->m_pMat;
              v119 = v118->xy;
              v120 = v118->yy;
              v121 = v118->zy;
              v122 = CEntity::GetColModel(this)->m_boxBound.m_vecMin.y;
              if ( nType == FLIGHTMODEL_RCPLANE )
              {
                v123 = this->m_fMass;
                v359.x = (float)(v123 * 0.0) * CTimer::ms_fTimeStep;
                v359.z = (float)(v123 * 0.004) * CTimer::ms_fTimeStep;
                v359.y = v359.x;
                CPhysical::ApplyMoveForce(this, v359);
              }
              if ( fThrottleControl == -10000.0 )
              {
                if ( PadFromPlayer )
                {
                  v124 = CPad::GetAccelerate(PadFromPlayer);
                  v23 = (float)(v124 - CPad::GetBrake(PadFromPlayer)) / 255.0;
                }
                else
                {
                  v23 = 0.0;
                }
              }
              v22.n64_f32[0] = (float)((float)(v24 * v119) + (float)(v22.n64_f32[1] * v120))
                             + (float)(v21.n64_f32[1] * v121);
              m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
              v347 = v24;
              if ( !this->m_baseVehicleType )
              {
                if ( m_nModelIndex != 539
                  && *(float *)&this[1].m_VehicleAudioEntity.m_EngineSounds[2].SoundPtr == 1.0
                  && *(float *)&this[1].m_VehicleAudioEntity.m_EngineSounds[3].SoundPtr == 1.0 )
                {
                  if ( m_nModelIndex != 460 )
                  {
                    v126 = (unsigned __int16)this->m_nModelIndex;
LABEL_172:
                    v128 = this->pFlyingHandling;
                    v127 = v21.n64_f32[1];
                    v129 = v128->fThrust;
                    goto LABEL_108;
                  }
                  v126 = 460;
                  if ( v23 > 0.0 || (*(_DWORD *)&this->m_nPhysicalFlags & 0x100) == 0 )
                    goto LABEL_172;
LABEL_113:
                  v127 = v21.n64_f32[1];
                  v21.n64_u32[0] = 0;
                  if ( v23 < 0.0
                    && (float)((float)((float)(this->m_pMat->xy * this->m_vecMoveSpeed.x)
                                     + (float)(this->m_pMat->yy * this->m_vecMoveSpeed.y))
                             + (float)(this->m_pMat->zy * this->m_vecMoveSpeed.z)) < 0.02 )
                  {
                    v7.n64_u32[0] = 0;
                    v6.n64_f32[0] = v23 + (float)(v22.n64_f32[0] * -7.76);
                    v21.n64_f32[0] = vmin_f32(v6, v7).n64_f32[0] * this->pFlyingHandling->fThrust;
                  }
                  v126 = (unsigned __int16)this->m_nModelIndex;
LABEL_119:
                  v133 = v121 * v122;
                  v134 = v120 * v122;
                  v346 = nType;
                  v135.n64_f32[1] = v119 * v122;
                  if ( nType == FLIGHTMODEL_PLANE_GLIDER )
                  {
                    v136 = 0.1;
                  }
                  else
                  {
                    if ( nType != FLIGHTMODEL_PLANE_LOWPOWER )
                      goto LABEL_124;
                    v136 = 0.3;
                  }
                  v21.n64_f32[0] = v21.n64_f32[0] * v136;
LABEL_124:
                  v137 = v133;
                  v138 = this->m_pMat;
                  v139 = v134;
                  v140 = v138->xy;
                  v141 = v138->yy;
                  v135.n64_u32[0] = LODWORD(v138->zy);
                  if ( v126 == 520 )
                  {
                    v142 = (float)((float)LOWORD(this[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity)
                                 * 1.5708)
                         / (float)CPlane::HARRIER_NOZZLE_ROTATE_LIMIT;
                    v143 = cosf(v142);
                    v144 = v142;
                    v137 = v133;
                    v139 = v134;
                    v145 = sinf(v144);
                    v141 = (float)(v141 * v143) + (float)(v145 * v138->yz);
                    v135.n64_f32[0] = (float)(v135.n64_f32[0] * v143) + (float)(v145 * v138->zz);
                    v140 = (float)(v140 * v143) + (float)(v145 * v138->xz);
                  }
                  v146 = v27 * v75;
                  v147 = this->m_fMass;
                  v360.x = (float)((float)(v21.n64_f32[0] * (float)(v140 * 0.008)) * v147) * CTimer::ms_fTimeStep;
                  v360.y = (float)((float)(v21.n64_f32[0] * (float)(v141 * 0.008)) * v147) * CTimer::ms_fTimeStep;
                  v360.z = CTimer::ms_fTimeStep
                         * (float)(v147 * (float)(v21.n64_f32[0] * (float)(v135.n64_f32[0] * 0.008)));
                  CPhysical::ApplyMoveForce(this, v360);
                  v148 = this->m_pMat;
                  v149 = v148->yx;
                  v150 = v148->zx;
                  v151 = fabsf((float)((float)(v347 * v148->xx) + (float)(v22.n64_f32[1] * v149)) + (float)(v127 * v150))
                       * (float)-(float)((float)((float)((float)(v347 * v148->xx) + (float)(v22.n64_f32[1] * v149))
                                               + (float)(v127 * v150))
                                       * this->pFlyingHandling->fSideSlipMult);
                  v152 = v148->xx * v151;
                  v153 = v149 * v151;
                  v154 = v150 * v151;
                  v155 = this->m_fMass;
                  v361.x = CTimer::ms_fTimeStep * (float)(v155 * v152);
                  v361.y = CTimer::ms_fTimeStep * (float)(v155 * v153);
                  v361.z = CTimer::ms_fTimeStep * (float)(v155 * v154);
                  CPhysical::ApplyMoveForce(this, v361);
                  v156 = this->m_pMat;
                  *(_QWORD *)&v379.x = __PAIR64__(LODWORD(v139), v135.n64_u32[1]);
                  xx = v156->xx;
                  v26.n64_u32[1] = LODWORD(v156->yx);
                  v158 = v156->zx;
                  v379.z = v137;
                  CPhysical::GetSpeed(&v, this, v379);
                  nType = v346;
                  v159 = v22.n64_f32[0];
                  if ( this->m_nModelIndex == 539 )
                  {
                    LODWORD(v159) = vmin_f32(v22, v21).n64_u32[0];
                    v8.n64_u64[0] = vmax_f32(v22, v21).n64_u64[0];
                    if ( v22.n64_f32[0] > 0.0 )
                      v159 = v8.n64_f32[0];
                  }
                  v161 = v26.n64_f32[0] * v75;
                  v160 = -(float)((float)((float)(v.x * this->m_pMat->xx) + (float)(v.y * this->m_pMat->yx))
                                + (float)(v.z * this->m_pMat->zx));
                  v162 = CTimer::ms_fTimeStep
                       * (float)(this->m_fTurnMass
                               * (float)((float)(v159 * (float)(v146 * this->pFlyingHandling->fYawMult))
                                       + (float)(fabsf(v160) * (float)(this->pFlyingHandling->fYawStabilise * v160))));
                  v362.x = xx * v162;
                  v362.y = v26.n64_f32[1] * v162;
                  v362.z = v158 * v162;
                  bPoopd.x = v135.n64_f32[1] + v350.x;
                  bPoopd.y = v134 + v350.y;
                  bPoopd.z = v133 + v350.z;
                  CPhysical::ApplyTurnForce(this, v362, bPoopd);
                  if ( fRollControl == -10000.0 )
                    LookLeft = v146;
                  v163 = this->m_pMat;
                  v164 = CTimer::ms_fTimeStep
                       * (float)(this->m_fTurnMass
                               * (float)(v22.n64_f32[0] * (float)(LookLeft * this->pFlyingHandling->fRollMult)));
                  v363.x = v163->xx * v164;
                  v363.y = v163->yx * v164;
                  v363.z = v163->zx * v164;
                  bPoope.x = v163->xz + v350.x;
                  bPoope.y = v163->yz + v350.y;
                  bPoope.z = v163->zz + v350.z;
                  CPhysical::ApplyTurnForce(this, v363, bPoope);
                  v165 = this->m_pMat;
                  v2.x = 0.0;
                  v2.y = 0.0;
                  v2.z = 1.0;
                  CrossProduct(&v, (const CVector *)&v165->xy, &v2);
                  v166 = v.x;
                  v167 = v.y;
                  v168 = this->m_pMat;
                  v169 = v.z;
                  v170 = v168->zz;
                  if ( v170 <= 0.0 )
                  {
                    v171 = v168->zx;
                    LODWORD(v169) = LODWORD(v.z) ^ 0x80000000;
                    LODWORD(v167) = LODWORD(v.y) ^ 0x80000000;
                    LODWORD(v166) = LODWORD(v.x) ^ 0x80000000;
                    if ( v171 <= 0.0 )
                      goto LABEL_133;
                  }
                  else
                  {
                    v171 = v168->zx;
                    if ( v171 <= 0.0 )
                    {
LABEL_133:
                      v8.n64_u32[0] = 1.0;
LABEL_136:
                      v172 = v168->yx;
                      v173.n64_f32[1] = v168->xx * v166;
                      v26.n64_u32[0] = 1.0;
                      v8.n64_f32[0] = CTimer::ms_fTimeStep
                                    * (float)((float)(this->m_fTurnMass
                                                    * (float)(this->pFlyingHandling->fRollStabilise
                                                            * (float)((float)(1.0 - fabsf(v168->zy))
                                                                    * (float)(v8.n64_f32[0]
                                                                            * (float)(1.0
                                                                                    - (float)((float)(v173.n64_f32[1] + (float)(v172 * v167))
                                                                                            + (float)(v171 * v169)))))))
                                            * 0.5);
                      v364.x = v168->xx * v8.n64_f32[0];
                      v364.y = v172 * v8.n64_f32[0];
                      v364.z = v171 * v8.n64_f32[0];
                      bPoopf.x = v168->xz + v350.x;
                      bPoopf.y = v168->yz + v350.y;
                      bPoopf.z = v170 + v350.z;
                      CPhysical::ApplyTurnForce(this, v364, bPoopf);
                      v174 = this->m_pMat;
                      *(_QWORD *)&v380.x = __PAIR64__(LODWORD(v139), v135.n64_u32[1]);
                      v135.n64_u32[0] = LODWORD(v174->xz);
                      v175 = v174->yz;
                      v176 = v174->zz;
                      v380.z = v137;
                      CPhysical::GetSpeed(&v, this, v380);
                      v177 = (float)((float)(v.x * this->m_pMat->xz) + (float)(v.y * this->m_pMat->yz))
                           + (float)(v.z * this->m_pMat->zz);
                      v178 = CTimer::ms_fTimeStep
                           * (float)(this->m_fTurnMass
                                   * (float)((float)(fabsf(v177)
                                                   * (float)-(float)(v177 * this->pFlyingHandling->fPitchStabilise))
                                           - (float)(v22.n64_f32[0] * (float)(v161 * this->pFlyingHandling->fPitchMult))));
                      v365.x = v135.n64_f32[0] * v178;
                      v365.y = v175 * v178;
                      v365.z = v176 * v178;
                      bPoopg.x = v135.n64_f32[1] + v350.x;
                      bPoopg.y = v134 + v350.y;
                      bPoopg.z = v133 + v350.z;
                      CPhysical::ApplyTurnForce(this, v365, bPoopg);
                      v135.n64_u32[0] = -1.0;
                      v179 = this->m_pMat;
                      v173.n64_f32[0] = sqrtf(
                                          (float)((float)(v347 * v347) + (float)(v22.n64_f32[1] * v22.n64_f32[1]))
                                        + (float)(v127 * v127));
                      v8.n64_u32[0] = 1008981770;
                      v180.n64_u64[0] = vmax_f32(v173, v8).n64_u64[0];
                      v180.n64_f32[0] = (float)((float)((float)(v347 * v179->xz) + (float)(v22.n64_f32[1] * v179->yz))
                                              + (float)(v127 * v179->zz))
                                      / v180.n64_f32[0];
                      v181 = asinf(vmax_f32(vmin_f32(v180, v26), v135).n64_f32[0]);
                      m_vehicleType = this->m_vehicleType;
                      if ( v181 < -0.73304 && m_vehicleType == 4 )
                        *(_DWORD *)&this[1].AutoPilot.aPathNodeList[1] += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0)
                                                                                              * 1000.0);
                      v183 = v22.n64_f32[0] * v22.n64_f32[0];
                      v184 = this->pFlyingHandling;
                      v185 = v184->fFormLiftMult;
                      if ( v346 == FLIGHTMODEL_RCPLANE )
                      {
                        if ( (float)(v183 * v185) > 0.004 )
                          v185 = 0.004 / v183;
                      }
                      else if ( m_vehicleType == 4 && *(float *)&this[1].m_nVehicleFlags < 1.0 )
                      {
                        v185 = v185 * v184->fGearDownLiftMult;
                      }
                      v186 = v183 * (float)(v185 - (float)(v181 * v184->fAttackLiftMult));
                      v187 = this->m_fMass;
                      v188 = CTimer::ms_fTimeStep * (float)(v187 * v186);
                      if ( v188 <= (float)(v187 * (float)(CTimer::ms_fTimeStep * 0.008)) )
                        goto LABEL_251;
                      v189 = (CSimpleTransform *)&v179->tx;
                      if ( !v179 )
                        v189 = &this->m_transform;
                      v190 = v189->m_translate.z;
                      v191 = v346 - 1;
                      if ( (unsigned int)(v346 - 1) > 1 )
                      {
                        if ( v190 < 800.0 )
                          goto LABEL_251;
                        v192 = -800.0;
                      }
                      else
                      {
                        if ( v190 < 500.0 )
                          goto LABEL_251;
                        if ( v190 >= 950.0 )
                        {
                          if ( v190 < 1500.0 )
                            goto LABEL_251;
                          v193 = (float)(v190 + -1000.0) + 500.0;
                          goto LABEL_155;
                        }
                        v192 = -500.0;
                      }
                      v193 = v190 + v192;
LABEL_155:
                      if ( v193 > 0.0 )
                      {
                        if ( v191 > 1 )
                        {
                          if ( v190 < 800.0 )
                            goto LABEL_177;
                          v194 = -800.0;
                        }
                        else
                        {
                          if ( v190 < 500.0 )
                            goto LABEL_177;
                          if ( v190 >= 950.0 )
                          {
                            if ( v190 >= 1500.0 )
                              v135.n64_f32[0] = (float)(v190 + -1000.0) + 500.0;
LABEL_177:
                            if ( (float)((float)(v135.n64_f32[0] / -50.0) + 1.0) < 0.0 )
                            {
                              v200 = 0.0;
LABEL_250:
                              v188 = (float)(v200 * CTimer::ms_fTimeStep) * v187;
                              goto LABEL_251;
                            }
                            if ( v191 > 1 )
                            {
                              if ( v190 >= 800.0 )
                              {
                                v202 = -800.0;
LABEL_186:
                                v201 = v190 + v202;
                                goto LABEL_249;
                              }
                              v201 = -1.0;
                            }
                            else
                            {
                              v201 = -1.0;
                              if ( v190 >= 500.0 )
                              {
                                if ( v190 >= 950.0 )
                                {
                                  if ( v190 >= 1500.0 )
                                    v201 = (float)(v190 + -1000.0) + 500.0;
                                  goto LABEL_249;
                                }
                                v202 = -500.0;
                                goto LABEL_186;
                              }
                            }
LABEL_249:
                            v200 = (float)((float)(v201 / -50.0) + 1.0) * 0.008;
                            goto LABEL_250;
                          }
                          v194 = -500.0;
                        }
                        v135.n64_f32[0] = v190 + v194;
                        goto LABEL_177;
                      }
LABEL_251:
                      v375.x = v188 * v179->xz;
                      v375.y = v188 * v179->yz;
                      v375.z = v188 * v179->zz;
                      CPhysical::ApplyMoveForce(this, v375);
                      goto LABEL_252;
                    }
                  }
                  v8.n64_u32[0] = -1.0;
                  goto LABEL_136;
                }
                if ( v23 <= 0.0 )
                  goto LABEL_113;
              }
              v127 = v21.n64_f32[1];
              v128 = this->pFlyingHandling;
              v129 = v128->fThrust;
              if ( m_nModelIndex == 539 )
              {
                v21.n64_f32[0] = v23 * v129;
                v126 = 539;
LABEL_109:
                if ( v22.n64_f32[0] > 0.0 )
                {
                  fThrustFallOff = v128->fThrustFallOff;
                  if ( fThrustFallOff < 1.0 )
                  {
                    if ( fThrustFallOff >= 0.0 )
                    {
                      v131 = v22.n64_f32[0] - fThrustFallOff;
                      v8.n64_u32[0] = -1088002458;
                    }
                    else
                    {
                      v8.n64_u32[0] = -3.0;
                      v131 = v22.n64_f32[0] + fThrustFallOff;
                    }
                    v132 = v131 * (float)(v131 * v8.n64_f32[0]);
                    v8.n64_u32[0] = 0;
                    v6.n64_f32[0] = v132 + 1.0;
                    v21.n64_f32[0] = v21.n64_f32[0] * vmax_f32(v6, v8).n64_f32[0];
                  }
                }
                goto LABEL_119;
              }
              v126 = (unsigned __int16)this->m_nModelIndex;
LABEL_108:
              v21.n64_f32[0] = (float)(v23 + 1.0) * (float)(v129 * 0.5);
              goto LABEL_109;
            }
            v67 = 1.5708;
          }
        }
        else
        {
          v67 = -3.1416;
        }
      }
      else
      {
        v67 = -1.5708;
      }
      v66 = v65 + v67;
    }
    v75 = 1.0 / cosf(v66);
    goto LABEL_90;
  }
LABEL_252:
  v285 = this->pFlyingHandling->vecTurnRes.x;
  v286 = this->pFlyingHandling->vecTurnRes.y;
  v287 = this->pFlyingHandling->vecTurnRes.z;
  v288 = CTimer::ms_fTimeStep;
  Multiply3x3(&v, &this->m_vecTurnSpeed, this->m_pMat);
  v289 = powf(v285, v288);
  v290 = powf(v286, v288);
  v291 = powf(v287, v288);
  if ( (unsigned int)(nType - 3) > 2 )
  {
    v294 = nType == FLIGHTMODEL_AUTOGYRO;
    if ( nType != FLIGHTMODEL_AUTOGYRO )
      v294 = nType == FLIGHTMODEL_HELI;
    if ( v294 )
    {
      v293 = sqrtf(
               (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                     + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
             + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z))
           + 1.0;
    }
    else if ( nType == FLIGHTMODEL_RCPLANE )
    {
      v293 = sqrtf(
               (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                     + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
             + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z))
           * 6.0;
    }
    else
    {
      v293 = 1.0;
    }
  }
  else
  {
    v292 = sqrtf(
             (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                   + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
           + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
    v293 = v292 + v292;
  }
  v295 = this->pFlyingHandling;
  v296 = v295->vecSpeedRes.x;
  if ( v296 <= 0.0 )
  {
    v299 = powf(v289, v293);
    v298 = 0.0;
    v.x = v299 * v.x;
  }
  else
  {
    v297 = v.x;
    v298 = (float)(v297 * powf(v289 / (float)((float)(v.x * (float)(v296 * v.x)) + 1.0), CTimer::ms_fTimeStep)) - v297;
  }
  v300 = v295->vecSpeedRes.y;
  if ( v300 <= 0.0 )
  {
    v303 = powf(v290, v293);
    v302 = 0.0;
    v.y = v303 * v.y;
  }
  else
  {
    v301 = v.y;
    v302 = (float)(v301 * powf(v290 / (float)((float)(v.y * (float)(v300 * v.y)) + 1.0), CTimer::ms_fTimeStep)) - v301;
  }
  v304 = v295->vecSpeedRes.z;
  if ( v304 <= 0.0 )
  {
    v307 = powf(v291, v293);
    v306 = 0.0;
    v.z = v307 * v.z;
  }
  else
  {
    v305 = v.z;
    v306 = (float)(v305 * powf(v291 / (float)((float)(v.z * (float)(v304 * v.z)) + 1.0), CTimer::ms_fTimeStep)) - v305;
  }
  Multiply3x3(&v2, this->m_pMat, &v);
  v308 = v293 * v298;
  v309 = *(_QWORD *)&v2.x;
  v310 = v293 * v302;
  this->m_vecTurnSpeed.z = v2.z;
  *(_QWORD *)&this->m_vecTurnSpeed.x = v309;
  if ( v308 != 0.0 )
  {
    v311 = this->m_pMat;
    v312 = this->m_fTurnMass;
    bPoopo.x = v311->xz + v350.x;
    bPoopo.y = v311->yz + v350.y;
    bPoopo.z = v311->zz + v350.z;
    v376.x = -(float)((float)(v308 * v311->xy) * v312);
    v376.y = -(float)((float)(v308 * v311->yy) * v312);
    v376.z = -(float)((float)(v308 * v311->zy) * v312);
    CPhysical::ApplyTurnForce(this, v376, bPoopo);
  }
  v313 = v293 * v306;
  if ( v310 != 0.0 )
  {
    v314 = this->m_pMat;
    v315 = this->m_fTurnMass;
    bPoopp.x = v314->xx + v350.x;
    bPoopp.y = v314->yx + v350.y;
    bPoopp.z = v314->zx + v350.z;
    v377.x = -(float)((float)(v310 * v314->xz) * v315);
    v377.y = -(float)((float)(v310 * v314->yz) * v315);
    v377.z = -(float)((float)(v310 * v314->zz) * v315);
    CPhysical::ApplyTurnForce(this, v377, bPoopp);
  }
  if ( v313 != 0.0 )
  {
    v316 = this->m_pMat;
    v317 = this->m_fTurnMass;
    bPoopq.x = v316->xy + v350.x;
    bPoopq.y = v316->yy + v350.y;
    bPoopq.z = v316->zy + v350.z;
    v378.x = -(float)((float)(v313 * v316->xx) * v317);
    v378.y = -(float)((float)(v313 * v316->yx) * v317);
    v378.z = -(float)((float)(v313 * v316->zx) * v317);
    CPhysical::ApplyTurnForce(this, v378, bPoopq);
  }
  v318 = this->m_vecMoveSpeed.x;
  v319 = this->m_vecMoveSpeed.y;
  v320 = this->m_vecMoveSpeed.z;
  v321 = (float)((float)(v318 * v318) + (float)(v319 * v319)) + (float)(v320 * v320);
  if ( v321 > 2.25 )
  {
    v322 = 1.0 / sqrtf(v321);
    this->m_vecMoveSpeed.x = (float)(v318 * 1.5) * v322;
    this->m_vecMoveSpeed.y = (float)(v319 * 1.5) * v322;
    this->m_vecMoveSpeed.z = (float)(v320 * 1.5) * v322;
  }
  v323 = this->m_vecTurnSpeed.x;
  v324 = this->m_vecTurnSpeed.y;
  v325 = this->m_vecTurnSpeed.z;
  v326 = (float)((float)(v323 * v323) + (float)(v324 * v324)) + (float)(v325 * v325);
  if ( v326 > 0.04 )
  {
    v327 = 1.0 / sqrtf(v326);
    this->m_vecTurnSpeed.x = (float)(v323 * 0.2) * v327;
    this->m_vecTurnSpeed.y = (float)(v324 * 0.2) * v327;
    this->m_vecTurnSpeed.z = (float)(v325 * 0.2) * v327;
  }
}
// 585FBE: variable 'v7' is possibly undefined
// 585FBE: variable 'v8' is possibly undefined
// 5860DA: variable 'v6' is possibly undefined

//----- (00587B20) --------------------------------------------------------
int __fastcall CVehicle::DoBladeCollision(
        CVehicle *this,
        CVector vecPos,
        CMatrix *mat,
        int nAxisDirn,
        float fRadius,
        float fImpactMult)
{
  char v7; // r0
  float v8; // s8
  float v9; // s10
  float v10; // s14
  float v11; // s1
  float v12; // s12
  float v13; // s3
  int v14; // r4
  float x; // s18
  float y; // s20
  float v17; // r8
  float v18; // s2
  float v19; // s16
  float v20; // s18
  float v21; // r0
  int v22; // s2
  int v23; // r8
  int v24; // r1
  int v25; // r1
  uint16 v26; // r0
  CMatrix *v27; // r5
  int v28; // r0
  int v29; // r9
  int v30; // r0
  CMatrix *v31; // r4
  CMatrix *v32; // r3
  CRepeatSector *v33; // r5
  CPtrList *v34; // r1
  int v36; // r2
  int result; // r0
  int v38; // [sp+Ch] [bp-94h]
  int v39; // [sp+10h] [bp-90h]
  int v40; // [sp+14h] [bp-8Ch]
  int v41; // [sp+24h] [bp-7Ch]
  CVector v42; // [sp+28h] [bp-78h] BYREF
  CVector vecMax; // [sp+34h] [bp-6Ch] BYREF
  CVector vecMin; // [sp+40h] [bp-60h] BYREF
  CVector vecCentre; // [sp+4Ch] [bp-54h] BYREF

  v7 = nAxisDirn + 3;
  vecCentre = vecPos;
  vecMax.y = fRadius;
  vecMax.x = fRadius;
  vecMax.z = fRadius;
  vecMin.y = -fRadius;
  vecMin.x = -fRadius;
  vecMin.z = -fRadius;
  if ( (unsigned int)(nAxisDirn + 3) > 6 )
  {
LABEL_8:
    v8 = fRadius;
    v9 = fRadius;
    v12 = fRadius;
    v10 = -fRadius;
    goto LABEL_9;
  }
  if ( ((1 << v7) & 0x41) != 0 )
  {
    v9 = fRadius;
    v12 = fRadius;
    v8 = ROTOR_SEMI_THICKNESS;
    v10 = -ROTOR_SEMI_THICKNESS;
    vecMax.z = ROTOR_SEMI_THICKNESS;
    vecMin.z = -ROTOR_SEMI_THICKNESS;
LABEL_9:
    v11 = -fRadius;
    goto LABEL_10;
  }
  if ( ((1 << v7) & 0x22) == 0 )
  {
    if ( ((1 << v7) & 0x14) != 0 )
    {
      v8 = fRadius;
      v9 = fRadius;
      v10 = -fRadius;
      v11 = -fRadius;
      v12 = ROTOR_SEMI_THICKNESS;
      v13 = -ROTOR_SEMI_THICKNESS;
      vecMax.x = ROTOR_SEMI_THICKNESS;
      vecMin.x = -ROTOR_SEMI_THICKNESS;
      goto LABEL_11;
    }
    goto LABEL_8;
  }
  v8 = fRadius;
  v12 = fRadius;
  v10 = -fRadius;
  v9 = ROTOR_SEMI_THICKNESS;
  v11 = -ROTOR_SEMI_THICKNESS;
  vecMax.y = ROTOR_SEMI_THICKNESS;
  vecMin.y = -ROTOR_SEMI_THICKNESS;
LABEL_10:
  v13 = -fRadius;
LABEL_11:
  vecMin.y = v11 + vecPos.y;
  vecMin.z = v10 + vecPos.z;
  vecMin.x = v13 + vecPos.x;
  vecMax.y = v9 + vecPos.y;
  vecMax.z = v8 + vecPos.z;
  vecMax.x = v12 + vecPos.x;
  CBox::Set(&TestBladeCol.m_boxBound, &vecMin, &vecMax);
  CSphere::Set(&TestBladeCol.m_sphereBound, fRadius, &vecCentre);
  v14 = 0;
  TestBladeCol.m_pColData = &TestBladeColData;
  CColSphere::Set(&TestBladeColSphere, fRadius, &vecCentre, 0, 0, 0xFFu);
  TestBladeColData.m_nNoOfSpheres = 1;
  TestBladeColData.m_pSphereArray = &TestBladeColSphere;
  operator*(&v42, mat, &vecCentre);
  x = v42.x;
  y = v42.y;
  v17 = floorf((float)((float)(v42.x - fRadius) / 50.0) + 60.0);
  v18 = x + fRadius;
  v19 = floorf((float)((float)(y - fRadius) / 50.0) + 60.0);
  v20 = floorf((float)((float)(y + fRadius) / 50.0) + 60.0);
  v21 = floorf((float)(v18 / 50.0) + 60.0);
  v22 = (int)v17;
  v23 = 120;
  v24 = (int)v20;
  if ( (int)v20 >= 120 )
    v24 = 120;
  v38 = v24;
  if ( (int)v21 < 120 )
    v23 = (int)v21;
  v25 = (int)v19;
  if ( (int)v19 <= 0 )
    v25 = 0;
  v40 = v25;
  if ( v22 > 0 )
    v14 = v22;
  v39 = v14;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v26 = 1;
  }
  else
  {
    v26 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v26;
  if ( v40 <= v38 )
  {
    do
    {
      v27 = mat;
      if ( v39 <= v23 )
      {
        v28 = 119;
        if ( v40 < 119 )
          v28 = v40;
        v29 = v39;
        v41 = 120 * v28;
        do
        {
          v30 = 119;
          if ( v29 < 119 )
            v30 = v29;
          CVehicle::BladeColSectorList(
            this,
            &CWorld::ms_aSectors[v30 + v41].m_buildingPtrListArray,
            &TestBladeCol,
            v27,
            nAxisDirn,
            fImpactMult);
          v31 = v27;
          v32 = v27;
          v33 = &CWorld::ms_aRepeatSectors[v29 & 0xF | (unsigned __int8)(16 * v40)];
          CVehicle::BladeColSectorList(this, (CPtrList *)v33, &TestBladeCol, v32, nAxisDirn, fImpactMult);
          CVehicle::BladeColSectorList(this, &v33->m_ptrListArray[1], &TestBladeCol, v31, nAxisDirn, 0.0);
          v34 = &v33->m_ptrListArray[2];
          v27 = v31;
          CVehicle::BladeColSectorList(this, v34, &TestBladeCol, v31, nAxisDirn, fImpactMult);
        }
        while ( v29++ < v23 );
      }
      v36 = v40++;
    }
    while ( v36 < v38 );
  }
  TestBladeColData.m_nNoOfSpheres = 0;
  TestBladeColData.m_pSphereArray = 0;
  result = 0;
  TestBladeCol.m_pColData = 0;
  return result;
}
// 587B20: using guessed type int nAxisDirn_0;

//----- (00587EAC) --------------------------------------------------------
int __fastcall CVehicle::BladeColSectorList(
        CVehicle *this,
        CPtrList *list,
        CColModel *TestColModel,
        CMatrix *mat,
        int nAxis,
        float fImpactMult)
{
  float xx; // s16
  float yx; // s18
  float zx; // s20
  CMatrix *v10; // r9
  CPtrNode *m_pHead; // r4
  float xz; // s0
  float yz; // s2
  float zz; // s4
  __int64 v15; // d16
  CPtrNode v16; // kr00_8
  bool v17; // zf
  char v18; // r1
  CColModel *v19; // r0
  CColModel *v20; // r5
  const CMatrix *v21; // r2
  int32 v22; // r10
  int v23; // r0
  float *v24; // r9
  CMatrix *m_pMat; // r1
  float *v26; // r2
  CSimpleTransform *p_tx; // r0
  float v28; // s0
  float v29; // s2
  float v30; // s4
  float v31; // s4
  int v32; // r1
  int v33; // r9
  int v34; // r0
  CColPoint *v35; // r5
  float z; // r2
  float32x2_t v37; // d1
  float v38; // s12
  float v39; // s5
  CColPoint *v40; // r1
  RwReal v41; // s2
  RwReal v42; // s4
  float v43; // r0
  CAESound *m_ReverseSoundPtr; // s0
  float v45; // s0
  float v46; // s0
  float32x2_t v47; // d0
  bool v48; // zf
  int v49; // r0
  unsigned int m_info; // r0
  CVector *GameCamPosition; // r0
  float v52; // s4
  float v53; // s0
  CVector *v54; // r0
  float v55; // s2
  float v56; // s0
  uint8 LocalDirection; // r11
  const CEventDamage *v58; // r0
  int v59; // r0
  float v60; // r0
  uint32 v61; // r5
  __int128 aColPoints; // [sp+0h] [bp-168h] BYREF
  float m_fElasticity; // [sp+1Ch] [bp-14Ch]
  CMatrix *v65; // [sp+40h] [bp-128h]
  CColModel *colModelA; // [sp+4Ch] [bp-11Ch]
  CVector fImpulseMagnitude; // [sp+68h] [bp-100h] BYREF
  CVector v68; // [sp+78h] [bp-F0h] BYREF
  CEventDamage v2; // [sp+88h] [bp-E0h] BYREF
  CPedDamageResponseCalculator pos; // [sp+C8h] [bp-A0h] BYREF
  CVector2D v71; // [sp+E0h] [bp-88h] BYREF
  CVector v72; // [sp+E8h] [bp-80h] BYREF
  CVector v; // [sp+F8h] [bp-70h] BYREF
  CVector v74; // 0:r1.12
  CVector v75; // 0:r1.12

  colModelA = TestColModel;
  v10 = mat;
  m_pHead = list->m_pHead;
  memset(&v, 0, sizeof(v));
  switch ( nAxis )
  {
    case -3:
      v.z = -0.2;
      xz = mat->xz;
      yz = mat->yz;
      zz = mat->zz;
      goto LABEL_5;
    case -2:
      v.y = -0.2;
      xz = mat->xy;
      yz = mat->yy;
      zz = mat->zy;
      goto LABEL_5;
    case -1:
      v.x = -0.2;
      xz = mat->xx;
      yz = mat->yx;
      zz = mat->zx;
LABEL_5:
      zx = -zz;
      yx = -yz;
      xx = -xz;
      break;
    case 1:
      v.x = 0.2;
      xx = mat->xx;
      yx = mat->yx;
      zx = mat->zx;
      break;
    case 2:
      v.y = 0.2;
      xx = mat->xy;
      yx = mat->yy;
      zx = mat->zy;
      break;
    case 3:
      v.z = 0.2;
      xx = mat->xz;
      yx = mat->yz;
      zx = mat->zz;
      break;
    default:
      break;
  }
  Multiply3x3((CVector *)&v2, mat, &v);
  v.z = *(RwReal *)&v2.m_bIsPersistent;
  *(_QWORD *)&v.x = *(_QWORD *)&v2._vptr$CEvent;
  v15 = *(_QWORD *)&colModelA->m_sphereBound.m_vecCentre.x;
  v72.z = colModelA->m_sphereBound.m_vecCentre.z;
  *(_QWORD *)&v72.x = v15;
  operator*((CVector *)&v2, v10, &v72);
  v72.z = *(RwReal *)&v2.m_bIsPersistent;
  *(_QWORD *)&v72.x = *(_QWORD *)&v2._vptr$CEvent;
  if ( m_pHead )
  {
    v65 = v10;
    while ( 1 )
    {
      v16 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v17 = v16.m_pVoid == this;
      if ( v16.m_pVoid != this )
        v17 = *((unsigned __int8 *)v16.m_pVoid + 28) << 31 == 0;
      if ( v17 || *((unsigned __int16 *)v16.m_pVoid + 24) == CWorld::ms_nCurrentScanCode )
        goto LABEL_15;
      v18 = *((_BYTE *)v16.m_pVoid + 58);
      *((_WORD *)v16.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      v19 = (v18 & 7) == 3 ? CPedModelInfo::AnimatePedColModelSkinned(
                               (CPedModelInfo *)CModelInfo::ms_modelInfoPtrs[*((__int16 *)v16.m_pVoid + 19)],
                               *((RpClump_0 **)v16.m_pVoid + 6)) : CEntity::GetColModel((CEntity *)v16.m_pVoid);
      v20 = v19;
      if ( (*((_BYTE *)v16.m_pVoid + 58) & 7) == 4 )
        break;
      if ( v19 )
      {
LABEL_25:
        v21 = (const CMatrix *)*((_DWORD *)v16.m_pVoid + 5);
        if ( !v21 )
        {
          CPlaceable::AllocateMatrix((CPlaceable *)v16.m_pVoid);
          CSimpleTransform::UpdateMatrix(
            (const CSimpleTransform *)((char *)v16.m_pVoid + 4),
            *((CMatrix **)v16.m_pVoid + 5));
          v21 = (const CMatrix *)*((_DWORD *)v16.m_pVoid + 5);
        }
        v22 = CCollision::ProcessColModels(v10, colModelA, v21, v20, CWorld::m_aTempColPts, 0, 0, 0);
        if ( v22 <= 0 )
          goto LABEL_15;
        if ( (*((_BYTE *)v16.m_pVoid + 58) & 7) == 3 )
        {
          v23 = *((_DWORD *)v16.m_pVoid + 5);
          v24 = (float *)((char *)v16.m_pVoid + 4);
          m_pMat = this->m_pMat;
          v26 = (float *)((char *)v16.m_pVoid + 4);
          if ( v23 )
            v26 = (float *)(v23 + 48);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &this->m_transform;
          v28 = p_tx->m_translate.x - *v26;
          v29 = p_tx->m_translate.y - v26[1];
          v71.y = v29;
          v71.x = v28;
          v30 = (float)(v28 * v28) + (float)(v29 * v29);
          if ( v30 <= 0.0 )
          {
            v71.x = 1.0;
          }
          else
          {
            v31 = 1.0 / sqrtf(v30);
            v71.y = v29 * v31;
            v71.x = v28 * v31;
          }
          LocalDirection = CPed::GetLocalDirection((CPed *)v16.m_pVoid, &v71);
          if ( !*((_DWORD *)v16.m_pVoid + 64) )
          {
            v75.z = 5.0;
            *((_DWORD *)v16.m_pVoid + 289) &= ~1u;
            v75.x = v71.x * -5.0;
            v75.y = v71.y * -5.0;
            CPhysical::ApplyMoveForce((CPhysical *)v16.m_pVoid, v75);
          }
          CPedDamageResponseCalculator::CPedDamageResponseCalculator(
            &pos,
            this,
            1000.0,
            WEAPONTYPE_RUNOVERBYCAR,
            PED_SPHERE_CHEST,
            0);
          CEventDamage::CEventDamage(
            &v2,
            this,
            CTimer::m_snTimeInMilliseconds,
            WEAPONTYPE_RUNOVERBYCAR,
            PED_SPHERE_CHEST,
            LocalDirection,
            0,
            0);
          if ( CEventDamage::AffectsPed(v58, (CPed *)v16.m_pVoid) )
            CPedDamageResponseCalculator::ComputeDamageResponse(&pos, (CPed *)v16.m_pVoid, &v2.m_pedDamageResponse, 1);
          else
            v2.m_pedDamageResponse.m_bDamageCalculated = 1;
          CEventGroup::Add((CEventGroup *)(*((_DWORD *)v16.m_pVoid + 272) + 104), (CEvent *)&v2, 0);
          if ( CLocalisation::Blood() )
          {
            v68.z = 0.01;
            v68.x = v71.x * 0.01;
            v68.y = v71.y * 0.01;
            v59 = *((_DWORD *)v16.m_pVoid + 5);
            if ( v59 )
              v24 = (float *)(v59 + 48);
            v60 = v24[2];
            *(_QWORD *)&fImpulseMagnitude.x = *(_QWORD *)v24;
            fImpulseMagnitude.x = fImpulseMagnitude.x + (float)(v71.x * 0.35);
            fImpulseMagnitude.y = fImpulseMagnitude.y + (float)(v71.y * 0.35);
            fImpulseMagnitude.z = v60 + 0.6;
            if ( CEntity::GetIsOnScreen((CEntity *)v16.m_pVoid) )
              Fx_c::AddBlood(&g_fx, &fImpulseMagnitude, &v68, 16, *((float *)v16.m_pVoid + 76));
          }
          CEventDamage::~CEventDamage(&v2);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&pos);
          v10 = v65;
          if ( !m_pHead )
            return 0;
        }
        else
        {
          if ( *((_WORD *)v16.m_pVoid + 19) == 345 )
            goto LABEL_15;
          v32 = 0;
          v33 = 0;
          fImpulseMagnitude.x = 0.0;
          m_fElasticity = this->m_fElasticity;
          this->m_fElasticity = 1.0;
          v34 = 0;
          do
          {
            v35 = &CWorld::m_aTempColPts[v32];
            z = v35->m_vecPosition.z;
            *(_QWORD *)&pos.m_pInflictor = *(_QWORD *)&v35->m_vecPosition.x;
            *(float *)&pos.m_eHitZone = z;
            v37.n64_f32[1] = z - v72.z;
            v38 = (float)((float)(xx * (float)(*(float *)&pos.m_pInflictor - v72.x))
                        + (float)(yx * (float)(pos.m_fRawDamage - v72.y)))
                + (float)(zx * (float)(z - v72.z));
            v39 = fabsf(v38);
            if ( v39 <= (float)(ROTOR_SEMI_THICKNESS + ROTOR_SEMI_THICKNESS)
              || (v40 = &CWorld::m_aTempColPts[v32],
                  v37.n64_f32[1] = v37.n64_f32[1] * v40->m_vecNormal.z,
                  v39 <= (float)(fabsf(
                                   (float)((float)((float)(*(float *)&pos.m_pInflictor - v72.x) * v40->m_vecNormal.x)
                                         + (float)((float)(pos.m_fRawDamage - v72.y) * v40->m_vecNormal.y))
                                 + v37.n64_f32[1])
                               * 0.3)) )
            {
              pos.m_fRawDamage = pos.m_fRawDamage - (float)(yx * v38);
              *(float *)&pos.m_eHitZone = z - (float)(zx * v38);
              *(float *)&pos.m_pInflictor = *(float *)&pos.m_pInflictor - (float)(xx * v38);
              *(float *)&v2.m_iAccumulatedTime = pos.m_fRawDamage - v72.y;
              *(float *)&v2.m_bIsPersistent = *(float *)&pos.m_eHitZone - v72.z;
              *(float *)&v2._vptr$CEvent = *(float *)&pos.m_pInflictor - v72.x;
              CrossProduct(&v68, &v, (const CVector *)&v2);
              *(RwReal *)&v2.m_bIsPersistent = v68.z;
              *(_QWORD *)&v2._vptr$CEvent = *(_QWORD *)&v68.x;
              v41 = v68.y + this->m_vecMoveSpeed.y;
              v42 = v68.z + this->m_vecMoveSpeed.z;
              v68.x = v68.x + this->m_vecMoveSpeed.x;
              v68.y = v41;
              v68.z = v42;
              v43 = CVector::NormaliseAndMag(&v68);
              memset((char *)&aColPoints + 4, 0, 12);
              Fx_c::AddSparks(
                &g_fx,
                (CVector *)&pos,
                &v68,
                v43 * 15.0,
                16,
                *(CVector *)((char *)&aColPoints + 4),
                1,
                0.2,
                1.0);
              if ( !this->m_baseVehicleType )
              {
                m_ReverseSoundPtr = this[1].m_VehicleAudioEntity.m_ReverseSoundPtr;
                if ( *(float *)&m_ReverseSoundPtr > 0.15 )
                {
                  CPhysical::ApplySoftCollision(this, (CEntity *)v16.m_pVoid, v35, &fImpulseMagnitude.x);
                  v45 = this->m_fTurnMass * -0.0005;
                  v74.x = *(float *)&v2._vptr$CEvent * v45;
                  v74.y = v45 * *(float *)&v2.m_iAccumulatedTime;
                  v74.z = v45 * *(float *)&v2.m_bIsPersistent;
                  *(float *)&aColPoints = *(float *)&pos.m_pInflictor - v72.x;
                  *((float *)&aColPoints + 1) = pos.m_fRawDamage - v72.y;
                  *((float *)&aColPoints + 2) = *(float *)&pos.m_eHitZone - v72.z;
                  CPhysical::ApplyTurnForce(this, v74, (CVector)aColPoints);
                  v46 = 0.15;
                  goto LABEL_45;
                }
                if ( *(float *)&m_ReverseSoundPtr < 0.075 && *(float *)&m_ReverseSoundPtr > 0.0 )
                {
                  v46 = -*(float *)&m_ReverseSoundPtr;
LABEL_45:
                  *(float *)&this[1].m_VehicleAudioEntity.m_ReverseSoundPtr = v46;
                }
              }
              v37.n64_u32[0] = LODWORD(fImpulseMagnitude.x);
              v47.n64_f32[0] = (float)(this->m_fMass * 100.0) / 3000.0;
              v47.n64_f32[1] = zx * v38;
              CPhysical::SetDamagedPieceRecord(
                this,
                vmax_f32(v47, v37).n64_f32[0] * fImpactMult,
                (CEntity *)v16.m_pVoid,
                v35,
                1.0);
              v34 = 1;
            }
            v32 = (__int16)++v33;
          }
          while ( v22 > (__int16)v33 );
          v49 = v34 << 24;
          v48 = v49 == 0;
          v10 = v65;
          if ( v49 )
            v48 = (*((_BYTE *)v16.m_pVoid + 58) & 7) == 3;
          if ( !v48
            && (CTimer::m_snTimeInMilliseconds > ROTOR_LAST_COL_TIME
             || CTimer::m_snTimeInMilliseconds < ROTOR_LAST_COL_TIME - 2000) )
          {
            m_info = (unsigned __int8)this->m_info;
            if ( m_info >> 3 == 8 )
            {
              CAudioEngine::ReportCollision(
                &AudioEngine,
                this,
                (CEntity *)v16.m_pVoid,
                0x40u,
                63,
                (CVector *)&pos,
                0,
                0.15,
                1.0,
                0,
                0);
            }
            else if ( !(m_info >> 3) )
            {
              GameCamPosition = CCamera::GetGameCamPosition(&TheCamera);
              v52 = GameCamPosition->z;
              v53 = *(float *)&pos.m_pInflictor - GameCamPosition->x;
              pos.m_fRawDamage = pos.m_fRawDamage - GameCamPosition->y;
              *(float *)&pos.m_eHitZone = *(float *)&pos.m_eHitZone - v52;
              *(float *)&pos.m_pInflictor = v53;
              CVector::Normalise((CVector *)&pos);
              v54 = CCamera::GetGameCamPosition(&TheCamera);
              v55 = (float)(pos.m_fRawDamage * 4.0) + v54->y;
              v56 = (float)(*(float *)&pos.m_pInflictor * 4.0) + v54->x;
              *(float *)&pos.m_eHitZone = (float)(*(float *)&pos.m_eHitZone * 4.0) + v54->z;
              *(float *)&pos.m_pInflictor = v56;
              pos.m_fRawDamage = v55;
              CAudioEngine::ReportCollision(
                &AudioEngine,
                this,
                (CEntity *)v16.m_pVoid,
                0x40u,
                63,
                (CVector *)&pos,
                0,
                0.15,
                1.0,
                0,
                0);
            }
            v61 = CTimer::m_snTimeInMilliseconds;
            ROTOR_LAST_COL_TIME = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
                                + v61
                                + 150;
          }
          this->m_fElasticity = m_fElasticity;
          if ( !m_pHead )
            return 0;
        }
      }
      else
      {
LABEL_15:
        if ( !m_pHead )
          return 0;
      }
    }
    if ( !v19 || *((_BYTE *)v16.m_pVoid + 320) == 3 )
      goto LABEL_15;
    goto LABEL_25;
  }
  return 0;
}
// 588234: variable 'xx' is possibly undefined
// 588238: variable 'yx' is possibly undefined
// 58823C: variable 'zx' is possibly undefined
// 5885AC: variable 'v58' is possibly undefined

//----- (0058873C) --------------------------------------------------------
RwObject_0 *__fastcall SetVehicleAtomicVisibilityCB(RwObject_0 *pObject, void *data)
{
  char AtomicId; // r0
  RwUInt8 v5; // r1

  if ( (CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)pObject) & 3) != 0 )
  {
    AtomicId = CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)pObject);
    v5 = 0;
    if ( (void *)(AtomicId & 3) == data )
      v5 = 4;
    pObject->flags = v5;
  }
  return pObject;
}

//----- (00588768) --------------------------------------------------------
RwFrame_0 *__fastcall SetVehicleAtomicVisibilityCB(RwFrame_0 *pFrame, void *data)
{
  RwFrameForAllObjects(pFrame, SetVehicleAtomicVisibilityCB, data);
  RwFrameForAllChildren(pFrame, SetVehicleAtomicVisibilityCB, data);
  return pFrame;
}

//----- (00588798) --------------------------------------------------------
void __fastcall CVehicle::SetComponentVisibility(CVehicle *this, RwFrame_0 *pFrame, uint32 flag)
{
  if ( pFrame )
  {
    if ( flag == 2 )
      *(_DWORD *)&this->m_nVehicleFlags |= 0x10000u;
    RwFrameForAllObjects(pFrame, SetVehicleAtomicVisibilityCB, (void *)flag);
    sub_19706C(pFrame, SetVehicleAtomicVisibilityCB, (void *)flag);
  }
}

//----- (005887E0) --------------------------------------------------------
void __fastcall CVehicle::SetComponentRotation(CVehicle *this, RwFrame_0 *pFrame, int32 nAxis, float fAngle, int a5)
{
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix v10; // [sp+0h] [bp-70h] BYREF

  if ( pFrame )
  {
    v10.m_pRwMat = 0;
    v10.m_owner = 0;
    CMatrix::Attach(&v10, &pFrame->modelling, 0);
    tx = v10.tx;
    ty = v10.ty;
    tz = v10.tz;
    if ( a5 == 1 )
    {
      if ( nAxis )
      {
        if ( nAxis == 1 )
        {
          CMatrix::SetRotateY(&v10, fAngle);
        }
        else if ( nAxis == 2 )
        {
          CMatrix::SetRotateZ(&v10, fAngle);
        }
      }
      else
      {
        CMatrix::SetRotateX(&v10, fAngle);
      }
    }
    else
    {
      memset(&v10.tx, 0, 12);
      if ( nAxis )
      {
        if ( nAxis == 1 )
        {
          CMatrix::RotateY(&v10, fAngle);
        }
        else if ( nAxis == 2 )
        {
          CMatrix::RotateZ(&v10, fAngle);
        }
      }
      else
      {
        CMatrix::RotateX(&v10, fAngle);
      }
    }
    v10.tx = tx + v10.tx;
    v10.ty = ty + v10.ty;
    v10.tz = tz + v10.tz;
    CMatrix::UpdateRW(&v10);
    CMatrix::~CMatrix(&v10);
  }
}

//----- (005888AC) --------------------------------------------------------
void __fastcall CVehicle::SetTransmissionRotation(
        CVehicle *this,
        RwFrame_0 *pFrame,
        float fHeightLeft,
        float fHeightRight,
        int a5,
        float a6,
        float a7,
        int a8)
{
  __int64 v8; // d8
  __int64 v9; // d9
  __int64 v10; // d10
  __int64 v11; // d11
  __int64 v12; // d12
  float ty; // s22
  float tx; // s20
  float tz; // s24
  float v18; // r0
  float v19; // s0
  float v20; // s0
  float v21; // r6
  CMatrix v22; // [sp+0h] [bp-90h] BYREF
  __int64 v23; // [sp+48h] [bp-48h]
  __int64 v24; // [sp+50h] [bp-40h]
  __int64 v25; // [sp+58h] [bp-38h]
  __int64 v26; // [sp+60h] [bp-30h]
  __int64 v27; // [sp+68h] [bp-28h]

  if ( pFrame )
  {
    v23 = v8;
    v24 = v9;
    v25 = v10;
    v26 = v11;
    v27 = v12;
    v22.m_pRwMat = 0;
    v22.m_owner = 0;
    CMatrix::Attach(&v22, &pFrame->modelling, 0);
    ty = v22.ty;
    tx = v22.tx;
    tz = v22.tz;
    v18 = atan2f((float)((float)(fHeightLeft + fHeightRight) * 0.5) - a7, v22.ty - a6);
    v19 = -0.0;
    if ( a8 )
      v19 = 3.1416;
    v20 = v19 - v18;
    v21 = atan2f(fHeightLeft - fHeightRight, COERCE_FLOAT(a5 & 0x7FFFFFFF) + COERCE_FLOAT(a5 & 0x7FFFFFFF));
    CMatrix::SetRotateX(&v22, v20);
    CMatrix::RotateY(&v22, v21);
    v22.tx = tx + v22.tx;
    v22.ty = ty + v22.ty;
    v22.tz = tz + v22.tz;
    CMatrix::UpdateRW(&v22);
    CMatrix::~CMatrix(&v22);
  }
}
// 5888BA: variable 'v8' is possibly undefined
// 5888BA: variable 'v9' is possibly undefined
// 5888BA: variable 'v10' is possibly undefined
// 5888BA: variable 'v11' is possibly undefined
// 5888BA: variable 'v12' is possibly undefined

//----- (005889B0) --------------------------------------------------------
void __fastcall CVehicle::ProcessBoatControl(
        CVehicle *this,
        tBoatHandlingData *pBoatHandling,
        float *fPrevVolume,
        int bBoatHasHitWall,
        int bBoatGrounded)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  float32x2_t v8; // d3
  float32x2_t v9; // d4
  float32x2_t v10; // d10
  float32x2_t v11; // d12
  CVehicle *v13; // r11
  int32 m_vehicleType; // r4
  _BOOL4 v16; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  CMatrix *m_pMat; // r1
  CPed *pDriver; // r0
  int v20; // r10
  char v21; // r4
  int m_nVehicleFlags; // r1
  unsigned int v23; // r0
  RwReal v24; // r4
  RwReal y; // r5
  RwReal z; // r8
  float VolumeUnderWater; // s16
  int m_nModelIndex; // r0
  float *p_m_f2ndSteerAngle; // r8
  CMatrix *v30; // r5
  float zy; // s0
  float v32; // s4
  float v33; // s2
  float v34; // s2
  CMatrix *v35; // r0
  float xy; // s6
  float yy; // s8
  float v38; // s10
  float v39; // s0
  float v40; // s0
  float v41; // s0
  float m_fMass; // s6
  int v43; // r4
  CMatrix *v44; // r1
  float zz; // s0
  float m_fGasPedal; // s6
  float xz; // s8
  unsigned int v48; // r5
  unsigned int v49; // r8
  CMatrix *v50; // r0
  float fAquaplaneOffsetY; // s0
  CPed *v52; // r0
  CPad *PadFromPlayer; // r10
  CMatrix *v54; // r0
  float v55; // s0
  CSimpleTransform *p_m_transform; // r1
  RwReal v57; // r4
  RwReal v58; // r5
  RwReal v59; // r8
  float v60; // s18
  float v61; // s20
  float v62; // s18
  CColModel *ColModel; // r0
  __int64 v64; // d16
  float fThrustOffsetZ; // s4
  float *p_m_fSteerAngle; // r8
  CMatrix *v67; // r0
  CSimpleTransform *p_tx; // r1
  float v69; // s22
  float v70; // s20
  float v71; // r4
  float v72; // r0
  float v73; // s0
  float v74; // s22
  float v75; // s0
  float v76; // s24
  float v77; // s28
  CMatrix *v78; // r1
  float v79; // s2
  int v80; // r4
  float m_fEngineAcceleration; // s8
  float v82; // s10
  float v83; // s2
  float v84; // s4
  float v85; // s6
  float v86; // s26
  float v87; // s28
  float v88; // s0
  CMatrix *v89; // r0
  float fThrustAppOffsetZ; // s6
  CMatrix *v91; // r0
  float yx; // s2
  float zx; // s4
  float v94; // s6
  CMatrix *v95; // r1
  float v96; // s0
  float v97; // s2
  float v98; // s24
  float v99; // s2
  float v100; // s4
  float v101; // s26
  float v102; // s28
  float v103; // s30
  float v104; // s26
  CMatrix *v105; // r0
  CMatrix *v106; // r0
  float v107; // s0
  int v108; // s2
  RwReal v109; // s8
  unsigned int v110; // s10
  unsigned int v111; // s0
  CMatrix *v112; // r0
  float v113; // s0
  float v114; // s2
  float v115; // s4
  float v116; // s6
  float v117; // s6
  __int64 v118; // r0
  bool v119; // zf
  int v120; // r10
  __int64 v121; // kr00_8
  float v122; // r8
  float v123; // r0
  __int64 v124; // d16
  float v125; // s18
  float v126; // r0
  float v127; // s20
  RwReal v128; // s2
  __int64 v129; // d16
  CMatrix *v130; // r4
  float m_fTurnMass; // s18
  float v132; // s22
  float yz; // s24
  float v134; // s26
  float v135; // s0
  int v136; // s0
  int v137; // r8
  float v138; // s18
  float v139; // s0
  float v140; // s0
  float v141; // s2
  float v142; // s4
  CMatrix *v143; // r0
  float v144; // s14
  float v145; // s1
  float v146; // s3
  tHandlingData *pHandling; // r0
  float fBrakeDeceleration; // s5
  float v149; // s8
  float32x2_t v150; // d3
  float v151; // s0
  float v152; // s12
  float v153; // s4
  float v154; // s2
  float v155; // s10
  float v156; // s0
  float v157; // s2
  float v158; // s0
  float v159; // s6
  RwReal v160; // s2
  RwReal v161; // s0
  __int64 v162; // d16
  const CEventDamage *v163; // r0
  CVector pBuoyancyForce; // [sp+0h] [bp-100h]
  CVector pBuoyancyForcea; // [sp+0h] [bp-100h]
  CVector pBuoyancyForceb; // [sp+0h] [bp-100h]
  CVector pBuoyancyForcec; // [sp+0h] [bp-100h]
  CVector pBuoyancyForced; // [sp+0h] [bp-100h]
  float *x; // [sp+10h] [bp-F0h]
  float xa; // [sp+10h] [bp-F0h]
  int v172; // [sp+18h] [bp-E8h]
  CVector v174; // [sp+20h] [bp-E0h] BYREF
  float pWaterZ; // [sp+2Ch] [bp-D4h] BYREF
  CEventDamage v; // [sp+30h] [bp-D0h] BYREF
  CPedDamageResponseCalculator v2; // [sp+70h] [bp-90h] BYREF
  CVector v178; // [sp+88h] [bp-78h] BYREF
  CVector pCentreOfBuoyancy; // [sp+94h] [bp-6Ch] BYREF
  CVector v180; // 0:r1.12
  CVector v181; // 0:r1.12
  CVector v182; // 0:r1.12
  CVector v183; // 0:r1.12
  CVector v184; // 0:r1.12
  CVector v185; // 0:r1.12
  CVector v186; // 0:r1.12
  CVector v187; // 0:r1.12
  CVector v188; // 0:r1.12
  CVector v189; // 0:r1.12
  CVector v190; // 0:r1.12
  CVector v191; // 0:r1.12
  CVector v192; // 0:r1.12
  CVector v193; // 0:r1.12
  CVector v194; // 0:r1.12
  CVector v195; // 0:r1.12
  CVector v196; // 0:r1.12
  CVector v197; // 0:r1.12
  CVector v198; // 0:r1.12

  v13 = 0;
  memset(&v178, 0, sizeof(v178));
  memset(&pCentreOfBuoyancy, 0, sizeof(pCentreOfBuoyancy));
  m_vehicleType = this->m_vehicleType;
  v16 = cBuoyancy::ProcessBuoyancyBoat(
          &mod_Buoyancy,
          this,
          this->m_fBuoyancyConstant,
          &pCentreOfBuoyancy,
          &v178,
          bBoatHasHitWall);
  if ( m_vehicleType == 5 )
    v13 = this;
  if ( !v16 )
  {
    v21 = 0;
    *(_DWORD *)&this->m_nPhysicalFlags &= ~0x100u;
    goto LABEL_142;
  }
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  if ( v178.z <= (float)(CTimer::ms_fTimeStep * (float)((float)(this->m_fMass * 0.1) * 0.008)) )
  {
    m_nVehicleFlags = (int)this->m_nVehicleFlags;
    v20 = 0;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xFFFFFEFF);
    v23 = m_nVehicleFlags & 0xBFFFFFFF;
  }
  else
  {
    m_pMat = this->m_pMat;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x100);
    if ( m_pMat->zz < -0.6 && fabsf(this->m_vecMoveSpeed.x) < 0.05 && fabsf(this->m_vecMoveSpeed.y) < 0.05 )
    {
      pDriver = this->pDriver;
      *(_DWORD *)&this->m_nVehicleFlags |= 0x40000000u;
      if ( pDriver )
      {
        *(_DWORD *)&pDriver->m_nPhysicalFlags |= 0x8000000u;
        if ( CPed::IsPlayer(this->pDriver) )
        {
          v20 = 1;
          CPlayerPed::HandlePlayerBreath((CPlayerPed *)this->pDriver, 1, 1.0);
        }
        else
        {
          CPedDamageResponseCalculator::CPedDamageResponseCalculator(
            &v2,
            this,
            CTimer::ms_fTimeStep,
            WEAPONTYPE_DROWNING,
            PED_SPHERE_CHEST,
            0);
          CEventDamage::CEventDamage(
            &v,
            this,
            CTimer::m_snTimeInMilliseconds,
            WEAPONTYPE_DROWNING,
            PED_SPHERE_CHEST,
            0,
            0,
            1);
          if ( CEventDamage::AffectsPed(v163, this->pDriver) )
            CPedDamageResponseCalculator::ComputeDamageResponse(&v2, this->pDriver, &v.m_pedDamageResponse, 1);
          else
            v.m_pedDamageResponse.m_bDamageCalculated = 1;
          CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v, 0);
          CEventDamage::~CEventDamage(&v);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v2);
          v20 = 1;
        }
      }
      else
      {
        v20 = 1;
      }
      goto LABEL_15;
    }
    v20 = 1;
    v23 = *(_DWORD *)&this->m_nVehicleFlags & 0xBFFFFFFF;
  }
  *(_DWORD *)&this->m_nVehicleFlags = v23;
LABEL_15:
  v24 = pCentreOfBuoyancy.x;
  y = pCentreOfBuoyancy.y;
  z = pCentreOfBuoyancy.z;
  VolumeUnderWater = mod_Buoyancy.VolumeUnderWater;
  if ( this->m_nModelIndex == 460
    && this->m_pMat->zz < -0.5
    && fabsf(this->m_vecMoveSpeed.x) < 0.2
    && fabsf(this->m_vecMoveSpeed.y) < 0.2 )
  {
    v180.x = v178.x * 0.03;
    v180.y = v178.y * 0.03;
    v180.z = v178.z * 0.03;
  }
  else
  {
    v180 = v178;
  }
  CPhysical::ApplyMoveForce(this, v180);
  if ( bBoatHasHitWall == 1 )
  {
    pBuoyancyForce.x = v24;
    *(_QWORD *)&pBuoyancyForce.y = __PAIR64__(LODWORD(z), LODWORD(y));
    v181.x = v178.x * 0.4;
    v181.y = v178.y * 0.4;
    v181.z = v178.z * 0.4;
    CPhysical::ApplyTurnForce(this, v181, pBuoyancyForce);
  }
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( m_nModelIndex == 460 )
  {
    p_m_f2ndSteerAngle = &this->m_f2ndSteerAngle;
    v30 = this->m_pMat;
    zy = v30->zy;
    if ( this->m_f2ndSteerAngle != 0.0 )
    {
      v32 = v178.z;
      v33 = CTimer::ms_fTimeStep;
      goto LABEL_26;
    }
    if ( zy < -0.5 && v30->zz > -0.5 && this->m_vecMoveSpeed.z < -0.15 )
    {
      m_fMass = this->m_fMass;
      v33 = CTimer::ms_fTimeStep;
      v32 = v178.z;
      if ( v178.z > (float)(CTimer::ms_fTimeStep * (float)((float)(m_fMass * 0.01) * 0.008))
        && v178.z < (float)(CTimer::ms_fTimeStep * (float)((float)(m_fMass * 0.4) * 0.008)) )
      {
LABEL_26:
        v34 = (float)((float)((float)(zy * -0.00017) * v32) * this->m_fTurnMass) * v33;
        v182.x = v30->xy * v34;
        v182.y = v34 * v30->yy;
        v182.z = zy * v34;
        CPhysical::ApplyTurnForce(this, v182, *(CVector *)&v30->xz);
        v35 = this->m_pMat;
        xy = v35->xy;
        yy = v35->yy;
        v38 = v35->zy;
        v39 = this->m_fMass
            * (float)((float)((float)((float)(this->m_vecMoveSpeed.x * xy) + (float)(this->m_vecMoveSpeed.y * yy))
                            + (float)(this->m_vecMoveSpeed.z * v38))
                    * -0.5);
        v183.x = xy * v39;
        v183.y = yy * v39;
        v183.z = v38 * v39;
        CPhysical::ApplyMoveForce(this, v183);
        v40 = (float)CTimer::m_snTimeInMilliseconds;
        if ( *p_m_f2ndSteerAngle == 0.0 )
        {
          v41 = v40 + 300.0;
        }
        else
        {
          if ( *p_m_f2ndSteerAngle >= v40 )
          {
LABEL_42:
            v20 = 0;
            v43 = 1;
            goto LABEL_48;
          }
          v41 = 0.0;
        }
        *p_m_f2ndSteerAngle = v41;
        goto LABEL_42;
      }
    }
  }
  v43 = 0;
  if ( v20 )
  {
    if ( bBoatGrounded )
      goto LABEL_48;
    v44 = this->m_pMat;
    zz = v44->zz;
    if ( zz <= 0.0 )
    {
LABEL_47:
      v43 = 0;
      goto LABEL_48;
    }
    m_fGasPedal = this->m_fGasPedal;
    if ( m_nModelIndex == 460 )
    {
      m_fGasPedal = m_fGasPedal + 1.0;
    }
    else if ( m_fGasPedal <= 0.05 )
    {
      v7.n64_u32[0] = 0;
      goto LABEL_46;
    }
    v7.n64_f32[0] = m_fGasPedal
                  * (float)((float)(CTimer::ms_fTimeStep
                                  * (float)((float)(pBoatHandling->fAquaplaneForce * v178.z)
                                          * (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                                          + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                                                  + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z))))
                          * 0.5);
LABEL_46:
    xz = v44->xz;
    v6.n64_f32[0] = (float)((float)(pBoatHandling->fAquaplaneLimit * 0.008) * this->m_fMass) * CTimer::ms_fTimeStep;
    v6.n64_u64[0] = vmin_f32(v7, v6).n64_u64[0];
    *(float *)&v48 = v44->yz * v6.n64_f32[0];
    *(float *)&v49 = v6.n64_f32[0] * zz;
    v184.x = xz * v6.n64_f32[0];
    v184.y = *(float *)&v48;
    v184.z = v6.n64_f32[0] * zz;
    CPhysical::ApplyMoveForce(this, v184);
    v50 = this->m_pMat;
    v185.x = xz * v6.n64_f32[0];
    fAquaplaneOffsetY = pBoatHandling->fAquaplaneOffsetY;
    *(_QWORD *)&v185.y = __PAIR64__(v49, v48);
    pBuoyancyForcea.x = pCentreOfBuoyancy.x - (float)(fAquaplaneOffsetY * v50->xy);
    pBuoyancyForcea.y = pCentreOfBuoyancy.y - (float)(fAquaplaneOffsetY * v50->yy);
    pBuoyancyForcea.z = pCentreOfBuoyancy.z - (float)(fAquaplaneOffsetY * v50->zy);
    CPhysical::ApplyTurnForce(this, v185, pBuoyancyForcea);
    goto LABEL_47;
  }
  v43 = 1;
LABEL_48:
  v172 = v20;
  if ( *(_BYTE *)&this->m_info <= 7u && (v52 = this->pDriver) != 0 && CPed::IsPlayer(v52) )
    PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
  else
    PadFromPlayer = 0;
  v54 = this->m_pMat;
  if ( v54->zz > -0.6 )
  {
    x = &this->m_fGasPedal;
    if ( fabsf(this->m_fGasPedal) > 0.05 )
    {
      v55 = 1.0;
      if ( !v13 )
        goto LABEL_64;
      goto LABEL_59;
    }
    v55 = sqrtf(
            (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
          + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y));
    if ( v55 > 0.01 )
    {
      if ( !v13 )
      {
LABEL_64:
        if ( *(_BYTE *)&this->m_info > 7u )
        {
          v62 = 1.0;
        }
        else
        {
          v60 = this->pHandling->fTractionBias
              * (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_pMat->xy)
                              + (float)(this->m_vecMoveSpeed.y * this->m_pMat->yy))
                      + (float)(this->m_vecMoveSpeed.z * this->m_pMat->zy));
          v61 = v60 * 0.5;
          if ( !CPad::GetHandBrake(PadFromPlayer) )
            v61 = v60;
          v62 = 1.0 - v61;
          if ( (float)(1.0 - v61) >= 0.0 )
          {
            if ( v62 > 1.0 )
              v62 = 1.0;
          }
          else
          {
            v62 = 0.0;
          }
        }
        ColModel = CEntity::GetColModel(this);
        v64 = *(_QWORD *)&ColModel->m_boxBound.m_vecMin.x;
        *(RwReal *)&v.m_bIsPersistent = ColModel->m_boxBound.m_vecMin.z;
        v.m_iAccumulatedTime = HIDWORD(v64);
        v._vptr$CEvent = 0;
        fThrustOffsetZ = pBoatHandling->fThrustOffsetZ;
        *(float *)&v.m_iAccumulatedTime = pBoatHandling->fThrustOffsetY * *((float *)&v64 + 1);
        *(float *)&v.m_bIsPersistent = fThrustOffsetZ * *(float *)&v.m_bIsPersistent;
        Multiply3x3((CVector *)&v2, this->m_pMat, (const CVector *)&v);
        p_m_fSteerAngle = &this->m_fSteerAngle;
        *(_DWORD *)&v.m_bIsPersistent = v2.m_eHitZone;
        *(_QWORD *)&v._vptr$CEvent = *(_QWORD *)&v2.m_pInflictor;
        v67 = this->m_pMat;
        p_tx = (CSimpleTransform *)&v67->tx;
        if ( !v67 )
          p_tx = &this->m_transform;
        v69 = *p_m_fSteerAngle;
        v70 = p_tx->m_translate.z + *(float *)&v2.m_eHitZone;
        CWaterLevel::GetWaterLevel(
          p_tx->m_translate.x + *(float *)&v2.m_pInflictor,
          p_tx->m_translate.y + v2.m_fRawDamage,
          v70,
          &pWaterZ,
          1,
          0);
        v71 = sinf(-(float)(v62 * v69));
        v72 = cosf(v62 * v69);
        if ( pWaterZ <= (float)(v70 + -0.5) )
        {
          if ( v13 )
            LOBYTE(v13[1].m_transform.m_translate.z) &= ~2u;
        }
        else
        {
          v73 = pWaterZ - v70;
          v10.n64_u32[0] = 1008981770;
          v74 = v71;
          v75 = v73 + 0.5;
          v76 = v75 * v75;
          if ( v75 > 1.0 )
            v76 = 1.0;
          pWaterZ = v76;
          if ( v13 )
            LOBYTE(v13[1].m_transform.m_translate.z) |= 2u;
          v77 = fabsf(*x);
          if ( v77 <= 0.01 || this->m_nModelIndex == 460 )
            goto LABEL_99;
          v78 = this->m_pMat;
          v79 = fabsf(*p_m_fSteerAngle);
          v174.y = v72;
          v174.x = -v71;
          v174.z = -v79;
          Multiply3x3((CVector *)&v2, v78, &v174);
          v80 = 0;
          m_fEngineAcceleration = this->pHandling->Transmission.m_fEngineAcceleration;
          v82 = (float)((float)((float)(v76 * *(float *)&v2.m_eHitZone) * *x) * 40.0) * m_fEngineAcceleration;
          v83 = (float)((float)((float)(v76 * v2.m_fRawDamage) * *x) * 40.0) * m_fEngineAcceleration;
          v84 = (float)((float)((float)(v76 * *(float *)&v2.m_pInflictor) * *x) * 40.0) * m_fEngineAcceleration;
          v85 = this->m_fMass;
          if ( v77 < 0.5 )
            v80 = 1;
          v11.n64_f32[0] = v82 * v85;
          v86 = v83 * v85;
          v87 = v84 * v85;
          if ( (float)(v82 * v85) > 0.2 )
            v11.n64_f32[0] = (float)((float)(1.2 - v11.n64_f32[0]) * (float)(1.2 - v11.n64_f32[0])) + 0.2;
          if ( bBoatGrounded )
          {
            v5.n64_u32[0] = 0;
            LODWORD(v88) = vmax_f32(v11, v5).n64_u32[0];
            if ( *x < 0.0 )
            {
              v87 = v87 * 5.0;
              v86 = v86 * 5.0;
            }
            v187.z = v88 * CTimer::ms_fTimeStep;
            v187.x = CTimer::ms_fTimeStep * v87;
            v187.y = CTimer::ms_fTimeStep * v86;
            CPhysical::ApplyMoveForce(this, v187);
          }
          else
          {
            v188.x = v87 * CTimer::ms_fTimeStep;
            v188.y = v86 * CTimer::ms_fTimeStep;
            v188.z = v11.n64_f32[0] * CTimer::ms_fTimeStep;
            CPhysical::ApplyMoveForce(this, v188);
            v89 = this->m_pMat;
            fThrustAppOffsetZ = pBoatHandling->fThrustAppOffsetZ;
            v189.y = v86 * CTimer::ms_fTimeStep;
            v189.x = v87 * CTimer::ms_fTimeStep;
            v189.z = v11.n64_f32[0] * CTimer::ms_fTimeStep;
            pBuoyancyForceb.x = *(float *)&v._vptr$CEvent - (float)(fThrustAppOffsetZ * v89->xz);
            pBuoyancyForceb.y = *(float *)&v.m_iAccumulatedTime - (float)(fThrustAppOffsetZ * v89->yz);
            pBuoyancyForceb.z = *(float *)&v.m_bIsPersistent - (float)(fThrustAppOffsetZ * v89->zz);
            CPhysical::ApplyTurnForce(this, v189, pBuoyancyForceb);
            v91 = this->m_pMat;
            yx = v91->yx;
            zx = v91->zx;
            v94 = (float)((float)((float)(v87 * v91->xx) + (float)(v86 * yx)) + (float)(v11.n64_f32[0] * zx))
                * this->pHandling->fTractionMultiplier;
            v190.x = CTimer::ms_fTimeStep * (float)-(float)(v94 * v91->xx);
            v190.y = CTimer::ms_fTimeStep * (float)-(float)(v94 * yx);
            v190.z = CTimer::ms_fTimeStep * (float)-(float)(v94 * zx);
            CPhysical::ApplyTurnForce(this, v190, *(CVector *)&v91->xz);
          }
          if ( *x > 0.0 && *(_BYTE *)&this->m_info <= 7u )
          {
            v2.m_fRawDamage = CEntity::GetColModel(this)->m_boxBound.m_vecMin.y;
            v2.m_eHitZone = PED_COL_SPHERE_LEG;
            v2.m_pInflictor = 0;
            Multiply3x3(&v174, this->m_pMat, (const CVector *)&v2);
          }
          if ( v80 )
          {
LABEL_99:
            if ( !bBoatGrounded )
            {
              v95 = this->m_pMat;
              v8.n64_f32[0] = this->m_fTurnMass * 0.01;
              v96 = *x;
              v97 = fabsf(*x);
              v7.n64_f32[0] = this->pHandling->fTractionLoss
                            * (float)((float)((float)(this->m_vecMoveSpeed.x * v95->xy)
                                            + (float)(this->m_vecMoveSpeed.y * v95->yy))
                                    + (float)(this->m_vecMoveSpeed.z * v95->zy));
              LODWORD(v98) = vmin_f32(v7, v8).n64_u32[0];
              if ( v97 > 0.01 )
              {
                v99 = 0.55 - v97;
                if ( *(_BYTE *)&this->m_info <= 7u )
                  v100 = 2.6;
                else
                  v100 = 5.0;
                v98 = v98 * (float)(v99 * v100);
              }
              if ( v98 <= 0.0 || v96 >= 0.0 )
              {
                if ( v98 < 0.0 && v96 > 0.0 )
                  v98 = -v98;
              }
              else
              {
                v98 = -v98;
              }
              v101 = pWaterZ;
              v174.x = -(float)(v74 * v98);
              v174.y = v98 * 0.0;
              v174.z = v98 * 0.0;
              Multiply3x3((CVector *)&v2, v95, &v174);
              v102 = v101 * *(float *)&v2.m_pInflictor;
              v103 = v101 * v2.m_fRawDamage;
              v104 = v101 * *(float *)&v2.m_eHitZone;
              v191.x = v102 * CTimer::ms_fTimeStep;
              v191.y = v103 * CTimer::ms_fTimeStep;
              v191.z = v104 * CTimer::ms_fTimeStep;
              CPhysical::ApplyMoveForce(this, v191);
              *(_QWORD *)&pBuoyancyForcec.x = *(_QWORD *)&v._vptr$CEvent;
              pBuoyancyForcec.z = *(RwReal *)&v.m_bIsPersistent;
              v192.x = v102 * CTimer::ms_fTimeStep;
              v192.y = v103 * CTimer::ms_fTimeStep;
              v192.z = v104 * CTimer::ms_fTimeStep;
              CPhysical::ApplyTurnForce(this, v192, pBuoyancyForcec);
              v6.n64_f32[0] = CTimer::ms_fTimeStep;
              pWaterZ = (float)((float)((float)(v74 * v98) * -0.75) / v62) * vmax_f32(v6, v10).n64_f32[0];
              v105 = this->m_pMat;
              v193.x = v105->xx * pWaterZ;
              v193.y = pWaterZ * v105->yx;
              v193.z = pWaterZ * v105->zx;
              CPhysical::ApplyTurnForce(this, v193, *(CVector *)&v105->xz);
            }
          }
        }
        goto LABEL_112;
      }
LABEL_59:
      if ( (v43 ^ 1) == 1 && v55 > 0.05 )
      {
        p_m_transform = (CSimpleTransform *)&v54->tx;
        if ( !v54 )
          p_m_transform = &this->m_transform;
        v57 = p_m_transform->m_translate.x;
        v58 = p_m_transform->m_translate.y;
        v59 = p_m_transform->m_translate.z;
        CEntity::GetColModel(this);
        v186.x = v57;
        *(_QWORD *)&v186.y = __PAIR64__(LODWORD(v59), LODWORD(v58));
        CBoat::AddWakePoint((CBoat *)v13, v186);
      }
      goto LABEL_64;
    }
  }
LABEL_112:
  if ( this->pHandling->fSuspensionBias != 0.0 )
  {
    v106 = this->m_pMat;
    v2.m_pInflictor = 0;
    v2.m_fRawDamage = 0.0;
    v2.m_eHitZone = 1065353216;
    CrossProduct((CVector *)&v, (const CVector *)&v106->xy, (const CVector *)&v2);
    v107 = CTimer::ms_fTimeStep
         * (float)((float)((float)((float)(this->m_vecMoveSpeed.x * *(float *)&v._vptr$CEvent)
                                 + (float)(this->m_vecMoveSpeed.y * *(float *)&v.m_iAccumulatedTime))
                         + (float)(this->m_vecMoveSpeed.z * *(float *)&v.m_bIsPersistent))
                 * (float)(VolumeUnderWater * (float)((float)(this->pHandling->fSuspensionBias * -0.1) * this->m_fMass)));
    *(float *)&v108 = (float)(*(float *)&v._vptr$CEvent * 0.3) + *(float *)&v.m_iAccumulatedTime;
    v109 = (float)(*(float *)&v._vptr$CEvent - (float)(*(float *)&v.m_iAccumulatedTime * 0.3)) * v107;
    *(float *)&v110 = *(float *)&v108 * v107;
    *(float *)&v111 = (float)(*(float *)&v.m_bIsPersistent + 0.0) * v107;
    *(float *)&v.m_bIsPersistent = *(float *)&v.m_bIsPersistent + 0.0;
    *(float *)&v._vptr$CEvent = *(float *)&v._vptr$CEvent - (float)(*(float *)&v.m_iAccumulatedTime * 0.3);
    v.m_iAccumulatedTime = v108;
    v194.x = v109;
    *(_QWORD *)&v194.y = __PAIR64__(v111, v110);
    CPhysical::ApplyMoveForce(this, v194);
  }
  if ( *(_BYTE *)&this->m_info <= 7u )
  {
    if ( CPad::GetHandBrake(PadFromPlayer) )
    {
      v112 = this->m_pMat;
      v113 = v112->xy;
      v114 = v112->yy;
      v115 = v112->zy;
      v116 = (float)((float)(this->m_vecMoveSpeed.x * v113) + (float)(this->m_vecMoveSpeed.y * v114))
           + (float)(this->m_vecMoveSpeed.z * v115);
      if ( v116 > 0.0 )
      {
        v117 = CTimer::ms_fTimeStep
             * (float)(VolumeUnderWater
                     * (float)(this->m_fMass * (float)((float)(v116 * this->pHandling->fSuspensionLowerLimit) * -0.1)));
        v195.x = v113 * v117;
        v195.y = v114 * v117;
        v195.z = v115 * v117;
        CPhysical::ApplyMoveForce(this, v195);
      }
    }
  }
  LODWORD(v118) = 0;
  HIDWORD(v118) = bBoatGrounded;
  if ( !v172 )
    LODWORD(v118) = 1;
  v120 = v118 | bBoatGrounded;
  v119 = v118 == 0;
  if ( !v118 )
    v119 = bBoatHasHitWall == 0;
  if ( v119 )
    CVehicle::ApplyBoatWaterResistance(this, pBoatHandling, VolumeUnderWater);
  if ( (this->m_nModelIndex != 460 || this->m_f2ndSteerAngle == 0.0) && !bBoatHasHitWall )
  {
    xa = pBoatHandling->vecTurnResistance.x;
    v121 = *(_QWORD *)&pBoatHandling->vecTurnResistance.y;
    v122 = CTimer::ms_fTimeStep;
    Multiply3x3((CVector *)&v, &this->m_vecTurnSpeed, this->m_pMat);
    v123 = powf(*(float *)&v121, v122);
    v124 = *(_QWORD *)&v._vptr$CEvent;
    v125 = v123;
    this->m_vecTurnSpeed.z = *(RwReal *)&v.m_bIsPersistent;
    *(_QWORD *)&this->m_vecTurnSpeed.x = v124;
    v126 = powf(*((float *)&v121 + 1), v122);
    v127 = this->m_vecTurnSpeed.x;
    v128 = v126 * this->m_vecTurnSpeed.z;
    this->m_vecTurnSpeed.y = v125 * this->m_vecTurnSpeed.y;
    this->m_vecTurnSpeed.z = v128;
    Multiply3x3((CVector *)&v, this->m_pMat, &this->m_vecTurnSpeed);
    v129 = *(_QWORD *)&v._vptr$CEvent;
    this->m_vecTurnSpeed.z = *(RwReal *)&v.m_bIsPersistent;
    *(_QWORD *)&this->m_vecTurnSpeed.x = v129;
    v130 = this->m_pMat;
    m_fTurnMass = this->m_fTurnMass;
    v132 = v130->xz;
    yz = v130->yz;
    v134 = v130->zz;
    Multiply3x3((CVector *)&v, v130, &this->m_vecCOM);
    v135 = (float)((float)(v127
                         * (float)(powf(xa, v122) * (float)(1.0 / (float)((float)(v127 * (float)(v127 * 1000.0)) + 1.0))))
                 - v127)
         * m_fTurnMass;
    v196.x = v135 * v132;
    v196.y = v135 * yz;
    v196.z = v135 * v134;
    pBuoyancyForced.x = v130->xy + *(float *)&v._vptr$CEvent;
    pBuoyancyForced.y = v130->yy + *(float *)&v.m_iAccumulatedTime;
    pBuoyancyForced.z = v130->zy + *(float *)&v.m_bIsPersistent;
    CPhysical::ApplyTurnForce(this, v196, pBuoyancyForced);
  }
  v136 = (int)(float)((float)(VolumeUnderWater - *fPrevVolume) * 10000.0);
  v21 = v172;
  if ( !v120 && this->m_pMat->zz > 0.0 )
  {
    v137 = (int)(float)((float)(VolumeUnderWater - *fPrevVolume) * 10000.0);
    v138 = (float)v136;
    v139 = pBoatHandling->fWaveAudioMult * (float)v136;
    if ( v139 > 200.0 )
      CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 99, v139);
    if ( v137 >= 201 )
    {
      v140 = this->m_vecMoveSpeed.x;
      v141 = this->m_vecMoveSpeed.y;
      v142 = this->m_vecMoveSpeed.z;
      v143 = this->m_pMat;
      v144 = v143->xy;
      v145 = v143->yy;
      v146 = v143->zy;
      pHandling = this->pHandling;
      v150.n64_u32[1] = LODWORD(pHandling->fBrakeBias);
      fBrakeDeceleration = pHandling->fBrakeDeceleration;
      v149 = (float)(v138 * -0.01) * v150.n64_f32[1];
      v150.n64_f32[0] = (float)(v138 * 0.001)
                      * (float)((float)((float)(v140 * v140) + (float)(v141 * v141)) + (float)(v142 * v142));
      v151 = (float)((float)(v144 * v140) + (float)(v145 * v141)) + (float)(v146 * v142);
      v152 = v142 + v150.n64_f32[0];
      v153 = fBrakeDeceleration - v142;
      v154 = (float)(v149 * v144) * v151;
      v155 = (float)(v149 * v145) * v151;
      v156 = (float)(v149 * v146) * v151;
      v9.n64_u32[0] = 0;
      v157 = v154 + 0.0;
      if ( v152 > fBrakeDeceleration )
        v150.n64_f32[0] = v153;
      v158 = vmax_f32(v150, v9).n64_f32[0] + v156;
      v159 = this->m_fMass;
      v160 = v159 * v157;
      v161 = v159 * v158;
      v197.x = v160;
      v197.y = v159 * (float)(v155 + 0.0);
      v197.z = v161;
      CPhysical::ApplyMoveForce(this, v197);
      v198.z = v161;
      v198.x = v160;
      v198.y = v159 * (float)(v155 + 0.0);
      CPhysical::ApplyTurnForce(this, v198, pCentreOfBuoyancy);
    }
  }
  if ( v13 )
  {
    v162 = *(_QWORD *)&v178.x;
    v13[1].m_fMassMultiplier = v178.z;
    *(_QWORD *)&v13[1].m_fMass = v162;
  }
  else if ( !this->m_baseVehicleType )
  {
    *(float *)&this[1].AutoPilot.LastTimeNotStuck = sqrtf(
                                                      (float)((float)(v178.x * v178.x) + (float)(v178.y * v178.y))
                                                    + (float)(v178.z * v178.z));
  }
  *fPrevVolume = VolumeUnderWater;
LABEL_142:
  if ( v13 )
    LOBYTE(v13[1].m_transform.m_translate.z) = LOBYTE(v13[1].m_transform.m_translate.z) & 0xFE | v21;
}
// 588E4A: variable 'v7' is possibly undefined
// 588E4A: variable 'v6' is possibly undefined
// 589230: variable 'v11' is possibly undefined
// 589230: variable 'v5' is possibly undefined
// 589402: variable 'v8' is possibly undefined
// 589520: variable 'v10' is possibly undefined
// 589936: variable 'v9' is possibly undefined
// 589A32: variable 'v163' is possibly undefined

//----- (00589AC0) --------------------------------------------------------
void __fastcall CVehicle::ApplyBoatWaterResistance(
        CVehicle *this,
        tBoatHandlingData *pBoatHandling,
        float fVolumeUnderWater)
{
  CMatrix *m_pMat; // r2
  CVector *p_m_vecMoveSpeed; // r8
  float x; // s18
  float y; // s20
  float z; // s22
  float v10; // s23
  float v11; // s16
  float v12; // s24
  float v13; // s26
  int m_nModelIndex; // r5
  float m_fMass; // s28
  float xy; // s30
  float yy; // s17
  float zy; // s19
  float fSuspensionForce; // s21
  float v20; // s0
  float v21; // s24
  float v22; // r5
  float v23; // r0
  float v24; // s0
  __int64 v25; // d16
  float v26; // s20
  float v27; // s22
  float v28; // s24
  float v29; // s26
  float v30; // s18
  __int64 v31; // d16
  CMatrix *v32; // r0
  float v33; // s0
  float v34; // s0
  float v35; // s0
  CVector v36; // [sp+0h] [bp-70h]
  CVector v37; // [sp+10h] [bp-60h] BYREF
  CVector v38; // 0:r1.12

  m_pMat = this->m_pMat;
  p_m_vecMoveSpeed = &this->m_vecMoveSpeed;
  x = pBoatHandling->vecMoveResistance.x;
  y = pBoatHandling->vecMoveResistance.y;
  z = pBoatHandling->vecMoveResistance.z;
  v10 = CTimer::ms_fTimeStep;
  v11 = this->m_vecMoveSpeed.x;
  v12 = this->m_vecMoveSpeed.y;
  v13 = this->m_vecMoveSpeed.z;
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  m_fMass = this->m_fMass;
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  zy = m_pMat->zy;
  fSuspensionForce = this->pHandling->fSuspensionForce;
  Multiply3x3(&v37, &this->m_vecMoveSpeed, m_pMat);
  v20 = m_fMass * (float)((float)((float)(fSuspensionForce * 0.001) * fVolumeUnderWater) * fVolumeUnderWater);
  if ( m_nModelIndex == 460 )
    v20 = v20 * 30.0;
  v21 = 1.0
      / fabsf(
          (float)(v20
                * (float)((float)((float)((float)((float)(v11 * xy) + (float)(v12 * yy)) + (float)(v13 * zy))
                                * (float)((float)((float)(v11 * xy) + (float)(v12 * yy)) + (float)(v13 * zy)))
                        + 0.05))
        + 1.0);
  v22 = powf(x * v21, v10 * 0.5);
  v23 = powf(y * v21, v10 * 0.5);
  v24 = z * v21;
  v25 = *(_QWORD *)&v37.x;
  v26 = v23;
  this->m_vecMoveSpeed.z = v37.z;
  *(_QWORD *)&this->m_vecMoveSpeed.x = v25;
  v27 = this->m_vecMoveSpeed.x;
  v28 = this->m_vecMoveSpeed.y;
  v29 = this->m_vecMoveSpeed.z;
  v30 = powf(v24, v10 * 0.5);
  this->m_vecMoveSpeed.x = v22 * v27;
  this->m_vecMoveSpeed.y = v26 * v28;
  this->m_vecMoveSpeed.z = v30 * v29;
  Multiply3x3(&v37, this->m_pMat, p_m_vecMoveSpeed);
  v31 = *(_QWORD *)&v37.x;
  this->m_vecMoveSpeed.z = v37.z;
  *(_QWORD *)&this->m_vecMoveSpeed.x = v31;
  v32 = this->m_pMat;
  v33 = (float)((float)(v26 + -1.0) * (float)(v26 * v28)) * this->m_fMass;
  v38.x = v33 * v32->xy;
  v38.y = v33 * v32->yy;
  v38.z = v33 * v32->zy;
  v36.x = -v32->xz;
  v36.y = -v32->yz;
  v36.z = -v32->zz;
  CPhysical::ApplyTurnForce(this, v38, v36);
  v34 = this->m_vecMoveSpeed.z;
  if ( v34 <= 0.0 )
    v35 = ((float)(1.0 - v30) * 0.5 + v30) * v34;
  else
    v35 = v30 * v34;
  this->m_vecMoveSpeed.z = v35;
}

//----- (00589CC0) --------------------------------------------------------
void __fastcall CVehicle::DoBoatSplashes(CVehicle *this, float fForceMag)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float v7; // s16
  int Mission; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r2
  float32x2_t v12; // d16
  float32x2_t v13; // d0
  float v14; // s26
  float v15; // s0
  float v16; // s2
  float v17; // s22
  float v18; // s16
  float v19; // s17
  int v20; // r5
  CColModel *ColModel; // r0
  float x; // s22
  float z; // s30
  CColModel *v24; // r0
  int m_nModelIndex; // r1
  float v26; // s26
  int *v27; // r2
  float v28; // s28
  RwReal y; // s17
  RwReal v30; // s30
  CMatrix *v31; // r0
  float xy; // s22
  float yy; // s19
  float zy; // s23
  float v35; // s0
  RwReal v36; // s22
  RwReal v37; // s25
  RwReal v38; // s23
  CMatrix *v39; // r6
  float v40; // s19
  float xx; // s27
  float yx; // s29
  float zx; // s31
  CMatrix *v44; // r6
  int v45; // r0
  float xz; // s8
  float zz; // s12
  float v48; // s2
  float v49; // s0
  CMatrix *v50; // r0
  float v51; // s22
  float v52; // s26
  float v53; // s28
  float v54; // s30
  CMatrix *v55; // r10
  int v56; // r5
  CMatrix *v57; // r4
  float v58; // s17
  float v59; // s23
  float v60; // s25
  float v61; // s2
  float v62; // s0
  float v63; // s1
  float v64; // s6
  float v65; // s0
  CVector v66; // [sp+18h] [bp-B8h] BYREF
  CVector v67; // [sp+28h] [bp-A8h] BYREF
  CVector v68; // [sp+38h] [bp-98h] BYREF
  CVector v; // [sp+48h] [bp-88h] BYREF
  FxPrtMult_c v70; // [sp+54h] [bp-7Ch] BYREF

  v7 = (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
             + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
     + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z);
  if ( v7 > 0.0025
    && this->m_pMat->zz > 0.0
    && !CCamera::GetLookingForwardFirstPerson(&TheCamera)
    && CEntity::IsVisible(this) )
  {
    Mission = (unsigned __int8)this->AutoPilot.Mission;
    if ( Mission != 1 || (CTimer::m_FrameCounter & 2) == 0 )
    {
      m_pMat = this->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &this->m_transform;
      p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_m_transform = &TheCamera.m_transform;
      v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
      v13.n64_u64[0] = vmul_f32(v12, v12).n64_u64[0];
      v14 = sqrtf((float)(v13.n64_f32[0] + v13.n64_f32[1]) + 0.0);
      if ( v14 < 80.0 )
      {
        v15 = (float)(sqrtf(v7) * 0.075) * fForceMag;
        if ( this->m_nModelIndex == 460 )
        {
          v16 = 0.5;
          v15 = v15 * 3.0;
        }
        else
        {
          v16 = 1.0;
        }
        if ( v15 > v16 )
          v15 = v16;
        if ( v15 > 0.15 && !(CTimer::m_FrameCounter % 3) )
        {
          v17 = v15 * 0.75;
          if ( Mission == 1 )
          {
            v13.n64_u32[0] = 1.0;
            v2.n64_f32[0] = v17 + v17;
            LODWORD(v17) = vmin_f32(v2, v13).n64_u32[0];
          }
          v18 = v17 * 10.0;
          v19 = (float)((float)(v17 + v17) + 0.3) * (float)((float)((float)((float)rand() * 4.6566e-10) * 0.4) + 0.8);
          v20 = (unsigned int)(float)((float)(v17 * 128.0) + 0.0);
          if ( (unsigned int)v20 >= 0x40 )
            v20 = 64;
          if ( v14 > 50.0 )
            v20 = (unsigned int)(float)((float)((float)(80.0 - v14) / 30.0) * (float)v20);
          FxPrtMult_c::FxPrtMult_c(&v70, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0);
          v4.n64_u32[0] = 1.0;
          v3.n64_f32[0] = (float)((float)(v17 * 10.0) + 0.75) * 0.1;
          v13.n64_f32[0] = (float)(unsigned int)v20 / 255.0;
          v2.n64_f32[0] = v19 * 0.2;
          LODWORD(v70.m_size) = vmin_f32(v3, v4).n64_u32[0];
          LODWORD(v70.m_life) = vmin_f32(v2, v4).n64_u32[0];
          LODWORD(v70.m_alpha) = vmin_f32(v13, v4).n64_u32[0];
          ColModel = CEntity::GetColModel(this);
          x = ColModel->m_boxBound.m_vecMin.x;
          z = ColModel->m_boxBound.m_vecMin.z;
          v24 = CEntity::GetColModel(this);
          m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
          v26 = 0.7;
          v27 = &dword_58A210;
          if ( m_nModelIndex == 460 )
            v26 = 0.25;
          v28 = v24->m_boxBound.m_vecMax.x;
          if ( m_nModelIndex == 460 )
            v27 = &dword_58A214;
          v30 = z * *(float *)v27;
          v.y = v24->m_boxBound.m_vecMax.y * 0.5;
          y = v.y;
          v.z = v30;
          v.x = x * v26;
          operator*(&v68, this->m_pMat, &v);
          v = v68;
          v31 = this->m_pMat;
          xy = v31->xy;
          yy = v31->yy;
          zy = v31->zy;
          v35 = (float)((float)((float)rand() * 4.6566e-10) * 0.4) + 0.8;
          v36 = -(float)(xy * v35);
          v37 = -(float)(yy * v35);
          v38 = -(float)(zy * v35);
          v68.x = v36;
          v68.y = v37;
          v68.z = v38;
          v39 = this->m_pMat;
          v40 = (float)rand();
          xx = v39->xx;
          yx = v39->yx;
          zx = v39->zx;
          v44 = this->m_pMat;
          v45 = rand();
          xz = v44->xz;
          zz = v44->zz;
          v48 = (float)((float)(v40 * 4.6566e-10) * 0.4) + 0.3;
          v49 = (float)((float)((float)v45 * 4.6566e-10) * 0.4) + 0.8;
          v68.y = v18 * (float)((float)(v44->yz * v49) + (float)(v37 - (float)(yx * v48)));
          v68.x = v18 * (float)((float)(v36 - (float)(xx * v48)) + (float)(xz * v49));
          v68.z = v18 * (float)((float)(zz * v49) + (float)(v38 - (float)(zx * v48)));
          FxSystem_c::AddParticle(g_fx.m_fxSysBoatSplash, &v, &v68, 0.0, &v70, -1.0, 1.2, 0.6, 0);
          v67.y = y;
          v67.x = v28 * v26;
          v67.z = v30;
          operator*(&v66, this->m_pMat, &v67);
          v67 = v66;
          v50 = this->m_pMat;
          v51 = v50->xy;
          v52 = v50->yy;
          v53 = v50->zy;
          v54 = (float)((float)((float)rand() * 4.6566e-10) * 0.4) + 0.8;
          v66.x = -(float)(v51 * v54);
          v66.y = -(float)(v52 * v54);
          v66.z = -(float)(v53 * v54);
          v55 = this->m_pMat;
          v56 = rand();
          v57 = this->m_pMat;
          v58 = v55->xx;
          v59 = v55->yx;
          v60 = v55->zx;
          v61 = (float)((float)((float)v56 * 4.6566e-10) * 0.4) + 0.3;
          v62 = (float)((float)((float)rand() * 4.6566e-10) * 0.4) + 0.8;
          v63 = v57->yz * v62;
          v64 = (float)((float)(v58 * v61) - (float)(v51 * v54)) + (float)(v57->xz * v62);
          v65 = (float)(v57->zz * v62) + (float)((float)(v60 * v61) - (float)(v53 * v54));
          v66.y = v18 * (float)(v63 + (float)((float)(v59 * v61) - (float)(v52 * v54)));
          v66.x = v18 * v64;
          v66.z = v18 * v65;
          FxSystem_c::AddParticle(g_fx.m_fxSysBoatSplash, &v67, &v66, 0.0, &v70, -1.0, 1.2, 0.6, 0);
        }
      }
    }
  }
}
// 589E2E: variable 'v2' is possibly undefined
// 589F02: variable 'v3' is possibly undefined
// 589F02: variable 'v4' is possibly undefined
// 58A210: using guessed type int dword_58A210;
// 58A214: using guessed type int;

//----- (0058A220) --------------------------------------------------------
RpMaterial_0 *__fastcall SetCompAlphaCB(RpMaterial_0 *pMaterial, void *pData)
{
  pMaterial->color._anon_0._anon_0.alpha = (unsigned __int8)pData;
  return pMaterial;
}

//----- (0058A224) --------------------------------------------------------
void __fastcall CVehicle::SetComponentAtomicAlpha(RpAtomic_0 *pAtomic, int32 nAlpha)
{
  RpGeometry_0 *geometry; // r0

  geometry = pAtomic->geometry;
  geometry->flags |= 0x40u;
  sub_198134(geometry, SetCompAlphaCB, (void *)nAlpha);
}

//----- (0058A240) --------------------------------------------------------
void __fastcall CVehicle::UpdateClumpAlpha(CVehicle *this)
{
  int ClumpAlpha; // r1

  ClumpAlpha = CVisibilityPlugins::GetClumpAlpha((RpClump_0 *)this->m_pRwObject);
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 4) != 0 )
  {
    ClumpAlpha -= 8;
    if ( ClumpAlpha <= 0 )
      ClumpAlpha = 0;
  }
  else if ( ClumpAlpha <= 254 )
  {
    ClumpAlpha += 16;
    if ( ClumpAlpha >= 255 )
      ClumpAlpha = 255;
  }
  sub_191044((RpClump_0 *)this->m_pRwObject, ClumpAlpha);
}

//----- (0058A278) --------------------------------------------------------
void __fastcall CVehicle::DoSunGlare(CVehicle *this)
{
  float32x2_t v1; // d5
  float v2; // s19
  float32x2_t v3; // d14
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  float x; // s0
  float y; // s2
  float z; // s4
  CSimpleTransform *p_m_transform; // r2
  float v11; // s0
  float v12; // s2
  float v13; // s4
  CVector *v14; // r1
  float v15; // s22
  float v16; // s16
  float v17; // s18
  float v18; // s20
  float v19; // s2
  float v20; // s0
  float v21; // s8
  float v22; // s0
  float v23; // s2
  float v24; // s4
  CMatrix *v25; // r1
  float v26; // s24
  float yy; // r0
  float xy; // s2
  float v29; // s6
  float v30; // s0
  float v31; // s0
  float v32; // s4
  float v33; // s6
  float v34; // s4
  float v35; // s2
  float v36; // s4
  float v37; // s0
  int m_nSunCoreRed; // r8
  int m_nSunCoreGreen; // r5
  int m_nSunCoreBlue; // r6
  float v41; // s22
  CCollisionData *m_pColData; // r11
  float v43; // s0
  float v44; // s6
  float v45; // s4
  unsigned int v46; // s0
  int m_nNoOfTriangles; // r9
  float32x2_t v48; // d11
  int v49; // r8
  int v50; // r6
  __int64 v51; // kr00_8
  int v52; // r3
  int v53; // r2
  float32x2_t v54; // d16
  float v55; // s0
  int v56; // r4
  __int64 v57; // kr08_8
  int v58; // r0
  int v59; // r2
  float32x2_t *v61; // r5
  float32x2_t v62; // d17
  float v63; // s2
  int v64; // r2
  float v65; // s4
  int v66; // r0
  int v67; // r0
  bool v68; // zf
  int v69; // r0
  int v70; // r0
  bool v71; // zf
  int v72; // r0
  float32x2_t v73; // d3
  float32x2_t v79; // d4
  float v80; // s8
  const CMatrix *v81; // r1
  char *v82; // [sp+48h] [bp-A8h]
  unsigned int v83; // [sp+4Ch] [bp-A4h]
  unsigned int v84; // [sp+50h] [bp-A0h]
  UInt8 B; // [sp+54h] [bp-9Ch]
  CVehicle *v86; // [sp+58h] [bp-98h]
  CVector v; // [sp+5Ch] [bp-94h] BYREF
  CVector v88; // [sp+68h] [bp-88h] BYREF
  CVector v89; // [sp+74h] [bp-7Ch] BYREF
  CVector Coors; // [sp+80h] [bp-70h] BYREF

  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) == 0 )
  {
    m_pMat = this->m_pMat;
    if ( m_pMat->zz >= 0.0 && CWeather::SunGlare > 0.0 && !(HIBYTE(this->pHandling->mFlags) << 28) )
    {
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &this->m_transform;
      x = p_tx->m_translate.x;
      y = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_m_transform = &TheCamera.m_transform;
      v11 = p_m_transform->m_translate.x - x;
      v12 = p_m_transform->m_translate.y - y;
      v13 = p_m_transform->m_translate.z - z;
      v14 = &CTimeCycle::m_VectorToSun[CTimeCycle::m_CurrentStoredValue];
      v15 = sqrtf((float)((float)(v11 * v11) + (float)(v12 * v12)) + (float)(v13 * v13));
      v16 = v12 * (float)(2.0 / v15);
      v17 = v11 * (float)(2.0 / v15);
      v18 = v13 * (float)(2.0 / v15);
      v19 = v14->y + v16;
      v20 = v14->x + v17;
      v21 = v14->z + v18;
      v89.x = (float)((float)(m_pMat->xx * v20) + (float)(m_pMat->yx * v19)) + (float)(v21 * m_pMat->zx);
      v22 = v20 * m_pMat->xy;
      v23 = v19 * m_pMat->yy;
      v24 = v21 * m_pMat->zy;
      v89.z = 0.0;
      v89.y = (float)(v22 + v23) + v24;
      CVector::Normalise(&v89);
      v25 = this->m_pMat;
      v26 = 1.0;
      yy = v25->yy;
      xy = v25->xy;
      v29 = (float)(xy * xy) + (float)(yy * yy);
      v30 = 1.0;
      if ( v29 > 0.0 )
      {
        v31 = 1.0 / sqrtf(v29);
        v32 = v31 * yy;
        v30 = xy * v31;
        yy = v32;
      }
      v33 = (float)(v17 * v17) + (float)(v16 * v16);
      v34 = 1.0;
      v35 = v16;
      if ( v33 > 0.0 )
      {
        v36 = 1.0 / sqrtf(v33);
        v35 = v16 * v36;
        v34 = v17 * v36;
      }
      v37 = fabsf((float)(v30 * v34) + (float)(v35 * yy));
      if ( v37 <= 0.995 )
      {
        if ( v37 <= 0.99 )
          return;
        v26 = (float)(v37 + -0.99) * 200.0;
      }
      if ( v15 <= 30.0 )
      {
        if ( v15 <= 13.0 )
          return;
        v26 = (float)((float)(v15 + -13.0) / 17.0) * v26;
      }
      v86 = this;
      m_nSunCoreRed = CTimeCycle::m_CurrentColours.m_nSunCoreRed;
      m_nSunCoreGreen = CTimeCycle::m_CurrentColours.m_nSunCoreGreen;
      m_nSunCoreBlue = CTimeCycle::m_CurrentColours.m_nSunCoreBlue;
      v41 = CWeather::SunGlare;
      m_pColData = CEntity::GetColModel(this)->m_pColData;
      CCollision::CalculateTrianglePlanes(m_pColData);
      v43 = (float)(v26 * 0.8) * v41;
      v44 = (float)(v43 * (float)(m_nSunCoreRed + 510)) / 3.0;
      v45 = (float)(v43 * (float)(m_nSunCoreGreen + 510)) / 3.0;
      v46 = (unsigned int)(float)((float)(v43 * (float)(m_nSunCoreBlue + 510)) / 3.0);
      m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
      if ( m_nNoOfTriangles >= 2 )
      {
        v48.n64_f32[0] = 0.25;
        v48.n64_f32[1] = 0.25;
        v49 = 0;
        v50 = 0;
        B = v46;
        v84 = (unsigned int)v45;
        v83 = (unsigned int)v44;
        v82 = (char *)&this->m_pRwObject + 3;
        do
        {
          v51 = *(_QWORD *)&m_pColData->m_pTriCompressedVectorArray;
          v52 = *(_DWORD *)(HIDWORD(v51) + v49);
          v53 = v51 + 12 * v52;
          v54.n64_u64[0] = *(unsigned __int64 *)v53;
          v55 = *(float *)(v53 + 8);
          if ( v55 > 0.0 )
          {
            v56 = HIDWORD(v51) + v49;
            v57 = *(_QWORD *)(HIDWORD(v51) + v49 + 4);
            v58 = *(_DWORD *)(HIDWORD(v51) + v49 + 16);
            v59 = v51 + 12 * HIDWORD(v57);
            _ZF = v58 == HIDWORD(v57);
            v61 = (float32x2_t *)(v51 + 12 * v57);
            v62.n64_u64[0] = *(unsigned __int64 *)v59;
            v63 = *(float *)(v59 + 8);
            v64 = 0;
            v65 = v61[1].n64_f32[0];
            if ( v58 != HIDWORD(v57) )
              _ZF = v58 == v52;
            if ( !_ZF && v58 != (_DWORD)v57 )
            {
              v66 = v51 + 12 * HIDWORD(v51);
              v3.n64_u64[0] = *(unsigned __int64 *)v66;
              v2 = *(float *)(v66 + 8);
              v64 = 1;
            }
            v67 = *(_DWORD *)(v56 + 20);
            v68 = v67 == HIDWORD(v57);
            if ( v67 != HIDWORD(v57) )
              v68 = v67 == v52;
            if ( !v68 && v67 != (_DWORD)v57 )
            {
              v69 = v51 + 12 * HIDWORD(v51);
              v3.n64_u64[0] = *(unsigned __int64 *)v69;
              v2 = *(float *)(v69 + 8);
              ++v64;
            }
            v70 = *(_DWORD *)(v56 + 24);
            v71 = v70 == HIDWORD(v57);
            if ( v70 != HIDWORD(v57) )
              v71 = v70 == v52;
            if ( !v71 && v70 != (_DWORD)v57 )
            {
              v72 = v51 + 12 * HIDWORD(v51);
              v3.n64_u64[0] = *(unsigned __int64 *)v72;
              v2 = *(float *)(v72 + 8);
              ++v64;
            }
            if ( v64 == 1 )
            {
              v73.n64_u64[0] = vmul_f32(vadd_f32(vadd_f32(vadd_f32(v54, (float32x2_t)v61->n64_u64[0]), v62), v3), v48).n64_u64[0];
              _D16 = vsub_f32(v73, v54).n64_i64[0];
              __asm { VCLT.F32        D4, D16, #0.0 }
              v79.n64_u64[0] = vbsl_s64(_D4, vneg_f32((float32x2_t)_D16).n64_i64[0], _D16);
              v1.n64_u32[0] = v79.n64_u32[1];
              v80 = vmin_f32(v79, v1).n64_f32[0] * 1.4;
              if ( v80 > 0.6 )
              {
                v81 = v86->m_pMat;
                v.x = v73.n64_f32[0] + (float)(v80 * v89.x);
                v.y = v73.n64_f32[1] + (float)(v80 * v89.y);
                v.z = (float)((float)((float)((float)(v55 + v65) + v63) + v2) * 0.25) + (float)(v80 * v89.z);
                operator*(&v88, v81, &v);
                Coors.x = v17 + v88.x;
                Coors.y = v16 + v88.y;
                Coors.z = v18 + v88.z;
                CCoronas::RegisterCorona(
                  (u_native)&v82[v50],
                  0,
                  v83,
                  v84,
                  B,
                  0xFFu,
                  &Coors,
                  CWeather::SunGlare * 0.9,
                  90.0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0.0,
                  0,
                  1.5,
                  0,
                  15.0,
                  0,
                  0);
                LOWORD(m_nNoOfTriangles) = m_pColData->m_nNoOfTriangles;
              }
            }
          }
          v49 += 32;
          v50 += 2;
        }
        while ( v50 <= (__int16)m_nNoOfTriangles - 2 );
      }
    }
  }
}
// 58A638: variable 'v3' is possibly undefined
// 58A654: variable 'v1' is possibly undefined
// 58A692: variable 'v2' is possibly undefined

//----- (0058A78C) --------------------------------------------------------
void __fastcall CVehicle::UpdatePassengerList(CVehicle *this)
{
  CPed *v1; // r1
  bool v2; // zf
  CPed *v3; // r1
  bool v4; // zf
  CPed *v5; // r1
  bool v6; // zf
  CPed *v7; // r1
  bool v8; // zf

  if ( !this->m_nNumPassengers )
    goto LABEL_18;
  v1 = this->pPassengers[0];
  v2 = v1 == 0;
  if ( !v1 )
    v2 = this->pPassengers[1] == 0;
  if ( v2 )
  {
    v3 = this->pPassengers[2];
    v4 = v3 == 0;
    if ( !v3 )
      v4 = this->pPassengers[3] == 0;
    if ( v4 )
    {
      v5 = this->pPassengers[4];
      v6 = v5 == 0;
      if ( !v5 )
        v6 = this->pPassengers[5] == 0;
      if ( v6 )
      {
        v7 = this->pPassengers[6];
        v8 = v7 == 0;
        if ( !v7 )
          v8 = this->pPassengers[7] == 0;
        if ( v8 )
LABEL_18:
          this->m_nNumPassengers = 0;
      }
    }
  }
}

//----- (0058A7DC) --------------------------------------------------------
CPed *__fastcall CVehicle::PickRandomPassenger(CVehicle *this)
{
  int v2; // r1
  CPed *result; // r0

  v2 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 8.0);
  result = this->pPassengers[v2 - ((v2 + ((unsigned int)(v2 >> 31) >> 29)) & 0x3FFFFFF8)];
  if ( !result )
  {
    result = this->pPassengers[v2 + 1 - ((v2 + 1 + ((unsigned int)((v2 + 1) >> 31) >> 29)) & 0x3FFFFFF8)];
    if ( !result )
    {
      result = this->pPassengers[v2 + 2 - ((v2 + 2 + ((unsigned int)((v2 + 2) >> 31) >> 29)) & 0x3FFFFFF8)];
      if ( !result )
      {
        result = this->pPassengers[v2 + 3 - ((v2 + 3 + ((unsigned int)((v2 + 3) >> 31) >> 29)) & 0x3FFFFFF8)];
        if ( !result )
        {
          result = this->pPassengers[v2 + 4 - ((v2 + 4 + ((unsigned int)((v2 + 4) >> 31) >> 29)) & 0x3FFFFFF8)];
          if ( !result )
          {
            result = this->pPassengers[v2 + 5 - ((v2 + 5 + ((unsigned int)((v2 + 5) >> 31) >> 29)) & 0x3FFFFFF8)];
            if ( !result )
            {
              result = this->pPassengers[v2 + 6 - ((v2 + 6 + ((unsigned int)((v2 + 6) >> 31) >> 29)) & 0x3FFFFFF8)];
              if ( !result )
                return this->pPassengers[v2 + 7 - ((v2 + 7 + ((unsigned int)((v2 + 7) >> 31) >> 29)) & 0x3FFFFFF8)];
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0058A8CC) --------------------------------------------------------
void __fastcall CVehicle::AddDamagedVehicleParticles(CVehicle *this)
{
  float m_nHealth; // s0
  RwObject_0 *m_pRwObject; // r1
  FxSystem_c *m_fxSysEngOverheat; // r0
  char *parent; // r3
  char *v6; // r1
  uint32 m_hashKey; // r2
  RwMatrix *v8; // r3
  __int64 v9; // d16
  FxSystem_c *v10; // r0
  RwReal v11; // s2
  RwReal v12; // s0
  FxSystem_c *v13; // r0
  RwV3d_0 offsetPos; // [sp+8h] [bp-20h] BYREF

  if ( this->m_vehicleType != 4 )
  {
    m_nHealth = this->m_nHealth;
    if ( m_nHealth < 650.0 && m_nHealth >= 250.0 && !(*((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31) )
    {
      m_pRwObject = this->m_pRwObject;
      if ( m_pRwObject )
      {
        m_fxSysEngOverheat = this->m_fxSysEngOverheat;
        if ( m_fxSysEngOverheat )
        {
LABEL_12:
          FxSystem_c::SetConstTime(m_fxSysEngOverheat, 1u, (float)((float)(this->m_nHealth + -250.0) / -400.0) + 1.0);
          v11 = this->m_vecMoveSpeed.x * 50.0;
          v12 = this->m_vecMoveSpeed.z * 50.0;
          offsetPos.y = this->m_vecMoveSpeed.y * 50.0;
          offsetPos.x = v11;
          offsetPos.z = v12;
          FxSystem_c::SetVelAdd(this->m_fxSysEngOverheat, &offsetPos);
          return;
        }
        parent = (char *)m_pRwObject->parent;
        v6 = "overheat_car_electric";
        m_hashKey = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey;
        v8 = (RwMatrix *)(parent + 16);
        v9 = *(_QWORD *)(m_hashKey + 84);
        if ( this->pHandling->Transmission.m_nEngineType != 69 )
          v6 = "overheat_car";
        offsetPos.z = *(RwReal *)(m_hashKey + 92);
        *(_QWORD *)&offsetPos.x = v9;
        v10 = FxManager_c::CreateFxSystem(&g_fxMan, (unsigned __int8 *)v6, &offsetPos, v8, 0);
        this->m_fxSysEngOverheat = v10;
        if ( v10 )
          FxSystem_c::Play(v10);
      }
      m_fxSysEngOverheat = this->m_fxSysEngOverheat;
      if ( !m_fxSysEngOverheat )
        return;
      goto LABEL_12;
    }
    v13 = this->m_fxSysEngOverheat;
    if ( v13 )
    {
      FxSystem_c::Kill(v13);
      this->m_fxSysEngOverheat = 0;
    }
  }
}

//----- (0058AA28) --------------------------------------------------------
void __fastcall CVehicle::MakeDirty(CVehicle *this, CColPoint *WheelColPoint)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float *p_nBodyDirtLevel; // r0
  unsigned __int32 v8; // s0
  float nBodyDirtLevel; // s0

  if ( SurfaceInfos_c::IsWater(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) || CWeather::Rain >= 0.2 )
  {
    nBodyDirtLevel = this->nBodyDirtLevel;
    if ( nBodyDirtLevel > 1.0 )
      this->nBodyDirtLevel = nBodyDirtLevel + (float)(CTimer::ms_fTimeStep * -0.01);
  }
  else
  {
    if ( SurfaceInfos_c::MakesCarDirty(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
    {
      if ( sqrtf(
             (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
           + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) <= 0.06 )
        return;
      v4.n64_u32[0] = 15.0;
      p_nBodyDirtLevel = &this->nBodyDirtLevel;
      v2.n64_f32[0] = this->nBodyDirtLevel + (float)(CTimer::ms_fTimeStep * 0.003);
      v8 = vmin_f32(v2, v4).n64_u32[0];
      goto LABEL_12;
    }
    if ( SurfaceInfos_c::MakesCarClean(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
    {
      if ( sqrtf(
             (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
           + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) > 0.04 )
      {
        v2.n64_u32[0] = 4.0;
        p_nBodyDirtLevel = &this->nBodyDirtLevel;
        v3.n64_u32[0] = LODWORD(this->nBodyDirtLevel);
        if ( v3.n64_f32[0] > 4.0 )
        {
          v3.n64_f32[0] = v3.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.02);
          v8 = vmax_f32(v3, v2).n64_u32[0];
LABEL_12:
          *(_DWORD *)p_nBodyDirtLevel = v8;
        }
      }
    }
  }
}
// 58AAB2: variable 'v2' is possibly undefined
// 58AAB2: variable 'v4' is possibly undefined
// 58AB4E: variable 'v3' is possibly undefined

//----- (0058AB8C) --------------------------------------------------------
int __fastcall CVehicle::AddWheelDirtAndWater(
        CVehicle *this,
        CColPoint *WheelColPoint,
        bool32 bProduceWheelDrops,
        int bWheelsSpinning,
        int bWheelInWater)
{
  int v8; // r5
  float v10; // s16
  float v11; // s16

  if ( !bProduceWheelDrops && !SurfaceInfos_c::IsSand(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
    return 0;
  if ( bWheelInWater )
  {
    Fx_c::AddWheelSpray(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, 1, this->m_lightingFromCollision);
    return 0;
  }
  if ( SurfaceInfos_c::CreatesWheelGrass(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
  {
    Fx_c::AddWheelGrass(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, this->m_lightingFromCollision);
    return 0;
  }
  if ( SurfaceInfos_c::CreatesWheelGravel(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
  {
    Fx_c::AddWheelGravel(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, this->m_lightingFromCollision);
    return 1;
  }
  if ( SurfaceInfos_c::CreatesWheelMud(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
  {
    Fx_c::AddWheelMud(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, this->m_lightingFromCollision);
    return 0;
  }
  if ( SurfaceInfos_c::CreatesWheelDust(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
  {
    v10 = CWeather::WetRoads;
    if ( CWeather::WetRoads <= 0.0
      || (float)(v10 + (float)((float)(1.01 - v10) * (float)((float)rand() * 4.6566e-10))) <= 0.5 )
    {
      Fx_c::AddWheelDust(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, this->m_lightingFromCollision);
    }
    return 0;
  }
  if ( SurfaceInfos_c::CreatesWheelSand(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType) )
  {
    v11 = CWeather::WetRoads;
    if ( CWeather::WetRoads <= 0.0
      || (float)(v11 + (float)((float)(1.01 - v11) * (float)((float)rand() * 4.6566e-10))) <= 0.5 )
    {
      Fx_c::AddWheelSand(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, this->m_lightingFromCollision);
    }
    return 0;
  }
  v8 = 1;
  if ( SurfaceInfos_c::CreatesWheelSpray(&g_surfaceInfos, WheelColPoint->m_dataB.m_nSurfaceType)
    && CWeather::WetRoads > 0.4 )
  {
    if ( CCullZones::CamNoRain() )
    {
      return 1;
    }
    else
    {
      v8 = 0;
      Fx_c::AddWheelSpray(&g_fx, this, WheelColPoint->m_vecPosition, bWheelsSpinning, 0, this->m_lightingFromCollision);
    }
  }
  return v8;
}

//----- (0058AE18) --------------------------------------------------------
void __fastcall CVehicle::AddWaterSplashParticles(CVehicle *this)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v4; // d16
  unsigned __int64 v5; // d1
  int v6; // r10
  int v7; // r5
  float v8; // r8
  const CCollisionData *v9; // r10
  int v10; // r0
  int v11; // r4
  float v12; // s20
  float v13; // s26
  float v14; // s24
  float v15; // s30
  float v16; // s22
  float v17; // s28
  float v18; // s2
  float v19; // s0
  int m_nNoOfTriangles; // [sp+18h] [bp-F0h]
  CCollisionData *m_pColData; // [sp+1Ch] [bp-ECh]
  int v23; // [sp+24h] [bp-E4h]
  RwV3d_0 v24; // [sp+28h] [bp-E0h] BYREF
  RwV3d_0 v25; // [sp+38h] [bp-D0h] BYREF
  FxPrtMult_c fxMults; // [sp+44h] [bp-C4h] BYREF
  CVector v27; // [sp+60h] [bp-A8h] BYREF
  CVector v28; // [sp+6Ch] [bp-9Ch] BYREF
  CVector v29; // [sp+78h] [bp-90h] BYREF
  CVector v30; // [sp+84h] [bp-84h] BYREF
  CVector v31; // [sp+90h] [bp-78h] BYREF
  CVector pt; // [sp+9Ch] [bp-6Ch] BYREF

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  v4.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v5 = vmul_f32(v4, v4).n64_u64[0];
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                             * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                     + *(float *)&v5)
             + *((float *)&v5 + 1)) <= 100.0 )
  {
    m_pColData = CEntity::GetColModel(this)->m_pColData;
    m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
    if ( m_nNoOfTriangles >= 1 )
    {
      v6 = 1058642330;
      v7 = 0;
      do
      {
        v8 = *(float *)&v6;
        v9 = m_pColData;
        CCollisionData::GetTrianglePoint(m_pColData, &pt, m_pColData->m_pTriangleArray[v7].m_nIndex1);
        operator*(&v29, this->m_pMat, &pt);
        CCollisionData::GetTrianglePoint(v9, &v31, v9->m_pTriangleArray[v7].m_nIndex2);
        operator*(&v28, this->m_pMat, &v31);
        v23 = v7;
        CCollisionData::GetTrianglePoint(v9, &v30, v9->m_pTriangleArray[v7].m_nIndex3);
        v6 = LODWORD(v8);
        operator*(&v27, this->m_pMat, &v30);
        FxPrtMult_c::FxPrtMult_c(&fxMults, 1.0, 1.0, 1.0, 0.35, 0.02, 0.0, 0.03);
        v10 = (int)(float)(CWeather::Rain + CWeather::Rain);
        if ( v10 >= 0 )
        {
          v11 = v10 + 1;
          v12 = v27.z - v28.z;
          v13 = v28.z - v29.z;
          v14 = v27.x - v28.x;
          v15 = v28.x - v29.x;
          v16 = v27.y - v28.y;
          v17 = v28.y - v29.y;
          do
          {
            v18 = (float)((float)rand() * 4.6566e-10) + 0.0;
            v19 = (float)(v18 * (float)((float)rand() * 4.6566e-10)) + 0.0;
            v25.x = (float)(v29.x + (float)(v15 * v18)) + (float)(v14 * v19);
            v25.y = (float)(v29.y + (float)(v17 * v18)) + (float)(v16 * v19);
            v25.z = (float)((float)(v13 * v18) + v29.z) + (float)(v12 * v19);
            memset(&v24, 0, sizeof(v24));
            FxSystem_c::AddParticle(g_fx.m_fxSysSplash, &v25, &v24, 0.0, &fxMults, -1.0, 1.2, v8, 0);
            --v11;
          }
          while ( v11 );
        }
        ++v7;
      }
      while ( v23 + 1 != m_nNoOfTriangles );
    }
  }
}

//----- (0058B090) --------------------------------------------------------
void __fastcall CVehicle::AddExhaustParticles(CVehicle *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  CVehicle *v4; // r4
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r6
  float32x2_t v8; // d16
  unsigned __int64 v9; // d1
  float v10; // s0
  CBaseModelInfo *v11; // r5
  CVector *m_hashKey; // r0
  __int64 v13; // d16
  int v14; // r6
  int m_nModelIndex; // r0
  _BOOL4 v16; // r1
  uint32 v17; // r0
  __int64 v18; // d16
  float x; // s2
  float y; // s0
  char v21; // r0
  CMatrix *v22; // r1
  float v23; // s4
  _BOOL4 v24; // r0
  float m_fGasPedal; // s16
  int v26; // r0
  float v27; // s18
  float v28; // s18
  int v29; // r10
  float m_lightingFromCollision; // s0
  FxSystem_c *m_fxSysBubble; // r0
  float v32; // s0
  FxSystem_c *m_fxSysSmoke2; // r0
  float v34; // s0
  FxSystem_c *v35; // r0
  float v36; // s0
  FxSystem_c *v37; // r0
  _BOOL4 v38; // [sp+30h] [bp-F0h]
  _BOOL4 v39; // [sp+38h] [bp-E8h]
  int v40; // [sp+3Ch] [bp-E4h]
  FxPrtMult_c pWaterZ; // [sp+40h] [bp-E0h] BYREF
  RwV3d_0 pos; // [sp+60h] [bp-C0h] BYREF
  CVector v43; // [sp+70h] [bp-B0h] BYREF
  RwV3d_0 vel; // [sp+7Ch] [bp-A4h] BYREF
  CMatrix m; // [sp+88h] [bp-98h] BYREF
  CVector v46; // [sp+D0h] [bp-50h] BYREF
  CVector v; // [sp+E0h] [bp-40h] BYREF

  v4 = this;
  if ( (*((_BYTE *)&this->m_nFlags + 2) & 2) == 0 )
  {
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_m_transform = &TheCamera.m_transform;
    v8.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v9 = vmul_f32(v8, v8).n64_u64[0];
    v10 = (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                        * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                + *(float *)&v9)
        + *((float *)&v9 + 1);
    if ( v10 <= 256.0 )
    {
      if ( v10 <= 64.0 )
      {
        LOWORD(this) = this->m_nModelIndex;
      }
      else
      {
        this = (CVehicle *)(unsigned __int16)this->m_nModelIndex;
        if ( !(((_DWORD)this + CTimer::m_FrameCounter) << 31) )
          return;
      }
      v11 = CModelInfo::ms_modelInfoPtrs[(__int16)this];
      m_hashKey = (CVector *)v11[2].m_hashKey;
      v13 = *(_QWORD *)&m_hashKey[6].x;
      v.z = m_hashKey[6].z;
      *(_QWORD *)&v.x = v13;
      v46 = m_hashKey[6];
      v46.x = -v46.x;
      CMatrix::CMatrix(&m, m_pMat);
      v40 = (v4->pHandling->mFlags >> 13) & 1;
      if ( v4->m_vehicleType == 9 )
      {
        v14 = v4->pHandling->mFlags & 0x2000;
        CBike::CalculateLeanMatrix((CBike *)v4);
        CMatrix::operator=(&m, (const CMatrix *)&v4[1].m_pLastRenderedLink);
        m_nModelIndex = v4->m_nModelIndex;
        switch ( m_nModelIndex )
        {
          case 581:
            v16 = v4->m_comp1 == 2;
            goto LABEL_17;
          case 522:
            if ( (unsigned __int8)v4->m_comp1 <= 1u )
            {
              v17 = v11[2].m_hashKey;
              v18 = *(_QWORD *)(v17 + 132);
              v46.z = *(RwReal *)(v17 + 140);
              *(_QWORD *)&v46.x = v18;
            }
            break;
          case 521:
            v16 = (unsigned __int8)(v4->m_comp1 - 1) < 2u;
LABEL_17:
            v40 = v14 != 0 || v16;
            break;
        }
      }
      if ( v.x == 0.0 && v.z == 0.0 )
      {
LABEL_60:
        CMatrix::~CMatrix(&m);
        return;
      }
      vel.z = 0.0;
      x = v4->m_vecMoveSpeed.x;
      y = v4->m_vecMoveSpeed.y;
      if ( (float)((float)((float)(x * v4->m_pMat->xy) + (float)(y * v4->m_pMat->yy))
                 + (float)(v4->m_vecMoveSpeed.z * v4->m_pMat->zy)) >= 0.05 )
      {
        v23 = 30.0;
      }
      else
      {
        v21 = `guard variable for'CVehicle::AddExhaustParticles(void)::speed;
        __dmb(0xBu);
        if ( (v21 & 1) == 0
          && _cxa_guard_acquire((__guard *)&`guard variable for'CVehicle::AddExhaustParticles(void)::speed) )
        {
          CVehicle::AddExhaustParticles(void)::speed = (float)((float)((float)rand() * 4.6566e-10) * 0.9) + -1.8;
          _cxa_guard_release((__guard *)&`guard variable for'CVehicle::AddExhaustParticles(void)::speed);
        }
        v22 = v4->m_pMat;
        v23 = CVehicle::AddExhaustParticles(void)::speed;
        x = v22->xy;
        y = v22->yy;
      }
      vel.x = x * v23;
      vel.y = v23 * y;
      operator*(&v43, &m, &v);
      v39 = 0;
      if ( (*((_BYTE *)&v4->m_nPhysicalFlags + 3) & 8) != 0
        && CWaterLevel::GetWaterLevel(v43.x, v43.y, v43.z, &pWaterZ.m_red, 1, 0) == 1 )
      {
        v39 = pWaterZ.m_red >= v43.z;
      }
      if ( v40 == 1 )
      {
        operator*((CVector *)&pWaterZ, &m, &v46);
        pos.z = pWaterZ.m_blue;
        *(_QWORD *)&pos.x = *(_QWORD *)&pWaterZ.m_red;
        v38 = 0;
        if ( (*((_BYTE *)&v4->m_nPhysicalFlags + 3) & 8) == 0
          || CWaterLevel::GetWaterLevel(pos.x, pos.y, pos.z, &pWaterZ.m_red, 1, 0) != 1 )
        {
LABEL_37:
          m_fGasPedal = v4->m_fGasPedal;
          v26 = rand();
          if ( (float)((float)(m_fGasPedal + 1.1)
                     * (float)((float)((float)((float)v26 * 4.6566e-10) + (float)((float)v26 * 4.6566e-10)) + 1.0)) > 2.5 )
          {
            v2.n64_u32[0] = 0;
            v1.n64_f32[0] = sqrtf(
                              (float)((float)(v4->m_vecMoveSpeed.x * v4->m_vecMoveSpeed.x)
                                    + (float)(v4->m_vecMoveSpeed.y * v4->m_vecMoveSpeed.y))
                            + (float)(v4->m_vecMoveSpeed.z * v4->m_vecMoveSpeed.z))
                          * 0.5;
            v3.n64_f32[0] = 0.2 - v1.n64_f32[0];
            v1.n64_f32[0] = 0.25 - v1.n64_f32[0];
            v27 = vmax_f32(v1, v2).n64_f32[0];
            FxPrtMult_c::FxPrtMult_c(&pWaterZ, 0.9, 0.9, 1.0, v27, 0.2, 1.0, vmax_f32(v3, v2).n64_f32[0]);
            v28 = v27 * 0.5;
            v29 = 2;
            do
            {
              if ( v39 )
              {
                pWaterZ.m_size = 0.6;
                pWaterZ.m_alpha = v28;
                m_lightingFromCollision = v4->m_lightingFromCollision;
                m_fxSysBubble = g_fx.m_fxSysBubble;
              }
              else
              {
                m_lightingFromCollision = v4->m_lightingFromCollision;
                m_fxSysBubble = g_fx.m_fxSysSmoke2;
              }
              FxSystem_c::AddParticle(m_fxSysBubble, &v43, &vel, 0.0, &pWaterZ, -1.0, m_lightingFromCollision, 0.6, 0);
              if ( v40 == 1 )
              {
                if ( v38 )
                {
                  pWaterZ.m_size = 0.6;
                  pWaterZ.m_alpha = v28;
                  v32 = v4->m_lightingFromCollision;
                  m_fxSysSmoke2 = g_fx.m_fxSysBubble;
                }
                else
                {
                  v32 = v4->m_lightingFromCollision;
                  m_fxSysSmoke2 = g_fx.m_fxSysSmoke2;
                }
                FxSystem_c::AddParticle(m_fxSysSmoke2, &pos, &vel, 0.0, &pWaterZ, -1.0, v32, 0.6, 0);
              }
              if ( v4->m_fGasPedal > 0.5 && v4->m_nCurrentGear <= 2u )
              {
                if ( (rand() & 1) != 0 )
                {
                  if ( v39 )
                  {
                    pWaterZ.m_size = 0.6;
                    pWaterZ.m_alpha = v28;
                    v36 = v4->m_lightingFromCollision;
                    v37 = g_fx.m_fxSysBubble;
                  }
                  else
                  {
                    v36 = v4->m_lightingFromCollision;
                    v37 = g_fx.m_fxSysSmoke2;
                  }
                  FxSystem_c::AddParticle(v37, &v43, &vel, 0.0, &pWaterZ, -1.0, v36, 0.6, 0);
                }
                else if ( v40 == 1 )
                {
                  if ( v38 )
                  {
                    pWaterZ.m_size = 0.6;
                    pWaterZ.m_alpha = v28;
                    v34 = v4->m_lightingFromCollision;
                    v35 = g_fx.m_fxSysBubble;
                  }
                  else
                  {
                    v34 = v4->m_lightingFromCollision;
                    v35 = g_fx.m_fxSysSmoke2;
                  }
                  FxSystem_c::AddParticle(v35, &pos, &vel, 0.0, &pWaterZ, -1.0, v34, 0.6, 0);
                }
              }
              --v29;
            }
            while ( v29 );
          }
          goto LABEL_60;
        }
        v24 = pWaterZ.m_red >= pos.z;
      }
      else
      {
        v24 = 0;
      }
      v38 = v24;
      goto LABEL_37;
    }
  }
}
// 58B416: variable 'v1' is possibly undefined
// 58B416: variable 'v2' is possibly undefined
// 58B412: variable 'v3' is possibly undefined
// A130E4: using guessed type char `guard variable for'CVehicle::AddExhaustParticles(void)::speed;

//----- (0058B600) --------------------------------------------------------
bool __fastcall CVehicle::GetHasDualExhausts(CVehicle *this)
{
  return (BYTE1(this->pHandling->mFlags) >> 5) & 1;
}

//----- (0058B610) --------------------------------------------------------
uint32 __fastcall CVehicle::AddSingleWheelParticles(
        CVehicle *this,
        tWheelState nWheelState,
        uint32 nWheelStatus,
        float fSusRatio,
        float fSpeed,
        CColPoint *pColPoint,
        CVector *pVecPos,
        float fOutsideVec,
        int32 nWheelIndex,
        uint32 nSkidmarkType,
        bool *pBloody,
        uint32 nOptionFlags)
{
  CVehicle *PlayerVehicle; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r2
  float32x2_t v20; // d16
  unsigned __int64 v21; // d1
  float v22; // s2
  float v23; // s0
  int v24; // r1
  _BOOL4 v25; // r5
  int v26; // r4
  float v27; // s20
  float v28; // s2
  float v29; // s0
  float v30; // s4
  CMatrix *v31; // r0
  float m_fGasPedal; // s0
  float v33; // s10
  float v34; // r3
  CPlayerPed *PlayerPed; // r0
  int v36; // r0
  bool v37; // zf
  float x; // s16
  int32 v39; // r0
  float v40; // s0
  float *v41; // r0
  int v42; // r0
  bool v43; // zf
  FxPrtMult_c *v44; // r0
  int32 m_vehicleType; // r1
  FxPrtMult_c *v46; // r5
  float v47; // s0
  float *p_m_life; // r0
  int v49; // r0
  bool v50; // zf
  int32 v51; // r1
  float v52; // s0
  float *p_m_size; // r2
  bool v54; // zf
  __int64 v55; // d16
  CMatrix *v56; // r0
  float v57; // s2
  float v58; // s0
  float v59; // s4
  float v60; // s4
  float v61; // s2
  float v62; // s0
  float v63; // s18
  float v64; // s18
  __int64 v65; // d16
  CMatrix *v66; // r0
  float v67; // s2
  float v68; // s0
  float v69; // s4
  float v70; // s4
  float v71; // s2
  float v72; // s0
  __int64 v73; // kr00_8
  float v74; // s2
  float v75; // s0
  float v76; // s18
  float v77; // s20
  float v78; // s22
  int v79; // r9
  int i; // r10
  float v81; // s2
  RwReal v82; // s0
  RwReal v83; // s6
  RwReal v84; // s2
  __int64 v85; // d16
  CMatrix *v86; // r0
  float v87; // s2
  float v88; // s0
  float v89; // s4
  float v90; // s4
  float v91; // s2
  float v92; // s0
  CMatrix *v93; // r1
  float xy; // r5
  float yy; // r6
  float v97; // s2
  float v98; // s0
  float v99; // s18
  float v100; // s20
  float v101; // s22
  int v102; // r9
  int j; // r10
  float v104; // s2
  RwReal v105; // s0
  RwReal v106; // s6
  RwReal v107; // s2
  float vecMoveSpeed_4; // [sp+8h] [bp-B8h]
  float vecMoveSpeed_4a; // [sp+8h] [bp-B8h]
  uint32 v110; // [sp+1Ch] [bp-A4h]
  uint32 v111; // [sp+1Ch] [bp-A4h]
  RwV3d_0 pos; // [sp+24h] [bp-9Ch] BYREF
  RwV3d_0 vel; // [sp+30h] [bp-90h] BYREF
  FxPrtMult_c pWaterZ[4]; // [sp+40h] [bp-80h] BYREF

  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( (*((_BYTE *)&this->m_nFlags + 2) & 2) != 0 )
    return 0;
  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  v20.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v21 = vmul_f32(v20, v20).n64_u64[0];
  v22 = (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                      * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
              + *(float *)&v21)
      + *((float *)&v21 + 1);
  if ( v22 > 625.0 && !(*((unsigned __int8 *)&this->m_nVehicleFlags + 5) << 31) )
    return 0;
  v23 = fSusRatio;
  if ( v22 <= 400.0 )
  {
    v24 = 1;
    if ( PlayerVehicle )
    {
      v25 = 1;
      if ( v22 <= 64.0 )
        goto LABEL_13;
    }
  }
  else
  {
    v24 = 3;
  }
  v25 = ((CTimer::m_FrameCounter + (unsigned __int16)this->m_nModelIndex) & v24) == 0;
LABEL_13:
  if ( v23 >= 1.0 )
    return 0;
  if ( SurfaceInfos_c::IsWater(&g_surfaceInfos, pColPoint->m_dataB.m_nSurfaceType) )
    goto LABEL_15;
  v26 = 0;
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 8) == 0
    || CWaterLevel::GetWaterLevel(pVecPos->x, pVecPos->y, pVecPos->z, &pWaterZ[0].m_red, 1, 0) != 1 )
  {
    goto LABEL_20;
  }
  if ( pWaterZ[0].m_red >= pVecPos->z )
LABEL_15:
    v26 = 1;
  else
    v26 = 0;
LABEL_20:
  if ( nWheelStatus == 1
    && (nWheelState == WS_SPINNING || fSpeed > 0.1)
    && SurfaceInfos_c::GetFrictionEffect(&g_surfaceInfos, pColPoint->m_dataB.m_nSurfaceType) == 1 )
  {
    v27 = fSpeed * 32.0;
    v28 = this->m_vecMoveSpeed.y * -50.0;
    v29 = this->m_vecMoveSpeed.z * -50.0;
    v30 = this->m_vecMoveSpeed.x * -50.0;
    if ( nWheelState == WS_SPINNING && fSpeed < 0.2 )
    {
      v31 = this->m_pMat;
      m_fGasPedal = this->m_fGasPedal;
      v27 = 10.0;
      v33 = m_fGasPedal * v31->xy;
      v28 = (float)(m_fGasPedal * v31->yy) * -12.0;
      v29 = (float)(m_fGasPedal * v31->zy) * -12.0;
      v30 = v33 * -12.0;
    }
    pWaterZ[0].m_green = v28;
    pWaterZ[0].m_red = v30;
    pWaterZ[0].m_blue = v29 + 2.5;
    v34 = CVector::NormaliseAndMag((CVector *)pWaterZ);
    Fx_c::AddSparks(&g_fx, pVecPos, (CVector *)pWaterZ, v34, (int)v27, this->m_vecMoveSpeed, 1, 0.1, 0.3);
    PlayerPed = FindPlayerPed(0);
    CAudioEngine::ReportCollision(
      &AudioEngine,
      this,
      PlayerPed,
      pColPoint->m_dataA.m_nSurfaceType,
      pColPoint->m_dataB.m_nSurfaceType,
      pVecPos,
      0,
      1.0,
      1.0,
      0,
      1);
  }
  CVehicle::MakeDirty(this, pColPoint);
  switch ( nWheelState )
  {
    case WS_LOCKED:
      if ( fSpeed <= 0.03 )
        goto LABEL_94;
      v42 = CVehicle::AddWheelDirtAndWater(this, pColPoint, fSpeed < 1.0, 0, v26);
      v43 = !v25;
      if ( v25 )
        v43 = v42 == 0;
      if ( v43 )
      {
LABEL_94:
        if ( nWheelStatus != 1 )
        {
          v85 = *(_QWORD *)&pVecPos->x;
          pWaterZ[0].m_blue = pVecPos->z;
          *(_QWORD *)&pWaterZ[0].m_red = v85;
          if ( this->m_nModelIndex == 471 )
          {
            v86 = this->m_pMat;
            v87 = v86->yx * 0.15;
            v88 = v86->zx * 0.15;
            v89 = v86->xx * 0.15;
            if ( nWheelIndex > 1 )
            {
              v90 = pWaterZ[0].m_red - v89;
              v91 = pWaterZ[0].m_green - v87;
              v92 = pWaterZ[0].m_blue - v88;
            }
            else
            {
              v90 = v89 + pWaterZ[0].m_red;
              v91 = v87 + pWaterZ[0].m_green;
              v92 = v88 + pWaterZ[0].m_blue;
            }
            pWaterZ[0].m_red = v90;
            pWaterZ[0].m_green = v91;
            pWaterZ[0].m_blue = v92;
          }
          if ( !v26 )
            goto LABEL_101;
        }
        return 0;
      }
      FxPrtMult_c::FxPrtMult_c(pWaterZ, 0.9, 0.9, 1.0, 0.5, 0.7, 1.0, 0.3);
      vel.z = 0.5;
      *(_QWORD *)&vel.x = unk_61EE50;
      m_vehicleType = this->m_vehicleType;
      v110 = nWheelStatus;
      if ( m_vehicleType != 2 )
      {
        if ( m_vehicleType == 10 )
        {
          v46 = v44;
          p_m_life = &v44->m_life;
          v47 = 0.3;
          pWaterZ[0].m_size = pWaterZ[0].m_size * 0.2;
          goto LABEL_87;
        }
        if ( m_vehicleType != 9 )
        {
          v46 = v44;
          v75 = 2.0;
          goto LABEL_89;
        }
      }
      v46 = v44;
      v47 = 0.5;
      p_m_life = &v44->m_size;
LABEL_87:
      v74 = v47 * *p_m_life;
      v75 = 3.0;
      *p_m_life = v74;
LABEL_89:
      v76 = CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y;
      v77 = CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x;
      v78 = CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z;
      v79 = (int)(float)(v75 * sqrtf((float)((float)(v77 * v77) + (float)(v76 * v76)) + (float)(v78 * v78)));
      if ( v79 <= 1 )
        v79 = 1;
      for ( i = 0; i < v79; ++i )
      {
        v81 = 1.0 - (float)((float)i / (float)v79);
        pWaterZ[0].m_blue = (float)((float)((float)rand() * 4.6566e-10) * 0.5) + 0.5;
        pWaterZ[0].m_green = pWaterZ[0].m_blue * 0.9;
        pWaterZ[0].m_red = pWaterZ[0].m_blue * 0.9;
        v82 = pVecPos->x - (float)(v77 * v81);
        v83 = pVecPos->y - (float)(v76 * v81);
        v84 = pVecPos->z - (float)(v78 * v81);
        pos.y = v83;
        pos.x = v82;
        pos.z = v84;
        FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, &pos, &vel, 0.3, v46, -1.0, this->m_lightingFromCollision, 0.6, 0);
      }
      nWheelStatus = v110;
      goto LABEL_94;
    case WS_SKIDDING:
      if ( (nOptionFlags & 4) != 0 )
        return 0;
      if ( fSpeed <= 0.03 )
        goto LABEL_74;
      v49 = CVehicle::AddWheelDirtAndWater(this, pColPoint, fSpeed < 1.0, 0, v26);
      v50 = !v25;
      if ( v25 )
        v50 = v49 == 0;
      if ( v50 )
        goto LABEL_74;
      FxPrtMult_c::FxPrtMult_c(pWaterZ, 0.9, 0.9, 1.0, 0.5, 0.7, 1.0, 0.3);
      vel.z = 0.5;
      *(_QWORD *)&vel.x = unk_61EE50;
      v51 = this->m_vehicleType;
      v111 = nWheelStatus;
      if ( v51 != 2 )
      {
        if ( v51 == 10 )
        {
          p_m_size = &pWaterZ[0].m_life;
          v52 = 0.3;
          pWaterZ[0].m_size = pWaterZ[0].m_size * 0.2;
          goto LABEL_104;
        }
        if ( v51 != 9 )
        {
          v98 = 2.0;
LABEL_106:
          v99 = CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y;
          v100 = CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x;
          v101 = CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z;
          v102 = (int)(float)(v98 * sqrtf((float)((float)(v100 * v100) + (float)(v99 * v99)) + (float)(v101 * v101)));
          if ( v102 <= 1 )
            v102 = 1;
          for ( j = 0; j < v102; ++j )
          {
            v104 = 1.0 - (float)((float)j / (float)v102);
            pWaterZ[0].m_blue = (float)((float)((float)rand() * 4.6566e-10) * 0.5) + 0.5;
            pWaterZ[0].m_green = pWaterZ[0].m_blue * 0.9;
            pWaterZ[0].m_red = pWaterZ[0].m_blue * 0.9;
            v105 = pVecPos->x - (float)(v100 * v104);
            v106 = pVecPos->y - (float)(v99 * v104);
            v107 = pVecPos->z - (float)(v101 * v104);
            pos.y = v106;
            pos.x = v105;
            pos.z = v107;
            FxSystem_c::AddParticle(
              g_fx.m_fxSysSmoke2,
              &pos,
              &vel,
              0.3,
              pWaterZ,
              -1.0,
              this->m_lightingFromCollision,
              0.6,
              0);
          }
          if ( v111 == 1 )
            return 0;
          goto LABEL_75;
        }
      }
      v52 = 0.5;
      p_m_size = &pWaterZ[0].m_size;
LABEL_104:
      v97 = v52 * *p_m_size;
      v98 = 3.0;
      *p_m_size = v97;
      goto LABEL_106;
    case WS_SPINNING:
      v36 = CVehicle::AddWheelDirtAndWater(this, pColPoint, fSpeed < 1.0, 1u, v26);
      v37 = !v25;
      if ( v25 )
        v37 = v36 == 0;
      if ( v37 )
      {
LABEL_74:
        if ( nWheelStatus == 1 )
          return 0;
LABEL_75:
        v65 = *(_QWORD *)&pVecPos->x;
        pWaterZ[0].m_blue = pVecPos->z;
        *(_QWORD *)&pWaterZ[0].m_red = v65;
        if ( this->m_nModelIndex == 471 )
        {
          v66 = this->m_pMat;
          v67 = v66->yx * 0.15;
          v68 = v66->zx * 0.15;
          v69 = v66->xx * 0.15;
          if ( nWheelIndex > 1 )
          {
            v70 = pWaterZ[0].m_red - v69;
            v71 = pWaterZ[0].m_green - v67;
            v72 = pWaterZ[0].m_blue - v68;
          }
          else
          {
            v70 = v69 + pWaterZ[0].m_red;
            v71 = v67 + pWaterZ[0].m_green;
            v72 = v68 + pWaterZ[0].m_blue;
          }
          pWaterZ[0].m_red = v70;
          pWaterZ[0].m_green = v71;
          pWaterZ[0].m_blue = v72;
        }
        if ( !v26 )
        {
LABEL_101:
          v93 = this->m_pMat;
          xy = v93->xy;
          yy = v93->yy;
          vecMoveSpeed_4a = COERCE_FLOAT(
                              (*((int (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 64))(
                                this,
                                nWheelIndex & 1));
          CSkidmarks::RegisterOne(
            (UInt32)this + nWheelIndex,
            (const CVector *)pWaterZ,
            xy,
            yy,
            __SPAIR64__((unsigned int)pBloody, nSkidmarkType),
            vecMoveSpeed_4a);
          return 0;
        }
        return 0;
      }
      FxPrtMult_c::FxPrtMult_c(pWaterZ, 0.9, 0.9, 1.0, 0.5, 1.0, 1.0, 0.5);
      x = this->m_vecMoveSpeed.x;
      if ( sqrtf(
             (float)((float)(x * x) + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
           + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.15 )
      {
        pWaterZ[0].m_alpha = 0.3;
        pWaterZ[0].m_size = 0.5;
      }
      v39 = this->m_vehicleType;
      if ( v39 != 2 )
      {
        if ( v39 == 10 )
        {
          v41 = &pWaterZ[0].m_life;
          v40 = 0.3;
          pWaterZ[0].m_size = pWaterZ[0].m_size * 0.2;
          goto LABEL_72;
        }
        if ( v39 != 9 )
        {
LABEL_73:
          v63 = fabsf(this->m_fGasPedal);
          vel.x = (float)((float)((float)(v63 * x) * -30.0) * (float)((float)rand() * 4.6566e-10)) + 0.0;
          v64 = v63 * this->m_vecMoveSpeed.y;
          vel.y = (float)((float)(v64 * -30.0) * (float)((float)rand() * 4.6566e-10)) + 0.0;
          vel.z = (float)((float)((float)(rand() % 10000) * 0.0001) * 0.8) + 0.0;
          pWaterZ[0].m_blue = (float)((float)((float)rand() * 4.6566e-10) * 0.5) + 0.5;
          pWaterZ[0].m_green = pWaterZ[0].m_blue * 0.9;
          pWaterZ[0].m_red = pWaterZ[0].m_blue * 0.9;
          FxSystem_c::AddParticle(
            g_fx.m_fxSysSmoke2,
            pVecPos,
            &vel,
            0.0,
            pWaterZ,
            -1.0,
            this->m_lightingFromCollision,
            0.6,
            0);
          goto LABEL_74;
        }
      }
      v40 = 0.5;
      v41 = &pWaterZ[0].m_size;
LABEL_72:
      *v41 = v40 * *v41;
      goto LABEL_73;
  }
  if ( fSpeed > 0.03 )
    CVehicle::AddWheelDirtAndWater(this, pColPoint, fSpeed < 1.0, 0, v26);
  v54 = (nWheelIndex & 1) == 0;
  if ( (nWheelIndex & 1) != 0 )
    v54 = (*((_DWORD *)&this->m_nVehicleFlags + 1) & 0x100) == 0;
  if ( (v54
     || sqrtf(
          (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
        + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) <= 0.04)
    && !*pBloody )
  {
    if ( nWheelStatus == 1 || (nOptionFlags & 2) == 0 )
      return 0;
  }
  else if ( nWheelStatus == 1 )
  {
    return 0;
  }
  v55 = *(_QWORD *)&pVecPos->x;
  pWaterZ[0].m_blue = pVecPos->z;
  *(_QWORD *)&pWaterZ[0].m_red = v55;
  if ( this->m_nModelIndex == 471 )
  {
    v56 = this->m_pMat;
    v57 = v56->yx * 0.15;
    v58 = v56->zx * 0.15;
    v59 = v56->xx * 0.15;
    if ( nWheelIndex > 1 )
    {
      v60 = pWaterZ[0].m_red - v59;
      v61 = pWaterZ[0].m_green - v57;
      v62 = pWaterZ[0].m_blue - v58;
    }
    else
    {
      v60 = v59 + pWaterZ[0].m_red;
      v61 = v57 + pWaterZ[0].m_green;
      v62 = v58 + pWaterZ[0].m_blue;
    }
    pWaterZ[0].m_red = v60;
    pWaterZ[0].m_green = v61;
    pWaterZ[0].m_blue = v62;
  }
  if ( !v26 )
  {
    v73 = *(_QWORD *)&this->m_pMat->xy;
    vecMoveSpeed_4 = COERCE_FLOAT((*((int (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 64))(this, nWheelIndex & 1));
    CSkidmarks::RegisterOne(
      (UInt32)this + nWheelIndex,
      (const CVector *)pWaterZ,
      *(float *)&v73,
      *((float *)&v73 + 1),
      __SPAIR64__((unsigned int)pBloody, nSkidmarkType),
      vecMoveSpeed_4);
  }
  return 0;
}
// 58BE32: conditional instruction was optimized away because r9.4>=1
// 58C04A: conditional instruction was optimized away because r9.4>=1
// 58B9DE: variable 'v44' is possibly undefined

//----- (0058C168) --------------------------------------------------------
bool __fastcall CVehicle::GetSpecialColModel(CVehicle *this)
{
  int m_nSpecialColModel; // r0
  CVehicle **v3; // r1
  int v5; // r6
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  tHydraulicData *v7; // r0

  m_nSpecialColModel = this->m_nSpecialColModel;
  if ( m_nSpecialColModel < 0 || CVehicle::m_aSpecialColVehicle[m_nSpecialColModel] != this )
  {
    v3 = CVehicle::m_aSpecialColVehicle;
    if ( CVehicle::m_aSpecialColVehicle[0] )
    {
      v3 = &CVehicle::m_aSpecialColVehicle[1];
      if ( CVehicle::m_aSpecialColVehicle[1] )
      {
        v3 = &CVehicle::m_aSpecialColVehicle[2];
        if ( CVehicle::m_aSpecialColVehicle[2] )
        {
          v3 = &CVehicle::m_aSpecialColVehicle[3];
          if ( CVehicle::m_aSpecialColVehicle[3] )
            return 0;
          v5 = 3;
        }
        else
        {
          v5 = 2;
        }
      }
      else
      {
        v5 = 1;
      }
    }
    else
    {
      v5 = 0;
    }
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    this->m_nSpecialColModel = v5;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x4000000);
    *v3 = this;
    CEntity::RegisterReference(this, v3);
    CCollision::RemoveTrianglePlanes(&CVehicle::m_aSpecialColModel[v5]);
    if ( !CVehicle::m_aSpecialColModel[v5].m_pColData )
      CColModel::AllocateData(&CVehicle::m_aSpecialColModel[v5]);
    CColModel::operator=(
      &CVehicle::m_aSpecialColModel[v5],
      CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel);
    v7 = &CVehicle::m_aSpecialHydraulicData[v5];
    *(_QWORD *)v7->aScriptControl = 0LL;
    *(_QWORD *)&v7->aScriptControl[2] = 0LL;
    v7->fJackedUpper = 100.0;
  }
  return 1;
}

//----- (0058C264) --------------------------------------------------------
void __fastcall CVehicle::ProcessDrivingAnims(CVehicle *this, CPed *pPed, bool8 playRadioAnim)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d8
  int v7; // r6
  CAnimBlendAssociation *Association; // r0
  tHandlingData *pHandling; // r0
  AnimationId *v11; // r11
  int m_specialFlags; // r0
  float v13; // s16
  AnimationId (**v14)[4]; // r0
  AnimationId (**v15)[4]; // r1
  CAnimBlendAssociation *v16; // r6
  CAnimBlendAssociation *v17; // r9
  CAnimBlendAssociation *v18; // r10
  CAnimBlendAssociation *v19; // r0
  CAnimBlendAssociation *v20; // r8
  CAnimBlendAssociation *v21; // r0
  int v22; // r1
  bool v23; // zf
  AnimationId v24; // r2
  AnimationId v25; // r2

  v7 = playRadioAnim;
  if ( (*((_BYTE *)&this->m_nFlags + 2) & 2) == 0 && CPed::IsPlayer(pPed) )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xBDu);
    if ( v7 )
      Association = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_CAR_RADIO, 4.0);
    if ( !Association )
    {
      if ( (*((_BYTE *)&this->m_nVehicleFlags + 1) & 8) != 0 )
      {
        v11 = aDriveAnimIdsLow;
      }
      else
      {
        pHandling = this->pHandling;
        if ( this->m_baseVehicleType != 5 || (pHandling->mFlags & 0x400) != 0 )
        {
          m_specialFlags = CVehicleAnimGroupData::m_vehicleAnimGroups[pHandling->AnimGroup].m_specialFlags;
          if ( (m_specialFlags & 4) != 0 )
          {
            v11 = aDriveAnimIdsKart;
          }
          else if ( (m_specialFlags & 8) != 0 )
          {
            v11 = aDriveAnimIdsTruck;
          }
          else
          {
            v13 = sqrtf(
                    (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                          + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                  + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z));
            if ( CStats::GetStatValue(0xA0u) >= 50.0 )
            {
              v14 = &aDriveAnimIdsProSlow_ptr;
              v15 = &aDriveAnimIdsPro_ptr;
            }
            else
            {
              v14 = &aDriveAnimIdsStdSlow_ptr;
              v15 = &aDriveAnimIdsStd_ptr;
            }
            v11 = (AnimationId *)*v14;
            if ( v13 > 0.4 )
              v11 = (AnimationId *)*v15;
          }
        }
        else
        {
          v11 = aDriveAnimIdsBoat;
        }
      }
      v16 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, *v11);
      v17 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, *((_DWORD *)v11 + 1));
      v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, *((_DWORD *)v11 + 2));
      v19 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, *((_DWORD *)v11 + 3));
      v20 = v19;
      if ( !v16 )
      {
        if ( !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x3Cu) )
          return;
        v24 = *v11;
        goto LABEL_47;
      }
      v5.n64_u32[0] = 1.0;
      if ( v16->m_fBlendAmount < 1.0 )
        return;
      if ( v19
        && TheCamera.Cams[TheCamera.ActiveCam].Mode == 16
        && TheCamera.Cams[TheCamera.ActiveCam].DirectionWasLooking == 1 )
      {
        v19->m_fBlendDelta = -1000.0;
      }
      v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x4Au);
      if ( !v21 )
      {
        v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x4Bu);
        if ( !v21 )
        {
          v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x4Cu);
          if ( !v21 )
            v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x4Du);
        }
      }
      if ( (*((_BYTE *)&this->m_nVehicleFlags + 1) & 8) == 0 && !v21 && this->m_fGasPedal < 0.0 )
      {
        v22 = HIBYTE(this->pHandling->mFlags) & 0xF;
        v23 = v22 == 2;
        if ( v22 != 2 )
          v23 = v22 == 4;
        if ( !v23 )
        {
          if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 16
            && TheCamera.Cams[TheCamera.ActiveCam].DirectionWasLooking == 1
            || v20 && (v20->m_fBlendAmount >= 1.0 || v20->m_fBlendDelta > 0.0) )
          {
            return;
          }
          v24 = *((_DWORD *)v11 + 3);
LABEL_47:
          sub_197F5C((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v24, 4.0);
          return;
        }
      }
      if ( v21 || (v3.n64_u32[0] = LODWORD(this->m_fSteerAngle), v3.n64_f32[0] == 0.0) )
      {
        if ( v17 )
          v17->m_fBlendDelta = -4.0;
        if ( v18 )
          v18->m_fBlendDelta = -4.0;
        goto LABEL_66;
      }
      if ( v3.n64_f32[0] <= 0.0 )
      {
        if ( v17 )
        {
          v17->m_fBlendAmount = 0.0;
          v17->m_fBlendDelta = 0.0;
        }
        if ( v18 )
        {
          v18->m_fBlendDelta = 0.0;
          v3.n64_f32[0] = v3.n64_f32[0] / -0.61;
          v4.n64_u32[0] = 0;
          LODWORD(v18->m_fBlendAmount) = vmin_f32(vmax_f32(v3, v4), v5).n64_u32[0];
          goto LABEL_66;
        }
        v25 = *((_DWORD *)v11 + 2);
      }
      else
      {
        if ( v18 )
        {
          v18->m_fBlendAmount = 0.0;
          v18->m_fBlendDelta = 0.0;
        }
        if ( v17 )
        {
          v17->m_fBlendDelta = 0.0;
          v3.n64_f32[0] = v3.n64_f32[0] / 0.61;
          v4.n64_u32[0] = 0;
          LODWORD(v17->m_fBlendAmount) = vmin_f32(vmax_f32(v3, v4), v5).n64_u32[0];
          goto LABEL_66;
        }
        v25 = *((_DWORD *)v11 + 1);
      }
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v25, 4.0);
LABEL_66:
      if ( v20 )
        v20->m_fBlendDelta = -4.0;
    }
  }
}
// 58C490: variable 'v3' is possibly undefined
// 58C490: variable 'v4' is possibly undefined
// 58C494: variable 'v5' is possibly undefined
// 676D80: using guessed type AnimationId (*aDriveAnimIdsPro_ptr)[4];
// 67786C: using guessed type AnimationId (*aDriveAnimIdsProSlow_ptr)[4];
// 678B68: using guessed type AnimationId (*aDriveAnimIdsStdSlow_ptr)[4];
// 6799F4: using guessed type AnimationId (*aDriveAnimIdsStd_ptr)[4];

//----- (0058C5E8) --------------------------------------------------------
void __fastcall CVehicle::SetGettingInFlags(CVehicle *this, uint8 nGettingIn)
{
  this->m_nGettingInFlags |= nGettingIn;
}

//----- (0058C5F4) --------------------------------------------------------
void __fastcall CVehicle::SetGettingOutFlags(CVehicle *this, uint8 nGettingOut)
{
  this->m_nGettingOutFlags |= nGettingOut;
}

//----- (0058C600) --------------------------------------------------------
void __fastcall CVehicle::ClearGettingInFlags(CVehicle *this, uint8 nGettingIn)
{
  this->m_nGettingInFlags &= ~nGettingIn;
}

//----- (0058C60E) --------------------------------------------------------
void __fastcall CVehicle::ClearGettingOutFlags(CVehicle *this, uint8 nGettingOut)
{
  this->m_nGettingOutFlags &= ~nGettingOut;
}

//----- (0058C61C) --------------------------------------------------------
void __fastcall CVehicle::SetWindowOpenFlag(CVehicle *this, uint8 nDoor)
{
  RwFrame_0 *FrameFromId; // r0

  FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, nDoor);
  if ( FrameFromId )
    sub_197F1C(FrameFromId, CVehicleModelInfo::SetAtomicFlagCB, &elf_hash_bucket[961]);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0058C644) --------------------------------------------------------
void __fastcall CVehicle::ClearWindowOpenFlag(CVehicle *this, uint8 nDoor)
{
  RwFrame_0 *FrameFromId; // r0

  FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, nDoor);
  if ( FrameFromId )
    sub_197F1C(FrameFromId, CVehicleModelInfo::ClearAtomicFlagCB, &elf_hash_bucket[961]);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0058C66C) --------------------------------------------------------
int32 __fastcall CVehicle::AddVehicleUpgrade(CVehicle *this, int32 modelId)
{
  int32 v3; // r4
  CBaseModelInfo *v4; // r6
  int32 ModelInfoIndex; // r6
  int32 OtherUpgrade; // r8
  unsigned int m_flags; // r0
  int v8; // r9
  RwFrame_0 *FrameFromId; // r0
  __int16 **v10; // r0
  unsigned int v11; // r0
  int v12; // r2
  int16 *m_upgrades; // r0
  int i; // r1
  int v15; // r2
  int32 v17; // [sp+4h] [bp-24h] BYREF
  unsigned int pData; // [sp+8h] [bp-20h] BYREF
  RpAtomic_0 *pAtomic; // [sp+Ch] [bp-1Ch]

  v3 = modelId;
  v4 = CModelInfo::ms_modelInfoPtrs[modelId];
  v17 = -1;
  if ( !CVehicle::SetVehicleUpgradeFlags(this, modelId, (v4->m_flags >> 10) & 0x1F, &v17) )
  {
    OtherUpgrade = CVehicleModelInfo::CLinkedUpgradeList::FindOtherUpgrade(&CVehicleModelInfo::ms_linkedUpgrades, v3);
    m_flags = v4->m_flags;
    v8 = (m_flags >> 10) & 0x1F;
    if ( (m_flags & 0x100) != 0 )
    {
      FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, v8);
      pData = v8;
      pAtomic = 0;
      RwFrameForAllObjects(FrameFromId, FindReplacementUpgradeCB, &pData);
      if ( pAtomic )
        ModelInfoIndex = CVisibilityPlugins::GetModelInfoIndex(pAtomic);
      else
        ModelInfoIndex = -1;
      v17 = ModelInfoIndex;
      CVehicle::AddReplacementUpgrade(this, v3, v8);
      if ( v8 == 2 )
      {
        this->m_wheelScale = *(float *)&CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][1].m_txdIndex;
        CVehicle::AddReplacementUpgrade(this, v3, 5);
        CVehicle::AddReplacementUpgrade(this, v3, 4);
        CVehicle::AddReplacementUpgrade(this, v3, 7);
        if ( !this->m_vehicleType )
        {
          if ( MI_OFFROAD_WHEEL == v3 )
          {
            this->hFlagsLocal |= 0x100000u;
          }
          else if ( (this->pHandling->hFlags & 0x100000) == 0 )
          {
            this->hFlagsLocal &= ~0x100000u;
          }
        }
      }
      goto LABEL_28;
    }
    pData = (m_flags >> 10) & 0x1F;
    pAtomic = 0;
    RpClumpForAllAtomics((RpClump_0 *)this->m_pRwObject, FindUpgradeCB, &pData);
    if ( pAtomic )
    {
      ModelInfoIndex = CVisibilityPlugins::GetModelInfoIndex(pAtomic);
LABEL_27:
      v17 = ModelInfoIndex;
      CVehicle::AddUpgrade(this, v3, v8);
LABEL_28:
      if ( (unsigned __int16)OtherUpgrade != 0xFFFF )
      {
        v11 = CModelInfo::ms_modelInfoPtrs[OtherUpgrade]->m_flags;
        v12 = (v11 >> 10) & 0x1F;
        if ( (v11 & 0x100) != 0 )
          CVehicle::AddReplacementUpgrade(this, OtherUpgrade, v12);
        else
          CVehicle::AddUpgrade(this, OtherUpgrade, v12);
      }
      goto LABEL_32;
    }
    if ( (v8 & 0x1F) == 15 )
    {
      if ( (this->hFlagsLocal & 0x80000) != 0 )
      {
        v10 = MI_NITRO_BOTTLE_SMALL_ptr;
        goto LABEL_26;
      }
    }
    else if ( v8 == 17 )
    {
      if ( (*((_BYTE *)&this->m_nVehicleFlags + 6) & 0x10) != 0 )
      {
        v10 = (__int16 **)&MI_STEREO_UPGRADE_ptr;
        goto LABEL_26;
      }
    }
    else if ( v8 == 16 && (this->hFlagsLocal & 0x20000) != 0 )
    {
      v10 = MI_HYDRAULICS_ptr;
LABEL_26:
      ModelInfoIndex = (unsigned __int16)**v10;
      goto LABEL_27;
    }
    ModelInfoIndex = -1;
    goto LABEL_27;
  }
  ModelInfoIndex = v17;
LABEL_32:
  m_upgrades = this->m_upgrades;
  for ( i = 0; i != 15; ++i )
  {
    v15 = m_upgrades[i];
    if ( ModelInfoIndex == v15 )
    {
      m_upgrades[i] = -1;
    }
    else if ( (unsigned __int16)v15 != 0xFFFF )
    {
      continue;
    }
    m_upgrades[i] = v3;
    LOWORD(v3) = -1;
  }
  return ModelInfoIndex;
}
// 58C708: masking with 0x1F was optimized away because r9.4 <= 0x1F
// 6767A0: using guessed type __int16 *MI_HYDRAULICS_ptr[3];
// 676964: using guessed type __int16 *MI_NITRO_BOTTLE_SMALL_ptr[2];

//----- (0058C864) --------------------------------------------------------
bool __fastcall CVehicle::SetVehicleUpgradeFlags(CVehicle *this, int32 modelId, int32 upgrade, int32 *replacing)
{
  uint32 hFlagsLocal; // r0
  bool result; // r0
  int8 v7; // r2
  int BassSetting; // r1

  if ( upgrade == 15 )
  {
    if ( this->m_baseVehicleType )
      return 0;
    if ( MI_NITRO_BOTTLE_LARGE == modelId )
    {
      v7 = 5;
    }
    else
    {
      v7 = 2;
      if ( MI_NITRO_BOTTLE_DOUBLE == modelId )
        v7 = 10;
    }
    if ( (this->hFlagsLocal & 0x80000) != 0 )
      *replacing = MI_NITRO_BOTTLE_SMALL;
    CAutomobile::NitrousControl((CAutomobile *)this, v7);
    return *(int *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 688) < 0;
  }
  if ( upgrade == 17 )
  {
    if ( this->m_VehicleAudioEntity.m_VehicleAudioSetting.RadioType
      || (*((_BYTE *)&this->m_nVehicleFlags + 6) & 0x10) != 0 )
    {
      result = 1;
      *replacing = modelId;
      return result;
    }
    BassSetting = (unsigned __int8)this->m_VehicleAudioEntity.m_VehicleAudioSetting.BassSetting;
    if ( BassSetting == 2 )
    {
      LOBYTE(BassSetting) = 0;
      goto LABEL_25;
    }
    if ( BassSetting != 1 )
    {
      if ( this->m_VehicleAudioEntity.m_VehicleAudioSetting.BassSetting )
      {
LABEL_26:
        CAudioEngine::SetRadioBassSetting(&AudioEngine, BassSetting);
        *((_DWORD *)&this->m_nVehicleFlags + 1) |= 0x100000u;
        return 1;
      }
      LOBYTE(BassSetting) = 1;
LABEL_25:
      this->m_VehicleAudioEntity.m_VehicleAudioSetting.BassSetting = BassSetting;
      goto LABEL_26;
    }
    return 1;
  }
  if ( upgrade != 16 )
    return 0;
  hFlagsLocal = this->hFlagsLocal;
  if ( (hFlagsLocal & 0x20000) != 0 )
  {
    *replacing = modelId;
    hFlagsLocal = this->hFlagsLocal;
  }
  this->m_nNoOfStaticFrames = 0;
  this->hFlagsLocal = hFlagsLocal | 0x20000;
  result = 1;
  this->m_vecMoveSpeed.z = 0.0;
  return result;
}

//----- (0058C958) --------------------------------------------------------
int32 __fastcall CVehicle::GetReplacementUpgrade(CVehicle *this, int32 component)
{
  RwFrame_0 *FrameFromId; // r0
  int32 v5; // [sp+0h] [bp-10h] BYREF
  RpAtomic_0 *pAtomic; // [sp+4h] [bp-Ch]

  FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, component);
  v5 = component;
  pAtomic = 0;
  RwFrameForAllObjects(FrameFromId, FindReplacementUpgradeCB, &v5);
  if ( pAtomic )
    return CVisibilityPlugins::GetModelInfoIndex(pAtomic);
  else
    return -1;
}

//----- (0058C990) --------------------------------------------------------
void __fastcall CVehicle::AddReplacementUpgrade(CVehicle *this, int32 modelId, int32 component)
{
  RwFrame_0 *FrameFromId; // r4
  CBaseModelInfo *v7; // r6
  char *parent; // r0
  CBaseModelInfo *v9; // r1
  int32 data[7]; // [sp+Ch] [bp-1Ch] BYREF

  FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, component);
  data[0] = 0;
  RwFrameForAllObjects(FrameFromId, RemoveObjectsCB, data);
  RwFrameForAllChildren(FrameFromId, RemoveObjectsCB, data);
  v7 = CModelInfo::ms_modelInfoPtrs[modelId];
  CVehicle::CreateReplacementAtomic(this, v7, FrameFromId, data[0], 0, 0);
  if ( component == 19 )
  {
    if ( (this->pHandling->mFlags & 0x2000) != 0 )
    {
      parent = (char *)CVehicle::CreateReplacementAtomic(this, v7, FrameFromId, data[0], 0, 1)->object.object.parent;
      *((float *)parent + 16) = FrameFromId->modelling.pos.x * -2.0;
      RwMatrixUpdate((RwMatrix *)(parent + 16));
    }
  }
  else if ( (component | 1) == 13 )
  {
    v9 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
    CCustomCarPlateMgr::SetupClumpAfterVehicleUpgrade(
      (RpClump_0 *)this->m_pRwObject,
      (RpMaterial_0 *)v9[1].m_hashKey,
      v9[1].m_modelName[9]);
  }
  if ( (*((int (__fastcall **)(CBaseModelInfo *))v7->_vptr$CBaseModelInfo + 3))(v7) )
  {
    CVehicle::CreateReplacementAtomic(this, v7, FrameFromId, data[0], 1, 0);
    if ( FrameFromId )
    {
      RwFrameForAllObjects(FrameFromId, SetVehicleAtomicVisibilityCB, (char *)&dword_0 + 1);
      RwFrameForAllChildren(FrameFromId, SetVehicleAtomicVisibilityCB, (char *)&dword_0 + 1);
    }
  }
}
// 0: using guessed type int dword_0;

//----- (0058CAAC) --------------------------------------------------------
int32 __fastcall CVehicle::GetUpgrade(CVehicle *this, int32 upgrade)
{
  __int16 **v5; // r0
  int32 v6; // [sp+0h] [bp-10h] BYREF
  RpAtomic_0 *pAtomic; // [sp+4h] [bp-Ch]

  v6 = upgrade;
  pAtomic = 0;
  RpClumpForAllAtomics((RpClump_0 *)this->m_pRwObject, FindUpgradeCB, &v6);
  if ( pAtomic )
    return CVisibilityPlugins::GetModelInfoIndex(pAtomic);
  if ( upgrade == 15 )
  {
    if ( (this->hFlagsLocal & 0x80000) != 0 )
    {
      v5 = MI_NITRO_BOTTLE_SMALL_ptr;
      return (unsigned __int16)**v5;
    }
    return -1;
  }
  if ( upgrade == 17 )
  {
    if ( (*((_BYTE *)&this->m_nVehicleFlags + 6) & 0x10) != 0 )
    {
      v5 = (__int16 **)&MI_STEREO_UPGRADE_ptr;
      return (unsigned __int16)**v5;
    }
    return -1;
  }
  if ( upgrade != 16 || (this->hFlagsLocal & 0x20000) == 0 )
    return -1;
  v5 = MI_HYDRAULICS_ptr;
  return (unsigned __int16)**v5;
}
// 6767A0: using guessed type __int16 *MI_HYDRAULICS_ptr[3];
// 676964: using guessed type __int16 *MI_NITRO_BOTTLE_SMALL_ptr[2];

//----- (0058CB2C) --------------------------------------------------------
void __fastcall CVehicle::AddUpgrade(CVehicle *this, int32 modelId, int32 upgrade)
{
  CBaseModelInfo *v5; // r10
  CBaseModelInfo *v6; // r8
  int v7; // r6
  RwFrame_0 *FrameFromId; // r9
  const UpgradePosnDesc *v9; // r11
  int v10; // r0
  int v11; // r0
  CBaseModelInfo *v12; // r1

  v5 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v6 = CModelInfo::ms_modelInfoPtrs[modelId];
  v7 = v5[2].m_hashKey + 32 * upgrade;
  FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, *(_DWORD *)(v7 + 208));
  RpClumpForAllAtomics((RpClump_0 *)this->m_pRwObject, RemoveUpgradeCB, (void *)upgrade);
  v9 = (const UpgradePosnDesc *)(v7 + 180);
  CVehicle::CreateUpgradeAtomic(this, v6, (const UpgradePosnDesc *)(v7 + 180), FrameFromId, 0);
  if ( *(_DWORD *)(v7 + 208) != 1 )
  {
    v10 = 4;
    switch ( upgrade )
    {
      case 0:
        v10 = 3;
        goto LABEL_7;
      case 1:
        goto LABEL_7;
      case 2:
        v10 = 5;
        goto LABEL_7;
      case 6:
        v10 = 7;
        goto LABEL_7;
      case 12:
        v10 = 13;
LABEL_7:
        v11 = v5[2].m_hashKey + 32 * v10;
        if ( *(_DWORD *)(v11 + 208) != -1 )
          v9 = (const UpgradePosnDesc *)(v11 + 180);
        break;
      default:
        break;
    }
    CVehicle::CreateUpgradeAtomic(this, v6, v9, FrameFromId, 1);
    if ( FrameFromId )
    {
      RwFrameForAllObjects(FrameFromId, SetVehicleAtomicVisibilityCB, (char *)&dword_0 + 1);
      RwFrameForAllChildren(FrameFromId, SetVehicleAtomicVisibilityCB, (char *)&dword_0 + 1);
    }
    v12 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
    CCustomCarPlateMgr::SetupClumpAfterVehicleUpgrade(
      (RpClump_0 *)this->m_pRwObject,
      (RpMaterial_0 *)v12[1].m_hashKey,
      v12[1].m_modelName[9]);
  }
}
// 0: using guessed type int dword_0;

//----- (0058CC2C) --------------------------------------------------------
void __fastcall CVehicle::RemoveVehicleUpgrade(CVehicle *this, int32 modelId)
{
  CBaseModelInfo *v4; // r6
  int OtherUpgrade; // r0
  unsigned int m_flags; // r1
  int v7; // r11
  RpClump_0 *m_pRwObject; // r0
  int v9; // r6
  RwFrame_0 *FrameFromId; // r8
  RwFrame_0 *v11; // r0
  RpClump_0 *v12; // r0
  RwFrame_0 *v13; // r6
  RwFrame_0 *v14; // r0
  RwFrame_0 *v15; // r0
  RwFrame_0 *v16; // r6
  RwFrame_0 *v17; // r0
  RwFrame_0 *v18; // r6
  RwFrame_0 *v19; // r0
  unsigned int v20; // r1
  RpClump_0 *v21; // r0
  int v22; // r6
  RwFrame_0 *v23; // r8
  RwFrame_0 *v24; // r0
  int data[8]; // [sp+18h] [bp-20h] BYREF

  v4 = CModelInfo::ms_modelInfoPtrs[modelId];
  if ( CVehicle::ClearVehicleUpgradeFlags(this, modelId, (v4->m_flags >> 10) & 0x1F) )
    return;
  OtherUpgrade = CVehicleModelInfo::CLinkedUpgradeList::FindOtherUpgrade(&CVehicleModelInfo::ms_linkedUpgrades, modelId);
  m_flags = v4->m_flags;
  v7 = OtherUpgrade;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  v9 = (m_flags >> 10) & 0x1F;
  if ( (m_flags & 0x100) != 0 )
  {
    FrameFromId = CClumpModelInfo::GetFrameFromId(m_pRwObject, (m_flags >> 10) & 0x1F);
    data[0] = 0;
    RwFrameForAllObjects(FrameFromId, RemoveObjectsCB, data);
    RwFrameForAllChildren(FrameFromId, RemoveObjectsCB, data);
    v11 = CClumpModelInfo::GetFrameFromId(
            (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pRwObject,
            v9);
    gpClumpToAddTo = (RpClump_0 *)this->m_pRwObject;
    RwFrameForAllObjects(v11, CopyObjectsCB, FrameFromId);
    if ( v9 == 2 )
    {
      v12 = (RpClump_0 *)this->m_pRwObject;
      this->m_wheelScale = 1.0;
      v13 = CClumpModelInfo::GetFrameFromId(v12, 5);
      data[0] = 0;
      RwFrameForAllObjects(v13, RemoveObjectsCB, data);
      RwFrameForAllChildren(v13, RemoveObjectsCB, data);
      v14 = CClumpModelInfo::GetFrameFromId(
              (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pRwObject,
              5);
      gpClumpToAddTo = (RpClump_0 *)this->m_pRwObject;
      RwFrameForAllObjects(v14, CopyObjectsCB, v13);
      v15 = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, 4);
      data[0] = 0;
      v16 = v15;
      RwFrameForAllObjects(v15, RemoveObjectsCB, data);
      RwFrameForAllChildren(v16, RemoveObjectsCB, data);
      v17 = CClumpModelInfo::GetFrameFromId(
              (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pRwObject,
              4);
      gpClumpToAddTo = (RpClump_0 *)this->m_pRwObject;
      RwFrameForAllObjects(v17, CopyObjectsCB, v16);
      v18 = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, 7);
      data[0] = 0;
      RwFrameForAllObjects(v18, RemoveObjectsCB, data);
      RwFrameForAllChildren(v18, RemoveObjectsCB, data);
      v19 = CClumpModelInfo::GetFrameFromId(
              (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pRwObject,
              7);
      gpClumpToAddTo = (RpClump_0 *)this->m_pRwObject;
      RwFrameForAllObjects(v19, CopyObjectsCB, v18);
    }
    if ( v7 == -1 )
      goto LABEL_11;
    goto LABEL_8;
  }
  RpClumpForAllAtomics(m_pRwObject, RemoveUpgradeCB, (void *)((m_flags >> 10) & 0x1F));
  if ( v7 != -1 )
  {
LABEL_8:
    v20 = CModelInfo::ms_modelInfoPtrs[v7]->m_flags;
    v21 = (RpClump_0 *)this->m_pRwObject;
    v22 = (v20 >> 10) & 0x1F;
    if ( (v20 & 0x100) != 0 )
    {
      v23 = CClumpModelInfo::GetFrameFromId(v21, (v20 >> 10) & 0x1F);
      data[0] = 0;
      RwFrameForAllObjects(v23, RemoveObjectsCB, data);
      RwFrameForAllChildren(v23, RemoveObjectsCB, data);
      v24 = CClumpModelInfo::GetFrameFromId(
              (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pRwObject,
              v22);
      gpClumpToAddTo = (RpClump_0 *)this->m_pRwObject;
      RwFrameForAllObjects(v24, CopyObjectsCB, v23);
    }
    else
    {
      RpClumpForAllAtomics(v21, RemoveUpgradeCB, (void *)((v20 >> 10) & 0x1F));
    }
  }
LABEL_11:
  if ( this->m_upgrades[0] == modelId )
    this->m_upgrades[0] = -1;
  if ( this->m_upgrades[1] == modelId )
    this->m_upgrades[1] = -1;
  if ( this->m_upgrades[2] == modelId )
    this->m_upgrades[2] = -1;
  if ( this->m_upgrades[3] == modelId )
    this->m_upgrades[3] = -1;
  if ( this->m_upgrades[4] == modelId )
    this->m_upgrades[4] = -1;
  if ( this->m_upgrades[5] == modelId )
    this->m_upgrades[5] = -1;
  if ( this->m_upgrades[6] == modelId )
    this->m_upgrades[6] = -1;
  if ( this->m_upgrades[7] == modelId )
    this->m_upgrades[7] = -1;
  if ( this->m_upgrades[8] == modelId )
    this->m_upgrades[8] = -1;
  if ( this->m_upgrades[9] == modelId )
    this->m_upgrades[9] = -1;
  if ( this->m_upgrades[10] == modelId )
    this->m_upgrades[10] = -1;
  if ( this->m_upgrades[11] == modelId )
    this->m_upgrades[11] = -1;
  if ( this->m_upgrades[12] == modelId )
    this->m_upgrades[12] = -1;
  if ( this->m_upgrades[13] == modelId )
    this->m_upgrades[13] = -1;
  if ( this->m_upgrades[14] == modelId )
    this->m_upgrades[14] = -1;
}

//----- (0058CF90) --------------------------------------------------------
bool __fastcall CVehicle::ClearVehicleUpgradeFlags(CVehicle *this, int32 modelId, int32 upgrade)
{
  uint32 hFlagsLocal; // r0
  int m_nSpecialColModel; // r1
  int (**v6)(void); // r0
  int BassSetting; // r1

  if ( upgrade == 15 )
  {
    if ( this->m_baseVehicleType )
      return 0;
    CAutomobile::NitrousControl((CAutomobile *)this, -1);
    return *(int *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 688) < 0;
  }
  if ( upgrade == 17 )
  {
    if ( this->m_VehicleAudioEntity.m_VehicleAudioSetting.RadioType
      || (*((_BYTE *)&this->m_nVehicleFlags + 6) & 0x10) == 0 )
    {
      return 1;
    }
    BassSetting = (unsigned __int8)this->m_VehicleAudioEntity.m_VehicleAudioSetting.BassSetting;
    if ( BassSetting == 1 )
    {
      LOBYTE(BassSetting) = 0;
    }
    else
    {
      if ( this->m_VehicleAudioEntity.m_VehicleAudioSetting.BassSetting )
      {
LABEL_19:
        CAudioEngine::SetRadioBassSetting(&AudioEngine, BassSetting);
        *((_DWORD *)&this->m_nVehicleFlags + 1) &= ~0x100000u;
        return 1;
      }
      LOBYTE(BassSetting) = 2;
    }
    this->m_VehicleAudioEntity.m_VehicleAudioSetting.BassSetting = BassSetting;
    goto LABEL_19;
  }
  if ( upgrade != 16 )
    return 0;
  hFlagsLocal = this->hFlagsLocal;
  if ( (hFlagsLocal & 0x20000) != 0 )
  {
    m_nSpecialColModel = this->m_nSpecialColModel;
    if ( m_nSpecialColModel >= 0 )
    {
      CVehicle::m_aSpecialColVehicle[m_nSpecialColModel] = 0;
      v6 = this->_vptr$CPlaceable;
      this->m_nSpecialColModel = -1;
      ((void (__fastcall *)(CVehicle *))v6[49])(this);
      hFlagsLocal = this->hFlagsLocal;
      this->m_vecMoveSpeed.z = 0.02;
      this->m_nNoOfStaticFrames = 0;
    }
  }
  this->hFlagsLocal = hFlagsLocal & 0xFFFDFFFF;
  return 1;
}

//----- (0058D068) --------------------------------------------------------
void __fastcall CVehicle::RemoveReplacementUpgrade(CVehicle *this, int32 component)
{
  RwFrame_0 *FrameFromId; // r5
  RwFrame_0 *v5; // r0
  int data[5]; // [sp+4h] [bp-14h] BYREF

  FrameFromId = CClumpModelInfo::GetFrameFromId((RpClump_0 *)this->m_pRwObject, component);
  data[0] = 0;
  RwFrameForAllObjects(FrameFromId, RemoveObjectsCB, data);
  RwFrameForAllChildren(FrameFromId, RemoveObjectsCB, data);
  v5 = CClumpModelInfo::GetFrameFromId(
         (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pRwObject,
         component);
  gpClumpToAddTo = (RpClump_0 *)this->m_pRwObject;
  RwFrameForAllObjects(v5, CopyObjectsCB, FrameFromId);
}

//----- (0058D0E8) --------------------------------------------------------
void __fastcall CVehicle::RemoveUpgrade(CVehicle *this, int32 upgrade)
{
  sub_18E410((RpClump_0 *)this->m_pRwObject, RemoveUpgradeCB, (void *)upgrade);
}

//----- (0058D0FC) --------------------------------------------------------
RpAtomic_0 *__fastcall RemoveUpgradeCB(RpAtomic_0 *pAtomic, void *data)
{
  unsigned int m_flags; // r1
  bool v5; // zf
  CBaseModelInfo *ModelInfo; // r5
  RwFrame_0 *parent; // r6

  if ( (CVisibilityPlugins::GetAtomicId(pAtomic) & 0x800) != 0 )
  {
    m_flags = CVisibilityPlugins::GetModelInfo(pAtomic)->m_flags;
    v5 = (m_flags & 0x100) == 0;
    if ( (m_flags & 0x100) == 0 )
      v5 = ((m_flags >> 10) & 0x1F) == (_DWORD)data;
    if ( v5 )
    {
      ModelInfo = CVisibilityPlugins::GetModelInfo(pAtomic);
      parent = (RwFrame_0 *)pAtomic->object.object.parent;
      RpClumpRemoveAtomic(pAtomic->clump, pAtomic);
      RpAtomicDestroy(pAtomic);
      RwFrameDestroy(parent);
      if ( ModelInfo )
        CBaseModelInfo::RemoveRef(ModelInfo);
    }
  }
  return pAtomic;
}

//----- (0058D158) --------------------------------------------------------
RpAtomic_0 *__fastcall FindUpgradeCB(RpAtomic_0 *pAtomic, void *data)
{
  RpAtomic_0 *v3; // r4

  v3 = pAtomic;
  if ( (CVisibilityPlugins::GetAtomicId(pAtomic) & 0x800) != 0
    && *(_DWORD *)data == (unsigned __int16)(CVisibilityPlugins::GetModelInfo(v3)->m_flags & 0x7C00) >> 10 )
  {
    *((_DWORD *)data + 1) = v3;
    return 0;
  }
  return v3;
}

//----- (0058D186) --------------------------------------------------------
RwObject_0 *__fastcall RemoveObjectsCB(RwObject_0 *pObject, void *pData)
{
  int32 AtomicId; // r0
  CBaseModelInfo *ModelInfo; // r5
  RwFrame_0 *parent; // r6

  if ( pObject->type == 1 )
  {
    AtomicId = CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)pObject);
    *(_DWORD *)pData = AtomicId;
    if ( (AtomicId & 0x800) == 0 )
    {
      ModelInfo = CVisibilityPlugins::GetModelInfo((RpAtomic_0 *)pObject);
      parent = (RwFrame_0 *)pObject->parent;
      RpClumpRemoveAtomic((RpClump_0 *)pObject[7].parent, (RpAtomic_0 *)pObject);
      RpAtomicDestroy((RpAtomic_0 *)pObject);
      if ( !CVisibilityPlugins::GetFrameHierarchyId(parent) )
        RwFrameDestroy(parent);
      if ( ModelInfo )
        CBaseModelInfo::RemoveRef(ModelInfo);
    }
  }
  return pObject;
}

//----- (0058D1E0) --------------------------------------------------------
RwFrame_0 *__fastcall RemoveObjectsCB(RwFrame_0 *pFrame, void *pData)
{
  RwFrameForAllObjects(pFrame, RemoveObjectsCB, pData);
  RwFrameForAllChildren(pFrame, RemoveObjectsCB, pData);
  return pFrame;
}

//----- (0058D210) --------------------------------------------------------
RwObject_0 *__fastcall CopyObjectsCB(RwObject_0 *pObject, void *pData)
{
  RpAtomic_0 *v4; // r6

  if ( pObject->type == 1 )
  {
    v4 = RpAtomicClone((RpAtomic_0 *)pObject);
    RpClumpAddAtomic(gpClumpToAddTo, v4);
    RpAtomicSetFrame(v4, (RwFrame_0 *)pData);
  }
  return pObject;
}

//----- (0058D24C) --------------------------------------------------------
RwObject_0 *__fastcall FindReplacementUpgradeCB(RwObject_0 *pObject, void *data)
{
  RpAtomic_0 *v2; // r4

  v2 = (RpAtomic_0 *)pObject;
  if ( pObject->type == 1
    && (CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)pObject) & 0x800) == 0
    && CVisibilityPlugins::GetModelInfoIndex(v2) != -1 )
  {
    *((_DWORD *)data + 1) = v2;
    return 0;
  }
  return &v2->object.object;
}

//----- (0058D278) --------------------------------------------------------
RpAtomic_0 *__fastcall RemoveAllUpgradesCB(RpAtomic_0 *pAtomic, void *pData)
{
  CBaseModelInfo *ModelInfo; // r5

  ModelInfo = CVisibilityPlugins::GetModelInfo(pAtomic);
  if ( ModelInfo )
  {
    RpClumpRemoveAtomic(pAtomic->clump, pAtomic);
    RpAtomicDestroy(pAtomic);
    CBaseModelInfo::RemoveRef(ModelInfo);
  }
  return pAtomic;
}

//----- (0058D2A0) --------------------------------------------------------
RpAtomic_0 *__fastcall CVehicle::CreateUpgradeAtomic(
        CVehicle *this,
        CBaseModelInfo *pUpgradeModel,
        const UpgradePosnDesc *pUpgradeDesc,
        RwFrame_0 *pParentFrame,
        int bDamaged)
{
  RpAtomic_0 *v9; // r4
  RwFrame_0 *parent; // r5
  __int64 v11; // d16
  int32 v12; // r1
  char pData[29]; // [sp+3h] [bp-1Dh] BYREF

  if ( bDamaged == 1 )
    CDamageAtomicModelInfo::m_bCreateDamagedVersion = 1;
  v9 = (RpAtomic_0 *)(*((int (__fastcall **)(CBaseModelInfo *))pUpgradeModel->_vptr$CBaseModelInfo + 11))(pUpgradeModel);
  parent = (RwFrame_0 *)v9->object.object.parent;
  CQuaternion::Get(&pUpgradeDesc->quat, &parent->modelling);
  v11 = *(_QWORD *)&pUpgradeDesc->posn.x;
  parent->modelling.pos.z = pUpgradeDesc->posn.z;
  *(_QWORD *)&parent->modelling.pos.x = v11;
  RwMatrixUpdate(&parent->modelling);
  RpClumpAddAtomic((RpClump_0 *)this->m_pRwObject, v9);
  RwFrameAddChild(pParentFrame, parent);
  CBaseModelInfo::AddRef(pUpgradeModel);
  if ( bDamaged )
    v12 = 2;
  else
    v12 = 1;
  CVisibilityPlugins::SetAtomicId(v9, v12);
  CVisibilityPlugins::SetAtomicFlag(v9, 0x800u);
  CVisibilityPlugins::SetAtomicFlag(v9, 0x400u);
  pData[0] = 0;
  RpGeometryForAllMaterials(v9->geometry, CVehicleModelInfo::HasAlphaMaterialCB, pData);
  if ( pData[0] )
  {
    CVisibilityPlugins::SetAtomicRenderCallback(v9, CVisibilityPlugins::RenderVehicleHiDetailAlphaCB);
    CVisibilityPlugins::SetAtomicFlag(v9, 0x40u);
  }
  else
  {
    CVisibilityPlugins::SetAtomicRenderCallback(v9, CVisibilityPlugins::RenderVehicleHiDetailCB);
  }
  CVehicleModelInfo::SetRenderPipelinesCB(v9, 0);
  CDamageAtomicModelInfo::m_bCreateDamagedVersion = 0;
  return v9;
}
// 67957C: using guessed type void *CVisibilityPlugins::RenderVehicleHiDetailAlphaCB;
// 679BB4: using guessed type void *CVisibilityPlugins::RenderVehicleHiDetailCB;
// 58D2A0: using guessed type char pData[29];

//----- (0058D39C) --------------------------------------------------------
RpAtomic_0 *__fastcall CVehicle::CreateReplacementAtomic(
        CVehicle *this,
        CBaseModelInfo *pUpgradeModel,
        RwFrame_0 *pParentFrame,
        int32 flags,
        int a5,
        int a6)
{
  RpAtomic_0 *v10; // r4
  RwFrame_0 *parent; // r5
  uint16 v12; // r1
  void **v13; // r0
  char pData[29]; // [sp+3h] [bp-1Dh] BYREF

  if ( a5 == 1 )
    CDamageAtomicModelInfo::m_bCreateDamagedVersion = 1;
  v10 = (RpAtomic_0 *)(*((int (__fastcall **)(CBaseModelInfo *))pUpgradeModel->_vptr$CBaseModelInfo + 11))(pUpgradeModel);
  CBaseModelInfo::AddRef(pUpgradeModel);
  parent = (RwFrame_0 *)v10->object.object.parent;
  RpClumpAddAtomic((RpClump_0 *)this->m_pRwObject, v10);
  if ( a6 == 1 )
  {
    parent->modelling.up.y = 1.0;
    parent->modelling.up.x = 0.0;
    parent->modelling.right.y = 0.0;
    parent->modelling.right.z = 0.0;
    parent->modelling.up.z = 0.0;
    parent->modelling.at.x = 0.0;
    parent->modelling.at.y = 0.0;
    parent->modelling.at.z = 1.0;
    parent->modelling.pos.x = 0.0;
    parent->modelling.pos.y = 0.0;
    parent->modelling.pos.z = 0.0;
    parent->modelling.right.x = 1.0;
    parent->modelling.flags |= 0x20003u;
    RwMatrixUpdate(&parent->modelling);
    CVisibilityPlugins::SetFrameHierarchyId(parent, 0);
    RwFrameAddChild(pParentFrame, parent);
  }
  else
  {
    RpAtomicSetFrame(v10, pParentFrame);
    RwFrameDestroy(parent);
  }
  CVisibilityPlugins::SetAtomicId(v10, flags & 0xFFFFFFFC);
  if ( a5 == 1 )
    v12 = 2;
  else
    v12 = 1;
  CVisibilityPlugins::SetAtomicFlag(v10, v12);
  pData[0] = 0;
  RpGeometryForAllMaterials(v10->geometry, CVehicleModelInfo::HasAlphaMaterialCB, pData);
  if ( pData[0] )
    v13 = &CVisibilityPlugins::RenderVehicleHiDetailAlphaCB;
  else
    v13 = &CVisibilityPlugins::RenderVehicleHiDetailCB;
  CVisibilityPlugins::SetAtomicRenderCallback(v10, (RpAtomicCallBackRender)*v13);
  CVehicleModelInfo::SetRenderPipelinesCB(v10, 0);
  CDamageAtomicModelInfo::m_bCreateDamagedVersion = 0;
  return v10;
}
// 67957C: using guessed type void *CVisibilityPlugins::RenderVehicleHiDetailAlphaCB;
// 679BB4: using guessed type void *CVisibilityPlugins::RenderVehicleHiDetailCB;
// 58D39C: using guessed type char pData[29];

//----- (0058D4AC) --------------------------------------------------------
void __fastcall CVehicle::SetupUpgradesAfterLoad(CVehicle *this)
{
  int v2; // r5
  int v3; // r1

  v2 = -15;
  do
  {
    v3 = (unsigned __int16)this->m_upgrades[v2 + 15];
    if ( v3 != 0xFFFF )
    {
      this->m_upgrades[v2 + 15] = -1;
      CVehicle::AddVehicleUpgrade(this, (__int16)v3);
    }
    ++v2;
  }
  while ( v2 * 2 );
}

//----- (0058D4DE) --------------------------------------------------------
int32 __fastcall CVehicle::GetSpareHasslePosId(CVehicle *this)
{
  int32 m_vehicleType; // r1
  int32 v2; // r1
  int m_hassleStatus; // r2
  int32 result; // r0

  m_vehicleType = this->m_vehicleType;
  if ( (unsigned int)(m_vehicleType - 9) < 2 )
  {
LABEL_4:
    v2 = 2;
    goto LABEL_6;
  }
  if ( m_vehicleType )
  {
    if ( m_vehicleType != 2 )
      return -1;
    goto LABEL_4;
  }
  v2 = 6;
LABEL_6:
  m_hassleStatus = this->m_hassleStatus;
  result = 0;
  while ( ((1 << result) & m_hassleStatus) != 0 )
  {
    if ( ++result >= v2 )
      return -1;
  }
  return result;
}

//----- (0058D516) --------------------------------------------------------
void __fastcall CVehicle::SetHasslePosId(CVehicle *this, int32 posId, bool used)
{
  uint8 m_hassleStatus; // r12
  int v4; // r1
  uint8 v5; // r3

  m_hassleStatus = this->m_hassleStatus;
  v4 = 1 << posId;
  v5 = v4 ^ m_hassleStatus;
  if ( used )
    v5 = v4 | m_hassleStatus;
  this->m_hassleStatus = v5;
}

//----- (0058D532) --------------------------------------------------------
void __fastcall CVehicle::InitWinch(CVehicle *this, Int32 ArgWinchType)
{
  *((_BYTE *)this + 1202) = (32 * ArgWinchType) & 0x60 | *((_BYTE *)this + 1202) & 0x9F;
}

//----- (0058D548) --------------------------------------------------------
void __fastcall CVehicle::UpdateWinch(CVehicle *this)
{
  int v2; // r0
  int *v3; // r1
  float v4; // s16
  Int32 Rope; // r0
  CRope *v6; // r0
  float m_fWinchHeight; // s6
  unsigned int ArgFixedAtNode; // r6
  CMatrix *m_pMat; // r1
  CVector v; // [sp+18h] [bp-38h] BYREF
  CVector v11; // [sp+24h] [bp-2Ch] BYREF

  v2 = (*((unsigned __int8 *)this + 1202) >> 5) & 3;
  if ( v2 )
  {
    v3 = dword_58D610;
    if ( v2 == 3 )
      v3 = &dword_58D610[1];
    v4 = *(float *)v3;
    Rope = CRopes::FindRope((u_native)&this->m_nFlags + 1);
    if ( Rope < 0 )
    {
      LOBYTE(ArgFixedAtNode) = 0;
    }
    else
    {
      v6 = &CRopes::aRopes[Rope];
      m_fWinchHeight = v6->m_fWinchHeight;
      ArgFixedAtNode = (unsigned int)(float)(m_fWinchHeight * 32.0);
      v4 = v4
         + (float)((float)(m_fWinchHeight * v6->m_RopeLength)
                 - (float)(v6->m_SegmentLength * (float)(int)(float)(m_fWinchHeight * 32.0)));
    }
    m_pMat = this->m_pMat;
    v.x = 0.0;
    v.y = 0.0;
    v.z = v4;
    operator*(&v11, m_pMat, &v);
    CRopes::RegisterRope(
      (u_native)&this->m_nFlags + 1,
      (*((unsigned __int8 *)this + 1202) >> 5) & 3,
      v11,
      0,
      ArgFixedAtNode,
      1,
      this,
      20000);
  }
}
// 58D610: using guessed type int dword_58D610[2];

//----- (0058D620) --------------------------------------------------------
void __fastcall CVehicle::RemoveWinch(CVehicle *this)
{
  Int32 Rope; // r0

  Rope = CRopes::FindRope((u_native)&this[29]);
  if ( Rope >= 0 )
    CRope::Remove(&CRopes::aRopes[Rope]);
  *((_BYTE *)this + 1202) &= 0x9Fu;
}

//----- (0058D658) --------------------------------------------------------
void __fastcall CVehicle::ReleasePickedUpEntityWithWinch(CVehicle *this)
{
  Int32 Rope; // r0

  Rope = CRopes::FindRope((u_native)&this->m_nFlags + 1);
  sub_196658(&CRopes::aRopes[Rope]);
}

//----- (0058D67C) --------------------------------------------------------
void __fastcall CVehicle::PickUpEntityWithWinch(CVehicle *this, CEntity *pToBePickedUp)
{
  Int32 Rope; // r0

  Rope = CRopes::FindRope((u_native)&this->m_nFlags + 1);
  sub_198D6C(&CRopes::aRopes[Rope], pToBePickedUp);
}

//----- (0058D6A4) --------------------------------------------------------
CPhysical *__fastcall CVehicle::QueryPickedUpEntityWithWinch(CVehicle *this)
{
  return CRopes::aRopes[CRopes::FindRope((u_native)&this->m_nFlags + 1)].m_pWinchCarriedObject;
}

//----- (0058D6C8) --------------------------------------------------------
float __fastcall CVehicle::GetRopeHeightForHeli(CVehicle *this)
{
  return CRopes::aRopes[CRopes::FindRope((u_native)&this->m_nFlags + 1)].m_fWinchHeight;
}

//----- (0058D6EC) --------------------------------------------------------
void __fastcall CVehicle::SetRopeHeightForHeli(CVehicle *this, float RopeHeight)
{
  CRopes::aRopes[CRopes::FindRope((u_native)&this->m_nFlags + 1)].m_fWinchHeight = RopeHeight;
}

//----- (0058D710) --------------------------------------------------------
bool __fastcall CVehicle::GetTowHitchPos(CVehicle *this, CVector *vecResult, bool bGenericPosOk, CVehicle *pVeh)
{
  bool result; // r0
  float y; // s2
  __int64 v8; // d16
  CVector v9; // [sp+0h] [bp-18h] BYREF

  result = 0;
  if ( bGenericPosOk )
  {
    vecResult->x = 0.0;
    y = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMax.y;
    vecResult->z = 0.0;
    vecResult->y = y + 1.0;
    operator*(&v9, this->m_pMat, vecResult);
    v8 = *(_QWORD *)&v9.x;
    vecResult->z = v9.z;
    result = 1;
    *(_QWORD *)&vecResult->x = v8;
  }
  return result;
}

//----- (0058D764) --------------------------------------------------------
bool __fastcall CVehicle::GetTowBarPos(CVehicle *this, CVector *vecResult, bool bGenericPosOk, CVehicle *pVeh)
{
  bool result; // r0
  float y; // s2
  __int64 v8; // d16
  CVector v9; // [sp+0h] [bp-18h] BYREF

  result = 0;
  if ( bGenericPosOk )
  {
    vecResult->x = 0.0;
    y = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.y;
    vecResult->z = 0.0;
    vecResult->y = y + -1.0;
    operator*(&v9, this->m_pMat, vecResult);
    v8 = *(_QWORD *)&v9.x;
    vecResult->z = v9.z;
    result = 1;
    *(_QWORD *)&vecResult->x = v8;
  }
  return result;
}

//----- (0058D7B8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CVehicle::UpdateTrailerLink(CVehicle *this, bool bApplyFullVelocityAtHookUp, bool bApplyDistToSpeed)
{
  float32x2_t v3; // d7
  float32x2_t v4; // d11
  _BOOL4 v6; // r6
  _BOOL4 v7; // r8
  float v8; // s16
  float v9; // s18
  float v10; // s20
  CVehicle *m_pTowingVehicle; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v13; // r2
  float32x2_t v14; // d1
  int m_nModelIndex; // r2
  bool v16; // zf
  float32x2_t v17; // d0
  RwReal v18; // s8
  float v19; // s6
  RwReal x; // r2
  RwReal v21; // r3
  CMatrix *v22; // r1
  float *p_tx; // r5
  float v24; // s26
  float v25; // s24
  float v26; // s22
  float v27; // s0
  CMatrix *v28; // r0
  float xz; // s0
  float yz; // s2
  float zz; // s4
  float v32; // s6
  float m_fMass; // s16
  float v34; // s0
  float vecOffset; // [sp+0h] [bp-B0h]
  CVector v1; // [sp+10h] [bp-A0h] BYREF
  CVector v37; // [sp+1Ch] [bp-94h] BYREF
  CVector v38; // [sp+28h] [bp-88h] BYREF
  CVector v39; // [sp+34h] [bp-7Ch] BYREF
  CVector v40; // [sp+40h] [bp-70h] BYREF
  CVector v41; // [sp+4Ch] [bp-64h] BYREF
  CVector v42; // [sp+58h] [bp-58h] BYREF
  CVector v43[6]; // [sp+64h] [bp-4Ch] BYREF
  CVector v44; // 0:r1.12

  v6 = bApplyDistToSpeed;
  memset(&v42, 0, sizeof(v42));
  v7 = bApplyFullVelocityAtHookUp;
  memset(v43, 0, 12);
  if ( !this->m_pTowingVehicle )
    goto LABEL_8;
  if ( (*(_BYTE *)&this->m_info & 0xF0) != 80 )
    goto LABEL_8;
  if ( (*((int (__fastcall **)(CVehicle *, CVector *, int))this->_vptr$CPlaceable + 60))(this, &v42, 1) != 1 )
    goto LABEL_8;
  if ( !(*((int (__fastcall **)(CVehicle *, CVector *, int, CVehicle *))this->m_pTowingVehicle->_vptr$CPlaceable + 61))(
          this->m_pTowingVehicle,
          v43,
          1,
          this) )
    goto LABEL_8;
  v8 = v43[0].x - v42.x;
  v9 = v43[0].y - v42.y;
  v10 = v43[0].z - v42.z;
  v4.n64_f32[0] = CTimer::ms_fTimeStep;
  v3.n64_u32[0] = 1060320051;
  if ( sqrtf((float)((float)(v8 * v8) + (float)(v9 * v9)) + (float)(v10 * v10)) > vmax_f32(v4, v3).n64_f32[0] )
    goto LABEL_8;
  m_pTowingVehicle = this->m_pTowingVehicle;
  m_pMat = this->m_pMat;
  v13 = m_pTowingVehicle->m_pMat;
  if ( (float)((float)((float)(v13->xy * m_pMat->xy) + (float)(v13->yy * m_pMat->yy)) + (float)(v13->zy * m_pMat->zy)) >= -0.4
    && (v14.n64_u32[1] = LODWORD(v13->xz),
        (float)((float)((float)(v14.n64_f32[1] * m_pMat->xz) + (float)(v13->yz * m_pMat->yz))
              + (float)(v13->zz * m_pMat->zz)) >= 0.0) )
  {
    m_nModelIndex = m_pTowingVehicle->m_nModelIndex;
    v16 = m_nModelIndex == 531;
    if ( m_nModelIndex != 531 )
      v16 = m_nModelIndex == 525;
    if ( !v16
      || TOWTRUCK_HOIST_DOWN_LIMIT - 100 >= LOWORD(m_pTowingVehicle[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity) )
    {
      v17.n64_u32[1] = LODWORD(m_pMat->tz);
      v18 = v42.y - m_pMat->ty;
      v19 = v42.z - v17.n64_f32[1];
      v42.x = v42.x - m_pMat->tx;
      x = v42.x;
      v42.y = v18;
      v21 = v18;
      v42.z = v42.z - v17.n64_f32[1];
      v22 = m_pTowingVehicle->m_pMat;
      p_tx = &v22->tx;
      if ( !v22 )
        p_tx = &m_pTowingVehicle->m_transform.m_translate.x;
      v43[0].x = v43[0].x - *p_tx;
      v43[0].y = v43[0].y - p_tx[1];
      vecOffset = v19;
      v43[0].z = v43[0].z - p_tx[2];
      CPhysical::GetSpeed(&v41, this, *(CVector *)&x);
      CPhysical::GetSpeed(&v40, this->m_pTowingVehicle, v43[0]);
      v24 = v40.x - v41.x;
      v25 = v40.y - v41.y;
      v26 = v40.z - v41.z;
      if ( v6 && !v7 )
      {
        v17.n64_u32[0] = 1.0;
        v14.n64_f32[0] = CTimer::ms_fTimeStep;
        v27 = 1.0 / vmax_f32(v14, v17).n64_f32[0];
        v26 = (float)(v10 * 0.3) * v27;
        v25 = (float)(v9 * 0.3) * v27;
        v24 = (float)(v8 * 0.3) * v27;
      }
      if ( this->m_vehicleType == 11 && *(float *)&this[1].m_upgrades[7] == -1000.0 )
      {
        v28 = this->m_pMat;
        xz = v28->xz;
        yz = v28->yz;
        zz = v28->zz;
        v32 = (float)((float)(v24 * xz) + (float)(v25 * yz)) + (float)(v26 * zz);
        v26 = v26 - (float)(zz * v32);
        v25 = v25 - (float)(yz * v32);
        v24 = v24 - (float)(xz * v32);
      }
      Multiply3x3(&v39, this->m_pMat, &this->m_vecCOM);
      v38.y = v25;
      v38.x = v24;
      v38.z = v26;
      CVector::Normalise(&v38);
      m_fMass = this->m_fMass;
      v1.x = v42.x - v39.x;
      v1.y = v42.y - v39.y;
      v1.z = v42.z - v39.z;
      CrossProduct(&v37, &v1, &v38);
      v34 = 1.0
          / (float)((float)(1.0 / m_fMass)
                  + (float)((float)((float)((float)(v37.x * v37.x) + (float)(v37.y * v37.y)) + (float)(v37.z * v37.z))
                          / this->m_fTurnMass));
      v44.x = v24 * v34;
      v44.y = v25 * v34;
      v44.z = v26 * v34;
      CPhysical::ApplyForce(this, v44, v42, 1);
    }
  }
  else
  {
LABEL_8:
    (*((void (__fastcall **)(CVehicle *))this->_vptr$CPlaceable + 63))(this);
  }
}
// 58D7B8: fragmented variable at r2.4 may be wrong
// 58D7B8: fragmented variable at r3.4 may be wrong

//----- (0058DB3C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CVehicle::UpdateTractorLink(CVehicle *this, bool bApplyFullVelocityAtHookUp, bool bApplyDistToSpeed)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d4
  _BOOL4 v6; // r8
  CVehicle *m_pVehicleBeingTowed; // r0
  _BOOL4 v8; // r6
  int m_nModelIndex; // r0
  float x; // s22
  bool v11; // zf
  __int64 v12; // kr00_8
  float v13; // s26
  float v14; // s30
  float v15; // s17
  CVehicle *v16; // r1
  CMatrix *m_pMat; // r0
  float *p_tx; // r2
  float v19; // s0
  float v20; // r3
  float v21; // s4
  CMatrix *v22; // r0
  CSimpleTransform *p_m_transform; // r2
  float v24; // s6
  float y; // s8
  float z; // s10
  float v27; // r2
  float v28; // s20
  float v29; // s18
  float v30; // s16
  CVehicle *v31; // r0
  float v32; // s0
  float v33; // s0
  float *p_xx; // r0
  float v35; // s0
  float v36; // s2
  float v37; // s4
  float v38; // s6
  float m_fMass; // s22
  float v40; // s0
  float vecOffset; // [sp+0h] [bp-C0h]
  CVector v1; // [sp+10h] [bp-B0h] BYREF
  CVector v43; // [sp+1Ch] [bp-A4h] BYREF
  CVector v44; // [sp+28h] [bp-98h] BYREF
  CVector v45; // [sp+34h] [bp-8Ch] BYREF
  CVector v46; // [sp+40h] [bp-80h] BYREF
  CVector v47; // [sp+4Ch] [bp-74h] BYREF
  float v48; // [sp+58h] [bp-68h] BYREF
  float v49; // [sp+5Ch] [bp-64h]
  float v50; // [sp+60h] [bp-60h]
  CVector v51[7]; // [sp+64h] [bp-5Ch] BYREF
  CVector v52; // 0:r1.12

  v6 = bApplyDistToSpeed;
  m_pVehicleBeingTowed = this->m_pVehicleBeingTowed;
  v8 = bApplyFullVelocityAtHookUp;
  if ( m_pVehicleBeingTowed )
  {
    v48 = 0.0;
    v49 = 0.0;
    v50 = 0.0;
    memset(v51, 0, 12);
    if ( (*((int (__fastcall **)(CVehicle *, float *, int, CVehicle *))m_pVehicleBeingTowed->_vptr$CPlaceable + 60))(
           m_pVehicleBeingTowed,
           &v48,
           1,
           this) == 1
      && (*((int (__fastcall **)(CVehicle *, CVector *, int, CVehicle *))this->_vptr$CPlaceable + 61))(
           this,
           v51,
           1,
           this->m_pVehicleBeingTowed) == 1 )
    {
      m_nModelIndex = this->m_nModelIndex;
      x = v51[0].x;
      v11 = m_nModelIndex == 531;
      v12 = *(_QWORD *)&v51[0].y;
      v13 = v48;
      v14 = v49;
      v15 = v50;
      if ( m_nModelIndex != 531 )
        v11 = m_nModelIndex == 525;
      if ( !v11
        || TOWTRUCK_HOIST_DOWN_LIMIT - 100 >= LOWORD(this[1].m_VehicleAudioEntity.m_SkidSound.ScratchSound.m_pAudioEntity) )
      {
        v16 = this->m_pVehicleBeingTowed;
        m_pMat = v16->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v16->m_transform.m_translate.x;
        v19 = v48 - *p_tx;
        v48 = v19;
        v49 = v49 - p_tx[1];
        v20 = v49;
        v21 = v50 - p_tx[2];
        v50 = v21;
        v22 = this->m_pMat;
        p_m_transform = (CSimpleTransform *)&v22->tx;
        if ( !v22 )
          p_m_transform = &this->m_transform;
        v24 = p_m_transform->m_translate.x;
        y = p_m_transform->m_translate.y;
        z = p_m_transform->m_translate.z;
        v27 = v19;
        vecOffset = v21;
        v51[0].x = v51[0].x - v24;
        v51[0].y = v51[0].y - y;
        v51[0].z = v51[0].z - z;
        CPhysical::GetSpeed(&v47, v16, *(CVector *)(&v20 - 1));
        CPhysical::GetSpeed(&v46, this, v51[0]);
        v28 = v47.x - v46.x;
        v29 = v47.y - v46.y;
        v30 = v47.z - v46.z;
        if ( v8 )
        {
          v31 = this->m_pVehicleBeingTowed;
        }
        else
        {
          v3.n64_u32[0] = 1.0;
          v31 = this->m_pVehicleBeingTowed;
          if ( v6 )
          {
            v4.n64_f32[0] = CTimer::ms_fTimeStep;
            v32 = 1.0 / vmax_f32(v4, v3).n64_f32[0];
            v30 = (float)((float)(v15 - *((float *)&v12 + 1)) * 0.1) * v32;
            v29 = (float)((float)(v14 - *(float *)&v12) * 0.1) * v32;
            v28 = (float)((float)(v13 - x) * 0.1) * v32;
          }
          else
          {
            v33 = (float)(1.0 - (float)(this->m_fMass / (float)(this->m_fMass + v31->m_fMass))) * 0.5;
            v30 = v30 * v33;
            v29 = v29 * v33;
            v28 = v28 * v33;
          }
        }
        if ( v31->m_vehicleType == 11 && *(float *)&v31[1].m_upgrades[7] == -1000.0 )
        {
          p_xx = &v31->m_pMat->xx;
          v35 = p_xx[8];
          v36 = p_xx[9];
          v37 = p_xx[10];
          v38 = (float)((float)(v28 * v35) + (float)(v29 * v36)) + (float)(v30 * v37);
          v30 = v30 - (float)(v37 * v38);
          v29 = v29 - (float)(v36 * v38);
          v28 = v28 - (float)(v35 * v38);
        }
        Multiply3x3(&v45, this->m_pMat, &this->m_vecCOM);
        v44.y = v29;
        v44.x = v28;
        v44.z = v30;
        CVector::Normalise(&v44);
        m_fMass = this->m_fMass;
        v1.x = v51[0].x - v45.x;
        v1.y = v51[0].y - v45.y;
        v1.z = v51[0].z - v45.z;
        CrossProduct(&v43, &v1, &v44);
        v40 = 1.0
            / (float)((float)(1.0 / m_fMass)
                    + (float)((float)((float)((float)(v43.x * v43.x) + (float)(v43.y * v43.y)) + (float)(v43.z * v43.z))
                            / this->m_fTurnMass));
        v52.x = v28 * v40;
        v52.y = v29 * v40;
        v52.z = v30 * v40;
        CPhysical::ApplyForce(this, v52, v51[0], 1);
        this->m_nNoOfStaticFrames = 0;
      }
    }
  }
}
// 58DB3C: fragmented variable at r3.4 may be wrong

//----- (0058DE3C) --------------------------------------------------------
float __fastcall CVehicle::FindWheelWidth(CVehicle *this, bool bRear)
{
  return 0.25;
}

//----- (0058DE44) --------------------------------------------------------
void __fastcall CVehicle::RenderDriverAndPassengers(CVehicle *this)
{
  CPed *pDriver; // r0
  CPed *v3; // r0
  CPed *v4; // r0
  CPed *v5; // r0
  CPed *v6; // r0
  CPed *v7; // r0
  CPed *v8; // r0
  CPed *v9; // r0
  CPed *v10; // r0

  if ( CMirrors::TypeOfMirror != 3 )
  {
    pDriver = this->pDriver;
    if ( pDriver && pDriver->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))pDriver->_vptr$CPlaceable + 19))(pDriver);
    v3 = this->pPassengers[0];
    if ( v3 && v3->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v3->_vptr$CPlaceable + 19))(v3);
    v4 = this->pPassengers[1];
    if ( v4 && v4->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v4->_vptr$CPlaceable + 19))(v4);
    v5 = this->pPassengers[2];
    if ( v5 && v5->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v5->_vptr$CPlaceable + 19))(v5);
    v6 = this->pPassengers[3];
    if ( v6 && v6->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v6->_vptr$CPlaceable + 19))(v6);
    v7 = this->pPassengers[4];
    if ( v7 && v7->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v7->_vptr$CPlaceable + 19))(v7);
    v8 = this->pPassengers[5];
    if ( v8 && v8->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v8->_vptr$CPlaceable + 19))(v8);
    v9 = this->pPassengers[6];
    if ( v9 && v9->m_nPedState == PED_DRIVING )
      (*((void (__fastcall **)(CPed *))v9->_vptr$CPlaceable + 19))(v9);
    v10 = this->pPassengers[7];
    if ( v10 )
    {
      if ( v10->m_nPedState == PED_DRIVING )
        (*((void (__fastcall **)(CPed *))v10->_vptr$CPlaceable + 19))(v10);
    }
  }
}

//----- (0058DF18) --------------------------------------------------------
void __fastcall CVehicle::ProcessWeapons(CVehicle *this)
{
  CVehicle *PlaneWeaponFiringStatus; // r1
  int m_nModelIndex; // r2
  eOrdnanceType v4; // r5
  _BOOL4 v5; // r0
  bool v6; // zf
  UInt8 m_SelectedWeapon; // r2
  UInt8 v8; // r2
  unsigned int v9; // r0
  int32 m_vehicleType; // r0
  UInt32 *p_m_TimeOfCreation; // r0
  UInt32 v12; // r5
  int v13; // r0
  int v14; // r6
  int i; // r4
  FxSystem_c *v16; // r0
  RwObject_0 *m_pRwObject; // r1
  RwMatrix *v18; // r1
  eOrdnanceType iType; // [sp+0h] [bp-18h] BYREF
  bool bFireGun; // [sp+7h] [bp-11h] BYREF

  if ( this->m_vehicleType == 4 && FindPlayerVehicle(-1, 0) == this && !*(_DWORD *)&this[1].m_comp1 )
    CWeaponEffects::ClearCrossHairImmediately(0);
  if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) != 0 )
    return;
  bFireGun = 0;
  iType = ORDNANCE_TYPE_NONE;
  if ( ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
  {
    PlaneWeaponFiringStatus = (CVehicle *)CVehicle::GetPlaneWeaponFiringStatus(this, &bFireGun, &iType);
    m_nModelIndex = this->m_nModelIndex;
    v4 = iType;
    v5 = bFireGun;
    if ( m_nModelIndex < 476 )
    {
      if ( m_nModelIndex != 425 )
      {
        v6 = m_nModelIndex == 447;
        if ( m_nModelIndex != 447 )
          v6 = m_nModelIndex == 464;
        if ( !v6 )
          goto LABEL_44;
        if ( bFireGun )
          m_SelectedWeapon = 1;
        else
          m_SelectedWeapon = this->m_SelectedWeapon;
        goto LABEL_43;
      }
      goto LABEL_21;
    }
    switch ( m_nModelIndex )
    {
      case 476:
        if ( bFireGun )
          m_SelectedWeapon = 1;
        else
          m_SelectedWeapon = this->m_SelectedWeapon;
        if ( iType == ORDNANCE_TYPE_PRIMARY )
          m_SelectedWeapon = 2;
        goto LABEL_43;
      case 520:
        if ( bFireGun )
          v8 = 1;
        else
          v8 = this->m_SelectedWeapon;
        this->m_SelectedWeapon = v8;
        if ( v4 != ORDNANCE_TYPE_SECONDARY )
        {
          if ( v4 == ORDNANCE_TYPE_PRIMARY )
            this->m_SelectedWeapon = 4;
          break;
        }
        m_SelectedWeapon = 3;
        goto LABEL_43;
      case 576:
LABEL_21:
        if ( bFireGun )
          m_SelectedWeapon = 1;
        else
          m_SelectedWeapon = this->m_SelectedWeapon;
        if ( iType == ORDNANCE_TYPE_PRIMARY )
          m_SelectedWeapon = 4;
LABEL_43:
        this->m_SelectedWeapon = m_SelectedWeapon;
        break;
    }
  }
  else
  {
    if ( (*((_BYTE *)&this->m_nVehicleFlags + 4) & 0x10) != 0 )
    {
      v5 = 1;
      bFireGun = 1;
      iType = ORDNANCE_TYPE_PRIMARY;
      if ( this->m_nModelIndex == 520 )
      {
        if ( this->m_SelectedWeapon == 3 )
        {
          v4 = ORDNANCE_TYPE_SECONDARY;
          PlaneWeaponFiringStatus = 0;
          v5 = 1;
          iType = ORDNANCE_TYPE_SECONDARY;
          goto LABEL_44;
        }
        PlaneWeaponFiringStatus = 0;
        v5 = 1;
      }
      else
      {
        PlaneWeaponFiringStatus = 0;
      }
      v4 = ORDNANCE_TYPE_PRIMARY;
      goto LABEL_44;
    }
    v5 = 0;
    v4 = ORDNANCE_TYPE_NONE;
    PlaneWeaponFiringStatus = 0;
  }
LABEL_44:
  switch ( this->m_SelectedWeapon )
  {
    case 1u:
      if ( v5 )
        CVehicle::FirePlaneGuns(this);
      goto LABEL_59;
    case 2u:
      if ( v4 )
        CVehicle::PossiblyDropFreeFallBombForPlayer(this, v4, 1);
      goto LABEL_59;
    case 3u:
      if ( v4 == ORDNANCE_TYPE_NONE )
        goto LABEL_59;
      if ( ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
      {
        if ( !PlaneWeaponFiringStatus )
          goto LABEL_59;
        goto LABEL_58;
      }
      v9 = this->AutoPilot.Mission - 35;
      if ( v9 <= 0x1C && ((1 << v9) & 0x11000001) != 0 )
      {
        PlaneWeaponFiringStatus = FindPlayerVehicle(-1, 0);
        if ( !PlaneWeaponFiringStatus )
          goto LABEL_59;
        goto LABEL_58;
      }
      PlaneWeaponFiringStatus = (CVehicle *)this->AutoPilot.pTargetEntity;
      if ( PlaneWeaponFiringStatus )
LABEL_58:
        CVehicle::FireHeatSeakingMissile(this, PlaneWeaponFiringStatus, v4, 1);
LABEL_59:
      m_vehicleType = this->m_vehicleType;
      if ( m_vehicleType == 4 )
      {
        p_m_TimeOfCreation = &this[1].m_TimeOfCreation;
      }
      else
      {
        if ( m_vehicleType != 3 )
          return;
        p_m_TimeOfCreation = (UInt32 *)&this[1].pPassengers[1];
      }
      v12 = *p_m_TimeOfCreation;
      if ( *p_m_TimeOfCreation )
      {
        v13 = this->m_nModelIndex;
        v14 = 1;
        if ( v13 < 520 )
        {
          switch ( this->m_nModelIndex )
          {
            case 0x1D0:
            case 0x1E7:
            case 0x1F1:
              goto LABEL_73;
            case 0x1D1:
            case 0x1D2:
            case 0x1D3:
            case 0x1D4:
            case 0x1D5:
            case 0x1D6:
            case 0x1D7:
            case 0x1D8:
            case 0x1D9:
            case 0x1DA:
            case 0x1DB:
            case 0x1DD:
            case 0x1DE:
            case 0x1DF:
            case 0x1E0:
            case 0x1E1:
            case 0x1E2:
            case 0x1E3:
            case 0x1E4:
            case 0x1E5:
            case 0x1E6:
            case 0x1E8:
            case 0x1E9:
            case 0x1EA:
            case 0x1EB:
            case 0x1EC:
            case 0x1ED:
            case 0x1EE:
            case 0x1EF:
            case 0x1F0:
              return;
            case 0x1DC:
              v14 = 6;
              goto LABEL_73;
            default:
              if ( v13 == 425 || v13 == 447 )
                goto LABEL_73;
              break;
          }
          return;
        }
        if ( v13 != 520 )
        {
          if ( v13 == 548 )
            goto LABEL_73;
          if ( v13 != 576 )
            return;
        }
        v14 = 2;
LABEL_73:
        for ( i = 0; i < v14; ++i )
        {
          v16 = *(FxSystem_c **)(v12 + 4 * i);
          if ( v16 )
          {
            m_pRwObject = this->m_pRwObject;
            if ( m_pRwObject )
              v18 = (RwMatrix *)((char *)m_pRwObject->parent + 16);
            else
              v18 = 0;
            FxSystem_c::SetMatrix(v16, v18);
          }
        }
      }
      return;
    case 4u:
      if ( v4 )
        CVehicle::FireUnguidedMissile(this, v4, 1);
      goto LABEL_59;
    default:
      goto LABEL_59;
  }
}

//----- (0058E174) --------------------------------------------------------
CEntity *__fastcall CVehicle::GetPlaneWeaponFiringStatus(CVehicle *this, bool *bFireGun, eOrdnanceType *iFireOrdnance)
{
  int32 PlayerSlotWithVehiclePointer; // r0
  CPad *Pad; // r6
  int m_nModelIndex; // r0
  bool v9; // zf
  TouchSense *v10; // r0
  CEntity *result; // r0
  TouchSense *v12; // r0
  int v13; // r5
  TouchSense *v14; // r0
  uint32 v15; // r4
  _BOOL4 v16; // r0
  bool v17; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  TouchSense *v20; // r0
  int IsLockedOn; // r0
  bool v22; // zf
  TouchSense *v23; // r0
  CEntity *v24; // r1
  uint32 v25; // r0
  unsigned int v26; // r3
  float v27; // s2
  bool v28; // cf
  uint8 v29; // r3
  CVector v30; // 0:r2.8,8:^0.4

  PlayerSlotWithVehiclePointer = CWorld::FindPlayerSlotWithVehiclePointer(this);
  Pad = CPad::GetPad(PlayerSlotWithVehiclePointer);
  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex < 476 )
  {
    if ( m_nModelIndex != 425 )
    {
      v9 = m_nModelIndex == 447;
      if ( m_nModelIndex != 447 )
        v9 = m_nModelIndex == 464;
      if ( !v9 )
        goto LABEL_38;
      if ( CPad::GetCarGunFired(Pad, 1, 1) == 2 )
        *bFireGun = 1;
      if ( this->m_nModelIndex == 464
        && CVehicle::bDisableRemoteDetonation
        && CHID::GetInputType() == 2
        && CPad::GetCarGunFired(Pad, 0, 0) == 1 )
      {
        TouchSense::instance();
        TouchSense::playBuiltinEffect(v10, 2, 86, 115, 20);
        *bFireGun = 1;
        result = 0;
LABEL_45:
        *iFireOrdnance = ORDNANCE_TYPE_NONE;
        return result;
      }
LABEL_19:
      result = 0;
      goto LABEL_45;
    }
    goto LABEL_20;
  }
  if ( m_nModelIndex == 576 )
  {
LABEL_20:
    v13 = 1;
    if ( CPad::GetCarGunFired(Pad, 1, 1) == 2 )
    {
      TouchSense::instance();
      TouchSense::playBuiltinEffect(v14, 2, 86, 115, 20);
      *bFireGun = 1;
    }
    else
    {
      v13 = 0;
    }
    if ( !CPad::UseRocket(Pad) )
    {
      result = 0;
      if ( v13 )
        return result;
      goto LABEL_44;
    }
    TouchSense::instance();
    TouchSense::playBuiltinEffect(v23, 2, 44, 115, 20);
LABEL_42:
    *iFireOrdnance = ORDNANCE_TYPE_PRIMARY;
    return 0;
  }
  if ( m_nModelIndex != 520 )
  {
    if ( m_nModelIndex != 476 )
    {
LABEL_38:
      result = 0;
LABEL_44:
      *bFireGun = 0;
      goto LABEL_45;
    }
    if ( CPad::GetCarGunFired(Pad, 1, 1) == 2 )
    {
      TouchSense::instance();
      TouchSense::playBuiltinEffect(v12, 2, 86, 115, 20);
      *bFireGun = 1;
    }
    goto LABEL_19;
  }
  *iFireOrdnance = ORDNANCE_TYPE_NONE;
  v15 = CTimer::m_snTimeInMilliseconds;
  v16 = CPad::FlareJustDown(Pad);
  v17 = !v16;
  if ( !v16 )
    v17 = !this->m_bFireAutoFlare;
  if ( !v17 )
  {
    if ( CTimer::m_snTimeInMilliseconds > this->TimeOfLastShotFired + 2000 )
    {
      m_pMat = this->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &this->m_transform;
      v30.x = p_tx->m_translate.x + (float)((float)(m_pMat->xy * -2.5) - m_pMat->xz);
      v30.y = p_tx->m_translate.y + (float)((float)(m_pMat->yy * -2.5) - m_pMat->yz);
      v30.z = p_tx->m_translate.z + (float)((float)(m_pMat->zy * -2.5) - m_pMat->zz);
      CProjectileInfo::AddProjectile(this, WEAPONTYPE_FLARE, v30, 0.0, (CVector *)&m_pMat->xy, 0);
      this->TimeOfLastShotFired = CTimer::m_snTimeInMilliseconds;
    }
    this->m_bFireAutoFlare = 0;
  }
  if ( CPad::UseRocket(Pad) )
  {
    TouchSense::instance();
    TouchSense::playBuiltinEffect(v20, 2, 44, 115, 20);
    IsLockedOn = CWeaponEffects::IsLockedOn(0);
    v22 = IsLockedOn == 0;
    if ( IsLockedOn )
      v22 = *(_DWORD *)&this[1].m_comp1 == 0;
    if ( !v22 )
    {
      result = CVehicle::ScanAndMarkTargetForHeatSeekingMissile(this, *(CEntity **)&this[1].m_upgrades[1]);
      if ( result )
      {
        if ( result == *(CEntity **)&this[1].m_upgrades[1] && v15 - *(_DWORD *)&this[1].m_comp1 > 0x5DC )
        {
          *iFireOrdnance = ORDNANCE_TYPE_SECONDARY;
          gCrossHair[0].m_blue = 0;
          *(_WORD *)&gCrossHair[0].m_red = 255;
          gCrossHair[0].m_bLockedOn = 1.0;
          gCrossHair[0].clearTargetTimer = 0;
          return result;
        }
      }
    }
    goto LABEL_42;
  }
  if ( CPad::GetTarget(Pad, 1) )
  {
    if ( !*(_DWORD *)&this[1].m_comp1 )
      *(_DWORD *)&this[1].m_comp1 = v15;
    v24 = CVehicle::ScanAndMarkTargetForHeatSeekingMissile(this, *(CEntity **)&this[1].m_upgrades[1]);
    if ( v24 && v24 == *(CEntity **)&this[1].m_upgrades[1] )
    {
      v25 = *(_DWORD *)&this[1].m_comp1;
    }
    else
    {
      v25 = v15;
      *(_DWORD *)&this[1].m_comp1 = v15;
    }
    v26 = v15 - v25;
    v27 = 0.0;
    result = 0;
    if ( v26 > 0x5DC )
      v27 = 1.0;
    v28 = v26 >= 0x5DD;
    v29 = 0;
    if ( !v28 )
      v29 = -1;
    gCrossHair[0].m_green = v29;
    gCrossHair[0].m_red = -1;
    gCrossHair[0].m_blue = v29;
    gCrossHair[0].clearTargetTimer = 0;
    gCrossHair[0].m_bLockedOn = v27;
    *(_DWORD *)&this[1].m_upgrades[1] = v24;
  }
  else
  {
    result = 0;
    *(_DWORD *)&this[1].m_comp1 = 0;
    *(_DWORD *)&this[1].m_upgrades[1] = 0;
  }
  return result;
}
// 58E1FC: variable 'v10' is possibly undefined
// 58E23A: variable 'v12' is possibly undefined
// 58E264: variable 'v14' is possibly undefined
// 58E340: variable 'v20' is possibly undefined
// 58E3B4: variable 'v23' is possibly undefined
// 14: using guessed type int dword_14;

//----- (0058E47C) --------------------------------------------------------
void __fastcall CVehicle::SelectPlaneWeapon(CVehicle *this, bool bFireGun, eOrdnanceType iFireOrdnance)
{
  int m_nModelIndex; // r12
  int m_SelectedWeapon; // r1
  int v5; // r1

  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex >= 476 )
  {
    if ( m_nModelIndex == 476 )
    {
      if ( bFireGun )
        LOBYTE(m_SelectedWeapon) = 1;
      else
        m_SelectedWeapon = this->m_SelectedWeapon;
      if ( iFireOrdnance == ORDNANCE_TYPE_PRIMARY )
        LOBYTE(m_SelectedWeapon) = 2;
      goto LABEL_30;
    }
    if ( m_nModelIndex == 520 )
    {
      if ( bFireGun )
        LOBYTE(v5) = 1;
      else
        v5 = this->m_SelectedWeapon;
      this->m_SelectedWeapon = v5;
      if ( iFireOrdnance == ORDNANCE_TYPE_SECONDARY )
      {
        LOBYTE(m_SelectedWeapon) = 3;
      }
      else
      {
        if ( iFireOrdnance != ORDNANCE_TYPE_PRIMARY )
          return;
        LOBYTE(m_SelectedWeapon) = 4;
      }
      goto LABEL_30;
    }
    if ( m_nModelIndex != 576 )
      return;
    goto LABEL_10;
  }
  if ( m_nModelIndex == 425 )
  {
LABEL_10:
    if ( bFireGun )
      LOBYTE(m_SelectedWeapon) = 1;
    else
      LOBYTE(m_SelectedWeapon) = this->m_SelectedWeapon;
    if ( iFireOrdnance == ORDNANCE_TYPE_PRIMARY )
      LOBYTE(m_SelectedWeapon) = 4;
    goto LABEL_30;
  }
  if ( m_nModelIndex == 447 || m_nModelIndex == 464 )
  {
    if ( bFireGun )
      LOBYTE(m_SelectedWeapon) = 1;
    else
      LOBYTE(m_SelectedWeapon) = this->m_SelectedWeapon;
LABEL_30:
    this->m_SelectedWeapon = m_SelectedWeapon;
  }
}

//----- (0058E500) --------------------------------------------------------
void __fastcall CVehicle::FirePlaneGuns(CVehicle *this)
{
  int m_nModelIndex; // r0
  bool v3; // zf
  int32 m_vehicleType; // r3
  uint8 *p_m_colour1; // r3
  float v6; // s0
  float v7; // s2
  eWeaponType v8; // r11
  UInt8 v9; // r8
  int v10; // r5
  char v11; // r0
  char v12; // r1
  int v13; // r0
  CMatrix *m_pMat; // r9
  int v15; // r2
  uint32 m_hashKey; // r1
  char v17; // r0
  __int64 v18; // d16
  RwReal v19; // r1
  int v20; // r1
  const CVector *v21; // r2
  __int64 v22; // d16
  float v23; // s0
  RwReal v24; // s2
  RwReal v25; // s4
  unsigned __int8 v26; // r0
  int v27; // r2
  float *v28; // r1
  float x; // s0
  float y; // s2
  float z; // s4
  int v32; // r1
  const CVector *v33; // r2
  float v34; // s6
  RwReal v35; // s2
  RwReal v36; // s4
  int32 v37; // r0
  CPad *Pad; // r0
  CPed *pDriver; // r0
  int32 m_nPedType; // r0
  CVector v41; // [sp+18h] [bp-60h] BYREF
  CVector pBarrelPosn; // [sp+24h] [bp-54h] BYREF
  CVector v; // [sp+30h] [bp-48h] BYREF
  CWeapon weapon; // [sp+40h] [bp-38h] BYREF

  m_nModelIndex = this->m_nModelIndex;
  v3 = m_nModelIndex == 520;
  if ( m_nModelIndex < 520 )
  {
    switch ( m_nModelIndex )
    {
      case 464:
      case 476:
      case 487:
      case 497:
        goto LABEL_10;
      case 465:
      case 466:
      case 467:
      case 468:
      case 469:
      case 470:
      case 471:
      case 472:
      case 473:
      case 474:
      case 475:
      case 477:
      case 478:
      case 479:
      case 480:
      case 481:
      case 482:
      case 483:
      case 484:
      case 485:
      case 486:
      case 488:
      case 489:
      case 490:
      case 491:
      case 492:
      case 493:
      case 494:
      case 495:
      case 496:
        return;
      default:
        if ( m_nModelIndex == 425 || m_nModelIndex == 447 )
          goto LABEL_10;
        break;
    }
    return;
  }
  if ( m_nModelIndex != 520 )
    v3 = m_nModelIndex == 576;
  if ( v3 || m_nModelIndex == 548 )
  {
LABEL_10:
    m_vehicleType = this->m_vehicleType;
    if ( m_vehicleType == 3 )
    {
      p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
    }
    else
    {
      if ( m_vehicleType != 4 )
      {
        v6 = 1.0;
LABEL_16:
        v7 = 60.0;
        if ( m_nModelIndex >= 520 )
        {
          switch ( m_nModelIndex )
          {
            case 520:
              v7 = 17.0;
              break;
            case 548:
              v7 = 100.0;
              break;
            case 576:
              v7 = 45.0;
              break;
          }
        }
        else if ( m_nModelIndex == 447 || m_nModelIndex == 464 )
        {
          v7 = 40.0;
        }
        else if ( m_nModelIndex == 476 )
        {
          v7 = 80.0;
        }
        if ( CTimer::m_snTimeInMilliseconds <= this->TimeOfLastShotFired + (int)(float)(v7 / v6) )
          return;
        v8 = WEAPONTYPE_MINIGUN;
        v9 = -96;
        v10 = 0;
        if ( m_nModelIndex >= 520 )
        {
          if ( m_nModelIndex != 520 )
          {
            if ( m_nModelIndex == 548 )
              goto LABEL_44;
            if ( m_nModelIndex != 576 )
              return;
          }
          v8 = WEAPONTYPE_MINIGUN;
          v9 = 0x80;
LABEL_40:
          v10 = 1;
        }
        else
        {
          switch ( m_nModelIndex )
          {
            case 464:
            case 487:
            case 497:
              goto LABEL_43;
            case 465:
            case 466:
            case 467:
            case 468:
            case 469:
            case 470:
            case 471:
            case 472:
            case 473:
            case 474:
            case 475:
            case 477:
            case 478:
            case 479:
            case 480:
            case 481:
            case 482:
            case 483:
            case 484:
            case 485:
            case 486:
            case 488:
            case 489:
            case 490:
            case 491:
            case 492:
            case 493:
            case 494:
            case 495:
            case 496:
              return;
            case 476:
              v11 = *((_BYTE *)this + 1203);
              v8 = WEAPONTYPE_M4;
              v9 = -32;
              v12 = v11 & 0xFC;
              v13 = (v11 + 1) & 3;
              if ( v13 != 3 )
                v12 |= v13;
              *((_BYTE *)this + 1203) = v12;
              goto LABEL_40;
            default:
              if ( m_nModelIndex == 425 )
                break;
              if ( m_nModelIndex != 447 )
                return;
LABEL_43:
              v8 = WEAPONTYPE_M4;
              v9 = 92;
              v10 = 0;
              break;
          }
        }
LABEL_44:
        m_pMat = this->m_pMat;
        CWeapon::CWeapon(&weapon, v8, 5000);
        v15 = this->m_nModelIndex;
        m_hashKey = CModelInfo::ms_modelInfoPtrs[v15][2].m_hashKey;
        v17 = *((_BYTE *)this + 1203);
        v18 = *(_QWORD *)(m_hashKey + 156);
        v19 = *(float *)(m_hashKey + 164);
        *(_QWORD *)&v.x = v18;
        v.z = v19;
        v20 = (unsigned __int16)v15;
        if ( *(float *)&v18 == 0.0 && v.y == 0.0 )
        {
          if ( v15 >= 520 )
          {
            switch ( v15 )
            {
              case 520:
                v21 = &s_HarrierGunPos;
                break;
              case 548:
                v21 = &s_CargoBobGunPos;
                break;
              case 576:
                v21 = &s_TornadoGunPos;
                break;
              default:
LABEL_59:
                memset(&v, 0, sizeof(v));
                if ( (unsigned __int16)v15 != 476 )
                {
LABEL_67:
                  operator*(&v41, m_pMat, &v);
                  v24 = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y) + v41.y;
                  v25 = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z) + v41.z;
                  pBarrelPosn.x = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x) + v41.x;
                  pBarrelPosn.y = v24;
                  pBarrelPosn.z = v25;
                  CWeapon::FireInstantHit(&weapon, this, &pBarrelPosn, &pBarrelPosn, 0, 0, 0, 0, 0);
                  v26 = *((_BYTE *)this + 1203) & 3;
                  if ( v10 != 1 )
                  {
                    CVehicle::DoPlaneGunFireFX(this, &weapon, &v, &pBarrelPosn, v26);
                    goto LABEL_91;
                  }
                  CVehicle::DoPlaneGunFireFX(this, &weapon, &v, &pBarrelPosn, (unsigned __int8)(2 * v26));
                  v27 = this->m_nModelIndex;
                  v28 = (float *)CModelInfo::ms_modelInfoPtrs[v27][2].m_hashKey;
                  x = v28[39];
                  y = v28[40];
                  z = v28[41];
                  v32 = (unsigned __int16)v27;
                  if ( x == 0.0 && y == 0.0 )
                  {
                    x = 0.0;
                    if ( v27 < 520 )
                    {
                      y = 0.0;
                      z = 0.0;
                      switch ( this->m_nModelIndex )
                      {
                        case 0x1D0:
                          v33 = &s_RCBaronGunPos;
                          goto LABEL_87;
                        case 0x1D1:
                        case 0x1D2:
                        case 0x1D3:
                        case 0x1D4:
                        case 0x1D5:
                        case 0x1D6:
                        case 0x1D7:
                        case 0x1D8:
                        case 0x1D9:
                        case 0x1DA:
                        case 0x1DB:
                        case 0x1DD:
                        case 0x1DE:
                        case 0x1DF:
                        case 0x1E0:
                        case 0x1E1:
                        case 0x1E2:
                        case 0x1E3:
                        case 0x1E4:
                        case 0x1E5:
                        case 0x1E6:
                        case 0x1E8:
                        case 0x1E9:
                        case 0x1EA:
                        case 0x1EB:
                        case 0x1EC:
                        case 0x1ED:
                        case 0x1EE:
                        case 0x1EF:
                        case 0x1F0:
                          goto LABEL_88;
                        case 0x1DC:
                          v33 = &s_MustangGunPos1;
                          goto LABEL_87;
                        case 0x1E7:
                          v33 = &s_MaverickGunPos;
                          goto LABEL_87;
                        case 0x1F1:
                          v33 = &s_PoliceMaverickGunPos;
                          goto LABEL_87;
                        default:
                          if ( v27 == 425 )
                          {
                            v33 = &s_HunterGunPos;
                          }
                          else
                          {
                            y = 0.0;
                            z = 0.0;
                            if ( v27 != 447 )
                              goto LABEL_88;
                            v33 = &s_SeaSparrowGunPos;
                          }
                          break;
                      }
                      goto LABEL_87;
                    }
                    if ( v27 == 520 )
                    {
                      v33 = &s_HarrierGunPos;
                      goto LABEL_87;
                    }
                    if ( v27 == 548 )
                    {
                      v33 = &s_CargoBobGunPos;
                      goto LABEL_87;
                    }
                    y = 0.0;
                    z = 0.0;
                    if ( v27 == 576 )
                    {
                      v33 = &s_TornadoGunPos;
LABEL_87:
                      x = v33->x;
                      y = v33->y;
                      z = v33->z;
                    }
                  }
LABEL_88:
                  if ( v32 == 476 )
                  {
                    v34 = (float)((*((_BYTE *)this + 1203) & 3) - 1);
                    z = z + (float)(s_MustangGunOffset.z * v34);
                    y = y + (float)(s_MustangGunOffset.y * v34);
                    x = x + (float)(s_MustangGunOffset.x * v34);
                  }
                  v.z = z;
                  v.y = y;
                  v.x = -x;
                  operator*(&v41, m_pMat, &v);
                  v35 = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y) + v41.y;
                  v36 = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z) + v41.z;
                  pBarrelPosn.x = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x) + v41.x;
                  pBarrelPosn.y = v35;
                  pBarrelPosn.z = v36;
                  CWeapon::FireInstantHit(&weapon, this, &pBarrelPosn, &pBarrelPosn, 0, 0, 0, 0, 0);
                  CVehicle::DoPlaneGunFireFX(this, &weapon, &v, &pBarrelPosn, (2 * (*((_BYTE *)this + 1203) & 3)) | 1);
LABEL_91:
                  if ( (*(_BYTE *)&this->m_info & 0xF8) != 64 )
                  {
                    pDriver = this->pDriver;
                    if ( !pDriver || !CPed::IsPlayer(pDriver) )
                    {
LABEL_98:
                      if ( v8 == WEAPONTYPE_MINIGUN )
                        v8 = WEAPONTYPE_M4;
                      CAudioEngine::ReportWeaponEvent(&AudioEngine, 149, v8, this);
                      this->TimeOfLastShotFired = CTimer::m_snTimeInMilliseconds;
                      return;
                    }
                    m_nPedType = this->pDriver->m_nPedType;
                    if ( m_nPedType == 1 )
                    {
                      v37 = 1;
                      goto LABEL_93;
                    }
                    if ( m_nPedType )
                      goto LABEL_98;
                  }
                  v37 = 0;
LABEL_93:
                  Pad = CPad::GetPad(v37);
                  CPad::StartShake(Pad, 240, v9, 0);
                  goto LABEL_98;
                }
LABEL_66:
                v23 = (float)((v17 & 3) - 1);
                v.x = (float)(s_MustangGunOffset.x * v23) + v.x;
                v.y = (float)(s_MustangGunOffset.y * v23) + v.y;
                v.z = (float)(s_MustangGunOffset.z * v23) + v.z;
                goto LABEL_67;
            }
          }
          else
          {
            switch ( v15 )
            {
              case 464:
                v21 = &s_RCBaronGunPos;
                break;
              case 465:
              case 466:
              case 467:
              case 468:
              case 469:
              case 470:
              case 471:
              case 472:
              case 473:
              case 474:
              case 475:
              case 477:
              case 478:
              case 479:
              case 480:
              case 481:
              case 482:
              case 483:
              case 484:
              case 485:
              case 486:
              case 488:
              case 489:
              case 490:
              case 491:
              case 492:
              case 493:
              case 494:
              case 495:
              case 496:
                goto LABEL_59;
              case 476:
                v21 = &s_MustangGunPos1;
                break;
              case 487:
                v21 = &s_MaverickGunPos;
                break;
              case 497:
                v21 = &s_PoliceMaverickGunPos;
                break;
              default:
                if ( v15 == 425 )
                {
                  v21 = &s_HunterGunPos;
                }
                else
                {
                  if ( v15 != 447 )
                    goto LABEL_59;
                  v21 = &s_SeaSparrowGunPos;
                }
                break;
            }
          }
          v22 = *(_QWORD *)&v21->x;
          v.z = v21->z;
          *(_QWORD *)&v.x = v22;
        }
        if ( v20 != 476 )
          goto LABEL_67;
        goto LABEL_66;
      }
      p_m_colour1 = &this[1].m_colour1;
    }
    v6 = (float)*p_m_colour1 * 0.0625;
    goto LABEL_16;
  }
}

//----- (0058EB98) --------------------------------------------------------
void __fastcall CVehicle::PossiblyDropFreeFallBombForPlayer(CVehicle *this, eOrdnanceType iType, bool bUseFiringRate)
{
  uint32 *p_m_LastTimeSecondaryFired; // r8
  int32 m_vehicleType; // r0
  uint8 *p_m_colour1; // r0
  int16 m_nModelIndex; // r3
  float v8; // s0
  int v9; // r0
  float v10; // s2
  int *v11; // r0
  int v12; // r2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r5
  float *m_hashKey; // r3
  float x; // s6
  float y; // s8
  float z; // s10
  const CVector *v19; // r1
  float v20; // s12
  float v21; // s4
  CVector *p_xy; // r0
  float v23; // s0
  unsigned int v24; // s2
  CPed *pDriver; // r0
  int32 m_nPedType; // r0
  int32 v27; // r0
  CPad *Pad; // r0
  CVector v29; // 0:r2.8,8:^0.4

  p_m_LastTimeSecondaryFired = &this->m_LastTimeSecondaryFired;
  if ( iType == ORDNANCE_TYPE_PRIMARY )
    p_m_LastTimeSecondaryFired = &this->m_LastTimePrimaryFired;
  if ( !bUseFiringRate )
  {
    m_nModelIndex = this->m_nModelIndex;
    goto LABEL_23;
  }
  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
    goto LABEL_9;
  }
  if ( m_vehicleType == 4 )
  {
    p_m_colour1 = &this[1].m_colour1;
LABEL_9:
    v8 = (float)*p_m_colour1 * 0.0625;
    goto LABEL_11;
  }
  v8 = 1.0;
LABEL_11:
  v9 = this->m_nModelIndex;
  m_nModelIndex = this->m_nModelIndex;
  if ( v9 >= 476 )
  {
    if ( v9 != 520 )
    {
      if ( v9 != 476 )
        goto LABEL_14;
LABEL_17:
      v10 = 1000.0;
      goto LABEL_22;
    }
    v11 = dword_58EDC4;
    if ( iType == ORDNANCE_TYPE_PRIMARY )
      v11 = &dword_58EDC4[1];
    v10 = *(float *)v11;
  }
  else
  {
    if ( v9 != 425 )
    {
      if ( v9 != 447 )
      {
LABEL_14:
        v10 = 350.0;
        goto LABEL_22;
      }
      goto LABEL_17;
    }
    v10 = 500.0;
  }
LABEL_22:
  if ( CTimer::m_snTimeInMilliseconds <= (int)(float)(v10 / v8) + *p_m_LastTimeSecondaryFired )
    return;
LABEL_23:
  v12 = m_nModelIndex;
  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  m_hashKey = (float *)CModelInfo::ms_modelInfoPtrs[m_nModelIndex][2].m_hashKey;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  x = m_hashKey[39];
  y = m_hashKey[40];
  if ( x != 0.0 || y != 0.0 || m_hashKey[41] != 0.0 )
  {
    z = m_hashKey[41];
    goto LABEL_46;
  }
  z = 0.0;
  if ( v12 >= 476 )
  {
    if ( v12 == 476 )
    {
      v19 = &s_MustangOrdnancePos;
    }
    else if ( v12 == 520 )
    {
      if ( iType == ORDNANCE_TYPE_SECONDARY )
      {
        v19 = &s_HarrierOrdnancePos2;
      }
      else
      {
        z = m_hashKey[41];
        if ( iType != ORDNANCE_TYPE_PRIMARY )
          goto LABEL_46;
        v19 = &s_HarrierOrdnancePos1;
      }
    }
    else
    {
      y = 0.0;
      x = 0.0;
      if ( v12 != 576 )
        goto LABEL_46;
      v19 = &s_TornadoOrdnancePos;
    }
  }
  else if ( v12 == 425 )
  {
    v19 = &s_HunterOrdnancePos;
  }
  else if ( v12 == 447 )
  {
    v19 = &s_SeaSparrowOrdnancePos;
  }
  else
  {
    y = 0.0;
    x = 0.0;
    if ( v12 != 464 )
      goto LABEL_46;
    v19 = &s_RCBaronOrdnancePos;
  }
  x = v19->x;
  y = v19->y;
  z = v19->z;
LABEL_46:
  v20 = -x;
  v21 = p_tx->m_translate.y + y;
  p_xy = (CVector *)&m_pMat->xy;
  v23 = p_tx->m_translate.z + z;
  if ( (*((_BYTE *)this + 1203) & 0xC) == 0 )
    v20 = x;
  *(float *)&v24 = p_tx->m_translate.x + v20;
  *((_BYTE *)this + 1203) = *((_BYTE *)this + 1203) & 0xF3 | (4 * ((*((_BYTE *)this + 1203) & 0xC) == 0));
  v29.z = v23;
  *(_QWORD *)&v29.x = __PAIR64__(LODWORD(v21), v24);
  CProjectileInfo::AddProjectile(this, WEAPONTYPE_FREEFALL_BOMB, v29, 0.0, p_xy, 0);
  pDriver = this->pDriver;
  if ( !pDriver || !CPed::IsPlayer(pDriver) )
    goto LABEL_55;
  m_nPedType = this->pDriver->m_nPedType;
  if ( m_nPedType == 1 )
  {
    v27 = 1;
    goto LABEL_54;
  }
  if ( !m_nPedType )
  {
    v27 = 0;
LABEL_54:
    Pad = CPad::GetPad(v27);
    CPad::StartShake(Pad, 240, 0xA0u, 0);
  }
LABEL_55:
  *p_m_LastTimeSecondaryFired = CTimer::m_snTimeInMilliseconds;
}
// 58EDC4: using guessed type int dword_58EDC4[2];

//----- (0058EDFC) --------------------------------------------------------
void __fastcall CVehicle::FireHeatSeakingMissile(
        CVehicle *this,
        CEntity *pTarget,
        eOrdnanceType iType,
        bool bUseFiringRate)
{
  float32x2_t v4; // d6
  float32x2_t v5; // d7
  uint32 *p_m_LastTimeSecondaryFired; // r8
  int32 m_vehicleType; // r0
  uint8 *p_m_colour1; // r0
  int16 m_nModelIndex; // r3
  float v11; // s0
  int v12; // r0
  float v13; // s2
  int *v14; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r5
  float *m_hashKey; // r6
  float x; // s2
  float y; // s4
  float z; // s0
  float v21; // s6
  float v22; // s8
  float v23; // s10
  const CVector *v24; // r2
  char v25; // r2
  char v26; // r6
  float v27; // s1
  float xy; // s3
  float yy; // s5
  float zy; // s7
  float v31; // s1
  float v32; // s12
  __int64 v33; // d16
  CPed *pDriver; // r0
  int32 m_nPedType; // r0
  int32 v36; // r0
  CPad *Pad; // r0
  CVector v38; // [sp+10h] [bp-20h] BYREF
  CVector v39; // 0:r2.8,8:^0.4

  p_m_LastTimeSecondaryFired = &this->m_LastTimeSecondaryFired;
  if ( iType == ORDNANCE_TYPE_PRIMARY )
    p_m_LastTimeSecondaryFired = &this->m_LastTimePrimaryFired;
  if ( !bUseFiringRate )
  {
    m_nModelIndex = this->m_nModelIndex;
    goto LABEL_23;
  }
  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
    goto LABEL_9;
  }
  if ( m_vehicleType == 4 )
  {
    p_m_colour1 = &this[1].m_colour1;
LABEL_9:
    v11 = (float)*p_m_colour1 * 0.0625;
    goto LABEL_11;
  }
  v11 = 1.0;
LABEL_11:
  v12 = this->m_nModelIndex;
  m_nModelIndex = this->m_nModelIndex;
  if ( v12 >= 476 )
  {
    if ( v12 != 520 )
    {
      if ( v12 != 476 )
        goto LABEL_14;
LABEL_17:
      v13 = 1000.0;
      goto LABEL_22;
    }
    v14 = dword_58F098;
    if ( iType == ORDNANCE_TYPE_PRIMARY )
      v14 = &dword_58F098[1];
    v13 = *(float *)v14;
  }
  else
  {
    if ( v12 != 425 )
    {
      if ( v12 != 447 )
      {
LABEL_14:
        v13 = 350.0;
        goto LABEL_22;
      }
      goto LABEL_17;
    }
    v13 = 500.0;
  }
LABEL_22:
  if ( CTimer::m_snTimeInMilliseconds <= (int)(float)(v13 / v11) + *p_m_LastTimeSecondaryFired )
    return;
LABEL_23:
  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  m_hashKey = (float *)CModelInfo::ms_modelInfoPtrs[m_nModelIndex][2].m_hashKey;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  v21 = m_hashKey[40];
  v22 = m_hashKey[41];
  if ( m_hashKey[39] != 0.0 || v21 != 0.0 || v22 != 0.0 )
  {
    v23 = m_hashKey[39];
    goto LABEL_46;
  }
  v23 = 0.0;
  if ( m_nModelIndex >= 476 )
  {
    if ( m_nModelIndex == 476 )
    {
      v24 = &s_MustangOrdnancePos;
    }
    else if ( m_nModelIndex == 520 )
    {
      if ( iType == ORDNANCE_TYPE_SECONDARY )
      {
        v24 = &s_HarrierOrdnancePos2;
      }
      else
      {
        v23 = m_hashKey[39];
        if ( iType != ORDNANCE_TYPE_PRIMARY )
          goto LABEL_46;
        v24 = &s_HarrierOrdnancePos1;
      }
    }
    else
    {
      v21 = 0.0;
      v22 = 0.0;
      if ( m_nModelIndex != 576 )
        goto LABEL_46;
      v24 = &s_TornadoOrdnancePos;
    }
  }
  else if ( m_nModelIndex == 425 )
  {
    v24 = &s_HunterOrdnancePos;
  }
  else if ( m_nModelIndex == 447 )
  {
    v24 = &s_SeaSparrowOrdnancePos;
  }
  else
  {
    v21 = 0.0;
    v22 = 0.0;
    if ( m_nModelIndex != 464 )
      goto LABEL_46;
    v24 = &s_RCBaronOrdnancePos;
  }
  v23 = v24->x;
  v21 = v24->y;
  v22 = v24->z;
LABEL_46:
  v25 = *((_BYTE *)this + 1203);
  v26 = 0;
  v4.n64_u32[0] = LODWORD(this->m_vecMoveSpeed.x);
  v5.n64_u32[0] = LODWORD(this->m_vecMoveSpeed.y);
  v27 = this->m_vecMoveSpeed.z;
  if ( (v25 & 0xC) == 0 )
    v26 = 1;
  *((_BYTE *)this + 1203) = v25 & 0xF3 | (4 * v26);
  xy = m_pMat->xy;
  yy = m_pMat->yy;
  zy = m_pMat->zy;
  v4.n64_f32[0] = (float)(v4.n64_f32[0] * xy) + (float)(v5.n64_f32[0] * yy);
  v5.n64_u32[0] = 0;
  v4.n64_f32[0] = v4.n64_f32[0] + (float)(v27 * zy);
  v31 = -v23;
  v32 = vmax_f32(v4, v5).n64_f32[0];
  if ( (v25 & 0xC) == 0 )
    v31 = v23;
  v33 = *(_QWORD *)&m_pMat->xy;
  v38.z = m_pMat->zy;
  *(_QWORD *)&v38.x = v33;
  v39.x = x + (float)(v31 + (float)((float)(xy * v32) * CTimer::ms_fTimeStep));
  v39.y = y + (float)(v21 + (float)((float)(yy * v32) * CTimer::ms_fTimeStep));
  v39.z = z + (float)(v22 + (float)((float)(zy * v32) * CTimer::ms_fTimeStep));
  CProjectileInfo::AddProjectile(this, WEAPONTYPE_ROCKET_HS, v39, 0.0, &v38, pTarget);
  pDriver = this->pDriver;
  if ( !pDriver || !CPed::IsPlayer(pDriver) )
    goto LABEL_57;
  m_nPedType = this->pDriver->m_nPedType;
  if ( m_nPedType == 1 )
  {
    v36 = 1;
    goto LABEL_56;
  }
  if ( !m_nPedType )
  {
    v36 = 0;
LABEL_56:
    Pad = CPad::GetPad(v36);
    CPad::StartShake(Pad, 240, 0xA0u, 0);
  }
LABEL_57:
  *p_m_LastTimeSecondaryFired = CTimer::m_snTimeInMilliseconds;
}
// 58EFDE: variable 'v4' is possibly undefined
// 58EFDE: variable 'v5' is possibly undefined
// 58F098: using guessed type int dword_58F098[2];

//----- (0058F0D4) --------------------------------------------------------
void __fastcall CVehicle::FireUnguidedMissile(CVehicle *this, eOrdnanceType iType, bool bUseFiringRate)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d8
  uint32 *p_m_LastTimeSecondaryFired; // r8
  int32 m_vehicleType; // r2
  uint8 *p_m_colour1; // r2
  int m_nModelIndex; // r2
  int16 *p_m_nModelIndex; // r6
  float v12; // s0
  int v13; // r3
  float v14; // s2
  int *v15; // r3
  int v16; // r0
  bool v17; // zf
  char v18; // r2
  int v19; // r0
  uint32 m_hashKey; // r1
  __int64 v21; // d16
  RwReal v22; // r1
  const CVector *v23; // r0
  __int64 v24; // d16
  CMatrix *m_pMat; // r0
  float xy; // s6
  float yy; // s8
  float zy; // s10
  int v29; // r0
  uint32 v30; // r1
  float32x2_t v31; // d0
  float y; // s2
  RwReal z; // s4
  const CVector *v34; // r0
  CMatrix *v35; // r0
  float v36; // s6
  float v37; // s8
  float v38; // s10
  float v39; // s0
  CPed *pDriver; // r0
  int32 m_nPedType; // r0
  int32 v42; // r0
  CPad *Pad; // r0
  CVector v44; // [sp+Ch] [bp-54h] BYREF
  CVector v; // [sp+18h] [bp-48h] BYREF
  CWeapon v46; // [sp+24h] [bp-3Ch] BYREF

  p_m_LastTimeSecondaryFired = &this->m_LastTimeSecondaryFired;
  if ( iType == ORDNANCE_TYPE_PRIMARY )
    p_m_LastTimeSecondaryFired = &this->m_LastTimePrimaryFired;
  if ( !bUseFiringRate )
  {
    p_m_nModelIndex = &this->m_nModelIndex;
    m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
    goto LABEL_23;
  }
  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
    goto LABEL_9;
  }
  if ( m_vehicleType == 4 )
  {
    p_m_colour1 = &this[1].m_colour1;
LABEL_9:
    v12 = (float)*p_m_colour1 * 0.0625;
    goto LABEL_11;
  }
  v12 = 1.0;
LABEL_11:
  p_m_nModelIndex = &this->m_nModelIndex;
  v13 = this->m_nModelIndex;
  m_nModelIndex = (unsigned __int16)v13;
  if ( v13 >= 476 )
  {
    if ( v13 != 520 )
    {
      if ( v13 != 476 )
        goto LABEL_14;
LABEL_17:
      v14 = 1000.0;
      goto LABEL_22;
    }
    v15 = dword_58F4E4;
    if ( iType == ORDNANCE_TYPE_PRIMARY )
      v15 = &dword_58F4E4[1];
    v14 = *(float *)v15;
  }
  else
  {
    if ( v13 != 425 )
    {
      if ( v13 != 447 )
      {
LABEL_14:
        v14 = 350.0;
        goto LABEL_22;
      }
      goto LABEL_17;
    }
    v14 = 500.0;
  }
LABEL_22:
  if ( CTimer::m_snTimeInMilliseconds <= *p_m_LastTimeSecondaryFired + (int)(float)(v14 / v12) )
    return;
LABEL_23:
  v16 = 425;
  v17 = m_nModelIndex == 425;
  if ( m_nModelIndex != 425 )
  {
    v16 = (__int16)m_nModelIndex;
    v17 = (__int16)m_nModelIndex == 576;
  }
  if ( v17 || v16 == 520 )
  {
    CWeapon::CWeapon(&v46, WEAPONTYPE_ROCKETLAUNCHER, 5000);
    v18 = 0;
    v19 = *p_m_nModelIndex;
    m_hashKey = CModelInfo::ms_modelInfoPtrs[v19][2].m_hashKey;
    v21 = *(_QWORD *)(m_hashKey + 156);
    v22 = *(float *)(m_hashKey + 164);
    *(_QWORD *)&v.x = v21;
    v.z = v22;
    if ( *(float *)&v21 == 0.0 )
      v18 = 1;
    if ( ((unsigned __int8)v18 & (*((float *)&v21 + 1) == 0.0)) != 0 && v.z == 0.0 )
    {
      if ( v19 < 476 )
      {
        switch ( v19 )
        {
          case 425:
            v23 = &s_HunterOrdnancePos;
            goto LABEL_48;
          case 447:
            v23 = &s_SeaSparrowOrdnancePos;
            goto LABEL_48;
          case 464:
            v23 = &s_RCBaronOrdnancePos;
LABEL_48:
            v24 = *(_QWORD *)&v23->x;
            v.z = v23->z;
            *(_QWORD *)&v.x = v24;
            goto LABEL_49;
        }
LABEL_42:
        memset(&v, 0, sizeof(v));
        goto LABEL_49;
      }
      if ( v19 == 476 )
      {
        v23 = &s_MustangOrdnancePos;
        goto LABEL_48;
      }
      if ( v19 != 520 )
      {
        if ( v19 == 576 )
        {
          v23 = &s_TornadoOrdnancePos;
          goto LABEL_48;
        }
        goto LABEL_42;
      }
      if ( iType == ORDNANCE_TYPE_SECONDARY )
      {
        v23 = &s_HarrierOrdnancePos2;
        goto LABEL_48;
      }
      if ( iType == ORDNANCE_TYPE_PRIMARY )
      {
        v23 = &s_HarrierOrdnancePos1;
        goto LABEL_48;
      }
    }
LABEL_49:
    operator*(&v44, this->m_pMat, &v);
    m_pMat = this->m_pMat;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
    v4.n64_u32[0] = 0;
    v3.n64_f32[0] = (float)((float)(this->m_vecMoveSpeed.x * xy) + (float)(this->m_vecMoveSpeed.y * yy))
                  + (float)(this->m_vecMoveSpeed.z * zy);
    v31.n64_u64[0] = vmax_f32(v3, v4).n64_u64[0];
    v.x = v44.x + (float)((float)(xy * v31.n64_f32[0]) * CTimer::ms_fTimeStep);
    v.y = (float)((float)(yy * v31.n64_f32[0]) * CTimer::ms_fTimeStep) + v44.y;
    v.z = (float)((float)(zy * v31.n64_f32[0]) * CTimer::ms_fTimeStep) + v44.z;
    CWeapon::FireProjectile(&v46, this, &v, 0, 0, 0.0);
    v29 = this->m_nModelIndex;
    v30 = CModelInfo::ms_modelInfoPtrs[v29][2].m_hashKey;
    v31.n64_u32[0] = *(_DWORD *)(v30 + 156);
    y = *(float *)(v30 + 160);
    z = *(float *)(v30 + 164);
    if ( v31.n64_f32[0] == 0.0 && y == 0.0 )
    {
      if ( v29 >= 476 )
      {
        if ( v29 == 476 )
        {
          v34 = &s_MustangOrdnancePos;
          goto LABEL_67;
        }
        if ( v29 == 520 )
        {
          if ( iType == ORDNANCE_TYPE_SECONDARY )
          {
            v34 = &s_HarrierOrdnancePos2;
            goto LABEL_67;
          }
          if ( iType == ORDNANCE_TYPE_PRIMARY )
          {
            v34 = &s_HarrierOrdnancePos1;
            goto LABEL_67;
          }
        }
        else
        {
          v31.n64_u32[0] = 0;
          y = 0.0;
          z = 0.0;
          if ( v29 == 576 )
          {
            v34 = &s_TornadoOrdnancePos;
            goto LABEL_67;
          }
        }
      }
      else
      {
        if ( v29 == 425 )
        {
          v34 = &s_HunterOrdnancePos;
          goto LABEL_67;
        }
        if ( v29 == 447 )
        {
          v34 = &s_SeaSparrowOrdnancePos;
          goto LABEL_67;
        }
        v31.n64_u32[0] = 0;
        y = 0.0;
        z = 0.0;
        if ( v29 == 464 )
        {
          v34 = &s_RCBaronOrdnancePos;
LABEL_67:
          v31.n64_u32[0] = LODWORD(v34->x);
          y = v34->y;
          z = v34->z;
        }
      }
    }
    v.z = z;
    v.y = y;
    v.x = -v31.n64_f32[0];
    operator*(&v44, this->m_pMat, &v);
    v35 = this->m_pMat;
    v36 = v35->xy;
    v37 = v35->yy;
    v38 = v35->zy;
    v31.n64_f32[0] = (float)((float)(this->m_vecMoveSpeed.x * v36) + (float)(this->m_vecMoveSpeed.y * v37))
                   + (float)(this->m_vecMoveSpeed.z * v38);
    v39 = vmax_f32(v31, v4).n64_f32[0];
    v.x = v44.x + (float)((float)(v36 * v39) * CTimer::ms_fTimeStep);
    v.y = (float)((float)(v37 * v39) * CTimer::ms_fTimeStep) + v44.y;
    v.z = (float)((float)(v38 * v39) * CTimer::ms_fTimeStep) + v44.z;
    CWeapon::FireProjectile(&v46, this, &v, 0, 0, 0.0);
    pDriver = this->pDriver;
    if ( !pDriver || !CPed::IsPlayer(pDriver) )
      goto LABEL_75;
    m_nPedType = this->pDriver->m_nPedType;
    if ( m_nPedType == 1 )
    {
      v42 = 1;
    }
    else
    {
      if ( m_nPedType )
      {
LABEL_75:
        *p_m_LastTimeSecondaryFired = CTimer::m_snTimeInMilliseconds;
        return;
      }
      v42 = 0;
    }
    Pad = CPad::GetPad(v42);
    CPad::StartShake(Pad, 240, 0xA0u, 0);
    goto LABEL_75;
  }
}
// 58F2D4: variable 'v3' is possibly undefined
// 58F2D4: variable 'v4' is possibly undefined
// 58F4E4: using guessed type int dword_58F4E4[2];

//----- (0058F53C) --------------------------------------------------------
int __fastcall CVehicle::GetPlaneNumGuns(CVehicle *this)
{
  int m_nModelIndex; // r1
  int result; // r0
  bool v3; // zf

  m_nModelIndex = this->m_nModelIndex;
  result = 1;
  if ( m_nModelIndex >= 520 )
  {
    switch ( m_nModelIndex )
    {
      case 520:
        return 2;
      case 548:
        return result;
      case 576:
        return 2;
      default:
        return 0;
    }
  }
  else
  {
    switch ( m_nModelIndex )
    {
      case 464:
      case 487:
      case 497:
        return result;
      case 465:
      case 466:
      case 467:
      case 468:
      case 469:
      case 470:
      case 471:
      case 472:
      case 473:
      case 474:
      case 475:
      case 477:
      case 478:
      case 479:
      case 480:
      case 481:
      case 482:
      case 483:
      case 484:
      case 485:
      case 486:
      case 488:
      case 489:
      case 490:
      case 491:
      case 492:
      case 493:
      case 494:
      case 495:
      case 496:
        return 0;
      case 476:
        result = 6;
        break;
      default:
        v3 = m_nModelIndex == 425;
        if ( m_nModelIndex != 425 )
          v3 = m_nModelIndex == 447;
        if ( !v3 )
          return 0;
        break;
    }
  }
  return result;
}

//----- (0058F5A4) --------------------------------------------------------
float __fastcall CVehicle::GetPlaneGunsAutoAimAngle(CVehicle *this)
{
  int m_nModelIndex; // r0
  float result; // r0
  bool v3; // zf

  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex >= 520 )
  {
    if ( m_nModelIndex >= 564 )
    {
      if ( m_nModelIndex == 564 )
        return 20.0;
      if ( m_nModelIndex != 576 )
        return 0.0;
    }
    else
    {
      v3 = m_nModelIndex == 520;
      if ( m_nModelIndex != 520 )
        v3 = m_nModelIndex == 548;
      if ( !v3 )
        return 0.0;
    }
    return 15.0;
  }
  switch ( m_nModelIndex )
  {
    case 464:
      return 30.0;
    case 465:
    case 466:
    case 467:
    case 468:
    case 469:
    case 470:
    case 471:
    case 472:
    case 473:
    case 474:
    case 475:
    case 477:
    case 478:
    case 479:
    case 480:
    case 481:
    case 482:
    case 483:
    case 484:
    case 485:
    case 486:
    case 488:
    case 489:
    case 490:
    case 491:
    case 492:
    case 493:
    case 494:
    case 495:
    case 496:
      return 0.0;
    case 476:
    case 487:
    case 497:
      return 15.0;
    default:
      if ( m_nModelIndex == 425 )
        return 25.0;
      if ( m_nModelIndex != 447 )
        return 0.0;
      result = 10.0;
      break;
  }
  return result;
}

//----- (0058F648) --------------------------------------------------------
void __fastcall CVehicle::SetFiringRateMultiplier(CVehicle *this, float val)
{
  float v2; // s0
  int32 m_vehicleType; // r1

  v2 = val;
  if ( val >= 0.0 )
  {
    if ( val > 15.938 )
      v2 = 15.938;
  }
  else
  {
    v2 = 0.0;
  }
  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    LOBYTE(this[1].pPassengers[2]) = (unsigned int)(float)(v2 * 16.0);
  }
  else if ( m_vehicleType == 4 )
  {
    this[1].m_colour1 = (unsigned int)(float)(v2 * 16.0);
  }
}

//----- (0058F6B0) --------------------------------------------------------
float __fastcall CVehicle::GetFiringRateMultiplier(CVehicle *this)
{
  int32 m_vehicleType; // r1
  uint8 *p_m_colour1; // r0

  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
  }
  else
  {
    if ( m_vehicleType != 4 )
      return 1.0;
    p_m_colour1 = &this[1].m_colour1;
  }
  return (float)*p_m_colour1 * 0.0625;
}

//----- (0058F6EC) --------------------------------------------------------
uint32 __fastcall CVehicle::GetPlaneGunsRateOfFire(CVehicle *this)
{
  int32 m_vehicleType; // r1
  uint8 *p_m_colour1; // r1
  float v3; // s0
  int m_nModelIndex; // r0
  float v5; // s2

  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
    goto LABEL_5;
  }
  if ( m_vehicleType == 4 )
  {
    p_m_colour1 = &this[1].m_colour1;
LABEL_5:
    v3 = (float)*p_m_colour1 * 0.0625;
    goto LABEL_7;
  }
  v3 = 1.0;
LABEL_7:
  m_nModelIndex = this->m_nModelIndex;
  v5 = 60.0;
  if ( m_nModelIndex >= 520 )
  {
    switch ( m_nModelIndex )
    {
      case 520:
        v5 = 17.0;
        break;
      case 548:
        v5 = 100.0;
        break;
      case 576:
        v5 = 45.0;
        break;
    }
  }
  else if ( m_nModelIndex == 447 || m_nModelIndex == 464 )
  {
    v5 = 40.0;
  }
  else if ( m_nModelIndex == 476 )
  {
    v5 = 80.0;
  }
  return (int)(float)(v5 / v3);
}

//----- (0058F78C) --------------------------------------------------------
CVector *__fastcall CVehicle::GetPlaneGunsPosition(CVector *retstr, CVehicle *this, int num)
{
  int m_nModelIndex; // r3
  uint32 m_hashKey; // r1
  __int64 v5; // d16
  const CVector *v6; // r1
  __int64 v7; // d16
  float v8; // s0
  RwReal v9; // s4
  RwReal v10; // s2
  RwReal v11; // s0

  m_nModelIndex = this->m_nModelIndex;
  m_hashKey = CModelInfo::ms_modelInfoPtrs[m_nModelIndex][2].m_hashKey;
  v5 = *(_QWORD *)(m_hashKey + 156);
  retstr->z = *(RwReal *)(m_hashKey + 164);
  *(_QWORD *)&retstr->x = v5;
  if ( retstr->x != 0.0 || retstr->y != 0.0 )
    goto LABEL_21;
  if ( m_nModelIndex >= 520 )
  {
    switch ( m_nModelIndex )
    {
      case 520:
        v6 = &s_HarrierGunPos;
        break;
      case 548:
        v6 = &s_CargoBobGunPos;
        break;
      case 576:
        v6 = &s_TornadoGunPos;
        break;
      default:
LABEL_16:
        retstr->x = 0.0;
        retstr->y = 0.0;
        retstr->z = 0.0;
        goto LABEL_21;
    }
  }
  else
  {
    switch ( m_nModelIndex )
    {
      case 464:
        v6 = &s_RCBaronGunPos;
        break;
      case 465:
      case 466:
      case 467:
      case 468:
      case 469:
      case 470:
      case 471:
      case 472:
      case 473:
      case 474:
      case 475:
      case 477:
      case 478:
      case 479:
      case 480:
      case 481:
      case 482:
      case 483:
      case 484:
      case 485:
      case 486:
      case 488:
      case 489:
      case 490:
      case 491:
      case 492:
      case 493:
      case 494:
      case 495:
      case 496:
        goto LABEL_16;
      case 476:
        v6 = &s_MustangGunPos1;
        break;
      case 487:
        v6 = &s_MaverickGunPos;
        break;
      case 497:
        v6 = &s_PoliceMaverickGunPos;
        break;
      default:
        if ( m_nModelIndex == 425 )
        {
          v6 = &s_HunterGunPos;
        }
        else
        {
          if ( m_nModelIndex != 447 )
            goto LABEL_16;
          v6 = &s_SeaSparrowGunPos;
        }
        break;
    }
  }
  v7 = *(_QWORD *)&v6->x;
  retstr->z = v6->z;
  *(_QWORD *)&retstr->x = v7;
LABEL_21:
  if ( (unsigned __int16)m_nModelIndex == 476 )
  {
    v8 = (float)(num - 1);
    v9 = (float)(s_MustangGunOffset.y * v8) + retstr->y;
    v10 = (float)(s_MustangGunOffset.x * v8) + retstr->x;
    v11 = (float)(s_MustangGunOffset.z * v8) + retstr->z;
    retstr->x = v10;
    retstr->y = v9;
    retstr->z = v11;
  }
  return retstr;
}

//----- (0058F8FC) --------------------------------------------------------
uint32 __fastcall CVehicle::GetPlaneOrdnanceRateOfFire(CVehicle *this, eOrdnanceType iType)
{
  int32 m_vehicleType; // r2
  uint8 *p_m_colour1; // r2
  float v4; // s0
  int m_nModelIndex; // r0
  float v6; // s2
  int *v7; // r0

  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    p_m_colour1 = (uint8 *)&this[1].pPassengers[2];
    goto LABEL_5;
  }
  if ( m_vehicleType == 4 )
  {
    p_m_colour1 = &this[1].m_colour1;
LABEL_5:
    v4 = (float)*p_m_colour1 * 0.0625;
    goto LABEL_7;
  }
  v4 = 1.0;
LABEL_7:
  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex < 476 )
  {
    if ( m_nModelIndex == 425 )
    {
      v6 = 500.0;
      return (int)(float)(v6 / v4);
    }
    if ( m_nModelIndex != 447 )
      goto LABEL_10;
    goto LABEL_13;
  }
  if ( m_nModelIndex != 520 )
  {
    if ( m_nModelIndex != 476 )
    {
LABEL_10:
      v6 = 350.0;
      return (int)(float)(v6 / v4);
    }
LABEL_13:
    v6 = 1000.0;
    return (int)(float)(v6 / v4);
  }
  v7 = dword_58F984;
  if ( iType == ORDNANCE_TYPE_PRIMARY )
    v7 = &dword_58F984[1];
  v6 = *(float *)v7;
  return (int)(float)(v6 / v4);
}
// 58F984: using guessed type int dword_58F984[2];

//----- (0058F994) --------------------------------------------------------
CVector *__fastcall CVehicle::GetPlaneOrdnancePosition(CVector *retstr, CVehicle *this, eOrdnanceType iType)
{
  int m_nModelIndex; // r1
  uint32 m_hashKey; // r3
  __int64 v5; // d16
  RwReal v6; // r3
  float x; // s0
  const CVector *v8; // r1
  __int64 v9; // d16

  m_nModelIndex = this->m_nModelIndex;
  m_hashKey = CModelInfo::ms_modelInfoPtrs[m_nModelIndex][2].m_hashKey;
  v5 = *(_QWORD *)(m_hashKey + 156);
  v6 = *(float *)(m_hashKey + 164);
  *(_QWORD *)&retstr->x = v5;
  x = retstr->x;
  retstr->z = v6;
  if ( x == 0.0 && retstr->y == 0.0 )
  {
    if ( m_nModelIndex >= 476 )
    {
      switch ( m_nModelIndex )
      {
        case 476:
          v8 = &s_MustangOrdnancePos;
          goto LABEL_21;
        case 520:
          if ( iType == ORDNANCE_TYPE_SECONDARY )
          {
            v8 = &s_HarrierOrdnancePos2;
          }
          else
          {
            if ( iType != ORDNANCE_TYPE_PRIMARY )
              return retstr;
            v8 = &s_HarrierOrdnancePos1;
          }
          goto LABEL_21;
        case 576:
          v8 = &s_TornadoOrdnancePos;
          goto LABEL_21;
      }
    }
    else
    {
      switch ( m_nModelIndex )
      {
        case 425:
          v8 = &s_HunterOrdnancePos;
          goto LABEL_21;
        case 447:
          v8 = &s_SeaSparrowOrdnancePos;
          goto LABEL_21;
        case 464:
          v8 = &s_RCBaronOrdnancePos;
LABEL_21:
          v9 = *(_QWORD *)&v8->x;
          retstr->z = v8->z;
          *(_QWORD *)&retstr->x = v9;
          return retstr;
      }
    }
    retstr->x = 0.0;
    retstr->y = 0.0;
    retstr->z = 0.0;
  }
  return retstr;
}

//----- (0058FA70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CEntity *__fastcall CVehicle::ScanAndMarkTargetForHeatSeekingMissile(CVehicle *this, CEntity *pPreferredExistingTarget)
{
  CSimpleTransform *p_m_transform; // r8
  CMatrix *m_pMat; // r0
  float Tolerance; // lr
  CSimpleTransform *p_tx; // r2
  float xy; // r3
  float yy; // r6
  float zy; // r5
  RwReal y; // r4
  CEntity *v11; // r4
  CVehicle *v12; // r6
  CVehicle *v13; // r0
  int m_nFlags; // r11
  int v15; // r10
  CMatrix *v16; // r0
  CMatrix *v17; // r2
  const CVector *p_m_translate; // r1
  int IsLineOfSightClear; // r0
  int v20; // r2
  CEntity *v21; // r8
  CMatrix *v22; // r0
  CVector *v23; // r3
  float bCheckPeds; // [sp+0h] [bp-38h]
  float v26; // [sp+4h] [bp-34h]
  CVector v28; // 0:r0.12

  p_m_transform = &this->m_transform;
  m_pMat = this->m_pMat;
  LOWORD(Tolerance) = -26214;
  p_tx = p_m_transform;
  yy = m_pMat->yy;
  xy = m_pMat->xy;
  zy = m_pMat->zy;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  y = p_tx->m_translate.y;
  v28.x = p_tx->m_translate.x;
  HIWORD(Tolerance) = 16281;
  v28.z = p_tx->m_translate.z;
  bCheckPeds = yy;
  v26 = zy;
  v28.y = y;
  v11 = CWeapon::PickTargetForHeatSeekingMissile(v28, *(CVector *)&xy, Tolerance, this, 1, pPreferredExistingTarget);
  v12 = 0;
  if ( this->m_vehicleType == 4 )
  {
    if ( !(2 * *(_DWORD *)&this[1].m_upgrades[3]) )
      v12 = (CVehicle *)(&dword_0 + 1);
    v13 = v12;
    v12 = this;
    if ( !v11 )
      goto LABEL_20;
  }
  else
  {
    v13 = 0;
    if ( !v11 )
      goto LABEL_20;
  }
  if ( CTimer::m_snTimeInMilliseconds - (unsigned int)v13 > 0x3E8 )
  {
    m_nFlags = (int)this->m_nFlags;
    v15 = (int)v11->m_nFlags;
    *(_DWORD *)&this->m_nFlags = m_nFlags & 0xFFFFFFFE;
    v16 = v11->m_pMat;
    *(_DWORD *)&v11->m_nFlags &= ~1u;
    v17 = this->m_pMat;
    p_m_translate = (const CVector *)&v16->tx;
    if ( !v16 )
      p_m_translate = &v11->m_transform.m_translate;
    if ( v17 )
      p_m_transform = (CSimpleTransform *)&v17->tx;
    IsLineOfSightClear = CWorld::GetIsLineOfSightClear(&p_m_transform->m_translate, p_m_translate, 1, 1, 0, 1, 0, 1, 0);
    *(_DWORD *)&this->m_nFlags = *(_DWORD *)&this->m_nFlags & 0xFFFFFFFE | m_nFlags & 1;
    *(_DWORD *)&v11->m_nFlags = *(_DWORD *)&v11->m_nFlags & 0xFFFFFFFE | v15 & 1;
    if ( v12 )
    {
      v20 = IsLineOfSightClear << 31;
      if ( CTimer::m_snTimeInMilliseconds > 1 )
        v20 = (IsLineOfSightClear << 31) | 1;
      *(_DWORD *)&v12[1].m_upgrades[3] = v20;
    }
    if ( IsLineOfSightClear )
      goto LABEL_25;
LABEL_29:
    v21 = 0;
LABEL_31:
    CWeaponEffects::ClearCrossHairImmediately(0);
    return v21;
  }
LABEL_20:
  if ( !v12 )
  {
    if ( v11 )
      goto LABEL_25;
    goto LABEL_29;
  }
  v21 = 0;
  if ( !v11 || *(int *)&v12[1].m_upgrades[3] > -1 )
    goto LABEL_31;
LABEL_25:
  if ( *(_BYTE *)&this->m_info > 7u )
  {
    v21 = v11;
    goto LABEL_31;
  }
  v22 = v11->m_pMat;
  v23 = (CVector *)&v22->tx;
  if ( !v22 )
    v23 = &v11->m_transform.m_translate;
  CWeaponEffects::MarkTarget(0, *v23, 0xFFu, 0xFFu, 0xFFu, 0x64u, 1.3, 1u);
  return v11;
}
// 58FA70: fragmented variable at r3.4 may be wrong
// 0: using guessed type int dword_0;

//----- (0058FBD8) --------------------------------------------------------
void __fastcall CVehicle::DoPlaneGunFireFX(
        CVehicle *this,
        CWeapon *weapon,
        CVector *gunOffset,
        CVector *wsFirePos,
        int a5)
{
  int32 m_vehicleType; // r0
  UInt32 m_TimeOfCreation; // r2
  int v11; // r1
  unsigned int v12; // r0
  int16 v13; // r6
  CPed *v14; // r2
  int m_nModelIndex; // r1
  unsigned int v16; // r0
  int16 v17; // r6
  bool v18; // zf
  int j; // r3
  int v20; // r2
  int v21; // r6
  bool v22; // zf
  FxSystem_c *v23; // r0
  RwObject_0 *v24; // r1
  RwMatrix *v25; // r3
  CPed *v26; // r0
  bool v27; // zf
  int i; // r3
  int v29; // r2
  int v30; // r6
  bool v31; // zf
  FxSystem_c *v32; // r0
  RwObject_0 *m_pRwObject; // r1
  RwMatrix *v34; // r3
  CVector fGunshellSize[2]; // [sp+0h] [bp-58h] BYREF
  CVector2D dirGunshell; // [sp+2Ch] [bp-2Ch] BYREF
  RwV3d_0 offsetPos; // [sp+34h] [bp-24h] BYREF
  CVector v38; // 0:r1.12

  memset(&offsetPos, 0, sizeof(offsetPos));
  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 3 )
  {
    v14 = this[1].pPassengers[1];
    if ( v14 )
      goto LABEL_63;
    m_nModelIndex = this->m_nModelIndex;
    v16 = 4;
    v17 = this->m_nModelIndex;
    if ( m_nModelIndex < 520 )
    {
      switch ( this->m_nModelIndex )
      {
        case 0x1D0:
        case 0x1E7:
        case 0x1F1:
          goto LABEL_48;
        case 0x1D1:
        case 0x1D2:
        case 0x1D3:
        case 0x1D4:
        case 0x1D5:
        case 0x1D6:
        case 0x1D7:
        case 0x1D8:
        case 0x1D9:
        case 0x1DA:
        case 0x1DB:
        case 0x1DD:
        case 0x1DE:
        case 0x1DF:
        case 0x1E0:
        case 0x1E1:
        case 0x1E2:
        case 0x1E3:
        case 0x1E4:
        case 0x1E5:
        case 0x1E6:
        case 0x1E8:
        case 0x1E9:
        case 0x1EA:
        case 0x1EB:
        case 0x1EC:
        case 0x1ED:
        case 0x1EE:
        case 0x1EF:
        case 0x1F0:
          goto LABEL_47;
        case 0x1DC:
          v16 = 24;
          break;
        default:
          v27 = m_nModelIndex == 425;
          if ( m_nModelIndex != 425 )
            v27 = m_nModelIndex == 447;
          if ( !v27 )
            goto LABEL_47;
          break;
      }
      goto LABEL_48;
    }
    if ( m_nModelIndex != 520 )
    {
      if ( m_nModelIndex == 548 )
      {
LABEL_48:
        this[1].pPassengers[1] = (CPed *)operator new[](v16);
        for ( i = 0; ; ++i )
        {
          v29 = v17;
          v30 = 1;
          if ( v29 >= 520 )
          {
            switch ( v29 )
            {
              case 520:
                goto LABEL_56;
              case 548:
                break;
              case 576:
LABEL_56:
                v30 = 2;
                break;
              default:
LABEL_60:
                v30 = 0;
                break;
            }
          }
          else
          {
            switch ( v29 )
            {
              case 464:
              case 487:
              case 497:
                break;
              case 465:
              case 466:
              case 467:
              case 468:
              case 469:
              case 470:
              case 471:
              case 472:
              case 473:
              case 474:
              case 475:
              case 477:
              case 478:
              case 479:
              case 480:
              case 481:
              case 482:
              case 483:
              case 484:
              case 485:
              case 486:
              case 488:
              case 489:
              case 490:
              case 491:
              case 492:
              case 493:
              case 494:
              case 495:
              case 496:
                goto LABEL_60;
              case 476:
                v30 = 6;
                break;
              default:
                v31 = v29 == 425;
                if ( v29 != 425 )
                  v31 = v29 == 447;
                if ( !v31 )
                  goto LABEL_60;
                break;
            }
          }
          v14 = this[1].pPassengers[1];
          if ( i >= v30 )
          {
            if ( !v14 )
              goto LABEL_70;
LABEL_63:
            v32 = (FxSystem_c *)*((_DWORD *)&v14->_vptr$CPlaceable + a5);
            if ( !v32 )
            {
              m_pRwObject = this->m_pRwObject;
              v34 = m_pRwObject ? (RwMatrix *)((char *)m_pRwObject->parent + 16) : 0;
              *((_DWORD *)&this[1].pPassengers[1]->_vptr$CPlaceable + a5) = FxManager_c::CreateFxSystem(
                                                                              &g_fxMan,
                                                                              "gunflash",
                                                                              &offsetPos,
                                                                              v34,
                                                                              0);
              v32 = (FxSystem_c *)*((_DWORD *)&this[1].pPassengers[1]->_vptr$CPlaceable + a5);
              if ( !v32 )
                goto LABEL_70;
            }
            FxSystem_c::SetOffsetPos(v32, gunOffset);
            v26 = this[1].pPassengers[1];
LABEL_69:
            FxSystem_c::Play(*((FxSystem_c **)&v26->_vptr$CPlaceable + a5));
            goto LABEL_70;
          }
          *((_DWORD *)&v14->_vptr$CPlaceable + i) = 0;
          v17 = this->m_nModelIndex;
        }
      }
      if ( m_nModelIndex != 576 )
      {
LABEL_47:
        v16 = 0;
        goto LABEL_48;
      }
    }
    v16 = 8;
    goto LABEL_48;
  }
  if ( m_vehicleType != 4 )
    return;
  m_TimeOfCreation = this[1].m_TimeOfCreation;
  if ( m_TimeOfCreation )
  {
LABEL_38:
    v23 = *(FxSystem_c **)(m_TimeOfCreation + 4 * a5);
    if ( !v23 )
    {
      v24 = this->m_pRwObject;
      v25 = v24 ? (RwMatrix *)((char *)v24->parent + 16) : 0;
      *(_DWORD *)(this[1].m_TimeOfCreation + 4 * a5) = FxManager_c::CreateFxSystem(
                                                         &g_fxMan,
                                                         "gunflash",
                                                         &offsetPos,
                                                         v25,
                                                         0);
      v23 = *(FxSystem_c **)(this[1].m_TimeOfCreation + 4 * a5);
      if ( !v23 )
        goto LABEL_70;
    }
    FxSystem_c::SetOffsetPos(v23, gunOffset);
    v26 = (CPed *)this[1].m_TimeOfCreation;
    goto LABEL_69;
  }
  v11 = this->m_nModelIndex;
  v12 = 4;
  v13 = this->m_nModelIndex;
  if ( v11 < 520 )
  {
    switch ( this->m_nModelIndex )
    {
      case 0x1D0:
      case 0x1E7:
      case 0x1F1:
        goto LABEL_23;
      case 0x1D1:
      case 0x1D2:
      case 0x1D3:
      case 0x1D4:
      case 0x1D5:
      case 0x1D6:
      case 0x1D7:
      case 0x1D8:
      case 0x1D9:
      case 0x1DA:
      case 0x1DB:
      case 0x1DD:
      case 0x1DE:
      case 0x1DF:
      case 0x1E0:
      case 0x1E1:
      case 0x1E2:
      case 0x1E3:
      case 0x1E4:
      case 0x1E5:
      case 0x1E6:
      case 0x1E8:
      case 0x1E9:
      case 0x1EA:
      case 0x1EB:
      case 0x1EC:
      case 0x1ED:
      case 0x1EE:
      case 0x1EF:
      case 0x1F0:
        goto LABEL_22;
      case 0x1DC:
        v12 = 24;
        break;
      default:
        v18 = v11 == 425;
        if ( v11 != 425 )
          v18 = v11 == 447;
        if ( !v18 )
          goto LABEL_22;
        break;
    }
    goto LABEL_23;
  }
  if ( v11 == 520 )
  {
LABEL_14:
    v12 = 8;
    goto LABEL_23;
  }
  if ( v11 != 548 )
  {
    if ( v11 != 576 )
    {
LABEL_22:
      v12 = 0;
      goto LABEL_23;
    }
    goto LABEL_14;
  }
LABEL_23:
  this[1].m_TimeOfCreation = operator new[](v12);
  for ( j = 0; ; ++j )
  {
    v20 = v13;
    v21 = 1;
    if ( v20 >= 520 )
    {
      switch ( v20 )
      {
        case 520:
          goto LABEL_31;
        case 548:
          break;
        case 576:
LABEL_31:
          v21 = 2;
          break;
        default:
LABEL_35:
          v21 = 0;
          break;
      }
    }
    else
    {
      switch ( v20 )
      {
        case 464:
        case 487:
        case 497:
          break;
        case 465:
        case 466:
        case 467:
        case 468:
        case 469:
        case 470:
        case 471:
        case 472:
        case 473:
        case 474:
        case 475:
        case 477:
        case 478:
        case 479:
        case 480:
        case 481:
        case 482:
        case 483:
        case 484:
        case 485:
        case 486:
        case 488:
        case 489:
        case 490:
        case 491:
        case 492:
        case 493:
        case 494:
        case 495:
        case 496:
          goto LABEL_35;
        case 476:
          v21 = 6;
          break;
        default:
          v22 = v20 == 425;
          if ( v20 != 425 )
            v22 = v20 == 447;
          if ( !v22 )
            goto LABEL_35;
          break;
      }
    }
    m_TimeOfCreation = this[1].m_TimeOfCreation;
    if ( j >= v21 )
      break;
    *(_DWORD *)(m_TimeOfCreation + 4 * j) = 0;
    v13 = this->m_nModelIndex;
  }
  if ( m_TimeOfCreation )
    goto LABEL_38;
LABEL_70:
  if ( CVehicle::s_bPlaneGunsEjectShellCasings )
  {
    dirGunshell.y = 0.1;
    dirGunshell.x = 0.0;
    CWeapon::AddGunshell(weapon, this, wsFirePos, &dirGunshell, 0.5);
  }
  v38 = *wsFirePos;
  memset(fGunshellSize, 0, 12);
  CPointLights::AddLight(0, v38, fGunshellSize[0], 3.0, 0.5, 0.4, 0.0, 0, 0, 0);
}

//----- (0058FF20) --------------------------------------------------------
bool __fastcall CVehicle::CanBeDriven(const CVehicle *this)
{
  int32 m_vehicleType; // r0
  bool result; // r0
  CBaseModelInfo *v4; // r1
  int v5; // r2
  float *m_hashKey; // r1

  m_vehicleType = this->m_vehicleType;
  if ( m_vehicleType == 11 || m_vehicleType == 6 && LOBYTE(this[1].m_nFlags.bdummy) )
    return 0;
  result = 0;
  if ( !(*((unsigned __int8 *)&this->m_nVehicleFlags + 4) >> 7) )
  {
    v4 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
    v5 = *(_DWORD *)&v4[1].m_modelName[20];
    m_hashKey = (float *)v4[2].m_hashKey;
    if ( v5 != 5 )
      m_hashKey += 12;
    if ( (float)((float)((float)(*m_hashKey * *m_hashKey) + (float)(m_hashKey[1] * m_hashKey[1]))
               + (float)(m_hashKey[2] * m_hashKey[2])) > 0.0 )
      return 1;
  }
  return result;
}

//----- (0058FF90) --------------------------------------------------------
void __fastcall CVehicle::ReactToVehicleDamage(CVehicle *this, CPed *pInflictor)
{
  unsigned __int16 v4; // r0
  int v5; // s0
  CPed *pDriver; // r2
  char v7; // r0
  int v8; // s0
  char v9; // r0
  CPed *v10; // r2

  v4 = rand();
  pDriver = this->pDriver;
  if ( pDriver )
  {
    v5 = (int)(float)((float)((float)v4 * 0.000015259) * 3000.0);
    if ( this->pPassengers[0] && (v7 = rand(), pDriver = this->pDriver, (v7 & 1) != 0) )
      IKChainManager_c::LookAt(
        &g_ikChainMan,
        "ReactToVhclDam",
        pDriver,
        this->pPassengers[0],
        v5 + 2000,
        5,
        0,
        0,
        0.25,
        500,
        3,
        0);
    else
      IKChainManager_c::LookAt(
        &g_ikChainMan,
        "ReactToVhclDam",
        pDriver,
        pInflictor,
        v5 + 2000,
        5,
        0,
        0,
        0.25,
        500,
        3,
        0);
  }
  v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3000.0);
  if ( this->pPassengers[0] )
  {
    v9 = rand();
    v10 = this->pPassengers[0];
    if ( (v9 & 1) != 0 )
      IKChainManager_c::LookAt(&g_ikChainMan, "ReactToVhclDam", v10, this->pDriver, v8 + 2000, 5, 0, 0, 0.25, 500, 3, 0);
    else
      IKChainManager_c::LookAt(&g_ikChainMan, "ReactToVhclDam", v10, pInflictor, v8 + 2000, 5, 0, 0, 0.25, 500, 3, 0);
  }
}

//----- (00590128) --------------------------------------------------------
void __fastcall CVehicle::ProcessSirenAndHorn(CVehicle *this, bool bHornAvailable)
{
  int m_nModelIndex; // r0
  bool v4; // zf
  CWidget *v5; // r5
  int v6; // r2
  unsigned int v7; // r2
  int CarAlarmState; // r0
  bool v9; // zf

  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex > 522 )
  {
    if ( (unsigned int)(m_nModelIndex - 596) > 5 || m_nModelIndex == 600 )
    {
      v4 = m_nModelIndex == 528;
      if ( m_nModelIndex != 528 )
        v4 = m_nModelIndex == 523;
      if ( !v4 )
        goto LABEL_21;
    }
  }
  else if ( ((unsigned int)(m_nModelIndex - 407) > 0x1A || ((1 << (m_nModelIndex + 105)) & 0x4910201) == 0)
         && m_nModelIndex != 490 )
  {
LABEL_21:
    if ( bHornAvailable )
    {
      CarAlarmState = this->CarAlarmState;
      v9 = CarAlarmState == 0;
      if ( this->CarAlarmState )
        v9 = CarAlarmState == 0xFFFF;
      if ( v9 || (*(_BYTE *)&this->m_info & 0xF8) == 40 )
        this->m_cHorn = CPad::GetHorn(Pads, 1);
    }
    return;
  }
  this->m_cHorn = 0;
  v5 = CTouchInterface::m_pWidgets[7];
  if ( CTouchInterface::m_pWidgets[7] )
  {
    if ( CTouchInterface::m_pWidgets[7]->m_fTapHoldTime > 0.2
      && !(*((unsigned __int8 *)&this->m_nVehicleFlags + 5) >> 7) )
    {
      this->m_cHorn = 1;
    }
    if ( CPad::HornJustDown(Pads) )
    {
      v6 = *((_DWORD *)&this->m_nVehicleFlags + 1);
      if ( v5->m_fTapHoldTime <= 0.2 )
        v7 = v6 ^ 0x8000;
      else
        v7 = v6 & 0xFFFF7FFF;
      *(_DWORD *)&this->m_nVehicleFlags = this->m_nVehicleFlags;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v7;
    }
  }
}

//----- (00590230) --------------------------------------------------------
bool8 __fastcall CVehicle::GetVehicleLightsStatus(CVehicle *this)
{
  unsigned int RandomSeed; // r0
  float v3; // s0
  int v4; // r5
  int v5; // r0
  bool v6; // zf
  CPed *pDriver; // r0
  char v9; // r2
  char v10; // r0

  if ( CClock::ms_nGameClockHours > 0x14u )
    goto LABEL_13;
  if ( CClock::ms_nGameClockHours == 20 )
  {
    if ( CClock::ms_nGameClockMinutes > (this->RandomSeed & 0x3Fu) )
      goto LABEL_13;
  }
  else
  {
    if ( CClock::ms_nGameClockHours < 6u )
      goto LABEL_13;
    if ( CClock::ms_nGameClockHours == 6 )
    {
      RandomSeed = 32;
      if ( CClock::ms_nGameClockMinutes < 0x20u )
        goto LABEL_13;
      goto LABEL_10;
    }
  }
  RandomSeed = this->RandomSeed;
LABEL_10:
  v3 = (float)RandomSeed / 50000.0;
  if ( CWeather::Foggyness <= v3 && CWeather::WetRoads <= v3 )
  {
    v4 = 0;
    goto LABEL_14;
  }
LABEL_13:
  v4 = 1;
LABEL_14:
  if ( this->m_lightingFromCollision >= 0.05 )
  {
    if ( !v4 )
      return 0;
  }
  else
  {
    v5 = CCullZones::CamNoRain();
    v6 = v4 == 0;
    if ( !v4 )
      v6 = v5 == 0;
    if ( v6 )
      return 0;
  }
  pDriver = this->pDriver;
  if ( !pDriver || (unsigned int)(pDriver->m_nPedType - 7) > 9 )
    return 1;
  v9 = 0;
  v10 = pDriver->RandomSeed;
  if ( !CPopCycle::m_bCurrentZoneIsGangArea )
    v9 = 1;
  return v9 & 1 | ((v10 & 1) == 0);
}
// 2A: using guessed type __int16 word_2A;

//----- (0059032C) --------------------------------------------------------
bool __fastcall CVehicle::DoHeadLightEffect(CVehicle *this, int32 lightId, CMatrix *matVehicle, int isRight, int a5)
{
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  char v10; // r2
  char v12; // r3
  float *v13; // r0
  char v14; // r1
  float v15; // s18
  float v16; // s16
  float v17; // s20
  bool v18; // fzf
  _BOOL4 result; // r0
  CMatrix *m_pMat; // r0
  float xy; // s4
  float yy; // s2
  float v23; // s0
  float m_heading; // r4
  float v25; // r8
  CMatrix *v26; // r6
  CSimpleTransform *p_tx; // r0
  float z; // s10
  RwReal v29; // s2
  float v30; // r10
  float v31; // s16
  int32 m_vehicleType; // r1
  int *v33; // r3
  float v34; // s0
  float v35; // s16
  char *v36; // r6
  UInt8 B; // r3
  UInt8 v38; // r2
  int *v39; // r5
  int v40; // s0
  float v41; // s0
  int *v42; // r2
  int *v43; // r4
  int v44; // [sp+48h] [bp-60h]
  CVector v45; // [sp+4Ch] [bp-5Ch] BYREF
  CVector v46; // [sp+58h] [bp-50h] BYREF
  CVector v; // [sp+64h] [bp-44h] BYREF

  v10 = 0;
  v12 = lightId;
  v13 = (float *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 24 * lightId);
  v14 = 0;
  v15 = v13[1];
  v16 = *v13;
  v17 = v13[2];
  v18 = *v13 == 0.0;
  result = 0;
  if ( v15 == 0.0 )
    v14 = 1;
  if ( v18 )
    v10 = 1;
  if ( lightId != 1 )
    v12 = 0;
  if ( ((unsigned __int8)(v14 & v10 & v12) & (v17 == 0.0)) == 0 && MobileSettings::settings[0].value )
  {
    m_pMat = this->m_pMat;
    if ( m_pMat )
    {
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      v23 = m_pMat->zy * 0.05;
    }
    else
    {
      m_heading = this->m_transform.m_heading;
      v25 = sinf(m_heading);
      yy = cosf(m_heading);
      v23 = 0.0;
      LODWORD(xy) = LODWORD(v25) ^ 0x80000000;
    }
    v44 = isRight;
    v.z = v17 + v23;
    v.y = v15 + (float)(yy * 0.05);
    v.x = v16 + (float)(xy * 0.05);
    if ( !isRight )
      v.x = (float)(v16 + (float)(xy * 0.05)) + (float)(v16 * -2.0);
    v26 = TheCamera.m_pMat;
    operator*(&v45, matVehicle, &v);
    p_tx = (CSimpleTransform *)&v26->tx;
    if ( !v26 )
      p_tx = &TheCamera.m_transform;
    z = p_tx->m_translate.z;
    v29 = p_tx->m_translate.y - v45.y;
    v46.x = p_tx->m_translate.x - v45.x;
    v46.y = v29;
    v46.z = z - v45.z;
    v30 = CVector::NormaliseAndMag(&v46);
    if ( !a5 )
    {
      v31 = (float)((float)(v46.x * matVehicle->xy) + (float)(v46.y * matVehicle->yy)) + (float)(v46.z * matVehicle->zy);
      if ( v31 > 0.0 && (TheCamera.Cams[TheCamera.ActiveCam].Mode != 16 || FindPlayerVehicle(-1, 0) != this) )
      {
        m_vehicleType = this->m_vehicleType;
        if ( m_vehicleType == 6 )
        {
          v33 = dword_5906FC;
          if ( this->m_nModelIndex == 449 )
            v33 = &dword_5906FC[1];
          v34 = *(float *)v33;
        }
        else
        {
          v34 = 0.9;
        }
        v35 = sqrtf(v31);
        v36 = (char *)this + 2 * lightId + v44;
        if ( v30 < 40.0 && v35 > v34 )
        {
          B = -61;
          v38 = -106;
          if ( (this->pHandling->hFlags & 0x400000) == 0 )
          {
            B = -116;
            v38 = -96;
          }
          if ( m_vehicleType == 6 )
          {
            v39 = dword_59070C;
            if ( this->m_nModelIndex == 449 )
              v39 = &dword_59070C[1];
            v40 = *v39;
          }
          else
          {
            v40 = 1033476506;
          }
          CCoronas::RegisterCorona(
            (u_native)(v36 + 4),
            this,
            v38,
            v38,
            B,
            0xFFu,
            &v,
            *(float *)&v40,
            TheCamera.LODDistMultiplier * 150.0,
            4,
            0,
            0,
            0,
            0,
            v35,
            0,
            0.3,
            0,
            15.0,
            0,
            0);
          m_vehicleType = this->m_vehicleType;
        }
        v6.n64_u32[0] = 1.0;
        v5.n64_f32[0] = (float)(v35 * 0.5) + 0.3;
        v41 = (float)((float)(v30 / -150.0) + 1.0) * (float)(v35 * 0.4);
        if ( m_vehicleType == 6 && this->m_nModelIndex != 449 )
        {
          v41 = v41 * 4.0;
          v5.n64_f32[0] = v5.n64_f32[0] + v5.n64_f32[0];
          v5.n64_u32[0] = vmin_f32(v5, v6).n64_u32[0];
        }
        v42 = dword_59072C;
        v43 = dword_590734;
        if ( (this->pHandling->hFlags & 0x400000) == 0 )
          v42 = &dword_59072C[1];
        if ( (this->pHandling->hFlags & 0x400000) == 0 )
          v43 = &dword_590734[1];
        CCoronas::RegisterCorona(
          (u_native)v36,
          this,
          (int)(float)(v5.n64_f32[0] * *(float *)v42),
          (int)(float)(v5.n64_f32[0] * *(float *)v42),
          (int)(float)(v5.n64_f32[0] * *(float *)v43),
          0x80u,
          &v,
          v41,
          TheCamera.LODDistMultiplier * 150.0,
          1,
          0,
          1u,
          0,
          0,
          v35,
          0,
          0.5,
          0,
          15.0,
          0,
          0);
      }
    }
    return a5 == 0;
  }
  return result;
}
// 59062E: variable 'v5' is possibly undefined
// 59062E: variable 'v6' is possibly undefined
// 5906FC: using guessed type int dword_5906FC[2];
// 59070C: using guessed type int dword_59070C[2];
// 59072C: using guessed type int dword_59072C[2];
// 590734: using guessed type int dword_590734[3];

//----- (00590740) --------------------------------------------------------
void __fastcall CVehicle::DoHeadLightBeam(CVehicle *this, int32 lightId, CMatrix *matVehicle, bool8 isRight)
{
  int v6; // r6
  uint32 v7; // r0
  __int64 v8; // d16
  float x; // s0
  float y; // s2
  float z; // s4
  CSimpleTransform *p_tx; // r2
  RwReal v13; // s2
  RwReal v14; // s4
  float xy; // s16
  float yy; // s20
  float zy; // s18
  float v18; // s22
  float v19; // s26
  float v20; // s24
  float v21; // s0
  RwReal v22; // s2
  RwReal v23; // s4
  RwReal v24; // s0
  float v25; // s0
  float v26; // s2
  float v27; // s4
  float v28; // s14
  float v29; // s1
  float v30; // s10
  CVector v31; // [sp+0h] [bp-90h] BYREF
  CVector v32; // [sp+Ch] [bp-84h] BYREF
  CVector v33; // [sp+18h] [bp-78h] BYREF
  CVector v34; // [sp+24h] [bp-6Ch] BYREF
  CVector v; // [sp+30h] [bp-60h] BYREF

  v6 = isRight;
  v7 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 24 * lightId;
  v8 = *(_QWORD *)v7;
  v.z = *(RwReal *)(v7 + 8);
  *(_QWORD *)&v.x = v8;
  if ( lightId != 1 || v.x != 0.0 || v.z != 0.0 )
  {
    operator*(&v34, matVehicle, &v);
    if ( v6 )
    {
      x = v34.x;
      y = v34.y;
      z = v34.z;
    }
    else
    {
      x = v34.x - (float)(matVehicle->xx * (float)(v.x + v.x));
      y = v34.y - (float)((float)(v.x + v.x) * matVehicle->yx);
      z = v34.z - (float)((float)(v.x + v.x) * matVehicle->zx);
      v34.x = x;
      v34.y = y;
      v34.z = z;
    }
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v13 = p_tx->m_translate.y - y;
    v14 = p_tx->m_translate.z - z;
    v33.x = p_tx->m_translate.x - x;
    v33.y = v13;
    v33.z = v14;
    CVector::NormaliseAndMag(&v33);
    xy = matVehicle->xy;
    yy = matVehicle->yy;
    zy = matVehicle->zy;
    v18 = v33.x;
    v19 = v33.y;
    v20 = v33.z;
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
    RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
    v21 = 0.15;
    if ( this->m_nModelIndex == 530 )
      v21 = 0.5;
    v22 = matVehicle->xy - (float)(matVehicle->xz * v21);
    v23 = matVehicle->yy - (float)(v21 * matVehicle->yz);
    v24 = matVehicle->zy - (float)(v21 * matVehicle->zz);
    v32.y = v23;
    v32.x = v22;
    v32.z = v24;
    CVector::Normalise(&v32);
    CrossProduct(&v31, &v32, &v33);
    CVector::Normalise(&v31);
    v25 = matVehicle->xy;
    v26 = matVehicle->yy * 0.1;
    v27 = matVehicle->zy * 0.1;
    *(_QWORD *)TempBufferRenderIndexList = 0x1000400010000LL;
    *(_QWORD *)&TempBufferRenderIndexList[4] = 0x3000200040003LL;
    TempBufferRenderIndexList[8] = 4;
    *(_DWORD *)&TempBufferRenderIndexList[9] = 0x20000;
    v34.x = v34.x - (float)(v25 * 0.1);
    v34.y = v34.y - v26;
    v34.z = v34.z - v27;
    v28 = (float)(v32.x * 3.0) + v34.x;
    TempBufferRenderIndexList[11] = 4;
    TempBufferVerticesStored = 5;
    v29 = (float)(v32.z * 3.0) + v34.z;
    TempBufferIndicesStored = 12;
    v30 = (float)(v32.y * 3.0) + v34.y;
    TempVertexBuffer.m_3d[0].color = (RwRGBA_0)(((unsigned int)(float)((float)(1.0
                                                                             - fabsf(
                                                                                 (float)((float)(v18 * xy)
                                                                                       + (float)(v19 * yy))
                                                                               + (float)(v20 * zy)))
                                                                     * 32.0) << 24) | 0xFFFFFF);
    TempVertexBuffer.m_3d[1].color = TempVertexBuffer.m_3d[0].color;
    TempVertexBuffer.m_3d[2].color = (RwRGBA_0)0xFFFFFF;
    TempVertexBuffer.m_3d[0].position.x = v34.x - (float)(v31.x * 0.05);
    TempVertexBuffer.m_3d[0].position.y = v34.y - (float)(v31.y * 0.05);
    TempVertexBuffer.m_3d[0].position.z = v34.z - (float)(v31.z * 0.05);
    TempVertexBuffer.m_3d[1].position.x = (float)(v31.x * 0.05) + v34.x;
    TempVertexBuffer.m_3d[1].position.y = (float)(v31.y * 0.05) + v34.y;
    TempVertexBuffer.m_3d[1].position.z = (float)(v31.z * 0.05) + v34.z;
    TempVertexBuffer.m_3d[2].position.x = v28 - (float)(v31.x * 0.5);
    TempVertexBuffer.m_3d[2].position.y = v30 - (float)(v31.y * 0.5);
    TempVertexBuffer.m_3d[2].position.z = v29 - (float)(v31.z * 0.5);
    TempVertexBuffer.m_3d[3].color = (RwRGBA_0)0xFFFFFF;
    TempVertexBuffer.m_3d[3].position.x = v28 + (float)(v31.x * 0.5);
    TempVertexBuffer.m_3d[3].position.y = v30 + (float)(v31.y * 0.5);
    TempVertexBuffer.m_3d[3].position.z = v29 + (float)(v31.z * 0.5);
    TempVertexBuffer.m_3d[4].color = TempVertexBuffer.m_3d[0].color;
    TempVertexBuffer.m_3d[4].position.x = (float)(v32.x * 0.2) + v34.x;
    TempVertexBuffer.m_3d[4].position.y = (float)(v32.y * 0.2) + v34.y;
    TempVertexBuffer.m_3d[4].position.z = (float)(v32.z * 0.2) + v34.z;
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, 5u, 0, 0x18u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 2);
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (00590B74) --------------------------------------------------------
void __fastcall CVehicle::DoHeadLightReflectionSingle(CVehicle *this, CMatrix *matVehicle, bool8 isRight)
{
  int m_nModelIndex; // r12
  CMatrix *m_pMat; // lr
  float *m_hashKey; // r3
  float v6; // s0
  float v7; // s2
  CSimpleTransform *p_tx; // r3
  __int64 v9; // d16
  float xy; // s6
  float yy; // s4
  float v12; // s8
  float xx; // s10
  float yx; // s12
  float v15; // s14
  float v16; // s4
  float v17; // s6
  float v18; // s8
  float v19; // s10
  float v20; // s12
  float v21; // s2
  CVector pShadowPos; // [sp+20h] [bp-18h] BYREF

  m_nModelIndex = this->m_nModelIndex;
  m_pMat = this->m_pMat;
  m_hashKey = (float *)CModelInfo::ms_modelInfoPtrs[m_nModelIndex][2].m_hashKey;
  v6 = *m_hashKey;
  v7 = m_hashKey[1];
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v9 = *(_QWORD *)&p_tx->m_translate.x;
  pShadowPos.z = p_tx->m_translate.z;
  *(_QWORD *)&pShadowPos.x = v9;
  xy = matVehicle->xy;
  yy = matVehicle->yy;
  v12 = (float)(xy * xy) + (float)(yy * yy);
  if ( !isRight )
    v6 = -v6;
  if ( v12 != 0.0 )
    v12 = 1.0 / sqrtf(v12);
  xx = matVehicle->xx;
  yx = matVehicle->yx;
  v15 = (float)(xx * xx) + (float)(yx * yx);
  if ( v15 != 0.0 )
    v15 = 1.0 / sqrtf(v15);
  v16 = yy * v12;
  v17 = xy * v12;
  v18 = yx * v15;
  v19 = xx * v15;
  if ( this->m_vehicleType == 9 || (unsigned __int16)m_nModelIndex == 471 )
    v20 = 1.25;
  else
    v20 = fabsf(v6) * 4.0;
  v21 = v7 + (float)((float)(v20 + v20) + 1.0);
  pShadowPos.z = pShadowPos.z + 2.0;
  pShadowPos.x = (float)(v6 * v19) + (float)(pShadowPos.x + (float)(v17 * v21));
  pShadowPos.y = (float)(v6 * v18) + (float)(pShadowPos.y + (float)(v16 * v21));
  CShadows::StoreCarLightShadow(
    this,
    (Int32)&this->m_pMat + 2,
    gpShadowHeadLightsTex2,
    &pShadowPos,
    v17 * (float)(v20 + v20),
    v16 * (float)(v20 + v20),
    v16 * v20,
    -(float)(v17 * v20),
    0x2D0000002DLL,
    45,
    7.0);
}

//----- (00590CE4) --------------------------------------------------------
void __fastcall CVehicle::DoHeadLightReflectionTwin(CVehicle *this, CMatrix *matVehicle)
{
  float *m_hashKey; // r2
  float v3; // s2
  float v4; // s0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  __int64 v7; // d16
  float xy; // s6
  float yy; // s4
  float v10; // s8
  float v11; // s6
  float v12; // s4
  float v13; // s2
  float v14; // s0
  CVector pShadowPos; // [sp+20h] [bp-18h] BYREF

  m_hashKey = (float *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey;
  v3 = *m_hashKey;
  v4 = m_hashKey[1];
  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v7 = *(_QWORD *)&p_tx->m_translate.x;
  pShadowPos.z = p_tx->m_translate.z;
  *(_QWORD *)&pShadowPos.x = v7;
  xy = matVehicle->xy;
  yy = matVehicle->yy;
  v10 = (float)(xy * xy) + (float)(yy * yy);
  if ( v10 != 0.0 )
    v10 = 1.0 / sqrtf(v10);
  v11 = xy * v10;
  v12 = yy * v10;
  v13 = v3 * 4.0;
  pShadowPos.z = pShadowPos.z + 2.0;
  v14 = v4 + (float)((float)(v13 + v13) + 1.0);
  pShadowPos.x = pShadowPos.x + (float)(v14 * v11);
  pShadowPos.y = (float)(v14 * v12) + pShadowPos.y;
  CShadows::StoreCarLightShadow(
    this,
    (Int32)&this->m_pMat + 2,
    gpShadowHeadLightsTex,
    &pShadowPos,
    (float)(v13 + v13) * v11,
    (float)(v13 + v13) * v12,
    v13 * v12,
    -(float)(v13 * v11),
    0x2D0000002DLL,
    45,
    7.0);
}

//----- (00590DE4) --------------------------------------------------------
void __fastcall CVehicle::DoHeadLightReflection(
        CVehicle *this,
        CMatrix *matVehicle,
        uint32 nLightFlags,
        int doLeft,
        int doRight)
{
  bool8 v5; // r2
  bool v6; // zf

  if ( !(nLightFlags << 31) )
  {
    if ( this->m_nModelIndex == 532 )
    {
LABEL_3:
      CVehicle::DoHeadLightReflectionTwin(this, matVehicle);
      return;
    }
    v5 = 1;
    goto LABEL_5;
  }
  v6 = doLeft == 0;
  if ( doLeft )
    v6 = doRight == 0;
  if ( !v6 )
    goto LABEL_3;
  if ( doLeft )
  {
    v5 = 0;
LABEL_5:
    CVehicle::DoHeadLightReflectionSingle(this, matVehicle, v5);
    return;
  }
  if ( doRight )
  {
    v5 = 1;
    goto LABEL_5;
  }
}

//----- (00590E14) --------------------------------------------------------
int __fastcall CVehicle::DoTailLightEffect(
        CVehicle *this,
        int32 lightId,
        CMatrix *matVehicle,
        int isRight,
        int forcedOff,
        uint32 nLightFlags,
        int lightsOn)
{
  float32x2_t v7; // d1
  float32x2_t v8; // d2
  int m_nModelIndex; // r0
  bool v14; // zf
  uint32 v15; // r0
  float v16; // s0
  RwReal v17; // s2
  CMatrix *m_pMat; // r5
  CSimpleTransform *p_tx; // r0
  float z; // s10
  RwReal v22; // s2
  float v23; // r4
  char v24; // r0
  float yy; // s2
  float v26; // s0
  float zy; // s4
  int v28; // r6
  float v29; // s16
  float v30; // s0
  float v31; // s2
  float v32; // s6
  int v33; // r1
  CVector v34; // [sp+44h] [bp-4Ch] BYREF
  CVector v35; // [sp+50h] [bp-40h] BYREF
  CVector v; // [sp+5Ch] [bp-34h] BYREF

  if ( !MobileSettings::settings[0].value )
    return 0;
  m_nModelIndex = this->m_nModelIndex;
  v14 = m_nModelIndex == 475;
  if ( m_nModelIndex != 475 )
    v14 = m_nModelIndex == 439;
  if ( v14 )
  {
    if ( CDamageManager::GetPanelStatus((const CDamageManager *)&this[1], 6) )
      return 0;
    LOWORD(m_nModelIndex) = this->m_nModelIndex;
  }
  v15 = CModelInfo::ms_modelInfoPtrs[(__int16)m_nModelIndex][2].m_hashKey + 12 * ((2 * lightId) | 1);
  v16 = *(float *)v15;
  v17 = *(float *)(v15 + 8);
  if ( lightId == 1 && *(float *)(v15 + 4) == 0.0 )
    return 0;
  v.y = *(RwReal *)(v15 + 4);
  v.x = v16;
  v.z = v17;
  if ( !isRight )
    v.x = v16 + (float)(v16 * -2.0);
  m_pMat = TheCamera.m_pMat;
  operator*(&v34, matVehicle, &v);
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &TheCamera.m_transform;
  z = p_tx->m_translate.z;
  v22 = p_tx->m_translate.y - v34.y;
  v35.x = p_tx->m_translate.x - v34.x;
  v35.y = v22;
  v35.z = z - v34.z;
  v23 = CVector::NormaliseAndMag(&v35);
  v24 = 0;
  if ( forcedOff )
  {
    v28 = 0;
  }
  else
  {
    yy = matVehicle->yy;
    v26 = matVehicle->xy * v35.x;
    zy = matVehicle->zy;
    v28 = 0;
    v29 = (float)((float)-(float)(yy * v35.y) - v26) - (float)(zy * v35.z);
    if ( v29 > 0.0 )
    {
      if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 16 )
      {
        v28 = 0;
        if ( FindPlayerVehicle(-1, 0) == this )
          goto LABEL_32;
      }
      v7.n64_u32[0] = 1.0;
      v8.n64_f32[0] = (float)(v29 * 0.5) + 0.2;
      v30 = (float)((float)(v23 / -150.0) + 1.0) * (float)(v29 * 0.2);
      if ( this->m_vehicleType == 6 && this->m_nModelIndex != 449 )
      {
        v8.n64_f32[0] = v8.n64_f32[0] * 3.0;
        v30 = v30 * 4.0;
        v8.n64_u32[0] = vmin_f32(v8, v7).n64_u32[0];
      }
      v31 = sqrtf(v29);
      if ( this->m_fBrakePedal <= 0.0 || (*(_BYTE *)&this->m_nVehicleFlags & 0x20) != 0 || !this->pDriver )
      {
        if ( !lightsOn )
        {
          v28 = 0;
          LOBYTE(v33) = 0;
          goto LABEL_31;
        }
        v32 = 96.0;
      }
      else
      {
        v32 = 128.0;
      }
      v28 = 1;
      v33 = (int)(float)(v8.n64_f32[0] * v32);
LABEL_31:
      CCoronas::RegisterCorona(
        (u_native)&this->m_transform.m_translate.y + 2 * lightId + isRight,
        this,
        v33,
        0,
        0,
        0x80u,
        &v,
        v30,
        TheCamera.LODDistMultiplier * 150.0,
        1,
        0,
        1u,
        0,
        0,
        v31,
        0,
        0.5,
        0,
        15.0,
        0,
        0);
LABEL_32:
      v24 = 0;
    }
  }
  if ( !forcedOff )
    v24 = 1;
  return (unsigned __int8)v24 & (v28 != 0);
}
// 590FFE: variable 'v8' is possibly undefined
// 590FFE: variable 'v7' is possibly undefined

//----- (005910E0) --------------------------------------------------------
void __fastcall CVehicle::DoVehicleLights(CVehicle *this, CMatrix *matVehicle, uint32 nLightFlags)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d2
  int VehicleLightsStatus; // r0
  unsigned int m_nVehicleFlags; // r1
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // lr
  int v10; // r2
  unsigned int m_info; // r3
  unsigned int v12; // r0
  int v13; // r3
  int v14; // r0
  uint32 v15; // r10
  int CarAlarmState; // r0
  int v17; // r9
  int v19; // r2
  bool v20; // zf
  bool v21; // zf
  float v22; // s0
  CVehicle *v23; // r5
  int32 m_baseVehicleType; // r1
  _BOOL4 v25; // r12
  int v26; // r8
  const CDamageManager *v27; // r0
  _BOOL4 v28; // r5
  uint32 v29; // r0
  uint32 v30; // r11
  _BOOL4 v31; // r5
  uint32 v32; // r0
  const CDamageManager *v33; // r11
  uint32 LightStatus; // r9
  uint32 v35; // r0
  _BOOL4 v36; // r9
  uint32 v37; // r0
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r5
  CSimpleTransform *p_m_transform; // r3
  _BOOL4 v46; // r2
  _BOOL4 v47; // r1
  int v48; // r6
  int v49; // r8
  int v50; // r5
  int v51; // r6
  int v52; // r5
  bool v53; // r0
  char v54; // r1
  char v55; // r1
  int v56; // r0
  int v57; // r0
  CVehicle::CVehicleFlags *v58; // r1
  CVehicle *v59; // r0
  CMatrix *v60; // r1
  bool8 v61; // r2
  int v62; // r6
  int v63; // r0
  int v64; // r0
  CMatrix *v65; // r0
  CMatrix **p_m_pMat; // r6
  CSimpleTransform *v67; // r10
  float *p_xy; // r5
  float xy; // r12
  CSimpleTransform *v70; // r3
  float *p_zy; // r9
  float zy; // lr
  float *p_yy; // r5
  unsigned int v74; // t1
  CVector forcedOff; // [sp+0h] [bp-60h]
  CVector forcedOffa; // [sp+0h] [bp-60h]
  uint32 v77; // [sp+4h] [bp-5Ch]
  uint32 v78; // [sp+4h] [bp-5Ch]
  uint32 v79; // [sp+4h] [bp-5Ch]
  uint32 v80; // [sp+4h] [bp-5Ch]
  uint32 v81; // [sp+4h] [bp-5Ch]
  __int64 v82; // [sp+28h] [bp-38h]
  int v83; // [sp+34h] [bp-2Ch]
  int v84; // [sp+34h] [bp-2Ch]
  _BOOL4 Coorsa; // [sp+38h] [bp-28h]
  _BOOL4 Coors; // [sp+38h] [bp-28h]
  CVehicle::CVehicleFlags *v87; // [sp+3Ch] [bp-24h]
  CMatrix *v89; // [sp+40h] [bp-20h]
  CVector m_translate; // 0:r1.12
  CVector v91; // 0:r1.12

  if ( CVehicle::ms_forceVehicleLightsOff )
    return;
  VehicleLightsStatus = CVehicle::GetVehicleLightsStatus(this);
  m_nVehicleFlags = (unsigned int)this->m_nVehicleFlags;
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  v10 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  if ( ((m_nVehicleFlags >> 6) & 1) != VehicleLightsStatus )
  {
    m_info = (unsigned __int8)this->m_info;
    if ( m_info >> 3 != 5 )
    {
      if ( m_info >> 3 != 4 || this->m_vehicleType == 6 )
      {
        m_nVehicleFlags = m_nVehicleFlags & 0xFFFFFFBF | ((VehicleLightsStatus & 1) << 6);
LABEL_7:
        *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
        *((_DWORD *)&this->m_nVehicleFlags + 1) = v10;
        goto LABEL_8;
      }
      if ( (m_nVehicleFlags & 0x40) != 0 )
      {
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        _D16 = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.x, *(float32x2_t *)&p_tx->m_translate.x).n64_i64[0];
        __asm { VCLT.F32        D0, D16, #0.0 }
        v3.n64_u64[0] = vbsl_s64(_D0, vneg_f32((float32x2_t)_D16).n64_i64[0], _D16);
        if ( (float)(v3.n64_f32[0] + v3.n64_f32[1]) > 100.0 )
        {
          m_nVehicleFlags &= ~0x40u;
          goto LABEL_7;
        }
      }
    }
  }
LABEL_8:
  v12 = *((unsigned __int8 *)this + 1202);
  v13 = (v12 >> 3) & 3;
  if ( v13 )
  {
    v14 = v12 & 0x18;
    if ( v13 == 1 )
    {
      m_nVehicleFlags &= ~0x40u;
      *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = v10;
    }
    v15 = v14 == 16;
  }
  else
  {
    v15 = 0;
  }
  CarAlarmState = this->CarAlarmState;
  v17 = 0;
  _ZF = CarAlarmState == 0;
  if ( this->CarAlarmState )
    _ZF = CarAlarmState == 0xFFFF;
  if ( !_ZF )
  {
    v17 = 0;
    if ( (*(_BYTE *)&this->m_info & 0xF8) != 40 )
    {
      if ( (CTimer::m_snTimeInMilliseconds & 0x100) == 0 )
        v17 = 1;
      v15 = (CTimer::m_snTimeInMilliseconds >> 8) & 1;
    }
  }
  if ( this->m_nModelIndex == 477 )
  {
    v19 = *(_BYTE *)&this->m_info & 0xF8;
    v20 = v19 == 40;
    if ( v19 != 40 )
      v20 = (m_nVehicleFlags & 0x10) == 0;
    if ( !v20 )
    {
      if ( v15 | ((unsigned __int8)(m_nVehicleFlags & 0x40) >> 6) )
        goto LABEL_31;
      v21 = CarAlarmState == 0;
      if ( this->CarAlarmState )
        v21 = CarAlarmState == 0xFFFF;
      if ( v21 )
      {
        v3.n64_u32[0] = *(_DWORD *)&this[1].AutoPilot.InvertDirVeryOldLink;
        if ( v3.n64_f32[0] > 0.0 )
        {
          v4.n64_u32[0] = 0;
          v3.n64_f32[0] = v3.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.01);
          *(_DWORD *)&this[1].AutoPilot.InvertDirVeryOldLink = vmax_f32(v3, v4).n64_u32[0];
        }
      }
      else
      {
LABEL_31:
        v4.n64_u32[0] = 1060288707;
        v3.n64_f32[0] = *(float *)&this[1].AutoPilot.InvertDirVeryOldLink + (float)(CTimer::ms_fTimeStep * 0.01);
        v22 = vmin_f32(v3, v4).n64_f32[0];
        *(float *)&this[1].AutoPilot.InvertDirVeryOldLink = v22;
        if ( v22 < 0.69813 )
          return;
      }
    }
  }
  v23 = this;
  m_baseVehicleType = this->m_baseVehicleType;
  *((_BYTE *)this + 1428) &= 0xF0u;
  if ( m_baseVehicleType )
    v23 = 0;
  if ( (nLightFlags & 4) != 0 )
  {
    v30 = nLightFlags & 1;
    v26 = 1;
    v25 = 1;
    v31 = v30;
    v32 = v30;
    goto LABEL_58;
  }
  v25 = 0;
  if ( v23 )
    v25 = CDamageManager::GetLightStatus((const CDamageManager *)&v23[1], RIGHT_HEADLIGHT) == 0;
  v26 = 0;
  if ( nLightFlags << 31 )
  {
    if ( v23 )
    {
      v33 = (const CDamageManager *)&v23[1];
      Coorsa = v25;
      v83 = v17;
      LightStatus = CDamageManager::GetLightStatus((const CDamageManager *)&v23[1], LEFT_HEADLIGHT);
      v35 = CDamageManager::GetLightStatus((const CDamageManager *)&v23[1], RIGHT_TAIL_LIGHT);
      v31 = LightStatus == 0;
      v36 = v35 == 0;
      v37 = CDamageManager::GetLightStatus(v33, RIGHT_TAIL_LIGHT);
      v25 = Coorsa;
      if ( !v37 )
        v26 = 1;
      v30 = 1;
      v32 = v26;
      v26 = v36;
      v17 = v83;
      goto LABEL_57;
    }
    v30 = 1;
  }
  else if ( v23 )
  {
    v27 = (const CDamageManager *)&v23[1];
    v28 = v25;
    v29 = CDamageManager::GetLightStatus(v27, RIGHT_TAIL_LIGHT);
    v26 = 0;
    v25 = v28;
    if ( !v29 )
      v26 = 1;
    v30 = 0;
  }
  else
  {
    v30 = 0;
  }
  v31 = 0;
  v32 = 0;
LABEL_57:
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
LABEL_58:
  v46 = (nLightFlags & 0x20) == 0;
  v47 = (nLightFlags & 0x10) == 0;
  if ( (*(_DWORD *)p_m_nVehicleFlags & 0x10) == 0 )
    return;
  v48 = v46 & v26;
  v49 = v46 & v32;
  if ( v15 | ((*(_DWORD *)p_m_nVehicleFlags & 0x40u) >> 6) | v17 )
  {
    v84 = v48;
    Coors = v25;
    v87 = p_m_nVehicleFlags;
    v50 = v31 && v47;
    LODWORD(v82) = v47 && v25;
    v51 = v17 | (!v47 || !v25);
    *((_BYTE *)this + 1428) = CVehicle::DoHeadLightEffect(this, 0, matVehicle, 1u, v51) | *((_BYTE *)this + 1428) & 0xFE;
    HIDWORD(v82) = v50;
    v52 = v17 | v50 ^ 1;
    v53 = CVehicle::DoHeadLightEffect(this, 0, matVehicle, 0, v52);
    v54 = *((_BYTE *)this + 1428);
    _ZF = (v54 & 1) == 0;
    v55 = v54 & 0xFD | (2 * v53);
    *((_BYTE *)this + 1428) = v55;
    if ( !_ZF )
    {
      CVehicle::DoHeadLightEffect(this, 1, matVehicle, 1u, v51);
      v55 = *((_BYTE *)this + 1428);
    }
    if ( (v55 & 2) != 0 )
      CVehicle::DoHeadLightEffect(this, 1, matVehicle, 0, v52);
    v56 = (4 * CVehicle::DoTailLightEffect(this, 0, matVehicle, 1u, v17 | v84 ^ 1, v77, 1)) & 4;
    *((_BYTE *)this + 1428) = *((_BYTE *)this + 1428) & 0xFB | v56;
    if ( v56 )
      CVehicle::DoTailLightEffect(this, 1, matVehicle, 1u, v17 | v84 ^ 1, v78, 1);
    if ( v30 == 1 )
    {
      v57 = (8 * CVehicle::DoTailLightEffect(this, 0, matVehicle, 0, v17 | v49 ^ 1, v78, 1)) & 8;
      *((_BYTE *)this + 1428) = *((_BYTE *)this + 1428) & 0xF7 | v57;
      if ( v57 )
        CVehicle::DoTailLightEffect(this, 1, matVehicle, 0, v17 | v49 ^ 1, v79, 1);
    }
    v58 = p_m_nVehicleFlags;
    if ( v17 | (this->m_vehicleType == 6) )
      goto LABEL_85;
    if ( v30 )
    {
      if ( (Coors & HIDWORD(v82)) != 1 )
      {
        if ( HIDWORD(v82) == 1 )
        {
          v59 = this;
          v60 = matVehicle;
          v61 = 0;
LABEL_83:
          CVehicle::DoHeadLightReflectionSingle(v59, v60, v61);
          goto LABEL_84;
        }
        if ( (_DWORD)v82 != 1 )
          goto LABEL_85;
LABEL_82:
        v60 = matVehicle;
        v59 = this;
        v61 = 1;
        goto LABEL_83;
      }
    }
    else if ( this->m_nModelIndex != 532 )
    {
      goto LABEL_82;
    }
    CVehicle::DoHeadLightReflectionTwin(this, matVehicle);
LABEL_84:
    v58 = p_m_nVehicleFlags;
LABEL_85:
    if ( !v17 )
    {
      if ( v82 )
      {
        p_m_pMat = &this->m_pMat;
        v65 = this->m_pMat;
        v67 = &this->m_transform;
        p_xy = &matVehicle->xy;
        xy = matVehicle->xy;
        v70 = &this->m_transform;
        if ( v65 )
          v70 = (CSimpleTransform *)&v65->tx;
        m_translate = v70->m_translate;
        p_zy = &matVehicle->zy;
        zy = matVehicle->zy;
        v89 = (CMatrix *)&matVehicle->xy;
        v74 = *((_DWORD *)p_xy + 1);
        p_yy = p_xy + 1;
        forcedOff.x = xy;
        *(_QWORD *)&forcedOff.y = __PAIR64__(LODWORD(zy), v74);
        if ( (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                   + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) >= 0.2025 )
          CPointLights::AddLight(1u, m_translate, forcedOff, 20.0, 1.0, 1.0, 1.0, 0, 0, 0);
        else
          CPointLights::AddLight(1u, m_translate, forcedOff, 20.0, 1.0, 1.0, 1.0, 1u, 0, 0);
        v58 = v87;
      }
      else
      {
        v67 = &this->m_transform;
        p_m_pMat = &this->m_pMat;
        p_zy = &matVehicle->zy;
        p_yy = &matVehicle->yy;
        v89 = (CMatrix *)&matVehicle->xy;
      }
      if ( *p_m_pMat )
        v67 = (CSimpleTransform *)&(*p_m_pMat)->tx;
      if ( (v84 | v49) == 1 && this->m_fBrakePedal > 0.0 && (*(_BYTE *)v58 & 0x20) == 0 )
      {
        if ( this->pDriver )
        {
          v91.z = v67->m_translate.z - (float)(*p_zy * 4.0);
          v91.y = v67->m_translate.y - (float)(*p_yy * 4.0);
          v91.x = v67->m_translate.x - (float)(v89->xx * 4.0);
          forcedOffa.x = -v89->xx;
          forcedOffa.y = -*p_yy;
          forcedOffa.z = -*p_zy;
          CPointLights::AddLight(1u, v91, forcedOffa, 10.0, 0.1, 0.02, 0.02, 0, 0, this);
        }
      }
    }
    return;
  }
  v62 = v48 ^ 1;
  v63 = (4 * CVehicle::DoTailLightEffect(this, 0, matVehicle, 1u, v62, v77, 0)) & 4;
  *((_BYTE *)this + 1428) = *((_BYTE *)this + 1428) & 0xFB | v63;
  if ( v63 )
    CVehicle::DoTailLightEffect(this, 1, matVehicle, 1u, v62, v80, 0);
  if ( v30 == 1 )
  {
    v64 = (8 * CVehicle::DoTailLightEffect(this, 0, matVehicle, 0, v49 ^ 1, v80, 0)) & 8;
    *((_BYTE *)this + 1428) = *((_BYTE *)this + 1428) & 0xF7 | v64;
    if ( v64 )
      CVehicle::DoTailLightEffect(this, 1, matVehicle, 0, v49 ^ 1, v81, 0);
  }
}
// 591208: variable 'v3' is possibly undefined
// 591208: variable 'v4' is possibly undefined
// 591472: variable 'v77' is possibly undefined
// 59149C: variable 'v78' is possibly undefined
// 5914E8: variable 'v79' is possibly undefined
// 591558: variable 'v80' is possibly undefined
// 5915A2: variable 'v81' is possibly undefined
// 679D90: using guessed type char *CVehicle::ms_forceVehicleLightsOff[3];

//----- (0059178C) --------------------------------------------------------
void __fastcall CVehicle::FillVehicleWithPeds(CVehicle *this, bool bBigPeds)
{
  CPlayerPed *pPed; // r11
  UInt32 v4; // r9
  int v5; // r0
  int v6; // r8
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  CPed *v9; // r5
  int v10; // r0
  int v11; // r2
  CPed *v12; // r0
  CVehicle *v13; // r1
  bool v14; // r3
  CPed *v15; // r0
  CPed *pDriver; // r0

  pPed = CWorld::Players[0].pPed;
  if ( bBigPeds )
  {
    CStats::SetStatValue(0x15u, 1000.0);
    CPedClothesDesc::SetModel(pPed->m_pPlayerData->m_pClothes, "afro", 1);
    v4 = 0;
    CClothes::RebuildPlayer(pPed, 0);
  }
  else
  {
    v4 = 95;
  }
  v5 = 0;
  do
  {
    v6 = v5;
    if ( v5 || (v15 = this->pDriver) == 0 || v15 != pPed )
    {
      if ( CStreaming::ms_aInfoForModel[v4].m_status == 1 )
      {
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        v9 = CPopulation::AddPed(PEDTYPE_CIVFEMALE, v4, &p_tx->m_translate, 0);
        if ( v6 )
        {
          v10 = *((_DWORD *)&this->pDriver + v6);
          if ( v10 )
            (*(void (__fastcall **)(int))(*(_DWORD *)v10 + 4))(v10);
          v11 = CCarEnterExit::ComputeTargetDoorToEnterAsPassenger(this, v6 - 1);
          v12 = v9;
          v13 = this;
          v14 = 0;
        }
        else
        {
          pDriver = this->pDriver;
          if ( pDriver )
            (*((void (__fastcall **)(CPed *))pDriver->_vptr$CPlaceable + 1))(pDriver);
          v12 = v9;
          v13 = this;
          v11 = 0;
          v14 = 1;
        }
        CCarEnterExit::SetPedInCarDirect(v12, v13, v11, v14);
      }
      else
      {
        CStreaming::RequestModel(v4, 8);
      }
    }
    v5 = v6 + 1;
  }
  while ( v6 < this->m_nMaxPassengers );
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00591898) --------------------------------------------------------
float __fastcall CVehicle::GetDooorAngleOpenRatio(const CVehicle *this, const eDoors doorId)
{
  return 0.0;
}

//----- (0059189C) --------------------------------------------------------
void __fastcall CVehicle::ProcessOpenDoor(
        CVehicle *this,
        CPed *pPed,
        uint32 nDoor,
        uint32 nAnimGroupId,
        uint32 nAnimId,
        float fCurrTime)
{
  int v10; // r4
  float v11; // s0
  float v12; // s0
  CVehicleAnimGroup *v13; // r0
  float v14; // s0
  float v15; // s2
  CVehicleAnimGroup *v16; // r0
  float v17; // s0
  float v18; // s2
  float v19; // s16
  CVehicleAnimGroup *v20; // r0
  CVehicleAnimGroup *v21; // r0
  int (**v22)(void); // r0
  void (__fastcall *v23)(CVehicle *, CPed *, uint32, int, int, int); // r5
  float v24; // r0
  float v25; // s0
  float v26; // s2
  float v27; // s2
  int v28; // r1

  if ( nDoor - 8 > 3 )
    v10 = 2;
  else
    v10 = dword_591C38[nDoor - 8];
  if ( !(*((int (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 34))(this, v10) )
  {
    switch ( nAnimId )
    {
      case 0x163u:
      case 0x164u:
      case 0x165u:
      case 0x166u:
        v13 = &CVehicleAnimGroupData::m_vehicleAnimGroups[this->pHandling->AnimGroup];
        v14 = v13->m_processDoorStartTimes[0];
        v15 = v13->m_processDoorStopTimes[0];
        if ( v14 < fCurrTime && v15 > fCurrTime )
          goto LABEL_20;
        if ( v15 < fCurrTime )
          goto LABEL_40;
        if ( v14 > fCurrTime )
          (*((void (__fastcall **)(CVehicle *, CPed *, uint32, int, _DWORD, _DWORD))this->_vptr$CPlaceable + 28))(
            this,
            pPed,
            nDoor,
            v10,
            0,
            0);
        return;
      case 0x16Cu:
      case 0x16Du:
      case 0x16Eu:
        if ( nAnimGroupId - 88 <= 0x19 && ((1 << (nAnimGroupId - 88)) & 0x2598007) != 0 )
        {
          v23 = (void (__fastcall *)(CVehicle *, CPed *, uint32, int, int, int))*((_DWORD *)this->_vptr$CPlaceable + 28);
          goto LABEL_41;
        }
        return;
      case 0x16Fu:
      case 0x170u:
      case 0x171u:
      case 0x172u:
        v16 = &CVehicleAnimGroupData::m_vehicleAnimGroups[this->pHandling->AnimGroup];
        v17 = v16->m_processDoorStartTimes[1];
        v18 = v16->m_processDoorStopTimes[1];
        if ( v17 >= fCurrTime || v18 <= fCurrTime )
          goto LABEL_25;
        v19 = 1.0 - (float)((float)(fCurrTime - v17) / (float)(v18 - v17));
        if ( (*((float (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 30))(this, v10) > v19 )
          goto LABEL_21;
        return;
      case 0x175u:
      case 0x176u:
      case 0x177u:
      case 0x178u:
        v20 = &CVehicleAnimGroupData::m_vehicleAnimGroups[this->pHandling->AnimGroup];
        v14 = v20->m_processDoorStartTimes[2];
        v15 = v20->m_processDoorStopTimes[2];
        if ( v14 >= fCurrTime || v15 <= fCurrTime )
        {
          if ( v15 < fCurrTime )
            goto LABEL_40;
          if ( v14 > fCurrTime )
            goto LABEL_55;
        }
        else
        {
LABEL_20:
          v19 = (float)(fCurrTime - v14) / (float)(v15 - v14);
          if ( (*((float (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 30))(this, v10) < v19 )
LABEL_21:
            (*((void (__fastcall **)(CVehicle *, CPed *, uint32, int, float, int))this->_vptr$CPlaceable + 28))(
              this,
              pPed,
              nDoor,
              v10,
              COERCE_FLOAT(LODWORD(v19)),
              1);
        }
        return;
      case 0x17Au:
      case 0x17Bu:
      case 0x183u:
      case 0x184u:
        v11 = 0.1;
        if ( fCurrTime > 0.1 && fCurrTime < 0.4 )
        {
          v12 = (float)(fCurrTime + -0.1) / 0.3;
          goto LABEL_48;
        }
        v27 = 0.4;
        goto LABEL_39;
      case 0x17Cu:
      case 0x17Du:
      case 0x17Eu:
      case 0x17Fu:
        v21 = &CVehicleAnimGroupData::m_vehicleAnimGroups[this->pHandling->AnimGroup];
        v17 = v21->m_processDoorStartTimes[3];
        v18 = v21->m_processDoorStopTimes[3];
        if ( v17 < fCurrTime && v18 > fCurrTime )
        {
          v22 = this->_vptr$CPlaceable;
          v12 = 1.0 - (float)((float)(fCurrTime - v17) / (float)(v18 - v17));
          goto LABEL_49;
        }
LABEL_25:
        if ( v18 < fCurrTime )
          goto LABEL_55;
        if ( v17 <= fCurrTime )
          return;
        goto LABEL_40;
      case 0x180u:
      case 0x181u:
        v11 = 0.01;
        if ( fCurrTime > 0.01 && fCurrTime < 0.1 )
        {
          v24 = COERCE_FLOAT((*((int (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 30))(this, v10));
          v25 = -0.01;
          v26 = 0.09;
          goto LABEL_47;
        }
        v27 = 0.1;
LABEL_39:
        if ( fCurrTime > v27 )
        {
LABEL_40:
          v23 = (void (__fastcall *)(CVehicle *, CPed *, uint32, int, int, int))*((_DWORD *)this->_vptr$CPlaceable + 28);
LABEL_41:
          v28 = 1065353216;
          goto LABEL_56;
        }
        if ( fCurrTime < v11 )
          goto LABEL_55;
        return;
      case 0x182u:
        if ( fCurrTime >= 0.3 || fCurrTime <= 0.05 )
        {
          if ( fCurrTime > 0.3 && fCurrTime < 0.475 )
          {
            v12 = (float)((float)(fCurrTime + -0.3) / -0.175) + 1.0;
            if ( (*((float (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 30))(this, v10) <= v12 )
              return;
            goto LABEL_48;
          }
          if ( fCurrTime > 0.475 )
          {
LABEL_55:
            v28 = 0;
            v23 = (void (__fastcall *)(CVehicle *, CPed *, uint32, int, int, int))*((_DWORD *)this->_vptr$CPlaceable + 28);
LABEL_56:
            v23(this, pPed, nDoor, v10, v28, 1);
          }
        }
        else
        {
          v24 = COERCE_FLOAT((*((int (__fastcall **)(CVehicle *, int))this->_vptr$CPlaceable + 30))(this, v10));
          v25 = -0.05;
          v26 = 0.15;
LABEL_47:
          v12 = (float)(fCurrTime + v25) / v26;
          if ( v24 < v12 )
          {
LABEL_48:
            v22 = this->_vptr$CPlaceable;
LABEL_49:
            ((void (__fastcall *)(CVehicle *, CPed *, uint32, int, float, int))v22[28])(
              this,
              pPed,
              nDoor,
              v10,
              COERCE_FLOAT(LODWORD(v12)),
              1);
            return;
          }
        }
        break;
      default:
        return;
    }
  }
}
// 591C38: using guessed type int dword_591C38[4];

//----- (00591C8C) --------------------------------------------------------
bool __fastcall CVehicle::CanPedLeanOut(const CVehicle *this, CPed *pPed)
{
  int AnimGroup; // r2
  bool result; // r0
  unsigned int m_vehicleType; // r1

  AnimGroup = this->pHandling->AnimGroup;
  if ( (unsigned int)(AnimGroup - 14) < 5 )
    return 0;
  if ( AnimGroup == 13 )
    return this->pPassengers[0] == pPed || this->pDriver == pPed;
  m_vehicleType = this->m_vehicleType;
  result = 0;
  if ( (m_vehicleType > 6 || ((1 << m_vehicleType) & 0x58) == 0) && m_vehicleType != 5 )
    return 1;
  return result;
}

//----- (00591CDC) --------------------------------------------------------
void __fastcall CVehicle::SetVehicleCreatedBy(CVehicle *this, Int32 NewVehicleCreatedBy, bool DontAdd)
{
  UInt8 v3; // r5

  v3 = NewVehicleCreatedBy;
  if ( DontAdd )
  {
    this->VehicleCreatedBy = NewVehicleCreatedBy;
  }
  else if ( this->VehicleCreatedBy != NewVehicleCreatedBy )
  {
    CCarCtrl::UpdateCarCount(this, 1u);
    this->VehicleCreatedBy = v3;
    sub_18ECA0(this, 0);
  }
}

//----- (00591D10) --------------------------------------------------------
float __fastcall CVehicle::GetNewSteeringAmt(CVehicle *this)
{
  return 0.0;
}

//----- (00591D14) --------------------------------------------------------
CVector *__fastcall CVehicle::GetGasTankPosition(CVector *retstr, CVehicle *this)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  __int64 v6; // d16
  CVector *result; // r0
  uint32 m_hashKey; // r0
  __int64 v9; // d16
  __int64 v10; // d16
  CVector v11; // [sp+0h] [bp-28h] BYREF
  CVector v; // [sp+10h] [bp-18h] BYREF

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v6 = *(_QWORD *)&p_tx->m_translate.x;
  retstr->z = p_tx->m_translate.z;
  *(_QWORD *)&retstr->x = v6;
  result = (CVector *)(*((unsigned __int8 *)&this->m_nVehicleFlags + 6) << 25);
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 6) & 0x40) != 0 )
  {
    m_hashKey = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey;
    v9 = *(_QWORD *)(m_hashKey + 96);
    result = *(CVector **)(m_hashKey + 104);
    *(_QWORD *)&v.x = v9;
    LODWORD(v.z) = result;
    if ( *(float *)&v9 != 0.0 || v.z != 0.0 )
    {
      operator*(&v11, m_pMat, &v);
      v10 = *(_QWORD *)&v11.x;
      result = (CVector *)LODWORD(v11.z);
      retstr->z = v11.z;
      *(_QWORD *)&retstr->x = v10;
    }
  }
  return result;
}

//----- (00591DA0) --------------------------------------------------------
void __fastcall CVehicle::SetTappedGasTankVehicle(CEntity *pTappedGasTankVehicle)
{
  if ( CVehicle::m_pTappedGasTankVehicle )
    CEntity::CleanUpOldReference(CVehicle::m_pTappedGasTankVehicle, &CVehicle::m_pTappedGasTankVehicle);
  CVehicle::m_pTappedGasTankVehicle = pTappedGasTankVehicle;
  if ( pTappedGasTankVehicle )
    sub_196050(pTappedGasTankVehicle, &CVehicle::m_pTappedGasTankVehicle);
}

//----- (00591DE8) --------------------------------------------------------
int __fastcall CVehicleAnimGroup::GetGroup(CVehicleAnimGroup *this, const int index)
{
  CVehicleAnimGroup *v2; // r4
  int v3; // s0

  v2 = this;
  if ( (unsigned int)(index - 355) > 0x23 )
    v3 = 0;
  else
    v3 = dword_61EE60[index - 355];
  if ( (this->m_flags & (int)COERCE_FLOAT(exp2f(v3))) != 0 )
    v2 = (CVehicleAnimGroup *)((char *)v2 + 1);
  return v2->m_firstGroup;
}
// 19CA48: using guessed type int __fastcall exp2f(_DWORD);
// 61EE60: using guessed type _DWORD dword_61EE60[36];

//----- (00591E34) --------------------------------------------------------
float __fastcall CVehicleAnimGroup::ComputeCriticalBlendTime(CVehicleAnimGroup *this, const int index)
{
  int v2; // r2
  float v3; // s0
  int v4; // r1

  v2 = index - 351;
  v3 = 0.0;
  v4 = 0;
  switch ( v2 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      goto LABEL_6;
    case 22:
    case 23:
    case 24:
    case 25:
      v4 = 2;
      goto LABEL_6;
    case 27:
    case 28:
      v4 = 3;
      goto LABEL_6;
    case 33:
    case 34:
      v4 = 1;
      goto LABEL_6;
    case 36:
    case 37:
      v4 = 4;
LABEL_6:
      v3 = this->m_criticalBlendTimes[v4];
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (00591E8C) --------------------------------------------------------
CVector *__fastcall CVehicleAnimGroup::ComputeAnimDoorOffsets(
        CVector *retstr,
        CVehicleAnimGroup *this,
        const int offsetType)
{
  CVehicleAnimGroup *v4; // r5
  float *v5; // r0
  float *v6; // r6
  int v7; // r0
  AnimationId v8; // r8
  int v9; // s0
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r0
  CAnimBlendSequence *m_pSequences; // r5
  int m_iNumKeyFrames; // r0
  int v13; // r0
  uint8 *m_pKeyFrames; // r1
  int v15; // r3
  __int64 v16; // d16
  __int64 v17; // d16
  CVector *result; // r0

  v4 = this;
  v5 = (float *)(&this->m_firstGroup + 12 * offsetType);
  v6 = v5 + 16;
  if ( (float)((float)((float)(v5[16] * v5[16]) + (float)(v5[17] * v5[17])) + (float)(v5[18] * v5[18])) == 0.0 )
  {
    v7 = offsetType - 1;
    if ( (unsigned int)(offsetType - 1) > 5 )
    {
      v9 = 3.0;
      v8 = ANIM_VEH_GETIN_FRONT_LHS;
    }
    else
    {
      v8 = dword_591F5C[v7];
      v9 = dword_591F74[v7];
    }
    if ( (this->m_flags & (int)exp2f(v9)) != 0 )
      v4 = (CVehicleAnimGroup *)((char *)v4 + 1);
    m_pAnimBlendHierarchy = CAnimManager::GetAnimAssociation((AssocGroupId)v4->m_firstGroup, v8)->m_pAnimBlendHierarchy;
    m_pSequences = m_pAnimBlendHierarchy->m_pSequences;
    CAnimManager::UncompressAnimation(m_pAnimBlendHierarchy);
    m_iNumKeyFrames = m_pSequences->m_iNumKeyFrames;
    if ( m_iNumKeyFrames >= 1 )
    {
      v13 = m_iNumKeyFrames - 1;
      m_pKeyFrames = m_pSequences->m_pKeyFrames;
      v15 = 20 * v13;
      if ( (m_pSequences->m_bitsFlag & 2) != 0 )
        v15 = 32 * v13;
      v16 = *(_QWORD *)&m_pKeyFrames[v15 + 20];
      v6[2] = *(float *)&m_pKeyFrames[v15 + 28];
      *(_QWORD *)v6 = v16;
    }
  }
  v17 = *(_QWORD *)v6;
  result = (CVector *)*((_DWORD *)v6 + 2);
  LODWORD(retstr->z) = result;
  *(_QWORD *)&retstr->x = v17;
  return result;
}
// 19CA48: using guessed type float __fastcall exp2f(_DWORD);
// 591F5C: using guessed type int dword_591F5C[6];
// 591F74: using guessed type int dword_591F74[6];

//----- (00591F8C) --------------------------------------------------------
void __fastcall WaterCreature_c::WaterCreature_c(WaterCreature_c *this)
{
  int v1; // r0

  ListItem_c::ListItem_c(this);
  *(_DWORD *)(v1 + 8) = 0;
}
// 591F96: variable 'v1' is possibly undefined

//----- (00591FA0) --------------------------------------------------------
int __fastcall WaterCreature_c::Init(
        WaterCreature_c *this,
        int32 id,
        CVector *pos,
        WaterCreature_c *pLeader,
        float waterLevel,
        float waterDepth)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d1
  int v12; // r5
  WaterCreatureInfo_t *v13; // r3
  uint16 *pModelIndex; // r5
  float minGrouping; // s20
  float maxGrouping; // s22
  float minSpeed; // s16
  float maxSpeed; // s18
  float v19; // s24
  float v20; // s26
  CObject *v21; // r0
  int32 v22; // r1
  CObject *v23; // r0
  CObject *m_pObject; // r0
  CObject *v25; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  CObject *v27; // r0
  CEntity::CFlags v28; // kr08_8
  int v29; // r10
  int v30; // r6
  int v31; // r5
  float v32; // s0
  CObject *v33; // r0
  float y; // s10
  float z; // s12
  float v36; // s0
  float v37; // s2
  float v38; // s4
  float v39; // s0
  float v40; // s2
  float v41; // s4
  CMatrix *m_pMat; // r1
  float *p_tz; // r0
  CObject *v44; // r1
  __int64 v45; // kr10_8
  CMatrix *v46; // r6
  RwReal v47; // r0
  RwReal *p_z; // r1
  CObject *v49; // r0
  CMatrix *v50; // r1
  float m_heading; // s0
  int v52; // r0
  CObject *v53; // r1
  float m_targetHeading; // s0
  CMatrix *v55; // r0
  CObject *v56; // r2
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v59; // r0
  RwMatrix *v60; // r1

  if ( CObject::nNoTempObjects > 0x95u )
    return 0;
  v13 = &WaterCreatureManager_c::ms_waterCreatureInfos[id];
  pModelIndex = v13->pModelIndex;
  minGrouping = v13->minGrouping;
  maxGrouping = v13->maxGrouping;
  minSpeed = v13->minSpeed;
  maxSpeed = v13->maxSpeed;
  if ( !pLeader )
  {
    v19 = waterLevel - WaterCreatureManager_c::ms_waterCreatureInfos[id].minDepth;
    v7.n64_f32[0] = waterLevel + -50.0;
    v6.n64_f32[0] = (float)(waterLevel - waterDepth) + 2.0;
    v20 = vmax_f32(v6, v7).n64_f32[0];
    if ( v19 < v20 )
      return 0;
    pos->z = v20 + (float)((float)(v19 - v20) * (float)((float)rand() * 4.6566e-10));
  }
  CPools::ms_pObjectPool->m_bDealWithNoMemory = 1;
  v21 = (CObject *)CObject::operator new(0x184u);
  v22 = *pModelIndex;
  v12 = 0;
  CObject::CObject(v21, v22, 0);
  this->m_pObject = v23;
  CPools::ms_pObjectPool->m_bDealWithNoMemory = 0;
  m_pObject = this->m_pObject;
  if ( m_pObject )
  {
    m_pObject->m_areaCode = CGame::currArea;
    (*((void (__fastcall **)(CObject *, int))this->m_pObject->_vptr$CPlaceable + 5))(this->m_pObject, 1);
    v25 = this->m_pObject;
    m_nFlags = v25->m_nFlags;
    *(_DWORD *)&v25->m_nFlags = *(_DWORD *)&m_nFlags | 0x100000;
    v25->m_nFlags.bdummy = m_nFlags.bdummy;
    *(_DWORD *)&this->m_pObject->m_nPhysicalFlags &= ~2u;
    *(_DWORD *)&this->m_pObject->m_nFlags &= ~1u;
    this->m_pObject->ObjectCreatedBy = 5;
    if ( (unsigned int)(id - 3) <= 1 )
    {
      v27 = this->m_pObject;
      v28 = v27->m_nFlags;
      *(_DWORD *)&v27->m_nFlags = *(_DWORD *)&v28 | 0x4000;
      v27->m_nFlags.bdummy = v28.bdummy;
    }
    this->m_pLeader = pLeader;
    this->m_id = id;
    this->m_delete = 0;
    if ( pLeader )
    {
      v29 = rand();
      v30 = rand();
      v31 = rand();
      v32 = (float)rand();
      v33 = this->m_pObject;
      y = pos->y;
      z = pos->z;
      v36 = minGrouping + (float)((float)(maxGrouping - minGrouping) * (float)(v32 * 4.6566e-10));
      v37 = (float)((float)((float)((float)v30 * 4.6566e-10) + (float)((float)v30 * 4.6566e-10)) + -1.0) * v36;
      v38 = (float)((float)((float)((float)v29 * 4.6566e-10) + (float)((float)v29 * 4.6566e-10)) + -1.0) * v36;
      v39 = z + (float)((float)((float)((float)v31 * 4.6566e-10) + -0.5) * v36);
      v40 = y + v37;
      v41 = pos->x + v38;
      this->m_offsetPos.x = pos->x - v41;
      this->m_offsetPos.y = y - v40;
      this->m_offsetPos.z = z - v39;
      m_pMat = v33->m_pMat;
      if ( m_pMat )
      {
        m_pMat->tx = v41;
        v33->m_pMat->ty = v40;
        p_tz = &v33->m_pMat->tz;
      }
      else
      {
        v33->m_transform.m_translate.x = v41;
        v33->m_transform.m_translate.y = v40;
        p_tz = &v33->m_transform.m_translate.z;
      }
      *p_tz = v39;
      v49 = pLeader->m_pObject;
      v50 = v49->m_pMat;
      if ( v50 )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(v50->xy) ^ 0x80000000), v50->yy);
      else
        m_heading = v49->m_transform.m_heading;
      this->m_targetHeading = m_heading;
      maxSpeed = pLeader->m_speed;
    }
    else
    {
      v44 = this->m_pObject;
      this->m_offsetPos.x = 0.0;
      this->m_offsetPos.y = 0.0;
      this->m_offsetPos.z = 0.0;
      v45 = *(_QWORD *)&pos->x;
      v46 = v44->m_pMat;
      v47 = pos->z;
      if ( v46 )
      {
        LODWORD(v46->tx) = v45;
        v44->m_pMat->ty = *((float *)&v45 + 1);
        p_z = &v44->m_pMat->tz;
      }
      else
      {
        *(_QWORD *)&v44->m_transform.m_translate.x = v45;
        p_z = &v44->m_transform.m_translate.z;
      }
      *p_z = v47;
      this->m_targetHeading = (float)((float)((float)rand() * 4.6566e-10) * 6.2832) + -3.1416;
    }
    v52 = rand();
    this->m_speedBurstMult = 0;
    v53 = this->m_pObject;
    m_targetHeading = this->m_targetHeading;
    this->m_processingCollision = 1;
    this->m_speed = minSpeed + (float)((float)(maxSpeed - minSpeed) * (float)((float)v52 * 4.6566e-10));
    v55 = v53->m_pMat;
    if ( v55 )
      CMatrix::SetRotateZOnly(v55, m_targetHeading);
    else
      v53->m_transform.m_heading = m_targetHeading;
    v56 = this->m_pObject;
    m_pRwObject = v56->m_pRwObject;
    if ( m_pRwObject )
    {
      parent = (char *)m_pRwObject->parent;
      v59 = v56->m_pMat;
      v60 = (RwMatrix *)(parent + 16);
      if ( v59 )
        CMatrix::UpdateRwMatrix(v59, v60);
      else
        CSimpleTransform::UpdateRwMatrix(&v56->m_transform, v60);
    }
    CEntity::UpdateRwFrame(this->m_pObject);
    CWorld::Add(this->m_pObject);
    v12 = 1;
    ++CObject::nNoTempObjects;
  }
  return v12;
}
// 59201A: variable 'v6' is possibly undefined
// 59201A: variable 'v7' is possibly undefined
// 59206A: variable 'v23' is possibly undefined

//----- (005922DC) --------------------------------------------------------
void __fastcall WaterCreature_c::Exit(WaterCreature_c *this)
{
  CObject *m_pObject; // r0

  List_c::RemoveItem(&g_waterCreatureMan.m_waterCreatureList, this);
  List_c::AddItem(&g_waterCreatureMan.m_waterCreaturePool, this);
  CWorld::Remove(this->m_pObject);
  m_pObject = this->m_pObject;
  if ( m_pObject )
    (*((void (__fastcall **)(CObject *))m_pObject->_vptr$CPlaceable + 1))(m_pObject);
  this->m_pObject = 0;
  --CObject::nNoTempObjects;
}

//----- (0059232C) --------------------------------------------------------
void __fastcall WaterCreature_c::Update(WaterCreature_c *this, float deltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d3
  float32x2_t v5; // d11
  WaterCreatureInfo_t *v8; // r0
  WaterCreature_c *m_pLeader; // r2
  float maxGrouping; // s18
  float minSpeed; // s22
  CObject *m_pObject; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  CObject *v15; // r0
  float v16; // s0
  float v17; // s2
  CMatrix *v18; // r1
  float v19; // s4
  float *p_x; // r2
  RwReal v21; // s0
  RwReal v22; // s4
  float v23; // s20
  float RadianAngleBetweenPoints; // r0
  float v25; // r0
  CObject *v26; // r2
  float v27; // r1
  float v28; // s0
  CMatrix *v29; // r0
  float maxTurnAngle; // s18
  float collCheckDist; // s20
  float turnFreq; // s24
  int v33; // r4
  CObject *v34; // r0
  CMatrix *v35; // r1
  CSimpleTransform *p_m_transform; // r2
  __int64 v37; // d16
  unsigned __int16 v38; // r0
  CObject *v39; // r1
  float *v40; // r0
  float *v41; // r4
  float m_speed; // s24
  WaterCreature_c *v43; // r1
  float *p_m_speed; // r0
  float v45; // s0
  CObject *v46; // r4
  float *p_xx; // r0
  float *v48; // r1
  float32x2_t v49; // d16
  float v50; // s26
  float v51; // s28
  float v52; // s16
  float v53; // s24
  float v54; // s4
  float v55; // s2
  float v56; // s0
  float *p_tz; // r0
  float m_heading; // r5
  float v59; // r6
  float v60; // s0
  RwReal v61; // s4
  float v62; // r5
  float v63; // r6
  float v64; // s4
  float v65; // s0
  float v66; // s2
  float v67; // s8
  float v68; // s6
  float v69; // s10
  bool8 v70; // r4
  float v71; // r0
  CObject *v72; // r4
  CMatrix *v73; // r0
  float v74; // s0
  float m_targetHeading; // s2
  float v76; // s4
  float v77; // s2
  CMatrix *v78; // r0
  int v79; // r0
  int8 *p_m_speedBurstMult; // r5
  unsigned __int16 v81; // r0
  CPlayerPed *PlayerPed; // r0
  CMatrix *v83; // r1
  float *v84; // r2
  RwReal v85; // s0
  RwReal v86; // s2
  float v87; // r0
  float v88; // r1
  unsigned int m_id; // r0
  CObject *v90; // r2
  CMatrix *v91; // r0
  float v92; // s18
  unsigned int m_speedBurstLength; // r2
  unsigned int v94; // r1
  CObject *v95; // r4
  float *v96; // r6
  float v97; // s4
  float v98; // s2
  float v99; // s0
  float v100; // r5
  float v101; // r9
  float v102; // s4
  float v103; // s2
  float v104; // s0
  float *p_z; // r0
  CObject *v106; // r0
  CEntity **p_m_pObject; // r4
  CMatrix *v108; // r1
  CSimpleTransform *v109; // r2
  __int64 v110; // kr00_8
  CEntity *v111; // r0
  float v112; // s0
  CMatrix *v113; // r1
  float *v114; // r0
  CEntity *v115; // r2
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v118; // r0
  RwMatrix *v119; // r1
  CMatrix *v120; // r3
  CSimpleTransform *v121; // r6
  float *v122; // r0
  float x; // s0
  float y; // s2
  float z; // s4
  WaterCreature_c *v126; // r2
  ListItem_c *m_head; // r6
  int v128; // r0
  WaterCreature_c *v129; // r3
  bool v130; // zf
  int v131; // r2
  int v132; // r3
  int v133; // r6
  float *v134; // r5
  int i; // r2
  int v136; // r6
  CEntity *refEntityPtr; // [sp+20h] [bp-F0h] BYREF
  CVector vecEnd; // [sp+24h] [bp-ECh] BYREF
  CVector vecStart; // [sp+30h] [bp-E0h] BYREF
  CColPoint v140[4]; // [sp+40h] [bp-D0h] BYREF

  v8 = &WaterCreatureManager_c::ms_waterCreatureInfos[this->m_id];
  m_pLeader = this->m_pLeader;
  if ( m_pLeader )
  {
    maxGrouping = v8->maxGrouping;
    minSpeed = v8->minSpeed;
    m_pObject = m_pLeader->m_pObject;
    m_pMat = m_pObject->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pObject->m_transform.m_translate.x;
    v15 = this->m_pObject;
    v16 = *p_tx + this->m_offsetPos.x;
    v17 = p_tx[1] + this->m_offsetPos.y;
    v18 = v15->m_pMat;
    v19 = p_tx[2] + this->m_offsetPos.z;
    p_x = &v18->tx;
    if ( !v18 )
      p_x = &v15->m_transform.m_translate.x;
    v21 = v16 - *p_x;
    v22 = v19 - p_x[2];
    v140[0].m_vecPosition.y = v17 - p_x[1];
    v140[0].m_vecPosition.x = v21;
    v140[0].m_vecPosition.z = v22;
    v23 = CVector::NormaliseAndMag(&v140[0].m_vecPosition);
    if ( v23 > 0.0 )
    {
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   v140[0].m_vecPosition.x,
                                   v140[0].m_vecPosition.y,
                                   0.0,
                                   0.0);
      v25 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      v26 = this->m_pObject;
      v27 = v25;
      v28 = v25;
      v29 = v26->m_pMat;
      if ( v29 )
        CMatrix::SetRotateZOnly(v29, v27);
      else
        v26->m_transform.m_heading = v28;
    }
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) < 5 )
    {
      m_speed = this->m_pLeader->m_speed;
      this->m_speed = minSpeed + (float)((float)(m_speed - minSpeed) * (float)((float)rand() * 4.6566e-10));
    }
    v43 = this->m_pLeader;
    p_m_speed = &this->m_speed;
    if ( v43->m_speedBurstMult > 0 )
      p_m_speed = &v43->m_speedBurst;
    v45 = *p_m_speed;
    if ( v23 > 2.0 )
      v45 = (float)((float)(v23 + -2.0) * 1.1) * v45;
    v2.n64_f32[0] = v45 * deltaTime;
    v5.n64_u32[0] = 0;
    v3.n64_f32[0] = v23 + -0.01;
    v46 = this->m_pObject;
    p_xx = &v46->m_pMat->xx;
    v48 = p_xx + 12;
    v49.n64_u64[0] = vmax_f32(v3, v5).n64_u64[0];
    if ( !p_xx )
      v48 = &v46->m_transform.m_translate.x;
    v50 = *v48;
    v51 = v48[1];
    v52 = v48[2];
    LODWORD(v53) = vmin_f32(v2, v49).n64_u32[0];
    if ( p_xx )
    {
      v54 = p_xx[6];
      v55 = v51 + (float)(v53 * p_xx[5]);
      p_xx[12] = v50 + (float)(v53 * p_xx[4]);
      v56 = v53 * v54;
      v46->m_pMat->ty = v55;
      p_tz = &v46->m_pMat->tz;
    }
    else
    {
      m_heading = v46->m_transform.m_heading;
      v59 = sinf(m_heading);
      v60 = cosf(m_heading);
      p_tz = &v46->m_transform.m_translate.z;
      v61 = v51 + (float)(v53 * v60);
      v56 = v53 * 0.0;
      v46->m_transform.m_translate.x = v50 - (float)(v59 * v53);
      v46->m_transform.m_translate.y = v61;
    }
    *p_tz = v52 + v56;
    if ( v23 > (float)(maxGrouping * 5.0) )
      this->m_pLeader = 0;
    goto LABEL_79;
  }
  maxTurnAngle = v8->maxTurnAngle;
  collCheckDist = v8->collCheckDist;
  if ( this->m_processingCollision
    || this->m_speedBurstMult
    || (turnFreq = v8->turnFreq, (float)((float)((float)rand() * 4.6566e-10) + 0.0) >= turnFreq) )
  {
    v33 = 0;
  }
  else
  {
    v33 = 1;
    this->m_targetHeading = (float)((float)((float)rand() * 4.6566e-10) * 6.2832) + -3.1416;
  }
  v34 = this->m_pObject;
  v35 = v34->m_pMat;
  p_m_transform = (CSimpleTransform *)&v35->tx;
  if ( !v35 )
    p_m_transform = &v34->m_transform;
  v37 = *(_QWORD *)&p_m_transform->m_translate.x;
  vecStart.z = p_m_transform->m_translate.z;
  *(_QWORD *)&vecStart.x = v37;
  v38 = rand();
  if ( collCheckDist > 0.0
    && (v33 || (int)(float)((float)((float)v38 * 0.000015259) * 100.0) < 10 || this->m_processingCollision) )
  {
    v39 = this->m_pObject;
    v40 = &v39->m_pMat->xx;
    v41 = v40 + 12;
    if ( v40 )
    {
      v66 = v40[4];
      v64 = v40[5];
      v65 = v40[6];
    }
    else
    {
      v41 = &v39->m_transform.m_translate.x;
      v62 = v39->m_transform.m_heading;
      v63 = sinf(v62);
      v64 = cosf(v62);
      v65 = 0.0;
      LODWORD(v66) = LODWORD(v63) ^ 0x80000000;
    }
    v67 = v41[1];
    v68 = *v41;
    v69 = v41[2];
    v70 = 0;
    vecEnd.y = (float)(collCheckDist * v64) + v67;
    vecEnd.x = (float)(collCheckDist * v66) + v68;
    vecEnd.z = (float)(collCheckDist * v65) + v69;
    if ( CWorld::ProcessLineOfSight(&vecStart, &vecEnd, v140, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 0) == 1 )
    {
      v71 = CGeneral::GetRadianAngleBetweenPoints(v140[0].m_vecNormal.x, v140[0].m_vecNormal.y, 0.0, 0.0);
      v70 = 1;
      this->m_targetHeading = CGeneral::LimitRadianAngle(v71);
    }
    this->m_processingCollision = v70;
  }
  v72 = this->m_pObject;
  v73 = v72->m_pMat;
  if ( v73 )
    v74 = atan2f(COERCE_FLOAT(LODWORD(v73->xy) ^ 0x80000000), v73->yy);
  else
    v74 = v72->m_transform.m_heading;
  m_targetHeading = this->m_targetHeading;
  if ( (float)(v74 + 3.1416) >= m_targetHeading )
  {
    if ( (float)(v74 + -3.1416) <= m_targetHeading )
      goto LABEL_49;
    v76 = 6.2832;
  }
  else
  {
    v76 = -6.2832;
  }
  m_targetHeading = m_targetHeading + v76;
  this->m_targetHeading = m_targetHeading;
LABEL_49:
  v77 = m_targetHeading - v74;
  if ( fabsf(v77) > maxTurnAngle )
  {
    if ( v77 >= 0.0 )
      v74 = maxTurnAngle + v74;
    else
      v74 = v74 - maxTurnAngle;
  }
  v78 = v72->m_pMat;
  if ( v78 )
    CMatrix::SetRotateZOnly(v78, v74);
  else
    v72->m_transform.m_heading = v74;
  if ( !this->m_processingCollision )
  {
    PlayerPed = FindPlayerPed(0);
    v83 = PlayerPed->m_pMat;
    v84 = &v83->tx;
    if ( !v83 )
      v84 = &PlayerPed->m_transform.m_translate.x;
    v85 = vecStart.x - *v84;
    v86 = vecStart.y - v84[1];
    v140[0].m_vecPosition.z = vecStart.z - v84[2];
    v140[0].m_vecPosition.y = v86;
    v140[0].m_vecPosition.x = v85;
    if ( CVector::NormaliseAndMag(&v140[0].m_vecPosition) >= 5.0 )
    {
      p_m_speedBurstMult = &this->m_speedBurstMult;
    }
    else
    {
      this->m_speedBurstMult = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 15.0) + 35;
      p_m_speedBurstMult = &this->m_speedBurstMult;
      this->m_speedBurstTime = 0;
      this->m_speedBurstLength = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 2500.0) + 2000;
      v87 = CGeneral::GetRadianAngleBetweenPoints(v140[0].m_vecPosition.x, v140[0].m_vecPosition.y, 0.0, 0.0);
      v88 = CGeneral::LimitRadianAngle(v87);
      m_id = this->m_id;
      this->m_targetHeading = v88;
      if ( m_id <= 2 )
      {
        v90 = this->m_pObject;
        v91 = v90->m_pMat;
        if ( v91 )
          CMatrix::SetRotateZOnly(v91, v88);
        else
          v90->m_transform.m_heading = v88;
      }
    }
    goto LABEL_67;
  }
  p_m_speedBurstMult = &this->m_speedBurstMult;
  LOBYTE(v79) = this->m_speedBurstMult;
  if ( !(_BYTE)v79 )
  {
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) <= 7 )
    {
      v81 = rand();
      this->m_speedBurstTime = 0;
      this->m_speedBurstMult = (int)(float)((float)((float)v81 * 0.000015259) * 10.0) + 5;
      this->m_speedBurstLength = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1500.0) + 1000;
    }
LABEL_67:
    LOBYTE(v79) = *p_m_speedBurstMult;
  }
  v92 = this->m_speed;
  v79 = (char)v79;
  if ( (char)v79 >= 1 )
  {
    m_speedBurstLength = this->m_speedBurstLength;
    v94 = this->m_speedBurstTime + (unsigned int)(float)(deltaTime * 1000.0);
    this->m_speedBurstTime = v94;
    if ( (unsigned __int16)v94 >= m_speedBurstLength )
      *p_m_speedBurstMult = 0;
    v4.n64_u32[0] = 0;
    v2.n64_f32[0] = 1.0 - (float)((float)(unsigned __int16)v94 / (float)m_speedBurstLength);
    v92 = v92 + (float)(v92 * (float)((float)((float)v79 * 0.1) * vmax_f32(v2, v4).n64_f32[0]));
    this->m_speedBurst = v92;
  }
  v95 = this->m_pObject;
  v96 = &v95->m_pMat->xx;
  if ( v96 )
  {
    v97 = v96[4];
    v98 = v96[5];
    v99 = v96[6];
  }
  else
  {
    v100 = v95->m_transform.m_heading;
    v101 = sinf(v100);
    v98 = cosf(v100);
    v99 = 0.0;
    LODWORD(v97) = LODWORD(v101) ^ 0x80000000;
  }
  v102 = vecStart.x + (float)(v92 * (float)(v97 * deltaTime));
  v103 = (float)(v92 * (float)(v98 * deltaTime)) + vecStart.y;
  v104 = (float)(v92 * (float)(v99 * deltaTime)) + vecStart.z;
  vecStart.x = v102;
  vecStart.y = v103;
  vecStart.z = v104;
  if ( v96 )
  {
    v96[12] = v102;
    v95->m_pMat->ty = v103;
    p_z = &v95->m_pMat->tz;
  }
  else
  {
    p_z = &v95->m_transform.m_translate.z;
    v95->m_transform.m_translate.x = v102;
    v95->m_transform.m_translate.y = v103;
  }
  *p_z = v104;
LABEL_79:
  if ( (unsigned __int8)(this->m_id - 3) >= 2u )
  {
    p_m_pObject = &this->m_pObject;
  }
  else
  {
    p_m_pObject = &this->m_pObject;
    v106 = this->m_pObject;
    v108 = v106->m_pMat;
    v109 = (CSimpleTransform *)&v108->tx;
    if ( !v108 )
      v109 = &v106->m_transform;
    v110 = *(_QWORD *)&v109->m_translate.x;
    if ( CWaterLevel::GetWaterLevel(
           *(float *)&v110,
           *((float *)&v110 + 1),
           v109->m_translate.z,
           &v140[0].m_vecPosition.x,
           1,
           0) == 1 )
    {
      v111 = *p_m_pObject;
      v112 = v140[0].m_vecPosition.x + -0.2;
      v113 = (*p_m_pObject)->m_pMat;
      if ( v113 )
      {
        LODWORD(v113->tx) = v110;
        v111->m_pMat->ty = *((float *)&v110 + 1);
        v114 = &v111->m_pMat->tz;
      }
      else
      {
        *(_QWORD *)&v111->m_transform.m_translate.x = v110;
        v114 = &v111->m_transform.m_translate.z;
      }
      *v114 = v112;
    }
  }
  v115 = *p_m_pObject;
  m_pRwObject = (*p_m_pObject)->m_pRwObject;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    v118 = v115->m_pMat;
    v119 = (RwMatrix *)(parent + 16);
    if ( v118 )
      CMatrix::UpdateRwMatrix(v118, v119);
    else
      CSimpleTransform::UpdateRwMatrix(&v115->m_transform, v119);
  }
  CEntity::UpdateRwFrame(*p_m_pObject);
  CWorld::Remove(*p_m_pObject);
  CWorld::Add(*p_m_pObject);
  v120 = (*p_m_pObject)->m_pMat;
  v121 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    v121 = &TheCamera.m_transform;
  v122 = &v120->tx;
  x = v121->m_translate.x;
  y = v121->m_translate.y;
  z = v121->m_translate.z;
  if ( !v120 )
    v122 = &(*p_m_pObject)->m_transform.m_translate.x;
  if ( (float)((float)((float)((float)(*v122 - x) * (float)(*v122 - x))
                     + (float)((float)(v122[1] - y) * (float)(v122[1] - y)))
             + (float)((float)(v122[2] - z) * (float)(v122[2] - z))) > 3600.0 )
  {
    v126 = this->m_pLeader;
    if ( !v126 )
      v126 = this;
    m_head = g_waterCreatureMan.m_waterCreatureList.m_head;
    v128 = 0;
    while ( 1 )
    {
      v129 = (WaterCreature_c *)m_head;
      if ( !m_head )
        break;
      m_head = m_head->m_next;
      v130 = v126 == v129;
      if ( v126 != v129 )
        v130 = v129->m_pLeader == v126;
      if ( v130 )
        *((_DWORD *)&v140[0].m_vecPosition.x + v128++) = v129;
    }
    if ( v128 >= 1 )
    {
      v131 = 0;
      while ( 1 )
      {
        v132 = *(_DWORD *)(*((_DWORD *)&v140[0].m_vecPosition.x + v131) + 8);
        v133 = *(_DWORD *)(v132 + 20);
        v134 = (float *)(v133 + 48);
        if ( !v133 )
          v134 = (float *)(v132 + 4);
        if ( (float)((float)((float)((float)(*v134 - x) * (float)(*v134 - x))
                           + (float)((float)(v134[1] - y) * (float)(v134[1] - y)))
                   + (float)((float)(v134[2] - z) * (float)(v134[2] - z))) <= 3600.0 )
          break;
        if ( ++v131 >= v128 )
        {
          for ( i = 0; i != v128; ++i )
          {
            v136 = *((_DWORD *)&v140[0].m_vecPosition.x + i);
            *(_BYTE *)(v136 + 13) = 1;
          }
          return;
        }
      }
    }
  }
}
// 59259E: variable 'v3' is possibly undefined
// 59259E: variable 'v5' is possibly undefined
// 5925B4: variable 'v2' is possibly undefined
// 59297A: variable 'v4' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00592BF0) --------------------------------------------------------
void __fastcall WaterCreatureManager_c::TryToExitGroup(WaterCreatureManager_c *this, WaterCreature_c *pWaterCreature)
{
  int v2; // r12
  WaterCreature_c *m_pLeader; // r2
  ListItem_c *m_head; // r0
  int v5; // lr
  WaterCreature_c *v6; // r3
  bool v7; // zf
  CSimpleTransform *p_tx; // r3
  int v9; // r2
  float32x2_t v10; // d16
  float x; // s0
  int v12; // r0
  int v13; // r1
  int v14; // r3
  float32x2_t v15; // d17
  unsigned __int64 v16; // d3
  int i; // r0
  int v18; // r1

  m_pLeader = pWaterCreature->m_pLeader;
  m_head = this->m_waterCreatureList.m_head;
  v5 = 0;
  if ( !m_pLeader )
    m_pLeader = pWaterCreature;
  while ( 1 )
  {
    v6 = (WaterCreature_c *)m_head;
    if ( !m_head )
      break;
    m_head = m_head->m_next;
    v7 = m_pLeader == v6;
    if ( m_pLeader != v6 )
      v7 = v6->m_pLeader == m_pLeader;
    if ( v7 )
      *(_DWORD *)(v2 + 4 * v5++) = v6;
  }
  if ( v5 >= 1 )
  {
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v9 = 0;
    v10.n64_u64[0] = *(unsigned __int64 *)&p_tx->m_translate.y;
    x = p_tx->m_translate.x;
    while ( 1 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v2 + 4 * v9) + 8);
      v13 = *(_DWORD *)(v12 + 20);
      v14 = v13 + 48;
      if ( !v13 )
        v14 = v12 + 4;
      v15.n64_u64[0] = vsub_f32(*(float32x2_t *)(v14 + 4), v10).n64_u64[0];
      v16 = vmul_f32(v15, v15).n64_u64[0];
      if ( (float)((float)((float)((float)(*(float *)v14 - x) * (float)(*(float *)v14 - x)) + *(float *)&v16)
                 + *((float *)&v16 + 1)) <= 3600.0 )
        break;
      if ( ++v9 >= v5 )
      {
        for ( i = 0; i != v5; ++i )
        {
          v18 = *(_DWORD *)(v2 + 4 * i);
          *(_BYTE *)(v18 + 13) = 1;
        }
        return;
      }
    }
  }
}
// 592C92: conditional instruction was optimized away because lr.4>=1
// 592C0C: variable 'v2' is possibly undefined

//----- (00592CB0) --------------------------------------------------------
void __fastcall WaterCreatureManager_c::WaterCreatureManager_c(WaterCreatureManager_c *this)
{
  int i; // r6
  int v3; // r0

  for ( i = 0; i != 6656; i += 52 )
  {
    ListItem_c::ListItem_c((ListItem_c *)((char *)this + i));
    *(_DWORD *)(v3 + 8) = 0;
  }
  List_c::List_c(&this->m_waterCreaturePool);
  List_c::List_c(&this->m_waterCreatureList);
}
// 592CC6: variable 'v3' is possibly undefined

//----- (00592CE8) --------------------------------------------------------
void __fastcall WaterCreatureManager_c::~WaterCreatureManager_c(WaterCreatureManager_c *this)
{
  int i; // r5

  List_c::~List_c(&this->m_waterCreatureList);
  List_c::~List_c(&this->m_waterCreaturePool);
  for ( i = 6604; i != -52; i -= 52 )
    ListItem_c::~ListItem_c((ListItem_c *)((char *)this + i));
}

//----- (00592D16) --------------------------------------------------------
bool8 __fastcall WaterCreatureManager_c::Init(WaterCreatureManager_c *this)
{
  List_c *p_m_waterCreaturePool; // r5
  int i; // r6

  p_m_waterCreaturePool = &this->m_waterCreaturePool;
  for ( i = 0; i != 6656; i += 52 )
    List_c::AddItem(p_m_waterCreaturePool, (ListItem_c *)((char *)this + i));
  this->m_lastUpdateTime = 0;
  return 1;
}

//----- (00592D48) --------------------------------------------------------
void __fastcall WaterCreatureManager_c::Exit(WaterCreatureManager_c *this)
{
  ListItem_c *m_head; // r5
  ListItem_c *m_next; // r4
  ListItem_c *m_prev; // r0

  m_head = this->m_waterCreatureList.m_head;
  if ( m_head )
  {
    do
    {
      m_next = m_head->m_next;
      List_c::RemoveItem(&g_waterCreatureMan.m_waterCreatureList, m_head);
      List_c::AddItem(&g_waterCreatureMan.m_waterCreaturePool, m_head);
      CWorld::Remove((CEntity *)m_head[1].m_prev);
      m_prev = m_head[1].m_prev;
      if ( m_prev )
        ((void (__fastcall *)(ListItem_c *))m_prev->m_prev->m_next)(m_prev);
      m_head[1].m_prev = 0;
      m_head = m_next;
      --CObject::nNoTempObjects;
    }
    while ( m_next );
  }
  sub_19CBF0(&this->m_waterCreaturePool);
}

//----- (00592DC8) --------------------------------------------------------
void __fastcall WaterCreatureManager_c::Update(WaterCreatureManager_c *this, float deltaTime)
{
  int32 v4; // r5
  List_c *p_m_waterCreaturePool; // r9
  int v6; // r0
  int v7; // r0
  int v8; // s0
  CSimpleTransform *p_tx; // r2
  float v10; // s0
  float v11; // s6
  float v12; // s2
  float v13; // s0
  float y; // s10
  float z; // s12
  int v16; // r0
  unsigned __int16 v17; // r0
  int v18; // r1
  ListItem_c *m_head; // r1
  ListItem_c *v20; // r2
  int m_next_low; // r3
  bool v22; // zf
  ListItem_c *m_prev; // r2
  float32x2_t *m_next; // r3
  float32x2_t *p_m_next; // r6
  float32x2_t v26; // d17
  unsigned __int64 v27; // d2
  WaterCreatureInfo_t *v28; // r0
  int minNum; // r5
  int maxNum; // r6
  int NumItems; // r10
  WaterCreature_c *v32; // r5
  int i; // r6
  WaterCreature_c *v34; // r8
  WaterCreature_c *v35; // r0
  List_c *p_m_waterCreatureList; // r5
  WaterCreature_c *v37; // r6
  ListItem_c *v38; // r4
  ListItem_c *v39; // r6
  ListItem_c *v40; // r0
  int id; // [sp+14h] [bp-4Ch]
  float pWaterZ; // [sp+18h] [bp-48h] BYREF
  float pWaterDepth; // [sp+1Ch] [bp-44h] BYREF
  CVector pos; // [sp+20h] [bp-40h] BYREF

  if ( FindPlayerPed(0)->m_pPlayerData->m_waterCoverPerc >= 0x33u )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    if ( (int)(CTimer::m_snTimeInMilliseconds - this->m_lastUpdateTime) > 1000 )
    {
      p_m_waterCreaturePool = &this->m_waterCreaturePool;
      if ( List_c::GetNumItems(&this->m_waterCreaturePool) >= 1 )
      {
        this->m_lastUpdateTime = v4;
        v6 = rand();
        pos.x = (float)((float)((float)v6 * 4.6566e-10) + (float)((float)v6 * 4.6566e-10)) + -1.0;
        v7 = rand();
        pos.z = 0.0;
        pos.y = (float)((float)((float)v7 * 4.6566e-10) + (float)((float)v7 * 4.6566e-10)) + -1.0;
        CVector::Normalise(&pos);
        v8 = rand();
        p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        v10 = (float)((float)((float)v8 * 4.6566e-10) * 15.0) + 25.0;
        v11 = v10 * pos.z;
        v12 = pos.x * v10;
        v13 = pos.y * v10;
        pos.z = v11;
        if ( !TheCamera.m_pMat )
          p_tx = &TheCamera.m_transform;
        y = p_tx->m_translate.y;
        z = p_tx->m_translate.z;
        pos.x = p_tx->m_translate.x + v12;
        pos.y = y + v13;
        pos.z = z + v11;
        if ( !CCamera::IsSphereVisible(&TheCamera, &pos, 3.0)
          && CWaterLevel::GetWaterDepth(&pos, &pWaterDepth, &pWaterZ, 0)
          && pWaterDepth > 4.5 )
        {
          v16 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
          if ( v16 > 79 )
          {
            if ( v16 > 89 )
            {
              v18 = 6;
              if ( v16 < 97 )
                v18 = 5;
              id = v18;
            }
            else
            {
              v17 = rand();
              id = (int)(float)((float)((float)v17 * 0.000015259) + (float)((float)v17 * 0.000015259)) + 3;
            }
          }
          else
          {
            id = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0);
          }
          m_head = this->m_waterCreatureList.m_head;
          if ( m_head )
          {
            while ( 1 )
            {
              v20 = m_head;
              m_next_low = LOBYTE(m_head[1].m_next);
              m_head = m_head->m_next;
              v22 = id == m_next_low;
              if ( id == m_next_low )
                v22 = v20[3].m_next == 0;
              if ( v22 )
              {
                m_prev = v20[1].m_prev;
                m_next = (float32x2_t *)m_prev[2].m_next;
                p_m_next = m_next + 6;
                if ( !m_next )
                  p_m_next = (float32x2_t *)&m_prev->m_next;
                v26.n64_u64[0] = vsub_f32(*(float32x2_t *)&pos.x, (float32x2_t)p_m_next->n64_u64[0]).n64_u64[0];
                v27 = vmul_f32(v26, v26).n64_u64[0];
                if ( (float)((float)(*(float *)&v27 + *((float *)&v27 + 1)) + 0.0) < (float)(WaterCreatureManager_c::ms_waterCreatureInfos[id].minSpacing
                                                                                           * WaterCreatureManager_c::ms_waterCreatureInfos[id].minSpacing) )
                  break;
              }
              if ( !m_head )
                goto LABEL_26;
            }
          }
          else
          {
LABEL_26:
            v28 = &WaterCreatureManager_c::ms_waterCreatureInfos[id];
            minNum = v28->minNum;
            maxNum = v28->maxNum;
            NumItems = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(maxNum - minNum))
                     + minNum;
            if ( List_c::GetNumItems(&this->m_waterCreaturePool) < NumItems )
              NumItems = List_c::GetNumItems(&this->m_waterCreaturePool);
            if ( NumItems >= 1 )
            {
              v32 = 0;
              for ( i = 0; i < NumItems; ++i )
              {
                v34 = (WaterCreature_c *)List_c::RemoveHead(p_m_waterCreaturePool);
                if ( WaterCreature_c::Init(v34, id, &pos, v32, pWaterZ, pWaterDepth) )
                {
                  List_c::AddItem(&this->m_waterCreatureList, v34);
                }
                else
                {
                  List_c::AddItem(p_m_waterCreaturePool, v34);
                  NumItems = i;
                }
                if ( !v32 )
                  v32 = v34;
                p_m_waterCreaturePool = &this->m_waterCreaturePool;
              }
            }
          }
        }
      }
    }
  }
  v35 = (WaterCreature_c *)this->m_waterCreatureList.m_head;
  if ( v35 )
  {
    p_m_waterCreatureList = &this->m_waterCreatureList;
    do
    {
      v37 = (WaterCreature_c *)v35->m_next;
      WaterCreature_c::Update(v35, deltaTime);
      v35 = v37;
    }
    while ( v37 );
    v38 = p_m_waterCreatureList->m_head;
    if ( p_m_waterCreatureList->m_head )
    {
      do
      {
        v39 = v38->m_next;
        if ( BYTE1(v38[1].m_next) )
        {
          List_c::RemoveItem(&g_waterCreatureMan.m_waterCreatureList, v38);
          List_c::AddItem(&g_waterCreatureMan.m_waterCreaturePool, v38);
          CWorld::Remove((CEntity *)v38[1].m_prev);
          v40 = v38[1].m_prev;
          if ( v40 )
            ((void (__fastcall *)(ListItem_c *))v40->m_prev->m_next)(v40);
          v38[1].m_prev = 0;
          --CObject::nNoTempObjects;
        }
        v38 = v39;
      }
      while ( v39 );
    }
  }
}

//----- (00593160) --------------------------------------------------------
int32 __fastcall WaterCreatureManager_c::GetRandomWaterCreatureId(WaterCreatureManager_c *this)
{
  int v1; // r1
  int32 result; // r0
  unsigned __int16 v3; // r0

  v1 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v1 <= 79 )
    return (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0);
  if ( v1 > 89 )
  {
    result = 6;
    if ( v1 < 97 )
      return 5;
  }
  else
  {
    v3 = rand();
    return (int)(float)((float)((float)v3 * 0.000015259) + (float)((float)v3 * 0.000015259)) + 3;
  }
  return result;
}

//----- (005931FC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall WaterCreatureManager_c::CanAddWaterCreatureAtPos(WaterCreatureManager_c *this, int32 id, CVector pos)
{
  ListItem_c *m_head; // r4
  float x; // s2
  float y; // s4
  ListItem_c *v6; // r2
  int m_next_low; // r0
  bool v8; // zf
  ListItem_c *m_prev; // r0
  ListItem_c *m_next; // r2
  float *p_m_next; // r3

  m_head = this->m_waterCreatureList.m_head;
  if ( !m_head )
    return 1;
  x = pos.x;
  y = pos.y;
  while ( 1 )
  {
    v6 = m_head;
    m_next_low = LOBYTE(m_head[1].m_next);
    m_head = m_head->m_next;
    v8 = m_next_low == id;
    if ( m_next_low == id )
      v8 = v6[3].m_next == 0;
    if ( v8 )
    {
      m_prev = v6[1].m_prev;
      m_next = m_prev[2].m_next;
      p_m_next = (float *)&m_next[6];
      if ( !m_next )
        p_m_next = (float *)&m_prev->m_next;
      if ( (float)((float)((float)((float)(x - *p_m_next) * (float)(x - *p_m_next))
                         + (float)((float)(y - p_m_next[1]) * (float)(y - p_m_next[1])))
                 + 0.0) < (float)(WaterCreatureManager_c::ms_waterCreatureInfos[id].minSpacing
                                * WaterCreatureManager_c::ms_waterCreatureInfos[id].minSpacing) )
        break;
    }
    if ( !m_head )
      return 1;
  }
  return 0;
}
// 5931FC: fragmented variable at 0:r2.8,8:^10.4 may be wrong

//----- (00593294) --------------------------------------------------------
int32 __fastcall WaterCreatureManager_c::TryToFreeUpWaterCreatures(WaterCreatureManager_c *this, int32 numToFree)
{
  ListItem_c *m_head; // r4
  int32 v4; // r5
  ListItem_c *v5; // r6
  ListItem_c *m_prev; // r0

  m_head = this->m_waterCreatureList.m_head;
  v4 = 0;
  do
  {
    if ( !m_head )
      break;
    v5 = m_head;
    while ( 1 )
    {
      m_head = v5->m_next;
      if ( (BYTE2(v5[1].m_prev[3].m_next) & 2) != 0 )
      {
        if ( v5[3].m_next )
          break;
      }
      v5 = v5->m_next;
      if ( !m_head )
        return v4;
    }
    List_c::RemoveItem(&g_waterCreatureMan.m_waterCreatureList, v5);
    List_c::AddItem(&g_waterCreatureMan.m_waterCreaturePool, v5);
    CWorld::Remove((CEntity *)v5[1].m_prev);
    m_prev = v5[1].m_prev;
    if ( m_prev )
      ((void (__fastcall *)(ListItem_c *))m_prev->m_prev->m_next)(m_prev);
    ++v4;
    v5[1].m_prev = 0;
    --CObject::nNoTempObjects;
  }
  while ( v4 < numToFree );
  return v4;
}

//----- (00593328) --------------------------------------------------------
void CWaterLevel::WaterLevelInitialise()
{
  u_native v0; // r8
  unsigned __int8 *Line; // r0
  const char *v2; // r9
  unsigned int v3; // r0
  bool v4; // zf
  int v5; // s5
  bool v6; // zf
  int32 TxdSlot; // r0
  CRenPar P2; // [sp+10h] [bp-140h]
  CRenPar P2a; // [sp+10h] [bp-140h]
  CRenPar P3; // [sp+28h] [bp-128h]
  CRenPar P3a; // [sp+28h] [bp-128h]
  CRenPar P4; // [sp+40h] [bp-110h]
  unsigned int P1_4; // [sp+70h] [bp-E0h]
  unsigned int P1_8; // [sp+74h] [bp-DCh]
  unsigned int P1_12; // [sp+78h] [bp-D8h]
  unsigned int v16; // [sp+7Ch] [bp-D4h]
  unsigned int v17; // [sp+80h] [bp-D0h]
  unsigned int v18; // [sp+84h] [bp-CCh]
  unsigned int v19; // [sp+88h] [bp-C8h]
  UInt32 v20; // [sp+8Ch] [bp-C4h] BYREF
  float v21; // [sp+90h] [bp-C0h] BYREF
  float v22; // [sp+94h] [bp-BCh] BYREF
  float v23; // [sp+98h] [bp-B8h] BYREF
  float v24; // [sp+9Ch] [bp-B4h] BYREF
  float v25; // [sp+A0h] [bp-B0h] BYREF
  float v26; // [sp+A4h] [bp-ACh] BYREF
  float v27; // [sp+A8h] [bp-A8h] BYREF
  float v28; // [sp+ACh] [bp-A4h] BYREF
  float v29; // [sp+B0h] [bp-A0h] BYREF
  float v30; // [sp+B4h] [bp-9Ch] BYREF
  float v31; // [sp+B8h] [bp-98h] BYREF
  float v32; // [sp+BCh] [bp-94h] BYREF
  unsigned int v33; // [sp+C0h] [bp-90h] BYREF
  unsigned int v34; // [sp+C4h] [bp-8Ch] BYREF
  unsigned int v35; // [sp+C8h] [bp-88h] BYREF
  unsigned int v36; // [sp+CCh] [bp-84h] BYREF
  unsigned int v37; // [sp+D0h] [bp-80h] BYREF
  unsigned int v38; // [sp+D4h] [bp-7Ch] BYREF
  unsigned int v39; // [sp+D8h] [bp-78h] BYREF
  CRenPar v40; // [sp+DCh] [bp-74h] BYREF
  float v41; // [sp+ECh] [bp-64h] BYREF
  float v42; // [sp+F0h] [bp-60h] BYREF
  float v43; // [sp+F4h] [bp-5Ch] BYREF
  float v44; // [sp+F8h] [bp-58h] BYREF
  float v45; // [sp+FCh] [bp-54h] BYREF
  unsigned __int8 pFilename[36]; // [sp+100h] [bp-50h] BYREF
  CRenPar v47; // 0:r2.8,8:^0.8
  CRenPar v48; // 0:r2.8,8:^0.8

  CWaterLevel::m_nNumOfWaterTriangles = 0;
  CWaterLevel::m_nNumOfWaterQuads = 0;
  CWaterLevel::m_nNumOfWaterVertices = 0;
  CWaterLevel::m_ElementsOnQuadsAndTrianglesList = 0;
  memset(CWaterLevel::m_QuadsAndTrianglesInEachBlock, 0, sizeof(CWaterLevel::m_QuadsAndTrianglesInEachBlock));
  if ( CWaterLevel::m_nWaterConfiguration == 1 )
  {
    strcpy((char *)pFilename, "DATA\\water1.dat");
  }
  else if ( !CWaterLevel::m_nWaterConfiguration )
  {
    strcpy((char *)((unsigned int)pFilename | 7), "ter.dat");
    *(_QWORD *)pFilename = *(_QWORD *)"DATA\\water.dat";
  }
  v0 = CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_593904);
  CWaterLevel::m_nNumOfWaterTriangles = 0;
  CWaterLevel::m_nNumOfWaterQuads = 0;
  CWaterLevel::m_nNumOfWaterVertices = 0;
  Line = CFileLoader::LoadLine(v0);
  v2 = (const char *)Line;
  if ( Line )
  {
    v17 = (unsigned int)Line;
    v16 = (unsigned int)Line;
    v19 = (unsigned int)Line;
    P1_12 = (unsigned int)Line;
    v18 = (unsigned int)Line;
    P1_4 = (unsigned int)Line;
    P1_8 = (unsigned int)Line;
    do
    {
      while ( 1 )
      {
        v3 = *(unsigned __int8 *)v2;
        if ( v3 <= 0x3A )
          break;
        v6 = v3 == 112;
        if ( v3 != 112 )
          v6 = v3 == 59;
        if ( !v6 )
          goto LABEL_11;
LABEL_18:
        v2 = (const char *)CFileLoader::LoadLine(v0);
        if ( !v2 )
          goto LABEL_22;
      }
      v4 = v3 == 0;
      if ( *v2 )
        v4 = v3 == 42;
      if ( v4 )
        goto LABEL_18;
LABEL_11:
      v20 = 1;
      if ( sscanf(
             v2,
             "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %d",
             &v45,
             &v44,
             &v40,
             &v28,
             &v24,
             &v36,
             &v32,
             &v43,
             &v42,
             &v39,
             &v27,
             &v23,
             &v35,
             &v31,
             &v41,
             &v40.m_FlowX,
             &v38,
             &v26,
             &v22,
             &v34,
             &v30,
             &v40.m_SmallWaves,
             &v40.m_BigWaves,
             &v37,
             &v25,
             &v21,
             &v33,
             &v29,
             &v20) == 29
        || sscanf(
             v2,
             "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
             &v45,
             &v44,
             &v40,
             &v28,
             &v24,
             &v36,
             &v32,
             &v43,
             &v42,
             &v39,
             &v27,
             &v23,
             &v35,
             &v31,
             &v41,
             &v40.m_FlowX,
             &v38,
             &v26,
             &v22,
             &v34,
             &v30,
             &v40.m_SmallWaves,
             &v40.m_BigWaves,
             &v37,
             &v25,
             &v21,
             &v33,
             &v29) == 28 )
      {
        *(_QWORD *)&P4.m_Z = __PAIR64__(v33, v37);
        P4.m_SmallWaves = v29;
        P3.m_SmallWaves = v30;
        *(_QWORD *)&P3.m_Z = __PAIR64__(v34, v38);
        P2.m_SmallWaves = v31;
        *(_QWORD *)&P2.m_Z = __PAIR64__(v35, v39);
        v47.m_SmallWaves = v32;
        v5 = (int)(float)(v23 * 64.0);
        v19 = (unsigned __int8)(int)(float)(v26 * 64.0) | v19 & 0xFFFF0000 | ((unsigned __int8)(int)(float)(v22 * 64.0) << 8);
        *(_DWORD *)&P3.m_FlowX = v19;
        v17 = v17 & 0xFFFF0000 | (unsigned __int8)(int)(float)(v28 * 64.0) | ((unsigned __int8)v5 << 8);
        v18 = (unsigned __int8)(int)(float)(v25 * 64.0) | v18 & 0xFFFF0000 | ((unsigned __int8)(int)(float)(v21 * 64.0) << 8);
        *(_DWORD *)&P4.m_FlowX = v18;
        *(_DWORD *)&v47.m_FlowX = v17;
        *(_QWORD *)&v47.m_Z = __PAIR64__(v36, LODWORD(v40.m_Z));
        v16 = v16 & 0xFFFF0000 | ((unsigned __int8)v5 << 8) | (unsigned __int8)(int)(float)(v27 * 64.0);
        *(_DWORD *)&P2.m_FlowX = v16;
        CWaterLevel::AddWaterLevelQuad(
          (int)v45,
          (int)v44,
          v47,
          (int)v43,
          (int)v42,
          P2,
          (int)v41,
          (int)*(float *)&v40.m_FlowX,
          P3,
          (int)v40.m_SmallWaves,
          (int)v40.m_BigWaves,
          P4,
          v20);
      }
      else
      {
        sscanf(
          v2,
          "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %d",
          &v45,
          &v44,
          &v40,
          &v28,
          &v24,
          &v36,
          &v32,
          &v43,
          &v42,
          &v39,
          &v27,
          &v23,
          &v35,
          &v31,
          &v41,
          &v40.m_FlowX,
          &v38,
          &v26,
          &v22,
          &v34,
          &v30,
          &v20);
        *(_QWORD *)&v48.m_Z = __PAIR64__(v36, LODWORD(v40.m_Z));
        P3a.m_SmallWaves = v30;
        *(_QWORD *)&P3a.m_Z = __PAIR64__(v34, v38);
        P2a.m_SmallWaves = v31;
        *(_QWORD *)&P2a.m_Z = __PAIR64__(v35, v39);
        v48.m_SmallWaves = v32;
        P1_12 = (unsigned __int8)(int)(float)(v26 * 64.0) | P1_12 & 0xFFFF0000 | ((unsigned __int8)(int)(float)(v22 * 64.0) << 8);
        *(_DWORD *)&P3a.m_FlowX = P1_12;
        P1_8 = (unsigned __int8)(int)(float)(v27 * 64.0) | P1_8 & 0xFFFF0000 | ((unsigned __int8)(int)(float)(v23 * 64.0) << 8);
        *(_DWORD *)&P2a.m_FlowX = P1_8;
        P1_4 = P1_4 & 0xFFFF0000 | (unsigned __int8)(int)(float)(v28 * 64.0) | ((unsigned __int8)(int)(float)(v24 * 64.0) << 8);
        *(_DWORD *)&v48.m_FlowX = P1_4;
        CWaterLevel::AddWaterLevelTriangle(
          (int)v45,
          (int)v44,
          v48,
          (int)v43,
          (int)v42,
          P2a,
          (int)v41,
          (int)*(float *)&v40.m_FlowX,
          P3a,
          v20);
      }
      v2 = (const char *)CFileLoader::LoadLine(v0);
    }
    while ( v2 );
  }
LABEL_22:
  CFileMgr::CloseFile(v0);
  CWaterLevel::FillQuadsAndTrianglesList();
  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  if ( !gpWaterTex )
    gpWaterTex = RwTextureRead((const RwChar *)"waterclear256", 0);
  if ( !gpSeaBedTex )
    gpSeaBedTex = RwTextureRead((const RwChar *)"seabd32", 0);
  if ( !gpWaterWakeTex )
    gpWaterWakeTex = RwTextureRead((const RwChar *)"waterwake", 0);
  CTxdStore::PopCurrentTxd();
}
// 593904: using guessed type int dword_593904;

//----- (0059396C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::AddWaterLevelQuad(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3,
        Int32 X4,
        Int32 Y4,
        CRenPar P4,
        UInt32 Flags)
{
  bool v13; // zf
  bool v14; // zf
  int v15; // r9
  int v16; // r8
  int m_Y; // lr
  int v18; // r6
  unsigned __int16 v19; // r10
  int v20; // r3
  int v21; // r4
  int v22; // r5
  int *v23; // r0
  int v24; // r0
  int *v25; // r0
  Int16 v26; // r0
  __int16 v27; // r2
  __int16 v28; // lr
  __int16 v29; // r3
  __int16 v30; // r5
  __int16 v31; // r6
  Int32 v32; // r4
  int v33; // r1
  char *v34; // r0
  char v35; // r1
  char v36; // r3
  __int64 v37; // [sp+0h] [bp-60h]
  int v38; // [sp+10h] [bp-50h]
  Int16 v39; // [sp+14h] [bp-4Ch]
  int v40; // [sp+18h] [bp-48h]
  int v41; // [sp+20h] [bp-40h]
  int v42; // [sp+24h] [bp-3Ch] BYREF
  int v43; // [sp+28h] [bp-38h]
  int v44; // [sp+2Ch] [bp-34h] BYREF
  int v45; // [sp+30h] [bp-30h]
  Int32 v46; // [sp+34h] [bp-2Ch]
  Int32 v47; // [sp+38h] [bp-28h]
  int v48; // [sp+3Ch] [bp-24h]
  Int32 v49; // [sp+40h] [bp-20h]

  v13 = X1 == X2;
  if ( X1 == X2 )
    v13 = X1 == X3;
  if ( !v13 || X1 != X4 )
  {
    v14 = Y1 == Y2;
    if ( Y1 == Y2 )
      v14 = Y1 == Y3;
    if ( !v14 || Y1 != Y4 )
    {
      v37 = *(_QWORD *)&P1.m_SmallWaves;
      v46 = CWaterLevel::AddWaterLevelVertex(X1, Y1, P1);
      v47 = CWaterLevel::AddWaterLevelVertex(X2, Y2, P2);
      v15 = CWaterLevel::AddWaterLevelVertex(X3, Y3, P3);
      v48 = v15;
      v49 = CWaterLevel::AddWaterLevelVertex(X4, Y4, P4);
      v38 = v47;
      v16 = 0;
      m_Y = (unsigned __int16)CWaterLevel::m_aVertices[v47].m_Y;
      v18 = (unsigned __int16)CWaterLevel::m_aVertices[v46].m_Y;
      v19 = CWaterLevel::m_aVertices[v46].m_Y;
      v41 = v49;
      v20 = 3;
      v40 = CWaterLevel::m_aVertices[v49].m_Y;
      v39 = CWaterLevel::m_aVertices[v15].m_Y;
      if ( v39 < v40 )
        v20 = 2;
      v21 = 0;
      if ( CWaterLevel::m_aVertices[*(&v46 + ((__int16)v18 >= (__int16)m_Y))].m_Y < CWaterLevel::m_aVertices[*(&v46 + v20)].m_Y )
        v20 = (__int16)v18 >= (__int16)m_Y;
      v22 = (unsigned __int16)CWaterLevel::m_aVertices[*(&v46 + v20)].m_Y;
      v23 = &v42;
      if ( v18 != v22 )
        v23 = &v44;
      *v23 = v46;
      if ( v18 == v22 )
        v21 = 1;
      else
        v16 = 1;
      if ( m_Y == v22 )
      {
        *(&v42 + v21) = v38;
        v21 = 1;
        if ( v19 == v22 )
          v21 = 2;
      }
      else
      {
        v24 = v16 | 2;
        v16 = 2;
        *(&v42 + v24) = v38;
        if ( v19 == v22 )
          v16 = 1;
      }
      if ( (unsigned __int16)v39 == v22 )
      {
        *(&v42 + v21++) = v15;
      }
      else
      {
        v25 = &v42 + v16++;
        v25[2] = v15;
      }
      if ( (unsigned __int16)v40 != v22 )
        v21 = v16 + 2;
      *(&v42 + v21) = v41;
      v27 = v42;
      v26 = v43;
      if ( CWaterLevel::m_aVertices[v42].m_X <= CWaterLevel::m_aVertices[v43].m_X )
      {
        v28 = v43;
        v26 = v42;
      }
      else
      {
        v28 = v42;
        v42 = v43;
        v43 = v27;
      }
      v30 = v44;
      v29 = v45;
      if ( CWaterLevel::m_aVertices[v44].m_X <= CWaterLevel::m_aVertices[v45].m_X )
      {
        v31 = v45;
        v29 = v44;
      }
      else
      {
        v31 = v44;
        v44 = v45;
        v45 = v30;
      }
      v32 = CWaterLevel::m_nNumOfWaterQuads;
      v33 = 5 * CWaterLevel::m_nNumOfWaterQuads;
      CWaterLevel::m_aQuads[CWaterLevel::m_nNumOfWaterQuads].Index1 = v26;
      v34 = (char *)CWaterLevel::m_aQuads + 2 * v33;
      *((_WORD *)v34 + 1) = v28;
      LOBYTE(v33) = v34[8];
      *((_WORD *)v34 + 2) = v29;
      v35 = v33 & 0xFC;
      *((_WORD *)v34 + 3) = v31;
      if ( (Flags & 1) == 0 )
        v35 |= 2u;
      v36 = v35 & 0xFA;
      if ( (Flags & 2) != 0 )
        v36 = v35 | 4;
      v34[8] = v36;
      CWaterLevel::m_nNumOfWaterQuads = v32 + 1;
    }
  }
}
// 59396C: fragmented variable at 0:r2.8,8:^68.8 may be wrong
// 59396C: variables would overlap: 0:r2.8,8:^68.8 and ^68.8

//----- (00593BD4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::AddWaterLevelTriangle(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3,
        UInt32 Flags)
{
  bool v10; // zf
  bool v11; // zf
  Int32 v12; // r10
  Int32 v13; // r4
  Int32 v14; // r0
  CWaterVertex *v15; // r1
  CWaterVertex *v16; // r2
  int m_Y; // r3
  bool v18; // cc
  Int16 v19; // r1
  CWaterVertex *v20; // r6
  __int16 v21; // r2
  Int32 v22; // r6
  CWaterTriangle *v23; // r3
  char v24; // r5
  char v25; // r0
  char v26; // r1
  __int64 v27; // [sp+0h] [bp-28h]

  v10 = X1 == X2;
  if ( X1 == X2 )
    v10 = X1 == X3;
  if ( !v10 )
  {
    v11 = Y1 == Y2;
    if ( Y1 == Y2 )
      v11 = Y1 == Y3;
    if ( !v11 )
    {
      v27 = *(_QWORD *)&P1.m_SmallWaves;
      v12 = CWaterLevel::AddWaterLevelVertex(X1, Y1, P1);
      v13 = CWaterLevel::AddWaterLevelVertex(X2, Y2, P2);
      v14 = CWaterLevel::AddWaterLevelVertex(X3, Y3, P3);
      v15 = &CWaterLevel::m_aVertices[v12];
      v16 = &CWaterLevel::m_aVertices[v13];
      m_Y = (unsigned __int16)v15->m_Y;
      if ( m_Y == (unsigned __int16)v16->m_Y )
      {
        v18 = v15->m_X < v16->m_X;
        v19 = v12;
        if ( v18 )
        {
          v19 = v13;
          LOWORD(v13) = v12;
        }
      }
      else
      {
        v20 = &CWaterLevel::m_aVertices[v14];
        if ( m_Y == (unsigned __int16)v20->m_Y )
        {
          v21 = v13;
          v18 = v15->m_X < v20->m_X;
          v19 = v12;
          if ( v18 )
          {
            v19 = v14;
            LOWORD(v14) = v12;
          }
          LOWORD(v13) = v14;
          LOWORD(v14) = v21;
        }
        else
        {
          v19 = v13;
          if ( v16->m_X >= v20->m_X )
            LOWORD(v13) = v14;
          else
            v19 = v14;
          LOWORD(v14) = v12;
        }
      }
      v22 = CWaterLevel::m_nNumOfWaterTriangles;
      CWaterLevel::m_aTriangles[CWaterLevel::m_nNumOfWaterTriangles].Index1 = v13;
      v23 = &CWaterLevel::m_aTriangles[v22];
      v24 = *((_BYTE *)v23 + 6);
      v23->Index2 = v19;
      v23->Index3 = v14;
      v25 = v24 & 0xFC;
      if ( (Flags & 1) == 0 )
        v25 |= 2u;
      v26 = v25 & 0xFA;
      if ( (Flags & 2) != 0 )
        v26 = v25 | 4;
      *((_BYTE *)v23 + 6) = v26;
      CWaterLevel::m_nNumOfWaterTriangles = v22 + 1;
    }
  }
}
// 593BD4: fragmented variable at 0:r2.8,8:^30.8 may be wrong
// 593BD4: variables would overlap: 0:r2.8,8:^30.8 and ^30.8

//----- (00593D08) --------------------------------------------------------
void CWaterLevel::FillQuadsAndTrianglesList()
{
  int v0; // r11
  int v1; // r12
  int v2; // r1
  int v3; // r2
  float v4; // s4
  float v5; // s6
  float v6; // s8
  float v7; // s10
  int v8; // r9
  UInt16 *v9; // r4
  Int16 *p_Index2; // r3
  unsigned int v11; // r5
  Int32 v12; // r6
  UInt16 *v13; // r5
  int v14; // r0
  UInt16 *v15; // r2
  UInt16 *v16; // r3
  int v17; // r2
  CWaterTriangle *v18; // r5
  int Index1; // r6
  int Index3; // r5
  Int16 v21; // r4
  Int16 v22; // r1
  unsigned int v23; // r5
  Int32 v24; // r6
  UInt16 *v25; // r0
  int v26; // r5
  int v27; // [sp+28h] [bp-40h]
  int v28; // [sp+3Ch] [bp-2Ch]

  v0 = CWaterLevel::m_nNumOfWaterTriangles;
  v1 = CWaterLevel::m_nNumOfWaterQuads;
  v2 = 0;
  do
  {
    v27 = v2;
    v3 = 0;
    v4 = (float)(500 * v2) + -3000.0;
    v5 = v4 + 500.0;
    do
    {
      v28 = v3;
      v6 = (float)(500 * v3) + -3000.0;
      v7 = v6 + 500.0;
      if ( v1 >= 1 )
      {
        v8 = 0;
        v9 = &CWaterLevel::m_QuadsAndTrianglesInEachBlock[v27][v3];
        p_Index2 = &CWaterLevel::m_aQuads[0].Index2;
        while ( 1 )
        {
          if ( v4 >= (float)CWaterLevel::m_aVertices[*p_Index2].m_X
            || v5 <= (float)CWaterLevel::m_aVertices[*(p_Index2 - 1)].m_X
            || v6 >= (float)CWaterLevel::m_aVertices[p_Index2[1]].m_Y
            || v7 <= (float)CWaterLevel::m_aVertices[*(p_Index2 - 1)].m_Y )
          {
            goto LABEL_15;
          }
          v11 = *v9;
          if ( (v11 >> 14) - 1 < 2 )
            break;
          if ( v11 >> 14 )
          {
            v12 = CWaterLevel::m_ElementsOnQuadsAndTrianglesList;
            v15 = &CWaterLevel::m_QuadsAndTrianglesList[CWaterLevel::m_ElementsOnQuadsAndTrianglesList];
            *v15 = 0;
            v14 = 1;
            *(v15 - 1) = v8 | 0x4000;
            goto LABEL_14;
          }
          *v9 = v8 | 0x4000;
LABEL_15:
          ++v8;
          p_Index2 += 5;
          if ( v1 == v8 )
            goto LABEL_16;
        }
        v12 = CWaterLevel::m_ElementsOnQuadsAndTrianglesList;
        CWaterLevel::m_QuadsAndTrianglesList[CWaterLevel::m_ElementsOnQuadsAndTrianglesList] = v11;
        v13 = &CWaterLevel::m_QuadsAndTrianglesList[v12];
        v14 = 3;
        v13[1] = v8 | 0x4000;
        v13[2] = 0;
        *v9 = v12 | 0xC000;
LABEL_14:
        CWaterLevel::m_ElementsOnQuadsAndTrianglesList = v14 + v12;
        goto LABEL_15;
      }
LABEL_16:
      if ( v0 >= 1 )
      {
        v16 = &CWaterLevel::m_QuadsAndTrianglesInEachBlock[v27][v28];
        v17 = 0;
        while ( 1 )
        {
          v18 = &CWaterLevel::m_aTriangles[v17];
          if ( v4 >= (float)CWaterLevel::m_aVertices[v18->Index2].m_X )
            goto LABEL_32;
          Index1 = CWaterLevel::m_aTriangles[v17].Index1;
          Index3 = v18->Index3;
          v21 = Index3;
          v22 = Index3;
          if ( CWaterLevel::m_aVertices[Index1].m_Y > CWaterLevel::m_aVertices[Index3].m_Y )
            v22 = CWaterLevel::m_aTriangles[v17].Index1;
          if ( CWaterLevel::m_aVertices[Index1].m_Y <= CWaterLevel::m_aVertices[Index3].m_Y )
            v21 = CWaterLevel::m_aTriangles[v17].Index1;
          if ( v7 <= (float)CWaterLevel::m_aVertices[v21].m_Y
            || v6 >= (float)CWaterLevel::m_aVertices[v22].m_Y
            || v5 <= (float)CWaterLevel::m_aVertices[Index1].m_X )
          {
            goto LABEL_32;
          }
          v23 = *v16;
          if ( (v23 >> 14) - 1 < 2 )
            break;
          if ( v23 >> 14 )
          {
            v26 = 1;
            v24 = CWaterLevel::m_ElementsOnQuadsAndTrianglesList;
            CWaterLevel::m_QuadsAndTrianglesList[CWaterLevel::m_ElementsOnQuadsAndTrianglesList] = 0;
            CWaterLevel::m_QuadsAndTrianglesList[v24 - 1] = v17 | 0x8000;
            goto LABEL_31;
          }
          *v16 = v17 | 0x8000;
LABEL_32:
          if ( v0 == ++v17 )
            goto LABEL_33;
        }
        v24 = CWaterLevel::m_ElementsOnQuadsAndTrianglesList;
        CWaterLevel::m_QuadsAndTrianglesList[CWaterLevel::m_ElementsOnQuadsAndTrianglesList] = v23;
        v25 = &CWaterLevel::m_QuadsAndTrianglesList[v24];
        v26 = 3;
        v25[1] = v17 | 0x8000;
        v25[2] = 0;
        *v16 = v24 | 0xC000;
LABEL_31:
        CWaterLevel::m_ElementsOnQuadsAndTrianglesList = v26 + v24;
        goto LABEL_32;
      }
LABEL_33:
      v3 = v28 + 1;
    }
    while ( v28 != 11 );
    v2 = v27 + 1;
  }
  while ( v27 != 11 );
}

//----- (005940B0) --------------------------------------------------------
void __fastcall CWaterLevel::FixVertexOnToLine(
        CWaterVertex *pVertex,
        CWaterVertex *pLineVertex1,
        CWaterVertex *pLineVertex2,
        float *pTotalChange)
{
  CWaterVertex *v4; // r9
  int m_X; // r5
  int v6; // r6
  float m_BigWaves; // s0
  float m_SmallWaves; // s2
  int v9; // r12
  float v10; // s4
  float v11; // s6
  int m_Y; // r12
  CWaterVertex *v13; // r4
  int v14; // r5
  CWaterVertex *v15; // r6
  int v16; // r4
  int v17; // r6
  int v18; // r5
  float v19; // s4
  int v20; // s6
  int v21; // lr
  int v22; // r6
  int v23; // r4
  int v24; // r8
  CWaterVertex *v25; // r4
  CWaterVertex *v26; // r5
  int v27; // r6
  int v28; // r5
  int v29; // r4
  int v30; // r6
  int v31; // r5
  int v32; // r6
  float m_Z; // s8
  float v34; // s10
  float v35; // s12
  float v36; // s14
  float v37; // s1
  float v38; // s4
  float v39; // s6
  float v40; // s3
  float v41; // s5
  int v42; // s7
  int v43; // r1
  int v44; // s9
  float v45; // s6
  float v46; // s14
  float v47; // s8
  float v48; // s12
  float v49; // s9
  float v50; // s7
  float v51; // s5
  float v52; // s11
  CWaterVertex *v53; // r6
  CWaterVertex *v54; // r5
  int v55; // r11
  int v56; // r5
  int v57; // r10
  bool v58; // cc
  CWaterVertex *v59; // r6
  int v60; // r4
  int v61; // r6
  float v62; // s4
  int v63; // r6
  int v64; // r2
  int v65; // [sp+0h] [bp-20h]

  v4 = pLineVertex2;
  m_X = (unsigned __int16)pLineVertex1->m_X;
  v6 = (unsigned __int16)pLineVertex2->m_X;
  m_BigWaves = pVertex->m_P.m_BigWaves;
  m_SmallWaves = pVertex->m_P.m_SmallWaves;
  v9 = (__int16)m_X;
  if ( v6 == m_X )
  {
    v10 = pVertex->m_P.m_SmallWaves;
    v11 = pVertex->m_P.m_BigWaves;
    if ( (unsigned __int16)pVertex->m_X == (unsigned __int16)m_X )
    {
      v10 = pVertex->m_P.m_SmallWaves;
      m_Y = pLineVertex1->m_Y;
      v11 = pVertex->m_P.m_BigWaves;
      v13 = pLineVertex2;
      v14 = pVertex->m_Y;
      v15 = pLineVertex2;
      if ( m_Y > pLineVertex2->m_Y )
        v15 = pLineVertex1;
      if ( m_Y <= pLineVertex2->m_Y )
        v13 = pLineVertex1;
      v16 = v13->m_Y;
      if ( v14 > v16 )
      {
        v10 = pVertex->m_P.m_SmallWaves;
        v17 = v15->m_Y;
        v11 = pVertex->m_P.m_BigWaves;
        if ( v14 < v17 )
        {
          v18 = v14 - m_Y;
          v19 = (float)(v17 - v16);
          if ( v18 < 0 )
            v18 = -v18;
          v20 = v18;
LABEL_23:
          v31 = *(_DWORD *)&pLineVertex2->m_P.m_FlowX;
          v32 = *(_DWORD *)&pLineVertex1->m_P.m_FlowX;
          m_Z = pLineVertex1->m_P.m_Z;
          v34 = pLineVertex1->m_P.m_BigWaves;
          v35 = pLineVertex1->m_P.m_SmallWaves;
          v36 = pLineVertex2->m_P.m_Z;
          v37 = pLineVertex2->m_P.m_BigWaves;
          v38 = (float)v20 / v19;
          v39 = 1.0;
          v40 = pLineVertex2->m_P.m_SmallWaves;
          v41 = (float)(char)v31;
          v42 = v32 << 16 >> 24;
          v43 = (char)v32;
          v44 = v31 << 16 >> 24;
LABEL_24:
          v45 = v39 - v38;
          v46 = v38 * v36;
          v47 = v45 * m_Z;
          v48 = v45 * v35;
          v49 = v38 * (float)v44;
          v50 = v45 * (float)v42;
          v51 = v38 * v41;
          v52 = v45 * (float)v43;
          v11 = (float)(v45 * v34) + (float)(v38 * v37);
          v10 = v48 + (float)(v38 * v40);
          pVertex->m_P.m_Z = v47 + v46;
          pVertex->m_P.m_BigWaves = v11;
          pVertex->m_P.m_SmallWaves = v10;
          pVertex->m_P.m_FlowY = (int)(float)(v50 + v49);
          pVertex->m_P.m_FlowX = (int)(float)(v52 + v51);
        }
      }
    }
  }
  else
  {
    v21 = (__int16)v6;
    v22 = (unsigned __int16)pLineVertex1->m_Y;
    v23 = (unsigned __int16)pLineVertex2->m_Y;
    v24 = (__int16)v22;
    if ( v23 == v22 )
    {
      v10 = pVertex->m_P.m_SmallWaves;
      v11 = pVertex->m_P.m_BigWaves;
      if ( (unsigned __int16)pVertex->m_Y == (unsigned __int16)v22 )
      {
        v10 = pVertex->m_P.m_SmallWaves;
        v11 = pVertex->m_P.m_BigWaves;
        v25 = pLineVertex2;
        v26 = pLineVertex2;
        if ( v21 < v9 )
          v25 = pLineVertex1;
        v27 = pVertex->m_X;
        if ( v21 > v9 )
          v26 = pLineVertex1;
        v28 = v26->m_X;
        if ( v27 > v28 )
        {
          v10 = pVertex->m_P.m_SmallWaves;
          v29 = v25->m_X;
          v11 = pVertex->m_P.m_BigWaves;
          if ( v27 < v29 )
          {
            v30 = v27 - v9;
            v19 = (float)(v29 - v28);
            if ( v30 < 0 )
              v30 = -v30;
            v20 = v30;
            goto LABEL_23;
          }
        }
      }
    }
    else
    {
      v10 = pVertex->m_P.m_SmallWaves;
      v11 = pVertex->m_P.m_BigWaves;
      v53 = pLineVertex2;
      v54 = pLineVertex2;
      if ( v21 < v9 )
        v53 = pLineVertex1;
      v55 = pVertex->m_X;
      if ( v21 > v9 )
        v54 = pLineVertex1;
      v56 = v54->m_X;
      if ( v55 > v56 )
      {
        v10 = pVertex->m_P.m_SmallWaves;
        v11 = pVertex->m_P.m_BigWaves;
        v65 = v53->m_X;
        if ( v55 < v65 )
        {
          v10 = pVertex->m_P.m_SmallWaves;
          v57 = (__int16)v23;
          v11 = pVertex->m_P.m_BigWaves;
          v58 = (__int16)v23 <= v24;
          v59 = pLineVertex2;
          if ( (__int16)v23 < v24 )
            v59 = pLineVertex1;
          v60 = pVertex->m_Y;
          if ( !v58 )
            pLineVertex2 = pLineVertex1;
          if ( v60 > pLineVertex2->m_Y )
          {
            v10 = pVertex->m_P.m_SmallWaves;
            v11 = pVertex->m_P.m_BigWaves;
            if ( v60 < v59->m_Y )
            {
              v61 = v55 - v9;
              v10 = pVertex->m_P.m_SmallWaves;
              v11 = pVertex->m_P.m_BigWaves;
              if ( (v60 - v24) * (v21 - v9) == (v57 - v24) * (v55 - v9) )
              {
                if ( v61 < 0 )
                  v61 = v9 - v55;
                v62 = (float)v61;
                v63 = *(_DWORD *)&v4->m_P.m_FlowX;
                v64 = *(_DWORD *)&pLineVertex1->m_P.m_FlowX;
                m_Z = pLineVertex1->m_P.m_Z;
                v34 = pLineVertex1->m_P.m_BigWaves;
                v35 = pLineVertex1->m_P.m_SmallWaves;
                v36 = v4->m_P.m_Z;
                v37 = v4->m_P.m_BigWaves;
                v38 = v62 / (float)(v65 - v56);
                v39 = 1.0;
                v40 = v4->m_P.m_SmallWaves;
                v41 = (float)(char)v63;
                v42 = v64 << 16 >> 24;
                v43 = (char)v64;
                v44 = v63 << 16 >> 24;
                goto LABEL_24;
              }
            }
          }
        }
      }
    }
  }
  *pTotalChange = *pTotalChange + (float)(fabsf(m_BigWaves - v11) + fabsf(m_SmallWaves - v10));
}

//----- (0059437C) --------------------------------------------------------
void __fastcall CWaterLevel::AddToQuadsAndTrianglesList(Int32 BlockX, Int32 BlockY, Int32 Element, UInt32 Type)
{
  UInt16 *v4; // r12
  unsigned int v5; // lr
  Int32 v6; // r1
  UInt16 *v7; // r0
  int v8; // r0

  v4 = &CWaterLevel::m_QuadsAndTrianglesInEachBlock[BlockX][BlockY];
  v5 = *v4;
  if ( (v5 >> 14) - 1 >= 2 )
  {
    if ( !(v5 >> 14) )
    {
      *v4 = Element | ((_WORD)Type << 14);
      return;
    }
    v6 = CWaterLevel::m_ElementsOnQuadsAndTrianglesList;
    *(_DWORD *)&CWaterLevel::m_QuadsAndTrianglesList[CWaterLevel::m_ElementsOnQuadsAndTrianglesList - 1] = (unsigned __int16)(Element | ((_WORD)Type << 14));
    v8 = 1;
  }
  else
  {
    v6 = CWaterLevel::m_ElementsOnQuadsAndTrianglesList;
    v7 = &CWaterLevel::m_QuadsAndTrianglesList[CWaterLevel::m_ElementsOnQuadsAndTrianglesList];
    *v7 = v5;
    v7[1] = Element | ((_WORD)Type << 14);
    v7[2] = 0;
    *v4 = v6 | 0xC000;
    v8 = 3;
  }
  CWaterLevel::m_ElementsOnQuadsAndTrianglesList = v8 + v6;
}

//----- (00594428) --------------------------------------------------------
void __fastcall CWaterLevel::MarkQuadsAndPolysToBeRendered(Int32 BlockX, Int32 BlockY, bool bInInterior)
{
  unsigned int v3; // r1
  int v4; // r3
  CWaterQuad *v5; // r0
  _BYTE *v6; // r0
  char v7; // r1
  char v8; // t1
  char v9; // r1
  int v10; // r1
  unsigned int v11; // r5
  unsigned int v12; // r6
  UInt16 *v13; // r1
  int v14; // r6
  CWaterQuad *v15; // r5
  char v16; // r3
  _BYTE *v17; // r5
  char v18; // t1
  int v19; // r5
  CWaterTriangle *v20; // r6
  char v21; // r3
  _BYTE *v22; // r6
  char v23; // t1
  unsigned int v24; // t1
  int v25; // r1
  CWaterTriangle *v26; // r0
  char v27; // r3
  char v28; // t1

  v3 = CWaterLevel::m_QuadsAndTrianglesInEachBlock[BlockX][BlockY];
  switch ( v3 >> 14 )
  {
    case 3u:
      v10 = v3 & 0x3FFF;
      v11 = CWaterLevel::m_QuadsAndTrianglesList[v10];
      if ( v11 >> 14 )
      {
        v12 = v11 >> 14;
        v13 = &CWaterLevel::m_QuadsAndTrianglesList[v10 + 1];
        do
        {
          if ( (v12 & 3) == 2 )
          {
            v19 = v11 & 0x3FFF;
            v20 = &CWaterLevel::m_aTriangles[v19];
            v23 = *((_BYTE *)v20 + 6);
            v22 = (char *)v20 + 6;
            v21 = v23;
            if ( (v23 & 2) == 0
              && CWaterLevel::m_aVertices[CWaterLevel::m_aTriangles[v19].Index1].m_P.m_Z > 950.0 == bInInterior )
            {
              *v22 = v21 | 1;
            }
          }
          else if ( (v12 & 3) == 1 )
          {
            v14 = v11 & 0x3FFF;
            v15 = &CWaterLevel::m_aQuads[v11 & 0x3FFF];
            v18 = *((_BYTE *)v15 + 8);
            v17 = (char *)v15 + 8;
            v16 = v18;
            if ( (v18 & 2) == 0
              && CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v14].Index1].m_P.m_Z > 950.0 == bInInterior )
            {
              *v17 = v16 | 1;
            }
          }
          v24 = *v13++;
          LOWORD(v11) = v24;
          v12 = v24 >> 14;
        }
        while ( v24 >> 14 );
      }
      break;
    case 2u:
      v25 = v3 & 0x3FFF;
      v26 = &CWaterLevel::m_aTriangles[v25];
      v28 = *((_BYTE *)v26 + 6);
      v6 = (char *)v26 + 6;
      v27 = v28;
      if ( (v28 & 2) == 0
        && CWaterLevel::m_aVertices[CWaterLevel::m_aTriangles[v25].Index1].m_P.m_Z > 950.0 == bInInterior )
      {
        v9 = v27 | 1;
        goto LABEL_24;
      }
      break;
    case 1u:
      v4 = v3 & 0x3FFF;
      v5 = &CWaterLevel::m_aQuads[v3 & 0x3FFF];
      v8 = *((_BYTE *)v5 + 8);
      v6 = (char *)v5 + 8;
      v7 = v8;
      if ( (v8 & 2) == 0 && CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v4].Index1].m_P.m_Z > 950.0 == bInInterior )
      {
        v9 = v7 | 1;
LABEL_24:
        *v6 = v9;
      }
      break;
  }
}

//----- (00594644) --------------------------------------------------------
void CWaterLevel::Shutdown()
{
  if ( gpWaterTex )
  {
    RwTextureDestroy(gpWaterTex);
    gpWaterTex = 0;
  }
  if ( gpSeaBedTex )
  {
    RwTextureDestroy(gpSeaBedTex);
    gpSeaBedTex = 0;
  }
  if ( gpWaterWakeTex )
  {
    RwTextureDestroy(gpWaterWakeTex);
    gpWaterWakeTex = 0;
  }
}

//----- (005946B0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
Int32 __fastcall CWaterLevel::AddWaterLevelVertex(Int32 X, Int32 Y, CRenPar P)
{
  __int16 v3; // r12
  Int32 v4; // r8
  float m_SmallWaves; // lr
  Int32 v6; // r1
  Int16 *p_m_Y; // r6
  Int32 v8; // r5
  int v9; // r4
  bool v10; // zf
  CWaterVertex *v11; // r0

  v3 = *(_WORD *)&P.m_FlowX;
  v4 = -3000;
  if ( X > -3000 )
  {
    m_SmallWaves = P.m_SmallWaves;
    if ( X > 2999 )
    {
      P.m_Z = 0.0;
      P.m_BigWaves = 1.0;
      m_SmallWaves = 0.0;
    }
    if ( X > 2999 )
    {
      v3 = 0;
      X = 3000;
    }
    if ( Y > -3000 )
      goto LABEL_3;
LABEL_13:
    v3 = 0;
    P.m_BigWaves = 1.0;
    m_SmallWaves = 0.0;
    P.m_Z = 0.0;
    goto LABEL_14;
  }
  v3 = 0;
  P.m_BigWaves = 1.0;
  m_SmallWaves = 0.0;
  P.m_Z = 0.0;
  X = -3000;
  if ( Y <= -3000 )
    goto LABEL_13;
LABEL_3:
  if ( Y > 2999 )
  {
    P.m_Z = 0.0;
    P.m_BigWaves = 1.0;
    m_SmallWaves = 0.0;
  }
  if ( Y > 2999 )
  {
    v3 = 0;
    Y = 3000;
  }
  v4 = Y;
LABEL_14:
  v6 = CWaterLevel::m_nNumOfWaterVertices;
  if ( CWaterLevel::m_nNumOfWaterVertices < 1 )
  {
LABEL_22:
    CWaterLevel::m_aVertices[CWaterLevel::m_nNumOfWaterVertices].m_X = X;
    v11 = &CWaterLevel::m_aVertices[v6];
    *(_WORD *)&v11->m_P.m_FlowX = v3;
    v11->m_P.m_Z = P.m_Z;
    v11->m_P.m_BigWaves = P.m_BigWaves;
    v11->m_P.m_SmallWaves = m_SmallWaves;
    v11->m_Y = v4;
    CWaterLevel::m_nNumOfWaterVertices = v6 + 1;
  }
  else
  {
    p_m_Y = &CWaterLevel::m_aVertices[0].m_Y;
    v8 = 0;
    while ( 1 )
    {
      v9 = *(p_m_Y - 1);
      v10 = X == v9;
      if ( X == v9 )
        v10 = v4 == *p_m_Y;
      if ( v10 && *(float *)(p_m_Y + 1) == P.m_Z )
        return v8;
      ++v8;
      p_m_Y += 10;
      if ( v8 >= CWaterLevel::m_nNumOfWaterVertices )
        goto LABEL_22;
    }
  }
  return v6;
}
// 5946B0: fragmented variable at 0:r2.8,8:^18.8 may be wrong
// 5946B0: variables would overlap: 0:r2.8,8:^18.8 and ^18.4
// 5946B0: variables would overlap: 0:r2.8,8:^18.8 and ^1C.2

//----- (005947CC) --------------------------------------------------------
void __fastcall CWaterLevel::AddWaveToResult(
        float x,
        float y,
        float *pWaterZ,
        float BigWavesAmpl,
        float SmallWavesAmpl,
        CVector *pNormal)
{
  float v9; // s18
  float v10; // r4
  float v11; // s4
  float v12; // s0
  float v13; // s2
  float v14; // s6
  int v15; // s12
  float v16; // s10
  int v17; // r3
  int v18; // r8
  int v19; // r9
  uint32 v20; // r5
  unsigned int v21; // r10
  unsigned int v22; // s8
  unsigned int v23; // r2
  int v24; // r5
  float v25; // s26
  float *v26; // r0
  int v27; // r3
  float v28; // s10
  float v29; // s8
  float v30; // s20
  float v31; // s13
  float v32; // s12
  float v33; // s14
  float v34; // s15
  float v35; // s7
  float v36; // s10
  float v37; // s8
  float v38; // s11
  float v39; // s14
  float v40; // s5
  float v41; // s15
  float v42; // s13
  float *v43; // r12
  float *v44; // r2
  float v45; // s12
  float v46; // s8
  float v47; // s10
  int v48; // r1
  float *v49; // r0
  float v50; // s4
  float v51; // s6
  float v52; // s4
  float v53; // s0
  float v54; // s2
  float *v55; // r5
  int v56; // r2
  int v57; // r3
  float v58; // s9
  float v59; // s13
  float v60; // s8
  float v61; // s18
  float v62; // s15
  float v63; // s5
  float v64; // s10
  float v65; // s8
  float v66; // s24
  float v67; // s5
  float v68; // s1
  float v69; // s26
  float v70; // s11
  float v71; // s3
  float v72; // s5
  float v73; // s18
  float v74; // s13
  float v75; // s7
  float v76; // s8
  float v77; // s4
  float v78; // s6
  float v79; // s2
  float v80; // s4
  float v81; // s2
  float v82; // s0
  uint32 v83; // r5
  int v84; // r6
  unsigned int v85; // s28
  unsigned int v86; // s7
  unsigned int v87; // r5
  int v88; // r2
  float v89; // s7
  float v90; // s1
  float v91; // s26
  float v92; // s20
  float v93; // s11
  float v94; // s12
  float v95; // s15
  float v96; // s3
  float v97; // s10
  float v98; // s7
  float v99; // s24
  float v100; // s14
  float v101; // s15
  float v102; // s10
  float v103; // s11
  float v104; // s1
  float *v105; // r12
  float v106; // s10
  float v107; // s12
  float v108; // s4
  __int64 v109; // d16
  float v110; // s2
  int v111; // r2
  int v112; // r5
  float v113; // s3
  float v114; // s18
  float v115; // s10
  float v116; // s11
  float v117; // s7
  float v118; // s15
  float v119; // s24
  float v120; // s14
  float v121; // s20
  float v122; // s3
  float v123; // s22
  float v124; // s13
  float v125; // s10
  float v126; // s7
  float v127; // s3
  unsigned __int8 v128; // r1
  unsigned int v129; // s12
  float v130; // s9
  float v131; // s18
  float v132; // s1
  int v133; // r6
  float v134; // s26
  float v135; // s11
  float v136; // s20
  float v137; // s24
  float v138; // s15
  float v139; // s18
  float v140; // s14
  float v141; // s9
  float v142; // s10
  float v143; // s4
  float v144; // s6
  CVector v2; // [sp+8h] [bp-88h] BYREF
  CVector v1; // [sp+14h] [bp-7Ch] BYREF
  CVector v147; // [sp+20h] [bp-70h] BYREF

  v9 = x * 0.5;
  v10 = floorf(x * 0.5);
  v11 = floorf(y * 0.5);
  v12 = (float)(y * 0.5) - v11;
  v13 = v9 - v10;
  v14 = BigWavesAmpl;
  v15 = (int)(float)(v11 + v11);
  v16 = (float)(v9 - v10) + v12;
  v17 = (int)(float)(v10 + v10);
  v18 = v15;
  v19 = v17;
  if ( pNormal )
  {
    if ( v16 >= 1.0 )
    {
      v81 = 1.0 - v13;
      v82 = 1.0 - v12;
      if ( v15 < 0 )
        v18 = -v15;
      v83 = CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset;
      if ( v17 < 0 )
        v19 = -v17;
      v84 = v17 + 2;
      v85 = v83 % 0xBB8;
      v86 = v83 % 0x1388;
      v87 = v83 % 0xDAC;
      v88 = v15 + 2;
      if ( v17 < -2 )
        v84 = -2 - v17;
      if ( v15 < -2 )
        v88 = -2 - v15;
      v89 = (float)v86 * 0.0012566;
      v90 = (float)v87 * 0.0017952;
      v91 = (float)v88 * 0.098175;
      v92 = (float)v85 * 0.0020944;
      v93 = *(float *)((char *)MultY + ((2 * (v88 + ((unsigned int)v88 >> 31))) & 0x1C));
      v94 = (float)((float)v19 * 0.098175) + v89;
      v95 = (float)((float)v84 * 0.24166) + v90;
      v96 = (float)((float)v84 * 0.098175) + v89;
      v97 = (float)v88 * 0.12083;
      v98 = *(float *)((char *)MultX + ((2 * (v84 + ((unsigned int)v84 >> 31))) & 0x1C));
      v99 = v93 * *(float *)((char *)MultX + ((2 * (v19 + ((unsigned int)v19 >> 31))) & 0x1C));
      v100 = (float)((float)v18 * 0.12083) + v95;
      v101 = v97 + v95;
      v102 = v97 + (float)((float)((float)v19 * 0.24166) + v90);
      v103 = (float)(v98 * v93) * CWeather::Wavyness;
      v104 = CWeather::Wavyness
           * (float)(v98 * *(float *)((char *)MultY + ((2 * (v18 + ((unsigned int)v18 >> 31))) & 0x1C)));
      v105 = &CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v88 * 0.31416)
                                                                                       + v92)
                                                                               * 256.0)
                                                                       / 6.2832)];
      v106 = (float)(*v105 * (float)((float)((float)(CWeather::Wavyness * v99) * 0.5) * SmallWavesAmpl))
           + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v102 * 256.0) / 6.2832)]
                           * (float)((float)(CWeather::Wavyness * v99) * SmallWavesAmpl))
                   + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)(v91 + v94) * 256.0)
                                                                                              / 6.2832)]
                                   * (float)((float)((float)(CWeather::Wavyness * v99)
                                                   + (float)(CWeather::Wavyness * v99))
                                           * v14))
                           + 0.0));
      v107 = (float)((float)((float)((float)((float)(v103 + v103) * v14)
                                   * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)(v91 + v96) * 256.0)
                                                                                              / 6.2832)])
                           + 0.0)
                   + (float)((float)(v103 * SmallWavesAmpl)
                           * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v101 * 256.0) / 6.2832)]))
           + (float)((float)((float)(v103 * 0.5) * SmallWavesAmpl) * *v105);
      v48 = -1073741824;
      v49 = pWaterZ;
      v108 = (float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v18 * 0.31416)
                                                                                              + v92)
                                                                                      * 256.0)
                                                                              / 6.2832)]
                   * (float)((float)(v104 * 0.5) * SmallWavesAmpl))
           + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v100 * 256.0) / 6.2832)]
                           * (float)(v104 * SmallWavesAmpl))
                   + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v18 * 0.098175) + v96) * 256.0)
                                                                                              / 6.2832)]
                                   * (float)((float)(v104 + v104) * v14))
                           + 0.0));
      v51 = v106 - v107;
      v52 = v108 - v107;
      v53 = v82 * v52;
      v54 = v107 + (float)(v81 * (float)(v106 - v107));
    }
    else
    {
      if ( v17 < 0 )
        v19 = -v17;
      v20 = CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset;
      if ( v15 < 0 )
        v18 = -v15;
      v21 = v20 % 0xBB8;
      v22 = v20 % 0xDAC;
      v23 = v20 % 0x1388;
      v24 = v17 + 2;
      v25 = *(float *)((char *)MultX + ((2 * (v19 + ((unsigned int)v19 >> 31))) & 0x1C));
      v26 = (float *)((char *)MultY + ((2 * (v18 + ((unsigned int)v18 >> 31))) & 0x1C));
      if ( v17 < -2 )
        v24 = -2 - v17;
      v27 = v15 + 2;
      if ( v15 < -2 )
        v27 = -2 - v15;
      v28 = (float)v23 * 0.0012566;
      v29 = (float)v22 * 0.0017952;
      v30 = (float)v21 * 0.0020944;
      v31 = (float)v18 * 0.098175;
      v32 = (float)((float)v19 * 0.098175) + v28;
      v33 = (float)v18 * 0.12083;
      v34 = (float)((float)v19 * 0.24166) + v29;
      v35 = v31 + v32;
      v36 = v31 + (float)((float)((float)v24 * 0.098175) + v28);
      v37 = v33 + (float)((float)((float)v24 * 0.24166) + v29);
      v38 = (float)((float)v27 * 0.12083) + v34;
      v39 = v33 + v34;
      v40 = CWeather::Wavyness
          * (float)(*v26 * *(float *)((char *)MultX + ((2 * (v24 + ((unsigned int)v24 >> 31))) & 0x1C)));
      v41 = (float)(v25 * *v26) * CWeather::Wavyness;
      v42 = CWeather::Wavyness
          * (float)(v25 * *(float *)((char *)MultY + ((2 * (v27 + ((unsigned int)v27 >> 31))) & 0x1C)));
      v43 = &CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v18 * 0.31416)
                                                                                      + v30)
                                                                              * 256.0)
                                                                      / 6.2832)];
      v44 = &CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v27 * 0.098175)
                                                                                      + v32)
                                                                              * 256.0)
                                                                      / 6.2832)];
      v45 = CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v37 * 256.0) / 6.2832)]
          * (float)(v40 * SmallWavesAmpl);
      v46 = (float)((float)((float)((float)((float)(v41 + v41) * v14)
                                  * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v35 * 256.0)
                                                                                             / 6.2832)])
                          + 0.0)
                  + (float)((float)(v41 * SmallWavesAmpl)
                          * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v39 * 256.0) / 6.2832)]))
          + (float)((float)((float)(v41 * 0.5) * SmallWavesAmpl) * *v43);
      v47 = (float)(*v43 * (float)((float)(v40 * 0.5) * SmallWavesAmpl))
          + (float)(v45
                  + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v36 * 256.0)
                                                                                             / 6.2832)]
                                  * (float)((float)(v40 + v40) * v14))
                          + 0.0));
      v48 = 0x40000000;
      v49 = pWaterZ;
      v50 = (float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v27 * 0.31416)
                                                                                             + v30)
                                                                                     * 256.0)
                                                                             / 6.2832)]
                  * (float)((float)(v42 * 0.5) * SmallWavesAmpl))
          + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v38 * 256.0) / 6.2832)]
                          * (float)(v42 * SmallWavesAmpl))
                  + (float)((float)(*v44 * (float)((float)(v42 + v42) * v14)) + 0.0));
      v51 = v47 - v46;
      v52 = v50 - v46;
      v53 = v12 * v52;
      v54 = v46 + (float)(v13 * (float)(v47 - v46));
    }
    *v49 = *v49 + (float)(v54 + v53);
    v1.y = 0.0;
    LODWORD(v1.x) = v48;
    LODWORD(v2.y) = v48;
    v2.x = 0.0;
    v1.z = v51;
    v2.z = v52;
    CrossProduct(&v147, &v1, &v2);
    v109 = *(_QWORD *)&v147.x;
    pNormal->z = v147.z;
    *(_QWORD *)&pNormal->x = v109;
    CVector::Normalise(pNormal);
  }
  else
  {
    if ( v16 >= 1.0 )
    {
      v110 = 1.0 - v13;
      v12 = 1.0 - v12;
      if ( v17 < 0 )
        v19 = -v17;
      v111 = v15 + 2;
      v112 = v17 + 2;
      if ( v15 < -2 )
        v111 = -2 - v15;
      if ( v17 < -2 )
        v112 = -2 - v17;
      if ( v15 < 0 )
        v18 = -v15;
      v113 = (float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xDAC) * 0.0017952;
      v114 = *(float *)((char *)MultY + ((2 * (v111 + ((unsigned int)v111 >> 31))) & 0x1C));
      v115 = (float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0x1388) * 0.0012566;
      v116 = (float)v111 * 0.12083;
      v117 = (float)v111 * 0.098175;
      v118 = (float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xBB8) * 0.0020944;
      v119 = (float)((float)v112 * 0.098175) + v115;
      v120 = (float)((float)v19 * 0.24166) + v113;
      v121 = *(float *)((char *)MultX + ((2 * (v112 + ((unsigned int)v112 >> 31))) & 0x1C));
      v122 = (float)((float)v112 * 0.24166) + v113;
      v123 = v117 + v119;
      v124 = (float)((float)v18 * 0.098175) + v119;
      v125 = v117 + (float)((float)((float)v19 * 0.098175) + v115);
      v126 = (float)((float)v18 * 0.12083) + v122;
      v127 = v116 + v122;
      v128 = (unsigned int)(float)((float)((float)((float)((float)v111 * 0.31416) + v118) * 256.0) / 6.2832);
      v129 = (unsigned int)(float)((float)((float)(v116 + v120) * 256.0) / 6.2832);
      v130 = CWeather::Wavyness
           * (float)(v114 * *(float *)((char *)MultX + ((2 * (v19 + ((unsigned int)v19 >> 31))) & 0x1C)));
      v131 = (float)(v121 * v114) * CWeather::Wavyness;
      v132 = (float)((float)((float)((float)v18 * 0.31416) + v118) * 256.0) / 6.2832;
      v133 = (unsigned __int8)(unsigned int)(float)((float)(v125 * 256.0) / 6.2832);
      v134 = v131 * 0.5;
      v135 = CWeather::Wavyness
           * (float)(v121 * *(float *)((char *)MultY + ((2 * (v18 + ((unsigned int)v18 >> 31))) & 0x1C)));
      v136 = v131 + v131;
      v137 = (float)(v130 + v130) * v14;
      v138 = v131 * SmallWavesAmpl;
      v139 = (float)(v130 * 0.5) * SmallWavesAmpl;
      v140 = CMaths::ms_SinTable[(unsigned __int8)v129] * (float)(v130 * SmallWavesAmpl);
      v141 = CMaths::ms_SinTable[v128];
      v142 = (float)((float)((float)((float)(v136 * v14)
                                   * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v123 * 256.0)
                                                                                              / 6.2832)])
                           + 0.0)
                   + (float)(v138
                           * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v127 * 256.0) / 6.2832)]))
           + (float)((float)(v134 * SmallWavesAmpl) * v141);
      v143 = (float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v132]
                   * (float)((float)(v135 * 0.5) * SmallWavesAmpl))
           + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v126 * 256.0) / 6.2832)]
                           * (float)(v135 * SmallWavesAmpl))
                   + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v124 * 256.0)
                                                                                              / 6.2832)]
                                   * (float)((float)(v135 + v135) * v14))
                           + 0.0));
      v144 = v110
           * (float)((float)((float)(v141 * v139)
                           + (float)(v140 + (float)((float)(CMaths::ms_SinTable[v133] * v137) + 0.0)))
                   - v142);
      v79 = v143 - v142;
      v80 = v142 + v144;
    }
    else
    {
      if ( v17 < 0 )
        v19 = -v17;
      v55 = (float *)((char *)MultX + ((2 * (v19 + ((unsigned int)v19 >> 31))) & 0x1C));
      v56 = v17 + 2;
      if ( v17 < -2 )
        v56 = -2 - v17;
      v57 = v15 + 2;
      if ( v15 < -2 )
        v57 = -2 - v15;
      if ( v15 < 0 )
        v18 = -v15;
      v58 = (float)v18 * 0.12083;
      v59 = (float)v18 * 0.098175;
      v60 = (float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xDAC) * 0.0017952;
      v61 = *(float *)((char *)MultY + ((2 * (v18 + ((unsigned int)v18 >> 31))) & 0x1C));
      v62 = (float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xBB8) * 0.0020944;
      v63 = (float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0x1388) * 0.0012566;
      v64 = (float)((float)v56 * 0.24166) + v60;
      v65 = (float)((float)v19 * 0.24166) + v60;
      v66 = (float)((float)v56 * 0.098175) + v63;
      v67 = (float)((float)v19 * 0.098175) + v63;
      v68 = (float)((float)v57 * 0.12083) + v65;
      v69 = *v55 * v61;
      v70 = v59 + v67;
      v71 = (float)((float)((float)((float)v57 * 0.098175) + v67) * 256.0) / 6.2832;
      v72 = (float)((float)(v59 + v66) * 256.0) / 6.2832;
      v73 = CWeather::Wavyness
          * (float)(v61 * *(float *)((char *)MultX + ((2 * (v56 + ((unsigned int)v56 >> 31))) & 0x1C)));
      v74 = *v55 * *(float *)((char *)MultY + ((2 * (v57 + ((unsigned int)v57 >> 31))) & 0x1C));
      v75 = CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v18 * 0.31416)
                                                                                     + v62)
                                                                             * 256.0)
                                                                     / 6.2832)];
      v76 = (float)((float)((float)((float)((float)((float)(v69 * CWeather::Wavyness) + (float)(v69 * CWeather::Wavyness))
                                          * v14)
                                  * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v70 * 256.0)
                                                                                             / 6.2832)])
                          + 0.0)
                  + (float)((float)((float)(v69 * CWeather::Wavyness) * SmallWavesAmpl)
                          * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)(v58 + v65) * 256.0)
                                                                                     / 6.2832)]))
          + (float)((float)((float)((float)(v69 * CWeather::Wavyness) * 0.5) * SmallWavesAmpl) * v75);
      v77 = (float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)v57 * 0.31416)
                                                                                             + v62)
                                                                                     * 256.0)
                                                                             / 6.2832)]
                  * (float)((float)((float)(CWeather::Wavyness * v74) * 0.5) * SmallWavesAmpl))
          + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)(v68 * 256.0) / 6.2832)]
                          * (float)((float)(CWeather::Wavyness * v74) * SmallWavesAmpl))
                  + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v71]
                                  * (float)((float)((float)(CWeather::Wavyness * v74) + (float)(CWeather::Wavyness * v74))
                                          * v14))
                          + 0.0));
      v78 = v13
          * (float)((float)((float)(v75 * (float)((float)(v73 * 0.5) * SmallWavesAmpl))
                          + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)(v58 + v64) * 256.0) / 6.2832)]
                                          * (float)(v73 * SmallWavesAmpl))
                                  + (float)((float)(CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v72]
                                                  * (float)((float)(v73 + v73) * v14))
                                          + 0.0)))
                  - v76);
      v79 = v77 - v76;
      v80 = v76 + v78;
    }
    *pWaterZ = *pWaterZ + (float)(v80 + (float)(v12 * v79));
  }
}

//----- (00595650) --------------------------------------------------------
void __fastcall CWaterLevel::CalculateWavesOnlyForCoordinate(
        Int32 X,
        Int32 Y,
        float BigWavesAmpl,
        float SmallWavesAmpl,
        float *pResultHeight)
{
  float v5; // s10
  float v6; // s8
  float v7; // s4

  if ( X < 0 )
    X = -X;
  if ( Y < 0 )
    Y = -Y;
  v5 = (float)(*(float *)((char *)MultX + ((2 * (X + ((unsigned int)X >> 31))) & 0x1C))
             * *(float *)((char *)MultY + ((2 * (Y + ((unsigned int)Y >> 31))) & 0x1C)))
     * CWeather::Wavyness;
  v6 = *pResultHeight
     + (float)((float)((float)(v5 + v5) * BigWavesAmpl)
             * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)Y * 0.098175)
                                                                                        + (float)((float)((float)X * 0.098175)
                                                                                                + (float)((float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0x1388) * 0.0012566)))
                                                                                * 256.0)
                                                                        / 6.2832)]);
  *pResultHeight = v6;
  v7 = v6
     + (float)((float)(v5 * SmallWavesAmpl)
             * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)Y * 0.12083)
                                                                                        + (float)((float)((float)X * 0.24166)
                                                                                                + (float)((float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xDAC) * 0.0017952)))
                                                                                * 256.0)
                                                                        / 6.2832)]);
  *pResultHeight = v7;
  *pResultHeight = v7
                 + (float)((float)((float)(v5 * 0.5) * SmallWavesAmpl)
                         * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)((float)((float)((float)((float)Y * 0.31416) + (float)((float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xBB8) * 0.0020944))
                                                                                            * 256.0)
                                                                                    / 6.2832)]);
}

//----- (00595878) --------------------------------------------------------
void __fastcall CWaterLevel::AddWaveToResult(
        Int32 x,
        Int32 y,
        float *pWaterZ,
        float BigWavesAmpl,
        float SmallWavesAmpl)
{
  CWaterLevel::CalculateWavesOnlyForCoordinate(x, y, BigWavesAmpl, SmallWavesAmpl, pWaterZ);
}

//----- (00595890) --------------------------------------------------------
int __fastcall CWaterLevel::GetWaterLevel(
        float x,
        float y,
        float z,
        float *pWaterZ,
        int bForceResult,
        CVector *pNormal)
{
  int result; // r0
  float SmallWavesAmpl; // [sp+8h] [bp-18h] BYREF
  float BigWavesAmpl[5]; // [sp+Ch] [bp-14h] BYREF

  if ( !CWaterLevel::GetWaterLevelNoWaves(x, y, z, pWaterZ, BigWavesAmpl, &SmallWavesAmpl) )
    return 0;
  if ( bForceResult || (float)(*pWaterZ - z) <= 3.0 )
  {
    CWaterLevel::AddWaveToResult(x, y, pWaterZ, BigWavesAmpl[0], SmallWavesAmpl, pNormal);
    return 1;
  }
  else
  {
    result = 0;
    *pWaterZ = 0.0;
  }
  return result;
}
// 595890: using guessed type float BigWavesAmpl[5];

//----- (00595900) --------------------------------------------------------
bool __fastcall CWaterLevel::GetWaterLevelNoWaves(float x, float y, float z, float *pWaterZ, float *a5, float *a6)
{
  float v10; // r4
  float v11; // r0
  int v12; // r1
  bool v13; // cf
  _BOOL4 result; // r0
  unsigned int v15; // r2
  int v16; // r2
  unsigned int v17; // r1
  unsigned int v18; // r3
  UInt16 *v19; // r4
  unsigned int v20; // t1

  v10 = floorf((float)(x / 500.0) + 6.0);
  v11 = floorf((float)(y / 500.0) + 6.0);
  v13 = (unsigned int)(int)v10 >= 0xB;
  if ( (unsigned int)(int)v10 <= 0xB )
  {
    v12 = (int)v11;
    v13 = (unsigned int)(int)v11 >= 0xC;
  }
  if ( v13 )
  {
    *pWaterZ = 0.0;
    if ( a5 )
      *a5 = 1.0;
    if ( a6 )
      *a6 = 0.0;
    return 1;
  }
  else
  {
    v15 = CWaterLevel::m_QuadsAndTrianglesInEachBlock[v10][v12];
    result = 0;
    switch ( v15 >> 14 )
    {
      case 3u:
        v16 = v15 & 0x3FFF;
        v17 = CWaterLevel::m_QuadsAndTrianglesList[v16];
        if ( !(v17 >> 14) )
          return result;
        v18 = v17 >> 14;
        v19 = &CWaterLevel::m_QuadsAndTrianglesList[v16 + 1];
        while ( 1 )
        {
          if ( (v18 & 3) == 2 )
          {
            if ( CWaterLevel::TestTriangleToGetWaterLevel(
                   &CWaterLevel::m_aTriangles[v17 & 0x3FFF],
                   x,
                   y,
                   z,
                   pWaterZ,
                   a5,
                   a6) )
            {
              return 1;
            }
          }
          else if ( (v18 & 3) == 1
                 && CWaterLevel::TestQuadToGetWaterLevel(&CWaterLevel::m_aQuads[v17 & 0x3FFF], x, y, z, pWaterZ, a5, a6) )
          {
            return 1;
          }
          v20 = *v19++;
          LOWORD(v17) = v20;
          result = 0;
          v18 = v20 >> 14;
          if ( !(v20 >> 14) )
            return result;
        }
      case 2u:
        return CWaterLevel::TestTriangleToGetWaterLevel(
                 &CWaterLevel::m_aTriangles[v15 & 0x3FFF],
                 x,
                 y,
                 z,
                 pWaterZ,
                 a5,
                 a6);
      case 1u:
        return CWaterLevel::TestQuadToGetWaterLevel(&CWaterLevel::m_aQuads[v15 & 0x3FFF], x, y, z, pWaterZ, a5, a6);
    }
  }
  return result;
}
// 5959A4: variable 'v12' is possibly undefined

//----- (00595AC4) --------------------------------------------------------
bool __fastcall CWaterLevel::TestQuadToGetWaterLevel(
        CWaterQuad *pQuad,
        float x,
        float y,
        float z,
        float *a5,
        float *a6,
        float *a7)
{
  float m_X; // s2
  int m_Y; // r2
  int v10; // r10
  _BOOL4 result; // r0
  float v12; // s4
  float v13; // s2
  float v14; // s4
  float m_Z; // s8
  float v16; // s6
  int Index3; // r2
  float v18; // s8
  float m_SmallWaves; // s6
  float m_BigWaves; // s6
  float v21; // s2
  bool v22; // nf

  m_X = (float)CWaterLevel::m_aVertices[pQuad->Index1].m_X;
  if ( m_X > x )
    return 0;
  if ( (float)CWaterLevel::m_aVertices[pQuad->Index2].m_X < x )
    return 0;
  m_Y = CWaterLevel::m_aVertices[pQuad->Index1].m_Y;
  if ( (float)m_Y > y )
    return 0;
  v10 = CWaterLevel::m_aVertices[pQuad->Index3].m_Y;
  if ( (float)v10 < y )
    return 0;
  v12 = x - m_X;
  v13 = (float)(y - (float)m_Y) / (float)(v10 - m_Y);
  v14 = v12 / (float)(CWaterLevel::m_aVertices[pQuad->Index2].m_X - CWaterLevel::m_aVertices[pQuad->Index1].m_X);
  if ( (float)(v14 + v13) <= 1.0 )
  {
    *a5 = (float)(CWaterLevel::m_aVertices[pQuad->Index1].m_P.m_Z
                + (float)(v14
                        * (float)(CWaterLevel::m_aVertices[pQuad->Index2].m_P.m_Z
                                - CWaterLevel::m_aVertices[pQuad->Index1].m_P.m_Z)))
        + (float)(v13
                * (float)(CWaterLevel::m_aVertices[pQuad->Index3].m_P.m_Z
                        - CWaterLevel::m_aVertices[pQuad->Index1].m_P.m_Z));
    if ( !a6 )
      return 1;
    m_BigWaves = CWaterLevel::m_aVertices[pQuad->Index1].m_P.m_BigWaves;
    *a6 = (float)(m_BigWaves
                + (float)(v14 * (float)(CWaterLevel::m_aVertices[pQuad->Index2].m_P.m_BigWaves - m_BigWaves)))
        + (float)(v13 * (float)(CWaterLevel::m_aVertices[pQuad->Index3].m_P.m_BigWaves - m_BigWaves));
    m_SmallWaves = CWaterLevel::m_aVertices[pQuad->Index1].m_P.m_SmallWaves;
    v18 = CWaterLevel::m_aVertices[pQuad->Index2].m_P.m_SmallWaves;
    Index3 = pQuad->Index3;
  }
  else
  {
    v14 = 1.0 - v14;
    v13 = 1.0 - v13;
    m_Z = CWaterLevel::m_aVertices[pQuad->Index4].m_P.m_Z;
    *a5 = (float)(m_Z + (float)(v14 * (float)(CWaterLevel::m_aVertices[pQuad->Index3].m_P.m_Z - m_Z)))
        + (float)(v13 * (float)(CWaterLevel::m_aVertices[pQuad->Index2].m_P.m_Z - m_Z));
    if ( !a6 )
      return 1;
    v16 = CWaterLevel::m_aVertices[pQuad->Index4].m_P.m_BigWaves;
    *a6 = (float)(v16 + (float)(v14 * (float)(CWaterLevel::m_aVertices[pQuad->Index3].m_P.m_BigWaves - v16)))
        + (float)(v13 * (float)(CWaterLevel::m_aVertices[pQuad->Index2].m_P.m_BigWaves - v16));
    Index3 = pQuad->Index2;
    v18 = CWaterLevel::m_aVertices[pQuad->Index3].m_P.m_SmallWaves;
    m_SmallWaves = CWaterLevel::m_aVertices[pQuad->Index4].m_P.m_SmallWaves;
  }
  *a7 = (float)(m_SmallWaves + (float)(v14 * (float)(v18 - m_SmallWaves)))
      + (float)(v13 * (float)(CWaterLevel::m_aVertices[Index3].m_P.m_SmallWaves - m_SmallWaves));
  v21 = *a5;
  if ( (float)(*a5 + -6.0) <= z )
    return (float)(v21 + 20.0) >= z;
  v22 = (*((_BYTE *)pQuad + 8) & 4) != 0;
  result = 0;
  if ( !v22 && (float)(v21 + 20.0) >= z )
    return 1;
  return result;
}

//----- (00595DD4) --------------------------------------------------------
bool __fastcall CWaterLevel::TestTriangleToGetWaterLevel(
        CWaterTriangle *pTriangle,
        float x,
        float y,
        float z,
        float *pWaterZ,
        float *pBigWaves,
        float *pSmallWaves)
{
  int Index1; // r5
  int m_X; // r6
  int v10; // r1
  int m_Y; // r2
  int v14; // r4
  Int16 v15; // r1
  int v16; // s0
  Int16 v17; // r1
  float v18; // s8
  int v19; // s0
  float v20; // s0
  float v21; // s4
  float v22; // s2
  float v23; // s6
  float m_BigWaves; // s6
  float m_SmallWaves; // s6
  float v26; // s8
  CWaterVertex *v27; // r1
  float v28; // s6

  Index1 = pTriangle->Index1;
  m_X = CWaterLevel::m_aVertices[Index1].m_X;
  if ( (float)m_X > x || (float)CWaterLevel::m_aVertices[pTriangle->Index2].m_X < x )
    return 0;
  m_Y = CWaterLevel::m_aVertices[pTriangle->Index3].m_Y;
  v14 = CWaterLevel::m_aVertices[Index1].m_Y;
  v15 = CWaterLevel::m_aVertices[pTriangle->Index3].m_Y;
  if ( v14 < m_Y )
    v15 = CWaterLevel::m_aVertices[Index1].m_Y;
  v16 = v15;
  v17 = CWaterLevel::m_aVertices[Index1].m_Y;
  v18 = (float)v16;
  if ( v14 < m_Y )
    v17 = CWaterLevel::m_aVertices[pTriangle->Index3].m_Y;
  v19 = v17;
  v10 = 0;
  v20 = (float)v19;
  if ( v18 <= y && v20 >= y )
  {
    v21 = (float)(x - (float)m_X) / (float)(CWaterLevel::m_aVertices[pTriangle->Index2].m_X - m_X);
    v22 = (float)(y - (float)v14) / (float)(m_Y - v14);
    if ( (unsigned __int16)m_X == (unsigned __int16)CWaterLevel::m_aVertices[pTriangle->Index3].m_X )
    {
      if ( (float)(v21 + v22) <= 1.0 )
      {
        v23 = (float)(CWaterLevel::m_aVertices[Index1].m_P.m_Z
                    + (float)(v21
                            * (float)(CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_Z
                                    - CWaterLevel::m_aVertices[Index1].m_P.m_Z)))
            + (float)(v22
                    * (float)(CWaterLevel::m_aVertices[pTriangle->Index3].m_P.m_Z
                            - CWaterLevel::m_aVertices[Index1].m_P.m_Z));
        *pWaterZ = v23;
        if ( pBigWaves )
        {
          m_BigWaves = CWaterLevel::m_aVertices[pTriangle->Index1].m_P.m_BigWaves;
          *pBigWaves = (float)(m_BigWaves
                             + (float)(v21
                                     * (float)(CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_BigWaves - m_BigWaves)))
                     + (float)(v22 * (float)(CWaterLevel::m_aVertices[pTriangle->Index3].m_P.m_BigWaves - m_BigWaves));
          m_SmallWaves = CWaterLevel::m_aVertices[pTriangle->Index1].m_P.m_SmallWaves;
          v26 = CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_SmallWaves - m_SmallWaves;
          v27 = &CWaterLevel::m_aVertices[pTriangle->Index3];
LABEL_18:
          *pSmallWaves = (float)(m_SmallWaves + (float)(v21 * v26))
                       + (float)(v22 * (float)(v27->m_P.m_SmallWaves - m_SmallWaves));
          v23 = *pWaterZ;
          goto LABEL_19;
        }
        goto LABEL_19;
      }
    }
    else if ( v21 >= v22 )
    {
      v21 = 1.0 - v21;
      v23 = (float)(CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_Z
                  + (float)(v21
                          * (float)(CWaterLevel::m_aVertices[Index1].m_P.m_Z
                                  - CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_Z)))
          + (float)(v22
                  * (float)(CWaterLevel::m_aVertices[pTriangle->Index3].m_P.m_Z
                          - CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_Z));
      *pWaterZ = v23;
      if ( pBigWaves )
      {
        v28 = CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_BigWaves;
        *pBigWaves = (float)(v28
                           + (float)(v21 * (float)(CWaterLevel::m_aVertices[pTriangle->Index1].m_P.m_BigWaves - v28)))
                   + (float)(v22 * (float)(CWaterLevel::m_aVertices[pTriangle->Index3].m_P.m_BigWaves - v28));
        m_SmallWaves = CWaterLevel::m_aVertices[pTriangle->Index2].m_P.m_SmallWaves;
        v27 = &CWaterLevel::m_aVertices[pTriangle->Index3];
        v26 = CWaterLevel::m_aVertices[pTriangle->Index1].m_P.m_SmallWaves - m_SmallWaves;
        goto LABEL_18;
      }
LABEL_19:
      if ( (float)(v23 + -6.0) <= z || (*((_BYTE *)pTriangle + 6) & 4) == 0 )
        return (float)(v23 + 20.0) >= z;
    }
    return 0;
  }
  return v10;
}

//----- (005960F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __fastcall CWaterLevel::TestLineAgainstWater(CVector StartCoors, CVector EndCoors, CVector *pPenetrationPoint)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d2
  float32x2_t v6; // d3
  float32x2_t v7; // d9
  float32x2_t v8; // d8
  float v9; // s9
  int v10; // s13
  int v11; // s14
  int v12; // r3
  float v13; // s20
  float v14; // s22
  float v15; // s12
  float v16; // s0
  float v17; // s2
  float v18; // s4
  float v19; // s6
  unsigned int v20; // r0
  bool v21; // cf
  int v22; // r10
  bool v23; // zf
  unsigned int v24; // r0
  UInt16 *i; // r11
  unsigned int v26; // r0
  int v27; // r0
  int v30; // [sp+34h] [bp-54h]
  int v31; // [sp+40h] [bp-48h]

  v5.n64_u32[0] = LODWORD(EndCoors.y);
  v3.n64_u32[0] = LODWORD(StartCoors.y);
  v4.n64_u32[0] = LODWORD(StartCoors.x);
  v6.n64_u32[0] = LODWORD(EndCoors.x);
  StartCoors.x = 0.0;
  v8.n64_u64[0] = vmin_f32(v4, v6).n64_u64[0];
  v9 = vmin_f32(v3, v5).n64_f32[0] / 500.0;
  v10 = (int)(float)((float)(vmax_f32(v4, v6).n64_f32[0] / 500.0) + 6.0);
  v11 = (int)(float)((float)(vmax_f32(v3, v5).n64_f32[0] / 500.0) + 6.0);
  v12 = (int)(float)((float)(v8.n64_f32[0] / 500.0) + 6.0);
  if ( v12 <= v10 )
  {
    v8.n64_u32[0] = LODWORD(EndCoors.z);
    v7.n64_u32[0] = LODWORD(StartCoors.z);
    v13 = vmax_f32(v7, v8).n64_f32[0];
    v14 = vmin_f32(v7, v8).n64_f32[0];
    v15 = fabsf(StartCoors.z) / (float)(v13 - v14);
    v16 = (float)((float)(EndCoors.y - StartCoors.y) * v15) + StartCoors.y;
    v17 = (float)((float)(v6.n64_f32[0] - v4.n64_f32[0]) * v15) + v4.n64_f32[0];
    if ( v14 < 0.0 )
      LOBYTE(StartCoors.x) = 1;
    v18 = StartCoors.z * EndCoors.z;
    v19 = (float)((float)(EndCoors.z - StartCoors.z) * v15) + StartCoors.z;
    v31 = LOBYTE(StartCoors.x) & (v13 > 0.0);
    v30 = (int)(float)((float)(v17 / 500.0) + 6.0);
    do
    {
      if ( (int)(float)(v9 + 6.0) <= v11 )
      {
        v20 = (int)(float)(v9 + 6.0);
        do
        {
          v21 = (unsigned int)v12 >= 0xB;
          v22 = v20;
          if ( (unsigned int)v12 <= 0xB )
            v21 = v20 >= 0xC;
          if ( v21 )
          {
            if ( v31 == 1 )
            {
              pPenetrationPoint->x = v17;
              pPenetrationPoint->y = v16;
              pPenetrationPoint->z = v19;
              v23 = v12 == v30;
              if ( v12 == v30 )
                v23 = v20 == (int)(float)((float)(v16 / 500.0) + 6.0);
              if ( v23 )
                goto LABEL_39;
            }
          }
          else
          {
            v24 = CWaterLevel::m_QuadsAndTrianglesInEachBlock[v12][v20];
            if ( v24 >> 14 == 3 )
            {
              for ( i = &CWaterLevel::m_QuadsAndTrianglesList[v24 & 0x3FFF]; ; ++i )
              {
                v26 = *i;
                if ( v26 >> 14 == 1 )
                {
                  if ( v18 < 0.0 )
                  {
                    pPenetrationPoint->x = v17;
                    pPenetrationPoint->y = v16;
                    v27 = v26 & 0x3FFF;
                    pPenetrationPoint->z = v19;
                    if ( v17 >= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v27].Index1].m_X
                      && v17 <= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v27].Index2].m_X
                      && v16 >= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v27].Index1].m_Y
                      && v16 <= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v27].Index3].m_Y )
                    {
                      goto LABEL_39;
                    }
                  }
                }
                else if ( !(v26 >> 14) )
                {
                  goto LABEL_36;
                }
              }
            }
            if ( v24 >> 14 == 1 && v18 < 0.0 )
            {
              pPenetrationPoint->x = v17;
              pPenetrationPoint->y = v16;
              pPenetrationPoint->z = v19;
              if ( v17 >= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v24 & 0x3FFF].Index1].m_X
                && v17 <= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v24 & 0x3FFF].Index2].m_X
                && v16 >= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v24 & 0x3FFF].Index1].m_Y
                && v16 <= (float)CWaterLevel::m_aVertices[CWaterLevel::m_aQuads[v24 & 0x3FFF].Index3].m_Y )
              {
LABEL_39:
                LODWORD(StartCoors.x) = 1;
                return StartCoors.x;
              }
            }
          }
LABEL_36:
          v20 = v22 + 1;
        }
        while ( v22 < v11 );
      }
    }
    while ( v12++ < v10 );
    StartCoors.x = 0.0;
  }
  return StartCoors.x;
}
// 5960F0: fragmented variable at 0:r3.4,4:^90.8 may be wrong
// 5960F0: variables would overlap: 0:r3.4,4:^90.8 and ^90.4
// 5960F0: variables would overlap: 0:r3.4,4:^90.8 and ^94.4

//----- (005964C0) --------------------------------------------------------
bool __fastcall IsOnScreen(const CVector *In, float Radius, bool ClipFarPlane)
{
  _BOOL4 v5; // r8
  float nearPlane; // s20
  float farPlane; // s16
  float z; // s18
  bool result; // r0
  CMatrix v10; // [sp+4h] [bp-7Ch] BYREF
  CVector v11; // [sp+4Ch] [bp-34h] BYREF

  v5 = ClipFarPlane;
  nearPlane = Scene.camera->nearPlane;
  farPlane = Scene.camera->farPlane;
  CMatrix::CMatrix(&v10, &Scene.camera->viewMatrix, 0);
  operator*(&v11, &v10, In);
  z = v11.z;
  CMatrix::~CMatrix(&v10);
  if ( z <= (float)(nearPlane - Radius) )
    return 0;
  result = 1;
  if ( z >= farPlane && v5 )
    return 0;
  return result;
}

//----- (00596540) --------------------------------------------------------
void CWaterLevel::PreRenderWater()
{
  float v0; // s2
  float v1; // s0
  float v2; // s6
  float v3; // s6
  char v4; // r0

  if ( CGame::CanSeeWaterFromCurrArea() == 1 )
  {
    emu_SetWaterTime((float)(CTimer::m_snTimeInMilliseconds & 0xFFFFF) * 0.00024414);
    CWaterLevel::ScanThroughBlocks();
    if ( (CTimer::m_FrameCounter & 0x1F) == 29 )
      CWaterLevel::FindNearestWaterAndItsFlow();
    v0 = CWaterLevel::m_CurrentDesiredFlowX;
    v1 = CTimer::ms_fTimeStep * 0.001;
    if ( fabsf(CWaterLevel::m_CurrentDesiredFlowX - CWaterLevel::m_CurrentFlowX) >= (float)(CTimer::ms_fTimeStep * 0.001) )
    {
      v2 = CTimer::ms_fTimeStep * 0.001;
      if ( (float)(CWaterLevel::m_CurrentDesiredFlowX - CWaterLevel::m_CurrentFlowX) < 0.0 )
        v2 = -v1;
      v0 = CWaterLevel::m_CurrentFlowX + v2;
    }
    v3 = CWaterLevel::m_CurrentDesiredFlowY;
    CWaterLevel::m_CurrentFlowX = v0;
    if ( fabsf(CWaterLevel::m_CurrentDesiredFlowY - CWaterLevel::m_CurrentFlowY) >= v1 )
    {
      if ( (float)(CWaterLevel::m_CurrentDesiredFlowY - CWaterLevel::m_CurrentFlowY) < 0.0 )
        v1 = -v1;
      v3 = CWaterLevel::m_CurrentFlowY + v1;
    }
    CWaterLevel::m_CurrentFlowY = v3;
    FindPlayerPed(-1);
    v4 = `guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos;
    __dmb(0xBu);
    if ( (v4 & 1) == 0 )
    {
      if ( _cxa_guard_acquire((__guard *)&`guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos) )
        sub_19B784((__guard *)&`guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos);
    }
  }
}
// A1DCAC: using guessed type char `guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos;

//----- (00596698) --------------------------------------------------------
void CWaterLevel::ScanThroughBlocks()
{
  float farPlane; // s0
  float x; // s2
  RwReal v2; // s8
  RwV2d_0 Points; // [sp+4h] [bp-6Ch] BYREF
  float v4; // [sp+Ch] [bp-64h]
  float v5; // [sp+10h] [bp-60h]
  float v6; // [sp+14h] [bp-5Ch]
  float v7; // [sp+18h] [bp-58h]
  float v8; // [sp+1Ch] [bp-54h]
  float v9; // [sp+20h] [bp-50h]
  float v10; // [sp+24h] [bp-4Ch]
  float v11; // [sp+28h] [bp-48h]
  RwV3d_0 pointsIn; // [sp+2Ch] [bp-44h] BYREF
  float v13; // [sp+38h] [bp-38h]
  RwReal v14; // [sp+3Ch] [bp-34h]
  float v15; // [sp+40h] [bp-30h]
  float v16; // [sp+44h] [bp-2Ch]
  float v17; // [sp+48h] [bp-28h]
  float v18; // [sp+4Ch] [bp-24h]
  RwReal v19; // [sp+50h] [bp-20h]
  float v20; // [sp+54h] [bp-1Ch]
  float v21; // [sp+58h] [bp-18h]
  float v22; // [sp+5Ch] [bp-14h]
  float v23; // [sp+60h] [bp-10h]
  int v24; // [sp+64h] [bp-Ch]

  CWaterLevel::m_NumBlocksOutsideWorldToBeRendered = 0;
  farPlane = TheCamera.m_pRwCamera->farPlane;
  x = TheCamera.m_pRwCamera->viewWindow.x;
  v2 = farPlane * TheCamera.m_pRwCamera->viewWindow.y;
  pointsIn.x = -(float)(farPlane * x);
  pointsIn.z = farPlane;
  v13 = farPlane * x;
  v15 = farPlane;
  v18 = farPlane;
  v16 = farPlane * x;
  v21 = farPlane;
  v19 = pointsIn.x;
  pointsIn.y = v2;
  v14 = v2;
  v17 = -v2;
  v20 = -v2;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  RwV3dTransformPoints(
    &pointsIn,
    &pointsIn,
    5,
    (const RwMatrix *)((char *)TheCamera.m_pRwCamera->object.object.parent + 16));
  Points.x = (float)(pointsIn.x / 500.0) + 6.0;
  Points.y = (float)(pointsIn.y / 500.0) + 6.0;
  v4 = (float)(v13 / 500.0) + 6.0;
  v5 = (float)(v14 / 500.0) + 6.0;
  v6 = (float)(v16 / 500.0) + 6.0;
  v7 = (float)(v17 / 500.0) + 6.0;
  v8 = (float)(v19 / 500.0) + 6.0;
  v9 = (float)(v20 / 500.0) + 6.0;
  v10 = (float)(v22 / 500.0) + 6.0;
  v11 = (float)(v23 / 500.0) + 6.0;
  CWorldScan::ScanWorld(&Points, 5, CWaterLevel::BlockHit);
}

//----- (005967E0) --------------------------------------------------------
void CWaterLevel::FindNearestWaterAndItsFlow()
{
  CSimpleTransform *p_tx; // r0
  float y; // s0
  float x; // s2
  Int32 v3; // r12
  float v4; // s12
  float m_Z; // s8
  float v6; // s10
  Int16 *p_Index3; // r1
  int v8; // lr
  float m_X; // s1
  float v10; // s14
  float v11; // s3
  float m_Y; // s3
  float v13; // s5
  float v14; // s7
  float v15; // s14
  Int16 *v16; // r4
  Int16 *v17; // r9
  float v18; // s12
  float v19; // s5
  float v20; // s7
  float v21; // s16
  float v22; // s15
  float v23; // s5
  float v24; // s11
  float v25; // s13
  float v26; // s9
  float v27; // s12
  float v28; // s1
  float v29; // s3

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  if ( y >= 3000.0 || (x = p_tx->m_translate.x, p_tx->m_translate.x <= -3000.0) || x >= 3000.0 || y <= -3000.0 )
  {
    TheCamera.DistanceToWater = 0.0;
    TheCamera.HeightOfNearestWater = 0.0;
    CWaterLevel::m_CurrentDesiredFlowX = 0.0;
    CWaterLevel::m_CurrentDesiredFlowY = 0.0;
  }
  else
  {
    if ( CWaterLevel::m_nNumOfWaterQuads < 1 )
    {
      v6 = 10000000.0;
      m_Z = 0.0;
    }
    else
    {
      v3 = 0;
      v4 = 10000000.0;
      m_Z = 0.0;
      v6 = 10000000.0;
      p_Index3 = &CWaterLevel::m_aQuads[0].Index3;
      do
      {
        v8 = *(p_Index3 - 2);
        m_X = (float)CWaterLevel::m_aVertices[v8].m_X;
        if ( x >= m_X )
        {
          v11 = (float)CWaterLevel::m_aVertices[*(p_Index3 - 1)].m_X;
          v10 = 0.0;
          if ( x > v11 )
            v10 = x - v11;
        }
        else
        {
          v10 = m_X - x;
        }
        m_Y = (float)CWaterLevel::m_aVertices[v8].m_Y;
        if ( y >= m_Y )
        {
          v14 = (float)CWaterLevel::m_aVertices[*p_Index3].m_Y;
          v13 = 0.0;
          if ( y > v14 )
            v13 = y - v14;
        }
        else
        {
          v13 = m_Y - y;
        }
        v15 = sqrtf((float)(v10 * v10) + (float)(v13 * v13));
        if ( v15 < v6
          && (CWaterLevel::m_aVertices[v8].m_P.m_BigWaves != 0.0
           || CWaterLevel::m_aVertices[v8].m_P.m_SmallWaves != 0.0
           || CWaterLevel::m_aVertices[*(p_Index3 - 1)].m_P.m_BigWaves != 0.0
           || CWaterLevel::m_aVertices[*(p_Index3 - 1)].m_P.m_SmallWaves != 0.0
           || CWaterLevel::m_aVertices[*p_Index3].m_P.m_BigWaves != 0.0
           || CWaterLevel::m_aVertices[*p_Index3].m_P.m_SmallWaves != 0.0
           || CWaterLevel::m_aVertices[p_Index3[1]].m_P.m_BigWaves != 0.0
           || CWaterLevel::m_aVertices[p_Index3[1]].m_P.m_SmallWaves != 0.0) )
        {
          v6 = v15;
          m_Z = CWaterLevel::m_aVertices[v8].m_P.m_Z;
        }
        if ( v15 < v4 )
        {
          v16 = p_Index3 - 1;
          v17 = p_Index3 + 1;
          v18 = y - (float)CWaterLevel::m_aVertices[p_Index3[1]].m_Y;
          v19 = y - (float)CWaterLevel::m_aVertices[*(p_Index3 - 1)].m_Y;
          v20 = x - (float)CWaterLevel::m_aVertices[*(p_Index3 - 1)].m_X;
          v21 = v18 * v18;
          v22 = v19 * v19;
          v23 = (float)((float)(x - m_X) * (float)(x - m_X)) + (float)((float)(y - m_Y) * (float)(y - m_Y));
          v24 = y - (float)CWaterLevel::m_aVertices[*p_Index3].m_Y;
          v25 = x - (float)CWaterLevel::m_aVertices[*p_Index3].m_X;
          v26 = x - (float)CWaterLevel::m_aVertices[p_Index3[1]].m_X;
          v27 = (float)(v20 * v20) + v22;
          v28 = (float)(v25 * v25) + (float)(v24 * v24);
          v29 = (float)(v26 * v26) + v21;
          if ( v23 >= v27 || v23 >= v29 )
          {
            if ( v28 < v29 )
              v17 = p_Index3;
            if ( v27 >= v29 )
              v16 = v17;
            if ( v27 >= v28 )
              v16 = v17;
            v8 = *v16;
          }
          CWaterLevel::m_CurrentDesiredFlowX = (float)CWaterLevel::m_aVertices[v8].m_P.m_FlowX * 0.015625;
          CWaterLevel::m_CurrentDesiredFlowY = (float)CWaterLevel::m_aVertices[(__int16)v8].m_P.m_FlowY * 0.015625;
          v4 = v15;
        }
        ++v3;
        p_Index3 += 5;
      }
      while ( v3 < CWaterLevel::m_nNumOfWaterQuads );
    }
    TheCamera.DistanceToWater = v6;
    TheCamera.HeightOfNearestWater = m_Z;
  }
}

//----- (00596CB8) --------------------------------------------------------
void CWaterLevel::HandleBeachToysStuff()
{
  char v0; // r0

  FindPlayerPed(-1);
  v0 = `guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos;
  __dmb(0xBu);
  if ( (v0 & 1) == 0 )
  {
    if ( _cxa_guard_acquire((__guard *)&`guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos) )
      sub_19B784((__guard *)&`guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos);
  }
}
// A1DCAC: using guessed type char `guard variable for'CWaterLevel::HandleBeachToysStuff(void)::prevBeachBallCreatedPos;

//----- (00596CFC) --------------------------------------------------------
void __fastcall CWaterLevel::RenderSeaBedSegment(
        Int32 BlockX,
        Int32 BlockY,
        float MinX,
        float MaxX,
        float MinY,
        float MaxY)
{
  float v6; // s3
  float v7; // s2
  Int32 v8; // r1
  float v9; // s5
  float v10; // s4
  RwIm3DVertex *v11; // r0
  RwImVertexIndex v12; // r5
  RwReal v13; // s8
  RwReal v14; // s2
  RwReal v15; // s10
  RwReal v16; // s4
  Int32 v17; // r0
  RwImVertexIndex *v18; // r2

  v6 = (float)BlockY + MaxY;
  v7 = (float)BlockY + MinY;
  v8 = TempBufferVerticesStored;
  v9 = (float)BlockX + MinX;
  v10 = (float)BlockX + MaxX;
  v11 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
  v12 = TempBufferVerticesStored + 3;
  v11->texCoords.v = MinY * 8.0;
  v13 = (float)(v6 * 500.0) + -3000.0;
  v14 = (float)(v7 * 500.0) + -3000.0;
  v11->texCoords.u = MinX * 8.0;
  v15 = (float)(v9 * 500.0) + -3000.0;
  v11->color = (RwRGBA_0)-11513776;
  v16 = (float)(v10 * 500.0) + -3000.0;
  v11->position.z = -70.0;
  v11[1].position.z = -70.0;
  v11[1].color = (RwRGBA_0)-11513776;
  v11->position.x = v15;
  v11->position.y = v14;
  v11[1].position.y = v13;
  v11[1].position.x = v15;
  v11[1].texCoords.u = MinX * 8.0;
  v11[1].texCoords.v = MaxY * 8.0;
  v11[2].position.x = v16;
  v11[2].position.y = v14;
  v11[2].position.z = -70.0;
  v11[2].color = (RwRGBA_0)-11513776;
  v11[3].texCoords.u = MaxX * 8.0;
  v11[3].texCoords.v = MaxY * 8.0;
  v11[2].texCoords.u = MaxX * 8.0;
  v11[2].texCoords.v = MinY * 8.0;
  v11[3].position.x = v16;
  v11[3].position.y = v13;
  v11[3].position.z = -70.0;
  v11[3].color = (RwRGBA_0)-11513776;
  v17 = TempBufferIndicesStored;
  v18 = &TempBufferRenderIndexList[TempBufferIndicesStored];
  *v18 = v8;
  v18[1] = v8 + 1;
  v18[2] = v8 + 2;
  v18[3] = v12;
  v18[4] = v8 + 1;
  TempBufferIndicesStored = v17 + 6;
  v18[5] = v8 + 2;
  TempBufferVerticesStored = v8 + 4;
}

//----- (00596E3C) --------------------------------------------------------
void __fastcall CWaterLevel::RenderDetailedSeaBedSegment(
        Int32 BlockX,
        Int32 BlockY,
        float MinX,
        float MaxX,
        float MinY,
        float MaxY)
{
  int v8; // r3
  float v9; // s4
  float v10; // s6
  int v11; // r4
  float v12; // s8
  float v13; // s10
  float v14; // s12
  int v15; // r3
  float v16; // s14
  int v17; // r6
  int v18; // r5
  __int16 v19; // r8
  RwImVertexIndex *v20; // r11
  RwReal *p_v; // r10
  int v22; // r2
  float v23; // s7
  float v24; // s9
  float v25; // s11
  float v26; // s13
  float v27; // s7
  float v28; // s9
  float v29; // s11
  float v30; // s13
  RwImVertexIndex v31; // r3
  bool v32; // cc
  RwImVertexIndex *v33; // r0
  RwImVertexIndex v34; // r1
  RwImVertexIndex v35; // r1
  float v36; // s15
  float v37; // s16
  float v38; // s15
  float v39; // s16
  float v40; // s18
  float v41; // s20
  RwReal v42; // s15
  RwReal v43; // s16
  RwReal v44; // s18
  RwReal v45; // s20
  int v46; // [sp+24h] [bp-4Ch]
  int v47; // [sp+28h] [bp-48h]
  Int32 v48; // [sp+2Ch] [bp-44h]
  int v49; // [sp+30h] [bp-40h]
  RwImVertexIndex *v50; // [sp+34h] [bp-3Ch]

  v8 = 1;
  v9 = MaxY - MinY;
  v10 = MaxX - MinX;
  v11 = (int)(float)((float)(MaxY - MinY) * 4.0);
  if ( v11 <= 1 )
    v11 = 1;
  if ( (int)(float)(v10 * 4.0) > 1 )
    v8 = (int)(float)(v10 * 4.0);
  v46 = v8;
  if ( v8 >= 1 )
  {
    v12 = (float)BlockY;
    v13 = (float)BlockX;
    v14 = (float)v11;
    v15 = 0;
    v16 = (float)v46;
    do
    {
      v17 = 0;
      v18 = 1;
      v49 = v15 + 1;
      v48 = TempBufferIndicesStored;
      v19 = TempBufferVerticesStored;
      v47 = 4 * v11 + TempBufferVerticesStored;
      v50 = &TempBufferRenderIndexList[TempBufferIndicesStored];
      v20 = &TempBufferRenderIndexList[5];
      p_v = &TempVertexBuffer.m_3d[TempBufferVerticesStored + 3].texCoords.v;
      v22 = TempBufferIndicesStored;
      v23 = (float)((float)(v10 * (float)v15) / v16) + MinX;
      v24 = (float)((float)(v10 * (float)(v15 + 1)) / v16) + MinX;
      v25 = v23 + v13;
      v26 = v24 + v13;
      v27 = v23 * 8.0;
      v28 = v24 * 8.0;
      v29 = (float)(v25 * 500.0) + -3000.0;
      v30 = (float)(v26 * 500.0) + -3000.0;
      do
      {
        v31 = v19 + v17;
        v32 = v18 < v11;
        v20[v22 - 5] = v19 + v17;
        v33 = &v50[3 * v17 / 2u];
        v34 = v19 + v17 + 3;
        *(p_v - 28) = v27;
        v17 += 4;
        v33[3] = v34;
        v35 = v31 + 1;
        v31 += 2;
        v33[2] = v31;
        v36 = v9 * (float)v18;
        v33[1] = v35;
        v37 = v9 * (float)(v18 - 1);
        v33[4] = v35;
        *(p_v - 35) = v29;
        *(p_v - 33) = -70.0;
        *(p_v - 29) = -2.769e38;
        ++v18;
        *(p_v - 19) = v27;
        *(p_v - 26) = v29;
        *(p_v - 24) = -70.0;
        *(p_v - 20) = -2.769e38;
        v20[v22] = v31;
        v20 += 6;
        v38 = (float)(v36 / v14) + MinY;
        *(p_v - 17) = v30;
        v39 = (float)(v37 / v14) + MinY;
        *(p_v - 15) = -70.0;
        *(p_v - 11) = -2.769e38;
        v40 = v38 + v12;
        v41 = v39 + v12;
        v42 = v38 * 8.0;
        v43 = v39 * 8.0;
        *(p_v - 18) = v42;
        *(p_v - 27) = v43;
        v44 = (float)(v40 * 500.0) + -3000.0;
        v45 = (float)(v41 * 500.0) + -3000.0;
        *(p_v - 25) = v44;
        *(p_v - 34) = v45;
        *(p_v - 16) = v45;
        *(p_v - 1) = v28;
        *p_v = v42;
        *(p_v - 10) = v28;
        *(p_v - 9) = v43;
        *(p_v - 8) = v30;
        *(p_v - 7) = v44;
        *(p_v - 6) = -70.0;
        *(p_v - 2) = -2.769e38;
        p_v += 36;
      }
      while ( v32 );
      v15 = v49;
      TempBufferIndicesStored = 6 * v11 + v48;
      TempBufferVerticesStored = v47;
    }
    while ( v49 < v46 );
  }
}
// 596F14: conditional instruction was optimized away because r4.4>=1

//----- (005970D0) --------------------------------------------------------
void CWaterLevel::RenderWater()
{
  signed int v0; // r8
  float v1; // s16
  CSimpleTransform *p_tx; // r4
  float v3; // s0
  float v4; // s18
  float v5; // r0
  float y; // s18
  float v7; // r4
  int32x2_t v8; // d8
  Int32 v9; // r11
  int v10; // r9
  Int32 v11; // r4
  Int32 v12; // r5
  CSimpleTransform *p_m_transform; // r1
  bool v14; // cc
  int32x2_t v15; // d16
  float32x2_t v16; // d16
  unsigned __int64 v17; // d0
  float v18; // s0
  int MaxY; // s29
  int v20; // r0
  int v21; // s4
  float v22; // s2
  int v23; // s27
  int *v24; // r1
  float v25; // s2
  float v26; // s4
  float v27; // s20
  float v28; // s18
  float v29; // s24
  float v30; // s26
  __int16 v31; // r5
  float v32; // r4
  float v33; // s30
  float v34; // r0
  float v35; // r4
  float v36; // r5
  float v37; // s28
  float v38; // r4
  int v39; // r0
  unsigned int v40; // lr
  signed int v41; // r4
  unsigned int v42; // r12
  Int32 v43; // r0
  CWaterTriangle *v44; // r5
  CWaterVertex *v45; // r1
  int Index2; // r9
  int Index3; // r5
  CWaterVertex *v48; // r6
  __int64 v49; // kr00_8
  Int32 v50; // r0
  CWaterVertex *v51; // r6
  CWaterVertex *v52; // r6
  __int64 v53; // kr08_8
  CWaterVertex *v54; // r0
  Int32 v55; // r0
  Int32 v56; // r10
  unsigned int v57; // r1
  unsigned int v58; // r2
  bool v59; // cf
  unsigned int v60; // r5
  CRenPar MinY; // [sp+0h] [bp-D0h]
  CRenPar MinYa; // [sp+0h] [bp-D0h]
  CRenPar P2; // [sp+10h] [bp-C0h]
  CRenPar P2a; // [sp+10h] [bp-C0h]
  CRenPar P2b; // [sp+10h] [bp-C0h]
  CRenPar X3; // [sp+20h] [bp-B0h]
  CRenPar P3_8; // [sp+30h] [bp-A0h]
  Int32 v68; // [sp+54h] [bp-7Ch]
  float m_SmallWaves; // [sp+58h] [bp-78h]
  float m_BigWaves; // [sp+5Ch] [bp-74h]
  float P1; // [sp+60h] [bp-70h]
  Int32 P1_8; // [sp+68h] [bp-68h]

  if ( CGame::CanSeeWaterFromCurrArea() == 1 )
  {
    v1 = (float)DETAILEDWATERDIST;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v3 = p_tx->m_translate.x + v1;
    v4 = floorf((float)(p_tx->m_translate.x - v1) * 0.5);
    v5 = ceilf(v3 * 0.5);
    CameraRangeMinX = 2 * (int)v4;
    CameraRangeMaxX = 2 * (int)v5;
    y = p_tx->m_translate.y;
    v7 = floorf((float)(y - v1) * 0.5);
    CameraRangeMaxY = 2 * (int)ceilf((float)(y + v1) * 0.5);
    CameraRangeMinY = 2 * (int)v7;
    DefinedState();
    TempBufferVerticesStored = 0;
    TempBufferIndicesStored = 0;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpSeaBedTex->raster);
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    emu_SetWater(1u);
    if ( CWaterLevel::m_NumBlocksOutsideWorldToBeRendered >= 1 )
    {
      v8.n64_u64[0] = vneg_s32((int32x2_t)0x1000000010LL).n64_u64[0];
      v9 = 0;
      v0 = (signed int)&CWaterLevel::m_NumBlocksOutsideWorldToBeRendered;
      do
      {
        v10 = 0;
        v11 = CWaterLevel::m_BlocksToBeRenderedOutsideWorldY[v9];
        v12 = CWaterLevel::m_BlocksToBeRenderedOutsideWorldX[v9];
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        v14 = v11 <= 11;
        if ( v11 <= 11 )
          v14 = v12 <= 11;
        v15.n64_u32[1] = CWaterLevel::m_BlocksToBeRenderedOutsideWorldY[v9];
        v15.n64_u32[0] = CWaterLevel::m_BlocksToBeRenderedOutsideWorldX[v9];
        v16.n64_u64[0] = vsub_f32(
                           *(float32x2_t *)&p_m_transform->m_translate.x,
                           vadd_f32(
                             vmul_f32(
                               vadd_f32(
                                 vcvt_f32_s32(vshl_s32(v8, vshl_n_s32(v15, 0x10u))),
                                 (float32x2_t)0x3F0000003F000000LL),
                               (float32x2_t)0x43FA000043FA0000LL),
                             (float32x2_t)0xC53B8000C53B8000LL)).n64_u64[0];
        v17 = vmul_f32(v16, v16).n64_u64[0];
        v18 = sqrtf(*(float *)&v17 + *((float *)&v17 + 1));
        if ( !v14 )
        {
          v21 = 0;
          v22 = 1.0;
          v23 = 0;
          goto LABEL_25;
        }
        v21 = 0;
        v22 = 1.0;
        v23 = 0;
        MaxY = 1.0;
        if ( (v11 | v12) < 0 )
          goto LABEL_26;
        if ( (_WORD)v12 )
        {
          if ( (unsigned __int16)v12 == 11 )
          {
            v20 = 1;
            v22 = 1.0;
            v21 = 1064682127;
            if ( !CWaterLevel::m_BlocksToBeRenderedOutsideWorldY[v9] )
              goto LABEL_16;
            goto LABEL_21;
          }
          v22 = 1.0;
          v20 = 0;
        }
        else
        {
          v20 = 1;
          v22 = 0.04;
        }
        v21 = 0;
        if ( !CWaterLevel::m_BlocksToBeRenderedOutsideWorldY[v9] )
        {
LABEL_16:
          MaxY = 1025758986;
          v23 = 0;
          if ( v20 )
          {
            v10 = 1;
            v23 = 0;
            MaxY = 1025758986;
            goto LABEL_26;
          }
LABEL_32:
          if ( v18 >= 600.0 )
            goto LABEL_34;
LABEL_33:
          CWaterLevel::RenderDetailedSeaBedSegment(v12, v11, 0.0, 1.0, *(float *)&v23, *(float *)&MaxY);
          goto LABEL_35;
        }
LABEL_21:
        v24 = &dword_597B1C;
        v10 = 0;
        if ( v11 == 11 )
        {
          v24 = &dword_597B20;
          v10 = 1;
        }
        if ( v20 )
        {
          v23 = *v24;
LABEL_25:
          MaxY = 1.0;
LABEL_26:
          if ( v18 >= 600.0 )
          {
            CWaterLevel::RenderSeaBedSegment(v12, v11, *(float *)&v21, v22, 0.0, 1.0);
            if ( !v10 )
              goto LABEL_35;
LABEL_34:
            CWaterLevel::RenderSeaBedSegment(v12, v11, 0.0, 1.0, *(float *)&v23, *(float *)&MaxY);
            goto LABEL_35;
          }
          CWaterLevel::RenderDetailedSeaBedSegment(v12, v11, *(float *)&v21, v22, 0.0, 1.0);
          if ( !v10 )
            goto LABEL_35;
          goto LABEL_33;
        }
        MaxY = 1.0;
        v23 = 1064682127;
        if ( v11 == 11 )
          goto LABEL_32;
LABEL_35:
        ++v9;
      }
      while ( v9 < CWaterLevel::m_NumBlocksOutsideWorldToBeRendered );
    }
    if ( TempBufferVerticesStored )
    {
      LittleTest();
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
    }
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
    v25 = (float)(CTimer::ms_fTimeStep * 0.04) * CWaterLevel::m_CurrentFlowX;
    v26 = (float)(CTimer::ms_fTimeStep * 0.04) * CWaterLevel::m_CurrentFlowY;
    v27 = CurrentTextureShiftU + (float)(v25 * 0.08);
    v28 = CurrentTextureShiftV + (float)(v26 * 0.08);
    CurrentTextureShiftU = v27;
    CurrentTextureShiftV = v28;
    if ( v27 > 1.0 )
    {
      v27 = v27 + -1.0;
      CurrentTextureShiftU = v27;
    }
    if ( v28 > 1.0 )
    {
      v28 = v28 + -1.0;
      CurrentTextureShiftV = v28;
    }
    v30 = CurrentTextureShiftSecondV + (float)(v26 * 0.04);
    CurrentTextureShiftSecondU = CurrentTextureShiftSecondU + (float)(v25 * 0.04);
    v29 = CurrentTextureShiftSecondU;
    CurrentTextureShiftSecondV = v30;
    if ( CurrentTextureShiftSecondU > 1.0 )
    {
      v29 = CurrentTextureShiftSecondU + -1.0;
      CurrentTextureShiftSecondU = CurrentTextureShiftSecondU + -1.0;
    }
    if ( v30 > 1.0 )
    {
      v30 = v30 + -1.0;
      CurrentTextureShiftSecondV = v30;
    }
    v31 = CTimer::m_snTimeInMilliseconds;
    v32 = (float)(CTimer::m_snTimeInMilliseconds & 0xFFF) * 0.001534;
    v33 = sinf(v32);
    v34 = cosf(v32);
    v35 = (float)(v31 & 0x1FFF) * 0.00076699;
    v36 = v34;
    v37 = cosf(v35);
    TextureShiftSecondU = v29;
    TextureShiftSecondV = v30 + (float)((float)(v37 * 0.04) * 0.6);
    TextureShiftU = v27 + (float)((float)(v33 * 0.08) * CWeather::Wavyness);
    TextureShiftV = v28 + (float)((float)(v36 * 0.08) * CWeather::Wavyness);
    TextureShiftHighLightU = (float)((float)((float)rand() * 4.6566e-10) * 0.01) + 0.0;
    v38 = sinf(v35);
    v39 = rand();
    v40 = (unsigned int)&TextureShiftHighLightV;
    TextureShiftHighLightU = TextureShiftHighLightU + (float)(v38 * 0.1);
    WaterColor._anon_0._anon_0.green = (unsigned int)CTimeCycle::m_CurrentColours.m_fWaterGreen;
    TextureShiftHighLightV = (float)(v37 * 0.1) + (float)((float)((float)((float)v39 * 4.6566e-10) * 0.01) + 0.0);
    WaterColor._anon_0._anon_0.red = (unsigned int)CTimeCycle::m_CurrentColours.m_fWaterRed;
    WaterColor._anon_0._anon_0.blue = (unsigned int)CTimeCycle::m_CurrentColours.m_fWaterBlue;
    v41 = 0;
    TempBufferIndicesStored = 0;
    WaterColorDebug = WaterColor;
    TempBufferVerticesStored = 0;
    AlphaMain = (int)CTimeCycle::m_CurrentColours.m_fWaterAlpha;
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpWaterTex->raster);
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    v43 = CWaterLevel::m_nNumOfWaterTriangles;
    if ( CWaterLevel::m_nNumOfWaterTriangles >= 1 )
    {
      v41 = 0;
      do
      {
        v0 = (signed int)&CWaterLevel::m_aTriangles[v41];
        if ( *(unsigned __int8 *)(v0 + 6) << 31 )
        {
          v44 = &CWaterLevel::m_aTriangles[v41];
          v45 = &CWaterLevel::m_aVertices[v44->Index1];
          Index2 = v44->Index2;
          Index3 = v44->Index3;
          v48 = &CWaterLevel::m_aVertices[Index2];
          v49 = *(_QWORD *)&v48->m_P.m_Z;
          v40 = HIDWORD(v49);
          *(_QWORD *)&P2.m_Z = v49;
          *(_QWORD *)&P2.m_SmallWaves = *(_QWORD *)&v48->m_P.m_SmallWaves;
          CWaterLevel::RenderWaterTriangle(
            CWaterLevel::m_aVertices[CWaterLevel::m_aTriangles[v41].Index1].m_X,
            v45->m_Y,
            v45->m_P,
            v48->m_X,
            v48->m_Y,
            P2,
            CWaterLevel::m_aVertices[Index3].m_X,
            CWaterLevel::m_aVertices[Index3].m_Y,
            CWaterLevel::m_aVertices[Index3].m_P);
          *(_BYTE *)(v0 + 6) &= ~1u;
          v43 = CWaterLevel::m_nNumOfWaterTriangles;
        }
        ++v41;
      }
      while ( v41 < v43 );
    }
    v50 = CWaterLevel::m_nNumOfWaterQuads;
    if ( CWaterLevel::m_nNumOfWaterQuads >= 1 )
    {
      v0 = 0;
      v41 = (signed int)CWaterLevel::m_aQuads + 8;
      do
      {
        if ( *(unsigned __int8 *)v41 << 31 )
        {
          v51 = &CWaterLevel::m_aVertices[*(__int16 *)(v41 - 8)];
          P1_8 = v51->m_Y;
          P1 = v51->m_P.m_Z;
          m_BigWaves = v51->m_P.m_BigWaves;
          m_SmallWaves = v51->m_P.m_SmallWaves;
          v68 = *(_DWORD *)&v51->m_P.m_FlowX;
          v52 = &CWaterLevel::m_aVertices[*(__int16 *)(v41 - 6)];
          v53 = *(_QWORD *)&v52->m_P.m_Z;
          v40 = HIDWORD(v53);
          v54 = &CWaterLevel::m_aVertices[*(__int16 *)(v41 - 4)];
          *(_QWORD *)&MinY.m_Z = __PAIR64__(LODWORD(m_BigWaves), LODWORD(P1));
          *(_QWORD *)&MinY.m_SmallWaves = __PAIR64__(v68, LODWORD(m_SmallWaves));
          *(_QWORD *)&P2a.m_Z = v53;
          *(_QWORD *)&P2a.m_SmallWaves = *(_QWORD *)&v52->m_P.m_SmallWaves;
          CWaterLevel::RenderWaterRectangle(
            CWaterLevel::m_aVertices[*(__int16 *)(v41 - 8)].m_X,
            v52->m_X,
            P1_8,
            v54->m_Y,
            MinY,
            P2a,
            v54->m_P,
            CWaterLevel::m_aVertices[*(__int16 *)(v41 - 2)].m_P);
          *(_BYTE *)v41 &= ~1u;
          v50 = CWaterLevel::m_nNumOfWaterQuads;
        }
        ++v0;
        v41 += 10;
      }
      while ( v0 < v50 );
    }
    v55 = CWaterLevel::m_NumBlocksOutsideWorldToBeRendered;
    if ( CWaterLevel::m_NumBlocksOutsideWorldToBeRendered >= 1 )
    {
      v56 = 0;
      do
      {
        v57 = CWaterLevel::m_BlocksToBeRenderedOutsideWorldX[v56];
        v58 = (unsigned __int16)CWaterLevel::m_BlocksToBeRenderedOutsideWorldY[v56];
        v59 = v57 >= 0xB;
        if ( v57 <= 0xB )
          v59 = v58 >= 0xC;
        if ( v59 )
        {
          v0 &= 0xFFFF0000;
          v40 &= 0xFFFF0000;
          P3_8.m_SmallWaves = 0.0;
          *(_DWORD *)&P3_8.m_FlowX = v0;
          v60 = v42 & 0xFFFF0000;
          v41 &= 0xFFFF0000;
          *(_QWORD *)&P3_8.m_Z = 0x3F80000000000000LL;
          X3.m_SmallWaves = 0.0;
          *(_DWORD *)&X3.m_FlowX = v40;
          *(_QWORD *)&X3.m_Z = 0x3F80000000000000LL;
          *(_DWORD *)&P2b.m_FlowX = v42 & 0xFFFF0000;
          P2b.m_SmallWaves = 0.0;
          *(_QWORD *)&P2b.m_Z = 0x3F80000000000000LL;
          *(_DWORD *)&MinYa.m_FlowX = v41;
          MinYa.m_SmallWaves = 0.0;
          *(_QWORD *)&MinYa.m_Z = 0x3F80000000000000LL;
          CWaterLevel::RenderWaterRectangle(
            (int)(float)((float)(500 * (__int16)v57) + -3000.0),
            (int)(float)((float)(500 * (__int16)v57 + 500) + -3000.0),
            (int)(float)((float)(500 * (__int16)v58) + -3000.0),
            (int)(float)((float)(500 * (__int16)v58 + 500) + -3000.0),
            MinYa,
            P2b,
            X3,
            P3_8);
          v55 = CWaterLevel::m_NumBlocksOutsideWorldToBeRendered;
          v42 = v60;
        }
        ++v56;
      }
      while ( v56 < v55 );
    }
    if ( TempBufferVerticesStored )
    {
      LittleTest();
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
    }
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
    emu_SetWater(0);
    CWaterLevel::RenderBoatWakes();
    sub_18E03C();
  }
}
// 5979B6: variable 'v0' is possibly undefined
// 5979D8: variable 'v42' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 597B1C: using guessed type int dword_597B1C;
// 597B20: using guessed type int;
// 67736C: using guessed type float *TextureShiftU_ptr;
// 677608: using guessed type float *TextureShiftSecondU_ptr;
// 678B98: using guessed type float TextureShiftV_ptr;
// 678CE4: using guessed type float *TextureShiftSecondV_ptr;

//----- (00597C00) --------------------------------------------------------
void CWaterLevel::SetCameraRange()
{
  float v0; // s16
  CSimpleTransform *p_tx; // r4
  float v2; // s0
  float v3; // s18
  float v4; // r0
  float y; // s18
  float v6; // r4

  v0 = (float)DETAILEDWATERDIST;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v2 = p_tx->m_translate.x + v0;
  v3 = floorf((float)(p_tx->m_translate.x - v0) * 0.5);
  v4 = ceilf(v2 * 0.5);
  CameraRangeMinX = 2 * (int)v3;
  CameraRangeMaxX = 2 * (int)v4;
  y = p_tx->m_translate.y;
  v6 = floorf((float)(y - v0) * 0.5);
  CameraRangeMaxY = 2 * (int)ceilf((float)(y + v0) * 0.5);
  CameraRangeMinY = 2 * (int)v6;
}

//----- (00597CF0) --------------------------------------------------------
void CWaterLevel::RenderAndEmptyRenderBuffer()
{
  if ( TempBufferVerticesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
  }
  TempBufferIndicesStored = 0;
  TempBufferVerticesStored = 0;
}

//----- (00597D64) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::RenderWaterTriangle(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3)
{
  int v11; // r0
  Int32 v12; // r8
  Int32 v13; // lr
  int v14; // r3
  int v15; // r3
  int v16; // r3
  float m_Z; // r3
  int v18; // [sp+0h] [bp-60h]
  float m_BigWaves; // [sp+0h] [bp-60h]
  float v20; // [sp+0h] [bp-60h]
  float v21; // [sp+0h] [bp-60h]
  float v22; // [sp+0h] [bp-60h]
  float v23; // [sp+0h] [bp-60h]
  float v24; // [sp+4h] [bp-5Ch]
  float m_SmallWaves; // [sp+4h] [bp-5Ch]
  int v26; // [sp+4h] [bp-5Ch]
  float v27; // [sp+4h] [bp-5Ch]
  float v28; // [sp+4h] [bp-5Ch]
  int v29; // [sp+4h] [bp-5Ch]
  Int32 v30; // [sp+8h] [bp-58h]
  Int32 v31; // [sp+8h] [bp-58h]
  Int32 v32; // [sp+8h] [bp-58h]
  Int32 v33; // [sp+8h] [bp-58h]
  Int32 v34; // [sp+Ch] [bp-54h]
  Int32 v35; // [sp+10h] [bp-50h]
  CRenPar v36; // [sp+14h] [bp-4Ch]
  Int32 v37; // [sp+24h] [bp-3Ch]
  Int32 v38; // [sp+28h] [bp-38h]
  CRenPar v39; // [sp+2Ch] [bp-34h]

  v11 = CameraRangeMaxX;
  if ( CameraRangeMaxX <= X1 || CameraRangeMinX >= X2 )
  {
    if ( X2 - X1 >= 169 && bSplitBigPolys )
    {
      m_BigWaves = P1.m_BigWaves;
      P1.m_BigWaves = P1.m_Z;
      m_SmallWaves = P1.m_SmallWaves;
      v31 = *(_DWORD *)&P1.m_FlowX;
      CWaterLevel::SplitWaterTriangleAlongXLine(
        (X2 + X1) / 2,
        X1,
        Y1,
        *(CRenPar *)&P1.m_BigWaves,
        X2,
        v35,
        P2,
        X3,
        Y3,
        P3);
      return;
    }
    goto LABEL_17;
  }
  v12 = Y3;
  if ( Y1 < Y3 )
    v12 = Y1;
  v13 = Y1;
  if ( Y1 < Y3 )
    v13 = Y3;
  if ( v12 >= CameraRangeMaxY || v13 <= CameraRangeMinY )
  {
    if ( X2 - X1 >= 169 && bSplitBigPolys )
    {
      v38 = Y3;
      v39 = P3;
      v37 = X3;
      v36 = P2;
      v34 = X2;
      v18 = v15;
      v24 = P1.m_SmallWaves;
      v30 = *(_DWORD *)&P1.m_FlowX;
      v11 = (X2 + X1) / 2;
      goto LABEL_21;
    }
LABEL_17:
    v20 = P1.m_SmallWaves;
    v26 = *(_DWORD *)&P1.m_FlowX;
    CWaterLevel::RenderFlatWaterTriangle_OneLayer(X1, Y1, P1, X2, Y2, P2, X3, Y3, P3, 0);
    return;
  }
  if ( CameraRangeMaxX < X2 )
  {
    v38 = Y3;
    v39 = P3;
    v37 = X3;
    v36 = P2;
    v34 = X2;
    v18 = v14;
    v24 = P1.m_SmallWaves;
    v30 = *(_DWORD *)&P1.m_FlowX;
LABEL_21:
    m_Z = P1.m_Z;
    CWaterLevel::SplitWaterTriangleAlongXLine(v11, X1, Y1, *(CRenPar *)(&v18 - 1), v34, v35, v36, v37, v38, v39);
    return;
  }
  if ( CameraRangeMinX > X1 )
  {
    v38 = Y3;
    v39 = P3;
    v37 = X3;
    v36 = P2;
    v34 = X2;
    v18 = v16;
    v24 = P1.m_SmallWaves;
    v30 = *(_DWORD *)&P1.m_FlowX;
    v11 = CameraRangeMinX;
    goto LABEL_21;
  }
  if ( v13 <= CameraRangeMaxY )
  {
    if ( v12 < CameraRangeMinY )
    {
      v22 = P1.m_BigWaves;
      P1.m_BigWaves = P1.m_Z;
      v28 = P1.m_SmallWaves;
      v33 = *(_DWORD *)&P1.m_FlowX;
      CWaterLevel::SplitWaterTriangleAlongYLine(
        CameraRangeMinY,
        X1,
        Y1,
        *(CRenPar *)&P1.m_BigWaves,
        X2,
        Y2,
        P2,
        X3,
        Y3,
        P3);
    }
    else
    {
      v23 = P1.m_SmallWaves;
      v29 = *(_DWORD *)&P1.m_FlowX;
      CWaterLevel::RenderHighDetailWaterTriangle(X1, Y1, P1, X2, Y2, P2, X3, Y3, P3);
    }
  }
  else
  {
    v21 = P1.m_BigWaves;
    v27 = P1.m_SmallWaves;
    P1.m_BigWaves = P1.m_Z;
    v32 = *(_DWORD *)&P1.m_FlowX;
    CWaterLevel::SplitWaterTriangleAlongYLine(
      CameraRangeMaxY,
      X1,
      Y1,
      *(CRenPar *)&P1.m_BigWaves,
      X2,
      Y2,
      P2,
      X3,
      Y3,
      P3);
  }
}
// 597D64: fragmented variable at 0:r2.8,8:^68.8 may be wrong
// 597D64: variables would overlap: 0:r2.8,8:^68.8 and ^68.4
// 597D64: variables would overlap: 0:r2.8,8:^68.8 and ^6C.4
// 597D64: fragmented variable at ^0.4 may be wrong
// 597D64: fragmented variable at ^4.4 may be wrong
// 597D64: fragmented variable at ^8.4 may be wrong

//----- (00598038) --------------------------------------------------------
void __fastcall CWaterLevel::RenderWaterRectangle(
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4)
{
  Int32 v10; // r5
  Int32 v11; // r9
  CRenPar v12; // [sp+30h] [bp-68h]
  CRenPar v13; // [sp+30h] [bp-68h]
  CRenPar v14; // [sp+34h] [bp-64h]
  CRenPar v15; // [sp+34h] [bp-64h]
  CRenPar v16; // [sp+34h] [bp-64h]
  CRenPar v17; // [sp+34h] [bp-64h]
  __int64 v18; // [sp+60h] [bp-38h]

  v10 = Y2;
  v11 = Y1;
  HIDWORD(v18) = LODWORD(P4.m_BigWaves);
  if ( Y1 < Y2 )
  {
    v10 = Y1;
    v11 = Y2;
  }
  *(float *)&v18 = P4.m_Z;
  if ( CameraRangeMaxX <= MinX || CameraRangeMinX >= MaxX || v10 >= CameraRangeMaxY || v11 <= CameraRangeMinY )
  {
    *(_QWORD *)&v12.m_Z = v18;
    *(_QWORD *)&v12.m_SmallWaves = *(_QWORD *)&P4.m_SmallWaves;
    CWaterLevel::RenderFlatWaterRectangle(MinX, MaxX, Y1, Y2, P1, P2, P3, v12);
    CWaterLevel::SetUpWaterFog(MinX, v10, MaxX, v11);
  }
  else if ( CameraRangeMaxX >= MaxX )
  {
    if ( CameraRangeMinX <= MinX )
    {
      if ( v10 >= CameraRangeMinY )
      {
        if ( v11 <= CameraRangeMaxY )
        {
          *(_QWORD *)&v13.m_Z = v18;
          *(_QWORD *)&v13.m_SmallWaves = *(_QWORD *)&P4.m_SmallWaves;
          CWaterLevel::RenderHighDetailWaterRectangle(MinX, MaxX, Y1, Y2, P1, P2, P3, v13);
        }
        else
        {
          *(_QWORD *)&v17.m_Z = v18;
          *(_QWORD *)&v17.m_SmallWaves = *(_QWORD *)&P4.m_SmallWaves;
          CWaterLevel::SplitWaterRectangleAlongYLine(CameraRangeMaxY, MinX, MaxX, Y1, Y2, P1, P2, P3, v17);
        }
      }
      else
      {
        *(_QWORD *)&v16.m_Z = v18;
        *(_QWORD *)&v16.m_SmallWaves = *(_QWORD *)&P4.m_SmallWaves;
        CWaterLevel::SplitWaterRectangleAlongYLine(CameraRangeMinY, MinX, MaxX, Y1, Y2, P1, P2, P3, v16);
      }
    }
    else
    {
      *(_QWORD *)&v15.m_Z = v18;
      *(_QWORD *)&v15.m_SmallWaves = *(_QWORD *)&P4.m_SmallWaves;
      CWaterLevel::SplitWaterRectangleAlongXLine(CameraRangeMinX, MinX, MaxX, Y1, Y2, P1, P2, P3, v15);
    }
  }
  else
  {
    *(_QWORD *)&v14.m_Z = v18;
    *(_QWORD *)&v14.m_SmallWaves = *(_QWORD *)&P4.m_SmallWaves;
    CWaterLevel::SplitWaterRectangleAlongXLine(CameraRangeMaxX, MinX, MaxX, Y1, Y2, P1, P2, P3, v14);
  }
}

//----- (005982F0) --------------------------------------------------------
void CWaterLevel::RenderBoatWakes()
{
  int v0; // r6
  CBoat *v1; // r5
  CMatrix *m_pMat; // r0
  float xy; // s20
  float yy; // s25
  CColModel *ColModel; // r0
  float v6; // s2
  float x; // s8
  float v8; // s31
  int m_nModelIndex; // r1
  float v10; // s0
  CSimpleTransform *p_tx; // r2
  CMatrix *v12; // r3
  float32x2_t *p_m_transform; // r0
  float32x2_t v14; // d16
  unsigned __int64 v15; // d4
  float v16; // s22
  unsigned int m_nNumWakeCoords; // r0
  int v18; // r2
  __int16 v19; // r8
  float v20; // s0
  float *v21; // r1
  float v22; // s2
  float v23; // s6
  float v24; // s4
  float v25; // s8
  float v26; // s17
  float v27; // s19
  float v28; // s10
  float v29; // s10
  _BOOL4 v30; // r1
  float v31; // s10
  float v32; // s12
  float v33; // s29
  float v34; // s14
  float v35; // s0
  float v36; // s9
  float v37; // s8
  float v38; // s0
  float v39; // s20
  float *v40; // [sp+0h] [bp-B0h]
  float *v41; // [sp+4h] [bp-ACh]
  float fWakeZ; // [sp+24h] [bp-8Ch] BYREF
  float fAlphaB; // [sp+28h] [bp-88h] BYREF
  float fAlphaA; // [sp+2Ch] [bp-84h] BYREF
  CVector2D v45; // [sp+30h] [bp-80h] BYREF
  CVector2D v46; // [sp+38h] [bp-78h] BYREF
  CVector2D vecB; // [sp+40h] [bp-70h] BYREF
  CVector2D vecA; // [sp+48h] [bp-68h] BYREF

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpWaterWakeTex->raster);
  CBoat::FillBoatList();
  fWakeZ = -0.03;
  LOWORD(v0) = 0;
  do
  {
    v1 = CBoat::apFrameWakeGeneratingBoats[(__int16)v0];
    if ( !v1 )
      break;
    m_pMat = v1->m_pMat;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    ColModel = CEntity::GetColModel(CBoat::apFrameWakeGeneratingBoats[(__int16)v0]);
    v6 = v1->m_fWakePtCounters[0];
    x = ColModel->m_boxBound.m_vecMax.x;
    v8 = x * 0.65;
    m_nModelIndex = (unsigned __int16)v1->m_nModelIndex;
    v10 = (float)v1->m_fWakeBoatSpeed[0] * 0.01;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    fAlphaA = (float)(v10 + 0.15) * 0.0;
    v12 = v1->m_pMat;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    p_m_transform = (float32x2_t *)&v12->tx;
    if ( !v12 )
      p_m_transform = (float32x2_t *)&v1->m_transform;
    if ( m_nModelIndex == 460 )
      v8 = (float)(x * 0.65) * 0.4;
    v14.n64_u64[0] = vsub_f32((float32x2_t)p_m_transform->n64_u64[0], *(float32x2_t *)&p_tx->m_translate.x).n64_u64[0];
    v15 = vmul_f32(v14, v14).n64_u64[0];
    v16 = sqrtf((float)(*(float *)&v15 + *((float *)&v15 + 1)) + 0.0);
    if ( v16 > 50.0 )
      fAlphaA = (float)((float)(v10 + 0.15) * 0.0) * (float)((float)(80.0 - v16) / 30.0);
    m_nNumWakeCoords = v1->m_nNumWakeCoords;
    if ( m_nNumWakeCoords >= 2 )
    {
      v18 = 1;
      v19 = 1;
      v20 = v8
          + (float)((float)((float)(v10 * 4.0) + 0.5)
                  * (float)(v8 * (float)((float)(CBoat::WAKE_LIFETIME - v6) / CBoat::WAKE_LIFETIME)));
      do
      {
        v21 = (float *)((char *)v1 + 8 * v18);
        v22 = v21[407];
        v23 = v21[406];
        v24 = v21[408];
        v25 = v21[405];
        v26 = v23 - v24;
        v27 = v25 - v22;
        v28 = (float)(v27 * v27) + (float)(v26 * v26);
        if ( v28 <= 9.0 )
        {
          v30 = 1;
        }
        else
        {
          v29 = sqrtf(v28);
          v26 = v26 * (float)(1.0 / v29);
          v27 = v27 * (float)(1.0 / v29);
          v30 = v29 <= 13.0;
        }
        v31 = (float)v1->m_fWakeBoatSpeed[v18] * 0.01;
        v32 = (float)v19;
        v33 = v8
            + (float)((float)((float)(v31 * 4.0) + 0.5)
                    * (float)(v8
                            * (float)((float)(CBoat::WAKE_LIFETIME - v1->m_fWakePtCounters[v18]) / CBoat::WAKE_LIFETIME)));
        v34 = v20 * xy;
        v35 = v20 * yy;
        v36 = v25 - v35;
        v37 = v35 + v25;
        v38 = (float)(1.0 - (float)(v32 / (float)(unsigned __int16)m_nNumWakeCoords)) * 160.0;
        vecA.y = v34 + v23;
        vecB.y = v23 - v34;
        v46.y = v24 - (float)(v27 * v33);
        vecA.x = v36;
        v45.y = (float)(v27 * v33) + v24;
        vecB.x = v37;
        v46.x = (float)(v26 * v33) + v22;
        v45.x = v22 - (float)(v26 * v33);
        if ( v19 <= 2 )
          v38 = (float)(v32 / 3.0) * v38;
        v39 = v38 * (float)(v31 + 0.15);
        if ( v16 > 50.0 )
          v39 = (float)((float)(80.0 - v16) / 30.0) * v39;
        fAlphaB = v39;
        if ( v30 )
        {
          CWaterLevel::RenderWakeSegment(&vecA, &vecB, &v46, &v45, v40, v41, &fAlphaA, &fAlphaB, &fWakeZ);
          LOWORD(m_nNumWakeCoords) = v1->m_nNumWakeCoords;
        }
        fAlphaA = v39;
        yy = v26;
        xy = v27;
        ++v19;
        v20 = v33;
        v18 = v19;
      }
      while ( v19 < (int)(unsigned __int16)m_nNumWakeCoords );
    }
    v0 = (__int16)(v0 + 1);
  }
  while ( v0 < 4 );
  if ( TempBufferVerticesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
  }
  TempBufferIndicesStored = 0;
  TempBufferVerticesStored = 0;
}
// 5985CA: variable 'v40' is possibly undefined
// 5985CA: variable 'v41' is possibly undefined

//----- (005986AC) --------------------------------------------------------
void __fastcall CWaterLevel::BlockHit(Int32 BlockX, Int32 BlockY)
{
  bool v3; // cc
  char v5; // r2
  Int32 v6; // r0

  v3 = BlockY <= 11;
  if ( BlockY <= 11 )
    v3 = BlockX <= 11;
  if ( v3 && (BlockY | BlockX) >= 0 )
  {
    v5 = CGame::currArea;
    if ( CGame::currArea )
      v5 = 1;
    CWaterLevel::MarkQuadsAndPolysToBeRendered(BlockX, BlockY, v5);
  }
  if ( (unsigned int)(BlockY - 1) > 9 || (unsigned int)(BlockX - 1) > 9 )
  {
    v6 = CWaterLevel::m_NumBlocksOutsideWorldToBeRendered;
    if ( CWaterLevel::m_NumBlocksOutsideWorldToBeRendered <= 69 )
    {
      CWaterLevel::m_BlocksToBeRenderedOutsideWorldX[CWaterLevel::m_NumBlocksOutsideWorldToBeRendered] = BlockX;
      CWaterLevel::m_BlocksToBeRenderedOutsideWorldY[v6] = BlockY;
      CWaterLevel::m_NumBlocksOutsideWorldToBeRendered = v6 + 1;
    }
  }
}

//----- (00598738) --------------------------------------------------------
void __fastcall CWaterLevel::CalculateWavesForCoordinate(
        Int32 X,
        Int32 Y,
        float BigWavesAmpl,
        float SmallWavesAmpl,
        float *pResultHeight,
        float *pResultShading,
        float *pResultHighLight,
        CVector *pNormal)
{
  float32x2_t v8; // d8
  float v10; // s14
  float v11; // s6
  float v12; // s1
  float v13; // s14
  RwReal v14; // s12
  float v15; // s10
  float32x2_t v16; // d1
  float v17; // s10
  RwReal v18; // s14
  RwReal v19; // s10
  float v20; // s0
  float v21; // s2
  RwReal v22; // s4
  RwReal v23; // s6
  float v24; // s0
  float v25; // s2
  int v26; // s4
  bool v27; // fnf

  if ( X < 0 )
    X = -X;
  v8.n64_u32[0] = 0;
  if ( Y < 0 )
    Y = -Y;
  v10 = (float)((float)((float)((float)Y * 0.098175)
                      + (float)((float)((float)X * 0.098175)
                              + (float)((float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset)
                                              % 0x1388)
                                      * 0.0012566)))
              * 256.0)
      / 6.2832;
  v11 = (float)(*(float *)((char *)MultX + ((2 * (X + ((unsigned int)X >> 31))) & 0x1C))
              * *(float *)((char *)MultY + ((2 * (Y + ((unsigned int)Y >> 31))) & 0x1C)))
      * CWeather::Wavyness;
  v12 = (float)(v11 + v11) * BigWavesAmpl;
  *pResultHeight = *pResultHeight + (float)(v12 * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v10]);
  v13 = CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)(v10 + 64.0)];
  pNormal->z = 1.0;
  v14 = -(float)((float)(v12 * 0.098175) * v13);
  pNormal->x = v14;
  pNormal->y = v14;
  v15 = (float)((float)((float)((float)Y * 0.12083)
                      + (float)((float)((float)X * 0.24166)
                              + (float)((float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset)
                                              % 0xDAC)
                                      * 0.0017952)))
              * 256.0)
      / 6.2832;
  *pResultHeight = *pResultHeight
                 + (float)((float)(v11 * SmallWavesAmpl) * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v15]);
  v16.n64_f32[1] = pNormal->z + 0.0;
  v17 = (float)((float)(v11 * SmallWavesAmpl) * 0.24166)
      * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)(v15 + 64.0)];
  v18 = v17 + pNormal->x;
  v19 = v17 + pNormal->y;
  pNormal->x = v18;
  pNormal->y = v19;
  LODWORD(pNormal->z) = v16.n64_u32[1];
  v20 = (float)((float)((float)((float)Y * 0.31416)
                      + (float)((float)((CTimer::m_snTimeInMilliseconds - CWaterLevel::m_nWaterTimeOffset) % 0xBB8)
                              * 0.0020944))
              * 256.0)
      / 6.2832;
  v21 = (float)(v11 * 0.5) * SmallWavesAmpl;
  *pResultHeight = *pResultHeight + (float)(v21 * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)v20]);
  v22 = pNormal->y + 0.0;
  v23 = pNormal->z + 0.0;
  pNormal->x = (float)((float)(v21 * 0.31416) * CMaths::ms_SinTable[(unsigned __int8)(unsigned int)(float)(v20 + 64.0)])
             + pNormal->x;
  pNormal->y = v22;
  pNormal->z = v23;
  CVector::Normalise(pNormal);
  v16.n64_f32[0] = (float)((float)(pNormal->x * 0.577) + (float)(pNormal->y * 0.577)) + (float)(pNormal->z * 0.577);
  *pResultShading = (float)(vmax_f32(v16, v8).n64_f32[0] * 0.65) + 0.27;
  v24 = (float)((float)(pNormal->x * 0.577) + (float)(pNormal->y * 0.577)) + (float)(pNormal->z * 0.577);
  v25 = (float)(v24 * 8.0) + -5.0;
  v26 = 1065185444;
  if ( v25 > 0.99 )
    v8.n64_u32[0] = 1065185444;
  if ( v25 < 0.0 )
    v26 = v8.n64_u32[0];
  v27 = v25 < 0.0;
  if ( v25 > 0.99 )
    v25 = *(float *)&v26;
  if ( v27 )
    v25 = *(float *)&v26;
  *pResultHighLight = v24;
  *pResultHighLight = CWeather::SunGlare * v25;
}
// 598A14: variable 'v8' is possibly undefined

//----- (00598B0C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::RenderHighDetailWaterTriangle(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3)
{
  int v11; // r4
  float m_Z; // r10
  _BOOL4 v13; // lr
  int v14; // r3
  Int32 v15; // [sp+10h] [bp-68h]
  Int32 v16; // [sp+3Ch] [bp-3Ch]
  Int32 v17; // [sp+40h] [bp-38h]
  float m_BigWaves; // [sp+4Ch] [bp-2Ch]
  CVector posn; // [sp+50h] [bp-28h] BYREF
  __int64 v20; // 0:^80.8
  CRenPar v21; // 0:r3.4,4:^0.12
  CRenPar v22; // 0:r2.8,8:^0.8

  m_BigWaves = P1.m_BigWaves;
  v11 = X2 - X1;
  m_Z = P1.m_Z;
  posn.z = P1.m_Z;
  posn.y = (float)(Y2 + Y1 + Y3) * 0.33333;
  posn.x = (float)(X2 + X1 + X3) * 0.33333;
  if ( CCamera::IsSphereVisible(&TheCamera, &posn, (float)(X2 - X1) * 0.71) )
  {
    v13 = 0;
    v14 = v11 / 2;
    if ( v11 >= -1 )
      v13 = (int)(((((unsigned int)v14 * (unsigned __int64)(unsigned int)(v14 - 1)) & 0x1FFFFFFFFLL) >> 1) + 2 * v14 + 1) >= 2048;
    if ( (unsigned int)(3 * v14 * v14) >> 12 || v13 )
    {
      v21.m_Z = m_Z;
      *(_QWORD *)&v21.m_BigWaves = __PAIR64__(LODWORD(P1.m_SmallWaves), LODWORD(m_BigWaves));
      *(_DWORD *)&v21.m_FlowX = *(_DWORD *)&P1.m_FlowX;
      CWaterLevel::SplitWaterTriangleAlongXLine(X1 + 2 * (v11 / 4), X1, Y1, v21, X2, v15, P2, X3, Y3, P3);
    }
    else
    {
      *(_QWORD *)&v22.m_Z = __PAIR64__(LODWORD(m_BigWaves), LODWORD(m_Z));
      *(_QWORD *)&v22.m_SmallWaves = v20;
      CWaterLevel::RenderHighDetailWaterTriangle_OneLayer(X1, Y1, v22, X2, Y2, P2, X3, Y3, P3, 0, v16, v17, v11 / 2);
    }
  }
}
// 598B0C: fragmented variable at 0:r2.8,8:^80.8 may be wrong
// 598B0C: variables would overlap: 0:r2.8,8:^80.8 and ^80.4
// 598B0C: variables would overlap: 0:r2.8,8:^80.8 and ^84.4

//----- (00598C70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::SplitWaterTriangleAlongXLine(
        Int32 SplitX,
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3)
{
  float m_Z; // r5
  int v14; // r0
  Int32 v15; // r4
  float v16; // s0
  float v17; // s2
  float v18; // s4
  float v19; // s6
  float v20; // s23
  float v21; // r2
  float v22; // r2
  Int32 v23; // r4
  float v24; // s16
  float v25; // s24
  unsigned int v26; // s17
  float v27; // s26
  float v28; // s6
  float v29; // s19
  float v30; // s21
  float v31; // s30
  float v32; // s28
  unsigned int v33; // s23
  float v34; // s25
  unsigned int v35; // r2
  float v36; // s2
  float v37; // s4
  float v38; // s16
  float v39; // r2
  float P1a; // [sp+0h] [bp-A8h]
  CRenPar P1b; // [sp+0h] [bp-A8h]
  float P1c; // [sp+0h] [bp-A8h]
  unsigned int P1d; // [sp+0h] [bp-A8h]
  CRenPar P1e; // [sp+0h] [bp-A8h]
  float P1f; // [sp+0h] [bp-A8h]
  int P1_4; // [sp+4h] [bp-A4h]
  int P1_4a; // [sp+4h] [bp-A4h]
  int P1_4b; // [sp+4h] [bp-A4h]
  int P1_4c; // [sp+4h] [bp-A4h]
  CRenPar P2a; // [sp+10h] [bp-98h]
  CRenPar P2b; // [sp+10h] [bp-98h]
  CRenPar P2c; // [sp+10h] [bp-98h]
  CRenPar P2d; // [sp+10h] [bp-98h]
  CRenPar v54; // [sp+20h] [bp-88h]
  CRenPar v55; // [sp+20h] [bp-88h]
  CRenPar P3a; // [sp+28h] [bp-80h]
  CRenPar P3b; // [sp+28h] [bp-80h]
  CRenPar P3_8; // [sp+30h] [bp-78h]
  CRenPar P3_8a; // [sp+30h] [bp-78h]

  m_Z = P1.m_Z;
  if ( X1 == X3 )
  {
    v14 = (Y1 - Y3) * (SplitX - X1) / (X2 - X1);
    v15 = v14 + Y3;
    v16 = (float)(SplitX - X1) / (float)(X2 - X1);
    *(_DWORD *)&P2a.m_FlowX = 0;
    P1_4 = 0;
    v17 = (float)(1.0 - v16) * P3.m_SmallWaves;
    v18 = (float)(1.0 - v16) * P3.m_Z;
    v19 = (float)(1.0 - v16) * P3.m_BigWaves;
    P2a.m_Z = (float)(v16 * P2.m_Z) + v18;
    v20 = (float)(v16 * P1.m_Z) + v18;
    P2a.m_BigWaves = (float)(v16 * P2.m_BigWaves) + v19;
    P2a.m_SmallWaves = (float)(v16 * P2.m_SmallWaves) + v17;
    P1a = (float)(v16 * P1.m_SmallWaves) + v17;
    v21 = v20;
    P1.m_Z = (float)(v16 * P1.m_BigWaves) + v19;
    CWaterLevel::RenderWaterTriangle(X1, v14 + Y3, P1, SplitX, v14 + Y3, P2a, X1, Y3, P3);
    *(_QWORD *)&P1b.m_SmallWaves = *(_QWORD *)&P1.m_SmallWaves;
    P3_8.m_Z = (float)(v16 * P2.m_Z) + v18;
    P3_8.m_BigWaves = (float)(v16 * P2.m_BigWaves) + v19;
    *(_QWORD *)&P3_8.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v16 * P2.m_SmallWaves) + v17);
    v54.m_Z = v20;
    v54.m_BigWaves = (float)(v16 * P1.m_BigWaves) + v19;
    *(_QWORD *)&v54.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v16 * P1.m_SmallWaves) + v17);
    P2b.m_Z = (float)((float)(1.0 - v16) * m_Z) + (float)(v16 * P2.m_Z);
    P2b.m_BigWaves = (float)((float)(1.0 - v16) * P1.m_BigWaves) + (float)(v16 * P2.m_BigWaves);
    *(_QWORD *)&P2b.m_SmallWaves = COERCE_UNSIGNED_INT((float)((float)(1.0 - v16) * P1.m_SmallWaves) + (float)(v16 * P2.m_SmallWaves));
    *(_QWORD *)&P1b.m_Z = __PAIR64__(LODWORD(P1.m_BigWaves), LODWORD(m_Z));
    CWaterLevel::RenderWaterRectangle(X1, SplitX, Y1, v15, P1b, P2b, v54, P3_8);
    v22 = (float)((float)(1.0 - v16) * m_Z) + (float)(v16 * P2.m_Z);
    P1.m_Z = (float)((float)(1.0 - v16) * P1.m_BigWaves) + (float)(v16 * P2.m_BigWaves);
    *(_DWORD *)&P3a.m_FlowX = 0;
    P3a.m_Z = (float)(v16 * P2.m_Z) + v18;
    P3a.m_BigWaves = (float)(v16 * P2.m_BigWaves) + v19;
    P3a.m_SmallWaves = (float)(v16 * P2.m_SmallWaves) + v17;
    P1_4a = 0;
    P1c = (float)((float)(1.0 - v16) * P1.m_SmallWaves) + (float)(v16 * P2.m_SmallWaves);
    CWaterLevel::RenderWaterTriangle(SplitX, Y1, P1, X2, Y1, P2, SplitX, v15, P3a);
  }
  else
  {
    v23 = (Y3 - Y1) * (SplitX - X1) / (X2 - X1) + Y1;
    v24 = (float)(SplitX - X1) / (float)(X2 - X1);
    *(_DWORD *)&P2c.m_FlowX = 0;
    P1_4b = 0;
    v25 = (float)(1.0 - v24) * P1.m_SmallWaves;
    *(float *)&v26 = v25 + (float)(v24 * P3.m_SmallWaves);
    v27 = (float)((float)(1.0 - v24) * P2.m_SmallWaves) + (float)(v24 * P3.m_SmallWaves);
    v28 = P1.m_Z;
    v29 = (float)(1.0 - v24) * P1.m_Z;
    v30 = (float)(1.0 - v24) * P1.m_BigWaves;
    v31 = (float)((float)(1.0 - v24) * P2.m_Z) + (float)(v24 * P3.m_Z);
    v32 = (float)((float)(1.0 - v24) * P2.m_BigWaves) + (float)(v24 * P3.m_BigWaves);
    *(float *)&v33 = v29 + (float)(v24 * P3.m_Z);
    v34 = v30 + (float)(v24 * P3.m_BigWaves);
    P2c.m_Z = v31;
    P2c.m_BigWaves = v32;
    P2c.m_SmallWaves = v27;
    P1d = v26;
    v35 = v33;
    P1.m_Z = v34;
    CWaterLevel::RenderWaterTriangle(SplitX, v23, P1, X2, v23, P2c, X2, Y3, P3);
    v36 = v24 * P2.m_BigWaves;
    v37 = v24 * P2.m_SmallWaves;
    v38 = v29 + (float)(v24 * P2.m_Z);
    *(_QWORD *)&P3_8a.m_Z = __PAIR64__(LODWORD(v32), LODWORD(v31));
    *(_QWORD *)&P3_8a.m_SmallWaves = LODWORD(v27);
    *(_QWORD *)&v55.m_Z = __PAIR64__(LODWORD(v34), v33);
    *(_QWORD *)&v55.m_SmallWaves = v26;
    *(_DWORD *)&P1e.m_FlowX = 0;
    P1e.m_Z = v38;
    P1e.m_BigWaves = v30 + v36;
    P1e.m_SmallWaves = v25 + v37;
    CWaterLevel::RenderWaterRectangle(SplitX, X2, Y1, v23, P1e, P2, v55, P3_8a);
    v39 = v28;
    P1.m_Z = P1.m_BigWaves;
    *(_QWORD *)&P3b.m_Z = __PAIR64__(LODWORD(v34), v33);
    *(_QWORD *)&P3b.m_SmallWaves = v26;
    *(_DWORD *)&P2d.m_FlowX = 0;
    P2d.m_Z = v38;
    P2d.m_BigWaves = v30 + v36;
    P2d.m_SmallWaves = v25 + v37;
    P1f = P1.m_SmallWaves;
    P1_4c = *(_DWORD *)&P1.m_FlowX;
    CWaterLevel::RenderWaterTriangle(X1, Y1, P1, SplitX, Y1, P2d, SplitX, v23, P3b);
  }
}
// 598C70: fragmented variable at 0:r3.4,4:^B0.12 may be wrong
// 598C70: variables would overlap: 0:r3.4,4:^B0.12 and ^B0.4
// 598C70: variables would overlap: 0:r3.4,4:^B0.12 and ^B4.4
// 598C70: variables would overlap: 0:r3.4,4:^B0.12 and ^B8.4

//----- (00598FAC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::RenderHighDetailWaterTriangle_OneLayer(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3,
        Int32 WaterLayer,
        Int32 PolysNeeded,
        Int32 VerticesNeeded,
        Int32 SizeInPolys)
{
  float v13; // s22
  float v15; // s16
  int v16; // r0
  CRenPar *v17; // r1
  CRenPar *v18; // r2
  float m_Z; // s20
  float v20; // s18
  float v21; // s24
  float v22; // s28
  Int32 v23; // lr
  float **v24; // r0
  float v25; // s0
  float **v26; // r2
  float v27; // s22
  float v28; // s26
  CSimpleTransform *p_tx; // r0
  Int32 v30; // r12
  Int32 v31; // r1
  int v32; // r8
  float v33; // s23
  float x; // s25
  int v35; // r10
  __int16 v36; // r3
  int v37; // r5
  int v38; // r9
  float v39; // s31
  float v40; // s0
  float v41; // s18
  float v42; // s30
  float v43; // s21
  float v44; // s28
  float v45; // s24
  float v46; // s6
  float v47; // s2
  unsigned int green; // r3
  RwIm3DVertex *v49; // r0
  float v50; // r2
  unsigned int v51; // s2
  unsigned int v52; // r4
  unsigned int v53; // r6
  Int32 v54; // r0
  RwIm3DVertex *v55; // r0
  float v56; // s0
  RwIm3DVertex *v57; // r0
  Int32 v58; // r2
  int v59; // r3
  bool v60; // zf
  Int32 v61; // r0
  RwImVertexIndex *v62; // r2
  Int32 v63; // r0
  RwImVertexIndex *v64; // r2
  float y; // [sp+1Ch] [bp-12Ch]
  int v66; // [sp+2Ch] [bp-11Ch]
  Int32 v67; // [sp+30h] [bp-118h]
  float v68; // [sp+34h] [bp-114h]
  __int16 v69; // [sp+3Ch] [bp-10Ch]
  float v70; // [sp+84h] [bp-C4h]
  float v71; // [sp+88h] [bp-C0h]
  float m_SmallWaves; // [sp+8Ch] [bp-BCh]
  float m_BigWaves; // [sp+90h] [bp-B8h]
  int v75; // [sp+A8h] [bp-A0h]
  __int16 v76; // [sp+ACh] [bp-9Ch]
  __int16 v77; // [sp+B0h] [bp-98h]
  int v78; // [sp+B8h] [bp-90h]
  float pResultHighLight; // [sp+BCh] [bp-8Ch] BYREF
  float pResultShading; // [sp+C0h] [bp-88h] BYREF
  float pResultHeight; // [sp+C4h] [bp-84h] BYREF
  CRenPar v82; // [sp+C8h] [bp-80h] BYREF
  CRenPar v83[7]; // [sp+D8h] [bp-70h] BYREF

  TempColourBufferIndex = 0;
  v83[0] = P1;
  v82 = P2;
  if ( TempBufferVerticesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
  }
  v15 = (float)SizeInPolys;
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
  if ( X1 == X3 )
  {
    v16 = X2 - X1;
    v17 = v83;
    v18 = &v82;
  }
  else
  {
    Y1 = Y2;
    v16 = X1 - X2;
    v17 = &v82;
    v18 = v83;
    X1 = X2;
  }
  m_BigWaves = v17->m_BigWaves;
  m_Z = v17->m_Z;
  m_SmallWaves = v17->m_SmallWaves;
  v20 = v18->m_BigWaves;
  v21 = v18->m_SmallWaves;
  v22 = v18->m_Z;
  v78 = v16 / SizeInPolys;
  v23 = WaterLayer;
  v66 = (Y3 - Y1) / SizeInPolys;
  if ( WaterLayer == 1 )
  {
    v24 = &TextureShiftSecondV_ptr;
    v25 = 0.04;
    v26 = &TextureShiftSecondU_ptr;
  }
  else
  {
    v68 = v17->m_SmallWaves;
    if ( WaterLayer )
      goto LABEL_12;
    v24 = (float **)&TextureShiftV_ptr;
    v25 = 0.08;
    v26 = &TextureShiftU_ptr;
  }
  v27 = (float)(v25 * (float)X1) + **v26;
  v28 = (float)(v25 * (float)Y1) + **v24;
  v23 = WaterLayer;
  v13 = v27 - floorf(v27);
  v68 = v28 - floorf(v28);
LABEL_12:
  v67 = Y1;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v30 = X1;
  if ( SizeInPolys >= 0 )
  {
    v31 = 0;
    v32 = 0;
    v33 = (float)(1.0 / v15) * (float)(v22 - m_Z);
    v70 = (float)(1.0 / v15) * (float)(v20 - m_BigWaves);
    v71 = (float)(1.0 / v15) * (float)(v21 - m_SmallWaves);
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    v35 = SizeInPolys + 1;
    do
    {
      v36 = SizeInPolys - v32;
      v69 = SizeInPolys - v32;
      if ( SizeInPolys - v32 >= 0 )
      {
        v37 = 0;
        v38 = 0;
        v39 = (float)(v67 + v32 * v66);
        v40 = (float)(v32 * v66);
        v77 = -2 - v36;
        v76 = v36 + 3;
        v75 = v35;
        v41 = (float)((float)(1.0 / v15) * (float)(P3.m_Z - m_Z)) * (float)v32;
        v42 = v40 * 0.1;
        v43 = v68 + (float)(v40 * 0.04);
        v44 = v68 + (float)(v40 * 0.08);
        do
        {
          v45 = (float)(v30 + v37);
          v46 = sqrtf((float)((float)(y - v39) * (float)(y - v39)) + (float)((float)(x - v45) * (float)(x - v45)))
              / (float)DETAILEDWATERDIST;
          v47 = 0.0;
          pResultHeight = v41 + (float)(m_Z + (float)(v33 * (float)v38));
          if ( v46 <= 1.0 )
          {
            v47 = 1.0;
            if ( v46 > 0.75 )
              v47 = (float)(1.0 - v46) * 4.0;
          }
          switch ( v23 )
          {
            case 2:
              v55 = &TempVertexBuffer.m_3d[v31];
              v55->texCoords.u = (float)((float)v37 * 0.1) + TextureShiftHighLightU;
              v56 = TextureShiftHighLightV;
              v55->position.x = v45;
              v55->position.y = v39;
              v55->position.z = (float)(v41 + (float)(m_Z + (float)(v33 * (float)v38))) + 0.1;
              v55->color = (RwRGBA_0)((unsigned int)(float)(255.0 * 255.0) | ((unsigned int)(float)(255.0 * 255.0) << 8) | ((unsigned int)(float)(255.0 * 255.0) << 16) | 0xFF000000);
              v55->texCoords.v = v42 + v56;
              break;
            case 1:
              v57 = &TempVertexBuffer.m_3d[v31];
              v58 = TempColourBufferIndex;
              v59 = TempColourBufferR[TempColourBufferIndex] | (TempColourBufferG[TempColourBufferIndex] << 8) | (TempColourBufferB[TempColourBufferIndex] << 16) | 0x5A000000;
              v57->texCoords.u = v13 + (float)((float)v37 * 0.04);
              v57->texCoords.v = v43;
              v57->color = (RwRGBA_0)v59;
              TempColourBufferIndex = v58 + 1;
              v35 = v75;
              break;
            case 0:
              CWaterLevel::CalculateWavesForCoordinate(
                v30 + v37,
                v67 + v32 * v66,
                (float)((float)((float)((float)(1.0 / v15) * (float)(P3.m_BigWaves - m_BigWaves)) * (float)v32)
                      + (float)(m_BigWaves + (float)(v70 * (float)v38)))
              * v47,
                (float)((float)((float)((float)(1.0 / v15) * (float)(P3.m_SmallWaves - m_SmallWaves)) * (float)v32)
                      + (float)(m_SmallWaves + (float)(v71 * (float)v38)))
              * v47,
                &pResultHeight,
                &pResultShading,
                &pResultHighLight,
                &VecForWaterNormalCalculation);
              v30 = X1;
              v31 = TempBufferVerticesStored;
              v23 = WaterLayer;
              pResultShading = 0.577;
              green = WaterColor._anon_0._anon_0.green;
              v49 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
              v50 = pResultHeight;
              v49->texCoords.u = v13 + (float)((float)v37 * 0.08);
              v49->texCoords.v = v44;
              v49->position.x = v45;
              v49->position.y = v39;
              v49->position.z = v50;
              v51 = (unsigned int)(float)((float)WaterColor._anon_0._anon_0.red * 0.577);
              v52 = (unsigned int)(float)((float)green * 0.577);
              v53 = (unsigned int)(float)((float)WaterColor._anon_0._anon_0.blue * 0.577);
              v49->color = (RwRGBA_0)(v51 | (AlphaMain << 24) | (v52 << 8) | (v53 << 16));
              v54 = TempColourBufferIndex;
              TempColourBufferR[TempColourBufferIndex] = v51;
              v35 = v75;
              TempColourBufferG[v54] = v52;
              TempColourBufferB[v54] = v53;
              TempColourBufferIndex = v54 + 1;
              break;
          }
          v60 = v32 == 0;
          if ( v32 )
            v60 = v38 == 0;
          if ( !v60 )
          {
            v61 = TempBufferIndicesStored;
            TempBufferRenderIndexList[TempBufferIndicesStored] = v31;
            v62 = &TempBufferRenderIndexList[v61];
            v62[1] = v31 - 1;
            TempBufferIndicesStored = v61 + 6;
            v62[2] = v31 - v76;
            v62[3] = v31;
            v62[4] = v77 + v31;
            v62[5] = v31 - v76;
          }
          ++v31;
          ++v38;
          TempBufferVerticesStored = v31;
          v37 += v78;
        }
        while ( v35 != v38 );
      }
      if ( v32 )
      {
        v63 = TempBufferIndicesStored;
        TempBufferRenderIndexList[TempBufferIndicesStored] = v31 - 1;
        v64 = &TempBufferRenderIndexList[v63];
        v64[1] = -2 - v69 + v31;
        TempBufferIndicesStored = v63 + 3;
        v64[2] = -3 - v69 + v31;
      }
      ++v32;
      --v35;
    }
    while ( v32 != SizeInPolys + 1 );
  }
}
// 598FAC: fragmented variable at 0:r2.8,8:^150.8 may be wrong
// 598FAC: variables would overlap: 0:r2.8,8:^150.8 and ^150.4
// 598FAC: variables would overlap: 0:r2.8,8:^150.8 and ^154.4
// 67736C: using guessed type float *TextureShiftU_ptr;
// 677608: using guessed type float *TextureShiftSecondU_ptr;
// 678B98: using guessed type float TextureShiftV_ptr;
// 678CE4: using guessed type float *TextureShiftSecondV_ptr;

//----- (00599708) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::RenderFlatWaterTriangle(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3)
{
  float m_SmallWaves; // [sp+0h] [bp-58h]
  int v10; // [sp+4h] [bp-54h]
  Int32 v11; // [sp+10h] [bp-48h]

  if ( X2 - X1 >= 169 && bSplitBigPolys )
  {
    CWaterLevel::SplitWaterTriangleAlongXLine((X2 + X1) / 2, X1, Y1, P1, X2, v11, P2, X3, Y3, P3);
  }
  else
  {
    m_SmallWaves = P1.m_SmallWaves;
    v10 = *(_DWORD *)&P1.m_FlowX;
    CWaterLevel::RenderFlatWaterTriangle_OneLayer(X1, Y1, P1, X2, Y2, P2, X3, Y3, P3, 0);
  }
}
// 599708: fragmented variable at 0:r2.8,8:^60.8 may be wrong
// 599708: variables would overlap: 0:r2.8,8:^60.8 and ^60.4
// 599708: variables would overlap: 0:r2.8,8:^60.8 and ^64.4

//----- (005997BC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::RenderFlatWaterTriangle_OneLayer(
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3,
        Int32 WaterLayer)
{
  float v10; // s2
  float v11; // s18
  Int32 v13; // r8
  Int32 v14; // r11
  bool v15; // cc
  Int32 v16; // r4
  float v17; // r2
  Int32 v18; // r6
  float v19; // s16
  float v20; // s22
  float v21; // s20
  float v22; // s24
  float v23; // r9
  float v24; // r0
  float v25; // s0
  int32 v26; // r0
  float v27; // s22
  float v28; // s24
  float v29; // r9
  float v30; // r0
  float v31; // r0
  Int32 v32; // lr
  float v33; // s8
  float v34; // s9
  RwReal v35; // s2
  RwReal v36; // s0
  RwIm3DVertex *v37; // r1
  unsigned int red; // r2
  unsigned int green; // r3
  unsigned int blue; // r5
  unsigned int v41; // r0
  RwImVertexIndex *v42; // r6
  int v43; // r0
  Int32 v44; // [sp+4h] [bp-54h]
  int32 v45; // [sp+8h] [bp-50h]
  float m_Z; // [sp+Ch] [bp-4Ch]

  m_Z = P1.m_Z;
  v13 = TempBufferVerticesStored;
  v14 = TempBufferIndicesStored;
  v15 = TempBufferIndicesStored < 4092;
  if ( TempBufferIndicesStored <= 4092 )
    v15 = TempBufferVerticesStored < 2045;
  if ( !v15 )
  {
    v16 = Y1;
    if ( TempBufferVerticesStored )
    {
      LittleTest();
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
    }
    v14 = 0;
    v13 = 0;
    TempBufferVerticesStored = 0;
    Y1 = v16;
    TempBufferIndicesStored = 0;
  }
  v17 = P3.m_Z;
  v18 = X3;
  if ( !WaterLayer )
  {
    v11 = 0.08;
    v19 = (float)X1;
    v27 = (float)((float)X1 * 0.08) + TextureShiftU;
    v21 = (float)Y1;
    v44 = Y1;
    v28 = (float)((float)Y1 * 0.08) + TextureShiftV;
    v29 = floorf(v27);
    v30 = floorf(v28);
    v17 = P3.m_Z;
    v18 = X3;
    v25 = v28 - v30;
    v10 = v27 - v29;
    v26 = AlphaMain << 24;
    goto LABEL_12;
  }
  if ( WaterLayer == 1 )
  {
    v11 = 0.04;
    v19 = (float)X1;
    v20 = (float)((float)X1 * 0.04) + TextureShiftSecondU;
    v21 = (float)Y1;
    v44 = Y1;
    v22 = (float)((float)Y1 * 0.04) + TextureShiftSecondV;
    v23 = floorf(v20);
    v24 = floorf(v22);
    v17 = P3.m_Z;
    v18 = X3;
    v25 = v22 - v24;
    v26 = 1509949440;
    v10 = v20 - v23;
LABEL_12:
    v45 = v26;
    v31 = m_Z;
    v32 = v44;
    goto LABEL_14;
  }
  v32 = Y1;
  v21 = (float)Y1;
  v25 = *(float *)&X1;
  v19 = (float)X1;
  v45 = 0;
  v31 = m_Z;
LABEL_14:
  v33 = 7.0;
  if ( Y3 - v32 > 0 )
    v33 = -7.0;
  v34 = v17;
  v35 = v10 + -7.0;
  v36 = v33 + v25;
  v37 = &TempVertexBuffer.m_3d[v13];
  red = WaterColorDebug._anon_0._anon_0.red;
  green = WaterColorDebug._anon_0._anon_0.green;
  v37->position.x = v19;
  v37->position.y = v21;
  v37->position.z = v31 + 0.0;
  v37->texCoords.u = v35;
  blue = WaterColorDebug._anon_0._anon_0.blue;
  v37->texCoords.v = v36;
  v37[1].texCoords.u = (float)(v11 * (float)(X2 - X1)) + v35;
  v37[1].position.x = (float)X2;
  v37[1].position.y = (float)Y2;
  v37[1].position.z = P2.m_Z + 0.0;
  v37[2].texCoords.u = (float)(v11 * (float)(v18 - X1)) + v35;
  v37[2].position.y = (float)Y3;
  v37[2].position.x = (float)v18;
  v37[2].position.z = v34 + 0.0;
  v37[1].texCoords.v = (float)(v11 * (float)(Y2 - v32)) + v36;
  v37[2].texCoords.v = (float)(v11 * (float)(Y3 - v32)) + v36;
  TempBufferRenderIndexList[v14] = v13;
  v41 = (unsigned int)(float)((float)red * 0.577) | v45 | ((unsigned int)(float)((float)green * 0.577) << 8) | ((unsigned int)(float)((float)blue * 0.577) << 16);
  v37->color = (RwRGBA_0)v41;
  v37[1].color = (RwRGBA_0)v41;
  v37[2].color = (RwRGBA_0)v41;
  TempBufferRenderIndexList[v14 + 1] = v13 + 1;
  v42 = &TempBufferRenderIndexList[TempBufferIndicesStored];
  TempBufferIndicesStored += 3;
  v43 = TempBufferVerticesStored + 3;
  v42[2] = TempBufferVerticesStored + 2;
  TempBufferVerticesStored = v43;
}
// 5997BC: fragmented variable at 0:r2.8,8:^60.8 may be wrong
// 67736C: using guessed type float *TextureShiftU_ptr;
// 677608: using guessed type float *TextureShiftSecondU_ptr;
// 678B98: using guessed type float TextureShiftV_ptr;
// 678CE4: using guessed type float *TextureShiftSecondV_ptr;

//----- (00599B48) --------------------------------------------------------
void __fastcall CWaterLevel::RenderHighDetailWaterRectangle(
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4)
{
  int v10; // r10
  Int32 v13; // r1
  Int32 v14; // r3
  Int32 v15; // r11
  Int32 v16; // [sp+44h] [bp-3Ch]
  Int32 v17; // [sp+48h] [bp-38h]
  CVector posn; // [sp+58h] [bp-28h] BYREF

  v10 = MaxX - MinX;
  posn.z = P1.m_Z;
  posn.y = (float)(Y2 + Y1) * 0.5;
  posn.x = (float)(MaxX + MinX) * 0.5;
  if ( CCamera::IsSphereVisible(
         &TheCamera,
         &posn,
         sqrtf(
           (float)((float)((float)v10 * 0.5) * (float)((float)v10 * 0.5))
         + (float)((float)((float)(Y1 - Y2) * 0.5) * (float)((float)(Y1 - Y2) * 0.5)))) )
  {
    v13 = Y2;
    v14 = Y1;
    if ( Y1 < Y2 )
    {
      v13 = Y1;
      v14 = Y2;
    }
    v15 = (v14 - v13) / 2;
    if ( 6 * v10 / 2 * v15 >= 4096 || (v10 / 2 + 1) * ((v14 - v13) / 2 + 1) >= 2048 )
    {
      if ( v10 / 2 <= v15 )
        CWaterLevel::SplitWaterRectangleAlongYLine(v13 + 2 * ((v14 - v13) / 4), MinX, MaxX, Y1, Y2, P1, P2, P3, P4);
      else
        CWaterLevel::SplitWaterRectangleAlongXLine(MinX + 2 * (v10 / 4), MinX, MaxX, Y1, Y2, P1, P2, P3, P4);
    }
    else
    {
      CWaterLevel::SetUpWaterFog(MinX, v13, MaxX, v14);
      CWaterLevel::RenderHighDetailWaterRectangle_OneLayer(
        MinX,
        MaxX,
        Y1,
        Y2,
        P1,
        P2,
        P3,
        P4,
        0,
        v16,
        v17,
        v10 / 2,
        v15);
    }
  }
}
// 599C6A: variable 'v16' is possibly undefined
// 599C6A: variable 'v17' is possibly undefined

//----- (00599D38) --------------------------------------------------------
void __fastcall CWaterLevel::SplitWaterRectangleAlongXLine(
        Int32 SplitX,
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4)
{
  float v12; // s0
  CRenPar P1a; // [sp+0h] [bp-90h]
  CRenPar v14; // [sp+10h] [bp-80h]
  CRenPar v15; // [sp+20h] [bp-70h]
  CRenPar v16; // [sp+30h] [bp-60h]

  v12 = (float)(SplitX - MinX) / (float)(MaxX - MinX);
  *(_DWORD *)&v16.m_FlowX = 0;
  *(_DWORD *)&v14.m_FlowX = 0;
  v16.m_Z = (float)((float)(1.0 - v12) * P3.m_Z) + (float)(v12 * P4.m_Z);
  v16.m_BigWaves = (float)((float)(1.0 - v12) * P3.m_BigWaves) + (float)(v12 * P4.m_BigWaves);
  v16.m_SmallWaves = (float)((float)(1.0 - v12) * P3.m_SmallWaves) + (float)(v12 * P4.m_SmallWaves);
  v14.m_Z = (float)((float)(1.0 - v12) * P1.m_Z) + (float)(v12 * P2.m_Z);
  v14.m_BigWaves = (float)((float)(1.0 - v12) * P1.m_BigWaves) + (float)(v12 * P2.m_BigWaves);
  v14.m_SmallWaves = (float)((float)(1.0 - v12) * P1.m_SmallWaves) + (float)(v12 * P2.m_SmallWaves);
  CWaterLevel::RenderWaterRectangle(MinX, SplitX, Y1, Y2, P1, v14, P3, v16);
  v15.m_Z = (float)((float)(1.0 - v12) * P3.m_Z) + (float)(v12 * P4.m_Z);
  v15.m_BigWaves = (float)((float)(1.0 - v12) * P3.m_BigWaves) + (float)(v12 * P4.m_BigWaves);
  *(_QWORD *)&v15.m_SmallWaves = COERCE_UNSIGNED_INT((float)((float)(1.0 - v12) * P3.m_SmallWaves) + (float)(v12 * P4.m_SmallWaves));
  P1a.m_Z = (float)((float)(1.0 - v12) * P1.m_Z) + (float)(v12 * P2.m_Z);
  P1a.m_BigWaves = (float)((float)(1.0 - v12) * P1.m_BigWaves) + (float)(v12 * P2.m_BigWaves);
  *(_QWORD *)&P1a.m_SmallWaves = COERCE_UNSIGNED_INT((float)((float)(1.0 - v12) * P1.m_SmallWaves) + (float)(v12 * P2.m_SmallWaves));
  CWaterLevel::RenderWaterRectangle(SplitX, MaxX, Y1, Y2, P1a, P2, v15, P4);
}

//----- (00599E9C) --------------------------------------------------------
void __fastcall CWaterLevel::SplitWaterRectangleAlongYLine(
        Int32 SplitY,
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4)
{
  float v12; // s0
  CRenPar P1a; // [sp+0h] [bp-90h]
  CRenPar v14; // [sp+10h] [bp-80h]
  CRenPar v15; // [sp+20h] [bp-70h]
  CRenPar v16; // [sp+30h] [bp-60h]

  v12 = (float)(SplitY - Y1) / (float)(Y2 - Y1);
  *(_DWORD *)&v16.m_FlowX = 0;
  *(_DWORD *)&v15.m_FlowX = 0;
  v16.m_Z = (float)((float)(1.0 - v12) * P2.m_Z) + (float)(v12 * P4.m_Z);
  v16.m_BigWaves = (float)((float)(1.0 - v12) * P2.m_BigWaves) + (float)(v12 * P4.m_BigWaves);
  v16.m_SmallWaves = (float)((float)(1.0 - v12) * P2.m_SmallWaves) + (float)(v12 * P4.m_SmallWaves);
  v15.m_Z = (float)((float)(1.0 - v12) * P1.m_Z) + (float)(v12 * P3.m_Z);
  v15.m_BigWaves = (float)((float)(1.0 - v12) * P1.m_BigWaves) + (float)(v12 * P3.m_BigWaves);
  v15.m_SmallWaves = (float)((float)(1.0 - v12) * P1.m_SmallWaves) + (float)(v12 * P3.m_SmallWaves);
  CWaterLevel::RenderWaterRectangle(MinX, MaxX, Y1, SplitY, P1, P2, v15, v16);
  v14.m_Z = (float)((float)(1.0 - v12) * P2.m_Z) + (float)(v12 * P4.m_Z);
  v14.m_BigWaves = (float)((float)(1.0 - v12) * P2.m_BigWaves) + (float)(v12 * P4.m_BigWaves);
  *(_QWORD *)&v14.m_SmallWaves = COERCE_UNSIGNED_INT((float)((float)(1.0 - v12) * P2.m_SmallWaves) + (float)(v12 * P4.m_SmallWaves));
  P1a.m_Z = (float)((float)(1.0 - v12) * P1.m_Z) + (float)(v12 * P3.m_Z);
  P1a.m_BigWaves = (float)((float)(1.0 - v12) * P1.m_BigWaves) + (float)(v12 * P3.m_BigWaves);
  *(_QWORD *)&P1a.m_SmallWaves = COERCE_UNSIGNED_INT((float)((float)(1.0 - v12) * P1.m_SmallWaves) + (float)(v12 * P3.m_SmallWaves));
  CWaterLevel::RenderWaterRectangle(MinX, MaxX, SplitY, Y2, P1a, v14, P3, P4);
}

//----- (0059A000) --------------------------------------------------------
void __fastcall CWaterLevel::SetUpWaterFog(Int32 minX, Int32 minY, Int32 maxX, Int32 maxY)
{
  float v8; // r5
  float v9; // s0
  int v10; // r1
  int v11; // r2
  int v12; // r0
  float v13; // s0
  int v14; // r1
  int v15; // r2
  Int32 v16; // r2
  Int16 *v17; // r3
  float v18; // [sp+8h] [bp-40h] BYREF
  float v19; // [sp+Ch] [bp-3Ch] BYREF
  float pWaterZ; // [sp+10h] [bp-38h] BYREF
  CVector v21; // [sp+14h] [bp-34h] BYREF

  if ( !CWaterLevel::m_bWaterFog || gWaterFogIndex > 69 )
    return;
  FindPlayerCoors(&v21, -1);
  v8 = 0.0;
  if ( !CWaterLevel::GetWaterLevelNoWaves((float)minX, (float)minY, 0.0, &pWaterZ, &v19, &v18) )
  {
    v9 = 0.0;
    pWaterZ = 0.0;
    goto LABEL_9;
  }
  if ( v19 == 0.0 )
    LOBYTE(v8) = 1;
  if ( (LOBYTE(v8) & (v18 == 0.0)) == 0 )
  {
    v9 = pWaterZ;
    v8 = pWaterZ;
LABEL_9:
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = v9 + CWaterLevel::m_fWaterFogHeight;
    if ( v21.x >= (float)minX )
      v10 = 1;
    if ( v21.x <= (float)maxX )
      v11 = 1;
    v14 = v10 & v11;
    v15 = 0;
    if ( v21.z < v13 )
      ++v14;
    if ( v21.y >= (float)minY )
      v15 = 1;
    if ( v21.y <= (float)maxY )
      v12 = 1;
    if ( (v12 & v15) + v14 == 3 )
      gbPlayerIsInsideWaterFog = 1;
    v16 = gWaterFogIndex;
    v17 = &CWaterLevel::ms_WaterFog.minX[gWaterFogIndex];
    *v17 = minX;
    v17[70] = minY;
    v17[140] = maxX;
    v17[210] = maxY;
    CWaterLevel::ms_WaterFog.z[v16] = v8;
    gWaterFogIndex = v16 + 1;
  }
}
// A1DCA0: using guessed type char gbPlayerIsInsideWaterFog;

//----- (0059A174) --------------------------------------------------------
void __fastcall CWaterLevel::RenderHighDetailWaterRectangle_OneLayer(
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4,
        Int32 WaterLayer,
        Int32 PolysNeeded,
        Int32 VerticesNeeded,
        Int32 XSizeInPolys,
        Int32 YSizeInPolys)
{
  float v13; // s18
  float v15; // s16
  float v16; // s22
  float v17; // s0
  float *v18; // r1
  float *v19; // r0
  float v20; // s18
  float v21; // s20
  CSimpleTransform *p_tx; // r0
  Int32 v23; // r12
  int v24; // r2
  float v25; // s21
  Int32 v26; // lr
  Int32 v27; // r4
  float v28; // s19
  float x; // s16
  float y; // s24
  int v31; // r0
  int v32; // r10
  int v33; // r5
  int v34; // r9
  int v35; // r8
  float v36; // s0
  float v37; // s4
  float v38; // s22
  float v39; // s30
  Int32 v40; // r6
  float v41; // s28
  float v42; // s17
  float v43; // s25
  float v44; // s29
  float v45; // s23
  float v46; // s0
  Int32 v47; // r0
  Int32 v48; // r1
  float v49; // s4
  float v50; // s6
  float v51; // s0
  float v52; // s2
  float m_SmallWaves; // s4
  float v54; // s6
  float v55; // s31
  float v56; // s27
  float v57; // s10
  float v58; // s8
  Int32 v59; // r11
  unsigned int green; // r3
  RwIm3DVertex *v61; // r0
  float v62; // r1
  unsigned int v63; // s2
  unsigned int v64; // r6
  unsigned int v65; // r1
  Int32 v66; // r0
  RwIm3DVertex *v67; // r1
  int v68; // r3
  bool v69; // zf
  Int32 v70; // r0
  RwImVertexIndex *v71; // r1
  int v72; // [sp+14h] [bp-13Ch]
  float v73; // [sp+18h] [bp-138h]
  float v74; // [sp+1Ch] [bp-134h]
  float v75; // [sp+20h] [bp-130h]
  float v76; // [sp+24h] [bp-12Ch]
  float v77; // [sp+28h] [bp-128h]
  float v78; // [sp+2Ch] [bp-124h]
  float v79; // [sp+30h] [bp-120h]
  int v80; // [sp+34h] [bp-11Ch]
  float v81; // [sp+3Ch] [bp-114h]
  int v84; // [sp+7Ch] [bp-D4h]
  float v85; // [sp+80h] [bp-D0h]
  float v86; // [sp+84h] [bp-CCh]
  __int16 v87; // [sp+94h] [bp-BCh]
  float v88; // [sp+98h] [bp-B8h]
  float v89; // [sp+9Ch] [bp-B4h]
  float v90; // [sp+A0h] [bp-B0h]
  float v91; // [sp+A4h] [bp-ACh]
  float v92; // [sp+A8h] [bp-A8h]
  int v94; // [sp+C8h] [bp-88h]
  int v95; // [sp+CCh] [bp-84h]
  int v96; // [sp+D0h] [bp-80h]
  int v97; // [sp+E0h] [bp-70h]
  float pResultHighLight; // [sp+E4h] [bp-6Ch] BYREF
  float pResultShading; // [sp+E8h] [bp-68h] BYREF
  float pResultHeight[25]; // [sp+ECh] [bp-64h] BYREF

  TempColourBufferIndex = 0;
  if ( TempBufferVerticesStored )
  {
    LittleTest();
    if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
    {
      RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
      RwIm3DEnd();
    }
  }
  v15 = (float)YSizeInPolys;
  TempBufferVerticesStored = 0;
  TempBufferIndicesStored = 0;
  v84 = (MaxX - MinX) / XSizeInPolys;
  v16 = (float)XSizeInPolys;
  v80 = (Y2 - Y1) / YSizeInPolys;
  v97 = (MinX - MaxX) / XSizeInPolys;
  if ( WaterLayer == 1 )
  {
    v17 = 0.04;
    v18 = &TextureShiftSecondV;
    v19 = &TextureShiftSecondU;
  }
  else
  {
    v81 = *(float *)&XSizeInPolys;
    if ( WaterLayer )
      goto LABEL_9;
    v17 = 0.08;
    v18 = &TextureShiftV;
    v19 = &TextureShiftU;
  }
  v20 = (float)(v17 * (float)MinX) + *v19;
  v21 = (float)(v17 * (float)Y1) + *v18;
  v13 = v20 - floorf(v20);
  v81 = v21 - floorf(v21);
LABEL_9:
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  if ( YSizeInPolys >= 0 )
  {
    v23 = WaterLayer;
    v24 = (MaxX - MinX) / XSizeInPolys;
    v25 = 1.0 / v16;
    v79 = 1.0 / v15;
    v78 = (float)(P2.m_SmallWaves - P4.m_SmallWaves) * (float)(1.0 / v15);
    v26 = 0;
    v27 = XSizeInPolys;
    v92 = (float)(P3.m_SmallWaves - P4.m_SmallWaves) * (float)(1.0 / v16);
    v89 = (float)(P2.m_SmallWaves - P1.m_SmallWaves) * (float)(1.0 / v16);
    v77 = (float)(P2.m_BigWaves - P4.m_BigWaves) * (float)(1.0 / v15);
    v74 = (float)(P3.m_BigWaves - P1.m_BigWaves) * (float)(1.0 / v15);
    v28 = (float)(P2.m_Z - P1.m_Z) * (float)(1.0 / v16);
    v91 = (float)(P3.m_BigWaves - P4.m_BigWaves) * (float)(1.0 / v16);
    v75 = (float)(P3.m_SmallWaves - P1.m_SmallWaves) * (float)(1.0 / v15);
    v88 = (float)(P2.m_BigWaves - P1.m_BigWaves) * (float)(1.0 / v16);
    v76 = (float)(P2.m_Z - P4.m_Z) * (float)(1.0 / v15);
    v73 = (float)(P3.m_Z - P1.m_Z) * (float)(1.0 / v15);
    v90 = (float)(P3.m_Z - P4.m_Z) * (float)(1.0 / v16);
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    v31 = MaxX + v97 * XSizeInPolys;
    v32 = 0;
    v72 = v31;
    v87 = -1 - XSizeInPolys;
    while ( v27 < 0 )
    {
LABEL_31:
      v27 = XSizeInPolys;
      v69 = v32++ == YSizeInPolys;
      if ( v69 )
        return;
    }
    v33 = 0;
    v34 = v27;
    v35 = 0;
    v36 = (float)(v32 * v80);
    v37 = (float)(YSizeInPolys - v32);
    v96 = v32;
    v95 = Y1 + v32 * v80;
    v38 = v75 * (float)v32;
    v39 = v74 * (float)v32;
    v40 = v72;
    v41 = v73 * (float)v32;
    v94 = Y2 + (YSizeInPolys - v32) * ((Y1 - Y2) / YSizeInPolys);
    v42 = v79 * (float)v32;
    v43 = v78 * v37;
    v44 = v77 * v37;
    v45 = v76 * v37;
    v85 = v81 + (float)(v36 * 0.04);
    v86 = v81 + (float)(v36 * 0.08);
    while ( 1 )
    {
      v46 = (float)v35;
      if ( (float)(v42 + (float)(v25 * (float)v35)) >= 1.0 )
      {
        v47 = v40;
        v48 = v94;
        v51 = v92 * (float)v34;
        v52 = v44 + (float)((float)(v91 * (float)v34) + P4.m_BigWaves);
        m_SmallWaves = P4.m_SmallWaves;
        pResultHeight[0] = v45 + (float)((float)(v90 * (float)v34) + P4.m_Z);
        v54 = v43;
      }
      else
      {
        v47 = MinX + v35 * v24;
        v48 = v95;
        v49 = (float)(v88 * v46) + P1.m_BigWaves;
        v50 = v41 + (float)((float)(v28 * v46) + P1.m_Z);
        v51 = v89 * v46;
        v52 = v39 + v49;
        m_SmallWaves = P1.m_SmallWaves;
        pResultHeight[0] = v50;
        v54 = v38;
      }
      v55 = (float)v47;
      v56 = (float)v48;
      v57 = sqrtf(
              (float)((float)(y - (float)v48) * (float)(y - (float)v48))
            + (float)((float)(x - (float)v47) * (float)(x - (float)v47)))
          / (float)DETAILEDWATERDIST;
      v58 = 0.0;
      if ( v57 <= 1.0 )
      {
        v58 = 1.0;
        if ( v57 > 0.75 )
          v58 = (float)(1.0 - v57) * 4.0;
      }
      if ( v23 == 1 )
        break;
      if ( !v23 )
      {
        v59 = v40;
        CWaterLevel::CalculateWavesForCoordinate(
          v47,
          v48,
          v52 * v58,
          (float)(v54 + (float)(m_SmallWaves + v51)) * v58,
          pResultHeight,
          &pResultShading,
          &pResultHighLight,
          &VecForWaterNormalCalculation);
        v24 = v84;
        v26 = TempBufferVerticesStored;
        green = WaterColor._anon_0._anon_0.green;
        v61 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
        v62 = pResultHeight[0];
        v61->texCoords.u = v13 + (float)((float)v33 * 0.08);
        v61->texCoords.v = v86;
        v61->position.x = v55;
        v61->position.y = v56;
        v61->position.z = v62;
        v63 = (unsigned int)(float)(pResultShading * (float)WaterColor._anon_0._anon_0.red);
        v64 = (unsigned int)(float)(pResultShading * (float)green);
        v65 = (unsigned int)(float)(pResultShading * (float)WaterColor._anon_0._anon_0.blue);
        v61->color = (RwRGBA_0)(v63 | (AlphaMain << 24) | (v64 << 8) | (v65 << 16));
        v23 = WaterLayer;
        v66 = TempColourBufferIndex;
        TempColourBufferR[TempColourBufferIndex] = v63;
        TempColourBufferG[v66] = v64;
        v40 = v59;
        TempColourBufferB[v66] = v65;
LABEL_25:
        TempColourBufferIndex = v66 + 1;
      }
      v69 = v32 == 0;
      if ( v32 )
        v69 = v35 == 0;
      if ( !v69 )
      {
        v70 = TempBufferIndicesStored;
        TempBufferRenderIndexList[TempBufferIndicesStored] = -2 - XSizeInPolys + v26;
        v71 = &TempBufferRenderIndexList[v70];
        TempBufferIndicesStored = v70 + 6;
        v71[1] = v87 + v26;
        v71[2] = v26 - 1;
        v71[3] = v26;
        v71[4] = v87 + v26;
        v71[5] = v26 - 1;
        v32 = v96;
      }
      ++v26;
      v33 += v24;
      ++v35;
      --v34;
      TempBufferVerticesStored = v26;
      v40 -= v97;
      if ( v34 == -1 )
        goto LABEL_31;
    }
    v67 = &TempVertexBuffer.m_3d[v26];
    v66 = TempColourBufferIndex;
    v68 = TempColourBufferR[TempColourBufferIndex] | (TempColourBufferG[TempColourBufferIndex] << 8) | (TempColourBufferB[TempColourBufferIndex] << 16) | 0x5A000000;
    v67->texCoords.u = v13 + (float)((float)v33 * 0.04);
    v67->texCoords.v = v85;
    v67->color = (RwRGBA_0)v68;
    goto LABEL_25;
  }
}
// 59A6EE: variable 'v13' is possibly undefined
// 67736C: using guessed type float *TextureShiftU_ptr;
// 677608: using guessed type float *TextureShiftSecondU_ptr;
// 678B98: using guessed type float TextureShiftV_ptr;
// 678CE4: using guessed type float *TextureShiftSecondV_ptr;
// 59A174: using guessed type float var_64[25];

//----- (0059A8E4) --------------------------------------------------------
void __fastcall CWaterLevel::RenderFlatWaterRectangle(
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4)
{
  Int32 v8; // r12
  float m_BigWaves; // r9
  float m_SmallWaves; // r11
  float v12; // r3
  float v13; // r10
  unsigned int v14; // lr
  float v15; // r1
  float m_Z; // r6
  float v17; // r11
  unsigned int v18; // r5
  int v19; // r1
  float v20; // s18
  float v21; // s20
  float v22; // s22
  float v23; // s24
  float v24; // s26
  float v25; // s28
  float v26; // r8
  float v27; // r0
  unsigned int v28; // r1
  float v29; // lr
  unsigned int v30; // r10
  float v31; // r12
  float v32; // r1
  float v33; // r3
  float v34; // r11
  float v35; // r9
  float v36; // r6
  unsigned int v37; // r4
  int v38; // r5
  float v39; // s21
  float v40; // s23
  float v41; // s25
  float v42; // r2
  float v43; // r4
  float v44; // r5
  CRenPar v45; // [sp+0h] [bp-F8h]
  CRenPar v46; // [sp+0h] [bp-F8h]
  CRenPar v47; // [sp+0h] [bp-F8h]
  CRenPar v48; // [sp+0h] [bp-F8h]
  CRenPar v49; // [sp+10h] [bp-E8h]
  CRenPar v50; // [sp+10h] [bp-E8h]
  CRenPar v51; // [sp+10h] [bp-E8h]
  CRenPar v52; // [sp+10h] [bp-E8h]
  CRenPar v53; // [sp+20h] [bp-D8h]
  CRenPar v54; // [sp+20h] [bp-D8h]
  CRenPar v55; // [sp+20h] [bp-D8h]
  CRenPar v56; // [sp+20h] [bp-D8h]
  CRenPar v57; // [sp+30h] [bp-C8h]
  CRenPar v58; // [sp+30h] [bp-C8h]
  CRenPar v59; // [sp+30h] [bp-C8h]
  __int64 v60; // [sp+4Ch] [bp-ACh]
  unsigned int v61; // [sp+50h] [bp-A8h]
  Int32 v62; // [sp+54h] [bp-A4h]
  float v63; // [sp+58h] [bp-A0h]
  __int64 v64; // [sp+5Ch] [bp-9Ch]
  float v65; // [sp+64h] [bp-94h]
  unsigned __int64 v66; // [sp+68h] [bp-90h]
  int v67; // [sp+74h] [bp-84h]
  Int32 v68; // [sp+78h] [bp-80h]
  int v69; // [sp+7Ch] [bp-7Ch]
  float v70; // [sp+7Ch] [bp-7Ch]
  int v72; // [sp+84h] [bp-74h]
  float v73; // [sp+88h] [bp-70h]
  float v74; // [sp+8Ch] [bp-6Ch]
  float v75; // [sp+8Ch] [bp-6Ch]
  unsigned __int64 v76; // [sp+90h] [bp-68h]

  v8 = MinX;
  v62 = Y1;
  m_SmallWaves = P4.m_SmallWaves;
  m_BigWaves = P4.m_BigWaves;
  HIDWORD(v64) = LODWORD(P3.m_BigWaves);
  v12 = P2.m_BigWaves;
  v13 = P2.m_SmallWaves;
  v14 = *(_DWORD *)&P2.m_FlowX;
  v66 = *(_QWORD *)&P1.m_SmallWaves;
  v15 = P3.m_SmallWaves;
  m_Z = P3.m_Z;
  v63 = P1.m_Z;
  v65 = P1.m_BigWaves;
  if ( bSplitBigPolys )
  {
    *(float *)&v60 = P3.m_SmallWaves;
    v17 = P2.m_Z;
    v18 = *(_DWORD *)&P1.m_FlowX;
    v19 = *(_DWORD *)&P3.m_FlowX;
    v20 = P2.m_SmallWaves * 0.5;
    v21 = P2.m_BigWaves * 0.5;
    v22 = P2.m_Z * 0.5;
    v23 = P4.m_SmallWaves * 0.5;
    v24 = P4.m_BigWaves * 0.5;
    v25 = P4.m_Z * 0.5;
    *(float *)&v64 = P3.m_Z;
    v68 = Y2;
    while ( 2 )
    {
      v26 = v17;
      v72 = v8;
      v69 = MaxX - v8;
      v27 = *(float *)&v64;
      HIDWORD(v60) = v19;
      v67 = v19;
      v28 = v14;
      v29 = v13;
      v30 = v28;
      v73 = *(float *)&v60;
      v31 = v12;
      v74 = *((float *)&v64 + 1);
      v32 = v65;
      LODWORD(v33) = v66;
      HIDWORD(v66) = v18;
      v76 = __PAIR64__(LODWORD(v63), v18);
      while ( 1 )
      {
        v34 = v29;
        v35 = v31;
        v36 = v26;
        if ( v69 >= 169 )
          break;
        Y2 = v68;
        v37 = v30;
        if ( v68 - Y1 < 169 )
        {
          v62 = Y1;
          v13 = v29;
          v63 = *((float *)&v76 + 1);
          v65 = v32;
          v66 = __PAIR64__(v76, LODWORD(v33));
          v12 = v31;
          v70 = v36;
          HIDWORD(v76) = v37;
          v15 = v73;
          v43 = v74;
          v61 = v67;
          goto LABEL_12;
        }
        v30 = 0;
        *(_DWORD *)&v57.m_FlowX = 0;
        *(_DWORD *)&v53.m_FlowX = 0;
        *(_QWORD *)&v49.m_Z = __PAIR64__(LODWORD(v31), LODWORD(v36));
        *(_QWORD *)&v45.m_Z = __PAIR64__(LODWORD(v32), HIDWORD(v76));
        *(_QWORD *)&v49.m_SmallWaves = __PAIR64__(v37, LODWORD(v29));
        *(_QWORD *)&v45.m_SmallWaves = __PAIR64__(v76, LODWORD(v33));
        v38 = (Y1 + v68) / 2;
        v39 = (float)(v33 * 0.5) + (float)(v73 * 0.5);
        v40 = (float)(v32 * 0.5) + (float)(v74 * 0.5);
        v41 = (float)(*((float *)&v76 + 1) * 0.5) + (float)(v27 * 0.5);
        v57.m_Z = v25 + (float)(v36 * 0.5);
        v57.m_BigWaves = v24 + (float)(v31 * 0.5);
        v57.m_SmallWaves = v23 + (float)(v29 * 0.5);
        v53.m_Z = v41;
        v53.m_BigWaves = v40;
        v53.m_SmallWaves = v39;
        CWaterLevel::RenderFlatWaterRectangle(v72, MaxX, Y1, v38, v45, v49, v53, v57);
        v33 = v39;
        v32 = v40;
        v29 = v23 + (float)(v29 * 0.5);
        v31 = v24 + (float)(v35 * 0.5);
        v26 = v25 + (float)(v36 * 0.5);
        *((float *)&v76 + 1) = v41;
        v73 = v34;
        v74 = v35;
        LODWORD(v76) = 0;
        v27 = v36;
        Y1 = v38;
        v67 = v37;
        if ( !bSplitBigPolys )
        {
          v13 = v23 + (float)(v34 * 0.5);
          v63 = v41;
          v27 = v36;
          v62 = v38;
          v65 = v40;
          v66 = LODWORD(v39);
          v70 = v25 + (float)(v36 * 0.5);
          v12 = v24 + (float)(v35 * 0.5);
          Y2 = v68;
          HIDWORD(v76) = 0;
          v15 = v34;
          v61 = v37;
          v43 = v35;
LABEL_12:
          m_BigWaves = P4.m_BigWaves;
          m_SmallWaves = P4.m_SmallWaves;
          v42 = P4.m_Z;
          m_Z = v27;
          goto LABEL_13;
        }
      }
      *(_DWORD *)&v58.m_FlowX = 0;
      *(_DWORD *)&v50.m_FlowX = 0;
      *(_QWORD *)&v54.m_Z = v64;
      *(_QWORD *)&v46.m_Z = __PAIR64__(LODWORD(v65), LODWORD(v63));
      *(_QWORD *)&v54.m_SmallWaves = v60;
      *(_QWORD *)&v46.m_SmallWaves = v66;
      v58.m_Z = v25 + (float)(*(float *)&v64 * 0.5);
      v58.m_BigWaves = v24 + (float)(*((float *)&v64 + 1) * 0.5);
      v58.m_SmallWaves = v23 + (float)(*(float *)&v60 * 0.5);
      v50.m_Z = (float)(v63 * 0.5) + v22;
      v50.m_BigWaves = (float)(v65 * 0.5) + v21;
      v50.m_SmallWaves = (float)(*(float *)&v66 * 0.5) + v20;
      Y2 = v68;
      CWaterLevel::RenderFlatWaterRectangle(v72, (MaxX + v72) / 2, v62, v68, v46, v50, v54, v58);
      Y1 = v62;
      v18 = 0;
      v8 = (MaxX + v72) / 2;
      *(float *)&v60 = v23 + (float)(*(float *)&v60 * 0.5);
      v63 = (float)(v63 * 0.5) + v22;
      v19 = 0;
      *((float *)&v64 + 1) = v24 + (float)(*((float *)&v64 + 1) * 0.5);
      *(float *)&v64 = v25 + (float)(*(float *)&v64 * 0.5);
      *(float *)&v66 = (float)(*(float *)&v66 * 0.5) + v20;
      v65 = (float)(v65 * 0.5) + v21;
      v12 = P2.m_BigWaves;
      v17 = P2.m_Z;
      v13 = P2.m_SmallWaves;
      v14 = *(_DWORD *)&P2.m_FlowX;
      if ( bSplitBigPolys )
        continue;
      break;
    }
    v72 = (MaxX + v72) / 2;
    v61 = 0;
    m_BigWaves = P4.m_BigWaves;
    v42 = P4.m_Z;
    v43 = *((float *)&v64 + 1);
    LODWORD(m_Z) = v64;
    v70 = P2.m_Z;
    m_SmallWaves = P4.m_SmallWaves;
    LODWORD(v15) = v60;
    HIDWORD(v66) = 0;
    HIDWORD(v76) = *(_DWORD *)&P2.m_FlowX;
  }
  else
  {
    v42 = P4.m_Z;
    v70 = P2.m_Z;
    v43 = P3.m_BigWaves;
    v61 = *(_DWORD *)&P3.m_FlowX;
    HIDWORD(v76) = *(_DWORD *)&P2.m_FlowX;
    v72 = MinX;
  }
LABEL_13:
  *(_QWORD *)&v59.m_Z = __PAIR64__(LODWORD(m_BigWaves), LODWORD(v42));
  *(_QWORD *)&v55.m_Z = __PAIR64__(LODWORD(v43), LODWORD(m_Z));
  v75 = v12;
  *(_QWORD *)&v51.m_Z = __PAIR64__(LODWORD(v12), LODWORD(v70));
  v44 = v15;
  *(_QWORD *)&v47.m_Z = __PAIR64__(LODWORD(v65), LODWORD(v63));
  *(_QWORD *)&v59.m_SmallWaves = __PAIR64__(*(unsigned int *)&P4.m_FlowX, LODWORD(m_SmallWaves));
  *(_QWORD *)&v55.m_SmallWaves = __PAIR64__(v61, LODWORD(v15));
  *(_QWORD *)&v51.m_SmallWaves = __PAIR64__(HIDWORD(v76), LODWORD(v13));
  *(_QWORD *)&v47.m_SmallWaves = v66;
  *(float *)&v76 = v13;
  CWaterLevel::RenderFlatWaterRectangle_OneLayer(v72, MaxX, v62, Y2, v47, v51, v55, v59, 0);
  *(_QWORD *)&v56.m_Z = __PAIR64__(LODWORD(v43), LODWORD(m_Z));
  *(_QWORD *)&v56.m_SmallWaves = __PAIR64__(v61, LODWORD(v44));
  *(_QWORD *)&v48.m_Z = __PAIR64__(LODWORD(v65), LODWORD(v63));
  *(_QWORD *)&v48.m_SmallWaves = v66;
  *(_QWORD *)&v52.m_Z = __PAIR64__(LODWORD(v75), LODWORD(v70));
  *(_QWORD *)&v52.m_SmallWaves = v76;
  CWaterLevel::RenderFlatWaterRectangle_OneLayer(v72, MaxX, v62, Y2, v48, v52, v56, P4, 1);
}

//----- (0059ACFC) --------------------------------------------------------
void __fastcall CWaterLevel::RenderFlatWaterRectangle_OneLayer(
        Int32 MinX,
        Int32 MaxX,
        Int32 Y1,
        Int32 Y2,
        CRenPar P1,
        CRenPar P2,
        CRenPar P3,
        CRenPar P4,
        Int32 WaterLayer)
{
  float v9; // s2
  float v10; // s20
  Int32 v14; // r6
  bool v15; // cc
  Int32 v16; // r8
  float m_Z; // r3
  float v18; // r5
  float v19; // r0
  Int32 v20; // r11
  float v21; // s16
  Int32 v22; // r10
  Int32 v23; // r9
  Int32 v24; // r4
  float v25; // s22
  float v26; // s18
  float v27; // s24
  float v28; // r8
  float v29; // r0
  Int32 v30; // s0
  float v31; // s22
  float v32; // s24
  float v33; // r8
  float v34; // r0
  int v35; // r2
  float v36; // s8
  float v37; // s10
  int v38; // r6
  float v39; // s6
  float v40; // s2
  float v41; // s0
  unsigned int red; // r4
  float *v43; // r6
  unsigned int green; // s5
  float v45; // s9
  unsigned int blue; // r0
  float v47; // s4
  float v48; // s6
  unsigned int v49; // r0
  Int32 v50; // r2
  Int32 v51; // r0
  RwImVertexIndex *v52; // r1
  int32 v53; // [sp+4h] [bp-4Ch]

  v14 = TempBufferVerticesStored;
  v15 = TempBufferIndicesStored < 4089;
  if ( TempBufferIndicesStored <= 4089 )
    v15 = TempBufferVerticesStored < 2044;
  if ( !v15 )
  {
    v16 = Y1;
    if ( TempBufferVerticesStored )
    {
      LittleTest();
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
    }
    v14 = 0;
    Y1 = v16;
    TempBufferIndicesStored = 0;
    TempBufferVerticesStored = 0;
  }
  m_Z = P4.m_Z;
  v18 = P3.m_Z;
  v19 = P2.m_Z;
  if ( WaterLayer )
  {
    if ( WaterLayer == 1 )
    {
      v10 = 0.04;
      v20 = Y2;
      v21 = (float)MinX;
      v22 = MaxX;
      v23 = MinX;
      v24 = Y1;
      v25 = (float)(v21 * 0.04) + TextureShiftSecondU;
      v26 = (float)Y1;
      v27 = (float)((float)Y1 * 0.04) + TextureShiftSecondV;
      v28 = floorf(v25);
      v29 = floorf(v27);
      m_Z = P4.m_Z;
      v18 = P3.m_Z;
      *(float *)&v30 = v27 - v29;
      v19 = P2.m_Z;
      v9 = v25 - v28;
      v53 = 1509949440;
    }
    else
    {
      v20 = Y2;
      v22 = MaxX;
      v26 = (float)Y1;
      v23 = MinX;
      v30 = MinX;
      v24 = Y1;
      v21 = (float)v30;
      v53 = 0;
    }
  }
  else
  {
    v10 = 0.08;
    v20 = Y2;
    v21 = (float)MinX;
    v22 = MaxX;
    v23 = MinX;
    v24 = Y1;
    v31 = (float)(v21 * 0.08) + TextureShiftU;
    v26 = (float)Y1;
    v32 = (float)((float)Y1 * 0.08) + TextureShiftV;
    v33 = floorf(v31);
    v34 = floorf(v32);
    m_Z = P4.m_Z;
    v18 = P3.m_Z;
    *(float *)&v30 = v32 - v34;
    v9 = v31 - v33;
    v53 = AlphaMain << 24;
    v19 = P2.m_Z;
  }
  v35 = v20 - v24;
  v36 = (float)v22;
  v37 = (float)v20;
  v38 = 9 * v14;
  v39 = 7.0;
  if ( v20 - v24 > 0 )
    v39 = -7.0;
  v40 = v9 + -7.0;
  v41 = v39 + *(float *)&v30;
  red = WaterColor._anon_0._anon_0.red;
  v43 = (float *)&TempVertexBuffer + v38;
  green = WaterColor._anon_0._anon_0.green;
  *v43 = v21;
  v45 = v19;
  v43[1] = v26;
  blue = WaterColor._anon_0._anon_0.blue;
  v43[2] = P1.m_Z + 0.0;
  v43[7] = v40;
  v47 = (float)(v10 * (float)(v22 - v23)) + v40;
  v43[8] = v41;
  v43[29] = m_Z + 0.0;
  v43[28] = v37;
  v43[27] = v36;
  v48 = (float)(v10 * (float)v35) + v41;
  v43[16] = v47;
  v43[17] = v41;
  v43[9] = v36;
  v43[10] = v26;
  v43[11] = v45 + 0.0;
  v43[25] = v40;
  v43[19] = v37;
  v43[18] = v21;
  v43[20] = v18 + 0.0;
  v43[34] = v47;
  v43[26] = v48;
  v43[35] = v48;
  v49 = (unsigned int)(float)((float)red * 0.577) | v53 | ((unsigned int)(float)((float)green * 0.577) << 8) | ((unsigned int)(float)((float)blue * 0.577) << 16);
  v50 = TempBufferVerticesStored;
  *((_DWORD *)v43 + 6) = v49;
  *((_DWORD *)v43 + 15) = v49;
  *((_DWORD *)v43 + 24) = v49;
  TempVertexBuffer.m_3d[v50 + 3].color = (RwRGBA_0)v49;
  v51 = TempBufferIndicesStored;
  v52 = &TempBufferRenderIndexList[TempBufferIndicesStored];
  *v52 = v50;
  TempBufferIndicesStored = v51 + 6;
  v52[1] = v50 + 1;
  v52[2] = v50 + 2;
  v52[3] = v50 + 3;
  v52[4] = v50 + 1;
  v52[5] = v50 + 2;
  TempBufferVerticesStored = v50 + 4;
}
// 59AEFC: variable 'v9' is possibly undefined
// 59AF14: variable 'v10' is possibly undefined
// 0: using guessed type int dword_0;
// 67736C: using guessed type float *TextureShiftU_ptr;
// 677608: using guessed type float *TextureShiftSecondU_ptr;
// 678B98: using guessed type float TextureShiftV_ptr;
// 678CE4: using guessed type float *TextureShiftSecondV_ptr;

//----- (0059B084) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWaterLevel::SplitWaterTriangleAlongYLine(
        Int32 SplitY,
        Int32 X1,
        Int32 Y1,
        CRenPar P1,
        Int32 X2,
        Int32 Y2,
        CRenPar P2,
        Int32 X3,
        Int32 Y3,
        CRenPar P3)
{
  float v10; // r3
  float v14; // s0
  float v15; // s2
  float v16; // s6
  float v17; // s4
  float v18; // s16
  unsigned int v19; // s17
  float v20; // s20
  float v21; // s23
  float v22; // r2
  float v23; // s4
  float v24; // s2
  float v25; // r2
  float v26; // r3
  int v27; // r6
  Int32 v28; // r9
  float v29; // s0
  float v30; // s2
  float v31; // s6
  float v32; // s4
  float v33; // r2
  Int32 v34; // r0
  float v35; // s0
  float v36; // s2
  float v37; // s4
  float v38; // s6
  float v39; // s16
  float v40; // s17
  float v41; // s21
  float v42; // s23
  float v43; // s4
  float v44; // s2
  int v45; // r0
  Int32 v46; // r11
  float v47; // s0
  float v48; // s24
  float v49; // s22
  float v50; // s8
  float v51; // s16
  float v52; // s18
  float v53; // s2
  float v54; // s4
  float v55; // s6
  float v56; // s10
  float v57; // s0
  unsigned int P1b; // [sp+0h] [bp-A8h]
  CRenPar P1c; // [sp+0h] [bp-A8h]
  float P1a; // [sp+0h] [bp-A8h]
  float P1d; // [sp+0h] [bp-A8h]
  CRenPar P1e; // [sp+0h] [bp-A8h]
  __int64 P1f; // [sp+0h] [bp-A8h]
  CRenPar P1g; // [sp+0h] [bp-A8h]
  __int64 P1h; // [sp+0h] [bp-A8h]
  CRenPar P1i; // [sp+0h] [bp-A8h]
  int P1_4a; // [sp+4h] [bp-A4h]
  int P1_4; // [sp+4h] [bp-A4h]
  int P1_4b; // [sp+4h] [bp-A4h]
  int P1_8; // [sp+8h] [bp-A0h]
  Int32 P1_12; // [sp+Ch] [bp-9Ch]
  CRenPar v72; // [sp+10h] [bp-98h]
  CRenPar v73; // [sp+10h] [bp-98h]
  CRenPar v74; // [sp+10h] [bp-98h]
  CRenPar v75; // [sp+10h] [bp-98h]
  CRenPar v76; // [sp+10h] [bp-98h]
  CRenPar v77; // [sp+10h] [bp-98h]
  CRenPar v78; // [sp+10h] [bp-98h]
  CRenPar v79; // [sp+20h] [bp-88h]
  Int32 v80; // [sp+20h] [bp-88h]
  CRenPar v81; // [sp+20h] [bp-88h]
  CRenPar v82; // [sp+20h] [bp-88h]
  CRenPar v83; // [sp+20h] [bp-88h]
  Int32 v84; // [sp+24h] [bp-84h]
  CRenPar v85; // [sp+28h] [bp-80h]
  CRenPar v86; // [sp+28h] [bp-80h]
  CRenPar v87; // [sp+28h] [bp-80h]
  CRenPar v88; // [sp+28h] [bp-80h]
  CRenPar v89; // [sp+28h] [bp-80h]
  CRenPar v90; // [sp+30h] [bp-78h]
  CRenPar v91; // [sp+30h] [bp-78h]
  CRenPar v92; // [sp+30h] [bp-78h]
  float v93; // [sp+44h] [bp-64h]
  CRenPar v94; // 0:r2.8,8:^0.8

  v93 = v10;
  if ( Y3 <= Y1 )
  {
    v27 = SplitY - Y1;
    if ( X1 != X3 )
    {
      v45 = (X2 - X1) * v27 / (Y3 - Y1);
      v46 = v45 + X1;
      P1h = *(_QWORD *)&P1.m_SmallWaves;
      *(_QWORD *)((char *)&P1 - 4) = *(_QWORD *)&P1.m_Z;
      v47 = (float)v27 / (float)(Y3 - Y1);
      *(_DWORD *)&v89.m_FlowX = 0;
      *(_DWORD *)&v77.m_FlowX = 0;
      v48 = v47 * P3.m_Z;
      v49 = v47 * P3.m_BigWaves;
      v50 = v47 * P2.m_SmallWaves;
      v51 = 1.0 - v47;
      v52 = v47 * P3.m_SmallWaves;
      v53 = (float)(1.0 - v47) * P1.m_SmallWaves;
      v54 = (float)(1.0 - v47) * P1.m_BigWaves;
      v55 = (float)(1.0 - v47) * v93;
      v56 = v47 * P2.m_BigWaves;
      v57 = v47 * P2.m_Z;
      v89.m_Z = v48 + v55;
      v89.m_BigWaves = v49 + v54;
      v89.m_SmallWaves = v52 + v53;
      v77.m_Z = v57 + v55;
      v77.m_BigWaves = v56 + v54;
      v77.m_SmallWaves = v50 + v53;
      CWaterLevel::RenderWaterTriangle(X1, Y1, P1, v45 + X1, Y1, v77, v45 + X1, SplitY, v89);
      *(_DWORD *)&v83.m_FlowX = 0;
      v83.m_Z = v57 + v55;
      v83.m_BigWaves = v56 + v54;
      v83.m_SmallWaves = v50 + v53;
      *(_DWORD *)&v78.m_FlowX = 0;
      v78.m_Z = v48 + v55;
      v78.m_BigWaves = v49 + v54;
      v78.m_SmallWaves = v52 + v53;
      *(_DWORD *)&P1i.m_FlowX = 0;
      P1i.m_Z = v48 + v55;
      P1i.m_BigWaves = v49 + v54;
      P1i.m_SmallWaves = v52 + v53;
      CWaterLevel::RenderWaterRectangle(v46, X2, SplitY, Y1, P1i, v78, v83, P2);
      v86 = P3;
      v25 = v48 + v55;
      v26 = v49 + v54;
      v84 = Y3;
      *(_DWORD *)&v73.m_FlowX = 0;
      v80 = X3;
      v73.m_Z = v48 + (float)(v51 * P2.m_Z);
      v73.m_BigWaves = v49 + (float)(v51 * P2.m_BigWaves);
      v73.m_SmallWaves = v52 + (float)(v51 * P2.m_SmallWaves);
      P1_4 = 0;
      P1_8 = X2;
      P1_12 = SplitY;
      v34 = v46;
      P1a = v52 + v53;
      goto LABEL_9;
    }
    v28 = X2 + (X1 - X2) * v27 / (Y3 - Y1);
    v29 = (float)v27 / (float)(Y3 - Y1);
    *(_DWORD *)&v87.m_FlowX = 0;
    P1_4b = 0;
    v30 = (float)(1.0 - v29) * P2.m_SmallWaves;
    v31 = (float)(1.0 - v29) * P2.m_BigWaves;
    v32 = (float)(1.0 - v29) * P2.m_Z;
    v87.m_Z = (float)(v29 * P3.m_Z) + v32;
    v87.m_BigWaves = (float)(v29 * P3.m_BigWaves) + v31;
    v87.m_SmallWaves = (float)(v29 * P3.m_SmallWaves) + v30;
    P1d = (float)(v29 * P1.m_SmallWaves) + v30;
    v33 = (float)(v29 * P1.m_Z) + v32;
    P1.m_Z = (float)(v29 * P1.m_BigWaves) + v31;
    CWaterLevel::RenderWaterTriangle(v28, Y1, P1, X2, Y2, P2, v28, SplitY, v87);
    *(_QWORD *)&v81.m_SmallWaves = *(_QWORD *)&P1.m_SmallWaves;
    *(_QWORD *)&v81.m_Z = __PAIR64__(LODWORD(P1.m_BigWaves), LODWORD(v93));
    v91.m_Z = (float)(v29 * v93) + v32;
    v91.m_BigWaves = (float)(v29 * P1.m_BigWaves) + v31;
    *(_QWORD *)&v91.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v29 * P1.m_SmallWaves) + v30);
    v74.m_Z = (float)(v29 * P3.m_Z) + v32;
    v74.m_BigWaves = (float)(v29 * P3.m_BigWaves) + v31;
    *(_QWORD *)&v74.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v29 * P3.m_SmallWaves) + v30);
    P1e.m_Z = (float)(v29 * P3.m_Z) + (float)((float)(1.0 - v29) * v93);
    P1e.m_BigWaves = (float)(v29 * P3.m_BigWaves) + (float)((float)(1.0 - v29) * P1.m_BigWaves);
    *(_QWORD *)&P1e.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v29 * P3.m_SmallWaves) + (float)((float)(1.0 - v29)
                                                                                              * P1.m_SmallWaves));
    CWaterLevel::RenderWaterRectangle(X1, v28, SplitY, Y1, P1e, v74, v81, v91);
    v25 = (float)(v29 * P3.m_Z) + (float)((float)(1.0 - v29) * v93);
    *(_DWORD *)&v73.m_FlowX = 0;
    v80 = X1;
    P1.m_Z = (float)(v29 * P3.m_BigWaves) + (float)((float)(1.0 - v29) * P1.m_BigWaves);
    v84 = Y3;
    v86 = P3;
    v73.m_Z = (float)(v29 * P3.m_Z) + v32;
    v73.m_BigWaves = (float)(v29 * P3.m_BigWaves) + v31;
    v73.m_SmallWaves = (float)(v29 * P3.m_SmallWaves) + v30;
    P1_4 = 0;
    P1_8 = X2 + (X1 - X2) * v27 / (Y3 - Y1);
    P1_12 = SplitY;
    P1a = (float)(v29 * P3.m_SmallWaves) + (float)((float)(1.0 - v29) * P1.m_SmallWaves);
  }
  else
  {
    if ( X1 != X3 )
    {
      P1f = *(_QWORD *)&P1.m_SmallWaves;
      *(_QWORD *)((char *)&P1 - 4) = *(_QWORD *)&P1.m_Z;
      v35 = (float)(SplitY - Y1) / (float)(Y3 - Y1);
      *(_DWORD *)&v88.m_FlowX = 0;
      *(_DWORD *)&v75.m_FlowX = 0;
      v36 = (float)(1.0 - v35) * P1.m_SmallWaves;
      v37 = (float)(1.0 - v35) * P1.m_BigWaves;
      v38 = (float)(1.0 - v35) * v93;
      v39 = (float)(v35 * P3.m_SmallWaves) + v36;
      v40 = (float)(v35 * P3.m_BigWaves) + v37;
      v41 = (float)(v35 * P2.m_SmallWaves) + v36;
      v42 = (float)(v35 * P2.m_BigWaves) + v37;
      v88.m_Z = (float)(v35 * P3.m_Z) + v38;
      v88.m_BigWaves = v40;
      v88.m_SmallWaves = v39;
      v75.m_Z = (float)(v35 * P2.m_Z) + v38;
      v75.m_BigWaves = v42;
      v75.m_SmallWaves = v41;
      CWaterLevel::RenderWaterTriangle(
        X1,
        Y1,
        P1,
        (X2 - X1) * (SplitY - Y1) / (Y3 - Y1) + X1,
        Y1,
        v75,
        (X2 - X1) * (SplitY - Y1) / (Y3 - Y1) + X1,
        SplitY,
        v88);
      v43 = (float)(1.0 - v35) * P2.m_Z;
      v44 = (float)(1.0 - v35) * P2.m_BigWaves;
      v92.m_Z = (float)(v35 * P3.m_Z) + v43;
      v92.m_BigWaves = (float)(v35 * P3.m_BigWaves) + v44;
      *(_QWORD *)&v92.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v35 * P3.m_SmallWaves) + (float)((float)(1.0 - v35)
                                                                                                * P2.m_SmallWaves));
      v82.m_Z = (float)(v35 * P3.m_Z) + v38;
      v82.m_BigWaves = v40;
      *(_QWORD *)&v82.m_SmallWaves = LODWORD(v39);
      P1g.m_Z = (float)(v35 * P2.m_Z) + v38;
      P1g.m_BigWaves = v42;
      *(_QWORD *)&P1g.m_SmallWaves = LODWORD(v41);
      CWaterLevel::RenderWaterRectangle((X2 - X1) * (SplitY - Y1) / (Y3 - Y1) + X1, X2, Y1, SplitY, P1g, P2, v82, v92);
      v94.m_Z = (float)(v35 * P3.m_Z) + v38;
      *(_DWORD *)&v76.m_FlowX = 0;
      v94.m_BigWaves = v40;
      v76.m_Z = (float)(v35 * P3.m_Z) + v43;
      v76.m_BigWaves = (float)(v35 * P3.m_BigWaves) + v44;
      v76.m_SmallWaves = (float)(v35 * P3.m_SmallWaves) + (float)((float)(1.0 - v35) * P2.m_SmallWaves);
      *(_QWORD *)&v94.m_SmallWaves = LODWORD(v39);
      CWaterLevel::RenderWaterTriangle(
        (X2 - X1) * (SplitY - Y1) / (Y3 - Y1) + X1,
        SplitY,
        v94,
        X2,
        SplitY,
        v76,
        X3,
        Y3,
        P3);
      return;
    }
    v14 = (float)(SplitY - Y1) / (float)(Y3 - Y1);
    *(_DWORD *)&v85.m_FlowX = 0;
    P1_4a = 0;
    v15 = (float)(1.0 - v14) * P2.m_SmallWaves;
    v16 = (float)(1.0 - v14) * P2.m_BigWaves;
    v17 = (float)(1.0 - v14) * P2.m_Z;
    v18 = (float)(v14 * P3.m_SmallWaves) + v15;
    *(float *)&v19 = (float)(v14 * P1.m_SmallWaves) + v15;
    v20 = (float)(v14 * P3.m_Z) + v17;
    v21 = (float)(v14 * P1.m_Z) + v17;
    v85.m_Z = v20;
    v85.m_BigWaves = (float)(v14 * P3.m_BigWaves) + v16;
    v85.m_SmallWaves = v18;
    P1b = v19;
    v22 = v21;
    P1.m_Z = (float)(v14 * P1.m_BigWaves) + v16;
    CWaterLevel::RenderWaterTriangle(
      (X1 - X2) * (SplitY - Y1) / (Y3 - Y1) + X2,
      Y1,
      P1,
      X2,
      Y2,
      P2,
      (X1 - X2) * (SplitY - Y1) / (Y3 - Y1) + X2,
      SplitY,
      v85);
    v23 = (float)(1.0 - v14) * v93;
    v24 = (float)(1.0 - v14) * P1.m_BigWaves;
    *(_QWORD *)&P1c.m_SmallWaves = *(_QWORD *)&P1.m_SmallWaves;
    v90.m_Z = v20;
    v90.m_BigWaves = (float)(v14 * P3.m_BigWaves) + v16;
    *(_QWORD *)&v90.m_SmallWaves = LODWORD(v18);
    v79.m_Z = (float)(v14 * P3.m_Z) + v23;
    v79.m_BigWaves = (float)(v14 * P3.m_BigWaves) + v24;
    *(_QWORD *)&v79.m_SmallWaves = COERCE_UNSIGNED_INT((float)(v14 * P3.m_SmallWaves) + (float)((float)(1.0 - v14)
                                                                                              * P1.m_SmallWaves));
    v72.m_Z = v21;
    v72.m_BigWaves = (float)(v14 * P1.m_BigWaves) + v16;
    *(_QWORD *)&v72.m_SmallWaves = v19;
    *(_QWORD *)&P1c.m_Z = __PAIR64__(LODWORD(P1.m_BigWaves), LODWORD(v93));
    CWaterLevel::RenderWaterRectangle(X1, (X1 - X2) * (SplitY - Y1) / (Y3 - Y1) + X2, Y1, SplitY, P1c, v72, v79, v90);
    v25 = (float)(v14 * P3.m_Z) + v23;
    P1.m_Z = (float)(v14 * P3.m_BigWaves) + v24;
    v80 = X1;
    v84 = Y3;
    v86 = P3;
    v73.m_Z = v20;
    v73.m_BigWaves = (float)(v14 * P3.m_BigWaves) + v16;
    *(_QWORD *)&v73.m_SmallWaves = LODWORD(v18);
    P1_4 = 0;
    P1_8 = (X1 - X2) * (SplitY - Y1) / (Y3 - Y1) + X2;
    P1_12 = SplitY;
    P1a = (float)(v14 * P3.m_SmallWaves) + (float)((float)(1.0 - v14) * P1.m_SmallWaves);
  }
  v34 = X1;
LABEL_9:
  CWaterLevel::RenderWaterTriangle(v34, SplitY, *(CRenPar *)&v25, P1_8, P1_12, v73, v80, v84, v86);
}
// 59B084: fragmented variable at 0:r3.4,4:^B0.12 may be wrong
// 59B084: variables would overlap: 0:r3.4,4:^B0.12 and ^B0.4
// 59B084: variables would overlap: 0:r3.4,4:^B0.12 and ^B4.4
// 59B084: variables would overlap: 0:r3.4,4:^B0.12 and ^B8.4
// 59B084: fragmented variable at r2.4 may be wrong
// 59B084: fragmented variable at r3.4 may be wrong
// 59B084: fragmented variable at ^0.4 may be wrong
// 59B084: fragmented variable at ^4.4 may be wrong
// 59B084: variables would overlap: r2.4 and r2.8

//----- (0059B6B0) --------------------------------------------------------
void __fastcall CWaterLevel::RenderWakeSegment(
        CVector2D *vecA,
        CVector2D *vecB,
        CVector2D *vecC,
        CVector2D *vecD,
        float *fWidthA,
        float *fWidthB,
        float *fAlphaA,
        float *fAlphaB,
        float *fWakeZ)
{
  float32x2_t v9; // d0
  float32x2_t v10; // d2
  float32x2_t v11; // d9
  int v12; // r11
  float *v13; // r8
  int v14; // r1
  Int32 v15; // r0
  float v16; // s29
  bool v17; // cc
  float32x2_t v18; // d15
  _DWORD *p_x; // r0
  float v20; // s2
  float v21; // s27
  float v22; // s28
  float y; // s2
  float32x2_t v24; // d11
  float32x2_t v25; // d16
  float v26; // s2
  float v27; // s22
  float v28; // s16
  float v29; // s20
  RwIm3DVertex *v30; // r4
  float v31; // s18
  RwReal v32; // s21
  float v33; // r0
  float v34; // r5
  float v35; // s18
  float32x2_t v36; // d12
  float32x2_t v37; // d9
  RwReal v38; // s28
  float v39; // r0
  float v40; // s16
  RwReal v41; // s20
  float v42; // r0
  float v43; // r10
  float v44; // r0
  float v45; // s2
  float v46; // r0
  Int32 v47; // r2
  RwIm3DVertex *v48; // r1
  Int32 v49; // r1
  RwImVertexIndex *v50; // r3
  float v55; // [sp+3Ch] [bp-ACh]
  RwReal v56; // [sp+40h] [bp-A8h]
  float v57; // [sp+54h] [bp-94h]
  float x; // [sp+58h] [bp-90h]
  RwReal v59; // [sp+5Ch] [bp-8Ch]
  RwReal v60; // [sp+6Ch] [bp-7Ch]
  unsigned __int64 v61; // [sp+70h] [bp-78h]
  RwReal v62; // [sp+78h] [bp-70h]
  float v63; // [sp+7Ch] [bp-6Ch]
  RwReal v64; // [sp+84h] [bp-64h]

  v12 = 0;
  v13 = &aAlphaFade[1];
  v14 = TempBufferIndicesStored;
  v15 = TempBufferVerticesStored;
  v16 = (float)(CTimer::m_snTimeInMilliseconds & 0xFFF) * 0.0015339;
  do
  {
    v17 = v14 < 4089;
    if ( v14 <= 4089 )
      v17 = v15 < 2044;
    if ( !v17 )
    {
      if ( v15 )
      {
        LittleTest();
        if ( RwIm3DTransform(TempVertexBuffer.m_3d, TempBufferVerticesStored, 0, 1u) )
        {
          RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
          RwIm3DEnd();
        }
      }
      v15 = 0;
      TempBufferIndicesStored = 0;
      TempBufferVerticesStored = 0;
    }
    v9.n64_f32[0] = *(v13 - 1);
    v18.n64_u64[0] = COERCE_UNSIGNED_INT(0.25);
    p_x = (_DWORD *)&TempVertexBuffer.m_3d[v15].position.x;
    v20 = *v13;
    p_x[6] = ((unsigned int)(float)(*fAlphaA * v9.n64_f32[0]) << 24) | 0xFFFFFF;
    p_x[15] = ((unsigned int)(float)(*fAlphaA * v20) << 24) | 0xFFFFFF;
    v10.n64_u32[0] = v12++;
    v21 = (float)v10.n64_i32[0] * 0.25;
    v22 = (float)v12 * 0.25;
    p_x[24] = ((unsigned int)(float)(*fAlphaB * v20) << 24) | 0xFFFFFF;
    p_x[33] = ((unsigned int)(float)(*fAlphaB * v9.n64_f32[0]) << 24) | 0xFFFFFF;
    x = vecC->x;
    v9.n64_u32[0] = LODWORD(vecC->y);
    v57 = vecD->x;
    y = vecD->y;
    v62 = (float)((float)(1.0 - v21) * y) + (float)(v21 * v9.n64_f32[0]);
    v64 = (float)((float)(1.0 - v22) * y) + (float)(v22 * v9.n64_f32[0]);
    v24.n64_u32[1] = LODWORD(vecB->x);
    v11.n64_f32[0] = (float)(v62 * 0.25) + 0.0;
    v9.n64_u32[0] = LODWORD(vecB->y);
    v10.n64_f32[0] = (float)(v64 * 0.25) + 0.0;
    v25.n64_u64[0] = vmin_f32(v10, v11).n64_u64[0];
    v61 = v10.n64_u64[0];
    v26 = vecA->y;
    v27 = vecA->x;
    v60 = (float)((float)(1.0 - v22) * v26) + (float)(v22 * v9.n64_f32[0]);
    v28 = (float)((float)(1.0 - v21) * v26) + (float)(v21 * v9.n64_f32[0]);
    v10.n64_f32[0] = (float)(v60 * 0.25) + 0.0;
    v9.n64_f32[0] = (float)(v28 * 0.25) + 0.0;
    v63 = v28;
    v29 = floorf(vmin_f32(v9, vmin_f32(v10, v25)).n64_f32[0]);
    v30 = &TempVertexBuffer.m_3d[TempBufferVerticesStored];
    v30[3].texCoords.v = v11.n64_f32[0] - v29;
    v31 = (float)((float)(v28 + 3072.0) * 0.03125) - floorf((float)(v28 + 3072.0) * 0.03125);
    v32 = (float)((float)(1.0 - v21) * v27) + (float)(v21 * v24.n64_f32[1]);
    v33 = floorf((float)(v32 + 3072.0) * 0.03125);
    v34 = sinf(v16 + (float)((float)((float)((float)((float)(v32 + 3072.0) * 0.03125) - v33) + v31) * 6.2832));
    v35 = (float)((float)(v60 + 3072.0) * 0.03125) - floorf((float)(v60 + 3072.0) * 0.03125);
    v36.n64_f32[1] = (float)((float)(1.0 - v22) * v27) + (float)(v22 * v24.n64_f32[1]);
    v37.n64_f32[1] = (float)(v36.n64_f32[1] + 3072.0) * 0.03125;
    v59 = v36.n64_f32[1];
    v55 = (float)(v37.n64_f32[1] - floorf(v37.n64_f32[1])) + v35;
    v37.n64_f32[0] = (float)((float)((float)((float)(1.0 - v21) * v57) + (float)(v21 * x)) * 0.25) + 0.0;
    v56 = (float)((float)(1.0 - v21) * v57) + (float)(v21 * x);
    v38 = (float)((float)(1.0 - v22) * v57) + (float)(v22 * x);
    v24.n64_f32[0] = (float)(v38 * 0.25) + 0.0;
    v36.n64_f32[0] = (float)(v36.n64_f32[1] * 0.25) + 0.0;
    v18.n64_f32[0] = (float)(v32 * 0.25) + 0.0;
    v39 = floorf(vmin_f32(v18, vmin_f32(v36, vmin_f32(v24, v37))).n64_f32[0]);
    v18.n64_f32[1] = v18.n64_f32[0] - v39;
    v36.n64_f32[0] = v36.n64_f32[0] - v39;
    v24.n64_f32[0] = v24.n64_f32[0] - v39;
    v30[3].texCoords.u = v37.n64_f32[0] - v39;
    v37.n64_f32[0] = (float)((float)(v64 + 3072.0) * 0.03125) - floorf((float)(v64 + 3072.0) * 0.03125);
    v11.n64_f32[1] = (float)((float)(v38 + 3072.0) * 0.03125) - floorf((float)(v38 + 3072.0) * 0.03125);
    v9.n64_u32[1] = HIDWORD(v61);
    v30[2].texCoords.v = *(float *)&v61 - v29;
    v36.n64_u32[1] = floorf((float)(v62 + 3072.0) * 0.03125);
    LODWORD(v30[2].texCoords.u) = v24.n64_u32[0];
    LODWORD(v30[1].texCoords.u) = v36.n64_u32[0];
    v30[1].texCoords.v = v10.n64_f32[0] - v29;
    LODWORD(v30->texCoords.u) = v18.n64_u32[1];
    v30->texCoords.v = v9.n64_f32[0] - v29;
    v24.n64_f32[0] = (float)(v11.n64_f32[1] + v37.n64_f32[0]) * 6.2832;
    v40 = (float)(CWeather::WindClipped * 0.4) + 0.2;
    v11.n64_f32[0] = (float)((float)((float)((float)(v56 + 3072.0) * 0.03125) - floorf((float)(v56 + 3072.0) * 0.03125))
                           + (float)((float)((float)(v62 + 3072.0) * 0.03125) - v36.n64_f32[1]))
                   * 6.2832;
    v41 = *fWakeZ + (float)(v34 * v40);
    v42 = sinf(v16 + (float)(v55 * 6.2832));
    v30->position.x = v32;
    v30->position.y = v63;
    v30->position.z = v41;
    v43 = v16 + v11.n64_f32[0];
    v11.n64_f32[0] = *fWakeZ + (float)(v42 * v40);
    v44 = sinf(v16 + v24.n64_f32[0]);
    v30[1].position.x = v59;
    v30[1].position.y = v60;
    LODWORD(v30[1].position.z) = v11.n64_u32[0];
    v45 = *fWakeZ;
    v30[2].position.x = v38;
    v30[2].position.y = v64;
    v30[2].position.z = v45 + (float)(v44 * v40);
    v46 = sinf(v43);
    v47 = TempBufferVerticesStored;
    ++v13;
    v9.n64_f32[0] = v46 * v40;
    LOWORD(v46) = TempBufferVerticesStored + 3;
    LOWORD(v34) = TempBufferVerticesStored + 1;
    v48 = &TempVertexBuffer.m_3d[TempBufferVerticesStored + 3];
    v9.n64_f32[0] = *fWakeZ + v9.n64_f32[0];
    v48->position.x = v56;
    v48->position.y = v62;
    LODWORD(v48->position.z) = v9.n64_u32[0];
    v49 = TempBufferIndicesStored;
    TempBufferRenderIndexList[TempBufferIndicesStored] = v47;
    v50 = &TempBufferRenderIndexList[v49];
    v14 = v49 + 6;
    v50[2] = LOWORD(v34);
    v50[4] = LOWORD(v46);
    v50[1] = v47 + 2;
    v50[3] = v47;
    v50[5] = v47 + 2;
    v15 = v47 + 4;
    TempBufferIndicesStored = v14;
    TempBufferVerticesStored = v47 + 4;
  }
  while ( v12 != 4 );
}
// 59B8D2: variable 'v10' is possibly undefined
// 59B8D2: variable 'v11' is possibly undefined
// 59B922: variable 'v9' is possibly undefined

//----- (0059BC8C) --------------------------------------------------------
void __fastcall CWaterLevel::ChangeWaterConfiguration(Int32 NewWaterConfig)
{
  if ( CWaterLevel::m_nWaterConfiguration != NewWaterConfig )
  {
    CWaterLevel::m_nWaterConfiguration = NewWaterConfig;
    CWaterLevel::WaterLevelInitialise();
  }
}

//----- (0059BCB0) --------------------------------------------------------
void CWaterLevel::SyncWater()
{
  CWaterLevel::m_nWaterTimeOffset = CTimer::m_snTimeInMilliseconds;
}

//----- (0059BCCC) --------------------------------------------------------
bool __fastcall CWaterLevel::GetGroundLevel(const CVector *pos, float *groundZ, ColData *pColData, float H)
{
  bool v4; // r6
  RwReal v6; // s0
  RwReal v7; // s2
  CVector vecStart; // [sp+1Ch] [bp-4Ch] BYREF
  CEntity *refEntityPtr; // [sp+28h] [bp-40h] BYREF
  CColPoint colPoint; // [sp+2Ch] [bp-3Ch] BYREF

  v4 = 0;
  v6 = pos->x + 0.0;
  v7 = pos->z + H;
  vecStart.y = pos->y + 0.0;
  vecStart.x = v6;
  vecStart.z = v7;
  if ( CWorld::ProcessVerticalLine(
         &vecStart,
         COERCE_FLOAT(LODWORD(H) ^ 0x80000000),
         &colPoint,
         &refEntityPtr,
         1,
         0,
         0,
         0,
         1,
         0,
         0) )
  {
    *groundZ = colPoint.m_vecPosition.z;
    v4 = 1;
    if ( pColData )
    {
      pColData->m_nSurfaceType = colPoint.m_dataB.m_nSurfaceType;
      pColData->m_nPieceType = colPoint.m_dataB.m_nPieceType;
    }
  }
  return v4;
}

//----- (0059BD50) --------------------------------------------------------
bool __fastcall CWaterLevel::GetGroundLevel_WS(const CVector *pos, float *groundZ, ColData *pColData, float H)
{
  float x; // s16
  float y; // s18
  bool v10; // r5
  RwReal v11; // s0
  CVector vecStart; // [sp+1Ch] [bp-74h] BYREF
  CEntity *refEntityPtr; // [sp+28h] [bp-68h] BYREF
  CColPoint colPoint; // [sp+2Ch] [bp-64h] BYREF

  x = pos->x;
  if ( (unsigned int)(int)floorf((float)(pos->x / 50.0) + 60.0) > 0x77 )
    return 0;
  y = pos->y;
  v10 = 0;
  if ( (unsigned int)(int)floorf((float)(y / 50.0) + 60.0) <= 0x77 )
  {
    v11 = pos->z + H;
    vecStart.y = y + 0.0;
    vecStart.x = x + 0.0;
    vecStart.z = v11;
    if ( CWorld::ProcessVerticalLine(
           &vecStart,
           COERCE_FLOAT(LODWORD(H) ^ 0x80000000),
           &colPoint,
           &refEntityPtr,
           1,
           0,
           0,
           0,
           1,
           0,
           0) )
    {
      *groundZ = colPoint.m_vecPosition.z;
      v10 = 1;
      if ( pColData )
      {
        pColData->m_nSurfaceType = colPoint.m_dataB.m_nSurfaceType;
        pColData->m_nPieceType = colPoint.m_dataB.m_nPieceType;
      }
    }
  }
  return v10;
}

//----- (0059BE3C) --------------------------------------------------------
bool __fastcall CWaterLevel::IsLocationOutOfWorldBounds_WS(const CVector *pos, int32 nBorderValue)
{
  float y; // s18
  float v4; // r5
  float v5; // r0
  int32 v6; // s0
  bool v7; // cc
  char v9; // r3
  char v10; // r2

  y = pos->y;
  v4 = floorf((float)(pos->x / 50.0) + 60.0);
  v5 = floorf((float)(y / 50.0) + 60.0);
  v6 = (int)v5;
  v7 = (int)v4 <= nBorderValue;
  if ( (int)v4 >= nBorderValue )
  {
    LODWORD(v5) = 120 - nBorderValue;
    v7 = 120 - nBorderValue <= (int)v4;
  }
  if ( v7 )
    return 1;
  v9 = 0;
  v10 = 0;
  if ( v6 < nBorderValue )
    v9 = 1;
  if ( SLODWORD(v5) <= v6 )
    v10 = 1;
  return v10 | v9;
}

//----- (0059BEC8) --------------------------------------------------------
bool __fastcall CWaterLevel::GetWaterDepth(const CVector *pos, float *pWaterDepth, float *pWaterZ, float *pGroundZ)
{
  bool v8; // r4
  RwReal v9; // s2
  RwReal v10; // s0
  RwReal z; // s0
  float v13; // [sp+20h] [bp-58h] BYREF
  CVector vecStart; // [sp+24h] [bp-54h] BYREF
  CEntity *refEntityPtr; // [sp+30h] [bp-48h] BYREF
  CColPoint colPoint; // [sp+34h] [bp-44h] BYREF

  v8 = 0;
  if ( CWaterLevel::GetWaterLevelNoWaves(pos->x, pos->y, pos->z, &v13, 0, 0) )
  {
    v9 = pos->x + 0.0;
    v10 = pos->z + 30.0;
    vecStart.y = pos->y + 0.0;
    vecStart.x = v9;
    vecStart.z = v10;
    v8 = 1;
    if ( CWorld::ProcessVerticalLine(&vecStart, -30.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
      z = colPoint.m_vecPosition.z;
    else
      z = -100.0;
    if ( pWaterDepth )
      *pWaterDepth = v13 - z;
    if ( pWaterZ )
      *pWaterZ = v13;
    if ( pGroundZ )
      *pGroundZ = z;
  }
  return v8;
}

//----- (0059BF84) --------------------------------------------------------
void CWaterLevel::RenderWaterFog()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  float v2; // s20
  float v3; // s16
  float v4; // s18
  float v5; // s22
  unsigned __int64 v6; // kr00_8
  float alpha; // s24
  int v8; // s0
  float v9; // s16
  signed int v10; // r4
  int v11; // r3
  int v12; // r8
  __int16 *v13; // r1
  float v14; // s2
  float v15; // s18
  float v16; // s4
  float v17; // s6
  int v18; // r1
  int v19; // r11
  float v20; // r0
  RwIm3DVertex *v21; // r1
  int green; // r2
  int blue; // r3
  int v24; // r0
  int v25; // r0
  int v26; // [sp+1Ch] [bp-8Ch]
  int v27; // [sp+20h] [bp-88h]
  int v28; // [sp+28h] [bp-80h]
  float v29[6]; // [sp+30h] [bp-78h]
  float v30[24]; // [sp+48h] [bp-60h]

  if ( !CWaterLevel::m_bWaterFog || !CWaterLevel::m_bWaterFogScript )
    return;
  if ( CWeather::UnderWaterness >= CPostEffects::m_fWaterFXStartUnderWaterness
    || (v2 = CWeather::WaterFogFXControl,
        !(int)(float)(CWeather::WaterFogFXControl * (float)CWaterLevel::m_WaterFogDensity)) )
  {
    gWaterFogIndex = 0;
    return;
  }
  v3 = (float)(int)(float)(CWeather::WaterFogFXControl * (float)CWaterLevel::m_WaterFogDensity);
  v4 = CWaterLevel::m_fWaterFogHeight;
  v26 = gWaterFogIndex;
  gWaterFogIndex = 0;
  if ( gbPlayerIsInsideWaterFog == 1 )
  {
    v1.n64_u32[0] = 1.0;
    v0.n64_f32[0] = fWaterFogInsideFader + (float)(CWaterLevel::m_fWaterFogInsideFadeSpeed * CTimer::ms_fTimeStep);
    LODWORD(v5) = vmin_f32(v0, v1).n64_u32[0];
    v6 = LODWORD(v5) | 0x4220000000000000LL;
    LODWORD(fWaterFogVolumeLeaveFadeWaitTimer) = HIDWORD(v6);
    LODWORD(fWaterFogInsideFader) = v6;
LABEL_13:
    gbPlayerIsInsideWaterFog = 0;
    if ( v5 > 0.0 )
    {
      alpha = (float)CWaterLevel::m_WaterFogInsideCol._anon_0._anon_0.alpha;
      CPostEffects::ImmediateModeRenderStatesStore();
      CPostEffects::ImmediateModeRenderStatesSet();
      CPostEffects::DrawQuad(
        0.0,
        0.0,
        (float)RsGlobal.screenWidth,
        (float)RsGlobal.screenHeight,
        CWaterLevel::m_WaterFogInsideCol._anon_0._anon_0.red,
        CWaterLevel::m_WaterFogInsideCol._anon_0._anon_0.green,
        CWaterLevel::m_WaterFogInsideCol._anon_0._anon_0.blue,
        (int)(float)(v2 * (float)(int)(float)(v5 * alpha)),
        0);
      CPostEffects::ImmediateModeRenderStatesReStore();
      if ( fWaterFogInsideFader == 1.0 )
        return;
    }
    goto LABEL_15;
  }
  fWaterFogVolumeLeaveFadeWaitTimer = fWaterFogVolumeLeaveFadeWaitTimer - CTimer::ms_fTimeStep;
  if ( fWaterFogVolumeLeaveFadeWaitTimer > 0.0 )
  {
    v5 = fWaterFogInsideFader;
    goto LABEL_13;
  }
  fWaterFogVolumeLeaveFadeWaitTimer = 0.0;
  fWaterFogInsideFader = fWaterFogInsideFader - (float)(CWaterLevel::m_fWaterFogInsideFadeSpeed * CTimer::ms_fTimeStep);
  v5 = fWaterFogInsideFader;
  if ( fWaterFogInsideFader >= 0.0 )
    goto LABEL_13;
  gbPlayerIsInsideWaterFog = 0;
  fWaterFogInsideFader = 0.0;
LABEL_15:
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  v8 = (int)(float)((float)(1.0 - fWaterFogInsideFader) * v3);
  if ( v26 >= 1 )
  {
    v9 = v4 / v3;
    v10 = 0;
    v11 = 0;
    v12 = CWaterLevel::m_WaterFogCol._anon_0._anon_0.alpha << 24;
    do
    {
      v13 = &CWaterLevel::ms_WaterFog.minX[v11];
      v14 = (float)v13[140];
      v27 = v11;
      v15 = CWaterLevel::ms_WaterFog.z[v11];
      v16 = (float)v13[70];
      v17 = (float)v13[210];
      v30[0] = (float)*v13;
      v30[3] = v30[0];
      v30[5] = v30[0];
      v30[1] = v14;
      v30[2] = v14;
      v29[0] = v16;
      v29[3] = v16;
      v29[5] = v17;
      v29[1] = v16;
      v29[2] = v17;
      v30[4] = v14;
      v29[4] = v17;
      if ( v8 >= 1 )
      {
        v18 = 0;
        do
        {
          v19 = 0;
          v28 = v18;
          do
          {
            v20 = v29[v19];
            TempVertexBuffer.m_3d[v10].position.x = v30[v19];
            v21 = &TempVertexBuffer.m_3d[v10];
            green = CWaterLevel::m_WaterFogCol._anon_0._anon_0.green;
            v21->position.y = v20;
            blue = CWaterLevel::m_WaterFogCol._anon_0._anon_0.blue;
            v24 = CWaterLevel::m_WaterFogCol._anon_0._anon_0.red | v12;
            v21->position.z = v15;
            v21->color = (RwRGBA_0)(v24 | (green << 8) | (blue << 16));
            v25 = v10 + 1;
            if ( v10 < 0 )
            {
              ++v10;
            }
            else
            {
              ++v10;
              if ( v25 == 2046 )
              {
                v10 = 0;
                if ( RwIm3DTransform(TempVertexBuffer.m_3d, 0x7FEu, 0, 8u) )
                {
                  RwIm3DRenderPrimitive(rwPRIMTYPETRILIST);
                  RwIm3DEnd();
                  v10 = 0;
                }
              }
            }
            ++v19;
          }
          while ( v19 != 6 );
          v15 = v9 + v15;
          v18 = v28 + 1;
        }
        while ( v28 + 1 != v8 );
      }
      v11 = v27 + 1;
    }
    while ( v27 + 1 != v26 );
    if ( v10 > 0 )
    {
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, v10, 0, 8u) )
      {
        RwIm3DRenderPrimitive(rwPRIMTYPETRILIST);
        RwIm3DEnd();
      }
    }
  }
  sub_198D5C();
}
// 59C04A: variable 'v0' is possibly undefined
// 59C04A: variable 'v1' is possibly undefined
// 0: using guessed type int dword_0;
// A1DCA0: using guessed type char gbPlayerIsInsideWaterFog;

//----- (0059C3B4) --------------------------------------------------------
CObject *__fastcall CWaterLevel::CreateBeachToy(const CVector *pos, eBeachToy beachToy)
{
  int32 v3; // r6
  int v4; // r0
  int v5; // r8
  __int16 **v6; // r0
  __int16 *v7; // r0
  __int16 **v8; // r0
  CObject *v9; // r5
  __int64 v10; // kr00_8
  CMatrix *m_pMat; // r3
  RwReal z; // r0
  RwReal *p_tz; // r1
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v16; // r0
  RwMatrix *v17; // r1
  int (**v18)(void); // r0

  if ( CObject::nNoTempObjects > 0x95u )
    return 0;
  if ( beachToy != BEACHTOY_LOUNGE_ANY )
  {
    v3 = MI_BEACHBALL;
    if ( beachToy != BEACHTOY_BEACHTOWEL_ANY
      || ((v4 = ((unsigned __int8)rand() + 3) & 7, v4 == 7) ? (beachToy = BEACHTOY_BEACHTOWEL01) : (beachToy = dword_59C51C[v4]),
          CObject::nNoTempObjects < 0x91u) )
    {
      v5 = 0;
      switch ( beachToy )
      {
        case BEACHTOY_BEACHBALL:
          v6 = MI_BEACHBALL_ptr;
          goto LABEL_14;
        case BEACHTOY_LOUNGE_WOOD_UP:
          goto LABEL_11;
        case BEACHTOY_LOUNGE_TOWEL_UP:
          goto LABEL_13;
        case BEACHTOY_LOUNGE_WOOD_DN:
          goto LABEL_12;
        case BEACHTOY_LOTION:
          v8 = &MI_LOTION_ptr;
          goto LABEL_20;
        case BEACHTOY_BEACHTOWEL01:
          v8 = (__int16 **)&MI_BEACHTOWEL01_ptr;
          goto LABEL_20;
        case BEACHTOY_BEACHTOWEL02:
          v8 = &MI_BEACHTOWEL02_ptr;
          goto LABEL_20;
        case BEACHTOY_BEACHTOWEL03:
          v8 = &MI_BEACHTOWEL03_ptr;
          goto LABEL_20;
        case BEACHTOY_BEACHTOWEL04:
          v8 = &MI_BEACHTOWEL04_ptr;
LABEL_20:
          v7 = *v8;
          v5 = 1;
          goto LABEL_21;
        default:
          goto LABEL_22;
      }
    }
    return 0;
  }
  switch ( rand() & 7 )
  {
    case 1:
    case 7:
LABEL_11:
      v6 = MI_LOUNGE_WOOD_UP_ptr;
      break;
    case 3:
    case 5:
LABEL_12:
      v6 = (__int16 **)&MI_LOUNGE_WOOD_DN_ptr;
      break;
    default:
LABEL_13:
      v6 = MI_LOUNGE_TOWEL_UP_ptr;
      break;
  }
LABEL_14:
  v7 = *v6;
  v5 = 0;
LABEL_21:
  v3 = (unsigned __int16)*v7;
LABEL_22:
  v9 = (CObject *)CObject::operator new(0x184u);
  CObject::CObject(v9, v3, 1);
  if ( !v9 )
    return 0;
  v10 = *(_QWORD *)&pos->x;
  m_pMat = v9->m_pMat;
  z = pos->z;
  if ( m_pMat )
  {
    LODWORD(m_pMat->tx) = v10;
    v9->m_pMat->ty = *((float *)&v10 + 1);
    p_tz = &v9->m_pMat->tz;
  }
  else
  {
    *(_QWORD *)&v9->m_transform.m_translate.x = v10;
    p_tz = &v9->m_transform.m_translate.z;
  }
  *p_tz = z;
  m_pRwObject = v9->m_pRwObject;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    v16 = v9->m_pMat;
    v17 = (RwMatrix *)(parent + 16);
    if ( v16 )
      CMatrix::UpdateRwMatrix(v16, v17);
    else
      CSimpleTransform::UpdateRwMatrix(&v9->m_transform, v17);
  }
  v9->m_vecTurnSpeed.y = 0.0;
  v9->m_vecTurnSpeed.z = 0.0;
  v9->ObjectCreatedBy = 3;
  v18 = v9->_vptr$CPlaceable;
  *(_QWORD *)&v9->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&v9->m_vecMoveSpeed.z = 0LL;
  ((void (__fastcall *)(CObject *, int))v18[5])(v9, v5);
  ++CObject::nNoTempObjects;
  v9->m_nEndOfLifeTime = CTimer::m_snTimeInMilliseconds + 43200000;
  CWorld::Add(v9);
  return v9;
}
// 59C51C: using guessed type int dword_59C51C[7];
// 6768C8: using guessed type __int16 *MI_BEACHTOWEL02_ptr;
// 676A94: using guessed type __int16 *MI_LOUNGE_WOOD_UP_ptr[2];
// 677998: using guessed type __int16 *MI_BEACHTOWEL04_ptr;
// 677BB8: using guessed type __int16 *MI_LOUNGE_TOWEL_UP_ptr[3];
// 678190: using guessed type __int16 *MI_BEACHBALL_ptr[2];
// 6781D4: using guessed type __int16 *MI_BEACHTOWEL03_ptr;
// 678200: using guessed type __int16 *MI_LOTION_ptr;

//----- (0059C570) --------------------------------------------------------
CPlantSurfProp *__fastcall CPlantSurfPropMgr::GetSurfProperties(uint16 nSurfaceType)
{
  if ( nSurfaceType <= 0xB1u )
    return CPlantSurfPropMgr::m_SurfPropPtrTab[nSurfaceType];
  else
    return 0;
}

//----- (0059C588) --------------------------------------------------------
void CScripted2dEffects::Init()
{
  UInt16 *v0; // r0
  CEffectUserList *v1; // r1
  float *v2; // r2
  int v3; // r6
  CScriptedEffectPairs *v4; // r5

  *(_QWORD *)&CScripted2dEffects::ms_activated[48] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_activated[56] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_activated[32] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_activated[40] = 0LL;
  *(_QWORD *)CScripted2dEffects::ms_activated = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_activated[8] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_activated[16] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_activated[24] = 0LL;
  memset(CScripted2dEffects::ms_effectSequenceTaskIDs, 255, sizeof(CScripted2dEffects::ms_effectSequenceTaskIDs));
  v0 = CScripted2dEffects::ScriptReferenceIndex;
  v1 = CScripted2dEffects::ms_userLists;
  v2 = CScripted2dEffects::ms_radii;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[48] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[56] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[32] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[40] = 0LL;
  *(_QWORD *)CScripted2dEffects::ms_useAgainFlags = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[8] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[16] = 0LL;
  *(_QWORD *)&CScripted2dEffects::ms_useAgainFlags[24] = 0LL;
  v3 = 0;
  do
  {
    v4 = &CScripted2dEffects::ms_effectPairs[v3];
    *v0++ = 1;
    v1->m_userTypes[0] = -1;
    v1->m_userTypes[1] = -1;
    v1->m_userTypes[2] = -1;
    v1->m_userTypes[3] = -1;
    v1->m_userTypesByPedType[0] = -1;
    v1->m_userTypesByPedType[1] = -1;
    v1->m_userTypesByPedType[2] = -1;
    v1->m_userTypesByPedType[3] = -1;
    v1->m_bUseList = 0;
    ++v1;
    v4->m_pairs[0].m_iPartnerUseMode2 = -1;
    v4->m_pairs[1].m_iPartnerUseMode2 = -1;
    v4->m_pairs[0].m_iEffect1 = -1;
    v4->m_pairs[0].m_iWaitingTask1 = -1;
    v4->m_pairs[0].m_iPartnerTask1 = -1;
    v4->m_pairs[0].m_iPartnerUseMode1 = -1;
    v4->m_pairs[0].m_iEffect2 = -1;
    v4->m_pairs[0].m_iWaitingTask2 = -1;
    v4->m_pairs[0].m_bUsePartnerImmediately = 0;
    v4->m_pairs[1].m_bUsePartnerImmediately = 0;
    v4->m_pairs[2].m_iPartnerUseMode2 = -1;
    v4->m_pairs[1].m_iEffect1 = -1;
    v4->m_pairs[1].m_iWaitingTask1 = -1;
    v4->m_pairs[1].m_iPartnerTask1 = -1;
    v4->m_pairs[1].m_iPartnerUseMode1 = -1;
    v4->m_pairs[1].m_iEffect2 = -1;
    v4->m_pairs[1].m_iWaitingTask2 = -1;
    CScripted2dEffects::ms_effectPairs[v3++].m_iNoOfPairs = 0;
    v4->m_pairs[2].m_iEffect1 = -1;
    v4->m_pairs[2].m_iWaitingTask1 = -1;
    v4->m_pairs[2].m_iPartnerTask1 = -1;
    v4->m_pairs[2].m_iPartnerUseMode1 = -1;
    v4->m_pairs[2].m_iEffect2 = -1;
    v4->m_pairs[2].m_iWaitingTask2 = -1;
    v4->m_pairs[2].m_bUsePartnerImmediately = 0;
    v4->m_pairs[3].m_iPartnerUseMode2 = -1;
    v4->m_pairs[3].m_iEffect1 = -1;
    v4->m_pairs[3].m_iWaitingTask1 = -1;
    v4->m_pairs[3].m_iPartnerTask1 = -1;
    v4->m_pairs[3].m_iPartnerUseMode1 = -1;
    v4->m_pairs[3].m_iEffect2 = -1;
    v4->m_pairs[3].m_iWaitingTask2 = -1;
    *v2++ = -1.0;
    v4->m_pairs[3].m_bUsePartnerImmediately = 0;
  }
  while ( v3 != 64 );
}

//----- (0059C6B0) --------------------------------------------------------
void __fastcall CScriptedEffectPairs::Flush(CScriptedEffectPairs *this)
{
  this->m_pairs[0].m_iPartnerUseMode2 = -1;
  this->m_pairs[0].m_iEffect2 = -1;
  this->m_pairs[0].m_iWaitingTask2 = -1;
  this->m_pairs[0].m_iPartnerTask1 = -1;
  this->m_pairs[0].m_iPartnerUseMode1 = -1;
  this->m_pairs[0].m_iEffect1 = -1;
  this->m_pairs[0].m_iWaitingTask1 = -1;
  this->m_pairs[0].m_bUsePartnerImmediately = 0;
  this->m_pairs[1].m_iPartnerUseMode2 = -1;
  this->m_pairs[1].m_iEffect1 = -1;
  this->m_pairs[1].m_iWaitingTask1 = -1;
  this->m_pairs[1].m_iPartnerTask1 = -1;
  this->m_pairs[1].m_iPartnerUseMode1 = -1;
  this->m_pairs[1].m_iEffect2 = -1;
  this->m_pairs[1].m_iWaitingTask2 = -1;
  this->m_pairs[1].m_bUsePartnerImmediately = 0;
  this->m_pairs[2].m_iPartnerUseMode2 = -1;
  this->m_pairs[2].m_bUsePartnerImmediately = 0;
  this->m_pairs[2].m_iEffect1 = -1;
  this->m_pairs[2].m_iWaitingTask1 = -1;
  this->m_pairs[2].m_iPartnerTask1 = -1;
  this->m_pairs[2].m_iPartnerUseMode1 = -1;
  this->m_pairs[2].m_iEffect2 = -1;
  this->m_pairs[2].m_iWaitingTask2 = -1;
  this->m_pairs[3].m_bUsePartnerImmediately = 0;
  this->m_pairs[3].m_iPartnerUseMode2 = -1;
  this->m_pairs[3].m_iEffect1 = -1;
  this->m_pairs[3].m_iWaitingTask1 = -1;
  this->m_pairs[3].m_iPartnerTask1 = -1;
  this->m_pairs[3].m_iPartnerUseMode1 = -1;
  this->m_pairs[3].m_iEffect2 = -1;
  this->m_pairs[3].m_iWaitingTask2 = -1;
  this->m_iNoOfPairs = 0;
}

//----- (0059C704) --------------------------------------------------------
void __fastcall CScriptedEffectPair::CScriptedEffectPair(CScriptedEffectPair *this)
{
  this->m_iEffect1 = -1;
  this->m_iWaitingTask1 = -1;
  this->m_iPartnerTask1 = -1;
  this->m_iPartnerUseMode1 = -1;
  this->m_iEffect2 = -1;
  this->m_iWaitingTask2 = -1;
  this->m_iPartnerUseMode2 = -1;
  this->m_bUsePartnerImmediately = 0;
}

//----- (0059C71E) --------------------------------------------------------
void __fastcall CScriptedEffectPair::Flush(CScriptedEffectPair *this)
{
  this->m_iEffect1 = -1;
  this->m_iWaitingTask1 = -1;
  this->m_iPartnerTask1 = -1;
  this->m_iPartnerUseMode1 = -1;
  this->m_iEffect2 = -1;
  this->m_iWaitingTask2 = -1;
  this->m_iPartnerUseMode2 = -1;
  this->m_bUsePartnerImmediately = 0;
}

//----- (0059C73A) --------------------------------------------------------
void __fastcall CScriptedEffectPairs::CScriptedEffectPairs(CScriptedEffectPairs *this)
{
  this->m_pairs[0].m_iPartnerUseMode2 = -1;
  this->m_pairs[0].m_iEffect2 = -1;
  this->m_pairs[0].m_iWaitingTask2 = -1;
  this->m_pairs[0].m_iPartnerTask1 = -1;
  this->m_pairs[0].m_iPartnerUseMode1 = -1;
  this->m_pairs[0].m_iEffect1 = -1;
  this->m_pairs[0].m_iWaitingTask1 = -1;
  this->m_pairs[0].m_bUsePartnerImmediately = 0;
  this->m_pairs[1].m_iPartnerUseMode2 = -1;
  this->m_pairs[1].m_iEffect1 = -1;
  this->m_pairs[1].m_iWaitingTask1 = -1;
  this->m_pairs[1].m_iPartnerTask1 = -1;
  this->m_pairs[1].m_iPartnerUseMode1 = -1;
  this->m_pairs[1].m_iEffect2 = -1;
  this->m_pairs[1].m_iWaitingTask2 = -1;
  this->m_pairs[1].m_bUsePartnerImmediately = 0;
  this->m_pairs[2].m_iPartnerUseMode2 = -1;
  this->m_pairs[2].m_bUsePartnerImmediately = 0;
  this->m_pairs[2].m_iEffect1 = -1;
  this->m_pairs[2].m_iWaitingTask1 = -1;
  this->m_pairs[2].m_iPartnerTask1 = -1;
  this->m_pairs[2].m_iPartnerUseMode1 = -1;
  this->m_pairs[2].m_iEffect2 = -1;
  this->m_pairs[2].m_iWaitingTask2 = -1;
  this->m_pairs[3].m_bUsePartnerImmediately = 0;
  this->m_pairs[3].m_iPartnerUseMode2 = -1;
  this->m_pairs[3].m_iEffect1 = -1;
  this->m_pairs[3].m_iWaitingTask1 = -1;
  this->m_pairs[3].m_iPartnerTask1 = -1;
  this->m_pairs[3].m_iPartnerUseMode1 = -1;
  this->m_pairs[3].m_iEffect2 = -1;
  this->m_pairs[3].m_iWaitingTask2 = -1;
  this->m_iNoOfPairs = 0;
}

//----- (0059C790) --------------------------------------------------------
int32 __fastcall CScripted2dEffects::AddScripted2DEffect(const float fRadius)
{
  int32 result; // r0
  CEffectUserList *v3; // r3
  float *v4; // r2
  CScriptedEffectPairs *v5; // r1

  result = 0;
  v3 = CScripted2dEffects::ms_userLists;
  v4 = CScripted2dEffects::ms_radii;
  v5 = CScripted2dEffects::ms_effectPairs;
  while ( CScripted2dEffects::ms_activated[result] )
  {
    ++v4;
    ++v3;
    ++v5;
    if ( result++ >= 63 )
      return -1;
  }
  CScripted2dEffects::ms_activated[result] = 1;
  CScripted2dEffects::ms_effectSequenceTaskIDs[result] = -1;
  v3->m_userTypes[0] = -1;
  v3->m_userTypes[1] = -1;
  v3->m_userTypes[2] = -1;
  v3->m_userTypes[3] = -1;
  v3->m_userTypesByPedType[0] = -1;
  v3->m_userTypesByPedType[1] = -1;
  v3->m_userTypesByPedType[2] = -1;
  v3->m_userTypesByPedType[3] = -1;
  v5->m_pairs[0].m_iPartnerUseMode2 = -1;
  v5->m_pairs[1].m_iPartnerUseMode2 = -1;
  v5->m_pairs[0].m_bUsePartnerImmediately = 0;
  v5->m_pairs[1].m_bUsePartnerImmediately = 0;
  v3->m_bUseList = 0;
  v5->m_pairs[2].m_iPartnerUseMode2 = -1;
  v5->m_pairs[1].m_iEffect1 = -1;
  v5->m_pairs[1].m_iWaitingTask1 = -1;
  v5->m_pairs[1].m_iPartnerTask1 = -1;
  v5->m_pairs[1].m_iPartnerUseMode1 = -1;
  v5->m_pairs[1].m_iEffect2 = -1;
  v5->m_pairs[1].m_iWaitingTask2 = -1;
  v5->m_pairs[2].m_iEffect1 = -1;
  v5->m_pairs[2].m_iWaitingTask1 = -1;
  v5->m_pairs[2].m_iPartnerTask1 = -1;
  v5->m_pairs[2].m_iPartnerUseMode1 = -1;
  v5->m_pairs[2].m_iEffect2 = -1;
  v5->m_pairs[2].m_iWaitingTask2 = -1;
  v5->m_pairs[3].m_bUsePartnerImmediately = 0;
  v5->m_iNoOfPairs = 0;
  v5->m_pairs[0].m_iEffect1 = -1;
  v5->m_pairs[0].m_iWaitingTask1 = -1;
  v5->m_pairs[0].m_iPartnerTask1 = -1;
  v5->m_pairs[0].m_iPartnerUseMode1 = -1;
  v5->m_pairs[0].m_iEffect2 = -1;
  v5->m_pairs[0].m_iWaitingTask2 = -1;
  v5->m_pairs[3].m_iEffect1 = -1;
  v5->m_pairs[3].m_iWaitingTask1 = -1;
  v5->m_pairs[3].m_iPartnerTask1 = -1;
  v5->m_pairs[3].m_iPartnerUseMode1 = -1;
  v5->m_pairs[3].m_iEffect2 = -1;
  v5->m_pairs[3].m_iWaitingTask2 = -1;
  v5->m_pairs[2].m_bUsePartnerImmediately = 0;
  v5->m_pairs[3].m_iPartnerUseMode2 = -1;
  CScripted2dEffects::ms_useAgainFlags[result] = 0;
  *v4 = fRadius;
  return result;
}

//----- (0059C88C) --------------------------------------------------------
void __fastcall CScripted2dEffects::ReturnScripted2DEffect(int32 id)
{
  const C2dEffect *v1; // r4
  const CPedAttractorManager *PedAttractorManager; // r0

  CScripted2dEffects::ms_activated[id] = 0;
  v1 = &CScripted2dEffects::ms_effects[id];
  PedAttractorManager = GetPedAttractorManager();
  sub_18F4B0(PedAttractorManager, v1);
}
// 6760D4: using guessed type char (*CScripted2dEffects::ms_activated)[64];
// 6786D8: using guessed type C2dEffect (*CScripted2dEffects::ms_effects)[64];

//----- (0059C8BC) --------------------------------------------------------
void __fastcall CScriptedEffectPairs::AddPair(CScriptedEffectPairs *this, const CScriptedEffectPair *a)
{
  __int64 v2; // d16
  __int64 v3; // d17
  char *v4; // r2
  __int64 v5; // d18
  __int64 v6; // d19

  if ( this->m_iNoOfPairs <= 3 )
  {
    v2 = *(_QWORD *)&a->m_iEffect1;
    v3 = *(_QWORD *)&a->m_iPartnerTask1;
    v4 = (char *)this + 36 * this->m_iNoOfPairs;
    v5 = *(_QWORD *)&a->m_iEffect2;
    v6 = *(_QWORD *)&a->m_iPartnerTask2;
    v4[36] = a->m_bUsePartnerImmediately;
    *(_QWORD *)(v4 + 4) = v2;
    *(_QWORD *)(v4 + 12) = v3;
    *(_QWORD *)(v4 + 20) = v5;
    *(_QWORD *)(v4 + 28) = v6;
    ++this->m_iNoOfPairs;
  }
}

//----- (0059C8F0) --------------------------------------------------------
const CScriptedEffectPairs *__fastcall CScripted2dEffects::GetEffectPairs(const C2dEffect *pEffect)
{
  int v1; // r1
  int v2; // r0

  v1 = (char *)pEffect - (char *)CScripted2dEffects::ms_effects + 64;
  v2 = 0;
  while ( 1 )
  {
    v1 -= 64;
    if ( !v1 )
      break;
    if ( v2++ > 62 )
    {
      v2 = -1;
      return &CScripted2dEffects::ms_effectPairs[v2];
    }
  }
  return &CScripted2dEffects::ms_effectPairs[v2];
}

//----- (0059C924) --------------------------------------------------------
int __fastcall CScripted2dEffects::GetIndex(const C2dEffect *pEffect)
{
  int v1; // r3
  int v2; // r1
  int v3; // r2
  int result; // r0

  v1 = 0;
  v2 = (char *)CScripted2dEffects::ms_effects - (char *)pEffect;
  do
  {
    v3 = v2;
    v2 += 64;
    result = v1;
    if ( v2 == 64 )
      break;
    ++v1;
  }
  while ( result <= 62 );
  if ( v3 )
    return -1;
  return result;
}

//----- (0059C95C) --------------------------------------------------------
bool C2dEffect::PluginAttach()
{
  g2dEffectPluginOffset = RpGeometryRegisterPlugin(
                            4,
                            0x253F2F8u,
                            RpGeometry2dEffectConstructor,
                            RpGeometry2dEffectDestructor,
                            RpGeometry2dEffectCopy);
  RpGeometryRegisterPluginStream(
    0x253F2F8u,
    RpGeometry2dEffectStreamRead,
    RpGeometry2dEffectStreamWrite,
    RpGeometry2dEffectStreamGetSize);
  return g2dEffectPluginOffset != -1;
}

//----- (0059C9C8) --------------------------------------------------------
void *__fastcall RpGeometry2dEffectConstructor(void *pGeometry, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pGeometry + g2dEffectPluginOffset) = 0;
  return pGeometry;
}

//----- (0059C9DC) --------------------------------------------------------
void *__fastcall RpGeometry2dEffectDestructor(void *pGeometry, RwInt32 offset, RwInt32 size)
{
  int v4; // r4
  unsigned int i; // r6
  _DWORD *v6; // r0
  unsigned int v7; // r1
  _DWORD *v8; // r8
  int v9; // r0
  RwTexture_0 *v10; // r0
  RwTexture_0 *v11; // r0
  void *v12; // r0
  RpAtomic_0 *v13; // r5
  RwFrame_0 *parent; // r11

  v4 = 0;
  for ( i = 0; ; ++i )
  {
    v6 = *(_DWORD **)((char *)pGeometry + g2dEffectPluginOffset);
    v7 = v6 ? *v6 : 0;
    if ( i >= v7 )
      break;
    v8 = &v6[v4];
    v9 = LOBYTE(v6[v4 + 4]);
    if ( v9 == 7 )
    {
      v12 = (void *)v8[11];
      if ( v12 )
      {
        CMemoryMgr::Free(v12);
        v8[11] = 0;
      }
      v13 = (RpAtomic_0 *)v8[12];
      if ( v13 )
      {
        parent = (RwFrame_0 *)v13->object.object.parent;
        if ( parent )
        {
          RpAtomicSetFrame((RpAtomic_0 *)v8[12], 0);
          RwFrameDestroy(parent);
        }
        RpAtomicDestroy(v13);
        v8[12] = 0;
      }
    }
    else if ( !v9 )
    {
      v10 = (RwTexture_0 *)v8[13];
      if ( v10 )
      {
        RwTextureDestroy(v10);
        v8[13] = 0;
      }
      v11 = (RwTexture_0 *)v8[14];
      if ( v11 )
      {
        RwTextureDestroy(v11);
        v8[14] = 0;
      }
    }
    v4 += 16;
  }
  if ( v6 )
    CMemoryMgr::Free(v6);
  return pGeometry;
}

//----- (0059CA98) --------------------------------------------------------
void *__fastcall RpGeometry2dEffectCopy(void *pGeometry, const void *pOtherGeometry, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pGeometry + g2dEffectPluginOffset) = 0;
  return pGeometry;
}

//----- (0059CAAC) --------------------------------------------------------
RwStream_0 *__fastcall RpGeometry2dEffectStreamRead(
        RwStream_0 *pStream,
        RwInt32 len,
        void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  _DWORD *v7; // r0
  char *v8; // r8
  unsigned int i; // r6
  __int64 v10; // d17
  char *v11; // r9
  RwUInt32 v12; // r2
  __int64 v13; // d17
  __int64 v14; // d17
  int v15; // r1
  int v16; // r2
  __int64 v17; // d17
  _QWORD *v18; // r0
  __int64 v19; // d19
  __int64 v20; // d16
  __int64 v21; // d17
  __int64 v22; // d22
  __int64 v23; // d23
  __int64 v24; // d20
  __int64 v25; // d21
  __int64 v26; // d17
  __int64 v27; // d17
  RwInt32 v28; // r0
  RwInt32 *v30; // [sp+14h] [bp-94h]
  char *v31; // [sp+18h] [bp-90h]
  RwInt32 v32; // [sp+24h] [bp-84h] BYREF
  RwUInt32 length; // [sp+28h] [bp-80h] BYREF
  RwInt32 ints; // [sp+2Ch] [bp-7Ch] BYREF
  __int64 v35; // [sp+30h] [bp-78h] BYREF
  __int64 v36; // [sp+38h] [bp-70h]
  _BYTE v37[30]; // [sp+40h] [bp-68h] BYREF
  __int64 v38; // [sp+5Eh] [bp-4Ah] BYREF
  __int64 v39; // [sp+66h] [bp-42h]
  __int64 v40; // [sp+6Eh] [bp-3Ah]
  __int64 v41; // [sp+76h] [bp-32h]
  __int64 v42; // [sp+7Eh] [bp-2Ah]

  if ( RpGeometry2dEffectStreamRead(RwStream *,int,void *,int,int)::particleTxdSlot == -1 )
    RpGeometry2dEffectStreamRead(RwStream *,int,void *,int,int)::particleTxdSlot = CTxdStore::FindTxdSlot("particle");
  RwStreamReadInt32(pStream, &ints, 4u);
  if ( ints )
  {
    v31 = (char *)pData;
    v7 = CMemoryMgr::Malloc((ints << 6) | 4);
    v30 = v7;
    if ( ints )
    {
      v8 = (char *)(v7 + 1);
      for ( i = 0; i < ints; ++i )
      {
        v11 = &v8[64 * i];
        RwStreamReadReal(pStream, (RwReal *)v11, 0xCu);
        RwStreamReadInt32(pStream, &v32, 4u);
        v11[12] = v32;
        RwStreamReadInt32(pStream, (RwInt32 *)&length, 4u);
        switch ( v11[12] )
        {
          case 0:
            v12 = length;
            if ( length == 76 )
            {
              RwStreamRead(pStream, &v35, 0x4Cu);
              v10 = v36;
              *((_QWORD *)v11 + 2) = v35;
              *((_QWORD *)v11 + 3) = v10;
              *((_DWORD *)v11 + 8) = *(_DWORD *)v37;
              *(_DWORD *)(v11 + 38) = *(_DWORD *)&v37[4];
              *((_WORD *)v11 + 18) = v37[8] | (BYTE4(v41) << 8);
              v11[42] = BYTE3(v41);
              *(_WORD *)(v11 + 43) = 0;
              v11[45] = 100;
              CTxdStore::PushCurrentTxd();
            }
            else
            {
              if ( length != 80 )
                goto LABEL_26;
              RwStreamRead(pStream, &v35, 0x50u);
              v13 = v36;
              *((_QWORD *)v11 + 2) = v35;
              *((_QWORD *)v11 + 3) = v13;
              *((_DWORD *)v11 + 8) = *(_DWORD *)v37;
              *(_DWORD *)(v11 + 38) = *(_DWORD *)&v37[4];
              *((_WORD *)v11 + 18) = v37[8] | (BYTE4(v41) << 8);
              v11[42] = BYTE3(v41);
              *(_WORD *)(v11 + 43) = *(_WORD *)((char *)&v41 + 5);
              v11[45] = HIBYTE(v41);
              CTxdStore::PushCurrentTxd();
            }
            CTxdStore::SetCurrentTxd(RpGeometry2dEffectStreamRead(RwStream *,int,void *,int,int)::particleTxdSlot, 0);
            *((_DWORD *)v11 + 12) = RwTextureRead(&v37[9], 0);
            *((_DWORD *)v11 + 13) = RwTextureRead((const RwChar *)&v38 + 3, 0);
            CTxdStore::PopCurrentTxd();
            break;
          case 1:
            v12 = length;
            if ( length != 24 )
              goto LABEL_26;
            RwStreamRead(pStream, &v35, 0x18u);
            strcpy(v11 + 16, (const char *)&v35);
            break;
          case 3:
            v12 = length;
            if ( length != 56 )
              goto LABEL_26;
            RwStreamRead(pStream, &v35, 0x38u);
            *((_DWORD *)v11 + 4) = HIDWORD(v35);
            *(_QWORD *)(v11 + 20) = v36;
            *((_DWORD *)v11 + 7) = *(_DWORD *)v37;
            *((_DWORD *)v11 + 8) = *(_DWORD *)&v37[4];
            *((_DWORD *)v11 + 9) = *(_DWORD *)&v37[8];
            *((_DWORD *)v11 + 10) = *(_DWORD *)&v37[12];
            *((_DWORD *)v11 + 11) = *(_DWORD *)&v37[16];
            *((_DWORD *)v11 + 12) = *(_DWORD *)&v37[20];
            v11[52] = v35;
            v11[53] = BYTE2(v38);
            v11[54] = BYTE6(v38);
            v11[55] = v39;
            strncpy(v11 + 56, &v37[24], 8u);
            break;
          case 6:
            v12 = length;
            *(_WORD *)&v37[24] = 6144;
            if ( (length | 4) != 44 )
              goto LABEL_26;
            RwStreamRead(pStream, &v35, length);
            v14 = v36;
            *((_QWORD *)v11 + 2) = v35;
            *((_QWORD *)v11 + 3) = v14;
            v15 = *(_DWORD *)&v37[4];
            v16 = *(_DWORD *)&v37[8];
            *((_DWORD *)v11 + 8) = *(_DWORD *)v37;
            *((_DWORD *)v11 + 9) = v15;
            *((_DWORD *)v11 + 10) = v16;
            *((_DWORD *)v11 + 11) = *(_DWORD *)&v37[12];
            strncpy(v11 + 48, &v37[16], 8u);
            *((_WORD *)v11 + 28) = *(_WORD *)&v37[24];
            v11[58] = v37[26];
            break;
          case 7:
            v12 = length;
            if ( length != 88 )
              goto LABEL_26;
            RwStreamRead(pStream, &v35, 0x58u);
            v17 = v36;
            *((_QWORD *)v11 + 2) = v35;
            *((_QWORD *)v11 + 3) = v17;
            *((_DWORD *)v11 + 8) = *(_DWORD *)v37;
            *((_WORD *)v11 + 18) = *(_WORD *)&v37[4];
            *((_DWORD *)v11 + 11) = 0;
            v18 = CMemoryMgr::Malloc(0x40u);
            *((_DWORD *)v11 + 10) = v18;
            v19 = v42;
            v20 = *(_QWORD *)&v37[6];
            v21 = *(_QWORD *)&v37[14];
            v22 = *(_QWORD *)&v37[22];
            v23 = v38;
            v24 = v39;
            v25 = v40;
            v18[6] = v41;
            v18[7] = v19;
            v18[4] = v24;
            v18[5] = v25;
            *v18 = v20;
            v18[1] = v21;
            v18 += 2;
            *v18 = v22;
            v18[1] = v23;
            break;
          case 8:
            v12 = length;
            if ( length != 4 )
              goto LABEL_26;
            RwStreamRead(pStream, &v35, 4u);
            *((_DWORD *)v11 + 4) = v35;
            break;
          case 9:
            v12 = length;
            if ( length != 12 )
              goto LABEL_26;
            RwStreamRead(pStream, &v35, 0xCu);
            *((_QWORD *)v11 + 2) = v35;
            v11[24] = v36;
            break;
          case 10:
            v12 = length;
            if ( length == 40 )
            {
              RwStreamRead(pStream, &v35, 0x28u);
              v11[52] = v37[20];
              v26 = v36;
              *((_QWORD *)v11 + 2) = v35;
              *((_QWORD *)v11 + 3) = v26;
              v27 = *(_QWORD *)&v37[8];
              *((_QWORD *)v11 + 4) = *(_QWORD *)v37;
              *((_QWORD *)v11 + 5) = v27;
              *((_DWORD *)v11 + 12) = *(_DWORD *)&v37[16];
            }
            else
            {
LABEL_26:
              RwStreamSkip(pStream, v12);
              --i;
              --ints;
            }
            break;
          default:
            break;
        }
        v28 = ints;
      }
    }
    else
    {
      v28 = 0;
    }
    *v30 = v28;
    *(_DWORD *)&v31[g2dEffectPluginOffset] = v30;
  }
  return pStream;
}

//----- (0059CF02) --------------------------------------------------------
RwInt32 __fastcall RpGeometry2dEffectStreamGetSize(const void *pData, RwInt32 offset, RwInt32 size)
{
  return -1;
}

//----- (0059CF08) --------------------------------------------------------
int __fastcall C2dEffect::Roadsign_GetNumLinesFromFlags(CRoadsignAttrFlags rsFlags)
{
  int v1; // r0
  int result; // r0

  v1 = *(_BYTE *)&rsFlags & 3;
  switch ( v1 )
  {
    case 0:
      return 4;
    case 3:
      return 3;
    case 2:
      LOWORD(result) = 2;
      break;
    default:
      LOWORD(result) = 1;
      break;
  }
  return (unsigned __int16)result;
}

//----- (0059CF2A) --------------------------------------------------------
int __fastcall C2dEffect::Roadsign_GetNumLettersFromFlags(unsigned int rsFlags)
{
  int v1; // r0
  int result; // r0

  v1 = (rsFlags >> 2) & 3;
  switch ( v1 )
  {
    case 0:
      return 16;
    case 3:
      return 8;
    case 2:
      LOWORD(result) = 4;
      break;
    default:
      LOWORD(result) = 2;
      break;
  }
  return (unsigned __int16)result;
}

//----- (0059CF4E) --------------------------------------------------------
int __fastcall C2dEffect::Roadsign_GetPaletteIDFromFlags(unsigned int rsFlags)
{
  int v1; // r0
  int result; // r0

  v1 = (rsFlags >> 4) & 3;
  switch ( v1 )
  {
    case 0:
      return 0;
    case 3:
      return 3;
    case 2:
      LOWORD(result) = 2;
      break;
    default:
      LOWORD(result) = 1;
      break;
  }
  return (unsigned __int16)result;
}

//----- (0059CF80) --------------------------------------------------------
void CBirds::Init()
{
  CBirds::aBirds[1].bActive = 0;
  CBirds::aBirds[0].bActive = 0;
  CBirds::aBirds[2].bActive = 0;
  CBirds::aBirds[3].bActive = 0;
  CBirds::aBirds[4].bActive = 0;
  CBirds::aBirds[5].bActive = 0;
  CBirds::NumberOfBirds = 0;
  CBirds::bHasBirdBeenShot = 0;
}

//----- (0059CFC0) --------------------------------------------------------
void CBirds::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  CSimpleTransform *p_tx; // r0
  float v3; // s16
  float y; // s18
  Int32 v5; // r4
  float z; // s20
  Int32 v7; // r5
  Int32 v8; // r9
  float v9; // s24
  float v10; // s22
  float v11; // s26
  float v12; // s20
  float v13; // r4
  float v14; // s0
  float v15; // s24
  float v16; // r10
  CBird *v17; // r0
  bool *p_bActive; // r0
  _BOOL4 bActive; // t1
  CBird *v20; // r1
  int v21; // r4
  float v22; // s16
  UInt32 v23; // r9
  float v24; // s18
  float v25; // s20
  CBird *v26; // r8
  float v27; // s24
  float v28; // s22
  float v29; // r5
  float v30; // r0
  float v31; // s0
  CBird *v32; // r5
  RwReal v33; // s8
  RwReal v34; // s0
  RwReal v35; // s10
  RwReal v36; // s4
  RwReal v37; // s6
  float x; // [sp+18h] [bp-70h]
  float pWaterZ; // [sp+24h] [bp-64h] BYREF
  CVector v40; // [sp+28h] [bp-60h] BYREF
  CVector v41; // 0:r0.12
  CVector v42; // 0:r3.4,4:^0.8

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v3 = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  if ( CGame::currArea == AREA_MAIN_MAP )
  {
    v5 = CBirds::NumberOfBirds;
    if ( CBirds::NumberOfBirds <= 5
      && (unsigned __int8)(CClock::ms_nGameClockHours - 6) <= 0xFu
      && (CTimer::m_FrameCounter & 0x1FF) == 6 )
    {
      z = p_tx->m_translate.z;
      v7 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(6 - v5)) + 1;
      if ( TheCamera.DistanceToWater < 30.0 )
      {
        v8 = 0;
        if ( v7 < 1 )
          goto LABEL_30;
        goto LABEL_16;
      }
      if ( CWeather::WeatherRegion != 4 )
      {
        v8 = 2;
        if ( v7 < 1 )
          goto LABEL_30;
        goto LABEL_16;
      }
      v8 = 1;
      if ( v7 >= 3 - CBirds::NumberOfBirds )
        v7 = 3 - CBirds::NumberOfBirds;
      if ( v7 >= 1 )
      {
LABEL_16:
        rand();
        rand();
        if ( (v8 & 3) == 1 )
        {
          v9 = 15.0;
          v10 = 80.0;
          v11 = 10.0;
        }
        else if ( (v8 & 3) != 0 )
        {
          v9 = 2.0;
          v10 = 40.0;
          v11 = 8.0;
        }
        else
        {
          v9 = 4.0;
          v10 = 45.0;
          v11 = 9.0;
        }
        v12 = z + (float)(v9 + (float)(v11 * (float)((float)rand() * 4.6566e-10)));
        if ( v12 > 5.0 )
        {
          if ( (rand() & 1) != 0 )
          {
            v14 = (float)(unsigned __int8)rand() * 0.024531;
          }
          else
          {
            v40.x = TheCamera.m_cameraMatrix.xy;
            v40.y = TheCamera.m_cameraMatrix.yy;
            v40.z = 0.0;
            if ( TheCamera.m_cameraMatrix.xy == 0.0 )
              v40.x = 0.01;
            CVector::Normalise(&v40);
            v13 = atan2f(v40.x, v40.y);
            v14 = v13 + (float)((float)((unsigned __int8)rand() - 128) * 0.0039062);
          }
          v15 = sinf(v14);
          v16 = y + (float)(v10 * cosf(v14));
          if ( !CWaterLevel::GetWaterLevelNoWaves(v3 + (float)(v10 * v15), v16, v12, &pWaterZ, 0, 0)
            || (float)(pWaterZ + 4.0) < v12 )
          {
            v40.z = 0.0;
            v40.x = TheCamera.m_cameraMatrix.xy;
            v40.y = TheCamera.m_cameraMatrix.yy;
            CVector::Normalise(&v40);
            v42.z = v12;
            v41.y = v16;
            v41.x = v3 + (float)(v10 * v15);
            v41.z = v12;
            v42.x = v3 + (float)(v40.x * 8.0);
            v42.y = y + (float)(v40.y * 8.0);
            CBirds::CreateNumberOfBirds(v41, v42, v7, v8, 1);
          }
        }
      }
    }
  }
LABEL_30:
  v17 = &CBirds::aBirds[CTimer::m_FrameCounter % 6];
  bActive = v17->bActive;
  p_bActive = &v17->bActive;
  if ( bActive )
  {
    v20 = &CBirds::aBirds[CTimer::m_FrameCounter % 6];
    if ( (float)((float)((float)(v20->Coors.x - v3) * (float)(v20->Coors.x - v3))
               + (float)((float)(v20->Coors.y - y) * (float)(v20->Coors.y - y))) > (float)(v20->Range * v20->Range) )
    {
      *p_bActive = 0;
      --CBirds::NumberOfBirds;
    }
  }
  v1.n64_u32[0] = 1.0;
  v21 = 0;
  v22 = CTimer::ms_fTimeStep / 50.0;
  v23 = CTimer::m_snTimeInMilliseconds;
  v0.n64_f32[0] = (float)(CTimer::ms_fTimeStep / 50.0) * 0.5;
  v24 = vmin_f32(v0, v1).n64_f32[0];
  v25 = 1.0 - v24;
  x = CTimer::ms_fTimeStep * 0.002;
  do
  {
    if ( CBirds::aBirds[v21].bActive && CBirds::aBirds[v21].Activity == 1 && v23 > CBirds::aBirds[v21].StartMovementTime )
    {
      v26 = &CBirds::aBirds[v21];
      v27 = CBirds::aBirds[v21].DesiredSpeed.x;
      v28 = CBirds::aBirds[v21].DesiredSpeed.y;
      if ( CBirds::aBirds[v21].bCircle )
      {
        v29 = cosf(x);
        v30 = sinf(x);
        v31 = v27 * v30;
        v27 = (float)(v27 * v29) + (float)(v28 * v30);
        v28 = (float)(v28 * v29) - v31;
        v26->DesiredSpeed.x = v27;
        v26->DesiredSpeed.y = v28;
      }
      v32 = &CBirds::aBirds[v21];
      v33 = (float)(v27 * v24) + (float)(CBirds::aBirds[v21].Speed.x * v25);
      v34 = (float)(v28 * v24) + (float)(CBirds::aBirds[v21].Speed.y * v25);
      v35 = (float)(CBirds::aBirds[v21].DesiredSpeed.z * v24) + (float)(CBirds::aBirds[v21].Speed.z * v25);
      v36 = (float)(v34 * v22) + CBirds::aBirds[v21].Coors.y;
      v37 = (float)(v35 * v22) + CBirds::aBirds[v21].Coors.z;
      v32->Coors.x = CBirds::aBirds[v21].Coors.x + (float)(v33 * v22);
      v32->Coors.y = v36;
      v32->Coors.z = v37;
      v32->Speed.x = v33;
      v32->Speed.y = v34;
      v32->Speed.z = v35;
      v32->Orientation = atan2f(v27, v28);
    }
    ++v21;
  }
  while ( v21 != 6 );
}
// 59D33E: variable 'v0' is possibly undefined
// 59D33E: variable 'v1' is possibly undefined

//----- (0059D4D4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CBirds::CreateNumberOfBirds(
        CVector CreationCoors,
        CVector TargetCoors,
        Int32 NumBirdsToBeCreated,
        Int32 Type,
        int bLineTest)
{
  int *v5; // r1
  float v6; // s16
  Int32 v7; // r5
  bool *p_bActive; // r8
  int v9; // r0
  int v10; // r10
  CBird *v11; // r4
  float z; // s4
  RwReal v13; // s0
  RwReal v14; // s2
  float *p_y; // r11
  RwReal v16; // s2
  RwReal v17; // s4
  int v18; // r5
  float x; // s28
  CBird *v20; // r8
  float y; // s31
  int v22; // r5
  int v23; // r6
  float v24; // s2
  float v25; // s0
  float v26; // s2
  bool *p_bCircle; // r8
  CBird *v28; // r4
  float v29; // s0
  RwReal v30; // s2
  RwReal v31; // s6
  RwReal v32; // s0
  __int64 v33; // d16
  UInt8 v34; // r0
  UInt8 v35; // r0
  CBird *v36; // r4
  float v37; // s0
  RwReal v38; // s2
  RwReal v39; // s6
  RwReal v40; // s0
  __int64 v41; // d16
  UInt8 v42; // r0
  UInt8 v43; // r0
  int v44; // r4
  float v45; // s0
  CBird *v46; // r5
  float v47; // s0
  RwReal v48; // s4
  RwReal v49; // s6
  RwReal v50; // s0
  __int64 v51; // d16
  RwReal v52; // r0
  _DWORD *p_FlapTime; // [sp+54h] [bp-8Ch]
  Int32 v55; // [sp+58h] [bp-88h]
  float *v56; // [sp+5Ch] [bp-84h]
  float *v57; // [sp+60h] [bp-80h]
  float *v58; // [sp+64h] [bp-7Ch]
  CVector v59; // [sp+68h] [bp-78h] BYREF
  CVector vecEnd; // [sp+74h] [bp-6Ch] BYREF

  v5 = dword_59D9BC;
  if ( Type == 1 )
    v5 = &dword_59D9BC[1];
  v6 = *(float *)v5;
  v7 = NumBirdsToBeCreated;
  vecEnd.y = TargetCoors.y;
  if ( !Type )
    v6 = 45.0;
  vecEnd.x = TargetCoors.x;
  vecEnd.z = TargetCoors.z;
  if ( NumBirdsToBeCreated >= 1 )
  {
    v58 = BirdOffsetInFlockX;
    v57 = BirdOffsetInFlockY;
    v56 = BirdOffsetInFlockZ;
    while ( 1 )
    {
      p_bActive = &CBirds::aBirds[0].bActive;
      if ( !CBirds::aBirds[0].bActive )
        break;
      p_bActive = &CBirds::aBirds[1].bActive;
      if ( !CBirds::aBirds[1].bActive )
      {
        v9 = 1;
        goto LABEL_19;
      }
      p_bActive = &CBirds::aBirds[2].bActive;
      if ( !CBirds::aBirds[2].bActive )
      {
        v9 = 2;
        goto LABEL_19;
      }
      if ( !CBirds::aBirds[3].bActive )
      {
        p_bActive = &CBirds::aBirds[3].bActive;
        v9 = 3;
        goto LABEL_19;
      }
      if ( !CBirds::aBirds[4].bActive )
      {
        p_bActive = &CBirds::aBirds[4].bActive;
        v9 = 4;
        goto LABEL_19;
      }
      if ( !CBirds::aBirds[5].bActive )
      {
        p_bActive = &CBirds::aBirds[5].bActive;
        v9 = 5;
LABEL_19:
        v10 = v9;
        v11 = &CBirds::aBirds[v9];
        z = vecEnd.z;
        v13 = vecEnd.x - CreationCoors.x;
        v14 = vecEnd.y - CreationCoors.y;
        v11->Coors = CreationCoors;
        p_y = &v11->Coors.y;
        v59.x = v13;
        v59.y = v14;
        v59.z = z - CreationCoors.z;
        CVector::Normalise(&v59);
        v16 = (float)((float)(v6 * v59.y) * 2.4) + v11->Coors.y;
        v17 = (float)((float)(v6 * v59.z) * 2.4) + v11->Coors.z;
        vecEnd.x = (float)((float)(v6 * v59.x) * 2.4) + v11->Coors.x;
        vecEnd.y = v16;
        vecEnd.z = v17;
        if ( !bLineTest || CWorld::GetIsLineOfSightClear(&v11->Coors, &vecEnd, 1, 0, 0, 0, 0, 0, 0) )
        {
          v55 = v7;
          v18 = rand();
          x = v59.x;
          *p_bActive = 1;
          v20 = &CBirds::aBirds[v10];
          y = v59.y;
          v20->Activity = 1;
          v20->Orientation = atan2f(x, y);
          v20->StartMovementTime = 0;
          v22 = v18 % 31;
          v23 = 1000 - 12 * v22;
          v20->FlapTime = v23;
          p_FlapTime = &v20->FlapTime;
          v24 = *v57;
          v11->Coors.x = *v58 + v11->Coors.x;
          v25 = v24 + *p_y;
          v26 = *v56;
          *p_y = v25;
          v11->Coors.z = v26 + v11->Coors.z;
          v20->bCircle = 0;
          p_bCircle = &v20->bCircle;
          *((float *)p_bCircle - 3) = v6;
          switch ( Type )
          {
            case 2:
              v36 = &CBirds::aBirds[v10];
              v37 = (float)((float)v22 * 0.02) + 5.0;
              v38 = v37 * x;
              v39 = v37 * y;
              v40 = v37 * v59.z;
              v36->DesiredSpeed.x = v38;
              v36->DesiredSpeed.y = v39;
              v41 = *(_QWORD *)&v36->DesiredSpeed.x;
              v36->DesiredSpeed.z = v40;
              v36->Speed.z = v36->DesiredSpeed.z;
              *(_QWORD *)&v36->Speed.x = v41;
              v42 = rand() | 0x80;
              v36->B = v42;
              v36->G = v42;
              v36->R = v42;
              v43 = rand() | 0x80;
              v36->WingB = v43;
              v36->WingG = v43;
              v36->WingR = v43;
              v36->Scale = (float)((float)((float)rand() * 4.6566e-10) * 0.1) + 0.5;
              *p_FlapTime = 500 - 6 * v22;
              break;
            case 1:
              v44 = 12 * v22;
              v45 = (float)v22;
              v46 = &CBirds::aBirds[v10];
              v47 = (float)(v45 * 0.02) + 3.0;
              v48 = v47 * x;
              v49 = v47 * y;
              v50 = v47 * v59.z;
              v46->DesiredSpeed.x = v48;
              v46->DesiredSpeed.y = v49;
              v46->DesiredSpeed.z = v50;
              *(_DWORD *)&v46->R = 1342836510;
              v51 = *(_QWORD *)&v46->DesiredSpeed.x;
              v52 = v46->DesiredSpeed.z;
              *(_WORD *)&v46->WingG = 2575;
              v46->Speed.z = v52;
              *(_QWORD *)&v46->Speed.x = v51;
              v46->Scale = (float)((float)((float)rand() * 4.6566e-10) * 0.5) + 2.0;
              *p_FlapTime = 1500 - v44;
              if ( (rand() & 4) != 0 )
                *p_FlapTime = "ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly";
              if ( (rand() & 8) != 0 )
                *p_bCircle = 1;
              break;
            case 0:
              v28 = &CBirds::aBirds[v10];
              v29 = (float)((float)v22 * 0.02) + 4.0;
              v30 = v29 * x;
              v31 = v29 * y;
              v32 = v29 * v59.z;
              v28->DesiredSpeed.x = v30;
              v28->DesiredSpeed.y = v31;
              v33 = *(_QWORD *)&v28->DesiredSpeed.x;
              v28->DesiredSpeed.z = v32;
              v28->Speed.z = v28->DesiredSpeed.z;
              *(_QWORD *)&v28->Speed.x = v33;
              v34 = (rand() & 0x3F) + 80;
              v28->B = v34;
              v28->G = v34;
              v28->R = v34;
              v35 = (rand() & 0x3F) - 76;
              v28->WingB = v35;
              v28->WingG = v35;
              v28->WingR = v35;
              v28->Scale = (float)((float)((float)rand() * 4.6566e-10) * 0.4) + 0.8;
              *p_FlapTime = v23;
              break;
          }
          v7 = v55;
          ++CBirds::NumberOfBirds;
        }
      }
      --v7;
      ++v56;
      ++v57;
      ++v58;
      if ( !v7 )
        return;
    }
    v9 = 0;
    goto LABEL_19;
  }
}
// 59D4D4: fragmented variable at 0:r3.4,4:^E8.8 may be wrong
// 59D4D4: variables would overlap: 0:r3.4,4:^E8.8 and ^E8.4
// 59D4D4: variables would overlap: 0:r3.4,4:^E8.8 and ^EC.4
// 59D9BC: using guessed type int dword_59D9BC[2];

//----- (0059DA40) --------------------------------------------------------
void CBirds::Render()
{
  unsigned int v0; // r5
  float32x2_t v1; // d9
  float32x2_t v2; // d12
  unsigned int v3; // r4
  int v4; // r6
  const RwV3d_0 *p_tx; // r10
  int32x4_t v6; // q7
  int v7; // r8
  float *p_x; // r4
  float v9; // r1
  float v10; // r2
  float v11; // r3
  char *v12; // r9
  float v13; // r0
  int v14; // r0
  int v15; // r6
  CBird *v16; // r0
  float Orientation; // r11
  float Scale; // r8
  float v19; // s20
  float v20; // s0
  char v21; // r0
  int32x4_t v22; // q13
  int v23; // r10
  unsigned int v24; // r0
  int32x4_t v25; // q3
  int32x4_t v26; // q8
  int32x4_t v27; // q0
  int32x4_t v28; // q12
  int32x4_t v29; // q15
  unsigned __int64 v30; // d20
  RwImVertexIndex *v31; // r1
  int32x4_t v32; // q14
  int32x4_t v33; // q1
  char *v34; // r9
  unsigned int v35; // r8
  unsigned int v36; // r6
  float v37; // s20
  float v38; // s18
  float v39; // r8
  float v40; // s18
  float v41; // r11
  float v42; // r6
  float v43; // r0
  float v44; // s18
  CMatrix *m_pMat; // r1
  float v46; // s17
  CSimpleTransform *p_m_transform; // r2
  float32x2_t v48; // d16
  unsigned __int64 v49; // d1
  float v50; // s2
  unsigned int v51; // r0
  float v52; // s20
  unsigned int v53; // r6
  char *v54; // r1
  int v55; // r10
  _BYTE *v56; // r0
  RwReal y; // r1
  RwReal z; // r2
  Int32 *v59; // r11
  VertexBuffer *v60; // r9
  float *v61; // r8
  int v62; // r3
  unsigned int *v63; // r3
  float v64; // r2
  float v65; // r1
  RwReal v66; // r12
  Int32 v67; // r0
  RwReal v68; // r3
  int v69; // r2
  RwIm3DVertex *v70; // r2
  Int32 *v71; // r2
  Int32 v72; // r1
  bool ClipFarPlane[4]; // [sp+0h] [bp-1C8h] BYREF
  Int32 *v74; // [sp+10h] [bp-1B8h]
  Int32 *v75; // [sp+14h] [bp-1B4h]
  CBird *v76; // [sp+18h] [bp-1B0h]
  CCamera *v77; // [sp+1Ch] [bp-1ACh]
  int32x4_t v78; // [sp+20h] [bp-1A8h]
  uint32 *v79; // [sp+30h] [bp-198h]
  CBird *v80; // [sp+34h] [bp-194h]
  RwImVertexIndex *v81; // [sp+38h] [bp-190h]
  Int32 *v82; // [sp+3Ch] [bp-18Ch]
  int32x4_t v83; // [sp+40h] [bp-188h]
  int32x4_t v84; // [sp+50h] [bp-178h]
  int32x4_t v85; // [sp+60h] [bp-168h]
  int32x4_t v86; // [sp+70h] [bp-158h]
  unsigned int *v87; // [sp+8Ch] [bp-13Ch]
  int32x4_t v88; // [sp+90h] [bp-138h]
  const RwV3d_0 *v89; // [sp+ACh] [bp-11Ch]
  CBird *v90; // [sp+B0h] [bp-118h]
  CBird *v91; // [sp+B4h] [bp-114h]
  uint32 *v92; // [sp+B8h] [bp-110h]
  CBird *v93; // [sp+BCh] [bp-10Ch]
  int v94; // [sp+C0h] [bp-108h]
  CBird *v95; // [sp+C4h] [bp-104h]
  _BYTE *v96; // [sp+C8h] [bp-100h]
  _BYTE *v97; // [sp+CCh] [bp-FCh]
  _BYTE *v98; // [sp+D0h] [bp-F8h]
  _BYTE *v99; // [sp+D4h] [bp-F4h]
  float v100; // [sp+D8h] [bp-F0h]
  Int32 *v101; // [sp+DCh] [bp-ECh]
  VertexBuffer *v102; // [sp+E0h] [bp-E8h]
  Int32 *v103; // [sp+E4h] [bp-E4h]
  float *v104; // [sp+E8h] [bp-E0h]
  float32x2_t *v105; // [sp+ECh] [bp-DCh]
  float v106; // [sp+F0h] [bp-D8h]
  CVector v107; // [sp+F4h] [bp-D4h] BYREF
  CVector v; // [sp+100h] [bp-C8h] BYREF
  RwV3d_0 pResult; // [sp+10Ch] [bp-BCh] BYREF
  CMatrix m; // [sp+118h] [bp-B0h] BYREF
  float pScaleY; // [sp+160h] [bp-68h] BYREF
  float pScaleX; // [sp+164h] [bp-64h] BYREF

  v3 = (unsigned int)ClipFarPlane;
  if ( CBirds::NumberOfBirds )
  {
    v2.n64_u32[0] = 1.0;
    v4 = 0;
    TempBufferVerticesStored = 0;
    p_tx = (const RwV3d_0 *)&m.tx;
    TempBufferIndicesStored = 0;
    v95 = CBirds::aBirds;
    v89 = (const RwV3d_0 *)&m.tx;
    v93 = CBirds::aBirds;
    v92 = &CTimer::m_snTimeInMilliseconds;
    v91 = CBirds::aBirds;
    v88.n128_u64[0] = 0x600000000LL;
    v88.n128_u64[1] = 7LL;
    v90 = CBirds::aBirds;
    v87 = (unsigned int *)&TempBufferVerticesStored;
    v86.n128_u64[0] = 0x200000003LL;
    v86.n128_u64[1] = 0x500000002LL;
    v85.n128_u64[0] = 0x200000004LL;
    v85.n128_u64[1] = 0x500000003LL;
    v84.n128_u64[0] = 0x100000000LL;
    v84.n128_u64[1] = 3LL;
    v83.n128_u64[0] = 0x200000005LL;
    v83.n128_u64[1] = 0x300000005LL;
    v6.n128_u64[0] = 0x300000000LL;
    v6.n128_u64[1] = 1LL;
    v81 = TempBufferRenderIndexList;
    v82 = &TempBufferIndicesStored;
    v78.n128_u64[0] = 0x300000002LL;
    v78.n128_u64[1] = 0x400000002LL;
    v80 = CBirds::aBirds;
    v79 = &CTimer::m_snTimeInMilliseconds;
    v77 = &TheCamera;
    v76 = CBirds::aBirds;
    v103 = &TempBufferVerticesStored;
    v102 = &TempVertexBuffer;
    v75 = &TempBufferIndicesStored;
    v74 = &TempBufferVerticesStored;
    v101 = &TempBufferVerticesStored;
    do
    {
      v7 = v4;
      if ( v95[v4].bActive )
      {
        v106 = *(float *)&v3;
        m.m_pRwMat = 0;
        m.m_owner = 0;
        p_x = &v93[v4].Coors.x;
        v9 = *p_x;
        v10 = p_x[1];
        v11 = p_x[2];
        v105 = (float32x2_t *)(p_x + 1);
        CMatrix::SetTranslate(&m, v9, v10, v11);
        v104 = p_x;
        v12 = (char *)(p_x + 14);
        if ( (unsigned __int8)(*((_BYTE *)p_x + 56) - 1) <= 1u )
        {
          v7 = v4;
          v13 = sinf((float)(6.28 / (float)v91[v4].FlapTime) * (float)((*v92 + 100 * v4) % v91[v4].FlapTime));
          m.tz = m.tz + (float)(v13 * 0.1);
        }
        v14 = CSprite::CalcScreenCoors(p_tx, &pResult, &pScaleX, &pScaleY, 0, 1);
        v3 = LODWORD(v106);
        if ( v14 == 1 )
        {
          v94 = v4;
          v15 = v7 * 17;
          v16 = &v90[v7];
          Orientation = v16->Orientation;
          m.xz = 0.0;
          m.yz = 0.0;
          Scale = v16->Scale;
          v19 = cosf(Orientation);
          v1.n64_f32[0] = Scale;
          v20 = sinf(Orientation);
          v21 = *v12;
          m.zz = Scale;
          m.zx = 0.0;
          m.zy = 0.0;
          m.xx = v19 * Scale;
          m.yx = -(float)(v20 * Scale);
          m.xy = v20 * Scale;
          m.yy = v19 * Scale;
          if ( (unsigned __int8)(v21 - 1) <= 1u )
          {
            v22 = v88;
            v23 = v15;
            v24 = *v87;
            v25 = v85;
            v26 = vdupq_n_s32(*v87);
            v27 = v84;
            v28 = vdupq_n_s32(*v87 + 8);
            v29 = v83;
            v30 = vmovn_s32(vaddq_s32(v26, v86)).n64_u64[0];
            v31 = &v81[*v82];
            v32 = v78;
            v33 = vaddq_s32(v28, v86);
            *(int16x4_t *)v31 = vmovn_s32(vaddq_s32(v26, v6));
            *(int16x4_t *)(v31 + 30) = vmovn_s32(vaddq_s32(v28, v6));
            *((int16x4_t *)v31 + 1) = vmovn_s32(vaddq_s32(v26, v32));
            *((int16x4_t *)v31 + 2) = vmovn_s32(vaddq_s32(v26, v29));
            *(int16x4_t *)(v31 + 34) = vmovn_s32(vaddq_s32(v28, v32));
            *(int16x4_t *)(v31 + 38) = vmovn_s32(vaddq_s32(v28, v29));
            *((int16x4_t *)v31 + 3) = vmovn_s32(vaddq_s32(v26, v27));
            *(int16x4_t *)(v31 + 42) = vmovn_s32(vaddq_s32(v28, v27));
            *((_QWORD *)v31 + 4) = v30;
            *(int16x4_t *)(v31 + 46) = vmovn_s32(v33);
            *((int16x4_t *)v31 + 5) = vmovn_s32(vaddq_s32(v26, v25));
            *(int16x4_t *)(v31 + 50) = vmovn_s32(vaddq_s32(v28, v25));
            *((int16x4_t *)v31 + 6) = vmovn_s32(vaddq_s32(v26, v22));
            *(int16x4_t *)(v31 + 54) = vmovn_s32(vaddq_s32(v28, v22));
            v31[28] = v24 + 7;
            v31[58] = v24 + 15;
            v31[29] = v24 + 6;
            v31[59] = v24 + 14;
            v34 = (char *)(&v80->Coors.x + v15);
            v35 = *((_DWORD *)v34 + 11);
            v36 = *v79 + 100 * v94;
            v37 = 6.28 / (float)v35;
            v38 = vmax_f32(v1, v2).n64_f32[0];
            v27.n128_f32[0] = v37 * (float)(v36 % v35);
            v39 = COERCE_FLOAT(COERCE_UNSIGNED_INT(sinf(v37 * (float)((v36 + v35 / 6) % v35))) ^ 0x80000000) / v38;
            v40 = COERCE_FLOAT(COERCE_UNSIGNED_INT(sinf(v27.n128_f32[0])) ^ 0x80000000) / v38;
            v41 = cosf(v39);
            v42 = sinf(v39);
            v100 = cosf(v40);
            v43 = sinf(v40);
            v44 = v42 * 0.5;
            m_pMat = v77->m_pMat;
            v46 = v41 * 0.5;
            p_m_transform = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_m_transform = &v77->m_transform;
            v48.n64_u64[0] = vsub_f32((float32x2_t)v105->n64_u64[0], *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
            v33.n128_u32[2] = *((_DWORD *)v34 + 13);
            v49 = vmul_f32(v48, v48).n64_u64[0];
            v33.n128_f32[0] = sqrtf(
                                (float)((float)((float)(*v104 - p_m_transform->m_translate.x)
                                              * (float)(*v104 - p_m_transform->m_translate.x))
                                      + *(float *)&v49)
                              + *((float *)&v49 + 1));
            v50 = v43 * 0.5;
            if ( v33.n128_f32[0] <= (float)(v33.n128_f32[2] * 0.7) )
            {
              v51 = 255;
            }
            else
            {
              v33.n128_f32[0] = (float)((float)(v33.n128_f32[0] - (float)(v33.n128_f32[2] * 0.7))
                                      / (float)(v33.n128_f32[2] * -0.3))
                              + 1.0;
              v33.n128_u32[2] = 0;
              v51 = (unsigned int)(float)(vmax_f32((float32x2_t)v33.n128_u64[0], *(float32x2_t *)&v33.n128_i8[8]).n64_f32[0]
                                        * 255.0);
            }
            v1.n64_f32[1] = v44 + v50;
            v52 = v46 + (float)(v100 * 0.5);
            LOBYTE(v53) = (_BYTE)v101;
            v54 = (char *)(&v76->Coors.x + v23);
            v98 = v54 + 62;
            v97 = v54 + 61;
            v96 = v54 + 60;
            v55 = 0;
            v101 = (Int32 *)(v54 + 59);
            LODWORD(v100) = v54 + 58;
            v99 = v54 + 57;
            v104 = (float *)(v51 << 24);
            do
            {
              switch ( v55 )
              {
                case 0:
                case 1:
                case 7:
                  v.z = 0.0;
                  v.x = 0.0;
                  goto LABEL_19;
                case 2:
                case 3:
                  v.z = v44;
                  v.x = v46;
                  goto LABEL_19;
                case 4:
                case 5:
                  v.z = v44 + v50;
                  v.x = v52;
                  LOBYTE(v53) = *v98;
                  LOBYTE(v0) = *v97;
                  v56 = v96;
                  goto LABEL_20;
                case 6:
                  v.x = 0.1;
                  v.z = 0.0;
LABEL_19:
                  LOBYTE(v53) = *(_BYTE *)v101;
                  LOBYTE(v0) = *(_BYTE *)LODWORD(v100);
                  v56 = v99;
LABEL_20:
                  LOBYTE(v3) = *v56;
                  break;
                default:
                  break;
              }
              v.y = CBirds::Render(void)::YCoors[v55];
              operator*(&v107, &m, &v);
              y = v107.y;
              z = v107.z;
              v59 = v103;
              v60 = v102;
              v61 = v104;
              v62 = 9 * (*v103 + v55);
              v102->m_3d[*v103 + v55].position.x = v107.x;
              v63 = (unsigned int *)v60 + v62;
              *((RwReal *)v63 + 1) = y;
              *((RwReal *)v63 + 2) = z;
              v63 += 6;
              v65 = CBirds::Render(void)::UCoors[v55];
              v106 = CBirds::Render(void)::VCoors[v55];
              v64 = v106;
              v105 = (float32x2_t *)LODWORD(v65);
              *v63 = (unsigned int)v61 | (unsigned __int8)v3 | ((unsigned __int8)v0 << 8) | ((unsigned __int8)v53 << 16);
              *((float *)v63 + 1) = v65;
              *((float *)v63 + 2) = v64;
              v.x = -v.x;
              operator*(&v107, &m, &v);
              v66 = v107.y;
              v67 = *v59;
              v68 = v107.z;
              v69 = v55 + *v59;
              ++v55;
              v70 = &v60->m_3d[v69];
              v70[8].position.x = v107.x;
              v3 = (unsigned int)(float)((float)(unsigned __int8)v3 * 0.8);
              v0 = (unsigned int)(float)((float)(unsigned __int8)v0 * 0.8);
              v70[8].position.y = v66;
              v70[8].position.z = v68;
              v53 = (unsigned int)(float)((float)(unsigned __int8)v53 * 0.8);
              v70[8].color = (RwRGBA_0)((unsigned int)v61 | v3 | (v0 << 8) | (v53 << 16));
              LODWORD(v70[8].texCoords.u) = v105;
              v70[8].texCoords.v = v106;
            }
            while ( v55 != 8 );
            v71 = v75;
            v101 = (Int32 *)v53;
            v72 = *v75;
            *v74 = v67 + 16;
            *v71 = v72 + 60;
          }
          p_tx = v89;
          v4 = v94;
        }
        CMatrix::~CMatrix(&m);
      }
      ++v4;
    }
    while ( v4 != 6 );
    if ( TempBufferIndicesStored )
    {
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
      RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCloudTex[1]->raster);
      CBrightLights::RenderOutGeometryBuffer();
    }
  }
}
// 59DE7E: variable 'v1' is possibly undefined
// 59DE7E: variable 'v2' is possibly undefined
// 59E012: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (0059E2B4) --------------------------------------------------------
void CBirds::Shutdown()
{
  if ( CBirds::aBirds[0].bActive )
    CBirds::aBirds[0].bActive = 0;
  if ( CBirds::aBirds[1].bActive )
    CBirds::aBirds[1].bActive = 0;
  if ( CBirds::aBirds[2].bActive )
    CBirds::aBirds[2].bActive = 0;
  if ( CBirds::aBirds[3].bActive )
    CBirds::aBirds[3].bActive = 0;
  if ( CBirds::aBirds[4].bActive )
    CBirds::aBirds[4].bActive = 0;
  if ( CBirds::aBirds[5].bActive )
    CBirds::aBirds[5].bActive = 0;
  CBirds::NumberOfBirds = 0;
}

//----- (0059E384) --------------------------------------------------------
void __fastcall CBirds::HandleGunShot(const CVector *pShotStart, const CVector *pShotEnd)
{
  const CColLine *v4; // r0
  const CColLine *v5; // r0
  const CColLine *v6; // r0
  const CColLine *v7; // r0
  const CColLine *v8; // r0
  const CColLine *v9; // r0
  CColSphere v10; // [sp+0h] [bp-48h] BYREF
  CColLine v11; // [sp+18h] [bp-30h] BYREF

  if ( CBirds::aBirds[0].bActive )
  {
    CColLine::CColLine(&v11, pShotStart, pShotEnd);
    v10.m_vecCentre.z = CBirds::aBirds[0].Coors.z;
    v10.m_fRadius = 0.5;
    *(_QWORD *)&v10.m_vecCentre.x = *(_QWORD *)&CBirds::aBirds[0].Coors.x;
    if ( CCollision::TestLineSphere(v4, &v10) )
    {
      CBirds::bHasBirdBeenShot = 1;
      CBirds::BirdShotAt = CBirds::aBirds[0].Coors;
      CBirds::aBirds[0].bActive = 0;
      --CBirds::NumberOfBirds;
    }
  }
  if ( CBirds::aBirds[1].bActive )
  {
    CColLine::CColLine(&v11, pShotStart, pShotEnd);
    v10.m_vecCentre.z = CBirds::aBirds[1].Coors.z;
    v10.m_fRadius = 0.5;
    *(_QWORD *)&v10.m_vecCentre.x = *(_QWORD *)&CBirds::aBirds[1].Coors.x;
    if ( CCollision::TestLineSphere(v5, &v10) )
    {
      CBirds::bHasBirdBeenShot = 1;
      CBirds::aBirds[1].bActive = 0;
      CBirds::BirdShotAt = CBirds::aBirds[1].Coors;
      --CBirds::NumberOfBirds;
    }
  }
  if ( CBirds::aBirds[2].bActive )
  {
    CColLine::CColLine(&v11, pShotStart, pShotEnd);
    v10.m_vecCentre.z = CBirds::aBirds[2].Coors.z;
    v10.m_fRadius = 0.5;
    *(_QWORD *)&v10.m_vecCentre.x = *(_QWORD *)&CBirds::aBirds[2].Coors.x;
    if ( CCollision::TestLineSphere(v6, &v10) )
    {
      CBirds::bHasBirdBeenShot = 1;
      CBirds::aBirds[2].bActive = 0;
      CBirds::BirdShotAt = CBirds::aBirds[2].Coors;
      --CBirds::NumberOfBirds;
    }
  }
  if ( CBirds::aBirds[3].bActive )
  {
    CColLine::CColLine(&v11, pShotStart, pShotEnd);
    v10.m_vecCentre.z = CBirds::aBirds[3].Coors.z;
    v10.m_fRadius = 0.5;
    *(_QWORD *)&v10.m_vecCentre.x = *(_QWORD *)&CBirds::aBirds[3].Coors.x;
    if ( CCollision::TestLineSphere(v7, &v10) )
    {
      CBirds::bHasBirdBeenShot = 1;
      CBirds::aBirds[3].bActive = 0;
      CBirds::BirdShotAt = CBirds::aBirds[3].Coors;
      --CBirds::NumberOfBirds;
    }
  }
  if ( CBirds::aBirds[4].bActive )
  {
    CColLine::CColLine(&v11, pShotStart, pShotEnd);
    v10.m_vecCentre.z = CBirds::aBirds[4].Coors.z;
    v10.m_fRadius = 0.5;
    *(_QWORD *)&v10.m_vecCentre.x = *(_QWORD *)&CBirds::aBirds[4].Coors.x;
    if ( CCollision::TestLineSphere(v8, &v10) )
    {
      CBirds::bHasBirdBeenShot = 1;
      CBirds::aBirds[4].bActive = 0;
      CBirds::BirdShotAt = CBirds::aBirds[4].Coors;
      --CBirds::NumberOfBirds;
    }
  }
  if ( CBirds::aBirds[5].bActive )
  {
    CColLine::CColLine(&v11, pShotStart, pShotEnd);
    v10.m_vecCentre.z = CBirds::aBirds[5].Coors.z;
    v10.m_fRadius = 0.5;
    *(_QWORD *)&v10.m_vecCentre.x = *(_QWORD *)&CBirds::aBirds[5].Coors.x;
    if ( CCollision::TestLineSphere(v9, &v10) )
    {
      CBirds::bHasBirdBeenShot = 1;
      CBirds::aBirds[5].bActive = 0;
      CBirds::BirdShotAt = CBirds::aBirds[5].Coors;
      --CBirds::NumberOfBirds;
    }
  }
}
// 59E3C2: variable 'v4' is possibly undefined
// 59E42E: variable 'v5' is possibly undefined
// 59E49C: variable 'v6' is possibly undefined
// 59E50C: variable 'v7' is possibly undefined
// 59E57C: variable 'v8' is possibly undefined
// 59E5EC: variable 'v9' is possibly undefined

//----- (0059E6D0) --------------------------------------------------------
void CClouds::Init()
{
  int32 TxdSlot; // r0

  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  gpCloudTex[0] = RwTextureRead((const RwChar *)"cloud1", 0);
  gpCloudTex[1] = RwTextureRead((const RwChar *)"cloudmasked", 0);
  gpMoonMask = RwTextureRead((const RwChar *)"lunar", (const RwChar *)"lunarm");
  CClouds::ms_vc.pTexture[0] = RwTextureRead((const RwChar *)"cloudhigh", (const RwChar *)"cloudhighm");
  CTxdStore::PopCurrentTxd();
  CClouds::CloudRotation = 0.0;
  CClouds::VolumetricCloudsInit();
  *(_QWORD *)CClouds::ms_mf.quadVT = 0x100000000LL;
  *(_QWORD *)&CClouds::ms_mf.quadVT[2] = 2LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[32] = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[40] = 0LL;
  CClouds::ms_mf.quadVT[4] = 2;
  CClouds::ms_mf.quadVT[5] = 3;
  CClouds::ms_mf.windVector.x = 0.06;
  CClouds::ms_mf.windVector.y = 0.06;
  CClouds::ms_mf.windVector.z = 0.0;
  *(_WORD *)&CClouds::ms_mf.bUsed[48] = 0;
  *(_QWORD *)CClouds::ms_mf.bUsed = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[8] = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[16] = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[24] = 0LL;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0059E7F0) --------------------------------------------------------
void CClouds::VolumetricCloudsInit()
{
  CClouds::ms_vc.quadNormal[0].y = 1.0;
  CClouds::ms_vc.quadNormal[0].x = 0.0;
  CClouds::ms_vc.modelY[0] = 0.0;
  CClouds::ms_vc.modelX[0] = -0.5;
  CClouds::ms_vc.modelZ[0] = 0.5;
  CClouds::ms_vc.modelU[0] = 0.0;
  CClouds::ms_vc.modelV[0] = 0.0;
  CClouds::ms_vc.modelX[1] = 0.5;
  CClouds::ms_vc.modelY[1] = 0.0;
  CClouds::ms_vc.modelZ[1] = 0.5;
  CClouds::ms_vc.modelU[1] = 1.0;
  CClouds::ms_vc.modelV[1] = 0.0;
  CClouds::ms_vc.modelX[2] = -0.5;
  CClouds::ms_vc.modelY[2] = 0.0;
  CClouds::ms_vc.modelZ[2] = -0.5;
  CClouds::ms_vc.modelV[2] = 1.0;
  CClouds::ms_vc.modelX[3] = 0.5;
  CClouds::ms_vc.modelY[3] = 0.0;
  CClouds::ms_vc.modelZ[3] = 0.5;
  CClouds::ms_vc.quadNormal[0].z = 0.0;
  CClouds::ms_vc.modelX[4] = 0.5;
  CClouds::ms_vc.modelV[3] = 0.0;
  CClouds::ms_vc.modelY[4] = 0.0;
  CClouds::ms_vc.modelZ[4] = -0.5;
  CClouds::ms_vc.modelV[4] = 1.0;
  CClouds::ms_vc.modelX[5] = -0.5;
  CClouds::ms_vc.modelY[5] = 0.0;
  CClouds::ms_vc.modelZ[5] = -0.5;
  CClouds::ms_vc.modelV[5] = 1.0;
  CClouds::ms_vc.quadNormal[1].y = 0.0;
  CClouds::ms_vc.quadNormal[1].x = 0.0;
  CClouds::ms_vc.quadNormal[1].z = 1.0;
  CClouds::ms_vc.modelX[6] = -0.5;
  CClouds::ms_vc.modelY[6] = 0.5;
  CClouds::ms_vc.modelZ[6] = 0.0;
  CClouds::ms_vc.modelU[6] = 0.0;
  CClouds::ms_vc.modelV[6] = 0.0;
  CClouds::ms_vc.modelX[7] = 0.5;
  CClouds::ms_vc.modelY[7] = 0.5;
  CClouds::ms_vc.modelZ[7] = 0.0;
  CClouds::ms_vc.modelU[7] = 1.0;
  CClouds::ms_vc.modelV[7] = 0.0;
  CClouds::ms_vc.modelX[8] = -0.5;
  CClouds::ms_vc.modelY[8] = -0.5;
  CClouds::ms_vc.modelU[8] = 0.0;
  CClouds::ms_vc.modelV[8] = 1.0;
  CClouds::ms_vc.modelX[9] = 0.5;
  CClouds::ms_vc.modelY[9] = 0.5;
  *(_QWORD *)&CClouds::ms_vc.modelU[2] = 0x3F80000000000000LL;
  *(_QWORD *)&CClouds::ms_vc.modelU[4] = 1065353216LL;
  CClouds::ms_vc.modelV[9] = 0.0;
  CClouds::ms_vc.modelU[9] = 1.0;
  CClouds::ms_vc.modelX[10] = 0.5;
  CClouds::ms_vc.modelY[10] = -0.5;
  CClouds::ms_vc.modelU[10] = 1.0;
  CClouds::ms_vc.modelV[10] = 1.0;
  CClouds::ms_vc.modelX[11] = -0.5;
  CClouds::ms_vc.modelY[11] = -0.5;
  CClouds::ms_vc.modelU[11] = 0.0;
  CClouds::ms_vc.modelV[11] = 1.0;
  CClouds::ms_vc.quadNormal[2].y = 0.0;
  CClouds::ms_vc.quadNormal[2].x = 1.0;
  CClouds::ms_vc.quadNormal[2].z = 0.0;
  CClouds::ms_vc.modelX[12] = 0.0;
  CClouds::ms_vc.modelY[12] = -0.5;
  CClouds::ms_vc.modelZ[12] = 0.5;
  CClouds::ms_vc.modelU[12] = 0.0;
  CClouds::ms_vc.modelV[12] = 0.0;
  CClouds::ms_vc.modelX[13] = 0.0;
  CClouds::ms_vc.modelY[13] = 0.5;
  CClouds::ms_vc.modelZ[13] = 0.5;
  CClouds::ms_vc.modelU[13] = 1.0;
  CClouds::ms_vc.modelV[13] = 0.0;
  CClouds::ms_vc.modelX[14] = 0.0;
  CClouds::ms_vc.modelZ[14] = -0.5;
  CClouds::ms_vc.modelU[14] = 0.0;
  CClouds::ms_vc.modelV[14] = 1.0;
  CClouds::ms_vc.modelX[15] = 0.0;
  CClouds::ms_vc.modelZ[15] = 0.5;
  *(_QWORD *)&CClouds::ms_vc.modelZ[8] = 0LL;
  *(_QWORD *)&CClouds::ms_vc.modelZ[10] = 0LL;
  CClouds::ms_vc.modelV[15] = 0.0;
  CClouds::ms_vc.modelU[15] = 1.0;
  CClouds::ms_vc.modelX[16] = 0.0;
  CClouds::ms_vc.modelZ[16] = -0.5;
  CClouds::ms_vc.modelU[16] = 1.0;
  CClouds::ms_vc.modelV[16] = 1.0;
  CClouds::ms_vc.modelX[17] = 0.0;
  CClouds::ms_vc.modelZ[17] = -0.5;
  CClouds::ms_vc.modelU[17] = 0.0;
  CClouds::ms_vc.modelV[17] = 1.0;
  *(_QWORD *)&CClouds::ms_vc.modelY[14] = 0x3F000000BF000000LL;
  *(_QWORD *)&CClouds::ms_vc.modelY[16] = 0xBF0000003F000000LL;
  memset(&CClouds::ms_vc, 0, 0x168u);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0059EAA0) --------------------------------------------------------
void CClouds::MovingFogInit()
{
  CClouds::ms_mf.quadVT[4] = 2;
  CClouds::ms_mf.quadVT[5] = 3;
  CClouds::ms_mf.windVector.x = 0.06;
  CClouds::ms_mf.windVector.y = 0.06;
  CClouds::ms_mf.windVector.z = 0.0;
  *(_WORD *)&CClouds::ms_mf.bUsed[48] = 0;
  *(_QWORD *)CClouds::ms_mf.quadVT = 0x100000000LL;
  *(_QWORD *)&CClouds::ms_mf.quadVT[2] = 2LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[32] = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[40] = 0LL;
  *(_QWORD *)CClouds::ms_mf.bUsed = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[8] = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[16] = 0LL;
  *(_QWORD *)&CClouds::ms_mf.bUsed[24] = 0LL;
}

//----- (0059EB04) --------------------------------------------------------
void CClouds::Shutdown()
{
  RwTextureDestroy(gpCloudTex[0]);
  gpCloudTex[0] = 0;
  RwTextureDestroy(gpCloudTex[1]);
  gpCloudTex[1] = 0;
  RwTextureDestroy(CClouds::ms_vc.pTexture[0]);
  CClouds::ms_vc.pTexture[0] = 0;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0059EB48) --------------------------------------------------------
void CClouds::Update()
{
  CClouds::CloudRotation = CClouds::CloudRotation
                         + (float)((float)(sinf(TheCamera.Orientation + -0.85) * 0.001) * CWeather::Wind);
  CClouds::IndividualRotation = (unsigned int)(float)((float)((float)((float)((float)(CWeather::Wind
                                                                                    * CTimer::ms_fTimeStep)
                                                                            * 0.5)
                                                                    + 0.3)
                                                            * 60.0)
                                                    + (float)CClouds::IndividualRotation);
}

//----- (0059EBF8) --------------------------------------------------------
void CClouds::Render()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d10
  float32x2_t v3; // d11
  float32x2_t v4; // d12
  int v5; // r0
  int v6; // r1
  int v7; // s20
  CSimpleTransform *p_tx; // r2
  float y; // s4
  float z; // s6
  unsigned int v11; // r10
  float v12; // s0
  int v13; // r4
  float v14; // s0
  int v15; // r11
  float v16; // s0
  CSimpleTransform *p_m_transform; // r2
  float v18; // s6
  float v19; // s4
  float v20; // s2
  RwReal v21; // s0
  char v22; // r0
  CSimpleTransform *v23; // r2
  float v24; // s6
  RwReal v25; // s2
  char v26; // r4
  unsigned int m_nLowCloudsRed; // r8
  unsigned int m_nLowCloudsGreen; // r5
  unsigned int m_nLowCloudsBlue; // r4
  float v30; // s0
  CMatrix *m_pMat; // r6
  float v32; // s0
  float v33; // s0
  int v34; // r5
  float v35; // s4
  float v36; // s2
  CSimpleTransform *v37; // r2
  float v38; // s0
  __int64 v39; // r0
  int i; // r8
  CSimpleTransform *v41; // r1
  float v42; // s4
  float v43; // s6
  uint32 v44; // r5
  uint32 v45; // r4
  CSimpleTransform *v46; // r2
  float x; // s16
  float v48; // s18
  float v49; // s20
  float v50; // s0
  float v51; // s4
  float v52; // s6
  float v53; // s2
  unsigned int R; // [sp+30h] [bp-98h]
  unsigned int G; // [sp+34h] [bp-94h]
  unsigned int B; // [sp+38h] [bp-90h]
  CVector v57; // [sp+3Ch] [bp-8Ch] BYREF
  RwV3d_0 In; // [sp+48h] [bp-80h] BYREF
  float pScaleY; // [sp+54h] [bp-74h] BYREF
  float pScaleX; // [sp+58h] [bp-70h] BYREF
  RwV3d_0 pResult; // [sp+5Ch] [bp-6Ch] BYREF

  if ( !CGame::CanSeeOutSideFromCurrArea() )
    return;
  CCoronas::SunBlockedByClouds = 0;
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  CSprite::InitSpriteBuffer();
  v5 = CClock::ms_nGameClockHours;
  v6 = (int)fabsf(
              (float)((float)((float)CClock::ms_nGameClockSeconds / 60.0)
                    + (float)(CClock::ms_nGameClockMinutes + 60 * CClock::ms_nGameClockHours))
            + -220.0);
  if ( v6 <= 219 )
  {
    v0.n64_f32[0] = CWeather::Foggyness;
    v1.n64_f32[0] = CWeather::CloudCoverage;
    v7 = (int)(float)((float)(1.0 - vmax_f32(v1, v0).n64_f32[0]) * (float)(220 - v6));
    if ( v7 >= 1 )
    {
      In.z = 15.0;
      p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        p_tx = &TheCamera.m_transform;
      y = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      In.x = p_tx->m_translate.x + 0.0;
      In.y = y + -100.0;
      In.z = z + 15.0;
      if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) == 1 )
      {
        v11 = CClock::ms_nGameClockDays;
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        CSprite::RenderOneXLUSprite(
          pResult.x,
          pResult.y,
          CDraw::ms_fFarClipZ,
          pScaleX * (float)((float)((float)CCoronas::MoonSize + (float)CCoronas::MoonSize) + 4.0),
          pScaleY * (float)((float)((float)CCoronas::MoonSize + (float)CCoronas::MoonSize) + 4.0),
          0,
          0,
          0,
          255,
          1.0 / CDraw::ms_fFarClipZ,
          0xFFu,
          0,
          0,
          0.0,
          0.0);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpMoonMask->raster);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        v12 = (float)((float)CCoronas::MoonSize + (float)CCoronas::MoonSize) + 4.0;
        CSprite::RenderOneXLUSprite(
          pResult.x
        + (float)((float)((float)((float)v11 / 31.0) + -0.5)
                * (float)((float)((float)(pScaleX * v12) * 2.7) + (float)((float)(pScaleX * v12) * 2.7))),
          pResult.y + (float)((float)(pScaleY * v12) * 0.7),
          CDraw::ms_fFarClipZ,
          pScaleX * (float)(v12 * 1.7),
          pScaleY * (float)(v12 * 1.7),
          0,
          0,
          0,
          0,
          1.0 / CDraw::ms_fFarClipZ,
          0xFFu,
          0,
          0,
          0.0,
          0.0);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_7);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
        RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaTexture[2]->raster);
        CSprite::RenderOneXLUSprite(
          pResult.x,
          pResult.y,
          CDraw::ms_fFarClipZ,
          pScaleX * (float)((float)((float)CCoronas::MoonSize + (float)CCoronas::MoonSize) + 4.0),
          pScaleY * (float)((float)((float)CCoronas::MoonSize + (float)CCoronas::MoonSize) + 4.0),
          (unsigned __int8)v7,
          (unsigned __int8)v7,
          (unsigned int)(float)((float)v7 * 0.85),
          255,
          1.0 / CDraw::ms_fFarClipZ,
          0xFFu,
          0,
          0,
          0.0,
          0.0);
        RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
        RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
      }
      v5 = CClock::ms_nGameClockHours;
    }
  }
  if ( (unsigned __int8)(v5 - 6) >= 0x10u )
  {
    v13 = 255;
    if ( (unsigned __int8)(v5 - 5) > 0x11u )
      goto LABEL_15;
    if ( v5 == 22 )
    {
      v13 = 255 * (unsigned int)CClock::ms_nGameClockMinutes / 0x3C;
      if ( !v13 )
        goto LABEL_28;
LABEL_15:
      v2.n64_f32[0] = CWeather::Foggyness;
      v3.n64_f32[0] = CWeather::CloudCoverage;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaTexture[0]->raster);
      v14 = vmax_f32(v3, v2).n64_f32[0];
      v2.n64_u32[1] = -1133133169;
      v15 = 0;
      v2.n64_f32[0] = (float)(int)(float)((float)(1.0 - v14) * (float)v13);
      do
      {
        In.y = 0.0;
        In.x = 100.0;
        v16 = 100.0;
        In.z = 10.0;
        if ( v15 >= 9 )
        {
          In.x = -100.0;
          v16 = -100.0;
        }
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        v18 = p_m_transform->m_translate.z;
        v19 = p_m_transform->m_translate.y + 0.0;
        v20 = StarCoorsY[v15 % 9];
        In.x = p_m_transform->m_translate.x + v16;
        v21 = v19 + (float)(StarCoorsX[v15 % 9] * -90.0);
        In.z = (float)(v18 + 10.0) + (float)(v20 * 80.0);
        In.y = v21;
        if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) == 1 )
        {
          v3.n64_u32[1] = LODWORD(pResult.z);
          v4.n64_f32[1] = StarSizes[v15 % 9];
          v22 = rand();
          CSprite::RenderBufferedOneXLUSprite(
            pResult.x,
            pResult.y,
            pResult.z,
            (float)(v4.n64_f32[1] * 0.8) * pScaleX,
            (float)(v4.n64_f32[1] * 0.8) * pScaleY,
            (unsigned __int8)(int)(float)((float)((float)((float)(v22 & 0x1F) * -0.015) + 1.0) * v2.n64_f32[0]),
            (unsigned __int8)(int)(float)((float)((float)((float)(v22 & 0x1F) * -0.015) + 1.0) * v2.n64_f32[0]),
            (unsigned __int8)(int)(float)((float)((float)((float)(v22 & 0x1F) * -0.015) + 1.0) * v2.n64_f32[0]),
            255,
            1.0 / v3.n64_f32[1],
            0xFFu);
        }
        ++v15;
      }
      while ( v15 != 11 );
      In.z = 10.0;
      v23 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        v23 = &TheCamera.m_transform;
      v24 = v23->m_translate.z;
      v25 = v23->m_translate.y + -90.0;
      In.x = v23->m_translate.x + 100.0;
      In.y = v25;
      In.z = (float)(v24 + 10.0) + 0.0;
      v26 = rand();
      if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) )
        CSprite::RenderOneXLUSprite(
          pResult.x,
          pResult.y,
          pResult.z,
          pScaleX * 5.0,
          pScaleY * 5.0,
          (unsigned __int8)(int)(float)((float)((float)((float)(v26 & 0x7F) * 0.0015625) + 0.5) * v2.n64_f32[0]),
          (unsigned __int8)(int)(float)((float)((float)((float)(v26 & 0x7F) * 0.0015625) + 0.5) * v2.n64_f32[0]),
          (unsigned __int8)(int)(float)((float)((float)((float)(v26 & 0x7F) * 0.0015625) + 0.5) * v2.n64_f32[0]),
          255,
          1.0 / pResult.z,
          0xFFu,
          0,
          0,
          0.0,
          0.0);
      CSprite::FlushSpriteBuffer();
      goto LABEL_28;
    }
    v13 = 255 * (60 - CClock::ms_nGameClockMinutes) / 60;
    if ( v13 )
      goto LABEL_15;
  }
LABEL_28:
  m_nLowCloudsRed = CTimeCycle::m_CurrentColours.m_nLowCloudsRed;
  m_nLowCloudsGreen = CTimeCycle::m_CurrentColours.m_nLowCloudsGreen;
  m_nLowCloudsBlue = CTimeCycle::m_CurrentColours.m_nLowCloudsBlue;
  v2.n64_f32[0] = CWeather::ExtraSunnyness;
  v3.n64_f32[0] = CWeather::CloudCoverage;
  v4.n64_f32[0] = CWeather::Foggyness;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCloudTex[0]->raster);
  v30 = 1.0 - vmax_f32(v2, vmax_f32(v4, v3)).n64_f32[0];
  m_pMat = TheCamera.m_pMat;
  B = (unsigned int)(float)(v30 * (float)m_nLowCloudsBlue);
  G = (unsigned int)(float)(v30 * (float)m_nLowCloudsGreen);
  R = (unsigned int)(float)(v30 * (float)m_nLowCloudsRed);
  if ( TheCamera.m_pMat )
  {
    v32 = sqrtf((float)(TheCamera.m_pMat->xx * TheCamera.m_pMat->xx) + (float)(TheCamera.m_pMat->yx
                                                                             * TheCamera.m_pMat->yx));
    if ( TheCamera.m_pMat->zz < 0.0 )
      v32 = -v32;
    v33 = atan2f(TheCamera.m_pMat->zx, v32);
  }
  else
  {
    v33 = 0.0;
  }
  v34 = 0;
  CClouds::ms_cameraRoll = v33;
  while ( 1 )
  {
    v35 = LowCloudsZ[v34] * 60.0;
    v36 = LowCloudsX[v34] * 800.0;
    v37 = (CSimpleTransform *)&m_pMat->tx;
    v38 = LowCloudsY[v34] * 800.0;
    if ( !m_pMat )
      v37 = &TheCamera.m_transform;
    v39 = *(_QWORD *)&v37->m_translate.x;
    In.y = v37->m_translate.y;
    In.x = *(float *)&v39 + v36;
    In.z = v35 + 40.0;
    In.y = In.y + v38;
    if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) == 1 )
      CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension(
        pResult.x,
        pResult.y,
        pResult.z,
        pScaleX * 320.0,
        pScaleY * 40.0,
        R,
        G,
        B,
        255,
        1.0 / pResult.z,
        CClouds::ms_cameraRoll,
        0xFFu);
    if ( v34 == 11 )
      break;
    m_pMat = TheCamera.m_pMat;
    ++v34;
  }
  CSprite::FlushSpriteBuffer();
  if ( CWeather::Rainbow != 0.0 )
  {
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaTexture[0]->raster);
    for ( i = 0; i != 6; ++i )
    {
      In.z = 5.0;
      v41 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        v41 = &TheCamera.m_transform;
      v42 = v41->m_translate.y;
      v43 = v41->m_translate.z;
      In.x = v41->m_translate.x + (float)((float)i * 1.5);
      In.y = v42 + 100.0;
      In.z = v43 + 5.0;
      if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) == 1 )
        CSprite::RenderBufferedOneXLUSprite(
          pResult.x,
          pResult.y,
          pResult.z,
          pScaleX + pScaleX,
          pScaleY * 50.0,
          (unsigned int)(float)(CWeather::Rainbow * (float)BowRed[i]),
          (unsigned int)(float)(CWeather::Rainbow * (float)BowGreen[i]),
          (unsigned int)(float)(CWeather::Rainbow * (float)BowBlue[i]),
          255,
          1.0 / pResult.z,
          0xFFu);
    }
    CSprite::FlushSpriteBuffer();
  }
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  if ( CClock::ms_nGameClockHours <= 4u
    && (unsigned __int16)CWeather::OldWeatherType <= 0x11u
    && ((1 << CWeather::OldWeatherType) & 0x22845) != 0
    && (unsigned __int16)CWeather::NewWeatherType <= 0x11u
    && ((1 << CWeather::NewWeatherType) & 0x22845) != 0 )
  {
    v44 = (CTimer::m_snTimeInMilliseconds >> 13) & 0x3F;
    v45 = CTimer::m_snTimeInMilliseconds & 0x1FFF;
    if ( v45 >> 5 <= 0x18 )
    {
      v46 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        v46 = &TheCamera.m_transform;
      x = v46->m_translate.x;
      v48 = v46->m_translate.y;
      v49 = v46->m_translate.z;
      In.z = 1.0;
      In.y = (float)(((unsigned __int16)CTimer::m_snTimeInMilliseconds >> 13) - 4) * 0.1;
      In.x = (float)(int)(v44 % 7 - 3) * 0.1;
      CVector::Normalise((CVector *)&In);
      v57.y = (float)(int)(v44 % 0xA - 5);
      v57.x = (float)(int)(v44 % 9 - 5);
      v57.z = 0.1;
      CVector::Normalise(&v57);
      v50 = (float)(int)(400 - v45) + (float)(int)(400 - v45);
      v51 = x + (float)(v57.x * 1000.0);
      TempVertexBuffer.m_3d[0].color = (RwRGBA_0)-503316481;
      v52 = v48 + (float)(v57.y * 1000.0);
      v53 = v49 + (float)(v57.z * 1000.0);
      TempVertexBuffer.m_3d[1].color = (RwRGBA_0)0xFFFFFF;
      TempVertexBuffer.m_3d[0].position.x = v51 + (float)(v50 * In.x);
      TempVertexBuffer.m_3d[0].position.y = v52 + (float)(v50 * In.y);
      TempVertexBuffer.m_3d[0].position.z = v53 + (float)(v50 * In.z);
      TempVertexBuffer.m_3d[1].position.x = v51 + (float)((float)(v50 + 50.0) * In.x);
      TempVertexBuffer.m_3d[1].position.y = v52 + (float)((float)(v50 + 50.0) * In.y);
      TempVertexBuffer.m_3d[1].position.z = v53 + (float)((float)(v50 + 50.0) * In.z);
      if ( RwIm3DTransform(TempVertexBuffer.m_3d, 2u, 0, 0x18u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPEPOLYLINE, CClouds::Render(void)::LTrailIndices, 2);
        RwIm3DEnd();
      }
    }
  }
}
// 59ECC6: variable 'v1' is possibly undefined
// 59ECC6: variable 'v0' is possibly undefined
// 59F024: variable 'v3' is possibly undefined
// 59F024: variable 'v2' is possibly undefined
// 59F2C8: variable 'v4' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 7: using guessed type char byte_7;

//----- (0059F924) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CClouds::SetUpOneSkyPoly(
        CVector Coors1,
        CVector Coors2,
        CVector Coors3,
        CVector Coors4,
        int R_1and2,
        int G_1and2,
        int B_1and2,
        int R_3and4,
        int G_3and4,
        int B_3and4)
{
  RwImVertexIndex v10; // r4
  int v11; // r5
  Int32 v12; // r0
  RwImVertexIndex *v13; // r1
  Int32 v14; // r2

  v10 = TempBufferVerticesStored;
  v11 = 9 * TempBufferVerticesStored;
  TempVertexBuffer.m_3d[TempBufferVerticesStored].position.x = Coors1.x;
  LODWORD(Coors1.x) = (char *)&TempVertexBuffer + 4 * v11;
  *(RwReal *)(LODWORD(Coors1.x) + 4) = Coors1.y;
  *(RwReal *)(LODWORD(Coors1.x) + 8) = Coors1.z;
  *(CVector *)(LODWORD(Coors1.x) + 36) = Coors2;
  LODWORD(Coors1.y) = R_1and2 | (G_1and2 << 8) | (B_1and2 << 16) | 0xFF000000;
  *(RwReal *)(LODWORD(Coors1.x) + 24) = Coors1.y;
  *(RwReal *)(LODWORD(Coors1.x) + 60) = Coors1.y;
  *(CVector *)(LODWORD(Coors1.x) + 72) = Coors3;
  *(_DWORD *)(LODWORD(Coors1.x) + 28) = 0;
  *(_DWORD *)(LODWORD(Coors1.x) + 32) = 0;
  LODWORD(Coors1.y) = R_3and4 | (G_3and4 << 8) | (B_3and4 << 16) | 0xFF000000;
  *(_DWORD *)(LODWORD(Coors1.x) + 64) = 0;
  *(_DWORD *)(LODWORD(Coors1.x) + 68) = 0;
  *(RwReal *)(LODWORD(Coors1.x) + 96) = Coors1.y;
  *(_DWORD *)(LODWORD(Coors1.x) + 100) = 0;
  *(_DWORD *)(LODWORD(Coors1.x) + 104) = 0;
  *(CVector *)(LODWORD(Coors1.x) + 108) = Coors4;
  *(RwReal *)(LODWORD(Coors1.x) + 132) = Coors1.y;
  *(_DWORD *)(LODWORD(Coors1.x) + 136) = 0;
  *(_DWORD *)(LODWORD(Coors1.x) + 140) = 0;
  v12 = TempBufferIndicesStored;
  v13 = &TempBufferRenderIndexList[TempBufferIndicesStored];
  *v13 = v10;
  v13[1] = v10 + 2;
  v13[2] = v10 + 1;
  v13[3] = v10 + 1;
  v13[4] = v10 + 2;
  v14 = TempBufferVerticesStored;
  TempBufferIndicesStored = v12 + 6;
  v13[5] = TempBufferVerticesStored + 3;
  TempBufferVerticesStored = v14 + 4;
}
// 59F924: fragmented variable at 0:r3.4,4:^20.8 may be wrong
// 59F924: variables would overlap: 0:r3.4,4:^20.8 and ^20.4
// 59F924: variables would overlap: 0:r3.4,4:^20.8 and ^24.4

//----- (0059FA10) --------------------------------------------------------
void CClouds::RenderSkyPolys()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d11
  float32x2_t v2; // d14
  float32x2_t v3; // d15
  __int64 v4; // d16
  float m_heading; // r4
  unsigned int red; // r9
  unsigned int green; // r10
  unsigned int blue; // r5
  CSimpleTransform *p_tx; // r3
  unsigned int m_nSkyBottomRed; // r11
  unsigned int m_nSkyBottomGreen; // r6
  unsigned int m_nSkyBottomBlue; // r4
  float x; // s26
  float y; // s24
  float v15; // s16
  float v16; // s18
  float z; // s20
  float v18; // s2
  int B_3and4; // s0
  int G_3and4; // s4
  int R_3and4; // s2
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v23; // r11
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  float v26; // s17
  float v27; // s28
  float v28; // s26
  int v29; // r6
  _BOOL4 v30; // r4
  int v31; // r5
  _BOOL4 v32; // r0
  bool v33; // zf
  CVector v34; // [sp+8h] [bp-A8h]
  CVector v35; // [sp+8h] [bp-A8h]
  CVector v36; // [sp+8h] [bp-A8h]
  CVector v37; // [sp+8h] [bp-A8h]
  CVector v38; // [sp+8h] [bp-A8h]
  CVector v39; // [sp+14h] [bp-9Ch]
  CVector v40; // [sp+14h] [bp-9Ch]
  CVector v41; // [sp+14h] [bp-9Ch]
  CVector v42; // [sp+14h] [bp-9Ch]
  CVector v43; // [sp+14h] [bp-9Ch]
  CVector v44; // [sp+40h] [bp-70h] BYREF
  CVector v45; // 0:r0.12
  CVector v46; // 0:r0.12
  CVector v47; // 0:r0.12
  CVector v48; // 0:r0.12
  CVector v49; // 0:r0.12
  CVector v50; // 0:r3.4,4:^0.8
  CVector v51; // 0:r3.4,4:^0.8
  CVector v52; // 0:r3.4,4:^0.8
  CVector v53; // 0:r3.4,4:^0.8
  CVector v54; // 0:r3.4,4:^0.8

  if ( TheCamera.m_pMat )
  {
    v4 = *(_QWORD *)&TheCamera.m_pMat->xy;
    v44.z = TheCamera.m_pMat->zy;
    *(_QWORD *)&v44.x = v4;
  }
  else
  {
    v44.z = 0.0;
    m_heading = TheCamera.m_transform.m_heading;
    v44.y = cosf(TheCamera.m_transform.m_heading);
    LODWORD(v44.x) = COERCE_UNSIGNED_INT(sinf(m_heading)) ^ 0x80000000;
  }
  v44.z = 0.0;
  CVector::Normalise(&v44);
  red = CTimeCycle::m_BelowHorizonGrey._anon_0._anon_0.red;
  green = CTimeCycle::m_BelowHorizonGrey._anon_0._anon_0.green;
  blue = CTimeCycle::m_BelowHorizonGrey._anon_0._anon_0.blue;
  v2.n64_f32[0] = CWeather::Foggyness;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  m_nSkyBottomRed = CTimeCycle::m_CurrentColours.m_nSkyBottomRed;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  m_nSkyBottomGreen = CTimeCycle::m_CurrentColours.m_nSkyBottomGreen;
  m_nSkyBottomBlue = CTimeCycle::m_CurrentColours.m_nSkyBottomBlue;
  x = v44.x;
  y = v44.y;
  v15 = p_tx->m_translate.x;
  v16 = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  v1.n64_u32[0] = 1.0;
  v3.n64_u32[0] = 0;
  v0.n64_f32[0] = (float)(z + -25.0) / 80.0;
  v18 = vmax_f32(vmax_f32(vmin_f32(v0, v1), v3), v2).n64_f32[0];
  B_3and4 = (unsigned int)(float)((float)(v18 * (float)m_nSkyBottomBlue) + (float)((float)(1.0 - v18) * (float)blue));
  TempBufferIndicesStored = 0;
  G_3and4 = (unsigned int)(float)((float)(v18 * (float)m_nSkyBottomGreen) + (float)((float)(1.0 - v18) * (float)green));
  R_3and4 = (unsigned int)(float)((float)(v18 * (float)m_nSkyBottomRed) + (float)((float)(1.0 - v18) * (float)red));
  TempBufferVerticesStored = 0;
  PlayerPed = FindPlayerPed(-1);
  v23 = PlayerPed;
  if ( PlayerPed )
  {
    m_pMat = PlayerPed->m_pMat;
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_m_transform = &v23->m_transform;
    v26 = p_m_transform->m_translate.z;
    if ( v26 > 0.0 )
      v1.n64_f32[0] = (float)(v26 / 40.0) + 1.0;
  }
  else
  {
    v26 = 0.0;
  }
  v27 = x * -1.4;
  v28 = y * 1.4;
  v45.z = z + (float)((float)(v44.z + 0.5) * 30.0);
  v45.y = v16 + (float)((float)((float)(v44.y - v27) + 0.0) * 30.0);
  v50.x = v15 + (float)((float)((float)((float)(y * 1.4) + v44.x) + 0.0) * 30.0);
  v45.x = v15 + (float)((float)((float)(v44.x - (float)(y * 1.4)) + 0.0) * 30.0);
  v50.y = v16 + (float)((float)((float)(v27 + v44.y) + 0.0) * 30.0);
  v50.z = z + (float)((float)((float)(v44.z + 0.0) + 0.5) * 30.0);
  v34.x = v15 + (float)((float)(v44.x - (float)(y * 1.4)) * 30.0);
  v34.y = v16 + (float)((float)(v44.y - v27) * 30.0);
  v34.z = z + (float)(v44.z * 30.0);
  v39.x = v15 + (float)((float)((float)(y * 1.4) + v44.x) * 30.0);
  v39.y = v16 + (float)((float)(v27 + v44.y) * 30.0);
  v39.z = z + (float)((float)(v44.z + 0.0) * 30.0);
  CClouds::SetUpOneSkyPoly(
    v45,
    v50,
    v34,
    v39,
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopBlue),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomBlue));
  v46.z = z + (float)(v44.z * 30.0);
  v46.x = v15 + (float)((float)(v44.x - (float)(y * 1.4)) * 30.0);
  v46.y = v16 + (float)((float)(v44.y - v27) * 30.0);
  v51.x = v15 + (float)((float)((float)(y * 1.4) + v44.x) * 30.0);
  v51.y = v16 + (float)((float)(v27 + v44.y) * 30.0);
  v51.z = z + (float)((float)(v44.z + 0.0) * 30.0);
  v35.x = v46.x;
  v35.y = v46.y;
  v35.z = z + (float)((float)(v44.z + -0.05) * 30.0);
  v40.x = v51.x;
  v40.y = v51.y;
  v40.z = z + (float)((float)((float)(v44.z + 0.0) + -0.05) * 30.0);
  CClouds::SetUpOneSkyPoly(
    v46,
    v51,
    v35,
    v40,
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomBlue),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomBlue));
  v47.z = z + (float)((float)(v44.z + -0.05) * 30.0);
  v47.y = v16 + (float)((float)(v44.y - v27) * 30.0);
  v47.x = v15 + (float)((float)(v44.x - (float)(y * 1.4)) * 30.0);
  v52.x = v15 + (float)((float)((float)(y * 1.4) + v44.x) * 30.0);
  v52.y = v16 + (float)((float)(v27 + v44.y) * 30.0);
  v52.z = z + (float)((float)((float)(v44.z + 0.0) + -0.05) * 30.0);
  v36.x = v15 + (float)((float)((float)(v44.x - (float)(y * 1.4)) - (float)(v1.n64_f32[0] * 0.0)) * 30.0);
  v36.y = v16 + (float)((float)((float)(v44.y - v27) - (float)(v1.n64_f32[0] * 0.0)) * 30.0);
  v36.z = z + (float)((float)(v44.z - (float)(v1.n64_f32[0] * 0.15)) * 30.0);
  v41.x = v15 + (float)((float)((float)((float)(y * 1.4) + v44.x) - (float)(v1.n64_f32[0] * 0.0)) * 30.0);
  v41.y = v16 + (float)((float)((float)(v27 + v44.y) - (float)(v1.n64_f32[0] * 0.0)) * 30.0);
  v41.z = z + (float)((float)((float)(v44.z + 0.0) - (float)(v1.n64_f32[0] * 0.15)) * 30.0);
  CClouds::SetUpOneSkyPoly(
    v47,
    v52,
    v36,
    v41,
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyBottomBlue),
    R_3and4,
    G_3and4,
    B_3and4);
  v48.x = v15 + (float)((float)((float)(v44.x - (float)(y * 1.4)) + 0.0) * 30.0);
  v48.y = v16 + (float)((float)((float)(v44.y - v27) + 0.0) * 30.0);
  v48.z = z + (float)((float)(v44.z + 0.5) * 30.0);
  v53.x = v15 + (float)((float)((float)((float)(y * 1.4) + v44.x) + 0.0) * 30.0);
  v53.y = v16 + (float)((float)((float)(v27 + v44.y) + 0.0) * 30.0);
  v53.z = z + (float)((float)((float)(v44.z + 0.0) + 0.5) * 30.0);
  v37.x = v15 + (float)((float)((float)((float)-v44.x - (float)(y * 1.4)) + 0.0) * 30.0);
  v37.y = v16 + (float)((float)((float)((float)-v44.y - v27) + 0.0) * 30.0);
  v37.z = z + (float)((float)(0.5 - v44.z) * 30.0);
  v42.x = v15 + (float)((float)((float)((float)(y * 1.4) - v44.x) + 0.0) * 30.0);
  v42.y = v16 + (float)((float)((float)(v27 - v44.y) + 0.0) * 30.0);
  v42.z = z + (float)((float)((float)(0.0 - v44.z) + 0.5) * 30.0);
  CClouds::SetUpOneSkyPoly(
    v48,
    v53,
    v37,
    v42,
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopBlue),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopRed),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopGreen),
    LOBYTE(CTimeCycle::m_CurrentColours.m_nSkyTopBlue));
  if ( v23 )
  {
    v29 = 1;
    if ( v26 <= 105.0 && v26 >= 0.0 )
    {
      v30 = TheCamera.m_pRwCamera->farPlane < 300.0;
      v29 = v30 | (CPedIntelligence::GetTaskSwim(v23->m_pPedIntelligence) != 0);
    }
    v31 = 0;
    if ( FindPlayerVehicle(-1, 0) )
    {
      v31 = 0;
      if ( FindPlayerVehicle(-1, 0)->m_vehicleType == 4 )
      {
        v31 = 1;
      }
      else if ( FindPlayerVehicle(-1, 0)->m_vehicleType == 3 )
      {
        v31 = 1;
      }
    }
    if ( CPedIntelligence::GetTaskJetPack(v23->m_pPedIntelligence) )
      goto LABEL_29;
    v32 = v23->m_WeaponSlots[v23->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_PARACHUTE;
  }
  else
  {
    v29 = 0;
    v31 = 0;
    v32 = 0;
  }
  v33 = v29 == 0;
  if ( !v29 )
    v33 = v31 == 0;
  if ( !v33 || v32 )
  {
LABEL_29:
    v49.y = v16 + (float)((float)((float)(v44.y - v27) + 0.0) * 30.0);
    v54.x = v15 + (float)((float)((float)(v28 + v44.x) + 0.0) * 30.0);
    v49.x = v15 + (float)((float)((float)(v44.x - v28) + 0.0) * 30.0);
    v49.z = z + (float)((float)((float)(v1.n64_f32[0] * -0.15) + v44.z) * 30.0);
    v54.y = v16 + (float)((float)((float)(v27 + v44.y) + 0.0) * 30.0);
    v54.z = z + (float)((float)((float)(v1.n64_f32[0] * -0.15) + (float)(v44.z + 0.0)) * 30.0);
    v38.x = v15 + (float)((float)((float)((float)-v44.x - v28) + 0.0) * 30.0);
    v38.y = v16 + (float)((float)((float)((float)-v44.y - v27) + 0.0) * 30.0);
    v38.z = z + (float)((float)((float)(v1.n64_f32[0] * -0.15) - v44.z) * 30.0);
    v43.x = v15 + (float)((float)((float)(v28 - v44.x) + 0.0) * 30.0);
    v43.y = v16 + (float)((float)((float)(v27 - v44.y) + 0.0) * 30.0);
    v43.z = z + (float)((float)((float)(v1.n64_f32[0] * -0.15) + (float)(0.0 - v44.z)) * 30.0);
    CClouds::SetUpOneSkyPoly(v49, v54, v38, v43, R_3and4, G_3and4, B_3and4, R_3and4, G_3and4, B_3and4);
  }
  CBrightLights::RenderOutGeometryBuffer();
}
// 59FB3C: variable 'v0' is possibly undefined
// 59FB3C: variable 'v1' is possibly undefined
// 59FB48: variable 'v3' is possibly undefined
// 59FB58: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 24: using guessed type int dword_24;

//----- (005A0218) --------------------------------------------------------
void CClouds::RenderBottomFromHeight()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  float32x2_t v2; // d4
  int32x2_t v3; // d11
  float32x2_t v4; // d13
  float32x2_t v5; // d14
  CSimpleTransform *p_tx; // r5
  float32x2_t v7; // d2
  float32x2_t v8; // d0
  int v9; // s22
  float32x2_t v10; // d0
  int v11; // s26
  float z; // s18
  float v13; // s0
  float v14; // s20
  float v15; // s18
  float v16; // s0
  int m_fCloudAlpha; // r5
  float v18; // s2
  int v20; // r12
  int v21; // lr
  RwUInt32 v29; // r1
  float32x2_t *p_m_transform; // r6
  float32x2_t v31; // d12
  unsigned __int32 *v32; // r10
  float32x2_t v33; // d19
  float32x2_t v34; // d11
  float v35; // s11
  float32x2_t v36; // d18
  float v37; // s13
  int v38; // r6
  float v39; // s13
  float32x2_t v40; // d18
  float32x2_t v43; // d12
  float v44; // s24
  float v45; // s13
  float v46; // s15
  RwImVertexIndex *v47; // r0
  float v48; // s13
  float v49; // s15
  RwIm3DVertex *v50; // r1
  RwReal v51; // s26
  RwReal v52; // s13
  int v53; // r0
  Int32 v54; // r0
  float v55; // s20
  int i; // r4
  float v57; // s0
  CSimpleTransform *v58; // r0
  float v59; // s2
  float v60; // s4
  float v61; // s6
  int v62; // s2
  int v63; // r10
  float32x2_t v64; // d0
  float v65; // s0
  int v66; // [sp+20h] [bp-A0h]
  unsigned int v67; // [sp+24h] [bp-9Ch]
  unsigned int v68; // [sp+28h] [bp-98h]
  unsigned int v69; // [sp+2Ch] [bp-94h]
  int v70; // [sp+34h] [bp-8Ch]
  int v71; // [sp+38h] [bp-88h]
  int v72; // [sp+3Ch] [bp-84h]
  float pScaleY; // [sp+40h] [bp-80h] BYREF
  float pScaleX; // [sp+44h] [bp-7Ch] BYREF
  RwV3d_0 pResult; // [sp+48h] [bp-78h] BYREF
  RwV3d_0 In; // [sp+54h] [bp-6Ch] BYREF

  v2.n64_u32[0] = 1132396544;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v0.n64_f32[0] = (float)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomBlue * 1.5;
  v1.n64_f32[0] = (float)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomGreen * 1.5;
  v7.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
  v8.n64_u64[0] = vmin_f32(v0, v2).n64_u64[0];
  v9 = (int)v8.n64_f32[0];
  v8.n64_f32[0] = (float)((float)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomRed
                        + (float)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomRed)
                + 20.0;
  v10.n64_u64[0] = vmin_f32(v8, v2).n64_u64[0];
  v11 = (int)v10.n64_f32[0];
  z = p_tx->m_translate.z;
  if ( z >= -90.0 )
  {
    v68 = (3 * (unsigned int)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomGreen) >> 2;
    v67 = (3 * (unsigned int)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomRed) >> 2;
    v69 = (3 * (unsigned int)CTimeCycle::m_CurrentColours.m_nFluffyCloudsBottomBlue) >> 2;
    CClouds::RenderBottomFromHeight(void)::WindShift = CClouds::RenderBottomFromHeight(void)::WindShift
                                                     + (float)((float)(CWeather::Wind * CTimer::ms_fTimeStep) * 0.25);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
    RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCloudTex[1]->raster);
    v13 = z + -190.0;
    v14 = 190.0;
    v15 = 160.0;
    v16 = (float)(v13 + -10.0) * 0.3;
    m_fCloudAlpha = (int)CTimeCycle::m_CurrentColours.m_fCloudAlpha;
    if ( v16 > 0.0 )
    {
      v15 = v16 + 160.0;
      v14 = v16 + 190.0;
    }
    v72 = 2 * m_fCloudAlpha / 3;
    if ( (unsigned int)(2 * m_fCloudAlpha + 2) >= 5 )
    {
      v66 = (int)CTimeCycle::m_CurrentColours.m_fCloudAlpha;
      v18 = CClouds::RenderBottomFromHeight(void)::WindShift;
      TempBufferVerticesStored = 0;
      TempBufferIndicesStored = 0;
      v10.n64_u32[1] = -0.75;
      _R6 = v69 << 16;
      v7.n64_u32[1] = 1114636288;
      v20 = 0;
      v21 = 0;
      _R0 = v9 << 16;
      __asm { UXTB16.W        R0, R0 }
      v70 = _R0 | (unsigned __int8)v11 | ((unsigned __int8)(int)v7.n64_f32[0] << 8);
      __asm { UXTB16.W        R6, R6 }
      v29 = 0;
      v71 = (unsigned __int8)v67 | ((unsigned __int8)v68 << 8) | _R6;
      do
      {
        p_m_transform = (float32x2_t *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = (float32x2_t *)&TheCamera.m_transform;
        v31.n64_u32[0] = p_m_transform->n64_u32[0];
        v32 = &p_m_transform->n64_u32[1];
        v3.n64_f32[0] = v18 * (float)((float)(RandomArray[v20 + 6] * 0.5) + 1.0);
        v33.n64_u64[0] = vdup_lane_s32(v3, 0).n64_u64[0];
        v34.n64_u64[0] = p_m_transform->n64_u64[0];
        v35 = v15 + (float)((float)(v14 - v15) * RandomArray[v20 + 2]);
        v36.n64_u64[0] = vsub_f32(
                           vadd_f32(vmul_f32(*(float32x2_t *)&RandomArray[v20], (float32x2_t)0x4400000044000000LL), v33),
                           (float32x2_t)p_m_transform->n64_u64[0]).n64_u64[0];
        In.z = v35;
        v37 = p_m_transform[1].n64_f32[0];
        v38 = 2 * m_fCloudAlpha / 3;
        v39 = v35 - v37;
        v40.n64_u64[0] = vsub_f32(
                           v36,
                           vcvt_f32_s32((int32x2_t)(vcvt_s32_f32(v36).n64_u64[0] & 0xFFFFFE00FFFFFE00LL | 0x10000000100LL))).n64_u64[0];
        if ( v39 > 0.0 )
          v38 = (int)(float)((float)((float)(v39 / -250.0) + 1.0) * (float)v72);
        v3.n64_u64[0] = vadd_f32(v34, v40).n64_u64[0];
        if ( v38 > 0 )
        {
          v31.n64_u32[1] = *v32;
          _D18 = vsub_f32(v31, v3).n64_i64[0];
          __asm { VCLT.F32        D12, D18, #0.0 }
          v43.n64_u64[0] = vbsl_s64(_D12, vneg_f32((float32x2_t)_D18).n64_i64[0], _D18);
          v4.n64_u32[0] = v43.n64_u32[1];
          v44 = vmax_f32(v43, v4).n64_f32[0];
          if ( (float)(v44 * 0.0039062) <= 0.75
            || (v38 = (int)(float)((float)((float)((float)((float)(v44 * 0.0039062) + -0.75) * -4.0) + 1.0) * (float)v38),
                v38 >= 1) )
          {
            v45 = RandomArray[v20 + 3] * 100.0;
            v46 = RandomArray[v20 + 4] * 100.0;
            TempBufferRenderIndexList[v21] = v29 + 2;
            v47 = &TempBufferRenderIndexList[v21];
            v47[3] = v29 + 2;
            v47[4] = v29 + 3;
            v48 = v45 + 60.0;
            v47[1] = v29 + 1;
            v49 = v46 + 60.0;
            v47[2] = v29;
            v47[5] = v29 + 1;
            v50 = &TempVertexBuffer.m_3d[v29];
            v50->color = (RwRGBA_0)(v70 | (v38 << 24));
            v51 = v48 + v3.n64_f32[0];
            v50->position.z = v35;
            v52 = v3.n64_f32[0] - v48;
            v53 = v71 | (v38 << 24);
            v50[1].color = (RwRGBA_0)v53;
            v50[1].position.z = v35;
            v50[2].color = (RwRGBA_0)v53;
            v50[3].color = (RwRGBA_0)v53;
            v50->position.y = v49 + v3.n64_f32[1];
            v50[1].position.y = v49 + (float)(v3.n64_f32[1] + 0.0);
            v50[2].position.x = v52;
            v50[2].position.y = v3.n64_f32[1] - v49;
            v50[2].position.z = v35;
            v50[3].position.x = v51;
            v50[3].position.y = (float)(v3.n64_f32[1] + 0.0) - v49;
            v50[3].position.z = v35;
            v50->position.x = v52 + 0.0;
            v50[1].position.x = v51 + 0.0;
            v50->texCoords.u = 0.0;
            v50->texCoords.v = 0.0;
            v50[1].texCoords.u = 0.0;
            v50[1].texCoords.v = 1.0;
            v54 = TempBufferVerticesStored;
            v50[2].texCoords.v = 0.0;
            v50[2].texCoords.u = 1.0;
            v50[3].texCoords.u = 1.0;
            TempVertexBuffer.m_3d[v54 + 3].texCoords.v = 1.0;
            v29 = v54 + 4;
            TempBufferVerticesStored = v54 + 4;
            v21 = TempBufferIndicesStored + 6;
            TempBufferIndicesStored += 6;
          }
        }
        ++v20;
      }
      while ( v20 != 16 );
      *(int32x2_t *)&In.x = v3;
      if ( v21 && RwIm3DTransform(TempVertexBuffer.m_3d, v29, 0, 0x19u) )
      {
        RwIm3DRenderIndexedPrimitive(rwPRIMTYPETRILIST, TempBufferRenderIndexList, TempBufferIndicesStored);
        RwIm3DEnd();
      }
      m_fCloudAlpha = v66;
      TempBufferVerticesStored = 0;
      TempBufferIndicesStored = 0;
    }
    CSprite::InitSpriteBuffer();
    if ( m_fCloudAlpha >= 2 )
    {
      v55 = v14 - v15;
      v5.n64_u32[0] = 1.0;
      for ( i = 0; i != 30; ++i )
      {
        v57 = CClouds::RenderBottomFromHeight(void)::WindShift * 0.5;
        v58 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          v58 = &TheCamera.m_transform;
        v59 = v57 + CClouds::RenderBottomFromHeight(void)::FluffyCloudsY[i];
        v60 = CClouds::RenderBottomFromHeight(void)::FluffyCloudsX[i] + v57;
        v10.n64_u32[0] = LODWORD(v58->m_translate.x);
        v61 = v58->m_translate.x
            + (float)((float)(v60 - v58->m_translate.x)
                    - (float)(int)((int)(float)(v60 - v58->m_translate.x) & 0xFFFFFF00 | 0x80));
        v7.n64_f32[0] = v58->m_translate.y
                      + (float)((float)(v59 - v58->m_translate.y)
                              - (float)(int)((int)(float)(v59 - v58->m_translate.y) & 0xFFFFFF00 | 0x80));
        In.z = v15 + (float)(v55 * RandomArray[i]);
        In.x = v61;
        In.y = v7.n64_f32[0];
        v62 = (int)(float)((float)((float)(fabsf(v58->m_translate.z - In.z) / -250.0) + 1.0) * (float)v72);
        v63 = v62;
        if ( v62 >= 1 )
        {
          v10.n64_f32[0] = fabsf(v10.n64_f32[0] - v61);
          v7.n64_f32[0] = fabsf(v58->m_translate.y - v7.n64_f32[0]);
          v64.n64_u64[0] = vmax_f32(v10, v7).n64_u64[0];
          v64.n64_f32[0] = v64.n64_f32[0] * 0.0078125;
          v10.n64_u64[0] = vmin_f32(v64, v5).n64_u64[0];
          if ( v10.n64_f32[0] > 0.75 )
            v63 = (int)(float)((float)((float)((float)(v10.n64_f32[0] + -0.75) * -4.0) + 1.0) * (float)v62);
          if ( v10.n64_f32[0] > 0.05 )
          {
            if ( v10.n64_f32[0] < 0.1 )
              v63 = (int)(float)((float)((float)(v10.n64_f32[0] + -0.05) * 20.0) * (float)v63);
            if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 0, 1) == 1 )
            {
              v65 = (float)(RandomArray[i + 1] + 1.0) * 12.0;
              CSprite::RenderBufferedOneXLUSprite(
                pResult.x,
                pResult.y,
                pResult.z,
                v65 * pScaleX,
                v65 * pScaleY,
                (unsigned __int8)v67,
                (unsigned __int8)v68,
                (unsigned __int8)v69,
                256,
                1.0 / pResult.z,
                v63);
            }
          }
        }
      }
    }
    CSprite::FlushSpriteBuffer();
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  }
}
// 5A0284: variable 'v1' is possibly undefined
// 5A0284: variable 'v2' is possibly undefined
// 5A0288: variable 'v0' is possibly undefined
// 5A04EE: variable 'v3' is possibly undefined
// 5A0568: variable 'v4' is possibly undefined
// 5A0818: variable 'v5' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (005A09C4) --------------------------------------------------------
Int32 CClouds::VolumetricClouds_GetFirstFreeSlot()
{
  Int32 result; // r0

  if ( CClouds::m_VolumetricCloudsUsedNum < 1 )
    return -1;
  result = 0;
  while ( CClouds::ms_vc.bUsed[result] )
  {
    if ( ++result >= CClouds::m_VolumetricCloudsUsedNum )
      return -1;
  }
  return result;
}

//----- (005A09F4) --------------------------------------------------------
void __fastcall CClouds::VolumetricClouds_Delete(Int32 id)
{
  if ( id <= 0 )
    id = 0;
  if ( id >= 179 )
    id = (Int32)&dword_B0 + 3;
  CClouds::ms_vc.bUsed[id] = 0;
  CClouds::ms_vc.bJustCreated[id] = 0;
}
// B0: using guessed type int;

//----- (005A0A18) --------------------------------------------------------
Int32 __fastcall CClouds::VolumetricClouds_Create(CVector *pPos)
{
  float v2; // s4
  float v3; // s2
  float v4; // s0
  float v5; // s18
  float v6; // s22
  int v7; // r8
  int *v8; // r3
  CClouds::volumeClouds *v9; // r2
  int v10; // r9
  RwReal *p_y; // r0
  float v12; // s24
  float z; // s26
  float x; // s19
  int v15; // r4
  float v16; // s17
  int v17; // r10
  CVector *v18; // r4
  unsigned __int16 v19; // r0
  bool v20; // cc
  int v21; // s0
  float v22; // s26
  int v23; // r4
  int v24; // r6
  float v25; // s20
  float v26; // s22
  float v27; // s28
  CSimpleTransform *p_tx; // r2
  float v29; // s17
  float y; // s19
  float v31; // s21
  float *v32; // r5
  int *v34; // [sp+0h] [bp-68h]
  CClouds::volumeClouds *v35; // [sp+4h] [bp-64h]

  v2 = (float)((float)((float)rand() * 4.6566e-10) * 4.0) + 1.0;
  v3 = v2 * 40.0;
  v4 = v2 * 100.0;
  v5 = v2 * 20.0;
  if ( pPos )
  {
    v6 = v4 - v5;
    v7 = 0;
    v8 = &CClouds::m_VolumetricCloudsUsedNum;
    v9 = &CClouds::ms_vc;
    v10 = (int)(float)(v2 * 3.0);
    p_y = &pPos->y;
    v12 = (float)(2 * v10);
    z = pPos->z;
    do
    {
      if ( *v8 < 1 )
        break;
      x = pPos->x;
      v15 = 0;
      v16 = *p_y;
      v17 = 0;
      while ( CClouds::ms_vc.bUsed[v17] )
      {
        ++v17;
        v15 += 12;
        if ( v17 >= *v8 )
          return -1;
      }
      if ( v15 == -12 )
        break;
      v9->bUsed[v17] = 1;
      CClouds::ms_vc.bJustCreated[v17] = 1;
      v34 = v8;
      v35 = v9;
      CClouds::ms_vc.alpha[v17] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 92.0) + 36;
      v18 = (CVector *)&CClouds::ms_vc.bUsed[v15];
      v18[210].x = v5 + (float)(v6 * (float)((float)rand() * 4.6566e-10));
      v18[210].y = v5 + (float)(v6 * (float)((float)rand() * 4.6566e-10));
      v18[210].z = v5 + (float)((float)(v3 - v5) * (float)((float)rand() * 4.6566e-10));
      v18[30].x = x + (float)((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * v12) - v10);
      v18[30].y = v16 + (float)((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * v12) - v10);
      v19 = rand();
      v8 = v34;
      v9 = v35;
      v20 = v7++ < 4;
      v21 = (int)(float)((float)((float)v19 * 0.000015259) * v12) - v10;
      p_y = &v18[30].y;
      z = z + (float)v21;
      v18[30].z = z;
      pPos = v18 + 30;
    }
    while ( v20 );
  }
  else
  {
    v22 = v4 - v5;
    v23 = 0;
    v24 = 0;
    v25 = CClouds::m_fVolumetricCloudMaxDistance;
    v26 = CClouds::m_fVolumetricCloudMaxDistance * 0.25;
    v27 = v25 + v25;
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    v29 = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    v31 = p_tx->m_translate.z;
    do
    {
      CClouds::ms_vc.bUsed[v24] = 1;
      CClouds::ms_vc.bJustCreated[v24] = 1;
      CClouds::ms_vc.alpha[v24] = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 92.0) + 36;
      v32 = (float *)&CClouds::ms_vc.bUsed[v23 * 12];
      CClouds::ms_vc.size[v23].x = v5 + (float)(v22 * (float)((float)rand() * 4.6566e-10));
      v32[631] = v5 + (float)(v22 * (float)((float)rand() * 4.6566e-10));
      v32[632] = v5 + (float)((float)(v3 - v5) * (float)((float)rand() * 4.6566e-10));
      v32[90] = v29 + (float)((float)(v27 * (float)((float)rand() * 4.6566e-10)) - v25);
      v32[91] = y + (float)((float)(v27 * (float)((float)rand() * 4.6566e-10)) - v25);
      ++v24;
      ++v23;
      v32[92] = v31 + (float)((float)((float)(v26 + v26) * (float)((float)rand() * 4.6566e-10)) - v26);
    }
    while ( v24 != 180 );
  }
  return -1;
}

//----- (005A0DE4) --------------------------------------------------------
unsigned __int32 CClouds::VolumetricCloudsGetMaxDistance()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1

  v0.n64_u32[0] = 1142292480;
  v1.n64_u32[0] = LODWORD(Scene.camera->farPlane);
  return vmin_f32(v1, v0).n64_u32[0];
}
// 5A0DF4: variable 'v1' is possibly undefined
// 5A0DF4: variable 'v0' is possibly undefined

//----- (005A0E08) --------------------------------------------------------
void CClouds::VolumetricCloudsRender()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  FxQuality_e FxQuality; // r0
  float v3; // s0
  int v4; // r0
  CSimpleTransform *p_tx; // r0
  float x; // s16
  float y; // s18
  float z; // s20
  char v9; // r0
  float v10; // s0
  int v11; // r5
  CVehicle *PlayerVehicle; // r4
  char v13; // r0
  int v14; // r0
  int v15; // r1
  float *p_xx; // r0
  float *p_x; // r1
  float v18; // s8
  float v19; // s0
  float v20; // s2
  float v21; // s24
  float v22; // s22
  float v23; // s2
  Int32 v24; // lr
  int v25; // r10
  signed int v26; // r5
  unsigned int v27; // r1
  float *v28; // r2
  float v29; // s0
  float v30; // s2
  float v31; // s8
  float v32; // s0
  float v33; // s4
  float v34; // s0
  bool *v35; // r3
  float v36; // s2
  int v37; // r1
  int v38; // r3
  int v39; // r6
  float v40; // s28
  float v41; // s30
  float v42; // s29
  float v43; // s26
  float v44; // s27
  float v45; // s25
  float *v46; // r0
  float *v47; // r2
  float v48; // s19
  int v49; // r1
  float v50; // s21
  int v51; // r0
  float v52; // s17
  float v53; // s23
  float v54; // s0
  float v55; // s4
  float v56; // s2
  __int64 v57; // r0
  int v58; // r11
  float v59; // s2
  float v60; // s4
  float v61; // s0
  float v62; // s2
  int v63; // s31
  float v64; // s0
  UInt8 v65; // r6
  int v66; // r9
  float v67; // s31
  float v68; // s22
  float v69; // s24
  UInt8 alpha; // r0
  UInt8 v71; // r6
  int v72; // r9
  int v73; // r11
  int v74; // r6
  __int64 v75; // r2
  RwIm3DVertex *v76; // r1
  RwReal v77; // r0
  RwReal v78; // s0
  RwReal v79; // s4
  int v80; // r0
  UInt8 blue; // [sp+Ch] [bp-D4h]
  CVector pPos; // [sp+64h] [bp-7Ch] BYREF
  CVector v83; // [sp+70h] [bp-70h] BYREF

  if ( CGame::currArea || FindPlayerPed(-1)->m_areaCode )
    return;
  FxQuality = Fx_c::GetFxQuality(&g_fx);
  v3 = 1.0;
  if ( FxQuality == FX_QUALITY_MEDIUM )
    v3 = 0.66;
  if ( FxQuality == FX_QUALITY_LOW )
    v3 = 0.5;
  CClouds::m_fVolumetricCloudDensity = v3;
  CClouds::m_VolumetricCloudsUsedNum = (int)(float)(v3 * 180.0);
  v4 = (int)(float)(v3 * 180.0);
  if ( v4 < 1 )
    return;
  if ( v4 >= 181 )
    CClouds::m_VolumetricCloudsUsedNum = 180;
  v0.n64_u32[0] = 1142292480;
  v1.n64_u32[0] = LODWORD(Scene.camera->farPlane);
  LODWORD(CClouds::m_fVolumetricCloudMaxDistance) = vmin_f32(v1, v0).n64_u32[0];
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  v9 = `guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastCamera;
  __dmb(0xBu);
  if ( (v9 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastCamera) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastCamera);
  }
  if ( !CClouds::m_bVolumetricCloudHeightSwitch )
    goto LABEL_21;
  v10 = CTimer::ms_fTimeStep * 4.0;
  if ( z >= 220.0 )
  {
    CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader = CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader
                                                                  - v10;
    if ( CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader >= 0.0 )
      goto LABEL_22;
LABEL_21:
    CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader = 0.0;
    goto LABEL_22;
  }
  CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader = CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader
                                                                + v10;
  if ( CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader >= 255.0 )
  {
    CClouds::VolumetricCloudsRender(void)::gfVolumetricCloudFader = 255.0;
    return;
  }
LABEL_22:
  CPostEffects::ImmediateModeRenderStatesStore();
  CPostEffects::ImmediateModeRenderStatesSet();
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, CClouds::ms_vc.pTexture[0]->raster);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  v11 = 0;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  FindPlayerCoors(&v83, -1);
  v13 = `guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastPlayer;
  __dmb(0xBu);
  if ( (v13 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastPlayer) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CClouds::VolumetricCloudsRender(void)::gPosLastPlayer);
  }
  v14 = 0;
  v15 = 0;
  if ( y != CClouds::VolumetricCloudsRender(void)::gPosLastCamera.y )
    v14 = 1;
  if ( x != CClouds::VolumetricCloudsRender(void)::gPosLastCamera.x )
    v15 = 1;
  if ( z != CClouds::VolumetricCloudsRender(void)::gPosLastCamera.z )
    v11 = 1;
  if ( v83.x != CClouds::VolumetricCloudsRender(void)::gPosLastPlayer.x
    || v83.y != CClouds::VolumetricCloudsRender(void)::gPosLastPlayer.y
    || v83.z != CClouds::VolumetricCloudsRender(void)::gPosLastPlayer.z )
  {
    CClouds::VolumetricCloudsRender(void)::gPosLastCamera.x = x;
    CClouds::VolumetricCloudsRender(void)::gPosLastCamera.y = y;
    CClouds::VolumetricCloudsRender(void)::gPosLastPlayer = v83;
    CClouds::VolumetricCloudsRender(void)::gPosLastCamera.z = z;
LABEL_35:
    if ( PlayerVehicle )
    {
      p_xx = &PlayerVehicle->m_pMat->xx;
      p_x = p_xx + 12;
      v18 = (float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0) * p_xx[5];
      v19 = (float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0) * p_xx[6];
      v20 = p_xx[4] * (float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0);
      pPos.y = v18;
      pPos.z = v19;
      if ( !p_xx )
        p_x = &PlayerVehicle->m_transform.m_translate.x;
      v21 = *p_x + v20;
      pPos.x = v21;
      v22 = p_x[1] + v18;
      pPos.y = v22;
      v23 = p_x[2];
    }
    else
    {
      v19 = (float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0) * TheCamera.m_cameraMatrix.zy;
      v21 = x + (float)(TheCamera.m_cameraMatrix.xy * (float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0));
      v22 = y + (float)((float)(CClouds::m_fVolumetricCloudMaxDistance + 200.0) * TheCamera.m_cameraMatrix.yy);
      v23 = z;
      pPos.z = v19;
      pPos.x = v21;
      pPos.y = v22;
    }
    pPos.x = v21 + (float)((float)((float)((float)rand() * 4.6566e-10) * 400.0) + -200.0);
    pPos.y = v22 + (float)((float)((float)((float)rand() * 4.6566e-10) * 400.0) + -200.0);
    pPos.z = (float)(v23 + v19) + (float)((float)((float)((float)rand() * 4.6566e-10) * 100.0) + -50.0);
    CClouds::VolumetricClouds_Create(&pPos);
    goto LABEL_41;
  }
  CClouds::VolumetricCloudsRender(void)::gPosLastCamera.x = x;
  CClouds::VolumetricCloudsRender(void)::gPosLastCamera.y = y;
  CClouds::VolumetricCloudsRender(void)::gPosLastPlayer = v83;
  CClouds::VolumetricCloudsRender(void)::gPosLastCamera.z = z;
  if ( (v14 | v15 | v11) == 1 )
    goto LABEL_35;
LABEL_41:
  v24 = CClouds::m_VolumetricCloudsUsedNum;
  if ( CClouds::m_VolumetricCloudsUsedNum < 1 )
    goto LABEL_93;
  v25 = 0;
  v26 = 0;
  v27 = (CTimeCycle::m_CurrentColours.m_nSkyBottomRed
       + CTimeCycle::m_CurrentColours.m_nSkyTopRed
       + CTimeCycle::m_CurrentColours.m_nSkyTopGreen
       + CTimeCycle::m_CurrentColours.m_nSkyTopBlue
       + CTimeCycle::m_CurrentColours.m_nSkyBottomGreen
       + (unsigned int)CTimeCycle::m_CurrentColours.m_nSkyBottomBlue)
      / 6
      + 64;
  if ( v27 >= 0xFF )
    LOBYTE(v27) = -1;
  blue = v27;
  do
  {
    if ( !CClouds::ms_vc.bUsed[v25] )
      goto LABEL_89;
    v28 = (float *)