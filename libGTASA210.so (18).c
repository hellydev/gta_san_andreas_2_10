hash_bucket[4937],
          0,
          0,
          8.0);
        break;
      case 704:
        v5 = (char *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
        break;
    }
  }
  return (CTask *)v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 668FF0: using guessed type void *off_668FF0;
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;
// 66C13C: using guessed type void *off_66C13C;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (0051EA64) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPointRoute::CreateNextSubTask(CTaskComplexFollowPointRoute *this, CPed *pPed)
{
  int v5; // r0
  int m_iProgress; // r1
  int SubTaskType; // r2

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1302 )
    return 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 704 )
  {
    if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
      return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowPointRoute *, CPed *))this->_vptr$CTask + 11))(
                        this,
                        pPed);
    return 0;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 200 )
    return 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203 )
    return 0;
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  m_iProgress = this->m_iProgress;
  if ( v5 == 900 && m_iProgress + 1 == this->m_pRoute->m_iRouteSize && (*((_BYTE *)this + 40) & 4) == 0 )
    return 0;
  this->m_iProgress = m_iProgress + 1;
  SubTaskType = CTaskComplexFollowPointRoute::GetSubTaskType(this);
  if ( (*((_BYTE *)this + 40) & 8) != 0 )
    SubTaskType = CTaskComplexFollowPointRoute::CalcGoToTaskType(this, pPed, SubTaskType);
  return CTaskComplexFollowPointRoute::CreateSubTask(this, SubTaskType, pPed);
}

//----- (0051EB08) --------------------------------------------------------
int __fastcall CTaskComplexFollowPointRoute::CalcGoToTaskType(
        CTaskComplexFollowPointRoute *this,
        CPed *pPed,
        int iSubTaskType)
{
  int m_iMoveState; // r2
  char v6; // r0
  __int64 v7; // kr00_8
  int m_iProgress; // r2
  float *p_y; // r1
  CSimpleTransform *p_tx; // r3
  int v11; // r3
  float v12; // s0
  float x; // s2
  int v14; // r3
  CMatrix *m_pMat; // r6
  int v16; // r6
  int v17; // r4
  int v18; // r0
  float v19; // s4
  float v20; // s6
  CPointRoute *m_pRoute; // r0
  int m_iRouteSize; // r1
  unsigned int m_iMode; // r2
  int v24; // r2
  float *v25; // r1
  float *v26; // r0
  float v27; // s6
  RwReal v28; // s2
  float v29; // s0
  float v30; // s0
  int v31; // r0
  float v32; // s2
  float v33; // s4
  float v34; // s0
  char v35; // r0
  bool v36; // zf
  char v37; // r0
  float v39; // s0
  float v40; // s2
  CVector v41; // [sp+0h] [bp-28h] BYREF
  CVector v42; // [sp+Ch] [bp-1Ch] BYREF

  m_iMoveState = this->m_iMoveState;
  v6 = *((_BYTE *)this + 40) & 0xEF;
  this->m_SpeedIncreaseAmt = this->m_SpeedDecreaseAmt;
  *((_BYTE *)this + 40) = v6;
  if ( m_iMoveState < 5 )
  {
    if ( (v6 & 0x20) == 0 )
      goto LABEL_45;
LABEL_39:
    v36 = iSubTaskType == 903;
    if ( iSubTaskType != 903 )
      v36 = iSubTaskType == 900;
    if ( v36 )
    {
      iSubTaskType = 926;
      v37 = v6 & 0x9F | 0x40;
    }
    else
    {
LABEL_45:
      v37 = v6 & 0x9F;
    }
    *((_BYTE *)this + 40) = v37;
    return iSubTaskType;
  }
  v7 = *(_QWORD *)&this->m_pRoute;
  m_iProgress = *(_DWORD *)v7 - 1;
  if ( SHIDWORD(v7) < *(_DWORD *)v7 )
    m_iProgress = this->m_iProgress;
  if ( m_iProgress >= 0 )
  {
    if ( *(_DWORD *)v7 == 1 )
    {
      p_y = (float *)(v7 + 8);
      p_tx = (CSimpleTransform *)(v7 + 4);
    }
    else
    {
      if ( this->m_iMode > 3u )
      {
        v12 = 0.0;
        x = 0.0;
        goto LABEL_17;
      }
      if ( HIDWORD(v7) )
      {
        v11 = v7 + 12 * HIDWORD(v7);
        p_y = (float *)(v11 - 4);
        p_tx = (CSimpleTransform *)(v11 - 8);
      }
      else if ( this->m_iRouteTraversals < 1 )
      {
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_y = &p_tx->m_translate.y;
      }
      else
      {
        v14 = v7 + 12 * (*(_DWORD *)v7 - 1);
        p_y = (float *)(v14 + 8);
        p_tx = (CSimpleTransform *)(v14 + 4);
      }
    }
    v12 = *p_y;
    x = p_tx->m_translate.x;
LABEL_17:
    v16 = 3 * m_iProgress;
    v17 = 0;
    v18 = v7 + 12 * m_iProgress;
    v19 = *(float *)(v18 + 4);
    v20 = *(float *)(v18 + 8);
    v42.z = 0.0;
    v42.y = v20 - v12;
    v42.x = v19 - x;
    CVector::Normalise(&v42);
    m_pRoute = this->m_pRoute;
    m_iRouteSize = m_pRoute->m_iRouteSize;
    if ( m_pRoute->m_iRouteSize != 1 )
    {
      m_iMode = this->m_iMode;
      if ( m_iMode >= 3 )
      {
        if ( m_iMode != 3 )
        {
          v39 = 0.0;
          v40 = 0.0;
LABEL_27:
          v26 = (float *)(&m_pRoute->m_iRouteSize + v16);
          v27 = v26[2];
          v28 = v40 - v26[1];
          v41.z = 0.0;
          v41.y = v39 - v27;
          v41.x = v28;
          CVector::Normalise(&v41);
          v29 = (float)((float)(v42.x * v41.x) + (float)(v42.y * v41.y)) + (float)(v42.z * v41.z);
          if ( v29 >= 0.707 )
          {
            v6 = *((_BYTE *)this + 40) & 0xEF;
          }
          else
          {
            v30 = (float)((float)(v29 + 1.0) / -1.707) + 1.0;
            if ( v30 >= 0.0 )
            {
              if ( v30 > 1.0 )
                v30 = 1.0;
            }
            else
            {
              v30 = 0.0;
            }
            v31 = this->m_iMoveState;
            v32 = 1.5;
            v33 = 4.0;
            if ( v31 == 7 )
              v32 = 3.0;
            v34 = v30 * v32;
            if ( v31 == 7 )
              v33 = 5.0;
            v35 = *((_BYTE *)this + 40);
            this->m_SpeedDecreaseDistance = v33;
            this->m_SpeedIncreaseDistance = v33;
            v6 = v35 | 0x10;
            this->m_SpeedDecreaseAmt = v34;
          }
          *((_BYTE *)this + 40) = v6;
          goto LABEL_39;
        }
        v17 = this->m_iProgress + 1;
        if ( v17 == m_iRouteSize )
          v17 = 0;
      }
      else
      {
        v24 = this->m_iProgress;
        v17 = v24 + 1;
        if ( v24 + 1 >= m_iRouteSize )
          v17 = v24 - 1;
      }
    }
    v25 = (float *)(&m_pRoute->m_iRouteSize + 3 * v17);
    v40 = v25[1];
    v39 = v25[2];
    goto LABEL_27;
  }
  return iSubTaskType;
}

//----- (0051ED1C) --------------------------------------------------------
CVector *__fastcall CTaskComplexFollowPointRoute::GetLastWaypoint(
        CVector *retstr,
        CTaskComplexFollowPointRoute *this,
        CPed *ped)
{
  CPointRoute *m_pRoute; // r4
  RwReal z; // r1
  __int64 v5; // d16
  int m_iProgress; // lr
  int v7; // r1
  __int64 v8; // d16
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r3

  m_pRoute = this->m_pRoute;
  if ( m_pRoute->m_iRouteSize == 1 )
  {
    z = m_pRoute->m_routePoints[0].z;
    v5 = *(_QWORD *)&m_pRoute->m_routePoints[0].x;
LABEL_3:
    retstr->z = z;
    *(_QWORD *)&retstr->x = v5;
    return retstr;
  }
  if ( this->m_iMode > 3u )
  {
    retstr->x = 0.0;
    retstr->y = 0.0;
    retstr->z = 0.0;
  }
  else
  {
    m_iProgress = this->m_iProgress;
    if ( m_iProgress )
    {
      v7 = 3 * m_iProgress;
    }
    else
    {
      if ( this->m_iRouteTraversals < 1 )
      {
        m_pMat = ped->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &ped->m_transform;
        v5 = *(_QWORD *)&p_tx->m_translate.x;
        z = p_tx->m_translate.z;
        goto LABEL_3;
      }
      v7 = 3 * m_pRoute->m_iRouteSize;
    }
    v8 = *(_QWORD *)((char *)m_pRoute + 4 * v7 - 8);
    retstr->z = *((RwReal *)&m_pRoute->m_iRouteSize + v7);
    *(_QWORD *)&retstr->x = v8;
  }
  return retstr;
}

//----- (0051ED8C) --------------------------------------------------------
CVector *__fastcall CTaskComplexFollowPointRoute::GetNextWaypoint(
        CVector *retstr,
        CTaskComplexFollowPointRoute *this,
        CPed *ped)
{
  CPointRoute *m_pRoute; // r2
  int m_iRouteSize; // lr
  RwReal z; // r1
  __int64 v6; // d16
  unsigned int m_iMode; // r3
  int m_iProgress; // r12
  int v9; // r1
  __int64 v10; // d16
  char *v11; // r1

  m_pRoute = this->m_pRoute;
  m_iRouteSize = m_pRoute->m_iRouteSize;
  if ( m_pRoute->m_iRouteSize != 1 )
  {
    m_iMode = this->m_iMode;
    if ( m_iMode >= 3 )
    {
      if ( m_iMode != 3 )
      {
        retstr->x = 0.0;
        retstr->y = 0.0;
        retstr->z = 0.0;
        return retstr;
      }
      v9 = this->m_iProgress + 1;
      if ( v9 == m_iRouteSize )
        goto LABEL_2;
    }
    else
    {
      m_iProgress = this->m_iProgress;
      v9 = m_iProgress + 1;
      if ( m_iProgress + 1 >= m_iRouteSize )
      {
        v10 = *(_QWORD *)((char *)m_pRoute + 12 * m_iProgress - 8);
        retstr->z = *((RwReal *)&m_pRoute->m_iRouteSize + 3 * m_iProgress);
        *(_QWORD *)&retstr->x = v10;
        return retstr;
      }
    }
    v11 = (char *)m_pRoute + 12 * v9;
    v6 = *(_QWORD *)(v11 + 4);
    z = *((float *)v11 + 3);
    goto LABEL_10;
  }
LABEL_2:
  z = m_pRoute->m_routePoints[0].z;
  v6 = *(_QWORD *)&m_pRoute->m_routePoints[0].x;
LABEL_10:
  retstr->z = z;
  *(_QWORD *)&retstr->x = v6;
  return retstr;
}

//----- (0051EDF8) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPointRoute::CreateFirstSubTask(CTaskComplexFollowPointRoute *this, CPed *pPed)
{
  CTaskComplexFollowPointRoute *v2; // r5
  CPed *v3; // r4
  char v4; // r0
  CPointRoute *m_pRoute; // r0
  int m_iRouteSize; // r2
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r11
  float v9; // s16
  int v10; // r6
  int v11; // r4
  int v12; // r9
  int v13; // r8
  float *v14; // r10
  float v15; // s0
  float *v16; // r0
  float v17; // s18
  float v18; // s20
  float v19; // s22
  float v20; // s2
  float y; // s8
  float v22; // s6
  float z; // s4
  float v24; // s3
  int v25; // r1
  float v26; // s0
  int m_routePoints; // r0
  float v28; // s4
  float32x2_t v29; // d17
  float32x2_t v30; // d17
  unsigned __int64 v31; // d3
  float v32; // s4
  int SubTaskType; // r2
  CPed *v35; // [sp+0h] [bp-58h]
  int v36; // [sp+4h] [bp-54h]
  CTaskComplexFollowPointRoute *v37; // [sp+8h] [bp-50h]
  CVector v38; // [sp+Ch] [bp-4Ch] BYREF

  v2 = this;
  v3 = pPed;
  v4 = *((_BYTE *)this + 40);
  *((_BYTE *)v2 + 40) = v4 & 0xFD;
  if ( (v4 & 8) != 0 )
  {
    *(_QWORD *)&v2->m_SpeedDecreaseDistance = 0LL;
    *(_QWORD *)&v2->m_SpeedDecreaseAmt = 0LL;
  }
  m_pRoute = v2->m_pRoute;
  m_iRouteSize = m_pRoute->m_iRouteSize;
  if ( m_pRoute->m_iRouteSize )
  {
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      SubTaskType = 704;
    }
    else
    {
      if ( v2->m_iMode )
      {
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v3->m_transform;
        if ( m_iRouteSize < 1 )
        {
          v10 = -1;
        }
        else
        {
          v9 = 3.4028e38;
          v10 = -1;
          v35 = v3;
          v11 = 8;
          v12 = 1;
          v37 = v2;
          v36 = m_pRoute->m_iRouteSize;
          while ( 1 )
          {
            v13 = v12;
            if ( m_iRouteSize == v12 )
              v13 = 0;
            v14 = (float *)((char *)&m_pRoute->m_iRouteSize + v11);
            v15 = *(float *)((char *)m_pRoute + v11 - 4);
            v16 = (float *)(&m_pRoute->m_iRouteSize + 3 * v13);
            v17 = v16[1] - v15;
            v38.x = v17;
            v18 = v16[2] - *v14;
            v38.y = v18;
            v19 = v16[3] - v14[1];
            v38.z = v19;
            CVector::Normalise(&v38);
            v20 = *(v14 - 1);
            y = p_tx->m_translate.y;
            v22 = v14[1];
            z = p_tx->m_translate.z;
            v24 = (float)((float)((float)(p_tx->m_translate.x - v20) * v38.x) + (float)((float)(y - *v14) * v38.y))
                + (float)((float)(z - v22) * v38.z);
            if ( v24 > 0.0
              && v24 < sqrtf((float)(v19 * v19) + (float)((float)(v17 * v17) + (float)(v18 * v18)))
              && (float)((float)((float)(z - (float)(v22 + (float)(v38.z * v24)))
                               * (float)(z - (float)(v22 + (float)(v38.z * v24))))
                       + (float)((float)((float)(p_tx->m_translate.x - (float)(v20 + (float)(v38.x * v24)))
                                       * (float)(p_tx->m_translate.x - (float)(v20 + (float)(v38.x * v24))))
                               + (float)((float)(y - (float)(*v14 + (float)(v38.y * v24)))
                                       * (float)(y - (float)(*v14 + (float)(v38.y * v24)))))) < (float)(v9 * v9) )
            {
              v9 = (float)((float)(z - (float)(v22 + (float)(v38.z * v24)))
                         * (float)(z - (float)(v22 + (float)(v38.z * v24))))
                 + (float)((float)((float)(p_tx->m_translate.x - (float)(v20 + (float)(v38.x * v24)))
                                 * (float)(p_tx->m_translate.x - (float)(v20 + (float)(v38.x * v24))))
                         + (float)((float)(y - (float)(*v14 + (float)(v38.y * v24)))
                                 * (float)(y - (float)(*v14 + (float)(v38.y * v24)))));
              v10 = v13;
            }
            m_iRouteSize = v36;
            v2 = v37;
            if ( v36 == v12 )
              break;
            ++v12;
            m_pRoute = v37->m_pRoute;
            v11 += 12;
          }
          if ( v10 == -1 )
          {
            v3 = v35;
            v25 = 0;
            v26 = 3.4028e38;
            v10 = -1;
            m_routePoints = (int)v37->m_pRoute->m_routePoints;
            do
            {
              v28 = *(float *)m_routePoints;
              v29.n64_u64[0] = *(unsigned __int64 *)(m_routePoints + 4);
              m_routePoints += 12;
              v30.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, v29).n64_u64[0];
              v31 = vmul_f32(v30, v30).n64_u64[0];
              v32 = (float)((float)((float)(p_tx->m_translate.x - v28) * (float)(p_tx->m_translate.x - v28))
                          + *(float *)&v31)
                  + *((float *)&v31 + 1);
              if ( v32 < (float)(v26 * v26) )
              {
                v26 = v32;
                v10 = v25;
              }
              ++v25;
            }
            while ( v36 != v25 );
          }
          else
          {
            v3 = v35;
          }
        }
        v2->m_iProgress = v10;
      }
      SubTaskType = CTaskComplexFollowPointRoute::GetSubTaskType(v2);
      if ( (*((_BYTE *)v2 + 40) & 8) != 0 )
        SubTaskType = CTaskComplexFollowPointRoute::CalcGoToTaskType(v2, v3, SubTaskType);
    }
  }
  else
  {
    SubTaskType = 200;
  }
  return CTaskComplexFollowPointRoute::CreateSubTask(v2, SubTaskType, v3);
}
// 51EF92: conditional instruction was optimized away because %var_54.4>=1

//----- (0051F034) --------------------------------------------------------
float __fastcall CTaskComplexFollowPointRoute::CalcBlendRatio(
        CTaskComplexFollowPointRoute *this,
        CPed *ped,
        bool slowing)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  _BOOL4 v5; // r6
  CMatrix *v7; // r0
  CSimpleTransform *p_m_transform; // r5
  float *v9; // r0
  float v10; // s0
  float v11; // s2
  CPointRoute *m_pRoute; // r3
  CMatrix *m_pMat; // r5
  int m_iRouteSize; // r2
  CSimpleTransform *p_tx; // r0
  float *p_z; // r1
  float *p_y; // r2
  float *p_x; // r3
  int m_iProgress; // r1
  int v20; // r1
  float v21; // s0
  float v22; // s2
  float v23; // s4
  float v24; // s6
  float v25; // s0
  float v26; // s0
  float *p_m_SpeedIncreaseAmt; // r0

  v5 = slowing;
  if ( !slowing )
  {
    m_pRoute = this->m_pRoute;
    m_pMat = ped->m_pMat;
    m_iRouteSize = m_pRoute->m_iRouteSize;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &ped->m_transform;
    if ( m_iRouteSize == 1 )
    {
      p_z = &m_pRoute->m_routePoints[0].z;
      p_y = &m_pRoute->m_routePoints[0].y;
      p_x = &m_pRoute->m_routePoints[0].x;
    }
    else
    {
      if ( this->m_iMode > 3u )
      {
        v21 = 0.0;
        v22 = 0.0;
        v23 = 0.0;
LABEL_17:
        v24 = (float)(p_tx->m_translate.z - v21) * (float)(p_tx->m_translate.z - v21);
        v10 = this->m_SpeedIncreaseDistance * this->m_SpeedIncreaseDistance;
        v11 = (float)((float)((float)(p_tx->m_translate.x - v23) * (float)(p_tx->m_translate.x - v23))
                    + (float)((float)(p_tx->m_translate.y - v22) * (float)(p_tx->m_translate.y - v22)))
            + v24;
        goto LABEL_18;
      }
      m_iProgress = this->m_iProgress;
      if ( m_iProgress )
      {
        v20 = 3 * m_iProgress;
      }
      else
      {
        if ( this->m_iRouteTraversals < 1 )
        {
          p_z = &p_tx->m_translate.z;
          p_y = &p_tx->m_translate.y;
          p_x = &p_tx->m_translate.x;
          goto LABEL_16;
        }
        v20 = 3 * m_iRouteSize;
      }
      p_z = (float *)(&m_pRoute->m_iRouteSize + v20);
      p_y = p_z - 1;
      p_x = p_z - 2;
    }
LABEL_16:
    v21 = *p_z;
    v22 = *p_y;
    v23 = *p_x;
    goto LABEL_17;
  }
  v7 = ped->m_pMat;
  p_m_transform = (CSimpleTransform *)&v7->tx;
  if ( !v7 )
    p_m_transform = &ped->m_transform;
  v9 = (float *)(&this->m_pRoute->m_iRouteSize + 3 * this->m_iProgress);
  v10 = this->m_SpeedDecreaseDistance * this->m_SpeedDecreaseDistance;
  v11 = (float)((float)((float)(v9[1] - p_m_transform->m_translate.x) * (float)(v9[1] - p_m_transform->m_translate.x))
              + (float)((float)(v9[2] - p_m_transform->m_translate.y) * (float)(v9[2] - p_m_transform->m_translate.y)))
      + (float)((float)(v9[3] - p_m_transform->m_translate.z) * (float)(v9[3] - p_m_transform->m_translate.z));
LABEL_18:
  if ( v11 >= v10 )
    return -1.0;
  v25 = v11 / v10;
  if ( v25 >= 0.0 )
  {
    if ( v25 > 1.0 )
      v25 = 1.0;
  }
  else
  {
    v25 = 0.0;
  }
  v4.n64_u32[0] = cosf(v25 * 3.1416);
  p_m_SpeedIncreaseAmt = &this->m_SpeedIncreaseAmt;
  if ( v5 )
    p_m_SpeedIncreaseAmt = &this->m_SpeedDecreaseAmt;
  v3.n64_f32[0] = (float)(v4.n64_f32[0] * 0.5) + 0.5;
  v4.n64_f32[0] = *p_m_SpeedIncreaseAmt;
  v4.n64_f32[0] = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState)
                - (float)(v4.n64_f32[0] * v3.n64_f32[0]);
  v3.n64_u32[0] = CTaskSimpleGoToPointFine::BaseRatio(PEDMOVE_WALK);
  LODWORD(v26) = vmax_f32(v3, v4).n64_u32[0];
  return v26;
}
// 51F1B6: variable 'v3' is possibly undefined
// 51F1B6: variable 'v4' is possibly undefined

//----- (0051F1DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPointRoute::ControlSubTask(CTaskComplexFollowPointRoute *this, CPed *pPed)
{
  CTask *m_pSubTask; // r5
  char v5; // r1
  int v6; // r0
  float v8; // r1
  int m_iMoveState; // r0
  CTaskSimpleGoToPointFine *v10; // r5
  float v11; // r0
  CTaskSimple *v12; // r0
  int v13; // r6
  __int64 v14; // r8
  char v15; // r4
  char m_pParent; // r2
  char v17; // r3
  int v18; // r0
  __int64 v19; // d16
  float v20; // r6
  CTask *v21; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 704 )
    return this->m_pSubTask;
  if ( pPed->m_pPedIntelligence->m_iStaticCounter > 30 || this->m_pRoute->m_iRouteSize < 1 )
    return 0;
  v5 = *((_BYTE *)this + 40);
  if ( (v5 & 2) == 0 )
  {
    if ( (*((_BYTE *)this + 40) & 8) != 0 )
    {
      v6 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
      v5 = *((_BYTE *)this + 40);
      if ( v6 == 200 )
      {
        m_pSubTask = this->m_pSubTask;
        *((_BYTE *)this + 40) = v5 & 0x8F;
        return m_pSubTask;
      }
    }
    if ( (v5 & 8) == 0 )
      return this->m_pSubTask;
    if ( (v5 & 0x20) != 0 )
    {
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 926 )
      {
        v8 = CTaskComplexFollowPointRoute::CalcBlendRatio(this, pPed, 1);
        if ( v8 < 0.0 )
          v8 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState);
        goto LABEL_22;
      }
      v5 = *((_BYTE *)this + 40);
    }
    if ( (v5 & 0x40) == 0
      || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 926 )
    {
LABEL_23:
      if ( (*((_BYTE *)this + 40) & 0x30) == 16 )
      {
        v20 = CTaskComplexFollowPointRoute::CalcBlendRatio(this, pPed, 1);
        if ( v20 >= 0.0 )
        {
          v21 = this->m_pSubTask;
          *((_BYTE *)this + 40) = *((_BYTE *)this + 40) & 0x8F | 0x20;
          if ( (*((int (__fastcall **)(CTask *))v21->_vptr$CTask + 5))(v21) != 926 )
          {
            m_pSubTask = CTaskComplexFollowPointRoute::CreateSubTask(this, 926, pPed);
            CTaskSimpleGoToPointFine::SetMoveRatio((CTaskSimpleGoToPointFine *)m_pSubTask, v20);
            return m_pSubTask;
          }
          CTaskSimpleGoToPointFine::SetMoveRatio((CTaskSimpleGoToPointFine *)this->m_pSubTask, v20);
        }
      }
      return this->m_pSubTask;
    }
    v8 = CTaskComplexFollowPointRoute::CalcBlendRatio(this, pPed, 0);
    if ( v8 < 0.0 )
    {
      m_iMoveState = this->m_iMoveState;
      v10 = (CTaskSimpleGoToPointFine *)this->m_pSubTask;
      *((_BYTE *)this + 40) &= ~0x40u;
      v11 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)m_iMoveState);
      CTaskSimpleGoToPointFine::SetMoveRatio(v10, v11);
      v12 = (CTaskSimple *)CTask::operator new(0x2Cu);
      v13 = this->m_iMoveState;
      m_pSubTask = v12;
      v14 = *(_QWORD *)&this->m_pRoute;
      v15 = *((_BYTE *)this + 40);
      CTaskSimple::CTaskSimple(v12);
      m_pSubTask[1]._vptr$CTask = (int (**)(void))v13;
      m_pSubTask->_vptr$CTask = (int (**)(void))&off_66C0A0;
      m_pParent = (char)m_pSubTask[3].m_pParent;
      v17 = BYTE1(m_pSubTask[3].m_pParent);
      v18 = v14 + 12 * HIDWORD(v14);
      v19 = *(_QWORD *)(v18 + 4);
      m_pSubTask[2].m_pParent = *(CTask **)(v18 + 12);
      m_pSubTask->_vptr$CTask = (int (**)(void))&off_66C0D4;
      m_pSubTask[3]._vptr$CTask = (int (**)(void))1056964608;
      BYTE1(m_pSubTask[3].m_pParent) = (8 * v15) & 8 | v17 & 0xE0;
      LOBYTE(m_pSubTask[3].m_pParent) = m_pParent & 0xC0;
      *(_QWORD *)&m_pSubTask[1].m_pParent = v19;
      return m_pSubTask;
    }
LABEL_22:
    CTaskSimpleGoToPointFine::SetMoveRatio((CTaskSimpleGoToPointFine *)this->m_pSubTask, v8);
    goto LABEL_23;
  }
  return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowPointRoute *, CPed *))this->_vptr$CTask + 11))(this, pPed);
}
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (0051F3C4) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
        CTaskComplexFollowNodeRoute *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fTargetRadius,
        const float fSlowDownDistance,
        const float fFollowNodeThresholdHeightChange,
        char bKeepNodesHeadingAwayFromTarget,
        const int iTime,
        int bUseBlending)
{
  __int64 v13; // d16
  char v14; // r3
  CPointRoute *v15; // r0
  CNodeRoute *v16; // r0

  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66C268;
  v13 = *(_QWORD *)&vTarget->x;
  v14 = *((_BYTE *)this + 76);
  this->m_vTarget.z = vTarget->z;
  this->m_iMoveState = iMoveState;
  this->m_fTargetRadius = fTargetRadius;
  this->m_fSlowDownDistance = fSlowDownDistance;
  this->m_fFollowNodeThresholdHeightChange = fFollowNodeThresholdHeightChange;
  this->m_iProgress = 0;
  this->m_iTime = iTime;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->m_startNode.Region = -1;
  this->m_CurrentNode.Region = -1;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  *((_BYTE *)this + 76) = bKeepNodesHeadingAwayFromTarget | (8 * bUseBlending) | v14 & 0xF6;
  *(_QWORD *)&this->m_vTarget.x = v13;
  if ( bUseBlending )
  {
    *((_BYTE *)this + 76) = (bKeepNodesHeadingAwayFromTarget | (8 * bUseBlending)) & 0x9F | v14 & 0x96;
    *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
    *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
  }
  v15 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v15->m_iRouteSize = 0;
  this->m_pPointRoute = v15;
  v16 = (CNodeRoute *)CNodeRoute::operator new(0x24u);
  v16->m_iRouteSize = 0;
  v16->m_routePoints[0].Region = -1;
  v16->m_routePoints[1].Region = -1;
  v16->m_routePoints[2].Region = -1;
  v16->m_routePoints[3].Region = -1;
  v16->m_routePoints[4].Region = -1;
  v16->m_routePoints[5].Region = -1;
  v16->m_routePoints[6].Region = -1;
  v16->m_routePoints[7].Region = -1;
  this->m_CurrentNode.Region = -1;
  this->m_pNodeRoute = v16;
  this->m_startNode = EmptyNodeAddress;
}
// 66C268: using guessed type void *;

//----- (0051F490) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::~CTaskComplexFollowNodeRoute(CTaskComplexFollowNodeRoute *this)
{
  CPointRoute *m_pPointRoute; // r0
  CNodeRoute *m_pNodeRoute; // r0

  m_pPointRoute = this->m_pPointRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C268;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  m_pNodeRoute = this->m_pNodeRoute;
  if ( m_pNodeRoute )
    CNodeRoute::operator delete(m_pNodeRoute);
  sub_18EDB4(this);
}
// 66C268: using guessed type void *off_66C268;

//----- (0051F4C4) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::~CTaskComplexFollowNodeRoute(CTaskComplexFollowNodeRoute *this)
{
  CPointRoute *m_pPointRoute; // r0
  CNodeRoute *m_pNodeRoute; // r0
  void *v4; // r0

  m_pPointRoute = this->m_pPointRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C268;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  m_pNodeRoute = this->m_pNodeRoute;
  if ( m_pNodeRoute )
    CNodeRoute::operator delete(m_pNodeRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 51F4F2: variable 'v4' is possibly undefined
// 66C268: using guessed type void *off_66C268;

//----- (0051F4FC) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::StopTimer(CTaskComplexFollowNodeRoute *this, const CEvent *pEvent)
{
  __int64 v3; // kr00_8

  if ( !CEventHandler::IsTemporaryEvent(pEvent) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v3 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v3) - CTimer::m_snTimeInMilliseconds + v3;
    }
  }
}

//----- (0051F534) --------------------------------------------------------
bool __fastcall CTaskComplexFollowNodeRoute::MakeAbortable(
        CTaskComplexFollowNodeRoute *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  const CVector *m_pSubTask; // r10
  int v9; // r0
  char *p_m_bIsPersistent; // r0
  int v11; // r9
  int v12; // r0
  bool v13; // zf
  bool v14; // zf
  int v15; // r0
  CMatrix *m_pMat; // r1
  float *v17; // r2
  CSimpleTransform *p_tx; // r0

  if ( !pEvent || this->m_iProgress + 1 == this->m_pPointRoute->m_iRouteSize )
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  v9 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent);
  if ( v9 == 1 )
  {
    p_m_bIsPersistent = (char *)&pEvent[1].m_bIsPersistent;
  }
  else
  {
    if ( v9 != 56 )
    {
      v11 = 0;
      goto LABEL_9;
    }
    p_m_bIsPersistent = (char *)&pEvent[1].m_iAccumulatedTime;
  }
  v11 = *(_DWORD *)p_m_bIsPersistent;
LABEL_9:
  v12 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v13 = v12 == 926;
  if ( v12 != 926 )
    v13 = v12 == 900;
  if ( v13 )
  {
    v14 = v11 == 0;
    if ( v11 )
    {
      m_pSubTask = (const CVector *)this->m_pSubTask;
      v14 = m_pSubTask == 0;
    }
    if ( !v14
      && (float)((float)((float)(*(float *)(v11 + 72) * *(float *)(v11 + 72))
                       + (float)(*(float *)(v11 + 76) * *(float *)(v11 + 76)))
               + (float)(*(float *)(v11 + 80) * *(float *)(v11 + 80))) < 0.015625
      && CPedGeometryAnalyser::IsEntityBlockingTarget((CEntity *)v11, m_pSubTask + 1, m_pSubTask[2].x) )
    {
      v15 = *(_DWORD *)(v11 + 20);
      m_pMat = pPed->m_pMat;
      v17 = (float *)(v15 + 48);
      if ( !v15 )
        v17 = (float *)(v11 + 4);
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      m_pSubTask[2].x = sqrtf(
                          (float)((float)(p_tx->m_translate.x - *v17) * (float)(p_tx->m_translate.x - *v17))
                        + (float)((float)(p_tx->m_translate.y - v17[1]) * (float)(p_tx->m_translate.y - v17[1])));
    }
  }
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}
// 51F5D0: variable 'm_pSubTask' is possibly undefined

//----- (0051F644) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::SetTarget(
        CTaskComplexFollowNodeRoute *this,
        const CPed *pPed,
        const CVector *vTarget,
        const float fTargetRadius,
        const float fSlowDownDistance,
        const float fFollowNodeThresholdHeightChange,
        int bForce)
{
  char v8; // r0
  __int64 v9; // d16

  if ( bForce
    || this->m_vTarget.x != vTarget->x
    || this->m_vTarget.y != vTarget->y
    || this->m_vTarget.z != vTarget->z
    || this->m_fTargetRadius != fTargetRadius
    || this->m_fSlowDownDistance != fSlowDownDistance
    || this->m_fFollowNodeThresholdHeightChange != fFollowNodeThresholdHeightChange )
  {
    v8 = *((_BYTE *)this + 76);
    v9 = *(_QWORD *)&vTarget->x;
    this->m_vTarget.z = vTarget->z;
    this->m_fTargetRadius = fTargetRadius;
    this->m_fSlowDownDistance = fSlowDownDistance;
    this->m_fFollowNodeThresholdHeightChange = fFollowNodeThresholdHeightChange;
    *(_QWORD *)&this->m_vTarget.x = v9;
    if ( (v8 & 8) != 0 )
    {
      *((_BYTE *)this + 76) = v8 & 0x9F | 0x40;
      *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
      *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
    }
    CTaskComplexFollowNodeRoute::ComputePathNodes(this, pPed);
    CTaskComplexFollowNodeRoute::ComputeRoute(this);
    *((_BYTE *)this + 76) |= 4u;
  }
}

//----- (0051F710) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::ComputePathNodes(CTaskComplexFollowNodeRoute *this, const CPed *pPed)
{
  float32x2_t *p_m_vTarget; // r5
  float GroundZFor3DCoord; // r0
  float z; // s0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r8
  float32x2_t *p_tx; // r0
  int16x4_t v10; // d16
  unsigned __int64 v11; // d1
  CSimpleTransform *v12; // r2
  CMatrix *v13; // r0
  CSimpleTransform *v14; // r1
  CNodeRoute *m_pNodeRoute; // r0
  int m_iRouteSize; // r2
  float v17; // s0
  CNodeAddress v18; // r3
  CPathNode *v19; // r2
  float32x2_t v20; // d16
  unsigned __int64 v21; // d2
  float v22; // s0
  float v23; // s2
  float v24; // s4
  CNodeAddress v25; // r3
  CPathNode *v26; // r2
  float32x2_t v27; // d16
  unsigned __int64 v28; // d2
  InteriorGroup_c *PedsInteriorGroup; // r0
  CNodeRoute *v30; // r9
  int v31; // r1
  bool v32; // zf
  Interior_c *PedsInterior; // r5
  CPathNode *v34; // r0
  int CoorsX; // s6
  int CoorsZ; // s2
  Interior_c *VectorsInterior; // r0
  bool v38; // zf
  const CNodeAddress *v39; // r10
  CMatrix *v40; // r2
  int v41; // r10
  unsigned int v42; // r0
  CPathNode *v43; // r1
  __int16 *v44; // r0
  RwReal v45; // s2
  bool v46; // cc
  CMatrix *v47; // r2
  CNodeRoute *v48; // r0
  int v49; // r1
  int v50; // r2
  int v51; // r3
  int v52; // r6
  int Region; // r3
  int v54; // r1
  CNodeRoute *v55; // r0
  int v56; // r2
  int *v57; // r6
  CVector *TargetCoors; // [sp+Ch] [bp-44h]
  CVector pVector; // [sp+10h] [bp-40h] BYREF
  bool pBool; // [sp+1Fh] [bp-31h] BYREF

  this->m_pNodeRoute->m_iRouteSize = 0;
  pBool = 0;
  p_m_vTarget = (float32x2_t *)&this->m_vTarget;
  GroundZFor3DCoord = CWorld::FindGroundZFor3DCoord(
                        this->m_vTarget.x,
                        this->m_vTarget.y,
                        this->m_vTarget.z + 1.0,
                        &pBool,
                        0);
  if ( pBool )
  {
    z = GroundZFor3DCoord + 1.0;
    this->m_vTarget.z = GroundZFor3DCoord + 1.0;
  }
  else
  {
    z = this->m_vTarget.z;
  }
  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = (float32x2_t *)&pPed->m_transform;
  if ( m_pMat )
    p_tx = (float32x2_t *)&m_pMat->tx;
  v10.n64_u64[0] = vsub_f32((float32x2_t)p_tx->n64_u64[0], (float32x2_t)p_m_vTarget->n64_u64[0]).n64_u64[0];
  v11 = vmul_f32(v10, v10).n64_u64[0];
  if ( sqrtf(
         (float)(*(float *)&v11 + *((float *)&v11 + 1))
       + (float)((float)(p_tx[1].n64_f32[0] - z) * (float)(p_tx[1].n64_f32[0] - z))) <= pPed->m_pPedIntelligence->m_fFollowNodeThresholdDistance )
  {
    if ( (*((_DWORD *)&pPed->m_nPedFlags + 3) & 0x8000) != 0
      || CPedGeometryAnalyser::IsWanderPathClear(
           (const CVector *)p_tx,
           (const CVector *)p_m_vTarget,
           this->m_fFollowNodeThresholdHeightChange,
           4) == 4 )
    {
      goto LABEL_12;
    }
    m_pMat = pPed->m_pMat;
  }
  v12 = &pPed->m_transform;
  if ( m_pMat )
    v12 = (CSimpleTransform *)&m_pMat->tx;
  CPathFind::ComputeRoute(
    &ThePaths,
    COERCE_RWREAL(1),
    &v12->m_translate,
    (const CVector *)p_m_vTarget,
    &this->m_startNode,
    this->m_pNodeRoute);
  this->m_startNode = EmptyNodeAddress;
LABEL_12:
  v13 = pPed->m_pMat;
  v14 = &pPed->m_transform;
  if ( v13 )
    v14 = (CSimpleTransform *)&v13->tx;
  m_pNodeRoute = this->m_pNodeRoute;
  m_iRouteSize = m_pNodeRoute->m_iRouteSize;
  v17 = fabsf(v14->m_translate.z - this->m_vTarget.z);
  if ( v17 >= this->m_fFollowNodeThresholdHeightChange )
  {
    if ( m_iRouteSize < 1 )
      goto LABEL_27;
  }
  else
  {
    if ( m_iRouteSize < 1 )
      goto LABEL_27;
    if ( !(*((unsigned __int8 *)this + 76) << 31) )
    {
      if ( m_pNodeRoute->m_routePoints[0].Region != 0xFFFF )
      {
        v18 = m_pNodeRoute->m_routePoints[0];
        v19 = ThePaths.pNodes[v18.Region];
        if ( v19 )
        {
          v10.n64_u32[0] = *(_DWORD *)&v19[HIWORD(*(unsigned int *)&v18)].CoorsX;
          v20.n64_u64[0] = vsub_f32(
                             (float32x2_t)p_m_vTarget->n64_u64[0],
                             vmul_f32(
                               vcvt_f32_s32((int32x2_t)vmovl_s16(v10).n128_u64[0]),
                               (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
          v21 = vmul_f32(v20, v20).n64_u64[0];
          v22 = sqrtf(
                  (float)((float)((float)(p_m_vTarget->n64_f32[0] - v14->m_translate.x)
                                * (float)(p_m_vTarget->n64_f32[0] - v14->m_translate.x))
                        + (float)((float)(p_m_vTarget->n64_f32[1] - v14->m_translate.y)
                                * (float)(p_m_vTarget->n64_f32[1] - v14->m_translate.y)))
                + 0.0);
          v23 = (float)(*(float *)&v21 + *((float *)&v21 + 1)) + 0.0;
          v24 = 3.0;
          goto LABEL_25;
        }
      }
      goto LABEL_27;
    }
  }
  if ( !(*((unsigned __int8 *)this + 76) << 31) && m_pNodeRoute->m_routePoints[0].Region != 0xFFFF )
  {
    v25 = m_pNodeRoute->m_routePoints[0];
    v26 = ThePaths.pNodes[v25.Region];
    if ( v26 )
    {
      v10.n64_u32[0] = *(_DWORD *)&v26[HIWORD(*(unsigned int *)&v25)].CoorsX;
      v27.n64_u64[0] = vsub_f32(
                         (float32x2_t)p_m_vTarget->n64_u64[0],
                         vmul_f32(
                           vcvt_f32_s32((int32x2_t)vmovl_s16(v10).n128_u64[0]),
                           (float32x2_t)0x3E0000003E000000LL)).n64_u64[0];
      v28 = vmul_f32(v27, v27).n64_u64[0];
      v22 = sqrtf(
              (float)((float)((float)(p_m_vTarget->n64_f32[0] - v14->m_translate.x)
                            * (float)(p_m_vTarget->n64_f32[0] - v14->m_translate.x))
                    + (float)((float)(p_m_vTarget->n64_f32[1] - v14->m_translate.y)
                            * (float)(p_m_vTarget->n64_f32[1] - v14->m_translate.y)))
            + 0.0);
      v23 = (float)(*(float *)&v28 + *((float *)&v28 + 1)) + 0.0;
      v24 = 50.0;
LABEL_25:
      v17 = v22 + v24;
      if ( sqrtf(v23) > v17 )
        m_pNodeRoute->m_iRouteSize = 0;
    }
  }
LABEL_27:
  TargetCoors = (CVector *)p_m_vTarget;
  PedsInteriorGroup = InteriorManager_c::GetPedsInteriorGroup(&g_interiorMan, (CPed *)pPed);
  v30 = this->m_pNodeRoute;
  v31 = v30->m_iRouteSize;
  if ( PedsInteriorGroup )
  {
    v32 = v31 == 0;
    if ( v31 )
      v32 = v30->m_routePoints[0].Region == 0xFFFF;
    if ( !v32 && ThePaths.pNodes[v30->m_routePoints[0].Region] )
    {
      PedsInterior = InteriorManager_c::GetPedsInterior(&g_interiorMan, (CPed *)pPed);
      v34 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)v30->m_routePoints][HIWORD(*(_DWORD *)v30->m_routePoints)];
      CoorsX = v34->CoorsX;
      CoorsZ = v34->CoorsZ;
      pVector.y = (float)v34->CoorsY * 0.125;
      pVector.x = (float)CoorsX * 0.125;
      pVector.z = (float)((float)CoorsZ * 0.125) + 1.0;
      VectorsInterior = InteriorManager_c::GetVectorsInterior(&g_interiorMan, &pVector);
      v38 = PedsInterior == 0;
      v39 = (const CNodeAddress *)VectorsInterior;
      if ( PedsInterior )
        v38 = PedsInterior == VectorsInterior;
      if ( v38 )
      {
        if ( !PedsInterior
          && VectorsInterior
          && !CPathFind::These2NodesAreAdjacent(&ThePaths, v30->m_routePoints[0], VectorsInterior->m_doorAddr) )
        {
          this->m_pNodeRoute->m_iRouteSize = 0;
          v47 = pPed->m_pMat;
          if ( v47 )
            p_m_transform = (CSimpleTransform *)&v47->tx;
          CPathFind::ComputeRoute(
            &ThePaths,
            COERCE_RWREAL(1),
            TargetCoors,
            &p_m_transform->m_translate,
            v39 + 252,
            this->m_pNodeRoute);
          v48 = this->m_pNodeRoute;
          v49 = v48->m_iRouteSize;
          if ( v48->m_iRouteSize >= 2 )
          {
            v50 = 1;
            do
            {
              v51 = *(&v48->m_iRouteSize + v50);
              *(&v48->m_iRouteSize + v50) = *(&v48->m_iRouteSize + v49);
              v52 = v49 - 2;
              *(&v48->m_iRouteSize + v49--) = v51;
              v46 = v50++ < v52;
            }
            while ( v46 );
          }
        }
      }
      else if ( !CPathFind::These2NodesAreAdjacent(&ThePaths, v30->m_routePoints[0], PedsInterior->m_doorAddr) )
      {
        this->m_pNodeRoute->m_iRouteSize = 0;
        v40 = pPed->m_pMat;
        if ( v40 )
          p_m_transform = (CSimpleTransform *)&v40->tx;
        CPathFind::ComputeRoute(
          &ThePaths,
          COERCE_RWREAL(1),
          &p_m_transform->m_translate,
          TargetCoors,
          &PedsInterior->m_doorAddr,
          this->m_pNodeRoute);
      }
    }
    goto LABEL_62;
  }
  if ( v31 < 1 )
    goto LABEL_62;
  v41 = 1;
  while ( 1 )
  {
    v42 = *(&v30->m_iRouteSize + v41);
    if ( (unsigned __int16)v42 != 0xFFFF )
    {
      v43 = ThePaths.pNodes[(unsigned __int16)v42];
      if ( v43 )
      {
        v44 = (__int16 *)&v43[HIWORD(v42)];
        v17 = (float)v44[4] * 0.125;
        v45 = (float)v44[6] * 0.125;
        pVector.y = (float)v44[5] * 0.125;
        pVector.x = v17;
        pVector.z = v45;
      }
    }
    pVector.z = pVector.z + 1.0;
    v17 = sqrtf(
            (float)((float)((float)(v17 - this->m_vTarget.x) * (float)(v17 - this->m_vTarget.x))
                  + (float)((float)(pVector.y - this->m_vTarget.y) * (float)(pVector.y - this->m_vTarget.y)))
          + (float)((float)(pVector.z - this->m_vTarget.z) * (float)(pVector.z - this->m_vTarget.z)));
    if ( v17 > pPed->m_pPedIntelligence->m_fFollowNodeThresholdDistance )
      goto LABEL_48;
    if ( (*((_DWORD *)&pPed->m_nPedFlags + 3) & 0x8000) != 0
      || CPedGeometryAnalyser::IsWanderPathClear(
           &pVector,
           (const CVector *)p_m_vTarget,
           this->m_fFollowNodeThresholdHeightChange,
           4) == 4 )
    {
      break;
    }
    v30 = this->m_pNodeRoute;
LABEL_48:
    v46 = v41++ < v30->m_iRouteSize;
    if ( !v46 )
      goto LABEL_62;
  }
  if ( v41 - 1 <= 7 )
    this->m_pNodeRoute->m_iRouteSize = v41;
LABEL_62:
  Region = this->m_CurrentNode.Region;
  v54 = 0;
  v55 = this->m_pNodeRoute;
  this->m_iProgress = 0;
  if ( Region == 0xFFFF )
  {
LABEL_63:
    this->m_iProgress = v54;
    v56 = v55->m_iRouteSize;
LABEL_70:
    if ( v56 >= 1 )
      this->m_CurrentNode = v55->m_routePoints[v54];
  }
  else
  {
    v56 = v55->m_iRouteSize;
    if ( v55->m_iRouteSize >= 1 )
    {
      v54 = 0;
      while ( 1 )
      {
        v57 = &v55->m_iRouteSize + v54;
        if ( Region == *((unsigned __int16 *)v57 + 2) && this->m_CurrentNode.Index == *((unsigned __int16 *)v57 + 3) )
          goto LABEL_63;
        if ( ++v54 >= v56 )
        {
          v54 = 0;
          goto LABEL_70;
        }
      }
    }
  }
}

//----- (0051FC90) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::ComputeRoute(CTaskComplexFollowNodeRoute *this)
{
  CNodeRoute *m_pNodeRoute; // r1
  int m_iRouteSize; // r12
  int i; // r2
  unsigned int v4; // r4
  CPathNode *v5; // r5
  CPointRoute *m_pPointRoute; // r1
  float *v7; // r3
  __int16 *v8; // r4
  int v9; // r6
  float v10; // s6
  CPointRoute *v11; // r1
  __int64 v12; // d16
  char *v13; // r2
  char v14; // r1

  this->m_pPointRoute->m_iRouteSize = 0;
  m_pNodeRoute = this->m_pNodeRoute;
  m_iRouteSize = m_pNodeRoute->m_iRouteSize;
  if ( m_pNodeRoute->m_iRouteSize >= 1 )
  {
    for ( i = 1; ; ++i )
    {
      v4 = *(&m_pNodeRoute->m_iRouteSize + i);
      v5 = ThePaths.pNodes[(unsigned __int16)v4];
      if ( v5 )
      {
        m_pPointRoute = this->m_pPointRoute;
        if ( m_pPointRoute->m_iRouteSize <= 7 )
        {
          v7 = (float *)(&m_pPointRoute->m_iRouteSize + 3 * m_pPointRoute->m_iRouteSize);
          v8 = (__int16 *)&v5[HIWORD(v4)];
          v9 = v8[5];
          v10 = (float)v8[6] * 0.125;
          v7[1] = (float)v8[4] * 0.125;
          v7[2] = (float)v9 * 0.125;
          v7[3] = v10;
          ++m_pPointRoute->m_iRouteSize;
        }
      }
      if ( m_iRouteSize == i )
        break;
      m_pNodeRoute = this->m_pNodeRoute;
    }
  }
  v11 = this->m_pPointRoute;
  if ( v11->m_iRouteSize > 7 )
  {
    v14 = 0;
  }
  else
  {
    v12 = *(_QWORD *)&this->m_vTarget.x;
    v13 = (char *)v11 + 12 * v11->m_iRouteSize;
    *((_DWORD *)v13 + 3) = LODWORD(this->m_vTarget.z);
    *(_QWORD *)(v13 + 4) = v12;
    ++v11->m_iRouteSize;
    v14 = 2;
  }
  *((_BYTE *)this + 76) = v14 | *((_BYTE *)this + 76) & 0xFD;
}

//----- (0051FD70) --------------------------------------------------------
int __fastcall CTaskComplexFollowNodeRoute::GetRouteSize(CTaskComplexFollowNodeRoute *this)
{
  CPointRoute *m_pPointRoute; // r0

  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute )
    return m_pPointRoute->m_iRouteSize;
  else
    return 0;
}

//----- (0051FD7C) --------------------------------------------------------
int __fastcall CTaskComplexFollowNodeRoute::CalcGoToTaskType(
        CTaskComplexFollowNodeRoute *this,
        CPed *pPed,
        int iSubTaskType)
{
  int m_iMoveState; // r2
  char v5; // r0
  CPointRoute *m_pPointRoute; // r0
  int m_iProgress; // r3
  int m_iRouteSize; // r6
  int v9; // r2
  float *p_y; // r1
  CSimpleTransform *m_routePoints; // r3
  char *v12; // r3
  CMatrix *m_pMat; // r6
  int v14; // r6
  float v15; // s0
  float *v16; // r0
  float v17; // s4
  RwReal v18; // s2
  CPointRoute *v19; // r0
  int v20; // r1
  int v21; // r3
  CVector *v22; // r0
  float *p_x; // r2
  float *v24; // r0
  float v25; // s6
  float v26; // s2
  RwReal v27; // s0
  float v28; // s0
  float v29; // s0
  int v30; // r0
  float v31; // s2
  float v32; // s4
  float v33; // s0
  char v34; // r0
  CVector v36; // [sp+0h] [bp-28h] BYREF
  CVector v37; // [sp+Ch] [bp-1Ch] BYREF

  if ( iSubTaskType == 900 )
  {
    m_iMoveState = this->m_iMoveState;
    v5 = *((_BYTE *)this + 76) & 0xEF;
    this->m_SpeedIncreaseAmt = this->m_SpeedDecreaseAmt;
    *((_BYTE *)this + 76) = v5;
    if ( m_iMoveState >= 5 )
    {
      m_pPointRoute = this->m_pPointRoute;
      m_iProgress = this->m_iProgress;
      m_iRouteSize = m_pPointRoute->m_iRouteSize;
      v9 = m_iProgress;
      if ( m_iProgress >= m_pPointRoute->m_iRouteSize )
        v9 = m_iRouteSize - 1;
      if ( v9 < 0 )
        return 900;
      if ( m_iRouteSize == 1 )
      {
        p_y = &m_pPointRoute->m_routePoints[0].y;
        m_routePoints = (CSimpleTransform *)m_pPointRoute->m_routePoints;
      }
      else if ( m_iProgress )
      {
        v12 = (char *)m_pPointRoute + 12 * m_iProgress;
        p_y = (float *)(v12 - 4);
        m_routePoints = (CSimpleTransform *)(v12 - 8);
      }
      else
      {
        m_pMat = pPed->m_pMat;
        m_routePoints = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          m_routePoints = &pPed->m_transform;
        p_y = &m_routePoints->m_translate.y;
      }
      v14 = v9;
      v15 = *p_y;
      v16 = (float *)(&m_pPointRoute->m_iRouteSize + 3 * v9);
      v17 = v16[2];
      v18 = v16[1] - m_routePoints->m_translate.x;
      v37.z = 0.0;
      v37.y = v17 - v15;
      v37.x = v18;
      CVector::Normalise(&v37);
      v19 = this->m_pPointRoute;
      v20 = 0;
      if ( v19->m_iRouteSize != 1 )
      {
        v21 = this->m_iProgress;
        v20 = v21 + 1;
        if ( v21 + 1 >= v19->m_iRouteSize )
          v20 = v21 - 1;
      }
      v22 = v19->m_routePoints;
      p_x = &v22[v14].x;
      v24 = &v22[v20].x;
      v25 = v24[1];
      v26 = p_x[1];
      v27 = *v24 - *p_x;
      v36.z = 0.0;
      v36.y = v25 - v26;
      v36.x = v27;
      CVector::Normalise(&v36);
      v28 = (float)((float)(v37.x * v36.x) + (float)(v37.y * v36.y)) + (float)(v37.z * v36.z);
      if ( v28 >= 0.707 )
      {
        v5 = *((_BYTE *)this + 76) & 0xEF;
      }
      else
      {
        v29 = (float)((float)(v28 + 1.0) / -1.707) + 1.0;
        if ( v29 >= 0.0 )
        {
          if ( v29 > 1.0 )
            v29 = 1.0;
        }
        else
        {
          v29 = 0.0;
        }
        v30 = this->m_iMoveState;
        v31 = 1.5;
        v32 = 4.0;
        if ( v30 == 7 )
          v31 = 3.0;
        v33 = v29 * v31;
        if ( v30 == 7 )
          v32 = 5.0;
        v34 = *((_BYTE *)this + 76);
        this->m_SpeedDecreaseDistance = v32;
        this->m_SpeedIncreaseDistance = v32;
        v5 = v34 | 0x10;
        this->m_SpeedDecreaseAmt = v33;
      }
      *((_BYTE *)this + 76) = v5;
    }
    iSubTaskType = 926;
    *((_BYTE *)this + 76) = v5 & 0x9F | (2 * (v5 & 0x20));
    if ( (v5 & 0x20) == 0 )
      return 900;
  }
  return iSubTaskType;
}

//----- (0051FF48) --------------------------------------------------------
CVector *__fastcall CTaskComplexFollowNodeRoute::GetLastWaypoint(
        CVector *retstr,
        CTaskComplexFollowNodeRoute *this,
        CPed *ped)
{
  CPointRoute *m_pPointRoute; // r12
  RwReal z; // r1
  __int64 v5; // d16
  int m_iProgress; // r1
  int v7; // r1
  __int64 v8; // d16
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r3

  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute->m_iRouteSize == 1 )
  {
    z = m_pPointRoute->m_routePoints[0].z;
    v5 = *(_QWORD *)&m_pPointRoute->m_routePoints[0].x;
  }
  else
  {
    m_iProgress = this->m_iProgress;
    if ( m_iProgress )
    {
      v7 = 3 * m_iProgress;
      v8 = *(_QWORD *)((char *)m_pPointRoute + 4 * v7 - 8);
      retstr->z = *((RwReal *)&m_pPointRoute->m_iRouteSize + v7);
      *(_QWORD *)&retstr->x = v8;
      return retstr;
    }
    m_pMat = ped->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &ped->m_transform;
    v5 = *(_QWORD *)&p_tx->m_translate.x;
    z = p_tx->m_translate.z;
  }
  retstr->z = z;
  *(_QWORD *)&retstr->x = v5;
  return retstr;
}

//----- (0051FF94) --------------------------------------------------------
CVector *__fastcall CTaskComplexFollowNodeRoute::GetNextWaypoint(
        CVector *retstr,
        CTaskComplexFollowNodeRoute *this,
        CPed *ped)
{
  CPointRoute *m_pPointRoute; // r2
  RwReal z; // r1
  __int64 v5; // d16
  int m_iProgress; // r12
  RwReal *p_z; // r1
  __int64 v8; // d16

  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute->m_iRouteSize == 1 )
  {
    z = m_pPointRoute->m_routePoints[0].z;
    v5 = *(_QWORD *)&m_pPointRoute->m_routePoints[0].x;
LABEL_5:
    retstr->z = z;
    *(_QWORD *)&retstr->x = v5;
    return retstr;
  }
  m_iProgress = this->m_iProgress;
  if ( m_iProgress + 1 < m_pPointRoute->m_iRouteSize )
  {
    p_z = &m_pPointRoute->m_routePoints[m_iProgress].z;
    v5 = *(_QWORD *)(p_z + 1);
    z = p_z[3];
    goto LABEL_5;
  }
  v8 = *(_QWORD *)((char *)m_pPointRoute + 12 * m_iProgress - 8);
  retstr->z = *((RwReal *)&m_pPointRoute->m_iRouteSize + 3 * m_iProgress);
  *(_QWORD *)&retstr->x = v8;
  return retstr;
}

//----- (0051FFDE) --------------------------------------------------------
int __fastcall CTaskComplexFollowNodeRoute::GetSubTaskType(
        const int iProgress,
        const bool bLastRoutePointIsTarget,
        const CPointRoute *route)
{
  int result; // r0
  int m_iRouteSize; // r1
  int v5; // r2

  if ( !bLastRoutePointIsTarget )
    return 900;
  m_iRouteSize = route->m_iRouteSize;
  if ( route->m_iRouteSize == iProgress )
    return 1302;
  v5 = iProgress + 1;
  result = 900;
  if ( v5 == m_iRouteSize )
    return 903;
  return result;
}

//----- (00520004) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRoute::CreateSubTask(
        const CTaskComplexFollowNodeRoute *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v5; // r4
  int m_iMoveState; // r6
  CPointRoute *v7; // r8
  int v8; // r5
  char v9; // r2
  char v10; // r3
  char *v11; // r0
  __int64 v12; // d16
  float v13; // r1
  CTaskComplex *v14; // r0
  float m_fSlowDownDistance; // s16
  __int64 v16; // kr00_8
  CPointRoute *m_pPointRoute; // r9
  int m_iProgress; // r5
  char v19; // r1
  float v20; // s0
  char v21; // r0
  float *v22; // r1
  float *v23; // r1
  __int64 v24; // d16

  v5 = 0;
  if ( iSubTaskType < 900 )
  {
    if ( iSubTaskType == 203 )
    {
      v5 = (char *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 0, 0, 0, 8.0);
      (*((void (__fastcall **)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))pPed->_vptr$CPlaceable + 15))(
        pPed,
        LODWORD(this->m_vTarget.x),
        LODWORD(this->m_vTarget.y),
        LODWORD(this->m_vTarget.z),
        0);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (char *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 926:
        v5 = (char *)CTask::operator new(0x24u);
        v13 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState);
        CTaskSimpleGoToPointFine::CTaskSimpleGoToPointFine(
          (CTaskSimpleGoToPointFine *)v5,
          v13,
          this->m_pPointRoute->m_routePoints[this->m_iProgress],
          0.5,
          0);
        break;
      case 903:
        v14 = (CTaskComplex *)CTask::operator new(0x28u);
        m_fSlowDownDistance = this->m_fSlowDownDistance;
        v5 = (char *)v14;
        v16 = *(_QWORD *)&this->m_iMoveState;
        m_pPointRoute = this->m_pPointRoute;
        m_iProgress = this->m_iProgress;
        CTaskComplex::CTaskComplex(v14);
        *((_DWORD *)v5 + 3) = v16;
        v19 = v5[36];
        v20 = *((float *)v5 + 4);
        *(_DWORD *)v5 = &off_66C13C;
        v21 = v19 & 0xE4;
        v5[36] = v19 & 0xE4;
        v22 = (float *)(&m_pPointRoute->m_iRouteSize + 3 * m_iProgress);
        if ( v20 != v22[1]
          || *((float *)v5 + 5) != v22[2]
          || *((float *)v5 + 6) != v22[3]
          || *((float *)v5 + 8) != m_fSlowDownDistance )
        {
          v23 = v22 + 1;
          v24 = *(_QWORD *)v23;
          *((float *)v5 + 6) = v23[2];
          *((_QWORD *)v5 + 2) = v24;
          *((float *)v5 + 8) = m_fSlowDownDistance;
          *((_DWORD *)v5 + 7) = HIDWORD(v16);
          v5[36] = v21 | 4;
        }
        break;
      case 900:
        v5 = (char *)CTask::operator new(0x2Cu);
        m_iMoveState = this->m_iMoveState;
        v7 = this->m_pPointRoute;
        v8 = this->m_iProgress;
        CTaskSimple::CTaskSimple((CTaskSimple *)v5);
        *((_DWORD *)v5 + 2) = m_iMoveState;
        *(_DWORD *)v5 = &off_66C0A0;
        v9 = v5[28];
        v10 = v5[29];
        v11 = (char *)v7 + 12 * v8;
        v12 = *(_QWORD *)(v11 + 4);
        *((_DWORD *)v5 + 5) = *((_DWORD *)v11 + 3);
        *(_DWORD *)v5 = &off_66C0D4;
        *((_DWORD *)v5 + 6) = 1056964608;
        v5[29] = v10 & 0xE0;
        v5[28] = v9 & 0xC0;
        *(_QWORD *)(v5 + 12) = v12;
        break;
    }
  }
  return (CTask *)v5;
}
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;
// 66C13C: using guessed type void *off_66C13C;

//----- (005201DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRoute::CreateFirstSubTask(CTaskComplexFollowNodeRoute *this, CPed *pPed)
{
  int m_iTime; // r0
  int v5; // r1
  char v6; // r0
  char v7; // r0
  int m_iProgress; // r1
  int v9; // r2
  int m_iRouteSize; // r3

  m_iTime = this->m_iTime;
  if ( m_iTime >= 0 )
  {
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v5;
    this->m_timer.m_iDuration = m_iTime;
  }
  v6 = *((_BYTE *)this + 76);
  if ( (v6 & 8) != 0 )
  {
    *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
    *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
  }
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v9 = 704;
  }
  else
  {
    if ( (v6 & 8) != 0 )
    {
      *((_BYTE *)this + 76) = v6 & 0x9F | 0x40;
      *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
      *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
    }
    CTaskComplexFollowNodeRoute::ComputePathNodes(this, pPed);
    CTaskComplexFollowNodeRoute::ComputeRoute(this);
    v7 = *((_BYTE *)this + 76);
    m_iProgress = this->m_iProgress;
    *((_BYTE *)this + 76) = v7 & 0xFB;
    if ( (v7 & 2) == 0 )
    {
      v9 = 900;
      if ( (v7 & 8) == 0 )
        return CTaskComplexFollowNodeRoute::CreateSubTask(this, v9, pPed);
      goto LABEL_18;
    }
    m_iRouteSize = this->m_pPointRoute->m_iRouteSize;
    if ( m_iRouteSize == m_iProgress )
    {
      v9 = 1302;
      if ( (v7 & 8) == 0 )
        return CTaskComplexFollowNodeRoute::CreateSubTask(this, v9, pPed);
      goto LABEL_18;
    }
    v9 = 900;
    if ( m_iProgress + 1 == m_iRouteSize )
      v9 = 903;
    if ( (v7 & 8) != 0 )
LABEL_18:
      v9 = CTaskComplexFollowNodeRoute::CalcGoToTaskType(this, pPed, v9);
  }
  return CTaskComplexFollowNodeRoute::CreateSubTask(this, v9, pPed);
}

//----- (005202A4) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRoute::CreateNextSubTask(CTaskComplexFollowNodeRoute *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  int (**v6)(void); // r0
  char v7; // r0
  int v8; // r1
  int v10; // r0
  int m_iProgress; // r1
  CNodeRoute *m_pNodeRoute; // r0
  int v13; // r2
  char v14; // r0
  int v15; // r2
  CTaskComplexFollowNodeRoute *v16; // r0
  int v17; // r1
  CNodeRoute *v18; // r2
  int m_iRouteSize; // r3

  if ( this->m_timer.m_bIsActive )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      v4 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v4;
      m_iStartTime = v4;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v4 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_timer.m_iDuration <= v4
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203 )
    {
      (*((void (__fastcall **)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))pPed->_vptr$CPlaceable + 15))(
        pPed,
        LODWORD(this->m_vTarget.x),
        LODWORD(this->m_vTarget.y),
        LODWORD(this->m_vTarget.z),
        0);
      return 0;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 704 )
  {
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      return 0;
    v6 = this->_vptr$CTask;
    return (CTask *)((int (__fastcall *)(CTaskComplexFollowNodeRoute *, CPed *))v6[11])(this, pPed);
  }
  v7 = *((_BYTE *)this + 76);
  if ( (v7 & 2) != 0 )
  {
    v10 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    if ( v10 != 926 )
    {
      if ( v10 == 903 )
      {
        m_iProgress = this->m_iProgress;
        v14 = *((_BYTE *)this + 76);
        v13 = m_iProgress + 1;
        this->m_iProgress = m_iProgress + 1;
        if ( (v14 & 2) == 0 )
          goto LABEL_23;
        goto LABEL_30;
      }
      if ( v10 != 900 )
        return 0;
    }
    m_iProgress = this->m_iProgress;
    m_pNodeRoute = this->m_pNodeRoute;
    v13 = m_iProgress + 1;
    this->m_iProgress = m_iProgress + 1;
    if ( m_iProgress + 1 < m_pNodeRoute->m_iRouteSize )
      this->m_CurrentNode = m_pNodeRoute->m_routePoints[v13];
    v14 = *((_BYTE *)this + 76);
    if ( (v14 & 2) == 0 )
    {
LABEL_23:
      v15 = 900;
      if ( (v14 & 8) == 0 )
      {
LABEL_25:
        v16 = this;
        v17 = v15;
        return CTaskComplexFollowNodeRoute::CreateSubTask(v16, v17, pPed);
      }
LABEL_24:
      v15 = CTaskComplexFollowNodeRoute::CalcGoToTaskType(this, pPed, v15);
      goto LABEL_25;
    }
LABEL_30:
    m_iRouteSize = this->m_pPointRoute->m_iRouteSize;
    if ( m_iRouteSize == v13 )
    {
      v15 = 1302;
      if ( (v14 & 8) == 0 )
        goto LABEL_25;
    }
    else
    {
      v15 = 900;
      if ( m_iProgress + 2 == m_iRouteSize )
        v15 = 903;
      if ( (v14 & 8) == 0 )
        goto LABEL_25;
    }
    goto LABEL_24;
  }
  v8 = this->m_iProgress + 1;
  if ( v8 == this->m_pPointRoute->m_iRouteSize )
  {
    if ( (*((_BYTE *)this + 76) & 8) != 0 )
    {
      *((_BYTE *)this + 76) = v7 & 0x9F | 0x40;
      *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
      *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
    }
    CTaskComplexFollowNodeRoute::ComputePathNodes(this, pPed);
    CTaskComplexFollowNodeRoute::ComputeRoute(this);
    v6 = this->_vptr$CTask;
    *((_BYTE *)this + 76) |= 4u;
    return (CTask *)((int (__fastcall *)(CTaskComplexFollowNodeRoute *, CPed *))v6[11])(this, pPed);
  }
  v18 = this->m_pNodeRoute;
  this->m_iProgress = v8;
  this->m_CurrentNode = v18->m_routePoints[v8];
  if ( (v7 & 8) != 0 )
    v17 = CTaskComplexFollowNodeRoute::CalcGoToTaskType(this, pPed, 900);
  else
    v17 = 900;
  v16 = this;
  return CTaskComplexFollowNodeRoute::CreateSubTask(v16, v17, pPed);
}

//----- (00520440) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRoute::ControlSubTask(CTaskComplexFollowNodeRoute *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  char v7; // r0
  float v8; // r1
  char *v9; // r6
  int m_iMoveState; // r0
  CTaskSimpleGoToPointFine *v11; // r5
  float v12; // r0
  int v13; // r5
  CPointRoute *m_pPointRoute; // r8
  int m_iProgress; // r4
  char v16; // r2
  char v17; // r3
  char *v18; // r0
  __int64 v19; // d16
  float v20; // r5
  CTask *m_pSubTask; // r0
  float v22; // r1
  CTaskSimpleGoToPointFine *v23; // r0

  if ( (*((_BYTE *)this + 76) & 4) != 0
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 704 )
  {
    return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowNodeRoute *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  }
  if ( this->m_timer.m_bIsActive )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      v4 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v4;
      m_iStartTime = v4;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v4 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_timer.m_iDuration <= v4
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
    {
      if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             1,
             0) == 1 )
      {
        v9 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v9, 0, 0, 0, 8.0);
        (*((void (__fastcall **)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))pPed->_vptr$CPlaceable + 15))(
          pPed,
          LODWORD(this->m_vTarget.x),
          LODWORD(this->m_vTarget.y),
          LODWORD(this->m_vTarget.z),
          0);
        return (CTask *)v9;
      }
      return this->m_pSubTask;
    }
  }
  v7 = *((_BYTE *)this + 76);
  if ( (v7 & 8) == 0 )
    return this->m_pSubTask;
  if ( (*((_BYTE *)this + 76) & 0x20) != 0 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 926 )
    {
      v8 = CTaskComplexFollowNodeRoute::CalcBlendRatio(this, pPed, 1);
      if ( v8 < 0.0 )
        v8 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState);
      goto LABEL_22;
    }
    v7 = *((_BYTE *)this + 76);
  }
  if ( (v7 & 0x40) == 0
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 926 )
  {
LABEL_23:
    if ( (*((_BYTE *)this + 76) & 0x30) == 16
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 903 )
    {
      v20 = CTaskComplexFollowNodeRoute::CalcBlendRatio(this, pPed, 1);
      if ( v20 >= 0.0 )
      {
        m_pSubTask = this->m_pSubTask;
        *((_BYTE *)this + 76) = *((_BYTE *)this + 76) & 0x8F | 0x20;
        if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 926 )
        {
          v9 = (char *)CTask::operator new(0x24u);
          v22 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState);
          CTaskSimpleGoToPointFine::CTaskSimpleGoToPointFine(
            (CTaskSimpleGoToPointFine *)v9,
            v22,
            this->m_pPointRoute->m_routePoints[this->m_iProgress],
            0.5,
            0);
          CTaskSimpleGoToPointFine::SetMoveRatio(v23, v20);
          return (CTask *)v9;
        }
        CTaskSimpleGoToPointFine::SetMoveRatio((CTaskSimpleGoToPointFine *)this->m_pSubTask, v20);
      }
    }
    return this->m_pSubTask;
  }
  v8 = CTaskComplexFollowNodeRoute::CalcBlendRatio(this, pPed, 0);
  if ( v8 >= 0.0 )
  {
LABEL_22:
    CTaskSimpleGoToPointFine::SetMoveRatio((CTaskSimpleGoToPointFine *)this->m_pSubTask, v8);
    goto LABEL_23;
  }
  m_iMoveState = this->m_iMoveState;
  v11 = (CTaskSimpleGoToPointFine *)this->m_pSubTask;
  *((_BYTE *)this + 76) &= ~0x40u;
  v12 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)m_iMoveState);
  CTaskSimpleGoToPointFine::SetMoveRatio(v11, v12);
  v9 = (char *)CTask::operator new(0x2Cu);
  v13 = this->m_iMoveState;
  m_pPointRoute = this->m_pPointRoute;
  m_iProgress = this->m_iProgress;
  CTaskSimple::CTaskSimple((CTaskSimple *)v9);
  *((_DWORD *)v9 + 2) = v13;
  *(_DWORD *)v9 = &off_66C0A0;
  v16 = v9[28];
  v17 = v9[29];
  v18 = (char *)m_pPointRoute + 12 * m_iProgress;
  v19 = *(_QWORD *)(v18 + 4);
  *((_DWORD *)v9 + 5) = *((_DWORD *)v18 + 3);
  *(_DWORD *)v9 = &off_66C0D4;
  *((_DWORD *)v9 + 6) = 1056964608;
  v9[29] = v17 & 0xE0;
  v9[28] = v16 & 0xC0;
  *(_QWORD *)(v9 + 12) = v19;
  return (CTask *)v9;
}
// 52068C: variable 'v23' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (005206A4) --------------------------------------------------------
float __fastcall CTaskComplexFollowNodeRoute::CalcBlendRatio(
        CTaskComplexFollowNodeRoute *this,
        CPed *ped,
        bool slowing)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  _BOOL4 v5; // r6
  int m_iProgress; // r2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r5
  float *v10; // r0
  float v11; // s4
  float v12; // s2
  float m_SpeedDecreaseDistance; // s0
  CPointRoute *m_pPointRoute; // r3
  CMatrix *v15; // r2
  CSimpleTransform *p_m_transform; // r0
  float *p_z; // r1
  float *p_y; // r2
  float *p_x; // r3
  int v20; // r1
  float v21; // s0
  float v22; // s2
  float v23; // s0
  float v24; // s0
  float *p_m_SpeedIncreaseAmt; // r0
  float v26; // s18
  float v27; // r4

  v5 = slowing;
  if ( slowing )
  {
    m_iProgress = this->m_iProgress;
    m_pMat = ped->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &ped->m_transform;
    v10 = (float *)(&this->m_pPointRoute->m_iRouteSize + 3 * m_iProgress);
    v11 = (float)(v10[3] - p_tx->m_translate.z) * (float)(v10[3] - p_tx->m_translate.z);
    v12 = (float)((float)(v10[1] - p_tx->m_translate.x) * (float)(v10[1] - p_tx->m_translate.x))
        + (float)((float)(v10[2] - p_tx->m_translate.y) * (float)(v10[2] - p_tx->m_translate.y));
    m_SpeedDecreaseDistance = this->m_SpeedDecreaseDistance;
  }
  else
  {
    m_pPointRoute = this->m_pPointRoute;
    v15 = ped->m_pMat;
    p_m_transform = (CSimpleTransform *)&v15->tx;
    if ( !v15 )
      p_m_transform = &ped->m_transform;
    if ( m_pPointRoute->m_iRouteSize == 1 )
    {
      p_z = &m_pPointRoute->m_routePoints[0].z;
      p_y = &m_pPointRoute->m_routePoints[0].y;
      p_x = &m_pPointRoute->m_routePoints[0].x;
    }
    else
    {
      v20 = this->m_iProgress;
      if ( v20 )
      {
        p_z = (float *)(&m_pPointRoute->m_iRouteSize + 3 * v20);
        p_y = p_z - 1;
        p_x = p_z - 2;
      }
      else
      {
        p_z = &p_m_transform->m_translate.z;
        p_y = &p_m_transform->m_translate.y;
        p_x = &p_m_transform->m_translate.x;
      }
    }
    v11 = (float)(p_m_transform->m_translate.z - *p_z) * (float)(p_m_transform->m_translate.z - *p_z);
    v12 = (float)((float)(p_m_transform->m_translate.x - *p_x) * (float)(p_m_transform->m_translate.x - *p_x))
        + (float)((float)(p_m_transform->m_translate.y - *p_y) * (float)(p_m_transform->m_translate.y - *p_y));
    m_SpeedDecreaseDistance = this->m_SpeedIncreaseDistance;
  }
  v21 = m_SpeedDecreaseDistance * m_SpeedDecreaseDistance;
  v22 = v12 + v11;
  if ( v22 >= v21 )
    return -1.0;
  v23 = v22 / v21;
  if ( v23 >= 0.0 )
  {
    if ( v23 > 1.0 )
      v23 = 1.0;
  }
  else
  {
    v23 = 0.0;
  }
  v4.n64_u32[0] = cosf(v23 * 3.1416);
  p_m_SpeedIncreaseAmt = &this->m_SpeedIncreaseAmt;
  if ( v5 )
    p_m_SpeedIncreaseAmt = &this->m_SpeedDecreaseAmt;
  v26 = *p_m_SpeedIncreaseAmt * (float)((float)(v4.n64_f32[0] * 0.5) + 0.5);
  v27 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState);
  v3.n64_f32[0] = CTaskSimpleGoToPointFine::BaseRatio(PEDMOVE_WALK) + 0.75;
  v4.n64_f32[0] = v27 - v26;
  LODWORD(v24) = vmax_f32(v3, v4).n64_u32[0];
  return v24;
}
// 520812: variable 'v3' is possibly undefined
// 520812: variable 'v4' is possibly undefined

//----- (0052082C) --------------------------------------------------------
bool __fastcall CTaskComplexFollowNodeRoute::CanGoStraightThere(
        const CTaskComplexFollowNodeRoute *this,
        const CPed *ped,
        const CVector *vStart,
        const CVector *vTarget,
        const float fFollowNodeThresholdDistance)
{
  int v5; // r12
  float32x2_t v6; // d16
  unsigned __int64 v7; // d1

  v5 = 0;
  v6.n64_u64[0] = vsub_f32(*(float32x2_t *)&vStart->y, *(float32x2_t *)&vTarget->y).n64_u64[0];
  v7 = vmul_f32(v6, v6).n64_u64[0];
  if ( sqrtf(
         (float)((float)((float)(vStart->x - vTarget->x) * (float)(vStart->x - vTarget->x)) + *(float *)&v7)
       + *((float *)&v7 + 1)) <= fFollowNodeThresholdDistance )
  {
    if ( *((unsigned __int8 *)&ped->m_nPedFlags + 13) >> 7 )
      return 1;
    return CPedGeometryAnalyser::IsWanderPathClear(vStart, vTarget, this->m_fFollowNodeThresholdHeightChange, 4) == 4;
  }
  return v5;
}

//----- (005208A0) --------------------------------------------------------
CTaskComplexWander *__fastcall CTaskComplexWander::GetWanderTaskByPedType(const CPed *ped)
{
  char *v1; // r4
  unsigned __int16 v2; // r5
  char v3; // r0
  char v4; // r0
  float v5; // s0
  unsigned __int16 v6; // r5
  float v7; // s0
  void **v8; // r0
  unsigned __int16 v9; // r5
  char v10; // r2
  unsigned __int16 v11; // r5
  char *v12; // r0
  unsigned __int16 v13; // r5

  switch ( __ROR4__(ped->m_nPedType - 6, 1) )
  {
    case 0:
      v1 = (char *)CTask::operator new(0x50u);
      v2 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      *((_QWORD *)v1 + 7) = 0LL;
      *((_QWORD *)v1 + 8) = 0LL;
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      *((_DWORD *)v1 + 8) = 0;
      *(_DWORD *)v1 = &off_66C5D8;
      v3 = v1[36];
      *(_DWORD *)(v1 + 50) = 0;
      *(_DWORD *)(v1 + 46) = 0;
      v4 = v3 & 0xF0;
      *((_DWORD *)v1 + 10) = 0;
      *((_DWORD *)v1 + 11) = 0;
      v5 = (float)((float)v2 * 0.000015259) * 8.0;
      *(_DWORD *)(v1 + 74) = 0;
      *(_DWORD *)(v1 + 70) = 0;
      goto LABEL_10;
    case 6:
      v1 = (char *)CTask::operator new(0x28u);
      v9 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      v10 = v1[36];
      *((_DWORD *)v1 + 8) = 0;
      *(_DWORD *)v1 = &off_66BB6C;
      v5 = (float)((float)v9 * 0.000015259) * 8.0;
      goto LABEL_9;
    case 7:
      v1 = (char *)CTask::operator new(0x38u);
      v11 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      v7 = (float)v11;
      v8 = &`vtable for'CTaskComplexWanderCriminal;
      goto LABEL_6;
    case 8:
      v1 = (char *)CTask::operator new(0x3Cu);
      v13 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      *((_DWORD *)v1 + 8) = 0;
      *((_WORD *)v1 + 24) = 0;
      v10 = v1[36];
      *(_DWORD *)v1 = &off_66C368;
      *((_DWORD *)v1 + 13) = 0;
      *((_DWORD *)v1 + 14) = 0;
      v5 = (float)((float)v13 * 0.000015259) * 8.0;
      goto LABEL_8;
    default:
      v1 = (char *)CTask::operator new(0x38u);
      v6 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      v7 = (float)v6;
      v8 = &`vtable for'CTaskComplexWanderStandard;
LABEL_6:
      v12 = (char *)*v8;
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      *((_DWORD *)v1 + 8) = 0;
      v10 = v1[36];
      v5 = (float)(v7 * 0.000015259) * 8.0;
      *(_DWORD *)v1 = v12 + 8;
      *((_WORD *)v1 + 24) = 0;
      *((_DWORD *)v1 + 13) = 0;
LABEL_8:
      *((_DWORD *)v1 + 10) = 0;
      *((_DWORD *)v1 + 11) = 0;
LABEL_9:
      v4 = v10 & 0xF0;
LABEL_10:
      v1[36] = v4 | 1;
      v1[16] = (int)v5;
      return (CTaskComplexWander *)v1;
  }
}
// 66BB6C: using guessed type void *;
// 66C368: using guessed type void *;
// 66C5D8: using guessed type void *off_66C5D8;
// 677A94: using guessed type void *`vtable for'CTaskComplexWanderStandard;
// 6783D4: using guessed type void *`vtable for'CTaskComplexWanderCriminal;

//----- (00520A94) --------------------------------------------------------
CTaskComplexWander *__fastcall CTaskComplexWander::GetWanderTaskByPedType(const int32 pedType)
{
  char *v1; // r4
  unsigned __int16 v2; // r5
  char v3; // r0
  char v4; // r0
  float v5; // s0
  unsigned __int16 v6; // r5
  float v7; // s0
  void **v8; // r0
  unsigned __int16 v9; // r5
  char v10; // r2
  unsigned __int16 v11; // r5
  char *v12; // r0
  unsigned __int16 v13; // r5

  switch ( __ROR4__(pedType - 6, 1) )
  {
    case 0:
      v1 = (char *)CTask::operator new(0x50u);
      v2 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      *((_QWORD *)v1 + 7) = 0LL;
      *((_QWORD *)v1 + 8) = 0LL;
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      *((_DWORD *)v1 + 8) = 0;
      *(_DWORD *)v1 = &off_66C5D8;
      v3 = v1[36];
      *(_DWORD *)(v1 + 50) = 0;
      *(_DWORD *)(v1 + 46) = 0;
      v4 = v3 & 0xF0;
      *((_DWORD *)v1 + 10) = 0;
      *((_DWORD *)v1 + 11) = 0;
      v5 = (float)((float)v2 * 0.000015259) * 8.0;
      *(_DWORD *)(v1 + 74) = 0;
      *(_DWORD *)(v1 + 70) = 0;
      goto LABEL_10;
    case 6:
      v1 = (char *)CTask::operator new(0x28u);
      v9 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      v10 = v1[36];
      *((_DWORD *)v1 + 8) = 0;
      *(_DWORD *)v1 = &off_66BB6C;
      v5 = (float)((float)v9 * 0.000015259) * 8.0;
      goto LABEL_9;
    case 7:
      v1 = (char *)CTask::operator new(0x38u);
      v11 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      v7 = (float)v11;
      v8 = &`vtable for'CTaskComplexWanderCriminal;
      goto LABEL_6;
    case 8:
      v1 = (char *)CTask::operator new(0x3Cu);
      v13 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      *((_DWORD *)v1 + 8) = 0;
      *((_WORD *)v1 + 24) = 0;
      v10 = v1[36];
      *(_DWORD *)v1 = &off_66C368;
      *((_DWORD *)v1 + 13) = 0;
      *((_DWORD *)v1 + 14) = 0;
      v5 = (float)((float)v13 * 0.000015259) * 8.0;
      goto LABEL_8;
    default:
      v1 = (char *)CTask::operator new(0x38u);
      v6 = rand();
      CTaskComplex::CTaskComplex((CTaskComplex *)v1);
      v7 = (float)v6;
      v8 = &`vtable for'CTaskComplexWanderStandard;
LABEL_6:
      v12 = (char *)*v8;
      *((_DWORD *)v1 + 3) = 4;
      *((_DWORD *)v1 + 5) = 1056964608;
      *((_WORD *)v1 + 12) = -1;
      *((_WORD *)v1 + 14) = -1;
      *((_DWORD *)v1 + 8) = 0;
      v10 = v1[36];
      v5 = (float)(v7 * 0.000015259) * 8.0;
      *(_DWORD *)v1 = v12 + 8;
      *((_WORD *)v1 + 24) = 0;
      *((_DWORD *)v1 + 13) = 0;
LABEL_8:
      *((_DWORD *)v1 + 10) = 0;
      *((_DWORD *)v1 + 11) = 0;
LABEL_9:
      v4 = v10 & 0xF0;
LABEL_10:
      v1[36] = v4 | 1;
      v1[16] = (int)v5;
      return (CTaskComplexWander *)v1;
  }
}
// 66BB6C: using guessed type void *off_66BB6C;
// 66C368: using guessed type void *off_66C368;
// 66C5D8: using guessed type void *off_66C5D8;
// 676B0C: using guessed type void *`vtable for'CTaskComplexWanderMedic;
// 677A94: using guessed type void *`vtable for'CTaskComplexWanderStandard;
// 6783D4: using guessed type void *`vtable for'CTaskComplexWanderCriminal;

//----- (00520C84) --------------------------------------------------------
void __fastcall CTaskComplexWander::CTaskComplexWander(
        CTaskComplexWander *this,
        const int iMoveState,
        const UINT8 iDir,
        const bool bWanderSensibly,
        float targetRadius)
{
  int v8; // r0
  char v9; // r2

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v8 + 12) = iMoveState;
  *(_BYTE *)(v8 + 16) = iDir;
  *(float *)(v8 + 20) = targetRadius;
  *(_WORD *)(v8 + 24) = -1;
  *(_WORD *)(v8 + 28) = -1;
  v9 = *(_BYTE *)(v8 + 36) & 0xF0;
  *(_DWORD *)(v8 + 32) = 0;
  *(_BYTE *)(v8 + 36) = v9 | bWanderSensibly;
  *(_DWORD *)v8 = &off_66C2A4;
}
// 520CA4: variable 'v8' is possibly undefined
// 66C2A4: using guessed type void *;

//----- (00520CD2) --------------------------------------------------------
void __fastcall CTaskComplexWander::SetDir(CTaskComplexWander *this, const int iDir)
{
  char v2; // r2

  if ( this->m_iDir != iDir )
  {
    v2 = *((_BYTE *)this + 36);
    this->m_iDir = iDir;
    *((_BYTE *)this + 36) = v2 | 2;
  }
}

//----- (00520CE8) --------------------------------------------------------
void __fastcall CTaskComplexWander::ContinueFrom(CTaskComplexWander *this, const CTaskComplexWander *taskWander)
{
  char v2; // r3

  if ( this->m_LastNode.Region != taskWander->m_LastNode.Region
    || this->m_LastNode.Index != taskWander->m_LastNode.Index
    || this->m_NextNode.Region != taskWander->m_NextNode.Region
    || this->m_NextNode.Index != taskWander->m_NextNode.Index )
  {
    this->m_LastNode = taskWander->m_LastNode;
    v2 = *((_BYTE *)this + 36);
    this->m_NextNode = taskWander->m_NextNode;
    this->m_iDir = taskWander->m_iDir;
    *((_BYTE *)this + 36) = v2 | 4;
  }
}

//----- (00520D24) --------------------------------------------------------
CTask *__fastcall CTaskComplexWander::CreateFirstSubTask(CTaskComplexWander *this, CPed *pPed)
{
  int v4; // r2

  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v4 = 704;
  }
  else
  {
    (*((void (__fastcall **)(CTaskComplexWander *, CPed *))this->_vptr$CTask + 15))(this, pPed);
    (*((void (__fastcall **)(CTaskComplexWander *, CPed *, _DWORD, CNodeAddress *, CNodeAddress *, UINT8 *))this->_vptr$CTask
     + 16))(
      this,
      pPed,
      this->m_iDir,
      &this->m_LastNode,
      &this->m_NextNode,
      &this->m_iDir);
    v4 = 900;
  }
  return CTaskComplexWander::CreateSubTask(this, pPed, v4);
}

//----- (00520D80) --------------------------------------------------------
CTask *__fastcall CTaskComplexWander::CreateSubTask(CTaskComplexWander *this, const CPed *pPed, const int iSubTaskType)
{
  CTaskSimpleCarDrive *v5; // r4
  void **v6; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float RadianAngleBetweenPoints; // r0
  float v10; // r0
  CMatrix *v11; // r0
  CSimpleTransform *p_m_transform; // r1
  float v13; // r0
  float v14; // r0
  RwReal y; // r8
  RwReal x; // r9
  float z; // s16
  CTaskSimple *v18; // r0
  int m_iMoveState; // r5
  float m_targetRadius; // r6
  uint8 m_bIsActive; // r1
  uint8 m_bIsStopped; // r2
  CVector v24; // [sp+10h] [bp-30h] BYREF

  v5 = 0;
  if ( iSubTaskType >= 704 )
  {
    switch ( iSubTaskType )
    {
      case 900:
        CPathFind::TakeWidthIntoAccountForWandering(&v24, &ThePaths, this->m_NextNode, pPed->RandomSeed);
        x = v24.x;
        y = v24.y;
        z = v24.z;
        v18 = (CTaskSimple *)CTask::operator new(0x2Cu);
        m_iMoveState = this->m_iMoveState;
        v5 = (CTaskSimpleCarDrive *)v18;
        m_targetRadius = this->m_targetRadius;
        CTaskSimple::CTaskSimple(v18);
        m_bIsActive = v5->m_passengerTimer.m_bIsActive;
        m_bIsStopped = v5->m_passengerTimer.m_bIsStopped;
        v5->m_pTargetVehicle = (CVehicle *)m_iMoveState;
        *(RwReal *)&v5->m_pAnimCloseDoor = x;
        *(RwReal *)&v5->m_pUtility = y;
        *(float *)&v5->m_passengerTimer.m_iDuration = m_targetRadius;
        v5->_vptr$CTask = (int (**)(void))&off_66C0D4;
        *(float *)&v5->m_passengerTimer.m_iStartTime = z + 1.0;
        v5->m_passengerTimer.m_bIsActive = m_bIsActive & 0xC0;
        v5->m_passengerTimer.m_bIsStopped = m_bIsStopped & 0xE0;
        break;
      case 719:
        v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
        CTaskSimpleCarDrive::CTaskSimpleCarDrive(v5, pPed->m_pMyVehicle, 0, 0);
        v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
        v6 = &`vtable for'CTaskSimpleCarDriveTimed;
        LOWORD(v5[1].m_pAnimCloseDoor) = 0;
        v5[1].m_pParent = 0;
        v5[1].m_pTargetVehicle = 0;
        goto LABEL_18;
      case 704:
        v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
        break;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 225:
        v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x14u);
        CPathFind::TakeWidthIntoAccountForWandering(&v24, &ThePaths, this->m_NextNode, pPed->RandomSeed);
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                     v24.x - p_tx->m_translate.x,
                                     v24.y - p_tx->m_translate.y,
                                     0.0,
                                     0.0);
        v10 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
        CTaskComplexObserveTrafficLightsAndAchieveHeading::CTaskComplexObserveTrafficLightsAndAchieveHeading(
          (CTaskComplexObserveTrafficLightsAndAchieveHeading *)v5,
          2000,
          v10);
        break;
      case 227:
        v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x14u);
        CPathFind::TakeWidthIntoAccountForWandering(&v24, &ThePaths, this->m_NextNode, pPed->RandomSeed);
        v11 = pPed->m_pMat;
        p_m_transform = (CSimpleTransform *)&v11->tx;
        if ( !v11 )
          p_m_transform = &pPed->m_transform;
        v13 = CGeneral::GetRadianAngleBetweenPoints(
                v24.x - p_m_transform->m_translate.x,
                v24.y - p_m_transform->m_translate.y,
                0.0,
                0.0);
        v14 = CGeneral::LimitRadianAngle(v13);
        CTaskComplexCrossRoadLookAndAchieveHeading::CTaskComplexCrossRoadLookAndAchieveHeading(
          (CTaskComplexCrossRoadLookAndAchieveHeading *)v5,
          2000,
          v14);
        break;
      case 421:
        v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(
          (CTaskSimpleRunAnim *)v5,
          ANIM_STD_PED,
          ANIM_STD_XPRESS_SCRATCH,
          4.0,
          421,
          "ScratchHead",
          0);
        v6 = &`vtable for'CTaskSimpleScratchHead;
LABEL_18:
        v5->_vptr$CTask = (int (**)(void))((char *)*v6 + 8);
        break;
    }
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66C0D4: using guessed type void *off_66C0D4;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;

//----- (00520F7C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWander::CreateNextSubTask(CTaskComplexWander *this, CPed *pPed)
{
  int v4; // r0
  CTaskSimpleCarDrive *v5; // r6
  void **v6; // r0
  CNodeAddress *p_m_NextNode; // r11
  CNodeAddress m_LastNode; // r5
  CNodeAddress *p_m_LastNode; // r9
  int v10; // r0
  bool v11; // zf
  int v12; // r1
  int v13; // r2
  int (**v15)(void); // r0
  UINT8 v16; // r2
  int v17; // r1
  int Region; // r0
  bool v19; // zf
  RwReal y; // r8
  RwReal x; // r9
  float z; // s16
  CTaskSimple *v23; // r0
  int m_iMoveState; // r5
  float m_targetRadius; // r4
  uint8 m_bIsActive; // r1
  uint8 m_bIsStopped; // r2
  CTaskSimpleStandStill *v28; // r8
  CTaskSimpleRunAnim *v29; // r8
  CTaskSimpleRunAnim *v30; // r8
  RwReal v31; // r8
  RwReal v32; // r9
  float v33; // s16
  CTaskSimple *v34; // r0
  int v35; // r10
  CTaskSimple *v36; // r5
  float v37; // r4
  char m_pParent; // r1
  char v39; // r2
  int v40; // r0
  CVector v41; // [sp+10h] [bp-38h] BYREF

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 <= 420 )
  {
    if ( v4 == 225 || v4 == 227 )
      goto LABEL_29;
    if ( v4 != 244 )
      return v5;
    goto LABEL_13;
  }
  if ( v4 <= 718 )
  {
    if ( v4 != 421 )
    {
      if ( v4 == 704 )
      {
        if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
        {
          v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
          CTaskSimpleCarDrive::CTaskSimpleCarDrive(v5, pPed->m_pMyVehicle, 0, 0);
          v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
          v6 = &`vtable for'CTaskSimpleCarDriveTimed;
          LOWORD(v5[1].m_pAnimCloseDoor) = 0;
          v5[1].m_pParent = 0;
          v5[1].m_pTargetVehicle = 0;
LABEL_31:
          v5->_vptr$CTask = (int (**)(void))((char *)*v6 + 8);
          return v5;
        }
        return (CTask *)(*((int (__fastcall **)(CTaskComplexWander *, CPed *))this->_vptr$CTask + 11))(this, pPed);
      }
      return v5;
    }
    v15 = this->_vptr$CTask;
    v16 = this->m_iDir + 1;
    this->m_iDir = v16;
    ((void (__fastcall *)(CTaskComplexWander *, CPed *, _DWORD, CNodeAddress *, CNodeAddress *, UINT8 *))v15[16])(
      this,
      pPed,
      v16,
      &this->m_LastNode,
      &this->m_NextNode,
      &this->m_iDir);
    Region = this->m_NextNode.Region;
    v19 = Region == 0xFFFF;
    if ( Region != 0xFFFF )
    {
      v17 = this->m_LastNode.Region;
      v19 = v17 == 0xFFFF;
    }
    if ( v19 || Region == v17 && this->m_NextNode.Index == this->m_LastNode.Index )
    {
      v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v5,
        ANIM_STD_PED,
        ANIM_STD_XPRESS_SCRATCH,
        4.0,
        421,
        "ScratchHead",
        0);
      v6 = &`vtable for'CTaskSimpleScratchHead;
      goto LABEL_31;
    }
LABEL_29:
    CPathFind::TakeWidthIntoAccountForWandering(&v41, &ThePaths, this->m_NextNode, pPed->RandomSeed);
    x = v41.x;
    y = v41.y;
    z = v41.z;
    v23 = (CTaskSimple *)CTask::operator new(0x2Cu);
    m_iMoveState = this->m_iMoveState;
    v5 = (CTaskSimpleCarDrive *)v23;
    m_targetRadius = this->m_targetRadius;
    CTaskSimple::CTaskSimple(v23);
    m_bIsActive = v5->m_passengerTimer.m_bIsActive;
    m_bIsStopped = v5->m_passengerTimer.m_bIsStopped;
    v5->m_pTargetVehicle = (CVehicle *)m_iMoveState;
    *(RwReal *)&v5->m_pAnimCloseDoor = x;
    *(RwReal *)&v5->m_pUtility = y;
    *(float *)&v5->m_passengerTimer.m_iDuration = m_targetRadius;
    v5->_vptr$CTask = (int (**)(void))&off_66C0D4;
    *(float *)&v5->m_passengerTimer.m_iStartTime = z + 1.0;
    v5->m_passengerTimer.m_bIsActive = m_bIsActive & 0xC0;
    v5->m_passengerTimer.m_bIsStopped = m_bIsStopped & 0xE0;
    return v5;
  }
  if ( v4 == 719 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexWander *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  if ( v4 == 900 )
  {
LABEL_13:
    if ( (*((_BYTE *)this + 36) & 8) != 0 )
    {
      *((_BYTE *)this + 36) &= ~8u;
      v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v5,
        ANIM_STD_PED,
        ANIM_STD_XPRESS_SCRATCH,
        4.0,
        421,
        "ScratchHead",
        0);
      v6 = &`vtable for'CTaskSimpleScratchHead;
      goto LABEL_31;
    }
    (*((void (__fastcall **)(CTaskComplexWander *, CPed *))this->_vptr$CTask + 15))(this, pPed);
    p_m_NextNode = &this->m_NextNode;
    p_m_LastNode = &this->m_LastNode;
    m_LastNode = this->m_LastNode;
    (*((void (__fastcall **)(CTaskComplexWander *, CPed *, _DWORD, CNodeAddress *, CNodeAddress *, UINT8 *))this->_vptr$CTask
     + 16))(
      this,
      pPed,
      this->m_iDir,
      &this->m_LastNode,
      &this->m_NextNode,
      &this->m_iDir);
    v10 = this->m_NextNode.Region;
    v11 = v10 == m_LastNode.Region;
    if ( v10 == m_LastNode.Region )
      v11 = this->m_NextNode.Index == HIWORD(*(unsigned int *)&m_LastNode);
    if ( v11 )
    {
      v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      v28 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v28, 500, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v28);
      v29 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v29,
        (const AssocGroupId)pPed->m_motionAnimGroup,
        ANIM_STD_ROADCROSS,
        4.0,
        0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v29);
      v30 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v30, ANIM_STD_PED, ANIM_STD_XPRESS_SCRATCH, 4.0, 421, "ScratchHead", 0);
      v30->_vptr$CTask = (int (**)(void))&off_665860;
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v30);
      CPathFind::TakeWidthIntoAccountForWandering(&v41, &ThePaths, this->m_NextNode, pPed->RandomSeed);
      v31 = v41.x;
      v32 = v41.y;
      v33 = v41.z;
      v34 = (CTaskSimple *)CTask::operator new(0x2Cu);
      v35 = this->m_iMoveState;
      v36 = v34;
      v37 = this->m_targetRadius;
      CTaskSimple::CTaskSimple(v34);
      m_pParent = (char)v36[3].m_pParent;
      v39 = BYTE1(v36[3].m_pParent);
      v36[1]._vptr$CTask = (int (**)(void))v35;
      *(RwReal *)&v36[1].m_pParent = v31;
      *(RwReal *)&v36[2]._vptr$CTask = v32;
      *(float *)&v36[3]._vptr$CTask = v37;
      v36->_vptr$CTask = (int (**)(void))&off_66C0D4;
      *(float *)&v36[2].m_pParent = v33 + 1.0;
      LOBYTE(v36[3].m_pParent) = m_pParent & 0xC0;
      BYTE1(v36[3].m_pParent) = v39 & 0xE0;
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v36);
      return v5;
    }
    if ( v10 == 0xFFFF
      || (v12 = this->m_LastNode.Region, v12 == 0xFFFF)
      || v10 == v12 && this->m_NextNode.Index == this->m_LastNode.Index )
    {
      v13 = 421;
      return CTaskComplexWander::CreateSubTask(this, pPed, v13);
    }
    v40 = *((unsigned __int8 *)this + 36);
    if ( (v40 & 1) != 0 )
    {
      if ( CPathFind::TestForPedTrafficLight(&ThePaths, *p_m_LastNode, *p_m_NextNode) )
      {
        v13 = 225;
        return CTaskComplexWander::CreateSubTask(this, pPed, v13);
      }
      v40 = *((unsigned __int8 *)this + 36);
    }
    if ( v40 << 31 && CPathFind::TestCrossesRoad(&ThePaths, *p_m_LastNode, *p_m_NextNode) )
      v13 = 227;
    else
      v13 = 900;
    return CTaskComplexWander::CreateSubTask(this, pPed, v13);
  }
  return v5;
}
// 5211E2: variable 'v17' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 665860: using guessed type void *off_665860;
// 66C0D4: using guessed type void *off_66C0D4;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;

//----- (005213A4) --------------------------------------------------------
void __fastcall CTaskComplexWander::ComputeTargetPos(
        const CTaskComplexWander *this,
        const CPed *pPed,
        CVector *vTargetPos,
        const CNodeAddress *nextNode)
{
  __int64 v5; // d16
  CVector v6; // [sp+0h] [bp-18h] BYREF

  CPathFind::TakeWidthIntoAccountForWandering(&v6, &ThePaths, *nextNode, pPed->RandomSeed);
  v5 = *(_QWORD *)&v6.x;
  vTargetPos->z = v6.z;
  *(_QWORD *)&vTargetPos->x = v5;
  vTargetPos->z = vTargetPos->z + 1.0;
}

//----- (005213E4) --------------------------------------------------------
bool __fastcall CTaskComplexWander::ValidNodes(const CTaskComplexWander *this)
{
  int v1; // r3
  int Region; // r1
  bool v3; // zf

  Region = this->m_NextNode.Region;
  v3 = Region == 0xFFFF;
  if ( Region != 0xFFFF )
  {
    v1 = this->m_LastNode.Region;
    v3 = v1 == 0xFFFF;
  }
  if ( v3 )
    return 0;
  if ( Region == v1 )
    return this->m_NextNode.Index != this->m_LastNode.Index;
  return 1;
}
// 5213FA: variable 'v1' is possibly undefined

//----- (00521410) --------------------------------------------------------
float __fastcall CTaskComplexWander::ComputeTargetHeading(const CTaskComplexWander *this, const CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float RadianAngleBetweenPoints; // r0
  CVector v7; // [sp+4h] [bp-14h] BYREF

  CPathFind::TakeWidthIntoAccountForWandering(&v7, &ThePaths, this->m_NextNode, pPed->RandomSeed);
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               v7.x - p_tx->m_translate.x,
                               v7.y - p_tx->m_translate.y,
                               0.0,
                               0.0);
  return CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
}

//----- (00521468) --------------------------------------------------------
CTask *__fastcall CTaskComplexWander::ControlSubTask(CTaskComplexWander *this, CPed *pPed)
{
  CTaskSimpleRunAnim *m_pSubTask; // r6
  char v6; // r1
  int v7; // r0
  int (**v8)(void); // r2
  CTask *v9; // r0
  RwReal x; // s0
  RwReal y; // s2
  float v12; // s4
  char m_pParent; // r1
  CVector v14; // [sp+Ch] [bp-1Ch] BYREF

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 704
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 719 )
  {
    return this->m_pSubTask;
  }
  v6 = *((_BYTE *)this + 36);
  m_pSubTask = (CTaskSimpleRunAnim *)this->m_pSubTask;
  if ( (v6 & 2) == 0
    || (v7 = (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(this->m_pSubTask),
        v6 = *((_BYTE *)this + 36),
        v7 != 900) )
  {
    if ( (v6 & 4) != 0
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 900 )
    {
      *((_BYTE *)this + 36) &= ~4u;
      CPathFind::TakeWidthIntoAccountForWandering(&v14, &ThePaths, this->m_NextNode, pPed->RandomSeed);
      v9 = this->m_pSubTask;
      x = v14.x;
      y = v14.y;
      v12 = v14.z + 1.0;
      if ( *(float *)&v9[1].m_pParent == v14.x
        && *(float *)&v9[2]._vptr$CTask == v14.y
        && *(float *)&v9[3]._vptr$CTask == 0.5 )
      {
        m_pSubTask = (CTaskSimpleRunAnim *)this->m_pSubTask;
      }
      else
      {
        m_pParent = (char)v9[3].m_pParent;
        v9[3]._vptr$CTask = (int (**)(void))1056964608;
        *(RwReal *)&v9[1].m_pParent = x;
        *(RwReal *)&v9[2]._vptr$CTask = y;
        *(float *)&v9[2].m_pParent = v12;
        LOBYTE(v9[3].m_pParent) = m_pParent & 0xD0 | 0x20;
        v9 = this->m_pSubTask;
        m_pSubTask = (CTaskSimpleRunAnim *)v9;
      }
    }
    else
    {
      CTaskComplexWander::ScanForBlockedNodes(this, pPed);
      (*((void (__fastcall **)(CTaskComplexWander *, CPed *))this->_vptr$CTask + 14))(this, pPed);
      v9 = this->m_pSubTask;
    }
    if ( (*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 5))(v9) == 900 )
    {
      this->m_pSubTask[1]._vptr$CTask = (int (**)(void))this->m_iMoveState;
      if ( this->m_iMoveState <= 4 )
        CPed::Say(pPed, 0x2Du, 0, 0.1, 0, 0, 0);
    }
    if ( pPed->m_pPedIntelligence->m_iStaticCounter > 30
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      m_pSubTask = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        m_pSubTask,
        ANIM_STD_PED,
        ANIM_STD_XPRESS_SCRATCH,
        4.0,
        421,
        "ScratchHead",
        0);
      m_pSubTask->_vptr$CTask = (int (**)(void))&off_665860;
    }
    return m_pSubTask;
  }
  this->m_NextNode.Region = -1;
  v8 = this->_vptr$CTask;
  *((_BYTE *)this + 36) = v6 & 0xFD;
  this->m_LastNode.Region = -1;
  return (CTask *)((int (__fastcall *)(CTaskComplexWander *, CPed *))v8[11])(this, pPed);
}
// 665860: using guessed type void *;

//----- (00521640) --------------------------------------------------------
void __fastcall CTaskComplexWander::ScanForBlockedNodes(CTaskComplexWander *this, CPed *pPed)
{
  CNodeAddress v4[6]; // [sp+10h] [bp-18h] BYREF

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 900
    && this->m_NextNode.Region != 0xFFFF
    && CTaskComplexWander::ScanForBlockedNode(this, pPed, &this->m_NextNode) )
  {
    (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
      this->m_pSubTask,
      pPed,
      0,
      0);
    v4[1] = this->m_LastNode;
    v4[0] = this->m_NextNode;
    (*((void (__fastcall **)(CTaskComplexWander *, CPed *))this->_vptr$CTask + 16))(this, pPed);
    if ( CTaskComplexWander::ScanForBlockedNode(this, pPed, v4)
      || __PAIR64__(v4[0].Index, v4[0].Region) == __PAIR64__(this->m_LastNode.Index, this->m_LastNode.Region) )
    {
      *((_BYTE *)this + 36) |= 8u;
    }
  }
}

//----- (005216E0) --------------------------------------------------------
bool __fastcall CTaskComplexWander::ScanForBlockedNode(
        const CTaskComplexWander *this,
        CPed *pPed,
        const CNodeAddress *nextNode)
{
  CMatrix *m_pMat; // r0
  float x; // s16
  CSimpleTransform *p_tx; // r1
  float y; // s18
  CPed *ClosestPedInRange; // r0
  CMatrix *v9; // r1
  float *p_x; // r2
  float v11; // s4
  CVehicle *ClosestVehicleInRange; // r0
  CMatrix *v13; // r1
  float *v14; // r2
  float v15; // s4
  CVector v17; // [sp+4h] [bp-2Ch] BYREF

  CPathFind::TakeWidthIntoAccountForWandering(&v17, &ThePaths, *nextNode, pPed->RandomSeed);
  m_pMat = pPed->m_pMat;
  x = v17.x;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  y = v17.y;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  if ( (float)((float)((float)((float)(v17.x - p_tx->m_translate.x) * (float)(v17.x - p_tx->m_translate.x))
                     + (float)((float)(v17.y - p_tx->m_translate.y) * (float)(v17.y - p_tx->m_translate.y)))
             + 0.0) > 9.0 )
    return 0;
  ClosestPedInRange = CPedScanner::GetClosestPedInRange(&pPed->m_pPedIntelligence->m_pedScanner);
  if ( ClosestPedInRange )
  {
    v9 = ClosestPedInRange->m_pMat;
    p_x = &v9->tx;
    if ( !v9 )
      p_x = &ClosestPedInRange->m_transform.m_translate.x;
    v11 = CModelInfo::ms_modelInfoPtrs[ClosestPedInRange->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius + 1.0;
    if ( (float)((float)((float)((float)(x - *p_x) * (float)(x - *p_x))
                       + (float)((float)(y - p_x[1]) * (float)(y - p_x[1])))
               + 0.0) < (float)(v11 * v11) )
      return 1;
  }
  ClosestVehicleInRange = CVehicleScanner::GetClosestVehicleInRange(&pPed->m_pPedIntelligence->m_vehicleScanner);
  if ( !ClosestVehicleInRange )
    return 0;
  v13 = ClosestVehicleInRange->m_pMat;
  v14 = &v13->tx;
  if ( !v13 )
    v14 = &ClosestVehicleInRange->m_transform.m_translate.x;
  v15 = CModelInfo::ms_modelInfoPtrs[ClosestVehicleInRange->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius + 1.0;
  return (float)((float)((float)((float)(x - *v14) * (float)(x - *v14))
                       + (float)((float)(y - v14[1]) * (float)(y - v14[1])))
               + 0.0) < (float)(v15 * v15);
}

//----- (00521828) --------------------------------------------------------
bool __fastcall CTaskComplexWander::ScanForBlockedNode(
        const CTaskComplexWander *this,
        const CVector *vTarget,
        const CEntity *pBlockEntity)
{
  bool result; // r0
  CMatrix *m_pMat; // r3
  float32x2_t v5; // d16
  CSimpleTransform *p_tx; // r1
  float32x2_t v7; // d16
  CColModel *m_pColModel; // r1
  unsigned __int64 v9; // d1

  result = 0;
  if ( pBlockEntity )
  {
    m_pMat = pBlockEntity->m_pMat;
    v5.n64_u64[0] = *(unsigned __int64 *)&vTarget->x;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pBlockEntity->m_transform;
    v7.n64_u64[0] = vsub_f32(v5, *(float32x2_t *)&p_tx->m_translate.x).n64_u64[0];
    m_pColModel = CModelInfo::ms_modelInfoPtrs[pBlockEntity->m_nModelIndex]->m_pColModel;
    v9 = vmul_f32(v7, v7).n64_u64[0];
    if ( (float)((float)(*(float *)&v9 + *((float *)&v9 + 1)) + 0.0) < (float)((float)(m_pColModel->m_sphereBound.m_fRadius
                                                                                     + 1.0)
                                                                             * (float)(m_pColModel->m_sphereBound.m_fRadius
                                                                                     + 1.0)) )
      return 1;
  }
  return result;
}

//----- (0052189C) --------------------------------------------------------
void __fastcall CTaskComplexWander::UpdateDir(CTaskComplexWander *this, const CPed *pPed)
{
  CNodeAddress m_NextNode; // r0
  CPathNode *v4; // r2
  int m_lastUpdateDirFrameCount; // r3
  UInt32 v6; // r2
  bool v7; // zf
  int m_iDir; // r0
  unsigned int v9; // r2
  int v10; // r2
  int v11; // r5
  unsigned int v12; // r0
  unsigned int v13; // r2
  CNodeAddress v14; // [sp+Ch] [bp-14h] BYREF
  CNodeAddress m_LastNode; // [sp+10h] [bp-10h] BYREF
  char v16[9]; // [sp+17h] [bp-9h] BYREF

  if ( this->m_NextNode.Region != 0xFFFF )
  {
    m_NextNode = this->m_NextNode;
    v4 = ThePaths.pNodes[m_NextNode.Region];
    if ( v4 )
    {
      if ( (*((_WORD *)&v4[HIWORD(*(unsigned int *)&m_NextNode)] + 12) & 0xFu) >= 3 )
      {
        m_lastUpdateDirFrameCount = this->m_lastUpdateDirFrameCount;
        v6 = CTimer::m_FrameCounter;
        v7 = CTimer::m_FrameCounter == m_lastUpdateDirFrameCount;
        if ( CTimer::m_FrameCounter != m_lastUpdateDirFrameCount )
          v7 = *((unsigned __int8 *)this + 36) << 31 == 0;
        if ( !v7 )
        {
          m_iDir = this->m_iDir;
          this->m_lastUpdateDirFrameCount = CTimer::m_FrameCounter;
          v9 = (3 * v6 + pPed->RandomSeed) % 0x64;
          if ( v9 <= 0x5A )
          {
            if ( v9 < 0x51 )
              return;
            v10 = 2;
          }
          else
          {
            v10 = 6;
          }
          v11 = (v10 + m_iDir) & 7;
          if ( v11 != m_iDir )
          {
            m_LastNode = this->m_LastNode;
            v14 = this->m_NextNode;
            (*((void (__fastcall **)(CTaskComplexWander *, const CPed *, _DWORD, CNodeAddress *, CNodeAddress *, char *))this->_vptr$CTask
             + 16))(
              this,
              pPed,
              (unsigned __int8)v11,
              &m_LastNode,
              &v14,
              v16);
            v12 = this->m_iDir;
            v13 = v12;
            if ( (unsigned __int8)v16[0] > v12 )
              v13 = (unsigned __int8)v16[0];
            if ( v12 >= (unsigned __int8)v16[0] )
              v12 = (unsigned __int8)v16[0];
            if ( (((int)(8 - v12 + v13) % 8) & 0xFCu) <= 3 )
              this->m_iDir = v11;
          }
        }
      }
    }
  }
}
// 52189C: using guessed type CNodeAddress var_10;
// 52189C: using guessed type char var_9[9];

//----- (00521988) --------------------------------------------------------
void __fastcall CTaskComplexWander::UpdatePathNodes(
        CTaskComplexWander *this,
        const CPed *pPed,
        const uint8 iDir,
        CNodeAddress *lastNode,
        CNodeAddress *nextNode,
        uint8 *iNewDir)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r6

  *lastNode = *nextNode;
  nextNode->Region = -1;
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  CPathFind::FindNextNodeWandering(&ThePaths, 1u, p_tx->m_translate, lastNode, nextNode, iDir, iNewDir);
}

//----- (005219D8) --------------------------------------------------------
void __fastcall CTaskComplexWanderGang::CTaskComplexWanderGang(
        CTaskComplexWanderGang *this,
        const int iMoveState,
        const UINT8 iDir,
        int32 minWanderTime,
        const bool bWanderSensibly,
        float targetRadius)
{
  int v9; // r0
  char v10; // r5
  uint32 v11; // r1

  CTaskComplex::CTaskComplex(this);
  *(_BYTE *)(v9 + 16) = iDir;
  *(_DWORD *)(v9 + 12) = iMoveState;
  *(float *)(v9 + 20) = targetRadius;
  *(_WORD *)(v9 + 24) = -1;
  *(_WORD *)(v9 + 28) = -1;
  *(_DWORD *)(v9 + 32) = 0;
  *(_WORD *)(v9 + 48) = 0;
  v10 = *(_BYTE *)(v9 + 36);
  *(_DWORD *)(v9 + 52) = minWanderTime;
  *(_DWORD *)(v9 + 40) = 0;
  *(_DWORD *)(v9 + 44) = 0;
  *(_BYTE *)(v9 + 36) = bWanderSensibly | v10 & 0xF0;
  *(_DWORD *)v9 = &off_66C724;
  v11 = CTimer::m_snTimeInMilliseconds;
  *(_BYTE *)(v9 + 48) = 1;
  *(_DWORD *)(v9 + 40) = v11;
  *(_DWORD *)(v9 + 44) = minWanderTime;
}
// 5219F2: variable 'v9' is possibly undefined
// 66C724: using guessed type void *;

//----- (00521A44) --------------------------------------------------------
bool8 __fastcall CTaskComplexWanderGang::CanJoinGang(CTaskComplexWanderGang *this)
{
  unsigned int v2; // r1
  int m_iStartTime; // r2

  if ( !this->m_timer.m_bIsActive )
    return 0;
  if ( this->m_timer.m_bIsStopped )
  {
    v2 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v2;
    m_iStartTime = v2;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v2 = CTimer::m_snTimeInMilliseconds;
  }
  return m_iStartTime + this->m_timer.m_iDuration <= v2;
}

//----- (00521A8C) --------------------------------------------------------
float __fastcall CTaskComplexWanderGang::GetDistanceSqToNode(CTaskComplexWanderGang *this, CPed *pPed)
{
  float32x2_t v2; // d0
  int Region; // r3
  float32x2_t v4; // d1
  CPathNode *v5; // r2
  int CoorsY; // r4
  float CoorsX; // s6
  CMatrix *m_pMat; // r3
  float CoorsZ; // s8
  CSimpleTransform *p_tx; // r2
  int v11; // r3
  CPathNode *v12; // r0
  int v13; // r3
  float v14; // s6
  CMatrix *v15; // r2
  float v16; // s8
  CSimpleTransform *p_m_transform; // r0
  float result; // r0

  v2.n64_u32[0] = 1232348144;
  Region = this->m_NextNode.Region;
  v4.n64_u64[0] = v2.n64_u64[0];
  if ( Region != 0xFFFF )
  {
    v4.n64_u64[0] = v2.n64_u64[0];
    if ( ThePaths.pNodes[this->m_NextNode.Region] )
    {
      v5 = &ThePaths.pNodes[Region][this->m_NextNode.Index];
      CoorsY = v5->CoorsY;
      CoorsX = (float)v5->CoorsX;
      m_pMat = pPed->m_pMat;
      CoorsZ = (float)v5->CoorsZ;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v4.n64_f32[0] = (float)((float)((float)((float)(CoorsX * 0.125) - p_tx->m_translate.x)
                                    * (float)((float)(CoorsX * 0.125) - p_tx->m_translate.x))
                            + (float)((float)((float)((float)CoorsY * 0.125) - p_tx->m_translate.y)
                                    * (float)((float)((float)CoorsY * 0.125) - p_tx->m_translate.y)))
                    + (float)((float)((float)(CoorsZ * 0.125) - p_tx->m_translate.z)
                            * (float)((float)(CoorsZ * 0.125) - p_tx->m_translate.z));
    }
  }
  v11 = this->m_LastNode.Region;
  if ( v11 != 0xFFFF && ThePaths.pNodes[this->m_LastNode.Region] )
  {
    v12 = &ThePaths.pNodes[v11][this->m_LastNode.Index];
    v13 = v12->CoorsY;
    v14 = (float)v12->CoorsX;
    v15 = pPed->m_pMat;
    v16 = (float)v12->CoorsZ;
    p_m_transform = (CSimpleTransform *)&v15->tx;
    if ( !v15 )
      p_m_transform = &pPed->m_transform;
    v2.n64_f32[0] = (float)((float)((float)((float)(v14 * 0.125) - p_m_transform->m_translate.x)
                                  * (float)((float)(v14 * 0.125) - p_m_transform->m_translate.x))
                          + (float)((float)((float)((float)v13 * 0.125) - p_m_transform->m_translate.y)
                                  * (float)((float)((float)v13 * 0.125) - p_m_transform->m_translate.y)))
                  + (float)((float)((float)(v16 * 0.125) - p_m_transform->m_translate.z)
                          * (float)((float)(v16 * 0.125) - p_m_transform->m_translate.z));
  }
  LODWORD(result) = vmin_f32(v2, v4).n64_u32[0];
  return result;
}
// 521A9A: variable 'v2' is possibly undefined

//----- (00521C00) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::CTaskComplexAvoidOtherPedWhileWandering(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pOtherPed,
        const CVector *vTarget,
        const int iMoveState)
{
  __int64 v8; // d16
  __int64 v9; // d16
  int v10; // r0

  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66C2F0;
  this->m_pOtherPed = pOtherPed;
  v8 = *(_QWORD *)&vTarget->x;
  this->m_vTarget.z = vTarget->z;
  *(_QWORD *)&this->m_vTarget.x = v8;
  v9 = *(_QWORD *)&vTarget->x;
  this->m_vDetourTarget.z = vTarget->z;
  this->m_Timer.m_iDuration = 0;
  *(_WORD *)&this->m_Timer.m_bIsActive = 0;
  *(_WORD *)&this->m_DontQuitYetTimer.m_bIsActive = 0;
  this->m_Timer.m_iStartTime = 0;
  this->m_DontQuitYetTimer.m_iStartTime = 0;
  this->m_DontQuitYetTimer.m_iDuration = 0;
  v10 = *((unsigned __int8 *)this + 92);
  this->m_iMoveState = iMoveState;
  *(_QWORD *)&this->m_vDetourTarget.x = v9;
  *((_BYTE *)this + 92) = v10 & 0xF8;
  if ( pOtherPed )
    CEntity::RegisterReference(pOtherPed, &this->m_pOtherPed);
}
// 66C2F0: using guessed type void *;

//----- (00521C78) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::~CTaskComplexAvoidOtherPedWhileWandering(
        CTaskComplexAvoidOtherPedWhileWandering *this)
{
  CPed *m_pOtherPed; // r0
  CEntity **p_m_pOtherPed; // r1

  p_m_pOtherPed = &this->m_pOtherPed;
  m_pOtherPed = this->m_pOtherPed;
  this->_vptr$CTask = (int (**)(void))&off_66C2F0;
  if ( m_pOtherPed )
    CEntity::CleanUpOldReference(m_pOtherPed, p_m_pOtherPed);
  sub_18EDB4(this);
}
// 66C2F0: using guessed type void *off_66C2F0;

//----- (00521CA4) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::~CTaskComplexAvoidOtherPedWhileWandering(
        CTaskComplexAvoidOtherPedWhileWandering *this)
{
  CPed *m_pOtherPed; // r0
  CEntity **p_m_pOtherPed; // r1
  void *v4; // r0

  p_m_pOtherPed = &this->m_pOtherPed;
  m_pOtherPed = this->m_pOtherPed;
  this->_vptr$CTask = (int (**)(void))&off_66C2F0;
  if ( m_pOtherPed )
    CEntity::CleanUpOldReference(m_pOtherPed, p_m_pOtherPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 521CCC: variable 'v4' is possibly undefined
// 66C2F0: using guessed type void *off_66C2F0;

//----- (00521CD4) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::QuitIK(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pPed)
{
  if ( *((unsigned __int8 *)this + 92) << 31 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      sub_1A0E80(&g_ikChainMan, pPed, 250);
  }
}

//----- (00521D10) --------------------------------------------------------
bool __fastcall CTaskComplexAvoidOtherPedWhileWandering::MakeAbortable(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent) != 1 )
    return 0;
  if ( *((unsigned __int8 *)this + 92) << 31 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  }
  *((_DWORD *)&pPed->m_nPedFlags + 3) &= ~0x40u;
  return 1;
}

//----- (00521D74) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidOtherPedWhileWandering::CreateNextSubTask(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pPed)
{
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexAvoidOtherPedWhileWandering *, CPed *))this->_vptr$CTask + 11))(
                      this,
                      pPed);
  if ( *((unsigned __int8 *)this + 92) << 31 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  }
  *((_DWORD *)&pPed->m_nPedFlags + 3) &= ~0x40u;
  return 0;
}

//----- (00521DD4) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidOtherPedWhileWandering::CreateFirstSubTask(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  __int64 v7; // d16
  CMatrix *v8; // r0
  CTaskSimple *v9; // r0
  int m_iMoveState; // r4
  CTask *result; // r0
  __int64 v12; // d16
  char v13; // r1
  int v14; // r2
  int v15; // r2
  int v16; // r3
  int v17; // r1
  CColSphere sphere; // [sp+Ch] [bp-4Ch] BYREF
  CVector vTarget; // [sp+20h] [bp-38h] BYREF
  CVector vStartPoint; // [sp+30h] [bp-28h] BYREF

  if ( this->m_pOtherPed )
  {
    m_pMat = pPed->m_pMat;
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v7 = *(_QWORD *)&p_tx->m_translate.x;
    this->m_vStartPoint.z = p_tx->m_translate.z;
    *(_QWORD *)&this->m_vStartPoint.x = v7;
    CTaskComplexAvoidOtherPedWhileWandering::ComputeAvoidSphere(this, pPed, &sphere);
    *(_QWORD *)&vStartPoint.x = *(_QWORD *)&this->m_vStartPoint.x;
    *(_QWORD *)&vTarget.x = *(_QWORD *)&this->m_vTarget.x;
    v8 = pPed->m_pMat;
    if ( v8 )
      p_m_transform = (CSimpleTransform *)&v8->tx;
    vStartPoint.z = p_m_transform->m_translate.z;
    vTarget.z = vStartPoint.z;
    sphere.m_vecCentre.z = vStartPoint.z;
    if ( CPedGeometryAnalyser::ComputeRouteRoundSphere(
           pPed,
           &sphere,
           &vStartPoint,
           &vTarget,
           &this->m_vNewTarget,
           &this->m_vDetourTarget) )
    {
      *((_DWORD *)&pPed->m_nPedFlags + 3) |= 0x40u;
      v9 = (CTaskSimple *)CTask::operator new(0x2Cu);
      m_iMoveState = this->m_iMoveState;
      CTaskSimple::CTaskSimple(v9);
      result[1]._vptr$CTask = (int (**)(void))m_iMoveState;
      result->_vptr$CTask = (int (**)(void))&off_66C0A0;
      v12 = *(_QWORD *)&this->m_vDetourTarget.x;
      LOBYTE(m_iMoveState) = BYTE1(result[3].m_pParent);
      v13 = (int)result[3].m_pParent & 0xC0;
      result[2].m_pParent = (CTask *)LODWORD(this->m_vDetourTarget.z);
      result->_vptr$CTask = (int (**)(void))&off_66C0D4;
      result[3]._vptr$CTask = (int (**)(void))1056964608;
      BYTE1(result[3].m_pParent) = m_iMoveState & 0xE0;
      LOBYTE(result[3].m_pParent) = v13;
      *(_QWORD *)&result[1].m_pParent = v12;
      v14 = CTimer::m_snTimeInMilliseconds;
      this->m_DontQuitYetTimer.m_bIsActive = 1;
      this->m_DontQuitYetTimer.m_iStartTime = v14;
      this->m_DontQuitYetTimer.m_iDuration = 2000;
      return result;
    }
    if ( *((unsigned __int8 *)this + 92) << 31 )
    {
      if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
        IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    }
  }
  v15 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v16 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  v17 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v17;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v15;
  result = 0;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v16 & 0xFFFFFFBF;
  return result;
}
// 521E78: variable 'result' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (00521F30) --------------------------------------------------------
bool __fastcall CTaskComplexAvoidOtherPedWhileWandering::ComputeDetourTarget(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        const CPed *ped)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CColSphere sphere; // [sp+Ch] [bp-44h] BYREF
  CVector vTarget; // [sp+20h] [bp-30h] BYREF
  CVector vStartPoint; // [sp+30h] [bp-20h] BYREF

  CTaskComplexAvoidOtherPedWhileWandering::ComputeAvoidSphere(this, ped, &sphere);
  *(_QWORD *)&vStartPoint.x = *(_QWORD *)&this->m_vStartPoint.x;
  *(_QWORD *)&vTarget.x = *(_QWORD *)&this->m_vTarget.x;
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  vStartPoint.z = p_tx->m_translate.z;
  vTarget.z = vStartPoint.z;
  sphere.m_vecCentre.z = vStartPoint.z;
  return CPedGeometryAnalyser::ComputeRouteRoundSphere(
           ped,
           &sphere,
           &vStartPoint,
           &vTarget,
           &this->m_vNewTarget,
           &this->m_vDetourTarget);
}

//----- (00521F8A) --------------------------------------------------------
int __fastcall CTaskComplexAvoidOtherPedWhileWandering::NearbyPedsInSphere(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        const CPed *ped,
        const CColSphere *sphere,
        CPed **nearbyPeds,
        CPed **a5)
{
  int v7; // r8
  CPed *v8; // r11
  CMatrix *m_pMat; // r0
  float v10; // r1
  const CVector *p_tx; // r2
  CPed **v12; // r0
  char v14; // [sp+44h] [bp-34h]
  CColSphere v15; // [sp+48h] [bp-30h] BYREF

  v7 = 0;
  v14 = 0;
  do
  {
    v8 = nearbyPeds[v7];
    if ( v8 )
    {
      m_pMat = v8->m_pMat;
      LOWORD(v10) = 26214;
      p_tx = (const CVector *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v8->m_transform.m_translate;
      HIWORD(v10) = 16262;
      CColSphere::Set(&v15, v10, p_tx, 0, 0, 0xFFu);
      if ( CColSphere::IntersectSphere(sphere, &v15) )
      {
        v12 = a5;
        if ( !*a5 )
          goto LABEL_22;
        v12 = a5 + 1;
        if ( !a5[1] )
          goto LABEL_22;
        v12 = a5 + 2;
        if ( !a5[2] )
          goto LABEL_22;
        v12 = a5 + 3;
        if ( !a5[3] )
          goto LABEL_22;
        v12 = a5 + 4;
        if ( !a5[4] )
          goto LABEL_22;
        v12 = a5 + 5;
        if ( !a5[5] )
          goto LABEL_22;
        v12 = a5 + 6;
        if ( !a5[6] )
          goto LABEL_22;
        v12 = a5 + 7;
        if ( !a5[7] )
          goto LABEL_22;
        v12 = a5 + 8;
        if ( !a5[8]
          || (v12 = a5 + 9, !a5[9])
          || (v12 = a5 + 10, !a5[10])
          || (v12 = a5 + 11, !a5[11])
          || (v12 = a5 + 12, !a5[12])
          || (v12 = a5 + 13, !a5[13])
          || (v12 = a5 + 14, !a5[14])
          || (v12 = a5 + 15, !a5[15]) )
        {
LABEL_22:
          nearbyPeds[v7] = 0;
          *v12 = v8;
          v14 = 1;
        }
      }
    }
    ++v7;
  }
  while ( v7 != 16 );
  return v14 & 1;
}

//----- (00522128) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::ComputeSphere(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CColSphere *sphere,
        CPed **accountedPeds)
{
  unsigned __int64 v3; // d0
  float32x2_t v4; // d4
  int v5; // r12
  int v6; // r3
  float v7; // s2
  float v8; // s4
  CPed *v9; // r0
  CMatrix *m_pMat; // lr
  float *p_tx; // r4
  int v12; // r0
  float v13; // s6
  float v14; // s2
  float v15; // s4
  RwReal v16; // s6
  float32x2_t v17; // d3
  CPed *v18; // r3
  CMatrix *v19; // r12
  float *p_x; // r4
  CVector vecCentre; // [sp+Ch] [bp-14h] BYREF

  LODWORD(v3) = 0;
  v5 = 0;
  v6 = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  v7 = 0.0;
  v8 = 0.0;
  do
  {
    v9 = accountedPeds[v6];
    if ( v9 )
    {
      m_pMat = v9->m_pMat;
      ++v5;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v9->m_transform.m_translate.x;
      v8 = *p_tx + v8;
      vecCentre.x = v8;
      v7 = p_tx[1] + v7;
      vecCentre.y = v7;
      *(float *)&v3 = p_tx[2] + *(float *)&v3;
      LODWORD(vecCentre.z) = v3;
    }
    ++v6;
  }
  while ( v6 != 16 );
  v12 = 0;
  v13 = 1.0 / (float)v5;
  v14 = v13 * v7;
  v15 = v13 * v8;
  v16 = v13 * *(float *)&v3;
  LODWORD(v3) = 0;
  vecCentre.y = v14;
  vecCentre.x = v15;
  vecCentre.z = v16;
  v17.n64_u64[0] = v3;
  do
  {
    v18 = accountedPeds[v12];
    if ( v18 )
    {
      v19 = v18->m_pMat;
      p_x = &v19->tx;
      if ( !v19 )
        p_x = &v18->m_transform.m_translate.x;
      v4.n64_f32[0] = (float)((float)((float)(*p_x - v15) * (float)(*p_x - v15))
                            + (float)((float)(p_x[1] - v14) * (float)(p_x[1] - v14)))
                    + 0.0;
      v17.n64_u64[0] = vmax_f32(v4, v17).n64_u64[0];
    }
    ++v12;
  }
  while ( v12 != 16 );
  CColSphere::Set(sphere, sqrtf(v17.n64_f32[0]) + 1.05, &vecCentre, 0, 0, 0xFFu);
}
// 5221BA: variable 'v3' is possibly undefined
// 5221F4: variable 'v4' is possibly undefined

//----- (00522230) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::ComputeAvoidSphere(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        const CPed *ped,
        CColSphere *sphere)
{
  CPed *m_pOtherPed; // r0
  CPedIntelligence *m_pPedIntelligence; // r4
  const CVector *p_m_translate; // r2
  bool v9; // zf
  float v10; // r1
  CEntity **m_entities; // r4
  int i; // r9
  const CPed *v13; // r1
  CPed *v14; // r0
  CTaskComplexAvoidOtherPedWhileWandering *v15; // r0
  CTaskComplexAvoidOtherPedWhileWandering *v16; // r0
  const CPed *v17; // r1
  CPed *v18[16]; // [sp+Ch] [bp-9Ch] BYREF
  CPed *nearbyPeds[23]; // [sp+4Ch] [bp-5Ch] BYREF

  m_pOtherPed = this->m_pOtherPed;
  m_pPedIntelligence = ped->m_pPedIntelligence;
  v10 = *(float *)&m_pOtherPed->m_pMat;
  p_m_translate = (const CVector *)(LODWORD(v10) + 48);
  v9 = LODWORD(v10) == 0;
  LOWORD(v10) = 26214;
  if ( v9 )
    p_m_translate = &m_pOtherPed->m_transform.m_translate;
  HIWORD(v10) = 16262;
  CColSphere::Set(sphere, v10, p_m_translate, 0, 0, 0xFFu);
  m_entities = m_pPedIntelligence->m_pedScanner.m_entities;
  for ( i = 0; i != 16; ++i )
  {
    v13 = (const CPed *)m_entities[i];
    if ( v13 == this->m_pOtherPed )
    {
      v14 = 0;
    }
    else if ( CPedGroups::AreInSameGroup(ped, v13) )
    {
      v14 = 0;
    }
    else
    {
      v14 = (CPed *)m_entities[i];
    }
    nearbyPeds[i] = v14;
    v18[i] = 0;
  }
  v18[0] = this->m_pOtherPed;
  v15 = (CTaskComplexAvoidOtherPedWhileWandering *)CTaskComplexAvoidOtherPedWhileWandering::NearbyPedsInSphere(
                                                     (CTaskComplexAvoidOtherPedWhileWandering *)v18[0],
                                                     v13,
                                                     sphere,
                                                     nearbyPeds,
                                                     v18);
  if ( v15 == (CTaskComplexAvoidOtherPedWhileWandering *)((char *)&dword_0 + 1) )
  {
    do
    {
      CTaskComplexAvoidOtherPedWhileWandering::ComputeSphere(v15, sphere, v18);
      v15 = (CTaskComplexAvoidOtherPedWhileWandering *)CTaskComplexAvoidOtherPedWhileWandering::NearbyPedsInSphere(
                                                         v16,
                                                         v17,
                                                         sphere,
                                                         nearbyPeds,
                                                         v18);
    }
    while ( v15 );
  }
}
// 5222B4: variable 'v13' is possibly undefined
// 5222CC: variable 'v16' is possibly undefined
// 5222CC: variable 'v17' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005222DC) --------------------------------------------------------
bool __fastcall CTaskComplexAvoidOtherPedWhileWandering::ComputeDetourTarget(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        const CPed *ped,
        CColSphere *sphere)
{
  CMatrix *m_pMat; // r12
  CSimpleTransform *p_tx; // r3
  CVector vTarget; // [sp+8h] [bp-28h] BYREF
  CVector vStartPoint; // [sp+18h] [bp-18h] BYREF

  *(_QWORD *)&vStartPoint.x = *(_QWORD *)&this->m_vStartPoint.x;
  *(_QWORD *)&vTarget.x = *(_QWORD *)&this->m_vTarget.x;
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  vStartPoint.z = p_tx->m_translate.z;
  vTarget.z = vStartPoint.z;
  sphere->m_vecCentre.z = vStartPoint.z;
  return CPedGeometryAnalyser::ComputeRouteRoundSphere(
           ped,
           sphere,
           &vStartPoint,
           &vTarget,
           &this->m_vNewTarget,
           &this->m_vDetourTarget);
}

//----- (00522328) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::SetUpIK(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pPed)
{
  CPad *Pad; // r6
  CPlayerPed *PlayerPed; // r0
  bool v6; // zf
  _BOOL4 v7; // r0
  bool v8; // zf
  CTask *m_pParent; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  RwReal v13; // s0
  RwReal v14; // s4
  CMatrix *v15; // r0
  float v16; // s4
  float x; // s6
  RwV3d_0 pOffsetPos; // [sp+20h] [bp-28h] BYREF
  CVector v19; // [sp+2Ch] [bp-1Ch] BYREF

  Pad = CPad::GetPad(0);
  PlayerPed = FindPlayerPed(-1);
  v6 = PlayerPed == pPed;
  if ( PlayerPed == pPed )
    v6 = Pad->DisablePlayerControls == 0;
  if ( !v6 )
  {
    v7 = CEntity::GetIsOnScreen(pPed);
    v8 = v7;
    if ( v7 )
      v8 = *((unsigned __int8 *)this + 92) << 31 == 0;
    if ( v8
      && !IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPed)
      && !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 5) )
    {
      m_pParent = this->m_pParent;
      if ( !m_pParent
        || (*((int (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent) != 917
        && (*((int (__fastcall **)(CTask *))this->m_pParent->CTaskComplex::CTask::_vptr$CTask + 5))(this->m_pParent) != 939 )
      {
        m_pMat = pPed->m_pMat;
        p_m_transform = &pPed->m_transform;
        p_tx = &pPed->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        v13 = this->m_vTarget.x - p_tx->m_translate.x;
        v14 = this->m_vTarget.z - p_tx->m_translate.z;
        v19.y = this->m_vTarget.y - p_tx->m_translate.y;
        v19.x = v13;
        v19.z = v14;
        if ( (float)((float)((float)(v13 * v13) + (float)(v19.y * v19.y)) + (float)(v14 * v14)) > 9.0 )
        {
          CVector::Normalise(&v19);
          v15 = pPed->m_pMat;
          if ( (float)((float)((float)(v19.x * v15->xy) + (float)(v19.y * v15->yy)) + (float)(v19.z * v15->zy)) < g_PedIkDiffDot )
          {
            if ( v15 )
              p_m_transform = (CSimpleTransform *)&v15->tx;
            v16 = (float)(v19.z + v19.z) + p_m_transform->m_translate.z;
            x = this->m_vTarget.x;
            pOffsetPos.y = (float)(v19.y + v19.y) + this->m_vTarget.y;
            pOffsetPos.x = (float)(v19.x + v19.x) + x;
            pOffsetPos.z = v16 + 0.61;
            IKChainManager_c::LookAt(
              &g_ikChainMan,
              "TaskAvoidOthPed",
              pPed,
              0,
              5000,
              -1,
              &pOffsetPos,
              0,
              0.25,
              500,
              3,
              0);
            *((_BYTE *)this + 92) |= 1u;
          }
        }
      }
    }
  }
}

//----- (005224F8) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(
        CTaskComplexAvoidOtherPedWhileWandering *this,
        CPed *pPed)
{
  CPed *m_pLeader; // r8
  CPed *m_pOtherPed; // r1
  int v6; // r0
  char *m_pSubTask; // r4
  int v8; // r2
  int v9; // r3
  int v10; // r1
  unsigned __int16 v12; // r0
  CPed *v13; // r0
  CSimpleTransform *p_m_transform; // r10
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CMatrix *v17; // r3
  float *p_x; // r2
  float v19; // s16
  CTask *SimplestActiveTask; // r0
  bool v21; // zf
  unsigned int v22; // r1
  int m_iStartTime; // r2
  float32x2_t *v24; // r0
  float32x2_t v25; // d16
  unsigned __int64 v26; // d1
  char v27; // r0
  __int64 v28; // r0
  char v29; // r2
  CTaskComplexGangFollower *TaskByType; // r0
  bool v31; // zf
  CMatrix *v32; // r0
  float *v33; // r1
  RwReal v34; // s2
  RwReal v35; // s4
  CMatrix *v36; // r0
  __int64 v37; // d16
  char v38; // r0
  CColSphere outVec; // [sp+Ch] [bp-64h] BYREF
  CVector vTarget; // [sp+20h] [bp-50h] BYREF
  CVector vStartPoint; // [sp+30h] [bp-40h] BYREF

  m_pOtherPed = this->m_pOtherPed;
  v6 = *((unsigned __int8 *)this + 92);
  if ( !m_pOtherPed )
  {
    if ( !(v6 << 31) || !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      goto LABEL_11;
    goto LABEL_10;
  }
  if ( (v6 & 2) != 0
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
  {
    goto LABEL_11;
  }
  if ( !this->m_Timer.m_bIsActive )
  {
    *(_QWORD *)&this->m_Timer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0xC800000000LL;
    this->m_Timer.m_bIsActive = 1;
  }
  CTaskComplexAvoidOtherPedWhileWandering::SetUpIK(this, pPed);
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203 )
    return this->m_pSubTask;
  if ( pPed->m_pPedIntelligence->m_iStaticCounter <= 30 )
  {
    v13 = this->m_pOtherPed;
    p_m_transform = &pPed->m_transform;
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    v17 = v13->m_pMat;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    p_x = &v17->tx;
    if ( !v17 )
      p_x = &v13->m_transform.m_translate.x;
    if ( fabsf(p_tx->m_translate.z - p_x[2]) > 3.0 )
    {
      if ( !(*((unsigned __int8 *)this + 92) << 31) || !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
        goto LABEL_11;
      goto LABEL_10;
    }
    v19 = (float)((float)((float)(p_tx->m_translate.x - *p_x) * (float)(p_tx->m_translate.x - *p_x))
                + (float)((float)(p_tx->m_translate.y - p_x[1]) * (float)(p_tx->m_translate.y - p_x[1])))
        + 0.0;
    SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&v13->m_pPedIntelligence->m_taskManager);
    v21 = SimplestActiveTask == 0;
    if ( SimplestActiveTask )
      v21 = this->m_DontQuitYetTimer.m_bIsActive == 0;
    if ( !v21 )
    {
      if ( this->m_DontQuitYetTimer.m_bIsStopped )
      {
        v22 = CTimer::m_snTimeInMilliseconds;
        this->m_DontQuitYetTimer.m_bIsStopped = 0;
        this->m_DontQuitYetTimer.m_iStartTime = v22;
        m_iStartTime = v22;
      }
      else
      {
        m_iStartTime = this->m_DontQuitYetTimer.m_iStartTime;
        v22 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_DontQuitYetTimer.m_iDuration <= v22 )
      {
        if ( CTask::IsGoToTask(SimplestActiveTask) )
        {
          v24 = (float32x2_t *)this->m_pOtherPed;
          if ( (float)((float)((float)(pPed->m_pMat->xy * *(float *)(v24[2].n64_u32[1] + 16))
                             + (float)(pPed->m_pMat->yy * *(float *)(v24[2].n64_u32[1] + 20)))
                     + (float)(pPed->m_pMat->zy * *(float *)(v24[2].n64_u32[1] + 24))) >= 0.923
            && v19 > 1.0 )
          {
            v25.n64_u64[0] = vmul_f32(v24[9], (float32x2_t)0x4248000042480000LL).n64_u64[0];
            v26 = vmul_f32(v25, v25).n64_u64[0];
            if ( (float)((float)((float)(*(float *)&v26 + *((float *)&v26 + 1)) + 0.0) + 0.25) >= (float)((float)((float)((float)(pPed->m_vecMoveSpeed.x * 50.0) * (float)(pPed->m_vecMoveSpeed.x * 50.0)) + (float)((float)(pPed->m_vecMoveSpeed.y * 50.0) * (float)(pPed->m_vecMoveSpeed.y * 50.0))) + 0.0) )
            {
              if ( !(*((unsigned __int8 *)this + 92) << 31) || !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
                goto LABEL_11;
              goto LABEL_10;
            }
          }
        }
      }
    }
    v27 = `guard variable for'CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(CPed *)::fMinAvoidDistAndABit;
    __dmb(0xBu);
    if ( (v27 & 1) == 0
      && _cxa_guard_acquire((__guard *)&`guard variable for'CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(CPed *)::fMinAvoidDistAndABit) )
    {
      CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(CPed *)::fMinAvoidDistAndABit = (float)(2.5 * 2.5) + 1.0;
      _cxa_guard_release((__guard *)&`guard variable for'CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(CPed *)::fMinAvoidDistAndABit);
    }
    if ( v19 > CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(CPed *)::fMinAvoidDistAndABit )
    {
      if ( !(*((unsigned __int8 *)this + 92) << 31) || !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
        goto LABEL_11;
      goto LABEL_10;
    }
    if ( !this->m_Timer.m_bIsActive )
      return this->m_pSubTask;
    if ( this->m_Timer.m_bIsStopped )
    {
      LODWORD(v28) = CTimer::m_snTimeInMilliseconds;
      this->m_Timer.m_bIsStopped = 0;
      this->m_Timer.m_iStartTime = v28;
      HIDWORD(v28) = v28;
    }
    else
    {
      HIDWORD(v28) = this->m_Timer.m_iStartTime;
      LODWORD(v28) = CTimer::m_snTimeInMilliseconds;
    }
    if ( HIDWORD(v28) + this->m_Timer.m_iDuration > (unsigned int)v28 )
      return this->m_pSubTask;
    v29 = *((_BYTE *)this + 92);
    HIDWORD(v28) = 200;
    *(_QWORD *)&this->m_Timer.m_iStartTime = v28;
    this->m_Timer.m_bIsActive = 1;
    if ( (v29 & 4) != 0 )
    {
      TaskByType = (CTaskComplexGangFollower *)CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 1207);
      v31 = TaskByType == 0;
      if ( TaskByType )
      {
        m_pLeader = TaskByType->m_pLeader;
        v31 = m_pLeader == 0;
      }
      if ( !v31 )
      {
        CTaskComplexGangFollower::CalculateOffsetPosition(TaskByType, &outVec.m_vecCentre);
        v32 = m_pLeader->m_pMat;
        v33 = &v32->tx;
        if ( !v32 )
          v33 = &m_pLeader->m_transform.m_translate.x;
        v34 = v33[1] + outVec.m_vecCentre.y;
        v35 = v33[2] + outVec.m_vecCentre.z;
        this->m_vTarget.x = *v33 + outVec.m_vecCentre.x;
        this->m_vTarget.y = v34;
        this->m_vTarget.z = v35;
      }
    }
    CTaskComplexAvoidOtherPedWhileWandering::ComputeAvoidSphere(this, pPed, &outVec);
    *(_QWORD *)&vStartPoint.x = *(_QWORD *)&this->m_vStartPoint.x;
    *(_QWORD *)&vTarget.x = *(_QWORD *)&this->m_vTarget.x;
    v36 = pPed->m_pMat;
    if ( v36 )
      p_m_transform = (CSimpleTransform *)&v36->tx;
    vStartPoint.z = p_m_transform->m_translate.z;
    vTarget.z = vStartPoint.z;
    outVec.m_vecCentre.z = vStartPoint.z;
    if ( CPedGeometryAnalyser::ComputeRouteRoundSphere(
           pPed,
           &outVec,
           &vStartPoint,
           &vTarget,
           &this->m_vNewTarget,
           &this->m_vDetourTarget) == 1 )
    {
      m_pSubTask = (char *)this->m_pSubTask;
      if ( *((float *)m_pSubTask + 3) == this->m_vDetourTarget.x
        && *((float *)m_pSubTask + 4) == this->m_vDetourTarget.y
        && *((float *)m_pSubTask + 5) == this->m_vDetourTarget.z
        && *((float *)m_pSubTask + 6) == 0.5 )
      {
        return (CTask *)m_pSubTask;
      }
      v37 = *(_QWORD *)&this->m_vDetourTarget.x;
      v38 = m_pSubTask[28] & 0xD0;
      *((_DWORD *)m_pSubTask + 5) = LODWORD(this->m_vDetourTarget.z);
      *((_DWORD *)m_pSubTask + 6) = 1056964608;
      *(_QWORD *)(m_pSubTask + 12) = v37;
      m_pSubTask[28] = v38 | 0x20;
      return this->m_pSubTask;
    }
    if ( !(*((unsigned __int8 *)this + 92) << 31) || !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      goto LABEL_11;
LABEL_10:
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
LABEL_11:
    v8 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v9 = *((_DWORD *)&pPed->m_nPedFlags + 3);
    v10 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
    *((_DWORD *)&pPed->m_nPedFlags + 1) = v10;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v8;
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v9 & 0xFFFFFFBF;
    return 0;
  }
  if ( *((unsigned __int8 *)this + 92) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  m_pSubTask = (char *)CTask::operator new(0x20u);
  v12 = rand();
  CTaskSimpleStandStill::CTaskSimpleStandStill(
    (CTaskSimpleStandStill *)m_pSubTask,
    (int)(float)((float)((float)v12 * 0.000015259) * 2000.0) + 500,
    0,
    0,
    8.0);
  return (CTask *)m_pSubTask;
}
// 5228CC: variable 'm_pLeader' is possibly undefined
// 9FF01C: using guessed type char `guard variable for'CTaskComplexAvoidOtherPedWhileWandering::ControlSubTask(CPed *)::fMinAvoidDistAndABit;

//----- (00522A64) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::CTaskComplexAvoidEntity(
        CTaskComplexAvoidEntity *this,
        const int iMoveState,
        CEntity *pEntity,
        const CVector *vTarget)
{
  __int64 v8; // d16
  __int64 v9; // d16
  char v10; // r2

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = iMoveState;
  this->_vptr$CTask = (int (**)(void))&off_66C32C;
  this->m_pEntity = pEntity;
  v8 = *(_QWORD *)&vTarget->x;
  this->m_vTarget.z = vTarget->z;
  *(_QWORD *)&this->m_vTarget.x = v8;
  v9 = *(_QWORD *)&vTarget->x;
  this->m_vDetourTarget.z = vTarget->z;
  *(_WORD *)&this->m_Timer.m_bIsActive = 0;
  *(_QWORD *)&this->m_vDetourTarget.x = v9;
  v10 = *((_BYTE *)this + 80);
  this->m_Timer.m_iStartTime = 0;
  this->m_Timer.m_iDuration = 0;
  *((_BYTE *)this + 80) = v10 & 0xFE;
  if ( pEntity )
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
}
// 66C32C: using guessed type void *;

//----- (00522AD4) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::~CTaskComplexAvoidEntity(CTaskComplexAvoidEntity *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C32C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 66C32C: using guessed type void *off_66C32C;

//----- (00522B00) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::~CTaskComplexAvoidEntity(CTaskComplexAvoidEntity *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C32C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 522B28: variable 'v4' is possibly undefined
// 66C32C: using guessed type void *off_66C32C;

//----- (00522B30) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::SetUpIK(CTaskComplexAvoidEntity *this, CPed *pPed)
{
  CPad *Pad; // r6
  CPlayerPed *PlayerPed; // r0
  bool v6; // zf
  _BOOL4 v7; // r0
  bool v8; // zf
  CTask *m_pParent; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  RwReal v13; // s0
  RwReal v14; // s4
  CMatrix *v15; // r0
  float v16; // s4
  float x; // s6
  RwV3d_0 pOffsetPos; // [sp+20h] [bp-28h] BYREF
  CVector v19; // [sp+2Ch] [bp-1Ch] BYREF

  Pad = CPad::GetPad(0);
  PlayerPed = FindPlayerPed(-1);
  v6 = PlayerPed == pPed;
  if ( PlayerPed == pPed )
    v6 = Pad->DisablePlayerControls == 0;
  if ( !v6 )
  {
    v7 = CEntity::GetIsOnScreen(pPed);
    v8 = v7;
    if ( v7 )
      v8 = *((unsigned __int8 *)this + 80) << 31 == 0;
    if ( v8
      && !IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPed)
      && !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 5) )
    {
      m_pParent = this->m_pParent;
      if ( !m_pParent
        || (*((int (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent) != 917
        && (*((int (__fastcall **)(CTask *))this->m_pParent->CTaskComplex::CTask::_vptr$CTask + 5))(this->m_pParent) != 939 )
      {
        m_pMat = pPed->m_pMat;
        p_m_transform = &pPed->m_transform;
        p_tx = &pPed->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        v13 = this->m_vTarget.x - p_tx->m_translate.x;
        v14 = this->m_vTarget.z - p_tx->m_translate.z;
        v19.y = this->m_vTarget.y - p_tx->m_translate.y;
        v19.x = v13;
        v19.z = v14;
        if ( (float)((float)((float)(v13 * v13) + (float)(v19.y * v19.y)) + (float)(v14 * v14)) > 9.0 )
        {
          CVector::Normalise(&v19);
          v15 = pPed->m_pMat;
          if ( (float)((float)((float)(v19.x * v15->xy) + (float)(v19.y * v15->yy)) + (float)(v19.z * v15->zy)) < g_PedIkDiffDot )
          {
            if ( v15 )
              p_m_transform = (CSimpleTransform *)&v15->tx;
            v16 = (float)(v19.z + v19.z) + p_m_transform->m_translate.z;
            x = this->m_vTarget.x;
            pOffsetPos.y = (float)(v19.y + v19.y) + this->m_vTarget.y;
            pOffsetPos.x = (float)(v19.x + v19.x) + x;
            pOffsetPos.z = v16 + 0.61;
            IKChainManager_c::LookAt(
              &g_ikChainMan,
              "TaskAvoidEntity",
              pPed,
              0,
              5000,
              -1,
              &pOffsetPos,
              0,
              0.25,
              500,
              3,
              0);
            *((_BYTE *)this + 80) |= 1u;
          }
        }
      }
    }
  }
}

//----- (00522D00) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::QuitIK(CTaskComplexAvoidEntity *this, CPed *pPed)
{
  if ( *((unsigned __int8 *)this + 80) << 31 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      sub_1A0E80(&g_ikChainMan, pPed, 250);
  }
}

//----- (00522D3C) --------------------------------------------------------
bool __fastcall CTaskComplexAvoidEntity::MakeAbortable(
        CTaskComplexAvoidEntity *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( *((unsigned __int8 *)this + 80) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  return 1;
}

//----- (00522D74) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidEntity::CreateNextSubTask(CTaskComplexAvoidEntity *this, CPed *pPed)
{
  if ( *((unsigned __int8 *)this + 80) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  return 0;
}

//----- (00522DAC) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidEntity::CreateFirstSubTask(CTaskComplexAvoidEntity *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  __int64 v7; // d16
  CEntity *m_pEntity; // r1
  CMatrix *v9; // r0
  CTaskSimple *v10; // r0
  int (**m_iMoveState)(void); // r4
  CTask *result; // r0
  __int64 v13; // d16
  char v14; // r3
  char v15; // r1
  CColSphere sphere; // [sp+Ch] [bp-64h] BYREF
  CEntity *accountedEntities; // [sp+20h] [bp-50h] BYREF
  _BYTE v18[48]; // [sp+24h] [bp-4Ch] BYREF
  int v19; // [sp+54h] [bp-1Ch]
  __int64 v20; // [sp+58h] [bp-18h]

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v7 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_vStartPoint.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_vStartPoint.x = v7;
  m_pEntity = this->m_pEntity;
  v19 = 0;
  v20 = 0LL;
  memset(v18, 0, sizeof(v18));
  accountedEntities = m_pEntity;
  CTaskComplexAvoidEntity::ComputeSphere((CTaskComplexAvoidEntity *)v18, &sphere, &accountedEntities);
  v9 = pPed->m_pMat;
  if ( v9 )
    p_m_transform = (CSimpleTransform *)&v9->tx;
  sphere.m_vecCentre.z = p_m_transform->m_translate.z;
  if ( CPedGeometryAnalyser::ComputeRouteRoundSphere(
         pPed,
         &sphere,
         &this->m_vStartPoint,
         &this->m_vTarget,
         &this->m_vNewTarget,
         &this->m_vDetourTarget) )
  {
    v10 = (CTaskSimple *)CTask::operator new(0x2Cu);
    m_iMoveState = (int (**)(void))this->m_iMoveState;
    CTaskSimple::CTaskSimple(v10);
    result[1]._vptr$CTask = m_iMoveState;
    result->_vptr$CTask = (int (**)(void))&off_66C0A0;
    v13 = *(_QWORD *)&this->m_vDetourTarget.x;
    v14 = BYTE1(result[3].m_pParent);
    v15 = (int)result[3].m_pParent & 0xC0;
    result[2].m_pParent = (CTask *)LODWORD(this->m_vDetourTarget.z);
    result->_vptr$CTask = (int (**)(void))&off_66C0D4;
    result[3]._vptr$CTask = (int (**)(void))1056964608;
    BYTE1(result[3].m_pParent) = v14 & 0xE0;
    LOBYTE(result[3].m_pParent) = v15;
    *(_QWORD *)&result[1].m_pParent = v13;
  }
  else
  {
    if ( *((unsigned __int8 *)this + 80) << 31 )
    {
      if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
        IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    }
    return 0;
  }
  return result;
}
// 522E44: variable 'result' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (00522EB8) --------------------------------------------------------
bool __fastcall CTaskComplexAvoidEntity::ComputeDetourTarget(CTaskComplexAvoidEntity *this, const CPed *ped)
{
  CEntity *m_pEntity; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CColSphere sphere; // [sp+Ch] [bp-64h] BYREF
  CEntity *accountedEntities; // [sp+20h] [bp-50h] BYREF
  _BYTE v10[48]; // [sp+24h] [bp-4Ch] BYREF
  int v11; // [sp+54h] [bp-1Ch]
  __int64 v12; // [sp+58h] [bp-18h]

  m_pEntity = this->m_pEntity;
  v11 = 0;
  v12 = 0LL;
  memset(v10, 0, sizeof(v10));
  accountedEntities = m_pEntity;
  CTaskComplexAvoidEntity::ComputeSphere((CTaskComplexAvoidEntity *)v10, &sphere, &accountedEntities);
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  sphere.m_vecCentre.z = p_tx->m_translate.z;
  return CPedGeometryAnalyser::ComputeRouteRoundSphere(
           ped,
           &sphere,
           &this->m_vStartPoint,
           &this->m_vTarget,
           &this->m_vNewTarget,
           &this->m_vDetourTarget);
}

//----- (00522F2A) --------------------------------------------------------
int __fastcall CTaskComplexAvoidEntity::NearbyEntitiesInSphere(
        CTaskComplexAvoidEntity *this,
        const CPed *ped,
        const CColSphere *sphere,
        CEntity **nearbyEntities,
        CEntity **accountedEntities)
{
  return 0;
}

//----- (00522F30) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::ComputeSphere(
        CTaskComplexAvoidEntity *this,
        CColSphere *sphere,
        CEntity **accountedEntities)
{
  unsigned __int64 v3; // d2
  float32x2_t v4; // d4
  float v5; // s0
  int v6; // r12
  int v7; // r3
  float v8; // s2
  CEntity *v9; // r0
  CMatrix *m_pMat; // lr
  float *p_tx; // r4
  int v12; // r0
  float v13; // s6
  float v14; // s0
  float v15; // s2
  float32x2_t v16; // d3
  CEntity *v17; // r3
  CMatrix *v18; // lr
  float *p_x; // r4
  CColModel *m_pColModel; // r3
  CVector vecCentre; // [sp+Ch] [bp-14h] BYREF

  v5 = 0.0;
  v6 = 0;
  v7 = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  v8 = 0.0;
  LODWORD(v3) = 0;
  do
  {
    v9 = accountedEntities[v7];
    if ( v9 )
    {
      m_pMat = v9->m_pMat;
      ++v6;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v9->m_transform.m_translate.x;
      *(float *)&v3 = *p_tx + *(float *)&v3;
      LODWORD(vecCentre.x) = v3;
      v8 = p_tx[1] + v8;
      vecCentre.y = v8;
      v5 = p_tx[2] + v5;
      vecCentre.z = v5;
    }
    ++v7;
  }
  while ( v7 != 16 );
  v12 = 0;
  vecCentre.z = 0.0;
  v13 = 1.0 / (float)v6;
  v14 = v13 * v8;
  v15 = v13 * *(float *)&v3;
  LODWORD(v3) = 0;
  v16.n64_u64[0] = v3;
  vecCentre.y = v14;
  vecCentre.x = v15;
  do
  {
    v17 = accountedEntities[v12];
    if ( v17 )
    {
      v18 = v17->m_pMat;
      p_x = &v18->tx;
      if ( !v18 )
        p_x = &v17->m_transform.m_translate.x;
      m_pColModel = CModelInfo::ms_modelInfoPtrs[v17->m_nModelIndex]->m_pColModel;
      v4.n64_f32[0] = (float)((float)((float)((float)(*p_x - v15) * (float)(*p_x - v15))
                                    + (float)((float)(p_x[1] - v14) * (float)(p_x[1] - v14)))
                            + 0.0)
                    + (float)(m_pColModel->m_sphereBound.m_fRadius * m_pColModel->m_sphereBound.m_fRadius);
      v16.n64_u64[0] = vmax_f32(v4, v16).n64_u64[0];
    }
    ++v12;
  }
  while ( v12 != 16 );
  CColSphere::Set(sphere, sqrtf(v16.n64_f32[0]) + 0.7, &vecCentre, 0, 0, 0xFFu);
}
// 522FBC: variable 'v3' is possibly undefined
// 523014: variable 'v4' is possibly undefined

//----- (00523054) --------------------------------------------------------
void __fastcall CTaskComplexAvoidEntity::ComputeAvoidSphere(
        CTaskComplexAvoidEntity *this,
        const CPed *ped,
        CColSphere *sphere)
{
  CEntity *m_pEntity; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CEntity *v8; // [sp+0h] [bp-48h] BYREF
  __int64 v9; // [sp+4h] [bp-44h]
  __int64 v10; // [sp+Ch] [bp-3Ch]
  __int64 v11; // [sp+14h] [bp-34h]
  __int64 v12; // [sp+1Ch] [bp-2Ch]
  __int64 v13; // [sp+24h] [bp-24h]
  __int64 v14; // [sp+2Ch] [bp-1Ch]
  int v15; // [sp+34h] [bp-14h]
  __int64 v16; // [sp+38h] [bp-10h]

  m_pEntity = this->m_pEntity;
  v15 = 0;
  v16 = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v8 = m_pEntity;
  CTaskComplexAvoidEntity::ComputeSphere((CTaskComplexAvoidEntity *)m_pEntity, sphere, &v8);
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  sphere->m_vecCentre.z = p_tx->m_translate.z;
}

//----- (005230A0) --------------------------------------------------------
bool __fastcall CTaskComplexAvoidEntity::ComputeDetourTarget(
        CTaskComplexAvoidEntity *this,
        const CPed *ped,
        const CColSphere *sphere)
{
  return CPedGeometryAnalyser::ComputeRouteRoundSphere(
           ped,
           sphere,
           &this->m_vStartPoint,
           &this->m_vTarget,
           &this->m_vNewTarget,
           &this->m_vDetourTarget);
}

//----- (005230C8) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidEntity::ControlSubTask(CTaskComplexAvoidEntity *this, CPed *pPed)
{
  CEntity *m_pEntity; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v6; // r3
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d3

  if ( this->m_pEntity )
  {
    CTaskComplexAvoidEntity::SetUpIK(this, pPed);
    if ( pPed->m_pPedIntelligence->m_iStaticCounter <= 30 )
    {
      m_pEntity = this->m_pEntity;
      m_pMat = pPed->m_pMat;
      v6 = m_pEntity->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      p_m_transform = (CSimpleTransform *)&v6->tx;
      if ( !v6 )
        p_m_transform = &m_pEntity->m_transform;
      v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
      v10 = vmul_f32(v9, v9).n64_u64[0];
      if ( (float)((float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                                 * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                         + *(float *)&v10)
                 + *((float *)&v10 + 1)) <= (float)(7.5 * (float)((float)(7.5 + 7.5) + (float)(7.5 + 7.5))) )
        return this->m_pSubTask;
      if ( *((unsigned __int8 *)this + 80) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
        goto LABEL_17;
    }
    else if ( *((unsigned __int8 *)this + 80) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    {
LABEL_17:
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
      return 0;
    }
  }
  else if ( *((unsigned __int8 *)this + 80) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
  {
    goto LABEL_17;
  }
  return 0;
}

//----- (005231E4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTaskComplexWanderStandard::ScanForStuff(CTaskComplexWanderStandard *this, CPed *pPed)
{
  CTaskComplexWanderStandard *v2; // r5
  CPed *v3; // r1
  CPed *v4; // r4
  int v5; // r1
  CTaskComplexWanderStandard *v6; // r1
  int m_iStartTime; // r1
  int v8; // r1
  int v9; // r1

  v2 = this;
  v4 = v3;
  this = (CTaskComplexWanderStandard *)CTimer::m_snTimeInMilliseconds;
  if ( !v2->m_timer.m_bIsActive )
  {
    v5 = 50;
    *(_QWORD *)&v2->m_timer.m_iStartTime = *(_QWORD *)&this;
    v2->m_timer.m_bIsActive = 1;
  }
  if ( (unsigned int)this >= v2->m_iMinNextScanTime )
  {
    if ( v2->m_timer.m_bIsStopped )
    {
      v2->m_timer.m_bIsStopped = 0;
      v6 = this;
      v2->m_timer.m_iStartTime = (int)this;
    }
    else
    {
      m_iStartTime = v2->m_timer.m_iStartTime;
    }
    if ( v8 + v2->m_timer.m_iDuration <= (unsigned int)this )
    {
      v9 = 50;
      *(_QWORD *)&v2->m_timer.m_iStartTime = *(_QWORD *)&this;
      v2->m_timer.m_bIsActive = 1;
      if ( !CTaskComplexWanderStandard::LookForGangMembers(v2, v4)
        && !CTaskComplexWanderStandard::LookForChatPartners(v2, v4) )
      {
        CTaskComplexWanderStandard::LookForSexyCars(v2, v4);
      }
    }
  }
}
// 5231E4: variables would overlap: r0.4 and r0.8

//----- (0052325C) --------------------------------------------------------
bool __fastcall CTaskComplexWanderStandard::LookForGangMembers(CTaskComplexWanderStandard *this, CPed *pPed)
{
  float32x2_t v4; // d8
  CMatrix *m_pMat; // r0
  CPedIntelligence *m_pPedIntelligence; // r5
  float32x2_t *p_tx; // r8
  int v8; // r0
  float v9; // s18
  int v10; // r4
  CPed *v11; // r6
  CMatrix *v12; // r1
  float32x2_t v13; // d16
  float32x2_t *p_m_transform; // r0
  float32x2_t v15; // d1
  float v16; // s0
  unsigned __int64 v17; // d2
  CPedGroup *PedsGroup; // r0
  CTask *ActiveTask; // r0
  CTask *v21; // r6
  int v22; // r8
  int v23; // r6
  CEventAcquaintancePed v24[3]; // [sp+0h] [bp-48h] BYREF

  if ( CPedGroups::GetPedsGroup(pPed) )
    return 0;
  CPathFind::TakeWidthIntoAccountForWandering((CVector *)v24, &ThePaths, this->m_NextNode, pPed->RandomSeed);
  v4.n64_u64[0] = *(unsigned __int64 *)&v24[0]._vptr$CEvent;
  m_pMat = pPed->m_pMat;
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  p_tx = (float32x2_t *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = (float32x2_t *)&pPed->m_transform;
  v8 = 76;
  v9 = *(float *)&v24[0].m_bIsPersistent + 1.0;
  while ( 1 )
  {
    v10 = v8;
    v11 = (CPed *)*((_DWORD *)&m_pPedIntelligence->m_pPed + v8);
    if ( v11 )
    {
      v12 = v11->m_pMat;
      v13.n64_u64[0] = vsub_f32((float32x2_t)p_tx->n64_u64[0], v4).n64_u64[0];
      p_m_transform = (float32x2_t *)&v12->tx;
      if ( !v12 )
        p_m_transform = (float32x2_t *)&v11->m_transform;
      v15.n64_u64[0] = vsub_f32((float32x2_t)p_m_transform->n64_u64[0], v4).n64_u64[0];
      v16 = p_m_transform[1].n64_f32[0] - v9;
      v17 = vmul_f32(v13, v15).n64_u64[0];
      if ( (float)((float)(*(float *)&v17 + *((float *)&v17 + 1)) + (float)((float)(p_tx[1].n64_f32[0] - v9) * v16)) > 0.0
        && (float)((float)((float)(v15.n64_f32[0] * v15.n64_f32[0]) + (float)(v15.n64_f32[1] * v15.n64_f32[1]))
                 + (float)(v16 * v16)) < 25.0 )
      {
        PedsGroup = CPedGroups::GetPedsGroup(v11);
        if ( PedsGroup )
        {
          if ( CPedGroupMembership::CountMembersExcludingLeader(&PedsGroup->m_membership) >= 1 )
            break;
        }
      }
    }
    v8 = v10 + 1;
    if ( v10 - 76 >= 15 )
      return 0;
  }
  CEventAcquaintancePed::CEventAcquaintancePed(v24, v11);
  v24[0].m_iTaskType = 940;
  v24[0]._vptr$CEvent = (int (**)(void))&off_669178;
  CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)v24, 0);
  ActiveTask = CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
  v21 = ActiveTask;
  if ( ActiveTask )
  {
    v22 = (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask);
    if ( v22 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))this->_vptr$CTask + 5))(this) )
    {
      v23 = (*((int (__fastcall **)(CTask *))v21->_vptr$CTask + 13))(v21);
      if ( v23 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))this->_vptr$CTask + 13))(this) )
        CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager)[6].m_pParent = (CTask *)(CTimer::m_snTimeInMilliseconds + 100000);
    }
  }
  CEventAcquaintancePed::~CEventAcquaintancePed(v24);
  return 1;
}
// 669178: using guessed type void *off_669178;
// 676FA8: using guessed type void *`vtable for'CEventAcquaintancePedDislike;

//----- (005233EC) --------------------------------------------------------
bool __fastcall CTaskComplexWanderStandard::LookForChatPartners(CTaskComplexWanderStandard *this, CPed *pPed)
{
  CPlayerPed *v4; // r1
  float *m_pMyVehicle; // r0
  bool v6; // zf
  bool v7; // r4
  CMatrix *m_pMat; // r0
  CPedIntelligence *m_pPedIntelligence; // r9
  CSimpleTransform *p_tx; // r1
  int v11; // r0
  int v12; // r10
  CPed *v13; // r6
  CTask *ActiveTask; // r0
  int v15; // r5
  int32 m_nPedType; // r0
  bool v17; // zf
  int32 v18; // r0
  bool v19; // zf
  float *p_xx; // r0
  const CVector *p_m_translate; // r1
  float v22; // s0
  float v23; // s2
  float v24; // s4
  CTask *v26; // r0
  CTask *v27; // r4
  int v28; // r5
  int v29; // r4
  CTask *v30; // r0
  CTask *v31; // r4
  int v32; // r5
  int v33; // r4
  CVector *vecStart; // [sp+18h] [bp-50h]
  CTaskComplexWanderStandard *v35; // [sp+1Ch] [bp-4Ch]
  CEventChatPartner v36; // [sp+20h] [bp-48h] BYREF
  CEventChatPartner v37; // [sp+30h] [bp-38h] BYREF

  if ( !SurfaceInfos_c::IsPavement(&g_surfaceInfos, pPed->m_LastMaterialToHaveBeenStandingOn) || this->m_iMoveState > 4 )
    return 0;
  v4 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v4->m_pMyVehicle;
  v6 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v6 = (*(_DWORD *)&v4->m_nPedFlags & 0x100) == 0;
  if ( !v6
    && (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) > 0.04 )
  {
    return 0;
  }
  v7 = 0;
  if ( !CStreaming::IsVeryBusy() && !CGameLogic::LaRiotsActiveHere() )
  {
    v35 = this;
    m_pMat = pPed->m_pMat;
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    vecStart = &p_tx->m_translate;
    v11 = 76;
    while ( 1 )
    {
      v12 = v11;
      v13 = (CPed *)*((_DWORD *)&m_pPedIntelligence->m_pPed + v11);
      if ( v13 )
      {
        if ( SurfaceInfos_c::IsPavement(&g_surfaceInfos, v13->m_LastMaterialToHaveBeenStandingOn) )
        {
          if ( CTaskManager::GetActiveTask(&v13->m_pPedIntelligence->m_taskManager) )
          {
            ActiveTask = CTaskManager::GetActiveTask(&v13->m_pPedIntelligence->m_taskManager);
            v15 = (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask);
            if ( v15 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))v35->_vptr$CTask + 5))(v35)
              && !CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 1204)
              && !CPedIntelligence::FindTaskByType(v13->m_pPedIntelligence, 1204)
              && !CEventGroup::GetEventOfType(&pPed->m_pPedIntelligence->m_eventGroup, 19)
              && !CEventGroup::GetEventOfType(&v13->m_pPedIntelligence->m_eventGroup, 19)
              && !CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 1215)
              && !CPedIntelligence::FindTaskByType(v13->m_pPedIntelligence, 1215) )
            {
              m_nPedType = pPed->m_nPedType;
              v17 = m_nPedType == 20;
              if ( m_nPedType != 20 )
                v17 = m_nPedType == 6;
              if ( !v17 )
              {
                v18 = v13->m_nPedType;
                v19 = v18 == 6;
                if ( v18 != 6 )
                  v19 = v18 == 20;
                if ( !v19
                  && !CPed::IsPlayer(pPed)
                  && !CPed::IsPlayer(v13)
                  && (unsigned int)(pPed->m_nPedType - 7) >= 0xA
                  && (unsigned int)(v13->m_nPedType - 7) >= 0xA
                  && CPedIntelligence::AreFriends(pPed, v13) )
                {
                  p_xx = &v13->m_pMat->xx;
                  p_m_translate = (const CVector *)(p_xx + 12);
                  if ( !p_xx )
                    p_m_translate = &v13->m_transform.m_translate;
                  v22 = p_m_translate->x - vecStart->x;
                  v23 = p_m_translate->y - vecStart->y;
                  v24 = p_m_translate->z - vecStart->z;
                  if ( (float)((float)((float)(v22 * v22) + (float)(v23 * v23)) + (float)(v24 * v24)) < 100.0
                    && (float)((float)((float)(v22 * pPed->m_pMat->xy) + (float)(v23 * pPed->m_pMat->yy))
                             + (float)(v24 * pPed->m_pMat->zy)) > 0.0
                    && (float)((float)((float)(v22 * p_xx[4]) + (float)(v23 * p_xx[5])) + (float)(v24 * p_xx[6])) < 0.0
                    && CWorld::GetIsLineOfSightClear(vecStart, p_m_translate, 1, 0, 0, 1, 0, 0, 0) )
                  {
                    break;
                  }
                }
              }
            }
          }
        }
      }
      v11 = v12 + 1;
      if ( v12 - 76 >= 15 )
        return 0;
    }
    CEventChatPartner::CEventChatPartner(&v37, 1, v13);
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v37, 0);
    CEventChatPartner::CEventChatPartner(&v36, 0, pPed);
    CEventGroup::Add(&v13->m_pPedIntelligence->m_eventGroup, (CEvent *)&v36, 0);
    v26 = CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
    v27 = v26;
    if ( v26 )
    {
      v28 = (*((int (__fastcall **)(CTask *))v26->_vptr$CTask + 5))(v26);
      if ( v28 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))v35->_vptr$CTask + 5))(v35) )
      {
        v29 = (*((int (__fastcall **)(CTask *))v27->_vptr$CTask + 13))(v27);
        if ( v29 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))v35->_vptr$CTask + 13))(v35) )
          CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager)[6].m_pParent = (CTask *)((char *)&elf_hash_chain[8526] + CTimer::m_snTimeInMilliseconds);
      }
    }
    v30 = CTaskManager::GetActiveTask(&v13->m_pPedIntelligence->m_taskManager);
    v31 = v30;
    if ( v30 )
    {
      v32 = (*((int (__fastcall **)(CTask *))v30->_vptr$CTask + 5))(v30);
      if ( v32 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))v35->_vptr$CTask + 5))(v35) )
      {
        v33 = (*((int (__fastcall **)(CTask *))v31->_vptr$CTask + 13))(v31);
        if ( v33 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))v35->_vptr$CTask + 13))(v35) )
          CTaskManager::GetActiveTask(&v13->m_pPedIntelligence->m_taskManager)[6].m_pParent = (CTask *)((char *)&elf_hash_chain[8526] + CTimer::m_snTimeInMilliseconds);
      }
    }
    CEventChatPartner::~CEventChatPartner(&v36);
    CEventChatPartner::~CEventChatPartner(&v37);
    return 1;
  }
  return v7;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (005237A8) --------------------------------------------------------
bool __fastcall CTaskComplexWanderStandard::LookForSexyCars(CTaskComplexWanderStandard *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CPedIntelligence *m_pPedIntelligence; // r6
  CSimpleTransform *p_tx; // r9
  int v6; // r0
  int v7; // r8
  CVehicle *v8; // r5
  bool v9; // zf
  CMatrix *v10; // r0
  const CVector *p_m_translate; // r1
  float v12; // s0
  float v13; // s2
  float v14; // s4
  CTask *ActiveTask; // r0
  CTask *v17; // r5
  int v18; // r6
  int v19; // r5
  CEventSexyVehicle v21; // [sp+18h] [bp-40h] BYREF

  m_pMat = pPed->m_pMat;
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v6 = 56;
  while ( 1 )
  {
    v7 = v6;
    v8 = (CVehicle *)*((_DWORD *)&m_pPedIntelligence->m_pPed + v6);
    v9 = v8 == 0;
    if ( v8 )
      v9 = pPed->m_pMyVehicle == v8;
    if ( !v9 && v8->pHandling->nMonetaryValue >= 0x9C41 && v8->m_nHealth > 500.0 )
    {
      v10 = v8->m_pMat;
      p_m_translate = (const CVector *)&v10->tx;
      if ( !v10 )
        p_m_translate = &v8->m_transform.m_translate;
      v12 = p_m_translate->x - p_tx->m_translate.x;
      v13 = p_m_translate->y - p_tx->m_translate.y;
      v14 = p_m_translate->z - p_tx->m_translate.z;
      if ( (float)((float)((float)(v12 * v12) + (float)(v13 * v13)) + (float)(v14 * v14)) < 25.0
        && (float)((float)((float)(v12 * pPed->m_pMat->xy) + (float)(v13 * pPed->m_pMat->yy))
                 + (float)(v14 * pPed->m_pMat->zy)) > 0.0
        && CWorld::GetIsLineOfSightClear(&p_tx->m_translate, p_m_translate, 1, 0, 0, 1, 0, 0, 0) )
      {
        break;
      }
    }
    v6 = v7 + 1;
    if ( v7 - 56 >= 15 )
      return 0;
  }
  CEventSexyVehicle::CEventSexyVehicle(&v21, v8);
  CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v21, 0);
  ActiveTask = CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
  v17 = ActiveTask;
  if ( ActiveTask )
  {
    v18 = (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask);
    if ( v18 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))this->_vptr$CTask + 5))(this) )
    {
      v19 = (*((int (__fastcall **)(CTask *))v17->_vptr$CTask + 13))(v17);
      if ( v19 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))this->_vptr$CTask + 13))(this) )
        CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager)[6].m_pParent = (CTask *)(CTimer::m_snTimeInMilliseconds + 100000);
    }
  }
  CEventSexyVehicle::~CEventSexyVehicle(&v21);
  return 1;
}

//----- (00523946) --------------------------------------------------------
bool __fastcall CTaskComplexWanderStandard::WillChat(
        const CTaskComplexWanderStandard *this,
        const CPed *ped,
        const CPed *otherPed)
{
  int32 m_nPedType; // r0
  bool v6; // zf
  int32 v7; // r0
  bool v8; // zf

  m_nPedType = ped->m_nPedType;
  v6 = m_nPedType == 20;
  if ( m_nPedType != 20 )
    v6 = m_nPedType == 6;
  if ( v6 )
    return 0;
  v7 = otherPed->m_nPedType;
  v8 = v7 == 6;
  if ( v7 != 6 )
    v8 = v7 == 20;
  return !v8
      && !CPed::IsPlayer(ped)
      && !CPed::IsPlayer(otherPed)
      && (unsigned int)(ped->m_nPedType - 7) >= 0xA
      && (unsigned int)(otherPed->m_nPedType - 7) >= 0xA
      && sub_19BC28(ped, otherPed);
}

//----- (0052399C) --------------------------------------------------------
void __fastcall CTaskComplexWanderStandard::SetNextMinScanTime(CTaskComplexWanderStandard *this, CPed *pPed)
{
  CTask *ActiveTask; // r0
  CTask *v5; // r6
  int v6; // r4
  int v7; // r4

  ActiveTask = CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
  v5 = ActiveTask;
  if ( ActiveTask )
  {
    v6 = (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask);
    if ( v6 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))this->_vptr$CTask + 5))(this) )
    {
      v7 = (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 13))(v5);
      if ( v7 == (*((int (__fastcall **)(CTaskComplexWanderStandard *))this->_vptr$CTask + 13))(this) )
        CTaskManager::GetActiveTask(&pPed->m_pPedIntelligence->m_taskManager)[6].m_pParent = (CTask *)(CTimer::m_snTimeInMilliseconds + 100000);
    }
  }
}

//----- (00523A08) --------------------------------------------------------
void __fastcall CTaskComplexWanderStandard::SetNextScanTime(CTaskComplexWanderStandard *this, int32 time)
{
  this->m_iMinNextScanTime = time;
}

//----- (00523A0C) --------------------------------------------------------
bool __fastcall CTaskComplexWanderCop::ShouldPursuePlayer(const CTaskComplexWanderCop *this, CPed *pPed)
{
  CTask *m_pSubTask; // r0
  CWanted *PlayerWanted; // r0

  if ( FindPlayerWanted(-1)->m_WantedLevel < WANTED_LEVEL1 )
    return 0;
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask )
  {
    if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 1103 )
      return 0;
  }
  PlayerWanted = FindPlayerWanted(-1);
  return sub_192824(PlayerWanted, (CCopPed *)pPed);
}

//----- (00523A4A) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderCop::CreateFirstSubTask(CTaskComplexWanderCop *this, CPed *pPed)
{
  CTaskSimpleStandStill *v4; // r0
  CTask *result; // r0
  CTask *m_pSubTask; // r0
  CWanted *PlayerWanted; // r0
  CTaskComplexPolicePursuit *v8; // r0
  CTask *m_pTaskToPerform; // r0
  int v10; // r2

  if ( pPed->m_nPedType != 6 )
    goto LABEL_17;
  if ( LOBYTE(pPed[1]._vptr$CPlaceable) )
  {
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v4, (const int)&elf_hash_chain[8526], 1, 0, 8.0);
    return result;
  }
  if ( FindPlayerWanted(-1)->m_WantedLevel >= WANTED_LEVEL1 )
  {
    m_pSubTask = this->m_pSubTask;
    if ( !m_pSubTask || (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 1103 )
    {
      PlayerWanted = FindPlayerWanted(-1);
      if ( CWanted::CanCopJoinPursuit(PlayerWanted, (CCopPed *)pPed) )
      {
        v8 = (CTaskComplexPolicePursuit *)CTask::operator new(0x18u);
        CTaskComplexPolicePursuit::CTaskComplexPolicePursuit(v8);
        return result;
      }
    }
  }
  m_pTaskToPerform = this->m_pTaskToPerform;
  if ( m_pTaskToPerform )
    return (CTask *)(*((int (__fastcall **)(CTask *))m_pTaskToPerform->_vptr$CTask + 2))(m_pTaskToPerform);
LABEL_17:
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v10 = 704;
  }
  else
  {
    (*((void (__fastcall **)(CTaskComplexWanderCop *, CPed *))this->_vptr$CTask + 15))(this, pPed);
    (*((void (__fastcall **)(CTaskComplexWanderCop *, CPed *, _DWORD, CNodeAddress *, CNodeAddress *, UINT8 *))this->_vptr$CTask
     + 16))(
      this,
      pPed,
      this->m_iDir,
      &this->m_LastNode,
      &this->m_NextNode,
      &this->m_iDir);
    v10 = 900;
  }
  return CTaskComplexWander::CreateSubTask(this, pPed, v10);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00523B2C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderCop::CreateNextSubTask(CTaskComplexWanderCop *this, CPed *pPed)
{
  CTask *m_pTaskToPerform; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r6

  if ( pPed->m_nPedType != 6 )
    return CTaskComplexWander::CreateNextSubTask(this, pPed);
  if ( LOBYTE(pPed[1]._vptr$CPlaceable) )
    return 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexWander::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1103 )
  {
    if ( this->m_pTaskToPerform )
    {
      v8 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexWander::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
      if ( v8 == (*((int (__fastcall **)(CTask *))this->m_pTaskToPerform->_vptr$CTask + 5))(this->m_pTaskToPerform) )
        return 0;
      m_pTaskToPerform = this->m_pTaskToPerform;
      if ( m_pTaskToPerform )
        return (CTask *)(*((int (__fastcall **)(CTask *))m_pTaskToPerform->_vptr$CTask + 2))(m_pTaskToPerform);
    }
    return CTaskComplexWander::CreateNextSubTask(this, pPed);
  }
  m_pTaskToPerform = this->m_pTaskToPerform;
  v6 = CTimer::m_snTimeInMilliseconds;
  this->m_pursuitWaitTimer.m_bIsActive = 1;
  this->m_pursuitWaitTimer.m_iStartTime = v6;
  this->m_pursuitWaitTimer.m_iDuration = 3000;
  if ( m_pTaskToPerform )
    return (CTask *)(*((int (__fastcall **)(CTask *))m_pTaskToPerform->_vptr$CTask + 2))(m_pTaskToPerform);
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v7 = 704;
  }
  else
  {
    (*((void (__fastcall **)(CTaskComplexWanderCop *, CPed *))this->_vptr$CTask + 15))(this, pPed);
    (*((void (__fastcall **)(CTaskComplexWanderCop *, CPed *, _DWORD, CNodeAddress *, CNodeAddress *, UINT8 *))this->_vptr$CTask
     + 16))(
      this,
      pPed,
      this->m_iDir,
      &this->m_LastNode,
      &this->m_NextNode,
      &this->m_iDir);
    v7 = 900;
  }
  return CTaskComplexWander::CreateSubTask(this, pPed, v7);
}

//----- (00523C10) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderCop::ControlSubTask(CTaskComplexWanderCop *this, CPed *pPed)
{
  CTaskComplexPolicePursuit *m_pSubTask; // r4
  CTask *v5; // r0
  CWanted *PlayerWanted; // r0
  unsigned int v7; // r0
  int m_iStartTime; // r1

  if ( pPed->m_nPedType != 6 )
    return CTaskComplexWander::ControlSubTask(this, pPed);
  m_pSubTask = (CTaskComplexPolicePursuit *)this->m_pSubTask;
  if ( FindPlayerWanted(-1)->m_WantedLevel >= WANTED_LEVEL1 )
  {
    v5 = this->m_pSubTask;
    if ( !v5 || (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 5))(v5) != 1103 )
    {
      PlayerWanted = FindPlayerWanted(-1);
      if ( CWanted::CanCopJoinPursuit(PlayerWanted, (CCopPed *)pPed) )
      {
        if ( !this->m_pursuitWaitTimer.m_bIsActive
          || (!this->m_pursuitWaitTimer.m_bIsStopped ? (m_iStartTime = this->m_pursuitWaitTimer.m_iStartTime,
                                                        v7 = CTimer::m_snTimeInMilliseconds) : (v7 = CTimer::m_snTimeInMilliseconds,
                                                                                                this->m_pursuitWaitTimer.m_bIsStopped = 0,
                                                                                                this->m_pursuitWaitTimer.m_iStartTime = v7,
                                                                                                m_iStartTime = v7),
              m_iStartTime + this->m_pursuitWaitTimer.m_iDuration <= v7) )
        {
          if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplexWander::CTaskComplex::_vptr$CTask
                + 7))(
                 this->m_pSubTask,
                 pPed,
                 1,
                 0) == 1 )
          {
            m_pSubTask = (CTaskComplexPolicePursuit *)CTask::operator new(0x18u);
            CTaskComplexPolicePursuit::CTaskComplexPolicePursuit(m_pSubTask);
          }
        }
        return m_pSubTask;
      }
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexWander::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1103 )
  {
    if ( this->m_pTaskToPerform )
      return m_pSubTask;
    return CTaskComplexWander::ControlSubTask(this, pPed);
  }
  return this->m_pSubTask;
}

//----- (00523CE0) --------------------------------------------------------
void __fastcall CTaskComplexWanderCop::ScanForStuff(CTaskComplexWanderCop *this, CPed *pPed)
{
  int v4; // r0
  bool v5; // zf
  __int64 v6; // r0
  CPlayerPed *PlayerPed; // r0

  if ( !this->m_timer.m_bIsActive )
  {
    *(_QWORD *)&this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0x3200000000LL;
    this->m_timer.m_bIsActive = 1;
  }
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexWander::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = v4 == 1103;
  if ( v4 != 1103 )
    v5 = this->m_timer.m_bIsActive == 0;
  if ( !v5 )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      LODWORD(v6) = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v6;
      HIDWORD(v6) = v6;
    }
    else
    {
      HIDWORD(v6) = this->m_timer.m_iStartTime;
      LODWORD(v6) = CTimer::m_snTimeInMilliseconds;
    }
    if ( HIDWORD(v6) + this->m_timer.m_iDuration <= (unsigned int)v6 )
    {
      HIDWORD(v6) = 50;
      *(_QWORD *)&this->m_timer.m_iStartTime = v6;
      HIDWORD(v6) = this->m_iMinNextCrimeScanTime;
      this->m_timer.m_bIsActive = 1;
      if ( (unsigned int)v6 >= HIDWORD(v6) )
      {
        CTaskComplexWanderCop::LookForCarAlarms((CTaskComplexWanderCop *)v6, pPed);
        if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN
          && FindPlayerPed(-1)->m_pMyVehicle
          && *(_BYTE *)&FindPlayerPed(-1)->m_pMyVehicle->m_nVehicleFlags << 31 )
        {
          PlayerPed = FindPlayerPed(-1);
          CPlayerPed::SetWantedLevelNoDrop(PlayerPed, 1);
        }
      }
      if ( CTimer::m_snTimeInMilliseconds >= this->m_iMinNextCriminalScanTime )
        CTaskComplexWanderCop::LookForCriminals(this, pPed);
    }
  }
}

//----- (00523DD0) --------------------------------------------------------
void __fastcall CTaskComplexWanderCop::LookForCarAlarms(CTaskComplexWanderCop *this, CPed *pPed)
{
  CVehicle *PlayerVehicle; // r0
  int CarAlarmState; // r1
  bool v5; // zf
  CVehicle *v6; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v8; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  CPlayerPed *PlayerPed; // r0

  if ( FindPlayerVehicle(-1, 0) && !FindPlayerVehicle(-1, 0)->m_baseVehicleType )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    CarAlarmState = PlayerVehicle->CarAlarmState;
    v5 = CarAlarmState == 0;
    if ( PlayerVehicle->CarAlarmState )
      v5 = CarAlarmState == 0xFFFF;
    if ( !v5 && (*(_BYTE *)&PlayerVehicle->m_info & 0xF8) != 40 )
    {
      v6 = FindPlayerVehicle(-1, 0);
      m_pMat = v6->m_pMat;
      v8 = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v6->m_transform;
      p_m_transform = (CSimpleTransform *)&v8->tx;
      if ( !v8 )
        p_m_transform = &pPed->m_transform;
      v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
      v12 = vmul_f32(v11, v11).n64_u64[0];
      if ( (float)((float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                                 * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                         + *(float *)&v12)
                 + *((float *)&v12 + 1)) < 400.0 )
      {
        PlayerPed = FindPlayerPed(-1);
        sub_190E14(PlayerPed, 1);
      }
    }
  }
}

//----- (00523E90) --------------------------------------------------------
void __fastcall CTaskComplexWanderCop::LookForStolenCopCars(CTaskComplexWanderCop *this, CPed *pPed)
{
  CPlayerPed *PlayerPed; // r0

  if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN && FindPlayerPed(-1)->m_pMyVehicle )
  {
    if ( *(_BYTE *)&FindPlayerPed(-1)->m_pMyVehicle->m_nVehicleFlags << 31 )
    {
      PlayerPed = FindPlayerPed(-1);
      sub_190E14(PlayerPed, 1);
    }
  }
}

//----- (00523EE0) --------------------------------------------------------
bool __fastcall CTaskComplexWanderCop::LookForCriminals(CTaskComplexWanderCop *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CPedIntelligence *m_pPedIntelligence; // r4
  CSimpleTransform *p_tx; // r9
  int v7; // r0
  int v8; // r11
  CPed *v9; // r6
  unsigned int m_nPedType; // r0
  bool v11; // cc
  CTask *ActiveTask; // r0
  int v13; // r5
  CMatrix *v14; // r0
  const CVector *p_m_translate; // r1
  float v16; // s0
  float v17; // s2
  float v18; // s4
  uint32 v20; // r0
  CEventPedToFlee v21; // [sp+18h] [bp-48h] BYREF
  CEventPedToChase v22; // [sp+28h] [bp-38h] BYREF

  m_pMat = pPed->m_pMat;
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v7 = 76;
  while ( 1 )
  {
    v8 = v7;
    v9 = (CPed *)*((_DWORD *)&m_pPedIntelligence->m_pPed + v7);
    if ( v9 )
    {
      m_nPedType = v9->m_nPedType;
      v11 = m_nPedType > 0x14;
      if ( m_nPedType != 20 )
        v11 = m_nPedType - 7 > 9;
      if ( !v11 && this->m_pLastPed != v9 )
      {
        if ( CTaskManager::GetActiveTask(&v9->m_pPedIntelligence->m_taskManager) )
        {
          ActiveTask = CTaskManager::GetActiveTask(&v9->m_pPedIntelligence->m_taskManager);
          v13 = (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask);
          if ( v13 == (*((int (__fastcall **)(CTaskComplexWanderCop *))this->_vptr$CTask + 5))(this) )
          {
            v14 = v9->m_pMat;
            p_m_translate = (const CVector *)&v14->tx;
            if ( !v14 )
              p_m_translate = &v9->m_transform.m_translate;
            v16 = p_m_translate->x - p_tx->m_translate.x;
            v17 = p_m_translate->y - p_tx->m_translate.y;
            v18 = p_m_translate->z - p_tx->m_translate.z;
            if ( (float)((float)((float)(v16 * v16) + (float)(v17 * v17)) + (float)(v18 * v18)) < 100.0
              && (float)((float)((float)(v16 * pPed->m_pMat->xy) + (float)(v17 * pPed->m_pMat->yy))
                       + (float)(v18 * pPed->m_pMat->zy)) > 0.0
              && CWorld::GetIsLineOfSightClear(&p_tx->m_translate, p_m_translate, 1, 0, 0, 1, 0, 0, 0) )
            {
              break;
            }
          }
        }
      }
    }
    v7 = v8 + 1;
    if ( v8 - 76 >= 15 )
      return 0;
  }
  CEventPedToChase::CEventPedToChase(&v22, v9);
  CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v22, 0);
  CEventPedToFlee::CEventPedToFlee(&v21, pPed);
  CEventGroup::Add(&v9->m_pPedIntelligence->m_eventGroup, &v21, 0);
  v20 = CTimer::m_snTimeInMilliseconds;
  this->m_pLastPed = v9;
  this->m_iMinNextCriminalScanTime = v20 + 30000;
  CEventPedToFlee::~CEventPedToFlee(&v21);
  CEventPedToChase::~CEventPedToChase(&v22);
  return 1;
}

//----- (00524074) --------------------------------------------------------
void __fastcall CTaskComplexWanderCriminal::ScanForStuff(CTaskComplexWanderCriminal *this, CPed *pPed)
{
  uint32 v4; // r6
  int v5; // s0
  int m_bIsActive; // r0
  __int64 v7; // r0

  if ( this->m_timer.m_bIsActive
    || (v4 = CTimer::m_snTimeInMilliseconds,
        this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds,
        this->m_timer.m_iDuration = 50,
        this->m_timer.m_bIsActive = 1,
        v5 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 30000.0),
        m_bIsActive = this->m_timer.m_bIsActive,
        this->m_iMinNextStealCarScanTime = v5 + v4,
        m_bIsActive) )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      LODWORD(v7) = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v7;
      HIDWORD(v7) = v7;
    }
    else
    {
      HIDWORD(v7) = this->m_timer.m_iStartTime;
      LODWORD(v7) = CTimer::m_snTimeInMilliseconds;
    }
    if ( HIDWORD(v7) + this->m_timer.m_iDuration <= (unsigned int)v7 )
    {
      HIDWORD(v7) = 50;
      *(_QWORD *)&this->m_timer.m_iStartTime = v7;
      HIDWORD(v7) = this->m_iMinNextStealCarScanTime;
      this->m_timer.m_bIsActive = 1;
      if ( (unsigned int)v7 >= HIDWORD(v7) )
        CTaskComplexWanderCriminal::LookForCarsToSteal(this, pPed);
    }
  }
}

//----- (00524134) --------------------------------------------------------
void __fastcall CTaskComplexWanderCriminal::LookForCarsToSteal(CTaskComplexWanderCriminal *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d8
  CPedIntelligence *m_pPedIntelligence; // r11
  int v7; // r4
  CVehicle *v8; // r9
  CPed **v9; // r0
  int v10; // r5
  CVehicle *v11; // r6
  CMatrix *m_pMat; // r0
  CMatrix *v13; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v16; // d16
  unsigned __int64 v17; // d1
  bool v18; // nf
  CEventVehicleToSteal v20[3]; // [sp+0h] [bp-38h] BYREF

  v3.n64_u32[0] = 2139095039;
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  v7 = 0;
  v8 = 0;
  do
  {
    while ( 1 )
    {
      v9 = &m_pPedIntelligence->m_pPed + v7;
      v10 = v7 + 1;
      v11 = (CVehicle *)v9[56];
      if ( v11 )
      {
        if ( CCarEnterExit::IsVehicleStealable((const CVehicle *)v9[56], pPed) )
          break;
      }
      ++v7;
      if ( v10 - 1 >= 15 )
        goto LABEL_13;
    }
    m_pMat = v11->m_pMat;
    v13 = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v11->m_transform;
    p_m_transform = (CSimpleTransform *)&v13->tx;
    if ( !v13 )
      p_m_transform = &pPed->m_transform;
    v16.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v17 = vmul_f32(v16, v16).n64_u64[0];
    v2.n64_f32[0] = (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                  * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                          + *(float *)&v17)
                  + *((float *)&v17 + 1);
    v18 = v2.n64_f32[0] < v3.n64_f32[0];
    v3.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
    if ( v18 )
      v8 = v11;
  }
  while ( v7++ < 15 );
LABEL_13:
  if ( v8 )
  {
    this->m_iMinNextStealCarScanTime = CTimer::m_snTimeInMilliseconds + 30000;
    if ( (float)((float)((float)rand() * 4.6566e-10) + 0.0) < 0.2 )
    {
      CEventVehicleToSteal::CEventVehicleToSteal(v20, v8);
      CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, v20, 0);
      CEventVehicleToSteal::~CEventVehicleToSteal(v20);
    }
  }
}
// 5241BA: variable 'v2' is possibly undefined
// 5241BA: variable 'v3' is possibly undefined
// 524248: using guessed type int **off_524248;

//----- (00524258) --------------------------------------------------------
void __fastcall CTaskComplexWanderProstitute::CTaskComplexWanderProstitute(
        CTaskComplexWanderProstitute *this,
        const int iMoveState,
        const UINT8 iDir,
        const bool bWanderSensibly)
{
  int v7; // r0
  char v8; // r2

  CTaskComplex::CTaskComplex(this);
  *(_BYTE *)(v7 + 16) = iDir;
  *(_DWORD *)(v7 + 12) = iMoveState;
  *(_DWORD *)(v7 + 20) = 1056964608;
  *(_WORD *)(v7 + 24) = -1;
  *(_WORD *)(v7 + 28) = -1;
  v8 = *(_BYTE *)(v7 + 36) & 0xF0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_WORD *)(v7 + 48) = 0;
  *(_DWORD *)(v7 + 52) = 0;
  *(_DWORD *)(v7 + 56) = 0;
  *(_DWORD *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_BYTE *)(v7 + 36) = v8 | bWanderSensibly;
  *(_DWORD *)v7 = &off_66C368;
}
// 524270: variable 'v7' is possibly undefined
// 66C368: using guessed type void *off_66C368;

//----- (005242AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderProstitute::CreateFirstSubTask(CTaskComplexWanderProstitute *this, CPed *pPed)
{
  int v4; // r2

  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v4 = 704;
  }
  else
  {
    (*((void (__fastcall **)(CTaskComplexWanderProstitute *, CPed *))this->_vptr$CTask + 15))(this, pPed);
    (*((void (__fastcall **)(CTaskComplexWanderProstitute *, CPed *, _DWORD, CNodeAddress *, CNodeAddress *, UINT8 *))this->_vptr$CTask
     + 16))(
      this,
      pPed,
      this->m_iDir,
      &this->m_LastNode,
      &this->m_NextNode,
      &this->m_iDir);
    v4 = 900;
  }
  return CTaskComplexWander::CreateSubTask(this, pPed, v4);
}

//----- (00524308) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTaskComplexWanderProstitute::ScanForStuff(CTaskComplexWanderProstitute *this, CPed *pPed)
{
  CTaskComplexWanderProstitute *v2; // r5
  CPed *v3; // r1
  CPed *v4; // r4
  int v5; // r1
  CTaskComplexWanderProstitute *v6; // r1
  int m_iStartTime; // r1
  int v8; // r1
  int v9; // r1
  CPedIntelligence *m_pPedIntelligence; // r0
  CPed *v11; // r5
  CEntity *v12; // r1
  CEntity *v13; // r1
  CEntity *v14; // r1
  CEntity *v15; // r1
  CEntity *v16; // r1
  CEntity *v17; // r1
  CEntity *v18; // r1
  CEntity *v19; // r1
  CEntity *v20; // r1
  CEntity *v21; // r1
  CEntity *v22; // r1
  CEntity *v23; // r1
  CEntity *v24; // r1
  CEntity *v25; // r1
  CEntity *v26; // r1
  CEntity **v27; // r10
  CEventGroup *p_m_eventGroup; // r9
  CPlayerPedData *m_pPlayerData; // r0
  int i; // r6
  bool v31; // zf
  CVehicle *m_pMyVehicle; // r1
  bool v33; // zf
  float v34; // s0
  CVehicle *v35; // r0
  float32x2_t v36; // d16
  unsigned __int64 v37; // d1
  CEventAcquaintancePed v38[4]; // [sp+4h] [bp-5Ch] BYREF

  v2 = this;
  v4 = v3;
  this = (CTaskComplexWanderProstitute *)CTimer::m_snTimeInMilliseconds;
  if ( !v2->m_timer.m_bIsActive )
  {
    v5 = 50;
    *(_QWORD *)&v2->m_timer.m_iStartTime = *(_QWORD *)&this;
    v2->m_timer.m_bIsActive = 1;
  }
  if ( (unsigned int)this >= v2->m_iMinNextScanTime )
  {
    if ( v2->m_timer.m_bIsStopped )
    {
      v2->m_timer.m_bIsStopped = 0;
      v6 = this;
      v2->m_timer.m_iStartTime = (int)this;
    }
    else
    {
      m_iStartTime = v2->m_timer.m_iStartTime;
    }
    if ( v8 + v2->m_timer.m_iDuration <= (unsigned int)this )
    {
      v9 = 50;
      *(_QWORD *)&v2->m_timer.m_iStartTime = *(_QWORD *)&this;
      v2->m_timer.m_bIsActive = 1;
      if ( !CTaskComplexWanderStandard::LookForGangMembers(v2, v4)
        && !CTaskComplexWanderStandard::LookForChatPartners(v2, v4) )
      {
        CTaskComplexWanderStandard::LookForSexyCars(v2, v4);
      }
    }
  }
  if ( CTimer::m_snTimeInMilliseconds > v2->m_iTimeToNextScanForPunters )
  {
    v2->m_iTimeToNextScanForPunters = CTimer::m_snTimeInMilliseconds + 2000;
    m_pPedIntelligence = v4->m_pPedIntelligence;
    v11 = (CPed *)m_pPedIntelligence->m_pedScanner.m_entities[0];
    if ( !v11 || v11->m_nPedType != 6 )
    {
      v12 = m_pPedIntelligence->m_pedScanner.m_entities[1];
      if ( !v12 || *(_DWORD *)&v12[23].numLodChildren != 6 )
      {
        v13 = m_pPedIntelligence->m_pedScanner.m_entities[2];
        if ( !v13 || *(_DWORD *)&v13[23].numLodChildren != 6 )
        {
          v14 = m_pPedIntelligence->m_pedScanner.m_entities[3];
          if ( !v14 || *(_DWORD *)&v14[23].numLodChildren != 6 )
          {
            v15 = m_pPedIntelligence->m_pedScanner.m_entities[4];
            if ( !v15 || *(_DWORD *)&v15[23].numLodChildren != 6 )
            {
              v16 = m_pPedIntelligence->m_pedScanner.m_entities[5];
              if ( !v16 || *(_DWORD *)&v16[23].numLodChildren != 6 )
              {
                v17 = m_pPedIntelligence->m_pedScanner.m_entities[6];
                if ( !v17 || *(_DWORD *)&v17[23].numLodChildren != 6 )
                {
                  v18 = m_pPedIntelligence->m_pedScanner.m_entities[7];
                  if ( !v18 || *(_DWORD *)&v18[23].numLodChildren != 6 )
                  {
                    v19 = m_pPedIntelligence->m_pedScanner.m_entities[8];
                    if ( !v19 || *(_DWORD *)&v19[23].numLodChildren != 6 )
                    {
                      v20 = m_pPedIntelligence->m_pedScanner.m_entities[9];
                      if ( !v20 || *(_DWORD *)&v20[23].numLodChildren != 6 )
                      {
                        v21 = m_pPedIntelligence->m_pedScanner.m_entities[10];
                        if ( !v21 || *(_DWORD *)&v21[23].numLodChildren != 6 )
                        {
                          v22 = m_pPedIntelligence->m_pedScanner.m_entities[11];
                          if ( !v22 || *(_DWORD *)&v22[23].numLodChildren != 6 )
                          {
                            v23 = m_pPedIntelligence->m_pedScanner.m_entities[12];
                            if ( !v23 || *(_DWORD *)&v23[23].numLodChildren != 6 )
                            {
                              v24 = m_pPedIntelligence->m_pedScanner.m_entities[13];
                              if ( !v24 || *(_DWORD *)&v24[23].numLodChildren != 6 )
                              {
                                v25 = m_pPedIntelligence->m_pedScanner.m_entities[14];
                                if ( !v25 || *(_DWORD *)&v25[23].numLodChildren != 6 )
                                {
                                  v26 = m_pPedIntelligence->m_pedScanner.m_entities[15];
                                  if ( !v26 || *(_DWORD *)&v26[23].numLodChildren != 6 )
                                  {
                                    v27 = &m_pPedIntelligence->m_pedScanner.m_entities[1];
                                    p_m_eventGroup = &m_pPedIntelligence->m_eventGroup;
                                    m_pPlayerData = (CPlayerPedData *)&`vtable for'CEventAcquaintancePedRespect;
                                    for ( i = 0; ; ++i )
                                    {
                                      v31 = v11 == 0;
                                      if ( v11 )
                                      {
                                        m_pPlayerData = v11->m_pPlayerData;
                                        v31 = m_pPlayerData == 0;
                                      }
                                      if ( !v31 )
                                      {
                                        m_pMyVehicle = v11->m_pMyVehicle;
                                        v33 = m_pMyVehicle == 0;
                                        if ( m_pMyVehicle )
                                          v33 = m_pPlayerData->m_pLastProstituteShagged == v4;
                                        if ( !v33 )
                                        {
                                          v34 = (float)(unsigned __int16)rand();
                                          v35 = v11->m_pMyVehicle;
                                          if ( v35->pHandling->nMonetaryValue > (int)(float)((float)(v34 * 0.000015259)
                                                                                           * 50000.0) )
                                          {
                                            v36.n64_u64[0] = vmul_f32(
                                                               *(float32x2_t *)&v35->m_vecMoveSpeed.y,
                                                               (float32x2_t)0x4248000042480000LL).n64_u64[0];
                                            v37 = vmul_f32(v36, v36).n64_u64[0];
                                            if ( (float)((float)((float)((float)(v35->m_vecMoveSpeed.x * 50.0)
                                                                       * (float)(v35->m_vecMoveSpeed.x * 50.0))
                                                               + *(float *)&v37)
                                                       + *((float *)&v37 + 1)) < 4.0
                                              && CTaskComplexProstituteSolicit::IsTaskValid(v4, v11) )
                                            {
                                              CEventAcquaintancePed::CEventAcquaintancePed(v38, v11);
                                              v38[0].m_iTaskType = 1309;
                                              v38[0]._vptr$CEvent = (int (**)(void))&off_6690D8;
                                              CEventGroup::Add(p_m_eventGroup, (CEvent *)v38, 0);
                                              CEventAcquaintancePed::~CEventAcquaintancePed(v38);
                                            }
                                          }
                                        }
                                      }
                                      if ( i == 15 )
                                        break;
                                      m_pPlayerData = (CPlayerPedData *)(i + 1);
                                      v11 = (CPed *)v27[i];
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
// 524308: variables would overlap: r0.4 and r0.8
// 6690D8: using guessed type void *off_6690D8;
// 676A4C: using guessed type void *`vtable for'CEventAcquaintancePedRespect;

//----- (005245B4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTaskComplexGoToAttractor::CTaskComplexGoToAttractor(
        CTaskComplexGoToAttractor *this,
        CPedAttractor *pAttractor,
        const CVector *vAttractPos,
        const float fAttractHeading,
        const float fAttractTime,
        const int iSlot,
        const int iMoveState)
{
  int v10; // r0
  __int64 v11; // d16

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v10 + 12) = pAttractor;
  *(_DWORD *)v10 = &off_66C3B4;
  v11 = *(_QWORD *)&vAttractPos->x;
  *(RwReal *)(v10 + 24) = vAttractPos->z;
  *(const float *)(v10 + 28) = fAttractHeading;
  *(const float *)(v10 + 32) = fAttractTime;
  *(_QWORD *)(v10 + 36) = *(_QWORD *)&iSlot;
  *(_QWORD *)(v10 + 16) = v11;
}
// 5245B4: variables would overlap: ^1C.4 and ^1C.8
// 66C3B4: using guessed type void *;

//----- (00524600) --------------------------------------------------------
void __fastcall CTaskComplexGoToAttractor::~CTaskComplexGoToAttractor(CTaskComplexGoToAttractor *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52460C: variable 'v1' is possibly undefined

//----- (00524610) --------------------------------------------------------
bool __fastcall CTaskComplexGoToAttractor::MakeAbortable(
        CTaskComplexGoToAttractor *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (0052461C) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToAttractor::CreateNextSubTask(CTaskComplexGoToAttractor *this, CPed *pPed)
{
  CPedAttractorManager *PedAttractorManager; // r0

  PedAttractorManager = GetPedAttractorManager();
  CPedAttractorManager::BroadcastArrival(PedAttractorManager, pPed, this->m_pAttractor);
  if ( (*((_BYTE *)&pPed->m_nPedFlags + 10) & 0x20) != 0 && CPedAttractor::GetHeadOfQueue(this->m_pAttractor) != pPed )
    *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x200000u;
  return 0;
}

//----- (00524654) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToAttractor::CreateFirstSubTask(CTaskComplexGoToAttractor *this, CPed *pPed)
{
  int m_iMoveState; // r9
  int v5; // r8
  CTaskSimpleStandStill *v6; // r5
  void *v7; // r6
  CVector *p_m_vAttractPos; // r8
  float v9; // s0
  char v10; // r0
  __int64 v11; // d16
  CTaskSimpleAnim *v12; // r0
  float m_fAttractHeading; // r9
  CTaskSimpleAnim *v14; // r6
  char m_pAnim; // r1
  __int64 v16; // d16
  __int64 v17; // kr00_8
  CMatrix *m_pMat; // r3
  RwReal z; // r0
  float *p_tz; // r1

  m_iMoveState = this->m_iMoveState;
  v5 = ((int (__fastcall *)(CPedAttractor *))*this->m_pAttractor->_vptr$CPedAttractor)(this->m_pAttractor);
  if ( (*((_BYTE *)&pPed->m_nPedFlags + 10) & 0x20) != 0 )
  {
    CPedPlacement::FindZCoorForPed(&this->m_vAttractPos);
    v17 = *(_QWORD *)&this->m_vAttractPos.x;
    m_pMat = pPed->m_pMat;
    z = this->m_vAttractPos.z;
    if ( m_pMat )
    {
      LODWORD(m_pMat->tx) = v17;
      pPed->m_pMat->ty = *((float *)&v17 + 1);
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      *(_QWORD *)&pPed->m_transform.m_translate.x = v17;
      p_tz = &pPed->m_transform.m_translate.z;
    }
    *p_tz = z;
    pPed->m_fDesiredHeading = this->m_fAttractHeading;
    pPed->m_fCurrentHeading = this->m_fAttractHeading;
    v6 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v6, 0, 0, 0, 8.0);
  }
  else
  {
    v6 = (CTaskSimpleStandStill *)CTask::operator new(0x40u);
    CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v6);
    v7 = CTask::operator new(0x28u);
    CTaskComplex::CTaskComplex((CTaskComplex *)v7);
    if ( v5 == 4 )
      m_iMoveState = 6;
    p_m_vAttractPos = &this->m_vAttractPos;
    *((_DWORD *)v7 + 3) = m_iMoveState;
    *(_DWORD *)v7 = &off_66C13C;
    v9 = *((float *)v7 + 4);
    v10 = *((_BYTE *)v7 + 36) & 0xE4;
    *((_BYTE *)v7 + 36) = v10;
    if ( v9 != this->m_vAttractPos.x
      || *((float *)v7 + 5) != this->m_vAttractPos.y
      || *((float *)v7 + 6) != this->m_vAttractPos.z
      || *((float *)v7 + 8) != 2.0 )
    {
      v11 = *(_QWORD *)&p_m_vAttractPos->x;
      *((_DWORD *)v7 + 6) = LODWORD(this->m_vAttractPos.z);
      *((_QWORD *)v7 + 2) = v11;
      *((_DWORD *)v7 + 7) = 1056964608;
      *((_DWORD *)v7 + 8) = 0x40000000;
      *((_BYTE *)v7 + 36) = v10 | 4;
    }
    CTaskComplexSequence::AddTask((CTaskComplexSequence *)v6, (CTask *)v7);
    v12 = (CTaskSimpleAnim *)CTask::operator new(0x80u);
    m_fAttractHeading = this->m_fAttractHeading;
    v14 = v12;
    CTaskSimpleAnim::CTaskSimpleAnim(v12, 0);
    v14->_vptr$CTask = (int (**)(void))&off_66C4E0;
    *((_WORD *)&v14[4] + 6) = 0;
    v14[4].m_pParent = 0;
    v14[4].m_pAnim = 0;
    m_pAnim = (char)v14[7].m_pAnim;
    v16 = *(_QWORD *)&p_m_vAttractPos->x;
    *((_DWORD *)&v14[6] + 3) = LODWORD(this->m_vAttractPos.z);
    *(float *)&v14[7]._vptr$CTask = m_fAttractHeading;
    v14[7].m_pParent = (CTask *)1056964608;
    *(_QWORD *)&v14[6].m_pParent = v16;
    LOBYTE(v14[7].m_pAnim) = m_pAnim & 0xFC | 1;
    CTaskComplexSequence::AddTask((CTaskComplexSequence *)v6, v14);
  }
  return v6;
}
// 66C13C: using guessed type void *off_66C13C;
// 66C4E0: using guessed type void *off_66C4E0;

//----- (005247E8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToAttractor::ControlSubTask(CTaskComplexGoToAttractor *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (005247EC) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAnyMeans::CTaskComplexGoToPointAnyMeans(
        CTaskComplexGoToPointAnyMeans *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fTargetRadius,
        const int iDesiredCarModel)
{
  int v8; // r0
  __int64 v9; // d16

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)v8 = &off_66C3F0;
  v9 = *(_QWORD *)&vTarget->x;
  *(RwReal *)(v8 + 20) = vTarget->z;
  *(_DWORD *)(v8 + 24) = iMoveState;
  *(const float *)(v8 + 28) = fTargetRadius;
  *(_DWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 36) = (unsigned int)iDesiredCarModel;
  *(_DWORD *)(v8 + 44) = 0;
  *(_WORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 12) = v9;
}
// 52480A: variable 'v8' is possibly undefined
// 66C3F0: using guessed type void *off_66C3F0;

//----- (00524830) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAnyMeans::CTaskComplexGoToPointAnyMeans(
        CTaskComplexGoToPointAnyMeans *this,
        const int iMoveState,
        const CVector *vTarget,
        CVehicle *pTargetVehicle,
        const float fTargetRadius,
        const int iDesiredCarModel)
{
  __int64 v10; // d16
  RwReal z; // r2

  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66C3F0;
  v10 = *(_QWORD *)&vTarget->x;
  z = vTarget->z;
  this->m_pTargetVehicle = pTargetVehicle;
  this->m_vTarget.z = z;
  this->m_iMoveState = iMoveState;
  this->m_fTargetRadius = fTargetRadius;
  this->m_iDesiredCarModel = iDesiredCarModel;
  this->m_forceMakeCarTimer.m_iStartTime = 0;
  this->m_forceMakeCarTimer.m_iDuration = 0;
  *(_QWORD *)&this->m_vTarget.x = v10;
  *(_WORD *)&this->m_forceMakeCarTimer.m_bIsActive = 0;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66C3F0: using guessed type void *;

//----- (00524890) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAnyMeans::~CTaskComplexGoToPointAnyMeans(CTaskComplexGoToPointAnyMeans *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66C3F0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66C3F0: using guessed type void *off_66C3F0;

//----- (005248BC) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAnyMeans::~CTaskComplexGoToPointAnyMeans(CTaskComplexGoToPointAnyMeans *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66C3F0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5248E4: variable 'v4' is possibly undefined
// 66C3F0: using guessed type void *off_66C3F0;

//----- (005248EC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAnyMeans::CreateNextSubTask(CTaskComplexGoToPointAnyMeans *this, CPed *pPed)
{
  int v4; // r0
  int v5; // r1
  bool v6; // zf

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 >= 832 )
  {
    if ( v4 == 832 )
    {
      v5 = 710;
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        v5 = 906;
      return CTaskComplexGoToPointAnyMeans::CreateSubTask(this, v5, pPed);
    }
    if ( v4 == 903 || v4 == 906 )
    {
      v5 = 1302;
      return CTaskComplexGoToPointAnyMeans::CreateSubTask(this, v5, pPed);
    }
    return 0;
  }
  if ( v4 == 701 )
  {
    v6 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v6 = pPed->m_pMyVehicle == 0;
    if ( v6 )
      v5 = 906;
    else
      v5 = 710;
    return CTaskComplexGoToPointAnyMeans::CreateSubTask(this, v5, pPed);
  }
  if ( v4 == 704 )
  {
    v5 = 903;
    return CTaskComplexGoToPointAnyMeans::CreateSubTask(this, v5, pPed);
  }
  if ( v4 != 710 )
    return 0;
  v5 = 704;
  return CTaskComplexGoToPointAnyMeans::CreateSubTask(this, v5, pPed);
}

//----- (00524978) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAnyMeans::CreateSubTask(
        const CTaskComplexGoToPointAnyMeans *this,
        const int iTaskType,
        CPed *pPed)
{
  char *v5; // r4
  __int64 v6; // kr00_8
  char v7; // r0
  __int64 v8; // d16
  _DWORD *v9; // r0
  _WORD *v10; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v13; // kr08_8
  char v14; // r1
  float v15; // s0
  __int64 v16; // d16

  v5 = 0;
  if ( iTaskType >= 832 )
  {
    switch ( iTaskType )
    {
      case 832:
        v5 = (char *)CTask::operator new(0x34u);
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        CTaskSimpleCreateCarAndGetIn::CTaskSimpleCreateCarAndGetIn(
          (CTaskSimpleCreateCarAndGetIn *)v5,
          &p_tx->m_translate,
          this->m_iDesiredCarModel);
        break;
      case 903:
        v5 = (char *)CTask::operator new(0x28u);
        v13 = *(_QWORD *)&this->m_iMoveState;
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        *((_DWORD *)v5 + 3) = v13;
        v14 = v5[36];
        v15 = *((float *)v5 + 4);
        *(_DWORD *)v5 = &off_66C13C;
        v5[36] = v14 & 0xE4;
        if ( v15 != this->m_vTarget.x
          || *((float *)v5 + 5) != this->m_vTarget.y
          || *((float *)v5 + 6) != this->m_vTarget.z
          || *((float *)v5 + 8) != 2.0 )
        {
          v16 = *(_QWORD *)&this->m_vTarget.x;
          *((_DWORD *)v5 + 6) = LODWORD(this->m_vTarget.z);
          *((_QWORD *)v5 + 2) = v16;
          *((_DWORD *)v5 + 7) = HIDWORD(v13);
          *((_DWORD *)v5 + 8) = 0x40000000;
          v5[36] = v14 & 0xE0 | 4;
        }
        break;
      case 906:
        v5 = (char *)CTask::operator new(0x60u);
        v6 = *(_QWORD *)&this->m_iMoveState;
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        *(_DWORD *)v5 = &off_66C268;
        v7 = v5[76];
        v8 = *(_QWORD *)&this->m_vTarget.x;
        *((_DWORD *)v5 + 5) = LODWORD(this->m_vTarget.z);
        *((_QWORD *)v5 + 3) = v6;
        *((_QWORD *)v5 + 4) = 0x4000000040400000LL;
        *((_DWORD *)v5 + 14) = 0;
        *((_DWORD *)v5 + 15) = -1;
        *((_WORD *)v5 + 20) = -1;
        *((_WORD *)v5 + 26) = -1;
        *((_WORD *)v5 + 36) = 0;
        *((_QWORD *)v5 + 10) = 0LL;
        *((_QWORD *)v5 + 11) = 0LL;
        *((_DWORD *)v5 + 16) = 0;
        *((_DWORD *)v5 + 17) = 0;
        *(_QWORD *)(v5 + 12) = v8;
        v5[76] = v7 & 0x96 | 8;
        v9 = CPointRoute::operator new(0x64u);
        *v9 = 0;
        *((_DWORD *)v5 + 12) = v9;
        v10 = CNodeRoute::operator new(0x24u);
        *(_DWORD *)v10 = 0;
        v10[2] = -1;
        v10[4] = -1;
        v10[6] = -1;
        v10[8] = -1;
        v10[10] = -1;
        v10[12] = -1;
        v10[14] = -1;
        v10[16] = -1;
        *((_WORD *)v5 + 26) = -1;
        *((_DWORD *)v5 + 11) = v10;
        *((CNodeAddress *)v5 + 10) = EmptyNodeAddress;
        break;
    }
  }
  else
  {
    switch ( iTaskType )
    {
      case 701:
        v5 = (char *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
          (CTaskComplexEnterCarAsDriver *)v5,
          this->m_pTargetVehicle);
        break;
      case 704:
        v5 = (char *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
        break;
      case 710:
        v5 = (char *)CTask::operator new(0x3Cu);
        CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(
          (CTaskComplexDriveToPoint *)v5,
          this->m_pTargetVehicle,
          &this->m_vTarget,
          -1.0,
          0,
          -1,
          -1.0,
          0);
        break;
    }
  }
  return (CTask *)v5;
}
// 66C13C: using guessed type void *off_66C13C;
// 66C268: using guessed type void *off_66C268;

//----- (00524B7C) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAnyMeans::CreateFirstSubTask(CTaskComplexGoToPointAnyMeans *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  CVehicle *m_pMyVehicle; // r0
  int v6; // r1
  bool v7; // zf

  m_pTargetVehicle = this->m_pTargetVehicle;
  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( m_pTargetVehicle )
  {
    if ( m_pMyVehicle )
    {
      v6 = 710;
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        v6 = 701;
    }
    else
    {
      v6 = 701;
    }
  }
  else
  {
    v7 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
      v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( v7 || !CVehicle::IsDriver(m_pMyVehicle, pPed) )
      v6 = 906;
    else
      v6 = 710;
  }
  return CTaskComplexGoToPointAnyMeans::CreateSubTask(this, v6, pPed);
}

//----- (00524BD0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAnyMeans::ControlSubTask(CTaskComplexGoToPointAnyMeans *this, CPed *pPed)
{
  CTaskComplexGoToPointAnyMeans *v2; // r5
  CTaskComplexEnterCarAsDriver *m_pSubTask; // r4
  unsigned int v5; // r0
  unsigned int m_iStartTime; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1
  CVehicle *ClosestVehicleInRange; // r8
  bool v12; // zf
  CVehicle *m_pTargetVehicle; // t1
  CMatrix *v14; // r0
  CSimpleTransform *p_m_transform; // r1

  v2 = this;
  m_pSubTask = (CTaskComplexEnterCarAsDriver *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 906 )
    return m_pSubTask;
  if ( v2->m_iDesiredCarModel == -1 )
  {
    if ( !v2->m_forceMakeCarTimer.m_bIsActive )
    {
LABEL_10:
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&v2->m_vTarget.y).n64_u64[0];
      v10 = vmul_f32(v9, v9).n64_u64[0];
      if ( (float)((float)((float)((float)(p_tx->m_translate.x - v2->m_vTarget.x)
                                 * (float)(p_tx->m_translate.x - v2->m_vTarget.x))
                         + *(float *)&v10)
                 + *((float *)&v10 + 1)) > 2500.0 )
      {
        ClosestVehicleInRange = CVehicleScanner::GetClosestVehicleInRange(&pPed->m_pPedIntelligence->m_vehicleScanner);
        v12 = ClosestVehicleInRange == 0;
        if ( ClosestVehicleInRange )
        {
          m_pTargetVehicle = v2->m_pTargetVehicle;
          v2 = (CTaskComplexGoToPointAnyMeans *)((char *)v2 + 32);
          v12 = ClosestVehicleInRange == m_pTargetVehicle;
        }
        if ( !v12 && CCarEnterExit::IsVehicleStealable(ClosestVehicleInRange, pPed) )
        {
          v2->_vptr$CTask = (int (**)(void))ClosestVehicleInRange;
          m_pSubTask = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x50u);
          CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(m_pSubTask, (CVehicle *)v2->_vptr$CTask);
          CEntity::RegisterReference((CEntity *)v2->_vptr$CTask, (CEntity **)v2);
        }
      }
      return m_pSubTask;
    }
  }
  else if ( !v2->m_forceMakeCarTimer.m_bIsActive )
  {
    *(_QWORD *)&v2->m_forceMakeCarTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0xBB800000000LL;
    v2->m_forceMakeCarTimer.m_bIsActive = 1;
  }
  if ( v2->m_forceMakeCarTimer.m_bIsStopped )
  {
    v5 = CTimer::m_snTimeInMilliseconds;
    v2->m_forceMakeCarTimer.m_bIsStopped = 0;
    v2->m_forceMakeCarTimer.m_iStartTime = v5;
    m_iStartTime = v5;
  }
  else
  {
    m_iStartTime = v2->m_forceMakeCarTimer.m_iStartTime;
    v5 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + v2->m_forceMakeCarTimer.m_iDuration > v5 )
    goto LABEL_10;
  m_pSubTask = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x34u);
  v14 = pPed->m_pMat;
  p_m_transform = (CSimpleTransform *)&v14->tx;
  if ( !v14 )
    p_m_transform = &pPed->m_transform;
  CTaskSimpleCreateCarAndGetIn::CTaskSimpleCreateCarAndGetIn(
    (CTaskSimpleCreateCarAndGetIn *)m_pSubTask,
    &p_m_transform->m_translate,
    v2->m_iDesiredCarModel);
  *(_QWORD *)&v2->m_forceMakeCarTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0xBB800000000LL;
  v2->m_forceMakeCarTimer.m_bIsActive = 1;
  return m_pSubTask;
}

//----- (00524D14) --------------------------------------------------------
void __fastcall CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
        CTaskComplexTurnToFaceEntityOrCoord *this,
        CEntity *pEntity,
        const float fHeadingChangeRateFrac,
        const float fHeadingTolerance)
{
  CTaskComplex::CTaskComplex(this);
  this->m_bFacingEntity = 1;
  this->_vptr$CTask = (int (**)(void))&off_66C42C;
  this->m_pEntity = pEntity;
  if ( pEntity )
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
  this->m_fHeadingChangeRateFrac = fHeadingChangeRateFrac;
  this->m_fHeadingTolerance = fHeadingTolerance;
}
// 66C42C: using guessed type void *;

//----- (00524D6C) --------------------------------------------------------
void __fastcall CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
        CTaskComplexTurnToFaceEntityOrCoord *this,
        const CVector *vTarget,
        const float fHeadingChangeRateFrac,
        const float fHeadingTolerance)
{
  int v7; // r0
  __int64 v8; // d16

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v7 + 12) = 0;
  *(_BYTE *)(v7 + 16) = 0;
  *(_DWORD *)v7 = &off_66C42C;
  v8 = *(_QWORD *)&vTarget->x;
  *(RwReal *)(v7 + 28) = vTarget->z;
  *(const float *)(v7 + 32) = fHeadingChangeRateFrac;
  *(const float *)(v7 + 36) = fHeadingTolerance;
  *(_QWORD *)(v7 + 20) = v8;
}
// 524D82: variable 'v7' is possibly undefined
// 66C42C: using guessed type void *off_66C42C;

//----- (00524DA8) --------------------------------------------------------
void __fastcall CTaskComplexTurnToFaceEntityOrCoord::~CTaskComplexTurnToFaceEntityOrCoord(
        CTaskComplexTurnToFaceEntityOrCoord *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C42C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 66C42C: using guessed type void *off_66C42C;

//----- (00524DD4) --------------------------------------------------------
void __fastcall CTaskComplexTurnToFaceEntityOrCoord::~CTaskComplexTurnToFaceEntityOrCoord(
        CTaskComplexTurnToFaceEntityOrCoord *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C42C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 524DFC: variable 'v4' is possibly undefined
// 66C42C: using guessed type void *off_66C42C;

//----- (00524E04) --------------------------------------------------------
CTask *__fastcall CTaskComplexTurnToFaceEntityOrCoord::CreateNextSubTask(
        CTaskComplexTurnToFaceEntityOrCoord *this,
        CPed *pPed)
{
  return 0;
}

//----- (00524E08) --------------------------------------------------------
CTask *__fastcall CTaskComplexTurnToFaceEntityOrCoord::CreateFirstSubTask(
        CTaskComplexTurnToFaceEntityOrCoord *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r2
  CMatrix *m_pMat; // r3
  CVector *p_tx; // r0
  RwReal *p_z; // r2
  RwReal *p_y; // r3
  float x; // s4
  CMatrix *v9; // r0
  float v10; // s0
  CSimpleTransform *p_m_transform; // r2
  RwReal v12; // s2
  RwReal v13; // s0
  float RadianAngleBetweenPoints; // r5
  CTaskSimple *v15; // r0
  __int64 v16; // kr00_8
  CTask *result; // r0
  char m_pParent; // r2
  CVector v19; // [sp+4h] [bp-1Ch] BYREF

  if ( this->m_bFacingEntity )
  {
    m_pEntity = this->m_pEntity;
    if ( !m_pEntity )
      return 0;
    m_pMat = m_pEntity->m_pMat;
    p_tx = (CVector *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pEntity->m_transform.m_translate;
    p_z = &p_tx->z;
    p_y = &p_tx->y;
  }
  else
  {
    p_z = &this->m_vTarget.z;
    p_y = &this->m_vTarget.y;
    p_tx = &this->m_vTarget;
  }
  x = p_tx->x;
  v9 = pPed->m_pMat;
  v10 = *p_z;
  p_m_transform = (CSimpleTransform *)&v9->tx;
  if ( !v9 )
    p_m_transform = &pPed->m_transform;
  v12 = *p_y - p_m_transform->m_translate.y;
  v13 = v10 - p_m_transform->m_translate.z;
  v19.x = x - p_m_transform->m_translate.x;
  v19.y = v12;
  v19.z = v13;
  CVector::Normalise(&v19);
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v19.x, v19.y, 0.0, 0.0);
  v15 = (CTaskSimple *)CTask::operator new(0x18u);
  v16 = *(_QWORD *)&this->m_fHeadingChangeRateFrac;
  CTaskSimple::CTaskSimple(v15);
  m_pParent = (char)result[2].m_pParent;
  result->_vptr$CTask = (int (**)(void))&off_66C108;
  *(float *)&result[1]._vptr$CTask = RadianAngleBetweenPoints;
  *(_QWORD *)&result[1].m_pParent = v16;
  LOBYTE(result[2].m_pParent) = m_pParent & 0xFE;
  return result;
}
// 524E9E: variable 'result' is possibly undefined
// 66C108: using guessed type void *off_66C108;

//----- (00524EC4) --------------------------------------------------------
float __fastcall CTaskComplexTurnToFaceEntityOrCoord::ComputeTargetHeading(
        const CTaskComplexTurnToFaceEntityOrCoord *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r2
  CMatrix *m_pMat; // r3
  CVector *p_tx; // r0
  RwReal *p_z; // r2
  RwReal *p_y; // r3
  float x; // s4
  CMatrix *v8; // r0
  float v9; // s0
  CSimpleTransform *p_m_transform; // r2
  RwReal v11; // s2
  RwReal v12; // s0
  CVector v14; // [sp+4h] [bp-14h] BYREF

  if ( this->m_bFacingEntity )
  {
    m_pEntity = this->m_pEntity;
    m_pMat = m_pEntity->m_pMat;
    p_tx = (CVector *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pEntity->m_transform.m_translate;
    p_z = &p_tx->z;
    p_y = &p_tx->y;
  }
  else
  {
    p_z = &this->m_vTarget.z;
    p_y = &this->m_vTarget.y;
    p_tx = &this->m_vTarget;
  }
  x = p_tx->x;
  v8 = pPed->m_pMat;
  v9 = *p_z;
  p_m_transform = (CSimpleTransform *)&v8->tx;
  if ( !v8 )
    p_m_transform = &pPed->m_transform;
  v11 = *p_y - p_m_transform->m_translate.y;
  v12 = v9 - p_m_transform->m_translate.z;
  v14.x = x - p_m_transform->m_translate.x;
  v14.y = v11;
  v14.z = v12;
  CVector::Normalise(&v14);
  return CGeneral::GetRadianAngleBetweenPoints(v14.x, v14.y, 0.0, 0.0);
}

//----- (00524F40) --------------------------------------------------------
CTask *__fastcall CTaskComplexTurnToFaceEntityOrCoord::ControlSubTask(
        CTaskComplexTurnToFaceEntityOrCoord *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r0
  CMatrix *m_pMat; // r2
  float *p_tx; // r3
  CMatrix *v6; // r0
  CSimpleTransform *p_m_transform; // r2
  float v8; // s2
  float v9; // s4
  float y; // s8
  float z; // s10
  float RadianAngleBetweenPoints; // r0
  float *v13; // r1
  CTask **p_m_pSubTask; // r4
  CTask *m_pSubTask; // t1
  float v16; // s0
  float v17; // s2
  float *v18; // r0
  CTask *v19; // t1
  float m_fCurrentHeading; // s4
  float v21; // s0
  float v22; // s2
  CVector v24; // [sp+4h] [bp-14h] BYREF

  if ( this->m_bFacingEntity )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      m_pMat = m_pEntity->m_pMat;
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pEntity->m_transform.m_translate.x;
      v6 = pPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v6->tx;
      v8 = p_tx[1];
      v9 = p_tx[2];
      if ( !v6 )
        p_m_transform = &pPed->m_transform;
      y = p_m_transform->m_translate.y;
      z = p_m_transform->m_translate.z;
      v24.x = *p_tx - p_m_transform->m_translate.x;
      v24.y = v8 - y;
      v24.z = v9 - z;
      CVector::Normalise(&v24);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v24.x, v24.y, 0.0, 0.0);
      m_pSubTask = this->m_pSubTask;
      p_m_pSubTask = &this->m_pSubTask;
      v13 = (float *)m_pSubTask;
      v16 = *((float *)p_m_pSubTask + 6);
      v17 = *((float *)p_m_pSubTask + 7);
      if ( *(float *)&m_pSubTask[1]._vptr$CTask != RadianAngleBetweenPoints || v13[3] != v16 || v13[4] != v17 )
      {
        v13[2] = RadianAngleBetweenPoints;
        v13[3] = v16;
        v13[4] = v17;
      }
    }
    else
    {
      v19 = this->m_pSubTask;
      p_m_pSubTask = &this->m_pSubTask;
      v18 = (float *)v19;
      m_fCurrentHeading = pPed->m_fCurrentHeading;
      v21 = *((float *)p_m_pSubTask + 6);
      v22 = *((float *)p_m_pSubTask + 7);
      if ( *(float *)&v19[1]._vptr$CTask != m_fCurrentHeading || v18[3] != v21 || v18[4] != v22 )
      {
        v18[2] = m_fCurrentHeading;
        v18[3] = v21;
        v18[4] = v22;
      }
    }
  }
  else
  {
    p_m_pSubTask = &this->m_pSubTask;
  }
  return *p_m_pSubTask;
}

//----- (0052504C) --------------------------------------------------------
void __fastcall CTaskComplexFollowPatrolRoute::CTaskComplexFollowPatrolRoute(
        CTaskComplexFollowPatrolRoute *this,
        const int iMoveState,
        const CPatrolRoute *route,
        const int iMode,
        const float fTargetRadius,
        const float fSlowDownDistance)
{
  int16 v6; // r6
  int16 v8; // r8
  char v10; // r1
  CPatrolRoute *v11; // r11
  bool v12; // cc
  int v13; // r4
  int v14; // r5
  int v15; // r6
  char *v16; // r1
  __int64 v17; // d16
  char v18; // r1
  CTaskComplexFollowPatrolRoute *v19; // [sp+4h] [bp-34h]

  v6 = iMode;
  v8 = iMoveState;
  CTaskComplex::CTaskComplex(this);
  this->m_iMode = v6;
  v10 = *((_BYTE *)this + 32);
  this->m_iMoveState = v8;
  *((_BYTE *)this + 32) = v10 & 0xFD;
  this->_vptr$CTask = (int (**)(void))&off_66C468;
  v11 = (CPatrolRoute *)CPatrolRoute::operator new(0x1A4u);
  v11->m_iRouteSize = 0;
  v11->m_anims[0].m_animName[0] = 0;
  v11->m_anims[0].m_animGroupName[0] = 0;
  v11->m_anims[1].m_animName[0] = 0;
  v11->m_anims[1].m_animGroupName[0] = 0;
  v11->m_anims[2].m_animName[0] = 0;
  v11->m_anims[2].m_animGroupName[0] = 0;
  v11->m_anims[3].m_animName[0] = 0;
  v11->m_anims[3].m_animGroupName[0] = 0;
  v11->m_anims[4].m_animName[0] = 0;
  v11->m_anims[4].m_animGroupName[0] = 0;
  v11->m_anims[5].m_animName[0] = 0;
  v11->m_anims[5].m_animGroupName[0] = 0;
  v11->m_anims[6].m_animName[0] = 0;
  v11->m_anims[6].m_animGroupName[0] = 0;
  v11->m_anims[7].m_animName[0] = 0;
  v11->m_anims[7].m_animGroupName[0] = 0;
  v19 = this;
  this->m_pRoute = v11;
  v12 = route->m_iRouteSize < 1;
  v11->m_iRouteSize = route->m_iRouteSize;
  if ( !v12 )
  {
    v13 = 0;
    v14 = 324;
    v15 = 0;
    do
    {
      v16 = (char *)v11 + v14;
      v17 = *(_QWORD *)((char *)&route->m_iRouteSize + v14);
      *((_DWORD *)v16 + 2) = *(_DWORD *)&route->m_anims[0].m_animName[v14 + 4];
      *(_QWORD *)v16 = v17;
      strcpy((char *)&v11->m_anims[v13], (const char *)&route->m_anims[v13]);
      strcpy((char *)v11->m_anims[v13].m_animGroupName, (const char *)route->m_anims[v13].m_animGroupName);
      ++v15;
      v14 += 12;
      ++v13;
    }
    while ( v15 < v11->m_iRouteSize );
  }
  v19->m_fTargetRadius = fTargetRadius;
  v19->m_fSlowDownDistance = fSlowDownDistance;
  v18 = *((_BYTE *)v19 + 32);
  v19->m_iProgress = 0;
  v19->m_iRouteTraversals = 0;
  *((_BYTE *)v19 + 32) = v18 | 1;
}
// 66C468: using guessed type void *;

//----- (00525168) --------------------------------------------------------
void __fastcall CTaskComplexFollowPatrolRoute::SetRoute(
        CTaskComplexFollowPatrolRoute *this,
        const CPatrolRoute *route,
        const float fTargetRadius,
        const float fSlowDownDistance,
        int bForce)
{
  CPatrolRoute *m_pRoute; // r9
  int m_iRouteSize; // r0
  int v10; // r2
  int v11; // r10
  int v12; // r4
  int v13; // r11
  float *v14; // r0
  float *v15; // r1
  int v16; // r4
  int v17; // r5
  int v18; // r6
  char *v19; // r1
  __int64 v20; // d16
  char v21; // r0
  int v22; // [sp+0h] [bp-38h]

  m_pRoute = this->m_pRoute;
  if ( bForce == 1 )
  {
    m_iRouteSize = route->m_iRouteSize;
  }
  else
  {
    m_iRouteSize = route->m_iRouteSize;
    v10 = m_pRoute->m_iRouteSize;
    if ( m_pRoute->m_iRouteSize == route->m_iRouteSize )
    {
      if ( v10 < 1 )
      {
LABEL_12:
        if ( this->m_fTargetRadius == fTargetRadius )
        {
          m_iRouteSize = v10;
          if ( this->m_fSlowDownDistance == fSlowDownDistance )
            return;
          goto LABEL_16;
        }
      }
      else
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v22 = m_pRoute->m_iRouteSize;
        while ( 1 )
        {
          v14 = (float *)((char *)&route->m_iRouteSize + v11 * 12);
          v15 = (float *)((char *)&m_pRoute->m_iRouteSize + v11 * 12);
          if ( m_pRoute->m_routePoints[v11].x != route->m_routePoints[v11].x || v15[82] != v14[82] || v15[83] != v14[83] )
            break;
          if ( strcmp((const char *)&m_pRoute->m_anims[v12], (const char *)&route->m_anims[v12])
            || strcmp(
                 (const char *)m_pRoute->m_anims[v12].m_animGroupName,
                 (const char *)route->m_anims[v12].m_animGroupName) )
          {
            m_iRouteSize = v22;
            goto LABEL_16;
          }
          v10 = v22;
          ++v13;
          ++v11;
          ++v12;
          if ( v13 >= v22 )
            goto LABEL_12;
        }
      }
      m_iRouteSize = v10;
    }
  }
LABEL_16:
  m_pRoute->m_iRouteSize = m_iRouteSize;
  if ( m_iRouteSize >= 1 )
  {
    v16 = 0;
    v17 = 324;
    v18 = 0;
    do
    {
      v19 = (char *)m_pRoute + v17;
      v20 = *(_QWORD *)((char *)&route->m_iRouteSize + v17);
      *((_DWORD *)v19 + 2) = *(_DWORD *)&route->m_anims[0].m_animName[v17 + 4];
      *(_QWORD *)v19 = v20;
      strcpy((char *)&m_pRoute->m_anims[v16], (const char *)&route->m_anims[v16]);
      strcpy((char *)m_pRoute->m_anims[v16].m_animGroupName, (const char *)route->m_anims[v16].m_animGroupName);
      ++v18;
      v17 += 12;
      ++v16;
    }
    while ( v18 < m_pRoute->m_iRouteSize );
  }
  this->m_fTargetRadius = fTargetRadius;
  this->m_fSlowDownDistance = fSlowDownDistance;
  v21 = *((_BYTE *)this + 32);
  this->m_iProgress = 0;
  this->m_iRouteTraversals = 0;
  *((_BYTE *)this + 32) = v21 | 1;
}

//----- (005252C4) --------------------------------------------------------
void __fastcall CTaskComplexFollowPatrolRoute::~CTaskComplexFollowPatrolRoute(CTaskComplexFollowPatrolRoute *this)
{
  CPatrolRoute *m_pRoute; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C468;
  if ( m_pRoute )
    CPatrolRoute::operator delete(m_pRoute);
  sub_18EDB4(this);
}
// 66C468: using guessed type void *off_66C468;

//----- (005252EC) --------------------------------------------------------
void __fastcall CTaskComplexFollowPatrolRoute::~CTaskComplexFollowPatrolRoute(CTaskComplexFollowPatrolRoute *this)
{
  CPatrolRoute *m_pRoute; // r0
  void *v3; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C468;
  if ( m_pRoute )
    CPatrolRoute::operator delete(m_pRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v3);
}
// 525310: variable 'v3' is possibly undefined
// 66C468: using guessed type void *off_66C468;

//----- (00525318) --------------------------------------------------------
bool __fastcall CTaskComplexFollowPatrolRoute::MakeAbortable(
        CTaskComplexFollowPatrolRoute *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CMatrix *m_pMat; // r12
  CTask *m_pSubTask; // r0
  CSimpleTransform *p_tx; // r4
  __int64 v8; // d16
  bool result; // r0

  if ( !iPriority )
    this->m_pRoute->m_iRouteSize = 0;
  m_pMat = pPed->m_pMat;
  m_pSubTask = this->m_pSubTask;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v8 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_PedPositionWhenAborted.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_PedPositionWhenAborted.x = v8;
  result = (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 7))(m_pSubTask);
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xFD | (2 * result);
  return result;
}

//----- (00525364) --------------------------------------------------------
int __fastcall CTaskComplexFollowPatrolRoute::GetSubTaskType(CTaskComplexFollowPatrolRoute *this)
{
  CPatrolRoute *m_pRoute; // r0
  int m_iRouteSize; // r1
  int16 m_iProgress; // r2
  int v5; // r3
  int m_iRouteTraversals; // r1
  int m_iMode; // r2

  m_pRoute = this->m_pRoute;
  m_iRouteSize = m_pRoute->m_iRouteSize;
  if ( !m_pRoute->m_iRouteSize )
    return 1302;
  m_iProgress = this->m_iProgress;
  while ( 1 )
  {
    v5 = m_iProgress + 1;
    if ( v5 < m_iRouteSize )
      return 900;
    if ( v5 == m_iRouteSize )
      return 903;
    if ( m_iRouteSize != m_iProgress )
      return 200;
    m_iRouteTraversals = (unsigned __int16)this->m_iRouteTraversals;
    m_iMode = this->m_iMode;
    this->m_iRouteTraversals = m_iRouteTraversals + 1;
    switch ( m_iMode )
    {
      case 0:
        return 1302;
      case 1:
        if ( m_iRouteTraversals )
          return 1302;
        goto LABEL_8;
      case 2:
LABEL_8:
        CPatrolRoute::Reverse(m_pRoute);
        break;
      case 3:
        break;
      default:
        return 200;
    }
    m_pRoute = this->m_pRoute;
    m_iProgress = 0;
    this->m_iProgress = 0;
    m_iRouteSize = m_pRoute->m_iRouteSize;
    if ( !m_pRoute->m_iRouteSize )
      return 1302;
  }
}

//----- (005253C0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPatrolRoute::CreateSubTask(
        CTaskComplexFollowPatrolRoute *this,
        const int iTaskType)
{
  char *v3; // r4
  CPatrolRoute *v4; // r0
  int v5; // r3
  int16 v6; // r1
  char *v7; // r0
  int v8; // r8
  char v9; // r1
  _DWORD *v10; // r0
  _WORD *v11; // r0
  CPatrolRoute *m_pRoute; // r6
  int m_iProgress; // r5
  int m_iMoveState; // r6
  int v15; // r8
  float m_fTargetRadius; // r9
  CPatrolRoute *v17; // r5
  char v18; // r3
  char *v19; // r0
  int v20; // r2
  __int64 v21; // d16
  int m_iMode; // r0
  bool v23; // zf
  float m_fSlowDownDistance; // s16
  int v25; // r6
  int v26; // r9
  float v27; // r8
  CPatrolRoute *v28; // r5
  char v29; // r1
  float v30; // s0
  char v31; // r0
  float *v32; // r1
  float *v33; // r1
  __int64 v34; // d16
  __int64 v36; // [sp+18h] [bp-30h]
  int v37; // [sp+20h] [bp-28h]

  v3 = 0;
  if ( iTaskType < 900 )
  {
    if ( iTaskType == 200 )
    {
      v3 = (char *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v3);
      *(_DWORD *)v3 = &off_668FF0;
    }
    else if ( iTaskType == 401 )
    {
      m_pRoute = this->m_pRoute;
      m_iProgress = this->m_iProgress;
      v3 = (char *)CTask::operator new(0x64u);
      CTaskSimpleRunNamedAnim::CTaskSimpleRunNamedAnim(
        (CTaskSimpleRunNamedAnim *)v3,
        m_pRoute->m_anims[m_iProgress].m_animName,
        m_pRoute->m_anims[m_iProgress].m_animGroupName,
        88,
        4.0,
        -1,
        0,
        0,
        0,
        0);
    }
  }
  else
  {
    switch ( iTaskType )
    {
      case 900:
        v3 = (char *)CTask::operator new(0x2Cu);
        m_iMoveState = this->m_iMoveState;
        v15 = this->m_iProgress;
        m_fTargetRadius = this->m_fTargetRadius;
        v17 = this->m_pRoute;
        CTaskSimple::CTaskSimple((CTaskSimple *)v3);
        *((_DWORD *)v3 + 2) = m_iMoveState;
        *(_DWORD *)v3 = &off_66C0A0;
        v18 = v3[29];
        v19 = (char *)v17 + 12 * v15;
        v20 = *((_DWORD *)v19 + 83);
        v21 = *(_QWORD *)(v19 + 324);
        LOBYTE(v19) = v3[28];
        *((_DWORD *)v3 + 5) = v20;
        *(_DWORD *)v3 = &off_66C0D4;
        *((float *)v3 + 6) = m_fTargetRadius;
        v3[29] = v18 & 0xE0;
        v3[28] = (unsigned __int8)v19 & 0xC0;
        *(_QWORD *)(v3 + 12) = v21;
        break;
      case 903:
        m_iMode = this->m_iMode;
        v23 = m_iMode == 3;
        if ( m_iMode != 3 )
          v23 = m_iMode == 2;
        if ( v23 )
        {
          m_fSlowDownDistance = 0.0;
        }
        else
        {
          m_fSlowDownDistance = this->m_fSlowDownDistance;
          if ( m_iMode == 1 && !this->m_iRouteTraversals )
            m_fSlowDownDistance = 0.0;
        }
        v3 = (char *)CTask::operator new(0x28u);
        v25 = this->m_iMoveState;
        v26 = this->m_iProgress;
        v27 = this->m_fTargetRadius;
        v28 = this->m_pRoute;
        CTaskComplex::CTaskComplex((CTaskComplex *)v3);
        *((_DWORD *)v3 + 3) = v25;
        v29 = v3[36];
        v30 = *((float *)v3 + 4);
        *(_DWORD *)v3 = &off_66C13C;
        v31 = v29 & 0xE4;
        v3[36] = v29 & 0xE4;
        v32 = (float *)(&v28->m_iRouteSize + 3 * v26);
        if ( v30 != v32[81]
          || *((float *)v3 + 5) != v32[82]
          || *((float *)v3 + 6) != v32[83]
          || *((float *)v3 + 8) != m_fSlowDownDistance )
        {
          v33 = v32 + 81;
          v34 = *(_QWORD *)v33;
          *((float *)v3 + 6) = v33[2];
          *((_QWORD *)v3 + 2) = v34;
          *((float *)v3 + 8) = m_fSlowDownDistance;
          *((float *)v3 + 7) = v27;
          v3[36] = v31 | 4;
        }
        break;
      case 906:
        v4 = this->m_pRoute;
        if ( v4->m_iRouteSize )
        {
          v5 = this->m_iProgress;
          v6 = this->m_iProgress;
          if ( v4->m_iRouteSize == v5 )
          {
            v6 = v5 - 1;
            this->m_iProgress = v5 - 1;
          }
          v7 = (char *)v4 + 12 * v6;
          v37 = *((_DWORD *)v7 + 83);
          v36 = *(_QWORD *)(v7 + 324);
          v3 = (char *)CTask::operator new(0x60u);
          v8 = this->m_iMoveState;
          CTaskComplex::CTaskComplex((CTaskComplex *)v3);
          v9 = v3[76];
          *(_DWORD *)v3 = &off_66C268;
          *((_DWORD *)v3 + 14) = 0;
          *((_DWORD *)v3 + 15) = -1;
          *((_DWORD *)v3 + 5) = v37;
          *((_DWORD *)v3 + 6) = v8;
          *((_DWORD *)v3 + 7) = 1056964608;
          *((_DWORD *)v3 + 8) = 1077936128;
          *((_DWORD *)v3 + 9) = 0x40000000;
          *((_WORD *)v3 + 20) = -1;
          *((_WORD *)v3 + 26) = -1;
          *((_WORD *)v3 + 36) = 0;
          *((_QWORD *)v3 + 10) = 0LL;
          *((_QWORD *)v3 + 11) = 0LL;
          *((_DWORD *)v3 + 16) = 0;
          *((_DWORD *)v3 + 17) = 0;
          *(_QWORD *)(v3 + 12) = v36;
          v3[76] = v9 & 0x96 | 8;
          v10 = CPointRoute::operator new(0x64u);
          *v10 = 0;
          *((_DWORD *)v3 + 12) = v10;
          v11 = CNodeRoute::operator new(0x24u);
          *(_DWORD *)v11 = 0;
          v11[2] = -1;
          v11[4] = -1;
          v11[6] = -1;
          v11[8] = -1;
          v11[10] = -1;
          v11[12] = -1;
          v11[14] = -1;
          v11[16] = -1;
          *((_WORD *)v3 + 26) = -1;
          *((_DWORD *)v3 + 11) = v11;
          *((CNodeAddress *)v3 + 10) = EmptyNodeAddress;
        }
        else
        {
          return 0;
        }
        break;
    }
  }
  return (CTask *)v3;
}
// 668FF0: using guessed type void *off_668FF0;
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;
// 66C13C: using guessed type void *off_66C13C;
// 66C268: using guessed type void *off_66C268;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (0052567C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPatrolRoute::CreateNextSubTask(CTaskComplexFollowPatrolRoute *this, CPed *pPed)
{
  CPatrolRoute *m_pRoute; // r0
  int m_iRouteSize; // r1
  int16 m_iProgress; // r2
  int v6; // r3
  int m_iRouteTraversals; // r1
  int m_iMode; // r2
  int v9; // r1
  int16 *p_m_iProgress; // r6
  CPatrolRoute *v11; // r0
  CPatrolRoute **p_m_pRoute; // r5
  int v13; // r1
  __int16 v14; // r3
  int v15; // r2
  int v16; // r1
  int v17; // r3
  int v18; // r1
  int v19; // r2

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
  {
    m_pRoute = this->m_pRoute;
    m_iRouteSize = m_pRoute->m_iRouteSize;
    if ( m_pRoute->m_iRouteSize )
    {
      m_iProgress = this->m_iProgress;
      while ( 1 )
      {
        v6 = m_iProgress + 1;
        if ( v6 < m_iRouteSize )
          break;
        if ( v6 == m_iRouteSize )
          goto LABEL_30;
        if ( m_iRouteSize != m_iProgress )
          goto LABEL_28;
        m_iRouteTraversals = (unsigned __int16)this->m_iRouteTraversals;
        m_iMode = this->m_iMode;
        this->m_iRouteTraversals = m_iRouteTraversals + 1;
        switch ( m_iMode )
        {
          case 0:
            goto LABEL_26;
          case 1:
            if ( m_iRouteTraversals )
              goto LABEL_26;
            goto LABEL_9;
          case 2:
LABEL_9:
            CPatrolRoute::Reverse(m_pRoute);
            break;
          case 3:
            break;
          default:
            goto LABEL_28;
        }
        m_pRoute = this->m_pRoute;
        m_iProgress = 0;
        this->m_iProgress = 0;
        m_iRouteSize = m_pRoute->m_iRouteSize;
        if ( !m_pRoute->m_iRouteSize )
          goto LABEL_26;
      }
LABEL_29:
      v13 = 900;
      return CTaskComplexFollowPatrolRoute::CreateSubTask(this, v13);
    }
    goto LABEL_26;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 200 )
  {
LABEL_26:
    v13 = 1302;
    return CTaskComplexFollowPatrolRoute::CreateSubTask(this, v13);
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 401 )
  {
    p_m_iProgress = &this->m_iProgress;
    LOWORD(v9) = this->m_iProgress;
    p_m_pRoute = &this->m_pRoute;
    v11 = this->m_pRoute;
    goto LABEL_17;
  }
  p_m_pRoute = &this->m_pRoute;
  v11 = this->m_pRoute;
  p_m_iProgress = &this->m_iProgress;
  v9 = this->m_iProgress;
  if ( !v11->m_anims[v9].m_animName[0] )
  {
LABEL_17:
    v14 = v9 + 1;
    *p_m_iProgress = v9 + 1;
    v15 = v11->m_iRouteSize;
    if ( v11->m_iRouteSize )
    {
      while ( 1 )
      {
        v16 = v14;
        v17 = v14 + 1;
        if ( v17 < v15 )
          goto LABEL_29;
        if ( v17 == v15 )
        {
LABEL_30:
          v13 = 903;
          return CTaskComplexFollowPatrolRoute::CreateSubTask(this, v13);
        }
        if ( v15 != v16 )
        {
LABEL_28:
          v13 = 200;
          return CTaskComplexFollowPatrolRoute::CreateSubTask(this, v13);
        }
        v18 = (unsigned __int16)this->m_iRouteTraversals;
        v19 = this->m_iMode;
        this->m_iRouteTraversals = v18 + 1;
        switch ( v19 )
        {
          case 0:
            goto LABEL_26;
          case 1:
            if ( v18 )
              goto LABEL_26;
            goto LABEL_23;
          case 2:
LABEL_23:
            CPatrolRoute::Reverse(v11);
            break;
          case 3:
            break;
          default:
            goto LABEL_28;
        }
        v14 = 0;
        v13 = 1302;
        *p_m_iProgress = 0;
        v11 = *p_m_pRoute;
        v15 = (*p_m_pRoute)->m_iRouteSize;
        if ( !v15 )
          return CTaskComplexFollowPatrolRoute::CreateSubTask(this, v13);
      }
    }
    goto LABEL_26;
  }
  v13 = 401;
  return CTaskComplexFollowPatrolRoute::CreateSubTask(this, v13);
}

//----- (00525790) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPatrolRoute::CreateFirstSubTask(CTaskComplexFollowPatrolRoute *this, CPed *pPed)
{
  CTaskComplexFollowPatrolRoute *v2; // r4
  char v3; // r2
  CPatrolRoute *m_pRoute; // r0
  int m_iRouteSize; // r10
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r11
  float v8; // s16
  int v9; // r6
  int v10; // r5
  int v11; // r8
  int v12; // r4
  float *v13; // r9
  float v14; // s0
  float *v15; // r0
  float v16; // s4
  float v17; // s18
  float v18; // s6
  float v19; // s20
  float v20; // s22
  float v21; // s2
  float v22; // s10
  float y; // s8
  float z; // s4
  float v25; // s3
  int v26; // r1
  float v27; // s0
  int m_routePoints; // r0
  float v29; // s4
  float32x2_t v30; // d17
  float32x2_t v31; // d17
  unsigned __int64 v32; // d3
  float v33; // s4
  char v34; // r0
  CPatrolRoute *v35; // r0
  int v36; // r1
  int v37; // r3
  int m_iRouteTraversals; // r1
  int m_iMode; // r2
  int v40; // r1
  CTaskComplexFollowPatrolRoute *v42; // [sp+0h] [bp-50h]
  CVector v43; // [sp+4h] [bp-4Ch] BYREF

  v2 = this;
  v3 = *((_BYTE *)this + 32);
  m_pRoute = this->m_pRoute;
  *((_BYTE *)v2 + 32) = v3 & 0xFE;
  m_iRouteSize = m_pRoute->m_iRouteSize;
  if ( m_pRoute->m_iRouteSize )
  {
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    if ( m_iRouteSize < 1 )
    {
      LOWORD(v9) = -1;
    }
    else
    {
      v8 = 3.4028e38;
      v9 = -1;
      v10 = 332;
      v11 = 1;
      v42 = v2;
      while ( 1 )
      {
        v12 = v11;
        if ( m_iRouteSize == v11 )
          v12 = 0;
        v13 = (float *)((char *)&m_pRoute->m_iRouteSize + v10);
        v14 = *(float *)((char *)m_pRoute + v10 - 8);
        v15 = (float *)(&m_pRoute->m_iRouteSize + 3 * v12);
        v16 = v15[82];
        v17 = v15[81] - v14;
        v18 = v15[83];
        v43.x = v17;
        v19 = v16 - *(v13 - 1);
        v43.y = v19;
        v20 = v18 - *v13;
        v43.z = v20;
        CVector::Normalise(&v43);
        v21 = *(v13 - 2);
        v22 = *(v13 - 1);
        y = p_tx->m_translate.y;
        z = p_tx->m_translate.z;
        v25 = (float)((float)((float)(p_tx->m_translate.x - v21) * v43.x) + (float)((float)(y - v22) * v43.y))
            + (float)((float)(z - *v13) * v43.z);
        if ( v25 > 0.0
          && v25 < sqrtf((float)(v20 * v20) + (float)((float)(v17 * v17) + (float)(v19 * v19)))
          && (float)((float)((float)(z - (float)(*v13 + (float)(v43.z * v25)))
                           * (float)(z - (float)(*v13 + (float)(v43.z * v25))))
                   + (float)((float)((float)(p_tx->m_translate.x - (float)(v21 + (float)(v43.x * v25)))
                                   * (float)(p_tx->m_translate.x - (float)(v21 + (float)(v43.x * v25))))
                           + (float)((float)(y - (float)(v22 + (float)(v43.y * v25)))
                                   * (float)(y - (float)(v22 + (float)(v43.y * v25)))))) < (float)(v8 * v8) )
        {
          v8 = (float)((float)(z - (float)(*v13 + (float)(v43.z * v25)))
                     * (float)(z - (float)(*v13 + (float)(v43.z * v25))))
             + (float)((float)((float)(p_tx->m_translate.x - (float)(v21 + (float)(v43.x * v25)))
                             * (float)(p_tx->m_translate.x - (float)(v21 + (float)(v43.x * v25))))
                     + (float)((float)(y - (float)(v22 + (float)(v43.y * v25)))
                             * (float)(y - (float)(v22 + (float)(v43.y * v25)))));
          v9 = v12;
        }
        v2 = v42;
        if ( m_iRouteSize == v11 )
          break;
        ++v11;
        m_pRoute = v42->m_pRoute;
        v10 += 12;
      }
      if ( v9 == -1 )
      {
        v26 = 0;
        v27 = 3.4028e38;
        LOWORD(v9) = -1;
        m_routePoints = (int)v42->m_pRoute->m_routePoints;
        do
        {
          v29 = *(float *)m_routePoints;
          v30.n64_u64[0] = *(unsigned __int64 *)(m_routePoints + 4);
          m_routePoints += 12;
          v31.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, v30).n64_u64[0];
          v32 = vmul_f32(v31, v31).n64_u64[0];
          v33 = (float)((float)((float)(p_tx->m_translate.x - v29) * (float)(p_tx->m_translate.x - v29)) + *(float *)&v32)
              + *((float *)&v32 + 1);
          if ( v33 < (float)(v27 * v27) )
          {
            v27 = v33;
            LOWORD(v9) = v26;
          }
          ++v26;
        }
        while ( m_iRouteSize != v26 );
      }
    }
    v34 = *((_BYTE *)v2 + 32);
    v2->m_iProgress = v9;
    *((_BYTE *)v2 + 32) = v34 & 0xFD;
    if ( (v34 & 2) != 0 )
    {
      v40 = 906;
    }
    else
    {
      v35 = v2->m_pRoute;
      while ( 1 )
      {
        v36 = v35->m_iRouteSize;
        if ( !v35->m_iRouteSize )
        {
LABEL_33:
          v40 = 1302;
          return CTaskComplexFollowPatrolRoute::CreateSubTask(v2, v40);
        }
        v37 = (__int16)v9 + 1;
        if ( v37 < v36 )
        {
          v40 = 900;
          return CTaskComplexFollowPatrolRoute::CreateSubTask(v2, v40);
        }
        if ( v37 == v36 )
          break;
        if ( v36 != (__int16)v9 )
          goto LABEL_31;
        m_iRouteTraversals = (unsigned __int16)v2->m_iRouteTraversals;
        m_iMode = v2->m_iMode;
        v2->m_iRouteTraversals = m_iRouteTraversals + 1;
        switch ( m_iMode )
        {
          case 0:
            goto LABEL_33;
          case 1:
            if ( m_iRouteTraversals )
              goto LABEL_33;
            goto LABEL_30;
          case 2:
LABEL_30:
            CPatrolRoute::Reverse(v35);
            break;
          case 3:
            break;
          default:
            goto LABEL_31;
        }
        LOWORD(v9) = 0;
        v35 = v2->m_pRoute;
        v2->m_iProgress = 0;
      }
      v40 = 903;
    }
  }
  else
  {
LABEL_31:
    v40 = 200;
  }
  return CTaskComplexFollowPatrolRoute::CreateSubTask(v2, v40);
}
// 525904: conditional instruction was optimized away because r10.4>=1

//----- (005259E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPatrolRoute::ControlSubTask(CTaskComplexFollowPatrolRoute *this, CPed *pPed)
{
  int (**v3)(void); // r2

  if ( !(*((unsigned __int8 *)this + 32) << 30) )
    return this->m_pSubTask;
  v3 = this->_vptr$CTask;
  this->m_iProgress = 0;
  return (CTask *)((int (__fastcall *)(CTaskComplexFollowPatrolRoute *, CPed *))v3[11])(this, pPed);
}

//----- (005259F8) --------------------------------------------------------
void __fastcall CTaskComplexGotoDoorAndOpen::CTaskComplexGotoDoorAndOpen(
        CTaskComplexGotoDoorAndOpen *this,
        CObject *pDoor)
{
  char v4; // r1

  CTaskComplex::CTaskComplex(this);
  v4 = *((_BYTE *)this + 52);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  *((_BYTE *)this + 52) = v4 & 0xF0 | 1;
  this->_vptr$CTask = (int (**)(void))&off_66C4A4;
  this->m_pDoor = pDoor;
  if ( pDoor )
    CEntity::RegisterReference(pDoor, &this->m_pDoor);
}
// 66C4A4: using guessed type void *;

//----- (00525A40) --------------------------------------------------------
void __fastcall CTaskComplexGotoDoorAndOpen::CTaskComplexGotoDoorAndOpen(
        CTaskComplexGotoDoorAndOpen *this,
        const CVector *target1,
        const CVector *target2)
{
  int v5; // r0
  __int64 v6; // d16
  __int64 v7; // d16
  char v8; // r1

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)v5 = &off_66C4A4;
  v6 = *(_QWORD *)&target1->x;
  *(RwReal *)(v5 + 24) = target1->z;
  *(_QWORD *)(v5 + 16) = v6;
  v7 = *(_QWORD *)&target2->x;
  *(RwReal *)(v5 + 36) = target2->z;
  *(_WORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 28) = v7;
  v8 = *(_BYTE *)(v5 + 52);
  *(_DWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 44) = 0;
  *(_BYTE *)(v5 + 52) = v8 & 0xF4;
}
// 525A50: variable 'v5' is possibly undefined
// 66C4A4: using guessed type void *off_66C4A4;

//----- (00525A8C) --------------------------------------------------------
void __fastcall CTaskComplexGotoDoorAndOpen::~CTaskComplexGotoDoorAndOpen(CTaskComplexGotoDoorAndOpen *this)
{
  CObject *m_pDoor; // r0
  CEntity **p_m_pDoor; // r1

  p_m_pDoor = &this->m_pDoor;
  m_pDoor = this->m_pDoor;
  this->_vptr$CTask = (int (**)(void))&off_66C4A4;
  if ( m_pDoor )
    CEntity::CleanUpOldReference(m_pDoor, p_m_pDoor);
  sub_18EDB4(this);
}
// 66C4A4: using guessed type void *off_66C4A4;

//----- (00525AB8) --------------------------------------------------------
void __fastcall CTaskComplexGotoDoorAndOpen::~CTaskComplexGotoDoorAndOpen(CTaskComplexGotoDoorAndOpen *this)
{
  CObject *m_pDoor; // r0
  CEntity **p_m_pDoor; // r1
  void *v4; // r0

  p_m_pDoor = &this->m_pDoor;
  m_pDoor = this->m_pDoor;
  this->_vptr$CTask = (int (**)(void))&off_66C4A4;
  if ( m_pDoor )
    CEntity::CleanUpOldReference(m_pDoor, p_m_pDoor);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 525AE0: variable 'v4' is possibly undefined
// 66C4A4: using guessed type void *off_66C4A4;

//----- (00525AE8) --------------------------------------------------------
bool __fastcall CTaskComplexGotoDoorAndOpen::MakeAbortable(
        CTaskComplexGotoDoorAndOpen *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (00525AFC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGotoDoorAndOpen::Clone(const CTaskComplexGotoDoorAndOpen *this)
{
  char v2; // r6
  CTaskComplex *v3; // r0
  CTaskComplex *v4; // r4
  __int64 v5; // d16
  __int64 v6; // d16
  char v7; // r0
  CObject *m_pDoor; // r5
  char m_pParent; // r2

  v2 = *((_BYTE *)this + 52);
  v3 = (CTaskComplex *)CTask::operator new(0x38u);
  v4 = v3;
  if ( (v2 & 1) != 0 )
  {
    m_pDoor = this->m_pDoor;
    CTaskComplex::CTaskComplex(v3);
    LOWORD(v4[4]._vptr$CTask) = 0;
    m_pParent = (char)v4[4].m_pParent;
    v4[3].m_pParent = 0;
    v4[3].m_pSubTask = 0;
    v4->_vptr$CTask = (int (**)(void))&off_66C4A4;
    LOBYTE(v4[4].m_pParent) = m_pParent & 0xF0 | 1;
    v4[1]._vptr$CTask = (int (**)(void))m_pDoor;
    if ( m_pDoor )
      CEntity::RegisterReference(m_pDoor, (CEntity **)&v4[1]);
  }
  else
  {
    CTaskComplex::CTaskComplex(v3);
    v4[1]._vptr$CTask = 0;
    v4->_vptr$CTask = (int (**)(void))&off_66C4A4;
    v5 = *(_QWORD *)&this->m_target1.x;
    v4[2]._vptr$CTask = (int (**)(void))LODWORD(this->m_target1.z);
    *(_QWORD *)&v4[1].m_pParent = v5;
    v6 = *(_QWORD *)&this->m_target2.x;
    v4[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_target2.z);
    LOWORD(v4[4]._vptr$CTask) = 0;
    *(_QWORD *)&v4[2].m_pParent = v6;
    v7 = (char)v4[4].m_pParent;
    v4[3].m_pParent = 0;
    v4[3].m_pSubTask = 0;
    LOBYTE(v4[4].m_pParent) = v7 & 0xF4;
  }
  return v4;
}
// 66C4A4: using guessed type void *off_66C4A4;

//----- (00525BA4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGotoDoorAndOpen::CreateFirstSubTask(CTaskComplexGotoDoorAndOpen *this, CPed *pPed)
{
  CPad *Pad; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  CObject *m_pDoor; // r0
  CMatrix *m_pMat; // r1
  float *p_xx; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float v11; // s8
  float v12; // s12
  float v13; // s14
  float v14; // s0
  float v15; // s2
  float v16; // s4
  float v17; // s6
  float v18; // s10
  float v19; // s3
  float v20; // s1
  float v21; // s12
  float v22; // s8
  float v23; // s4
  float v24; // s5
  float v25; // s9
  float v26; // s14
  float v27; // s6
  float v28; // s2
  float v29; // s6
  float v30; // s0
  float v31; // s4
  float v32; // s8
  float v33; // s10
  char *v34; // r5
  int v35; // s0
  RwReal z; // r0
  __int64 v37; // d16
  char v38; // r1
  CEventAreaCodes v40[2]; // [sp+0h] [bp-20h] BYREF

  if ( CPed::IsPlayer(pPed) )
  {
    Pad = CPad::GetPad(0);
    Pad->DisablePlayerControls |= 8u;
    *((_BYTE *)this + 52) |= 8u;
  }
  CEventAreaCodes::CEventAreaCodes(v40, pPed);
  EventGlobalGroup = GetEventGlobalGroup();
  CEventGroup::Add(EventGlobalGroup, v40, 0);
  m_pDoor = this->m_pDoor;
  this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_iDuration = 1000;
  this->m_timer.m_bIsActive = 1;
  if ( m_pDoor )
  {
    m_pMat = pPed->m_pMat;
    p_xx = &m_pDoor->m_pMat->xx;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    p_x = p_xx + 12;
    if ( !p_xx )
      p_x = &m_pDoor->m_transform.m_translate.x;
    v11 = p_x[1];
    v12 = p_x[2];
    v13 = v11 - p_tx->m_translate.y;
    v14 = p_xx[4];
    v15 = p_xx[5];
    v16 = p_xx[6];
    v17 = v16 * (float)(v12 - p_tx->m_translate.z);
    v18 = *p_x + (float)(*p_xx * 0.75);
    v19 = v15 + v15;
    v20 = v16 * -0.5;
    v21 = v12 + (float)(p_xx[2] * 0.75);
    v22 = v11 + (float)(p_xx[1] * 0.75);
    v23 = v16 + v16;
    v24 = v14 + v14;
    v25 = (float)((float)(v14 * (float)(*p_x - p_tx->m_translate.x)) + (float)(v15 * v13)) + v17;
    v26 = v15 * -0.5;
    v27 = v14 * -0.5;
    if ( v25 <= 0.0 )
    {
      v28 = v22 - v26;
      v29 = v18 - v27;
      v30 = v21 - v20;
      v31 = v21 - v23;
      v32 = v22 - v19;
      v33 = v18 - v24;
    }
    else
    {
      v28 = v22 + v26;
      v29 = v18 + v27;
      v30 = v21 + v20;
      v31 = v21 + v23;
      v32 = v22 + v19;
      v33 = v18 + v24;
    }
    this->m_target1.x = v29;
    this->m_target1.y = v28;
    this->m_target1.z = v30;
    this->m_target2.x = v33;
    this->m_target2.y = v32;
    this->m_target2.z = v31;
    if ( (*(_BYTE *)&m_pDoor->m_nPhysicalFlags & 8) != 0 )
    {
      *((_BYTE *)this + 52) |= 4u;
      *(_DWORD *)&m_pDoor->m_nPhysicalFlags &= ~8u;
      *(_DWORD *)&this->m_pDoor->m_nPhysicalFlags &= ~4u;
    }
    if ( RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 2u) )
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_WALK, 1000.0);
    v34 = (char *)CTask::operator new(0x2Cu);
    CTaskSimple::CTaskSimple((CTaskSimple *)v34);
    *((_DWORD *)v34 + 2) = 4;
    v35 = 1051931443;
    *(_DWORD *)v34 = &off_66C0A0;
    v37 = *(_QWORD *)&this->m_target1.x;
    z = this->m_target1.z;
  }
  else
  {
    if ( (*((_BYTE *)this + 52) & 1) != 0 )
    {
      v34 = 0;
      goto LABEL_20;
    }
    *((_BYTE *)this + 52) |= 2u;
    v34 = (char *)CTask::operator new(0x2Cu);
    CTaskSimple::CTaskSimple((CTaskSimple *)v34);
    v35 = 0.5;
    *((_DWORD *)v34 + 2) = 4;
    *(_DWORD *)v34 = &off_66C0A0;
    z = this->m_target2.z;
    v37 = *(_QWORD *)&this->m_target2.x;
  }
  *((RwReal *)v34 + 5) = z;
  *(_QWORD *)(v34 + 12) = v37;
  v38 = v34[28];
  *((_DWORD *)v34 + 6) = v35;
  v34[28] = v38 & 0xC0;
  *(_DWORD *)v34 = &off_66C0D4;
  v34[29] &= 0xE0u;
LABEL_20:
  CEventAreaCodes::~CEventAreaCodes(v40);
  return (CTask *)v34;
}
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (00525DEC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGotoDoorAndOpen::CreateNextSubTask(CTaskComplexGotoDoorAndOpen *this, CPed *pPed)
{
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskSimpleRunAnim *v5; // r5
  char *v6; // r5
  __int64 v7; // d16
  char v8; // r0
  char v9; // r2
  _BOOL4 IsPlayer; // r0
  CPad *Pad; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 900 )
    return 0;
  if ( (*((_BYTE *)this + 52) & 2) != 0 )
  {
    IsPlayer = CPed::IsPlayer(pPed);
    v6 = 0;
    if ( IsPlayer )
    {
      Pad = CPad::GetPad(0);
      Pad->DisablePlayerControls |= 8u;
    }
  }
  else
  {
    if ( !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, ANIM_STD_PED, ANIM_STD_OPENDOOR, 8.0, 0);
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v5, 4);
    }
    v6 = (char *)CTask::operator new(0x2Cu);
    CTaskSimple::CTaskSimple((CTaskSimple *)v6);
    *((_DWORD *)v6 + 2) = 4;
    *(_DWORD *)v6 = &off_66C0A0;
    v7 = *(_QWORD *)&this->m_target2.x;
    v8 = v6[28] & 0xC0;
    v9 = v6[29];
    *((_DWORD *)v6 + 5) = LODWORD(this->m_target2.z);
    *(_DWORD *)v6 = &off_66C0D4;
    *((_DWORD *)v6 + 6) = 1045220557;
    v6[28] = v8;
    v6[29] = v9 & 0xE0;
    *(_QWORD *)(v6 + 12) = v7;
    *((_BYTE *)this + 52) |= 2u;
  }
  return (CTask *)v6;
}
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (00525ED8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGotoDoorAndOpen::ControlSubTask(CTaskComplexGotoDoorAndOpen *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  CTask *v6; // r4
  CPad *Pad; // r0

  if ( !this->m_timer.m_bIsActive
    || (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v4 = CTimer::m_snTimeInMilliseconds) : (v4 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v4, m_iStartTime = v4),
        m_iStartTime + this->m_timer.m_iDuration > v4) )
  {
    if ( this->m_pDoor || !(*((unsigned __int8 *)this + 52) << 31) )
      return this->m_pSubTask;
  }
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) != 1 )
    return this->m_pSubTask;
  v6 = 0;
  if ( CPed::IsPlayer(pPed) )
  {
    Pad = CPad::GetPad(0);
    Pad->DisablePlayerControls |= 8u;
  }
  return v6;
}

//----- (00525F68) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEntryExit::CreateFirstSubTask(CTaskComplexUseEntryExit *this, CPed *pPed)
{
  CEntryExit *m_pEE; // r0
  float left; // s16
  float top; // s18
  float right; // s20
  float bottom; // s22
  CTask *pz_low; // r4
  CTaskSimple *v8; // r0
  CTask *result; // r0
  char m_pParent; // r3
  char v11; // r2

  m_pEE = this->m_pEE;
  left = m_pEE->rect.left;
  top = m_pEE->rect.top;
  right = m_pEE->rect.right;
  bottom = m_pEE->rect.bottom;
  pz_low = (CTask *)LODWORD(m_pEE->pz);
  v8 = (CTaskSimple *)CTask::operator new(0x2Cu);
  CTaskSimple::CTaskSimple(v8);
  m_pParent = (char)result[3].m_pParent;
  v11 = BYTE1(result[3].m_pParent);
  result[1]._vptr$CTask = (int (**)(void))&byte_6;
  result[2].m_pParent = pz_low;
  result[3]._vptr$CTask = (int (**)(void))1056964608;
  result->_vptr$CTask = (int (**)(void))&off_66C0D4;
  LOBYTE(result[3].m_pParent) = m_pParent & 0xC0;
  BYTE1(result[3].m_pParent) = v11 & 0xE0;
  *(float *)&result[1].m_pParent = (float)(left + right) * 0.5;
  *(float *)&result[2]._vptr$CTask = (float)(top + bottom) * 0.5;
  return result;
}
// 525FA2: variable 'result' is possibly undefined
// 6: using guessed type char byte_6;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (00525FE0) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEntryExit::CreateNextSubTask(CTaskComplexUseEntryExit *this, CPed *pPed)
{
  char v4; // r1
  CEntryExit *m_pEE; // r0
  CEntryExit *pLink; // r1
  CEntity *NearestDoor; // r8
  void *v8; // r5
  char v9; // r2
  CEntryExit *m_pSpawnEE; // r0
  int (**v11)(void); // r5
  float spawnx; // r1
  float spawny; // r2
  float spawnz; // r3
  int (*v15)(void); // r12
  float v16; // s0

  v4 = *((_BYTE *)this + 20);
  if ( (v4 & 1) != 0 )
    goto LABEL_6;
  m_pEE = this->m_pEE;
  *((_BYTE *)this + 20) = v4 | 1;
  pLink = m_pEE->pLink;
  if ( !pLink )
    pLink = m_pEE;
  this->m_pSpawnEE = pLink;
  NearestDoor = CEntryExitManager::FindNearestDoor(m_pEE, 10.0);
  if ( !NearestDoor )
  {
LABEL_6:
    m_pSpawnEE = this->m_pSpawnEE;
    v11 = pPed->_vptr$CPlaceable;
    spawnx = m_pSpawnEE->spawnx;
    spawny = m_pSpawnEE->spawny;
    spawnz = m_pSpawnEE->spawnz;
    pPed->m_areaCode = m_pSpawnEE->areacode;
    pPed->m_pLastEntryExit = this->m_pEE;
    v15 = v11[15];
    v8 = 0;
    ((void (__fastcall *)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))v15)(
      pPed,
      LODWORD(spawnx),
      LODWORD(spawny),
      LODWORD(spawnz),
      0);
    v16 = (float)(this->m_pSpawnEE->spawnrot * 3.1416) / 180.0;
    pPed->m_fDesiredHeading = v16;
    pPed->m_fCurrentHeading = v16;
    CWorld::Remove(pPed);
    *(_DWORD *)&pPed->m_nFlags |= 0x40000u;
    CWorld::Add(pPed);
  }
  else
  {
    v8 = CTask::operator new(0x38u);
    CTaskComplex::CTaskComplex((CTaskComplex *)v8);
    *((_WORD *)v8 + 24) = 0;
    v9 = *((_BYTE *)v8 + 52);
    *((_DWORD *)v8 + 10) = 0;
    *((_DWORD *)v8 + 11) = 0;
    *(_DWORD *)v8 = &off_66C4A4;
    *((_BYTE *)v8 + 52) = v9 & 0xF0 | 1;
    *((_DWORD *)v8 + 3) = NearestDoor;
    CEntity::RegisterReference(NearestDoor, (CEntity **)v8 + 3);
  }
  return (CTask *)v8;
}
// 66C4A4: using guessed type void *off_66C4A4;

//----- (005260CC) --------------------------------------------------------
void __fastcall CTaskComplexUseEntryExit::UseEntryExit(CTaskComplexUseEntryExit *this, CPed *pPed)
{
  CEntryExit *m_pSpawnEE; // r0
  float spawnx; // r1
  float spawny; // r2
  float spawnz; // r3
  int (**v8)(void); // r12
  float v9; // s0

  m_pSpawnEE = this->m_pSpawnEE;
  spawnx = m_pSpawnEE->spawnx;
  spawny = m_pSpawnEE->spawny;
  spawnz = m_pSpawnEE->spawnz;
  v8 = pPed->_vptr$CPlaceable;
  pPed->m_areaCode = m_pSpawnEE->areacode;
  pPed->m_pLastEntryExit = this->m_pEE;
  ((void (__fastcall *)(CPed *, _DWORD, _DWORD, _DWORD, _DWORD))v8[15])(
    pPed,
    LODWORD(spawnx),
    LODWORD(spawny),
    LODWORD(spawnz),
    0);
  v9 = (float)(this->m_pSpawnEE->spawnrot * 3.1416) / 180.0;
  pPed->m_fDesiredHeading = v9;
  pPed->m_fCurrentHeading = v9;
  CWorld::Remove(pPed);
  *(_DWORD *)&pPed->m_nFlags |= 0x40000u;
  sub_19B3E4(pPed);
}

//----- (00526144) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEntryExit::ControlSubTask(CTaskComplexUseEntryExit *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (00526148) --------------------------------------------------------
bool __fastcall CTaskComplexUseEntryExit::MakeAbortable(
        CTaskComplexUseEntryExit *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (0052615C) --------------------------------------------------------
void __fastcall CTaskSimpleSlideToCoord::CTaskSimpleSlideToCoord(
        CTaskSimpleSlideToCoord *this,
        const CVector *vPos,
        const float fHeading,
        const float fSpeed)
{
  int v7; // r0
  char v8; // r2
  __int64 v9; // d16

  CTaskSimpleAnim::CTaskSimpleAnim((CTaskSimpleAnim *)this, 0);
  *(_WORD *)(v7 + 76) = 0;
  *(_DWORD *)(v7 + 68) = 0;
  *(_DWORD *)(v7 + 72) = 0;
  *(_DWORD *)v7 = &off_66C4E0;
  v8 = *(_BYTE *)(v7 + 120);
  v9 = *(_QWORD *)&vPos->x;
  *(RwReal *)(v7 + 108) = vPos->z;
  *(const float *)(v7 + 112) = fHeading;
  *(const float *)(v7 + 116) = fSpeed;
  *(_BYTE *)(v7 + 120) = v8 & 0xFC | 1;
  *(_QWORD *)(v7 + 100) = v9;
}
// 526178: variable 'v7' is possibly undefined
// 66C4E0: using guessed type void *;

//----- (005261B0) --------------------------------------------------------
void __fastcall CTaskSimpleSlideToCoord::CTaskSimpleSlideToCoord(
        CTaskSimpleSlideToCoord *this,
        const CVector *vPos,
        const float fHeading,
        const float fSpeed,
        const unsigned __int8 *pAnimName,
        const unsigned __int8 *pAnimGroupName,
        const int32 flags,
        const float fBlendDelta,
        bool bRunInSequence,
        const int iTime)
{
  int v13; // r0
  __int64 v14; // d16
  char v15; // r2

  CTaskSimpleRunNamedAnim::CTaskSimpleRunNamedAnim(
    this,
    pAnimName,
    pAnimGroupName,
    flags,
    fBlendDelta,
    iTime,
    0,
    bRunInSequence,
    0,
    0);
  *(_DWORD *)v13 = &off_66C4E0;
  v14 = *(_QWORD *)&vPos->x;
  v15 = *(_BYTE *)(v13 + 120);
  *(RwReal *)(v13 + 108) = vPos->z;
  *(const float *)(v13 + 112) = fHeading;
  *(const float *)(v13 + 116) = fSpeed;
  *(_DWORD *)(v13 + 124) = -1;
  *(_BYTE *)(v13 + 120) = v15 | 3;
  *(_QWORD *)(v13 + 100) = v14;
}
// 5261EE: variable 'v13' is possibly undefined
// 66C4E0: using guessed type void *off_66C4E0;

//----- (00526220) --------------------------------------------------------
void __fastcall CTaskSimpleSlideToCoord::~CTaskSimpleSlideToCoord(CTaskSimpleSlideToCoord *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim((CTaskSimpleAnim *)this);
  sub_197118(v1);
}
// 52622C: variable 'v1' is possibly undefined

//----- (00526230) --------------------------------------------------------
bool __fastcall CTaskSimpleSlideToCoord::MakeAbortable(
        CTaskSimpleSlideToCoord *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((_BYTE *)this + 120) & 2) == 0 || sub_18D410((CTaskSimpleAnim *)this, pPed, iPriority, pEvent);
}

//----- (00526244) --------------------------------------------------------
bool __fastcall CTaskSimpleSlideToCoord::ProcessPed(CTaskSimpleSlideToCoord *this, CPed *pPed)
{
  _BOOL4 v4; // r8
  int v5; // r0
  int v6; // r1
  CTaskSimpleStandStill *v7; // r0
  CMatrix *m_pMat; // r0
  float x; // s4
  CSimpleTransform *p_tx; // r1
  float y; // s6
  float v12; // s12
  float v13; // s8
  float v14; // s14
  float v15; // s0
  float m_fSpeed; // s10
  float v17; // s6
  float v18; // s4
  float v19; // s8
  float v20; // s12
  CTaskSimpleStandStill v22; // [sp+8h] [bp-30h] BYREF

  v4 = (*((_BYTE *)this + 120) & 2) == 0 || CTaskSimpleRunNamedAnim::ProcessPed(this, pPed);
  v5 = *((unsigned __int8 *)this + 120);
  if ( this->m_iTimer == -1 )
  {
    if ( (v5 & 2) != 0 )
    {
      if ( !v4 )
        goto LABEL_10;
      v6 = CTimer::m_snTimeInMilliseconds + 500;
    }
    else
    {
      v6 = CTimer::m_snTimeInMilliseconds + 2000;
    }
    this->m_iTimer = v6;
  }
LABEL_10:
  if ( v5 << 31 )
  {
    CTaskSimpleStandStill::CTaskSimpleStandStill(&v22, (const int)&elf_hash_bucket[4937], 0, 0, 8.0);
    CTaskSimpleStandStill::ProcessPed(v7, pPed);
    if ( CPed::IsPlayer(pPed) )
      (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))pPed->m_pPedIntelligence->m_taskManager.m_tasks[4]->_vptr$CTask
       + 7))(
        pPed->m_pPedIntelligence->m_taskManager.m_tasks[4],
        pPed,
        2,
        0);
    pPed->m_fDesiredHeading = this->m_fHeading;
    *((_BYTE *)this + 120) &= ~1u;
    CTaskSimpleStandStill::~CTaskSimpleStandStill(&v22);
  }
  m_pMat = pPed->m_pMat;
  x = this->m_vPos.x;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  y = this->m_vPos.y;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v12 = p_tx->m_translate.y;
  v13 = 0.0;
  v14 = 0.0;
  v15 = (float)((float)((float)(p_tx->m_translate.x - x) * (float)(p_tx->m_translate.x - x))
              + (float)((float)(v12 - y) * (float)(v12 - y)))
      + 0.0;
  if ( v15 >= 0.0025 )
  {
    m_fSpeed = this->m_fSpeed;
    v17 = (float)(y - v12) * m_fSpeed;
    v18 = (float)(x - p_tx->m_translate.x) * m_fSpeed;
    v19 = (float)(this->m_vPos.z - p_tx->m_translate.z) * m_fSpeed;
    v20 = v19 * m_pMat->zy;
    v13 = (float)((float)(v18 * m_pMat->xx) + (float)(v17 * m_pMat->yx)) + (float)(v19 * m_pMat->zx);
    v14 = (float)((float)(v18 * m_pMat->xy) + (float)(v17 * m_pMat->yy)) + v20;
  }
  pPed->m_extractedVelocity.y = v14;
  pPed->m_extractedVelocity.x = v13;
  return this->m_iTimer < CTimer::m_snTimeInMilliseconds
      || v15 < 0.0025
      && v4
      && COERCE_FLOAT(COERCE_UNSIGNED_INT(CGeneral::LimitRadianAngle(pPed->m_fCurrentHeading - pPed->m_fDesiredHeading)) & 0x7FFFFFFF) < 0.1;
}
// 5262B8: variable 'v7' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00526430) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDisturbance::CTaskComplexInvestigateDisturbance(
        CTaskComplexInvestigateDisturbance *this,
        const CVector *vTargetPos,
        CEntity *pSourceEntity)
{
  __int64 v6; // d16
  RwReal z; // r0

  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66C514;
  v6 = *(_QWORD *)&vTargetPos->x;
  z = vTargetPos->z;
  this->m_pSourceEntity = pSourceEntity;
  this->m_vTargetPos.z = z;
  *(_QWORD *)&this->m_vTargetPos.x = v6;
  if ( pSourceEntity )
    CEntity::RegisterReference(pSourceEntity, &this->m_pSourceEntity);
}
// 66C514: using guessed type void *;

//----- (00526478) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDisturbance::~CTaskComplexInvestigateDisturbance(
        CTaskComplexInvestigateDisturbance *this)
{
  CEntity *m_pSourceEntity; // r0
  CEntity **p_m_pSourceEntity; // r1

  p_m_pSourceEntity = &this->m_pSourceEntity;
  m_pSourceEntity = this->m_pSourceEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C514;
  if ( m_pSourceEntity )
    CEntity::CleanUpOldReference(m_pSourceEntity, p_m_pSourceEntity);
  sub_18EDB4(this);
}
// 66C514: using guessed type void *off_66C514;

//----- (005264A4) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDisturbance::~CTaskComplexInvestigateDisturbance(
        CTaskComplexInvestigateDisturbance *this)
{
  CEntity *m_pSourceEntity; // r0
  CEntity **p_m_pSourceEntity; // r1
  void *v4; // r0

  p_m_pSourceEntity = &this->m_pSourceEntity;
  m_pSourceEntity = this->m_pSourceEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C514;
  if ( m_pSourceEntity )
    CEntity::CleanUpOldReference(m_pSourceEntity, p_m_pSourceEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5264CC: variable 'v4' is possibly undefined
// 66C514: using guessed type void *off_66C514;

//----- (005264D4) --------------------------------------------------------
bool __fastcall CTaskComplexInvestigateDisturbance::MakeAbortable(
        CTaskComplexInvestigateDisturbance *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0

  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask )
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
             m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  else
    return 1;
}

//----- (005264F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDisturbance::CreateNextSubTask(
        CTaskComplexInvestigateDisturbance *this,
        CPed *pPed)
{
  int v4; // r0
  char *v5; // r4
  CEntity *m_pSourceEntity; // r8
  char v7; // r3
  __int64 v8; // d16
  float v9; // s0
  char v10; // r1
  __int64 v11; // d16

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 <= 906 )
  {
    if ( v4 == 400 )
    {
      CPed::Say(pPed, 0xCEu, 0, 1.0, 0, 0, 0);
      v5 = (char *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v5,
        ANIM_STD_PED,
        ANIM_STD_XPRESS_SCRATCH,
        4.0,
        421,
        "ScratchHead",
        0);
      *(_DWORD *)v5 = &off_665860;
      return (CTask *)v5;
    }
    if ( v4 != 903 )
      return (CTask *)v5;
    goto LABEL_7;
  }
  if ( v4 == 920 )
  {
    if ( this->m_pSourceEntity )
    {
      v5 = (char *)CTask::operator new(0x58u);
      m_pSourceEntity = this->m_pSourceEntity;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_QWORD *)v5 + 3) = 0x400000003F000000LL;
      *((_QWORD *)v5 + 4) = 0x4000000000000000LL;
      *((_QWORD *)v5 + 2) = 0x3E80000C350LL;
      *((_WORD *)v5 + 24) = 0;
      *((_WORD *)v5 + 30) = 0;
      *((_DWORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 11) = 0;
      *((_DWORD *)v5 + 13) = 0;
      *((_DWORD *)v5 + 14) = 0;
      *((_DWORD *)v5 + 18) = 0;
      *((_DWORD *)v5 + 19) = 0;
      *((_DWORD *)v5 + 20) = 6;
      v7 = v5[84];
      *(_DWORD *)v5 = &off_668A58;
      *((_DWORD *)v5 + 16) = &off_66D3FC;
      v5[84] = v7 & 0xF0 | 3;
      *((_DWORD *)v5 + 17) = 0;
      *((_DWORD *)v5 + 3) = m_pSourceEntity;
      if ( m_pSourceEntity )
        CEntity::RegisterReference(m_pSourceEntity, (CEntity **)v5 + 3);
      v8 = *(_QWORD *)&this->m_vTargetPos.x;
      *((_DWORD *)v5 + 19) = LODWORD(this->m_vTargetPos.z);
      *(_QWORD *)(v5 + 68) = v8;
    }
    else
    {
      v5 = (char *)CTask::operator new(0x28u);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      v9 = *((float *)v5 + 4);
      *((_DWORD *)v5 + 3) = 4;
      v10 = v5[36];
      *(_DWORD *)v5 = &off_66C13C;
      v5[36] = v10 & 0xE4;
      if ( v9 != this->m_vTargetPos.x
        || *((float *)v5 + 5) != this->m_vTargetPos.y
        || *((float *)v5 + 6) != this->m_vTargetPos.z
        || *((float *)v5 + 8) != 2.0 )
      {
        v11 = *(_QWORD *)&this->m_vTargetPos.x;
        *((_DWORD *)v5 + 6) = LODWORD(this->m_vTargetPos.z);
        *((_QWORD *)v5 + 2) = v11;
        *((_DWORD *)v5 + 7) = 1056964608;
        *((_DWORD *)v5 + 8) = 0x40000000;
        v5[36] = v10 & 0xE0 | 4;
      }
    }
  }
  else if ( v4 == 907 )
  {
LABEL_7:
    v5 = (char *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(
      (CTaskSimpleRunAnim *)v5,
      (const AssocGroupId)pPed->m_motionAnimGroup,
      ANIM_STD_ROADCROSS,
      4.0,
      0);
  }
  return (CTask *)v5;
}
// 665860: using guessed type void *off_665860;
// 668A58: using guessed type void *off_668A58;
// 66C13C: using guessed type void *off_66C13C;
// 66D3FC: using guessed type void *off_66D3FC;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;

//----- (005266F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDisturbance::CreateFirstSubTask(
        CTaskComplexInvestigateDisturbance *this,
        CPed *pPed)
{
  CEvent *CurrentEvent; // r0
  CEvent *v5; // r6
  UInt16 v6; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v9; // s0
  RwReal v10; // s4
  CEntity *m_pSourceEntity; // r6
  CTaskComplex *v12; // r0
  CTaskComplex *v13; // r5
  CEntity *v14; // r4
  __int64 v15; // d16
  CVector v17; // [sp+24h] [bp-24h] BYREF

  CurrentEvent = CEventHandlerHistory::GetCurrentEvent(&pPed->m_pPedIntelligence->m_eventHandler.m_history);
  v5 = CurrentEvent;
  if ( CurrentEvent )
  {
    if ( (*((int (__fastcall **)(CEvent *))CurrentEvent->_vptr$CEvent + 2))(CurrentEvent) == 62 )
    {
      if ( (float)((float)((float)rand() * 4.6566e-10) + 0.0) >= 0.2 )
      {
        v6 = 202;
LABEL_9:
        CPed::Say(pPed, v6, 0, 1.0, 0, 0, 0);
        goto LABEL_10;
      }
    }
    else
    {
      if ( (*((int (__fastcall **)(CEvent *))v5->_vptr$CEvent + 2))(v5) != 63 )
        goto LABEL_10;
      if ( (float)((float)((float)rand() * 4.6566e-10) + 0.0) >= 0.2 )
      {
        v6 = 203;
        goto LABEL_9;
      }
    }
    v6 = 204;
    goto LABEL_9;
  }
LABEL_10:
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v9 = this->m_vTargetPos.x - p_tx->m_translate.x;
  v10 = this->m_vTargetPos.z - p_tx->m_translate.z;
  v17.y = this->m_vTargetPos.y - p_tx->m_translate.y;
  v17.x = v9;
  v17.z = v10;
  CVector::Normalise(&v17);
  if ( (float)((float)((float)(v17.x * pPed->m_pMat->xy) + (float)(v17.y * pPed->m_pMat->yy))
             + (float)(v17.z * pPed->m_pMat->zy)) >= 0.707 )
    CPedIntelligence::SetTaskDuckSecondary(pPed->m_pPedIntelligence, 0x1388u);
  else
    IKChainManager_c::LookAt(
      &g_ikChainMan,
      "TaskInvDisturb",
      pPed,
      0,
      5000,
      -1,
      &this->m_vTargetPos,
      0,
      0.25,
      500,
      3,
      0);
  m_pSourceEntity = this->m_pSourceEntity;
  v12 = (CTaskComplex *)CTask::operator new(0x28u);
  v13 = v12;
  if ( m_pSourceEntity )
  {
    v14 = this->m_pSourceEntity;
    CTaskComplex::CTaskComplex(v12);
    LOBYTE(v13[1].m_pParent) = 1;
    v13->_vptr$CTask = (int (**)(void))&off_66C42C;
    v13[1]._vptr$CTask = (int (**)(void))v14;
    if ( v14 )
      CEntity::RegisterReference(v14, (CEntity **)&v13[1]);
  }
  else
  {
    CTaskComplex::CTaskComplex(v12);
    v13[1]._vptr$CTask = 0;
    LOBYTE(v13[1].m_pParent) = 0;
    v13->_vptr$CTask = (int (**)(void))&off_66C42C;
    v15 = *(_QWORD *)&this->m_vTargetPos.x;
    v13[2].m_pParent = (CTask *)LODWORD(this->m_vTargetPos.z);
    *(_QWORD *)&v13[1].m_pSubTask = v15;
  }
  v13[2].m_pSubTask = (CTask *)1077936128;
  v13[3]._vptr$CTask = (int (**)(void))1045220557;
  return v13;
}
// 66C42C: using guessed type void *off_66C42C;

//----- (0052690C) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDisturbance::ControlSubTask(
        CTaskComplexInvestigateDisturbance *this,
        CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (00526910) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRouteShooting::CreateNextSubTask(
        CTaskComplexFollowNodeRouteShooting *this,
        CPed *pPed)
{
  CTask *NextSubTask; // r5
  CTask *TaskSecondary; // r0
  CTask *v6; // r6

  NextSubTask = CTaskComplexFollowNodeRoute::CreateNextSubTask(this, pPed);
  if ( !NextSubTask )
  {
    TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
    v6 = TaskSecondary;
    if ( TaskSecondary )
    {
      if ( (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
        (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))v6->_vptr$CTask + 7))(v6, pPed, 1, 0);
    }
  }
  return NextSubTask;
}

//----- (00526960) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRouteShooting::CreateFirstSubTask(
        CTaskComplexFollowNodeRouteShooting *this,
        CPed *pPed)
{
  unsigned __int64 v2; // r2

  v2 = CTimer::m_snTimeInMilliseconds | 0xFFFFFFFF00000000LL;
  this->m_gunTimer.m_bIsActive = 1;
  *(_QWORD *)&this->m_gunTimer.m_iStartTime = v2;
  return CTaskComplexFollowNodeRoute::CreateFirstSubTask(this, pPed);
}

//----- (00526980) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRouteShooting::ControlSubTask(
        CTaskComplexFollowNodeRouteShooting *this,
        CPed *pPed)
{
  CTask *TaskSecondary; // r0
  CTaskSimpleUseGun *v5; // r6
  __int64 v6; // r0
  unsigned int v7; // r0
  int m_iStartTime; // r1
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r0
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskSimpleUseGun *v12; // r6
  CPed *m_pTargetPed; // r2
  CTaskSimpleUseGun *v14; // r0
  CPed *v15; // r1
  int8 v16; // r3
  CVector v18; // 0:r2.8,8:^0.4

  if ( this->m_pTargetPed )
  {
    TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
    v5 = (CTaskSimpleUseGun *)TaskSecondary;
    if ( TaskSecondary )
    {
      if ( (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
      {
        if ( this->m_gunTimer.m_bIsActive
          && (!this->m_gunTimer.m_bIsStopped ? (HIDWORD(v6) = this->m_gunTimer.m_iStartTime,
                                                LODWORD(v6) = CTimer::m_snTimeInMilliseconds) : (LODWORD(v6) = CTimer::m_snTimeInMilliseconds,
                                                                                                 this->m_gunTimer.m_bIsStopped = 0,
                                                                                                 this->m_gunTimer.m_iStartTime = v6,
                                                                                                 HIDWORD(v6) = v6),
              HIDWORD(v6) + this->m_gunTimer.m_iDuration <= (unsigned int)v6) )
        {
          if ( v5->m_nLastCommand != 3 )
            return CTaskComplexFollowNodeRoute::ControlSubTask(this, pPed);
          v16 = 6;
          m_pTargetPed = this->m_pTargetPed;
          HIDWORD(v6) = CTaskComplexFollowNodeRouteShooting::ms_iShootRecoverTime;
          *(_QWORD *)&this->m_gunTimer.m_iStartTime = v6;
          this->m_gunTimer.m_bIsActive = 1;
          v14 = v5;
          v15 = pPed;
        }
        else
        {
          m_pTargetPed = this->m_pTargetPed;
          v14 = v5;
          v15 = pPed;
          v16 = 3;
        }
        CTaskSimpleUseGun::ControlGun(v14, v15, m_pTargetPed, v16);
      }
    }
    else if ( this->m_gunTimer.m_bIsActive )
    {
      if ( this->m_gunTimer.m_bIsStopped )
      {
        v7 = CTimer::m_snTimeInMilliseconds;
        this->m_gunTimer.m_bIsStopped = 0;
        this->m_gunTimer.m_iStartTime = v7;
        m_iStartTime = v7;
      }
      else
      {
        m_iStartTime = this->m_gunTimer.m_iStartTime;
        v7 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_gunTimer.m_iDuration <= v7 )
      {
        m_eWeaponType = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
        WeaponSkill = CPed::GetWeaponSkill(pPed);
        if ( (CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill)->m_nFlags & 2) != 0 )
        {
          *(_QWORD *)&this->m_gunTimer.m_iStartTime = __PAIR64__(
                                                        CTaskComplexFollowNodeRouteShooting::ms_iShootTime,
                                                        CTimer::m_snTimeInMilliseconds);
          this->m_gunTimer.m_bIsActive = 1;
          m_pPedIntelligence = pPed->m_pPedIntelligence;
          v12 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
          v18.z = 0.0;
          *(_QWORD *)&v18.x = 0LL;
          CTaskSimpleUseGun::CTaskSimpleUseGun(v12, this->m_pTargetPed, v18, 3, 3, 0);
          CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v12, 0);
        }
      }
    }
  }
  return CTaskComplexFollowNodeRoute::ControlSubTask(this, pPed);
}

//----- (00526AF0) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAiming::~CTaskComplexGoToPointAiming(CTaskComplexGoToPointAiming *this)
{
  CEntity *m_pAimEntity; // r0
  CEntity **p_m_pAimEntity; // r1

  p_m_pAimEntity = &this->m_pAimEntity;
  m_pAimEntity = this->m_pAimEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C1B4;
  if ( m_pAimEntity )
    CEntity::CleanUpOldReference(m_pAimEntity, p_m_pAimEntity);
  sub_18EDB4(this);
}
// 66C1B4: using guessed type void *off_66C1B4;

//----- (00526B24) --------------------------------------------------------
void __fastcall CPatrolRoute::Reverse(CPatrolRoute *this)
{
  int m_iRouteSize; // r0
  int v3; // r6
  int v4; // r3
  int v5; // r2
  int v6; // r1
  int v7; // r0
  char *v8; // r4
  char *v9; // r0
  char *v10; // r5
  char *v11; // r1
  __int64 v12; // d16
  int v13; // [sp+4h] [bp-74h]
  int v14; // [sp+8h] [bp-70h]
  int v15; // [sp+10h] [bp-68h]
  int v16; // [sp+14h] [bp-64h]
  int v17; // [sp+18h] [bp-60h]
  int v18; // [sp+1Ch] [bp-5Ch]
  __int64 v19; // [sp+20h] [bp-58h]
  int v20; // [sp+28h] [bp-50h]
  char v21[24]; // [sp+30h] [bp-48h] BYREF
  char v22[16]; // [sp+48h] [bp-30h] BYREF

  m_iRouteSize = this->m_iRouteSize;
  if ( m_iRouteSize >= 2 )
  {
    v3 = 324;
    v4 = 0;
    v18 = 40 * m_iRouteSize - 36;
    v17 = 40 * m_iRouteSize - 12;
    v5 = 12 * m_iRouteSize + 312;
    v6 = m_iRouteSize - 1;
    v7 = 1;
    do
    {
      v8 = (char *)this + v4;
      v13 = v7;
      v14 = v4;
      v9 = (char *)this + v3;
      v10 = (char *)this->m_anims + v4;
      v15 = v6;
      v16 = v5;
      v20 = *(_DWORD *)&this->m_anims[0].m_animName[v3 + 4];
      v11 = (char *)this + v5;
      v19 = *(_QWORD *)((char *)&this->m_iRouteSize + v3);
      v12 = *(_QWORD *)((char *)&this->m_iRouteSize + v5);
      *((_DWORD *)v9 + 2) = *(_DWORD *)&this->m_anims[0].m_animName[v5 + 4];
      *(_QWORD *)v9 = v12;
      *((_DWORD *)v11 + 2) = v20;
      *(_QWORD *)v11 = v19;
      strcpy(v21, v10);
      strcpy(v22, v8 + 28);
      strcpy(v10, (const char *)this + v18);
      strcpy(v8 + 28, (const char *)this + v17);
      strcpy((char *)this + v18, v21);
      strcpy((char *)this + v17, v22);
      v3 += 12;
      v4 = v14 + 40;
      v6 = v15 - 1;
      v5 = v16 - 12;
      v7 = v13 + 1;
      v18 -= 40;
      v17 -= 40;
    }
    while ( v13 < v15 - 1 );
  }
}

//----- (00526C48) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointUntilCollisionAndStandStill::~CTaskComplexGoToPointUntilCollisionAndStandStill(
        CTaskComplexGoToPointUntilCollisionAndStandStill *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 526C54: variable 'v1' is possibly undefined

//----- (00526C58) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointUntilCollisionAndStandStill::Clone(
        const CTaskComplexGoToPointUntilCollisionAndStandStill *this)
{
  CTaskComplex *v2; // r0
  float m_fSlowDownDistance; // s16
  float m_fTargetRadius; // r5
  CTask *m_iMoveState; // r6
  CTask *result; // r0
  char m_pParent; // r2
  int (**v8)(void); // s0
  CTask v9; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x28u);
  m_fSlowDownDistance = this->m_fSlowDownDistance;
  m_fTargetRadius = this->m_fTargetRadius;
  m_iMoveState = (CTask *)this->m_iMoveState;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iMoveState;
  m_pParent = (char)result[4].m_pParent;
  v8 = result[2]._vptr$CTask;
  result->_vptr$CTask = (int (**)(void))&off_66C13C;
  LOBYTE(result[4].m_pParent) = m_pParent & 0xE4;
  if ( *(float *)&v8 != this->m_vTarget.x
    || *(float *)&result[2].m_pParent != this->m_vTarget.y
    || *(float *)&result[3]._vptr$CTask != this->m_vTarget.z
    || *(float *)&result[4]._vptr$CTask != m_fSlowDownDistance )
  {
    v9 = *(CTask *)&this->m_vTarget.x;
    result[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTarget.z);
    result[2] = v9;
    *(float *)&result[4]._vptr$CTask = m_fSlowDownDistance;
    *(float *)&result[3].m_pParent = m_fTargetRadius;
    LOBYTE(result[4].m_pParent) = m_pParent & 0xE0 | 4;
  }
  result->_vptr$CTask = (int (**)(void))&off_66C550;
  return result;
}
// 526C7A: variable 'result' is possibly undefined
// 66C13C: using guessed type void *off_66C13C;
// 66C550: using guessed type void *;

//----- (00526D14) --------------------------------------------------------
int __fastcall CTaskComplexGoToPointAndStandStill::GetTaskType(const CTaskComplexGoToPointAndStandStill *this)
{
  return 903;
}

//----- (00526D1C) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStill::Serialize(CTaskComplexGoToPointAndStandStill *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  __int64 v6; // d16
  float m_fTargetRadius; // r6
  float *v8; // r5
  float m_fSlowDownDistance; // r5
  float *v10; // r4
  int v11; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexGoToPointAndStandStill *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoToPointAndStandStill *))this->_vptr$CTask + 5))(this) == 903 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(0xCu);
    v6 = *(_QWORD *)&this->m_vTarget.x;
    v5[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v5 = v6;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 12);
    free(v5);
    m_fTargetRadius = this->m_fTargetRadius;
    if ( UseDataFence )
      AddDataFence();
    v8 = (float *)malloc(4u);
    *v8 = m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    m_fSlowDownDistance = this->m_fSlowDownDistance;
    if ( UseDataFence )
      AddDataFence();
    v10 = (float *)malloc(4u);
    *v10 = m_fSlowDownDistance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v11 = (*((int (__fastcall **)(CTaskComplexGoToPointAndStandStill *))this->_vptr$CTask + 5))(this);
    sub_1941C4(903, v11);
  }
}

//----- (00526E4C) --------------------------------------------------------
void __fastcall CTaskComplexWanderStandard::~CTaskComplexWanderStandard(CTaskComplexWanderStandard *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 526E58: variable 'v1' is possibly undefined

//----- (00526E5C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderStandard::Clone(const CTaskComplexWanderStandard *this)
{
  CTaskComplex *v2; // r0
  char v3; // r5
  CTask *m_iMoveState; // r6
  CTask *result; // r0
  int m_pParent_low; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  v3 = *((_BYTE *)&this->CTaskComplexWander + 36);
  m_iMoveState = (CTask *)this->m_iMoveState;
  LOBYTE(this) = this->m_iDir;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  result[1].m_pParent = m_iMoveState;
  result[2].m_pParent = (CTask *)1056964608;
  LOWORD(result[3]._vptr$CTask) = -1;
  LOWORD(result[3].m_pParent) = -1;
  result[4]._vptr$CTask = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[6].m_pParent = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  m_pParent_low = LOBYTE(result[4].m_pParent);
  result->_vptr$CTask = (int (**)(void))&off_66C58C;
  LOBYTE(result[4].m_pParent) = v3 & 1 | m_pParent_low & 0xF0;
  return result;
}
// 526E7E: variable 'result' is possibly undefined
// 66C58C: using guessed type void *off_66C58C;
// 677A94: using guessed type void *`vtable for'CTaskComplexWanderStandard;

//----- (00526EBC) --------------------------------------------------------
int __fastcall CTaskComplexWanderStandard::GetWanderType(const CTaskComplexWanderStandard *this)
{
  return 0;
}

//----- (00526EC0) --------------------------------------------------------
void __fastcall CTaskComplexWanderCop::~CTaskComplexWanderCop(CTaskComplexWanderCop *this)
{
  CTask *m_pTaskToPerform; // r0
  void *v3; // r0

  m_pTaskToPerform = this->m_pTaskToPerform;
  this->_vptr$CTask = (int (**)(void))&off_66C5D8;
  if ( m_pTaskToPerform )
    (*((void (__fastcall **)(CTask *))m_pTaskToPerform->_vptr$CTask + 1))(m_pTaskToPerform);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v3);
}
// 526EE6: variable 'v3' is possibly undefined
// 66C5D8: using guessed type void *off_66C5D8;

//----- (00526EF0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderCop::Clone(const CTaskComplexWanderCop *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iMoveState; // r5
  CTask *result; // r0
  char m_pParent; // r3

  v2 = (CTaskComplex *)CTask::operator new(0x50u);
  m_iMoveState = (CTask *)this->m_iMoveState;
  LOBYTE(this) = this->m_iDir;
  CTaskComplex::CTaskComplex(v2);
  result[7] = 0LL;
  result[8] = 0LL;
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  result[1].m_pParent = m_iMoveState;
  result[2].m_pParent = (CTask *)1056964608;
  LOWORD(result[3]._vptr$CTask) = -1;
  LOWORD(result[3].m_pParent) = -1;
  result[4]._vptr$CTask = 0;
  *(int (***)(void))((char *)&result[6]._vptr$CTask + 2) = 0;
  *(CTask **)((char *)&result[5].m_pParent + 2) = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  *(int (***)(void))((char *)&result[9]._vptr$CTask + 2) = 0;
  m_pParent = (char)result[4].m_pParent;
  *(CTask **)((char *)&result[8].m_pParent + 2) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C5D8;
  LOBYTE(result[4].m_pParent) = m_pParent & 0xF0 | 1;
  return result;
}
// 526F08: variable 'result' is possibly undefined
// 66C5D8: using guessed type void *off_66C5D8;

//----- (00526F5C) --------------------------------------------------------
void __fastcall CTaskComplexWanderCriminal::~CTaskComplexWanderCriminal(CTaskComplexWanderCriminal *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 526F68: variable 'v1' is possibly undefined

//----- (00526F6C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderCriminal::Clone(const CTaskComplexWanderCriminal *this)
{
  CTaskComplex *v2; // r0
  char v3; // r5
  CTask *m_iMoveState; // r6
  CTask *result; // r0
  int m_pParent_low; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  v3 = *((_BYTE *)&this->CTaskComplexWander + 36);
  m_iMoveState = (CTask *)this->m_iMoveState;
  LOBYTE(this) = this->m_iDir;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  result[1].m_pParent = m_iMoveState;
  result[2].m_pParent = (CTask *)1056964608;
  LOWORD(result[3]._vptr$CTask) = -1;
  LOWORD(result[3].m_pParent) = -1;
  result[4]._vptr$CTask = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[6].m_pParent = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  m_pParent_low = LOBYTE(result[4].m_pParent);
  result->_vptr$CTask = (int (**)(void))&off_66C624;
  LOBYTE(result[4].m_pParent) = v3 & 1 | m_pParent_low & 0xF0;
  return result;
}
// 526F8E: variable 'result' is possibly undefined
// 66C624: using guessed type void *off_66C624;
// 6783D4: using guessed type void *`vtable for'CTaskComplexWanderCriminal;

//----- (00526FCC) --------------------------------------------------------
int __fastcall CTaskComplexWanderCriminal::GetWanderType(const CTaskComplexWanderCriminal *this)
{
  return 3;
}

//----- (00526FD0) --------------------------------------------------------
void __fastcall CTaskComplexWanderProstitute::~CTaskComplexWanderProstitute(CTaskComplexWanderProstitute *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 526FDC: variable 'v1' is possibly undefined

//----- (00526FE0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderProstitute::Clone(const CTaskComplexWanderProstitute *this)
{
  CTaskComplex *v2; // r0
  char v3; // r5
  CTask *m_iMoveState; // r6
  CTask *result; // r0
  int m_pParent_low; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x3Cu);
  v3 = *((_BYTE *)&this->CTaskComplexWander + 36);
  m_iMoveState = (CTask *)this->m_iMoveState;
  LOBYTE(this) = this->m_iDir;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  result[1].m_pParent = m_iMoveState;
  result[2].m_pParent = (CTask *)1056964608;
  LOWORD(result[3]._vptr$CTask) = -1;
  LOWORD(result[3].m_pParent) = -1;
  result[4]._vptr$CTask = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[6].m_pParent = 0;
  result[7]._vptr$CTask = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  m_pParent_low = LOBYTE(result[4].m_pParent);
  result->_vptr$CTask = (int (**)(void))&off_66C368;
  LOBYTE(result[4].m_pParent) = v3 & 1 | m_pParent_low & 0xF0;
  return result;
}
// 527002: variable 'result' is possibly undefined
// 66C368: using guessed type void *off_66C368;

//----- (00527044) --------------------------------------------------------
int __fastcall CTaskComplexWanderProstitute::GetWanderType(const CTaskComplexWanderProstitute *this)
{
  return 7;
}

//----- (00527048) --------------------------------------------------------
void __fastcall CTaskComplexUseEntryExit::~CTaskComplexUseEntryExit(CTaskComplexUseEntryExit *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 527054: variable 'v1' is possibly undefined

//----- (00527058) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEntryExit::Clone(const CTaskComplexUseEntryExit *this)
{
  CTaskComplex *v2; // r0
  CEntryExit *m_pEE; // r4
  CTask *result; // r0
  char m_pParent; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  m_pEE = this->m_pEE;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = (CTask *)m_pEE;
  result[2]._vptr$CTask = 0;
  m_pParent = (char)result[2].m_pParent;
  result->_vptr$CTask = (int (**)(void))&off_66C670;
  LOBYTE(result[2].m_pParent) = m_pParent & 0xFE;
  return result;
}
// 52706E: variable 'result' is possibly undefined
// 66C670: using guessed type void *;

//----- (00527088) --------------------------------------------------------
int __fastcall CTaskComplexUseEntryExit::GetTaskType(const CTaskComplexUseEntryExit *this)
{
  return 938;
}

//----- (00527090) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRouteShooting::~CTaskComplexFollowNodeRouteShooting(
        CTaskComplexFollowNodeRouteShooting *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  CPointRoute *m_pPointRoute; // r0
  CNodeRoute *m_pNodeRoute; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66C6AC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  m_pPointRoute = this->m_pPointRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C268;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  m_pNodeRoute = this->m_pNodeRoute;
  if ( m_pNodeRoute )
    CNodeRoute::operator delete(m_pNodeRoute);
  sub_18EDB4(this);
}
// 66C268: using guessed type void *off_66C268;
// 66C6AC: using guessed type void *;

//----- (005270E0) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRouteShooting::~CTaskComplexFollowNodeRouteShooting(
        CTaskComplexFollowNodeRouteShooting *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  CPointRoute *m_pPointRoute; // r0
  CNodeRoute *m_pNodeRoute; // r0
  void *v6; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66C6AC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  m_pPointRoute = this->m_pPointRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C268;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  m_pNodeRoute = this->m_pNodeRoute;
  if ( m_pNodeRoute )
    CNodeRoute::operator delete(m_pNodeRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 527126: variable 'v6' is possibly undefined
// 66C268: using guessed type void *off_66C268;
// 66C6AC: using guessed type void *off_66C6AC;

//----- (00527134) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRouteShooting::Clone(const CTaskComplexFollowNodeRouteShooting *this)
{
  char *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CPed *m_pTargetPed; // r9
  char v6; // r11
  int m_iTime; // r4
  int *v8; // r8
  RwReal z; // r0
  __int64 v10; // d18
  char v11; // r1
  _DWORD *v12; // r0
  _WORD *v13; // r0
  CNodeAddress v14; // r0

  v2 = (char *)CTask::operator new(0x70u);
  v3 = *(_QWORD *)&this->m_iMoveState;
  v4 = *(_QWORD *)&this->m_fSlowDownDistance;
  m_pTargetPed = this->m_pTargetPed;
  v6 = *((_BYTE *)&this->CTaskComplexFollowNodeRoute + 76);
  m_iTime = this->m_iTime;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  v8 = (int *)(v2 + 24);
  *(_DWORD *)v2 = &off_66C268;
  z = this->m_vTarget.z;
  v10 = *(_QWORD *)&this->m_vTarget.x;
  v11 = v2[76] & 0x96;
  *((_QWORD *)v2 + 3) = v3;
  *((_QWORD *)v2 + 4) = v4;
  *((_QWORD *)v2 + 10) = 0LL;
  *((_QWORD *)v2 + 11) = 0LL;
  *((RwReal *)v2 + 5) = z;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 15) = m_iTime;
  *((_WORD *)v2 + 20) = -1;
  *((_WORD *)v2 + 26) = -1;
  *((_WORD *)v2 + 36) = 0;
  *((_DWORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 17) = 0;
  *(_QWORD *)(v2 + 12) = v10;
  v2[76] = v6 & 1 | v11 | 8;
  v12 = CPointRoute::operator new(0x64u);
  *v12 = 0;
  *((_DWORD *)v2 + 12) = v12;
  v13 = CNodeRoute::operator new(0x24u);
  *(_DWORD *)v13 = 0;
  v13[2] = -1;
  v13[4] = -1;
  v13[6] = -1;
  v13[8] = -1;
  v13[10] = -1;
  v13[12] = -1;
  v13[14] = -1;
  v13[16] = -1;
  *((_WORD *)v2 + 26) = -1;
  *((_DWORD *)v2 + 11) = v13;
  v14 = EmptyNodeAddress;
  *(_DWORD *)v2 = &off_66C6AC;
  *((CNodeAddress *)v2 + 10) = v14;
  *((_WORD *)v2 + 54) = 0;
  *((_DWORD *)v2 + 25) = 0;
  *((_DWORD *)v2 + 26) = 0;
  *((_DWORD *)v2 + 24) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 24);
  if ( *v8 >= 7 )
    *v8 = 6;
  *((_DWORD *)v2 + 10) = this->m_startNode;
  return (CTask *)v2;
}
// 66C268: using guessed type void *off_66C268;
// 66C6AC: using guessed type void *off_66C6AC;

//----- (00527244) --------------------------------------------------------
int __fastcall CTaskComplexFollowNodeRouteShooting::GetTaskType(const CTaskComplexFollowNodeRouteShooting *this)
{
  return 937;
}

//----- (0052724C) --------------------------------------------------------
void __fastcall CTaskComplexFollowNodeRoute::Serialize(CTaskComplexFollowNodeRoute *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  __int64 v6; // d16
  float *v7; // r5
  float *v8; // r5
  float *v9; // r5
  int v10; // r6
  _DWORD *v11; // r5
  _DWORD *v12; // r5
  int v13; // r5
  _DWORD *v14; // r4
  int v15; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexFollowNodeRoute *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFollowNodeRoute *))this->_vptr$CTask + 5))(this) == 906 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(0xCu);
    v6 = *(_QWORD *)&this->m_vTarget.x;
    v5[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v5 = v6;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 12);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v7 = (float *)malloc(4u);
    *v7 = this->m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v8 = (float *)malloc(4u);
    *v8 = this->m_fSlowDownDistance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    if ( UseDataFence )
      AddDataFence();
    v9 = (float *)malloc(4u);
    *v9 = this->m_fFollowNodeThresholdHeightChange;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    free(v9);
    v10 = *((_BYTE *)this + 76) & 1;
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    v12 = malloc(4u);
    *v12 = this->m_iTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    free(v12);
    v13 = (*((unsigned __int8 *)this + 76) >> 3) & 1;
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(4u);
    *v14 = v13;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
    j_free(v14);
  }
  else
  {
    v15 = (*((int (__fastcall **)(CTaskComplexFollowNodeRoute *))this->_vptr$CTask + 5))(this);
    sub_1941C4(906, v15);
  }
}

//----- (00527444) --------------------------------------------------------
CTask *__fastcall CTaskSimpleGoToPoint::Clone(const CTaskSimpleGoToPoint *this)
{
  CTaskSimple *v2; // r0
  int m_iMoveState; // r5
  float m_fTargetRadius; // r6
  char v5; // r8
  CTask *result; // r0
  __int64 v7; // d16
  char m_pParent; // r3

  v2 = (CTaskSimple *)CTask::operator new(0x2Cu);
  m_iMoveState = this->m_iMoveState;
  m_fTargetRadius = this->m_fTargetRadius;
  v5 = *((_BYTE *)this + 29);
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = (int (**)(void))m_iMoveState;
  result->_vptr$CTask = (int (**)(void))&off_66C0A0;
  LOBYTE(m_iMoveState) = BYTE1(result[3].m_pParent);
  v7 = *(_QWORD *)&this->m_vTarget.x;
  m_pParent = (char)result[3].m_pParent;
  result[2].m_pParent = (CTask *)LODWORD(this->m_vTarget.z);
  result->_vptr$CTask = (int (**)(void))&off_66C0D4;
  *(float *)&result[3]._vptr$CTask = m_fTargetRadius;
  BYTE1(result[3].m_pParent) = v5 & 9 | m_iMoveState & 0xE0;
  LOBYTE(result[3].m_pParent) = m_pParent & 0xC0;
  *(_QWORD *)&result[1].m_pParent = v7;
  return result;
}
// 527466: variable 'result' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (005274AC) --------------------------------------------------------
int __fastcall CTaskSimpleGoToPoint::GetTaskType(const CTaskSimpleGoToPoint *this)
{
  return 900;
}

//----- (005274B4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleAchieveHeading::Clone(const CTaskSimpleAchieveHeading *this)
{
  CTaskSimple *v2; // r0
  CTask v3; // kr00_8
  float m_fHeadingTolerance; // r4
  CTask *result; // r0
  char m_pParent; // r2

  v2 = (CTaskSimple *)CTask::operator new(0x18u);
  v3 = *(CTask *)&this->m_fDesiredHeading;
  m_fHeadingTolerance = this->m_fHeadingTolerance;
  CTaskSimple::CTaskSimple(v2);
  result[1] = v3;
  *(float *)&result[2]._vptr$CTask = m_fHeadingTolerance;
  m_pParent = (char)result[2].m_pParent;
  result->_vptr$CTask = (int (**)(void))&off_66C108;
  LOBYTE(result[2].m_pParent) = m_pParent & 0xFE;
  return result;
}
// 5274D0: variable 'result' is possibly undefined
// 66C108: using guessed type void *off_66C108;

//----- (005274F0) --------------------------------------------------------
int __fastcall CTaskSimpleAchieveHeading::GetTaskType(const CTaskSimpleAchieveHeading *this)
{
  return 902;
}

//----- (005274F8) --------------------------------------------------------
void __fastcall CTaskSimpleAchieveHeading::Serialize(CTaskSimpleAchieveHeading *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  float *v4; // r5
  float *v5; // r5
  float *v6; // r5
  int v7; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleAchieveHeading *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleAchieveHeading *))this->_vptr$CTask + 5))(this) == 902 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = (float *)malloc(4u);
    *v4 = this->m_fDesiredHeading;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = (float *)malloc(4u);
    *v5 = this->m_fHeadingChangeRateFrac;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = (float *)malloc(4u);
    *v6 = this->m_fHeadingTolerance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    j_free(v6);
  }
  else
  {
    v7 = (*((int (__fastcall **)(CTaskSimpleAchieveHeading *))this->_vptr$CTask + 5))(this);
    sub_1941C4(902, v7);
  }
}

//----- (005275F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStill::Clone(const CTaskComplexGoToPointAndStandStill *this)
{
  CTaskComplex *v2; // r0
  float m_fSlowDownDistance; // s16
  float m_fTargetRadius; // r8
  char v5; // r6
  CTask *m_iMoveState; // r5
  CTask *result; // r0
  int (**v8)(void); // s0
  char v9; // r2
  char v10; // r1
  CTask v11; // d16
  CTask *m_pParent; // s0
  float v13; // s2

  v2 = (CTaskComplex *)CTask::operator new(0x28u);
  m_fSlowDownDistance = this->m_fSlowDownDistance;
  m_fTargetRadius = this->m_fTargetRadius;
  v5 = *((_BYTE *)this + 36);
  m_iMoveState = (CTask *)this->m_iMoveState;
  CTaskComplex::CTaskComplex(v2);
  v8 = result[2]._vptr$CTask;
  result[1].m_pParent = m_iMoveState;
  v9 = (int)result[4].m_pParent & 0xE4;
  result->_vptr$CTask = (int (**)(void))&off_66C13C;
  v10 = v5 & 3 | v9;
  LOBYTE(result[4].m_pParent) = v10;
  if ( *(float *)&v8 != this->m_vTarget.x
    || *(float *)&result[2].m_pParent != this->m_vTarget.y
    || *(float *)&result[3]._vptr$CTask != this->m_vTarget.z
    || *(float *)&result[4]._vptr$CTask != m_fSlowDownDistance )
  {
    v10 |= 4u;
    v11 = *(CTask *)&this->m_vTarget.x;
    result[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTarget.z);
    result[2] = v11;
    *(float *)&result[4]._vptr$CTask = m_fSlowDownDistance;
    *(float *)&result[3].m_pParent = m_fTargetRadius;
    LOBYTE(result[4].m_pParent) = v10;
  }
  if ( (v10 & 2) != 0 )
  {
    m_pParent = result[3].m_pParent;
    LOBYTE(result[4].m_pParent) = v10 & 0xFE;
    if ( (int)m_iMoveState >= 5 )
      v13 = 1.0;
    else
      v13 = 0.5;
    if ( *(float *)&m_pParent >= v13 )
      v13 = *(float *)&m_pParent;
    result[4]._vptr$CTask = 0;
    *(float *)&result[3].m_pParent = v13;
  }
  return result;
}
// 52761C: variable 'result' is possibly undefined
// 66C13C: using guessed type void *off_66C13C;

//----- (005276E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillTimed::Clone(const CTaskComplexGoToPointAndStandStillTimed *this)
{
  CTaskComplex *v2; // r0
  int (**m_iTime)(void); // r8
  float m_fSlowDownDistance; // s16
  float m_fTargetRadius; // r6
  CTask *m_iMoveState; // r5
  CTask *result; // r0
  char m_pParent; // r2
  int (**v9)(void); // s0
  CTask v10; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  m_iTime = (int (**)(void))this->m_iTime;
  m_fSlowDownDistance = this->m_fSlowDownDistance;
  m_fTargetRadius = this->m_fTargetRadius;
  m_iMoveState = (CTask *)this->m_iMoveState;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iMoveState;
  m_pParent = (char)result[4].m_pParent;
  v9 = result[2]._vptr$CTask;
  result->_vptr$CTask = (int (**)(void))&off_66C13C;
  LOBYTE(result[4].m_pParent) = m_pParent & 0xE4;
  if ( *(float *)&v9 != this->m_vTarget.x
    || *(float *)&result[2].m_pParent != this->m_vTarget.y
    || *(float *)&result[3]._vptr$CTask != this->m_vTarget.z
    || *(float *)&result[4]._vptr$CTask != m_fSlowDownDistance )
  {
    v10 = *(CTask *)&this->m_vTarget.x;
    result[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTarget.z);
    result[2] = v10;
    *(float *)&result[4]._vptr$CTask = m_fSlowDownDistance;
    *(float *)&result[3].m_pParent = m_fTargetRadius;
    LOBYTE(result[4].m_pParent) = m_pParent & 0xE0 | 4;
  }
  result[5]._vptr$CTask = m_iTime;
  LOWORD(result[6].m_pParent) = 0;
  result[5].m_pParent = 0;
  result[6]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C178;
  return result;
}
// 527706: variable 'result' is possibly undefined
// 66C13C: using guessed type void *off_66C13C;
// 66C178: using guessed type void *off_66C178;

//----- (005277AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAiming::Clone(const CTaskComplexGoToPointAiming *this)
{
  CTaskComplex *v2; // r0
  float m_fMoveTargetRadius; // s16
  float m_fSlowDownDistance; // s18
  CTaskComplex *v5; // r4
  __int64 v6; // kr00_8
  RwReal x; // r9
  RwReal y; // r10
  RwReal z; // r11
  CVector *p_m_vecMovePos; // r8
  __int64 v11; // d16
  char m_pParent; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  m_fMoveTargetRadius = this->m_fMoveTargetRadius;
  m_fSlowDownDistance = this->m_fSlowDownDistance;
  v5 = v2;
  v6 = *(_QWORD *)&this->m_iMoveState;
  x = this->m_vecAimPos.x;
  y = this->m_vecAimPos.y;
  z = this->m_vecAimPos.z;
  CTaskComplex::CTaskComplex(v2);
  v5[1]._vptr$CTask = (int (**)(void))v6;
  *(RwReal *)&v5[1].m_pSubTask = x;
  *(RwReal *)&v5[2]._vptr$CTask = y;
  *(RwReal *)&v5[2].m_pParent = z;
  p_m_vecMovePos = &this->m_vecMovePos;
  v5->_vptr$CTask = (int (**)(void))&off_66C1B4;
  v5[1].m_pParent = (CTask *)HIDWORD(v6);
  if ( HIDWORD(v6) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v6), (CEntity **)&v5[1].m_pParent);
  if ( *(float *)&v5[2].m_pSubTask != p_m_vecMovePos->x
    || *(float *)&v5[3]._vptr$CTask != this->m_vecMovePos.y
    || *(float *)&v5[3].m_pParent != this->m_vecMovePos.z
    || *(float *)&v5[3].m_pSubTask != m_fMoveTargetRadius
    || *(float *)&v5[4]._vptr$CTask != m_fSlowDownDistance )
  {
    v11 = *(_QWORD *)&p_m_vecMovePos->x;
    v5[3].m_pParent = (CTask *)LODWORD(this->m_vecMovePos.z);
    *(_QWORD *)&v5[2].m_pSubTask = v11;
    m_pParent = (char)v5[4].m_pParent;
    *(float *)&v5[3].m_pSubTask = m_fMoveTargetRadius;
    *(float *)&v5[4]._vptr$CTask = m_fSlowDownDistance;
    LOBYTE(v5[4].m_pParent) = m_pParent | 1;
  }
  return v5;
}
// 66C1B4: using guessed type void *off_66C1B4;

//----- (00527894) --------------------------------------------------------
int __fastcall CTaskComplexGoToPointAiming::GetTaskType(const CTaskComplexGoToPointAiming *this)
{
  return 924;
}

//----- (0052789C) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAiming::Serialize(CTaskComplexGoToPointAiming *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  CEntity *m_pAimEntity; // r0
  int v6; // r6
  _DWORD *v7; // r5
  CEntity *v8; // r0
  int v9; // r1
  int v10; // r5
  int v11; // r0
  _DWORD *v12; // r5
  void *v13; // r0
  _DWORD *v14; // r6
  _DWORD *v15; // r5
  __int64 v16; // d16
  _DWORD *v17; // r5
  __int64 v18; // d16

  v2 = (*((int (__fastcall **)(CTaskComplexGoToPointAiming *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoToPointAiming *))this->_vptr$CTask + 5))(this) != 924 )
  {
    v11 = (*((int (__fastcall **)(CTaskComplexGoToPointAiming *))this->_vptr$CTask + 5))(this);
    sub_1941C4(924, v11);
    return;
  }
  if ( UseDataFence )
    AddDataFence();
  v4 = malloc(4u);
  *v4 = this->m_iMoveState;
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
  free(v4);
  m_pAimEntity = this->m_pAimEntity;
  if ( !m_pAimEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v12 = malloc(4u);
    *v12 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    v13 = v12;
    goto LABEL_22;
  }
  v6 = *(_BYTE *)&m_pAimEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v7 = malloc(4u);
  *v7 = v6;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  v8 = this->m_pAimEntity;
  v9 = *(_BYTE *)&v8->m_info & 7;
  switch ( v9 )
  {
    case 2:
      v10 = GettPoolVehicleRef((CVehicle *)v8);
      goto LABEL_19;
    case 4:
      v10 = GettPoolObjRef((CObject *)v8);
      goto LABEL_19;
    case 3:
      v10 = GettPoolPedRef((CPed *)v8);
LABEL_19:
      if ( UseDataFence )
        AddDataFence();
      v14 = malloc(4u);
      *v14 = v10;
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      v13 = v14;
LABEL_22:
      free(v13);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v15 = malloc(0xCu);
  v16 = *(_QWORD *)&this->m_vecAimPos.x;
  v15[2] = LODWORD(this->m_vecAimPos.z);
  *(_QWORD *)v15 = v16;
  CGenericGameStorage::_SaveDataToWorkBuffer(v15, 12);
  free(v15);
  if ( UseDataFence )
    AddDataFence();
  v17 = malloc(0xCu);
  v18 = *(_QWORD *)&this->m_vecMovePos.x;
  v17[2] = LODWORD(this->m_vecMovePos.z);
  *(_QWORD *)v17 = v18;
  CGenericGameStorage::_SaveDataToWorkBuffer(v17, 12);
  j_free(v17);
}

//----- (00527A74) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::Clone(
        const CTaskComplexGoToPointAndStandStillAndAchieveHeading *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iMoveState; // r5
  __int64 v4; // d8
  __int64 v5; // d9
  CTask *result; // r0
  char m_pParent; // r2
  CTask v8; // d16
  RwReal z; // r1

  v2 = (CTaskComplex *)CTask::operator new(0x30u);
  m_iMoveState = (CTask *)this->m_iMoveState;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  v5 = *(_QWORD *)&this->m_fHeadingChangeRateFrac;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iMoveState;
  m_pParent = (char)result[5].m_pParent;
  result->_vptr$CTask = (int (**)(void))&off_66C1F0;
  v8 = *(CTask *)&this->m_vTarget.x;
  z = this->m_vTarget.z;
  *(_QWORD *)&result[3].m_pParent = v4;
  *(_QWORD *)&result[4].m_pParent = v5;
  *(RwReal *)&result[3]._vptr$CTask = z;
  LOBYTE(result[5].m_pParent) = m_pParent | 1;
  result[2] = v8;
  return result;
}
// 527A98: variable 'result' is possibly undefined
// 66C1F0: using guessed type void *;

//----- (00527AC8) --------------------------------------------------------
int __fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::GetTaskType(
        const CTaskComplexGoToPointAndStandStillAndAchieveHeading *this)
{
  return 904;
}

//----- (00527AD0) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::Serialize(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  __int64 v6; // d16
  float *v7; // r5
  int v8; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexGoToPointAndStandStillAndAchieveHeading *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoToPointAndStandStillAndAchieveHeading *))this->_vptr$CTask + 5))(this) == 904 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(0xCu);
    v6 = *(_QWORD *)&this->m_vTarget.x;
    v5[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v5 = v6;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 12);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v7 = (float *)malloc(4u);
    *v7 = this->m_fDesiredHeading;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexGoToPointAndStandStillAndAchieveHeading *))this->_vptr$CTask + 5))(this);
    sub_1941C4(904, v8);
  }
}

//----- (00527BD4) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPointRoute::Clone(const CTaskComplexFollowPointRoute *this)
{
  CTaskComplex *v2; // r0
  int m_iMode; // r6
  CTaskComplex *v4; // r4
  __int64 v5; // kr00_8
  __int64 v6; // kr08_8
  char v7; // r5
  char v8; // r1
  CTask *v9; // r0
  int v10; // r2
  int v11; // r2
  CTask **p_m_pParent; // r3
  int v13; // r6
  __int64 v14; // d16
  CTask *v15; // r5
  char m_pParent; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x3Cu);
  m_iMode = this->m_iMode;
  v4 = v2;
  v5 = *(_QWORD *)&this->m_iMoveState;
  v6 = *(_QWORD *)&this->m_fSlowDownDistance;
  v7 = *((_BYTE *)this + 40);
  CTaskComplex::CTaskComplex(v2);
  v4[1]._vptr$CTask = (int (**)(void))m_iMode;
  v4[1].m_pSubTask = (CTask *)v5;
  v8 = (int)v4[3].m_pParent & 0xF2;
  v4->_vptr$CTask = (int (**)(void))&off_66C22C;
  LOBYTE(v4[3].m_pParent) = v7 & 0xD | v8;
  if ( (v7 & 8) != 0 )
  {
    LOBYTE(v4[3].m_pParent) = v7 & 0xD | v8 & 0x9F;
    *(_QWORD *)&v4[3].m_pSubTask = 0LL;
    *(_QWORD *)&v4[4].m_pParent = 0LL;
  }
  v9 = (CTask *)CPointRoute::operator new(0x64u);
  v9->_vptr$CTask = 0;
  v4[2].m_pSubTask = v9;
  v10 = *(_DWORD *)HIDWORD(v6);
  v9->_vptr$CTask = (int (**)(void))*(_DWORD *)HIDWORD(v6);
  if ( v10 >= 1 )
  {
    v11 = HIDWORD(v6) + 4;
    p_m_pParent = &v9->m_pParent;
    v13 = 0;
    do
    {
      v14 = *(_QWORD *)v11;
      ++v13;
      v15 = *(CTask **)(v11 + 8);
      v11 += 12;
      p_m_pParent[2] = v15;
      *(_QWORD *)p_m_pParent = v14;
      p_m_pParent += 3;
    }
    while ( v13 < (int)v9->_vptr$CTask );
  }
  v4[2]._vptr$CTask = (int (**)(void))HIDWORD(v5);
  v4[2].m_pParent = (CTask *)v6;
  m_pParent = (char)v4[3].m_pParent;
  v4[3]._vptr$CTask = 0;
  v4[1].m_pParent = 0;
  LOBYTE(v4[3].m_pParent) = m_pParent | 2;
  if ( (m_pParent & 8) != 0 )
  {
    LOBYTE(v4[3].m_pParent) = m_pParent & 0x9D | 0x42;
    *(_QWORD *)&v4[3].m_pSubTask = 0LL;
    *(_QWORD *)&v4[4].m_pParent = 0LL;
  }
  return v4;
}
// 66C22C: using guessed type void *off_66C22C;

//----- (00527CB0) --------------------------------------------------------
int __fastcall CTaskComplexFollowPointRoute::GetTaskType(const CTaskComplexFollowPointRoute *this)
{
  return 905;
}

//----- (00527CB8) --------------------------------------------------------
void __fastcall CTaskComplexFollowPointRoute::Serialize(CTaskComplexFollowPointRoute *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  CPointRoute *m_pRoute; // r5
  CPointRoute *v6; // r6
  _DWORD *v7; // r5
  float *v8; // r5
  float *v9; // r5
  int v10; // r0
  bool v11; // [sp+5h] [bp-13h] BYREF
  bool v12; // [sp+6h] [bp-12h] BYREF
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v2 = (*((int (__fastcall **)(CTaskComplexFollowPointRoute *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFollowPointRoute *))this->_vptr$CTask + 5))(this) == 905 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    m_pRoute = this->m_pRoute;
    v6 = (CPointRoute *)malloc(0x64u);
    qmemcpy(v6, m_pRoute, sizeof(CPointRoute));
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 100);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = this->m_iMode;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v8 = (float *)malloc(4u);
    *v8 = this->m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    if ( UseDataFence )
      AddDataFence();
    v9 = (float *)malloc(4u);
    *v9 = this->m_fSlowDownDistance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    free(v9);
    pData[0] = *((_BYTE *)this + 40) & 1;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
    v12 = (*((_BYTE *)this + 40) & 8) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&v12, 1);
    v11 = (*((_BYTE *)this + 40) & 4) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&v11, 1);
  }
  else
  {
    v10 = (*((int (__fastcall **)(CTaskComplexFollowPointRoute *))this->_vptr$CTask + 5))(this);
    sub_1941C4(905, v10);
  }
}
// 527CB8: using guessed type char pData[17];

//----- (00527E98) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowNodeRoute::Clone(const CTaskComplexFollowNodeRoute *this)
{
  char *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  char v5; // r9
  int m_iTime; // r6
  char v7; // r1
  RwReal z; // r0
  __int64 v9; // d16
  _DWORD *v10; // r0
  _WORD *v11; // r0

  v2 = (char *)CTask::operator new(0x60u);
  v3 = *(_QWORD *)&this->m_iMoveState;
  v4 = *(_QWORD *)&this->m_fSlowDownDistance;
  v5 = *((_BYTE *)this + 76);
  m_iTime = this->m_iTime;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  v7 = v2[76] & 0xF6;
  *(_DWORD *)v2 = &off_66C268;
  z = this->m_vTarget.z;
  v9 = *(_QWORD *)&this->m_vTarget.x;
  *((_QWORD *)v2 + 3) = v3;
  *((_QWORD *)v2 + 4) = v4;
  *((RwReal *)v2 + 5) = z;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 15) = m_iTime;
  *((_DWORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 17) = 0;
  *((_WORD *)v2 + 20) = -1;
  *((_WORD *)v2 + 26) = -1;
  *((_WORD *)v2 + 36) = 0;
  v2[76] = v5 & 9 | v7;
  *(_QWORD *)(v2 + 12) = v9;
  if ( (v5 & 8) != 0 )
  {
    v2[76] = v5 & 9 | v7 & 0x9F;
    *((_QWORD *)v2 + 10) = 0LL;
    *((_QWORD *)v2 + 11) = 0LL;
  }
  v10 = CPointRoute::operator new(0x64u);
  *v10 = 0;
  *((_DWORD *)v2 + 12) = v10;
  v11 = CNodeRoute::operator new(0x24u);
  *(_DWORD *)v11 = 0;
  v11[2] = -1;
  v11[4] = -1;
  v11[6] = -1;
  v11[8] = -1;
  v11[10] = -1;
  v11[12] = -1;
  v11[14] = -1;
  v11[16] = -1;
  *((_WORD *)v2 + 26) = -1;
  *((_DWORD *)v2 + 11) = v11;
  *((CNodeAddress *)v2 + 10) = EmptyNodeAddress;
  *((_DWORD *)v2 + 10) = this->m_startNode;
  return (CTask *)v2;
}
// 66C268: using guessed type void *off_66C268;

//----- (00527F74) --------------------------------------------------------
int __fastcall CTaskComplexFollowNodeRoute::GetTaskType(const CTaskComplexFollowNodeRoute *this)
{
  return 906;
}

//----- (00527F7C) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidOtherPedWhileWandering::Clone(const CTaskComplexAvoidOtherPedWhileWandering *this)
{
  char *v2; // r4
  CPed *m_pOtherPed; // r6
  int m_iMoveState; // r8
  __int64 v5; // d16
  __int64 v6; // d16
  char v7; // r2

  v2 = (char *)CTask::operator new(0x60u);
  m_pOtherPed = this->m_pOtherPed;
  m_iMoveState = this->m_iMoveState;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66C2F0;
  *((_DWORD *)v2 + 3) = m_pOtherPed;
  v5 = *(_QWORD *)&this->m_vTarget.x;
  *((_DWORD *)v2 + 9) = LODWORD(this->m_vTarget.z);
  *(_QWORD *)(v2 + 28) = v5;
  v6 = *(_QWORD *)&this->m_vTarget.x;
  *((_DWORD *)v2 + 12) = LODWORD(this->m_vTarget.z);
  *((_DWORD *)v2 + 17) = 0;
  v7 = v2[92];
  *((_WORD *)v2 + 36) = 0;
  *((_WORD *)v2 + 42) = 0;
  *((_DWORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *((_DWORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 22) = m_iMoveState;
  *((_QWORD *)v2 + 5) = v6;
  v2[92] = v7 & 0xF8;
  if ( m_pOtherPed )
    CEntity::RegisterReference(m_pOtherPed, (CEntity **)v2 + 3);
  if ( (*((_BYTE *)this + 92) & 4) != 0 )
    v2[92] |= 4u;
  return (CTask *)v2;
}
// 66C2F0: using guessed type void *off_66C2F0;

//----- (00528010) --------------------------------------------------------
int __fastcall CTaskComplexAvoidOtherPedWhileWandering::GetTaskType(
        const CTaskComplexAvoidOtherPedWhileWandering *this)
{
  return 917;
}

//----- (00528018) --------------------------------------------------------
void __fastcall CTaskComplexAvoidOtherPedWhileWandering::Serialize(CTaskComplexAvoidOtherPedWhileWandering *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  _DWORD *v7; // r5
  __int64 v8; // d16
  int v9; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexAvoidOtherPedWhileWandering *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexAvoidOtherPedWhileWandering *))this->_vptr$CTask + 5))(this) == 917 )
  {
    v4 = GettPoolPedRef(this->m_pOtherPed);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(0xCu);
    v8 = *(_QWORD *)&this->m_vTarget.x;
    v7[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v7 = v8;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 12);
    j_free(v7);
  }
  else
  {
    v9 = (*((int (__fastcall **)(CTaskComplexAvoidOtherPedWhileWandering *))this->_vptr$CTask + 5))(this);
    sub_1941C4(917, v9);
  }
}

//----- (00528124) --------------------------------------------------------
CTask *__fastcall CTaskComplexAvoidEntity::Clone(const CTaskComplexAvoidEntity *this)
{
  char *v2; // r4
  __int64 v3; // kr00_8
  __int64 v4; // d16
  __int64 v5; // d16
  char v6; // r2

  v2 = (char *)CTask::operator new(0x54u);
  v3 = *(_QWORD *)&this->m_pEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *(_DWORD *)v2 = &off_66C32C;
  *((_DWORD *)v2 + 3) = v3;
  v4 = *(_QWORD *)&this->m_vTarget.x;
  *((_DWORD *)v2 + 10) = LODWORD(this->m_vTarget.z);
  *((_QWORD *)v2 + 4) = v4;
  v5 = *(_QWORD *)&this->m_vTarget.x;
  *((_DWORD *)v2 + 13) = LODWORD(this->m_vTarget.z);
  *((_WORD *)v2 + 38) = 0;
  *(_QWORD *)(v2 + 44) = v5;
  v6 = v2[80];
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 18) = 0;
  v2[80] = v6 & 0xFE;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66C32C: using guessed type void *off_66C32C;

//----- (0052819C) --------------------------------------------------------
int __fastcall CTaskComplexAvoidEntity::GetTaskType(const CTaskComplexAvoidEntity *this)
{
  return 939;
}

//----- (005281A4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToAttractor::Clone(const CTaskComplexGoToAttractor *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pAttractor; // r5
  __int64 v4; // d8
  __int64 v5; // d9
  CTask *result; // r0
  CTask v7; // d16
  RwReal z; // r1

  v2 = (CTaskComplex *)CTask::operator new(0x2Cu);
  m_pAttractor = (CTask *)this->m_pAttractor;
  v4 = *(_QWORD *)&this->m_fAttractHeading;
  v5 = *(_QWORD *)&this->m_iSlot;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pAttractor;
  result->_vptr$CTask = (int (**)(void))&off_66C3B4;
  v7 = *(CTask *)&this->m_vAttractPos.x;
  z = this->m_vAttractPos.z;
  *(_QWORD *)&result[3].m_pParent = v4;
  *(_QWORD *)&result[4].m_pParent = v5;
  *(RwReal *)&result[3]._vptr$CTask = z;
  result[2] = v7;
  return result;
}
// 5281C8: variable 'result' is possibly undefined
// 66C3B4: using guessed type void *off_66C3B4;

//----- (005281EC) --------------------------------------------------------
int __fastcall CTaskComplexGoToAttractor::GetTaskType(const CTaskComplexGoToAttractor *this)
{
  return 915;
}

//----- (005281F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAnyMeans::Clone(const CTaskComplexGoToPointAnyMeans *this)
{
  CTaskComplex *v2; // r0
  CTask v3; // r8
  CTaskComplex *v4; // r4
  __int64 v5; // kr00_8
  CTask v6; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x34u);
  v3 = *(CTask *)&this->m_iMoveState;
  v4 = v2;
  v5 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex(v2);
  v4->_vptr$CTask = (int (**)(void))&off_66C3F0;
  v6 = *(CTask *)&this->m_vTarget.x;
  v4[1].m_pSubTask = (CTask *)LODWORD(this->m_vTarget.z);
  v4[2].CTask = v3;
  v4[3]._vptr$CTask = (int (**)(void))HIDWORD(v5);
  v4[3].m_pParent = 0;
  v4[3].m_pSubTask = 0;
  LOWORD(v4[4]._vptr$CTask) = 0;
  v4[1].CTask = v6;
  v4[2].m_pSubTask = (CTask *)v5;
  if ( (_DWORD)v5 )
    CEntity::RegisterReference((CEntity *)v5, (CEntity **)&v4[2].m_pSubTask);
  return v4;
}
// 66C3F0: using guessed type void *off_66C3F0;

//----- (00528258) --------------------------------------------------------
int __fastcall CTaskComplexGoToPointAnyMeans::GetTaskType(const CTaskComplexGoToPointAnyMeans *this)
{
  return 918;
}

//----- (00528260) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAnyMeans::Serialize(CTaskComplexGoToPointAnyMeans *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  __int64 v5; // d16
  _DWORD *v6; // r5
  float *v7; // r5
  int v8; // r5
  _DWORD *v9; // r6
  _DWORD *v10; // r5
  int v11; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexGoToPointAnyMeans *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoToPointAnyMeans *))this->_vptr$CTask + 5))(this) == 918 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(0xCu);
    v5 = *(_QWORD *)&this->m_vTarget.x;
    v4[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v4 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 12);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = (float *)malloc(4u);
    *v7 = this->m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    v8 = GettPoolVehicleRef(this->m_pTargetVehicle);
    if ( UseDataFence )
      AddDataFence();
    v9 = malloc(4u);
    *v9 = v8;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    free(v9);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iDesiredCarModel;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v11 = (*((int (__fastcall **)(CTaskComplexGoToPointAnyMeans *))this->_vptr$CTask + 5))(this);
    sub_1941C4(918, v11);
  }
}

//----- (005283C8) --------------------------------------------------------
CTask *__fastcall CTaskComplexTurnToFaceEntityOrCoord::Clone(const CTaskComplexTurnToFaceEntityOrCoord *this)
{
  _BOOL4 m_bFacingEntity; // r6
  CTaskComplex *v3; // r0
  CTaskComplex *v4; // r4
  float m_fHeadingChangeRateFrac; // s16
  float m_fHeadingTolerance; // s18
  CEntity *m_pEntity; // r5
  __int64 v8; // d16
  CTask *result; // r0

  m_bFacingEntity = this->m_bFacingEntity;
  v3 = (CTaskComplex *)CTask::operator new(0x28u);
  v4 = v3;
  if ( m_bFacingEntity )
  {
    m_fHeadingChangeRateFrac = this->m_fHeadingChangeRateFrac;
    m_fHeadingTolerance = this->m_fHeadingTolerance;
    m_pEntity = this->m_pEntity;
    CTaskComplex::CTaskComplex(v3);
    LOBYTE(v4[1].m_pParent) = 1;
    v4->_vptr$CTask = (int (**)(void))&off_66C42C;
    v4[1]._vptr$CTask = (int (**)(void))m_pEntity;
    if ( m_pEntity )
      CEntity::RegisterReference(m_pEntity, (CEntity **)&v4[1]);
  }
  else
  {
    m_fHeadingChangeRateFrac = this->m_fHeadingChangeRateFrac;
    m_fHeadingTolerance = this->m_fHeadingTolerance;
    CTaskComplex::CTaskComplex(v3);
    v4[1]._vptr$CTask = 0;
    LOBYTE(v4[1].m_pParent) = 0;
    v4->_vptr$CTask = (int (**)(void))&off_66C42C;
    v8 = *(_QWORD *)&this->m_vTarget.x;
    v4[2].m_pParent = (CTask *)LODWORD(this->m_vTarget.z);
    *(_QWORD *)&v4[1].m_pSubTask = v8;
  }
  *(float *)&v4[2].m_pSubTask = m_fHeadingChangeRateFrac;
  result = v4;
  *(float *)&v4[3]._vptr$CTask = m_fHeadingTolerance;
  return result;
}
// 66C42C: using guessed type void *off_66C42C;

//----- (0052845C) --------------------------------------------------------
int __fastcall CTaskComplexTurnToFaceEntityOrCoord::GetTaskType(const CTaskComplexTurnToFaceEntityOrCoord *this)
{
  return 920;
}

//----- (00528464) --------------------------------------------------------
void __fastcall CTaskComplexTurnToFaceEntityOrCoord::Serialize(CTaskComplexTurnToFaceEntityOrCoord *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5
  __int64 v15; // d16

  v2 = (*((int (__fastcall **)(CTaskComplexTurnToFaceEntityOrCoord *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexTurnToFaceEntityOrCoord *))this->_vptr$CTask + 5))(this) != 920 )
  {
    v10 = (*((int (__fastcall **)(CTaskComplexTurnToFaceEntityOrCoord *))this->_vptr$CTask + 5))(this);
    sub_1941C4(920, v10);
    return;
  }
  m_pEntity = this->m_pEntity;
  if ( !m_pEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_18;
  }
  v5 = *(_BYTE *)&m_pEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  if ( v8 == 2 )
  {
    v9 = GettPoolVehicleRef((CVehicle *)v7);
    goto LABEL_15;
  }
  if ( v8 == 3 )
  {
    v9 = GettPoolPedRef((CPed *)v7);
LABEL_15:
    if ( UseDataFence )
      AddDataFence();
    v13 = malloc(4u);
    *v13 = v9;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    v12 = v13;
LABEL_18:
    free(v12);
  }
  if ( UseDataFence )
    AddDataFence();
  CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bFacingEntity, 1);
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(0xCu);
  v15 = *(_QWORD *)&this->m_vTarget.x;
  v14[2] = LODWORD(this->m_vTarget.z);
  *(_QWORD *)v14 = v15;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
  j_free(v14);
}

//----- (005285E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPatrolRoute::Clone(const CTaskComplexFollowPatrolRoute *this)
{
  CTaskComplexFollowPatrolRoute *v2; // r0
  CTask *result; // r0

  v2 = (CTaskComplexFollowPatrolRoute *)CTask::operator new(0x30u);
  CTaskComplexFollowPatrolRoute::CTaskComplexFollowPatrolRoute(
    v2,
    this->m_iMoveState,
    this->m_pRoute,
    this->m_iMode,
    this->m_fTargetRadius,
    this->m_fSlowDownDistance);
  return result;
}

//----- (00528610) --------------------------------------------------------
int __fastcall CTaskComplexFollowPatrolRoute::GetTaskType(const CTaskComplexFollowPatrolRoute *this)
{
  return 931;
}

//----- (00528618) --------------------------------------------------------
void __fastcall CTaskComplexFollowPatrolRoute::Serialize(CTaskComplexFollowPatrolRoute *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _WORD *v4; // r5
  CPatrolRoute *m_pRoute; // r5
  CPatrolRoute *v6; // r6
  _WORD *v7; // r5
  float *v8; // r5
  float *v9; // r5
  int v10; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexFollowPatrolRoute *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFollowPatrolRoute *))this->_vptr$CTask + 5))(this) == 931 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(2u);
    *v4 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 2);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    m_pRoute = this->m_pRoute;
    v6 = (CPatrolRoute *)malloc(0x1A4u);
    qmemcpy(v6, m_pRoute, sizeof(CPatrolRoute));
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 420);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(2u);
    *v7 = this->m_iMode;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 2);
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v8 = (float *)malloc(4u);
    *v8 = this->m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    if ( UseDataFence )
      AddDataFence();
    v9 = (float *)malloc(4u);
    *v9 = this->m_fSlowDownDistance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    j_free(v9);
  }
  else
  {
    v10 = (*((int (__fastcall **)(CTaskComplexFollowPatrolRoute *))this->_vptr$CTask + 5))(this);
    sub_1941C4(931, v10);
  }
}

//----- (0052877C) --------------------------------------------------------
int __fastcall CTaskComplexGotoDoorAndOpen::GetTaskType(const CTaskComplexGotoDoorAndOpen *this)
{
  return 932;
}

//----- (00528784) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSlideToCoord::Clone(const CTaskSimpleSlideToCoord *this)
{
  char v2; // r6
  CTaskSimpleRunNamedAnim *v3; // r0
  CTask v4; // kr00_8
  CVector *p_m_vPos; // r5
  CTask *result; // r0
  char v7; // r2
  __int64 v8; // d16
  char v9; // r1
  char v10; // r2

  v2 = *((_BYTE *)this + 120);
  v3 = (CTaskSimpleRunNamedAnim *)CTask::operator new(0x80u);
  v4 = *(CTask *)&this->m_fHeading;
  p_m_vPos = &this->m_vPos;
  if ( (v2 & 2) != 0 )
  {
    CTaskSimpleRunNamedAnim::CTaskSimpleRunNamedAnim(
      v3,
      this->m_animName,
      this->m_animGroupName,
      this->m_flags,
      this->m_fBlendDelta,
      this->m_iTime,
      0,
      (*((_BYTE *)&this->CTaskSimpleAnim:104 + 12) & 0x10) != 0,
      0,
      0);
    result->_vptr$CTask = (int (**)(void))&off_66C4E0;
    v10 = (char)result[15]._vptr$CTask;
    v8 = *(_QWORD *)&p_m_vPos->x;
    result[13].m_pParent = (CTask *)LODWORD(this->m_vPos.z);
    result[14] = v4;
    result[15].m_pParent = (CTask *)-1;
    v9 = v10 | 3;
  }
  else
  {
    CTaskSimpleAnim::CTaskSimpleAnim((CTaskSimpleAnim *)v3, 0);
    LOWORD(result[9].m_pParent) = 0;
    result[8].m_pParent = 0;
    result[9]._vptr$CTask = 0;
    result->_vptr$CTask = (int (**)(void))&off_66C4E0;
    v7 = (char)result[15]._vptr$CTask;
    v8 = *(_QWORD *)&p_m_vPos->x;
    result[13].m_pParent = (CTask *)LODWORD(this->m_vPos.z);
    result[14] = v4;
    v9 = v7 & 0xFC | 1;
  }
  LOBYTE(result[15]._vptr$CTask) = v9;
  *(_QWORD *)&result[12].m_pParent = v8;
  return result;
}
// 5287B2: variable 'result' is possibly undefined
// 66C4E0: using guessed type void *off_66C4E0;

//----- (00528848) --------------------------------------------------------
int __fastcall CTaskSimpleSlideToCoord::GetTaskType(const CTaskSimpleSlideToCoord *this)
{
  return 934;
}

//----- (00528850) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDisturbance::Clone(const CTaskComplexInvestigateDisturbance *this)
{
  char *v2; // r4
  CEntity *m_pSourceEntity; // r5
  __int64 v4; // d16

  v2 = (char *)CTask::operator new(0x1Cu);
  m_pSourceEntity = this->m_pSourceEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66C514;
  v4 = *(_QWORD *)&this->m_vTargetPos.x;
  *((_DWORD *)v2 + 5) = LODWORD(this->m_vTargetPos.z);
  *(_QWORD *)(v2 + 12) = v4;
  *((_DWORD *)v2 + 6) = m_pSourceEntity;
  if ( m_pSourceEntity )
    CEntity::RegisterReference(m_pSourceEntity, (CEntity **)v2 + 6);
  return (CTask *)v2;
}
// 66C514: using guessed type void *off_66C514;

//----- (0052889C) --------------------------------------------------------
int __fastcall CTaskComplexInvestigateDisturbance::GetTaskType(const CTaskComplexInvestigateDisturbance *this)
{
  return 935;
}

//----- (005288A4) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointShooting::~CTaskComplexGoToPointShooting(CTaskComplexGoToPointShooting *this)
{
  CEntity *m_pAimEntity; // r0
  CEntity **p_m_pAimEntity; // r1
  void *v4; // r0

  p_m_pAimEntity = &this->m_pAimEntity;
  m_pAimEntity = this->m_pAimEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C1B4;
  if ( m_pAimEntity )
    CEntity::CleanUpOldReference(m_pAimEntity, p_m_pAimEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5288CC: variable 'v4' is possibly undefined
// 66C1B4: using guessed type void *off_66C1B4;

//----- (005288D4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointShooting::Clone(const CTaskComplexGoToPointShooting *this)
{
  CTaskComplex *v2; // r0
  float m_fMoveTargetRadius; // s16
  float m_fSlowDownDistance; // s18
  CTaskComplex *v5; // r4
  __int64 v6; // kr00_8
  RwReal x; // r9
  RwReal y; // r10
  RwReal z; // r11
  CVector *p_m_vecMovePos; // r8
  __int64 v11; // d16
  char m_pParent; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  m_fMoveTargetRadius = this->m_fMoveTargetRadius;
  m_fSlowDownDistance = this->m_fSlowDownDistance;
  v5 = v2;
  v6 = *(_QWORD *)&this->m_iMoveState;
  x = this->m_vecAimPos.x;
  y = this->m_vecAimPos.y;
  z = this->m_vecAimPos.z;
  CTaskComplex::CTaskComplex(v2);
  v5[1]._vptr$CTask = (int (**)(void))v6;
  *(RwReal *)&v5[1].m_pSubTask = x;
  *(RwReal *)&v5[2]._vptr$CTask = y;
  *(RwReal *)&v5[2].m_pParent = z;
  p_m_vecMovePos = &this->m_vecMovePos;
  v5->_vptr$CTask = (int (**)(void))&off_66C1B4;
  v5[1].m_pParent = (CTask *)HIDWORD(v6);
  if ( HIDWORD(v6) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v6), (CEntity **)&v5[1].m_pParent);
  if ( *(float *)&v5[2].m_pSubTask != p_m_vecMovePos->x
    || *(float *)&v5[3]._vptr$CTask != this->m_vecMovePos.y
    || *(float *)&v5[3].m_pParent != this->m_vecMovePos.z
    || *(float *)&v5[3].m_pSubTask != m_fMoveTargetRadius
    || *(float *)&v5[4]._vptr$CTask != m_fSlowDownDistance )
  {
    v11 = *(_QWORD *)&p_m_vecMovePos->x;
    v5[3].m_pParent = (CTask *)LODWORD(this->m_vecMovePos.z);
    *(_QWORD *)&v5[2].m_pSubTask = v11;
    m_pParent = (char)v5[4].m_pParent;
    *(float *)&v5[3].m_pSubTask = m_fMoveTargetRadius;
    *(float *)&v5[4]._vptr$CTask = m_fSlowDownDistance;
    LOBYTE(v5[4].m_pParent) = m_pParent | 1;
  }
  v5->_vptr$CTask = (int (**)(void))&off_66C6E8;
  return v5;
}
// 66C1B4: using guessed type void *off_66C1B4;
// 66C6E8: using guessed type void *off_66C6E8;

//----- (005289C8) --------------------------------------------------------
int __fastcall CTaskComplexGoToPointShooting::GetTaskType(const CTaskComplexGoToPointShooting *this)
{
  return 901;
}

//----- (005289D0) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointShooting::Serialize(CTaskComplexGoToPointShooting *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  __int64 v6; // d16
  CEntity *m_pAimEntity; // r0
  int v8; // r6
  _DWORD *v9; // r5
  CEntity *v10; // r0
  int v11; // r1
  int v12; // r5
  int v13; // r0
  _DWORD *v14; // r5
  void *v15; // r0
  _DWORD *v16; // r6
  _DWORD *v17; // r5
  __int64 v18; // d16
  float *v19; // r5
  float *v20; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexGoToPointShooting *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoToPointShooting *))this->_vptr$CTask + 5))(this) != 901 )
  {
    v13 = (*((int (__fastcall **)(CTaskComplexGoToPointShooting *))this->_vptr$CTask + 5))(this);
    sub_1941C4(901, v13);
    return;
  }
  if ( UseDataFence )
    AddDataFence();
  v4 = malloc(4u);
  *v4 = this->m_iMoveState;
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
  free(v4);
  if ( UseDataFence )
    AddDataFence();
  v5 = malloc(0xCu);
  v6 = *(_QWORD *)&this->m_vecMovePos.x;
  v5[2] = LODWORD(this->m_vecMovePos.z);
  *(_QWORD *)v5 = v6;
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 12);
  free(v5);
  m_pAimEntity = this->m_pAimEntity;
  if ( !m_pAimEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(4u);
    *v14 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
    v15 = v14;
    goto LABEL_24;
  }
  v8 = *(_BYTE *)&m_pAimEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v9 = malloc(4u);
  *v9 = v8;
  CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
  free(v9);
  v10 = this->m_pAimEntity;
  v11 = *(_BYTE *)&v10->m_info & 7;
  switch ( v11 )
  {
    case 2:
      v12 = GettPoolVehicleRef((CVehicle *)v10);
      goto LABEL_21;
    case 4:
      v12 = GettPoolObjRef((CObject *)v10);
      goto LABEL_21;
    case 3:
      v12 = GettPoolPedRef((CPed *)v10);
LABEL_21:
      if ( UseDataFence )
        AddDataFence();
      v16 = malloc(4u);
      *v16 = v12;
      CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
      v15 = v16;
LABEL_24:
      free(v15);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v17 = malloc(0xCu);
  v18 = *(_QWORD *)&this->m_vecAimPos.x;
  v17[2] = LODWORD(this->m_vecAimPos.z);
  *(_QWORD *)v17 = v18;
  CGenericGameStorage::_SaveDataToWorkBuffer(v17, 12);
  free(v17);
  if ( UseDataFence )
    AddDataFence();
  v19 = (float *)malloc(4u);
  *v19 = this->m_fMoveTargetRadius;
  CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
  free(v19);
  if ( UseDataFence )
    AddDataFence();
  v20 = (float *)malloc(4u);
  *v20 = this->m_fSlowDownDistance;
  CGenericGameStorage::_SaveDataToWorkBuffer(v20, 4);
  j_free(v20);
}

//----- (00528C08) --------------------------------------------------------
void __fastcall CTaskComplexWanderGang::~CTaskComplexWanderGang(CTaskComplexWanderGang *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 528C14: variable 'v1' is possibly undefined

//----- (00528C18) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderGang::Clone(const CTaskComplexWanderGang *this)
{
  CTaskComplex *v2; // r0
  char v3; // r8
  CTask *m_minWanderTime; // r5
  CTask *m_iMoveState; // r6
  CTask *result; // r0
  int m_pParent_low; // r3

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  v3 = *((_BYTE *)&this->CTaskComplexWander + 36);
  m_minWanderTime = (CTask *)this->m_minWanderTime;
  m_iMoveState = (CTask *)this->m_iMoveState;
  LOBYTE(this) = this->m_iDir;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  result[1].m_pParent = m_iMoveState;
  result[2].m_pParent = (CTask *)1056964608;
  LOWORD(result[3]._vptr$CTask) = -1;
  LOWORD(result[3].m_pParent) = -1;
  result[4]._vptr$CTask = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[6].m_pParent = m_minWanderTime;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  m_pParent_low = LOBYTE(result[4].m_pParent);
  result->_vptr$CTask = (int (**)(void))&off_66C724;
  LOBYTE(result[4].m_pParent) = v3 & 1 | m_pParent_low & 0xF0;
  result[5]._vptr$CTask = (int (**)(void))CTimer::m_snTimeInMilliseconds;
  result[5].m_pParent = m_minWanderTime;
  LOBYTE(result[6]._vptr$CTask) = 1;
  return result;
}
// 528C40: variable 'result' is possibly undefined
// 66C724: using guessed type void *off_66C724;

//----- (00528C90) --------------------------------------------------------
int __fastcall CTaskComplexWanderGang::GetWanderType(const CTaskComplexWanderGang *this)
{
  return 4;
}

//----- (00528C98) --------------------------------------------------------
void __fastcall CTaskInteriorBeInHouse::CTaskInteriorBeInHouse(
        CTaskInteriorBeInHouse *this,
        InteriorGroup_c *pInteriorGroup)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = pInteriorGroup;
  v3[4] = 0;
  v3[5] = 0;
  *v3 = &off_66C770;
}
// 528CA6: variable 'v3' is possibly undefined
// 66C770: using guessed type void *;

//----- (00528CC0) --------------------------------------------------------
void __fastcall CTaskInteriorBeInHouse::~CTaskInteriorBeInHouse(CTaskInteriorBeInHouse *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 528CCC: variable 'v1' is possibly undefined

//----- (00528CD0) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInHouse::Clone(const CTaskInteriorBeInHouse *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pInteriorGroup; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  m_pInteriorGroup = (CTask *)this->m_pInteriorGroup;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pInteriorGroup;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C770;
  return result;
}
// 528CE6: variable 'result' is possibly undefined
// 66C770: using guessed type void *off_66C770;

//----- (00528CFC) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInHouse::CreateNextSubTask(CTaskInteriorBeInHouse *this, CPed *pPed)
{
  CTaskComplex *v3; // r0
  __int64 v4; // kr00_8
  CTask *v5; // r6
  CTask *result; // r0
  int32 pTime[5]; // [sp+4h] [bp-14h] BYREF

  *((_DWORD *)&pPed->m_nPedFlags + 2) |= 0x80u;
  CTaskInteriorBeInHouse::GetInfoForPedToUse(this, pPed, pTime);
  v3 = (CTaskComplex *)CTask::operator new(0x1Cu);
  v4 = *(_QWORD *)&this->m_pCurrInterior;
  v5 = (CTask *)pTime[0];
  CTaskComplex::CTaskComplex(v3);
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  result[1].m_pParent = (CTask *)HIDWORD(v4);
  result[2]._vptr$CTask = (int (**)(void))v4;
  result[2].m_pParent = v5;
  LOBYTE(result[3]._vptr$CTask) = 0;
  return result;
}
// 528D34: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;
// 528CFC: using guessed type int32 pTime[5];

//----- (00528D4C) --------------------------------------------------------
void __fastcall CTaskInteriorBeInHouse::GetInfoForPedToUse(CTaskInteriorBeInHouse *this, CPed *pPed, int32 *pTime)
{
  int32 m_nPedType; // r4
  InteriorInfo_t **p_m_pCurrInteriorInfo; // r5
  unsigned __int16 v7; // r0
  int v8; // r1
  int v9; // s0
  char v10; // r1
  InteriorGroup_c *m_pInteriorGroup; // r0
  InteriorGroup_c *v12; // r0
  int32 v13; // r1
  InteriorInfo_t *m_pCurrInteriorInfo; // r0

  m_nPedType = pPed->m_nPedType;
  this->m_pCurrInteriorInfo = 0;
  p_m_pCurrInteriorInfo = &this->m_pCurrInteriorInfo;
  v7 = rand();
  v8 = 90;
  v9 = (int)(float)((float)((float)v7 * 0.000015259) * 100.0);
  if ( (unsigned int)(m_nPedType - 7) < 0xA )
    v8 = 0;
  if ( v8 > v9 )
  {
    v10 = rand();
    m_pInteriorGroup = this->m_pInteriorGroup;
    if ( (v10 & 1) != 0 )
    {
      if ( !InteriorGroup_c::FindInteriorInfo(m_pInteriorGroup, 3, &this->m_pCurrInteriorInfo, &this->m_pCurrInterior) )
      {
        v12 = this->m_pInteriorGroup;
        v13 = 4;
        goto LABEL_9;
      }
    }
    else if ( !InteriorGroup_c::FindInteriorInfo(
                 m_pInteriorGroup,
                 4,
                 &this->m_pCurrInteriorInfo,
                 &this->m_pCurrInterior) )
    {
      v12 = this->m_pInteriorGroup;
      v13 = 3;
LABEL_9:
      InteriorGroup_c::FindInteriorInfo(v12, v13, &this->m_pCurrInteriorInfo, &this->m_pCurrInterior);
    }
    *pTime = -1;
  }
  m_pCurrInteriorInfo = *p_m_pCurrInteriorInfo;
  if ( v9 <= 99 && !m_pCurrInteriorInfo )
  {
    InteriorGroup_c::FindInteriorInfo(this->m_pInteriorGroup, 1, &this->m_pCurrInteriorInfo, &this->m_pCurrInterior);
    *pTime = -1;
    m_pCurrInteriorInfo = this->m_pCurrInteriorInfo;
  }
  if ( v9 <= 99 && !m_pCurrInteriorInfo )
  {
    InteriorGroup_c::FindInteriorInfo(this->m_pInteriorGroup, 5, &this->m_pCurrInteriorInfo, &this->m_pCurrInterior);
    *pTime = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 25000.0) + 5000;
    m_pCurrInteriorInfo = this->m_pCurrInteriorInfo;
  }
  if ( !m_pCurrInteriorInfo )
  {
    InteriorGroup_c::FindInteriorInfo(this->m_pInteriorGroup, 1, &this->m_pCurrInteriorInfo, &this->m_pCurrInterior);
    *pTime = -1;
    if ( !this->m_pCurrInteriorInfo )
    {
      InteriorGroup_c::FindInteriorInfo(this->m_pInteriorGroup, 2, &this->m_pCurrInteriorInfo, &this->m_pCurrInterior);
      *pTime = -1;
    }
  }
}

//----- (00528E88) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInHouse::CreateFirstSubTask(CTaskInteriorBeInHouse *this, CPed *pPed)
{
  CTaskComplex *v3; // r0
  __int64 v4; // kr00_8
  CTask *v5; // r6
  CTask *result; // r0
  int32 pTime[5]; // [sp+4h] [bp-14h] BYREF

  CTaskInteriorBeInHouse::GetInfoForPedToUse(this, pPed, pTime);
  v3 = (CTaskComplex *)CTask::operator new(0x1Cu);
  v4 = *(_QWORD *)&this->m_pCurrInterior;
  v5 = (CTask *)pTime[0];
  CTaskComplex::CTaskComplex(v3);
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  result[1].m_pParent = (CTask *)HIDWORD(v4);
  result[2]._vptr$CTask = (int (**)(void))v4;
  result[2].m_pParent = v5;
  LOBYTE(result[3]._vptr$CTask) = 1;
  return result;
}
// 528EB2: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;
// 528E88: using guessed type int32 pTime[5];

//----- (00528ECC) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInHouse::ControlSubTask(CTaskInteriorBeInHouse *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (00528ED0) --------------------------------------------------------
void __fastcall CTaskInteriorBeInOffice::CTaskInteriorBeInOffice(
        CTaskInteriorBeInOffice *this,
        InteriorGroup_c *pInteriorGroup)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = pInteriorGroup;
  v3[4] = 0;
  v3[5] = 0;
  *v3 = &off_66C7AC;
}
// 528EDE: variable 'v3' is possibly undefined
// 66C7AC: using guessed type void *;

//----- (00528EF8) --------------------------------------------------------
void __fastcall CTaskInteriorBeInOffice::~CTaskInteriorBeInOffice(CTaskInteriorBeInOffice *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 528F04: variable 'v1' is possibly undefined

//----- (00528F08) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInOffice::Clone(const CTaskInteriorBeInOffice *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pInteriorGroup; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  m_pInteriorGroup = (CTask *)this->m_pInteriorGroup;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pInteriorGroup;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C7AC;
  return result;
}
// 528F1E: variable 'result' is possibly undefined
// 66C7AC: using guessed type void *off_66C7AC;

//----- (00528F34) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInOffice::CreateNextSubTask(CTaskInteriorBeInOffice *this, CPed *pPed)
{
  CTaskComplex *v3; // r0
  __int64 v4; // kr00_8
  CTask *v5; // r6
  CTask *result; // r0
  int32 pTime[5]; // [sp+4h] [bp-14h] BYREF

  *((_DWORD *)&pPed->m_nPedFlags + 2) |= 0x80u;
  CTaskInteriorBeInOffice::GetInfoForPedToUse(this, pTime);
  v3 = (CTaskComplex *)CTask::operator new(0x1Cu);
  v4 = *(_QWORD *)&this->m_pCurrInterior;
  v5 = (CTask *)pTime[0];
  CTaskComplex::CTaskComplex(v3);
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  result[1].m_pParent = (CTask *)HIDWORD(v4);
  result[2]._vptr$CTask = (int (**)(void))v4;
  result[2].m_pParent = v5;
  LOBYTE(result[3]._vptr$CTask) = 0;
  return result;
}
// 528F6C: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;
// 528F34: using guessed type int32 pTime[5];

//----- (00528F84) --------------------------------------------------------
void __fastcall CTaskInteriorBeInOffice::GetInfoForPedToUse(CTaskInteriorBeInOffice *this, int32 *pTime)
{
  InteriorInfo_t *m_pCurrInteriorInfo; // r0
  InteriorInfo_t **p_m_pCurrInteriorInfo; // r6
  float v6; // s16
  int32 v7; // r0
  int32 v8; // r0

  p_m_pCurrInteriorInfo = &this->m_pCurrInteriorInfo;
  m_pCurrInteriorInfo = this->m_pCurrInteriorInfo;
  if ( m_pCurrInteriorInfo && m_pCurrInteriorInfo->type == 6 )
  {
    InteriorGroup_c::FindInteriorInfo(
      this->m_pInteriorGroup,
      7,
      p_m_pCurrInteriorInfo,
      (Interior_c **)p_m_pCurrInteriorInfo - 1);
    v6 = 5000.0;
  }
  else
  {
    InteriorGroup_c::FindInteriorInfo(
      this->m_pInteriorGroup,
      6,
      p_m_pCurrInteriorInfo,
      (Interior_c **)p_m_pCurrInteriorInfo - 1);
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) > 20 )
    {
      v7 = -1;
      goto LABEL_8;
    }
    v6 = 25000.0;
  }
  v7 = (int)(float)(v6 * (float)((float)(unsigned __int16)rand() * 0.000015259)) + 5000;
LABEL_8:
  for ( *pTime = v7; !*p_m_pCurrInteriorInfo; *pTime = v8 )
  {
    InteriorGroup_c::FindInteriorInfo(
      this->m_pInteriorGroup,
      6,
      p_m_pCurrInteriorInfo,
      (Interior_c **)p_m_pCurrInteriorInfo - 1);
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 20 )
      v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 25000.0) + 5000;
    else
      v8 = -1;
  }
}

//----- (005290B0) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInOffice::CreateFirstSubTask(CTaskInteriorBeInOffice *this, CPed *pPed)
{
  CTaskComplex *v3; // r0
  __int64 v4; // kr00_8
  CTask *v5; // r6
  CTask *result; // r0
  int32 pTime[5]; // [sp+4h] [bp-14h] BYREF

  CTaskInteriorBeInOffice::GetInfoForPedToUse(this, pTime);
  v3 = (CTaskComplex *)CTask::operator new(0x1Cu);
  v4 = *(_QWORD *)&this->m_pCurrInterior;
  v5 = (CTask *)pTime[0];
  CTaskComplex::CTaskComplex(v3);
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  result[1].m_pParent = (CTask *)HIDWORD(v4);
  result[2]._vptr$CTask = (int (**)(void))v4;
  result[2].m_pParent = v5;
  LOBYTE(result[3]._vptr$CTask) = 1;
  return result;
}
// 5290DA: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;
// 5290B0: using guessed type int32 pTime[5];

//----- (005290F4) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInOffice::ControlSubTask(CTaskInteriorBeInOffice *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (005290F8) --------------------------------------------------------
void __fastcall CTaskInteriorBeInShop::CTaskInteriorBeInShop(
        CTaskInteriorBeInShop *this,
        InteriorGroup_c *pInteriorGroup)
{
  int v4; // s0

  v4 = (unsigned __int16)rand();
  CTaskComplexWander::CTaskComplexWander(this, 4, (int)(float)((float)((float)v4 * 0.000015259) * 8.0), 1, 0.2);
  this->_vptr$CTask = (int (**)(void))&off_66C7E8;
  this->m_pInteriorGroup = pInteriorGroup;
  this->m_currInteriorInfo = 0;
  this->m_scanForStuff = 1;
}
// 66C7E8: using guessed type void *;

//----- (00529170) --------------------------------------------------------
void __fastcall CTaskInteriorBeInShop::~CTaskInteriorBeInShop(CTaskInteriorBeInShop *this)
{
  void *v1; // r0

  CTaskComplexWander::~CTaskComplexWander(this);
  sub_197118(v1);
}
// 52917C: variable 'v1' is possibly undefined

//----- (00529180) --------------------------------------------------------
CTask *__fastcall CTaskInteriorBeInShop::Clone(const CTaskInteriorBeInShop *this)
{
  CTaskComplexWander *v2; // r4
  InteriorGroup_c *m_pInteriorGroup; // r5
  int v4; // s0
  CTask *result; // r0

  v2 = (CTaskComplexWander *)CTask::operator new(0x34u);
  m_pInteriorGroup = this->m_pInteriorGroup;
  v4 = (unsigned __int16)rand();
  CTaskComplexWander::CTaskComplexWander(v2, 4, (int)(float)((float)((float)v4 * 0.000015259) * 8.0), 1, 0.2);
  v2->_vptr$CTask = (int (**)(void))&off_66C7E8;
  v2[1]._vptr$CTask = (int (**)(void))m_pInteriorGroup;
  v2[1].m_pParent = 0;
  result = v2;
  LOBYTE(v2[1].m_pSubTask) = 1;
  return result;
}
// 66C7E8: using guessed type void *off_66C7E8;

//----- (005291FC) --------------------------------------------------------
void __fastcall CTaskInteriorBeInShop::ScanForStuff(CTaskInteriorBeInShop *this, CPed *pPed)
{
  CMatrix *m_pMat; // r1
  InteriorGroup_c *m_pInteriorGroup; // r0
  CSimpleTransform *p_tx; // r6
  InteriorInfo_t *ClosestInteriorInfo; // r0
  bool v8; // zf
  int type; // r0
  Interior_c *v10; // r4
  InteriorInfo_t *v11; // r5
  Interior_c *v12; // r5
  InteriorInfo_t *v13; // r6
  CEvent v14; // [sp+20h] [bp-40h] BYREF
  InteriorInfo_t *v15; // [sp+2Ch] [bp-34h]
  Interior_c *v16; // [sp+30h] [bp-30h]
  int v17; // [sp+34h] [bp-2Ch]
  char v18; // [sp+38h] [bp-28h]
  float v19; // [sp+3Ch] [bp-24h] BYREF
  Interior_c *v20; // [sp+40h] [bp-20h] BYREF
  InteriorInfo_t *v21; // [sp+44h] [bp-1Ch] BYREF

  v20 = 0;
  v21 = 0;
  if ( this->m_scanForStuff )
  {
    m_pMat = pPed->m_pMat;
    m_pInteriorGroup = this->m_pInteriorGroup;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    ClosestInteriorInfo = (InteriorInfo_t *)InteriorGroup_c::FindClosestInteriorInfo(
                                              m_pInteriorGroup,
                                              -1,
                                              p_tx->m_translate,
                                              2.0,
                                              &v21,
                                              &v20,
                                              &v19);
    v8 = ClosestInteriorInfo == 0;
    if ( ClosestInteriorInfo )
    {
      ClosestInteriorInfo = v21;
      v8 = this->m_currInteriorInfo == v21;
    }
    if ( !v8 )
    {
      type = (unsigned __int8)ClosestInteriorInfo->type;
      if ( type == 9 )
      {
        if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 81 )
        {
          this->m_scanForStuff = 0;
          v12 = v20;
          v13 = v21;
          CEvent::CEvent(&v14);
          v15 = v13;
          v14._vptr$CEvent = (int (**)(void))&off_666FCC;
          v16 = v12;
          v17 = 0;
          v18 = 0;
          CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v14, 0);
LABEL_13:
          CEvent::~CEvent(&v14);
        }
      }
      else if ( type == 8 )
      {
        if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) < 51 )
        {
          IKChainManager_c::LookAt(&g_ikChainMan, "TaskBeInShop", pPed, 0, 3000, -1, &v21->pos, 1, 0.25, 500, 3, 0);
          goto LABEL_15;
        }
        v10 = v20;
        v11 = v21;
        CEvent::CEvent(&v14);
        v15 = v11;
        v16 = v10;
        v17 = 0;
        v18 = 0;
        v14._vptr$CEvent = (int (**)(void))&off_666FCC;
        CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v14, 0);
        goto LABEL_13;
      }
LABEL_15:
      this->m_currInteriorInfo = v21;
    }
  }
}
// 666FCC: using guessed type void *off_666FCC;
// 5291FC: using guessed type float var_24;

//----- (005293A4) --------------------------------------------------------
void __fastcall CTaskInteriorShopKeeper::CTaskInteriorShopKeeper(
        CTaskInteriorShopKeeper *this,
        InteriorGroup_c *pInteriorGroup,
        bool8 isSetup)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v5 + 16) = pInteriorGroup;
  *(_BYTE *)(v5 + 20) = isSetup;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = 0;
  *(_BYTE *)(v5 + 12) = 0;
  *(_DWORD *)v5 = &off_66C834;
}
// 5293B4: variable 'v5' is possibly undefined
// 66C834: using guessed type void *off_66C834;

//----- (005293CC) --------------------------------------------------------
void __fastcall CTaskInteriorShopKeeper::~CTaskInteriorShopKeeper(CTaskInteriorShopKeeper *this)
{
  InteriorInfo_t *m_pInteriorInfo; // r1

  m_pInteriorInfo = this->m_pInteriorInfo;
  this->_vptr$CTask = (int (**)(void))&off_66C834;
  if ( m_pInteriorInfo )
    m_pInteriorInfo->beingUsed = 0;
  sub_18EDB4(this);
}
// 66C834: using guessed type void *;

//----- (005293E8) --------------------------------------------------------
void __fastcall CTaskInteriorShopKeeper::~CTaskInteriorShopKeeper(CTaskInteriorShopKeeper *this)
{
  InteriorInfo_t *m_pInteriorInfo; // r1
  void *v2; // r0

  m_pInteriorInfo = this->m_pInteriorInfo;
  this->_vptr$CTask = (int (**)(void))&off_66C834;
  if ( m_pInteriorInfo )
    m_pInteriorInfo->beingUsed = 0;
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v2);
}
// 529408: variable 'v2' is possibly undefined
// 66C834: using guessed type void *off_66C834;

//----- (00529410) --------------------------------------------------------
CTask *__fastcall CTaskInteriorShopKeeper::Clone(const CTaskInteriorShopKeeper *this)
{
  CTaskComplex *v2; // r0
  bool8 m_isSetup; // r5
  int (**m_pInteriorGroup)(void); // r6
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x20u);
  m_isSetup = this->m_isSetup;
  m_pInteriorGroup = (int (**)(void))this->m_pInteriorGroup;
  CTaskComplex::CTaskComplex(v2);
  result[2]._vptr$CTask = m_pInteriorGroup;
  LOBYTE(result[2].m_pParent) = m_isSetup;
  result[3]._vptr$CTask = 0;
  result[3].m_pParent = 0;
  LOBYTE(result[1].m_pParent) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C834;
  result[3]._vptr$CTask = (int (**)(void))this->m_pInteriorInfo;
  result[3].m_pParent = (CTask *)this->m_pInterior;
  return result;
}
// 52942C: variable 'result' is possibly undefined
// 66C834: using guessed type void *off_66C834;

//----- (00529450) --------------------------------------------------------
CTask *__fastcall CTaskInteriorShopKeeper::CreateNextSubTask(CTaskInteriorShopKeeper *this, CPed *pPed)
{
  CTaskComplex *v3; // r0
  __int64 v4; // kr00_8
  CTask *result; // r0

  v3 = (CTaskComplex *)CTask::operator new(0x1Cu);
  v4 = *(_QWORD *)&this->m_pInteriorInfo;
  CTaskComplex::CTaskComplex(v3);
  *(_QWORD *)&result[1].m_pParent = v4;
  result[2].m_pParent = 0;
  LOBYTE(result[3]._vptr$CTask) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  return result;
}
// 529468: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;

//----- (00529480) --------------------------------------------------------
CTask *__fastcall CTaskInteriorShopKeeper::CreateFirstSubTask(CTaskInteriorShopKeeper *this, CPed *pPed)
{
  InteriorInfo_t *m_pInteriorInfo; // r0
  InteriorInfo_t **p_m_pInteriorInfo; // r2
  char v5; // r5
  CTaskComplex *v6; // r0
  int (**m_pInterior)(void); // r4
  CTask *v8; // r6
  __int64 v9; // kr00_8
  CTask *result; // r0
  CTaskComplex *v11; // r0
  __int64 v12; // kr08_8

  p_m_pInteriorInfo = &this->m_pInteriorInfo;
  m_pInteriorInfo = this->m_pInteriorInfo;
  if ( !m_pInteriorInfo )
  {
    InteriorGroup_c::FindInteriorInfo(this->m_pInteriorGroup, 10, p_m_pInteriorInfo, &this->m_pInterior);
    m_pInteriorInfo = this->m_pInteriorInfo;
  }
  v5 = 1;
  m_pInteriorInfo->beingUsed = 1;
  if ( this->m_isSetup )
  {
    v6 = (CTaskComplex *)CTask::operator new(0x1Cu);
    v9 = *(_QWORD *)&this->m_pInteriorInfo;
    m_pInterior = (int (**)(void))this->m_pInterior;
    v8 = (CTask *)v9;
    CTaskComplex::CTaskComplex(v6);
    v5 = 0;
  }
  else
  {
    this->m_isSetup = 1;
    v11 = (CTaskComplex *)CTask::operator new(0x1Cu);
    v12 = *(_QWORD *)&this->m_pInteriorInfo;
    m_pInterior = (int (**)(void))this->m_pInterior;
    v8 = (CTask *)v12;
    CTaskComplex::CTaskComplex(v11);
  }
  result[1].m_pParent = v8;
  result[2]._vptr$CTask = m_pInterior;
  result[2].m_pParent = 0;
  LOBYTE(result[3]._vptr$CTask) = v5;
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  return result;
}
// 5294CE: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;

//----- (005294E8) --------------------------------------------------------
CTask *__fastcall CTaskInteriorShopKeeper::ControlSubTask(CTaskInteriorShopKeeper *this, CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleRunAnim *v3; // r0

  if ( !this->m_startServeAnim )
    return this->m_pSubTask;
  this->m_startServeAnim = 0;
  v3 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v3, ANIM_INT_SHOP_PED, ANIM_INT_SHOP_SERVE, 4.0, 0);
  return result;
}

//----- (00529518) --------------------------------------------------------
void __fastcall CTaskInteriorGoToInfo::CTaskInteriorGoToInfo(
        CTaskInteriorGoToInfo *this,
        InteriorInfo_t *pInteriorInfo,
        Interior_c *pInterior,
        bool8 doInstantly)
{
  int v7; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v7 + 12) = pInteriorInfo;
  *(_DWORD *)(v7 + 16) = pInterior;
  *(_BYTE *)(v7 + 20) = doInstantly;
  *(_DWORD *)v7 = &off_66C870;
}
// 52952C: variable 'v7' is possibly undefined
// 66C870: using guessed type void *;

//----- (00529548) --------------------------------------------------------
void __fastcall CTaskInteriorGoToInfo::~CTaskInteriorGoToInfo(CTaskInteriorGoToInfo *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 529554: variable 'v1' is possibly undefined

//----- (00529558) --------------------------------------------------------
CTask *__fastcall CTaskInteriorGoToInfo::Clone(const CTaskInteriorGoToInfo *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  v3 = *(_QWORD *)&this->m_pInteriorInfo;
  LOBYTE(this) = this->m_doInstantly;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  LOBYTE(result[2].m_pParent) = (_BYTE)this;
  result->_vptr$CTask = (int (**)(void))&off_66C870;
  return result;
}
// 529574: variable 'result' is possibly undefined
// 66C870: using guessed type void *off_66C870;

//----- (0052958C) --------------------------------------------------------
CTask *__fastcall CTaskInteriorGoToInfo::CreateNextSubTask(CTaskInteriorGoToInfo *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  InteriorInfo_t *m_pInteriorInfo; // r1
  CSimpleTransform *p_tx; // r2
  float32x2_t v7; // d16
  unsigned __int64 v8; // d0
  CTaskComplexFollowNodeRoute *v9; // r0
  InteriorInfo_t *v10; // r3
  __int64 v11; // d16
  CTask *result; // r0
  float RadianAngleBetweenPoints; // r0
  float v14; // r4
  CTaskSimpleAchieveHeading *v15; // r0
  CVector vTarget; // [sp+18h] [bp-18h] BYREF

  if ( !this->m_pInteriorInfo
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 906
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 900 )
  {
    return 0;
  }
  m_pMat = pPed->m_pMat;
  m_pInteriorInfo = this->m_pInteriorInfo;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&m_pInteriorInfo->pos.x).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  if ( (float)((float)(*(float *)&v8 + *((float *)&v8 + 1)) + 0.0) <= 0.04 )
  {
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 m_pInteriorInfo->dir.x,
                                 m_pInteriorInfo->dir.y,
                                 0.0,
                                 0.0);
    v14 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v15 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v15, v14, 0.5, 0.2);
  }
  else
  {
    v9 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
    v10 = this->m_pInteriorInfo;
    v11 = *(_QWORD *)&v10->pos.x;
    vTarget.z = v10->pos.z;
    *(_QWORD *)&vTarget.x = v11;
    CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(v9, 4, &vTarget, 0.2, 3.0, 2.0, 0, -1, 1);
  }
  return result;
}

//----- (00529694) --------------------------------------------------------
CTask *__fastcall CTaskInteriorGoToInfo::CreateFirstSubTask(CTaskInteriorGoToInfo *this, CPed *pPed)
{
  InteriorInfo_t *m_pInteriorInfo; // r0
  CMatrix *m_pMat; // r5
  float x; // s0
  float y; // s2
  __int64 v8; // kr00_8
  RwReal z; // r2
  float *p_tz; // r3
  Interior_c *PedsInterior; // r4
  Interior_c *m_pInterior; // r0
  CPathNode *v13; // r0
  int CoorsZ; // s6
  RwReal v15; // s4
  CTaskComplexFollowNodeRoute *v16; // r0
  CTask *result; // r0
  float RadianAngleBetweenPoints; // r0
  float v19; // r1
  CMatrix *v20; // r0
  CTaskSimpleGoToPoint *v21; // r0
  InteriorInfo_t *v22; // r1
  __int64 v23; // d16
  CVector vTarget; // [sp+18h] [bp-18h] BYREF

  m_pInteriorInfo = this->m_pInteriorInfo;
  if ( !m_pInteriorInfo )
    return 0;
  if ( this->m_doInstantly )
  {
    m_pMat = pPed->m_pMat;
    x = m_pInteriorInfo->dir.x;
    y = m_pInteriorInfo->dir.y;
    v8 = *(_QWORD *)&m_pInteriorInfo->pos.x;
    z = m_pInteriorInfo->pos.z;
    if ( m_pMat )
    {
      LODWORD(m_pMat->tx) = v8;
      pPed->m_pMat->ty = *((float *)&v8 + 1);
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      *(_QWORD *)&pPed->m_transform.m_translate.x = v8;
      p_tz = &pPed->m_transform.m_translate.z;
    }
    *p_tz = z;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(x, y, 0.0, 0.0);
    v19 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v20 = pPed->m_pMat;
    pPed->m_fCurrentHeading = v19;
    pPed->m_fDesiredHeading = v19;
    if ( v20 )
      CMatrix::SetRotateZOnly(v20, v19);
    else
      pPed->m_transform.m_heading = v19;
    return 0;
  }
  PedsInterior = InteriorManager_c::GetPedsInterior(&g_interiorMan, pPed);
  m_pInterior = this->m_pInterior;
  if ( PedsInterior == m_pInterior )
  {
    v21 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
    v22 = this->m_pInteriorInfo;
    v23 = *(_QWORD *)&v22->pos.x;
    vTarget.z = v22->pos.z;
    *(_QWORD *)&vTarget.x = v23;
    CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v21, 4, &vTarget, 0.2, 0, 0);
  }
  else
  {
    v13 = &ThePaths.pNodes[(unsigned __int16)*(_DWORD *)&m_pInterior->m_doorAddr][HIWORD(*(_DWORD *)&m_pInterior->m_doorAddr)];
    CoorsZ = v13->CoorsZ;
    v15 = (float)v13->CoorsX * 0.125;
    vTarget.y = (float)v13->CoorsY * 0.125;
    vTarget.x = v15;
    vTarget.z = (float)CoorsZ * 0.125;
    v16 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
    CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(v16, 4, &vTarget, 0.2, 3.0, 2.0, 0, -1, 1);
    result[5]._vptr$CTask = (int (**)(void))PedsInterior->m_doorAddr;
  }
  return result;
}
// 529784: variable 'result' is possibly undefined

//----- (0052980C) --------------------------------------------------------
CTask *__fastcall CTaskInteriorGoToInfo::ControlSubTask(CTaskInteriorGoToInfo *this, CPed *pPed)
{
  if ( this->m_pInteriorInfo )
    return this->m_pSubTask;
  else
    return 0;
}

//----- (00529818) --------------------------------------------------------
void __fastcall CTaskInteriorUseInfo::CTaskInteriorUseInfo(
        CTaskInteriorUseInfo *this,
        InteriorInfo_t *pInteriorInfo,
        Interior_c *pInterior,
        int32 duration,
        bool8 doInstantly)
{
  int v8; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v8 + 12) = pInteriorInfo;
  *(_DWORD *)(v8 + 16) = pInterior;
  *(_DWORD *)(v8 + 20) = duration;
  *(_BYTE *)(v8 + 24) = doInstantly;
  *(_DWORD *)v8 = &off_66C8AC;
}
// 529830: variable 'v8' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;

//----- (00529848) --------------------------------------------------------
void __fastcall CTaskInteriorUseInfo::~CTaskInteriorUseInfo(CTaskInteriorUseInfo *this)
{
  InteriorInfo_t *m_pInteriorInfo; // r1

  m_pInteriorInfo = this->m_pInteriorInfo;
  this->_vptr$CTask = (int (**)(void))&off_66C8AC;
  if ( m_pInteriorInfo )
    m_pInteriorInfo->beingUsed = 0;
  sub_18EDB4(this);
}
// 66C8AC: using guessed type void *;

//----- (00529864) --------------------------------------------------------
void __fastcall CTaskInteriorUseInfo::~CTaskInteriorUseInfo(CTaskInteriorUseInfo *this)
{
  InteriorInfo_t *m_pInteriorInfo; // r1
  void *v2; // r0

  m_pInteriorInfo = this->m_pInteriorInfo;
  this->_vptr$CTask = (int (**)(void))&off_66C8AC;
  if ( m_pInteriorInfo )
    m_pInteriorInfo->beingUsed = 0;
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v2);
}
// 529884: variable 'v2' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;

//----- (0052988C) --------------------------------------------------------
CTask *__fastcall CTaskInteriorUseInfo::Clone(const CTaskInteriorUseInfo *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pInteriorInfo; // r5
  int (**m_pInterior)(void); // r6
  CTask *m_duration; // r8
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x1Cu);
  m_pInteriorInfo = (CTask *)this->m_pInteriorInfo;
  m_pInterior = (int (**)(void))this->m_pInterior;
  m_duration = (CTask *)this->m_duration;
  LOBYTE(this) = this->m_doInstantly;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pInteriorInfo;
  result[2]._vptr$CTask = m_pInterior;
  result[2].m_pParent = m_duration;
  LOBYTE(result[3]._vptr$CTask) = (_BYTE)this;
  result->_vptr$CTask = (int (**)(void))&off_66C8AC;
  return result;
}
// 5298AC: variable 'result' is possibly undefined
// 66C8AC: using guessed type void *off_66C8AC;

//----- (005298C8) --------------------------------------------------------
bool __fastcall CTaskInteriorUseInfo::MakeAbortable(
        CTaskInteriorUseInfo *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( this->m_pInteriorInfo->pNoCollisionEntity )
    pPed->m_pNOCollisionVehicle = 0;
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (005298EC) --------------------------------------------------------
CTask *__fastcall CTaskInteriorUseInfo::CreateNextSubTask(CTaskInteriorUseInfo *this, CPed *pPed)
{
  CTaskSimpleRunTimedAnim *v4; // r4
  InteriorInfo_t *m_pInteriorInfo; // r8
  int32 m_duration; // r6
  bool8 m_doInstantly; // r5
  char *v8; // r0
  CTaskSimpleStandStill *v9; // r0
  char *v10; // r1
  InteriorInfo_t *v11; // r8
  int32 v12; // r6
  bool8 v13; // r5
  int v14; // r3
  InteriorInfo_t *v15; // r8
  int32 v16; // r6
  float v17; // s0
  InteriorInfo_t *v18; // r8
  int32 v19; // r6
  bool8 v20; // r5
  bool v21; // r2
  CTask *v22; // r4
  CTaskSimpleRunAnim *v23; // r5

  if ( !this->m_pInteriorInfo )
    return 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1401 )
  {
    switch ( this->m_pInteriorInfo->type )
    {
      case 1:
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x2Cu);
        m_pInteriorInfo = this->m_pInteriorInfo;
        m_duration = this->m_duration;
        m_doInstantly = this->m_doInstantly;
        CTaskSimple::CTaskSimple(v4);
        LOWORD(v4->m_timer.m_iStartTime) = 0;
        v4->m_pAnim = (CAnimBlendAssociation *)m_duration;
        *((_DWORD *)&v4->CTaskSimpleAnim + 3) = m_pInteriorInfo;
        LOBYTE(v4->m_animGroup) = m_doInstantly;
        v8 = (char *)&`vtable for'CTaskInteriorSitInChair;
        goto LABEL_10;
      case 2:
        v9 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        v10 = (char *)&CWorld::m_aTempColPts[2].m_vecNormal.y + 3;
        v4 = (CTaskSimpleRunTimedAnim *)v9;
        goto LABEL_19;
      case 3:
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x30u);
        v11 = this->m_pInteriorInfo;
        v12 = this->m_duration;
        v13 = this->m_doInstantly;
        CTaskSimple::CTaskSimple(v4);
        v14 = 337;
        LOWORD(v4->m_timer.m_iStartTime) = 0;
        v4->m_pAnim = (CAnimBlendAssociation *)v12;
        *((_DWORD *)&v4->CTaskSimpleAnim + 3) = v11;
        goto LABEL_9;
      case 4:
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x30u);
        v15 = this->m_pInteriorInfo;
        v16 = this->m_duration;
        v13 = this->m_doInstantly;
        CTaskSimple::CTaskSimple(v4);
        LOWORD(v4->m_timer.m_iStartTime) = 0;
        v4->m_pAnim = (CAnimBlendAssociation *)v16;
        *((_DWORD *)&v4->CTaskSimpleAnim + 3) = v15;
        v14 = 340;
LABEL_9:
        v8 = (char *)&`vtable for'CTaskInteriorLieInBed;
        *(_DWORD *)&v4->m_timer.m_bIsActive = v14;
        BYTE1(v4->m_animGroup) = v13;
LABEL_10:
        LOWORD(v4->m_timer.m_iDuration) = 0;
        BYTE2(v4->m_timer.m_iDuration) = 0;
        v4->m_animID = ANIM_STD_WALK;
        v4->m_fBlendDelta = NAN;
        v4->m_fBlendOutDelta = 0.0;
        v4->m_iDuration = 0;
        goto LABEL_16;
      case 5:
        if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 0) )
          goto LABEL_25;
        v17 = 4.0;
        if ( this->m_doInstantly )
          v17 = 1000.0;
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
        CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
          v4,
          ANIM_INT_HOUSE_PED,
          ANIM_INT_KITCHEN_SINK,
          v17,
          4.0,
          this->m_duration,
          0);
        return v4;
      case 6:
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x38u);
        v18 = this->m_pInteriorInfo;
        v19 = this->m_duration;
        v20 = this->m_doInstantly;
        CTaskSimple::CTaskSimple(v4);
        LOWORD(v4->m_timer.m_iStartTime) = 0;
        v4->m_iTaskType = 0;
        v4->m_timer.m_iDuration = 0;
        *(_DWORD *)&v4->m_timer.m_bIsActive = 0;
        v4->m_pAnim = (CAnimBlendAssociation *)v19;
        *((_DWORD *)&v4->CTaskSimpleAnim + 3) = v18;
        LOBYTE(v4->m_animGroup) = v20;
        v4->m_animID = ANIM_STD_WALK;
        v4->m_fBlendDelta = NAN;
        v4->m_fBlendOutDelta = 0.0;
        v4->m_iDuration = 0;
        LOWORD(v4[1]._vptr$CTask) = 0;
        v8 = (char *)&`vtable for'CTaskInteriorSitAtDesk;
        BYTE2(v4[1]._vptr$CTask) = 0;
LABEL_16:
        v4->_vptr$CTask = (int (**)(void))(v8 + 8);
        return v4;
      case 7:
        if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 2) )
          goto LABEL_25;
        v9 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        v4 = (CTaskSimpleRunTimedAnim *)v9;
        v10 = (_BYTE *)(elf_hash_bucket + 4748);
LABEL_19:
        v21 = 0;
        goto LABEL_29;
      case 8:
        if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 1) )
          goto LABEL_25;
        CPed::Say(pPed, 0xBCu, 0, 1.0, 0, 0, 0);
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim((CTaskSimpleRunAnim *)v4, ANIM_INT_SHOP_PED, ANIM_INT_SHOP_SHELF, 4.0, 0);
        return v4;
      case 9:
        if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 1) )
          goto LABEL_25;
        v22 = InteriorGroup_c::GetPed(this->m_pInterior->m_pInteriorGroup, 0)->m_pPedIntelligence->m_taskManager.m_tasks[4];
        if ( (*((int (__fastcall **)(CTask *))v22->_vptr$CTask + 5))(v22) != 1405 )
          goto LABEL_25;
        LOBYTE(v22[1].m_pParent) = 1;
        CPed::Say(pPed, 0xBDu, 0, 1.0, 0, 0, 0);
        v4 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x40u);
        CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v4);
        v23 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v23, ANIM_INT_SHOP_PED, ANIM_INT_SHOP_PAY, 4.0, 0);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v4, v23);
        return v4;
      case 0xA:
        v9 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        v4 = (CTaskSimpleRunTimedAnim *)v9;
        v10 = 0;
        v21 = 1;
LABEL_29:
        CTaskSimpleStandStill::CTaskSimpleStandStill(v9, (const int)v10, v21, 0, 8.0);
        break;
      default:
        goto LABEL_25;
    }
  }
  else
  {
LABEL_25:
    v4 = 0;
    if ( this->m_pInteriorInfo->pNoCollisionEntity )
      pPed->m_pNOCollisionVehicle = 0;
  }
  return v4;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00529BB8) --------------------------------------------------------
CTask *__fastcall CTaskInteriorUseInfo::CreateFirstSubTask(CTaskInteriorUseInfo *this, CPed *pPed)
{
  InteriorInfo_t *m_pInteriorInfo; // r0
  CTaskComplex *v4; // r0
  __int64 v5; // kr00_8
  bool8 m_doInstantly; // r4
  CTask *result; // r0

  m_pInteriorInfo = this->m_pInteriorInfo;
  if ( !m_pInteriorInfo )
    return 0;
  m_pInteriorInfo->beingUsed = 1;
  v4 = (CTaskComplex *)CTask::operator new(0x18u);
  v5 = *(_QWORD *)&this->m_pInteriorInfo;
  m_doInstantly = this->m_doInstantly;
  CTaskComplex::CTaskComplex(v4);
  result->_vptr$CTask = (int (**)(void))&off_66C870;
  *(_QWORD *)&result[1].m_pParent = v5;
  LOBYTE(result[2].m_pParent) = m_doInstantly;
  return result;
}
// 529BE2: variable 'result' is possibly undefined
// 66C870: using guessed type void *off_66C870;

//----- (00529BFC) --------------------------------------------------------
CTask *__fastcall CTaskInteriorUseInfo::ControlSubTask(CTaskInteriorUseInfo *this, CPed *pPed)
{
  InteriorInfo_t *m_pInteriorInfo; // r2
  CEntity *pNoCollisionEntity; // r2

  m_pInteriorInfo = this->m_pInteriorInfo;
  if ( !m_pInteriorInfo )
    return 0;
  pNoCollisionEntity = m_pInteriorInfo->pNoCollisionEntity;
  if ( pNoCollisionEntity )
    pPed->m_pNOCollisionVehicle = pNoCollisionEntity;
  return this->m_pSubTask;
}

//----- (00529C14) --------------------------------------------------------
void __fastcall CTaskInteriorSitInChair::CTaskInteriorSitInChair(
        CTaskInteriorSitInChair *this,
        int32 duration,
        InteriorInfo_t *pInteriorInfo,
        bool8 doInstantly)
{
  int v7; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v7 + 36) = 0;
  *(_DWORD *)(v7 + 8) = duration;
  *(_DWORD *)(v7 + 12) = pInteriorInfo;
  *(_BYTE *)(v7 + 16) = doInstantly;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = -1;
  *(_WORD *)(v7 + 40) = 0;
  *(_BYTE *)(v7 + 42) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)v7 = &off_66C8E8;
}
// 529C2E: variable 'v7' is possibly undefined
// 66C8E8: using guessed type void *;

//----- (00529C58) --------------------------------------------------------
void __fastcall CTaskInteriorSitInChair::~CTaskInteriorSitInChair(CTaskInteriorSitInChair *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C8E8;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66C8E8: using guessed type void *off_66C8E8;

//----- (00529C8C) --------------------------------------------------------
void __fastcall CTaskInteriorSitInChair::~CTaskInteriorSitInChair(CTaskInteriorSitInChair *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C8E8;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 529CB6: variable 'v3' is possibly undefined
// 66C8E8: using guessed type void *off_66C8E8;

//----- (00529CC4) --------------------------------------------------------
CTask *__fastcall CTaskInteriorSitInChair::Clone(const CTaskInteriorSitInChair *this)
{
  CTaskSimple *v2; // r0
  CTask v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x2Cu);
  v3 = *(CTask *)&this->m_duration;
  LOBYTE(this) = this->m_doInstantly;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(result[4].m_pParent) = 0;
  result[1] = v3;
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  LOWORD(result[5]._vptr$CTask) = 0;
  BYTE2(result[5]._vptr$CTask) = 0;
  *(_QWORD *)&result[2].m_pParent = 0xFFFFFFFF00000000LL;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C8E8;
  return result;
}
// 529CE6: variable 'result' is possibly undefined
// 66C8E8: using guessed type void *off_66C8E8;

//----- (00529D10) --------------------------------------------------------
bool __fastcall CTaskInteriorSitInChair::MakeAbortable(
        CTaskInteriorSitInChair *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0

  if ( iPriority == 2 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      result = 1;
      this->m_pAnim = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    this->m_taskAborting = 1;
    return 0;
  }
  return result;
}

//----- (00529D74) --------------------------------------------------------
bool __fastcall CTaskInteriorSitInChair::ProcessPed(CTaskInteriorSitInChair *this, CPed *pPed)
{
  float32x2_t v2; // d3
  float32x2_t v3; // d5
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r6
  bool v8; // r6
  CAnimBlendAssociation *v9; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  RwReal z; // r8
  RwReal x; // r6
  float y; // r9
  float v15; // r1
  CMatrix *v16; // r0
  AnimationId m_prevAnimId; // r0
  int v18; // r0
  int v19; // r1
  CMatrix *v20; // r0
  float *p_tz; // r0
  int m_duration; // r0
  int v23; // r1
  CAnimBlendAssociation *v24; // r0
  unsigned int v25; // r0
  int m_iStartTime; // r1
  CAnimBlendAssociation *v27; // r0
  CAnimBlendAssociation *v28; // r0
  CAnimBlendAssociation *v29; // r0
  InteriorInfo_t *m_pInteriorInfo; // r1
  CMatrix *v31; // r0
  CSimpleTransform *p_m_transform; // r2
  float v33; // s0
  float v34; // s2
  float v35; // s4
  float v36; // s8
  float v37; // s2
  float v38; // s0
  float v39; // s6
  float v40; // s2
  float v41; // s0
  float v42; // s4
  float v43; // s6
  float v44; // s0
  float RadianAngleBetweenPoints; // r0
  InteriorGroup_c *PedsInteriorGroup; // r0
  CMatrix *v47; // r1
  CSimpleTransform *v48; // r6
  unsigned __int16 v49; // r0
  CAnimBlendAssociation *v51; // r0
  float distSq; // [sp+24h] [bp-34h] BYREF
  Interior_c *v53; // [sp+28h] [bp-30h] BYREF
  CVector v54; // [sp+2Ch] [bp-2Ch] BYREF

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_animId = m_pAnim->m_animId;
  else
    m_animId = -1;
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  if ( this->m_taskFinished && !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x158u) )
    return 1;
  if ( !this->m_taskAborting )
    goto LABEL_17;
  if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 0) )
    return 1;
  switch ( m_animId )
  {
    case 345:
      if ( !this->m_updatePedPos )
      {
        v8 = 0;
        CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
        v9 = CAnimManager::BlendAnimation(
               (RpClump_0 *)pPed->m_pRwObject,
               ANIM_INT_HOUSE_PED,
               ANIM_INT_LOUNGE_CHAIR_OUT,
               1000.0);
        this->m_pAnim = v9;
        CAnimBlendAssociation::SetFinishCallback(v9, CTaskInteriorSitInChair::FinishAnimCB, this);
        this->m_updatePedPos = 1;
        return v8;
      }
      break;
    case 344:
      this->m_pAnim->m_fSpeed = 3.0;
      break;
    case 343:
      this->m_pAnim->m_fBlendDelta = -8.0;
      break;
  }
LABEL_17:
  if ( this->m_pAnim )
  {
    if ( !this->m_updatePedPos )
      goto LABEL_42;
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    z = p_tx->m_translate.z;
    if ( m_animId == 344 )
    {
      operator*(&v54, m_pMat, &CCarEnterExit::ms_vecPedChairAnimOffset);
      x = v54.x;
      y = v54.y;
    }
    else if ( m_animId == 345 )
    {
      operator*(&v54, m_pMat, &CCarEnterExit::ms_vecPedChairAnimOffset);
      x = v54.x;
      y = v54.y;
      v15 = CGeneral::LimitRadianAngle(pPed->m_fCurrentHeading + 3.1416);
      v16 = pPed->m_pMat;
      pPed->m_fCurrentHeading = v15;
      pPed->m_fDesiredHeading = v15;
      if ( !v16 )
      {
        pPed->m_transform.m_heading = v15;
        goto LABEL_40;
      }
      CMatrix::SetRotateZOnly(v16, v15);
    }
    else
    {
      y = p_tx->m_translate.y;
      x = p_tx->m_translate.x;
    }
    v20 = pPed->m_pMat;
    if ( v20 )
    {
      v20->tx = x;
      pPed->m_pMat->ty = y;
      p_tz = &pPed->m_pMat->tz;
LABEL_41:
      *p_tz = z;
      this->m_updatePedPos = 0;
LABEL_42:
      if ( this->m_taskTimer.m_bIsActive )
      {
        if ( this->m_taskTimer.m_bIsStopped )
        {
          v25 = CTimer::m_snTimeInMilliseconds;
          this->m_taskTimer.m_bIsStopped = 0;
          this->m_taskTimer.m_iStartTime = v25;
          m_iStartTime = v25;
        }
        else
        {
          m_iStartTime = this->m_taskTimer.m_iStartTime;
          v25 = CTimer::m_snTimeInMilliseconds;
        }
        if ( m_iStartTime + this->m_taskTimer.m_iDuration <= v25 )
        {
          v27 = this->m_pAnim;
          if ( v27->m_animId != 344 )
          {
            CAnimBlendAssociation::SetDeleteCallback(v27, CDefaultAnimCallback::DefaultAnimCB, 0);
            v28 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPed->m_pRwObject,
                    ANIM_INT_HOUSE_PED,
                    ANIM_INT_LOUNGE_CHAIR_OUT,
                    1000.0);
            this->m_pAnim = v28;
            CAnimBlendAssociation::SetFinishCallback(v28, CTaskInteriorSitInChair::FinishAnimCB, this);
            this->m_updatePedPos = 1;
          }
        }
      }
      v29 = this->m_pAnim;
      if ( v29->m_animId != 343 )
        goto LABEL_54;
      m_pInteriorInfo = this->m_pInteriorInfo;
      v31 = pPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v31->tx;
      if ( !v31 )
        p_m_transform = &pPed->m_transform;
      v33 = m_pInteriorInfo->pos.x - p_m_transform->m_translate.x;
      v34 = m_pInteriorInfo->pos.y - p_m_transform->m_translate.y;
      v35 = m_pInteriorInfo->pos.z - p_m_transform->m_translate.z;
      v3.n64_u32[0] = 1017370378;
      v2.n64_f32[0] = sqrtf((float)((float)(v33 * v33) + (float)(v34 * v34)) + (float)(v35 * v35));
      v36 = 1.0 / v2.n64_f32[0];
      v37 = v34 * (float)(1.0 / v2.n64_f32[0]);
      v38 = v33 * (float)(1.0 / v2.n64_f32[0]);
      v39 = vmin_f32(v2, v3).n64_f32[0];
      v40 = v37 * v39;
      v41 = v38 * v39;
      v42 = (float)(v35 * v36) * v39;
      v43 = (float)(v31->xx * v41) + (float)(v31->yx * v40);
      v44 = (float)(v42 * v31->zy) + (float)((float)(v31->xy * v41) + (float)(v31->yy * v40));
      pPed->m_extractedVelocity.x = (float)(v31->zx * v42) + v43;
      pPed->m_extractedVelocity.y = v44;
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   this->m_pInteriorInfo->dir.x,
                                   this->m_pInteriorInfo->dir.y,
                                   0.0,
                                   0.0);
      pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      goto LABEL_53;
    }
LABEL_40:
    p_tz = &pPed->m_transform.m_translate.z;
    pPed->m_transform.m_translate.x = x;
    pPed->m_transform.m_translate.y = y;
    goto LABEL_41;
  }
  if ( InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 0) )
  {
    m_prevAnimId = this->m_prevAnimId;
    if ( m_prevAnimId == ANIM_INT_LOUNGE_CHAIR_IN )
    {
      m_duration = this->m_duration;
      if ( m_duration >= 0 )
      {
        v23 = CTimer::m_snTimeInMilliseconds;
        this->m_taskTimer.m_bIsActive = 1;
        this->m_taskTimer.m_iStartTime = v23;
        this->m_taskTimer.m_iDuration = m_duration;
      }
    }
    else
    {
      if ( m_prevAnimId != -1 )
        goto LABEL_53;
      if ( !this->m_doInstantly )
      {
        v51 = CAnimManager::BlendAnimation(
                (RpClump_0 *)pPed->m_pRwObject,
                ANIM_INT_HOUSE_PED,
                ANIM_INT_LOUNGE_CHAIR_IN,
                4.0);
        this->m_pAnim = v51;
        CAnimBlendAssociation::SetFinishCallback(v51, CTaskInteriorSitInChair::FinishAnimCB, this);
        goto LABEL_53;
      }
      v18 = this->m_duration;
      if ( v18 >= 0 )
      {
        v19 = CTimer::m_snTimeInMilliseconds;
        this->m_taskTimer.m_bIsActive = 1;
        this->m_taskTimer.m_iStartTime = v19;
        this->m_taskTimer.m_iDuration = v18;
      }
    }
    v24 = CAnimManager::BlendAnimation(
            (RpClump_0 *)pPed->m_pRwObject,
            ANIM_INT_HOUSE_PED,
            ANIM_INT_LOUNGE_CHAIR_LOOP,
            1000.0);
    this->m_pAnim = v24;
    CAnimBlendAssociation::SetFinishCallback(v24, CTaskInteriorSitInChair::FinishAnimCB, this);
    this->m_updatePedPos = 1;
  }
LABEL_53:
  v29 = this->m_pAnim;
LABEL_54:
  if ( !v29 || v29->m_animId != 345 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    return 0;
  }
  if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
    || (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) <= 980 )
  {
    return 0;
  }
  PedsInteriorGroup = InteriorManager_c::GetPedsInteriorGroup(&g_interiorMan, pPed);
  v8 = 0;
  if ( PedsInteriorGroup )
  {
    v53 = 0;
    v54.x = 0.0;
    v47 = pPed->m_pMat;
    v48 = (CSimpleTransform *)&v47->tx;
    if ( !v47 )
      v48 = &pPed->m_transform;
    InteriorGroup_c::FindClosestInteriorInfo(
      PedsInteriorGroup,
      0,
      v48->m_translate,
      10.0,
      (InteriorInfo_t **)&v54,
      &v53,
      &distSq);
    if ( LODWORD(v54.x) )
    {
      v49 = rand();
      IKChainManager_c::LookAt(
        &g_ikChainMan,
        "TaskSitInChair",
        pPed,
        0,
        (int)(float)((float)((float)v49 * 0.000015259) * 10000.0) + 10000,
        -1,
        (RwV3d_0 *)(LODWORD(v54.x) + 4),
        0,
        0.25,
        500,
        3,
        0);
    }
    return 0;
  }
  return v8;
}
// 52A06A: variable 'v2' is possibly undefined
// 52A06A: variable 'v3' is possibly undefined

//----- (0052A284) --------------------------------------------------------
void __fastcall CTaskInteriorSitInChair::FinishAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int m_animId; // r2

  m_animId = pAnim->m_animId;
  *((_DWORD *)pData + 6) = m_animId;
  if ( m_animId == 344 )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 41) = 1;
  }
  if ( *((_BYTE *)pData + 42) && *((_DWORD *)pData + 6) == 343 )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 41) = 1;
  }
  *((_DWORD *)pData + 5) = 0;
}

//----- (0052A2C4) --------------------------------------------------------
void __fastcall CTaskInteriorLieInBed::CTaskInteriorLieInBed(
        CTaskInteriorLieInBed *this,
        int32 duration,
        InteriorInfo_t *pInteriorInfo,
        int rightHandSide,
        bool8 doInstantly)
{
  int v8; // r0
  int v9; // r2

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v8 + 36) = 0;
  *(_DWORD *)(v8 + 8) = duration;
  *(_DWORD *)(v8 + 12) = pInteriorInfo;
  *(_BYTE *)(v8 + 17) = doInstantly;
  *(_DWORD *)(v8 + 20) = 0;
  *(_DWORD *)(v8 + 24) = -1;
  v9 = 337;
  if ( rightHandSide )
    v9 = 340;
  *(_DWORD *)(v8 + 44) = v9;
  *(_WORD *)(v8 + 40) = 0;
  *(_BYTE *)(v8 + 42) = 0;
  *(_DWORD *)(v8 + 28) = 0;
  *(_DWORD *)(v8 + 32) = 0;
  *(_DWORD *)v8 = &off_66C91C;
}
// 52A2E0: variable 'v8' is possibly undefined
// 66C91C: using guessed type void *;

//----- (0052A318) --------------------------------------------------------
void __fastcall CTaskInteriorLieInBed::~CTaskInteriorLieInBed(CTaskInteriorLieInBed *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C91C;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66C91C: using guessed type void *off_66C91C;

//----- (0052A34C) --------------------------------------------------------
void __fastcall CTaskInteriorLieInBed::~CTaskInteriorLieInBed(CTaskInteriorLieInBed *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C91C;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 52A376: variable 'v3' is possibly undefined
// 66C91C: using guessed type void *off_66C91C;

//----- (0052A384) --------------------------------------------------------
CTask *__fastcall CTaskInteriorLieInBed::Clone(const CTaskInteriorLieInBed *this)
{
  CTaskSimple *v2; // r0
  int32 m_duration; // r5
  InteriorInfo_t *m_pInteriorInfo; // r6
  bool8 m_doInstantly; // r8
  int m_rightHandSide; // r4
  CTask *result; // r0
  CTask *v8; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x30u);
  m_pInteriorInfo = this->m_pInteriorInfo;
  m_duration = this->m_duration;
  m_doInstantly = this->m_doInstantly;
  m_rightHandSide = this->m_rightHandSide;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(result[4].m_pParent) = 0;
  result[1] = (CTask)__PAIR64__((unsigned int)m_pInteriorInfo, m_duration);
  v8 = (CTask *)(elf_hash_bucket + 85);
  if ( m_rightHandSide )
    v8 = (CTask *)(elf_hash_bucket + 88);
  result[5].m_pParent = v8;
  BYTE1(result[2]._vptr$CTask) = m_doInstantly;
  LOWORD(result[5]._vptr$CTask) = 0;
  BYTE2(result[5]._vptr$CTask) = 0;
  *(_QWORD *)&result[2].m_pParent = 0xFFFFFFFF00000000LL;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C91C;
  return result;
}
// 52A3A6: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 66C91C: using guessed type void *off_66C91C;

//----- (0052A3E4) --------------------------------------------------------
bool __fastcall CTaskInteriorLieInBed::MakeAbortable(
        CTaskInteriorLieInBed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CPedIntelligence *m_pPedIntelligence; // r1
  bool result; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pAnim = 0;
    }
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedDuringScriptCommands = 0;
    result = 1;
    *(_WORD *)&m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedEverywhere = 1;
  }
  else
  {
    this->m_taskAborting = 1;
    return 0;
  }
  return result;
}

//----- (0052A43C) --------------------------------------------------------
bool __fastcall CTaskInteriorLieInBed::ProcessPed(CTaskInteriorLieInBed *this, CPed *pPed)
{
  float32x2_t v2; // d3
  float32x2_t v3; // d5
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r6
  int32 m_animOffset; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  bool v10; // r6
  CAnimBlendAssociation *v11; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  RwReal z; // r8
  const CVector **v15; // r2
  AnimationId m_prevAnimId; // r0
  AnimationId v17; // r2
  int v18; // r0
  int v19; // r1
  CAnimBlendAssociation *v20; // r0
  __int64 v21; // r0
  CMatrix *v22; // r2
  float *p_tz; // r0
  int32 v24; // r0
  float v25; // r1
  CMatrix *v26; // r0
  CPedIntelligence *v27; // r0
  int m_duration; // r0
  int v29; // r1
  unsigned int v30; // r0
  int m_iStartTime; // r1
  CAnimBlendAssociation *v32; // r0
  CAnimBlendAssociation *v33; // r0
  InteriorInfo_t *m_pInteriorInfo; // r1
  CMatrix *v35; // r0
  CSimpleTransform *p_m_transform; // r2
  float v37; // s0
  float v38; // s2
  float v39; // s4
  float v40; // s8
  float v41; // s2
  float v42; // s0
  float v43; // s6
  float v44; // s2
  float v45; // s0
  float v46; // s4
  float v47; // s6
  float v48; // s0
  float RadianAngleBetweenPoints; // r0
  CAnimBlendAssociation *v50; // r0
  CVector v52; // [sp+4h] [bp-1Ch] BYREF

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_animId = m_pAnim->m_animId;
  else
    m_animId = -1;
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  if ( this->m_taskFinished && !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, this->m_animOffset + 2) )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedDuringScriptCommands = 0;
LABEL_12:
    v10 = 1;
    *(_WORD *)&m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedEverywhere = 1;
    return v10;
  }
  if ( !this->m_taskAborting )
    goto LABEL_18;
  if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 0) )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedDuringScriptCommands = 0;
    goto LABEL_12;
  }
  m_animOffset = this->m_animOffset;
  if ( m_animId == m_animOffset )
  {
    this->m_pAnim->m_fBlendDelta = -8.0;
  }
  else if ( m_animId == m_animOffset + 1 )
  {
    if ( !this->m_updatePedPos )
    {
      v10 = 0;
      CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      v11 = CAnimManager::BlendAnimation(
              (RpClump_0 *)pPed->m_pRwObject,
              ANIM_INT_HOUSE_PED,
              (AnimationId)(this->m_animOffset + 2),
              1000.0);
      this->m_pAnim = v11;
      CAnimBlendAssociation::SetFinishCallback(v11, CTaskInteriorLieInBed::FinishAnimCB, this);
      this->m_updatePedPos = 1;
      return v10;
    }
  }
  else if ( m_animId == m_animOffset + 2 )
  {
    this->m_pAnim->m_fSpeed = 3.0;
  }
LABEL_18:
  if ( !this->m_pAnim )
  {
    v10 = 0;
    if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 0) )
      return v10;
    m_prevAnimId = this->m_prevAnimId;
    v17 = m_prevAnimId + 1;
    if ( m_prevAnimId == -1 )
    {
      v27 = pPed->m_pPedIntelligence;
      v27->m_eventScanner.m_acquaintanceScanner.m_bActivatedDuringScriptCommands = 0;
      *(_WORD *)&v27->m_eventScanner.m_acquaintanceScanner.m_bActivatedEverywhere = 0;
      if ( this->m_doInstantly )
      {
        m_duration = this->m_duration;
        if ( m_duration >= 0 )
        {
          v29 = CTimer::m_snTimeInMilliseconds;
          this->m_taskTimer.m_bIsActive = 1;
          this->m_taskTimer.m_iStartTime = v29;
          this->m_taskTimer.m_iDuration = m_duration;
        }
        v20 = CAnimManager::BlendAnimation(
                (RpClump_0 *)pPed->m_pRwObject,
                ANIM_INT_HOUSE_PED,
                (AnimationId)(this->m_animOffset + 1),
                1000.0);
        this->m_pAnim = v20;
        goto LABEL_44;
      }
      v50 = CAnimManager::BlendAnimation(
              (RpClump_0 *)pPed->m_pRwObject,
              ANIM_INT_HOUSE_PED,
              (AnimationId)this->m_animOffset,
              4.0);
      this->m_pAnim = v50;
      CAnimBlendAssociation::SetFinishCallback(v50, CTaskInteriorLieInBed::FinishAnimCB, this);
    }
    else if ( m_prevAnimId == this->m_animOffset )
    {
      v18 = this->m_duration;
      if ( v18 >= 0 )
      {
        v19 = CTimer::m_snTimeInMilliseconds;
        this->m_taskTimer.m_bIsActive = 1;
        this->m_taskTimer.m_iStartTime = v19;
        this->m_taskTimer.m_iDuration = v18;
      }
      v20 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_INT_HOUSE_PED, v17, 1000.0);
      this->m_pAnim = v20;
LABEL_44:
      CAnimBlendAssociation::SetFinishCallback(v20, CTaskInteriorLieInBed::FinishAnimCB, this);
      v10 = 0;
      this->m_updatePedPos = 1;
      return v10;
    }
    return 0;
  }
  if ( !this->m_updatePedPos )
    goto LABEL_46;
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  z = p_tx->m_translate.z;
  if ( (m_animId | 1) == 339 )
  {
    v15 = (const CVector **)&CCarEnterExit::ms_vecPedBedLAnimOffset;
LABEL_32:
    operator*(&v52, m_pMat, *v15);
    v21 = *(_QWORD *)&v52.x;
    goto LABEL_34;
  }
  if ( (unsigned int)(m_animId - 341) <= 1 )
  {
    v15 = (const CVector **)&CCarEnterExit::ms_vecPedBedRAnimOffset;
    goto LABEL_32;
  }
  v21 = *(_QWORD *)&p_tx->m_translate.x;
LABEL_34:
  v22 = pPed->m_pMat;
  if ( v22 )
  {
    LODWORD(v22->tx) = v21;
    pPed->m_pMat->ty = *((float *)&v21 + 1);
    p_tz = &pPed->m_pMat->tz;
  }
  else
  {
    *(_QWORD *)&pPed->m_transform.m_translate.x = v21;
    p_tz = &pPed->m_transform.m_translate.z;
  }
  *p_tz = z;
  v24 = this->m_animOffset;
  this->m_updatePedPos = 0;
  if ( m_animId == v24 + 1 )
  {
    v25 = CGeneral::LimitRadianAngle(pPed->m_fCurrentHeading + 3.1416);
    v26 = pPed->m_pMat;
    pPed->m_fCurrentHeading = v25;
    pPed->m_fDesiredHeading = v25;
    if ( v26 )
      CMatrix::SetRotateZOnly(v26, v25);
    else
      pPed->m_transform.m_heading = v25;
  }
LABEL_46:
  if ( this->m_taskTimer.m_bIsActive )
  {
    if ( this->m_taskTimer.m_bIsStopped )
    {
      v30 = CTimer::m_snTimeInMilliseconds;
      this->m_taskTimer.m_bIsStopped = 0;
      this->m_taskTimer.m_iStartTime = v30;
      m_iStartTime = v30;
    }
    else
    {
      m_iStartTime = this->m_taskTimer.m_iStartTime;
      v30 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_taskTimer.m_iDuration <= v30 )
    {
      v32 = this->m_pAnim;
      if ( this->m_animOffset + 2 != v32->m_animId )
      {
        CAnimBlendAssociation::SetDeleteCallback(v32, CDefaultAnimCallback::DefaultAnimCB, 0);
        v33 = CAnimManager::BlendAnimation(
                (RpClump_0 *)pPed->m_pRwObject,
                ANIM_INT_HOUSE_PED,
                (AnimationId)(this->m_animOffset + 2),
                1000.0);
        this->m_pAnim = v33;
        CAnimBlendAssociation::SetFinishCallback(v33, CTaskInteriorLieInBed::FinishAnimCB, this);
        this->m_updatePedPos = 1;
      }
    }
  }
  if ( this->m_animOffset != this->m_pAnim->m_animId )
    return 0;
  m_pInteriorInfo = this->m_pInteriorInfo;
  v35 = pPed->m_pMat;
  v10 = 0;
  p_m_transform = (CSimpleTransform *)&v35->tx;
  if ( !v35 )
    p_m_transform = &pPed->m_transform;
  v37 = m_pInteriorInfo->pos.x - p_m_transform->m_translate.x;
  v38 = m_pInteriorInfo->pos.y - p_m_transform->m_translate.y;
  v39 = m_pInteriorInfo->pos.z - p_m_transform->m_translate.z;
  v3.n64_u32[0] = 1017370378;
  v2.n64_f32[0] = sqrtf((float)((float)(v37 * v37) + (float)(v38 * v38)) + (float)(v39 * v39));
  v40 = 1.0 / v2.n64_f32[0];
  v41 = v38 * (float)(1.0 / v2.n64_f32[0]);
  v42 = v37 * (float)(1.0 / v2.n64_f32[0]);
  v43 = vmin_f32(v2, v3).n64_f32[0];
  v44 = v41 * v43;
  v45 = v42 * v43;
  v46 = (float)(v39 * v40) * v43;
  v47 = (float)(v35->xx * v45) + (float)(v35->yx * v44);
  v48 = (float)(v46 * v35->zy) + (float)((float)(v35->xy * v45) + (float)(v35->yy * v44));
  pPed->m_extractedVelocity.x = (float)(v35->zx * v46) + v47;
  pPed->m_extractedVelocity.y = v48;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               this->m_pInteriorInfo->dir.x,
                               this->m_pInteriorInfo->dir.y,
                               0.0,
                               0.0);
  pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  return v10;
}
// 52A754: variable 'v2' is possibly undefined
// 52A754: variable 'v3' is possibly undefined
// 677FB0: using guessed type CVector *CCarEnterExit::ms_vecPedBedLAnimOffset;

//----- (0052A828) --------------------------------------------------------
void __fastcall CTaskInteriorLieInBed::FinishAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int m_animId; // r3
  int v3; // r2

  m_animId = pAnim->m_animId;
  v3 = *((_DWORD *)pData + 11) + 2;
  *((_DWORD *)pData + 6) = m_animId;
  if ( v3 == m_animId )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 41) = 1;
  }
  if ( *((_BYTE *)pData + 42) && *((_DWORD *)pData + 6) == *((_DWORD *)pData + 11) )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 41) = 1;
  }
  *((_DWORD *)pData + 5) = 0;
}

//----- (0052A868) --------------------------------------------------------
void __fastcall CTaskInteriorSitAtDesk::CTaskInteriorSitAtDesk(
        CTaskInteriorSitAtDesk *this,
        int32 duration,
        InteriorInfo_t *pInteriorInfo,
        bool8 doInstantly)
{
  int v7; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v7 + 36) = 0;
  *(_WORD *)(v7 + 48) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_DWORD *)(v7 + 8) = duration;
  *(_DWORD *)(v7 + 12) = pInteriorInfo;
  *(_BYTE *)(v7 + 16) = doInstantly;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = -1;
  *(_WORD *)(v7 + 52) = 0;
  *(_BYTE *)(v7 + 54) = 0;
  *(_DWORD *)v7 = &off_66C950;
}
// 52A882: variable 'v7' is possibly undefined
// 66C950: using guessed type void *;

//----- (0052A8B0) --------------------------------------------------------
void __fastcall CTaskInteriorSitAtDesk::~CTaskInteriorSitAtDesk(CTaskInteriorSitAtDesk *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C950;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66C950: using guessed type void *off_66C950;

//----- (0052A8E4) --------------------------------------------------------
void __fastcall CTaskInteriorSitAtDesk::~CTaskInteriorSitAtDesk(CTaskInteriorSitAtDesk *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C950;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 52A90E: variable 'v3' is possibly undefined
// 66C950: using guessed type void *off_66C950;

//----- (0052A91C) --------------------------------------------------------
CTask *__fastcall CTaskInteriorSitAtDesk::Clone(const CTaskInteriorSitAtDesk *this)
{
  CTaskSimple *v2; // r0
  CTask v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x38u);
  v3 = *(CTask *)&this->m_duration;
  LOBYTE(this) = this->m_doInstantly;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(result[4].m_pParent) = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  result[1] = v3;
  LOBYTE(result[2]._vptr$CTask) = (_BYTE)this;
  *(_QWORD *)&result[2].m_pParent = 0xFFFFFFFF00000000LL;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  LOWORD(result[6].m_pParent) = 0;
  BYTE2(result[6].m_pParent) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C950;
  return result;
}
// 52A93E: variable 'result' is possibly undefined
// 66C950: using guessed type void *off_66C950;

//----- (0052A96C) --------------------------------------------------------
bool __fastcall CTaskInteriorSitAtDesk::MakeAbortable(
        CTaskInteriorSitAtDesk *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      result = 1;
      this->m_pAnim = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    this->m_taskAborting = 1;
    return 0;
  }
  return result;
}

//----- (0052A9AC) --------------------------------------------------------
bool __fastcall CTaskInteriorSitAtDesk::ProcessPed(CTaskInteriorSitAtDesk *this, CPed *pPed)
{
  float32x2_t v2; // d3
  float32x2_t v3; // d5
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r6
  float v8; // r1
  CMatrix *m_pMat; // r0
  bool v10; // r6
  CAnimBlendAssociation *v11; // r0
  CMatrix *v12; // r1
  CSimpleTransform *p_tx; // r2
  RwReal z; // r8
  const CVector *v15; // r2
  AnimationId m_prevAnimId; // r0
  int m_duration; // r0
  __int64 v18; // r0
  CMatrix *v19; // r2
  float *p_tz; // r0
  unsigned int v21; // r0
  int v22; // r1
  unsigned int v23; // r0
  int m_iStartTime; // r1
  CAnimBlendAssociation *v25; // r0
  CAnimBlendAssociation *v26; // r0
  int v27; // r1
  CAnimBlendAssociation *v28; // r0
  int v29; // r0
  AnimationId v30; // r2
  CAnimBlendAssociation *v31; // r0
  CAnimBlendAssociation *v32; // r0
  InteriorInfo_t *m_pInteriorInfo; // r1
  CMatrix *v34; // r0
  CSimpleTransform *p_m_transform; // r2
  float v36; // s0
  float v37; // s2
  float v38; // s4
  float v39; // s8
  float v40; // s2
  float v41; // s0
  float v42; // s6
  float v43; // s2
  float v44; // s0
  float v45; // s4
  float v46; // s6
  float v47; // s0
  float RadianAngleBetweenPoints; // r0
  float v50[3]; // [sp+0h] [bp-28h] BYREF
  CVector v51; // [sp+Ch] [bp-1Ch] BYREF

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_animId = m_pAnim->m_animId;
  else
    m_animId = -1;
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  if ( this->m_taskFinished && !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x149u) )
  {
    v8 = CGeneral::LimitRadianAngle(pPed->m_fCurrentHeading + 3.1416);
    m_pMat = pPed->m_pMat;
    pPed->m_fCurrentHeading = v8;
    pPed->m_fDesiredHeading = v8;
    if ( !m_pMat )
    {
      pPed->m_transform.m_heading = v8;
      return 1;
    }
    CMatrix::SetRotateZOnly(m_pMat, v8);
    return 1;
  }
  if ( !this->m_taskAborting )
    goto LABEL_19;
  if ( !InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 2) )
    return 1;
  if ( m_animId == 328 )
  {
    this->m_pAnim->m_fBlendDelta = -8.0;
  }
  else if ( (unsigned int)(m_animId - 330) > 6 )
  {
    if ( m_animId == 329 )
      this->m_pAnim->m_fSpeed = 2.0;
  }
  else if ( !this->m_updatePedPos )
  {
    v10 = 0;
    CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    v11 = CAnimManager::BlendAnimation(
            (RpClump_0 *)pPed->m_pRwObject,
            ANIM_INT_OFFICE_PED,
            ANIM_INT_OFFICE_DESK_OUT,
            1000.0);
    this->m_pAnim = v11;
    CAnimBlendAssociation::SetFinishCallback(v11, CTaskInteriorSitAtDesk::FinishAnimCB, this);
    this->m_updatePedPos = 1;
    return v10;
  }
LABEL_19:
  if ( !this->m_pAnim )
  {
    if ( InteriorManager_c::AreAnimsLoaded(&g_interiorMan, 2) )
    {
      m_prevAnimId = this->m_prevAnimId;
      if ( m_prevAnimId == ANIM_INT_OFFICE_DESK_IN )
      {
        m_duration = this->m_duration;
        if ( m_duration >= 0 )
        {
LABEL_54:
          v27 = CTimer::m_snTimeInMilliseconds;
          this->m_taskTimer.m_bIsActive = 1;
          this->m_taskTimer.m_iStartTime = v27;
          this->m_taskTimer.m_iDuration = m_duration;
        }
LABEL_55:
        CTaskInteriorSitAtDesk::StartRandomLoopAnim(this, pPed, 1000.0);
        v10 = 0;
        this->m_updatePedPos = 1;
        return v10;
      }
      if ( m_prevAnimId != -1 )
      {
        if ( (unsigned int)(m_prevAnimId - 333) <= 3 )
          CTaskInteriorSitAtDesk::StartRandomLoopAnim(this, pPed, 4.0);
        return 0;
      }
      if ( this->m_doInstantly )
      {
        m_duration = this->m_duration;
        if ( m_duration >= 0 )
          goto LABEL_54;
        goto LABEL_55;
      }
      v31 = CAnimManager::BlendAnimation(
              (RpClump_0 *)pPed->m_pRwObject,
              ANIM_INT_OFFICE_PED,
              ANIM_INT_OFFICE_DESK_IN,
              4.0);
      this->m_pAnim = v31;
      CAnimBlendAssociation::SetFinishCallback(v31, CTaskInteriorSitAtDesk::FinishAnimCB, this);
    }
    return 0;
  }
  if ( !this->m_updatePedPos )
    goto LABEL_39;
  v12 = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&v12->tx;
  if ( !v12 )
    p_tx = &pPed->m_transform;
  z = p_tx->m_translate.z;
  if ( (unsigned int)(m_animId - 330) > 2 )
  {
    if ( m_animId != 329 )
    {
      v18 = *(_QWORD *)&p_tx->m_translate.x;
      goto LABEL_35;
    }
    v15 = (const CVector *)v50;
    v50[0] = -CCarEnterExit::ms_vecPedDeskAnimOffset.x;
    v50[1] = -CCarEnterExit::ms_vecPedDeskAnimOffset.y;
    v50[2] = -CCarEnterExit::ms_vecPedDeskAnimOffset.z;
  }
  else
  {
    v15 = &CCarEnterExit::ms_vecPedDeskAnimOffset;
  }
  operator*(&v51, v12, v15);
  v18 = *(_QWORD *)&v51.x;
LABEL_35:
  v19 = pPed->m_pMat;
  if ( v19 )
  {
    LODWORD(v19->tx) = v18;
    pPed->m_pMat->ty = *((float *)&v18 + 1);
    p_tz = &pPed->m_pMat->tz;
  }
  else
  {
    *(_QWORD *)&pPed->m_transform.m_translate.x = v18;
    p_tz = &pPed->m_transform.m_translate.z;
  }
  *p_tz = z;
  this->m_updatePedPos = 0;
LABEL_39:
  if ( this->m_taskTimer.m_bIsActive
    && (!this->m_taskTimer.m_bIsStopped ? (v22 = this->m_taskTimer.m_iStartTime, v21 = CTimer::m_snTimeInMilliseconds) : (v21 = CTimer::m_snTimeInMilliseconds, this->m_taskTimer.m_bIsStopped = 0, this->m_taskTimer.m_iStartTime = v21, v22 = v21),
        v22 + this->m_taskTimer.m_iDuration <= v21) )
  {
    v25 = this->m_pAnim;
    if ( v25->m_animId != 329 )
    {
      CAnimBlendAssociation::SetDeleteCallback(v25, CDefaultAnimCallback::DefaultAnimCB, 0);
      v26 = CAnimManager::BlendAnimation(
              (RpClump_0 *)pPed->m_pRwObject,
              ANIM_INT_OFFICE_PED,
              ANIM_INT_OFFICE_DESK_OUT,
              1000.0);
      this->m_pAnim = v26;
      CAnimBlendAssociation::SetFinishCallback(v26, CTaskInteriorSitAtDesk::FinishAnimCB, this);
      this->m_updatePedPos = 1;
    }
  }
  else if ( this->m_animTimer.m_bIsActive )
  {
    if ( this->m_animTimer.m_bIsStopped )
    {
      v23 = CTimer::m_snTimeInMilliseconds;
      this->m_animTimer.m_bIsStopped = 0;
      this->m_animTimer.m_iStartTime = v23;
      m_iStartTime = v23;
    }
    else
    {
      m_iStartTime = this->m_animTimer.m_iStartTime;
      v23 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_animTimer.m_iDuration <= v23 )
    {
      this->m_animTimer.m_bIsActive = 0;
      if ( (rand() & 1) != 0 )
      {
        v28 = this->m_pAnim;
        if ( v28 )
          CAnimBlendAssociation::SetDeleteCallback(v28, CDefaultAnimCallback::DefaultAnimCB, 0);
        v29 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
        if ( v29 <= 60 )
        {
          if ( v29 <= 35 )
          {
            v30 = ANIM_INT_OFFICE_DESK_CRASH;
            if ( v29 > 10 )
              v30 = ANIM_INT_OFFICE_DESK_WATCH;
          }
          else
          {
            v30 = ANIM_INT_OFFICE_DESK_DRINK;
          }
        }
        else
        {
          v30 = ANIM_INT_OFFICE_DESK_READ;
        }
        v32 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_INT_OFFICE_PED, v30, 4.0);
        this->m_pAnim = v32;
        CAnimBlendAssociation::SetFinishCallback(v32, CTaskInteriorSitAtDesk::FinishAnimCB, this);
      }
      else
      {
        CTaskInteriorSitAtDesk::StartRandomLoopAnim(this, pPed, 4.0);
      }
    }
  }
  if ( this->m_pAnim->m_animId != 328 )
    return 0;
  m_pInteriorInfo = this->m_pInteriorInfo;
  v34 = pPed->m_pMat;
  v10 = 0;
  p_m_transform = (CSimpleTransform *)&v34->tx;
  if ( !v34 )
    p_m_transform = &pPed->m_transform;
  v36 = m_pInteriorInfo->pos.x - p_m_transform->m_translate.x;
  v37 = m_pInteriorInfo->pos.y - p_m_transform->m_translate.y;
  v38 = m_pInteriorInfo->pos.z - p_m_transform->m_translate.z;
  v3.n64_u32[0] = 1017370378;
  v2.n64_f32[0] = sqrtf((float)((float)(v36 * v36) + (float)(v37 * v37)) + (float)(v38 * v38));
  v39 = 1.0 / v2.n64_f32[0];
  v40 = v37 * (float)(1.0 / v2.n64_f32[0]);
  v41 = v36 * (float)(1.0 / v2.n64_f32[0]);
  v42 = vmin_f32(v2, v3).n64_f32[0];
  v43 = v40 * v42;
  v44 = v41 * v42;
  v45 = (float)(v38 * v39) * v42;
  v46 = (float)(v34->xx * v44) + (float)(v34->yx * v43);
  v47 = (float)(v45 * v34->zy) + (float)((float)(v34->xy * v44) + (float)(v34->yy * v43));
  pPed->m_extractedVelocity.x = (float)(v34->zx * v45) + v46;
  pPed->m_extractedVelocity.y = v47;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               this->m_pInteriorInfo->dir.x,
                               this->m_pInteriorInfo->dir.y,
                               0.0,
                               0.0);
  pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  return v10;
}
// 52AD90: variable 'v2' is possibly undefined
// 52AD90: variable 'v3' is possibly undefined

//----- (0052AE54) --------------------------------------------------------
void __fastcall CTaskInteriorSitAtDesk::FinishAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int m_animId; // r2

  m_animId = pAnim->m_animId;
  *((_DWORD *)pData + 6) = m_animId;
  if ( m_animId == 329 )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 53) = 1;
  }
  if ( *((_BYTE *)pData + 54) && *((_DWORD *)pData + 6) == 328 )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 53) = 1;
  }
  *((_DWORD *)pData + 5) = 0;
}

//----- (0052AE94) --------------------------------------------------------
void __fastcall CTaskInteriorSitAtDesk::StartRandomLoopAnim(CTaskInteriorSitAtDesk *this, CPed *pPed, float blendSpeed)
{
  CAnimBlendAssociation *m_pAnim; // r0
  int v7; // r5
  unsigned __int16 v8; // r0
  AnimationId v9; // r2
  int v10; // r5
  unsigned __int16 v11; // r0
  CAnimBlendAssociation *v12; // r0
  int v13; // r0

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  v7 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v7 < 41 )
  {
    v11 = rand();
    v9 = ANIM_INT_OFFICE_DESK_BOREDLOOP;
    if ( v7 > 10 )
      v9 = ANIM_INT_OFFICE_DESK_IDLELOOP;
    v10 = (int)(float)((float)((float)v11 * 0.000015259) * 3000.0) + 2000;
  }
  else
  {
    v8 = rand();
    v9 = ANIM_INT_OFFICE_DESK_TYPELOOP;
    v10 = (int)(float)((float)((float)v8 * 0.000015259) * 5000.0) + 7000;
  }
  v12 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_INT_OFFICE_PED, v9, blendSpeed);
  this->m_pAnim = v12;
  CAnimBlendAssociation::SetFinishCallback(v12, CTaskInteriorSitAtDesk::FinishAnimCB, this);
  v13 = CTimer::m_snTimeInMilliseconds;
  this->m_animTimer.m_bIsActive = 1;
  this->m_animTimer.m_iStartTime = v13;
  this->m_animTimer.m_iDuration = v10;
}

//----- (0052AF90) --------------------------------------------------------
void __fastcall CTaskInteriorSitAtDesk::StartRandomOneOffAnim(CTaskInteriorSitAtDesk *this, CPed *pPed)
{
  CAnimBlendAssociation *m_pAnim; // r0
  int v5; // r0
  AnimationId v6; // r2
  CAnimBlendAssociation *v7; // r0

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  v5 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v5 <= 60 )
  {
    if ( v5 <= 35 )
    {
      v6 = ANIM_INT_OFFICE_DESK_CRASH;
      if ( v5 > 10 )
        v6 = ANIM_INT_OFFICE_DESK_WATCH;
    }
    else
    {
      v6 = ANIM_INT_OFFICE_DESK_DRINK;
    }
  }
  else
  {
    v6 = ANIM_INT_OFFICE_DESK_READ;
  }
  v7 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_INT_OFFICE_PED, v6, 4.0);
  this->m_pAnim = v7;
  sub_18C19C(v7, CTaskInteriorSitAtDesk::FinishAnimCB, this);
}

//----- (0052B01C) --------------------------------------------------------
int __fastcall CTaskInteriorBeInHouse::GetTaskType(const CTaskInteriorBeInHouse *this)
{
  return 1402;
}

//----- (0052B022) --------------------------------------------------------
int __fastcall CTaskInteriorBeInOffice::GetTaskType(const CTaskInteriorBeInOffice *this)
{
  return 1403;
}

//----- (0052B028) --------------------------------------------------------
int __fastcall CTaskInteriorBeInShop::GetTaskType(const CTaskInteriorBeInShop *this)
{
  return 1404;
}

//----- (0052B02E) --------------------------------------------------------
int __fastcall CTaskInteriorBeInShop::GetWanderType(const CTaskInteriorBeInShop *this)
{
  return 5;
}

//----- (0052B032) --------------------------------------------------------
int __fastcall CTaskInteriorShopKeeper::GetTaskType(const CTaskInteriorShopKeeper *this)
{
  return 1405;
}

//----- (0052B038) --------------------------------------------------------
int __fastcall CTaskInteriorGoToInfo::GetTaskType(const CTaskInteriorGoToInfo *this)
{
  return 1401;
}

//----- (0052B03E) --------------------------------------------------------
int __fastcall CTaskInteriorUseInfo::GetTaskType(const CTaskInteriorUseInfo *this)
{
  return 1400;
}

//----- (0052B044) --------------------------------------------------------
int __fastcall CTaskInteriorSitInChair::GetTaskType(const CTaskInteriorSitInChair *this)
{
  return 1407;
}

//----- (0052B04A) --------------------------------------------------------
int __fastcall CTaskInteriorLieInBed::GetTaskType(const CTaskInteriorLieInBed *this)
{
  return 1406;
}

//----- (0052B050) --------------------------------------------------------
int __fastcall CTaskInteriorSitAtDesk::GetTaskType(const CTaskInteriorSitAtDesk *this)
{
  return 1408;
}

//----- (0052B058) --------------------------------------------------------
void __fastcall CTaskSimpleGetUp::CTaskSimpleGetUp(CTaskSimpleGetUp *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)v1 = &off_66C988;
}
// 52B064: variable 'v1' is possibly undefined
// 66C988: using guessed type void *;

//----- (0052B078) --------------------------------------------------------
void __fastcall CTaskSimpleGetUp::~CTaskSimpleGetUp(CTaskSimpleGetUp *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C988;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66C988: using guessed type void *off_66C988;

//----- (0052B0AC) --------------------------------------------------------
void __fastcall CTaskSimpleGetUp::~CTaskSimpleGetUp(CTaskSimpleGetUp *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C988;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 52B0D6: variable 'v3' is possibly undefined
// 66C988: using guessed type void *off_66C988;

//----- (0052B0E4) --------------------------------------------------------
bool __fastcall CTaskSimpleGetUp::MakeAbortable(
        CTaskSimpleGetUp *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool v8; // zf
  _BOOL4 v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r1

  if ( iPriority != 1 )
  {
    if ( iPriority == 2 )
    {
      m_pAnim = this->m_pAnim;
      if ( m_pAnim )
        m_pAnim->m_fBlendDelta = -1000.0;
      goto LABEL_20;
    }
LABEL_21:
    LOBYTE(v9) = 0;
    return v9;
  }
  if ( pEvent )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
    {
      v8 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
      if ( LOBYTE(pEvent[5]._vptr$CEvent) )
        v8 = !*(&pEvent->m_bIsPersistent + 1);
      if ( v8 )
      {
        v9 = 0;
        if ( (float)((float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * 3.0) < (float)(CTimer::m_snTimeInMilliseconds - *(_DWORD *)&pEvent[1].m_bIsPersistent) )
          goto LABEL_18;
      }
      else
      {
        v9 = 1;
      }
    }
    else
    {
      v10 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent);
      v9 = 0;
      if ( v10 < 61 )
        return v9;
    }
  }
  else
  {
    v9 = 0;
  }
  if ( this->m_pAnim )
  {
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
    *(_WORD *)&this->m_bHasPedGotUp = 257;
    goto LABEL_20;
  }
LABEL_18:
  if ( !this->m_bHasPedGotUp && !v9 )
    goto LABEL_21;
LABEL_20:
  v11 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v12 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  v13 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v13;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v11;
  LOBYTE(v9) = 1;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v12 & 0xFFFFFFF7;
  return v9;
}

//----- (0052B210) --------------------------------------------------------
bool __fastcall CTaskSimpleGetUp::ProcessPed(CTaskSimpleGetUp *this, CPed *pPed)
{
  int m_nPedFlags; // r12
  int v6; // r1
  unsigned int v7; // r2
  int v8; // r3
  CAnimBlendAssociation *m_pAnim; // r0
  CPedFlags *p_m_nPedFlags; // r5

  pPed->m_ik.m_flags |= 8u;
  if ( this->m_bIsFinished )
    return 1;
  if ( this->m_pAnim || (CTaskSimpleGetUp::StartAnim(this, pPed), this->m_pAnim) )
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    v6 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    v7 = *((_DWORD *)&pPed->m_nPedFlags + 3) & 0xFFFFFFF7;
    v8 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v7;
    m_pAnim = this->m_pAnim;
    p_m_nPedFlags = &pPed->m_nPedFlags;
    if ( m_pAnim && m_pAnim->m_fCurrentTime >= (float)(m_pAnim->m_pAnimBlendHierarchy->m_fTotalTime * 0.75) )
      return 0;
  }
  else
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    p_m_nPedFlags = &pPed->m_nPedFlags;
    v6 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    v8 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v7 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  }
  *(_DWORD *)p_m_nPedFlags = m_nPedFlags;
  *((_DWORD *)p_m_nPedFlags + 1) = v6;
  *((_DWORD *)p_m_nPedFlags + 2) = v8 | 0x100000;
  *((_DWORD *)p_m_nPedFlags + 3) = v7;
  return 0;
}

//----- (0052B2A4) --------------------------------------------------------
bool __fastcall CTaskSimpleGetUp::StartAnim(CTaskSimpleGetUp *this, CPed *pPed)
{
  CEntity *v4; // r0
  CPhysical *v5; // r5
  bool v6; // zf
  RwReal x; // r0
  bool v8; // zf
  CEntity *m_pNOCollisionVehicle; // r0
  int (**v10)(void); // r1
  bool v11; // zf
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *FirstAssociation; // r0
  float v14; // r3
  AnimationId v15; // r2
  CAnimBlendAssociation *v16; // r0
  bool v17; // r6
  CEntity *v20; // r10
  CMatrix *m_pMat; // r8
  const CMatrix *v22; // r2
  CColModel *m_pColModel; // r9
  CEntity *v24; // r0
  float v25; // s0
  const CEventDamage *v26; // r0
  CEventDamage v27; // [sp+14h] [bp-6Ch] BYREF
  CPedDamageResponseCalculator v28; // [sp+54h] [bp-2Ch] BYREF

  v4 = CPedPlacement::IsPositionClearOfCars(pPed);
  v5 = (CPhysical *)v4;
  v6 = v4 == 0;
  if ( v4 )
    v6 = v4[24]._vptr$CPlaceable == (int (**)(void))byte_9;
  if ( !v6 )
  {
    x = v4[24].m_transform.m_translate.x;
    v8 = LODWORD(x) == 2;
    if ( LODWORD(x) != 2 )
      v8 = v5 == pPed->m_pAttachToEntity;
    if ( !v8 && pPed->m_pGroundPhysical != v5 )
      goto LABEL_26;
  }
  m_pNOCollisionVehicle = pPed->m_pNOCollisionVehicle;
  if ( !m_pNOCollisionVehicle || (*(_BYTE *)&m_pNOCollisionVehicle->m_info & 7) != 2 )
    goto LABEL_14;
  v10 = m_pNOCollisionVehicle[24]._vptr$CPlaceable;
  v11 = v10 == (int (**)(void))byte_9;
  if ( v10 != (int (**)(void))byte_9 )
    v11 = LODWORD(m_pNOCollisionVehicle[24].m_transform.m_translate.x) == 2;
  if ( v11 )
    goto LABEL_14;
  if ( !IsVehiclePointerValid((CVehicle *)m_pNOCollisionVehicle) )
    goto LABEL_14;
  if ( (CTimer::m_FrameCounter + pPed->RandomSeed + 5) << 29 )
    goto LABEL_26;
  v20 = pPed->m_pNOCollisionVehicle;
  m_pMat = pPed->m_pMat;
  v22 = v20->m_pMat;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[pPed->m_nModelIndex]->m_pColModel;
  if ( v22 )
  {
    v24 = pPed->m_pNOCollisionVehicle;
  }
  else
  {
    CPlaceable::AllocateMatrix(pPed->m_pNOCollisionVehicle);
    CSimpleTransform::UpdateMatrix(&v20->m_transform, v20->m_pMat);
    v24 = pPed->m_pNOCollisionVehicle;
    v22 = v20->m_pMat;
  }
  if ( CCollision::ProcessColModels(
         m_pMat,
         m_pColModel,
         v22,
         CModelInfo::ms_modelInfoPtrs[v24->m_nModelIndex]->m_pColModel,
         aTempPedColPts,
         0,
         0,
         0) < 1 )
  {
LABEL_14:
    m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
    pPed->m_pNOCollisionVehicle = 0;
    FirstAssociation = RpAnimBlendClumpGetFirstAssociation(m_pRwObject, 0x800u);
    LOWORD(v14) = 0;
    v15 = ANIM_STD_GET_UP;
    if ( FirstAssociation )
      v15 = ANIM_STD_GET_UP_FRONT;
    HIWORD(v14) = 17530;
    v16 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v15, v14);
    this->m_pAnim = v16;
    CAnimBlendAssociation::SetFinishCallback(v16, CTaskSimpleGetUp::FinishAnimGetUpCB, this);
    v17 = 1;
    CPed::SetPedState(pPed, PED_IDLE);
  }
  else
  {
LABEL_26:
    *((_DWORD *)&pPed->m_nPedFlags + 3) |= 8u;
    if ( CPed::IsPlayer(pPed) )
    {
      v25 = CTimer::ms_fTimeStep;
      if ( CTimer::ms_fTimeStep <= 0.0 )
        return 0;
    }
    else
    {
      v17 = 0;
      if ( !CPad::GetPad(0)->DisablePlayerControls )
        return v17;
      v25 = 1000.0;
    }
    CPedDamageResponseCalculator::CPedDamageResponseCalculator(
      &v28,
      v5,
      v25,
      WEAPONTYPE_RUNOVERBYCAR,
      PED_SPHERE_CHEST,
      0);
    CEventDamage::CEventDamage(
      &v27,
      v5,
      CTimer::m_snTimeInMilliseconds,
      WEAPONTYPE_RUNOVERBYCAR,
      PED_SPHERE_CHEST,
      0,
      0,
      *(_DWORD *)&pPed->m_nPedFlags & 0x100);
    if ( CEventDamage::AffectsPed(v26, pPed) )
      CPedDamageResponseCalculator::ComputeDamageResponse(&v28, pPed, &v27.m_pedDamageResponse, 1);
    else
      v27.m_pedDamageResponse.m_bDamageCalculated = 1;
    v17 = 0;
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v27, 0);
    CEventDamage::~CEventDamage(&v27);
    CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v28);
  }
  return v17;
}
// 52B454: variable 'v26' is possibly undefined

//----- (0052B4B4) --------------------------------------------------------
void __fastcall CTaskSimpleGetUp::FinishAnimGetUpCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v2; // r0

  v2 = *((_DWORD *)pData + 3);
  *((_BYTE *)pData + 9) = 1;
  *(_DWORD *)(v2 + 28) = -998637568;
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (0052B4CC) --------------------------------------------------------
void __fastcall CTaskComplexGetUpAndStandStill::CTaskComplexGetUpAndStandStill(CTaskComplexGetUpAndStandStill *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66C9BC;
}
// 52B4DC: variable 'v1' is possibly undefined
// 66C9BC: using guessed type void *;

//----- (0052B4E8) --------------------------------------------------------
void __fastcall CTaskComplexGetUpAndStandStill::~CTaskComplexGetUpAndStandStill(CTaskComplexGetUpAndStandStill *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52B4F4: variable 'v1' is possibly undefined

//----- (0052B4F8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetUpAndStandStill::CreateSubTask(
        CTaskComplexGetUpAndStandStill *this,
        const int iSubTaskType)
{
  CTask *result; // r0
  CTaskSimple *v3; // r0
  CTaskSimpleStandStill *v4; // r0

  if ( iSubTaskType == 203 )
  {
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v4, 0, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 205 )
  {
    v3 = (CTaskSimple *)CTask::operator new(0x10u);
    CTaskSimple::CTaskSimple(v3);
    LOWORD(result[1]._vptr$CTask) = 0;
    result[1].m_pParent = 0;
    result->_vptr$CTask = (int (**)(void))&off_66C988;
  }
  else
  {
    return 0;
  }
  return result;
}
// 52B51A: variable 'result' is possibly undefined
// 66C988: using guessed type void *off_66C988;

//----- (0052B548) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetUpAndStandStill::CreateNextSubTask(CTaskComplexGetUpAndStandStill *this, CPed *pPed)
{
  CTaskSimpleStandStill *v3; // r0
  CTask *result; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 205
    || !LOBYTE(this->m_pSubTask[1]._vptr$CTask) )
  {
    return 0;
  }
  v3 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v3, 0, 0, 0, 8.0);
  return result;
}

//----- (0052B584) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetUpAndStandStill::CreateFirstSubTask(CTaskComplexGetUpAndStandStill *this, CPed *pPed)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x10u);
  CTaskSimple::CTaskSimple(v2);
  LOWORD(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C988;
  return result;
}
// 52B596: variable 'result' is possibly undefined
// 66C988: using guessed type void *off_66C988;

//----- (0052B5A8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetUpAndStandStill::ControlSubTask(CTaskComplexGetUpAndStandStill *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0052B5AC) --------------------------------------------------------
void __fastcall CTaskSimpleFall::CTaskSimpleFall(
        CTaskSimpleFall *this,
        const AnimationId animID,
        const AssocGroupId animGroup,
        uint32 nPauseTime)
{
  int v7; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v7 + 8) = 0;
  *(_DWORD *)(v7 + 12) = animID;
  *(_DWORD *)(v7 + 16) = animGroup;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = nPauseTime;
  *(_DWORD *)(v7 + 28) = nPauseTime;
  *(_DWORD *)v7 = &off_66C9F8;
}
// 52B5C2: variable 'v7' is possibly undefined
// 66C9F8: using guessed type void *;

//----- (0052B5E0) --------------------------------------------------------
void __fastcall CTaskSimpleFall::~CTaskSimpleFall(CTaskSimpleFall *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C9F8;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66C9F8: using guessed type void *off_66C9F8;

//----- (0052B614) --------------------------------------------------------
void __fastcall CTaskSimpleFall::~CTaskSimpleFall(CTaskSimpleFall *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66C9F8;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 52B63E: variable 'v3' is possibly undefined
// 66C9F8: using guessed type void *off_66C9F8;

//----- (0052B64C) --------------------------------------------------------
bool __fastcall CTaskSimpleFall::MakeAbortable(
        CTaskSimpleFall *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *Association; // r9
  CAnimBlendAssociation *v9; // r0
  bool result; // r0
  float v11; // s0
  CAnimBlendAssociation *m_pAnim; // r0

  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Du);
  if ( Association )
  {
    if ( iPriority == 2 )
    {
LABEL_3:
      v9 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, this->m_animID);
      if ( v9 )
        v9->m_fBlendDelta = -1000.0;
      if ( Association )
        Association->m_fBlendDelta = -1000.0;
      this->m_nPauseCountdown = 0;
      result = 1;
      this->m_bIsFinished = 1;
      return result;
    }
  }
  else
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Cu);
    if ( iPriority == 2 )
      goto LABEL_3;
  }
  result = 0;
  if ( iPriority == 1 && pEvent )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 && pPed->m_nHealth < 1.0
      || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 66
      || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent) == 71
      || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 93 )
    {
      if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 66
        || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 93 )
      {
        v11 = -8.0;
      }
      else
      {
        v11 = -2.0;
      }
      if ( Association )
        Association->m_fBlendDelta = v11;
      m_pAnim = this->m_pAnim;
      if ( m_pAnim )
      {
        m_pAnim->m_fBlendDelta = v11;
        CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      }
      result = 1;
      this->m_bIsFinished = 1;
      this->m_pAnim = 0;
      this->m_nPauseCountdown = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0052B770) --------------------------------------------------------
bool __fastcall CTaskSimpleFall::ProcessPed(CTaskSimpleFall *this, CPed *pPed)
{
  int v4; // r2
  bool v5; // zf
  _BOOL4 m_bIsFinished; // r0
  uint32 m_nPauseCountdown; // r0
  unsigned int v8; // r1
  uint32 v9; // r0

  v4 = *((_DWORD *)&pPed->m_nPedFlags + 2) | 0x100000;
  v5 = (*(_DWORD *)&pPed->m_nPedFlags & 1 | *((_DWORD *)&pPed->m_nPedFlags + 1) & 0x80000) == 0;
  pPed->m_ik.m_flags |= 8u;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v4;
  m_bIsFinished = this->m_bIsFinished;
  if ( !v5 )
    v5 = !m_bIsFinished;
  if ( v5 )
  {
    if ( !this->m_pAnim && !m_bIsFinished )
      m_bIsFinished = CTaskSimpleFall::StartAnim(this, pPed);
    CTaskSimpleFall::ProcessFall((CTaskSimpleFall *)m_bIsFinished, pPed);
    return 0;
  }
  m_nPauseCountdown = this->m_nPauseCountdown;
  v8 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
  if ( m_nPauseCountdown > v8 )
  {
    v9 = m_nPauseCountdown - v8;
    this->m_nPauseCountdown = v9;
    if ( v9 > 0x1F4
      && CPed::IsPlayer(pPed)
      && (*((_BYTE *)&pPed->m_nPedFlags + 8) & 0x40) == 0
      && pPed->m_nPedState != PED_ARRESTED
      && CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed)
      && !CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed)->DisablePlayerControls )
    {
      this->m_nPauseCountdown = 500 - (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    }
    return 0;
  }
  this->m_nPauseCountdown = 0;
  return 1;
}

//----- (0052B86C) --------------------------------------------------------
bool __fastcall CTaskSimpleFall::StartAnim(CTaskSimpleFall *this, CPed *pPed)
{
  uint32 m_animID; // r1
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v8; // r0
  CAnimBlendAssociation *v9; // r0

  if ( pPed->m_pAttachToEntity )
    return 0;
  m_animID = this->m_animID;
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( m_animID == 191 )
  {
    Association = RpAnimBlendClumpGetAssociation(m_pRwObject, 0x69u);
    this->m_pAnim = Association;
    if ( Association )
      goto LABEL_9;
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x6Au);
    this->m_pAnim = Association;
    if ( Association )
      goto LABEL_9;
  }
  else
  {
    v8 = RpAnimBlendClumpGetAssociation(m_pRwObject, m_animID);
    this->m_pAnim = v8;
    if ( v8 )
    {
      CAnimBlendAssociation::SetCurrentTime(v8, 0.0);
      this->m_pAnim->m_fBlendAmount = 0.0;
      this->m_pAnim->m_fBlendDelta = 8.0;
      this->m_pAnim->m_bitsFlag |= 5u;
      this->m_pAnim->m_bitsFlag &= ~8u;
      Association = this->m_pAnim;
LABEL_9:
      CAnimBlendAssociation::SetFinishCallback(Association, CTaskSimpleFall::FinishAnimFallCB, this);
      return 1;
    }
    v9 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, this->m_animGroup, this->m_animID, 8.0);
    this->m_pAnim = v9;
    v9->m_bitsFlag |= 4u;
    this->m_pAnim->m_bitsFlag &= ~8u;
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CTaskSimpleFall::FinishAnimFallCB, this);
    if ( this->m_animID == ANIM_STD_BIKE_FALLBACK )
      CAnimBlendAssociation::SetCurrentTime(this->m_pAnim, 0.4);
  }
  return 1;
}

//----- (0052B940) --------------------------------------------------------
void __fastcall CTaskSimpleFall::ProcessFall(CTaskSimpleFall *this, CPed *pPed)
{
  _BOOL4 IsPlayer; // r0
  int v4; // r1
  bool v5; // zf
  CAnimBlendAssociation *FirstAssociation; // r0
  CAnimBlendAssociation *v7; // r6
  CAnimBlendAssociation *Association; // r5
  CAnimBlendAssociation *v9; // r0
  CAnimBlendAssociation *v10; // r0
  AnimationId v11; // r2
  CAnimBlendAssociation *v12; // r0
  float m_fCurrentTime; // s2

  IsPlayer = CPed::IsPlayer(pPed);
  v4 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v5 = !IsPlayer;
  if ( IsPlayer )
    v5 = (v4 & 0x80000010) == 0;
  if ( !v5 && (*(_DWORD *)&pPed->m_nPedFlags & 1) == 0 )
  {
    FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPed->m_pRwObject, 0x10u);
    v7 = FirstAssociation;
    if ( FirstAssociation && (FirstAssociation->m_animId & 0xFFFFFFFE) == 124 )
    {
      Association = FirstAssociation;
LABEL_29:
      if ( Association->m_fBlendAmount > 0.3 && Association->m_fBlendDelta >= 0.0 )
      {
        m_fCurrentTime = Association->m_fCurrentTime;
        if ( m_fCurrentTime > 0.667 && (float)(m_fCurrentTime - Association->m_fTimeStep) <= 0.667 )
        {
          CAnimBlendAssociation::SetCurrentTime(Association, 0.0);
          Association->m_bitsFlag |= 1u;
        }
      }
      return;
    }
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Cu);
    if ( Association )
      goto LABEL_29;
    v10 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Du);
    if ( !v7 )
    {
      Association = v10;
      if ( !v10 )
        return;
      goto LABEL_29;
    }
    Association = v10;
    if ( !v10 )
    {
      if ( v7->m_fCurrentTime > (float)(v7->m_pAnimBlendHierarchy->m_fTotalTime * 0.8) )
      {
        if ( (v7->m_bitsFlag & 0x800) != 0 )
          v11 = ANIM_STD_FALL_ONFRONT;
        else
          v11 = ANIM_STD_FALL_ONBACK;
        sub_197F5C((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v11, 8.0);
        return;
      }
      Association = 0;
    }
    if ( !v10 )
      return;
    goto LABEL_29;
  }
  if ( (*(_DWORD *)&pPed->m_nPedFlags & 3) == 1 && (v4 & 0x80000010) != 0 )
  {
    v9 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Cu);
    if ( v9 || (v9 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Du)) != 0 )
    {
      *((_DWORD *)&pPed->m_nPedFlags + 1) &= ~0x10u;
      v9->m_fSpeed = 3.0;
    }
    else
    {
      v12 = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPed->m_pRwObject, 0x10u);
      if ( v12 && !(LOBYTE(v12->m_bitsFlag) << 31) )
        *((_DWORD *)&pPed->m_nPedFlags + 1) &= ~0x10u;
    }
  }
}

//----- (0052BAB8) --------------------------------------------------------
void __fastcall CTaskSimpleFall::FinishAnimFallCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 5) = 0;
}

//----- (0052BAC4) --------------------------------------------------------
void __fastcall CTaskComplexFallAndGetUp::CTaskComplexFallAndGetUp(
        CTaskComplexFallAndGetUp *this,
        const AnimationId animID,
        const AssocGroupId animGroup,
        const int iDownTime)
{
  _DWORD *v7; // r0

  CTaskComplex::CTaskComplex(this);
  v7[3] = animID;
  v7[4] = animGroup;
  v7[5] = iDownTime;
  *v7 = &off_66CA2C;
}
// 52BAD8: variable 'v7' is possibly undefined
// 66CA2C: using guessed type void *;

//----- (0052BAF0) --------------------------------------------------------
void __fastcall CTaskComplexFallAndGetUp::CTaskComplexFallAndGetUp(
        CTaskComplexFallAndGetUp *this,
        const int iDir,
        const int iDownTime)
{
  _DWORD *v5; // r0

  CTaskComplex::CTaskComplex(this);
  v5[5] = iDownTime;
  *v5 = &off_66CA2C;
  if ( (unsigned int)iDir <= 3 )
    v5[3] = iDir + 24;
  v5[4] = 0;
}
// 52BB00: variable 'v5' is possibly undefined
// 66CA2C: using guessed type void *off_66CA2C;

//----- (0052BB24) --------------------------------------------------------
void __fastcall CTaskComplexFallAndGetUp::~CTaskComplexFallAndGetUp(CTaskComplexFallAndGetUp *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52BB30: variable 'v1' is possibly undefined

//----- (0052BB34) --------------------------------------------------------
void __fastcall CTaskComplexFallAndGetUp::SetDownTime(CTaskComplexFallAndGetUp *this, const int iDownTime)
{
  CTask *m_pSubTask; // r0
  CTask *v4; // r0
  int m_iDownTime; // r1

  m_pSubTask = this->m_pSubTask;
  this->m_iDownTime = iDownTime;
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 207 )
  {
    v4 = this->m_pSubTask;
    m_iDownTime = this->m_iDownTime;
    v4[3]._vptr$CTask = (int (**)(void))m_iDownTime;
    v4[3].m_pParent = (CTask *)m_iDownTime;
  }
}

//----- (0052BB52) --------------------------------------------------------
bool __fastcall CTaskComplexFallAndGetUp::IsFalling(const CTaskComplexFallAndGetUp *this)
{
  CTask *m_pSubTask; // r0
  bool v2; // r4

  m_pSubTask = this->m_pSubTask;
  v2 = 0;
  if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 207 )
    return 1;
  return v2;
}

//----- (0052BB6C) --------------------------------------------------------
bool __fastcall CTaskComplexFallAndGetUp::MakeAbortable(
        CTaskComplexFallAndGetUp *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int (**v8)(void); // r1
  CTask *m_pSubTask; // r0
  CTask *v11; // r0

  if ( iPriority == 2 )
  {
    v8 = this->m_pSubTask->CTaskComplex::_vptr$CTask;
    return v8[7]();
  }
  if ( pPed->m_nPedState != PED_ARRESTED && (*((_BYTE *)&pPed->m_nPedFlags + 8) & 0x40) == 0 )
  {
    m_pSubTask = this->m_pSubTask;
    if ( iPriority == 1 )
    {
      v8 = m_pSubTask->_vptr$CTask;
      return v8[7]();
    }
    if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 207 )
    {
      v11 = this->m_pSubTask;
      this->m_iDownTime = 0;
      (*((void (__fastcall **)(CTask *, CPed *, const int, const CEvent *))v11->_vptr$CTask + 7))(
        v11,
        pPed,
        iPriority,
        pEvent);
    }
  }
  return 0;
}

//----- (0052BBD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndGetUp::CreateNextSubTask(CTaskComplexFallAndGetUp *this, CPed *pPed)
{
  CTask *v2; // r4
  CTaskSimple *v3; // r0
  int v4; // r0

  v2 = 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 207 )
  {
    v3 = (CTaskSimple *)CTask::operator new(0x10u);
    CTaskSimple::CTaskSimple(v3);
    *(_WORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    v2 = (CTask *)v4;
    *(_DWORD *)v4 = &off_66C988;
  }
  return v2;
}
// 52BBF6: variable 'v4' is possibly undefined
// 66C988: using guessed type void *off_66C988;

//----- (0052BC0C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndGetUp::CreateSubTask(CTaskComplexFallAndGetUp *this, const int iSubTaskType)
{
  CTaskSimple *v3; // r4
  CTaskSimple *v4; // r0
  __int64 v5; // kr00_8
  int m_iDownTime; // r5
  CTaskSimple *v7; // r0
  int v8; // r0

  v3 = 0;
  if ( iSubTaskType == 205 )
  {
    v7 = (CTaskSimple *)CTask::operator new(0x10u);
    CTaskSimple::CTaskSimple(v7);
    *(_WORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    v3 = (CTaskSimple *)v8;
    *(_DWORD *)v8 = &off_66C988;
  }
  else if ( iSubTaskType == 207 )
  {
    v4 = (CTaskSimple *)CTask::operator new(0x20u);
    v5 = *(_QWORD *)&this->m_animID;
    v3 = v4;
    m_iDownTime = this->m_iDownTime;
    CTaskSimple::CTaskSimple(v4);
    LOBYTE(v3[1]._vptr$CTask) = 0;
    *(_QWORD *)&v3[1].m_pParent = v5;
    v3[2].m_pParent = 0;
    v3[3]._vptr$CTask = (int (**)(void))m_iDownTime;
    v3[3].m_pParent = (CTask *)m_iDownTime;
    v3->_vptr$CTask = (int (**)(void))&off_66C9F8;
  }
  return v3;
}
// 52BC58: variable 'v8' is possibly undefined
// 66C988: using guessed type void *off_66C988;
// 66C9F8: using guessed type void *off_66C9F8;

//----- (0052BC78) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndGetUp::CreateFirstSubTask(CTaskComplexFallAndGetUp *this, CPed *pPed)
{
  CTaskSimple *v3; // r0
  __int64 v4; // kr00_8
  int (**m_iDownTime)(void); // r4
  CTask *result; // r0

  v3 = (CTaskSimple *)CTask::operator new(0x20u);
  v4 = *(_QWORD *)&this->m_animID;
  m_iDownTime = (int (**)(void))this->m_iDownTime;
  CTaskSimple::CTaskSimple(v3);
  LOBYTE(result[1]._vptr$CTask) = 0;
  *(_QWORD *)&result[1].m_pParent = v4;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = m_iDownTime;
  result[3].m_pParent = (CTask *)m_iDownTime;
  result->_vptr$CTask = (int (**)(void))&off_66C9F8;
  return result;
}
// 52BC96: variable 'result' is possibly undefined
// 66C9F8: using guessed type void *off_66C9F8;

//----- (0052BCB4) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndGetUp::ControlSubTask(CTaskComplexFallAndGetUp *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0052BCB8) --------------------------------------------------------
void __fastcall CTaskComplexFallAndStayDown::CTaskComplexFallAndStayDown(
        CTaskComplexFallAndStayDown *this,
        const AnimationId animID,
        const AssocGroupId animGroup)
{
  _DWORD *v5; // r0

  CTaskComplex::CTaskComplex(this);
  v5[3] = animID;
  v5[4] = animGroup;
  *v5 = &off_66CA68;
}
// 52BCC6: variable 'v5' is possibly undefined
// 66CA68: using guessed type void *off_66CA68;

//----- (0052BCD8) --------------------------------------------------------
void __fastcall CTaskComplexFallAndStayDown::CTaskComplexFallAndStayDown(
        CTaskComplexFallAndStayDown *this,
        const int iDir)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  *v3 = &off_66CA68;
  if ( (unsigned int)iDir <= 3 )
    v3[3] = iDir + 24;
  v3[4] = 0;
}
// 52BCEE: variable 'v3' is possibly undefined
// 66CA68: using guessed type void *;

//----- (0052BD08) --------------------------------------------------------
void __fastcall CTaskComplexFallAndStayDown::~CTaskComplexFallAndStayDown(CTaskComplexFallAndStayDown *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52BD14: variable 'v1' is possibly undefined

//----- (0052BD18) --------------------------------------------------------
bool __fastcall CTaskComplexFallAndStayDown::MakeAbortable(
        CTaskComplexFallAndStayDown *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0
  int v9; // r2

  if ( iPriority == 1 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 207 )
    {
      m_pSubTask = this->m_pSubTask;
      v9 = 1;
      return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
               m_pSubTask,
               pPed,
               v9,
               pEvent);
    }
  }
  else
  {
    if ( iPriority == 2 )
    {
      m_pSubTask = this->m_pSubTask;
      v9 = 2;
      return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
               m_pSubTask,
               pPed,
               v9,
               pEvent);
    }
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 207 )
      (*((void (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
       + 7))(
        this->m_pSubTask,
        pPed,
        iPriority,
        pEvent);
  }
  return 0;
}

//----- (0052BD7C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndStayDown::CreateNextSubTask(CTaskComplexFallAndStayDown *this, CPed *pPed)
{
  (*((void (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  return 0;
}

//----- (0052BD8C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndStayDown::CreateSubTask(CTaskComplexFallAndStayDown *this, const int iSubTaskType)
{
  CTask *v3; // r4
  CTaskSimple *v4; // r0
  __int64 v5; // kr00_8
  int v6; // r0

  v3 = 0;
  if ( iSubTaskType == 207 )
  {
    v4 = (CTaskSimple *)CTask::operator new(0x20u);
    v5 = *(_QWORD *)&this->m_animID;
    CTaskSimple::CTaskSimple(v4);
    *(_BYTE *)(v6 + 8) = 0;
    *(_QWORD *)(v6 + 12) = v5;
    *(_DWORD *)(v6 + 20) = 0;
    *(_DWORD *)(v6 + 24) = 99999999;
    v3 = (CTask *)v6;
    *(_DWORD *)(v6 + 28) = 99999999;
    *(_DWORD *)v6 = &off_66C9F8;
  }
  return v3;
}
// 52BDB4: variable 'v6' is possibly undefined
// 66C9F8: using guessed type void *off_66C9F8;

//----- (0052BDD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndStayDown::CreateFirstSubTask(CTaskComplexFallAndStayDown *this, CPed *pPed)
{
  CTaskSimple *v3; // r0
  __int64 v4; // kr00_8
  CTask *result; // r0

  v3 = (CTaskSimple *)CTask::operator new(0x20u);
  v4 = *(_QWORD *)&this->m_animID;
  CTaskSimple::CTaskSimple(v3);
  LOBYTE(result[1]._vptr$CTask) = 0;
  *(_QWORD *)&result[1].m_pParent = v4;
  *(_QWORD *)&result[2].m_pParent = 0x5F5E0FF00000000LL;
  result[3].m_pParent = (CTask *)99999999;
  result->_vptr$CTask = (int (**)(void))&off_66C9F8;
  return result;
}
// 52BDFA: variable 'result' is possibly undefined
// 66C9F8: using guessed type void *off_66C9F8;

//----- (0052BE14) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndStayDown::ControlSubTask(CTaskComplexFallAndStayDown *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0052BE18) --------------------------------------------------------
void __fastcall CTaskComplexInAirAndLand::CTaskComplexInAirAndLand(
        CTaskComplexInAirAndLand *this,
        bool bJump,
        bool bToDeath)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_BYTE *)(v5 + 12) = bJump;
  *(_BYTE *)(v5 + 13) = bToDeath;
  *(_BYTE *)(v5 + 14) = 0;
  *(_DWORD *)v5 = &off_66CAA4;
}
// 52BE28: variable 'v5' is possibly undefined
// 66CAA4: using guessed type void *;

//----- (0052BE40) --------------------------------------------------------
void __fastcall CTaskComplexInAirAndLand::~CTaskComplexInAirAndLand(CTaskComplexInAirAndLand *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52BE4C: variable 'v1' is possibly undefined

//----- (0052BE50) --------------------------------------------------------
CTask *__fastcall CTaskComplexInAirAndLand::CreateFirstSubTask(CTaskComplexInAirAndLand *this, CPed *pPed)
{
  CTaskSimple *v3; // r0
  int m_bIsJumping; // r5
  int m_bIsFallingToDeath; // r4
  CTask *result; // r0
  char m_pParent; // r3

  v3 = (CTaskSimple *)CTask::operator new(0x3Cu);
  m_bIsJumping = this->m_bIsJumping;
  m_bIsFallingToDeath = this->m_bIsFallingToDeath;
  CTaskSimple::CTaskSimple(v3);
  *(int (***)(void))((char *)&result[6]._vptr$CTask + 2) = 0;
  *(CTask **)((char *)&result[5].m_pParent + 2) = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  result[7]._vptr$CTask = 0;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  m_pParent = (char)result[4].m_pParent;
  result->_vptr$CTask = (int (**)(void))&off_66CAE0;
  LOBYTE(result[4].m_pParent) = (m_bIsJumping != 0) | (2 * (m_bIsFallingToDeath != 0)) | m_pParent & 0xF8;
  result[5].m_pParent = (CTask *)CTimer::m_snTimeInMilliseconds;
  result[6]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 248);
  LOBYTE(result[6].m_pParent) = 1;
  return result;
}
// 52BE6E: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 66CAE0: using guessed type void *;

//----- (0052BEC4) --------------------------------------------------------
CTask *__fastcall CTaskComplexInAirAndLand::CreateNextSubTask(CTaskComplexInAirAndLand *this, CPed *pPed)
{
  int v4; // r0
  CTaskSimple *v5; // r4
  CTask *m_pSubTask; // r1
  CTask *m_pParent; // r0
  __int16 m_pParent_high; // r2
  float z; // s16
  char v10; // r0
  char v11; // r0
  CTaskSimple *v12; // r0
  _DWORD *v13; // r0
  CPad *PadFromPlayer; // r4
  CTask *v15; // r0
  int v16; // r0
  char v17; // r2
  CPlayerPedData *v18; // r0
  _BOOL4 v19; // r8
  int v20; // r0
  int v21; // s0
  CEntity **v22; // r6
  CMatrix *v23; // r0
  CSimpleTransform *p_m_transform; // r2
  __int64 v25; // d16
  char v26; // r2
  CPlayerPedData *m_pPlayerData; // r0
  _BOOL4 IsWearingBalaclava; // r8
  int v29; // r0
  int v30; // s0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v33; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventEditableResponse v36; // [sp+10h] [bp-40h] BYREF
  CEntity *v37; // [sp+20h] [bp-30h]
  int v38; // [sp+24h] [bp-2Ch]
  uint32 v39; // [sp+28h] [bp-28h]
  __int64 v40; // [sp+2Ch] [bp-24h]
  RwReal v41; // [sp+34h] [bp-1Ch]

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 == 207 )
  {
    v12 = (CTaskSimple *)CTask::operator new(0x10u);
    CTaskSimple::CTaskSimple(v12);
    *((_WORD *)v13 + 4) = 0;
    v13[3] = 0;
    v5 = (CTaskSimple *)v13;
    *v13 = &off_66C988;
    return v5;
  }
  if ( v4 == 241 )
  {
    m_pSubTask = this->m_pSubTask;
    m_pParent = m_pSubTask[3].m_pParent;
    if ( this->m_bIsFallingToDeath )
    {
      if ( m_pParent )
      {
        m_pParent_high = HIWORD(m_pParent[5].m_pParent);
        m_pParent[3].m_pParent = (CTask *)-1056964608;
        HIWORD(m_pParent[5].m_pParent) = m_pParent_high | 4;
        CAnimBlendAssociation::SetFinishCallback(
          (CAnimBlendAssociation *)m_pParent,
          CDefaultAnimCallback::DefaultAnimCB,
          0);
        this->m_pSubTask[3].m_pParent = 0;
      }
      z = pPed->m_vecMoveSpeed.z;
      v5 = (CTaskSimple *)CTask::operator new(0x14u);
      CTaskSimple::CTaskSimple(v5);
      v5[1]._vptr$CTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66CB14;
      v10 = (char)v5[2]._vptr$CTask;
      if ( z >= -0.1 )
      {
        v5[1].m_pParent = (CTask *)-1;
        v11 = v10 & 0xF8 | 2;
      }
      else
      {
        v5[1].m_pParent = (CTask *)(&off_18 + 2);
        v11 = v10 & 0xF8;
      }
      LOBYTE(v5[2]._vptr$CTask) = v11 | 4;
      return v5;
    }
    if ( m_pParent && LOWORD(m_pParent[5].m_pParent) == 120 )
    {
      if ( *(float *)&m_pSubTask[4]._vptr$CTask >= -0.4 )
      {
        v5 = (CTaskSimple *)CTask::operator new(0x14u);
        CTaskSimple::CTaskSimple(v5);
        v5[1]._vptr$CTask = 0;
        v26 = (char)v5[2]._vptr$CTask;
        v5[1].m_pParent = (CTask *)(&dword_78 + 3);
        v5->_vptr$CTask = (int (**)(void))&off_66CB14;
        LOBYTE(v5[2]._vptr$CTask) = v26 & 0xF8 | 4;
      }
      else
      {
        v5 = (CTaskSimple *)CTask::operator new(0x20u);
        CTaskSimple::CTaskSimple(v5);
        LOBYTE(v5[1]._vptr$CTask) = 0;
        v5[1].m_pParent = (CTask *)(&off_18 + 2);
        v5[2]._vptr$CTask = 0;
        v5[2].m_pParent = 0;
        v5[3]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 448);
        v5[3].m_pParent = (CTask *)(elf_hash_bucket + 448);
        v5->_vptr$CTask = (int (**)(void))&off_66C9F8;
      }
      CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 59, 0.0, 1.0, 0, 0, 0, 0);
      m_pPlayerData = pPed->m_pPlayerData;
      if ( !m_pPlayerData )
        return v5;
      IsWearingBalaclava = CPedClothesDesc::GetIsWearingBalaclava(m_pPlayerData->m_pClothes);
      CEventEditableResponse::CEventEditableResponse(&v36);
      v30 = 1114636288;
      if ( IsWearingBalaclava )
        v30 = 1117126656;
      v37 = pPed;
      v36._vptr$CEvent = (int (**)(void))&off_66714C;
      v39 = -1;
      v40 = 0LL;
      v41 = 0.0;
      v22 = (CEntity **)(v29 + 16);
      v38 = v30;
      CEntity::RegisterReference(pPed, (CEntity **)(v29 + 16));
      if ( v39 == -1 )
      {
        v39 = CTimer::m_snTimeInMilliseconds;
        m_pMat = v37->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v37->m_transform;
        v33 = *(_QWORD *)&p_tx->m_translate.x;
        v41 = p_tx->m_translate.z;
        v40 = v33;
      }
      goto LABEL_41;
    }
    if ( CPed::IsPlayer(pPed) )
    {
      PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
      v15 = this->m_pSubTask[3].m_pParent;
      if ( v15 && LOWORD(v15[5].m_pParent) == 9 )
      {
        v5 = (CTaskSimple *)CTask::operator new(0x14u);
        CTaskSimple::CTaskSimple(v5);
        v16 = 10;
LABEL_25:
        v17 = (char)v5[2]._vptr$CTask;
        v5[1]._vptr$CTask = 0;
        v5[1].m_pParent = (CTask *)v16;
        LOBYTE(v5[2]._vptr$CTask) = v17 & 0xF8 | 4;
        v5->_vptr$CTask = (int (**)(void))&off_66CB14;
        CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 58, 0.0, 1.0, 0, 0, 0, 0);
        v18 = pPed->m_pPlayerData;
        if ( !v18 )
          return v5;
        v19 = CPedClothesDesc::GetIsWearingBalaclava(v18->m_pClothes);
        CEventEditableResponse::CEventEditableResponse(&v36);
        v21 = 1113325568;
        if ( v19 )
          v21 = 1116471296;
        v37 = pPed;
        v36._vptr$CEvent = (int (**)(void))&off_66714C;
        v39 = -1;
        v40 = 0LL;
        v41 = 0.0;
        v22 = (CEntity **)(v20 + 16);
        v38 = v21;
        CEntity::RegisterReference(pPed, (CEntity **)(v20 + 16));
        if ( v39 == -1 )
        {
          v39 = CTimer::m_snTimeInMilliseconds;
          v23 = v37->m_pMat;
          p_m_transform = (CSimpleTransform *)&v23->tx;
          if ( !v23 )
            p_m_transform = &v37->m_transform;
          v25 = *(_QWORD *)&p_m_transform->m_translate.x;
          v41 = p_m_transform->m_translate.z;
          v40 = v25;
        }
LABEL_41:
        EventGlobalGroup = GetEventGlobalGroup();
        CEventGroup::Add(EventGlobalGroup, (CEvent *)&v36, 0);
        v36._vptr$CEvent = (int (**)(void))&off_66714C;
        if ( v37 )
          CEntity::CleanUpOldReference(v37, v22);
        CEvent::~CEvent((CEvent *)&v36);
        return v5;
      }
      if ( PadFromPlayer
        && pPed->m_pPlayerData->m_moveBlendRatio > 1.5
        && (CPad::GetPedWalkLeftRight(PadFromPlayer) || CPad::GetPedWalkUpDown(PadFromPlayer)) )
      {
        v5 = (CTaskSimple *)CTask::operator new(0x14u);
        CTaskSimple::CTaskSimple(v5);
        v16 = 119;
        goto LABEL_25;
      }
    }
    v5 = (CTaskSimple *)CTask::operator new(0x14u);
    CTaskSimple::CTaskSimple(v5);
    v16 = 122;
    goto LABEL_25;
  }
  return v5;
}
// 52BF5A: variable 'v13' is possibly undefined
// 52C0B4: variable 'v20' is possibly undefined
// 52C184: variable 'v29' is possibly undefined
// 18: using guessed type int (*off_18)();
// 78: using guessed type int dword_78;
// FC: using guessed type int elf_hash_bucket[16411];
// 66714C: using guessed type void *off_66714C;
// 66C988: using guessed type void *off_66C988;
// 66C9F8: using guessed type void *off_66C9F8;
// 66CB14: using guessed type void *;

//----- (0052C23C) --------------------------------------------------------
CTask *__fastcall CTaskComplexInAirAndLand::ControlSubTask(CTaskComplexInAirAndLand *this, CPed *pPed)
{
  char *m_pSubTask; // r4
  int v5; // r0
  bool v6; // zf
  CTask *v7; // r6
  CMatrix *m_pMat; // r1
  float v9; // s16
  CSimpleTransform *p_tx; // r2
  float z; // s18
  float v12; // s20
  char v13; // r9
  int (**v14)(void); // r8
  CEntity **v15; // r5
  char v16; // r11
  CTask *v17; // r6
  CTask v18; // d16
  CTask *m_pParent; // [sp+4h] [bp-3Ch]

  m_pSubTask = (char *)this->m_pSubTask;
  if ( m_pSubTask && !this->m_bIsFallingToDeath )
  {
    v5 = (*(int (__fastcall **)(CTask *))(*(_DWORD *)m_pSubTask + 20))(this->m_pSubTask);
    v6 = v5 == 241;
    if ( v5 == 241 )
      v6 = this->m_bDisableClimb == 0;
    if ( v6 )
    {
      v7 = this->m_pSubTask;
      if ( v7[7]._vptr$CTask )
      {
        m_pMat = pPed->m_pMat;
        v9 = *(float *)&v7[2]._vptr$CTask;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        z = p_tx->m_translate.z;
        v12 = CTaskSimpleClimb::ms_fMinForStretchGrab;
        m_pSubTask = (char *)CTask::operator new(0x30u);
        v13 = (char)v7[3]._vptr$CTask;
        m_pParent = v7[2].m_pParent;
        v14 = v7[7]._vptr$CTask;
        CTaskSimple::CTaskSimple((CTaskSimple *)m_pSubTask);
        *(_DWORD *)m_pSubTask = &off_66CBF4;
        *((_WORD *)m_pSubTask + 4) = 0;
        m_pSubTask[10] = 0;
        m_pSubTask[12] = 0;
        *((_DWORD *)m_pSubTask + 11) = 0;
        *((_DWORD *)m_pSubTask + 9) = v14;
        v15 = (CEntity **)(m_pSubTask + 36);
        CWidgetHelpText::ConditionSatisfied(0x400u);
        v16 = 1;
        v17 = v7 + 1;
        if ( (float)(v9 - z) < (float)(v12 + -0.3) )
          v16 = 2;
        if ( *v15 )
          CEntity::RegisterReference(*v15, (CEntity **)m_pSubTask + 9);
        v18 = *v17;
        *((_DWORD *)m_pSubTask + 8) = v17[1]._vptr$CTask;
        *((CTask *)m_pSubTask + 3) = v18;
        m_pSubTask[15] = v13;
        *((_DWORD *)m_pSubTask + 5) = m_pParent;
        m_pSubTask[13] = v16;
        m_pSubTask[11] = 0;
        m_pSubTask[14] = 0;
        m_pSubTask[16] = -1;
        *((_WORD *)m_pSubTask + 20) = 0;
      }
    }
  }
  return (CTask *)m_pSubTask;
}
// 66CBF4: using guessed type void *off_66CBF4;

//----- (0052C350) --------------------------------------------------------
void __fastcall CTaskSimpleInAir::CTaskSimpleInAir(
        CTaskSimpleInAir *this,
        bool bJump,
        bool bFallingToDeath,
        bool bTumbleWhilstFalling)
{
  int v7; // r0
  uint32 v8; // r1

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v7 + 50) = 0;
  *(_DWORD *)(v7 + 46) = 0;
  *(_DWORD *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_DWORD *)(v7 + 56) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_BYTE *)(v7 + 36) = bJump | (2 * bFallingToDeath) | (4 * bTumbleWhilstFalling) | *(_BYTE *)(v7 + 36) & 0xF8;
  *(_DWORD *)v7 = &off_66CAE0;
  v8 = CTimer::m_snTimeInMilliseconds;
  *(_BYTE *)(v7 + 52) = 1;
  *(_DWORD *)(v7 + 44) = v8;
  *(_DWORD *)(v7 + 48) = 500;
}
// 52C36A: variable 'v7' is possibly undefined
// 66CAE0: using guessed type void *off_66CAE0;

//----- (0052C3BC) --------------------------------------------------------
void __fastcall CTaskSimpleInAir::~CTaskSimpleInAir(CTaskSimpleInAir *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CEntity *m_pClimbEnt; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CAE0;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pClimbEnt = this->m_pClimbEnt;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, &this->m_pClimbEnt);
  sub_1A01F4(this);
}
// 66CAE0: using guessed type void *off_66CAE0;

//----- (0052C3FC) --------------------------------------------------------
void __fastcall CTaskSimpleInAir::~CTaskSimpleInAir(CTaskSimpleInAir *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CEntity *m_pClimbEnt; // r0
  void *v4; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CAE0;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pClimbEnt = this->m_pClimbEnt;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, &this->m_pClimbEnt);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 52C434: variable 'v4' is possibly undefined
// 66CAE0: using guessed type void *off_66CAE0;

//----- (0052C440) --------------------------------------------------------
bool __fastcall CTaskSimpleInAir::MakeAbortable(
        CTaskSimpleInAir *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2
    && (iPriority != 1
     || (*((_BYTE *)&pPed->m_nPedFlags + 6) & 8) == 0
     && (!pEvent
      || ((*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 32
       || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent) != 71)
      && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 93)) )
  {
    return 0;
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    m_pAnim->m_fBlendDelta = -8.0;
    this->m_pAnim->m_bitsFlag |= 4u;
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  *(_DWORD *)&pPed->m_nPedFlags &= ~0x200u;
  return 1;
}

//----- (0052C4CC) --------------------------------------------------------
bool __fastcall CTaskSimpleInAir::ProcessPed(CTaskSimpleInAir *this, CPed *pPed)
{
  float *p_tx; // r8
  RwReal v5; // r1
  RwReal v6; // r2
  float v7; // r8
  unsigned int v8; // r0
  int m_iStartTime; // r1
  UInt16 v10; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r1
  bool v13; // zf
  char *v14; // r4
  CAnimBlendAssociation *v15; // r0
  RwObject_0 **p_m_pRwObject; // r4
  CAnimBlendAssociation *v17; // r0
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v19; // r0
  RwReal z; // s0
  int v21; // r1
  int v22; // r0
  char v23; // r1
  CTask *m_pParent; // r0
  bool v25; // zf
  CMatrix *m_pMat; // r0
  float xy; // s0
  float yy; // s2
  float zy; // s4
  float v30; // s6
  bool v31; // cc
  float v32; // s6
  CPedFlags *p_m_nPedFlags; // r9
  _BOOL4 v34; // r0
  float v35; // s0
  int m_iNumStuckFrames; // r2
  bool v37; // zf
  CAnimBlendAssociation *v38; // r0
  bool result; // r0
  CAnimBlendAssociation *v40; // r0
  bool v41; // zf
  CAnimBlendAssociation *v42; // r0
  _BOOL4 IsPlayer; // r1
  CTask *v44; // r0
  CTask *v45; // r9
  CEntity *v46; // r0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-54h] BYREF
  CColPoint colPoint; // [sp+20h] [bp-50h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-24h] BYREF
  CVector v50; // 0:r1.12
  CVector v51; // 0:r1.12

  p_tx = &pPed->m_pMat->tx;
  v5 = *p_tx;
  v6 = p_tx[1];
  v7 = p_tx[2];
  vecStart.x = v5;
  vecStart.y = v6;
  vecStart.z = v7;
  if ( this->m_FallScreamTimer.m_bIsActive )
  {
    if ( this->m_FallScreamTimer.m_bIsStopped )
    {
      v8 = CTimer::m_snTimeInMilliseconds;
      this->m_FallScreamTimer.m_bIsStopped = 0;
      this->m_FallScreamTimer.m_iStartTime = v8;
      m_iStartTime = v8;
    }
    else
    {
      m_iStartTime = this->m_FallScreamTimer.m_iStartTime;
      v8 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_FallScreamTimer.m_iDuration <= v8
      && pPed->m_nPedState != PED_ABSEIL_FROM_HELI
      && (float)(pPed->m_vecMoveSpeed.z * 50.0) <= -20.0 )
    {
      if ( CPed::IsPlayer(pPed) )
        v10 = 358;
      else
        v10 = 346;
      CPed::Say(pPed, v10, 0, 1.0, 0, 0, 0);
      this->m_FallScreamTimer.m_bIsActive = 0;
    }
  }
  m_pAnim = this->m_pAnim;
  if ( !m_pAnim )
  {
    *(_DWORD *)&pPed->m_nPedFlags |= 0x200u;
    if ( (*((_BYTE *)this + 36) & 1) != 0 )
    {
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x76u);
      this->m_pAnim = Association;
      if ( !Association
        && (Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x80u),
            (this->m_pAnim = Association) == 0)
        || Association->m_fBlendAmount < 1.0 && Association->m_fBlendDelta <= 0.0 )
      {
        CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_JUMP_GLIDE, 4.0);
      }
    }
    else if ( (*((_BYTE *)this + 36) & 2) != 0 )
    {
      if ( pPed->m_vecMoveSpeed.z <= 0.0 )
      {
        v19 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_FALL_GLIDE, 4.0);
        this->m_pAnim = v19;
        CAnimBlendAssociation::SetDeleteCallback(v19, CTaskSimpleInAir::DeleteInAirAnimCB, this);
        this->m_pAnim->m_fBlendDelta = 0.5;
        this->m_pAnim->m_fBlendAmount = 1.0;
      }
    }
    else
    {
      v15 = this->m_pAnim;
      if ( !v15 )
      {
        p_m_pRwObject = &pPed->m_pRwObject;
        v15 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x80u);
        this->m_pAnim = v15;
        if ( !v15 )
        {
LABEL_28:
          v17 = CAnimManager::BlendAnimation((RpClump_0 *)*p_m_pRwObject, ANIM_STD_PED, ANIM_STD_FALL_GLIDE, 4.0);
          this->m_pAnim = v17;
          if ( !v17 )
            goto LABEL_39;
          goto LABEL_38;
        }
      }
      if ( v15->m_fBlendAmount < 1.0 && v15->m_fBlendDelta <= 0.0 )
      {
        p_m_pRwObject = &pPed->m_pRwObject;
        goto LABEL_28;
      }
    }
    v17 = this->m_pAnim;
    if ( !v17 )
      goto LABEL_39;
LABEL_38:
    CAnimBlendAssociation::SetDeleteCallback(v17, CTaskSimpleInAir::DeleteInAirAnimCB, this);
    m_pAnim = this->m_pAnim;
    if ( !m_pAnim )
      goto LABEL_39;
  }
  m_animId = (unsigned __int16)m_pAnim->m_animId;
  v13 = m_animId == 128;
  if ( m_animId == 128 )
    v13 = *(_BYTE *)&pPed->m_nPedFlags << 31 == 0;
  if ( v13
    && m_pAnim->m_fCurrentTime < m_pAnim->m_pAnimBlendHierarchy->m_fTotalTime
    && (m_pAnim->m_fBlendAmount >= 1.0 || m_pAnim->m_fBlendDelta > 0.0) )
  {
    v50.x = 0.0;
    v50.y = 0.0;
    v50.z = (float)(pPed->m_fMass * 0.0028) * CTimer::ms_fTimeStep;
    CPhysical::ApplyMoveForce(pPed, v50);
    v14 = (char *)this + 36;
    goto LABEL_83;
  }
LABEL_39:
  z = pPed->m_vecMoveSpeed.z;
  if ( z > 0.0 )
  {
    if ( pPed->m_vecMoveSpeed.x != 0.0 )
      goto LABEL_48;
    v21 = 0;
    v22 = 0;
    if ( z == 0.0 )
      v21 = 1;
    if ( pPed->m_vecMoveSpeed.y == 0.0 )
      v22 = 1;
    if ( (v21 & v22) == 0 )
      goto LABEL_48;
  }
  v14 = (char *)this + 36;
  v23 = *((_BYTE *)this + 36);
  if ( (v23 & 2) == 0 && (pPed->m_nPedState & 0xFFFFFFFE) == 54 )
  {
LABEL_48:
    v14 = (char *)this + 36;
    if ( (*((_BYTE *)this + 36) & 2) == 0 )
    {
      m_pParent = this->m_pParent;
      v25 = m_pParent == 0;
      if ( m_pParent )
      {
        m_pParent = m_pParent->m_pParent;
        v25 = m_pParent == 0;
      }
      if ( !v25 && (*((int (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent) == 211 )
      {
        m_pMat = pPed->m_pMat;
        xy = m_pMat->xy;
        yy = m_pMat->yy;
        zy = m_pMat->zy;
        v30 = (float)((float)(pPed->m_vecMoveSpeed.x * xy) + (float)(pPed->m_vecMoveSpeed.y * yy))
            + (float)(pPed->m_vecMoveSpeed.z * zy);
        v31 = v30 < 0.05;
        if ( v30 < 0.05 )
          v31 = this->m_iNumStuckFrames < 1000;
        if ( v31 )
        {
          v32 = (float)(0.05 - v30) * pPed->m_fMass;
          v51.x = xy * v32;
          v51.y = yy * v32;
          v51.z = zy * v32;
          CPhysical::ApplyMoveForce(pPed, v51);
          this->m_iNumStuckFrames += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        }
      }
    }
    goto LABEL_83;
  }
  p_m_nPedFlags = &pPed->m_nPedFlags;
  if ( z < this->m_fFallVel )
    this->m_fFallVel = z;
  v34 = 1;
  if ( !(*(_BYTE *)&pPed->m_nPedFlags << 31) )
  {
    v34 = CWorld::ProcessVerticalLine(&vecStart, v7 + -4.0, &colPoint, &refEntityPtr, 1, 1, 0, 1, 0, 0, 0);
    v23 = *v14;
  }
  if ( (v23 & 2) != 0 )
  {
    v35 = pPed->m_vecMoveSpeed.z;
    if ( v35 > 0.0 || v35 <= CTaskSimpleInAir::ms_fMaxStuckVelocity )
    {
      this->m_iNumStuckFrames = 0;
    }
    else
    {
      m_iNumStuckFrames = this->m_iNumStuckFrames;
      this->m_iNumStuckFrames = m_iNumStuckFrames + 1;
      if ( m_iNumStuckFrames >= CTaskSimpleInAir::ms_iNumStuckFallingFramesBeforeQuitting )
      {
        *(_DWORD *)p_m_nPedFlags |= 1u;
        goto LABEL_69;
      }
    }
  }
  if ( !v34 )
  {
    if ( pPed->m_nPedState != PED_ABSEIL_FROM_HELI && pPed->m_vecMoveSpeed.z < -0.1 )
    {
      v40 = this->m_pAnim;
      v41 = v40 == 0;
      if ( v40 )
        v41 = v40->m_animId == 120;
      if ( !v41 )
      {
        CAnimBlendAssociation::SetDeleteCallback(v40, CDefaultAnimCallback::DefaultAnimCB, 0);
        v42 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_FALL, 4.0);
        this->m_pAnim = v42;
        CAnimBlendAssociation::SetDeleteCallback(v42, CTaskSimpleInAir::DeleteInAirAnimCB, this);
      }
    }
    goto LABEL_83;
  }
LABEL_69:
  if ( (float)(pPed->m_pMat->tz - colPoint.m_vecPosition.z) < 1.3 )
    goto LABEL_73;
  v37 = *(_BYTE *)p_m_nPedFlags << 31 == 0;
  if ( !(*(_BYTE *)p_m_nPedFlags << 31) )
    v37 = pPed->m_pAttachToEntity == 0;
  if ( !v37 )
  {
LABEL_73:
    v38 = this->m_pAnim;
    if ( v38 && (*v14 & 2) != 0 )
    {
      v38->m_fBlendDelta = -1000.0;
      this->m_pAnim->m_bitsFlag |= 4u;
      CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pAnim = 0;
    }
    *(_DWORD *)p_m_nPedFlags &= ~0x200u;
    return 1;
  }
LABEL_83:
  if ( !((unsigned __int8)*v14 << 31) || this->m_pClimbEnt || (pPed->m_nPedState & 0xFFFFFFFE) == 54 )
    return 0;
  IsPlayer = CPed::IsPlayer(pPed);
  result = 0;
  if ( IsPlayer && CGame::currArea == AREA_MAIN_MAP )
  {
    if ( pPed->m_vecMoveSpeed.z <= -0.2
      || sqrtf(
           (float)(pPed->m_vecMoveSpeed.x * pPed->m_vecMoveSpeed.x)
         + (float)(pPed->m_vecMoveSpeed.y * pPed->m_vecMoveSpeed.y)) <= 0.05 )
    {
      return 0;
    }
    v44 = this->m_pParent;
    if ( v44 && (*((int (__fastcall **)(CTask *))v44->_vptr$CTask + 5))(v44) == 240 && (v45 = this->m_pParent) != 0 )
    {
      if ( BYTE2(v45[1].m_pParent) )
        return 0;
    }
    else
    {
      v45 = 0;
    }
    v46 = CTaskSimpleClimb::TestForClimb(pPed, &this->m_vecEdge, &this->m_fEdgeHeading, &this->m_nEdgeSurfaceType, 0);
    this->m_pClimbEnt = v46;
    if ( v46 )
    {
      CEntity::RegisterReference(v46, &this->m_pClimbEnt);
      return 0;
    }
    result = 0;
    if ( v45 && this->m_fEdgeHeading < -1000.0 )
    {
      BYTE2(v45[1].m_pParent) = 1;
      return 0;
    }
  }
  return result;
}

//----- (0052CAAC) --------------------------------------------------------
void __fastcall CTaskSimpleInAir::DeleteInAirAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  bool v2; // zf

  v2 = pAnim == 0;
  if ( pAnim )
    v2 = pData == 0;
  if ( !v2 && *((CAnimBlendAssociation **)pData + 7) == pAnim )
    *((_DWORD *)pData + 7) = 0;
}

//----- (0052CAC0) --------------------------------------------------------
CEntity *__fastcall CTaskSimpleClimb::TestForClimb(
        CPed *pPed,
        CVector *vecTargetPos,
        float *fGrabHeading,
        uint8 *nSurfaceType,
        int bLaunch)
{
  int v6; // r5
  CEntity *v9; // r0
  CEntity *v10; // r6
  __int64 v11; // d16
  float v12; // s16
  const CMatrix *m_pMat; // r1
  CMatrix *v14; // r0
  float m_heading; // s0
  float v16; // r4
  float v17; // r5
  float v18; // s16
  float v19; // r0
  CVector v21; // [sp+10h] [bp-50h] BYREF
  CVector v; // [sp+20h] [bp-40h] BYREF
  uint8 v23; // [sp+2Fh] [bp-31h] BYREF
  CVector v24; // [sp+30h] [bp-30h] BYREF
  float v25[9]; // [sp+3Ch] [bp-24h] BYREF

  v6 = 0;
  v9 = CTaskSimpleClimb::ScanToGrab(pPed, vecTargetPos, fGrabHeading, nSurfaceType, bLaunch, 0, 0, 0);
  v10 = v9;
  if ( v9 )
  {
    v11 = *(_QWORD *)&vecTargetPos->x;
    v.z = vecTargetPos->z;
    *(_QWORD *)&v.x = v11;
    v12 = *fGrabHeading;
    if ( (unsigned __int8)((*(_BYTE *)&v9->m_info & 7) - 2) <= 2u )
    {
      m_pMat = v9->m_pMat;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(v9);
        CSimpleTransform::UpdateMatrix(&v10->m_transform, v10->m_pMat);
        m_pMat = v10->m_pMat;
      }
      operator*(&v21, m_pMat, &v);
      v = v21;
      v14 = v10->m_pMat;
      if ( v14 )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(v14->xy) ^ 0x80000000), v14->yy);
      else
        m_heading = v10->m_transform.m_heading;
      v12 = v12 + m_heading;
    }
    v16 = v12;
    v17 = sinf(v12);
    v18 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
    v19 = cosf(v16);
    v.y = v.y + (float)(v19 * v18);
    v.x = v.x - (float)(v17 * v18);
    v.z = CTaskSimpleClimb::ms_fAtEdgeOffsetVert + v.z;
    if ( CTaskSimpleClimb::ScanToGrab(pPed, &v24, v25, &v23, 0, 1u, 0, &v) )
    {
      v6 = 0;
      *fGrabHeading = -9999.9;
    }
    else
    {
      return v10;
    }
  }
  return (CEntity *)v6;
}
// 52CAC0: using guessed type float var_24[9];

//----- (0052CBF8) --------------------------------------------------------
void __fastcall CTaskSimpleLand::CTaskSimpleLand(CTaskSimpleLand *this, const AnimationId anim)
{
  int v3; // r0
  char v4; // r2
  char v5; // r3

  CTaskSimple::CTaskSimple(this);
  v4 = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = anim;
  v5 = *(_BYTE *)(v3 + 16);
  *(_DWORD *)v3 = &off_66CB14;
  if ( anim == -1 )
    v4 = 1;
  *(_BYTE *)(v3 + 16) = v5 & 0xF8 | (2 * v4) | 4;
}
// 52CC06: variable 'v3' is possibly undefined
// 66CB14: using guessed type void *off_66CB14;

//----- (0052CC30) --------------------------------------------------------
void __fastcall CTaskSimpleLand::~CTaskSimpleLand(CTaskSimpleLand *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CB14;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66CB14: using guessed type void *off_66CB14;

//----- (0052CC64) --------------------------------------------------------
void __fastcall CTaskSimpleLand::~CTaskSimpleLand(CTaskSimpleLand *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CB14;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 52CC8E: variable 'v3' is possibly undefined
// 66CB14: using guessed type void *off_66CB14;

//----- (0052CC9C) --------------------------------------------------------
bool __fastcall CTaskSimpleLand::MakeAbortable(
        CTaskSimpleLand *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    m_pAnim->m_fBlendDelta = -1000.0;
    this->m_pAnim->m_bitsFlag |= 4u;
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  *(_DWORD *)&pPed->m_nPedFlags &= ~0x400u;
  return 1;
}

//----- (0052CD04) --------------------------------------------------------
bool __fastcall CTaskSimpleLand::ProcessPed(CTaskSimpleLand *this, CPed *pPed)
{
  char v4; // r0
  CAnimBlendAssociation *v5; // r0
  CMatrix *m_pMat; // r0
  float m_fCurrentHeading; // s0
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v9; // r0
  CAnimBlendAssociation *v10; // r0
  CPad *PadFromPlayer; // r0
  CAnimBlendAssociation *m_pAnim; // r5
  float m_fSpeed; // s16
  char v15; // r0

  v4 = *((_BYTE *)this + 16);
  if ( (v4 & 1) != 0 )
  {
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x400u;
    if ( (*((_BYTE *)this + 16) & 2) == 0 )
    {
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0);
      this->m_pAnim = Association;
      if ( Association )
        CAnimBlendAssociation::SetCurrentTime(Association, 0.0);
      v9 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 1u);
      this->m_pAnim = v9;
      if ( v9 )
        CAnimBlendAssociation::SetCurrentTime(v9, 0.0);
      v10 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 2u);
      this->m_pAnim = v10;
      if ( v10 )
        CAnimBlendAssociation::SetCurrentTime(v10, 0.0);
      this->m_pAnim = 0;
    }
    return 1;
  }
  else
  {
    if ( (v4 & 2) == 0 && !this->m_pAnim )
    {
      v5 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, this->m_animID, 100.0);
      this->m_pAnim = v5;
      CAnimBlendAssociation::SetFinishCallback(v5, CTaskSimpleLand::FinishAnimLandCB, this);
      v4 = *((_BYTE *)this + 16);
    }
    if ( (v4 & 4) != 0 )
    {
      m_pMat = pPed->m_pMat;
      if ( m_pMat->zz != 1.0
        || pPed->m_vecTurnSpeed.x != 0.0
        || pPed->m_vecTurnSpeed.y != 0.0
        || pPed->m_vecTurnSpeed.z != 0.0 )
      {
        m_fCurrentHeading = pPed->m_fCurrentHeading;
        pPed->m_vecTurnSpeed.x = 0.0;
        pPed->m_vecTurnSpeed.y = 0.0;
        pPed->m_vecTurnSpeed.z = 0.0;
        if ( m_pMat )
          CMatrix::SetRotateZOnly(m_pMat, m_fCurrentHeading);
        else
          pPed->m_transform.m_heading = m_fCurrentHeading;
      }
      *(_DWORD *)&pPed->m_nPedFlags |= 0x400u;
      if ( CPed::IsPlayer(pPed) )
      {
        PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
        if ( pPed->m_eMoveState == PEDMOVE_SPRINT && CPad::GetSprint(PadFromPlayer, 0) )
          this->m_pAnim->m_fSpeed = 2.0;
        if ( this->m_animID != ANIM_STD_IDLE_TIRED )
        {
          m_pAnim = this->m_pAnim;
          m_fSpeed = m_pAnim->m_fSpeed;
          m_pAnim->m_fSpeed = m_fSpeed * CStats::GetFatAndMuscleModifier(STAT_MODIFIER_JUMP_SPEED);
        }
      }
      v15 = *((_BYTE *)this + 16);
      *((_BYTE *)this + 16) = v15 & 0xFB;
      if ( (v15 & 2) != 0 )
        *((_BYTE *)this + 16) = v15 & 0xFA | 1;
    }
    return 0;
  }
}

//----- (0052CE7C) --------------------------------------------------------
void __fastcall CTaskSimpleLand::FinishAnimLandCB(CAnimBlendAssociation *pAnim, void *pData)
{
  char v2; // r2
  int m_animId; // r1
  bool v4; // zf

  if ( pData )
  {
    v2 = *((_BYTE *)pData + 16);
    *((_DWORD *)pData + 2) = 0;
    *((_BYTE *)pData + 16) = v2 | 1;
  }
  if ( pAnim )
  {
    m_animId = pAnim->m_animId;
    v4 = m_animId == 119;
    if ( m_animId != 119 )
      v4 = m_animId == 10;
    if ( v4 )
      pAnim->m_fBlendDelta = -100.0;
  }
}

//----- (0052CEA8) --------------------------------------------------------
bool8 __fastcall CTaskSimpleLand::RightFootLanded(CTaskSimpleLand *this)
{
  CAnimBlendAssociation *m_pAnim; // r1
  bool8 result; // r0
  float m_fCurrentTime; // s2

  m_pAnim = this->m_pAnim;
  if ( !m_pAnim )
    return 0;
  result = 0;
  m_fCurrentTime = m_pAnim->m_fCurrentTime;
  if ( m_fCurrentTime >= 0.1 && (float)(m_fCurrentTime - m_pAnim->m_fTimeStep) < 0.1 )
    return 1;
  return result;
}

//----- (0052CEE4) --------------------------------------------------------
bool8 __fastcall CTaskSimpleLand::LeftFootLanded(CTaskSimpleLand *this)
{
  CAnimBlendAssociation *m_pAnim; // r1
  bool8 result; // r0
  float m_fCurrentTime; // s2

  m_pAnim = this->m_pAnim;
  if ( !m_pAnim )
    return 0;
  result = 0;
  m_fCurrentTime = m_pAnim->m_fCurrentTime;
  if ( m_fCurrentTime >= 0.2 && (float)(m_fCurrentTime - m_pAnim->m_fTimeStep) < 0.2 )
    return 1;
  return result;
}

//----- (0052CF20) --------------------------------------------------------
void __fastcall CTaskComplexFallToDeath::CTaskComplexFallToDeath(
        CTaskComplexFallToDeath *this,
        const int iNudgeDir,
        const CVector *vNudgeVec,
        bool over_railing,
        bool tumble)
{
  char v7; // r6
  int v8; // r0
  __int64 v9; // d16
  char v10; // r1

  v7 = iNudgeDir;
  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)v8 = &off_66CB48;
  v9 = *(_QWORD *)&vNudgeVec->x;
  v10 = *(_BYTE *)(v8 + 33) & 0xE0 | (16 * tumble) | (8 * over_railing);
  *(RwReal *)(v8 + 20) = vNudgeVec->z;
  *(_DWORD *)(v8 + 24) = -1;
  *(_DWORD *)(v8 + 28) = -1;
  *(_BYTE *)(v8 + 32) = v7;
  *(_BYTE *)(v8 + 33) = v10;
  *(_QWORD *)(v8 + 12) = v9;
}
// 52CF42: variable 'v8' is possibly undefined
// 66CB48: using guessed type void *;

//----- (0052CF78) --------------------------------------------------------
void __fastcall CTaskComplexFallToDeath::~CTaskComplexFallToDeath(CTaskComplexFallToDeath *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52CF84: variable 'v1' is possibly undefined

//----- (0052CF88) --------------------------------------------------------
bool __fastcall CTaskComplexFallToDeath::MakeAbortable(
        CTaskComplexFallToDeath *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  uint32 m_KnockedBackAnimID; // r1
  CAnimBlendAssociation *Association; // r0
  uint32 m_DeathAnimID; // r1
  CAnimBlendAssociation *v10; // r0

  if ( iPriority != 2 )
    return 0;
  m_KnockedBackAnimID = this->m_KnockedBackAnimID;
  if ( m_KnockedBackAnimID != -1 )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_KnockedBackAnimID);
    if ( Association )
      Association->m_fBlendDelta = -1000.0;
  }
  m_DeathAnimID = this->m_DeathAnimID;
  if ( m_DeathAnimID != -1 )
  {
    v10 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_DeathAnimID);
    if ( v10 )
      v10->m_fBlendDelta = -1000.0;
  }
  return 1;
}

//----- (0052CFCC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallToDeath::CreateFirstSubTask(CTaskComplexFallToDeath *this, CPed *pPed)
{
  RwReal *v4; // r0
  float v5; // s0
  float v6; // s2
  int v7; // lr
  int v8; // r6
  int v9; // r8
  unsigned int m_NudgeDir; // r0
  AnimationId m_KnockedBackAnimID; // r2
  CTaskSimple *v12; // r0
  CTask *result; // r0
  char m_pParent; // r3
  CVector v15; // 0:r1.12

  v4 = &CTaskComplexFallToDeath::ms_NoRailingVerticalForce;
  v5 = this->m_NudgeVec.x * CTaskComplexFallToDeath::ms_LateralForceMagnitude;
  v6 = this->m_NudgeVec.y * CTaskComplexFallToDeath::ms_LateralForceMagnitude;
  v7 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v8 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v9 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  if ( (*((_BYTE *)this + 33) & 8) != 0 )
    v4 = &CTaskComplexFallToDeath::ms_OverRailingVerticalForce;
  v15.z = *v4;
  *(_DWORD *)&pPed->m_nPedFlags &= ~1u;
  v15.x = v5;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v7;
  v15.y = v6;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v8;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v9;
  CPhysical::ApplyMoveForce(pPed, v15);
  m_NudgeDir = (char)this->m_NudgeDir;
  if ( m_NudgeDir > 3 )
  {
    m_KnockedBackAnimID = this->m_KnockedBackAnimID;
    if ( (unsigned int)m_KnockedBackAnimID <= ANIM_STD_IDLE )
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, m_KnockedBackAnimID, 1000.0);
  }
  else
  {
    this->m_KnockedBackAnimID = dword_52D0C4[m_NudgeDir];
  }
  v12 = (CTaskSimple *)CTask::operator new(0x3Cu);
  CTaskSimple::CTaskSimple(v12);
  *(int (***)(void))((char *)&result[6]._vptr$CTask + 2) = 0;
  *(CTask **)((char *)&result[5].m_pParent + 2) = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  result[7]._vptr$CTask = 0;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  m_pParent = (char)result[4].m_pParent;
  result->_vptr$CTask = (int (**)(void))&off_66CAE0;
  LOBYTE(result[4].m_pParent) = m_pParent & 0xF8 | 2;
  result[5].m_pParent = (CTask *)CTimer::m_snTimeInMilliseconds;
  result[6]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 248);
  LOBYTE(result[6].m_pParent) = 1;
  return result;
}
// 52D074: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 52D0C4: using guessed type int dword_52D0C4[4];
// 66CAE0: using guessed type void *off_66CAE0;

//----- (0052D0DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallToDeath::CreateNextSubTask(CTaskComplexFallToDeath *this, CPed *pPed)
{
  int v4; // r0
  float z; // s16
  CTaskSimple *v6; // r0
  CTask *result; // r0
  char v8; // r1
  char v9; // r1
  CEntity *m_pEntityStandingOn; // r1
  bool v11; // zf
  CTaskSimple *v12; // r0
  char m_pParent; // r5
  uint32 m_KnockedBackAnimID; // r1
  CAnimBlendAssociation *Association; // r0
  CTaskSimpleDead *v16; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 242 )
  {
    if ( (*((_BYTE *)this + 33) & 1) != 0 || fabsf(pPed->m_vecMoveSpeed.z) < 0.01 )
      goto LABEL_13;
    m_pEntityStandingOn = pPed->m_pEntityStandingOn;
    v11 = m_pEntityStandingOn == 0;
    if ( m_pEntityStandingOn )
      v11 = (*(_BYTE *)&m_pEntityStandingOn->m_info & 7) == 1;
    if ( v11 )
    {
      *((_BYTE *)this + 33) |= 1u;
      v12 = (CTaskSimple *)CTask::operator new(0x3Cu);
      CTaskSimple::CTaskSimple(v12);
      *(int (***)(void))((char *)&result[6]._vptr$CTask + 2) = 0;
      *(CTask **)((char *)&result[5].m_pParent + 2) = 0;
      result[5]._vptr$CTask = 0;
      result[5].m_pParent = 0;
      result[7]._vptr$CTask = 0;
      m_pParent = (char)result[4].m_pParent;
      result->_vptr$CTask = (int (**)(void))&off_66CAE0;
      result[3].m_pParent = 0;
      result[4]._vptr$CTask = 0;
      LOBYTE(result[4].m_pParent) = m_pParent & 0xF8 | 2;
      result[5].m_pParent = (CTask *)CTimer::m_snTimeInMilliseconds;
      result[6]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 248);
      LOBYTE(result[6].m_pParent) = 1;
    }
    else
    {
LABEL_13:
      if ( (*((_BYTE *)this + 33) & 4) == 0 )
      {
        m_KnockedBackAnimID = this->m_KnockedBackAnimID;
        if ( m_KnockedBackAnimID != -1 )
        {
          Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_KnockedBackAnimID);
          if ( Association )
            Association->m_fBlendDelta = -1000.0;
        }
        this->m_DeathAnimID = ANIM_STD_HIGHIMPACT_FRONT;
        CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_HIGHIMPACT_FRONT, 8.0);
      }
      CPedIntelligence::ClearTasks(pPed->m_pPedIntelligence, 0, 1);
      v16 = (CTaskSimpleDead *)CTask::operator new(0x10u);
      CTaskSimpleDead::CTaskSimpleDead(v16, CTimer::m_snTimeInMilliseconds, 0);
    }
  }
  else if ( v4 == 241 )
  {
    z = pPed->m_vecMoveSpeed.z;
    v6 = (CTaskSimple *)CTask::operator new(0x14u);
    CTaskSimple::CTaskSimple(v6);
    result[1]._vptr$CTask = 0;
    result->_vptr$CTask = (int (**)(void))&off_66CB14;
    v8 = (char)result[2]._vptr$CTask;
    if ( fabsf(z) >= 0.1 )
    {
      result[1].m_pParent = (CTask *)&off_18;
      LOBYTE(result[2]._vptr$CTask) = v8 & 0xF8 | 4;
      v9 = *((_BYTE *)this + 33) | 4;
    }
    else
    {
      result[1].m_pParent = (CTask *)-1;
      LOBYTE(result[2]._vptr$CTask) = v8 & 0xF8 | 6;
      v9 = *((_BYTE *)this + 33) & 0xFB;
    }
    *((_BYTE *)this + 33) = v9;
  }
  else
  {
    return 0;
  }
  return result;
}
// 52D114: variable 'result' is possibly undefined
// 18: using guessed type int (*off_18)();
// FC: using guessed type int elf_hash_bucket[16411];
// 66CAE0: using guessed type void *off_66CAE0;
// 66CB14: using guessed type void *off_66CB14;

//----- (0052D26C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallToDeath::ControlSubTask(CTaskComplexFallToDeath *this, CPed *pPed)
{
  char v4; // r0
  CTaskSimple *m_pSubTask; // r4
  uint32 m_KnockedBackAnimID; // r1
  CAnimBlendAssociation *Association; // r0
  uint32 m_DeathAnimID; // r1
  CAnimBlendAssociation *v9; // r0
  char v10; // r2

  v4 = *((_BYTE *)this + 33);
  m_pSubTask = (CTaskSimple *)this->m_pSubTask;
  if ( (*(_DWORD *)&pPed->m_nPhysicalFlags & 0x100) == 0 || (v4 & 2) != 0 )
  {
    if ( (v4 & 3) == 1
      && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(this->m_pSubTask) != 218
      && fabsf(pPed->m_vecMoveSpeed.z) < 0.01 )
    {
      m_KnockedBackAnimID = this->m_KnockedBackAnimID;
      *((_BYTE *)this + 33) |= 6u;
      if ( m_KnockedBackAnimID != -1 )
      {
        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_KnockedBackAnimID);
        if ( Association )
          Association->m_fBlendDelta = -1000.0;
      }
      m_DeathAnimID = this->m_DeathAnimID;
      if ( m_DeathAnimID != -1 )
      {
        v9 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_DeathAnimID);
        if ( v9 )
          v9->m_fBlendDelta = -1000.0;
      }
      m_pSubTask = (CTaskSimple *)CTask::operator new(0x14u);
      CTaskSimple::CTaskSimple(m_pSubTask);
      m_pSubTask[1]._vptr$CTask = 0;
      v10 = (char)m_pSubTask[2]._vptr$CTask;
      m_pSubTask[1].m_pParent = (CTask *)&off_18;
      m_pSubTask->_vptr$CTask = (int (**)(void))&off_66CB14;
      LOBYTE(m_pSubTask[2]._vptr$CTask) = v10 & 0xF8 | 4;
    }
  }
  else
  {
    *((_BYTE *)this + 33) = v4 | 2;
    *((_DWORD *)&pPed->m_nPedFlags + 1) |= 0x80000u;
    m_pSubTask = (CTaskSimple *)CTask::operator new(0x28u);
    CTaskComplexDie::CTaskComplexDie(
      (CTaskComplexDie *)m_pSubTask,
      WEAPONTYPE_DROWNING,
      ANIM_STD_PED,
      ANIM_STD_DROWN,
      4.0,
      1.0,
      0,
      0,
      0,
      0);
  }
  return m_pSubTask;
}
// 18: using guessed type int (*off_18)();
// 66CB14: using guessed type void *off_66CB14;

//----- (0052D370) --------------------------------------------------------
bool __fastcall CTaskComplexFallToDeath::CalcFall(CPed *pPed, int *iFallDir, bool *bOverRailing)
{
  float zy; // s20
  float yy; // s22
  float xy; // s24
  bool v7; // r5
  CMatrix *m_pMat; // r8
  int v9; // r9
  int v10; // r0
  int v11; // r1
  int v12; // r9
  int v13; // r0
  int v14; // r1
  int v15; // r9
  int v16; // r0
  int v17; // r1
  int v18; // r9
  int v19; // r0
  int v20; // r1
  int v21; // r9
  int v22; // r0
  int v23; // r1
  int v24; // r9
  int v25; // r0
  int v26; // r1
  int v27; // r9
  int v28; // r0
  int v29; // r1
  int v30; // r9
  int v31; // r0
  int v32; // r1
  int v33; // r10
  CSimpleTransform *p_m_transform; // r9
  int v35; // r0
  float xx; // s0
  float yx; // s2
  float zx; // s4
  CMatrix *v39; // r0
  CSimpleTransform *p_tx; // r1
  float v41; // s2
  RwReal v42; // s4
  CSimpleTransform *v43; // r1
  CMatrix *v44; // r0
  float z; // s4
  RwReal v46; // s2
  CMatrix *v49; // r1
  RwReal v50; // s0
  RwReal v51; // s4
  CVector v54; // [sp+24h] [bp-ACh] BYREF
  CVector v55; // [sp+30h] [bp-A0h] BYREF
  CVector v56; // [sp+3Ch] [bp-94h] BYREF
  CVector vecEnd; // [sp+48h] [bp-88h] BYREF
  CVector vecStart; // [sp+54h] [bp-7Ch] BYREF
  _QWORD v59[14]; // [sp+60h] [bp-70h]

  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    return 0;
  v7 = 0;
  if ( !(*((unsigned __int8 *)&pPed->m_nPhysicalFlags + 1) << 31) )
  {
    m_pMat = pPed->m_pMat;
    v59[0] = unk_61E698;
    v59[1] = unk_61E6A0;
    v9 = rand() & 3;
    v10 = rand() & 3;
    v11 = *((_DWORD *)v59 + v9);
    *((_DWORD *)v59 + v9) = *((_DWORD *)v59 + v10);
    *((_DWORD *)v59 + v10) = v11;
    v12 = rand() & 3;
    v13 = rand() & 3;
    v14 = *((_DWORD *)v59 + v12);
    *((_DWORD *)v59 + v12) = *((_DWORD *)v59 + v13);
    *((_DWORD *)v59 + v13) = v14;
    v15 = rand() & 3;
    v16 = rand() & 3;
    v17 = *((_DWORD *)v59 + v15);
    *((_DWORD *)v59 + v15) = *((_DWORD *)v59 + v16);
    *((_DWORD *)v59 + v16) = v17;
    v18 = rand() & 3;
    v19 = rand() & 3;
    v20 = *((_DWORD *)v59 + v18);
    *((_DWORD *)v59 + v18) = *((_DWORD *)v59 + v19);
    *((_DWORD *)v59 + v19) = v20;
    v21 = rand() & 3;
    v22 = rand() & 3;
    v23 = *((_DWORD *)v59 + v21);
    *((_DWORD *)v59 + v21) = *((_DWORD *)v59 + v22);
    *((_DWORD *)v59 + v22) = v23;
    v24 = rand() & 3;
    v25 = rand() & 3;
    v26 = *((_DWORD *)v59 + v24);
    *((_DWORD *)v59 + v24) = *((_DWORD *)v59 + v25);
    *((_DWORD *)v59 + v25) = v26;
    v27 = rand() & 3;
    v28 = rand() & 3;
    v29 = *((_DWORD *)v59 + v27);
    *((_DWORD *)v59 + v27) = *((_DWORD *)v59 + v28);
    *((_DWORD *)v59 + v28) = v29;
    v30 = rand() & 3;
    v31 = rand() & 3;
    v32 = *((_DWORD *)v59 + v30);
    v33 = 0;
    *((_DWORD *)v59 + v30) = *((_DWORD *)v59 + v31);
    p_m_transform = &pPed->m_transform;
    *((_DWORD *)v59 + v31) = v32;
    while ( 1 )
    {
      v35 = *((_DWORD *)v59 + v33);
      *iFallDir = v35;
      switch ( v35 )
      {
        case 0:
          xy = m_pMat->xy;
          yy = m_pMat->yy;
          zy = m_pMat->zy;
          break;
        case 1:
          xx = m_pMat->xx;
          yx = m_pMat->yx;
          zx = m_pMat->zx;
          goto LABEL_8;
        case 2:
          xx = m_pMat->xy;
          yx = m_pMat->yy;
          zx = m_pMat->zy;
LABEL_8:
          zy = -zx;
          yy = -yx;
          xy = -xx;
          break;
        case 3:
          xy = m_pMat->xx;
          yy = m_pMat->yx;
          zy = m_pMat->zx;
          break;
        default:
          break;
      }
      v39 = pPed->m_pMat;
      p_tx = &pPed->m_transform;
      if ( v39 )
        p_tx = (CSimpleTransform *)&v39->tx;
      v41 = p_tx->m_translate.y + 0.0;
      v42 = (float)(CTaskComplexFallToDeath::ms_PedChestHeightOffset + p_tx->m_translate.z)
          + (float)(zy * CTaskComplexFallToDeath::ms_NearEdgeDist);
      vecStart.x = (float)(p_tx->m_translate.x + 0.0) + (float)(xy * CTaskComplexFallToDeath::ms_NearEdgeDist);
      vecStart.y = v41 + (float)(yy * CTaskComplexFallToDeath::ms_NearEdgeDist);
      vecEnd.x = vecStart.x;
      vecStart.z = v42;
      vecEnd.y = vecStart.y;
      vecEnd.z = v42 - CTaskComplexFallToDeath::ms_FallVerticalDistance;
      if ( CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 1, 0, 1, 0, 0, 0) )
      {
        v43 = &pPed->m_transform;
        vecEnd.x = (float)(xy * 0.7) + vecStart.x;
        vecEnd.y = (float)(yy * 0.7) + vecStart.y;
        vecEnd.z = (float)(zy * 0.7) + vecStart.z;
        v44 = pPed->m_pMat;
        if ( v44 )
          v43 = (CSimpleTransform *)&v44->tx;
        z = v43->m_translate.z;
        v46 = v43->m_translate.y + 0.0;
        v56.x = v43->m_translate.x + 0.0;
        v56.y = v46;
        v56.z = CTaskComplexFallToDeath::ms_PedChestHeightOffset + z;
        if ( CWorld::GetIsLineOfSightClear(&vecEnd, &v56, 1, 1, 0, 1, 0, 0, 0) )
          break;
      }
      if ( v33++ >= 1 )
        return 0;
    }
    v7 = 1;
    v49 = pPed->m_pMat;
    if ( v49 )
      p_m_transform = (CSimpleTransform *)&v49->tx;
    v50 = p_m_transform->m_translate.z - CTaskComplexFallToDeath::ms_PedShinHeightOffset;
    *(_QWORD *)&v55.x = *(_QWORD *)&p_m_transform->m_translate.x;
    v55.z = v50;
    v51 = (float)(yy * 0.7)
        + (float)(p_m_transform->m_translate.y + (float)(yy * CTaskComplexFallToDeath::ms_NearEdgeDist));
    v54.x = (float)(xy * 0.7) + (float)((float)(xy * CTaskComplexFallToDeath::ms_NearEdgeDist) + v55.x);
    v54.y = v51;
    v54.z = (float)(zy * 0.7) + (float)(v50 + (float)(zy * CTaskComplexFallToDeath::ms_NearEdgeDist));
    *bOverRailing = !CWorld::GetIsLineOfSightClear(&v55, &v54, 1, 1, 0, 1, 0, 0, 0);
  }
  return v7;
}
// 52D572: variable 'zy' is possibly undefined
// 52D562: variable 'xy' is possibly undefined
// 52D566: variable 'yy' is possibly undefined

//----- (0052D708) --------------------------------------------------------
void __fastcall CTaskSimpleJump::CTaskSimpleJump(CTaskSimpleJump *this, const bool bForceEdgeSearch)
{
  int v3; // r0

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v3 + 28) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  *(_BYTE *)(v3 + 36) = bForceEdgeSearch;
  *(_BYTE *)(v3 + 37) = 0;
  *(_DWORD *)(v3 + 40) = 0;
  *(_DWORD *)v3 = &off_66CB84;
}
// 52D716: variable 'v3' is possibly undefined
// 66CB84: using guessed type void *off_66CB84;

//----- (0052D734) --------------------------------------------------------
void __fastcall CTaskSimpleJump::~CTaskSimpleJump(CTaskSimpleJump *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CEntity *m_pClimbEnt; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CB84;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pClimbEnt = this->m_pClimbEnt;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, &this->m_pClimbEnt);
  sub_1A01F4(this);
}
// 66CB84: using guessed type void *;

//----- (0052D774) --------------------------------------------------------
void __fastcall CTaskSimpleJump::~CTaskSimpleJump(CTaskSimpleJump *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CEntity *m_pClimbEnt; // r0
  void *v4; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CB84;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pClimbEnt = this->m_pClimbEnt;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, &this->m_pClimbEnt);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 52D7AC: variable 'v4' is possibly undefined
// 66CB84: using guessed type void *off_66CB84;

//----- (0052D7B8) --------------------------------------------------------
bool __fastcall CTaskSimpleJump::MakeAbortable(
        CTaskSimpleJump *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r1

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    m_pAnim->m_bitsFlag |= 4u;
    this->m_pAnim->m_fBlendDelta = -4.0;
  }
  return iPriority == 2;
}

//----- (0052D7D8) --------------------------------------------------------
bool __fastcall CTaskSimpleJump::ProcessPed(CTaskSimpleJump *this, CPed *pPed)
{
  CPed *v3; // r4
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v7; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  _BOOL4 m_bIsFinished; // r0
  CEventEditableResponse v10; // [sp+8h] [bp-38h] BYREF
  CEntity *v11[2]; // [sp+18h] [bp-28h] BYREF
  uint32 v12; // [sp+20h] [bp-20h]
  __int64 v13; // [sp+24h] [bp-1Ch]
  RwReal z; // [sp+2Ch] [bp-14h]

  v3 = pPed;
  if ( this->m_bIsFinished )
  {
    if ( (CPed::IsPlayer(pPed) || this->m_bForceEdgeSearch) && CGame::currArea == AREA_MAIN_MAP )
      this->m_pClimbEnt = CTaskSimpleClimb::TestForClimb(
                            v3,
                            &this->m_vecEdge,
                            &this->m_fEdgeHeading,
                            &this->m_nEdgeSurfaceType,
                            1);
    if ( !this->m_pClimbEnt )
      CTaskSimpleJump::HasPedHitHead(this, v3);
    if ( this->m_bHasHitHead )
    {
      if ( CPed::IsPlayer(v3) )
      {
        CEventEditableResponse::CEventEditableResponse(&v10);
        v11[0] = v3;
        v11[1] = (CEntity *)1110704128;
        v12 = -1;
        v13 = 0LL;
        z = 0.0;
        v10._vptr$CEvent = (int (**)(void))&off_66714C;
        if ( v3 )
        {
          CEntity::RegisterReference(v3, v11);
          if ( v12 != -1 )
          {
LABEL_19:
            EventGlobalGroup = GetEventGlobalGroup();
            CEventGroup::Add(EventGlobalGroup, (CEvent *)&v10, 0);
            v10._vptr$CEvent = (int (**)(void))&off_66714C;
            if ( v11[0] )
              CEntity::CleanUpOldReference(v11[0], v11);
            CEvent::~CEvent((CEvent *)&v10);
            return 1;
          }
          v3 = (CPed *)v11[0];
        }
        v12 = CTimer::m_snTimeInMilliseconds;
        m_pMat = v3->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v3->m_transform;
        v7 = *(_QWORD *)&p_tx->m_translate.x;
        z = p_tx->m_translate.z;
        v13 = v7;
        goto LABEL_19;
      }
    }
    else
    {
      CTaskSimpleJump::Launch(this, v3);
    }
  }
  else
  {
    if ( this->m_pAnim )
      return 0;
    if ( CTaskSimpleJump::StartLaunchAnim(this, pPed) )
    {
      m_bIsFinished = this->m_bIsFinished;
      this->m_bHasPedJumped = 1;
      return m_bIsFinished;
    }
    this->m_bHasPedJumped = 0;
  }
  return 1;
}
// 66714C: using guessed type void *off_66714C;

//----- (0052D92C) --------------------------------------------------------
bool __fastcall CTaskSimpleJump::HasPedHitHead(CTaskSimpleJump *this, CPed *pPed)
{
  bool v4; // r6
  CSimpleTransform *p_m_transform; // r9
  CSimpleTransform *p_tx; // r2
  CMatrix *m_pMat; // r1
  CCollisionData *m_pColData; // r4
  float v9; // s6
  CMatrix *v10; // r1
  __int64 v11; // kr00_8
  RwReal z; // r9
  CMatrix *v13; // r3
  __int64 v14; // kr08_8
  RwReal v15; // r0
  float *p_tz; // r1
  int v17; // r0
  int v18; // r1
  CMatrix *v19; // r0
  float *p_z; // r0
  int v21; // r0
  int v22; // r1
  CVector v25; // [sp+20h] [bp-38h] BYREF
  CVector v; // [sp+30h] [bp-28h] BYREF
  CVector v27; // 0:r0.12

  if ( (*(_BYTE *)&pPed->m_nFlags & 0x10) != 0 )
    return 0;
  v4 = 0;
  if ( CEventHandler::GetCurrentEventType(&pPed->m_pPedIntelligence->m_eventHandler) != 93 )
  {
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    m_pMat = pPed->m_pMat;
    m_pColData = CModelInfo::ms_modelInfoPtrs[pPed->m_nModelIndex]->m_pColModel->m_pColData;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v9 = (float)(m_pMat->zy * 0.25) + p_tx->m_translate.z;
    v27.x = (float)(m_pMat->xy * 0.25) + p_tx->m_translate.x;
    v27.y = (float)(m_pMat->yy * 0.25) + p_tx->m_translate.y;
    v27.z = v9 + (float)(m_pColData->m_pSphereArray[2].m_vecCentre.z + 0.25);
    this->m_bFacingWall = CWorld::TestSphereAgainstWorld(v27, 0.25, 0, 1, 1, 0, 1, 0, 0) != 0;
    v10 = pPed->m_pMat;
    if ( v10 )
      p_m_transform = (CSimpleTransform *)&v10->tx;
    v11 = *(_QWORD *)&p_m_transform->m_translate.x;
    z = p_m_transform->m_translate.z;
    v.x = 0.0;
    v.y = 0.0;
    v.z = 0.75;
    operator*(&v25, v10, &v);
    v = v25;
    v13 = pPed->m_pMat;
    v14 = *(_QWORD *)&v25.x;
    v15 = v25.z;
    if ( v13 )
    {
      v13->tx = v25.x;
      pPed->m_pMat->ty = *((float *)&v14 + 1);
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      *(_QWORD *)&pPed->m_transform.m_translate.x = *(_QWORD *)&v25.x;
      p_tz = &pPed->m_transform.m_translate.z;
    }
    *p_tz = v15;
    if ( m_pColData->m_nNoOfSpheres >= 1 )
    {
      v17 = 0;
      v18 = 12;
      do
      {
        ++v17;
        *(RwReal *)((char *)&m_pColData->m_pSphereArray->m_vecCentre.x + v18) = 0.3;
        v18 += 20;
      }
      while ( v17 < m_pColData->m_nNoOfSpheres );
    }
    if ( (*((int (__fastcall **)(CPed *, _DWORD))pPed->_vptr$CPlaceable + 14))(pPed, 0) )
      this->m_bHasHitHead = 1;
    v19 = pPed->m_pMat;
    if ( v19 )
    {
      LODWORD(v19->tx) = v11;
      pPed->m_pMat->ty = *((float *)&v11 + 1);
      p_z = &pPed->m_pMat->tz;
    }
    else
    {
      p_z = &pPed->m_transform.m_translate.z;
      *(_QWORD *)&pPed->m_transform.m_translate.x = v11;
    }
    *p_z = z;
    if ( m_pColData->m_nNoOfSpheres >= 1 )
    {
      v21 = 0;
      v22 = 12;
      do
      {
        ++v21;
        *(RwReal *)((char *)&m_pColData->m_pSphereArray->m_vecCentre.x + v22) = 0.35;
        v22 += 20;
      }
      while ( v21 < m_pColData->m_nNoOfSpheres );
    }
    return this->m_bHasHitHead;
  }
  return v4;
}

//----- (0052DAD0) --------------------------------------------------------
void __fastcall CTaskSimpleJump::Launch(CTaskSimpleJump *this, CPed *pPed)
{
  CAnimBlendAssociation *Association; // r0
  float v5; // s16
  float v6; // s0
  _BOOL4 IsPlayer; // r0
  bool v8; // zf
  float v9; // s18
  float m_fCurrentHeading; // r8
  float v11; // r0
  CPhysical *m_pGroundPhysical; // r6
  float v13; // s0
  float x; // s2
  float v15; // r0
  float v16; // s0
  float v17; // r0
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *v19; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r5
  RwInt32 v21; // r6
  RwMatrix *MatrixArray; // r0
  CMatrix *m_pMat; // r0
  float xy; // s8
  float v25; // s24
  float yy; // s10
  float v27; // s20
  float v28; // s22
  RpHAnimHierarchy_0 *v29; // r5
  RwInt32 v30; // r6
  RwMatrix *v31; // r0
  uint32 m_nTimeOfDeath; // r0
  RwV3d_0 pointsIn; // [sp+2Ch] [bp-64h] BYREF
  CVector v34; // 0:r1.12

  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 2u);
  if ( Association )
  {
    v5 = 0.17;
    v6 = 0.05;
  }
  else
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 1u);
    v5 = 0.1;
    if ( !Association )
      goto LABEL_6;
    v6 = 0.07;
  }
  v5 = v5 + (float)(v6 * Association->m_fBlendAmount);
LABEL_6:
  IsPlayer = CPed::IsPlayer(pPed);
  v8 = !IsPlayer;
  if ( !IsPlayer )
    v8 = !this->m_bUsePlayerLaunchForce;
  if ( v8 )
    v9 = 4.5;
  else
    v9 = 8.5;
  if ( pPed->m_pPlayerData )
  {
    v5 = v5 * CStats::GetFatAndMuscleModifier(STAT_MODIFIER_JUMP_SPEED);
    v9 = v9 * CStats::GetFatAndMuscleModifier(STAT_MODIFIER_JUMP_SPEED);
  }
  if ( CCheat::m_aCheatsActive[68] && CPed::IsPlayer(pPed) )
    v9 = v9 * 10.0;
  v34.z = v9;
  v34.x = 0.0;
  v34.y = 0.0;
  CPhysical::ApplyMoveForce(pPed, v34);
  if ( this->m_bFacingWall )
  {
    pPed->m_vecMoveSpeed.x = 0.0;
    pPed->m_vecMoveSpeed.y = 0.0;
  }
  else if ( ((float)((float)(pPed->m_vecMoveSpeed.x * pPed->m_vecMoveSpeed.x)
                   + (float)(pPed->m_vecMoveSpeed.y * pPed->m_vecMoveSpeed.y)) < (float)(v5 * v5)
          || pPed->m_pGroundPhysical)
         && !this->m_pClimbEnt )
  {
    m_fCurrentHeading = pPed->m_fCurrentHeading;
    v11 = sinf(m_fCurrentHeading);
    m_pGroundPhysical = pPed->m_pGroundPhysical;
    v13 = v5 * v11;
    if ( m_pGroundPhysical )
    {
      x = m_pGroundPhysical->m_vecMoveSpeed.x;
      v15 = cosf(m_fCurrentHeading);
      pPed->m_vecMoveSpeed.x = x - v13;
      v16 = (float)(v5 * v15) + m_pGroundPhysical->m_vecMoveSpeed.y;
    }
    else
    {
      v17 = cosf(m_fCurrentHeading);
      pPed->m_vecMoveSpeed.x = -v13;
      v16 = v5 * v17;
    }
    pPed->m_vecMoveSpeed.y = v16;
  }
  *(_DWORD *)&pPed->m_nPedFlags = *(_DWORD *)&pPed->m_nPedFlags & 0xFFFFFDFE | 0x200;
  if ( !this->m_pClimbEnt )
  {
    m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
    if ( this->m_bFacingWall )
    {
      v19 = CAnimManager::BlendAnimation(m_pRwObject, ANIM_STD_PED, ANIM_STD_CLIMB_GRAB, 8.0);
      v19->m_bitsFlag |= 8u;
    }
    else
    {
      CAnimManager::BlendAnimation(m_pRwObject, ANIM_STD_PED, ANIM_STD_JUMP_GLIDE, 8.0);
    }
  }
  if ( (*((_BYTE *)&pPed->m_nPedFlags + 3) & 0x10) != 0 && CLocalisation::Blood() )
  {
    memset(&pointsIn, 0, sizeof(pointsIn));
    AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
    v21 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, pPed->m_aPedFrames[9]->boneTag);
    MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
    RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &MatrixArray[v21]);
    m_pMat = pPed->m_pMat;
    xy = m_pMat->xy;
    v25 = m_pMat->zy * 0.2;
    yy = m_pMat->yy;
    v27 = m_pMat->xx * 0.14;
    v28 = m_pMat->yx * 0.14;
    pointsIn.z = v25 + (float)(pointsIn.z + -0.1);
    pointsIn.x = (float)(xy * 0.2) + pointsIn.x;
    pointsIn.y = (float)(yy * 0.2) + pointsIn.y;
    CShadows::AddPermanentShadow(
      1u,
      gpBloodPoolTex,
      (CVector *)&pointsIn,
      xy * 0.26,
      yy * 0.26,
      v27,
      v28,
      255,
      0xFFu,
      0,
      0,
      4.0,
      0xBB8u,
      1.0);
    memset(&pointsIn, 0, sizeof(pointsIn));
    v29 = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
    v30 = RpHAnimIDGetIndex(v29, pPed->m_aPedFrames[10]->boneTag);
    v31 = RpHAnimHierarchyGetMatrixArray(v29);
    RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &v31[v30]);
    pointsIn.x = (float)(xy * 0.2) + pointsIn.x;
    pointsIn.y = (float)(yy * 0.2) + pointsIn.y;
    pointsIn.z = v25 + (float)(pointsIn.z + -0.1);
    CShadows::AddPermanentShadow(
      1u,
      gpBloodPoolTex,
      (CVector *)&pointsIn,
      xy * 0.26,
      yy * 0.26,
      v27,
      v28,
      255,
      0xFFu,
      0,
      0,
      4.0,
      0xBB8u,
      1.0);
    m_nTimeOfDeath = pPed->m_nTimeOfDeath;
    if ( m_nTimeOfDeath < 0x29 )
    {
      pPed->m_nTimeOfDeath = 0;
      *(_DWORD *)&pPed->m_nPedFlags &= ~0x10000000u;
    }
    else
    {
      pPed->m_nTimeOfDeath = m_nTimeOfDeath - 40;
    }
  }
}

//----- (0052DE44) --------------------------------------------------------
bool __fastcall CTaskSimpleJump::StartLaunchAnim(CTaskSimpleJump *this, CPed *pPed)
{
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v5; // r0
  CAnimBlendAssociation *v7; // r0
  float m_fBlendAmount; // s0
  float v9; // s0
  AnimationId v10; // r2
  CAnimBlendAssociation *m_pAnim; // r6

  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x74u);
  this->m_pAnim = Association;
  if ( Association )
    return 0;
  v5 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x75u);
  this->m_pAnim = v5;
  if ( v5 )
    return 0;
  if ( SurfaceInfos_c::IsSteepSlope(&g_surfaceInfos, pPed->m_LastMaterialToHaveBeenStandingOn) )
  {
    if ( (float)((float)((float)(pPed->m_pMat->xy * pPed->m_vecGroundNormal.x)
                       + (float)(pPed->m_pMat->yy * pPed->m_vecGroundNormal.y))
               + (float)(pPed->m_pMat->zy * pPed->m_vecGroundNormal.z)) < 0.0 )
    {
LABEL_20:
      pPed->m_ik.m_flags |= 8u;
      return 0;
    }
  }
  else if ( CPed::IsPlayer(pPed)
         && !CGameLogic::IsPlayerAllowedToGoInThisDirection((CPlayerPed *)pPed, *(CVector *)&pPed->m_pMat->xy, 5.0) )
  {
    goto LABEL_20;
  }
  v7 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 2u);
  if ( v7 )
  {
    m_fBlendAmount = v7->m_fBlendAmount;
    if ( m_fBlendAmount >= 0.3 )
    {
LABEL_13:
      if ( m_fBlendAmount >= 0.3 )
        goto LABEL_16;
      goto LABEL_14;
    }
  }
  v7 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 1u);
  if ( v7 )
  {
    m_fBlendAmount = v7->m_fBlendAmount;
    goto LABEL_13;
  }
LABEL_14:
  v7 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0);
  if ( !v7 )
    goto LABEL_21;
  m_fBlendAmount = v7->m_fBlendAmount;
LABEL_16:
  if ( m_fBlendAmount > 0.3 )
  {
    v9 = (float)(v7->m_fCurrentTime / v7->m_pAnimBlendHierarchy->m_fTotalTime) + 0.367;
    if ( v9 > 1.0 )
      v9 = v9 + -1.0;
    goto LABEL_22;
  }
LABEL_21:
  v9 = 0.0;
LABEL_22:
  v10 = ANIM_STD_JUMP_LAUNCH_R;
  if ( v9 < 0.5 )
    v10 = ANIM_STD_JUMP_LAUNCH;
  m_pAnim = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v10, 8.0);
  this->m_pAnim = m_pAnim;
  if ( pPed->m_pPlayerData )
  {
    m_pAnim->m_fSpeed = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_JUMP_SPEED);
    m_pAnim = this->m_pAnim;
  }
  CAnimBlendAssociation::SetFinishCallback(m_pAnim, CTaskSimpleJump::FinishAnimLaunchCB, this);
  pPed->m_fDesiredHeading = pPed->m_fCurrentHeading;
  return 1;
}

//----- (0052DFE8) --------------------------------------------------------
void __fastcall CTaskSimpleJump::FinishAnimLaunchCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 32) = 1;
  *((_DWORD *)pData + 10) = 0;
}

//----- (0052DFF4) --------------------------------------------------------
void __fastcall CTaskComplexJump::CTaskComplexJump(CTaskComplexJump *this, int32 nForceClimb)
{
  int v3; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v3 + 12) = nForceClimb;
  *(_BYTE *)(v3 + 16) = 0;
  *(_DWORD *)v3 = &off_66CBB8;
}
// 52E002: variable 'v3' is possibly undefined
// 66CBB8: using guessed type void *off_66CBB8;

//----- (0052E018) --------------------------------------------------------
void __fastcall CTaskComplexJump::~CTaskComplexJump(CTaskComplexJump *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 52E024: variable 'v1' is possibly undefined

//----- (0052E028) --------------------------------------------------------
bool __fastcall CTaskComplexJump::MakeAbortable(
        CTaskComplexJump *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v8; // zf

  if ( iPriority == 1 && pEvent )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
    {
      if ( pEvent[2]._vptr$CEvent == (int (**)(void))((char *)&dword_34 + 2) )
      {
        v8 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
        if ( LOBYTE(pEvent[5]._vptr$CEvent) )
          v8 = !*(&pEvent->m_bIsPersistent + 1);
        if ( !v8 )
          goto LABEL_12;
      }
    }
    else if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 10 )
    {
LABEL_12:
      *(_DWORD *)&pPed->m_nPedFlags &= 0xFFFFF9FF;
      return 1;
    }
  }
  if ( (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent) == 1 )
    goto LABEL_12;
  return 0;
}
// 34: using guessed type int dword_34;

//----- (0052E09C) --------------------------------------------------------
CTask *__fastcall CTaskComplexJump::CreateNextSubTask(CTaskComplexJump *this, CPed *pPed)
{
  int v4; // r0
  CTask *m_pSubTask; // r0
  int v7; // r1
  CTask *m_pParent; // r0
  bool v9; // zf

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 > 253 )
  {
    if ( v4 == 254 )
    {
      v7 = 240;
      if ( (*((_BYTE *)&pPed->m_nPedFlags + 1) & 2) == 0 )
        v7 = 1302;
      return CTaskComplexJump::CreateSubTask(this, v7, pPed);
    }
    if ( v4 != 500 )
      return 0;
  }
  else if ( v4 == 210 )
  {
    m_pSubTask = this->m_pSubTask;
    if ( HIBYTE(m_pSubTask[4]._vptr$CTask) )
    {
      if ( BYTE1(m_pSubTask[4]._vptr$CTask) )
      {
        v7 = 500;
        *(_DWORD *)&pPed->m_nPedFlags |= 0x400u;
      }
      else
      {
        m_pParent = m_pSubTask[3].m_pParent;
        v9 = m_pParent == 0;
        if ( m_pParent )
          v9 = this->m_nForceClimb == -1;
        if ( v9 )
          v7 = 240;
        else
          v7 = 254;
        *(_DWORD *)&pPed->m_nPedFlags |= 0x200u;
      }
      return CTaskComplexJump::CreateSubTask(this, v7, pPed);
    }
  }
  else if ( v4 != 240 )
  {
    return 0;
  }
  v7 = 1302;
  *(_DWORD *)&pPed->m_nPedFlags &= ~0x400u;
  return CTaskComplexJump::CreateSubTask(this, v7, pPed);
}

//----- (0052E138) --------------------------------------------------------
CTask *__fastcall CTaskComplexJump::CreateSubTask(CTaskComplexJump *this, const int iSubTaskType, CPed *pPed)
{
  char *v5; // r4
  CTask *m_pSubTask; // r0
  CTask *v7; // r0
  int32 v8; // r8
  CTask *v9; // r11
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float v12; // s16
  float v13; // s20
  float z; // s18
  CTask *v15; // r6
  CEntity **v16; // r5
  char v17; // r9
  CTask v18; // d16
  int32 m_nForceClimb; // r6
  char v21; // [sp+0h] [bp-40h]
  CTask *m_pParent; // [sp+4h] [bp-3Ch]

  v5 = 0;
  if ( iSubTaskType <= 253 )
  {
    if ( iSubTaskType == 210 )
    {
      v5 = (char *)CTask::operator new(0x2Cu);
      m_nForceClimb = this->m_nForceClimb;
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *((_DWORD *)v5 + 7) = 0;
      *((_DWORD *)v5 + 8) = 0;
      if ( m_nForceClimb != 1 )
        LOBYTE(m_nForceClimb) = 0;
      v5[36] = m_nForceClimb;
      v5[37] = 0;
      *((_DWORD *)v5 + 10) = 0;
      *(_DWORD *)v5 = &off_66CB84;
      if ( this->m_bUsePlayerLaunchForce || CPedGroups::IsInPlayersGroup(pPed) )
        v5[37] = 1;
    }
    else if ( iSubTaskType == 240 )
    {
      v5 = (char *)CTask::operator new(0x10u);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_WORD *)v5 + 6) = 1;
      v5[14] = 0;
      *(_DWORD *)v5 = &off_66CAA4;
      m_pSubTask = this->m_pSubTask;
      if ( m_pSubTask )
      {
        if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 254
          && LOBYTE(this->m_pSubTask[1].m_pParent) )
        {
          v5[14] = 1;
        }
      }
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 254:
        v7 = this->m_pSubTask;
        if ( v7 && (*((int (__fastcall **)(CTask *))v7->_vptr$CTask + 5))(v7) == 210 )
        {
          v8 = this->m_nForceClimb;
          v9 = this->m_pSubTask;
          m_pMat = pPed->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          v12 = *(float *)&v9[2]._vptr$CTask;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          v13 = CTaskSimpleClimb::ms_fMinForStretchGrab;
          z = p_tx->m_translate.z;
          v5 = (char *)CTask::operator new(0x30u);
          v21 = (char)v9[3]._vptr$CTask;
          m_pParent = v9[2].m_pParent;
          v15 = v9[3].m_pParent;
          CTaskSimple::CTaskSimple((CTaskSimple *)v5);
          *(_DWORD *)v5 = &off_66CBF4;
          *((_WORD *)v5 + 4) = 0;
          v5[10] = 0;
          v5[12] = 0;
          *((_DWORD *)v5 + 11) = 0;
          *((_DWORD *)v5 + 9) = v15;
          v16 = (CEntity **)(v5 + 36);
          CWidgetHelpText::ConditionSatisfied(0x400u);
          v17 = 1;
          if ( (float)(v12 - z) < v13 )
            v17 = 2;
          if ( v8 != 1 )
            LOBYTE(v8) = 0;
          if ( *v16 )
            CEntity::RegisterReference(*v16, (CEntity **)v5 + 9);
          v18 = v9[1];
          *((_DWORD *)v5 + 8) = v9[2]._vptr$CTask;
          *((CTask *)v5 + 3) = v18;
          v5[15] = v21;
          *((_DWORD *)v5 + 5) = m_pParent;
          v5[13] = v17;
          v5[11] = v8;
          v5[14] = 0;
          v5[16] = -1;
          *((_WORD *)v5 + 20) = 0;
        }
        else
        {
          v5 = (char *)CTask::operator new(0x10u);
          CTaskComplex::CTaskComplex((CTaskComplex *)v5);
          *((_WORD *)v5 + 6) = 1;
          v5[14] = 0;
          *(_DWORD *)v5 = &off_66CAA4;
        }
        break;
      case 500:
        v5 = (char *)CTask::operator new(0x10u);
        CTaskSimpleHitHead::CTaskSimpleHitHead((CTaskSimpleHitHead *)v5);
        break;
      case 1302:
        *(_DWORD *)&pPed->m_nPedFlags &= ~0x200u;
        return 0;
    }
  }
  return (CTask *)v5;
}
// 66CAA4: using guessed type void *off_66CAA4;
// 66CB84: using guessed type void *off_66CB84;
// 66CBF4: using guessed type void *off_66CBF4;

//----- (0052E33C) --------------------------------------------------------
CTask *__fastcall CTaskComplexJump::CreateFirstSubTask(CTaskComplexJump *this, CPed *pPed)
{
  CTaskSimple *v4; // r4
  int32 m_nForceClimb; // r5

  v4 = (CTaskSimple *)CTask::operator new(0x2Cu);
  m_nForceClimb = this->m_nForceClimb;
  CTaskSimple::CTaskSimple(v4);
  v4[3].m_pParent = 0;
  v4[4]._vptr$CTask = 0;
  if ( m_nForceClimb != 1 )
    LOBYTE(m_nForceClimb) = 0;
  LOBYTE(v4[4].m_pParent) = m_nForceClimb;
  BYTE1(v4[4].m_pParent) = 0;
  v4[5]._vptr$CTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66CB84;
  if ( this->m_bUsePlayerLaunchForce || CPedGroups::IsInPlayersGroup(pPed) )
    BYTE1(v4[4].m_pParent) = 1;
  return v4;
}
// 66CB84: using guessed type void *off_66CB84;

//----- (0052E398) --------------------------------------------------------
CTask *__fastcall CTaskComplexJump::ControlSubTask(CTaskComplexJump *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0052E39C) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::CTaskSimpleClimb(
        CTaskSimpleClimb *this,
        CEntity *pClimbEnt,
        const CVector *vecTarget,
        float fHeading,
        uint8 nSurfaceType,
        int8 nHeight,
        const bool bForceClimb)
{
  int8 v11; // r2
  CEntity *m_pClimbEnt; // r0
  bool v13; // r1
  __int64 v14; // d16

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)&this->m_bIsFinished = 0;
  this->m_bChangePosition = 0;
  this->m_bInvalidClimb = 0;
  this->m_pAnim = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CBF4;
  this->m_pClimbEnt = pClimbEnt;
  CWidgetHelpText::ConditionSatisfied(0x400u);
  v11 = nHeight;
  m_pClimbEnt = this->m_pClimbEnt;
  v13 = bForceClimb;
  if ( m_pClimbEnt )
  {
    CEntity::RegisterReference(m_pClimbEnt, &this->m_pClimbEnt);
    v11 = nHeight;
    v13 = bForceClimb;
  }
  v14 = *(_QWORD *)&vecTarget->x;
  this->m_vecHandholdPos.z = vecTarget->z;
  *(_QWORD *)&this->m_vecHandholdPos.x = v14;
  this->m_nSurfaceType = nSurfaceType;
  this->m_fHandholdHeading = fHeading;
  this->m_nHeightForAnim = v11;
  this->m_bForceClimb = v13;
  this->m_nHeightForPos = 0;
  this->m_nFallAfterVault = -1;
  this->m_nGetToPosCounter = 0;
}
// 66CBF4: using guessed type void *;

//----- (0052E43C) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::~CTaskSimpleClimb(CTaskSimpleClimb *this)
{
  CEntity *m_pClimbEnt; // r0
  CEntity **p_m_pClimbEnt; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pClimbEnt = &this->m_pClimbEnt;
  m_pClimbEnt = this->m_pClimbEnt;
  this->_vptr$CTask = (int (**)(void))&off_66CBF4;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, p_m_pClimbEnt);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  sub_1A01F4(this);
}
// 66CBF4: using guessed type void *off_66CBF4;

//----- (0052E480) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::~CTaskSimpleClimb(CTaskSimpleClimb *this)
{
  CEntity *m_pClimbEnt; // r0
  CEntity **p_m_pClimbEnt; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pClimbEnt = &this->m_pClimbEnt;
  m_pClimbEnt = this->m_pClimbEnt;
  this->_vptr$CTask = (int (**)(void))&off_66CBF4;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, p_m_pClimbEnt);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  CTask::~CTask(this);
  sub_197118(v5);
}
// 52E4BC: variable 'v5' is possibly undefined
// 66CBF4: using guessed type void *off_66CBF4;

//----- (0052E4C8) --------------------------------------------------------
void CTaskSimpleClimb::Shutdown()
{
  CColModel::RemoveCollisionVolumes(&CTaskSimpleClimb::ms_ClimbColModel);
  CColModel::RemoveCollisionVolumes(&CTaskSimpleClimb::ms_StandupColModel);
  CColModel::RemoveCollisionVolumes(&CTaskSimpleClimb::ms_VaultColModel);
  sub_195058(&CTaskSimpleClimb::ms_FindEdgeColModel);
}

//----- (0052E508) --------------------------------------------------------
bool __fastcall CTaskSimpleClimb::MakeAbortable(
        CTaskSimpleClimb *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool result; // r0
  CAnimBlendAssociation *m_pAnim; // r0

  if ( pEvent
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent) <= 70
    && pPed->m_nHealth > 0.0 )
  {
    return 0;
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    m_pAnim->m_fBlendDelta = -4.0;
    CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  pPed->m_vecMoveSpeed.x = 0.0;
  pPed->m_vecMoveSpeed.y = 0.0;
  pPed->m_vecMoveSpeed.z = -0.05;
  result = 1;
  this->m_bIsFinished = 1;
  return result;
}

//----- (0052E578) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::StartSpeech(const CTaskSimpleClimb *this, CPed *pPed)
{
  int m_nHeightForAnim; // r0
  UInt16 v5; // r1

  if ( CPed::IsPlayer(pPed) )
  {
    m_nHeightForAnim = this->m_nHeightForAnim;
    if ( m_nHeightForAnim == 3 )
    {
      v5 = 355;
    }
    else
    {
      if ( m_nHeightForAnim != 2 )
        return;
      v5 = 354;
    }
    CPed::Say(pPed, v5, 0, 1.0, 0, 0, 0);
  }
}

//----- (0052E5BC) --------------------------------------------------------
bool __fastcall CTaskSimpleClimb::ProcessPed(CTaskSimpleClimb *this, CPed *pPed)
{
  float v2; // s22
  float v3; // s24
  bool v6; // r6
  CEntity *m_pClimbEnt; // r0
  int v8; // r1
  bool v9; // zf
  int m_nHeightForAnim; // r0
  UInt16 v11; // r1
  __int64 v12; // d16
  float m_fHandholdHeading; // s16
  CEntity *v14; // r9
  const CMatrix *m_pMat; // r1
  CMatrix *v16; // r0
  float m_heading; // s0
  CAnimBlendAssociation *m_pAnim; // r0
  int v19; // r10
  float *m_nHeightForPos; // r0
  unsigned int v21; // r0
  float v22; // r6
  float v23; // s18
  float v24; // s2
  CMatrix *v25; // r0
  float v26; // s22
  CSimpleTransform *p_tx; // r1
  float x; // s28
  float y; // s17
  float v30; // s24
  float z; // s30
  float v32; // s26
  float v33; // s0
  float v34; // s2
  float v35; // s4
  float v36; // s10
  float v37; // s8
  float v38; // s12
  RwReal v39; // s4
  RwReal v40; // s2
  CAnimBlendAssociation *v41; // r0
  uint16 m_bitsFlag; // r1
  bool v43; // zf
  CMatrix *v44; // r0
  float *p_x; // r1
  CMatrix *v46; // r0
  float v47; // s6
  float v48; // s1
  float v49; // s10
  float v50; // s12
  float v51; // s8
  float v52; // s14
  float v53; // s14
  CAnimBlendAssociation *v54; // r0
  bool v55; // zf
  unsigned int v56; // r1
  int (**v57)(void); // r0
  CMatrix *v58; // r0
  float v59; // s0
  int m_nPedFlags; // r6
  int v61; // r12
  int v62; // lr
  int v63; // r2
  CMatrix *v64; // r0
  float xy; // s0
  float v66; // s2
  float yy; // s4
  float v68; // s6
  float v69; // s8
  float v70; // s0
  unsigned int v71; // r6
  int v72; // r0
  CEntity **v73; // r6
  CMatrix *v74; // r0
  CSimpleTransform *p_m_transform; // r2
  double v76; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  CAnimBlendAssociation *v78; // r0
  CPad *PadFromPlayer; // r6
  CAnimBlendAssociation *v80; // r0
  int8 v81; // r0
  int8 v82; // r0
  int v83; // r0
  bool v84; // zf
  CAnimBlendAssociation *v85; // r1
  bool v86; // zf
  float v87; // s20
  float v88; // s18
  float v89; // r0
  float v90; // s20
  float v91; // s18
  float v92; // r0
  CMatrix *v93; // r0
  float v94; // r3
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v98; // r0
  float v99; // s2
  float v100; // s4
  CEventEditableResponse vecTargetPos; // [sp+10h] [bp-A8h] BYREF
  CEntity *v103; // [sp+20h] [bp-98h]
  int v104; // [sp+24h] [bp-94h]
  uint32 v105; // [sp+28h] [bp-90h]
  double v106; // [sp+2Ch] [bp-8Ch]
  RwReal v107; // [sp+34h] [bp-84h]
  CVector v; // [sp+38h] [bp-80h] BYREF
  CVector v109; // [sp+48h] [bp-70h] BYREF
  uint8 nSurfaceType; // [sp+5Bh] [bp-5Dh] BYREF
  float fGrabHeading[23]; // [sp+5Ch] [bp-5Ch] BYREF
  CVector v112; // 0:r1.12
  CVector v113; // 0:r2.8,8:^0.4

  if ( !this->m_bIsFinished )
  {
    m_pClimbEnt = this->m_pClimbEnt;
    if ( m_pClimbEnt )
    {
      v8 = *(_BYTE *)&m_pClimbEnt->m_info & 7;
      if ( v8 == 2 )
      {
        if ( LODWORD(m_pClimbEnt[24].m_transform.m_translate.x) != 6
          || sqrtf(
               (float)((float)(m_pClimbEnt[1].m_transform.m_translate.z * m_pClimbEnt[1].m_transform.m_translate.z)
                     + (float)(m_pClimbEnt[1].m_transform.m_heading * m_pClimbEnt[1].m_transform.m_heading))
             + (float)(*(float *)&m_pClimbEnt[1].m_pMat * *(float *)&m_pClimbEnt[1].m_pMat)) <= 0.1 )
        {
          goto LABEL_16;
        }
      }
      else
      {
        v9 = v8 == 4;
        if ( v8 == 4 )
          v9 = (*(_DWORD *)&m_pClimbEnt->m_nFlags & 0x40004) == 0;
        if ( !v9 || (LOBYTE(m_pClimbEnt[1].m_transform.m_translate.y) & 4) != 0 )
        {
LABEL_16:
          if ( (*(_BYTE *)&m_pClimbEnt->m_info & 7) == 2 )
            pPed->m_pNOCollisionVehicle = m_pClimbEnt;
          if ( !this->m_pAnim || this->m_bChangeAnimation )
          {
            CTaskSimpleClimb::StartAnim(this, pPed);
            if ( CPed::IsPlayer(pPed) )
            {
              m_nHeightForAnim = this->m_nHeightForAnim;
              if ( m_nHeightForAnim == 3 )
              {
                v11 = 355;
              }
              else
              {
                if ( m_nHeightForAnim != 2 )
                  goto LABEL_26;
                v11 = 354;
              }
              CPed::Say(pPed, v11, 0, 1.0, 0, 0, 0);
            }
          }
LABEL_26:
          v12 = *(_QWORD *)&this->m_vecHandholdPos.x;
          m_fHandholdHeading = this->m_fHandholdHeading;
          v14 = this->m_pClimbEnt;
          v.z = this->m_vecHandholdPos.z;
          *(_QWORD *)&v.x = v12;
          if ( (unsigned __int8)((*(_BYTE *)&v14->m_info & 7) - 2) <= 2u )
          {
            m_pMat = v14->m_pMat;
            if ( !m_pMat )
            {
              CPlaceable::AllocateMatrix(v14);
              CSimpleTransform::UpdateMatrix(&v14->m_transform, v14->m_pMat);
              m_pMat = v14->m_pMat;
            }
            operator*((CVector *)&vecTargetPos, m_pMat, &v);
            v.z = *(RwReal *)&vecTargetPos.m_bIsPersistent;
            *(_QWORD *)&v.x = *(_QWORD *)&vecTargetPos._vptr$CEvent;
            v14 = this->m_pClimbEnt;
            v16 = v14->m_pMat;
            if ( v16 )
              m_heading = atan2f(COERCE_FLOAT(LODWORD(v16->xy) ^ 0x80000000), v16->yy);
            else
              m_heading = v14->m_transform.m_heading;
            m_fHandholdHeading = m_fHandholdHeading + m_heading;
          }
          if ( this->m_bChangePosition && (m_pAnim = this->m_pAnim) != 0 )
          {
            v19 = 0;
            if ( m_pAnim->m_fBlendAmount == 1.0 )
            {
              this->m_bChangePosition = 0;
              this->m_nHeightForPos = this->m_nHeightForAnim;
              v19 = 1;
            }
          }
          else
          {
            v19 = 0;
          }
          m_nHeightForPos = (float *)this->m_nHeightForPos;
          if ( (int)m_nHeightForPos < 1 )
          {
            if ( v19 != 1 )
              goto LABEL_92;
          }
          else
          {
            v21 = (unsigned int)m_nHeightForPos - 1;
            if ( v21 <= 5 )
            {
              v2 = *off_66CCB0[v21];
              v3 = *off_66CC90[v21];
            }
            v22 = sinf(m_fHandholdHeading);
            v23 = cosf(m_fHandholdHeading);
            v24 = v3 * v22;
            v25 = pPed->m_pMat;
            v26 = v2 + v.z;
            p_tx = (CSimpleTransform *)&v25->tx;
            if ( !v25 )
              p_tx = &pPed->m_transform;
            x = p_tx->m_translate.x;
            y = p_tx->m_translate.y;
            v30 = v.y + (float)(v3 * v23);
            z = p_tx->m_translate.z;
            v32 = v.x - v24;
            v33 = 0.0;
            if ( (*(_DWORD *)&v14->m_nFlags & 0x40004) != 0 )
            {
              v34 = 0.0;
              v35 = 0.0;
              if ( v19 != 1 )
                goto LABEL_46;
            }
            else
            {
              v34 = 0.0;
              v35 = 0.0;
              if ( (unsigned __int8)((*(_BYTE *)&v14->m_info & 7) - 2) <= 2u )
              {
                v44 = v14->m_pMat;
                p_x = &v44->tx;
                if ( !v44 )
                  p_x = &v14->m_transform.m_translate.x;
                v113.x = v32 - *p_x;
                v113.y = v30 - p_x[1];
                v113.z = v26 - p_x[2];
                CPhysical::GetSpeed((CVector *)&vecTargetPos, (CPhysical *)v14, v113);
                v34 = *(float *)&vecTargetPos.m_iAccumulatedTime;
                v33 = *(float *)&vecTargetPos._vptr$CEvent;
                v35 = *(float *)&vecTargetPos.m_bIsPersistent;
              }
              if ( v19 != 1 )
              {
LABEL_46:
                v36 = v30 - y;
                v37 = v32 - x;
                v38 = v26 - z;
                *(_DWORD *)&pPed->m_nPedFlags &= ~1u;
                if ( (float)((float)((float)(v37 * v37) + (float)(v36 * v36)) + (float)(v38 * v38)) >= 0.1 )
                {
                  v47 = CTimer::ms_fTimeStep;
                  v48 = v38 * 0.25;
                  v49 = (float)(v36 * 0.25) * (float)(1.0 / CTimer::ms_fTimeStep);
                  v50 = (float)(v37 * 0.25) * (float)(1.0 / CTimer::ms_fTimeStep);
                  v51 = v48 * (float)(1.0 / CTimer::ms_fTimeStep);
                  pPed->m_vecMoveSpeed.x = v50;
                  pPed->m_vecMoveSpeed.y = v49;
                  pPed->m_vecMoveSpeed.z = v51;
                  v52 = sqrtf((float)((float)(v50 * v50) + (float)(v49 * v49)) + (float)(v51 * v51));
                  if ( v52 > 0.2 )
                  {
                    v53 = 0.2 / v52;
                    v50 = v50 * v53;
                    v49 = v53 * v49;
                    v51 = v53 * v51;
                    pPed->m_vecMoveSpeed.x = v50;
                    pPed->m_vecMoveSpeed.y = v49;
                    pPed->m_vecMoveSpeed.z = v51;
                  }
                  pPed->m_vecMoveSpeed.x = v33 + v50;
                  pPed->m_vecMoveSpeed.y = v34 + v49;
                  pPed->m_vecMoveSpeed.z = v35 + v51;
                  v54 = this->m_pAnim;
                  v55 = LOBYTE(v54->m_bitsFlag) << 31 == 0;
                  if ( LOBYTE(v54->m_bitsFlag) << 31 )
                    v55 = v54->m_animId == 129;
                  if ( v55 )
                  {
                    v56 = (unsigned __int16)this->m_nGetToPosCounter
                        + (unsigned int)(float)((float)(v47 / 50.0) * 1000.0);
                    this->m_nGetToPosCounter = v56;
                    if ( (int)(v56 << 16) > 65536000 || (__int16)v56 > 500 && v54->m_animId == 129 )
                    {
                      v57 = this->_vptr$CTask;
                      this->m_bInvalidClimb = 1;
                      ((void (__fastcall *)(CTaskSimpleClimb *, CPed *, int, _DWORD))v57[7])(this, pPed, 1, 0);
                      v58 = pPed->m_pMat;
                      v59 = pPed->m_fMass * -0.1;
                      v112.x = v59 * v58->xy;
                      v112.y = v59 * v58->yy;
                      v112.z = v59 * v58->zy;
                      CPhysical::ApplyMoveForce(pPed, v112);
                    }
                  }
                }
                else
                {
                  v39 = v35 + (float)(v38 * (float)(1.0 / CTimer::ms_fTimeStep));
                  v40 = v34 + (float)(v36 * (float)(1.0 / CTimer::ms_fTimeStep));
                  pPed->m_vecMoveSpeed.x = v33 + (float)(v37 * (float)(1.0 / CTimer::ms_fTimeStep));
                  pPed->m_vecMoveSpeed.y = v40;
                  pPed->m_vecMoveSpeed.z = v39;
                  v41 = this->m_pAnim;
                  m_bitsFlag = v41->m_bitsFlag;
                  v43 = (m_bitsFlag & 1) == 0;
                  if ( (m_bitsFlag & 1) == 0 )
                    v43 = this->m_nHeightForAnim == 3;
                  if ( v43 )
                  {
                    v109.z = CTaskSimpleClimb::ms_fAtEdgeOffsetVert + v.z;
                    v109.x = v.x - (float)(v22 * CTaskSimpleClimb::ms_fAtEdgeOffsetHorz);
                    v109.y = (float)(v23 * CTaskSimpleClimb::ms_fAtEdgeOffsetHorz) + v.y;
                    if ( (*(_BYTE *)&this->m_pClimbEnt->m_info & 7) != 2 )
                    {
                      if ( !CTaskSimpleClimb::ScanToGrab(
                              pPed,
                              (CVector *)&vecTargetPos,
                              fGrabHeading,
                              &nSurfaceType,
                              0,
                              0,
                              1u,
                              &v109) )
                      {
                        this->m_bChangeAnimation = 1;
                        this->m_nHeightForAnim = 5;
                        goto LABEL_92;
                      }
                      v41 = this->m_pAnim;
                      m_bitsFlag = v41->m_bitsFlag;
                    }
                    v41->m_bitsFlag = m_bitsFlag | 1;
                  }
                }
LABEL_92:
                if ( CPed::IsPlayer(pPed) )
                  PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
                else
                  PadFromPlayer = 0;
                v80 = this->m_pAnim;
                if ( v80 && v80->m_fBlendAmount == 1.0 )
                {
                  switch ( v80->m_animId )
                  {
                    case 0x80:
                      if ( (float)(v80->m_fCurrentTime + v80->m_fTimeStep) < v80->m_pAnimBlendHierarchy->m_fTotalTime )
                        break;
                      if ( this->m_bForceClimb
                        || PadFromPlayer && (CPad::GetJump(PadFromPlayer) || CPad::GetAutoClimb(PadFromPlayer)) )
                      {
                        v81 = this->m_nHeightForAnim;
                        this->m_bChangeAnimation = 1;
                        this->m_nHeightForAnim = v81 + 1;
                      }
                      CTaskSimpleClimb::StartAnim(this, pPed);
                      if ( !PadFromPlayer )
                        goto LABEL_119;
                      goto LABEL_118;
                    case 0x81:
                      if ( this->m_bForceClimb )
                        goto LABEL_116;
                      if ( !PadFromPlayer )
                        goto LABEL_119;
                      if ( !CPad::GetJump(PadFromPlayer) && !CPad::GetAutoClimb(PadFromPlayer) )
                        goto LABEL_118;
LABEL_116:
                      v82 = this->m_nHeightForAnim;
                      this->m_bChangeAnimation = 1;
                      this->m_nHeightForAnim = v82 + 1;
                      break;
                    case 0x82:
                    case 0x83:
                      if ( v80->m_fCurrentTime != v80->m_pAnimBlendHierarchy->m_fTotalTime )
                        break;
                      goto LABEL_116;
                    case 0x85:
                      if ( (float)(v80->m_fCurrentTime + v80->m_fTimeStep) < v80->m_pAnimBlendHierarchy->m_fTotalTime )
                        break;
                      goto LABEL_116;
                    default:
                      if ( v80->m_fCurrentTime != v80->m_pAnimBlendHierarchy->m_fTotalTime
                        || (!PadFromPlayer || !CPad::JumpJustDown(PadFromPlayer)) && !this->m_bForceClimb )
                      {
                        break;
                      }
                      goto LABEL_116;
                  }
                }
                if ( PadFromPlayer )
                {
LABEL_118:
                  if ( CPad::GetAbortClimb(PadFromPlayer) )
                    goto LABEL_134;
                }
LABEL_119:
                v83 = (unsigned __int8)this->m_nHeightForPos;
                v84 = v83 == 5;
                if ( v83 != 5 )
                  v84 = v83 == 3;
                if ( !v84 )
                  goto LABEL_145;
                v85 = this->m_pAnim;
                v86 = v85 == 0;
                if ( v85 )
                  v86 = LOBYTE(v85->m_bitsFlag) << 31 == 0;
                if ( v86 )
                {
LABEL_145:
                  if ( this->m_nHeightForAnim == 3 && (char)v83 <= 2 )
                  {
                    v87 = sinf(m_fHandholdHeading);
                    v88 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
                    v89 = cosf(m_fHandholdHeading);
                    v109.z = CTaskSimpleClimb::ms_fAtEdgeOffsetVert + v.z;
                    v109.x = v.x - (float)(v87 * v88);
                    v109.y = v.y + (float)(v88 * v89);
                    if ( (*(_BYTE *)&this->m_pClimbEnt->m_info & 7) != 2
                      && !CTaskSimpleClimb::ScanToGrab(
                            pPed,
                            (CVector *)&vecTargetPos,
                            fGrabHeading,
                            &nSurfaceType,
                            0,
                            0,
                            1u,
                            &v109) )
                    {
                      this->m_nHeightForAnim = 5;
                    }
                  }
                  goto LABEL_135;
                }
                v90 = sinf(m_fHandholdHeading);
                v91 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
                v92 = cosf(m_fHandholdHeading);
                v109.z = CTaskSimpleClimb::ms_fAtEdgeOffsetVert + v.z;
                v109.x = v.x - (float)(v90 * v91);
                v109.y = v.y + (float)(v91 * v92);
                if ( !CTaskSimpleClimb::ScanToGrab(
                        pPed,
                        (CVector *)&vecTargetPos,
                        fGrabHeading,
                        &nSurfaceType,
                        0,
                        1u,
                        0,
                        &v109) )
                {
LABEL_135:
                  v93 = pPed->m_pMat;
                  pPed->m_fCurrentHeading = m_fHandholdHeading;
                  pPed->m_fDesiredHeading = m_fHandholdHeading;
                  if ( v93 )
                  {
                    v94 = m_fHandholdHeading;
                    tx = v93->tx;
                    ty = v93->ty;
                    v6 = 0;
                    tz = v93->tz;
                    CMatrix::SetRotate(v93, 0.0, 0.0, v94);
                    v98 = pPed->m_pMat;
                    v99 = ty + v98->ty;
                    v100 = tz + v98->tz;
                    v98->tx = tx + v98->tx;
                    v98->ty = v99;
                    v98->tz = v100;
                  }
                  else
                  {
                    v6 = 0;
                    pPed->m_transform.m_heading = m_fHandholdHeading;
                  }
                  return v6;
                }
LABEL_134:
                (*((void (__fastcall **)(CTaskSimpleClimb *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(
                  this,
                  pPed,
                  1,
                  0);
                goto LABEL_135;
              }
            }
            v46 = pPed->m_pMat;
            if ( v46 )
            {
              v46->tx = v32;
              pPed->m_pMat->ty = v30;
              m_nHeightForPos = &pPed->m_pMat->tz;
            }
            else
            {
              m_nHeightForPos = &pPed->m_transform.m_translate.z;
              pPed->m_transform.m_translate.x = v32;
              pPed->m_transform.m_translate.y = v30;
            }
            *m_nHeightForPos = v26;
            pPed->m_vecMoveSpeed.x = v33;
            pPed->m_vecMoveSpeed.y = v34;
            pPed->m_vecMoveSpeed.z = v35;
            LOBYTE(m_nHeightForPos) = this->m_nHeightForPos;
          }
          if ( ((unsigned __int8)m_nHeightForPos | 2) == 6 )
          {
            this->m_bIsFinished = 1;
            m_nPedFlags = (int)pPed->m_nPedFlags;
            v61 = *((_DWORD *)&pPed->m_nPedFlags + 1);
            v62 = *((_DWORD *)&pPed->m_nPedFlags + 2);
            v63 = *((_DWORD *)&pPed->m_nPedFlags + 3);
            *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags & 0xFFFFF9FF;
            v64 = pPed->m_pMat;
            xy = v64->xy;
            if ( this->m_nHeightForPos == 6 )
            {
              v66 = 0.02;
              yy = v64->yy;
              v68 = v64->zy * 0.02;
              v69 = -0.05;
              v70 = xy * 0.02;
              v71 = m_nPedFlags & 0xFFFFF9FE;
            }
            else
            {
              v66 = 0.05;
              v71 = m_nPedFlags & 0xFFFFF9FE | 1;
              yy = v64->yy;
              v70 = xy * 0.05;
              v68 = v64->zy * 0.05;
              v69 = -0.01;
            }
            pPed->m_vecMoveSpeed.x = v70 + 0.0;
            pPed->m_vecMoveSpeed.y = (float)(yy * v66) + 0.0;
            pPed->m_vecMoveSpeed.z = v68 + v69;
            *(_DWORD *)&pPed->m_nPedFlags = v71 | 2;
            *((_DWORD *)&pPed->m_nPedFlags + 1) = v61;
            *((_DWORD *)&pPed->m_nPedFlags + 2) = v62;
            *((_DWORD *)&pPed->m_nPedFlags + 3) = v63;
            if ( CPed::IsPlayer(pPed) )
            {
              CEventEditableResponse::CEventEditableResponse(&vecTargetPos);
              v103 = pPed;
              v104 = 1112014848;
              v73 = (CEntity **)(v72 + 16);
              v105 = -1;
              v106 = 0.0;
              v107 = 0.0;
              vecTargetPos._vptr$CEvent = (int (**)(void))&off_66714C;
              CEntity::RegisterReference(pPed, (CEntity **)(v72 + 16));
              if ( v105 == -1 )
              {
                v105 = CTimer::m_snTimeInMilliseconds;
                v74 = v103->m_pMat;
                p_m_transform = (CSimpleTransform *)&v74->tx;
                if ( !v74 )
                  p_m_transform = &v103->m_transform;
                v76 = *(double *)&p_m_transform->m_translate.x;
                v107 = p_m_transform->m_translate.z;
                v106 = v76;
              }
              EventGlobalGroup = GetEventGlobalGroup();
              CEventGroup::Add(EventGlobalGroup, (CEvent *)&vecTargetPos, 0);
              vecTargetPos._vptr$CEvent = (int (**)(void))&off_66714C;
              if ( v103 )
                CEntity::CleanUpOldReference(v103, v73);
              CEvent::~CEvent((CEvent *)&vecTargetPos);
            }
            v78 = this->m_pAnim;
            if ( v78 )
              v78->m_fBlendDelta = -8.0;
            goto LABEL_2;
          }
          goto LABEL_92;
        }
      }
    }
    v6 = 1;
    (*((void (__fastcall **)(CTaskSimpleClimb *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(this, pPed, 1, 0);
    return v6;
  }
LABEL_2:
  v6 = 1;
  if ( pPed->m_pNOCollisionVehicle == this->m_pClimbEnt )
    pPed->m_pNOCollisionVehicle = 0;
  return v6;
}
// 52E7B4: variable 'v3' is possibly undefined
// 52E7BC: variable 'v2' is possibly undefined
// 52EBDE: variable 'v72' is possibly undefined
// 66714C: using guessed type void *off_66714C;
// 66CC90: using guessed type float *off_66CC90[6];
// 66CCB0: using guessed type float *off_66CCB0[6];
// 67630C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetHorz[2];
// 67699C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetVert;

//----- (0052EF7C) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::StartAnim(CTaskSimpleClimb *this, CPed *pPed)
{
  CTaskSimpleClimb *v2; // r4
  CPlayerPedData *m_pPlayerData; // r0
  CAnimBlendAssociation *v5; // r0
  int v6; // r3
  RpClump_0 *v7; // r0
  AnimationId v8; // r2
  CAnimBlendAssociation *m_pAnim; // r0
  RpClump_0 *m_pRwObject; // r0
  AnimationId v11; // r2
  int v12; // r3
  CAnimBlendAssociation *v13; // r0
  __int16 v14; // r0
  CAnimBlendAssociation *v15; // r0
  CAnimBlendAssociation *v16; // r0
  CAnimBlendAssociation *v17; // r0
  int v18; // s0
  CAnimBlendAssociation *v19; // r0
  CPlayerPedData *v20; // r0
  bool v21; // zf
  CAnimBlendAssociation *v22; // r0
  CAnimBlendAssociation *v23; // r0

  v2 = this;
  switch ( this->m_nHeightForAnim )
  {
    case 1:
      m_pAnim = this->m_pAnim;
      if ( m_pAnim )
      {
        CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
        m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
        v11 = ANIM_STD_CLIMB_IDLE;
        v12 = 1082130432;
      }
      else
      {
        m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
        v11 = ANIM_STD_CLIMB_GRAB;
        v12 = 1090519040;
      }
      v22 = CAnimManager::BlendAnimation(m_pRwObject, ANIM_STD_PED, v11, *(float *)&v12);
      v2->m_nHeightForPos = 1;
      v2->m_pAnim = v22;
      v14 = 0;
      goto LABEL_25;
    case 2:
      if ( this->m_nHeightForPos )
      {
        v13 = this->m_pAnim;
        if ( v13 )
          CAnimBlendAssociation::SetDeleteCallback(v13, CDefaultAnimCallback::DefaultAnimCB, 0);
        v2->m_pAnim = CAnimManager::BlendAnimation(
                        (RpClump_0 *)pPed->m_pRwObject,
                        ANIM_STD_PED,
                        ANIM_STD_CLIMB_PULLUP,
                        1000.0);
        v2->m_nHeightForPos = 2;
        v14 = 0;
      }
      else
      {
        *(_WORD *)&this->m_nHeightForAnim = 771;
        v23 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_CLIMB_STANDUP, 4.0);
        v2->m_pAnim = v23;
        v23->m_bitsFlag &= ~1u;
        v14 = 0;
      }
      goto LABEL_25;
    case 3:
      v15 = this->m_pAnim;
      if ( v15 )
        CAnimBlendAssociation::SetDeleteCallback(v15, CDefaultAnimCallback::DefaultAnimCB, 0);
      v6 = 1148846080;
      v7 = (RpClump_0 *)pPed->m_pRwObject;
      v8 = ANIM_STD_CLIMB_STANDUP;
      goto LABEL_24;
    case 4:
    case 6:
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
      CPed::SetMoveState(pPed, PEDMOVE_STILL);
      (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
      m_pPlayerData = pPed->m_pPlayerData;
      if ( m_pPlayerData )
        m_pPlayerData->m_moveBlendRatio = 0.0;
      v5 = v2->m_pAnim;
      if ( v5 )
        CAnimBlendAssociation::SetDeleteCallback(v5, CDefaultAnimCallback::DefaultAnimCB, 0);
      v6 = 1148846080;
      v7 = (RpClump_0 *)pPed->m_pRwObject;
      v8 = ANIM_STD_CLIMB_STANDFINISH;
      if ( v2->m_nHeightForAnim == 6 )
        v8 = ANIM_STD_CLIMB_VAULTFINISH;
      goto LABEL_24;
    case 5:
      v16 = this->m_pAnim;
      if ( v16
        && (CAnimBlendAssociation::SetDeleteCallback(v16, CDefaultAnimCallback::DefaultAnimCB, 0),
            (v17 = v2->m_pAnim) != 0)
        && v17->m_animId == 131 )
      {
        v18 = 16.0;
      }
      else
      {
        v18 = 1148846080;
      }
      v6 = v18;
      v7 = (RpClump_0 *)pPed->m_pRwObject;
      v8 = ANIM_STD_CLIMB_VAULTOVER;
LABEL_24:
      v2->m_pAnim = CAnimManager::BlendAnimation(v7, ANIM_STD_PED, v8, *(float *)&v6);
      v14 = 256;
LABEL_25:
      *(_WORD *)&v2->m_bChangeAnimation = v14;
      break;
    default:
      break;
  }
  v19 = v2->m_pAnim;
  if ( v19 )
  {
    CAnimBlendAssociation::SetDeleteCallback(v19, CTaskSimpleClimb::DeleteAnimClimbCB, v2);
    v20 = pPed->m_pPlayerData;
    v21 = v20 == 0;
    if ( v20 )
    {
      v2 = (CTaskSimpleClimb *)v2->m_pAnim;
      v21 = BYTE2(v2->m_pAnim) << 31 == 0;
    }
    if ( !v21 && (unsigned int)(SLOWORD(v2->m_pAnim) - 130) <= 3 && LOWORD(v2->m_pAnim) != 132 )
      *(float *)&v2->m_pClimbEnt = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_CLIMB_SPEED);
  }
}

//----- (0052F12C) --------------------------------------------------------
bool __fastcall CTaskSimpleClimb::TestForVault(
        CTaskSimpleClimb *this,
        CPed *pPed,
        CVector *vecHoldPos,
        float fHoldHeading)
{
  float v8; // s18
  __int64 v9; // d8
  float v10; // s20
  float v11; // r0
  CVector v14; // [sp+10h] [bp-50h] BYREF
  uint8 nSurfaceType; // [sp+1Fh] [bp-41h] BYREF
  CVector vecTargetPos; // [sp+20h] [bp-40h] BYREF
  float fGrabHeading[13]; // [sp+2Ch] [bp-34h] BYREF

  v8 = sinf(fHoldHeading);
  v9 = *(_QWORD *)&vecHoldPos->x;
  v10 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
  v11 = cosf(fHoldHeading);
  v14.z = CTaskSimpleClimb::ms_fAtEdgeOffsetVert + vecHoldPos->z;
  v14.x = *(float *)&v9 - (float)(v8 * v10);
  v14.y = *((float *)&v9 + 1) + (float)(v11 * v10);
  return (*(_BYTE *)&this->m_pClimbEnt->m_info & 7) != 2
      && CTaskSimpleClimb::ScanToGrab(pPed, &vecTargetPos, fGrabHeading, &nSurfaceType, 0, 0, 1u, &v14) == 0;
}
// 67630C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetHorz[2];
// 67699C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetVert;
// 52F12C: using guessed type float fGrabHeading[13];

//----- (0052F1F4) --------------------------------------------------------
bool __fastcall CTaskSimpleClimb::TestForStandUp(
        CTaskSimpleClimb *this,
        CPed *pPed,
        CVector *vecHoldPos,
        float fHoldHeading)
{
  float v7; // s18
  __int64 v8; // d8
  float v9; // s20
  float v10; // r0
  bool v11; // r5
  CVector v13; // [sp+10h] [bp-50h] BYREF
  uint8 nSurfaceType; // [sp+1Fh] [bp-41h] BYREF
  CVector vecTargetPos; // [sp+20h] [bp-40h] BYREF
  float fGrabHeading[13]; // [sp+2Ch] [bp-34h] BYREF

  v7 = sinf(fHoldHeading);
  v8 = *(_QWORD *)&vecHoldPos->x;
  v9 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
  v10 = cosf(fHoldHeading);
  v13.z = vecHoldPos->z;
  v11 = 0;
  v13.z = CTaskSimpleClimb::ms_fAtEdgeOffsetVert + v13.z;
  v13.x = *(float *)&v8 - (float)(v7 * v9);
  v13.y = *((float *)&v8 + 1) + (float)(v10 * v9);
  if ( !CTaskSimpleClimb::ScanToGrab(pPed, &vecTargetPos, fGrabHeading, &nSurfaceType, 0, 1u, 0, &v13) )
    return 1;
  return v11;
}
// 67630C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetHorz[2];
// 67699C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetVert;
// 52F1F4: using guessed type float fGrabHeading[13];

//----- (0052F2A4) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::DeleteAnimClimbCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_DWORD *)pData + 11) = 0;
}

//----- (0052F2AC) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::GetCameraTargetPos(CTaskSimpleClimb *this, CPed *pPed, CVector *vecTarget)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v7; // d16
  CAnimBlendAssociation *m_pAnim; // r0
  float v9; // s0
  float *v10; // r0
  float **v11; // r1
  float v12; // s2
  float **v13; // r0
  float **v14; // r1
  float **v15; // r2
  float **v16; // r3
  float v17; // s16
  float v18; // s18
  float v19; // s2
  __int64 v20; // d16
  float m_fHandholdHeading; // s20
  __int64 v22; // kr00_8
  const CMatrix *v23; // r1
  CEntity *m_pClimbEnt; // r0
  CMatrix *v25; // r1
  float m_heading; // s0
  float v27; // r5
  float v28; // s20
  float v29; // r0
  __int64 v30; // d16
  float z; // s4
  RwReal v32; // s0
  CVector v33; // [sp+0h] [bp-48h] BYREF
  CVector v; // [sp+10h] [bp-38h] BYREF

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v7 = *(_QWORD *)&p_tx->m_translate.x;
  vecTarget->z = p_tx->m_translate.z;
  *(_QWORD *)&vecTarget->x = v7;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    v9 = m_pAnim->m_fCurrentTime / m_pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
    switch ( m_pAnim->m_animId )
    {
      case 0x79:
      case 0x86:
        v10 = &CTaskSimpleClimb::ms_fVaultOffsetVert;
        v11 = &CTaskSimpleClimb::ms_fVaultOffsetHorz;
        goto LABEL_9;
      case 0x82:
        v12 = 1.0;
        v13 = &CTaskSimpleClimb::ms_fAtEdgeOffsetVert;
        v14 = CTaskSimpleClimb::ms_fHangingOffsetVert;
        v15 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
        v16 = &CTaskSimpleClimb::ms_fHangingOffsetHorz;
        goto LABEL_11;
      case 0x83:
        v12 = 1.0;
        v13 = &CTaskSimpleClimb::ms_fStandUpOffsetVert;
        v14 = &CTaskSimpleClimb::ms_fAtEdgeOffsetVert;
        v15 = &CTaskSimpleClimb::ms_fStandUpOffsetHorz;
        v16 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
        goto LABEL_11;
      case 0x84:
        v10 = (float *)&CTaskSimpleClimb::ms_fStandUpOffsetVert;
        v11 = &CTaskSimpleClimb::ms_fStandUpOffsetHorz;
LABEL_9:
        v17 = **(float **)v10;
        v18 = **v11;
        goto LABEL_12;
      case 0x85:
        v12 = 1.0;
        v13 = (float **)&CTaskSimpleClimb::ms_fVaultOffsetVert;
        v14 = &CTaskSimpleClimb::ms_fAtEdgeOffsetVert;
        v15 = &CTaskSimpleClimb::ms_fVaultOffsetHorz;
        v16 = CTaskSimpleClimb::ms_fAtEdgeOffsetHorz;
LABEL_11:
        v19 = v12 - v9;
        v17 = (float)(v9 * **v13) + (float)(v19 * **v14);
        v18 = (float)(v9 * **v15) + (float)(v19 * **v16);
LABEL_12:
        v20 = *(_QWORD *)&this->m_vecHandholdPos.x;
        m_fHandholdHeading = this->m_fHandholdHeading;
        v22 = *(_QWORD *)&this->m_vecHandholdPos.z;
        v.z = this->m_vecHandholdPos.z;
        *(_QWORD *)&v.x = v20;
        if ( (unsigned __int8)((*(_BYTE *)(HIDWORD(v22) + 58) & 7) - 2) <= 2u )
        {
          v23 = *(const CMatrix **)(HIDWORD(v22) + 20);
          if ( !v23 )
          {
            CPlaceable::AllocateMatrix((CPlaceable *)HIDWORD(v22));
            CSimpleTransform::UpdateMatrix(
              (const CSimpleTransform *)(HIDWORD(v22) + 4),
              *(CMatrix **)(HIDWORD(v22) + 20));
            v23 = *(const CMatrix **)(HIDWORD(v22) + 20);
          }
          operator*(&v33, v23, &v);
          v = v33;
          m_pClimbEnt = this->m_pClimbEnt;
          v25 = m_pClimbEnt->m_pMat;
          if ( v25 )
            m_heading = atan2f(COERCE_FLOAT(LODWORD(v25->xy) ^ 0x80000000), v25->yy);
          else
            m_heading = m_pClimbEnt->m_transform.m_heading;
          m_fHandholdHeading = m_fHandholdHeading + m_heading;
        }
        v27 = m_fHandholdHeading;
        v28 = sinf(m_fHandholdHeading);
        v29 = cosf(v27);
        v30 = *(_QWORD *)&v.x;
        vecTarget->z = v.z;
        z = vecTarget->z;
        *(_QWORD *)&vecTarget->x = v30;
        v32 = vecTarget->y + (float)(v18 * v29);
        vecTarget->x = vecTarget->x - (float)(v18 * v28);
        vecTarget->y = v32;
        vecTarget->z = v17 + z;
        break;
      default:
        return;
    }
  }
}
// 67630C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetHorz[2];
// 67663C: using guessed type float *CTaskSimpleClimb::ms_fStandUpOffsetHorz;
// 676708: using guessed type float *CTaskSimpleClimb::ms_fHangingOffsetVert[2];
// 67699C: using guessed type float *CTaskSimpleClimb::ms_fAtEdgeOffsetVert;
// 676AB4: using guessed type float CTaskSimpleClimb::ms_fVaultOffsetVert;
// 678134: using guessed type float *CTaskSimpleClimb::ms_fHangingOffsetHorz;
// 6783E0: using guessed type float *CTaskSimpleClimb::ms_fVaultOffsetHorz;
// 678ADC: using guessed type float *CTaskSimpleClimb::ms_fStandUpOffsetVert;

//----- (0052F4A4) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::GetCameraStickModifier(
        CTaskSimpleClimb *this,
        CPed *pPed,
        float *fAlpha,
        float *fBeta,
        float *fStickAlpha,
        float *fStickBeta)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d1
  float32x2_t v8; // d3
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r0
  int m_nFallAfterVault; // r0
  __int64 v15; // d16
  float m_fHandholdHeading; // s16
  __int64 v17; // kr00_8
  const CMatrix *v18; // r1
  CEntity *m_pClimbEnt; // r0
  CMatrix *m_pMat; // r1
  float m_heading; // s0
  CMatrix *v22; // r0
  float v23; // s0
  float v24; // s4
  float v25; // s0
  float v26; // s6
  int v27; // s6
  float v28; // s8
  float v29; // r6
  float x; // s16
  float y; // s18
  float v32; // s22
  RwReal v33; // s24
  float v34; // r8
  float *v35; // r1
  CEntity *refEntityPtr; // [sp+1Ch] [bp-7Ch] BYREF
  CColPoint v37; // [sp+20h] [bp-78h] BYREF
  CVector v; // [sp+50h] [bp-48h] BYREF

  m_pAnim = this->m_pAnim;
  if ( !m_pAnim )
    return;
  m_animId = (unsigned __int16)m_pAnim->m_animId;
  if ( m_animId != 129 )
  {
    if ( m_animId == 133 )
    {
      m_nFallAfterVault = this->m_nFallAfterVault;
      if ( m_nFallAfterVault <= -1 )
      {
        v15 = *(_QWORD *)&this->m_vecHandholdPos.x;
        m_fHandholdHeading = this->m_fHandholdHeading;
        v17 = *(_QWORD *)&this->m_vecHandholdPos.z;
        v.z = this->m_vecHandholdPos.z;
        *(_QWORD *)&v.x = v15;
        if ( (unsigned __int8)((*(_BYTE *)(HIDWORD(v17) + 58) & 7) - 2) <= 2u )
        {
          v18 = *(const CMatrix **)(HIDWORD(v17) + 20);
          if ( !v18 )
          {
            CPlaceable::AllocateMatrix((CPlaceable *)HIDWORD(v17));
            CSimpleTransform::UpdateMatrix(
              (const CSimpleTransform *)(HIDWORD(v17) + 4),
              *(CMatrix **)(HIDWORD(v17) + 20));
            v18 = *(const CMatrix **)(HIDWORD(v17) + 20);
          }
          operator*(&v37.m_vecPosition, v18, &v);
          v = v37.m_vecPosition;
          m_pClimbEnt = this->m_pClimbEnt;
          m_pMat = m_pClimbEnt->m_pMat;
          if ( m_pMat )
            m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
          else
            m_heading = m_pClimbEnt->m_transform.m_heading;
          m_fHandholdHeading = m_fHandholdHeading + m_heading;
        }
        v29 = m_fHandholdHeading;
        x = v.x;
        y = v.y;
        v32 = CTaskSimpleClimb::ms_fVaultOffsetHorz;
        v33 = CTaskSimpleClimb::ms_fVaultOffsetVert + v.z;
        v34 = sinf(v29);
        refEntityPtr = 0;
        v.y = y + (float)(cosf(v29) * v32);
        v.x = x - (float)(v34 * v32);
        v.z = v33;
        if ( CWorld::ProcessVerticalLine(&v, v33 + -3.0, &v37, &refEntityPtr, 1, 1, 0, 1, 0, 0, 0) )
        {
          v8.n64_u32[0] = 0;
          v6.n64_f32[0] = (float)(v.z - v37.m_vecPosition.z) + -1.0;
          v6.n64_u64[0] = vmax_f32(v6, v8).n64_u64[0];
          m_nFallAfterVault = (int)(float)(v6.n64_f32[0] * 10.0);
        }
        else
        {
          m_nFallAfterVault = 20;
        }
        this->m_nFallAfterVault = m_nFallAfterVault;
      }
      v35 = (float *)sub_52F744;
      v6.n64_f32[0] = *fAlpha;
      if ( m_nFallAfterVault > 8 )
        v35 = (float *)&dword_52F748;
      if ( v6.n64_f32[0] > *v35 )
      {
        v7.n64_u32[0] = -1119040307;
        v6.n64_f32[0] = (float)(v6.n64_f32[0] - *v35) * -0.05;
        *(_DWORD *)fStickAlpha = vmax_f32(v6, v7).n64_u32[0];
      }
    }
    return;
  }
  v22 = pPed->m_pMat;
  if ( v22 )
    v23 = atan2f(COERCE_FLOAT(LODWORD(v22->xy) ^ 0x80000000), v22->yy);
  else
    v23 = pPed->m_transform.m_heading;
  v24 = *fBeta;
  v25 = v23 + -1.5708;
  if ( v25 <= (float)(*fBeta + 3.1416) )
  {
    if ( v25 >= (float)(v24 + -3.1416) )
      goto LABEL_18;
    v26 = 6.2832;
  }
  else
  {
    v26 = -6.2832;
  }
  v25 = v25 + v26;
LABEL_18:
  if ( v25 > (float)((float)(v24 + 1.5708) + 0.2) )
  {
    v27 = 1017370378;
LABEL_24:
    *(_DWORD *)fStickBeta = v27;
    return;
  }
  v27 = 0;
  v28 = *fStickBeta;
  if ( v25 > (float)(v24 + 1.5708) && v28 < 0.0 )
    goto LABEL_24;
  if ( v25 < (float)((float)(v24 + -1.5708) + -0.2) )
  {
    v27 = -1130113270;
    goto LABEL_24;
  }
  if ( v25 < (float)(v24 + -1.5708) && v28 > 0.0 )
    *fStickBeta = 0.0;
}
// 52F6BC: variable 'v6' is possibly undefined
// 52F6BC: variable 'v8' is possibly undefined
// 52F6FA: variable 'v7' is possibly undefined
// 52F744: using guessed type int sub_52F744();
// 52F748: using guessed type int;

//----- (0052F750) --------------------------------------------------------
CEntity *__fastcall CTaskSimpleClimb::ScanToGrab(
        CPed *pPed,
        CVector *vecTargetPos,
        float *fGrabHeading,
        uint8 *nSurfaceType,
        int bLaunch,
        unsigned int bTestStandup,
        unsigned int bTestDropOtherSide,
        CVector *pAbsPos)
{
  CVector *v9; // r9
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r0
  CSimpleTransform *p_tx; // r2
  RwReal v13; // r2
  float v14; // r4
  RwReal v15; // r12
  float *p_tz; // r1
  __int64 v17; // d16
  CMatrix *v18; // r0
  RwReal v19; // s4
  RwReal v20; // s0
  float v21; // s16
  float m_fRadius; // s20
  float v23; // s18
  float v24; // r10
  float v25; // s0
  float v26; // s2
  float v27; // s20
  float v28; // s16
  float v29; // r0
  int v30; // s2
  int v31; // s16
  uint16 v32; // r0
  int v33; // r1
  CMatrix *v34; // r0
  RwReal *v35; // r0
  int v36; // r2
  int v37; // r6
  unsigned int v38; // r0
  int v39; // r0
  int v40; // r9
  int v41; // r0
  CEntity *v42; // r4
  CEntity *v43; // r1
  CEntity *result; // r0
  CMatrix *v46; // r0
  RwReal *p_z; // r0
  const CMatrix *v48; // r1
  __int64 v49; // d16
  CMatrix *v50; // r0
  float m_heading; // s0
  RwReal x; // [sp+1Ch] [bp-ECh]
  float y; // [sp+20h] [bp-E8h]
  RwReal z; // [sp+24h] [bp-E4h]
  int v55; // [sp+28h] [bp-E0h]
  int v56; // [sp+34h] [bp-D4h]
  CPlaceable *v57; // [sp+38h] [bp-D0h]
  int v58; // [sp+48h] [bp-C0h]
  int v59; // [sp+4Ch] [bp-BCh]
  CPed *v62; // [sp+58h] [bp-B0h]
  CMatrix v64; // [sp+60h] [bp-A8h] BYREF
  CVector v65; // [sp+A8h] [bp-60h] BYREF
  CVector v66; // [sp+B4h] [bp-54h] BYREF

  v9 = pAbsPos;
  if ( !CTaskSimpleClimb::ms_ClimbColModel.m_pColData )
    CTaskSimpleClimb::CreateColModel();
  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  if ( pAbsPos )
  {
    v13 = pAbsPos->x;
    v14 = pAbsPos->y;
    v15 = pAbsPos->z;
    if ( m_pMat )
    {
      m_pMat->tx = v13;
      pPed->m_pMat->ty = v14;
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      p_tz = &pPed->m_transform.m_translate.z;
      pPed->m_transform.m_translate.x = v13;
      pPed->m_transform.m_translate.y = v14;
    }
    *p_tz = v15;
    m_pMat = pPed->m_pMat;
  }
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  v17 = *(_QWORD *)&p_m_transform->m_translate.x;
  vecTargetPos->z = p_m_transform->m_translate.z;
  *(_QWORD *)&vecTargetPos->x = v17;
  v18 = pPed->m_pMat;
  v19 = (float)(v18->yy * 10.0) + vecTargetPos->y;
  v20 = (float)(v18->zy * 10.0) + vecTargetPos->z;
  vecTargetPos->x = (float)(v18->xy * 10.0) + vecTargetPos->x;
  vecTargetPos->y = v19;
  vecTargetPos->z = v20;
  operator*(&v66, pPed->m_pMat, &CTaskSimpleClimb::ms_ClimbColModel.m_sphereBound.m_vecCentre);
  v21 = v66.x;
  m_fRadius = CTaskSimpleClimb::ms_ClimbColModel.m_sphereBound.m_fRadius;
  v23 = v66.y;
  v24 = floorf((float)((float)(v66.x - CTaskSimpleClimb::ms_ClimbColModel.m_sphereBound.m_fRadius) / 50.0) + 60.0);
  v25 = m_fRadius + v23;
  v26 = v21 + m_fRadius;
  v27 = floorf((float)((float)(v23 - m_fRadius) / 50.0) + 60.0);
  v28 = floorf((float)(v25 / 50.0) + 60.0);
  v29 = floorf((float)(v26 / 50.0) + 60.0);
  v30 = (int)v28;
  v31 = (int)v29;
  v62 = pPed;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v32 = 1;
  }
  else
  {
    v32 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v32;
  v33 = (int)v27;
  v57 = 0;
  if ( (int)v27 <= v30 )
  {
    v36 = (int)v24;
    v37 = v31;
    v38 = (unsigned int)pAbsPos;
    if ( pAbsPos )
      v38 = 1;
    v56 = v38 & (bTestStandup | bTestDropOtherSide);
    while ( 1 )
    {
      v55 = v33;
      if ( v36 <= v37 )
        break;
LABEL_42:
      v9 = pAbsPos;
      v36 = (int)v24;
      v33 = v55 + 1;
      if ( v55 >= v30 )
        goto LABEL_16;
    }
    v39 = 0;
    if ( v33 > 0 )
      v39 = v33;
    v40 = v36;
    if ( v39 >= 119 )
      v39 = 119;
    v59 = 120 * v39;
    v58 = (unsigned __int8)(16 * v33);
    while ( 1 )
    {
      v41 = 0;
      if ( v40 > 0 )
        v41 = v40;
      if ( v41 >= 119 )
        v41 = 119;
      v42 = CTaskSimpleClimb::ScanToGrabSectorList(
              &CWorld::ms_aSectors[v41 + v59].m_buildingPtrListArray,
              v62,
              vecTargetPos,
              fGrabHeading,
              nSurfaceType,
              bLaunch,
              bTestStandup,
              bTestDropOtherSide);
      v43 = CTaskSimpleClimb::ScanToGrabSectorList(
              &CWorld::ms_aRepeatSectors[v40 & 0xF | v58].m_ptrListArray[2],
              v62,
              vecTargetPos,
              fGrabHeading,
              nSurfaceType,
              bLaunch,
              bTestStandup,
              bTestDropOtherSide);
      if ( !v43 )
        v43 = CTaskSimpleClimb::ScanToGrabSectorList(
                (CPtrList *)&CWorld::ms_aRepeatSectors[v40 & 0xF | v58],
                v62,
                vecTargetPos,
                fGrabHeading,
                nSurfaceType,
                bLaunch,
                bTestStandup,
                bTestDropOtherSide);
      result = 0;
      if ( v42 == (CEntity *)((char *)&dword_0 + 1) )
        break;
      v37 = v31;
      if ( v43 == (CEntity *)((char *)&dword_0 + 1) )
        break;
      if ( v43 )
        v42 = v43;
      if ( v42 )
      {
        if ( v56 == 1 )
        {
          v46 = v62->m_pMat;
          if ( v46 )
          {
            v46->tx = x;
            v62->m_pMat->ty = y;
            p_z = &v62->m_pMat->tz;
          }
          else
          {
            v62->m_transform.m_translate.x = x;
            v62->m_transform.m_translate.y = y;
            p_z = &v62->m_transform.m_translate.z;
          }
          *p_z = z;
          return v42;
        }
        v57 = v42;
        result = v42;
        if ( __PAIR64__(bTestDropOtherSide, bTestStandup) )
          return result;
      }
      if ( v40++ >= v31 )
        goto LABEL_42;
    }
  }
  else
  {
LABEL_16:
    if ( v9 )
    {
      v34 = v62->m_pMat;
      if ( v34 )
      {
        v34->tx = x;
        v62->m_pMat->ty = y;
        v35 = &v62->m_pMat->tz;
      }
      else
      {
        v62->m_transform.m_translate.x = x;
        v62->m_transform.m_translate.y = y;
        v35 = &v62->m_transform.m_translate.z;
      }
      *v35 = z;
    }
    if ( v57 )
    {
      if ( (unsigned __int8)((BYTE2(v57[2].m_transform.m_translate.y) & 7) - 2) <= 2u )
      {
        v48 = v57->m_pMat;
        if ( !v48 )
        {
          CPlaceable::AllocateMatrix(v57);
          CSimpleTransform::UpdateMatrix(&v57->m_transform, v57->m_pMat);
          v48 = v57->m_pMat;
        }
        Invert(&v64, v48);
        operator*(&v65, &v64, vecTargetPos);
        v49 = *(_QWORD *)&v65.x;
        vecTargetPos->z = v65.z;
        *(_QWORD *)&vecTargetPos->x = v49;
        CMatrix::~CMatrix(&v64);
        v50 = v57->m_pMat;
        if ( v50 )
          m_heading = atan2f(COERCE_FLOAT(LODWORD(v50->xy) ^ 0x80000000), v50->yy);
        else
          m_heading = v57->m_transform.m_heading;
        *fGrabHeading = *fGrabHeading - m_heading;
      }
      return (CEntity *)v57;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0052FB3C) --------------------------------------------------------
int CTaskSimpleClimb::CreateColModel()
{
  CCollisionData *m_pColData; // r4
  CColSphere *m_pSphereArray; // r0
  CColSphere *v2; // r0
  CColSphere *v3; // r0
  CColSphere *v4; // r0
  CColSphere *v5; // r0
  CColSphere *v6; // r0
  CColSphere *v7; // r0
  CColSphere *v8; // r0
  CColSphere *v9; // r0
  CColSphere *v10; // r0
  CColSphere *v11; // r0
  CColSphere *v12; // r0
  CColSphere *v13; // r0
  CColSphere *v14; // r0
  CColSphere *v15; // r0
  CColSphere *v16; // r0
  CColSphere *v17; // r0
  CColSphere *v18; // r0
  CColSphere *v19; // r0
  CColSphere *v20; // r0
  CColSphere *v21; // r0
  CColSphere *v22; // r0
  CCollisionData *v23; // r6
  CColSphere *v24; // r0
  CColSphere *v25; // r0
  CColSphere *v26; // r0
  CColSphere *v27; // r0
  CColSphere *v28; // r0
  CColSphere *v29; // r0
  CColSphere *v30; // r0
  CCollisionData *v31; // r8
  CColSphere *v32; // r0
  CColSphere *v33; // r0
  CColSphere *v34; // r0
  CColSphere *v35; // r0
  CColSphere *v36; // r0
  CColSphere *v37; // r0
  CCollisionData *v38; // r4
  CColSphere *v39; // r0
  CColSphere *v40; // r0
  CColSphere *v41; // r0
  CColSphere *v42; // r0
  CColSphere *v43; // r0
  CColSphere *v44; // r0
  CColSphere *v45; // r0
  CColSphere *v46; // r0
  CColSphere *v47; // r0
  CColSphere *v48; // r0
  CColSphere *v49; // r0
  CColSphere *v50; // r0
  CColSphere *v51; // r0
  CColSphere *v52; // r0
  CColSphere *v53; // r0
  CColSphere *v54; // r0
  CVector vecMax; // [sp+14h] [bp-34h] BYREF
  CVector vecCentre; // [sp+20h] [bp-28h] BYREF

  CColModel::AllocateData(&CTaskSimpleClimb::ms_ClimbColModel, 22, 0, 0, 0, 0, 0);
  m_pColData = CTaskSimpleClimb::ms_ClimbColModel.m_pColData;
  m_pSphereArray = CTaskSimpleClimb::ms_ClimbColModel.m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.06;
  vecCentre.z = 1.2;
  CColSphere::Set(m_pSphereArray, 0.4, &vecCentre, 0, 0, 0xFFu);
  v2 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.06;
  vecCentre.z = 1.7;
  CColSphere::Set(v2 + 1, 0.4, &vecCentre, 1u, 1u, 0xFFu);
  v3 = m_pColData->m_pSphereArray;
  vecCentre.z = 2.2;
  vecCentre.x = 0.0;
  vecCentre.y = -0.06;
  CColSphere::Set(v3 + 2, 0.4, &vecCentre, 2u, 2u, 0xFFu);
  v4 = m_pColData->m_pSphereArray;
  vecCentre.y = -0.06;
  vecCentre.z = 2.5;
  vecCentre.x = 0.0;
  CColSphere::Set(v4 + 3, 0.4, &vecCentre, 3u, 3u, 0xFFu);
  v5 = m_pColData->m_pSphereArray;
  vecCentre.y = 0.5;
  vecCentre.x = 0.0;
  vecCentre.z = 2.9;
  CColSphere::Set(v5 + 4, 0.4, &vecCentre, 4u, 4u, 0xFFu);
  v6 = m_pColData->m_pSphereArray;
  vecCentre.y = 0.5;
  vecCentre.x = 0.0;
  vecCentre.z = 2.4;
  CColSphere::Set(v6 + 5, 0.4, &vecCentre, 5u, 5u, 0xFFu);
  v7 = m_pColData->m_pSphereArray;
  vecCentre.y = 0.5;
  vecCentre.x = 0.0;
  vecCentre.z = 1.9;
  CColSphere::Set(v7 + 6, 0.4, &vecCentre, 6u, 6u, 0xFFu);
  v8 = m_pColData->m_pSphereArray;
  vecCentre.y = 0.5;
  vecCentre.x = 0.0;
  vecCentre.z = 1.4;
  CColSphere::Set(v8 + 7, 0.4, &vecCentre, 7u, 7u, 0xFFu);
  v9 = m_pColData->m_pSphereArray + 8;
  vecCentre.y = 0.5;
  vecCentre.x = 0.0;
  vecCentre.z = 0.9;
  CColSphere::Set(v9, 0.4, &vecCentre, 8u, 8u, 0xFFu);
  v10 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.5;
  vecCentre.z = 0.4;
  CColSphere::Set(v10 + 9, 0.4, &vecCentre, 9u, 9u, 0xFFu);
  v11 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.0;
  vecCentre.z = 2.9;
  CColSphere::Set(v11 + 10, 0.4, &vecCentre, 0xAu, 0xAu, 0xFFu);
  v12 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.0;
  vecCentre.z = 2.4;
  CColSphere::Set(v12 + 11, 0.4, &vecCentre, 0xBu, 0xBu, 0xFFu);
  v13 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.0;
  vecCentre.z = 1.9;
  CColSphere::Set(v13 + 12, 0.4, &vecCentre, 0xCu, 0xCu, 0xFFu);
  v14 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.0;
  vecCentre.z = 1.4;
  CColSphere::Set(v14 + 13, 0.4, &vecCentre, 0xDu, 0xDu, 0xFFu);
  v15 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.0;
  vecCentre.z = 0.9;
  CColSphere::Set(v15 + 14, 0.4, &vecCentre, 0xEu, 0xEu, 0xFFu);
  v16 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.0;
  vecCentre.z = 0.4;
  CColSphere::Set(v16 + 15, 0.4, &vecCentre, 0xFu, 0xFu, 0xFFu);
  v17 = m_pColData->m_pSphereArray;
  vecCentre.z = 2.9;
  vecCentre.x = 0.0;
  vecCentre.y = 1.5;
  CColSphere::Set(v17 + 16, 0.4, &vecCentre, 0x10u, 0x10u, 0xFFu);
  v18 = m_pColData->m_pSphereArray;
  vecCentre.z = 2.4;
  vecCentre.x = 0.0;
  vecCentre.y = 1.5;
  CColSphere::Set(v18 + 17, 0.4, &vecCentre, 0x11u, 0x11u, 0xFFu);
  v19 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.5;
  vecCentre.z = 1.9;
  CColSphere::Set(v19 + 18, 0.4, &vecCentre, 0x12u, 0x12u, 0xFFu);
  v20 = m_pColData->m_pSphereArray;
  vecCentre.z = 1.4;
  vecCentre.x = 0.0;
  vecCentre.y = 1.5;
  CColSphere::Set(v20 + 19, 0.4, &vecCentre, 0x13u, 0x13u, 0xFFu);
  v21 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.5;
  vecCentre.z = 0.9;
  CColSphere::Set(v21 + 20, 0.4, &vecCentre, 0x14u, 0x14u, 0xFFu);
  v22 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.5;
  vecCentre.z = 0.4;
  CColSphere::Set(v22 + 21, 0.4, &vecCentre, 0x15u, 0x15u, 0xFFu);
  vecCentre.y = 0.75;
  vecCentre.z = 1.65;
  vecCentre.x = 0.0;
  CSphere::Set(&CTaskSimpleClimb::ms_ClimbColModel.m_sphereBound, 2.02, &vecCentre);
  vecCentre.y = -0.46;
  vecCentre.x = -0.4;
  vecCentre.z = 0.0;
  vecMax.y = 1.9;
  vecMax.z = 3.3;
  vecMax.x = 0.4;
  CBox::Set(&CTaskSimpleClimb::ms_ClimbColModel.m_boxBound, &vecCentre, &vecMax);
  CTaskSimpleClimb::ms_ClimbColModel.m_level = 0;
  CColModel::AllocateData(&CTaskSimpleClimb::ms_StandupColModel, 7, 0, 0, 0, 0, 0);
  v23 = CTaskSimpleClimb::ms_StandupColModel.m_pColData;
  v24 = CTaskSimpleClimb::ms_StandupColModel.m_pColData->m_pSphereArray;
  vecCentre.z = 1.75;
  vecCentre.x = 0.0;
  vecCentre.y = 0.6;
  CColSphere::Set(v24, 0.35, &vecCentre, 0, 0, 0xFFu);
  v25 = v23->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.6;
  vecCentre.z = 1.3;
  CColSphere::Set(v25 + 1, 0.35, &vecCentre, 1u, 1u, 0xFFu);
  v26 = v23->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.6;
  vecCentre.z = 0.85;
  CColSphere::Set(v26 + 2, 0.35, &vecCentre, 2u, 2u, 0xFFu);
  v27 = v23->m_pSphereArray;
  vecCentre.z = 0.65;
  vecCentre.x = 0.0;
  vecCentre.y = 0.3;
  CColSphere::Set(v27 + 3, 0.35, &vecCentre, 3u, 3u, 0xFFu);
  v28 = v23->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = 0.5;
  CColSphere::Set(v28 + 4, 0.35, &vecCentre, 4u, 4u, 0xFFu);
  v29 = v23->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = 0.1;
  CColSphere::Set(v29 + 5, 0.35, &vecCentre, 5u, 5u, 0xFFu);
  v30 = v23->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = -0.3;
  CColSphere::Set(v30 + 6, 0.35, &vecCentre, 6u, 6u, 0xFFu);
  vecCentre.x = 0.0;
  vecCentre.y = 0.3;
  vecCentre.z = 0.7;
  CSphere::Set(&CTaskSimpleClimb::ms_StandupColModel.m_sphereBound, 1.5, &vecCentre);
  vecCentre.z = -0.65;
  vecCentre.x = -0.35;
  vecCentre.y = -0.35;
  vecMax.y = 0.95;
  vecMax.z = 2.1;
  vecMax.x = 0.35;
  CBox::Set(&CTaskSimpleClimb::ms_StandupColModel.m_boxBound, &vecCentre, &vecMax);
  CTaskSimpleClimb::ms_StandupColModel.m_level = 0;
  CColModel::AllocateData(&CTaskSimpleClimb::ms_VaultColModel, 6, 0, 0, 0, 0, 0);
  v31 = CTaskSimpleClimb::ms_VaultColModel.m_pColData;
  v32 = CTaskSimpleClimb::ms_VaultColModel.m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.1;
  vecCentre.z = -0.2;
  CColSphere::Set(v32, 0.3, &vecCentre, 0, 0, 0xFFu);
  v33 = v31->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.1;
  vecCentre.z = 0.2;
  CColSphere::Set(v33 + 1, 0.3, &vecCentre, 1u, 1u, 0xFFu);
  v34 = v31->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 1.1;
  vecCentre.z = 0.6;
  CColSphere::Set(v34 + 2, 0.3, &vecCentre, 2u, 2u, 0xFFu);
  v35 = v31->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.7;
  vecCentre.z = 0.6;
  CColSphere::Set(v35 + 3, 0.3, &vecCentre, 3u, 3u, 0xFFu);
  v36 = v31->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.35;
  vecCentre.z = 0.6;
  CColSphere::Set(v36 + 4, 0.3, &vecCentre, 4u, 4u, 0xFFu);
  v37 = v31->m_pSphereArray;
  vecCentre.z = 0.6;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  CColSphere::Set(v37 + 5, 0.3, &vecCentre, 5u, 5u, 0xFFu);
  vecCentre.x = 0.0;
  vecCentre.y = 0.5;
  vecCentre.z = 0.1;
  CSphere::Set(&CTaskSimpleClimb::ms_VaultColModel.m_sphereBound, 1.15, &vecCentre);
  vecCentre.x = -0.35;
  vecCentre.y = -0.35;
  vecCentre.z = -0.6;
  vecMax.x = 0.35;
  vecMax.y = 1.3;
  vecMax.z = 0.85;
  CBox::Set(&CTaskSimpleClimb::ms_VaultColModel.m_boxBound, &vecCentre, &vecMax);
  CTaskSimpleClimb::ms_VaultColModel.m_level = 0;
  CColModel::AllocateData(&CTaskSimpleClimb::ms_FindEdgeColModel, 16, 0, 0, 0, 0, 0);
  v38 = CTaskSimpleClimb::ms_FindEdgeColModel.m_pColData;
  v39 = CTaskSimpleClimb::ms_FindEdgeColModel.m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.5;
  vecCentre.z = 0.5;
  CColSphere::Set(v39, 0.3, &vecCentre, 0, 0, 0xFFu);
  v40 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.5;
  vecCentre.z = 0.3;
  CColSphere::Set(v40 + 1, 0.3, &vecCentre, 1u, 1u, 0xFFu);
  v41 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.5;
  vecCentre.z = 0.1;
  CColSphere::Set(v41 + 2, 0.3, &vecCentre, 2u, 2u, 0xFFu);
  v42 = v38->m_pSphereArray + 3;
  vecCentre.x = 0.0;
  vecCentre.y = -0.5;
  vecCentre.z = -0.1;
  CColSphere::Set(v42, 0.3, &vecCentre, 3u, 3u, 0xFFu);
  v43 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.3;
  vecCentre.z = 0.5;
  CColSphere::Set(v43 + 4, 0.3, &vecCentre, 4u, 4u, 0xFFu);
  v44 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.3;
  vecCentre.z = 0.3;
  CColSphere::Set(v44 + 5, 0.3, &vecCentre, 5u, 5u, 0xFFu);
  v45 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.3;
  vecCentre.z = 0.1;
  CColSphere::Set(v45 + 6, 0.3, &vecCentre, 6u, 6u, 0xFFu);
  v46 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.3;
  vecCentre.z = -0.1;
  CColSphere::Set(v46 + 7, 0.3, &vecCentre, 7u, 7u, 0xFFu);
  v47 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.1;
  vecCentre.z = 0.5;
  CColSphere::Set(v47 + 8, 0.3, &vecCentre, 8u, 8u, 0xFFu);
  v48 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.1;
  vecCentre.z = 0.3;
  CColSphere::Set(v48 + 9, 0.3, &vecCentre, 9u, 9u, 0xFFu);
  v49 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.1;
  vecCentre.z = 0.1;
  CColSphere::Set(v49 + 10, 0.3, &vecCentre, 0xAu, 0xAu, 0xFFu);
  v50 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.1;
  vecCentre.z = -0.1;
  CColSphere::Set(v50 + 11, 0.3, &vecCentre, 0xBu, 0xBu, 0xFFu);
  v51 = v38->m_pSphereArray;
  vecCentre.z = 0.5;
  vecCentre.x = 0.0;
  vecCentre.y = 0.1;
  CColSphere::Set(v51 + 12, 0.3, &vecCentre, 0xCu, 0xCu, 0xFFu);
  v52 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.1;
  vecCentre.z = 0.3;
  CColSphere::Set(v52 + 13, 0.3, &vecCentre, 0xDu, 0xDu, 0xFFu);
  v53 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.1;
  vecCentre.z = 0.1;
  CColSphere::Set(v53 + 14, 0.3, &vecCentre, 0xEu, 0xEu, 0xFFu);
  v54 = v38->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.1;
  vecCentre.z = -0.1;
  CColSphere::Set(v54 + 15, 0.3, &vecCentre, 0xFu, 0xFu, 0xFFu);
  vecCentre.y = -0.2;
  vecCentre.z = 0.2;
  vecCentre.x = 0.0;
  CSphere::Set(&CTaskSimpleClimb::ms_FindEdgeColModel.m_sphereBound, 0.9, &vecCentre);
  vecCentre.y = -0.8;
  vecCentre.x = -0.3;
  vecCentre.z = -0.4;
  vecMax.x = 0.3;
  vecMax.y = 0.4;
  vecMax.z = 0.8;
  CBox::Set(&CTaskSimpleClimb::ms_FindEdgeColModel.m_boxBound, &vecCentre, &vecMax);
  CTaskSimpleClimb::ms_FindEdgeColModel.m_level = 0;
  return 1;
}

//----- (005303FC) --------------------------------------------------------
CEntity *__fastcall CTaskSimpleClimb::ScanToGrabSectorList(
        CPtrList *list,
        CPed *pPed,
        CVector *vecTargetPos,
        float *fGrabHeading,
        uint8 *nSurfaceType,
        int bLaunch,
        unsigned int bTestStandup,
        unsigned int bTestDropOtherSide)
{
  char v10; // r0
  CPed *v11; // r5
  int FatAndMuscleModifier; // r4
  CColModel *v13; // r6
  CPtrNode *m_pHead; // r8
  int v15; // r1
  float32x2_t v16; // d8
  float x; // s18
  float m_fRadius; // s20
  int CanClimb; // r0
  unsigned int m_nPieceType; // r1
  bool v21; // zf
  float v22; // s0
  float y; // s2
  float v24; // s4
  __int64 v25; // d16
  float m_fCurrentHeading; // r0
  const CMatrix *v27; // r1
  float *p_x; // r0
  __int64 v29; // d16
  const CMatrix *v30; // r4
  CColModel *v31; // r0
  float v32; // s0
  float v33; // s2
  float v34; // s4
  __int64 v35; // d16
  float *p_xx; // r0
  float *v37; // r1
  __int64 v38; // d16
  CPtrNode v39; // kr00_8
  int v40; // r1
  int v41; // r0
  int v42; // r2
  int v43; // r0
  float32x2_t v44; // d16
  unsigned __int64 v45; // d1
  const CMatrix *v46; // r10
  const CMatrix *m_pMat; // r4
  CColModel *ColModel; // r0
  float z; // s0
  unsigned __int64 v50; // d2
  int v52; // [sp+48h] [bp-A8h]
  int v53; // [sp+4Ch] [bp-A4h]
  CTaskSimpleSwim *TaskSwim; // [sp+64h] [bp-8Ch]
  int m_pVoid; // [sp+6Ch] [bp-84h]
  int16 m_nNoOfSpheres; // [sp+80h] [bp-70h]
  CVector v59; // [sp+84h] [bp-6Ch] BYREF

  v10 = `guard variable for'CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge;
  __dmb(0xBu);
  if ( (v10 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge) )
  {
    CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge.m_pRwMat = 0;
    CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge.m_owner = 0;
    _cxa_atexit(
      (void (__fastcall *)(void *))CMatrix::~CMatrix,
      &CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge,
      &_dso_handle);
    _cxa_guard_release((__guard *)&`guard variable for'CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge);
  }
  TaskSwim = CPedIntelligence::GetTaskSwim(pPed->m_pPedIntelligence);
  if ( pPed->m_pPlayerData )
  {
    v11 = pPed;
    if ( CPedIntelligence::GetTaskSwim(pPed->m_pPedIntelligence) )
      FatAndMuscleModifier = 0;
    else
      FatAndMuscleModifier = (int)CStats::GetFatAndMuscleModifier(STAT_MODIFIER_CLIMB_HEIGHT);
  }
  else
  {
    v11 = pPed;
    FatAndMuscleModifier = 0;
  }
  v13 = &CTaskSimpleClimb::ms_ClimbColModel;
  if ( bTestDropOtherSide )
    v13 = &CTaskSimpleClimb::ms_VaultColModel;
  if ( bTestStandup )
    v13 = &CTaskSimpleClimb::ms_StandupColModel;
  operator*(&v59, v11->m_pMat, &v13->m_sphereBound.m_vecCentre);
  m_pHead = list->m_pHead;
  if ( !m_pHead )
    return 0;
  v15 = 0;
  v16.n64_u64[0] = *(unsigned __int64 *)&v59.y;
  x = v59.x;
  m_fRadius = v13->m_sphereBound.m_fRadius;
  if ( FatAndMuscleModifier < 1 )
    v15 = 1;
  if ( FatAndMuscleModifier != 1 )
    FatAndMuscleModifier = 0;
  v53 = bLaunch & v15;
  v52 = FatAndMuscleModifier & bLaunch | v15;
  m_pVoid = 0;
  while ( 1 )
  {
    v39 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v39.m_pVoid + 24) == CWorld::ms_nCurrentScanCode )
      goto LABEL_93;
    v40 = *((_DWORD *)v39.m_pVoid + 7);
    *((_WORD *)v39.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
    if ( (v40 & 1) == 0 )
      goto LABEL_93;
    v41 = *((_BYTE *)v39.m_pVoid + 58) & 7;
    if ( v41 != 1 )
    {
      if ( v41 != 4 || (v42 = *((_DWORD *)v39.m_pVoid + 17), !(v40 & 0x40004 | v42 & 4)) || (v42 & 0x40) != 0 )
      {
        if ( v41 != 2 )
          goto LABEL_93;
        if ( !__PAIR64__(bTestDropOtherSide, bTestStandup) )
        {
          v43 = *((_DWORD *)v39.m_pVoid + 361);
          if ( (!TaskSwim || v43 != 5)
            && (v43 != 6
             || sqrtf(
                  (float)((float)(*((float *)v39.m_pVoid + 18) * *((float *)v39.m_pVoid + 18))
                        + (float)(*((float *)v39.m_pVoid + 19) * *((float *)v39.m_pVoid + 19)))
                + (float)(*((float *)v39.m_pVoid + 20) * *((float *)v39.m_pVoid + 20))) >= 0.1) )
          {
            goto LABEL_93;
          }
        }
      }
    }
    CEntity::GetBoundCentre(&v59, (const CEntity *)v39.m_pVoid);
    v44.n64_u64[0] = vsub_f32(v16, *(float32x2_t *)&v59.y).n64_u64[0];
    v45 = vmul_f32(v44, v44).n64_u64[0];
    if ( sqrtf((float)((float)((float)(x - v59.x) * (float)(x - v59.x)) + *(float *)&v45) + *((float *)&v45 + 1)) >= (float)(m_fRadius + CModelInfo::ms_modelInfoPtrs[*((__int16 *)v39.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius) )
      goto LABEL_93;
    if ( (*((_BYTE *)v39.m_pVoid + 58) & 7) == 2 )
    {
      m_nNoOfSpheres = -1;
      if ( *((_DWORD *)v39.m_pVoid + 361) == 5 )
      {
        m_nNoOfSpheres = CEntity::GetColModel((CEntity *)v39.m_pVoid)->m_pColData->m_nNoOfSpheres;
        CEntity::GetColModel((CEntity *)v39.m_pVoid)->m_pColData->m_nNoOfSpheres = 0;
      }
    }
    else
    {
      m_nNoOfSpheres = -1;
    }
    v46 = (const CMatrix *)*((_DWORD *)v39.m_pVoid + 5);
    m_pMat = v11->m_pMat;
    if ( !v46 )
    {
      CPlaceable::AllocateMatrix((CPlaceable *)v39.m_pVoid);
      CSimpleTransform::UpdateMatrix(
        (const CSimpleTransform *)((char *)v39.m_pVoid + 4),
        *((CMatrix **)v39.m_pVoid + 5));
      v46 = (const CMatrix *)*((_DWORD *)v39.m_pVoid + 5);
    }
    ColModel = CEntity::GetColModel((CEntity *)v39.m_pVoid);
    if ( CCollision::ProcessColModels(m_pMat, v13, v46, ColModel, CWorld::m_aTempColPts, 0, 0, 0) < 1 )
      goto LABEL_90;
    if ( (bTestStandup | bTestDropOtherSide) == 1 )
      break;
    m_nPieceType = CWorld::m_aTempColPts[0].m_dataA.m_nPieceType;
    if ( (unsigned int)CWorld::m_aTempColPts[0].m_dataA.m_nPieceType - 2 < 2 )
      goto LABEL_88;
    if ( CWorld::m_aTempColPts[0].m_dataA.m_nPieceType < 2u )
      goto LABEL_95;
    z = vecTargetPos->z;
    if ( CWorld::m_aTempColPts[0].m_vecPosition.z <= z )
    {
      v50 = vmul_f32(
              vsub_f32(*(float32x2_t *)&CWorld::m_aTempColPts[0].m_vecPosition.x, *(float32x2_t *)&vecTargetPos->x),
              *(float32x2_t *)&v11->m_pMat->xy).n64_u64[0];
      if ( (float)((float)(*(float *)&v50 + *((float *)&v50 + 1))
                 + (float)((float)(CWorld::m_aTempColPts[0].m_vecPosition.z - z) * v11->m_pMat->zy)) >= 0.0 )
        goto LABEL_88;
    }
    CanClimb = SurfaceInfos_c::CanClimb(&g_surfaceInfos, CWorld::m_aTempColPts[0].m_dataB.m_nSurfaceType);
    m_nPieceType = CWorld::m_aTempColPts[0].m_dataA.m_nPieceType;
    if ( !CanClimb )
    {
      if ( CWorld::m_aTempColPts[0].m_dataA.m_nPieceType <= 0xAu )
        goto LABEL_89;
      goto LABEL_90;
    }
    if ( CWorld::m_aTempColPts[0].m_dataA.m_nPieceType == 16 )
      goto LABEL_90;
    v21 = CWorld::m_aTempColPts[0].m_dataA.m_nPieceType == 4;
    if ( CWorld::m_aTempColPts[0].m_dataA.m_nPieceType != 4 )
      v21 = CWorld::m_aTempColPts[0].m_dataA.m_nPieceType == 10;
    if ( v21 )
    {
LABEL_95:
      if ( m_nNoOfSpheres > -1 )
      {
        m_pVoid = 1;
        if ( (*((_BYTE *)v39.m_pVoid + 58) & 7) != 2 )
          return (CEntity *)m_pVoid;
        CEntity::GetColModel((CEntity *)v39.m_pVoid)->m_pColData->m_nNoOfSpheres = m_nNoOfSpheres;
      }
      return (CEntity *)(&dword_0 + 1);
    }
    if ( !v53
      && CWorld::m_aTempColPts[0].m_dataA.m_nPieceType <= 0x11u
      && ((1 << CWorld::m_aTempColPts[0].m_dataA.m_nPieceType) & (unsigned int)&elf_hash_chain[16814]) != 0 )
    {
LABEL_88:
      if ( m_nPieceType <= 0xA )
      {
LABEL_89:
        if ( ((1 << m_nPieceType) & 0x41F) != 0 )
          goto LABEL_95;
      }
    }
    else if ( v52
           || CWorld::m_aTempColPts[0].m_dataA.m_nPieceType > 0x12u
           || ((1 << CWorld::m_aTempColPts[0].m_dataA.m_nPieceType) & (unsigned int)&stru_4103C.st_value) == 0 )
    {
      v22 = CWorld::m_aTempColPts[0].m_vecNormal.x;
      y = CWorld::m_aTempColPts[0].m_vecNormal.y;
      v24 = CWorld::m_aTempColPts[0].m_vecNormal.z;
      if ( CWorld::m_aTempColPts[0].m_vecNormal.x <= 0.05
        && CWorld::m_aTempColPts[0].m_vecNormal.x >= -0.05
        && CWorld::m_aTempColPts[0].m_vecNormal.y <= 0.05
        && CWorld::m_aTempColPts[0].m_vecNormal.y >= -0.05 )
      {
        v25 = *(_QWORD *)&CWorld::m_aTempColPts[0].m_vecPosition.x;
        vecTargetPos->z = CWorld::m_aTempColPts[0].m_vecPosition.z;
        *(_QWORD *)&vecTargetPos->x = v25;
        m_fCurrentHeading = v11->m_fCurrentHeading;
        goto LABEL_49;
      }
      v27 = v11->m_pMat;
      p_x = &v11->m_transform.m_translate.x;
      if ( v27 )
        p_x = &v27->tx;
      if ( (float)((float)(CWorld::m_aTempColPts[0].m_vecNormal.z * 0.0)
                 + (float)((float)(CWorld::m_aTempColPts[0].m_vecNormal.x
                                 * (float)(CWorld::m_aTempColPts[0].m_vecPosition.x - *p_x))
                         + (float)(CWorld::m_aTempColPts[0].m_vecNormal.y
                                 * (float)(CWorld::m_aTempColPts[0].m_vecPosition.y - p_x[1])))) < 0.0 )
      {
        v24 = -CWorld::m_aTempColPts[0].m_vecNormal.z;
        y = -CWorld::m_aTempColPts[0].m_vecNormal.y;
        v22 = -CWorld::m_aTempColPts[0].m_vecNormal.x;
      }
      if ( (float)((float)((float)(v22 * v27->xy) + (float)(y * v27->yy)) + (float)(v24 * v27->zy)) > 0.3 )
      {
        v29 = *(_QWORD *)&CWorld::m_aTempColPts[0].m_vecPosition.x;
        vecTargetPos->z = CWorld::m_aTempColPts[0].m_vecPosition.z;
        *(_QWORD *)&vecTargetPos->x = v29;
        m_fCurrentHeading = atan2f(COERCE_FLOAT(LODWORD(v22) ^ 0x80000000), y);
LABEL_49:
        *fGrabHeading = m_fCurrentHeading;
        *nSurfaceType = CWorld::m_aTempColPts[0].m_dataB.m_nSurfaceType;
        v27 = v11->m_pMat;
        m_pVoid = (int)v39.m_pVoid;
      }
      CMatrix::operator=(
        &CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge,
        v27);
      CMatrix::SetTranslateOnly(
        &CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge,
        CWorld::m_aTempColPts[0].m_vecPosition.x,
        CWorld::m_aTempColPts[0].m_vecPosition.y,
        CWorld::m_aTempColPts[0].m_vecPosition.z);
      v30 = (const CMatrix *)*((_DWORD *)v39.m_pVoid + 5);
      if ( !v30 )
      {
        CPlaceable::AllocateMatrix((CPlaceable *)v39.m_pVoid);
        CSimpleTransform::UpdateMatrix(
          (const CSimpleTransform *)((char *)v39.m_pVoid + 4),
          *((CMatrix **)v39.m_pVoid + 5));
        v30 = (const CMatrix *)*((_DWORD *)v39.m_pVoid + 5);
      }
      v31 = CEntity::GetColModel((CEntity *)v39.m_pVoid);
      if ( CCollision::ProcessColModels(
             &CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge,
             &CTaskSimpleClimb::ms_FindEdgeColModel,
             v30,
             v31,
             CWorld::m_aTempColPts,
             0,
             0,
             0) >= 1 )
      {
        v32 = CWorld::m_aTempColPts[0].m_vecNormal.x;
        v33 = CWorld::m_aTempColPts[0].m_vecNormal.y;
        v34 = CWorld::m_aTempColPts[0].m_vecNormal.z;
        if ( CWorld::m_aTempColPts[0].m_vecNormal.x > 0.05
          || CWorld::m_aTempColPts[0].m_vecNormal.x < -0.05
          || CWorld::m_aTempColPts[0].m_vecNormal.y > 0.05
          || CWorld::m_aTempColPts[0].m_vecNormal.y < -0.05 )
        {
          p_xx = &v11->m_pMat->xx;
          v37 = &v11->m_transform.m_translate.x;
          if ( p_xx )
            v37 = p_xx + 12;
          if ( (float)((float)(CWorld::m_aTempColPts[0].m_vecNormal.z * 0.0)
                     + (float)((float)(CWorld::m_aTempColPts[0].m_vecNormal.x
                                     * (float)(CWorld::m_aTempColPts[0].m_vecPosition.x - *v37))
                             + (float)(CWorld::m_aTempColPts[0].m_vecNormal.y
                                     * (float)(CWorld::m_aTempColPts[0].m_vecPosition.y - v37[1])))) < 0.0 )
          {
            v34 = -CWorld::m_aTempColPts[0].m_vecNormal.z;
            v33 = -CWorld::m_aTempColPts[0].m_vecNormal.y;
            v32 = -CWorld::m_aTempColPts[0].m_vecNormal.x;
          }
          if ( (float)((float)((float)(v32 * p_xx[4]) + (float)(v33 * p_xx[5])) + (float)(v34 * p_xx[6])) > 0.3 )
          {
            v38 = *(_QWORD *)&CWorld::m_aTempColPts[0].m_vecPosition.x;
            vecTargetPos->z = CWorld::m_aTempColPts[0].m_vecPosition.z;
            *(_QWORD *)&vecTargetPos->x = v38;
            *fGrabHeading = atan2f(COERCE_FLOAT(LODWORD(v32) ^ 0x80000000), v33);
            *nSurfaceType = CWorld::m_aTempColPts[0].m_dataB.m_nSurfaceType;
            m_pVoid = (int)v39.m_pVoid;
          }
        }
        else
        {
          v35 = *(_QWORD *)&CWorld::m_aTempColPts[0].m_vecPosition.x;
          vecTargetPos->z = CWorld::m_aTempColPts[0].m_vecPosition.z;
          *(_QWORD *)&vecTargetPos->x = v35;
          *nSurfaceType = CWorld::m_aTempColPts[0].m_dataB.m_nSurfaceType;
        }
      }
    }
LABEL_90:
    if ( m_nNoOfSpheres > -1 && (*((_BYTE *)v39.m_pVoid + 58) & 7) == 2 )
      CEntity::GetColModel((CEntity *)v39.m_pVoid)->m_pColData->m_nNoOfSpheres = m_nNoOfSpheres;
LABEL_93:
    if ( !m_pHead )
      return (CEntity *)m_pVoid;
  }
  if ( m_nNoOfSpheres > -1 )
  {
    m_pVoid = (int)v39.m_pVoid;
    if ( (*((_BYTE *)v39.m_pVoid + 58) & 7) != 2 )
      return (CEntity *)m_pVoid;
    CEntity::GetColModel((CEntity *)v39.m_pVoid)->m_pColData->m_nNoOfSpheres = m_nNoOfSpheres;
  }
  return (CEntity *)v39.m_pVoid;
}
// 0: using guessed type int dword_0;
// 10168: using guessed type int elf_hash_chain[22025];
// 4103C: using guessed type Elf32_Sym stru_4103C;
// 9FF854: using guessed type char `guard variable for'CTaskSimpleClimb::ScanToGrabSectorList(CPtrList &,CPed *,CVector &,float &,unsigned char &,bool,bool,bool)::matTestForEdge;

//----- (00530BCC) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::CTaskSimpleJetPack(
        CTaskSimpleJetPack *this,
        const CVector *pVecTargetPos,
        float fCruiseHeight,
        int32 nHoverTime,
        CEntity *pTargetEnt)
{
  __int64 v9; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_bSwitchedWeapons = 0;
  *(_DWORD *)&this->m_bIsFinished = 0;
  this->m_vecTargetPos.z = 0.0;
  this->m_fCruiseHeight = fCruiseHeight;
  this->m_nHoverTime = nHoverTime;
  *(_QWORD *)&this->m_pJetPackClump = 0LL;
  *(_QWORD *)&this->m_vecTargetPos.x = 0LL;
  *(_QWORD *)&this->m_vecOldSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecOldSpeed.z = 0LL;
  *(_QWORD *)&this->m_fLegTwist = 0LL;
  *(_QWORD *)&this->m_fLegSwingSideSpeed = 0LL;
  this->m_nStartHover = 0;
  *(_QWORD *)&this->m_fThrustStrafe = 0LL;
  *(_QWORD *)&this->m_fLegSwingFwd = 0LL;
  *(_WORD *)&this->m_nThrustStop = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CC28;
  this->m_pTargetEnt = pTargetEnt;
  if ( pTargetEnt )
    CEntity::RegisterReference(pTargetEnt, &this->m_pTargetEnt);
  if ( pVecTargetPos )
  {
    v9 = *(_QWORD *)&pVecTargetPos->x;
    this->m_vecTargetPos.z = pVecTargetPos->z;
    *(_QWORD *)&this->m_vecTargetPos.x = v9;
  }
  this->m_pFxSysL = 0;
  this->m_pFxSysR = 0;
}
// 66CC28: using guessed type void *;

//----- (00530C5C) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::~CTaskSimpleJetPack(CTaskSimpleJetPack *this)
{
  RpClump_0 *m_pJetPackClump; // r0
  CClumpModelInfo *ClumpModelInfo; // r0
  RpAtomic_0 *FirstAtomic; // r0
  FxSystem_c *m_pFxSysL; // r0
  FxSystem_c *m_pFxSysR; // r0
  CEntity *m_pTargetEnt; // r0

  m_pJetPackClump = this->m_pJetPackClump;
  this->_vptr$CTask = (int (**)(void))&off_66CC28;
  if ( m_pJetPackClump )
  {
    ClumpModelInfo = CVisibilityPlugins::GetClumpModelInfo(m_pJetPackClump);
    CBaseModelInfo::RemoveRef(ClumpModelInfo);
    FirstAtomic = GetFirstAtomic(this->m_pJetPackClump);
    if ( FirstAtomic && j_RpSkinGeometryGetSkin(FirstAtomic->geometry) )
      RpClumpForAllAtomics(this->m_pJetPackClump, AtomicRemoveAnimFromSkinCB, 0);
    RpClumpDestroy(this->m_pJetPackClump);
    this->m_pJetPackClump = 0;
  }
  m_pFxSysL = this->m_pFxSysL;
  if ( m_pFxSysL )
  {
    FxSystem_c::Kill(m_pFxSysL);
    this->m_pFxSysL = 0;
  }
  m_pFxSysR = this->m_pFxSysR;
  if ( m_pFxSysR )
  {
    FxSystem_c::Kill(m_pFxSysR);
    this->m_pFxSysR = 0;
  }
  m_pTargetEnt = this->m_pTargetEnt;
  if ( m_pTargetEnt )
    CEntity::CleanUpOldReference(m_pTargetEnt, &this->m_pTargetEnt);
  sub_1A01F4(this);
}
// 66CC28: using guessed type void *off_66CC28;

//----- (00530CD8) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::StopJetPackEffect(CTaskSimpleJetPack *this)
{
  FxSystem_c *m_pFxSysL; // r0
  FxSystem_c *m_pFxSysR; // r0

  m_pFxSysL = this->m_pFxSysL;
  if ( m_pFxSysL )
  {
    FxSystem_c::Kill(m_pFxSysL);
    this->m_pFxSysL = 0;
  }
  m_pFxSysR = this->m_pFxSysR;
  if ( m_pFxSysR )
  {
    FxSystem_c::Kill(m_pFxSysR);
    this->m_pFxSysR = 0;
  }
}

//----- (00530CFC) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::~CTaskSimpleJetPack(CTaskSimpleJetPack *this)
{
  void *v1; // r0

  CTaskSimpleJetPack::~CTaskSimpleJetPack(this);
  sub_197118(v1);
}
// 530D08: variable 'v1' is possibly undefined

//----- (00530D0C) --------------------------------------------------------
bool __fastcall CTaskSimpleJetPack::MakeAbortable(
        CTaskSimpleJetPack *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v7; // zf
  FxSystem_c *m_pFxSysL; // r0
  FxSystem_c *m_pFxSysR; // r0

  if ( !pEvent )
  {
LABEL_11:
    if ( this->m_bSwitchedWeapons && CPed::IsPlayer(pPed) )
    {
      CPed::ReplaceWeaponWhenExitingVehicle(pPed);
      this->m_bSwitchedWeapons = 0;
    }
    m_pFxSysL = this->m_pFxSysL;
    this->m_bIsFinished = 1;
    if ( m_pFxSysL )
    {
      FxSystem_c::Kill(m_pFxSysL);
      this->m_pFxSysL = 0;
    }
    m_pFxSysR = this->m_pFxSysR;
    if ( m_pFxSysR )
    {
      FxSystem_c::Kill(m_pFxSysR);
      this->m_pFxSysR = 0;
    }
    CAEPedAudioEntity::TurnOffJetPack(&pPed->m_PedAudioEntity);
    return 1;
  }
  if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
  {
    if ( pPed->m_nHealth > 0.0 )
      return 0;
    v7 = *(_BYTE *)&pPed->m_nPedFlags << 31 == 0;
    if ( !(*(_BYTE *)&pPed->m_nPedFlags << 31) )
      v7 = *((unsigned __int8 *)&pPed->m_nPhysicalFlags + 1) << 31 == 0;
    if ( v7 )
      return 0;
  }
  if ( !CPed::IsPlayer(pPed) || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 58 )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent) < 63 )
      return 0;
    goto LABEL_11;
  }
  return 1;
}

//----- (00530DBC) --------------------------------------------------------
bool __fastcall CTaskSimpleJetPack::ProcessPed(CTaskSimpleJetPack *this, CPed *pPed)
{
  int m_bIsFinished; // r1
  int m_bSwitchedWeapons; // r0
  FxSystem_c *m_pFxSysL; // r0
  FxSystem_c *m_pFxSysR; // r0
  float v9; // s0
  float v10; // s2
  float v11; // r6
  float v12; // s16
  int v13; // s0
  CPlayerPedData *m_pPlayerData; // r0

  m_bIsFinished = this->m_bIsFinished;
  m_bSwitchedWeapons = this->m_bSwitchedWeapons;
  if ( m_bIsFinished )
  {
    if ( m_bSwitchedWeapons && CPed::IsPlayer(pPed) )
      CPed::ReplaceWeaponWhenExitingVehicle(pPed);
    m_pFxSysL = this->m_pFxSysL;
    if ( m_pFxSysL )
    {
      FxSystem_c::Kill(m_pFxSysL);
      this->m_pFxSysL = 0;
    }
    m_pFxSysR = this->m_pFxSysR;
    if ( m_pFxSysR )
    {
      FxSystem_c::Kill(m_pFxSysR);
      this->m_pFxSysR = 0;
    }
    return 1;
  }
  else
  {
    if ( !m_bSwitchedWeapons )
    {
      if ( CPed::IsPlayer(pPed) )
        CPed::RemoveWeaponWhenEnteringVehicle(pPed, 1);
      this->m_bSwitchedWeapons = 1;
    }
    *((_DWORD *)&pPed->m_nPedFlags + 3) |= 0x100u;
    if ( CTaskSimpleJetPack::ProcessAnims(this, pPed) )
    {
      if ( pPed->m_nHealth >= 1.0 )
      {
        if ( CPed::IsPlayer(pPed) )
          CTaskSimpleJetPack::ProcessControlInput(this, (CPlayerPed *)pPed);
      }
      else
      {
        this->m_fThrustAngle = 0.0;
        *(_WORD *)&this->m_nThrustStop = 0;
        v9 = -1.0;
        if ( (rand() & 1) != 0 )
          v9 = 1.0;
        v10 = this->m_fThrustStrafe + v9;
        this->m_fThrustStrafe = v10;
        if ( v10 <= 3.0 )
        {
          if ( v10 < -3.0 )
            this->m_fThrustStrafe = -3.0;
        }
        else
        {
          this->m_fThrustStrafe = 3.0;
        }
        v11 = sinf((float)((float)CTimer::m_snTimeInMilliseconds * 1.5708) / 1000.0);
        v12 = CTaskSimpleJetPack::JETPACK_TURN_RATE;
        v13 = rand();
        m_pPlayerData = pPed->m_pPlayerData;
        pPed->m_fDesiredHeading = pPed->m_fDesiredHeading
                                + (float)(CTimer::ms_fTimeStep
                                        * (float)((float)(v12 * v11) * (float)((float)((float)v13 * 4.6566e-10) + 0.0)));
        if ( m_pPlayerData )
          m_pPlayerData->m_moveBlendRatio = 0.0;
      }
      CTaskSimpleJetPack::ProcessThrust(this, pPed);
      if ( this->m_nThrustFwd > 0 || fabsf(this->m_fThrustStrafe) > 0.1 )
        *(_DWORD *)&pPed->m_nPedFlags &= ~1u;
    }
    return 0;
  }
}

//----- (00530F90) --------------------------------------------------------
bool __fastcall CTaskSimpleJetPack::ProcessAnims(CTaskSimpleJetPack *this, CPed *pPed)
{
  RpClump_0 **p_m_pJetPackClump; // r5
  CBaseModelInfo *v5; // r6
  bool v6; // r5

  if ( CStreaming::ms_aInfoForModel[370].m_status == 1 )
  {
    p_m_pJetPackClump = &this->m_pJetPackClump;
    if ( this->m_pJetPackClump )
      goto LABEL_6;
    v5 = CModelInfo::ms_modelInfoPtrs[370];
    *p_m_pJetPackClump = (RpClump_0 *)(*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[370]->_vptr$CBaseModelInfo
                                       + 11))(CModelInfo::ms_modelInfoPtrs[370]);
    CBaseModelInfo::AddRef(v5);
  }
  else
  {
    CStreaming::RequestModel(370, 8);
    p_m_pJetPackClump = &this->m_pJetPackClump;
  }
  if ( !*p_m_pJetPackClump )
    return 0;
LABEL_6:
  if ( *(_BYTE *)&pPed->m_nPedFlags << 31 )
  {
    if ( CPed::IsPlayer(pPed) )
      CPlayerPed::SetRealMoveAnim((CPlayerPed *)pPed);
    return 1;
  }
  else
  {
    CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 4.0);
    v6 = 1;
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
  }
  return v6;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00531028) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::ProcessControlInput(CTaskSimpleJetPack *this, CPlayerPed *pPlayerPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  float32x2_t v6; // d5
  CPad *PadFromPlayer; // r6
  eWeaponType m_eWeaponType; // r4
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r0
  CTask *v13; // r0
  float PedWalkLeftRight; // s20
  float PedWalkUpDown; // s18
  float v16; // s16
  int InputType; // r0
  bool v18; // zf
  CEntity *m_pEntLockOnTarget; // r0
  bool v20; // zf
  float RadianAngleBetweenPoints; // r0
  float v22; // s0
  float *v23; // r1
  float v24; // s22
  float v25; // s24
  float v26; // s26
  float v27; // s28
  float v28; // s22
  float v29; // r0
  float *p_m_fThrustStrafe; // r0
  float v31; // s0
  float v32; // s2
  float v33; // s4
  float v34; // r0
  CEntity *v35; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v37; // r2
  float *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  float v40; // s2
  float v41; // s0
  float v42; // s8
  float v43; // s10
  float v44; // s4
  float m_fMass; // s6
  int v46; // r0
  bool v47; // zf
  __int16 v48; // r0
  char v49; // r4
  int8 v50; // r0
  int v51; // r4
  int v52; // r5
  int v53; // r0
  _BOOL4 LookRight; // r0
  float *v55; // r0
  unsigned __int32 v56; // s0
  CPlayerPedData *m_pPlayerData; // r1
  float m_moveBlendRatio; // s4
  float v59; // s2
  float v60; // s4
  CVector v61; // 0:r1.12

  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  m_eWeaponType = pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(pPlayerPed);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  if ( WeaponInfo->m_eFireType == FIRETYPE_INSTANT_HIT && (WeaponInfo->m_nFlags & 2) != 0 )
  {
    v13 = pPlayerPed->m_pPedIntelligence->m_taskManager.m_tasks[4];
    if ( v13 )
    {
      if ( !(*((int (__fastcall **)(CTask *))v13->_vptr$CTask + 5))(v13) )
        CTaskSimplePlayerOnFoot::ProcessPlayerWeapon(
          (CTaskSimplePlayerOnFoot *)pPlayerPed->m_pPedIntelligence->m_taskManager.m_tasks[4],
          pPlayerPed);
    }
  }
  PedWalkLeftRight = (float)CPad::GetPedWalkLeftRight(PadFromPlayer);
  PedWalkUpDown = (float)CPad::GetPedWalkUpDown(PadFromPlayer);
  v16 = sqrtf((float)(PedWalkLeftRight * PedWalkLeftRight) + (float)(PedWalkUpDown * PedWalkUpDown)) / 60.0;
  InputType = CHID::GetInputType();
  v18 = InputType == 2;
  if ( InputType == 2 )
    v18 = *(_BYTE *)&pPlayerPed->m_nPedFlags << 31 == 0;
  if ( v18 )
  {
    v23 = (float *)((char *)&TheCamera + 528 * TheCamera.ActiveCam);
    v24 = v23[182];
    v25 = v23[183];
    v26 = -v24;
    v27 = -v25;
    if ( CCamera::GetLookDirection(&TheCamera) == 3 )
    {
      v26 = v24;
      v27 = v25;
    }
    pPlayerPed->m_fDesiredHeading = atan2f(COERCE_FLOAT(LODWORD(v26) ^ 0x80000000), v27);
    v28 = CTimer::ms_fTimeStep;
    v29 = powf(CTaskSimpleJetPack::JETPACK_ANGLE_RATE, CTimer::ms_fTimeStep);
    v2.n64_u32[0] = 1.0;
    PedWalkUpDown = PedWalkUpDown * 0.0078125;
    this->m_fThrustAngle = (float)(v29 * this->m_fThrustAngle)
                         + (float)((float)(PedWalkUpDown * (float)(1.0 - v29)) * CTaskSimpleJetPack::THRUST_MAX_ANGLE);
    if ( (float)(PedWalkLeftRight * 0.0078125) >= 0.0 )
    {
      v3.n64_u32[0] = LODWORD(this->m_fThrustStrafe);
      p_m_fThrustStrafe = &this->m_fThrustStrafe;
      if ( (float)(PedWalkLeftRight * 0.0078125) > 0.0 )
      {
        v3.n64_f32[0] = v3.n64_f32[0] + (float)(v28 * 0.1);
        v2.n64_u64[0] = vmin_f32(v3, v2).n64_u64[0];
        *p_m_fThrustStrafe = v2.n64_f32[0];
        goto LABEL_36;
      }
      if ( v3.n64_f32[0] <= 0.0 )
      {
        if ( v3.n64_f32[0] < 0.0 )
        {
          v4.n64_u32[0] = 0;
          v2.n64_f32[0] = v3.n64_f32[0] + (float)(v28 * 0.05);
          v2.n64_u64[0] = vmin_f32(v2, v4).n64_u64[0];
          *p_m_fThrustStrafe = v2.n64_f32[0];
        }
        goto LABEL_36;
      }
      v2.n64_u32[0] = -1119040307;
      v4.n64_u32[0] = 0;
    }
    else
    {
      v2.n64_u32[0] = -1110651699;
      v4.n64_u32[0] = -1.0;
      v3.n64_u32[0] = LODWORD(this->m_fThrustStrafe);
      p_m_fThrustStrafe = &this->m_fThrustStrafe;
    }
    v2.n64_f32[0] = v3.n64_f32[0] + (float)(v28 * v2.n64_f32[0]);
    v2.n64_u64[0] = vmax_f32(v2, v4).n64_u64[0];
    *p_m_fThrustStrafe = v2.n64_f32[0];
    goto LABEL_36;
  }
  m_pEntLockOnTarget = pPlayerPed->m_pEntLockOnTarget;
  v20 = m_pEntLockOnTarget == 0;
  if ( !m_pEntLockOnTarget )
    v20 = *(_BYTE *)&pPlayerPed->m_nPedFlags << 31 == 0;
  if ( v20 && !CPad::GetTarget(PadFromPlayer, 0) )
  {
    PedWalkUpDown = PedWalkUpDown * 0.0078125;
    if ( (float)(PedWalkLeftRight * 0.0078125) == 0.0 )
    {
      v31 = CTimer::ms_fTimeStep;
    }
    else
    {
      v31 = CTimer::ms_fTimeStep;
      v32 = pPlayerPed->m_fDesiredHeading
          + (float)((float)((float)(PedWalkLeftRight * 0.0078125) * CTaskSimpleJetPack::JETPACK_TURN_RATE)
                  * CTimer::ms_fTimeStep);
      pPlayerPed->m_fDesiredHeading = v32;
      if ( v32 > 3.1416 )
      {
        v33 = -6.2832;
LABEL_33:
        pPlayerPed->m_fDesiredHeading = v32 + v33;
        goto LABEL_34;
      }
      if ( v32 < -3.1416 )
      {
        v33 = 6.2832;
        goto LABEL_33;
      }
    }
LABEL_34:
    v34 = powf(CTaskSimpleJetPack::JETPACK_ANGLE_RATE, v31);
    v22 = (float)(v34 * this->m_fThrustAngle)
        + (float)((float)(PedWalkUpDown * (float)(1.0 - v34)) * CTaskSimpleJetPack::THRUST_MAX_ANGLE);
    goto LABEL_35;
  }
  if ( v16 > 0.0 )
  {
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 0.0,
                                 0.0,
                                 COERCE_FLOAT(LODWORD(PedWalkLeftRight) ^ 0x80000000),
                                 PedWalkUpDown);
    pPlayerPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
    v22 = (float)(v16 * (float)(CTaskSimpleJetPack::THRUST_MAX_ANGLE * -0.75)) * 0.46875;
LABEL_35:
    this->m_fThrustAngle = v22;
    goto LABEL_36;
  }
  pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
LABEL_36:
  v35 = pPlayerPed->m_pEntLockOnTarget;
  if ( v35 && !(*(_BYTE *)&pPlayerPed->m_nPedFlags << 31) )
  {
    m_pMat = v35->m_pMat;
    v37 = pPlayerPed->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v35->m_transform.m_translate.x;
    p_m_transform = (CSimpleTransform *)&v37->tx;
    if ( !v37 )
      p_m_transform = &pPlayerPed->m_transform;
    v40 = p_m_transform->m_translate.x - *p_tx;
    v41 = p_m_transform->m_translate.y - p_tx[1];
    v5.n64_f32[0] = sqrtf((float)(v40 * v40) + (float)(v41 * v41));
    v42 = (float)(fabsf(p_m_transform->m_translate.z - p_tx[2]) * 0.2) + 3.0;
    if ( v5.n64_f32[0] < v42 )
    {
      v6.n64_u32[0] = 1036831949;
      v43 = vmax_f32(v5, v6).n64_f32[0];
      v44 = (float)(1.0 - (float)(v5.n64_f32[0] / v42)) * 3.0;
      m_fMass = pPlayerPed->m_fMass;
      v61.x = (float)((float)((float)((float)((float)(v40 * (float)(1.0 / v43)) * v44) * 0.008)
                            * CTaskSimpleJetPack::THRUST_FULL)
                    * m_fMass)
            * CTimer::ms_fTimeStep;
      v61.y = (float)((float)((float)((float)((float)(v41 * (float)(1.0 / v43)) * v44) * 0.008)
                            * CTaskSimpleJetPack::THRUST_FULL)
                    * m_fMass)
            * CTimer::ms_fTimeStep;
      v61.z = (float)((float)((float)((float)((float)((float)(1.0 / v43) * 0.0) * v44) * 0.008)
                            * CTaskSimpleJetPack::THRUST_FULL)
                    * m_fMass)
            * CTimer::ms_fTimeStep;
      CPhysical::ApplyMoveForce(pPlayerPed, v61);
    }
  }
  v46 = CHID::GetInputType();
  v47 = v46 == 2;
  if ( v46 == 2 )
    v47 = *(_BYTE *)&pPlayerPed->m_nPedFlags << 31 == 0;
  if ( !v47 )
  {
    if ( !CPad::GetJetpackHover(PadFromPlayer) )
    {
      v48 = 0;
LABEL_56:
      *(_WORD *)&this->m_nThrustStop = v48;
      goto LABEL_57;
    }
LABEL_55:
    this->m_fThrustStrafe = 0.0;
    v48 = 1;
    goto LABEL_56;
  }
  v49 = 0;
  this->m_nThrustStop = 0;
  if ( CPad::GetBrake(PadFromPlayer) )
  {
    v50 = -1;
  }
  else
  {
    if ( PedWalkUpDown != 0.0 )
      v49 = 1;
    v50 = (CPad::GetAccelerate(PadFromPlayer) != 0) | v49;
  }
  this->m_nThrustFwd = v50;
  if ( CPad::GetJetpackHover(PadFromPlayer) )
    goto LABEL_55;
  v2.n64_u32[0] = LODWORD(this->m_fThrustStrafe);
  if ( v2.n64_f32[0] <= 0.0 )
  {
    if ( v2.n64_f32[0] < 0.0 )
    {
      v4.n64_u32[0] = 0;
      v2.n64_f32[0] = v2.n64_f32[0] + (float)(CTimer::ms_fTimeStep * 0.05);
      v2.n64_u64[0] = vmin_f32(v2, v4).n64_u64[0];
      LODWORD(this->m_fThrustStrafe) = v2.n64_u32[0];
    }
  }
  else
  {
    v4.n64_u32[0] = 0;
    v2.n64_f32[0] = v2.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.05);
    v2.n64_u64[0] = vmax_f32(v2, v4).n64_u64[0];
    LODWORD(this->m_fThrustStrafe) = v2.n64_u32[0];
  }
LABEL_57:
  if ( CPad::GetAccelerate(PadFromPlayer) )
    this->m_nThrustFwd = 1;
  if ( CPad::GetBrake(PadFromPlayer) )
    this->m_nThrustFwd = -1;
  v51 = CPad::GetPedWalkUpDown(PadFromPlayer);
  v52 = CPad::GetPedWalkLeftRight(PadFromPlayer);
  if ( CHID::GetInputType() == 2 )
  {
    if ( CHID::IsPressed(HID_MAPPING_FLIGHT_ASCEND, 0) )
      this->m_nThrustFwd = 1;
    if ( CHID::IsPressed(HID_MAPPING_FLIGHT_DESCEND, 0) )
      this->m_nThrustFwd = -1;
    if ( CHID::IsPressed(HID_MAPPING_FLIGHT_ASCEND, 0) && CHID::IsPressed(HID_MAPPING_FLIGHT_DESCEND, 0) )
      this->m_nThrustFwd = 0;
  }
  if ( !this->m_nThrustFwd && *(_BYTE *)&pPlayerPed->m_nPedFlags << 31 )
    goto LABEL_74;
  if ( v51 < 0 )
    v51 = -v51;
  if ( v51 <= 64 )
  {
    v53 = v52;
    if ( v52 < 0 )
      v53 = -v52;
    if ( v53 >= 65 )
      this->m_nThrustFwd = 0;
  }
  else
  {
LABEL_74:
    v52 = 0;
  }
  if ( (CPad::GetLookLeft(PadFromPlayer, 1) || v52 <= -1) && !CPad::GetTarget(PadFromPlayer, 0) )
  {
    v4.n64_u32[0] = -1.0;
    v55 = &this->m_fThrustStrafe;
    v2.n64_f32[0] = this->m_fThrustStrafe + (float)(CTimer::ms_fTimeStep * -0.1);
    v56 = vmax_f32(v2, v4).n64_u32[0];
    goto LABEL_92;
  }
  LookRight = CPad::GetLookRight(PadFromPlayer, 1);
  if ( (v52 > 0 || LookRight) && !CPad::GetTarget(PadFromPlayer, 0) )
  {
    v4.n64_u32[0] = 1.0;
    v55 = &this->m_fThrustStrafe;
    v2.n64_f32[0] = this->m_fThrustStrafe + (float)(CTimer::ms_fTimeStep * 0.1);
LABEL_91:
    v56 = vmin_f32(v2, v4).n64_u32[0];
    goto LABEL_92;
  }
  v2.n64_u32[0] = LODWORD(this->m_fThrustStrafe);
  v55 = &this->m_fThrustStrafe;
  if ( v2.n64_f32[0] <= 0.0 )
  {
    if ( v2.n64_f32[0] >= 0.0 )
      goto LABEL_93;
    v4.n64_u32[0] = 0;
    v2.n64_f32[0] = v2.n64_f32[0] + (float)(CTimer::ms_fTimeStep * 0.05);
    goto LABEL_91;
  }
  v4.n64_u32[0] = 0;
  v2.n64_f32[0] = v2.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.05);
  v56 = vmax_f32(v2, v4).n64_u32[0];
LABEL_92:
  *(_DWORD *)v55 = v56;
LABEL_93:
  if ( v16 <= 0.0 )
  {
    pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
  }
  else
  {
    m_pPlayerData = pPlayerPed->m_pPlayerData;
    m_moveBlendRatio = m_pPlayerData->m_moveBlendRatio;
    v59 = v16 - m_moveBlendRatio;
    v60 = (float)(CTimer::ms_fTimeStep * 0.07) + m_moveBlendRatio;
    if ( v59 > (float)(CTimer::ms_fTimeStep * 0.07) )
      v16 = v60;
    m_pPlayerData->m_moveBlendRatio = v16;
  }
}
// 531206: variable 'v2' is possibly undefined
// 531206: variable 'v4' is possibly undefined
// 531238: variable 'v3' is possibly undefined
// 5313D0: variable 'v5' is possibly undefined
// 5313D0: variable 'v6' is possibly undefined

//----- (00531794) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::ProcessThrust(CTaskSimpleJetPack *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t *p_y; // r10
  float32x2_t v8; // d8
  float x; // s18
  CMatrix *m_pMat; // r0
  CMatrix **p_m_pMat; // r11
  float m_fMass; // s6
  float zz; // s4
  float v14; // s0
  float v15; // s2
  float v17; // s0
  float y; // s2
  float z; // s4
  float v20; // s6
  float v21; // s8
  CMatrix *v22; // r1
  float v23; // s2
  float v24; // s6
  float v25; // s4
  float v26; // s0
  float v27; // s2
  CMatrix **v28; // r4
  float m_fThrustAngle; // r11
  float v30; // r8
  CMatrix *v31; // r6
  float v32; // r0
  CSimpleTransform *p_m_transform; // r11
  CSimpleTransform *p_tx; // r1
  float v35; // s21
  float v36; // s22
  float v37; // s24
  float v38; // s26
  float v39; // s30
  float v40; // s0
  float v41; // s8
  float v42; // s0
  float v43; // s2
  float v44; // s4
  float v45; // s6
  float v46; // s6
  float m_fThrustStrafe; // s0
  CMatrix *v48; // r0
  float v49; // s6
  float m_fLegSwingFwd; // s30
  float32x2_t v51; // d8
  float v52; // s18
  float m_fLegSwingFwdSpeed; // s20
  float v54; // s19
  float v55; // r0
  float v56; // s24
  float v57; // s28
  float v58; // r8
  float v59; // s26
  float v60; // s19
  float v61; // s20
  float v62; // s0
  float v63; // s30
  float m_fLegSwingSideSpeed; // s19
  float v65; // s0
  float m_fLegSwingSide; // s18
  unsigned __int64 v67; // d1
  float v68; // s16
  float v69; // s2
  float v70; // s0
  float v71; // s30
  float v72; // s16
  float v73; // s18
  float v74; // s20
  float v75; // r0
  __int64 v76; // d16
  CAEPedAudioEntity *p_m_PedAudioEntity; // r5
  CVector v78; // 0:r1.12
  CVector v79; // 0:r1.12
  CVector v80; // 0:r1.12
  CVector v81; // 0:r1.12

  p_y = (float32x2_t *)&pPed->m_vecMoveSpeed.y;
  v8.n64_u64[0] = *(unsigned __int64 *)&pPed->m_vecMoveSpeed.y;
  x = pPed->m_vecMoveSpeed.x;
  if ( this->m_nThrustStop )
  {
    p_m_pMat = &pPed->m_pMat;
    m_pMat = pPed->m_pMat;
    m_fMass = pPed->m_fMass;
    zz = m_pMat->zz;
    v14 = m_pMat->xz * 0.008;
    v15 = m_pMat->yz * 0.008;
    v78.x = (float)(v14 * m_fMass) * CTimer::ms_fTimeStep;
    v78.y = (float)(v15 * m_fMass) * CTimer::ms_fTimeStep;
    v78.z = (float)((float)(zz * 0.008) * m_fMass) * CTimer::ms_fTimeStep;
    CPhysical::ApplyMoveForce(pPed, v78);
    v17 = pPed->m_vecMoveSpeed.x;
    y = pPed->m_vecMoveSpeed.y;
    z = pPed->m_vecMoveSpeed.z;
    v20 = (float)(CTaskSimpleJetPack::THRUST_STOP * 0.008) * CTimer::ms_fTimeStep;
    v21 = (float)((float)(v17 * v17) + (float)(y * y)) + (float)(z * z);
    if ( (float)(v20 * v20) > v21 )
      v20 = v20 * 0.75;
    if ( (float)(v20 * v20) > v21 )
    {
      pPed->m_vecMoveSpeed.x = 0.0;
      pPed->m_vecMoveSpeed.y = 0.0;
      pPed->m_vecMoveSpeed.z = 0.0;
      goto LABEL_21;
    }
    v41 = 1.0 / sqrtf(v21);
    v42 = (float)(v17 * v41) * v20;
    v43 = (float)(y * v41) * v20;
    v44 = (float)(z * v41) * v20;
    v45 = pPed->m_fMass;
    v80.x = -(float)(v42 * v45);
    v80.y = -(float)(v43 * v45);
    v80.z = -(float)(v44 * v45);
    goto LABEL_20;
  }
  p_m_pMat = &pPed->m_pMat;
  v22 = pPed->m_pMat;
  v23 = CTaskSimpleJetPack::THRUST_NOMINAL;
  if ( this->m_nThrustFwd < 0 )
    v23 = CTaskSimpleJetPack::THRUST_NOMINAL * 0.5;
  v24 = pPed->m_fMass;
  v25 = (float)(v23 * (float)(v22->xz * 0.008)) * v24;
  v26 = (float)(v23 * (float)(v22->yz * 0.008)) * v24;
  v27 = v24 * (float)(v23 * (float)(v22->zz * 0.008));
  v79.x = v25 * CTimer::ms_fTimeStep;
  v79.y = v26 * CTimer::ms_fTimeStep;
  v79.z = CTimer::ms_fTimeStep * v27;
  CPhysical::ApplyMoveForce(pPed, v79);
  if ( this->m_nThrustFwd >= 1 )
  {
    v28 = &pPed->m_pMat;
    m_fThrustAngle = this->m_fThrustAngle;
    v30 = sinf(m_fThrustAngle);
    v31 = pPed->m_pMat;
    v32 = cosf(m_fThrustAngle);
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    if ( v31 )
      p_tx = (CSimpleTransform *)&v31->tx;
    v35 = p_tx->m_translate.z;
    v3.n64_u32[0] = 0.75;
    v4.n64_f32[0] = (float)(v32 * v31->zz) - (float)(v31->zy * v30);
    v36 = (float)(v32 * v31->yz) - (float)(v31->yy * v30);
    v37 = (float)(v32 * v31->xz) - (float)(v31->xy * v30);
    LODWORD(v38) = vmin_f32(v4, v3).n64_u32[0];
    if ( v35 <= (float)(CCamera::CalculateGroundHeight(&TheCamera, 2u) + 100.0) )
    {
      v40 = 1.0;
    }
    else
    {
      if ( *v28 )
        p_m_transform = (CSimpleTransform *)&(*v28)->tx;
      v39 = p_m_transform->m_translate.z;
      v4.n64_u32[0] = 0;
      v2.n64_f32[0] = (float)((float)(v39 - (float)(CCamera::CalculateGroundHeight(&TheCamera, 2u) + 100.0)) / -20.0)
                    + 1.0;
      LODWORD(v40) = vmax_f32(v2, v4).n64_u32[0];
    }
    v46 = pPed->m_fMass;
    v81.x = (float)((float)((float)((float)(v37 * 0.008) * v40) * CTaskSimpleJetPack::THRUST_FULL) * v46)
          * CTimer::ms_fTimeStep;
    v81.y = (float)((float)((float)((float)(v36 * 0.008) * v40) * CTaskSimpleJetPack::THRUST_FULL) * v46)
          * CTimer::ms_fTimeStep;
    v81.z = (float)((float)((float)((float)(v38 * 0.008) * v40) * CTaskSimpleJetPack::THRUST_FULL) * v46)
          * CTimer::ms_fTimeStep;
    CPhysical::ApplyMoveForce(pPed, v81);
    p_m_pMat = &pPed->m_pMat;
  }
  m_fThrustStrafe = this->m_fThrustStrafe;
  if ( m_fThrustStrafe != 0.0 )
  {
    v48 = pPed->m_pMat;
    v49 = pPed->m_fMass;
    v80.x = (float)((float)((float)((float)(m_fThrustStrafe * v48->xx) * 0.008) * CTaskSimpleJetPack::THRUST_STRAFE)
                  * v49)
          * CTimer::ms_fTimeStep;
    v80.y = (float)((float)((float)((float)(m_fThrustStrafe * v48->yx) * 0.008) * CTaskSimpleJetPack::THRUST_STRAFE)
                  * v49)
          * CTimer::ms_fTimeStep;
    v80.z = CTimer::ms_fTimeStep
          * (float)(v49
                  * (float)(CTaskSimpleJetPack::THRUST_STRAFE * (float)((float)(m_fThrustStrafe * v48->zx) * 0.008)));
LABEL_20:
    CPhysical::ApplyMoveForce(pPed, v80);
  }
LABEL_21:
  m_fLegSwingFwd = this->m_fLegSwingFwd;
  v51.n64_u64[0] = vadd_f32(
                     vsub_f32((float32x2_t)p_y->n64_u64[0], v8),
                     vsub_f32((float32x2_t)p_y->n64_u64[0], *(float32x2_t *)&this->m_vecOldSpeed.y)).n64_u64[0];
  v52 = (float)(pPed->m_vecMoveSpeed.x - x) + (float)(pPed->m_vecMoveSpeed.x - this->m_vecOldSpeed.x);
  m_fLegSwingFwdSpeed = this->m_fLegSwingFwdSpeed;
  v54 = (float)((float)(v52 * (*p_m_pMat)->xy) + (float)(v51.n64_f32[0] * (*p_m_pMat)->yy))
      + (float)(v51.n64_f32[1] * (*p_m_pMat)->zy);
  if ( (*(_DWORD *)&pPed->m_nPedFlags & 3) != 0 )
    v54 = 0.0;
  v55 = sinf(this->m_fLegSwingFwd);
  v56 = CTimer::ms_fTimeStep;
  v57 = CTaskSimpleJetPack::LEG_SWING_DELTA_V_MULT;
  v58 = CTimer::ms_fTimeStep;
  v59 = CTaskSimpleJetPack::LEG_SWING_GRAVITY_MULT;
  v60 = (float)(m_fLegSwingFwdSpeed - (float)(CTaskSimpleJetPack::LEG_SWING_DELTA_V_MULT * v54))
      - (float)((float)(v55 * CTaskSimpleJetPack::LEG_SWING_GRAVITY_MULT) * CTimer::ms_fTimeStep);
  v61 = powf(CTaskSimpleJetPack::LEG_SWING_DAMP_FRAC, CTimer::ms_fTimeStep);
  this->m_fLegSwingFwdSpeed = v61 * v60;
  v62 = m_fLegSwingFwd + (float)(v56 * (float)(v61 * v60));
  this->m_fLegSwingFwd = v62;
  v63 = CTaskSimpleJetPack::LEG_SWING_MAX_ANGLE;
  if ( v62 <= CTaskSimpleJetPack::LEG_SWING_MAX_ANGLE )
  {
    if ( v62 < (float)-CTaskSimpleJetPack::LEG_SWING_MAX_ANGLE )
      this->m_fLegSwingFwd = -CTaskSimpleJetPack::LEG_SWING_MAX_ANGLE;
  }
  else
  {
    this->m_fLegSwingFwd = CTaskSimpleJetPack::LEG_SWING_MAX_ANGLE;
  }
  v65 = v52 * (*p_m_pMat)->xx;
  m_fLegSwingSide = this->m_fLegSwingSide;
  v67 = vmul_f32(v51, *(float32x2_t *)&(*p_m_pMat)->yx).n64_u64[0];
  v68 = (float)(v65 + *(float *)&v67) + *((float *)&v67 + 1);
  if ( (*(_DWORD *)&pPed->m_nPedFlags & 3) != 0 )
    v68 = 0.0;
  m_fLegSwingSideSpeed = this->m_fLegSwingSideSpeed;
  v69 = v61
      * (float)((float)(m_fLegSwingSideSpeed - (float)(v57 * v68))
              - (float)((float)(sinf(this->m_fLegSwingSide) * v59) * v56));
  this->m_fLegSwingSideSpeed = v69;
  v70 = m_fLegSwingSide + (float)(v56 * v69);
  this->m_fLegSwingSide = v70;
  if ( v70 <= v63 )
  {
    v71 = -v63;
    if ( v70 < v71 )
      this->m_fLegSwingSide = v71;
  }
  else
  {
    this->m_fLegSwingSide = v63;
  }
  this->m_fLegTwist = v61 * this->m_fLegTwist;
  v72 = pPed->m_vecMoveSpeed.x;
  v73 = pPed->m_vecMoveSpeed.y;
  v74 = pPed->m_vecMoveSpeed.z;
  v75 = powf(
          1.0
        - (float)(CTaskSimpleJetPack::THRUST_MOVE_DAMPING
                * sqrtf((float)((float)(v72 * v72) + (float)(v73 * v73)) + (float)(v74 * v74))),
          v58);
  pPed->m_vecMoveSpeed.x = v72 * v75;
  pPed->m_vecMoveSpeed.y = v73 * v75;
  pPed->m_vecMoveSpeed.z = v74 * v75;
  v76 = *(_QWORD *)&pPed->m_vecMoveSpeed.x;
  this->m_vecOldSpeed.z = pPed->m_vecMoveSpeed.z;
  *(_QWORD *)&this->m_vecOldSpeed.x = v76;
  if ( !this->m_bIsFinished )
  {
    p_m_PedAudioEntity = &pPed->m_PedAudioEntity;
    CAEPedAudioEntity::TurnOnJetPack(p_m_PedAudioEntity);
    sub_19B328(p_m_PedAudioEntity, (float)this->m_nThrustFwd, this->m_fThrustAngle);
  }
}
// 53199E: variable 'v4' is possibly undefined
// 53199E: variable 'v3' is possibly undefined
// 5319E8: variable 'v2' is possibly undefined

//----- (00531DC4) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::DropJetPack(CTaskSimpleJetPack *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  CVector pResultX; // [sp+14h] [bp-1Ch] BYREF

  if ( !this->m_bIsFinished )
  {
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    CPickups::CreatePickupCoorsCloseToCoors(
      p_tx->m_translate.x,
      p_tx->m_translate.y,
      p_tx->m_translate.z,
      &pResultX.x,
      &pResultX.y,
      &pResultX.z);
    CPickups::GenerateNewOne(pResultX, 0x172u, 5, 0, 0, 1, 0);
  }
  (*((void (__fastcall **)(CTaskSimpleJetPack *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(this, pPed, 1, 0);
  *(_WORD *)&this->m_nThrustStop = 0;
  this->m_fThrustStrafe = 0.0;
}
// 531DC4: using guessed type CVector pResultX;

//----- (00531E34) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::ApplyRollAndPitch(CTaskSimpleJetPack *this, CPed *pPed)
{
  CPedFlags *p_m_nPedFlags; // r10
  RwFrame_0 *pFrame; // r6
  RwFrame_0 *v6; // r5

  if ( !(*(_BYTE *)&pPed->m_nPedFlags << 30) )
  {
    p_m_nPedFlags = &pPed->m_nPedFlags;
    pFrame = pPed->m_aPedFrames[7]->_anon_1.pFrame;
    RtQuatRotate(
      (RtQuat_0 *)pFrame,
      &CPedIK::ZaxisIK,
      (float)(this->m_fLegSwingFwd * 180.0) / 3.1416,
      rwCOMBINEPOSTCONCAT);
    RtQuatRotate(
      (RtQuat_0 *)pFrame,
      &CPedIK::YaxisIK,
      (float)(this->m_fLegSwingSide * 180.0) / 3.1416,
      rwCOMBINEPOSTCONCAT);
    v6 = pPed->m_aPedFrames[8]->_anon_1.pFrame;
    RtQuatRotate((RtQuat_0 *)v6, &CPedIK::ZaxisIK, (float)(this->m_fLegSwingFwd * 180.0) / 3.1416, rwCOMBINEPOSTCONCAT);
    RtQuatRotate((RtQuat_0 *)v6, &CPedIK::YaxisIK, (float)(this->m_fLegSwingSide * 180.0) / 3.1416, rwCOMBINEPOSTCONCAT);
    *((_DWORD *)p_m_nPedFlags + 1) |= 0x4000u;
  }
}

//----- (00531F04) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::RenderJetPack(CTaskSimpleJetPack *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  FxSystem_c *m_pFxSysL; // r0
  FxSystem_c *m_pFxSysR; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  RwMatrix *MatrixArray; // r0
  __int64 *p_at; // r1
  __int64 v13; // d18
  __int64 v14; // d19
  __int64 *v15; // r3
  __int64 v16; // d16
  __int64 v17; // d17
  char *parent; // r9
  __int64 v19; // d23
  __int64 v20; // d20
  __int64 v21; // d21
  float m_fOldHeading; // s0
  float m_fDesiredHeading; // s2
  float v24; // s4
  float v25; // s2
  float v26; // s0
  float v27; // s18
  RwFrame_0 *FrameFromName; // r0
  RwV3d_0 *p_pos; // r11
  RwMatrix *p_modelling; // r8
  float v31; // r6
  float v32; // r10
  float v33; // s22
  float32x2_t v34; // d16
  RwFrame_0 *v35; // r0
  RwV3d_0 *v36; // r11
  RwMatrix *v37; // r8
  float v38; // r6
  float v39; // r10
  float v40; // s16
  float v41; // s0
  float32x2_t v42; // d16
  __int64 v43; // [sp+0h] [bp-50h]
  __int64 v44; // [sp+0h] [bp-50h]
  RwReal z; // [sp+8h] [bp-48h]
  RwReal v46; // [sp+8h] [bp-48h]

  if ( !this->m_pJetPackClump || this->m_bIsFinished )
  {
    m_pFxSysL = this->m_pFxSysL;
    if ( m_pFxSysL )
    {
      FxSystem_c::Kill(m_pFxSysL);
      this->m_pFxSysL = 0;
    }
    m_pFxSysR = this->m_pFxSysR;
    if ( m_pFxSysR )
    {
      FxSystem_c::Kill(m_pFxSysR);
      this->m_pFxSysR = 0;
    }
    goto LABEL_26;
  }
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
  MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  p_at = (__int64 *)&MatrixArray[3].at;
  v13 = *(_QWORD *)&MatrixArray[3].up.x;
  v14 = *(_QWORD *)&MatrixArray[3].up.z;
  v15 = (__int64 *)&MatrixArray[3];
  MatrixArray = (RwMatrix *)((char *)MatrixArray + 240);
  v16 = *p_at;
  v17 = p_at[1];
  parent = (char *)this->m_pJetPackClump->object.parent;
  v19 = *(_QWORD *)&MatrixArray->right.z;
  v20 = *v15;
  v21 = v15[1];
  *((_QWORD *)parent + 8) = *(_QWORD *)&MatrixArray->right.x;
  *((_QWORD *)parent + 9) = v19;
  *((_QWORD *)parent + 6) = v16;
  *((_QWORD *)parent + 7) = v17;
  *((_QWORD *)parent + 4) = v13;
  *((_QWORD *)parent + 5) = v14;
  *((_QWORD *)parent + 2) = v20;
  *((_QWORD *)parent + 3) = v21;
  RwMatrixTranslate((RwMatrix *)(parent + 16), &JETPACK_POS_OFFSET, rwCOMBINEPRECONCAT);
  RwMatrixRotate((RwMatrix *)(parent + 16), &JETPACK_ROT_AXIS, 90.0, rwCOMBINEPRECONCAT);
  m_fOldHeading = this->m_fOldHeading;
  m_fDesiredHeading = pPed->m_fDesiredHeading;
  if ( m_fDesiredHeading <= (float)(m_fOldHeading + 3.1416) )
  {
    if ( m_fDesiredHeading >= (float)(m_fOldHeading + -3.1416) )
      goto LABEL_12;
    v24 = 6.2832;
  }
  else
  {
    v24 = -6.2832;
  }
  m_fDesiredHeading = m_fDesiredHeading + v24;
LABEL_12:
  v25 = m_fDesiredHeading - m_fOldHeading;
  v26 = 0.2;
  if ( v25 <= 0.2 )
  {
    v26 = v25;
    if ( v25 < -0.2 )
      v26 = -0.2;
  }
  v27 = (float)((float)(v26 * 180.0) / 3.1416) * 10.0;
  FrameFromName = CClumpModelInfo::GetFrameFromName(this->m_pJetPackClump, "jetball1");
  if ( FrameFromName )
  {
    p_pos = &FrameFromName->modelling.pos;
    p_modelling = &FrameFromName->modelling;
    z = FrameFromName->modelling.pos.z;
    v43 = *(_QWORD *)&FrameFromName->modelling.pos.x;
    if ( this->m_nThrustStop )
    {
      v31 = (float)CTimer::m_snTimeInMilliseconds / 79.577;
      v32 = sinf(v31);
      v33 = cosf(v31) * 45.0;
      v2.n64_f32[0] = v32 * 45.0;
    }
    else
    {
      v5.n64_u32[0] = 0;
      v2.n64_f32[0] = this->m_fThrustStrafe * 45.0;
      v4.n64_u32[0] = 1119092736;
      v3.n64_f32[0] = v27 + (float)((float)(this->m_fThrustAngle * 180.0) / 3.1416);
      LODWORD(v33) = vmax_f32(v2, v5).n64_u32[0];
      v34.n64_u64[0] = vmin_f32(v3, v4).n64_u64[0];
      v3.n64_u32[0] = -1028390912;
      v2.n64_u64[0] = vmax_f32(v34, v3).n64_u64[0];
    }
    RwMatrixRotate(p_modelling, &CPedIK::XaxisIK, v2.n64_f32[0], rwCOMBINEREPLACE);
    RwMatrixRotate(p_modelling, &CPedIK::YaxisIK, v33, rwCOMBINEPRECONCAT);
    p_pos->z = z;
    *(_QWORD *)&p_pos->x = v43;
  }
  v35 = CClumpModelInfo::GetFrameFromName(this->m_pJetPackClump, "jetball2");
  if ( v35 )
  {
    v36 = &v35->modelling.pos;
    v37 = &v35->modelling;
    v46 = v35->modelling.pos.z;
    v44 = *(_QWORD *)&v35->modelling.pos.x;
    if ( this->m_nThrustStop )
    {
      v38 = (float)CTimer::m_snTimeInMilliseconds / 79.577;
      v39 = sinf(v38);
      v40 = cosf(v38) * 45.0;
      v41 = v39 * -45.0;
    }
    else
    {
      v5.n64_u32[0] = 0;
      v2.n64_f32[0] = this->m_fThrustStrafe * 45.0;
      v4.n64_u32[0] = 1119092736;
      v3.n64_f32[0] = (float)((float)(this->m_fThrustAngle * 180.0) / 3.1416) - v27;
      LODWORD(v40) = vmin_f32(v2, v5).n64_u32[0];
      v42.n64_u64[0] = vmin_f32(v3, v4).n64_u64[0];
      v3.n64_u32[0] = -1028390912;
      LODWORD(v41) = vmax_f32(v42, v3).n64_u32[0];
    }
    RwMatrixRotate(v37, &CPedIK::XaxisIK, v41, rwCOMBINEREPLACE);
    RwMatrixRotate(v37, &CPedIK::YaxisIK, v40, rwCOMBINEPRECONCAT);
    v36->z = v46;
    *(_QWORD *)&v36->x = v44;
  }
  RwFrameUpdateObjects((RwFrame_0 *)parent);
  RpClumpRender(this->m_pJetPackClump);
  CTaskSimpleJetPack::DoJetPackEffect(this, pPed);
LABEL_26:
  this->m_fOldHeading = pPed->m_fCurrentHeading;
}
// 5320B0: variable 'v2' is possibly undefined
// 5320B0: variable 'v5' is possibly undefined
// 5320B4: variable 'v3' is possibly undefined
// 5320B4: variable 'v4' is possibly undefined

//----- (00532244) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::DoJetPackEffect(CTaskSimpleJetPack *this, CPed *pPed)
{
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r0
  RwMatrix *v5; // r5
  FxSystem_c *v6; // r0
  FxSystem_c *v7; // r0
  char v8; // r0
  RwFrame_0 *FrameFromName; // r0
  RwMatrix *LTM; // r0
  RwFrame_0 *v11; // r0
  RwMatrix *v12; // r0
  float v13; // s2
  float m_fxKeyTime; // s0
  FxSystem_c *m_pFxSysL; // r0
  FxSystem_c *m_pFxSysR; // r0
  RwV3d_0 offsetPos; // [sp+4h] [bp-1Ch] BYREF

  m_pRwObject = pPed->m_pRwObject;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    v5 = (RwMatrix *)(parent + 16);
    if ( !this->m_pFxSysL )
    {
      memset(&offsetPos, 0, sizeof(offsetPos));
      v6 = FxManager_c::CreateFxSystem(&g_fxMan, "jetpack", &offsetPos, (RwMatrix *)(parent + 16), 0);
      this->m_pFxSysL = v6;
      if ( v6 )
      {
        FxSystem_c::Play(v6);
        FxSystem_c::SetLocalParticles(this->m_pFxSysL, 1u);
        FxSystem_c::CopyParentMatrix(this->m_pFxSysL);
        this->m_fxKeyTime = 0.0;
      }
    }
    if ( !this->m_pFxSysR )
    {
      memset(&offsetPos, 0, sizeof(offsetPos));
      v7 = FxManager_c::CreateFxSystem(&g_fxMan, "jetpack", &offsetPos, v5, 0);
      this->m_pFxSysR = v7;
      if ( v7 )
      {
        FxSystem_c::Play(v7);
        FxSystem_c::SetLocalParticles(this->m_pFxSysR, 1u);
        FxSystem_c::CopyParentMatrix(this->m_pFxSysR);
        this->m_fxKeyTime = 0.0;
      }
    }
  }
  v8 = `guard variable for'CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset;
  __dmb(0xBu);
  if ( (v8 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset) )
  {
    CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset.x = 0.0;
    CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset.y = 0.0;
    CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset.z = -0.15;
    _cxa_guard_release((__guard *)&`guard variable for'CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset);
  }
  if ( this->m_pFxSysL )
  {
    FrameFromName = CClumpModelInfo::GetFrameFromName(this->m_pJetPackClump, "jetball1");
    LTM = RwFrameGetLTM(FrameFromName);
    FxSystem_c::SetMatrix(this->m_pFxSysL, LTM);
    FxSystem_c::SetOffsetPos(this->m_pFxSysL, &CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset);
  }
  if ( this->m_pFxSysR )
  {
    v11 = CClumpModelInfo::GetFrameFromName(this->m_pJetPackClump, "jetball2");
    v12 = RwFrameGetLTM(v11);
    FxSystem_c::SetMatrix(this->m_pFxSysR, v12);
    FxSystem_c::SetOffsetPos(this->m_pFxSysR, &CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset);
  }
  if ( this->m_nThrustFwd )
  {
    v13 = 1.0;
  }
  else
  {
    v13 = 0.0;
    if ( this->m_fThrustStrafe != 0.0 )
      v13 = 1.0;
  }
  m_fxKeyTime = this->m_fxKeyTime;
  if ( m_fxKeyTime >= v13 )
  {
    if ( m_fxKeyTime > v13 )
    {
      m_fxKeyTime = m_fxKeyTime + -0.1;
      this->m_fxKeyTime = m_fxKeyTime;
      if ( m_fxKeyTime < 0.0 )
      {
        m_fxKeyTime = 0.0;
        this->m_fxKeyTime = 0.0;
      }
    }
  }
  else
  {
    m_fxKeyTime = m_fxKeyTime + 0.1;
    this->m_fxKeyTime = m_fxKeyTime;
    if ( m_fxKeyTime > 1.0 )
    {
      this->m_fxKeyTime = 1.0;
      m_fxKeyTime = 1.0;
    }
  }
  m_pFxSysL = this->m_pFxSysL;
  if ( m_pFxSysL )
    FxSystem_c::SetConstTime(m_pFxSysL, 1u, m_fxKeyTime);
  m_pFxSysR = this->m_pFxSysR;
  if ( m_pFxSysR )
    FxSystem_c::SetConstTime(m_pFxSysR, 1u, this->m_fxKeyTime);
}
// 9FF864: using guessed type char `guard variable for'CTaskSimpleJetPack::DoJetPackEffect(CPed *)::offset;

//----- (00532424) --------------------------------------------------------
void __fastcall CTaskComplexStuckInAir::CTaskComplexStuckInAir(CTaskComplexStuckInAir *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66CC5C;
}
// 532434: variable 'v1' is possibly undefined
// 66CC5C: using guessed type void *;

//----- (00532440) --------------------------------------------------------
void __fastcall CTaskComplexStuckInAir::~CTaskComplexStuckInAir(CTaskComplexStuckInAir *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 53244C: variable 'v1' is possibly undefined

//----- (00532450) --------------------------------------------------------
CTask *__fastcall CTaskComplexStuckInAir::CreateSubTask(
        CTaskComplexStuckInAir *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskComplex *v5; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v8; // s18
  float v9; // s20
  float v10; // s16
  char v11; // r0
  CMatrix *v12; // r1
  float v13; // s2
  float v14; // s4
  float v15; // s0
  float v16; // s4
  float v17; // s2
  float v18; // s0
  CTaskSimpleStandStill *v19; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  CTaskComplex *v21; // r0
  CTaskComplexFleePoint *v22; // r0
  CVector vFleePos; // [sp+4h] [bp-34h] BYREF

  result = 0;
  if ( iSubTaskType > 210 )
  {
    if ( iSubTaskType == 211 )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      *(_DWORD *)&pPed->m_nPedFlags |= 1u;
      *(_DWORD *)&m_pPedIntelligence->m_stuckChecker.m_nStuckCounter = 0;
      v21 = (CTaskComplex *)CTask::operator new(0x14u);
      CTaskComplex::CTaskComplex(v21);
      result[1].m_pParent = (CTask *)-1;
      result->_vptr$CTask = (int (**)(void))&off_66CBB8;
      LOBYTE(result[2]._vptr$CTask) = 0;
    }
    else if ( iSubTaskType == 908 )
    {
      *(_DWORD *)&pPed->m_nPedFlags |= 1u;
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v8 = p_tx->m_translate.x - (float)(m_pMat->xy * 0.5);
      v9 = p_tx->m_translate.y - (float)(m_pMat->yy * 0.5);
      v10 = p_tx->m_translate.z - (float)(m_pMat->zy * 0.5);
      vFleePos.y = v9;
      vFleePos.x = v8;
      vFleePos.z = v10;
      v11 = rand();
      v12 = pPed->m_pMat;
      v13 = v12->xx * 0.5;
      v14 = v12->yx * 0.5;
      v15 = v12->zx * 0.5;
      if ( (v11 & 1) != 0 )
      {
        v16 = v14 + v9;
        v17 = v13 + v8;
        v18 = v15 + v10;
      }
      else
      {
        v16 = v9 - v14;
        v17 = v8 - v13;
        v18 = v10 - v15;
      }
      vFleePos.y = v16;
      vFleePos.x = v17;
      vFleePos.z = v18;
      v22 = (CTaskComplexFleePoint *)CTask::operator new(0x3Cu);
      CTaskComplexFleePoint::CTaskComplexFleePoint(v22, &vFleePos, 0, 5.0, 10000);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    *(_DWORD *)&pPed->m_nPedFlags |= 1u;
    v19 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v19, 5000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 208 )
  {
    *(_DWORD *)&pPed->m_pPedIntelligence->m_stuckChecker.m_nStuckCounter = 0;
    v5 = (CTaskComplex *)CTask::operator new(0x18u);
    CTaskComplex::CTaskComplex(v5);
    result->_vptr$CTask = (int (**)(void))&off_66CA2C;
    result[1].m_pParent = (CTask *)(&off_18 + 2);
    result[2]._vptr$CTask = 0;
    result[2].m_pParent = (CTask *)(elf_hash_bucket + 748);
  }
  return result;
}
// 53248A: variable 'result' is possibly undefined
// 18: using guessed type int (*off_18)();
// FC: using guessed type int elf_hash_bucket[16411];
// 66CA2C: using guessed type void *off_66CA2C;
// 66CBB8: using guessed type void *off_66CBB8;

//----- (005325CC) --------------------------------------------------------
CTask *__fastcall CTaskComplexStuckInAir::CreateNextSubTask(CTaskComplexStuckInAir *this, CPed *pPed)
{
  int v3; // r0
  int v5; // r1
  CPlayerPedData *m_nStuck; // r0

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v3 > 210 )
  {
    if ( v3 == 211 )
    {
      m_nStuck = (CPlayerPedData *)pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck;
      if ( pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
      {
        v5 = 203;
      }
      else
      {
        m_nStuck = pPed->m_pPlayerData;
        v5 = 1302;
        if ( !m_nStuck )
          v5 = 908;
      }
      return CTaskComplexStuckInAir::CreateSubTask((CTaskComplexStuckInAir *)m_nStuck, v5, pPed);
    }
    if ( v3 != 908 )
      return 0;
  }
  else
  {
    if ( v3 == 203 )
    {
      m_nStuck = (CPlayerPedData *)pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck;
      if ( pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
      {
        m_nStuck = pPed->m_pPlayerData;
        v5 = 203;
        if ( !m_nStuck )
          v5 = 211;
      }
      else
      {
        v5 = 1302;
      }
      return CTaskComplexStuckInAir::CreateSubTask((CTaskComplexStuckInAir *)m_nStuck, v5, pPed);
    }
    if ( v3 != 208 )
      return 0;
  }
  v5 = 203;
  m_nStuck = (CPlayerPedData *)pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck;
  if ( !pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
    v5 = 1302;
  return CTaskComplexStuckInAir::CreateSubTask((CTaskComplexStuckInAir *)m_nStuck, v5, pPed);
}

//----- (0053264C) --------------------------------------------------------
CTask *__fastcall CTaskComplexStuckInAir::CreateFirstSubTask(CTaskComplexStuckInAir *this, CPed *pPed)
{
  int m_nStuck; // r2
  int v4; // r1

  m_nStuck = pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck;
  v4 = 203;
  if ( m_nStuck == 2 )
    v4 = 208;
  return CTaskComplexStuckInAir::CreateSubTask((CTaskComplexStuckInAir *)pPed, v4, pPed);
}

//----- (00532664) --------------------------------------------------------
CTask *__fastcall CTaskComplexStuckInAir::ControlSubTask(CTaskComplexStuckInAir *this, CPed *pPed)
{
  CTaskSimpleStandStill *m_pSubTask; // r6
  int v5; // r0
  int v6; // r0
  CPad *PadFromPlayer; // r8
  int PedWalkLeftRight; // r9
  int PedWalkUpDown; // r0
  float RadianAngleBetweenPoints; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v14; // r0
  CAnimBlendAssociation *v15; // r0
  CAnimBlendAssociation *v16; // r0
  CAnimBlendAssociation *v17; // r0
  CAnimBlendAssociation *v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  CTask *v23; // r0

  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  v5 = (*((int (__fastcall **)(CTaskSimpleStandStill *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask);
  if ( v5 > 210 )
  {
    if ( v5 == 211 )
    {
      if ( !pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
        goto LABEL_52;
      if ( !(*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask) )
        goto LABEL_52;
      v19 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask);
      if ( (*(int (__fastcall **)(int))(*(_DWORD *)v19 + 20))(v19) != 241 )
      {
        v20 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask);
        if ( !(*(int (__fastcall **)(int))(*(_DWORD *)v20 + 12))(v20) )
          goto LABEL_52;
        v21 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask);
        v22 = (*(int (__fastcall **)(int))(*(_DWORD *)v21 + 12))(v21);
        if ( (*(int (__fastcall **)(int))(*(_DWORD *)v22 + 20))(v22) != 241 )
          goto LABEL_52;
      }
    }
    else if ( v5 != 908 || !pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
    {
      goto LABEL_52;
    }
    *(_DWORD *)&pPed->m_nPedFlags |= 1u;
    m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 5000, 0, 0, 8.0);
    goto LABEL_52;
  }
  if ( v5 == 203 )
  {
    if ( pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
    {
      if ( pPed->m_pPlayerData )
      {
        PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
        PedWalkLeftRight = CPad::GetPedWalkLeftRight(PadFromPlayer);
        PedWalkUpDown = CPad::GetPedWalkUpDown(PadFromPlayer);
        if ( PedWalkUpDown | PedWalkLeftRight )
        {
          RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                       0.0,
                                       0.0,
                                       -(float)PedWalkLeftRight,
                                       (float)PedWalkUpDown);
          pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
        }
        if ( CPad::JumpJustDown(PadFromPlayer) )
        {
          m_pPedIntelligence = pPed->m_pPedIntelligence;
          *(_DWORD *)&pPed->m_nPedFlags |= 1u;
          *(_DWORD *)&m_pPedIntelligence->m_stuckChecker.m_nStuckCounter = 0;
          m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x14u);
          CTaskComplex::CTaskComplex((CTaskComplex *)m_pSubTask);
          m_pSubTask->m_timer.m_iStartTime = -1;
          m_pSubTask->_vptr$CTask = (int (**)(void))&off_66CBB8;
          LOBYTE(m_pSubTask->m_timer.m_iDuration) = 0;
        }
      }
      m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
      *(_DWORD *)&pPed->m_nPedFlags = *(_DWORD *)&pPed->m_nPedFlags & 0xFFFFFDFE | 1;
      Association = RpAnimBlendClumpGetAssociation(m_pRwObject, 0x74u);
      if ( Association && Association->m_fBlendAmount > 0.0 && Association->m_fBlendDelta >= 0.0 )
        Association->m_fBlendDelta = -8.0;
      v14 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x75u);
      if ( v14 && v14->m_fBlendAmount > 0.0 && v14->m_fBlendDelta >= 0.0 )
        v14->m_fBlendDelta = -8.0;
      v15 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x76u);
      if ( v15 && v15->m_fBlendAmount > 0.0 && v15->m_fBlendDelta >= 0.0 )
        v15->m_fBlendDelta = -8.0;
      v16 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x77u);
      if ( v16 && v16->m_fBlendAmount > 0.0 && v16->m_fBlendDelta >= 0.0 )
        v16->m_fBlendDelta = -8.0;
      v17 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x78u);
      if ( v17 && v17->m_fBlendAmount > 0.0 && v17->m_fBlendDelta >= 0.0 )
        v17->m_fBlendDelta = -8.0;
      v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x79u);
      if ( v18 && v18->m_fBlendAmount > 0.0 && v18->m_fBlendDelta >= 0.0 )
        v18->m_fBlendDelta = -8.0;
    }
    else
    {
      m_pSubTask = 0;
    }
  }
  else if ( v5 == 208 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask) )
    {
      v6 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask);
      if ( (*(int (__fastcall **)(int))(*(_DWORD *)v6 + 20))(v6) == 207
        && *(_BYTE *)((*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 3))(this->m_pSubTask)
                    + 8)
        && pPed->m_pPedIntelligence->m_stuckChecker.m_nStuck )
      {
        *(_DWORD *)&pPed->m_nPedFlags |= 1u;
      }
    }
  }
LABEL_52:
  v23 = this->m_pSubTask;
  if ( m_pSubTask != v23 )
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))v23->_vptr$CTask + 7))(v23, pPed, 1, 0);
  return m_pSubTask;
}
// 66CBB8: using guessed type void *off_66CBB8;

//----- (00532964) --------------------------------------------------------
CTask *__fastcall CTaskSimpleGetUp::Clone(const CTaskSimpleGetUp *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x10u);
  CTaskSimple::CTaskSimple(v1);
  LOWORD(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C988;
  return result;
}
// 532976: variable 'result' is possibly undefined
// 66C988: using guessed type void *off_66C988;

//----- (00532988) --------------------------------------------------------
int __fastcall CTaskSimpleGetUp::GetTaskType(const CTaskSimpleGetUp *this)
{
  return 205;
}

//----- (0053298C) --------------------------------------------------------
void __fastcall CTaskSimpleGetUp::Serialize(CTaskSimpleGetUp *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleGetUp *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleGetUp *))this->_vptr$CTask + 5))(this) != 205 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleGetUp *))this->_vptr$CTask + 5))(this);
    sub_1941C4(205, v4);
  }
}

//----- (005329F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetUpAndStandStill::Clone(const CTaskComplexGetUpAndStandStill *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66C9BC;
  return result;
}
// 532A0A: variable 'result' is possibly undefined
// 66C9BC: using guessed type void *off_66C9BC;

//----- (00532A14) --------------------------------------------------------
int __fastcall CTaskComplexGetUpAndStandStill::GetTaskType(const CTaskComplexGetUpAndStandStill *this)
{
  return 206;
}

//----- (00532A18) --------------------------------------------------------
void __fastcall CTaskComplexGetUpAndStandStill::Serialize(CTaskComplexGetUpAndStandStill *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexGetUpAndStandStill *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGetUpAndStandStill *))this->_vptr$CTask + 5))(this) != 206 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexGetUpAndStandStill *))this->_vptr$CTask + 5))(this);
    sub_1941C4(206, v4);
  }
}

//----- (00532A80) --------------------------------------------------------
CTask *__fastcall CTaskSimpleFall::Clone(const CTaskSimpleFall *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  int (**m_nPauseLength)(void); // r4
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_animID;
  m_nPauseLength = (int (**)(void))this->m_nPauseLength;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = 0;
  *(_QWORD *)&result[1].m_pParent = v3;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = m_nPauseLength;
  result[3].m_pParent = (CTask *)m_nPauseLength;
  result->_vptr$CTask = (int (**)(void))&off_66C9F8;
  return result;
}
// 532A9E: variable 'result' is possibly undefined
// 66C9F8: using guessed type void *off_66C9F8;

//----- (00532ABC) --------------------------------------------------------
int __fastcall CTaskSimpleFall::GetTaskType(const CTaskSimpleFall *this)
{
  return 207;
}

//----- (00532AC0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndGetUp::Clone(const CTaskComplexFallAndGetUp *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *m_iDownTime; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  v3 = *(_QWORD *)&this->m_animID;
  m_iDownTime = (CTask *)this->m_iDownTime;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  result[2].m_pParent = m_iDownTime;
  result->_vptr$CTask = (int (**)(void))&off_66CA2C;
  return result;
}
// 532ADC: variable 'result' is possibly undefined
// 66CA2C: using guessed type void *off_66CA2C;

//----- (00532AF4) --------------------------------------------------------
int __fastcall CTaskComplexFallAndGetUp::GetTaskType(const CTaskComplexFallAndGetUp *this)
{
  return 208;
}

//----- (00532AF8) --------------------------------------------------------
void __fastcall CTaskComplexFallAndGetUp::Serialize(CTaskComplexFallAndGetUp *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexFallAndGetUp *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFallAndGetUp *))this->_vptr$CTask + 5))(this) == 208 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_animID;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = this->m_animGroup;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iDownTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    j_free(v6);
  }
  else
  {
    v7 = (*((int (__fastcall **)(CTaskComplexFallAndGetUp *))this->_vptr$CTask + 5))(this);
    sub_1941C4(208, v7);
  }
}

//----- (00532BEC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallAndStayDown::Clone(const CTaskComplexFallAndStayDown *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_animID;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  result->_vptr$CTask = (int (**)(void))&off_66CA68;
  return result;
}
// 532C02: variable 'result' is possibly undefined
// 66CA68: using guessed type void *off_66CA68;

//----- (00532C14) --------------------------------------------------------
int __fastcall CTaskComplexFallAndStayDown::GetTaskType(const CTaskComplexFallAndStayDown *this)
{
  return 209;
}

//----- (00532C18) --------------------------------------------------------
void __fastcall CTaskComplexFallAndStayDown::Serialize(CTaskComplexFallAndStayDown *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  AnimationId m_animID; // r6
  _DWORD *v5; // r5
  AssocGroupId m_animGroup; // r5
  _DWORD *v7; // r4
  int v8; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexFallAndStayDown *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFallAndStayDown *))this->_vptr$CTask + 5))(this) == 209 )
  {
    m_animID = this->m_animID;
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = m_animID;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    m_animGroup = this->m_animGroup;
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = m_animGroup;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexFallAndStayDown *))this->_vptr$CTask + 5))(this);
    sub_1941C4(209, v8);
  }
}

//----- (00532CDC) --------------------------------------------------------
CTask *__fastcall CTaskComplexInAirAndLand::Clone(const CTaskComplexInAirAndLand *this)
{
  CTaskComplex *v2; // r0
  int m_bIsJumping; // r5
  int m_bIsFallingToDeath; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_bIsJumping = this->m_bIsJumping;
  m_bIsFallingToDeath = this->m_bIsFallingToDeath;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[1].m_pParent) = m_bIsJumping != 0;
  BYTE1(result[1].m_pParent) = m_bIsFallingToDeath != 0;
  BYTE2(result[1].m_pParent) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66CAA4;
  return result;
}
// 532CFC: variable 'result' is possibly undefined
// 66CAA4: using guessed type void *off_66CAA4;

//----- (00532D14) --------------------------------------------------------
int __fastcall CTaskComplexInAirAndLand::GetTaskType(const CTaskComplexInAirAndLand *this)
{
  return 240;
}

//----- (00532D18) --------------------------------------------------------
void __fastcall CTaskComplexInAirAndLand::Serialize(CTaskComplexInAirAndLand *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexInAirAndLand *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexInAirAndLand *))this->_vptr$CTask + 5))(this) == 240 )
  {
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bIsJumping, 1);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bIsFallingToDeath, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskComplexInAirAndLand *))this->_vptr$CTask + 5))(this);
    sub_1941C4(240, v4);
  }
}

//----- (00532DC0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleInAir::Clone(const CTaskSimpleInAir *this)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0
  int m_pParent_low; // r3

  v2 = (CTaskSimple *)CTask::operator new(0x3Cu);
  LOBYTE(this) = *((_BYTE *)this + 36);
  CTaskSimple::CTaskSimple(v2);
  *(int (***)(void))((char *)&result[6]._vptr$CTask + 2) = 0;
  *(CTask **)((char *)&result[5].m_pParent + 2) = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  result[7]._vptr$CTask = 0;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  m_pParent_low = LOBYTE(result[4].m_pParent);
  result->_vptr$CTask = (int (**)(void))&off_66CAE0;
  LOBYTE(result[4].m_pParent) = (unsigned __int8)this & 7 | m_pParent_low & 0xF8;
  result[5].m_pParent = (CTask *)CTimer::m_snTimeInMilliseconds;
  result[6]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 248);
  LOBYTE(result[6].m_pParent) = 1;
  return result;
}
// 532DDC: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 66CAE0: using guessed type void *off_66CAE0;

//----- (00532E24) --------------------------------------------------------
int __fastcall CTaskSimpleInAir::GetTaskType(const CTaskSimpleInAir *this)
{
  return 241;
}

//----- (00532E28) --------------------------------------------------------
void __fastcall CTaskSimpleInAir::Serialize(CTaskSimpleInAir *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0
  bool v5; // [sp+5h] [bp-13h] BYREF
  bool v6; // [sp+6h] [bp-12h] BYREF
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleInAir *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleInAir *))this->_vptr$CTask + 5))(this) == 241 )
  {
    pData[0] = *((_BYTE *)this + 36) & 1;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
    v6 = (*((_BYTE *)this + 36) & 2) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&v6, 1);
    v5 = (*((_BYTE *)this + 36) & 4) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&v5, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleInAir *))this->_vptr$CTask + 5))(this);
    sub_1941C4(241, v4);
  }
}
// 532E28: using guessed type char pData[17];

//----- (00532F14) --------------------------------------------------------
CTask *__fastcall CTaskSimpleLand::Clone(const CTaskSimpleLand *this)
{
  CTaskSimple *v2; // r0
  CTask *m_animID; // r4
  CTask *result; // r0
  char v5; // r2
  char v6; // r3

  v2 = (CTaskSimple *)CTask::operator new(0x14u);
  m_animID = (CTask *)this->m_animID;
  CTaskSimple::CTaskSimple(v2);
  v5 = 0;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = m_animID;
  v6 = (char)result[2]._vptr$CTask;
  result->_vptr$CTask = (int (**)(void))&off_66CB14;
  if ( m_animID == (CTask *)-1 )
    v5 = 1;
  LOBYTE(result[2]._vptr$CTask) = v6 & 0xF8 | (2 * v5) | 4;
  return result;
}
// 532F2A: variable 'result' is possibly undefined
// 66CB14: using guessed type void *off_66CB14;

//----- (00532F54) --------------------------------------------------------
int __fastcall CTaskSimpleLand::GetTaskType(const CTaskSimpleLand *this)
{
  return 242;
}

//----- (00532F58) --------------------------------------------------------
void __fastcall CTaskSimpleLand::Serialize(CTaskSimpleLand *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleLand *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleLand *))this->_vptr$CTask + 5))(this) == 242 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_animID;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleLand *))this->_vptr$CTask + 5))(this);
    sub_1941C4(242, v5);
  }
}

//----- (00532FF0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFallToDeath::Clone(const CTaskComplexFallToDeath *this)
{
  CTaskComplex *v2; // r0
  uint8 m_NudgeDir; // r5
  char v4; // r6
  CTask *result; // r0
  __int64 v6; // r2
  __int64 v7; // d16
  char v8; // r1

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  m_NudgeDir = this->m_NudgeDir;
  v4 = *((_BYTE *)this + 33);
  CTaskComplex::CTaskComplex(v2);
  HIDWORD(v6) = -1;
  result->_vptr$CTask = (int (**)(void))&off_66CB48;
  v7 = *(_QWORD *)&this->m_NudgeVec.x;
  *(RwReal *)&v6 = this->m_NudgeVec.z;
  v8 = BYTE1(result[4]._vptr$CTask) & 0xE0;
  *(_QWORD *)&result[2].m_pParent = v6;
  result[3].m_pParent = (CTask *)-1;
  LOBYTE(result[4]._vptr$CTask) = m_NudgeDir;
  BYTE1(result[4]._vptr$CTask) = v8 | v4 & 0x18;
  *(_QWORD *)&result[1].m_pParent = v7;
  return result;
}
// 533018: variable 'result' is possibly undefined
// 66CB48: using guessed type void *off_66CB48;

//----- (0053304C) --------------------------------------------------------
int __fastcall CTaskComplexFallToDeath::GetTaskType(const CTaskComplexFallToDeath *this)
{
  return 277;
}

//----- (00533054) --------------------------------------------------------
void __fastcall CTaskComplexFallToDeath::Serialize(CTaskComplexFallToDeath *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  __int64 v5; // d16
  int v6; // r0
  bool v7; // [sp+6h] [bp-12h] BYREF
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v2 = (*((int (__fastcall **)(CTaskComplexFallToDeath *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFallToDeath *))this->_vptr$CTask + 5))(this) == 277 )
  {
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_NudgeDir, 1);
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(0xCu);
    v5 = *(_QWORD *)&this->m_NudgeVec.x;
    v4[2] = LODWORD(this->m_NudgeVec.z);
    *(_QWORD *)v4 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 12);
    free(v4);
    pData[0] = (*((_BYTE *)this + 33) & 8) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
    v7 = (*((_BYTE *)this + 33) & 0x10) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&v7, 1);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexFallToDeath *))this->_vptr$CTask + 5))(this);
    sub_1941C4(277, v6);
  }
}
// 533054: using guessed type char pData[17];

//----- (00533174) --------------------------------------------------------
CTask *__fastcall CTaskSimpleJump::Clone(const CTaskSimpleJump *this)
{
  CTaskSimple *v2; // r0
  bool m_bForceEdgeSearch; // r5
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x2Cu);
  m_bForceEdgeSearch = this->m_bForceEdgeSearch;
  CTaskSimple::CTaskSimple(v2);
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  LOBYTE(result[4].m_pParent) = m_bForceEdgeSearch;
  BYTE1(result[4].m_pParent) = 0;
  result[5]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66CB84;
  BYTE1(result[4].m_pParent) = this->m_bUsePlayerLaunchForce;
  return result;
}
// 53318C: variable 'result' is possibly undefined
// 66CB84: using guessed type void *off_66CB84;

//----- (005331B0) --------------------------------------------------------
int __fastcall CTaskSimpleJump::GetTaskType(const CTaskSimpleJump *this)
{
  return 210;
}

//----- (005331B4) --------------------------------------------------------
void __fastcall CTaskSimpleJump::Serialize(CTaskSimpleJump *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleJump *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleJump *))this->_vptr$CTask + 5))(this) == 210 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bForceEdgeSearch, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleJump *))this->_vptr$CTask + 5))(this);
    sub_1941C4(210, v4);
  }
}

//----- (0053323C) --------------------------------------------------------
CTask *__fastcall CTaskComplexJump::Clone(const CTaskComplexJump *this)
{
  CTaskComplex *v2; // r0
  CTask *m_nForceClimb; // r5
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  m_nForceClimb = (CTask *)this->m_nForceClimb;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_nForceClimb;
  LOBYTE(result[2]._vptr$CTask) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66CBB8;
  LOBYTE(result[2]._vptr$CTask) = this->m_bUsePlayerLaunchForce;
  return result;
}
// 533252: variable 'result' is possibly undefined
// 66CBB8: using guessed type void *off_66CBB8;

//----- (00533268) --------------------------------------------------------
int __fastcall CTaskComplexJump::GetTaskType(const CTaskComplexJump *this)
{
  return 211;
}

//----- (0053326C) --------------------------------------------------------
void __fastcall CTaskComplexJump::Serialize(CTaskComplexJump *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexJump *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexJump *))this->_vptr$CTask + 5))(this) == 211 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_nForceClimb;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexJump *))this->_vptr$CTask + 5))(this);
    sub_1941C4(211, v5);
  }
}

//----- (00533304) --------------------------------------------------------
CTask *__fastcall CTaskSimpleClimb::Clone(const CTaskSimpleClimb *this)
{
  void *v2; // r4
  uint8 m_nSurfaceType; // r11
  float m_fHandholdHeading; // r10
  CEntity *m_pClimbEnt; // r9
  CEntity *v6; // r0
  CVector *p_m_vecHandholdPos; // r5
  __int64 v8; // d16
  CTask *result; // r0
  int8 m_nHeightForAnim; // [sp+4h] [bp-24h]
  bool m_bForceClimb; // [sp+8h] [bp-20h]

  v2 = CTask::operator new(0x30u);
  m_bForceClimb = this->m_bForceClimb;
  m_nHeightForAnim = this->m_nHeightForAnim;
  m_nSurfaceType = this->m_nSurfaceType;
  m_fHandholdHeading = this->m_fHandholdHeading;
  m_pClimbEnt = this->m_pClimbEnt;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_WORD *)v2 + 4) = 0;
  *((_BYTE *)v2 + 10) = 0;
  *((_BYTE *)v2 + 12) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *(_DWORD *)v2 = &off_66CBF4;
  *((_DWORD *)v2 + 9) = m_pClimbEnt;
  CWidgetHelpText::ConditionSatisfied(0x400u);
  v6 = (CEntity *)*((_DWORD *)v2 + 9);
  p_m_vecHandholdPos = &this->m_vecHandholdPos;
  if ( v6 )
    CEntity::RegisterReference(v6, (CEntity **)v2 + 9);
  v8 = *(_QWORD *)&p_m_vecHandholdPos->x;
  *((_DWORD *)v2 + 8) = LODWORD(p_m_vecHandholdPos->z);
  *((_QWORD *)v2 + 3) = v8;
  *((_BYTE *)v2 + 15) = m_nSurfaceType;
  *((float *)v2 + 5) = m_fHandholdHeading;
  *((_BYTE *)v2 + 13) = m_nHeightForAnim;
  *((_BYTE *)v2 + 11) = m_bForceClimb;
  *((_BYTE *)v2 + 14) = 0;
  *((_BYTE *)v2 + 16) = -1;
  result = (CTask *)v2;
  *((_WORD *)v2 + 20) = 0;
  return result;
}
// 66CBF4: using guessed type void *off_66CBF4;

//----- (005333A8) --------------------------------------------------------
int __fastcall CTaskSimpleClimb::GetTaskType(const CTaskSimpleClimb *this)
{
  return 254;
}

//----- (005333AC) --------------------------------------------------------
void __fastcall CTaskSimpleClimb::Serialize(CTaskSimpleClimb *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pClimbEnt; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5
  __int64 v15; // d16
  float *v16; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleClimb *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleClimb *))this->_vptr$CTask + 5))(this) != 202 )
  {
    v10 = (*((int (__fastcall **)(CTaskSimpleClimb *))this->_vptr$CTask + 5))(this);
    sub_1941C4(202, v10);
    return;
  }
  m_pClimbEnt = this->m_pClimbEnt;
  if ( !m_pClimbEnt )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_20;
  }
  v5 = *(_BYTE *)&m_pClimbEnt->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pClimbEnt;
  v8 = *(_BYTE *)&v7->m_info & 7;
  switch ( v8 )
  {
    case 2:
      v9 = GettPoolVehicleRef((CVehicle *)v7);
      goto LABEL_17;
    case 4:
      v9 = GettPoolObjRef((CObject *)v7);
      goto LABEL_17;
    case 3:
      v9 = GettPoolPedRef((CPed *)v7);
LABEL_17:
      if ( UseDataFence )
        AddDataFence();
      v13 = malloc(4u);
      *v13 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v12 = v13;
LABEL_20:
      free(v12);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(0xCu);
  v15 = *(_QWORD *)&this->m_vecHandholdPos.x;
  v14[2] = LODWORD(this->m_vecHandholdPos.z);
  *(_QWORD *)v14 = v15;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
  free(v14);
  if ( UseDataFence )
    AddDataFence();
  v16 = (float *)malloc(4u);
  *v16 = this->m_fHandholdHeading;
  CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
  free(v16);
  if ( UseDataFence )
    AddDataFence();
  CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_nSurfaceType, 1);
  if ( UseDataFence )
    AddDataFence();
  CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_nHeightForAnim, 1);
  if ( UseDataFence )
    AddDataFence();
  sub_19E9A8(&this->m_bForceClimb, 1);
}

//----- (005335A0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleJetPack::Clone(const CTaskSimpleJetPack *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CEntity *m_pTargetEnt; // r8
  CTaskSimple v6; // d16
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x70u);
  v3 = *(_QWORD *)&this->m_fCruiseHeight;
  v4 = v2;
  m_pTargetEnt = this->m_pTargetEnt;
  CTaskSimple::CTaskSimple(v2);
  v4[8] = 0LL;
  v4[9] = 0LL;
  v4[6] = 0LL;
  v4[7] = 0LL;
  v4[4] = 0LL;
  v4[5] = 0LL;
  v4[2] = 0LL;
  v4[3] = 0LL;
  LOBYTE(v4[1].m_pParent) = 0;
  v4[1]._vptr$CTask = 0;
  v4[10]._vptr$CTask = 0;
  *(_QWORD *)&v4[10].m_pParent = v3;
  v4[11].m_pParent = 0;
  *(_WORD *)((char *)&v4[1].m_pParent + 1) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66CC28;
  v4[12]._vptr$CTask = (int (**)(void))m_pTargetEnt;
  if ( m_pTargetEnt )
    CEntity::RegisterReference(m_pTargetEnt, (CEntity **)&v4[12]);
  v6 = *(CTaskSimple *)&this->m_vecTargetPos.x;
  v4[10]._vptr$CTask = (int (**)(void))LODWORD(this->m_vecTargetPos.z);
  result = v4;
  v4[9] = v6;
  v4[12].m_pParent = 0;
  v4[13]._vptr$CTask = 0;
  return result;
}
// 66CC28: using guessed type void *off_66CC28;

//----- (0053363C) --------------------------------------------------------
int __fastcall CTaskSimpleJetPack::GetTaskType(const CTaskSimpleJetPack *this)
{
  return 1303;
}

//----- (00533644) --------------------------------------------------------
void __fastcall CTaskSimpleJetPack::Serialize(CTaskSimpleJetPack *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  __int64 v5; // d16
  float *v6; // r5
  _DWORD *v7; // r5
  CEntity *m_pTargetEnt; // r0
  int v9; // r6
  _DWORD *v10; // r5
  CEntity *v11; // r0
  int v12; // r1
  int v13; // r4
  int v14; // r0
  _DWORD *v15; // r4
  _DWORD *v16; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleJetPack *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleJetPack *))this->_vptr$CTask + 5))(this) == 1303 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(0xCu);
    v5 = *(_QWORD *)&this->m_vecTargetPos.x;
    v4[2] = LODWORD(this->m_vecTargetPos.z);
    *(_QWORD *)v4 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 12);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v6 = (float *)malloc(4u);
    *v6 = this->m_fCruiseHeight;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = this->m_nHoverTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    m_pTargetEnt = this->m_pTargetEnt;
    if ( m_pTargetEnt )
    {
      v9 = *(_BYTE *)&m_pTargetEnt->m_info & 7;
      if ( UseDataFence )
        AddDataFence();
      v10 = malloc(4u);
      *v10 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
      free(v10);
      v11 = this->m_pTargetEnt;
      v12 = *(_BYTE *)&v11->m_info & 7;
      switch ( v12 )
      {
        case 2:
          v13 = GettPoolVehicleRef((CVehicle *)v11);
          break;
        case 4:
          v13 = GettPoolObjRef((CObject *)v11);
          break;
        case 3:
          v13 = GettPoolPedRef((CPed *)v11);
          break;
        default:
          return;
      }
      if ( UseDataFence )
        AddDataFence();
      v16 = malloc(4u);
      *v16 = v13;
      CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
      j_free(v16);
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v15 = malloc(4u);
      *v15 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
      j_free(v15);
    }
  }
  else
  {
    v14 = (*((int (__fastcall **)(CTaskSimpleJetPack *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1303, v14);
  }
}

//----- (00533818) --------------------------------------------------------
CTask *__fastcall CTaskComplexStuckInAir::Clone(const CTaskComplexStuckInAir *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66CC5C;
  return result;
}
// 53382E: variable 'result' is possibly undefined
// 66CC5C: using guessed type void *off_66CC5C;

//----- (00533838) --------------------------------------------------------
int __fastcall CTaskComplexStuckInAir::GetTaskType(const CTaskComplexStuckInAir *this)
{
  return 515;
}

//----- (00533840) --------------------------------------------------------
void __fastcall CTaskComplexStuckInAir::Serialize(CTaskComplexStuckInAir *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexStuckInAir *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexStuckInAir *))this->_vptr$CTask + 5))(this) != 515 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexStuckInAir *))this->_vptr$CTask + 5))(this);
    sub_1941C4(515, v4);
  }
}

//----- (005338B0) --------------------------------------------------------
void __fastcall CTaskManager::CTaskManager(CTaskManager *this, CPed *pPed)
{
  this->m_pPed = pPed;
  *(_QWORD *)&this->m_tasksSecondary[2] = 0LL;
  *(_QWORD *)&this->m_tasksSecondary[4] = 0LL;
  *(_QWORD *)this->m_tasks = 0LL;
  *(_QWORD *)&this->m_tasks[2] = 0LL;
  *(_QWORD *)&this->m_tasks[4] = 0LL;
  *(_QWORD *)&this->m_tasksSecondary[1] = 0LL;
}

//----- (005338CA) --------------------------------------------------------
void __fastcall CTaskManager::~CTaskManager(CTaskManager *this)
{
  CTask *v2; // r0
  CTask *v3; // r0
  CTask *v4; // r0
  CTask *v5; // r0
  CTask *v6; // r0
  CTask *v7; // r0
  CTask *v8; // r0
  CTask *v9; // r0
  CTask *v10; // r0
  CTask *v11; // r0
  CTask *v12; // r0

  v2 = this->m_tasks[0];
  if ( v2 )
    (*((void (__fastcall **)(CTask *))v2->_vptr$CTask + 1))(v2);
  v3 = this->m_tasks[1];
  this->m_tasks[0] = 0;
  if ( v3 )
    (*((void (__fastcall **)(CTask *))v3->_vptr$CTask + 1))(v3);
  v4 = this->m_tasks[2];
  this->m_tasks[1] = 0;
  if ( v4 )
    (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 1))(v4);
  v5 = this->m_tasks[3];
  this->m_tasks[2] = 0;
  if ( v5 )
    (*((void (__fastcall **)(CTask *))v5->_vptr$CTask + 1))(v5);
  v6 = this->m_tasks[4];
  this->m_tasks[3] = 0;
  if ( v6 )
    (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
  v7 = this->m_tasksSecondary[0];
  this->m_tasks[4] = 0;
  if ( v7 )
    (*((void (__fastcall **)(CTask *))v7->_vptr$CTask + 1))(v7);
  v8 = this->m_tasksSecondary[1];
  this->m_tasksSecondary[0] = 0;
  if ( v8 )
    (*((void (__fastcall **)(CTask *))v8->_vptr$CTask + 1))(v8);
  v9 = this->m_tasksSecondary[2];
  this->m_tasksSecondary[1] = 0;
  if ( v9 )
    (*((void (__fastcall **)(CTask *))v9->_vptr$CTask + 1))(v9);
  v10 = this->m_tasksSecondary[3];
  this->m_tasksSecondary[2] = 0;
  if ( v10 )
    (*((void (__fastcall **)(CTask *))v10->_vptr$CTask + 1))(v10);
  v11 = this->m_tasksSecondary[4];
  this->m_tasksSecondary[3] = 0;
  if ( v11 )
    (*((void (__fastcall **)(CTask *))v11->_vptr$CTask + 1))(v11);
  v12 = this->m_tasksSecondary[5];
  this->m_tasksSecondary[4] = 0;
  if ( v12 )
    (*((void (__fastcall **)(CTask *))v12->_vptr$CTask + 1))(v12);
  this->m_tasksSecondary[5] = 0;
}

//----- (0053397A) --------------------------------------------------------
void __fastcall CTaskManager::SetTask(CTaskManager *this, CTask *pTask, const int iPriority, const bool bForceNewTask)
{
  CTask *v6; // r0
  CTask *v7; // r6
  int v8; // r0
  CTask *v9; // r4
  CTask *v10; // r0
  CTask *v11; // r4
  CTask *v12; // r0

  v6 = this->m_tasks[iPriority];
  v7 = pTask;
  if ( pTask )
  {
    if ( v6 != pTask )
    {
      if ( v6 )
        (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
      this->m_tasks[iPriority] = v7;
      if ( v7 )
      {
        if ( !(*((int (__fastcall **)(CTask *))v7->_vptr$CTask + 4))(v7) )
        {
          while ( 1 )
          {
            v8 = (*((int (__fastcall **)(CTask *, CPed *))v7->_vptr$CTask + 11))(v7, this->m_pPed);
            v9 = (CTask *)v8;
            if ( !v8 )
              break;
            (*((void (__fastcall **)(CTask *, int))v7->_vptr$CTask + 9))(v7, v8);
            v7 = v9;
            if ( (*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 4))(v9) == 1 )
              goto LABEL_14;
          }
          CTaskManager::SetNextSubTask(this, v7->m_pParent);
        }
LABEL_14:
        v10 = this->m_tasks[iPriority];
        if ( v10 )
        {
          do
          {
            v11 = v10;
            v10 = (CTask *)(*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 3))(v10);
          }
          while ( v10 );
          if ( !(*((int (__fastcall **)(CTask *))v11->_vptr$CTask + 4))(v11) )
          {
            v12 = this->m_tasks[iPriority];
            if ( v12 )
              (*((void (__fastcall **)(CTask *))v12->_vptr$CTask + 1))(v12);
            this->m_tasks[iPriority] = 0;
          }
        }
      }
    }
  }
  else if ( v6 )
  {
    (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
    this->m_tasks[iPriority] = 0;
  }
}
// 5339EE: conditional instruction was optimized away because r1.4==0

//----- (00533A32) --------------------------------------------------------
void __fastcall CTaskManager::AddSubTasks(CTaskManager *this, CTask *pTask)
{
  CTask *v2; // r5
  int v4; // r0
  CTask *v5; // r6

  v2 = pTask;
  if ( pTask && !(*((int (__fastcall **)(CTask *))pTask->_vptr$CTask + 4))(pTask) )
  {
    while ( 1 )
    {
      v4 = (*((int (__fastcall **)(CTask *, CPed *))v2->_vptr$CTask + 11))(v2, this->m_pPed);
      v5 = (CTask *)v4;
      if ( !v4 )
        break;
      (*((void (__fastcall **)(CTask *, int))v2->_vptr$CTask + 9))(v2, v4);
      v2 = v5;
      if ( (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 4))(v5) == 1 )
        return;
    }
    CTaskManager::SetNextSubTask(this, v2->m_pParent);
  }
}

//----- (00533A84) --------------------------------------------------------
CTask *__fastcall CTaskManager::GetSimplestTask(CTask *pTask)
{
  CTask *v1; // r4

  if ( !pTask )
    return 0;
  do
  {
    v1 = pTask;
    pTask = (CTask *)(*((int (__fastcall **)(CTask *))pTask->_vptr$CTask + 3))(pTask);
  }
  while ( pTask );
  return v1;
}

//----- (00533AA2) --------------------------------------------------------
CTask *__fastcall CTaskManager::GetActiveTask(const CTaskManager *this)
{
  CTask *v1; // r1
  bool v2; // zf
  bool v4; // zf

  v1 = this->m_tasks[0];
  v2 = this->m_tasks[0] == 0;
  if ( !this->m_tasks[0] )
  {
    v1 = this->m_tasks[1];
    v2 = v1 == 0;
  }
  if ( !v2 )
    return v1;
  v1 = this->m_tasks[2];
  v4 = v1 == 0;
  if ( !v1 )
  {
    v1 = this->m_tasks[3];
    v4 = v1 == 0;
  }
  if ( v4 )
    return this->m_tasks[4];
  else
    return v1;
}

//----- (00533AC2) --------------------------------------------------------
CTask *__fastcall CTaskManager::GetSimplestActiveTask(const CTaskManager *this)
{
  CTask *v2; // r0
  bool v3; // zf
  CTask *v4; // r4
  bool v6; // zf

  v2 = this->m_tasks[0];
  v3 = v2 == 0;
  if ( !v2 )
  {
    v2 = this->m_tasks[1];
    v3 = v2 == 0;
  }
  if ( v3 )
  {
    v2 = this->m_tasks[2];
    v6 = v2 == 0;
    if ( !v2 )
    {
      v2 = this->m_tasks[3];
      v6 = v2 == 0;
    }
    if ( v6 )
    {
      v2 = this->m_tasks[4];
      if ( !v2 )
        return 0;
    }
  }
  do
  {
    v4 = v2;
    v2 = (CTask *)(*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 3))(v2);
  }
  while ( v2 );
  return v4;
}

//----- (00533AFE) --------------------------------------------------------
CTask *__fastcall CTaskManager::GetSimplestTask(const CTaskManager *this, const int iPriority)
{
  CTask *v2; // r0
  CTask *v3; // r4

  v2 = this->m_tasks[iPriority];
  if ( !v2 )
    return 0;
  do
  {
    v3 = v2;
    v2 = (CTask *)(*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 3))(v2);
  }
  while ( v2 );
  return v3;
}

//----- (00533B20) --------------------------------------------------------
CTask *__fastcall CTaskManager::FindActiveTaskByType(const CTaskManager *this, const int iTaskType)
{
  CTask *v4; // r5
  bool v5; // zf
  CTask *v6; // r6
  int v7; // r0
  CTask *v8; // r5
  CTask *v9; // r5
  CTask *v10; // r5
  CTask *v11; // r5
  CTask *v12; // r5
  CTask *v13; // r5
  bool v15; // zf

  v4 = this->m_tasks[0];
  v5 = this->m_tasks[0] == 0;
  if ( !this->m_tasks[0] )
  {
    v4 = this->m_tasks[1];
    v5 = v4 == 0;
  }
  if ( v5 )
  {
    v4 = this->m_tasks[2];
    v15 = v4 == 0;
    if ( !v4 )
    {
      v4 = this->m_tasks[3];
      v15 = v4 == 0;
    }
    if ( v15 )
    {
      v4 = this->m_tasks[4];
      if ( !v4 )
        goto LABEL_9;
    }
  }
  do
  {
    v6 = v4;
    if ( (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 5))(v4) != iTaskType )
      v6 = 0;
    v7 = (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 3))(v4);
    v4 = (CTask *)v7;
  }
  while ( !v6 && v7 );
  if ( !v6 )
  {
LABEL_9:
    v8 = this->m_tasksSecondary[0];
    v6 = 0;
    do
    {
      if ( !v8 )
        break;
      v6 = 0;
      if ( (*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 5))(v8) == iTaskType )
        v6 = v8;
      v8 = (CTask *)(*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 3))(v8);
    }
    while ( !v6 );
    if ( !v6 )
    {
      v9 = this->m_tasksSecondary[1];
      do
      {
        if ( !v9 )
          break;
        v6 = v9;
        if ( (*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 5))(v9) != iTaskType )
          v6 = 0;
        v9 = (CTask *)(*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 3))(v9);
      }
      while ( !v6 );
    }
    if ( !v6 )
    {
      v10 = this->m_tasksSecondary[2];
      do
      {
        if ( !v10 )
          break;
        v6 = v10;
        if ( (*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 5))(v10) != iTaskType )
          v6 = 0;
        v10 = (CTask *)(*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 3))(v10);
      }
      while ( !v6 );
    }
    if ( !v6 )
    {
      v11 = this->m_tasksSecondary[3];
      do
      {
        if ( !v11 )
          break;
        v6 = v11;
        if ( (*((int (__fastcall **)(CTask *))v11->_vptr$CTask + 5))(v11) != iTaskType )
          v6 = 0;
        v11 = (CTask *)(*((int (__fastcall **)(CTask *))v11->_vptr$CTask + 3))(v11);
      }
      while ( !v6 );
    }
    if ( !v6 )
    {
      v12 = this->m_tasksSecondary[4];
      do
      {
        if ( !v12 )
          break;
        v6 = v12;
        if ( (*((int (__fastcall **)(CTask *))v12->_vptr$CTask + 5))(v12) != iTaskType )
          v6 = 0;
        v12 = (CTask *)(*((int (__fastcall **)(CTask *))v12->_vptr$CTask + 3))(v12);
      }
      while ( !v6 );
    }
    if ( !v6 )
    {
      v13 = this->m_tasksSecondary[5];
      do
      {
        if ( !v13 )
          break;
        v6 = v13;
        if ( (*((int (__fastcall **)(CTask *))v13->_vptr$CTask + 5))(v13) != iTaskType )
          v6 = 0;
        v13 = (CTask *)(*((int (__fastcall **)(CTask *))v13->_vptr$CTask + 3))(v13);
      }
      while ( !v6 );
    }
  }
  return v6;
}

//----- (00533C70) --------------------------------------------------------
CTask *__fastcall CTaskManager::FindTaskByType(const CTaskManager *this, const int iPriority, const int iTaskType)
{
  CTask *v3; // r5
  CTask *v5; // r6

  v3 = this->m_tasks[iPriority];
  v5 = 0;
  do
  {
    if ( !v3 )
      break;
    v5 = 0;
    if ( (*((int (__fastcall **)(CTask *))v3->_vptr$CTask + 5))(v3) == iTaskType )
      v5 = v3;
    v3 = (CTask *)(*((int (__fastcall **)(CTask *))v3->_vptr$CTask + 3))(v3);
  }
  while ( !v5 );
  return v5;
}

//----- (00533CAA) --------------------------------------------------------
void __fastcall CTaskManager::SetTaskSecondary(CTaskManager *this, CTask *pTaskSecondary, const int iType)
{
  CTask **v4; // r8
  CTask *v5; // r5
  CTask *v6; // r0
  int *v7; // r8
  CTask *v8; // t1
  int v9; // r0
  CTask *v10; // r6
  int v11; // r0
  int v12; // r4

  v4 = &this->m_tasks[iType];
  v5 = pTaskSecondary;
  v8 = v4[5];
  v7 = (int *)(v4 + 5);
  v6 = v8;
  if ( v8 != pTaskSecondary )
  {
    if ( v6 )
      (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
    *v7 = (int)v5;
    if ( v5 )
    {
      if ( !(*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 4))(v5) )
      {
        while ( 1 )
        {
          v9 = (*((int (__fastcall **)(CTask *, CPed *))v5->_vptr$CTask + 11))(v5, this->m_pPed);
          v10 = (CTask *)v9;
          if ( !v9 )
            break;
          (*((void (__fastcall **)(CTask *, int))v5->_vptr$CTask + 9))(v5, v9);
          v5 = v10;
          if ( (*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 4))(v10) == 1 )
            goto LABEL_10;
        }
        CTaskManager::SetNextSubTask(this, v5->m_pParent);
      }
LABEL_10:
      v11 = *v7;
      if ( *v7 )
      {
        do
        {
          v12 = v11;
          v11 = (*(int (__fastcall **)(int))(*(_DWORD *)v11 + 12))(v11);
        }
        while ( v11 );
        if ( !(*(int (__fastcall **)(int))(*(_DWORD *)v12 + 16))(v12) )
        {
          if ( *v7 )
            (*(void (__fastcall **)(int))(*(_DWORD *)*v7 + 4))(*v7);
          *v7 = 0;
        }
      }
    }
  }
}

//----- (00533D46) --------------------------------------------------------
CTask *__fastcall CTaskManager::GetTaskSecondary(const CTaskManager *this, const int iType)
{
  return this->m_tasksSecondary[iType];
}

//----- (00533D4E) --------------------------------------------------------
bool __fastcall CTaskManager::HasTaskSecondary(const CTaskManager *this, const CTask *pTaskSecondary)
{
  CTask *v2; // r2
  bool v3; // zf
  CTask *v4; // r2
  bool v5; // zf

  if ( this->m_tasksSecondary[0] == pTaskSecondary )
    return 1;
  v2 = this->m_tasksSecondary[1];
  v3 = v2 == pTaskSecondary;
  if ( v2 != pTaskSecondary )
    v3 = this->m_tasksSecondary[2] == pTaskSecondary;
  if ( v3 )
    return 1;
  v4 = this->m_tasksSecondary[3];
  v5 = v4 == pTaskSecondary;
  if ( v4 != pTaskSecondary )
    v5 = this->m_tasksSecondary[4] == pTaskSecondary;
  return v5 || this->m_tasksSecondary[5] == pTaskSecondary;
}

//----- (00533D7C) --------------------------------------------------------
void __fastcall CTaskManager::ClearTaskEventResponse(CTaskManager *this)
{
  CTask *v2; // r0
  CTask **v3; // r5
  CTask *v4; // r0
  CTask **v5; // r4
  CTask *v6; // t1

  v3 = &this->m_tasks[1];
  v2 = this->m_tasks[1];
  if ( v2 )
  {
    (*((void (__fastcall **)(CTask *))v2->_vptr$CTask + 1))(v2);
  }
  else
  {
    v6 = this->m_tasks[2];
    v5 = &this->m_tasks[2];
    v4 = v6;
    if ( !v6 )
      return;
    (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 1))(v4);
    v3 = v5;
  }
  *v3 = 0;
}

//----- (00533DAA) --------------------------------------------------------
void __fastcall CTaskManager::SetNextSubTask(CTaskManager *this, CTask *pTask)
{
  CTask *v2; // r6
  CTaskManager *v3; // r4
  CTask **v4; // r5
  void (__fastcall *v5)(CTask *, CTask **); // r2
  int v6; // r0
  CTask **v7; // r6

  while ( 1 )
  {
    v2 = pTask;
    v3 = this;
    if ( !pTask )
      break;
    while ( 1 )
    {
      v4 = (CTask **)(*((int (__fastcall **)(CTask *, CPed *))v2->_vptr$CTask + 10))(v2, v3->m_pPed);
      v5 = (void (__fastcall *)(CTask *, CTask **))*((_DWORD *)v2->_vptr$CTask + 9);
      if ( v4 )
        break;
      v5(v2, 0);
      v2 = v2->m_pParent;
      if ( !v2 )
        return;
    }
    v5(v2, v4);
    if ( ((int (__fastcall *)(CTask **))(*v4)[2]._vptr$CTask)(v4) )
      break;
    while ( 1 )
    {
      v6 = ((int (__fastcall *)(CTask **, CPed *))(*v4)[5].m_pParent)(v4, v3->m_pPed);
      v7 = (CTask **)v6;
      if ( !v6 )
        break;
      ((void (__fastcall *)(CTask **, int))(*v4)[4].m_pParent)(v4, v6);
      v4 = v7;
      if ( ((int (__fastcall *)(CTask **))(*v7)[2]._vptr$CTask)(v7) )
        return;
    }
    pTask = v4[1];
    this = v3;
  }
}

//----- (00533E22) --------------------------------------------------------
void __fastcall CTaskManager::ManageTasks(CTaskManager *this)
{
  CTask *v2; // r0
  int v3; // r8
  CTask *v4; // r5
  int v5; // r6
  CTask *v6; // r0
  CTask **v7; // r5
  CTask *v8; // r0
  CTask *v9; // r5
  CTask *v10; // r0
  CTask **v11; // r5
  CTask *v13; // r0
  CTask *v14; // r0
  int i; // r4
  CTask **v16; // r10
  CTask *v17; // r5
  _DWORD *v18; // r10
  CTask *v19; // t1
  int v20; // r0
  int v21; // r6
  bool v22; // zf
  int v23; // r0
  CTask **v24; // r6

  v2 = this->m_tasks[0];
  if ( v2 )
  {
    v3 = 0;
  }
  else
  {
    v2 = this->m_tasks[1];
    if ( v2 )
    {
      v3 = 1;
    }
    else
    {
      v2 = this->m_tasks[2];
      if ( v2 )
      {
        v3 = 2;
      }
      else
      {
        v2 = this->m_tasks[3];
        if ( v2 )
        {
          v3 = 3;
        }
        else
        {
          v2 = this->m_tasks[4];
          if ( !v2 )
            goto LABEL_36;
          v3 = 4;
        }
      }
    }
  }
  do
  {
    v4 = v2;
    v2 = (CTask *)(*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 3))(v2);
  }
  while ( v2 );
  if ( (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 4))(v4) != 1 )
  {
    v13 = this->m_tasks[v3];
    if ( v13 )
      (*((void (__fastcall **)(CTask *))v13->_vptr$CTask + 1))(v13);
    this->m_tasks[v3] = 0;
    return;
  }
  v5 = 0;
  while ( 1 )
  {
    CTaskManager::ParentsControlChildren(this, this->m_tasks[v3]);
    v6 = this->m_tasks[v3];
    if ( v6 )
    {
      do
      {
        v7 = (CTask **)v6;
        v6 = (CTask *)(*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 3))(v6);
      }
      while ( v6 );
    }
    else
    {
      v7 = 0;
    }
    if ( !((int (__fastcall *)(CTask **))(*v7)[2]._vptr$CTask)(v7) )
    {
      CTaskManager::SetNextSubTask(this, v7[1]);
      v8 = this->m_tasks[v3];
      do
      {
        v9 = v8;
        v8 = (CTask *)(*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 3))(v8);
      }
      while ( v8 );
      if ( !(*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 4))(v9) )
        break;
    }
    v10 = this->m_tasks[v3];
    if ( v10 )
    {
      do
      {
        v11 = (CTask **)v10;
        v10 = (CTask *)(*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 3))(v10);
      }
      while ( v10 );
    }
    else
    {
      v11 = 0;
    }
    if ( ((int (__fastcall *)(CTask **, CPed *))(*v11)[4].m_pParent)(v11, this->m_pPed) != 1 )
      goto LABEL_36;
    CTaskManager::SetNextSubTask(this, v11[1]);
    if ( !(*((int (__fastcall **)(CTask *))this->m_tasks[v3]->_vptr$CTask + 3))(this->m_tasks[v3]) )
      break;
    if ( v5++ > 9 )
      goto LABEL_36;
  }
  v14 = this->m_tasks[v3];
  if ( v14 )
    (*((void (__fastcall **)(CTask *))v14->_vptr$CTask + 1))(v14);
  this->m_tasks[v3] = 0;
LABEL_36:
  for ( i = 0; i != 6; ++i )
  {
    v16 = &this->m_tasks[i];
    v19 = v16[5];
    v18 = v16 + 5;
    v17 = v19;
    if ( v19 )
    {
      do
      {
        CTaskManager::ParentsControlChildren(this, v17);
        v20 = (int)v17;
        do
        {
          v21 = v20;
          v20 = (*(int (__fastcall **)(int))(*(_DWORD *)v20 + 12))(v20);
        }
        while ( v20 );
        v22 = (*(int (__fastcall **)(int))(*(_DWORD *)v21 + 16))(v21) == 1;
        v23 = (int)v17;
        if ( !v22 )
          break;
        do
        {
          v24 = (CTask **)v23;
          v23 = (*(int (__fastcall **)(int))(*(_DWORD *)v23 + 12))(v23);
        }
        while ( v23 );
        if ( ((int (__fastcall *)(CTask **, CPed *))(*v24)[4].m_pParent)(v24, this->m_pPed) != 1 )
          goto LABEL_46;
        CTaskManager::SetNextSubTask(this, v24[1]);
      }
      while ( (*((int (__fastcall **)(CTask *))v17->_vptr$CTask + 3))(v17) );
      (*((void (__fastcall **)(CTask *))v17->_vptr$CTask + 1))(v17);
      *v18 = 0;
    }
LABEL_46:
    ;
  }
}

//----- (00533FC8) --------------------------------------------------------
void __fastcall CTaskManager::ParentsControlChildren(CTaskManager *this, CTask *pTask)
{
  CTask *v2; // r5
  int v4; // r4
  CTask **v5; // r6
  int v6; // r0
  CTask **v7; // r4

  v2 = pTask;
  if ( pTask )
  {
    while ( !(*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 4))(v2) )
    {
      v4 = (*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 3))(v2);
      v5 = (CTask **)(*((int (__fastcall **)(CTask *, CPed *))v2->_vptr$CTask + 12))(v2, this->m_pPed);
      if ( (CTask **)v4 != v5 )
      {
        (*(void (__fastcall **)(int, CPed *, int, _DWORD))(*(_DWORD *)v4 + 28))(v4, this->m_pPed, 1, 0);
        (*((void (__fastcall **)(CTask *, CTask **))v2->_vptr$CTask + 9))(v2, v5);
        if ( v5 && !((int (__fastcall *)(CTask **))(*v5)[2]._vptr$CTask)(v5) )
        {
          while ( 1 )
          {
            v6 = ((int (__fastcall *)(CTask **, CPed *))(*v5)[5].m_pParent)(v5, this->m_pPed);
            v7 = (CTask **)v6;
            if ( !v6 )
              break;
            ((void (__fastcall *)(CTask **, int))(*v5)[4].m_pParent)(v5, v6);
            v5 = v7;
            if ( ((int (__fastcall *)(CTask **))(*v7)[2]._vptr$CTask)(v7) )
              return;
          }
          CTaskManager::SetNextSubTask(this, v5[1]);
        }
        return;
      }
      v2 = (CTask *)(*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 3))(v2);
      if ( !v2 )
        return;
    }
  }
}

//----- (00534070) --------------------------------------------------------
void __fastcall CTaskManager::Flush(CTaskManager *this)
{
  CTask *v2; // r0
  CTask *v3; // r0
  CTask *v4; // r0
  CTask *v5; // r0
  CTask *v6; // r0
  CTask *v7; // r0
  CTask *v8; // r0
  CTask *v9; // r0
  CTask *v10; // r0
  CTask *v11; // r0
  CTask *v12; // r0

  v2 = this->m_tasks[0];
  if ( v2 )
    (*((void (__fastcall **)(CTask *))v2->_vptr$CTask + 1))(v2);
  v3 = this->m_tasks[1];
  this->m_tasks[0] = 0;
  if ( v3 )
    (*((void (__fastcall **)(CTask *))v3->_vptr$CTask + 1))(v3);
  v4 = this->m_tasks[2];
  this->m_tasks[1] = 0;
  if ( v4 )
    (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 1))(v4);
  v5 = this->m_tasks[3];
  this->m_tasks[2] = 0;
  if ( v5 )
    (*((void (__fastcall **)(CTask *))v5->_vptr$CTask + 1))(v5);
  v6 = this->m_tasks[4];
  this->m_tasks[3] = 0;
  if ( v6 )
    (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
  v7 = this->m_tasksSecondary[0];
  this->m_tasks[4] = 0;
  if ( v7 )
    (*((void (__fastcall **)(CTask *))v7->_vptr$CTask + 1))(v7);
  v8 = this->m_tasksSecondary[1];
  this->m_tasksSecondary[0] = 0;
  if ( v8 )
    (*((void (__fastcall **)(CTask *))v8->_vptr$CTask + 1))(v8);
  v9 = this->m_tasksSecondary[2];
  this->m_tasksSecondary[1] = 0;
  if ( v9 )
    (*((void (__fastcall **)(CTask *))v9->_vptr$CTask + 1))(v9);
  v10 = this->m_tasksSecondary[3];
  this->m_tasksSecondary[2] = 0;
  if ( v10 )
    (*((void (__fastcall **)(CTask *))v10->_vptr$CTask + 1))(v10);
  v11 = this->m_tasksSecondary[4];
  this->m_tasksSecondary[3] = 0;
  if ( v11 )
    (*((void (__fastcall **)(CTask *))v11->_vptr$CTask + 1))(v11);
  v12 = this->m_tasksSecondary[5];
  this->m_tasksSecondary[4] = 0;
  if ( v12 )
    (*((void (__fastcall **)(CTask *))v12->_vptr$CTask + 1))(v12);
  this->m_tasksSecondary[5] = 0;
}

//----- (0053411E) --------------------------------------------------------
void __fastcall CTaskManager::FlushImmediately(CTaskManager *this)
{
  CTask *v2; // r0
  CTask *v3; // r0
  CTask *v4; // r0
  CTask *v5; // r0
  CTask *v6; // r0
  CTask *v7; // r0
  CTask *v8; // r0
  CTask *v9; // r0
  CTask *v10; // r0
  CTask *v11; // r0
  CTask *v12; // r0
  CTask *v13; // r0
  CTask *v14; // r0
  CTask *v15; // r0
  CTask *v16; // r0
  CTask *v17; // r0
  CTask *v18; // r0
  CTask *v19; // r0
  CTask *v20; // r0
  CTask *v21; // r0
  CTask *v22; // r0

  v2 = this->m_tasks[0];
  if ( v2 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v2->_vptr$CTask + 7))(v2, this->m_pPed, 2, 0) == 1 )
  {
    if ( this->m_tasks[0] )
      (*((void (__fastcall **)(CTask *))this->m_tasks[0]->_vptr$CTask + 1))(this->m_tasks[0]);
    this->m_tasks[0] = 0;
  }
  v3 = this->m_tasks[1];
  if ( v3 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v3->_vptr$CTask + 7))(v3, this->m_pPed, 2, 0) == 1 )
  {
    v4 = this->m_tasks[1];
    if ( v4 )
      (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 1))(v4);
    this->m_tasks[1] = 0;
  }
  v5 = this->m_tasks[2];
  if ( v5 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v5->_vptr$CTask + 7))(v5, this->m_pPed, 2, 0) == 1 )
  {
    v6 = this->m_tasks[2];
    if ( v6 )
      (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
    this->m_tasks[2] = 0;
  }
  v7 = this->m_tasks[3];
  if ( v7 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v7->_vptr$CTask + 7))(v7, this->m_pPed, 2, 0) == 1 )
  {
    v8 = this->m_tasks[3];
    if ( v8 )
      (*((void (__fastcall **)(CTask *))v8->_vptr$CTask + 1))(v8);
    this->m_tasks[3] = 0;
  }
  v9 = this->m_tasks[4];
  if ( v9 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v9->_vptr$CTask + 7))(v9, this->m_pPed, 2, 0) == 1 )
  {
    v10 = this->m_tasks[4];
    if ( v10 )
      (*((void (__fastcall **)(CTask *))v10->_vptr$CTask + 1))(v10);
    this->m_tasks[4] = 0;
  }
  v11 = this->m_tasksSecondary[0];
  if ( v11 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v11->_vptr$CTask + 7))(v11, this->m_pPed, 2, 0) == 1 )
  {
    v12 = this->m_tasksSecondary[0];
    if ( v12 )
      (*((void (__fastcall **)(CTask *))v12->_vptr$CTask + 1))(v12);
    this->m_tasksSecondary[0] = 0;
  }
  v13 = this->m_tasksSecondary[1];
  if ( v13 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v13->_vptr$CTask + 7))(v13, this->m_pPed, 2, 0) == 1 )
  {
    v14 = this->m_tasksSecondary[1];
    if ( v14 )
      (*((void (__fastcall **)(CTask *))v14->_vptr$CTask + 1))(v14);
    this->m_tasksSecondary[1] = 0;
  }
  v15 = this->m_tasksSecondary[2];
  if ( v15 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v15->_vptr$CTask + 7))(v15, this->m_pPed, 2, 0) == 1 )
  {
    v16 = this->m_tasksSecondary[2];
    if ( v16 )
      (*((void (__fastcall **)(CTask *))v16->_vptr$CTask + 1))(v16);
    this->m_tasksSecondary[2] = 0;
  }
  v17 = this->m_tasksSecondary[3];
  if ( v17 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v17->_vptr$CTask + 7))(v17, this->m_pPed, 2, 0) == 1 )
  {
    v18 = this->m_tasksSecondary[3];
    if ( v18 )
      (*((void (__fastcall **)(CTask *))v18->_vptr$CTask + 1))(v18);
    this->m_tasksSecondary[3] = 0;
  }
  v19 = this->m_tasksSecondary[4];
  if ( v19 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v19->_vptr$CTask + 7))(v19, this->m_pPed, 2, 0) == 1 )
  {
    v20 = this->m_tasksSecondary[4];
    if ( v20 )
      (*((void (__fastcall **)(CTask *))v20->_vptr$CTask + 1))(v20);
    this->m_tasksSecondary[4] = 0;
  }
  v21 = this->m_tasksSecondary[5];
  if ( v21 && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v21->_vptr$CTask + 7))(v21, this->m_pPed, 2, 0) == 1 )
  {
    v22 = this->m_tasksSecondary[5];
    if ( v22 )
      (*((void (__fastcall **)(CTask *))v22->_vptr$CTask + 1))(v22);
    this->m_tasksSecondary[5] = 0;
  }
}

//----- (005342CC) --------------------------------------------------------
void __fastcall CTaskManager::StopTimers(CTaskManager *this, const CEvent *pEvent)
{
  CTask *v4; // r0
  CTask *v5; // r0
  CTask *v6; // r0
  CTask *v7; // r0
  CTask *v8; // r0

  v4 = this->m_tasks[0];
  if ( v4 )
    (*((void (__fastcall **)(CTask *, const CEvent *))v4->_vptr$CTask + 6))(v4, pEvent);
  v5 = this->m_tasks[1];
  if ( v5 )
    (*((void (__fastcall **)(CTask *, const CEvent *))v5->_vptr$CTask + 6))(v5, pEvent);
  v6 = this->m_tasks[2];
  if ( v6 )
    (*((void (__fastcall **)(CTask *, const CEvent *))v6->_vptr$CTask + 6))(v6, pEvent);
  v7 = this->m_tasks[3];
  if ( v7 )
    (*((void (__fastcall **)(CTask *, const CEvent *))v7->_vptr$CTask + 6))(v7, pEvent);
  v8 = this->m_tasks[4];
  if ( v8 )
    (*((void (__fastcall **)(CTask *, const CEvent *))v8->_vptr$CTask + 6))(v8, pEvent);
}

//----- (00534320) --------------------------------------------------------
void __fastcall CTaskComplexPartner::CTaskComplexPartner(
        CTaskComplexPartner *this,
        unsigned __int8 *idString,
        CPed *pPartner,
        bool8 isLeader,
        float meetDist,
        bool8 fineTune,
        int32 numLoops,
        CVector targetPos)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isLeader = isLeader;
  this->m_meetDist = meetDist;
  this->m_fineTune = fineTune;
  this->m_numLoops = numLoops;
  this->m_targetPos = targetPos;
  this->m_abortTask = 0;
  *(_WORD *)&this->m_state = -255;
  this->m_animsReferenced = 0;
  this->m_animString[0] = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  this->m_pPartner = pPartner;
  if ( pPartner )
    CEntity::RegisterReference(pPartner, &this->m_pPartner);
}
// 66CCD0: using guessed type void *off_66CCD0;

//----- (0053439C) --------------------------------------------------------
void __fastcall CTaskComplexPartnerShove::~CTaskComplexPartnerShove(CTaskComplexPartner *this)
{
  CPed *m_pPartner; // r0
  CEntity **p_m_pPartner; // r1
  int (**v4)(void); // r2

  p_m_pPartner = &this->m_pPartner;
  m_pPartner = this->m_pPartner;
  v4 = (int (**)(void))&off_66CCD0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  if ( m_pPartner )
  {
    CEntity::CleanUpOldReference(m_pPartner, p_m_pPartner);
    v4 = this->_vptr$CTask;
  }
  ((void (__fastcall *)(CTaskComplexPartner *))v4[14])(this);
  sub_18EDB4(this);
}
// 66CCD0: using guessed type void *off_66CCD0;

//----- (005343D4) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartner::CreateNextSubTask(CTaskComplexPartner *this, CPed *pPed)
{
  CPed *m_pPartner; // r0
  CTask *ActiveTaskByType; // r0
  CTask *result; // r0
  CTask *v7; // r0
  CTask v8; // d16
  int8 v9; // r0
  CTaskComplexGoToPointAndStandStill *v10; // r0
  CTaskComplexTurnToFaceEntityOrCoord *v11; // r0
  CTask *v12; // r0
  CTask *v13; // r0
  CTask *v14; // r0
  int (**v15)(void); // r1
  CTask *v16; // r0
  CTask v17; // d16
  CTask *v18; // r0
  CTask *v19; // r6
  CMatrix *v20; // r0
  float yy; // s0
  float v22; // s2
  CPed *v23; // r1
  CMatrix *m_pMat; // r0
  CMatrix *v25; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r6
  float x; // s0
  float y; // s2
  float v30; // s6
  float v31; // s10
  float v32; // s8
  float v33; // s14
  float v34; // s12
  CTaskSimpleStandStill *v35; // r0
  float v36; // s12
  float v37; // s10
  float v38; // s2
  float v39; // s0
  float v40; // s8
  float v41; // s6
  float v42; // s6
  float v43; // s4
  float v44; // s0
  float m_heading; // r6
  float v46; // r8
  UINT8 NodeHeadingFromVector; // r8
  CTaskComplexWanderStandard *v48; // r6

  m_pPartner = this->m_pPartner;
  if ( !m_pPartner )
    return 0;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                       &m_pPartner->m_pPedIntelligence->m_taskManager,
                       this->m_taskType);
  if ( !ActiveTaskByType || (CPed *)ActiveTaskByType[7]._vptr$CTask != pPed )
    return 0;
  switch ( this->m_state )
  {
    case 1:
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
        return 0;
      if ( this->m_isLeader )
      {
        CTaskComplexPartner::CalcTargetPositions(this, pPed, &this->m_targetPos, &this->m_targetPosOther);
        v7 = CTaskManager::FindActiveTaskByType(&this->m_pPartner->m_pPedIntelligence->m_taskManager, this->m_taskType);
        v8 = *(CTask *)&this->m_targetPosOther.x;
        v7[9]._vptr$CTask = (int (**)(void))LODWORD(this->m_targetPosOther.z);
        v7[8] = v8;
      }
      v9 = 2;
      goto LABEL_51;
    case 2:
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
        return 0;
      if ( this->m_targetPos.x == 0.0 )
        goto LABEL_52;
      this->m_timeout = 0;
      this->m_state = 3;
      v10 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(v10, 4, &this->m_targetPos, 0.1, 0.0, 0, 1);
      return result;
    case 3:
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
      {
        v11 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v11, this->m_pPartner, 0.5, 0.2);
        return result;
      }
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 920 )
        return 0;
      v9 = 4;
      goto LABEL_51;
    case 4:
      v12 = CTaskManager::FindActiveTaskByType(&this->m_pPartner->m_pPedIntelligence->m_taskManager, this->m_taskType);
      if ( v12 && (SBYTE1(v12[11]._vptr$CTask) | 1) == 5 )
      {
        if ( (unsigned __int8)this->m_firstToTarget == 255 )
          this->m_firstToTarget = 0;
        v13 = CTaskManager::FindActiveTaskByType(&this->m_pPartner->m_pPedIntelligence->m_taskManager, this->m_taskType);
        if ( BYTE2(v13[11]._vptr$CTask) == 255 )
          BYTE2(v13[11]._vptr$CTask) = 1;
        v9 = 5;
        goto LABEL_51;
      }
      if ( (unsigned __int8)this->m_firstToTarget == 255 )
        this->m_firstToTarget = 1;
      v16 = CTaskManager::FindActiveTaskByType(&this->m_pPartner->m_pPedIntelligence->m_taskManager, this->m_taskType);
      if ( BYTE2(v16[11]._vptr$CTask) == 255 )
        BYTE2(v16[11]._vptr$CTask) = 0;
      v17 = *(CTask *)&this->m_targetPosOther.x;
      v16[9]._vptr$CTask = (int (**)(void))LODWORD(this->m_targetPosOther.z);
      v16[8] = v17;
      goto LABEL_52;
    case 5:
      if ( this->m_fineTune )
      {
        if ( this->m_firstToTarget == 1 )
        {
          v14 = CTaskManager::FindActiveTaskByType(
                  &this->m_pPartner->m_pPedIntelligence->m_taskManager,
                  this->m_taskType);
          if ( !v14 || BYTE1(v14[11]._vptr$CTask) != 6 )
            goto LABEL_52;
        }
        else
        {
          v23 = this->m_pPartner;
          m_pMat = pPed->m_pMat;
          v25 = v23->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          p_x = &v25->tx;
          x = p_tx->m_translate.x;
          y = p_tx->m_translate.y;
          if ( !v25 )
            p_x = &v23->m_transform.m_translate.x;
          v30 = p_x[1];
          v31 = x - *p_x;
          v32 = y - v30;
          v33 = (float)(v31 * v31) + (float)(v32 * v32);
          v34 = sqrtf(v33);
          if ( v34 <= 0.99 || v34 >= 1.01 )
          {
            if ( v33 <= 0.0 )
            {
              v37 = 1.0;
            }
            else
            {
              v36 = 1.0 / v34;
              v32 = v32 * v36;
              v37 = v31 * v36;
            }
            v38 = (float)(v30 + v32) - y;
            v39 = (float)(*p_x + v37) - x;
            v40 = (float)(v39 * v39) + (float)(v38 * v38);
            v41 = sqrtf(v40);
            if ( v41 > 0.02 )
            {
              if ( v40 <= 0.0 )
              {
                v39 = 0.02;
              }
              else
              {
                v42 = 1.0 / v41;
                v38 = v38 * v42;
                v39 = (float)(v39 * v42) * 0.02;
              }
              v38 = v38 * 0.02;
            }
            v43 = (float)(v39 * m_pMat->xy) + (float)(v38 * m_pMat->yy);
            v44 = (float)(v39 * m_pMat->xx) + (float)(v38 * m_pMat->yx);
            pPed->m_extractedVelocity.y = v43;
            pPed->m_extractedVelocity.x = v44;
            goto LABEL_52;
          }
        }
      }
      else
      {
        v18 = CTaskManager::FindActiveTaskByType(&this->m_pPartner->m_pPedIntelligence->m_taskManager, this->m_taskType);
        if ( !v18 || SBYTE1(v18[11]._vptr$CTask) < 5 )
          goto LABEL_52;
        v19 = pPed->m_pPedIntelligence->m_taskManager.m_tasks[4];
        if ( v19
          && (*((int (__fastcall **)(CTask *))v19->_vptr$CTask + 5))(pPed->m_pPedIntelligence->m_taskManager.m_tasks[4]) == 912
          && !(*((int (__fastcall **)(CTask *))v19->_vptr$CTask + 13))(v19) )
        {
          v20 = pPed->m_pMat;
          if ( v20 )
          {
            yy = v20->yy;
            v22 = -v20->xy;
          }
          else
          {
            m_heading = pPed->m_transform.m_heading;
            v46 = sinf(m_heading);
            yy = cosf(m_heading);
            v22 = v46;
          }
          NodeHeadingFromVector = CGeneral::GetNodeHeadingFromVector(v22, COERCE_FLOAT(LODWORD(yy) ^ 0x80000000));
          v48 = (CTaskComplexWanderStandard *)CTask::operator new(0x38u);
          CTaskComplexWander::CTaskComplexWander(v48, 4, NodeHeadingFromVector, 1, 0.5);
          *(_WORD *)&v48->m_timer.m_bIsActive = 0;
          v48->m_iMinNextScanTime = 0;
          v48->m_timer.m_iStartTime = 0;
          v48->m_timer.m_iDuration = 0;
          v48->_vptr$CTask = (int (**)(void))&off_66C58C;
          CTaskComplexWanderStandard::SetNextScanTime(
            v48,
            (int32)&elf_hash_chain[8526] + CTimer::m_snTimeInMilliseconds);
          CTaskManager::SetTask(&pPed->m_pPedIntelligence->m_taskManager, v48, 4, 0);
        }
      }
      v9 = 6;
LABEL_51:
      this->m_state = v9;
LABEL_52:
      v35 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v35, 50, 0, 0, 8.0);
      break;
    case 6:
      if ( !this->m_animsReferenced || !this->m_numLoops )
        return 0;
      v15 = this->_vptr$CTask;
      --this->m_numLoops;
      return (CTask *)((int (__fastcall *)(CTaskComplexPartner *))v15[15])(this);
    default:
      return 0;
  }
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 66C58C: using guessed type void *off_66C58C;
// 677A94: using guessed type void *`vtable for'CTaskComplexWanderStandard;

//----- (0053480C) --------------------------------------------------------
bool8 __fastcall CTaskComplexPartner::IsPartnerStillValid(CTaskComplexPartner *this, CPed *pPed)
{
  CPed *m_pPartner; // r2
  CTask *ActiveTaskByType; // r0
  bool8 result; // r0

  m_pPartner = this->m_pPartner;
  result = 0;
  if ( m_pPartner )
  {
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                         &m_pPartner->m_pPedIntelligence->m_taskManager,
                         this->m_taskType);
    if ( ActiveTaskByType )
    {
      if ( (CPed *)ActiveTaskByType[7]._vptr$CTask == pPed )
        return 1;
    }
  }
  return result;
}

//----- (00534832) --------------------------------------------------------
int32 __fastcall CTaskComplexPartner::GetPartnerState(CTaskComplexPartner *this)
{
  CTask *ActiveTaskByType; // r0

  ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                       &this->m_pPartner->m_pPedIntelligence->m_taskManager,
                       this->m_taskType);
  if ( ActiveTaskByType )
    return SBYTE1(ActiveTaskByType[11]._vptr$CTask);
  else
    return 0;
}

//----- (00534850) --------------------------------------------------------
void __fastcall CTaskComplexPartner::SetFirstToTargetFlag(CTaskComplexPartner *this, bool8 val)
{
  if ( (unsigned __int8)this->m_firstToTarget == 255 )
    this->m_firstToTarget = val;
}

//----- (0053485E) --------------------------------------------------------
void __fastcall CTaskComplexPartner::SetTargetPos(CTaskComplexPartner *this, CVector *targetPos)
{
  __int64 v2; // d16

  v2 = *(_QWORD *)&targetPos->x;
  this->m_targetPos.z = targetPos->z;
  *(_QWORD *)&this->m_targetPos.x = v2;
}

//----- (0053486C) --------------------------------------------------------
void __fastcall CTaskComplexPartner::CalcTargetPositions(
        CTaskComplexPartner *this,
        CPed *pPed,
        CVector *target1,
        CVector *target2)
{
  CPed *m_pPartner; // r0
  CMatrix *m_pMat; // r2
  CMatrix *v9; // r3
  CSimpleTransform *p_tx; // r4
  float *p_x; // r1
  float x; // s16
  float y; // s18
  float z; // s22
  float v15; // s20
  float v16; // s24
  RwReal v17; // s28
  RwReal v18; // s30
  float m_meetDist; // s17
  float v20; // s26
  float v21; // s28
  float v22; // s22
  int v23; // r0
  float v24; // s10
  float v25; // s10
  int v26; // r1
  float v27; // s10
  float v28; // s10
  RwReal v29; // s8
  RwReal v30; // s6
  RwReal v31; // s2
  RwReal v32; // s0
  RwReal v33; // s4
  CVector v34; // [sp+4h] [bp-5Ch] BYREF

  m_pPartner = this->m_pPartner;
  m_pMat = pPed->m_pMat;
  v9 = m_pPartner->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_x = &v9->tx;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  if ( !v9 )
    p_x = &m_pPartner->m_transform.m_translate.x;
  v15 = *p_x;
  v16 = p_x[1];
  v17 = *p_x - x;
  v18 = p_x[2] - z;
  v34.y = v16 - y;
  v34.x = v17;
  v34.z = v18;
  m_meetDist = this->m_meetDist;
  CVector::Normalise(&v34);
  v20 = y + (float)(m_meetDist * (float)(v16 - y));
  v21 = x + (float)(m_meetDist * v17);
  v22 = z + (float)(v18 * m_meetDist);
  if ( (*((int (__fastcall **)(CTaskComplexPartner *))this->_vptr$CTask + 5))(this) == 1204 )
  {
LABEL_15:
    v29 = v20 - (float)(v34.y * 0.5);
    v30 = v22 - (float)(v34.z * 0.5);
    v31 = v20 + (float)(v34.y * 0.5);
    v32 = v21 + (float)(v34.x * 0.5);
    v33 = v22 + (float)(v34.z * 0.5);
    target1->x = v21 - (float)(v34.x * 0.5);
    target1->y = v29;
    target1->z = v30;
    target2->x = v32;
    target2->y = v31;
    target2->z = v33;
  }
  else
  {
    v23 = -1;
    do
    {
      v24 = sqrtf((float)((float)(v21 - x) * (float)(v21 - x)) + (float)((float)(v20 - y) * (float)(v20 - y)));
      if ( v24 >= 0.7 )
      {
        v26 = 0;
      }
      else
      {
        v25 = 0.75 - v24;
        v26 = 1;
        v22 = v22 + (float)(v25 * v34.z);
        v20 = v20 + (float)(v25 * v34.y);
        v21 = v21 + (float)(v25 * v34.x);
      }
      v27 = sqrtf((float)((float)(v21 - v15) * (float)(v21 - v15)) + (float)((float)(v20 - v16) * (float)(v20 - v16)));
      if ( v27 >= 0.7 )
      {
        if ( v26 != 1 )
          goto LABEL_15;
      }
      else
      {
        v28 = 0.75 - v27;
        v22 = v22 - (float)(v28 * v34.z);
        v20 = v20 - (float)(v28 * v34.y);
        v21 = v21 - (float)(v28 * v34.x);
      }
      ++v23;
    }
    while ( v23 <= 9 );
    this->m_abortTask = 1;
  }
}

//----- (005349FC) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartner::CreateFirstSubTask(CTaskComplexPartner *this, CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleStandStill *v5; // r0

  if ( this->m_isLeader && this->m_taskType == 1204 && *((_BYTE *)&this->m_timeout + 2) )
  {
    if ( CAEPedSpeechAudioEntity::RequestPedConversation(pPed, this->m_pPartner) )
    {
      LOBYTE(this[1]._vptr$CTask) = 1;
    }
    else
    {
      result = 0;
      if ( !*((_BYTE *)&this->m_timeout + 3) )
        return result;
      *((_BYTE *)&this->m_timeout + 2) = 0;
    }
  }
  CPed::StopPlayingHandSignal(pPed);
  v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 50, 0, 0, 8.0);
  return result;
}

//----- (00534A5C) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartner::ControlSubTask(CTaskComplexPartner *this, CPed *pPed)
{
  int m_state; // r1
  CPed *m_pPartner; // r0
  CTask *ActiveTaskByType; // r0
  CPed *v7; // r0
  bool v8; // zf
  CTask *v9; // r6
  int16 v10; // r0

  m_state = this->m_state;
  m_pPartner = this->m_pPartner;
  if ( m_state <= 1 )
  {
    if ( !m_pPartner )
      goto LABEL_10;
    if ( !this->m_abortTask )
      goto LABEL_11;
  }
  else if ( !m_pPartner )
  {
    goto LABEL_10;
  }
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                       &m_pPartner->m_pPedIntelligence->m_taskManager,
                       this->m_taskType);
  if ( !ActiveTaskByType )
    goto LABEL_10;
  v7 = (CPed *)ActiveTaskByType[7]._vptr$CTask;
  v8 = v7 == pPed;
  if ( v7 == pPed )
    v8 = this->m_abortTask == 0;
  if ( !v8 )
  {
LABEL_10:
    v9 = 0;
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) )
    {
      return v9;
    }
  }
LABEL_11:
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 903
    || (v10 = this->m_timeout + 1, this->m_timeout = v10, v10 < 151)
    || (v9 = 0,
        !(*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0)) )
  {
    CPed::DropEntityThatThisPedIsHolding(pPed, 1u);
    (*((void (__fastcall **)(CTaskComplexPartner *))this->_vptr$CTask + 13))(this);
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 500);
    return this->m_pSubTask;
  }
  return v9;
}

//----- (00534B20) --------------------------------------------------------
void __fastcall CTaskComplexPartner::StreamRequiredAnims(CTaskComplexPartner *this)
{
  int32 AnimationBlockIndex; // r0

  if ( !this->m_animsReferenced )
  {
    if ( !this->m_animString[0] )
    {
LABEL_5:
      this->m_animsReferenced = 1;
      return;
    }
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex(this->m_animString);
    if ( CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
    {
      CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
      goto LABEL_5;
    }
    sub_192918(AnimationBlockIndex + 25575, 8);
  }
}

//----- (00534B6C) --------------------------------------------------------
void __fastcall CTaskComplexPartner::RemoveStreamedAnims(CTaskComplexPartner *this)
{
  int32 AnimationBlockIndex; // r0

  if ( this->m_animsReferenced )
  {
    if ( this->m_animString[0] )
    {
      AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex(this->m_animString);
      CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    }
    this->m_animsReferenced = 0;
  }
}

//----- (00534B94) --------------------------------------------------------
void __fastcall CTaskComplexPartnerDeal::CTaskComplexPartnerDeal(
        CTaskComplexPartnerDeal *this,
        unsigned __int8 *idString,
        CPed *pPartner,
        bool8 isLeader,
        float meetDist,
        CVector targetPos)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isLeader = isLeader;
  this->m_meetDist = meetDist;
  this->m_fineTune = 1;
  this->m_numLoops = 1;
  this->m_targetPos = targetPos;
  this->m_abortTask = 0;
  *(_WORD *)&this->m_state = -255;
  this->m_animsReferenced = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  this->m_animString[0] = 0;
  this->m_pPartner = pPartner;
  if ( pPartner )
    CEntity::RegisterReference(pPartner, &this->m_pPartner);
  this->m_taskType = 1202;
  this->_vptr$CTask = (int (**)(void))&off_66CD18;
  strcpy((char *)this->m_animString, "gangs");
}
// 66CCD0: using guessed type void *off_66CCD0;
// 66CD18: using guessed type void *;

//----- (00534C30) --------------------------------------------------------
void __fastcall CTaskComplexPartnerDeal::~CTaskComplexPartnerDeal(CTaskComplexPartnerDeal *this)
{
  CPed *m_pPartner; // r0
  CEntity **p_m_pPartner; // r1
  int (**v4)(void); // r2
  void *v5; // r0

  p_m_pPartner = &this->m_pPartner;
  m_pPartner = this->m_pPartner;
  v4 = (int (**)(void))&off_66CCD0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  if ( m_pPartner )
  {
    CEntity::CleanUpOldReference(m_pPartner, p_m_pPartner);
    v4 = this->_vptr$CTask;
  }
  ((void (__fastcall *)(CTaskComplexPartner *))v4[14])(this);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 534C5E: variable 'v5' is possibly undefined
// 66CCD0: using guessed type void *off_66CCD0;

//----- (00534C68) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerDeal::CreateFirstSubTask(CTaskComplexPartnerDeal *this, CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleStandStill *v5; // r0

  if ( this->m_isLeader && this->m_taskType == 1204 && *((_BYTE *)&this->m_timeout + 2) )
  {
    if ( CAEPedSpeechAudioEntity::RequestPedConversation(pPed, this->m_pPartner) )
    {
      LOBYTE(this[1]._vptr$CTask) = 1;
    }
    else
    {
      result = 0;
      if ( !*((_BYTE *)&this->m_timeout + 3) )
        return result;
      *((_BYTE *)&this->m_timeout + 2) = 0;
    }
  }
  CPed::StopPlayingHandSignal(pPed);
  v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 50, 0, 0, 8.0);
  return result;
}

//----- (00534CC8) --------------------------------------------------------
void __fastcall CTaskComplexPartnerDeal::StreamRequiredAnims(CTaskComplexPartnerDeal *this)
{
  int m_animsReferenced; // r5
  _BOOL4 ShouldLoadGangAnims; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v5; // r0
  int32 v6; // r0

  m_animsReferenced = this->m_animsReferenced;
  ShouldLoadGangAnims = CTaskComplexGangLeader::ShouldLoadGangAnims();
  if ( m_animsReferenced )
  {
    if ( ShouldLoadGangAnims )
      return;
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex(this->m_animString);
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    v5 = 0;
LABEL_4:
    this->m_animsReferenced = v5;
    return;
  }
  if ( ShouldLoadGangAnims )
  {
    v6 = CAnimManager::GetAnimationBlockIndex(this->m_animString);
    if ( !CAnimManager::ms_aAnimBlocks[v6].m_loaded )
    {
      sub_192918(v6 + 25575, 8);
      return;
    }
    CAnimManager::AddAnimBlockRef(v6);
    v5 = 1;
    goto LABEL_4;
  }
}

//----- (00534D2C) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerDeal::GetPartnerSequence(CTaskComplexPartnerDeal *this)
{
  CTaskComplexSequence *v2; // r4
  int m_isLeader; // r8
  CTaskComplexTurnToFaceEntityOrCoord *v4; // r6
  CTaskSimpleRunAnim *v5; // r5
  AnimationId v6; // r2

  v2 = (CTaskComplexSequence *)CTask::operator new(0x40u);
  CTaskComplexSequence::CTaskComplexSequence(v2);
  m_isLeader = this->m_isLeader;
  v4 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
  CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v4, this->m_pPartner, 0.5, 0.02);
  CTaskComplexSequence::AddTask(v2, v4);
  v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  if ( m_isLeader )
    v6 = ANIM_GANG_DRUGS_DEAL;
  else
    v6 = ANIM_GANG_DRUGS_BUY;
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, ANIM_GANG_PED, v6, 4.0, 0);
  CTaskComplexSequence::AddTask(v2, v5);
  return v2;
}

//----- (00534DAC) --------------------------------------------------------
void __fastcall CTaskComplexPartnerGreet::CTaskComplexPartnerGreet(
        CTaskComplexPartnerGreet *this,
        unsigned __int8 *idString,
        CPed *pPartner,
        bool8 isLeader,
        float meetDist,
        int32 subType,
        CVector targetPos)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isLeader = isLeader;
  this->m_meetDist = meetDist;
  this->m_fineTune = 1;
  this->m_numLoops = 1;
  this->m_targetPos = targetPos;
  this->m_abortTask = 0;
  *(_WORD *)&this->m_state = -255;
  this->m_animsReferenced = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  this->m_animString[0] = 0;
  this->m_pPartner = pPartner;
  if ( pPartner )
    CEntity::RegisterReference(pPartner, &this->m_pPartner);
  this->m_taskType = 1203;
  this->m_subType = subType;
  this->_vptr$CTask = (int (**)(void))&off_66CD60;
  strcpy((char *)this->m_animString, "gangs");
}
// 534E48: using guessed type void **off_534E48;
// 534E4C: using guessed type void **off_534E4C;
// 66CCD0: using guessed type void *off_66CCD0;
// 66CD60: using guessed type void *;

//----- (00534E50) --------------------------------------------------------
void __fastcall CTaskComplexPartnerGreet::~CTaskComplexPartnerGreet(CTaskComplexPartnerGreet *this)
{
  CPed *m_pPartner; // r0
  CEntity **p_m_pPartner; // r1
  int (**v4)(void); // r2
  void *v5; // r0

  p_m_pPartner = &this->m_pPartner;
  m_pPartner = this->m_pPartner;
  v4 = (int (**)(void))&off_66CCD0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  if ( m_pPartner )
  {
    CEntity::CleanUpOldReference(m_pPartner, p_m_pPartner);
    v4 = this->_vptr$CTask;
  }
  ((void (__fastcall *)(CTaskComplexPartner *))v4[14])(this);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 534E7E: variable 'v5' is possibly undefined
// 66CCD0: using guessed type void *off_66CCD0;

//----- (00534E88) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerGreet::CreateFirstSubTask(CTaskComplexPartnerGreet *this, CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleStandStill *v5; // r0

  if ( this->m_isLeader && this->m_taskType == 1204 && *((_BYTE *)&this->m_timeout + 2) )
  {
    if ( CAEPedSpeechAudioEntity::RequestPedConversation(pPed, this->m_pPartner) )
    {
      LOBYTE(this->m_subType) = 1;
    }
    else
    {
      result = 0;
      if ( !*((_BYTE *)&this->m_timeout + 3) )
        return result;
      *((_BYTE *)&this->m_timeout + 2) = 0;
    }
  }
  CPed::StopPlayingHandSignal(pPed);
  v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 50, 0, 0, 8.0);
  return result;
}

//----- (00534EE8) --------------------------------------------------------
void __fastcall CTaskComplexPartnerGreet::StreamRequiredAnims(CTaskComplexPartnerGreet *this)
{
  int m_animsReferenced; // r5
  _BOOL4 ShouldLoadGangAnims; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v5; // r0
  int32 v6; // r0

  m_animsReferenced = this->m_animsReferenced;
  ShouldLoadGangAnims = CTaskComplexGangLeader::ShouldLoadGangAnims();
  if ( m_animsReferenced )
  {
    if ( ShouldLoadGangAnims )
      return;
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex(this->m_animString);
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    v5 = 0;
LABEL_4:
    this->m_animsReferenced = v5;
    return;
  }
  if ( ShouldLoadGangAnims )
  {
    v6 = CAnimManager::GetAnimationBlockIndex(this->m_animString);
    if ( !CAnimManager::ms_aAnimBlocks[v6].m_loaded )
    {
      sub_192918(v6 + 25575, 8);
      return;
    }
    CAnimManager::AddAnimBlockRef(v6);
    v5 = 1;
    goto LABEL_4;
  }
}

//----- (00534F4C) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerGreet::GetPartnerSequence(CTaskComplexPartnerGreet *this)
{
  CTaskComplexSequence *v2; // r4
  CTaskComplexTurnToFaceEntityOrCoord *v3; // r6
  CTaskSimpleRunAnim *v4; // r6
  int m_isLeader; // r6
  CTaskSimpleRunAnim *v6; // r8
  AnimationId v7; // r2
  CTaskComplexSequence *v8; // r0
  CTask *v9; // r1
  float v10; // s4
  float v11; // s6
  float v12; // s16
  float v13; // s18
  int v14; // s20
  int v15; // s22
  int v16; // r11
  CTaskSimpleDoHandSignal *v17; // r6
  CTaskSimpleStandStill *v18; // r6
  CTaskSimpleStandStill *v19; // r6
  CTaskSimpleRunTimedAnim *v20; // r5
  CTaskSimpleStandStill *v21; // r6
  CTaskSimpleDoHandSignal *v22; // r6
  CTaskSimpleRunTimedAnim *v23; // r6
  CTaskSimpleStandStill *v24; // r5
  CTaskSimpleStandStill *v25; // r5
  CTaskSimpleRunTimedAnim *v26; // r5

  v2 = (CTaskComplexSequence *)CTask::operator new(0x40u);
  CTaskComplexSequence::CTaskComplexSequence(v2);
  v3 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
  CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v3, this->m_pPartner, 0.5, 0.001);
  CTaskComplexSequence::AddTask(v2, v3);
  switch ( this->m_subType )
  {
    case 0:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_GANG_PED, ANIM_GANG_GREET_A, 4.0, 0);
      goto LABEL_11;
    case 1:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_GANG_PED, ANIM_GANG_GREET_B, 4.0, 0);
      goto LABEL_11;
    case 2:
      m_isLeader = this->m_isLeader;
      v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      if ( m_isLeader )
        v7 = ANIM_GANG_GREET_CA;
      else
        v7 = ANIM_GANG_GREET_CB;
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_GANG_PED, v7, 4.0, 0);
      v8 = v2;
      v9 = v6;
      goto LABEL_12;
    case 3:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_GANG_PED, ANIM_GANG_GREET_D, 4.0, 0);
      goto LABEL_11;
    case 4:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_GANG_PED, ANIM_GANG_GREET_E, 4.0, 0);
      goto LABEL_11;
    case 5:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_GANG_PED, ANIM_GANG_GREET_F, 4.0, 0);
LABEL_11:
      v8 = v2;
      v9 = v4;
LABEL_12:
      CTaskComplexSequence::AddTask(v8, v9);
      break;
    default:
      break;
  }
  v10 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 4000.0;
  v11 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 4000.0;
  v12 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 4000.0;
  v13 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 4000.0;
  v15 = (int)v11;
  v16 = rand() & 1;
  v14 = (int)v10;
  if ( this->m_isLeader )
  {
    v17 = (CTaskSimpleDoHandSignal *)CTask::operator new(0xCu);
    CTaskSimpleDoHandSignal::CTaskSimpleDoHandSignal(v17);
    CTaskComplexSequence::AddTask(v2, v17);
    v18 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v18, 1000, 0, 0, 8.0);
    CTaskComplexSequence::AddTask(v2, v18);
    v19 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v19, v14 + 3000, 0, 0, 8.0);
    CTaskComplexSequence::AddTask(v2, v19);
    v20 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
    CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
      v20,
      ANIM_STD_PED,
      ANIM_STD_CHAT,
      4.0,
      -4.0,
      v15 + 3000,
      416,
      "Chat",
      0);
    v20->_vptr$CTask = (int (**)(void))&off_668878;
    CTaskComplexSequence::AddTask(v2, v20);
    if ( v16 )
      goto LABEL_17;
  }
  else
  {
    v21 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v21, 1000, 0, 0, 8.0);
    CTaskComplexSequence::AddTask(v2, v21);
    v22 = (CTaskSimpleDoHandSignal *)CTask::operator new(0xCu);
    CTaskSimpleDoHandSignal::CTaskSimpleDoHandSignal(v22);
    CTaskComplexSequence::AddTask(v2, v22);
    v23 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
    CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
      v23,
      ANIM_STD_PED,
      ANIM_STD_CHAT,
      4.0,
      -4.0,
      v14 + 3000,
      416,
      "Chat",
      0);
    v23->_vptr$CTask = (int (**)(void))&off_668878;
    CTaskComplexSequence::AddTask(v2, v23);
    v24 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v24, v15 + 3000, 0, 0, 8.0);
    CTaskComplexSequence::AddTask(v2, v24);
    if ( v16 )
    {
LABEL_17:
      v25 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v25, (int)v12 + 3000, 0, 0, 8.0);
      CTaskComplexSequence::AddTask(v2, v25);
      v26 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        v26,
        ANIM_STD_PED,
        ANIM_STD_CHAT,
        4.0,
        -4.0,
        (int)v13 + 3000,
        416,
        "Chat",
        0);
      v26->_vptr$CTask = (int (**)(void))&off_668878;
      CTaskComplexSequence::AddTask(v2, v26);
    }
  }
  return v2;
}
// 668878: using guessed type void *off_668878;

//----- (00535324) --------------------------------------------------------
void __fastcall CTaskComplexPartnerChat::CTaskComplexPartnerChat(
        CTaskComplexPartnerChat *this,
        unsigned __int8 *idString,
        CPed *pPartner,
        bool8 isLeader,
        float meetDist,
        int32 numLoops,
        int useAudio,
        bool8 defaultToNonAudio,
        CVector targetPos)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isLeader = isLeader;
  this->m_meetDist = meetDist;
  this->m_numLoops = numLoops;
  this->m_fineTune = 0;
  this->m_targetPos = targetPos;
  this->m_abortTask = 0;
  *(_WORD *)&this->m_state = -255;
  this->m_animsReferenced = 0;
  this->m_animString[0] = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  this->m_pPartner = pPartner;
  if ( pPartner )
    CEntity::RegisterReference(pPartner, &this->m_pPartner);
  this->m_taskType = 1204;
  this->m_chatStarted = 0;
  this->m_useAudio = useAudio;
  this->_vptr$CTask = (int (**)(void))&off_66CDA8;
  if ( useAudio )
    this->m_numLoops = 4;
  this->m_defaultToNonAudio = defaultToNonAudio;
  strcpy((char *)this->m_idString, (const char *)idString);
}
// 66CCD0: using guessed type void *;
// 66CDA8: using guessed type void *;

//----- (005353DC) --------------------------------------------------------
void __fastcall CTaskComplexPartnerChat::~CTaskComplexPartnerChat(CTaskComplexPartnerChat *this)
{
  int m_useAudio; // r1
  CPed *m_pPartner; // r0
  int (**v4)(void); // r2

  m_useAudio = this->m_useAudio;
  this->_vptr$CTask = (int (**)(void))&off_66CDA8;
  if ( m_useAudio && this->m_chatStarted )
    CAEPedSpeechAudioEntity::ReleasePedConversation();
  m_pPartner = this->m_pPartner;
  v4 = (int (**)(void))&off_66CCD0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  if ( m_pPartner )
  {
    CEntity::CleanUpOldReference(m_pPartner, &this->m_pPartner);
    v4 = this->_vptr$CTask;
  }
  ((void (__fastcall *)(CTaskComplexPartner *))v4[14])((CTaskComplexPartner *)this);
  sub_18EDB4(this);
}
// 66CCD0: using guessed type void *off_66CCD0;
// 66CDA8: using guessed type void *off_66CDA8;

//----- (00535434) --------------------------------------------------------
void __fastcall CTaskComplexPartnerChat::~CTaskComplexPartnerChat(CTaskComplexPartnerChat *this)
{
  int m_useAudio; // r1
  CPed *m_pPartner; // r0
  int (**v4)(void); // r2
  void *v5; // r0

  m_useAudio = this->m_useAudio;
  this->_vptr$CTask = (int (**)(void))&off_66CDA8;
  if ( m_useAudio && this->m_chatStarted )
    CAEPedSpeechAudioEntity::ReleasePedConversation();
  m_pPartner = this->m_pPartner;
  v4 = (int (**)(void))&off_66CCD0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  if ( m_pPartner )
  {
    CEntity::CleanUpOldReference(m_pPartner, &this->m_pPartner);
    v4 = this->_vptr$CTask;
  }
  ((void (__fastcall *)(CTaskComplexPartner *))v4[14])((CTaskComplexPartner *)this);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 535482: variable 'v5' is possibly undefined
// 66CCD0: using guessed type void *off_66CCD0;
// 66CDA8: using guessed type void *off_66CDA8;

//----- (00535490) --------------------------------------------------------
bool __fastcall CTaskComplexPartnerChat::MakeAbortable(
        CTaskComplexPartnerChat *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v6; // zf

  if ( (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplexPartner:912::CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent) != 1 )
    return 0;
  v6 = this->m_useAudio == 0;
  if ( this->m_useAudio )
    v6 = this->m_chatStarted == 0;
  if ( !v6 )
  {
    CAEPedSpeechAudioEntity::ReleasePedConversation();
    this->m_chatStarted = 0;
  }
  return 1;
}

//----- (005354C4) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerChat::GetPartnerSequence(CTaskComplexPartnerChat *this)
{
  CTaskComplexSequence *v2; // r9
  CTaskComplexTurnToFaceEntityOrCoord *v3; // r4
  float v4; // s0
  int v5; // r2
  Int16 v6; // r8
  int m_isLeader; // r10
  void *v8; // r6
  int m_numLoops; // r11
  CPed *m_pPartner; // r4
  CTaskComplex *v11; // r0
  CPed *v12; // r6
  void *v13; // r4
  int v14; // r5
  int v15; // r0
  CTaskSimpleRunTimedAnim *v16; // r5
  CTaskComplex *v17; // r0
  CPed *v18; // r6
  int v19; // r5
  CTaskSimpleStandStill *v20; // r5
  Int16 v22; // [sp+14h] [bp-34h]

  v2 = (CTaskComplexSequence *)CTask::operator new(0x40u);
  CTaskComplexSequence::CTaskComplexSequence(v2);
  v3 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
  CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v3, this->m_pPartner, 0.5, 0.001);
  CTaskComplexSequence::AddTask(v2, v3);
  v4 = (float)((int)(float)(this->m_targetPos.z
                          + (float)(this->m_targetPos.y + (float)(this->m_targetPos.x + (float)(16 * this->m_numLoops)))) & 0x7F)
     * 0.0078125;
  if ( !this->m_isLeader )
  {
    v15 = BYTE2(CPedIntelligence::FindTaskByType(this->m_pPartner->m_pPedIntelligence, 1204)[14]._vptr$CTask);
    this->m_useAudio = v15;
    if ( v15 )
      goto LABEL_3;
LABEL_12:
    if ( this->m_isLeader )
    {
      v16 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        v16,
        ANIM_STD_PED,
        ANIM_STD_CHAT,
        4.0,
        -4.0,
        (int)(float)((float)(v4 * 3000.0) + 3500.0),
        416,
        "Chat",
        0);
      v16->_vptr$CTask = (int (**)(void))&off_668878;
      CTaskComplexSequence::AddTask(v2, v16);
      v13 = CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(
        (CTaskSimpleStandStill *)v13,
        (int)(float)((float)((float)(1.0 - v4) * 3000.0) + 3500.0),
        0,
        0,
        8.0);
    }
    else
    {
      v20 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v20, (int)(float)((float)(v4 * 3000.0) + 3500.0), 0, 0, 8.0);
      CTaskComplexSequence::AddTask(v2, v20);
      v13 = CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        (CTaskSimpleRunTimedAnim *)v13,
        ANIM_STD_PED,
        ANIM_STD_CHAT,
        4.0,
        -4.0,
        (int)(float)((float)((float)(1.0 - v4) * 3000.0) + 3500.0),
        416,
        "Chat",
        0);
      *(_DWORD *)v13 = &off_668878;
    }
    goto LABEL_20;
  }
  if ( !this->m_useAudio )
    goto LABEL_12;
LABEL_3:
  v5 = 3 - this->m_numLoops;
  v6 = CAEPedSpeechAudioEntity::s_Conversation[v5][0];
  v22 = CAEPedSpeechAudioEntity::s_Conversation[v5][1];
  if ( v5 == CAEPedSpeechAudioEntity::s_ConversationLength )
    this->m_numLoops = 0;
  m_isLeader = this->m_isLeader;
  v8 = CTask::operator new(0x20u);
  m_numLoops = this->m_numLoops;
  m_pPartner = this->m_pPartner;
  CTaskComplex::CTaskComplex((CTaskComplex *)v8);
  *(_DWORD *)v8 = &off_66CDF0;
  if ( m_isLeader )
  {
    *((_DWORD *)v8 + 4) = m_pPartner;
    *((_BYTE *)v8 + 12) = 1;
    *((_DWORD *)v8 + 5) = m_numLoops;
    *((_WORD *)v8 + 12) = v6;
    if ( m_pPartner )
      CEntity::RegisterReference(m_pPartner, (CEntity **)v8 + 4);
    *((_DWORD *)v8 + 7) = 0;
    *((_BYTE *)v8 + 26) = 0;
    CTaskComplexSequence::AddTask(v2, (CTask *)v8);
    v11 = (CTaskComplex *)CTask::operator new(0x20u);
    v12 = this->m_pPartner;
    v13 = v11;
    v14 = this->m_numLoops;
    CTaskComplex::CTaskComplex(v11);
    *((_BYTE *)v13 + 12) = 0;
    *(_DWORD *)v13 = &off_66CDF0;
    *((_DWORD *)v13 + 5) = v14;
    *((_WORD *)v13 + 12) = v6;
    *((_DWORD *)v13 + 4) = v12;
    if ( v12 )
      CEntity::RegisterReference(v12, (CEntity **)v13 + 4);
    *((_DWORD *)v13 + 7) = 0;
    *((_BYTE *)v13 + 26) = 0;
  }
  else
  {
    *((_DWORD *)v8 + 4) = m_pPartner;
    *((_BYTE *)v8 + 12) = 0;
    *((_DWORD *)v8 + 5) = m_numLoops;
    *((_WORD *)v8 + 12) = v22;
    if ( m_pPartner )
      CEntity::RegisterReference(m_pPartner, (CEntity **)v8 + 4);
    *((_DWORD *)v8 + 7) = 0;
    *((_BYTE *)v8 + 26) = 0;
    CTaskComplexSequence::AddTask(v2, (CTask *)v8);
    v17 = (CTaskComplex *)CTask::operator new(0x20u);
    v18 = this->m_pPartner;
    v13 = v17;
    v19 = this->m_numLoops;
    CTaskComplex::CTaskComplex(v17);
    *((_BYTE *)v13 + 12) = 1;
    *(_DWORD *)v13 = &off_66CDF0;
    *((_DWORD *)v13 + 5) = v19;
    *((_WORD *)v13 + 12) = v22;
    *((_DWORD *)v13 + 4) = v18;
    if ( v18 )
      CEntity::RegisterReference(v18, (CEntity **)v13 + 4);
    *((_DWORD *)v13 + 7) = 0;
    *((_BYTE *)v13 + 26) = 0;
  }
LABEL_20:
  CTaskComplexSequence::AddTask(v2, (CTask *)v13);
  return v2;
}
// 668878: using guessed type void *off_668878;
// 66CDF0: using guessed type void *;

//----- (005357F4) --------------------------------------------------------
void __fastcall CTaskComplexChat::CTaskComplexChat(
        CTaskComplexChat *this,
        bool8 isChatter,
        CPed *pPartner,
        int32 stage,
        Int16 GlobalSpeechContext)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isChatter = isChatter;
  this->m_stage = stage;
  this->m_GlobalSpeechContext = GlobalSpeechContext;
  this->_vptr$CTask = (int (**)(void))&off_66CDF0;
  this->m_pPartner = pPartner;
  if ( pPartner )
    CEntity::RegisterReference(pPartner, &this->m_pPartner);
  this->m_timeout = 0;
  this->m_taskFinished = 0;
}
// 66CDF0: using guessed type void *off_66CDF0;

//----- (00535840) --------------------------------------------------------
void __fastcall CTaskComplexChat::~CTaskComplexChat(CTaskComplexChat *this)
{
  CPed *m_pPartner; // r0
  CEntity **p_m_pPartner; // r1

  p_m_pPartner = &this->m_pPartner;
  m_pPartner = this->m_pPartner;
  this->_vptr$CTask = (int (**)(void))&off_66CDF0;
  if ( m_pPartner )
    CEntity::CleanUpOldReference(m_pPartner, p_m_pPartner);
  sub_18EDB4(this);
}
// 66CDF0: using guessed type void *off_66CDF0;

//----- (0053586C) --------------------------------------------------------
void __fastcall CTaskComplexChat::~CTaskComplexChat(CTaskComplexChat *this)
{
  CPed *m_pPartner; // r0
  CEntity **p_m_pPartner; // r1
  void *v4; // r0

  p_m_pPartner = &this->m_pPartner;
  m_pPartner = this->m_pPartner;
  this->_vptr$CTask = (int (**)(void))&off_66CDF0;
  if ( m_pPartner )
    CEntity::CleanUpOldReference(m_pPartner, p_m_pPartner);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 535894: variable 'v4' is possibly undefined
// 66CDF0: using guessed type void *off_66CDF0;

//----- (0053589C) --------------------------------------------------------
CTask *__fastcall CTaskComplexChat::Clone(const CTaskComplexChat *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r5
  Int16 m_GlobalSpeechContext; // r9
  bool8 m_isChatter; // r10

  v2 = (CTaskComplex *)CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_pPartner;
  v4 = v2;
  m_GlobalSpeechContext = this->m_GlobalSpeechContext;
  m_isChatter = this->m_isChatter;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(v4[1]._vptr$CTask) = m_isChatter;
  v4[1].m_pSubTask = (CTask *)HIDWORD(v3);
  LOWORD(v4[2]._vptr$CTask) = m_GlobalSpeechContext;
  v4->_vptr$CTask = (int (**)(void))&off_66CDF0;
  v4[1].m_pParent = (CTask *)v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1].m_pParent);
  v4[2].m_pParent = 0;
  BYTE2(v4[2]._vptr$CTask) = 0;
  BYTE2(v4[2]._vptr$CTask) = this->m_taskFinished;
  return v4;
}
// 66CDF0: using guessed type void *off_66CDF0;

//----- (005358FC) --------------------------------------------------------
CTask *__fastcall CTaskComplexChat::CreateNextSubTask(CTaskComplexChat *this, CPed *pPed)
{
  return 0;
}

//----- (00535900) --------------------------------------------------------
CTask *__fastcall CTaskComplexChat::CreateFirstSubTask(CTaskComplexChat *this, CPed *pPed)
{
  int m_GlobalSpeechContext; // r0
  int v5; // r0
  CTaskSimpleRunAnim *v6; // r0
  AnimationId v7; // r2
  CTask *result; // r0
  CTaskSimpleStandStill *v9; // r0
  CTaskSimpleRunTimedAnim *v10; // r0
  CTaskSimpleRunTimedAnim *v11; // r0

  if ( !this->m_pPartner )
    return 0;
  if ( !this->m_isChatter )
  {
    v9 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v9, 999999, 0, 0, 8.0);
    return result;
  }
  m_GlobalSpeechContext = this->m_GlobalSpeechContext;
  if ( m_GlobalSpeechContext >= 0 )
    CPed::Say(pPed, m_GlobalSpeechContext, 0, 1.0, 0, 0, 0);
  CInterestingEvents::Add(&g_InterestingEvents, EPedsChatting, pPed);
  if ( (unsigned int)(this->m_GlobalSpeechContext - 164) <= 4 && ((1 << (this->m_GlobalSpeechContext + 92)) & 0x19) != 0 )
  {
    v5 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0);
    switch ( v5 )
    {
      case 2:
        v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        v7 = ANIM_STD_ENDCHAT3;
        goto LABEL_16;
      case 1:
        v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        v7 = ANIM_STD_ENDCHAT2;
        goto LABEL_16;
      case 0:
        v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        v7 = ANIM_STD_ENDCHAT1;
LABEL_16:
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, v7, 4.0, 0);
        return result;
    }
    v11 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
    CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(v11, ANIM_STD_PED, ANIM_STD_CHAT, 4.0, -4.0, 4000, 416, "Chat", 0);
  }
  else
  {
    v10 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
    CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
      v10,
      ANIM_STD_PED,
      ANIM_STD_CHAT,
      4.0,
      -4.0,
      999999,
      416,
      "Chat",
      0);
  }
  result->_vptr$CTask = (int (**)(void))&off_668878;
  return result;
}
// 535A4A: variable 'result' is possibly undefined
// 668878: using guessed type void *off_668878;

//----- (00535A6C) --------------------------------------------------------
CTask *__fastcall CTaskComplexChat::ControlSubTask(CTaskComplexChat *this, CPed *pPed)
{
  CPed *m_pPartner; // r0
  CTask *v5; // r6
  CTask *TaskByType; // r6
  int32 m_timeout; // r0

  m_pPartner = this->m_pPartner;
  if ( !m_pPartner )
    return 0;
  if ( this->m_taskFinished )
  {
    v5 = 0;
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) )
    {
      return v5;
    }
    m_pPartner = this->m_pPartner;
  }
  TaskByType = CPedIntelligence::FindTaskByType(m_pPartner->m_pPedIntelligence, 1218);
  if ( TaskByType )
  {
    if ( (int)TaskByType[2].m_pParent < this->m_stage )
      this->m_taskFinished = 1;
    if ( !BYTE2(TaskByType[3]._vptr$CTask) && this->m_isChatter == LOBYTE(TaskByType[1].m_pParent) )
      this->m_taskFinished = 1;
  }
  if ( this->m_isChatter && !CPed::GetPedTalking(pPed) )
  {
    if ( TaskByType && !BYTE2(TaskByType[3]._vptr$CTask) && !LOBYTE(TaskByType[1].m_pParent) )
    {
      this->m_taskFinished = 1;
      BYTE2(TaskByType[3]._vptr$CTask) = 1;
    }
    m_timeout = this->m_timeout;
    this->m_timeout = m_timeout + 1;
    if ( m_timeout >= 50 )
    {
      this->m_taskFinished = 1;
      if ( TaskByType )
        BYTE2(TaskByType[3]._vptr$CTask) = 1;
    }
  }
  return this->m_pSubTask;
}

//----- (00535B04) --------------------------------------------------------
void __fastcall CTaskComplexPartnerShove::CTaskComplexPartnerShove(
        CTaskComplexPartnerShove *this,
        unsigned __int8 *idString,
        CPed *pPartner,
        bool8 isLeader,
        float meetDist,
        int32 numLoops,
        CVector targetPos)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isLeader = isLeader;
  this->m_meetDist = meetDist;
  this->m_fineTune = 0;
  this->m_numLoops = numLoops;
  this->m_targetPos = targetPos;
  this->m_abortTask = 0;
  *(_WORD *)&this->m_state = -255;
  this->m_animsReferenced = 0;
  this->m_animString[0] = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  this->m_pPartner = pPartner;
  if ( pPartner )
    CEntity::RegisterReference(pPartner, &this->m_pPartner);
  this->m_numLoops = numLoops;
  this->m_taskType = 1209;
  this->_vptr$CTask = (int (**)(void))&off_66CE2C;
}
// 66CCD0: using guessed type void *off_66CCD0;
// 66CE2C: using guessed type void *;

//----- (00535B90) --------------------------------------------------------
void __fastcall CTaskComplexPartnerShove::~CTaskComplexPartnerShove(CTaskComplexPartnerShove *this)
{
  CPed *m_pPartner; // r0
  CEntity **p_m_pPartner; // r1
  int (**v4)(void); // r2
  void *v5; // r0

  p_m_pPartner = &this->m_pPartner;
  m_pPartner = this->m_pPartner;
  v4 = (int (**)(void))&off_66CCD0;
  this->_vptr$CTask = (int (**)(void))&off_66CCD0;
  if ( m_pPartner )
  {
    CEntity::CleanUpOldReference(m_pPartner, p_m_pPartner);
    v4 = this->_vptr$CTask;
  }
  ((void (__fastcall *)(CTaskComplexPartner *))v4[14])(this);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 535BBE: variable 'v5' is possibly undefined
// 66CCD0: using guessed type void *off_66CCD0;

//----- (00535BC8) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerShove::GetPartnerSequence(CTaskComplexPartnerShove *this)
{
  CTaskComplexSequence *v2; // r4
  CTaskComplexTurnToFaceEntityOrCoord *v3; // r6
  int m_isLeader; // r6
  CTaskSimpleRunAnim *v5; // r5
  AnimationId v6; // r2

  v2 = (CTaskComplexSequence *)CTask::operator new(0x40u);
  CTaskComplexSequence::CTaskComplexSequence(v2);
  v3 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
  CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v3, this->m_pPartner, 0.5, 0.001);
  CTaskComplexSequence::AddTask(v2, v3);
  m_isLeader = this->m_isLeader;
  v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  if ( m_isLeader )
    v6 = ANIM_STD_SHOVE;
  else
    v6 = ANIM_STD_HANDSUP;
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, ANIM_STD_PED, v6, 4.0, 0);
  CTaskComplexSequence::AddTask(v2, v5);
  return v2;
}

//----- (00535C44) --------------------------------------------------------
void __fastcall CTaskComplexWalkAlongsidePed::CTaskComplexWalkAlongsidePed(
        CTaskComplexWalkAlongsidePed *this,
        CPed *pPed,
        float giveUpDist)
{
  CTaskComplex::CTaskComplex(this);
  this->m_giveUpDist = giveUpDist;
  this->m_Offset.x = 0.0;
  this->m_Offset.y = 0.0;
  this->m_Offset.z = 0.0;
  this->_vptr$CTask = (int (**)(void))&off_66CE74;
  this->m_pTargetPed = pPed;
  CEntity::RegisterReference(pPed, &this->m_pTargetPed);
  this->m_giveUpDist = giveUpDist;
}
// 66CE74: using guessed type void *;

//----- (00535C84) --------------------------------------------------------
void __fastcall CTaskComplexWalkAlongsidePed::~CTaskComplexWalkAlongsidePed(CTaskComplexWalkAlongsidePed *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66CE74;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  sub_18EDB4(this);
}
// 66CE74: using guessed type void *off_66CE74;

//----- (00535CB0) --------------------------------------------------------
void __fastcall CTaskComplexWalkAlongsidePed::~CTaskComplexWalkAlongsidePed(CTaskComplexWalkAlongsidePed *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66CE74;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 535CD8: variable 'v4' is possibly undefined
// 66CE74: using guessed type void *off_66CE74;

//----- (00535CE0) --------------------------------------------------------
bool __fastcall CTaskComplexWalkAlongsidePed::MakeAbortable(
        CTaskComplexWalkAlongsidePed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (00535CEC) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkAlongsidePed::CreateFirstSubTask(CTaskComplexWalkAlongsidePed *this, CPed *pPed)
{
  int v4; // r1

  if ( !this->m_pTargetPed )
    return 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v4 = 704;
    if ( !pPed->m_pMyVehicle )
      v4 = 907;
  }
  else
  {
    v4 = 907;
  }
  return CTaskComplexWalkAlongsidePed::CreateSubTask(this, v4, pPed);
}

//----- (00535D20) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkAlongsidePed::CreateSubTask(
        const CTaskComplexWalkAlongsidePed *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v5; // r4
  CPed *m_pTargetPed; // r8
  char v7; // r3
  char v8; // r0
  __int64 v9; // d16

  switch ( iSubTaskType )
  {
    case 203:
      v5 = (char *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 10, 0, 0, 8.0);
      break;
    case 907:
      v5 = (char *)CTask::operator new(0x58u);
      m_pTargetPed = this->m_pTargetPed;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_QWORD *)v5 + 3) = 0x40A000003F000000LL;
      *((_QWORD *)v5 + 4) = 0x4000000000000000LL;
      *((_QWORD *)v5 + 2) = 0x3E80000C350LL;
      *((_WORD *)v5 + 24) = 0;
      *((_WORD *)v5 + 30) = 0;
      *((_DWORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 11) = 0;
      *((_DWORD *)v5 + 13) = 0;
      *((_DWORD *)v5 + 14) = 0;
      *((_DWORD *)v5 + 18) = 0;
      *((_DWORD *)v5 + 19) = 0;
      *((_DWORD *)v5 + 20) = 6;
      v7 = v5[84];
      *(_DWORD *)v5 = &off_668968;
      *((_DWORD *)v5 + 16) = &off_66D3CC;
      v8 = v7 & 0xF0;
      v5[84] = v7 & 0xF0;
      *((_DWORD *)v5 + 17) = 0;
      *((_DWORD *)v5 + 3) = m_pTargetPed;
      if ( m_pTargetPed )
      {
        CEntity::RegisterReference(m_pTargetPed, (CEntity **)v5 + 3);
        v8 = v5[84];
      }
      v9 = *(_QWORD *)&this->m_Offset.x;
      *((_DWORD *)v5 + 19) = LODWORD(this->m_Offset.z);
      *(_QWORD *)(v5 + 68) = v9;
      *((_DWORD *)v5 + 20) = 7;
      v5[84] = v8 | 8;
      break;
    case 704:
      v5 = (char *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
      break;
    default:
      return 0;
  }
  return (CTask *)v5;
}
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;

//----- (00535E48) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkAlongsidePed::CreateNextSubTask(CTaskComplexWalkAlongsidePed *this, CPed *pPed)
{
  int v4; // r0
  int v5; // r1

  if ( !this->m_pTargetPed )
    return 0;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 != 203 )
  {
    if ( v4 == 907 )
    {
      v5 = 203;
      return CTaskComplexWalkAlongsidePed::CreateSubTask(this, v5, pPed);
    }
    if ( v4 != 704 )
      return 0;
  }
  v5 = 907;
  return CTaskComplexWalkAlongsidePed::CreateSubTask(this, v5, pPed);
}

//----- (00535E84) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkAlongsidePed::ControlSubTask(CTaskComplexWalkAlongsidePed *this, CPed *pPed)
{
  CTaskSimpleStandStill *v4; // r6
  CAnimBlendAssociation *Association; // r8
  CAnimBlendAssociation *v6; // r5
  unsigned int MoveStateFromGoToTask; // r11
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r10
  CSimpleTransform *p_tx; // r1
  CPed *m_pTargetPed; // r0
  float x; // s0
  float y; // s2
  CMatrix *v14; // r1
  float *p_x; // r2
  float v16; // s18
  float v17; // s16
  float v18; // s20
  CTask *m_pSubTask; // r2
  CTask v20; // kr00_8
  CTask *ActiveTaskByType; // r8
  CTask *v22; // r0
  CTask *v23; // r5
  int v24; // lr
  int v25; // r8
  CMatrix *v26; // r0
  CMatrix *v27; // r0
  float v28; // s14
  float xy; // s6
  float yy; // s10
  float zy; // s8
  float32x2_t v32; // d2
  float32x2_t v33; // d0
  float v34; // s4
  float32x2_t v35; // d0
  float32x2_t v36; // d0
  float m_fSpeed; // s24
  float v38; // s0
  float v39; // s0
  float v40; // s24
  float v41; // s0
  float v42; // s0
  __int64 v43; // d16
  char m_pParent; // r0
  unsigned int v45; // r5
  int v46; // r6
  int v47; // r3
  CPed *v48; // r2
  unsigned int v49; // r0
  int v50; // r5
  int v51; // r6
  CAnimBlendAssociation *v53; // [sp+4h] [bp-64h]
  CAnimBlendAssociation *v54; // [sp+8h] [bp-60h]
  int m_iStaticCounter; // [sp+Ch] [bp-5Ch]
  CVector v56; // [sp+10h] [bp-58h] BYREF

  if ( this->m_pTargetPed )
  {
    v4 = 0;
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0);
    v6 = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pTargetPed->m_pRwObject, 0);
    MoveStateFromGoToTask = CPedIntelligence::GetMoveStateFromGoToTask(this->m_pTargetPed->m_pPedIntelligence);
    m_pMat = pPed->m_pMat;
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    m_pTargetPed = this->m_pTargetPed;
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    v14 = m_pTargetPed->m_pMat;
    p_x = &v14->tx;
    if ( !v14 )
      p_x = &m_pTargetPed->m_transform.m_translate.x;
    v16 = *p_x - x;
    v17 = p_x[1] - y;
    v18 = (float)((float)(v16 * v16) + (float)(v17 * v17)) + 0.0;
    if ( v18 <= (float)(this->m_giveUpDist * this->m_giveUpDist) )
    {
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 907 )
      {
        v24 = 0;
        v25 = 0;
        goto LABEL_57;
      }
      v53 = Association;
      v54 = v6;
      m_pSubTask = this->m_pSubTask;
      v20 = *(CTask *)&this->m_Offset.y;
      m_iStaticCounter = pPed->m_pPedIntelligence->m_iStaticCounter;
      m_pSubTask[8].m_pParent = (CTask *)LODWORD(this->m_Offset.x);
      m_pSubTask[9] = v20;
      m_pSubTask[4]._vptr$CTask = (int (**)(void))1077936128;
      ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 906);
      v22 = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 900);
      v23 = v22;
      v24 = 0;
      if ( ActiveTaskByType )
      {
        v25 = 0;
        goto LABEL_53;
      }
      v25 = 0;
      if ( !v22 )
      {
LABEL_53:
        if ( v18 < 4.0
          && m_iStaticCounter >= 9
          && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          this->m_Offset.x = v16;
          this->m_Offset.y = v17;
          this->m_Offset.z = 0.0;
          v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
          CTaskSimpleStandStill::CTaskSimpleStandStill(v4, 10, 0, 0, 8.0);
          return v4;
        }
LABEL_57:
        v45 = *((_DWORD *)&pPed->m_nPedFlags + 3) & 0xFFFEFFFF;
        v46 = *((_DWORD *)&pPed->m_nPedFlags + 2);
        v47 = *((_DWORD *)&pPed->m_nPedFlags + 1);
        *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
        *((_DWORD *)&pPed->m_nPedFlags + 1) = v47;
        *((_DWORD *)&pPed->m_nPedFlags + 2) = v46;
        *((_DWORD *)&pPed->m_nPedFlags + 3) = v45 | (v25 << 16);
        v48 = this->m_pTargetPed;
        v49 = *((_DWORD *)&v48->m_nPedFlags + 3) & 0xFFFEFFFF;
        v50 = *((_DWORD *)&v48->m_nPedFlags + 2);
        v51 = *((_DWORD *)&v48->m_nPedFlags + 1);
        *(_DWORD *)&v48->m_nPedFlags = v48->m_nPedFlags;
        *((_DWORD *)&v48->m_nPedFlags + 1) = v51;
        *((_DWORD *)&v48->m_nPedFlags + 2) = v50;
        *((_DWORD *)&v48->m_nPedFlags + 3) = v49 | (v24 << 16);
        return this->m_pSubTask;
      }
      operator*(&v56, this->m_pTargetPed->m_pMat, &this->m_Offset);
      v26 = pPed->m_pMat;
      v24 = 0;
      if ( v26 )
        p_m_transform = (CSimpleTransform *)&v26->tx;
      if ( MoveStateFromGoToTask > 7 )
      {
        v25 = 0;
      }
      else
      {
        v25 = 0;
        if ( ((1 << MoveStateFromGoToTask) & 0xD0) != 0 )
        {
          v27 = this->m_pTargetPed->m_pMat;
          v28 = p_m_transform->m_translate.y;
          xy = v27->xy;
          yy = v27->yy;
          zy = v27->zy;
          v32.n64_f32[1] = (float)(p_m_transform->m_translate.x * xy) + (float)(v28 * yy);
          v33.n64_f32[1] = (float)(v32.n64_f32[1] + (float)(p_m_transform->m_translate.z * zy))
                         - (float)((float)((float)(v56.x * xy) + (float)(v56.y * yy)) + (float)(v56.z * zy));
          if ( v33.n64_f32[1] < 0.0 )
          {
            v34 = (float)((float)((float)(v56.x - p_m_transform->m_translate.x)
                                * (float)(v56.x - p_m_transform->m_translate.x))
                        + (float)((float)(v56.y - v28) * (float)(v56.y - v28)))
                + 0.0;
            if ( v53 && v34 < 2.0 )
            {
              v56.y = (float)(yy + yy) + v56.y;
              v56.x = v56.x + (float)(xy + xy);
              v56.z = (float)(zy + zy) + v56.z;
            }
            if ( v53 && v34 < 0.0625 )
            {
              v32.n64_u32[0] = 1062836634;
              v33.n64_f32[0] = v53->m_fSpeed + -0.0125;
              v35.n64_u64[0] = vmax_f32(v33, v32).n64_u64[0];
              LODWORD(v53->m_fSpeed) = v35.n64_u32[0];
              if ( v54 )
              {
                v32.n64_u32[0] = 1.25;
                v35.n64_f32[0] = v54->m_fSpeed + 0.0125;
                LODWORD(v54->m_fSpeed) = vmin_f32(v35, v32).n64_u32[0];
LABEL_45:
                v24 = 1;
                v25 = 1;
                goto LABEL_48;
              }
              goto LABEL_47;
            }
            if ( v53 && v34 > 0.0625 )
            {
              v32.n64_u32[0] = 1.25;
              v33.n64_f32[0] = v53->m_fSpeed + 0.0125;
              v36.n64_u64[0] = vmin_f32(v33, v32).n64_u64[0];
              LODWORD(v53->m_fSpeed) = v36.n64_u32[0];
              if ( v54 )
              {
                v32.n64_u32[0] = 1062836634;
                v36.n64_f32[0] = v54->m_fSpeed + -0.0125;
                LODWORD(v54->m_fSpeed) = vmax_f32(v36, v32).n64_u32[0];
                goto LABEL_45;
              }
LABEL_47:
              v25 = 1;
              v24 = 0;
              goto LABEL_48;
            }
            if ( v53 )
            {
              m_fSpeed = v53->m_fSpeed;
              CPed::SetMoveAnimSpeed(pPed, v53);
              v38 = v53->m_fSpeed;
              if ( fabsf(m_fSpeed - v38) >= 0.013 )
              {
                if ( m_fSpeed > v38 )
                  v39 = -0.0125;
                else
                  v39 = 0.0125;
                m_fSpeed = m_fSpeed + v39;
              }
              v53->m_fSpeed = m_fSpeed;
              if ( v54 )
              {
                v40 = v54->m_fSpeed;
                CPed::SetMoveAnimSpeed(this->m_pTargetPed, v54);
                v41 = v54->m_fSpeed;
                if ( fabsf(v40 - v41) >= 0.013 )
                {
                  if ( v40 > v41 )
                    v42 = -0.0125;
                  else
                    v42 = 0.0125;
                  v40 = v40 + v42;
                }
                v54->m_fSpeed = v40;
                goto LABEL_45;
              }
              goto LABEL_47;
            }
          }
          v24 = 0;
          v25 = 0;
        }
      }
LABEL_48:
      if ( *(float *)&v23[1].m_pParent != v56.x
        || *(float *)&v23[2]._vptr$CTask != v56.y
        || *(float *)&v23[2].m_pParent != v56.z
        || *(float *)&v23[3]._vptr$CTask != 0.5 )
      {
        v43 = *(_QWORD *)&v56.x;
        v23[2].m_pParent = (CTask *)LODWORD(v56.z);
        *(_QWORD *)&v23[1].m_pParent = v43;
        m_pParent = (char)v23[3].m_pParent;
        v23[3]._vptr$CTask = (int (**)(void))1056964608;
        LOBYTE(v23[3].m_pParent) = m_pParent & 0xD0 | 0x20;
      }
      goto LABEL_53;
    }
  }
  else
  {
    v4 = 0;
    if ( !(*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
            this->m_pSubTask,
            pPed,
            1,
            0) )
      return this->m_pSubTask;
  }
  return v4;
}

//----- (0053633C) --------------------------------------------------------
void __fastcall CTaskComplexWaitForPed::CTaskComplexWaitForPed(
        CTaskComplexWaitForPed *this,
        CPed *pPed,
        float targetDist,
        int32 timeout,
        bool8 lookAtPed)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_targetDist = targetDist;
  this->m_timeout = timeout;
  this->m_lookAtPed = lookAtPed;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CEB0;
  this->m_pPed = pPed;
  CEntity::RegisterReference(pPed, &this->m_pPed);
}
// 66CEB0: using guessed type void *;

//----- (00536384) --------------------------------------------------------
void __fastcall CTaskComplexWaitForPed::~CTaskComplexWaitForPed(CTaskComplexWaitForPed *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66CEB0;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  sub_18EDB4(this);
}
// 66CEB0: using guessed type void *off_66CEB0;

//----- (005363B0) --------------------------------------------------------
void __fastcall CTaskComplexWaitForPed::~CTaskComplexWaitForPed(CTaskComplexWaitForPed *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  void *v4; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66CEB0;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5363D8: variable 'v4' is possibly undefined
// 66CEB0: using guessed type void *off_66CEB0;

//----- (005363E0) --------------------------------------------------------
bool __fastcall CTaskComplexWaitForPed::MakeAbortable(
        CTaskComplexWaitForPed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (005363E4) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForPed::CreateNextSubTask(CTaskComplexWaitForPed *this, CPed *pPed)
{
  return 0;
}

//----- (005363E8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForPed::CreateFirstSubTask(CTaskComplexWaitForPed *this, CPed *pPed)
{
  CTask *result; // r0
  int m_timeout; // r12
  int v5; // r2
  CTaskSimpleStandStill *v6; // r0

  result = 0;
  if ( this->m_pPed )
  {
    m_timeout = this->m_timeout;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v5;
    this->m_timer.m_iDuration = m_timeout;
    this->m_frameCounter = 0;
    v6 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v6, 999999, 0, 0, 8.0);
  }
  return result;
}

//----- (0053643C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForPed::ControlSubTask(CTaskComplexWaitForPed *this, CPed *pPed)
{
  CPed *m_pPed; // r0
  unsigned int v5; // r0
  int m_iStartTime; // r1
  CTask *m_pSubTask; // r6
  CTask *TaskByType; // r0
  __int64 v9; // d16
  CMatrix *m_pMat; // r1
  CPed *v11; // r0
  float x; // s0
  int m_iAccumulatedTime; // s2
  CMatrix *v14; // r1
  float z; // s4
  float *p_tx; // r2
  CMatrix *v17; // r2
  CSimpleTransform *p_m_transform; // r3
  CMatrix *v20; // r3
  float *p_x; // r2
  CSimpleTransform *v22; // r0
  float RadianAngleBetweenPoints; // r0
  int32 m_frameCounter; // r0
  int32 v25; // r1
  CVector v26; // [sp+0h] [bp-38h] BYREF
  CEventDeadPed v27; // [sp+Ch] [bp-2Ch] BYREF

  m_pPed = this->m_pPed;
  if ( !m_pPed )
    return 0;
  if ( CPed::IsAlive(m_pPed) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      if ( this->m_timer.m_bIsStopped )
      {
        v5 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsStopped = 0;
        this->m_timer.m_iStartTime = v5;
        m_iStartTime = v5;
      }
      else
      {
        m_iStartTime = this->m_timer.m_iStartTime;
        v5 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_timer.m_iDuration <= v5 )
        return 0;
    }
    TaskByType = CPedIntelligence::FindTaskByType(this->m_pPed->m_pPedIntelligence, 1208);
    if ( TaskByType )
    {
      v9 = *(_QWORD *)&TaskByType[2].m_pParent;
      m_pMat = pPed->m_pMat;
      LODWORD(v26.z) = TaskByType[3].m_pParent;
      *(_QWORD *)&v26.x = v9;
      operator*((CVector *)&v27, m_pMat, &v26);
      v11 = this->m_pPed;
      x = *(float *)&v27._vptr$CEvent;
      m_iAccumulatedTime = v27.m_iAccumulatedTime;
      v14 = v11->m_pMat;
      z = *(float *)&v27.m_bIsPersistent;
      p_tx = &v14->tx;
    }
    else
    {
      v11 = this->m_pPed;
      v17 = pPed->m_pMat;
      v14 = v11->m_pMat;
      p_m_transform = (CSimpleTransform *)&v17->tx;
      if ( !v17 )
        p_m_transform = &pPed->m_transform;
      p_tx = &v14->tx;
      x = p_m_transform->m_translate.x;
      m_iAccumulatedTime = SLODWORD(p_m_transform->m_translate.y);
      z = p_m_transform->m_translate.z;
    }
    if ( !v14 )
      p_tx = &v11->m_transform.m_translate.x;
    if ( (float)((float)((float)((float)(x - *p_tx) * (float)(x - *p_tx))
                       + (float)((float)(*(float *)&m_iAccumulatedTime - p_tx[1])
                               * (float)(*(float *)&m_iAccumulatedTime - p_tx[1])))
               + (float)((float)(z - p_tx[2]) * (float)(z - p_tx[2]))) < (float)(this->m_targetDist * this->m_targetDist) )
      return 0;
    if ( this->m_lookAtPed && !this->m_frameCounter )
    {
      v20 = pPed->m_pMat;
      p_x = &v14->tx;
      if ( !v14 )
        p_x = &v11->m_transform.m_translate.x;
      v22 = (CSimpleTransform *)&v20->tx;
      if ( !v20 )
        v22 = &pPed->m_transform;
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   *p_x - v22->m_translate.x,
                                   p_x[1] - v22->m_translate.y,
                                   0.0,
                                   0.0);
      pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    }
    m_frameCounter = this->m_frameCounter;
    m_pSubTask = this->m_pSubTask;
    v25 = m_frameCounter + 1;
    if ( m_frameCounter > 9 )
      v25 = 0;
    this->m_frameCounter = v25;
  }
  else
  {
    m_pSubTask = 0;
    CEventDeadPed::CEventDeadPed(&v27, this->m_pPed, 0, CTimer::m_snTimeInMilliseconds);
    v27.m_iTaskType = 600;
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v27, 0);
    CEventDeadPed::~CEventDeadPed(&v27);
  }
  return m_pSubTask;
}

//----- (005365D4) --------------------------------------------------------
void __fastcall CTaskComplexBeInCouple::CTaskComplexBeInCouple(
        CTaskComplexBeInCouple *this,
        CPed *pPed,
        bool8 isLeader,
        bool8 holdHands,
        bool8 lookAtEachOther,
        float giveUpDist)
{
  CTaskComplex::CTaskComplex(this);
  this->m_isLeader = isLeader;
  this->m_holdHands = holdHands;
  this->m_lookAtEachOther = lookAtEachOther;
  this->m_giveUpDist = giveUpDist;
  this->m_prevSide = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CEEC;
  this->m_pPed = pPed;
  if ( pPed )
    CEntity::RegisterReference(pPed, &this->m_pPed);
}
// 66CEEC: using guessed type void *;

//----- (00536628) --------------------------------------------------------
void __fastcall CTaskComplexBeInCouple::~CTaskComplexBeInCouple(CTaskComplexBeInCouple *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66CEEC;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  sub_18EDB4(this);
}
// 66CEEC: using guessed type void *off_66CEEC;

//----- (00536654) --------------------------------------------------------
void __fastcall CTaskComplexBeInCouple::~CTaskComplexBeInCouple(CTaskComplexBeInCouple *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  void *v4; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66CEEC;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 53667C: variable 'v4' is possibly undefined
// 66CEEC: using guessed type void *off_66CEEC;

//----- (00536684) --------------------------------------------------------
bool __fastcall CTaskComplexBeInCouple::MakeAbortable(
        CTaskComplexBeInCouple *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v6; // zf
  int (**v8)(void); // r0
  bool v9; // r8

  v6 = pEvent == 0;
  if ( pEvent )
    v6 = this->m_pPed == 0;
  if ( !v6 && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 10))(pEvent) == 1 )
  {
    v8 = pEvent->_vptr$CEvent;
    v9 = *(&pEvent->m_bIsPersistent + 1);
    *(&pEvent->m_bIsPersistent + 1) = 0;
    if ( ((int (__fastcall *)(const CEvent *))v8[2])(pEvent) == 9
      || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 31
      || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 15 )
    {
      CEventGroup::Add(&this->m_pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)pEvent, 0);
    }
    *(&pEvent->m_bIsPersistent + 1) = v9;
  }
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
  return 1;
}

//----- (00536740) --------------------------------------------------------
void __fastcall CTaskComplexBeInCouple::AbortArmIK(CTaskComplexBeInCouple *this, CPed *pPed)
{
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
    sub_19A228(&g_ikChainMan, 1, pPed, 250);
}

//----- (005367A0) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInCouple::CreateNextSubTask(CTaskComplexBeInCouple *this, CPed *pPed)
{
  int m_isLeader; // r6
  void *v5; // r4
  unsigned __int16 v6; // r0
  CTaskComplex *v7; // r0
  CPed *m_pPed; // r6
  float m_giveUpDist; // r5

  if ( this->m_pPed )
  {
    m_isLeader = this->m_isLeader;
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
    if ( m_isLeader )
    {
      v5 = CTask::operator new(0x38u);
      v6 = rand();
      CTaskComplexWander::CTaskComplexWander(
        (CTaskComplexWander *)v5,
        4,
        (int)(float)((float)((float)v6 * 0.000015259) * 8.0),
        1,
        0.5);
      *((_WORD *)v5 + 24) = 0;
      *(_DWORD *)v5 = &off_66C58C;
      *((_DWORD *)v5 + 13) = 0;
      *((_DWORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 11) = 0;
    }
    else
    {
      v7 = (CTaskComplex *)CTask::operator new(0x20u);
      m_pPed = this->m_pPed;
      v5 = v7;
      m_giveUpDist = this->m_giveUpDist;
      CTaskComplex::CTaskComplex(v7);
      *((float *)v5 + 4) = m_giveUpDist;
      *((_DWORD *)v5 + 5) = 0;
      *((_DWORD *)v5 + 6) = 0;
      *((_DWORD *)v5 + 7) = 0;
      *(_DWORD *)v5 = &off_66CE74;
      *((_DWORD *)v5 + 3) = m_pPed;
      CEntity::RegisterReference(m_pPed, (CEntity **)v5 + 3);
      *((float *)v5 + 4) = m_giveUpDist;
    }
  }
  else
  {
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
    return 0;
  }
  return (CTask *)v5;
}
// 66C58C: using guessed type void *off_66C58C;
// 66CE74: using guessed type void *off_66CE74;
// 677A94: using guessed type void *`vtable for'CTaskComplexWanderStandard;

//----- (00536908) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInCouple::CreateFirstSubTask(CTaskComplexBeInCouple *this, CPed *pPed)
{
  return (CTask *)(*((int (__fastcall **)(CTaskComplexBeInCouple *, CPed *))this->_vptr$CTask + 10))(this, pPed);
}

//----- (00536910) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInCouple::ControlSubTask(CTaskComplexBeInCouple *this, CPed *pPed)
{
  CPed *m_pPed; // r0
  int m_isLeader; // r6
  CTask *TaskByType; // r0
  bool v7; // zf
  void *v8; // r4
  CTask *ActiveTaskByType; // r8
  CTask *v11; // r9
  CPed *v12; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r6
  int v15; // r10
  float *p_xx; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float v19; // s16
  CTask *v20; // r0
  int v21; // r1
  CPed *v22; // r2
  CSimpleTransform *v23; // r0
  CMatrix *v24; // r1
  CMatrix *v25; // r3
  float *v26; // r1
  bool v27; // zf
  float v28; // s22
  float v29; // s24
  float v30; // s18
  CMatrix *v31; // r0
  RwReal v32; // s2
  RwReal v33; // s0
  unsigned __int16 v34; // r0
  unsigned __int16 v35; // r0
  CPed *v36; // r5
  RwV3d_0 pOffsetPos; // [sp+24h] [bp-4Ch] BYREF

  m_pPed = this->m_pPed;
  if ( !m_pPed || !CPed::IsAlive(m_pPed) )
  {
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
    if ( !IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
      return 0;
LABEL_18:
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
    return 0;
  }
  m_isLeader = this->m_isLeader;
  TaskByType = CPedIntelligence::FindTaskByType(this->m_pPed->m_pPedIntelligence, 1215);
  if ( m_isLeader )
  {
    if ( TaskByType && !LOBYTE(TaskByType[2].m_pParent) )
      goto LABEL_14;
LABEL_15:
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
    if ( !IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
      return 0;
    goto LABEL_18;
  }
  v7 = TaskByType == 0;
  if ( TaskByType )
    v7 = LOBYTE(TaskByType[2].m_pParent) == 0;
  if ( v7 )
    goto LABEL_15;
LABEL_14:
  if ( (CPed *)TaskByType[2]._vptr$CTask != pPed )
    goto LABEL_15;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 1215);
  v11 = CTaskManager::FindActiveTaskByType(&this->m_pPed->m_pPedIntelligence->m_taskManager, 1215);
  v12 = this->m_pPed;
  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  v15 = 1;
  p_xx = &v12->m_pMat->xx;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  p_x = p_xx + 12;
  if ( !p_xx )
    p_x = &v12->m_transform.m_translate.x;
  v19 = (float)((float)((float)(*p_xx * p_tx->m_translate.x) + (float)(p_xx[1] * p_tx->m_translate.y))
              + (float)(p_xx[2] * p_tx->m_translate.z))
      - (float)((float)((float)(*p_xx * *p_x) + (float)(p_xx[1] * p_x[1])) + (float)(p_xx[2] * p_x[2]));
  if ( v19 < 0.0 )
    v15 = 2;
  if ( !this->m_isLeader )
  {
    v20 = CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 1208);
    if ( v20 )
    {
      v21 = 1065772646;
      if ( v19 < 0.0 )
        v21 = -1081711002;
      v20[2].m_pParent = (CTask *)v21;
      v20[3]._vptr$CTask = 0;
      v20[3].m_pParent = 0;
    }
  }
  v22 = this->m_pPed;
  v23 = &pPed->m_transform;
  v24 = pPed->m_pMat;
  v25 = v22->m_pMat;
  if ( v24 )
    v23 = (CSimpleTransform *)&v24->tx;
  v26 = &v25->tx;
  if ( !v25 )
    v26 = &v22->m_transform.m_translate.x;
  v27 = v11 == 0;
  if ( v11 )
    v27 = ActiveTaskByType == 0;
  if ( v27
    || (v28 = *v26 - v23->m_translate.x,
        v29 = v26[1] - v23->m_translate.y,
        v30 = (float)((float)(v28 * v28) + (float)(v29 * v29)) + 0.0,
        v30 > (float)(this->m_giveUpDist * this->m_giveUpDist)) )
  {
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
    if ( !IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
      return 0;
    goto LABEL_18;
  }
  if ( v30 <= 4.0 || !this->m_isLeader )
    goto LABEL_78;
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
  if ( !CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 1213) )
  {
    v8 = CTask::operator new(0x2Cu);
    v36 = this->m_pPed;
    CTaskComplex::CTaskComplex((CTaskComplex *)v8);
    *((_WORD *)v8 + 18) = 0;
    *((_QWORD *)v8 + 2) = 0x4E203F400000LL;
    *((_BYTE *)v8 + 24) = 0;
    *((_DWORD *)v8 + 7) = 0;
    *((_DWORD *)v8 + 8) = 0;
    *(_DWORD *)v8 = &off_66CEB0;
    *((_DWORD *)v8 + 3) = v36;
    CEntity::RegisterReference(v36, (CEntity **)v8 + 3);
  }
  else
  {
LABEL_78:
    if ( this->m_holdHands )
    {
      v31 = pPed->m_pMat;
      if ( v31 )
        p_m_transform = (CSimpleTransform *)&v31->tx;
      v32 = (float)(v29 * 0.5) + p_m_transform->m_translate.y;
      v33 = (float)(v28 * 0.5) + p_m_transform->m_translate.x;
      pOffsetPos.z = p_m_transform->m_translate.z + 0.0;
      pOffsetPos.y = v32;
      pOffsetPos.x = v33;
      if ( v30 >= 2.25 )
      {
        if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
          IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
        if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
          IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
      }
      else
      {
        if ( v15 != this->m_prevSide )
        {
          if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
            IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 250);
          if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 1, pPed) )
            IKChainManager_c::AbortPointArm(&g_ikChainMan, 1, pPed, 250);
        }
        if ( v19 >= 0.0 )
        {
          IKChainManager_c::PointArm(
            &g_ikChainMan,
            "CTaskComplexBeInCouple",
            1,
            pPed,
            0,
            -1,
            &pOffsetPos,
            0.5,
            250,
            30.0);
          this->m_prevSide = 1;
        }
        else
        {
          IKChainManager_c::PointArm(
            &g_ikChainMan,
            "CTaskComplexBeInCouple",
            0,
            pPed,
            0,
            -1,
            &pOffsetPos,
            0.5,
            250,
            30.0);
          this->m_prevSide = 2;
        }
      }
    }
    if ( this->m_lookAtEachOther )
    {
      if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
        && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 81 )
      {
        v34 = rand();
        IKChainManager_c::LookAt(
          &g_ikChainMan,
          "TaskBeInCouple",
          pPed,
          this->m_pPed,
          (int)(float)((float)((float)v34 * 0.000015259) * 2000.0) + 2000,
          5,
          0,
          0,
          0.25,
          500,
          3,
          0);
      }
      if ( !IKChainManager_c::IsLooking(&g_ikChainMan, this->m_pPed)
        && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 81 )
      {
        v35 = rand();
        IKChainManager_c::LookAt(
          &g_ikChainMan,
          "TaskBeInCouple",
          this->m_pPed,
          pPed,
          (int)(float)((float)((float)v35 * 0.000015259) * 2000.0) + 2000,
          5,
          0,
          0,
          0.25,
          500,
          3,
          0);
      }
    }
    return this->m_pSubTask;
  }
  return (CTask *)v8;
}
// 66CEB0: using guessed type void *off_66CEB0;

//----- (00536F30) --------------------------------------------------------
int32 __fastcall CTaskComplexBeInCouple::GetPartnerSide(CTaskComplexBeInCouple *this, CPed *pPed)
{
  CPed *m_pPed; // r12
  CMatrix *m_pMat; // r2
  float *p_xx; // r0
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  bool v7; // zf
  float v8; // s6
  float v9; // s8
  float v10; // s0
  float v11; // s10
  int32 result; // r0

  m_pPed = this->m_pPed;
  m_pMat = pPed->m_pMat;
  p_xx = &m_pPed->m_pMat->xx;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_x = p_xx + 12;
  v7 = p_xx == 0;
  v8 = *p_xx;
  v9 = p_xx[1];
  v10 = *p_xx * p_tx->m_translate.x;
  v11 = p_xx[2];
  result = 1;
  if ( v7 )
    p_x = &m_pPed->m_transform.m_translate.x;
  if ( (float)((float)((float)(v10 + (float)(v9 * p_tx->m_translate.y)) + (float)(v11 * p_tx->m_translate.z))
             - (float)((float)((float)(v8 * *p_x) + (float)(v9 * p_x[1])) + (float)(v11 * p_x[2]))) < 0.0 )
    return 2;
  return result;
}

//----- (00536FB2) --------------------------------------------------------
int __fastcall CTaskComplexPartner::GetTaskType(const CTaskComplexPartner *this)
{
  return 256;
}

//----- (00536FB8) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerDeal::Clone(const CTaskComplexPartnerDeal *this)
{
  char *v2; // r4
  __int64 v3; // d8
  __int64 v4; // d9
  CPed *m_pPartner; // r5

  v2 = (char *)CTask::operator new(0x74u);
  v3 = *(_QWORD *)&this->m_meetDist;
  v4 = *(_QWORD *)&this->m_targetPos.y;
  m_pPartner = this->m_pPartner;
  LOBYTE(this) = this->m_isLeader;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 60) = v3;
  *(_QWORD *)(v2 + 68) = v4;
  v2[88] = (char)this;
  *(_DWORD *)(v2 + 89) = (char *)&elf_hash_chain[16230] + 1;
  v2[110] = 0;
  *(_WORD *)(v2 + 93) = 1;
  *(_DWORD *)v2 = &off_66CCD0;
  *((_DWORD *)v2 + 14) = m_pPartner;
  if ( m_pPartner )
    CEntity::RegisterReference(m_pPartner, (CEntity **)v2 + 14);
  *((_DWORD *)v2 + 13) = 1202;
  *(_DWORD *)v2 = &off_66CD18;
  strcpy(v2 + 94, "gangs");
  return (CTask *)v2;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 66CCD0: using guessed type void *off_66CCD0;
// 66CD18: using guessed type void *off_66CD18;

//----- (0053705C) --------------------------------------------------------
int __fastcall CTaskComplexPartnerDeal::GetTaskType(const CTaskComplexPartnerDeal *this)
{
  return 1202;
}

//----- (00537064) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerGreet::Clone(const CTaskComplexPartnerGreet *this)
{
  char *v2; // r4
  __int64 v3; // d8
  __int64 v4; // d9
  int32 m_subType; // r8
  CPed *m_pPartner; // r5

  v2 = (char *)CTask::operator new(0x78u);
  v3 = *(_QWORD *)&this->m_meetDist;
  v4 = *(_QWORD *)&this->m_targetPos.y;
  m_subType = this->m_subType;
  m_pPartner = this->m_pPartner;
  LOBYTE(this) = this->m_isLeader;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 60) = v3;
  *(_QWORD *)(v2 + 68) = v4;
  v2[88] = (char)this;
  *(_DWORD *)(v2 + 89) = (char *)&elf_hash_chain[16230] + 1;
  v2[110] = 0;
  *(_WORD *)(v2 + 93) = 1;
  *(_DWORD *)v2 = &off_66CCD0;
  *((_DWORD *)v2 + 14) = m_pPartner;
  if ( m_pPartner )
    CEntity::RegisterReference(m_pPartner, (CEntity **)v2 + 14);
  *((_DWORD *)v2 + 13) = 1203;
  *((_DWORD *)v2 + 29) = m_subType;
  *(_DWORD *)v2 = &off_66CD60;
  strcpy(v2 + 94, "gangs");
  return (CTask *)v2;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 66CCD0: using guessed type void *off_66CCD0;
// 66CD60: using guessed type void *off_66CD60;

//----- (00537110) --------------------------------------------------------
int __fastcall CTaskComplexPartnerGreet::GetTaskType(const CTaskComplexPartnerGreet *this)
{
  return 1203;
}

//----- (00537118) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerChat::Clone(const CTaskComplexPartnerChat *this)
{
  char *v2; // r4
  __int64 v3; // d8
  __int64 v4; // d9
  int m_useAudio; // r9
  bool8 m_defaultToNonAudio; // r8
  CPed *m_pPartner; // r6
  int8 m_numLoops; // r10
  bool8 m_isLeader; // r11
  unsigned __int8 *m_idString; // r5

  v2 = (char *)CTask::operator new(0x78u);
  v3 = *(_QWORD *)&this->m_meetDist;
  v4 = *(_QWORD *)&this->m_targetPos.y;
  m_useAudio = this->m_useAudio;
  m_defaultToNonAudio = this->m_defaultToNonAudio;
  m_pPartner = this->m_pPartner;
  m_numLoops = this->m_numLoops;
  m_isLeader = this->m_isLeader;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  m_idString = this->m_idString;
  *(_QWORD *)(v2 + 60) = v3;
  *(_QWORD *)(v2 + 68) = v4;
  v2[88] = m_isLeader;
  v2[91] = m_numLoops;
  *((_WORD *)v2 + 46) = 0;
  *(_WORD *)(v2 + 89) = -255;
  v2[110] = 0;
  v2[94] = 0;
  *(_DWORD *)v2 = &off_66CCD0;
  *((_DWORD *)v2 + 14) = m_pPartner;
  if ( m_pPartner )
    CEntity::RegisterReference(m_pPartner, (CEntity **)v2 + 14);
  *((_DWORD *)v2 + 13) = 1204;
  v2[116] = 0;
  v2[114] = m_useAudio;
  *(_DWORD *)v2 = &off_66CDA8;
  if ( m_useAudio )
    v2[91] = 4;
  v2[115] = m_defaultToNonAudio;
  strcpy(v2 + 20, (const char *)m_idString);
  return (CTask *)v2;
}
// 66CCD0: using guessed type void *off_66CCD0;
// 66CDA8: using guessed type void *off_66CDA8;

//----- (005371E4) --------------------------------------------------------
int __fastcall CTaskComplexPartnerChat::GetTaskType(const CTaskComplexPartnerChat *this)
{
  return 1204;
}

//----- (005371EC) --------------------------------------------------------
void __fastcall CTaskComplexPartnerChat::Serialize(CTaskComplexPartnerChat *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  float *v6; // r5
  _DWORD *v7; // r5
  __int64 v8; // d16
  int v9; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexPartnerChat *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexPartnerChat *))this->_vptr$CTask + 5))(this) == 1204 )
  {
    v4 = GettPoolPedRef(this->m_pPartner);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(this->m_idString, 32);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_isLeader, 1);
    if ( UseDataFence )
      AddDataFence();
    v6 = (float *)malloc(4u);
    *v6 = this->m_meetDist;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_numLoops, 1);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_useAudio, 1);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_defaultToNonAudio, 1);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(0xCu);
    v8 = *(_QWORD *)&this->m_targetPos.x;
    v7[2] = LODWORD(this->m_targetPos.z);
    *(_QWORD *)v7 = v8;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 12);
    j_free(v7);
  }
  else
  {
    v9 = (*((int (__fastcall **)(CTaskComplexPartnerChat *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1204, v9);
  }
}

//----- (00537390) --------------------------------------------------------
int __fastcall CTaskComplexChat::GetTaskType(const CTaskComplexChat *this)
{
  return 1218;
}

//----- (00537398) --------------------------------------------------------
CTask *__fastcall CTaskComplexPartnerShove::Clone(const CTaskComplexPartnerShove *this)
{
  char *v2; // r4
  __int64 v3; // d8
  __int64 v4; // d9
  CPed *m_pPartner; // r5
  int8 m_numLoops; // r8

  v2 = (char *)CTask::operator new(0x74u);
  v3 = *(_QWORD *)&this->m_meetDist;
  v4 = *(_QWORD *)&this->m_targetPos.y;
  m_pPartner = this->m_pPartner;
  m_numLoops = this->m_numLoops;
  LOBYTE(this) = this->m_isLeader;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 60) = v3;
  *(_QWORD *)(v2 + 68) = v4;
  v2[88] = (char)this;
  v2[91] = m_numLoops;
  *((_WORD *)v2 + 46) = 0;
  *(_WORD *)(v2 + 89) = -255;
  v2[110] = 0;
  v2[94] = 0;
  *(_DWORD *)v2 = &off_66CCD0;
  *((_DWORD *)v2 + 14) = m_pPartner;
  if ( m_pPartner )
    CEntity::RegisterReference(m_pPartner, (CEntity **)v2 + 14);
  v2[91] = m_numLoops;
  *((_DWORD *)v2 + 13) = 1209;
  *(_DWORD *)v2 = &off_66CE2C;
  return (CTask *)v2;
}
// 66CCD0: using guessed type void *off_66CCD0;
// 66CE2C: using guessed type void *off_66CE2C;

//----- (00537434) --------------------------------------------------------
int __fastcall CTaskComplexPartnerShove::GetTaskType(const CTaskComplexPartnerShove *this)
{
  return 1209;
}

//----- (0053743C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkAlongsidePed::Clone(const CTaskComplexWalkAlongsidePed *this)
{
  void *v2; // r5
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *(_DWORD *)v2 = &off_66CE74;
  *((_DWORD *)v2 + 3) = v3;
  CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  return (CTask *)v2;
}
// 66CE74: using guessed type void *off_66CE74;

//----- (00537484) --------------------------------------------------------
int __fastcall CTaskComplexWalkAlongsidePed::GetTaskType(const CTaskComplexWalkAlongsidePed *this)
{
  return 1208;
}

//----- (0053748C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForPed::Clone(const CTaskComplexWaitForPed *this)
{
  void *v2; // r5
  CPed *m_pPed; // r6
  __int64 v4; // r8

  v2 = CTask::operator new(0x2Cu);
  m_pPed = this->m_pPed;
  v4 = *(_QWORD *)&this->m_targetDist;
  LOBYTE(this) = this->m_lookAtPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 18) = 0;
  *((_QWORD *)v2 + 2) = v4;
  *((_BYTE *)v2 + 24) = (_BYTE)this;
  *((_DWORD *)v2 + 7) = 0;
  *((_DWORD *)v2 + 8) = 0;
  *(_DWORD *)v2 = &off_66CEB0;
  *((_DWORD *)v2 + 3) = m_pPed;
  CEntity::RegisterReference(m_pPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66CEB0: using guessed type void *off_66CEB0;

//----- (005374DC) --------------------------------------------------------
int __fastcall CTaskComplexWaitForPed::GetTaskType(const CTaskComplexWaitForPed *this)
{
  return 1213;
}

//----- (005374E4) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInCouple::Clone(const CTaskComplexBeInCouple *this)
{
  void *v2; // r4
  CPed *m_pPed; // r5
  float m_giveUpDist; // r8
  bool8 m_lookAtEachOther; // r9

  v2 = CTask::operator new(0x20u);
  m_pPed = this->m_pPed;
  m_giveUpDist = this->m_giveUpDist;
  m_lookAtEachOther = this->m_lookAtEachOther;
  LOWORD(this) = *(_WORD *)&this->m_isLeader;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 10) = (_WORD)this;
  *((_BYTE *)v2 + 22) = m_lookAtEachOther;
  *((float *)v2 + 6) = m_giveUpDist;
  *((_BYTE *)v2 + 28) = 0;
  *(_DWORD *)v2 = &off_66CEEC;
  *((_DWORD *)v2 + 4) = m_pPed;
  if ( m_pPed )
    CEntity::RegisterReference(m_pPed, (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 66CEEC: using guessed type void *off_66CEEC;

//----- (0053753C) --------------------------------------------------------
int __fastcall CTaskComplexBeInCouple::GetTaskType(const CTaskComplexBeInCouple *this)
{
  return 1215;
}

//----- (00537550) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::CTaskSimplePlayerOnFoot(CTaskSimplePlayerOnFoot *this)
{
  int32 AnimationBlockIndex; // r0
  uint32 v3; // r1

  CTaskSimple::CTaskSimple(this);
  this->_vptr$CTask = (int (**)(void))&off_66CF28;
  AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("playidles");
  v3 = CTimer::m_FrameCounter;
  this->m_nPlayerIdlesAnimBlock = AnimationBlockIndex;
  this->m_nLastFrameProcessed = v3;
  this->m_nFightIdleMoveCount = 0;
  this->m_fControlSprint = 0.0;
  this->m_lastLookAtEntity = 0;
}
// 66CF28: using guessed type void *;

//----- (00537594) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::~CTaskSimplePlayerOnFoot(CTaskSimplePlayerOnFoot *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 5375A0: variable 'v1' is possibly undefined

//----- (005375A4) --------------------------------------------------------
bool __fastcall CTaskSimplePlayerOnFoot::MakeAbortable(
        CTaskSimplePlayerOnFoot *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v6; // r6
  CTask *TaskSecondary; // r0
  CTask *v8; // r0
  CTask *v9; // r0
  _BOOL4 v10; // r0
  bool v11; // zf
  int (**v12)(void); // r0

  if ( iPriority != 1 )
  {
    if ( iPriority == 2 )
    {
      pPed->m_pPlayerData->m_moveBlendRatio = 0.0;
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
      goto LABEL_14;
    }
    return 0;
  }
  if ( !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0) )
    goto LABEL_14;
  if ( pEvent )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent) < 61 )
      return 0;
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
    {
      TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
      if ( (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1018
        || (*(&pEvent[2].m_bIsPersistent + 1) & 2) != 0 )
      {
        v8 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
        (*((void (__fastcall **)(CTask *, CPed *, int, const CEvent *))v8->_vptr$CTask + 7))(v8, pPed, 1, pEvent);
      }
LABEL_14:
      if ( pPed->m_pEntLockOnTarget || (*((_BYTE *)pPed->m_pPlayerData + 52) & 8) != 0 )
      {
        if ( !pEvent )
          return 1;
      }
      else
      {
        v10 = CCamera::Using1stPersonWeaponMode(&TheCamera);
        v6 = 1;
        if ( !pEvent || !v10 )
          return v6;
      }
      if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 9
        && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 66 )
      {
        return 1;
      }
      if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 9 )
        goto LABEL_31;
      v11 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
      if ( LOBYTE(pEvent[5]._vptr$CEvent) )
        v11 = !*(&pEvent->m_bIsPersistent + 1);
      if ( !v11 )
        goto LABEL_31;
      if ( !pPed->m_pAttachToEntity )
      {
        if ( (*(&pEvent[2].m_bIsPersistent + 1) & 2) == 0 )
        {
          v12 = pEvent[2]._vptr$CEvent;
          v6 = 1;
          if ( (int)v12 < 48 || v12 == (int (**)(void))&dword_34 )
            return v6;
        }
LABEL_31:
        CCamera::ClearPlayerWeaponMode(&TheCamera);
        CWeaponEffects::ClearCrossHair(pPed->m_nPedType);
        CPed::SetWeaponLockOnTarget(pPed, 0);
      }
      return 1;
    }
  }
  if ( !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0) )
    goto LABEL_14;
  v6 = 0;
  v9 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))v9->_vptr$CTask + 7))(v9, pPed, 1, pEvent) == 1 )
    goto LABEL_14;
  return v6;
}
// 34: using guessed type int dword_34;

//----- (0053770C) --------------------------------------------------------
void __fastcall CheckForTargetToPutHandsUp(CPlayerPed *pPlayerPed, CPed *pTargetPed)
{
  CWeaponInfo *WeaponInfo; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CPedIntelligence *m_pPedIntelligence; // r1
  CTask *v8; // r0
  bool v9; // zf
  CPedGroup *PedsGroup; // r6
  CEventGunAimedAt *v11; // r8
  CEventGroupEvent v12; // [sp+Ch] [bp-24h] BYREF

  WeaponInfo = CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1);
  if ( pTargetPed && WeaponInfo->m_eFireType == FIRETYPE_INSTANT_HIT )
  {
    m_pMat = pPlayerPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPlayerPed->m_transform;
    if ( CPedIntelligence::IsInSeeingRange(pTargetPed->m_pPedIntelligence, &p_tx->m_translate) )
    {
      m_pPedIntelligence = pTargetPed->m_pPedIntelligence;
      v8 = m_pPedIntelligence->m_taskManager.m_tasks[0];
      v9 = v8 == 0;
      if ( !v8 )
      {
        v8 = m_pPedIntelligence->m_taskManager.m_tasks[1];
        v9 = v8 == 0;
      }
      if ( v9 && (v8 = m_pPedIntelligence->m_taskManager.m_tasks[2]) == 0
        || (*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 5))(v8) != 601 )
      {
        if ( pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType != WEAPONTYPE_PISTOL_SILENCED )
          CPed::Say(pPlayerPed, 0xB0u, 0, 1.0, 0, 0, 0);
        PedsGroup = CPedGroups::GetPedsGroup(pTargetPed);
        if ( PedsGroup )
        {
          if ( !CPedGroups::AreInSameGroup(pTargetPed, pPlayerPed) )
          {
            v11 = (CEventGunAimedAt *)CEvent::operator new(0x14u);
            CEventGunAimedAt::CEventGunAimedAt(v11, pPlayerPed);
            CEventGroupEvent::CEventGroupEvent(&v12, pTargetPed, (CEvent *)v11);
            CPedGroupIntelligence::AddEvent(&PedsGroup->m_intelligence, &v12);
            CEventGroupEvent::~CEventGroupEvent(&v12);
          }
        }
        else
        {
          CEventGunAimedAt::CEventGunAimedAt((CEventGunAimedAt *)&v12, pPlayerPed);
          CEventGroup::Add(&pTargetPed->m_pPedIntelligence->m_eventGroup, &v12, 0);
          CEventGunAimedAt::~CEventGunAimedAt((CEventGunAimedAt *)&v12);
        }
      }
    }
  }
}

//----- (00537808) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::ProcessPlayerWeapon(CTaskSimplePlayerOnFoot *this, CPlayerPed *pPlayerPed)
{
  CWeapon *m_WeaponSlots; // r6
  eWeaponType m_eWeaponType; // r5
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r8
  CEntity *m_pEntLockOnTarget; // r0
  CPed *m_pMouseLockOnRecruitPed; // r10
  eWeaponType v10; // r5
  CEntity *m_pEntMagnetizeTarget; // r9
  CEntity *v12; // r1
  CEntity *v13; // r2
  uint8 v14; // r1
  CPlayerPedData *m_pPlayerData; // r0
  char v16; // r11
  AssocGroupId m_animGroup; // r0
  CAnimBlock *m_pAnimBlock; // r0
  bool v19; // zf
  CAnimBlendAssociation *FirstAssociation; // r5
  char *v21; // r0
  int v22; // r1
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplexUseGoggles *v24; // r5
  int8 v25; // r8
  CTaskSimpleThrowProjectile *v26; // r0
  char v27; // r1
  CTaskSimpleUseGun *v28; // r0
  int v29; // r0
  bool v30; // zf
  int v31; // r8
  CTaskSimpleStealthKill *v32; // r5
  const CEventDamage *v33; // r0
  int v34; // r8
  Int16 v35; // r1
  CMatrix *m_pMat; // r1
  CWeapon *v37; // r0
  CSimpleTransform *p_tx; // r2
  int MeleeAttack; // r0
  CPedIntelligence **p_m_pPedIntelligence; // r6
  CTask *ActiveTaskByType; // r6
  CPlayerPedData *v42; // r3
  char *v43; // r0
  int v44; // r6
  CTask *v45; // r0
  CPedIntelligence *v46; // r11
  int8 v47; // r5
  CTask *v48; // r0
  int v49; // r1
  CPedIntelligence *v50; // r0
  CTaskSimpleUseGun *v51; // r0
  _BOOL4 Target; // r0
  bool v53; // zf
  CPedIntelligence *v54; // r6
  CTaskSimpleThrowProjectile *v55; // r5
  CTask *v56; // r0
  CPedIntelligence *v57; // r5
  CTask *v58; // r0
  int v59; // r1
  CPedIntelligence *v60; // r0
  CTaskSimpleUseGun *v61; // r0
  CTaskSimpleUseGun *v62; // r6
  CTask *v63; // r0
  CAnimBlendAssociation *Association; // r0
  CTask *TaskSecondary; // r0
  CPedIntelligence *v66; // r5
  CTaskSimpleFight *v67; // r0
  CTaskSimpleFight *v68; // r6
  CTaskSimpleUseGun *v69; // r0
  eWeaponType v70; // r5
  eMoveState m_eMoveState; // r0
  bool v72; // zf
  _BOOL4 IsTargetingActive; // r0
  bool v74; // zf
  CTask *v75; // r0
  CPedIntelligence *v76; // r5
  CTaskSimpleUseGun *v77; // r0
  CPedIntelligence **v78; // r5
  CPad *v79; // r6
  float y; // s16
  CTaskSimpleFight *TaskFighting; // r0
  int8 v82; // r2
  CTaskSimpleUseGun *TaskUseGun; // r0
  CTaskSimpleUseGun *v84; // r0
  __int64 v85; // kr00_8
  CTaskSimpleUseGun *v86; // r0
  CEntity *v87; // r5
  _BOOL4 v88; // r6
  CTaskSimpleFight *v89; // r0
  CMatrix *v90; // r0
  CMatrix *v91; // r1
  CSimpleTransform *p_m_transform; // r2
  float *p_x; // r3
  float v94; // s20
  float v95; // s18
  float v96; // s16
  float xy; // s4
  float yy; // s2
  float zy; // s0
  int v100; // r1
  AssocGroupId v101; // r1
  RpClump_0 *m_pRwObject; // r0
  int v103; // r2
  float m_heading; // r6
  float v105; // r8
  int32 v106; // r3
  CTaskSimpleDuck *v107; // r0
  CAnimBlendAssociation *v108; // r1
  int v109; // r1
  CTaskSimpleFight *v110; // r5
  CTaskSimpleUseGun *v111; // r9
  eWeaponType v112; // r5
  int8 v113; // r1
  eWeaponType v114; // r0
  __int16 v115; // r1
  int v116; // r0
  bool v117; // zf
  bool v118; // zf
  int v119; // r0
  bool v120; // zf
  unsigned int v121; // r1
  CPad *v122; // r0
  CEntity *v123; // r1
  CPlayerPed *v124; // r0
  bool v125; // r2
  CEntity *v126; // r5
  _BOOL4 v127; // r0
  CTask *v128; // r0
  CTask *v129; // r5
  CPlayerPedData *v130; // r0
  __int16 v131; // r1
  eFireType m_eFireType; // r1
  bool v133; // zf
  CWeaponInfo *v134; // r6
  CTaskSimpleUseGun *v135; // r8
  CTask *v136; // r1
  CTaskSimpleDuck *TaskDuck; // r0
  CTask *v138; // r0
  CTask *v139; // r0
  int InputType; // r0
  bool v141; // zf
  CEntity *v142; // r2
  CMatrix *v143; // r3
  CEventDamage *v144; // r1
  CMatrix *v145; // r5
  __int64 v146; // d16
  float v147; // s2
  CSimpleTransform *v148; // r0
  float v149; // s0
  float v150; // s10
  float v151; // s0
  CTask *v152; // r0
  CPedIntelligence *v153; // r5
  CTaskSimpleUseGun *v154; // r6
  CAnimBlendAssociation *m_pDuckAnim; // r1
  CTaskSimplePlayerOnFoot *v156; // [sp+24h] [bp-A4h]
  CTaskSimplePlayerOnFoot *v157; // [sp+24h] [bp-A4h]
  CWeaponInfo *v158; // [sp+28h] [bp-A0h]
  CEntity *v159; // [sp+2Ch] [bp-9Ch]
  eWeaponType v160; // [sp+30h] [bp-98h]
  CPad *PadFromPlayer; // [sp+34h] [bp-94h]
  CEventDamage v162; // [sp+38h] [bp-90h] BYREF
  CPedDamageResponseCalculator v163; // [sp+78h] [bp-50h] BYREF
  CVector cvector; // 0:r2.8,8:^0.4
  CVector v165; // 0:r2.8,8:^0.4
  CVector cvectorb; // 0:r2.8,8:^0.4
  CVector v167; // 0:r2.8,8:^0.4

  if ( CTheScripts::bDrawCrossHair == SCRIPT_CROSSHAIR_CAMERA )
    return;
  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  m_WeaponSlots = pPlayerPed->m_WeaponSlots;
  m_eWeaponType = pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(pPlayerPed);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  m_pEntLockOnTarget = pPlayerPed->m_pEntLockOnTarget;
  m_pMouseLockOnRecruitPed = 0;
  v10 = pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType;
  if ( m_pEntLockOnTarget && (*(_BYTE *)&m_pEntLockOnTarget->m_info & 7) == 3 )
    m_pMouseLockOnRecruitPed = (CPed *)pPlayerPed->m_pEntLockOnTarget;
  m_pEntMagnetizeTarget = pPlayerPed->m_pEntMagnetizeTarget;
  if ( m_pEntMagnetizeTarget && (*(_BYTE *)&m_pEntMagnetizeTarget->m_info & 7) == 3 )
    m_pMouseLockOnRecruitPed = (CPed *)pPlayerPed->m_pEntMagnetizeTarget;
  v12 = 0;
  if ( m_pEntLockOnTarget && (*(_BYTE *)&m_pEntLockOnTarget->m_info & 7) == 2 )
    v12 = pPlayerPed->m_pEntLockOnTarget;
  if ( m_pEntMagnetizeTarget )
  {
    v13 = v12;
    if ( (*(_BYTE *)&m_pEntMagnetizeTarget->m_info & 7) == 2 )
      v13 = pPlayerPed->m_pEntMagnetizeTarget;
    v159 = v13;
    if ( (*(_BYTE *)&m_pEntMagnetizeTarget->m_info & 7) != 2 )
      m_pEntMagnetizeTarget = v12;
  }
  else
  {
    m_pEntMagnetizeTarget = v12;
    v159 = v12;
  }
  if ( (*((_BYTE *)pPlayerPed->m_pPlayerData + 52) & 4) != 0 && !m_pEntLockOnTarget )
  {
    CCamera::ClearPlayerWeaponMode(&TheCamera);
    CWeaponEffects::ClearCrossHair(pPlayerPed->m_nPedType);
  }
  v14 = 100;
  if ( (WeaponInfo->m_nFlags & 1) != 0 )
    v14 = 95;
  pPlayerPed->m_nShootingAccuracy = v14;
  if ( CPad::WeaponJustDown(PadFromPlayer, pPlayerPed, 1, 0)
    && (m_pMouseLockOnRecruitPed || CHID::GetInputType() == 2 && pPlayerPed->m_pMouseLockOnRecruitPed) )
  {
    CPlayerPed::PlayerHasJustAttackedSomeone(pPlayerPed);
  }
  v160 = v10;
  if ( pPlayerPed->m_pFire || v10 != WEAPONTYPE_COUNTRYRIFLE && (WeaponInfo->m_nFlags & 4) == 0 )
  {
    if ( v10 == WEAPONTYPE_ROCKETLAUNCHER_HS && !CPad::GetTarget(PadFromPlayer, 0) )
    {
      m_pPlayerData = pPlayerPed->m_pPlayerData;
      m_pPlayerData->m_FireHSMissilePressedTime = 0;
      m_pPlayerData->m_LastHSMissileTarget = 0;
    }
LABEL_34:
    if ( WeaponInfo->m_eFireType == FIRETYPE_USE )
    {
      if ( CPad::WeaponJustDown(PadFromPlayer, pPlayerPed, 0, 1) )
      {
        v21 = (char *)pPlayerPed + 28 * pPlayerPed->m_nCurrentWeapon;
        v22 = *((_DWORD *)v21 + 361);
        if ( (unsigned int)(v22 - 44) >= 2 )
        {
          if ( v22 == 40 )
          {
            m_pMat = pPlayerPed->m_pMat;
            v37 = (CWeapon *)(v21 + 1444);
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &pPlayerPed->m_transform;
            CWeapon::Fire(v37, pPlayerPed, &p_tx->m_translate, &p_tx->m_translate, 0, 0, 0);
          }
        }
        else
        {
          m_pPedIntelligence = pPlayerPed->m_pPedIntelligence;
          if ( !m_pPedIntelligence->m_taskManager.m_tasks[3] )
          {
            v24 = (CTaskComplexUseGoggles *)CTask::operator new(0xCu);
            CTaskComplexUseGoggles::CTaskComplexUseGoggles(v24);
            CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v24, 3, 0);
            pPlayerPed->m_pPlayerData->m_bDontAllowWeaponChange = 1;
          }
        }
      }
    }
    else
    {
      if ( WeaponInfo->m_eFireType == FIRETYPE_MELEE )
      {
        v156 = this;
        v158 = WeaponInfo;
        if ( m_pMouseLockOnRecruitPed )
          goto LABEL_37;
        if ( !CPad::GetTarget(PadFromPlayer, 0)
          && !CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0) )
        {
          ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pPlayerPed->m_pPedIntelligence->m_taskManager, 307);
          v34 = 0;
          if ( CCamera::Using1stPersonWeaponMode(&TheCamera) || ActiveTaskByType )
          {
            p_m_pPedIntelligence = &pPlayerPed->m_pPedIntelligence;
          }
          else
          {
            p_m_pPedIntelligence = &pPlayerPed->m_pPedIntelligence;
            if ( !CRopes::PlayerControlsCrane )
            {
              if ( CPad::MeleeAttackJustDown(PadFromPlayer) )
              {
                v34 = 11;
                if ( CHID::IsPressed(HID_MAPPING_ENTER_AND_EXIT_TARGETING, 0) )
                  v34 = 12;
              }
              else
              {
                v34 = 0;
              }
            }
          }
          if ( CPad::GetBlock(PadFromPlayer) )
            v34 = 2;
          Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPlayerPed->m_pRwObject, 0x15Bu);
          m_pMouseLockOnRecruitPed = 0;
          if ( Association )
            Association->m_fBlendAmount = -2.0;
          if ( v34 << 24 )
            goto LABEL_151;
          goto LABEL_253;
        }
        if ( CHID::GetInputType() == 2 && (m_pMouseLockOnRecruitPed = pPlayerPed->m_pMouseLockOnRecruitPed) != 0 )
        {
LABEL_37:
          v16 = 1;
          if ( pPlayerPed->m_pPlayerData->m_moveBlendRatio < 1.9
            && pPlayerPed->m_eMoveState != PEDMOVE_SPRINT
            && !CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0) )
          {
            m_animGroup = WeaponInfo->m_animGroup;
            if ( m_animGroup )
            {
              m_pAnimBlock = CAnimManager::ms_aAnimAssocGroups[m_animGroup].m_pAnimBlock;
              v19 = m_pAnimBlock == 0;
              if ( m_pAnimBlock )
                v19 = !m_pAnimBlock->m_loaded;
              if ( !v19
                && CPedIntelligence::TestForStealthKill(pPlayerPed->m_pPedIntelligence, m_pMouseLockOnRecruitPed, 0) )
              {
                if ( (*((_BYTE *)&pPlayerPed->m_nPedFlags + 3) & 4) != 0 )
                {
                  if ( !CPedIntelligence::GetTaskDuck(pPlayerPed->m_pPedIntelligence, 1)
                    || (TaskDuck = CPedIntelligence::GetTaskDuck(pPlayerPed->m_pPedIntelligence, 1),
                        TaskDuck->m_vecMoveCommand.x == 0.0)
                    && TaskDuck->m_vecMoveCommand.y == 0.0
                    && (m_pDuckAnim = TaskDuck->m_pDuckAnim) != 0
                    && m_pDuckAnim->m_fBlendAmount >= 1.0
                    && !TaskDuck->m_bIsAborting
                    && TaskDuck->m_nShotWhizzingCounter < 1 )
                  {
                    FirstAssociation = CAnimManager::BlendAnimation(
                                         (RpClump_0 *)pPlayerPed->m_pRwObject,
                                         WeaponInfo->m_animGroup,
                                         ANIM_STEALTH_READY,
                                         8.0);
                  }
                  else
                  {
                    FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPlayerPed->m_pRwObject);
                  }
                }
                else
                {
                  FirstAssociation = 0;
                }
                goto LABEL_74;
              }
            }
          }
        }
        else
        {
          v16 = 0;
          m_pMouseLockOnRecruitPed = 0;
        }
        FirstAssociation = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPlayerPed->m_pRwObject, 0x15Bu);
        if ( FirstAssociation )
          FirstAssociation->m_fBlendAmount = -2.0;
        else
          FirstAssociation = 0;
LABEL_74:
        v29 = CPad::MeleeAttackJustDown(PadFromPlayer);
        v30 = FirstAssociation == 0;
        v31 = v29;
        if ( FirstAssociation )
          v30 = v29 == 0;
        if ( !v30
          && ((FirstAssociation->m_fBlendAmount > 0.5) & (unsigned __int8)v16) == 1
          && CPedIntelligence::TestForStealthKill(pPlayerPed->m_pPedIntelligence, m_pMouseLockOnRecruitPed, 1) )
        {
          v32 = (CTaskSimpleStealthKill *)CTask::operator new(0x20u);
          CTaskSimpleStealthKill::CTaskSimpleStealthKill(v32, 1, m_pMouseLockOnRecruitPed, v158->m_animGroup);
          CTaskManager::SetTask(&pPlayerPed->m_pPedIntelligence->m_taskManager, v32, 3, 0);
          CPedDamageResponseCalculator::CPedDamageResponseCalculator(
            &v163,
            pPlayerPed,
            0.0,
            (const eWeaponType)m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType,
            PED_SPHERE_CHEST,
            0);
          CEventDamage::CEventDamage(
            &v162,
            pPlayerPed,
            CTimer::m_snTimeInMilliseconds,
            (const eWeaponType)m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType,
            PED_SPHERE_CHEST,
            0,
            0,
            *(_DWORD *)&m_pMouseLockOnRecruitPed->m_nPedFlags & 0x100);
          if ( CEventDamage::AffectsPed(v33, m_pMouseLockOnRecruitPed) )
          {
            CPedDamageResponseCalculator::ComputeDamageResponse(
              &v163,
              m_pMouseLockOnRecruitPed,
              &v162.m_pedDamageResponse,
              0);
            CEventGroup::Add(&m_pMouseLockOnRecruitPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v162, 0);
            CCrime::ReportCrime(CRIME_STAB_PED, m_pMouseLockOnRecruitPed, pPlayerPed);
            CAEPedWeaponAudioEntity::AddAudioEvent(&pPlayerPed->m_PedWeaponAudioEntity, 156);
          }
          CPlayerPed::ClearWeaponTarget(pPlayerPed);
          CEventDamage::~CEventDamage(&v162);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v163);
          this = v156;
          WeaponInfo = v158;
          goto LABEL_156;
        }
        if ( v31 == 1 )
        {
          LOBYTE(v34) = 11;
          this = v156;
          goto LABEL_151;
        }
        this = v156;
        if ( (unsigned __int8)v31 == 2 )
        {
          LOBYTE(v34) = 12;
          if ( (CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_nFlags & 0x200) != 0 )
            LOBYTE(v34) = 11;
          goto LABEL_151;
        }
        if ( CPad::GetBlock(PadFromPlayer) )
        {
          LOBYTE(v34) = 2;
          goto LABEL_151;
        }
        MeleeAttack = CPad::GetMeleeAttack(PadFromPlayer);
        p_m_pPedIntelligence = &pPlayerPed->m_pPedIntelligence;
        if ( v160 == WEAPONTYPE_CHAINSAW
          && MeleeAttack
          && CTaskManager::GetTaskSecondary(&(*p_m_pPedIntelligence)->m_taskManager, 0) )
        {
          LOBYTE(v34) = 11;
LABEL_151:
          TaskSecondary = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
          v66 = pPlayerPed->m_pPedIntelligence;
          if ( TaskSecondary )
          {
            if ( CPedIntelligence::GetTaskFighting(pPlayerPed->m_pPedIntelligence) )
            {
              v67 = (CTaskSimpleFight *)CTaskManager::GetTaskSecondary(
                                          &pPlayerPed->m_pPedIntelligence->m_taskManager,
                                          0);
              CTaskSimpleFight::ControlFight(v67, pPlayerPed->m_pEntLockOnTarget, v34);
            }
          }
          else
          {
            v68 = (CTaskSimpleFight *)CTask::operator new(0x28u);
            CTaskSimpleFight::CTaskSimpleFight(v68, pPlayerPed->m_pEntLockOnTarget, (char)v34, 0x7D0u);
            CTaskManager::SetTaskSecondary(&v66->m_taskManager, v68, 0);
          }
          goto LABEL_155;
        }
LABEL_253:
        if ( CPedIntelligence::GetTaskFighting(*p_m_pPedIntelligence) )
        {
          v110 = (CTaskSimpleFight *)CTaskManager::GetTaskSecondary(&(*p_m_pPedIntelligence)->m_taskManager, 0);
          WeaponInfo = v158;
          if ( pPlayerPed->m_eMoveState == PEDMOVE_STILL && CPad::GetSprint(PadFromPlayer, 0) )
            CTaskSimpleFight::ControlFight(v110, pPlayerPed->m_pEntLockOnTarget, 15);
          else
            CTaskSimpleFight::ControlFight(
              v110,
              pPlayerPed->m_pEntLockOnTarget,
              pPlayerPed->m_pPlayerData->m_nChosenWeapon != pPlayerPed->m_nCurrentWeapon);
          goto LABEL_156;
        }
LABEL_155:
        WeaponInfo = v158;
        goto LABEL_156;
      }
      if ( pPlayerPed->m_eMoveState != PEDMOVE_SPRINT
        && pPlayerPed->m_pPlayerData->m_nChosenWeapon == pPlayerPed->m_nCurrentWeapon
        && CPad::GetWeapon(PadFromPlayer, pPlayerPed, 1) )
      {
        switch ( WeaponInfo->m_eFireType )
        {
          case FIRETYPE_INSTANT_HIT:
          case FIRETYPE_AREA_EFFECT:
            v158 = WeaponInfo;
            if ( CTaskSimpleUseGun::RequirePistolWhip(pPlayerPed, pPlayerPed->m_pEntLockOnTarget) )
            {
              v25 = 5;
            }
            else if ( pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eState == WEAPONSTATE_RELOADING )
            {
              Target = CPad::GetTarget(PadFromPlayer, 0);
              v53 = !Target;
              if ( !Target )
                v53 = pPlayerPed->m_pEntLockOnTarget == 0;
              if ( v53 && (*((_BYTE *)pPlayerPed->m_pPlayerData + 52) & 8) == 0 )
                break;
              v25 = 1;
            }
            else
            {
              v25 = 2;
            }
            v56 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
            v57 = pPlayerPed->m_pPedIntelligence;
            if ( v56 )
            {
              v58 = CTaskManager::GetTaskSecondary(&v57->m_taskManager, 0);
              v59 = (*((int (__fastcall **)(CTask *))v58->_vptr$CTask + 5))(v58);
              v60 = pPlayerPed->m_pPedIntelligence;
              if ( v59 == 1017 )
              {
                if ( CPedIntelligence::GetTaskUseGun(v60) )
                {
                  v61 = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(
                                               &pPlayerPed->m_pPedIntelligence->m_taskManager,
                                               0);
                  CTaskSimpleUseGun::ControlGun(v61, pPlayerPed, pPlayerPed->m_pEntLockOnTarget, v25);
                }
              }
              else
              {
                v63 = CTaskManager::GetTaskSecondary(&v60->m_taskManager, 0);
                (*((void (__fastcall **)(CTask *, CPlayerPed *, int, _DWORD))v63->_vptr$CTask + 7))(
                  v63,
                  pPlayerPed,
                  1,
                  0);
              }
            }
            else
            {
              v62 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
              cvector.z = 0.0;
              *(_QWORD *)&cvector.x = 0LL;
              CTaskSimpleUseGun::CTaskSimpleUseGun(v62, pPlayerPed->m_pEntLockOnTarget, cvector, v25, 1, 0);
              CTaskManager::SetTaskSecondary(&v57->m_taskManager, v62, 0);
              pPlayerPed->m_pPlayerData->m_fAttackButtonCounter = 0.0;
            }
            if ( CPad::GetTarget(PadFromPlayer, 0) )
              goto LABEL_155;
            WeaponInfo = v158;
            if ( pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_EXTINGUISHER )
              pPlayerPed->m_pPlayerData->m_fLookPitch = -CWeapon::ms_fExtinguisherAimAngle;
            break;
          case FIRETYPE_PROJECTILE:
            v43 = (char *)pPlayerPed + 28 * pPlayerPed->m_nCurrentWeapon;
            if ( (unsigned int)(*((_DWORD *)v43 + 361) - 35) > 1 )
            {
              if ( CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0)
                || !CPad::WeaponJustDown(PadFromPlayer, pPlayerPed, 1, 1) )
              {
                if ( CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0)
                  && (v128 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0),
                      (*((int (__fastcall **)(CTask *))v128->_vptr$CTask + 5))(v128) != 1018) )
                {
                  v139 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
                  (*((void (__fastcall **)(CTask *, CPlayerPed *, int, _DWORD))v139->_vptr$CTask + 7))(
                    v139,
                    pPlayerPed,
                    1,
                    0);
                }
                else if ( CPedIntelligence::GetTaskThrow(pPlayerPed->m_pPedIntelligence) )
                {
                  v129 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
                  v27 = !CPad::WeaponJustDown(PadFromPlayer, pPlayerPed, 1, 1);
                  v26 = (CTaskSimpleThrowProjectile *)v129;
                  goto LABEL_59;
                }
              }
              else
              {
                v54 = pPlayerPed->m_pPedIntelligence;
                v55 = (CTaskSimpleThrowProjectile *)CTask::operator new(0x24u);
                CTaskSimpleThrowProjectile::CTaskSimpleThrowProjectile(v55, 0, 0, 0, 0);
                CTaskManager::SetTaskSecondary(&v54->m_taskManager, v55, 0);
              }
            }
            else
            {
              v157 = this;
              v44 = *((_DWORD *)v43 + 362);
              v45 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
              v46 = pPlayerPed->m_pPedIntelligence;
              v47 = 2;
              if ( v44 == 2 )
                v47 = 1;
              if ( v45 )
              {
                v48 = CTaskManager::GetTaskSecondary(&v46->m_taskManager, 0);
                v49 = (*((int (__fastcall **)(CTask *))v48->_vptr$CTask + 5))(v48);
                v50 = pPlayerPed->m_pPedIntelligence;
                if ( v49 == 1017 )
                {
                  this = v157;
                  if ( CPedIntelligence::GetTaskUseGun(v50) )
                  {
                    v51 = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(
                                                 &pPlayerPed->m_pPedIntelligence->m_taskManager,
                                                 0);
                    CTaskSimpleUseGun::ControlGun(v51, pPlayerPed, pPlayerPed->m_pEntLockOnTarget, v47);
                  }
                }
                else
                {
                  v138 = CTaskManager::GetTaskSecondary(&v50->m_taskManager, 0);
                  (*((void (__fastcall **)(CTask *, CPlayerPed *, int, _DWORD))v138->_vptr$CTask + 7))(
                    v138,
                    pPlayerPed,
                    1,
                    0);
                  this = v157;
                }
              }
              else
              {
                v134 = WeaponInfo;
                v135 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
                cvectorb.z = 0.0;
                *(_QWORD *)&cvectorb.x = 0LL;
                CTaskSimpleUseGun::CTaskSimpleUseGun(v135, pPlayerPed->m_pEntLockOnTarget, cvectorb, v47, 1, 0);
                v136 = v135;
                WeaponInfo = v134;
                CTaskManager::SetTaskSecondary(&v46->m_taskManager, v136, 0);
                this = v157;
              }
            }
            break;
          case FIRETYPE_CAMERA:
            if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 46
              && CTimer::m_snTimeInMilliseconds > pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_nTimer )
            {
              v162._vptr$CEvent = 0;
              v162.m_iAccumulatedTime = 0;
              *(_DWORD *)&v162.m_bIsPersistent = 1058642330;
              operator*((CVector *)&v163, pPlayerPed->m_pMat, (const CVector *)&v162);
              *(_DWORD *)&v162.m_bIsPersistent = v163.m_eHitZone;
              *(_QWORD *)&v162._vptr$CEvent = *(_QWORD *)&v163.m_pInflictor;
              CWeapon::Fire(
                &pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon],
                pPlayerPed,
                (CVector *)&v162,
                0,
                0,
                0,
                0);
            }
            break;
          default:
            break;
        }
      }
      else if ( CPedIntelligence::GetTaskThrow(pPlayerPed->m_pPedIntelligence) )
      {
        v26 = (CTaskSimpleThrowProjectile *)CTaskManager::GetTaskSecondary(
                                              &pPlayerPed->m_pPedIntelligence->m_taskManager,
                                              0);
        v27 = 1;
LABEL_59:
        CTaskSimpleThrowProjectile::ControlThrow(v26, v27, 0, 0);
      }
    }
LABEL_156:
    if ( pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eState == WEAPONSTATE_RELOADING
      && (WeaponInfo->m_nFlags & 0x1000) != 0 )
    {
      if ( CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence) )
      {
        v69 = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
        CTaskSimpleUseGun::ControlGun(v69, pPlayerPed, pPlayerPed->m_pEntLockOnTarget, 4);
        goto LABEL_160;
      }
      if ( (*((_BYTE *)&pPlayerPed->m_nPedFlags + 3) & 4) != 0 )
      {
        if ( (WeaponInfo->m_nFlags & 0x3000) == 12288 )
        {
          if ( CPedIntelligence::GetTaskDuck(pPlayerPed->m_pPedIntelligence, 1) )
          {
            v107 = CPedIntelligence::GetTaskDuck(pPlayerPed->m_pPedIntelligence, 1);
            if ( v107->m_vecMoveCommand.x == 0.0 && v107->m_vecMoveCommand.y == 0.0 )
            {
              v108 = v107->m_pDuckAnim;
              if ( v108 )
              {
                if ( v108->m_fBlendAmount >= 1.0 && !v107->m_bIsAborting && v107->m_nShotWhizzingCounter <= 0 )
                {
                  if ( (WeaponInfo->m_nFlags & 0x2000) != 0 )
                  {
                    v109 = WeaponInfo->m_nFlags & 0x1000;
                    if ( v109 )
                      v109 = 227;
                  }
                  else
                  {
                    v109 = 0;
                  }
                  if ( !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPlayerPed->m_pRwObject, v109) )
                  {
                    v101 = WeaponInfo->m_animGroup;
                    m_pRwObject = (RpClump_0 *)pPlayerPed->m_pRwObject;
                    if ( (WeaponInfo->m_nFlags & 0x2000) != 0 )
                    {
                      v103 = WeaponInfo->m_nFlags & 0x1000;
                      if ( v103 )
                        v103 = 227;
                    }
                    else
                    {
                      v103 = 0;
                    }
                    goto LABEL_229;
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v100 = WeaponInfo->m_nFlags & 0x1000;
        if ( v100 )
          v100 = 226;
        if ( !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPlayerPed->m_pRwObject, v100) )
        {
          v101 = WeaponInfo->m_animGroup;
          m_pRwObject = (RpClump_0 *)pPlayerPed->m_pRwObject;
          v103 = *(_QWORD *)&WeaponInfo->m_nFlags & 0x1000;
          if ( (*(_QWORD *)&WeaponInfo->m_nFlags & 0x1000) != 0 )
            v103 = 226;
LABEL_229:
          CAnimManager::BlendAnimation(m_pRwObject, v101, (AnimationId)v103, 4.0);
        }
      }
    }
LABEL_160:
    if ( !pPlayerPed->m_pEntLockOnTarget && CHID::IsPressed(HID_MAPPING_ENTER_AND_EXIT_TARGETING, 0) )
      CPlayerPed::HandleMeleeTargeting(pPlayerPed);
    v70 = v160;
    if ( pPlayerPed->m_pFire && (v160 == WEAPONTYPE_COUNTRYRIFLE || (WeaponInfo->m_nFlags & 4) != 0)
      || pPlayerPed->m_pPlayerData->m_nChosenWeapon != pPlayerPed->m_nCurrentWeapon )
    {
      goto LABEL_177;
    }
    m_eMoveState = pPlayerPed->m_eMoveState;
    v72 = m_eMoveState == PEDMOVE_SPRINT;
    if ( m_eMoveState != PEDMOVE_SPRINT )
      v72 = WeaponInfo->m_eFireType == FIRETYPE_PROJECTILE;
    if ( v72
      || (unsigned int)(v160 - 40) <= 5 && ((1 << (v160 - 40)) & 0x31) != 0
      || CCamera::Using1stPersonWeaponMode(&TheCamera)
      || !CCamera::IsTargetingActive(&TheCamera, pPlayerPed)
      && (v160 != WEAPONTYPE_KNIFE && WeaponInfo->m_eFireType == FIRETYPE_MELEE
       || !CPad::GetEnterTargeting(PadFromPlayer)) )
    {
LABEL_177:
      if ( pPlayerPed->m_pPlayerData->m_nChosenWeapon != pPlayerPed->m_nCurrentWeapon
        || pPlayerPed->m_eMoveState == PEDMOVE_SPRINT
        || !CCamera::Using1stPersonWeaponMode(&TheCamera) )
      {
        goto LABEL_182;
      }
      IsTargetingActive = CCamera::IsTargetingActive(&TheCamera);
      v74 = !IsTargetingActive;
      if ( !IsTargetingActive )
        v74 = pPlayerPed->m_pAttachToEntity == 0;
      if ( v74 )
      {
LABEL_182:
        if ( pPlayerPed->m_pEntLockOnTarget || (*((_BYTE *)pPlayerPed->m_pPlayerData + 52) & 8) != 0 )
        {
          v78 = &pPlayerPed->m_pPedIntelligence;
          v79 = PadFromPlayer;
          if ( CPedIntelligence::GetTaskFighting(pPlayerPed->m_pPedIntelligence) )
          {
            y = pPlayerPed->m_pPlayerData->m_vecFightMovement.y;
            TaskFighting = CPedIntelligence::GetTaskFighting(pPlayerPed->m_pPedIntelligence);
            if ( y < -0.5 )
              v82 = 16;
            else
              v82 = 15;
            CTaskSimpleFight::ControlFight(TaskFighting, 0, v82);
          }
        }
        else
        {
          v78 = &pPlayerPed->m_pPedIntelligence;
          v79 = PadFromPlayer;
        }
        if ( CPedIntelligence::GetTaskUseGun(*v78) )
        {
          if ( CPad::GetWeapon(v79, pPlayerPed, 0)
            || CPad::GetPedWalkUpDown(v79) <= 50
            && CPad::GetPedWalkUpDown(v79) >= -50
            && CPad::GetPedWalkLeftRight(v79) <= 50
            && CPad::GetPedWalkLeftRight(v79) >= -50 )
          {
            TaskUseGun = CPedIntelligence::GetTaskUseGun(*v78);
            CTaskSimpleUseGun::PlayerPassiveControlGun(TaskUseGun);
          }
          else
          {
            v84 = CPedIntelligence::GetTaskUseGun(*v78);
            CTaskSimpleUseGun::ControlGun(v84, pPlayerPed, pPlayerPed->m_pEntLockOnTarget, 7);
          }
          if ( (WeaponInfo->m_nFlags & 2) == 0 && TheCamera.Cams[TheCamera.ActiveCam].Mode == 4 )
          {
            v85 = *(_QWORD *)&TheCamera.Cams[TheCamera.ActiveCam].Front.x;
            pPlayerPed->m_fDesiredHeading = atan2f(COERCE_FLOAT(v85 ^ 0x80000000), *((float *)&v85 + 1));
          }
          if ( pPlayerPed->m_pEntLockOnTarget || (*((_BYTE *)pPlayerPed->m_pPlayerData + 52) & 8) != 0 )
          {
            v86 = CPedIntelligence::GetTaskUseGun(*v78);
            CTaskSimpleUseGun::AbortIK(v86, pPlayerPed);
          }
        }
        if ( pPlayerPed->m_pEntLockOnTarget )
          CPlayerPed::ClearWeaponTarget(pPlayerPed);
        CPlayerPed::Clear3rdPersonMouseTarget(pPlayerPed);
        *((_WORD *)pPlayerPed->m_pPlayerData + 26) &= ~8u;
        goto LABEL_206;
      }
      v75 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
      v76 = pPlayerPed->m_pPedIntelligence;
      if ( !v75 )
      {
        v111 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
        *(_QWORD *)&v165.x = 0LL;
        v165.z = 0.0;
        CTaskSimpleUseGun::CTaskSimpleUseGun(v111, pPlayerPed->m_pEntLockOnTarget, v165, 1, 1, 0);
        CTaskManager::SetTaskSecondary(&v76->m_taskManager, v111, 0);
        goto LABEL_206;
      }
      if ( !CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence) )
      {
LABEL_206:
        *((_WORD *)pPlayerPed->m_pPlayerData + 26) = (4 * LOWORD(pPlayerPed->m_pEntLockOnTarget)) & 4 | *((_WORD *)pPlayerPed->m_pPlayerData + 26) & 0xFFFB;
        v87 = pPlayerPed->m_pEntLockOnTarget;
        if ( !v87 )
          goto LABEL_239;
        v88 = (*(_BYTE *)&v87->m_info & 7) == 3
           && ((BYTE2(v87[19].m_pRwObject) & 0x10) != 0 || v87[18].m_pMat == (CMatrix *)((char *)&dword_34 + 3));
        if ( WeaponInfo->m_eFireType
          || (v89 = CPedIntelligence::GetTaskFighting(pPlayerPed->m_pPedIntelligence), !v88) && v89 )
        {
          if ( (*((_BYTE *)&pPlayerPed->m_nPedFlags + 3) & 4) != 0 || (WeaponInfo->m_nFlags & 2) == 0 )
            goto LABEL_239;
        }
        v90 = pPlayerPed->m_pMat;
        v91 = v87->m_pMat;
        p_m_transform = (CSimpleTransform *)&v90->tx;
        if ( !v90 )
          p_m_transform = &pPlayerPed->m_transform;
        p_x = &v91->tx;
        if ( !v91 )
          p_x = &v87->m_transform.m_translate.x;
        v94 = *p_x - p_m_transform->m_translate.x;
        v95 = p_x[1] - p_m_transform->m_translate.y;
        v96 = p_x[2] - p_m_transform->m_translate.z;
        if ( v90 )
        {
          xy = v90->xy;
          yy = v90->yy;
          zy = v90->zy;
        }
        else
        {
          m_heading = pPlayerPed->m_transform.m_heading;
          v105 = sinf(m_heading);
          yy = cosf(m_heading);
          zy = 0.0;
          LODWORD(xy) = LODWORD(v105) ^ 0x80000000;
        }
        if ( (float)((float)(v96 * zy) + (float)((float)(v95 * yy) + (float)(v94 * xy))) <= 0.0 )
        {
LABEL_239:
          if ( this->m_lastLookAtEntity
            && IKChainManager_c::IsLooking(&g_ikChainMan, pPlayerPed)
            && IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPlayerPed) == this->m_lastLookAtEntity )
          {
            IKChainManager_c::AbortLookAt(&g_ikChainMan, pPlayerPed, 250);
          }
        }
        else if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPlayerPed)
               || IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPlayerPed) != v87 )
        {
          v106 = -1;
          if ( (*(_BYTE *)&v87->m_info & 7) == 3 )
            v106 = 5;
          IKChainManager_c::LookAt(
            &g_ikChainMan,
            "ProcPlyrWeapon",
            pPlayerPed,
            v87,
            (int32)&CWorld::m_aTempColPts[2].m_vecNormal.y + 3,
            v106,
            0,
            0,
            0.25,
            500,
            3,
            0);
        }
        this->m_lastLookAtEntity = v87;
        return;
      }
LABEL_180:
      v77 = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
      CTaskSimpleUseGun::ControlGun(v77, pPlayerPed, pPlayerPed->m_pEntLockOnTarget, 1);
      goto LABEL_206;
    }
    CheckForTargetToPutHandsUp(pPlayerPed, m_pMouseLockOnRecruitPed);
    if ( m_pMouseLockOnRecruitPed
      && CPlayerPed::DoesTargetHaveToBeBroken(
           pPlayerPed,
           m_pMouseLockOnRecruitPed,
           &pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon])
      || v159
      && CPlayerPed::DoesTargetHaveToBeBroken(
           pPlayerPed,
           m_pEntMagnetizeTarget,
           &pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon])
      || (*(_BYTE *)&pPlayerPed->m_nPedFlags & 0x40) == 0
      && (v112 = pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType,
          v113 = CPed::GetWeaponSkill(pPlayerPed),
          v114 = v112,
          v70 = v160,
          !(LOBYTE(CWeaponInfo::GetWeaponInfo(v114, v113)->m_nFlags) << 31)) )
    {
      CPlayerPed::ClearWeaponTarget(pPlayerPed);
      CPlayerPed::FindWeaponLockOnTarget(pPlayerPed);
    }
    if ( (unsigned int)(v70 - 33) <= 5 && ((1 << (v70 - 33)) & 0x31) != 0 )
    {
LABEL_272:
      v115 = *((_WORD *)pPlayerPed->m_pPlayerData + 26);
      v116 = WeaponInfo->m_nFlags & 1;
      if ( (v115 & 8) != 0 || !v116 )
      {
        if ( (v115 & 8) != 0
          && v116
          && CHID::GetInputType() != 2
          && (CPad::ShiftTargetLeftJustDown(PadFromPlayer) || CPad::ShiftTargetRightJustDown(PadFromPlayer)) )
        {
          v126 = pPlayerPed->m_pEntLockOnTarget;
          v127 = CPad::ShiftTargetLeftJustDown(PadFromPlayer);
          v125 = v127;
          if ( !v126 )
          {
            v124 = pPlayerPed;
            v123 = 0;
LABEL_298:
            CPlayerPed::FindNextWeaponLockOnTarget(v124, v123, v125);
            goto LABEL_345;
          }
          if ( v127 )
            CPlayerPed::FindNextWeaponLockOnTarget(pPlayerPed, pPlayerPed->m_pEntLockOnTarget, 1);
          v122 = PadFromPlayer;
LABEL_296:
          if ( !CPad::ShiftTargetRightJustDown(v122) )
            goto LABEL_345;
          v123 = pPlayerPed->m_pEntLockOnTarget;
          v124 = pPlayerPed;
          v125 = 0;
          goto LABEL_298;
        }
        if ( (WeaponInfo->m_nFlags & 8) != 0 && !pPlayerPed->m_pEntLockOnTarget )
        {
          v130 = pPlayerPed->m_pPlayerData;
          v131 = *((_WORD *)v130 + 26);
          if ( (v131 & 8) == 0 )
            goto LABEL_344;
        }
        if ( CHID::GetInputType() == 2 && (*((_BYTE *)pPlayerPed->m_pPlayerData + 52) & 8) != 0 )
        {
          m_eFireType = WeaponInfo->m_eFireType;
          if ( WeaponInfo->m_eFireType )
            LOBYTE(m_eFireType) = 1;
          CPlayerPed::Compute3rdPersonMouseTarget(pPlayerPed, m_eFireType);
        }
      }
      else
      {
        v117 = v159 == 0;
        if ( !v159 )
          v117 = m_pMouseLockOnRecruitPed == 0;
        if ( !v117 || (v70 | 4) == 37 )
        {
          if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(CPad::AimWeaponLeftRight(PadFromPlayer, pPlayerPed, 0)) & 0x7FFFFFFF) <= 100.0
            || CGameLogic::IsCoopGameGoingOn() == 1 )
          {
            v118 = v159 == 0;
            if ( !v159 )
              v118 = m_pMouseLockOnRecruitPed == 0;
            if ( v118 )
              goto LABEL_291;
            if ( m_pMouseLockOnRecruitPed )
            {
              if ( !CPlayerPed::PedCanBeTargettedVehicleWise(m_pMouseLockOnRecruitPed) )
                goto LABEL_291;
              v119 = CLocalisation::KickingWhenDown();
              v120 = v119 == 0;
              v121 = m_pMouseLockOnRecruitPed->m_nPedState & 0xFFFFFFFE;
              if ( !v119 )
                v120 = v121 == 54;
              if ( v120
                || v121 == 54 && CTimer::m_snTimeInMilliseconds - m_pMouseLockOnRecruitPed->m_nTimeOfDeath > 0x12C )
              {
LABEL_291:
                CPlayerPed::ClearWeaponTarget(pPlayerPed);
                CPlayerPed::FindWeaponLockOnTarget(pPlayerPed);
              }
            }
          }
          if ( !pPlayerPed->m_pEntLockOnTarget )
            goto LABEL_353;
          if ( CPad::ShiftTargetLeftJustDown(PadFromPlayer) )
            CPlayerPed::FindNextWeaponLockOnTarget(pPlayerPed, pPlayerPed->m_pEntLockOnTarget, 1);
          v122 = PadFromPlayer;
          goto LABEL_296;
        }
        if ( CPad::GetEnterTargeting(PadFromPlayer) == 1 || this->m_nLastFrameProcessed < CTimer::m_FrameCounter - 1 )
        {
          CPlayerPed::FindWeaponLockOnTarget(pPlayerPed);
          v130 = pPlayerPed->m_pPlayerData;
          v131 = *((_WORD *)v130 + 26);
LABEL_344:
          *((_WORD *)v130 + 26) = v131 | 8;
        }
      }
LABEL_345:
      if ( pPlayerPed->m_pEntLockOnTarget )
      {
        if ( WeaponInfo->m_eFireType || (*((_BYTE *)&pPlayerPed->m_nPedFlags + 3) & 4) != 0 )
          *((_WORD *)pPlayerPed->m_pPlayerData + 26) &= ~8u;
LABEL_349:
        CCamera::SetNewPlayerWeaponMode(&TheCamera, 53, 0, 0);
        v142 = pPlayerPed->m_pEntLockOnTarget;
        if ( v142 )
        {
          v143 = v142->m_pMat;
          v144 = (CEventDamage *)&v143->tx;
          if ( !v143 )
            v144 = (CEventDamage *)&v142->m_transform;
        }
        else
        {
          v145 = pPlayerPed->m_pMat;
          v146 = *(_QWORD *)&v145->xy;
          *(float *)&v162.m_bIsPersistent = v145->zy;
          *(_QWORD *)&v162._vptr$CEvent = v146;
          v147 = sinf(pPlayerPed->m_pPlayerData->m_fLookPitch);
          v148 = (CSimpleTransform *)&v145->tx;
          v144 = &v162;
          v149 = (float)(v147 + *(float *)&v162.m_bIsPersistent) * 5.0;
          *(float *)&v162.m_bIsPersistent = v149;
          if ( !v145 )
            v148 = &pPlayerPed->m_transform;
          v150 = v148->m_translate.y;
          v151 = v148->m_translate.z + v149;
          *(float *)&v162._vptr$CEvent = v148->m_translate.x + (float)(*(float *)&v162._vptr$CEvent * 5.0);
          *(float *)&v162.m_iAccumulatedTime = v150 + (float)(*(float *)&v162.m_iAccumulatedTime * 5.0);
          *(float *)&v162.m_bIsPersistent = v151;
        }
        CCamera::UpdateAimingCoors(&TheCamera, (const CVector *)v144);
        v152 = CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 0);
        v153 = pPlayerPed->m_pPedIntelligence;
        if ( !v152 )
        {
          v154 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
          *(_QWORD *)&v167.x = 0LL;
          v167.z = 0.0;
          CTaskSimpleUseGun::CTaskSimpleUseGun(v154, pPlayerPed->m_pEntLockOnTarget, v167, 1, 1, 0);
          CTaskManager::SetTaskSecondary(&v153->m_taskManager, v154, 0);
          goto LABEL_206;
        }
        if ( !CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence) )
          goto LABEL_206;
        goto LABEL_180;
      }
LABEL_353:
      if ( WeaponInfo->m_eFireType <= (unsigned int)FIRETYPE_USE && ((1 << WeaponInfo->m_eFireType) & 0x25) != 0 )
        goto LABEL_206;
      goto LABEL_349;
    }
    if ( MobileSettings::IsLockOnMode() )
    {
      v133 = v159 == 0;
      if ( !v159 )
        v133 = m_pMouseLockOnRecruitPed == 0;
      if ( !v133 )
        goto LABEL_272;
    }
    else
    {
      InputType = CHID::GetInputType();
      v141 = v159 == 0;
      if ( !v159 )
        v141 = m_pMouseLockOnRecruitPed == 0;
      if ( !v141 || InputType != 1 )
        goto LABEL_272;
    }
    CPlayerPed::FindWeaponLockOnTarget(pPlayerPed);
    goto LABEL_272;
  }
  if ( !CCamera::Using1stPersonWeaponMode(&TheCamera)
    && (CPad::GetEnterTargeting(PadFromPlayer)
     || CPad::GetTarget(PadFromPlayer, 0) && this->m_nLastFrameProcessed < CTimer::m_FrameCounter - 1) )
  {
    switch ( v10 )
    {
      case WEAPONTYPE_SNIPERRIFLE:
        v35 = 7;
        break;
      case WEAPONTYPE_ROCKETLAUNCHER:
        v35 = 8;
        break;
      case WEAPONTYPE_ROCKETLAUNCHER_HS:
        v42 = pPlayerPed->m_pPlayerData;
        v42->m_FireHSMissilePressedTime = CTimer::m_snTimeInMilliseconds;
        v42->m_LastHSMissileTarget = 0;
        v35 = 51;
        break;
      case WEAPONTYPE_CAMERA:
        v35 = 46;
        break;
      default:
        v35 = 34;
        break;
    }
    CCamera::SetNewPlayerWeaponMode(&TheCamera, v35, 0, 0);
    sub_18D8EC(pPlayerPed, PED_SNIPER_MODE);
  }
  else
  {
    if ( CCamera::Using1stPersonWeaponMode(&TheCamera) || CPad::WeaponUsesTargetingButton() != 1 )
      goto LABEL_34;
    if ( CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence) )
    {
      v28 = CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence);
      CTaskSimpleUseGun::PlayerPassiveControlGun(v28);
    }
    *((_WORD *)pPlayerPed->m_pPlayerData + 26) &= ~4u;
  }
}
// 537986: conditional instruction was optimized away because r10.4!=0
// 537C38: variable 'v33' is possibly undefined
// 34: using guessed type int dword_34;

//----- (00538CFC) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::PlayIdleAnimations(CTaskSimplePlayerOnFoot *this, CPlayerPed *pPlayerPed)
{
  CPad *PadFromPlayer; // r6
  bool v5; // zf
  CTaskSimpleHoldEntity *TaskHold; // r0
  bool v7; // zf
  uint32 LastTimeTouched; // r0
  uint32 v9; // r1
  int32 m_nPlayerIdlesAnimBlock; // r6
  int32 v11; // r8
  CAnimBlendAssociation *FirstAssociation; // r0
  CAnimBlock *v13; // r1
  int32 *p_m_numAnims; // r10
  int *p_m_animIndex; // r5
  int v16; // r1
  float v17; // s0
  int v18; // r4
  CAnimBlendAssociation *v19; // r0
  CAnimBlendAssociation *i; // r0

  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  v5 = CWorld::Players[0].pPed == 0;
  if ( CWorld::Players[0].pPed )
    v5 = CWorld::Players[1].pPed == 0;
  if ( v5 )
  {
    if ( TheCamera.m_WideScreenOn
      || *(_DWORD *)&pPlayerPed->m_nPedFlags & 0x4000000 | *((_DWORD *)&pPlayerPed->m_nPedFlags + 3) & 2 )
    {
      goto LABEL_10;
    }
    TaskHold = CPedIntelligence::GetTaskHold(pPlayerPed->m_pPedIntelligence, 0);
    v7 = TaskHold == 0;
    if ( !TaskHold )
      v7 = PadFromPlayer->DisablePlayerControls == 0;
    if ( !v7 || pPlayerPed->m_eMoveState > PEDMOVE_STILL || (unsigned int)(pPlayerPed->m_motionAnimGroup - 54) > 2 )
    {
LABEL_10:
      LastTimeTouched = CTimer::m_snTimeInMilliseconds;
      PadFromPlayer->LastTimeTouched = CTimer::m_snTimeInMilliseconds;
      v9 = LastTimeTouched;
    }
    else
    {
      LastTimeTouched = PadFromPlayer->LastTimeTouched;
      v9 = CTimer::m_snTimeInMilliseconds;
    }
    m_nPlayerIdlesAnimBlock = this->m_nPlayerIdlesAnimBlock;
    v11 = v9 - LastTimeTouched;
    if ( (int)(v9 - LastTimeTouched) < 10001 )
    {
      if ( CAnimManager::ms_aAnimBlocks[m_nPlayerIdlesAnimBlock].m_loaded )
      {
        CStreaming::SetModelIsDeletable(m_nPlayerIdlesAnimBlock + 25575);
        for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPlayerPed->m_pRwObject);
              i;
              i = RpAnimBlendGetNextAssociation(i) )
        {
          if ( (i->m_bitsFlag & 0x200) != 0 )
            i->m_fBlendDelta = -8.0;
        }
      }
      CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::timeLastIdlePlayed = 0;
    }
    else
    {
      CStreaming::RequestModel(m_nPlayerIdlesAnimBlock + 25575, 2);
      if ( CAnimManager::ms_aAnimBlocks[m_nPlayerIdlesAnimBlock].m_loaded )
      {
        FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPlayerPed->m_pRwObject);
        if ( FirstAssociation )
        {
          v13 = &CAnimManager::ms_aAnimBlocks[m_nPlayerIdlesAnimBlock];
          p_m_numAnims = &v13->m_numAnims;
          p_m_animIndex = &v13->m_animIndex;
          while ( 1 )
          {
            v16 = -1431655765
                * (((char *)FirstAssociation->m_pAnimBlendHierarchy - (char *)CAnimManager::ms_aAnimations) >> 3);
            if ( v16 >= *p_m_animIndex && v16 < *p_m_animIndex + *p_m_numAnims )
              break;
            FirstAssociation = RpAnimBlendGetNextAssociation(FirstAssociation);
            if ( !FirstAssociation )
              goto LABEL_18;
          }
        }
        else
        {
LABEL_18:
          if ( (*(_BYTE *)&pPlayerPed->m_nPedFlags & 0xC) == 0
            && v11 - CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::timeLastIdlePlayed >= 20001 )
          {
            do
            {
              v17 = (float)(unsigned __int16)rand();
              v18 = (int)(float)((float)(v17 * 0.000015259) * 4.0);
            }
            while ( CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::lastIdlePlayed == v18 );
            v19 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPlayerPed->m_pRwObject,
                    (AssocGroupId)CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::aIdleAnims[v18][1],
                    (AnimationId)CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::aIdleAnims[v18][0],
                    8.0);
            v19->m_bitsFlag |= 0x200u;
            CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::lastIdlePlayed = (int)(float)((float)(v17 * 0.000015259) * 4.0);
            CTaskSimplePlayerOnFoot::PlayIdleAnimations(CPlayerPed *)::timeLastIdlePlayed = v11;
            if ( CStats::GetStatValue(0x12Fu) != 0.0 && CTimer::m_snTimeInMilliseconds >= 0x124F81 )
              CPed::Say(pPlayerPed, 0x150u, 0, 0.2, 0, 0, 0);
          }
        }
      }
    }
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00538F60) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::PlayerControlFighter(CTaskSimplePlayerOnFoot *this, CPlayerPed *pPlayerPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d14
  CTaskSimpleFight *TaskFighting; // r9
  eFireType m_eFireType; // r11
  CPad *PadFromPlayer; // r10
  float PedWalkLeftRight; // s18
  float PedWalkUpDown; // s20
  float v13; // s26
  float v14; // s24
  float v15; // s16
  float v16; // s28
  float RadianAngleBetweenPoints; // r0
  float v18; // r4
  float v19; // r5
  float v20; // r4
  CMatrix *m_pMat; // r0
  float v22; // r0
  float v23; // r4
  float v24; // s16
  float v25; // r0
  CMatrix *v26; // r1
  float v27; // s0
  float v28; // s4
  float v29; // s22
  CPlayerPedData *v30; // r0
  CPlayerPedData **p_m_pPlayerData; // r4
  float v32; // s0
  float v33; // s4
  bool v34; // fzf
  bool v35; // fnf
  float v36; // s4
  float v37; // s4
  float x; // s0
  float v39; // s4
  CEntity *m_pEntLockOnTarget; // r0
  CMatrix *v41; // r1
  CMatrix *v42; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v45; // d16
  unsigned __int64 v46; // d1
  _BOOL4 Sprint; // r0
  float v48; // r0
  float v49; // s18
  _BOOL4 v50; // r0
  bool v51; // zf
  char v52; // r4
  float v53; // s2
  float v54; // s0
  CPlayerPedData *m_pPlayerData; // r0
  float y; // s4
  float v57; // s6
  float v58; // s2
  uint32 v59; // r0
  _BOOL4 Duck; // r0
  bool v61; // zf
  CTaskSimpleFight *v62; // r0
  int8 v63; // r2
  CPlayerPedData *v64; // r0
  float v65; // s2
  float v66; // s0
  CVector v67; // 0:r1.12

  TaskFighting = CPedIntelligence::GetTaskFighting(pPlayerPed->m_pPedIntelligence);
  if ( !TaskFighting )
    return;
  m_eFireType = CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_eFireType;
  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  PedWalkLeftRight = (float)CPad::GetPedWalkLeftRight(PadFromPlayer);
  PedWalkUpDown = (float)CPad::GetPedWalkUpDown(PadFromPlayer);
  v13 = PedWalkLeftRight * 0.0078125;
  v14 = CTimer::ms_fTimeStep;
  v15 = PedWalkUpDown * 0.0078125;
  if ( CGameLogic::IsPlayerUse2PlayerControls(pPlayerPed) )
  {
    v16 = sqrtf((float)(v13 * v13) + (float)(v15 * v15));
    if ( v16 > 0.0 )
    {
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   0.0,
                                   0.0,
                                   -(float)(PedWalkLeftRight * 0.0078125),
                                   PedWalkUpDown * 0.0078125);
      v18 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
      LODWORD(v19) = COERCE_UNSIGNED_INT(sinf(v18)) ^ 0x80000000;
      v20 = cosf(v18);
      *(_QWORD *)&v67.y = LODWORD(v20);
      v67.x = v19;
      if ( CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v67, 0.0) == 1 )
      {
        m_pMat = pPlayerPed->m_pMat;
        v15 = -(float)(v16
                     * (float)((float)((float)(m_pMat->xy * v19) + (float)(v20 * m_pMat->yy)) + (float)(m_pMat->zy * 0.0)));
        v13 = v16 * (float)((float)((float)(m_pMat->xx * v19) + (float)(v20 * m_pMat->yx)) + (float)(m_pMat->zx * 0.0));
      }
      else
      {
        v13 = 0.0;
        v15 = 0.0;
      }
    }
  }
  else if ( pPlayerPed->m_pEntLockOnTarget || CHID::GetInputType() == 2 && CPad::GetTarget(PadFromPlayer, 0) )
  {
    v5.n64_f32[0] = sqrtf((float)(v13 * v13) + (float)(v15 * v15));
    if ( v5.n64_f32[0] > 0.0 )
    {
      v22 = CGeneral::GetRadianAngleBetweenPoints(
              0.0,
              0.0,
              -(float)(PedWalkLeftRight * 0.0078125),
              PedWalkUpDown * 0.0078125);
      v23 = CGeneral::LimitRadianAngle(v22 - TheCamera.Orientation);
      v24 = sinf(v23);
      v25 = cosf(v23);
      v26 = pPlayerPed->m_pMat;
      v27 = (float)((float)(v25 * v26->yx) - (float)(v26->xx * v24)) + (float)(v26->zx * 0.0);
      v4.n64_u32[0] = 1.0;
      v28 = vmin_f32(v5, v4).n64_f32[0];
      v15 = -(float)(v28 * (float)((float)((float)(v25 * v26->yy) - (float)(v26->xy * v24)) + (float)(v26->zy * 0.0)));
      v13 = v28 * v27;
    }
  }
  v29 = v14 * 0.07;
  if ( !pPlayerPed->m_pEntLockOnTarget && (CHID::GetInputType() != 2 || !CPad::GetTarget(PadFromPlayer, 0)) )
  {
    v48 = CGeneral::GetRadianAngleBetweenPoints(
            0.0,
            0.0,
            COERCE_FLOAT(LODWORD(PedWalkLeftRight) ^ 0x80000000),
            PedWalkUpDown);
    v3.n64_u32[0] = 1.0;
    v2.n64_f32[0] = sqrtf((float)(v13 * v13) + (float)(v15 * v15));
    v49 = vmin_f32(v2, v3).n64_f32[0];
    if ( v49 == 0.0 )
    {
      pPlayerPed->m_pPlayerData->m_vecFightMovement.x = 0.0;
      pPlayerPed->m_pPlayerData->m_vecFightMovement.y = 0.0;
    }
    else if ( v15 <= 0.0 )
    {
      v53 = -v49;
      v54 = v48;
      m_pPlayerData = pPlayerPed->m_pPlayerData;
      y = m_pPlayerData->m_vecFightMovement.y;
      v57 = (float)-v49 - y;
      if ( fabsf(v57) > v29 )
      {
        v58 = -v29;
        if ( v57 > 0.0 )
          v58 = v14 * 0.07;
        v53 = y + v58;
      }
      m_pPlayerData->m_vecFightMovement.y = v53;
      pPlayerPed->m_pPlayerData->m_vecFightMovement.x = 0.0;
      pPlayerPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(v54 - TheCamera.Orientation);
    }
    if ( v15 > 0.0 || pPlayerPed->m_pEntLockOnTarget || TaskFighting->m_nLastCommand > 10 )
      v59 = 0;
    else
      v59 = this->m_nFightIdleMoveCount + (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    this->m_nFightIdleMoveCount = v59;
    if ( CPad::GetSprint(PadFromPlayer, 0) )
      goto LABEL_61;
    Duck = CPad::GetDuck(PadFromPlayer);
    if ( v15 > 0.0 )
      goto LABEL_61;
    v61 = m_eFireType == FIRETYPE_MELEE;
    if ( m_eFireType == FIRETYPE_MELEE )
      v61 = !Duck;
    if ( !v61 || this->m_nFightIdleMoveCount >> 4 > 0x7C )
    {
LABEL_61:
      CPad::GetSprint(PadFromPlayer, 0);
      v52 = 15;
      if ( v49 > 0.5 )
        v52 = 16;
      if ( CTaskSimpleDuck::CanPedDuck(pPlayerPed) && CPad::DuckJustDown(PadFromPlayer, pPlayerPed) )
      {
        CPedIntelligence::SetTaskDuckSecondary(pPlayerPed->m_pPedIntelligence, 0);
        v52 = 18;
      }
      goto LABEL_68;
    }
    p_m_pPlayerData = &pPlayerPed->m_pPlayerData;
    goto LABEL_72;
  }
  v30 = pPlayerPed->m_pPlayerData;
  p_m_pPlayerData = &pPlayerPed->m_pPlayerData;
  v32 = v30->m_vecFightMovement.y;
  v33 = fabsf(v15 - v32);
  v34 = v33 == v29;
  v35 = v33 < v29;
  v36 = v15;
  if ( !v35 && !v34 )
  {
    v37 = -v29;
    if ( (float)(v15 - v32) > 0.0 )
      v37 = v14 * 0.07;
    v36 = v32 + v37;
  }
  v30->m_vecFightMovement.y = v36;
  x = (*p_m_pPlayerData)->m_vecFightMovement.x;
  if ( fabsf(v13 - x) > v29 )
  {
    v39 = -v29;
    if ( (float)(v13 - x) > 0.0 )
      v39 = v14 * 0.07;
    v13 = x + v39;
  }
  (*p_m_pPlayerData)->m_vecFightMovement.x = v13;
  m_pEntLockOnTarget = pPlayerPed->m_pEntLockOnTarget;
  if ( m_pEntLockOnTarget )
  {
    v41 = pPlayerPed->m_pMat;
    v42 = m_pEntLockOnTarget->m_pMat;
    p_tx = (CSimpleTransform *)&v41->tx;
    if ( !v41 )
      p_tx = &pPlayerPed->m_transform;
    p_m_transform = (CSimpleTransform *)&v42->tx;
    if ( !v42 )
      p_m_transform = &m_pEntLockOnTarget->m_transform;
    v45.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v46 = vmul_f32(v45, v45).n64_u64[0];
    if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                               * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                       + *(float *)&v46)
               + *((float *)&v46 + 1)) <= 16.0
      || TaskFighting->m_nLastCommand >= 11 )
    {
      Sprint = CPad::GetSprint(PadFromPlayer, 0);
      if ( m_eFireType == FIRETYPE_MELEE && !Sprint )
        goto LABEL_72;
    }
  }
  else
  {
    v50 = CPad::GetSprint(PadFromPlayer, 0);
    v51 = m_eFireType == FIRETYPE_MELEE;
    if ( m_eFireType == FIRETYPE_MELEE )
      v51 = !v50;
    if ( v51 )
      goto LABEL_72;
  }
  if ( CPad::GetSprint(PadFromPlayer, 0) )
  {
    v52 = 17;
LABEL_68:
    v62 = TaskFighting;
    v63 = v52;
LABEL_69:
    CTaskSimpleFight::ControlFight(v62, 0, v63);
    return;
  }
  if ( v15 < -0.5 )
  {
    v52 = 16;
    goto LABEL_68;
  }
  if ( !CPad::GetBlock(PadFromPlayer) )
  {
    v52 = 15;
    goto LABEL_68;
  }
LABEL_72:
  v64 = *p_m_pPlayerData;
  v65 = (*p_m_pPlayerData)->m_vecFightMovement.y;
  if ( v65 == 0.0 )
  {
    v66 = v64->m_vecFightMovement.x;
  }
  else
  {
    v66 = v64->m_vecFightMovement.x;
    if ( fabsf(v65) > fabsf(v66) )
    {
      v62 = TaskFighting;
      if ( v65 < 0.0 )
        v63 = 3;
      else
        v63 = 5;
      goto LABEL_69;
    }
  }
  if ( v66 != 0.0 )
  {
    v62 = TaskFighting;
    if ( v66 <= 0.0 )
      v63 = 4;
    else
      v63 = 6;
    goto LABEL_69;
  }
}
// 539166: variable 'v5' is possibly undefined
// 539166: variable 'v4' is possibly undefined
// 5392C0: variable 'v2' is possibly undefined
// 5392C0: variable 'v3' is possibly undefined

//----- (005394E4) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::PlayerControlZeldaWeapon(
        CTaskSimplePlayerOnFoot *this,
        CPlayerPed *pPlayerPed)
{
  CTaskSimpleUseGun *TaskUseGun; // r5
  CPad *PadFromPlayer; // r8
  float PedWalkLeftRight; // s18
  float PedWalkUpDown; // s0
  float v7; // s16
  float v8; // s20
  float RadianAngleBetweenPoints; // r0
  float v10; // r6
  float v11; // r9
  CEntity **p_m_pEntLockOnTarget; // r9
  float y; // s18
  float x; // s22
  int IsPlayerAllowedToGoInThisDirection; // r0
  CMatrix *m_pMat; // r1
  float v17; // s2
  float v18; // s0
  CEntity *v19; // r0
  CMatrix *v20; // r1
  CMatrix *v21; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float v24; // s0
  float v25; // s0
  CVector2D pMoveVec; // [sp+8h] [bp-40h] BYREF
  CVector v27; // 0:r1.12

  TaskUseGun = CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence);
  if ( !TaskUseGun || pPlayerPed->m_pAttachToEntity )
    return;
  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  pMoveVec.x = 0.0;
  pMoveVec.y = 0.0;
  if ( (TaskUseGun->m_pWeaponInfo->m_nFlags & 4) != 0 && !CGameLogic::IsPlayerUse2PlayerControls(pPlayerPed) )
  {
    PedWalkLeftRight = 0.0;
    PedWalkUpDown = 0.0;
    v7 = 0.0;
    if ( !CCamera::Using1stPersonWeaponMode(&TheCamera) )
      goto LABEL_7;
  }
  else
  {
    PedWalkLeftRight = (float)CPad::GetPedWalkLeftRight(PadFromPlayer);
    PedWalkUpDown = (float)CPad::GetPedWalkUpDown(PadFromPlayer);
  }
  pMoveVec.y = PedWalkUpDown;
  pMoveVec.x = PedWalkLeftRight;
  v7 = PedWalkLeftRight * 0.0078125;
  PedWalkLeftRight = PedWalkUpDown * 0.0078125;
LABEL_7:
  pMoveVec.y = PedWalkLeftRight;
  pMoveVec.x = v7;
  if ( CGameLogic::IsPlayerUse2PlayerControls(pPlayerPed) )
  {
    v8 = sqrtf((float)(v7 * v7) + (float)(PedWalkLeftRight * PedWalkLeftRight));
    if ( v8 <= 0.0 )
    {
      p_m_pEntLockOnTarget = &pPlayerPed->m_pEntLockOnTarget;
    }
    else
    {
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   0.0,
                                   0.0,
                                   COERCE_FLOAT(LODWORD(v7) ^ 0x80000000),
                                   PedWalkLeftRight);
      v10 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
      v11 = sinf(v10);
      v27.y = cosf(v10);
      LODWORD(v27.x) = LODWORD(v11) ^ 0x80000000;
      p_m_pEntLockOnTarget = &pPlayerPed->m_pEntLockOnTarget;
      if ( pPlayerPed->m_pEntLockOnTarget )
      {
        v27.z = 0.0;
        y = v27.y;
        x = v27.x;
        IsPlayerAllowedToGoInThisDirection = CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v27, 0.0);
        m_pMat = pPlayerPed->m_pMat;
        v17 = 0.0;
        if ( IsPlayerAllowedToGoInThisDirection )
          v17 = v8;
        v7 = v17 * (float)((float)((float)(m_pMat->xx * x) + (float)(y * m_pMat->yx)) + (float)(m_pMat->zx * 0.0));
        pMoveVec.x = v7;
        v18 = v17 * (float)((float)((float)(m_pMat->xy * x) + (float)(y * m_pMat->yy)) + (float)(m_pMat->zy * 0.0));
      }
      else
      {
        v27.z = 0.0;
        pPlayerPed->m_fDesiredHeading = v10;
        v7 = 0.0;
        v18 = 0.0;
        if ( CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v27, 0.0) )
          v18 = v8;
        pMoveVec.x = 0.0;
      }
      PedWalkLeftRight = -v18;
      pMoveVec.y = -v18;
    }
    v19 = *p_m_pEntLockOnTarget;
    if ( *p_m_pEntLockOnTarget )
    {
      v20 = pPlayerPed->m_pMat;
      v21 = v19->m_pMat;
      p_tx = (CSimpleTransform *)&v20->tx;
      if ( !v20 )
        p_tx = &pPlayerPed->m_transform;
      p_x = &v21->tx;
      if ( !v21 )
        p_x = &v19->m_transform.m_translate.x;
      pPlayerPed->m_fDesiredHeading = atan2f(-(float)(*p_x - p_tx->m_translate.x), p_x[1] - p_tx->m_translate.y);
    }
  }
  v24 = sqrtf((float)(v7 * v7) + (float)(PedWalkLeftRight * PedWalkLeftRight));
  if ( v24 > 1.0 )
  {
    v25 = 1.0 / v24;
    pMoveVec.y = v25 * PedWalkLeftRight;
    pMoveVec.x = v7 * v25;
  }
  CTaskSimpleUseGun::ControlGunMove(TaskUseGun, &pMoveVec);
  if ( CTaskSimpleDuck::CanPedDuck(pPlayerPed) && CPad::DuckJustDown(PadFromPlayer, pPlayerPed) )
    CPedIntelligence::SetTaskDuckSecondary(pPlayerPed->m_pPedIntelligence, 0);
}

//----- (00539770) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::PlayerControlDucked(CTaskSimplePlayerOnFoot *this, CPlayerPed *pPlayerPed)
{
  CTaskSimpleDuck *TaskSecondary; // r5
  CPad *PadFromPlayer; // r6
  float v5; // s20
  float v6; // s18
  float v7; // s16
  bool v8; // zf
  float v9; // r0
  float v10; // r6
  float v11; // r8
  float v12; // r0
  float v13; // s0
  CAnimBlendAssociation *v14; // r0
  CTaskSimpleUseGun *TaskUseGun; // r0
  _BOOL4 Sprint; // r0
  CAnimBlendAssociation *v17; // r0
  CAnimBlendAssociation *v18; // r0
  float RadianAngleBetweenPoints; // r0
  float v20; // r8
  float v21; // r6
  float v22; // r9
  int IsPlayerAllowedToGoInThisDirection; // r0
  CMatrix *m_pMat; // r1
  float v25; // s20
  CEntity *m_pEntLockOnTarget; // r0
  float v27; // s16
  float v28; // s22
  CMatrix *v29; // r3
  CSimpleTransform *p_tx; // r2
  float *p_x; // r1
  float v32; // s0
  CVector2D v33; // r1
  CVector2D v34; // r1
  CVector vecVehicle; // [sp+4h] [bp-44h] BYREF
  CVector v36; // 0:r1.12
  CVector v37; // 0:r1.12

  TaskSecondary = (CTaskSimpleDuck *)CTaskManager::GetTaskSecondary(&pPlayerPed->m_pPedIntelligence->m_taskManager, 1);
  if ( TaskSecondary )
  {
    PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
    v5 = (float)CPad::GetPedWalkLeftRight(PadFromPlayer) * 0.0078125;
    v6 = (float)CPad::GetPedWalkUpDown(PadFromPlayer) * 0.0078125;
    if ( pPlayerPed->m_pAttachToEntity )
    {
      v7 = 0.0;
    }
    else
    {
      v7 = sqrtf((float)(v5 * v5) + (float)(v6 * v6));
      if ( v7 > 1.0 )
        v7 = 1.0;
    }
    v8 = !TaskSecondary->m_bIsFinished;
    if ( !TaskSecondary->m_bIsFinished )
      v8 = !TaskSecondary->m_bIsAborting;
    if ( v8 )
    {
      if ( CPad::DuckJustDown(PadFromPlayer, pPlayerPed)
        || CPad::JumpJustDown(PadFromPlayer)
        || (memset(&vecVehicle, 0, sizeof(vecVehicle)),
            CPad::ExitVehicleJustDown(PadFromPlayer, 0, 0, 1, &vecVehicle) == 1)
        || !CTaskSimpleDuck::CanPedDuck(pPlayerPed) )
      {
        CPedIntelligence::ClearTaskDuckSecondary(pPlayerPed->m_pPedIntelligence);
        if ( !CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence)
          || (CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence)->m_pWeaponInfo->m_nFlags & 2) != 0 )
        {
          Sprint = CPad::GetSprint(PadFromPlayer, 0);
          if ( v7 > 0.5 && Sprint )
          {
            v17 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPlayerPed->m_pRwObject,
                    pPlayerPed->m_motionAnimGroup,
                    ANIM_STD_RUN,
                    4.0);
            v17->m_bitsFlag |= 1u;
            pPlayerPed->m_pPlayerData->m_moveBlendRatio = 1.5;
            pPlayerPed->m_eMoveStateAnim = PEDMOVE_RUN;
            CPed::SetMoveState(pPlayerPed, PEDMOVE_RUN);
          }
          else if ( v7 > 0.5 )
          {
            v18 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPlayerPed->m_pRwObject,
                    pPlayerPed->m_motionAnimGroup,
                    ANIM_STD_WALK,
                    4.0);
            v18->m_bitsFlag |= 1u;
            pPlayerPed->m_pPlayerData->m_moveBlendRatio = 1.5;
            pPlayerPed->m_eMoveStateAnim = PEDMOVE_WALK;
            CPed::SetMoveState(pPlayerPed, PEDMOVE_WALK);
          }
        }
        else if ( v7 > 0.5 )
        {
          v14 = CAnimManager::BlendAnimation(
                  (RpClump_0 *)pPlayerPed->m_pRwObject,
                  ANIM_STD_PED,
                  ANIM_STD_WEAPON_FWD,
                  4.0);
          v14->m_bitsFlag |= 1u;
          pPlayerPed->m_pPlayerData->m_moveBlendRatio = 1.0;
          vecVehicle.x = 1.0;
          vecVehicle.y = 0.0;
          TaskUseGun = CPedIntelligence::GetTaskUseGun(pPlayerPed->m_pPedIntelligence);
          CTaskSimpleUseGun::ControlGunMove(TaskUseGun, (CVector2D *)&vecVehicle);
        }
      }
      else if ( (pPlayerPed->m_pEntLockOnTarget
              || CPad::GetTarget(PadFromPlayer, 0)
              || (*((_BYTE *)pPlayerPed->m_pPlayerData + 52) & 8) != 0
              || CPad::GetSprint(PadFromPlayer, 0))
             && !CWeapon::IsTypeMelee(&pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon]) )
      {
        if ( CGameLogic::IsPlayerUse2PlayerControls(pPlayerPed) )
        {
          RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                       0.0,
                                       0.0,
                                       COERCE_FLOAT(LODWORD(v5) ^ 0x80000000),
                                       v6);
          v20 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
          v21 = sinf(v20);
          v22 = cosf(v20);
          LODWORD(v37.x) = LODWORD(v21) ^ 0x80000000;
          *(_QWORD *)&v37.y = LODWORD(v22);
          IsPlayerAllowedToGoInThisDirection = CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v37, 0.0);
          m_pMat = pPlayerPed->m_pMat;
          v25 = 0.0;
          if ( IsPlayerAllowedToGoInThisDirection )
            v25 = v7;
          m_pEntLockOnTarget = pPlayerPed->m_pEntLockOnTarget;
          v27 = (float)((float)(v22 * m_pMat->yy) - (float)(m_pMat->xy * v21)) + (float)(m_pMat->zy * 0.0);
          v28 = (float)((float)(v22 * m_pMat->yx) - (float)(m_pMat->xx * v21)) + (float)(m_pMat->zx * 0.0);
          if ( m_pEntLockOnTarget )
          {
            v29 = m_pEntLockOnTarget->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &pPlayerPed->m_transform;
            p_x = &v29->tx;
            if ( !v29 )
              p_x = &m_pEntLockOnTarget->m_transform.m_translate.x;
            v32 = atan2f(-(float)(*p_x - p_tx->m_translate.x), p_x[1] - p_tx->m_translate.y);
          }
          else
          {
            v32 = v20;
          }
          v6 = -(float)(v25 * v27);
          v5 = v25 * v28;
          pPlayerPed->m_fDesiredHeading = v32;
        }
        v34.x = v5;
        v34.y = v6;
        CTaskSimpleDuck::ControlDuckMove(TaskSecondary, v34);
        pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
      }
      else
      {
        if ( v7 <= 0.0 )
        {
          v13 = v7;
        }
        else
        {
          v9 = CGeneral::GetRadianAngleBetweenPoints(0.0, 0.0, COERCE_FLOAT(LODWORD(v5) ^ 0x80000000), v6);
          v10 = CGeneral::LimitRadianAngle(v9 - TheCamera.Orientation);
          pPlayerPed->m_fDesiredHeading = v10;
          v11 = sinf(v10);
          v12 = cosf(v10);
          LODWORD(v36.x) = LODWORD(v11) ^ 0x80000000;
          *(_QWORD *)&v36.y = LODWORD(v12);
          v13 = 0.0;
          if ( CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v36, 0.0) )
            v13 = v7;
        }
        pPlayerPed->m_pPlayerData->m_moveBlendRatio = v13;
        v33.x = 0.0;
        LODWORD(v33.y) = LODWORD(v13) ^ 0x80000000;
        CTaskSimpleDuck::ControlDuckMove(TaskSecondary, v33);
      }
    }
  }
}

//----- (00539B44) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::PlayerControlZelda(
        CTaskSimplePlayerOnFoot *this,
        CPlayerPed *pPlayerPed,
        const bool bMoveOnly)
{
  CPlayerPedData *m_pPlayerData; // r0
  _BOOL4 v6; // r9
  CPad *PadFromPlayer; // r10
  float PedWalkUpDown; // s0
  float PedWalkLeftRight; // s20
  float v10; // s18
  float v11; // s2
  float RadianAngleBetweenPoints; // r0
  float v13; // r5
  float v14; // r6
  float v15; // r0
  CPlayerPedData *v16; // r0
  float m_moveBlendRatio; // s0
  float v18; // s2
  CPhysical *m_pGroundPhysical; // r0
  AssocGroupId m_motionAnimGroup; // r5
  CAnimBlendAssocGroup *v21; // r6
  CPlayerPed *v22; // r0
  eMoveState v23; // r1
  _BOOL4 Target; // r0
  bool v25; // zf
  CTask *TaskByType; // r0
  int v27; // r5
  float *p_m_fEdgeHeading; // r5
  CEntity *v29; // r0
  CMatrix *m_pMat; // r0
  float m_heading; // s0
  CPedIntelligence *v32; // r6
  CTaskComplexJump *v33; // r5
  CAnimBlendAssocGroup *v34; // r5
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r6
  CTask *ActiveTask; // r0
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplexJump *v38; // r5
  CVector v39; // 0:r1.12

  m_pPlayerData = pPlayerPed->m_pPlayerData;
  v6 = bMoveOnly;
  m_pPlayerData->m_vecFightMovement.x = 0.0;
  m_pPlayerData->m_vecFightMovement.y = 0.0;
  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  if ( pPlayerPed->m_pAttachToEntity )
  {
    PedWalkUpDown = 0.0;
    PedWalkLeftRight = 0.0;
    v10 = 0.0;
  }
  else
  {
    PedWalkLeftRight = (float)CPad::GetPedWalkLeftRight(PadFromPlayer);
    PedWalkUpDown = (float)CPad::GetPedWalkUpDown(PadFromPlayer);
    v10 = sqrtf((float)(PedWalkLeftRight * PedWalkLeftRight) + (float)(PedWalkUpDown * PedWalkUpDown)) / 60.0;
  }
  v11 = v10;
  if ( PadFromPlayer->NewState.m_bPedWalk )
    v11 = 1.0;
  if ( v10 > 1.0 )
    v10 = v11;
  if ( v10 <= 0.0 )
  {
    pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
  }
  else
  {
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 0.0,
                                 0.0,
                                 COERCE_FLOAT(LODWORD(PedWalkLeftRight) ^ 0x80000000),
                                 PedWalkUpDown);
    v13 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
    pPlayerPed->m_fDesiredHeading = v13;
    v14 = sinf(v13);
    v15 = cosf(v13);
    LODWORD(v39.x) = LODWORD(v14) ^ 0x80000000;
    *(_QWORD *)&v39.y = LODWORD(v15);
    if ( CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v39, 0.0) == 1 )
    {
      v16 = pPlayerPed->m_pPlayerData;
      m_moveBlendRatio = v16->m_moveBlendRatio;
      v18 = CTimer::ms_fTimeStep * 0.07;
      if ( (float)(v10 - m_moveBlendRatio) <= (float)(CTimer::ms_fTimeStep * 0.07) )
      {
        if ( (float)(v10 - m_moveBlendRatio) >= (float)-v18 )
          v16->m_moveBlendRatio = v10;
        else
          v16->m_moveBlendRatio = m_moveBlendRatio - v18;
      }
      else
      {
        v16->m_moveBlendRatio = v18 + m_moveBlendRatio;
      }
    }
    else
    {
      pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
    }
  }
  if ( (CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_nFlags & 0x200) == 0 )
  {
    m_pGroundPhysical = pPlayerPed->m_pGroundPhysical;
    if ( (!m_pGroundPhysical || (*(_DWORD *)&m_pGroundPhysical->m_nPhysicalFlags & 0xC) != 4)
      && (!CPedIntelligence::GetTaskHold(pPlayerPed->m_pPedIntelligence, 0)
       || !CPedIntelligence::GetTaskHold(pPlayerPed->m_pPedIntelligence, 0)->m_pAnim) )
    {
      if ( !pPlayerPed->m_pPlayerData->m_bPlayerSprintDisabled )
      {
        m_motionAnimGroup = pPlayerPed->m_motionAnimGroup;
        v21 = CAnimManager::ms_aAnimAssocGroups;
        if ( !SurfaceInfos_c::CantSprintOn(&g_surfaceInfos, pPlayerPed->m_LastMaterialToHaveBeenStandingOn) )
        {
          v34 = &v21[m_motionAnimGroup];
          m_pAnimBlendHierarchy = CAnimBlendAssocGroup::GetAnimation(v34, 1u)->m_pAnimBlendHierarchy;
          if ( m_pAnimBlendHierarchy != CAnimBlendAssocGroup::GetAnimation(v34, 2u)->m_pAnimBlendHierarchy )
          {
            if ( CPlayerPed::ControlButtonSprint(pPlayerPed, SPRINT_ON_FOOT) < 1.0 )
              goto LABEL_27;
            v22 = pPlayerPed;
            v23 = PEDMOVE_SPRINT;
            goto LABEL_26;
          }
        }
      }
      if ( CPad::GetSprint(PadFromPlayer, 0) )
      {
        v22 = pPlayerPed;
        v23 = PEDMOVE_RUN;
LABEL_26:
        CPed::SetMoveState(v22, v23);
      }
    }
  }
LABEL_27:
  CPlayerPed::SetRealMoveAnim(pPlayerPed);
  RpAnimBlendClumpGetAssociation((RpClump_0 *)pPlayerPed->m_pRwObject, 0xBu);
  RpAnimBlendClumpGetAssociation((RpClump_0 *)pPlayerPed->m_pRwObject, 0xCu);
  if ( CTaskSimpleDuck::CanPedDuck(pPlayerPed) && !v6 && CPad::DuckJustDown(PadFromPlayer, pPlayerPed) )
    CPedIntelligence::SetTaskDuckSecondary(pPlayerPed->m_pPedIntelligence, 0);
  if ( !v6
    && (*((_BYTE *)&pPlayerPed->m_nPedFlags + 1) & 2) == 0
    && (CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_nFlags & 0x200) == 0
    && CPad::JumpJustDown(PadFromPlayer) )
  {
    Target = CPad::GetTarget(PadFromPlayer, 0);
    v25 = !Target;
    if ( !Target )
      v25 = pPlayerPed->m_pAttachToEntity == 0;
    if ( v25 )
    {
      switch ( TheCamera.Cams[TheCamera.ActiveCam].Mode )
      {
        case 7:
        case 8:
        case 0x22:
        case 0x2D:
        case 0x2E:
        case 0x33:
          break;
        default:
          CPlayerPed::ClearWeaponTarget(pPlayerPed);
          if ( CTaskManager::GetActiveTask(&pPlayerPed->m_pPedIntelligence->m_taskManager) )
          {
            ActiveTask = CTaskManager::GetActiveTask(&pPlayerPed->m_pPedIntelligence->m_taskManager);
            if ( (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) != 211 )
            {
              m_pPedIntelligence = pPlayerPed->m_pPedIntelligence;
              v38 = (CTaskComplexJump *)CTask::operator new(0x14u);
              CTaskComplexJump::CTaskComplexJump(v38, 0);
              CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v38, 3, 0);
            }
          }
          break;
      }
    }
  }
  TaskByType = CTaskManager::FindTaskByType(&pPlayerPed->m_pPedIntelligence->m_taskManager, 3, 1600);
  v27 = 0;
  if ( TaskByType && (*((int (__fastcall **)(CTask *))TaskByType->_vptr$CTask + 5))(TaskByType) == 1600 )
    v27 = 1;
  if ( CGame::currArea == AREA_MAIN_MAP && !(!CPad::GetSprint(PadFromPlayer, 0) | v27) )
  {
    if ( MobileSettings::settings[35].value )
    {
      p_m_fEdgeHeading = &this->m_fEdgeHeading;
      v29 = CTaskSimpleClimb::TestForClimb(
              pPlayerPed,
              &this->m_vecEdge,
              &this->m_fEdgeHeading,
              &this->m_nEdgeSurfaceType,
              1);
      this->m_pClimbEnt = v29;
      if ( v29 )
      {
        m_pMat = pPlayerPed->m_pMat;
        if ( m_pMat )
          m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
        else
          m_heading = pPlayerPed->m_transform.m_heading;
        if ( m_heading > (float)(*p_m_fEdgeHeading + -0.75) && m_heading < (float)(*p_m_fEdgeHeading + 0.75) )
        {
          v32 = pPlayerPed->m_pPedIntelligence;
          v33 = (CTaskComplexJump *)CTask::operator new(0x14u);
          CTaskComplexJump::CTaskComplexJump(v33, 0);
          CTaskManager::SetTask(&v32->m_taskManager, v33, 3, 0);
        }
      }
    }
  }
  CTaskSimplePlayerOnFoot::PlayIdleAnimations(this, pPlayerPed);
  pPlayerPed->m_ik.m_flags |= 8u;
}

//----- (00539F9C) --------------------------------------------------------
bool __fastcall CTaskSimplePlayerOnFoot::ProcessPed(CTaskSimplePlayerOnFoot *this, CPed *pPed)
{
  int v4; // r6
  eMoveState m_eMoveState; // r4
  int m_nCurrentMove; // r0
  int v7; // r2
  int v8; // r1
  CTaskSimplePlayerOnFoot *v9; // r0

  if ( CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed) )
  {
    v4 = 0;
    m_eMoveState = pPed->m_eMoveState;
    if ( m_eMoveState > PEDMOVE_TURN_R )
      v4 = 1;
    if ( pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_CHAINSAW
      && CPedIntelligence::GetTaskFighting(pPed->m_pPedIntelligence) )
    {
      m_nCurrentMove = (unsigned __int8)CPedIntelligence::GetTaskFighting(pPed->m_pPedIntelligence)->m_nCurrentMove;
      v7 = 0;
      v8 = 0;
      if ( m_eMoveState > PEDMOVE_TURN_R )
        v7 = 1;
      if ( m_nCurrentMove == 4 )
        v8 = 1;
      v4 = v7 | v8;
    }
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    if ( (*((_BYTE *)&pPed->m_nPedFlags + 3) & 4) != 0 )
    {
      CTaskSimplePlayerOnFoot::PlayerControlDucked(
        (CTaskSimplePlayerOnFoot *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 3) << 29),
        (CPlayerPed *)pPed);
    }
    else if ( v4 | (CPedIntelligence::GetTaskFighting(pPed->m_pPedIntelligence) == 0) )
    {
      if ( CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence)
        && CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence)->m_pWeaponInfo
        && (v9 = (CTaskSimplePlayerOnFoot *)(LOBYTE(CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence)->m_pWeaponInfo->m_nFlags) << 30),
            (int)v9 >= 0) )
      {
        CTaskSimplePlayerOnFoot::PlayerControlZeldaWeapon(v9, (CPlayerPed *)pPed);
      }
      else
      {
        CTaskSimplePlayerOnFoot::PlayerControlZelda(this, (CPlayerPed *)pPed, 0);
      }
    }
    else
    {
      CTaskSimplePlayerOnFoot::PlayerControlFighter(this, (CPlayerPed *)pPed);
    }
    CTaskSimplePlayerOnFoot::ProcessPlayerWeapon(this, (CPlayerPed *)pPed);
  }
  this->m_nLastFrameProcessed = CTimer::m_FrameCounter;
  return 0;
}

//----- (0053A090) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::CTaskSimpleSwim(CTaskSimpleSwim *this, const CVector *pTargetPos, CPed *pTargetPed)
{
  __int64 v6; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_fStopTimer = 0.0;
  this->m_nSwimTimer = 0;
  *(_QWORD *)&this->m_fControlSpeed = 3212836864LL;
  *(_QWORD *)&this->m_vecTargetPos.y = 0LL;
  *(_QWORD *)&this->m_fRollTorso = 0LL;
  *(_QWORD *)&this->m_nLastParticleTime = 0LL;
  *(_QWORD *)&this->m_fDiveAngle = 0LL;
  *(_QWORD *)&this->m_fPitchTorso = 0LL;
  *(_DWORD *)&this->m_bAddedIdleAnim = 0;
  this->m_nSwimAnim = ANIM_STD_NUM;
  this->_vptr$CTask = (int (**)(void))&off_66CF5C;
  this->m_pTargetPed = pTargetPed;
  if ( pTargetPos )
  {
    v6 = *(_QWORD *)&pTargetPos->x;
    this->m_vecTargetPos.z = pTargetPos->z;
    *(_QWORD *)&this->m_vecTargetPos.x = v6;
  }
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
  this->m_playedDiveSplash = 0;
  this->m_pFxSys = 0;
  this->fDistanceOffset = 0.0;
}
// 66CF5C: using guessed type void *;

//----- (0053A124) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::~CTaskSimpleSwim(CTaskSimpleSwim *this)
{
  _BOOL4 m_bAnimsReferenced; // r1
  CEntity *m_pClimbEnt; // r0
  CPed *m_pTargetPed; // r0

  m_bAnimsReferenced = this->m_bAnimsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66CF5C;
  if ( m_bAnimsReferenced )
    CAnimManager::RemoveAnimBlockRef(CAnimManager::ms_aAnimAssocGroups[71].m_pAnimBlock - CAnimManager::ms_aAnimBlocks);
  m_pClimbEnt = this->m_pClimbEnt;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, &this->m_pClimbEnt);
  m_pTargetPed = this->m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, &this->m_pTargetPed);
  sub_1A01F4(this);
}
// 66CF5C: using guessed type void *off_66CF5C;

//----- (0053A188) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::~CTaskSimpleSwim(CTaskSimpleSwim *this)
{
  _BOOL4 m_bAnimsReferenced; // r1
  CEntity *m_pClimbEnt; // r0
  CPed *m_pTargetPed; // r0
  void *v5; // r0

  m_bAnimsReferenced = this->m_bAnimsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66CF5C;
  if ( m_bAnimsReferenced )
    CAnimManager::RemoveAnimBlockRef(CAnimManager::ms_aAnimAssocGroups[71].m_pAnimBlock - CAnimManager::ms_aAnimBlocks);
  m_pClimbEnt = this->m_pClimbEnt;
  if ( m_pClimbEnt )
    CEntity::CleanUpOldReference(m_pClimbEnt, &this->m_pClimbEnt);
  m_pTargetPed = this->m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, &this->m_pTargetPed);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 53A1E0: variable 'v5' is possibly undefined
// 66CF5C: using guessed type void *off_66CF5C;

//----- (0053A1F0) --------------------------------------------------------
bool __fastcall CTaskSimpleSwim::MakeAbortable(
        CTaskSimpleSwim *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  uint32 m_nSwimAnim; // r1
  CAnimBlendAssociation *Association; // r0
  FxSystem_c *m_pFxSys; // r0
  bool v11; // zf

  if ( iPriority == 2 )
  {
    CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    pPed->m_eMoveStateAnim = PEDMOVE_STILL;
    m_nSwimAnim = this->m_nSwimAnim;
    if ( m_nSwimAnim != 191 )
    {
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_nSwimAnim);
      if ( Association )
        Association->m_fBlendDelta = -1000.0;
    }
    CPed::RestoreHeadingRate(pPed);
  }
  else
  {
    if ( !pEvent )
      return 0;
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 3))(pEvent) <= 70 )
    {
      if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 9 )
        return 0;
      v11 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
      if ( LOBYTE(pEvent[5]._vptr$CEvent) )
        v11 = !*(&pEvent->m_bIsPersistent + 1);
      if ( v11 )
        return 0;
    }
  }
  m_pFxSys = this->m_pFxSys;
  if ( m_pFxSys )
  {
    FxSystem_c::Kill(m_pFxSys);
    this->m_pFxSys = 0;
  }
  return 1;
}

//----- (0053A286) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::DestroyFxSystem(CTaskSimpleSwim *this)
{
  FxSystem_c *m_pFxSys; // r0

  m_pFxSys = this->m_pFxSys;
  if ( m_pFxSys )
  {
    FxSystem_c::Kill(m_pFxSys);
    this->m_pFxSys = 0;
  }
}

//----- (0053A2A0) --------------------------------------------------------
bool __fastcall CTaskSimpleSwim::ProcessPed(CTaskSimpleSwim *this, CPed *pPed)
{
  bool v4; // r6
  FxSystem_c *m_pFxSys; // r0
  int m_nPedFlags; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  uint32 m_nSwimTimer; // r0
  bool v11; // zf
  uint32 m_nSwimAnim; // r1
  CAnimBlendAssociation *v13; // r6
  AnimationId v14; // r0
  AnimationId v15; // r2
  const CEventDamage *v16; // r0
  uint32 v17; // r0
  unsigned int v18; // r1
  bool v19; // cf
  uint32 v20; // r1
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CPlayerPedData *m_pPlayerData; // r1
  float m_moveBlendRatio; // s0
  float v26; // s16
  CAnimBlendAssociation *Association; // r0
  bool v28; // r1
  bool v29; // zf
  float m_fBreath; // s16
  CEventDamage v31; // [sp+14h] [bp-74h] BYREF
  CPedDamageResponseCalculator v32; // [sp+54h] [bp-34h] BYREF

  if ( this->m_pClimbEnt )
  {
    CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 8.0);
    v4 = 1;
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    pPed->m_eMoveStateAnim = PEDMOVE_STILL;
    m_pFxSys = this->m_pFxSys;
    if ( !m_pFxSys )
      return v4;
    goto LABEL_34;
  }
  if ( this->m_fStopTimer <= CTaskSimpleSwim::SWIM_STOP_TIME )
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    if ( (m_nPedFlags & 0x100) == 0 )
    {
      v7 = *((_DWORD *)&pPed->m_nPedFlags + 1);
      v8 = *((_DWORD *)&pPed->m_nPedFlags + 2);
      v9 = *((_DWORD *)&pPed->m_nPedFlags + 3);
      *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags & 0xFFFFFDFF;
      *((_DWORD *)&pPed->m_nPedFlags + 1) = v7;
      *((_DWORD *)&pPed->m_nPedFlags + 2) = v8;
      *((_DWORD *)&pPed->m_nPedFlags + 3) = v9;
      if ( CPed::IsPlayer(pPed) )
      {
        m_nSwimTimer = this->m_nSwimTimer;
        v11 = m_nSwimTimer == 0;
        if ( m_nSwimTimer )
          v11 = this->m_nSwimState == 4;
        if ( v11 )
        {
          CTaskSimpleSwim::ProcessControlInput(this, (CPlayerPed *)pPed);
          this->m_nSwimTimer = 0;
        }
        else
        {
          CTaskSimpleSwim::ProcessControlAI(this, pPed);
          v17 = this->m_nSwimTimer;
          v18 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
          v19 = v17 >= v18;
          v20 = v17 - v18;
          if ( v20 == 0 || !v19 )
            v20 = 0;
          this->m_nSwimTimer = v20;
          m_pMat = pPed->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          pPed->m_pPlayerData->m_moveBlendRatio = sqrtf(
                                                    (float)((float)(this->m_vecTargetPos.x - p_tx->m_translate.x)
                                                          * (float)(this->m_vecTargetPos.x - p_tx->m_translate.x))
                                                  + (float)((float)(this->m_vecTargetPos.y - p_tx->m_translate.y)
                                                          * (float)(this->m_vecTargetPos.y - p_tx->m_translate.y)));
          m_pPlayerData = pPed->m_pPlayerData;
          m_moveBlendRatio = m_pPlayerData->m_moveBlendRatio;
          if ( m_moveBlendRatio < 0.5 )
          {
            m_pPlayerData->m_moveBlendRatio = 0.0;
            goto LABEL_32;
          }
          if ( m_moveBlendRatio > 1.0 )
            m_pPlayerData->m_moveBlendRatio = 1.0;
        }
        v26 = 1.0;
        if ( this->m_nSwimState == 4 )
        {
          Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Au);
          v28 = 1;
          if ( Association )
            v26 = (float)(Association->m_fSpeed * Association->m_fBlendAmount) + 1.0;
        }
        else
        {
          v28 = 0;
        }
        CPlayerPed::HandlePlayerBreath((CPlayerPed *)pPed, v28, v26);
        v29 = !this->m_bAddedIdleAnim;
        if ( this->m_bAddedIdleAnim )
          v29 = this->m_nSwimState == 4;
        if ( !v29 )
        {
          m_fBreath = pPed->m_pPlayerData->m_fBreath;
          if ( m_fBreath < (float)(CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BREATH_UNDERWATER) * 0.5) )
            CPed::Say(pPed, 0x164u, 0, 1.0, 0, 0, 0);
        }
        CPed::SetMoveState(pPed, PEDMOVE_NONE);
      }
      else
      {
        CTaskSimpleSwim::ProcessControlAI(this, pPed);
        if ( this->m_nSwimState == 4 )
        {
          CPedDamageResponseCalculator::CPedDamageResponseCalculator(
            &v32,
            0,
            CTimer::ms_fTimeStep,
            WEAPONTYPE_DROWNING,
            PED_SPHERE_CHEST,
            0);
          CEventDamage::CEventDamage(
            &v31,
            0,
            CTimer::m_snTimeInMilliseconds,
            WEAPONTYPE_DROWNING,
            PED_SPHERE_CHEST,
            0,
            0,
            *(_DWORD *)&pPed->m_nPedFlags & 0x100);
          if ( CEventDamage::AffectsPed(v16, pPed) )
            CPedDamageResponseCalculator::ComputeDamageResponse(&v32, pPed, &v31.m_pedDamageResponse, 1);
          else
            v31.m_pedDamageResponse.m_bDamageCalculated = 1;
          CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v31, 0);
          CEventDamage::~CEventDamage(&v31);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v32);
        }
      }
      CTaskSimpleSwim::ProcessSwimAnims(this, pPed);
      CTaskSimpleSwim::ProcessSwimmingResistance(this, pPed);
      CTaskSimpleSwim::ProcessEffects(this, pPed);
      return 0;
    }
  }
  m_nSwimAnim = this->m_nSwimAnim;
  if ( m_nSwimAnim == 191 )
    v13 = 0;
  else
    v13 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, m_nSwimAnim);
  pPed->m_eMoveStateAnim = PEDMOVE_STILL;
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  if ( v13 )
  {
    if ( v13->m_animId == 128 )
      v13->m_bitsFlag |= 8u;
    else
      v13->m_fBlendDelta = -4.0;
    v14 = this->m_nSwimAnim;
    if ( v14 == ANIM_SWIM_CRAWL )
    {
      pPed->m_eMoveStateAnim = PEDMOVE_RUN;
      CPed::SetMoveState(pPed, PEDMOVE_RUN);
      v15 = ANIM_STD_RUN;
      goto LABEL_33;
    }
    if ( v14 == ANIM_SWIM_BREAST )
    {
      pPed->m_eMoveStateAnim = PEDMOVE_WALK;
      CPed::SetMoveState(pPed, PEDMOVE_WALK);
      v15 = ANIM_STD_WALK;
      goto LABEL_33;
    }
  }
LABEL_32:
  v15 = ANIM_STD_IDLE;
LABEL_33:
  CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, v15, 4.0);
  CPed::RestoreHeadingRate(pPed);
  m_pFxSys = this->m_pFxSys;
  if ( !m_pFxSys )
    return 1;
LABEL_34:
  FxSystem_c::Kill(m_pFxSys);
  v4 = 1;
  this->m_pFxSys = 0;
  return v4;
}
// 53A3FC: variable 'v16' is possibly undefined

//----- (0053A5D4) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::ProcessControlAI(CTaskSimpleSwim *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v6; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  RwReal v9; // s0
  RwReal v10; // s4
  float fDistanceOffset; // s0
  CPed *v12; // r0
  float v13; // s4
  float v14; // s6
  CMatrix *v15; // r1
  float *v16; // r2
  float x; // s0
  RwReal v18; // s4
  RwReal v19; // s2
  float y; // s2
  __int64 v21; // r0
  CMatrix *v22; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *v24; // r1
  _BOOL4 IsPlayer; // r0
  CMatrix *v26; // r1
  CSimpleTransform *v27; // r2
  float v28; // s4
  float v29; // s0
  CPed *v30; // r0
  CPedGroup *PedsGroup; // r0
  CPed *Leader; // r0
  CMatrix *v33; // r0
  int v34; // r6
  CPed *v35; // r0
  bool v36; // zf
  CMatrix *v37; // r0
  CSimpleTransform *v38; // r1
  float v39; // s0
  CMatrix *v40; // r0
  float v41; // s4
  float v42; // s6
  CVector v43; // [sp+4h] [bp-24h] BYREF

  m_pTargetPed = this->m_pTargetPed;
  this->m_nSwimState = 0;
  if ( m_pTargetPed )
  {
    m_pMat = pPed->m_pMat;
    v6 = m_pTargetPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    p_x = &v6->tx;
    if ( !v6 )
      p_x = &m_pTargetPed->m_transform.m_translate.x;
    v9 = *p_x - p_tx->m_translate.x;
    v10 = p_x[2] - p_tx->m_translate.z;
    v43.y = p_x[1] - p_tx->m_translate.y;
    v43.x = v9;
    v43.z = v10;
    CVector::Normalise(&v43);
    fDistanceOffset = this->fDistanceOffset;
    if ( fDistanceOffset == 0.0 )
    {
      fDistanceOffset = (float)((float)(rand() & 3) * 0.5) + 1.5;
      this->fDistanceOffset = fDistanceOffset;
    }
    v12 = this->m_pTargetPed;
    v13 = fDistanceOffset * v43.y;
    v14 = fDistanceOffset * v43.z;
    v15 = v12->m_pMat;
    v16 = &v15->tx;
    if ( !v15 )
      v16 = &v12->m_transform.m_translate.x;
    x = *v16 - (float)(fDistanceOffset * v43.x);
    v18 = v16[1] - v13;
    v19 = v16[2] - v14;
    this->m_vecTargetPos.x = x;
    this->m_vecTargetPos.y = v18;
    this->m_vecTargetPos.z = v19;
  }
  else
  {
    x = this->m_vecTargetPos.x;
  }
  y = this->m_vecTargetPos.y;
  v21 = 0LL;
  if ( x != 0.0 )
    HIDWORD(v21) = 1;
  if ( y != 0.0 )
    LODWORD(v21) = 1;
  if ( !v21 && this->m_vecTargetPos.z == 0.0 )
    goto LABEL_33;
  v22 = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  v24 = &pPed->m_transform;
  if ( v22 )
    v24 = (CSimpleTransform *)&v22->tx;
  pPed->m_fDesiredHeading = atan2f(-(float)(x - v24->m_translate.x), y - v24->m_translate.y);
  IsPlayer = CPed::IsPlayer(pPed);
  v26 = pPed->m_pMat;
  v27 = &pPed->m_transform;
  if ( v26 )
    v27 = (CSimpleTransform *)&v26->tx;
  v28 = 1.0;
  v29 = sqrtf(
          (float)((float)(this->m_vecTargetPos.x - v27->m_translate.x)
                * (float)(this->m_vecTargetPos.x - v27->m_translate.x))
        + (float)((float)(this->m_vecTargetPos.y - v27->m_translate.y)
                * (float)(this->m_vecTargetPos.y - v27->m_translate.y)));
  if ( IsPlayer )
    v28 = 0.5;
  if ( v29 <= v28 )
    goto LABEL_33;
  v30 = this->m_pTargetPed;
  this->m_nSwimState = 1;
  if ( !v30
    || !CPedGroups::GetPedsGroup(pPed)
    || (PedsGroup = CPedGroups::GetPedsGroup(pPed),
        Leader = CPedGroupMembership::GetLeader(&PedsGroup->m_membership),
        Leader != this->m_pTargetPed) )
  {
    if ( this->m_fControlSpeed > 1.0 )
    {
      v33 = pPed->m_pMat;
      if ( v33 )
        p_m_transform = (CSimpleTransform *)&v33->tx;
      if ( sqrtf(
             (float)((float)(this->m_vecTargetPos.x - p_m_transform->m_translate.x)
                   * (float)(this->m_vecTargetPos.x - p_m_transform->m_translate.x))
           + (float)((float)(this->m_vecTargetPos.y - p_m_transform->m_translate.y)
                   * (float)(this->m_vecTargetPos.y - p_m_transform->m_translate.y))) > 2.0 )
        this->m_nSwimState = 2;
    }
LABEL_33:
    v34 = 0;
    goto LABEL_34;
  }
  if ( CPedIntelligence::GetTaskSwim(Leader->m_pPedIntelligence)
    && CPedIntelligence::GetTaskSwim(this->m_pTargetPed->m_pPedIntelligence)->m_nSwimState == 2 )
  {
    v40 = pPed->m_pMat;
    if ( v40 )
      p_m_transform = (CSimpleTransform *)&v40->tx;
    v41 = p_m_transform->m_translate.x;
    v42 = p_m_transform->m_translate.y;
    v34 = 1;
    if ( sqrtf(
           (float)((float)(this->m_vecTargetPos.x - v41) * (float)(this->m_vecTargetPos.x - v41))
         + (float)((float)(this->m_vecTargetPos.y - v42) * (float)(this->m_vecTargetPos.y - v42))) > 5.0 )
      this->m_nSwimState = 2;
  }
  else
  {
    v34 = 1;
  }
LABEL_34:
  v35 = this->m_pTargetPed;
  v36 = v35 == 0;
  if ( v35 )
    v36 = *(_BYTE *)&v35->m_nPedFlags << 31 == 0;
  if ( !v36 && !(*((unsigned __int8 *)&v35->m_nPhysicalFlags + 1) << 31) )
    goto LABEL_61;
  if ( (*((_BYTE *)&pPed->m_nPedFlags + 13) & 0x20) != 0 && !(*((unsigned __int8 *)&v35->m_nPhysicalFlags + 1) << 31) )
  {
    v37 = pPed->m_pMat;
    v38 = (CSimpleTransform *)&v37->tx;
    if ( !v37 )
      v38 = &pPed->m_transform;
    if ( sqrtf(
           (float)((float)(this->m_vecTargetPos.x - v38->m_translate.x)
                 * (float)(this->m_vecTargetPos.x - v38->m_translate.x))
         + (float)((float)(this->m_vecTargetPos.y - v38->m_translate.y)
                 * (float)(this->m_vecTargetPos.y - v38->m_translate.y))) < 1.0 )
    {
LABEL_61:
      if ( !((CTimer::m_FrameCounter + pPed->RandomSeed + 124) << 25)
        && CTaskSimpleClimb::TestForClimb(pPed, &this->m_vecEdge, &this->m_fEdgeHeading, &this->m_nEdgeSurfaceType, 1) )
      {
        this->m_nSwimState = 5;
      }
    }
  }
  this->m_fPitchTorso = 0.0;
  this->m_fRollTorso = 0.0;
  if ( !v34 && !CPed::IsPlayer(pPed) && this->m_fControlSpeed < 0.0 )
  {
    v39 = pPed->m_extractedVelocity.y * 0.5;
    pPed->m_extractedVelocity.x = pPed->m_extractedVelocity.x * 0.5;
    pPed->m_extractedVelocity.y = v39;
  }
}

//----- (0053A958) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::ProcessControlInput(CTaskSimpleSwim *this, CPlayerPed *pPlayerPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  float32x2_t v6; // d4
  float32x2_t v7; // d10
  float32x2_t v8; // d11
  _BOOL4 m_bAddedIdleAnim; // r0
  bool v12; // zf
  CPad *PadFromPlayer; // r6
  float PedWalkLeftRight; // s16
  int PedWalkUpDown; // r0
  float v16; // s18
  float v17; // s20
  float v18; // s16
  unsigned int m_nSwimState; // r0
  float RadianAngleBetweenPoints; // r0
  float v21; // s22
  float v22; // s20
  float v23; // r9
  float v24; // r8
  float v25; // s0
  int v26; // r6
  float *v27; // r1
  float v28; // s16
  float v29; // s18
  unsigned __int32 v30; // s20
  float v31; // s22
  float v32; // s24
  int LookDirection; // r6
  float v34; // r0
  float m_fCurrentHeading; // s4
  float v36; // s4
  float v37; // s0
  float v38; // s18
  float v39; // s16
  float v40; // s4
  float v41; // s6
  float v42; // s0
  float v43; // r6
  float v44; // s0
  float v45; // s2
  CMatrix *m_pMat; // r0
  __int64 v47; // kr00_8
  float *p_m_fDesiredHeading; // r4
  float v49; // s0
  float v50; // s2
  CPlayerPedData *v51; // r1
  float v52; // s6
  float v53; // s0
  float v54; // s8
  float v55; // s6
  CPlayerPedData *v56; // r0
  float v57; // s2
  float v58; // s4
  float v59; // r0
  float v60; // s24
  float v61; // r0
  float m_fDiveAngle; // s2
  float v63; // s4
  int v64; // r1
  int v65; // r0
  float v66; // s2
  bool v67; // fnf
  CPlayerPedData *v68; // r0
  float m_moveBlendRatio; // s4
  float v70; // s6
  float v71; // s4
  int v72; // r0
  CMatrix *v73; // r0
  CSimpleTransform *p_tx; // r1
  float xy; // s16
  float yy; // s18
  float zy; // s20
  float x; // s22
  float y; // s24
  float z; // s26
  int16 v81; // r4
  float m_fDiveSurfaceSpeed; // s6
  float v83; // s4
  float v84; // s8
  float v85; // s6
  float v86; // s8
  float v87; // s10
  int v88; // r1
  float v89; // s0
  float v90; // s4
  bool v91; // nf
  int v92; // s4
  bool v93; // fzf
  bool v94; // fnf
  CPlayerPedData *m_pPlayerData; // r0
  float m_fRollAngle; // s18
  float v97; // s0
  int v98; // r6
  int v99; // s18
  bool v100; // zf
  float v101; // s20
  float v102; // s0
  bool v103; // zf
  float m_fRollTorso; // s22
  float m_fPitchTorso; // s20
  float v106; // s0
  float v107; // r0
  int v108; // r2
  float v109; // [sp+8h] [bp-50h] BYREF
  float pWaterZ[19]; // [sp+Ch] [bp-4Ch] BYREF
  CVector v111; // 0:r1.12

  m_bAddedIdleAnim = this->m_bAddedIdleAnim;
  v12 = !m_bAddedIdleAnim;
  if ( m_bAddedIdleAnim )
    v12 = !this->m_bAnimsReferenced;
  if ( v12 )
  {
    pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
    return;
  }
  PadFromPlayer = CPlayerPed::GetPadFromPlayer(pPlayerPed);
  PedWalkLeftRight = (float)CPad::GetPedWalkLeftRight(PadFromPlayer);
  PedWalkUpDown = CPad::GetPedWalkUpDown(PadFromPlayer);
  v16 = PedWalkLeftRight * 0.0078125;
  v17 = (float)PedWalkUpDown * 0.0078125;
  if ( this->m_nSwimState <= 2 )
  {
    if ( CPad::SwimJumpJustDown(PadFromPlayer) )
    {
      this->m_nSwimState = 5;
    }
    else if ( CPad::DiveJustDown(PadFromPlayer) )
    {
      this->m_nSwimState = 3;
      pPlayerPed->m_pPlayerData->m_moveBlendRatio = 0.0;
    }
  }
  v18 = sqrtf((float)(v16 * v16) + (float)(v17 * v17));
  m_nSwimState = this->m_nSwimState;
  if ( m_nSwimState >= 3 )
  {
    if ( m_nSwimState != 4 )
    {
      if ( m_nSwimState == 3 && this->m_fDiveSurfaceSpeed > 0.0 )
        this->m_fDiveSurfaceSpeed = 0.0;
      goto LABEL_129;
    }
    if ( CHID::GetInputType() == 2 )
    {
      v27 = (float *)((char *)&TheCamera + 528 * TheCamera.ActiveCam);
      v28 = v27[182];
      v29 = v27[183];
      v30 = *((_DWORD *)v27 + 184);
      v31 = -v28;
      v32 = -v29;
      LookDirection = CCamera::GetLookDirection(&TheCamera);
      if ( LookDirection == 3 )
      {
        v31 = v28;
        v32 = v29;
      }
      v34 = atan2f(COERCE_FLOAT(LODWORD(v31) ^ 0x80000000), v32);
      v2.n64_u32[0] = 0;
      m_fCurrentHeading = pPlayerPed->m_fCurrentHeading;
      if ( LookDirection == 3 )
        v2.n64_u32[0] = v30;
      pPlayerPed->m_fDesiredHeading = v34;
      v3.n64_f32[0] = v34 - m_fCurrentHeading;
      if ( (float)(v34 - m_fCurrentHeading) >= -3.1416 )
      {
        if ( v3.n64_f32[0] <= 3.1416 )
          v36 = -0.0;
        else
          v36 = 6.2832;
      }
      else
      {
        v36 = -6.2832;
      }
      v7.n64_u32[0] = -1.0;
      v8.n64_u32[0] = 1.0;
      v39 = CTimer::ms_fTimeStep;
      v59 = v2.n64_f32[0];
      v3.n64_f32[0] = (float)(v36 - v3.n64_f32[0]) * 10.0;
      v38 = vmin_f32(vmax_f32(v3, v7), v8).n64_f32[0];
      v60 = this->m_fRollAngle + (float)(CTimer::ms_fTimeStep * (float)(v38 * 0.04));
      v2.n64_f32[0] = this->m_fRollTorso + (float)(CTimer::ms_fTimeStep * (float)(v38 * 0.08));
      this->m_fRollAngle = v60;
      this->m_fRollTorso = v2.n64_f32[0];
      v61 = asinf(v59);
      m_fDiveAngle = this->m_fDiveAngle;
      v2.n64_f32[0] = (float)(v61 - m_fDiveAngle) * 10.0;
      v2.n64_u64[0] = vmin_f32(vmax_f32(v2, v7), v8).n64_u64[0];
      if ( this->m_fDiveSurfaceSpeed == 0.0 || v2.n64_f32[0] < 0.0 )
        this->m_fDiveAngle = m_fDiveAngle + (float)((float)(v2.n64_f32[0] * 0.02) * v39);
      v63 = v60 + v60;
      v64 = 0;
      v65 = 0;
      v66 = v60 + v60;
      if ( (float)(v60 + v60) > 1.0 )
      {
        v66 = 1.0;
        v64 = 1;
      }
      v67 = v66 < -1.0;
LABEL_113:
      v3.n64_u32[0] = 1.0;
      v6.n64_u32[0] = -1.0;
      v87 = 1.0;
      if ( v67 )
        v65 = 1;
      v88 = v64 | v65;
      if ( v65 )
        v87 = -1.0;
      if ( v88 )
        v63 = v87;
      v2.n64_f32[0] = v2.n64_f32[0] + (float)(v63 * (float)(v38 * -0.08));
      this->m_fPitchTorso = this->m_fPitchTorso
                          + (float)(v39 * (float)(vmax_f32(vmin_f32(v2, v3), v6).n64_f32[0] * -0.08));
      goto LABEL_120;
    }
    if ( v18 <= 0.0 )
    {
      v39 = CTimer::ms_fTimeStep;
LABEL_120:
      v89 = this->m_fDiveAngle + (float)(v39 * 0.001);
      v90 = v89;
      if ( v89 > 1.3963 )
        v90 = 1.3963;
      v91 = v90 < -1.3963;
      *(float *)&v92 = 1.3963;
      v93 = v89 == 1.3963;
      v94 = v89 < 1.3963;
      if ( v91 )
      {
        *(float *)&v92 = -1.3963;
        v89 = -1.3963;
      }
      if ( !v94 && !v93 )
        v89 = *(float *)&v92;
      this->m_fDiveAngle = v89;
      m_pPlayerData = pPlayerPed->m_pPlayerData;
      if ( m_pPlayerData->m_fSprintEnergy <= 0.0 )
        m_pPlayerData->m_fSprintEnergy = 0.1;
      CPlayerPed::ControlButtonSprint(pPlayerPed, SPRINT_UNDER_WATER);
      goto LABEL_129;
    }
    v37 = 1.0 / v18;
    v38 = v16 * (float)(1.0 / v18);
    v39 = CTimer::ms_fTimeStep;
    v40 = pPlayerPed->m_fDesiredHeading + (float)((float)(v38 * -0.03) * CTimer::ms_fTimeStep);
    pPlayerPed->m_fDesiredHeading = v40;
    if ( v40 <= 3.1416 )
    {
      if ( v40 >= -3.1416 )
        goto LABEL_102;
      v41 = 6.2832;
    }
    else
    {
      v41 = -6.2832;
    }
    pPlayerPed->m_fDesiredHeading = v40 + v41;
LABEL_102:
    v2.n64_f32[0] = v17 * v37;
    m_fDiveSurfaceSpeed = this->m_fDiveSurfaceSpeed;
    v83 = this->m_fRollAngle + (float)((float)(v38 * 0.04) * v39);
    v84 = this->m_fRollTorso + (float)((float)(v38 * 0.08) * v39);
    this->m_fRollAngle = v83;
    this->m_fRollTorso = v84;
    if ( MobileSettings::settings[15].value )
    {
      if ( v2.n64_f32[0] <= 0.0 && m_fDiveSurfaceSpeed != 0.0 )
        goto LABEL_110;
      v85 = 0.02;
    }
    else
    {
      if ( v2.n64_f32[0] >= 0.0 && m_fDiveSurfaceSpeed != 0.0 )
        goto LABEL_110;
      v85 = -0.02;
    }
    this->m_fDiveAngle = this->m_fDiveAngle + (float)((float)(v2.n64_f32[0] * v85) * v39);
LABEL_110:
    v63 = v83 + v83;
    v64 = 0;
    v65 = 0;
    v86 = v63;
    if ( v63 > 1.0 )
    {
      v86 = 1.0;
      v64 = 1;
    }
    v67 = v86 < -1.0;
    goto LABEL_113;
  }
  if ( !CGameLogic::IsPlayerUse2PlayerControls(pPlayerPed) )
  {
    v26 = 0;
    goto LABEL_47;
  }
  if ( v18 <= 0.0 )
    goto LABEL_45;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               0.0,
                               0.0,
                               COERCE_FLOAT(LODWORD(v16) ^ 0x80000000),
                               v17);
  v21 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints - TheCamera.Orientation);
  v22 = pPlayerPed->m_fCurrentHeading;
  v23 = sinf(v21);
  v24 = cosf(v21);
  if ( v21 > (float)(v22 + 3.1416) )
  {
    v25 = -6.2832;
LABEL_34:
    v21 = v21 + v25;
    goto LABEL_35;
  }
  if ( v21 < (float)(v22 + -3.1416) )
  {
    v25 = 6.2832;
    goto LABEL_34;
  }
LABEL_35:
  v42 = 1.0;
  LODWORD(v43) = LODWORD(v23) ^ 0x80000000;
  if ( (float)(v21 - v22) <= 1.0 )
  {
    v42 = v21 - v22;
    if ( (float)(v21 - v22) < -1.0 )
      v42 = -1.0;
  }
  v44 = v22 + (float)((float)(v42 * 0.08) * CTimer::ms_fTimeStep);
  pPlayerPed->m_fDesiredHeading = v44;
  if ( v44 <= 3.1416 )
  {
    if ( v44 >= -3.1416 )
      goto LABEL_43;
    v45 = 6.2832;
  }
  else
  {
    v45 = -6.2832;
  }
  pPlayerPed->m_fDesiredHeading = v44 + v45;
LABEL_43:
  LODWORD(v111.x) = LODWORD(v23) ^ 0x80000000;
  *(_QWORD *)&v111.y = LODWORD(v24);
  if ( CGameLogic::IsPlayerAllowedToGoInThisDirection(pPlayerPed, v111, 0.0) == 1 )
  {
    m_pMat = pPlayerPed->m_pMat;
    v17 = -(float)(v18
                 * (float)((float)((float)(m_pMat->xy * v43) + (float)(v24 * m_pMat->yy)) + (float)(m_pMat->zy * 0.0)));
    v16 = v18 * (float)((float)((float)(m_pMat->xx * v43) + (float)(v24 * m_pMat->yx)) + (float)(m_pMat->zx * 0.0));
LABEL_45:
    v26 = 1;
    goto LABEL_47;
  }
  v16 = 0.0;
  v26 = 1;
  v17 = 0.0;
  v18 = 0.0;
LABEL_47:
  if ( CHID::GetInputType() != 2 )
  {
    if ( v18 <= 0.0 )
    {
      v56 = pPlayerPed->m_pPlayerData;
      v3.n64_u32[0] = LODWORD(v56->m_moveBlendRatio);
      v53 = CTimer::ms_fTimeStep;
      if ( v3.n64_f32[0] > 0.0 )
      {
        v5.n64_u32[0] = 0;
        v3.n64_f32[0] = v3.n64_f32[0] + (float)(CTimer::ms_fTimeStep * -0.05);
        LODWORD(v56->m_moveBlendRatio) = vmax_f32(v3, v5).n64_u32[0];
      }
      goto LABEL_88;
    }
    if ( v26 == 1 )
    {
      v53 = CTimer::ms_fTimeStep;
LABEL_85:
      v68 = pPlayerPed->m_pPlayerData;
      m_moveBlendRatio = v68->m_moveBlendRatio;
      v70 = v18 - m_moveBlendRatio;
      v71 = (float)(v53 * 0.07) + m_moveBlendRatio;
      if ( v70 > (float)(v53 * 0.07) )
        v18 = v71;
      v68->m_moveBlendRatio = v18;
      goto LABEL_88;
    }
    v53 = CTimer::ms_fTimeStep;
    v57 = pPlayerPed->m_fDesiredHeading + (float)((float)(v16 * -0.03) * CTimer::ms_fTimeStep);
    pPlayerPed->m_fDesiredHeading = v57;
    if ( v57 <= 3.1416 )
    {
      if ( v57 >= -3.1416 )
        goto LABEL_79;
      v58 = 6.2832;
    }
    else
    {
      v58 = -6.2832;
    }
    pPlayerPed->m_fDesiredHeading = v57 + v58;
LABEL_79:
    if ( this->m_nSwimState )
    {
      if ( v17 <= 0.0 )
        goto LABEL_85;
    }
    else
    {
      v18 = -0.0;
    }
    v18 = v18 - v17;
    if ( v18 < 0.0 )
      v18 = 0.0;
    goto LABEL_85;
  }
  v47 = *(_QWORD *)&TheCamera.Cams[TheCamera.ActiveCam].Front.x;
  pPlayerPed->m_fDesiredHeading = atan2f(COERCE_FLOAT(v47 ^ 0x80000000), *((float *)&v47 + 1));
  p_m_fDesiredHeading = &pPlayerPed->m_fDesiredHeading;
  if ( CCamera::GetLookDirection(&TheCamera) != 3 )
  {
    v49 = *p_m_fDesiredHeading + 3.1416;
    *p_m_fDesiredHeading = v49;
    if ( v49 > 3.1416 )
      *p_m_fDesiredHeading = v49 + -6.2832;
  }
  v50 = -v17;
  v51 = pPlayerPed->m_pPlayerData;
  v52 = v51->m_moveBlendRatio;
  v53 = CTimer::ms_fTimeStep;
  v54 = (float)-v17 - v52;
  v55 = (float)(CTimer::ms_fTimeStep * 0.07) + v52;
  if ( v54 > (float)(CTimer::ms_fTimeStep * 0.07) )
    v50 = v55;
  v51->m_moveBlendRatio = v50;
  v3.n64_f32[0] = *p_m_fDesiredHeading - pPlayerPed->m_fCurrentHeading;
  if ( v3.n64_f32[0] >= -3.1416 )
  {
    if ( v3.n64_f32[0] <= 3.1416 )
      v4.n64_u32[0] = 0x80000000;
    else
      v4.n64_u32[0] = 1086918619;
  }
  else
  {
    v4.n64_u32[0] = -1060565029;
  }
  v3.n64_f32[0] = v4.n64_f32[0] - v3.n64_f32[0];
  v4.n64_u32[0] = -1.0;
  v3.n64_f32[0] = v3.n64_f32[0] * 10.0;
  v5.n64_u32[0] = 1.0;
  LODWORD(v16) = vmin_f32(vmax_f32(v3, v4), v5).n64_u32[0];
LABEL_88:
  v72 = (unsigned __int16)this->m_nSwimState;
  this->m_fRollTorso = this->m_fRollTorso + (float)((float)(v16 * 0.08) * v53);
  if ( v72 == 2 )
  {
    this->m_fRollAngle = (float)((float)(v16 * 0.04) * v53) + this->m_fRollAngle;
    v109 = 0.0;
    pWaterZ[0] = 0.0;
    v73 = pPlayerPed->m_pMat;
    p_tx = (CSimpleTransform *)&v73->tx;
    xy = v73->xy;
    yy = v73->yy;
    zy = v73->zy;
    if ( !v73 )
      p_tx = &pPlayerPed->m_transform;
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    if ( CWaterLevel::GetWaterLevel(p_tx->m_translate.x + xy, y + yy, z + zy, pWaterZ, 1, 0) == 1
      && CWaterLevel::GetWaterLevel(x - xy, y - yy, z - zy, &v109, 1, 0) == 1 )
    {
      this->m_fDiveAngle = atan2f(pWaterZ[0] - v109, 2.0);
    }
  }
  else if ( v72 == 1 )
  {
    this->m_fPitchTorso = (float)((float)(fabsf(v16) * 0.04) * v53) + this->m_fPitchTorso;
  }
  v81 = 2;
  if ( CPlayerPed::ControlButtonSprint(pPlayerPed, SPRINT_ON_WATER) < 1.0 )
    v81 = pPlayerPed->m_pPlayerData->m_moveBlendRatio > 0.5;
  this->m_nSwimState = v81;
LABEL_129:
  m_fRollAngle = this->m_fRollAngle;
  if ( m_fRollAngle > 0.01 || m_fRollAngle < -0.01 )
    v97 = m_fRollAngle * powf(0.95, CTimer::ms_fTimeStep);
  else
    v97 = 0.0;
  v98 = (unsigned __int16)this->m_nSwimState;
  v99 = 1064011039;
  v100 = v98 == 2;
  this->m_fRollAngle = v97;
  if ( v98 != 2 )
    v100 = v98 == 4;
  if ( !v100 )
  {
    v101 = this->m_fDiveAngle;
    if ( v101 > 0.01 || v101 < -0.01 )
      v102 = v101 * powf(0.95, CTimer::ms_fTimeStep);
    else
      v102 = 0.0;
    v103 = v98 == 5;
    this->m_fDiveAngle = v102;
    if ( v98 != 5 )
      v103 = v98 == 3;
    if ( v103 )
      v99 = 1064514355;
  }
  m_fRollTorso = this->m_fRollTorso;
  m_fPitchTorso = this->m_fPitchTorso;
  if ( m_fRollTorso > 0.01 || m_fRollTorso < -0.01 || m_fPitchTorso > 0.01 || m_fPitchTorso < -0.01 )
  {
    v107 = powf(*(float *)&v99, CTimer::ms_fTimeStep);
    v106 = v107 * m_fPitchTorso;
    this->m_fRollTorso = v107 * m_fRollTorso;
  }
  else
  {
    v106 = 0.0;
    this->m_fRollTorso = 0.0;
  }
  this->m_fPitchTorso = v106;
  if ( v98 != 2 )
  {
    if ( v98 == 1 )
      v108 = 1056964608;
    else
      v108 = 1065353216;
    CPlayerPed::HandleSprintEnergy(pPlayerPed, 0, *(float *)&v108);
  }
}
// 53ADBE: variable 'v3' is possibly undefined
// 53ADBE: variable 'v4' is possibly undefined
// 53ADC2: variable 'v5' is possibly undefined
// 53AE80: variable 'v7' is possibly undefined
// 53AE88: variable 'v8' is possibly undefined
// 53AED0: variable 'v2' is possibly undefined
// 53B1C2: variable 'v6' is possibly undefined
// 53A958: using guessed type float pWaterZ[19];

//----- (0053B3F0) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::ProcessSwimAnims(CTaskSimpleSwim *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  CAnimBlendAssociation *Association; // r0
  FxSystem_c *m_pWeaponFxSys; // r0
  _BOOL4 IsPlayer; // r0
  bool v10; // zf
  CAnimBlock *m_pAnimBlock; // r0
  const unsigned __int8 *AnimBlockName; // r0
  _BOOL4 m_loaded; // r2
  int v14; // r0
  bool v15; // zf
  CAnimBlendAssociation *v16; // r0
  CAnimBlendAssociation *v17; // r0
  CAnimBlendAssociation *v18; // r0
  CAnimBlendAssociation *v19; // r0
  CAnimBlendAssociation *v20; // r0
  CAnimBlendAssociation *v21; // r0
  CAnimBlendAssociation *v22; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r2
  CMatrix *v26; // r0
  RpClump_0 *m_pRwObject; // r0
  AnimationId v28; // r6
  CAnimBlendAssociation *v29; // r6
  CAnimBlendAssociation *v30; // r6
  CAnimBlendAssociation *v31; // r0
  CAnimBlendAssociation *v32; // r0
  float m_fDiveSurfaceSpeed; // s0
  float v34; // s0
  AnimationId v35; // r1
  CAnimBlendAssociation *v36; // r0
  CAnimBlendAssociation *v37; // r0
  AnimationId v38; // r2
  int v39; // r3
  RpClump_0 *v40; // r0
  CSimpleTransform *v41; // r6
  CMatrix *v42; // r0
  CSimpleTransform *v43; // r2
  CMatrix *v44; // r0
  AnimationId m_nSwimAnim; // r0
  bool v46; // zf
  CAnimBlendAssociation *v47; // r0
  CPlayerPedData *m_pPlayerData; // r0
  int m_nSwimState; // r2
  CEntity *v50; // r0
  float m_fControlSpeed; // s0
  float v52; // s0
  CAnimBlendAssociation *v53; // r0
  CAnimBlendAssociation *v54; // r6
  float v55; // [sp+8h] [bp-18h] BYREF
  float pWaterZ[5]; // [sp+Ch] [bp-14h] BYREF

  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xEu);
  if ( this->m_bAddedIdleAnim )
  {
    if ( Association && Association->m_fBlendAmount < 1.0 && Association->m_fBlendDelta <= 0.0 )
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_IDLE_SWIM, 8.0);
  }
  else
  {
    if ( (Association
       || (Association = CAnimManager::BlendAnimation(
                           (RpClump_0 *)pPed->m_pRwObject,
                           ANIM_STD_PED,
                           ANIM_STD_IDLE_SWIM,
                           8.0)) != 0)
      && Association->m_fBlendAmount >= 1.0 )
    {
      this->m_bAddedIdleAnim = 1;
    }
    RpAnimBlendClumpSetBlendDeltas((RpClump_0 *)pPed->m_pRwObject, 0x10u, -8.0);
    m_pWeaponFxSys = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_pWeaponFxSys;
    if ( m_pWeaponFxSys )
    {
      FxSystem_c::Kill(m_pWeaponFxSys);
      pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_pWeaponFxSys = 0;
    }
    pWaterZ[0] = 0.0;
    IsPlayer = CPed::IsPlayer(pPed);
    v10 = IsPlayer;
    if ( IsPlayer )
      v10 = this->m_nSwimState == 0;
    if ( v10 )
    {
      m_pMat = pPed->m_pMat;
      p_m_transform = &pPed->m_transform;
      p_tx = &pPed->m_transform;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( CWaterLevel::GetWaterLevel(p_tx->m_translate.x, p_tx->m_translate.y, p_tx->m_translate.z, pWaterZ, 1, 0) == 1 )
      {
        v26 = pPed->m_pMat;
        if ( v26 )
          p_m_transform = (CSimpleTransform *)&v26->tx;
        if ( p_m_transform->m_translate.z < (float)(pWaterZ[0] + -2.0) )
          this->m_nSwimState = 4;
      }
    }
  }
  if ( !this->m_bAnimsReferenced )
  {
    m_pAnimBlock = CAnimManager::ms_aAnimAssocGroups[71].m_pAnimBlock;
    if ( !m_pAnimBlock )
    {
      AnimBlockName = CAnimManager::GetAnimBlockName(ANIM_SWIM_PED);
      m_pAnimBlock = CAnimManager::GetAnimationBlock(AnimBlockName);
    }
    m_loaded = m_pAnimBlock->m_loaded;
    v14 = m_pAnimBlock - CAnimManager::ms_aAnimBlocks;
    if ( m_loaded )
    {
      CAnimManager::AddAnimBlockRef(v14);
      this->m_bAnimsReferenced = 1;
    }
    else
    {
      CStreaming::RequestModel(v14 + 25575, 8);
    }
  }
  v15 = !this->m_bAddedIdleAnim;
  if ( this->m_bAddedIdleAnim )
    v15 = !this->m_bAnimsReferenced;
  if ( v15 )
    return;
  switch ( this->m_nSwimState )
  {
    case 0:
      if ( this->m_nSwimAnim != ANIM_STD_IDLE_SWIM )
      {
        v16 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x137u);
        if ( v16 )
          v16->m_fBlendDelta = -1.0;
        v17 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x138u);
        if ( v17 )
          v17->m_fBlendDelta = -1.0;
        v18 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x139u);
        if ( v18 )
          v18->m_fBlendDelta = -4.0;
        v19 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Au);
        if ( v19 )
          v19->m_fBlendDelta = -2.0;
        v20 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Bu);
        if ( v20 )
          v20->m_fBlendDelta = -2.0;
        v21 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Cu);
        if ( v21 )
          v21->m_fBlendDelta = -4.0;
        v22 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x80u);
        if ( v22 )
          v22->m_fBlendDelta = -4.0;
        this->m_nSwimAnim = ANIM_STD_IDLE_SWIM;
      }
      goto LABEL_99;
    case 1:
      m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
      v28 = ANIM_SWIM_BREAST;
      if ( this->m_nSwimAnim != ANIM_SWIM_BREAST )
      {
        v38 = ANIM_SWIM_BREAST;
        goto LABEL_75;
      }
      v29 = RpAnimBlendClumpGetAssociation(m_pRwObject, 0x137u);
      if ( !v29 )
        goto LABEL_85;
      if ( CPed::IsPlayer(pPed) )
      {
        v29->m_fSpeed = pPed->m_pPlayerData->m_moveBlendRatio;
      }
      else
      {
        m_fControlSpeed = this->m_fControlSpeed;
        if ( m_fControlSpeed > 0.0 && m_fControlSpeed <= 1.0 )
          v29->m_fSpeed = m_fControlSpeed;
      }
      goto LABEL_99;
    case 2:
      m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
      if ( this->m_nSwimAnim != ANIM_SWIM_CRAWL )
      {
        v28 = ANIM_SWIM_CRAWL;
        v38 = ANIM_SWIM_CRAWL;
LABEL_75:
        v39 = 0x40000000;
        goto LABEL_97;
      }
      v30 = RpAnimBlendClumpGetAssociation(m_pRwObject, 0x138u);
      if ( !v30 )
        goto LABEL_85;
      if ( pPed->m_pPlayerData )
      {
        v2.n64_u32[0] = 1.0;
        v3.n64_u32[0] = CPlayerPed::GetButtonSprintResults((CPlayerPed *)pPed, SPRINT_ON_WATER);
        LODWORD(v30->m_fSpeed) = vmax_f32(v3, v2).n64_u32[0];
      }
      else
      {
        v2.n64_u32[0] = LODWORD(this->m_fControlSpeed);
        if ( v2.n64_f32[0] > 1.0 )
        {
          v4.n64_u32[0] = 1.5;
          v2.n64_f32[0] = v2.n64_f32[0] + -1.0;
          LODWORD(v30->m_fSpeed) = vmin_f32(v2, v4).n64_u32[0];
        }
      }
      goto LABEL_99;
    case 3:
      m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
      v28 = ANIM_SWIM_DIVE;
      if ( this->m_nSwimAnim != ANIM_SWIM_DIVE )
      {
        v38 = ANIM_SWIM_DIVE;
        v39 = 1090519040;
        goto LABEL_97;
      }
      v31 = RpAnimBlendClumpGetAssociation(m_pRwObject, 0x139u);
      if ( !v31 )
        goto LABEL_85;
      if ( v31->m_fCurrentTime == v31->m_pAnimBlendHierarchy->m_fTotalTime )
        this->m_nSwimState = 4;
      goto LABEL_99;
    case 4:
      if ( (this->m_nSwimAnim & 0xFFFFFFFE) == 314 && this->m_fDiveSurfaceSpeed >= 0.0 )
      {
        if ( pPed->m_pPlayerData && CPlayerPed::GetButtonSprintResults((CPlayerPed *)pPed, SPRINT_UNDER_WATER) >= 1.0 )
        {
          v53 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Au);
          v54 = v53;
          if ( !v53 || v53->m_fBlendDelta < 0.0 || v53->m_fBlendAmount == 0.0 )
            v54 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_SWIM_PED, ANIM_SWIM_UWATER, 4.0);
          if ( v54->m_fCurrentTime == v54->m_pAnimBlendHierarchy->m_fTotalTime )
          {
            CAnimBlendAssociation::Start(v54, 0.0);
            v2.n64_u32[0] = 1060320051;
            v3.n64_u32[0] = CPlayerPed::GetButtonSprintResults((CPlayerPed *)pPed, SPRINT_UNDER_WATER);
            LODWORD(v54->m_fSpeed) = vmax_f32(v3, v2).n64_u32[0];
          }
          v28 = ANIM_SWIM_UWATER;
        }
        else
        {
          v47 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Bu);
          if ( v47 && v47->m_fBlendDelta >= 0.0 && v47->m_fBlendAmount != 0.0 )
          {
            v28 = ANIM_SWIM_UWATER_IDLE;
          }
          else
          {
            m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
            v28 = ANIM_SWIM_UWATER_IDLE;
            v38 = ANIM_SWIM_UWATER_IDLE;
            v39 = 1082130432;
LABEL_97:
            CAnimManager::BlendAnimation(m_pRwObject, ANIM_SWIM_PED, v38, *(float *)&v39);
          }
        }
        goto LABEL_98;
      }
      v32 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Au);
      if ( v32 )
      {
        m_fDiveSurfaceSpeed = this->m_fDiveSurfaceSpeed;
        if ( m_fDiveSurfaceSpeed < 0.0 && v32->m_fBlendAmount >= 0.99 )
        {
          if ( m_fDiveSurfaceSpeed <= -2.0 )
            v34 = 1.3963;
          else
            v34 = (float)(CTaskSimpleSwim::SWIM_DIVE_UNDER_ANGLE * 3.1416) / 180.0;
          this->m_fDiveSurfaceSpeed = 0.0;
          this->m_fDiveAngle = v34;
        }
      }
      else
      {
        CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_SWIM_PED, ANIM_SWIM_UWATER, 1000.0);
        m_nSwimAnim = this->m_nSwimAnim;
        v46 = m_nSwimAnim == ANIM_STD_NUM;
        if ( m_nSwimAnim != ANIM_STD_NUM )
          v46 = m_nSwimAnim == ANIM_STD_IDLE_SWIM;
        if ( v46 )
          v52 = -2.0;
        else
          v52 = -1.0;
        this->m_nSwimAnim = ANIM_SWIM_UWATER;
        this->m_fDiveSurfaceSpeed = v52;
      }
      goto LABEL_99;
    case 5:
      v35 = this->m_nSwimAnim;
      if ( v35 == ANIM_SWIM_JUMP )
      {
        v36 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Cu);
        if ( v36 )
        {
          if ( (float)(v36->m_fCurrentTime + v36->m_fTimeStep) >= (float)(v36->m_pAnimBlendHierarchy->m_fTotalTime * 0.25) )
          {
            v28 = ANIM_STD_CLIMB_GRAB;
            v37 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_CLIMB_GRAB, 8.0);
            v37->m_bitsFlag |= 8u;
LABEL_98:
            this->m_nSwimAnim = v28;
          }
          goto LABEL_99;
        }
        goto LABEL_85;
      }
      v40 = (RpClump_0 *)pPed->m_pRwObject;
      if ( v35 == ANIM_STD_CLIMB_GRAB )
      {
        if ( !RpAnimBlendClumpGetAssociation(v40, 0x80u) )
          goto LABEL_85;
        v41 = &pPed->m_transform;
        v55 = 0.0;
        v42 = pPed->m_pMat;
        v43 = &pPed->m_transform;
        if ( v42 )
          v43 = (CSimpleTransform *)&v42->tx;
        if ( CWaterLevel::GetWaterLevel(v43->m_translate.x, v43->m_translate.y, v43->m_translate.z, &v55, 1, 0) == 1 )
        {
          v44 = pPed->m_pMat;
          if ( v44 )
            v41 = (CSimpleTransform *)&v44->tx;
          if ( v55 > (float)(v41->m_translate.z + 0.5) )
LABEL_85:
            this->m_nSwimState = 0;
        }
      }
      else
      {
        CAnimManager::BlendAnimation(v40, ANIM_SWIM_PED, ANIM_SWIM_JUMP, 8.0);
        this->m_nSwimAnim = ANIM_SWIM_JUMP;
        pPed->m_vecMoveSpeed.z = 8.0 / pPed->m_fMass;
        v50 = CTaskSimpleClimb::TestForClimb(
                pPed,
                &this->m_vecEdge,
                &this->m_fEdgeHeading,
                &this->m_nEdgeSurfaceType,
                1);
        this->m_pClimbEnt = v50;
        if ( v50 )
          CEntity::RegisterReference(v50, &this->m_pClimbEnt);
      }
LABEL_99:
      m_pPlayerData = pPed->m_pPlayerData;
      if ( !m_pPlayerData )
        return;
      m_nSwimState = (unsigned __int16)this->m_nSwimState;
      if ( m_pPlayerData->m_moveBlendRatio <= 0.5 )
      {
        if ( m_nSwimState != 4 )
          return;
        m_nSwimState = 4;
      }
      CStats::UpdateStatsWhenSwimming(m_nSwimState == 4, m_nSwimState == 2);
      return;
    default:
      goto LABEL_99;
  }
}
// 53B67E: variable 'v3' is possibly undefined
// 53B67E: variable 'v2' is possibly undefined
// 53B974: variable 'v4' is possibly undefined
// 53B3F0: using guessed type float pWaterZ[5];

//----- (0053BA28) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::ProcessSwimmingResistance(CTaskSimpleSwim *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  float32x2_t v6; // d4
  float32x2_t v7; // d8
  float32x2_t v10; // d9
  CAnimBlendAssociation *Association; // r6
  CAnimBlendAssociation *v12; // r0
  float v13; // s0
  float m_fBlendAmount; // s6
  CMatrix **p_m_pMat; // r4
  CMatrix *m_pMat; // t1
  float v17; // s4
  float x; // s5
  float v19; // s10
  float v20; // s8
  float v21; // s12
  float v22; // s14
  float v23; // s8
  float v24; // s18
  CMatrix *v25; // r0
  float zx; // s22
  float v27; // s20
  float zy; // s24
  float v29; // s26
  float y; // s28
  float v31; // s2
  float v32; // s23
  float v33; // s25
  CAnimBlendAssociation *v34; // r0
  CMatrix *v35; // r6
  float m_fDiveAngle; // r9
  float v37; // s20
  float v38; // s30
  float xx; // s22
  float yx; // s24
  float v41; // s26
  float xy; // s28
  float v43; // s21
  float v44; // s6
  CAnimBlendAssociation *v45; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r2
  float v48; // s0
  float v49; // s2
  float v50; // s4
  float v51; // s6
  float m_fDiveSurfaceSpeed; // s22
  CSimpleTransform *v53; // r1
  float v54; // s26
  float z; // s28
  float v56; // s20
  float v57; // s2
  float v58; // s4
  float v59; // s2
  float v60; // s0
  float v61; // s0
  float v62; // s2
  CSimpleTransform *v63; // r1
  float32x2_t v64; // d16
  float v65; // s0
  float32x2_t v66; // d2
  CTaskSimpleSwim *v67; // [sp+8h] [bp-68h]
  float pWaterZ[25]; // [sp+Ch] [bp-64h] BYREF
  CVector v69; // 0:r1.12

  v7.n64_u32[0] = 981668463;
  v2.n64_f32[0] = CTimer::ms_fTimeStep;
  v10.n64_u64[0] = vmax_f32(v2, v7).n64_u64[0];
  switch ( this->m_nSwimState )
  {
    case 0:
    case 1:
    case 2:
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x137u);
      v12 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x138u);
      if ( Association )
      {
        v4.n64_u32[0] = LODWORD(Association->m_fBlendAmount);
        v13 = v4.n64_f32[0] * 0.4;
        v3.n64_f32[0] = 1.0 - v4.n64_f32[0];
      }
      else
      {
        v3.n64_u32[0] = 1.0;
        v13 = 0.0;
      }
      v67 = this;
      if ( v12 )
      {
        m_fBlendAmount = v12->m_fBlendAmount;
        v4.n64_f32[0] = m_fBlendAmount * 0.2;
        v3.n64_f32[0] = v3.n64_f32[0] - m_fBlendAmount;
      }
      if ( v12 )
        v13 = v13 + v4.n64_f32[0];
      m_pMat = pPed->m_pMat;
      p_m_pMat = &pPed->m_pMat;
      v17 = 1.0 / v10.n64_f32[0];
      v10.n64_u32[0] = 0;
      x = pPed->m_extractedVelocity.x;
      v3.n64_u64[0] = vmax_f32(v3, v10).n64_u64[0];
      v19 = x * m_pMat->zx;
      v5.n64_u32[1] = LODWORD(pPed->m_extractedVelocity.y);
      v20 = x * m_pMat->yx;
      v5.n64_f32[0] = x * m_pMat->xx;
      v4.n64_u32[1] = 1057803469;
      v2.n64_f32[1] = v17 * (float)(v5.n64_f32[1] * m_pMat->zy);
      v21 = v17 * (float)(v5.n64_f32[1] * m_pMat->xy);
      v22 = v17 * (float)(v5.n64_f32[1] * m_pMat->yy);
      v23 = (float)(v17 * v20) + 0.0;
      v5.n64_f32[0] = (float)(v17 * v5.n64_f32[0]) + 0.0;
      v24 = v13 + (float)(v3.n64_f32[0] * 0.55);
      v4.n64_f32[0] = (float)((float)(v17 * v19) + 0.0) + v2.n64_f32[1];
      v3.n64_f32[0] = v23 + v22;
      v2.n64_f32[0] = v5.n64_f32[0] + v21;
      goto LABEL_21;
    case 3:
      v67 = this;
      p_m_pMat = &pPed->m_pMat;
      v25 = pPed->m_pMat;
      zx = v25->zx;
      v27 = 1.0 / v10.n64_f32[0];
      zy = v25->zy;
      v29 = pPed->m_extractedVelocity.x;
      y = pPed->m_extractedVelocity.y;
      v31 = (float)(1.0 / v10.n64_f32[0]) * (float)(v29 * v25->yx);
      v10.n64_f32[1] = (float)(1.0 / v10.n64_f32[0]) * (float)(y * v25->yy);
      v32 = (float)(1.0 / v10.n64_f32[0]) * (float)(y * v25->xy);
      v33 = (float)((float)(1.0 / v10.n64_f32[0]) * (float)(v29 * v25->xx)) + 0.0;
      v34 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x139u);
      v10.n64_u32[0] = -1.0;
      v3.n64_f32[0] = (float)(v31 + 0.0) + v10.n64_f32[1];
      v2.n64_f32[0] = v33 + v32;
      if ( v34 )
        v4.n64_f32[0] = (float)(v34->m_fCurrentTime * -0.1) / v34->m_pAnimBlendHierarchy->m_fTotalTime;
      else
        v4.n64_f32[0] = (float)((float)(v27 * (float)(v29 * zx)) + 0.0) + (float)(v27 * (float)(y * zy));
      goto LABEL_21;
    case 4:
      p_m_pMat = &pPed->m_pMat;
      v35 = pPed->m_pMat;
      v67 = this;
      m_fDiveAngle = this->m_fDiveAngle;
      v37 = 1.0 / v10.n64_f32[0];
      v38 = cosf(m_fDiveAngle);
      xx = v35->xx;
      yx = v35->yx;
      v41 = v35->zx;
      xy = v35->xy;
      v43 = v35->zy;
      v2.n64_u32[1] = 0;
      v2.n64_f32[0] = (float)(pPed->m_extractedVelocity.y * sinf(m_fDiveAngle)) / v10.n64_f32[0];
      v24 = -1.0;
      v44 = (float)((float)((float)(v37 * (float)(pPed->m_extractedVelocity.x * v41)) + 0.0)
                  + (float)(v37 * (float)((float)(v38 * v43) * pPed->m_extractedVelocity.y)))
          + v2.n64_f32[0];
      v2.n64_f32[0] = (float)((float)(v37 * (float)(pPed->m_extractedVelocity.x * xx)) + 0.0)
                    + (float)(v37 * (float)((float)(v38 * xy) * pPed->m_extractedVelocity.y));
      v3.n64_f32[0] = (float)((float)(v37 * (float)(pPed->m_extractedVelocity.x * yx)) + 0.0)
                    + (float)(v37 * (float)((float)(v38 * v35->yy) * pPed->m_extractedVelocity.y));
      v4.n64_f32[0] = v44 + 0.0075;
      goto LABEL_21;
    case 5:
      v45 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x80u);
      if ( (v45 || (v45 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x13Cu)) != 0)
        && v45->m_fCurrentTime < v45->m_pAnimBlendHierarchy->m_fTotalTime
        && (v45->m_fBlendAmount >= 1.0 || v45->m_fBlendDelta > 0.0) )
      {
        v69.x = 0.0;
        v69.y = 0.0;
        v69.z = (float)(pPed->m_fMass * 0.0024) * CTimer::ms_fTimeStep;
        sub_1932F0(pPed, v69);
      }
      return;
    default:
      v2.n64_u32[0] = 0;
      v24 = -1.0;
      v67 = this;
      p_m_pMat = &pPed->m_pMat;
      v3.n64_u32[0] = 0;
      v4.n64_u32[0] = 0;
LABEL_21:
      p_m_transform = &pPed->m_transform;
      LODWORD(pPed->m_vecMoveSpeed.x) = v2.n64_u32[0];
      LODWORD(pPed->m_vecMoveSpeed.y) = v3.n64_u32[0];
      LODWORD(pPed->m_vecMoveSpeed.z) = v4.n64_u32[0];
      p_tx = &pPed->m_transform;
      v48 = CTimer::ms_fTimeStep * v2.n64_f32[0];
      v49 = CTimer::ms_fTimeStep * v3.n64_f32[0];
      if ( *p_m_pMat )
        p_tx = (CSimpleTransform *)&(*p_m_pMat)->tx;
      v50 = p_tx->m_translate.x;
      v51 = p_tx->m_translate.y;
      pWaterZ[0] = 0.0;
      if ( CWaterLevel::GetWaterLevel(v48 + v50, v49 + v51, p_tx->m_translate.z, pWaterZ, 1, 0) == 1 )
      {
        if ( v67->m_nSwimState == 4 )
        {
          m_fDiveSurfaceSpeed = v67->m_fDiveSurfaceSpeed;
          if ( m_fDiveSurfaceSpeed >= 0.0 )
          {
            v53 = &pPed->m_transform;
            if ( *p_m_pMat )
              v53 = (CSimpleTransform *)&(*p_m_pMat)->tx;
            v54 = pWaterZ[0];
            z = v53->m_translate.z;
            v56 = v67->m_fDiveAngle;
            if ( pWaterZ[0] >= (float)(z + 0.65) || v56 <= 0.7854 )
            {
              if ( v56 >= 0.0 )
              {
                if ( pWaterZ[0] >= (float)(z + 0.65) )
                {
                  v62 = 0.0;
                  if ( m_fDiveSurfaceSpeed > 0.001 )
                    v62 = m_fDiveSurfaceSpeed * 0.95;
                  v67->m_fDiveSurfaceSpeed = v62;
                }
                else
                {
                  v2.n64_u32[0] = 1020054733;
                  if ( m_fDiveSurfaceSpeed > 0.025 )
                  {
                    m_fDiveSurfaceSpeed = m_fDiveSurfaceSpeed * 0.95;
                    v67->m_fDiveSurfaceSpeed = m_fDiveSurfaceSpeed;
                  }
                  v59 = CTimer::ms_fTimeStep;
                  if ( m_fDiveSurfaceSpeed < 0.025 )
                  {
                    v4.n64_f32[0] = m_fDiveSurfaceSpeed + (float)(CTimer::ms_fTimeStep * 0.002);
                    LODWORD(m_fDiveSurfaceSpeed) = vmin_f32(v4, v2).n64_u32[0];
                    v67->m_fDiveSurfaceSpeed = m_fDiveSurfaceSpeed;
                  }
                  v60 = v56 + (float)(m_fDiveSurfaceSpeed * v59);
                  v67->m_fDiveAngle = v60;
                  v24 = (float)((float)((float)(v60 / 0.7854) * 0.75) * 0.35) + 0.2;
                }
              }
              else
              {
                if ( v54 >= (float)((float)(z - sinf(v67->m_fDiveAngle)) + 0.65) )
                {
                  v61 = 0.0;
                  if ( m_fDiveSurfaceSpeed > 0.001 )
                    v61 = m_fDiveSurfaceSpeed * 0.95;
                  v57 = CTimer::ms_fTimeStep;
                  v58 = v61;
                }
                else
                {
                  v57 = CTimer::ms_fTimeStep;
                  v58 = m_fDiveSurfaceSpeed + (float)(CTimer::ms_fTimeStep * 0.002);
                  if ( v58 > 0.05 )
                    v58 = 0.05;
                }
                v67->m_fDiveSurfaceSpeed = v58;
                v67->m_fDiveAngle = v56 + (float)(v58 * v57);
              }
            }
            else
            {
              v67->m_fDiveSurfaceSpeed = 0.0;
              v67->m_nSwimState = 0;
            }
          }
        }
        if ( v24 > 0.0 )
        {
          v63 = &pPed->m_transform;
          if ( *p_m_pMat )
            v63 = (CSimpleTransform *)&(*p_m_pMat)->tx;
          v6.n64_f32[0] = CTimer::ms_fTimeStep * 0.1;
          v5.n64_f32[0] = CTimer::ms_fTimeStep * -0.1;
          v4.n64_f32[0] = (float)(pWaterZ[0] - (float)(v24 + v63->m_translate.z)) / CTimer::ms_fTimeStep;
          v64.n64_u64[0] = vmin_f32(v6, v4).n64_u64[0];
          pWaterZ[0] = pWaterZ[0] - (float)(v24 + v63->m_translate.z);
          v65 = pPed->m_vecMoveSpeed.z;
          v6.n64_f32[0] = CTimer::ms_fTimeStep * 0.02;
          v66.n64_u64[0] = vmax_f32(v5, v64).n64_u64[0];
          v3.n64_f32[0] = CTimer::ms_fTimeStep * -0.02;
          v66.n64_f32[0] = v66.n64_f32[0] - v65;
          v3.n64_u64[0] = vmax_f32(v3, vmin_f32(v6, v66)).n64_u64[0];
          pPed->m_vecMoveSpeed.z = v65 + v3.n64_f32[0];
        }
      }
      if ( *p_m_pMat )
        p_m_transform = (CSimpleTransform *)&(*p_m_pMat)->tx;
      if ( p_m_transform->m_translate.z < -69.0 )
      {
        v2.n64_u32[0] = 0;
        p_m_transform->m_translate.z = -69.0;
        v3.n64_u32[0] = LODWORD(pPed->m_vecMoveSpeed.z);
        LODWORD(pPed->m_vecMoveSpeed.z) = vmax_f32(v3, v2).n64_u32[0];
      }
      return;
  }
}
// 53BA56: variable 'v2' is possibly undefined
// 53BA56: variable 'v7' is possibly undefined
// 53BABE: variable 'v4' is possibly undefined
// 53BAF6: variable 'v3' is possibly undefined
// 53BFA8: variable 'v6' is possibly undefined
// 53BFB8: variable 'v5' is possibly undefined
// 53BA28: using guessed type float pWaterZ[25];

//----- (0053C078) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::ProcessEffects(CTaskSimpleSwim *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r8
  CSimpleTransform *p_tx; // r5
  float xy; // s4
  float yy; // s2
  float zy; // s0
  float m_heading; // r6
  float v11; // r4
  float v12; // s16
  float v13; // s0
  float v14; // s18
  CPlayerPedData *m_pPlayerData; // r0
  float m_waterHeight; // r4
  FxSystem_c *m_pFxSys; // r0
  RwMatrix *v18; // r6
  FxSystem_c *v19; // r0
  int m_nSwimState; // r0
  float AngleBetweenPoints; // r0
  float v22; // r4
  FxPrtMult_c *v23; // r0
  RpHAnimHierarchy_0 *v24; // r6
  RwMatrix *v25; // r9
  RwInt32 v26; // r10
  RwMatrix *v27; // r4
  RwMatrix *v28; // r6
  CMatrix *v29; // r0
  RwV3d_0 *p_right; // r4
  float z; // s16
  RwV3d_0 *v32; // r0
  FxSystem_c *v33; // r0
  RwV3d_0 *v34; // r5
  FxSystem_c *v35; // r0
  RwV3d_0 *v36; // r4
  FxSystem_c *v37; // r0
  FxSystem_c *v38; // r0
  float m_fBreath; // s16
  int v40; // r4
  FxSystem_c *FxSystem; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  RwMatrix *MatrixArray; // r0
  __int64 v44; // d16
  RwInt32 v45; // [sp+14h] [bp-7Ch]
  RwMatrix *v46; // [sp+18h] [bp-78h]
  RwInt32 v47; // [sp+1Ch] [bp-74h]
  RwInt32 v48; // [sp+20h] [bp-70h]
  RwV3d_0 vel; // [sp+24h] [bp-6Ch] BYREF
  FxPrtMult_c pos; // [sp+30h] [bp-60h] BYREF
  RwV3d_0 v51; // [sp+50h] [bp-40h] BYREF

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
  {
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
  }
  else
  {
    m_heading = pPed->m_transform.m_heading;
    v11 = sinf(m_heading);
    yy = cosf(m_heading);
    zy = 0.0;
    LODWORD(xy) = LODWORD(v11) ^ 0x80000000;
  }
  v12 = (float)(yy * 0.4) + p_tx->m_translate.y;
  v13 = (float)(zy * 0.4) + p_tx->m_translate.z;
  v14 = p_tx->m_translate.x + (float)(xy * 0.4);
  v51.y = v12;
  v51.x = v14;
  v51.z = v13;
  m_pPlayerData = pPed->m_pPlayerData;
  if ( m_pPlayerData )
  {
    m_waterHeight = m_pPlayerData->m_waterHeight;
    v51.z = m_waterHeight;
  }
  else
  {
    m_waterHeight = v13 + 0.5;
    v51.z = v13 + 0.5;
  }
  if ( this->m_nSwimState )
  {
    m_pFxSys = this->m_pFxSys;
    if ( m_pFxSys )
    {
      FxSystem_c::Kill(m_pFxSys);
      this->m_pFxSys = 0;
    }
  }
  else
  {
    v18 = RwMatrixCreate();
    v18->pos.z = m_waterHeight;
    v18->pos.x = v14;
    v18->pos.y = v12;
    RwMatrixUpdate(v18);
    v19 = this->m_pFxSys;
    if ( v19
      || (memset(&pos, 0, 12),
          FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, "water_ripples", (RwV3d_0 *)&pos, v18, 0),
          (this->m_pFxSys = FxSystem) != 0)
      && (FxSystem_c::CopyParentMatrix(FxSystem), FxSystem_c::Play(this->m_pFxSys), (v19 = this->m_pFxSys) != 0) )
    {
      FxSystem_c::SetMatrix(v19, v18);
      FxSystem_c::SetLocalParticles(this->m_pFxSys, 1u);
    }
    RwMatrixDestroy(v18);
  }
  m_nSwimState = (unsigned __int16)this->m_nSwimState;
  if ( m_nSwimState == 3 )
  {
    if ( !this->m_playedDiveSplash )
    {
      pos.m_blue = v51.z;
      *(_QWORD *)&pos.m_red = *(_QWORD *)&v51.x;
      Fx_c::TriggerWaterSplash(&g_fx, (CVector *)&pos);
      this->m_playedDiveSplash = 1;
      CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 75, 0.0, 1.0, 0, 0, 0, 0);
    }
  }
  else
  {
    this->m_playedDiveSplash = 0;
    if ( (unsigned int)(m_nSwimState - 1) >= 2 )
    {
      if ( m_nSwimState == 4 && CTimer::m_snTimeInMilliseconds - this->m_nLastParticleTime >= 0x65 )
      {
        this->m_nLastParticleTime = CTimer::m_snTimeInMilliseconds;
        if ( CPed::IsPlayer(pPed) )
        {
          m_fBreath = pPed->m_pPlayerData->m_fBreath;
          v40 = (int)(float)((float)(100.0
                                   - (float)((float)(m_fBreath
                                                   / CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BREATH_UNDERWATER))
                                           * 100.0))
                           / 3.0);
        }
        else
        {
          v40 = 5;
        }
        if ( v40 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) )
        {
          AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
          MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
          v44 = *(_QWORD *)&MatrixArray[3].pos.x;
          pos.m_blue = MatrixArray[3].pos.z;
          *(_QWORD *)&pos.m_red = v44;
          LOBYTE(MatrixArray) = `guard variable for'CTaskSimpleSwim::ProcessEffects(CPed *)::fxMults;
          __dmb(0xBu);
          if ( ((unsigned __int8)MatrixArray & 1) == 0
            && _cxa_guard_acquire((__guard *)&`guard variable for'CTaskSimpleSwim::ProcessEffects(CPed *)::fxMults) )
          {
            FxPrtMult_c::FxPrtMult_c(
              &CTaskSimpleSwim::ProcessEffects(CPed *)::fxMults,
              1.0,
              1.0,
              1.0,
              0.25,
              0.3,
              0.0,
              0.5);
            _cxa_guard_release((__guard *)&`guard variable for'CTaskSimpleSwim::ProcessEffects(CPed *)::fxMults);
          }
          vel.x = 0.0;
          vel.y = 0.0;
          vel.z = 2.0;
          FxSystem_c::AddParticle(
            g_fx.m_fxSysBubble,
            (RwV3d_0 *)&pos,
            &vel,
            0.0,
            &CTaskSimpleSwim::ProcessEffects(CPed *)::fxMults,
            -1.0,
            1.2,
            0.6,
            0);
        }
      }
    }
    else
    {
      if ( CTimer::m_snTimeInMilliseconds - this->m_nLastParticleTime >= 0x65 )
      {
        this->m_nLastParticleTime = CTimer::m_snTimeInMilliseconds;
        AngleBetweenPoints = CGeneral::GetAngleBetweenPoints(pPed->m_pMat->xy, pPed->m_pMat->yy, 0.0, 0.0);
        v22 = CGeneral::LimitAngle(AngleBetweenPoints);
        FxPrtMult_c::FxPrtMult_c(&pos, 1.0, 1.0, 1.0, 0.2, 0.4, 0.0, 0.5);
        memset(&vel, 0, sizeof(vel));
        FxSystem_c::AddParticle(g_fx.m_fxSysWake, &v51, &vel, 0.0, v23, v22 + 180.0, 1.2, 0.6, 0);
      }
      CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 76, 0.0, 1.0, 0, 0, 0, 0);
      if ( this->m_nSwimState == 2 )
      {
        v24 = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
        v45 = RpHAnimIDGetIndex(v24, 24);
        v25 = RpHAnimHierarchyGetMatrixArray(v24);
        v26 = RpHAnimIDGetIndex(v24, 34);
        v27 = RpHAnimHierarchyGetMatrixArray(v24);
        v47 = RpHAnimIDGetIndex(v24, 53);
        v46 = RpHAnimHierarchyGetMatrixArray(v24);
        v48 = RpHAnimIDGetIndex(v24, 43);
        v28 = RpHAnimHierarchyGetMatrixArray(v24);
        v29 = pPed->m_pMat;
        p_right = &v27[v26].right;
        if ( v29 )
          p_m_transform = (CSimpleTransform *)&v29->tx;
        z = p_m_transform->m_translate.z;
        v32 = &v25[v45].right;
        if ( fabsf(v32[4].z - z) < 0.05 )
        {
          v33 = FxManager_c::CreateFxSystem(&g_fxMan, "water_swim", v32 + 4, 0, 0);
          if ( v33 )
          {
            FxSystem_c::PlayAndKill(v33);
            CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 74, 0.0, 1.0, 0, 0, 0, 0);
          }
        }
        v34 = &v46[v47].right;
        if ( fabsf(p_right[4].z - z) < 0.05 )
        {
          v35 = FxManager_c::CreateFxSystem(&g_fxMan, "water_swim", p_right + 4, 0, 0);
          if ( v35 )
          {
            FxSystem_c::PlayAndKill(v35);
            CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 74, 0.0, 1.0, 0, 0, 0, 0);
          }
        }
        v36 = &v28[v48].right;
        if ( fabsf(v34[4].z - z) < 0.05 )
        {
          v37 = FxManager_c::CreateFxSystem(&g_fxMan, "water_swim", v34 + 4, 0, 0);
          if ( v37 )
          {
            FxSystem_c::PlayAndKill(v37);
            CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 74, 0.0, 1.0, 0, 0, 0, 0);
          }
        }
        if ( fabsf(v36[4].z - z) < 0.05 )
        {
          v38 = FxManager_c::CreateFxSystem(&g_fxMan, "water_swim", v36 + 4, 0, 0);
          if ( v38 )
          {
            FxSystem_c::PlayAndKill(v38);
            CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 74, 0.0, 1.0, 0, 0, 0, 0);
          }
        }
      }
    }
  }
}
// 53C268: variable 'v23' is possibly undefined
// 9FF888: using guessed type char `guard variable for'CTaskSimpleSwim::ProcessEffects(CPed *)::fxMults;

//----- (0053C614) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::ApplyRollAndPitch(CTaskSimpleSwim *this, CPed *pPed)
{
  __int64 v4; // r0
  RwObject_0 *m_pRwObject; // r0
  RwMatrix *v6; // r1
  CMatrix v7; // [sp+0h] [bp-F0h] BYREF
  CMatrix v8; // [sp+48h] [bp-A8h] BYREF
  LimbOrientation torso; // [sp+90h] [bp-60h] BYREF
  CMatrix v10; // [sp+98h] [bp-58h] BYREF

  v4 = *(_QWORD *)&this->m_fPitchTorso;
  torso.yaw = *((float *)&v4 + 1);
  LODWORD(torso.pitch) = v4;
  CPedIK::RotateTorso(&pPed->m_ik, pPed->m_aPedFrames[1], &torso, 0);
  m_pRwObject = pPed->m_pRwObject;
  if ( m_pRwObject )
    v6 = (RwMatrix *)((char *)m_pRwObject->parent + 16);
  else
    v6 = 0;
  CMatrix::CMatrix(&v8, v6, 0);
  v7.m_pRwMat = 0;
  v7.m_owner = 0;
  CMatrix::SetTranslate(&v7, 0.0, 0.0, 0.0);
  CMatrix::RotateY(&v7, this->m_fRollAngle);
  CMatrix::RotateX(&v7, this->m_fDiveAngle);
  operator*(&v10, &v8, &v7);
  CMatrix::operator=(&v8, &v10);
  CMatrix::~CMatrix(&v10);
  CMatrix::UpdateRW(&v8);
  CEntity::UpdateRwFrame(pPed);
  CMatrix::~CMatrix(&v7);
  CMatrix::~CMatrix(&v8);
}

//----- (0053C6B4) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::CreateFxSystem(CTaskSimpleSwim *this, CPed *pPed, RwMatrix *pMat)
{
  FxSystem_c *v4; // r0
  RwV3d_0 offsetPos; // [sp+4h] [bp-14h] BYREF

  memset(&offsetPos, 0, sizeof(offsetPos));
  v4 = FxManager_c::CreateFxSystem(&g_fxMan, "water_ripples", &offsetPos, pMat, 0);
  this->m_pFxSys = v4;
  if ( v4 )
  {
    FxSystem_c::CopyParentMatrix(v4);
    FxSystem_c::Play(this->m_pFxSys);
  }
}

//----- (0053C6F4) --------------------------------------------------------
CTask *__fastcall CTaskSimplePlayerOnFoot::Clone(const CTaskSimplePlayerOnFoot *this)
{
  CTaskSimple *v1; // r4
  int32 AnimationBlockIndex; // r0
  UInt32 v3; // r1
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x34u);
  CTaskSimple::CTaskSimple(v1);
  v1->_vptr$CTask = (int (**)(void))&off_66CF28;
  AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("playidles");
  v3 = CTimer::m_FrameCounter;
  v1[4]._vptr$CTask = (int (**)(void))AnimationBlockIndex;
  v1[4].m_pParent = (CTask *)v3;
  v1[5]._vptr$CTask = 0;
  result = v1;
  v1[5].m_pParent = 0;
  v1[6]._vptr$CTask = 0;
  return result;
}
// 66CF28: using guessed type void *off_66CF28;

//----- (0053C73C) --------------------------------------------------------
int __fastcall CTaskSimplePlayerOnFoot::GetTaskType(const CTaskSimplePlayerOnFoot *this)
{
  return 0;
}

//----- (0053C740) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFoot::Serialize(CTaskSimplePlayerOnFoot *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimplePlayerOnFoot *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimplePlayerOnFoot *))this->_vptr$CTask + 5))(this) )
  {
    v4 = (*((int (__fastcall **)(CTaskSimplePlayerOnFoot *))this->_vptr$CTask + 5))(this);
    sub_1941C4(0, v4);
  }
}

//----- (0053C7B0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSwim::Clone(const CTaskSimpleSwim *this)
{
  char *v2; // r4
  CPed *m_pTargetPed; // r8
  __int64 v4; // d16
  CTask *result; // r0

  v2 = (char *)CTask::operator new(0x68u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_QWORD *)v2 + 2) = 3212836864LL;
  *((_QWORD *)v2 + 3) = 0LL;
  *((_QWORD *)v2 + 6) = 0LL;
  *((_QWORD *)v2 + 7) = 0LL;
  *(_QWORD *)(v2 + 36) = 0LL;
  *(_QWORD *)(v2 + 44) = 0LL;
  *((_DWORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 23) = 0;
  *((_DWORD *)v2 + 2) = 0;
  *((_DWORD *)v2 + 3) = 191;
  *(_DWORD *)v2 = &off_66CF5C;
  *((_DWORD *)v2 + 8) = m_pTargetPed;
  v4 = *(_QWORD *)&this->m_vecTargetPos.x;
  *((_DWORD *)v2 + 7) = LODWORD(this->m_vecTargetPos.z);
  *(_QWORD *)(v2 + 20) = v4;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 8);
  v2[100] = 0;
  result = (CTask *)v2;
  *((_DWORD *)v2 + 24) = 0;
  *((_DWORD *)v2 + 21) = 0;
  return result;
}
// 66CF5C: using guessed type void *off_66CF5C;

//----- (0053C854) --------------------------------------------------------
int __fastcall CTaskSimpleSwim::GetTaskType(const CTaskSimpleSwim *this)
{
  return 1304;
}

//----- (0053C85C) --------------------------------------------------------
void __fastcall CTaskSimpleSwim::Serialize(CTaskSimpleSwim *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pTargetPed; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  __int64 v11; // d16

  v2 = (*((int (__fastcall **)(CTaskSimpleSwim *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleSwim *))this->_vptr$CTask + 5))(this) == 1304 )
  {
    m_pTargetPed = this->m_pTargetPed;
    if ( m_pTargetPed )
    {
      v5 = GettPoolPedRef(m_pTargetPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(0xCu);
    v11 = *(_QWORD *)&this->m_vecTargetPos.x;
    v10[2] = LODWORD(this->m_vecTargetPos.z);
    *(_QWORD *)v10 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 12);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleSwim *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1304, v8);
  }
}

//----- (0053C968) --------------------------------------------------------
void __fastcall CTaskSimpleArrestPed::CTaskSimpleArrestPed(CTaskSimpleArrestPed *this, CPed *pArrestedPed)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CF90;
  this->m_pArrestedPed = pArrestedPed;
  if ( pArrestedPed )
    CEntity::RegisterReference(pArrestedPed, &this->m_pArrestedPed);
}
// 66CF90: using guessed type void *;

//----- (0053C9A0) --------------------------------------------------------
void __fastcall CTaskSimpleArrestPed::~CTaskSimpleArrestPed(CTaskSimpleArrestPed *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CPed *m_pArrestedPed; // r0
  CPed **p_m_pArrestedPed; // r5
  CAnimBlendAssociation *v5; // r0
  bool v6; // zf
  CPed *v7; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66CF90;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  p_m_pArrestedPed = &this->m_pArrestedPed;
  m_pArrestedPed = this->m_pArrestedPed;
  if ( m_pArrestedPed )
    CEntity::CleanUpOldReference(m_pArrestedPed, &this->m_pArrestedPed);
  v5 = this->m_pAnim;
  v6 = v5 == 0;
  if ( v5 )
  {
    v5 = (CAnimBlendAssociation *)*p_m_pArrestedPed;
    v6 = *p_m_pArrestedPed == 0;
  }
  if ( !v6 && !CPed::IsPlayer((const CPed *)v5) )
  {
    v7 = *p_m_pArrestedPed;
    if ( *((unsigned __int8 *)&(*p_m_pArrestedPed)->m_nPedFlags + 1) << 31 )
    {
      if ( v7->m_nPedState == PED_ARRESTED )
        CPed::SetPedState(v7, PED_DRIVING);
    }
  }
  sub_1A01F4(this);
}
// 66CF90: using guessed type void *off_66CF90;

//----- (0053CA0C) --------------------------------------------------------
void __fastcall CTaskSimpleArrestPed::~CTaskSimpleArrestPed(CTaskSimpleArrestPed *this)
{
  void *v1; // r0

  CTaskSimpleArrestPed::~CTaskSimpleArrestPed(this);
  sub_197118(v1);
}
// 53CA18: variable 'v1' is possibly undefined

//----- (0053CA1C) --------------------------------------------------------
bool __fastcall CTaskSimpleArrestPed::MakeAbortable(
        CTaskSimpleArrestPed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0
  bool v8; // zf
  CPed *m_pArrestedPed; // r0
  ePedState v10; // r1

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      result = 1;
      this->m_pAnim = 0;
      return result;
    }
    return 1;
  }
  if ( pEvent && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
  {
    v8 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
    if ( LOBYTE(pEvent[5]._vptr$CEvent) )
      v8 = !*(&pEvent->m_bIsPersistent + 1);
    if ( !v8 )
    {
      m_pArrestedPed = this->m_pArrestedPed;
      if ( *((unsigned __int8 *)&m_pArrestedPed->m_nPedFlags + 1) << 31 )
        v10 = PED_DRIVING;
      else
        v10 = PED_NONE;
      CPed::SetPedState(m_pArrestedPed, v10);
      *((_DWORD *)&this->m_pArrestedPed->m_nPedFlags + 2) &= ~0x40u;
    }
    return 1;
  }
  return 0;
}

//----- (0053CA94) --------------------------------------------------------
void __fastcall CTaskSimpleArrestPed::FinishAnimArrestPedCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_DWORD *)pData + 4) = 0;
  *((_BYTE *)pData + 12) = 1;
}

//----- (0053CAA0) --------------------------------------------------------
void __fastcall CTaskSimpleArrestPed::StartAnim(CTaskSimpleArrestPed *this, CPed *pPed)
{
  CAnimBlendAssociation *v4; // r0
  CPed *m_pArrestedPed; // r0
  CPlayerPedData *m_pPlayerData; // r1
  CEntity **p_m_ArrestingOfficer; // r1
  CCopPed *m_ArrestingOfficer; // t1
  CPed *v9; // r0
  int v10; // r2
  int v11; // r3
  int v12; // r5

  v4 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_ARREST, 4.0);
  this->m_pAnim = v4;
  v4->m_bitsFlag |= 1u;
  CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CTaskSimpleArrestPed::FinishAnimArrestPedCB, this);
  if ( CPed::IsPlayer(this->m_pArrestedPed) )
    CPed::Say(pPed, 0xDu, 0, 1.0, 1, 1, 1);
  if ( CPed::CanSetPedState(this->m_pArrestedPed) )
    CPed::SetPedState(this->m_pArrestedPed, PED_ARRESTED);
  if ( pPed->m_nPedType == 6 )
  {
    m_pArrestedPed = this->m_pArrestedPed;
    if ( m_pArrestedPed->m_nPedType <= 1u )
    {
      m_pPlayerData = m_pArrestedPed->m_pPlayerData;
      m_ArrestingOfficer = m_pPlayerData->m_ArrestingOfficer;
      p_m_ArrestingOfficer = &m_pPlayerData->m_ArrestingOfficer;
      if ( !m_ArrestingOfficer )
      {
        *p_m_ArrestingOfficer = pPed;
        CEntity::RegisterReference(pPed, p_m_ArrestingOfficer);
      }
    }
  }
  v9 = this->m_pArrestedPed;
  v10 = *((_DWORD *)&v9->m_nPedFlags + 1);
  v11 = *((_DWORD *)&v9->m_nPedFlags + 2) | 0x40;
  v12 = *((_DWORD *)&v9->m_nPedFlags + 3);
  *(_DWORD *)&v9->m_nPedFlags = v9->m_nPedFlags;
  *((_DWORD *)&v9->m_nPedFlags + 1) = v10;
  *((_DWORD *)&v9->m_nPedFlags + 2) = v11;
  *((_DWORD *)&v9->m_nPedFlags + 3) = v12;
  sub_18D8EC(pPed, PED_ARREST_PLAYER);
}

//----- (0053CB60) --------------------------------------------------------
bool __fastcall CTaskSimpleArrestPed::ProcessPed(CTaskSimpleArrestPed *this, CPed *pPed)
{
  float y; // s0
  float x; // s2
  CPed *m_pArrestedPed; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  float RadianAngleBetweenPoints; // r3
  CMatrix *v10; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v14; // r0
  float v15; // s2
  float v16; // s4
  RwV3d_0 posn; // [sp+4h] [bp-2Ch] BYREF

  if ( !this->m_bIsFinished )
  {
    if ( this->m_pAnim )
    {
      m_pArrestedPed = this->m_pArrestedPed;
      if ( m_pArrestedPed )
      {
        CPed::GetBonePosition(m_pArrestedPed, &posn, 3u, 0);
        x = posn.x;
        y = posn.y;
      }
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(x, y, p_tx->m_translate.x, p_tx->m_translate.y);
      v10 = pPed->m_pMat;
      pPed->m_fCurrentHeading = RadianAngleBetweenPoints;
      pPed->m_fDesiredHeading = RadianAngleBetweenPoints;
      if ( v10 )
      {
        tx = v10->tx;
        ty = v10->ty;
        tz = v10->tz;
        CMatrix::SetRotate(v10, 0.0, 0.0, RadianAngleBetweenPoints);
        v14 = pPed->m_pMat;
        v15 = ty + v14->ty;
        v16 = tz + v14->tz;
        v14->tx = tx + v14->tx;
        v14->ty = v15;
        v14->tz = v16;
      }
      else
      {
        pPed->m_transform.m_heading = RadianAngleBetweenPoints;
      }
      CPedIK::PointGunAtPosition(&pPed->m_ik, (const CVector *)&posn, this->m_pAnim->m_fBlendAmount);
    }
    else
    {
      if ( CWeapon::IsTypeMelee(&pPed->m_WeaponSlots[pPed->m_nCurrentWeapon]) )
      {
        CPed::GiveWeapon(pPed, WEAPONTYPE_PISTOL, 0xAu, 0);
        CPed::SetCurrentWeapon(pPed, WEAPONTYPE_PISTOL);
      }
      CTaskSimpleArrestPed::StartAnim(this, pPed);
    }
  }
  return 0;
}
// 53CBDE: variable 'x' is possibly undefined
// 53CBDE: variable 'y' is possibly undefined

//----- (0053CC50) --------------------------------------------------------
void __fastcall CTaskComplexArrestPed::CTaskComplexArrestPed(CTaskComplexArrestPed *this, CPed *pTargetPed)
{
  CTaskComplex::CTaskComplex(this);
  this->m_pVehicleAttemptedWithLockedDoor = 0;
  this->_vptr$CTask = (int (**)(void))&off_66CFC4;
  this->m_pTargetPed = pTargetPed;
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
}
// 66CFC4: using guessed type void *;

//----- (0053CC84) --------------------------------------------------------
void __fastcall CTaskComplexArrestPed::~CTaskComplexArrestPed(CTaskComplexArrestPed *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66CFC4;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  sub_18EDB4(this);
}
// 66CFC4: using guessed type void *off_66CFC4;

//----- (0053CCB0) --------------------------------------------------------
void __fastcall CTaskComplexArrestPed::~CTaskComplexArrestPed(CTaskComplexArrestPed *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66CFC4;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 53CCD8: variable 'v4' is possibly undefined
// 66CFC4: using guessed type void *off_66CFC4;

//----- (0053CCE0) --------------------------------------------------------
bool __fastcall CTaskComplexArrestPed::MakeAbortable(
        CTaskComplexArrestPed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (0053CCEC) --------------------------------------------------------
CTask *__fastcall CTaskComplexArrestPed::CreateNextSubTask(CTaskComplexArrestPed *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  int v5; // r0
  void *v6; // r6
  bool v7; // zf
  CVehicle *m_pMyVehicle; // r0
  CPed *v9; // r0
  CPed *v10; // r0
  const CTaskComplexFallAndGetUp *v11; // r0
  CTaskComplexFallAndGetUp *v12; // r6
  CPed *v13; // r0
  CMatrix *v14; // r1
  CMatrix *v15; // r2
  CSimpleTransform *v16; // r3
  CSimpleTransform *v17; // r1
  float *p_z; // r3
  float32x2_t v19; // d16
  float32x2_t v20; // d17
  float z; // s2
  int v22; // r1
  CTaskComplexArrestPed *v23; // r0
  int v25; // r5
  CPed *v26; // r4
  float v27; // s0
  char v28; // r1
  const CTaskComplexFallAndGetUp *ActiveTaskByType; // r0
  const CTaskComplexFallAndGetUp *v30; // r0
  CPed *v31; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v33; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v36; // d16
  unsigned __int64 v37; // d0

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    return 0;
  if ( (*((_BYTE *)&m_pTargetPed->m_nPedFlags + 8) & 0x40) != 0
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1100 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 907
      || ((int)this->m_pSubTask[9]._vptr$CTask & 4) == 0 )
    {
      v25 = *((_DWORD *)&this->m_pTargetPed->m_nPedFlags + 2);
      v6 = CTask::operator new(0x4Cu);
      v26 = this->m_pTargetPed;
      CTaskComplex::CTaskComplex((CTaskComplex *)v6);
      v27 = 4.0;
      if ( (v25 & 0x40) == 0 )
        v27 = 3.0;
      *(_DWORD *)v6 = &off_6656D4;
      *((_DWORD *)v6 + 4) = 50000;
      *((_DWORD *)v6 + 5) = 1000;
      *((_DWORD *)v6 + 7) = 0x40000000;
      *((_DWORD *)v6 + 8) = 0;
      *((_DWORD *)v6 + 9) = 0x40000000;
      *((_WORD *)v6 + 24) = 0;
      *((_WORD *)v6 + 30) = 0;
      *((_DWORD *)v6 + 11) = 0;
      *((_DWORD *)v6 + 10) = 0;
      *((_DWORD *)v6 + 13) = 0;
      *((_DWORD *)v6 + 14) = 0;
      v28 = *((_BYTE *)v6 + 72);
      *((_DWORD *)v6 + 16) = &off_665710;
      *((_DWORD *)v6 + 17) = 6;
      *((_BYTE *)v6 + 72) = v28 & 0xF0 | 3;
      *((float *)v6 + 6) = v27;
      *((_DWORD *)v6 + 3) = v26;
      if ( v26 )
        CEntity::RegisterReference(v26, (CEntity **)v6 + 3);
      return (CTask *)v6;
    }
    goto LABEL_32;
  }
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v6 = 0;
  if ( v5 <= 828 )
  {
    if ( v5 != 703 )
    {
      v7 = v5 == 722;
      if ( v5 != 722 )
        v7 = v5 == 728;
      if ( !v7 )
        return (CTask *)v6;
      if ( ((int)this->m_pSubTask[2]._vptr$CTask & 2) != 0 )
      {
        m_pMyVehicle = this->m_pTargetPed->m_pMyVehicle;
        if ( m_pMyVehicle )
        {
          if ( !CVehicle::CanPedOpenLocks(m_pMyVehicle, pPed) )
            this->m_pVehicleAttemptedWithLockedDoor = this->m_pTargetPed->m_pMyVehicle;
        }
      }
      if ( !CPed::IsAlive(this->m_pTargetPed) )
        goto LABEL_32;
      v9 = this->m_pTargetPed;
      if ( *((unsigned __int8 *)&v9->m_nPedFlags + 1) << 31 )
      {
        if ( ((int)this->m_pSubTask[2]._vptr$CTask & 2) == 0
          && !CTaskManager::FindActiveTaskByType(&v9->m_pPedIntelligence->m_taskManager, 704) )
        {
          goto LABEL_32;
        }
      }
      goto LABEL_58;
    }
    ActiveTaskByType = (const CTaskComplexFallAndGetUp *)CTaskManager::FindActiveTaskByType(
                                                           &this->m_pTargetPed->m_pPedIntelligence->m_taskManager,
                                                           208);
    v12 = (CTaskComplexFallAndGetUp *)ActiveTaskByType;
    if ( !ActiveTaskByType
      || !CTaskComplexFallAndGetUp::IsFalling(ActiveTaskByType)
      || ((int)this->m_pSubTask[2]._vptr$CTask & 4) != 0 )
    {
LABEL_58:
      v6 = CTask::operator new(0x38u);
      CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(
        (CTaskComplexKillPedOnFoot *)v6,
        this->m_pTargetPed,
        -1,
        0,
        0,
        0,
        1);
      return (CTask *)v6;
    }
    goto LABEL_45;
  }
  switch ( v5 )
  {
    case 829:
      goto LABEL_58;
    case 907:
      v30 = (const CTaskComplexFallAndGetUp *)CTaskManager::FindActiveTaskByType(
                                                &this->m_pTargetPed->m_pPedIntelligence->m_taskManager,
                                                208);
      v12 = (CTaskComplexFallAndGetUp *)v30;
      if ( !v30 || !CTaskComplexFallAndGetUp::IsFalling(v30) || ((int)this->m_pSubTask[9]._vptr$CTask & 4) == 0 )
        goto LABEL_58;
LABEL_45:
      v31 = this->m_pTargetPed;
      m_pMat = pPed->m_pMat;
      v33 = v31->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      p_m_transform = (CSimpleTransform *)&v33->tx;
      v19.n64_u64[0] = *(unsigned __int64 *)&p_tx->m_translate.x;
      p_z = &p_tx->m_translate.z;
      if ( !v33 )
        p_m_transform = &v31->m_transform;
      v20.n64_u64[0] = *(unsigned __int64 *)&p_m_transform->m_translate.x;
      z = p_m_transform->m_translate.z;
      v22 = 1000;
LABEL_50:
      if ( fabsf(z - *p_z) <= 2.0 )
      {
        v36.n64_u64[0] = vsub_f32(v20, v19).n64_u64[0];
        v37 = vmul_f32(v36, v36).n64_u64[0];
        if ( (float)((float)(*(float *)&v37 + *((float *)&v37 + 1)) + 0.0) <= 9.0 )
        {
          CTaskComplexFallAndGetUp::SetDownTime(v12, (const int)&elf_hash_chain[8526]);
          v22 = 1100;
        }
      }
      v23 = this;
      return CTaskComplexArrestPed::CreateSubTask(v23, v22, pPed);
    case 1000:
      v10 = this->m_pTargetPed;
      if ( v10->m_nHealth > 0.0 )
      {
        v11 = (const CTaskComplexFallAndGetUp *)CTaskManager::FindActiveTaskByType(
                                                  &v10->m_pPedIntelligence->m_taskManager,
                                                  208);
        v12 = (CTaskComplexFallAndGetUp *)v11;
        if ( v11 && CTaskComplexFallAndGetUp::IsFalling(v11) )
        {
          v13 = this->m_pTargetPed;
          v14 = pPed->m_pMat;
          v15 = v13->m_pMat;
          v16 = (CSimpleTransform *)&v14->tx;
          if ( !v14 )
            v16 = &pPed->m_transform;
          v17 = (CSimpleTransform *)&v15->tx;
          v19.n64_u64[0] = *(unsigned __int64 *)&v16->m_translate.x;
          p_z = &v16->m_translate.z;
          if ( !v15 )
            v17 = &v13->m_transform;
          v20.n64_u64[0] = *(unsigned __int64 *)&v17->m_translate.x;
          z = v17->m_translate.z;
          v22 = 907;
          goto LABEL_50;
        }
        if ( pPed->m_nPedType == 6
          || !CPed::IsPlayer(this->m_pTargetPed)
          || !this->m_pTargetPed->m_pPlayerData->m_Wanted->m_nCopsInPursuit )
        {
          goto LABEL_58;
        }
        return 0;
      }
LABEL_32:
      v23 = this;
      v22 = 1100;
      return CTaskComplexArrestPed::CreateSubTask(v23, v22, pPed);
  }
  return (CTask *)v6;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (0053D030) --------------------------------------------------------
CTask *__fastcall CTaskComplexArrestPed::CreateSubTask(CTaskComplexArrestPed *this, int iSubTaskType, CPed *pPed)
{
  char *v4; // r4
  CPed *m_pTargetPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v7; // r3
  CSimpleTransform *p_tx; // r6
  float *p_x; // r1
  RwReal v10; // s0
  RwReal v11; // s4
  CPed *v12; // r1
  const CVehicle *m_pMyVehicle; // r0
  CVehicle *v14; // r0
  int v15; // r2
  CPed *v16; // r5
  CEntity **v17; // r1
  int v18; // r6
  float v19; // s0
  char v20; // r1
  CVector vDir; // [sp+Ch] [bp-1Ch] BYREF

  v4 = 0;
  if ( iSubTaskType <= 906 )
  {
    if ( iSubTaskType >= 728 )
    {
      if ( iSubTaskType == 728 )
      {
        v4 = (char *)CTask::operator new(0x50u);
        CTaskComplexOpenPassengerDoor::CTaskComplexOpenPassengerDoor(
          (CTaskComplexOpenPassengerDoor *)v4,
          this->m_pTargetPed->m_pMyVehicle,
          8);
      }
      else if ( iSubTaskType == 829 )
      {
        m_pTargetPed = this->m_pTargetPed;
        m_pMat = pPed->m_pMat;
        v7 = m_pTargetPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_x = &v7->tx;
        if ( !v7 )
          p_x = &m_pTargetPed->m_transform.m_translate.x;
        v10 = *p_x - p_tx->m_translate.x;
        v11 = p_x[2] - p_tx->m_translate.z;
        vDir.y = p_x[1] - p_tx->m_translate.y;
        vDir.x = v10;
        vDir.z = v11;
        v4 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleWaitUntilPedIsOutCar::CTaskSimpleWaitUntilPedIsOutCar(
          (CTaskSimpleWaitUntilPedIsOutCar *)v4,
          this->m_pTargetPed,
          &vDir);
      }
    }
    else if ( iSubTaskType == 703 )
    {
      v4 = (char *)CTask::operator new(0x54u);
      CTaskComplexDragPedFromCar::CTaskComplexDragPedFromCar(
        (CTaskComplexDragPedFromCar *)v4,
        this->m_pTargetPed,
        (const int)&elf_hash_chain[8526]);
    }
    else if ( iSubTaskType == 722 )
    {
      v4 = (char *)CTask::operator new(0x50u);
      CTaskComplexOpenDriverDoor::CTaskComplexOpenDriverDoor(
        (CTaskComplexOpenDriverDoor *)v4,
        this->m_pTargetPed->m_pMyVehicle);
    }
    return (CTask *)v4;
  }
  if ( iSubTaskType > 1002 )
  {
    if ( iSubTaskType == 1003 )
    {
      v4 = (char *)CTask::operator new(0x20u);
      CTaskComplexDestroyCar::CTaskComplexDestroyCar(
        (CTaskComplexDestroyCar *)v4,
        this->m_pTargetPed->m_pMyVehicle,
        0,
        0,
        0);
      return (CTask *)v4;
    }
    if ( iSubTaskType == 1100 )
    {
      v12 = this->m_pTargetPed;
      m_pMyVehicle = v12->m_pMyVehicle;
      if ( m_pMyVehicle && CVehicle::IsDriver(m_pMyVehicle, v12) )
      {
        v14 = this->m_pTargetPed->m_pMyVehicle;
        v15 = *((_DWORD *)&v14->m_nVehicleFlags + 1);
        *(_DWORD *)&v14->m_nVehicleFlags |= 0x20u;
        *((_DWORD *)&v14->m_nVehicleFlags + 1) = v15;
        this->m_pTargetPed->m_pMyVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_pTargetPed->m_pMyVehicle->m_info & 7 | 0x48);
      }
      v4 = (char *)CTask::operator new(0x14u);
      v16 = this->m_pTargetPed;
      CTaskSimple::CTaskSimple((CTaskSimple *)v4);
      v4[12] = 0;
      *((_DWORD *)v4 + 4) = 0;
      *(_DWORD *)v4 = &off_66CF90;
      *((_DWORD *)v4 + 2) = v16;
      v17 = (CEntity **)(v4 + 8);
      if ( v16 )
        goto LABEL_28;
    }
  }
  else
  {
    if ( iSubTaskType != 907 )
    {
      if ( iSubTaskType == 1000 )
      {
        v4 = (char *)CTask::operator new(0x38u);
        CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(
          (CTaskComplexKillPedOnFoot *)v4,
          this->m_pTargetPed,
          -1,
          0,
          0,
          0,
          1);
      }
      return (CTask *)v4;
    }
    v18 = *((_DWORD *)&this->m_pTargetPed->m_nPedFlags + 2);
    v4 = (char *)CTask::operator new(0x4Cu);
    v16 = this->m_pTargetPed;
    CTaskComplex::CTaskComplex((CTaskComplex *)v4);
    v19 = 4.0;
    if ( (v18 & 0x40) == 0 )
      v19 = 3.0;
    *(_DWORD *)v4 = &off_6656D4;
    *((_DWORD *)v4 + 4) = 50000;
    *((_DWORD *)v4 + 5) = 1000;
    *((_DWORD *)v4 + 7) = 0x40000000;
    *((_DWORD *)v4 + 8) = 0;
    *((_DWORD *)v4 + 9) = 0x40000000;
    *((_WORD *)v4 + 24) = 0;
    *((_WORD *)v4 + 30) = 0;
    *((_DWORD *)v4 + 10) = 0;
    *((_DWORD *)v4 + 11) = 0;
    *((_DWORD *)v4 + 13) = 0;
    *((_DWORD *)v4 + 14) = 0;
    v20 = v4[72];
    *((_DWORD *)v4 + 16) = &off_665710;
    *((_DWORD *)v4 + 17) = 6;
    v4[72] = v20 & 0xF0 | 3;
    *((float *)v4 + 6) = v19;
    *((_DWORD *)v4 + 3) = v16;
    v17 = (CEntity **)(v4 + 12);
    if ( v16 )
LABEL_28:
      CEntity::RegisterReference(v16, v17);
  }
  return (CTask *)v4;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;
// 66CF90: using guessed type void *off_66CF90;

//----- (0053D284) --------------------------------------------------------
CTask *__fastcall CTaskComplexArrestPed::CreateFirstSubTask(CTaskComplexArrestPed *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  int v5; // r6
  const CVehicle *m_pMyVehicle; // r0
  int32 m_vehicleType; // r1
  CPed *v9; // r0
  eWeaponType v10; // r1

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    return 0;
  this->m_bNewTarget = 0;
  if ( *((unsigned __int8 *)&m_pTargetPed->m_nPedFlags + 1) << 31 )
  {
    m_pMyVehicle = m_pTargetPed->m_pMyVehicle;
    if ( m_pMyVehicle->m_baseVehicleType == 9 || (m_vehicleType = m_pMyVehicle->m_vehicleType, m_vehicleType == 2) )
    {
      v5 = 703;
    }
    else if ( m_vehicleType == 5 )
    {
      if ( CWeapon::IsTypeMelee(&pPed->m_WeaponSlots[pPed->m_nCurrentWeapon]) )
      {
        if ( CPed::DoWeHaveWeaponAvailable(pPed, WEAPONTYPE_SHOTGUN) )
        {
          v9 = pPed;
          v10 = WEAPONTYPE_SHOTGUN;
        }
        else
        {
          if ( !CPed::DoWeHaveWeaponAvailable(pPed, WEAPONTYPE_PISTOL) )
            CPed::GiveWeapon(pPed, WEAPONTYPE_PISTOL, 0xAu, 0);
          v9 = pPed;
          v10 = WEAPONTYPE_PISTOL;
        }
        CPed::SetCurrentWeapon(v9, v10);
      }
      v5 = 1003;
    }
    else
    {
      v5 = 1003;
      if ( !CVehicle::IsUpsideDown(m_pMyVehicle) && !CVehicle::IsOnItsSide(this->m_pTargetPed->m_pMyVehicle) )
        v5 = 722;
    }
  }
  else
  {
    v5 = 1000;
  }
  return CTaskComplexArrestPed::CreateSubTask(this, v5, pPed);
}

//----- (0053D348) --------------------------------------------------------
CTask *__fastcall CTaskComplexArrestPed::ControlSubTask(CTaskComplexArrestPed *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  CTask *m_pSubTask; // r10
  int v6; // r4
  CTask *v7; // r0
  int v8; // r0
  const CTaskComplexFallAndGetUp *v9; // r0
  CTaskComplexFallAndGetUp *v10; // r9
  CPed *v11; // r0
  CMatrix *v12; // r1
  CMatrix *v13; // r2
  CSimpleTransform *v14; // r3
  float32x2_t *v15; // r1
  float *p_z; // r3
  float32x2_t v17; // d16
  float32x2_t v18; // d16
  unsigned __int64 v19; // d0
  CTask *ActiveTaskByType; // r0
  CPed *v21; // r1
  CMatrix *m_pMat; // r3
  CMatrix *v23; // r4
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r3
  CPedFlags *p_m_nPedFlags; // r0
  float32x2_t v27; // d16
  unsigned __int64 v28; // d1
  CTask *v29; // r0
  CPed *v30; // r1
  CMatrix *v31; // r3
  CMatrix *v32; // r4
  CSimpleTransform *v33; // r2
  CSimpleTransform *v34; // r3
  CPedFlags *v35; // r0
  float32x2_t v36; // d16
  unsigned __int64 v37; // d1
  CPed *v38; // r0
  CVehicle *m_pMyVehicle; // r0
  CWanted *PlayerWanted; // r0
  CPed *v41; // r0
  CVehicle *v42; // r0
  eWeaponType v44; // r1

  m_pTargetPed = this->m_pTargetPed;
  m_pSubTask = this->m_pSubTask;
  if ( !m_pTargetPed )
  {
    v6 = 1302;
    v7 = this->m_pSubTask;
    goto LABEL_75;
  }
  if ( m_pTargetPed->m_nHealth <= 0.0 )
  {
    v6 = 1302;
    goto LABEL_67;
  }
  if ( this->m_bNewTarget )
  {
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      m_pSubTask = (CTask *)(*((int (__fastcall **)(CTaskComplexArrestPed *, CPed *))this->_vptr$CTask + 11))(
                              this,
                              pPed);
      v6 = 200;
      goto LABEL_67;
    }
    goto LABEL_66;
  }
  if ( (*((_BYTE *)&m_pTargetPed->m_nPedFlags + 8) & 0x40) != 0
    && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(this->m_pSubTask) != 1100 )
  {
    v6 = 907;
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 907 )
      goto LABEL_67;
  }
  v8 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v6 = 200;
  if ( v8 < 728 )
  {
    if ( v8 == 703 )
    {
LABEL_34:
      v6 = 200;
      if ( !(*((unsigned __int8 *)&this->m_pTargetPed->m_nPedFlags + 1) << 31) )
        v6 = 1000;
      goto LABEL_67;
    }
    if ( v8 != 722 )
      goto LABEL_67;
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pTargetPed->m_pPedIntelligence->m_taskManager, 704);
    v21 = this->m_pTargetPed;
    m_pMat = pPed->m_pMat;
    v23 = v21->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    p_m_transform = (CSimpleTransform *)&v23->tx;
    if ( !v23 )
      p_m_transform = &v21->m_transform;
    if ( ActiveTaskByType )
    {
      p_m_nPedFlags = &v21->m_nPedFlags;
      v27.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
      v28 = vmul_f32(v27, v27).n64_u64[0];
      if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                 * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                         + *(float *)&v28)
                 + *((float *)&v28 + 1)) < 25.0
        && (*(_DWORD *)&v21->m_nPedFlags & 0x100) != 0 )
      {
        goto LABEL_44;
      }
    }
    else
    {
      p_m_nPedFlags = &v21->m_nPedFlags;
    }
    if ( !(*((unsigned __int8 *)p_m_nPedFlags + 1) << 31) )
      goto LABEL_64;
    v6 = 200;
    if ( !CCarEnterExit::IsRoomForPedToLeaveCar(v21->m_pMyVehicle, 10, 0)
      && CCarEnterExit::IsRoomForPedToLeaveCar(this->m_pTargetPed->m_pMyVehicle, 8, 0) )
    {
      v6 = 728;
    }
LABEL_67:
    v41 = this->m_pTargetPed;
    if ( !v41 )
      goto LABEL_73;
    goto LABEL_68;
  }
  if ( v8 == 728 )
  {
    v29 = CTaskManager::FindActiveTaskByType(&this->m_pTargetPed->m_pPedIntelligence->m_taskManager, 704);
    v30 = this->m_pTargetPed;
    v31 = pPed->m_pMat;
    v32 = v30->m_pMat;
    v33 = (CSimpleTransform *)&v31->tx;
    if ( !v31 )
      v33 = &pPed->m_transform;
    v34 = (CSimpleTransform *)&v32->tx;
    if ( !v32 )
      v34 = &v30->m_transform;
    if ( v29 )
    {
      v35 = &v30->m_nPedFlags;
      v36.n64_u64[0] = vsub_f32(*(float32x2_t *)&v34->m_translate.y, *(float32x2_t *)&v33->m_translate.y).n64_u64[0];
      v37 = vmul_f32(v36, v36).n64_u64[0];
      if ( (float)((float)((float)((float)(v34->m_translate.x - v33->m_translate.x)
                                 * (float)(v34->m_translate.x - v33->m_translate.x))
                         + *(float *)&v37)
                 + *((float *)&v37 + 1)) < 25.0
        && (*(_DWORD *)&v30->m_nPedFlags & 0x100) != 0 )
      {
LABEL_44:
        v6 = 829;
        goto LABEL_67;
      }
    }
    else
    {
      v35 = &v30->m_nPedFlags;
    }
    if ( *((unsigned __int8 *)v35 + 1) << 31 )
    {
      if ( CCarEnterExit::IsRoomForPedToLeaveCar(v30->m_pMyVehicle, 8, 0) )
        goto LABEL_66;
      if ( CCarEnterExit::IsRoomForPedToLeaveCar(this->m_pTargetPed->m_pMyVehicle, 10, 0) )
      {
        v6 = 722;
        goto LABEL_67;
      }
LABEL_80:
      if ( CWeapon::IsTypeMelee(&pPed->m_WeaponSlots[pPed->m_nCurrentWeapon]) )
      {
        if ( CPed::DoWeHaveWeaponAvailable(pPed, WEAPONTYPE_SHOTGUN) )
          v44 = WEAPONTYPE_SHOTGUN;
        else
          v44 = WEAPONTYPE_PISTOL;
        CPed::SetCurrentWeapon(pPed, v44);
        v6 = 1003;
        goto LABEL_67;
      }
LABEL_85:
      v6 = 1003;
      goto LABEL_67;
    }
LABEL_64:
    v6 = 1000;
    goto LABEL_67;
  }
  if ( v8 == 1003 )
    goto LABEL_34;
  if ( v8 != 1000 )
    goto LABEL_67;
  v9 = (const CTaskComplexFallAndGetUp *)CTaskManager::FindActiveTaskByType(
                                           &this->m_pTargetPed->m_pPedIntelligence->m_taskManager,
                                           208);
  v10 = (CTaskComplexFallAndGetUp *)v9;
  if ( v9 && CTaskComplexFallAndGetUp::IsFalling(v9) )
  {
    v11 = this->m_pTargetPed;
    v6 = 907;
    v12 = pPed->m_pMat;
    v13 = v11->m_pMat;
    v14 = (CSimpleTransform *)&v12->tx;
    if ( !v12 )
      v14 = &pPed->m_transform;
    v15 = (float32x2_t *)&v13->tx;
    v17.n64_u64[0] = *(unsigned __int64 *)&v14->m_translate.x;
    p_z = &v14->m_translate.z;
    if ( !v13 )
      v15 = (float32x2_t *)&v11->m_transform;
    if ( fabsf(*p_z - v15[1].n64_f32[0]) <= 2.0 )
    {
      v18.n64_u64[0] = vsub_f32(v17, (float32x2_t)v15->n64_u64[0]).n64_u64[0];
      v19 = vmul_f32(v18, v18).n64_u64[0];
      if ( (float)((float)(*(float *)&v19 + *((float *)&v19 + 1)) + 0.0) <= 9.0 )
      {
        CTaskComplexFallAndGetUp::SetDownTime(v10, (const int)&elf_hash_chain[8526]);
        v6 = 1100;
      }
    }
    goto LABEL_67;
  }
  v38 = this->m_pTargetPed;
  if ( !(*((unsigned __int8 *)&v38->m_nPedFlags + 1) << 31) )
    goto LABEL_66;
  m_pMyVehicle = v38->m_pMyVehicle;
  if ( !m_pMyVehicle )
    goto LABEL_66;
  if ( m_pMyVehicle->m_baseVehicleType == 5 || (unsigned int)(m_pMyVehicle->m_vehicleType - 3) <= 1 )
    goto LABEL_80;
  if ( !CWeapon::IsTypeMelee(&pPed->m_WeaponSlots[pPed->m_nCurrentWeapon]) )
  {
    PlayerWanted = FindPlayerWanted(-1);
    if ( !CWanted::IsClosestCop(PlayerWanted, pPed, 2) )
      goto LABEL_85;
  }
  v41 = this->m_pTargetPed;
  if ( this->m_pVehicleAttemptedWithLockedDoor != v41->m_pMyVehicle )
  {
    if ( !CTaskManager::FindActiveTaskByType(&v41->m_pPedIntelligence->m_taskManager, 704) )
    {
      v42 = this->m_pTargetPed->m_pMyVehicle;
      if ( v42->m_baseVehicleType == 9 || v42->m_vehicleType == 2 )
      {
        v6 = 703;
      }
      else
      {
        v6 = 1003;
        if ( !CVehicle::IsUpsideDown(v42) && !CVehicle::IsOnItsSide(this->m_pTargetPed->m_pMyVehicle) )
          v6 = 722;
      }
      goto LABEL_67;
    }
LABEL_66:
    v6 = 200;
    goto LABEL_67;
  }
  v6 = 200;
  if ( !v41 )
  {
LABEL_73:
    if ( v6 == 200 )
      return m_pSubTask;
    goto LABEL_74;
  }
LABEL_68:
  if ( !CPed::IsPlayer(v41) )
    goto LABEL_73;
  if ( FindPlayerWanted(-1)->m_nCopsInPursuit != 1 )
  {
    FindPlayerWanted(-1);
    goto LABEL_73;
  }
  CPed::Say(pPed, 0xC7u, 0, 1.0, 0, 0, 0);
  if ( v6 == 200 )
    return m_pSubTask;
LABEL_74:
  v7 = this->m_pSubTask;
LABEL_75:
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v7->_vptr$CTask + 7))(v7, pPed, 1, 0) == 1 )
    return CTaskComplexArrestPed::CreateSubTask(this, v6, pPed);
  return m_pSubTask;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0053D78C) --------------------------------------------------------
void __fastcall CTaskComplexPolicePursuit::CTaskComplexPolicePursuit(CTaskComplexPolicePursuit *this)
{
  int v1; // r0
  char v2; // r2

  CTaskComplex::CTaskComplex(this);
  v2 = *(_BYTE *)(v1 + 12);
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  *(_BYTE *)(v1 + 12) = v2 & 0xF8 | 4;
  *(_DWORD *)v1 = &off_66D000;
}
// 53D798: variable 'v1' is possibly undefined
// 66D000: using guessed type void *;

//----- (0053D7B8) --------------------------------------------------------
void __fastcall CTaskComplexPolicePursuit::~CTaskComplexPolicePursuit(CTaskComplexPolicePursuit *this)
{
  CCopPed *m_pCopPed; // r5
  CWanted *PlayerWanted; // r0
  CPlayerPed *m_pClosestPlayer; // r0

  m_pCopPed = (CCopPed *)this->m_pCopPed;
  this->_vptr$CTask = (int (**)(void))&off_66D000;
  if ( m_pCopPed && FindPlayerPed(-1) )
  {
    PlayerWanted = FindPlayerWanted(-1);
    CWanted::RemovePursuitCop(PlayerWanted, m_pCopPed);
  }
  m_pClosestPlayer = this->m_pClosestPlayer;
  if ( m_pClosestPlayer )
    CEntity::CleanUpOldReference(m_pClosestPlayer, &this->m_pClosestPlayer);
  sub_18EDB4(this);
}
// 66D000: using guessed type void *off_66D000;

//----- (0053D804) --------------------------------------------------------
void __fastcall CTaskComplexPolicePursuit::ClearPursuit(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  CWanted *PlayerWanted; // r0

  if ( FindPlayerPed(-1) )
  {
    PlayerWanted = FindPlayerWanted(-1);
    sub_18DAE0(PlayerWanted, (CCopPed *)pPed);
  }
}

//----- (0053D82C) --------------------------------------------------------
void __fastcall CTaskComplexPolicePursuit::~CTaskComplexPolicePursuit(CTaskComplexPolicePursuit *this)
{
  CCopPed *m_pCopPed; // r5
  CWanted *PlayerWanted; // r0
  CPlayerPed *m_pClosestPlayer; // r0
  void *v5; // r0

  m_pCopPed = (CCopPed *)this->m_pCopPed;
  this->_vptr$CTask = (int (**)(void))&off_66D000;
  if ( m_pCopPed && FindPlayerPed(-1) )
  {
    PlayerWanted = FindPlayerWanted(-1);
    CWanted::RemovePursuitCop(PlayerWanted, m_pCopPed);
  }
  m_pClosestPlayer = this->m_pClosestPlayer;
  if ( m_pClosestPlayer )
    CEntity::CleanUpOldReference(m_pClosestPlayer, &this->m_pClosestPlayer);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 53D874: variable 'v5' is possibly undefined
// 66D000: using guessed type void *off_66D000;

//----- (0053D87C) --------------------------------------------------------
bool __fastcall CTaskComplexPolicePursuit::MakeAbortable(
        CTaskComplexPolicePursuit *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (0053D888) --------------------------------------------------------
CTask *__fastcall CTaskComplexPolicePursuit::CreateNextSubTask(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  return 0;
}

//----- (0053D88C) --------------------------------------------------------
CTask *__fastcall CTaskComplexPolicePursuit::CreateFirstSubTask(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  int v4; // r1

  this->m_pCopPed = pPed;
  if ( CTaskComplexPolicePursuit::SetPursuit(this, pPed) )
  {
    v4 = 1101;
  }
  else
  {
    v4 = 1302;
    *((_BYTE *)this + 12) &= ~4u;
  }
  return CTaskComplexPolicePursuit::CreateSubTask(this, v4, pPed);
}

//----- (0053D8B8) --------------------------------------------------------
bool __fastcall CTaskComplexPolicePursuit::SetPursuit(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  CSimpleTransform *p_m_transform; // r0
  CPlayerPed *v5; // r6
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r3
  CMatrix *v8; // r2
  CSimpleTransform *v9; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1
  float v12; // s0
  CVehicle *m_pMyVehicle; // r1
  CMatrix *v14; // r2
  CMatrix *v15; // r3
  CSimpleTransform *v16; // r2
  float32x2_t v17; // d16
  unsigned __int64 v18; // d2
  float v19; // s2
  CVehicle *v20; // r0
  CEntity *v21; // r0
  CEntity **p_m_pClosestPlayer; // r4
  CPlayerPed *m_pClosestPlayer; // t1
  CWanted *PlayerWanted; // r0
  bool result; // r0

  p_m_transform = &pPed->m_transform;
  v5 = CWorld::Players[0].pPed;
  if ( CWorld::Players[0].pPed )
  {
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    v8 = CWorld::Players[0].pPed->m_pMat;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v9 = (CSimpleTransform *)&v8->tx;
    if ( !v8 )
      v9 = &CWorld::Players[0].pPed->m_transform;
    v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&v9->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
    v11 = vmul_f32(v10, v10).n64_u64[0];
    v12 = (float)((float)((float)(v9->m_translate.x - p_tx->m_translate.x)
                        * (float)(v9->m_translate.x - p_tx->m_translate.x))
                + *(float *)&v11)
        + *((float *)&v11 + 1);
    if ( v12 >= 3.4028e38
      || *((unsigned __int8 *)&CWorld::Players[0].pPed->m_nPedFlags + 1) << 31
      && (m_pMyVehicle = CWorld::Players[0].pPed->m_pMyVehicle,
          (float)(v12
                * (float)((float)((float)(m_pMyVehicle->m_vecMoveSpeed.x * m_pMyVehicle->m_vecMoveSpeed.x)
                                + (float)(m_pMyVehicle->m_vecMoveSpeed.y * m_pMyVehicle->m_vecMoveSpeed.y))
                        + (float)(m_pMyVehicle->m_vecMoveSpeed.z * m_pMyVehicle->m_vecMoveSpeed.z))) >= 16.0) )
    {
      v5 = 0;
      v12 = 3.4028e38;
    }
  }
  else
  {
    v12 = 3.4028e38;
    v5 = 0;
  }
  if ( CWorld::Players[1].pPed )
  {
    v14 = pPed->m_pMat;
    v15 = CWorld::Players[1].pPed->m_pMat;
    if ( v14 )
      p_m_transform = (CSimpleTransform *)&v14->tx;
    v16 = (CSimpleTransform *)&v15->tx;
    if ( !v15 )
      v16 = &CWorld::Players[1].pPed->m_transform;
    v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&v16->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
    v18 = vmul_f32(v17, v17).n64_u64[0];
    v19 = (float)((float)((float)(v16->m_translate.x - p_m_transform->m_translate.x)
                        * (float)(v16->m_translate.x - p_m_transform->m_translate.x))
                + *(float *)&v18)
        + *((float *)&v18 + 1);
    if ( v19 < v12 )
    {
      if ( *((unsigned __int8 *)&CWorld::Players[1].pPed->m_nPedFlags + 1) << 31 )
      {
        v20 = CWorld::Players[1].pPed->m_pMyVehicle;
        if ( (float)(v19
                   * (float)((float)((float)(v20->m_vecMoveSpeed.x * v20->m_vecMoveSpeed.x)
                                   + (float)(v20->m_vecMoveSpeed.y * v20->m_vecMoveSpeed.y))
                           + (float)(v20->m_vecMoveSpeed.z * v20->m_vecMoveSpeed.z))) < 16.0 )
          v5 = CWorld::Players[1].pPed;
      }
      else
      {
        v5 = CWorld::Players[1].pPed;
      }
    }
  }
  m_pClosestPlayer = this->m_pClosestPlayer;
  p_m_pClosestPlayer = &this->m_pClosestPlayer;
  v21 = m_pClosestPlayer;
  if ( m_pClosestPlayer )
    CEntity::CleanUpOldReference(v21, p_m_pClosestPlayer);
  PlayerWanted = FindPlayerWanted(-1);
  if ( v5 && CWanted::SetPursuitCop(PlayerWanted, (CCopPed *)pPed) )
  {
    *p_m_pClosestPlayer = v5;
    CEntity::RegisterReference(v5, p_m_pClosestPlayer);
    return 1;
  }
  else
  {
    result = 0;
    *p_m_pClosestPlayer = 0;
  }
  return result;
}

//----- (0053DA50) --------------------------------------------------------
CTask *__fastcall CTaskComplexPolicePursuit::CreateSubTask(
        const CTaskComplexPolicePursuit *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v5; // r4
  CEntity *m_pMyVehicle; // r5
  CEntity **v7; // r1
  float m_fRadius; // s16
  char v9; // r1

  v5 = 0;
  if ( iSubTaskType > 906 )
  {
    if ( iSubTaskType == 907 )
    {
      v5 = (char *)CTask::operator new(0x4Cu);
      m_pMyVehicle = pPed->m_pMyVehicle;
      m_fRadius = CModelInfo::ms_modelInfoPtrs[m_pMyVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *(_DWORD *)v5 = &off_6656D4;
      *((_DWORD *)v5 + 4) = 50000;
      *((_DWORD *)v5 + 5) = 1000;
      *((_DWORD *)v5 + 7) = 0x40000000;
      *((_DWORD *)v5 + 8) = 0;
      *((_DWORD *)v5 + 9) = 0x40000000;
      *((_WORD *)v5 + 24) = 0;
      *((_WORD *)v5 + 30) = 0;
      *((_DWORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 11) = 0;
      *((_DWORD *)v5 + 13) = 0;
      *((_DWORD *)v5 + 14) = 0;
      v9 = v5[72];
      *((_DWORD *)v5 + 16) = &off_665710;
      *((_DWORD *)v5 + 17) = 6;
      v5[72] = v9 & 0xF0 | 3;
      *((float *)v5 + 6) = m_fRadius + 1.0;
      *((_DWORD *)v5 + 3) = m_pMyVehicle;
      v7 = (CEntity **)(v5 + 12);
      if ( !m_pMyVehicle )
        return (CTask *)v5;
    }
    else
    {
      if ( iSubTaskType != 1101 )
        return (CTask *)v5;
      if ( !this->m_pClosestPlayer )
        return 0;
      v5 = (char *)CTask::operator new(0x24u);
      m_pMyVehicle = this->m_pClosestPlayer;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_DWORD *)v5 + 8) = 0;
      *(_DWORD *)v5 = &off_66CFC4;
      *((_DWORD *)v5 + 4) = m_pMyVehicle;
      v7 = (CEntity **)(v5 + 16);
      if ( !m_pMyVehicle )
        return (CTask *)v5;
    }
    CEntity::RegisterReference(m_pMyVehicle, v7);
    return (CTask *)v5;
  }
  if ( iSubTaskType == 203 )
  {
    v5 = (char *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 0, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 421 )
  {
    v5 = (char *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(
      (CTaskSimpleRunAnim *)v5,
      ANIM_STD_PED,
      ANIM_STD_XPRESS_SCRATCH,
      4.0,
      421,
      "ScratchHead",
      0);
    *(_DWORD *)v5 = &off_665860;
  }
  return (CTask *)v5;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;
// 665860: using guessed type void *off_665860;
// 66CFC4: using guessed type void *off_66CFC4;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;

//----- (0053DBBC) --------------------------------------------------------
CTask *__fastcall CTaskComplexPolicePursuit::ControlSubTask(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  CWanted *PlayerWanted; // r4
  CVehicle *m_pMyVehicle; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v7; // r2
  int v8; // r6
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  CTaskComplexPolicePursuit *v13; // r0
  bool v14; // zf
  CTaskSimpleRunAnim *m_pSubTask; // r4
  CEventVehicleToSteal v17; // [sp+10h] [bp-28h] BYREF

  PlayerWanted = FindPlayerWanted(-1);
  if ( CTaskComplexPolicePursuit::PersistPursuit(this, pPed) )
    goto LABEL_16;
  if ( *((unsigned __int8 *)this + 12) << 31
    && ((*((_BYTE *)&pPed->m_nPedFlags + 2) & 0x20) == 0
     || pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType != WEAPONTYPE_PISTOL) )
  {
    CPed::SetCurrentWeapon(pPed, WEAPONTYPE_PISTOL);
    v8 = 1101;
    *(_DWORD *)&pPed->m_nPedFlags |= 0x200000u;
    goto LABEL_21;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1101 )
  {
LABEL_16:
    v8 = 200;
    goto LABEL_21;
  }
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v8 = 1302;
  }
  else
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( m_pMyVehicle )
    {
      if ( PlayerWanted->m_WantedLevel )
      {
        m_pMat = pPed->m_pMat;
        v7 = m_pMyVehicle->m_pMat;
        v8 = 203;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_m_transform = (CSimpleTransform *)&v7->tx;
        if ( !v7 )
          p_m_transform = &m_pMyVehicle->m_transform;
        v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
        v12 = vmul_f32(v11, v11).n64_u64[0];
        if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                   * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                           + *(float *)&v12)
                   + *((float *)&v12 + 1)) < 25.0 )
          v8 = 907;
      }
      else
      {
        v8 = 701;
      }
    }
    else
    {
      v8 = 203;
    }
  }
LABEL_21:
  v13 = (CTaskComplexPolicePursuit *)(*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v14 = v8 == 1101;
  if ( v8 != 1101 )
    v14 = v13 == (CTaskComplexPolicePursuit *)((char *)&elf_hash_bucket[212] + 1);
  if ( v14 )
    CTaskComplexPolicePursuit::SetWeapon(v13, pPed);
  m_pSubTask = (CTaskSimpleRunAnim *)this->m_pSubTask;
  if ( v8 == 200
    || (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(this->m_pSubTask, pPed, 1, 0) != 1 )
  {
    return m_pSubTask;
  }
  if ( v8 == 701 )
  {
    CEventVehicleToSteal::CEventVehicleToSteal(&v17, pPed->m_pMyVehicle);
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v17, 0);
    m_pSubTask = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(
      m_pSubTask,
      ANIM_STD_PED,
      ANIM_STD_XPRESS_SCRATCH,
      4.0,
      421,
      "ScratchHead",
      0);
    m_pSubTask->_vptr$CTask = (int (**)(void))&off_665860;
    CEventVehicleToSteal::~CEventVehicleToSteal(&v17);
    return m_pSubTask;
  }
  return CTaskComplexPolicePursuit::CreateSubTask(this, v8, pPed);
}
// FC: using guessed type int elf_hash_bucket[16411];
// 665860: using guessed type void *off_665860;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;

//----- (0053DD64) --------------------------------------------------------
bool __fastcall CTaskComplexPolicePursuit::PersistPursuit(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  CWanted *PlayerWanted; // r5
  int v5; // r0
  char v6; // r1
  bool v7; // zf
  char v8; // r0
  char v9; // r0
  CWanted *v10; // r0

  PlayerWanted = FindPlayerWanted(-1);
  if ( pPed->m_nHealth > 0.0 )
  {
    v5 = CCullZones::NoPolice();
    v6 = *((_BYTE *)this + 12);
    v7 = v5 == 1;
    if ( v5 == 1 )
      v7 = (v6 & 1) == 0;
    if ( v7 )
    {
      if ( (*((_BYTE *)&pPed->m_nPedFlags + 1) & 8) == 0 )
        goto LABEL_18;
      v8 = v6 | 3;
    }
    else
    {
      if ( (*((_BYTE *)this + 12) & 2) != 0 && !CCullZones::NoPolice() )
      {
        v9 = *((_BYTE *)this + 12);
      }
      else
      {
        if ( PlayerWanted->m_WantedLevel )
          goto LABEL_18;
        v9 = *((_BYTE *)this + 12);
        if ( (v9 & 3) != 1 )
          goto LABEL_18;
      }
      v8 = v9 & 0xFC;
    }
    *((_BYTE *)this + 12) = v8;
  }
  if ( FindPlayerPed(-1) )
  {
    v10 = FindPlayerWanted(-1);
    CWanted::RemovePursuitCop(v10, (CCopPed *)pPed);
  }
LABEL_18:
  CWanted::RemoveExcessPursuitCops(PlayerWanted);
  return sub_18DA34(PlayerWanted, (CCopPed *)pPed);
}

//----- (0053DDFA) --------------------------------------------------------
void __fastcall CTaskComplexPolicePursuit::SetWeapon(CTaskComplexPolicePursuit *this, CPed *pPed)
{
  eWantedLevel m_WantedLevel; // r0
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v5; // r0
  eWeaponType v6; // r1

  m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
  if ( m_WantedLevel < WANTED_LEVEL2 )
  {
    if ( m_WantedLevel != WANTED_LEVEL1
      || FindPlayerPed(-1)->m_pGroundPhysical
      || pPed->m_nPedState == PED_ARREST_PLAYER )
    {
      return;
    }
    if ( CPed::DoWeHaveWeaponAvailable(pPed, WEAPONTYPE_NIGHTSTICK) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CWeaponInfo::GetWeaponInfo(PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_eFireType != FIRETYPE_INSTANT_HIT )
      {
        v5 = FindPlayerPed(-1);
        if ( CWeaponInfo::GetWeaponInfo(v5->m_WeaponSlots[v5->m_nCurrentWeapon].m_eWeaponType, 1)->m_eFireType != FIRETYPE_PROJECTILE )
        {
          sub_19173C(pPed, WEAPONTYPE_NIGHTSTICK);
          return;
        }
      }
    }
  }
  else if ( pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType )
  {
    return;
  }
  if ( CPed::DoWeHaveWeaponAvailable(pPed, WEAPONTYPE_SHOTGUN) )
    v6 = WEAPONTYPE_SHOTGUN;
  else
    v6 = WEAPONTYPE_PISTOL;
  sub_19173C(pPed, v6);
}

//----- (0053DEBC) --------------------------------------------------------
void __fastcall CTaskComplexKillCriminal::CTaskComplexKillCriminal(
        CTaskComplexKillCriminal *this,
        CPed *pCriminal,
        bool bRandomise)
{
  CPed **p_m_pCriminal; // r5
  CPed *v7; // r0
  int m_nPedType; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_pCopPed = 0;
  this->m_timeToGetOutOfCar = 3.0;
  this->m_bRandomise = bRandomise;
  *(_WORD *)&this->m_bIAmFinished = 0;
  this->m_bSetUp = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D03C;
  this->m_pCriminal = pCriminal;
  p_m_pCriminal = &this->m_pCriminal;
  if ( pCriminal )
  {
    if ( CPed::IsPlayer(pCriminal)
      || (v7 = *p_m_pCriminal, m_nPedType = (*p_m_pCriminal)->m_nPedType, (unsigned int)m_nPedType <= 0x13)
      && ((1 << m_nPedType) & (unsigned int)"eObjectCarriedWithRopeEv") != 0
      || m_nPedType > 23
      || v7->CharCreatedBy == 2 )
    {
      *p_m_pCriminal = 0;
    }
    else
    {
      CEntity::RegisterReference(v7, &this->m_pCriminal);
    }
  }
}
// 66D03C: using guessed type void *;

//----- (0053DF3C) --------------------------------------------------------
void __fastcall CTaskComplexKillCriminal::~CTaskComplexKillCriminal(CTaskComplexKillCriminal *this)
{
  CPed *m_pCriminal; // r0
  CEntity **p_m_pCriminal; // r1
  CCopPed *m_pCopPed; // r0
  CCopPed **p_m_pCopPed; // r5
  CCopPed *v6; // r0
  int v7; // r3
  unsigned int v8; // r2
  int v9; // r4
  CEntity *v10; // r0
  CVehicle *m_pMyVehicle; // r1
  CVehicle *v12; // r1
  CVehicle *v13; // r0

  p_m_pCriminal = &this->m_pCriminal;
  m_pCriminal = this->m_pCriminal;
  this->_vptr$CTask = (int (**)(void))&off_66D03C;
  if ( m_pCriminal )
    CEntity::CleanUpOldReference(m_pCriminal, p_m_pCriminal);
  p_m_pCopPed = &this->m_pCopPed;
  m_pCopPed = this->m_pCopPed;
  if ( m_pCopPed )
  {
    m_pCopPed->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds;
    v6 = *p_m_pCopPed;
    v7 = *((_DWORD *)&(*p_m_pCopPed)->m_nPedFlags + 2);
    v8 = *((_DWORD *)&(*p_m_pCopPed)->m_nPedFlags + 1) & 0xFFFFFFBF;
    v9 = *((_DWORD *)&(*p_m_pCopPed)->m_nPedFlags + 3);
    *(_DWORD *)&v6->m_nPedFlags = (*p_m_pCopPed)->m_nPedFlags;
    *((_DWORD *)&v6->m_nPedFlags + 1) = v8;
    *((_DWORD *)&v6->m_nPedFlags + 2) = v7;
    *((_DWORD *)&v6->m_nPedFlags + 3) = v9;
    (*p_m_pCopPed)->fRemoveRangeMultiplier = 1.0;
    v10 = *p_m_pCopPed;
    m_pMyVehicle = (*p_m_pCopPed)->m_pMyVehicle;
    if ( m_pMyVehicle )
    {
      m_pMyVehicle->ExtendedRemovalRange = 0;
      *((_DWORD *)&(*p_m_pCopPed)->m_pMyVehicle->m_nVehicleFlags + 1) &= ~0x40u;
      v10 = *p_m_pCopPed;
      v12 = (*p_m_pCopPed)->m_pMyVehicle;
      if ( v12->pDriver == *p_m_pCopPed )
      {
        v12->AutoPilot.DrivingMode = 2;
        (*p_m_pCopPed)->m_pMyVehicle->AutoPilot.Mission = 1;
        (*p_m_pCopPed)->m_pMyVehicle->AutoPilot.CruiseSpeed = 10;
        v13 = (*p_m_pCopPed)->m_pMyVehicle;
        if ( (*(_BYTE *)&v13->m_info & 0xF8) != 16 )
        {
          CCarCtrl::JoinCarWithRoadSystem(v13);
          v13 = (*p_m_pCopPed)->m_pMyVehicle;
        }
        *((_DWORD *)&v13->m_nVehicleFlags + 1) &= ~0x8000u;
        v10 = *p_m_pCopPed;
      }
    }
    if ( v10 )
      CEntity::CleanUpOldReference(v10, &this->m_pCopPed);
  }
  sub_18EDB4(this);
}
// 66D03C: using guessed type void *off_66D03C;

//----- (0053E03C) --------------------------------------------------------
void __fastcall CTaskComplexKillCriminal::~CTaskComplexKillCriminal(CTaskComplexKillCriminal *this)
{
  void *v1; // r0

  CTaskComplexKillCriminal::~CTaskComplexKillCriminal(this);
  sub_197118(v1);
}
// 53E048: variable 'v1' is possibly undefined

//----- (0053E04C) --------------------------------------------------------
bool __fastcall CTaskComplexKillCriminal::MakeAbortable(
        CTaskComplexKillCriminal *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v8; // r6
  int v9; // r0
  CPed *m_pCriminal; // r1
  bool v11; // zf
  const CPed *v12; // r0
  CCopPed *m_pCopPed; // r5
  CPed *v14; // r0
  int32 v15; // r0
  CPed *v16; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v18; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v21; // d16
  unsigned __int64 v22; // d1
  CPed *v23; // r0

  if ( !pEvent )
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  v8 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent);
  v9 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent);
  m_pCriminal = this->m_pCriminal;
  if ( m_pCriminal && (CPed *)v9 == m_pCriminal )
  {
    switch ( v8 )
    {
      case 9:
      case 15:
      case 31:
      case 36:
      case 41:
        goto LABEL_23;
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 32:
      case 33:
      case 34:
      case 35:
      case 37:
      case 38:
      case 39:
      case 40:
        return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
                + 7))(
                 this->m_pSubTask,
                 pPed,
                 iPriority,
                 pEvent);
      default:
        if ( v8 == 73 )
          goto LABEL_23;
        return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
                + 7))(
                 this->m_pSubTask,
                 pPed,
                 iPriority,
                 pEvent);
    }
  }
  v11 = v8 == 73;
  if ( v8 != 73 )
    v11 = v8 == 36;
  if ( !v11 )
  {
    switch ( v8 )
    {
      case 9:
      case 15:
      case 31:
      case 41:
        if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent) )
        {
          if ( (*(_BYTE *)((*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent) + 58) & 7) == 3 )
          {
            v12 = (const CPed *)(*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent);
            if ( !CPed::IsPlayer(v12) )
            {
              m_pCopPed = this->m_pCopPed;
              if ( m_pCopPed )
              {
                v14 = (CPed *)(*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent);
                v15 = CCopPed::AddCriminalToKill(m_pCopPed, v14);
                if ( (v8 | 0x20) == 41 )
                {
                  if ( v15 )
                  {
                    v16 = this->m_pCriminal;
                    if ( !v16 )
                      goto LABEL_21;
                    m_pMat = pPed->m_pMat;
                    v18 = v16->m_pMat;
                    p_tx = (CSimpleTransform *)&m_pMat->tx;
                    if ( !m_pMat )
                      p_tx = &pPed->m_transform;
                    p_m_transform = (CSimpleTransform *)&v18->tx;
                    if ( !v18 )
                      p_m_transform = &v16->m_transform;
                    v21.n64_u64[0] = vsub_f32(
                                       *(float32x2_t *)&p_m_transform->m_translate.y,
                                       *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
                    v22 = vmul_f32(v21, v21).n64_u64[0];
                    if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                               * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                                       + *(float *)&v22)
                               + *((float *)&v22 + 1)) < 625.0 )
                    {
LABEL_21:
                      v23 = (CPed *)(*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent);
                      CTaskComplexKillCriminal::ChangeTarget(this, v23);
                    }
                  }
                }
              }
            }
          }
        }
        break;
      default:
        return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
                + 7))(
                 this->m_pSubTask,
                 pPed,
                 iPriority,
                 pEvent);
    }
  }
LABEL_23:
  ++pEvent->m_iAccumulatedTime;
  return 0;
}

//----- (0053E1D8) --------------------------------------------------------
bool __fastcall CTaskComplexKillCriminal::ChangeTarget(CTaskComplexKillCriminal *this, CPed *pPed)
{
  CPed *m_pCriminal; // r0
  CEntity **p_m_pCriminal; // r6
  float *p_m_nHealth; // r9
  bool v7; // zf
  CTask *m_pSubTask; // r0
  bool v9; // r4
  CCopPed *m_pCopPed; // r0
  CCopPed *m_pPartner; // r0
  bool v12; // zf
  CTaskComplexKillCriminal *TaskByType; // r0

  p_m_pCriminal = &this->m_pCriminal;
  m_pCriminal = this->m_pCriminal;
  if ( m_pCriminal == pPed )
    return 1;
  if ( !pPed )
    return 0;
  p_m_nHealth = &pPed->m_nHealth;
  if ( pPed->m_nHealth <= 0.0 )
    return 0;
  v7 = m_pCriminal == 0;
  if ( m_pCriminal )
    v7 = *((unsigned __int8 *)&m_pCriminal->m_nPedFlags + 1) << 31 == 0;
  if ( !v7 )
    return 0;
  m_pSubTask = this->m_pSubTask;
  if ( !m_pSubTask
    || (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 1000
    || (v9 = 0,
        (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
          this->m_pSubTask,
          pPed,
          1,
          0) == 1) )
  {
    m_pCopPed = this->m_pCopPed;
    if ( (m_pCopPed->m_aCriminalsImAfter[0] != pPed || *p_m_nHealth <= 0.0)
      && (m_pCopPed->m_aCriminalsImAfter[1] != pPed || *p_m_nHealth <= 0.0)
      && (m_pCopPed->m_aCriminalsImAfter[2] != pPed || *p_m_nHealth <= 0.0)
      && (m_pCopPed->m_aCriminalsImAfter[3] != pPed || *p_m_nHealth <= 0.0)
      && (m_pCopPed->m_aCriminalsImAfter[4] != pPed || *p_m_nHealth <= 0.0) )
    {
      return 0;
    }
    if ( *p_m_pCriminal )
      CEntity::CleanUpOldReference(*p_m_pCriminal, p_m_pCriminal);
    this->m_pCriminal = pPed;
    CEntity::RegisterReference(pPed, p_m_pCriminal);
    m_pPartner = this->m_pCopPed->m_pPartner;
    v12 = m_pPartner == 0;
    if ( m_pPartner )
      v12 = *((unsigned __int8 *)&m_pPartner->m_nPedFlags + 1) << 31 == 0;
    if ( !v12 )
    {
      TaskByType = (CTaskComplexKillCriminal *)CPedIntelligence::FindTaskByType(m_pPartner->m_pPedIntelligence, 1105);
      if ( TaskByType )
        CTaskComplexKillCriminal::ChangeTarget(TaskByType, pPed);
    }
    this->m_bIAmFinished = 0;
    return 1;
  }
  return v9;
}

//----- (0053E30C) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillCriminal::CreateFirstSubTask(CTaskComplexKillCriminal *this, CPed *pPed)
{
  CPed *m_pCriminal; // r0
  CTaskComplexLeaveCar *SubTask; // r6
  CPed *v7; // r1
  CVehicle *m_pMyVehicle; // r2
  const CPed *pDriver; // r0
  int v10; // r4
  const CPed *v11; // r0
  CCopPed **p_m_pCopPed; // r8
  CPed *v13; // r0
  CVehicle *v14; // r0
  CPed *v15; // r0
  CCopPed *v16; // r0
  bool v17; // zf
  int v18; // r1
  CCopPed *m_pPartner; // r1
  CCopPed *v20; // r1
  CCopPed *v21; // r1
  CTask *TaskByType; // r0
  CPed *v23; // r1
  CCopPed *v24; // r0
  int v25; // r2
  int v26; // r3
  int v27; // r6
  CCopPed *v28; // r0
  CPed *v29; // r0
  bool v30; // zf
  int v31; // r1
  CVehicle *v32; // r0
  bool v33; // zf
  UInt8 CruiseSpeed; // r0
  CPed *v35; // r0
  CVehicle *v36; // r1
  CPed *v37; // r0
  CVehicle *v38; // r1
  int v39; // r5
  int (***v40)(void); // r1
  CPed *v41; // r4
  CVehicle *v42; // r0
  uint32 v43; // r1
  CVehicle *v44; // r0
  CTask *m_pSubTask; // r0
  CVehicle *v46; // r1
  int m_nMaxPassengers; // r2
  CPed **pPassengers; // r3
  int v49; // r6
  CCopPed *v50; // r1
  CEventAcquaintancePed v51; // [sp+Ch] [bp-2Ch] BYREF

  m_pCriminal = this->m_pCriminal;
  if ( !m_pCriminal || CPed::IsPlayer(m_pCriminal) )
    return 0;
  SubTask = 0;
  if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN && g_LoadMonitor.m_bEnableAmbientCrime )
  {
    if ( pPed->m_nPedType == 6 )
    {
      v7 = this->m_pCriminal;
      m_pMyVehicle = v7->m_pMyVehicle;
      if ( m_pMyVehicle )
      {
        pDriver = m_pMyVehicle->pDriver;
        if ( pDriver )
        {
          if ( CPed::IsPlayer(pDriver) )
            return 0;
          v7 = this->m_pCriminal;
          m_pMyVehicle = v7->m_pMyVehicle;
        }
        if ( m_pMyVehicle->m_nMaxPassengers )
        {
          v10 = 0;
          do
          {
            v11 = m_pMyVehicle->pPassengers[v10];
            if ( v11 )
            {
              if ( CPed::IsPlayer(v11) )
                return 0;
              v7 = this->m_pCriminal;
            }
            m_pMyVehicle = v7->m_pMyVehicle;
            ++v10;
          }
          while ( v10 < m_pMyVehicle->m_nMaxPassengers );
        }
      }
      this->m_pCopPed = (CCopPed *)pPed;
      p_m_pCopPed = &this->m_pCopPed;
      CEntity::RegisterReference(pPed, &this->m_pCopPed);
      if ( !this->m_bRandomise
        || (v13 = this->m_pCriminal, (*((_DWORD *)&v13->m_nPedFlags + 3) & 0x800) != 0)
        || (*(_DWORD *)&v13->m_nPedFlags & 0x100) != 0
        && (v14 = v13->m_pMyVehicle) != 0
        && (*((_BYTE *)&v14->m_nVehicleFlags + 6) & 8) != 0
        && !(int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0) )
      {
        CCopPed::AddCriminalToKill(this->m_pCopPed, this->m_pCriminal);
        v15 = this->m_pCriminal;
        if ( *((unsigned __int8 *)&v15->m_nPedFlags + 1) << 31 )
          CPedIntelligence::SetPedDecisionMakerType(v15->m_pPedIntelligence, 6);
        v16 = *p_m_pCopPed;
        v18 = *((unsigned __int8 *)&(*p_m_pCopPed)->m_nPedFlags + 1) << 31;
        v17 = v18 == 0;
        if ( v18 )
        {
          v18 = (int)v16->m_pMyVehicle;
          v17 = v18 == 0;
        }
        if ( v17 )
        {
          m_pPartner = v16->m_pPartner;
          if ( !m_pPartner || m_pPartner->m_nHealth <= 0.0 )
            v16->m_bIAmDriver = 1;
          goto LABEL_48;
        }
        v20 = *(CCopPed **)(v18 + 1124);
        if ( v20 == pPed )
        {
          v16->m_bIAmDriver = 1;
          v28 = *p_m_pCopPed;
          if ( (*p_m_pCopPed)->m_pPartner )
            goto LABEL_43;
          v46 = v28->m_pMyVehicle;
          m_nMaxPassengers = v46->m_nMaxPassengers;
          if ( v46->m_nMaxPassengers )
          {
            pPassengers = v46->pPassengers;
            v49 = 0;
            while ( 1 )
            {
              v50 = (CCopPed *)pPassengers[v49];
              if ( v50 )
              {
                if ( v50->m_nPedType == 6 )
                  break;
              }
              if ( ++v49 >= m_nMaxPassengers )
                goto LABEL_44;
            }
            CCopPed::SetPartner(v28, v50);
            if ( (*p_m_pCopPed)->m_pPartner )
            {
LABEL_43:
              CEventAcquaintancePed::CEventAcquaintancePed(&v51, this->m_pCriminal);
              v51.m_iTaskType = 1105;
              v51._vptr$CEvent = (int (**)(void))&off_665394;
              CEventGroup::Add(&this->m_pCopPed->m_pPartner->m_pPedIntelligence->m_eventGroup, (CEvent *)&v51, 0);
              CEventAcquaintancePed::~CEventAcquaintancePed(&v51);
            }
          }
        }
        else
        {
          if ( v20 && v20->m_nPedType == 6 )
          {
            CCopPed::SetPartner(v16, v20);
            LOBYTE((*p_m_pCopPed)->m_pMyVehicle->pDriver[1].RandomSeed) = 1;
            v16 = *p_m_pCopPed;
          }
          v21 = v16->m_pPartner;
          if ( v21 )
          {
            if ( !v21->m_bIAmDriver )
              goto LABEL_44;
            TaskByType = CPedIntelligence::FindTaskByType(v21->m_pPedIntelligence, 1105);
            if ( TaskByType )
            {
              v23 = this->m_pCriminal;
              if ( (CPed *)TaskByType[1].m_pParent == v23 )
              {
                (*p_m_pCopPed)->m_bIAmDriver = 0;
                v24 = *p_m_pCopPed;
                v25 = *((_DWORD *)&(*p_m_pCopPed)->m_nPedFlags + 1);
                v26 = *((_DWORD *)&(*p_m_pCopPed)->m_nPedFlags + 2);
                v27 = *((_DWORD *)&(*p_m_pCopPed)->m_nPedFlags + 3);
                *(_DWORD *)&v24->m_nPedFlags = *(_DWORD *)&(*p_m_pCopPed)->m_nPedFlags | 0x20000000;
                *((_DWORD *)&v24->m_nPedFlags + 1) = v25;
                *((_DWORD *)&v24->m_nPedFlags + 2) = v26;
                *((_DWORD *)&v24->m_nPedFlags + 3) = v27;
                goto LABEL_44;
              }
            }
            else
            {
              v23 = this->m_pCriminal;
            }
            CEventAcquaintancePed::CEventAcquaintancePed(&v51, v23);
            v51.m_iTaskType = 1105;
            SubTask = 0;
            v51._vptr$CEvent = (int (**)(void))&off_665394;
            CEventGroup::Add(&(*p_m_pCopPed)->m_pPartner->m_pPedIntelligence->m_eventGroup, (CEvent *)&v51, 0);
            CEventAcquaintancePed::~CEventAcquaintancePed(&v51);
            return SubTask;
          }
          v16->m_bIAmDriver = 1;
          m_pSubTask = this->m_pSubTask;
          if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 704 )
          {
            SubTask = (CTaskComplexLeaveCar *)this->m_pSubTask;
            if ( SubTask )
              goto LABEL_50;
          }
          else
          {
            SubTask = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
            CTaskComplexLeaveCar::CTaskComplexLeaveCar(SubTask, pPed->m_pMyVehicle, 0, 0, 1, 0);
            if ( SubTask )
              goto LABEL_50;
          }
        }
LABEL_44:
        v29 = this->m_pCriminal;
        v30 = *((unsigned __int8 *)&v29->m_nPedFlags + 1) << 31 == 0;
        if ( *((unsigned __int8 *)&v29->m_nPedFlags + 1) << 31 )
          v30 = v29->m_pMyVehicle == 0;
        if ( !v30 )
        {
          v31 = 709;
          if ( (*p_m_pCopPed)->m_bIAmDriver )
            v31 = 724;
          goto LABEL_49;
        }
LABEL_48:
        v31 = 1000;
LABEL_49:
        SubTask = (CTaskComplexLeaveCar *)CTaskComplexKillCriminal::CreateSubTask(this, v31, pPed, 0);
LABEL_50:
        v32 = pPed->m_pMyVehicle;
        v33 = v32 == 0;
        if ( v32 )
          v33 = !(*p_m_pCopPed)->m_bIAmDriver;
        if ( !v33 )
        {
          this->m_origDrivingMode = v32->AutoPilot.DrivingMode;
          this->m_origMission = pPed->m_pMyVehicle->AutoPilot.Mission;
          CruiseSpeed = pPed->m_pMyVehicle->AutoPilot.CruiseSpeed;
          this->m_bSetUp = 1;
          this->m_origCruiseSpeed = CruiseSpeed;
        }
        v35 = this->m_pCriminal;
        v36 = v35->m_pMyVehicle;
        if ( v36 )
        {
          if ( (*((_BYTE *)&v36->m_nVehicleFlags + 6) & 8) != 0 )
          {
            if ( v36->m_nNumPassengers )
            {
              CPed::GiveWeapon(v35, WEAPONTYPE_PISTOL, 0x3E8u, 1);
              CPed::SetCurrentWeapon(this->m_pCriminal, WEAPONTYPE_PISTOL);
              v37 = this->m_pCriminal;
              v38 = v37->m_pMyVehicle;
              if ( v38->m_nMaxPassengers )
              {
                v39 = 0;
                do
                {
                  v40 = &v38->_vptr$CPlaceable + v39;
                  v41 = (CPed *)v40[282];
                  if ( v41 )
                  {
                    CPed::GiveWeapon((CPed *)v40[282], WEAPONTYPE_PISTOL, 0x3E8u, 1);
                    CPed::SetCurrentWeapon(v41, WEAPONTYPE_PISTOL);
                    CCopPed::AddCriminalToKill(this->m_pCopPed, v41);
                    v37 = this->m_pCriminal;
                  }
                  v38 = v37->m_pMyVehicle;
                  ++v39;
                }
                while ( v39 < v38->m_nMaxPassengers );
              }
            }
            else if ( (rand() & 1) != 0 )
            {
              CPed::GiveWeapon(this->m_pCriminal, WEAPONTYPE_PISTOL, 0x3E8u, 1);
              CPed::SetCurrentWeapon(this->m_pCriminal, WEAPONTYPE_PISTOL);
            }
          }
        }
        else if ( (rand() & 1) != 0 )
        {
          CPed::GiveWeapon(this->m_pCriminal, WEAPONTYPE_PISTOL, 0x3E8u, 1);
          CPed::SetCurrentWeapon(this->m_pCriminal, WEAPONTYPE_PISTOL);
          CEventAcquaintancePed::CEventAcquaintancePed(&v51, pPed);
          v51.m_iTaskType = 1000;
          v51._vptr$CEvent = (int (**)(void))&off_665394;
          CEventGroup::Add(&this->m_pCriminal->m_pPedIntelligence->m_eventGroup, (CEvent *)&v51, 0);
          CEventAcquaintancePed::~CEventAcquaintancePed(&v51);
        }
        v42 = pPed->m_pMyVehicle;
        v43 = CTimer::m_snTimeInMilliseconds;
        *((_DWORD *)&pPed->m_nPedFlags + 1) |= 0x40u;
        pPed->fRemoveRangeMultiplier = 0.3;
        pPed->DontUseSmallerRemovalRange = v43 + 300000;
        if ( v42 )
        {
          v42->ExtendedRemovalRange = 255;
          *((_DWORD *)&pPed->m_pMyVehicle->m_nVehicleFlags + 1) |= 0x40u;
          v44 = pPed->m_pMyVehicle;
          if ( v44 )
          {
            if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
              *((_DWORD *)&v44->m_nVehicleFlags + 1) |= 0x8000u;
          }
        }
        CInterestingEvents::Add(&g_InterestingEvents, ECopKillingCriminal, pPed);
        return SubTask;
      }
    }
    return 0;
  }
  return SubTask;
}
// 665394: using guessed type void *off_665394;
// 676218: using guessed type void *`vtable for'CEventAcquaintancePedHate;

//----- (0053E80C) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillCriminal::CreateSubTask(
        const CTaskComplexKillCriminal *this,
        const int iSubTaskType,
        CPed *pPed,
        bool bForce)
{
  CTask *m_pSubTask; // r0
  CTaskComplexEnterCarAsPassenger *v8; // r4
  CPed *v9; // r0
  CVehicle *m_pMyVehicle; // r0
  CPed *m_pCriminal; // r1
  bool v12; // zf
  int32 m_baseVehicleType; // r5
  CTaskComplexCarDriveMission *v15; // r0
  int v16; // r3

  if ( !bForce )
  {
    m_pSubTask = this->m_pSubTask;
    if ( m_pSubTask )
    {
      if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == iSubTaskType )
        return this->m_pSubTask;
    }
  }
  v8 = 0;
  if ( iSubTaskType < 1000 )
  {
    switch ( iSubTaskType )
    {
      case 700:
        v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(v8, pPed->m_pMyVehicle, 0, 0);
        break;
      case 701:
        v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
          (CTaskComplexEnterCarAsDriver *)v8,
          pPed->m_pMyVehicle);
        break;
      case 704:
        v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v8, pPed->m_pMyVehicle, 0, 0, 1, 0);
        break;
      case 709:
        v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x60u);
        CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v8, pPed->m_pMyVehicle, 0, 0);
        break;
      case 724:
        m_pMyVehicle = pPed->m_pMyVehicle;
        if ( m_pMyVehicle )
        {
          m_pCriminal = this->m_pCriminal;
          v12 = *((unsigned __int8 *)&m_pCriminal->m_nPedFlags + 1) << 31 == 0;
          if ( *((unsigned __int8 *)&m_pCriminal->m_nPedFlags + 1) << 31 )
            v12 = m_pCriminal->m_pMyVehicle == 0;
          if ( v12 )
          {
            v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x2Cu);
            CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(
              (CTaskComplexCarDriveMission *)v8,
              pPed->m_pMyVehicle,
              this->m_pCriminal,
              55,
              2,
              20.0);
          }
          else
          {
            m_baseVehicleType = m_pMyVehicle->m_baseVehicleType;
            v15 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
            v8 = (CTaskComplexEnterCarAsPassenger *)v15;
            if ( m_baseVehicleType == 9 )
              v16 = 53;
            else
              v16 = 18;
            CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(
              v15,
              pPed->m_pMyVehicle,
              this->m_pCriminal->m_pMyVehicle,
              v16,
              2,
              (float)this->m_pCriminal->m_pMyVehicle->AutoPilot.CruiseSpeed + 10.0);
          }
        }
        else
        {
          v8 = 0;
        }
        break;
      default:
        return v8;
    }
    return v8;
  }
  switch ( iSubTaskType )
  {
    case 1000:
      v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x38u);
      CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(
        (CTaskComplexKillPedOnFoot *)v8,
        this->m_pCriminal,
        -1,
        0,
        0,
        0,
        1);
LABEL_25:
      CPed::SetCurrentWeapon(pPed, WEAPONTYPE_PISTOL);
      return v8;
    case 1022:
      v8 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x44u);
      CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy((CTaskSimpleGangDriveBy *)v8, this->m_pCriminal, 0, 70.0, 70, 8, 0);
      goto LABEL_25;
    case 1302:
      v9 = this->m_pCriminal;
      if ( v9 )
        CPed::SetPedDefaultDecisionMaker(v9);
      return 0;
  }
  return v8;
}

//----- (0053E9BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillCriminal::CreateNextSubTask(CTaskComplexKillCriminal *this, CPed *pPed)
{
  CCopPed *m_pPartner; // r4
  int v5; // r0
  CTaskSimpleCarDrive *v6; // r6
  CTask *result; // r0
  int m_nPedFlags; // r0
  int v9; // r6
  CTask *v10; // r0
  CPed *v11; // r0
  CPed *v12; // r1
  _BOOL4 m_bIAmFinished; // r0
  CTask *m_pSubTask; // r0
  CPed *v15; // r0
  CCopPed *v16; // r1
  CPed *v17; // r2
  CPed *v18; // r3
  CPed *v19; // r3
  CPed *v20; // r3
  int v21; // r1
  CPed *v22; // r0
  CTask *v23; // r0
  CCopPed *v24; // r0
  CCopPed *m_pCopPed; // r1
  CPed *v26; // r2
  CPed *v27; // r3
  CPed *v28; // r3
  CPed *v29; // r3
  CPed *v30; // r1
  CPed *m_pCriminal; // r1
  bool v32; // zf
  CVehicle *m_pMyVehicle; // r0
  CMatrix *m_pMat; // r2
  CMatrix *v35; // r3
  CSimpleTransform *p_tx; // r4
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v38; // d16
  unsigned __int64 v39; // d1
  CVehicle *v40; // r0
  CPed *v41; // r0
  bool v42; // zf
  CMatrix *v43; // r1
  CMatrix *v44; // r2
  CSimpleTransform *v45; // r3
  CSimpleTransform *v46; // r0
  float32x2_t v47; // d16
  unsigned __int64 v48; // d1

  m_pPartner = this->m_pCopPed->m_pPartner;
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v6 = 0;
  if ( v5 < 704 )
  {
    if ( v5 == 700 )
    {
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
        goto LABEL_105;
    }
    else
    {
      if ( v5 != 701 )
        return v6;
      m_nPedFlags = (int)pPed->m_nPedFlags;
      if ( (m_nPedFlags & 0x100) != 0 )
      {
        if ( m_pPartner )
        {
          if ( m_pPartner->m_nHealth <= 0.0 )
            v9 = 1;
          else
            v9 = *((_BYTE *)&m_pPartner->m_nPedFlags + 1) & 1;
        }
        else
        {
          v9 = 1;
        }
        if ( !this->m_bIAmFinished )
        {
          m_pCriminal = this->m_pCriminal;
          if ( m_pCriminal )
          {
            if ( m_pCriminal->m_nHealth > 0.0 )
            {
              v32 = *((unsigned __int8 *)&m_pCriminal->m_nPedFlags + 1) << 31 == 0;
              if ( *((unsigned __int8 *)&m_pCriminal->m_nPedFlags + 1) << 31 )
                v32 = m_pCriminal->m_pMyVehicle == 0;
              if ( !v32 )
                goto LABEL_104;
              m_pMyVehicle = pPed->m_pMyVehicle;
              if ( m_pMyVehicle )
              {
                m_pMat = m_pCriminal->m_pMat;
                v35 = m_pMyVehicle->m_pMat;
                p_tx = (CSimpleTransform *)&m_pMat->tx;
                if ( !m_pMat )
                  p_tx = &m_pCriminal->m_transform;
                p_m_transform = (CSimpleTransform *)&v35->tx;
                if ( !v35 )
                  p_m_transform = &m_pMyVehicle->m_transform;
                v38.n64_u64[0] = vsub_f32(
                                   *(float32x2_t *)&p_m_transform->m_translate.y,
                                   *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
                v39 = vmul_f32(v38, v38).n64_u64[0];
                if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                           * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                                   + *(float *)&v39)
                           + *((float *)&v39 + 1)) > 625.0 )
                {
LABEL_104:
                  if ( v9 == 1 )
                    return CTaskComplexKillCriminal::CreateSubTask(this, 724, pPed, 0);
                  goto LABEL_105;
                }
              }
              goto LABEL_57;
            }
          }
        }
        m_pCopPed = this->m_pCopPed;
        v26 = m_pCopPed->m_aCriminalsImAfter[0];
        if ( v26 && v26->m_nHealth > 0.0 )
        {
          if ( v26 == this->m_pCriminal )
            v26 = 0;
        }
        else
        {
          v26 = 0;
        }
        v27 = m_pCopPed->m_aCriminalsImAfter[1];
        if ( v27 && v27->m_nHealth > 0.0 && v27 != this->m_pCriminal )
          v26 = m_pCopPed->m_aCriminalsImAfter[1];
        v28 = m_pCopPed->m_aCriminalsImAfter[2];
        if ( v28 && v28->m_nHealth > 0.0 && v28 != this->m_pCriminal )
          v26 = m_pCopPed->m_aCriminalsImAfter[2];
        v29 = m_pCopPed->m_aCriminalsImAfter[3];
        if ( v29 && v29->m_nHealth > 0.0 && v29 != this->m_pCriminal )
          v26 = m_pCopPed->m_aCriminalsImAfter[3];
        v30 = m_pCopPed->m_aCriminalsImAfter[4];
        if ( v30 && v30->m_nHealth > 0.0 && v30 != this->m_pCriminal || (v30 = v26) != 0 )
        {
          if ( CTaskComplexKillCriminal::ChangeTarget(this, v30) )
            goto LABEL_91;
          m_nPedFlags = (int)pPed->m_nPedFlags;
        }
        if ( (m_nPedFlags & 0x100) != 0 )
        {
          v40 = pPed->m_pMyVehicle;
          if ( v40 )
            *((_DWORD *)&v40->m_nVehicleFlags + 1) &= ~0x8000u;
        }
        m_pSubTask = this->m_pSubTask;
        if ( v9 != 1 )
        {
          if ( !m_pSubTask )
            goto LABEL_116;
LABEL_106:
          if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 709 )
            return this->m_pSubTask;
LABEL_116:
          v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
          CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
          return v6;
        }
        if ( !m_pSubTask )
          goto LABEL_27;
        goto LABEL_26;
      }
    }
    m_bIAmFinished = this->m_bIAmFinished;
    this->m_bCantGetInCar = 1;
    if ( !m_bIAmFinished )
    {
      v22 = this->m_pCriminal;
      if ( v22 )
      {
        if ( v22->m_nHealth > 0.0 )
        {
LABEL_57:
          v23 = this->m_pSubTask;
          if ( v23 && (*((int (__fastcall **)(CTask *))v23->_vptr$CTask + 5))(v23) == 1000 )
            return this->m_pSubTask;
          goto LABEL_91;
        }
      }
    }
    m_pSubTask = this->m_pSubTask;
    if ( !m_pSubTask )
    {
LABEL_27:
      v15 = this->m_pCriminal;
      if ( v15 )
        CPed::SetPedDefaultDecisionMaker(v15);
      return 0;
    }
LABEL_26:
    if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 1302 )
      return this->m_pSubTask;
    goto LABEL_27;
  }
  if ( v5 == 704 )
  {
    if ( pPed->m_pMyVehicle && !this->m_bCantGetInCar )
    {
      if ( this->m_bIAmFinished )
        goto LABEL_17;
      v41 = this->m_pCriminal;
      if ( !v41 || v41->m_nHealth <= 0.0 )
        goto LABEL_17;
      v42 = *((unsigned __int8 *)&v41->m_nPedFlags + 1) << 31 == 0;
      if ( *((unsigned __int8 *)&v41->m_nPedFlags + 1) << 31 )
        v42 = v41->m_pMyVehicle == 0;
      if ( !v42 )
        goto LABEL_17;
      v43 = v41->m_pMat;
      v44 = pPed->m_pMat;
      v45 = (CSimpleTransform *)&v43->tx;
      if ( !v43 )
        v45 = &v41->m_transform;
      v46 = (CSimpleTransform *)&v44->tx;
      if ( !v44 )
        v46 = &pPed->m_transform;
      v47.n64_u64[0] = vsub_f32(*(float32x2_t *)&v46->m_translate.y, *(float32x2_t *)&v45->m_translate.y).n64_u64[0];
      v48 = vmul_f32(v47, v47).n64_u64[0];
      if ( (float)((float)((float)((float)(v46->m_translate.x - v45->m_translate.x)
                                 * (float)(v46->m_translate.x - v45->m_translate.x))
                         + *(float *)&v48)
                 + *((float *)&v48 + 1)) > 625.0 )
      {
LABEL_17:
        v10 = this->m_pSubTask;
        if ( v10 && (*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 5))(v10) == 701 )
          return this->m_pSubTask;
        v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
          (CTaskComplexEnterCarAsDriver *)v6,
          pPed->m_pMyVehicle);
        return v6;
      }
    }
    goto LABEL_57;
  }
  if ( v5 != 1000 )
  {
    if ( v5 == 1022 )
    {
      if ( this->m_pCopPed->m_bIAmDriver )
        return CTaskComplexKillCriminal::CreateSubTask(this, 724, pPed, 0);
LABEL_105:
      m_pSubTask = this->m_pSubTask;
      if ( !m_pSubTask )
        goto LABEL_116;
      goto LABEL_106;
    }
    return v6;
  }
  v11 = this->m_pCriminal;
  if ( v11 && v11->m_nHealth > 0.0 )
  {
    v12 = this->m_pCriminal;
    goto LABEL_52;
  }
  v16 = this->m_pCopPed;
  v17 = v16->m_aCriminalsImAfter[0];
  if ( v17 && v17->m_nHealth > 0.0 )
  {
    if ( v17 == v11 )
      v17 = 0;
  }
  else
  {
    v17 = 0;
  }
  v18 = v16->m_aCriminalsImAfter[1];
  if ( v18 && v18->m_nHealth > 0.0 && v18 != v11 )
    v17 = v16->m_aCriminalsImAfter[1];
  v19 = v16->m_aCriminalsImAfter[2];
  if ( v19 && v19->m_nHealth > 0.0 && v19 != v11 )
    v17 = v16->m_aCriminalsImAfter[2];
  v20 = v16->m_aCriminalsImAfter[3];
  if ( v20 && v20->m_nHealth > 0.0 && v20 != v11 )
    v17 = v16->m_aCriminalsImAfter[3];
  v12 = v16->m_aCriminalsImAfter[4];
  if ( v12 && v12->m_nHealth > 0.0 && v12 != v11 || (v12 = v17) != 0 )
  {
LABEL_52:
    if ( !CTaskComplexKillCriminal::ChangeTarget(this, v12) )
      goto LABEL_53;
LABEL_91:
    v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x38u);
    CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(
      (CTaskComplexKillPedOnFoot *)v6,
      this->m_pCriminal,
      -1,
      0,
      0,
      0,
      1);
    CPed::SetCurrentWeapon(pPed, WEAPONTYPE_PISTOL);
    return v6;
  }
LABEL_53:
  if ( !this->m_bCantGetInCar && pPed->m_pMyVehicle )
  {
    v24 = this->m_pCopPed;
    if ( !v24->m_bIAmDriver )
    {
      if ( m_pPartner && m_pPartner->m_nHealth > 0.0 )
      {
        v21 = 700;
        goto LABEL_132;
      }
      v24->m_bIAmDriver = 1;
      CCopPed::SetPartner(this->m_pCopPed, 0);
    }
    v21 = 701;
    goto LABEL_132;
  }
  v21 = 1302;
LABEL_132:
  result = CTaskComplexKillCriminal::CreateSubTask(this, v21, pPed, 0);
  this->m_bIAmFinished = 1;
  return result;
}

//----- (0053EE84) --------------------------------------------------------
CPed *__fastcall CTaskComplexKillCriminal::FindNextCriminalToKill(
        CTaskComplexKillCriminal *this,
        CPed *pPed,
        bool bAny)
{
  float v3; // s0
  CPed *m_pCriminal; // r2
  CMatrix *m_pMat; // lr
  CMatrix *v6; // r12
  CSimpleTransform *p_tx; // r3
  float *p_x; // lr
  CPed *v9; // r12
  CPed **m_aCriminalsImAfter; // lr
  int i; // r2
  CPed *v12; // r3
  CMatrix *v13; // r4
  CMatrix *v14; // r5
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *v16; // r4
  float32x2_t v17; // d16
  unsigned __int64 v18; // d2

  v3 = 0.0;
  if ( !bAny )
  {
    m_pCriminal = this->m_pCriminal;
    if ( m_pCriminal )
    {
      if ( m_pCriminal->m_nHealth > 0.0 )
      {
        m_pMat = pPed->m_pMat;
        v6 = m_pCriminal->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_x = &v6->tx;
        if ( !v6 )
          p_x = &m_pCriminal->m_transform.m_translate.x;
        v3 = (float)((float)((float)(*p_x - p_tx->m_translate.x) * (float)(*p_x - p_tx->m_translate.x))
                   + (float)((float)(p_x[1] - p_tx->m_translate.y) * (float)(p_x[1] - p_tx->m_translate.y)))
           + (float)((float)(p_x[2] - p_tx->m_translate.z) * (float)(p_x[2] - p_tx->m_translate.z));
      }
    }
  }
  v9 = 0;
  m_aCriminalsImAfter = this->m_pCopPed->m_aCriminalsImAfter;
  for ( i = 0; i != 5; ++i )
  {
    v12 = m_aCriminalsImAfter[i];
    if ( v12 && v12->m_nHealth > 0.0 && v12 != this->m_pCriminal )
    {
      v13 = pPed->m_pMat;
      v14 = v12->m_pMat;
      p_m_transform = (CSimpleTransform *)&v13->tx;
      if ( !v13 )
        p_m_transform = &pPed->m_transform;
      v16 = (CSimpleTransform *)&v14->tx;
      if ( !v14 )
        v16 = &v12->m_transform;
      v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&v16->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
      v18 = vmul_f32(v17, v17).n64_u64[0];
      if ( (float)((float)((float)((float)(v16->m_translate.x - p_m_transform->m_translate.x)
                                 * (float)(v16->m_translate.x - p_m_transform->m_translate.x))
                         + *(float *)&v18)
                 + *((float *)&v18 + 1)) < v3 )
        v9 = m_aCriminalsImAfter[i];
      if ( v3 == 0.0 )
        v9 = m_aCriminalsImAfter[i];
    }
  }
  return v9;
}

//----- (0053EF98) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillCriminal::ControlSubTask(CTaskComplexKillCriminal *this, CPed *pPed)
{
  CPed *m_pCriminal; // r0
  CPed **p_m_pCriminal; // r10
  CTask *v5; // r4
  int m_nPedType; // r1
  CWanted *PlayerWanted; // r0
  CTask *v8; // r5
  int v9; // r0
  CCopPed *m_pCopPed; // r0
  CCopPed *m_pPartner; // r6
  int v12; // r9
  CPed *v13; // r0
  CVehicle **p_m_pMyVehicle; // r8
  CVehicle *m_pMyVehicle; // r1
  bool v16; // zf
  float *v17; // r1
  bool v18; // zf
  int v19; // r1
  CVehicle *v20; // r1
  CMatrix *v21; // r3
  CMatrix *v22; // r2
  CSimpleTransform *v23; // r6
  float *v24; // r2
  float x; // s0
  float y; // s4
  float z; // s2
  CMatrix *v28; // r0
  float *v29; // r2
  CPed *v30; // r1
  CCopPed *v32; // r1
  CPed *v33; // r0
  CPed *v34; // r2
  CPed *v35; // r2
  CPed *v36; // r2
  CPed *v37; // r1
  int m_nPedFlags; // r0
  bool v39; // zf
  CPed *v40; // r0
  int v41; // r4
  bool v42; // zf
  CVehicle *v43; // r0
  bool v44; // zf
  CMatrix *v45; // r2
  CMatrix *v46; // r1
  CSimpleTransform *v47; // r3
  CSimpleTransform *v48; // r1
  float32x2_t v49; // d16
  unsigned __int64 v50; // d1
  int v51; // r8
  CPed *v52; // r9
  bool v53; // zf
  CTaskSimpleGangDriveBy *v54; // r6
  CVehicle *v55; // r0
  float v56; // s16
  bool v57; // zf
  CMatrix *v58; // r2
  CMatrix *v59; // r1
  CSimpleTransform *v60; // r3
  float *p_x; // r1
  float v62; // s0
  float v63; // s4
  float v64; // s2
  CMatrix *v65; // r0
  float *v66; // r1
  int v67; // r2
  CTask *v68; // r12
  CMatrix *v69; // r3
  float *v70; // r4
  float *v71; // r2
  float v72; // s0
  int v73; // r0
  CPed *v74; // r0
  float *v75; // r1
  float v76; // s0
  CVehicle *v77; // r0
  CMatrix *v78; // r2
  CMatrix *v79; // r3
  int v80; // r6
  CSimpleTransform *v81; // r1
  float32x2_t v82; // d16
  unsigned __int64 v83; // d1
  CPed *NextCriminalToKill; // r1
  CVehicle *v85; // r0
  CMatrix *m_pMat; // r2
  CMatrix *v87; // r6
  int p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v90; // d16
  unsigned __int64 v91; // d1
  float v92; // s2
  CMatrix *v93; // r2
  CMatrix *v94; // r3
  CSimpleTransform *v95; // r6
  int v96; // r0
  float32x2_t v97; // d16
  unsigned __int64 v98; // d1
  CPed *v99; // r0
  int16 v100; // r1
  const CPed *pDriver; // r0
  bool v102; // zf
  CPed *v103; // r0
  CVehicle *v104; // r1
  int v105; // r8
  int (***v106)(void); // r1
  CPed *v107; // r6
  bool v108; // zf
  int v109; // r0
  CMatrix *v110; // r2
  CMatrix *v111; // r3
  int v112; // r6
  int v113; // r0
  float32x2_t v114; // d16
  unsigned __int64 v115; // d1
  bool v116; // zf
  CEntity **v117; // r1
  CEventAcquaintancePed v119; // [sp+14h] [bp-44h] BYREF

  p_m_pCriminal = &this->m_pCriminal;
  m_pCriminal = this->m_pCriminal;
  v5 = (CTask *)*(p_m_pCriminal - 1);
  if ( m_pCriminal )
  {
    if ( CPed::IsPlayer(m_pCriminal) )
      return 0;
    m_nPedType = (*p_m_pCriminal)->m_nPedType;
    if ( (unsigned int)m_nPedType <= 0x13 && ((1 << m_nPedType) & (unsigned int)"eObjectCarriedWithRopeEv") != 0 )
      return 0;
    if ( m_nPedType > 23 || (*p_m_pCriminal)->CharCreatedBy == 2 )
      return 0;
  }
  if ( FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel == WANTED_CLEAN
    || (PlayerWanted = FindPlayerWanted(-1), !CWanted::CanCopJoinPursuit(PlayerWanted, (CCopPed *)pPed)) )
  {
    if ( g_LoadMonitor.m_bEnableAmbientCrime )
      goto LABEL_13;
    return 0;
  }
  v8 = 0;
  v9 = (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0);
  if ( !g_LoadMonitor.m_bEnableAmbientCrime || v9 )
    return v8;
LABEL_13:
  m_pCopPed = this->m_pCopPed;
  m_pPartner = m_pCopPed->m_pPartner;
  if ( m_pCopPed->m_bIAmDriver
    || m_pPartner && m_pPartner->m_nHealth > 0.0
    || (m_pCopPed->m_bIAmDriver = 1,
        CCopPed::SetPartner(this->m_pCopPed, 0),
        !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31)) )
  {
    v12 = 200;
  }
  else
  {
    v12 = 704;
    if ( !pPed->m_pMyVehicle )
      v12 = 200;
  }
  if ( pPed->m_nHealth <= 0.0 )
  {
LABEL_88:
    v12 = 1302;
    goto LABEL_89;
  }
  v13 = *p_m_pCriminal;
  if ( !*p_m_pCriminal || v13->m_nHealth <= 0.0 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1000 )
      goto LABEL_89;
    v32 = this->m_pCopPed;
    v33 = v32->m_aCriminalsImAfter[0];
    if ( v33 && v33->m_nHealth > 0.0 )
    {
      if ( v33 == *p_m_pCriminal )
        v33 = 0;
    }
    else
    {
      v33 = 0;
    }
    v34 = v32->m_aCriminalsImAfter[1];
    if ( v34 && v34->m_nHealth > 0.0 && v34 != *p_m_pCriminal )
      v33 = v32->m_aCriminalsImAfter[1];
    v35 = v32->m_aCriminalsImAfter[2];
    if ( v35 && v35->m_nHealth > 0.0 && v35 != *p_m_pCriminal )
      v33 = v32->m_aCriminalsImAfter[2];
    v36 = v32->m_aCriminalsImAfter[3];
    if ( v36 && v36->m_nHealth > 0.0 && v36 != *p_m_pCriminal )
      v33 = v32->m_aCriminalsImAfter[3];
    if ( ((v37 = v32->m_aCriminalsImAfter[4]) != 0 && v37->m_nHealth > 0.0 && v37 != *p_m_pCriminal || (v37 = v33) != 0)
      && CTaskComplexKillCriminal::ChangeTarget(this, v37) )
    {
      goto LABEL_89;
    }
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 700
      || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 701 )
    {
      goto LABEL_89;
    }
    m_nPedFlags = (int)pPed->m_nPedFlags;
    if ( pPed->m_pMyVehicle )
    {
      v39 = (*(_DWORD *)&pPed->m_nPedFlags & 0x100) == 0;
      if ( (m_nPedFlags & 0x100) == 0 )
        v39 = !this->m_bCantGetInCar;
      if ( v39 )
      {
        v12 = 700;
        if ( this->m_pCopPed->m_bIAmDriver )
          v12 = 701;
        goto LABEL_89;
      }
    }
    if ( (m_nPedFlags & 0x100) != 0
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 709
      && m_pPartner
      && m_pPartner->m_nHealth > 0.0 )
    {
      if ( *((unsigned __int8 *)&m_pPartner->m_nPedFlags + 1) << 31 )
        v12 = 1302;
      goto LABEL_89;
    }
    goto LABEL_88;
  }
  if ( this->m_pCopPed->m_bIAmDriver )
  {
    p_m_pMyVehicle = &pPed->m_pMyVehicle;
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      *((_DWORD *)&m_pMyVehicle->m_nVehicleFlags + 1) |= 0x8000u;
      v13 = *p_m_pCriminal;
    }
    v17 = (float *)(*((unsigned __int8 *)&v13->m_nPedFlags + 1) << 31);
    v16 = v17 == 0;
    if ( v17 )
    {
      v17 = (float *)v13->m_pMyVehicle;
      v16 = v17 == 0;
    }
    if ( !v16 )
    {
      v56 = v17[307];
      v57 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
        v57 = *p_m_pMyVehicle == 0;
      if ( v57 )
      {
        if ( sqrtf((float)((float)(v17[18] * v17[18]) + (float)(v17[19] * v17[19])) + (float)(v17[20] * v17[20])) >= 0.2 )
        {
          if ( *p_m_pMyVehicle
            && !this->m_bCantGetInCar
            && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 701
            && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 700 )
          {
            v85 = (*p_m_pCriminal)->m_pMyVehicle;
            m_pMat = (*p_m_pMyVehicle)->m_pMat;
            v87 = v85->m_pMat;
            p_tx = (int)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = (int)&(*p_m_pMyVehicle)->m_transform;
            p_m_transform = (CSimpleTransform *)&v87->tx;
            if ( !v87 )
              p_m_transform = &v85->m_transform;
            v90.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)(p_tx + 4)).n64_u64[0];
            v91 = vmul_f32(v90, v90).n64_u64[0];
            if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - *(float *)p_tx)
                                       * (float)(p_m_transform->m_translate.x - *(float *)p_tx))
                               + *(float *)&v91)
                       + *((float *)&v91 + 1)) > 400.0
              || sqrtf(
                   (float)((float)(v85->m_vecMoveSpeed.x * v85->m_vecMoveSpeed.x)
                         + (float)(v85->m_vecMoveSpeed.y * v85->m_vecMoveSpeed.y))
                 + (float)(v85->m_vecMoveSpeed.z * v85->m_vecMoveSpeed.z)) >= 0.2 )
            {
              v12 = 700;
              if ( this->m_pCopPed->m_bIAmDriver )
                v12 = 701;
            }
          }
        }
        else
        {
          v58 = v13->m_pMat;
          v59 = pPed->m_pMat;
          v60 = (CSimpleTransform *)&v59->tx;
          if ( !v59 )
            v60 = &pPed->m_transform;
          p_x = &v58->tx;
          if ( !v58 )
            p_x = &v13->m_transform.m_translate.x;
          v62 = *p_x;
          v63 = p_x[1];
          v64 = p_x[2];
          if ( (float)((float)((float)((float)(*p_x - v60->m_translate.x) * (float)(*p_x - v60->m_translate.x))
                             + (float)((float)(v63 - v60->m_translate.y) * (float)(v63 - v60->m_translate.y)))
                     + (float)((float)(v64 - v60->m_translate.z) * (float)(v64 - v60->m_translate.z))) < 36.0 )
            goto LABEL_200;
          if ( m_pPartner && !(*((unsigned __int8 *)&m_pPartner->m_nPedFlags + 1) << 31) )
          {
            v65 = m_pPartner->m_pMat;
            v66 = &v65->tx;
            if ( !v65 )
              v66 = &m_pPartner->m_transform.m_translate.x;
            if ( (float)((float)((float)((float)(v62 - *v66) * (float)(v62 - *v66))
                               + (float)((float)(v63 - v66[1]) * (float)(v63 - v66[1])))
                       + (float)((float)(v64 - v66[2]) * (float)(v64 - v66[2]))) < 36.0 )
            {
LABEL_200:
              CEventAcquaintancePed::CEventAcquaintancePed(&v119, pPed);
              v119._vptr$CEvent = (int (**)(void))&off_665394;
              v99 = *p_m_pCriminal;
              v100 = 1030;
              if ( (*p_m_pCriminal)->m_pMyVehicle->m_nHealth < 250.0 )
                v100 = 704;
              v119.m_iTaskType = v100;
              CEventGroup::Add(&v99->m_pPedIntelligence->m_eventGroup, (CEvent *)&v119, 0);
              CPed::SetPedDefaultDecisionMaker(*p_m_pCriminal);
              pDriver = (*p_m_pCriminal)->m_pMyVehicle->pDriver;
              v102 = *p_m_pCriminal == pDriver;
              if ( *p_m_pCriminal != pDriver )
                v102 = pDriver == 0;
              if ( !v102 && !CPed::IsPlayer(pDriver) )
                CEventGroup::Add(
                  &(*p_m_pCriminal)->m_pMyVehicle->pDriver->m_pPedIntelligence->m_eventGroup,
                  (CEvent *)&v119,
                  0);
              v103 = *p_m_pCriminal;
              v104 = (*p_m_pCriminal)->m_pMyVehicle;
              if ( v104->m_nMaxPassengers )
              {
                v105 = 0;
                do
                {
                  v106 = &v104->_vptr$CPlaceable + v105;
                  v107 = (CPed *)v106[282];
                  v108 = v107 == 0;
                  if ( v107 )
                    v108 = v107 == v103;
                  if ( !v108 && !CPed::IsPlayer((const CPed *)v106[282]) )
                  {
                    CEventGroup::Add(&v107->m_pPedIntelligence->m_eventGroup, (CEvent *)&v119, 0);
                    CPed::SetPedDefaultDecisionMaker(v107);
                  }
                  v103 = *p_m_pCriminal;
                  ++v105;
                  v104 = (*p_m_pCriminal)->m_pMyVehicle;
                }
                while ( v105 < v104->m_nMaxPassengers );
              }
              CEventAcquaintancePed::~CEventAcquaintancePed(&v119);
              p_m_pMyVehicle = &pPed->m_pMyVehicle;
              goto LABEL_216;
            }
          }
        }
      }
      else if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 724
             || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1022 )
      {
        v74 = *p_m_pCriminal;
        v75 = (float *)(*p_m_pCriminal)->m_pMyVehicle;
        if ( sqrtf((float)((float)(v75[18] * v75[18]) + (float)(v75[19] * v75[19])) + (float)(v75[20] * v75[20])) >= 0.12 )
        {
          this->m_timeToGetOutOfCar = 1.0;
        }
        else
        {
          v76 = this->m_timeToGetOutOfCar + (float)(CTimer::ms_fTimeStep / -50.0);
          this->m_timeToGetOutOfCar = v76;
          if ( v76 <= 0.0 && CEventHandler::GetCurrentEventType(&v74->m_pPedIntelligence->m_eventHandler) != 36 )
          {
            v77 = (*p_m_pCriminal)->m_pMyVehicle;
            v78 = (*p_m_pMyVehicle)->m_pMat;
            v79 = v77->m_pMat;
            v80 = (int)&v78->tx;
            if ( !v78 )
              v80 = (int)&(*p_m_pMyVehicle)->m_transform;
            v81 = (CSimpleTransform *)&v79->tx;
            if ( !v79 )
              v81 = &v77->m_transform;
            v82.n64_u64[0] = vsub_f32(*(float32x2_t *)&v81->m_translate.y, *(float32x2_t *)(v80 + 4)).n64_u64[0];
            v83 = vmul_f32(v82, v82).n64_u64[0];
            if ( (float)((float)((float)((float)(v81->m_translate.x - *(float *)v80)
                                       * (float)(v81->m_translate.x - *(float *)v80))
                               + *(float *)&v83)
                       + *((float *)&v83 + 1)) < 225.0 )
            {
              NextCriminalToKill = CTaskComplexKillCriminal::FindNextCriminalToKill(this, pPed, 0);
              if ( NextCriminalToKill )
                CTaskComplexKillCriminal::ChangeTarget(this, NextCriminalToKill);
              v12 = 1000;
            }
          }
        }
      }
      else if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 709
             && (!m_pPartner || m_pPartner->m_nHealth <= 0.0 || *((unsigned __int8 *)&m_pPartner->m_nPedFlags + 1) << 31) )
      {
        v12 = 724;
      }
      if ( v56 >= 250.0 )
        goto LABEL_216;
      goto LABEL_200;
    }
    v19 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31;
    v18 = v19 == 0;
    if ( v19 )
    {
      v19 = (int)*p_m_pMyVehicle;
      v18 = *p_m_pMyVehicle == 0;
    }
    if ( !v18 )
    {
      v67 = *(_DWORD *)(v19 + 20);
      v68 = v5;
      v69 = v13->m_pMat;
      v70 = (float *)(v67 + 48);
      if ( !v67 )
        v70 = (float *)(v19 + 4);
      v71 = &v69->tx;
      if ( !v69 )
        v71 = &v13->m_transform.m_translate.x;
      v72 = (float)((float)((float)(*v71 - *v70) * (float)(*v71 - *v70))
                  + (float)((float)(v71[1] - v70[1]) * (float)(v71[1] - v70[1])))
          + (float)((float)(v71[2] - v70[2]) * (float)(v71[2] - v70[2]));
      if ( m_pPartner && m_pPartner->m_nHealth > 0.0 )
        v73 = *((_BYTE *)&m_pPartner->m_nPedFlags + 1) & 1;
      else
        v73 = 1;
      v5 = v68;
      if ( v72 <= 225.0 )
      {
        v92 = 16.0;
        if ( *(_DWORD *)(v19 + 1440) == 9 )
          v92 = 5.0;
        if ( v72 < v92 )
          v12 = 1000;
        if ( (*(_BYTE *)(v19 + 958) & 0xFE) != 54 )
          v12 = 1000;
      }
      else if ( v73 )
      {
        v12 = 724;
      }
      goto LABEL_216;
    }
    if ( !this->m_bCantGetInCar )
    {
      v20 = *p_m_pMyVehicle;
      if ( !*p_m_pMyVehicle )
        goto LABEL_89;
      v21 = v13->m_pMat;
      v22 = pPed->m_pMat;
      v23 = (CSimpleTransform *)&v22->tx;
      if ( !v22 )
        v23 = &pPed->m_transform;
      v24 = &v21->tx;
      x = v23->m_translate.x;
      y = v23->m_translate.y;
      z = v23->m_translate.z;
      if ( !v21 )
        v24 = &v13->m_transform.m_translate.x;
      if ( (float)((float)((float)((float)(*v24 - x) * (float)(*v24 - x))
                         + (float)((float)(v24[1] - y) * (float)(v24[1] - y)))
                 + (float)((float)(v24[2] - z) * (float)(v24[2] - z))) > 625.0 )
        goto LABEL_40;
      v28 = v20->m_pMat;
      v29 = &v28->tx;
      if ( !v28 )
        v29 = &v20->m_transform.m_translate.x;
      if ( (float)((float)((float)((float)(*v29 - x) * (float)(*v29 - x))
                         + (float)((float)(v29[1] - y) * (float)(v29[1] - y)))
                 + (float)((float)(v29[2] - z) * (float)(v29[2] - z))) > 250.0 )
      {
LABEL_40:
        v30 = CTaskComplexKillCriminal::FindNextCriminalToKill(this, pPed, 0);
        if ( !v30 || !CTaskComplexKillCriminal::ChangeTarget(this, v30) )
        {
          v12 = 701;
          goto LABEL_216;
        }
LABEL_115:
        v12 = 1000;
      }
    }
  }
  else
  {
    if ( !(*((unsigned __int8 *)&m_pPartner->m_nPedFlags + 1) << 31)
      && !CPedIntelligence::FindTaskByType(m_pPartner->m_pPedIntelligence, 701) )
    {
      v12 = 1000;
      p_m_pMyVehicle = &pPed->m_pMyVehicle;
      goto LABEL_216;
    }
    v55 = pPed->m_pMyVehicle;
    if ( !v55 )
    {
      v12 = 1000;
      goto LABEL_89;
    }
    p_m_pMyVehicle = &pPed->m_pMyVehicle;
    if ( this->m_bCantGetInCar )
      goto LABEL_115;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      v12 = 709;
      if ( *((unsigned __int8 *)&m_pPartner->m_nPedFlags + 1) << 31 )
      {
        v93 = v55->m_pMat;
        v94 = (*p_m_pCriminal)->m_pMat;
        v95 = (CSimpleTransform *)&v93->tx;
        if ( !v93 )
          v95 = &v55->m_transform;
        v96 = (int)&v94->tx;
        if ( !v94 )
          v96 = (int)&(*p_m_pCriminal)->m_transform;
        v97.n64_u64[0] = vsub_f32(*(float32x2_t *)(v96 + 4), *(float32x2_t *)&v95->m_translate.y).n64_u64[0];
        v98 = vmul_f32(v97, v97).n64_u64[0];
        if ( sqrtf(
               (float)((float)((float)(*(float *)v96 - v95->m_translate.x) * (float)(*(float *)v96 - v95->m_translate.x))
                     + *(float *)&v98)
             + *((float *)&v98 + 1)) < 60.0 )
          v12 = 1022;
      }
    }
    else
    {
      v12 = 700;
    }
  }
LABEL_216:
  if ( *p_m_pMyVehicle && (*p_m_pMyVehicle)->m_baseVehicleType == 9 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 724 )
    {
      if ( v12 == 200 )
        goto LABEL_222;
      v109 = 1022;
      if ( v12 == 1022 )
      {
LABEL_231:
        v116 = *((unsigned __int8 *)&(*p_m_pCriminal)->m_nPedFlags + 1) << 31 == 0;
        if ( *((unsigned __int8 *)&(*p_m_pCriminal)->m_nPedFlags + 1) << 31 )
          v116 = (*p_m_pCriminal)->m_pMyVehicle == 0;
        (*p_m_pMyVehicle)->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&(*p_m_pMyVehicle)->m_info & 7 | 0x18);
        if ( v116 )
        {
          (*p_m_pMyVehicle)->AutoPilot.Mission = 55;
          (*p_m_pMyVehicle)->AutoPilot.CruiseSpeed = 20;
          (*p_m_pMyVehicle)->AutoPilot.ActualSpeed = (float)(*p_m_pMyVehicle)->AutoPilot.CruiseSpeed;
          (*p_m_pMyVehicle)->AutoPilot.DrivingMode = 2;
          v117 = p_m_pCriminal;
        }
        else
        {
          (*p_m_pMyVehicle)->AutoPilot.Mission = 53;
          (*p_m_pMyVehicle)->AutoPilot.CruiseSpeed = (*p_m_pCriminal)->m_pMyVehicle->AutoPilot.CruiseSpeed + 10;
          (*p_m_pMyVehicle)->AutoPilot.ActualSpeed = (float)(*p_m_pMyVehicle)->AutoPilot.CruiseSpeed;
          (*p_m_pMyVehicle)->AutoPilot.DrivingMode = 2;
          v117 = &(*p_m_pCriminal)->m_pMyVehicle;
        }
        v12 = v109;
        (*p_m_pMyVehicle)->AutoPilot.pTargetEntity = *v117;
        goto LABEL_89;
      }
      if ( v12 == 724 )
      {
LABEL_222:
        v110 = (*p_m_pMyVehicle)->m_pMat;
        v111 = (*p_m_pCriminal)->m_pMat;
        v112 = (int)&v110->tx;
        if ( !v110 )
          v112 = (int)&(*p_m_pMyVehicle)->m_transform;
        v113 = (int)&v111->tx;
        if ( !v111 )
          v113 = (int)&(*p_m_pCriminal)->m_transform;
        v114.n64_u64[0] = vsub_f32(*(float32x2_t *)(v113 + 4), *(float32x2_t *)(v112 + 4)).n64_u64[0];
        v115 = vmul_f32(v114, v114).n64_u64[0];
        if ( sqrtf(
               (float)((float)((float)(*(float *)v113 - *(float *)v112) * (float)(*(float *)v113 - *(float *)v112))
                     + *(float *)&v115)
             + *((float *)&v115 + 1)) < 60.0 )
        {
          v109 = 1022;
          goto LABEL_231;
        }
      }
    }
    else
    {
      v109 = 1022;
      if ( v12 == 1022 )
        goto LABEL_231;
    }
    v16 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1022;
    v109 = v12;
    if ( v16 )
      goto LABEL_231;
  }
LABEL_89:
  v40 = *p_m_pCriminal;
  v8 = v5;
  v41 = v12;
  v42 = *p_m_pCriminal == 0;
  if ( *p_m_pCriminal )
    v42 = *((unsigned __int8 *)&v40->m_nPedFlags + 1) << 31 == 0;
  if ( !v42 )
  {
    v43 = v40->m_pMyVehicle;
    v44 = v43 == 0;
    if ( v43 )
      v44 = v43->m_nNumPassengers == 0;
    if ( !v44 )
    {
      v45 = v43->m_pMat;
      v46 = pPed->m_pMat;
      v47 = (CSimpleTransform *)&v46->tx;
      if ( !v46 )
        v47 = &pPed->m_transform;
      v48 = (CSimpleTransform *)&v45->tx;
      if ( !v45 )
        v48 = &v43->m_transform;
      v49.n64_u64[0] = vsub_f32(*(float32x2_t *)&v48->m_translate.y, *(float32x2_t *)&v47->m_translate.y).n64_u64[0];
      v50 = vmul_f32(v49, v49).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(v48->m_translate.x - v47->m_translate.x)
                           * (float)(v48->m_translate.x - v47->m_translate.x))
                   + *(float *)&v50)
           + *((float *)&v50 + 1)) < 60.0
        && v43->m_nMaxPassengers )
      {
        v51 = 0;
        do
        {
          v52 = v43->pPassengers[v51];
          v53 = v52 == 0;
          if ( v52 )
            v53 = *((unsigned __int8 *)&v52->m_nPedFlags + 1) << 31 == 0;
          if ( !v53 && !CPedIntelligence::FindTaskByType(v52->m_pPedIntelligence, 1022) )
          {
            v54 = (CTaskSimpleGangDriveBy *)CTask::operator new(0x44u);
            CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(v54, pPed, 0, 70.0, 70, 8, 0);
            CTaskManager::SetTask(&v52->m_pPedIntelligence->m_taskManager, v54, 3, 0);
          }
          ++v51;
          v43 = (*p_m_pCriminal)->m_pMyVehicle;
        }
        while ( v51 < v43->m_nMaxPassengers );
      }
    }
  }
  if ( v41 != 200
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
  {
    return CTaskComplexKillCriminal::CreateSubTask(this, v41, pPed, 0);
  }
  return v8;
}
// 665394: using guessed type void *off_665394;
// 676218: using guessed type void *`vtable for'CEventAcquaintancePedHate;

//----- (0053FC2C) --------------------------------------------------------
void __fastcall CTaskComplexCopInCar::CTaskComplexCopInCar(
        CTaskComplexCopInCar *this,
        CVehicle *pCopVehicle,
        CPed *pColleague,
        CPed *pTargetPed,
        bool bIsDriver)
{
  char v9; // r3
  CEntity **p_m_pTargetPed; // r6

  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_DriverGetOutTimer.m_bIsActive = 0;
  *(_WORD *)&this->m_NextPursuitAttemptTimer.m_bIsActive = 0;
  this->m_NextPursuitAttemptTimer.m_iStartTime = 0;
  this->m_NextPursuitAttemptTimer.m_iDuration = 0;
  v9 = *((_BYTE *)this + 48);
  this->m_DriverGetOutTimer.m_iStartTime = 0;
  this->m_DriverGetOutTimer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D078;
  *((_BYTE *)this + 48) = v9 & 0xFA | bIsDriver | 4;
  this->m_pTargetPed = pTargetPed;
  p_m_pTargetPed = &this->m_pTargetPed;
  this->m_pColleague = pColleague;
  this->m_pCopVehicle = pCopVehicle;
  if ( pCopVehicle )
  {
    CEntity::RegisterReference(pCopVehicle, &this->m_pCopVehicle);
    pColleague = this->m_pColleague;
  }
  if ( pColleague )
    CEntity::RegisterReference(pColleague, &this->m_pColleague);
  if ( *p_m_pTargetPed )
    CEntity::RegisterReference(*p_m_pTargetPed, &this->m_pTargetPed);
}
// 66D078: using guessed type void *;

//----- (0053FCB8) --------------------------------------------------------
void __fastcall CTaskComplexCopInCar::~CTaskComplexCopInCar(CTaskComplexCopInCar *this)
{
  CVehicle *m_pCopVehicle; // r0
  CEntity **p_m_pCopVehicle; // r1
  CPed *m_pColleague; // r0
  CPed *m_pTargetPed; // r0

  p_m_pCopVehicle = &this->m_pCopVehicle;
  m_pCopVehicle = this->m_pCopVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66D078;
  if ( m_pCopVehicle )
    CEntity::CleanUpOldReference(m_pCopVehicle, p_m_pCopVehicle);
  m_pColleague = this->m_pColleague;
  if ( m_pColleague )
    CEntity::CleanUpOldReference(m_pColleague, &this->m_pColleague);
  m_pTargetPed = this->m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, &this->m_pTargetPed);
  sub_18EDB4(this);
}
// 66D078: using guessed type void *off_66D078;

//----- (0053FD00) --------------------------------------------------------
void __fastcall CTaskComplexCopInCar::~CTaskComplexCopInCar(CTaskComplexCopInCar *this)
{
  CVehicle *m_pCopVehicle; // r0
  CEntity **p_m_pCopVehicle; // r1
  CPed *m_pColleague; // r0
  CPed *m_pTargetPed; // r0
  void *v6; // r0

  p_m_pCopVehicle = &this->m_pCopVehicle;
  m_pCopVehicle = this->m_pCopVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66D078;
  if ( m_pCopVehicle )
    CEntity::CleanUpOldReference(m_pCopVehicle, p_m_pCopVehicle);
  m_pColleague = this->m_pColleague;
  if ( m_pColleague )
    CEntity::CleanUpOldReference(m_pColleague, &this->m_pColleague);
  m_pTargetPed = this->m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, &this->m_pTargetPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 53FD44: variable 'v6' is possibly undefined
// 66D078: using guessed type void *off_66D078;

//----- (0053FD4C) --------------------------------------------------------
bool __fastcall CTaskComplexCopInCar::MakeAbortable(
        CTaskComplexCopInCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0
  int v8; // r0
  bool v9; // zf
  CVehicle *m_pCopVehicle; // r2

  m_pSubTask = this->m_pSubTask;
  if ( !m_pSubTask )
  {
LABEL_10:
    LOBYTE(v8) = 1;
    return v8;
  }
  v8 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
         m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  if ( pEvent && v8 == 1 )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 9
      || !LOBYTE(pEvent[5]._vptr$CEvent) )
    {
      goto LABEL_10;
    }
    v9 = !*(&pEvent->m_bIsPersistent + 1);
    if ( *(&pEvent->m_bIsPersistent + 1) )
      v9 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( v9 )
      goto LABEL_10;
    m_pCopVehicle = this->m_pCopVehicle;
    LOBYTE(v8) = 1;
    if ( pPed->m_pMyVehicle == m_pCopVehicle )
    {
      if ( m_pCopVehicle )
      {
        if ( CVehicle::IsDriver(pPed->m_pMyVehicle, pPed) )
        {
          this->m_pCopVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_pCopVehicle->m_info & 7 | 0x20);
          this->m_pCopVehicle->AutoPilot.Mission = 0;
          this->m_pCopVehicle->AutoPilot.CruiseSpeed = 0;
        }
        goto LABEL_10;
      }
    }
  }
  return v8;
}

//----- (0053FDD4) --------------------------------------------------------
CTask *__fastcall CTaskComplexCopInCar::CreateFirstSubTask(CTaskComplexCopInCar *this, CPed *pPed)
{
  CTaskSimpleCarDrive *v3; // r0
  CTask *result; // r0

  CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, 6);
  if ( !this->m_pColleague )
    *((_BYTE *)this + 48) |= 1u;
  v3 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  sub_18D108(v3, this->m_pCopVehicle, 0, 0);
  return result;
}

//----- (0053FE0C) --------------------------------------------------------
CTask *__fastcall CTaskComplexCopInCar::CreateSubTask(
        const CTaskComplexCopInCar *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v4; // r4
  char v5; // r2
  CVehicle **p_m_pCopVehicle; // r6
  int PoliceCarMissionForWantedLevel; // r8
  float PoliceCarSpeedForWantedLevel; // s16
  unsigned __int16 v9; // r0
  CTaskComplexCarDriveMission *v10; // r0
  CPed *m_pTargetPed; // r2

  v4 = 0;
  if ( iSubTaskType >= 912 )
  {
    if ( iSubTaskType == 912 )
    {
      v4 = (char *)CTask::operator new(0x50u);
      v9 = rand();
      CTaskComplexWander::CTaskComplexWander(
        (CTaskComplexWander *)v4,
        4,
        (int)(float)((float)((float)v9 * 0.000015259) * 8.0),
        1,
        0.5);
      *((_QWORD *)v4 + 7) = 0LL;
      *((_QWORD *)v4 + 8) = 0LL;
      *(_DWORD *)(v4 + 50) = 0;
      *(_DWORD *)(v4 + 46) = 0;
      *(_DWORD *)v4 = &off_66C5D8;
      *(_DWORD *)(v4 + 74) = 0;
      *(_DWORD *)(v4 + 70) = 0;
      *((_DWORD *)v4 + 10) = 0;
      *((_DWORD *)v4 + 11) = 0;
    }
    else if ( iSubTaskType == 1103 )
    {
      v4 = (char *)CTask::operator new(0x18u);
      CTaskComplex::CTaskComplex((CTaskComplex *)v4);
      v5 = v4[12];
      *((_DWORD *)v4 + 4) = 0;
      *((_DWORD *)v4 + 5) = 0;
      *(_DWORD *)v4 = &off_66D000;
      v4[12] = v5 & 0xF8 | 4;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 700:
        CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, 6);
        v4 = (char *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(
          (CTaskComplexEnterCarAsPassenger *)v4,
          this->m_pCopVehicle,
          0,
          0);
        break;
      case 701:
        CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, 6);
        v4 = (char *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
          (CTaskComplexEnterCarAsDriver *)v4,
          this->m_pCopVehicle);
        break;
      case 702:
      case 703:
      case 705:
      case 706:
      case 707:
      case 708:
      case 710:
      case 711:
      case 712:
      case 713:
      case 714:
      case 715:
      case 716:
      case 717:
      case 718:
      case 719:
      case 720:
      case 721:
      case 722:
      case 723:
        return (CTask *)v4;
      case 704:
        CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, 1);
        v4 = (char *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v4, this->m_pCopVehicle, 0, 0, 1, 0);
        break;
      case 709:
        v4 = (char *)CTask::operator new(0x60u);
        CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v4, this->m_pCopVehicle, 0, 0);
        break;
      case 724:
        if ( CPed::IsPlayer(this->m_pTargetPed) )
        {
          if ( *((unsigned __int8 *)&this->m_pTargetPed->m_nPedFlags + 1) << 31 )
          {
            PoliceCarMissionForWantedLevel = CCarAI::FindPoliceCarMissionForWantedLevel();
            p_m_pCopVehicle = &this->m_pCopVehicle;
          }
          else
          {
            p_m_pCopVehicle = &this->m_pCopVehicle;
            PoliceCarMissionForWantedLevel = 43;
          }
          PoliceCarSpeedForWantedLevel = (float)CCarAI::FindPoliceCarSpeedForWantedLevel(this->m_pCopVehicle);
        }
        else
        {
          p_m_pCopVehicle = &this->m_pCopVehicle;
          PoliceCarSpeedForWantedLevel = (float)(this->m_pCopVehicle->pHandling->Transmission.m_fMaxFlatVelocity * 60.0)
                                       * 0.9;
          if ( *((unsigned __int8 *)&this->m_pTargetPed->m_nPedFlags + 1) << 31 )
          {
            PoliceCarMissionForWantedLevel = 2;
            if ( (rand() & 2u) < 2 )
              PoliceCarMissionForWantedLevel = 4;
          }
          else
          {
            PoliceCarMissionForWantedLevel = 55;
          }
        }
        v10 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
        m_pTargetPed = this->m_pTargetPed;
        v4 = (char *)v10;
        if ( *((unsigned __int8 *)&m_pTargetPed->m_nPedFlags + 1) << 31 )
          m_pTargetPed = (CPed *)m_pTargetPed->m_pMyVehicle;
        CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(
          v10,
          *p_m_pCopVehicle,
          m_pTargetPed,
          PoliceCarMissionForWantedLevel,
          (int)PoliceCarSpeedForWantedLevel,
          10.0);
        break;
      default:
        if ( iSubTaskType == 203 )
        {
          v4 = (char *)CTask::operator new(0x20u);
          CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v4, 1000, 1, 0, 8.0);
        }
        break;
    }
  }
  return (CTask *)v4;
}
// 66C5D8: using guessed type void *off_66C5D8;
// 66D000: using guessed type void *off_66D000;

//----- (00540084) --------------------------------------------------------
CTask *__fastcall CTaskComplexCopInCar::CreateNextSubTask(CTaskComplexCopInCar *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  char *v5; // r5
  CTask *result; // r0
  int v7; // r0
  bool v8; // zf
  CVehicle *m_pMyVehicle; // r0
  CTask *m_pSubTask; // r5
  CWanted *PlayerWanted; // r0
  __int64 v12; // r0
  unsigned __int16 v13; // r0
  char v14; // r2
  char v15; // r1
  CPed *v16; // r0
  CTaskComplexCopInCar *v17; // r0
  int v18; // r1
  CPed *v19; // r0
  CVehicle *m_pCopVehicle; // r1
  CMatrix *m_pMat; // r2
  CMatrix *v22; // r3
  float *p_tx; // r0
  CSimpleTransform *p_m_transform; // r1
  int v25; // r0

  m_pTargetPed = this->m_pTargetPed;
  if ( m_pTargetPed && m_pTargetPed->m_nPedState != PED_DEAD )
  {
    v7 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    switch ( v7 )
    {
      case 700:
      case 701:
        m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31);
        v8 = m_pMyVehicle == 0;
        if ( m_pMyVehicle )
        {
          m_pMyVehicle = pPed->m_pMyVehicle;
          v8 = m_pMyVehicle == 0;
        }
        if ( v8 )
          goto LABEL_16;
        CVehicle::ChangeLawEnforcerState(m_pMyVehicle, 1u);
        v15 = *((_BYTE *)this + 48);
        v16 = this->m_pTargetPed;
        *((_BYTE *)this + 48) = v15 & 0xFB;
        *((_BYTE *)this + 48) = (*(_DWORD *)&v16->m_nPedFlags >> 5) & 8 | v15 & 0xF3;
        v17 = this;
        v18 = 724;
        goto LABEL_19;
      case 702:
      case 703:
      case 705:
      case 706:
      case 707:
      case 708:
      case 710:
      case 711:
      case 712:
      case 713:
      case 714:
      case 715:
      case 716:
      case 717:
      case 718:
      case 719:
      case 720:
      case 721:
      case 722:
      case 723:
        return (CTask *)v5;
      case 704:
LABEL_16:
        v5 = (char *)CTask::operator new(0x18u);
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        v14 = v5[12];
        *((_DWORD *)v5 + 4) = 0;
        *((_DWORD *)v5 + 5) = 0;
        *(_DWORD *)v5 = &off_66D000;
        v5[12] = v14 & 0xF8 | 4;
        return (CTask *)v5;
      case 709:
        this->m_pCopVehicle->AutoPilot.Mission = 0;
        CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, 1);
        v5 = (char *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, this->m_pCopVehicle, 0, 0, 1, 0);
        return (CTask *)v5;
      case 724:
        *((_BYTE *)this + 48) |= 2u;
        v5 = (char *)CTask::operator new(0x60u);
        CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, this->m_pCopVehicle, 0, 0);
        return (CTask *)v5;
      default:
        if ( v7 != 1103 )
          return (CTask *)v5;
        m_pSubTask = this->m_pSubTask;
        PlayerWanted = FindPlayerWanted(-1);
        if ( PlayerWanted->m_WantedLevel == WANTED_CLEAN )
          return 0;
        if ( !CWanted::CanCopJoinPursuit(PlayerWanted, (CCopPed *)pPed) || ((int)m_pSubTask[1].m_pParent & 4) == 0 )
          goto LABEL_15;
        v19 = this->m_pTargetPed;
        if ( (*((_DWORD *)&v19->m_nPedFlags + 2) & 0x40) != 0 )
          return 0;
        if ( (*(_DWORD *)&v19->m_nPedFlags & 0x100) == 0
          || (m_pCopVehicle = this->m_pCopVehicle, v19->m_pMyVehicle == m_pCopVehicle)
          || !m_pCopVehicle )
        {
LABEL_15:
          v12 = CTimer::m_snTimeInMilliseconds | 0xBB800000000LL;
          this->m_NextPursuitAttemptTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_NextPursuitAttemptTimer.m_iStartTime = v12;
          v5 = (char *)CTask::operator new(0x50u);
          v13 = rand();
          CTaskComplexWander::CTaskComplexWander(
            (CTaskComplexWander *)v5,
            4,
            (int)(float)((float)((float)v13 * 0.000015259) * 8.0),
            1,
            0.5);
          *((_QWORD *)v5 + 7) = 0LL;
          *((_QWORD *)v5 + 8) = 0LL;
          *(_DWORD *)(v5 + 50) = 0;
          *(_DWORD *)(v5 + 46) = 0;
          *(_DWORD *)v5 = &off_66C5D8;
          *((_DWORD *)v5 + 10) = 0;
          *((_DWORD *)v5 + 11) = 0;
          *(_DWORD *)(v5 + 74) = 0;
          *(_DWORD *)(v5 + 70) = 0;
          return (CTask *)v5;
        }
        m_pMat = m_pCopVehicle->m_pMat;
        v22 = pPed->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &m_pCopVehicle->m_transform.m_translate.x;
        p_m_transform = (CSimpleTransform *)&v22->tx;
        if ( !v22 )
          p_m_transform = &pPed->m_transform;
        if ( !(*((unsigned __int8 *)this + 48) << 31) )
          goto LABEL_35;
        if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
        {
          v18 = 709;
        }
        else if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - *p_tx)
                                        * (float)(p_m_transform->m_translate.x - *p_tx))
                                + (float)((float)(p_m_transform->m_translate.y - p_tx[1])
                                        * (float)(p_m_transform->m_translate.y - p_tx[1])))
                        + (float)((float)(p_m_transform->m_translate.z - p_tx[2])
                                * (float)(p_m_transform->m_translate.z - p_tx[2]))) >= 16.0 )
        {
LABEL_35:
          v25 = CTimer::m_snTimeInMilliseconds;
          this->m_NextPursuitAttemptTimer.m_bIsActive = 1;
          this->m_NextPursuitAttemptTimer.m_iStartTime = v25;
          this->m_NextPursuitAttemptTimer.m_iDuration = 3000;
          v18 = 912;
        }
        else
        {
          v18 = 701;
        }
        v17 = this;
LABEL_19:
        result = CTaskComplexCopInCar::CreateSubTask(v17, v18, pPed);
        break;
    }
  }
  else
  {
    return 0;
  }
  return result;
}
// 66C5D8: using guessed type void *off_66C5D8;
// 66D000: using guessed type void *off_66D000;

//----- (0054042C) --------------------------------------------------------
CTask *__fastcall CTaskComplexCopInCar::ControlSubTask(CTaskComplexCopInCar *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  CTaskComplexEnterCarAsDriver *m_pSubTask; // r4
  bool v6; // zf
  CVehicle *m_pCopVehicle; // r0
  CPed *m_pColleague; // r1
  bool v10; // zf
  int v11; // r0
  unsigned int v12; // r0
  unsigned int m_nPedFlags; // r0
  char v14; // r1
  const CVehicle *v15; // r0
  const CVehicle *m_fxSysHeliDust; // r1
  bool v17; // zf
  bool v18; // zf
  CMatrix *m_pMat; // r2
  CVehicle *v20; // r12
  CVehicle *m_pMyVehicle; // r1
  CSimpleTransform *p_tx; // r3
  CMatrix *v23; // r0
  float z; // s4
  CMatrix *v25; // r2
  float v26; // s2
  float x; // s6
  float v28; // s0
  float y; // s8
  float v30; // s10
  float *p_x; // r3
  float *v32; // r1
  float v33; // s4
  float v34; // s12
  float v35; // s0
  float v36; // s6
  float v37; // s7
  float v38; // s2
  int v39; // r1
  int v40; // r0
  float v41; // s0
  float v42; // s2
  int v43; // r8
  int (**v44)(void); // r0
  char v45; // r1
  unsigned int v46; // r0
  int m_iStartTime; // r1
  CPed *v48; // r0
  CVehicle *v49; // r0
  bool v50; // zf
  CMatrix *v51; // r1
  CMatrix *v52; // r2
  CSimpleTransform *p_m_transform; // r3
  CSimpleTransform *v54; // r1
  float32x2_t v55; // d16
  unsigned __int64 v56; // d1
  char v57; // r1
  CPed *v58; // r0
  char m_pTargetVehicle; // r1
  unsigned __int16 v60; // r0
  int *v61; // r2
  float v62; // s2
  int v63; // r2
  unsigned int v64; // r0
  int v65; // r1

  m_pTargetPed = this->m_pTargetPed;
  m_pSubTask = (CTaskComplexEnterCarAsDriver *)this->m_pSubTask;
  v6 = m_pTargetPed == 0;
  if ( m_pTargetPed )
    v6 = m_pTargetPed->m_nPedState == PED_DEAD;
  if ( v6 )
  {
    if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
           m_pSubTask,
           pPed,
           1,
           0) )
    {
      return 0;
    }
    return m_pSubTask;
  }
  m_pCopVehicle = this->m_pCopVehicle;
  if ( m_pCopVehicle && !m_pCopVehicle->pDriver && m_pCopVehicle->AutoPilot.Mission )
    m_pCopVehicle->AutoPilot.Mission = 0;
  if ( (*((_BYTE *)this + 48) & 1) == 0 )
  {
    m_pColleague = this->m_pColleague;
    v10 = m_pColleague == 0;
    if ( m_pColleague )
      v10 = m_pColleague->m_nPedState == PED_DEAD;
    if ( v10 )
      *((_BYTE *)this + 48) |= 1u;
  }
  v11 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v11 >= 912 )
  {
    if ( v11 == 912 )
    {
      if ( this->m_NextPursuitAttemptTimer.m_bIsActive )
      {
        if ( this->m_NextPursuitAttemptTimer.m_bIsStopped )
        {
          v46 = CTimer::m_snTimeInMilliseconds;
          this->m_NextPursuitAttemptTimer.m_bIsStopped = 0;
          this->m_NextPursuitAttemptTimer.m_iStartTime = v46;
          m_iStartTime = v46;
        }
        else
        {
          m_iStartTime = this->m_NextPursuitAttemptTimer.m_iStartTime;
          v46 = CTimer::m_snTimeInMilliseconds;
        }
        if ( m_iStartTime + this->m_NextPursuitAttemptTimer.m_iDuration <= v46
          && (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
               m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          m_pSubTask = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x18u);
          CTaskComplex::CTaskComplex(m_pSubTask);
          m_pTargetVehicle = (char)m_pSubTask->m_pTargetVehicle;
          *((_DWORD *)&m_pSubTask->CTaskComplexEnterCar + 4) = 0;
          m_pSubTask->m_iTargetDoor = 0;
          m_pSubTask->_vptr$CTask = (int (**)(void))&off_66D000;
          LOBYTE(m_pSubTask->m_pTargetVehicle) = m_pTargetVehicle & 0xF8 | 4;
        }
      }
    }
    else if ( v11 == 1103 )
    {
      v15 = (const CVehicle *)this->m_pTargetPed;
      if ( BYTE1(v15->pPassengers[7]) << 31 )
      {
        m_fxSysHeliDust = (const CVehicle *)v15->m_fxSysHeliDust;
        v17 = m_fxSysHeliDust == 0;
        if ( m_fxSysHeliDust )
        {
          v15 = this->m_pCopVehicle;
          v17 = m_fxSysHeliDust == v15;
        }
        if ( !v17 )
        {
          v18 = v15 == 0;
          if ( v15 )
            v18 = *((unsigned __int8 *)this + 48) << 31 == 0;
          if ( !v18
            && v15->m_nHealth > 0.0
            && !v15->m_pFire
            && !CVehicle::IsUpsideDown(v15)
            && !CVehicle::IsOnItsSide(this->m_pCopVehicle) )
          {
            m_pMat = pPed->m_pMat;
            v20 = this->m_pCopVehicle;
            m_pMyVehicle = this->m_pTargetPed->m_pMyVehicle;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            v23 = v20->m_pMat;
            z = m_pMyVehicle->m_vecMoveSpeed.z;
            if ( !m_pMat )
              p_tx = &pPed->m_transform;
            v25 = m_pMyVehicle->m_pMat;
            v26 = m_pMyVehicle->m_vecMoveSpeed.y * m_pMyVehicle->m_vecMoveSpeed.y;
            x = p_tx->m_translate.x;
            v28 = m_pMyVehicle->m_vecMoveSpeed.x * m_pMyVehicle->m_vecMoveSpeed.x;
            y = p_tx->m_translate.y;
            v30 = p_tx->m_translate.z;
            p_x = &v25->tx;
            if ( !v25 )
              p_x = &m_pMyVehicle->m_transform.m_translate.x;
            v32 = &v23->tx;
            v33 = z * z;
            v34 = *p_x - x;
            if ( !v23 )
              v32 = &v20->m_transform.m_translate.x;
            v35 = v28 + v26;
            v36 = *v32 - x;
            v37 = v32[2];
            v38 = v32[1] - y;
            v39 = 0;
            v40 = 0;
            v41 = (float)(CTimer::ms_fTimeStep * (float)(v35 + v33)) * 50.0;
            v42 = (float)((float)(v36 * v36) + (float)(v38 * v38)) + (float)((float)(v37 - v30) * (float)(v37 - v30));
            if ( (float)((float)((float)(v34 * v34) + (float)((float)(p_x[1] - y) * (float)(p_x[1] - y)))
                       + (float)((float)(p_x[2] - v30) * (float)(p_x[2] - v30))) > 100.0 )
              v39 = 1;
            if ( v41 > 1.0 )
              v40 = 1;
            if ( v42 < 16.0
              && (v40 | v39) == 1
              && (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
                   m_pSubTask,
                   pPed,
                   1,
                   0) == 1 )
            {
              CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, 6);
              m_pSubTask = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x50u);
              CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(m_pSubTask, this->m_pCopVehicle);
            }
          }
        }
      }
    }
    return m_pSubTask;
  }
  if ( v11 != 709 )
  {
    if ( v11 == 724 )
    {
      v12 = *((unsigned __int8 *)this + 48);
      if ( ((*(_DWORD *)&this->m_pTargetPed->m_nPedFlags >> 8) & 1) != ((v12 >> 3) & 1) )
      {
        if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
               m_pSubTask,
               pPed,
               1,
               0) )
        {
          m_nPedFlags = (unsigned int)this->m_pTargetPed->m_nPedFlags;
          v14 = *((_BYTE *)this + 48) & 0xF7;
LABEL_24:
          *((_BYTE *)this + 48) = (m_nPedFlags >> 5) & 8 | v14;
          return CTaskComplexCopInCar::CreateSubTask(this, 724, pPed);
        }
        LOBYTE(v12) = *((_BYTE *)this + 48);
      }
      if ( (v12 & 2) != 0
        && (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
             m_pSubTask,
             pPed,
             1,
             0) == 1 )
      {
        m_pSubTask = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x60u);
        CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)m_pSubTask, this->m_pCopVehicle, 0, 0);
      }
    }
    return m_pSubTask;
  }
  v43 = *((unsigned __int8 *)this + 48);
  if ( (v43 & 2) == 0 )
    return m_pSubTask;
  if ( v43 << 31 )
  {
    if ( !this->m_DriverGetOutTimer.m_bIsActive )
    {
      v60 = rand();
      v61 = dword_540978;
      if ( (v43 & 4) != 0 )
        v61 = &dword_540978[1];
      v62 = *(float *)v61;
      this->m_DriverGetOutTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
      v63 = 250;
      this->m_DriverGetOutTimer.m_bIsActive = 1;
      if ( (v43 & 4) != 0 )
        v63 = 3000;
      this->m_DriverGetOutTimer.m_iDuration = (int)(float)(v62 * (float)((float)v60 * 0.000015259)) + v63;
      return m_pSubTask;
    }
    v48 = this->m_pTargetPed;
    if ( *((unsigned __int8 *)&v48->m_nPedFlags + 1) << 31 )
    {
      v49 = v48->m_pMyVehicle;
      v50 = v49 == 0;
      if ( v49 )
        v50 = v49 == this->m_pCopVehicle;
      if ( !v50 )
      {
        v51 = pPed->m_pMat;
        v52 = v49->m_pMat;
        p_m_transform = (CSimpleTransform *)&v51->tx;
        if ( !v51 )
          p_m_transform = &pPed->m_transform;
        v54 = (CSimpleTransform *)&v52->tx;
        if ( !v52 )
          v54 = &v49->m_transform;
        v55.n64_u64[0] = vsub_f32(*(float32x2_t *)&v54->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
        v56 = vmul_f32(v55, v55).n64_u64[0];
        if ( (float)((float)((float)((float)(v54->m_translate.x - p_m_transform->m_translate.x)
                                   * (float)(v54->m_translate.x - p_m_transform->m_translate.x))
                           + *(float *)&v56)
                   + *((float *)&v56 + 1)) > 100.0
          || (float)((float)(CTimer::ms_fTimeStep
                           * (float)((float)((float)(v49->m_vecMoveSpeed.x * v49->m_vecMoveSpeed.x)
                                           + (float)(v49->m_vecMoveSpeed.y * v49->m_vecMoveSpeed.y))
                                   + (float)(v49->m_vecMoveSpeed.z * v49->m_vecMoveSpeed.z)))
                   * 50.0) > 1.0 )
        {
          if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
                 m_pSubTask,
                 pPed,
                 1,
                 0) == 1 )
          {
            v57 = *((_BYTE *)this + 48);
            v58 = this->m_pTargetPed;
            this->m_DriverGetOutTimer.m_bIsActive = 0;
            *((_BYTE *)this + 48) = v57 & 0xF9;
            m_nPedFlags = (unsigned int)v58->m_nPedFlags;
            v14 = v57 & 0xF1;
            goto LABEL_24;
          }
          if ( !this->m_DriverGetOutTimer.m_bIsActive )
            return m_pSubTask;
        }
      }
    }
    if ( this->m_DriverGetOutTimer.m_bIsStopped )
    {
      v64 = CTimer::m_snTimeInMilliseconds;
      this->m_DriverGetOutTimer.m_bIsStopped = 0;
      this->m_DriverGetOutTimer.m_iStartTime = v64;
      v65 = v64;
    }
    else
    {
      v65 = this->m_DriverGetOutTimer.m_iStartTime;
      v64 = CTimer::m_snTimeInMilliseconds;
    }
    if ( v65 + this->m_DriverGetOutTimer.m_iDuration > v64
      || (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
           m_pSubTask,
           pPed,
           1,
           0) != 1 )
    {
      return m_pSubTask;
    }
    v44 = this->_vptr$CTask;
    v45 = *((_BYTE *)this + 48);
    this->m_DriverGetOutTimer.m_bIsActive = 0;
  }
  else
  {
    if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(
           m_pSubTask,
           pPed,
           1,
           0) != 1 )
      return m_pSubTask;
    v44 = this->_vptr$CTask;
    v45 = *((_BYTE *)this + 48);
  }
  *((_BYTE *)this + 48) = v45 & 0xFD;
  return (CTask *)((int (__fastcall *)(CTaskComplexCopInCar *, CPed *))v44[10])(this, pPed);
}
// 540978: using guessed type int dword_540978[2];
// 66D000: using guessed type void *off_66D000;

//----- (00540980) --------------------------------------------------------
CTask *__fastcall CTaskSimpleArrestPed::Clone(const CTaskSimpleArrestPed *this)
{
  void *v2; // r4
  CPed *m_pArrestedPed; // r5

  v2 = CTask::operator new(0x14u);
  m_pArrestedPed = this->m_pArrestedPed;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 12) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_66CF90;
  *((_DWORD *)v2 + 2) = m_pArrestedPed;
  if ( m_pArrestedPed )
    CEntity::RegisterReference(m_pArrestedPed, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66CF90: using guessed type void *off_66CF90;

//----- (005409C0) --------------------------------------------------------
int __fastcall CTaskSimpleArrestPed::GetTaskType(const CTaskSimpleArrestPed *this)
{
  return 1100;
}

//----- (005409C8) --------------------------------------------------------
CTask *__fastcall CTaskComplexArrestPed::Clone(const CTaskComplexArrestPed *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x24u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 8) = 0;
  *(_DWORD *)v2 = &off_66CFC4;
  *((_DWORD *)v2 + 4) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 66CFC4: using guessed type void *off_66CFC4;

//----- (00540A04) --------------------------------------------------------
int __fastcall CTaskComplexArrestPed::GetTaskType(const CTaskComplexArrestPed *this)
{
  return 1101;
}

//----- (00540A0C) --------------------------------------------------------
CTask *__fastcall CTaskComplexPolicePursuit::Clone(const CTaskComplexPolicePursuit *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0
  char m_pParent; // r3

  v1 = (CTaskComplex *)CTask::operator new(0x18u);
  CTaskComplex::CTaskComplex(v1);
  m_pParent = (char)result[1].m_pParent;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D000;
  LOBYTE(result[1].m_pParent) = m_pParent & 0xF8 | 4;
  return result;
}
// 540A1E: variable 'result' is possibly undefined
// 66D000: using guessed type void *off_66D000;

//----- (00540A3C) --------------------------------------------------------
int __fastcall CTaskComplexPolicePursuit::GetTaskType(const CTaskComplexPolicePursuit *this)
{
  return 1103;
}

//----- (00540A44) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillCriminal::Clone(const CTaskComplexKillCriminal *this)
{
  char *v2; // r4
  CPed *m_pCriminal; // r6
  char *v4; // r5
  int v5; // r0
  int v6; // r1

  v2 = (char *)CTask::operator new(0x20u);
  m_pCriminal = this->m_pCriminal;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 5) = 1077936128;
  *((_WORD *)v2 + 12) = 0;
  v2[26] = 0;
  v2[30] = 0;
  *(_DWORD *)v2 = &off_66D03C;
  *((_DWORD *)v2 + 3) = m_pCriminal;
  v4 = v2 + 12;
  if ( m_pCriminal )
  {
    if ( CPed::IsPlayer(m_pCriminal)
      || (v5 = *(_DWORD *)v4, v6 = *(_DWORD *)(*(_DWORD *)v4 + 1436), (unsigned int)v6 <= 0x13)
      && ((1 << v6) & (unsigned int)"eObjectCarriedWithRopeEv") != 0
      || v6 > 23
      || *(_BYTE *)(v5 + 1096) == 2 )
    {
      *(_DWORD *)v4 = 0;
    }
    else
    {
      CEntity::RegisterReference((CEntity *)v5, (CEntity **)v2 + 3);
    }
  }
  return (CTask *)v2;
}
// 66D03C: using guessed type void *off_66D03C;

//----- (00540AC8) --------------------------------------------------------
int __fastcall CTaskComplexKillCriminal::GetTaskType(const CTaskComplexKillCriminal *this)
{
  return 1105;
}

//----- (00540AD0) --------------------------------------------------------
CTask *__fastcall CTaskComplexCopInCar::Clone(const CTaskComplexCopInCar *this)
{
  unsigned __int8 *v2; // r4
  CVehicle *m_pCopVehicle; // r8
  CPed *m_pColleague; // r9
  CPed *m_pTargetPed; // r10
  int v6; // r1
  CEntity **v7; // r6

  v2 = (unsigned __int8 *)CTask::operator new(0x34u);
  m_pCopVehicle = this->m_pCopVehicle;
  m_pColleague = this->m_pColleague;
  m_pTargetPed = this->m_pTargetPed;
  LOBYTE(this) = *((_BYTE *)this + 48);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 16) = 0;
  *((_WORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 0;
  v6 = v2[48];
  *(_DWORD *)v2 = &off_66D078;
  v2[48] = (unsigned __int8)this & 1 | v6 & 0xFA | 4;
  *((_DWORD *)v2 + 5) = m_pTargetPed;
  v7 = (CEntity **)(v2 + 20);
  *((_DWORD *)v2 + 4) = m_pColleague;
  *((_DWORD *)v2 + 3) = m_pCopVehicle;
  if ( m_pCopVehicle )
  {
    CEntity::RegisterReference(m_pCopVehicle, (CEntity **)v2 + 3);
    m_pColleague = (CPed *)*((_DWORD *)v2 + 4);
  }
  if ( m_pColleague )
    CEntity::RegisterReference(m_pColleague, (CEntity **)v2 + 4);
  if ( *v7 )
    CEntity::RegisterReference(*v7, (CEntity **)v2 + 5);
  return (CTask *)v2;
}
// 66D078: using guessed type void *off_66D078;

//----- (00540B6C) --------------------------------------------------------
int __fastcall CTaskComplexCopInCar::GetTaskType(const CTaskComplexCopInCar *this)
{
  return 1106;
}

//----- (00540B80) --------------------------------------------------------
void __fastcall CTaskSimpleShakeFist::CTaskSimpleShakeFist(CTaskSimpleShakeFist *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)v1 = &off_66D0B4;
}
// 540B8C: variable 'v1' is possibly undefined
// 66D0B4: using guessed type void *;

//----- (00540BA0) --------------------------------------------------------
void __fastcall CTaskSimpleShakeFist::~CTaskSimpleShakeFist(CTaskSimpleShakeFist *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66D0B4;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66D0B4: using guessed type void *off_66D0B4;

//----- (00540BD4) --------------------------------------------------------
void __fastcall CTaskSimpleShakeFist::~CTaskSimpleShakeFist(CTaskSimpleShakeFist *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66D0B4;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 540BFE: variable 'v3' is possibly undefined
// 66D0B4: using guessed type void *off_66D0B4;

//----- (00540C0C) --------------------------------------------------------
bool __fastcall CTaskSimpleShakeFist::MakeAbortable(
        CTaskSimpleShakeFist *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0

  m_pAnim = this->m_pAnim;
  if ( (unsigned int)(iPriority - 1) > 1 )
  {
    if ( m_pAnim )
      m_pAnim->m_fBlendDelta = -4.0;
    return 0;
  }
  else if ( m_pAnim )
  {
    m_pAnim->m_fBlendDelta = -4.0;
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    result = 1;
    this->m_pAnim = 0;
  }
  else
  {
    return 1;
  }
  return result;
}

//----- (00540C54) --------------------------------------------------------
bool __fastcall CTaskSimpleShakeFist::ProcessPed(CTaskSimpleShakeFist *this, CPed *pPed)
{
  CAnimBlendAssociation *v4; // r0

  if ( this->m_bIsFinished )
    return 1;
  if ( !this->m_pAnim )
  {
    v4 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_PARTIAL_FUCKU, 4.0);
    this->m_pAnim = v4;
    v4->m_bitsFlag |= 8u;
    this->m_pAnim->m_bitsFlag |= 4u;
    CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CTaskSimpleShakeFist::FinishAnimShakeFistCB, this);
  }
  return 0;
}

//----- (00540CAC) --------------------------------------------------------
void __fastcall CTaskSimpleShakeFist::StartAnim(CTaskSimpleShakeFist *this, CPed *pPed)
{
  CAnimBlendAssociation *v3; // r0

  v3 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_PARTIAL_FUCKU, 4.0);
  this->m_pAnim = v3;
  v3->m_bitsFlag |= 8u;
  this->m_pAnim->m_bitsFlag |= 4u;
  sub_1929E0(this->m_pAnim, CTaskSimpleShakeFist::FinishAnimShakeFistCB, this);
}

//----- (00540CEC) --------------------------------------------------------
void __fastcall CTaskSimpleShakeFist::FinishAnimShakeFistCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (00540CF8) --------------------------------------------------------
void __fastcall CTaskSimpleFacial::CTaskSimpleFacial(CTaskSimpleFacial *this, int32 type, int32 time)
{
  int v5; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 24) = time;
  *(_DWORD *)(v5 + 20) = type;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)v5 = &off_66D0E8;
}
// 540D08: variable 'v5' is possibly undefined
// 66D0E8: using guessed type void *off_66D0E8;

//----- (00540D24) --------------------------------------------------------
void __fastcall CTaskSimpleFacial::~CTaskSimpleFacial(CTaskSimpleFacial *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 540D30: variable 'v1' is possibly undefined

//----- (00540D34) --------------------------------------------------------
bool __fastcall CTaskSimpleFacial::MakeAbortable(
        CTaskSimpleFacial *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  unsigned int m_type; // r0
  uint32 v5; // r2
  CAnimBlendAssociation *Association; // r0

  m_type = this->m_type;
  if ( m_type > 8 )
    v5 = -1;
  else
    v5 = dword_61E710[m_type];
  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, v5);
  if ( Association )
    Association->m_fBlendDelta = -4.0;
  return 1;
}
// 61E710: using guessed type _DWORD dword_61E710[9];

//----- (00540D6C) --------------------------------------------------------
AnimationId __fastcall CTaskSimpleFacial::GetAnimId(int32 type)
{
  if ( (unsigned int)type <= 8 )
    return dword_61E710[type];
  else
    return -1;
}
// 61E710: using guessed type _DWORD dword_61E710[9];

//----- (00540D84) --------------------------------------------------------
bool __fastcall CTaskSimpleFacial::ProcessPed(CTaskSimpleFacial *this, CPed *pPed)
{
  unsigned int m_type; // r0
  signed int v5; // r5
  CAnimBlendAssociation *Association; // r8
  bool v7; // r6
  unsigned int v8; // r0
  int m_iStartTime; // r1
  uint16 m_bitsFlag; // r0
  __int64 v11; // r0

  m_type = this->m_type;
  if ( m_type > 8 )
    v5 = -1;
  else
    v5 = dword_61E710[m_type];
  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, v5);
  if ( RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xA0u) )
  {
    if ( v5 == 160 )
    {
      if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 39 )
      {
        v7 = 0;
        Association->m_fSpeed = (float)((float)((float)rand() * 4.6566e-10) * 2.5) + 0.5;
        return v7;
      }
      return 0;
    }
    if ( Association )
    {
      m_bitsFlag = Association->m_bitsFlag;
      Association->m_fBlendDelta = -4.0;
      Association->m_bitsFlag = m_bitsFlag | 4;
    }
    return 1;
  }
  if ( this->m_timer.m_bIsActive )
  {
    if ( Association )
    {
      if ( this->m_timer.m_bIsStopped )
      {
        v8 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsStopped = 0;
        this->m_timer.m_iStartTime = v8;
        m_iStartTime = v8;
      }
      else
      {
        m_iStartTime = this->m_timer.m_iStartTime;
        v8 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_timer.m_iDuration > v8 )
        return 0;
      Association->m_fBlendDelta = -4.0;
    }
    return 1;
  }
  v7 = 1;
  if ( !Association )
  {
    CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, (AnimationId)v5, 4.0);
    HIDWORD(v11) = this->m_duration;
    LODWORD(v11) = CTimer::m_snTimeInMilliseconds;
    *(_QWORD *)&this->m_timer.m_iStartTime = v11;
    this->m_timer.m_bIsActive = 1;
    return 0;
  }
  return v7;
}
// 61E710: using guessed type _DWORD dword_61E710[9];

//----- (00540ED4) --------------------------------------------------------
void __fastcall CTaskComplexFacial::CTaskComplexFacial(CTaskComplexFacial *this)
{
  int v2; // s0
  bool8 v3; // r0

  CTaskComplex::CTaskComplex(this);
  this->m_request = -1;
  this->m_request2 = -1;
  this->_vptr$CTask = (int (**)(void))&off_66D11C;
  v2 = (unsigned __int16)rand();
  v3 = 0;
  *(_WORD *)&this->m_talkingLastFrame = 0;
  if ( (int)(float)((float)((float)v2 * 0.000015259) * 100.0) > 70 )
    v3 = 1;
  this->m_chews = v3;
}
// 66D11C: using guessed type void *;

//----- (00540F38) --------------------------------------------------------
void __fastcall CTaskComplexFacial::~CTaskComplexFacial(CTaskComplexFacial *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 540F44: variable 'v1' is possibly undefined

//----- (00540F48) --------------------------------------------------------
bool __fastcall CTaskComplexFacial::MakeAbortable(
        CTaskComplexFacial *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (00540F5C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFacial::CreateNextSubTask(CTaskComplexFacial *this, CPed *pPed)
{
  CTaskSimple *v4; // r0
  CTask *result; // r0
  char *v6; // r1
  CTask *m_request2; // r5
  CTaskSimple *v8; // r0
  int (**m_request2Time)(void); // r4
  CTaskSimple *v10; // r0
  CTaskSimple *v11; // r0

  if ( !CPed::IsAlive(pPed)
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         2,
         0) == 1 )
  {
    v4 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v4);
    LOWORD(result[2]._vptr$CTask) = 0;
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    v6 = (char *)&`vtable for'CTaskSimplePause;
    goto LABEL_10;
  }
  m_request2 = (CTask *)this->m_request2;
  if ( m_request2 == (CTask *)-1 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 303
      && this->m_chews )
    {
      v10 = (CTaskSimple *)CTask::operator new(0x1Cu);
      CTaskSimple::CTaskSimple(v10);
      LOWORD(result[2]._vptr$CTask) = 0;
      result[3]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 4748);
      result[1]._vptr$CTask = 0;
      result[1].m_pParent = 0;
      m_request2 = (CTask *)byte_8;
      v6 = (char *)&`vtable for'CTaskSimpleFacial;
LABEL_11:
      result->_vptr$CTask = (int (**)(void))(v6 + 8);
      goto LABEL_12;
    }
    v11 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v11);
    v6 = (char *)&`vtable for'CTaskSimplePause;
    LOWORD(result[2]._vptr$CTask) = 0;
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
LABEL_10:
    m_request2 = (CTask *)(elf_hash_bucket + 4748);
    goto LABEL_11;
  }
  this->m_request2 = -1;
  v8 = (CTaskSimple *)CTask::operator new(0x1Cu);
  m_request2Time = (int (**)(void))this->m_request2Time;
  CTaskSimple::CTaskSimple(v8);
  LOWORD(result[2]._vptr$CTask) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D0E8;
  result[3]._vptr$CTask = m_request2Time;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
LABEL_12:
  result[2].m_pParent = m_request2;
  return result;
}
// 540F92: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 66D0E8: using guessed type void *;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (00541050) --------------------------------------------------------
CTask *__fastcall CTaskComplexFacial::CreateFirstSubTask(CTaskComplexFacial *this, CPed *pPed)
{
  CTaskSimple *v3; // r0
  CTask *result; // r0

  if ( CPed::IsPlayer(pPed) )
    this->m_chews = 0;
  v3 = (CTaskSimple *)CTask::operator new(0x18u);
  CTaskSimple::CTaskSimple(v3);
  LOWORD(result[2]._vptr$CTask) = 0;
  result[2].m_pParent = (CTask *)(elf_hash_bucket + 4748);
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_665750;
  return result;
}
// 541076: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 665750: using guessed type void *off_665750;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (0054108C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFacial::ControlSubTask(CTaskComplexFacial *this, CPed *pPed)
{
  CTaskSimple *v4; // r0
  CTask *result; // r0
  char *v6; // r1
  CTaskSimple *v7; // r0
  CAnimBlendAssociation *Association; // r0
  CTaskSimple *v9; // r0
  CTaskSimple *v10; // r0
  CTask *m_pSubTask; // r0
  CTask *m_request; // r5
  int32 m_requestTime; // r2
  uint32 v14; // r1
  CTaskSimple *v15; // r0
  int (**v16)(void); // r4

  if ( !CPed::IsAlive(pPed)
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         2,
         0) == 1 )
  {
    v4 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v4);
    LOWORD(result[2]._vptr$CTask) = 0;
    result[2].m_pParent = (CTask *)(elf_hash_bucket + 4748);
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    v6 = (char *)&`vtable for'CTaskSimplePause;
LABEL_10:
    result->_vptr$CTask = (int (**)(void))(v6 + 8);
    return result;
  }
  if ( this->m_stopAll
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
  {
    *(_WORD *)&this->m_talkingLastFrame = 0;
    v7 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v7);
LABEL_14:
    LOWORD(result[2]._vptr$CTask) = 0;
    result->_vptr$CTask = (int (**)(void))&off_665750;
    result[2].m_pParent = (CTask *)(elf_hash_bucket + 4748);
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    return result;
  }
  if ( RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xCu) )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xA0u);
    this->m_request2 = -1;
    this->m_talkingLastFrame = 1;
    if ( !Association )
    {
      v9 = (CTaskSimple *)CTask::operator new(0x1Cu);
      CTaskSimple::CTaskSimple(v9);
      LOWORD(result[2]._vptr$CTask) = 0;
      result[3]._vptr$CTask = 0;
      result[2].m_pParent = (CTask *)&byte_7;
      v6 = (char *)&`vtable for'CTaskSimpleFacial;
      result[1]._vptr$CTask = 0;
      result[1].m_pParent = 0;
      goto LABEL_10;
    }
    return this->m_pSubTask;
  }
  if ( this->m_talkingLastFrame
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
  {
    this->m_talkingLastFrame = 0;
    v10 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v10);
    goto LABEL_14;
  }
  if ( this->m_request == -1 )
    return this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 303 )
  {
    m_pSubTask = this->m_pSubTask;
    m_request = (CTask *)this->m_request;
    if ( m_pSubTask[2].m_pParent == m_request )
    {
      m_requestTime = this->m_requestTime;
      v14 = CTimer::m_snTimeInMilliseconds;
      LOBYTE(m_pSubTask[2]._vptr$CTask) = 1;
      m_pSubTask[1]._vptr$CTask = (int (**)(void))v14;
      m_pSubTask[1].m_pParent = (CTask *)m_requestTime;
      this->m_request = -1;
      return this->m_pSubTask;
    }
  }
  else
  {
    m_request = (CTask *)this->m_request;
  }
  this->m_request = -1;
  v15 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v16 = (int (**)(void))this->m_requestTime;
  CTaskSimple::CTaskSimple(v15);
  LOWORD(result[2]._vptr$CTask) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D0E8;
  result[2].m_pParent = m_request;
  result[3]._vptr$CTask = v16;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  return result;
}
// 5410C6: variable 'result' is possibly undefined
// 7: using guessed type char byte_7;
// FC: using guessed type int elf_hash_bucket[16411];
// 665750: using guessed type void *off_665750;
// 66D0E8: using guessed type void *off_66D0E8;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (00541220) --------------------------------------------------------
void __fastcall CTaskComplexFacial::SetRequest(
        CTaskComplexFacial *this,
        int32 type,
        int32 time,
        int32 type2,
        int32 time2)
{
  int32 *p_m_request; // r0

  p_m_request = &this->m_request;
  *p_m_request = type;
  p_m_request[1] = time;
  p_m_request[2] = type2;
  p_m_request[3] = time2;
}

//----- (0054122C) --------------------------------------------------------
void __fastcall CTaskComplexFacial::StopAll(CTaskComplexFacial *this)
{
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 303 )
    this->m_stopAll = 1;
}

//----- (00541248) --------------------------------------------------------
void __fastcall CTaskSimpleAffectSecondaryBehaviour::CTaskSimpleAffectSecondaryBehaviour(
        CTaskSimpleAffectSecondaryBehaviour *this,
        const bool bAdd,
        const int iType,
        CTask *pTask)
{
  int v7; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v7 + 8) = bAdd;
  *(_DWORD *)(v7 + 12) = iType;
  *(_DWORD *)(v7 + 16) = pTask;
  *(_DWORD *)v7 = &off_66D158;
}
// 54125C: variable 'v7' is possibly undefined
// 66D158: using guessed type void *off_66D158;

//----- (00541274) --------------------------------------------------------
void __fastcall CTaskSimpleAffectSecondaryBehaviour::~CTaskSimpleAffectSecondaryBehaviour(
        CTaskSimpleAffectSecondaryBehaviour *this)
{
  CTask *m_pTask; // r0

  m_pTask = this->m_pTask;
  this->_vptr$CTask = (int (**)(void))&off_66D158;
  if ( m_pTask )
    (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(m_pTask);
  sub_1A01F4(this);
}
// 66D158: using guessed type void *;

//----- (005412A0) --------------------------------------------------------
void __fastcall CTaskSimpleAffectSecondaryBehaviour::~CTaskSimpleAffectSecondaryBehaviour(
        CTaskSimpleAffectSecondaryBehaviour *this)
{
  CTask *m_pTask; // r0
  void *v3; // r0

  m_pTask = this->m_pTask;
  this->_vptr$CTask = (int (**)(void))&off_66D158;
  if ( m_pTask )
    (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(m_pTask);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 5412C6: variable 'v3' is possibly undefined
// 66D158: using guessed type void *off_66D158;

//----- (005412D0) --------------------------------------------------------
bool __fastcall CTaskSimpleAffectSecondaryBehaviour::ProcessPed(CTaskSimpleAffectSecondaryBehaviour *this, CPed *pPed)
{
  CTask *TaskSecondary; // r0
  bool v5; // r6
  CPedIntelligence *m_pPedIntelligence; // r4
  CTask *v7; // r0

  TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, this->m_iType);
  if ( this->m_bAdd )
  {
    if ( !TaskSecondary
      || (v5 = 0,
          (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))TaskSecondary->_vptr$CTask + 7))(
            TaskSecondary,
            pPed,
            1,
            0) == 1) )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v7 = (CTask *)(*((int (__fastcall **)(CTask *))this->m_pTask->_vptr$CTask + 2))(this->m_pTask);
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v7, this->m_iType);
      return 1;
    }
  }
  else
  {
    if ( !TaskSecondary )
      return 1;
    v5 = 0;
    (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))TaskSecondary->_vptr$CTask + 7))(
      TaskSecondary,
      pPed,
      0,
      0);
  }
  return v5;
}

//----- (00541338) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
        CTaskSimpleHoldEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        AnimationId nAnimId,
        AssocGroupId nAnimGroup,
        bool bDontDropWhenAnimDone)
{
  __int64 v12; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_nAnimId = nAnimId;
  this->m_nAnimGroup = nAnimGroup;
  this->m_pAnimBlock = 0;
  this->m_pAnimHierarchy = 0;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = bDontDropWhenAnimDone;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v12 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v12;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
}
// 66D18C: using guessed type void *;

//----- (005413C0) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
        CTaskSimpleHoldEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        const unsigned __int8 *pAnimName,
        const unsigned __int8 *pAnimGroupName,
        int32 nFlags)
{
  __int64 v12; // d16
  CAnimBlock *AnimationBlock; // r0
  CAnimBlendHierarchy *Animation; // r0
  CAnimBlock *m_pAnimBlock; // r2

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_nAnimId = ANIM_STD_NUM;
  this->m_nAnimGroup = ANIM_STD_PED;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v12 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v12;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
  this->m_nAnimFlags = nFlags;
  AnimationBlock = CAnimManager::GetAnimationBlock(pAnimGroupName);
  this->m_pAnimBlock = AnimationBlock;
  Animation = CAnimManager::GetAnimation(pAnimName, AnimationBlock);
  m_pAnimBlock = this->m_pAnimBlock;
  this->m_pAnimHierarchy = Animation;
  CAnimManager::AddAnimBlockRef(m_pAnimBlock - CAnimManager::ms_aAnimBlocks);
}
// 66D18C: using guessed type void *off_66D18C;

//----- (00541468) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
        CTaskSimpleHoldEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        CAnimBlock *pAnimBlock,
        CAnimBlendHierarchy *pAnimHierarchy,
        int32 nFlags)
{
  __int64 v12; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_fHeadingOffset = 0.0;
  this->m_nAnimId = ANIM_STD_NUM;
  this->m_nAnimGroup = ANIM_STD_PED;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v12 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v12;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
  this->m_pAnimBlock = pAnimBlock;
  this->m_nAnimFlags = nFlags;
  this->m_pAnimHierarchy = pAnimHierarchy;
  CAnimManager::AddAnimBlockRef(pAnimBlock - CAnimManager::ms_aAnimBlocks);
}
// 66D18C: using guessed type void *off_66D18C;

//----- (0054150C) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::~CTaskSimpleHoldEntity(CTaskSimpleHoldEntity *this)
{
  void *v1; // r0

  CTaskSimpleHoldEntity::~CTaskSimpleHoldEntity(this);
  sub_197118(v1);
}
// 541518: variable 'v1' is possibly undefined

//----- (0054151C) --------------------------------------------------------
bool __fastcall CTaskSimpleHoldEntity::MakeAbortable(
        CTaskSimpleHoldEntity *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool v7; // r6

  m_pAnim = this->m_pAnim;
  if ( (unsigned int)(iPriority - 1) > 1 )
  {
    v7 = 0;
    if ( m_pAnim )
      m_pAnim->m_fBlendDelta = -4.0;
  }
  else
  {
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -4.0;
      CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pAnim = 0;
    }
    v7 = 1;
    CTaskSimpleHoldEntity::DropEntity(this, pPed, 1);
    this->m_bIsFinished = 1;
  }
  return v7;
}

//----- (0054157C) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::DropEntity(CTaskSimpleHoldEntity *this, CPed *pPed, bool bAtSpeed)
{
  CEntity *m_pHoldEntity; // r0
  CEntity **p_m_pHoldEntity; // r4
  CEntity *v6; // r5
  _BOOL4 v7; // r9
  RwReal y; // r0
  int m_pMat_low; // r0
  int v10; // r8
  int m_nFlags; // r0
  __int64 v12; // d16
  float v13; // s0
  CMatrix *m_pMat; // r0
  float v15; // s0
  RwReal v16; // s2
  float v17; // s4
  float v18; // s0
  float v19; // s0
  CMatrix *v20; // r0
  float v21; // s0
  RwReal v22; // s2
  float v23; // s4
  float v24; // s0
  CMatrix *v25; // r0
  float v26; // s0
  float v27; // s4
  int v28; // r0
  CEntity **v29; // r9
  CMatrix *v30; // r0
  CSimpleTransform *p_tx; // r2
  double v32; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  int (**v34)(void); // r0
  CMatrix *v35; // r0
  CSimpleTransform *p_m_transform; // r1
  __int64 v37; // kr00_8
  float v38; // s16
  float v39; // s0
  CMatrix *v40; // r0
  float v41; // s0
  float *p_tz; // r0
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v45; // r0
  RwMatrix *v46; // r1
  CEventEditableResponse v47; // [sp+0h] [bp-48h] BYREF
  CEntity *v48; // [sp+10h] [bp-38h]
  int v49; // [sp+14h] [bp-34h]
  uint32 v50; // [sp+18h] [bp-30h]
  double v51; // [sp+1Ch] [bp-2Ch]
  RwReal z; // [sp+24h] [bp-24h]

  p_m_pHoldEntity = &this->m_pHoldEntity;
  m_pHoldEntity = this->m_pHoldEntity;
  if ( m_pHoldEntity )
  {
    *(_DWORD *)&m_pHoldEntity->m_nFlags |= 1u;
    v6 = *p_m_pHoldEntity;
    if ( (*(_BYTE *)&(*p_m_pHoldEntity)->m_info & 7) != 4 )
    {
LABEL_37:
      CEntity::CleanUpOldReference(*p_m_pHoldEntity, p_m_pHoldEntity);
      *p_m_pHoldEntity = 0;
      return;
    }
    v6[5]._vptr$CPlaceable = (int (**)(void))pPed;
    v7 = !bAtSpeed;
    y = v6[1].m_transform.m_translate.y;
    if ( (LOBYTE(y) & 4) == 0 || v7 )
    {
      LODWORD(v6[1].m_transform.m_translate.y) = LODWORD(y) & 0xFDFFFFFF;
      if ( bAtSpeed )
      {
        if ( (*(_DWORD *)&v6->m_nFlags & 0x40004) != 0 )
        {
          (*((void (__fastcall **)(CEntity *, _DWORD))v6->_vptr$CPlaceable + 5))(v6, 0);
          CPhysical::AddToMovingList((CPhysical *)v6);
        }
        v12 = *(_QWORD *)&pPed->m_vecMoveSpeed.x;
        v6[1].m_pMat = (CMatrix *)LODWORD(pPed->m_vecMoveSpeed.z);
        *(_QWORD *)&v6[1].m_transform.m_translate.z = v12;
        v13 = (float)rand();
        m_pMat = pPed->m_pMat;
        v15 = (float)((float)(v13 * 4.6566e-10) * 0.03) + 0.03;
        v16 = (float)(m_pMat->xy * v15) + v6[1].m_transform.m_translate.z;
        v17 = (float)(m_pMat->zy * v15) + *(float *)&v6[1].m_pMat;
        v18 = (float)(m_pMat->yy * v15) + v6[1].m_transform.m_heading;
        v6[1].m_transform.m_translate.z = v16;
        v6[1].m_transform.m_heading = v18;
        *(float *)&v6[1].m_pMat = v17;
        v19 = (float)rand();
        v20 = pPed->m_pMat;
        v21 = (float)((float)(v19 * 4.6566e-10) * 0.06) + -0.03;
        v22 = (float)(v20->xx * v21) + v6[1].m_transform.m_translate.z;
        v23 = (float)(v20->zx * v21) + *(float *)&v6[1].m_pMat;
        v24 = (float)(v20->yx * v21) + v6[1].m_transform.m_heading;
        v6[1].m_transform.m_translate.z = v22;
        v6[1].m_transform.m_heading = v24;
        *(float *)&v6[1].m_pMat = v23;
        v25 = pPed->m_pMat;
        v26 = (float)(v25->yz * 0.01) + v24;
        v27 = (float)(v25->zz * 0.01) + v23;
        v6[1].m_transform.m_translate.z = (float)(v25->xz * 0.01) + v22;
        v6[1].m_transform.m_heading = v26;
        *(float *)&v6[1].m_pMat = v27;
        v10 = (*((int (__fastcall **)(CEntity *, _DWORD))v6->_vptr$CPlaceable + 14))(v6, 0);
      }
      else
      {
        v10 = 0;
        v6[1].m_transform.m_translate.z = 0.0;
        v6[1].m_transform.m_heading = 0.0;
        v6[1].m_pMat = 0;
      }
      goto LABEL_17;
    }
    if ( (BYTE1(v6[5].m_pRwObject) & 0x20) != 0 )
    {
      v10 = 1;
    }
    else
    {
      m_pMat_low = LOBYTE(v6[5].m_pMat);
      v10 = 1;
      if ( m_pMat_low == 2 )
        goto LABEL_17;
      if ( m_pMat_low != 3 )
      {
        if ( m_pMat_low == 6 )
          goto LABEL_17;
        ++CObject::nNoTempObjects;
      }
      v10 = 0;
      v6[5].pReferences = 0;
      m_nFlags = (int)v6->m_nFlags;
      LOBYTE(v6[5].m_pMat) = 3;
      *(_DWORD *)&v6->m_nFlags = m_nFlags & 0xFFFFFF7E;
    }
LABEL_17:
    if ( (BYTE1(v6[5].m_pRwObject) & 0x20) != 0 && pPed->m_pPlayerData != 0 && !v7 )
    {
      CEventEditableResponse::CEventEditableResponse(&v47);
      v29 = (CEntity **)(v28 + 16);
      v48 = pPed;
      v49 = 1114636288;
      v50 = -1;
      v51 = 0.0;
      z = 0.0;
      v47._vptr$CEvent = (int (**)(void))&off_66714C;
      CEntity::RegisterReference(pPed, (CEntity **)(v28 + 16));
      if ( v50 == -1 )
      {
        v50 = CTimer::m_snTimeInMilliseconds;
        v30 = v48->m_pMat;
        p_tx = (CSimpleTransform *)&v30->tx;
        if ( !v30 )
          p_tx = &v48->m_transform;
        v32 = *(double *)&p_tx->m_translate.x;
        z = p_tx->m_translate.z;
        v51 = v32;
      }
      EventGlobalGroup = GetEventGlobalGroup();
      CEventGroup::Add(EventGlobalGroup, (CEvent *)&v47, 0);
      v47._vptr$CEvent = (int (**)(void))&off_66714C;
      if ( v48 )
        CEntity::CleanUpOldReference(v48, v29);
      CEvent::~CEvent((CEvent *)&v47);
    }
    if ( v10 == 1 )
    {
      v34 = v6->_vptr$CPlaceable;
      v6[1].m_transform.m_translate.z = 0.0;
      v6[1].m_transform.m_heading = 0.0;
      v6[1].m_pMat = 0;
      ((void (__fastcall *)(CEntity *, int))v34[5])(v6, 1);
      CPhysical::RemoveFromMovingList((CPhysical *)v6);
      v35 = pPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v35->tx;
      if ( !v35 )
        p_m_transform = &pPed->m_transform;
      v37 = *(_QWORD *)&p_m_transform->m_translate.x;
      v38 = p_m_transform->m_translate.z + -1.0;
      v39 = CEntity::GetColModel(v6)->m_boxBound.m_vecMin.z;
      v40 = v6->m_pMat;
      v41 = v38 - v39;
      if ( v40 )
      {
        LODWORD(v40->tx) = v37;
        v6->m_pMat->ty = *((float *)&v37 + 1);
        p_tz = &v6->m_pMat->tz;
      }
      else
      {
        p_tz = &v6->m_transform.m_translate.z;
        *(_QWORD *)&v6->m_transform.m_translate.x = v37;
      }
      *p_tz = v41;
      m_pRwObject = v6->m_pRwObject;
      if ( m_pRwObject )
      {
        parent = (char *)m_pRwObject->parent;
        v45 = v6->m_pMat;
        v46 = (RwMatrix *)(parent + 16);
        if ( v45 )
          CMatrix::UpdateRwMatrix(v45, v46);
        else
          CSimpleTransform::UpdateRwMatrix(&v6->m_transform, v46);
      }
      CEntity::UpdateRwFrame(v6);
    }
    goto LABEL_37;
  }
}
// 541778: variable 'v28' is possibly undefined
// 66714C: using guessed type void *off_66714C;

//----- (005418B4) --------------------------------------------------------
bool __fastcall CTaskSimpleHoldEntity::ProcessPed(CTaskSimpleHoldEntity *this, CPed *pPed)
{
  int (**v4)(void); // r0
  CEntity **p_m_pHoldEntity; // r6
  CPhysical *v6; // r0
  CAnimBlendHierarchy *m_pAnimHierarchy; // r0
  bool v8; // zf
  bool *p_m_bIsFinished; // r5
  CPhysical *v10; // r0
  CMatrix *m_pMat; // r1
  float m_heading; // s0
  bool v13; // r4
  AnimationId m_nAnimId; // r0
  bool v15; // zf
  CAnimBlendAssociation *m_pAnim; // r0
  int v17; // r0
  CAnimBlendAssociation *v18; // r0
  CEntity *m_pHoldEntity; // r6
  const CMatrix *v20; // r1
  CMatrix *v21; // r1
  CSimpleTransform *p_tx; // r0
  float v23; // s0
  int v24; // s2
  float v25; // s4
  float v26; // s10
  CEntity *v27; // r1
  float x; // s0
  float y; // s2
  CMatrix *v30; // r2
  float *p_x; // r0
  CPad *PadFromPlayer; // r0
  CTaskSimple *v33; // r6
  CTask *v34; // r0
  CTask *v35; // r0
  CTask *TaskSecondary; // r0
  CTask *v38; // r0
  CTask *v39; // r9
  CEntity *v40; // r0
  CTask *v41; // r8
  bool v42; // zf
  __int64 v43; // d16
  CEntity *v44; // r0
  CEventScriptCommand v45[2]; // [sp+0h] [bp-30h] BYREF

  if ( this->m_bIsFirstTime )
  {
    v4 = this->_vptr$CTask;
    this->m_bIsFirstTime = 0;
    p_m_pHoldEntity = &this->m_pHoldEntity;
    if ( ((int (__fastcall *)(CTaskSimpleHoldEntity *))v4[5])(this) == 309 )
    {
      v6 = (CPhysical *)*p_m_pHoldEntity;
      if ( *p_m_pHoldEntity )
        goto LABEL_8;
      m_pAnimHierarchy = this->m_pAnimHierarchy;
      v8 = m_pAnimHierarchy == 0;
      if ( !m_pAnimHierarchy )
        v8 = this->m_nAnimGroup == ANIM_STD_PED;
      if ( v8 )
      {
        if ( !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
          goto LABEL_62;
        TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4);
        if ( (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) != 307 )
          goto LABEL_62;
        v38 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4);
        v39 = v38;
        if ( !v38 )
          goto LABEL_62;
        v41 = v38 + 1;
        v40 = (CEntity *)v38[1]._vptr$CTask;
        v42 = v40 == 0;
        if ( v40 )
          v42 = v39[4].m_pParent == 0;
        if ( !v42 )
        {
          this->m_pHoldEntity = v40;
          CEntity::RegisterReference(v40, &this->m_pHoldEntity);
          v43 = *(_QWORD *)&v39[1].m_pParent;
          LODWORD(this->m_vecAttachOffset.z) = v39[2].m_pParent;
          this->m_nAnimId = ANIM_CARRY_PUTDOWN;
          *(_QWORD *)&this->m_vecAttachOffset.x = v43;
          this->m_nAnimGroup = (AssocGroupId)v39[4].m_pParent;
          CTaskSimpleHoldEntity::ChoosePutDownHeight(this, pPed);
          v44 = (CEntity *)v39[1]._vptr$CTask;
          if ( v44 )
          {
            CEntity::CleanUpOldReference(v44, (CEntity **)&v39[1]);
            v41->_vptr$CTask = 0;
          }
        }
        else
        {
LABEL_62:
          this->m_bIsFinished = 1;
        }
      }
    }
    v6 = (CPhysical *)*p_m_pHoldEntity;
    if ( !*p_m_pHoldEntity )
    {
      p_m_bIsFinished = &this->m_bIsFinished;
      goto LABEL_17;
    }
LABEL_8:
    p_m_bIsFinished = &this->m_bIsFinished;
    if ( !this->m_bIsFinished )
    {
      *(_DWORD *)&v6->m_nFlags &= ~1u;
      v10 = (CPhysical *)*p_m_pHoldEntity;
      if ( (*(_BYTE *)&(*p_m_pHoldEntity)->m_info & 7) == 4 )
      {
        if ( (*(_DWORD *)&v10->m_nFlags & 0x40004) != 0 )
        {
          (*((void (__fastcall **)(CPhysical *, _DWORD))v10->_vptr$CPlaceable + 5))(v10, 0);
          CPhysical::AddToMovingList((CPhysical *)*p_m_pHoldEntity);
          v10 = (CPhysical *)*p_m_pHoldEntity;
        }
        *(_DWORD *)&v10->m_nPhysicalFlags |= 0x2000000u;
        LOBYTE((*p_m_pHoldEntity)[3].m_transform.m_translate.y) = 0;
        v10 = (CPhysical *)*p_m_pHoldEntity;
      }
      m_pMat = v10->m_pMat;
      if ( m_pMat )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        m_heading = v10->m_transform.m_heading;
      this->m_fHeadingOffset = m_heading - pPed->m_fCurrentHeading;
      goto LABEL_20;
    }
LABEL_17:
    v13 = 1;
    *p_m_bIsFinished = 1;
    return v13;
  }
  p_m_bIsFinished = &this->m_bIsFinished;
LABEL_20:
  if ( *p_m_bIsFinished )
    return 1;
  m_nAnimId = this->m_nAnimId;
  v15 = m_nAnimId == ANIM_STD_NUM;
  if ( m_nAnimId == ANIM_STD_NUM )
    v15 = this->m_pAnimHierarchy == 0;
  if ( !v15 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      if ( m_pAnim->m_fBlendDelta < 0.0 && !this->m_bDontDropWhenAnimDone )
        CTaskSimpleHoldEntity::DropEntity(this, pPed, 1);
    }
    else
    {
      CTaskSimpleHoldEntity::StartAnim(this, pPed);
    }
  }
  if ( !this->m_pHoldEntity )
    return 0;
  v17 = (*((int (__fastcall **)(CTaskSimpleHoldEntity *))this->_vptr$CTask + 5))(this);
  if ( v17 != 307 )
  {
    if ( v17 == 309 )
    {
      if ( CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
      {
        v34 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4);
        if ( (*((int (__fastcall **)(CTask *))v34->_vptr$CTask + 5))(v34) == 307 )
        {
          v35 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4);
          v13 = 0;
          (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))v35->_vptr$CTask + 7))(v35, pPed, 1, 0);
          return v13;
        }
      }
    }
    else if ( v17 == 308 )
    {
      v18 = this->m_pAnim;
      if ( (!v18 || v18->m_fCurrentTime < *(float *)&this[1]._vptr$CTask)
        && (*(float *)&this[1].m_pParent != 0.0 || *(float *)&this[1].m_pHoldEntity != 0.0) )
      {
        m_pHoldEntity = this->m_pHoldEntity;
        v20 = m_pHoldEntity->m_pMat;
        if ( !v20 )
        {
          CPlaceable::AllocateMatrix(this->m_pHoldEntity);
          CSimpleTransform::UpdateMatrix(&m_pHoldEntity->m_transform, m_pHoldEntity->m_pMat);
          v20 = m_pHoldEntity->m_pMat;
        }
        operator*((CVector *)v45, v20, (const CVector *)&this[1].m_pParent);
        v21 = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&v21->tx;
        if ( !v21 )
          p_tx = &pPed->m_transform;
        v23 = *(float *)&v45[0]._vptr$CEvent - p_tx->m_translate.x;
        *(float *)&v24 = *(float *)&v45[0].m_iAccumulatedTime - p_tx->m_translate.y;
        v25 = *(float *)&v45[0].m_bIsPersistent - p_tx->m_translate.z;
        *(float *)&v45[0]._vptr$CEvent = v23;
        v45[0].m_iAccumulatedTime = v24;
        *(float *)&v45[0].m_bIsPersistent = v25;
        v26 = CTimer::ms_fTimeStep;
        pPed->m_extractedVelocity.x = pPed->m_extractedVelocity.x
                                    + (float)((float)((float)((float)((float)(v23 * v21->xx)
                                                                    + (float)(*(float *)&v24 * v21->yx))
                                                            + (float)(v25 * v21->zx))
                                                    * 0.1)
                                            / CTimer::ms_fTimeStep);
        pPed->m_extractedVelocity.y = pPed->m_extractedVelocity.y
                                    + (float)((float)((float)((float)((float)(v23 * v21->xy)
                                                                    + (float)(*(float *)&v24 * v21->yy))
                                                            + (float)(v25 * v21->zy))
                                                    * 0.1)
                                            / v26);
        v27 = this->m_pHoldEntity;
        x = p_tx->m_translate.x;
        y = p_tx->m_translate.y;
        v30 = v27->m_pMat;
        p_x = &v30->tx;
        if ( !v30 )
          p_x = &v27->m_transform.m_translate.x;
        pPed->m_fDesiredHeading = atan2f(-(float)(*p_x - x), p_x[1] - y);
      }
    }
    return 0;
  }
  if ( (unsigned int)(this->m_nAnimGroup - 81) > 2 || !CPed::IsPlayer(pPed) )
    return 0;
  PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
  v13 = 0;
  if ( CPad::DropItemJustDown(PadFromPlayer) )
  {
    v33 = (CTaskSimple *)CTask::operator new(0x40u);
    CTaskSimple::CTaskSimple(v33);
    v33[1] = 0LL;
    v33[2] = 0LL;
    LOWORD(v33[3]._vptr$CTask) = 262;
    v33[4]._vptr$CTask = (int (**)(void))(&dword_BC + 3);
    v33[4].m_pParent = 0;
    v33[5].m_pParent = 0;
    v33[6]._vptr$CTask = 0;
    LOWORD(v33[6].m_pParent) = 256;
    BYTE2(v33[6].m_pParent) = 0;
    v33[7]._vptr$CTask = 0;
    v33[7].m_pParent = (CTask *)1058642330;
    v33->_vptr$CTask = (int (**)(void))&off_66D298;
    CTaskSimpleHoldEntity::m_nPutDownTimer = 2000;
    CEventScriptCommand::CEventScriptCommand(v45, 3, v33, 0);
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, v45, 0);
    CEventScriptCommand::~CEventScriptCommand(v45);
  }
  return v13;
}
// BC: using guessed type int dword_BC;
// 66D298: using guessed type void *;

//----- (00541CD0) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::ChoosePutDownHeight(CTaskSimpleHoldEntity *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  float yy; // s4
  float v8; // s6
  float xy; // s2
  float z; // s12
  float x; // s8
  float y; // s10
  CMatrix *v13; // r0
  float v14; // s2
  AssocGroupId v15; // r0
  AssocGroupId m_nAnimGroup; // r0
  int *v17; // r1
  int v18; // s0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-4Ch] BYREF
  CColPoint colPoint; // [sp+20h] [bp-48h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-1Ch] BYREF

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  yy = m_pMat->yy;
  v8 = m_pMat->zy * 0.65;
  xy = m_pMat->xy;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  z = p_tx->m_translate.z;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  refEntityPtr = 0;
  vecStart.y = (float)(yy * 0.65) + y;
  vecStart.x = (float)(xy * 0.65) + x;
  vecStart.z = (float)(v8 + z) + 0.2;
  if ( CWorld::ProcessVerticalLine(&vecStart, vecStart.z + -1.5, &colPoint, &refEntityPtr, 1, 0, 0, 1, 0, 0, 0) )
  {
    v13 = pPed->m_pMat;
    if ( v13 )
      p_m_transform = (CSimpleTransform *)&v13->tx;
    v14 = p_m_transform->m_translate.z;
    if ( colPoint.m_vecPosition.z >= (float)(v14 + -0.2) )
    {
      v15 = ANIM_CARRY_BOX_105;
    }
    else
    {
      v15 = ANIM_CARRY_BOX;
      if ( colPoint.m_vecPosition.z >= (float)(v14 + -0.7) )
        v15 = ANIM_CARRY_BOX_05;
    }
  }
  else
  {
    v15 = ANIM_CARRY_BOX;
  }
  this->m_nAnimGroup = v15;
  if ( (*((int (__fastcall **)(CTaskSimpleHoldEntity *))this->_vptr$CTask + 5))(this) == 309 )
  {
    m_nAnimGroup = this->m_nAnimGroup;
    v17 = dword_541DF0;
    if ( m_nAnimGroup == ANIM_CARRY_BOX_05 )
      v17 = &dword_541DF0[1];
    v18 = *v17;
    if ( m_nAnimGroup == ANIM_CARRY_BOX_105 )
      v18 = 1054727646;
    this[1]._vptr$CTask = (int (**)(void))v18;
  }
}
// 541DF0: using guessed type int dword_541DF0[2];

//----- (00541DFC) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::ReleaseEntity(CTaskSimpleHoldEntity *this)
{
  CEntity *m_pHoldEntity; // r0
  CEntity **p_m_pHoldEntity; // r4

  p_m_pHoldEntity = &this->m_pHoldEntity;
  m_pHoldEntity = this->m_pHoldEntity;
  if ( m_pHoldEntity )
  {
    CEntity::CleanUpOldReference(m_pHoldEntity, p_m_pHoldEntity);
    *p_m_pHoldEntity = 0;
  }
}

//----- (00541E18) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::StartAnim(CTaskSimpleHoldEntity *this, CPed *pPed)
{
  CAnimBlendHierarchy *m_pAnimHierarchy; // r1
  int v5; // r2
  AssocGroupId m_nAnimGroup; // r1
  CAnimBlock *m_pAnimBlock; // r6
  const unsigned __int8 *AnimBlockName; // r0
  int v9; // r0
  CAnimBlendAssociation *v10; // r0
  int v11; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnimHierarchy = this->m_pAnimHierarchy;
  if ( m_pAnimHierarchy )
  {
    v5 = this->m_nAnimFlags | 0x414;
    this->m_nAnimFlags = v5;
    this->m_pAnim = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, m_pAnimHierarchy, v5, 4.0);
  }
  else
  {
    m_nAnimGroup = this->m_nAnimGroup;
    if ( m_nAnimGroup )
    {
      if ( !this->m_pAnimBlock )
      {
        m_pAnimBlock = CAnimManager::ms_aAnimAssocGroups[m_nAnimGroup].m_pAnimBlock;
        if ( !m_pAnimBlock )
        {
          AnimBlockName = CAnimManager::GetAnimBlockName(this->m_nAnimGroup);
          m_pAnimBlock = CAnimManager::GetAnimationBlock(AnimBlockName);
        }
        v9 = m_pAnimBlock - CAnimManager::ms_aAnimBlocks;
        if ( !m_pAnimBlock->m_loaded )
        {
          sub_192918(v9 + 25575, 8);
          return;
        }
        CAnimManager::AddAnimBlockRef(v9);
        m_nAnimGroup = this->m_nAnimGroup;
        this->m_pAnimBlock = m_pAnimBlock;
      }
    }
    else
    {
      m_nAnimGroup = ANIM_STD_PED;
    }
    v10 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, m_nAnimGroup, this->m_nAnimId, 4.0);
    this->m_pAnim = v10;
    v10->m_bitsFlag |= 4u;
    if ( (*((int (__fastcall **)(CTaskSimpleHoldEntity *))this->_vptr$CTask + 5))(this) == 307 )
      this->m_pAnim->m_bitsFlag |= 0x400u;
  }
  v11 = (*((int (__fastcall **)(CTaskSimpleHoldEntity *))this->_vptr$CTask + 5))(this);
  m_pAnim = this->m_pAnim;
  if ( v11 == 308 )
    sub_18C19C(m_pAnim, CTaskSimpleHoldEntity::FinishAnimHoldEntityCB, this);
  else
    sub_1929E0(m_pAnim, CTaskSimpleHoldEntity::FinishAnimHoldEntityCB, this);
}

//----- (00541F18) --------------------------------------------------------
bool __fastcall CTaskSimpleHoldEntity::SetPedPosition(CTaskSimpleHoldEntity *this, CPed *pPed)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool v5; // r6
  int v6; // r0
  bool v7; // zf
  CEntity *m_pHoldEntity; // r0
  CEntity::CFlags m_nFlags; // r2
  CMatrix *v10; // r1
  CEntity *v11; // r0
  CSimpleTransform *p_tx; // r3
  CMatrix *v13; // r2
  __int64 v14; // kr00_8
  float v15; // r1
  __int64 v16; // d16
  RpHAnimHierarchy_0 *v17; // r6
  RwInt32 v18; // r8
  RwMatrix *v19; // r0
  RwReal v20; // s2
  RwReal v21; // s4
  CMatrix *v22; // r0
  CEntity *v23; // r5
  CMatrix *v24; // r0
  CEntity *v25; // r1
  RwReal y; // r2
  RwReal z; // r0
  CMatrix *v28; // r6
  RwReal *p_z; // r1
  CAnimBlendAssociation *v30; // r0
  __int64 v31; // d16
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v33; // r5
  RwMatrix *v34; // r5
  CEntity *v35; // r6
  CMatrix *m_pMat; // r0
  CEntity *v37; // r1
  __int64 v38; // kr08_8
  float zx; // r0
  CMatrix *v40; // r6
  float *p_tz; // r1
  CEntity *v42; // r2
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v45; // r0
  RwMatrix *v46; // r1
  CMatrix v48; // [sp+0h] [bp-68h] BYREF
  CVector v; // [sp+48h] [bp-20h] BYREF

  if ( (*((int (__fastcall **)(CTaskSimpleHoldEntity *))this->_vptr$CTask + 5))(this) == 308 )
  {
    m_pAnim = this->m_pAnim;
    if ( !m_pAnim || m_pAnim->m_fCurrentTime < *(float *)&this[1]._vptr$CTask )
      return 0;
    goto LABEL_8;
  }
  v6 = (*((int (__fastcall **)(CTaskSimpleHoldEntity *))this->_vptr$CTask + 5))(this);
  v7 = v6 == 309;
  if ( v6 == 309 )
    v7 = !this->m_bIsFirstTime;
  if ( !v7 || (v30 = this->m_pAnim) != 0 && v30->m_fCurrentTime <= *(float *)&this[1]._vptr$CTask )
  {
LABEL_8:
    m_pHoldEntity = this->m_pHoldEntity;
    if ( m_pHoldEntity )
    {
      m_nFlags = m_pHoldEntity->m_nFlags;
      *(_DWORD *)&m_nFlags = *(_DWORD *)&m_nFlags & 0xFFFFFF7F | (((*(_DWORD *)&pPed->m_nFlags >> 7) & 1) << 7);
      m_pHoldEntity->m_nFlags = m_nFlags;
      if ( (*((_BYTE *)&pPed->m_nPedFlags + 9) & 4) != 0 )
      {
        if ( (this->m_nOrientateFlags & 0x10) != 0 )
        {
          v31 = *(_QWORD *)&this->m_vecAttachOffset.x;
          v48.zx = this->m_vecAttachOffset.z;
          *(_QWORD *)&v48.xx = v31;
          AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
          v33 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, pPed->m_aPedFrames[this->m_nBoneId]->boneTag);
          v34 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v33];
          RwV3dTransformPoints((RwV3d_0 *)&v48, (const RwV3d_0 *)&v48, 1, v34);
          v35 = this->m_pHoldEntity;
          m_pMat = v35->m_pMat;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(this->m_pHoldEntity);
            CSimpleTransform::UpdateMatrix(&v35->m_transform, v35->m_pMat);
            m_pMat = v35->m_pMat;
          }
          CMatrix::UpdateMatrix(m_pMat, v34);
          v37 = this->m_pHoldEntity;
          v38 = *(_QWORD *)&v48.xx;
          zx = v48.zx;
          v40 = v37->m_pMat;
          if ( v40 )
          {
            v40->tx = v48.xx;
            v37->m_pMat->ty = *((float *)&v38 + 1);
            p_tz = &v37->m_pMat->tz;
          }
          else
          {
            *(_QWORD *)&v37->m_transform.m_translate.x = *(_QWORD *)&v48.xx;
            p_tz = &v37->m_transform.m_translate.z;
          }
          *p_tz = zx;
        }
        else
        {
          v16 = *(_QWORD *)&this->m_vecAttachOffset.x;
          v.z = this->m_vecAttachOffset.z;
          *(_QWORD *)&v.x = v16;
          Multiply3x3((CVector *)&v48, pPed->m_pMat, &v);
          v.z = v48.zx;
          *(_QWORD *)&v.x = *(_QWORD *)&v48.xx;
          v17 = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
          v18 = RpHAnimIDGetIndex(v17, pPed->m_aPedFrames[this->m_nBoneId]->boneTag);
          v19 = &RpHAnimHierarchyGetMatrixArray(v17)[v18];
          v20 = v19->pos.y + v.y;
          v21 = v19->pos.z + v.z;
          v.x = v19->pos.x + v.x;
          v.y = v20;
          v.z = v21;
          CMatrix::CMatrix(&v48, pPed->m_pMat);
          CMatrix::RotateZ(v22, this->m_fHeadingOffset);
          v23 = this->m_pHoldEntity;
          v24 = v23->m_pMat;
          if ( !v24 )
          {
            CPlaceable::AllocateMatrix(this->m_pHoldEntity);
            CSimpleTransform::UpdateMatrix(&v23->m_transform, v23->m_pMat);
            v24 = v23->m_pMat;
          }
          CMatrix::operator=(v24, &v48);
          v25 = this->m_pHoldEntity;
          y = v.y;
          z = v.z;
          v28 = v25->m_pMat;
          if ( v28 )
          {
            v28->tx = v.x;
            v25->m_pMat->ty = y;
            p_z = &v25->m_pMat->tz;
          }
          else
          {
            v25->m_transform.m_translate.x = v.x;
            v25->m_transform.m_translate.y = y;
            p_z = &v25->m_transform.m_translate.z;
          }
          *p_z = z;
          CMatrix::~CMatrix(&v48);
        }
      }
      else
      {
        v10 = pPed->m_pMat;
        v11 = this->m_pHoldEntity;
        p_tx = (CSimpleTransform *)&v10->tx;
        v13 = v11->m_pMat;
        if ( !v10 )
          p_tx = &pPed->m_transform;
        v14 = *(_QWORD *)&p_tx->m_translate.x;
        v15 = p_tx->m_translate.z;
        if ( v13 )
        {
          LODWORD(v13->tx) = v14;
          v11->m_pMat->ty = *((float *)&v14 + 1);
          v11->m_pMat->tz = v15;
        }
        else
        {
          *(_QWORD *)&v11->m_transform.m_translate.x = v14;
          v11->m_transform.m_translate.z = v15;
        }
      }
      v42 = this->m_pHoldEntity;
      m_pRwObject = v42->m_pRwObject;
      if ( m_pRwObject )
      {
        parent = (char *)m_pRwObject->parent;
        v45 = v42->m_pMat;
        v46 = (RwMatrix *)(parent + 16);
        if ( v45 )
          CMatrix::UpdateRwMatrix(v45, v46);
        else
          CSimpleTransform::UpdateRwMatrix(&v42->m_transform, v46);
      }
      CEntity::UpdateRwFrame(this->m_pHoldEntity);
      return 1;
    }
    else
    {
      v5 = 0;
      (*((void (__fastcall **)(CTaskSimpleHoldEntity *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(this, pPed, 1, 0);
    }
    return v5;
  }
  v5 = 0;
  if ( this->m_pHoldEntity )
    CTaskSimpleHoldEntity::DropEntity(this, pPed, 0);
  return v5;
}
// 54204A: variable 'v22' is possibly undefined

//----- (00542170) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::FinishAnimHoldEntityCB(CAnimBlendAssociation *pAnim, void *pData)
{
  CEntity *v4; // r0

  if ( *((_BYTE *)pData + 54) )
  {
    *((_DWORD *)pData + 14) = 0;
    *((_QWORD *)pData + 4) = 191LL;
  }
  else
  {
    if ( (*(int (__fastcall **)(void *))(*(_DWORD *)pData + 20))(pData) == 308 && pAnim->m_fBlendAmount > 0.0 )
    {
      v4 = (CEntity *)*((_DWORD *)pData + 2);
      if ( v4 )
      {
        CEntity::CleanUpOldReference(v4, (CEntity **)pData + 2);
        *((_DWORD *)pData + 2) = 0;
      }
    }
    *((_BYTE *)pData + 52) = 1;
    *((_DWORD *)pData + 14) = 0;
  }
}

//----- (005421C8) --------------------------------------------------------
bool __fastcall CTaskSimpleHoldEntity::CanThrowEntity(CTaskSimpleHoldEntity *this)
{
  return this->m_pHoldEntity && __PAIR64__(this->m_nOrientateFlags, this->m_nBoneId) == 0x1000000006LL;
}

//----- (005421E0) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::PlayAnim(
        CTaskSimpleHoldEntity *this,
        AnimationId nAnimId,
        AssocGroupId nAnimGroup)
{
  this->m_nAnimId = nAnimId;
  this->m_nAnimGroup = nAnimGroup;
}

//----- (005421E8) --------------------------------------------------------
void __fastcall CTaskSimplePickUpEntity::CTaskSimplePickUpEntity(
        CTaskSimplePickUpEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        AnimationId nAnimId,
        AssocGroupId nAnimGroup,
        float fTimeToAttach)
{
  __int64 v12; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_nAnimId = nAnimId;
  this->m_nAnimGroup = nAnimGroup;
  this->m_pAnimBlock = 0;
  this->m_pAnimHierarchy = 0;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v12 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v12;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
  this->m_fTimeToAttach = fTimeToAttach;
  this->m_vecTargetOffset.x = 0.0;
  this->m_vecTargetOffset.y = 0.0;
  this->m_vecTargetOffset.z = 0.0;
  this->_vptr$CTask = (int (**)(void))&off_66D264;
}
// 66D18C: using guessed type void *off_66D18C;
// 66D264: using guessed type void *;

//----- (00542290) --------------------------------------------------------
void __fastcall CTaskSimplePickUpEntity::CTaskSimplePickUpEntity(
        CTaskSimplePickUpEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        const unsigned __int8 *pAnimName,
        const unsigned __int8 *pAnimGroupName,
        int32 nFlags,
        float fTimeToAttach)
{
  int v9; // r0

  CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
    this,
    pEntity,
    pVecOffset,
    nBone,
    nOrientateFlags,
    pAnimName,
    pAnimGroupName,
    nFlags);
  *(float *)(v9 + 60) = fTimeToAttach;
  *(_DWORD *)(v9 + 64) = 0;
  *(_DWORD *)(v9 + 68) = 0;
  *(_DWORD *)(v9 + 72) = 0;
  *(_DWORD *)v9 = &off_66D264;
}
// 5422B4: variable 'v9' is possibly undefined
// 66D264: using guessed type void *off_66D264;

//----- (005422CC) --------------------------------------------------------
void __fastcall CTaskSimplePickUpEntity::CTaskSimplePickUpEntity(
        CTaskSimplePickUpEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        CAnimBlock *pAnimBlock,
        CAnimBlendHierarchy *pAnimHierarchy,
        int32 nFlags,
        float fTimeToAttach)
{
  __int64 v13; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_fHeadingOffset = 0.0;
  this->m_nAnimId = ANIM_STD_NUM;
  this->m_nAnimGroup = ANIM_STD_PED;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v13 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v13;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
  this->m_pAnimBlock = pAnimBlock;
  this->m_nAnimFlags = nFlags;
  this->m_pAnimHierarchy = pAnimHierarchy;
  CAnimManager::AddAnimBlockRef(pAnimBlock - CAnimManager::ms_aAnimBlocks);
  this->m_fTimeToAttach = fTimeToAttach;
  this->_vptr$CTask = (int (**)(void))&off_66D264;
  this->m_vecTargetOffset.x = 0.0;
  this->m_vecTargetOffset.y = 0.0;
  this->m_vecTargetOffset.z = 0.0;
}
// 66D18C: using guessed type void *off_66D18C;
// 66D264: using guessed type void *off_66D264;

//----- (00542394) --------------------------------------------------------
void __fastcall CTaskSimplePutDownEntity::CTaskSimplePutDownEntity(
        CTaskSimplePutDownEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        AnimationId nAnimId,
        AssocGroupId nAnimGroup,
        float fTimeToDrop)
{
  __int64 v12; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_nAnimId = nAnimId;
  this->m_nAnimGroup = nAnimGroup;
  this->m_pAnimBlock = 0;
  this->m_pAnimHierarchy = 0;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v12 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v12;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
  this->m_fTimeToDrop = fTimeToDrop;
  this->_vptr$CTask = (int (**)(void))&off_66D298;
}
// 66D18C: using guessed type void *off_66D18C;
// 66D298: using guessed type void *off_66D298;

//----- (00542434) --------------------------------------------------------
void __fastcall CTaskSimplePutDownEntity::CTaskSimplePutDownEntity(
        CTaskSimplePutDownEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        const unsigned __int8 *pAnimName,
        const unsigned __int8 *pAnimGroupName,
        int32 nFlags,
        float fTimeToDrop)
{
  int v9; // r0

  CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
    this,
    pEntity,
    pVecOffset,
    nBone,
    nOrientateFlags,
    pAnimName,
    pAnimGroupName,
    nFlags);
  *(float *)(v9 + 60) = fTimeToDrop;
  *(_DWORD *)v9 = &off_66D298;
}
// 542456: variable 'v9' is possibly undefined
// 66D298: using guessed type void *off_66D298;

//----- (00542468) --------------------------------------------------------
void __fastcall CTaskSimplePutDownEntity::CTaskSimplePutDownEntity(
        CTaskSimplePutDownEntity *this,
        CEntity *pEntity,
        const CVector *pVecOffset,
        uint8 nBone,
        uint8 nOrientateFlags,
        CAnimBlock *pAnimBlock,
        CAnimBlendHierarchy *pAnimHierarchy,
        int32 nFlags,
        float fTimeToDrop)
{
  __int64 v13; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_vecAttachOffset.y = 0.0;
  this->m_vecAttachOffset.z = 0.0;
  this->m_nOrientateFlags = nOrientateFlags;
  this->m_nBoneId = nBone;
  this->m_fHeadingOffset = 0.0;
  this->m_nAnimId = ANIM_STD_NUM;
  this->m_nAnimGroup = ANIM_STD_PED;
  this->m_pAnim = 0;
  *(_WORD *)&this->m_bIsFinished = 256;
  this->m_bDontDropWhenAnimDone = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  this->m_vecAttachOffset.x = 0.0;
  this->m_pHoldEntity = pEntity;
  if ( pVecOffset )
  {
    v13 = *(_QWORD *)&pVecOffset->x;
    this->m_vecAttachOffset.z = pVecOffset->z;
    *(_QWORD *)&this->m_vecAttachOffset.x = v13;
  }
  if ( pEntity )
  {
    *(_DWORD *)&pEntity->m_nFlags |= 0x400u;
    CEntity::RegisterReference(this->m_pHoldEntity, &this->m_pHoldEntity);
  }
  this->m_pAnimBlock = pAnimBlock;
  this->m_nAnimFlags = nFlags;
  this->m_pAnimHierarchy = pAnimHierarchy;
  CAnimManager::AddAnimBlockRef(pAnimBlock - CAnimManager::ms_aAnimBlocks);
  this->m_fTimeToDrop = fTimeToDrop;
  this->_vptr$CTask = (int (**)(void))&off_66D298;
}
// 66D18C: using guessed type void *off_66D18C;
// 66D298: using guessed type void *off_66D298;

//----- (00542528) --------------------------------------------------------
void __fastcall CTaskSimplePutDownEntity::CTaskSimplePutDownEntity(CTaskSimplePutDownEntity *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v1 + 24) = 262;
  *(_QWORD *)(v1 + 32) = 191LL;
  *(_DWORD *)(v1 + 44) = 0;
  *(_DWORD *)(v1 + 48) = 0;
  *(_WORD *)(v1 + 52) = 256;
  *(_BYTE *)(v1 + 54) = 0;
  *(_QWORD *)(v1 + 8) = 0LL;
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)(v1 + 60) = 1058642330;
  *(_DWORD *)v1 = &off_66D298;
}
// 542536: variable 'v1' is possibly undefined
// 66D298: using guessed type void *off_66D298;

//----- (00542580) --------------------------------------------------------
void __fastcall CTaskComplexGoPickUpEntity::CTaskComplexGoPickUpEntity(
        CTaskComplexGoPickUpEntity *this,
        CEntity *pEntity,
        AssocGroupId nAnimGroup)
{
  CTaskComplex::CTaskComplex(this);
  this->m_vecGoTargetOffset.y = 0.0;
  this->m_nAnimGroup = nAnimGroup;
  *(_QWORD *)&this->m_vecAttachOffset.x = 3296313344LL;
  *(_QWORD *)&this->m_vecAttachOffset.z = 0xC479C00000000000LL;
  this->m_vecGoTargetOffset.z = 0.0;
  this->_vptr$CTask = (int (**)(void))&off_66D1C0;
  this->m_pHoldEntity = pEntity;
  if ( pEntity )
    CEntity::RegisterReference(pEntity, &this->m_pHoldEntity);
  this->m_bAnimsReferenced = 0;
  this->m_nStartTime = 0;
}
// 66D1C0: using guessed type void *;

//----- (005425F4) --------------------------------------------------------
void __fastcall CTaskComplexGoPickUpEntity::~CTaskComplexGoPickUpEntity(CTaskComplexGoPickUpEntity *this)
{
  CEntity *m_pHoldEntity; // r0
  CEntity **p_m_pHoldEntity; // r1

  p_m_pHoldEntity = &this->m_pHoldEntity;
  m_pHoldEntity = this->m_pHoldEntity;
  this->_vptr$CTask = (int (**)(void))&off_66D1C0;
  if ( m_pHoldEntity )
    CEntity::CleanUpOldReference(m_pHoldEntity, p_m_pHoldEntity);
  if ( this->m_bAnimsReferenced )
  {
    CAnimManager::RemoveAnimBlockRef(CAnimManager::ms_aAnimAssocGroups[this->m_nAnimGroup].m_pAnimBlock - CAnimManager::ms_aAnimBlocks);
    this->m_bAnimsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66D1C0: using guessed type void *off_66D1C0;

//----- (00542654) --------------------------------------------------------
void __fastcall CTaskComplexGoPickUpEntity::~CTaskComplexGoPickUpEntity(CTaskComplexGoPickUpEntity *this)
{
  CEntity *m_pHoldEntity; // r0
  CEntity **p_m_pHoldEntity; // r1
  void *v4; // r0

  p_m_pHoldEntity = &this->m_pHoldEntity;
  m_pHoldEntity = this->m_pHoldEntity;
  this->_vptr$CTask = (int (**)(void))&off_66D1C0;
  if ( m_pHoldEntity )
    CEntity::CleanUpOldReference(m_pHoldEntity, p_m_pHoldEntity);
  if ( this->m_bAnimsReferenced )
  {
    CAnimManager::RemoveAnimBlockRef(CAnimManager::ms_aAnimAssocGroups[this->m_nAnimGroup].m_pAnimBlock - CAnimManager::ms_aAnimBlocks);
    this->m_bAnimsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5426A8: variable 'v4' is possibly undefined
// 66D1C0: using guessed type void *off_66D1C0;

//----- (005426B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoPickUpEntity::CreateFirstSubTask(CTaskComplexGoPickUpEntity *this, CPed *pPed)
{
  CEntity *m_pHoldEntity; // r5
  float *p_x; // r3
  CMatrix *m_pMat; // r0
  CMatrix *v6; // r2
  CSimpleTransform *p_tx; // r0
  float v8; // s16
  float v9; // s18
  float v10; // s20
  CColModel *m_pColModel; // r8
  float y; // s2
  float x; // s0
  float v14; // r1
  CMatrix *v15; // r0
  float v16; // s0
  CTask *result; // r0
  float v18; // s2
  CMatrix *v19; // r0
  CMatrix *v20; // r5
  CEntity *v21; // r2
  CEntity *v22; // r1
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v25; // r0
  RwMatrix *v26; // r1
  CEntity *v27; // r6
  float *p_xx; // r0
  CEntity *v29; // r5
  float *v30; // r1
  float v31; // s22
  float v32; // s0
  float v33; // s2
  float v34; // s0
  float v35; // s2
  RwReal v36; // s2
  float v37; // s0
  float v38; // s0
  float v39; // s2
  CEntity *v40; // r5
  CVector *p_m_vecGoTargetOffset; // r4
  const CMatrix *v42; // r1
  CTaskComplexGoToPointAndStandStill *v43; // r0
  CVector v44; // [sp+10h] [bp-50h] BYREF
  CVector vTarget; // [sp+20h] [bp-40h] BYREF

  m_pHoldEntity = this->m_pHoldEntity;
  if ( !m_pHoldEntity )
    return 0;
  p_x = &m_pHoldEntity->m_transform.m_translate.x;
  this->m_nStartTime = CTimer::m_snTimeInMilliseconds;
  m_pMat = m_pHoldEntity->m_pMat;
  v6 = pPed->m_pMat;
  if ( m_pMat )
    p_x = &m_pMat->tx;
  p_tx = (CSimpleTransform *)&v6->tx;
  if ( !v6 )
    p_tx = &pPed->m_transform;
  v8 = p_tx->m_translate.x - *p_x;
  v9 = p_tx->m_translate.y - p_x[1];
  v10 = p_tx->m_translate.z - p_x[2];
  vTarget.y = v9;
  vTarget.x = v8;
  vTarget.z = v10;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[m_pHoldEntity->m_nModelIndex]->m_pColModel;
  this->m_vecAttachOffset.x = -0.2;
  this->m_vecAttachOffset.y = -0.2 - m_pColModel->m_boxBound.m_vecMin.y;
  this->m_vecAttachOffset.z = -m_pColModel->m_boxBound.m_vecMin.z;
  y = m_pColModel->m_boxBound.m_vecMax.y;
  x = m_pColModel->m_boxBound.m_vecMax.x;
  if ( x > (float)(y + y) )
  {
    v14 = atan2f(COERCE_FLOAT(LODWORD(v8) ^ 0x80000000), v9);
    v15 = m_pHoldEntity->m_pMat;
    v16 = v14;
    if ( !v15 )
      goto LABEL_13;
    goto LABEL_19;
  }
  if ( y > (float)(x + x) )
  {
    v18 = atan2f(COERCE_FLOAT(LODWORD(v8) ^ 0x80000000), v9);
    v15 = m_pHoldEntity->m_pMat;
    v16 = v18 + -1.5708;
    if ( !v15 )
    {
LABEL_13:
      m_pHoldEntity->m_transform.m_heading = v16;
      goto LABEL_20;
    }
    v14 = v18 + -1.5708;
    goto LABEL_19;
  }
  v19 = m_pHoldEntity->m_pMat;
  if ( !v19 )
  {
    CPlaceable::AllocateMatrix(m_pHoldEntity);
    CSimpleTransform::UpdateMatrix(&m_pHoldEntity->m_transform, m_pHoldEntity->m_pMat);
    v19 = m_pHoldEntity->m_pMat;
  }
  if ( v19->zz < 0.9 )
  {
    v20 = this->m_pHoldEntity->m_pMat;
    if ( v20 )
    {
      v14 = atan2f(COERCE_FLOAT(LODWORD(v20->xy) ^ 0x80000000), v20->yy);
      v15 = v20;
LABEL_19:
      CMatrix::SetRotateZOnly(v15, v14);
    }
  }
LABEL_20:
  v21 = this->m_pHoldEntity;
  if ( (*(_BYTE *)&v21->m_info & 7) == 4 )
  {
    v21[1].m_transform.m_translate.z = 0.0;
    v21[1].m_transform.m_heading = 0.0;
    v21[1].m_pMat = 0;
    v22 = this->m_pHoldEntity;
    v22[1].m_pRwObject = 0;
    *(_DWORD *)&v22[1].m_nFlags = 0;
    v22[1].m_nFlags.bdummy = 0;
    (*((void (__fastcall **)(CEntity *, int))this->m_pHoldEntity->_vptr$CPlaceable + 5))(this->m_pHoldEntity, 1);
    v21 = this->m_pHoldEntity;
  }
  m_pRwObject = v21->m_pRwObject;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    v25 = v21->m_pMat;
    v26 = (RwMatrix *)(parent + 16);
    if ( v25 )
      CMatrix::UpdateRwMatrix(v25, v26);
    else
      CSimpleTransform::UpdateRwMatrix(&v21->m_transform, v26);
  }
  v27 = this->m_pHoldEntity;
  p_xx = &v27->m_pMat->xx;
  if ( p_xx )
  {
    v29 = this->m_pHoldEntity;
    v30 = &v27->m_pMat->xx;
  }
  else
  {
    CPlaceable::AllocateMatrix(this->m_pHoldEntity);
    CSimpleTransform::UpdateMatrix(&v27->m_transform, v27->m_pMat);
    v29 = this->m_pHoldEntity;
    v30 = &v27->m_pMat->xx;
    p_xx = &v29->m_pMat->xx;
  }
  v31 = (float)((float)(v8 * *v30) + (float)(v9 * v30[1])) + (float)(v10 * v30[2]);
  if ( !p_xx )
  {
    CPlaceable::AllocateMatrix(v29);
    CSimpleTransform::UpdateMatrix(&v29->m_transform, v29->m_pMat);
    p_xx = &v29->m_pMat->xx;
  }
  v32 = (float)((float)(v8 * p_xx[4]) + (float)(v9 * p_xx[5])) + (float)(v10 * p_xx[6]);
  v33 = fabsf(v32);
  if ( v31 <= v33 )
  {
    if ( v31 >= (float)-v33 )
    {
      this->m_vecGoTargetOffset.x = 0.0;
      if ( v32 <= 0.0 )
      {
        v38 = -0.4;
        v39 = m_pColModel->m_boxBound.m_vecMin.y;
      }
      else
      {
        v38 = 0.4;
        v39 = m_pColModel->m_boxBound.m_vecMax.y;
      }
      v37 = v39 + v38;
      goto LABEL_40;
    }
    v34 = -0.4;
    v35 = m_pColModel->m_boxBound.m_vecMin.x;
  }
  else
  {
    v34 = 0.4;
    v35 = m_pColModel->m_boxBound.m_vecMax.x;
  }
  v36 = v35 + v34;
  v37 = 0.0;
  this->m_vecGoTargetOffset.x = v36;
LABEL_40:
  this->m_vecGoTargetOffset.y = v37;
  this->m_vecGoTargetOffset.z = m_pColModel->m_boxBound.m_vecMin.z + 1.0;
  v40 = this->m_pHoldEntity;
  p_m_vecGoTargetOffset = &this->m_vecGoTargetOffset;
  v42 = v40->m_pMat;
  if ( !v42 )
  {
    CPlaceable::AllocateMatrix(v40);
    CSimpleTransform::UpdateMatrix(&v40->m_transform, v40->m_pMat);
    v42 = v40->m_pMat;
  }
  operator*(&v44, v42, p_m_vecGoTargetOffset);
  vTarget = v44;
  v43 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
  CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(v43, 4, &vTarget, 0.2, 0.0, 0, 1);
  return result;
}

//----- (005429AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoPickUpEntity::CreateNextSubTask(CTaskComplexGoPickUpEntity *this, CPed *pPed)
{
  int v4; // r0
  CEntity *v5; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v7; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float v10; // s0
  float v11; // r4
  char *v12; // r5
  float v13; // r0
  CPedIntelligence *m_pPedIntelligence; // r8
  char *v15; // r6
  CEntity *m_pHoldEntity; // r9
  __int64 v17; // d16
  int v18; // s16
  CEntity *v19; // r0
  CMatrix *v20; // r1
  CSimpleTransform *p_m_transform; // r2
  float z; // s18
  float v23; // s0
  CMatrix *v24; // r0
  float v25; // s0
  CSimpleTransform *v26; // r1
  float v27; // s2
  AssocGroupId v28; // r0
  CEntity *v29; // r8
  AssocGroupId m_nAnimGroup; // r9
  __int64 v31; // d16
  RwReal y; // r1
  RwReal v33; // r2

  if ( !this->m_pHoldEntity )
    return 0;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 308 )
  {
    this->m_nStartTime = CTimer::m_snTimeInMilliseconds;
    v12 = 0;
    if ( CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
      return (CTask *)v12;
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v15 = (char *)CTask::operator new(0x3Cu);
    m_pHoldEntity = this->m_pHoldEntity;
    CTaskSimple::CTaskSimple((CTaskSimple *)v15);
    *(_DWORD *)v15 = &off_66D18C;
    *((_DWORD *)v15 + 3) = 0;
    *((_DWORD *)v15 + 4) = 0;
    *((_DWORD *)v15 + 5) = 0;
    *((_WORD *)v15 + 12) = 262;
    *((_QWORD *)v15 + 4) = 0x510000013ELL;
    *((_DWORD *)v15 + 11) = 0;
    *((_DWORD *)v15 + 12) = 0;
    *((_WORD *)v15 + 26) = 256;
    v15[54] = 0;
    *((_DWORD *)v15 + 14) = 0;
    *((_DWORD *)v15 + 2) = m_pHoldEntity;
    v17 = *(_QWORD *)&this->m_vecAttachOffset.x;
    *((_DWORD *)v15 + 5) = LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)(v15 + 12) = v17;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference(*((CEntity **)v15 + 2), (CEntity **)v15 + 2);
    }
    CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, (CTask *)v15, 4);
    return 0;
  }
  if ( v4 != 902 )
  {
    if ( v4 == 903 )
    {
      v5 = this->m_pHoldEntity;
      m_pMat = pPed->m_pMat;
      v7 = v5->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      p_x = &v7->tx;
      if ( !v7 )
        p_x = &v5->m_transform.m_translate.x;
      v10 = *p_x - p_tx->m_translate.x;
      v11 = p_x[1] - p_tx->m_translate.y;
      v12 = (char *)CTask::operator new(0x18u);
      v13 = atan2f(COERCE_FLOAT(LODWORD(v10) ^ 0x80000000), v11);
      CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading((CTaskSimpleAchieveHeading *)v12, v13, 1.0, 0.001);
      return (CTask *)v12;
    }
    return 0;
  }
  v18 = 1058642330;
  if ( this->m_nAnimGroup == ANIM_CARRY_BOX )
  {
    v19 = this->m_pHoldEntity;
    v20 = v19->m_pMat;
    p_m_transform = (CSimpleTransform *)&v20->tx;
    if ( !v20 )
      p_m_transform = &v19->m_transform;
    z = p_m_transform->m_translate.z;
    v23 = CEntity::GetColModel(v19)->m_boxBound.m_vecMin.z;
    v24 = pPed->m_pMat;
    v25 = z + v23;
    v26 = (CSimpleTransform *)&v24->tx;
    if ( !v24 )
      v26 = &pPed->m_transform;
    v27 = v26->m_translate.z;
    if ( v27 < v25 )
    {
      v18 = 1045220557;
      v28 = ANIM_CARRY_BOX_105;
LABEL_24:
      this->m_nAnimGroup = v28;
      goto LABEL_25;
    }
    if ( v27 < (float)(v25 + 0.55) )
    {
      v18 = 1049135241;
      v28 = ANIM_CARRY_BOX_05;
      goto LABEL_24;
    }
  }
LABEL_25:
  v12 = (char *)CTask::operator new(0x4Cu);
  v29 = this->m_pHoldEntity;
  m_nAnimGroup = this->m_nAnimGroup;
  CTaskSimple::CTaskSimple((CTaskSimple *)v12);
  *((_DWORD *)v12 + 3) = 0;
  *((_DWORD *)v12 + 4) = 0;
  *((_DWORD *)v12 + 5) = 0;
  *((_WORD *)v12 + 12) = 262;
  *((_DWORD *)v12 + 8) = 317;
  *((_DWORD *)v12 + 9) = m_nAnimGroup;
  *((_DWORD *)v12 + 11) = 0;
  *((_DWORD *)v12 + 12) = 0;
  *((_WORD *)v12 + 26) = 256;
  v12[54] = 0;
  *((_DWORD *)v12 + 14) = 0;
  *(_DWORD *)v12 = &off_66D18C;
  *((_DWORD *)v12 + 2) = v29;
  v31 = *(_QWORD *)&this->m_vecAttachOffset.x;
  *((_DWORD *)v12 + 5) = LODWORD(this->m_vecAttachOffset.z);
  *(_QWORD *)(v12 + 12) = v31;
  if ( v29 )
  {
    *(_DWORD *)&v29->m_nFlags |= 0x400u;
    CEntity::RegisterReference(*((CEntity **)v12 + 2), (CEntity **)v12 + 2);
  }
  *((_DWORD *)v12 + 15) = v18;
  *((_DWORD *)v12 + 16) = 0;
  *((_DWORD *)v12 + 17) = 0;
  *((_DWORD *)v12 + 18) = 0;
  *(_DWORD *)v12 = &off_66D264;
  y = this->m_vecGoTargetOffset.y;
  v33 = this->m_vecGoTargetOffset.z;
  *((_DWORD *)v12 + 16) = LODWORD(this->m_vecGoTargetOffset.x);
  *((RwReal *)v12 + 17) = y;
  *((RwReal *)v12 + 18) = v33;
  return (CTask *)v12;
}
// 66D18C: using guessed type void *off_66D18C;
// 66D264: using guessed type void *off_66D264;

//----- (00542C08) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoPickUpEntity::ControlSubTask(CTaskComplexGoPickUpEntity *this, CPed *pPed)
{
  AssocGroupId m_nAnimGroup; // r0
  CAnimBlock *m_pAnimBlock; // r1
  const unsigned __int8 *AnimBlockName; // r0
  int v7; // r0
  CTask *m_pSubTask; // r0
  int v9; // r0
  CTask *v10; // r0
  CTask *v11; // r5
  int (**v12)(void); // r1
  bool v13; // zf
  CTask *v15; // r6
  CPad *PadFromPlayer; // r0
  CPad *v17; // r10
  int PedWalkLeftRight; // r8
  int PedWalkUpDown; // r9
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v22; // s16
  float v23; // s22
  float v24; // s0

  m_nAnimGroup = this->m_nAnimGroup;
  if ( m_nAnimGroup && !this->m_bAnimsReferenced )
  {
    m_pAnimBlock = CAnimManager::ms_aAnimAssocGroups[m_nAnimGroup].m_pAnimBlock;
    if ( !m_pAnimBlock )
    {
      AnimBlockName = CAnimManager::GetAnimBlockName(m_nAnimGroup);
      m_pAnimBlock = CAnimManager::GetAnimationBlock(AnimBlockName);
    }
    v7 = m_pAnimBlock - CAnimManager::ms_aAnimBlocks;
    if ( m_pAnimBlock->m_loaded )
    {
      CAnimManager::AddAnimBlockRef(v7);
      this->m_bAnimsReferenced = 1;
    }
    else
    {
      CStreaming::RequestModel(v7 + 25575, 8);
    }
  }
  m_pSubTask = this->m_pSubTask;
  if ( !m_pSubTask )
    return this->m_pSubTask;
  v9 = (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask);
  if ( v9 == 308 )
  {
    v10 = this->m_pSubTask;
    v12 = v10[7]._vptr$CTask;
    v13 = v12 == 0;
    if ( !v12 )
      v13 = LOBYTE(v10[6].m_pParent) == 0;
    if ( v13 && CTimer::m_snTimeInMilliseconds > CTaskComplexGoPickUpEntity::MAX_PICKUP_TIME + this->m_nStartTime )
      goto LABEL_13;
    return this->m_pSubTask;
  }
  if ( v9 != 903 )
    return this->m_pSubTask;
  if ( CTimer::m_snTimeInMilliseconds <= CTaskComplexGoPickUpEntity::MAX_GOTO_TIME + this->m_nStartTime )
  {
    if ( !pPed->m_pPlayerData )
      return this->m_pSubTask;
    v15 = this->m_pSubTask;
    PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
    v17 = PadFromPlayer;
    if ( !PadFromPlayer )
      return this->m_pSubTask;
    PedWalkLeftRight = CPad::GetPedWalkLeftRight(PadFromPlayer);
    PedWalkUpDown = CPad::GetPedWalkUpDown(v17);
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    v22 = atan2f(
            -(float)(*(float *)&v15[2]._vptr$CTask - p_tx->m_translate.x),
            *(float *)&v15[2].m_pParent - p_tx->m_translate.y);
    v23 = CGeneral::GetRadianAngleBetweenPoints(0.0, 0.0, -(float)PedWalkLeftRight, (float)PedWalkUpDown)
        - TheCamera.Orientation;
    if ( v23 <= (float)(v22 + 3.1416) )
    {
      if ( v23 >= (float)(v22 + -3.1416) )
      {
LABEL_30:
        if ( CPad::JumpJustDown(v17)
          || CPad::SprintJustDown(v17)
          || (float)(sqrtf(
                       (float)((float)PedWalkLeftRight * (float)PedWalkLeftRight)
                     + (float)((float)PedWalkUpDown * (float)PedWalkUpDown))
                   * 0.0078125) > 0.75
          && fabsf(v23 - v22) > 0.7854 )
        {
          goto LABEL_12;
        }
        return this->m_pSubTask;
      }
      v24 = 6.2832;
    }
    else
    {
      v24 = -6.2832;
    }
    v23 = v23 + v24;
    goto LABEL_30;
  }
LABEL_12:
  v10 = this->m_pSubTask;
LABEL_13:
  v11 = 0;
  (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))v10->_vptr$CTask + 7))(v10, pPed, 1, 0);
  return v11;
}

//----- (00542E3C) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::CTaskSimpleDuck(
        CTaskSimpleDuck *this,
        uint8 nDuckControl,
        uint16 nLengthOfDuck,
        int16 nUseShotsWhizzingEvents)
{
  int v7; // r0
  uint32 v8; // r1

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v7 + 36) = nDuckControl;
  *(_BYTE *)(v7 + 37) = -1;
  *(_DWORD *)(v7 + 24) = 16842752;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)v7 = &off_66D1FC;
  v8 = CTimer::m_snTimeInMilliseconds;
  *(_WORD *)(v7 + 12) = nLengthOfDuck;
  *(_DWORD *)(v7 + 8) = v8;
  *(_WORD *)(v7 + 14) = nUseShotsWhizzingEvents;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 20) = 0;
}
// 542E56: variable 'v7' is possibly undefined
// 66D1FC: using guessed type void *;

//----- (00542E90) --------------------------------------------------------
void __fastcall CTaskSimpleDuckWhileShotsWhizzing::~CTaskSimpleDuckWhileShotsWhizzing(CTaskSimpleDuck *this)
{
  CAnimBlendAssociation *m_pDuckAnim; // r0
  CAnimBlendAssociation *v3; // r0
  CAnimBlendAssociation *m_pMoveAnim; // r0
  CAnimBlendAssociation *v5; // r0

  m_pDuckAnim = this->m_pDuckAnim;
  this->_vptr$CTask = (int (**)(void))&off_66D1FC;
  if ( m_pDuckAnim )
  {
    CAnimBlendAssociation::SetFinishCallback(m_pDuckAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    v3 = this->m_pDuckAnim;
    if ( v3->m_fBlendAmount > 0.0 && v3->m_fBlendDelta >= 0.0 && (v3->m_bitsFlag & 0x10) != 0 )
      v3->m_fBlendDelta = -8.0;
  }
  m_pMoveAnim = this->m_pMoveAnim;
  if ( m_pMoveAnim )
  {
    CAnimBlendAssociation::SetFinishCallback(m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    v5 = this->m_pMoveAnim;
    if ( v5->m_fBlendAmount > 0.0 && v5->m_fBlendDelta >= 0.0 )
      v5->m_fBlendDelta = -8.0;
  }
  sub_1A01F4(this);
}
// 66D1FC: using guessed type void *off_66D1FC;

//----- (00542F28) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::~CTaskSimpleDuck(CTaskSimpleDuck *this)
{
  void *v1; // r0

  CTaskSimpleDuckWhileShotsWhizzing::~CTaskSimpleDuckWhileShotsWhizzing(this);
  sub_197118(v1);
}
// 542F34: variable 'v1' is possibly undefined

//----- (00542F38) --------------------------------------------------------
bool __fastcall CTaskSimpleDuck::MakeAbortable(
        CTaskSimpleDuck *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pDuckAnim; // r0
  CAnimBlendAssociation *v9; // r0
  float v10; // s16
  CAnimBlendAssociation *v11; // r0
  CAnimBlendAssociation *v12; // r0
  CTaskSimpleUseGun *TaskUseGun; // r0
  bool result; // r0
  CAnimBlendAssociation *m_pMoveAnim; // r0

  if ( iPriority == 2 )
  {
    m_pDuckAnim = this->m_pDuckAnim;
    if ( m_pDuckAnim )
    {
      if ( (m_pDuckAnim->m_bitsFlag & 0x10) != 0 )
        m_pDuckAnim->m_fBlendDelta = -1000.0;
      else
        CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
      CAnimBlendAssociation::SetFinishCallback(this->m_pDuckAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pDuckAnim = 0;
    }
    m_pMoveAnim = this->m_pMoveAnim;
    if ( m_pMoveAnim )
    {
      m_pMoveAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetFinishCallback(this->m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pMoveAnim = 0;
    }
    goto LABEL_39;
  }
  if ( iPriority == 1
    && pEvent
    && this->m_nShotWhizzingCounter >= 0
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 49
    && *((_WORD *)&pEvent->m_bIsPersistent + 1) == 311
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 11))(pEvent) )
  {
LABEL_39:
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x4000000u;
    result = 1;
    this->m_bNeedToSetDuckFlag = 1;
    return result;
  }
  v9 = this->m_pMoveAnim;
  if ( !v9 || (v9->m_animId | 2) != 59 )
  {
    v10 = -4.0;
    if ( iPriority == 1 )
      v10 = -8.0;
    v11 = this->m_pDuckAnim;
    if ( v11 )
    {
      if ( v11->m_fBlendAmount > 0.0 && v11->m_fBlendDelta >= 0.0 )
      {
        if ( (v11->m_bitsFlag & 0x10) != 0 )
          v11->m_fBlendDelta = v10;
        CAnimManager::BlendAnimation(
          (RpClump_0 *)pPed->m_pRwObject,
          pPed->m_motionAnimGroup,
          ANIM_STD_IDLE,
          COERCE_FLOAT(LODWORD(v10) ^ 0x80000000));
        pPed->m_eMoveStateAnim = PEDMOVE_STILL;
      }
      if ( iPriority == 1 )
      {
        CAnimBlendAssociation::SetFinishCallback(this->m_pDuckAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
        this->m_pDuckAnim = 0;
      }
    }
    v12 = this->m_pMoveAnim;
    if ( !v12 )
      goto LABEL_31;
    if ( v12->m_fBlendAmount > 0.0 && v12->m_fBlendDelta >= 0.0 )
    {
      if ( iPriority != 1 && (v12->m_animId | 2) != 58 )
      {
LABEL_31:
        if ( CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence) )
        {
          TaskUseGun = CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence);
          CTaskSimpleUseGun::ClearAnim(TaskUseGun, pPed);
        }
        result = 1;
        if ( iPriority == 1 )
        {
          this->m_bIsFinished = 1;
          *(_DWORD *)&pPed->m_nPedFlags &= ~0x4000000u;
          this->m_bNeedToSetDuckFlag = 1;
          return result;
        }
        this->m_bIsAborting = 1;
        return 0;
      }
      v12->m_fBlendDelta = v10;
      this->m_pMoveAnim->m_bitsFlag &= ~1u;
    }
    if ( iPriority == 1 )
    {
      CAnimBlendAssociation::SetFinishCallback(this->m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pMoveAnim = 0;
    }
    goto LABEL_31;
  }
  return 0;
}

//----- (00543118) --------------------------------------------------------
bool __fastcall CTaskSimpleDuck::AbortBecauseOfOtherDuck(CTaskSimpleDuck *this, CPed *pPed)
{
  CAnimBlendAssociation *m_pDuckAnim; // r0
  CAnimBlendAssociation *m_pMoveAnim; // r0

  m_pDuckAnim = this->m_pDuckAnim;
  if ( m_pDuckAnim )
  {
    CAnimBlendAssociation::SetFinishCallback(m_pDuckAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pDuckAnim = 0;
  }
  m_pMoveAnim = this->m_pMoveAnim;
  if ( m_pMoveAnim )
  {
    m_pMoveAnim->m_fBlendDelta = -8.0;
    CAnimBlendAssociation::SetFinishCallback(this->m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pMoveAnim = 0;
  }
  this->m_bIsFinished = 1;
  this->m_bNeedToSetDuckFlag = 1;
  return 1;
}

//----- (00543160) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDuck::RestartTask(CTaskSimpleDuck *this, CPed *pPed)
{
  int m_nShotWhizzingCounter; // r1

  if ( this->m_bNeedToSetDuckFlag )
  {
    *(_DWORD *)&pPed->m_nPedFlags |= 0x4000000u;
    this->m_bNeedToSetDuckFlag = 0;
  }
  m_nShotWhizzingCounter = this->m_nShotWhizzingCounter;
  this->m_nStartTime = CTimer::m_snTimeInMilliseconds;
  if ( m_nShotWhizzingCounter >= 0 )
    this->m_nShotWhizzingCounter = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1500.0) + 1000;
  return this;
}

//----- (005431CC) --------------------------------------------------------
bool __fastcall CTaskSimpleDuck::ProcessPed(CTaskSimpleDuck *this, CPed *pPed)
{
  bool v4; // r6
  CTask *SimplestActiveTask; // r0
  CTaskSimpleDuck *v6; // r6
  CTask *TaskSecondary; // r0
  CTaskSimpleDuck *v8; // r5
  CAnimBlendAssociation *m_pDuckAnim; // r0
  CAnimBlendAssociation *m_pMoveAnim; // r0
  CTaskSimpleUseGun *TaskUseGun; // r0
  int m_nLengthOfDuck; // r0
  CAnimBlendAssociation *v13; // r0
  uint8 *p_m_nDuckControlType; // r5
  int v15; // r0
  bool v16; // zf
  int m_nCountDownFrames; // r0
  CAnimBlendAssociation *Association; // r0
  AnimationId v20; // r2
  int m_nDuckControlType; // r6
  CAnimBlendAssociation *v22; // r0
  uint32 v23; // r1
  CAnimBlendAssociation *v24; // r0

  if ( this->m_bIsFinished || pPed->m_nHealth < 1.0 )
  {
    if ( !this->m_bIsAborting )
      (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(this, pPed, 1, 0);
    if ( this->m_bNeedToSetDuckFlag )
      return 1;
LABEL_46:
    v4 = 1;
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x4000000u;
    return v4;
  }
  if ( this->m_bNeedToSetDuckFlag )
  {
    SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
    v6 = (CTaskSimpleDuck *)SimplestActiveTask;
    if ( SimplestActiveTask
      && (*((int (__fastcall **)(CTask *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask) != 415 )
    {
      v6 = 0;
    }
    TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 1);
    v8 = (CTaskSimpleDuck *)TaskSecondary;
    if ( TaskSecondary && (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) != 415 )
      v8 = 0;
    if ( v6 && v8 == this )
    {
      m_pDuckAnim = v6->m_pDuckAnim;
      if ( m_pDuckAnim )
      {
        CAnimBlendAssociation::SetFinishCallback(m_pDuckAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
        v6->m_pDuckAnim = 0;
      }
      m_pMoveAnim = v6->m_pMoveAnim;
      if ( m_pMoveAnim )
      {
        m_pMoveAnim->m_fBlendDelta = -8.0;
        CAnimBlendAssociation::SetFinishCallback(v6->m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
        v6->m_pMoveAnim = 0;
      }
      v6->m_bIsFinished = 1;
      v6->m_bNeedToSetDuckFlag = 1;
    }
    else if ( v6 == this && v8 )
    {
      v4 = 0;
      (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(this, pPed, 1, 0);
      return v4;
    }
    if ( CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence) )
    {
      TaskUseGun = CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence);
      CTaskSimpleUseGun::ClearAnim(TaskUseGun, pPed);
    }
    *(_DWORD *)&pPed->m_nPedFlags |= 0x4000000u;
    this->m_bNeedToSetDuckFlag = 0;
  }
  else if ( (*((_BYTE *)&pPed->m_nPedFlags + 3) & 4) == 0 )
  {
    this->m_bIsFinished = 1;
  }
  if ( this->m_bIsAborting )
    return 0;
  if ( !this->m_bIsInControl )
  {
    m_nCountDownFrames = this->m_nCountDownFrames;
    this->m_nCountDownFrames = m_nCountDownFrames - 1;
    if ( !m_nCountDownFrames )
    {
      v4 = 0;
      if ( (*((int (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))this->_vptr$CTask + 7))(this, pPed, 1, 0) != 1 )
        return v4;
      goto LABEL_46;
    }
    return 0;
  }
  m_nLengthOfDuck = this->m_nLengthOfDuck;
  this->m_nCountDownFrames = 4;
  if ( m_nLengthOfDuck && CTimer::m_snTimeInMilliseconds > m_nLengthOfDuck + this->m_nStartTime )
    (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, _DWORD, _DWORD))this->_vptr$CTask + 7))(this, pPed, 0, 0);
  if ( this->m_nShotWhizzingCounter >= 1 )
    this->m_nShotWhizzingCounter = this->m_nLengthOfDuck
                                 - (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
  v13 = this->m_pDuckAnim;
  if ( v13 )
  {
    p_m_nDuckControlType = &this->m_nDuckControlType;
    if ( v13->m_fBlendAmount > 0.99 )
    {
      v15 = *p_m_nDuckControlType;
      v16 = v15 == 4;
      if ( v15 != 4 )
        v16 = v15 == 2;
      if ( !v16 )
        goto LABEL_61;
      CTaskSimpleDuck::SetMoveAnim(this, pPed);
    }
  }
  else
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xAu);
    if ( Association )
      Association->m_fBlendDelta = -2.0;
    v20 = ANIM_STD_WEAPON_CROUCH;
    p_m_nDuckControlType = &this->m_nDuckControlType;
    m_nDuckControlType = this->m_nDuckControlType;
    if ( !this->m_nDuckControlType )
      v20 = ANIM_STD_DUCK_COWER;
    v22 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v20, 4.0);
    this->m_pDuckAnim = v22;
    CAnimBlendAssociation::SetDeleteCallback(v22, CTaskSimpleDuck::DeleteDuckAnimCB, this);
    v23 = 141;
    if ( !m_nDuckControlType )
      v23 = 55;
    v24 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, v23);
    if ( v24 && v24->m_fBlendAmount > 0.0 && v24->m_fBlendDelta >= 0.0 )
    {
      if ( (v24->m_bitsFlag & 0x10) != 0 )
        v24->m_fBlendDelta = -4.0;
      else
        CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_IDLE, 4.0);
    }
  }
  v15 = *p_m_nDuckControlType;
LABEL_61:
  v4 = 0;
  if ( v15 == 2 )
    this->m_bIsInControl = 0;
  return v4;
}

//----- (00543474) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::DeleteDuckAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  bool v2; // zf
  int v3; // r0
  int v4; // r0

  v2 = pAnim == 0;
  if ( pAnim )
    v2 = pData == 0;
  if ( !v2 )
  {
    switch ( pAnim->m_animId )
    {
      case '7':
        goto LABEL_7;
      case '8':
      case ':':
        v3 = *((unsigned __int8 *)pData + 25);
        goto LABEL_11;
      case '9':
      case ';':
        v3 = *((unsigned __int8 *)pData + 25);
        *((_DWORD *)pData + 7) = 0;
LABEL_11:
        *((_DWORD *)pData + 5) = 0;
        if ( v3 )
          goto LABEL_12;
        return;
      default:
        if ( pAnim->m_animId != 141 )
          return;
LABEL_7:
        v4 = *((_DWORD *)pData + 5);
        *((_DWORD *)pData + 4) = 0;
        if ( !v4 || !*((_BYTE *)pData + 25) )
LABEL_12:
          *((_BYTE *)pData + 24) = 1;
        break;
    }
  }
}

//----- (005434C0) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::SetMoveAnim(CTaskSimpleDuck *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float x; // s0
  CAnimBlendAssociation *v7; // r0
  AnimationId v8; // r2
  CAnimBlendAssociation *v9; // r0
  CAnimBlendAssociation *m_pMoveAnim; // r0
  CAnimBlendAssociation *v11; // r0
  CAnimBlendAssociation *v12; // r0

  x = this->m_vecMoveCommand.x;
  if ( x == 0.0 )
  {
    v2.n64_u32[0] = LODWORD(this->m_vecMoveCommand.y);
    if ( v2.n64_f32[0] > 0.0 )
    {
      m_pMoveAnim = this->m_pMoveAnim;
      if ( m_pMoveAnim )
      {
        if ( m_pMoveAnim->m_animId != 56 )
        {
LABEL_13:
          v3.n64_u32[0] = 1058642330;
LABEL_20:
          LODWORD(m_pMoveAnim->m_fSpeed) = vmax_f32(v2, v3).n64_u32[0];
          return;
        }
        CAnimBlendAssociation::SetFinishCallback(m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      }
      v11 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_WEAPON_CROUCH_BACK, 8.0);
      this->m_pMoveAnim = v11;
      CAnimBlendAssociation::SetDeleteCallback(v11, CTaskSimpleDuck::DeleteDuckAnimCB, this);
      m_pMoveAnim = this->m_pMoveAnim;
      v2.n64_u32[0] = LODWORD(this->m_vecMoveCommand.y);
      goto LABEL_13;
    }
    m_pMoveAnim = this->m_pMoveAnim;
    if ( v2.n64_f32[0] >= 0.0 )
    {
      if ( m_pMoveAnim && (m_pMoveAnim->m_animId | 2) == 58 )
      {
        m_pMoveAnim->m_bitsFlag &= ~1u;
        this->m_pMoveAnim->m_fBlendDelta = -4.0;
      }
      return;
    }
    if ( m_pMoveAnim )
    {
      if ( m_pMoveAnim->m_animId != 58 )
      {
LABEL_19:
        v3.n64_u32[0] = 1058642330;
        v2.n64_f32[0] = -v2.n64_f32[0];
        goto LABEL_20;
      }
      CAnimBlendAssociation::SetFinishCallback(m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    }
    v12 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_WEAPON_CROUCH_FWD, 8.0);
    this->m_pMoveAnim = v12;
    CAnimBlendAssociation::SetDeleteCallback(v12, CTaskSimpleDuck::DeleteDuckAnimCB, this);
    m_pMoveAnim = this->m_pMoveAnim;
    v2.n64_u32[0] = LODWORD(this->m_vecMoveCommand.y);
    goto LABEL_19;
  }
  v7 = this->m_pMoveAnim;
  if ( v7 )
  {
    if ( (v7->m_animId | 2) != 58 )
      return;
    CAnimBlendAssociation::SetFinishCallback(v7, CDefaultAnimCallback::DefaultAnimCB, 0);
    x = this->m_vecMoveCommand.x;
  }
  v8 = ANIM_STD_WEAPON_CROUCH_LEFT;
  if ( x > 0.0 )
    v8 = ANIM_STD_WEAPON_CROUCH_RIGHT;
  v9 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v8, 8.0);
  this->m_pMoveAnim = v9;
  sub_18C19C(v9, CTaskSimpleDuck::DeleteDuckAnimCB, this);
}
// 5435B4: variable 'v2' is possibly undefined
// 5435B4: variable 'v3' is possibly undefined

//----- (00543600) --------------------------------------------------------
bool __fastcall CTaskSimpleDuck::ControlDuckMove(CTaskSimpleDuck *this, CVector2D vecMove)
{
  float v2; // s2
  float y; // s6
  float v4; // s8

  this->m_bIsInControl = 1;
  if ( this->m_vecMoveCommand.x != 1.0 )
  {
    v2 = -1.0;
    y = this->m_vecMoveCommand.y;
    v4 = CTimer::ms_fTimeStep * 0.07;
    if ( (float)(vecMove.y - y) <= (float)(CTimer::ms_fTimeStep * 0.07) )
    {
      if ( (float)(vecMove.y - y) < (float)-v4 )
        this->m_vecMoveCommand.y = y - v4;
      else
        this->m_vecMoveCommand.y = vecMove.y;
    }
    else
    {
      this->m_vecMoveCommand.y = y + v4;
    }
    if ( fabsf(vecMove.y) < 0.1 && fabsf(vecMove.x) > 0.9 )
    {
      if ( vecMove.x > 0.0 )
        v2 = 1.0;
      this->m_vecMoveCommand.y = 0.0;
      this->m_vecMoveCommand.x = v2;
    }
  }
  return 1;
}

//----- (005436C0) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::ForceStopMove(CTaskSimpleDuck *this)
{
  this->m_vecMoveCommand.y = 0.0;
  this->m_bIsInControl = 1;
}

//----- (005436CA) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::StartCountDown(CTaskSimpleDuck *this, uint8 nNumIdleFrames, bool bMax)
{
  if ( bMax && (unsigned int)this->m_nCountDownFrames < nNumIdleFrames )
    nNumIdleFrames = this->m_nCountDownFrames;
  this->m_nCountDownFrames = nNumIdleFrames;
}

//----- (005436E0) --------------------------------------------------------
bool __fastcall CTaskSimpleDuck::SetControlType(CTaskSimpleDuck *this, uint8 nType)
{
  bool v2; // zf
  uint32 v4; // r2

  v2 = !this->m_bIsFinished;
  if ( !this->m_bIsFinished )
    v2 = !this->m_bIsAborting;
  if ( !v2 )
    return 0;
  if ( nType == 4 )
    this->m_nLengthOfDuck = 0;
  v4 = CTimer::m_snTimeInMilliseconds;
  this->m_nDuckControlType = nType;
  this->m_nStartTime = v4;
  this->m_bIsInControl = 1;
  return 1;
}

//----- (00543714) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::SetDuckTimer(CTaskSimpleDuck *this, uint16 nLengthOfDuck)
{
  uint32 v2; // r2

  if ( this->m_nDuckControlType != 4 )
  {
    v2 = CTimer::m_snTimeInMilliseconds;
    this->m_nLengthOfDuck = nLengthOfDuck;
    this->m_nStartTime = v2;
  }
}

//----- (00543730) --------------------------------------------------------
bool __fastcall CTaskSimpleDuck::CanPedDuck(CPed *pPed)
{
  eWeaponType m_eWeaponType; // r5
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r5
  bool v5; // zf
  eWeaponType v7; // r0

  m_eWeaponType = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(pPed);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  if ( CHID::GetInputType() )
    goto LABEL_2;
  v7 = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
  if ( v7 != WEAPONTYPE_SNIPERRIFLE )
  {
    if ( v7 == WEAPONTYPE_CAMERA && TheCamera.Cams[TheCamera.ActiveCam].Mode == 46 )
      return 0;
    goto LABEL_2;
  }
  if ( TheCamera.Cams[TheCamera.ActiveCam].Mode != 7 )
  {
LABEL_2:
    v5 = WeaponInfo->m_eFireType == FIRETYPE_MELEE;
    if ( WeaponInfo->m_eFireType )
      v5 = WeaponInfo->m_eFireType == FIRETYPE_USE;
    if ( v5
      || (pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType | 2) == 43
      || (WeaponInfo->m_nFlags & 0x2000) != 0 )
    {
      return 1;
    }
  }
  return 0;
}

//----- (005437E8) --------------------------------------------------------
void __fastcall CTaskSimpleDuckWhileShotsWhizzing::CTaskSimpleDuckWhileShotsWhizzing(
        CTaskSimpleDuckWhileShotsWhizzing *this,
        const uint16 nLengthOfDuck)
{
  int v3; // r0
  uint32 v4; // r1

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v3 + 24) = 16842752;
  *(_DWORD *)(v3 + 28) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  *(_WORD *)(v3 + 36) = -256;
  *(_DWORD *)v3 = &off_66D1FC;
  v4 = CTimer::m_snTimeInMilliseconds;
  *(_WORD *)(v3 + 12) = nLengthOfDuck;
  *(_DWORD *)(v3 + 8) = v4;
  *(_WORD *)(v3 + 14) = -1;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)v3 = &off_66D230;
}
// 543804: variable 'v3' is possibly undefined
// 66D1FC: using guessed type void *off_66D1FC;
// 66D230: using guessed type void *off_66D230;

//----- (00543844) --------------------------------------------------------
void __fastcall CTaskSimpleDuckWhileShotsWhizzing::~CTaskSimpleDuckWhileShotsWhizzing(
        CTaskSimpleDuckWhileShotsWhizzing *this)
{
  void *v1; // r0

  CTaskSimpleDuckWhileShotsWhizzing::~CTaskSimpleDuckWhileShotsWhizzing(this);
  sub_197118(v1);
}
// 543850: variable 'v1' is possibly undefined

//----- (00543854) --------------------------------------------------------
bool __fastcall CTaskSimpleDuckWhileShotsWhizzing::MakeAbortable(
        CTaskSimpleDuckWhileShotsWhizzing *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CPed *v6; // r8
  CTaskSimpleDuckWhileShotsWhizzing *v7; // r5
  int v8; // r2
  CAnimBlendAssociation *m_pDuckAnim; // r0
  bool v10; // r4
  CAnimBlendAssociation *m_pMoveAnim; // r0

  v6 = pPed;
  v7 = this;
  if ( iPriority == 2 )
  {
    v8 = 2;
    return CTaskSimpleDuck::MakeAbortable(this, pPed, v8, pEvent);
  }
  if ( !pEvent || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 49 )
  {
    this = v7;
    pPed = v6;
    v8 = iPriority;
    return CTaskSimpleDuck::MakeAbortable(this, pPed, v8, pEvent);
  }
  m_pDuckAnim = v7->m_pDuckAnim;
  v10 = 0;
  if ( m_pDuckAnim )
  {
    CAnimBlendAssociation::SetFinishCallback(m_pDuckAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    m_pMoveAnim = v7->m_pMoveAnim;
    v7->m_pDuckAnim = 0;
    if ( m_pMoveAnim )
    {
      CAnimBlendAssociation::SetFinishCallback(m_pMoveAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      v7->m_pMoveAnim = 0;
    }
    v10 = 1;
    *(_DWORD *)&v6->m_nPedFlags &= ~0x4000000u;
  }
  return v10;
}

//----- (005438D8) --------------------------------------------------------
bool __fastcall CTaskSimpleDuckWhileShotsWhizzing::ProcessPed(CTaskSimpleDuckWhileShotsWhizzing *this, CPed *pPed)
{
  CAnimBlendAssociation *v4; // r0

  if ( !this->m_pDuckAnim )
  {
    v4 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_DUCK_COWER, 4.0);
    this->m_pDuckAnim = v4;
    CAnimBlendAssociation::SetDeleteCallback(v4, CTaskSimpleDuck::DeleteDuckAnimCB, this);
  }
  return CTaskSimpleDuck::ProcessPed(this, pPed);
}

//----- (00543910) --------------------------------------------------------
void __fastcall CTaskSimpleHoldEntity::~CTaskSimpleHoldEntity(CTaskSimpleHoldEntity *this)
{
  _BOOL4 m_bIsFirstTime; // r1
  CEntity *m_pHoldEntity; // r0
  CEntity **p_m_pHoldEntity; // r5
  CEntity *v5; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  CAnimBlendAssociation *m_pAnim; // r0
  CAnimBlock *m_pAnimBlock; // r0

  m_bIsFirstTime = this->m_bIsFirstTime;
  this->_vptr$CTask = (int (**)(void))&off_66D18C;
  if ( !m_bIsFirstTime )
  {
    p_m_pHoldEntity = &this->m_pHoldEntity;
    m_pHoldEntity = this->m_pHoldEntity;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags &= ~0x400u;
      CEntity::CleanUpOldReference(*p_m_pHoldEntity, &this->m_pHoldEntity);
      v5 = *p_m_pHoldEntity;
      m_nFlags = (*p_m_pHoldEntity)->m_nFlags;
      *(_DWORD *)&v5->m_nFlags = *(_DWORD *)&m_nFlags | 0x800;
      v5->m_nFlags.bdummy = m_nFlags.bdummy;
      *p_m_pHoldEntity = 0;
    }
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pAnimBlock = this->m_pAnimBlock;
  if ( m_pAnimBlock )
    CAnimManager::RemoveAnimBlockRef(m_pAnimBlock - CAnimManager::ms_aAnimBlocks);
  sub_1A01F4(this);
}
// 66D18C: using guessed type void *off_66D18C;

//----- (0054398C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleShakeFist::Clone(const CTaskSimpleShakeFist *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x10u);
  CTaskSimple::CTaskSimple(v1);
  LOBYTE(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D0B4;
  return result;
}
// 54399E: variable 'result' is possibly undefined
// 66D0B4: using guessed type void *off_66D0B4;

//----- (005439B0) --------------------------------------------------------
int __fastcall CTaskSimpleShakeFist::GetTaskType(const CTaskSimpleShakeFist *this)
{
  return 302;
}

//----- (005439B8) --------------------------------------------------------
void __fastcall CTaskSimpleShakeFist::Serialize(CTaskSimpleShakeFist *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleShakeFist *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleShakeFist *))this->_vptr$CTask + 5))(this) != 302 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleShakeFist *))this->_vptr$CTask + 5))(this);
    sub_1941C4(302, v4);
  }
}

//----- (00543A24) --------------------------------------------------------
CTask *__fastcall CTaskSimpleFacial::Clone(const CTaskSimpleFacial *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_type;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(result[2]._vptr$CTask) = 0;
  *(_QWORD *)&result[2].m_pParent = v3;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D0E8;
  return result;
}
// 543A3C: variable 'result' is possibly undefined
// 66D0E8: using guessed type void *off_66D0E8;

//----- (00543A54) --------------------------------------------------------
int __fastcall CTaskSimpleFacial::GetTaskType(const CTaskSimpleFacial *this)
{
  return 303;
}

//----- (00543A5C) --------------------------------------------------------
void __fastcall CTaskSimpleFacial::Serialize(CTaskSimpleFacial *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleFacial *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleFacial *))this->_vptr$CTask + 5))(this) == 202 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_type;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = this->m_duration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskSimpleFacial *))this->_vptr$CTask + 5))(this);
    sub_1941C4(202, v6);
  }
}

//----- (00543B24) --------------------------------------------------------
CTask *__fastcall CTaskComplexFacial::Clone(const CTaskComplexFacial *this)
{
  char *v1; // r4
  int v2; // s0
  char v3; // r0

  v1 = (char *)CTask::operator new(0x20u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v1);
  *((_DWORD *)v1 + 4) = -1;
  *((_DWORD *)v1 + 6) = -1;
  *(_DWORD *)v1 = &off_66D11C;
  v2 = (unsigned __int16)rand();
  v3 = 0;
  *(_WORD *)(v1 + 13) = 0;
  if ( (int)(float)((float)((float)v2 * 0.000015259) * 100.0) > 70 )
    v3 = 1;
  v1[12] = v3;
  return (CTask *)v1;
}
// 66D11C: using guessed type void *off_66D11C;

//----- (00543B8C) --------------------------------------------------------
int __fastcall CTaskComplexFacial::GetTaskType(const CTaskComplexFacial *this)
{
  return 305;
}

//----- (00543B94) --------------------------------------------------------
void __fastcall CTaskComplexFacial::Serialize(CTaskComplexFacial *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexFacial *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFacial *))this->_vptr$CTask + 5))(this) != 305 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexFacial *))this->_vptr$CTask + 5))(this);
    sub_1941C4(305, v4);
  }
}

//----- (00543C04) --------------------------------------------------------
CTask *__fastcall CTaskSimpleAffectSecondaryBehaviour::Clone(const CTaskSimpleAffectSecondaryBehaviour *this)
{
  CTask *m_pTask; // r0
  int (**v3)(void); // r5
  CTaskSimple *v4; // r0
  CTask *m_iType; // r6
  bool m_bAdd; // r4
  CTask *result; // r0

  m_pTask = this->m_pTask;
  if ( m_pTask )
    v3 = (int (**)(void))(*((int (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 2))(m_pTask);
  else
    v3 = 0;
  v4 = (CTaskSimple *)CTask::operator new(0x14u);
  m_iType = (CTask *)this->m_iType;
  m_bAdd = this->m_bAdd;
  CTaskSimple::CTaskSimple(v4);
  LOBYTE(result[1]._vptr$CTask) = m_bAdd;
  result[1].m_pParent = m_iType;
  result[2]._vptr$CTask = v3;
  result->_vptr$CTask = (int (**)(void))&off_66D158;
  return result;
}
// 543C2E: variable 'result' is possibly undefined
// 66D158: using guessed type void *off_66D158;

//----- (00543C48) --------------------------------------------------------
int __fastcall CTaskSimpleAffectSecondaryBehaviour::GetTaskType(const CTaskSimpleAffectSecondaryBehaviour *this)
{
  return 306;
}

//----- (00543C4E) --------------------------------------------------------
bool __fastcall CTaskSimpleAffectSecondaryBehaviour::MakeAbortable(
        CTaskSimpleAffectSecondaryBehaviour *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (00543C54) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHoldEntity::Clone(const CTaskSimpleHoldEntity *this)
{
  CAnimBlendHierarchy *m_pAnimHierarchy; // r6
  CTaskSimple *v3; // r0
  uint8 m_nOrientateFlags; // r11
  CVector *p_m_vecAttachOffset; // r8
  uint8 m_nBoneId; // r10
  CTaskSimple *v7; // r4
  CEntity *m_pHoldEntity; // r9
  __int64 v9; // kr00_8
  __int64 v10; // d16
  CTaskSimple v11; // kr08_8
  __int64 v12; // d16
  int32 m_nAnimFlags; // [sp+0h] [bp-20h]

  m_pAnimHierarchy = this->m_pAnimHierarchy;
  v3 = (CTaskSimple *)CTask::operator new(0x3Cu);
  m_nOrientateFlags = this->m_nOrientateFlags;
  p_m_vecAttachOffset = &this->m_vecAttachOffset;
  m_nBoneId = this->m_nBoneId;
  v7 = v3;
  m_pHoldEntity = this->m_pHoldEntity;
  if ( m_pAnimHierarchy )
  {
    m_nAnimFlags = this->m_nAnimFlags;
    v9 = *(_QWORD *)&this->m_pAnimBlock;
    CTaskSimple::CTaskSimple(v3);
    LOBYTE(v7[3]._vptr$CTask) = m_nBoneId;
    v7[1].m_pParent = 0;
    v7[2]._vptr$CTask = 0;
    v7[2].m_pParent = 0;
    BYTE1(v7[3]._vptr$CTask) = m_nOrientateFlags;
    v7[3].m_pParent = 0;
    v7[4]._vptr$CTask = (int (**)(void))(&dword_BC + 3);
    v7[4].m_pParent = 0;
    LOWORD(v7[6].m_pParent) = 256;
    BYTE2(v7[6].m_pParent) = 0;
    v7[7]._vptr$CTask = 0;
    v7->_vptr$CTask = (int (**)(void))&off_66D18C;
    v7[1]._vptr$CTask = (int (**)(void))m_pHoldEntity;
    v10 = *(_QWORD *)&p_m_vecAttachOffset->x;
    v7[2].m_pParent = (CTask *)LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)&v7[1].m_pParent = v10;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference((CEntity *)v7[1]._vptr$CTask, (CEntity **)&v7[1]);
    }
    v7[5].m_pParent = (CTask *)v9;
    v7[5]._vptr$CTask = (int (**)(void))m_nAnimFlags;
    v7[6]._vptr$CTask = (int (**)(void))HIDWORD(v9);
    CAnimManager::AddAnimBlockRef(((int)v9 - (int)CAnimManager::ms_aAnimBlocks) >> 5);
  }
  else
  {
    v11 = *(CTaskSimple *)&this->m_nAnimId;
    CTaskSimple::CTaskSimple(v3);
    LOBYTE(v7[3]._vptr$CTask) = m_nBoneId;
    v7[1].m_pParent = 0;
    v7[2]._vptr$CTask = 0;
    v7[2].m_pParent = 0;
    BYTE1(v7[3]._vptr$CTask) = m_nOrientateFlags;
    v7[4] = v11;
    v7[5].m_pParent = 0;
    v7[6]._vptr$CTask = 0;
    LOWORD(v7[6].m_pParent) = 256;
    BYTE2(v7[6].m_pParent) = 0;
    v7[7]._vptr$CTask = 0;
    v7->_vptr$CTask = (int (**)(void))&off_66D18C;
    v7[1]._vptr$CTask = (int (**)(void))m_pHoldEntity;
    v12 = *(_QWORD *)&p_m_vecAttachOffset->x;
    v7[2].m_pParent = (CTask *)LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)&v7[1].m_pParent = v12;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference((CEntity *)v7[1]._vptr$CTask, (CEntity **)&v7[1]);
    }
  }
  return v7;
}
// BC: using guessed type int dword_BC;
// 66D18C: using guessed type void *off_66D18C;

//----- (00543D7C) --------------------------------------------------------
int __fastcall CTaskSimpleHoldEntity::GetTaskType(const CTaskSimpleHoldEntity *this)
{
  return 307;
}

//----- (00543D90) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoPickUpEntity::Clone(const CTaskComplexGoPickUpEntity *this)
{
  void *v2; // r4
  CEntity *m_pHoldEntity; // r5
  AssocGroupId m_nAnimGroup; // r8
  CTask *result; // r0

  v2 = CTask::operator new(0x34u);
  m_pHoldEntity = this->m_pHoldEntity;
  m_nAnimGroup = this->m_nAnimGroup;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = 3296313344LL;
  *((_QWORD *)v2 + 3) = 0xC479C00000000000LL;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 11) = m_nAnimGroup;
  *(_DWORD *)v2 = &off_66D1C0;
  *((_DWORD *)v2 + 3) = m_pHoldEntity;
  if ( m_pHoldEntity )
    CEntity::RegisterReference(m_pHoldEntity, (CEntity **)v2 + 3);
  *((_BYTE *)v2 + 48) = 0;
  result = (CTask *)v2;
  *((_DWORD *)v2 + 10) = 0;
  return result;
}
// 66D1C0: using guessed type void *off_66D1C0;

//----- (00543E04) --------------------------------------------------------
int __fastcall CTaskComplexGoPickUpEntity::GetTaskType(const CTaskComplexGoPickUpEntity *this)
{
  return 310;
}

//----- (00543E0C) --------------------------------------------------------
void __fastcall CTaskComplexGoPickUpEntity::Serialize(CTaskComplexGoPickUpEntity *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pHoldEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexGoPickUpEntity *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoPickUpEntity *))this->_vptr$CTask + 5))(this) != 310 )
  {
    v10 = (*((int (__fastcall **)(CTaskComplexGoPickUpEntity *))this->_vptr$CTask + 5))(this);
    sub_1941C4(310, v10);
    return;
  }
  m_pHoldEntity = this->m_pHoldEntity;
  if ( !m_pHoldEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_20;
  }
  v5 = *(_BYTE *)&m_pHoldEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pHoldEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  switch ( v8 )
  {
    case 2:
      v9 = GettPoolVehicleRef((CVehicle *)v7);
      goto LABEL_17;
    case 4:
      v9 = GettPoolObjRef((CObject *)v7);
      goto LABEL_17;
    case 3:
      v9 = GettPoolPedRef((CPed *)v7);
LABEL_17:
      if ( UseDataFence )
        AddDataFence();
      v13 = malloc(4u);
      *v13 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v12 = v13;
LABEL_20:
      free(v12);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(4u);
  *v14 = this->m_nAnimGroup;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
  j_free(v14);
}

//----- (00543F70) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDuck::Clone(const CTaskSimpleDuck *this)
{
  CTaskSimple *v2; // r0
  CTask *v3; // r6
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x28u);
  v3 = *(CTask **)&this->m_nLengthOfDuck;
  LOBYTE(this) = this->m_nDuckControlType;
  CTaskSimple::CTaskSimple(v2);
  BYTE1(result[4].m_pParent) = -1;
  LOBYTE(result[4].m_pParent) = (_BYTE)this;
  result->_vptr$CTask = (int (**)(void))&off_66D1FC;
  result[1]._vptr$CTask = (int (**)(void))CTimer::m_snTimeInMilliseconds;
  result[1].m_pParent = v3;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = (int (**)(void))16842752;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  return result;
}
// 543F96: variable 'result' is possibly undefined
// 66D1FC: using guessed type void *off_66D1FC;

//----- (00543FCC) --------------------------------------------------------
int __fastcall CTaskSimpleDuck::GetTaskType(const CTaskSimpleDuck *this)
{
  return 415;
}

//----- (00543FD4) --------------------------------------------------------
void __fastcall CTaskSimpleDuck::Serialize(CTaskSimpleDuck *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _WORD *v4; // r5
  _WORD *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleDuck *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDuck *))this->_vptr$CTask + 5))(this) == 415 )
  {
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_nDuckControlType, 1);
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(2u);
    *v4 = this->m_nLengthOfDuck;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 2);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(2u);
    *v5 = this->m_nShotWhizzingCounter;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskSimpleDuck *))this->_vptr$CTask + 5))(this);
    sub_1941C4(415, v6);
  }
}

//----- (005440C0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDuckWhileShotsWhizzing::Clone(const CTaskSimpleDuckWhileShotsWhizzing *this)
{
  CTaskSimple *v2; // r0
  uint16 m_nLengthOfDuck; // r5
  CTask *result; // r0
  int (**v5)(void); // r1

  v2 = (CTaskSimple *)CTask::operator new(0x28u);
  m_nLengthOfDuck = this->m_nLengthOfDuck;
  CTaskSimple::CTaskSimple(v2);
  result[3]._vptr$CTask = (int (**)(void))16842752;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  LOWORD(result[4].m_pParent) = -256;
  result->_vptr$CTask = (int (**)(void))&off_66D1FC;
  v5 = (int (**)(void))CTimer::m_snTimeInMilliseconds;
  LOWORD(result[1].m_pParent) = m_nLengthOfDuck;
  result[1]._vptr$CTask = v5;
  HIWORD(result[1].m_pParent) = -1;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D230;
  return result;
}
// 5440E4: variable 'result' is possibly undefined
// 66D1FC: using guessed type void *off_66D1FC;
// 66D230: using guessed type void *;

//----- (00544124) --------------------------------------------------------
int __fastcall CTaskSimpleDuckWhileShotsWhizzing::GetTaskType(const CTaskSimpleDuckWhileShotsWhizzing *this)
{
  return 311;
}

//----- (0054412C) --------------------------------------------------------
void __fastcall CTaskSimpleDuckWhileShotsWhizzing::Serialize(CTaskSimpleDuckWhileShotsWhizzing *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _WORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleDuckWhileShotsWhizzing *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDuckWhileShotsWhizzing *))this->_vptr$CTask + 5))(this) == 311 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(2u);
    *v4 = this->m_nLengthOfDuck;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 2);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleDuckWhileShotsWhizzing *))this->_vptr$CTask + 5))(this);
    sub_1941C4(311, v5);
  }
}

//----- (005441CC) --------------------------------------------------------
void __fastcall CTaskSimplePickUpEntity::~CTaskSimplePickUpEntity(CTaskSimplePickUpEntity *this)
{
  void *v1; // r0

  CTaskSimpleHoldEntity::~CTaskSimpleHoldEntity(this);
  sub_197118(v1);
}
// 5441D8: variable 'v1' is possibly undefined

//----- (005441DC) --------------------------------------------------------
CTask *__fastcall CTaskSimplePickUpEntity::Clone(const CTaskSimplePickUpEntity *this)
{
  CAnimBlendHierarchy *m_pAnimHierarchy; // r6
  CTaskSimple *v3; // r0
  uint8 m_nOrientateFlags; // r11
  CVector *p_m_vecAttachOffset; // r8
  uint8 m_nBoneId; // r10
  CTaskSimple *v7; // r4
  CEntity *m_pHoldEntity; // r9
  float m_fTimeToAttach; // s16
  __int64 v10; // kr00_8
  __int64 v11; // d16
  CTaskSimple v12; // kr08_8
  __int64 v13; // d16
  int32 m_nAnimFlags; // [sp+4h] [bp-2Ch]

  m_pAnimHierarchy = this->m_pAnimHierarchy;
  v3 = (CTaskSimple *)CTask::operator new(0x4Cu);
  m_nOrientateFlags = this->m_nOrientateFlags;
  p_m_vecAttachOffset = &this->m_vecAttachOffset;
  m_nBoneId = this->m_nBoneId;
  v7 = v3;
  m_pHoldEntity = this->m_pHoldEntity;
  if ( m_pAnimHierarchy )
  {
    m_fTimeToAttach = this->m_fTimeToAttach;
    m_nAnimFlags = this->m_nAnimFlags;
    v10 = *(_QWORD *)&this->m_pAnimBlock;
    CTaskSimple::CTaskSimple(v3);
    LOBYTE(v7[3]._vptr$CTask) = m_nBoneId;
    v7[1].m_pParent = 0;
    v7[2]._vptr$CTask = 0;
    v7[2].m_pParent = 0;
    BYTE1(v7[3]._vptr$CTask) = m_nOrientateFlags;
    v7[3].m_pParent = 0;
    v7[4]._vptr$CTask = (int (**)(void))(&dword_BC + 3);
    v7[4].m_pParent = 0;
    LOWORD(v7[6].m_pParent) = 256;
    BYTE2(v7[6].m_pParent) = 0;
    v7[7]._vptr$CTask = 0;
    v7->_vptr$CTask = (int (**)(void))&off_66D18C;
    v7[1]._vptr$CTask = (int (**)(void))m_pHoldEntity;
    v11 = *(_QWORD *)&p_m_vecAttachOffset->x;
    v7[2].m_pParent = (CTask *)LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)&v7[1].m_pParent = v11;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference((CEntity *)v7[1]._vptr$CTask, (CEntity **)&v7[1]);
    }
    v7[5].m_pParent = (CTask *)v10;
    v7[5]._vptr$CTask = (int (**)(void))m_nAnimFlags;
    v7[6]._vptr$CTask = (int (**)(void))HIDWORD(v10);
    CAnimManager::AddAnimBlockRef(((int)v10 - (int)CAnimManager::ms_aAnimBlocks) >> 5);
  }
  else
  {
    m_fTimeToAttach = this->m_fTimeToAttach;
    v12 = *(CTaskSimple *)&this->m_nAnimId;
    CTaskSimple::CTaskSimple(v3);
    LOBYTE(v7[3]._vptr$CTask) = m_nBoneId;
    v7[1].m_pParent = 0;
    v7[2]._vptr$CTask = 0;
    v7[2].m_pParent = 0;
    BYTE1(v7[3]._vptr$CTask) = m_nOrientateFlags;
    v7[4] = v12;
    v7[5].m_pParent = 0;
    v7[6]._vptr$CTask = 0;
    LOWORD(v7[6].m_pParent) = 256;
    BYTE2(v7[6].m_pParent) = 0;
    v7[7]._vptr$CTask = 0;
    v7->_vptr$CTask = (int (**)(void))&off_66D18C;
    v7[1]._vptr$CTask = (int (**)(void))m_pHoldEntity;
    v13 = *(_QWORD *)&p_m_vecAttachOffset->x;
    v7[2].m_pParent = (CTask *)LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)&v7[1].m_pParent = v13;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference((CEntity *)v7[1]._vptr$CTask, (CEntity **)&v7[1]);
    }
  }
  *(float *)&v7[7].m_pParent = m_fTimeToAttach;
  v7[8]._vptr$CTask = 0;
  v7[8].m_pParent = 0;
  v7[9]._vptr$CTask = 0;
  v7->_vptr$CTask = (int (**)(void))&off_66D264;
  return v7;
}
// BC: using guessed type int dword_BC;
// 66D18C: using guessed type void *off_66D18C;
// 66D264: using guessed type void *off_66D264;

//----- (00544334) --------------------------------------------------------
int __fastcall CTaskSimplePickUpEntity::GetTaskType(const CTaskSimplePickUpEntity *this)
{
  return 308;
}

//----- (0054433A) --------------------------------------------------------
void __fastcall CTaskSimplePutDownEntity::~CTaskSimplePutDownEntity(CTaskSimplePutDownEntity *this)
{
  void *v1; // r0

  CTaskSimpleHoldEntity::~CTaskSimpleHoldEntity(this);
  sub_197118(v1);
}
// 544346: variable 'v1' is possibly undefined

//----- (0054434C) --------------------------------------------------------
CTask *__fastcall CTaskSimplePutDownEntity::Clone(const CTaskSimplePutDownEntity *this)
{
  CAnimBlendHierarchy *m_pAnimHierarchy; // r6
  CTaskSimple *v3; // r0
  uint8 m_nOrientateFlags; // r11
  CVector *p_m_vecAttachOffset; // r8
  uint8 m_nBoneId; // r10
  CTaskSimple *v7; // r4
  CEntity *m_pHoldEntity; // r9
  float m_fTimeToDrop; // s16
  __int64 v10; // kr00_8
  __int64 v11; // d16
  CTaskSimple v12; // kr08_8
  __int64 v13; // d16
  int32 m_nAnimFlags; // [sp+4h] [bp-2Ch]

  m_pAnimHierarchy = this->m_pAnimHierarchy;
  v3 = (CTaskSimple *)CTask::operator new(0x40u);
  m_nOrientateFlags = this->m_nOrientateFlags;
  p_m_vecAttachOffset = &this->m_vecAttachOffset;
  m_nBoneId = this->m_nBoneId;
  v7 = v3;
  m_pHoldEntity = this->m_pHoldEntity;
  if ( m_pAnimHierarchy )
  {
    m_fTimeToDrop = this->m_fTimeToDrop;
    m_nAnimFlags = this->m_nAnimFlags;
    v10 = *(_QWORD *)&this->m_pAnimBlock;
    CTaskSimple::CTaskSimple(v3);
    LOBYTE(v7[3]._vptr$CTask) = m_nBoneId;
    v7[1].m_pParent = 0;
    v7[2]._vptr$CTask = 0;
    v7[2].m_pParent = 0;
    BYTE1(v7[3]._vptr$CTask) = m_nOrientateFlags;
    v7[3].m_pParent = 0;
    v7[4]._vptr$CTask = (int (**)(void))(&dword_BC + 3);
    v7[4].m_pParent = 0;
    LOWORD(v7[6].m_pParent) = 256;
    BYTE2(v7[6].m_pParent) = 0;
    v7[7]._vptr$CTask = 0;
    v7->_vptr$CTask = (int (**)(void))&off_66D18C;
    v7[1]._vptr$CTask = (int (**)(void))m_pHoldEntity;
    v11 = *(_QWORD *)&p_m_vecAttachOffset->x;
    v7[2].m_pParent = (CTask *)LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)&v7[1].m_pParent = v11;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference((CEntity *)v7[1]._vptr$CTask, (CEntity **)&v7[1]);
    }
    v7[5].m_pParent = (CTask *)v10;
    v7[5]._vptr$CTask = (int (**)(void))m_nAnimFlags;
    v7[6]._vptr$CTask = (int (**)(void))HIDWORD(v10);
    CAnimManager::AddAnimBlockRef(((int)v10 - (int)CAnimManager::ms_aAnimBlocks) >> 5);
  }
  else
  {
    m_fTimeToDrop = this->m_fTimeToDrop;
    v12 = *(CTaskSimple *)&this->m_nAnimId;
    CTaskSimple::CTaskSimple(v3);
    LOBYTE(v7[3]._vptr$CTask) = m_nBoneId;
    v7[1].m_pParent = 0;
    v7[2]._vptr$CTask = 0;
    v7[2].m_pParent = 0;
    BYTE1(v7[3]._vptr$CTask) = m_nOrientateFlags;
    v7[4] = v12;
    v7[5].m_pParent = 0;
    v7[6]._vptr$CTask = 0;
    LOWORD(v7[6].m_pParent) = 256;
    BYTE2(v7[6].m_pParent) = 0;
    v7[7]._vptr$CTask = 0;
    v7->_vptr$CTask = (int (**)(void))&off_66D18C;
    v7[1]._vptr$CTask = (int (**)(void))m_pHoldEntity;
    v13 = *(_QWORD *)&p_m_vecAttachOffset->x;
    v7[2].m_pParent = (CTask *)LODWORD(this->m_vecAttachOffset.z);
    *(_QWORD *)&v7[1].m_pParent = v13;
    if ( m_pHoldEntity )
    {
      *(_DWORD *)&m_pHoldEntity->m_nFlags |= 0x400u;
      CEntity::RegisterReference((CEntity *)v7[1]._vptr$CTask, (CEntity **)&v7[1]);
    }
  }
  *(float *)&v7[7].m_pParent = m_fTimeToDrop;
  v7->_vptr$CTask = (int (**)(void))&off_66D298;
  return v7;
}
// BC: using guessed type int dword_BC;
// 66D18C: using guessed type void *off_66D18C;
// 66D298: using guessed type void *off_66D298;

//----- (0054449C) --------------------------------------------------------
int __fastcall CTaskSimplePutDownEntity::GetTaskType(const CTaskSimplePutDownEntity *this)
{
  return 309;
}

//----- (005444B0) --------------------------------------------------------
void __fastcall CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
        const CEntitySeekPosCalculatorXYOffset *this,
        const CPed *ped,
        const CEntity *entity,
        CVector *vSeekPos)
{
  CMatrix *m_pMat; // r12
  float x; // s0
  float y; // s2
  float z; // s4
  CSimpleTransform *p_tx; // r0
  float v9; // s8
  float v10; // s10
  CVector vTarget; // [sp+4h] [bp-14h] BYREF

  m_pMat = entity->m_pMat;
  x = this->m_vOffset.x;
  y = this->m_vOffset.y;
  z = this->m_vOffset.z;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &entity->m_transform;
  v9 = p_tx->m_translate.y;
  v10 = p_tx->m_translate.z;
  vTarget.x = p_tx->m_translate.x + x;
  vTarget.y = v9 + y;
  vTarget.z = v10 + z;
  CPedGeometryAnalyser::ComputeClearTarget(ped, &vTarget, vSeekPos);
}

//----- (00544508) --------------------------------------------------------
void __fastcall CEntitySeekPosCalculatorRadiusAngleOffset::ComputeEntitySeekPos(
        const CEntitySeekPosCalculatorRadiusAngleOffset *this,
        const CPed *ped,
        const CEntity *entity,
        CVector *vSeekPos)
{
  CMatrix *m_pMat; // r0
  float xy; // s2
  float yy; // s0
  float m_heading; // r5
  float v12; // r10
  float RadianAngleBetweenPoints; // r0
  float v14; // r0
  float v15; // r5
  float v16; // s0
  float m_fRadius; // s16
  CMatrix *v18; // r0
  float v19; // s0
  CSimpleTransform *p_tx; // r4
  RwReal v21; // s18
  float v22; // r0
  float z; // s4
  CVector vTarget; // [sp+4h] [bp-34h] BYREF

  m_pMat = entity->m_pMat;
  if ( m_pMat )
  {
    xy = m_pMat->xy;
    yy = m_pMat->yy;
  }
  else
  {
    m_heading = entity->m_transform.m_heading;
    v12 = sinf(m_heading);
    yy = cosf(m_heading);
    LODWORD(xy) = LODWORD(v12) ^ 0x80000000;
  }
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(xy, yy, 0.0, 0.0);
  v14 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  v15 = CGeneral::LimitRadianAngle(v14 + this->m_fAngle);
  v16 = sinf(v15);
  m_fRadius = this->m_fRadius;
  v18 = entity->m_pMat;
  v19 = v16 * m_fRadius;
  p_tx = (CSimpleTransform *)&v18->tx;
  if ( !v18 )
    p_tx = &entity->m_transform;
  v21 = p_tx->m_translate.x - v19;
  v22 = cosf(v15);
  vTarget.x = v21;
  z = p_tx->m_translate.z;
  vTarget.y = (float)(v22 * m_fRadius) + p_tx->m_translate.y;
  vTarget.z = (float)(m_fRadius * 0.0) + z;
  CPedGeometryAnalyser::ComputeClearTarget(ped, &vTarget, vSeekPos);
}

//----- (005445E4) --------------------------------------------------------
void __fastcall CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
        const CEntitySeekPosCalculatorDriving *this,
        const CPed *ped,
        const CEntity *entity,
        CVector *vSeekPos)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r12

  m_pMat = entity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &entity->m_transform;
  sub_19DCF0(ped, &p_tx->m_translate, vSeekPos);
}

//----- (005445FC) --------------------------------------------------------
void __fastcall CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
        const CEntitySeekPosCalculatorVehicleId *this,
        const CPed *ped,
        const CEntity *entity,
        CVector *vSeekPos)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float x; // s18
  float y; // s20
  float z; // s22
  float xx; // s0
  float yx; // s24
  float zx; // s4
  float xy; // s16
  float yy; // s2
  float zy; // s6
  float m_heading; // r4
  CColModel *m_pColModel; // r1
  int32 m_posId; // r0
  float v21; // s12
  float v22; // s10
  float v23; // s8
  float v24; // s4
  float v25; // s14
  float v26; // s8
  float v27; // s0
  float v28; // s4
  float v29; // s8
  float v30; // s10
  float v31; // s8
  float v32; // s4
  float v33; // s1
  float v34; // s8

  m_pMat = entity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &entity->m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  if ( m_pMat )
  {
    xx = m_pMat->xx;
    yx = m_pMat->yx;
    zx = m_pMat->zx;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
  }
  else
  {
    m_heading = entity->m_transform.m_heading;
    yx = sinf(m_heading);
    xy = -yx;
    zy = 0.0;
    yy = cosf(m_heading);
    xx = yy;
    zx = 0.0;
  }
  m_pColModel = CModelInfo::ms_modelInfoPtrs[entity->m_nModelIndex]->m_pColModel;
  m_posId = this->m_posId;
  v21 = m_pColModel->m_boxBound.m_vecMin.y;
  v22 = m_pColModel->m_boxBound.m_vecMax.y;
  if ( m_posId > 2 )
  {
    v31 = m_pColModel->m_boxBound.m_vecMax.x + 0.5;
    v32 = zx * v31;
    v33 = yx * v31;
    v34 = xx * v31;
    v27 = z + v32;
    v28 = y + v33;
    v29 = x + v34;
    if ( m_posId == 5 )
    {
      v30 = v21 * 0.5;
      goto LABEL_15;
    }
    if ( m_posId == 3 )
    {
      v30 = v22 * 0.5;
      goto LABEL_15;
    }
  }
  else
  {
    v23 = m_pColModel->m_boxBound.m_vecMin.x + -0.5;
    v24 = zx * v23;
    v25 = yx * v23;
    v26 = xx * v23;
    v27 = z + v24;
    v28 = y + v25;
    v29 = x + v26;
    if ( m_posId == 2 )
    {
      v30 = v21 * 0.5;
      goto LABEL_15;
    }
    if ( !m_posId )
    {
      v30 = v22 * 0.5;
LABEL_15:
      v27 = (float)(zy * v30) + v27;
      v28 = (float)(yy * v30) + v28;
      v29 = (float)(xy * v30) + v29;
    }
  }
  vSeekPos->x = v29;
  vSeekPos->y = v28;
  vSeekPos->z = v27;
}

//----- (00544730) --------------------------------------------------------
void __fastcall CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
        const CEntitySeekPosCalculatorEntitySurface *this,
        const CPed *ped,
        const CEntity *entity,
        CVector *vSeekPos)
{
  sub_18D7B0(ped, (CEntity *)entity, vSeekPos);
}

//----- (0054473A) --------------------------------------------------------
void __fastcall CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
        const CEntitySeekPosCalculatorFixedPos *this,
        const CPed *ped,
        const CEntity *entity,
        CVector *vSeekPos)
{
  sub_19DCF0(ped, &this->m_vecPos, vSeekPos);
}

//----- (00544750) --------------------------------------------------------
void __fastcall CFollowLeaderOffSets::CFollowLeaderOffSets(CFollowLeaderOffSets *this)
{
  this->m_fScale = 1.0;
  this->m_offsets[0] = (CVector2D)0x3F800000BF800000LL;
  this->m_offsets[1] = (CVector2D)0x3F8000003F800000LL;
  this->m_offsets[2].x = 0.0;
  this->m_offsets[2].y = 1.0;
  *(_QWORD *)&this->m_movingOffsets[2].y = 0xBFA00000BFA00000LL;
  *(_QWORD *)&this->m_movingOffsets[3].y = 0x3FA00000BFA00000LL;
  *(_QWORD *)&this->m_movingOffsets[0].y = 0x3F80000000000000LL;
  *(_QWORD *)&this->m_movingOffsets[1].y = 0LL;
  this->m_offsets[3] = (CVector2D)3212836864LL;
  this->m_offsets[4].x = 1.0;
  this->m_offsets[4].y = 0.0;
  this->m_offsets[5].x = -1.0;
  *(_QWORD *)&this->m_offsets[5].y = 3212836864LL;
  this->m_offsets[6].y = -1.0;
  this->m_offsets[7].x = 1.0;
  this->m_offsets[7].y = -1.0;
  this->m_movingOffsets[0].x = -1.0;
  *(_QWORD *)&this->m_movingOffsets[5].y = 0xBF800000C0200000LL;
  *(_QWORD *)&this->m_movingOffsets[6].y = 0x3F800000C0200000LL;
  this->m_movingOffsets[4].y = -1.25;
  this->m_movingOffsets[5].x = 0.0;
  this->m_movingOffsets[7].y = -2.5;
}

//----- (00544810) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderInFormation::CTaskComplexFollowLeaderInFormation(
        CTaskComplexFollowLeaderInFormation *this,
        CPedGroup *pPedGroup,
        CPed *pLeader,
        const int x,
        const int y,
        const float fMaxDistanceToLeader)
{
  int v10; // r0
  int *v11; // r2
  int v12; // r0

  CTaskComplex::CTaskComplex(this);
  this->m_pPedGroup = pPedGroup;
  this->m_iMoveState = 4;
  this->m_fMaxDistanceToLeader = fMaxDistanceToLeader;
  this->_vptr$CTask = (int (**)(void))&off_66D2CC;
  this->m_pLeader = pLeader;
  if ( x == 1 )
  {
    v10 = y + 1;
    if ( (unsigned int)(y + 1) < 3 )
    {
      v11 = dword_5448AC;
      goto LABEL_8;
    }
    goto LABEL_9;
  }
  if ( x )
  {
    if ( x == -1 )
    {
      v10 = y + 1;
      if ( (unsigned int)(y + 1) < 3 )
      {
        v11 = dword_5448B8;
LABEL_8:
        v12 = v11[v10];
        goto LABEL_14;
      }
    }
LABEL_9:
    v12 = 0;
    goto LABEL_14;
  }
  v12 = y;
  if ( y != 1 )
    v12 = 0;
  if ( y == -1 )
    v12 = 6;
LABEL_14:
  this->m_vOffset.x = CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[v12].x;
  this->m_vOffset.y = CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[v12].y;
  this->m_vOffset.z = 0.0;
  if ( pLeader )
    CEntity::RegisterReference(pLeader, &this->m_pLeader);
}
// 5448AC: using guessed type int dword_5448AC[3];
// 5448B8: using guessed type int dword_5448B8[3];
// 66D2CC: using guessed type void *off_66D2CC;

//----- (005448C8) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderInFormation::CTaskComplexFollowLeaderInFormation(
        CTaskComplexFollowLeaderInFormation *this,
        CPedGroup *pPedGroup,
        CPed *pLeader,
        const CVector *vOffset,
        const float fMaxDistanceToLeader)
{
  __int64 v9; // d16

  CTaskComplex::CTaskComplex(this);
  this->m_pPedGroup = pPedGroup;
  this->_vptr$CTask = (int (**)(void))&off_66D2CC;
  this->m_pLeader = pLeader;
  v9 = *(_QWORD *)&vOffset->x;
  this->m_vOffset.z = vOffset->z;
  this->m_iMoveState = 4;
  this->m_fMaxDistanceToLeader = fMaxDistanceToLeader;
  *(_QWORD *)&this->m_vOffset.x = v9;
  if ( pLeader )
    CEntity::RegisterReference(pLeader, &this->m_pLeader);
}
// 66D2CC: using guessed type void *;

//----- (00544920) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderInFormation::~CTaskComplexFollowLeaderInFormation(
        CTaskComplexFollowLeaderInFormation *this)
{
  CPed *m_pLeader; // r0
  CEntity **p_m_pLeader; // r1

  p_m_pLeader = &this->m_pLeader;
  m_pLeader = this->m_pLeader;
  this->_vptr$CTask = (int (**)(void))&off_66D2CC;
  if ( m_pLeader )
    CEntity::CleanUpOldReference(m_pLeader, p_m_pLeader);
  sub_18EDB4(this);
}
// 66D2CC: using guessed type void *off_66D2CC;

//----- (0054494C) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderInFormation::~CTaskComplexFollowLeaderInFormation(
        CTaskComplexFollowLeaderInFormation *this)
{
  CPed *m_pLeader; // r0
  CEntity **p_m_pLeader; // r1
  void *v4; // r0

  p_m_pLeader = &this->m_pLeader;
  m_pLeader = this->m_pLeader;
  this->_vptr$CTask = (int (**)(void))&off_66D2CC;
  if ( m_pLeader )
    CEntity::CleanUpOldReference(m_pLeader, p_m_pLeader);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 544974: variable 'v4' is possibly undefined
// 66D2CC: using guessed type void *off_66D2CC;

//----- (00544980) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderInFormation::CreateNextSubTask(
        CTaskComplexFollowLeaderInFormation *this,
        CPed *pPed)
{
  eMoveState m_eMoveState; // r5
  int v5; // r0
  char *v6; // r4
  CPed *m_pLeader; // r6
  char v9; // r3
  __int64 v10; // d16

  m_eMoveState = this->m_pLeader->m_eMoveState;
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v6 = 0;
  if ( v5 >= 704 )
  {
    if ( v5 != 704 && v5 != 709 )
    {
      if ( v5 != 907 )
        return (CTask *)v6;
      if ( (unsigned int)m_eMoveState <= PEDMOVE_STILL )
      {
        v6 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v6, 500, 0, 0, 8.0);
        return (CTask *)v6;
      }
    }
LABEL_12:
    v6 = (char *)CTask::operator new(0x58u);
    m_pLeader = this->m_pLeader;
    CTaskComplex::CTaskComplex((CTaskComplex *)v6);
    *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
    *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
    *((_DWORD *)v6 + 4) = 50000;
    *((_DWORD *)v6 + 5) = 1000;
    *((_WORD *)v6 + 24) = 0;
    *((_WORD *)v6 + 30) = 0;
    *((_DWORD *)v6 + 10) = 0;
    *((_DWORD *)v6 + 11) = 0;
    *((_DWORD *)v6 + 13) = 0;
    *((_DWORD *)v6 + 14) = 0;
    *((_DWORD *)v6 + 18) = 0;
    *((_DWORD *)v6 + 19) = 0;
    *((_DWORD *)v6 + 20) = 6;
    v9 = v6[84];
    *(_DWORD *)v6 = &off_668968;
    *((_DWORD *)v6 + 16) = &off_66D3CC;
    v6[84] = v9 & 0xF0 | 2;
    *((_DWORD *)v6 + 17) = 0;
    *((_DWORD *)v6 + 3) = m_pLeader;
    if ( m_pLeader )
      CEntity::RegisterReference(m_pLeader, (CEntity **)v6 + 3);
    v10 = *(_QWORD *)&this->m_vOffset.x;
    *((_DWORD *)v6 + 19) = LODWORD(this->m_vOffset.z);
    *(_QWORD *)(v6 + 68) = v10;
    *((_DWORD *)v6 + 20) = 7;
    return (CTask *)v6;
  }
  switch ( v5 )
  {
    case 202:
      v6 = (char *)CTask::operator new(0x18u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v6);
      *((_WORD *)v6 + 8) = 0;
      *((_DWORD *)v6 + 5) = 2000;
      *((_DWORD *)v6 + 2) = 0;
      *((_DWORD *)v6 + 3) = 0;
      *(_DWORD *)v6 = &off_665750;
      return (CTask *)v6;
    case 203:
      goto LABEL_12;
    case 700:
      return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowLeaderInFormation *, CPed *))this->_vptr$CTask + 11))(
                        this,
                        pPed);
  }
  return (CTask *)v6;
}
// 665750: using guessed type void *off_665750;
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (00544B60) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderInFormation::CreateSubTask(
        CTaskComplexFollowLeaderInFormation *this,
        const int iSubTaskType,
        const CPed *pPed)
{
  char *v5; // r4
  CPed *m_pLeader; // r8
  char v7; // r3
  __int64 v8; // d16
  int v9; // r4
  unsigned __int16 v10; // r0
  CPed *Member; // r4
  CMatrix *m_pMat; // r0
  float *p_tx; // r1
  CMatrix *v14; // r0
  float v15; // s0
  float v16; // s2
  float v17; // s4
  CSimpleTransform *p_m_transform; // r1
  RwReal v19; // s0
  RwReal v20; // s4
  float RadianAngleBetweenPoints; // r5
  float m_fCurrentHeading; // r1
  CVector v24; // [sp+Ch] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType < 704 )
  {
    switch ( iSubTaskType )
    {
      case 202:
        v5 = (char *)CTask::operator new(0x18u);
        CTaskSimple::CTaskSimple((CTaskSimple *)v5);
        *((_WORD *)v5 + 8) = 0;
        *((_DWORD *)v5 + 5) = 2000;
        *((_DWORD *)v5 + 2) = 0;
        *((_DWORD *)v5 + 3) = 0;
        *(_DWORD *)v5 = &off_665750;
        break;
      case 203:
        v5 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 500, 0, 0, 8.0);
        break;
      case 700:
        v5 = (char *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(
          (CTaskComplexEnterCarAsPassenger *)v5,
          this->m_pLeader->m_pMyVehicle,
          0,
          0);
        break;
    }
  }
  else if ( iSubTaskType > 901 )
  {
    if ( iSubTaskType == 902 )
    {
      v9 = CPedGroupMembership::CountMembers(&this->m_pPedGroup->m_membership);
      v10 = rand();
      Member = CPedGroupMembership::GetMember(
                 &this->m_pPedGroup->m_membership,
                 (int)(float)((float)((float)v10 * 0.000015259) * (float)v9));
      if ( Member == pPed )
        Member = CPedGroupMembership::GetLeader(&this->m_pPedGroup->m_membership);
      if ( Member && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 50.0) == 20 )
      {
        m_pMat = Member->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &Member->m_transform.m_translate.x;
        v14 = pPed->m_pMat;
        v15 = *p_tx;
        v16 = p_tx[1];
        v17 = p_tx[2];
        p_m_transform = (CSimpleTransform *)&v14->tx;
        if ( !v14 )
          p_m_transform = &pPed->m_transform;
        v19 = v15 - p_m_transform->m_translate.x;
        v20 = v17 - p_m_transform->m_translate.z;
        v24.y = v16 - p_m_transform->m_translate.y;
        v24.x = v19;
        v24.z = v20;
        CVector::Normalise(&v24);
        RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v24.x, v24.y, 0.0, 0.0);
        v5 = (char *)CTask::operator new(0x18u);
        m_fCurrentHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      }
      else
      {
        v5 = (char *)CTask::operator new(0x18u);
        m_fCurrentHeading = pPed->m_fCurrentHeading;
      }
      CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading((CTaskSimpleAchieveHeading *)v5, m_fCurrentHeading, 0.5, 0.2);
    }
    else if ( iSubTaskType == 907 )
    {
      v5 = (char *)CTask::operator new(0x58u);
      m_pLeader = this->m_pLeader;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_QWORD *)v5 + 3) = 0x400000003F800000LL;
      *((_QWORD *)v5 + 4) = 0x4000000000000000LL;
      *((_QWORD *)v5 + 2) = 0x3E80000C350LL;
      *((_WORD *)v5 + 24) = 0;
      *((_WORD *)v5 + 30) = 0;
      *((_DWORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 11) = 0;
      *((_DWORD *)v5 + 13) = 0;
      *((_DWORD *)v5 + 14) = 0;
      *((_DWORD *)v5 + 18) = 0;
      *((_DWORD *)v5 + 19) = 0;
      *((_DWORD *)v5 + 20) = 6;
      v7 = v5[84];
      *(_DWORD *)v5 = &off_668968;
      *((_DWORD *)v5 + 16) = &off_66D3CC;
      v5[84] = v7 & 0xF0 | 2;
      *((_DWORD *)v5 + 17) = 0;
      *((_DWORD *)v5 + 3) = m_pLeader;
      if ( m_pLeader )
        CEntity::RegisterReference(m_pLeader, (CEntity **)v5 + 3);
      v8 = *(_QWORD *)&this->m_vOffset.x;
      *((_DWORD *)v5 + 19) = LODWORD(this->m_vOffset.z);
      *(_QWORD *)(v5 + 68) = v8;
      *((_DWORD *)v5 + 20) = 7;
    }
  }
  else if ( iSubTaskType == 704 )
  {
    v5 = (char *)CTask::operator new(0x34u);
    CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
  }
  else if ( iSubTaskType == 709 )
  {
    v5 = (char *)CTask::operator new(0x60u);
    CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
  }
  return (CTask *)v5;
}
// 665750: using guessed type void *off_665750;
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (00544E44) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderInFormation::CreateFirstSubTask(
        CTaskComplexFollowLeaderInFormation *this,
        CPed *pPed)
{
  CVehicle *m_pMyVehicle; // lr
  bool v4; // zf
  int v5; // r1
  int v6; // r1
  CPed *m_pLeader; // r12

  v5 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31;
  v4 = v5 == 0;
  if ( v5 )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    v4 = m_pMyVehicle == 0;
  }
  if ( v4 )
  {
    v6 = 907;
  }
  else
  {
    m_pLeader = this->m_pLeader;
    v6 = 704;
    if ( *((unsigned __int8 *)&m_pLeader->m_nPedFlags + 1) << 31 && m_pLeader->m_pMyVehicle == m_pMyVehicle )
      v6 = 709;
  }
  return CTaskComplexFollowLeaderInFormation::CreateSubTask(this, v6, pPed);
}
// 544E7C: variable 'm_pMyVehicle' is possibly undefined

//----- (00544E90) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderInFormation::ControlSubTask(
        CTaskComplexFollowLeaderInFormation *this,
        CPed *pPed)
{
  CTaskComplexEnterCarAsPassenger *m_pSubTask; // r4
  CPed *m_pLeader; // r0
  bool v6; // zf
  int v7; // r1
  CTask *v8; // r0
  CTask *v10; // r0
  float m_fRadius; // s0
  uint32 v12; // r1
  float m_fMaxDistanceToLeader; // s0
  CPed *v14; // r0
  float v15; // s0
  CMatrix *v16; // r1
  CMatrix *v17; // r2
  CSimpleTransform *v18; // r3
  CSimpleTransform *v19; // r1
  float32x2_t v20; // d16
  unsigned __int64 v21; // d2
  CTaskSimpleStandStill *v22; // r0
  CPed *v23; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v25; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v28; // d16
  unsigned __int64 v29; // d1
  CPed *v30; // r8
  char m_pParent; // r3
  uint8 *p_m_nDoorFlagsSet; // r6
  CEntity **p_m_pTargetVehicle; // r1
  CEntity *v34; // r0
  __int64 v35; // d16
  CPed *v36; // r0
  CMatrix *v37; // r1
  CMatrix *v38; // r2
  CSimpleTransform *v39; // r3
  CSimpleTransform *v40; // r1
  float v41; // s0
  float32x2_t v42; // d16
  CVehicle *m_pMyVehicle; // r0
  unsigned __int64 v44; // d1
  CColModel *m_pColModel; // r1
  float v46; // s0
  CPed *v47; // r9
  char v48; // r2
  CTaskSimpleStandStill v49; // [sp+8h] [bp-38h] BYREF

  if ( !this->m_pLeader )
    return 0;
  m_pSubTask = (CTaskComplexEnterCarAsPassenger *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsPassenger *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 709 )
  {
    m_pLeader = this->m_pLeader;
    v6 = *((unsigned __int8 *)&m_pLeader->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&m_pLeader->m_nPedFlags + 1) << 31 )
      v6 = m_pLeader->m_pMyVehicle == 0;
    if ( v6 )
    {
      v7 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
      v8 = this->m_pSubTask;
      if ( v7 != 700 )
      {
        if ( (*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 5))(v8) != 202
          && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
        {
          return m_pSubTask;
        }
        v23 = this->m_pLeader;
        m_pMat = pPed->m_pMat;
        v25 = v23->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_m_transform = (CSimpleTransform *)&v25->tx;
        if ( !v25 )
          p_m_transform = &v23->m_transform;
        v28.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
        v29 = vmul_f32(v28, v28).n64_u64[0];
        if ( (float)((float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                                   * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                           + *(float *)&v29)
                   + *((float *)&v29 + 1)) >= (float)(this->m_fMaxDistanceToLeader * this->m_fMaxDistanceToLeader) )
          return m_pSubTask;
        m_pSubTask = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x58u);
        v30 = this->m_pLeader;
        CTaskComplex::CTaskComplex(m_pSubTask);
        *(_QWORD *)&m_pSubTask->m_iTargetDoorOppositeToFlag = 0x400000003F800000LL;
        *(_QWORD *)&m_pSubTask->m_iDraggedPedDownTime = 0x4000000000000000LL;
        *((_QWORD *)&m_pSubTask->CTaskComplexEnterCar + 2) = 0x3E80000C350LL;
        LOWORD(m_pSubTask->m_vTargetDoorPos.y) = 0;
        *(_WORD *)&m_pSubTask->m_bIsAborting = 0;
        *(_DWORD *)&m_pSubTask->m_nNumGettingInSet = 0;
        m_pSubTask->m_vTargetDoorPos.x = 0.0;
        m_pSubTask->m_vTargetDoorPos.z = 0.0;
        m_pSubTask->m_pTaskUtilityLineUpPedWithCar = 0;
        m_pSubTask->m_fCruiseSpeed = 0.0;
        m_pSubTask->m_iEnterCarStartTime = 0;
        m_pSubTask[1]._vptr$CTask = (int (**)(void))&byte_6;
        m_pParent = (char)m_pSubTask[1].m_pParent;
        m_pSubTask->_vptr$CTask = (int (**)(void))&off_668968;
        m_pSubTask->m_pDraggedPed = (CPed *)&off_66D3CC;
        LOBYTE(m_pSubTask[1].m_pParent) = m_pParent & 0xF0 | 2;
        *(_DWORD *)&m_pSubTask->m_nDoorFlagsSet = 0;
        p_m_nDoorFlagsSet = &m_pSubTask->m_nDoorFlagsSet;
        m_pSubTask->m_pTargetVehicle = (CVehicle *)v30;
        p_m_pTargetVehicle = &m_pSubTask->m_pTargetVehicle;
        if ( !v30 )
          goto LABEL_33;
        v34 = v30;
        goto LABEL_32;
      }
      if ( (*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))v8->_vptr$CTask + 7))(v8, pPed, 0, 0) == 1 )
        return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowLeaderInFormation *, CPed *))this->_vptr$CTask + 11))(
                          this,
                          pPed);
    }
    else
    {
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 907 )
      {
        v10 = this->m_pSubTask;
        m_fRadius = CModelInfo::ms_modelInfoPtrs[this->m_pLeader->m_pMyVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
        if ( *(float *)&v10[3]._vptr$CTask != m_fRadius )
        {
          *(float *)&v10[3]._vptr$CTask = m_fRadius;
          v12 = CTimer::m_snTimeInMilliseconds;
          LOBYTE(v10[6]._vptr$CTask) = 1;
          v10[5]._vptr$CTask = (int (**)(void))v12;
          v10[5].m_pParent = 0;
        }
        m_fMaxDistanceToLeader = this->m_fMaxDistanceToLeader;
        if ( m_fMaxDistanceToLeader > 0.0 )
        {
          v14 = this->m_pLeader;
          v15 = m_fMaxDistanceToLeader * m_fMaxDistanceToLeader;
          v16 = pPed->m_pMat;
          v17 = v14->m_pMat;
          v18 = (CSimpleTransform *)&v16->tx;
          if ( !v16 )
            v18 = &pPed->m_transform;
          v19 = (CSimpleTransform *)&v17->tx;
          if ( !v17 )
            v19 = &v14->m_transform;
          v20.n64_u64[0] = vsub_f32(*(float32x2_t *)&v18->m_translate.y, *(float32x2_t *)&v19->m_translate.y).n64_u64[0];
          v21 = vmul_f32(v20, v20).n64_u64[0];
          if ( (float)((float)((float)((float)(v18->m_translate.x - v19->m_translate.x)
                                     * (float)(v18->m_translate.x - v19->m_translate.x))
                             + *(float *)&v21)
                     + *((float *)&v21 + 1)) > v15
            && (*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                 this->m_pSubTask,
                 pPed,
                 0,
                 0) == 1 )
          {
            CTaskSimpleStandStill::CTaskSimpleStandStill(&v49, 0, 0, 0, 8.0);
            CTaskSimpleStandStill::ProcessPed(v22, pPed);
            m_pSubTask = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x18u);
            CTaskSimple::CTaskSimple((CTaskSimple *)m_pSubTask);
            *((_WORD *)&m_pSubTask->CTaskComplexEnterCar + 8) = 0;
            m_pSubTask->m_iTargetDoor = 2000;
            m_pSubTask->m_pSubTask = 0;
            m_pSubTask->m_pTargetVehicle = 0;
            m_pSubTask->_vptr$CTask = (int (**)(void))&off_665750;
            CTaskSimpleStandStill::~CTaskSimpleStandStill(&v49);
          }
        }
        return m_pSubTask;
      }
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203
        && !CPedGroups::GetPedsGroup(pPed) )
      {
        v36 = this->m_pLeader;
        v37 = pPed->m_pMat;
        v38 = v36->m_pMat;
        v39 = (CSimpleTransform *)&v37->tx;
        if ( !v37 )
          v39 = &pPed->m_transform;
        v40 = (CSimpleTransform *)&v38->tx;
        if ( !v38 )
          v40 = &v36->m_transform;
        v41 = v39->m_translate.x - v40->m_translate.x;
        v42.n64_u64[0] = vsub_f32(*(float32x2_t *)&v39->m_translate.y, *(float32x2_t *)&v40->m_translate.y).n64_u64[0];
        m_pMyVehicle = v36->m_pMyVehicle;
        v44 = vmul_f32(v42, v42).n64_u64[0];
        m_pColModel = CModelInfo::ms_modelInfoPtrs[m_pMyVehicle->m_nModelIndex]->m_pColModel;
        v46 = (float)((float)(v41 * v41) + *(float *)&v44) + *((float *)&v44 + 1);
        if ( v46 < (float)(m_pColModel->m_sphereBound.m_fRadius * m_pColModel->m_sphereBound.m_fRadius) )
        {
          if ( m_pMyVehicle->m_nNumPassengers < (unsigned int)m_pMyVehicle->m_nMaxPassengers
            && (*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                 this->m_pSubTask,
                 pPed,
                 0,
                 0) == 1 )
          {
            m_pSubTask = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
            CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(
              m_pSubTask,
              this->m_pLeader->m_pMyVehicle,
              0,
              0);
          }
          return m_pSubTask;
        }
        if ( v46 < (float)(this->m_fMaxDistanceToLeader * this->m_fMaxDistanceToLeader)
          && (*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               0,
               0) == 1 )
        {
          m_pSubTask = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x58u);
          v47 = this->m_pLeader;
          CTaskComplex::CTaskComplex(m_pSubTask);
          *(_QWORD *)&m_pSubTask->m_iTargetDoorOppositeToFlag = 0x400000003F800000LL;
          *(_QWORD *)&m_pSubTask->m_iDraggedPedDownTime = 0x4000000000000000LL;
          *((_QWORD *)&m_pSubTask->CTaskComplexEnterCar + 2) = 0x3E80000C350LL;
          LOWORD(m_pSubTask->m_vTargetDoorPos.y) = 0;
          *(_WORD *)&m_pSubTask->m_bIsAborting = 0;
          *(_DWORD *)&m_pSubTask->m_nNumGettingInSet = 0;
          m_pSubTask->m_vTargetDoorPos.x = 0.0;
          m_pSubTask->m_vTargetDoorPos.z = 0.0;
          m_pSubTask->m_pTaskUtilityLineUpPedWithCar = 0;
          m_pSubTask->m_fCruiseSpeed = 0.0;
          m_pSubTask->m_iEnterCarStartTime = 0;
          m_pSubTask[1]._vptr$CTask = (int (**)(void))&byte_6;
          v48 = (char)m_pSubTask[1].m_pParent;
          m_pSubTask->_vptr$CTask = (int (**)(void))&off_668968;
          m_pSubTask->m_pDraggedPed = (CPed *)&off_66D3CC;
          LOBYTE(m_pSubTask[1].m_pParent) = v48 & 0xF0 | 2;
          *(_DWORD *)&m_pSubTask->m_nDoorFlagsSet = 0;
          p_m_nDoorFlagsSet = &m_pSubTask->m_nDoorFlagsSet;
          m_pSubTask->m_pTargetVehicle = (CVehicle *)v47;
          p_m_pTargetVehicle = &m_pSubTask->m_pTargetVehicle;
          if ( !v47 )
            goto LABEL_33;
          v34 = v47;
LABEL_32:
          CEntity::RegisterReference(v34, p_m_pTargetVehicle);
LABEL_33:
          v35 = *(_QWORD *)&this->m_vOffset.x;
          *((_DWORD *)p_m_nDoorFlagsSet + 2) = LODWORD(this->m_vOffset.z);
          *(_QWORD *)p_m_nDoorFlagsSet = v35;
          m_pSubTask[1]._vptr$CTask = (int (**)(void))&byte_7;
        }
      }
    }
  }
  return m_pSubTask;
}
// 544FEE: variable 'v22' is possibly undefined
// 6: using guessed type char byte_6;
// 7: using guessed type char byte_7;
// 665750: using guessed type void *off_665750;
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (005452D0) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderAnyMeans::CTaskComplexFollowLeaderAnyMeans(
        CTaskComplexFollowLeaderAnyMeans *this,
        CPedGroup *pPedGroup,
        CPed *pLeader,
        const CVector *vOffset)
{
  __int64 v8; // d16

  CTaskComplex::CTaskComplex(this);
  this->m_pPedGroup = pPedGroup;
  this->_vptr$CTask = (int (**)(void))&off_66D308;
  this->m_pLeader = pLeader;
  v8 = *(_QWORD *)&vOffset->x;
  this->m_vOffset.z = vOffset->z;
  *(_QWORD *)&this->m_vOffset.x = v8;
  if ( pLeader )
    CEntity::RegisterReference(pLeader, &this->m_pLeader);
}
// 66D308: using guessed type void *;

//----- (0054531C) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderAnyMeans::~CTaskComplexFollowLeaderAnyMeans(
        CTaskComplexFollowLeaderAnyMeans *this)
{
  CPed *m_pLeader; // r0
  CEntity **p_m_pLeader; // r1

  p_m_pLeader = &this->m_pLeader;
  m_pLeader = this->m_pLeader;
  this->_vptr$CTask = (int (**)(void))&off_66D308;
  if ( m_pLeader )
    CEntity::CleanUpOldReference(m_pLeader, p_m_pLeader);
  sub_18EDB4(this);
}
// 66D308: using guessed type void *off_66D308;

//----- (00545348) --------------------------------------------------------
void __fastcall CTaskComplexFollowLeaderAnyMeans::~CTaskComplexFollowLeaderAnyMeans(
        CTaskComplexFollowLeaderAnyMeans *this)
{
  CPed *m_pLeader; // r0
  CEntity **p_m_pLeader; // r1
  void *v4; // r0

  p_m_pLeader = &this->m_pLeader;
  m_pLeader = this->m_pLeader;
  this->_vptr$CTask = (int (**)(void))&off_66D308;
  if ( m_pLeader )
    CEntity::CleanUpOldReference(m_pLeader, p_m_pLeader);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 545370: variable 'v4' is possibly undefined
// 66D308: using guessed type void *off_66D308;

//----- (00545378) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderAnyMeans::CreateNextSubTask(
        CTaskComplexFollowLeaderAnyMeans *this,
        CPed *pPed)
{
  int v4; // r0
  bool v5; // zf
  int v6; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 > 912 )
  {
    if ( v4 == 913 )
    {
      v6 = 1302;
    }
    else
    {
      if ( v4 != 922 )
        return 0;
      v6 = 719;
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        v6 = 203;
    }
  }
  else
  {
    v5 = v4 == 203;
    if ( v4 != 203 )
      v5 = v4 == 719;
    if ( !v5 )
      return 0;
    v6 = 922;
    if ( !(*((unsigned __int8 *)&this->m_pLeader->m_nPedFlags + 1) << 31) )
      v6 = 913;
  }
  return CTaskComplexFollowLeaderAnyMeans::CreateSubTask(this, v6, pPed);
}

//----- (005453E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderAnyMeans::CreateSubTask(
        const CTaskComplexFollowLeaderAnyMeans *this,
        const int iSubTaskType,
        const CPed *pPed)
{
  char *v5; // r4
  CPed *m_pLeader; // r8
  __int64 v7; // d16
  __int64 v8; // kr00_8
  __int64 v9; // d16

  v5 = 0;
  if ( iSubTaskType > 912 )
  {
    if ( iSubTaskType == 913 )
    {
      v5 = (char *)CTask::operator new(0x28u);
      v8 = *(_QWORD *)&this->m_pPedGroup;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_DWORD *)v5 + 3) = v8;
      *(_DWORD *)v5 = &off_66D2CC;
      *((_DWORD *)v5 + 4) = HIDWORD(v8);
      v9 = *(_QWORD *)&this->m_vOffset.x;
      *((_DWORD *)v5 + 7) = LODWORD(this->m_vOffset.z);
      *((_DWORD *)v5 + 8) = 4;
      *((_DWORD *)v5 + 9) = -1082130432;
      *(_QWORD *)(v5 + 20) = v9;
      if ( HIDWORD(v8) )
        CEntity::RegisterReference((CEntity *)HIDWORD(v8), (CEntity **)v5 + 4);
    }
    else if ( iSubTaskType == 922 )
    {
      v5 = (char *)CTask::operator new(0x34u);
      m_pLeader = this->m_pLeader;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_DWORD *)v5 + 4) = 1000;
      *((_DWORD *)v5 + 5) = 1090519040;
      *((_WORD *)v5 + 16) = 0;
      *((_DWORD *)v5 + 11) = 0;
      *((_DWORD *)v5 + 12) = 0;
      *((_DWORD *)v5 + 6) = 0;
      *((_DWORD *)v5 + 7) = 0;
      *(_DWORD *)v5 = &off_66D408;
      *((_DWORD *)v5 + 9) = &off_66D3CC;
      *((_DWORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 3) = m_pLeader;
      if ( m_pLeader )
        CEntity::RegisterReference(m_pLeader, (CEntity **)v5 + 3);
      v7 = *(_QWORD *)&this->m_vOffset.x;
      *((_DWORD *)v5 + 12) = LODWORD(this->m_vOffset.z);
      *((_QWORD *)v5 + 5) = v7;
      *((_DWORD *)v5 + 20) = 7;
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (char *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 719 )
  {
    v5 = (char *)CTask::operator new(0x70u);
    CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
    *((_DWORD *)v5 + 24) = 2000;
    *((_WORD *)v5 + 54) = 0;
    *((_DWORD *)v5 + 25) = 0;
    *((_DWORD *)v5 + 26) = 0;
    *(_DWORD *)v5 = &off_66571C;
  }
  return (CTask *)v5;
}
// 66571C: using guessed type void *off_66571C;
// 66D2CC: using guessed type void *off_66D2CC;
// 66D3CC: using guessed type void *off_66D3CC;
// 66D408: using guessed type void *;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;

//----- (00545534) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderAnyMeans::CreateFirstSubTask(
        CTaskComplexFollowLeaderAnyMeans *this,
        CPed *pPed)
{
  char *v3; // r4
  __int64 v4; // kr00_8
  __int64 v5; // d16

  v3 = (char *)CTask::operator new(0x28u);
  v4 = *(_QWORD *)&this->m_pPedGroup;
  CTaskComplex::CTaskComplex((CTaskComplex *)v3);
  *((_DWORD *)v3 + 3) = v4;
  *(_DWORD *)v3 = &off_66D2CC;
  *((_DWORD *)v3 + 4) = HIDWORD(v4);
  v5 = *(_QWORD *)&this->m_vOffset.x;
  *((_DWORD *)v3 + 7) = LODWORD(this->m_vOffset.z);
  *((_DWORD *)v3 + 8) = 4;
  *((_DWORD *)v3 + 9) = -1082130432;
  *(_QWORD *)(v3 + 20) = v5;
  if ( HIDWORD(v4) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v4), (CEntity **)v3 + 4);
  return (CTask *)v3;
}
// 66D2CC: using guessed type void *off_66D2CC;

//----- (00545594) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderAnyMeans::ControlSubTask(CTaskComplexFollowLeaderAnyMeans *this, CPed *pPed)
{
  void *m_pSubTask; // r4
  CPed *m_pLeader; // r8
  __int64 v5; // d16

  if ( !this->m_pLeader )
    return 0;
  m_pSubTask = this->m_pSubTask;
  if ( (*(int (__fastcall **)(void *))(*(_DWORD *)m_pSubTask + 20))(m_pSubTask) == 913
    && *((unsigned __int8 *)&this->m_pLeader->m_nPedFlags + 1) << 31 )
  {
    m_pSubTask = CTask::operator new(0x34u);
    m_pLeader = this->m_pLeader;
    CTaskComplex::CTaskComplex((CTaskComplex *)m_pSubTask);
    *((_DWORD *)m_pSubTask + 4) = 1000;
    *((_DWORD *)m_pSubTask + 5) = 1090519040;
    *((_WORD *)m_pSubTask + 16) = 0;
    *((_DWORD *)m_pSubTask + 11) = 0;
    *((_DWORD *)m_pSubTask + 12) = 0;
    *((_DWORD *)m_pSubTask + 6) = 0;
    *((_DWORD *)m_pSubTask + 7) = 0;
    *(_DWORD *)m_pSubTask = &off_66D408;
    *((_DWORD *)m_pSubTask + 9) = &off_66D3CC;
    *((_DWORD *)m_pSubTask + 10) = 0;
    *((_DWORD *)m_pSubTask + 3) = m_pLeader;
    if ( m_pLeader )
      CEntity::RegisterReference(m_pLeader, (CEntity **)m_pSubTask + 3);
    v5 = *(_QWORD *)&this->m_vOffset.x;
    *((_DWORD *)m_pSubTask + 12) = LODWORD(this->m_vOffset.z);
    *((_QWORD *)m_pSubTask + 5) = v5;
    *((_DWORD *)m_pSubTask + 20) = 7;
  }
  return (CTask *)m_pSubTask;
}
// 66D3CC: using guessed type void *off_66D3CC;
// 66D408: using guessed type void *off_66D408;

//----- (00545640) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntityAiming::CTaskComplexSeekEntityAiming(
        CTaskComplexSeekEntityAiming *this,
        CEntity *pEntity,
        const float fSeekRadius,
        const float fAimRadius)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fSeekRadius = fSeekRadius;
  this->m_fAimRadius = fAimRadius;
  this->_vptr$CTask = (int (**)(void))&off_66D344;
  this->m_pTargetEntity = pEntity;
  if ( pEntity )
    CEntity::RegisterReference(pEntity, &this->m_pTargetEntity);
}
// 66D344: using guessed type void *;

//----- (00545684) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntityAiming::~CTaskComplexSeekEntityAiming(CTaskComplexSeekEntityAiming *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66D344;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  sub_18EDB4(this);
}
// 66D344: using guessed type void *off_66D344;

//----- (005456B0) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntityAiming::~CTaskComplexSeekEntityAiming(CTaskComplexSeekEntityAiming *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1
  void *v4; // r0

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66D344;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5456D8: variable 'v4' is possibly undefined
// 66D344: using guessed type void *off_66D344;

//----- (005456E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAiming::CreateNextSubTask(CTaskComplexSeekEntityAiming *this, CPed *pPed)
{
  int v3; // r0
  void *v4; // r4
  __int64 v5; // kr00_8
  char v6; // r3

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v3 != 203 )
  {
    if ( v3 == 907 && this->m_pTargetEntity )
    {
      v4 = CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v4, 2000, 0, 0, 8.0);
      return (CTask *)v4;
    }
    return 0;
  }
  if ( !this->m_pTargetEntity )
    return 0;
  v4 = CTask::operator new(0x4Cu);
  v5 = *(_QWORD *)&this->m_pTargetEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v4);
  *((_DWORD *)v4 + 4) = 50000;
  *((_DWORD *)v4 + 5) = 1000;
  *((_DWORD *)v4 + 6) = HIDWORD(v5);
  *((_DWORD *)v4 + 7) = 0x40000000;
  *((_DWORD *)v4 + 8) = 0;
  *((_DWORD *)v4 + 9) = 0x40000000;
  *((_WORD *)v4 + 24) = 0;
  *((_WORD *)v4 + 30) = 0;
  *((_DWORD *)v4 + 10) = 0;
  *((_DWORD *)v4 + 11) = 0;
  *((_DWORD *)v4 + 13) = 0;
  *((_DWORD *)v4 + 14) = 0;
  v6 = *((_BYTE *)v4 + 72);
  *(_DWORD *)v4 = &off_6656D4;
  *((_DWORD *)v4 + 16) = &off_665710;
  *((_DWORD *)v4 + 17) = 6;
  *((_BYTE *)v4 + 72) = v6 & 0xF0 | 3;
  *((_DWORD *)v4 + 3) = v5;
  if ( (_DWORD)v5 )
    CEntity::RegisterReference((CEntity *)v5, (CEntity **)v4 + 3);
  return (CTask *)v4;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (005457B4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAiming::CreateFirstSubTask(CTaskComplexSeekEntityAiming *this, CPed *pPed)
{
  void *v3; // r4
  __int64 v4; // kr00_8
  char v5; // r3

  if ( !this->m_pTargetEntity )
    return 0;
  v3 = CTask::operator new(0x4Cu);
  v4 = *(_QWORD *)&this->m_pTargetEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v3);
  *((_DWORD *)v3 + 4) = 50000;
  *((_DWORD *)v3 + 5) = 1000;
  *((_DWORD *)v3 + 6) = HIDWORD(v4);
  *((_DWORD *)v3 + 7) = 0x40000000;
  *((_DWORD *)v3 + 8) = 0;
  *((_DWORD *)v3 + 9) = 0x40000000;
  *((_WORD *)v3 + 24) = 0;
  *((_WORD *)v3 + 30) = 0;
  *((_DWORD *)v3 + 10) = 0;
  *((_DWORD *)v3 + 11) = 0;
  *((_DWORD *)v3 + 13) = 0;
  *((_DWORD *)v3 + 14) = 0;
  v5 = *((_BYTE *)v3 + 72);
  *(_DWORD *)v3 = &off_6656D4;
  *((_DWORD *)v3 + 16) = &off_665710;
  *((_DWORD *)v3 + 17) = 6;
  *((_BYTE *)v3 + 72) = v5 & 0xF0 | 3;
  *((_DWORD *)v3 + 3) = v4;
  if ( (_DWORD)v4 )
    CEntity::RegisterReference((CEntity *)v4, (CEntity **)v3 + 3);
  return (CTask *)v3;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (0054584C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAiming::ControlSubTask(CTaskComplexSeekEntityAiming *this, CPed *pPed)
{
  CEntity *m_pTargetEntity; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v6; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float v9; // s16
  CTaskSimpleUseGun *TaskSecondary; // r6
  float v11; // s16
  int v12; // r0
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskSimpleUseGun *v14; // r5
  CVector v16; // 0:r2.8,8:^0.4

  m_pTargetEntity = this->m_pTargetEntity;
  m_pMat = pPed->m_pMat;
  v6 = m_pTargetEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_x = &v6->tx;
  if ( !v6 )
    p_x = &m_pTargetEntity->m_transform.m_translate.x;
  v9 = (float)((float)(p_tx->m_translate.x - *p_x) * (float)(p_tx->m_translate.x - *p_x))
     + (float)((float)(p_tx->m_translate.y - p_x[1]) * (float)(p_tx->m_translate.y - p_x[1]));
  TaskSecondary = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
  v11 = v9 + 0.0;
  v12 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v12 == 203 )
  {
    if ( TaskSecondary
      && (*((int (__fastcall **)(CTaskSimpleUseGun *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
    {
      CTaskSimpleUseGun::ControlGun(TaskSecondary, pPed, this->m_pTargetEntity, 1);
    }
    if ( v11 >= (float)(this->m_fSeekRadius * this->m_fSeekRadius) )
      (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
        this->m_pSubTask,
        pPed,
        0,
        0);
  }
  else if ( v12 == 907 )
  {
    if ( v11 >= (float)(this->m_fAimRadius * this->m_fAimRadius) )
    {
      if ( TaskSecondary
        && (*((int (__fastcall **)(CTaskSimpleUseGun *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
      {
        CTaskSimpleUseGun::ControlGun(TaskSecondary, pPed, this->m_pTargetEntity, 6);
      }
    }
    else if ( TaskSecondary )
    {
      if ( (*((int (__fastcall **)(CTaskSimpleUseGun *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
        CTaskSimpleUseGun::ControlGun(TaskSecondary, pPed, this->m_pTargetEntity, 1);
    }
    else
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v14 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
      v16.z = 0.0;
      *(_QWORD *)&v16.x = 0LL;
      CTaskSimpleUseGun::CTaskSimpleUseGun(v14, this->m_pTargetEntity, v16, 1, 1, 0);
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v14, 0);
    }
  }
  return this->m_pSubTask;
}

//----- (00545998) --------------------------------------------------------
void __fastcall CTaskComplexFollowPedFootsteps::CTaskComplexFollowPedFootsteps(
        CTaskComplexFollowPedFootsteps *this,
        CPed *pTargetPed)
{
  char v4; // r2
  CPointRoute *v5; // r0

  CTaskComplex::CTaskComplex(this);
  v4 = *((_BYTE *)this + 30);
  this->_vptr$CTask = (int (**)(void))&off_66D380;
  this->m_pTargetPed = pTargetPed;
  this->m_LastTime = CTimer::m_snTimeInMilliseconds;
  this->m_LastLosTime = 0;
  this->m_PointRoute = 0;
  this->m_MoveState = 4;
  *((_BYTE *)this + 30) = v4 & 0xFE;
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
  v5 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v5->m_iRouteSize = 0;
  this->m_PointRoute = v5;
  if ( v5 )
    v5->m_iRouteSize = 0;
}
// 66D380: using guessed type void *;

//----- (00545A04) --------------------------------------------------------
void __fastcall CTaskComplexFollowPedFootsteps::~CTaskComplexFollowPedFootsteps(CTaskComplexFollowPedFootsteps *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  CPointRoute *m_PointRoute; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66D380;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  m_PointRoute = this->m_PointRoute;
  if ( m_PointRoute )
  {
    CPointRoute::operator delete(m_PointRoute);
    this->m_PointRoute = 0;
  }
  sub_18EDB4(this);
}
// 66D380: using guessed type void *off_66D380;

//----- (00545A3C) --------------------------------------------------------
void __fastcall CTaskComplexFollowPedFootsteps::~CTaskComplexFollowPedFootsteps(CTaskComplexFollowPedFootsteps *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  CPointRoute *m_PointRoute; // r0
  void *v5; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66D380;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  m_PointRoute = this->m_PointRoute;
  if ( m_PointRoute )
  {
    CPointRoute::operator delete(m_PointRoute);
    this->m_PointRoute = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 545A70: variable 'v5' is possibly undefined
// 66D380: using guessed type void *off_66D380;

//----- (00545A78) --------------------------------------------------------
bool __fastcall CTaskComplexFollowPedFootsteps::MakeAbortable(
        CTaskComplexFollowPedFootsteps *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (00545A84) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPedFootsteps::CreateSubTask(
        CTaskComplexFollowPedFootsteps *this,
        const int iTaskType,
        const CPed *pPed)
{
  CPed *m_pTargetPed; // r2
  CPointRoute *m_PointRoute; // r0
  void *v6; // r4
  int m_nPedFlags; // r6
  CPed *v9; // r5
  float v10; // s0
  char v11; // r1
  __int64 v12; // d16
  CVector *v13; // r1
  int v14; // r2
  __int64 v15; // d16
  int v16; // r3
  CVector vTarget; // [sp+8h] [bp-20h] BYREF

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    return 0;
  m_PointRoute = this->m_PointRoute;
  v6 = 0;
  if ( m_PointRoute )
  {
    if ( iTaskType >= 900 )
    {
      if ( iTaskType == 900 )
      {
        v12 = *(_QWORD *)&m_PointRoute->m_routePoints[0].x;
        vTarget.z = m_PointRoute->m_routePoints[0].z;
        *(_QWORD *)&vTarget.x = v12;
        if ( m_PointRoute->m_iRouteSize < 2 )
        {
          v16 = m_PointRoute->m_iRouteSize - 1;
        }
        else
        {
          v13 = &m_PointRoute->m_routePoints[1];
          v14 = 0;
          do
          {
            v15 = *(_QWORD *)&v13->x;
            ++v14;
            v13[-1].z = v13->z;
            *(_QWORD *)&v13[-1].x = v15;
            ++v13;
            v16 = m_PointRoute->m_iRouteSize - 1;
          }
          while ( v14 < v16 );
        }
        m_PointRoute->m_iRouteSize = v16;
        v6 = CTask::operator new(0x2Cu);
        CTaskSimpleGoToPoint::CTaskSimpleGoToPoint((CTaskSimpleGoToPoint *)v6, this->m_MoveState, &vTarget, 0.01, 0, 0);
      }
      else if ( iTaskType == 907 )
      {
        m_nPedFlags = (int)m_pTargetPed->m_nPedFlags;
        v6 = CTask::operator new(0x4Cu);
        v9 = this->m_pTargetPed;
        CTaskComplex::CTaskComplex((CTaskComplex *)v6);
        v10 = 1.0;
        if ( (m_nPedFlags & 0x100) != 0 )
          v10 = 4.0;
        *(_DWORD *)v6 = &off_6656D4;
        *((_DWORD *)v6 + 4) = 50000;
        *((_DWORD *)v6 + 5) = 1000;
        *((_DWORD *)v6 + 7) = 0x40000000;
        *((_DWORD *)v6 + 8) = 0;
        *((_DWORD *)v6 + 9) = 0x40000000;
        *((_WORD *)v6 + 24) = 0;
        *((_WORD *)v6 + 30) = 0;
        *((_DWORD *)v6 + 10) = 0;
        *((_DWORD *)v6 + 11) = 0;
        *((_DWORD *)v6 + 13) = 0;
        *((_DWORD *)v6 + 14) = 0;
        v11 = *((_BYTE *)v6 + 72);
        *((_DWORD *)v6 + 16) = &off_665710;
        *((_DWORD *)v6 + 17) = 6;
        *((_BYTE *)v6 + 72) = v11 & 0xF0 | 3;
        *((float *)v6 + 6) = v10;
        *((_DWORD *)v6 + 3) = v9;
        if ( v9 )
          CEntity::RegisterReference(v9, (CEntity **)v6 + 3);
      }
    }
    else if ( iTaskType == 203 )
    {
      v6 = CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v6, 10000, 0, 0, 8.0);
    }
    else if ( iTaskType == 500 )
    {
      v6 = CTask::operator new(0x10u);
      CTaskSimpleHitHead::CTaskSimpleHitHead((CTaskSimpleHitHead *)v6);
    }
  }
  return (CTask *)v6;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (00545BE0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPedFootsteps::CreateNextSubTask(CTaskComplexFollowPedFootsteps *this, CPed *pPed)
{
  int v4; // r0
  CPed *m_pTargetPed; // r1
  CMatrix *m_pMat; // r2
  CMatrix *v7; // r3
  CSimpleTransform *p_tx; // r0
  CSimpleTransform *p_m_transform; // r2
  int (__fastcall *v10)(CTaskComplexFollowPedFootsteps *, int, CPed *); // r3
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  CTaskComplexFollowPedFootsteps *v13; // r0
  int v14; // r1
  CPointRoute *m_PointRoute; // r0
  bool v16; // zf
  int (**v17)(void); // r0
  int v18; // r1

  if ( !this->m_pTargetPed )
    goto LABEL_18;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 < 500 )
  {
    if ( v4 == 200 || v4 != 203 )
      goto LABEL_18;
    goto LABEL_14;
  }
  if ( v4 == 500 )
    goto LABEL_20;
  if ( v4 == 900 )
  {
LABEL_14:
    m_PointRoute = this->m_PointRoute;
    v16 = m_PointRoute == 0;
    if ( m_PointRoute )
      v16 = m_PointRoute->m_iRouteSize == 0;
    if ( !v16 )
    {
      v17 = this->_vptr$CTask;
      v18 = 900;
      return (CTask *)((int (__fastcall *)(CTaskComplexFollowPedFootsteps *, int, CPed *))v17[13])(this, v18, pPed);
    }
LABEL_20:
    v10 = (int (__fastcall *)(CTaskComplexFollowPedFootsteps *, int, CPed *))*((_DWORD *)this->_vptr$CTask + 13);
LABEL_21:
    v13 = this;
    v14 = 203;
    return (CTask *)v10(v13, v14, pPed);
  }
  if ( v4 != 907 )
  {
LABEL_18:
    v17 = this->_vptr$CTask;
    v18 = 1302;
    return (CTask *)((int (__fastcall *)(CTaskComplexFollowPedFootsteps *, int, CPed *))v17[13])(this, v18, pPed);
  }
  m_pTargetPed = this->m_pTargetPed;
  m_pMat = pPed->m_pMat;
  v7 = m_pTargetPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_m_transform = (CSimpleTransform *)&v7->tx;
  if ( !v7 )
    p_m_transform = &m_pTargetPed->m_transform;
  v10 = (int (__fastcall *)(CTaskComplexFollowPedFootsteps *, int, CPed *))*((_DWORD *)this->_vptr$CTask + 13);
  v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v12 = vmul_f32(v11, v11).n64_u64[0];
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                             * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                     + *(float *)&v12)
             + *((float *)&v12 + 1)) <= 1.4 )
    goto LABEL_21;
  v13 = this;
  v14 = 907;
  return (CTask *)v10(v13, v14, pPed);
}

//----- (00545CA8) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPedFootsteps::CreateFirstSubTask(CTaskComplexFollowPedFootsteps *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r1
  CMatrix *m_pMat; // r3
  CMatrix *v5; // lr
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r3
  int v8; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowPedFootsteps *, int, CPed *))this->_vptr$CTask + 13))(
                      this,
                      1302,
                      pPed);
  m_pMat = pPed->m_pMat;
  v5 = m_pTargetPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_m_transform = (CSimpleTransform *)&v5->tx;
  if ( !v5 )
    p_m_transform = &m_pTargetPed->m_transform;
  v8 = 203;
  v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v10 = vmul_f32(v9, v9).n64_u64[0];
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                             * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                     + *(float *)&v10)
             + *((float *)&v10 + 1)) > 1.4 )
    v8 = 907;
  return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowPedFootsteps *, int, CPed *))this->_vptr$CTask + 13))(
                    this,
                    v8,
                    pPed);
}

//----- (00545D2C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPedFootsteps::ControlSubTask(CTaskComplexFollowPedFootsteps *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  CTask *v5; // r8
  __int64 v6; // kr00_8
  int v7; // r4
  CPed *v9; // r2
  CMatrix *m_pMat; // r1
  CMatrix **p_m_pMat; // r11
  CSimpleTransform *p_m_transform; // r9
  CMatrix *v13; // r3
  CSimpleTransform *p_tx; // r0
  const CVector *p_m_translate; // r1
  bool IsLineOfSightClear; // r0
  float *p_x; // r3
  CMatrix *v18; // r1
  float *v19; // r0
  float v20; // s20
  float v21; // s18
  RwReal v22; // s0
  float v23; // s16
  float v24; // s22
  float v25; // s6
  float v26; // s24
  float v27; // s26
  uint32 *p_m_LastTime; // r4
  CPointRoute *m_PointRoute; // r0
  CPed *v30; // r2
  char *v31; // r1
  CMatrix *v32; // r3
  CSimpleTransform *v33; // r4
  __int64 v34; // d16
  CTask *SimplestActiveTask; // r0
  CTask *v36; // r0
  CPed *v37; // r2
  CMatrix *v38; // r3
  CSimpleTransform *v39; // r1
  __int64 v40; // d16
  char m_pParent; // r1
  CPointRoute *v42; // r0
  float *v43; // r1
  float v44; // s0
  float v45; // s4
  float v46; // s2
  RwReal v47; // s10
  float *v48; // r0
  float v49; // s10
  RwReal v50; // s0
  float *v51; // r1
  int v52; // r1
  CPointRoute *v53; // r0
  float x; // s2
  float *v55; // r1
  float y; // s4
  int v57; // r2
  float z; // s6
  float v59; // s0
  RwReal v60; // s8
  float v61; // s12
  RwReal v62; // s10
  __int64 v63; // r0
  int v64; // r3
  int v65; // r2
  float32x2_t v66; // d16
  unsigned __int64 v67; // d2
  CVector v68; // [sp+18h] [bp-68h] BYREF
  CVector v69; // [sp+24h] [bp-5Ch] BYREF

  v6 = *(_QWORD *)&this->m_pSubTask;
  m_pTargetPed = this->m_pTargetPed;
  v5 = (CTask *)v6;
  if ( !m_pTargetPed || !this->m_PointRoute || !CPed::IsAlive(m_pTargetPed) )
  {
    v7 = 1302;
    goto LABEL_7;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 907 )
    return this->m_pSubTask;
  v9 = this->m_pTargetPed;
  if ( !(*((unsigned __int8 *)&v9->m_nPedFlags + 1) << 31) )
  {
    if ( pPed->m_pPedIntelligence->m_iStaticCounter > 30 )
    {
      v7 = 500;
      goto LABEL_7;
    }
    if ( CTimer::m_snTimeInMilliseconds - this->m_LastLosTime <= 0x1F4 )
    {
      p_m_transform = &pPed->m_transform;
      p_m_pMat = &pPed->m_pMat;
    }
    else
    {
      this->m_LastLosTime = CTimer::m_snTimeInMilliseconds;
      p_m_pMat = &pPed->m_pMat;
      m_pMat = pPed->m_pMat;
      p_m_transform = &pPed->m_transform;
      v13 = v9->m_pMat;
      p_tx = &pPed->m_transform;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      p_m_translate = (const CVector *)&v13->tx;
      if ( !v13 )
        p_m_translate = &v9->m_transform.m_translate;
      IsLineOfSightClear = CWorld::GetIsLineOfSightClear(&p_tx->m_translate, p_m_translate, 1, 0, 0, 1, 0, 0, 0);
      v9 = this->m_pTargetPed;
      *((_BYTE *)this + 30) = IsLineOfSightClear | *((_BYTE *)this + 30) & 0xFE;
    }
    p_x = &p_m_transform->m_translate.x;
    v18 = v9->m_pMat;
    if ( *p_m_pMat )
      p_x = &(*p_m_pMat)->tx;
    v19 = &v18->tx;
    if ( !v18 )
      v19 = &v9->m_transform.m_translate.x;
    v20 = *v19;
    v21 = v19[1];
    v22 = *v19 - *p_x;
    v23 = v19[2];
    v24 = v23 - p_x[2];
    v25 = (float)(v21 - p_x[1]) * (float)(v21 - p_x[1]);
    v69.y = v21 - p_x[1];
    v69.x = v22;
    v69.z = v24;
    v26 = (float)(v22 * v22) + v25;
    v27 = v26 + (float)(v24 * v24);
    if ( v27 < 1.96
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
    {
      if ( !(*((unsigned __int8 *)this + 30) << 31) )
        return v5;
      v7 = 203;
      this->m_PointRoute->m_iRouteSize = 0;
      goto LABEL_7;
    }
    if ( v27 <= 64.0 && (sqrtf(v26) >= 1.0 || fabsf(v24) <= 2.0) )
    {
      if ( *((unsigned __int8 *)this + 30) << 31 )
      {
        this->m_PointRoute->m_iRouteSize = 0;
        m_PointRoute = this->m_PointRoute;
        if ( m_PointRoute->m_iRouteSize <= 7 )
        {
          v30 = this->m_pTargetPed;
          v31 = (char *)m_PointRoute + 12 * m_PointRoute->m_iRouteSize;
          v32 = v30->m_pMat;
          v33 = (CSimpleTransform *)&v32->tx;
          if ( !v32 )
            v33 = &v30->m_transform;
          v34 = *(_QWORD *)&v33->m_translate.x;
          *((_DWORD *)v31 + 3) = LODWORD(v33->m_translate.z);
          *(_QWORD *)(v31 + 4) = v34;
          ++m_PointRoute->m_iRouteSize;
        }
        this->m_LastTime = CTimer::m_snTimeInMilliseconds - 332;
        p_m_LastTime = &this->m_LastTime;
        SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
        if ( CTask::IsGoToTask(SimplestActiveTask) )
        {
          v36 = CTaskManager::GetSimplestActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
          v37 = this->m_pTargetPed;
          v38 = v37->m_pMat;
          v39 = (CSimpleTransform *)&v38->tx;
          if ( !v38 )
            v39 = &v37->m_transform;
          if ( *(float *)&v36[1].m_pParent != v39->m_translate.x
            || *(float *)&v36[2]._vptr$CTask != v39->m_translate.y
            || *(float *)&v36[2].m_pParent != v39->m_translate.z
            || *(float *)&v36[3]._vptr$CTask != 0.5 )
          {
            v40 = *(_QWORD *)&v39->m_translate.x;
            v36[2].m_pParent = (CTask *)LODWORD(v39->m_translate.z);
            *(_QWORD *)&v36[1].m_pParent = v40;
            m_pParent = (char)v36[3].m_pParent;
            v36[3]._vptr$CTask = (int (**)(void))1056964608;
            LOBYTE(v36[3].m_pParent) = m_pParent & 0xD0 | 0x20;
          }
        }
      }
      else
      {
        p_m_LastTime = &this->m_LastTime;
      }
      if ( CTimer::m_snTimeInMilliseconds - *p_m_LastTime < 0xA6 || (v42 = this->m_PointRoute, v42->m_iRouteSize > 7) )
      {
        if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
          || this->m_PointRoute->m_iRouteSize <= 1 )
        {
          return v5;
        }
        v7 = 900;
        goto LABEL_7;
      }
      *p_m_LastTime = CTimer::m_snTimeInMilliseconds;
      if ( v42->m_iRouteSize )
      {
        v43 = (float *)(&v42->m_iRouteSize + 3 * v42->m_iRouteSize);
        v44 = *(v43 - 2);
        v45 = *(v43 - 1);
        v46 = *v43;
        v47 = v23 - *v43;
        v69.y = v21 - v45;
        v69.x = v20 - v44;
        v69.z = v47;
        if ( (float)((float)((float)((float)(v20 - v44) * (float)(v20 - v44))
                           + (float)((float)(v21 - v45) * (float)(v21 - v45)))
                   + (float)(v47 * v47)) <= 0.1225 )
          goto LABEL_59;
        if ( v42->m_iRouteSize >= 2 )
        {
          v48 = (float *)(&v42->m_iRouteSize + 3 * v42->m_iRouteSize);
          v49 = *(v48 - 3);
          v50 = v44 - *(v48 - 5);
          v68.y = v45 - *(v48 - 4);
          v68.x = v50;
          v68.z = v46 - v49;
          CVector::Normalise(&v68);
          CVector::Normalise(&v69);
          if ( (float)((float)((float)(v68.x * v69.x) + (float)(v68.y * v69.y)) + (float)(v68.z * v69.z)) >= 0.95 )
            --this->m_PointRoute->m_iRouteSize;
        }
        v42 = this->m_PointRoute;
        if ( v42->m_iRouteSize > 7 )
          goto LABEL_59;
        v51 = (float *)(&v42->m_iRouteSize + 3 * v42->m_iRouteSize);
        v51[1] = v20;
        v51[2] = v21;
        v51[3] = v23;
        v52 = v42->m_iRouteSize + 1;
      }
      else
      {
        v52 = 1;
        v42->m_routePoints[0].x = v20;
        v42->m_routePoints[0].y = v21;
        v42->m_routePoints[0].z = v23;
      }
      v42->m_iRouteSize = v52;
LABEL_59:
      v53 = this->m_PointRoute;
      if ( v53->m_iRouteSize < 2 )
      {
        v59 = 0.0;
      }
      else
      {
        x = v53->m_routePoints[0].x;
        v55 = &v53->m_routePoints[1].x;
        y = v53->m_routePoints[0].y;
        v57 = 1;
        z = v53->m_routePoints[0].z;
        v59 = 0.0;
        do
        {
          ++v57;
          v60 = *v55 - x;
          v61 = v55[2];
          v62 = v55[1] - y;
          v55 += 3;
          v69.y = v62;
          v69.x = v60;
          v69.z = v61 - z;
          v59 = v59 + (float)((float)((float)(v60 * v60) + (float)(v62 * v62)) + (float)(v69.z * v69.z));
        }
        while ( v57 < v53->m_iRouteSize );
      }
      v63 = *(_QWORD *)&this->m_pSubTask;
      v64 = *(_DWORD *)(HIDWORD(v63) + 20);
      if ( *p_m_pMat )
        p_m_transform = (CSimpleTransform *)&(*p_m_pMat)->tx;
      v65 = v64 + 48;
      if ( !v64 )
        v65 = HIDWORD(v63) + 4;
      WORD2(v63) = 4;
      v66.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)(v65 + 4)).n64_u64[0];
      v67 = vmul_f32(v66, v66).n64_u64[0];
      if ( (float)(v59
                 + (float)((float)((float)((float)(p_m_transform->m_translate.x - *(float *)v65)
                                         * (float)(p_m_transform->m_translate.x - *(float *)v65))
                                 + *(float *)&v67)
                         + *((float *)&v67 + 1))) > 12.25 )
        WORD2(v63) = 6;
      this->m_MoveState = WORD2(v63);
      if ( (*(int (__fastcall **)(_DWORD))(*(_DWORD *)v63 + 20))(v63) == 900 )
        this->m_pSubTask[1]._vptr$CTask = (int (**)(void))this->m_MoveState;
      return v5;
    }
  }
  v7 = 907;
LABEL_7:
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexFollowPedFootsteps *, int, CPed *))this->_vptr$CTask + 13))(
                      this,
                      v7,
                      pPed);
  return v5;
}

//----- (0054622C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderInFormation::Clone(const CTaskComplexFollowLeaderInFormation *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  float m_fMaxDistanceToLeader; // r9
  __int64 v6; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x28u);
  v3 = *(_QWORD *)&this->m_pPedGroup;
  v4 = v2;
  m_fMaxDistanceToLeader = this->m_fMaxDistanceToLeader;
  CTaskComplex::CTaskComplex(v2);
  v4[1]._vptr$CTask = (int (**)(void))v3;
  v4->_vptr$CTask = (int (**)(void))&off_66D2CC;
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v6 = *(_QWORD *)&this->m_vOffset.x;
  v4[2].m_pParent = (CTask *)LODWORD(this->m_vOffset.z);
  v4[2].m_pSubTask = (CTask *)byte_4;
  *(float *)&v4[3]._vptr$CTask = m_fMaxDistanceToLeader;
  *(_QWORD *)&v4[1].m_pSubTask = v6;
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)&v4[1].m_pParent);
  return v4;
}
// 66D2CC: using guessed type void *off_66D2CC;

//----- (0054628C) --------------------------------------------------------
int __fastcall CTaskComplexFollowLeaderInFormation::GetTaskType(const CTaskComplexFollowLeaderInFormation *this)
{
  return 913;
}

//----- (00546294) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowLeaderAnyMeans::Clone(const CTaskComplexFollowLeaderAnyMeans *this)
{
  char *v2; // r4
  __int64 v3; // kr00_8
  __int64 v4; // d16

  v2 = (char *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pPedGroup;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v3;
  *(_DWORD *)v2 = &off_66D308;
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  v4 = *(_QWORD *)&this->m_vOffset.x;
  *((_DWORD *)v2 + 7) = LODWORD(this->m_vOffset.z);
  *(_QWORD *)(v2 + 20) = v4;
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 66D308: using guessed type void *off_66D308;

//----- (005462E8) --------------------------------------------------------
int __fastcall CTaskComplexFollowLeaderAnyMeans::GetTaskType(const CTaskComplexFollowLeaderAnyMeans *this)
{
  return 923;
}

//----- (005462F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAiming::Clone(const CTaskComplexSeekEntityAiming *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  float m_fAimRadius; // r6

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  v3 = *(_QWORD *)&this->m_pTargetEntity;
  v4 = v2;
  m_fAimRadius = this->m_fAimRadius;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  *(float *)&v4[1].m_pSubTask = m_fAimRadius;
  v4->_vptr$CTask = (int (**)(void))&off_66D344;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  return v4;
}
// 66D344: using guessed type void *off_66D344;

//----- (00546338) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntityAiming::GetTaskType(const CTaskComplexSeekEntityAiming *this)
{
  return 933;
}

//----- (00546340) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntityAiming::Serialize(CTaskComplexSeekEntityAiming *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pTargetEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  float *v14; // r5
  float *v15; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexSeekEntityAiming *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntityAiming *))this->_vptr$CTask + 5))(this) != 933 )
  {
    v10 = (*((int (__fastcall **)(CTaskComplexSeekEntityAiming *))this->_vptr$CTask + 5))(this);
    sub_1941C4(933, v10);
    return;
  }
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_20;
  }
  v5 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pTargetEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  switch ( v8 )
  {
    case 2:
      v9 = GettPoolVehicleRef((CVehicle *)v7);
      goto LABEL_17;
    case 4:
      v9 = GettPoolObjRef((CObject *)v7);
      goto LABEL_17;
    case 3:
      v9 = GettPoolPedRef((CPed *)v7);
LABEL_17:
      if ( UseDataFence )
        AddDataFence();
      v13 = malloc(4u);
      *v13 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v12 = v13;
LABEL_20:
      free(v12);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = (float *)malloc(4u);
  *v14 = this->m_fSeekRadius;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
  free(v14);
  if ( UseDataFence )
    AddDataFence();
  v15 = (float *)malloc(4u);
  *v15 = this->m_fAimRadius;
  CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
  j_free(v15);
}

//----- (005464D4) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPedFootsteps::Clone(const CTaskComplexFollowPedFootsteps *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5
  char v4; // r3
  _DWORD *v5; // r0

  v2 = CTask::operator new(0x20u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  v4 = *((_BYTE *)v2 + 30);
  *(_DWORD *)v2 = &off_66D380;
  *((_DWORD *)v2 + 3) = m_pTargetPed;
  *((_DWORD *)v2 + 4) = CTimer::m_snTimeInMilliseconds;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_WORD *)v2 + 14) = 4;
  *((_BYTE *)v2 + 30) = v4 & 0xFE;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 3);
  v5 = CPointRoute::operator new(0x64u);
  *v5 = 0;
  *((_DWORD *)v2 + 6) = v5;
  if ( v5 )
    *v5 = 0;
  return (CTask *)v2;
}
// 66D380: using guessed type void *off_66D380;

//----- (00546548) --------------------------------------------------------
int __fastcall CTaskComplexFollowPedFootsteps::GetTaskType(const CTaskComplexFollowPedFootsteps *this)
{
  return 936;
}

//----- (00546550) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::~CTaskComplexSeekEntityAnyMeans(
        CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66D408;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 66D408: using guessed type void *off_66D408;

//----- (0054657C) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::~CTaskComplexSeekEntityAnyMeans(
        CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66D408;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5465A4: variable 'v4' is possibly undefined
// 66D408: using guessed type void *off_66D408;

//----- (005465AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::Clone(
        const CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this)
{
  void *v2; // r5
  CEntity *m_pEntity; // r6
  __int64 v4; // d16
  CTask *result; // r0

  v2 = CTask::operator new(0x34u);
  m_pEntity = this->m_pEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = 1000;
  *((_DWORD *)v2 + 5) = 1090519040;
  *((_WORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 12) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *(_DWORD *)v2 = &off_66D408;
  *((_DWORD *)v2 + 9) = &off_66D3CC;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
  v4 = *(_QWORD *)&this->m_entitySeekPosCalculator.m_vOffset.x;
  *((_DWORD *)v2 + 12) = LODWORD(this->m_entitySeekPosCalculator.m_vOffset.z);
  result = (CTask *)v2;
  *((_QWORD *)v2 + 5) = v4;
  return result;
}
// 66D3CC: using guessed type void *off_66D3CC;
// 66D408: using guessed type void *off_66D408;

//----- (0054662C) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::GetTaskType(
        const CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this)
{
  return 922;
}

//----- (00546632) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::CreateNextSubTask(
        CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed)
{
  return 0;
}

//----- (00546638) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::CreateFirstSubTask(
        CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r0
  float y; // s2
  CMatrix *m_pMat; // r2
  float z; // s4
  float *p_tx; // r3
  __int64 v8; // r0
  float m_fTargetRadius; // s16
  CTaskComplexDriveToPoint *v10; // r0
  CTask *result; // r0
  CVector vClearTarget; // [sp+10h] [bp-28h] BYREF
  CVector vTarget; // [sp+1Ch] [bp-1Ch] BYREF

  m_pEntity = this->m_pEntity;
  y = this->m_entitySeekPosCalculator.m_vOffset.y;
  m_pMat = m_pEntity->m_pMat;
  z = this->m_entitySeekPosCalculator.m_vOffset.z;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pEntity->m_transform.m_translate.x;
  vTarget.x = *p_tx + this->m_entitySeekPosCalculator.m_vOffset.x;
  vTarget.y = p_tx[1] + y;
  vTarget.z = p_tx[2] + z;
  CPedGeometryAnalyser::ComputeClearTarget(pPed, &vTarget, &vClearTarget);
  HIDWORD(v8) = this->m_iPeriod;
  m_fTargetRadius = this->m_fTargetRadius;
  LODWORD(v8) = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  *(_QWORD *)&this->m_scanTimer.m_iStartTime = v8;
  v10 = (CTaskComplexDriveToPoint *)CTask::operator new(0x3Cu);
  CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(v10, 0, &vClearTarget, 30.0, 0, -1, m_fTargetRadius, 0);
  return result;
}

//----- (005466D8) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset>::ControlSubTask(
        CTaskComplexSeekEntityAnyMeans<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r0
  __int64 v4; // r2
  CTaskComplex *v5; // r0
  CTask *result; // r0
  CTask *m_pSubTask; // r6
  CMatrix *m_pMat; // r2
  float *p_tx; // r3
  float y; // s2
  float z; // s4
  __int64 v12; // d16
  CVector v13; // [sp+0h] [bp-28h] BYREF
  CVector v14; // [sp+Ch] [bp-1Ch] BYREF

  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
  {
    if ( this->m_scanTimer.m_bIsActive )
    {
      if ( this->m_scanTimer.m_bIsStopped )
      {
        LODWORD(v4) = CTimer::m_snTimeInMilliseconds;
        this->m_scanTimer.m_bIsStopped = 0;
        this->m_scanTimer.m_iStartTime = v4;
        HIDWORD(v4) = v4;
      }
      else
      {
        HIDWORD(v4) = this->m_scanTimer.m_iStartTime;
        LODWORD(v4) = CTimer::m_snTimeInMilliseconds;
      }
      if ( HIDWORD(v4) + this->m_scanTimer.m_iDuration <= (unsigned int)v4 )
      {
        HIDWORD(v4) = this->m_iPeriod;
        m_pSubTask = this->m_pSubTask;
        this->m_scanTimer.m_bIsActive = 1;
        *(_QWORD *)&this->m_scanTimer.m_iStartTime = v4;
        m_pMat = m_pEntity->m_pMat;
        p_tx = &m_pMat->tx;
        y = this->m_entitySeekPosCalculator.m_vOffset.y;
        z = this->m_entitySeekPosCalculator.m_vOffset.z;
        if ( !m_pMat )
          p_tx = &m_pEntity->m_transform.m_translate.x;
        v14.x = *p_tx + this->m_entitySeekPosCalculator.m_vOffset.x;
        v14.y = p_tx[1] + y;
        v14.z = p_tx[2] + z;
        CPedGeometryAnalyser::ComputeClearTarget(pPed, &v14, &v13);
        v12 = *(_QWORD *)&v13.x;
        m_pSubTask[5].m_pParent = (CTask *)LODWORD(v13.z);
        *(_QWORD *)&m_pSubTask[4].m_pParent = v12;
      }
    }
    return this->m_pSubTask;
  }
  else
  {
    v5 = (CTaskComplex *)CTask::operator new(0x14u);
    CTaskComplex::CTaskComplex(v5);
    result[1].m_pParent = 0;
    LOWORD(result[2]._vptr$CTask) = 1;
    result->_vptr$CTask = (int (**)(void))&off_66AF80;
  }
  return result;
}
// 546718: variable 'result' is possibly undefined
// 66AF80: using guessed type void *off_66AF80;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (005467B4) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDeadPed::CTaskComplexInvestigateDeadPed(
        CTaskComplexInvestigateDeadPed *this,
        CPed *pDeadPed)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  *(_QWORD *)&this->m_vStartPos.x = 0LL;
  *(_QWORD *)&this->m_vStartPos.z = 0LL;
  this->m_timer.m_iDuration = 0;
  *(_QWORD *)&this->m_vTargetPos.x = 0LL;
  *(_QWORD *)&this->m_vTargetPos.z = 0LL;
  this->m_timer.m_iStartTime = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D444;
  this->m_pDeadPed = pDeadPed;
  if ( pDeadPed )
    CEntity::RegisterReference(pDeadPed, &this->m_pDeadPed);
}
// 66D444: using guessed type void *;

//----- (00546800) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDeadPed::~CTaskComplexInvestigateDeadPed(CTaskComplexInvestigateDeadPed *this)
{
  CPed *m_pDeadPed; // r0
  CEntity **p_m_pDeadPed; // r1

  p_m_pDeadPed = &this->m_pDeadPed;
  m_pDeadPed = this->m_pDeadPed;
  this->_vptr$CTask = (int (**)(void))&off_66D444;
  if ( m_pDeadPed )
    CEntity::CleanUpOldReference(m_pDeadPed, p_m_pDeadPed);
  sub_18EDB4(this);
}
// 66D444: using guessed type void *off_66D444;

//----- (0054682C) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDeadPed::~CTaskComplexInvestigateDeadPed(CTaskComplexInvestigateDeadPed *this)
{
  CPed *m_pDeadPed; // r0
  CEntity **p_m_pDeadPed; // r1
  void *v4; // r0

  p_m_pDeadPed = &this->m_pDeadPed;
  m_pDeadPed = this->m_pDeadPed;
  this->_vptr$CTask = (int (**)(void))&off_66D444;
  if ( m_pDeadPed )
    CEntity::CleanUpOldReference(m_pDeadPed, p_m_pDeadPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 546854: variable 'v4' is possibly undefined
// 66D444: using guessed type void *off_66D444;

//----- (0054685C) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDeadPed::ComputeTargetPos(
        CTaskComplexInvestigateDeadPed *this,
        CPed *pPed,
        CVector *vTargetPos)
{
  CPed *m_pDeadPed; // r0
  CMatrix *m_pMat; // r2
  CMatrix *v7; // r3
  CSimpleTransform *p_tx; // r4
  float *p_x; // r1
  float y; // s2
  float v11; // s6
  RwReal v12; // s0
  CPed *v13; // r0
  CMatrix *v14; // r1
  float *v15; // r2
  RwReal v16; // s2
  RwReal v17; // s4
  CVector v18; // [sp+4h] [bp-1Ch] BYREF

  m_pDeadPed = this->m_pDeadPed;
  m_pMat = pPed->m_pMat;
  v7 = m_pDeadPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_x = &v7->tx;
  y = p_tx->m_translate.y;
  if ( !v7 )
    p_x = &m_pDeadPed->m_transform.m_translate.x;
  v11 = p_x[1];
  v12 = p_tx->m_translate.x - *p_x;
  v18.z = 0.0;
  v18.y = y - v11;
  v18.x = v12;
  CVector::Normalise(&v18);
  v13 = this->m_pDeadPed;
  v14 = v13->m_pMat;
  v15 = &v14->tx;
  if ( !v14 )
    v15 = &v13->m_transform.m_translate.x;
  v16 = (float)(v18.y + v18.y) + v15[1];
  v17 = (float)(v18.z + v18.z) + v15[2];
  vTargetPos->x = (float)(v18.x + v18.x) + *v15;
  vTargetPos->y = v16;
  vTargetPos->z = v17;
}

//----- (00546900) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDeadPed::CreateNextSubTask(CTaskComplexInvestigateDeadPed *this, CPed *pPed)
{
  int v4; // r0
  int v5; // r1
  CPed *m_pDeadPed; // r12
  CMatrix *m_pMat; // r1
  CMatrix *v8; // r0
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  __int64 v11; // r2

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 > 901 )
  {
    switch ( v4 )
    {
      case 902:
        IKChainManager_c::LookAt(
          &g_ikChainMan,
          "TaskInvDeadPed",
          pPed,
          this->m_pDeadPed,
          this->m_iLookTime,
          5,
          0,
          0,
          0.25,
          500,
          3,
          0);
        v5 = 1210;
        return CTaskComplexInvestigateDeadPed::CreateSubTask(this, v5, pPed);
      case 903:
        m_pDeadPed = this->m_pDeadPed;
        m_pMat = pPed->m_pMat;
        v8 = m_pDeadPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_x = &v8->tx;
        v11 = *(_QWORD *)&p_tx->m_translate.x;
        if ( !v8 )
          p_x = &m_pDeadPed->m_transform.m_translate.x;
        this->m_fTargetHeading = CGeneral::GetRadianAngleBetweenPoints(
                                   *p_x,
                                   p_x[1],
                                   *(float *)&v11,
                                   *((float *)&v11 + 1));
        v5 = 902;
        return CTaskComplexInvestigateDeadPed::CreateSubTask(this, v5, pPed);
      case 1210:
        v5 = 400;
        return CTaskComplexInvestigateDeadPed::CreateSubTask(this, v5, pPed);
    }
  }
  else
  {
    switch ( v4 )
    {
      case 203:
        v5 = 903;
        return CTaskComplexInvestigateDeadPed::CreateSubTask(this, v5, pPed);
      case 400:
        v5 = 900;
        return CTaskComplexInvestigateDeadPed::CreateSubTask(this, v5, pPed);
      case 900:
        v5 = 1302;
        return CTaskComplexInvestigateDeadPed::CreateSubTask(this, v5, pPed);
    }
  }
  return 0;
}

//----- (005469F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDeadPed::CreateSubTask(
        CTaskComplexInvestigateDeadPed *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskSimpleAchieveHeading *v5; // r4
  CPed *m_pDeadPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v8; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float y; // s2
  float v12; // s6
  RwReal v13; // s0
  CPed *v14; // r0
  CMatrix *v15; // r1
  float *v16; // r2
  RwReal v17; // s2
  RwReal v18; // s4
  CVector v20; // [sp+24h] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType > 901 )
  {
    switch ( iSubTaskType )
    {
      case 902:
        v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
        CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v5, this->m_fTargetHeading, 0.5, 0.2);
        break;
      case 903:
        m_pDeadPed = this->m_pDeadPed;
        m_pMat = pPed->m_pMat;
        v8 = m_pDeadPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_x = &v8->tx;
        y = p_tx->m_translate.y;
        if ( !v8 )
          p_x = &m_pDeadPed->m_transform.m_translate.x;
        v12 = p_x[1];
        v13 = p_tx->m_translate.x - *p_x;
        v20.z = 0.0;
        v20.y = y - v12;
        v20.x = v13;
        CVector::Normalise(&v20);
        v14 = this->m_pDeadPed;
        v15 = v14->m_pMat;
        v16 = &v15->tx;
        if ( !v15 )
          v16 = &v14->m_transform.m_translate.x;
        v17 = (float)(v20.y + v20.y) + v16[1];
        v18 = (float)(v20.z + v20.z) + v16[2];
        this->m_vTargetPos.x = (float)(v20.x + v20.x) + *v16;
        this->m_vTargetPos.y = v17;
        this->m_vTargetPos.z = v18;
        v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x28u);
        CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
          (CTaskComplexGoToPointAndStandStill *)v5,
          6,
          &this->m_vTargetPos,
          0.5,
          2.0,
          0,
          0);
        break;
      case 1210:
        v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
        CTaskComplexSignalAtPed::CTaskComplexSignalAtPed((CTaskComplexSignalAtPed *)v5, this->m_pDeadPed, -1, 0);
        break;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 203:
        v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 1000, 0, 0, 8.0);
        IKChainManager_c::LookAt(
          &g_ikChainMan,
          "TaskInvDeadPed",
          pPed,
          this->m_pDeadPed,
          1000,
          5,
          0,
          0,
          0.25,
          500,
          3,
          0);
        break;
      case 400:
        v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(
          (CTaskSimpleRunAnim *)v5,
          (const AssocGroupId)pPed->m_motionAnimGroup,
          ANIM_STD_ROADCROSS,
          4.0,
          0);
        break;
      case 900:
        v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x2Cu);
        CTaskSimpleGoToPoint::CTaskSimpleGoToPoint((CTaskSimpleGoToPoint *)v5, 4, &this->m_vStartPos, 0.5, 0, 0);
        break;
    }
  }
  return v5;
}

//----- (00546BD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDeadPed::CreateFirstSubTask(CTaskComplexInvestigateDeadPed *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v6; // d16
  CTaskSimpleStandStill *v7; // r6

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v6 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_vStartPos.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_vStartPos.x = v6;
  this->m_iLookTime = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 2000.0) + 5000;
  v7 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v7, 1000, 0, 0, 8.0);
  IKChainManager_c::LookAt(&g_ikChainMan, "TaskInvDeadPed", pPed, this->m_pDeadPed, 1000, 5, 0, 0, 0.25, 500, 3, 0);
  return v7;
}

//----- (00546C9C) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDeadPed::ControlSubTask(CTaskComplexInvestigateDeadPed *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  __int64 v6; // kr00_8
  CMatrix *m_pMat; // r1
  int v8; // r2
  CSimpleTransform *p_tx; // r3
  bool v10; // zf
  float32x2_t v11; // d8
  float *v12; // r1
  float x; // s18
  float y; // s2
  float v15; // s6
  RwReal v16; // s0
  CPed *m_pDeadPed; // r0
  CMatrix *v18; // r1
  CSimpleTransform *p_m_transform; // r2
  float v20; // s4
  float32x2_t v21; // d0
  float32x2_t v22; // d16
  unsigned __int64 v23; // d3
  char v24; // r2
  __int64 v25; // d16
  __int64 v26; // r0
  CVector v28; // [sp+Ch] [bp-2Ch] BYREF

  if ( this->m_pDeadPed )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 903 )
    {
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 400 )
        CPed::Say(pPed, 0xB5u, 0, 1.0, 0, 0, 0);
      return this->m_pSubTask;
    }
    if ( !this->m_timer.m_bIsActive
      || (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v4 = CTimer::m_snTimeInMilliseconds) : (v4 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v4, m_iStartTime = v4),
          m_iStartTime + this->m_timer.m_iDuration > v4) )
    {
      v6 = *(_QWORD *)&this->m_pSubTask;
      m_pMat = pPed->m_pMat;
      v8 = *(_DWORD *)(HIDWORD(v6) + 20);
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      v10 = m_pMat == 0;
      v11.n64_u64[0] = *(unsigned __int64 *)&this->m_vTargetPos.y;
      v12 = (float *)(v8 + 48);
      x = this->m_vTargetPos.x;
      if ( v10 )
        p_tx = &pPed->m_transform;
      y = p_tx->m_translate.y;
      if ( !v8 )
        v12 = (float *)(HIDWORD(v6) + 4);
      v15 = v12[1];
      v16 = p_tx->m_translate.x - *v12;
      v28.z = 0.0;
      v28.y = y - v15;
      v28.x = v16;
      CVector::Normalise(&v28);
      m_pDeadPed = this->m_pDeadPed;
      v18 = m_pDeadPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v18->tx;
      if ( !v18 )
        p_m_transform = &m_pDeadPed->m_transform;
      v20 = (float)(v28.x + v28.x) + p_m_transform->m_translate.x;
      v21.n64_u64[0] = vadd_f32(
                         vadd_f32(*(float32x2_t *)&v28.y, *(float32x2_t *)&v28.y),
                         *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
      v22.n64_u64[0] = vsub_f32(v21, v11).n64_u64[0];
      v23 = vmul_f32(v22, v22).n64_u64[0];
      if ( (float)((float)((float)((float)(v20 - x) * (float)(v20 - x)) + *(float *)&v23) + *((float *)&v23 + 1)) > 1.0 )
      {
        LODWORD(this->m_vTargetPos.y) = v21.n64_u32[0];
        this->m_vTargetPos.x = v20;
        LODWORD(this->m_vTargetPos.z) = v21.n64_u32[1];
        if ( *(float *)(v6 + 16) != v20 || *(float *)(v6 + 20) != v21.n64_f32[0] || *(float *)(v6 + 32) != 2.0 )
        {
          v24 = *(_BYTE *)(v6 + 36);
          v25 = *(_QWORD *)&this->m_vTargetPos.x;
          *(RwReal *)&v26 = this->m_vTargetPos.z;
          HIDWORD(v26) = 1056964608;
          *(_QWORD *)(v6 + 24) = v26;
          *(_DWORD *)(v6 + 32) = 0x40000000;
          *(_BYTE *)(v6 + 36) = v24 | 4;
          *(_QWORD *)(v6 + 16) = v25;
        }
      }
      return this->m_pSubTask;
    }
  }
  return 0;
}

//----- (00546E60) --------------------------------------------------------
void __fastcall CTaskComplexReactToGunAimedAt::CTaskComplexReactToGunAimedAt(
        CTaskComplexReactToGunAimedAt *this,
        CPed *pAggressorPed)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D480;
  this->m_pAggressorPed = pAggressorPed;
  if ( pAggressorPed )
    CEntity::RegisterReference(pAggressorPed, &this->m_pAggressorPed);
}
// 66D480: using guessed type void *;

//----- (00546E98) --------------------------------------------------------
void __fastcall CTaskComplexReactToGunAimedAt::~CTaskComplexReactToGunAimedAt(CTaskComplexReactToGunAimedAt *this)
{
  CPed *m_pAggressorPed; // r0
  CEntity **p_m_pAggressorPed; // r1

  p_m_pAggressorPed = &this->m_pAggressorPed;
  m_pAggressorPed = this->m_pAggressorPed;
  this->_vptr$CTask = (int (**)(void))&off_66D480;
  if ( m_pAggressorPed )
    CEntity::CleanUpOldReference(m_pAggressorPed, p_m_pAggressorPed);
  sub_18EDB4(this);
}
// 66D480: using guessed type void *off_66D480;

//----- (00546EC4) --------------------------------------------------------
void __fastcall CTaskComplexReactToGunAimedAt::~CTaskComplexReactToGunAimedAt(CTaskComplexReactToGunAimedAt *this)
{
  CPed *m_pAggressorPed; // r0
  CEntity **p_m_pAggressorPed; // r1
  void *v4; // r0

  p_m_pAggressorPed = &this->m_pAggressorPed;
  m_pAggressorPed = this->m_pAggressorPed;
  this->_vptr$CTask = (int (**)(void))&off_66D480;
  if ( m_pAggressorPed )
    CEntity::CleanUpOldReference(m_pAggressorPed, p_m_pAggressorPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 546EEC: variable 'v4' is possibly undefined
// 66D480: using guessed type void *off_66D480;

//----- (00546EF4) --------------------------------------------------------
CTask *__fastcall CTaskComplexReactToGunAimedAt::CreateNextSubTask(CTaskComplexReactToGunAimedAt *this, CPed *pPed)
{
  int v4; // r0
  int v5; // r1
  bool v6; // zf

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 < 704 )
  {
    switch ( v4 )
    {
      case 202:
        if ( pPed->m_pMyVehicle )
        {
          v5 = 704;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
            v5 = 902;
        }
        else
        {
          v5 = 902;
        }
        return CTaskComplexReactToGunAimedAt::CreateSubTask(this, v5, pPed);
      case 412:
        CPed::Say(pPed, 0x73u, 0, 1.0, 0, 0, 0);
        v5 = 911;
        break;
      case 413:
        v5 = 912;
        break;
      default:
        return 0;
    }
  }
  else if ( v4 > 910 )
  {
    v6 = v4 == 911;
    if ( v4 != 911 )
      v6 = v4 == 912;
    if ( !v6 )
      return 0;
    v5 = 1302;
  }
  else
  {
    v5 = 902;
    if ( v4 != 704 )
    {
      if ( v4 == 902 )
      {
        if ( LOBYTE(pPed->m_pPedStats->m_nStatFlags) >> 7 )
        {
          v5 = 412;
        }
        else
        {
          CPed::Say(pPed, 0x72u, 0, 1.0, 0, 0, 0);
          v5 = 413;
        }
        return CTaskComplexReactToGunAimedAt::CreateSubTask(this, v5, pPed);
      }
      return 0;
    }
  }
  return CTaskComplexReactToGunAimedAt::CreateSubTask(this, v5, pPed);
}

//----- (00546FC8) --------------------------------------------------------
CTask *__fastcall CTaskComplexReactToGunAimedAt::CreateSubTask(
        CTaskComplexReactToGunAimedAt *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskSimpleRunAnim *v5; // r4
  CPed *v6; // r0
  CMatrix *v7; // r1
  CMatrix *v8; // r2
  CSimpleTransform *p_m_transform; // r3
  float *v10; // r1
  float RadianAngleBetweenPoints; // r0
  float v12; // r5
  unsigned __int16 v13; // r0
  void **v14; // r0
  CPed *m_pAggressorPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v17; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  UINT8 NodeHeadingFromVector; // r6
  __int64 v21; // r0
  int v22; // r6

  v5 = 0;
  if ( iSubTaskType < 704 )
  {
    switch ( iSubTaskType )
    {
      case 202:
        if ( pPed->m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
          v22 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) + 1000;
        else
          v22 = 0;
        v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x18u);
        CTaskSimple::CTaskSimple(v5);
        LOWORD(v5->m_animGroup) = 0;
        v14 = &`vtable for'CTaskSimplePause;
        v5->m_animID = v22;
        v5->m_pAnim = 0;
        *((_DWORD *)&v5->CTaskSimpleAnim + 3) = 0;
        break;
      case 412:
        v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, ANIM_STD_PED, ANIM_STD_HANDSCOWER, 4.0, 412, "Cower", 0);
        v14 = &`vtable for'CTaskSimpleCower;
        break;
      case 413:
        v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x34u);
        v13 = rand();
        CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
          (CTaskSimpleRunTimedAnim *)v5,
          ANIM_STD_PED,
          ANIM_STD_HANDSUP,
          4.0,
          -4.0,
          (int)(float)((float)((float)v13 * 0.000015259) * 2000.0) + 3000,
          413,
          "HandsUp",
          0);
        v14 = &`vtable for'CTaskSimpleHandsUp;
        break;
      default:
        return v5;
    }
    v5->_vptr$CTask = (int (**)(void))((char *)*v14 + 8);
    return v5;
  }
  if ( iSubTaskType > 910 )
  {
    if ( iSubTaskType == 911 )
    {
      v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x40u);
      CTaskComplexSmartFleeEntity::CTaskComplexSmartFleeEntity(
        (CTaskComplexSmartFleeEntity *)v5,
        this->m_pAggressorPed,
        0,
        60.0,
        (const int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
        (const int)&elf_hash_bucket[187],
        1.0);
    }
    else if ( iSubTaskType == 912 )
    {
      m_pAggressorPed = this->m_pAggressorPed;
      m_pMat = pPed->m_pMat;
      v17 = m_pAggressorPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      p_x = &v17->tx;
      if ( !v17 )
        p_x = &m_pAggressorPed->m_transform.m_translate.x;
      NodeHeadingFromVector = CGeneral::GetNodeHeadingFromVector(
                                p_tx->m_translate.x - *p_x,
                                p_tx->m_translate.y - p_x[1]);
      v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x38u);
      CTaskComplexWander::CTaskComplexWander((CTaskComplexWander *)v5, 4, NodeHeadingFromVector, 1, 0.5);
      LOWORD(v5[1].m_animGroup) = 0;
      v5[1].m_animID = ANIM_STD_WALK;
      v5[1].m_pAnim = 0;
      *((_DWORD *)&v5[1].CTaskSimpleAnim + 3) = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66C58C;
      v21 = CTimer::m_snTimeInMilliseconds | 0x271000000000LL;
      this->m_timer.m_bIsActive = 1;
      *(_QWORD *)&this->m_timer.m_iStartTime = v21;
    }
  }
  else if ( iSubTaskType == 704 )
  {
    v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x34u);
    CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
  }
  else if ( iSubTaskType == 902 )
  {
    v6 = this->m_pAggressorPed;
    v7 = pPed->m_pMat;
    v8 = v6->m_pMat;
    p_m_transform = (CSimpleTransform *)&v7->tx;
    if ( !v7 )
      p_m_transform = &pPed->m_transform;
    v10 = &v8->tx;
    if ( !v8 )
      v10 = &v6->m_transform.m_translate.x;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 *v10 - p_m_transform->m_translate.x,
                                 v10[1] - p_m_transform->m_translate.y,
                                 0.0,
                                 0.0);
    v12 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    pPed->m_fDesiredHeading = v12;
    v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading((CTaskSimpleAchieveHeading *)v5, v12, 0.5, 0.2);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66C58C: using guessed type void *off_66C58C;
// 676378: using guessed type void *`vtable for'CTaskSimpleCower;
// 676D34: using guessed type void *`vtable for'CTaskSimpleHandsUp;
// 677A94: using guessed type void *`vtable for'CTaskComplexWanderStandard;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (005472B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexReactToGunAimedAt::CreateFirstSubTask(CTaskComplexReactToGunAimedAt *this, CPed *pPed)
{
  CTask *v2; // r5
  CTaskSimple *v3; // r0
  CTask *result; // r0

  if ( pPed->m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v2 = (CTask *)((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) + 1000);
  else
    v2 = 0;
  v3 = (CTaskSimple *)CTask::operator new(0x18u);
  CTaskSimple::CTaskSimple(v3);
  LOWORD(result[2]._vptr$CTask) = 0;
  result[2].m_pParent = v2;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_665750;
  return result;
}
// 5472FE: variable 'result' is possibly undefined
// 665750: using guessed type void *off_665750;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (0054731C) --------------------------------------------------------
CTask *__fastcall CTaskComplexReactToGunAimedAt::ControlSubTask(CTaskComplexReactToGunAimedAt *this, CPed *pPed)
{
  CTask *m_pSubTask; // r4
  unsigned int v5; // r0
  int m_iStartTime; // r1

  if ( !this->m_pAggressorPed )
    return 0;
  m_pSubTask = this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 912 && this->m_timer.m_bIsActive )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      v5 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v5;
      m_iStartTime = v5;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v5 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_timer.m_iDuration <= v5
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) )
    {
      return 0;
    }
  }
  return m_pSubTask;
}

//----- (00547390) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBackup::CTaskComplexWaitForBackup(
        CTaskComplexWaitForBackup *this,
        CPed *pAggressorPed,
        CPed *pBackupPed,
        const float fWaitDistance)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fWaitDistance = fWaitDistance;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66D4BC;
  this->m_pBackupPed = pBackupPed;
  this->m_pAggressorPed = pAggressorPed;
  if ( pAggressorPed )
  {
    CEntity::RegisterReference(pAggressorPed, &this->m_pAggressorPed);
    pBackupPed = this->m_pBackupPed;
  }
  if ( pBackupPed )
    CEntity::RegisterReference(pBackupPed, &this->m_pBackupPed);
}
// 66D4BC: using guessed type void *off_66D4BC;

//----- (005473EC) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBackup::~CTaskComplexWaitForBackup(CTaskComplexWaitForBackup *this)
{
  CPed *m_pAggressorPed; // r0
  CEntity **p_m_pAggressorPed; // r1
  CPed *m_pBackupPed; // r0

  p_m_pAggressorPed = &this->m_pAggressorPed;
  m_pAggressorPed = this->m_pAggressorPed;
  this->_vptr$CTask = (int (**)(void))&off_66D4BC;
  if ( m_pAggressorPed )
    CEntity::CleanUpOldReference(m_pAggressorPed, p_m_pAggressorPed);
  m_pBackupPed = this->m_pBackupPed;
  if ( m_pBackupPed )
    CEntity::CleanUpOldReference(m_pBackupPed, &this->m_pBackupPed);
  sub_18EDB4(this);
}
// 66D4BC: using guessed type void *;

//----- (00547428) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBackup::~CTaskComplexWaitForBackup(CTaskComplexWaitForBackup *this)
{
  CPed *m_pAggressorPed; // r0
  CEntity **p_m_pAggressorPed; // r1
  CPed *m_pBackupPed; // r0
  void *v5; // r0

  p_m_pAggressorPed = &this->m_pAggressorPed;
  m_pAggressorPed = this->m_pAggressorPed;
  this->_vptr$CTask = (int (**)(void))&off_66D4BC;
  if ( m_pAggressorPed )
    CEntity::CleanUpOldReference(m_pAggressorPed, p_m_pAggressorPed);
  m_pBackupPed = this->m_pBackupPed;
  if ( m_pBackupPed )
    CEntity::CleanUpOldReference(m_pBackupPed, &this->m_pBackupPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 54745E: variable 'v5' is possibly undefined
// 66D4BC: using guessed type void *off_66D4BC;

//----- (00547468) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBackup::CreateNextSubTask(CTaskComplexWaitForBackup *this, CPed *pPed)
{
  int v4; // r1
  CTask *result; // r0
  CPed *v6; // r0
  CMatrix *v7; // r1
  CMatrix *v8; // r2
  CSimpleTransform *v9; // r3
  float *p_x; // r1
  float x; // s0
  float y; // s2
  CPed *m_pBackupPed; // r0
  unsigned int v14; // r0
  int m_iStartTime; // r1
  CVehicle *m_pMyVehicle; // r0
  bool v17; // zf
  CPed *m_pAggressorPed; // r0
  CMatrix *v19; // r1
  CMatrix *v20; // r2
  CSimpleTransform *v21; // r3
  float RadianAngleBetweenPoints; // r0
  float v23; // r5
  CTaskSimpleAchieveHeading *v24; // r0
  CTaskSimpleGunControl *v25; // r0
  CTaskComplexLeaveCar *v26; // r0
  CPed *v27; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v29; // r2
  CSimpleTransform *p_tx; // r3
  unsigned __int64 *p_m_transform; // r1
  float32x2_t v32; // d17
  int v33; // r1
  float32x2_t v34; // d16
  unsigned __int64 v35; // d0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  result = 0;
  if ( v4 > 901 )
  {
    if ( v4 == 902 )
    {
      if ( CWeaponInfo::GetWeaponInfo(pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_eFireType == FIRETYPE_INSTANT_HIT )
      {
        v25 = (CTaskSimpleGunControl *)CTask::operator new(0x3Cu);
        CTaskSimpleGunControl::CTaskSimpleGunControl(v25, this->m_pAggressorPed, 0, 0, 1, 100, 2000);
        return result;
      }
    }
    else
    {
      if ( v4 != 1020 )
        return result;
      m_pBackupPed = this->m_pBackupPed;
      if ( m_pBackupPed && CPed::IsAlive(m_pBackupPed) )
      {
        if ( !this->m_timer.m_bIsActive
          || (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime,
                                             v14 = CTimer::m_snTimeInMilliseconds) : (v14 = CTimer::m_snTimeInMilliseconds,
                                                                                      this->m_timer.m_bIsStopped = 0,
                                                                                      this->m_timer.m_iStartTime = v14,
                                                                                      m_iStartTime = v14),
              m_iStartTime + this->m_timer.m_iDuration > v14) )
        {
          v27 = this->m_pBackupPed;
          m_pMat = pPed->m_pMat;
          v29 = v27->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          p_m_transform = (unsigned __int64 *)&v29->tx;
          if ( !v29 )
            p_m_transform = (unsigned __int64 *)&v27->m_transform;
          v32.n64_u64[0] = *p_m_transform;
          v33 = 902;
          v34.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, v32).n64_u64[0];
          v35 = vmul_f32(v34, v34).n64_u64[0];
          if ( (float)((float)(*(float *)&v35 + *((float *)&v35 + 1)) + 0.0) < (float)((float)this->m_fWaitDistance
                                                                                     * (float)this->m_fWaitDistance) )
            v33 = 1302;
          return CTaskComplexWaitForBackup::CreateSubTask(this, v33, pPed);
        }
      }
    }
    return 0;
  }
  if ( v4 == 202 )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    v17 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
      v17 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( !v17 )
    {
      v26 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v26, pPed->m_pMyVehicle, 0, 0, 1, 0);
      return result;
    }
    m_pAggressorPed = this->m_pAggressorPed;
    v19 = pPed->m_pMat;
    v20 = m_pAggressorPed->m_pMat;
    v21 = (CSimpleTransform *)&v19->tx;
    if ( !v19 )
      v21 = &pPed->m_transform;
    p_x = &v20->tx;
    x = v21->m_translate.x;
    y = v21->m_translate.y;
    if ( !v20 )
      p_x = &m_pAggressorPed->m_transform.m_translate.x;
    goto LABEL_24;
  }
  if ( v4 == 704 )
  {
    v6 = this->m_pAggressorPed;
    v7 = pPed->m_pMat;
    v8 = v6->m_pMat;
    v9 = (CSimpleTransform *)&v7->tx;
    if ( !v7 )
      v9 = &pPed->m_transform;
    p_x = &v8->tx;
    x = v9->m_translate.x;
    y = v9->m_translate.y;
    if ( !v8 )
      p_x = &v6->m_transform.m_translate.x;
LABEL_24:
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(*p_x - x, p_x[1] - y, 0.0, 0.0);
    v23 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    pPed->m_fDesiredHeading = v23;
    v24 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v24, v23, 0.5, 0.2);
  }
  return result;
}

//----- (005476A0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBackup::CreateSubTask(
        CTaskComplexWaitForBackup *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskComplexLeaveCar *v6; // r0
  CTaskSimpleGunControl *v7; // r0
  CTask *v8; // r4
  CPed *m_pAggressorPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v11; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float RadianAngleBetweenPoints; // r0
  float v15; // r5
  CTaskSimpleAchieveHeading *v16; // r0
  CTaskSimple *v17; // r0

  result = 0;
  if ( iSubTaskType > 901 )
  {
    if ( iSubTaskType == 902 )
    {
      m_pAggressorPed = this->m_pAggressorPed;
      m_pMat = pPed->m_pMat;
      v11 = m_pAggressorPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      p_x = &v11->tx;
      if ( !v11 )
        p_x = &m_pAggressorPed->m_transform.m_translate.x;
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   *p_x - p_tx->m_translate.x,
                                   p_x[1] - p_tx->m_translate.y,
                                   0.0,
                                   0.0);
      v15 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      pPed->m_fDesiredHeading = v15;
      v16 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
      CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v16, v15, 0.5, 0.2);
    }
    else if ( iSubTaskType == 1020 )
    {
      v7 = (CTaskSimpleGunControl *)CTask::operator new(0x3Cu);
      CTaskSimpleGunControl::CTaskSimpleGunControl(v7, this->m_pAggressorPed, 0, 0, 1, 100, 2000);
    }
  }
  else if ( iSubTaskType == 202 )
  {
    if ( pPed->m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v8 = (CTask *)((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) + 1000);
    else
      v8 = 0;
    v17 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v17);
    LOWORD(result[2]._vptr$CTask) = 0;
    result[2].m_pParent = v8;
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    result->_vptr$CTask = (int (**)(void))&off_665750;
  }
  else if ( iSubTaskType == 704 )
  {
    v6 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
    CTaskComplexLeaveCar::CTaskComplexLeaveCar(v6, pPed->m_pMyVehicle, 0, 0, 1, 0);
  }
  return result;
}
// 5477C2: variable 'result' is possibly undefined
// 665750: using guessed type void *off_665750;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (005477EC) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBackup::CreateFirstSubTask(CTaskComplexWaitForBackup *this, CPed *pPed)
{
  __int64 v2; // r2
  CTask *v3; // r5
  CTaskSimple *v4; // r0
  CTask *result; // r0

  v2 = CTimer::m_snTimeInMilliseconds | 0x4E2000000000LL;
  this->m_timer.m_bIsActive = 1;
  *(_QWORD *)&this->m_timer.m_iStartTime = v2;
  if ( pPed->m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v3 = (CTask *)((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) + 1000);
  else
    v3 = 0;
  v4 = (CTaskSimple *)CTask::operator new(0x18u);
  CTaskSimple::CTaskSimple(v4);
  LOWORD(result[2]._vptr$CTask) = 0;
  result[2].m_pParent = v3;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_665750;
  return result;
}
// 547850: variable 'result' is possibly undefined
// 665750: using guessed type void *off_665750;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (00547874) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBackup::ControlSubTask(CTaskComplexWaitForBackup *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (00547878) --------------------------------------------------------
void __fastcall CTaskComplexExtinguishFires::CTaskComplexExtinguishFires(CTaskComplexExtinguishFires *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  v1[3] = 0;
  *v1 = &off_66D4F8;
}
// 547884: variable 'v1' is possibly undefined
// 66D4F8: using guessed type void *;

//----- (00547898) --------------------------------------------------------
void __fastcall CTaskComplexExtinguishFires::~CTaskComplexExtinguishFires(CTaskComplexExtinguishFires *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 5478A4: variable 'v1' is possibly undefined

//----- (005478A8) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFires::CreateNextSubTask(CTaskComplexExtinguishFires *this, CPed *pPed)
{
  int v4; // r0
  bool v5; // zf
  CSimpleTransform *v6; // r4
  CMatrix *v7; // r2
  CSimpleTransform *v8; // r1
  CFire *v9; // r6
  float32x2_t *v10; // r0
  CMatrix *v11; // r1
  float32x2_t v12; // d16
  unsigned __int64 v13; // d1
  CTaskSimpleGunControl *v14; // r0
  CTask *result; // r0
  CSimpleTransform *p_m_transform; // r4
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CFire *v19; // r6
  float32x2_t *NearestFire; // r0
  CMatrix *v21; // r1
  float32x2_t v22; // d16
  unsigned __int64 v23; // d1
  CTaskSimpleStandStill *v24; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = v4 == 203;
  if ( v4 != 203 )
    v5 = v4 == 1020;
  if ( v5 )
  {
    p_m_transform = &pPed->m_transform;
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    v19 = 0;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    NearestFire = (float32x2_t *)CFireManager::FindNearestFire(&gFireManager, &p_tx->m_translate, 0, 0);
    if ( NearestFire )
    {
      v21 = pPed->m_pMat;
      if ( v21 )
        p_m_transform = (CSimpleTransform *)&v21->tx;
      v22.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, NearestFire[1]).n64_u64[0];
      v23 = vmul_f32(v22, v22).n64_u64[0];
      if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - NearestFire->n64_f32[1])
                                 * (float)(p_m_transform->m_translate.x - NearestFire->n64_f32[1]))
                         + *(float *)&v23)
                 + *((float *)&v23 + 1)) > (float)(20.0 * 20.0) )
        NearestFire = 0;
      v19 = (CFire *)NearestFire;
    }
    if ( v19 == this->m_pFire )
    {
      CFire::Extinguish(v19);
      this->m_pFire = 0;
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexExtinguishFires *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  }
  if ( v4 != 903 )
    return 0;
  v6 = &pPed->m_transform;
  v7 = pPed->m_pMat;
  v8 = &pPed->m_transform;
  v9 = 0;
  if ( v7 )
    v8 = (CSimpleTransform *)&v7->tx;
  v10 = (float32x2_t *)CFireManager::FindNearestFire(&gFireManager, &v8->m_translate, 0, 0);
  if ( v10 )
  {
    v11 = pPed->m_pMat;
    if ( v11 )
      v6 = (CSimpleTransform *)&v11->tx;
    v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&v6->m_translate.y, v10[1]).n64_u64[0];
    v13 = vmul_f32(v12, v12).n64_u64[0];
    if ( (float)((float)((float)((float)(v6->m_translate.x - v10->n64_f32[1])
                               * (float)(v6->m_translate.x - v10->n64_f32[1]))
                       + *(float *)&v13)
               + *((float *)&v13 + 1)) > (float)(20.0 * 20.0) )
      v10 = 0;
    v9 = (CFire *)v10;
  }
  if ( this->m_pFire != v9 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexExtinguishFires *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  if ( pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_EXTINGUISHER )
  {
    v14 = (CTaskSimpleGunControl *)CTask::operator new(0x3Cu);
    CTaskSimpleGunControl::CTaskSimpleGunControl(v14, 0, &v9->m_vLocation, 0, 5, 1, -1);
  }
  else
  {
    v24 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v24, 2000, 0, 0, 8.0);
  }
  return result;
}
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (00547A50) --------------------------------------------------------
CFire *__fastcall CTaskComplexExtinguishFires::GetNearestFire(const CTaskComplexExtinguishFires *this, CPed *pPed)
{
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  CFire *v6; // r5
  CFire *NearestFire; // r0
  CMatrix *v8; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v6 = 0;
  NearestFire = CFireManager::FindNearestFire(&gFireManager, &p_tx->m_translate, 0, 0);
  if ( NearestFire )
  {
    v8 = pPed->m_pMat;
    if ( v8 )
      p_m_transform = (CSimpleTransform *)&v8->tx;
    v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&NearestFire->m_vLocation.y).n64_u64[0];
    v10 = vmul_f32(v9, v9).n64_u64[0];
    if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x)
                               * (float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x))
                       + *(float *)&v10)
               + *((float *)&v10 + 1)) > (float)(20.0 * 20.0) )
      return 0;
    return NearestFire;
  }
  return v6;
}
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (00547AD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFires::CreateFirstSubTask(CTaskComplexExtinguishFires *this, CPed *pPed)
{
  CSimpleTransform *p_m_transform; // r4
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CTaskComplexGoToPointAndStandStill *v7; // r9
  CFire *NearestFire; // r6
  CMatrix *v9; // r0
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1

  p_m_transform = &pPed->m_transform;
  m_pMat = pPed->m_pMat;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v7 = 0;
  NearestFire = CFireManager::FindNearestFire(&gFireManager, &p_tx->m_translate, 0, 0);
  if ( !NearestFire )
    goto LABEL_7;
  v9 = pPed->m_pMat;
  if ( v9 )
    p_m_transform = (CSimpleTransform *)&v9->tx;
  v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&NearestFire->m_vLocation.y).n64_u64[0];
  v11 = vmul_f32(v10, v10).n64_u64[0];
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x)
                             * (float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x))
                     + *(float *)&v11)
             + *((float *)&v11 + 1)) <= (float)(20.0 * 20.0) )
  {
    this->m_pFire = NearestFire;
    v7 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
    CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
      v7,
      6,
      &NearestFire->m_vLocation,
      1.5,
      2.0,
      0,
      0);
  }
  else
  {
LABEL_7:
    this->m_pFire = 0;
  }
  return v7;
}
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (00547BA0) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFires::ControlSubTask(CTaskComplexExtinguishFires *this, CPed *pPed)
{
  CSimpleTransform *p_m_transform; // r4
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CFire *v7; // r5
  float32x2_t *NearestFire; // r0
  CMatrix *v9; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1
  CTask *m_pSubTask; // r6
  CSimpleTransform *v14; // r4
  CMatrix *v15; // r2
  CSimpleTransform *v16; // r1
  CFire *v17; // r0
  CMatrix *v18; // r1
  float32x2_t v19; // d16
  unsigned __int64 v20; // d1
  CTask *v21; // r1
  CVector *p_m_vLocation; // r0
  char m_pParent; // r2
  CTask v24; // d16

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1020 )
  {
    p_m_transform = &pPed->m_transform;
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    v7 = 0;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    NearestFire = (float32x2_t *)CFireManager::FindNearestFire(&gFireManager, &p_tx->m_translate, 0, 0);
    if ( NearestFire )
    {
      v9 = pPed->m_pMat;
      if ( v9 )
        p_m_transform = (CSimpleTransform *)&v9->tx;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, NearestFire[1]).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - NearestFire->n64_f32[1])
                                 * (float)(p_m_transform->m_translate.x - NearestFire->n64_f32[1]))
                         + *(float *)&v11)
                 + *((float *)&v11 + 1)) > (float)(20.0 * 20.0) )
        NearestFire = 0;
      v7 = (CFire *)NearestFire;
    }
    m_pSubTask = this->m_pSubTask;
    if ( v7 == this->m_pFire )
      return m_pSubTask;
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 1, 0) == 1 )
      return (CTask *)(*((int (__fastcall **)(CTaskComplexExtinguishFires *, CPed *))this->_vptr$CTask + 11))(
                        this,
                        pPed);
    return this->m_pSubTask;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 903 )
    return this->m_pSubTask;
  v14 = &pPed->m_transform;
  v15 = pPed->m_pMat;
  v16 = &pPed->m_transform;
  m_pSubTask = 0;
  if ( v15 )
    v16 = (CSimpleTransform *)&v15->tx;
  v17 = CFireManager::FindNearestFire(&gFireManager, &v16->m_translate, 0, 0);
  if ( !v17 )
    return m_pSubTask;
  v18 = pPed->m_pMat;
  if ( v18 )
    v14 = (CSimpleTransform *)&v18->tx;
  v19.n64_u64[0] = vsub_f32(*(float32x2_t *)&v14->m_translate.y, *(float32x2_t *)&v17->m_vLocation.y).n64_u64[0];
  v20 = vmul_f32(v19, v19).n64_u64[0];
  if ( (float)((float)((float)((float)(v14->m_translate.x - v17->m_vLocation.x)
                             * (float)(v14->m_translate.x - v17->m_vLocation.x))
                     + *(float *)&v20)
             + *((float *)&v20 + 1)) <= (float)(20.0 * 20.0) )
  {
    if ( this->m_pFire != v17 )
    {
      v21 = this->m_pSubTask;
      this->m_pFire = v17;
      if ( *(float *)&v21[2]._vptr$CTask != v17->m_vLocation.x
        || *(float *)&v21[2].m_pParent != v17->m_vLocation.y
        || *(float *)&v21[3]._vptr$CTask != v17->m_vLocation.z
        || *(float *)&v21[4]._vptr$CTask != 2.0 )
      {
        p_m_vLocation = &v17->m_vLocation;
        m_pParent = (char)v21[4].m_pParent;
        v24 = *(CTask *)&p_m_vLocation->x;
        v21[3]._vptr$CTask = (int (**)(void))LODWORD(p_m_vLocation->z);
        v21[3].m_pParent = (CTask *)1069547520;
        v21[4]._vptr$CTask = (int (**)(void))0x40000000;
        LOBYTE(v21[4].m_pParent) = m_pParent | 4;
        v21[2] = v24;
      }
    }
    return this->m_pSubTask;
  }
  return 0;
}
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (00547D94) --------------------------------------------------------
CTask *__fastcall CTaskComplexInvestigateDeadPed::Clone(const CTaskComplexInvestigateDeadPed *this)
{
  char *v2; // r4
  CPed *m_pDeadPed; // r5

  v2 = (char *)CTask::operator new(0x3Cu);
  m_pDeadPed = this->m_pDeadPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 44) = 0LL;
  *(_QWORD *)(v2 + 52) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *(_QWORD *)(v2 + 36) = 0LL;
  *((_WORD *)v2 + 12) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 5) = 0;
  *(_DWORD *)v2 = &off_66D444;
  *((_DWORD *)v2 + 3) = m_pDeadPed;
  if ( m_pDeadPed )
    CEntity::RegisterReference(m_pDeadPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66D444: using guessed type void *off_66D444;

//----- (00547DEC) --------------------------------------------------------
int __fastcall CTaskComplexInvestigateDeadPed::GetTaskType(const CTaskComplexInvestigateDeadPed *this)
{
  return 600;
}

//----- (00547DF4) --------------------------------------------------------
void __fastcall CTaskComplexInvestigateDeadPed::Serialize(CTaskComplexInvestigateDeadPed *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pDeadPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexInvestigateDeadPed *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexInvestigateDeadPed *))this->_vptr$CTask + 5))(this) == 600 )
  {
    m_pDeadPed = this->m_pDeadPed;
    if ( m_pDeadPed )
    {
      v5 = GettPoolPedRef(m_pDeadPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexInvestigateDeadPed *))this->_vptr$CTask + 5))(this);
    sub_1941C4(600, v8);
  }
}

//----- (00547EC4) --------------------------------------------------------
CTask *__fastcall CTaskComplexReactToGunAimedAt::Clone(const CTaskComplexReactToGunAimedAt *this)
{
  void *v2; // r4
  CPed *m_pAggressorPed; // r5

  v2 = CTask::operator new(0x1Cu);
  m_pAggressorPed = this->m_pAggressorPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 12) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 5) = 0;
  *(_DWORD *)v2 = &off_66D480;
  *((_DWORD *)v2 + 3) = m_pAggressorPed;
  if ( m_pAggressorPed )
    CEntity::RegisterReference(m_pAggressorPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66D480: using guessed type void *off_66D480;

//----- (00547F04) --------------------------------------------------------
int __fastcall CTaskComplexReactToGunAimedAt::GetTaskType(const CTaskComplexReactToGunAimedAt *this)
{
  return 601;
}

//----- (00547F0C) --------------------------------------------------------
void __fastcall CTaskComplexReactToGunAimedAt::Serialize(CTaskComplexReactToGunAimedAt *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pAggressorPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexReactToGunAimedAt *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexReactToGunAimedAt *))this->_vptr$CTask + 5))(this) == 601 )
  {
    m_pAggressorPed = this->m_pAggressorPed;
    if ( m_pAggressorPed )
    {
      v5 = GettPoolPedRef(m_pAggressorPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexReactToGunAimedAt *))this->_vptr$CTask + 5))(this);
    sub_1941C4(601, v8);
  }
}

//----- (00547FE0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBackup::Clone(const CTaskComplexWaitForBackup *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  CPed *m_pBackupPed; // r5

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_fWaitDistance;
  v4 = v2;
  m_pBackupPed = this->m_pBackupPed;
  CTaskComplex::CTaskComplex(v2);
  v4[1]._vptr$CTask = (int (**)(void))v3;
  LOWORD(v4[2].m_pSubTask) = 0;
  v4[2]._vptr$CTask = 0;
  v4[2].m_pParent = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66D4BC;
  v4[1].m_pSubTask = (CTask *)m_pBackupPed;
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  if ( HIDWORD(v3) )
  {
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)&v4[1].m_pParent);
    m_pBackupPed = (CPed *)v4[1].m_pSubTask;
  }
  if ( m_pBackupPed )
    CEntity::RegisterReference(m_pBackupPed, (CEntity **)&v4[1].m_pSubTask);
  return v4;
}
// 66D4BC: using guessed type void *off_66D4BC;

//----- (00548044) --------------------------------------------------------
int __fastcall CTaskComplexWaitForBackup::GetTaskType(const CTaskComplexWaitForBackup *this)
{
  return 602;
}

//----- (0054804C) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBackup::Serialize(CTaskComplexWaitForBackup *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pAggressorPed; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  CPed *m_pBackupPed; // r0
  int v11; // r5
  _DWORD *v12; // r6
  void *v13; // r0
  _DWORD *v14; // r5
  float m_fWaitDistance; // r5
  float *v16; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexWaitForBackup *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWaitForBackup *))this->_vptr$CTask + 5))(this) == 602 )
  {
    m_pAggressorPed = this->m_pAggressorPed;
    if ( m_pAggressorPed )
    {
      v5 = GettPoolPedRef(m_pAggressorPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    m_pBackupPed = this->m_pBackupPed;
    if ( m_pBackupPed )
    {
      v11 = GettPoolPedRef(m_pBackupPed);
      if ( UseDataFence )
        AddDataFence();
      v12 = malloc(4u);
      *v12 = v11;
      CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
      v13 = v12;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v14 = malloc(4u);
      *v14 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      v13 = v14;
    }
    free(v13);
    m_fWaitDistance = this->m_fWaitDistance;
    if ( UseDataFence )
      AddDataFence();
    v16 = (float *)malloc(4u);
    *v16 = m_fWaitDistance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
    j_free(v16);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexWaitForBackup *))this->_vptr$CTask + 5))(this);
    sub_1941C4(602, v8);
  }
}

//----- (005481AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFires::Clone(const CTaskComplexExtinguishFires *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0x10u);
  CTaskComplex::CTaskComplex(v1);
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66D4F8;
  return result;
}
// 5481BE: variable 'result' is possibly undefined
// 66D4F8: using guessed type void *off_66D4F8;

//----- (005481D0) --------------------------------------------------------
int __fastcall CTaskComplexExtinguishFires::GetTaskType(const CTaskComplexExtinguishFires *this)
{
  return 604;
}

//----- (005481D8) --------------------------------------------------------
void __fastcall CTaskComplexExtinguishFires::Serialize(CTaskComplexExtinguishFires *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexExtinguishFires *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexExtinguishFires *))this->_vptr$CTask + 5))(this) != 604 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexExtinguishFires *))this->_vptr$CTask + 5))(this);
    sub_1941C4(604, v4);
  }
}

//----- (00548244) --------------------------------------------------------
uint8 __fastcall CTaskCategories::ComputeTaskCategory(const CTask *pTask)
{
  int v2; // r5
  int v3; // r0
  unsigned int v4; // r2
  uint8 v5; // r5

  v2 = (*((int (__fastcall **)(const CTask *))pTask->_vptr$CTask + 5))(pTask);
  v3 = (*((int (__fastcall **)(const CTask *))pTask->_vptr$CTask + 5))(pTask);
  v4 = v2 - 1019;
  v5 = 1;
  if ( v4 < 3 )
    v5 = 4;
  if ( (unsigned int)(v3 - 1019) < 3 )
    v5 = 2;
  if ( (unsigned int)((*((int (__fastcall **)(const CTask *))pTask->_vptr$CTask + 5))(pTask) - 1019) < 3 )
    return 4;
  return v5;
}

//----- (00548288) --------------------------------------------------------
void __fastcall CTaskCategories::IsKillPedTask(const CTask *pTask, bool *bIsKillPedTask, bool *bIsKillPlayerTask)
{
  *bIsKillPedTask = 0;
  *bIsKillPlayerTask = 0;
  if ( (unsigned int)((*((int (__fastcall **)(const CTask *))pTask->_vptr$CTask + 5))(pTask) - 1019) <= 2 )
    *bIsKillPedTask = 1;
}

//----- (005482A8) --------------------------------------------------------
void __fastcall CTaskCategories::IsFollowPedTask(const CTask *pTask, bool *bIsFollowPedTask, bool *bIsFollowPlayerTask)
{
  *bIsFollowPedTask = 0;
  *bIsFollowPlayerTask = 0;
}

//----- (005482B0) --------------------------------------------------------
void __fastcall CTaskCategories::IsFleePedTask(const CTask *pTask, bool *bIsFleePedTask, bool *bIsFleePlayerTask)
{
  int v6; // r0
  bool v7; // zf
  CTask *m_pParent; // r0

  *bIsFleePedTask = 0;
  *bIsFleePlayerTask = 0;
  v6 = (*((int (__fastcall **)(const CTask *))pTask->_vptr$CTask + 5))(pTask);
  v7 = v6 == 911;
  if ( v6 != 911 )
    v7 = v6 == 909;
  if ( v7 )
  {
    m_pParent = pTask[1].m_pParent;
    if ( m_pParent )
    {
      if ( (BYTE2(m_pParent[7]._vptr$CTask) & 7) == 3 )
      {
        *bIsFleePedTask = 1;
        if ( CPed::IsPlayer((const CPed *)m_pParent) )
          *bIsFleePlayerTask = 1;
      }
    }
  }
}

//----- (00548300) --------------------------------------------------------
void __fastcall CPedList::Empty(CPedList *this)
{
  CPed **v1; // r0

  *(_QWORD *)&this->m_aMembers[26] = 0LL;
  *(_QWORD *)&this->m_aMembers[28] = 0LL;
  *(_QWORD *)&this->m_aMembers[23] = 0LL;
  *(_QWORD *)&this->m_aMembers[25] = 0LL;
  *(_QWORD *)&this->m_aMembers[19] = 0LL;
  *(_QWORD *)&this->m_aMembers[21] = 0LL;
  *(_QWORD *)&this->m_aMembers[15] = 0LL;
  *(_QWORD *)&this->m_aMembers[17] = 0LL;
  *(_QWORD *)&this->m_aMembers[11] = 0LL;
  *(_QWORD *)&this->m_aMembers[13] = 0LL;
  *(_QWORD *)&this->m_aMembers[7] = 0LL;
  *(_QWORD *)&this->m_aMembers[9] = 0LL;
  *(_QWORD *)&this->m_nMembers = 0LL;
  *(_QWORD *)&this->m_aMembers[1] = 0LL;
  v1 = &this->m_aMembers[3];
  *(_QWORD *)v1 = 0LL;
  *((_QWORD *)v1 + 1) = 0LL;
}

//----- (0054833E) --------------------------------------------------------
void __fastcall CPedList::BuildListFromGroup_NoLeader(CPedList *this, CPedGroupMembership *pGroupMemberShip)
{
  int m_nMembers; // r1

  this->m_nMembers = 0;
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 0) )
    this->m_aMembers[this->m_nMembers++] = CPedGroupMembership::GetMember(pGroupMemberShip, 0);
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 1) )
    this->m_aMembers[this->m_nMembers++] = CPedGroupMembership::GetMember(pGroupMemberShip, 1);
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 2) )
    this->m_aMembers[this->m_nMembers++] = CPedGroupMembership::GetMember(pGroupMemberShip, 2);
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 3) )
    this->m_aMembers[this->m_nMembers++] = CPedGroupMembership::GetMember(pGroupMemberShip, 3);
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 4) )
    this->m_aMembers[this->m_nMembers++] = CPedGroupMembership::GetMember(pGroupMemberShip, 4);
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 5) )
    this->m_aMembers[this->m_nMembers++] = CPedGroupMembership::GetMember(pGroupMemberShip, 5);
  if ( CPedGroupMembership::GetMember(pGroupMemberShip, 6) )
  {
    this->m_aMembers[this->m_nMembers] = CPedGroupMembership::GetMember(pGroupMemberShip, 6);
    m_nMembers = this->m_nMembers + 1;
    this->m_nMembers = m_nMembers;
  }
  else
  {
    m_nMembers = this->m_nMembers;
  }
  if ( m_nMembers < 30 )
    memset(&this->m_aMembers[m_nMembers], 0, 4 * (30 - m_nMembers));
}

//----- (00548446) --------------------------------------------------------
void __fastcall CPedList::BuildListFromGroup_NotInCar_NoLeader(CPedList *this, CPedGroupMembership *pGroupMemberShip)
{
  int v4; // r6
  CPed *Member; // r0
  CPed *v6; // r0

  v4 = 0;
  this->m_nMembers = 0;
  do
  {
    Member = CPedGroupMembership::GetMember(pGroupMemberShip, v4);
    if ( Member )
    {
      if ( !CPedIntelligence::IsInACarOrEnteringOne(Member->m_pPedIntelligence) )
      {
        v6 = CPedGroupMembership::GetMember(pGroupMemberShip, v4);
        if ( this->m_nMembers <= 29 )
          this->m_aMembers[this->m_nMembers++] = v6;
      }
    }
    ++v4;
  }
  while ( v4 != 7 );
  if ( this->m_nMembers <= 29 )
    memset(&this->m_aMembers[this->m_nMembers], 0, 4 * (30 - this->m_nMembers));
}

//----- (005484A6) --------------------------------------------------------
void __fastcall CPedList::AddMember(CPedList *this, CPed *pPed)
{
  if ( this->m_nMembers <= 29 )
    this->m_aMembers[this->m_nMembers++] = pPed;
}

//----- (005484BC) --------------------------------------------------------
void __fastcall CPedList::BuildListOfPedsOfPedType(CPedList *this, Int32 PedType)
{
  Int32 v2; // r12
  CPedPool *v3; // lr
  int32 m_nSize; // r3
  int v5; // r2
  int v6; // r3
  int v7; // r2
  CPed *v8; // r4

  v2 = 0;
  this->m_nMembers = 0;
  v3 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( !m_nSize )
    goto LABEL_10;
  v2 = 0;
  v5 = 1996 * m_nSize;
  v6 = m_nSize - 1;
  v7 = v5 - 1996;
  do
  {
    if ( (v3->m_aFlags[v6] & 0x80u) == 0 )
    {
      v8 = (CPed *)&(*v3->m_aStorage)[v7];
      if ( v8 )
      {
        if ( v8->m_nPedType == PedType && v2 < 30 )
        {
          this->m_aMembers[v2] = v8;
          v2 = this->m_nMembers + 1;
          this->m_nMembers = v2;
        }
      }
    }
    --v6;
    v7 -= 1996;
  }
  while ( v6 != -1 );
  if ( v2 <= 29 )
LABEL_10:
    memset(&this->m_aMembers[v2], 0, 4 * (30 - v2));
}

//----- (00548544) --------------------------------------------------------
void __fastcall CPedList::RemovePedsThatDontListenToPlayer(CPedList *this)
{
  Int32 m_nMembers; // r1
  CPed **m_aMembers; // r2
  int v3; // r12
  int i; // r2
  CPed *v5; // r3

  m_nMembers = this->m_nMembers;
  if ( this->m_nMembers >= 1 )
  {
    m_aMembers = this->m_aMembers;
    do
    {
      if ( (*((_BYTE *)&(*m_aMembers)->m_nPedFlags + 8) & 0x20) != 0 )
      {
        *m_aMembers = 0;
        --this->m_nMembers;
      }
      ++m_aMembers;
      --m_nMembers;
    }
    while ( m_nMembers );
  }
  v3 = 0;
  for ( i = 1; i != 31; ++i )
  {
    v5 = (CPed *)*(&this->m_nMembers + i);
    if ( v5 )
      this->m_aMembers[v3++] = v5;
  }
  if ( v3 <= 29 )
    memset(&this->m_aMembers[v3], 0, 4 * (30 - v3));
}

//----- (005485A6) --------------------------------------------------------
void __fastcall CPedList::FillUpHoles(CPedList *this)
{
  int v1; // r12
  int i; // r2
  CPed *v3; // r3

  v1 = 0;
  for ( i = 1; i != 31; ++i )
  {
    v3 = (CPed *)*(&this->m_nMembers + i);
    if ( v3 )
      this->m_aMembers[v1++] = v3;
  }
  if ( v1 <= 29 )
    memset(&this->m_aMembers[v1], 0, 4 * (30 - v1));
}

//----- (005485E6) --------------------------------------------------------
void __fastcall CPedList::RemovePedsAttackingPedType(CPedList *this, Int32 PedType)
{
  Int32 m_nMembers; // r6
  CPed **m_aMembers; // r5
  CTask *TaskByType; // r0
  bool v7; // zf
  int v8; // r1
  int i; // r0
  CPed *v10; // r2

  m_nMembers = this->m_nMembers;
  if ( this->m_nMembers >= 1 )
  {
    m_aMembers = this->m_aMembers;
    do
    {
      TaskByType = CPedIntelligence::FindTaskByType((*m_aMembers)->m_pPedIntelligence, 1000);
      v7 = TaskByType == 0;
      if ( TaskByType )
      {
        TaskByType = (CTask *)TaskByType[2]._vptr$CTask;
        v7 = TaskByType == 0;
      }
      if ( v7 || TaskByType[179].m_pParent != (CTask *)PedType )
      {
        *m_aMembers = 0;
        --this->m_nMembers;
      }
      ++m_aMembers;
      --m_nMembers;
    }
    while ( m_nMembers );
  }
  v8 = 0;
  for ( i = 1; i != 31; ++i )
  {
    v10 = (CPed *)*(&this->m_nMembers + i);
    if ( v10 )
      this->m_aMembers[v8++] = v10;
  }
  if ( v8 <= 29 )
    memset(&this->m_aMembers[v8], 0, 4 * (30 - v8));
}

//----- (00548662) --------------------------------------------------------
void __fastcall CPedList::ExtractPedsWithGuns(CPedList *this, CPedList *SourcePedList)
{
  CPed **m_aMembers; // r6
  int v5; // r5
  int m_nMembers; // r0
  int v7; // r1
  int i; // r0
  CPed *v9; // r2

  if ( SourcePedList->m_nMembers > 0 )
  {
    m_aMembers = SourcePedList->m_aMembers;
    v5 = 0;
    do
    {
      if ( CWeapon::IsTypeMelee(&m_aMembers[v5]->m_WeaponSlots[m_aMembers[v5]->m_nCurrentWeapon]) )
      {
        m_nMembers = SourcePedList->m_nMembers;
      }
      else
      {
        if ( this->m_nMembers <= 29 )
          this->m_aMembers[this->m_nMembers++] = m_aMembers[v5];
        m_aMembers[v5] = 0;
        m_nMembers = SourcePedList->m_nMembers - 1;
        SourcePedList->m_nMembers = m_nMembers;
      }
      ++v5;
    }
    while ( v5 < m_nMembers );
  }
  v7 = 0;
  for ( i = 1; i != 31; ++i )
  {
    v9 = (CPed *)*(&SourcePedList->m_nMembers + i);
    if ( v9 )
      SourcePedList->m_aMembers[v7++] = v9;
  }
  if ( v7 <= 29 )
    memset(&SourcePedList->m_aMembers[v7], 0, 4 * (30 - v7));
}

//----- (005486FC) --------------------------------------------------------
void __fastcall CPointList::Empty(CPointList *this)
{
  bool *m_aPointHasBeenClaimed; // r0

  *(_DWORD *)&this->m_aPointHasBeenClaimed[20] = 0;
  *(_DWORD *)&this->m_aPointHasBeenClaimed[16] = 0;
  this->m_nPoints = 0;
  m_aPointHasBeenClaimed = this->m_aPointHasBeenClaimed;
  *(_QWORD *)m_aPointHasBeenClaimed = 0LL;
  *((_QWORD *)m_aPointHasBeenClaimed + 1) = 0LL;
}

//----- (00548716) --------------------------------------------------------
void __fastcall CPointList::AddPoint(CPointList *this, CVector NewPoint)
{
  Int32 m_nPoints; // r12
  CVector *v3; // r0

  m_nPoints = this->m_nPoints;
  if ( this->m_nPoints <= 23 )
  {
    this->m_nPoints = m_nPoints + 1;
    v3 = &this->m_aPoints[m_nPoints];
    v3->x = NewPoint.x;
    v3->y = NewPoint.y;
    v3->z = NewPoint.z;
  }
}

//----- (00548740) --------------------------------------------------------
void __fastcall CPointList::MergeListsRemovingDoubles(
        CPointList *this,
        CPointList *pMainList,
        CPointList *pToBeMergedList)
{
  Int32 m_nPoints; // lr
  Int32 v4; // r3
  Int32 v5; // r0
  float *v6; // r4
  float v7; // s2
  float v8; // s4
  float v9; // s6
  Int32 v10; // r4
  RwReal *p_y; // r5
  float *v12; // r0

  m_nPoints = pToBeMergedList->m_nPoints;
  if ( pToBeMergedList->m_nPoints >= 1 )
  {
    v4 = 0;
    do
    {
      v5 = pMainList->m_nPoints;
      if ( pMainList->m_nPoints > 23 )
        break;
      v6 = (float *)(&pToBeMergedList->m_nPoints + 3 * v4);
      v7 = v6[1];
      v8 = v6[2];
      v9 = v6[3];
      if ( v5 < 1 )
      {
LABEL_8:
        pMainList->m_nPoints = v5 + 1;
        v12 = (float *)(&pMainList->m_nPoints + 3 * v5);
        v12[1] = v7;
        v12[2] = v8;
        v12[3] = v9;
        m_nPoints = pToBeMergedList->m_nPoints;
      }
      else
      {
        v10 = 0;
        p_y = &pMainList->m_aPoints[0].y;
        while ( sqrtf(
                  (float)((float)((float)(*(p_y - 1) - v7) * (float)(*(p_y - 1) - v7))
                        + (float)((float)(*p_y - v8) * (float)(*p_y - v8)))
                + (float)((float)(p_y[1] - v9) * (float)(p_y[1] - v9))) >= 1.5 )
        {
          ++v10;
          p_y += 3;
          if ( v10 >= v5 )
            goto LABEL_8;
        }
      }
      ++v4;
    }
    while ( v4 < m_nPoints );
  }
}

//----- (005487E4) --------------------------------------------------------
void __fastcall CFormation::GenerateGatherDestinations(CPedList *pPedList, CPed *pLeader)
{
  Int32 m_nMembers; // r0
  float m_fCurrentHeading; // s16
  float v5; // s18
  int v6; // r11
  int v7; // r4
  float v8; // s0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r8
  float v11; // r5
  float v12; // r0
  float x; // s4
  float v14; // s0
  float y; // s6
  float v16; // s8
  float *v17; // r0

  *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[16] = 0;
  *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[20] = 0;
  CFormation::m_Destinations.m_nPoints = 0;
  *(_QWORD *)CFormation::m_Destinations.m_aPointHasBeenClaimed = 0LL;
  *(_QWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[8] = 0LL;
  m_nMembers = pPedList->m_nMembers;
  m_fCurrentHeading = pLeader->m_fCurrentHeading;
  if ( (unsigned int)(m_nMembers - 1) >= 4 )
  {
    if ( m_nMembers <= 0 )
      return;
    v5 = 2.5;
  }
  else
  {
    v5 = *(float *)&dword_548910[m_nMembers - 1];
  }
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = m_fCurrentHeading + 1.5708;
    if ( m_nMembers >= 2 )
      v8 = (float)(3.1416 / (float)m_nMembers)
         + (float)((float)((float)((float)v7 / (float)m_nMembers) * 6.2832) - m_fCurrentHeading);
    m_pMat = pLeader->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pLeader->m_transform;
    if ( v6 <= 23 )
    {
      v11 = sinf(v8);
      v12 = cosf(v8);
      x = p_tx->m_translate.x;
      v14 = v5 * v12;
      y = p_tx->m_translate.y;
      v16 = p_tx->m_translate.z + 0.0;
      v17 = (float *)(&CFormation::m_Destinations.m_nPoints + 3 * v6);
      CFormation::m_Destinations.m_nPoints = ++v6;
      v17[1] = x + (float)(v5 * v11);
      v17[2] = y + v14;
      v17[3] = v16;
      m_nMembers = pPedList->m_nMembers;
    }
    ++v7;
  }
  while ( v7 < m_nMembers );
}
// 548910: using guessed type int dword_548910[4];

//----- (00548934) --------------------------------------------------------
void __fastcall CFormation::GenerateGatherDestinations_AroundCar(CPedList *pPedList, CVehicle *pLeaderVehicle)
{
  CColModel *m_pColModel; // r0
  float y; // s16
  float x; // s18
  float v7; // s20
  CMatrix *m_pMat; // r0
  __int64 v9; // d16
  CMatrix *v10; // r0
  __int64 v11; // d16
  float v12; // s2
  int v13; // r1
  float v14; // s0
  int v15; // r12
  int v16; // lr
  unsigned int v17; // r3
  float v18; // s12
  float v19; // s6
  float v20; // s8
  float v21; // s10
  float v22; // s14
  int v23; // r0
  CMatrix *v24; // r2
  CSimpleTransform *p_tx; // r6
  float v26; // s7
  float v27; // s5
  float v28; // s3
  float v29; // s9
  int v30; // r2
  float *v31; // r1
  int v32; // r0
  float v33; // s12
  float v34; // s6
  float v35; // s8
  float v36; // s2
  float v37; // s10
  CMatrix *v38; // r6
  CSimpleTransform *p_m_transform; // r3
  float v40; // s1
  float z; // s9
  float v42; // s5
  float v43; // s7
  int v44; // r3
  float v45; // s13
  float *v46; // r1
  float v47; // s11
  float v48; // s1
  CVector v49; // [sp+0h] [bp-48h] BYREF
  CVector v50; // [sp+10h] [bp-38h] BYREF

  m_pColModel = CModelInfo::ms_modelInfoPtrs[pLeaderVehicle->m_nModelIndex]->m_pColModel;
  y = m_pColModel->m_boxBound.m_vecMin.y;
  x = m_pColModel->m_boxBound.m_vecMax.x;
  v7 = m_pColModel->m_boxBound.m_vecMax.y;
  m_pMat = pLeaderVehicle->m_pMat;
  v9 = *(_QWORD *)&m_pMat->xx;
  v50.z = m_pMat->zx;
  *(_QWORD *)&v50.x = v9;
  CVector::Normalise(&v50);
  v10 = pLeaderVehicle->m_pMat;
  v11 = *(_QWORD *)&v10->xy;
  v49.z = v10->zy;
  *(_QWORD *)&v49.x = v11;
  CVector::Normalise(&v49);
  v12 = x + 1.5;
  *(_QWORD *)CFormation::m_Destinations.m_aPointHasBeenClaimed = 0LL;
  *(_QWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[8] = 0LL;
  v13 = 0;
  v14 = v7 - y;
  *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[16] = 0;
  *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[20] = 0;
  CFormation::m_Destinations.m_nPoints = 0;
  v15 = pPedList->m_nMembers - pPedList->m_nMembers / 2;
  if ( pPedList->m_nMembers >= 2 )
  {
    v16 = pPedList->m_nMembers / 2;
    v17 = pPedList->m_nMembers + 1;
    v18 = v12 * v50.y;
    v19 = v12 * v50.z;
    v20 = v14 * v49.y;
    v13 = 0;
    v21 = v14 * v49.x;
    v22 = v12 * v50.x;
    v23 = 0;
    do
    {
      v24 = pLeaderVehicle->m_pMat;
      p_tx = (CSimpleTransform *)&v24->tx;
      if ( !v24 )
        p_tx = &pLeaderVehicle->m_transform;
      v26 = p_tx->m_translate.x - v22;
      v27 = p_tx->m_translate.y - v18;
      v28 = p_tx->m_translate.z - v19;
      if ( v17 >= 3 )
      {
        v29 = 0.5 - (float)((float)v23 / (float)v16);
        v28 = v28 + (float)(v29 * (float)(v14 * v49.z));
        v27 = v27 + (float)(v29 * v20);
        v26 = v26 + (float)(v29 * v21);
      }
      if ( v13 <= 23 )
      {
        v30 = v13 + 1;
        CFormation::m_Destinations.m_nPoints = v13 + 1;
        v31 = (float *)(&CFormation::m_Destinations.m_nPoints + 3 * v13);
        v31[1] = v26;
        v31[2] = v27;
        v31[3] = v28;
        v13 = v30;
      }
      ++v23;
    }
    while ( v16 != v23 );
  }
  if ( v15 >= 1 )
  {
    v32 = 0;
    v33 = v12 * v50.y;
    v34 = v12 * v50.z;
    v35 = v14 * v49.y;
    v36 = v12 * v50.x;
    v37 = v14 * v49.x;
    do
    {
      v38 = pLeaderVehicle->m_pMat;
      p_m_transform = (CSimpleTransform *)&v38->tx;
      if ( !v38 )
        p_m_transform = &pLeaderVehicle->m_transform;
      if ( v13 <= 23 )
      {
        v40 = 0.5 - (float)((float)v32 / (float)v15);
        z = p_m_transform->m_translate.z;
        v42 = p_m_transform->m_translate.x + v36;
        v43 = p_m_transform->m_translate.y + v33;
        v44 = v13 + 1;
        CFormation::m_Destinations.m_nPoints = v13 + 1;
        v45 = v40 * v37;
        v46 = (float *)(&CFormation::m_Destinations.m_nPoints + 3 * v13);
        v47 = v40 * v35;
        v48 = v40 * (float)(v14 * v49.z);
        v46[1] = v42 + v45;
        v46[2] = v43 + v47;
        v46[3] = (float)(z + v34) + v48;
        v13 = v44;
      }
      ++v32;
    }
    while ( v15 != v32 );
  }
}

//----- (00548B54) --------------------------------------------------------
Int32 __fastcall CFormation::FindNearestAvailableDestination(CVector Coors, float *TotalDistance)
{
  float x; // r12
  float y; // s4
  float v4; // s0
  RwReal v5; // r4
  float v6; // s8

  x = Coors.x;
  if ( CFormation::m_Destinations.m_nPoints < 1 )
  {
    v4 = 10000000.0;
    Coors.x = NAN;
  }
  else
  {
    y = Coors.y;
    v4 = 10000000.0;
    Coors.x = NAN;
    Coors.y = 0.0;
    v5 = 0.0;
    do
    {
      if ( !CFormation::m_Destinations.m_aPointHasBeenClaimed[LODWORD(v5)] )
      {
        v6 = sqrtf(
               (float)((float)((float)(*(float *)((char *)&CFormation::m_Destinations.m_aPoints[0].x + LODWORD(Coors.y))
                                     - x)
                             * (float)(*(float *)((char *)&CFormation::m_Destinations.m_aPoints[0].x + LODWORD(Coors.y))
                                     - x))
                     + (float)((float)(*(float *)((char *)&CFormation::m_Destinations.m_aPoints[0].y + LODWORD(Coors.y))
                                     - y)
                             * (float)(*(float *)((char *)&CFormation::m_Destinations.m_aPoints[0].y + LODWORD(Coors.y))
                                     - y)))
             + (float)((float)(*(float *)((char *)&CFormation::m_Destinations.m_aPoints[0].z + LODWORD(Coors.y))
                             - Coors.z)
                     * (float)(*(float *)((char *)&CFormation::m_Destinations.m_aPoints[0].z + LODWORD(Coors.y))
                             - Coors.z)));
        if ( v6 < v4 )
        {
          Coors.x = v5;
          v4 = v6;
        }
      }
      ++LODWORD(v5);
      LODWORD(Coors.y) += 12;
    }
    while ( SLODWORD(v5) < CFormation::m_Destinations.m_nPoints );
  }
  *TotalDistance = v4 + *TotalDistance;
  return SLODWORD(Coors.x);
}

//----- (00548C0C) --------------------------------------------------------
void __fastcall CFormation::DistributeDestinations(CPedList *pPedList)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d4
  Int32 m_nMembers; // lr
  float32x2_t v5; // d16
  float v6; // s2
  float32x2_t v7; // d17
  float v8; // s4
  Int32 m_nPoints; // r6
  Int32 v10; // r1
  CVector *m_aPoints; // r0
  float x; // s0
  float32x2_t v13; // d18
  float v14; // s10
  float v15; // s6
  int *v16; // r1
  int v17; // lr
  Int32 v18; // r3
  CPed *v19; // r2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r5
  int v22; // r0
  __int64 v23; // kr00_8
  int *v24; // r0
  int z_low; // r5
  float v26; // s12
  float32x2_t v27; // d18
  float v28; // s4
  float v29; // s12
  float32x2_t v30; // d3
  Int32 v31; // r1
  CVector *v32; // r0
  float v33; // s14
  float32x2_t v34; // d17
  float32x2_t v35; // d17
  unsigned __int64 v36; // d8
  int *v37; // r0
  Int32 v38; // r1
  float v39; // s10
  float32x2_t v40; // d7
  float v41; // s5
  float32x2_t v42; // d16
  float32x2_t v43; // d16
  unsigned __int64 v44; // d8
  float *v45; // r0
  Int32 v46; // r1
  float v47; // s0
  float v48; // s8
  float v49; // s12
  float v50; // s0
  int v51; // r0
  float v52; // s24
  int v53; // r0
  float v54; // s4
  CVector *v55; // r2
  int *v56; // r3
  Int32 v57; // r1
  float v58; // s2
  float32x2_t v59; // d16
  Int32 i; // r3
  float32x2_t v61; // d17
  unsigned __int64 v62; // d4
  float v63; // s6
  size_t v64; // [sp+Ch] [bp-19Ch]
  int v65; // [sp+18h] [bp-190h]
  Int32 v66; // [sp+1Ch] [bp-18Ch]
  int v67[75]; // [sp+20h] [bp-188h] BYREF
  int v68[75]; // [sp+24h] [bp-184h] BYREF
  _BYTE v69[292]; // [sp+28h] [bp-180h] BYREF
  __int64 v70; // [sp+14Ch] [bp-5Ch]
  int v71; // [sp+154h] [bp-54h]
  int v72; // [sp+158h] [bp-50h]

  *(_QWORD *)&v69[284] = 0LL;
  v70 = 0LL;
  v71 = 0;
  v72 = 0;
  v67[0] = 0;
  qmemcpy(&CFormation::m_Peds, pPedList, sizeof(CFormation::m_Peds));
  m_nMembers = CFormation::m_Peds.m_nMembers;
  if ( CFormation::m_Peds.m_nMembers )
  {
    v5.n64_u64[0] = 0LL;
    v6 = 0.0;
    v7.n64_u64[0] = 0LL;
    v8 = 0.0;
    m_nPoints = CFormation::m_Destinations.m_nPoints;
    if ( CFormation::m_Destinations.m_nPoints >= 1 )
    {
      v7.n64_u64[0] = 0LL;
      v8 = 0.0;
      v10 = 0;
      m_aPoints = CFormation::m_Destinations.m_aPoints;
      do
      {
        x = m_aPoints->x;
        ++v10;
        v13.n64_u64[0] = *(unsigned __int64 *)&m_aPoints->y;
        ++m_aPoints;
        v8 = v8 + x;
        v7.n64_u64[0] = vadd_f32(v7, v13).n64_u64[0];
      }
      while ( v10 < CFormation::m_Destinations.m_nPoints );
    }
    v1.n64_u32[0] = 1.0;
    v66 = CFormation::m_Peds.m_nMembers;
    v14 = 0.0;
    v15 = 1.0 / (float)CFormation::m_Destinations.m_nPoints;
    if ( CFormation::m_Peds.m_nMembers >= 1 )
    {
      v5.n64_u64[0] = 0LL;
      v16 = v68;
      v14 = 0.0;
      v17 = 0;
      v18 = 0;
      do
      {
        v19 = CFormation::m_Peds.m_aMembers[v18];
        m_pMat = v19->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v19->m_transform;
        if ( v17 <= 23 )
        {
          v22 = 3 * v17++;
          v23 = *(_QWORD *)&p_tx->m_translate.x;
          v24 = &v67[v22];
          z_low = LODWORD(p_tx->m_translate.z);
          *(_QWORD *)(v24 + 1) = v23;
          v24[3] = z_low;
        }
        v26 = *(float *)v16;
        ++v18;
        v27.n64_u64[0] = *(unsigned __int64 *)(v16 + 1);
        v16 += 3;
        v14 = v14 + v26;
        v5.n64_u64[0] = vadd_f32(v5, v27).n64_u64[0];
      }
      while ( v18 < v66 );
      v67[0] = v17;
      m_nMembers = v66;
    }
    v28 = v8 * v15;
    v29 = (float)m_nMembers;
    v30.n64_u64[0] = vmul_n_f32(v7, v15).n64_u64[0];
    if ( m_nPoints >= 1 )
    {
      v31 = 0;
      v6 = 0.0;
      v32 = CFormation::m_Destinations.m_aPoints;
      do
      {
        v33 = v32->x;
        ++v31;
        v34.n64_u64[0] = *(unsigned __int64 *)&v32->y;
        ++v32;
        v35.n64_u64[0] = vsub_f32(v34, v30).n64_u64[0];
        v36 = vmul_f32(v35, v35).n64_u64[0];
        v6 = v6
           + sqrtf((float)((float)((float)(v33 - v28) * (float)(v33 - v28)) + *(float *)&v36) + *((float *)&v36 + 1));
      }
      while ( v31 < m_nPoints );
    }
    if ( m_nMembers >= 1 )
    {
      v37 = v68;
      v38 = 0;
      v2.n64_f32[0] = v6 / (float)m_nPoints;
      v39 = v14 * (float)(1.0 / v29);
      v3.n64_u32[0] = 0;
      v40.n64_u64[0] = vmul_n_f32(v5, 1.0 / v29).n64_u64[0];
      do
      {
        v41 = *(float *)v37;
        ++v38;
        v42.n64_u64[0] = *(unsigned __int64 *)(v37 + 1);
        v37 += 3;
        v43.n64_u64[0] = vsub_f32(v42, v40).n64_u64[0];
        v44 = vmul_f32(v43, v43).n64_u64[0];
        v3.n64_f32[0] = v3.n64_f32[0]
                      + sqrtf(
                          (float)((float)((float)(v41 - v39) * (float)(v41 - v39)) + *(float *)&v44)
                        + *((float *)&v44 + 1));
      }
      while ( v38 < m_nMembers );
      v3.n64_f32[0] = v3.n64_f32[0] / v29;
      v45 = (float *)v69;
      v46 = 0;
      v47 = vmax_f32(v2, v1).n64_f32[0] / vmax_f32(v3, v1).n64_f32[0];
      do
      {
        ++v46;
        v48 = v30.n64_f32[0] + (float)(v47 * (float)(*v45 - v40.n64_f32[0]));
        v49 = v30.n64_f32[1] + (float)(v47 * (float)(v45[1] - v40.n64_f32[1]));
        *(v45 - 1) = v28 + (float)(v47 * (float)(*(v45 - 1) - v39));
        *v45 = v48;
        v45[1] = v49;
        v45 += 3;
      }
      while ( v46 < m_nMembers );
      v64 = 4 * m_nMembers;
      v50 = 1000000.0;
      v51 = 0;
      do
      {
        v65 = v51;
        v52 = 0.0;
        CFormation::m_aPedLinkToDestinations[0] = -1;
        CFormation::m_aPedLinkToDestinations[1] = -1;
        CFormation::m_aPedLinkToDestinations[2] = -1;
        CFormation::m_aPedLinkToDestinations[3] = -1;
        CFormation::m_aPedLinkToDestinations[4] = -1;
        CFormation::m_aPedLinkToDestinations[5] = -1;
        CFormation::m_aPedLinkToDestinations[6] = -1;
        *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[16] = 0;
        *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[20] = 0;
        *(_QWORD *)CFormation::m_Destinations.m_aPointHasBeenClaimed = 0LL;
        *(_QWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[8] = 0LL;
        v53 = 0;
        do
        {
          if ( m_nPoints < 1 )
          {
            v57 = -1;
            v54 = 10000000.0;
          }
          else
          {
            v54 = 10000000.0;
            v55 = CFormation::m_Destinations.m_aPoints;
            v56 = &v67[3 * v53];
            v57 = -1;
            v58 = *((float *)v56 + 1);
            v59.n64_u64[0] = (unsigned __int64)*((float32x2_t *)v56 + 1);
            for ( i = 0; i != m_nPoints; ++i )
            {
              if ( !CFormation::m_Destinations.m_aPointHasBeenClaimed[i] )
              {
                v61.n64_u64[0] = vsub_f32(*(float32x2_t *)&v55->y, v59).n64_u64[0];
                v62 = vmul_f32(v61, v61).n64_u64[0];
                v63 = sqrtf(
                        (float)((float)((float)(v55->x - v58) * (float)(v55->x - v58)) + *(float *)&v62)
                      + *((float *)&v62 + 1));
                if ( v63 < v54 )
                {
                  v57 = i;
                  v54 = v63;
                }
              }
              ++v55;
            }
          }
          v52 = v52 + v54;
          CFormation::m_aPedLinkToDestinations[v53++] = v57;
          CFormation::m_Destinations.m_aPointHasBeenClaimed[v57] = 1;
        }
        while ( v53 != m_nMembers );
        if ( v52 < v50 )
        {
          qmemcpy(CFormation::m_aFinalPedLinkToDestinations, CFormation::m_aPedLinkToDestinations, v64);
          v50 = v52;
          m_nMembers = v66;
        }
        v51 = v65 + 1;
      }
      while ( v65 + 1 < m_nMembers );
    }
  }
}
// 548DD8: conditional instruction was optimized away because lr.4>=1
// 548E3C: conditional instruction was optimized away because lr.4>=1
// 548DEA: variable 'v2' is possibly undefined
// 548DEA: variable 'v1' is possibly undefined
// 548DE6: variable 'v3' is possibly undefined
// 548C0C: using guessed type int var_188[75];

//----- (00548FE0) --------------------------------------------------------
void __fastcall CFormation::DistributeDestinations_CoverPoints(CPedList *pPedList, CVector TargetCoors)
{
  unsigned __int64 v2; // d2
  float32x2_t v3; // d8
  RwReal x; // r4
  RwReal y; // r5
  Int32 m_nMembers; // r0
  Int32 m_nPoints; // r8
  float v8; // s0
  float v9; // s2
  Int32 v10; // r10
  int v11; // r4
  float *v12; // r3
  float v13; // s8
  float v14; // s10
  int v15; // r3
  float32x2_t v16; // d7
  float v17; // s12
  CPed *v18; // r1
  CMatrix *m_pMat; // r5
  CSimpleTransform *p_tx; // r2
  float v21; // s3
  bool v22; // cc

  x = TargetCoors.x;
  y = TargetCoors.y;
  qmemcpy(&CFormation::m_Peds, pPedList, sizeof(CFormation::m_Peds));
  m_nMembers = CFormation::m_Peds.m_nMembers;
  if ( CFormation::m_Peds.m_nMembers )
  {
    m_nPoints = CFormation::m_Destinations.m_nPoints;
    CFormation::m_aFinalPedLinkToDestinations[0] = -1;
    CFormation::m_aFinalPedLinkToDestinations[1] = -1;
    CFormation::m_aFinalPedLinkToDestinations[2] = -1;
    CFormation::m_aFinalPedLinkToDestinations[3] = -1;
    CFormation::m_aFinalPedLinkToDestinations[4] = -1;
    CFormation::m_aFinalPedLinkToDestinations[5] = -1;
    CFormation::m_aFinalPedLinkToDestinations[6] = -1;
    CFormation::m_aFinalPedLinkToDestinations[7] = -1;
    if ( CFormation::m_Destinations.m_nPoints >= 1 )
    {
      v8 = y;
      LODWORD(v2) = 1053609165;
      v9 = x;
      v10 = 0;
      do
      {
        if ( m_nMembers >= 1 )
        {
          v11 = -1;
          v12 = (float *)(&CFormation::m_Destinations.m_nPoints + 3 * v10);
          v13 = v12[1];
          v14 = v12[2];
          v15 = 0;
          v16.n64_u64[0] = v2;
          v17 = sqrtf((float)((float)(v13 - v9) * (float)(v13 - v9)) + (float)((float)(v14 - v8) * (float)(v14 - v8)));
          do
          {
            if ( CFormation::m_aFinalPedLinkToDestinations[v15] <= -1 )
            {
              v18 = CFormation::m_Peds.m_aMembers[v15];
              m_pMat = v18->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &v18->m_transform;
              HIDWORD(v2) = LODWORD(p_tx->m_translate.y);
              v21 = sqrtf(
                      (float)((float)(p_tx->m_translate.x - v9) * (float)(p_tx->m_translate.x - v9))
                    + (float)((float)(*((float *)&v2 + 1) - v8) * (float)(*((float *)&v2 + 1) - v8)));
              if ( v17 <= (float)(v21 + 1.0) )
              {
                *((float *)&v2 + 1) = (float)(*((float *)&v2 + 1) - v14) * (float)(*((float *)&v2 + 1) - v14);
                v3.n64_f32[0] = 1.0
                              - (float)((float)((float)(v17
                                                      + sqrtf(
                                                          (float)((float)(p_tx->m_translate.x - v13)
                                                                * (float)(p_tx->m_translate.x - v13))
                                                        + *((float *)&v2 + 1)))
                                              - v21)
                                      / v21);
                v22 = v3.n64_f32[0] <= v16.n64_f32[0];
                v16.n64_u64[0] = vmax_f32(v3, v16).n64_u64[0];
                if ( !v22 )
                  v11 = v15;
              }
            }
            ++v15;
          }
          while ( m_nMembers != v15 );
          if ( v11 > -1 )
            CFormation::m_aFinalPedLinkToDestinations[v11] = v10;
        }
        ++v10;
      }
      while ( v10 < m_nPoints );
    }
  }
}
// 549094: variable 'v2' is possibly undefined
// 54910E: variable 'v3' is possibly undefined

//----- (00549164) --------------------------------------------------------
void __fastcall CFormation::DistributeDestinations_PedsToAttack(CPedList *pPedList)
{
  Int32 v1; // r6
  Int32 v2; // r8
  unsigned __int64 v3; // d0
  Int32 m_nMembers; // r10
  Int32 v5; // r4
  signed int v6; // r0
  int v7; // r1
  int32x4_t v8; // q8
  int32x4_t *v9; // r2
  unsigned int v10; // r3
  int v11; // r2
  float32x2_t v12; // d1
  Int32 v13; // r1
  Int32 v14; // lr
  CPed **v15; // r11
  CPed *v16; // r5
  CMatrix *m_pMat; // r0
  CMatrix *v18; // r4
  float32x2_t *p_tx; // r2
  float32x2_t *p_m_transform; // r0
  float32x2_t v21; // d16
  float32x2_t v22; // d2
  bool v23; // nf
  bool v24; // fnf
  int v25; // [sp+8h] [bp-A8h]
  Int32 v27; // [sp+18h] [bp-98h]
  _DWORD v28[37]; // [sp+1Ch] [bp-94h] BYREF

  qmemcpy(&CFormation::m_Peds, pPedList, sizeof(CFormation::m_Peds));
  if ( !CFormation::m_Peds.m_nMembers )
    return;
  CFormation::m_aFinalPedLinkToDestinations[0] = -1;
  CFormation::m_aFinalPedLinkToDestinations[1] = -1;
  CFormation::m_aFinalPedLinkToDestinations[2] = -1;
  CFormation::m_aFinalPedLinkToDestinations[3] = -1;
  CFormation::m_aFinalPedLinkToDestinations[4] = -1;
  CFormation::m_aFinalPedLinkToDestinations[5] = -1;
  CFormation::m_aFinalPedLinkToDestinations[6] = -1;
  CFormation::m_aFinalPedLinkToDestinations[7] = -1;
  m_nMembers = CFormation::m_DestinationPeds.m_nMembers;
  v5 = pPedList->m_nMembers;
  v6 = (int)ceilf((float)pPedList->m_nMembers / (float)CFormation::m_DestinationPeds.m_nMembers);
  if ( v6 <= 2 )
    v6 = 2;
  if ( m_nMembers >= 1 )
  {
    if ( (unsigned int)m_nMembers > 3 && (v7 = m_nMembers & 0x7FFFFFFC, (m_nMembers & 0xFFFFFFFC) != 0) )
    {
      v8 = vdupq_n_s32(v6);
      v9 = (int32x4_t *)v28;
      v10 = m_nMembers & 0xFFFFFFFC;
      do
      {
        *v9++ = v8;
        v10 -= 4;
      }
      while ( v10 );
      if ( m_nMembers == v7 )
        goto LABEL_13;
    }
    else
    {
      v7 = 0;
    }
    do
      v28[v7++] = v6;
    while ( v7 < m_nMembers );
  }
LABEL_13:
  if ( v5 >= 1 )
  {
    v11 = 0;
    LODWORD(v3) = 1232348158;
    do
    {
      v25 = v11;
      if ( v5 >= 1 )
      {
        v12.n64_u64[0] = v3;
        v13 = 0;
        v27 = v5;
        do
        {
          if ( CFormation::m_aFinalPedLinkToDestinations[v13] <= -1 && m_nMembers >= 1 )
          {
            v14 = 0;
            v15 = &pPedList->m_aMembers[v13];
            do
            {
              if ( (int)v28[v14] >= 1 )
              {
                v16 = CFormation::m_DestinationPeds.m_aMembers[v14];
                m_pMat = (*v15)->m_pMat;
                v18 = v16->m_pMat;
                p_tx = (float32x2_t *)&m_pMat->tx;
                if ( !m_pMat )
                  p_tx = (float32x2_t *)&(*v15)->m_transform;
                p_m_transform = (float32x2_t *)&v18->tx;
                if ( !v18 )
                  p_m_transform = (float32x2_t *)&v16->m_transform;
                v21.n64_u64[0] = vsub_f32((float32x2_t)p_tx->n64_u64[0], (float32x2_t)p_m_transform->n64_u64[0]).n64_u64[0];
                v22.n64_u64[0] = vmul_f32(v21, v21).n64_u64[0];
                v22.n64_f32[0] = sqrtf(v22.n64_f32[0] + v22.n64_f32[1]);
                v23 = v22.n64_f32[0] < v12.n64_f32[0];
                v24 = v22.n64_f32[0] < v12.n64_f32[0];
                v12.n64_u64[0] = vmin_f32(v22, v12).n64_u64[0];
                if ( v23 )
                  v2 = v14;
                if ( v24 )
                  v1 = v13;
              }
              ++v14;
            }
            while ( m_nMembers != v14 );
          }
          ++v13;
        }
        while ( v13 < v27 );
      }
      CFormation::m_aFinalPedLinkToDestinations[v1] = v2;
      v11 = v25 + 1;
      --v28[v2];
      v5 = pPedList->m_nMembers;
    }
    while ( v25 + 1 < pPedList->m_nMembers );
  }
}
// 5491EC: mask 0xFFFFFFFC is shortened because r10.4 <= 0x7FFFFFFF
// 54924C: variable 'v3' is possibly undefined
// 5492F4: variable 'v2' is possibly undefined
// 5492F4: variable 'v1' is possibly undefined
// 549164: using guessed type _DWORD var_94[37];

//----- (00549334) --------------------------------------------------------
void __fastcall CFormation::ReturnTargetPedForPed(CPed *pPed, CPed **ppTargetPed)
{
  int v2; // r3
  int v3; // r4

  if ( CFormation::m_Peds.m_nMembers >= 1 )
  {
    v2 = 0;
    while ( 1 )
    {
      if ( CFormation::m_Peds.m_aMembers[v2] == pPed )
      {
        v3 = CFormation::m_aFinalPedLinkToDestinations[v2];
        if ( v3 >= 0 )
          break;
      }
      if ( ++v2 >= CFormation::m_Peds.m_nMembers )
        return;
    }
    *ppTargetPed = CFormation::m_DestinationPeds.m_aMembers[v3];
  }
}

//----- (00549394) --------------------------------------------------------
bool __fastcall CFormation::ReturnDestinationForPed(CPed *pPed, CVector *Dest)
{
  int v2; // r2
  int v3; // r3
  bool result; // r0
  char *v6; // r0
  __int64 v7; // d16

  v2 = 0;
  while ( 1 )
  {
    if ( CFormation::m_Peds.m_aMembers[v2] == pPed )
    {
      v3 = CFormation::m_aFinalPedLinkToDestinations[v2];
      if ( v3 > -1 )
        break;
    }
    if ( v2++ >= 23 )
      return 0;
  }
  v6 = (char *)&CFormation::m_Destinations + 12 * v3;
  v7 = *(_QWORD *)(v6 + 4);
  Dest->z = *((RwReal *)v6 + 3);
  result = 1;
  *(_QWORD *)&Dest->x = v7;
  return result;
}

//----- (005493F4) --------------------------------------------------------
void __fastcall CFormation::FindCoverPoints(CVector Target, float CutoffDist)
{
  RwReal x; // r5
  float y; // lr
  RwReal z; // r12
  CVehiclePool *v6; // r10
  int32 m_nSize; // r6
  int v8; // r0
  CColModel *m_pColModel; // r1
  RwReal v10; // r8
  Int32 m_nPoints; // r12
  Int32 v12; // r1
  RwReal *p_y; // r2
  Int32 v14; // r0
  Int32 v15; // r3
  RwReal v16; // r4
  __int64 v17; // kr00_8
  CVector *v18; // r0
  CObjectPool *v19; // r9
  int32 v20; // r0
  int v21; // r6
  float v22; // s18
  float v23; // s22
  int v24; // r4
  uint8 *v25; // r5
  int v26; // r1
  float *v27; // r0
  float v28; // s26
  float v29; // s28
  float v30; // s0
  float v31; // s30
  float v32; // s2
  float *v33; // r0
  float v34; // s4
  const CVector *v35; // [sp+4h] [bp-1CCh]
  CVector *pBoxMin; // [sp+8h] [bp-1C8h]
  const CVector *p_m_vecMax; // [sp+Ch] [bp-1C4h]
  RwReal v38; // [sp+28h] [bp-1A8h]
  RwReal v39; // [sp+2Ch] [bp-1A4h]
  CPointList pPointList; // [sp+30h] [bp-1A0h] BYREF
  CVector v41; // 0:r1.12

  x = Target.x;
  y = Target.y;
  z = Target.z;
  *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[16] = 0;
  *(_DWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[20] = 0;
  CFormation::m_Destinations.m_nPoints = 0;
  v6 = CPools::ms_pVehiclePool;
  *(_QWORD *)CFormation::m_Destinations.m_aPointHasBeenClaimed = 0LL;
  *(_QWORD *)&CFormation::m_Destinations.m_aPointHasBeenClaimed[8] = 0LL;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v38 = Target.y;
    v39 = Target.x;
    do
    {
      if ( (v6->m_aFlags[--m_nSize] & 0x80u) == 0 )
      {
        v8 = (int)v6->m_aStorage[m_nSize];
        if ( v8 )
        {
          if ( !*(_DWORD *)(v8 + 1440)
            && sqrtf(
                 (float)((float)(*(float *)(v8 + 72) * *(float *)(v8 + 72))
                       + (float)(*(float *)(v8 + 76) * *(float *)(v8 + 76)))
               + (float)(*(float *)(v8 + 80) * *(float *)(v8 + 80))) < 0.005 )
          {
            m_pColModel = CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v8 + 38)]->m_pColModel;
            if ( m_pColModel->m_boxBound.m_vecMax.z < 1.5 )
            {
              pPointList.m_nPoints = 0;
              v10 = z;
              memset(pPointList.m_aPointHasBeenClaimed, 0, sizeof(pPointList.m_aPointHasBeenClaimed));
              pBoxMin = &m_pColModel->m_boxBound.m_vecMin;
              p_m_vecMax = &m_pColModel->m_boxBound.m_vecMax;
              v41.x = x;
              *(_QWORD *)&v41.y = __PAIR64__(LODWORD(z), LODWORD(y));
              CFormation::FindCoverPointsBehindBox(
                &pPointList,
                v41,
                *(CMatrix **)(v8 + 20),
                v35,
                pBoxMin,
                p_m_vecMax,
                CutoffDist);
              m_nPoints = pPointList.m_nPoints;
              if ( pPointList.m_nPoints >= 1 )
              {
                v12 = 0;
                p_y = &pPointList.m_aPoints[0].y;
                v14 = CFormation::m_Destinations.m_nPoints;
                do
                {
                  if ( v14 <= 23 )
                  {
                    v15 = v14 + 1;
                    v16 = *(p_y - 1);
                    v17 = *(_QWORD *)p_y;
                    v18 = &CFormation::m_Destinations.m_aPoints[v14];
                    CFormation::m_Destinations.m_nPoints = v15;
                    v18->x = v16;
                    *(_QWORD *)&v18->y = v17;
                    v14 = v15;
                  }
                  ++v12;
                  p_y += 3;
                }
                while ( v12 < m_nPoints );
              }
              y = v38;
              x = v39;
              z = v10;
            }
          }
        }
      }
    }
    while ( m_nSize );
  }
  v19 = CPools::ms_pObjectPool;
  v20 = CPools::ms_pObjectPool->m_nSize;
  if ( v20 )
  {
    v21 = v20 - 1;
    v22 = z;
    v23 = x;
    v24 = 420 * v20 - 420;
    do
    {
      if ( (v19->m_aFlags[v21] & 0x80u) == 0 )
      {
        v25 = &(*v19->m_aStorage)[v24];
        if ( v25 )
        {
          if ( *(float *)(*((_DWORD *)v25 + 5) + 40) > 0.95
            && CObject::CanBeUsedToTakeCoverBehind((CObject *)&(*v19->m_aStorage)[v24]) )
          {
            v26 = *((_DWORD *)v25 + 5);
            v27 = (float *)(v26 + 48);
            if ( !v26 )
              v27 = (float *)(v25 + 4);
            v28 = *v27;
            v29 = v27[1];
            v30 = *v27 - v23;
            if ( sqrtf((float)(v30 * v30) + (float)((float)(v29 - y) * (float)(v29 - y))) < CutoffDist )
            {
              v31 = v27[2];
              pPointList.m_aPoints[0].x = v29 - y;
              *(float *)&pPointList.m_nPoints = v30;
              pPointList.m_aPoints[0].y = v31 - v22;
              CVector::Normalise((CVector *)&pPointList);
              if ( CFormation::m_Destinations.m_nPoints <= 23 )
              {
                v32 = v29 + pPointList.m_aPoints[0].x;
                v33 = (float *)(&CFormation::m_Destinations.m_nPoints + 3 * CFormation::m_Destinations.m_nPoints);
                v34 = v31 + pPointList.m_aPoints[0].y;
                ++CFormation::m_Destinations.m_nPoints;
                v33[1] = v28 + *(float *)&pPointList.m_nPoints;
                v33[2] = v32;
                v33[3] = v34;
              }
            }
          }
        }
      }
      --v21;
      v24 -= 420;
    }
    while ( v21 != -1 );
  }
}
// 549508: variable 'v35' is possibly undefined
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (005496AC) --------------------------------------------------------
void __fastcall CFormation::FindCoverPointsBehindBox(
        CPointList *pPointList,
        CVector Target,
        CMatrix *pMat,
        const CVector *pBoxOffset,
        const CVector *pBoxMin,
        const CVector *pBoxMax,
        float CutoffDist)
{
  unsigned __int64 v7; // d0
  float32x2_t v8; // d1
  float y; // r8
  float x; // r9
  RwReal v12; // r1
  RwReal v13; // r1
  float v14; // s18
  int v15; // r5
  RwReal *p_y; // r6
  float v17; // s2
  float v18; // s6
  float v19; // s8
  float v20; // s12
  CVector *v21; // r8
  int v22; // r10
  float v23; // s2
  float v24; // s4
  float32x2_t v25; // d4
  float v26; // s6
  float v27; // s10
  float v28; // s26
  float v29; // s28
  RwReal v30; // s0
  float v31; // s24
  RwReal v32; // s2
  float v33; // s26
  float z; // s30
  float v35; // s28
  Int32 m_nPoints; // r0
  float v37; // s0
  float v38; // s2
  float v39; // s4
  float *v40; // r0
  CVector *v41; // [sp+8h] [bp-B0h]
  CVector v; // [sp+Ch] [bp-ACh] BYREF
  CVector v43; // [sp+18h] [bp-A0h] BYREF
  float v44; // [sp+24h] [bp-94h]
  CVector v45; // [sp+28h] [bp-90h] BYREF
  CVector v46; // [sp+34h] [bp-84h]
  CVector v47; // [sp+40h] [bp-78h]
  CVector v48; // [sp+4Ch] [bp-6Ch]

  y = Target.y;
  x = Target.x;
  if ( fabsf(Target.z - pMat->tz) < 7.0 )
  {
    *(_QWORD *)&v.x = *(_QWORD *)&pBoxMin->x;
    v.z = 0.0;
    operator*(&v43, pMat, &v);
    v45 = v43;
    v12 = pBoxMax->y;
    v.x = pBoxMin->x;
    v.y = v12;
    v.z = 0.0;
    operator*(&v43, pMat, &v);
    v46 = v43;
    *(_QWORD *)&v.x = *(_QWORD *)&pBoxMax->x;
    v.z = 0.0;
    operator*(&v43, pMat, &v);
    v47 = v43;
    v13 = pBoxMin->y;
    v.x = pBoxMax->x;
    v.y = v13;
    v.z = 0.0;
    operator*(&v43, pMat, &v);
    v14 = y;
    v48 = v43;
    v15 = 0;
    p_y = &v45.y;
    v17 = v45.y - y;
    v18 = v46.y - y;
    v19 = v47.y - y;
    v20 = v43.y - y;
    v21 = &v43;
    v22 = 0;
    *(float *)&v7 = (float)((float)(v45.x - x) * (float)(v45.x - x)) + (float)(v17 * v17);
    v23 = (float)((float)(v47.x - x) * (float)(v47.x - x)) + (float)(v19 * v19);
    *(float *)&v7 = sqrtf(*(float *)&v7);
    v24 = sqrtf((float)((float)(v46.x - x) * (float)(v46.x - x)) + (float)(v18 * v18));
    v25.n64_u64[0] = v7;
    v8.n64_f32[0] = sqrtf(v23);
    if ( v24 < *(float *)&v7 )
      v25.n64_f32[0] = v24;
    v26 = sqrtf((float)((float)(v43.x - x) * (float)(v43.x - x)) + (float)(v20 * v20));
    LODWORD(v43.x) = v7;
    LODWORD(v27) = vmin_f32(v8, v25).n64_u32[0];
    v43.y = v24;
    LODWORD(v43.z) = v8.n64_u32[0];
    v44 = v26;
    if ( v24 < *(float *)&v7 )
      v15 = 1;
    if ( v8.n64_f32[0] < v25.n64_f32[0] )
      v15 = 2;
    if ( v26 < v27 )
      v15 = 3;
    v41 = &v45 + (((_BYTE)v15 + 2) & 3);
    do
    {
      if ( v15 != v22 && (((_BYTE)v22 + 2) & 3) != v15 && pPointList->m_nPoints <= 23 && v21->x < CutoffDist )
      {
        v28 = *(p_y - 1);
        v29 = *p_y;
        v30 = v41->y - *p_y;
        v.z = 0.0;
        v31 = p_y[1];
        v32 = v41->x - v28;
        v.y = v30;
        v.x = v32;
        CVector::Normalise(&v);
        v33 = v28 + v.x;
        z = v.z;
        v35 = v29 + v.y;
        v.z = 0.0;
        v.x = v33 - x;
        v.y = v35 - v14;
        CVector::Normalise(&v);
        m_nPoints = pPointList->m_nPoints;
        if ( pPointList->m_nPoints <= 23 )
        {
          v37 = v.x * 0.75;
          v38 = v.y * 0.75;
          v39 = v.z * 0.75;
          pPointList->m_nPoints = m_nPoints + 1;
          v40 = (float *)(&pPointList->m_nPoints + 3 * m_nPoints);
          v40[1] = v33 + v37;
          v40[2] = v35 + v38;
          v40[3] = (float)(v31 + z) + v39;
        }
      }
      ++v22;
      p_y += 3;
      v21 = (CVector *)((char *)v21 + 4);
    }
    while ( v22 != 4 );
  }
}
// 549810: variable 'v7' is possibly undefined
// 549832: variable 'v8' is possibly undefined

//----- (00549960) --------------------------------------------------------
void *__fastcall CTaskAllocator::operator new(size_t nSize)
{
  int v1; // lr
  CTaskAllocatorPool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pTaskAllocatorPool;
  result = (void *)CPools::ms_pTaskAllocatorPool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pTaskAllocatorPool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (005499C0) --------------------------------------------------------
void __fastcall CTaskAllocator::operator delete(void *pVoid)
{
  CTaskAllocatorPool *v1; // r1
  signed int v2; // r0

  v1 = CPools::ms_pTaskAllocatorPool;
  v2 = (signed int)((int)pVoid - (unsigned int)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (005499E8) --------------------------------------------------------
void __fastcall CTaskAllocatorKillOnFoot::CTaskAllocatorKillOnFoot(
        CTaskAllocatorKillOnFoot *this,
        CPed *pAttacked,
        int groupID)
{
  this->m_GroupTargetID = groupID;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  this->m_pTarget = pAttacked;
  if ( pAttacked )
    CEntity::RegisterReference(pAttacked, &this->m_pTarget);
}
// 66D534: using guessed type void *;

//----- (00549A18) --------------------------------------------------------
void __fastcall CTaskAllocatorKillOnFoot::~CTaskAllocatorKillOnFoot(CTaskAllocatorKillOnFoot *this)
{
  CPed *m_pTarget; // r0
  CEntity **p_m_pTarget; // r1

  p_m_pTarget = &this->m_pTarget;
  m_pTarget = this->m_pTarget;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  if ( m_pTarget )
    CEntity::CleanUpOldReference(m_pTarget, p_m_pTarget);
}
// 66D534: using guessed type void *off_66D534;

//----- (00549A40) --------------------------------------------------------
void __fastcall CTaskAllocatorKillOnFoot::~CTaskAllocatorKillOnFoot(CTaskAllocatorKillOnFoot *this)
{
  CPed *m_pTarget; // r0
  CEntity **p_m_pTarget; // r1
  CTaskAllocatorPool *v4; // r0
  int v5; // r1

  p_m_pTarget = &this->m_pTarget;
  m_pTarget = this->m_pTarget;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  if ( m_pTarget )
    CEntity::CleanUpOldReference(m_pTarget, p_m_pTarget);
  v4 = CPools::ms_pTaskAllocatorPool;
  v5 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v5] |= 0x80u;
  if ( v5 < v4->m_nFreeIndex )
    v4->m_nFreeIndex = v5;
}
// 66D534: using guessed type void *off_66D534;

//----- (00549A88) --------------------------------------------------------
bool __fastcall TaskIsFighting(Int32 TaskType)
{
  unsigned int v2; // r2
  bool result; // r0
  bool v4; // zf

  v2 = TaskType - 1020;
  result = 1;
  if ( v2 > 9 || ((1 << v2) & 0x35D) == 0 )
  {
    v4 = TaskType == 1101;
    if ( TaskType != 1101 )
      v4 = TaskType == 1502;
    if ( !v4 )
      return 0;
  }
  return result;
}

//----- (00549AB8) --------------------------------------------------------
void __fastcall CTaskAllocatorKillOnFoot::AllocateTasks(
        CTaskAllocatorKillOnFoot *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  CPed *Leader; // r0
  CPed *m_pTarget; // r0
  CPed *v6; // r0
  CMatrix *m_pMat; // r1
  CVector *p_tx; // r2
  CPed *v9; // r0
  CMatrix *v10; // r1
  CVector *p_m_translate; // r3
  CTaskComplexSequence *v12; // r9
  Int32 v13; // r4
  CPed *v14; // r6
  CTask *Task; // r0
  int v16; // r0
  bool v17; // zf
  bool v18; // zf
  CTaskComplexSequence *v19; // r8
  CTaskComplexLeaveCar *v20; // r9
  CTask *v21; // r1
  CTaskComplexSequence *v22; // r0
  CTaskComplexKillPedGroupOnFoot *v23; // r5
  CTaskComplexSequence *v24; // r8
  CTaskComplexKillPedOnFoot *v25; // r0
  CPed *v26; // r1
  CTask *v27; // r5
  CTaskSimpleRunTimedAnim *v28; // r5
  unsigned __int16 v29; // r0
  CPedGroupIntelligence *v30; // r11
  Int32 v31; // r8
  CPed *v32; // r4
  CTask *v33; // r0
  int v34; // r0
  bool v35; // zf
  bool v36; // zf
  CTaskComplexLeaveCar *v37; // r5
  CTaskComplexKillPedOnFoot *v38; // r5
  CTaskAllocatorKillOnFoot *v39; // [sp+20h] [bp-2B8h]
  CPedTaskPair *p; // [sp+24h] [bp-2B4h]
  CTaskSimple v41; // [sp+28h] [bp-2B0h] BYREF
  CTaskComplexSequence v42; // [sp+30h] [bp-2A8h] BYREF
  CPedList SourcePedList; // [sp+70h] [bp-268h] BYREF
  CPedList v44; // [sp+ECh] [bp-1ECh] BYREF
  CPointList v45; // [sp+168h] [bp-170h] BYREF

  CPedList::Empty(&v44);
  CPedList::Empty(&SourcePedList);
  CPointList::Empty(&v45);
  CPedList::BuildListFromGroup_NoLeader(&SourcePedList, &pGroupIntelligence->m_pPedGroup->m_membership);
  if ( CPedGroupMembership::GetLeader(&pGroupIntelligence->m_pPedGroup->m_membership) )
  {
    Leader = CPedGroupMembership::GetLeader(&pGroupIntelligence->m_pPedGroup->m_membership);
    if ( CPed::IsPlayer(Leader) )
      CPedList::RemovePedsThatDontListenToPlayer(&SourcePedList);
  }
  m_pTarget = this->m_pTarget;
  v39 = this;
  if ( m_pTarget && !CWeapon::IsTypeMelee(&m_pTarget->m_WeaponSlots[m_pTarget->m_nCurrentWeapon]) )
  {
    CPedList::ExtractPedsWithGuns(&v44, &SourcePedList);
    v6 = this->m_pTarget;
    m_pMat = v6->m_pMat;
    p_tx = (CVector *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v6->m_transform.m_translate;
    CFormation::FindCoverPoints(*p_tx, 30.0);
    v9 = this->m_pTarget;
    v10 = v9->m_pMat;
    p_m_translate = (CVector *)&v10->tx;
    if ( !v10 )
      p_m_translate = &v9->m_transform.m_translate;
    CFormation::DistributeDestinations_CoverPoints(&v44, *p_m_translate);
    if ( v44.m_nMembers >= 1 )
    {
      v12 = &v42;
      v13 = 0;
      do
      {
        v14 = v44.m_aMembers[v13];
        Task = CPedGroupIntelligence::GetTask(pGroupIntelligence, v14, pGroupIntelligence->m_pedTaskPairs);
        if ( !Task )
          goto LABEL_18;
        v16 = (*((int (__fastcall **)(CTask *))Task->_vptr$CTask + 5))(Task);
        if ( (unsigned int)(v16 - 1020) > 9 || ((1 << (v16 + 4)) & 0x35D) == 0 )
        {
          v17 = v16 == 1101;
          if ( v16 != 1101 )
            v17 = v16 == 1502;
          if ( !v17 )
          {
LABEL_18:
            CTaskComplexSequence::CTaskComplexSequence(v12);
            v18 = *((unsigned __int8 *)&v14->m_nPedFlags + 1) << 31 == 0;
            if ( *((unsigned __int8 *)&v14->m_nPedFlags + 1) << 31 )
              v18 = v14->m_pMyVehicle == 0;
            if ( !v18 )
            {
              v19 = v12;
              v20 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
              CTaskComplexLeaveCar::CTaskComplexLeaveCar(v20, v14->m_pMyVehicle, 0, 0, 1, 0);
              v21 = v20;
              v22 = v19;
              v12 = v19;
              this = v39;
              CTaskComplexSequence::AddTask(v22, v21);
            }
            if ( this->m_GroupTargetID == -1 )
            {
              v25 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
              v26 = this->m_pTarget;
              v27 = v25;
              v24 = v12;
              CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v25, v26, -1, 0, 0, 0, 2);
              CTaskComplexSequence::AddTask(v12, v27);
              v28 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
              v29 = rand();
              CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
                v28,
                ANIM_STD_PED,
                ANIM_STD_IDLE_HBHB,
                4.0,
                -4.0,
                (int)(float)((float)((float)v29 * 0.000015259) * 1000.0) + 1000,
                422,
                "LookAbout",
                0);
              v28->_vptr$CTask = (int (**)(void))&off_665898;
              CTaskComplexSequence::AddTask(v12, v28);
            }
            else
            {
              v23 = (CTaskComplexKillPedGroupOnFoot *)CTask::operator new(0x14u);
              CTaskComplexKillPedGroupOnFoot::CTaskComplexKillPedGroupOnFoot(
                v23,
                this->m_GroupTargetID,
                this->m_pTarget);
              CTaskComplexSequence::AddTask(v12, v23);
              v24 = v12;
            }
            CTaskSimple::CTaskSimple(&v41);
            v41._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v14, 1, v24, 0, &v41, -1);
            CTask::~CTask(&v41);
            CTaskComplexSequence::~CTaskComplexSequence(v24);
            v12 = v24;
            this = v39;
          }
        }
        ++v13;
      }
      while ( v13 < v44.m_nMembers );
    }
  }
  if ( SourcePedList.m_nMembers >= 1 )
  {
    v30 = pGroupIntelligence;
    v31 = 0;
    p = pGroupIntelligence->m_pedTaskPairs;
    do
    {
      v32 = SourcePedList.m_aMembers[v31];
      v33 = CPedGroupIntelligence::GetTask(pGroupIntelligence, v32, p);
      if ( !v33 )
        goto LABEL_35;
      v34 = (*((int (__fastcall **)(CTask *))v33->_vptr$CTask + 5))(v33);
      if ( (unsigned int)(v34 - 1020) > 9 || ((1 << (v34 + 4)) & 0x35D) == 0 )
      {
        v35 = v34 == 1101;
        if ( v34 != 1101 )
          v35 = v34 == 1502;
        if ( !v35 )
        {
LABEL_35:
          CTaskComplexSequence::CTaskComplexSequence(&v42);
          v36 = *((unsigned __int8 *)&v32->m_nPedFlags + 1) << 31 == 0;
          if ( *((unsigned __int8 *)&v32->m_nPedFlags + 1) << 31 )
            v36 = v32->m_pMyVehicle == 0;
          if ( !v36 )
          {
            v37 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
            CTaskComplexLeaveCar::CTaskComplexLeaveCar(v37, v32->m_pMyVehicle, 0, 0, 1, 0);
            CTaskComplexSequence::AddTask(&v42, v37);
          }
          if ( v39->m_GroupTargetID == -1 )
          {
            v38 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
            CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v38, v39->m_pTarget, -1, 0, 0, 0, 1);
          }
          else
          {
            v38 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x14u);
            CTaskComplexKillPedGroupOnFoot::CTaskComplexKillPedGroupOnFoot(
              (CTaskComplexKillPedGroupOnFoot *)v38,
              v39->m_GroupTargetID,
              v39->m_pTarget);
          }
          CTaskComplexSequence::AddTask(&v42, v38);
          CPedGroupIntelligence::SetTask(v30, v32, &v42, p, -1, 0);
          CTaskComplexSequence::~CTaskComplexSequence(&v42);
          pGroupIntelligence = v30;
        }
      }
      ++v31;
    }
    while ( v31 < SourcePedList.m_nMembers );
  }
}
// 665898: using guessed type void *off_665898;
// 668FF0: using guessed type void *off_668FF0;
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (00549E90) --------------------------------------------------------
void __fastcall CTaskAllocatorAttack::CTaskAllocatorAttack(
        CTaskAllocatorAttack *this,
        CPed *pAttacked,
        int groupID,
        CPed *pOriginator)
{
  CPed **p_m_pOriginator; // r5

  this->m_GroupTargetID = groupID;
  *(_WORD *)&this->m_NextUpdateTimer.m_bIsActive = 0;
  this->m_NextUpdateTimer.m_iStartTime = 0;
  this->m_NextUpdateTimer.m_iDuration = 0;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D558;
  this->m_pOriginator = pOriginator;
  p_m_pOriginator = &this->m_pOriginator;
  this->m_pTarget = pAttacked;
  if ( pAttacked )
  {
    CEntity::RegisterReference(pAttacked, &this->m_pTarget);
    pOriginator = *p_m_pOriginator;
  }
  if ( pOriginator )
    CEntity::RegisterReference(pOriginator, &this->m_pOriginator);
}
// 66D558: using guessed type void *off_66D558;

//----- (00549EDC) --------------------------------------------------------
void __fastcall CTaskAllocatorAttack::~CTaskAllocatorAttack(CTaskAllocatorAttack *this)
{
  CPed *m_pTarget; // r0
  CEntity **p_m_pTarget; // r1
  CPed *m_pOriginator; // r0
  CTaskAllocatorPool *v5; // r0
  int v6; // r1

  p_m_pTarget = &this->m_pTarget;
  m_pTarget = this->m_pTarget;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D558;
  if ( m_pTarget )
    CEntity::CleanUpOldReference(m_pTarget, p_m_pTarget);
  m_pOriginator = this->m_pOriginator;
  if ( m_pOriginator )
    CEntity::CleanUpOldReference(m_pOriginator, &this->m_pOriginator);
  v5 = CPools::ms_pTaskAllocatorPool;
  v6 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v6] |= 0x80u;
  if ( v6 < v5->m_nFreeIndex )
    v5->m_nFreeIndex = v6;
}
// 66D558: using guessed type void *off_66D558;

//----- (00549F34) --------------------------------------------------------
Bool __fastcall CTaskAllocatorAttack::TargetIsArmed(CTaskAllocatorAttack *this)
{
  Int32 m_GroupTargetID; // r1
  CPedGroupMembership *p_m_membership; // r4
  CPed *Member; // r0
  CPed *v4; // r0
  CPed *v5; // r0
  CPed *v6; // r0
  CPed *v7; // r0
  CPed *v8; // r0
  CPed *v9; // r0
  CPed *v10; // r0

  m_GroupTargetID = this->m_GroupTargetID;
  if ( m_GroupTargetID == -1 )
    return !CWeapon::IsTypeMelee(&this->m_pTarget->m_WeaponSlots[this->m_pTarget->m_nCurrentWeapon]);
  p_m_membership = &CPedGroups::ms_groups[m_GroupTargetID].m_membership;
  if ( CPedGroupMembership::GetMember(p_m_membership, 0) )
  {
    Member = CPedGroupMembership::GetMember(p_m_membership, 0);
    if ( !CWeapon::IsTypeMelee(&Member->m_WeaponSlots[Member->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 1) )
  {
    v4 = CPedGroupMembership::GetMember(p_m_membership, 1);
    if ( !CWeapon::IsTypeMelee(&v4->m_WeaponSlots[v4->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 2) )
  {
    v5 = CPedGroupMembership::GetMember(p_m_membership, 2);
    if ( !CWeapon::IsTypeMelee(&v5->m_WeaponSlots[v5->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 3) )
  {
    v6 = CPedGroupMembership::GetMember(p_m_membership, 3);
    if ( !CWeapon::IsTypeMelee(&v6->m_WeaponSlots[v6->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 4) )
  {
    v7 = CPedGroupMembership::GetMember(p_m_membership, 4);
    if ( !CWeapon::IsTypeMelee(&v7->m_WeaponSlots[v7->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 5) )
  {
    v8 = CPedGroupMembership::GetMember(p_m_membership, 5);
    if ( !CWeapon::IsTypeMelee(&v8->m_WeaponSlots[v8->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 6) )
  {
    v9 = CPedGroupMembership::GetMember(p_m_membership, 6);
    if ( !CWeapon::IsTypeMelee(&v9->m_WeaponSlots[v9->m_nCurrentWeapon]) )
      return 1;
  }
  if ( CPedGroupMembership::GetMember(p_m_membership, 7)
    && (v10 = CPedGroupMembership::GetMember(p_m_membership, 7),
        !CWeapon::IsTypeMelee(&v10->m_WeaponSlots[v10->m_nCurrentWeapon])) )
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (0054A0D4) --------------------------------------------------------
CTaskAllocator *__fastcall CTaskAllocatorAttack::ProcessGroup(
        CTaskAllocatorAttack *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  __int64 v6; // kr00_8
  CTaskAllocatorKillOnFoot v8; // [sp+4h] [bp-1Ch] BYREF

  if ( this->m_NextUpdateTimer.m_bIsActive )
  {
    if ( this->m_NextUpdateTimer.m_bIsStopped )
    {
      v4 = CTimer::m_snTimeInMilliseconds;
      this->m_NextUpdateTimer.m_bIsStopped = 0;
      this->m_NextUpdateTimer.m_iStartTime = v4;
      m_iStartTime = v4;
    }
    else
    {
      m_iStartTime = this->m_NextUpdateTimer.m_iStartTime;
      v4 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_NextUpdateTimer.m_iDuration > v4 )
      return this;
  }
  else
  {
    v4 = CTimer::m_snTimeInMilliseconds;
  }
  this->m_NextUpdateTimer.m_iStartTime = v4;
  this->m_NextUpdateTimer.m_iDuration = 3000;
  this->m_NextUpdateTimer.m_bIsActive = 1;
  v6 = *(_QWORD *)&this->m_pTarget;
  *(_QWORD *)&v8.m_pTarget = v6;
  v8._vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  if ( (_DWORD)v6 )
    CEntity::RegisterReference((CEntity *)v6, &v8.m_pTarget);
  CTaskAllocatorKillOnFoot::AllocateTasks(&v8, pGroupIntelligence);
  v8._vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  if ( v8.m_pTarget )
    CEntity::CleanUpOldReference(v8.m_pTarget, &v8.m_pTarget);
  return this;
}
// 66D534: using guessed type void *off_66D534;

//----- (0054A184) --------------------------------------------------------
void __fastcall CTaskAllocatorAttack::AllocateTasks(
        CTaskAllocatorAttack *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  int v4; // r0
  __int64 v5; // r0
  CTaskAllocatorKillOnFoot v6; // [sp+4h] [bp-14h] BYREF

  v4 = CTimer::m_snTimeInMilliseconds;
  this->m_NextUpdateTimer.m_bIsActive = 1;
  this->m_NextUpdateTimer.m_iStartTime = v4;
  this->m_NextUpdateTimer.m_iDuration = 3000;
  v5 = *(_QWORD *)&this->m_pTarget;
  *(_QWORD *)&v6.m_pTarget = v5;
  v6._vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  if ( (_DWORD)v5 )
    CEntity::RegisterReference((CEntity *)v5, &v6.m_pTarget);
  CTaskAllocatorKillOnFoot::AllocateTasks(&v6, pGroupIntelligence);
  v6._vptr$CTaskAllocator = (int (**)(void))&off_66D534;
  if ( v6.m_pTarget )
    CEntity::CleanUpOldReference(v6.m_pTarget, &v6.m_pTarget);
}
// 66D534: using guessed type void *off_66D534;

//----- (0054A1F4) --------------------------------------------------------
bool __fastcall CTaskAllocator::IsFinished(CTaskAllocator *this, CPedGroupIntelligence *pGroupIntelligence)
{
  CTask *m_pTask; // r0
  bool v3; // zf
  CTask *v5; // r0
  bool v6; // zf
  CTask *v7; // r0
  bool v8; // zf

  if ( pGroupIntelligence->m_pedTaskPairs[0].m_pTask )
    return 0;
  m_pTask = pGroupIntelligence->m_pedTaskPairs[1].m_pTask;
  v3 = m_pTask == 0;
  if ( !m_pTask )
    v3 = pGroupIntelligence->m_pedTaskPairs[2].m_pTask == 0;
  if ( !v3 )
    return 0;
  v5 = pGroupIntelligence->m_pedTaskPairs[3].m_pTask;
  v6 = v5 == 0;
  if ( !v5 )
    v6 = pGroupIntelligence->m_pedTaskPairs[4].m_pTask == 0;
  if ( !v6 )
    return 0;
  v7 = pGroupIntelligence->m_pedTaskPairs[5].m_pTask;
  v8 = v7 == 0;
  if ( !v7 )
    v8 = pGroupIntelligence->m_pedTaskPairs[6].m_pTask == 0;
  return v8 && pGroupIntelligence->m_pedTaskPairs[7].m_pTask == 0;
}

//----- (0054A234) --------------------------------------------------------
void __fastcall CTaskAllocatorPlayerCommandAttack::CTaskAllocatorPlayerCommandAttack(
        CTaskAllocatorPlayerCommandAttack *this,
        CPed *pAttacked,
        Int32 GroupID,
        Int32 PedTypeToAttack)
{
  CPlayerPed *PlayerPed; // r0

  PlayerPed = FindPlayerPed(-1);
  this->m_GroupTargetID = GroupID;
  *(_WORD *)&this->m_NextUpdateTimer.m_bIsActive = 0;
  this->m_NextUpdateTimer.m_iStartTime = 0;
  this->m_NextUpdateTimer.m_iDuration = 0;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D558;
  this->m_pOriginator = PlayerPed;
  this->m_pTarget = pAttacked;
  if ( pAttacked )
  {
    CEntity::RegisterReference(pAttacked, &this->m_pTarget);
    PlayerPed = (CPlayerPed *)this->m_pOriginator;
  }
  if ( PlayerPed )
    CEntity::RegisterReference(PlayerPed, &this->m_pOriginator);
  this->m_PedTypeToAttack = PedTypeToAttack;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D57C;
}
// 66D558: using guessed type void *;
// 66D57C: using guessed type void *;

//----- (0054A2A4) --------------------------------------------------------
void __fastcall CTaskAllocatorPlayerCommandAttack::AllocateTasks(
        CTaskAllocatorPlayerCommandAttack *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  __int64 v4; // r0
  CPed *Leader; // r0
  Int32 v6; // r10
  CPed *v7; // r4
  bool v8; // zf
  CTaskComplexLeaveCar *v9; // r5
  CTaskComplexKillPedOnFoot *v10; // r5
  CTaskSimpleStandStill *v11; // r5
  CPed *m_pTarget; // r0
  int v13; // r1
  CTask *m_GroupTargetID; // r1
  CPedGroupIntelligence *v15; // [sp+10h] [bp-E0h]
  CPed *ppTargetPed; // [sp+14h] [bp-DCh] BYREF
  CTaskComplexSequence v17; // [sp+18h] [bp-D8h] BYREF
  CPedList v18; // [sp+58h] [bp-98h] BYREF

  CPedList::Empty(&v18);
  if ( this->m_PedTypeToAttack < 0 )
  {
    m_pTarget = this->m_pTarget;
    if ( m_pTarget )
    {
      v13 = CTimer::m_snTimeInMilliseconds;
      this->m_NextUpdateTimer.m_bIsActive = 1;
      this->m_NextUpdateTimer.m_iStartTime = v13;
      this->m_NextUpdateTimer.m_iDuration = 3000;
      m_GroupTargetID = (CTask *)this->m_GroupTargetID;
      v17.m_pParent = (CTask *)m_pTarget;
      v17._vptr$CTask = (int (**)(void))&off_66D534;
      v17.m_pSubTask = m_GroupTargetID;
      CEntity::RegisterReference(m_pTarget, (CEntity **)&v17.m_pParent);
      CTaskAllocatorKillOnFoot::AllocateTasks((CTaskAllocatorKillOnFoot *)&v17, pGroupIntelligence);
      v17._vptr$CTask = (int (**)(void))&off_66D534;
      if ( v17.m_pParent )
        CEntity::CleanUpOldReference((CEntity *)v17.m_pParent, (CEntity **)&v17.m_pParent);
    }
  }
  else
  {
    v4 = CTimer::m_snTimeInMilliseconds | 0xBB800000000LL;
    this->m_NextUpdateTimer.m_bIsActive = 1;
    *(_QWORD *)&this->m_NextUpdateTimer.m_iStartTime = v4;
    CPedList::BuildListFromGroup_NoLeader(&v18, &pGroupIntelligence->m_pPedGroup->m_membership);
    if ( CPedGroupMembership::GetLeader(&pGroupIntelligence->m_pPedGroup->m_membership) )
    {
      Leader = CPedGroupMembership::GetLeader(&pGroupIntelligence->m_pPedGroup->m_membership);
      if ( CPed::IsPlayer(Leader) )
        CPedList::RemovePedsThatDontListenToPlayer(&v18);
    }
    v15 = pGroupIntelligence;
    CPedList::RemovePedsAttackingPedType(&v18, this->m_PedTypeToAttack);
    CPedList::BuildListOfPedsOfPedType(&CFormation::m_DestinationPeds, this->m_PedTypeToAttack);
    CFormation::DistributeDestinations_PedsToAttack(&v18);
    if ( v18.m_nMembers >= 1 )
    {
      v6 = 0;
      do
      {
        v7 = v18.m_aMembers[v6];
        CTaskComplexSequence::CTaskComplexSequence(&v17);
        v8 = *((unsigned __int8 *)&v7->m_nPedFlags + 1) << 31 == 0;
        if ( *((unsigned __int8 *)&v7->m_nPedFlags + 1) << 31 )
          v8 = v7->m_pMyVehicle == 0;
        if ( !v8 )
        {
          v9 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
          CTaskComplexLeaveCar::CTaskComplexLeaveCar(v9, v7->m_pMyVehicle, 0, 0, 1, 0);
          CTaskComplexSequence::AddTask(&v17, v9);
        }
        CFormation::ReturnTargetPedForPed(v7, &ppTargetPed);
        v10 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
        CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v10, ppTargetPed, -1, 0, 0, 0, 2);
        CTaskComplexSequence::AddTask(&v17, v10);
        v11 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(
          v11,
          (const int)"List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
          1,
          0,
          8.0);
        CTaskComplexSequence::AddTask(&v17, v11);
        CPedGroupIntelligence::SetTask(v15, v7, &v17, v15->m_pedTaskPairs, -1, 0);
        CTaskComplexSequence::~CTaskComplexSequence(&v17);
        ++v6;
      }
      while ( v6 < v18.m_nMembers );
    }
  }
}
// 66D534: using guessed type void *off_66D534;

//----- (0054A45C) --------------------------------------------------------
CTaskAllocator *__fastcall CTaskAllocatorPlayerCommandAttack::ProcessGroup(
        CTaskAllocatorPlayerCommandAttack *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  CTaskAllocatorPlayerCommandAttack *v3; // r5

  v3 = this;
  CTaskAllocatorAttack::ProcessGroup(this, pGroupIntelligence);
  if ( (*((int (__fastcall **)(CTaskAllocatorPlayerCommandAttack *, CPedGroupIntelligence *))v3->_vptr$CTaskAllocator + 4))(
         v3,
         pGroupIntelligence) )
  {
    return 0;
  }
  return v3;
}

//----- (0054A480) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasic::CTaskAllocatorKillThreatsBasic(
        CTaskAllocatorKillThreatsBasic *this,
        CPed *pThreatPed)
{
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5A0;
  this->m_pThreatPed = pThreatPed;
  if ( pThreatPed )
    CEntity::RegisterReference(pThreatPed, &this->m_pThreatPed);
}
// 66D5A0: using guessed type void *;

//----- (0054A4B4) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasic::~CTaskAllocatorKillThreatsBasic(CTaskAllocatorKillThreatsBasic *this)
{
  CPed *m_pThreatPed; // r0
  CEntity **p_m_pThreatPed; // r1
  CTaskAllocatorPool *v4; // r0
  int v5; // r1

  p_m_pThreatPed = &this->m_pThreatPed;
  m_pThreatPed = this->m_pThreatPed;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5A0;
  if ( m_pThreatPed )
    CEntity::CleanUpOldReference(m_pThreatPed, p_m_pThreatPed);
  v4 = CPools::ms_pTaskAllocatorPool;
  v5 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v5] |= 0x80u;
  if ( v5 < v4->m_nFreeIndex )
    v4->m_nFreeIndex = v5;
}
// 66D5A0: using guessed type void *off_66D5A0;

//----- (0054A4FC) --------------------------------------------------------
CTaskAllocator *__fastcall CTaskAllocatorKillThreatsBasic::ProcessGroup(
        CTaskAllocatorKillThreatsBasic *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  unsigned int v3; // r0
  int m_iStartTime; // r2
  int (**v5)(void); // r3

  if ( !this->m_timer.m_bIsActive )
  {
    this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_iDuration = 0;
    this->m_timer.m_bIsActive = 1;
  }
  if ( this->m_timer.m_bIsStopped )
  {
    v3 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v3;
    m_iStartTime = v3;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v3 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration <= v3 )
  {
    v5 = this->_vptr$CTaskAllocator;
    this->m_timer.m_iStartTime = v3;
    this->m_timer.m_iDuration = 5000;
    this->m_timer.m_bIsActive = 1;
    ((void (__fastcall *)(CTaskAllocatorKillThreatsBasic *, CPedGroupIntelligence *))v5[2])(this, pGroupIntelligence);
  }
  return this;
}

//----- (0054A564) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasic::AllocateTasks(
        CTaskAllocatorKillThreatsBasic *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  CPed *m_pThreatPed; // r0
  CPedGroup *m_pPedGroup; // r4
  CPedGroupMembership *p_m_membership; // r9
  CPedGroup *PedsGroup; // r0
  CPedGroup *v8; // r1
  int i; // r6
  CPed *Member; // r0
  CPed *v11; // r8
  CPed *Leader; // r2
  CInterestingEvents::EType v13; // r1
  int j; // r4
  CPed *v15; // r0
  CPed *v16; // r6
  CTaskComplexKillPedOnFoot *v17; // r8
  CTaskSimpleRunTimedAnim *v18; // r5
  unsigned __int16 v19; // r0
  CTaskAllocatorKillThreatsBasic *v20; // [sp+20h] [bp-90h]
  int GroupId; // [sp+20h] [bp-90h]
  CTaskComplexSequence ppClosestPeds; // [sp+24h] [bp-8Ch] BYREF
  CTask v23; // [sp+64h] [bp-4Ch] BYREF
  CTaskComplexKillPedGroupOnFoot v24[3]; // [sp+6Ch] [bp-44h] BYREF

  CPedGroupIntelligence::FlushTasks(pGroupIntelligence, pGroupIntelligence->m_pedTaskPairs, 0);
  CPedGroupIntelligence::FlushTasks(pGroupIntelligence, pGroupIntelligence->m_secondaryPedTaskPairs, 0);
  v20 = this;
  m_pThreatPed = this->m_pThreatPed;
  if ( m_pThreatPed )
  {
    m_pPedGroup = pGroupIntelligence->m_pPedGroup;
    p_m_membership = &pGroupIntelligence->m_pPedGroup->m_membership;
    PedsGroup = CPedGroups::GetPedsGroup(m_pThreatPed);
    if ( PedsGroup )
    {
      GroupId = CPedGroups::GetGroupId(PedsGroup);
      v8 = &CPedGroups::ms_groups[GroupId];
      if ( v8 == m_pPedGroup )
        return;
      CTaskAllocatorKillThreatsBasic::ComputeClosestPeds(m_pPedGroup, v8, (CPed **)&ppClosestPeds);
      for ( i = 0; i != 8; ++i )
      {
        Member = CPedGroupMembership::GetMember(p_m_membership, i);
        v11 = Member;
        if ( Member )
        {
          if ( !CPed::IsPlayer(Member) )
          {
            CTaskComplexKillPedGroupOnFoot::CTaskComplexKillPedGroupOnFoot(
              v24,
              GroupId,
              *((CPed **)&ppClosestPeds._vptr$CTask + i));
            CTaskSimple::CTaskSimple((CTaskSimple *)&v23);
            v23._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v11, 1, v24, 0, &v23, -1);
            CTask::~CTask(&v23);
            CTaskComplexKillPedGroupOnFoot::~CTaskComplexKillPedGroupOnFoot(v24);
          }
        }
      }
      Leader = CPedGroupMembership::GetLeader(p_m_membership);
      v13 = EGangFight;
    }
    else
    {
      for ( j = 0; j != 8; ++j )
      {
        v15 = CPedGroupMembership::GetMember(p_m_membership, j);
        v16 = v15;
        if ( v15 && !CPed::IsPlayer(v15) )
        {
          CTaskComplexSequence::CTaskComplexSequence(&ppClosestPeds);
          v17 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
          CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v17, v20->m_pThreatPed, -1, 0, 0, 0, 1);
          CTaskComplexSequence::AddTask(&ppClosestPeds, v17);
          v18 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
          v19 = rand();
          CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
            v18,
            ANIM_STD_PED,
            ANIM_STD_IDLE_HBHB,
            4.0,
            -4.0,
            (int)(float)((float)((float)v19 * 0.000015259) * 1000.0) + 1000,
            422,
            "LookAbout",
            0);
          v18->_vptr$CTask = (int (**)(void))&off_665898;
          CTaskComplexSequence::AddTask(&ppClosestPeds, v18);
          CTaskSimple::CTaskSimple((CTaskSimple *)v24);
          v24[0]._vptr$CTask = (int (**)(void))&off_668FF0;
          CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v16, 1, &ppClosestPeds, 0, v24, -1);
          CTask::~CTask(v24);
          CTaskComplexSequence::~CTaskComplexSequence(&ppClosestPeds);
        }
      }
      Leader = CPedGroupMembership::GetLeader(p_m_membership);
      v13 = EGangAttackingPed;
    }
    CInterestingEvents::Add(&g_InterestingEvents, v13, Leader);
  }
}
// 665898: using guessed type void *off_665898;
// 668FF0: using guessed type void *off_668FF0;
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (0054A7A0) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasic::ComputeClosestPeds(
        CPedGroup *group,
        CPedGroup *otherGroup,
        CPed **ppClosestPeds)
{
  int v3; // r4
  float *v4; // r11
  CPed **v5; // r2
  CPed *Member; // r0
  const CPed *v7; // r8
  int v8; // r6
  float *v9; // r10
  CPed *v10; // r0
  CPed *v11; // r5
  CMatrix *m_pMat; // r0
  CMatrix *v13; // r1
  float *p_tx; // r2
  float *p_x; // r0
  int i; // r4
  float v17; // s0
  int v18; // r1
  int v19; // r0
  int v20; // r6
  int v21; // r2
  float *v22; // r3
  float v23; // s5
  float v24; // s1
  float v25; // s14
  float v26; // s12
  float v27; // s10
  float v28; // s8
  float v29; // s6
  float v30; // s4
  float v31; // s2
  float v32; // s7
  float v33; // s9
  float v34; // s11
  float v35; // s13
  float v36; // s3
  float v37; // s15
  bool v38; // fnf
  _DWORD *v39; // r2
  _DWORD *v40; // r0
  CPed *Leader; // r0
  CPed *v42; // r8
  CPed *v43; // r0
  CPed *v44; // r0
  CPed *v45; // r0
  CPed *v46; // r0
  CPed *v47; // r0
  CPed *v48; // r0
  CPed *v49; // r0
  const CPedGroupMembership *v51; // [sp+8h] [bp-130h]
  const CPedGroupMembership *p_m_membership; // [sp+Ch] [bp-12Ch]
  _QWORD v53[37]; // [sp+10h] [bp-128h] BYREF

  v3 = 0;
  v4 = (float *)v53;
  *(_QWORD *)ppClosestPeds = 0LL;
  *((_QWORD *)ppClosestPeds + 1) = 0LL;
  v5 = ppClosestPeds + 4;
  *(_QWORD *)v5 = 0LL;
  *((_QWORD *)v5 + 1) = 0LL;
  v53[0] = 0x7F7FFFFF7F7FFFFFLL;
  v53[1] = 0x7F7FFFFF7F7FFFFFLL;
  v53[2] = 0x7F7FFFFF7F7FFFFFLL;
  v53[3] = 0x7F7FFFFF7F7FFFFFLL;
  v53[4] = 0x7F7FFFFF7F7FFFFFLL;
  v53[5] = 0x7F7FFFFF7F7FFFFFLL;
  v53[6] = 0x7F7FFFFF7F7FFFFFLL;
  v53[7] = 0x7F7FFFFF7F7FFFFFLL;
  v53[10] = 0x7F7FFFFF7F7FFFFFLL;
  v53[11] = 0x7F7FFFFF7F7FFFFFLL;
  v53[8] = 0x7F7FFFFF7F7FFFFFLL;
  v53[9] = 0x7F7FFFFF7F7FFFFFLL;
  v53[14] = 0x7F7FFFFF7F7FFFFFLL;
  v53[15] = 0x7F7FFFFF7F7FFFFFLL;
  v53[12] = 0x7F7FFFFF7F7FFFFFLL;
  v53[13] = 0x7F7FFFFF7F7FFFFFLL;
  v53[18] = 0x7F7FFFFF7F7FFFFFLL;
  v53[19] = 0x7F7FFFFF7F7FFFFFLL;
  v53[16] = 0x7F7FFFFF7F7FFFFFLL;
  v53[17] = 0x7F7FFFFF7F7FFFFFLL;
  v53[22] = 0x7F7FFFFF7F7FFFFFLL;
  v53[23] = 0x7F7FFFFF7F7FFFFFLL;
  v53[20] = 0x7F7FFFFF7F7FFFFFLL;
  v53[21] = 0x7F7FFFFF7F7FFFFFLL;
  v53[26] = 0x7F7FFFFF7F7FFFFFLL;
  v53[27] = 0x7F7FFFFF7F7FFFFFLL;
  v53[24] = 0x7F7FFFFF7F7FFFFFLL;
  v53[25] = 0x7F7FFFFF7F7FFFFFLL;
  v53[30] = 0x7F7FFFFF7F7FFFFFLL;
  v53[31] = 0x7F7FFFFF7F7FFFFFLL;
  v53[28] = 0x7F7FFFFF7F7FFFFFLL;
  v53[29] = 0x7F7FFFFF7F7FFFFFLL;
  p_m_membership = &otherGroup->m_membership;
  v51 = &group->m_membership;
  do
  {
    Member = CPedGroupMembership::GetMember(v51, v3);
    v7 = Member;
    if ( Member && CPed::IsAlive(Member) && !CPed::IsPlayer(v7) )
    {
      v8 = 0;
      v9 = v4;
      do
      {
        v10 = CPedGroupMembership::GetMember(p_m_membership, v8);
        v11 = v10;
        if ( v10 && CPed::IsAlive(v10) )
        {
          m_pMat = v11->m_pMat;
          v13 = v7->m_pMat;
          p_tx = &m_pMat->tx;
          if ( !m_pMat )
            p_tx = &v11->m_transform.m_translate.x;
          p_x = &v13->tx;
          if ( !v13 )
            p_x = &v7->m_transform.m_translate.x;
          *v9 = (float)((float)((float)(*p_x - *p_tx) * (float)(*p_x - *p_tx))
                      + (float)((float)(p_x[1] - p_tx[1]) * (float)(p_x[1] - p_tx[1])))
              + (float)((float)(p_x[2] - p_tx[2]) * (float)(p_x[2] - p_tx[2]));
        }
        ++v8;
        ++v9;
      }
      while ( v8 != 8 );
    }
    ++v3;
    v4 += 8;
  }
  while ( v3 != 8 );
  for ( i = 0; i != 8; ++i )
  {
    v17 = 3.4028e38;
    v18 = -1;
    v19 = 0;
    v20 = -1;
    v21 = 0;
    do
    {
      v22 = (float *)&v53[v19];
      v23 = v17;
      v19 += 4;
      v24 = *v22;
      v25 = v22[1];
      v26 = v22[2];
      v27 = v22[3];
      v28 = v22[4];
      v29 = v22[5];
      v30 = v22[6];
      v31 = v22[7];
      if ( *v22 < v17 )
        v23 = *v22;
      v32 = v23;
      if ( v25 < v23 )
        v32 = v22[1];
      v33 = v32;
      if ( v26 < v32 )
        v33 = v22[2];
      v34 = v33;
      if ( v27 < v33 )
        v34 = v22[3];
      v35 = v34;
      if ( v28 < v34 )
        v35 = v22[4];
      v36 = v35;
      if ( v29 < v35 )
        v36 = v22[5];
      v37 = v36;
      if ( v24 < v17 )
        v20 = v21;
      if ( v25 < v23 )
        v20 = v21;
      if ( v26 < v32 )
        v20 = v21;
      if ( v30 < v36 )
        v37 = v22[6];
      if ( v27 < v33 )
        v20 = v21;
      if ( v28 < v34 )
        v20 = v21;
      if ( v29 < v35 )
        v20 = v21;
      if ( v30 < v36 )
        v20 = v21;
      v38 = v24 < v17;
      v17 = v37;
      if ( v31 < v37 )
        v20 = v21;
      ++v21;
      if ( v38 )
        v18 = 0;
      if ( v25 < v23 )
        v18 = 1;
      if ( v26 < v32 )
        v18 = 2;
      if ( v27 < v33 )
        v18 = 3;
      if ( v28 < v34 )
        v18 = 4;
      if ( v29 < v35 )
        v18 = 5;
      if ( v31 < v37 )
        v17 = v22[7];
      if ( v30 < v36 )
        v18 = 6;
      if ( v31 < v37 )
        v18 = 7;
    }
    while ( v19 != 32 );
    if ( (v18 | v20) >= 0 )
    {
      v39 = (_DWORD *)v53 + v18;
      LODWORD(v53[4 * v20]) = 2139095039;
      v40 = &v53[4 * v20];
      *v39 = 2139095039;
      v40[1] = 2139095039;
      v39[8] = 2139095039;
      v40[2] = 2139095039;
      v39[16] = 2139095039;
      v40[3] = 2139095039;
      v39[24] = 2139095039;
      v40[4] = 2139095039;
      v39[32] = 2139095039;
      v40[5] = 2139095039;
      v39[40] = 2139095039;
      v40[6] = 2139095039;
      v39[48] = 2139095039;
      v40[7] = 2139095039;
      v39[56] = 2139095039;
      ppClosestPeds[v20] = CPedGroupMembership::GetMember(p_m_membership, v18);
    }
  }
  Leader = CPedGroupMembership::GetLeader(p_m_membership);
  v42 = Leader;
  if ( Leader && CPed::IsAlive(Leader) )
    goto LABEL_111;
  v43 = CPedGroupMembership::GetMember(p_m_membership, 0);
  v42 = v43;
  if ( v43 )
  {
    if ( CPed::IsAlive(v43) )
      goto LABEL_111;
  }
  v44 = CPedGroupMembership::GetMember(p_m_membership, 1);
  v42 = v44;
  if ( v44 )
  {
    if ( CPed::IsAlive(v44) )
      goto LABEL_111;
  }
  v45 = CPedGroupMembership::GetMember(p_m_membership, 2);
  v42 = v45;
  if ( v45 )
  {
    if ( CPed::IsAlive(v45) )
      goto LABEL_111;
  }
  v46 = CPedGroupMembership::GetMember(p_m_membership, 3);
  v42 = v46;
  if ( v46 )
  {
    if ( CPed::IsAlive(v46) )
      goto LABEL_111;
  }
  if ( (v47 = CPedGroupMembership::GetMember(p_m_membership, 4), (v42 = v47) != 0) && CPed::IsAlive(v47)
    || (v48 = CPedGroupMembership::GetMember(p_m_membership, 5), (v42 = v48) != 0) && CPed::IsAlive(v48)
    || (v49 = CPedGroupMembership::GetMember(p_m_membership, 6), (v42 = v49) != 0) && CPed::IsAlive(v49) )
  {
LABEL_111:
    if ( CPedGroupMembership::GetMember(v51, 0) && !*ppClosestPeds )
      *ppClosestPeds = v42;
    if ( CPedGroupMembership::GetMember(v51, 1) && !ppClosestPeds[1] )
      ppClosestPeds[1] = v42;
    if ( CPedGroupMembership::GetMember(v51, 2) && !ppClosestPeds[2] )
      ppClosestPeds[2] = v42;
    if ( CPedGroupMembership::GetMember(v51, 3) && !ppClosestPeds[3] )
      ppClosestPeds[3] = v42;
    if ( CPedGroupMembership::GetMember(v51, 4) && !ppClosestPeds[4] )
      ppClosestPeds[4] = v42;
    if ( CPedGroupMembership::GetMember(v51, 5) && !ppClosestPeds[5] )
      ppClosestPeds[5] = v42;
    if ( CPedGroupMembership::GetMember(v51, 6) && !ppClosestPeds[6] )
      ppClosestPeds[6] = v42;
    if ( CPedGroupMembership::GetMember(v51, 7) )
    {
      if ( !ppClosestPeds[7] )
        ppClosestPeds[7] = v42;
    }
  }
}

//----- (0054AC84) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasicRandomGroup::AllocateTasks(
        CTaskAllocatorKillThreatsBasicRandomGroup *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  CPed *m_pThreatPed; // r0
  CPedGroup *m_pPedGroup; // r4
  CPedGroupMembership *p_m_membership; // r10
  CPedGroup *PedsGroup; // r0
  int32 GroupId; // r6
  CPedGroup *v9; // r1
  int i; // r9
  CPed *Member; // r0
  CPed *v12; // r8
  CPed *Leader; // r2
  CInterestingEvents::EType v14; // r1
  int j; // r5
  CPed *v16; // r0
  CPed *v17; // r4
  CTaskComplexKillPedOnFoot *v18; // r6
  CTaskSimpleRunTimedAnim *v19; // r6
  unsigned __int16 v20; // r0
  CTaskAllocatorKillThreatsBasicRandomGroup *v21; // [sp+24h] [bp-94h]
  CTaskComplexSequence ppClosestPeds; // [sp+28h] [bp-90h] BYREF
  CTask v23; // [sp+68h] [bp-50h] BYREF
  CTaskComplexSeekCoverUntilTargetDead v24[3]; // [sp+70h] [bp-48h] BYREF

  CPedGroupIntelligence::FlushTasks(pGroupIntelligence, pGroupIntelligence->m_pedTaskPairs, 0);
  CPedGroupIntelligence::FlushTasks(pGroupIntelligence, pGroupIntelligence->m_secondaryPedTaskPairs, 0);
  v21 = this;
  m_pThreatPed = this->m_pThreatPed;
  if ( m_pThreatPed )
  {
    m_pPedGroup = pGroupIntelligence->m_pPedGroup;
    p_m_membership = &pGroupIntelligence->m_pPedGroup->m_membership;
    PedsGroup = CPedGroups::GetPedsGroup(m_pThreatPed);
    if ( PedsGroup )
    {
      GroupId = CPedGroups::GetGroupId(PedsGroup);
      v9 = &CPedGroups::ms_groups[GroupId];
      if ( v9 == m_pPedGroup )
        return;
      CTaskAllocatorKillThreatsBasic::ComputeClosestPeds(m_pPedGroup, v9, (CPed **)&ppClosestPeds);
      for ( i = 0; i != 8; ++i )
      {
        Member = CPedGroupMembership::GetMember(p_m_membership, i);
        v12 = Member;
        if ( Member && !CPed::IsPlayer(Member) )
        {
          if ( CWeapon::IsTypeMelee(&v12->m_WeaponSlots[v12->m_nCurrentWeapon])
            && !CWeapon::IsTypeMelee(&v21->m_pThreatPed->m_WeaponSlots[v21->m_pThreatPed->m_nCurrentWeapon]) )
          {
            CTaskComplexSeekCoverUntilTargetDead::CTaskComplexSeekCoverUntilTargetDead(v24, GroupId);
            CTaskSimple::CTaskSimple((CTaskSimple *)&v23);
            v23._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v12, 1, v24, 0, &v23, -1);
            CTask::~CTask(&v23);
            CTaskComplexSeekCoverUntilTargetDead::~CTaskComplexSeekCoverUntilTargetDead(v24);
          }
          else
          {
            CTaskComplexKillPedGroupOnFoot::CTaskComplexKillPedGroupOnFoot(
              (CTaskComplexKillPedGroupOnFoot *)v24,
              GroupId,
              *((CPed **)&ppClosestPeds._vptr$CTask + i));
            CTaskSimple::CTaskSimple((CTaskSimple *)&v23);
            v23._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v12, 1, v24, 0, &v23, -1);
            CTask::~CTask(&v23);
            CTaskComplexKillPedGroupOnFoot::~CTaskComplexKillPedGroupOnFoot((CTaskComplexKillPedGroupOnFoot *)v24);
          }
        }
      }
      Leader = CPedGroupMembership::GetLeader(p_m_membership);
      v14 = EGangFight;
    }
    else
    {
      for ( j = 0; j != 8; ++j )
      {
        v16 = CPedGroupMembership::GetMember(p_m_membership, j);
        v17 = v16;
        if ( v16 && !CPed::IsPlayer(v16) )
        {
          if ( CWeapon::IsTypeMelee(&v17->m_WeaponSlots[v17->m_nCurrentWeapon])
            && !CWeapon::IsTypeMelee(&v21->m_pThreatPed->m_WeaponSlots[v21->m_pThreatPed->m_nCurrentWeapon]) )
          {
            CTaskComplexSeekCoverUntilTargetDead::CTaskComplexSeekCoverUntilTargetDead(
              (CTaskComplexSeekCoverUntilTargetDead *)&ppClosestPeds,
              v21->m_pThreatPed);
            CTaskSimple::CTaskSimple((CTaskSimple *)v24);
            v24[0]._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v17, 1, &ppClosestPeds, 0, v24, -1);
            CTask::~CTask(v24);
            CTaskComplexSeekCoverUntilTargetDead::~CTaskComplexSeekCoverUntilTargetDead((CTaskComplexSeekCoverUntilTargetDead *)&ppClosestPeds);
          }
          else
          {
            CTaskComplexSequence::CTaskComplexSequence(&ppClosestPeds);
            v18 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
            CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v18, v21->m_pThreatPed, -1, 0, 0, 0, 1);
            CTaskComplexSequence::AddTask(&ppClosestPeds, v18);
            v19 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
            v20 = rand();
            CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
              v19,
              ANIM_STD_PED,
              ANIM_STD_IDLE_HBHB,
              4.0,
              -4.0,
              (int)(float)((float)((float)v20 * 0.000015259) * 1000.0) + 1000,
              422,
              "LookAbout",
              0);
            v19->_vptr$CTask = (int (**)(void))&off_665898;
            CTaskComplexSequence::AddTask(&ppClosestPeds, v19);
            CTaskSimple::CTaskSimple((CTaskSimple *)v24);
            v24[0]._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v17, 1, &ppClosestPeds, 0, v24, -1);
            CTask::~CTask(v24);
            CTaskComplexSequence::~CTaskComplexSequence(&ppClosestPeds);
          }
        }
      }
      Leader = CPedGroupMembership::GetLeader(p_m_membership);
      v14 = EGangAttackingPed;
    }
    CInterestingEvents::Add(&g_InterestingEvents, v14, Leader);
  }
}
// 665898: using guessed type void *off_665898;
// 668FF0: using guessed type void *off_668FF0;
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (0054AFB0) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsDriveby::CTaskAllocatorKillThreatsDriveby(
        CTaskAllocatorKillThreatsDriveby *this,
        CPed *pThreatPed)
{
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5C4;
  this->m_pThreatPed = pThreatPed;
  if ( pThreatPed )
    CEntity::RegisterReference(pThreatPed, &this->m_pThreatPed);
}
// 66D5C4: using guessed type void *;

//----- (0054AFE4) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsDriveby::~CTaskAllocatorKillThreatsDriveby(
        CTaskAllocatorKillThreatsDriveby *this)
{
  CPed *m_pThreatPed; // r0
  CEntity **p_m_pThreatPed; // r1

  p_m_pThreatPed = &this->m_pThreatPed;
  m_pThreatPed = this->m_pThreatPed;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5C4;
  if ( m_pThreatPed )
    CEntity::CleanUpOldReference(m_pThreatPed, p_m_pThreatPed);
}
// 66D5C4: using guessed type void *off_66D5C4;

//----- (0054B00C) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsDriveby::~CTaskAllocatorKillThreatsDriveby(
        CTaskAllocatorKillThreatsDriveby *this)
{
  CPed *m_pThreatPed; // r0
  CEntity **p_m_pThreatPed; // r1
  CTaskAllocatorPool *v4; // r0
  int v5; // r1

  p_m_pThreatPed = &this->m_pThreatPed;
  m_pThreatPed = this->m_pThreatPed;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5C4;
  if ( m_pThreatPed )
    CEntity::CleanUpOldReference(m_pThreatPed, p_m_pThreatPed);
  v4 = CPools::ms_pTaskAllocatorPool;
  v5 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v5] |= 0x80u;
  if ( v5 < v4->m_nFreeIndex )
    v4->m_nFreeIndex = v5;
}
// 66D5C4: using guessed type void *off_66D5C4;

//----- (0054B054) --------------------------------------------------------
CTaskAllocator *__fastcall CTaskAllocatorKillThreatsDriveby::ProcessGroup(
        CTaskAllocatorKillThreatsDriveby *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  unsigned int v3; // r0
  int m_iStartTime; // r2
  int (**v5)(void); // r3

  if ( !this->m_timer.m_bIsActive )
  {
    this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_iDuration = 0;
    this->m_timer.m_bIsActive = 1;
  }
  if ( this->m_timer.m_bIsStopped )
  {
    v3 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v3;
    m_iStartTime = v3;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v3 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration <= v3 )
  {
    v5 = this->_vptr$CTaskAllocator;
    this->m_timer.m_iStartTime = v3;
    this->m_timer.m_iDuration = 5000;
    this->m_timer.m_bIsActive = 1;
    ((void (__fastcall *)(CTaskAllocatorKillThreatsDriveby *, CPedGroupIntelligence *))v5[2])(this, pGroupIntelligence);
  }
  return this;
}

//----- (0054B0BC) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsDriveby::AllocateTasks(
        CTaskAllocatorKillThreatsDriveby *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  CPed *m_pThreatPed; // r0
  CPedGroup *m_pPedGroup; // r6
  CPedGroupMembership *p_m_membership; // r5
  CTask *TaskByType; // r0
  CPedGroup *v8; // r1
  int i; // r11
  CPed *Member; // r0
  CPed *v11; // r8
  CPed *Leader; // r2
  CInterestingEvents::EType v13; // r1
  int j; // r6
  CPed *v15; // r0
  CPed *v16; // r10
  CTaskComplexKillPedOnFoot *v17; // r9
  CTaskSimpleRunTimedAnim *v18; // r4
  unsigned __int16 v19; // r0
  int m_pParent; // [sp+1Ch] [bp-A4h]
  CPedGroupIntelligence *v21; // [sp+20h] [bp-A0h]
  CPedGroupIntelligence *v22; // [sp+20h] [bp-A0h]
  CTaskSimple v23; // [sp+24h] [bp-9Ch] BYREF
  CTaskSimpleGangDriveBy v24; // [sp+2Ch] [bp-94h] BYREF
  CTask ppClosestPeds[10]; // [sp+70h] [bp-50h] BYREF

  CPedGroupIntelligence::FlushTasks(pGroupIntelligence, pGroupIntelligence->m_pedTaskPairs, 0);
  CPedGroupIntelligence::FlushTasks(pGroupIntelligence, pGroupIntelligence->m_secondaryPedTaskPairs, 0);
  v21 = (CPedGroupIntelligence *)this;
  m_pThreatPed = this->m_pThreatPed;
  if ( m_pThreatPed )
  {
    m_pPedGroup = pGroupIntelligence->m_pPedGroup;
    p_m_membership = &pGroupIntelligence->m_pPedGroup->m_membership;
    TaskByType = CTaskManager::FindTaskByType(&m_pThreatPed->m_pPedIntelligence->m_taskManager, 3, 243);
    if ( TaskByType )
    {
      m_pParent = (int)TaskByType[1].m_pParent;
      v8 = &CPedGroups::ms_groups[m_pParent];
      if ( v8 == m_pPedGroup )
        return;
      v22 = pGroupIntelligence;
      CTaskAllocatorKillThreatsBasic::ComputeClosestPeds(m_pPedGroup, v8, (CPed **)ppClosestPeds);
      for ( i = 0; i != 8; ++i )
      {
        Member = CPedGroupMembership::GetMember(p_m_membership, i);
        v11 = Member;
        if ( Member && !CPed::IsPlayer(Member) )
        {
          if ( *((unsigned __int8 *)&v11->m_nPedFlags + 1) << 31 )
          {
            if ( v11->m_pMyVehicle->pDriver != v11 )
            {
              CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(
                &v24,
                *((CEntity **)&ppClosestPeds[0]._vptr$CTask + i),
                0,
                60.0,
                90,
                8,
                0);
              CTaskSimple::CTaskSimple(&v23);
              v23._vptr$CTask = (int (**)(void))&off_668FF0;
              CPedGroupIntelligence::SetEventResponseTask(v22, v11, 1, &v24, 0, &v23, -1);
              CTask::~CTask(&v23);
              CTaskSimpleGangDriveBy::~CTaskSimpleGangDriveBy(&v24);
            }
          }
          else
          {
            CTaskComplexKillPedGroupOnFoot::CTaskComplexKillPedGroupOnFoot(
              (CTaskComplexKillPedGroupOnFoot *)&v24,
              m_pParent,
              *((CPed **)&ppClosestPeds[0]._vptr$CTask + i));
            CTaskSimple::CTaskSimple(&v23);
            v23._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(v22, v11, 1, &v24, 0, &v23, -1);
            CTask::~CTask(&v23);
            CTaskComplexKillPedGroupOnFoot::~CTaskComplexKillPedGroupOnFoot((CTaskComplexKillPedGroupOnFoot *)&v24);
          }
        }
      }
      Leader = CPedGroupMembership::GetLeader(p_m_membership);
      v13 = EGangFight;
    }
    else
    {
      for ( j = 0; j != 8; ++j )
      {
        v15 = CPedGroupMembership::GetMember(p_m_membership, j);
        v16 = v15;
        if ( v15 && !CPed::IsPlayer(v15) )
        {
          if ( *((unsigned __int8 *)&v16->m_nPedFlags + 1) << 31 )
          {
            if ( v16->m_pMyVehicle->pDriver != v16 )
            {
              CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(
                &v24,
                (CEntity *)v21->m_pCurrentEvent,
                0,
                60.0,
                90,
                (int8)byte_8,
                0);
              CTaskSimple::CTaskSimple((CTaskSimple *)ppClosestPeds);
              ppClosestPeds[0]._vptr$CTask = (int (**)(void))&off_668FF0;
              CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v16, 1, &v24, 0, ppClosestPeds, -1);
              CTask::~CTask(ppClosestPeds);
              CTaskSimpleGangDriveBy::~CTaskSimpleGangDriveBy(&v24);
            }
          }
          else
          {
            CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)&v24);
            v17 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
            CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v17, (CPed *)v21->m_pCurrentEvent, -1, 0, 0, 0, 1);
            CTaskComplexSequence::AddTask((CTaskComplexSequence *)&v24, v17);
            v18 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
            v19 = rand();
            CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
              v18,
              ANIM_STD_PED,
              ANIM_STD_IDLE_HBHB,
              4.0,
              -4.0,
              (int)(float)((float)((float)v19 * 0.000015259) * 1000.0) + 1000,
              422,
              "LookAbout",
              0);
            v18->_vptr$CTask = (int (**)(void))&off_665898;
            CTaskComplexSequence::AddTask((CTaskComplexSequence *)&v24, v18);
            CTaskSimple::CTaskSimple((CTaskSimple *)ppClosestPeds);
            ppClosestPeds[0]._vptr$CTask = (int (**)(void))&off_668FF0;
            CPedGroupIntelligence::SetEventResponseTask(pGroupIntelligence, v16, 1, &v24, 0, ppClosestPeds, -1);
            CTask::~CTask(ppClosestPeds);
            CTaskComplexSequence::~CTaskComplexSequence((CTaskComplexSequence *)&v24);
          }
        }
      }
      Leader = CPedGroupMembership::GetLeader(p_m_membership);
      v13 = EGangAttackingPed;
    }
    CInterestingEvents::Add(&g_InterestingEvents, v13, Leader);
  }
}
// 665898: using guessed type void *off_665898;
// 668FF0: using guessed type void *off_668FF0;
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (0054B3F8) --------------------------------------------------------
void __fastcall CTaskAllocatorAttack::~CTaskAllocatorAttack(CTaskAllocatorAttack *this)
{
  CPed *m_pTarget; // r0
  CEntity **p_m_pTarget; // r1
  CPed *m_pOriginator; // r0

  p_m_pTarget = &this->m_pTarget;
  m_pTarget = this->m_pTarget;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D558;
  if ( m_pTarget )
    CEntity::CleanUpOldReference(m_pTarget, p_m_pTarget);
  m_pOriginator = this->m_pOriginator;
  if ( m_pOriginator )
    CEntity::CleanUpOldReference(m_pOriginator, &this->m_pOriginator);
}
// 66D558: using guessed type void *off_66D558;

//----- (0054B42C) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasic::~CTaskAllocatorKillThreatsBasic(CTaskAllocatorKillThreatsBasic *this)
{
  CPed *m_pThreatPed; // r0
  CEntity **p_m_pThreatPed; // r1

  p_m_pThreatPed = &this->m_pThreatPed;
  m_pThreatPed = this->m_pThreatPed;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5A0;
  if ( m_pThreatPed )
    CEntity::CleanUpOldReference(m_pThreatPed, p_m_pThreatPed);
}
// 66D5A0: using guessed type void *off_66D5A0;

//----- (0054B456) --------------------------------------------------------
CTaskAllocator *__fastcall CTaskAllocator::ProcessGroup(
        CTaskAllocator *this,
        CPedGroupIntelligence *pGroupIntelligence)
{
  return 0;
}

//----- (0054B45C) --------------------------------------------------------
void __fastcall CTaskAllocatorRetreat::~CTaskAllocatorRetreat(CTaskAllocatorRetreat *this)
{
  CTaskAllocatorPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pTaskAllocatorPool;
  v2 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (0054B484) --------------------------------------------------------
int __fastcall CTaskAllocatorRetreat::GetType(const CTaskAllocatorRetreat *this)
{
  return 2;
}

//----- (0054B488) --------------------------------------------------------
void __fastcall CTaskAllocatorPlayerCommandAttack::~CTaskAllocatorPlayerCommandAttack(
        CTaskAllocatorPlayerCommandAttack *this)
{
  CPed *m_pTarget; // r0
  CEntity **p_m_pTarget; // r1
  CPed *m_pOriginator; // r0
  CTaskAllocatorPool *v5; // r0
  int v6; // r1

  p_m_pTarget = &this->m_pTarget;
  m_pTarget = this->m_pTarget;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D558;
  if ( m_pTarget )
    CEntity::CleanUpOldReference(m_pTarget, p_m_pTarget);
  m_pOriginator = this->m_pOriginator;
  if ( m_pOriginator )
    CEntity::CleanUpOldReference(m_pOriginator, &this->m_pOriginator);
  v5 = CPools::ms_pTaskAllocatorPool;
  v6 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v6] |= 0x80u;
  if ( v6 < v5->m_nFreeIndex )
    v5->m_nFreeIndex = v6;
}
// 66D558: using guessed type void *off_66D558;

//----- (0054B4E0) --------------------------------------------------------
int __fastcall CTaskAllocatorPlayerCommandAttack::GetType(const CTaskAllocatorPlayerCommandAttack *this)
{
  return 6;
}

//----- (0054B4E8) --------------------------------------------------------
void __fastcall CTaskAllocatorPlayerCommandRetreat::~CTaskAllocatorPlayerCommandRetreat(
        CTaskAllocatorPlayerCommandRetreat *this)
{
  CTaskAllocatorPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pTaskAllocatorPool;
  v2 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (0054B510) --------------------------------------------------------
int __fastcall CTaskAllocatorPlayerCommandRetreat::GetType(const CTaskAllocatorPlayerCommandRetreat *this)
{
  return 7;
}

//----- (0054B514) --------------------------------------------------------
void __fastcall CTaskAllocatorKillThreatsBasicRandomGroup::~CTaskAllocatorKillThreatsBasicRandomGroup(
        CTaskAllocatorKillThreatsBasicRandomGroup *this)
{
  CPed *m_pThreatPed; // r0
  CEntity **p_m_pThreatPed; // r1
  CTaskAllocatorPool *v4; // r0
  int v5; // r1

  p_m_pThreatPed = &this->m_pThreatPed;
  m_pThreatPed = this->m_pThreatPed;
  this->_vptr$CTaskAllocator = (int (**)(void))&off_66D5A0;
  if ( m_pThreatPed )
    CEntity::CleanUpOldReference(m_pThreatPed, p_m_pThreatPed);
  v4 = CPools::ms_pTaskAllocatorPool;
  v5 = ((char *)this - (char *)CPools::ms_pTaskAllocatorPool->m_aStorage) >> 5;
  CPools::ms_pTaskAllocatorPool->m_aFlags[v5] |= 0x80u;
  if ( v5 < v4->m_nFreeIndex )
    v4->m_nFreeIndex = v5;
}
// 66D5A0: using guessed type void *off_66D5A0;

//----- (0054B55C) --------------------------------------------------------
int __fastcall CTaskAllocatorKillThreatsBasicRandomGroup::GetType(
        const CTaskAllocatorKillThreatsBasicRandomGroup *this)
{
  return 10;
}

//----- (0054B560) --------------------------------------------------------
int __fastcall CTaskAllocatorKillOnFoot::GetType(const CTaskAllocatorKillOnFoot *this)
{
  return 4;
}

//----- (0054B564) --------------------------------------------------------
int __fastcall CTaskAllocatorAttack::GetType(const CTaskAllocatorAttack *this)
{
  return 1;
}

//----- (0054B568) --------------------------------------------------------
int __fastcall CTaskAllocatorKillThreatsBasic::GetType(const CTaskAllocatorKillThreatsBasic *this)
{
  return 9;
}

//----- (0054B56C) --------------------------------------------------------
int __fastcall CTaskAllocatorKillThreatsDriveby::GetType(const CTaskAllocatorKillThreatsDriveby *this)
{
  return 11;
}

//----- (0054B570) --------------------------------------------------------
void CMessages::Init()
{
  int v0; // r2
  _BOOL4 v1; // r1
  CPreviousMessage *v2; // r0

  CMessages::BriefMessages[0].pShortMessage = 0;
  CMessages::BriefMessages[0].pMessage = 0;
  CMessages::BriefMessages[1].pShortMessage = 0;
  CMessages::BriefMessages[1].pMessage = 0;
  CMessages::BriefMessages[2].pShortMessage = 0;
  CMessages::BriefMessages[2].pMessage = 0;
  CMessages::BriefMessages[3].pShortMessage = 0;
  CMessages::BriefMessages[3].pMessage = 0;
  CMessages::BriefMessages[4].pShortMessage = 0;
  CMessages::BriefMessages[4].pMessage = 0;
  CMessages::BriefMessages[5].pShortMessage = 0;
  CMessages::BriefMessages[5].pMessage = 0;
  CMessages::BriefMessages[6].pShortMessage = 0;
  CMessages::BriefMessages[6].pMessage = 0;
  CMessages::BriefMessages[7].pShortMessage = 0;
  CMessages::BriefMessages[7].pMessage = 0;
  CMessages::BIGMessages[0][0].pShortMessage = 0;
  CMessages::BIGMessages[0][0].pMessage = 0;
  CMessages::BIGMessages[0][1].pShortMessage = 0;
  CMessages::BIGMessages[0][1].pMessage = 0;
  CMessages::BIGMessages[0][2].pShortMessage = 0;
  CMessages::BIGMessages[0][2].pMessage = 0;
  CMessages::BIGMessages[0][3].pShortMessage = 0;
  CMessages::BIGMessages[0][3].pMessage = 0;
  CMessages::BIGMessages[1][0].pShortMessage = 0;
  CMessages::BIGMessages[1][0].pMessage = 0;
  CMessages::BIGMessages[1][1].pShortMessage = 0;
  CMessages::BIGMessages[1][1].pMessage = 0;
  CMessages::BIGMessages[1][2].pShortMessage = 0;
  CMessages::BIGMessages[1][2].pMessage = 0;
  CMessages::BIGMessages[1][3].pShortMessage = 0;
  CMessages::BIGMessages[1][3].pMessage = 0;
  CMessages::BIGMessages[2][0].pShortMessage = 0;
  CMessages::BIGMessages[2][0].pMessage = 0;
  CMessages::BIGMessages[2][1].pShortMessage = 0;
  CMessages::BIGMessages[2][1].pMessage = 0;
  CMessages::BIGMessages[2][2].pShortMessage = 0;
  CMessages::BIGMessages[2][2].pMessage = 0;
  CMessages::BIGMessages[2][3].pShortMessage = 0;
  CMessages::BIGMessages[2][3].pMessage = 0;
  CMessages::BIGMessages[3][0].pShortMessage = 0;
  CMessages::BIGMessages[3][0].pMessage = 0;
  CMessages::BIGMessages[3][1].pShortMessage = 0;
  CMessages::BIGMessages[3][1].pMessage = 0;
  CMessages::BIGMessages[3][2].pShortMessage = 0;
  CMessages::BIGMessages[3][2].pMessage = 0;
  CMessages::BIGMessages[3][3].pShortMessage = 0;
  CMessages::BIGMessages[3][3].pMessage = 0;
  CMessages::BIGMessages[4][0].pShortMessage = 0;
  CMessages::BIGMessages[4][0].pMessage = 0;
  CMessages::BIGMessages[4][1].pShortMessage = 0;
  CMessages::BIGMessages[4][1].pMessage = 0;
  CMessages::BIGMessages[4][2].pShortMessage = 0;
  CMessages::BIGMessages[4][2].pMessage = 0;
  CMessages::BIGMessages[4][3].pShortMessage = 0;
  CMessages::BIGMessages[4][3].pMessage = 0;
  CMessages::BIGMessages[5][0].pShortMessage = 0;
  CMessages::BIGMessages[5][0].pMessage = 0;
  CMessages::BIGMessages[5][1].pShortMessage = 0;
  CMessages::BIGMessages[5][1].pMessage = 0;
  CMessages::BIGMessages[5][2].pShortMessage = 0;
  CMessages::BIGMessages[5][2].pMessage = 0;
  CMessages::BIGMessages[5][3].pShortMessage = 0;
  CMessages::BIGMessages[5][3].pMessage = 0;
  CMessages::BIGMessages[6][0].pShortMessage = 0;
  CMessages::BIGMessages[6][0].pMessage = 0;
  CMessages::BIGMessages[6][1].pShortMessage = 0;
  CMessages::BIGMessages[6][1].pMessage = 0;
  CMessages::BIGMessages[6][2].pShortMessage = 0;
  CMessages::BIGMessages[6][2].pMessage = 0;
  CMessages::BIGMessages[6][3].pShortMessage = 0;
  CMessages::BIGMessages[6][3].pMessage = 0;
  CMessages::BIGMessages[7][0].pShortMessage = 0;
  CMessages::BIGMessages[7][0].pMessage = 0;
  CMessages::BIGMessages[7][1].pShortMessage = 0;
  CMessages::BIGMessages[7][1].pMessage = 0;
  CMessages::BIGMessages[7][2].pShortMessage = 0;
  CMessages::BIGMessages[7][2].pMessage = 0;
  CMessages::BIGMessages[7][3].pShortMessage = 0;
  CMessages::BIGMessages[7][3].pMessage = 0;
  v0 = 0;
  v1 = SkipBriefsClear;
  do
  {
    v2 = &CMessages::PreviousBriefs[v0];
    if ( !v1 )
      CMessages::PreviousBriefs[v0].TextLabel[0] = 0;
    ++v0;
    v2->pShortMessage = 0;
    v2->pMessage = 0;
  }
  while ( v0 != 20 );
}

//----- (0054B710) --------------------------------------------------------
void CMessages::ClearPreviousBriefArray()
{
  int v0; // r2
  _BOOL4 v1; // lr
  CPreviousMessage *v2; // r0

  v0 = 0;
  v1 = SkipBriefsClear;
  do
  {
    v2 = &CMessages::PreviousBriefs[v0];
    if ( !v1 )
      CMessages::PreviousBriefs[v0].TextLabel[0] = 0;
    ++v0;
    v2->pShortMessage = 0;
    v2->pMessage = 0;
  }
  while ( v0 != 20 );
}

//----- (0054B75C) --------------------------------------------------------
UInt16 __fastcall CMessages::GetGxtStringLength(GxtChar *pGxtString)
{
  UInt16 result; // r0
  GxtChar *v2; // r1
  int v3; // t1

  if ( !*pGxtString )
    return 0;
  v2 = pGxtString + 1;
  result = 0;
  do
  {
    v3 = *v2++;
    ++result;
  }
  while ( v3 );
  return result;
}

//----- (0054B77A) --------------------------------------------------------
void __fastcall CMessages::GxtStringCopy(GxtChar *pDest, GxtChar *pSource, UInt16 MaxLength)
{
  int v3; // r5
  int v4; // r3
  unsigned __int16 v5; // r2
  int v6; // lr
  unsigned int v7; // r2
  int v8; // r1
  bool v9; // zf
  int v10; // r2
  GxtChar *v11; // r3

  v3 = MaxLength - 1;
  if ( !pSource )
  {
    if ( MaxLength >= 2u )
    {
      if ( (unsigned int)v3 < 8 || (v6 = (MaxLength + 7) & 7, v3 == v6) )
      {
        v8 = 0;
        v5 = 0;
      }
      else
      {
        v7 = MaxLength - 2;
        v8 = 0;
        if ( (unsigned __int16)v7 == 0xFFFF )
        {
          v5 = 0;
        }
        else
        {
          v9 = HIWORD(v7) == 0;
          v5 = 0;
          if ( v9 )
          {
            v8 = v3 - v6;
            v10 = v3 - v6;
            v11 = pDest;
            do
            {
              *(_QWORD *)v11 = 0LL;
              *((_QWORD *)v11 + 1) = 0LL;
              v11 += 8;
              v10 -= 8;
            }
            while ( v10 );
            v5 = v3 - v6;
            if ( !v6 )
              goto LABEL_20;
          }
        }
      }
      do
      {
        ++v5;
        pDest[v8] = 0;
        v8 = v5;
      }
      while ( v3 > v5 );
      goto LABEL_20;
    }
LABEL_17:
    v5 = 0;
    goto LABEL_20;
  }
  if ( MaxLength < 2u )
    goto LABEL_17;
  v4 = 0;
  v5 = 0;
  do
  {
    if ( !pSource[v4] )
      break;
    ++v5;
    pDest[v4] = pSource[v4];
    v4 = v5;
  }
  while ( v3 > v5 );
LABEL_20:
  pDest[v5] = 0;
}

//----- (0054B814) --------------------------------------------------------
Bool8 __fastcall CMessages::GxtStringCompare(GxtChar *pGxtString1, GxtChar *pGxtString2, UInt16 NumOfCharsToCompare)
{
  int v3; // r12
  GxtChar *v4; // r4
  unsigned __int16 v5; // r3
  int v6; // t1
  GxtChar *v7; // r5
  unsigned __int16 v8; // r4
  int v9; // t1
  bool v10; // cf
  Bool8 v11; // r6
  bool v12; // zf
  unsigned __int16 v13; // r4
  int v14; // r3
  int v15; // r6

  v3 = *pGxtString1;
  if ( *pGxtString1 )
  {
    v4 = pGxtString1 + 1;
    v5 = 0;
    do
    {
      v6 = *v4++;
      ++v5;
    }
    while ( v6 );
  }
  else
  {
    v5 = 0;
  }
  if ( *pGxtString2 )
  {
    v7 = pGxtString2 + 1;
    v8 = 0;
    do
    {
      v9 = *v7++;
      ++v8;
    }
    while ( v9 );
  }
  else
  {
    v8 = 0;
  }
  if ( v5 == v8 )
    goto LABEL_18;
  v10 = (unsigned int)v5 >= NumOfCharsToCompare;
  v11 = 0;
  if ( (unsigned int)v5 >= NumOfCharsToCompare )
    v10 = (unsigned int)v8 >= NumOfCharsToCompare;
  if ( v10 )
  {
LABEL_18:
    v12 = NumOfCharsToCompare == 0;
    v11 = 1;
    if ( NumOfCharsToCompare )
      v12 = v3 == 0;
    if ( !v12 )
    {
      if ( v3 == *pGxtString2 )
      {
        v13 = 1;
        while ( 1 )
        {
          v11 = 1;
          if ( (unsigned int)v13 >= NumOfCharsToCompare )
            break;
          v14 = pGxtString1[v13];
          if ( !pGxtString1[v13] )
            break;
          v15 = pGxtString2[v13++];
          if ( v14 != v15 )
            return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v11;
}

//----- (0054B8A0) --------------------------------------------------------
void CMessages::Process()
{
  unsigned int v0; // r6
  UInt32 v1; // r9
  int v2; // r1
  CQueuedMessage *v3; // r1
  __int64 v4; // d17
  CQueuedMessage *v5; // r4
  Int32 *p_NumberToInsert3; // r3
  __int64 v7; // d18
  __int64 v8; // d19
  __int64 v9; // d22
  __int64 v10; // d20
  __int64 v11; // d21
  GxtChar *pMessage; // r0
  UInt32 *p_Duration; // r1
  __int64 v14; // d17
  CQueuedMessage *v15; // r1
  __int64 v16; // d20
  __int64 v17; // d21
  __int64 v18; // d18
  __int64 v19; // d19
  __int64 v20; // d22
  UInt32 *v21; // r4
  __int64 v22; // d17
  __int64 v23; // d18
  __int64 v24; // d19
  __int64 v25; // d22
  __int64 v26; // d20
  __int64 v27; // d21
  UInt32 *v28; // r1
  int v29; // r2
  bool v30; // zf

  v0 = 0;
  v1 = CTimer::m_snTimeInMilliseconds;
  do
  {
    if ( CMessages::BIGMessages[v0 / 0xE0][0].pMessage
      && v1 > CMessages::BIGMessages[v0 / 0xE0][0].Duration + CMessages::BIGMessages[v0 / 0xE0][0].WhenStarted )
    {
      v2 = 0;
      CMessages::BIGMessages[v0 / 0xE0][0].pMessage = 0;
      if ( CMessages::BIGMessages[v0 / 0xE0][1].pMessage )
      {
        v3 = CMessages::BIGMessages[v0 / 0xE0];
        v4 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].NumberToInsert5;
        v5 = &CMessages::BIGMessages[v0 / 0xE0][1];
        p_NumberToInsert3 = &CMessages::BIGMessages[v0 / 0xE0][0].NumberToInsert3;
        v7 = *(_QWORD *)v5->TextLabel;
        v8 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].pMessage;
        v9 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].pShortMessage;
        v10 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].Duration;
        v11 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].NumberToInsert;
        pMessage = CMessages::BIGMessages[v0 / 0xE0][2].pMessage;
        *(_QWORD *)p_NumberToInsert3 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].NumberToInsert3;
        *((_QWORD *)p_NumberToInsert3 + 1) = v4;
        *(_QWORD *)&v3->pShortMessage = v9;
        *(_QWORD *)v3->TextLabel = v7;
        *(_QWORD *)&v3->pMessage = v8;
        p_Duration = &CMessages::BIGMessages[v0 / 0xE0][0].Duration;
        *(_QWORD *)p_Duration = v10;
        *((_QWORD *)p_Duration + 1) = v11;
        if ( pMessage )
        {
          v14 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].NumberToInsert5;
          v15 = &CMessages::BIGMessages[v0 / 0xE0][2];
          v16 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].Duration;
          v17 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].NumberToInsert;
          v18 = *(_QWORD *)v15->TextLabel;
          v19 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].pMessage;
          v20 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].pShortMessage;
          *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].NumberToInsert3 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].NumberToInsert3;
          *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].NumberToInsert5 = v14;
          *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].pShortMessage = v20;
          *(_QWORD *)v5->TextLabel = v18;
          *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][1].pMessage = v19;
          v21 = &CMessages::BIGMessages[v0 / 0xE0][1].Duration;
          *(_QWORD *)v21 = v16;
          *((_QWORD *)v21 + 1) = v17;
          if ( CMessages::BIGMessages[v0 / 0xE0][3].pMessage )
          {
            v22 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][3].NumberToInsert5;
            v23 = *(_QWORD *)CMessages::BIGMessages[v0 / 0xE0][3].TextLabel;
            v24 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][3].pMessage;
            v25 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][3].pShortMessage;
            v26 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][3].Duration;
            v27 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][3].NumberToInsert;
            *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].NumberToInsert3 = *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][3].NumberToInsert3;
            *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].NumberToInsert5 = v22;
            *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].pShortMessage = v25;
            *(_QWORD *)v15->TextLabel = v23;
            *(_QWORD *)&CMessages::BIGMessages[v0 / 0xE0][2].pMessage = v24;
            v28 = &CMessages::BIGMessages[v0 / 0xE0][2].Duration;
            *(_QWORD *)v28 = v26;
            *((_QWORD *)v28 + 1) = v27;
            v2 = 3;
          }
          else
          {
            v2 = 2;
          }
        }
        else
        {
          v2 = 1;
        }
      }
      CMessages::BIGMessages[0][v2 + v0 / 0x38].pMessage = 0;
      CMessages::BIGMessages[v0 / 0xE0][0].WhenStarted = v1;
    }
    v0 += 224;
  }
  while ( v0 != 1792 );
  if ( CMessages::BriefMessages[0].pMessage
    && v1 > CMessages::BriefMessages[0].WhenStarted + CMessages::BriefMessages[0].Duration )
  {
    CMessages::BriefMessages[0].pMessage = 0;
    if ( CMessages::BriefMessages[1].pMessage )
    {
      CMessages::BriefMessages[0] = CMessages::BriefMessages[1];
      if ( CMessages::BriefMessages[2].pMessage )
      {
        CMessages::BriefMessages[1] = CMessages::BriefMessages[2];
        if ( CMessages::BriefMessages[3].pMessage )
        {
          CMessages::BriefMessages[2] = CMessages::BriefMessages[3];
          if ( CMessages::BriefMessages[4].pMessage )
          {
            CMessages::BriefMessages[3] = CMessages::BriefMessages[4];
            if ( CMessages::BriefMessages[5].pMessage )
            {
              CMessages::BriefMessages[4] = CMessages::BriefMessages[5];
              if ( CMessages::BriefMessages[6].pMessage )
              {
                CMessages::BriefMessages[5] = CMessages::BriefMessages[6];
                if ( CMessages::BriefMessages[7].pMessage )
                {
                  CMessages::BriefMessages[6] = CMessages::BriefMessages[7];
                  v29 = 7;
                }
                else
                {
                  v29 = 6;
                }
              }
              else
              {
                v29 = 5;
              }
            }
            else
            {
              v29 = 4;
            }
          }
          else
          {
            v29 = 3;
          }
        }
        else
        {
          v29 = 2;
        }
      }
      else
      {
        v29 = 1;
      }
    }
    else
    {
      v29 = 0;
    }
    CMessages::BriefMessages[v29].pMessage = 0;
    v30 = CMessages::BriefMessages[0].pMessage == 0;
    CMessages::BriefMessages[0].WhenStarted = v1;
    if ( CMessages::BriefMessages[0].pMessage )
      v30 = CMessages::BriefMessages[0].bAddToPreviousBriefs == 0;
    if ( !v30 )
      CMessages::AddToPreviousBriefArray(
        CMessages::BriefMessages[0].TextLabel,
        CMessages::BriefMessages[0].pMessage,
        CMessages::BriefMessages[0].NumberToInsert,
        CMessages::BriefMessages[0].NumberToInsert2,
        CMessages::BriefMessages[0].NumberToInsert3,
        CMessages::BriefMessages[0].NumberToInsert4,
        CMessages::BriefMessages[0].NumberToInsert5,
        CMessages::BriefMessages[0].NumberToInsert6,
        CMessages::BriefMessages[0].pShortMessage);
  }
}

//----- (0054BCAC) --------------------------------------------------------
void __fastcall CMessages::AddToPreviousBriefArray(
        const unsigned __int8 *Label,
        GxtChar *pText,
        Int32 NumToInsert,
        Int32 NumToInsert2,
        Int32 NumToInsert3,
        Int32 NumToInsert4,
        Int32 NumToInsert5,
        Int32 NumToInsert6,
        GxtChar *pShortText)
{
  __int16 v13; // r1
  int v14; // r3
  Int32 *p_NumberToInsert3; // r2
  GxtChar *v16; // r6
  int v17; // r0
  bool v18; // zf
  Int32 v19; // r0
  bool v20; // zf
  bool v21; // zf
  __int16 v22; // r0
  int v23; // r2
  CPreviousMessage *v24; // r0
  __int64 v25; // d18
  __int64 v26; // d17
  __int64 v27; // d20
  __int64 v28; // d21
  Int32 *p_NumberToInsert2; // r1

  v13 = 0;
  v14 = 0;
  p_NumberToInsert3 = &CMessages::PreviousBriefs[0].NumberToInsert3;
  do
  {
    v16 = (GxtChar *)*(p_NumberToInsert3 - 3);
    if ( !v16 )
    {
      if ( !(v14 << 16) )
        goto LABEL_24;
      goto LABEL_21;
    }
    if ( *(p_NumberToInsert3 - 2) == NumToInsert )
    {
      v17 = *(p_NumberToInsert3 - 1);
      v18 = v17 == NumToInsert2;
      if ( v17 == NumToInsert2 )
        v18 = *p_NumberToInsert3 == NumToInsert3;
      if ( v18 )
      {
        v19 = p_NumberToInsert3[1];
        v20 = v19 == NumToInsert4;
        if ( v19 == NumToInsert4 )
          v20 = p_NumberToInsert3[2] == NumToInsert5;
        if ( v20 )
        {
          v21 = v16 == pText;
          if ( v16 == pText )
            v21 = p_NumberToInsert3[3] == NumToInsert6;
          if ( v21 && (GxtChar *)p_NumberToInsert3[4] == pShortText )
            return;
        }
      }
    }
    ++v14;
    p_NumberToInsert3 += 10;
    ++v13;
  }
  while ( (unsigned __int16)v14 < 0x14u );
  v13 = v14;
  if ( (unsigned __int16)v14 == 20 )
  {
    v22 = 18;
    goto LABEL_22;
  }
LABEL_21:
  v22 = v13 - 1;
  if ( (__int16)(v13 - 1) < 0 )
    goto LABEL_24;
LABEL_22:
  v23 = v22 + 1;
  v24 = &CMessages::PreviousBriefs[v22];
  do
  {
    v25 = *(_QWORD *)&v24->NumberToInsert6;
    v26 = *(_QWORD *)&v24->pMessage;
    --v23;
    v27 = *(_QWORD *)&v24->NumberToInsert2;
    v28 = *(_QWORD *)&v24->NumberToInsert4;
    *(_QWORD *)v24[1].TextLabel = *(_QWORD *)v24->TextLabel;
    *(_QWORD *)&v24[1].pMessage = v26;
    p_NumberToInsert2 = &v24[1].NumberToInsert2;
    *(_QWORD *)&v24[1].NumberToInsert6 = v25;
    --v24;
    *(_QWORD *)p_NumberToInsert2 = v27;
    *((_QWORD *)p_NumberToInsert2 + 1) = v28;
  }
  while ( v23 > 0 );
LABEL_24:
  if ( Label )
    strncpy((char *)CMessages::PreviousBriefs, (const char *)Label, 8u);
  else
    CMessages::PreviousBriefs[0].TextLabel[0] = 0;
  CMessages::PreviousBriefs[0].TextLabel[7] = 0;
  CMessages::PreviousBriefs[0].pMessage = pText;
  CMessages::PreviousBriefs[0].NumberToInsert = NumToInsert;
  CMessages::PreviousBriefs[0].NumberToInsert2 = NumToInsert2;
  CMessages::PreviousBriefs[0].NumberToInsert3 = NumToInsert3;
  CMessages::PreviousBriefs[0].NumberToInsert4 = NumToInsert4;
  CMessages::PreviousBriefs[0].NumberToInsert5 = NumToInsert5;
  CMessages::PreviousBriefs[0].NumberToInsert6 = NumToInsert6;
  CMessages::PreviousBriefs[0].pShortMessage = pShortText;
}

//----- (0054BDD4) --------------------------------------------------------
void __fastcall CMessages::Display(Bool8 bBeforeFade)
{
  int v1; // r8
  int v2; // r6
  UInt16 v3; // r4
  GxtChar v4[414]; // [sp+14h] [bp-33Ch] BYREF

  v1 = bBeforeFade;
  if ( bBeforeFade )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      CMessages::InsertNumberInString(
        CMessages::BIGMessages[v2][0].pMessage,
        CMessages::BIGMessages[v2][0].NumberToInsert,
        CMessages::BIGMessages[v2][0].NumberToInsert2,
        CMessages::BIGMessages[v2][0].NumberToInsert3,
        CMessages::BIGMessages[v2][0].NumberToInsert4,
        CMessages::BIGMessages[v2][0].NumberToInsert5,
        CMessages::BIGMessages[v2][0].NumberToInsert6,
        v4);
      CMessages::InsertStringInString(v4, CMessages::BIGMessages[v2][0].pShortMessage);
      CHud::SetBigMessage(v4, v3);
      ++v2;
      ++v3;
    }
    while ( v2 != 8 );
  }
  if ( CTheScripts::bDrawSubtitlesBeforeFade == v1 )
  {
    CMessages::InsertNumberInString(
      CMessages::BriefMessages[0].pMessage,
      CMessages::BriefMessages[0].NumberToInsert,
      CMessages::BriefMessages[0].NumberToInsert2,
      CMessages::BriefMessages[0].NumberToInsert3,
      CMessages::BriefMessages[0].NumberToInsert4,
      CMessages::BriefMessages[0].NumberToInsert5,
      CMessages::BriefMessages[0].NumberToInsert6,
      v4);
    CMessages::InsertStringInString(v4, CMessages::BriefMessages[0].pShortMessage);
    CHud::SetMessage(v4);
  }
}
// 54BDD4: using guessed type GxtChar var_33C[414];

//----- (0054BE84) --------------------------------------------------------
void __fastcall CMessages::InsertNumberInString(
        GxtChar *pOriginalString,
        Int32 NumberToInsert,
        Int32 NumberToInsert2,
        Int32 NumberToInsert3,
        Int32 NumberToInsert4,
        Int32 NumberToInsert5,
        Int32 NumberToInsert6,
        GxtChar *pNewString)
{
  GxtChar *v9; // r10
  size_t v12; // r9
  unsigned int v13; // r4
  int v15; // r5
  int v16; // r11
  unsigned int v17; // r9
  int v18; // lr
  GxtChar *v19; // r2
  GxtChar *v20; // r12
  int v21; // r0
  int v22; // r5
  int v23; // r3
  int v24; // r2
  Int32 v25; // [sp+8h] [bp-48h]
  size_t v26; // [sp+Ch] [bp-44h]
  GxtChar pOutput[11]; // [sp+10h] [bp-40h] BYREF
  unsigned __int8 s[8]; // [sp+26h] [bp-2Ah] BYREF

  v9 = pNewString;
  if ( pOriginalString )
  {
    sprintf(s, (const unsigned __int8 *)&dword_54BFF4, NumberToInsert);
    v12 = strlen((const char *)s);
    AsciiToGxtChar(s, pOutput);
    if ( !*pOriginalString )
      goto LABEL_24;
    v13 = 0;
    while ( pOriginalString[++v13] )
      ;
    if ( v13 )
    {
      v26 = v12;
      v25 = NumberToInsert3;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      do
      {
        v18 = v15;
        v19 = &pOriginalString[v17];
        v20 = &pNewString[v16];
        v21 = 0;
        v22 = 0;
        while ( 1 )
        {
          v23 = v19[v21];
          if ( v23 == 126 && v19[v22 + 1] == 49 && v19[v21 + 2] == 126 )
            break;
          v20[v22++] = v23;
          ++v21;
          if ( v17 + v22 >= v13 )
          {
            v16 += v22;
            goto LABEL_25;
          }
        }
        v24 = v17 + v22;
        if ( v26 )
        {
          qmemcpy(&v20[v21], pOutput, 2 * v26);
          v24 = v17 + v22;
          v16 += v26 + v22;
        }
        else
        {
          v16 += v22;
        }
        v17 = v24 + 3;
        v15 = v18 + 1;
        switch ( (char)v18 )
        {
          case 0:
            sprintf(s, (const unsigned __int8 *)&dword_54BFF4, NumberToInsert2);
            break;
          case 1:
            sprintf(s, (const unsigned __int8 *)&dword_54BFF4, v25);
            break;
          case 2:
            sprintf(s, (const unsigned __int8 *)&dword_54BFF4, NumberToInsert4);
            break;
          case 3:
            sprintf(s, (const unsigned __int8 *)&dword_54BFF4, NumberToInsert5);
            break;
          case 4:
            sprintf(s, (const unsigned __int8 *)&dword_54BFF4, NumberToInsert6);
            break;
          default:
            break;
        }
        v26 = strlen((const char *)s);
        AsciiToGxtChar(s, pOutput);
      }
      while ( v17 < v13 );
    }
    else
    {
LABEL_24:
      v16 = 0;
    }
LABEL_25:
    v9 = &pNewString[v16];
  }
  *v9 = 0;
}
// 54BFF4: using guessed type int dword_54BFF4;

//----- (0054BFFC) --------------------------------------------------------
void __fastcall CMessages::InsertStringInString(GxtChar *pBigString, GxtChar *pSmallString)
{
  GxtChar *v2; // r3
  unsigned __int16 v3; // r2
  int v4; // t1
  unsigned int v5; // lr
  int v6; // r10
  unsigned int v7; // r12
  int v8; // r5
  int v9; // r4
  int v10; // r9
  unsigned __int16 v11; // r8
  unsigned __int16 i; // r3
  int v13; // r10
  int v14; // r2
  GxtChar *v15; // r10
  int v16; // r4
  unsigned __int16 v17; // r3
  __int64 v18; // d16
  __int64 v19; // d17
  __int16 *v20; // r3
  int v21; // r4
  GxtChar *v22; // r10
  int v23; // r5
  __int16 v24; // t1
  int v25; // r3
  GxtChar *v26; // r6
  int v27; // r1
  unsigned int v28; // r1
  __int16 *v29; // r3
  unsigned int v30; // r5
  GxtChar *v31; // r2
  __int64 v32; // d16
  __int64 v33; // d17
  int v34; // [sp+0h] [bp-350h]
  unsigned int v35; // [sp+8h] [bp-348h]
  __int16 v37[414]; // [sp+14h] [bp-33Ch] BYREF

  if ( !pBigString || (unsigned int)pSmallString + 1 < 2 )
    return;
  if ( *pBigString )
  {
    v2 = pBigString + 1;
    v3 = 0;
    do
    {
      v4 = *v2++;
      ++v3;
    }
    while ( v4 );
  }
  else
  {
    v3 = 0;
  }
  if ( *pSmallString )
    v5 = wcslen(pSmallString + 1) + 1;
  else
    v5 = 0;
  v6 = (unsigned __int16)v5 + v3;
  v7 = (unsigned __int16)v6;
  if ( !(_WORD)v6 )
  {
    i = 0;
    v37[0] = 0;
    goto LABEL_45;
  }
  v8 = (unsigned __int16)v5 - (v5 & 7);
  v35 = (unsigned __int16)v5 - 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  do
  {
    v25 = pBigString[v11];
    if ( v25 == 126 )
    {
      v26 = &pBigString[v11];
      v27 = v8;
      if ( v26[1] == 97 && v26[2] == 126 )
      {
        v11 += 3;
        if ( !(v5 << 16) )
          goto LABEL_31;
        v34 = v6;
        v13 = 0;
        if ( (unsigned __int16)v5 >= 8u )
        {
          v14 = v10;
          if ( !v8 )
            goto LABEL_24;
          v13 = 0;
          if ( (unsigned __int16)(v10 + v35) == (unsigned __int16)v10 + (unsigned __int16)v35 )
          {
            v14 = v10;
            if ( !HIWORD(v35) )
            {
              v15 = pSmallString;
              v14 = v10 + v8;
              v16 = 0;
              do
              {
                v17 = v10 + v16;
                v16 += 8;
                v18 = *(_QWORD *)v15;
                v19 = *((_QWORD *)v15 + 1);
                v15 += 8;
                v20 = &v37[v17];
                *(_QWORD *)v20 = v18;
                *((_QWORD *)v20 + 1) = v19;
              }
              while ( v8 != v16 );
              v13 = v8;
              if ( (v5 & 7) == 0 )
                goto LABEL_26;
            }
            goto LABEL_24;
          }
        }
        v14 = v10;
LABEL_24:
        v21 = (unsigned __int16)v5 - v13;
        v22 = &pSmallString[v13];
        do
        {
          v23 = (unsigned __int16)v14;
          v24 = *v22++;
          --v21;
          ++v14;
          v37[v23] = v24;
        }
        while ( v21 );
LABEL_26:
        v6 = v34;
        v10 += v5;
        v8 = v27;
        goto LABEL_31;
      }
    }
    v37[v9] = v25;
    ++v11;
    ++v10;
LABEL_31:
    v9 = (unsigned __int16)v10;
  }
  while ( v7 > (unsigned __int16)v10 );
  i = 0;
  v37[(unsigned __int16)v10] = 0;
  if ( !v7 )
    goto LABEL_45;
  if ( v7 <= 7 || v7 == (v6 & 7) )
  {
    v28 = 0;
    goto LABEL_42;
  }
  v28 = 0;
  if ( (unsigned __int16)(v7 - 1) == 0xFFFF )
  {
LABEL_42:
    for ( i = 0; i < v7; v28 = i )
    {
LABEL_43:
      ++i;
      pBigString[v28] = v37[v28];
    }
    goto LABEL_44;
  }
  i = 0;
  if ( (v7 - 1) >> 16 )
    goto LABEL_43;
  v28 = v7 - (v6 & 7);
  v29 = v37;
  v30 = v28;
  v31 = pBigString;
  do
  {
    v32 = *(_QWORD *)v29;
    v33 = *((_QWORD *)v29 + 1);
    v29 += 8;
    v30 -= 8;
    *(_QWORD *)v31 = v32;
    *((_QWORD *)v31 + 1) = v33;
    v31 += 8;
  }
  while ( v30 );
  i = v7 - (v6 & 7);
  if ( (v6 & 7) != 0 )
    goto LABEL_43;
LABEL_44:
  if ( (unsigned __int16)(i >> 4) <= 0x18u )
LABEL_45:
    memset(&pBigString[i], 0, 2 * (unsigned __int16)(399 - i) + 2);
}
// 54BFFC: using guessed type __int16 var_33C[414];

//----- (0054C1E0) --------------------------------------------------------
Int16 __fastcall CMessages::CutString(Int16 CharNum, unsigned __int8 *pInString, unsigned __int8 **ppCutStrings)
{
  int v4; // r9
  size_t v6; // r0
  int v7; // r3
  int v8; // r4
  int v9; // r6
  Int16 v10; // r10
  __int16 v11; // r2
  __int16 v12; // r4

  v4 = CharNum;
  v6 = strlen((const char *)pInString);
  if ( (int)(v6 << 16) < 1 )
    return 0;
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = v8 + v4;
    v10 = v7 + 1;
    v11 = v6;
    ppCutStrings[v7] = &pInString[v8];
    if ( v8 + v4 < (__int16)v6 )
    {
      do
        v12 = v9--;
      while ( pInString[v12] != 32 );
      pInString[v12] = 0;
      v11 = v12 + 1;
    }
    v8 = v11;
    if ( (__int16)v6 <= v11 )
      break;
  }
  while ( v7++ < 7 );
  return v10;
}

//----- (0054C24C) --------------------------------------------------------
void __fastcall CMessages::AddMessage(
        const unsigned __int8 *Label,
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Colour,
        int a5)
{
  GxtChar **p_pMessage; // r4
  int v10; // r11
  int v11; // r0
  int v12; // r5
  CQueuedMessage *v13; // r0
  uint32 v14; // r1
  CQueuedMessage *v15; // r0

  p_pMessage = &CMessages::BriefMessages[0].pMessage;
  if ( CMessages::BriefMessages[0].pMessage )
  {
    p_pMessage = &CMessages::BriefMessages[1].pMessage;
    if ( CMessages::BriefMessages[1].pMessage )
    {
      p_pMessage = &CMessages::BriefMessages[2].pMessage;
      if ( CMessages::BriefMessages[2].pMessage )
      {
        p_pMessage = &CMessages::BriefMessages[3].pMessage;
        if ( CMessages::BriefMessages[3].pMessage )
        {
          p_pMessage = &CMessages::BriefMessages[4].pMessage;
          if ( CMessages::BriefMessages[4].pMessage )
          {
            if ( CMessages::BriefMessages[5].pMessage )
            {
              if ( CMessages::BriefMessages[6].pMessage )
              {
                if ( CMessages::BriefMessages[7].pMessage )
                  return;
                p_pMessage = &CMessages::BriefMessages[7].pMessage;
                v10 = 1;
                v11 = 7;
              }
              else
              {
                p_pMessage = &CMessages::BriefMessages[6].pMessage;
                v10 = 1;
                v11 = 6;
              }
            }
            else
            {
              p_pMessage = &CMessages::BriefMessages[5].pMessage;
              v10 = 1;
              v11 = 5;
            }
          }
          else
          {
            v10 = 1;
            v11 = 4;
          }
        }
        else
        {
          v10 = 1;
          v11 = 3;
        }
      }
      else
      {
        v10 = 1;
        v11 = 2;
      }
    }
    else
    {
      v11 = 1;
      v10 = 1;
    }
  }
  else
  {
    v11 = 0;
    v10 = 0;
  }
  v12 = v11;
  v13 = &CMessages::BriefMessages[v11];
  if ( Label )
    strncpy((char *)v13, (const char *)Label, 8u);
  else
    v13->TextLabel[0] = 0;
  v14 = CTimer::m_snTimeInMilliseconds;
  v15 = &CMessages::BriefMessages[v12];
  v15->TextLabel[7] = 0;
  *p_pMessage = pText;
  v15->Colour = Colour;
  v15->pShortMessage = 0;
  v15->bAddToPreviousBriefs = a5;
  v15->Duration = Duration;
  v15->WhenStarted = v14;
  v15->NumberToInsert = -1;
  v15->NumberToInsert2 = -1;
  v15->NumberToInsert3 = -1;
  v15->NumberToInsert4 = -1;
  v15->NumberToInsert5 = -1;
  v15->NumberToInsert6 = -1;
  if ( !v10 )
  {
    if ( a5 )
      CMessages::AddToPreviousBriefArray(
        CMessages::BriefMessages[0].TextLabel,
        CMessages::BriefMessages[0].pMessage,
        CMessages::BriefMessages[0].NumberToInsert,
        CMessages::BriefMessages[0].NumberToInsert2,
        CMessages::BriefMessages[0].NumberToInsert3,
        CMessages::BriefMessages[0].NumberToInsert4,
        CMessages::BriefMessages[0].NumberToInsert5,
        CMessages::BriefMessages[0].NumberToInsert6,
        CMessages::BriefMessages[0].pShortMessage);
  }
}

//----- (0054C3C8) --------------------------------------------------------
void __fastcall CMessages::AddMessageJumpQ(
        const unsigned __int8 *Label,
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Colour,
        int a5)
{
  if ( Label )
    strncpy((char *)CMessages::BriefMessages, (const char *)Label, 8u);
  else
    CMessages::BriefMessages[0].TextLabel[0] = 0;
  CMessages::BriefMessages[0].pMessage = pText;
  CMessages::BriefMessages[0].TextLabel[7] = 0;
  CMessages::BriefMessages[0].Colour = Colour;
  CMessages::BriefMessages[0].pShortMessage = 0;
  CMessages::BriefMessages[0].bAddToPreviousBriefs = a5;
  CMessages::BriefMessages[0].Duration = Duration;
  CMessages::BriefMessages[0].WhenStarted = CTimer::m_snTimeInMilliseconds;
  CMessages::BriefMessages[0].NumberToInsert = -1;
  CMessages::BriefMessages[0].NumberToInsert2 = -1;
  CMessages::BriefMessages[0].NumberToInsert3 = -1;
  CMessages::BriefMessages[0].NumberToInsert4 = -1;
  CMessages::BriefMessages[0].NumberToInsert5 = -1;
  CMessages::BriefMessages[0].NumberToInsert6 = -1;
  if ( a5 )
    CMessages::AddToPreviousBriefArray(CMessages::BriefMessages[0].TextLabel, pText, -1, -1, -1, -1, -1, -1, 0);
}

//----- (0054C46C) --------------------------------------------------------
void __fastcall CMessages::ClearMessages(bool8 bIgnoreMissionTitle)
{
  CMessages::BIGMessages[0][0].pShortMessage = 0;
  CMessages::BIGMessages[0][0].pMessage = 0;
  CMessages::BIGMessages[0][1].pShortMessage = 0;
  CMessages::BIGMessages[0][1].pMessage = 0;
  CMessages::BIGMessages[0][2].pMessage = 0;
  CMessages::BIGMessages[0][2].pShortMessage = 0;
  CMessages::BIGMessages[0][3].pMessage = 0;
  CMessages::BIGMessages[0][3].pShortMessage = 0;
  if ( !bIgnoreMissionTitle )
  {
    CMessages::BIGMessages[1][0].pShortMessage = 0;
    CMessages::BIGMessages[1][0].pMessage = 0;
    CMessages::BIGMessages[1][1].pShortMessage = 0;
    CMessages::BIGMessages[1][1].pMessage = 0;
    CMessages::BIGMessages[1][2].pShortMessage = 0;
    CMessages::BIGMessages[1][2].pMessage = 0;
    CMessages::BIGMessages[1][3].pShortMessage = 0;
    CMessages::BIGMessages[1][3].pMessage = 0;
  }
  CMessages::BIGMessages[2][0].pShortMessage = 0;
  CMessages::BIGMessages[2][0].pMessage = 0;
  CMessages::BIGMessages[2][1].pShortMessage = 0;
  CMessages::BIGMessages[2][1].pMessage = 0;
  CMessages::BIGMessages[2][2].pMessage = 0;
  CMessages::BIGMessages[2][2].pShortMessage = 0;
  CMessages::BIGMessages[2][3].pMessage = 0;
  CMessages::BIGMessages[2][3].pShortMessage = 0;
  CMessages::BIGMessages[3][0].pMessage = 0;
  CMessages::BIGMessages[3][0].pShortMessage = 0;
  CMessages::BIGMessages[3][1].pShortMessage = 0;
  CMessages::BIGMessages[3][1].pMessage = 0;
  CMessages::BIGMessages[3][2].pShortMessage = 0;
  CMessages::BIGMessages[3][2].pMessage = 0;
  CMessages::BIGMessages[3][3].pShortMessage = 0;
  CMessages::BIGMessages[3][3].pMessage = 0;
  if ( !bIgnoreMissionTitle )
  {
    CMessages::BIGMessages[4][0].pShortMessage = 0;
    CMessages::BIGMessages[4][0].pMessage = 0;
    CMessages::BIGMessages[4][1].pShortMessage = 0;
    CMessages::BIGMessages[4][1].pMessage = 0;
    CMessages::BIGMessages[4][2].pShortMessage = 0;
    CMessages::BIGMessages[4][2].pMessage = 0;
    CMessages::BIGMessages[4][3].pShortMessage = 0;
    CMessages::BIGMessages[4][3].pMessage = 0;
  }
  CMessages::BIGMessages[5][0].pShortMessage = 0;
  CMessages::BIGMessages[5][0].pMessage = 0;
  CMessages::BIGMessages[5][1].pShortMessage = 0;
  CMessages::BIGMessages[5][1].pMessage = 0;
  CMessages::BIGMessages[5][2].pShortMessage = 0;
  CMessages::BIGMessages[5][2].pMessage = 0;
  CMessages::BIGMessages[5][3].pShortMessage = 0;
  CMessages::BIGMessages[5][3].pMessage = 0;
  CMessages::BIGMessages[6][0].pShortMessage = 0;
  CMessages::BIGMessages[6][0].pMessage = 0;
  CMessages::BIGMessages[6][1].pShortMessage = 0;
  CMessages::BIGMessages[6][1].pMessage = 0;
  CMessages::BIGMessages[6][2].pShortMessage = 0;
  CMessages::BIGMessages[6][2].pMessage = 0;
  CMessages::BIGMessages[6][3].pShortMessage = 0;
  CMessages::BIGMessages[6][3].pMessage = 0;
  CMessages::BIGMessages[7][0].pShortMessage = 0;
  CMessages::BIGMessages[7][0].pMessage = 0;
  CMessages::BIGMessages[7][1].pShortMessage = 0;
  CMessages::BIGMessages[7][1].pMessage = 0;
  CMessages::BIGMessages[7][2].pShortMessage = 0;
  CMessages::BIGMessages[7][2].pMessage = 0;
  CMessages::BIGMessages[7][3].pShortMessage = 0;
  CMessages::BriefMessages[0].pShortMessage = 0;
  CMessages::BriefMessages[0].pMessage = 0;
  CMessages::BriefMessages[1].pShortMessage = 0;
  CMessages::BriefMessages[1].pMessage = 0;
  CMessages::BriefMessages[2].pShortMessage = 0;
  CMessages::BriefMessages[2].pMessage = 0;
  CMessages::BriefMessages[3].pShortMessage = 0;
  CMessages::BriefMessages[3].pMessage = 0;
  CMessages::BriefMessages[4].pShortMessage = 0;
  CMessages::BriefMessages[4].pMessage = 0;
  CMessages::BriefMessages[5].pShortMessage = 0;
  CMessages::BriefMessages[5].pMessage = 0;
  CMessages::BriefMessages[6].pShortMessage = 0;
  CMessages::BriefMessages[6].pMessage = 0;
  CMessages::BriefMessages[7].pShortMessage = 0;
  CMessages::BIGMessages[7][3].pMessage = 0;
  CMessages::BriefMessages[7].pMessage = 0;
}

//----- (0054C5E8) --------------------------------------------------------
void CMessages::ClearSmallMessagesOnly()
{
  CMessages::BriefMessages[0].pShortMessage = 0;
  CMessages::BriefMessages[0].pMessage = 0;
  CMessages::BriefMessages[1].pShortMessage = 0;
  CMessages::BriefMessages[1].pMessage = 0;
  CMessages::BriefMessages[2].pShortMessage = 0;
  CMessages::BriefMessages[2].pMessage = 0;
  CMessages::BriefMessages[3].pShortMessage = 0;
  CMessages::BriefMessages[3].pMessage = 0;
  CMessages::BriefMessages[4].pShortMessage = 0;
  CMessages::BriefMessages[4].pMessage = 0;
  CMessages::BriefMessages[5].pShortMessage = 0;
  CMessages::BriefMessages[5].pMessage = 0;
  CMessages::BriefMessages[6].pShortMessage = 0;
  CMessages::BriefMessages[6].pMessage = 0;
  CMessages::BriefMessages[7].pShortMessage = 0;
  CMessages::BriefMessages[7].pMessage = 0;
}

//----- (0054C62C) --------------------------------------------------------
void __fastcall CMessages::AddBigMessage(GxtChar *pText, UInt32 Duration, UInt16 Row)
{
  CQueuedMessage *v3; // r2
  uint32 v4; // r0

  v3 = CMessages::BIGMessages[Row];
  v3->Colour = 0;
  v3->pMessage = pText;
  v4 = CTimer::m_snTimeInMilliseconds;
  v3->pShortMessage = 0;
  v3->Duration = Duration;
  v3->WhenStarted = v4;
  v3->NumberToInsert = -1;
  v3->NumberToInsert2 = -1;
  v3->NumberToInsert3 = -1;
  v3->NumberToInsert4 = -1;
  v3->NumberToInsert5 = -1;
  v3->NumberToInsert6 = -1;
}

//----- (0054C678) --------------------------------------------------------
void __fastcall CMessages::AddBigMessageQ(GxtChar *pText, UInt32 Duration, UInt16 Row)
{
  int v3; // r4
  CQueuedMessage *v4; // r2
  GxtChar **p_pMessage; // r2
  GxtChar *pMessage; // t1
  CQueuedMessage *v7; // r2
  GxtChar *v8; // t1
  CQueuedMessage *v9; // r2
  GxtChar *v10; // t1
  CQueuedMessage *v11; // r2
  GxtChar *v12; // t1
  int v13; // lr
  CQueuedMessage *v14; // r0
  uint32 v15; // r2

  v3 = Row;
  v4 = CMessages::BIGMessages[Row];
  pMessage = v4->pMessage;
  p_pMessage = &v4->pMessage;
  if ( pMessage )
  {
    v7 = CMessages::BIGMessages[v3];
    v8 = v7[1].pMessage;
    p_pMessage = &v7[1].pMessage;
    if ( v8 )
    {
      v9 = CMessages::BIGMessages[v3];
      v10 = v9[2].pMessage;
      p_pMessage = &v9[2].pMessage;
      if ( v10 )
      {
        v11 = CMessages::BIGMessages[v3];
        v12 = v11[3].pMessage;
        p_pMessage = &v11[3].pMessage;
        if ( v12 )
          return;
        v13 = 3;
      }
      else
      {
        v13 = 2;
      }
    }
    else
    {
      v13 = 1;
    }
  }
  else
  {
    v13 = 0;
  }
  *p_pMessage = pText;
  v14 = &CMessages::BIGMessages[v3][v13];
  v15 = CTimer::m_snTimeInMilliseconds;
  v14->Colour = 0;
  v14->Duration = Duration;
  v14->WhenStarted = v15;
  v14->NumberToInsert = -1;
  v14->NumberToInsert2 = -1;
  v14->NumberToInsert3 = -1;
  v14->NumberToInsert4 = -1;
  v14->NumberToInsert5 = -1;
  v14->NumberToInsert6 = -1;
  v14->pShortMessage = 0;
}

//----- (0054C730) --------------------------------------------------------
void CMessages::ReloadPreviousBriefArray()
{
  int i; // r4
  GxtChar *v1; // r0
  CPreviousMessage *v2; // r1

  for ( i = 0; i != 20; ++i )
  {
    if ( CMessages::PreviousBriefs[i].TextLabel[0] )
    {
      v1 = CText::Get(&TheText, CMessages::PreviousBriefs[i].TextLabel);
      v2 = &CMessages::PreviousBriefs[i];
      v2->pMessage = v1;
      v2->pShortMessage = 0;
    }
  }
}

//----- (0054C780) --------------------------------------------------------
void __fastcall CMessages::AddMessageWithNumber(
        const unsigned __int8 *Label,
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Colour,
        Int32 NumToInsert,
        Int32 NumToInsert2,
        Int32 NumToInsert3,
        Int32 NumToInsert4,
        Int32 NumToInsert5,
        Int32 NumToInsert6,
        int bAddToPrevBriefs)
{
  GxtChar **p_pMessage; // r8
  UInt16 v15; // r5
  UInt32 v16; // r6
  int v17; // r9
  int v18; // r0
  int v19; // r11
  CQueuedMessage *v20; // r0
  uint32 v21; // r1
  CQueuedMessage *v22; // r0
  GxtChar *v24; // [sp+18h] [bp-660h]
  GxtChar v25[814]; // [sp+1Ch] [bp-65Ch] BYREF

  CMessages::InsertNumberInString(
    pText,
    NumToInsert,
    NumToInsert2,
    NumToInsert3,
    NumToInsert4,
    NumToInsert5,
    NumToInsert6,
    v25);
  v24 = pText;
  p_pMessage = &CMessages::BriefMessages[0].pMessage;
  if ( CMessages::BriefMessages[0].pMessage )
  {
    p_pMessage = &CMessages::BriefMessages[1].pMessage;
    if ( CMessages::BriefMessages[1].pMessage )
    {
      p_pMessage = &CMessages::BriefMessages[2].pMessage;
      if ( CMessages::BriefMessages[2].pMessage )
      {
        p_pMessage = &CMessages::BriefMessages[3].pMessage;
        if ( CMessages::BriefMessages[3].pMessage )
        {
          p_pMessage = &CMessages::BriefMessages[4].pMessage;
          if ( CMessages::BriefMessages[4].pMessage )
          {
            if ( CMessages::BriefMessages[5].pMessage )
            {
              if ( CMessages::BriefMessages[6].pMessage )
              {
                if ( CMessages::BriefMessages[7].pMessage )
                  return;
                v15 = Colour;
                v16 = Duration;
                p_pMessage = &CMessages::BriefMessages[7].pMessage;
                v17 = 1;
                v18 = 7;
              }
              else
              {
                v15 = Colour;
                v16 = Duration;
                p_pMessage = &CMessages::BriefMessages[6].pMessage;
                v17 = 1;
                v18 = 6;
              }
            }
            else
            {
              v15 = Colour;
              v16 = Duration;
              p_pMessage = &CMessages::BriefMessages[5].pMessage;
              v17 = 1;
              v18 = 5;
            }
          }
          else
          {
            v15 = Colour;
            v16 = Duration;
            v17 = 1;
            v18 = 4;
          }
        }
        else
        {
          v15 = Colour;
          v16 = Duration;
          v17 = 1;
          v18 = 3;
        }
      }
      else
      {
        v15 = Colour;
        v16 = Duration;
        v17 = 1;
        v18 = 2;
      }
    }
    else
    {
      v15 = Colour;
      v16 = Duration;
      v18 = 1;
      v17 = 1;
    }
  }
  else
  {
    v15 = Colour;
    v16 = Duration;
    v18 = 0;
    v17 = 0;
  }
  v19 = v18;
  v20 = &CMessages::BriefMessages[v18];
  if ( Label )
    strncpy((char *)v20, (const char *)Label, 8u);
  else
    v20->TextLabel[0] = 0;
  v21 = CTimer::m_snTimeInMilliseconds;
  v22 = &CMessages::BriefMessages[v19];
  v22->TextLabel[7] = 0;
  *p_pMessage = v24;
  v22->Colour = v15;
  v22->Duration = v16;
  v22->WhenStarted = v21;
  v22->NumberToInsert = NumToInsert;
  v22->NumberToInsert2 = NumToInsert2;
  v22->NumberToInsert3 = NumToInsert3;
  v22->NumberToInsert4 = NumToInsert4;
  v22->NumberToInsert5 = NumToInsert5;
  v22->NumberToInsert6 = NumToInsert6;
  v22->pShortMessage = 0;
  v22->bAddToPreviousBriefs = bAddToPrevBriefs;
  if ( !v17 )
  {
    if ( bAddToPrevBriefs )
      CMessages::AddToPreviousBriefArray(
        CMessages::BriefMessages[0].TextLabel,
        CMessages::BriefMessages[0].pMessage,
        CMessages::BriefMessages[0].NumberToInsert,
        CMessages::BriefMessages[0].NumberToInsert2,
        CMessages::BriefMessages[0].NumberToInsert3,
        CMessages::BriefMessages[0].NumberToInsert4,
        CMessages::BriefMessages[0].NumberToInsert5,
        CMessages::BriefMessages[0].NumberToInsert6,
        CMessages::BriefMessages[0].pShortMessage);
  }
}
// 54C780: using guessed type GxtChar var_65C[814];

//----- (0054C958) --------------------------------------------------------
void __fastcall CMessages::AddMessageJumpQWithNumber(
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Colour,
        Int32 NumToInsert,
        __int64 NumToInsert2,
        Int32 NumToInsert4,
        Int32 NumToInsert5,
        Int32 NumToInsert6,
        int bAddToPrevBriefs)
{
  GxtChar v13[814]; // [sp+14h] [bp-65Ch] BYREF

  CMessages::InsertNumberInString(
    pText,
    NumToInsert,
    NumToInsert2,
    SHIDWORD(NumToInsert2),
    NumToInsert4,
    NumToInsert5,
    NumToInsert6,
    v13);
  CMessages::BriefMessages[0].Colour = Colour;
  CMessages::BriefMessages[0].pMessage = pText;
  CMessages::BriefMessages[0].Duration = Duration;
  CMessages::BriefMessages[0].NumberToInsert = NumToInsert;
  CMessages::BriefMessages[0].pShortMessage = 0;
  *(_QWORD *)&CMessages::BriefMessages[0].NumberToInsert2 = NumToInsert2;
  CMessages::BriefMessages[0].NumberToInsert4 = NumToInsert4;
  CMessages::BriefMessages[0].NumberToInsert5 = NumToInsert5;
  CMessages::BriefMessages[0].NumberToInsert6 = NumToInsert6;
  CMessages::BriefMessages[0].bAddToPreviousBriefs = bAddToPrevBriefs;
  CMessages::BriefMessages[0].WhenStarted = CTimer::m_snTimeInMilliseconds;
  if ( bAddToPrevBriefs )
    CMessages::AddToPreviousBriefArray(
      CMessages::BriefMessages[0].TextLabel,
      pText,
      NumToInsert,
      NumToInsert2,
      SHIDWORD(NumToInsert2),
      NumToInsert4,
      NumToInsert5,
      NumToInsert6,
      0);
}
// 54C958: using guessed type GxtChar var_65C[814];

//----- (0054C9FC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CMessages::AddBigMessageWithNumber(
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Row,
        Int32 NumToInsert,
        Int32 NumToInsert2,
        Int32 NumToInsert3,
        Int32 NumToInsert4,
        Int32 NumToInsert5,
        Int32 NumToInsert6)
{
  int v9; // r5
  CQueuedMessage *v13; // r0
  GxtChar v14[814]; // [sp+14h] [bp-65Ch] BYREF

  v9 = Row;
  CMessages::InsertNumberInString(
    pText,
    NumToInsert,
    NumToInsert2,
    NumToInsert3,
    NumToInsert4,
    NumToInsert5,
    NumToInsert6,
    v14);
  v13 = CMessages::BIGMessages[v9];
  v13->pMessage = pText;
  v13->Duration = Duration;
  v13->Colour = 0;
  v13->WhenStarted = CTimer::m_snTimeInMilliseconds;
  v13->NumberToInsert = NumToInsert;
  *(_QWORD *)&v13->NumberToInsert2 = *(_QWORD *)&NumToInsert2;
  v13->NumberToInsert4 = NumToInsert4;
  v13->NumberToInsert5 = NumToInsert5;
  v13->NumberToInsert6 = NumToInsert6;
  v13->pShortMessage = 0;
}
// 54C9FC: variables would overlap: ^678.4 and ^678.8
// 54C9FC: using guessed type GxtChar var_65C[814];

//----- (0054CA7C) --------------------------------------------------------
void __fastcall CMessages::AddBigMessageWithNumberQ(
        GxtChar *pText,
        UInt32 Duration,
        int Row,
        Int32 NumToInsert,
        Int32 NumToInsert2,
        Int32 NumToInsert3,
        Int32 NumToInsert4,
        Int32 NumToInsert5,
        Int32 NumToInsert6)
{
  CQueuedMessage *v13; // r2
  GxtChar **p_pMessage; // r2
  GxtChar *pMessage; // t1
  CQueuedMessage *v16; // r2
  GxtChar *v17; // t1
  CQueuedMessage *v18; // r2
  GxtChar *v19; // t1
  CQueuedMessage *v20; // r2
  GxtChar *v21; // t1
  int v22; // r3
  uint32 v23; // r0
  CQueuedMessage *v24; // r1
  GxtChar v25[814]; // [sp+14h] [bp-65Ch] BYREF

  CMessages::InsertNumberInString(
    pText,
    NumToInsert,
    NumToInsert2,
    NumToInsert3,
    NumToInsert4,
    NumToInsert5,
    NumToInsert6,
    v25);
  v13 = CMessages::BIGMessages[Row];
  pMessage = v13->pMessage;
  p_pMessage = &v13->pMessage;
  if ( pMessage )
  {
    v16 = CMessages::BIGMessages[Row];
    v17 = v16[1].pMessage;
    p_pMessage = &v16[1].pMessage;
    if ( v17 )
    {
      v18 = CMessages::BIGMessages[Row];
      v19 = v18[2].pMessage;
      p_pMessage = &v18[2].pMessage;
      if ( v19 )
      {
        v20 = CMessages::BIGMessages[Row];
        v21 = v20[3].pMessage;
        p_pMessage = &v20[3].pMessage;
        if ( v21 )
          return;
        v22 = 3;
      }
      else
      {
        v22 = 2;
      }
    }
    else
    {
      v22 = 1;
    }
  }
  else
  {
    v22 = 0;
  }
  *p_pMessage = pText;
  v23 = CTimer::m_snTimeInMilliseconds;
  v24 = &CMessages::BIGMessages[Row][v22];
  v24->Colour = 0;
  v24->Duration = Duration;
  v24->WhenStarted = v23;
  v24->NumberToInsert = NumToInsert;
  v24->NumberToInsert2 = NumToInsert2;
  v24->NumberToInsert3 = NumToInsert3;
  v24->NumberToInsert4 = NumToInsert4;
  v24 = (CQueuedMessage *)((char *)v24 + 40);
  *(_DWORD *)v24->TextLabel = NumToInsert5;
  *(_DWORD *)&v24->TextLabel[4] = NumToInsert6;
  v24->pMessage = 0;
}
// 54CA7C: using guessed type GxtChar var_65C[814];

//----- (0054CB68) --------------------------------------------------------
void __fastcall CMessages::AddMessageWithString(
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Colour,
        GxtChar *pShortText,
        int bAddToPrevBriefs)
{
  GxtChar *v9; // r1
  unsigned __int16 v10; // r0
  GxtChar *v11; // r2
  int v12; // r6
  GxtChar **p_pMessage; // r0
  int v14; // r1
  CQueuedMessage *v15; // r0
  uint32 v16; // r3
  GxtChar pBigString[812]; // [sp+18h] [bp-658h] BYREF

  if ( pText )
  {
    v9 = pBigString;
    v10 = 0;
    v11 = pText;
    do
    {
      if ( !*v11 )
        break;
      ++v10;
      *v9++ = *v11++;
    }
    while ( v10 <= 0x18Eu );
  }
  else
  {
    memset(pBigString, 0, 0x31Eu);
    v10 = 399;
  }
  v12 = 0;
  pBigString[v10] = 0;
  CMessages::InsertStringInString(pBigString, pShortText);
  p_pMessage = &CMessages::BriefMessages[0].pMessage;
  if ( CMessages::BriefMessages[0].pMessage )
  {
    p_pMessage = &CMessages::BriefMessages[1].pMessage;
    if ( CMessages::BriefMessages[1].pMessage )
    {
      p_pMessage = &CMessages::BriefMessages[2].pMessage;
      if ( CMessages::BriefMessages[2].pMessage )
      {
        p_pMessage = &CMessages::BriefMessages[3].pMessage;
        if ( CMessages::BriefMessages[3].pMessage )
        {
          p_pMessage = &CMessages::BriefMessages[4].pMessage;
          if ( CMessages::BriefMessages[4].pMessage )
          {
            if ( CMessages::BriefMessages[5].pMessage )
            {
              if ( CMessages::BriefMessages[6].pMessage )
              {
                if ( CMessages::BriefMessages[7].pMessage )
                  return;
                p_pMessage = &CMessages::BriefMessages[7].pMessage;
                v14 = 1;
                v12 = 7;
              }
              else
              {
                p_pMessage = &CMessages::BriefMessages[6].pMessage;
                v14 = 1;
                v12 = 6;
              }
            }
            else
            {
              p_pMessage = &CMessages::BriefMessages[5].pMessage;
              v14 = 1;
              v12 = 5;
            }
          }
          else
          {
            v14 = 1;
            v12 = 4;
          }
        }
        else
        {
          v14 = 1;
          v12 = 3;
        }
      }
      else
      {
        v14 = 1;
        v12 = 2;
      }
    }
    else
    {
      v12 = 1;
      v14 = 1;
    }
  }
  else
  {
    v14 = 0;
  }
  *p_pMessage = pText;
  v15 = &CMessages::BriefMessages[v12];
  v16 = CTimer::m_snTimeInMilliseconds;
  v15->Colour = Colour;
  v15->pShortMessage = pShortText;
  v15->bAddToPreviousBriefs = bAddToPrevBriefs;
  v15->Duration = Duration;
  v15->WhenStarted = v16;
  v15->NumberToInsert = -1;
  v15->NumberToInsert2 = -1;
  v15->NumberToInsert3 = -1;
  v15->NumberToInsert4 = -1;
  v15->NumberToInsert5 = -1;
  v15->NumberToInsert6 = -1;
  if ( !v14 )
  {
    if ( bAddToPrevBriefs )
      CMessages::AddToPreviousBriefArray(
        CMessages::BriefMessages[0].TextLabel,
        CMessages::BriefMessages[0].pMessage,
        CMessages::BriefMessages[0].NumberToInsert,
        CMessages::BriefMessages[0].NumberToInsert2,
        CMessages::BriefMessages[0].NumberToInsert3,
        CMessages::BriefMessages[0].NumberToInsert4,
        CMessages::BriefMessages[0].NumberToInsert5,
        CMessages::BriefMessages[0].NumberToInsert6,
        CMessages::BriefMessages[0].pShortMessage);
  }
}
// 54CB68: using guessed type GxtChar pBigString[812];

//----- (0054CCEC) --------------------------------------------------------
void __fastcall CMessages::AddMessageJumpQWithString(
        GxtChar *pText,
        UInt32 Duration,
        UInt16 Colour,
        GxtChar *pShortText,
        int a5)
{
  GxtChar *v9; // r1
  unsigned __int16 v10; // r0
  GxtChar *v11; // r2
  GxtChar pBigString[812]; // [sp+18h] [bp-658h] BYREF

  if ( pText )
  {
    v9 = pBigString;
    v10 = 0;
    v11 = pText;
    do
    {
      if ( !*v11 )
        break;
      ++v10;
      *v9++ = *v11++;
    }
    while ( v10 <= 0x18Eu );
  }
  else
  {
    memset(pBigString, 0, 0x31Eu);
    v10 = 399;
  }
  pBigString[v10] = 0;
  CMessages::InsertStringInString(pBigString, pShortText);
  CMessages::BriefMessages[0].Colour = Colour;
  CMessages::BriefMessages[0].pMessage = pText;
  CMessages::BriefMessages[0].pShortMessage = pShortText;
  CMessages::BriefMessages[0].bAddToPreviousBriefs = a5;
  CMessages::BriefMessages[0].Duration = Duration;
  CMessages::BriefMessages[0].WhenStarted = CTimer::m_snTimeInMilliseconds;
  CMessages::BriefMessages[0].NumberToInsert = -1;
  CMessages::BriefMessages[0].NumberToInsert2 = -1;
  CMessages::BriefMessages[0].NumberToInsert3 = -1;
  CMessages::BriefMessages[0].NumberToInsert4 = -1;
  CMessages::BriefMessages[0].NumberToInsert5 = -1;
  CMessages::BriefMessages[0].NumberToInsert6 = -1;
  if ( a5 )
    CMessages::AddToPreviousBriefArray(CMessages::BriefMessages[0].TextLabel, pText, -1, -1, -1, -1, -1, -1, pShortText);
}
// 54CCEC: using guessed type GxtChar pBigString[812];

//----- (0054CDA8) --------------------------------------------------------
void __fastcall CMessages::ClearThisPrint(GxtChar *pText)
{
  CQueuedMessage *v2; // r12
  int v3; // r0
  int v4; // r1
  int v5; // r11
  GxtChar *pMessage; // r2
  GxtChar v7; // r5
  GxtChar *v8; // r3
  bool v9; // zf
  int v10; // t1
  int v11; // r1
  CQueuedMessage *v12; // r2
  __int64 v13; // d16
  __int64 v14; // d17
  CQueuedMessage *v15; // r3
  __int64 v16; // d22
  __int64 v17; // d23
  __int64 v18; // d18
  __int64 v19; // d19
  UInt32 *p_Duration; // r2
  int v21; // r1
  int v22; // r0
  UInt32 v23; // r2
  bool v24; // zf
  CQueuedMessage *v25; // r10

  v2 = CMessages::BriefMessages;
  do
  {
    while ( 1 )
    {
      v3 = 0;
      v4 = 0;
      v5 = 0;
      do
      {
        if ( v4 << 24 )
          break;
        pMessage = CMessages::BriefMessages[v3].pMessage;
        if ( !pMessage )
          break;
        v7 = *pText;
        v4 = 0;
        v8 = pText;
        while ( 1 )
        {
          v9 = v4 << 24 == 0;
          if ( !(v4 << 24) )
            v9 = *pMessage == v7;
          if ( !v9 )
            break;
          v10 = v8[1];
          ++v8;
          v7 = v10;
          ++pMessage;
          v4 = 0;
          if ( !v10 )
          {
            v7 = 0;
            v4 = 0;
            if ( !*pMessage )
            {
              v4 = 1;
              v5 = 1;
            }
          }
        }
        if ( !(v4 << 24) )
          LOWORD(v3) = v3 + 1;
        v3 = (__int16)v3;
      }
      while ( (__int16)v3 < 8 );
      if ( !(v4 << 24) )
        goto LABEL_45;
      if ( v3 << 16 )
        break;
      v21 = *(int *)((char *)&dword_40 + (_DWORD)v2);
      v22 = 0;
      *(_DWORD *)&byte_8[(_DWORD)v2] = 0;
      if ( v21 )
      {
        CMessages::BriefMessages[0] = CMessages::BriefMessages[1];
        if ( CMessages::BriefMessages[2].pMessage )
        {
          CMessages::BriefMessages[1] = CMessages::BriefMessages[2];
          if ( CMessages::BriefMessages[3].pMessage )
          {
            CMessages::BriefMessages[2] = CMessages::BriefMessages[3];
            if ( CMessages::BriefMessages[4].pMessage )
            {
              CMessages::BriefMessages[3] = CMessages::BriefMessages[4];
              if ( CMessages::BriefMessages[5].pMessage )
              {
                CMessages::BriefMessages[4] = CMessages::BriefMessages[5];
                if ( CMessages::BriefMessages[6].pMessage )
                {
                  CMessages::BriefMessages[5] = CMessages::BriefMessages[6];
                  if ( CMessages::BriefMessages[7].pMessage )
                  {
                    CMessages::BriefMessages[6] = CMessages::BriefMessages[7];
                    v22 = 7;
                  }
                  else
                  {
                    v22 = 6;
                  }
                }
                else
                {
                  v22 = 5;
                }
              }
              else
              {
                v22 = 4;
              }
            }
            else
            {
              v22 = 3;
            }
          }
          else
          {
            v22 = 2;
          }
        }
        else
        {
          v22 = 1;
        }
      }
      v23 = CTimer::m_snTimeInMilliseconds;
      CMessages::BriefMessages[v22].pMessage = 0;
      v24 = CMessages::BriefMessages[0].pMessage == 0;
      CMessages::BriefMessages[0].WhenStarted = v23;
      if ( CMessages::BriefMessages[0].pMessage )
        v24 = CMessages::BriefMessages[0].bAddToPreviousBriefs == 0;
      if ( !v24 )
      {
        v25 = v2;
        CMessages::AddToPreviousBriefArray(
          CMessages::BriefMessages[0].TextLabel,
          CMessages::BriefMessages[0].pMessage,
          CMessages::BriefMessages[0].NumberToInsert,
          CMessages::BriefMessages[0].NumberToInsert2,
          CMessages::BriefMessages[0].NumberToInsert3,
          CMessages::BriefMessages[0].NumberToInsert4,
          CMessages::BriefMessages[0].NumberToInsert5,
          CMessages::BriefMessages[0].NumberToInsert6,
          CMessages::BriefMessages[0].pShortMessage);
        v2 = v25;
      }
LABEL_45:
      if ( !(v5 << 24) )
        return;
    }
    CMessages::BriefMessages[v3].pMessage = 0;
    v11 = (__int16)v3;
    if ( (__int16)v3 <= 6 )
    {
      v12 = &CMessages::BriefMessages[(__int16)v3];
      while ( v12[1].pMessage )
      {
        v13 = *(_QWORD *)&v12[1].NumberToInsert3;
        v14 = *(_QWORD *)&v12[1].NumberToInsert5;
        v15 = v12 + 1;
        ++v11;
        v16 = *(_QWORD *)&v12[1].Duration;
        v17 = *(_QWORD *)&v12[1].NumberToInsert;
        v3 = (__int16)(v3 + 1);
        v18 = *(_QWORD *)v12[1].TextLabel;
        v19 = *(_QWORD *)&v12[1].pMessage;
        *(_QWORD *)&v12->pShortMessage = *(_QWORD *)&v12[1].pShortMessage;
        *(_QWORD *)&v12->NumberToInsert3 = v13;
        *(_QWORD *)&v12->NumberToInsert5 = v14;
        *(_QWORD *)v12->TextLabel = v18;
        *(_QWORD *)&v12->pMessage = v19;
        p_Duration = &v12->Duration;
        *(_QWORD *)p_Duration = v16;
        *((_QWORD *)p_Duration + 1) = v17;
        v12 = v15;
        if ( v3 >= 7 )
          goto LABEL_25;
      }
    }
    v3 = v11;
LABEL_25:
    CMessages::BriefMessages[v3].pMessage = 0;
  }
  while ( v5 << 24 );
}
// 40: using guessed type int dword_40;

//----- (0054D1A0) --------------------------------------------------------
void __fastcall CMessages::ClearThisBigPrint(GxtChar *pText)
{
  __int16 v2; // r10
  int v3; // r9
  int v4; // r4
  int v5; // r8
  GxtChar **p_pMessage; // r12
  int v7; // r0
  bool v8; // cc
  GxtChar *v9; // r2
  GxtChar v10; // r3
  int v11; // r1
  GxtChar *v12; // r0
  bool v13; // zf
  int v14; // r1
  int v15; // t1
  CQueuedMessage *v16; // r0
  __int64 v17; // d16
  __int64 v18; // d17
  CQueuedMessage *v19; // r1
  __int64 v20; // d22
  __int64 v21; // d23
  __int64 v22; // d18
  __int64 v23; // d19
  UInt32 *p_Duration; // r0
  CQueuedMessage *v25; // r1
  int v26; // r0
  GxtChar *pMessage; // r2
  CQueuedMessage *v28; // r1
  __int64 v29; // d17
  CQueuedMessage *v30; // r0
  __int64 v31; // d18
  __int64 v32; // d19
  __int64 v33; // d22
  __int64 v34; // d20
  __int64 v35; // d21
  GxtChar *v36; // r2
  CQueuedMessage *v37; // r2
  __int64 v38; // d17
  __int64 v39; // d20
  __int64 v40; // d21
  __int64 v41; // d18
  __int64 v42; // d19
  __int64 v43; // d22
  UInt32 *v44; // r0
  CQueuedMessage *v45; // r0
  __int64 v46; // d17
  __int64 v47; // d18
  __int64 v48; // d19
  __int64 v49; // d22
  __int64 v50; // d20
  __int64 v51; // d21
  CQueuedMessage *v52; // r1

  do
  {
    while ( 1 )
    {
      v2 = 0;
      v3 = 0;
      v4 = 0;
LABEL_4:
      v5 = (__int16)v3;
      p_pMessage = &CMessages::BIGMessages[v2][(__int16)v3].pMessage;
      v7 = 1;
      while ( 1 )
      {
        v8 = v2 <= 7;
        if ( v2 <= 7 )
          v8 = (__int16)v3 <= 3;
        if ( !v8 || !(v7 << 31) )
          break;
        v9 = *p_pMessage;
        if ( *p_pMessage )
        {
          v10 = *pText;
          v11 = 0;
          v12 = pText;
          while ( 1 )
          {
            v14 = v11 << 24;
            v13 = v14 == 0;
            if ( !v14 )
              v13 = *v9 == v10;
            if ( !v13 )
              break;
            v15 = v12[1];
            ++v12;
            v10 = v15;
            ++v9;
            v11 = 0;
            if ( !v15 )
            {
              v10 = 0;
              v11 = 0;
              if ( !*v9 )
              {
                v11 = 1;
                v4 = 1;
              }
            }
          }
          v7 = 0;
          if ( v14 )
            continue;
        }
        if ( (unsigned __int16)++v3 == 4 )
        {
          ++v2;
          v3 = 0;
        }
        goto LABEL_4;
      }
      if ( v7 << 31 )
        goto LABEL_30;
      if ( !(v3 << 16) )
        break;
      *p_pMessage = 0;
      if ( (__int16)v3 <= 2 )
      {
        v16 = &CMessages::BIGMessages[v2][(__int16)v3];
        while ( v16[1].pMessage )
        {
          v17 = *(_QWORD *)&v16[1].NumberToInsert3;
          v18 = *(_QWORD *)&v16[1].NumberToInsert5;
          v19 = v16 + 1;
          ++v5;
          v20 = *(_QWORD *)&v16[1].Duration;
          v21 = *(_QWORD *)&v16[1].NumberToInsert;
          v22 = *(_QWORD *)v16[1].TextLabel;
          v23 = *(_QWORD *)&v16[1].pMessage;
          *(_QWORD *)&v16->pShortMessage = *(_QWORD *)&v16[1].pShortMessage;
          *(_QWORD *)&v16->NumberToInsert3 = v17;
          *(_QWORD *)&v16->NumberToInsert5 = v18;
          *(_QWORD *)v16->TextLabel = v22;
          *(_QWORD *)&v16->pMessage = v23;
          p_Duration = &v16->Duration;
          *(_QWORD *)p_Duration = v20;
          *((_QWORD *)p_Duration + 1) = v21;
          v3 = (__int16)(v3 + 1);
          v16 = v19;
          if ( v3 >= 3 )
          {
            v5 = v3;
            break;
          }
        }
      }
      CMessages::BIGMessages[v2][v5].pMessage = 0;
LABEL_30:
      if ( !(v4 << 24) )
        return;
    }
    v25 = CMessages::BIGMessages[v2];
    v26 = 0;
    pMessage = v25[1].pMessage;
    v25->pMessage = 0;
    if ( pMessage )
    {
      v28 = CMessages::BIGMessages[v2];
      v29 = *(_QWORD *)&v28[1].NumberToInsert5;
      v30 = v28 + 1;
      v31 = *(_QWORD *)v28[1].TextLabel;
      v32 = *(_QWORD *)&v28[1].pMessage;
      v33 = *(_QWORD *)&v28[1].pShortMessage;
      v34 = *(_QWORD *)&v28[1].Duration;
      v35 = *(_QWORD *)&v28[1].NumberToInsert;
      v36 = v28[2].pMessage;
      *(_QWORD *)&v28->NumberToInsert3 = *(_QWORD *)&v28[1].NumberToInsert3;
      *(_QWORD *)&v28->NumberToInsert5 = v29;
      *(_QWORD *)&v28->pShortMessage = v33;
      *(_QWORD *)v28->TextLabel = v31;
      *(_QWORD *)&v28->pMessage = v32;
      v28 = (CQueuedMessage *)((char *)v28 + 16);
      *(_QWORD *)v28->TextLabel = v34;
      *(_QWORD *)&v28->pMessage = v35;
      if ( v36 )
      {
        v37 = CMessages::BIGMessages[v2];
        v38 = *(_QWORD *)&v37[2].NumberToInsert5;
        v39 = *(_QWORD *)&v37[2].Duration;
        v40 = *(_QWORD *)&v37[2].NumberToInsert;
        v41 = *(_QWORD *)v37[2].TextLabel;
        v42 = *(_QWORD *)&v37[2].pMessage;
        v43 = *(_QWORD *)&v37[2].pShortMessage;
        *(_QWORD *)&v30->NumberToInsert3 = *(_QWORD *)&v37[2].NumberToInsert3;
        *(_QWORD *)&v30->NumberToInsert5 = v38;
        *(_QWORD *)&v30->pShortMessage = v43;
        *(_QWORD *)v30->TextLabel = v41;
        *(_QWORD *)&v30->pMessage = v42;
        v44 = &v30->Duration;
        *(_QWORD *)v44 = v39;
        *((_QWORD *)v44 + 1) = v40;
        if ( v37[3].pMessage )
        {
          v45 = CMessages::BIGMessages[v2];
          v46 = *(_QWORD *)&v45[3].NumberToInsert5;
          v47 = *(_QWORD *)v45[3].TextLabel;
          v48 = *(_QWORD *)&v45[3].pMessage;
          v49 = *(_QWORD *)&v45[3].pShortMessage;
          v50 = *(_QWORD *)&v45[3].Duration;
          v51 = *(_QWORD *)&v45[3].NumberToInsert;
          *(_QWORD *)&v37[2].NumberToInsert3 = *(_QWORD *)&v45[3].NumberToInsert3;
          *(_QWORD *)&v37[2].NumberToInsert5 = v46;
          v26 = 3;
          *(_QWORD *)&v37[2].pShortMessage = v49;
          *(_QWORD *)v37[2].TextLabel = v47;
          *(_QWORD *)&v37[2].pMessage = v48;
          *(_QWORD *)&v37[2].Duration = v50;
          *(_QWORD *)&v37[2].NumberToInsert = v51;
        }
        else
        {
          v26 = 2;
        }
      }
      else
      {
        v26 = 1;
      }
    }
    v52 = CMessages::BIGMessages[v2];
    v52[v26].pMessage = 0;
    v52->WhenStarted = CTimer::m_snTimeInMilliseconds;
  }
  while ( v4 << 24 );
}

//----- (0054D42C) --------------------------------------------------------
void __fastcall CMessages::ClearThisBigPrintNow(UInt32 Row)
{
  GxtChar *pMessage; // r0

  pMessage = CMessages::BIGMessages[Row][0].pMessage;
  if ( pMessage )
    CMessages::ClearThisBigPrint(pMessage);
  CHud::m_BigMessage[Row][0] = 0;
  BigMessageInUse[Row] = 0.0;
}

//----- (0054D470) --------------------------------------------------------
void __fastcall CMessages::ClearAllMessagesDisplayedByGame(bool8 bIgnoreMissionTitle)
{
  int v2; // r4
  _BOOL4 v3; // r0
  CPreviousMessage *v4; // r5

  CMessages::ClearMessages(bIgnoreMissionTitle);
  v2 = 0;
  v3 = SkipBriefsClear;
  do
  {
    v4 = &CMessages::PreviousBriefs[v2];
    if ( !v3 )
      CMessages::PreviousBriefs[v2].TextLabel[0] = 0;
    ++v2;
    v4->pShortMessage = 0;
    v4->pMessage = 0;
  }
  while ( v2 != 20 );
  sub_18B960(bIgnoreMissionTitle);
}

//----- (0054D4C8) --------------------------------------------------------
bool8 __fastcall CKeyArray::Load(
        CKeyArray *this,
        const UInt32 Bytes,
        u_native FileId,
        UInt32 *pNumCharsRead,
        bool8 LoadFromMemoryCard)
{
  CKeyEntry *v9; // r0

  this->Count = Bytes >> 3;
  v9 = (CKeyEntry *)operator new[](Bytes & 0xFFFFFFF8);
  this->pBuffer = v9;
  CFileMgr::Read_old(FileId, (unsigned __int8 *)v9, Bytes);
  *pNumCharsRead += Bytes;
  return 1;
}

//----- (0054D4FE) --------------------------------------------------------
void __fastcall CKeyArray::Unload(CKeyArray *this)
{
  CKeyEntry *pBuffer; // r0

  pBuffer = this->pBuffer;
  if ( pBuffer )
  {
    operator delete[](pBuffer);
    this->pBuffer = 0;
  }
  this->Count = 0;
}

//----- (0054D516) --------------------------------------------------------
void __fastcall CKeyArray::Update(CKeyArray *this, GxtChar *pDataBuffer)
{
  CKeyEntry *pBuffer; // r12
  UInt32 v3; // r3

  if ( this->Count )
  {
    pBuffer = this->pBuffer;
    v3 = 0;
    do
      pBuffer[v3++].pData = (GxtChar *)((char *)pBuffer[v3++].pData + (unsigned int)pDataBuffer);
    while ( v3 < this->Count );
  }
}

//----- (0054D538) --------------------------------------------------------
GxtChar *__fastcall CKeyArray::Search(CKeyArray *this, const Char *pSearchKey, Bool8 *bFoundTheText)
{
  uint32 UppercaseKey; // r0
  signed int v6; // r2
  CKeyEntry *pBuffer; // r3
  int v8; // r6
  CKeyEntry *v9; // r4
  uint32 TextHashKey; // r1
  GxtChar *result; // r0

  UppercaseKey = CKeyGen::GetUppercaseKey(pSearchKey);
  v6 = this->Count + 0xFFFF;
  if ( (__int16)(LOWORD(this->Count) - 1) < 0 )
    goto LABEL_11;
  pBuffer = this->pBuffer;
  LOWORD(this) = 0;
  while ( 1 )
  {
    v8 = ((__int16)this + (__int16)v6) / 2;
    v9 = &pBuffer[(unsigned __int16)v8];
    TextHashKey = v9->TextHashKey;
    if ( TextHashKey == UppercaseKey )
      break;
    if ( TextHashKey < UppercaseKey )
    {
      this = (CKeyArray *)(__int16)(v8 + 1);
      if ( (__int16)v6 < (int)this )
        goto LABEL_11;
    }
    else
    {
      v6 = (__int16)(v8 - 1);
      if ( (__int16)this > v6 )
        goto LABEL_11;
    }
  }
  if ( v9 )
  {
    *bFoundTheText = 1;
    return v9->pData;
  }
  else
  {
LABEL_11:
    result = 0;
    *bFoundTheText = 0;
  }
  return result;
}

//----- (0054D5AA) --------------------------------------------------------
CKeyEntry *__fastcall CKeyArray::BinarySearch(
        CKeyArray *this,
        const UInt32 hash_key,
        CKeyEntry *pBuffer,
        int StartIndex,
        int a5)
{
  int v5; // r12
  CKeyEntry *result; // r0
  int v7; // r4
  UInt32 TextHashKey; // r5

  LOWORD(v5) = a5;
  if ( StartIndex > a5 )
    return 0;
  while ( 1 )
  {
    v7 = ((__int16)StartIndex + (__int16)v5) / 2;
    result = &pBuffer[(unsigned __int16)v7];
    TextHashKey = result->TextHashKey;
    if ( TextHashKey == hash_key )
      break;
    if ( TextHashKey < hash_key )
    {
      StartIndex = (__int16)(v7 + 1);
      result = 0;
      if ( (__int16)v5 < StartIndex )
        return result;
    }
    else
    {
      v5 = (__int16)(v7 - 1);
      if ( (__int16)StartIndex > v5 )
        return 0;
    }
  }
  return result;
}

//----- (0054D5FA) --------------------------------------------------------
bool8 __fastcall CData::Load(
        CData *this,
        const UInt32 Bytes,
        u_native FileId,
        UInt32 *pNumCharsRead,
        bool8 LoadFromMemoryCard)
{
  GxtChar *v9; // r0

  this->Count = Bytes >> 1;
  v9 = (GxtChar *)operator new[](Bytes & 0xFFFFFFFE);
  this->pBuffer = v9;
  CFileMgr::Read_old(FileId, (unsigned __int8 *)v9, Bytes);
  *pNumCharsRead += Bytes;
  return 1;
}

//----- (0054D630) --------------------------------------------------------
void __fastcall CData::Unload(CData *this)
{
  GxtChar *pBuffer; // r0

  pBuffer = this->pBuffer;
  if ( pBuffer )
  {
    operator delete[](pBuffer);
    this->pBuffer = 0;
  }
  this->Count = 0;
}

//----- (0054D648) --------------------------------------------------------
void __fastcall CMissionTextOffsets::Load(
        CMissionTextOffsets *this,
        const UInt32 Bytes,
        u_native FileId,
        UInt32 *pNumCharsRead,
        int32 ActualFileSize)
{
  UInt32 v7; // r6
  int v8; // r0

  v7 = Bytes / 0xC;
  CFileMgr::Read_old(FileId, (unsigned __int8 *)this, 12 * (Bytes / 0xC));
  *pNumCharsRead += 12 * v7;
  v8 = 0;
  while ( v7 > (unsigned __int16)v8++ )
    ;
  this->NumberOfEntries = v7;
}

//----- (0054D690) --------------------------------------------------------
GxtChar __fastcall CText::GetUpperCase(CText *this, const GxtChar C)
{
  GxtChar *v2; // r0

  switch ( this->LanguageCode )
  {
    case 'e':
      if ( (unsigned __int16)(C - 97) <= 0x19u )
        return C - 32;
      return C;
    case 'f':
      if ( (unsigned __int16)(C - 97) <= 0x19u )
        return C - 32;
      if ( (C & 0xFFFFFF80) != 128 )
        return C;
      v2 = FrenchUpperCaseTable;
      return v2[C - 128];
    case 'g':
    case 'i':
    case 's':
      if ( (unsigned __int16)(C - 97) <= 0x19u )
        return C - 32;
      if ( (C & 0xFFFFFF80) == 128 )
      {
        v2 = UpperCaseTable;
        return v2[C - 128];
      }
      return C;
    default:
      return C;
  }
}

//----- (0054D708) --------------------------------------------------------
Char *__fastcall GxtCharToAscii(GxtChar *pInString, UInt8 amount_to_shift)
{
  int v2; // r1
  int v3; // r2
  unsigned int v4; // r1
  unsigned int v5; // r1
  Char *result; // r0

  if ( amount_to_shift )
    pInString += (unsigned __int8)(amount_to_shift - 1) + 1;
  v2 = 0;
  if ( pInString )
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = pInString[v2];
      if ( !v4 )
        break;
      if ( v4 >= 0x80 )
      {
        if ( v4 > 0x83 )
        {
          if ( v4 > 0x8D )
          {
            if ( v4 > 0x91 )
            {
              if ( v4 > 0x95 )
              {
                if ( v4 > 0x9A )
                {
                  if ( v4 > 0xA4 )
                  {
                    if ( v4 > 0xA8 )
                    {
                      if ( v4 > 0xCC )
                      {
                        v5 = (unsigned __int16)(v4 - 205);
                        if ( v5 >= 3 )
                          LOBYTE(v4) = 35;
                        else
                          v4 = 0xBFF1D1u >> (8 * v5);
                      }
                      else
                      {
                        LOBYTE(v4) = v4 + 80;
                      }
                    }
                    else
                    {
                      LOBYTE(v4) = v4 + 77;
                    }
                  }
                  else
                  {
                    LOBYTE(v4) = v4 + 75;
                  }
                }
                else
                {
                  LOBYTE(v4) = v4 + 73;
                }
              }
              else
              {
                LOBYTE(v4) = v4 + 71;
              }
            }
            else
            {
              LOBYTE(v4) = v4 + 68;
            }
          }
          else
          {
            LOBYTE(v4) = v4 + 66;
          }
        }
        else
        {
          LOBYTE(v4) = v4 + 64;
        }
      }
      GxtCharToAscii(unsigned short *,unsigned char)::aStr[v3] = v4;
      v2 = v3 + 1;
      if ( v3 >= 254 )
        goto LABEL_28;
    }
    v2 = v3;
  }
LABEL_28:
  result = GxtCharToAscii(unsigned short *,unsigned char)::aStr;
  GxtCharToAscii(unsigned short *,unsigned char)::aStr[v2] = 0;
  return result;
}

//----- (0054D7A8) --------------------------------------------------------
unsigned __int8 *__fastcall GxtCharToAsciiForSaveLoad(GxtChar *pInString)
{
  int v1; // r2
  unsigned int v2; // r3
  GxtChar v3; // r1
  bool v4; // cc
  int v5; // r1
  unsigned __int8 *result; // r0

  if ( pInString )
  {
    v1 = 0;
    while ( 1 )
    {
      v2 = pInString[v1];
      if ( !pInString[v1] )
        break;
      v3 = pInString[v1];
      if ( v2 == 47 )
        LOBYTE(v3) = 32;
      if ( v2 > 0x7E )
        LOBYTE(v3) = 32;
      if ( v2 == 42 )
        LOBYTE(v3) = 32;
      if ( v2 == 63 )
        LOBYTE(v3) = 32;
      v4 = v1 < 255;
      GxtCharToAsciiForSaveLoad(unsigned short *)::aStr[v1] = v3;
      v5 = ++v1;
      if ( !v4 )
        goto LABEL_16;
    }
    v5 = v1;
  }
  else
  {
    v5 = 0;
  }
LABEL_16:
  result = GxtCharToAsciiForSaveLoad(unsigned short *)::aStr;
  GxtCharToAsciiForSaveLoad(unsigned short *)::aStr[v5] = 0;
  return result;
}

//----- (0054D804) --------------------------------------------------------
void __fastcall TextCopy(GxtChar *pOutStr, const GxtChar *pInStr)
{
  GxtChar v2; // r2
  const GxtChar *v3; // r1
  int v4; // t1

  v2 = *pInStr;
  if ( *pInStr )
  {
    v3 = pInStr + 1;
    do
    {
      *pOutStr++ = v2;
      v4 = *v3++;
      v2 = v4;
    }
    while ( v4 );
  }
  *pOutStr = 0;
}

//----- (0054D81C) --------------------------------------------------------
bool8 __fastcall CText::ReadChunkHeader(
        CText *this,
        ChunkHeader *pHead,
        u_native FileId,
        UInt32 *pNumCharsRead,
        bool8 LoadFromMemoryCard)
{
  CFileMgr::ReadBytes(FileId, pHead->Type, 8);
  *pNumCharsRead += 8;
  return 1;
}

//----- (0054D834) --------------------------------------------------------
void __fastcall CText::Load(CText *this, bool8 bKeepMissionText)
{
  const char *v3; // r0
  const char *v4; // r0
  __int64 v5; // d16
  const char *v6; // r0
  void *v7; // r6
  CText *v8; // r10
  int v9; // r0
  unsigned int v10; // r8
  int v11; // r5
  unsigned int v12; // r5
  int v13; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 *v16; // r0
  CKeyEntry *pBuffer; // r0
  UInt32 v18; // r2
  GxtChar *v19; // r1
  GxtChar *v20; // r1
  int v21; // r5
  int v22; // r3
  unsigned int v23; // r4
  int v24; // [sp+4h] [bp-54h]
  int v25; // [sp+8h] [bp-50h]
  int v26; // [sp+Ch] [bp-4Ch]
  CMissionTextOffsets *p_MissionTextOffsets; // [sp+10h] [bp-48h]
  char buffer[3]; // [sp+14h] [bp-44h] BYREF
  unsigned __int8 v29; // [sp+17h] [bp-41h] BYREF
  char pData[4]; // [sp+18h] [bp-40h] BYREF
  unsigned int v31; // [sp+1Ch] [bp-3Ch]
  unsigned __int8 pFilename[8]; // [sp+20h] [bp-38h] BYREF
  int v33[4]; // [sp+28h] [bp-30h] BYREF

  this->bUsesMultipleTextChunks = 0;
  v24 = bKeepMissionText;
  CText::Unload(this, bKeepMissionText);
  CFileMgr::SetDir("TEXT");
  switch ( FrontEndMenuManager.m_PrefsLanguage )
  {
    case 0:
      v3 = "AMERICAN.GXT";
      goto LABEL_11;
    case 1:
      v4 = "FRENCH.GXT";
      goto LABEL_5;
    case 2:
      v4 = "GERMAN.GXT";
LABEL_5:
      v5 = *(_QWORD *)v4;
      strcpy((char *)v33, "XT");
      goto LABEL_12;
    case 3:
      v6 = "ITALIAN.GXT";
      goto LABEL_9;
    case 4:
      v6 = "SPANISH.GXT";
      goto LABEL_9;
    case 5:
      v6 = "RUSSIAN.GXT";
LABEL_9:
      v5 = *(_QWORD *)v6;
      v33[0] = 5527623;
      goto LABEL_12;
    case 6:
      v3 = "JAPANESE.GXT";
LABEL_11:
      v5 = *(_QWORD *)v3;
      *(_QWORD *)((unsigned int)pFilename | 5) = *(_QWORD *)(v3 + 5);
LABEL_12:
      *(_QWORD *)pFilename = v5;
      break;
    default:
      break;
  }
  v7 = (void *)CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_54DB50);
  OS_FileRead(v7, buffer, 2);
  OS_FileRead(v7, buffer, 2);
  v8 = this;
  p_MissionTextOffsets = &this->MissionTextOffsets;
  v25 = 1;
  while ( 2 )
  {
    v9 = 0;
LABEL_15:
    v26 = v9;
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          CFileMgr::ReadBytes((u_native)v7, (unsigned __int8 *)pData, 8);
          v10 = v31;
        }
        while ( !v31 );
        if ( strncmp(pData, "TABL", 4u) )
          break;
        v12 = v10 / 0xC;
        CFileMgr::Read_old((u_native)v7, (unsigned __int8 *)p_MissionTextOffsets, 12 * (v10 / 0xC));
        v13 = 0;
        while ( v12 > (unsigned __int16)v13++ )
          ;
        v8->bUsesMultipleTextChunks = 1;
        v8->MissionTextOffsets.NumberOfEntries = v12;
      }
      if ( !strncmp(pData, "TKEY", 4u) )
      {
        v8->KeyArray.Count = v10 >> 3;
        v15 = (unsigned __int8 *)operator new[](v10 & 0xFFFFFFF8);
        v8->KeyArray.pBuffer = (CKeyEntry *)v15;
        CFileMgr::Read_old((u_native)v7, v15, v10);
        v9 = 1;
        if ( v25 << 31 )
          goto LABEL_15;
        goto LABEL_29;
      }
      if ( !strncmp(pData, "TDAT", 4u) )
        break;
      v11 = 0;
      do
      {
        CFileMgr::ReadBytes((u_native)v7, &v29, 1);
        ++v11;
      }
      while ( v31 > (unsigned __int16)v11 );
    }
    v8->Data.Count = v10 >> 1;
    v16 = (unsigned __int8 *)operator new[](v10 & 0xFFFFFFFE);
    v8->Data.pBuffer = (GxtChar *)v16;
    CFileMgr::Read_old((u_native)v7, v16, v10);
    v25 = 0;
    if ( !(v26 << 24) )
      continue;
    break;
  }
LABEL_29:
  if ( v8->KeyArray.Count )
  {
    pBuffer = v8->KeyArray.pBuffer;
    v18 = 0;
    v19 = v8->Data.pBuffer;
    do
      pBuffer[v18++].pData = (GxtChar *)((char *)pBuffer[v18++].pData + (unsigned int)v19);
    while ( v18 < v8->KeyArray.Count );
  }
  CFileMgr::CloseFile((u_native)v7);
  v20 = CText::Get(&TheText, "CDERROR");
  v21 = 0;
  if ( v20 )
  {
    do
    {
      v22 = v21;
      v23 = v20[v21];
      if ( !v20[v21] )
        break;
      if ( v23 >= 0x80 )
      {
        if ( v23 > 0x83 )
        {
          if ( v23 > 0x8D )
          {
            if ( v23 > 0x91 )
            {
              if ( v23 > 0x95 )
              {
                if ( v23 > 0x9A )
                {
                  if ( v23 > 0xA4 )
                  {
                    if ( v23 > 0xA8 )
                    {
                      if ( v23 > 0xCC )
                      {
                        if ( (unsigned __int16)(v23 - 205) >= 3u )
                          LOBYTE(v23) = 35;
                        else
                          v23 = 0xBFF1D1u >> (8 * (v23 + 51));
                      }
                      else
                      {
                        LOBYTE(v23) = v23 + 80;
                      }
                    }
                    else
                    {
                      LOBYTE(v23) = v23 + 77;
                    }
                  }
                  else
                  {
                    LOBYTE(v23) = v23 + 75;
                  }
                }
                else
                {
                  LOBYTE(v23) = v23 + 73;
                }
              }
              else
              {
                LOBYTE(v23) = v23 + 71;
              }
            }
            else
            {
              LOBYTE(v23) = v23 + 68;
            }
          }
          else
          {
            LOBYTE(v23) = v23 + 66;
          }
        }
        else
        {
          LOBYTE(v23) = v23 + 64;
        }
      }
      ++v21;
      GxtCharToAscii(unsigned short *,unsigned char)::aStr[v22] = v23;
    }
    while ( v22 < 254 );
  }
  GxtCharToAscii(unsigned short *,unsigned char)::aStr[v21] = 0;
  strcpy((char *)v8->LoadedCDErrorText, (const char *)GxtCharToAscii(unsigned short *,unsigned char)::aStr);
  v8->bTextIsLoaded = 1;
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  if ( !v24 && CGame::bMissionPackGame && !v8->bMissionTextIsLoaded )
  {
    do
    {
      if ( CMenuManager::CheckMissionPackValidMenu(&FrontEndMenuManager) )
      {
        CTimer::Suspend();
        CText::LoadMissionPackText(v8);
        CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
        CTimer::Resume();
      }
    }
    while ( !v8->bMissionTextIsLoaded && CGame::bMissionPackGame );
  }
}
// 54DB50: using guessed type int dword_54DB50;
// 61CADE: using guessed type char byte_61CADE;
// 54D834: using guessed type char pData[4];

//----- (0054DB90) --------------------------------------------------------
void __fastcall CText::Unload(CText *this, bool8 bKeepMissionText)
{
  int v3; // r5
  GxtChar *pBuffer; // r0
  CKeyEntry *v5; // r0
  GxtChar *v6; // r0

  v3 = bKeepMissionText;
  CMessages::ClearAllMessagesDisplayedByGame(0);
  if ( this->KeyArray.pBuffer )
  {
    operator delete[](this->KeyArray.pBuffer);
    this->KeyArray.pBuffer = 0;
  }
  pBuffer = this->Data.pBuffer;
  this->KeyArray.Count = 0;
  if ( pBuffer )
  {
    operator delete[](pBuffer);
    this->Data.pBuffer = 0;
  }
  this->bTextIsLoaded = 0;
  this->Data.Count = 0;
  if ( !v3 )
  {
    v5 = this->MissionTextKeyArray.pBuffer;
    if ( v5 )
    {
      operator delete[](v5);
      this->MissionTextKeyArray.pBuffer = 0;
    }
    v6 = this->MissionTextData.pBuffer;
    this->MissionTextKeyArray.Count = 0;
    if ( v6 )
    {
      operator delete[](v6);
      this->MissionTextData.pBuffer = 0;
    }
    *(_DWORD *)&this->LoadedMissionTextName[3] = 0;
    *(_DWORD *)&this->bMissionTextIsLoaded = 0;
    this->MissionTextData.Count = 0;
    this->LoadedMissionTextName[7] = 0;
  }
}

//----- (0054DBFC) --------------------------------------------------------
GxtChar *__fastcall CText::Get(CText *this, const unsigned __int8 *Ident)
{
  uint32 UppercaseKey; // r0
  signed int v5; // r2
  int v6; // r4
  int v7; // r6
  CKeyEntry *v8; // r5
  uint32 TextHashKey; // r1
  GxtChar *result; // r0
  bool v11; // zf
  bool v12; // zf
  uint32 v13; // r0
  signed int v14; // r2
  int v15; // r6
  int v16; // r5
  CKeyEntry *v17; // r4
  uint32 v18; // r1

  if ( (*Ident | 0x20) == 32 )
    goto LABEL_29;
  UppercaseKey = CKeyGen::GetUppercaseKey(Ident);
  v5 = this->KeyArray.Count + 0xFFFF;
  if ( (__int16)(LOWORD(this->KeyArray.Count) - 1) >= 0 )
  {
    LOWORD(v6) = 0;
    while ( 1 )
    {
      v7 = ((__int16)v6 + (__int16)v5) / 2;
      v8 = &this->KeyArray.pBuffer[(unsigned __int16)v7];
      TextHashKey = v8->TextHashKey;
      if ( TextHashKey == UppercaseKey )
        break;
      if ( TextHashKey < UppercaseKey )
      {
        v6 = (__int16)(v7 + 1);
        if ( (__int16)v5 < v6 )
          goto LABEL_12;
      }
      else
      {
        v5 = (__int16)(v7 - 1);
        if ( (__int16)v6 > v5 )
          goto LABEL_12;
      }
    }
    if ( v8 )
      return v8->pData;
  }
LABEL_12:
  v11 = CGame::bMissionPackGame == 0;
  if ( CGame::bMissionPackGame )
    v11 = this->bMissionTextIsLoaded == 0;
  if ( !v11 )
    goto LABEL_32;
  v12 = this->bUsesMultipleTextChunks == 0;
  if ( this->bUsesMultipleTextChunks )
    v12 = this->bMissionTextIsLoaded == 0;
  if ( !v12 )
  {
LABEL_32:
    v13 = CKeyGen::GetUppercaseKey(Ident);
    v14 = this->MissionTextKeyArray.Count + 0xFFFF;
    if ( (__int16)(LOWORD(this->MissionTextKeyArray.Count) - 1) >= 0 )
    {
      LOWORD(v15) = 0;
      while ( 1 )
      {
        v16 = ((__int16)v15 + (__int16)v14) / 2;
        v17 = &this->MissionTextKeyArray.pBuffer[(unsigned __int16)v16];
        v18 = v17->TextHashKey;
        if ( v18 == v13 )
          break;
        if ( v18 < v13 )
        {
          v15 = (__int16)(v16 + 1);
          if ( (__int16)v14 < v15 )
            goto LABEL_29;
        }
        else
        {
          v14 = (__int16)(v16 - 1);
          if ( (__int16)v15 > v14 )
            goto LABEL_29;
        }
      }
      if ( v17 )
        return v17->pData;
    }
  }
LABEL_29:
  result = GxtErrorString;
  GxtErrorString[24] = 0;
  *(_QWORD *)&GxtErrorString[16] = 0LL;
  *(_QWORD *)&GxtErrorString[20] = 0LL;
  *(_QWORD *)GxtErrorString = 0LL;
  *(_QWORD *)&GxtErrorString[4] = 0LL;
  *(_QWORD *)&GxtErrorString[8] = 0LL;
  *(_QWORD *)&GxtErrorString[12] = 0LL;
  return result;
}

//----- (0054DD24) --------------------------------------------------------
void __fastcall CText::LoadMissionPackText(CText *this)
{
  CKeyEntry *pBuffer; // r0
  GxtChar *v3; // r0
  Bool8 v4; // r6
  void *v5; // r0
  void *v6; // r5
  CKeyEntry *v7; // r0
  unsigned int v8; // r11
  int v9; // r6
  GxtChar *v10; // r0
  CKeyEntry *v11; // r0
  UInt32 v12; // r2
  GxtChar *v13; // r1
  int v14; // [sp+8h] [bp-68h]
  int i; // [sp+Ch] [bp-64h]
  char buffer[3]; // [sp+10h] [bp-60h] BYREF
  unsigned __int8 v17; // [sp+13h] [bp-5Dh] BYREF
  char pData[4]; // [sp+14h] [bp-5Ch] BYREF
  unsigned int v19; // [sp+18h] [bp-58h]
  unsigned __int8 s[8]; // [sp+1Eh] [bp-52h] BYREF

  CMessages::ClearAllMessagesDisplayedByGame(1u);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  pBuffer = this->MissionTextKeyArray.pBuffer;
  if ( pBuffer )
  {
    operator delete[](pBuffer);
    this->MissionTextKeyArray.pBuffer = 0;
  }
  v3 = this->MissionTextData.pBuffer;
  v4 = 0;
  this->MissionTextKeyArray.Count = 0;
  if ( v3 )
  {
    operator delete[](v3);
    this->MissionTextData.pBuffer = 0;
  }
  *(_DWORD *)&this->bMissionTextIsLoaded = 0;
  *(_DWORD *)&this->LoadedMissionTextName[3] = 0;
  this->MissionTextData.Count = 0;
  this->LoadedMissionTextName[7] = 0;
  CFileMgr::SetDirMyDocuments();
  sprintf(s, "MPACK//MPACK%d//TEXT.GXT", CGame::bMissionPackGame);
  v5 = (void *)CFileMgr::OpenFile(s, "rb");
  v6 = v5;
  if ( v5 )
  {
    if ( OS_FileRead(v5, buffer, 2) == OSFE_NoError && OS_FileRead(v6, buffer, 2) == OSFE_NoError )
    {
      v14 = 1;
      while ( 2 )
      {
        for ( i = 0; ; i = 1 )
        {
          do
          {
LABEL_12:
            CFileMgr::ReadBytes((u_native)v6, (unsigned __int8 *)pData, 8);
            v8 = v19;
          }
          while ( !v19 );
          if ( strncmp(pData, "TKEY", 4u) )
            break;
          this->MissionTextKeyArray.Count = v8 >> 3;
          v7 = (CKeyEntry *)operator new[](v8 & 0xFFFFFFF8);
          this->MissionTextKeyArray.pBuffer = v7;
          CFileMgr::Read_old((u_native)v6, (unsigned __int8 *)v7, v8);
          if ( !(v14 << 31) )
            goto LABEL_20;
        }
        if ( !strncmp(pData, "TDAT", 4u) )
        {
          this->MissionTextData.Count = v8 >> 1;
          v10 = (GxtChar *)operator new[](v8 & 0xFFFFFFFE);
          this->MissionTextData.pBuffer = v10;
          CFileMgr::Read_old((u_native)v6, (unsigned __int8 *)v10, v8);
          v14 = 0;
          if ( !(i << 24) )
            continue;
LABEL_20:
          if ( this->MissionTextKeyArray.Count )
          {
            v11 = this->MissionTextKeyArray.pBuffer;
            v12 = 0;
            v13 = this->MissionTextData.pBuffer;
            do
              v11[v12++].pData = (GxtChar *)((char *)v11[v12++].pData + (unsigned int)v13);
            while ( v12 < this->MissionTextKeyArray.Count );
          }
          v4 = 1;
          strcpy((char *)this->LoadedMissionTextName, "MPNAME");
          goto LABEL_25;
        }
        break;
      }
      v9 = 0;
      while ( CFileMgr::ReadBytes((u_native)v6, &v17, 1) == 1 )
      {
        if ( v19 <= (unsigned __int16)++v9 )
          goto LABEL_12;
      }
    }
    v4 = 0;
  }
LABEL_25:
  this->bMissionTextIsLoaded = v4;
}
// 61CADE: using guessed type char byte_61CADE;
// 54DD24: using guessed type char pData[4];

//----- (0054DF0C) --------------------------------------------------------
void __fastcall CText::GetNameOfLoadedMissionText(CText *this, unsigned __int8 *pStringToFill)
{
  sub_19B9DC((char *)pStringToFill, (const char *)this->LoadedMissionTextName);
}

//----- (0054DF18) --------------------------------------------------------
void __fastcall CText::LoadMissionText(CText *this, unsigned __int8 *pMissionTextStem)
{
  CKeyEntry *pBuffer; // r0
  GxtChar *v5; // r0
  unsigned __int16 v6; // r8
  unsigned int NumberOfEntries; // r9
  size_t v8; // r4
  int v9; // r1
  const char *v10; // r5
  int v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  __int64 v14; // d16
  const char *v15; // r0
  int32 Offset; // r4
  u_native v17; // r6
  unsigned int v18; // r9
  int v19; // r5
  CKeyEntry *v20; // r0
  GxtChar *v21; // r0
  CKeyEntry *v22; // r0
  UInt32 v23; // r2
  GxtChar *v24; // r1
  int v25; // [sp+Ch] [bp-5Ch]
  int v26; // [sp+14h] [bp-54h]
  unsigned __int8 v27; // [sp+1Bh] [bp-4Dh] BYREF
  char v28[4]; // [sp+1Ch] [bp-4Ch] BYREF
  unsigned int v29; // [sp+20h] [bp-48h]
  unsigned __int8 pData; // [sp+26h] [bp-42h] BYREF
  unsigned __int8 v31; // [sp+27h] [bp-41h] BYREF
  unsigned __int8 v32; // [sp+28h] [bp-40h] BYREF
  unsigned __int8 v33; // [sp+29h] [bp-3Fh] BYREF
  unsigned __int8 v34; // [sp+2Ah] [bp-3Eh] BYREF
  unsigned __int8 v35; // [sp+2Bh] [bp-3Dh] BYREF
  unsigned __int8 v36; // [sp+2Ch] [bp-3Ch] BYREF
  unsigned __int8 v37; // [sp+2Dh] [bp-3Bh] BYREF
  Char CheckName[10]; // [sp+2Eh] [bp-3Ah] BYREF
  int v39[4]; // [sp+38h] [bp-30h] BYREF

  if ( !CGame::bMissionPackGame )
  {
    CMessages::ClearAllMessagesDisplayedByGame(1u);
    pBuffer = this->MissionTextKeyArray.pBuffer;
    if ( pBuffer )
    {
      operator delete[](pBuffer);
      this->MissionTextKeyArray.pBuffer = 0;
    }
    v5 = this->MissionTextData.pBuffer;
    v6 = 0;
    this->MissionTextKeyArray.Count = 0;
    if ( v5 )
    {
      operator delete[](v5);
      this->MissionTextData.pBuffer = 0;
    }
    *(_DWORD *)&this->bMissionTextIsLoaded = 0;
    *(_DWORD *)&this->LoadedMissionTextName[3] = 0;
    this->MissionTextData.Count = 0;
    this->LoadedMissionTextName[7] = 0;
    NumberOfEntries = this->MissionTextOffsets.NumberOfEntries;
    v8 = (unsigned __int16)strlen((const char *)pMissionTextStem);
LABEL_8:
    v9 = 1;
    v10 = (const char *)&this->MissionTextOffsets.OffsetEntries[v6];
    while ( v9 << 31 && v6 < NumberOfEntries )
    {
      if ( v8 == (unsigned __int16)strlen(v10) )
      {
        v11 = strncmp(v10, (const char *)pMissionTextStem, v8);
        v9 = 0;
        if ( !v11 )
          continue;
      }
      ++v6;
      goto LABEL_8;
    }
    if ( !(v9 << 31) )
    {
      CFileMgr::SetDir("TEXT");
      switch ( FrontEndMenuManager.m_PrefsLanguage )
      {
        case 0:
          v12 = "AMERICAN.GXT";
          goto LABEL_25;
        case 1:
          v13 = "FRENCH.GXT";
          goto LABEL_19;
        case 2:
          v13 = "GERMAN.GXT";
LABEL_19:
          v14 = *(_QWORD *)v13;
          strcpy((char *)v39, "XT");
          goto LABEL_26;
        case 3:
          v15 = "ITALIAN.GXT";
          goto LABEL_23;
        case 4:
          v15 = "SPANISH.GXT";
          goto LABEL_23;
        case 5:
          v15 = "RUSSIAN.GXT";
LABEL_23:
          v14 = *(_QWORD *)v15;
          v39[0] = 5527623;
          goto LABEL_26;
        case 6:
          v12 = "JAPANESE.GXT";
LABEL_25:
          v14 = *(_QWORD *)v12;
          *(_QWORD *)((unsigned int)&CheckName[2] | 5) = *(_QWORD *)(v12 + 5);
LABEL_26:
          *(_QWORD *)&CheckName[2] = v14;
          break;
        default:
          break;
      }
      CTimer::Suspend();
      Offset = this->MissionTextOffsets.OffsetEntries[(__int16)v6].Offset;
      v17 = CFileMgr::OpenFile(&CheckName[2], (const unsigned __int8 *)&dword_54E218);
      CFileMgr::Seek(v17, Offset, 0);
      v25 = 1;
      CFileMgr::ReadBytes(v17, &pData, 1);
      CFileMgr::ReadBytes(v17, &v31, 1);
      CFileMgr::ReadBytes(v17, &v32, 1);
      CFileMgr::ReadBytes(v17, &v33, 1);
      CFileMgr::ReadBytes(v17, &v34, 1);
      CFileMgr::ReadBytes(v17, &v35, 1);
      CFileMgr::ReadBytes(v17, &v36, 1);
      CFileMgr::ReadBytes(v17, &v37, 1);
      do
      {
        v26 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            do
            {
              CFileMgr::ReadBytes(v17, (unsigned __int8 *)v28, 8);
              v18 = v29;
            }
            while ( !v29 );
            if ( strncmp(v28, "TKEY", 4u) )
              break;
            this->MissionTextKeyArray.Count = v18 >> 3;
            v20 = (CKeyEntry *)operator new[](v18 & 0xFFFFFFF8);
            this->MissionTextKeyArray.pBuffer = v20;
            CFileMgr::Read_old(v17, (unsigned __int8 *)v20, v18);
            if ( !(v25 << 31) )
              goto LABEL_39;
            v26 = 1;
          }
          if ( !strncmp(v28, "TDAT", 4u) )
            break;
          v19 = 0;
          do
          {
            CFileMgr::ReadBytes(v17, &v27, 1);
            ++v19;
          }
          while ( v29 > (unsigned __int16)v19 );
        }
        this->MissionTextData.Count = v18 >> 1;
        v21 = (GxtChar *)operator new[](v18 & 0xFFFFFFFE);
        this->MissionTextData.pBuffer = v21;
        CFileMgr::Read_old(v17, (unsigned __int8 *)v21, v18);
        v25 = 0;
      }
      while ( !(v26 << 24) );
LABEL_39:
      if ( this->MissionTextKeyArray.Count )
      {
        v22 = this->MissionTextKeyArray.pBuffer;
        v23 = 0;
        v24 = this->MissionTextData.pBuffer;
        do
          v22[v23++].pData = (GxtChar *)((char *)v22[v23++].pData + (unsigned int)v24);
        while ( v23 < this->MissionTextKeyArray.Count );
      }
      CFileMgr::CloseFile(v17);
      CTimer::Resume();
      CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
      strcpy((char *)this->LoadedMissionTextName, (const char *)pMissionTextStem);
      anytimeMissionScript[0] = 0;
      this->bMissionTextIsLoaded = 1;
    }
  }
}
// 54E218: using guessed type int dword_54E218;
// 61CADE: using guessed type char byte_61CADE;
// 54DF18: using guessed type char var_4C[4];

//----- (0054E230) --------------------------------------------------------
void __fastcall CText::CText(CText *this)
{
  this->MissionTextOffsets.NumberOfEntries = 0;
  this->LoadedMissionTextName[7] = 0;
  *(_DWORD *)&this->LoadedMissionTextName[3] = 0;
  *(_DWORD *)&this->bMissionTextIsLoaded = 0;
  *(_WORD *)&this->LanguageCode = 101;
  this->KeyArray = 0LL;
  this->Data = 0LL;
  this->MissionTextKeyArray = 0LL;
  this->MissionTextData = 0LL;
  GxtErrorString[24] = 0;
  *(_QWORD *)&GxtErrorString[16] = 0LL;
  *(_QWORD *)&GxtErrorString[20] = 0LL;
  *(_QWORD *)GxtErrorString = 0LL;
  *(_QWORD *)&GxtErrorString[4] = 0LL;
  *(_QWORD *)&GxtErrorString[8] = 0LL;
  *(_QWORD *)&GxtErrorString[12] = 0LL;
}

//----- (0054E274) --------------------------------------------------------
void __fastcall CText::~CText(CText *this)
{
  GxtChar *pBuffer; // r0
  CKeyEntry *v3; // r0
  GxtChar *v4; // r0
  CKeyEntry *v5; // r0

  pBuffer = this->MissionTextData.pBuffer;
  if ( pBuffer )
  {
    operator delete[](pBuffer);
    this->MissionTextData.pBuffer = 0;
  }
  v3 = this->MissionTextKeyArray.pBuffer;
  this->MissionTextData.Count = 0;
  if ( v3 )
  {
    operator delete[](v3);
    this->MissionTextKeyArray.pBuffer = 0;
  }
  v4 = this->Data.pBuffer;
  this->MissionTextKeyArray.Count = 0;
  if ( v4 )
  {
    operator delete[](v4);
    this->Data.pBuffer = 0;
  }
  v5 = this->KeyArray.pBuffer;
  this->Data.Count = 0;
  if ( v5 )
  {
    operator delete[](v5);
    this->KeyArray.pBuffer = 0;
  }
  this->KeyArray.Count = 0;
}

//----- (0054E2C0) --------------------------------------------------------
RwObject_0 *__fastcall GetCurrentAtomicObjectCB(RwObject_0 *pObject, void *data)
{
  if ( (pObject->flags & 4) != 0 )
    *(_DWORD *)data = pObject;
  return pObject;
}

//----- (0054E2D0) --------------------------------------------------------
void __fastcall CAutomobile::CAutomobile(CAutomobile *this, int nModelIndex, UInt8 CreatedBy, UInt8 DoSuspensionLines)
{
  CBaseModelInfo *v6; // r11
  int v7; // r5
  Bool8 v8; // r0
  char *v9; // r0
  uint32 v10; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r3
  tHandlingData *pHandling; // r0
  int v13; // r2
  unsigned int v14; // r1
  uint32 mFlags; // r6
  int *v16; // r6
  int *v17; // r3
  int m_nModelIndex; // r2
  float v19; // s2
  RwFrame_0 *v20; // r0
  CDoor *v21; // r2
  int v22; // r1
  int *v23; // r2
  int v24; // r3
  float v25; // s0
  uint16 v26; // r2
  unsigned int v27; // r2
  int *v28; // r3
  int v29; // s0
  uint16 v30; // r2
  CBouncingPanel *BouncingPanels; // r5
  float v32; // s0
  int v33; // r0
  CBouncingPanel *v34; // r0
  int16 v35; // r1
  int16 v36; // r2
  int v37; // r0
  bool v38; // zf
  float v39; // s0
  int *v40; // r2
  tHandlingData *v41; // r2
  __int64 v42; // d16
  float fDragCoeff; // s0
  eCarLockState m_eDoorLockState; // r2
  int v45; // r0
  CDoor *p_ChassisDoor; // [sp+8h] [bp-D0h]
  int v47; // [sp+Ch] [bp-CCh]
  CMatrix v48; // [sp+10h] [bp-C8h] BYREF
  CMatrix v49; // [sp+58h] [bp-80h] BYREF

  v47 = DoSuspensionLines;
  CVehicle::CVehicle(this, CreatedBy);
  this->_vptr$CPlaceable = (int (**)(void))&off_66D678;
  CDamageManager::ResetDamageStatus(&this->Damage);
  this->Damage.fWheelDamageEffect = 0.5;
  memset(this->Door, 0, sizeof(this->Door));
  p_ChassisDoor = &this->ChassisDoor;
  *(_QWORD *)&this->ChassisDoor.m_fOpenAngle = 0LL;
  *(_QWORD *)&this->ChassisDoor.m_nDirn = 0LL;
  this->ChassisDoor.m_fPrevAngle = 0.0;
  this->ChassisDoor.m_fAngVel = 0.0;
  this->BouncingPanels[2].m_nComponentIndex = -1;
  this->BouncingPanels[1].m_nComponentIndex = -1;
  this->BouncingPanels[0].m_nComponentIndex = -1;
  v6 = CModelInfo::ms_modelInfoPtrs[nModelIndex];
  v7 = *((unsigned __int8 *)&v6[1].m_flags + 2);
  this->m_BlowUpTimer = 0.0;
  this->m_baseVehicleType = 0;
  this->m_vehicleType = 0;
  this->nBrakesOn = 0;
  v8 = CAutomobile::m_sAllTaxiLights;
  if ( CAutomobile::m_sAllTaxiLights )
    v8 = 1;
  this->m_nAutomobileFlags = (CAutomobile::CAutomobileFlags)(v8 & 1 | 0x30);
  (*((void (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 6))(this, nModelIndex);
  v9 = (char *)&mod_HandlingManager + 224 * v7;
  this->pHandling = (tHandlingData *)(v9 + 20);
  v10 = *((_DWORD *)v9 + 57);
  this->hFlagsLocal = v10;
  if ( (v10 & 0x10000) != 0 && (rand() & 3) == 0 )
    CVehicle::AddVehicleUpgrade(this, MI_HYDRAULICS);
  this->pFlyingHandling = cHandlingDataMgr::GetFlyingPointer(&mod_HandlingManager, v7);
  this->m_fGasPedalAudioRevs = 0.0;
  this->fBrakeCount = 20.0;
  this->m_fEngineRevs = 0.0;
  this->m_fEngineForce = 0.0;
  CVehicleModelInfo::ChooseVehicleColour(
    (CVehicleModelInfo *)v6,
    &this->m_colour1,
    &this->m_colour2,
    &this->m_colour3,
    &this->m_colour4,
    1);
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  pHandling = this->pHandling;
  v13 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  v14 = *(_DWORD *)&this->m_nVehicleFlags & 0xFFFFF0FF;
  *(_DWORD *)&this->m_nVehicleFlags = v14;
  mFlags = pHandling->mFlags;
  if ( (mFlags & 1) != 0 )
  {
    v14 |= 0x100u;
    *(_DWORD *)p_m_nVehicleFlags = v14;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v13;
    mFlags = pHandling->mFlags;
  }
  if ( (mFlags & 8) != 0 )
  {
    v14 |= 0x400u;
    *(_DWORD *)p_m_nVehicleFlags = v14;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v13;
    mFlags = pHandling->mFlags;
  }
  if ( (mFlags & 2) != 0 )
  {
    v14 |= 0x200u;
    *(_DWORD *)p_m_nVehicleFlags = v14;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v13;
    mFlags = pHandling->mFlags;
  }
  if ( (mFlags & 4) != 0 )
  {
    v14 |= 0x800u;
    *(_DWORD *)p_m_nVehicleFlags = v14;
    *((_DWORD *)&this->m_nVehicleFlags + 1) = v13;
  }
  this->Door[2].m_fClosedAngle = 0.0;
  this->Door[3].m_nAxis = 2;
  v16 = dword_54EA90;
  this->Door[3].m_nDirn = 20;
  this->Door[3].m_fClosedAngle = 0.0;
  this->Door[2].m_nAxis = 2;
  this->Door[2].m_nDirn = 20;
  v17 = dword_54EA88;
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( (v14 & 0x200) == 0 )
  {
    v17 = &dword_54EA88[1];
    v16 = &dword_54EA90[1];
  }
  v19 = *(float *)v17;
  LODWORD(this->Door[2].m_fOpenAngle) = *v16;
  this->Door[3].m_fOpenAngle = v19;
  if ( m_nModelIndex == 432 )
  {
    v20 = this->m_aCarNodes[6];
    this->Door[4].m_fOpenAngle = 1.0;
    this->Door[4].m_fClosedAngle = 1.0;
    this->Door[4].m_fAngle = 1.0;
    this->Door[4].m_fPrevAngle = 1.0;
    this->Door[5].m_fOpenAngle = 1.0;
    this->Door[5].m_fClosedAngle = 1.0;
    this->Door[5].m_fAngle = 1.0;
    this->Door[5].m_fPrevAngle = 1.0;
    GetFirstObject(v20)->flags = 0;
    GetFirstObject(this->m_aCarNodes[3])->flags = 0;
    pHandling = this->pHandling;
  }
  else
  {
    v21 = &this->Door[4];
    if ( (v14 & 0x100) != 0 )
    {
      v21->m_fOpenAngle = -1.5708;
      this->Door[4].m_nAxis = 2;
      this->Door[4].m_fClosedAngle = 0.0;
      this->Door[4].m_nDirn = 16;
      this->Door[5].m_nAxis = 2;
      this->Door[5].m_nDirn = 19;
      v22 = 1070141403;
    }
    else
    {
      v21->m_fOpenAngle = -1.2566;
      this->Door[4].m_nAxis = 2;
      this->Door[4].m_fClosedAngle = 0.0;
      this->Door[4].m_nDirn = 20;
      this->Door[5].m_nAxis = 2;
      v22 = 1067506044;
      this->Door[5].m_nDirn = 20;
    }
    LODWORD(this->Door[5].m_fOpenAngle) = v22;
    this->Door[5].m_fClosedAngle = 0.0;
  }
  v23 = dword_54EA98;
  v24 = pHandling->mFlags & 0x10;
  if ( !v24 )
    v23 = &dword_54EA98[1];
  v25 = *(float *)v23;
  v26 = 36;
  this->Door[0].m_fOpenAngle = v25;
  this->Door[0].m_nAxis = 0;
  this->Door[0].m_fClosedAngle = 0.0;
  if ( !v24 )
    v26 = 33;
  this->Door[0].m_nDirn = v26;
  if ( (pHandling->mFlags & 0x20) != 0 )
  {
    v29 = -1079977604;
    v30 = 21;
  }
  else
  {
    v27 = pHandling->mFlags & 0x40;
    v28 = dword_54EAA0;
    if ( !v27 )
      v28 = &dword_54EAA0[1];
    v29 = *v28;
    v30 = ((v27 >> 5) ^ 2) + 18;
  }
  this->Door[1].m_nAxis = 0;
  BouncingPanels = this->BouncingPanels;
  this->Door[1].m_nDirn = v30;
  this->Door[1].m_fClosedAngle = 0.0;
  LODWORD(this->Door[1].m_fOpenAngle) = v29;
  if ( BYTE1(pHandling->mFlags) << 31 )
  {
    CDamageManager::SetDoorStatus(&this->Damage, FRONT_LEFT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(&this->Damage, FRONT_RIGHT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(&this->Damage, REAR_LEFT_DOOR_0, 4u);
    CDamageManager::SetDoorStatus(&this->Damage, REAR_RIGHT_DOOR_0, 4u);
  }
  this->DoorRotation[0] = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
  this->DoorRotation[1] = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
  this->DoorRotation[2] = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
  this->DoorRotation[3] = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
  this->DoorRotation[4] = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
  v32 = (float)rand();
  v33 = (unsigned __int16)this->m_nModelIndex;
  this->DoorRotation[5] = (float)((float)(v32 * 4.6566e-10) * 0.3) + -0.15;
  if ( v33 == 531 )
  {
    if ( this->m_aCarNodes[17] && (unsigned __int16)BouncingPanels->m_nComponentIndex == 0xFFFF )
    {
      v34 = this->BouncingPanels;
      v35 = 17;
      v36 = 1;
      goto LABEL_41;
    }
  }
  else if ( v33 == 525 && this->m_aCarNodes[21] && (unsigned __int16)BouncingPanels->m_nComponentIndex == 0xFFFF )
  {
    v34 = this->BouncingPanels;
    v35 = 21;
    v36 = 2;
LABEL_41:
    CBouncingPanel::SetPanel(v34, v35, v36, 1.0);
  }
  if ( (this->hFlagsLocal & 0x10000000) != 0 )
  {
    v37 = this->m_nModelIndex;
    this->ChassisDoor.m_nDoorState = 1;
    v38 = v37 == 419;
    v39 = 0.03;
    if ( v37 != 419 )
      v38 = v37 == 598;
    if ( !v38 )
    {
      v40 = dword_54EAAC;
      if ( (unsigned __int16)v37 == 409 )
        v40 = &dword_54EAAC[1];
      v39 = *(float *)v40;
    }
    p_ChassisDoor->m_fOpenAngle = v39 * 3.1416;
    this->ChassisDoor.m_nAxis = 2;
    this->ChassisDoor.m_fClosedAngle = v39 * -3.1416;
    this->ChassisDoor.m_nDirn = 196;
  }
  else if ( this->m_nModelIndex == 544 )
  {
    p_ChassisDoor->m_fOpenAngle = 0.31416;
    this->ChassisDoor.m_fClosedAngle = -0.31416;
    *(_DWORD *)&this->ChassisDoor.m_nDirn = 16908676;
  }
  this->m_vecOldTurnSpeed.y = 0.0;
  this->m_vecOldTurnSpeed.z = 0.0;
  v41 = this->pHandling;
  *(_QWORD *)&this->m_vecOldMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecOldMoveSpeed.z = 0LL;
  this->m_fMass = v41->fMass;
  this->m_fTurnMass = v41->fTurnMass;
  v42 = *(_QWORD *)&v41->CentreOfMass.x;
  this->m_vecCOM.z = v41->CentreOfMass.z;
  this->m_fElasticity = 0.05;
  *(_QWORD *)&this->m_vecCOM.x = v42;
  this->m_fBuoyancyConstant = v41->fBuoyancyConstant;
  fDragCoeff = v41->fDragCoeff;
  if ( fDragCoeff > 0.01 )
    fDragCoeff = (float)(fDragCoeff * 0.5) / 1000.0;
  this->m_fAirResistance = fDragCoeff;
  this->m_fSteerAngle = 0.0;
  this->m_fGasPedal = 0.0;
  this->m_fBrakePedal = 0.0;
  this->pEntityThatSetUsOnFire = 0;
  this->m_fGasPedalAudioRevs = 0.0;
  this->m_nHornPattern = 0;
  this->m_cHorn = 0;
  this->ZRot = 0.0;
  this->ZRotSpeed = 0.0;
  this->fPrevSpeed = 0.0;
  this->m_aGroundPhysicalPtrs[0] = 0;
  this->m_aGroundOffsets[0].x = 0.0;
  this->m_aGroundOffsets[0].y = 0.0;
  this->m_aGroundOffsets[0].z = 0.0;
  this->m_aWheelRatios[0] = 1.0;
  this->m_aRatioHistory[0] = 1.0;
  this->m_aWheelCounts[0] = 0.0;
  this->m_aWheelPitchAngles[0] = 0.0;
  this->m_aWheelAngularVelocity[0] = 0.0;
  this->m_aWheelLongitudinalSlip[0] = 0.0;
  this->m_aWheelState[0] = WS_ROLLING;
  this->aWheelSkidmarkType[0] = SKIDMARKTYPE_DEFAULT;
  this->m_aGroundPhysicalPtrs[1] = 0;
  *(_DWORD *)&this->m_nSuspensionHydraulics = 0;
  this->m_nBusDoorTimer = 0;
  this->m_nBusDoorStart = 0;
  this->bWheelBloody[0] = 0;
  this->m_aGroundOffsets[1].x = 0.0;
  this->m_aWheelRatios[1] = 1.0;
  this->m_aRatioHistory[1] = 1.0;
  this->m_aWheelCounts[1] = 0.0;
  this->m_aWheelPitchAngles[1] = 0.0;
  this->m_aWheelAngularVelocity[1] = 0.0;
  this->m_aWheelLongitudinalSlip[1] = 0.0;
  this->m_aWheelState[1] = WS_ROLLING;
  this->aWheelSkidmarkType[1] = SKIDMARKTYPE_DEFAULT;
  this->bWheelBloody[1] = 0;
  this->m_aGroundPhysicalPtrs[2] = 0;
  this->m_aWheelRatios[2] = 1.0;
  this->m_aRatioHistory[2] = 1.0;
  this->m_aWheelCounts[2] = 0.0;
  this->m_aWheelPitchAngles[2] = 0.0;
  this->m_aWheelAngularVelocity[2] = 0.0;
  this->m_aWheelLongitudinalSlip[2] = 0.0;
  this->m_aWheelState[2] = WS_ROLLING;
  this->aWheelSkidmarkType[2] = SKIDMARKTYPE_DEFAULT;
  this->bWheelBloody[2] = 0;
  this->m_aGroundPhysicalPtrs[3] = 0;
  this->m_aGroundOffsets[1].y = 0.0;
  this->m_aGroundOffsets[1].z = 0.0;
  this->m_aGroundOffsets[2].x = 0.0;
  this->m_aGroundOffsets[2].y = 0.0;
  this->m_aGroundOffsets[2].z = 0.0;
  this->m_aGroundOffsets[3].x = 0.0;
  this->m_aGroundOffsets[3].y = 0.0;
  this->m_aGroundOffsets[3].z = 0.0;
  *(_QWORD *)&this->m_fHeightAboveRoad = 0LL;
  *(_QWORD *)&this->m_fExtraTractionMult = 0x3F8000003F800000LL;
  this->m_aWheelRatios[3] = 1.0;
  this->m_aRatioHistory[3] = 1.0;
  this->m_aWheelCounts[3] = 0.0;
  this->m_aWheelPitchAngles[3] = 0.0;
  this->m_aWheelAngularVelocity[3] = 0.0;
  this->m_aWheelLongitudinalSlip[3] = 0.0;
  this->m_aWheelState[3] = WS_ROLLING;
  this->aWheelSkidmarkType[3] = SKIDMARKTYPE_DEFAULT;
  this->bWheelBloody[3] = 0;
  this->m_nDriveWheelsOnGroundLastFrame = 0;
  *(_WORD *)&this->nNoOfContactWheels = 0;
  if ( v47 )
    (*((void (__fastcall **)(CAutomobile *))this->_vptr$CPlaceable + 49))(this);
  this->m_nNumPassengers = 0;
  m_eDoorLockState = this->m_eDoorLockState;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_info & 7 | 0x10);
  if ( m_eDoorLockState == CARLOCK_UNLOCKED && CVehicle::IsLawEnforcementVehicle(this) )
    this->m_eDoorLockState = CARLOCK_LOCKED_INITIALLY;
  this->HeliRequestedOrientation = -1.0;
  this->PropRotate = 0.0;
  this->m_HarvesterTimer = 0;
  v45 = (unsigned __int16)this->m_nModelIndex;
  *(_QWORD *)&this->LeftDoorOpenForDriveBys = 0LL;
  *(_QWORD *)&this->GunOrientation = 0x3D4CCCCD00000000LL;
  if ( v45 == 432 )
  {
    *(_DWORD *)&this->m_nPhysicalFlags |= 0x840000u;
  }
  else if ( v45 == 65534 )
  {
    GetFirstObject(this->m_aCarNodes[5])->flags = 0;
    if ( (unsigned __int16)this->m_nModelIndex == 65534 )
    {
      v49.m_pRwMat = 0;
      v49.m_owner = 0;
      CMatrix::Attach(&v49, &this->m_aCarNodes[2]->modelling, 0);
      CMatrix::CMatrix(&v48, &this->m_aCarNodes[5]->modelling, 0);
      CMatrix::SetTranslate(&v49, v48.tx + 0.1, 0.0, v48.tz);
      CMatrix::UpdateRW(&v49);
      CMatrix::~CMatrix(&v48);
      CMatrix::~CMatrix(&v49);
    }
  }
  this->m_pFxSysNitro1 = 0;
  this->m_pFxSysNitro2 = 0;
  CAEVehicleAudioEntity::Initialise(&this->m_VehicleAudioEntity, this);
  this->m_statusWhenEngineBlown = 0;
  this->m_heliDustRatio = 0.0;
}
// 54EA88: using guessed type int dword_54EA88[2];
// 54EA90: using guessed type int dword_54EA90[2];
// 54EA98: using guessed type int dword_54EA98[2];
// 54EAA0: using guessed type int dword_54EAA0[2];
// 54EAAC: using guessed type int dword_54EAAC[2];
// 66D678: using guessed type void *;
// 6767A0: using guessed type __int16 *MI_HYDRAULICS_ptr[3];

//----- (0054EAC8) --------------------------------------------------------
void __fastcall CAutomobile::~CAutomobile(CAutomobile *this)
{
  FxSystem_c *m_fxSysEngFire; // r0
  FxSystem_c *m_pFxSysNitro1; // r0
  FxSystem_c *m_pFxSysNitro2; // r0

  m_fxSysEngFire = this->m_fxSysEngFire;
  this->_vptr$CPlaceable = (int (**)(void))&off_66D678;
  if ( m_fxSysEngFire )
  {
    FxSystem_c::Kill(m_fxSysEngFire);
    this->m_fxSysEngFire = 0;
  }
  m_pFxSysNitro1 = this->m_pFxSysNitro1;
  if ( m_pFxSysNitro1 )
  {
    FxSystem_c::Kill(m_pFxSysNitro1);
    this->m_pFxSysNitro1 = 0;
  }
  m_pFxSysNitro2 = this->m_pFxSysNitro2;
  if ( m_pFxSysNitro2 )
  {
    FxSystem_c::Kill(m_pFxSysNitro2);
    this->m_pFxSysNitro2 = 0;
  }
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  sub_195C74(this);
}
// 66D678: using guessed type void *off_66D678;

//----- (0054EB20) --------------------------------------------------------
void __fastcall CAutomobile::StopNitroEffect(CAutomobile *this)
{
  FxSystem_c *m_pFxSysNitro1; // r0
  FxSystem_c *m_pFxSysNitro2; // r0

  m_pFxSysNitro1 = this->m_pFxSysNitro1;
  if ( m_pFxSysNitro1 )
  {
    FxSystem_c::Kill(m_pFxSysNitro1);
    this->m_pFxSysNitro1 = 0;
  }
  m_pFxSysNitro2 = this->m_pFxSysNitro2;
  if ( m_pFxSysNitro2 )
  {
    FxSystem_c::Kill(m_pFxSysNitro2);
    this->m_pFxSysNitro2 = 0;
  }
}

//----- (0054EB4C) --------------------------------------------------------
void __fastcall CAutomobile::~CAutomobile(CAutomobile *this)
{
  FxSystem_c *m_fxSysEngFire; // r0
  FxSystem_c *m_pFxSysNitro1; // r0
  FxSystem_c *m_pFxSysNitro2; // r0
  void *v5; // r0

  m_fxSysEngFire = this->m_fxSysEngFire;
  this->_vptr$CPlaceable = (int (**)(void))&off_66D678;
  if ( m_fxSysEngFire )
  {
    FxSystem_c::Kill(m_fxSysEngFire);
    this->m_fxSysEngFire = 0;
  }
  m_pFxSysNitro1 = this->m_pFxSysNitro1;
  if ( m_pFxSysNitro1 )
  {
    FxSystem_c::Kill(m_pFxSysNitro1);
    this->m_pFxSysNitro1 = 0;
  }
  m_pFxSysNitro2 = this->m_pFxSysNitro2;
  if ( m_pFxSysNitro2 )
  {
    FxSystem_c::Kill(m_pFxSysNitro2);
    this->m_pFxSysNitro2 = 0;
  }
  CAEVehicleAudioEntity::Terminate(&this->m_VehicleAudioEntity);
  CVehicle::~CVehicle(this);
  sub_199F98(v5);
}
// 54EB9E: variable 'v5' is possibly undefined
// 66D678: using guessed type void *off_66D678;

//----- (0054EBA8) --------------------------------------------------------
void __fastcall CAutomobile::SetModelIndex(CAutomobile *this, uint32 index)
{
  RpClump_0 *m_pRwObject; // r0

  CVehicle::SetModelIndex(this, index);
  this->m_aCarNodes[24] = 0;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aCarNodes[20] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[22] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[16] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[18] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[12] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[14] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[8] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[10] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[4] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[6] = 0LL;
  *(_QWORD *)this->m_aCarNodes = 0LL;
  *(_QWORD *)&this->m_aCarNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aCarNodes);
}

//----- (0054EBF6) --------------------------------------------------------
void __fastcall CAutomobile::SetupModelNodes(CAutomobile *this)
{
  RpClump_0 *m_pRwObject; // r2

  this->m_aCarNodes[24] = 0;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  *(_QWORD *)&this->m_aCarNodes[20] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[22] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[16] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[18] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[12] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[14] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[8] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[10] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[4] = 0LL;
  *(_QWORD *)&this->m_aCarNodes[6] = 0LL;
  *(_QWORD *)this->m_aCarNodes = 0LL;
  *(_QWORD *)&this->m_aCarNodes[2] = 0LL;
  sub_18AA98(m_pRwObject, this->m_aCarNodes);
}

//----- (0054EC38) --------------------------------------------------------
void __fastcall CAutomobile::SetupSuspensionLines(CAutomobile *this)
{
  float32x2_t v1; // d2
  float32x2_t v2; // d3
  CVehicleModelInfo *v4; // r10
  CColModel *ColModel; // r5
  CCollisionData *m_pColData; // r6
  int v7; // r0
  int v8; // r1
  float *m_fLineLength; // r9
  int32 v10; // r5
  int v11; // r11
  int *v12; // r0
  float z; // r0
  __int64 v14; // d16
  int v15; // r0
  bool v16; // zf
  float *p_m_wheelScale; // r0
  CColLine *m_pLineArray; // r0
  __int64 v19; // d16
  float *v20; // r0
  tHandlingData *pHandling; // r1
  float v22; // s4
  float v23; // s4
  float v24; // s2
  float *v25; // r1
  float v26; // s2
  int v27; // r2
  int v28; // r5
  float v29; // s2
  int m_nNoOfSpheres; // r2
  int v31; // r0
  int v32; // r1
  float v33; // s2
  CColSphere *m_pSphereArray; // r3
  float v35; // s8
  int v36; // r0
  int v37; // r1
  int v38; // s4
  float *v39; // r2
  float v40; // s8
  float v41; // s10
  float v42; // s12
  float v43; // s14
  float v44; // s4
  float v45; // s1
  float v46; // s3
  float *v47; // r2
  float *v48; // r2
  float v49; // s8
  float v50; // s10
  float v51; // s12
  float v52; // s14
  float v53; // s3
  float v54; // s1
  float *v55; // r2
  int v56; // r0
  int v57; // r1
  int v58; // s4
  float *v59; // r2
  float v60; // s8
  float v61; // s10
  float v62; // s12
  float v63; // s14
  float v64; // s4
  float v65; // s1
  float v66; // s3
  float *v67; // r2
  float *v68; // r2
  float v69; // s8
  float v70; // s10
  float v71; // s12
  float v72; // s14
  float v73; // s3
  float v74; // s1
  float *v75; // r2
  float *p_x; // [sp+0h] [bp-48h]
  CColModel *v77; // [sp+4h] [bp-44h]
  int v78; // [sp+8h] [bp-40h]
  float *p_m_wheelScaleRear; // [sp+Ch] [bp-3Ch]
  CVector posn; // [sp+10h] [bp-38h] BYREF

  v4 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  ColModel = CEntity::GetColModel(this);
  m_pColData = ColModel->m_pColData;
  if ( m_pColData->_anon_1.m_pLineArray )
  {
    v7 = 1;
  }
  else
  {
    v8 = 4;
    if ( this->m_nModelIndex == 432 )
      v8 = 12;
    m_pColData->_anon_0.m_nNoOfLines = v8;
    m_pColData->_anon_1.m_pLineArray = (CColLine *)CMemoryMgr::Malloc(32 * v8);
    v7 = 0;
  }
  m_fLineLength = this->m_fLineLength;
  v78 = v7;
  p_x = &ColModel->m_boxBound.m_vecMin.x;
  v77 = ColModel;
  v10 = 0;
  v11 = 24;
  p_m_wheelScaleRear = &v4->m_wheelScaleRear;
  do
  {
    CVehicleModelInfo::GetWheelPosn(v4, v10, &posn, 0);
    if ( this->m_vehicleType == 2 )
    {
      v12 = dword_54F16C;
      if ( posn.x > 0.0 )
        v12 = &dword_54F16C[1];
      posn.x = posn.x + *(float *)v12;
    }
    z = posn.z;
    *(m_fLineLength - 20) = posn.z;
    posn.z = this->pHandling->fSuspensionUpperLimit + z;
    v14 = *(_QWORD *)&posn.x;
    v15 = (int)m_pColData->_anon_1.m_pLineArray + v11;
    *(RwReal *)(v15 - 16) = posn.z;
    *(_QWORD *)(v15 - 24) = v14;
    LOWORD(v15) = v10++ | 2;
    v16 = (unsigned __int16)v15 == 2;
    p_m_wheelScale = &v4->m_wheelScaleRear;
    if ( v16 )
      p_m_wheelScale = &v4->m_wheelScale;
    posn.z = posn.z
           + (float)((float)(this->pHandling->fSuspensionLowerLimit - this->pHandling->fSuspensionUpperLimit)
                   + (float)(*p_m_wheelScale * -0.5));
    m_pLineArray = m_pColData->_anon_1.m_pLineArray;
    v19 = *(_QWORD *)&posn.x;
    *(RwReal *)((char *)&m_pLineArray->m_vecStart.x + v11) = posn.z;
    *(_QWORD *)((char *)m_pLineArray + v11 - 8) = v19;
    *(m_fLineLength - 4) = this->pHandling->fSuspensionUpperLimit - this->pHandling->fSuspensionLowerLimit;
    v20 = (float *)((char *)&m_pColData->_anon_1.m_pLineArray->m_vecStart.x + v11);
    v11 += 32;
    *m_fLineLength++ = *(v20 - 4) - *v20;
  }
  while ( v11 != 152 );
  if ( CVehicle::GetVehicleAppearance(this) != APR_PLANE )
    CVehicle::GetVehicleAppearance(this);
  pHandling = this->pHandling;
  v22 = (float)(v4->m_wheelScale * 0.5)
      + (float)((float)(this->m_fSuspensionLength[0]
                      * (float)(1.0 - (float)(1.0 / (float)(pHandling->fSuspensionForce * 4.0))))
              - m_pColData->_anon_1.m_pLineArray->m_vecStart.z);
  this->m_fHeightAboveRoad = v22;
  this->m_fRearHeightAboveRoad = (float)(*p_m_wheelScaleRear * 0.5)
                               + (float)((float)(this->m_fSuspensionLength[3]
                                               * (float)(1.0 - (float)(1.0 / (float)(pHandling->fSuspensionForce * 4.0))))
                                       - m_pColData->_anon_1.m_pLineArray[3].m_vecStart.z);
  this->m_aWheelSuspensionHeights[0] = (float)(v4->m_wheelScale * 0.5) - v22;
  this->m_aWheelSuspensionHeights[1] = (float)(*p_m_wheelScaleRear * 0.5) - v22;
  this->m_aWheelSuspensionHeights[2] = (float)(v4->m_wheelScale * 0.5) - v22;
  this->m_aWheelSuspensionHeights[3] = (float)(*p_m_wheelScaleRear * 0.5) - v22;
  v23 = m_pColData->_anon_1.m_pLineArray->m_vecEnd.z;
  v24 = p_x[2];
  v25 = &v77->m_boxBound.m_vecMin.x;
  if ( v23 < v24 )
  {
    p_x[2] = v23;
    v24 = v23;
  }
  if ( sqrtf((float)((float)(*p_x * *p_x) + (float)(p_x[1] * p_x[1])) + (float)(v24 * v24)) <= sqrtf(
                                                                                                 (float)((float)(p_x[3] * p_x[3]) + (float)(p_x[4] * p_x[4]))
                                                                                               + (float)(p_x[5] * p_x[5])) )
    v25 = &v77->m_boxBound.m_vecMax.x;
  v26 = sqrtf((float)((float)(*v25 * *v25) + (float)(v25[1] * v25[1])) + (float)(v25[2] * v25[2]));
  if ( p_x[9] < v26 )
    p_x[9] = v26;
  if ( this->m_nModelIndex == 441 )
  {
    p_x[9] = 2.0;
    if ( m_pColData->m_nNoOfSpheres >= 1 )
    {
      LOWORD(v27) = 0;
      do
      {
        v28 = (__int16)v27;
        v27 = (__int16)(v27 + 1);
        m_pColData->m_pSphereArray[v28].m_fRadius = 0.3;
      }
      while ( v27 < m_pColData->m_nNoOfSpheres );
    }
  }
  if ( !(((this->pHandling->mFlags & 0x40000000) == 0) | v78) )
  {
    v29 = 0.25;
    if ( this->m_nModelIndex == 571 )
      v29 = 0.12;
    m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
    if ( m_nNoOfSpheres >= 1 )
    {
      v31 = 0;
      v32 = 12;
      v33 = v29 - this->m_fHeightAboveRoad;
      v1.n64_u32[0] = 1053609165;
      do
      {
        m_pSphereArray = m_pColData->m_pSphereArray;
        v35 = *(float *)((char *)m_pSphereArray + v32 - 4);
        v2.n64_u32[0] = *(_DWORD *)((char *)&m_pSphereArray->m_vecCentre.x + v32);
        if ( (float)(v35 - v2.n64_f32[0]) < v33 )
        {
          if ( v2.n64_f32[0] > 0.4 )
          {
            v2.n64_f32[0] = v35 - v33;
            v2.n64_u64[0] = vmax_f32(v2, v1).n64_u64[0];
            *(_DWORD *)((char *)&m_pSphereArray->m_vecCentre.x + v32) = v2.n64_u32[0];
            m_pSphereArray = m_pColData->m_pSphereArray;
            v2.n64_u32[0] = *(_DWORD *)((char *)&m_pSphereArray->m_vecCentre.x + v32);
          }
          *(float *)((char *)m_pSphereArray + v32 - 4) = v33 + v2.n64_f32[0];
          LOWORD(m_nNoOfSpheres) = m_pColData->m_nNoOfSpheres;
        }
        v32 += 20;
        ++v31;
      }
      while ( v31 < (__int16)m_nNoOfSpheres );
    }
  }
  if ( this->m_nModelIndex == 432 )
  {
    v36 = 32;
    v37 = 1;
    do
    {
      v38 = v37++;
      v39 = &m_pColData->_anon_1.m_pLineArray->m_vecStart.x;
      v40 = v39[8];
      v41 = v39[9];
      v42 = v39[10];
      v43 = *v39;
      v44 = (float)v38 * 0.2;
      v45 = v39[1];
      v46 = v39[2];
      v47 = &v39[v36];
      *v47 = (float)((float)(1.0 - v44) * v43) + (float)(v44 * v40);
      v47[1] = (float)((float)(1.0 - v44) * v45) + (float)(v44 * v41);
      v47[2] = (float)((float)(1.0 - v44) * v46) + (float)(v44 * v42);
      v48 = &m_pColData->_anon_1.m_pLineArray->m_vecStart.x;
      v49 = v44 * v48[12];
      v50 = v44 * v48[13];
      v51 = v48[14];
      v52 = (float)(1.0 - v44) * v48[4];
      v53 = v48[6];
      v54 = (float)(1.0 - v44) * v48[5];
      v55 = &v48[v36];
      v36 += 8;
      v55[4] = v52 + v49;
      v55[5] = v54 + v50;
      v55[6] = (float)((float)(1.0 - v44) * v53) + (float)(v44 * v51);
    }
    while ( v36 != 64 );
    v56 = 70;
    v57 = 1;
    do
    {
      v58 = v57++;
      v59 = &m_pColData->_anon_1.m_pLineArray->m_vecStart.x;
      v60 = v59[24];
      v61 = v59[25];
      v62 = v59[26];
      v63 = v59[16];
      v64 = (float)v58 * 0.2;
      v65 = v59[17];
      v66 = v59[18];
      v67 = &v59[v56];
      *(v67 - 6) = (float)((float)(1.0 - v64) * v63) + (float)(v64 * v60);
      *(v67 - 5) = (float)((float)(1.0 - v64) * v65) + (float)(v64 * v61);
      *(v67 - 4) = (float)((float)(1.0 - v64) * v66) + (float)(v64 * v62);
      v68 = &m_pColData->_anon_1.m_pLineArray->m_vecStart.x;
      v69 = v64 * v68[28];
      v70 = v64 * v68[29];
      v71 = v68[30];
      v72 = (float)(1.0 - v64) * v68[20];
      v73 = v68[22];
      v74 = (float)(1.0 - v64) * v68[21];
      v75 = &v68[v56];
      v56 += 8;
      *(v75 - 2) = v72 + v69;
      *(v75 - 1) = v74 + v70;
      *v75 = (float)((float)(1.0 - v64) * v73) + (float)(v64 * v71);
    }
    while ( v56 != 102 );
  }
}
// 54EFB8: variable 'v2' is possibly undefined
// 54EFB8: variable 'v1' is possibly undefined
// 54F16C: using guessed type int dword_54F16C[2];

//----- (0054F180) --------------------------------------------------------
TweakInt32 CAutomobile::GetJackedCounter()
{
  return 500;
}

//----- (0054F188) --------------------------------------------------------
void __fastcall CAutomobile::HydraulicControl(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float32x2_t v4; // d4
  float32x2_t v5; // d5
  unsigned __int64 v6; // d11
  CVehicleModelInfo *v8; // r9
  unsigned int m_info; // r0
  float m_wheelScale; // s18
  bool v11; // zf
  CPed *pDriver; // r0
  CPlayerPed *v13; // r6
  int m_nSpecialColModel; // r2
  float v15; // s18
  float fJackedUpper; // s28
  CCollisionData *m_pColData; // r8
  tHydraulicData *v18; // r0
  float fJackedLower; // s19
  float fStdUpper; // s26
  float fSuspensionLowerLimit; // s20
  float v22; // s30
  float v23; // s24
  int m_nNoOfSpheres; // r0
  float32x2_t v25; // d14
  int v26; // r2
  int p_z; // r1
  float v28; // s2
  tHandlingData *pHandling; // r0
  int *v30; // r2
  float v31; // s2
  float v32; // s0
  float v33; // s0
  float v34; // s0
  float fStoppedLower; // s2
  float v36; // s0
  tHydraulicData *v37; // r0
  unsigned int m_nSuspensionHydraulics; // r0
  UInt16 v39; // r0
  int v40; // r10
  CPad *v41; // r0
  unsigned int v42; // r0
  UInt16 v43; // r1
  float v44; // s16
  float *v45; // r5
  int v46; // r4
  int32 v47; // r6
  float v48; // s20
  float v49; // s22
  float v50; // s24
  __int64 v51; // d16
  CColLine *v52; // r0
  __int64 v53; // d16
  CColLine *v54; // r0
  float v55; // s0
  float v56; // s0
  float v57; // s16
  float *v58; // r5
  int v59; // r4
  int32 v60; // r6
  float v61; // s20
  float v62; // s22
  float v63; // s28
  __int64 v64; // d16
  CColLine *v65; // r0
  __int64 v66; // d16
  CColLine *v67; // r0
  float v68; // s0
  float v69; // s0
  tHydraulicData *v70; // r0
  float v71; // r1
  float v72; // r2
  float v73; // r3
  float v74; // r0
  float32x2_t v75; // d2
  float v76; // s0
  CPad *PadFromPlayer; // r0
  float32x2_t v78; // d1
  CPad *v79; // r0
  int CarGunLeftRight; // r4
  CPad *v81; // r0
  int CarGunUpDown; // r0
  float v83; // s22
  float v84; // r6
  float v85; // s22
  unsigned int v86; // r0
  float v87; // s24
  float v88; // s17
  float v89; // s26
  float *v90; // r10
  _DWORD *v91; // r5
  int v92; // r4
  int32 v93; // r6
  float v94; // s25
  float v95; // s27
  float v96; // s31
  float v97; // s2
  float v98; // s0
  __int64 v99; // d16
  CColLine *v100; // r0
  CColLine *v101; // r0
  RwReal v102; // r1
  float v103; // s4
  float v104; // s0
  tHydraulicData *v105; // r0
  float v106; // s30
  _DWORD *v107; // r10
  float v108; // s28
  float *m_aWheelRatios; // r4
  int v110; // r5
  int32 v111; // r6
  float v112; // s25
  float v113; // s27
  float z; // s29
  float v115; // s2
  float v116; // s0
  __int64 v117; // d16
  CColLine *v118; // r0
  CColLine *v119; // r0
  RwReal v120; // r1
  float v121; // s4
  float v122; // s0
  float v123; // s0
  int v124; // r4
  float v125; // s0
  int v126; // r1
  int v127; // r0
  CAEVehicleAudioEntity *p_m_VehicleAudioEntity; // r0
  tAudioEvent v129; // r1
  float v130; // s8
  float v131; // s2
  float v132; // s6
  float v133; // s0
  float v134; // s2
  float v135; // s6
  float v136; // s0
  int v137; // [sp+4h] [bp-84h]
  unsigned __int64 v138; // [sp+8h] [bp-80h] BYREF
  unsigned __int64 v139; // [sp+10h] [bp-78h]
  CVector posn; // [sp+18h] [bp-70h] BYREF

  v8 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  m_info = (unsigned __int8)this->m_info;
  m_wheelScale = v8->m_wheelScale;
  if ( !(m_info >> 3) )
    goto LABEL_7;
  v11 = m_info >> 3 == 3;
  if ( m_info >> 3 == 3 )
    v11 = this->VehicleCreatedBy == 2;
  if ( v11 && this->m_nSpecialColModel >= 0 )
  {
LABEL_7:
    if ( (this->hFlagsLocal & 0x40000) == 0 )
    {
      if ( m_info > 7 )
      {
        v13 = 0;
        goto LABEL_16;
      }
      pDriver = this->pDriver;
      if ( pDriver )
      {
        if ( CPed::IsPlayer(pDriver) )
          v13 = (CPlayerPed *)this->pDriver;
        else
          v13 = 0;
      }
      else
      {
        v13 = 0;
      }
      if ( !CGameLogic::GameState )
      {
LABEL_16:
        if ( !CVehicle::GetSpecialColModel(this) )
          return;
        m_nSpecialColModel = this->m_nSpecialColModel;
        v15 = m_wheelScale * 0.5;
        fJackedUpper = CVehicle::m_aSpecialHydraulicData[m_nSpecialColModel].fJackedUpper;
        m_pColData = CVehicle::m_aSpecialColModel[m_nSpecialColModel].m_pColData;
        if ( fJackedUpper >= 100.0 )
        {
          LODWORD(v6) = 0;
          m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
          v25.n64_u64[0] = v6;
          if ( m_nNoOfSpheres >= 1 )
          {
            v26 = 0;
            v25.n64_u32[0] = 0;
            p_z = (int)&m_pColData->m_pSphereArray->m_vecCentre.z;
            do
            {
              v1.n64_u32[0] = *(_DWORD *)p_z;
              ++v26;
              v28 = *(float *)(p_z + 4);
              p_z += 20;
              v1.n64_f32[0] = v1.n64_f32[0] - v28;
              v25.n64_u64[0] = vmin_f32(v1, v25).n64_u64[0];
            }
            while ( v26 < m_nNoOfSpheres );
          }
          CVehicleModelInfo::GetWheelPosn(v8, 0, &posn, 0);
          pHandling = this->pHandling;
          v30 = dword_54FCA8;
          fSuspensionLowerLimit = pHandling->fSuspensionLowerLimit;
          v23 = (float)(pHandling->fSuspensionUpperLimit - fSuspensionLowerLimit) * 1.5;
          if ( (this->hFlagsLocal & 0x10000) == 0 )
            v23 = pHandling->fSuspensionUpperLimit - fSuspensionLowerLimit;
          fStdUpper = fSuspensionLowerLimit + v23;
          v31 = v23 * 0.15;
          v32 = v25.n64_f32[0] - posn.z;
          CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStdUpper = fSuspensionLowerLimit + v23;
          v2.n64_f32[0] = v32 + 0.0;
          v33 = v15 + v32;
          CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStdLower = fSuspensionLowerLimit;
          if ( (this->hFlagsLocal & 0x10000) == 0 )
            v30 = &dword_54FCA8[1];
          v4.n64_f32[0] = fStdUpper + *(float *)v30;
          fJackedLower = fSuspensionLowerLimit + *(float *)v30;
          fJackedUpper = vmax_f32(v4, v2).n64_f32[0];
          CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fJackedUpper = fJackedUpper;
          v22 = fJackedUpper - fJackedLower;
          CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fJackedLower = fJackedLower;
          CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStoppedUpper = fStdUpper - v31;
          v34 = v33 + -0.1;
          CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStoppedLower = fSuspensionLowerLimit + v31;
          fStoppedLower = CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStoppedLower;
          if ( fStoppedLower > v34 )
          {
            v36 = fStoppedLower - v34;
            CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStoppedUpper = CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].fStoppedUpper
                                                                                      - v36;
            v37 = &CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel];
            v37->fStoppedLower = v37->fStoppedLower - v36;
          }
        }
        else
        {
          v18 = &CVehicle::m_aSpecialHydraulicData[m_nSpecialColModel];
          fJackedLower = v18->fJackedLower;
          fStdUpper = v18->fStdUpper;
          fSuspensionLowerLimit = v18->fStdLower;
          v22 = fJackedUpper - fJackedLower;
          v23 = v18->fStdUpper - fSuspensionLowerLimit;
        }
        m_nSuspensionHydraulics = this->m_nSuspensionHydraulics;
        if ( m_nSuspensionHydraulics > 0x13 || this->fPrevSpeed <= 0.02 || this->m_fGasPedal == 0.0 )
        {
          v39 = m_nSuspensionHydraulics - 1;
          if ( v39 > 0x3Bu || this->fPrevSpeed >= 0.01 || (this->m_nSuspensionHydraulics = v39) != 0 )
          {
LABEL_36:
            v40 = 0;
            if ( v13 )
              goto LABEL_37;
LABEL_57:
            v138 = unk_5E8538;
            v139 = unk_5E8540;
            if ( (*(_BYTE *)&this->m_info & 0xF8) == 24 )
            {
              v70 = &CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel];
              v71 = v70->aScriptControl[0];
              v72 = v70->aScriptControl[1];
              v73 = v70->aScriptControl[2];
              v74 = v70->aScriptControl[3];
              v138 = __PAIR64__(LODWORD(v72), LODWORD(v71));
              v139 = __PAIR64__(LODWORD(v74), LODWORD(v73));
              *(float *)&v6 = v71;
              v75.n64_f32[0] = v72;
              v76 = v74;
            }
            else
            {
              LODWORD(v6) = 1.0;
              if ( v13 )
              {
                PadFromPlayer = CPlayerPed::GetPadFromPlayer(v13);
                v76 = 1.0;
                v78.n64_u32[1] = HIDWORD(v6);
                v75.n64_u64[0] = v6;
                if ( !CPad::GetHydraulicJump(PadFromPlayer) )
                {
                  v79 = CPlayerPed::GetPadFromPlayer(v13);
                  CarGunLeftRight = CPad::GetCarGunLeftRight(v79, 1, 1);
                  v81 = CPlayerPed::GetPadFromPlayer(v13);
                  CarGunUpDown = CPad::GetCarGunUpDown(v81, 1, 0, 2500.0, 1);
                  v83 = sqrtf(
                          (float)((float)CarGunLeftRight * (float)CarGunLeftRight)
                        + (float)((float)CarGunUpDown * (float)CarGunUpDown));
                  v84 = atan2f((float)CarGunLeftRight, (float)CarGunUpDown) + -0.7854;
                  v85 = (float)(v83 * 1.5) * 0.0078125;
                  v4.n64_u32[0] = 0;
                  v75.n64_f32[0] = cosf(v84) * v85;
                  v78.n64_f32[0] = sinf(v84) * v85;
                  v5.n64_f32[0] = -v78.n64_f32[0];
                  v3.n64_f32[0] = -v75.n64_f32[0];
                  LODWORD(v76) = vmax_f32(v75, v4).n64_u32[0];
                  v75.n64_u32[0] = vmax_f32(v5, v4).n64_u32[0];
                  LODWORD(v6) = vmax_f32(v3, v4).n64_u32[0];
                  v138 = __PAIR64__(v75.n64_u32[0], v6);
                  LODWORD(v139) = vmax_f32(v78, v4).n64_u32[0];
                  *((float *)&v139 + 1) = v76;
                }
              }
              else
              {
                v76 = 1.0;
                v75.n64_u32[0] = 1.0;
              }
            }
            v86 = this->m_nSuspensionHydraulics;
            v137 = v40;
            if ( v86 < 0x1F4 )
            {
              if ( *(float *)&v6 == 0.0 && v75.n64_f32[0] == 0.0 && v76 == 0.0 )
              {
                if ( !this->m_nSuspensionHydraulics )
                {
                  v105 = &CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel];
                  fStdUpper = v105->fStoppedUpper;
                  fSuspensionLowerLimit = v105->fStoppedLower;
                  v23 = fStdUpper - fSuspensionLowerLimit;
                }
              }
              else
              {
                if ( !this->m_nSuspensionHydraulics )
                {
                  LODWORD(v6) = 0;
                  v138 = 0LL;
                  v139 = 0LL;
                }
                this->m_nSuspensionHydraulics = 60;
              }
              v106 = v22 - v23;
              v107 = (_DWORD *)&v138 + 1;
              v108 = fJackedUpper - fStdUpper;
              v88 = 0.0;
              m_aWheelRatios = this->m_aWheelRatios;
              v110 = 0;
              v111 = 0;
              while ( 1 )
              {
                if ( *(float *)&v6 > 1.0 )
                {
                  *(v107 - 1) = 1065353216;
                  LODWORD(v6) = 1.0;
                }
                v112 = *m_aWheelRatios;
                v113 = m_aWheelRatios[45];
                z = m_pColData->_anon_1.m_pLineArray[v110].m_vecStart.z;
                CVehicleModelInfo::GetWheelPosn(v8, v111, &posn, 0);
                v115 = v23 + (float)(v106 * *(float *)&v6);
                posn.z = (float)(fStdUpper + (float)(v108 * *(float *)&v6)) + posn.z;
                v116 = v15 + v115;
                v117 = *(_QWORD *)&posn.x;
                v118 = &m_pColData->_anon_1.m_pLineArray[v110];
                v118->m_vecStart.z = posn.z;
                *(_QWORD *)&v118->m_vecStart.x = v117;
                posn.z = posn.z - (float)(v15 + v115);
                v119 = &m_pColData->_anon_1.m_pLineArray[v110];
                v120 = posn.z;
                if ( fabsf(posn.z - v119->m_vecEnd.z) > fabsf(v88) )
                  v88 = posn.z - v119->m_vecEnd.z;
                *(_QWORD *)&v119->m_vecEnd.x = *(_QWORD *)&posn.x;
                v119->m_vecEnd.z = v120;
                v121 = *m_aWheelRatios;
                m_aWheelRatios[45] = v116;
                m_aWheelRatios[41] = v115;
                if ( v121 < 1.0 )
                {
                  v122 = (float)(m_pColData->_anon_1.m_pLineArray[v110].m_vecStart.z - (float)(z - (float)(v112 * v113)))
                       / v116;
                  *m_aWheelRatios = v122;
                  if ( v122 > 1.0 )
                    *m_aWheelRatios = 1.0;
                }
                if ( v110 == 3 )
                  break;
                LODWORD(v6) = *v107;
                ++v111;
                ++m_aWheelRatios;
                ++v110;
                ++v107;
              }
            }
            else
            {
              v87 = v23 - v22;
              v88 = 0.0;
              v89 = fStdUpper - fJackedUpper;
              v90 = this->m_aWheelRatios;
              v91 = (_DWORD *)&v138 + 1;
              v92 = 0;
              v93 = 0;
              if ( v86 >> 3 <= 0x3E )
                this->m_nSuspensionHydraulics = v86 + 1;
              while ( 1 )
              {
                if ( *(float *)&v6 > 1.0 )
                {
                  *(v91 - 1) = 1065353216;
                  LODWORD(v6) = 1.0;
                }
                v94 = *v90;
                v95 = v90[45];
                v96 = m_pColData->_anon_1.m_pLineArray[v92].m_vecStart.z;
                CVehicleModelInfo::GetWheelPosn(v8, v93, &posn, 0);
                v97 = v22 + (float)(v87 * *(float *)&v6);
                posn.z = (float)(fJackedUpper + (float)(v89 * *(float *)&v6)) + posn.z;
                v98 = v15 + v97;
                v99 = *(_QWORD *)&posn.x;
                v100 = &m_pColData->_anon_1.m_pLineArray[v92];
                v100->m_vecStart.z = posn.z;
                *(_QWORD *)&v100->m_vecStart.x = v99;
                posn.z = posn.z - (float)(v15 + v97);
                v101 = &m_pColData->_anon_1.m_pLineArray[v92];
                v102 = posn.z;
                if ( fabsf(posn.z - v101->m_vecEnd.z) > fabsf(v88) )
                  v88 = posn.z - v101->m_vecEnd.z;
                *(_QWORD *)&v101->m_vecEnd.x = *(_QWORD *)&posn.x;
                v101->m_vecEnd.z = v102;
                v103 = *v90;
                v90[45] = v98;
                v90[41] = v97;
                if ( v103 < 1.0 )
                {
                  v104 = (float)(m_pColData->_anon_1.m_pLineArray[v92].m_vecStart.z - (float)(v96 - (float)(v94 * v95)))
                       / v98;
                  *v90 = v104;
                  if ( v104 > 1.0 )
                    *v90 = 1.0;
                }
                if ( v92 == 3 )
                  break;
                LODWORD(v6) = *v91;
                ++v93;
                ++v90;
                ++v92;
                ++v91;
              }
            }
            v123 = fJackedLower - fSuspensionLowerLimit;
            v124 = v137;
            if ( (float)(fJackedLower - fSuspensionLowerLimit) != 0.0 && fabsf(v88 / v123) > 0.01 )
            {
              v125 = (float)((float)(v88 + v123) * 0.5) / v123;
              if ( v125 >= 0.0 )
              {
                if ( v125 > 1.0 )
                  v125 = 1.0;
              }
              else
              {
                v125 = 0.0;
              }
              v126 = 0;
              v127 = 0;
              if ( v125 > 0.6 )
                v126 = 1;
              if ( v125 < 0.4 )
                v127 = 1;
              v124 = v137 | v127 | v126;
              if ( v125 < (float)(0.5 - (float)(CTimer::ms_fTimeStep * 0.05)) )
                goto LABEL_109;
              if ( v125 > (float)((float)(CTimer::ms_fTimeStep * 0.05) + 0.5) )
              {
                p_m_VehicleAudioEntity = &this->m_VehicleAudioEntity;
                v129 = 109;
                goto LABEL_110;
              }
              if ( v125 > (float)((float)(CTimer::ms_fTimeStep * 0.025) + 0.5) )
              {
LABEL_109:
                p_m_VehicleAudioEntity = &this->m_VehicleAudioEntity;
                v129 = 107;
LABEL_110:
                CAEVehicleAudioEntity::AddAudioEvent(p_m_VehicleAudioEntity, v129, 0.0);
                if ( !v124 )
                  goto LABEL_114;
                goto LABEL_113;
              }
            }
            if ( v124 != 1 )
            {
LABEL_114:
              CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].aScriptControl[0] = 0.0;
              CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].aScriptControl[1] = 0.0;
              CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].aScriptControl[2] = 0.0;
              CVehicle::m_aSpecialHydraulicData[this->m_nSpecialColModel].aScriptControl[3] = 0.0;
              return;
            }
LABEL_113:
            v130 = 1.0 - (float)(this->m_fSuspensionLength[0] / this->m_fLineLength[0]);
            v131 = 1.0 - (float)(this->m_fSuspensionLength[1] / this->m_fLineLength[1]);
            v132 = 1.0 - (float)(this->m_fSuspensionLength[2] / this->m_fLineLength[2]);
            v133 = 1.0 - (float)(this->m_fSuspensionLength[3] / this->m_fLineLength[3]);
            v134 = (float)(this->m_aWheelRatios[1] - v131) / (float)(1.0 - v131);
            v135 = (float)(this->m_aWheelRatios[2] - v132) / (float)(1.0 - v132);
            v136 = (float)(this->m_aWheelRatios[3] - v133) / (float)(1.0 - v133);
            this->m_aRatioHistory[0] = (float)(this->m_aWheelRatios[0] - v130) / (float)(1.0 - v130);
            this->m_aRatioHistory[1] = v134;
            this->m_aRatioHistory[2] = v135;
            this->m_aRatioHistory[3] = v136;
            goto LABEL_114;
          }
          v40 = 0;
          CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 111, 0.0);
          if ( !v13 )
            goto LABEL_57;
        }
        else
        {
          if ( this->m_nSuspensionHydraulics )
          {
            this->m_nSuspensionHydraulics = m_nSuspensionHydraulics + 1;
            goto LABEL_36;
          }
          this->m_nSuspensionHydraulics = 20;
          CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 110, 0.0);
          v40 = 1;
          if ( !v13 )
            goto LABEL_57;
        }
LABEL_37:
        v41 = CPlayerPed::GetPadFromPlayer(v13);
        if ( CPad::HornJustDown(v41) )
        {
          v42 = this->m_nSuspensionHydraulics;
          v43 = 60;
          if ( v42 < 0x1F4 )
            v43 = 500;
          this->m_nSuspensionHydraulics = v43;
          if ( v42 >= 0x1F4 )
          {
            v57 = v15 + v23;
            v58 = this->m_aWheelRatios;
            v59 = 0;
            v60 = 0;
            do
            {
              v61 = *v58;
              v62 = v58[45];
              v63 = m_pColData->_anon_1.m_pLineArray[v59].m_vecStart.z;
              CVehicleModelInfo::GetWheelPosn(v8, v60, &posn, 0);
              posn.z = fStdUpper + posn.z;
              v64 = *(_QWORD *)&posn.x;
              v65 = &m_pColData->_anon_1.m_pLineArray[v59];
              v65->m_vecStart.z = posn.z;
              *(_QWORD *)&v65->m_vecStart.x = v64;
              posn.z = posn.z - v57;
              v66 = *(_QWORD *)&posn.x;
              v67 = &m_pColData->_anon_1.m_pLineArray[v59];
              v67->m_vecEnd.z = posn.z;
              *(_QWORD *)&v67->m_vecEnd.x = v66;
              v68 = *v58;
              v58[45] = v57;
              v58[41] = v23;
              if ( v68 < 1.0 )
              {
                v69 = (float)(m_pColData->_anon_1.m_pLineArray[v59].m_vecStart.z - (float)(v63 - (float)(v61 * v62)))
                    / v57;
                *v58 = v69;
                if ( v69 > 1.0 )
                  *v58 = 1.0;
              }
              ++v59;
              ++v58;
              ++v60;
            }
            while ( v59 != 4 );
            CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 107, 0.0);
            if ( !v40 )
              goto LABEL_114;
          }
          else
          {
            v44 = v15 + v22;
            v45 = this->m_aWheelRatios;
            v46 = 0;
            v47 = 0;
            do
            {
              v48 = *v45;
              v49 = v45[45];
              v50 = m_pColData->_anon_1.m_pLineArray[v46].m_vecStart.z;
              CVehicleModelInfo::GetWheelPosn(v8, v47, &posn, 0);
              posn.z = fJackedUpper + posn.z;
              v51 = *(_QWORD *)&posn.x;
              v52 = &m_pColData->_anon_1.m_pLineArray[v46];
              v52->m_vecStart.z = posn.z;
              *(_QWORD *)&v52->m_vecStart.x = v51;
              posn.z = posn.z - v44;
              v53 = *(_QWORD *)&posn.x;
              v54 = &m_pColData->_anon_1.m_pLineArray[v46];
              v54->m_vecEnd.z = posn.z;
              *(_QWORD *)&v54->m_vecEnd.x = v53;
              v55 = *v45;
              v45[45] = v44;
              v45[41] = v22;
              if ( v55 < 1.0 )
              {
                v56 = (float)(m_pColData->_anon_1.m_pLineArray[v46].m_vecStart.z - (float)(v50 - (float)(v48 * v49)))
                    / v44;
                *v45 = v56;
                if ( v56 > 1.0 )
                  *v45 = 1.0;
              }
              ++v46;
              ++v45;
              ++v47;
            }
            while ( v46 != 4 );
            CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 109, 0.0);
          }
          goto LABEL_113;
        }
        goto LABEL_57;
      }
    }
  }
}
// 54F286: variable 'v6' is possibly undefined
// 54F2AC: variable 'v1' is possibly undefined
// 54F350: variable 'v4' is possibly undefined
// 54F350: variable 'v2' is possibly undefined
// 54F79A: variable 'v5' is possibly undefined
// 54F79E: variable 'v3' is possibly undefined
// 54FCA8: using guessed type int dword_54FCA8[2];

//----- (0054FCDC) --------------------------------------------------------
bool __fastcall CAutomobile::UpdateMovingCollision(CAutomobile *this, float fScriptControl)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float y; // s18
  float z; // s20
  CPad *m_nModelIndex; // r0
  bool v8; // zf
  bool v9; // zf
  float x; // s16
  CPed *pDriver; // r0
  CPad *v12; // r5
  int v13; // r1
  bool v14; // zf
  bool v15; // zf
  int v16; // r8
  unsigned __int32 v17; // s0
  CColModel *m_pColModel; // r6
  CCollisionData *m_pColData; // r11
  CCollisionData *v21; // r10
  float CarGunUpDown; // s0
  unsigned int v23; // s0
  int m_nSuspensionHydraulics; // r6
  int v25; // r0
  float v26; // s2
  float v27; // s4
  UInt16 *p_m_nSuspensionHydraulics; // r2
  int v29; // r1
  int v30; // r0
  float v32; // s2
  RwFrame_0 *v33; // r0
  int m_nNoOfTriangles; // r1
  float v35; // s22
  float v36; // s24
  int v37; // r9
  int v38; // r8
  float *p_x; // r0
  float v40; // s4
  RwReal v41; // s0
  float v42; // s26
  float v43; // s2
  float *v44; // r0
  bool v45; // cc
  float *v46; // r0
  float v47; // s4
  RwReal v48; // s0
  float v49; // s28
  float v50; // s2
  float *v51; // r0
  float *v52; // r0
  float v53; // s4
  RwReal v54; // s0
  float v55; // s2
  float *v56; // r0
  CColTrianglePlane *m_pTrianglePlaneArray; // r0
  int v58; // r4
  int v59; // r5
  int v60; // r6
  CColSphere *m_pSphereArray; // r0
  int v62; // r5
  int v63; // r4
  float *v64; // r0
  float v65; // s4
  RwReal v66; // s0
  float v67; // s2
  float v68; // s4
  float *v69; // r0
  float v70; // s0
  float v71; // s2
  float v72; // s0
  int m_nSpecialColModel; // [sp+8h] [bp-C0h]
  CColModel *v74; // [sp+Ch] [bp-BCh]
  CVector v; // [sp+10h] [bp-B8h] BYREF
  CVector v76; // [sp+1Ch] [bp-ACh] BYREF
  CMatrix m; // [sp+28h] [bp-A0h] BYREF

  m_nModelIndex = (CPad *)this->m_nModelIndex;
  v8 = m_nModelIndex == (CPad *)&elf_hash_bucket[68];
  if ( (int)m_nModelIndex < 524 )
  {
    v9 = m_nModelIndex == (CPad *)((char *)&elf_hash_bucket[38] + 2);
    if ( m_nModelIndex != (CPad *)((char *)&elf_hash_bucket[38] + 2) )
      v9 = m_nModelIndex == (CPad *)((char *)&elf_hash_bucket[47] + 3);
    if ( !v9 && m_nModelIndex != (CPad *)((char *)&elf_hash_bucket[58] + 2) )
      goto LABEL_12;
LABEL_11:
    this->m_nOldSuspensionHydraulics = this->m_nSuspensionHydraulics;
    goto LABEL_12;
  }
  if ( m_nModelIndex != (CPad *)&elf_hash_bucket[68] )
    v8 = m_nModelIndex == (CPad *)&elf_hash_bucket[85];
  if ( v8 || m_nModelIndex == (CPad *)((char *)&elf_hash_bucket[69] + 2) )
    goto LABEL_11;
LABEL_12:
  x = fScriptControl;
  if ( *(_BYTE *)&this->m_info < 8u )
  {
    pDriver = this->pDriver;
    if ( !pDriver )
      goto LABEL_57;
    LOBYTE(v12) = 0;
    if ( !CPed::IsPlayer(pDriver) || CGameLogic::GameState )
      return (char)v12;
    m_nModelIndex = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
    v13 = (unsigned __int16)this->m_nModelIndex;
    v12 = m_nModelIndex;
    goto LABEL_28;
  }
  LOBYTE(v12) = 0;
  if ( fScriptControl < 0.0 || this->VehicleCreatedBy != 2 )
    return (char)v12;
  v13 = (unsigned __int16)m_nModelIndex;
  v12 = 0;
  if ( (int)m_nModelIndex >= 524 )
  {
    if ( ((unsigned int)&m_nModelIndex[-2].PCTempKeyState.m_bChatIndicated > 0x14
       || ((1 << ((_BYTE)m_nModelIndex - 12)) & 0x100041) == 0)
      && m_nModelIndex != (CPad *)&elf_hash_bucket[85] )
    {
      return (char)v12;
    }
    goto LABEL_28;
  }
  v14 = m_nModelIndex == (CPad *)((char *)&elf_hash_bucket[38] + 2);
  if ( m_nModelIndex != (CPad *)((char *)&elf_hash_bucket[38] + 2) )
    v14 = m_nModelIndex == (CPad *)((char *)&elf_hash_bucket[47] + 3);
  if ( v14 || m_nModelIndex == (CPad *)((char *)&elf_hash_bucket[58] + 2) )
  {
LABEL_28:
    v15 = v13 == 544;
    if ( v13 != 544 )
    {
      m_nModelIndex = (CPad *)(__int16)v13;
      v15 = (__int16)v13 == 524;
    }
    if ( v15 )
    {
      this->m_nOldSuspensionHydraulics = this->m_nSuspensionHydraulics;
      if ( x >= 0.0 )
      {
        v23 = (unsigned int)(float)((float)DEFAULT_COLLISION_EXTENDLIMIT * x);
      }
      else
      {
        if ( !v12 )
          goto LABEL_57;
        if ( CPad::GetCarGunUpDown(v12, 0, 0, 2500.0, 0) > -11 )
        {
          if ( !this->m_nSuspensionHydraulics )
            goto LABEL_57;
          v3.n64_u32[0] = 0;
          m_nSuspensionHydraulics = this->m_nSuspensionHydraulics;
          v2.n64_f32[0] = (float)(m_nSuspensionHydraulics
                                - (int)(float)((float)(CTimer::ms_fTimeStep
                                                     * (float)((float)(CPad::GetCarGunUpDown(v12, 0, 0, 2500.0, 0) + 100)
                                                             * 10.0))
                                             * 0.0078125));
          v17 = vmax_f32(v2, v3).n64_u32[0];
        }
        else
        {
          v16 = this->m_nSuspensionHydraulics;
          v3.n64_f32[0] = (float)DEFAULT_COLLISION_EXTENDLIMIT;
          v2.n64_f32[0] = (float)(v16
                                - (int)(float)((float)(CTimer::ms_fTimeStep
                                                     * (float)((float)(2 * CPad::GetCarGunUpDown(v12, 0, 0, 2500.0, 0))
                                                             * 10.0))
                                             * 0.0078125));
          v17 = vmin_f32(v3, v2).n64_u32[0];
        }
        v23 = (unsigned int)*(float *)&v17;
      }
      LOBYTE(v12) = 0;
      this->m_nSuspensionHydraulics = v23;
      return (char)v12;
    }
    m_pColModel = CModelInfo::ms_modelInfoPtrs[(_DWORD)m_nModelIndex]->m_pColModel;
    m_pColData = m_pColModel->m_pColData;
    if ( CVehicle::GetSpecialColModel(this) )
    {
      v74 = m_pColModel;
      m_nSpecialColModel = this->m_nSpecialColModel;
      v21 = CVehicle::m_aSpecialColModel[this->m_nSpecialColModel].m_pColData;
      if ( v12 )
        CarGunUpDown = (float)CPad::GetCarGunUpDown(v12, 1, this, (float)DEFAULT_COLLISION_EXTENDLIMIT, 0);
      else
        CarGunUpDown = 0.0;
      if ( x >= 0.0 )
      {
        p_m_nSuspensionHydraulics = &this->m_nSuspensionHydraulics;
        this->m_nOldSuspensionHydraulics = this->m_nSuspensionHydraulics;
        v29 = (unsigned __int16)this->m_nModelIndex;
        v30 = (unsigned int)(float)((float)DEFAULT_COLLISION_EXTENDLIMIT * x);
        goto LABEL_60;
      }
      v25 = this->m_nSuspensionHydraulics;
      this->m_nOldSuspensionHydraulics = v25;
      if ( v12 )
      {
        LOBYTE(v12) = 0;
        v26 = 10.0;
        if ( fabsf(CarGunUpDown) <= 10.0 )
          return (char)v12;
        v27 = 20.0;
        p_m_nSuspensionHydraulics = &this->m_nSuspensionHydraulics;
        if ( CarGunUpDown > 0.0 )
          v27 = 10.0;
        v29 = (unsigned __int16)this->m_nModelIndex;
        if ( v29 == 530 )
          v26 = v27;
        v30 = v25 + (int)(float)((float)(CTimer::ms_fTimeStep * (float)(CarGunUpDown * v26)) * 0.0078125);
        if ( v30 <= 0 )
          v30 = 0;
        if ( v30 >= DEFAULT_COLLISION_EXTENDLIMIT )
          LOWORD(v30) = DEFAULT_COLLISION_EXTENDLIMIT;
LABEL_60:
        *p_m_nSuspensionHydraulics = v30;
        m.m_pRwMat = 0;
        m.m_owner = 0;
        if ( v29 >= 486 )
        {
          if ( v29 == 592 )
          {
            if ( this->m_aCarNodes[24] )
            {
              CMatrix::SetRotateX(&m, CPlane::ANDROM_COL_ANGLE_MULT * (float)(unsigned __int16)v30);
              v33 = this->m_aCarNodes[24];
              goto LABEL_78;
            }
          }
          else
          {
            if ( v29 == 530 )
            {
              if ( this->m_aCarNodes[20] )
              {
                CMatrix::SetTranslate(&m, 0.0, 0.0, (float)(unsigned __int16)v30 * 0.0006);
                x = 0.0;
                y = 0.0;
                z = 0.0;
              }
              goto LABEL_79;
            }
            if ( v29 == 486 && this->m_aCarNodes[20] )
            {
              v30 = (unsigned __int16)v30;
              v32 = 0.0002;
LABEL_70:
              CMatrix::SetRotateX(&m, (float)(unsigned int)v30 * v32);
              v33 = this->m_aCarNodes[20];
LABEL_78:
              x = v33->modelling.pos.x;
              y = v33->modelling.pos.y;
              z = v33->modelling.pos.z;
            }
          }
LABEL_79:
          m_nNoOfTriangles = v21->m_nNoOfTriangles;
          if ( m_nNoOfTriangles < 1 )
          {
            v36 = 1000.0;
            v35 = -1000.0;
          }
          else
          {
            v35 = -1000.0;
            v36 = 1000.0;
            v37 = 0;
            v38 = 0;
            do
            {
              if ( v21->m_pTriangleArray[v37].m_nSurfaceType == 65 )
              {
                p_x = &m_pColData->m_pTriCompressedVectorArray[m_pColData->m_pTriangleArray[v37].m_nIndex1].x;
                v40 = p_x[2];
                v41 = *p_x - x;
                v.y = p_x[1] - y;
                v.x = v41;
                v.z = v40 - z;
                operator*(&v76, &m, &v);
                v42 = z + v76.z;
                v43 = y + v76.y;
                v44 = &v21->m_pTriCompressedVectorArray[v21->m_pTriangleArray[v37].m_nIndex1].x;
                v45 = (float)(z + v76.z) <= v35;
                *v44 = x + v76.x;
                v44[1] = v43;
                v44[2] = v42;
                if ( v45 )
                {
                  if ( v42 >= v36 )
                    v42 = v36;
                }
                else
                {
                  v35 = v42;
                  v42 = v36;
                }
                v46 = &m_pColData->m_pTriCompressedVectorArray[m_pColData->m_pTriangleArray[v37].m_nIndex2].x;
                v47 = v46[2];
                v48 = *v46 - x;
                v.y = v46[1] - y;
                v.x = v48;
                v.z = v47 - z;
                operator*(&v76, &m, &v);
                v49 = z + v76.z;
                v50 = y + v76.y;
                v45 = (float)(z + v76.z) <= v35;
                v51 = &v21->m_pTriCompressedVectorArray[v21->m_pTriangleArray[v37].m_nIndex2].x;
                *v51 = x + v76.x;
                v51[1] = v50;
                v51[2] = v49;
                if ( v45 )
                {
                  if ( v49 >= v42 )
                    v49 = v42;
                }
                else
                {
                  v35 = v49;
                  v49 = v42;
                }
                v52 = &m_pColData->m_pTriCompressedVectorArray[m_pColData->m_pTriangleArray[v37].m_nIndex3].x;
                v53 = v52[2];
                v54 = *v52 - x;
                v.y = v52[1] - y;
                v.x = v54;
                v.z = v53 - z;
                operator*(&v76, &m, &v);
                v36 = z + v76.z;
                v55 = y + v76.y;
                v45 = (float)(z + v76.z) <= v35;
                v56 = &v21->m_pTriCompressedVectorArray[v21->m_pTriangleArray[v37].m_nIndex3].x;
                *v56 = x + v76.x;
                v56[1] = v55;
                v56[2] = v36;
                if ( v45 )
                {
                  if ( v36 >= v49 )
                    v36 = v49;
                }
                else
                {
                  v35 = v36;
                  v36 = v49;
                }
              }
              ++v38;
              ++v37;
            }
            while ( v38 < v21->m_nNoOfTriangles );
            LOWORD(m_nNoOfTriangles) = v21->m_nNoOfTriangles;
          }
          m_pTrianglePlaneArray = v21->m_pTrianglePlaneArray;
          if ( m_pTrianglePlaneArray )
          {
            if ( (__int16)m_nNoOfTriangles >= 1 )
            {
              CColTrianglePlane::Set(m_pTrianglePlaneArray, v21->m_pTriCompressedVectorArray, v21->m_pTriangleArray);
              if ( v21->m_nNoOfTriangles >= 2 )
              {
                v58 = 1;
                v59 = 1;
                v60 = 1;
                do
                {
                  CColTrianglePlane::Set(
                    &v21->m_pTrianglePlaneArray[v60],
                    v21->m_pTriCompressedVectorArray,
                    &v21->m_pTriangleArray[v59]);
                  ++v58;
                  ++v60;
                  ++v59;
                }
                while ( v58 < v21->m_nNoOfTriangles );
              }
            }
          }
          if ( v21->m_nNoOfSpheres >= 1 )
          {
            m_pSphereArray = v21->m_pSphereArray;
            v62 = 0;
            v63 = 8;
            do
            {
              if ( *((_BYTE *)&m_pSphereArray->m_vecCentre.z + v63) == 65 )
              {
                v64 = (float *)((char *)&m_pColData->m_pSphereArray->m_vecCentre.x + v63);
                v65 = *v64;
                v66 = *(v64 - 2) - x;
                v.y = *(v64 - 1) - y;
                v.x = v66;
                v.z = v65 - z;
                operator*(&v76, &m, &v);
                v67 = y + v76.y;
                v68 = z + v76.z;
                v69 = (float *)((char *)&v21->m_pSphereArray->m_vecCentre.x + v63);
                *(v69 - 2) = x + v76.x;
                *(v69 - 1) = v67;
                *v69 = v68;
                m_pSphereArray = v21->m_pSphereArray;
                v70 = *(float *)((char *)&m_pSphereArray->m_vecCentre.x + v63);
                v71 = *(float *)((char *)&m_pSphereArray->m_vecCentre.y + v63);
                if ( (float)(v70 + v71) <= v35 )
                {
                  v72 = v70 - v71;
                  if ( v72 < v36 )
                    v36 = v72;
                }
                else
                {
                  v35 = v70 + v71;
                }
              }
              ++v62;
              v63 += 20;
            }
            while ( v62 < v21->m_nNoOfSpheres );
          }
          if ( v35 > v74->m_boxBound.m_vecMax.z )
            CVehicle::m_aSpecialColModel[m_nSpecialColModel].m_boxBound.m_vecMax.z = v35;
          if ( v36 < v74->m_boxBound.m_vecMin.z )
            CVehicle::m_aSpecialColModel[m_nSpecialColModel].m_boxBound.m_vecMin.z = v36;
          CMatrix::~CMatrix(&m);
          LOBYTE(v12) = 1;
          return (char)v12;
        }
        if ( v29 == 406 )
        {
          if ( this->m_vehicleType != 1 || !this->m_aCarNodes[22] )
            goto LABEL_79;
          CMatrix::SetRotateX(&m, CMonsterTruck::DUMPER_COL_ANGLEMULT * (float)(unsigned __int16)v30);
          v33 = this->m_aCarNodes[22];
          goto LABEL_78;
        }
        if ( v29 != 443 || !this->m_aCarNodes[20] )
          goto LABEL_79;
        v30 = (unsigned __int16)v30;
        v32 = -0.0001;
        goto LABEL_70;
      }
    }
LABEL_57:
    LOBYTE(v12) = 0;
  }
  return (char)v12;
}
// 54FE6E: variable 'v3' is possibly undefined
// 54FE6E: variable 'v2' is possibly undefined
// 5501CC: variable 'y' is possibly undefined
// 5501D4: variable 'z' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 676F9C: using guessed type float *CMonsterTruck::DUMPER_COL_ANGLEMULT;
// 679728: using guessed type float *CPlane::ANDROM_COL_ANGLE_MULT;

//----- (00550508) --------------------------------------------------------
CVector *__fastcall CAutomobile::AddMovingCollisionSpeed(CVector *retstr, CAutomobile *this, CVector *vecOffset)
{
  CVector *result; // r0
  unsigned int m_info; // r1
  bool v8; // zf
  bool v9; // zf
  unsigned int m_nOldSuspensionHydraulics; // r1
  int m_nModelIndex; // r3
  int v12; // r2
  RwFrame_0 *v13; // r6
  __int64 v14; // d16
  float v15; // s0
  __int64 v16; // d16
  RwReal z; // r3
  RwFrame_0 *v18; // r3
  RwFrame_0 *v19; // r2
  float v20; // s4
  float v21; // s0
  RwReal v22; // s2
  RwReal v23; // s4
  RwReal v24; // s0
  __int64 v25; // d16
  RwReal v26; // s2
  RwReal v27; // s4
  __int64 v28; // d16
  CVector v29; // [sp+0h] [bp-48h] BYREF
  CVector v2; // [sp+Ch] [bp-3Ch] BYREF
  CVector v31; // [sp+18h] [bp-30h] BYREF
  CVector v; // [sp+28h] [bp-20h] BYREF

  result = 0;
  retstr->x = 0.0;
  retstr->y = 0.0;
  retstr->z = 0.0;
  m_info = (unsigned __int8)this->m_info;
  v8 = m_info >> 3 == 0;
  if ( m_info >> 3 )
    v8 = m_info >> 3 == 9;
  if ( v8 )
    goto LABEL_29;
  if ( this->VehicleCreatedBy == 2 )
  {
    v9 = this->m_nSuspensionHydraulics == 0;
    if ( !this->m_nSuspensionHydraulics )
      v9 = this->m_nOldSuspensionHydraulics == 0;
    if ( !v9 )
    {
LABEL_29:
      memset(&v, 0, sizeof(v));
      result = (CVector *)this->m_nSuspensionHydraulics;
      m_nOldSuspensionHydraulics = this->m_nOldSuspensionHydraulics;
      if ( (unsigned int)&result[8].y - m_nOldSuspensionHydraulics <= 0xC8 )
      {
        m_nModelIndex = this->m_nModelIndex;
        v12 = (unsigned __int16)m_nModelIndex;
        if ( (unsigned __int16)m_nModelIndex == 406 )
        {
          v13 = this->m_aCarNodes[22];
          if ( v13 )
          {
            v14 = *(_QWORD *)&v13->modelling.pos.x;
            v.z = v13->modelling.pos.z;
            v15 = CMonsterTruck::DUMPER_COL_ANGLEMULT;
LABEL_21:
            *(_QWORD *)&v.x = v14;
LABEL_25:
            if ( v15 != 0.0 )
            {
              retstr->x = (float)((float)(unsigned int)result - (float)m_nOldSuspensionHydraulics)
                        * (float)(v15 / CTimer::ms_fTimeStep);
              Multiply3x3(&v31, this->m_pMat, retstr);
              v25 = *(_QWORD *)&v31.x;
              retstr->z = v31.z;
              *(_QWORD *)&retstr->x = v25;
              Multiply3x3(&v29, this->m_pMat, &v);
              v26 = vecOffset->y - v29.y;
              v27 = vecOffset->z - v29.z;
              v2.x = vecOffset->x - v29.x;
              v2.y = v26;
              v2.z = v27;
              CrossProduct(&v31, retstr, &v2);
              v28 = *(_QWORD *)&v31.x;
              result = (CVector *)LODWORD(v31.z);
              retstr->z = v31.z;
              *(_QWORD *)&retstr->x = v28;
            }
            return result;
          }
        }
        if ( m_nModelIndex == 486 )
        {
          v18 = this->m_aCarNodes[20];
          if ( v18 )
          {
            v16 = *(_QWORD *)&v18->modelling.pos.x;
            z = v18->modelling.pos.z;
            v15 = 0.0002;
            goto LABEL_17;
          }
        }
        else if ( m_nModelIndex == 443 )
        {
          v15 = -0.0001;
          v16 = *(_QWORD *)&PACKER_COL_PIVOT.x;
          z = PACKER_COL_PIVOT.z;
LABEL_17:
          v.z = z;
          *(_QWORD *)&v.x = v16;
          goto LABEL_23;
        }
        if ( v12 == 592 )
        {
          v19 = this->m_aCarNodes[24];
          if ( !v19 )
            return result;
          v14 = *(_QWORD *)&v19->modelling.pos.x;
          v.z = v19->modelling.pos.z;
          v15 = CPlane::ANDROM_COL_ANGLE_MULT;
          goto LABEL_21;
        }
        v15 = 0.0;
LABEL_23:
        if ( v12 == 530 )
        {
          v20 = (float)(unsigned int)result;
          result = (CVector *)this->m_pMat;
          v21 = (float)(v20 - (float)m_nOldSuspensionHydraulics) * (float)(0.0012 / CTimer::ms_fTimeStep);
          v22 = result[2].z * v21;
          v23 = v21 * result[3].x;
          v24 = v21 * result[3].y;
          retstr->x = v22;
          retstr->y = v23;
          retstr->z = v24;
          return result;
        }
        goto LABEL_25;
      }
    }
  }
  return result;
}
// 676F9C: using guessed type float *CMonsterTruck::DUMPER_COL_ANGLEMULT;
// 679728: using guessed type float *CPlane::ANDROM_COL_ANGLE_MULT;

//----- (00550710) --------------------------------------------------------
float __fastcall CAutomobile::GetMovingCollisionOffset(CAutomobile *this)
{
  unsigned int m_nSuspensionHydraulics; // r1
  float v2; // s0
  int m_nModelIndex; // r3
  float **v4; // r0
  unsigned int v6; // s0
  float v7; // s2

  m_nSuspensionHydraulics = this->m_nSuspensionHydraulics;
  v2 = 0.0;
  if ( !this->m_nSuspensionHydraulics )
    return v2;
  m_nModelIndex = this->m_nModelIndex;
  if ( (unsigned __int16)m_nModelIndex == 406 && this->m_aCarNodes[22] )
  {
    v4 = &CMonsterTruck::DUMPER_COL_ANGLEMULT;
    return **v4 * (float)m_nSuspensionHydraulics;
  }
  if ( m_nModelIndex == 486 )
  {
    if ( this->m_aCarNodes[20] )
    {
      v6 = this->m_nSuspensionHydraulics;
      v7 = 0.0002;
      return (float)v6 * v7;
    }
  }
  else if ( m_nModelIndex == 443 )
  {
    v6 = this->m_nSuspensionHydraulics;
    v7 = -0.0001;
    return (float)v6 * v7;
  }
  if ( (unsigned __int16)m_nModelIndex == 530 )
  {
    v6 = this->m_nSuspensionHydraulics;
    v7 = 0.0006;
    return (float)v6 * v7;
  }
  if ( (unsigned __int16)m_nModelIndex == 592 && this->m_aCarNodes[24] )
  {
    v4 = &CPlane::ANDROM_COL_ANGLE_MULT;
    return **v4 * (float)m_nSuspensionHydraulics;
  }
  return v2;
}
// 676F9C: using guessed type float *CMonsterTruck::DUMPER_COL_ANGLEMULT;
// 679728: using guessed type float *CPlane::ANDROM_COL_ANGLE_MULT;

//----- (005507BC) --------------------------------------------------------
void __fastcall CAutomobile::GetComponentWorldPosition(CAutomobile *this, int32 component, CVector *posn)
{
  RwFrame_0 *v4; // r0
  RwMatrix *LTM; // r0
  __int64 v6; // d16

  v4 = this->m_aCarNodes[component];
  if ( v4 )
  {
    LTM = RwFrameGetLTM(v4);
    v6 = *(_QWORD *)&LTM->pos.x;
    posn->z = LTM->pos.z;
    *(_QWORD *)&posn->x = v6;
  }
}

//----- (005507E2) --------------------------------------------------------
bool __fastcall CAutomobile::IsComponentPresent(const CAutomobile *this, int32 component)
{
  return this->m_aCarNodes[component] != 0;
}

//----- (005507F4) --------------------------------------------------------
void __fastcall CAutomobile::OpenDoor(
        CAutomobile *this,
        CPed *pPed,
        int32 index,
        eDoors DoorID,
        float timeRatio,
        int bPlaySoundSample)
{
  int (***v7)(void); // r6
  int (**v10)(void); // r0
  float tx; // s16
  float ty; // s18
  CPlaceable *v13; // r9
  float tz; // s20
  RwFrame_0 **v15; // r6
  int v16; // r0
  CEntity **v17; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  double v20; // d16
  CDamageManager *p_Damage; // r0
  eDoors v22; // r1
  uint32 v23; // r2
  TouchSense *v24; // r0
  int v25; // r0
  CMatrix *v26; // r0
  CSimpleTransform *p_m_transform; // r2
  double v28; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventEditableResponse v30; // [sp+8h] [bp-C0h] BYREF
  CEntity *v31; // [sp+18h] [bp-B0h]
  int v32; // [sp+1Ch] [bp-ACh]
  uint32 v33; // [sp+20h] [bp-A8h]
  double v34; // [sp+24h] [bp-A4h]
  RwReal z; // [sp+2Ch] [bp-9Ch]
  float v36; // [sp+30h] [bp-98h]
  float v37; // [sp+34h] [bp-94h]
  float v38; // [sp+38h] [bp-90h]
  CMatrix v39; // [sp+40h] [bp-88h] BYREF

  v7 = &this->_vptr$CPlaceable + index;
  v10 = v7[407];
  if ( v10 )
  {
    CMatrix::CMatrix(&v39, (RwMatrix *)(v10 + 4), 0);
    tx = v39.tx;
    ty = v39.ty;
    v13 = (CAutomobile *)((char *)this + 24 * DoorID);
    tz = v39.tz;
    v36 = 0.0;
    v37 = 0.0;
    v38 = 0.0;
    if ( CDoor::IsClosed((const CDoor *)&v13[61].m_pMat) )
    {
      v15 = (RwFrame_0 **)(v7 + 407);
      RwFrameForAllObjects(*v15, CVehicleModelInfo::ClearAtomicFlagCB, &elf_hash_bucket[193]);
      CDoor::Open((CDoor *)&v13[61].m_pMat, timeRatio);
      if ( v13[62].m_transform.m_translate.y != *(float *)&v13[62]._vptr$CPlaceable )
      {
        RwFrameForAllObjects(*v15, CVehicleModelInfo::SetAtomicFlagCB, &elf_hash_bucket[193]);
        if ( bPlaySoundSample == 1 )
        {
          CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, DoorID + 78, 0.0);
          if ( pPed )
          {
            CEventEditableResponse::CEventEditableResponse(&v30);
            v17 = (CEntity **)(v16 + 16);
            v31 = pPed;
            v32 = 1114636288;
            v33 = -1;
            v34 = 0.0;
            z = 0.0;
            v30._vptr$CEvent = (int (**)(void))&off_66714C;
            CEntity::RegisterReference(pPed, (CEntity **)(v16 + 16));
            if ( v33 == -1 )
            {
              v33 = CTimer::m_snTimeInMilliseconds;
              m_pMat = v31->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &v31->m_transform;
              v20 = *(double *)&p_tx->m_translate.x;
              z = p_tx->m_translate.z;
              v34 = v20;
            }
LABEL_25:
            EventGlobalGroup = GetEventGlobalGroup();
            CEventGroup::Add(EventGlobalGroup, (CEvent *)&v30, 0);
            v30._vptr$CEvent = (int (**)(void))&off_66714C;
            if ( v31 )
              CEntity::CleanUpOldReference(v31, v17);
            CEvent::~CEvent((CEvent *)&v30);
          }
        }
      }
LABEL_28:
      *(&v36 + BYTE2(v13[62].m_transform.m_translate.x)) = v13[62].m_transform.m_translate.y;
      CMatrix::SetRotate(&v39, v36, v37, v38);
      v39.tx = tx + v39.tx;
      v39.ty = ty + v39.ty;
      v39.tz = tz + v39.tz;
      CMatrix::UpdateRW(&v39);
      CMatrix::~CMatrix(&v39);
      return;
    }
    CDoor::Open((CDoor *)&v13[61].m_pMat, timeRatio);
    if ( timeRatio != 0.0 )
      goto LABEL_28;
    if ( CDamageManager::GetDoorStatus(&this->Damage, DoorID) == 1 )
    {
      p_Damage = &this->Damage;
      v22 = DoorID;
      v23 = 0;
    }
    else
    {
      if ( CDamageManager::GetDoorStatus(&this->Damage, DoorID) != 3 )
        goto LABEL_17;
      p_Damage = &this->Damage;
      v22 = DoorID;
      v23 = 2;
    }
    CDamageManager::SetDoorStatus(p_Damage, v22, v23);
LABEL_17:
    if ( bPlaySoundSample != 1 )
      goto LABEL_28;
    CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, DoorID + 84, 0.0);
    if ( FindPlayerVehicle(-1, 0) == this )
    {
      TouchSense::instance();
      TouchSense::playBuiltinEffect(v24, 2, 14, 115, 20);
    }
    if ( !pPed )
      goto LABEL_28;
    CEventEditableResponse::CEventEditableResponse(&v30);
    v31 = pPed;
    v32 = 1123024896;
    v17 = (CEntity **)(v25 + 16);
    v33 = -1;
    v34 = 0.0;
    z = 0.0;
    v30._vptr$CEvent = (int (**)(void))&off_66714C;
    CEntity::RegisterReference(pPed, (CEntity **)(v25 + 16));
    if ( v33 == -1 )
    {
      v33 = CTimer::m_snTimeInMilliseconds;
      v26 = v31->m_pMat;
      p_m_transform = (CSimpleTransform *)&v26->tx;
      if ( !v26 )
        p_m_transform = &v31->m_transform;
      v28 = *(double *)&p_m_transform->m_translate.x;
      z = p_m_transform->m_translate.z;
      v34 = v28;
    }
    goto LABEL_25;
  }
}
// 5508CA: variable 'v16' is possibly undefined
// 5509A2: variable 'v24' is possibly undefined
// 5509C6: variable 'v25' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 66714C: using guessed type void *off_66714C;

//----- (00550AB0) --------------------------------------------------------
float __fastcall CAutomobile::GetDooorAngleOpenRatio(const CAutomobile *this, const eDoors DoorId)
{
  return sub_19BFCC(&this->Door[DoorId]);
}

//----- (00550AC0) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorReady(const CAutomobile *this, eDoors DoorID)
{
  if ( CDoor::IsClosed(&this->Door[DoorID]) )
    return 1;
  else
    return (*((int (__fastcall **)(const CAutomobile *, eDoors))this->_vptr$CPlaceable + 34))(this, DoorID);
}

//----- (00550AF0) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorFullyOpen(const CAutomobile *this, eDoors DoorID)
{
  if ( CDoor::IsFullyOpen(&this->Door[DoorID]) )
    return 1;
  else
    return (*((int (__fastcall **)(const CAutomobile *, eDoors))this->_vptr$CPlaceable + 34))(this, DoorID);
}

//----- (00550B20) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorClosed(const CAutomobile *this, eDoors DoorID)
{
  return sub_18E77C(&this->Door[DoorID]);
}

//----- (00550B30) --------------------------------------------------------
bool __fastcall CAutomobile::IsDoorMissing(const CAutomobile *this, eDoors DoorID)
{
  return (unsigned __int8)CDamageManager::GetDoorStatus(&this->Damage, DoorID) == 4;
}

//----- (00550B48) --------------------------------------------------------
bool __fastcall CAutomobile::IsOpenTopCar(const CAutomobile *this)
{
  int m_nModelIndex; // r1
  bool v2; // zf
  bool v4; // zf

  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  if ( m_nModelIndex == 439 )
  {
    v4 = this->m_comp1 == 0;
    if ( this->m_comp1 )
      v4 = this->m_comp2 == 0;
    if ( !v4 )
      return 1;
  }
  else if ( m_nModelIndex == 480 )
  {
    v2 = this->m_comp1 == 0;
    if ( this->m_comp1 )
      v2 = this->m_comp2 == 0;
    if ( !v2 )
      return 1;
  }
  return 0;
}

//----- (00550B84) --------------------------------------------------------
void __fastcall CAutomobile::dmgDrawCarCollidingParticles(
        CAutomobile *this,
        const CVector *DamagePosition,
        float fImpulse,
        eWeaponType weaponType)
{
  TouchSense *v8; // r0
  bool v9; // zf
  __int64 v10; // d16
  float v11; // r0
  __int64 v12; // d16
  FxPrtMult_c *v13; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  float z; // s4
  float x; // s6
  float v18; // s10
  float v19; // s0
  int v20; // r9
  FxPrtMult_c *v21; // r11
  int i; // r6
  RwRGBA_0 v23; // r0
  float m_lightingFromCollision; // s6
  int v25; // [sp+24h] [bp-7Ch]
  RwRGBA_0 col; // [sp+28h] [bp-78h] BYREF
  RwV3d_0 v27; // [sp+2Ch] [bp-74h] BYREF
  FxPrtMult_c v28; // [sp+38h] [bp-68h] BYREF
  CVector pos; // [sp+58h] [bp-48h] BYREF

  if ( CEntity::GetIsOnScreen(this) )
  {
    TouchSense::instance();
    if ( fImpulse <= 45.0 )
      TouchSense::playBuiltinEffect(v8, 2, 97, 115, 20);
    else
      TouchSense::playBuiltinEffect(v8, 1, 94, 115, 20);
    v9 = weaponType == WEAPONTYPE_UNARMED;
    v25 = (int)fImpulse;
    if ( weaponType )
      v9 = weaponType == WEAPONTYPE_FLOWERS;
    if ( !v9 )
    {
      v10 = *(_QWORD *)&this->m_vecMoveSpeed.x;
      v28.m_blue = this->m_vecMoveSpeed.z;
      *(_QWORD *)&v28.m_red = v10;
      v11 = CVector::NormaliseAndMag((CVector *)&v28);
      v12 = *(_QWORD *)&DamagePosition->x;
      pos.z = DamagePosition->z;
      *(_QWORD *)&pos.x = v12;
      Fx_c::AddSparks(
        &g_fx,
        &pos,
        (CVector *)&v28,
        v11 * -10.0,
        ((char)v25 / 10 + 4) & 0x3F,
        this->m_vecMoveSpeed,
        1,
        0.3,
        1.0);
    }
    FxPrtMult_c::FxPrtMult_c(&v28, 0.4, 0.4, 0.4, 0.6, 0.4, 1.0, 0.1);
    memset(&pos, 0, sizeof(pos));
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    z = DamagePosition->z;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    x = p_tx->m_translate.x;
    v18 = p_tx->m_translate.z;
    v19 = DamagePosition->x - p_tx->m_translate.x;
    v27.y = (float)((float)(DamagePosition->y - p_tx->m_translate.y) * 0.7) + p_tx->m_translate.y;
    v27.x = (float)(v19 * 0.7) + x;
    v27.z = (float)((float)(z - v18) * 0.7) + v18;
    v20 = (int)(float)(sqrtf(
                         (float)((float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x)
                                       * (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x))
                               + (float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y)
                                       * (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y)))
                       + (float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z)
                               * (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z)))
                     * 4.0);
    if ( v20 <= 1 )
      v20 = 1;
    v21 = v13;
    for ( i = 0; i < v20; ++i )
      FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &v27, &pos, 0.0, v21, -1.0, 1.2, 0.6, 0);
    if ( (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                       + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
               + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.0625 )
    {
      col = CVehicleModelInfo::ms_vehicleColourTable[this->m_colour1];
      v23 = col;
      m_lightingFromCollision = this->m_lightingFromCollision;
      col._anon_0._anon_0.green = (unsigned int)(float)(m_lightingFromCollision * (float)col._anon_0._anon_0.green);
      col._anon_0._anon_0.red = (unsigned int)(float)(m_lightingFromCollision * (float)v23._anon_0._anon_0.red);
      col._anon_0._anon_0.blue = (unsigned int)(float)(m_lightingFromCollision * (float)v23._anon_0._anon_0.blue);
      Fx_c::AddDebris(&g_fx, (CVector *)&v27, &col, 0.06, v25 / 100 + 1);
    }
  }
}
// 550D4E: conditional instruction was optimized away because r9.4>=1
// 550BC8: variable 'v8' is possibly undefined
// 550D5A: variable 'v13' is possibly undefined

//----- (00550E84) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CAutomobile::ProcessCarOnFireAndExplode(CAutomobile *this, bool8 forceExplode)
{
  int v3; // r6
  float *p_m_nHealth; // r5
  char EngineStatus; // r8
  int v6; // r9
  int32 m_vehicleType; // r0
  int m_statusWhenEngineBlown; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  FxSystem_c *v10; // r0
  float v11; // s0
  char v12; // r0
  uint32 m_hashKey; // r1
  __int64 v14; // d16
  RwObject_0 *m_pRwObject; // r1
  int v16; // r0
  RwMatrix *v17; // r3
  FxSystem_c *m_fxSysEngFire; // r0
  int m_nModelIndex; // r1
  bool v20; // zf
  CEventGlobalGroup *EventGlobalGroup; // r0
  FxSystem_c *v22; // r0
  float v23; // s2
  float v24; // s0
  int v25; // r6
  float *p_m_BlowUpTimer; // r11
  float v27; // s2
  float v28; // s0
  int *v29; // r1
  float v30; // s2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v33; // d16
  float v34; // s0
  float v35; // s20
  float v36; // s22
  float v37; // s0
  int v38; // r0
  bool v39; // zf
  CMatrix *v40; // r0
  float v41; // r12
  CSimpleTransform *p_m_transform; // r2
  __int64 v43; // kr00_8 OVERLAPPED
  __int64 alpha; // [sp+0h] [bp-90h]
  RwV3d_0 vel; // [sp+1Ch] [bp-74h] BYREF
  RwV3d_0 offsetPos; // [sp+28h] [bp-68h] BYREF
  FxPrtMult_c v47[3]; // [sp+34h] [bp-5Ch] BYREF

  v3 = forceExplode;
  p_m_nHealth = &this->m_nHealth;
  EngineStatus = CDamageManager::GetEngineStatus(&this->Damage);
  if ( *p_m_nHealth < 250.0
    && (*(_BYTE *)&this->m_info & 0xF8) != 40
    && (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) == 0 )
  {
    v6 = 0;
    m_vehicleType = this->m_vehicleType;
    if ( !this->m_fxSysEngFire )
    {
      if ( m_vehicleType == 4 )
        goto LABEL_9;
      if ( m_vehicleType != 3 )
        v6 = 1;
    }
    if ( (unsigned int)(m_vehicleType - 3) > 1 )
    {
      v11 = this->m_BlowUpTimer + (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
      this->m_BlowUpTimer = v11;
      if ( v11 > 5000.0 )
LABEL_30:
        (*((void (__fastcall **)(CAutomobile *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(
          this,
          this->pEntityThatSetUsOnFire,
          0);
LABEL_31:
      if ( !v6 )
        goto LABEL_49;
      goto LABEL_32;
    }
LABEL_9:
    m_statusWhenEngineBlown = this->m_statusWhenEngineBlown;
    if ( !this->m_statusWhenEngineBlown )
    {
      m_nPhysicalFlags = this->m_nPhysicalFlags;
      if ( (*(_WORD *)&m_nPhysicalFlags & 0x2000) == 0
        && ((*(_WORD *)&m_nPhysicalFlags & 0x100) != 0
         || this->m_aWheelRatios[0] < 1.0
         || this->m_aWheelRatios[1] < 1.0
         || this->m_aWheelRatios[2] < 1.0
         || this->m_aWheelRatios[3] < 1.0
         || this->m_vecMoveSpeed.x == 0.0 && this->m_vecMoveSpeed.y == 0.0) )
      {
        m_statusWhenEngineBlown = 1;
      }
      else
      {
        m_statusWhenEngineBlown = 2;
      }
      this->m_statusWhenEngineBlown = m_statusWhenEngineBlown;
    }
    if ( v3 )
      goto LABEL_30;
    m_nModelIndex = this->m_nModelIndex;
    if ( (unsigned int)(m_nModelIndex - 441) <= 0x18 && ((1 << (m_nModelIndex + 71)) & 0x1800001) != 0 )
      goto LABEL_45;
    v20 = m_nModelIndex == 564;
    if ( m_nModelIndex != 564 )
      v20 = m_nModelIndex == 501;
    if ( v20 )
LABEL_45:
      v25 = 1;
    else
      v25 = 0;
    p_m_BlowUpTimer = &this->m_BlowUpTimer;
    v27 = (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * 0.2;
    if ( m_statusWhenEngineBlown == 1 )
      v27 = (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    if ( v25 )
      v27 = (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    v28 = *p_m_BlowUpTimer + v27;
    *p_m_BlowUpTimer = v28;
    if ( v28 <= 5000.0 )
    {
      FxPrtMult_c::FxPrtMult_c(v47, 0.0, 0.0, 0.0, 0.4, 1.0, 1.0, 0.3);
      if ( v25 == 1 )
      {
        v29 = dword_551424;
        v30 = 0.15;
        if ( (*(_BYTE *)&this->m_info & 0xF8) == 64 )
        {
          v30 = 0.5;
          v29 = &dword_551424[1];
        }
        LODWORD(v47[0].m_size) = *v29;
        v47[0].m_life = v47[0].m_size;
        v47[0].m_alpha = v30;
      }
      if ( !((unsigned __int8)CTimer::m_FrameCounter << 31) )
      {
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        v33 = *(_QWORD *)&p_tx->m_translate.x;
        offsetPos.z = p_tx->m_translate.z;
        *(_QWORD *)&offsetPos.x = v33;
        v34 = (float)rand() * 4.6566e-10;
        if ( v25 == 1 )
        {
          vel.x = v34 + -0.5;
          vel.y = (float)((float)rand() * 4.6566e-10) + -0.5;
          v35 = -0.7;
          v36 = 1.4;
          v37 = (float)((float)rand() * 4.6566e-10) * 0.4;
        }
        else
        {
          vel.x = (float)(v34 * 3.0) + -1.5;
          vel.y = (float)((float)((float)rand() * 4.6566e-10) * 3.0) + -1.5;
          v35 = -2.0;
          v36 = 4.0;
          v37 = (float)rand() * 4.6566e-10;
        }
        vel.z = v37 + 0.0;
        offsetPos.x = offsetPos.x + (float)(v35 + (float)(v36 * (float)((float)rand() * 4.6566e-10)));
        offsetPos.y = offsetPos.y + (float)(v35 + (float)(v36 * (float)((float)rand() * 4.6566e-10)));
        FxSystem_c::AddParticle(g_fx.m_fxSysSmokeHuge, &offsetPos, &vel, 0.0, v47, -1.0, 1.2, 0.6, 0);
      }
    }
    else
    {
      (*((void (__fastcall **)(CAutomobile *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(
        this,
        this->pEntityThatSetUsOnFire,
        0);
    }
    if ( ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
    {
      if ( !this->m_fxSysEngFire && *p_m_BlowUpTimer > 2500.0 )
      {
        v12 = 2;
LABEL_33:
        m_hashKey = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey;
        v14 = *(_QWORD *)(m_hashKey + 84);
        offsetPos.z = *(RwReal *)(m_hashKey + 92);
        *(_QWORD *)&offsetPos.x = v14;
        m_pRwObject = this->m_pRwObject;
        if ( m_pRwObject )
        {
          v16 = v12 & 3;
          v17 = (RwMatrix *)((char *)m_pRwObject->parent + 16);
          if ( v16 == 2 )
          {
            m_fxSysEngFire = FxManager_c::CreateFxSystem(&g_fxMan, "fire_large", &offsetPos, v17, 0);
LABEL_47:
            this->m_fxSysEngFire = m_fxSysEngFire;
            if ( !m_fxSysEngFire )
              goto LABEL_49;
            goto LABEL_48;
          }
          if ( v16 == 1 )
          {
            m_fxSysEngFire = FxManager_c::CreateFxSystem(&g_fxMan, "fire_car", &offsetPos, v17, 0);
            goto LABEL_47;
          }
        }
        m_fxSysEngFire = this->m_fxSysEngFire;
        if ( !m_fxSysEngFire )
        {
LABEL_49:
          v22 = this->m_fxSysEngFire;
          if ( v22 )
          {
            v23 = this->m_vecMoveSpeed.x * 50.0;
            v24 = this->m_vecMoveSpeed.z * 50.0;
            v47[0].m_green = this->m_vecMoveSpeed.y * 50.0;
            v47[0].m_red = v23;
            v47[0].m_blue = v24;
            FxSystem_c::SetVelAdd(v22, (RwV3d_0 *)v47);
          }
          goto LABEL_21;
        }
LABEL_48:
        FxSystem_c::Play(m_fxSysEngFire);
        CEventVehicleOnFire::CEventVehicleOnFire((CEventVehicleOnFire *)v47, this);
        EventGlobalGroup = GetEventGlobalGroup();
        CEventGroup::Add(EventGlobalGroup, (CEvent *)v47, 0);
        CEventVehicleOnFire::~CEventVehicleOnFire((CEventVehicleOnFire *)v47);
        goto LABEL_49;
      }
    }
    else
    {
      v38 = this->m_nModelIndex;
      if ( (unsigned int)(v38 - 441) > 0x18 || ((1 << (v38 + 71)) & 0x1800001) == 0 )
      {
        v39 = v38 == 501;
        if ( v38 != 501 )
          v39 = v38 == 564;
        if ( !v39 && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 250.0) <= 2 )
        {
          v40 = this->m_pMat;
          LOWORD(v41) = 0;
          p_m_transform = (CSimpleTransform *)&v40->tx;
          if ( !v40 )
            p_m_transform = &this->m_transform;
          v43 = *(_QWORD *)&p_m_transform->m_translate.x;
          HIWORD(v41) = -16512;
          alpha = *(_QWORD *)&p_m_transform->m_translate.y;
          CExplosion::AddExplosion(this, this->pEntityThatSetUsOnFire, EXP_TYPE_ROCKET, *(CVector *)&v43, 0, 1u, v41, 0);
          if ( !v6 )
            goto LABEL_49;
LABEL_32:
          v12 = 1;
          goto LABEL_33;
        }
      }
    }
    goto LABEL_31;
  }
  v10 = this->m_fxSysEngFire;
  this->m_BlowUpTimer = 0.0;
  if ( v10 )
  {
    FxSystem_c::Kill(v10);
    this->m_fxSysEngFire = 0;
  }
LABEL_21:
  if ( (EngineStatus & 0xFEu) >= 0xE2 && *p_m_nHealth > 250.0 )
    *p_m_nHealth = *p_m_nHealth + -2.0;
  CVehicle::ProcessDelayedExplosion(this);
}
// 5513E5: failed to expand linear variable kr00_8.8
// 551424: using guessed type int dword_551424[2];

//----- (00551474) --------------------------------------------------------
bool8 __fastcall CAutomobile::IsInAir(CAutomobile *this)
{
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1

  m_nPhysicalFlags = this->m_nPhysicalFlags;
  return (*(_WORD *)&m_nPhysicalFlags & 0x2000) != 0
      || (*(_WORD *)&m_nPhysicalFlags & 0x100) == 0
      && this->m_aWheelRatios[0] >= 1.0
      && this->m_aWheelRatios[1] >= 1.0
      && this->m_aWheelRatios[2] >= 1.0
      && this->m_aWheelRatios[3] >= 1.0
      && (this->m_vecMoveSpeed.x != 0.0 || this->m_vecMoveSpeed.z != 0.0);
}

//----- (00551500) --------------------------------------------------------
void __fastcall CAutomobile::VehicleDamage(
        CAutomobile *this,
        float fImpulse,
        CVector *nPieceType,
        CEntity *pDamageEntity,
        __int64 pVecDamagePos,
        eWeaponType weaponType)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d1
  float32x2_t v8; // d2
  CEntity *m_pDamageEntity; // r5
  float v12; // s16
  CVector *p_m_vecDamageNormal; // r6
  const CVector *p_m_vecDamagePos; // r11
  float v15; // s18
  CEntity::CEntityInfo v16; // r0
  int v17; // r10
  float m_fDamageImpulseMagnitude; // r6
  float m_fMass; // s16
  unsigned int m_info; // r0
  float v21; // s20
  float y; // s4
  float x; // s0
  float z; // s2
  float v25; // s6
  bool v26; // zf
  CVehicle *m_pTowingVehicle; // r0
  bool v28; // zf
  float v29; // s20
  float v30; // s22
  float v31; // s24
  CVehicle *PlayerVehicle; // r0
  CVehicle *v33; // r0
  CPlayerPed *PlayerPed; // r0
  unsigned int v35; // s0
  CPad *Pad; // r0
  uint32 LightStatus; // r9
  CVehicle *v38; // r5
  float v39; // s20
  const CVector *v40; // r6
  char *v41; // r0
  int v42; // r8
  _BOOL4 v43; // r11
  int v44; // r6
  int v45; // r6
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float xx; // s20
  float yx; // s24
  float zx; // s22
  float v51; // s26
  float v52; // s30
  float v53; // s4
  float v54; // s28
  float v55; // s0
  float v56; // s0
  CMatrix *v57; // r0
  CSimpleTransform *p_m_transform; // r1
  unsigned __int64 v59; // d1
  float v60; // s0
  float v61; // s0
  float v62; // s0
  float v63; // s2
  tHandlingData *pHandling; // r0
  CAutomobile *v65; // r1
  tComponent v66; // r2
  float v67; // s4
  float v68; // s0
  unsigned int m_nModelIndex; // r0
  bool v70; // zf
  float v71; // s2
  CAutomobile *v72; // r2
  CAutomobile *v73; // r6
  unsigned __int64 v74; // d1
  CEntity *v75; // r6
  bool v76; // zf
  CAutomobile *v77; // r0
  bool v78; // zf
  int VehicleTypeForAudio; // r0
  CPed *pDriver; // r0
  UInt16 v81; // r1
  CEntity *v82; // r0
  CAutomobile *v83; // r0
  CPed *v84; // r0
  UInt16 v85; // r1
  float *p_m_nHealth; // r6
  float m_nHealth; // s16
  CAutomobile *v88; // r0
  CVehicle *v89; // r8
  int v90; // s16
  int v91; // r1
  float v92; // s0
  float v93; // s0
  float v94; // s0
  bool v95; // zf
  CEntity *v96; // r0
  float v97; // s0
  CEntity *v98; // r0
  CPed *v99; // r0
  CDamageManager *p_Damage; // r0
  uint32 v101; // r1
  float *p_x; // [sp+10h] [bp-90h]
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // [sp+14h] [bp-8Ch]
  uint32 v104; // [sp+18h] [bp-88h]
  uint32 v105; // [sp+1Ch] [bp-84h]
  CEventVehicleDamage pBeingShotAt; // [sp+20h] [bp-80h] BYREF
  float fDamage[25]; // [sp+3Ch] [bp-64h] BYREF

  fDamage[0] = fImpulse;
  m_pDamageEntity = pDamageEntity;
  if ( (*((_BYTE *)&this->m_nVehicleFlags + 2) & 0x20) == 0 )
    return;
  if ( fImpulse == 0.0 )
  {
    m_pDamageEntity = this->m_pDamageEntity;
    m_fDamageImpulseMagnitude = this->m_fDamageImpulseMagnitude;
    fDamage[0] = m_fDamageImpulseMagnitude;
    nPieceType = (CVector *)this->m_nDamagedPieceType;
    m_fMass = this->m_fMass;
    if ( this->m_pMat->zz < 0.0 && this != FindPlayerVehicle(-1, 0) )
    {
      if ( (*(_BYTE *)&this->m_nAutomobileFlags & 8) != 0 )
        return;
      m_info = (unsigned __int8)this->m_info;
      if ( m_info >> 3 == 8 || *((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31 )
        return;
      if ( m_info >> 3 != 5 )
      {
        v8.n64_u32[0] = 0;
        v6.n64_f32[0] = this->m_nHealth + (float)(CTimer::ms_fTimeStep * -4.0);
        v6.n64_u64[0] = vmax_f32(v6, v8).n64_u64[0];
        LODWORD(this->m_nHealth) = v6.n64_u32[0];
      }
    }
    v21 = m_fDamageImpulseMagnitude;
    if ( m_fDamageImpulseMagnitude == 0.0 )
      return;
    if ( (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x10) != 0 )
      return;
    p_m_vecDamageNormal = &this->m_vecDamageNormal;
    p_m_vecDamagePos = &this->m_vecDamagePos;
    if ( this->m_vehicleType == 2 )
    {
      if ( CBike::DamageKnockOffRider(
             this,
             this->m_fDamageImpulseMagnitude,
             this->m_nDamagedPieceType,
             this->m_pDamageEntity,
             &this->m_vecDamagePos,
             &this->m_vecDamageNormal) )
      {
        return;
      }
    }
    y = this->m_vecDamageNormal.y;
    x = this->m_vecDamageNormal.x;
    z = this->m_vecDamageNormal.z;
    v25 = (float)((float)(x * this->m_pMat->xy) + (float)(y * this->m_pMat->yy)) + (float)(z * this->m_pMat->zy);
    if ( (*(_BYTE *)&this->m_info & 0xF8) == 24
      && v25 < -0.4
      && this->VehicleCreatedBy != 2
      && (float)(v21 / this->m_fMass) > 0.1 )
    {
      this->AutoPilot.TempAction = 19;
      this->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 4000;
    }
    v12 = (float)(m_fMass / 1500.0) * 25.0;
    v26 = CGame::currArea == AREA_MAIN_MAP;
    if ( CGame::currArea )
      v26 = m_pDamageEntity == 0;
    if ( v26 || fabsf(v25) <= 0.4 )
    {
      if ( !m_pDamageEntity )
      {
        v15 = 1.0;
LABEL_40:
        v17 = 0;
        m_pDamageEntity = 0;
        goto LABEL_41;
      }
      v16 = m_pDamageEntity->m_info;
    }
    else
    {
      v16 = m_pDamageEntity->m_info;
      if ( (*(_BYTE *)&v16 & 7) == 2 )
      {
        v21 = v21 * 0.333;
        fDamage[0] = v21;
      }
    }
    v15 = 1.0;
    if ( (*(_BYTE *)&v16 & 7) == 3 )
    {
      if ( LOBYTE(m_pDamageEntity[19].m_transform.m_heading) << 31 )
      {
        v6.n64_f32[0] = (float)((float)((float)(*(float *)&m_pDamageEntity[20].numLodChildren
                                              * m_pDamageEntity->m_pMat->xy)
                                      * x)
                              + (float)((float)(*(float *)&m_pDamageEntity[20].numLodChildren
                                              * m_pDamageEntity->m_pMat->yy)
                                      * y))
                      + (float)((float)(*(float *)&m_pDamageEntity[20].numLodChildren * m_pDamageEntity->m_pMat->zy) * z);
        if ( v6.n64_f32[0] < 0.0 )
        {
          v7.n64_u32[0] = 0;
          v6.n64_f32[0] = v21 + (float)(v6.n64_f32[0] * *(float *)&m_pDamageEntity[2].m_pRwObject);
          v6.n64_u64[0] = vmax_f32(v6, v7).n64_u64[0];
          fDamage[0] = v6.n64_f32[0];
        }
      }
    }
    goto LABEL_7;
  }
  LOBYTE(pBeingShotAt._vptr$CEvent) = 0;
  if ( !CVehicle::CanVehicleBeDamaged(this, pDamageEntity, weaponType, (Bool8 *)&pBeingShotAt) )
    return;
  v12 = 25.0;
  p_m_vecDamageNormal = (CVector *)HIDWORD(pVecDamagePos);
  p_m_vecDamagePos = (const CVector *)pVecDamagePos;
  v15 = 0.333;
  if ( !m_pDamageEntity )
    goto LABEL_40;
  v16 = m_pDamageEntity->m_info;
LABEL_7:
  if ( (*(_BYTE *)&v16 & 7) == 1
    && (float)((float)((float)(p_m_vecDamageNormal->x * this->m_pMat->xz)
                     + (float)(p_m_vecDamageNormal->y * this->m_pMat->yz))
             + (float)(p_m_vecDamageNormal->z * this->m_pMat->zz)) > 0.6 )
  {
    return;
  }
  v17 = 1;
LABEL_41:
  if ( *(_BYTE *)&this->m_info >= 8u
    && (v17 & ((unsigned __int8)(*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x40) >> 6)) == 1
    && m_pDamageEntity != FindPlayerPed(-1)
    && m_pDamageEntity != FindPlayerVehicle(-1, 0) )
  {
    return;
  }
  CVehicle::ReduceVehicleDamage(this, fDamage);
  if ( v17 == 1 )
  {
    m_pTowingVehicle = this->m_pTowingVehicle;
    v28 = m_pDamageEntity == m_pTowingVehicle;
    if ( m_pDamageEntity != m_pTowingVehicle )
      v28 = m_pDamageEntity == this->m_pVehicleBeingTowed;
    if ( v28 )
      return;
  }
  if ( fDamage[0] > v12 && (*(_BYTE *)&this->m_info & 0xF8) != 40 )
  {
    p_m_nVehicleFlags = &this->m_nVehicleFlags;
    if ( *(_BYTE *)&this->m_nVehicleFlags << 31 )
    {
      if ( FindPlayerVehicle(-1, 0) )
      {
        if ( m_pDamageEntity == FindPlayerVehicle(-1, 0) && (*(_BYTE *)&this->m_info & 0xF8) != 32 )
        {
          v29 = this->m_vecMoveSpeed.x;
          v30 = this->m_vecMoveSpeed.y;
          v31 = this->m_vecMoveSpeed.z;
          PlayerVehicle = FindPlayerVehicle(-1, 0);
          if ( sqrtf((float)((float)(v29 * v29) + (float)(v30 * v30)) + (float)(v31 * v31)) <= sqrtf(
                                                                                                 (float)((float)(PlayerVehicle->m_vecMoveSpeed.x * PlayerVehicle->m_vecMoveSpeed.x) + (float)(PlayerVehicle->m_vecMoveSpeed.y * PlayerVehicle->m_vecMoveSpeed.y))
                                                                                               + (float)(PlayerVehicle->m_vecMoveSpeed.z * PlayerVehicle->m_vecMoveSpeed.z)) )
          {
            v33 = FindPlayerVehicle(-1, 0);
            if ( sqrtf(
                   (float)((float)(v33->m_vecMoveSpeed.x * v33->m_vecMoveSpeed.x)
                         + (float)(v33->m_vecMoveSpeed.y * v33->m_vecMoveSpeed.y))
                 + (float)(v33->m_vecMoveSpeed.z * v33->m_vecMoveSpeed.z)) > 0.1 )
            {
              PlayerPed = FindPlayerPed(-1);
              CPlayerPed::SetWantedLevelNoDrop(PlayerPed, 1);
            }
          }
        }
      }
    }
    p_x = &p_m_vecDamageNormal->x;
    if ( *(_BYTE *)&this->m_info <= 7u && fDamage[0] > 50.0 )
    {
      v8.n64_u32[0] = 1132068864;
      v6.n64_f32[0] = (float)((float)((float)(fDamage[0] * 0.4) * 2000.0) / this->m_fMass) + 100.0;
      v35 = (unsigned int)vmin_f32(v6, v8).n64_f32[0];
      Pad = CPad::GetPad(0);
      CPad::StartShake(Pad, 0x9C40 / v35, v35, 0x7D0u);
    }
    if ( v17 == 1 && (*(_BYTE *)&m_pDamageEntity->m_info & 7) == 2 )
    {
      this->pLastDamageEntity = m_pDamageEntity;
      this->LastDamagedWeaponType = 49;
      CEntity::RegisterReference(m_pDamageEntity, &this->pLastDamageEntity);
    }
    LightStatus = CDamageManager::GetLightStatus(&this->Damage, LEFT_HEADLIGHT);
    v105 = CDamageManager::GetLightStatus(&this->Damage, RIGHT_HEADLIGHT);
    v104 = CDamageManager::GetLightStatus(&this->Damage, LEFT_TAIL_LIGHT);
    v38 = (CVehicle *)CDamageManager::GetLightStatus(&this->Damage, RIGHT_TAIL_LIGHT);
    if ( *(_BYTE *)&this->m_info <= 7u )
      CWorld::Players[CWorld::PlayerInFocus].vehicle_time_counter = CTimer::m_snTimeInMilliseconds;
    v39 = (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
        + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z);
    if ( v39 > 0.0004 )
      CAutomobile::dmgDrawCarCollidingParticles(this, p_m_vecDamagePos, v15 * fDamage[0], weaponType);
    v40 = p_m_vecDamagePos;
    if ( v39 > 0.3 )
    {
      v41 = (char *)&nPieceType[-1].z + 3;
      v42 = 0;
      v43 = 1;
      switch ( (unsigned int)v41 )
      {
        case 0u:
          v42 = 0;
          v44 = 1;
          goto LABEL_71;
        case 1u:
          v42 = 0;
          v45 = 1;
          goto LABEL_96;
        case 2u:
          CDamageManager::ApplyDamage(
            &this->Damage,
            this,
            CT_PANEL_FRONT_BUMPER,
            fDamage[0] * 4.0,
            this->pHandling->fCollisionDamageMultiplier);
          m_pMat = this->m_pMat;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &this->m_transform;
          xx = m_pMat->xx;
          yx = m_pMat->yx;
          zx = m_pMat->zx;
          v51 = *p_x;
          v52 = p_x[1];
          v53 = zx * (float)(v40->z - p_tx->m_translate.z);
          v54 = p_x[2];
          v55 = (float)(m_pMat->xx * (float)(v40->x - p_tx->m_translate.x))
              + (float)(yx * (float)(v40->y - p_tx->m_translate.y));
          v56 = (float)(v55 + v53) / CEntity::GetColModel(this)->m_boxBound.m_vecMax.x;
          if ( v56 > 0.7
            || (v67 = (float)((float)(v51 * xx) + (float)(v52 * yx)) + (float)(v54 * zx), v67 < -0.5)
            && v56 > 0.5
            && fDamage[0] > (float)(FRONT_DAMAGE_MAG_MIN_WING * this->m_fMass) )
          {
            v42 = 8;
            goto LABEL_108;
          }
          if ( v56 < -0.7 )
            goto LABEL_107;
          v42 = 0;
          if ( v67 > 0.5 && v56 < -0.5 )
          {
            if ( fDamage[0] > (float)(FRONT_DAMAGE_MAG_MIN_WING * this->m_fMass) )
LABEL_107:
              v42 = 4;
            else
              v42 = 0;
          }
LABEL_108:
          if ( CDamageManager::GetPanelStatus(&this->Damage, 5) )
          {
            if ( fDamage[0] <= (float)(FRONT_DAMAGE_MAG_MIN_BONNET * this->m_fMass) )
            {
              if ( weaponType <= WEAPONTYPE_PARACHUTE && (rand() & 3) == 0 )
                v42 |= 1u;
            }
            else
            {
              v42 |= 1u;
            }
          }
          if ( CDamageManager::GetPanelStatus(&this->Damage, 5) < 2
            || fDamage[0] <= (float)(FRONT_DAMAGE_MAG_MIN_WSCREEN * this->m_fMass) )
          {
            if ( !v42 )
              break;
          }
          else
          {
            v42 |= 2u;
          }
          v44 = 0;
          if ( (v42 & 1) != 0 )
          {
LABEL_71:
            CDamageManager::ApplyDamage(
              &this->Damage,
              this,
              CT_DOOR_BONNET,
              fDamage[0] * 4.0,
              this->pHandling->fCollisionDamageMultiplier);
            if ( v44 )
              break;
          }
          v43 = v42 == 0;
          if ( (v42 & 4) == 0 && v42 )
            goto LABEL_122;
LABEL_121:
          CDamageManager::ApplyDamage(
            &this->Damage,
            this,
            CT_PANEL_FRONT_LEFT,
            fDamage[0] * 4.0,
            this->pHandling->fCollisionDamageMultiplier);
          if ( v43 )
            break;
LABEL_122:
          v43 = v42 == 0;
          if ( (v42 & 8) == 0 && v42 )
            goto LABEL_125;
LABEL_124:
          CDamageManager::ApplyDamage(
            &this->Damage,
            this,
            CT_PANEL_FRONT_RIGHT,
            fDamage[0] * 4.0,
            this->pHandling->fCollisionDamageMultiplier);
          if ( !v43 )
          {
LABEL_125:
            if ( !v42 || (v42 & 2) != 0 )
            {
LABEL_127:
              v62 = 4.0;
              v63 = fDamage[0];
              pHandling = this->pHandling;
              v65 = this;
              v66 = CT_PANEL_WINDSCREEN;
LABEL_128:
              CDamageManager::ApplyDamage(&this->Damage, v65, v66, v63 * v62, pHandling->fCollisionDamageMultiplier);
            }
          }
          break;
        case 3u:
          CDamageManager::ApplyDamage(
            &this->Damage,
            this,
            CT_PANEL_REAR_BUMPER,
            fDamage[0] * 4.0,
            this->pHandling->fCollisionDamageMultiplier);
          v57 = this->m_pMat;
          p_m_transform = (CSimpleTransform *)&v57->tx;
          if ( !v57 )
            p_m_transform = &this->m_transform;
          v59 = vmul_f32(
                  *(float32x2_t *)&v57->yx,
                  vsub_f32(*(float32x2_t *)&v40->y, *(float32x2_t *)&p_m_transform->m_translate.y)).n64_u64[0];
          v60 = (float)(v57->xx * (float)(v40->x - p_m_transform->m_translate.x)) + *(float *)&v59;
          v61 = (float)(v60 + *((float *)&v59 + 1)) / CEntity::GetColModel(this)->m_boxBound.m_vecMax.x;
          if ( (*(_DWORD *)p_m_nVehicleFlags & 0x100) != 0
            && v61 > 0.1
            && fDamage[0] > (float)(FRONT_DAMAGE_MAG_MIN_WING * this->m_fMass) )
          {
            v42 = 64;
          }
          else
          {
            v42 = 0;
            if ( v61 < -0.1 && (*(_DWORD *)p_m_nVehicleFlags & 0x100) != 0 )
            {
              if ( fDamage[0] <= (float)(FRONT_DAMAGE_MAG_MIN_WING * this->m_fMass) )
                v42 = 0;
              else
                v42 = 32;
            }
          }
          if ( CDamageManager::GetPanelStatus(&this->Damage, 6) < 2 )
            v42 |= 0x10u;
          if ( !v42 )
            break;
          if ( (v42 & 0x10) != 0 )
          {
            v45 = 0;
LABEL_96:
            CDamageManager::ApplyDamage(
              &this->Damage,
              this,
              CT_DOOR_BOOT,
              fDamage[0] * 4.0,
              this->pHandling->fCollisionDamageMultiplier);
            if ( v45 )
              break;
          }
          v43 = v42 == 0;
          if ( (v42 & 0x20) == 0 && v42 )
            goto LABEL_100;
LABEL_99:
          CDamageManager::ApplyDamage(
            &this->Damage,
            this,
            CT_DOOR_REAR_LEFT,
            fDamage[0] * 4.0,
            this->pHandling->fCollisionDamageMultiplier);
          if ( v43 )
            break;
LABEL_100:
          if ( v42 && (v42 & 0x40) == 0 )
            break;
LABEL_102:
          v62 = 4.0;
          v63 = fDamage[0];
          pHandling = this->pHandling;
          v65 = this;
          v66 = CT_DOOR_REAR_RIGHT;
          goto LABEL_128;
        case 4u:
          v62 = 4.0;
          v63 = fDamage[0];
          pHandling = this->pHandling;
          v65 = this;
          v66 = CT_DOOR_FRONT_LEFT;
          goto LABEL_128;
        case 5u:
          v62 = 4.0;
          v63 = fDamage[0];
          pHandling = this->pHandling;
          v65 = this;
          v66 = CT_DOOR_FRONT_RIGHT;
          goto LABEL_128;
        case 6u:
          goto LABEL_99;
        case 7u:
          goto LABEL_102;
        case 8u:
          goto LABEL_121;
        case 9u:
          goto LABEL_124;
        case 0x12u:
          goto LABEL_127;
        default:
          break;
      }
    }
    v68 = v15 * (float)((float)((float)(fDamage[0] - v12) * this->pHandling->fCollisionDamageMultiplier) * 0.6);
    fDamage[0] = v68;
    m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
    if ( m_nModelIndex > 0x1F4 )
    {
      v70 = m_nModelIndex == 501;
      if ( m_nModelIndex != 501 )
        v70 = m_nModelIndex == 564;
      if ( v70 )
      {
LABEL_137:
        v71 = 30.0;
LABEL_138:
        v68 = v68 * v71;
        fDamage[0] = v68;
      }
    }
    else
    {
      if ( m_nModelIndex != 428 )
      {
        if ( m_nModelIndex != 465 )
          goto LABEL_139;
        goto LABEL_137;
      }
      v82 = this->m_pDamageEntity;
      if ( v82 && *(_BYTE *)&v82->m_info <= 7u )
      {
        v71 = 7.0;
        goto LABEL_138;
      }
    }
LABEL_139:
    v72 = (CAutomobile *)this->m_pDamageEntity;
    if ( v72 && v72->m_nModelIndex == 432 )
    {
      v68 = v68 * 15.0;
      fDamage[0] = v68;
    }
    if ( v68 <= 0.0 )
      goto LABEL_200;
    if ( v72 && (*(_BYTE *)&v72->m_info & 7) == 2 && v72->pDriver && v68 > 5.0 && this->pDriver )
    {
      v73 = v72;
      v74 = vmul_f32(
              vsub_f32(*(float32x2_t *)&v72->m_vecMoveSpeed.y, *(float32x2_t *)&this->m_vecMoveSpeed.y),
              *(float32x2_t *)&this->m_vecDamageNormal.y).n64_u64[0];
      if ( (float)((float)((float)((float)(v72->m_vecMoveSpeed.x - this->m_vecMoveSpeed.x) * this->m_vecDamageNormal.x)
                         + *(float *)&v74)
                 + *((float *)&v74 + 1)) >= 0.0 )
        v72 = this;
      else
        v73 = this;
      CEventVehicleDamage::CEventVehicleDamage(&pBeingShotAt, v73, v72, WEAPONTYPE_RAMMEDBYCAR);
      pBeingShotAt._vptr$CEvent = (int (**)(void))&off_66D7A0;
      CEventGroup::Add(&v73->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&pBeingShotAt, 0);
      CVehicle::ReactToVehicleDamage(this, v73->pDriver);
      CEventVehicleDamage::~CEventVehicleDamage(&pBeingShotAt);
      v68 = fDamage[0];
    }
    if ( v68 > 5.0 )
    {
      v75 = this->m_pDamageEntity;
      v76 = v75 == 0;
      if ( v75 )
        v76 = this->pDriver == 0;
      if ( !v76 && (*(_BYTE *)&v75->m_info & 7) == 2 )
      {
        v77 = (CAutomobile *)FindPlayerVehicle(-1, 0);
        v78 = v77 == this;
        if ( v77 == this )
          v78 = LOBYTE(v75[19].m_pLod) == 2;
        if ( !v78 && v75[18].m_pLastRenderedLink )
        {
          VehicleTypeForAudio = CAEVehicleAudioEntity::GetVehicleTypeForAudio(&this->m_VehicleAudioEntity);
          if ( VehicleTypeForAudio == 1 )
          {
            pDriver = this->pDriver;
            v81 = 66;
          }
          else
          {
            v26 = VehicleTypeForAudio == 0;
            pDriver = this->pDriver;
            if ( v26 )
              v81 = 67;
            else
              v81 = 68;
          }
          CPed::Say(pDriver, v81, 0, 0.66, 0, 0, 0);
        }
      }
      v83 = (CAutomobile *)FindPlayerVehicle(-1, 0);
      if ( v75 )
      {
        if ( this == v83 )
        {
          v84 = CVehicle::PickRandomPassenger(this);
          if ( v84 )
          {
            if ( (*(_BYTE *)&v75->m_info & 7) == 3 )
              v85 = 36;
            else
              v85 = 29;
            CPed::Say(v84, v85, 0, 1.0, 0, 0, 0);
          }
        }
      }
      CInterestingEvents::Add(&g_InterestingEvents, ECarCrash, this);
    }
    p_m_nHealth = &this->m_nHealth;
    m_nHealth = this->m_nHealth;
    v88 = (CAutomobile *)FindPlayerVehicle(-1, 0);
    v89 = v38;
    v90 = (int)m_nHealth;
    v91 = *(_DWORD *)p_m_nVehicleFlags & 0x8000;
    if ( this == v88 )
    {
      v92 = 2.0;
      if ( v91 )
        v92 = 6.0;
    }
    else if ( v91 )
    {
      v92 = 12.0;
    }
    else
    {
      v38 = (CVehicle *)this->m_pDamageEntity;
      if ( !v38 || v38 != FindPlayerVehicle(-1, 0) )
      {
        v93 = fDamage[0] * 0.25;
        goto LABEL_187;
      }
      v92 = 1.5;
    }
    v93 = fDamage[0] / v92;
LABEL_187:
    v94 = *p_m_nHealth - v93;
    *p_m_nHealth = v94;
    v95 = CCheat::m_aCheatsActive[60] == 0;
    if ( CCheat::m_aCheatsActive[60] )
    {
      v38 = (CVehicle *)this->m_pDamageEntity;
      v95 = v38 == 0;
    }
    if ( !v95 )
    {
      if ( v38 == FindPlayerVehicle(-1, 0) )
      {
        (*((void (__fastcall **)(CAutomobile *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(
          this,
          this->m_pDamageEntity,
          0);
        v38 = v89;
        goto LABEL_200;
      }
      v94 = *p_m_nHealth;
    }
    v38 = v89;
    if ( v90 >= 1 && v94 <= 0.0 )
    {
      *p_m_nHealth = 1.0;
      v96 = this->m_pDamageEntity;
      if ( v96 )
      {
        if ( v96->m_nModelIndex == 432 && FindPlayerVehicle(-1, 0) != this )
        {
          (*((void (__fastcall **)(CAutomobile *, CEntity *, _DWORD))this->_vptr$CPlaceable + 42))(
            this,
            this->m_pDamageEntity,
            0);
          if ( LightStatus == 1 )
            goto LABEL_202;
          goto LABEL_201;
        }
      }
    }
LABEL_200:
    if ( LightStatus == 1 )
      goto LABEL_202;
LABEL_201:
    if ( CDamageManager::GetLightStatus(&this->Damage, LEFT_HEADLIGHT) == 1 )
    {
LABEL_208:
      CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 92, 0.0);
      goto LABEL_209;
    }
LABEL_202:
    if ( (v105 == 1 || CDamageManager::GetLightStatus(&this->Damage, RIGHT_HEADLIGHT) != 1)
      && (v104 == 1 || CDamageManager::GetLightStatus(&this->Damage, LEFT_TAIL_LIGHT) != 1)
      && (v38 == (CVehicle *)((char *)&dword_0 + 1)
       || CDamageManager::GetLightStatus(&this->Damage, RIGHT_TAIL_LIGHT) != 1) )
    {
      goto LABEL_209;
    }
    goto LABEL_208;
  }
LABEL_209:
  v97 = this->m_nHealth;
  if ( v97 >= 250.0 )
  {
    if ( this->m_nModelIndex != 424 )
      return;
    if ( v97 >= 400.0 )
    {
      if ( v97 >= 600.0 )
        return;
      p_Damage = &this->Damage;
      v101 = 100;
    }
    else
    {
      p_Damage = &this->Damage;
      v101 = 200;
    }
    CDamageManager::SetEngineStatus(p_Damage, v101);
    return;
  }
  if ( CDamageManager::GetEngineStatus(&this->Damage) <= 0xE0 )
  {
    CDamageManager::SetEngineStatus(&this->Damage, 0xE1u);
    this->m_BlowUpTimer = 0.0;
    v98 = this->m_pDamageEntity;
    this->pEntityThatSetUsOnFire = v98;
    if ( v98 )
      CEntity::RegisterReference(v98, &this->pEntityThatSetUsOnFire);
    v99 = CVehicle::PickRandomPassenger(this);
    if ( v99 )
      CPed::Say(v99, 0x21u, 0x5DCu, 1.0, 0, 0, 0);
  }
}
// 551D32: conditional instruction was optimized away because r8.4>=10u
// 551E72: conditional instruction was optimized away because r8.4!=0
// 551E82: conditional instruction was optimized away because r8.4!=0
// 551EA0: conditional instruction was optimized away because r8.4!=0
// 551EEA: conditional instruction was optimized away because r8.4!=0
// 551624: variable 'v6' is possibly undefined
// 551624: variable 'v8' is possibly undefined
// 5517AC: variable 'v7' is possibly undefined
// 0: using guessed type int dword_0;
// 66D7A0: using guessed type void *off_66D7A0;
// 551500: using guessed type float fDamage[25];

//----- (00552414) --------------------------------------------------------
void __fastcall CAutomobile::TellHeliToGoToCoors(
        CAutomobile *this,
        float TargetX,
        float TargetY,
        float TargetZ,
        float MinHeightAboveTerrain,
        float LowestFlightHeight)
{
  CEntity::CEntityInfo m_info; // r4
  float *p_ZRot; // r4
  float ZRot; // s2
  float v9; // s0

  this->AutoPilot.Mission = 20;
  this->AutoPilot.CruiseSpeed = 100;
  m_info = this->m_info;
  this->AutoPilot.TargetCoors.x = TargetX;
  this->AutoPilot.TargetCoors.y = TargetY;
  this->AutoPilot.TargetCoors.z = TargetZ;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
  p_ZRot = &this->ZRot;
  *(float *)&this[1].m_nFlags.bdummy = LowestFlightHeight;
  ZRot = this->ZRot;
  *(float *)&this[1].pReferences = MinHeightAboveTerrain;
  if ( ZRot == 0.0 )
  {
    v9 = CGeneral::GetATanOfXY(this->m_pMat->xy, this->m_pMat->yy) + 3.1416;
    *p_ZRot = v9;
    if ( v9 > 6.2832 )
    {
      do
        v9 = v9 + -6.2832;
      while ( v9 > 6.2832 );
      *p_ZRot = v9;
    }
  }
}

//----- (005524B4) --------------------------------------------------------
void __fastcall CAutomobile::SetHeliOrientation(CAutomobile *this, float Orientation)
{
  this->HeliRequestedOrientation = Orientation;
}

//----- (005524BA) --------------------------------------------------------
void __fastcall CAutomobile::ClearHeliOrientation(CAutomobile *this)
{
  this->HeliRequestedOrientation = -1.0;
}

//----- (005524C6) --------------------------------------------------------
void __fastcall CAutomobile::TellPlaneToGoToCoors(
        CAutomobile *this,
        float TargetX,
        float TargetY,
        float TargetZ,
        float MinHeightAboveTerrain,
        float LowestFlightHeight)
{
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  CVector *p_TargetCoors; // r12
  CEntity::CEntityInfo m_info; // r0
  float ZRot; // s2

  this->AutoPilot.Mission = 22;
  v6.n64_f32[0] = LowestFlightHeight;
  v7.n64_f32[0] = TargetZ;
  this->AutoPilot.CruiseSpeed = 0;
  p_TargetCoors = &this->AutoPilot.TargetCoors;
  m_info = this->m_info;
  p_TargetCoors->x = TargetX;
  p_TargetCoors->y = TargetY;
  p_TargetCoors->z = TargetZ;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x18);
  this[1].m_nFlags.bdummy = vmax_f32(v6, v7).n64_u32[0];
  ZRot = this->ZRot;
  *(float *)&this[1].pReferences = MinHeightAboveTerrain;
  if ( ZRot == 0.0 )
    this->ZRot = CGeneral::GetATanOfXY(this->m_pMat->xy, this->m_pMat->yy);
  *(_DWORD *)&this->m_nVehicleFlags |= 0x10u;
}
// 5524E8: variable 'v6' is possibly undefined
// 5524E8: variable 'v7' is possibly undefined

//----- (0055253C) --------------------------------------------------------
void __fastcall CAutomobile::ProcessFlyingCarStuff(CAutomobile *this)
{
  unsigned int v1; // r1

  v1 = *(_BYTE *)&this->m_info >> 3;
  if ( v1 <= 8
    && ((1 << v1) & 0x109) != 0
    && CCheat::m_aCheatsActive[56]
    && CTimer::ms_fTimeStep > 0.0
    && sqrtf(
         (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
               + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
       + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) > 0.0 )
  {
    CVehicle::FlyingControl(this, FLIGHTMODEL_PLANE, -10000.0, -10000.0, -10000.0, -10000.0);
  }
}

//----- (005525CC) --------------------------------------------------------
void __fastcall CAutomobile::SetBumperDamage(CAutomobile *this, ePanels PanelID, bool bDontSpawnStuff)
{
  _BOOL4 v4; // r8
  char PanelStatus; // r6
  int32 CarNodeIndexFromPanel; // r4
  int (***v8)(void); // r0
  RwFrame_0 *v9; // r1
  int m_nComponentIndex; // r0
  CBouncingPanel *BouncingPanels; // r5
  CAutomobile *v12; // r0
  uint32 v13; // r2
  RwFrame_0 **v14; // r6
  int v15; // r1
  int v16; // r1
  int v17; // s0

  v4 = bDontSpawnStuff;
  PanelStatus = CDamageManager::GetPanelStatus(&this->Damage, PanelID);
  CarNodeIndexFromPanel = CDamageManager::GetCarNodeIndexFromPanel(PanelID);
  v8 = &this->_vptr$CPlaceable + CarNodeIndexFromPanel;
  v9 = (RwFrame_0 *)v8[407];
  if ( !v9
    || (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << CarNodeIndexFromPanel)) == 0 )
  {
    return;
  }
  if ( PanelStatus == 1 )
  {
    v12 = this;
    v13 = 2;
LABEL_13:
    sub_18B798(v12, v9, v13);
    return;
  }
  if ( PanelStatus == 3 )
  {
    if ( !v4 )
    {
      v14 = (RwFrame_0 **)(v8 + 407);
      CAutomobile::SpawnFlyingComponent(this, CarNodeIndexFromPanel, 0);
      v9 = *v14;
    }
    v12 = this;
    v13 = 0;
    goto LABEL_13;
  }
  if ( PanelStatus == 2 && (this->pHandling->mFlags & 0x10000000) == 0 )
  {
    m_nComponentIndex = this->BouncingPanels[0].m_nComponentIndex;
    if ( m_nComponentIndex == -1 )
    {
      BouncingPanels = this->BouncingPanels;
LABEL_21:
      v17 = rand();
      sub_193578(BouncingPanels, CarNodeIndexFromPanel, 0, (float)((float)((float)v17 * -4.6566e-10) * 0.3) + -0.2);
      return;
    }
    if ( CarNodeIndexFromPanel != m_nComponentIndex )
    {
      v15 = (unsigned __int16)this->BouncingPanels[1].m_nComponentIndex;
      if ( v15 == 0xFFFF )
      {
        BouncingPanels = &this->BouncingPanels[1];
        goto LABEL_21;
      }
      if ( CarNodeIndexFromPanel != (__int16)v15 )
      {
        v16 = (unsigned __int16)this->BouncingPanels[2].m_nComponentIndex;
        if ( v16 == 0xFFFF )
        {
          BouncingPanels = &this->BouncingPanels[2];
          goto LABEL_21;
        }
        if ( CarNodeIndexFromPanel != (__int16)v16 && LOWORD(this->ChassisDoor.m_fOpenAngle) == 0xFFFF )
        {
          BouncingPanels = (CBouncingPanel *)&this->ChassisDoor;
          goto LABEL_21;
        }
      }
    }
  }
}

//----- (005526F4) --------------------------------------------------------
CPhysical *__fastcall CAutomobile::SpawnFlyingComponent(CAutomobile *this, int32 index, uint32 type)
{
  CObject *v6; // r4
  int (***v7)(void); // r5
  RwFrame_0 *v8; // r0
  RwMatrix *LTM; // r5
  int (**v10)(void); // r0
  int v11; // r1
  CMatrix *v12; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float tz; // s4
  float v16; // s0
  float z; // s10
  float v18; // s2
  float xx; // s6
  float yx; // s8
  float zx; // s12
  int m_nFlags; // r1
  int v23; // r0
  RwFrame_0 *v24; // r6
  RpAtomic_0 *v25; // r0
  __int64 v26; // d19
  __int64 v27; // d20
  __int64 v28; // d21
  __int64 v29; // d16
  __int64 v30; // d17
  __int64 v31; // d22
  __int64 v32; // d23
  int (**v33)(void); // r1
  int v34; // r2
  float v35; // s2
  unsigned int v36; // s0
  uint32 v37; // r0
  __int64 v38; // d16
  float v39; // s0
  float v40; // s2
  CMatrix **p_m_pMat; // r5
  bool v42; // cc
  float v43; // s0
  float x; // s4
  float y; // s6
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *v47; // r2
  RwReal v48; // s0
  RwReal v49; // s4
  CMatrix *v50; // r1
  float *p_x; // r0
  float v52; // s4
  float v53; // s10
  float v54; // s0
  float xz; // s2
  float yz; // s4
  float zz; // s0
  float *p_xx; // r0
  float v59; // s6
  float v60; // s4
  float v61; // s0
  CSimpleTransform *v62; // r1
  float v63; // s0
  float v64; // s4
  RwReal v65; // s2
  const CMatrix *v66; // r8
  const CMatrix *v67; // r5
  CColModel *m_pColModel; // r6
  CColModel *ColModel; // r0
  CMatrix v71; // [sp+10h] [bp-68h] BYREF
  RpAtomic_0 *data; // [sp+58h] [bp-20h] BYREF
  CVector v73; // 0:r1.12
  CVector v74; // 0:r1.12

  if ( CObject::nNoTempObjects > 0x95u )
    return 0;
  v7 = &this->_vptr$CPlaceable + index;
  v6 = 0;
  v8 = (RwFrame_0 *)v7[407];
  if ( v8 )
  {
    data = 0;
    RwFrameForAllObjects(v8, GetCurrentAtomicObjectCB, &data);
    if ( data )
    {
      CPools::ms_pObjectPool->m_bDealWithNoMemory = 1;
      v6 = (CObject *)CObject::operator new(0x184u);
      CObject::CObject(v6);
      CPools::ms_pObjectPool->m_bDealWithNoMemory = 0;
      if ( !v6 )
        return 0;
      LTM = RwFrameGetLTM((RwFrame_0 *)v7[407]);
      if ( index == 18 )
      {
        v10 = v6->_vptr$CPlaceable;
        v11 = 377;
LABEL_8:
        ((void (__fastcall *)(CObject *, int))v10[7])(v6, v11);
      }
      else
      {
        switch ( type )
        {
          case 0u:
            (*((void (__fastcall **)(CObject *, int))v6->_vptr$CPlaceable + 7))(v6, 375);
            CMatrix::CMatrix(&v71, LTM, 0);
            m_pMat = this->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            tz = v71.tz;
            if ( !m_pMat )
              p_tx = &this->m_transform;
            v16 = v71.tx - p_tx->m_translate.x;
            z = p_tx->m_translate.z;
            v18 = v71.ty - p_tx->m_translate.y;
            xx = m_pMat->xx;
            yx = m_pMat->yx;
            zx = m_pMat->zx;
            v6->m_vecCOM.y = 0.0;
            v6->m_vecCOM.z = 0.0;
            v6->m_vecCOM.x = -(float)((float)((float)(v16 * xx) + (float)(v18 * yx)) + (float)((float)(tz - z) * zx));
            CMatrix::~CMatrix(v12);
            break;
          case 1u:
            v10 = v6->_vptr$CPlaceable;
            v11 = 379;
            goto LABEL_8;
          case 2u:
            (*((void (__fastcall **)(CObject *, int))v6->_vptr$CPlaceable + 7))(v6, 374);
            m_nFlags = (int)v6->m_nFlags;
            v6->m_vecCOM.x = 0.0;
            v6->m_vecCOM.y = -0.5;
            v6->m_vecCOM.z = 0.0;
            *(_DWORD *)&v6->m_nFlags = m_nFlags | 0x4000;
            break;
          case 3u:
            (*((void (__fastcall **)(CObject *, int))v6->_vptr$CPlaceable + 7))(v6, 377);
            v23 = 1053609165;
            goto LABEL_18;
          case 4u:
            (*((void (__fastcall **)(CObject *, int))v6->_vptr$CPlaceable + 7))(v6, 378);
            v23 = -1097229926;
LABEL_18:
            v6->m_vecCOM.x = 0.0;
            LODWORD(v6->m_vecCOM.y) = v23;
            v6->m_vecCOM.z = 0.0;
            break;
          default:
            v10 = v6->_vptr$CPlaceable;
            v11 = 376;
            goto LABEL_8;
        }
      }
      CObject::RefModelInfo(v6, this->m_nModelIndex);
      v24 = RwFrameCreate();
      v25 = RpAtomicClone(data);
      data = v25;
      v26 = *(_QWORD *)&LTM->pos.z;
      v27 = *(_QWORD *)&LTM->at.x;
      v28 = *(_QWORD *)&LTM->at.z;
      v29 = *(_QWORD *)&LTM->right.x;
      v30 = *(_QWORD *)&LTM->right.z;
      v31 = *(_QWORD *)&LTM->up.x;
      v32 = *(_QWORD *)&LTM->up.z;
      *(_QWORD *)&v24->modelling.pos.x = *(_QWORD *)&LTM->pos.x;
      *(_QWORD *)&v24->modelling.pos.z = v26;
      *(_QWORD *)&v24->modelling.at.x = v27;
      *(_QWORD *)&v24->modelling.at.z = v28;
      *(_QWORD *)&v24->modelling.right.x = v29;
      *(_QWORD *)&v24->modelling.right.z = v30;
      *(_QWORD *)&v24->modelling.up.x = v31;
      *(_QWORD *)&v24->modelling.up.z = v32;
      RpAtomicSetFrame(v25, v24);
      CVisibilityPlugins::SetAtomicRenderCallback(data, 0);
      CEntity::AttachToRwObject(v6, &data->object.object, 1);
      v33 = v6->_vptr$CPlaceable;
      v34 = (int)v6->m_nFlags;
      v6->m_fMass = 10.0;
      v6->m_fTurnMass = 25.0;
      v6->m_fAirResistance = 0.97;
      v6->m_fElasticity = 0.1;
      v6->m_fBuoyancyConstant = 0.10667;
      v6->ObjectCreatedBy = 3;
      *(_DWORD *)&v6->m_nFlags = v34 | 0x80000;
      ((void (__fastcall *)(CObject *, _DWORD))v33[5])(v6, 0);
      v6->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&v6->m_nObjectFlags & 0xFFFFFF7E | 0x80);
      v6->m_colour1 = this->m_colour1;
      v6->m_colour2 = this->m_colour2;
      CObject::SetRemapTexture(v6, this->m_pRemapTexture, this->m_remapTxdName);
      if ( ++CObject::nNoTempObjects < 0x15u )
      {
        if ( CObject::nNoTempObjects < 0xBu )
        {
          v37 = CTimer::m_snTimeInMilliseconds + 20000;
LABEL_25:
          v6->m_nEndOfLifeTime = v37;
          v38 = *(_QWORD *)&this->m_vecMoveSpeed.x;
          v6->m_vecMoveSpeed.z = this->m_vecMoveSpeed.z;
          v39 = v6->m_vecMoveSpeed.z;
          *(_QWORD *)&v6->m_vecMoveSpeed.x = v38;
          if ( v39 <= 0.0 )
          {
            p_m_pMat = &this->m_pMat;
            if ( this->m_pMat->zz > 0.0 )
            {
              v42 = (unsigned int)index > 0x12;
              if ( index != 18 )
                v42 = type - 3 > 1;
              if ( !v42 )
              {
                v43 = (float)(v39 * -1.5) + 0.04;
LABEL_34:
                x = v6->m_vecMoveSpeed.x;
                y = v6->m_vecMoveSpeed.y;
                p_m_transform = &this->m_transform;
                v6->m_vecMoveSpeed.z = v43;
                v47 = &this->m_transform;
                v6->m_vecMoveSpeed.x = x * 0.75;
                v6->m_vecMoveSpeed.y = y * 0.75;
                v48 = this->m_vecTurnSpeed.x + this->m_vecTurnSpeed.x;
                v49 = this->m_vecTurnSpeed.z + this->m_vecTurnSpeed.z;
                v6->m_vecTurnSpeed.y = this->m_vecTurnSpeed.y + this->m_vecTurnSpeed.y;
                v6->m_vecTurnSpeed.x = v48;
                v6->m_vecTurnSpeed.z = v49;
                v50 = v6->m_pMat;
                if ( *p_m_pMat )
                  v47 = (CSimpleTransform *)&(*p_m_pMat)->tx;
                p_x = &v50->tx;
                v52 = v47->m_translate.z;
                if ( !v50 )
                  p_x = &v6->m_transform.m_translate.x;
                v53 = p_x[2];
                v54 = *p_x - v47->m_translate.x;
                v71.yx = p_x[1] - v47->m_translate.y;
                v71.xx = v54;
                v71.zx = v53 - v52;
                CVector::Normalise((CVector *)&v71);
                if ( index == 18 || type - 3 < 2 )
                {
                  xz = (*p_m_pMat)->xz;
                  yz = (*p_m_pMat)->yz;
                  zz = (*p_m_pMat)->zz;
                  v73.x = xz + v71.xx;
                  v71.xx = xz + v71.xx;
                  v73.y = yz + v71.yx;
                  v71.yx = yz + v71.yx;
                  v73.z = zz + v71.zx;
                  v71.zx = zz + v71.zx;
                  if ( zz > 0.0 )
                  {
                    p_xx = &v6->m_pMat->xx;
                    v59 = sqrtf(
                            (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                          + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y));
                    v60 = (float)(yz * v59) + p_xx[13];
                    v61 = (float)(v59 * zz) + p_xx[14];
                    p_xx[12] = (float)(xz * v59) + p_xx[12];
                    p_xx[13] = v60;
                    p_xx[14] = v61;
                  }
                }
                else
                {
                  v73.x = v71.xx;
                  v73.y = v71.yx;
                  v73.z = v71.zx;
                }
                CPhysical::ApplyMoveForce(v6, v73);
                if ( type == 1 )
                {
                  v6->m_vecTurnSpeed.x = 0.5;
                  v6->m_fTurnMass = 5.0;
                  v6->m_fAirResistance = 0.99;
                }
                if ( (*(_BYTE *)&this->m_info & 0xF8) == 40 && CEntity::IsVisible(this) )
                {
                  if ( *p_m_pMat )
                    p_m_transform = (CSimpleTransform *)&(*p_m_pMat)->tx;
                  v62 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
                  if ( !TheCamera.m_pMat )
                    v62 = &TheCamera.m_transform;
                  v63 = v62->m_translate.x - p_m_transform->m_translate.x;
                  v64 = v62->m_translate.z - p_m_transform->m_translate.z;
                  if ( (float)((float)((float)(v63 * v71.xx)
                                     + (float)((float)(v62->m_translate.y - p_m_transform->m_translate.y) * v71.yx))
                             + (float)(v64 * v71.zx)) > -0.5 )
                  {
                    v71.yx = v62->m_translate.y - p_m_transform->m_translate.y;
                    v71.xx = v63;
                    v71.zx = v64;
                    CVector::Normalise((CVector *)&v71);
                    v65 = (float)(v71.zx + 0.3) * 5.0;
                    v71.zx = v71.zx + 0.3;
                    v74.x = v71.xx * 5.0;
                    v74.y = v71.yx * 5.0;
                    v74.z = v65;
                    CPhysical::ApplyMoveForce(v6, v74);
                  }
                }
                v66 = *p_m_pMat;
                v67 = v6->m_pMat;
                m_pColModel = CModelInfo::ms_modelInfoPtrs[v6->m_nModelIndex]->m_pColModel;
                ColModel = CEntity::GetColModel(this);
                if ( CCollision::ProcessColModels(v67, m_pColModel, v66, ColModel, CWorld::m_aTempColPts, 0, 0, 0) >= 1 )
                  v6->m_pNOCollisionVehicle = this;
                if ( (*((_BYTE *)&this->m_nPhysicalFlags + 3) & 0x20) != 0 )
                  *(_DWORD *)&v6->m_nPhysicalFlags |= 0x20000000u;
                CWorld::Add(v6);
                return v6;
              }
            }
            v40 = 0.25;
          }
          else
          {
            v40 = 1.5;
            p_m_pMat = &this->m_pMat;
          }
          v43 = v39 * v40;
          goto LABEL_34;
        }
        v36 = CTimer::m_snTimeInMilliseconds;
        v35 = 10000.0;
      }
      else
      {
        v35 = 4000.0;
        v36 = CTimer::m_snTimeInMilliseconds;
      }
      v37 = (unsigned int)(float)((float)v36 + v35);
      goto LABEL_25;
    }
  }
  return v6;
}
// 55280E: variable 'v12' is possibly undefined

//----- (00552CDC) --------------------------------------------------------
void __fastcall CAutomobile::SetPanelDamage(CAutomobile *this, ePanels PanelID, bool bDontSpawnStuff)
{
  _BOOL4 v4; // r8
  char PanelStatus; // r4
  unsigned int CarNodeIndexFromPanel; // r5
  int (***v8)(void); // r0
  RwFrame_0 *v9; // r1
  RwFrame_0 **v10; // r10
  int m_nComponentIndex; // r0
  CBouncingPanel *BouncingPanels; // r6
  CAutomobile *v13; // r0
  uint32 v14; // r2
  int v15; // r2
  int v16; // r2
  int v17; // r0

  v4 = bDontSpawnStuff;
  PanelStatus = CDamageManager::GetPanelStatus(&this->Damage, PanelID);
  CarNodeIndexFromPanel = CDamageManager::GetCarNodeIndexFromPanel(PanelID);
  v8 = &this->_vptr$CPlaceable + CarNodeIndexFromPanel;
  v9 = (RwFrame_0 *)v8[407];
  if ( v9
    && (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << CarNodeIndexFromPanel)) != 0 )
  {
    v10 = (RwFrame_0 **)(v8 + 407);
    if ( PanelStatus == 1 )
    {
      if ( PanelID != WINDSCREEN_PANEL )
      {
LABEL_27:
        v13 = this;
        v14 = 2;
LABEL_28:
        sub_18B798(v13, v9, v14);
        return;
      }
      CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 91, 0.0);
LABEL_13:
      v9 = *v10;
      goto LABEL_27;
    }
    if ( PanelStatus == 3 )
    {
      if ( v4 )
      {
        if ( PanelID == WINDSCREEN_PANEL )
          CGlass::CarWindscreenShatters(this, 0);
      }
      else
      {
        CAutomobile::SpawnFlyingComponent(this, CarNodeIndexFromPanel, 5u);
      }
      v9 = *v10;
      v13 = this;
      v14 = 0;
      goto LABEL_28;
    }
    if ( PanelStatus == 2 && (this->pHandling->mFlags & 0x10000000) == 0 )
    {
      m_nComponentIndex = this->BouncingPanels[0].m_nComponentIndex;
      if ( m_nComponentIndex == -1 )
      {
        BouncingPanels = this->BouncingPanels;
        if ( CarNodeIndexFromPanel > 0x12 )
          goto LABEL_32;
      }
      else
      {
        if ( CarNodeIndexFromPanel == m_nComponentIndex )
          goto LABEL_27;
        v15 = (unsigned __int16)this->BouncingPanels[1].m_nComponentIndex;
        if ( v15 == 0xFFFF )
        {
          BouncingPanels = &this->BouncingPanels[1];
          if ( CarNodeIndexFromPanel > 0x12 )
            goto LABEL_32;
        }
        else
        {
          if ( CarNodeIndexFromPanel == (__int16)v15 )
            goto LABEL_27;
          v16 = (unsigned __int16)this->BouncingPanels[2].m_nComponentIndex;
          if ( v16 == 0xFFFF )
          {
            BouncingPanels = &this->BouncingPanels[2];
            if ( CarNodeIndexFromPanel > 0x12 )
            {
LABEL_32:
              v17 = rand();
              CBouncingPanel::SetPanel(
                BouncingPanels,
                CarNodeIndexFromPanel,
                1,
                (float)((float)((float)v17 * -4.6566e-10) * 0.3) + -0.2);
              goto LABEL_13;
            }
          }
          else
          {
            if ( CarNodeIndexFromPanel == (__int16)v16 || LOWORD(this->ChassisDoor.m_fOpenAngle) != 0xFFFF )
              goto LABEL_27;
            BouncingPanels = (CBouncingPanel *)&this->ChassisDoor;
            if ( CarNodeIndexFromPanel > 0x12 )
              goto LABEL_32;
          }
        }
      }
      if ( ((1 << CarNodeIndexFromPanel) & 0x4C000) != 0 )
        goto LABEL_27;
      goto LABEL_32;
    }
  }
}

//----- (00552E3C) --------------------------------------------------------
void __fastcall CAutomobile::SetDoorDamage(CAutomobile *this, eDoors DoorID, bool bDontSpawnStuff)
{
  CDamageManager *p_Damage; // r11
  _BOOL4 v5; // r8
  unsigned __int8 DoorStatus; // r4
  int32 CarNodeIndexFromDoor; // r9
  int (***v9)(void); // r6
  bool v10; // cf
  int v11; // r0
  RwFrame_0 **v12; // r4
  float *v13; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v17; // r0
  uint32 v18; // r2
  CPhysical *v19; // r0
  CMatrix v20; // [sp+0h] [bp-80h] BYREF

  p_Damage = &this->Damage;
  v5 = bDontSpawnStuff;
  DoorStatus = CDamageManager::GetDoorStatus(&this->Damage, DoorID);
  CarNodeIndexFromDoor = CDamageManager::GetCarNodeIndexFromDoor(DoorID);
  v9 = &this->_vptr$CPlaceable + CarNodeIndexFromDoor;
  if ( v9[407] )
  {
    if ( CVehicle::CanDoorsBeDamaged(this) )
      goto LABEL_7;
    v10 = (unsigned int)DoorID >= FRONT_LEFT_DOOR_0;
    if ( (unsigned int)DoorID >= FRONT_LEFT_DOOR_0 )
      v10 = DoorStatus >= 3u;
    if ( v10 )
    {
      CDoor::Open(&this->Door[DoorID], 0.0);
      sub_19F704(p_Damage, DoorID, 2u);
    }
    else
    {
LABEL_7:
      if ( DoorID == BOOT_0 && (this->pHandling->mFlags & 0x80) != 0 )
      {
        if ( DoorStatus == 3 )
        {
          DoorStatus = 4;
        }
        else if ( DoorStatus == 1 )
        {
          DoorStatus = 4;
          if ( (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << CarNodeIndexFromDoor)) != 0 )
            DoorStatus = 2;
        }
        CDamageManager::SetDoorStatus(p_Damage, BOOT_0, DoorStatus);
      }
      v11 = DoorStatus - 1;
      v12 = (RwFrame_0 **)(v9 + 407);
      switch ( v11 )
      {
        case 0:
        case 2:
          RwFrameForAllObjects(*v12, CVehicleModelInfo::SetAtomicFlagCB, &elf_hash_bucket[193]);
          if ( DoorID == BONNET_0 )
            this->Door[0].m_fAngVel = 0.2;
          break;
        case 1:
          if ( (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << CarNodeIndexFromDoor)) != 0 )
            CVehicle::SetComponentVisibility(this, *v12, 2u);
          v13 = (float *)(&this->CPlaceable + DoorID);
          if ( v13[375] != 0.0 )
          {
            v13[374] = 0.0;
            v13[375] = 0.0;
            v13[376] = 0.0;
            CMatrix::CMatrix(&v20, &(*v12)->modelling, 0);
            tx = v20.tx;
            ty = v20.ty;
            tz = v20.tz;
            CMatrix::SetRotate(v17, 0.0, 0.0, 0.0);
            v20.tx = tx + v20.tx;
            v20.ty = ty + v20.ty;
            v20.tz = tz + v20.tz;
            CMatrix::UpdateRW(&v20);
            CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, DoorID + 84, 0.0);
            CMatrix::~CMatrix(&v20);
          }
          break;
        case 3:
          if ( !v5 )
          {
            if ( DoorID )
            {
              if ( DoorID == BOOT_0 )
                v18 = 4;
              else
                v18 = 2;
              CAutomobile::SpawnFlyingComponent(this, CarNodeIndexFromDoor, v18);
            }
            else
            {
              v19 = CAutomobile::SpawnFlyingComponent(this, CarNodeIndexFromDoor, 3u);
              CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 93, v19);
            }
          }
          sub_18B798(this, *v12, 0);
          break;
        default:
          return;
      }
    }
  }
}
// 552FA6: variable 'v17' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00553048) --------------------------------------------------------
void __fastcall CAutomobile::SetRandomDamage(CAutomobile *this, bool bLotsOfDamage)
{
  _BOOL4 v3; // r4
  float v4; // s18
  float v5; // s0
  int v6; // r9
  float v7; // s0
  int i; // r5
  int v9; // r6
  int v10; // r0
  int v11; // r1
  int v12; // r2
  bool v13; // cc
  int32 CarNodeIndexFromDoor; // r4
  int j; // r5
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int32 v20; // r6
  int32 CarNodeIndexFromPanel; // r11
  int v22; // [sp+4h] [bp-44h]
  int v23; // [sp+9h] [bp-3Fh]
  __int16 v24; // [sp+Dh] [bp-3Bh]
  char v25; // [sp+Fh] [bp-39h]
  int v26; // [sp+10h] [bp-38h]
  __int16 v27; // [sp+14h] [bp-34h]

  v26 = 0;
  v3 = bLotsOfDamage;
  v27 = 0;
  v25 = 0;
  v23 = 16842752;
  v24 = 1;
  v4 = (float)(unsigned __int16)rand() * 0.000015259;
  if ( v3 )
  {
    v5 = (float)(unsigned __int16)rand() * 0.000015259;
    v6 = (int)(float)(v4 * 6.0);
    if ( !v6 )
    {
      v22 = (int)(float)(v5 * 3.0) + 1;
      goto LABEL_21;
    }
    v7 = v5 * 4.0;
LABEL_6:
    v22 = (int)v7;
    if ( v6 >= 1 )
    {
      for ( i = 0; i != v6; ++i )
      {
        v9 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(6 - i));
        if ( i )
        {
          if ( v9 < 0 )
          {
            v9 = -1;
          }
          else
          {
            v10 = -1;
            v11 = 0;
            do
            {
              v10 += *((unsigned __int8 *)&v26 + v11) ^ 1;
              v12 = v11 + 1;
              if ( v10 >= v9 )
                break;
              v13 = v11++ - 1 < 5;
            }
            while ( v13 );
            v9 = v12 - 1;
          }
        }
        CarNodeIndexFromDoor = CDamageManager::GetCarNodeIndexFromDoor((eDoors)v9);
        if ( !CDamageManager::GetDoorStatus(&this->Damage, (eDoors)v9)
          && (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << CarNodeIndexFromDoor)) != 0 )
        {
          CDamageManager::SetDoorStatus(&this->Damage, (eDoors)v9, 2u);
          CVehicle::SetComponentVisibility(this, this->m_aCarNodes[CarNodeIndexFromDoor], 2u);
        }
        *((_BYTE *)&v26 + v9) = 1;
      }
    }
LABEL_21:
    if ( v22 < 1 )
      return;
    goto LABEL_24;
  }
  v6 = (int)v4;
  if ( (int)v4 )
  {
    v7 = (float)(unsigned __int16)rand() * 0.000015259;
    goto LABEL_6;
  }
  v22 = 1;
LABEL_24:
  for ( j = 0; j != v22; ++j )
  {
    v16 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(4 - j));
    if ( v16 < 0 )
    {
      v20 = -1;
    }
    else
    {
      v17 = -1;
      v18 = 0;
      do
      {
        v17 += *((unsigned __int8 *)&v23 + v18) ^ 1;
        v19 = v18 + 1;
        if ( v17 >= v16 )
          break;
        v13 = v18++ - 1 < 6;
      }
      while ( v13 );
      v20 = v19 - 1;
    }
    CarNodeIndexFromPanel = CDamageManager::GetCarNodeIndexFromPanel((ePanels)v20);
    if ( !CDamageManager::GetPanelStatus(&this->Damage, v20)
      && (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << CarNodeIndexFromPanel)) != 0 )
    {
      CDamageManager::SetPanelStatus(&this->Damage, v20, 1u);
      CVehicle::SetComponentVisibility(this, this->m_aCarNodes[CarNodeIndexFromPanel], 2u);
    }
    *((_BYTE *)&v23 + v20) = 1;
  }
}

//----- (005532A4) --------------------------------------------------------
void __fastcall CAutomobile::SetTotalDamage(CAutomobile *this, bool bRemoveStuff)
{
  CDamageManager *p_Damage; // r9
  _BOOL4 v4; // r8
  eDoors i; // r4
  int32 CarNodeIndexFromDoor; // r0
  char v7; // r6
  int (***v8)(void); // r0
  RwFrame_0 **v9; // r11
  RwFrame_0 *v10; // r1
  CAutomobile *v11; // r0
  uint32 v12; // r2
  int32 v13; // r4
  int32 CarNodeIndexFromPanel; // r0
  char v15; // r6
  int (***v16)(void); // r0
  RwFrame_0 **v17; // r11
  RwFrame_0 *v18; // r1
  CAutomobile *v19; // r0
  uint32 v20; // r2

  p_Damage = &this->Damage;
  v4 = bRemoveStuff;
  for ( i = BONNET_0; i != MAX_DOORS_0; ++i )
  {
    CarNodeIndexFromDoor = CDamageManager::GetCarNodeIndexFromDoor(i);
    v7 = CarNodeIndexFromDoor;
    v8 = &this->_vptr$CPlaceable + CarNodeIndexFromDoor;
    if ( !v8[407] )
      continue;
    v9 = (RwFrame_0 **)(v8 + 407);
    if ( v4 && !(int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0) )
    {
      CDamageManager::SetDoorStatus(p_Damage, i, 4u);
      v10 = *v9;
      v11 = this;
      v12 = 0;
      goto LABEL_9;
    }
    if ( !CDamageManager::GetDoorStatus(p_Damage, i)
      && (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << v7)) != 0 )
    {
      CDamageManager::SetDoorStatus(p_Damage, i, 2u);
      v10 = *v9;
      v11 = this;
      v12 = 2;
LABEL_9:
      CVehicle::SetComponentVisibility(v11, v10, v12);
      continue;
    }
  }
  v13 = 0;
  while ( 2 )
  {
    if ( (v13 & 0xFFFFFFFE) != 2 )
    {
      CarNodeIndexFromPanel = CDamageManager::GetCarNodeIndexFromPanel((ePanels)v13);
      v15 = CarNodeIndexFromPanel;
      v16 = &this->_vptr$CPlaceable + CarNodeIndexFromPanel;
      if ( v16[407] )
      {
        v17 = (RwFrame_0 **)(v16 + 407);
        if ( v4 && !(int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0) )
        {
          CDamageManager::SetPanelStatus(p_Damage, v13, 3u);
          v18 = *v17;
          v19 = this;
          v20 = 0;
LABEL_20:
          CVehicle::SetComponentVisibility(v19, v18, v20);
        }
        else if ( !CDamageManager::GetPanelStatus(p_Damage, v13)
               && (*(_DWORD *)(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex][2].m_hashKey + 808) & (1 << v15)) != 0 )
        {
          CDamageManager::SetPanelStatus(p_Damage, v13, 1u);
          v18 = *v17;
          v19 = this;
          v20 = 2;
          goto LABEL_20;
        }
      }
    }
    if ( ++v13 != 7 )
      continue;
    break;
  }
}

//----- (00553410) --------------------------------------------------------
RpMaterial_0 *__fastcall DisableMatFx(RpMaterial_0 *pMaterial, void *data)
{
  RpMatFXMaterialSetEffects(pMaterial, rpMATFXEFFECTNULL);
  return pMaterial;
}

//----- (00553420) --------------------------------------------------------
void __fastcall CAutomobile::ReduceHornCounter(CAutomobile *this)
{
  UInt32 m_cHorn; // r1

  m_cHorn = this->m_cHorn;
  if ( m_cHorn )
    this->m_cHorn = m_cHorn - 1;
}

//----- (00553430) --------------------------------------------------------
void __fastcall CAutomobile::ProcessBuoyancy(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d3
  float32x2_t v4; // d8
  float32x2_t v5; // d11
  float AmbientRed_Obj; // r8
  float m_fDirectionalLightMultiplier; // s16
  float AmbientGreen_Obj; // r6
  float v10; // s20
  float AmbientBlue_Obj; // r5
  float v12; // s18
  float v13; // s20
  unsigned __int16 v14; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  int v16; // r5
  float m_fBuoyancyConstant; // s2
  float v18; // s4
  float z; // s24
  float v20; // s6
  float v21; // s20
  float v22; // r0
  int m_nModelIndex; // r1
  float v24; // s22
  RwReal v25; // s0
  RwReal v26; // s2
  float *v27; // r4
  bool v28; // zf
  int v29; // r6
  tHandlingData *pHandling; // r1
  CPhysical::CPhysicalFlags v31; // r2
  int v32; // r6
  int v33; // r4
  float *v34; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  int v37; // r0
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r0
  CVehicle::CVehicleFlags *v39; // r5
  float v40; // s2
  int v41; // r2
  int v42; // r0
  int v43; // r1
  float m_fMass; // s4
  float v45; // s0
  CPed *pDriver; // r0
  float v47; // s0
  ePedPieceTypes v48; // s4
  float v49; // s0
  RwReal v50; // s2
  RwReal v51; // s4
  const CEventDamage *v52; // r0
  CPed **pPassengers; // r5
  int v54; // r11
  CPed *v55; // r0
  float v56; // s0
  ePedPieceTypes v57; // s4
  const CEventDamage *v58; // r0
  const CVector *vecSpeed; // [sp+20h] [bp-E0h]
  CRGBA v60; // [sp+40h] [bp-C0h] BYREF
  CEventDamage v61; // [sp+44h] [bp-BCh] BYREF
  CPedDamageResponseCalculator v62; // [sp+84h] [bp-7Ch] BYREF
  CRGBA v63; // [sp+98h] [bp-68h] BYREF
  CRGBA v64; // [sp+9Ch] [bp-64h] BYREF
  CVector v65; // [sp+A0h] [bp-60h] BYREF
  CVector pCentreOfBuoyancy; // [sp+ACh] [bp-54h] BYREF
  CVector v67; // 0:r1.12
  CVector v68; // 0:r1.12
  CVector v69; // 0:r2.8,8:^0.4

  CRGBA::CRGBA(&v64, 0, 0, 0, 0);
  AmbientRed_Obj = CTimeCycle::GetAmbientRed_Obj();
  m_fDirectionalLightMultiplier = CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier;
  AmbientGreen_Obj = CTimeCycle::GetAmbientGreen_Obj();
  v10 = CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier;
  AmbientBlue_Obj = CTimeCycle::GetAmbientBlue_Obj();
  v5.n64_u32[0] = 0.5;
  v12 = (float)(v10 * 255.0) * 0.0039062;
  v13 = (float)(CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier * 255.0) * 0.0039062;
  v14 = rand();
  CRGBA::CRGBA(
    &v63,
    (unsigned int)(float)((float)(AmbientRed_Obj
                                + (float)((float)((float)(m_fDirectionalLightMultiplier * 255.0) * 0.0039062) * 0.5))
                        * 114.75),
    (unsigned int)(float)((float)(AmbientGreen_Obj + (float)(v12 * 0.5)) * 114.75),
    (unsigned int)(float)((float)(AmbientBlue_Obj + (float)(v13 * 0.5)) * 114.75),
    (int)(float)((float)((float)v14 * 0.000015259) * 32.0) + 0x80);
  if ( cBuoyancy::ProcessBuoyancy(&mod_Buoyancy, this, this->m_fBuoyancyConstant, &pCentreOfBuoyancy, &v65) == 1 )
  {
    if ( this->m_vehicleType == 4 && this->m_vecMoveSpeed.z < -1.0 )
      (*((void (__fastcall **)(CAutomobile *, CAutomobile *, _DWORD))this->_vptr$CPlaceable + 42))(this, this, 0);
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    v16 = *(_DWORD *)&m_nPhysicalFlags | 0x8000000;
    m_fBuoyancyConstant = this->m_fBuoyancyConstant;
    v18 = this->m_fMass * 0.008;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x8000000);
    v3.n64_u32[0] = 1008981770;
    v1.n64_f32[0] = CTimer::ms_fTimeStep;
    z = v65.z;
    v20 = v65.z / (float)(v18 * vmax_f32(v1, v3).n64_f32[0]);
    if ( m_fBuoyancyConstant < v18 )
      v20 = v20 * (float)((float)(v18 * 1.05) / m_fBuoyancyConstant);
    v4.n64_u32[0] = 1.0;
    v21 = v20 * 1.5;
    if ( !(*(_DWORD *)&m_nPhysicalFlags << 31) )
      v21 = v20;
    v2.n64_f32[0] = (float)(v21 * -0.05) + 1.0;
    v22 = powf(vmax_f32(v2, v5).n64_f32[0], CTimer::ms_fTimeStep);
    m_nModelIndex = this->m_nModelIndex;
    v24 = v22;
    if ( m_nModelIndex != 539 || this->m_pMat->zz <= 0.3 || (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) != 0 )
    {
      v25 = v22 * this->m_vecTurnSpeed.y;
      v26 = v22 * this->m_vecTurnSpeed.z;
      *(float32x4_t *)&this->m_vecMoveSpeed.x = vmulq_n_f32(*(float32x4_t *)&this->m_vecMoveSpeed.x, v22);
      this->m_vecTurnSpeed.y = v25;
      this->m_vecTurnSpeed.z = v26;
    }
    v67.z = z;
    if ( (this->pHandling->mFlags & 0x2000000) != 0
      && (v27 = &this->m_aWheelAngularVelocity[1], this->m_aWheelAngularVelocity[1] > 0.15) )
    {
      v28 = m_nModelIndex == 417;
      if ( m_nModelIndex != 417 )
        v28 = m_nModelIndex == 447;
      if ( v28 )
      {
        v29 = 0;
        if ( v21 <= 3.0 )
          goto LABEL_30;
        *v27 = 0.0;
      }
      else
      {
        v1.n64_f32[0] = v21 * 8.0;
        v49 = 1.0 / vmax_f32(v1, v4).n64_f32[0];
        v68.x = v49 * (float)(v65.x * -2.0);
        v68.y = v49 * (float)(v65.y * -2.0);
        v68.z = v49 * (float)(z * -2.0);
        CPhysical::ApplyMoveForce(this, v68);
        v50 = v24 * this->m_vecTurnSpeed.y;
        v51 = v24 * this->m_vecTurnSpeed.z;
        this->m_vecTurnSpeed.x = v24 * this->m_vecTurnSpeed.x;
        this->m_vecTurnSpeed.y = v50;
        this->m_vecTurnSpeed.z = v51;
        if ( v21 <= 0.9 )
          return;
        *v27 = 0.0;
        v16 = (int)this->m_nPhysicalFlags;
        v67.z = v65.z;
      }
      v29 = 1;
    }
    else
    {
      v29 = 0;
    }
LABEL_30:
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(v16 | 0x8000000);
    v67.x = v65.x;
    v67.y = v65.y;
    CPhysical::ApplyMoveForce(this, v67);
    CPhysical::ApplyTurnForce(this, v65, pCentreOfBuoyancy);
    v37 = (unsigned __int16)this->m_nModelIndex;
    if ( v37 == 447 )
    {
      if ( v21 >= 3.0 )
      {
LABEL_37:
        if ( (CCheat::m_aCheatsActive[41] || v37 == 539)
          && *(_BYTE *)&this->m_info <= 7u
          && this->m_pMat->zz > 0.3
          && (*((_BYTE *)&this->m_nVehicleFlags + 3) & 0x40) == 0 )
        {
          p_m_nVehicleFlags = &this->m_nVehicleFlags;
          *(_DWORD *)&this->m_nPhysicalFlags &= ~0x100u;
LABEL_67:
          *(_DWORD *)p_m_nVehicleFlags &= ~0x40000000u;
          return;
        }
        if ( (v21 >= 1.0) | v29
          || v21 > 0.6
          && (this->m_aWheelRatios[0] == 1.0
           || this->m_aWheelRatios[1] == 1.0
           || this->m_aWheelRatios[2] == 1.0
           || this->m_aWheelRatios[3] == 1.0) )
        {
          v39 = &this->m_nVehicleFlags;
          v40 = this->m_vecMoveSpeed.z;
          v41 = *(_DWORD *)&this->m_nPhysicalFlags | 0x100;
          v42 = *((_DWORD *)&this->m_nVehicleFlags + 1);
          v43 = *(_DWORD *)&this->m_nVehicleFlags | 0x40000000;
          *(_DWORD *)&this->m_nVehicleFlags = v43;
          this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)v41;
          if ( v40 < -0.1 )
            this->m_vecMoveSpeed.z = -0.1;
          m_fMass = this->m_fMass;
          v45 = this->m_fBuoyancyConstant;
          if ( v45 > (float)((float)((float)(m_fMass * 0.008) * 100.0) / 125.0) )
          {
            v45 = v45 + (float)((float)(m_fMass * -0.001) * 0.008);
            this->m_fBuoyancyConstant = v45;
          }
          vecSpeed = &this->m_vecMoveSpeed;
          if ( v45 < (float)(m_fMass * 0.008) )
          {
            *(_DWORD *)v39 = v43 & 0xFFFFFFEF;
            *((_DWORD *)&this->m_nVehicleFlags + 1) = v42;
          }
          pDriver = this->pDriver;
          if ( pDriver )
          {
            *(_DWORD *)&pDriver->m_nPhysicalFlags |= 0x8000000u;
            if ( CPed::IsPlayer(this->pDriver) || (*(_BYTE *)&this->m_nAutomobileFlags & 4) == 0 )
            {
              if ( this->m_vehicleType == 2
                && this->m_aWheelRatios[0] == 1.0
                && this->m_aWheelRatios[1] == 1.0
                && this->m_aWheelRatios[2] == 1.0
                && this->m_aWheelRatios[3] == 1.0 )
              {
                v47 = -this->m_vecMoveSpeed.x;
                *(float *)&v48 = -this->m_vecMoveSpeed.z;
                v62.m_fRawDamage = -this->m_vecMoveSpeed.y;
                *(float *)&v62.m_pInflictor = v47;
                v62.m_eHitZone = v48;
                CVector::Normalise((CVector *)&v62);
                CEventKnockOffBike::CEventKnockOffBike(
                  (CEventKnockOffBike *)&v61,
                  this,
                  vecSpeed,
                  (const CVector *)&v62,
                  this->m_fMass
                * sqrtf(
                    (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                          + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                  + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)),
                  0.0,
                  WEAPONTYPE_DROWNING,
                  0,
                  0,
                  0,
                  0,
                  0);
                CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v61, 0);
                if ( CPed::IsPlayer(this->pDriver) )
                  CPlayerPed::HandlePlayerBreath((CPlayerPed *)this->pDriver, 1, 1.0);
                *(_DWORD *)v39 &= ~0x10u;
                CEventKnockOffBike::~CEventKnockOffBike((CEventKnockOffBike *)&v61);
              }
              else if ( CPed::IsPlayer(this->pDriver) )
              {
                CPlayerPed::HandlePlayerBreath((CPlayerPed *)this->pDriver, 1, 1.0);
              }
              else
              {
                CPedDamageResponseCalculator::CPedDamageResponseCalculator(
                  &v62,
                  this,
                  CTimer::ms_fTimeStep,
                  WEAPONTYPE_DROWNING,
                  PED_SPHERE_CHEST,
                  0);
                CEventDamage::CEventDamage(
                  &v61,
                  this,
                  CTimer::m_snTimeInMilliseconds,
                  WEAPONTYPE_DROWNING,
                  PED_SPHERE_CHEST,
                  0,
                  0,
                  1);
                if ( CEventDamage::AffectsPed(v52, this->pDriver) )
                  CPedDamageResponseCalculator::ComputeDamageResponse(&v62, this->pDriver, &v61.m_pedDamageResponse, 1);
                else
                  v61.m_pedDamageResponse.m_bDamageCalculated = 1;
                CEventGroup::Add(&this->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v61, 0);
                CEventDamage::~CEventDamage(&v61);
                CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v62);
              }
            }
          }
          if ( this->m_nMaxPassengers )
          {
            pPassengers = this->pPassengers;
            v54 = 0;
            do
            {
              v55 = pPassengers[v54];
              if ( v55 )
              {
                *(_DWORD *)&v55->m_nPhysicalFlags |= 0x8000000u;
                if ( CPed::IsPlayer(pPassengers[v54]) || (*(_BYTE *)&this->m_nAutomobileFlags & 4) == 0 )
                {
                  if ( this->m_vehicleType == 2
                    && this->m_aWheelRatios[0] == 1.0
                    && this->m_aWheelRatios[1] == 1.0
                    && this->m_aWheelRatios[2] == 1.0
                    && this->m_aWheelRatios[3] == 1.0 )
                  {
                    v56 = -this->m_vecMoveSpeed.x;
                    *(float *)&v57 = -this->m_vecMoveSpeed.z;
                    v62.m_fRawDamage = -this->m_vecMoveSpeed.y;
                    *(float *)&v62.m_pInflictor = v56;
                    v62.m_eHitZone = v57;
                    CVector::Normalise((CVector *)&v62);
                    CEventKnockOffBike::CEventKnockOffBike(
                      (CEventKnockOffBike *)&v61,
                      this,
                      vecSpeed,
                      (const CVector *)&v62,
                      this->m_fMass
                    * sqrtf(
                        (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                              + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                      + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)),
                      0.0,
                      WEAPONTYPE_DROWNING,
                      0,
                      0,
                      0,
                      0,
                      0);
                    CEventGroup::Add(&pPassengers[v54]->m_pPedIntelligence->m_eventGroup, (CEvent *)&v61, 0);
                    if ( CPed::IsPlayer(pPassengers[v54]) )
                      CPlayerPed::HandlePlayerBreath((CPlayerPed *)pPassengers[v54], 1, 1.0);
                    CEventKnockOffBike::~CEventKnockOffBike((CEventKnockOffBike *)&v61);
                  }
                  else if ( CPed::IsPlayer(pPassengers[v54]) )
                  {
                    CPlayerPed::HandlePlayerBreath((CPlayerPed *)pPassengers[v54], 1, 1.0);
                  }
                  else
                  {
                    CPedDamageResponseCalculator::CPedDamageResponseCalculator(
                      &v62,
                      this,
                      CTimer::ms_fTimeStep,
                      WEAPONTYPE_DROWNING,
                      PED_SPHERE_CHEST,
                      0);
                    CEventDamage::CEventDamage(
                      &v61,
                      this,
                      CTimer::m_snTimeInMilliseconds,
                      WEAPONTYPE_DROWNING,
                      PED_SPHERE_CHEST,
                      0,
                      0,
                      1);
                    if ( CEventDamage::AffectsPed(v58, pPassengers[v54]) )
                      CPedDamageResponseCalculator::ComputeDamageResponse(
                        &v62,
                        pPassengers[v54],
                        &v61.m_pedDamageResponse,
                        1);
                    else
                      v61.m_pedDamageResponse.m_bDamageCalculated = 1;
                    CEventGroup::Add(&pPassengers[v54]->m_pPedIntelligence->m_eventGroup, (CEvent *)&v61, 0);
                    CEventDamage::~CEventDamage(&v61);
                    CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v62);
                  }
                }
              }
              ++v54;
            }
            while ( v54 < this->m_nMaxPassengers );
          }
          return;
        }
LABEL_66:
        *(_DWORD *)&this->m_nPhysicalFlags &= ~0x100u;
        p_m_nVehicleFlags = &this->m_nVehicleFlags;
        goto LABEL_67;
      }
    }
    else if ( v21 >= 3.0 || v37 != 417 )
    {
      goto LABEL_37;
    }
    if ( v21 < 0.6 || this->m_pMat->zz > -0.5 )
      goto LABEL_66;
    goto LABEL_37;
  }
  pHandling = this->pHandling;
  v31 = this->m_nPhysicalFlags;
  *(_DWORD *)&this->m_nVehicleFlags &= ~0x40000000u;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v31 & 0xF7FFFEFF);
  this->m_fBuoyancyConstant = pHandling->fBuoyancyConstant;
  CRGBA::CRGBA((CRGBA *)&v62, 0x9Bu, 0x9Bu, 0xB9u, 0xC4u);
  CRGBA::CRGBA(&v60, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  v32 = 2024;
  v33 = 0;
  do
  {
    if ( *(float *)((char *)&this->_vptr$CPlaceable + v32) < 1.0 )
    {
      v34 = (float *)((char *)this + v33 * 44);
      if ( SurfaceInfos_c::IsWater(&g_surfaceInfos, this->m_aWheelColPoints[v33].m_dataB.m_nSurfaceType) )
      {
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        v69.x = (float)((float)(m_pMat->xz * 0.3) + v34[462]) - p_tx->m_translate.x;
        v69.y = (float)((float)(m_pMat->yz * 0.3) + v34[463]) - p_tx->m_translate.y;
        v69.z = (float)((float)(m_pMat->zz * 0.3) + v34[464]) - p_tx->m_translate.z;
        CPhysical::GetSpeed((CVector *)&v61, this, v69);
      }
    }
    v32 += 4;
    ++v33;
  }
  while ( v32 != 2040 );
}
// 553592: variable 'v1' is possibly undefined
// 553592: variable 'v3' is possibly undefined
// 5535DC: variable 'v2' is possibly undefined
// 5535DC: variable 'v5' is possibly undefined
// 553B2C: variable 'v4' is possibly undefined
// 553BCE: variable 'v52' is possibly undefined
// 553DC2: variable 'v58' is possibly undefined

//----- (00553E44) --------------------------------------------------------
void __fastcall CAutomobile::ProcessControl(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d8
  unsigned __int64 v5; // d10
  CAutomobile *v6; // r4
  int v7; // r5
  CCollisionData *m_pColData; // r6
  int m_nVehicleFlags; // r1
  int v10; // r2
  CAutomobile::CAutomobileFlags v11; // r0
  int m_nModelIndex; // r0
  bool v13; // zf
  unsigned int m_info; // r1
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  bool8 v16; // r11
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r10
  bool v18; // zf
  bool v19; // zf
  uint32 hFlagsLocal; // r0
  int v21; // r1
  int v22; // r2
  CEntity *pBombOwner; // r0
  unsigned int v24; // r0
  CEntity::CEntityInfo v25; // r0
  _BOOL4 v26; // r9
  int v27; // r8
  CEntity *m_pDamageEntity; // r0
  float v29; // s2
  float v30; // s0
  int v31; // r0
  float *v32; // r1
  unsigned __int32 *v33; // r2
  float *v34; // r3
  float32x4_t v35; // q9
  float32x4_t v36; // q2
  float v37; // s6
  float v38; // s12
  CEntity *v39; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v43; // d16
  uint8 *p_m_nNoOfStaticFrames; // r6
  CMatrix *v45; // r0
  float *p_x; // r1
  int v47; // r8
  int v48; // r0
  bool v49; // zf
  CPhysical *v50; // r1
  int v51; // r0
  CPhysical *v52; // r1
  CPhysical *v53; // r1
  CPhysical *v54; // r2
  int v55; // r1
  unsigned int v56; // r0
  int v57; // r1
  bool v58; // zf
  char v59; // r1
  bool v60; // zf
  FxSystem_c *m_pFxSysNitro1; // r0
  FxSystem_c *m_pFxSysNitro2; // r0
  int m_nFlags; // r5
  int v64; // r8
  int v65; // r0
  CPad *v66; // r0
  char v67; // r0
  int v68; // r4
  tBoatHandlingData *BoatPointer; // r0
  CPhysical::CPhysicalFlags v70; // r0
  unsigned int v71; // r1
  const CPed *z_low; // r0
  CPad *Pad; // r0
  int v74; // r5
  CEntryInfoList *p_m_listEntryInfo; // r4
  const CPed *m_pHead; // r0
  float v77; // s8
  float v78; // s2
  float v79; // s6
  float v80; // s0
  RwReal v81; // s6
  float v82; // s16
  int v83; // r6
  int v84; // r3
  int v85; // r11
  int v86; // r10
  int v87; // r5
  int v88; // r4
  float *v89; // r6
  eSkidmarkType SkidmarkType; // r0
  CMatrix *v91; // r0
  float *v92; // r2
  RwReal v93; // s0
  CVector *v94; // r0
  RwReal v95; // s4
  int v96; // r3
  int v97; // r8
  __int64 v98; // d16
  CVector *v99; // r1
  int v100; // r8
  CVector *v101; // r6
  RwReal *v102; // r0
  int v103; // r9
  __int64 v104; // d16
  __int64 v105; // d16
  int v106; // r6
  int i; // r4
  __int64 v108; // d16
  CVector *v109; // r5
  CPhysical *v110; // r1
  RwReal v111; // s2
  RwReal v112; // s4
  CPhysical *v113; // r4
  float v114; // s0
  RwReal x; // r0
  unsigned int v116; // r1
  int v117; // r0
  uint8 v118; // r0
  uint32 v119; // r0
  float *p_xx; // r0
  float v121; // s0
  RwReal v122; // r0
  float *p_m_fElasticity; // r8
  float v124; // s20
  char v125; // r2
  float z; // s0
  float v127; // s22
  float v128; // s18
  float v129; // s0
  char v130; // r2
  int v131; // r1
  unsigned __int8 v132; // r1
  float *p_m_fBuoyancyConstant; // r6
  float v134; // s0
  int v135; // r3
  bool v136; // zf
  float *v137; // r3
  float v138; // s0
  int v139; // r3
  bool v140; // zf
  float *p_y; // r3
  float v142; // s0
  int v143; // r2
  bool v144; // zf
  uint8 nFasterCheat; // r2
  bool8 v146; // r2
  float v147; // s24
  float v148; // s2
  float v149; // s0
  float v150; // s26
  bool v151; // zf
  float v152; // s20
  CMatrix *v153; // r1
  float v154; // s22
  float y; // s28
  float xx; // s19
  float zx; // s23
  float v158; // s30
  float AdhesiveLimit; // r0
  float v160; // r0
  float v161; // s4
  float v162; // s2
  CAutomobile *v163; // r6
  float *v164; // r4
  float v165; // s18
  uint32 v166; // r0
  int v167; // r5
  float v168; // s0
  int v169; // s2
  float v170; // s0
  CPhysical *v171; // r6
  float v172; // s0
  unsigned int v173; // r0
  bool v174; // r1
  int y_low; // r1
  bool v176; // zf
  CEntity *m_pLod; // r0
  int v178; // r0
  bool v179; // zf
  float v180; // s24
  float32x2_t v181; // d11
  int32 v182; // r6
  int v183; // r10
  int v184; // r11
  float v185; // s26
  float *v186; // r5
  float *v187; // r8
  float v188; // s0
  float v189; // s21
  float *v190; // r0
  float v191; // s2
  float v192; // s26
  float v193; // s20
  float *v194; // r0
  float v195; // s28
  float v196; // r0
  float v197; // s0
  float v198; // s0
  float v199; // s0
  float v200; // s2
  unsigned int v201; // r8
  CPad *v202; // r0
  unsigned int v203; // r0
  int m_fTrueDistanceTravelled_high; // r1
  int v205; // r1
  const CPed *v206; // r0
  CPad *PadFromPlayer; // r5
  const CMatrix *v208; // r5
  float m_fTurnMass; // s22
  float v210; // s24
  float v211; // s26
  float v212; // s28
  float v213; // r6
  float xy; // s30
  float yy; // s17
  float zy; // s19
  float xz; // s21
  float yz; // s23
  float zz; // s25
  float v220; // s24
  float v221; // r0
  float v222; // s0
  CVehicle *x_low; // r0
  int v224; // r4
  CPhysical *v225; // r6
  CVehicle *v226; // r0
  RwReal v227; // r0
  float *v228; // r8
  CPlayerPed *v229; // r4
  CEntryInfoNode *v230; // r0
  float *v231; // r0
  int v232; // r0
  bool v233; // zf
  float *v234; // r0
  float m_fMass; // s0
  float v236; // s18
  CMatrix *v237; // r0
  CSimpleTransform *v238; // r1
  __int64 v239; // kr18_8
  float v240; // s22
  float v241; // s0
  CMatrix *v242; // r0
  float v243; // s0
  float *p_tz; // r0
  int v245; // r0
  CVector bBoatGrounded; // [sp+0h] [bp-140h]
  CVector bBoatGroundeda; // [sp+0h] [bp-140h]
  CVector *p_m_vecMoveSpeed; // [sp+1Ch] [bp-124h]
  int v249; // [sp+20h] [bp-120h]
  CVehicle::CVehicleFlags *v250; // [sp+24h] [bp-11Ch]
  bool8 v251; // [sp+2Ch] [bp-114h]
  CDamageManager *v252; // [sp+38h] [bp-108h]
  int v253; // [sp+3Ch] [bp-104h]
  int v254; // [sp+40h] [bp-100h]
  float *p_m_fGasPedal; // [sp+40h] [bp-100h]
  CPhysical *v256; // [sp+44h] [bp-FCh]
  CColPoint v257; // [sp+48h] [bp-F8h] BYREF
  float v; // [sp+74h] [bp-CCh] BYREF
  CVector aWheelOffsets[4]; // [sp+78h] [bp-C8h] BYREF
  CVector aWheelSpeeds[4]; // [sp+A8h] [bp-98h] BYREF
  int v261[25]; // [sp+DCh] [bp-64h] BYREF
  CVector v262; // 0:r1.12
  CVector v263; // 0:r1.12

  v6 = this;
  v7 = (*((_DWORD *)&this->m_nVehicleFlags + 1) >> 25) & 1;
  v261[0] = v7;
  m_pColData = CEntity::GetColModel(this)->m_pColData;
  m_nVehicleFlags = (int)v6->m_nVehicleFlags;
  v10 = *((_DWORD *)&v6->m_nVehicleFlags + 1);
  v11 = (CAutomobile::CAutomobileFlags)(*(_BYTE *)&v6->m_nAutomobileFlags & 0xBF);
  v6->nBrakesOn = 0;
  *(_DWORD *)&v6->m_nVehicleFlags = m_nVehicleFlags & 0xFFFFDFFF;
  *((_DWORD *)&v6->m_nVehicleFlags + 1) = v10 & 0xFFFFFFFD;
  v6->m_nAutomobileFlags = v11;
  CAEVehicleAudioEntity::Service(&v6->m_VehicleAudioEntity);
  m_nModelIndex = v6->m_nModelIndex;
  v13 = m_nModelIndex == 420;
  if ( m_nModelIndex != 420 )
    v13 = m_nModelIndex == 438;
  if ( !v13 && v6->m_pMat->zz < 0.0 )
    *(_BYTE *)&v6->m_nAutomobileFlags &= ~1u;
  if ( (unsigned int)(v6->m_vehicleType - 3) > 1 )
    goto LABEL_27;
  m_info = (unsigned __int8)v6->m_info;
  if ( (unsigned __int8)(v6->AutoPilot.Mission - 57) < 2u )
  {
    if ( (m_info & 0xF8) != 40 )
      goto LABEL_9;
LABEL_27:
    v16 = 0;
    goto LABEL_28;
  }
  if ( m_info > 7 || v6->m_nHealth >= 250.0 )
    goto LABEL_27;
  v16 = 0;
  if ( v6->m_statusWhenEngineBlown != 2 )
    goto LABEL_28;
LABEL_9:
  if ( v6->m_fDamageImpulseMagnitude <= 0.0 || v6->m_vecDamageNormal.z <= 0.0 )
  {
    m_nPhysicalFlags = v6->m_nPhysicalFlags;
    if ( (*(_WORD *)&m_nPhysicalFlags & 0x2000) != 0
      || (*(_WORD *)&m_nPhysicalFlags & 0x100) == 0
      && v6->m_aWheelRatios[0] >= 1.0
      && v6->m_aWheelRatios[1] >= 1.0
      && v6->m_aWheelRatios[2] >= 1.0
      && v6->m_aWheelRatios[3] >= 1.0
      && (v6->m_vecMoveSpeed.x != 0.0 || v6->m_vecMoveSpeed.y != 0.0 || v6->m_vecMoveSpeed.z != 0.0) )
    {
      goto LABEL_27;
    }
  }
  if ( v6->m_vecMoveSpeed.z < 0.0 && !(*((unsigned __int8 *)&v6->m_nPhysicalFlags + 1) << 31) )
    goto LABEL_27;
  v16 = 1;
LABEL_28:
  p_m_nVehicleFlags = &v6->m_nVehicleFlags;
  if ( CCheat::m_aCheatsActive[99] && *(_BYTE *)&v6->m_info <= 7u )
  {
    v18 = m_nModelIndex == 438;
    if ( m_nModelIndex != 438 )
      v18 = m_nModelIndex == 420;
    if ( v18 )
    {
      v7 |= 0x10u;
      v261[0] = v7;
    }
  }
  v19 = CCheat::m_aCheatsActive[61] == 0;
  if ( !CCheat::m_aCheatsActive[61] )
    v19 = (v7 & 0x10) == 0;
  if ( !v19 )
  {
    hFlagsLocal = v6->hFlagsLocal;
    v6->m_nNitroBoosts = 101;
    v6->hFlagsLocal = hFlagsLocal | 0x80000;
  }
  if ( (*((_BYTE *)&v6->m_nVehicleFlags + 1) & 2) != 0 )
    CAutomobile::ProcessAutoBusDoors(v6);
  CVehicle::ProcessCarAlarm(v6);
  CVehicle::UpdateClumpAlpha(v6);
  CVehicle::UpdatePassengerList(v6);
  v22 = *((_DWORD *)&v6->m_nVehicleFlags + 1);
  v21 = *(_DWORD *)p_m_nVehicleFlags;
  if ( v6->pDriver )
  {
    if ( (v22 & 0x20) == 0 && (*((_BYTE *)&v6->CVehicle + 1202) & 7) == 5 )
    {
      v6->DelayedExplosion = 1000;
      pBombOwner = v6->pBombOwner;
      v6->pDelayedExplosionInflictor = pBombOwner;
      if ( pBombOwner )
      {
        CEntity::RegisterReference(pBombOwner, &v6->pDelayedExplosionInflictor);
        v22 = *((_DWORD *)&v6->m_nVehicleFlags + 1);
        v21 = *(_DWORD *)p_m_nVehicleFlags;
      }
    }
    v24 = v22 | 0x20;
  }
  else
  {
    v24 = v22 & 0xFFFFFFDF;
  }
  *(_DWORD *)p_m_nVehicleFlags = v21;
  *((_DWORD *)&v6->m_nVehicleFlags + 1) = v24;
  if ( v6->m_nNumPassengers && CVehicle::IsUpsideDown(v6) )
    CVehicle::CanPedEnterCar(v6);
  if ( (*((int (__fastcall **)(CAutomobile *, int *))v6->_vptr$CPlaceable + 67))(v6, v261) )
    return;
  v25 = v6->m_info;
  v252 = (CDamageManager *)m_pColData;
  if ( (*(_BYTE *)&v25 & 0xF0) != 32 )
  {
    v27 = 0;
    goto LABEL_114;
  }
  v26 = !(*((unsigned __int8 *)&v6->m_nVehicleFlags + 3) << 31)
     && v6->m_vecMoveSpeed.x == 0.0
     && v6->m_vecMoveSpeed.y == 0.0
     && v6->m_vecMoveSpeed.z == 0.0
     && v6->m_aRatioHistory[3] != 1.0;
  if ( v6->m_vehicleType == 4 )
  {
    if ( v6->m_fDamageImpulseMagnitude > 0.0
      && (m_pDamageEntity = v6->m_pDamageEntity) != 0
      && (*(_BYTE *)&m_pDamageEntity->m_info & 7) == 2 )
    {
      v29 = 0.003;
      v30 = 0.1;
      v3.n64_u32[0] = 994352038;
    }
    else
    {
      v3.n64_u32[0] = 1007908028;
      v29 = 0.003;
      v30 = 0.1;
    }
  }
  else
  {
    v31 = *(_BYTE *)&v25 & 0xF8;
    v32 = (float *)&unk_554304;
    v33 = (unsigned __int32 *)&loc_55430C;
    if ( v31 == 40 )
    {
      v32 = (float *)&loc_554308;
      v33 = (unsigned __int32 *)&loc_554310;
    }
    v34 = (float *)&loc_554314;
    if ( v31 == 40 )
      v34 = (float *)&loc_554318;
    v3.n64_u32[0] = *v33;
    v29 = *v32;
    v30 = *v34;
  }
  v35.n128_u64[0] = 0x3F0000003F000000LL;
  v35.n128_u64[1] = 0x3F0000003F000000LL;
  v36 = vmulq_f32(vaddq_f32(*(float32x4_t *)&v6->m_vecAverageMoveSpeed.x, *(float32x4_t *)&v6->m_vecMoveSpeed.x), v35);
  v37 = (float)(v6->m_vecAverageTurnSpeed.z + v6->m_vecTurnSpeed.z) * 0.5;
  v38 = (float)(v6->m_vecAverageTurnSpeed.y + v6->m_vecTurnSpeed.y) * 0.5;
  *(float32x4_t *)&v6->m_vecAverageMoveSpeed.x = v36;
  v2.n64_f32[1] = v36.n128_f32[0] * v36.n128_f32[0];
  v3.n64_f32[1] = v36.n128_f32[2] * v36.n128_f32[2];
  v6->m_vecAverageTurnSpeed.y = v38;
  v6->m_vecAverageTurnSpeed.z = v37;
  v1.n64_f32[1] = (float)((float)(v36.n128_f32[0] * v36.n128_f32[0]) + (float)(v36.n128_f32[1] * v36.n128_f32[1]))
                + (float)(v36.n128_f32[2] * v36.n128_f32[2]);
  if ( v1.n64_f32[1] > (float)((float)(v3.n64_f32[0] * CTimer::ms_fTimeStep)
                             * (float)(v3.n64_f32[0] * CTimer::ms_fTimeStep)) )
    goto LABEL_83;
  if ( (float)((float)((float)(v36.n128_f32[3] * v36.n128_f32[3]) + (float)(v38 * v38)) + (float)(v37 * v37)) > (float)((float)(v29 * CTimer::ms_fTimeStep) * (float)(v29 * CTimer::ms_fTimeStep)) )
    goto LABEL_83;
  if ( v6->m_fTrueDistanceTravelled >= v30 )
    goto LABEL_83;
  if ( v6->m_fDamageImpulseMagnitude > 0.0 )
  {
    v39 = v6->m_pDamageEntity;
    if ( v39 )
    {
      if ( (*(_BYTE *)&v39->m_info & 7) == 3 )
        goto LABEL_83;
    }
  }
  if ( !(*((unsigned __int8 *)&v6->m_nPhysicalFlags + 1) << 31) )
    goto LABEL_223;
  m_pMat = v6->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &v6->m_transform;
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  v43.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
  v2.n64_u64[0] = vmul_f32(v43, v43).n64_u64[0];
  if ( (float)((float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                             * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                     + v2.n64_f32[0])
             + v2.n64_f32[1]) < 2500.0 )
  {
LABEL_83:
    p_m_nNoOfStaticFrames = &v6->m_nNoOfStaticFrames;
    if ( v26 )
    {
      ++*p_m_nNoOfStaticFrames;
LABEL_85:
      v45 = v6->m_pMat;
      p_x = &v45->tx;
      if ( !v45 )
        p_x = &v6->m_transform.m_translate.x;
      if ( CCarCtrl::MapCouldMoveInThisArea(*p_x, p_x[1]) )
      {
        v47 = 0;
      }
      else
      {
        if ( !v26 || *p_m_nNoOfStaticFrames >= 0xBu )
          *p_m_nNoOfStaticFrames = 10;
        v6->m_vecTurnSpeed.z = 0.0;
        v47 = 1;
        *(_QWORD *)&v6->m_vecMoveSpeed.x = 0LL;
        *(_QWORD *)&v6->m_vecMoveSpeed.z = 0LL;
        v6->m_vecTurnSpeed.y = 0.0;
      }
      goto LABEL_94;
    }
    v47 = 0;
    *p_m_nNoOfStaticFrames = 0;
  }
  else
  {
LABEL_223:
    v47 = 0;
    p_m_nNoOfStaticFrames = &v6->m_nNoOfStaticFrames;
    v118 = v6->m_nNoOfStaticFrames + 1;
    v6->m_nNoOfStaticFrames = v118;
    if ( v118 > 0xAu || v26 )
      goto LABEL_85;
  }
LABEL_94:
  if ( (v6->pHandling->mFlags & 0x2000000) != 0 && v6->m_aWheelAngularVelocity[1] > 0.0 )
    goto LABEL_112;
  v48 = v6->m_nModelIndex;
  v49 = v48 == 447;
  if ( v48 != 447 )
    v49 = v48 == 417;
  if ( v49 && !v6->nNoOfContactWheels && v6->m_fDamageImpulseMagnitude <= 0.0
    || ((unsigned __int16)v48 == 539 || CCheat::m_aCheatsActive[41])
    && (v6->m_aWheelRatios[0] < 1.0 && v6->m_aWheelColPoints[0].m_dataB.m_nSurfaceType == 39
     || v6->m_aWheelRatios[1] < 1.0 && v6->m_aWheelColPoints[1].m_dataB.m_nSurfaceType == 39
     || v6->m_aWheelRatios[2] < 1.0 && v6->m_aWheelColPoints[2].m_dataB.m_nSurfaceType == 39
     || v6->m_aWheelRatios[3] < 1.0 && v6->m_aWheelColPoints[3].m_dataB.m_nSurfaceType == 39) )
  {
LABEL_112:
    v47 = 0;
    *p_m_nNoOfStaticFrames = 0;
  }
  v27 = v47 != 0;
LABEL_114:
  v50 = v6->m_aGroundPhysicalPtrs[0];
  v51 = CWorld::bForceProcessControl;
  if ( v50 )
  {
    *((_DWORD *)&v6->m_nVehicleFlags + 1) |= 2u;
    if ( !v51 && (*(_BYTE *)&v50->m_nFlags & 0x20) != 0 )
      goto LABEL_137;
  }
  v52 = v6->m_aGroundPhysicalPtrs[1];
  if ( v52 )
  {
    *((_DWORD *)&v6->m_nVehicleFlags + 1) |= 2u;
    if ( !v51 && (*(_BYTE *)&v52->m_nFlags & 0x20) != 0 )
      goto LABEL_137;
  }
  if ( (v53 = v6->m_aGroundPhysicalPtrs[2]) != 0
    && (*((_DWORD *)&v6->m_nVehicleFlags + 1) |= 2u, !v51)
    && (*(_BYTE *)&v53->m_nFlags & 0x20) != 0
    || (v54 = v6->m_aGroundPhysicalPtrs[3], v55 = *((_DWORD *)&v6->m_nVehicleFlags + 1), v54)
    && (v55 |= 2u,
        *(_DWORD *)p_m_nVehicleFlags = *(_DWORD *)p_m_nVehicleFlags,
        *((_DWORD *)&v6->m_nVehicleFlags + 1) = v55,
        !v51)
    && (*(_BYTE *)&v54->m_nFlags & 0x20) != 0 )
  {
LABEL_137:
    *(_DWORD *)&v6->m_nFlags |= 0x40u;
    return;
  }
  if ( (v55 & 2) != 0 )
  {
    v27 = 0;
    v6->m_nNoOfStaticFrames = 0;
  }
  (*((void (__fastcall **)(CAutomobile *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int))v6->_vptr$CPlaceable + 57))(
    v6,
    0,
    0,
    0,
    0,
    0,
    49);
  v56 = (unsigned __int8)v6->m_info;
  v57 = v6->m_nModelIndex;
  if ( v56 <= 7 )
  {
    v58 = v57 == 601;
    if ( v57 != 601 )
      v58 = v57 == 407;
    if ( v58 )
    {
      CAutomobile::FireTruckControl(v6, 0);
      goto LABEL_155;
    }
  }
  if ( v57 < 486 )
  {
    switch ( v57 )
    {
      case 406:
        goto LABEL_154;
      case 432:
LABEL_149:
        CAutomobile::TankControl(v6);
        goto LABEL_155;
      case 443:
LABEL_154:
        v27 &= !CAutomobile::UpdateMovingCollision(v6, -1.0);
        goto LABEL_155;
    }
LABEL_141:
    if ( (v6->hFlagsLocal & 0x20000) != 0 )
    {
      v59 = v261[0];
    }
    else if ( v56 > 7 || (v59 = v261[0], (v261[0] & 0x10) == 0) )
    {
      if ( CCheat::m_aCheatsActive[35]
        && v56 <= 7
        && (float)((float)((float)(v6->m_vecMoveSpeed.x * v6->m_vecMoveSpeed.x)
                         + (float)(v6->m_vecMoveSpeed.y * v6->m_vecMoveSpeed.y))
                 + (float)(v6->m_vecMoveSpeed.z * v6->m_vecMoveSpeed.z)) > 0.04 )
      {
        CAutomobile::BoostJumpControl(v6);
      }
      goto LABEL_155;
    }
    if ( (v59 & 0x10) != 0 )
    {
      CAutomobile::BoostJumpControl(v6);
      v119 = v6->hFlagsLocal;
      if ( (v119 & 0x20000) == 0 )
        v6->hFlagsLocal = v119 | 0x20000;
    }
    CAutomobile::HydraulicControl(v6);
  }
  else
  {
    switch ( v6->m_nModelIndex )
    {
      case 0x20C:
      case 0x212:
        goto LABEL_154;
      case 0x20D:
      case 0x213:
        CAutomobile::TowTruckControl(v6);
        break;
      case 0x20E:
      case 0x20F:
      case 0x210:
      case 0x211:
      case 0x214:
      case 0x215:
      case 0x216:
      case 0x217:
      case 0x218:
      case 0x219:
      case 0x21A:
      case 0x21B:
      case 0x21C:
      case 0x21D:
      case 0x21E:
      case 0x21F:
      case 0x220:
      case 0x221:
      case 0x222:
      case 0x223:
      case 0x224:
      case 0x225:
      case 0x226:
      case 0x227:
      case 0x228:
      case 0x229:
      case 0x22A:
      case 0x22B:
      case 0x22C:
      case 0x22D:
      case 0x22E:
      case 0x22F:
      case 0x230:
      case 0x231:
      case 0x232:
      case 0x233:
        goto LABEL_141;
      case 0x234:
        goto LABEL_149;
      default:
        v60 = v57 == 486;
        if ( v57 != 486 )
          v60 = v57 == 592;
        if ( !v60 )
          goto LABEL_141;
        goto LABEL_154;
    }
  }
LABEL_155:
  if ( (v6->hFlagsLocal & 0x80000) != 0 )
  {
    CAutomobile::NitrousControl(v6, 0);
  }
  else
  {
    m_pFxSysNitro1 = v6->m_pFxSysNitro1;
    if ( m_pFxSysNitro1 )
    {
      FxSystem_c::Kill(m_pFxSysNitro1);
      v6->m_pFxSysNitro1 = 0;
    }
    m_pFxSysNitro2 = v6->m_pFxSysNitro2;
    if ( m_pFxSysNitro2 )
    {
      FxSystem_c::Kill(m_pFxSysNitro2);
      v6->m_pFxSysNitro2 = 0;
    }
  }
  v256 = v6;
  if ( FindPlayerVehicle(-1, 0) == v6 )
  {
    v65 = *((_BYTE *)&v6->CVehicle + 1202) & 7;
    if ( v65 == 2 )
    {
      Pad = CPad::GetPad(0);
      if ( !CPad::UseBomb(Pad) )
        goto LABEL_162;
      *((_BYTE *)&v6->CVehicle + 1202) = *((_BYTE *)&v6->CVehicle + 1202) & 0xF8 | 5;
    }
    else
    {
      if ( v65 != 1 )
        goto LABEL_162;
      v66 = CPad::GetPad(0);
      if ( !CPad::UseBomb(v66) )
        goto LABEL_162;
      v67 = *((_BYTE *)&v6->CVehicle + 1202);
      v6->DelayedExplosion = 7000;
      *((_BYTE *)&v6->CVehicle + 1202) = v67 & 0xF8 | 4;
      v6->pDelayedExplosionInflictor = FindPlayerPed(-1);
    }
    CGarages::TriggerMessage("GA_12", -1, 0xBB8u, -1);
  }
LABEL_162:
  v249 = v27;
  v250 = &v6->m_nVehicleFlags;
  if ( v27 != 1 )
  {
    if ( !(*((unsigned __int8 *)&v6->m_nVehicleFlags + 3) << 31) )
      (*((void (__fastcall **)(CAutomobile *, int))v6->_vptr$CPlaceable + 24))(v6, 1);
    m_nFlags = (int)v6->m_nFlags;
    v64 = v6->m_fDamageImpulseMagnitude > 0.0 && v6->m_vecDamageNormal.z > 0.1;
    v68 = *(_DWORD *)&v6->m_nPhysicalFlags & 0x100;
    CPhysical::ProcessControl(v256);
    if ( v256->m_nModelIndex == 460 )
    {
      BoatPointer = cHandlingDataMgr::GetBoatPointer(
                      &mod_HandlingManager,
                      *((_BYTE *)&CModelInfo::ms_modelInfoPtrs[460][1].m_flags + 2));
      CVehicle::ProcessBoatControl(
        (CVehicle *)v256,
        BoatPointer,
        (float *)&v256[7].m_nNoOfStaticFrames,
        (m_nFlags & 0x1000) != 0,
        v64);
      v70 = v256->m_nPhysicalFlags;
      v71 = *(_DWORD *)&v70 & 0xF7FFFFFF;
      if ( (*(_WORD *)&v70 & 0x100) != 0 )
        v71 = *(_DWORD *)&v70 | 0x8000000;
      v256->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)v71;
      if ( v68 )
      {
LABEL_192:
        if ( v256->m_nModelIndex == 464 )
          (*((void (__fastcall **)(CPhysical *))v256->_vptr$CPlaceable + 69))(v256);
        v251 = v16;
        if ( SLOBYTE(v256[6].m_vecAttachTiltOffset.y) >= 0 )
        {
          v77 = 1.0 - (float)(v256[6].m_AttachQuat.imag.z / v256[6].m_lightingFromPointLights);
          v78 = 1.0 - (float)(v256[6].m_AttachQuat.real / *(float *)&v256[6].m_pRealTimeShadow);
          v79 = 1.0 - (float)(*(float *)&v256[6].m_pNOCollisionVehicle / *(float *)&v256[7]._vptr$CPlaceable);
          v80 = 1.0 - (float)(v256[6].m_lightingFromCollision / v256[7].m_transform.m_translate.x);
          v2.n64_f32[1] = 1.0 - v78;
          v1.n64_f32[1] = 1.0 - v79;
          v2.n64_f32[0] = (float)(v256[6].m_vecAverageTurnSpeed.x - v78) / (float)(1.0 - v78);
          v81 = (float)(v256[6].m_vecAverageTurnSpeed.y - v79) / (float)(1.0 - v79);
          v1.n64_f32[0] = (float)(v256[6].m_vecAverageTurnSpeed.z - v80) / (float)(1.0 - v80);
          v256[6].m_vecAverageMoveSpeed.z = (float)(v256[6].m_vecAverageMoveSpeed.z - v77) / (float)(1.0 - v77);
          LODWORD(v256[6].m_vecAverageTurnSpeed.x) = v2.n64_u32[0];
          v256[6].m_vecAverageTurnSpeed.y = v81;
          LODWORD(v256[6].m_vecAverageTurnSpeed.z) = v1.n64_u32[0];
        }
        (*((void (__fastcall **)(CPhysical *))v256->_vptr$CPlaceable + 71))(v256);
        v82 = 1.0;
        v83 = 2104;
        v84 = 16;
        v85 = 0;
        v86 = 0;
        v87 = 0;
        v88 = 0;
        do
        {
          if ( *(float *)((char *)&v256[6].m_vecAverageMoveSpeed.z + v87) >= 1.0 )
          {
            if ( v252->m_Wheel[2] << 31 )
            {
              v100 = v83;
              v101 = &aWheelOffsets[v88];
              v102 = (RwReal *)(v252->m_Lights + v86);
              v103 = v84;
              v104 = *(_QWORD *)v102;
              v101->z = v102[2];
              *(_QWORD *)&v101->x = v104;
              v101->z = aWheelOffsets[v88].z - *(float *)(v252->m_Lights + v86 + 12);
              Multiply3x3(aWheelSpeeds, v256->m_pMat, &aWheelOffsets[v88]);
              v105 = *(_QWORD *)&aWheelSpeeds[0].x;
              v96 = v103;
              v101->z = aWheelSpeeds[0].z;
              *(_QWORD *)&v101->x = v105;
              v83 = v100;
            }
            else
            {
              v97 = v84;
              Multiply3x3(aWheelSpeeds, v256->m_pMat, (const CVector *)(v252->m_Lights + v84));
              v98 = *(_QWORD *)&aWheelSpeeds[0].x;
              v99 = &aWheelOffsets[v88];
              v96 = v97;
              v99->z = aWheelSpeeds[0].z;
              *(_QWORD *)&v99->x = v98;
            }
          }
          else
          {
            v253 = v84;
            v254 = v83;
            *((_BYTE *)&v256->_vptr$CPlaceable + v83) = 0;
            v89 = (float *)((char *)v256 + v85);
            SkidmarkType = SurfaceInfos_c::GetSkidmarkType(
                             &g_surfaceInfos,
                             *((unsigned __int8 *)&v256[5].m_pNOCollisionVehicle + v85 + 3));
            *(_DWORD *)(&v256[6].m_nNoOfStaticFrames + v87) = SkidmarkType;
            if ( SkidmarkType == SKIDMARKTYPE_SANDY )
              *((_BYTE *)&v256->_vptr$CPlaceable + v254) = 1;
            v91 = v256->m_pMat;
            v92 = &v256->m_transform.m_translate.x;
            if ( v91 )
              v92 = &v91->tx;
            v93 = v89[463] - v92[1];
            v94 = &aWheelOffsets[v88];
            v95 = v89[464] - v92[2];
            v94->x = v89[462] - *v92;
            v94->y = v93;
            v94->z = v95;
            v96 = v253;
            v83 = v254;
          }
          ++v88;
          v85 += 44;
          v84 = v96 + 32;
          v86 += 36;
          ++v83;
          v87 += 4;
        }
        while ( v88 != 4 );
        v16 = v251;
        v106 = 2300;
        for ( i = 0; i != 4; ++i )
        {
          CPhysical::GetSpeed(&v257.m_vecPosition, v256, aWheelOffsets[i]);
          v108 = *(_QWORD *)&v257.m_vecPosition.x;
          v109 = &aWheelSpeeds[i];
          v109->z = v257.m_vecPosition.z;
          *(_QWORD *)&v109->x = v108;
          v110 = *(CPhysical **)((char *)&v256->_vptr$CPlaceable + v106);
          if ( v110 )
          {
            CPhysical::GetSpeed(&v257.m_vecPosition, v110, *(CVector *)((char *)&v256[7].m_vecMoveFriction.z + i * 12));
            v111 = v109->y - v257.m_vecPosition.y;
            v112 = v109->z - v257.m_vecPosition.z;
            v109->x = v109->x - v257.m_vecPosition.x;
            v109->y = v111;
            v109->z = v112;
            *(int (***)(void))((char *)&v256->_vptr$CPlaceable + v106) = 0;
          }
          v106 += 4;
        }
        v113 = v256;
        p_m_nVehicleFlags = v250;
        v114 = (float)((float)(v256->m_vecMoveSpeed.x * v256->m_pMat->xy)
                     + (float)(v256->m_vecMoveSpeed.y * v256->m_pMat->yy))
             + (float)(v256->m_vecMoveSpeed.z * v256->m_pMat->zy);
        v = v114;
        if ( (*((_BYTE *)v250 + 3) & 0x20) != 0
          && v256[3].m_vecDamageNormal.z > 0.4
          && v114 > 0.15
          && v256[3].m_vecDamagePos.x < 0.1
          && v256 == FindPlayerVehicle(-1, 0)
          && TheCamera.Cams[TheCamera.ActiveCam].Mode != 16 )
        {
          if ( *(_BYTE *)&v256->m_info <= 7u && (*(_BYTE *)(LODWORD(v256[2].m_vecAttachTiltOffset.x) + 204) & 2) == 0 )
          {
            x = v256[6].m_AttachQuat.imag.x;
            if ( x == 0.0 )
            {
              v117 = 1000;
            }
            else
            {
              v116 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
              if ( LODWORD(x) > v116 )
                v117 = LODWORD(x) - v116;
              else
                v117 = 0;
            }
            LODWORD(v256[6].m_AttachQuat.imag.x) = v117;
          }
          if ( (v256[6].m_vecAverageMoveSpeed.z < 1.0 || v256[6].m_vecAverageTurnSpeed.y < 1.0)
            && (v256[6].m_vecAverageTurnSpeed.x < 1.0 || v256[6].m_vecAverageTurnSpeed.z < 1.0) )
          {
            v2.n64_u32[0] = 1159479296;
            v3.n64_u32[0] = LODWORD(v256->m_fTurnMass);
            p_xx = &v256->m_pMat->xx;
            v121 = vmin_f32(v3, v2).n64_f32[0] * -0.008;
            bBoatGrounded.x = -p_xx[4];
            bBoatGrounded.y = -p_xx[5];
            v262.x = p_xx[8] * v121;
            v262.y = p_xx[9] * v121;
            v262.z = v121 * p_xx[10];
            bBoatGrounded.z = -p_xx[6];
            CPhysical::ApplyTurnForce(v256, v262, bBoatGrounded);
          }
        }
        v122 = v256[2].m_vecAttachTiltOffset.x;
        p_m_fElasticity = &v256[6].m_fElasticity;
        v124 = v256[3].m_vecDamagePos.x;
        v125 = BYTE1(v256[7].m_aCollisionRecordPtrs[4]);
        z = v256[6].m_vecAverageMoveSpeed.z;
        v127 = *(float *)(LODWORD(v122) + 148);
        v128 = CTimer::ms_fTimeStep;
        LOBYTE(v256[7].m_aCollisionRecordPtrs[4]) = 0;
        BYTE1(v256[7].m_aCollisionRecordPtrs[4]) = 0;
        BYTE2(v256[7].m_aCollisionRecordPtrs[4]) = v125;
        if ( z >= 1.0 )
        {
          v129 = *p_m_fElasticity - v128;
          if ( v129 <= 0.0 )
          {
            v132 = 0;
            v130 = 0;
            *p_m_fElasticity = 0.0;
            goto LABEL_246;
          }
        }
        else
        {
          v129 = 4.0;
        }
        v130 = 1;
        *p_m_fElasticity = v129;
        LOBYTE(v256[7].m_aCollisionRecordPtrs[4]) = 1;
        v131 = *(unsigned __int8 *)(LODWORD(v122) + 116);
        if ( v131 == 70 )
        {
          v132 = 1;
          BYTE1(v256[7].m_aCollisionRecordPtrs[4]) = 1;
        }
        else if ( v131 == 52 )
        {
          v132 = 1;
          v130 = 1;
          BYTE1(v256[7].m_aCollisionRecordPtrs[4]) = 1;
        }
        else
        {
          v132 = 0;
        }
LABEL_246:
        p_m_fBuoyancyConstant = &v256[6].m_fBuoyancyConstant;
        if ( v256[6].m_vecAverageTurnSpeed.x >= 1.0 )
        {
          v134 = *p_m_fBuoyancyConstant - v128;
          if ( v134 <= 0.0 )
          {
            *p_m_fBuoyancyConstant = 0.0;
            goto LABEL_255;
          }
        }
        else
        {
          v134 = 4.0;
        }
        *p_m_fBuoyancyConstant = v134;
        LOBYTE(v256[7].m_aCollisionRecordPtrs[4]) = ++v130;
        v135 = *(unsigned __int8 *)(LODWORD(v122) + 116);
        v136 = v135 == 52;
        if ( v135 != 52 )
          v136 = v135 == 82;
        if ( v136 )
          BYTE1(v256[7].m_aCollisionRecordPtrs[4]) = ++v132;
LABEL_255:
        v137 = &v256[6].m_vecCOM.x;
        if ( v256[6].m_vecAverageTurnSpeed.y >= 1.0 )
        {
          v138 = *v137 - v128;
          if ( v138 <= 0.0 )
          {
            *v137 = 0.0;
            goto LABEL_264;
          }
        }
        else
        {
          v138 = 4.0;
        }
        *v137 = v138;
        LOBYTE(v256[7].m_aCollisionRecordPtrs[4]) = ++v130;
        v139 = *(unsigned __int8 *)(LODWORD(v122) + 116);
        v140 = v139 == 52;
        if ( v139 != 52 )
          v140 = v139 == 70;
        if ( v140 )
          BYTE1(v256[7].m_aCollisionRecordPtrs[4]) = ++v132;
LABEL_264:
        p_y = &v256[6].m_vecCOM.y;
        if ( v256[6].m_vecAverageTurnSpeed.z >= 1.0 )
        {
          v142 = *p_y - v128;
          if ( v142 <= 0.0 )
          {
            *p_y = 0.0;
LABEL_273:
            if ( (BYTE2(v256[2].m_vecAttachTiltOffset.z) & 8) != 0 && *(float *)&v256[7].m_pMat < 0.0 )
            {
              nFasterCheat = 2;
            }
            else
            {
              v146 = CCheat::m_aCheatsActive[35];
              if ( CCheat::m_aCheatsActive[35] )
                v146 = 1;
              nFasterCheat = (v146 | LOBYTE(v261[0])) & 1;
            }
            v147 = 0.0;
            if ( (*(_BYTE *)v250 & 0x10) != 0 && (*(_BYTE *)(LODWORD(v122) + 207) & 6) == 0 )
            {
              v113 = v256;
              v147 = cTransmission::CalculateDriveAcceleration(
                       (cTransmission *)(LODWORD(v122) + 44),
                       &v256[3].m_vecDamageNormal.z,
                       (uint8 *)&v256[3].m_vecAttachPosnOffset.z,
                       &v256[3].m_vecAttachTiltOffset.x,
                       &v,
                       (float *)&v256[6].m_listEntryInfo,
                       (float *)&v256[6].m_pMovingListNode,
                       v132,
                       nFasterCheat)
                   / v256->m_fMassMultiplier;
            }
            if ( (*(_BYTE *)&v113->m_info & 0xF8) == 24 )
            {
              v148 = v113[7].m_transform.m_heading * 0.004;
              v149 = *(float *)(LODWORD(v113[2].m_vecAttachTiltOffset.x) + 40);
            }
            else
            {
              v149 = 0.004;
              v148 = *(float *)(LODWORD(v113[2].m_vecAttachTiltOffset.x) + 40);
            }
            v150 = (float)((float)(v149 * v148) * 0.25) / v113->m_fMassMultiplier;
            if ( CCheat::m_aCheatsActive[35] || v113->m_nModelIndex == 539 && v113[7].m_vecAttachPosnOffset.x == 0.0 )
              v150 = v150 * 4.0;
            if ( v113 != FindPlayerVehicle(-1, 0) )
            {
              v151 = (v261[0] & 1) == 0;
              if ( (v261[0] & 1) == 0 )
                v151 = CCheat::m_aCheatsActive[35] == 0;
              if ( !v151 )
              {
                v147 = v147 * 1.4;
                v150 = v150 * 1.2;
                if ( (v261[0] & 2) != 0 || CCheat::m_aCheatsActive[35] )
                {
                  v147 = v147 * 1.4;
                  v150 = v150 * 1.3;
                }
              }
            }
            v152 = v124 * v127;
            if ( v > 0.01 && (*p_m_fElasticity > 0.0 || *p_m_fBuoyancyConstant > 0.0) && *(_BYTE *)&v113->m_info <= 7u )
            {
              v153 = v113->m_pMat;
              v154 = v113->m_vecMoveSpeed.x;
              y = v113->m_vecMoveSpeed.y;
              xx = v153->xx;
              HIDWORD(v5) = LODWORD(v153->yx);
              zx = v153->zx;
              v158 = v113->m_vecMoveSpeed.z;
              v257.m_dataB.m_nSurfaceType = 1;
              v257.m_dataA.m_nSurfaceType = 60;
              AdhesiveLimit = SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, &v257);
              v4.n64_u32[0] = 1.0;
              v1.n64_f32[0] = (float)((float)(v150 * 16.0) * AdhesiveLimit) / (float)(v * v);
              v1.n64_u64[0] = vmin_f32(v1, v4).n64_u64[0];
              v160 = asinf(v1.n64_f32[0]);
              v161 = (float)((float)(v154 * xx) + (float)(y * *((float *)&v5 + 1))) + (float)(v158 * zx);
              v162 = v113[3].m_vecDamageNormal.x;
              if ( v161 > 0.05 && v162 < 0.0 || v161 < -0.05 && v162 > 0.0 || (*(_BYTE *)v250 & 0x20) != 0 )
                v1.n64_u64[0] = v4.n64_u64[0];
              else
                v1.n64_f32[0] = v160
                              / (float)((float)(*(float *)(LODWORD(v113[2].m_vecAttachTiltOffset.x) + 160) * 3.1416)
                                      / 180.0);
              LODWORD(v82) = vmin_f32(v1, v4).n64_u32[0];
            }
            v163 = (CAutomobile *)v113;
            v164 = &v113[3].m_vecDamageNormal.x;
            v165 = v152 * v128;
            v166 = v163->hFlagsLocal;
            v167 = v166 & 0x800000;
            v168 = v82 * *v164;
            *v164 = v168;
            if ( (v166 & 0x800000) == 0 )
            {
              v169 = -998653952;
              if ( (v166 & 0x20) == 0 )
                v169 = LODWORD(v168);
              CAutomobile::ProcessCarWheelPair(
                v163,
                0,
                2,
                *(float *)&v169,
                aWheelSpeeds,
                aWheelOffsets,
                v150,
                v147,
                v165,
                1);
              v166 = v163->hFlagsLocal;
            }
            if ( (v166 & 0x20) != 0 )
            {
              v170 = -*v164;
            }
            else if ( (v166 & 0x40) != 0 )
            {
              v170 = v256[3].m_vecDamageNormal.y;
            }
            else
            {
              v170 = -999.0;
            }
            v171 = v256;
            CAutomobile::ProcessCarWheelPair(
              (CAutomobile *)v256,
              1,
              3,
              v170,
              aWheelSpeeds,
              aWheelOffsets,
              v150,
              v147,
              v165,
              0);
            if ( v167 )
            {
              if ( (LOBYTE(v256[2].m_vecAttachTiltOffset.z) & 0x20) != 0 )
                v172 = -999.0;
              else
                v172 = *v164;
              v171 = v256;
              CAutomobile::ProcessCarWheelPair(
                (CAutomobile *)v256,
                0,
                2,
                v172,
                aWheelSpeeds,
                aWheelOffsets,
                v150,
                v147,
                v165,
                1);
            }
            v173 = (unsigned __int8)v171->m_info;
            v6 = (CAutomobile *)v171;
            if ( v173 > 7 )
            {
              y_low = LOWORD(v171[3].m_vecCOM.y);
              v176 = y_low == 0;
              if ( LOWORD(v171[3].m_vecCOM.y) )
                v176 = y_low == 0xFFFF;
              if ( v176 || (v173 & 0xF8) == 40 )
              {
                m_pLod = v171[4].m_pLod;
                if ( m_pLod )
                  v171[4].m_pLod = (CEntity *)((char *)m_pLod - 1);
              }
            }
            else
            {
              v174 = 0;
              if ( (LODWORD(v171[2].m_vecAttachTiltOffset.z) & 0x20000) == 0 && !CCheat::m_aCheatsActive[35] )
                v174 = (v261[0] & 0x10) == 0;
              CVehicle::ProcessSirenAndHorn((CVehicle *)v171, v174);
            }
            if ( v171->m_nModelIndex != 464 )
              (*((void (__fastcall **)(CPhysical *))v171->_vptr$CPlaceable + 69))(v171);
            goto LABEL_335;
          }
        }
        else
        {
          v142 = 4.0;
        }
        *p_y = v142;
        LOBYTE(v256[7].m_aCollisionRecordPtrs[4]) = v130 + 1;
        v143 = *(unsigned __int8 *)(LODWORD(v122) + 116);
        v144 = v143 == 52;
        if ( v143 != 52 )
          v144 = v143 == 82;
        if ( v144 )
          BYTE1(v256[7].m_aCollisionRecordPtrs[4]) = ++v132;
        goto LABEL_273;
      }
    }
    else
    {
      CAutomobile::ProcessBuoyancy((CAutomobile *)v256);
      if ( v68 )
        goto LABEL_192;
    }
    if ( *((unsigned __int8 *)&v256->m_nPhysicalFlags + 1) << 31 )
    {
      z_low = (const CPed *)LODWORD(v256[3].m_vecCOM.z);
      if ( z_low && CPed::IsPlayer(z_low) )
      {
        CPlayerPed::ResetPlayerBreath((CPlayerPed *)LODWORD(v256[3].m_vecCOM.z));
      }
      else if ( LOBYTE(v256[3].m_fTrueDistanceTravelled) )
      {
        v74 = 0;
        p_m_listEntryInfo = &v256[3].m_listEntryInfo;
        do
        {
          m_pHead = (const CPed *)p_m_listEntryInfo[v74].m_pHead;
          if ( m_pHead && CPed::IsPlayer(m_pHead) )
            CPlayerPed::ResetPlayerBreath((CPlayerPed *)p_m_listEntryInfo[v74].m_pHead);
          ++v74;
        }
        while ( v74 < LOBYTE(v256[3].m_fTrueDistanceTravelled) );
      }
    }
    goto LABEL_192;
  }
  CPhysical::SkipPhysics(v6);
  *(_DWORD *)p_m_nVehicleFlags &= 0xDEFFFFFF;
  v6->m_fTyreTemp = 1.0;
LABEL_335:
  CAutomobile::ProcessCarOnFireAndExplode(v6, v16);
  if ( (*((_BYTE *)p_m_nVehicleFlags + 5) & 0x80) != 0 && (CTimer::m_FrameCounter & 7) == 5 )
  {
    v178 = CVehicle::UsesSiren(v6);
    v179 = v178 == 0;
    if ( v178 )
      v179 = v6->m_nModelIndex == 423;
    if ( !v179 && FindPlayerVehicle(-1, 0) == v6 )
      CCarAI::MakeWayForCarWithSiren(v6);
  }
  p_m_fGasPedal = &v6->m_fGasPedal;
  p_m_vecMoveSpeed = &v6->m_vecMoveSpeed;
  LODWORD(v5) = 0;
  v180 = 0.0;
  v181.n64_u64[0] = v5;
  v182 = 0;
  v183 = 2056;
  v184 = 1883;
  v185 = (float)((float)(v6->m_vecMoveSpeed.x * v6->m_vecMoveSpeed.x)
               + (float)(v6->m_vecMoveSpeed.y * v6->m_vecMoveSpeed.y))
       + (float)(v6->m_vecMoveSpeed.z * v6->m_vecMoveSpeed.z);
  do
  {
    v186 = (float *)(&v6->_vptr$CPlaceable + v182);
    v187 = v186 + 506;
    v188 = v186[506];
    v189 = v186[510] - v188;
    if ( v189 > 0.3 )
    {
      if ( v185 > 0.04 && (v261[0] & 8) == 0 )
      {
        CDamageManager::GetWheelStatus(&v6->Damage, v182);
        if ( v189 > v180 )
          v180 = v189;
      }
      v188 = *v187;
    }
    if ( v188 < 1.0 && *(_BYTE *)&v6->m_info <= 7u )
    {
      v1.n64_f32[0] = (float)SurfaceInfos_c::GetRoughness(
                               &g_surfaceInfos,
                               *((unsigned __int8 *)&v6->_vptr$CPlaceable + v184))
                    * 0.1;
      v181.n64_u64[0] = vmax_f32(v181, v1).n64_u64[0];
    }
    if ( *(float *)((char *)&v6->_vptr$CPlaceable + v183) <= 0.0 && (*p_m_fGasPedal > 0.5 || *p_m_fGasPedal < -0.5) )
    {
      if ( (v182 | 2) == 3 )
      {
        if ( mod_HandlingManager.m_aHandlingData[v6->pHandling->nVehicleID].Transmission.m_nDriveType != 70 )
          goto LABEL_358;
      }
      else if ( (v182 | 2) == 2
             && mod_HandlingManager.m_aHandlingData[v6->pHandling->nVehicleID].Transmission.m_nDriveType != 82 )
      {
LABEL_358:
        v190 = &CVehicle::WHEELSPIN_INAIR_TARGET_RATE;
        goto LABEL_362;
      }
    }
    if ( v6->m_aWheelState[v182] != WS_SPINNING )
      goto LABEL_363;
    v190 = &CVehicle::WHEELSPIN_TARGET_RATE;
LABEL_362:
    *(float *)&v5 = *(float *)&v5 + *v190;
LABEL_363:
    ++v182;
    v184 += 44;
    v183 += 4;
    v186[510] = v186[506];
    *v187 = 1.0;
  }
  while ( v182 != 4 );
  v191 = 0.5;
  v192 = CTimer::ms_fTimeStep;
  if ( v6->pHandling->Transmission.m_nDriveType == 52 )
    v191 = 0.25;
  v193 = *(float *)&v5 * v191;
  v194 = &CVehicle::WHEELSPIN_RISE_RATE;
  v195 = v256[3].m_vecAttachTiltOffset.y;
  if ( v193 < v195 )
    v194 = &CVehicle::WHEELSPIN_FALL_RATE;
  v196 = powf(*v194, CTimer::ms_fTimeStep);
  v256[3].m_vecAttachTiltOffset.y = (float)(v195 * v196) + (float)(v193 * (float)(1.0 - v196));
  v197 = 0.0;
  if ( v181.n64_f32[0] < 0.29 )
    v197 = v180;
  if ( (CTimer::m_snTimeInMilliseconds & 0x7FF) > 0x320 )
  {
    v180 = v197;
    v181.n64_u32[0] = 0;
  }
  if ( (v261[0] & 8) == 0 && v180 > 0.0 && *(_BYTE *)&v256->m_info <= 7u )
  {
    v198 = (float)((float)(v256->m_vecMoveSpeed.x * v256->m_vecMoveSpeed.x)
                 + (float)(v256->m_vecMoveSpeed.y * v256->m_vecMoveSpeed.y))
         + (float)(v256->m_vecMoveSpeed.z * v256->m_vecMoveSpeed.z);
    if ( v198 > 0.01 )
    {
      v199 = sqrtf(v198);
      if ( v180 <= 0.0 )
      {
        v3.n64_u32[0] = 1125515264;
        v1.n64_f32[0] = (float)((float)((float)((float)(v181.n64_f32[0] * 200.0) * v199) * 2000.0) / v256->m_fMass)
                      + 40.0;
        v200 = 5000.0;
      }
      else
      {
        v3.n64_u32[0] = 1132068864;
        v1.n64_f32[0] = (float)((float)((float)((float)(v180 * 200.0) * v199) * 2000.0) / v256->m_fMass) + 100.0;
        v200 = 20000.0;
      }
      v201 = (unsigned int)vmin_f32(v1, v3).n64_f32[0];
      v202 = CPad::GetPad(0);
      CPad::StartShake(v202, (unsigned int)(float)((float)(v192 * v200) / (float)v201), v201, 0);
    }
  }
  v13 = (*(_DWORD *)v250 & 0x2000) == 0;
  *(_DWORD *)v250 &= 0xDEFFFFFF;
  if ( v13 )
    CCarCtrl::ScanForPedDanger((CVehicle *)v256);
  if ( (BYTE2(v256[2].m_vecAttachTiltOffset.z) & 2) != 0
    && sqrtf(
         (float)((float)(v256->m_vecMoveSpeed.x * v256->m_vecMoveSpeed.x)
               + (float)(v256->m_vecMoveSpeed.y * v256->m_vecMoveSpeed.y))
       + (float)(v256->m_vecMoveSpeed.z * v256->m_vecMoveSpeed.z)) < 0.2 )
  {
    if ( (v203 = (unsigned __int8)v256->m_info, (v203 & 0xF8) == 24)
      && (m_fTrueDistanceTravelled_high = SHIBYTE(v256[3].m_fTrueDistanceTravelled), m_fTrueDistanceTravelled_high != -1)
      && ((v205 = m_fTrueDistanceTravelled_high, CVehicle::m_aSpecialHydraulicData[v205].aScriptControl[0] > 0.5)
       && CVehicle::m_aSpecialHydraulicData[v205].aScriptControl[1] > 0.5
       || CVehicle::m_aSpecialHydraulicData[v205].aScriptControl[2] > 0.5
       && CVehicle::m_aSpecialHydraulicData[v205].aScriptControl[3] > 0.5)
      || v203 <= 7
      && (v206 = (const CPed *)LODWORD(v256[3].m_vecCOM.z)) != 0
      && CPed::IsPlayer(v206)
      && (PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)LODWORD(v256[3].m_vecCOM.z)),
          fabsf((float)CPad::GetCarGunLeftRight(PadFromPlayer, 1, 1)) > 50.0)
      && fabsf((float)CPad::GetCarGunUpDown(PadFromPlayer, 1, 0, 2500.0, 1)) < 50.0 )
    {
      v208 = v256->m_pMat;
      m_fTurnMass = v256->m_fTurnMass;
      v210 = v256->m_vecTurnSpeed.x;
      v211 = v256->m_vecTurnSpeed.y;
      v212 = v256->m_vecTurnSpeed.z;
      v213 = CTimer::ms_fTimeStep;
      xy = v208->xy;
      yy = v208->yy;
      zy = v208->zy;
      xz = v208->xz;
      yz = v208->yz;
      zz = v208->zz;
      Multiply3x3(aWheelSpeeds, v208, &v256->m_vecCOM);
      v220 = (float)((float)(v210 * xy) + (float)(v211 * yy)) + (float)(v212 * zy);
      v221 = powf(0.985, v213);
      v222 = (float)(powf(v221 / (float)((float)(v220 * (float)(v220 * 5.0)) + 1.0), v213) * v220) - v220;
      bBoatGroundeda.x = v208->xx + aWheelSpeeds[0].x;
      bBoatGroundeda.y = v208->yx + aWheelSpeeds[0].y;
      bBoatGroundeda.z = v208->zx + aWheelSpeeds[0].z;
      v263.x = -(float)((float)(xz * v222) * m_fTurnMass);
      v263.y = -(float)((float)(yz * v222) * m_fTurnMass);
      v263.z = -(float)((float)(zz * v222) * m_fTurnMass);
      CPhysical::ApplyTurnForce(v256, v263, bBoatGroundeda);
    }
  }
  x_low = (CVehicle *)LODWORD(v256[3].m_AttachQuat.imag.x);
  if ( x_low )
  {
    if ( (*(_BYTE *)&v256->m_info & 0xF8) == 80 )
    {
      if ( x_low->m_vecMoveSpeed.x == 0.0
        && x_low->m_vecMoveSpeed.y == 0.0
        && x_low->m_vecMoveSpeed.z == 0.0
        && (float)((float)((float)(v256->m_vecMoveSpeed.x * v256->m_vecMoveSpeed.x)
                         + (float)(v256->m_vecMoveSpeed.y * v256->m_vecMoveSpeed.y))
                 + (float)(v256->m_vecMoveSpeed.z * v256->m_vecMoveSpeed.z)) <= 0.01 )
      {
        v224 = 0;
      }
      else
      {
        CVehicle::UpdateTractorLink(x_low, 0, 0);
        v224 = 1;
      }
      v225 = v256;
      CVehicle::UpdateTrailerLink((CVehicle *)v256, 0, 0);
      v226 = (CVehicle *)LODWORD(v256[3].m_AttachQuat.imag.x);
      if ( v226 && (*(_BYTE *)&v256->m_info & 0xF8) == 80 )
      {
        if ( v224 == 1 )
          CVehicle::UpdateTractorLink(v226, 0, 1);
        v225 = v256;
        CVehicle::UpdateTrailerLink((CVehicle *)v256, 0, 1);
      }
    }
    else
    {
      (*((void (__fastcall **)(CPhysical *))v256->_vptr$CPlaceable + 63))(v256);
      v225 = v256;
    }
  }
  else
  {
    v227 = v256[3].m_AttachQuat.imag.y;
    v225 = v256;
    if ( v227 != 0.0 )
    {
      if ( (*(_BYTE *)(LODWORD(v227) + 58) & 0xF8) == 80 )
      {
        v225 = v256;
        if ( *(CPhysical **)(LODWORD(v227) + 1232) == v256 )
        {
          CPhysical::RemoveFromMovingList(v256);
          CPhysical::AddToMovingList(v256);
        }
      }
      else
      {
        v225 = v256;
        CEntity::CleanUpOldReference((CEntity *)LODWORD(v227), (CEntity **)&v256[3].m_AttachQuat.imag.y);
        v256[3].m_AttachQuat.imag.y = 0.0;
      }
    }
  }
  if ( (*(_DWORD *)&v225->m_nPhysicalFlags & 0xC) == 12 )
  {
    v228 = &p_m_vecMoveSpeed->x;
    *(_QWORD *)&p_m_vecMoveSpeed[2].z = 0LL;
    *(_QWORD *)&p_m_vecMoveSpeed[3].y = 0LL;
    *(_QWORD *)&p_m_vecMoveSpeed->x = 0LL;
    *(_QWORD *)&p_m_vecMoveSpeed->z = 0LL;
    *(_QWORD *)&p_m_vecMoveSpeed[1].y = 0LL;
    *(_QWORD *)&p_m_vecMoveSpeed[2].x = 0LL;
    goto LABEL_455;
  }
  v228 = &p_m_vecMoveSpeed->x;
  if ( !v249
    && (*p_m_fGasPedal == 0.0 || (*(_BYTE *)&v225->m_info & 0xF8) == 40)
    && fabsf(p_m_vecMoveSpeed->x) < 0.005
    && fabsf(v225->m_vecMoveSpeed.y) < 0.005
    && fabsf(v225->m_vecMoveSpeed.z) < 0.005 )
  {
    if ( v225->m_fDamageImpulseMagnitude <= 0.0
      || (v229 = (CPlayerPed *)v256->m_pDamageEntity, v225 = v256, v229 != FindPlayerPed(-1)) )
    {
      v230 = v225[4].m_listEntryInfo.m_pHead;
      if ( v230 != (CEntryInfoNode *)((char *)&dword_0 + 3) )
      {
        if ( v230 == (CEntryInfoNode *)byte_4 )
        {
          v231 = &v225[7].m_vecAttachPosnOffset.x;
          goto LABEL_429;
        }
        goto LABEL_430;
      }
      v231 = &v225[7].m_vecAttachPosnOffset.y;
LABEL_429:
      if ( *v231 == 0.0 )
      {
LABEL_430:
        v232 = LOWORD(v225[6].m_vecAttachTiltOffset.z);
        v233 = v232 == 0;
        if ( LOWORD(v225[6].m_vecAttachTiltOffset.z) )
          v233 = v232 == HIWORD(v225[6].m_vecAttachTiltOffset.z);
        if ( v233 && !(*((unsigned __int8 *)&v225->m_nPhysicalFlags + 1) << 31) )
        {
          v234 = (float *)LODWORD(v225[3].m_AttachQuat.imag.x);
          if ( !v234 || v234[18] == 0.0 && v234[19] == 0.0 && v234[20] == 0.0 )
          {
            m_fMass = v225[6].m_fMass;
            if ( m_fMass < 1.0
              || v225[6].m_fTurnMass < 1.0
              || v225[6].m_fMassMultiplier < 1.0
              || v225[6].m_fAirResistance < 1.0 )
            {
              if ( (v225->m_nModelIndex == 539 || CCheat::m_aCheatsActive[41])
                && (m_fMass < 1.0 && HIBYTE(v225[5].m_pNOCollisionVehicle) == 39
                 || v225[6].m_fTurnMass < 1.0 && *((_BYTE *)&v225[6].m_nFlags + 3) == 39
                 || v225[6].m_fMassMultiplier < 1.0 && HIBYTE(v225[6].m_vecMoveSpeed.x) == 39
                 || v225[6].m_fAirResistance < 1.0 && HIBYTE(v225[6].m_vecTurnFriction.z) == 39) )
              {
                v225->m_nNoOfStaticFrames = 0;
              }
              else
              {
                v225->m_vecMoveSpeed.x = 0.0;
                v225->m_vecMoveSpeed.y = 0.0;
                v225->m_vecMoveSpeed.z = 0.0;
                v225->m_vecTurnSpeed.z = 0.0;
              }
            }
          }
        }
      }
    }
  }
LABEL_455:
  v236 = CWeather::Earthquake;
  if ( CWeather::Earthquake > 0.0 )
  {
    v237 = v225->m_pMat;
    v238 = (CSimpleTransform *)&v237->tx;
    if ( !v237 )
      v238 = &v225->m_transform;
    v239 = *(_QWORD *)&v238->m_translate.x;
    v240 = v238->m_translate.z;
    v241 = (float)rand();
    v242 = v225->m_pMat;
    v243 = v240 + (float)((float)((float)(v236 * 0.5) * (float)(v241 * 4.6566e-10)) + 0.0);
    if ( v242 )
    {
      LODWORD(v242->tx) = v239;
      v225->m_pMat->ty = *((float *)&v239 + 1);
      p_tz = &v225->m_pMat->tz;
    }
    else
    {
      p_tz = &v225->m_transform.m_translate.z;
      *(_QWORD *)&v225->m_transform.m_translate.x = v239;
    }
    *p_tz = v243;
  }
  v245 = (unsigned __int16)v225->m_nModelIndex;
  if ( v245 == 532 )
  {
    CAutomobile::ProcessHarvester((CAutomobile *)v225);
    v245 = (unsigned __int16)v225->m_nModelIndex;
  }
  if ( v245 == 432
    && (*v228 != 0.0
     || v225->m_vecMoveSpeed.y != 0.0
     || v225->m_vecMoveSpeed.z != 0.0
     || v225->m_vecTurnSpeed.x != 0.0
     || v225->m_vecTurnSpeed.y != 0.0
     || v225->m_vecTurnSpeed.z != 0.0) )
  {
    v225[5]._vptr$CPlaceable = (int (**)(void))1065353216;
    v225[5].m_transform.m_translate.x = 1.0;
    v225[5].m_pRwObject = (RwObject_0 *)1065353216;
    *(_DWORD *)&v225[5].m_nFlags = 1065353216;
    *(_DWORD *)&v225[5].RandomSeed = 1065353216;
    v225[5].pReferences = (CReference *)1065353216;
    v225[5].m_transform.m_translate.z = 1.0;
    v225[5].m_transform.m_heading = 1.0;
  }
}
// 553FA6: conditional instruction was optimized away because r1.4<8u
// 554C8E: variable 'v3' is possibly undefined
// 554C8E: variable 'v2' is possibly undefined
// 555042: variable 'v1' is possibly undefined
// 555042: variable 'v4' is possibly undefined
// 555308: variable 'v5' is possibly undefined
// 0: using guessed type int dword_0;
// 553E44: using guessed type int var_64[25];
// 553E44: using guessed type CVector var_C8[4];
// 553E44: using guessed type CVector aWheelSpeeds[4];

//----- (00555CAC) --------------------------------------------------------
void __fastcall CAutomobile::SetTaxiLight(CAutomobile *this, bool State)
{
  this->m_nAutomobileFlags = (CAutomobile::CAutomobileFlags)(State | *(_BYTE *)&this->m_nAutomobileFlags & 0xFE);
}

//----- (00555CBC) --------------------------------------------------------
void __fastcall CAutomobile::ProcessAutoBusDoors(CAutomobile *this)
{
  UInt32 m_nBusDoorTimer; // r0
  int v3; // r0
  bool v4; // zf
  float v5; // s0
  int v6; // r0
  bool v7; // zf
  float v8; // s0

  m_nBusDoorTimer = this->m_nBusDoorTimer;
  if ( m_nBusDoorTimer <= CTimer::m_snTimeInMilliseconds )
  {
    if ( this->m_nBusDoorStart )
    {
      v6 = (*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 2);
      v7 = v6 == 0;
      if ( !v6 )
        v7 = this->m_nGettingInFlags << 31 == 0;
      if ( v7 )
        (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, _DWORD, int))this->_vptr$CPlaceable + 28))(
          this,
          0,
          10,
          2,
          0,
          1);
      if ( !(*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 3)
        && (this->m_nGettingInFlags & 4) == 0 )
      {
        (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, _DWORD, int))this->_vptr$CPlaceable + 28))(
          this,
          0,
          8,
          3,
          0,
          1);
      }
      this->m_nBusDoorTimer = 0;
      this->m_nBusDoorStart = 0;
    }
  }
  else if ( CTimer::m_snTimeInMilliseconds > m_nBusDoorTimer - 500 )
  {
    v3 = (*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 2);
    v4 = v3 == 0;
    if ( !v3 )
      v4 = this->m_nGettingInFlags << 31 == 0;
    if ( v4 )
    {
      if ( (*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 33))(this, 2) )
      {
        v5 = 0.0;
        this->m_nBusDoorTimer = CTimer::m_snTimeInMilliseconds;
      }
      else
      {
        v5 = (float)((float)(CTimer::m_snTimeInMilliseconds + 500 - this->m_nBusDoorTimer) / -500.0) + 1.0;
      }
      (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, float, int))this->_vptr$CPlaceable + 28))(
        this,
        0,
        10,
        2,
        COERCE_FLOAT(LODWORD(v5)),
        1);
    }
    if ( !(*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 34))(this, 3)
      && (this->m_nGettingInFlags & 4) == 0 )
    {
      if ( (*((int (__fastcall **)(CAutomobile *, int))this->_vptr$CPlaceable + 33))(this, 3) )
      {
        v8 = 0.0;
        this->m_nBusDoorTimer = CTimer::m_snTimeInMilliseconds;
      }
      else
      {
        v8 = (float)((float)(CTimer::m_snTimeInMilliseconds + 500 - this->m_nBusDoorTimer) / -500.0) + 1.0;
      }
      (*((void (__fastcall **)(CAutomobile *, _DWORD, int, int, float, int))this->_vptr$CPlaceable + 28))(
        this,
        0,
        8,
        3,
        COERCE_FLOAT(LODWORD(v8)),
        1);
    }
  }
}

//----- (00555E58) --------------------------------------------------------
void __fastcall CAutomobile::TankControl(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  int m_nModelIndex; // r0
  unsigned int m_info; // r1
  bool v6; // zf
  CPad *Pad; // r0
  RwReal v8; // s2
  RwReal v9; // s4
  CPed *pDriver; // r0
  CPad *PadFromPlayer; // r0
  CPad *v12; // r5
  float *p_GunOrientation; // r8
  char *v14; // r0
  __int64 v15; // d16
  __int64 v16; // kr00_8
  float v17; // r6
  float v18; // r0
  float v19; // s2
  float v20; // s8
  float v21; // s16
  float v22; // s18
  float v23; // s16
  float v24; // s4
  float v25; // s6
  float GunElevation; // s2
  float v27; // s6
  float v28; // s2
  float *p_GunElevation; // r6
  int v30; // r0
  float v31; // s0
  CPlayerInfo *v32; // r0
  UInt32 *p_LastTimeBigGunFired; // r0
  UInt32 LastTimeBigGunFired; // t1
  float v35; // r5
  float v36; // r0
  float v37; // r1
  RwFrame_0 *v38; // r0
  RwMatrix *LTM; // r0
  __int64 v40; // d16
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  CMatrix *m_pMat; // r0
  float x; // s16
  float y; // s18
  float z; // s20
  float v47; // r5
  float v48; // s16
  float v49; // r0
  CMatrix *v50; // r0
  RwReal v51; // s0
  unsigned int v52; // s2
  float m_fMass; // s8
  CPlayerPed *PlayerPed; // r0
  CVector pTargetEnt; // [sp+0h] [bp-D0h]
  CVector dir; // [sp+20h] [bp-B0h] BYREF
  CEntity *refEntityPtr; // [sp+2Ch] [bp-A4h] BYREF
  CColPoint v58; // [sp+30h] [bp-A0h] BYREF
  CVector pShotTarget; // [sp+60h] [bp-70h] BYREF
  CVector m_vecPosition; // [sp+70h] [bp-60h] BYREF
  CVector pShotOrigin; // [sp+80h] [bp-50h] BYREF
  CVector v; // [sp+90h] [bp-40h] BYREF
  CVector v63; // 0:r1.12
  CVector v64; // 0:r2.8,8:^0.4

  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  m_info = (unsigned __int8)this->m_info;
  v6 = m_nModelIndex == 564;
  if ( m_nModelIndex == 564 )
    v6 = (m_info & 0xF8) == 64;
  if ( !v6 )
  {
    if ( m_info > 7 )
      return;
    if ( m_nModelIndex != 432 )
      return;
    if ( CGameLogic::GameState )
      return;
    pDriver = this->pDriver;
    if ( !pDriver )
      return;
    if ( !CPed::IsPlayer(pDriver) )
      return;
    PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
    v12 = PadFromPlayer;
    if ( !PadFromPlayer )
      return;
    p_GunOrientation = &this->GunOrientation;
    if ( TheCamera.Cams[TheCamera.ActiveCam].Mode != 18 )
    {
      v21 = CTimer::ms_fTimeStep * -0.015;
      *p_GunOrientation = *p_GunOrientation
                        + (float)((float)(v21 * (float)CPad::GetCarGunLeftRight(PadFromPlayer, 0, 0)) * 0.0078125);
      v22 = CTimer::ms_fTimeStep;
      v23 = this->GunElevation
          + (float)((float)((float)(v22 * 0.005) * (float)CPad::GetCarGunUpDown(v12, 0, 0, 2500.0, 0)) * 0.0078125);
      this->GunElevation = v23;
      v1.n64_f32[0] = *p_GunOrientation;
      goto LABEL_30;
    }
    v14 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
    v15 = *((_QWORD *)v14 + 91);
    v58.m_vecPosition.z = *((RwReal *)v14 + 184);
    *(_QWORD *)&v58.m_vecPosition.x = v15;
    Multiply3x3(&v, &v58.m_vecPosition, this->m_pMat);
    v58.m_vecPosition = v;
    v16 = *(_QWORD *)&v.x;
    v17 = atan2f(COERCE_FLOAT(LODWORD(v.x) ^ 0x80000000), v.y);
    v18 = atan2f(
            v58.m_vecPosition.z,
            sqrtf((float)(*(float *)&v16 * *(float *)&v16) + (float)(*((float *)&v16 + 1) * *((float *)&v16 + 1))));
    v19 = *p_GunOrientation;
    v1.n64_f32[0] = v17;
    if ( v17 <= (float)(*p_GunOrientation + 3.1416) )
    {
      if ( v17 >= (float)(v19 + -3.1416) )
      {
LABEL_21:
        v23 = v18 + 0.2618;
        v24 = CTimer::ms_fTimeStep;
        v25 = CTimer::ms_fTimeStep * 0.015;
        if ( (float)(v1.n64_f32[0] - v19) <= (float)(CTimer::ms_fTimeStep * 0.015) )
        {
          if ( (float)(v1.n64_f32[0] - v19) < (float)(CTimer::ms_fTimeStep * -0.015) )
            v1.n64_f32[0] = v19 - v25;
        }
        else
        {
          v1.n64_f32[0] = v19 + v25;
        }
        *p_GunOrientation = v1.n64_f32[0];
        GunElevation = this->GunElevation;
        v27 = v24 * 0.005;
        if ( (float)(v23 - GunElevation) <= (float)(v24 * 0.005) )
        {
          if ( (float)(v23 - GunElevation) < (float)(v24 * -0.005) )
            v23 = GunElevation - v27;
        }
        else
        {
          v23 = GunElevation + v27;
        }
        this->GunElevation = v23;
LABEL_30:
        if ( v1.n64_f32[0] >= -3.1416 )
        {
          if ( v1.n64_f32[0] <= 3.1416 )
            goto LABEL_35;
          v28 = -6.2832;
        }
        else
        {
          v28 = 6.2832;
        }
        v1.n64_f32[0] = v1.n64_f32[0] + v28;
        *p_GunOrientation = v1.n64_f32[0];
LABEL_35:
        p_GunElevation = &this->GunElevation;
        if ( v23 <= 0.61087 )
        {
          if ( v1.n64_f32[0] > 1.5708 || v1.n64_f32[0] < -1.5708 )
          {
            v2.n64_u32[0] = -1.0;
            v1.n64_f32[0] = cosf(v1.n64_f32[0]) * 1.3;
            v31 = (float)(vmax_f32(v1, v2).n64_f32[0] * -0.069813) + -0.12217;
            if ( v23 < v31 )
              *p_GunElevation = v31;
            goto LABEL_44;
          }
          if ( v23 >= -0.12217 )
          {
LABEL_44:
            if ( CPad::CarGunJustDown(v12) )
            {
              v32 = &CWorld::Players[CWorld::PlayerInFocus];
              LastTimeBigGunFired = v32->LastTimeBigGunFired;
              p_LastTimeBigGunFired = &v32->LastTimeBigGunFired;
              if ( CTimer::m_snTimeInMilliseconds > LastTimeBigGunFired + 800 )
              {
                *p_LastTimeBigGunFired = CTimer::m_snTimeInMilliseconds;
                v35 = *p_GunOrientation;
                v36 = cosf(*p_GunOrientation);
                v37 = *p_GunElevation;
                v.y = v36;
                v.z = sinf(v37);
                v.x = sinf(COERCE_FLOAT(LODWORD(v35) ^ 0x80000000));
                Multiply3x3(&v58.m_vecPosition, this->m_pMat, &v);
                v = v58.m_vecPosition;
                v38 = this->m_aCarNodes[22];
                if ( v38 )
                {
                  LTM = RwFrameGetLTM(v38);
                  v40 = *(_QWORD *)&LTM->pos.x;
                  p_m_transform = &this->m_transform;
                  pShotOrigin.z = LTM->pos.z;
                  p_tx = &this->m_transform;
                  *(_QWORD *)&pShotOrigin.x = v40;
                  m_pMat = this->m_pMat;
                  if ( m_pMat )
                    p_tx = (CSimpleTransform *)&m_pMat->tx;
                  v64.x = *(float *)&v40 - p_tx->m_translate.x;
                  v64.y = *((float *)&v40 + 1) - p_tx->m_translate.y;
                  m_vecPosition.z = pShotOrigin.z - p_tx->m_translate.z;
                  *(_QWORD *)&m_vecPosition.x = *(_QWORD *)&v64.x;
                  v64.z = m_vecPosition.z;
                  CPhysical::GetSpeed(&v58.m_vecPosition, this, v64);
                  m_vecPosition = v58.m_vecPosition;
                  x = (float)(CTimer::ms_fTimeStep * v58.m_vecPosition.x) + pShotOrigin.x;
                  y = (float)(CTimer::ms_fTimeStep * v58.m_vecPosition.y) + pShotOrigin.y;
                  z = (float)(CTimer::ms_fTimeStep * v58.m_vecPosition.z) + pShotOrigin.z;
                  pShotOrigin.x = x;
                  pShotOrigin.y = y;
                  pShotOrigin.z = z;
                }
                else
                {
                  v47 = *p_GunOrientation;
                  v48 = sinf(*p_GunOrientation);
                  v49 = cosf(v47);
                  m_vecPosition.z = vecTURRET_CENTRE.z + (float)(vecTURBAR.z + -1.0);
                  m_vecPosition.x = vecTURRET_CENTRE.x
                                  + (float)((float)(v49 * vecTURBAR.x) - (float)(v48 * vecTURBAR.y));
                  m_vecPosition.y = vecTURRET_CENTRE.y
                                  + (float)((float)(v48 * vecTURBAR.x) + (float)(v49 * vecTURBAR.y));
                  operator*(&v58.m_vecPosition, this->m_pMat, &m_vecPosition);
                  x = pShotOrigin.x;
                  p_m_transform = &this->m_transform;
                  y = pShotOrigin.y;
                  z = pShotOrigin.z;
                }
                v50 = this->m_pMat;
                if ( v50 )
                  p_m_transform = (CSimpleTransform *)&v50->tx;
                v51 = x - p_m_transform->m_translate.x;
                *(float *)&v52 = y - p_m_transform->m_translate.y;
                m_vecPosition.z = z - p_m_transform->m_translate.z;
                LODWORD(m_vecPosition.y) = v52;
                m_vecPosition.x = v51;
                m_fMass = this->m_fMass;
                pTargetEnt.x = v51;
                *(_QWORD *)&pTargetEnt.y = __PAIR64__(LODWORD(m_vecPosition.z), v52);
                v63.x = v.x * (float)(m_fMass * -0.1);
                v63.y = (float)(m_fMass * -0.1) * v.y;
                v63.z = (float)(m_fMass * -0.1) * v.z;
                CPhysical::ApplyForce(this, v63, pTargetEnt, 1);
                pShotTarget.x = (float)(v.x * 60.0) + x;
                pShotTarget.y = (float)(v.y * 60.0) + y;
                pShotTarget.z = (float)(v.z * 60.0) + z;
                CWeapon::DoTankDoomAiming(this, this->pDriver, &pShotOrigin, &pShotTarget);
                CWorld::pIgnoreEntity = this;
                refEntityPtr = 0;
                CWorld::ProcessLineOfSight(&pShotOrigin, &pShotTarget, &v58, &refEntityPtr, 1, 1, 1, 1, 1, 1, 0, 0);
                CWorld::pIgnoreEntity = 0;
                if ( refEntityPtr )
                {
                  pShotTarget.z = v58.m_vecPosition.z - (float)((float)(v58.m_vecPosition.z - pShotOrigin.z) * 0.04);
                  pShotTarget.x = v58.m_vecPosition.x - (float)((float)(v58.m_vecPosition.x - pShotOrigin.x) * 0.04);
                  pShotTarget.y = v58.m_vecPosition.y - (float)((float)(v58.m_vecPosition.y - pShotOrigin.y) * 0.04);
                }
                PlayerPed = FindPlayerPed(-1);
                CExplosion::AddExplosion(0, PlayerPed, EXP_TYPE_TANK_GRENADE, pShotTarget, 0, 1u, -1.0, 0);
                dir.x = pShotTarget.x - pShotOrigin.x;
                dir.y = pShotTarget.y - pShotOrigin.y;
                dir.z = pShotTarget.z - pShotOrigin.z;
                Fx_c::TriggerTankFire(&g_fx, &pShotOrigin, &dir);
              }
            }
            return;
          }
          v30 = -1107675682;
        }
        else
        {
          v30 = 1058824619;
        }
        *(_DWORD *)p_GunElevation = v30;
        goto LABEL_44;
      }
      v20 = 6.2832;
    }
    else
    {
      v20 = -6.2832;
    }
    v1.n64_f32[0] = v17 + v20;
    goto LABEL_21;
  }
  Pad = CPad::GetPad(0);
  if ( CPad::CarGunJustDown(Pad) && CTimer::m_snTimeInMilliseconds > TIGER_GUNFIRE_RATE + this->TimeOfLastShotFired )
  {
    CWeapon::CWeapon((CWeapon *)&v58, WEAPONTYPE_MINIGUN, 5000);
    v = TIGER_GUN_POS;
    operator*(&pShotOrigin, this->m_pMat, &v);
    v8 = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y) + pShotOrigin.y;
    v9 = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.z) + pShotOrigin.z;
    v.x = (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x) + pShotOrigin.x;
    v.y = v8;
    v.z = v9;
    CWeapon::FireInstantHit((CWeapon *)&v58, this, &v, &v, 0, 0, 0, 0, 1);
    pShotOrigin.x = 0.0;
    pShotOrigin.y = 0.1;
    CWeapon::AddGunshell((CWeapon *)&v58, this, &v, (const CVector2D *)&pShotOrigin, 0.025);
    CAudioEngine::ReportWeaponEvent(&AudioEngine, 145, WEAPONTYPE_MINIGUN, this);
    this->TimeOfLastShotFired = CTimer::m_snTimeInMilliseconds;
  }
}
// 55623A: variable 'v1' is possibly undefined
// 55623A: variable 'v2' is possibly undefined

//----- (0055665C) --------------------------------------------------------
void __fastcall CAutomobile::TowTruckControl(CAutomobile *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  CPed *pDriver; // r0
  CPad *PadFromPlayer; // r0
  int CarGunUpDown; // r0
  CVehicle *m_pVehicleBeingTowed; // r0
  unsigned int m_nSuspensionHydraulics; // r1
  bool v10; // zf
  int v11; // r6
  CEntity *v12; // r5
  float32x2_t v13; // d16
  unsigned __int64 v14; // d0
  Int16 pNum; // [sp+1Eh] [bp-92h] BYREF
  CEntity *v16[16]; // [sp+20h] [bp-90h] BYREF
  float32x2_t v17; // [sp+60h] [bp-50h] BYREF
  float v18; // [sp+68h] [bp-48h]
  CVector Coors; // [sp+70h] [bp-40h] BYREF

  if ( *(_BYTE *)&this->m_info <= 7u )
  {
    pDriver = this->pDriver;
    if ( pDriver )
    {
      if ( CPed::IsPlayer(pDriver) )
      {
        PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
        if ( PadFromPlayer )
        {
          CarGunUpDown = CPad::GetCarGunUpDown(PadFromPlayer, 1, this, (float)TOWTRUCK_HOIST_DOWN_LIMIT, 0);
          if ( fabsf((float)CarGunUpDown) > 10.0 )
          {
            v2.n64_u32[0] = 2.0;
            if ( CarGunUpDown > 0 )
              v2.n64_u32[0] = 6.0;
            v1.n64_f32[0] = (float)(v2.n64_f32[0] * (float)CarGunUpDown) * CTimer::ms_fTimeStep;
            v2.n64_u32[0] = 0;
            v1.n64_f32[0] = (float)(this->m_nSuspensionHydraulics + (int)v1.n64_f32[0]);
            v3.n64_f32[0] = (float)TOWTRUCK_HOIST_DOWN_LIMIT;
            v1.n64_u64[0] = vmin_f32(vmax_f32(v1, v2), v3).n64_u64[0];
            this->m_nSuspensionHydraulics = (unsigned int)v1.n64_f32[0];
          }
          m_pVehicleBeingTowed = this->m_pVehicleBeingTowed;
          m_nSuspensionHydraulics = this->m_nSuspensionHydraulics;
          if ( m_pVehicleBeingTowed )
          {
            v1.n64_f32[0] = (float)m_nSuspensionHydraulics;
            v2.n64_f32[0] = (float)TOWTRUCK_HOIST_UP_LIMIT;
            m_nSuspensionHydraulics = (unsigned int)vmax_f32(v1, v2).n64_f32[0];
            this->m_nSuspensionHydraulics = m_nSuspensionHydraulics;
          }
          v10 = m_nSuspensionHydraulics == TOWTRUCK_HOIST_DOWN_LIMIT;
          if ( m_nSuspensionHydraulics == TOWTRUCK_HOIST_DOWN_LIMIT )
            v10 = m_pVehicleBeingTowed == 0;
          if ( v10 )
          {
            memset(&Coors, 0, sizeof(Coors));
            v17.n64_u64[0] = 0LL;
            v18 = 0.0;
            if ( (*((int (__fastcall **)(CAutomobile *, CVector *, _DWORD, CAutomobile *))this->_vptr$CPlaceable + 61))(
                   this,
                   &Coors,
                   0,
                   this) == 1 )
            {
              CWorld::FindObjectsInRange(&Coors, 10.0, 1, &pNum, 16, v16, 0, 1, 0, 0, 0);
              if ( pNum >= 1 )
              {
                LOWORD(v11) = 0;
                while ( 1 )
                {
                  v12 = v16[(__int16)v11];
                  if ( v12 != this
                    && (*((int (__fastcall **)(CEntity *, float32x2_t *, int, CAutomobile *))v12->_vptr$CPlaceable + 60))(
                         v16[(__int16)v11],
                         &v17,
                         1,
                         this) == 1
                    && (v12[17].m_nScanCode & 8) == 0 )
                  {
                    v13.n64_u64[0] = vsub_f32(v17, *(float32x2_t *)&Coors.x).n64_u64[0];
                    v14 = vmul_f32(v13, v13).n64_u64[0];
                    if ( sqrtf(*(float *)&v14 + *((float *)&v14 + 1)) < 0.5 && fabsf(v18 - Coors.z) < 1.0 )
                      break;
                  }
                  v11 = (__int16)(v11 + 1);
                  if ( v11 >= pNum )
                    return;
                }
                (*((void (__fastcall **)(CEntity *, CAutomobile *, _DWORD))v12->_vptr$CPlaceable + 62))(v12, this, 0);
                this->m_nSuspensionHydraulics -= 100;
              }
            }
          }
        }
      }
    }
  }
}
// 556720: variable 'v1' is possibly undefined
// 556720: variable 'v2' is possibly undefined
// 556724: variable 'v3' is possibly undefined

//----- (00556894) --------------------------------------------------------
void __fastcall CAutomobile::BoostJumpControl(CAutomobile *this)
{
  CPed *pDriver; // r0
  CPlayerPed *PlayerPed; // r0
  CPad *PadFromPlayer; // r0
  CMatrix *m_pMat; // r0
  float v6; // s0
  CVector v7; // 0:r1.12
  CVector v8; // 0:r1.12

  pDriver = this->pDriver;
  if ( pDriver )
  {
    if ( CPed::IsPlayer(pDriver) )
    {
      PlayerPed = FindPlayerPed(-1);
      PadFromPlayer = CPlayerPed::GetPadFromPlayer(PlayerPed);
      if ( CPad::GetJump(PadFromPlayer) && this->m_aWheelRatios[0] < 1.0 )
      {
        v7.z = this->m_fMass * 0.15;
        v7.x = v7.z * 0.0;
        v7.y = v7.z * 0.0;
        CPhysical::ApplyMoveForce(this, v7);
        m_pMat = this->m_pMat;
        v6 = this->m_fTurnMass * 0.01;
        v8.x = v6 * m_pMat->xz;
        v8.y = v6 * m_pMat->yz;
        v8.z = v6 * m_pMat->zz;
        CPhysical::ApplyTurnForce(this, v8, *(CVector *)&m_pMat->xy);
      }
    }
  }
}

//----- (00556950) --------------------------------------------------------
void __fastcall CAutomobile::NitrousControl(CAutomobile *this, int8 nGiveBoosts)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  int v7; // r6
  CPad *PadFromPlayer; // r5
  float *p_m_fTyreTemp; // r6
  int m_nNitroBoosts; // r0
  uint32 hFlagsLocal; // r0
  uint32 v12; // r0
  FxSystem_c *m_pFxSysNitro1; // r0
  FxSystem_c *m_pFxSysNitro2; // r0
  float v15; // s4
  float m_fGasPedal; // s0
  float v17; // s0
  uint32 v18; // r0
  float v19; // s2
  int v20; // r1
  CAutomobile *v21; // r0

  v7 = nGiveBoosts;
  if ( *(_BYTE *)&this->m_info <= 7u && CPed::IsPlayer(this->pDriver) )
  {
    PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)this->pDriver);
    if ( v7 < 1 )
      goto LABEL_4;
LABEL_12:
    this->m_fTyreTemp = 1.0;
    hFlagsLocal = this->hFlagsLocal;
    this->m_nNitroBoosts = v7;
    v12 = hFlagsLocal | 0x80000;
LABEL_13:
    this->hFlagsLocal = v12;
    goto LABEL_14;
  }
  PadFromPlayer = 0;
  if ( v7 >= 1 )
    goto LABEL_12;
LABEL_4:
  if ( v7 <= -1 )
  {
    this->m_fTyreTemp = 1.0;
    v18 = this->hFlagsLocal;
    this->m_nNitroBoosts = 0;
    v12 = v18 & 0xFFF7FFFF;
    goto LABEL_13;
  }
  v2.n64_u32[0] = 1.0;
  p_m_fTyreTemp = &this->m_fTyreTemp;
  v3.n64_u32[0] = LODWORD(this->m_fTyreTemp);
  if ( v3.n64_f32[0] != 1.0 || (m_nNitroBoosts = this->m_nNitroBoosts, m_nNitroBoosts < 1) )
  {
    v15 = CTimer::ms_fTimeStep * 0.001;
    if ( v3.n64_f32[0] >= 0.0 )
    {
      v5.n64_u32[0] = 0.25;
      v4.n64_f32[0] = 1.0 - this->m_fGasPedal;
      v3.n64_f32[0] = v3.n64_f32[0] + (float)(v15 * vmax_f32(v4, v5).n64_f32[0]);
      v19 = vmin_f32(v3, v2).n64_f32[0];
      *p_m_fTyreTemp = v19;
      v17 = (float)(1.0 - v19) * 0.5;
    }
    else
    {
      *p_m_fTyreTemp = v3.n64_f32[0] - v15;
      if ( (float)(v3.n64_f32[0] - v15) < -1.0 )
      {
        *p_m_fTyreTemp = 0.000001;
        if ( !this->m_nNitroBoosts )
        {
          this->hFlagsLocal &= ~0x80000u;
          CVehicle::RemoveUpgrade(this, 15);
          *p_m_fTyreTemp = 1.0;
        }
      }
      m_fGasPedal = this->m_fGasPedal;
      if ( m_fGasPedal <= 0.0 )
      {
        v21 = this;
        v20 = 1056964608;
        goto LABEL_35;
      }
      v17 = (float)(fabsf(m_fGasPedal) * 0.5) + 0.5;
    }
    v20 = LODWORD(v17);
    v21 = this;
LABEL_35:
    CAutomobile::DoNitroEffect(v21, *(float *)&v20);
    return;
  }
  if ( (*(_BYTE *)&this->m_info & 0xF8) == 24 )
    goto LABEL_8;
  if ( PadFromPlayer
    && CPad::GetNitroFired(PadFromPlayer)
    && !CPad::GetLookLeft(PadFromPlayer, 1)
    && !CPad::GetLookRight(PadFromPlayer, 1)
    && !CPad::GetLookBehindForCar(PadFromPlayer) )
  {
    LOBYTE(m_nNitroBoosts) = this->m_nNitroBoosts;
LABEL_8:
    *p_m_fTyreTemp = -0.000001;
    if ( (char)m_nNitroBoosts <= 100 )
      this->m_nNitroBoosts = m_nNitroBoosts - 1;
  }
LABEL_14:
  m_pFxSysNitro1 = this->m_pFxSysNitro1;
  if ( m_pFxSysNitro1 )
  {
    FxSystem_c::Kill(m_pFxSysNitro1);
    this->m_pFxSysNitro1 = 0;
  }
  m_pFxSysNitro2 = this->m_pFxSysNitro2;
  if ( m_pFxSysNitro2 )
  {
    FxSystem_c::Kill(m_pFxSysNitro2);
    this->m_pFxSysNitro2 = 0;
  }
}
// 556AB6: variable 'v4' is possibly undefined
// 556AB6: variable 'v5' is possibly undefined
// 556AC6: variable 'v3' is possibly undefined
// 556AC6: variable 'v2' is possibly undefined

//----- (00556B38) --------------------------------------------------------
void __fastcall CAutomobile::ProcessCarWheelPair(
        CAutomobile *this,
        int32 nWheel1,
        int32 nWheel2,
        float fSteerAngle,
        CVector *aWheelSpeeds,
        CVector *aWheelOffsets,
        float fAdhesiveScalar,
        float fDriveForce,
        float fFrictionForce,
        int bFrontWheels)
{
  float32x2_t v10; // d0
  float32x2_t v11; // d2
  float v12; // s28
  float v13; // s30
  tHandlingData *pHandling; // r2
  int v19; // r5
  float v21; // s22
  int m_nDriveType; // r1
  _BOOL4 v23; // r10
  float v24; // s20
  bool v25; // zf
  float m_fTurnMass; // s2
  CMatrix *m_pMat; // r0
  float v28; // s0
  float v29; // s17
  float v30; // r6
  int v31; // r0
  int v32; // r0
  tHandlingData *v33; // r0
  float v34; // s26
  float v35; // s24
  tHandlingData *v36; // r0
  int32 v37; // r5
  CColPoint *v38; // r8
  CMatrix *v39; // r1
  __int64 v40; // d16
  float y; // s4
  float x; // s6
  float z; // s14
  float32x2_t v44; // d0
  float v45; // s8
  float v46; // s17
  RwReal v47; // s2
  float v48; // s19
  char *v49; // r4
  float WetMultiplier; // r0
  unsigned __int8 *v51; // r4
  uint32 hFlagsLocal; // r1
  _BOOL4 v53; // r8
  float *v54; // r12
  float *v55; // r4
  float v56; // s2
  int v57; // r0
  float *v58; // r9
  CMatrix *v59; // r1
  CColPoint *v60; // r5
  __int64 v61; // d16
  float v62; // s4
  float v63; // s6
  float v64; // s14
  float32x2_t v65; // d0
  float v66; // s8
  float v67; // s17
  RwReal v68; // s2
  float v69; // s22
  char *v70; // r4
  float v71; // r0
  unsigned __int8 *v72; // r4
  uint32 v73; // r1
  float *v74; // r12
  float *v75; // r4
  float v76; // s2
  int v77; // r0
  tWheelState v78; // r0
  bool v79; // zf
  float v80; // s0
  float m_fTyreTemp; // s0
  float *v82; // r1
  float *v83; // r0
  float v84; // s0
  float v85; // s2
  float *v86; // r0
  float *v87; // r1
  float v88; // s0
  float v89; // s2
  CVector vecOffset; // [sp+0h] [bp-C8h]
  int32 v91; // [sp+28h] [bp-A0h]
  int v92; // [sp+2Ch] [bp-9Ch]
  float *v93; // [sp+34h] [bp-94h]
  CVector v94; // [sp+38h] [bp-90h] BYREF
  int v95; // [sp+44h] [bp-84h] BYREF
  CVector vecRight; // [sp+48h] [bp-80h] BYREF
  CVector vecForward; // [sp+58h] [bp-70h] BYREF

  pHandling = this->pHandling;
  v19 = bFrontWheels;
  v21 = fAdhesiveScalar;
  m_nDriveType = mod_HandlingManager.m_aHandlingData[LOBYTE(pHandling->nVehicleID)].Transmission.m_nDriveType;
  if ( bFrontWheels == 1 )
  {
    v23 = 0;
    v24 = pHandling->fSuspensionBias + pHandling->fSuspensionBias;
    if ( m_nDriveType != 82 )
      v23 = 1;
  }
  else
  {
    v23 = m_nDriveType != 70;
    v24 = 2.0 - (float)(pHandling->fSuspensionBias + pHandling->fSuspensionBias);
    if ( (*(_BYTE *)&this->m_nVehicleFlags & 0x20) == 0 || (this->hFlagsLocal & 0x40) != 0 )
    {
      v25 = m_nDriveType == 70;
      if ( m_nDriveType != 70 )
        v25 = this->nBrakesOn == 0;
      if ( v25 )
      {
        if ( (this->hFlagsLocal & 0x80000) == 0
          && mod_HandlingManager.m_aHandlingData[LOBYTE(pHandling->nVehicleID)].Transmission.m_nDriveType != 70 )
        {
          v21 = this->m_fTyreTemp * fAdhesiveScalar;
        }
      }
      else
      {
        m_fTurnMass = this->m_fTurnMass;
        v10.n64_f32[0] = 3000.0 / m_fTurnMass;
        v11.n64_u32[0] = 1.0;
        m_pMat = this->m_pMat;
        v28 = this->m_fSteerAngle * (float)((float)(m_fTurnMass * -0.002) * vmin_f32(v10, v11).n64_f32[0]);
        vecOffset.x = v28 * m_pMat->xx;
        vecOffset.y = v28 * m_pMat->yx;
        vecOffset.z = v28 * m_pMat->zx;
        CPhysical::ApplyTurnForce(this, aWheelOffsets[nWheel1], vecOffset);
        fFrictionForce = 0.0;
        v23 = 1;
        v21 = 0.0;
      }
    }
    else
    {
      fFrictionForce = 20000.0;
    }
  }
  v93 = (float *)(&this->_vptr$CPlaceable + nWheel1);
  v29 = v93[514];
  if ( v29 > 0.0 || this->m_aWheelCounts[nWheel2] > 0.0 )
  {
    if ( fSteerAngle <= -100.0 )
    {
      v31 = 0;
    }
    else
    {
      v30 = sinf(fSteerAngle);
      v12 = cosf(fSteerAngle);
      v31 = 1;
      v13 = v30;
    }
    v92 = v31;
    if ( ((*(_BYTE *)&this->m_info >> 3) | 8) == 8 )
      v32 = 0;
    else
      v32 = (LOBYTE(this->hFlagsLocal) >> 3) & 1;
    if ( bFrontWheels == 1 )
    {
      if ( !v32 )
      {
        v33 = this->pHandling;
        v34 = v33->fBrakeBias + v33->fBrakeBias;
        v35 = v33->fTractionBias + v33->fTractionBias;
        goto LABEL_29;
      }
    }
    else if ( !v32 )
    {
      v36 = this->pHandling;
      v34 = 2.0 - (float)(v36->fBrakeBias + v36->fBrakeBias);
      v35 = 2.0 - (float)(v36->fTractionBias + v36->fTractionBias);
LABEL_29:
      if ( v29 <= 0.0 )
        goto LABEL_54;
      v37 = nWheel2;
      v38 = (CColPoint *)((char *)this + 44 * nWheel1);
      v39 = this->m_pMat;
      v40 = *(_QWORD *)&v39->xy;
      vecForward.z = v39->zy;
      *(_QWORD *)&vecForward.x = v40;
      y = v38[42].m_vecNormal.y;
      x = v38[42].m_vecNormal.x;
      z = v38[42].m_vecNormal.z;
      v44.n64_f32[1] = vecForward.z * z;
      v45 = (float)((float)(*(float *)&v40 * x) + (float)(*((float *)&v40 + 1) * y)) + (float)(vecForward.z * z);
      vecForward.z = vecForward.z - (float)(z * v45);
      vecForward.x = *(float *)&v40 - (float)(x * v45);
      vecForward.y = *((float *)&v40 + 1) - (float)(y * v45);
      CVector::Normalise(&vecForward);
      CrossProduct(&v94, &vecForward, &v38[42].m_vecNormal);
      vecRight = v94;
      CVector::Normalise(&vecRight);
      v46 = 0.0;
      if ( v23 )
        v46 = fDriveForce;
      if ( v92 == 1 && this->m_nModelIndex != 520 )
      {
        v11.n64_f32[1] = v12 * vecRight.x;
        v11.n64_f32[0] = (float)(v12 * vecForward.z) - (float)(v13 * vecRight.z);
        v44.n64_f32[1] = (float)(v13 * vecForward.x) + (float)(v12 * vecRight.x);
        v47 = (float)(v12 * vecForward.y) - (float)(v13 * vecRight.y);
        v44.n64_f32[0] = (float)(v12 * vecForward.x) - (float)(v13 * vecRight.x);
        vecRight.z = (float)(v13 * vecForward.z) + (float)(v12 * vecRight.z);
        vecRight.y = (float)(v13 * vecForward.y) + (float)(v12 * vecRight.y);
        LODWORD(vecForward.z) = v11.n64_u32[0];
        vecRight.x = v44.n64_f32[1];
        vecForward.y = v47;
        LODWORD(vecForward.x) = v44.n64_u32[0];
      }
      v38[42].m_dataA.m_nSurfaceType = 60;
      v91 = v37;
      v48 = v21 * SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, v38 + 42);
      if ( *(_BYTE *)&this->m_info <= 7u )
      {
        v49 = (char *)this + 44 * nWheel1;
        WetMultiplier = SurfaceInfos_c::GetWetMultiplier(&g_surfaceInfos, (unsigned __int8)v49[1883]);
        v51 = (unsigned __int8 *)(v49 + 1883);
        hFlagsLocal = this->hFlagsLocal;
        v11.n64_u32[0] = 2.0;
        v44.n64_f32[0] = v24 * (float)((float)((float)(1.0 - v93[506]) * 4.0) * this->pHandling->fSuspensionForce);
        v48 = (float)(v48 * WetMultiplier) * vmin_f32(v44, v11).n64_f32[0];
        if ( (hFlagsLocal & 0x200000) != 0 )
        {
          if ( SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, *v51) > 2 )
          {
            v53 = v23;
            v48 = v48 * 1.4;
LABEL_44:
            v95 = *((_DWORD *)v93 + 607);
            if ( CDamageManager::GetWheelStatus(&this->Damage, nWheel1) == 1 )
            {
              v54 = (float *)(&dword_0 + 1);
              v55 = v93 + 539;
              v56 = v35 * (float)(v48 * this->Damage.fWheelDamageEffect);
            }
            else
            {
              v56 = v35 * v48;
              v55 = v93 + 539;
              v54 = 0;
            }
            CVehicle::ProcessWheel(
              this,
              &vecForward,
              &vecRight,
              &aWheelSpeeds[nWheel1],
              &aWheelOffsets[nWheel1],
              this->nNoOfContactWheels,
              v46,
              fFrictionForce * v34,
              v56,
              (unsigned __int8)nWheel1,
              v55,
              (tWheelState *)&v95,
              v54);
            v23 = v53;
            v19 = bFrontWheels;
            nWheel2 = v91;
            if ( v23 )
            {
              v57 = v95;
              if ( this->m_fGasPedal < 0.0 && v95 == 1 )
                v57 = 0;
            }
            else
            {
              v57 = v95;
            }
            *((_DWORD *)v93 + 607) = v57;
LABEL_54:
            v58 = (float *)(&this->_vptr$CPlaceable + nWheel2);
            if ( v58[514] <= 0.0 )
              goto LABEL_77;
            v59 = this->m_pMat;
            v60 = (CColPoint *)((char *)this + 44 * nWheel2);
            v61 = *(_QWORD *)&v59->xy;
            vecForward.z = v59->zy;
            *(_QWORD *)&vecForward.x = v61;
            v62 = v60[42].m_vecNormal.y;
            v63 = v60[42].m_vecNormal.x;
            v64 = v60[42].m_vecNormal.z;
            v65.n64_f32[1] = vecForward.z * v64;
            v66 = (float)((float)(*(float *)&v61 * v63) + (float)(*((float *)&v61 + 1) * v62))
                + (float)(vecForward.z * v64);
            vecForward.z = vecForward.z - (float)(v64 * v66);
            vecForward.x = *(float *)&v61 - (float)(v63 * v66);
            vecForward.y = *((float *)&v61 + 1) - (float)(v62 * v66);
            CVector::Normalise(&vecForward);
            CrossProduct(&v94, &vecForward, &v60[42].m_vecNormal);
            vecRight = v94;
            CVector::Normalise(&vecRight);
            v67 = 0.0;
            if ( v23 )
              v67 = fDriveForce;
            if ( v92 == 1 )
            {
              v11.n64_f32[1] = v12 * vecRight.x;
              v11.n64_f32[0] = (float)(v12 * vecForward.z) - (float)(v13 * vecRight.z);
              v65.n64_f32[1] = (float)(v13 * vecForward.x) + (float)(v12 * vecRight.x);
              v68 = (float)(v12 * vecForward.y) - (float)(v13 * vecRight.y);
              v65.n64_f32[0] = (float)(v12 * vecForward.x) - (float)(v13 * vecRight.x);
              vecRight.z = (float)(v13 * vecForward.z) + (float)(v12 * vecRight.z);
              vecRight.y = (float)(v13 * vecForward.y) + (float)(v12 * vecRight.y);
              LODWORD(vecForward.z) = v11.n64_u32[0];
              vecRight.x = v65.n64_f32[1];
              vecForward.y = v68;
              LODWORD(vecForward.x) = v65.n64_u32[0];
            }
            v60[42].m_dataA.m_nSurfaceType = 60;
            v69 = v21 * SurfaceInfos_c::GetAdhesiveLimit(&g_surfaceInfos, v60 + 42);
            if ( *(_BYTE *)&this->m_info > 7u )
              goto LABEL_67;
            v70 = (char *)this + 44 * nWheel2;
            v71 = SurfaceInfos_c::GetWetMultiplier(&g_surfaceInfos, (unsigned __int8)v70[1883]);
            v72 = (unsigned __int8 *)(v70 + 1883);
            v73 = this->hFlagsLocal;
            v11.n64_u32[0] = 2.0;
            v65.n64_f32[0] = v24 * (float)((float)((float)(1.0 - v58[506]) * 4.0) * this->pHandling->fSuspensionForce);
            v69 = (float)(v69 * v71) * vmin_f32(v65, v11).n64_f32[0];
            if ( (v73 & 0x200000) != 0 )
            {
              if ( SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, *v72) > 2 )
              {
                v69 = v69 * 1.4;
LABEL_67:
                v95 = *((_DWORD *)v58 + 607);
                if ( CDamageManager::GetWheelStatus(&this->Damage, nWheel2) == 1 )
                {
                  v74 = (float *)(&dword_0 + 1);
                  v75 = v58 + 539;
                  v76 = v35 * (float)(v69 * this->Damage.fWheelDamageEffect);
                }
                else
                {
                  v76 = v35 * v69;
                  v75 = v58 + 539;
                  v74 = 0;
                }
                CVehicle::ProcessWheel(
                  this,
                  &vecForward,
                  &vecRight,
                  &aWheelSpeeds[nWheel2],
                  &aWheelOffsets[nWheel2],
                  this->nNoOfContactWheels,
                  v67,
                  fFrictionForce * v34,
                  v76,
                  (unsigned __int8)nWheel2,
                  v75,
                  (tWheelState *)&v95,
                  v74);
                v19 = bFrontWheels;
                if ( v23 )
                {
                  v77 = v95;
                  if ( this->m_fGasPedal < 0.0 && v95 == 1 )
                    v77 = 0;
                }
                else
                {
                  v77 = v95;
                }
                *((_DWORD *)v58 + 607) = v77;
                goto LABEL_77;
              }
              v73 = this->hFlagsLocal;
            }
            if ( (v73 & 0x100000) != 0 && SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, *v72) > 2 )
              v69 = v69 * 1.15;
            goto LABEL_67;
          }
          hFlagsLocal = this->hFlagsLocal;
        }
        if ( (hFlagsLocal & 0x100000) != 0 )
        {
          v53 = v23;
          if ( SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, *v51) > 2 )
            v48 = v48 * 1.15;
          goto LABEL_44;
        }
      }
      v53 = v23;
      goto LABEL_44;
    }
    v34 = 1.0;
    v35 = 1.0;
    goto LABEL_29;
  }
LABEL_77:
  if ( !v19 && (this->hFlagsLocal & 0x80000) == 0 )
  {
    if ( !this->nBrakesOn || !v23 )
      goto LABEL_88;
    v78 = this->m_aWheelState[1];
    v79 = v78 == WS_SPINNING;
    if ( v78 != WS_SPINNING )
      v79 = this->m_aWheelState[3] == WS_SPINNING;
    if ( v79 )
    {
      v80 = this->m_fTyreTemp + (float)(CTimer::ms_fTimeStep * 0.001);
      this->m_fTyreTemp = v80;
      if ( v80 > 3.0 )
        this->m_fTyreTemp = 3.0;
    }
    else
    {
LABEL_88:
      m_fTyreTemp = this->m_fTyreTemp;
      if ( m_fTyreTemp > 1.0 )
        this->m_fTyreTemp = (float)((float)(m_fTyreTemp + -1.0) * powf(0.995, CTimer::ms_fTimeStep)) + 1.0;
    }
  }
  if ( (this->pHandling->mFlags & 0x2000000) == 0 )
  {
    if ( v93[514] > 0.0 )
      goto LABEL_102;
    if ( fDriveForce == 0.0 || !v23 )
    {
      v82 = v93;
      v83 = v93 + 535;
      v84 = v93[535] * 0.95;
LABEL_100:
      *v83 = v84;
      goto LABEL_101;
    }
    v82 = v93;
    v83 = v93 + 535;
    v84 = v93[535];
    if ( fDriveForce <= 0.0 )
    {
      if ( v84 > -1.0 )
      {
        v85 = 0.05;
        goto LABEL_99;
      }
    }
    else if ( v84 < 1.0 )
    {
      v85 = -0.1;
LABEL_99:
      v84 = v84 + v85;
      goto LABEL_100;
    }
LABEL_101:
    v82[527] = v82[527] + (float)(v84 * CTimer::ms_fTimeStep);
LABEL_102:
    v86 = (float *)(&this->_vptr$CPlaceable + nWheel2);
    if ( v86[514] > 0.0 )
      return;
    if ( fDriveForce == 0.0 || !v23 )
    {
      v87 = v86 + 535;
      v88 = v86[535] * 0.95;
LABEL_111:
      *v87 = v88;
      goto LABEL_112;
    }
    v87 = v86 + 535;
    v88 = v86[535];
    if ( fDriveForce <= 0.0 )
    {
      if ( v88 > -1.0 )
      {
        v89 = 0.05;
        goto LABEL_110;
      }
    }
    else if ( v88 < 1.0 )
    {
      v89 = -0.1;
LABEL_110:
      v88 = v88 + v89;
      goto LABEL_111;
    }
LABEL_112:
    v86[527] = v86[527] + (float)(v88 * CTimer::ms_fTimeStep);
  }
}
// 556C16: variable 'v10' is possibly undefined
// 556C16: variable 'v11' is possibly undefined
// 556E08: variable 'v12' is possibly undefined
// 556E2C: variable 'v13' is possibly undefined
// 0: using guessed type int dword_0;

//----- (005574F8) --------------------------------------------------------
void __fastcall CAutomobile::ProcessHarvester(CAutomobile *this)
{
  CMatrix *m_pMat; // r10
  CObjectPool *v3; // r8
  int32 v4; // r0
  int v5; // r5
  int v6; // r6
  uint8 *v7; // r0
  int v8; // r3
  bool v9; // zf
  CMatrix *v10; // r4
  int v11; // r2
  CSimpleTransform *p_m_transform; // r3
  float *v13; // r4
  float v14; // s0
  float v15; // s2
  float v16; // s4
  float v17; // s6
  CPedPool *v18; // r11
  int32 m_nSize; // r0
  int v20; // r4
  int v21; // r5
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r8
  uint8 *v23; // r6
  CMatrix *v24; // r0
  int v25; // r1
  CSimpleTransform *p_tx; // r2
  float *v27; // r0
  float v28; // s0
  float v29; // s2
  float v30; // s4
  float v31; // s6
  float xy; // s20
  float yy; // s22
  int32 v34; // r4
  __int16 **v35; // r0
  CObject *v36; // r6
  CPlaceable *v37; // r0
  RwReal y; // r1
  CMatrix *v39; // r3
  RwReal z; // r0
  RwReal *p_tz; // r1
  __int64 v42; // d16
  float v43; // s18
  float v44; // s20
  float v45; // s0
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *v48; // r0
  RwMatrix *v49; // r1
  FxPrtMult_c v; // [sp+1Ch] [bp-84h] BYREF
  RwV3d_0 vel; // [sp+38h] [bp-68h] BYREF
  CVector v52; // [sp+44h] [bp-5Ch] BYREF

  if ( *(_BYTE *)&this->m_info <= 7u )
  {
    CStreaming::m_bStreamHarvesterModelsThisFrame = 1;
    m_pMat = this->m_pMat;
    if ( sqrtf(
           (float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y)) > 0.01 )
    {
      if ( (unsigned __int8)CTimer::m_FrameCounter << 31 )
      {
        v18 = CPools::ms_pPedPool;
        m_nSize = CPools::ms_pPedPool->m_nSize;
        if ( m_nSize )
        {
          v20 = m_nSize - 1;
          v21 = 1996 * m_nSize - 1996;
          do
          {
            if ( (v18->m_aFlags[v20] & 0x80u) == 0 )
            {
              m_aStorage = v18->m_aStorage;
              v23 = &(*v18->m_aStorage)[v21];
              if ( v23 )
              {
                if ( !CPed::IsPlayer((const CPed *)&(*v18->m_aStorage)[v21]) )
                {
                  v24 = this->m_pMat;
                  v25 = *((_DWORD *)v23 + 5);
                  p_tx = (CSimpleTransform *)&v24->tx;
                  if ( !v24 )
                    p_tx = &this->m_transform;
                  v27 = (float *)(v25 + 48);
                  if ( !v25 )
                    v27 = (float *)(v23 + 4);
                  v28 = *v27 - p_tx->m_translate.x;
                  v29 = v27[1] - p_tx->m_translate.y;
                  v30 = v27[2] - p_tx->m_translate.z;
                  v31 = (float)((float)(v28 * m_pMat->xy) + (float)(v29 * m_pMat->yy)) + (float)(v30 * m_pMat->zy);
                  if ( v31 > 4.0
                    && v31 < 5.0
                    && fabsf((float)((float)(v28 * m_pMat->xx) + (float)(v29 * m_pMat->yx)) + (float)(v30 * m_pMat->zx)) < 4.0
                    && fabsf((float)((float)(v28 * m_pMat->xz) + (float)(v29 * m_pMat->yz)) + (float)(v30 * m_pMat->zz)) < 4.0 )
                  {
                    (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[v21] + 88))(v23);
                    this->m_HarvesterTimer = 20;
                    CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 115, 0.0);
                  }
                }
              }
            }
            --v20;
            v21 -= 1996;
          }
          while ( v20 != -1 );
        }
      }
      else
      {
        v3 = CPools::ms_pObjectPool;
        v4 = CPools::ms_pObjectPool->m_nSize;
        if ( v4 )
        {
          v5 = v4 - 1;
          v6 = 420 * v4 - 420;
          do
          {
            if ( (v3->m_aFlags[v5] & 0x80u) == 0 )
            {
              v7 = &(*v3->m_aStorage)[v6];
              if ( v7 )
              {
                v8 = *((__int16 *)v7 + 19);
                v9 = v8 == MI_GRASSHOUSE;
                if ( v8 != MI_GRASSHOUSE )
                  v9 = v8 == MI_GRASSPLANT;
                if ( v9 && (*((_DWORD *)v7 + 7) & 0x280) == 0x80 )
                {
                  v10 = this->m_pMat;
                  v11 = *((_DWORD *)v7 + 5);
                  p_m_transform = (CSimpleTransform *)&v10->tx;
                  if ( !v10 )
                    p_m_transform = &this->m_transform;
                  v13 = (float *)(v11 + 48);
                  if ( !v11 )
                    v13 = (float *)(v7 + 4);
                  v14 = *v13 - p_m_transform->m_translate.x;
                  v15 = v13[1] - p_m_transform->m_translate.y;
                  v16 = v13[2] - p_m_transform->m_translate.z;
                  v17 = (float)((float)(v14 * m_pMat->xy) + (float)(v15 * m_pMat->yy)) + (float)(v16 * m_pMat->zy);
                  if ( v17 > 4.0
                    && v17 < 5.0
                    && fabsf((float)((float)(v14 * m_pMat->xx) + (float)(v15 * m_pMat->yx)) + (float)(v16 * m_pMat->zx)) < 4.0
                    && fabsf((float)((float)(v14 * m_pMat->xz) + (float)(v15 * m_pMat->yz)) + (float)(v16 * m_pMat->zz)) < 4.0 )
                  {
                    CObject::ObjectDamage((CObject *)v7, 99999.0, 0, 0, (int)this, WEAPONTYPE_RUNOVERBYCAR);
                  }
                }
              }
            }
            --v5;
            v6 -= 420;
          }
          while ( v5 != -1 );
        }
      }
    }
    if ( this->m_HarvesterTimer )
    {
      v.m_green = -3.8;
      v.m_red = -1.2;
      v.m_blue = 1.5;
      operator*(&v52, m_pMat, (const CVector *)&v);
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      vel.z = m_pMat->zy * -0.1;
      vel.x = (float)(xy * -0.1) + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.1) + -0.05);
      v34 = -1;
      vel.y = (float)(yy * -0.1) + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.1) + -0.05);
      switch ( this->m_HarvesterTimer )
      {
        case 1u:
          v35 = (__int16 **)&MI_HARVESTERBODYPART1_ptr;
          goto LABEL_47;
        case 2u:
          v35 = MI_HARVESTERBODYPART2_ptr;
          goto LABEL_47;
        case 3u:
          v35 = &MI_HARVESTERBODYPART3_ptr;
          goto LABEL_47;
        case 4u:
          v35 = MI_HARVESTERBODYPART2_ptr;
          goto LABEL_47;
        case 6u:
          v35 = &MI_HARVESTERBODYPART4_ptr;
          goto LABEL_47;
        case 7u:
          v35 = (__int16 **)&MI_HARVESTERBODYPART1_ptr;
LABEL_47:
          v34 = (unsigned __int16)**v35;
          break;
        default:
          break;
      }
      if ( !CLocalisation::ShootLimbs() )
        v34 = -1;
      if ( v34 >= 0 )
      {
        v36 = (CObject *)CObject::operator new(0x184u);
        CObject::CObject(v36, v34, 1);
        CPlaceable::SetMatrix(v37, m_pMat);
        y = v52.y;
        v39 = v36->m_pMat;
        z = v52.z;
        if ( v39 )
        {
          v39->tx = v52.x;
          v36->m_pMat->ty = y;
          p_tz = &v36->m_pMat->tz;
        }
        else
        {
          v36->m_transform.m_translate.x = v52.x;
          v36->m_transform.m_translate.y = y;
          p_tz = &v36->m_transform.m_translate.z;
        }
        *p_tz = z;
        v42 = *(_QWORD *)&vel.x;
        v36->m_vecMoveSpeed.z = vel.z;
        *(_QWORD *)&v36->m_vecMoveSpeed.x = v42;
        v43 = (float)rand();
        v44 = (float)rand();
        v45 = (float)rand();
        m_pRwObject = v36->m_pRwObject;
        v36->ObjectCreatedBy = 3;
        v36->m_vecTurnSpeed.x = (float)((float)(v43 * 4.6566e-10) * 0.08) + -0.04;
        v36->m_vecTurnSpeed.y = (float)((float)(v44 * 4.6566e-10) * 0.08) + -0.04;
        v36->m_vecTurnSpeed.z = (float)((float)(v45 * 4.6566e-10) * 0.08) + -0.04;
        if ( m_pRwObject )
        {
          parent = (char *)m_pRwObject->parent;
          v48 = v36->m_pMat;
          v49 = (RwMatrix *)(parent + 16);
          if ( v48 )
            CMatrix::UpdateRwMatrix(v48, v49);
          else
            CSimpleTransform::UpdateRwMatrix(&v36->m_transform, v49);
        }
        CEntity::UpdateRwFrame(v36);
        (*((void (__fastcall **)(CObject *, _DWORD))v36->_vptr$CPlaceable + 5))(v36, 0);
        ++CObject::nNoTempObjects;
        CWorld::Add(v36);
      }
      --this->m_HarvesterTimer;
      if ( CLocalisation::Blood() )
      {
        if ( !(this->m_HarvesterTimer % 3u) )
        {
          FxPrtMult_c::FxPrtMult_c(&v);
          FxPrtMult_c::SetUp(&v, 0.15, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0);
          FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, &v52, &vel, 0.0, &v, -1.0, 1.2, 0.6, 0);
        }
      }
    }
  }
}
// 557920: variable 'v37' is possibly undefined
// 676C84: using guessed type int CPools::ms_pPedPool[2];
// 6772A4: using guessed type __int16 *MI_HARVESTERBODYPART4_ptr;
// 678518: using guessed type __int16 *MI_HARVESTERBODYPART2_ptr[2];
// 678D20: using guessed type __int16 *MI_HARVESTERBODYPART3_ptr;

//----- (00557AD0) --------------------------------------------------------
bool __fastcall CAutomobile::ProcessAI(CAutomobile *this, uint32 *nProcContFlags)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d12
  CColModel *ColModel; // r9
  int RecordingNumber; // r0
  const CVector *v10; // r0
  const CVector *PlayerSpeed; // r0
  CMatrix *m_pMat; // r5
  CSimpleTransform *p_tx; // r0
  float32x2_t v14; // d16
  uint32 v15; // r0
  unsigned int m_info; // r0
  CEntity::CEntityInfo *p_m_info; // r5
  uint32 hFlagsLocal; // r1
  CCollisionData *Mission; // r2
  bool v20; // zf
  tHandlingData *pHandling; // r1
  __int64 v22; // d16
  unsigned int v23; // r0
  unsigned int v24; // r0
  int m_nModelIndex; // r0
  bool v26; // zf
  CMatrix *v27; // r1
  CSimpleTransform *p_m_transform; // r0
  float xx; // s10
  float v30; // s4
  float yx; // s12
  float v32; // s2
  float zx; // s14
  float v34; // s0
  float x; // s6
  float y; // s1
  unsigned int v37; // r0
  _BOOL4 v38; // r6
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r8
  int v40; // r0
  CVehicle::CVehicleFlags v41; // r0
  int v42; // r0
  bool v43; // zf
  float v44; // s4
  float z; // s6
  float v46; // s2
  float v47; // s0
  tHandlingData *v48; // r0
  float v49; // s0
  UInt8 m_nDriveWheelsOnGround; // r2
  float32x4_t v51; // q8
  int v52; // r0
  UInt32 m_cHorn; // r0
  int32 m_vehicleType; // r1
  CVehicle::CVehicleFlags v55; // r0
  int v56; // r2
  int *v57; // r3
  float v58; // s0
  int v59; // r1
  bool v60; // zf
  CPad *Pad; // r0
  void (__fastcall *v62)(CAutomobile *, CPlayerPed *, _DWORD); // r6
  CPlayerPed *PlayerPed; // r0
  int v64; // r0
  bool v65; // zf
  void (__fastcall *v66)(CAutomobile *, CPlayerPed *, _DWORD); // r6
  CPlayerPed *v67; // r0
  CPed *pDriver; // r0
  CPed **p_pDriver; // r11
  unsigned int v70; // r1
  CVehicle *m_pTowingVehicle; // r0
  tHandlingData *v72; // r2
  __int64 v73; // d16
  int CarAlarmState; // r5
  bool v75; // zf
  CPed *v76; // r0
  CPed *v77; // r0
  int v78; // r0
  bool v79; // zf
  CPad *PadFromPlayer; // r8
  Int32 m_nPedType; // r0
  float v82; // s0
  int32 v83; // r1
  int v84; // r0
  UInt32 nCarLess3WheelCounter; // r0
  unsigned int v86; // r0
  float v87; // s0
  CMatrix *v88; // r0
  float v89; // s0
  float v90; // s16
  float v91; // s18
  float v92; // s20
  float v93; // s0
  int32 v94; // r0
  float v95; // s18
  float m_fTurnMass; // s22
  float v97; // s20
  float v98; // s16
  float32x2_t v99; // d0
  float v100; // s22
  float v101; // s18
  CMatrix *v102; // r0
  float v103; // s2
  float v104; // s4
  float v105; // s6
  float xy; // s8
  float yy; // s10
  float v108; // s0
  float zy; // s12
  float v110; // s0
  CMatrix *v111; // r0
  float v112; // s0
  CMatrix *v114; // r0
  CVector bCheckBuildings; // [sp+0h] [bp-A8h]
  CVector bCheckBuildingsa; // [sp+0h] [bp-A8h]
  CEntity *refEntityPtr; // [sp+24h] [bp-84h] BYREF
  CColPoint v118; // [sp+28h] [bp-80h] BYREF
  CVector vecEnd; // [sp+54h] [bp-54h] BYREF
  CVector v120; // 0:r1.12
  CVector v121; // 0:r1.12
  CVector v122; // 0:r1.12

  ColModel = CEntity::GetColModel(this);
  RecordingNumber = this->AutoPilot.RecordingNumber;
  *(_WORD *)((char *)&this->AutoPilot + 75) &= 0xFFFCu;
  if ( RecordingNumber >= 0 && !CVehicleRecording::bUseCarAI[RecordingNumber] )
  {
LABEL_187:
    LOBYTE(v38) = 0;
    return v38;
  }
  if ( !FindPlayerVehicle(-1, 0)
    || this == FindPlayerVehicle(-1, 0)
    || FindPlayerPed(-1)->m_pPlayerData->m_Wanted->m_WantedLevel < WANTED_LEVEL4
    || (unsigned __int8)(this->AutoPilot.Mission - 2) > 3u
    || (v10 = FindPlayerSpeed(-1),
        sqrtf((float)((float)(v10->x * v10->x) + (float)(v10->y * v10->y)) + (float)(v10->z * v10->z)) <= 0.3) )
  {
    if ( this->m_nModelIndex == 441 && (*(_BYTE *)&this->m_info & 0xF8) != 64 )
    {
      v15 = *nProcContFlags | 1;
      goto LABEL_17;
    }
  }
  else
  {
    *nProcContFlags |= 1u;
    PlayerSpeed = FindPlayerSpeed(-1);
    if ( sqrtf(
           (float)((float)(PlayerSpeed->x * PlayerSpeed->x) + (float)(PlayerSpeed->y * PlayerSpeed->y))
         + (float)(PlayerSpeed->z * PlayerSpeed->z)) > 0.4
      && sqrtf(
           (float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                 + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
         + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) < 0.3 )
    {
      goto LABEL_13;
    }
    m_pMat = this->m_pMat;
    FindPlayerCoors(&v118.m_vecPosition, -1);
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    v14.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&v118.m_vecPosition.y).n64_u64[0];
    v2.n64_u64[0] = vmul_f32(v14, v14).n64_u64[0];
    if ( sqrtf(
           (float)((float)((float)(p_tx->m_translate.x - v118.m_vecPosition.x)
                         * (float)(p_tx->m_translate.x - v118.m_vecPosition.x))
                 + v2.n64_f32[0])
         + v2.n64_f32[1]) > 50.0 )
    {
LABEL_13:
      v15 = *nProcContFlags | 2;
LABEL_17:
      *nProcContFlags = v15;
    }
  }
  if ( *nProcContFlags << 31 || CCheat::m_aCheatsActive[35] )
  {
    p_m_info = &this->m_info;
    m_info = (unsigned __int8)this->m_info;
    this->m_vecCOM.z = (float)(this->m_fSuspensionLength[0] * 0.3) - this->m_fHeightAboveRoad;
LABEL_29:
    v23 = m_info >> 3;
    goto LABEL_30;
  }
  p_m_info = &this->m_info;
  m_info = (unsigned __int8)this->m_info;
  if ( (m_info & 0xF8) != 24 )
  {
    pHandling = this->pHandling;
    v22 = *(_QWORD *)&pHandling->CentreOfMass.x;
    this->m_vecCOM.z = pHandling->CentreOfMass.z;
    *(_QWORD *)&this->m_vecCOM.x = v22;
    goto LABEL_29;
  }
  hFlagsLocal = this->hFlagsLocal;
  if ( (hFlagsLocal & 0x10000) != 0 )
  {
    Mission = (CCollisionData *)(unsigned __int8)this->AutoPilot.Mission;
    v20 = Mission == 0;
    if ( this->AutoPilot.Mission )
    {
      Mission = ColModel->m_pColData;
      v20 = Mission == 0;
    }
    if ( v20 || Mission->_anon_0.m_nNoOfLines < 1 )
    {
      v72 = this->pHandling;
      hFlagsLocal &= ~8u;
      v73 = *(_QWORD *)&v72->CentreOfMass.x;
      this->m_vecCOM.z = v72->CentreOfMass.z;
      *(_QWORD *)&this->m_vecCOM.x = v73;
    }
    else
    {
      hFlagsLocal |= 8u;
      this->m_vecCOM.y = (float)(Mission->_anon_1.m_pLineArray->m_vecStart.y
                               + Mission->_anon_1.m_pLineArray[1].m_vecStart.y)
                       * 0.5;
    }
    this->hFlagsLocal = hFlagsLocal;
  }
  v23 = m_info >> 3;
  if ( (hFlagsLocal & 4) != 0 )
    this->m_vecCOM.z = this->pHandling->CentreOfMass.z
                     + (float)((float)(ColModel->m_boxBound.m_vecMin.z - this->pHandling->CentreOfMass.z) * 0.4);
LABEL_30:
  v24 = v23 & 0x1F;
  if ( (v24 > 9 || ((1 << v24) & 0x331) == 0) && *(_BYTE *)&this->m_nVehicleFlags << 31 )
    CAutomobile::ScanForCrimes(this);
  if ( (*((_DWORD *)&this->m_nVehicleFlags + 1) & 0xC) == 8
    && this->VehicleCreatedBy != 2
    && this->AutoPilot.Mission == 1
    && !((CTimer::m_FrameCounter + this->RandomSeed) << 28) )
  {
    m_nModelIndex = this->m_nModelIndex;
    v26 = m_nModelIndex == 420;
    if ( m_nModelIndex != 420 )
      v26 = m_nModelIndex == 438;
    if ( !v26 )
    {
      v27 = this->m_pMat;
      p_m_transform = (CSimpleTransform *)&v27->tx;
      xx = v27->xx;
      v30 = v27->yy * 10.0;
      yx = v27->yx;
      v32 = v27->xy * 10.0;
      zx = v27->zx;
      v34 = v27->zy * 10.0;
      if ( !v27 )
        p_m_transform = &this->m_transform;
      x = p_m_transform->m_translate.x;
      y = p_m_transform->m_translate.y;
      v2.n64_u32[1] = LODWORD(p_m_transform->m_translate.z);
      refEntityPtr = 0;
      vecEnd.y = (float)(v30 + y) + (float)(yx * 3.0);
      vecEnd.x = (float)(v32 + x) + (float)(xx * 3.0);
      vecEnd.z = (float)(v34 + v2.n64_f32[1]) + (float)(zx * 3.0);
      if ( CWorld::ProcessLineOfSight(
             &p_m_transform->m_translate,
             &vecEnd,
             &v118,
             &refEntityPtr,
             1,
             1,
             1,
             0,
             0,
             0,
             0,
             0) != 1
        || refEntityPtr == this )
      {
        CCarAI::GetCarToParkAtCoors(this, &vecEnd);
      }
    }
  }
  v37 = (unsigned int)*p_m_info;
  LOBYTE(v38) = 0;
  p_m_nVehicleFlags = &this->m_nVehicleFlags;
  switch ( v37 >> 3 )
  {
    case 0u:
      goto LABEL_103;
    case 2u:
      CCarAI::UpdateCarAI(this);
      CPhysical::ProcessControl(this);
      CCarCtrl::UpdateCarOnRails(this);
      v48 = this->pHandling;
      v49 = this->AutoPilot.ActualSpeed / 50.0;
      m_nDriveWheelsOnGround = this->m_nDriveWheelsOnGround;
      this->nNoOfContactWheels = 4;
      this->m_nDriveWheelsOnGround = 4;
      this->m_nDriveWheelsOnGroundLastFrame = m_nDriveWheelsOnGround;
      cTransmission::CalculateGearForSimpleCar(&v48->Transmission, v49, &this->m_nCurrentGear);
      v51 = vaddq_f32(
              vdupq_n_s32(
                COERCE_UNSIGNED_INT(
                  CVehicle::ProcessWheelRotation(
                    this,
                    WS_ROLLING,
                    (const CVector *)&this->m_pMat->xy,
                    &this->m_vecMoveSpeed,
                    0.35))),
              *(float32x4_t *)this->m_aWheelPitchAngles);
      v52 = *((unsigned __int8 *)&this->AutoPilot + 75) << 30;
      *(float32x4_t *)this->m_aWheelPitchAngles = v51;
      if ( v52 && !CAutomobile::HasCarStoppedBecauseOfLight(this) )
        (*((void (__fastcall **)(CAutomobile *))this->_vptr$CPlaceable + 55))(this);
      m_cHorn = this->m_cHorn;
      LOBYTE(v38) = 1;
      if ( m_cHorn )
        this->m_cHorn = m_cHorn - 1;
      *(_DWORD *)p_m_nVehicleFlags &= 0xDEFFFFFF;
      return v38;
    case 3u:
    case 0xCu:
      CCarAI::UpdateCarAI(this);
      CCarCtrl::SteerAICarWithPhysics(this);
      CCarCtrl::ReconsiderRoute(this);
      if ( *((unsigned __int8 *)&this->AutoPilot + 75) << 30 && !CAutomobile::HasCarStoppedBecauseOfLight(this) )
        (*((void (__fastcall **)(CAutomobile *))this->_vptr$CPlaceable + 55))(this);
      v40 = *(_DWORD *)p_m_nVehicleFlags;
      if ( (*(_DWORD *)p_m_nVehicleFlags & 0x80000) != 0 )
      {
        *((_DWORD *)&v41 + 1) = *((_DWORD *)&this->m_nVehicleFlags + 1);
        this->m_fGasPedal = 0.0;
        this->m_fBrakePedal = 1.0;
        *(_DWORD *)&v41 = v40 | 0x20;
        *p_m_nVehicleFlags = v41;
      }
      if ( (this->m_aWheelRatios[0] >= 1.0
         || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[0].m_dataB.m_nSurfaceType) != 4)
        && (this->m_aWheelRatios[1] >= 1.0
         || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[1].m_dataB.m_nSurfaceType) != 4)
        && (this->m_aWheelRatios[2] >= 1.0
         || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[2].m_dataB.m_nSurfaceType) != 4)
        && (this->m_aWheelRatios[3] >= 1.0
         || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[3].m_dataB.m_nSurfaceType) != 4) )
      {
        goto LABEL_187;
      }
      v42 = this->m_nModelIndex;
      LOBYTE(v38) = 0;
      if ( v42 == 424 )
        return v38;
      v43 = v42 == 441;
      if ( v42 != 441 )
        v43 = v42 == 495;
      if ( v43 )
        return v38;
      *(_BYTE *)&this->m_nAutomobileFlags |= 0x40u;
      if ( CWeather::WetRoads <= 0.0 )
      {
        v47 = this->m_fMass * -0.005;
        v46 = this->m_vecMoveSpeed.x;
        v44 = this->m_vecMoveSpeed.y;
        z = this->m_vecMoveSpeed.z;
      }
      else
      {
        v44 = this->m_vecMoveSpeed.y;
        z = this->m_vecMoveSpeed.z;
        v46 = this->m_vecMoveSpeed.x;
        v47 = (float)((float)(1.0 - CWeather::WetRoads) * -0.005) * this->m_fMass;
      }
      v82 = v47 * CTimer::ms_fTimeStep;
      v120.x = v46 * v82;
      v120.y = v82 * v44;
      v120.z = v82 * z;
      CPhysical::ApplyMoveForce(this, v120);
      goto LABEL_187;
    case 4u:
      if ( this->m_aGroundPhysicalPtrs[0] )
        *((_DWORD *)&this->m_nVehicleFlags + 1) |= 2u;
      if ( this->m_aGroundPhysicalPtrs[1] )
        *((_DWORD *)&this->m_nVehicleFlags + 1) |= 2u;
      if ( this->m_aGroundPhysicalPtrs[2] )
        *((_DWORD *)&this->m_nVehicleFlags + 1) |= 2u;
      if ( this->m_aGroundPhysicalPtrs[3] )
        *((_DWORD *)&this->m_nVehicleFlags + 1) |= 2u;
      m_vehicleType = this->m_vehicleType;
      if ( m_vehicleType == 3
        || m_vehicleType == 4
        && (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                 + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) < 0.1 )
      {
        this->m_fBrakePedal = 1.0;
      }
      *((_DWORD *)&v55 + 1) = *((_DWORD *)&this->m_nVehicleFlags + 1);
      v56 = *(_DWORD *)p_m_nVehicleFlags;
      if ( (*((_BYTE *)&v55 + 4) & 2) != 0 )
      {
        v58 = 0.5;
      }
      else
      {
        v57 = &dword_558934;
        if ( (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                           + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                   + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) < 0.01 )
          v57 = &dword_558938;
        v58 = *(float *)v57;
      }
      this->m_fBrakePedal = v58;
      *(_DWORD *)p_m_nVehicleFlags = v56 & 0xFFFFFFDF;
      *((_DWORD *)&this->m_nVehicleFlags + 1) = *((_DWORD *)&v55 + 1);
      this->m_fGasPedal = 0.0;
      this->m_fSteerAngle = 0.0;
      CarAlarmState = this->CarAlarmState;
      v75 = CarAlarmState == 0;
      if ( this->CarAlarmState )
        v75 = CarAlarmState == 0xFFFF;
      if ( v75 )
      {
        this->m_cHorn = 0;
      }
      else if ( (v37 & 0xF8) == 40 )
      {
        this->m_cHorn = 0;
      }
      LOBYTE(v38) = 0;
      if ( (v56 & 0x80000) != 0 )
      {
        this->m_fGasPedal = 0.0;
        *(_DWORD *)&v55 = v56 | 0x20;
        *p_m_nVehicleFlags = v55;
        this->m_fBrakePedal = 1.0;
      }
      return v38;
    case 5u:
      LOBYTE(v38) = 0;
      *(_DWORD *)p_m_nVehicleFlags |= 0x20u;
      v59 = this->CarAlarmState;
      this->m_fGasPedal = 0.0;
      v60 = v59 == 0;
      this->m_fBrakePedal = 0.05;
      this->m_fSteerAngle = 0.0;
      if ( v59 )
        v60 = v59 == 0xFFFF;
      if ( !v60 )
        goto LABEL_132;
      goto LABEL_133;
    case 8u:
      if ( !CVehicle::bDisableRemoteDetonation )
      {
        Pad = CPad::GetPad(0);
        if ( CPad::CarGunJustDown(Pad) )
        {
          v62 = (void (__fastcall *)(CAutomobile *, CPlayerPed *, _DWORD))*((_DWORD *)this->_vptr$CPlaceable + 42);
          PlayerPed = FindPlayerPed(-1);
          v62(this, PlayerPed, 0);
          CRemote::TakeRemoteControlledCarFromPlayer(1);
        }
      }
      if ( this->m_nModelIndex == 441 && !CVehicle::bDisableRemoteDetonationOnContact )
      {
        FindPlayerCoors(&v118.m_vecPosition, -1);
        v64 = CAutomobile::RcbanditCheckHitWheels(this);
        v65 = v64 == 0;
        if ( !v64 )
          v65 = *((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31 == 0;
        if ( !v65 )
        {
          CRemote::TakeRemoteControlledCarFromPlayer(1);
          v66 = (void (__fastcall *)(CAutomobile *, CPlayerPed *, _DWORD))*((_DWORD *)this->_vptr$CPlaceable + 42);
          v67 = FindPlayerPed(-1);
          v66(this, v67, 0);
        }
      }
      if ( CWorld::Players[CWorld::PlayerInFocus].pRemoteVehicle == this )
      {
        pDriver = this->pDriver;
        if ( !pDriver )
        {
          CEntity::PruneReferences(this);
          PadFromPlayer = 0;
          goto LABEL_146;
        }
        p_pDriver = &this->pDriver;
        v38 = 1;
LABEL_140:
        PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pDriver);
        CEntity::PruneReferences(this);
        if ( !v38 )
        {
          m_nPedType = (*p_pDriver)->m_nPedType;
          if ( (unsigned int)m_nPedType > 1 )
          {
LABEL_148:
            if ( *(_BYTE *)p_m_info <= 7u )
            {
              v83 = this->m_vehicleType;
              if ( v83 != 3 )
              {
                v84 = (unsigned __int16)this->m_nModelIndex;
                if ( (v83 != 4 || v84 == 539) && (__int16)v84 != 432 && (__int16)v84 != 601 )
                  CVehicle::DoDriveByShootings(this);
              }
            }
            nCarLess3WheelCounter = CWorld::Players[CWorld::PlayerInFocus].nCarLess3WheelCounter;
            if ( nCarLess3WheelCounter > 0x1F4 && (unsigned int)(this->m_vehicleType - 3) >= 2 )
            {
              v86 = nCarLess3WheelCounter - 500;
              if ( v86 >= 0x3E8 )
                v86 = 1000;
              v87 = (float)v86;
              if ( PadFromPlayer && (v88 = this->m_pMat, v88->zz > -0.4) )
              {
                v89 = v87 / 500.0;
                v90 = -v89;
                v92 = CAR_BALANCE_MULT;
                if ( v88->zx > 0.0 )
                  v90 = v89;
                v91 = this->pHandling->CentreOfMass.z;
                v93 = v91
                    + (float)(ColModel->m_boxBound.m_vecMax.z
                            * (float)((float)(v90 * v92)
                                    * (float)((float)CPad::GetSteeringLeftRight(PadFromPlayer) * 0.0078125)));
              }
              else
              {
                v93 = this->pHandling->CentreOfMass.z
                    + (float)((float)(CAR_BALANCE_MULT * -0.5) * ColModel->m_boxBound.m_vecMax.z);
              }
              this->m_vecCOM.z = v93;
              if ( !PadFromPlayer )
                goto LABEL_186;
            }
            else
            {
              this->m_vecCOM.z = this->pHandling->CentreOfMass.z;
              if ( !PadFromPlayer )
              {
LABEL_186:
                CAutomobile::DoSoftGroundResistance(this, nProcContFlags);
                goto LABEL_187;
              }
            }
            if ( this->nNoOfContactWheels )
              goto LABEL_186;
            v94 = this->m_vehicleType;
            if ( (unsigned int)(v94 - 3) < 2 )
              goto LABEL_186;
            if ( v94 == 1 )
              v95 = 0.0025;
            else
              v95 = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_CAR_INAIR_BALANCE) * 0.0007;
            m_fTurnMass = this->m_fTurnMass;
            v3.n64_u32[0] = 1.0;
            v97 = (float)CPad::GetSteeringLeftRight(PadFromPlayer) * 0.0078125;
            v98 = (float)CPad::GetSteeringUpDown(PadFromPlayer) * 0.0078125;
            v5.n64_f32[0] = 3000.0 / m_fTurnMass;
            v99.n64_u64[0] = vmin_f32(v5, v3).n64_u64[0];
            v100 = m_fTurnMass * v99.n64_f32[0];
            if ( CHID::GetInputType() == 2 && fabsf(v97) < 0.05 )
            {
              v4.n64_u32[0] = -1.5;
              v3.n64_f32[0] = CPad::NewMouseControllerState.m_AmountMoved.y * 0.02;
              v99.n64_f32[0] = CPad::NewMouseControllerState.m_AmountMoved.x * 0.02;
              v2.n64_u32[0] = 1.5;
              LODWORD(v98) = vmin_f32(vmax_f32(v3, v4), v2).n64_u32[0];
              LODWORD(v97) = vmin_f32(vmax_f32(v99, v4), v2).n64_u32[0];
            }
            v101 = v95 * v100;
            if ( CPad::GetHandBrake(PadFromPlayer) )
            {
              v102 = this->m_pMat;
              if ( v97 < 0.0 || v97 > 0.0 )
              {
                v103 = v102->xx;
                v104 = v102->yx;
                v105 = v102->zx;
                xy = v102->xy;
                yy = v102->yy;
                v108 = CTimer::ms_fTimeStep;
                zy = v102->zy;
LABEL_180:
                v110 = v101 * (float)(v97 * v108);
                v121.x = v103 * v110;
                v121.y = v110 * v104;
                v121.z = v110 * v105;
                bCheckBuildings.x = this->m_vecCOM.x + xy;
                bCheckBuildings.y = this->m_vecCOM.y + yy;
                bCheckBuildings.z = this->m_vecCOM.z + zy;
                CPhysical::ApplyTurnForce(this, v121, bCheckBuildings);
              }
            }
            else if ( !CPad::GetAccelerate(PadFromPlayer) )
            {
              v114 = this->m_pMat;
              if ( v97 < 0.0 || v97 > 0.0 )
              {
                v103 = v114->xx;
                v104 = v114->yx;
                v105 = v114->zx;
                xy = v114->xz;
                yy = v114->yz;
                v108 = CTimer::ms_fTimeStep;
                zy = v114->zz;
                goto LABEL_180;
              }
            }
            if ( !CPad::GetAccelerate(PadFromPlayer) )
            {
              v111 = this->m_pMat;
              if ( v98 < 0.0 || v98 > 0.0 )
              {
                v112 = v101 * (float)(v98 * CTimer::ms_fTimeStep);
                v122.x = v111->xz * v112;
                v122.y = v112 * v111->yz;
                v122.z = v112 * v111->zz;
                bCheckBuildingsa.x = this->m_vecCOM.x + v111->xy;
                bCheckBuildingsa.y = this->m_vecCOM.y + v111->yy;
                bCheckBuildingsa.z = this->m_vecCOM.z + v111->zy;
                CPhysical::ApplyTurnForce(this, v122, bCheckBuildingsa);
              }
            }
            goto LABEL_186;
          }
LABEL_147:
          (*((void (__fastcall **)(CAutomobile *, _DWORD))this->_vptr$CPlaceable + 25))(
            this,
            (unsigned __int8)m_nPedType);
          goto LABEL_148;
        }
LABEL_146:
        m_nPedType = CWorld::FindPlayerSlotWithRemoteVehiclePointer(this);
        if ( m_nPedType < 0 )
          goto LABEL_148;
        goto LABEL_147;
      }
LABEL_103:
      pDriver = this->pDriver;
      if ( !pDriver )
        goto LABEL_187;
      p_pDriver = &this->pDriver;
      v38 = 0;
      v70 = pDriver->m_nPedState - 58;
      if ( v70 > 5 || ((1 << v70) & 0x29) == 0 )
        goto LABEL_140;
      break;
    case 9u:
      if ( (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                 + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) < 0.01
        || (v76 = this->pDriver) != 0
        && CPed::IsPlayer(v76)
        && ((v77 = this->pDriver, v77->m_nPedState == PED_ARRESTED)
         || CTaskManager::FindActiveTaskByType(&v77->m_pPedIntelligence->m_taskManager, 823)
         || CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 825)
         || CTaskManager::FindActiveTaskByType(&this->pDriver->m_pPedIntelligence->m_taskManager, 809)) )
      {
        *(_DWORD *)p_m_nVehicleFlags |= 0x20u;
        this->m_fGasPedal = 0.0;
        this->m_fBrakePedal = 1.0;
      }
      else
      {
        this->m_fBrakePedal = 0.0;
        *(_DWORD *)p_m_nVehicleFlags &= ~0x20u;
      }
      LOBYTE(v38) = 0;
      this->m_fSteerAngle = 0.0;
      this->m_fGasPedal = 0.0;
      v78 = this->CarAlarmState;
      v79 = v78 == 0;
      if ( this->CarAlarmState )
        v79 = v78 == 0xFFFF;
      if ( v79 )
        goto LABEL_133;
      LOBYTE(v37) = *p_m_info;
LABEL_132:
      if ( (v37 & 0xF8) != 40 )
        goto LABEL_187;
LABEL_133:
      this->m_cHorn = 0;
      return v38;
    case 0xAu:
      LOBYTE(v38) = 0;
      *(_DWORD *)p_m_nVehicleFlags &= ~0x20u;
      m_pTowingVehicle = this->m_pTowingVehicle;
      this->m_fGasPedal = 0.0;
      this->m_fBrakePedal = 0.0;
      this->m_fSteerAngle = 0.0;
      if ( m_pTowingVehicle )
        return v38;
      (*((void (__fastcall **)(CAutomobile *))this->_vptr$CPlaceable + 63))(this);
      goto LABEL_187;
    default:
      return v38;
  }
  return v38;
}
// 558666: variable 'v5' is possibly undefined
// 558666: variable 'v3' is possibly undefined
// 5586B8: variable 'v4' is possibly undefined
// 5586C0: variable 'v2' is possibly undefined
// 558934: using guessed type int dword_558934;
// 558938: using guessed type int;

//----- (005589A4) --------------------------------------------------------
void __fastcall CAutomobile::ScanForCrimes(CAutomobile *this)
{
  CVehicle *PlayerVehicle; // r0
  int CarAlarmState; // r1
  bool v4; // zf
  CVehicle *v5; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v7; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1

  if ( FindPlayerVehicle(-1, 0) && !FindPlayerVehicle(-1, 0)->m_baseVehicleType )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    CarAlarmState = PlayerVehicle->CarAlarmState;
    v4 = CarAlarmState == 0;
    if ( PlayerVehicle->CarAlarmState )
      v4 = CarAlarmState == 0xFFFF;
    if ( !v4 && (*(_BYTE *)&PlayerVehicle->m_info & 0xF8) != 40 )
    {
      v5 = FindPlayerVehicle(-1, 0);
      m_pMat = v5->m_pMat;
      v7 = this->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v5->m_transform;
      p_m_transform = (CSimpleTransform *)&v7->tx;
      if ( !v7 )
        p_m_transform = &this->m_transform;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      if ( (float)((float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                                 * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                         + *(float *)&v11)
                 + *((float *)&v11 + 1)) < 400.0 )
        sub_190E14(CWorld::Players[CWorld::PlayerInFocus].pPed, 1);
    }
  }
}

//----- (00558A7C) --------------------------------------------------------
bool16 __fastcall CAutomobile::RcbanditCheckHitWheels(const CAutomobile *this)
{
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  float y; // s4
  float v4; // s20
  float v5; // s24
  float v6; // r5
  float v7; // s16
  int v8; // r11
  float v9; // s2
  int v10; // r5
  int v11; // r6
  int v12; // r9
  uint16 v13; // r0
  int v15; // r8
  int v17; // [sp+4h] [bp-54h]
  int v18; // [sp+8h] [bp-50h]

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  y = p_tx->m_translate.y;
  v4 = p_tx->m_translate.x + 2.0;
  v5 = floorf((float)((float)(p_tx->m_translate.x + -2.0) / 50.0) + 60.0);
  v6 = floorf((float)((float)(y + -2.0) / 50.0) + 60.0);
  v7 = floorf((float)(v4 / 50.0) + 60.0);
  v8 = 119;
  v9 = v6;
  v10 = 0;
  v11 = (int)floorf((float)((float)(y + 2.0) / 50.0) + 60.0);
  v12 = (int)v9;
  if ( v11 >= 119 )
    v11 = 119;
  if ( (int)v7 < 119 )
    v8 = (int)v7;
  if ( v12 <= 0 )
    v12 = 0;
  if ( (int)v5 > 0 )
    v10 = (int)v5;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v13 = 1;
  }
  else
  {
    v13 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v13;
  if ( v12 > v11 )
    return 0;
  v17 = v10 - 1;
  v18 = v10;
  while ( v10 > v8 )
  {
LABEL_21:
    v10 = v18;
    if ( v12++ >= v11 )
      return 0;
  }
  v15 = v17;
  while ( !CAutomobile::RcbanditCheck1CarWheels(
             this,
             (CPtrList *)&CWorld::ms_aRepeatSectors[++v15 & 0xF | (unsigned __int8)(16 * v12)]) )
  {
    if ( v15 >= v8 )
      goto LABEL_21;
  }
  return 1;
}

//----- (00558BF4) --------------------------------------------------------
void __fastcall CAutomobile::DoSoftGroundResistance(CAutomobile *this, uint32 *nProcContFlags)
{
  float *m_aWheelRatios; // r6
  int m_nModelIndex; // r0
  bool v6; // zf
  int v7; // r0
  bool v8; // zf
  CMatrix *v9; // r0
  float v10; // s0
  float v11; // s2
  float v12; // s6
  float v13; // s8
  float v14; // s10
  float v15; // s4
  float v16; // s12
  float v17; // s6
  float v18; // s8
  float v19; // s10
  float v20; // s12
  CMatrix *m_pMat; // r0
  float x; // s2
  float y; // s0
  float xz; // s4
  float yz; // s8
  float z; // s6
  float zz; // s10
  float v28; // s12
  float v29; // s4
  float v30; // s0
  float v31; // s2
  float v32; // s6
  float v33; // s6
  float v34; // s10
  float v35; // s8
  float v36; // s6
  uint32 hFlagsLocal; // r0
  float v38; // s8
  float v39; // s6
  CVector v40; // 0:r1.12
  CVector v41; // 0:r1.12

  m_aWheelRatios = this->m_aWheelRatios;
  if ( (this->m_aWheelRatios[0] >= 1.0
     || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[0].m_dataB.m_nSurfaceType) != 4)
    && (this->m_aWheelRatios[1] >= 1.0
     || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[1].m_dataB.m_nSurfaceType) != 4)
    && (this->m_aWheelRatios[2] >= 1.0
     || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[2].m_dataB.m_nSurfaceType) != 4)
    && (this->m_aWheelRatios[3] >= 1.0
     || SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_aWheelColPoints[3].m_dataB.m_nSurfaceType) != 4) )
  {
    goto LABEL_20;
  }
  m_nModelIndex = this->m_nModelIndex;
  v6 = m_nModelIndex == 432;
  if ( m_nModelIndex != 432 )
    v6 = m_nModelIndex == 441;
  if ( !v6 )
  {
    m_pMat = this->m_pMat;
    x = this->m_vecMoveSpeed.x;
    y = this->m_vecMoveSpeed.y;
    xz = m_pMat->xz;
    yz = m_pMat->yz;
    z = this->m_vecMoveSpeed.z;
    zz = m_pMat->zz;
    v28 = (float)((float)(x * xz) + (float)(y * yz)) + (float)(z * zz);
    v29 = x - (float)(xz * v28);
    v30 = y - (float)(yz * v28);
    v31 = z - (float)(zz * v28);
    v32 = (float)(v31 * v31) + (float)((float)(v29 * v29) + (float)(v30 * v30));
    if ( v32 <= 0.09 )
    {
      v36 = 0.005;
      *(_BYTE *)&this->m_nAutomobileFlags |= 0x40u;
    }
    else
    {
      v33 = sqrtf(v32);
      v34 = 1.0 / v33;
      v35 = (float)(v33 * -2.0) + 1.0;
      v36 = v35 * 0.005;
      v31 = (float)(v31 * 0.3) * v34;
      v30 = (float)(v30 * 0.3) * v34;
      v29 = (float)(v29 * 0.3) * v34;
      if ( v35 < 0.2 )
        v36 = 0.001;
    }
    hFlagsLocal = this->hFlagsLocal;
    if ( (hFlagsLocal & 0x200000) != 0 )
    {
      v38 = v36 * 0.3;
    }
    else
    {
      v38 = v36 * 0.6;
      if ( (hFlagsLocal & 0x100000) == 0 )
        v38 = v36;
    }
    if ( CWeather::WetRoads > 0.2 )
      v38 = v38 * (float)(1.2 - CWeather::WetRoads);
    v39 = CTimer::ms_fTimeStep * (float)(this->m_fMass * v38);
    v41.x = -(float)(v39 * v29);
    v41.y = -(float)(v39 * v30);
    v41.z = -(float)(v39 * v31);
    CPhysical::ApplyMoveForce(this, v41);
    *nProcContFlags |= 8u;
  }
  else
  {
LABEL_20:
    if ( *m_aWheelRatios < 1.0 && this->m_aWheelColPoints[0].m_dataB.m_nSurfaceType == 178
      || this->m_aWheelRatios[1] < 1.0 && this->m_aWheelColPoints[1].m_dataB.m_nSurfaceType == 178
      || this->m_aWheelRatios[2] < 1.0 && this->m_aWheelColPoints[2].m_dataB.m_nSurfaceType == 178
      || this->m_aWheelRatios[3] < 1.0 && this->m_aWheelColPoints[3].m_dataB.m_nSurfaceType == 178 )
    {
      v7 = this->m_nModelIndex;
      v8 = v7 == 432;
      if ( v7 != 432 )
        v8 = v7 == 441;
      if ( !v8 )
      {
        v9 = this->m_pMat;
        v10 = this->m_vecMoveSpeed.x;
        v11 = this->m_vecMoveSpeed.y;
        v12 = v9->xz;
        v13 = v9->yz;
        v14 = v9->zz;
        v15 = this->m_vecMoveSpeed.z;
        v16 = (float)((float)(v10 * v12) + (float)(v11 * v13)) + (float)(v15 * v14);
        v17 = v12 * v16;
        v18 = v13 * v16;
        v19 = v14 * v16;
        v20 = (float)(CVehicle::ms_fRailTrackResistance * this->m_fMass) * CTimer::ms_fTimeStep;
        v40.x = -(float)(v20 * (float)(v10 - v17));
        v40.y = -(float)(v20 * (float)(v11 - v18));
        v40.z = -(float)(v20 * (float)(v15 - v19));
        sub_1932F0(this, v40);
      }
    }
  }
}

//----- (00558F50) --------------------------------------------------------
void __fastcall CAutomobile::PlayHornIfNecessary(CAutomobile *this)
{
  if ( *((unsigned __int8 *)&this->AutoPilot + 75) << 30 )
  {
    if ( !CAutomobile::HasCarStoppedBecauseOfLight(this) )
      (*((void (__fastcall **)(CAutomobile *))this->_vptr$CPlaceable + 55))(this);
  }
}

//----- (00558F78) --------------------------------------------------------
void __fastcall CAutomobile::ProcessControlCollisionCheck(CAutomobile *this, bool bDoMovement)
{
  _BOOL4 v3; // r5
  CEntity::CFlags *p_m_nFlags; // r8
  __int64 v5; // d16
  __int64 v6; // d17
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  int v8; // r6
  int v9; // r5
  CMatrix v10; // [sp+0h] [bp-58h] BYREF

  v3 = bDoMovement;
  CMatrix::CMatrix(&v10, this->m_pMat);
  p_m_nFlags = &this->m_nFlags;
  *(_DWORD *)&this->m_nFlags &= ~0x10u;
  CPhysical::SkipPhysics(this);
  *(float *)&v5 = 1.0;
  *((float *)&v5 + 1) = 1.0;
  *(float *)&v6 = 1.0;
  *((float *)&v6 + 1) = 1.0;
  *(_QWORD *)this->m_aWheelRatios = v5;
  *(_QWORD *)&this->m_aWheelRatios[2] = v6;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  this->m_fTrueDistanceTravelled = 0.0;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xFFFF6FFF);
  if ( v3 )
  {
    CPhysical::ApplyMoveSpeed(this);
    CPhysical::ApplyTurnSpeed(this);
    if ( CPhysical::CheckCollision(this) )
    {
      v8 = 0;
      do
      {
        CMatrix::operator=(this->m_pMat, &v10);
        CPhysical::ApplyMoveSpeed(this);
        CPhysical::ApplyTurnSpeed(this);
        if ( !CPhysical::CheckCollision(this) )
          break;
        ++v8;
      }
      while ( (unsigned __int16)v8 < 5u );
    }
  }
  else
  {
    v9 = *(_DWORD *)p_m_nFlags;
    *(_DWORD *)p_m_nFlags &= ~1u;
    CPhysical::CheckCollision(this);
    *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFFE | v9 & 1;
  }
  *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFCF | 0x20;
  CMatrix::~CMatrix(&v10);
}

//----- (0055903E) --------------------------------------------------------
void __fastcall CAutomobile::Teleport(CAutomobile *this, CVector NewCoors, int bClearOrientation)
{
  RwReal z; // r8
  float y; // r6
  RwReal x; // r5
  CMatrix *m_pMat; // r1
  float *p_tz; // r1
  CMatrix *v9; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v13; // r0
  float v14; // s2
  float v15; // s4
  int (**v16)(void); // r0

  z = NewCoors.z;
  y = NewCoors.y;
  x = NewCoors.x;
  CWorld::Remove(this);
  m_pMat = this->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = x;
    this->m_pMat->ty = y;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = x;
    this->m_transform.m_translate.y = y;
  }
  *p_tz = z;
  if ( bClearOrientation )
  {
    v9 = this->m_pMat;
    if ( v9 )
    {
      tx = v9->tx;
      ty = v9->ty;
      tz = v9->tz;
      CMatrix::SetRotate(v9, 0.0, 0.0, 0.0);
      v13 = this->m_pMat;
      v14 = ty + v13->ty;
      v15 = tz + v13->tz;
      v13->tx = tx + v13->tx;
      v13->ty = v14;
      v13->tz = v15;
    }
    else
    {
      this->m_transform.m_heading = 0.0;
    }
  }
  this->m_vecTurnSpeed.y = 0.0;
  this->m_vecTurnSpeed.z = 0.0;
  v16 = this->_vptr$CPlaceable;
  *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
  ((void (__fastcall *)(CAutomobile *))v16[68])(this);
  sub_19B3E4(this);
}

//----- (005590EC) --------------------------------------------------------
void __fastcall CAutomobile::ProcessSwingingDoor(CAutomobile *this, int32 index, eDoors DoorID)
{
  CDamageManager *p_Damage; // r8
  int (***v6)(void); // r5
  unsigned __int8 DoorStatus; // r9
  int (**v8)(void); // r0
  int v9; // r6
  float v10; // r0
  CPlaceable *v11; // r5
  bool v12; // zf
  bool v13; // cc
  unsigned int m_info; // r1
  bool v15; // zf
  CPhysical *v16; // r5
  char v17; // r0
  CMatrix *m_pMat; // r1
  float v19; // s4
  float v20; // s2
  float v21; // s0
  float v22; // s8
  float v23; // s10
  float v24; // s6
  float v25; // s0
  float v26; // s2
  float v27; // s4
  float v28; // s12
  float v29; // s10
  CMatrix *v30; // r0
  CVector v31; // [sp+Ch] [bp-F4h] BYREF
  float v32; // [sp+18h] [bp-E8h]
  float v33; // [sp+1Ch] [bp-E4h]
  float v34; // [sp+20h] [bp-E0h]
  CVector v35; // [sp+28h] [bp-D8h] BYREF
  CMatrix vecOffset; // [sp+38h] [bp-C8h] BYREF
  CVector v; // [sp+80h] [bp-80h] BYREF
  CMatrix v38; // [sp+90h] [bp-70h] BYREF
  CVector v39; // 0:r1.12

  p_Damage = &this->Damage;
  v6 = &this->_vptr$CPlaceable + index;
  DoorStatus = CDamageManager::GetDoorStatus(&this->Damage, DoorID);
  v8 = v6[407];
  if ( v8 )
  {
    v9 = DoorStatus | 2;
    if ( v9 == 3 )
      goto LABEL_3;
    if ( DoorStatus <= 2u )
    {
      v13 = DoorID <= BOOT_0;
      if ( DoorID >= BOOT_0 )
        v13 = this->m_fDamageImpulseMagnitude <= 100.0;
      if ( !v13 )
      {
        m_info = (unsigned __int8)this->m_info;
        v15 = m_info >> 3 == 3;
        if ( m_info >> 3 != 3 )
          v15 = m_info >> 3 == 0;
        if ( v15 )
        {
LABEL_3:
          CMatrix::CMatrix(&v38, (RwMatrix *)(v8 + 4), 0);
          v = *(CVector *)&v38.tx;
          if ( v9 == 2 )
          {
            if ( CVehicle::CanDoorsBeDamaged(this) )
            {
              Multiply3x3((CVector *)&vecOffset, this->m_pMat, &v);
              if ( CDoor::ProcessImpact(
                     &this->Door[DoorID],
                     this,
                     &this->m_vecOldMoveSpeed,
                     &this->m_vecOldTurnSpeed,
                     (CVector *)&vecOffset) )
              {
                CDamageManager::SetDoorStatus(p_Damage, DoorID, ++DoorStatus);
              }
            }
          }
          if ( (DoorStatus | 2) == 3 )
          {
            CMatrix::CMatrix(&vecOffset, (RwMatrix *)(v6[407] + 4), 0);
            v35 = *(CVector *)&vecOffset.tx;
            v32 = 0.0;
            v33 = 0.0;
            v34 = 0.0;
            if ( DoorID == BONNET_0 && (this->Door[0].m_nDirn & 0xF) == 1 )
            {
              v10 = sinf(this->Door[0].m_fAngle);
              this->Door[0].m_fAngVel = this->Door[0].m_fAngVel
                                      + (float)((float)((float)((float)(this->m_pMat->xy
                                                                      * (float)((float)(v10 + 0.1) * 0.05))
                                                              * this->m_vecMoveSpeed.x)
                                                      + (float)((float)((float)((float)(v10 + 0.1) * 0.05)
                                                                      * this->m_pMat->yy)
                                                              * this->m_vecMoveSpeed.y))
                                              + (float)((float)((float)((float)(v10 + 0.1) * 0.05) * this->m_pMat->zy)
                                                      * this->m_vecMoveSpeed.z));
            }
            Multiply3x3(&v31, this->m_pMat, &v35);
            v11 = (CAutomobile *)((char *)this + 24 * DoorID);
            if ( CDoor::Process(
                   (CDoor *)&v11[61].m_pMat,
                   this,
                   &this->m_vecOldMoveSpeed,
                   &this->m_vecOldTurnSpeed,
                   &v31) )
            {
              CDamageManager::SetDoorStatus(p_Damage, DoorID, (unsigned __int8)(DoorStatus - 1));
              CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, DoorID + 84, 0.0);
            }
            *(&v32 + BYTE2(v11[62].m_transform.m_translate.x)) = v11[62].m_transform.m_translate.y;
            CMatrix::SetRotate(&vecOffset, v32, v33, v34);
            vecOffset.tx = v35.x + vecOffset.tx;
            vecOffset.ty = v35.y + vecOffset.ty;
            vecOffset.tz = v35.z + vecOffset.tz;
            CMatrix::UpdateRW(&vecOffset);
            v12 = DoorID == BONNET_0;
            if ( DoorID == BONNET_0 )
              v12 = this->Door[0].m_nDoorState == 1;
            if ( v12
              && (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_pMat->xy)
                               + (float)(this->m_vecMoveSpeed.y * this->m_pMat->yy))
                       + (float)(this->m_vecMoveSpeed.z * this->m_pMat->zy)) > 0.4 )
            {
              v16 = CAutomobile::SpawnFlyingComponent(this, 16, 2u);
              CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 93, v16);
              CVehicle::SetComponentVisibility(this, this->m_aCarNodes[16], 0);
              CDamageManager::SetDoorStatus(p_Damage, BONNET_0, 4u);
              if ( v16 )
              {
                v17 = rand();
                m_pMat = this->m_pMat;
                v19 = this->m_vecMoveSpeed.x * 0.4;
                v20 = this->m_vecMoveSpeed.y * 0.4;
                v21 = this->m_vecMoveSpeed.z * 0.4;
                v22 = m_pMat->yx * 0.1;
                v23 = m_pMat->zx * 0.1;
                v24 = m_pMat->xx * 0.1;
                if ( (v17 & 1) != 0 )
                {
                  v25 = v21 + v23;
                  v26 = v20 + v22;
                  v27 = v19 + v24;
                }
                else
                {
                  v25 = v21 - v23;
                  v26 = v20 - v22;
                  v27 = v19 - v24;
                }
                v28 = m_pMat->zz * 0.5;
                v29 = m_pMat->yz * 0.5;
                v16->m_vecMoveSpeed.x = v27 + (float)(m_pMat->xz * 0.5);
                v16->m_vecMoveSpeed.y = v26 + v29;
                v16->m_vecMoveSpeed.z = v25 + v28;
                v30 = this->m_pMat;
                v39.x = v30->xz * 10.0;
                v39.y = v30->yz * 10.0;
                v39.z = v30->zz * 10.0;
                CPhysical::ApplyTurnForce(v16, v39, *(CVector *)&v30->xy);
              }
            }
            CMatrix::~CMatrix(&vecOffset);
          }
          CMatrix::~CMatrix(&v38);
        }
      }
    }
  }
}

//----- (00559478) --------------------------------------------------------
CPhysical *__fastcall CAutomobile::RemoveBonnetInPedCollision(CAutomobile *this)
{
  CPhysical *v2; // r6

  if ( !this->m_aCarNodes[16] )
    return 0;
  if ( CDamageManager::GetDoorStatus(&this->Damage, BONNET_0) == 1
    || (v2 = 0, CDamageManager::GetDoorStatus(&this->Damage, BONNET_0) == 3) )
  {
    if ( this->Door[0].m_fAngle > (float)(this->Door[0].m_fOpenAngle * 0.4) )
    {
      v2 = CAutomobile::SpawnFlyingComponent(this, 16, 2u);
      CAEVehicleAudioEntity::AddAudioEvent(&this->m_VehicleAudioEntity, 93, v2);
      CVehicle::SetComponentVisibility(this, this->m_aCarNodes[16], 0);
      CDamageManager::SetDoorStatus(&this->Damage, BONNET_0, 4u);
      return v2;
    }
    return 0;
  }
  return v2;
}

//----- (00559508) --------------------------------------------------------
void __fastcall CAutomobile::ResetSuspension(CAutomobile *this)
{
  __int64 v1; // d16
  __int64 v2; // d17
  float *m_aWheelPitchAngles; // r1
  tWheelState *m_aWheelState; // r0

  *(float *)&v1 = 1.0;
  *((float *)&v1 + 1) = 1.0;
  *(float *)&v2 = 1.0;
  *((float *)&v2 + 1) = 1.0;
  *(_QWORD *)this->m_aWheelCounts = 0LL;
  *(_QWORD *)&this->m_aWheelCounts[2] = 0LL;
  *(_QWORD *)this->m_aWheelRatios = v1;
  *(_QWORD *)&this->m_aWheelRatios[2] = v2;
  m_aWheelPitchAngles = this->m_aWheelPitchAngles;
  m_aWheelState = this->m_aWheelState;
  *(_QWORD *)m_aWheelPitchAngles = 0LL;
  *((_QWORD *)m_aWheelPitchAngles + 1) = 0LL;
  *(_QWORD *)m_aWheelState = 0LL;
  *((_QWORD *)m_aWheelState + 1) = 0LL;
}

//----- (00559534) --------------------------------------------------------
void __fastcall CAutomobile::UpdateWheelMatrix(CAutomobile *this, int32 nWheelIndex, int32 nOptionFlags)
{
  int (***v5)(void); // r6
  char *v7; // r0
  uint32 hFlagsLocal; // r1
  float v9; // s16
  int v10; // r11
  unsigned int v11; // r6
  uint32 v12; // r1
  float m_fSteerAngle; // s22
  _BOOL4 v14; // r10
  CBaseModelInfo *v15; // r5
  float *v16; // r8
  float tx; // s18
  float ty; // s20
  float v19; // s2
  float v20; // s0
  float m_wheelScale; // s2
  float v22; // s4
  int m_nModelIndex; // r0
  bool v24; // zf
  float v25; // r9
  float v26; // s6
  float v27; // s4
  uint32 v28; // r1
  float v29; // s4
  bool v30; // nf
  uint32 v31; // r1
  float v32; // s4
  float v33; // r3
  float v34; // r1
  uint32 WheelStatus; // r0
  float v36; // s0
  float v37; // s2
  uint32 mFlags; // r0
  int v39; // r1
  bool v40; // zf
  int v41; // r2
  int v42; // r1
  float v43; // s2
  float v44; // r0
  float v45; // r1
  char *v46; // r6
  __int64 v47; // d16
  CMatrix *m_pMat; // r0
  RwReal v49; // s2
  RwReal v50; // s4
  float v51; // s16
  FxSystem_c *m_fxSysSmokeHuge; // r0
  float *p_m_n2dEffects; // r6
  float v54; // s0
  float v55; // s4
  float v56; // s0
  float v57; // s8
  float v58; // s10
  FxPrtMult_c *v59; // r0
  float v60; // s4
  float v61; // s0
  float v62; // s8
  float v63; // s10
  int32 v64; // [sp+14h] [bp-ECh]
  int v65; // [sp+18h] [bp-E8h]
  CBaseModelInfo *v66; // [sp+1Ch] [bp-E4h]
  FxPrtMult_c v67; // [sp+20h] [bp-E0h] BYREF
  RwV3d_0 vel; // [sp+3Ch] [bp-C4h] BYREF
  RwV3d_0 pos; // [sp+48h] [bp-B8h] BYREF
  FxPrtMult_c v70; // [sp+58h] [bp-A8h] BYREF
  CRGBA v71; // [sp+74h] [bp-8Ch] BYREF
  CMatrix v72; // [sp+78h] [bp-88h] BYREF

  v5 = &this->_vptr$CPlaceable + nWheelIndex;
  if ( !v5[407] )
    return;
  v72.m_pRwMat = 0;
  v72.m_owner = 0;
  v66 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  CRGBA::CRGBA(&v71, 0xFFu, 0xFFu, 0xFFu, 0x20u);
  v7 = (char *)(v5 + 407);
  v64 = nOptionFlags;
  switch ( nWheelIndex )
  {
    case 2:
      v9 = 1.0;
      if ( (this->hFlagsLocal & 0x20) == 0 )
      {
        v65 = 1;
        v10 = 0;
        m_fSteerAngle = this->m_fSteerAngle;
        v11 = 2;
        goto LABEL_18;
      }
      v10 = 0;
      v65 = 1;
      v11 = 2;
      goto LABEL_31;
    case 3:
    case 4:
      hFlagsLocal = this->hFlagsLocal;
      if ( (hFlagsLocal & 0x20) != 0 )
      {
        v9 = 1.0;
        v10 = 1;
        v11 = 3;
        v65 = 0;
        m_fSteerAngle = -this->m_fSteerAngle;
      }
      else
      {
        v9 = 1.0;
        if ( (hFlagsLocal & 0x40) == 0 )
        {
          v10 = 1;
          v11 = 3;
          v65 = 0;
          goto LABEL_31;
        }
        v65 = 0;
        v10 = 1;
        m_fSteerAngle = this->m_f2ndSteerAngle;
        v11 = 3;
      }
      goto LABEL_18;
    case 5:
      v9 = -1.0;
      if ( (this->hFlagsLocal & 0x20) == 0 )
      {
        v65 = 1;
        v11 = 0;
        m_fSteerAngle = this->m_fSteerAngle;
        v10 = 0;
        goto LABEL_18;
      }
      v11 = 0;
      v65 = 1;
      v10 = 0;
      goto LABEL_31;
    case 6:
    case 7:
      v12 = this->hFlagsLocal;
      if ( (v12 & 0x20) != 0 )
      {
        v9 = -1.0;
        v65 = 0;
        m_fSteerAngle = -this->m_fSteerAngle;
      }
      else
      {
        v9 = -1.0;
        if ( (v12 & 0x40) == 0 )
        {
          v11 = 1;
          v65 = 0;
          v10 = 1;
LABEL_31:
          v15 = v66;
          v14 = v9 < 0.0;
          goto LABEL_32;
        }
        v65 = 0;
        m_fSteerAngle = this->m_f2ndSteerAngle;
      }
      v11 = 1;
      v10 = 1;
LABEL_18:
      v14 = v9 < 0.0;
      if ( (nOptionFlags & 2) == 0 && m_fSteerAngle != 0.0 )
      {
        if ( v9 >= 0.0 )
        {
          if ( v10 == 1 )
          {
            v10 = 1;
            v14 = 0;
            if ( m_fSteerAngle < 0.0 )
              m_fSteerAngle = m_fSteerAngle * 0.6;
          }
          else
          {
            v14 = 0;
            v10 = 0;
            if ( m_fSteerAngle > 0.0 )
              m_fSteerAngle = m_fSteerAngle * 0.6;
          }
          v15 = v66;
          goto LABEL_34;
        }
        if ( v10 == 1 )
        {
          if ( m_fSteerAngle <= 0.0 )
            goto LABEL_78;
        }
        else if ( m_fSteerAngle >= 0.0 )
        {
LABEL_78:
          v14 = 1;
          v15 = v66;
          m_fSteerAngle = m_fSteerAngle + 3.1416;
          goto LABEL_34;
        }
        m_fSteerAngle = m_fSteerAngle * 0.6;
        goto LABEL_78;
      }
      v15 = v66;
LABEL_32:
      m_fSteerAngle = 0.0;
      if ( v14 )
        m_fSteerAngle = 3.1416;
LABEL_34:
      CMatrix::Attach(&v72, (RwMatrix *)(*(_DWORD *)v7 + 16), 0);
      v16 = (float *)(&this->_vptr$CPlaceable + v11);
      tx = v72.tx;
      ty = v72.ty;
      if ( v15[1].m_flags == 0xFFFF )
      {
        m_wheelScale = this->m_wheelScale;
        v22 = *(float *)&v15[1].m_txdIndex;
        if ( v10 )
          v20 = m_wheelScale * (float)(*(float *)&v15[1].m_n2dEffects / v22);
        else
          v20 = this->m_wheelScale;
        v19 = v22 / (float)(m_wheelScale * 0.7);
      }
      else
      {
        v19 = 1.0;
        if ( v10 == 1 )
          v20 = *(float *)&v15[1].m_n2dEffects;
        else
          v20 = *(float *)&v15[1].m_txdIndex;
      }
      m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
      if ( m_nModelIndex != 532 )
        goto LABEL_52;
      v24 = nWheelIndex == 6;
      if ( nWheelIndex != 6 )
        v24 = nWheelIndex == 3;
      if ( v24 )
      {
        v20 = 1.7 / *(float *)&v15[1].m_txdIndex;
        if ( v14 )
          m_fSteerAngle = m_fSteerAngle + -3.1416;
        m_fSteerAngle = m_fSteerAngle * 0.5;
        v25 = (float)((float)(1.7 - *(float *)&v15[1].m_n2dEffects) * 0.45) + v16[531];
        if ( v14 )
          m_fSteerAngle = m_fSteerAngle + 3.1416;
      }
      else
      {
LABEL_52:
        v26 = m_fSteerAngle;
        if ( m_nModelIndex == 513 )
          v26 = 0.0;
        if ( nWheelIndex == 5 )
          m_fSteerAngle = v26;
        v25 = v16[531];
      }
      if ( (unsigned int)(this->m_vehicleType - 1) < 2 )
      {
        v27 = 1.0;
        goto LABEL_85;
      }
      if ( v10 == 1 )
      {
        v28 = this->hFlagsLocal;
        if ( (v28 & 0xF000) != 0 )
        {
          if ( (v28 & 0x1000) == 0 )
          {
            if ( (v28 & 0x2000) == 0 )
            {
              if ( (v28 & 0x4000) == 0 )
              {
                v29 = 1.25;
                v30 = (this->hFlagsLocal & 0x8000) != 0;
                goto LABEL_71;
              }
              goto LABEL_83;
            }
            goto LABEL_82;
          }
LABEL_75:
          v32 = 0.65;
LABEL_84:
          v27 = v19 * v32;
          goto LABEL_85;
        }
      }
      if ( v65 != 1 || (v31 = this->hFlagsLocal, (v31 & 0xF00) == 0) )
      {
        v27 = v19;
        goto LABEL_85;
      }
      if ( (v31 & 0x100) != 0 )
        goto LABEL_75;
      if ( (v31 & 0x200) != 0 )
      {
LABEL_82:
        v32 = 0.8;
        goto LABEL_84;
      }
      if ( (v31 & 0x400) != 0 )
      {
LABEL_83:
        v32 = 1.1;
        goto LABEL_84;
      }
      v29 = 1.25;
      v30 = (this->hFlagsLocal & 0x800) != 0;
LABEL_71:
      v27 = v19 * v29;
      if ( !v30 )
        v27 = v19;
LABEL_85:
      if ( 